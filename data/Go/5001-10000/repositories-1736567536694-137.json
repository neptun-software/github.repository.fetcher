{
  "metadata": {
    "timestamp": 1736567536694,
    "page": 137,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "0voice/Introduction-to-Golang",
      "stars": 7793,
      "defaultBranch": "main",
      "files": [
        {
          "name": "Go 语言参考手册.md",
          "type": "blob",
          "size": 125.46875,
          "content": "## 介绍\n\n\n\n这是一个 Go 语言的参考手册，你也可以访问[golang.org](https://golang.org/)获取更多信息和其他文档。\n\nGo 是在设计时考虑了系统编程的通用型编程语言。它是强类型，有垃圾回收机制并原生支持并发编程。Go 程序由一个或多个 package 组成，这样可以高效的管理依赖。\n\nGo 的语法简洁且有规则，这让自动化工具可以很容易的分析代码，例如：集成开发环境。\n\n\n\n## 标记\n\n\n\n语法采用扩展巴科斯范式。\n\n\n\n```go\nProduction  = production_name \"=\" [ Expression ] \".\" .\nExpression  = Alternative { \"|\" Alternative } .\nAlternative = Term { Term } .\nTerm        = production_name | token [ \"…\" token ] | Group | Option | Repetition .\nGroup       = \"(\" Expression \")\" .\nOption      = \"[\" Expression \"]\" .\nRepetition  = \"{\" Expression \"}\" .\n```\n\n\n\n产生式是由词法单元和以下操作符构成的表达式（优先级依次递增）：\n\n\n\n```go\n|   或\n()  分组\n[]  可选 (出现 0 或 1 次)\n{}  可重复 (出现 0 到 n 次)\n```\n\n\n\n小写的产生式名称用来与词法单元区分。非终结符采用驼峰式。词法单元由双引号或反引号组成。\n\n\n\n`a...b` 表示从 `a` 到 `b` 之间的任意字符。省略号 `...` 也可以在规范中表示对更详细的枚举和代码片段的省略。字符 `...` 不是 Go 语言的词法单元。\n\n\n\n## 源码表示法\n\n\n\nGo 的源代码使用 UTF-8 编码的 Unicode 文本。不过它并不是完全规范化的，单重音的代码点与由相同字符和音标组成的代码点是不同的；前者我们认为它是两个代码点。简单来讲，文档会在源代码文本中使用非规范的术语字符来表示一个 Unicode 代码点。\n\n\n\n每个代码点都是不同的；相同字符的大写和小写形式表示不同的字符。\n\n\n\n实现限制：为了兼容其他工具，编译器不允许出现 Utf-8 编码的源文本中的 NUL 字符（U+0000）。\n\n\n\n实现限制：为了兼容其他工具，如果源文本中是以Utf-8 编码的字节序标记（U+FEFF）为起始代码点。编译器会忽略它。字节序标记不应出现在源文本的任何位置。\n\n\n\n#### 字符\n\n\n\n这些单词表示 Unicode 字符的类别：\n\n\n\n```go\nnewline        = /* Unicode 代码点 U+000A */ .\nunicode_char   = /* 排除换行以外的任意 Unicode 代码点 */ .\nunicode_letter = /* 一个字母（\"Letter\"）类型的 Unicode 代码点  */ .\nunicode_digit  = /* 一个数字（\"Number, decimal digit\"）类型的 Unicode 代码点  */ .\n```\n\n\n\n在 Unicode8.0 标准中，第 4.5 章节 “一般类别” 中定义了字符的类别。Go 能够处理任何字符集，包括 Lu，Li，Lt，Lm 或 Lo 作为 Unicode 字母，还可以把数字字符集 Nd 当作 Unicode 数字处理。\n\n\n\n#### 字母和数字\n\n\n\n我们认为下划线 `_` （U+005F）是一个字母：\n\n\n\n```go\nletter        = unicode_letter | \"_\" .\ndecimal_digit = \"0\" … \"9\" .\noctal_digit   = \"0\" … \"7\" .\nhex_digit     = \"0\" … \"9\" | \"A\" … \"F\" | \"a\" … \"f\" .\n```\n\n\n\n## 词汇元素\n\n\n\n#### 注释\n\n\n\n注释是程序的说明文档。在 Go 中有两种形式：\n\n\n\n- 单行注释从 `//` 开始直到行末结束。\n- 通用注释从 `/*` 开始直到 `*/` 结束。\n\n\n\n注释不能嵌套在其他注释、字符串和 rune 的字面值中。不包含换行符的通用注释之间通过空格符连接，其他情况下每段注释都会另起一行。\n\n\n\n#### 词汇元素\n\n\n\n词汇元素构成了 Go 语言的词汇表。它有四种类型：标识符、关键字、操作符/标点符号、字面值。空白符可以是空格（U+0020）、水平制表符（U+0009）、换行符（U+000D）或换行符（U+000A）。它本身会被忽略，一般用来区分不同的词汇元素。换行符或文件终止符（EOF）还可能触发编译程序在源代码的行末或文件末尾追加分号。在分解源代码的词汇元素的过程中，会把当前可以形成有效词汇元素的最长字符序列作为下一个词汇元素。\n\n\n\n#### 分号\n\n\n\n正规语法在很多产生式中使用分号 \";\" 作为终结符。Go 程序中遵循下面两条规则省略了大部分的分号：\n\n\n\n1. 当某行的最后一个词汇元素是以下元素时自动补全分号：\n\n- 一个标识符。\n- 一个整数，浮点数，虚数，rune 或字符串字面值。\n\n- 关键字 `break`、`continue`、`fallthrough` 和 `return` 其中之一。\n- 操作符/标点符号 `++`，`--`，`)`，`]` 和 `}` 其中之一。\n\n1. 为了支持独占一行的复杂语句，会省略与 \")\" 或 \"}\" 相邻的分号。\n\n\n\n为了反应惯用用途，本篇文档的所有例子都基于以上规则省略分号。\n\n\n\n#### 标识符\n\n\n\n标识符表示程序实体单元，例如：变量、类型。一个标识符由一个或多个字母和数字组成。标识符的首字符必须为字母。\n\n\n\n```go\nidentifier = letter { letter | unicode_digit } .\n```\n\n\n\n```go\na\n_x9\nThisVariableIsExported\nαβ\n```\n\n\n\nGo 已经预定义了一些标识符。\n\n\n\n#### 关键字\n\n\n\n以下关键字是预留的，它们不能作为标识符：\n\n\n\n```go\nbreak        default      func         interface    select\ncase         defer        go           map          struct\nchan         else         goto         package      switch\nconst        fallthrough  if           range        type\ncontinue     for          import       return       var\n```\n\n\n\n#### 操作符和标点符号\n\n\n\n以下字符序列用于表示操作符（包括赋值运算符）和标点符号：\n\n\n\n```go\n+    &     +=    &=     &&    ==    !=    (    )\n-    |     -=    |=     ||    <     <=    [    ]\n*    ^     *=    ^=     <-    >     >=    {    }\n/    <<    /=    <<=    ++    =     :=    ,    ;\n%    >>    %=    >>=    --    !     ...   .    :\n     &^          &^=\n```\n\n\n\n#### 整型字面值\n\n\n\n整型字面值是一个数字序列，相当于整型常量。可以使用前缀指定非小数进制：0 表示八进制，0x/0X 表示十六进制。在十六进制字面值中，字母 a-f 和 A-F 都表示数字 10-15。\n\n\n\n```go\nint_lit     = decimal_lit | octal_lit | hex_lit .\ndecimal_lit = ( \"1\" … \"9\" ) { decimal_digit } .\noctal_lit   = \"0\" { octal_digit } .\nhex_lit     = \"0\" ( \"x\" | \"X\" ) hex_digit { hex_digit } .\n```\n\n\n\n```go\n42\n0600\n0xBadFace\n170141183460469231731687303715884105727\n```\n\n\n\n#### 浮点字面值\n\n\n\n浮点字面值是一个小数，相当于浮点数常量。它由整数部分，小数点，小数部分和指数部分构成。整数部分和小数部分用小数点链接；指数部分由  `e` / `E` 字符后接一个有符号指数构成。整数部分和小数部分可以省略其一；小数点和指数部分可以省略其一。\n\n\n\n```go\nfloat_lit = decimals \".\" [ decimals ] [ exponent ] |\n            decimals exponent |\n            \".\" decimals [ exponent ] .\ndecimals  = decimal_digit { decimal_digit } .\nexponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals .\n```\n\n\n\n```go\n0.\n72.40\n072.40  // == 72.40\n2.71828\n1.e+0\n6.67428e-11\n1E6\n.25\n.12345E+5\n```\n\n\n\n#### 虚数字面值\n\n\n\n虚数字面值是一个小数，相当于复数常量中的虚数部分。它由浮点数或者整数后接小写字母 i 构成。\n\n\n\n```go\nimaginary_lit = (decimals | float_lit) \"i\" .\n```\n\n\n\n```go\n0i\n011i  // == 11i\n0.i\n2.71828i\n1.e+0i\n6.67428e-11i\n1E6i\n.25i\n.12345E+5i\n```\n\n\n\n#### Rune 字面值\n\n\n\nrune 类型字面值相当于一个 rune 常量。它是一个表示 Unicode 代码点的整数。rune 类型字面值表示为用单引号包裹的一个或多个字符，像 'x' 或 '\\n'。在单引号中除了换行符和未转义的单引号其他的字符都可以直接显示。单引号包裹的字符的值和字符在 Unicode 编码中的值相等，而以反斜线开头的多字符序列会把值翻译成多种格式。\n\n\n\n使用引号表示单字符是最简单的方式；因为 Go 的源文本是 UTF-8 编码，一个整数可能代表多个 UTF-8 字节。例如， 'a' 可以使用单字节表示字符 a，Unicode 编码 U+0061，值 0x61，而 'ä' 是两字节表示分音符的 a，Unicode 编码 U+00E4，值 0xe4。\n\n\n\n反斜线能将任意值编码成 ASCII 文本。有四种方式将整数值表示为数字常量：`\\x` 后接两个十六进制数；`\\u` 后接四个十六进制数；`\\U` 后接八个十六进制数。 `\\` 后接三个八进制数。每种情况下都使用相应进制来表示字面量的整数值。\n\n\n\n虽然这四种方式都以整数表示，但它们的有效区间并不相同。八进制只能表示 0 - 255 以内的整数。十六进制满可以满足需求。`\\u` 和 `\\U`  都可以表示 Unicode 代码点，不过其中的一些值是无效的，特别是 0x10FFFF 以上的值。\n\n\n\n反斜线结合以下字符具有特殊含义：\n\n\n\n```go\n\\a   U+0007 alert or bell\n\\b   U+0008 退格符\n\\f   U+000C form feed\n\\n   U+000A line feed or newline\n\\r   U+000D carriage return\n\\t   U+0009 水平制表符\n\\v   U+000b 垂直制表符\n\\\\   U+005c 反斜线\n\\'   U+0027 单引号  (只在 rune 字面值中有效)\n\\\"   U+0022 双引号  (只在字符串字面值中有效)\n```\n\n\n\n其他所有以反斜线开头的序列在 rune 的规则中都是非法的。\n\n\n\n```go\nrune_lit         = \"'\" ( unicode_value | byte_value ) \"'\" .\nunicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .\nbyte_value       = octal_byte_value | hex_byte_value .\noctal_byte_value = `\\` octal_digit octal_digit octal_digit .\nhex_byte_value   = `\\` \"x\" hex_digit hex_digit .\nlittle_u_value   = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit .\nbig_u_value      = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit\n                           hex_digit hex_digit hex_digit hex_digit .\nescaped_char     = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) .\n```\n\n\n\n```go\n'a'\n'ä'\n'本'\n'\\t'\n'\\000'\n'\\007'\n'\\377'\n'\\x07'\n'\\xff'\n'\\u12e4'\n'\\U00101234'\n'\\''         // 包含单引号的 rune 字面值\n'aa'         // 无效: 太多字符\n'\\xa'        // 无效: 缺少十六进制数\n'\\0'         // 无效: 缺少八进制数\n'\\uDFFF'     // 无效: surrogate half\n'\\U00110000' // 无效: 非法的 Unicode 代码点\n```\n\n\n\n#### 字符串字面量\n\n\n\n字符串字面量表示从字符序列中获取的字符串常量。它有两种格式：原始字符串字面量和解释型字符串字面量。\n\n\n\n原始字符串是由反引号包裹（`foo`）。字符串中除反引号以外的其他字符都会显示出来。原生字符串由反引号之间的（默认 UTF-8 编码）的字符组成。它的值为引号内未经解释（默认 UTF-8 编码）所有字符；尤其是，反斜线再字符串中没有特殊意义并且字符串中保留换行符。在原始字符串的值中会丢弃回车键返回 '\\r' 字符。\n\n\n\n解释型字符串由双引号之间的字符组成（\"bar\"）。除了换行符和双引号其他字符都会显示出来。双引号之间的文本组成字面量的值。反斜线的转义规则与 rune 字面量基本相同（不同的是 \\’ 非法，而 \\\" 合法）。三位八进制数（\\nnn）和两位十六进制数（\\xnn）换码符的值表示相应字符串的字节。其他的换码符都表示字符各自的 UTF-8 编码（可能是多字节）。因此字符串 \\377 和 \\xFF 都表示值为 0xFF=255 的单个字节，而  `ÿ`, `\\u00FF`, `\\U000000FF` 和 `\\xc3\\xbf` 表示 UTF-8 编码字符 U+00FF 的两个字节 0xc3 0xbf。\n\n\n\n```go\nstring_lit             = raw_string_lit | interpreted_string_lit .\nraw_string_lit         = \"`\" { unicode_char | newline } \"`\" .\ninterpreted_string_lit = `\"` { unicode_value | byte_value } `\"` .\n```\n\n\n\n```go\n`abc`                // 等价于 \"abc\"\n`\\n\n\\n`                  // 等价于 \"\\\\n\\n\\\\n\"\n\"\\n\"\n\"\\\"\"                 // 等价于 `\"`\n\"Hello, world!\\n\"\n\"日本語\"\n\"\\u65e5本\\U00008a9e\"\n\"\\xff\\u00FF\"\n\"\\uD800\"             // 无效: surrogate half\n\"\\U00110000\"         // 无效: 无效的 Unicode 代码点\n```\n\n\n\n这些例子都表示相同的字符串：\n\n\n\n```go\n\"日本語\"                                 // UTF-8 文本\n`日本語`                                 // UTF-8 文本作为原生字面值\n\"\\u65e5\\u672c\\u8a9e\"                    // 确定的 Unicode 代码点 \n\"\\U000065e5\\U0000672c\\U00008a9e\"        // 确定的 Unicode 代码点\n\"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\"  // 确定的 UTF-8 字节\n```\n\n\n\n如果源代码中使用两个代码点表示一个字符，例如带音标的字母，把它放在 rune 中会报错（它不是单代码点）。并且在字符串中会显示两个代码点。\n\n\n\n## 常量\n\n\n\n常量分为：布尔型，rune型，整型，浮点型，复数型，字符串型。其中 rune，整型，浮点型，复数型统称为数字常量。\n\n\n\n常量的值可以表示为一个 rune字面量，整数字面量，浮点数字面量，虚数字面量，字符串字面量，表示常量的标识符，常量表达式，一个转换结果为常量的类型转换，和一些返回值为常量的内置函数(接受任何值的`unsafe.Sizeof`，接受部分表达式的`cap` 或 `len`，接受虚数常量的`real` 和 `imag`，接受数字常量的 `complex`)。布尔类型的值为预定义常量 `true` 或 `false`，预定义的标识符 `iota` 表示一个整型常量。\n\n\n\n一般情况下复数常量是常量表达式的一种形式。会在常量表达式章节详细讨论。\n\n\n\n数字常量可以表示任意精度的确定值而且不会溢出。因此，没有常量可以表示非 0，无穷大和非数字值。\n\n\n\n常量可以指定类型也可以不指定类型。字面值常量，`true`，`false`，`iota`，和只包含无类型常量操作的常量表达式是无类型的。\n\n\n\n常量可以通过常量声明和转换时显式的指定具体类型，也可以隐式的在变量声明、赋值或作为表达式操作元时隐式的指定具体类型。如果常量的值和他的类型不匹配，会报错。\n\n\n\n无类型常量由一个默认的类型，这个类型会根据使用常量时的上下文进行隐式转换。例如：短变量声明 `i := 0` 没有指定 i 的类型。无类型常量的默认类型可以是：`bool`，`rune`，`int`，`float64`，`complex128` 或者 `string`，具体选择哪种类型由常量的值决定。\n\n\n\n实现限制：虽然数字常量在 Go 中是任意精度，不过编译器在实现时会在内部限制精度。这意味着每个编译器实现都要：\n\n\n\n- 至少保证整形常量有 256 位\n- 浮点数常量（包括复数常量）都要保证至少 256 位的主体部分和至少 16 位的有符号指数部分\n\n- 如果不能表示给定整数的精度抛出错误\n- 如果浮点数或复数溢出抛出错误\n\n- 如果由于精度限制不能表示浮点数或者复数进行舍入\n\n\n\n这些要求同时作用于字面量常量额和常量表达式的结果。\n\n\n\n## 变量\n\n\n\n变量是一个用来储存值的位置。根据不同的变量类型，可以保存不同的值。\n\n\n\n变量声明，函数参数和返回值，声明的函数签名，函数字面值都会为命名变量预留储存空间。调用内置的  `new`  函数或获取复合字面值的地址都会在运行时为变量分配存储空间。这种匿名变量是通过（可能是隐式的）指针间接引用的。\n\n\n\n像数组，切片和结构体类型的变量，它们内部都包含很多元素或字段，而且这些元素和字段都可以直接被访问。数组和切片中的每个元素的行为和单独的变量基本相同。\n\n\n\n变量的静态类型可以通过变量声明、提供给 `new` 的类型、复合字面值、结构体变量声明的元素类型以上几种方式确定。通过new或者类型初始化。接口类型的变量也有一个明确的动态类型，这个动态类型是在运行时赋值给变量的具体值类型（特例：预声明的 nil 是无类型的）。动态类型在程序的执行过程中可能并不相同，但是接口变量的值是可以分配给相同静态类型的变量。\n\n\n\n```go\nvar x interface{}  // x 的静态类型为 interface{} 值为 nil\nvar v *T           // v 的静态类型为 *T 值为 nil\nx = 42             // x 的动态类型为 int 值为 42\nx = v              // x 动态类型为 *T 值为 (*T)(nil)\n```\n\n\n\n在表达式中使用变量可以取出变量的值；这个值就是变量最近一次被赋予的值。如果没有对变量赋过值，那么他的值是该类型的零值。\n\n\n\n## 类型\n\n\n\n类型是一个集合，集合包括值和针对值的操作&方法。一个类型可以使用类型名来表示。类型有多种表现形式：如果存在类型名，可以使用类型名表示，或者也可以使用根据已有类型组合成的类型字面值。\n\n\n\n```go\nType      = TypeName | TypeLit | \"(\" Type \")\" .\nTypeName  = identifier | QualifiedIdent .\nTypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |\n\t    SliceType | MapType | ChannelType .\n```\n\n\n\nGo 已经预先声明了某些类型的名称。并引入了类型声明。复合类型（数组、结构体、指针、函数、接口、切片、map、channel）可以使用他们的类型字面值。\n\n\n\n每个类型T都有一个底层类型。如果T是预定义类型或者类型字面值。那么底层类型就是他自身。否则，T的底层类型就是它再类型声明时引用到的类型。\n\n\n\n```go\ntype (\n\tA1 = string\n\tA2 = A1\n)\n\ntype (\n\tB1 string\n\tB2 B1\n\tB3 []B1\n\tB4 B3\n)\n```\n\n\n\n`string`，`A1`，`A2`，`B1`，`B2` 的底层类型是 `string`。`[]B1`，`B3`，`B4` 的下游类型是[]B1。\n\n\n\n#### 方法集\n\n\n\n类型可能会有一个与之关联的方法集。接口类型的方法集就可以使用自身表示。对于其他类型，类型 T 的方法集由所有接收者类型为 T 的方法组成。而对应指针类型 *T 的方法集由所有接收者类型为 T 或 *T 的方法组成。如果是结构体类型且含有嵌入字段，那么方法集中可能还会包含更多的方法，具体请看结构体类型章节。其他类型的方法集都为空。方法集中的每个方法都有唯一且不为空的方法名。\n\n\n\n类型的方法集用来确定类型实现的接口和以类型作为接收者能够调用的方法。\n\n\n\n#### 布尔类型\n\n\n\n布尔类型表示预定义常量 `true` 和 `false` 表示布尔真实值的集合。预定义的布尔类型为 `bool`；它是通过类型声明创建的。\n\n\n\n#### 数字类型\n\n\n\n一个数字类型相当于整型和浮点型的所有值的集合。预定义的数字类型包括：\n\n\n\n```go\nuint8       8 位无符号整数集合 (0 to 255)\nuint16      16 位无符号整数集合 (0 to 65535)\nuint32      32 位无符号整数集合 (0 to 4294967295)\nuint64      64 位无符号整数集合 (0 to 18446744073709551615)\n\nint8        8 位有符号整数集合 (-128 to 127)\nint16       16 位有符号整数集合 (-32768 to 32767)\nint32       32 位有符号整数集合 (-2147483648 to 2147483647)\nint64       64 位有符号整数集合 (-9223372036854775808 to 9223372036854775807)\n\nfloat32     IEEE-754 32 位浮点数集合\nfloat64     IEEE-754 64 位浮点数集合\n\ncomplex64   实部虚部都为 float32 的复数集合\ncomplex128  实部虚部都为 float64 的复数集合\n\nbyte        uint8 的别名\nrune        int32 的别名\n```\n\n\n\nn 位整数的值具有 n 比特的宽度并用补码表示。\n\n\n\n以下几种预定义类型由具体平台实现指定长度：\n\n\n\n```go\nuint     32 或 64 位\nint      和 uint 位数相同\nuintptr  能够容纳指针值的无符号整数\n```\n\n\n\n为了避免移植性问题，除了被 uint8 的别名 byte 和 int32 的别名 rune，其他所有的数字类型都是通过类型声明定义。当在表达式中使用不同的数字类型需要进行类型转换。例如：int32 和 int 不是相同的类型，即使他们在指定的平台上是相等的。\n\n\n\n#### 字符串类型\n\n\n\n字符串类型表示字符串的值类型。字符串的值是一个字节序列（有可能为空）。字符串一旦创建就无法修改它的值。预定义的字符串类型是 `string`，它是通过类型声明定义的。\n\n\n\n可以使用内置函数 `len` 获取字符串长度。如果字符串是常量那么它的长度在编译时也为常量。可以通过数字下标 0～len(s)-1 访问字符串字节。获取字符串的地址是非法操作；如果 `s[i]` 是字符串的第 i 个字节，那么 `&s[i]` 是无效的。\n\n\n\n#### 数组类型\n\n\n\n数组是一定数量的单一类型元素序列，而这个单一类型叫做元素类型。元素的个数表示元素的长度，它永远不是负数。\n\n\n\n```go\nArrayType   = \"[\" ArrayLength \"]\" ElementType .\nArrayLength = Expression .\nElementType = Type .\n```\n\n\n\n长度是数组类型的一部分；它是一个类型为 int 的非负常量。可以用内置函数 `len` 获取数组的长度。元素可以通过下标 `0～len(a)-1` 访问。数组一般都是一维的，不过也可以是多维的。\n\n\n\n```go\n[32]byte\n[2*N] struct { x, y int32 }\n[1000]*float64\n[3][5]int\n[2][2][2]float64  // same as [2]([2]([2]float64))\n```\n\n\n\n#### 切片类型\n\n\n\n切片描述了底层数组的一个连续片段并提供对连续片段内元素的访问。切片类型表示元素类型的数组的所有切片的集合。没有被初始化的切片用 nil 表示。\n\n\n\n```go\nSliceType = \"[\" \"]\" ElementType .\n```\n\n\n\n与数组一样，切片的可以使用索引访问并且有长度，切片的长度可以通过内置的 `len` 函数获取；与数组不同的是它的长度在运行时是可以变化的。我们可以通过下标 `0～len(s)-1` 来访问切片内的元素。切片的索引可能会小于相同元素再底层数组的索引。\n\n\n\n切片一旦初始化，那么就有一个与之对应的底层数组保存切片中的元素。切片和底层的数组还有其他指向该数组的切片共享相同的储存空间；而不同的数组总是有着不同的存储空间。\n\n\n\n切片的底层数组可能会延伸到切片末尾以外，切片的容积等于切片现在的长度加上数组中切片还没使用的长度；可以从原始切片中切出一个长度与容量相等的切片。切片的容量可以通过内置的 `cap(a)` 函数来获取。可以通过函数`make`来创建一个T类型的新切片。\n\n\n\n使用内置函数 `make` 可以出实话给定元素类型 T 的切片。`make` 函数接收三个参数：切片类型、切片长度、切片容积，其中切片容积是可选参数。`make` 创建的切片会在底层分配一个切片所引用的新数组。\n\n\n\n```go\nmake([]T, length, capacity)\n```\n\n\n\n`make` 的作用就是创建新数组并切分它，所以下面两种写法是等价的：\n\n\n\n```go\nmake([]int, 50, 100)\nnew([100]int)[0:50]\n```\n\n\n\n与数组相同，切片一般是一维的，不过也可以复合成多维。数组中的数组都必须是相同的长度，但是切片中的切片长度是动态变化的，不过切片中的切片需要单独初始化。\n\n\n\n#### 结构体类型\n\n\n\n结构体是一个命名元素序列，命名元素也叫做字段，每个字段都对应一个名称和类型，字段的名字可以是显式指定的（标识符列表）也可以是隐式的（嵌入字段）。在结构体中非空字段具有唯一性。\n\n\n\n```go\nStructType    = \"struct\" \"{\" { FieldDecl \";\" } \"}\" .\nFieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .\nEmbeddedField = [ \"*\" ] TypeName .\nTag           = string_lit .\n```\n\n\n\n```go\n// 空结构体.\nstruct {}\n\n// 6个字段的结构体.\nstruct {\n\tx, y int\n\tu float32\n\t_ float32  // padding\n\tA *[]int\n\tF func()\n}\n```\n\n\n\n一个指定了类型而没有指定名称的字段叫做嵌入字段，嵌入字段必须指定类型名 T 或指向非接口类型的指针类型 *T，其中 T 不能为指针类型。或者一个非接口类型的指针。并且T本身不能为指针类型。这种情况下会把类型名作为字段的名字。\n\n\n\n```go\n// 一个包含 4 个嵌入字段 T1, *T2, P.T3 和 *P.T4 的结构体\nstruct {\n\tT1        // 字段名为 T1\n\t*T2       // 字段名为 T2\n\tP.T3      // 字段名为 T3\n\t*P.T4     // 字段名为 T4\n\tx, y int  // 字段名为 x 和 y\n}\n```\n\n\n\n以下声明是错误的因为字段名称必须唯一。\n\n\n\n```go\nstruct {\n\tT     // 嵌入字段 *T 与 *P.T 冲突\n\t*T    // 嵌入字段 T 与 *P.T 冲突\n\t*P.T  // 嵌入字段 T 与 *T 冲突\n}\n```\n\n\n\n如果 `x.f` 是表示该字段或方法 `f` 的合法选择器，则会调用结构 `x` 中嵌入字段的字段或方法 `f`。\n\n\n\n从嵌入字段组合来的字段与结构体原来的字段行为基本相同，只是不能在结构体的复合字面值中直接使用。\n\n\n\n给定一个结构体 S 和一个类型 T，依据以下规则生成组合后的方法集：\n\n\n\n- 如果 S 包含嵌入字段 T，则 S 和 *S 的方法集包括接收者为 T 的方法集，而 *S 包括 接收者为 *T 的方法集。\n- 如果 S 包含字段 *T。那么S和*S均包含接收者为 T 和 *T 的所有方法集。\n\n\n\n声明字段时可以给该字段添加一个字符串的 tag。这个 tag 将会成为它所对应字段的一个属性。空 tag 和缺省 tag 是相同的。tag 的值可以通过反射的接口获取，可以作为类型结构体的类型定义的一部分，也可以忽略。\n\n\n\n```go\nstruct {\n\tx, y float64 \"\"  // 空 tag 和缺省 tag 相同\n\tname string  \"any string is permitted as a tag\"\n\t_    [4]byte \"ceci n'est pas un champ de structure\"\n}\n\n// 结构体对应一个 TimeStamp 的 protocol buffer.\n// tag 字符串中定义了 protocol buffer 字段对应的数字;\n// 一般使用 reflect 包读取他们.\nstruct {\n\tmicrosec  uint64 `protobuf:\"1\"`\n\tserverIP6 uint64 `protobuf:\"2\"`\n}\n```\n\n\n\n#### 指针类型\n\n\n\n指针类型表示所有指向给定类型变量的指针集合。这个指定的类型叫做指针的基础类型。没有初始化的指针值为nil。\n\n\n\n```go\nPointerType = \"*\" BaseType .\nBaseType    = Type .\n```\n\n\n\n```go\n*Point\n*[4]int\n```\n\n\n\n#### 函数类型\n\n\n\n函数类型可以表示所有具有相同参数类型和返回值类型的函数。未初始化的函数类型值为 nil。\n\n\n\n```go\nFunctionType   = \"func\" Signature .\nSignature      = Parameters [ Result ] .\nResult         = Parameters | Type .\nParameters     = \"(\" [ ParameterList [ \",\" ] ] \")\" .\nParameterList  = ParameterDecl { \",\" ParameterDecl } .\nParameterDecl  = [ IdentifierList ] [ \"...\" ] Type .\n```\n\n\n\n在参数和返回值列表中，标识符列表必须同时存在或缺省。如果存在，那么每个名字都表示指定类型的一个参数/返回值，这些标识符必须非空并且不能重复。如果缺省，指定类型的参数/返回值使用对应的类型表示。参数列表和返回值列表一般都是需要加括号，不过在只有一个缺省返回值时，它可以不使用括号。\n\n\n\n函数的最后一个参数可以添加前缀 `...`。包含这种参数的函数叫做变参函数，它可以接收零个或多个参数。\n\n\n\n```go\nfunc()\nfunc(x int) int\nfunc(a, _ int, z float32) bool\nfunc(a, b int, z float32) (bool)\nfunc(prefix string, values ...int)\nfunc(a, b int, z float64, opt ...interface{}) (success bool)\nfunc(int, int, float64) (float64, *[]int)\nfunc(n int) func(p *T)\n```\n\n\n\n#### 接口类型\n\n\n\n接口类型指定了一个方法集。一个接口类型变量可以保存任何方法集是该接口超集的类型。我们可以认为类型实现了接口。没有初始化的接口类型值为 nil。\n\n\n\n```go\nInterfaceType      = \"interface\" \"{\" { MethodSpec \";\" } \"}\" .\nMethodSpec         = MethodName Signature | InterfaceTypeName .\nMethodName         = identifier .\nInterfaceTypeName  = TypeName .\n```\n\n\n\n在接口类型的方法集中，每个方法的名称必须是非空且唯一。\n\n\n\n```go\n// A simple File interface\ninterface {\n\tRead(b Buffer) bool\n\tWrite(b Buffer) bool\n\tClose()\n}\n```\n\n\n\n接口可以由多个类型实现，例如：类型 `S1` 和类型 `S2` 都有以下方法集：\n\n\n\n```go\nfunc (p T) Read(b Buffer) bool { return … }\nfunc (p T) Write(b Buffer) bool { return … }\nfunc (p T) Close() { … }\n```\n\n\n\n（这里的类型 T 可以表示 `S1` 也可以表示 `S2` ） `S1` 和 `S2` 都实现了接口 `File`，而不用管类型是否还有其他方法。\n\n\n\n一个类型实现了任何方法集的为其子集的接口。因此它可能实现了多个不同接口。例如：所有的类型都实现了空接口：\n\n\n\n```go\ninterface{}\n```\n\n\n\n与之相似，思考下面这个定义为 `Locker` 的接口：\n\n\n\n```go\ntype Locker interface {\n\tLock()\n\tUnlock()\n}\n```\n\n\n\n如果 `S1` 和 `S2` 也实现了它：\n\n\n\n```go\nfunc (p T) Lock() { … }\nfunc (p T) Unlock() { … }\n```\n\n\n\n那它们就实现了两个接口 `Locker` 和 `File`。\n\n\n\n一个接口 T 可以使用另一个接口 E 来指定方法。这种方式叫做将接口 E 嵌入进接口 T。它把 E 中所有的方法（包括导出和未导出的方法）全部添加进接口 T。\n\n\n\n```go\ntype ReadWriter interface {\n\tRead(b Buffer) bool\n\tWrite(b Buffer) bool\n}\n\ntype File interface {\n\tReadWriter  // 与添加 ReadWriter 接口中的方法是等价的\n\tLocker      // 与添加 Locker 接口中的方法是等价的 \n\tClose()\n}\n\ntype LockedFile interface {\n\tLocker\n\tFile        // 无效: Lock, Unlock 不是唯一的\n\tLock()      // 无效: Lock 不是唯一的\n}\n```\n\n\n\n接口 T 不能递归的嵌入进自己或已经嵌入过它的接口。\n\n\n\n```go\n// 无效: Bad 不能嵌入它自己\ntype Bad interface {\n\tBad\n}\n\n// 无效: Bad1 不能嵌入已经引用它的 Bad2\ntype Bad1 interface {\n\tBad2\n}\ntype Bad2 interface {\n\tBad1\n}\n```\n\n\n\n#### Map类型\n\n\n\nmap 类型是一种以唯一值作为键的无序集合。\n\n\n\n```go\nMapType     = \"map\" \"[\" KeyType \"]\" ElementType .\nKeyType     = Type .\n```\n\n\n\nmap的键类型必须能使用比较运算符 `==` 和 `!=` 进行比较。因此它的键类型不能是函数，map，或者切片。如果键是接口类型，那么比较运算符必须能比较他的动态值。如果不能会抛出一个运行时错误。\n\n\n\n```go\nmap[string]int\nmap[*T]struct{ x, y float64 }\nmap[string]interface{}\n```\n\n\n\nmap中元素的个数叫做它的长度。对于一个map `m`。它的长度可以通过内置函数 `len` 获得，而且它的长度可能再运行时发生变化。map 可以再运行时添加和取回元素，页可以使用内置函数 `delete`移除元素。\n\n\n\n可以使用内置函数 `make` 初始化一个新的且为空的 map。它能指定 map 的类型和预留的空间：\n\n\n\n```go\nmake(map[string]int)\nmake(map[string]int, 100)\n```\n\n\n\nmap 的预留空间不会固定住 map 的长度；它可以通过添加一定数量的元素来增加自己的长度（nil map 不能添加元素）。nil map 和空 map 是相等的，只是 nil map 不能添加元素。\n\n\n\n#### Channel类型\n\n\n\nchannel提供一种手段在并发执行的函数间发送和接收指定类型的值。没有初始化的 channel 是nil。\n\n\n\n```go\nChannelType = ( \"chan\" | \"chan\" \"<-\" | \"<-\" \"chan\" ) ElementType .\n```\n\n\n\n操作符 `<-` 可以指定 channel 的数据流动方向。如果没有指定方向，channel 默认是双向的。channel 可以通过转换和赋值来限制只读和只写。\n\n\n\n```go\nchan T          // 可以接收和发送 T 类型的数据\nchan<- float64  // 只能发送 float64 类型的值\n<-chan int      // 只能接收\n```\n\n\n\n`<-` 与最左侧的 `chan` 关联：\n\n\n\n```go\nchan<- chan int    // 等价于 chan<- (chan int)\nchan<- <-chan int  // 等价于 chan<- (<-chan int)\n<-chan <-chan int  // 等价于 <-chan (<-chan int)\nchan (<-chan int)\n```\n\n\n\n可以通过内置的 `make` 函数初始化 channel。`make` 函数可以指定channel的类型和容量。\n\n\n\n```go\nmake(chan int, 100)\n```\n\n\n\n容量是设置了最大能缓存元素的数量。如果没有设置容量或值为 0，channel 就是没有缓存的，这时只有当发送者和接收者都准备好后才会传输数据。而带缓存的 channel 在缓存没有满的时候依然可以成功发送数据，当缓存不为空的时候可以成功接收到数据，值为 nil 的 channel 不能传输数据。\n\n\n\n可以通过内置函数 `close` 关闭 channel。在接收端的第二个返回值可以用来提示接收者在关闭的 channel 是否还包含数据。\n\n\n\nchannel 可以在发送语句，接收操作中使用。可以不考虑同步性直接在多个 goroutine 中对 channel 调用内置函数 `len` 和 `cap` 。channel 的行为和 FIFO 队列相同。举个例子，一个 goruntine 发送数据，另一个 goruntine 接收他们，接收数据的顺序和发送数据的顺序是相同的。\n\n\n\n## 类型的属性和值\n\n\n\n#### 类型标识\n\n\n\n两个类型可能相同也可能不同。\n\n\n\n定义的类型都是不同类型。如果两个类型的底层类型在结构上是相同的，那它们也是相等的。总的来说：\n\n\n\n- 2 个数组的长度和元素类型相同，那么它们就是相同类型。\n- 如果两个切片的元素类型相同那么它们就是相同类型。\n\n- 如果两个结构体字段顺序相同，并且字段名称、字段类型和 tag 都相同那么它们就是相等的。非导出字段的字段名在不同的包中总是不同的。\n- 如果两个指针的基础类型相同那么他们具有相同类型。\n\n- 如果两个函数具有相同的参数和返回值列表，并且他们的类型相同那么他们就是相同的，参数的名称不一定要相同。\n- 如果两个接口的方法集完全相同（方法的顺序）。\n\n- 如果两个 map 类型的键类型和值类型相同那它们就是相等的。\n- 如果两个 channel 类型包含的对象类型和 channel 的方向都是相同的那它们就是相同的。\n\n\n\n给出下列声明：\n\n\n\n```go\ntype (\n\tA0 = []string\n\tA1 = A0\n\tA2 = struct{ a, b int }\n\tA3 = int\n\tA4 = func(A3, float64) *A0\n\tA5 = func(x int, _ float64) *[]string\n)\n\ntype (\n\tB0 A0\n\tB1 []string\n\tB2 struct{ a, b int }\n\tB3 struct{ a, c int }\n\tB4 func(int, float64) *B0\n\tB5 func(x int, y float64) *A1\n)\n\ntype\tC0 = B0\n```\n\n\n\n这些类型是相等的：\n\n\n\n```go\nA0, A1, and []string\nA2 and struct{ a, b int }\nA3 and int\nA4, func(int, float64) *[]string, and A5\n\nB0, B0, and C0\n[]int and []int\nstruct{ a, b *T5 } and struct{ a, b *T5 }\nfunc(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5\n```\n\n\n\nB0 和 B1 不是一种类型因为它们是通过类型定义方式分别定义的；`func(int, float64) *B0` 和 `func(x int, y float64) *[]string` 是不同的，因为 B0 和 []string 不是相同类型。\n\n\n\n#### 可分配性\n\n\n\n在以下情况下，可以将 x 分配给类型为 T 的变量（把 x 分配给 T）：\n\n\n\n- x 的类型为 T\n- x 的类型 V 和 T 有相同的底层类型并且类型 T 或 V 至少一个定义的类型\n\n- T 是一个接口类型并且 x 实现了 T\n- x 是一个 channel，并且 T 是channel类型，类型V和类型T有相同的元素类型，并且 2 种类型至少有一种不是定义的类型\n\n- x 等于 nil 并且 T 是一个指针，函数，切片，map，channel 或接口类型\n- x 是一个可以表示 T 类型值的无类型常量\n\n\n\n#### 代表性\n\n\n\n满足以下条件时可以用 T 类型的值表示常量 x：\n\n\n\n- T 值的集合包括 x\n- T 是浮点型，而 x 在没有溢出的情况下能够近似成 T 类型。近似规则使用 `IEEE 754 round-to-even`，负零和无符号的零相同。需要注意的是，常量的值不会为负零，NaN，或无限值。\n\n- T 为复数类型，并且 x 的 `real(x)` 和 `imag(x)` 部分由复数类型对应的浮点类型（`float32` 或 `float64` ）组成。\n\n\n\n```go\nx                   T           x 可以表示 T 的值，因为：\n\n'a'                 byte        97 在 byte 类型值的集合中\n97                  rune        rune 是 int32 的别名，97 在 32 位整型值的集合中\n\"foo\"               string      \"foo\" 在字符串值的集合中\n1024                int16       1024 在 16 位整型值的集合中\n42.0                byte        42 在 8 位无符号整型值的集合中\n1e10                uint64      10000000000 在 64 位无符号整型值的集合中\n2.718281828459045   float32     2.718281828459045 的近似值 2.7182817 在 float32 类型值的集合中\n-1e-1000            float64     -1e-1000 的近视值 IEEE -0.0，等于 0 \n0i                  int         0 是整型值\n(42 + 0i)           float32     42.0 (0 虚部) 在 float32 类型值的集合中\n```\n\n\n\n```go\nx                   T           x 不能表示 T 的值，因为：\n\n0                   bool        0 不在布尔值的集合中\n'a'                 string      'a' 是 rune 类型, 它不在字符串类型的值集合中\n1024                byte        1024 不在 8 位无符号整型值的集合中\n-1                  uint16      -1 不在 16 位无符号整型值的集合中\n1.1                 int         1.1 不是整型值\n42i                 float32     (0 + 42i) 不在 float32 类型值的集合中\n1e1000              float64     1e1000 取近似值时会溢出成 IEEE\n```\n\n\n\n## 代码块\n\n\n\n代码块是用大括号括起来的声明和语句。\n\n\n\n```go\nBlock = \"{\" StatementList \"}\" .\nStatementList = { Statement \";\" } .\n```\n\n\n\n除了源码中显式的代码块，也有一些隐式的代码块。\n\n\n\n- 包含所有的Go代码的全局代码块。\n- 包含所有包的代码的包代码块。\n\n- 包含文件内的所有代码的文件代码块。\n- 每个 if，switch和 for 的范围都会形成隐式的块。\n\n- 每个 switch 和 select 条件都有自己的代码块。\n\n\n\n代码块可以嵌套并且影响作用域。\n\n\n\n## 声明和作用域\n\n\n\n一段声明可以给常量，类型，变量，函数，标签，和包绑定标识符。程序中每个标识符都需要声明。相同标识符不能在同一个代码块中声明2次。并且相同标识符不能同时在文件和 package 代码块中声明。\n\n\n\n空标识符可以和其他标识符一样在声明中使用。不过它不绑定标识符，等于没有声明。在 package 代码块中 `init` 标识符只能用做 `init` 函数的标识符，就像空标识符一样，它不会引入新的绑定。\n\n\n\n```go\nDeclaration   = ConstDecl | TypeDecl | VarDecl .\nTopLevelDecl  = Declaration | FunctionDecl | MethodDecl .\n```\n\n\n\n声明过的标识符的作用域就是声明标识符所在的作用域。\n\n\n\ngo使用块来规定词汇的方位：\n\n\n\n- 预定义的标识符具有全局作用域。\n- 所有定义的顶级标识符具有包作用域。\n\n- import进来的包的名字标识符具有文件作用域。\n- 方法的接收者，函数参数，返回值变量具有函数作用域。\n\n- 函数内定义的参量和变量标识符的作用域是标识符被声明到容纳他的块结束。\n\n\n\n一个代码块中声明的标识符可以在它内部的代码块中重新声明。在内部代码块的作用域中标识符表示在内部代码块中声明的实体。\n\n\n\npakcage 语句不属于声明。包名不会出现在任何的作用域中。它的作用只是用来标识属于相同包的多个文件并在导入时指定默认包名。\n\n\n\n#### 标签的作用域\n\n\n\n可以使用标签语句来声明标签，并且可以在 `break`，`continue`，`goto` 语法中使用。如果只声明但没有使用标签时非法的。标签的作用域只有定义时的函数体，早递归函数体中没有作用。\n\n\n\n#### 空标识符\n\n\n\n空标识符使用下划线 `_` 代表。与一般的非空标识符不同，它作为匿名标识符在声明，运算元和赋值语句中都有特殊含义。\n\n\n\n#### 预定义的标识符\n\n\n\n以下标识符已经在全局作用域中预先声明：\n\n\n\n```go\nTypes:\n\tbool byte complex64 complex128 error float32 float64\n\tint int8 int16 int32 int64 rune string\n\tuint uint8 uint16 uint32 uint64 uintptr\n\nConstants:\n\ttrue false iota\n\nZero value:\n\tnil\n\nFunctions:\n\tappend cap close complex copy delete imag len\n\tmake new panic print println real recover\n```\n\n\n\n#### 导出标识符\n\n\n\n标识符可以导出供其他包使用。在以下两种情况同时满足时标识符是导出的：\n\n\n\n- 标识符的首字母是大写（Unicode 的 `Lu` 类）\n- 标识符声明在包作用域或者它是字段名/方法名。\n\n\n\n其他任何标识符都不是导出的。\n\n\n\n#### 标识符的唯一性\n\n\n\n给定一个标识符集合，一个标识符与集合中的每个标识符都不相同，那就认为这个标识符是唯一的。假设有两个标识符，如果它们的拼写不同，或者它们在不同的包中并没有导出，那它们就是不同标识符。相反，其他情况下都认为标识符是相同的。\n\n\n\n#### 常量声明\n\n\n\n常量声明使用常量表达式绑定一系列标识符。标识符的数量必须等于表达式的数量。左侧第 n 个标识符绑定右侧第 n 个表达式的值。\n\n\n\n```go\nConstDecl      = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) .\nConstSpec      = IdentifierList [ [ Type ] \"=\" ExpressionList ] .\n\nIdentifierList = identifier { \",\" identifier } .\nExpressionList = Expression { \",\" Expression } .\n```\n\n\n\n如果给定类型，常量会指定类型，并且表达式的值必须能对这个类型进行赋值。\n\n如果没有给定类型。常量会转换成相应的表达式类型。如果表达式的值是无类型常量，那么声明的常量也是无类型的，并且常量的标识符代表常量的值。例如：即使小数部分是 0，只要表达式是浮点数字面值，常量标识符也表示为浮点数常量。\n\n\n\n```go\nconst Pi float64 = 3.14159265358979323846\nconst zero = 0.0         // 无类型浮点数常量\nconst (\n\tsize int64 = 1024\n\teof        = -1  // 无类型整型常量\n)\nconst a, b, c = 3, 4, \"foo\"  // a = 3, b = 4, c = \"foo\", 无类型整型和字符串常量\nconst u, v float32 = 0, 3    // u = 0.0, v = 3.0\n```\n\n\n\n括号内的常量声明列表的表达式除了第一个必须声明其他表达式可以不写。空的表达式列表的值和类型都和前面的非空表达式相同。缺省的表达式列表等价于重复之前的表达式。标识符的数量必须等于表达式的数量。`iota`常量生成器是一个可以快速生成序列值的机制。\n\n\n\n```go\nconst (\n\tSunday = iota\n\tMonday\n\tTuesday\n\tWednesday\n\tThursday\n\tFriday\n\tPartyday\n\tnumberOfDays  // 非导出常量\n)\n```\n\n\n\n#### Iota\n\n\n\n在常量声明中，预定义的标识符 `iota` 表示连续的无类型整型常量。它的值为常量声明中每个常量定义的位置（从零开始）。它能够用来生成一个关联常量集合：\n\n\n\n```go\nconst ( // iota is reset to 0\n\tc0 = iota  // c0 == 0\n\tc1 = iota  // c1 == 1\n\tc2 = iota  // c2 == 2\n)\n\nconst ( // iota is reset to 0\n\ta = 1 << iota  // a == 1\n\tb = 1 << iota  // b == 2\n\tc = 3          // c == 3  (没有使用 iota 不过它的值依然递增)\n\td = 1 << iota  // d == 8\n)\n\nconst ( // iota is reset to 0\n\tu         = iota * 42  // u == 0     (无类型整型常量)\n\tv float64 = iota * 42  // v == 42.0  (float64 类型常量)\n\tw         = iota * 42  // w == 84    (无类型整型常量)\n)\n\nconst x = iota  // x == 0  (iota 被重置)\nconst y = iota  // y == 0  (iota 被重置)\n```\n\n\n\n根据定义，在同一个常量定义中多次使用 `iota` 会得到相同的值：\n\n\n\n```go\nconst (\n\tbit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)\n\tbit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)\n\t_, _                                  //                        (iota == 2, unused)\n\tbit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)\n)\n```\n\n\n\n最后一个例子利用了最后一个非空表达式列表的隐式重复。\n\n\n\n#### 类型声明\n\n\n\n类型声明为类型绑定一个标识符。类型声明有2种方式：类型声明和别名声明。\n\n\n\n```go\nTypeDecl = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) .\nTypeSpec = AliasDecl | TypeDef .\n```\n\n\n\n##### Alias声明\n\n\n\n别名声明给指定类型绑定一个标识符名称。\n\n\n\n```go\nAliasDecl = identifier \"=\" Type .\n```\n\n\n\n在标识符作用域内，它作为类型的别名。\n\n\n\n```go\ntype (\n\tnodeList = []*Node  // nodeList 和 []*Node 是相同类型\n\tPolar    = polar    // Polar 和 polar 表示相同类型\n)\n```\n\n\n\n##### Type 定义\n\n\n\n类型定义会创建一个新类型并绑定一个标识符，新类型与给定类型具有相同的底层类型和操作。\n\n\n\n```go\nTypeDef = identifier Type .\n```\n\n\n\n这个类型叫做定义类型，它和其他所有类型都不相同，包括创建它的类型。\n\n\n\n```go\ntype (\n\tPoint struct{ x, y float64 }  // Point 和 struct{ x, y float64 } 是不同类型\n\tpolar Point                   // polar 和 Point 表示不同类型\n)\n\ntype TreeNode struct {\n\tleft, right *TreeNode\n\tvalue *Comparable\n}\n\ntype Block interface {\n\tBlockSize() int\n\tEncrypt(src, dst []byte)\n\tDecrypt(src, dst []byte)\n}\n```\n\n\n\n定义类型可以关联该类型的方法。它不会继承原来类型的任何方法。但是接口类型的方法集和类型的结构没有改变。\n\n\n\n```go\n// Mutex 是一个拥有 Lock 和 Unlock 两个方法的数据类型。\ntype Mutex struct         { /* Mutex fields */ }\nfunc (m *Mutex) Lock()    { /* Lock implementation */ }\nfunc (m *Mutex) Unlock()  { /* Unlock implementation */ }\n\n// NewMutex 与 Mutex 结构相同不过方法集为空。\ntype NewMutex Mutex\n\n// PtrMutex 的底层类型 *Mutex 的方法集没有改变，\n// 但是 PtrMutex 的方法集为空。\ntype PtrMutex *Mutex\n\n// *PrintableMutex 包含嵌入字段 Mutex 的 Lock 和 Unlock 方法。\ntype PrintableMutex struct {\n\tMutex\n}\n\n// MyBlock 是与 Block 有相同方法集的接口类型\ntype MyBlock Block\n```\n\n\n\n类型定义可以定义方法集不同的布尔值、数字和字符串类型：\n\n\n\n```go\ntype TimeZone int\n\nconst (\n\tEST TimeZone = -(5 + iota)\n\tCST\n\tMST\n\tPST\n)\n\nfunc (tz TimeZone) String() string {\n\treturn fmt.Sprintf(\"GMT%+dh\", tz)\n}\n```\n\n\n\n#### 变量声明\n\n\n\n变量声明可以创建一个或多个变量，并绑定对应的标识符、指定类型和初始值。\n\n\n\n```go\nVarDecl     = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) .\nVarSpec     = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n```\n\n\n\n```go\nvar i int\nvar U, V, W float64\nvar k = 0\nvar x, y float32 = -1, -2\nvar (\n\ti       int\n\tu, v, s = 2.0, 3.0, \"bar\"\n)\nvar re, im = complexSqrt(-1)\nvar _, found = entries[name]  // map lookup; only interested in \"found\"\n```\n\n\n\n如果给定一个表达式列表。变量会根据赋值规则使用表达式进行初始化。否则，每个变量都会初始化成变量类型的零值。\n\n\n\n如果指定类型，变量会为指定类型。如果没有指定类型，变量会使用分配的初始值类型。如果初始值为无类型常量，它会转换成初始值的默认类型。如果是一个无类型布尔值，那么变量的类型就是 `bool`。值 `nil` 不能给没有指定类型的变量赋值。\n\n\n\n```go\nvar d = math.Sin(0.5)  // d is float64\nvar i = 42             // i is int\nvar t, ok = x.(T)      // t is T, ok is bool\nvar n = nil            // illegal\n```\n\n\n\n实现的限制：在函数体内声明的变量如果没有使用过编译器需要报错。\n\n\n\n#### 短变量声明\n\n\n\n短变量声明的语法:\n\n\n\n```go\nShortVarDecl = IdentifierList \":=\" ExpressionList .\n```\n\n\n\n它比正常使用初始化表达式进行变量声明的方式要短，而且不指定类型：\n\n\n\n```go\n\"var\" IdentifierList = ExpressionList .\n```\n\n\n\n```go\ni, j := 0, 10\nf := func() int { return 7 }\nch := make(chan int)\nr, w := os.Pipe(fd)  // os.Pipe() 返回两个值\n_, y, _ := coord(p)  // coord() 返回三个值，我们只关注 y\n```\n\n\n\n和常规变量声明不同，即使之前在相同代码块中声明过的变量，也可以在短变量重新声明相同类型的变量，并且保证至少会有一个新的非空变量。总之，只应该在多变量短声明的时候重新声明变量，重新声明并不会使用新的变量，而是给变量分配新值。\n\n\n\n```go\nfield1, offset := nextField(str, 0)\nfield2, offset := nextField(str, offset)  // 重新声明 offset\na, a := 1, 2                              // 非法：声明了 a 两次并且没有新的变量\n```\n\n\n\n短变量声明只能在函数中使用，例如在 `if`、`for`、`switch`语句的上下文中声明临时变量。\n\n\n\n#### 函数声明\n\n\n\n函数声明为函数绑定标识符。\n\n\n\n```go\nFunctionDecl = \"func\" FunctionName Signature [ FunctionBody ] .\nFunctionName = identifier .\nFunctionBody = Block .\n```\n\n\n\n如果函数指定了返回参数。函数体的语句必须以终止语句结束。\n\n\n\n```go\nfunc IndexRune(s string, r rune) int {\n   for i, c := range s {\n   \tif c == r {\n   \t\treturn i\n   \t}\n   }\n   // 无效：缺少 return 语句\n}\n```\n\n\n\n函数声明可以没有函数体。这样的声明提供一个函数声明，并由其他外部实现，例如汇编脚本。\n\n\n\n```go\nfunc min(x int, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc flushICache(begin, end uintptr)  // 由外部实现\n```\n\n\n\n#### 方法声明\n\n\n\n方法是一个带接收者的函数，方法声明为方法绑定标识符作为方法名并指定方法对应的接收者类型。\n\n\n\n```go\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] .\nReceiver   = Parameters .\n```\n\n\n\n接收者通过在方法增加一个额外的参数来指定。这个参数必须是一个非可变参数。它的类型必须是 T 或者 T 的指针（可能包含括号）。T 被称作接收者的基础类型；它不能是指针或接口类型，并且只能在同一个包中定义方法。声明后，我们认为方法绑定了基础类型，并且可以通过 T 或 *T 选择器访问方法名。\n\n\n\n非空的接收者标识符在方法签名中必须是唯一的。如果接收者的值没有在该方法中使用，那么接收者标识符可以省略。函数和方法的参数也是一样。\n\n\n\n对于一个基础类型。绑定的非空的方法名必须是唯一的。如果基础类型是一个结构体，非空的方法名也不能与结构体字段重复。\n\n\n\n给定一个`Point`类型。声明：\n\n\n\n```go\nfunc (p *Point) Length() float64 {\n\treturn math.Sqrt(p.x * p.x + p.y * p.y)\n}\n\nfunc (p *Point) Scale(factor float64) {\n\tp.x *= factor\n\tp.y *= factor\n}\n```\n\n\n\n为类型 `*Point`绑定了2个方法 `Length` 和 `Scale`。\n\n方法的类型就是以接收者作为第一个参数的函数类型，例如 `Scale` 方法：\n\n\n\n```go\nfunc(p *Point, factor float64)\n```\n\n\n\n但是以这种方式声明的函数并不是方法。\n\n\n\n## 表达式\n\n\n\n表达式通过针对运算元使用运算符和函数来获取计算值。\n\n\n\n#### 运算元\n\n\n\n运算元代表表达式中的一个简单的。运算元可以是字面值，非空标识符。或括号表达式。\n\n\n\n空标识符只能出现在赋值声明的左侧。\n\n\n\n```go\nOperand     = Literal | OperandName | MethodExpr | \"(\" Expression \")\" .\nLiteral     = BasicLit | CompositeLit | FunctionLit .\nBasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .\nOperandName = identifier | QualifiedIdent.\n```\n\n\n\n#### 修饰标识符\n\n\n\n修饰标识符是以包名作为前缀修饰的标识符。包名和标识符都不能为空。\n\n\n\n```go\nQualifiedIdent = PackageName \".\" identifier .\n```\n\n\n\n修饰标识符可以用来访问不同包（需要先导入）中的标识符。标识符必须是导出的并在包级代码块声明才能够被访问。\n\n\n\n```go\nmath.Sin\t// 表示 math 包中的 Sin 函数\n```\n\n\n\n#### 复合字面值\n\n\n\n复合字面值能为结构体、数组、切片和 map 初始化值。它每次只能创建一个值。字面值由一个字面值类型和使用括号括起来的元素列表组成。元素前也可以声明元素对应的键。\n\n\n\n```go\nCompositeLit  = LiteralType LiteralValue .\nLiteralType   = StructType | ArrayType | \"[\" \"...\" \"]\" ElementType |\n                SliceType | MapType | TypeName .\nLiteralValue  = \"{\" [ ElementList [ \",\" ] ] \"}\" .\nElementList   = KeyedElement { \",\" KeyedElement } .\nKeyedElement  = [ Key \":\" ] Element .\nKey           = FieldName | Expression | LiteralValue .\nFieldName     = identifier .\nElement       = Expression | LiteralValue .\n```\n\n\n\n字面值类型的底层类型必须是一个结构体，数组，切片或 map 类型（如果没有指定类型名就会强制执行这个约束）。元素的类型和键都必须能够分配给相应的字段的元素和键类型；没有额外的类型转换。键可以表示结构体的字段名，切片和数组的索引，map 类型的键。对于 map 字面值，所有的元素都必须有键。如果相同字段名或常量值的键对应多个元素就会报错。如果 map 类型的键为非常量类型，请看求值顺序章节。\n\n\n\n结构体字面值遵循以下规则：\n\n\n\n- 在结构体中，键必须是它的字段名。\n- 不包含任何键的元素列表的顺序需要与结构体字段的声明顺序相同。\n\n- 如果一个元素指定了键，那么所有的元素都必须指定键。\n- 包含键的元素列表不需要指定结构体的每个字字段，缺省字段会使用字段类型的零值。\n\n- 字面值可以不指定元素；这样的字面值等于该类型的零值。\n- 指定非本包的非导出字段会报错。\n\n\n\n给定声明：\n\n\n\n```go\ntype Point3D struct { x, y, z float64 }\ntype Line struct { p, q Point3D }\n```\n\n\n\n我们可以使用这种写法：\n\n\n\n```go\norigin := Point3D{}                            // Point3D 的零值\nline := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 的零值\n```\n\n\n\n数组和切片遵循以下规则：\n\n\n\n- 每个元素都关联一个数字索引标记元素再数组中的位置。\n- 给元素指定的键会作为它的索引。键必须是能够表示非负的 `int` 类型值的常量；如果是指定类型的常量，那么常量必须是整型。\n\n- 元素没有指定键时会使用之前的索引加一。如果第一个元素没有指定键，它的索引为零。\n\n\n\n对复合字面值取址会生成指向由字面量初始化的变量的指针。\n\n\n\n```go\nvar pointer *Point3D = &Point3D{y: 1000}\n```\n\n\n\n数组字面值需要在类型中指定数组的长度。如果提供的元素少于数组的长度，那么缺少元素的位置将会使用元素类型的零值替代。如果索引超过数组的长度会报错。`…` 表示数组的长度等于最大元素索引加一。\n\n\n\n```go\nbuffer := [10]string{}             // len(buffer) == 10\nintSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6\ndays := [...]string{\"Sat\", \"Sun\"}  // len(days) == 2\n```\n\n\n\n切片字面值底层其实就是数组字面值。因此它的长度和容量都是元素的最大索引加一。切片字面值的格式为：\n\n\n\n```go\n[]T{x1, x2, … xn}\n```\n\n\n\n可以在数组上进行切片操作从而获得切片：\n\n\n\n```go\ntmp := [n]T{x1, x2, … xn}\ntmp[0 : n]\n```\n\n\n\n在一个数组、切片或 map 类型 T 中。元素或者 map 的键可能有自己的字面值类型，如果字面值类型和元素或者键类型相同，那么对应的类型标识符可以省略。与之类似，如果元素或键的类型为 `*T`，那么它们的 `&T` 也可以省略。\n\n\n\n```go\n[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}\n[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}\n[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}\nmap[string]Point{\"orig\": {0, 0}}    // same as map[string]Point{\"orig\": Point{0, 0}}\nmap[Point]string{{0, 0}: \"orig\"}    // same as map[Point]string{Point{0, 0}: \"orig\"}\n\ntype PPoint *Point\n[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}\n[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}\n```\n\n\n\n当复合字面值使用字面值类型的类型名格式出现在 `if`、`for` 或 `switch` 语句的关键字和括号之间并且没有使用圆括号包裹的时候，会引发语法歧义。在这种特殊的情况下字面值的括号会被认为是语句的代码块。为了避免歧义，复合字面值必须用括号括起来。\n\n\n\n```go\nif x == (T{a,b,c}[i]) { … }\nif (x == T{a,b,c}[i]) { … }\n```\n\n\n\n下面是合法的数组、切片和 map 的例子：\n\n\n\n```go\n// list of prime numbers\nprimes := []int{2, 3, 5, 7, 9, 2147483647}\n\n// vowels[ch] is true if ch is a vowel\nvowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}\n\n// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}\nfilter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}\n\n// frequencies in Hz for equal-tempered scale (A4 = 440Hz)\nnoteFrequency := map[string]float32{\n\t\"C0\": 16.35, \"D0\": 18.35, \"E0\": 20.60, \"F0\": 21.83,\n\t\"G0\": 24.50, \"A0\": 27.50, \"B0\": 30.87,\n}\n```\n\n\n\n#### 函数字面值\n\n\n\n函数字面值表示一个匿名函数。\n\n\n\n```go\nFunctionLit = \"func\" Function .\n```\n\n\n\n```go\nfunc(a, b int, z float64) bool { return a*b < int(z) }\n```\n\n\n\n函数字面值能分配给变量或直接调用。\n\n\n\n函数字面值是一个闭包。它可以引用包裹函数中的变量，这些变量在包裹函数和函数字面值之间是共享的。并且它会一直存在直到生命周期结束。\n\n\n\n#### 主要表达式\n\n\n\n主要表达式是一元和二元表达式的运算元。\n\n\n\n```go\nPrimaryExpr =\n\tOperand |\n\tConversion |\n\tPrimaryExpr Selector |\n\tPrimaryExpr Index |\n\tPrimaryExpr Slice |\n\tPrimaryExpr TypeAssertion |\n\tPrimaryExpr Arguments .\n\nSelector       = \".\" identifier .\nIndex          = \"[\" Expression \"]\" .\nSlice          = \"[\" [ Expression ] \":\" [ Expression ] \"]\" |\n                 \"[\" [ Expression ] \":\" Expression \":\" Expression \"]\" .\nTypeAssertion  = \".\" \"(\" Type \")\" .\nArguments      = \"(\" [ ( ExpressionList | Type [ \",\" ExpressionList ] ) [ \"...\" ] [ \",\" ] ] \")\" .\n```\n\n\n\n```go\nx\n2\n(s + \".txt\")\nf(3.1415, true)\nPoint{1, 2}\nm[\"foo\"]\ns[i : j + 1]\nobj.color\nf.p[i].x()\n```\n\n\n\n#### 选择器\n\n\n\n对于一个 x 不是包名的主要表达式，选择器表达式：\n\n\n\n```go\nx.f\n```\n\n\n\n表示 x 的字段或方法 f（有时为 *x）。标识符 f 叫做（字段/方法）选择器。它不能是空标识符。选择器表达式的类型就是 f 的类型。如果 x 是包名。请参考修饰标识符。\n\n\n\n选择器 f 可以表示类型 T 的方法或字段 f。也可以表示类型 T 的嵌入方法或字段 f。访问 f 所需穿过的嵌套层数叫做它在类型 T 中的深度。声明在 T 中的字段或方法的深度为 0。声明在 T 的嵌入字段 A 中的方法或字段的深度等于 f 在 A 中的深度加一。\n\n\n\n选择器遵循以下原则：\n\n\n\n- 对于非指针/接口类型 T/*T 的值 x，x.f 表示第一层的方法/字段。如果在第一层没有对应的 f，选择器表达式就是非法的。\n- 对于接口类型 I 的值 x，`x.f`表示动态值 x 的方法名 f。如果接口 I 的方法集中没有 f 方法，选择器就是非法的。\n\n- 作为例外，如果 x 是一个指针类型并且 (*x).f 是合法的选择器表达式（只能表示字段，不能表示方法）。那么(*x).f 可以简写成 x.f。\n- 在其他情况下，x.f 都是非法的。\n\n- 如果x是指针类型，并且值为 nil，其中 f 为结构体字段。赋值或取值 x.f 会引起运行时恐慌。\n- 如果x是接口类型，并且值为 nil。调用 x.f  会引起运行时恐慌。\n\n\n\n例如给定声明：\n\n\n\n```go\ntype T0 struct {\n\tx int\n}\n\nfunc (*T0) M0()\n\ntype T1 struct {\n\ty int\n}\n\nfunc (T1) M1()\n\ntype T2 struct {\n\tz int\n\tT1\n\t*T0\n}\n\nfunc (*T2) M2()\n\ntype Q *T2\n\nvar t T2     // with t.T0 != nil\nvar p *T2    // with p != nil and (*p).T0 != nil\nvar q Q = p\n```\n\n\n\n结果：\n\n\n\n```go\nt.z          // t.z\nt.y          // t.T1.y\nt.x          // (*t.T0).x\n\np.z          // (*p).z\np.y          // (*p).T1.y\np.x          // (*(*p).T0).x\n\nq.x          // (*(*q).T0).x        (*q).x is a valid field selector\n\np.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver\np.M1()       // ((*p).T1).M1()      M1 expects T1 receiver\np.M2()       // p.M2()              M2 expects *T2 receiver\nt.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls\n```\n\n\n\n但是下面这种方式是不合法的：\n\n\n\n```go\nq.M0()       // (*q).M0 is valid but not a field selector\n```\n\n\n\n#### 方法表达式\n\n\n\n如果 M 在类型 T 的方法集中。那么 T.M 就是能够正常调用的函数。使用与 M 相同的参数只是在参数列表的最前面增加了接收者参数。\n\n\n\n```go\nMethodExpr    = ReceiverType \".\" MethodName .\nReceiverType  = TypeName | \"(\" \"*\" TypeName \")\" | \"(\" ReceiverType \")\" .\n```\n\n\n\n假设结构体 T 有两个方法。接收者类型为 T 的 Mv 方法和接收者类型为 *T 的 Mp 方法：\n\n\n\n```go\ntype T struct {\n\ta int\n}\nfunc (tv  T) Mv(a int) int         { return 0 }  // value receiver\nfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver\n\nvar t T\n```\n\n\n\n表达式\n\n\n\n```go\nT.Mv\n```\n\n\n\n将会生成一个等价于 Mv 方法只是第一个参数显式声明接受者的函数。它的签名为：\n\n\n\n```go\nfunc(tv T, a int) int\n```\n\n\n\n这个函数能够通过接收者正常调用，以下5种方式是等价的：\n\n\n\n```go\nt.Mv(7)\nT.Mv(t, 7)\n(T).Mv(t, 7)\nf1 := T.Mv; f1(t, 7)\nf2 := (T).Mv; f2(t, 7)\n```\n\n\n\n与之类似：\n\n\n\n```go\n(*T).Mp\n```\n\n\n\n生成表示 Mp 的函数签名：\n\n\n\n```go\nfunc(tp *T, f float32) float32\n```\n\n\n\n对于一个把值作为接收者的方法，我们可以显式的从指针接收者获得函数：\n\n\n\n```go\n(*T).Mv\n```\n\n\n\n生成表示 Mv 的函数签名：\n\n\n\n```go\nfunc(tv *T, a int) int\n```\n\n\n\n这样的函数会通过接收者间接的创建一个值作为接收者传入底层方法中。方法内不能修改接收者的值，因为它的地址是在函数的调用栈里面。\n\n\n\n最后一个例子。把值作为接收者函数当做指针作为接收者的方法是非法的，因为指针接收者的方法集中不包含值类型的方法集。\n\n\n\n通过函数调用语法从方法中获取函数的值。接收者作为调用函数的第一个参数。给定  `f :=T.Mv`，f 作为`f(t,7)` 进行调用而不是 `t.f(7)`。想创建一个绑定接收者的函数可以使用函数字面值或者方法值。\n\n\n\n在接口类型中定义函数获取函数值是合法的。最终的函数调用会使用接口类型作为接收者。\n\n\n\n#### 方法值\n\n\n\n如果表达式 x 拥有静态类型 T 并且 M 在类型 T 的方法集中。x.M 叫做方法值。方法值 `x.M` 是一个函数值，这个函数和 x.M 拥有相同的参数列表。表达式 x 在计算方法值时会被保存和计算，这个拷贝的副本会作为任何接下来调用的接收者。\n\n\n\n类型 T 可能是接口类型也可能不是接口类型。\n\n\n\n与方法表达式中讲过的一样，假设类型 T 有两个方法：接收者类型为 T 的 Mv 和接受者类型为 *T 的 Mp ：\n\n\n\n```go\ntype T struct {\n\ta int\n}\nfunc (tv  T) Mv(a int) int         { return 0 }  // value receiver\nfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver\n\nvar t T\nvar pt *T\nfunc makeT() T\n```\n\n\n\n表达式：\n\n\n\n```go\nt.Mv\n```\n\n\n\n生成一个类型的函数值：\n\n\n\n```go\nfunc(int) int\n```\n\n\n\n以下两种调用是等价的：\n\n\n\n```go\nt.Mv(7)\nf := t.Mv; f(7)\n```\n\n\n\n相似的，表达式：\n\n\n\n```go\npt.Mp\n```\n\n\n\n生成一个类型的函数值：\n\n\n\n```go\nfunc(float32) float32\n```\n\n\n\n与选择器相同，使用指针调用以值作为接收者的非接口方法会自动将指针解引用：`pt.Mv` 等价于 `(*pt).Mv`。\n\n\n\n与方法调用相同，使用值调用以指针作为接收者的非接口方法会自动对值取址：`pt.Mv` 等价于 `(&pt).Mv`。\n\n\n\n```go\nf := t.Mv; f(7)   // like t.Mv(7)\nf := pt.Mp; f(7)  // like pt.Mp(7)\nf := pt.Mv; f(7)  // like (*pt).Mv(7)\nf := t.Mp; f(7)   // like (&t).Mp(7)\nf := makeT().Mp   // invalid: result of makeT() is not addressable\n```\n\n\n\n尽管上面使用的都是非接口类型的例子，不过对于接口类型同样适用。\n\n\n\n```go\nvar i interface { M(int) } = myVal\nf := i.M; f(7)  // like i.M(7)\n```\n\n\n\n#### index表达式\n\n\n\n主要表达式格式：\n\n\n\n```go\na[x]\n```\n\n\n\n可以表示数组元素、数组的指针、切片、字符串或 map 类型 a 索引 x 对应的值。x 称作索引或者 map 的键。遵循以下规则：\n\n\n\n如果a不是 map 类型：\n\n\n\n- 索引 x 必须是整型或无类型常量。\n- 常量索引必须是非负数且可以使用 int 类型表示。\n\n- 无类型的常量索引会作为 int 型的值。\n- 索引 x 的范围在 `0<=x<len(a)` 内，否则就是越界。\n\n\n\n对于数组类型 A：\n\n\n\n- 常量索引必须在合法范围内。\n- 如果 x 在运行时越界会引起运行时恐慌。\n\n- `a[x]` 表示数组在索引 x 处的元素。`a[x]` 的类型就是 A 的元素类型。\n\n\n\n对于数组的指针类型：\n\n\n\n- 可以使用 `a[x]` 表示 `(*a)[x]`。\n\n\n\n对于切片类型 S：\n\n\n\n- 如果 x 在运行时越界会引起运行时恐慌。\n- `a[x]` 表示切片在索引 x 处的元素。`a[x]` 的类型就是 S 的元素类型。\n\n\n\n对于字符串类型：\n\n\n\n- 如果字符串 a 为常量，那么常量索引必须在合法范围内。\n- 如果 x 在运行时越界会引起运行时恐慌。\n\n- a[x] 表示索引 x 处的非常量字节，它是byte类型。\n- 不能对 a[x] 分配值。\n\n\n\n对于 map 类型 M：\n\n\n\n- 必须保证 x 的类型能够给 M 的键分配值。\n- 如果map包含键为 x 的值，a[x] 就是 map 中键 x 对应的值，它的类型就是 M 的元素类型。\n\n- 如果 map 值为 nil 或不包含这个实体，那么 a[x] 为 M 元素类型的零值。\n\n\n\n否则 a[x] 就是非法的。\n\n\n\n基于 `map[K]V` 类型  a 的索引表达式可以使用特殊格式的赋值和初始化语法。\n\n\n\n```go\nv, ok = a[x]\nv, ok := a[x]\nvar v, ok = a[x]\n```\n\n\n\n它会额外生成一个无类型的布尔值。如果 ok 是 true，那么代表在map中有该键，如果没有 ok 为 false。\n\n\n\n给一个值为 nil 的 map 类型变量赋值会导致运行时恐慌。\n\n\n\n#### 切片表达式\n\n\n\n切片表达式可以基于字符串、数组、数组指针、切片创建字符串子串或切片。它有两种变体，一种是简单的格式是指定开始和结束位置，完全格式的语法还可以指定容量。\n\n\n\n\\####### 简单切片表达式\n\n\n\n对于数组、字符串、指针数组、切片 a，主要表达式：\n\n\n\n```go\na[low:high]\n```\n\n\n\n可以构造字符串子串或切片。索引 `low` 和 `high` 决定结果切片中的元素。结果切片的索引从 0 开始，长度为 `high - low`。从数组切分出的切片 s 拥有类型 `[]int`，长度为 3 ，容积为 4。\n\n\n\n```go\na := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]\n```\n\n\n\n```go\ns[0] == 2\ns[1] == 3\ns[2] == 4\n```\n\n\n\n为了方便起见，索引值都可以缺省。当 low 缺省时默认从 0 开始。当缺 high 缺省时默认的取切片的长度。\n\n\n\n```go\na[2:]  // same as a[2 : len(a)]\na[:3]  // same as a[0 : 3]\na[:]   // same as a[0 : len(a)]\n```\n\n\n\n如果 a 是一个数组指针，那么 `a[low:high]` 可以表示 `(*a)[low : high]`。\n\n\n\n对于数组或者字符串，索引的范围是`0<=low<=high<=len(a)`。对于切片，最大的索引值可以为切片的容量，而不是切片的长度。常量索引必须为非负数，且能够转换成 int 类型。对于数组或者常量字符串。常量索引值必须在合法范围内。如果2个索引都是常量。low 必须小于 high。如果索引在运行时访问了非法内存，程序会发生运行时恐慌。\n\n\n\n除了无类型字符串，对于切片和字符串的操作结果是非常量类型的值，它的类型与运算元相同。如果运算元为无类型字符串，那么结果类型会为 string。如果把数组作为运算元，它必须是可寻址的，并且获得的切片和原数组具有同一元素类型。\n\n\n\n如果切片运算元为 nil，那么结果也是 nil。否则结果切片会和运算元共享相同的底层无类型数组。\n\n\n\n###### 完全切片表达式\n\n\n\n对于数组，数组指针或非字符串切片，主要表达式为：\n\n\n\n```go\na[low : high : max]\n```\n\n\n\n它会构造一个同类型切片，并具有与简单切片表达式的 `a[low:high]` 相同的长度和元素。另外，它还可以把切片的容量设置为 `max - low`。这时只有第一个索引可以为缺省值，默认为零。从数组中获得切片以后：\n\n\n\n```go\na := [5]int{1, 2, 3, 4, 5}\nt := a[1:3:5]\n```\n\n\n\n切片 t 为 []int 类型，长度为 2，容量为 4，并且元素为：\n\n\n\n```go\nt[0] == 2\nt[1] == 3\n```\n\n\n\n和简单切片表达式一样，如果 a 是数组指针 ，那么 `a[low:high:max]` 可以简写为 `(*a)[low:high:max]`。如果切分操作元是数组，那么这个数组必须是可以寻址的。\n\n\n\n如果索引必须在 `0 <= low <= high <= max <= cap(a)` 范围内。常量索引不能是负数并且能够使用 `int` 类型表示；对于数组，索引必须在合法范围内。如果有多个索引都是常量的，那么所有索引都需要在合法范围内。如果索引是非法的，会引起运行时恐慌。\n\n\n\n#### 类型断言\n\n\n\n对于接口类型 x 和类型 T，主要表达式：\n\n\n\n```go\nx.(T)\n```\n\n\n\n可以断言 x 不是 nil  且 x 的值是 T 类型。标记 x.(T) 叫做类型断言。\n\n\n\n更确切的说，如果 T 不是接口类型，那么 x.(T) 将会断言动态类型 x 的类型是不是 T。\n\n这时，T 必须实现了 x 的（接口）类型。否则断言会是非法的因为 x 不能保存 T 类型的值。如果 T 是接口类型，那么可以断言动态类型 x 是否实现了 T 接口。\n\n\n\n如果类型断言成功，表达式的值为 x 的值，但它的类型是T。如果断言失败，将会导致运行时恐慌。换句话说，即使 x 是运行时确定的，x.(T) 也必须是编程时就确认存在的。\n\n\n\n```go\nvar x interface{} = 7          // x 拥有动态类型 int 值为 7\ni := x.(int)                   // i 为 int 类型值为 7\n\ntype I interface { m() }\n\nfunc f(y I) {\n   s := y.(string)        // 非法: 字符串没有实现接口 I （缺少 m 方法）\n   r := y.(io.Reader)     // r 拥有接口 io.Reader 所以 y 的动态类型必须同时实现 I 和 io.Reader\n   …\n}\n```\n\n\n\n类型断言可以使用特定格式的赋值和初始化语句。\n\n\n\n```go\nv, ok = x.(T)\nv, ok := x.(T)\nvar v, ok = x.(T)\nvar v, ok T1 = x.(T)\n```\n\n\n\n这时将会额外生成一个无类型的布尔值。如果断言成功，ok返回 `true`，否则是 `false`。并且 v 会是 T 类型的零值。这时不会有恐慌发生。\n\n\n\n#### 调用\n\n\n\n给定函数类型为 F 的表达式 f：\n\n\n\n```go\nf(a1, a2, … an)\n```\n\n\n\n可以使用 a1,a2...an 来调用函数 f。除一种特殊情况之外，函数参数必须是对应 F 函数参数类型的单值表达式，且在函数调用前就已经完成求值。表达式的结果类型是 f 的结果类型。函数调用和方法调用相似，只是方法额外需要一个接收者类型。\n\n\n\n```go\nmath.Atan2(x, y)  // function call\nvar pt *Point\npt.Scale(3.5)     // method call with receiver pt\n```\n\n\n\n在函数调用中，函数的值和参数是按照顺序求值的。在计算之后作为参数会传进函数，函数开始执行。当函数执行完成后返回的参数将会返回给函数的调用者。\n\n\n\n调用值为 nil 的函数会导致运行时恐慌。\n\n\n\n作为特例，如果函数或者方法的返回值等于参数列表的个数，那么会嵌套调用。这将把返回值直接赋值给下一次调用函数的参数。\n\n\n\n```go\nfunc Split(s string, pos int) (string, string) {\n\treturn s[0:pos], s[pos:]\n}\n\nfunc Join(s, t string) string {\n\treturn s + t\n}\n\nif Join(Split(value, len(value)/2)) != value {\n\tlog.Panic(\"test fails\")\n}\n```\n\n\n\n如果 x 的方法集中包含 m 那么 `x.m()` 是合法的。并且参数列表和 m 的参数列表相同。如果x是可寻址的，那么那么x指针的方法集`(&x).m()`可以简写成`x.m()`。\n\n\n\n```go\nvar p Point\np.Scale(3.5)\n```\n\n\n\n没有方法类型，也没有方法字面值。\n\n\n\n#### 通过 `...` 来传递参数\n\n\n\n如果 f 的最后一个参数 p 的类型是 `...T`。那么在函数内部 p 参数的类型就是 `[]T`。如果 f 调用时没有传入 p 对应的参数，那么p为 nil。否则这些参数会以切片方式传入，在新的底层切片中。切片中的类型都是能赋值给类型 T 的值。这个切片的长度和容量在不同的调用中有所不同。\n\n\n\n给定函数调用：\n\n\n\n```go\nfunc Greeting(prefix string, who ...string)\nGreeting(\"nobody\")\nGreeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\")\n```\n\n\n\n在 `Greeting` 中，第一次调用时，`who`是 nil 类型。而在第二次调用时是`[]string{\"Joe\", \"Anna\", \"Eileen\"}`。\n\n\n\n如果在调用的时候的最后一个参数是[]T，那么我们可以使用`...`来将切片中的值依次赋值给参数列表。\n\n\n\n给定切片s并且调用:\n\n\n\n```go\ns := []string{\"James\", \"Jasmine\"}\nGreeting(\"goodbye:\", s...)\n```\n\n\n\nz 在 `Greeting`。中 `who` 会和切片 s 共享相同的底层数组。\n\n\n\n#### 操作符\n\n\n\n操作符用来连接运算元。\n\n\n\n```go\nExpression = UnaryExpr | Expression binary_op Expression .\nUnaryExpr  = PrimaryExpr | unary_op UnaryExpr .\n\nbinary_op  = \"||\" | \"&&\" | rel_op | add_op | mul_op .\nrel_op     = \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" .\nadd_op     = \"+\" | \"-\" | \"|\" | \"^\" .\nmul_op     = \"*\" | \"/\" | \"%\" | \"<<\" | \">>\" | \"&\" | \"&^\" .\n\nunary_op   = \"+\" | \"-\" | \"!\" | \"^\" | \"*\" | \"&\" | \"<-\" .\n```\n\n\n\n比较运算符在此处讨论。对于其他二元操作符，两个操作元的类型必须是相同的，除了位移和无类型常量。针对常量的操作，请看常量表达式章节。\n\n\n\n除了位移操作，如果其中一个操作符是无类型常量，而另个不是，那么无类型的常量会转换成另一个运算元的类型。\n\n\n\n在右移表达式中的运算元必须是无符号的整数或者可以转换成 uint 的无类型的常量。如果左移一个无类型常量那么结果依然是无类型的。他首先会转换成指定类型。\n\n\n\n```go\nvar s uint = 33\nvar i = 1<<s           // 1 has type int\nvar j int32 = 1<<s     // 1 has type int32; j == 0\nvar k = uint64(1<<s)   // 1 has type uint64; k == 1<<33\nvar m int = 1.0<<s     // 1.0 has type int; m == 0 if ints are 32bits in size\nvar n = 1.0<<s == j    // 1.0 has type int32; n == true\nvar o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size\nvar p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int\nvar u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift\nvar u1 = 1.0<<s != 0   // illegal: 1.0 has type float64, cannot shift\nvar u2 = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift\nvar v float32 = 1<<s   // illegal: 1 has type float32, cannot shift\nvar w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression\n```\n\n\n\n###### 运算符优先级\n\n\n\n一元运算符拥有最高优先级。++ 和 -- 是语句而不是表达式，他们在运算符的优先级之外。所以 (*p)++ 和 *p++ 是一样的。\n\n\n\n二元运算符有 5 个优先级。乘法运算符在最高级，紧接着是加法运算符。比较运算符，&& 运算符，最后是 ||。\n\n\n\n```go\nPrecedence    Operator\n    5             *  /  %  <<  >>  &  &^\n    4             +  -  |  ^\n    3             ==  !=  <  <=  >  >=\n    2             &&\n    1             ||\n```\n\n\n\n相同优先级的二元运算符的执行顺序是由左到右。例如 `x/y*z`和`(x/y)*z` 是一样的。\n\n\n\n```go\n+x\n23 + 3*x[i]\nx <= f()\n^a >> b\nf() || g()\nx == y+1 && <-chanPtr > 0\n```\n\n\n\n#### 算数运算符\n\n\n\n算数运算符应用在 2 个数字值之间，别切生成一个相同类型的值作为第一个运算元。四种算数运算符(+,-,*,/)应用在数字，浮点，复合类型之中。+ 也可以用于字符串。位运算和位移运算只适用于整数。\n\n\n\n```go\n+    sum                    integers, floats, complex values, strings\n-    difference             integers, floats, complex values\n*    product                integers, floats, complex values\n/    quotient               integers, floats, complex values\n%    remainder              integers\n\n&    bitwise AND            integers\n|    bitwise OR             integers\n^    bitwise XOR            integers\n&^   bit clear (AND NOT)    integers\n\n<<   left shift             integer << unsigned integer\n>>   right shift            integer >> unsigned integer\n```\n\n\n\n###### 数字运算符\n\n\n\n对于两个整数 x 和 y。整数商 `q=x/y` 和余数 `r=x%y` 遵循以下规律。\n\n\n\n```go\nx = q*y + r  and  |r| < |y|\n```\n\n\n\n`x/y` 截断为 0。\n\n\n\n```go\nx     y     x / y     x % y\n 5     3       1         2\n-5     3      -1        -2\n 5    -3      -1         2\n-5    -3       1        -2\n```\n\n\n\n作为这个规则的例外情况，如果 x 非常大，那么 `q=x/-1` 等于 x。\n\n\n\n```go\nx, q\nint8                     -128\nint16                  -32768\nint32             -2147483648\nint64    -9223372036854775808\n```\n\n\n\n如果除数是一个常量。那么它不能是 0，如果除数在运行时为 0，会导致运行时恐慌。如果除数是负数并且除数是：\n\n\n\n```go\nx     x / 4     x % 4     x >> 2     x & 3\n 11      2         3         2          3\n-11     -2        -3        -3          1\n```\n\n\n\n位移运算符移动左侧运算元右侧元算元指定的位数。如果左侧是有符号整型，那它就实现了位移运算，如果是无符号整数使用逻辑位移。位移运算没有上限，位移操作让左边运算元位移 n 个 1。`x<<1` 和 `x*2` 是相等的。并且 `x>>1` 和 `x/2` 是相同的。\n\n\n\n对于整数运算元，一元运算符+-^定义如下：\n\n\n\n```go\n+x                          is 0 + x\n-x    negation              is 0 - x\n^x    bitwise complement    is m ^ x  with m = \"all bits set to 1\" for unsigned x\n                                      and  m = -1 for signed x\n```\n\n\n\n###### 整型溢出\n\n\n\n对于无符号的值，运算符+-*和<<都是2禁止运算。这里的n是无符号类型的宽度，无符号整型将会丢弃溢出的位，并且程序将会返回`wrap around`。\n\n\n\n对于有符号的整数，操作符+=*<<都会溢出并且值存在，并且代表相应的有符号的值。在运算时不会抛出异常。标一起不会报错。所以不是所有情况下x<x+1都成立。\n\n\n\n###### 浮点数运算符\n\n\n\n对于浮点数和其他复杂数字，+x和x是一样的，-x是x的对立面。除了IEEE-754还没有指定浮点数除0或者复数的结果。是否抛出异常将会依赖其具体实现。\n\n\n\n一种实现可以合并多个浮点操作进一个操作，有可能是夸语句的，并且他的结果可能和依次单独执行的结果不一样。1个浮点数类型将会转变成目标的精度，防止四舍五入的融合。\n\n\n\n```go\n// FMA allowed for computing r, because x*y is not explicitly rounded:\nr  = x*y + z\nr  = z;   r += x*y\nt  = x*y; r = t + z\n*p = x*y; r = *p + z\nr  = x*y + float64(z)\n\n// FMA disallowed for computing r, because it would omit rounding of x*y:\nr  = float64(x*y) + z\nr  = z; r += float64(x*y)\nt  = float64(x*y); r = t + z\n```\n\n\n\n###### 字符串\n\n\n\n字符串可以使用+和+=操作符。\n\n\n\n```go\ns := \"hi\" + string(c)\ns += \" and good bye\"\n```\n\n\n\n字符串想家将会创建一个新的字符串。\n\n\n\n#### 比较运算符\n\n\n\n比较运算符比较连个运算元，并且生成一个无类型的布尔值。\n\n\n\n```go\n==    equal\n!=    not equal\n<     less\n<=    less or equal\n>     greater\n>=    greater or equal\n```\n\n\n\n在任何比较运算元中2种类型必须是可以分配的。\n\n\n\n使用等于运算符`==`和`!=`的运算元必须是可比较的。使用顺序运算符`<`,`<=`,`>`和`>=`必须是可比较的。这些限制导致比较运算符被定义成以下的方式。\n\n\n\n- 布尔值是可比较的，两个布尔值当他们同为`true`或者false的使用是相等的\n- 整数值是可比较和排序的\n\n- 浮点数是可比较和排序的，具体定义在IEEE-754标准中。\n- 复数是可比较的，2个复数当实部和虚部都相等时就是相等的。\n\n- 字符串是可以比较和排序的。是按照字节顺序排序。\n- 指针式可以排序的，连个指针当指向相同变量时是相同的，或者他们2个都是nil。指向一个为非配的变量的结果是未定义的。\n\n- channel是可比较的。当两个管道是用同一个make出来的，或者都是nil时时相等的。\n- 接口值时可以比较的，2个接口值时相等的如果2个标识符的动态类型是一样的或者他们都是nil。\n\n- 一个非接口类型的值x和一个接口类型的值T在非接口类型是可以比较的并且非接口类型实现了接口是是可以比较的。当他们的动态类型类型相同时时相等的。\n- 当结构体内的所有字段都是可以比较的时候，他是可以比较的。连个结构体的值当非空字段都相等时他们是相等的。\n\n- 数组类型的值时可比较的，如果数组的原属时可以比较的，那么当数组的所有值是相等的时候他们就是相等的。\n\n\n\n使用两个动态类型的标识符来比较接口的值。如果这个类型的值时不可比较的，那么将会引起一个panic。这个行为不仅仅时接口，数组结构体接口字段都有这个问题。\n\n\n\n切片，map，和函数值都是不可比较的，然而，作为一个特殊的例子，切片，map和函数的值的nil时可以比较的，指针，channel和接口的值nil也是可以比较的。\n\n\n\n```go\nconst c = 3 < 4            // c is the untyped boolean constant true\n\ntype MyBool bool\nvar x, y int\nvar (\n\t// The result of a comparison is an untyped boolean.\n\t// The usual assignment rules apply.\n\tb3        = x == y // b3 has type bool\n\tb4 bool   = x == y // b4 has type bool\n\tb5 MyBool = x == y // b5 has type MyBool\n)\n```\n\n\n\n#### 逻辑操作符\n\n\n\n逻辑运算符使用布尔值值，并且生成一个相同类型的结果值作为操作元。右面的操作元计算是有条件的。\n\n\n\n```go\n&&    conditional AND    p && q  is  \"if p then q else false\"\n||    conditional OR     p || q  is  \"if p then true else q\"\n!     NOT                !p      is  \"not p\"\n```\n\n\n\n#### 地址操作符\n\n\n\n以类型 T 的 x 作为运算元，取址操作 `&x` 会生成一个类型为 `*T` 并指向 x 的指针。运算元必须是能够取址的，它可以是一个变量，指针，切片的取值操作；或是一个可取址结构体的字段选择器；或是对于可取址数组的索引取值操作。作为寻址能力的例外，x 可能是一个复合字面值。如果对 x 进行取址操作将会 panic，`&x` 也会 panic。\n\n\n\n对于一个 `*T` 类型的运算元 x，指针解引用 `*x` 表示 x 指向的 T 类型。如果 x 为 nil，那么解引用 `*x` 会 panic。\n\n\n\n```go\n&x\n&a[f(2)]\n&Point{2, 3}\n*p\n*pf(x)\n\nvar x *int = nil\n*x   // causes a run-time panic\n&*x  // causes a run-time panic\n```\n\n\n\n#### 接收操作符\n\n\n\n对于管道类型的运算元 `ch`，接收操作 `<-ch` 返回值是管道 `ch` 接收到的值。带方向的管道需要有接受权限，接收操作的类型也是通道的元素类型。表达式会一直阻塞直到接收到返回值。从 nil 通道接收值会一直阻塞。从一个已经关闭的通道接收数据会在其他数据都被接收以后生成该通道元素类型的零值。\n\n\n\n```go\nv1 := <-ch\nv2 = <-ch\nf(<-ch)\n<-strobe  // wait until clock pulse and discard received value\n```\n\n\n\n接收数据的表达式可以使用赋值表达式。\n\n\n\n```go\nx, ok = <-ch\nx, ok := <-ch\nvar x, ok = <-ch\nvar x, ok T = <-ch\n```\n\n\n\n它还可以生成一个额外的无类型布尔值来表示通道是否关闭。如果 ok 为 `true` 说明获取到的是发送到通道内的数据，而 `false` 它就返回一个零值因为通道内没有元素且已经关闭。\n\n\n\n#### 类型转换\n\n\n\n类型转换表达式 `T(x)` 其中 T 代表类型，x 代表可以转换成 T 类型的表达式。\n\n\n\n```go\nConversion = Type \"(\" Expression [ \",\" ] \")\" .\n```\n\n\n\n如果类型是以 `*` 或 `<-` 开头，或以关键字 `func` 开头并且没有返回值列表，那么它必须用括号括起来避免歧义：\n\n\n\n```go\n*Point(p)        // same as *(Point(p))\n(*Point)(p)      // p is converted to *Point\n<-chan int(c)    // same as <-(chan int(c))\n(<-chan int)(c)  // c is converted to <-chan int\nfunc()(x)        // function signature func() x\n(func())(x)      // x is converted to func()\n(func() int)(x)  // x is converted to func() int\nfunc() int(x)    // x is converted to func() int (unambiguous)\n```\n\n\n\n常量 x 可以在可以用类型 T 表示时自动转换。作为一个特例，整数常量 x 可以转换成字符串类型就和非常量 x 一样。\n\n\n\n对常量的转换会生成一个指定类型的常量。\n\n\n\n```go\nuint(iota)               // iota value of type uint\nfloat32(2.718281828)     // 2.718281828 of type float32\ncomplex128(1)            // 1.0 + 0.0i of type complex128\nfloat32(0.49999999)      // 0.5 of type float32\nfloat64(-1e-1000)        // 0.0 of type float64\nstring('x')              // \"x\" of type string\nstring(0x266c)           // \"♬\" of type string\nMyString(\"foo\" + \"bar\")  // \"foobar\" of type MyString\nstring([]byte{'a'})      // not a constant: []byte{'a'} is not a constant\n(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type\nint(1.2)                 // illegal: 1.2 cannot be represented as an int\nstring(65.0)             // illegal: 65.0 is not an integer constant\n```\n\n\n\n非常量 x 可以在以下情况下转换成类型 T：\n\n\n\n- x 可以给类型 T 赋值\n- 忽略的结构体标签，x 的类型和 T 具有相同的底层类型\n\n- 忽略的结构体标签，x 的类型和 T 都是指针类型，并且指针所指的类型具有相同的底层类型\n- x 的类型和 T 都是整数或者浮点数类型\n\n- x 的类型和 T 都是复数类型\n- x 是一个字符串而 T 时字节切片或者 rune 切片\n\n\n\n在比较两个结构体类型的时候会忽略结构体标签：\n\n\n\n```go\ntype Person struct {\n\tName    string\n\tAddress *struct {\n\t\tStreet string\n\t\tCity   string\n\t}\n}\n\nvar data *struct {\n\tName    string `json:\"name\"`\n\tAddress *struct {\n\t\tStreet string `json:\"street\"`\n\t\tCity   string `json:\"city\"`\n\t} `json:\"address\"`\n}\n\nvar person = (*Person)(data)  // ignoring tags, the underlying types are identical\n```\n\n\n\n这个规则也适用于数字类型与字符串类型间的相互转换。这个转换可能会改变 x 的值并且会增加运行时消耗。包 unsafe 实现了这个功能底层的限制。\n\n\n\n###### 数字之间的转换\n\n\n\n对于非常量的数字转换，需要遵守以下规则：\n\n\n\n- 在转换整型数字时，如果是一个有符号整型，它是继承有符号的无限精度；否则就不用继承符号。转换时会截断数字以适应类型的大小。例如：如果 `v:=uint16(0x10F0)`，然后 ``uint32(int8(v)) == 0xFFFFFFF0 。类型转换总是生成有效值，并且永远不会溢出。\n- 如果要将浮点数转换成整型，会丢弃小数部分（截断为零）。\n\n- 如果要将整型或浮点型转换成浮点数类型，或或者一个复数转换成其他复数类型，结果会四舍五入成指定精度。例如： 可以使用超出IEEE-754 32位数的附加精度来存储float32类型的变量x的值，但float32（x）表示将x的值舍入为32位精度的结果。x + 0.1 会使用超过 32 位的精度，而 `float32(x+0.1)` 不会。\n\n\n\n在所有浮点数和复数的非常量转换中，如果结构类型不能成功表示数据，那么结果将会依赖于具体平台实现。\n\n\n\n###### 字符串的类型转换\n\n\n\n1. 转换一个有符号或者无符号的整型值会转换成对应的 UTF-8 表示整型值。不在范围内的 Unicode 代码点会转换成 \"\\uFFFD\"。\n\n```go\nstring('a')       // \"a\"\nstring(-1)        // \"\\ufffd\" == \"\\xef\\xbf\\xbd\"\nstring(0xf8)      // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\"\ntype MyString string\nMyString(0x65e5)  // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\"\n```\n\n1. 将字节切片转换成字符串类型会生成一个由切片元素组成的字符串\n\n\n\n```go\nstring([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'})   // \"hellø\"\nstring([]byte{})                                     // \"\"\nstring([]byte(nil))                                  // \"\"\n\ntype MyBytes []byte\nstring(MyBytes{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'})  // \"hellø\"\n```\n\n\n\n1. 将 rune 切片转换成字符串类型会生成一个由切片元素组成的字符串\n\n\n\n```go\nstring([]rune{0x767d, 0x9d6c, 0x7fd4})   // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\"\nstring([]rune{})                         // \"\"\nstring([]rune(nil))                      // \"\"\n\ntype MyRunes []rune\nstring(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\"\n```\n\n\n\n1. 将字符串转换成字节切片会生成由字符串中每个字节组成的切片\n\n```go\n[]byte(\"hellø\")   // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}\n[]byte(\"\")        // []byte{}\n\nMyBytes(\"hellø\")  // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}\n```\n\n1. 将字符串转换成 rune 切片会生成由字符串中每个 Unicode 代码点组成的切片\n\n\n\n```go\n[]rune(MyString(\"白鵬翔\"))  // []rune{0x767d, 0x9d6c, 0x7fd4}\n[]rune(\"\")                 // []rune{}\n\nMyRunes(\"白鵬翔\")           // []rune{0x767d, 0x9d6c, 0x7fd4}\n```\n\n\n\n###### 常量表达式\n\n\n\n常量表达式只包含常量运算元并且在编译程序时就已经计算完成。\n\n\n\n无类型布尔值，数值和字符串常量都可以当作运算元。除了位置操作符，如果二元运算符石不同类型的常量，操作元，和非布尔值，和即将在接下来出现的：整型，rune，浮点数和复数类型。例如：一个无类型整型常量减去无类型复数常量，结果为复数常量。\n\n\n\n一个常量的比较运算会生成无类型的布尔常量。如果左移运算是一个无类型常量，结果会是一个整型常量。它会和原来常量为相同类型。其他与无类型常量的运算都会生成相同类型的结果（布尔值，整型，浮点数，复数，字符串常量）。\n\n\n\n```go\nconst a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)\nconst b = 15 / 4           // b == 3     (untyped integer constant)\nconst c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)\nconst Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)\nconst Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)\nconst d = 1 << 3.0         // d == 8     (untyped integer constant)\nconst e = 1.0 << 3         // e == 8     (untyped integer constant)\nconst f = int32(1) << 33   // illegal    (constant 8589934592 overflows int32)\nconst g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)\nconst h = \"foo\" > \"bar\"    // h == true  (untyped boolean constant)\nconst j = true             // j == true  (untyped boolean constant)\nconst k = 'w' + 1          // k == 'x'   (untyped rune constant)\nconst l = \"hi\"             // l == \"hi\"  (untyped string constant)\nconst m = string(k)        // m == \"x\"   (type string)\nconst Σ = 1 - 0.707i       //            (untyped complex constant)\nconst Δ = Σ + 2.0e-4       //            (untyped complex constant)\nconst Φ = iota*1i - 1/1i   //            (untyped complex constant)\n```\n\n\n\n对一个无类型整数，rune，或浮点数应用内置的 `complex` 函数会生成无类型的复数常量。\n\n\n\n```go\nconst ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)\nconst iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)\n```\n\n\n\n常量表达式总是一个明确的值；中间值和常量自己可以比语言所支持的精度更高，下面的声明是合法的：\n\n\n\n```go\nconst Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)\nconst Four int8 = Huge >> 98  // Four == 4                                (type int8)\n```\n\n\n\n常量的除法的除数不能为 0:\n\n\n\n```go\n3.14 / 0.0   // illegal: division by zero\n```\n\n\n\n定义了类型的常量的精度必须根据常量类型定义。所以下面的常量表达式是非法的：\n\n\n\n```go\nuint(-1)     // -1 cannot be represented as a uint\nint(3.14)    // 3.14 cannot be represented as an int\nint64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64\nFour * 300   // operand 300 cannot be represented as an int8 (type of Four)\nFour * 100   // product 400 cannot be represented as an int8 (type of Four)\n```\n\n\n\n补码使用的一元操作符 ^ 对于非常量的匹配模式：补码对于无符号常量为 1，对于有符号和无类型常量为 -1。\n\n\n\n```go\n^1         // untyped integer constant, equal to -2\nuint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8\n^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)\nint8(^1)   // same as int8(-2)\n^int8(1)   // same as -1 ^ int8(1) = -2\n```\n\n\n\n实现限制：编译器在处理无类型浮点数和复数时会取近似值；具体请看常量章节。这个取近似值的操作在浮点数在整数上下文时会产生无效值，即使在计算过后是一个整型。\n\n\n\n#### 运算优先级\n\n\n\n在包级别，初始化的依赖性由变量声明的初始化表达式顺序决定。否则，当计算表达式内的操作数时，赋值，返回语句，所有函数调用，方法调用，和通信操作都会由左向右计算。\n\n\n\n例如，在函数作用域中的赋值：\n\n\n\n```go\ny[f()], ok = g(h(), i()+x[j()], <-c), k()\n```\n\n\n\n函数调用和通信的发生顺序为：`f()`，`h()`，`i()`，`j()`，`<-c`，`g()` 和 `k()`。但是对 y 和 x 的取值操作没有指定。\n\n\n\n```go\na := 1\nf := func() int { a++; return a }\nx := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified\nm := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified\nn := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified\n```\n\n\n\n在包级别，依赖的初始化顺序会覆盖这个从左向右的规则：\n\n\n\n```go\nvar a, b, c = f() + v(), g(), sqr(u()) + v()\n\nfunc f() int        { return c }\nfunc g() int        { return a }\nfunc sqr(x int) int { return x*x }\n\n// functions u and v are independent of all other variables and functions\n```\n\n\n\n## 语句\n\n\n\n语句控制程序的执行。\n\n\n\n```go\nStatement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n```\n\n\n\n#### 终止语句\n\n\n\n终止语句会阻止相同代码块中下面所有语句的执行。以下语句属于终止语句：\n\n\n\n1. `return` 和 `goto` 语句\n2. 对内置 `panic` 函数的调用\n\n1. 代码块结束\n2. `if` 语句中：\n\n1. else 分支\n2. 所有分支末尾\n\n1. `for`语句中：\n\n1. `break` 语句和循环结束\n\n1. `switch` 语句：\n\n1. 在 `switch` 语句中没有 `break` 语句，\n2. 有一个默认的 case\n\n1. 语句列表中的每个 case 语句和有可能存在的 `fallthrough` 语句\n\n1. `select` 语句中：\n\n1. 没有 break 语句\n2. 每个 case 中的语句列表，如果包含默认 case\n\n\n\n所有其他语句都不是中断语句。\n\n\n\n如果语句序列不为空并且最后一个非空语句是终止语句，那么语句序列就以终结语句结尾。\n\n\n\n#### 空语句\n\n\n\n空语句不做任何事情。\n\n\n\n```go\nEmptyStmt = .\n```\n\n\n\n#### 标签语句\n\n\n\n标签语句可以作为 `goto`，`break` 和 `continue` 语句的目标。\n\n\n\n```go\nLabeledStmt = Label \":\" Statement .\nLabel       = identifier .\n```\n\n\n\n```go\nError: log.Panic(\"error encountered\")\n```\n\n\n\n#### 表达式语句\n\n\n\n除了特定的内置函数，一般的函数、方法和接收操作都可以出现在表达式语句的上下文中。这些语句可以使用括号括起来。\n\n\n\n```go\nExpressionStmt = Expression .\n```\n\n\n\n下面的内置函数不允许出现在语句的上下文中：\n\n\n\n```go\nappend cap complex imag len make new real\nunsafe.Alignof unsafe.Offsetof unsafe.Sizeof\n```\n\n\n\n```go\nh(x+y)\nf.Close()\n<-ch\n(<-ch)\nlen(\"foo\")  // illegal if len is the built-in function\n```\n\n\n\n#### 发送语句\n\n\n\n发送语句可以向通道发送一个值。通道表达式必须是通道类型，通道方向必须允许发送操作，并且值类型是可以分配给通道元素通道类型。\n\n\n\n```go\nSendStmt = Channel \"<-\" Expression .\nChannel  = Expression .\n```\n\n\n\n通道类型和值表达式会在发送之前求值。发送操作会一致阻塞，直到可以进行发送操作。如果接收者已经准备好向没有缓存的通道发送值可以立即执行。如果通道内还有缓存空间，向通道内发送值也会立即执行。向关闭的通道发送数据会导致运行时恐慌。像值为 nil 的通道发送数据会一直阻塞。\n\n\n\n```go\nch <- 3  // send value 3 to channel ch\n```\n\n\n\n#### 递增/递减语句\n\n\n\n“++” 和 “--” 语句可以递增或者递减运算元一个无类型常量 1。作为一个赋值语句，运算元必须是可寻址的或者 map 的索引表达式。\n\n\n\n```go\nIncDecStmt = Expression ( \"++\" | \"--\" ) .\n```\n\n\n\n下面的赋值语句在语义上是等价的：\n\n\n\n```go\nIncDec statement    Assignment\nx++                 x += 1\nx--                 x -= 1\n```\n\n\n\n#### 赋值\n\n\n\n```go\nAssignment = ExpressionList assign_op ExpressionList .\n\nassign_op = [ add_op | mul_op ] \"=\" .\n```\n\n\n\n所有左侧运算元都必须是可寻址的、map 索引表达式或空标识符其中之一。运算元可以用括号括起来。\n\n\n\n```go\nx = 1\n*p = f()\na[i] = 23\n(k) = <-ch  // same as: k = <-ch\n```\n\n\n\n对于赋值操作 `x op= y` 其中 `op` 为二元运算符，它和 `x=x op (y)` 是等价的，不过它只计算一次 x。`op=` 是单独的一个词汇单元，在赋值操作中左侧表达式和右侧表达式必须都是单值表达式，并且左侧表达式不能是空白标识符。\n\n\n\n```go\na[i] <<= 2\ni &^= 1<<n\n```\n\n\n\n元祖赋值语句会把运算返回的多个值分别分配给变量列表。它有两种格式，第一种：它是返回多值的表达式，例如函数调用、通道和 map 运算、类型断言。左侧运算元的数量必须等于返回值的数量。如果函数返回两个值：\n\n\n\n```go\nx, y = f()\n```\n\n\n\n它会将第一个返回值分配给 x ，把第二个返回值分配给 y。第二种格式中，左侧运算元的数量必须等于右侧运算元的数量。每个表达式都只能返回单一值，右侧第 n 个值会赋值给左侧第 n 个变量。\n\n\n\n```go\none, two, three = '一', '二', '三'\n```\n\n\n\n空标识符可以在分配时忽略一个右面位置的表达式：\n\n\n\n```go\n_ = x       // evaluate x but ignore it\nx, _ = f()  // evaluate f() but ignore second result value\n```\n\n\n\n赋值分为两个阶段。首先会计算左侧运算元的索引表达式和指针的解引用工作并以一定顺序计算右侧表达式的值。\n\n\n\n然后依次对左侧运算元赋值。\n\n\n\n```go\na, b = b, a  // exchange a and b\n\nx := []int{1, 2, 3}\ni := 0\ni, x[i] = 1, 2  // set i = 1, x[0] = 2\n\ni = 0\nx[i], i = 2, 1  // set x[0] = 2, i = 1\n\nx[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)\n\nx[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.\n\ntype Point struct { x, y int }\nvar p *Point\nx[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7\n\ni = 2\nx = []int{3, 5, 7}\nfor i, x[i] = range x {  // set i, x[2] = 0, x[0]\n\tbreak\n}\n// after this loop, i == 0 and x == []int{3, 5, 3}\n```\n\n\n\n在赋值语句中每个值都必须能分配给左侧指定类型的值。除了以下特例：\n\n\n\n1. 任何类型都能分配给空标识符。\n2. 如果把无类型常量分配给接口类型或者空标识符，它会转换成默认类型。\n\n1. 如果无类型的布尔值分配给了接口类型或者空标识符，它会先转换成 `bool` 类型。\n\n\n\n#### if 语句\n\n\n\n`if` 语句根据布尔值表达式的值来决定执行条件分支的代码。如果表达式为真，就执行 `if` 分支内的代码，否则执行 `else` 分支的代码。\n\n\n\n```go\nIfStmt = \"if\" [ SimpleStmt \";\" ] Expression Block [ \"else\" ( IfStmt | Block ) ] .\n```\n\n\n\n```go\nif x > max {\n\tx = max\n}\n```\n\n\n\n表达式可能先于普通语句，它会在表达式求值之前发生。\n\n\n\n```go\nif x := f(); x < y {\n\treturn x\n} else if x > z {\n\treturn z\n} else {\n\treturn y\n}\n```\n\n\n\n#### switch 语句\n\n\n\n#### for 语句\n\n\n\nfor 语句可以用来重复执行一段代码。它有三种格式：迭代器可以是单一条件、for 分句或者 range 语句。\n\n\n\n```go\nForStmt = \"for\" [ Condition | ForClause | RangeClause ] Block .\nCondition = Expression .\n```\n\n\n\n###### 单一条件的 for 语句\n\n\n\n这种情况下 for 会在条件为 true 时一直重复。条件会在每次迭代时都重新计算。如果没有指定条件，默认一直为 true。\n\n\n\n```go\nfor a < b {\n\ta *= 2\n}\n```\n\n\n\n###### 带分句的 for 语句\n\n\n\n带分句的 for 语句也是由条件控制，只是它有一个初始化和寄送的过程。例如赋值、递增或者递减语句。初始化语句可以是短变量声明，但是寄送语句不能。在初始化语句中声明的变量可以在迭代过程中使用。\n\n\n\n```go\nForClause = [ InitStmt ] \";\" [ Condition ] \";\" [ PostStmt ] .\nInitStmt = SimpleStmt .\nPostStmt = SimpleStmt .\n```\n\n\n\n```go\nfor i := 0; i < 10; i++ {\n\tf(i)\n}\n```\n\n\n\n如果初始化语句非空，它会在进入迭代前执行一次；post 语句在每次循环后都会执行一次。在只有条件的情况下可以省略分号。如果缺省条件语句，默认为 true。\n\n\n\n```go\nfor cond { S() }    is the same as    for ; cond ; { S() }\nfor      { S() }    is the same as    for true     { S() }\n```\n\n\n\n###### 带 range 分句的 for 语句\n\n\n\n带 range 分句的 for 语句可以访问数组、切片、字符串、map 的所有元素，还可以从通道中接收值。迭代获得元素分配给了相应的迭代变量并执行代码块。\n\n\n\n```go\nRangeClause = [ ExpressionList \"=\" | IdentifierList \":=\" ] \"range\" Expression .\n```\n\n\n\n右侧的 range 分句表达式叫做 range 表达式，它可能是数组、数组的指针、切片、字符串、map 或通道接收者类型。在分配时，左侧运算元必须是可寻址的或者 map 的索引表达式；它们作为迭代变量。如果 range 表达式是一个通道类型，至少需要有一个变量，它也可以有两个变量。如果迭代变量是空标识符，就代表在分句中不存在该标识符。\n\n\n\n```go\nRange expression                          1st value          2nd value\n\narray or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E\nstring          s  string type            index    i  int    see below  rune\nmap             m  map[K]V                key      k  K      m[k]       V\nchannel         c  chan E, <-chan E       element  e  E\n```\n\n\n\n```go\nvar testdata *struct {\n\ta *[7]int\n}\nfor i, _ := range testdata.a {\n\t// testdata.a is never evaluated; len(testdata.a) is constant\n\t// i ranges from 0 to 6\n\tf(i)\n}\n\nvar a [10]string\nfor i, s := range a {\n\t// type of i is int\n\t// type of s is string\n\t// s == a[i]\n\tg(i, s)\n}\n\nvar key string\nvar val interface {}  // element type of m is assignable to val\nm := map[string]int{\"mon\":0, \"tue\":1, \"wed\":2, \"thu\":3, \"fri\":4, \"sat\":5, \"sun\":6}\nfor key, val = range m {\n\th(key, val)\n}\n// key == last map key encountered in iteration\n// val == map[key]\n\nvar ch chan Work = producer()\nfor w := range ch {\n\tdoWork(w)\n}\n\n// empty a channel\nfor range ch {}\n```\n\n\n\n#### Go 语句\n\n\n\n`go` 语句会开始在相同地址空间中的单独 goroutine 中调用函数。\n\n\n\n```go\nGoStmt = \"go\" Expression .\n```\n\n\n\n表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数有表达式语句的限制。\n\n\n\n函数的值和参数会按顺序在调用的 goroutine 中求值。不像普通的函数调用，程序不会等待函数调用完成，而是直接开启一个新的 goroutine 执行函数。函数退出时，goroutine 也会退出。函数的任何返回值都会被丢弃。\n\n\n\n```go\ngo Server()\ngo func(ch chan<- bool) { for { sleep(10); ch <- true }} (c)\n```\n\n\n\n#### select 语句\n\n\n\nselect 语句会在接收/发送操作集中选择一个执行。它看起来和 switch 很像，只不过是专门针对通信操作的。\n\n\n\n```go\nSelectStmt = \"select\" \"{\" { CommClause } \"}\" .\nCommClause = CommCase \":\" StatementList .\nCommCase   = \"case\" ( SendStmt | RecvStmt ) | \"default\" .\nRecvStmt   = [ ExpressionList \"=\" | IdentifierList \":=\" ] RecvExpr .\nRecvExpr   = Expression .\n```\n\n\n\n接收表达式可以将接收表达式的值分配给一个或两个变量。接收表达式必须是一个接收运算元（可以使用括号括起来）。它最多允许有一个 default 语句。\n\n\n\nselect 语句执行以下几个步骤：\n\n\n\n1. 对于 select 语句的所有分句，接收操作的通道运算元、通道、发送语句的右侧表达式都会执行一次操作。\n2. 如果一个或多个通信同时发生，它会通过一致性随机选择一个执行。如果没有 default 语句，select 语句会一直阻塞。\n\n1. 除了 default 分句，其他分句只有在开始进行通信的时候才会执行。\n2. 如果 select 分句是一个接收语句，它可以给变量分配值。\n\n1. 执行 select 分句内的内容。\n\n\n\n如果向 nil 通道发送信息在没有 default 分句的情况下会一直阻塞。\n\n\n\n```go\nvar a []int\nvar c, c1, c2, c3, c4 chan int\nvar i1, i2 int\nselect {\ncase i1 = <-c1:\n\tprint(\"received \", i1, \" from c1\\n\")\ncase c2 <- i2:\n\tprint(\"sent \", i2, \" to c2\\n\")\ncase i3, ok := (<-c3):  // same as: i3, ok := <-c3\n\tif ok {\n\t\tprint(\"received \", i3, \" from c3\\n\")\n\t} else {\n\t\tprint(\"c3 is closed\\n\")\n\t}\ncase a[f()] = <-c4:\n\t// same as:\n\t// case t := <-c4\n\t//\ta[f()] = t\ndefault:\n\tprint(\"no communication\\n\")\n}\n\nfor {  // send random sequence of bits to c\n\tselect {\n\tcase c <- 0:  // note: no statement, no fallthrough, no folding of cases\n\tcase c <- 1:\n\t}\n}\n\nselect {}  // block forever\n```\n\n\n\n#### return 语句\n\n\n\n`return` 语句会终止函数 F 的执行并可选的返回一个或多个返回值。所有的滞后函数都会在 F 返回到它的调用者之前执行。\n\n\n\n```go\nReturnStmt = \"return\" [ ExpressionList ] .\n```\n\n\n\n如果函数没有返回值类型，return 不能返回任何值。\n\n\n\n```go\nfunc noResult() {\n\treturn\n}\n```\n\n\n\n有三种方式能够返回指定类型的值：\n\n\n\n1. 返回值可以直接在 return 语句中列出。每个表达式都必须返回一个值并且能够分配给相应的返回值类型。\n\n```go\nfunc simpleF() int {\n\treturn 2\n}\n\nfunc complexF1() (re float64, im float64) {\n\treturn -7.0, -4.0\n}\n```\n\n1. return 语句的表达式列表可以是一个返回多值的函数调用。这时会使用临时变量来获取函数调用的返回值并直接将其作为 return 语句的表达式列表。\n\n```go\nfunc complexF2() (re float64, im float64) {\n\treturn complexF1()\n}\n```\n\n1. 如果制定了返回值的标识符那么 return 的表达式列表可以为空。返回值参数会作为普通的本地变量按需分配。return 语句会直接返回它们。\n\n```go\nfunc complexF3() (re float64, im float64) {\n\tre = 7.0\n\tim = 4.0\n\treturn\n}\n\nfunc (devnull) Write(p []byte) (n int, _ error) {\n\tn = len(p)\n\treturn\n}\n```\n\n\n\n不管如何声明，所有的返回值都会在进入函数前提前初始化成类型的零值。return 语句会在所有 defer 函数之前指定返回值。\n\n\n\n实现限制：编译器不允许在覆盖了命名返回值的作用域中直接返回。\n\n\n\n```go\nfunc f(n int) (res int, err error) {\n\tif _, err := f(n-1); err != nil {\n\t\treturn  // invalid return statement: err is shadowed\n\t}\n\treturn\n}\n```\n\n\n\n#### break 语句\n\n\n\n`break` 语句会在 `for`、`switch` 或 `select` 语句内部退出到相同函数的某个位置。\n\n\n\n```go\nBreakStmt = \"break\" [ Label ] .\n```\n\n\n\n如果想指定标签，它必须出现在它所中止的 `for`、`switch` 或 `select` 语句旁。\n\n\n\n```go\nOuterLoop:\n\tfor i = 0; i < n; i++ {\n\t\tfor j = 0; j < m; j++ {\n\t\t\tswitch a[i][j] {\n\t\t\tcase nil:\n\t\t\t\tstate = Error\n\t\t\t\tbreak OuterLoop\n\t\t\tcase item:\n\t\t\t\tstate = Found\n\t\t\t\tbreak OuterLoop\n\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n#### continue 语句\n\n\n\n`continue` 语句会提前 `for` 语句的下一次迭代。`for` 语句必须和 `continue` 在相同函数中。\n\n\n\n```go\nRowLoop:\n\tfor y, row := range rows {\n\t\tfor x, data := range row {\n\t\t\tif data == endOfRow {\n\t\t\t\tcontinue RowLoop\n\t\t\t}\n\t\t\trow[x] = data + bias(x, y)\n\t\t}\n\t}\n```\n\n\n\n#### goto 语句\n\n\n\n`goto` 会将程序跳转到相同函数的指定标签处。\n\n\n\n```go\nGotoStmt = \"goto\" Label .\n```\n\n\n\n```go\ngoto Error\n```\n\n\n\ngoto 语句不允许跳过作用域内程序变量的初始化工作。\n\n\n\n```go\ngoto L  // BAD\n\tv := 3\nL:\n```\n\n\n\n上面的程序是错误的，因为它跳过了变量 v 的初始化过程。\n\n\n\n```go\nif n%2 == 1 {\n\tgoto L1\n}\nfor n > 0 {\n\tf()\n\tn--\nL1:\n\tf()\n\tn--\n}\n```\n\n\n\n标签作用域外的 goto 语句不能跳转到标签处，所以上面的代码是错误的。\n\n\n\n#### Fallthrough 语句\n\n\n\n`fallthrough` 语句会跳转到 `switch` 语句中的下一个 case 分句中。它应该只在最后一个非空分句中使用。\n\n\n\n```go\nFallthroughStmt = \"fallthrough\" .\n```\n\n\n\n#### Defer 语句\n\n\n\n`defer` 语句会在包裹函数返回后触发函数调用。这里的返回泛指函数因为 return 语句终止、到达函数末尾或者当前 goroutine 触发运行时恐慌。\n\n\n\n```go\nDeferStmt = \"defer\" Expression .\n```\n\n\n\n表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数会有一些限制。\n\n\n\n每次执行 defer 语句执行时都会计算函数的参数和值，但是并不会调用函数。相反，函数的调用是在包裹函数返回后进行，它们的执行顺序与声明顺序正好相反。如果 defer 对应的函数值为 nil，会在调用函数的时候导致运行时恐慌而不是声明 defer 语句的时候。\n\n\n\n例如：当 defer 函数为函数字面值且包裹函数具有命名结果值，此时，我们在defer 函数中可以访问和修改命名的结果值。defer 函数的所有返回值都会被忽略。\n\n\n\n```go\nlock(l)\ndefer unlock(l)  // unlocking happens before surrounding function returns\n\n// prints 3 2 1 0 before surrounding function returns\nfor i := 0; i <= 3; i++ {\n\tdefer fmt.Print(i)\n}\n\n// f returns 1\nfunc f() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\n```\n\n\n\n#### 内置函数\n\n\n\n内置函数是预定义的。调用他们和其他函数一样只是他们接受一个类型而不是一个表达式。\n\n\n\n内置函数没有标准的 Go 类型，所以他们只能作为调用表达式；而不能作为函数的值。\n\n\n\n###### Close\n\n\n\n对于管道类型 c，内置函数 `close(c)` 意味着不在有数据插入到管道中。如果 `c` 是一个只接收数据的管道，会发生错误。向已经关闭的发送数据或者重复关闭已经关闭的管道会导致运行时恐慌。关闭 nil 管道会引起运行时恐慌。调用 close 后所有之前发送的数据都能接收到，并且在最后不会阻塞而返回零值。多值的接收操作能够返回接收到的数据和表示管道是否关闭的布尔值。\n\n\n\n###### 长度和容积\n\n\n\n内置函数 `len` 和 `cap` 可以接收多种类型的参数，并且返回一个 int 类型结果值。函数的实现能够确保结果值不会溢出。\n\n\n\n```go\nCall      Argument type    Result\n\nlen(s)    string type      string length in bytes\n          [n]T, *[n]T      array length (== n)\n          []T              slice length\n          map[K]T          map length (number of defined keys)\n          chan T           number of elements queued in channel buffer\n\ncap(s)    [n]T, *[n]T      array length (== n)\n          []T              slice capacity\n          chan T           channel buffer capacity\n```\n\n\n\n切片的容积底层数组包含的元素个数。在任何情况下都有以下关系：\n\n\n\n```go\n0 <= len(s) <= cap(s)\n```\n\n\n\n`nil` 切片，map，或者 channel 的长度都为 0。`nil` 切片，管道的容积都为 0。\n\n\n\n表达式 `len(x)` 在 `s` 是字符串常量时也为常量。如果 `s` 为数组或者指向数组的指针并且表达式 s 不包含 `channel` 接收器或者函数调用那么 `len(s)` 和 `cap(s)` 也是常量；在这个情况下 s 时不能求值的。其他情况下 `len` 和 `cap` 不是常量并且 `s` 是可以求值的。\n\n\n\n```go\nconst (\n\tc1 = imag(2i)                    // imag(2i) = 2.0 is a constant\n\tc2 = len([10]float64{2})         // [10]float64{2} contains no function calls\n\tc3 = len([10]float64{c1})        // [10]float64{c1} contains no function calls\n\tc4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issued\n\tc5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call\n)\nvar z complex128\n```\n\n\n\n###### 内存分配\n\n\n\n内置函数 `new` 接收一个类型 T，它会在运行时给变量分配内存，并且返回一个指向类型 `T` 的 `*T` 类型指针。变量的初始化在初始化值章节中介绍。\n\n\n\n```go\nnew(T)\n```\n\n\n\n例如：\n\n\n\n```go\ntype S struct { a int; b float64 }\nnew(S)\n```\n\n\n\n给 S 类型的变量分配空间，并初始化它（`a=0`，`b=0.0`），并且返回一个 `*S` 类型值保存变量所在的位置。\n\n\n\n###### 创建切片，map 和 管道\n\n\n\n内置函数 `make` 以一个类型作为参数，它必须是一个切片，map 或者管道类型，它返回一个 T 类型的值，而不是（*T）类型，它会按初始化值章节描述的方式进行初始化。\n\n\n\n```go\nCall             Type T     Result\n\nmake(T, n)       slice      slice of type T with length n and capacity n\nmake(T, n, m)    slice      slice of type T with length n and capacity m\n\nmake(T)          map        map of type T\nmake(T, n)       map        map of type T with initial space for approximately n elements\n\nmake(T)          channel    unbuffered channel of type T\nmake(T, n)       channel    buffered channel of type T, buffer size n\n```\n\n\n\nn 和 m 必须是整数类型或者无类型常量。一个常量参数不能为负数并且该值在 `int` 类型的范围内；如果它是无类型常量，会被转换成 `int` 类型。如果 n 和 m 都是常量，那么 n 必须大于 m。如果 n 是负数或者大于 m 会引发运行时 panic。\n\n\n\n```go\ns := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100\ns := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000\ns := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int\ns := make([]int, 10, 0)         // illegal: len(s) > cap(s)\nc := make(chan int, 10)         // channel with a buffer size of 10\nm := make(map[string]int, 100)  // map with initial space for approximately 100 elements\n```\n\n\n\n使用 make 来指定大小初始化 map 类型将会创建一个预留 n 个元素空间的 map 类型。更详细的行为依赖于具体实现。\n\n\n\n###### 追加或者拷贝切片\n\n\n\n内置函数 `append` 和 `copy` 可以进行切片的通用操作。对于这两个函数，一个是拷贝内存，一个是引用内存。\n\n\n\n可变参数的函数 `append` 可以向切片 s 中追加一个或多个 x 值，并返回这个切片。传进 `...T` 的值会根据参数传值。作为特例，`append` 在 s 为 `[]byte` 切片时，可以使用字符串后面跟 `...` 作为参数。\n\n\n\n如果 s 的容积容纳不下这些元素，那么 `append` 会分配一个新的足够大的数组。否则会使用原来的底层数组。\n\n\n\n```go\ns0 := []int{0, 0}\ns1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}\ns2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}\ns3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}\ns4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}\n\nvar t []interface{}\nt = append(t, 42, 3.1415, \"foo\")   //                             t == []interface{}{42, 3.1415, \"foo\"}\n\nvar b []byte\nb = append(b, \"bar\"...)            // append string contents      b == []byte{'b', 'a', 'r' }\n```\n\n\n\n`copy` 函数从 `src` 拷贝原属到 `dst` 并且返回拷贝元素的个数。参数中所有的元素类型必须是 T 类型或者能转换成 T 的类型。拷贝元素的数量是 `len(src)` 和 `len(dst)` 中的较小值。作为特例，`copy` 可以从 string 类型拷贝元素到 `[]byte` 类型。这会把字符串中的元素拷贝到字节切片中。\n\n\n\n```go\ncopy(dst, src []T) int\ncopy(dst []byte, src string) int\n```\n\n\n\n例：\n\n\n\n```go\nvar a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}\nvar s = make([]int, 6)\nvar b = make([]byte, 5)\nn1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}\nn2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}\nn3 := copy(b, \"Hello, World!\")  // n3 == 5, b == []byte(\"Hello\")\n```\n\n\n\n###### 删除 map 中的元素\n\n\n\n内置函数 `delete` 移除 map 类型 m 中的键值 k。k 的类型必须是能够转换成 m 键类型的类型。\n\n\n\n```go\ndelete(m, k)  // remove element m[k] from map m\n```\n\n\n\n如果 map 类型 m 是 nil 或者 m[k] 不存在，那么 `delete` 函数不做任何事情。\n\n\n\n###### 操作复数\n\n\n\n有三个函数可以组装或者分解复数。内置函数 `complex` 会构造一个复数，`real` 和 `imag` 会分解出复数的实部和虚部。\n\n\n\n```go\ncomplex(realPart, imaginaryPart floatT) complexT\nreal(complexT) floatT\nimag(complexT) floatT\n```\n\n\n\n参数的类型和返回值类型是对应的。对于 `complex`，两个参数必须是相同的浮点类型，并返回由相同浮点数组成的复数类型。`complex64` 是 `float32` 对应的类型，`complex128` 是 `float64` 对应的参数类型。如果参数是一个无类型常量，它会转换成另一个参数的类型。如果两个参数都是无类型常量，他们必须实数或者虚数部分为零，并且它会返回一个无类型的复数常量。\n\n\n\n`real` 和 `imag` 函数和 `complex` 正好相反的，所以对于一个值复数类型 Z 的值 z，`z==Z(complex(real(z),imag(z)))`。\n\n\n\n如果这么操作都是常量，那么返回的值也是常量。\n\n\n\n```go\nvar a = complex(2, -2)             // complex128\nconst b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i\nx := float32(math.Cos(math.Pi/2))  // float32\nvar c64 = complex(5, -x)           // complex64\nvar s uint = complex(1, 0)         // untyped complex constant 1 + 0i can be converted to uint\n_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift\nvar rl = real(c64)                 // float32\nvar im = imag(a)                   // float64\nconst c = imag(b)                  // untyped constant -1.4\n_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift\n```\n\n\n\n###### 处理 panic\n\n\n\n两个内置函数 `panic` 和 `recover`，可以抛出和处理运行时 `panic` 和程序的错误条件。\n\n\n\n```go\nfunc panic(interface{})\nfunc recover() interface{}\n```\n\n\n\n当执行 F 函数时，显式的调用 `panic`或者运行时 panic 都会中断 F 的执行。但是 F 中的延迟函数还会执行。接下来调用 F 函数处的延迟函数也会执行，一直到顶级的延迟函数。鉴于这点，程序关闭并且错误条件可以抛出。包括 `panic` 中的值。这个顺序叫做 `panicking`。\n\n\n\n```go\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n```\n\n\n\n`recover` 函数允许程序从一个 panicking 中恢复执行。假设函数 G 延迟执行函数 D ，在 D 中调用 `recover` 这时如果在 G 执行时发生 panic 会在 D 中恢复。当函数执行到 D，`recover` 的返回值会返回 `panic` 对应的错误，并且终止 `panicking` 。在这个情况下 G 函数和 `panic` 之间的代码不会执行。任何在 D 中 G 之前的延迟函数会返回到调用者。\n\n\n\n在下面两种情况下 `recover` 会返回 nil：\n\n\n\n- panic 的参数为 nil\n- 携程里没有发生 panic\n\n- recover 不是在延迟函数中执行\n\n\n\n本例中的 `protect` 函数会在 g 发生 panic 的时候恢复执行。\n\n\n\n```go\nfunc protect(g func()) {\n\tdefer func() {\n\t\tlog.Println(\"done\")  // Println executes normally even if there is a panic\n\t\tif x := recover(); x != nil {\n\t\t\tlog.Printf(\"run time panic: %v\", x)\n\t\t}\n\t}()\n\tlog.Println(\"start\")\n\tg()\n}\n```\n\n\n\n###### 初始化\n\n\n\n这个实现提供了多个内置函数来帮助进行初始化。这些函数用来输出信息但是不确定会一直存在于语言中，他们都没有返回值。\n\n\n\n```go\nFunction   Behavior\n\nprint      prints all arguments; formatting of arguments is implementation-specific\nprintln    like print but prints spaces between arguments and a newline at the end\n```\n\n\n\n实现限制：`print` 和 `println` 不接受除了布尔值，数字，字符串以外的其他类型。\n\n\n\n#### 程序的初始化和执行\n\n\n\n###### 零值\n\n\n\n当为变量分配内存空间时，不管是声明还是调用 `new` 或者使用字面值和 `make` 初始化，只要创建了一个新值变量都会有一个默认值。这样的元素和值会使用它类型的零值：`false` 是布尔值的零值，0 为数值类型零值，\"\" 为字符串零值，nil 为指针，函数，接口，切片，频道，字典。初始化会递归完成，所以结构体里的数组中的元素也都会有它自己的零值。\n\n\n\n下面两个声明时相等的：\n\n\n\n```go\nvar i int\nvar i int = 0\n```\n\n\n\n请看下面的声明：\n\n\n\n```go\ntype T struct { i int; f float64; next *T }\nt := new(T)\nt.i == 0\nt.f == 0.0\nt.next == nil\n```\n\n\n\n这和下面的声明时同等效果的：\n\n\n\n```go\nvar t T\n```\n\n\n\n###### 包的初始化\n\n\n\n保级变量会按声明的顺序进行初始化，如果依赖其他变量，则会在其他变量之后进行初始化。\n\n\n\n更确切的说，如果包级变量还没初始化并且没有初始化表达式或者表达式中不包含对其他未初始化变量的依赖，那么会认为它正在等待初始化。初始化过程会从最早声明的变量开始向下一个包级变量重复，直到没有需要初始化的变量。\n\n\n\n如果在初始化过程完成后还有未初始化的变量，那么这些变量可能是循环初始化了，这事程序不是合法的。\n\n\n\n在多个文件中变量的声明顺序会依据编译时文件出现的顺序：声明在第一个文件中的变量优先于第二个文件中声明的变量，依此类推。\n\n\n\n对依赖关系的分析不会根据变量的具体值，它只分析在源码中是否引用了其他变量。例如，如果变量 x 的初始化表达式引用了变量 y 那么 x 就依赖于 y：\n\n\n\n- 引用一个变量或者函数中用到了一个变量\n- 引用了一个方法值 `m` 或者方法表达式 `t.m` (这里的静态类型 `t` 不是借口类型，并且方法 `m` 是 `t` 方法集中的方法)。`t.m` 的返回值不会在此时影响。\n\n- 变量，函数，或者方法 x 依赖变量 y\n\n\n\n依赖分析会在每个包中执行；他只考虑当前包中的析变量，函数，和方法。\n\n\n\n例如，给定声明：\n\n\n\n```go\nvar (\n\ta = c + b\n\tb = f()\n\tc = f()\n\td = 3\n)\n\nfunc f() int {\n\td++\n\treturn d\n}\n```\n\n\n\n初始化顺序为 d，b，c，a。\n\n\n\n变量可以在包中声明的初始化函数 `init` 中进行初始化，它没有参数和返回值。\n\n\n\n```go\nfunc init() {}\n```\n\n\n\n可以为每个包定义多个该函数，甚至在一个文件中也可以。并且不会声明该该标识符。因此 init 函数不能在程序中调用。\n\n\n\n还未导入的包会先初始化包级的变量然后按照 `init` 函数在源码中的顺序调用，它可能在包的多个文件中。如果需要导入一个包，它会在初始化自己之前先初始化这个需要导入的包。如果导入一个包多次，那这个包只会初始化一次。导入的包不能存在循环引用。\n\n\n\n包的初始化——变量初始化和对 init 函数的调用会按顺序发生在同一个 goroutine 中。 `init` 函数可能会启动其他 goroutine。不过一般 `init` 函数都是按序进行初始化的：它只在上一步已经执行完成时才会调用下一个步骤。\n\n\n\n确保初始化行为是可以复现的，构建系统鼓励在同一个包中包含多个文件这些文件在编译器中会以字母排序。\n\n\n\n###### 程序执行\n\n\n\n一个完整的程序由一个 `main` 包导入所有需要的包。`main` 包必须以 `main` 作为包名并且声明一个没有参数和返回值的 `main` 函数。\n\n\n\n```go\nfunc main() {}\n```\n\n\n\n程序先初始化 `main` 包然后调用 `main` 函数。当 `main` 函数返回时，程序就会退出。它不会等待其他 goroutines 完成。\n\n\n\n#### 错误\n\n\n\n预定义的错误类型为：\n\n\n\n```go\ntype error interface {\n\tError() string\n}\n```\n\n\n\n它是表示错误信息的常规接口，nil 代表没有发生错误。例如，在文件中读取数据可以定义为：\n\n\n\n```go\nfunc Read(f *File, b []byte) (n int, err error)\n```\n\n\n\n#### 运行时恐慌\n\n\n\n运行时错误（例如数组的越界访问）会造成运行时恐慌，它和以 `runtime.Error` 接口实现调用内置的 `panic` 函数一样。`runtime.Error` 满足预定义的 `error` 接口。不同的错误值代表不同的运行时错误条件。\n\n\n\n```go\npackage runtime\n\ntype Error interface {\n\terror\n\t// and perhaps other methods\n}\n```\n\n\n\n#### 系统相关\n\n\n\n###### unsafe 包\n\n\n\n`unsafe` 是编译器已知的内置包，可以通过导入路径 `unsafe` 访问包内容，提供 `unsafe` 包目的是支持底层编程（包括操作非 Go 类型的数据结构）。使用 `unsafe` 包必须自己保证类型安全而且它有可能破坏程序的移植性。`unsafe` 包提供了以下接口：\n\n\n\n```go\npackage unsafe\n\ntype ArbitraryType int  // 任意一个 Go 类型；它不是一个具体的类型。\ntype Pointer *ArbitraryType\n\nfunc Alignof(variable ArbitraryType) uintptr\nfunc Offsetof(selector ArbitraryType) uintptr\nfunc Sizeof(variable ArbitraryType) uintptr\n```\n\n\n\n`Pointer` 是一个指针类型，但是不能解引用 `Pointer` 的值。所有底层类型 `uintptr` 的指针和值都能转换成 `Pointer` 类型，反之亦然。`Pointer` 和  `uintptr` 之间的转换效果由具体实现定义。\n\n\n\n```go\nvar f float64\nbits = *(*uint64)(unsafe.Pointer(&f))\n\ntype ptr unsafe.Pointer\nbits = *(*uint64)(ptr(&f))\n\nvar p ptr = nil\n```\n\n\n\n假设变量 v 由 `var v = x` 定义。`Alignof` 以表达式 x 作为参数并返回 x 的对齐字节数。`Sizeof` 以表达式 x 作为参数并返回 x 的大小。\n\n\n\n函数 `Offsetof` 以选择器 `s.f`（ s 或者 *s 结构体中的 f 字段）作为参数，返回字段相对结构体首地址的位置。如果 f 是一个嵌入字段，那 f 必须可以直接访问（不能通过指针进行间接访问）。对于结构体 s 的 f 字段：\n\n\n\n```go\nuintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))\n```\n\n\n\n计算机的体系结构要求对齐内存地址（对于一个变量的地址有多种因素影响对齐）。`Alignof` 函数获取一个人和类型的表达式并返回变量对齐的字节数。对于变量 x：\n\n\n\n```go\nuintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0\n```\n\n\n\n编译时 `uintptr` 类型常量表达式会调用 `Alignof`，`Offsetof`，和 `Sizeof`。\n\n\n\n###### 确定的大小和对齐字节数\n\n\n\n对于数字类型，确定有以下尺寸：\n\n\n\n```go\ntype                                 size in bytes\n\nbyte, uint8, int8                     1\nuint16, int16                         2\nuint32, int32, float32                4\nuint64, int64, float64, complex64     8\ncomplex128                           16\n```\n\n\n\nGo 中规定的最小对齐特性：\n\n\n\n1. 对于任意变量类型 x：`unsafe.Alignof(x)` 至少为 1。\n2. 对于结构体类型：`unsafe.Alignof(x)` 是所有内部字段 `unsafe.Alignof(x.f)` 的最大值，并且至少为 1。\n\n1. 对于数组类型：`unsafe.Alignof(x)` 和数组元素类型的 alignment 相同。\n\n\n\n结构体（数组）在内部没有字段（元素）的时候大小为 0。两个所占空间大小为 0 的不同变量可能在内存中拥有相同地址。\n"
        },
        {
          "name": "Go 语言参考手册.pdf",
          "type": "blob",
          "size": 1035.443359375,
          "content": null
        },
        {
          "name": "Golang PPT",
          "type": "tree",
          "content": null
        },
        {
          "name": "Golang 入门笔记.md",
          "type": "blob",
          "size": 0.34765625,
          "content": "# Golang 入门笔记思维导图版：https://www.processon.com/view/link/611b35887d9c08015c29e2ba\n\n![Golang 入门笔记1](https://user-images.githubusercontent.com/87457873/129732962-f8159b4d-1baa-4776-9c9b-2f9c917310aa.png)\n\n![Golang 入门笔记2](https://user-images.githubusercontent.com/87457873/129733110-4a144b8e-dcbc-454f-8167-f65f7c330db0.png)\n"
        },
        {
          "name": "Golang 入门笔记.pdf",
          "type": "blob",
          "size": 511.28515625,
          "content": null
        },
        {
          "name": "Golang 新手可能会踩的 50 个坑.md",
          "type": "blob",
          "size": 65.076171875,
          "content": "## 前言\n\n\n\nGo 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。\n\n如果花时间学习官方 doc、wiki、[讨论邮件列表](https://groups.google.com/forum/#!forum/golang-nuts)、 [Rob Pike](https://github.com/robpike) 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。\n\n## 初级篇：1-34\n\n### 1. 左大括号 `{` 不能单独放一行\n\n在其他大多数语言中，`{` 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 `;` 来分隔多条语句，比如会在 `)` 后加分号：\n\n```go\n// 错误示例\nfunc main()\n{\n    println(\"hello world\")\n}\n\n// 等效于\nfunc main();    // 无函数体\n{\n    println(\"hello world\")\n}\n```\n\n> ./main.go: missing function body\n\n> ./main.go: syntax error: unexpected semicolon or newline before {\n\n```go\n// 正确示例\nfunc main() {\n    println(\"hello world\")\n}\n```\n\n### 2. 未使用的变量\n\n如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。\n\n即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：\n\n```go\n// 错误示例\nvar gvar int     // 全局变量，声明不使用也可以\n\nfunc main() {\n    var one int     // error: one declared and not used\n    two := 2    // error: two declared and not used\n    var three int    // error: three declared and not used\n    three = 3\n}\n\n// 正确示例\n// 可以直接注释或移除未使用的变量\nfunc main() {\n    var one int\n    _ = one\n\n    two := 2\n    println(two)\n\n    var three int\n    one = three\n\n    var four int\n    four = four\n}\n```\n\n### 3. 未使用的 import\n\n如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。\n\n可以使用 `_` 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 `init()`\n\n```go\n// 错误示例\nimport (\n    \"fmt\"    // imported and not used: \"fmt\"\n    \"log\"    // imported and not used: \"log\"\n    \"time\"    // imported and not used: \"time\"\n)\n\nfunc main() {\n}\n\n// 正确示例\n// 可以使用 goimports 工具来注释或移除未使用到的包\nimport (\n    _ \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n    _ = log.Println\n    _ = time.Now\n}\n```\n\n### 4. 简短声明的变量只能在函数内部使用\n\n```go\n// 错误示例\nmyvar := 1    // syntax error: non-declaration statement outside function body\nfunc main() {\n}\n\n// 正确示例\nvar  myvar = 1\nfunc main() {\n}\n```\n\n### 5. 使用简短声明来重复声明变量\n\n不能用简短声明方式来单独为一个变量重复声明， `:=` 左侧至少有一个新变量，才允许多变量的重复声明：\n\n```go\n// 错误示例\nfunc main() {\n    one := 0\n    one := 1 // error: no new variables on left side of :=\n}\n\n// 正确示例\nfunc main() {\n    one := 0\n    one, two := 1, 2    // two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err\n    one, two = two, one    // 交换两个变量值的简写\n}\n```\n\n### 6. 不能使用简短声明来设置字段的值\n\nstruct 的变量字段不能使用 `:=` 来赋值以使用预定义的变量来避免解决：\n\n```go\n// 错误示例\ntype info struct {\n    result int\n}\n\nfunc work() (int, error) {\n    return 3, nil\n}\n\nfunc main() {\n    var data info\n    data.result, err := work()    // error: non-name data.result on left side of :=\n    fmt.Printf(\"info: %+v\\n\", data)\n}\n\n// 正确示例\nfunc main() {\n    var data info\n    var err error    // err 需要预声明\n\n    data.result, err = work()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Printf(\"info: %+v\\n\", data)\n}\n```\n\n### 7. 不小心覆盖了变量\n\n对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 `:=` 是一个赋值操作符。\n\n如果你在新的代码块中像下边这样误用了 `:=`，编译不会报错，但是变量不会按你的预期工作：\n\n```go\nfunc main() {\n    x := 1\n    println(x)        // 1\n    {\n        println(x)    // 1\n        x := 2\n        println(x)    // 2    // 新的 x 变量的作用域只在代码块内部\n    }\n    println(x)        // 1\n}\n```\n\n这是 Go 开发者常犯的错，而且不易被发现。\n\n可使用 [vet](http://godoc.org/golang.org/x/tools/cmd/vet) 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 `-shadow` 选项来启用：\n\n```\n> go tool vet -shadow main.go\nmain.go:9: declaration of \"x\" shadows declaration at main.go:5\n```\n\n注意 vet 不会报告全部被覆盖的变量，可以使用 [go-nyet](https://github.com/barakmich/go-nyet) 来做进一步的检测：\n\n```go\n> $GOPATH/bin/go-nyet main.go\nmain.go:10:3:Shadowing variable `x`\n```\n\n### 8. 显式类型的变量无法使用 nil 来初始化\n\n`nil` 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。\n\n```go\n// 错误示例\nfunc main() {\n    var x = nil    // error: use of untyped nil\n    _ = x\n}\n\n// 正确示例\nfunc main() {\n    var x interface{} = nil\n    _ = x\n}\n```\n\n### 9. 直接使用值为 nil 的 slice、map\n\n允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic\n\n```go\n// map 错误示例\nfunc main() {\n    var m map[string]int\n    m[\"one\"] = 1        // error: panic: assignment to entry in nil map\n    // m := make(map[string]int)// map 的正确声明，分配了实际的内存\n}\n\n// slice 正确示例\nfunc main() {\n    var s []int\n    s = append(s, 1)\n}\n```\n\n### 10. map 容量\n\n在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 `cap()` 来检测分配空间的大小：\n\n```go\n// 错误示例\nfunc main() {\n    m := make(map[string]int, 99)\n    println(cap(m))     // error: invalid argument m1 (type map[string]int) for cap\n}\n```\n\n### 11. string 类型的变量值不能为 nil\n\n对那些喜欢用 `nil` 初始化字符串的人来说，这就是坑：\n\n```go\n// 错误示例\nfunc main() {\n    var s string = nil    // cannot use nil as type string in assignment\n    if s == nil {    // invalid operation: s == nil (mismatched types string and nil)\n        s = \"default\"\n    }\n}\n\n// 正确示例\nfunc main() {\n    var s string    // 字符串类型的零值是空串 \"\"\n    if s == \"\" {\n        s = \"default\"\n    }\n}\n```\n\n### 12. Array 类型的值作为函数参数\n\n在 C/C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。\n\n在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：\n\n```go\n// 数组使用值拷贝传参\nfunc main() {\n    x := [3]int{1,2,3}\n\n    func(arr [3]int) {\n        arr[0] = 7\n        fmt.Println(arr)    // [7 2 3]\n    }(x)\n    fmt.Println(x)            // [1 2 3]    // 并不是你以为的 [7 2 3]\n}\n```\n\n如果想修改参数数组：\n\n- 直接传递指向这个数组的指针类型：\n\n```go\n// 传址会修改原数据\nfunc main() {\n    x := [3]int{1,2,3}\n\n    func(arr *[3]int) {\n        (*arr)[0] = 7\n        fmt.Println(arr)    // &[7 2 3]\n    }(&x)\n    fmt.Println(x)    // [7 2 3]\n}\n```\n\n- 直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）\n\n```go\n// 会修改 slice 的底层 array，从而修改 slice\nfunc main() {\n    x := []int{1, 2, 3}\n    func(arr []int) {\n        arr[0] = 7\n        fmt.Println(x)    // [7 2 3]\n    }(x)\n    fmt.Println(x)    // [7 2 3]\n}\n```\n\n### 13. range 遍历 slice 和 array 时混淆了返回值\n\n与其他编程语言中的 `for-in` 、`foreach` 遍历语句不同，Go 中的 `range` 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：\n\n```go\n// 错误示例\nfunc main() {\n    x := []string{\"a\", \"b\", \"c\"}\n    for v := range x {\n        fmt.Println(v)    // 0 1 2\n    }\n}\n\n// 正确示例\nfunc main() {\n    x := []string{\"a\", \"b\", \"c\"}\n    for _, v := range x {    // 使用 _ 丢弃索引\n        fmt.Println(v)\n    }\n}\n```\n\n### 14. slice 和 array 其实是一维数据\n\n看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。\n\n对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。\n\n可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。\n\n1. 使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。\n2. 使用“独立”的切片分两步：\n\n- 创建外部 slice\n\n- 对每个内部 slice 进行内存分配\n  注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice\n\n```go\n// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组\nfunc main() {\n    x := 2\n    y := 4\n\n    table := make([][]int, x)\n    for i  := range table {\n        table[i] = make([]int, y)\n    }\n}\n```\n\n1. 使用“共享底层数组”的切片\n\n- 创建一个存放原始数据的容器 slice\n- 创建其他的 slice\n\n- 切割原始 slice 来初始化其他的 slice\n\n```go\nfunc main() {\n    h, w := 2, 4\n    raw := make([]int, h*w)\n\n    for i := range raw {\n        raw[i] = i\n    }\n\n    // 初始化原始 slice\n    fmt.Println(raw, &raw[4])    // [0 1 2 3 4 5 6 7] 0xc420012120\n\n    table := make([][]int, h)\n    for i := range table {\n\n        // 等间距切割原始 slice，创建动态多维数组 table\n        // 0: raw[0*4: 0*4 + 4]\n        // 1: raw[1*4: 1*4 + 4]\n        table[i] = raw[i*w : i*w + w]\n    }\n\n    fmt.Println(table, &table[1][0])    // [[0 1 2 3] [4 5 6 7]] 0xc420012120\n}\n```\n\n更多关于多维数组的参考\n\n[go-how-is-two-dimensional-arrays-memory-representation](https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation)\n\n[what-is-a-concise-way-to-create-a-2d-slice-in-go](https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go)\n\n### 15. 访问 map 中不存在的 key\n\n和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：\n\n```\n> php -r '$v = [\"x\"=>1, \"y\"=>2]; @var_dump($v[\"z\"]);'\nNULL\n```\n\nGo 则会返回元素对应数据类型的零值，比如 `nil`、`''` 、`false` 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。\n\n检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：\n\n```go\n// 错误的 key 检测方式\nfunc main() {\n    x := map[string]string{\"one\": \"2\", \"two\": \"\", \"three\": \"3\"}\n    if v := x[\"two\"]; v == \"\" {\n        fmt.Println(\"key two is no entry\")    // 键 two 存不存在都会返回的空字符串\n    }\n}\n\n// 正确示例\nfunc main() {\n    x := map[string]string{\"one\": \"2\", \"two\": \"\", \"three\": \"3\"}\n    if _, ok := x[\"two\"]; !ok {\n        fmt.Println(\"key two is no entry\")\n    }\n}\n```\n\n### 16. string 类型的值是常量，不可更改\n\n尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。\n\nstring 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：\n\n```go\n// 修改字符串的错误示例\nfunc main() {\n    x := \"text\"\n    x[0] = \"T\"        // error: cannot assign to x[0]\n    fmt.Println(x)\n}\n\n// 修改示例\nfunc main() {\n    x := \"text\"\n    xBytes := []byte(x)\n    xBytes[0] = 'T'    // 注意此时的 T 是 rune 类型\n    x = string(xBytes)\n    fmt.Println(x)    // Text\n}\n```\n\n**注意：** 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。\n\n更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符\n\n```go\nfunc main() {\n    x := \"text\"\n    xRunes := []rune(x)\n    xRunes[0] = '我'\n    x = string(xRunes)\n    fmt.Println(x)    // 我ext\n}\n```\n\n### 17. string 与 byte slice 之间的转换\n\n当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。\n\nGo 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：\n\n- 在 `map[string]` 中查找 key 时，使用了对应的 `[]byte`，避免做 `m[string(key)]` 的内存分配\n- 使用 `for range` 迭代 string 转换为 []byte 的迭代：`for i,v := range []byte(str) {...}`\n\n雾：[参考原文](http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv)\n\n### 18. string 与索引操作符\n\n对字符串用索引访问返回的不是字符，而是一个 byte 值。\n\n这种处理方式和其他语言一样，比如 PHP 中：\n\n```php\n> php -r '$name=\"中文\"; var_dump($name);'    # \"中文\" 占用 6 个字节\nstring(6) \"中文\"\n\n> php -r '$name=\"中文\"; var_dump($name[0]);' # 把第一个字节当做 Unicode 字符读取，显示 U+FFFD\nstring(1) \"�\"\n\n> php -r '$name=\"中文\"; var_dump($name[0].$name[1].$name[2]);'\nstring(3) \"中\"\n```\n\n```go\nfunc main() {\n    x := \"ascii\"\n    fmt.Println(x[0])        // 97\n    fmt.Printf(\"%T\\n\", x[0])// uint8\n}\n```\n\n如果需要使用 `for range` 迭代访问字符串中的字符（unicode code point / rune），标准库中有 `\"unicode/utf8\"` 包来做 UTF8 的相关解码编码。另外 [utf8string](https://godoc.org/golang.org/x/exp/utf8string) 也有像 `func (s *String) At(i int) rune` 等很方便的库函数。\n\n### 19. 字符串并不都是 UTF8 文本\n\nstring 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。\n\n判断字符串是否是 UTF8 文本，可使用 \"unicode/utf8\" 包中的 `ValidString()` 函数：\n\n```go\nfunc main() {\n    str1 := \"ABC\"\n    fmt.Println(utf8.ValidString(str1))    // true\n\n    str2 := \"A\\xfeC\"\n    fmt.Println(utf8.ValidString(str2))    // false\n\n    str3 := \"A\\\\xfeC\"\n    fmt.Println(utf8.ValidString(str3))    // true    // 把转义字符转义成字面值\n}\n```\n\n### 20. 字符串的长度\n\n在 Python 中：\n\n```Python \ndata = u'♥'\nprint(len(data)) # 1\n```\n\n然而在 Go 中：\n\n```go\nfunc main() {\n    char := \"♥\"\n    fmt.Println(len(char))    // 3\n}\n```\n\nGo 的内建函数 `len()` 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。\n\n如果要得到字符串的字符数，可使用 \"unicode/utf8\" 包中的 `RuneCountInString(str string) (n int)`\n\n```go\nfunc main() {\n    char := \"♥\"\n    fmt.Println(utf8.RuneCountInString(char))    // 1\n}\n```\n\n**注意：**`RuneCountInString` 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：\n\n```\nfunc main() {\n    char := \"é\"\n    fmt.Println(len(char))    // 3\n    fmt.Println(utf8.RuneCountInString(char))    // 2\n    fmt.Println(\"cafe\\u0301\")    // café    // 法文的 cafe，实际上是两个 rune 的组合\n}\n```\n\n参考：[normalization](https://blog.golang.org/normalization)\n\n### 21. 在多行 array、slice、map 语句中缺少 `,` 号\n\n```go\nfunc main() {\n    x := []int {\n        1,\n        2    // syntax error: unexpected newline, expecting comma or }\n    }\n    y := []int{1,2,}\n    z := []int{1,2}\n    // ...\n}\n```\n\n声明语句中 `}` 折叠到单行后，尾部的 `,` 不是必需的。\n\n### 22. `log.Fatal` 和 `log.Panic` 不只是 log\n\nlog 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 `Fatal*()`、`Panic*()` 时能做更多日志外的事，如中断程序的执行等：\n\n```go\nfunc main() {\n    log.Fatal(\"Fatal level log: log entry\")        // 输出信息后，程序终止执行\n    log.Println(\"Nomal level log: log entry\")\n}\n```\n\n### 23. 对内建数据结构的操作并不是同步的\n\n尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。\n\ngoroutine 和 channel 是进行原子操作的好方法，或使用 \"sync\" 包中的锁。\n\n### 24. range 迭代 string 得到的值\n\nrange 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。\n\n注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用[norm](https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/) 包。\n\nfor range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。\n\n```go\nfunc main() {\n    data := \"A\\xfe\\x02\\xff\\x04\"\n    for _, v := range data {\n        fmt.Printf(\"%#x \", v)    // 0x41 0xfffd 0x2 0xfffd 0x4    // 错误\n    }\n\n    for _, v := range []byte(data) {\n        fmt.Printf(\"%#x \", v)    // 0x41 0xfe 0x2 0xff 0x4    // 正确\n    }\n}\n```\n\n### 25. range 迭代 map\n\n如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。\n\nGo 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：\n\n```go\nfunc main() {\n    m := map[string]int{\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n    for k, v := range m {\n        fmt.Println(k, v)\n    }\n}\n```\n\n如果你去 [Go Playground](https://play.golang.org/) 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079494-de9e6a55-0bd7-4d37-9cf8-4edc3c9ee978.png)\n\n\n\n### 26. switch 中的 fallthrough 语句\n\n`switch` 语句中的 `case` 代码块会默认带上 break，但可以使用 `fallthrough` 来强制执行下一个 case 代码块。\n\n```go\nfunc main() {\n    isSpace := func(char byte) bool {\n        switch char {\n        case ' ':    // 空格符会直接 break，返回 false // 和其他语言不一样\n        // fallthrough    // 返回 true\n        case '\\t':\n            return true\n        }\n        return false\n    }\n    fmt.Println(isSpace('\\t'))    // true\n    fmt.Println(isSpace(' '))    // false\n}\n```\n\n不过你可以在 case 代码块末尾使用 `fallthrough`，强制执行下一个 case 代码块。\n\n也可以改写 case 为多条件判断：\n\n```go\nfunc main() {\n    isSpace := func(char byte) bool {\n        switch char {\n        case ' ', '\\t':\n            return true\n        }\n        return false\n    }\n    fmt.Println(isSpace('\\t'))    // true\n    fmt.Println(isSpace(' '))    // true\n}\n```\n\n### 27. 自增和自减运算\n\n很多编程语言都自带前置后置的 `++`、`--` 运算。但 Go 特立独行，去掉了前置操作，同时 `++`、`—` 只作为运算符而非表达式。\n\n```go\n// 错误示例\nfunc main() {\n    data := []int{1, 2, 3}\n    i := 0\n    ++i            // syntax error: unexpected ++, expecting }\n    fmt.Println(data[i++])    // syntax error: unexpected ++, expecting :\n}\n\n// 正确示例\nfunc main() {\n    data := []int{1, 2, 3}\n    i := 0\n    i++\n    fmt.Println(data[i])    // 2\n}\n```\n\n### 28. 按位取反\n\n很多编程语言使用 `~` 作为一元按位取反（NOT）操作符，Go 重用 `^` XOR 操作符来按位取反：\n\n```go\n// 错误的取反操作\nfunc main() {\n    fmt.Println(~2)        // bitwise complement operator is ^\n}\n\n// 正确示例\nfunc main() {\n    var d uint8 = 2\n    fmt.Printf(\"%08b\\n\", d)        // 00000010\n    fmt.Printf(\"%08b\\n\", ^d)    // 11111101\n}\n```\n\n同时 `^` 也是按位异或（XOR）操作符。\n\n一个操作符能重用两次，是因为一元的 NOT 操作 `NOT 0x02`，与二元的 XOR 操作 `0x22 XOR 0xff` 是一致的。\n\nGo 也有特殊的操作符 AND NOT `&^` 操作符，不同位才取1。\n\n```go\nfunc main() {\n    var a uint8 = 0x82\n    var b uint8 = 0x02\n    fmt.Printf(\"%08b [A]\\n\", a)\n    fmt.Printf(\"%08b [B]\\n\", b)\n\n    fmt.Printf(\"%08b (NOT B)\\n\", ^b)\n    fmt.Printf(\"%08b ^ %08b = %08b [B XOR 0xff]\\n\", b, 0xff, b^0xff)\n\n    fmt.Printf(\"%08b ^ %08b = %08b [A XOR B]\\n\", a, b, a^b)\n    fmt.Printf(\"%08b & %08b = %08b [A AND B]\\n\", a, b, a&b)\n    fmt.Printf(\"%08b &^%08b = %08b [A 'AND NOT' B]\\n\", a, b, a&^b)\n    fmt.Printf(\"%08b&(^%08b)= %08b [A AND (NOT B)]\\n\", a, b, a&(^b))\n}\n```\n\n```go\n10000010 [A]\n00000010 [B]\n11111101 (NOT B)\n00000010 ^ 11111111 = 11111101 [B XOR 0xff]\n10000010 ^ 00000010 = 10000000 [A XOR B]\n10000010 & 00000010 = 00000010 [A AND B]\n10000010 &^00000010 = 10000000 [A 'AND NOT' B]\n10000010&(^00000010)= 10000000 [A AND (NOT B)]\n```\n\n### 29. 运算符的优先级\n\n除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。\n\n```go\nfunc main() {\n    fmt.Printf(\"0x2 & 0x2 + 0x4 -> %#x\\n\", 0x2&0x2+0x4)    // & 优先 +\n    //prints: 0x2 & 0x2 + 0x4 -> 0x6\n    //Go:    (0x2 & 0x2) + 0x4\n    //C++:    0x2 & (0x2 + 0x4) -> 0x2\n\n    fmt.Printf(\"0x2 + 0x2 << 0x1 -> %#x\\n\", 0x2+0x2<<0x1)    // << 优先 +\n    //prints: 0x2 + 0x2 << 0x1 -> 0x6\n    //Go:     0x2 + (0x2 << 0x1)\n    //C++:   (0x2 + 0x2) << 0x1 -> 0x8\n\n    fmt.Printf(\"0xf | 0x2 ^ 0x2 -> %#x\\n\", 0xf|0x2^0x2)    // | 优先 ^\n    //prints: 0xf | 0x2 ^ 0x2 -> 0xd\n    //Go:    (0xf | 0x2) ^ 0x2\n    //C++:    0xf | (0x2 ^ 0x2) -> 0xf\n}\n```\n\n优先级列表：\n\n```go\nPrecedence    Operator\n    5             *  /  %  <<  >>  &  &^\n    4             +  -  |  ^\n    3             ==  !=  <  <=  >  >=\n    2             &&\n    1             ||\n```\n\n### 30. 不导出的 struct 字段无法被 encode\n\n以小写字母开头的字段成员是无法被外部直接访问的，所以 `struct` 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：\n\n```go\nfunc main() {\n    in := MyData{1, \"two\"}\n    fmt.Printf(\"%#v\\n\", in)    // main.MyData{One:1, two:\"two\"}\n\n    encoded, _ := json.Marshal(in)\n    fmt.Println(string(encoded))    // {\"One\":1}    // 私有字段 two 被忽略了\n\n    var out MyData\n    json.Unmarshal(encoded, &out)\n    fmt.Printf(\"%#v\\n\", out)     // main.MyData{One:1, two:\"\"}\n}\n```\n\n### 31. 程序退出时还有 goroutine 在执行\n\n程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：\n\n```go\n// 主程序会直接退出\nfunc main() {\n    workerCount := 2\n    for i := 0; i < workerCount; i++ {\n        go doIt(i)\n    }\n    time.Sleep(1 * time.Second)\n    fmt.Println(\"all done!\")\n}\n\nfunc doIt(workerID int) {\n    fmt.Printf(\"[%v] is running\\n\", workerID)\n    time.Sleep(3 * time.Second)        // 模拟 goroutine 正在执行\n    fmt.Printf(\"[%v] is done\\n\", workerID)\n}\n```\n\n如下，`main()` 主程序不等两个 goroutine 执行完就直接退出了：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079610-d9523090-8363-463a-b6f0-aa4e55a1b7ef.png)\n\n\n\n常用解决办法：使用 \"WaitGroup\" 变量，它会让主程序等待所有 goroutine 执行完毕再退出。\n\n如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 `kill` 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：\n\n```go\n// 等待所有 goroutine 执行完毕\n// 进入死锁\nfunc main() {\n    var wg sync.WaitGroup\n    done := make(chan struct{})\n\n    workerCount := 2\n    for i := 0; i < workerCount; i++ {\n        wg.Add(1)\n        go doIt(i, done, wg)\n    }\n\n    close(done)\n    wg.Wait()\n    fmt.Println(\"all done!\")\n}\n\nfunc doIt(workerID int, done <-chan struct{}, wg sync.WaitGroup) {\n    fmt.Printf(\"[%v] is running\\n\", workerID)\n    defer wg.Done()\n    <-done\n    fmt.Printf(\"[%v] is done\\n\", workerID)\n}\n```\n\n执行结果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079522-5d8f767c-aa6d-4960-bcd3-795aca54b1da.png)\n\n\n\n看起来好像 goroutine 都执行完了，然而报错：\n\nfatal error: all goroutines are asleep - deadlock!\n\n为什么会发生死锁？goroutine 在退出前调用了 `wg.Done()` ，程序应该正常退出的。\n\n原因是 goroutine 得到的 \"WaitGroup\" 变量是 `var wg WaitGroup` 的一份拷贝值，即 `doIt()` 传参只传值。所以哪怕在每个 goroutine 中都调用了 `wg.Done()`， 主程序中的 `wg` 变量并不会受到影响。\n\n```go\n// 等待所有 goroutine 执行完毕\n// 使用传址方式为 WaitGroup 变量传参\n// 使用 channel 关闭 goroutine\n\nfunc main() {\n    var wg sync.WaitGroup\n    done := make(chan struct{})\n    ch := make(chan interface{})\n\n    workerCount := 2\n    for i := 0; i < workerCount; i++ {\n        wg.Add(1)\n        go doIt(i, ch, done, &wg)    // wg 传指针，doIt() 内部会改变 wg 的值\n    }\n\n    for i := 0; i < workerCount; i++ {    // 向 ch 中发送数据，关闭 goroutine\n        ch <- i\n    }\n\n    close(done)\n    wg.Wait()\n    close(ch)\n    fmt.Println(\"all done!\")\n}\n\nfunc doIt(workerID int, ch <-chan interface{}, done <-chan struct{}, wg *sync.WaitGroup) {\n    fmt.Printf(\"[%v] is running\\n\", workerID)\n    defer wg.Done()\n    for {\n        select {\n        case m := <-ch:\n            fmt.Printf(\"[%v] m => %v\\n\", workerID, m)\n        case <-done:\n            fmt.Printf(\"[%v] is done\\n\", workerID)\n            return\n        }\n    }\n}\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-48ae068a-8fe5-49b8-ba79-6aecc941525a.png)\n\n\n\n### 32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回\n\n只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：\n\n```go\nfunc main() {\n    ch := make(chan string)\n\n    go func() {\n        for m := range ch {\n            fmt.Println(\"Processed:\", m)\n            time.Sleep(1 * time.Second)    // 模拟需要长时间运行的操作\n        }\n    }()\n\n    ch <- \"cmd.1\"\n    ch <- \"cmd.2\" // 不会被接收处理\n}\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079544-84c1140a-23ae-4858-80b7-b0adf759ee18.png)\n\n\n\n### 33. 向已关闭的 channel 发送数据会造成 panic\n\n从已关闭的 channel 接收数据是安全的：\n\n接收状态值 `ok` 是 `false` 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 `false`\n\n向已关闭的 channel 中发送数据会造成 panic：\n\n```go\nfunc main() {\n    ch := make(chan int)\n    for i := 0; i < 3; i++ {\n        go func(idx int) {\n            ch <- idx\n        }(i)\n    }\n\n    fmt.Println(<-ch)        // 输出第一个发送的值\n    close(ch)            // 不能关闭，还有其他的 sender\n    time.Sleep(2 * time.Second)    // 模拟做其他的操作\n}\n```\n\n运行结果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-645d7d98-a284-417a-94d0-a0b810b6d032.png)\n\n\n\n针对上边有 bug 的这个例子，可使用一个废弃 channel `done` 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 `<- done` 的结果是 `{}`：\n\n```go\nfunc main() {\n    ch := make(chan int)\n    done := make(chan struct{})\n\n    for i := 0; i < 3; i++ {\n        go func(idx int) {\n            select {\n            case ch <- (idx + 1) * 2:\n                fmt.Println(idx, \"Send result\")\n            case <-done:\n                fmt.Println(idx, \"Exiting\")\n            }\n        }(i)\n    }\n\n    fmt.Println(\"Result: \", <-ch)\n    close(done)\n    time.Sleep(3 * time.Second)\n}\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079515-81889255-1ad8-424a-9b46-20de774153b4.png)\n\n\n\n### 34. 使用了值为 `nil` 的 channel\n\n在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：\n\n```go\nfunc main() {\n    var ch chan int // 未初始化，值为 nil\n    for i := 0; i < 3; i++ {\n        go func(i int) {\n            ch <- i\n        }(i)\n    }\n\n    fmt.Println(\"Result: \", <-ch)\n    time.Sleep(2 * time.Second)\n}\n```\n\nruntime 死锁错误：\n\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan receive (nil chan)]\n\n利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：\n\n```go\nfunc main() {\n    inCh := make(chan int)\n    outCh := make(chan int)\n\n    go func() {\n        var in <-chan int = inCh\n        var out chan<- int\n        var val int\n\n        for {\n            select {\n            case out <- val:\n                println(\"--------\")\n                out = nil\n                in = inCh\n            case val = <-in:\n                println(\"++++++++++\")\n                out = outCh\n                in = nil\n            }\n        }\n    }()\n\n    go func() {\n        for r := range outCh {\n            fmt.Println(\"Result: \", r)\n        }\n    }()\n\n    time.Sleep(0)\n    inCh <- 1\n    inCh <- 2\n    time.Sleep(3 * time.Second)\n}\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079586-ec05c601-40cf-4ae1-b8f6-c02b63226d74.png)\n\n\n\n### 34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值\n\n方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。\n\n除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:\n\n```go\ntype data struct {\n    num   int\n    key   *string\n    items map[string]bool\n}\n\nfunc (this *data) pointerFunc() {\n    this.num = 7\n}\n\nfunc (this data) valueFunc() {\n    this.num = 8\n    *this.key = \"valueFunc.key\"\n    this.items[\"valueFunc\"] = true\n}\n\nfunc main() {\n    key := \"key1\"\n\n    d := data{1, &key, make(map[string]bool)}\n    fmt.Printf(\"num=%v  key=%v  items=%v\\n\", d.num, *d.key, d.items)\n\n    d.pointerFunc()    // 修改 num 的值为 7\n    fmt.Printf(\"num=%v  key=%v  items=%v\\n\", d.num, *d.key, d.items)\n\n    d.valueFunc()    // 修改 key 和 items 的值\n    fmt.Printf(\"num=%v  key=%v  items=%v\\n\", d.num, *d.key, d.items)\n}\n```\n\n运行结果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-aac01481-dec9-4479-b0be-d9f7165af772.png)\n\n\n\n## 中级篇：35-50\n\n### 35. 关闭 HTTP 的响应体\n\n使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：\n\n```go\n// 请求失败造成 panic\nfunc main() {\n    resp, err := http.Get(\"https://api.ipify.org?format=json\")\n    defer resp.Body.Close()    // resp 可能为 nil，不能读取 Body\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    checkError(err)\n\n    fmt.Println(string(body))\n}\n\nfunc checkError(err error) {\n    if err != nil{\n        log.Fatalln(err)\n    }\n}\n```\n\n上边的代码能正确发起请求，但是一旦请求失败，变量 `resp` 值为 `nil`，造成 panic：\n\npanic: runtime error: invalid memory address or nil pointer dereference\n\n应该先检查HTTP 响应错误为 `nil`，再调用 `resp.Body.Close()` 来关闭响应体：\n\n```go\n// 大多数情况正确的示例\nfunc main() {\n    resp, err := http.Get(\"https://api.ipify.org?format=json\")\n    checkError(err)\n\n    defer resp.Body.Close()    // 绝大多数情况下的正确关闭方式\n    body, err := ioutil.ReadAll(resp.Body)\n    checkError(err)\n\n    fmt.Println(string(body))\n}\n```\n\n输出：\n\nGet [https://api.ipify.org?format=...](https://api.ipify.org?format=json): x509: certificate signed by unknown authority\n\n绝大多数请求失败的情况下，`resp` 的值为 `nil` 且 `err` 为 `non-nil`。但如果你得到的是重定向错误，那它俩的值都是 `non-nil`，最后依旧可能发生内存泄露。2 个解决办法：\n\n- 可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。\n- 手动调用 `defer` 来关闭响应体：\n\n```go\n// 正确示例\nfunc main() {\n    resp, err := http.Get(\"http://www.baidu.com\")\n\n    // 关闭 resp.Body 的正确姿势\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n\n    checkError(err)\n    defer resp.Body.Close()\n\n    body, err := ioutil.ReadAll(resp.Body)\n    checkError(err)\n\n    fmt.Println(string(body))\n}\n```\n\n`resp.Body.Close()` 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。\n\n如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：\n\n```\n_, err = io.Copy(ioutil.Discard, resp.Body)    // 手动丢弃读取完毕的数据\n```\n\n如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：\n\n```\njson.NewDecoder(resp.Body).Decode(&data)\n```\n\n### 36. 关闭 HTTP 连接\n\n一些支持 HTTP1.1 或 HTTP1.0 配置了 `connection: keep-alive` 选项的服务器会保持一段时间的长连接。但标准库 \"net/http\" 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：\n\n- 直接设置请求变量的 `Close` 字段值为 `true`，每次请求结束后就会主动关闭连接。\n- 设置 Header 请求头部选项 `Connection: close`，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。\n\n```go\n// 主动关闭连接\nfunc main() {\n    req, err := http.NewRequest(\"GET\", \"http://golang.org\", nil)\n    checkError(err)\n\n    req.Close = true\n    //req.Header.Add(\"Connection\", \"close\")    // 等效的关闭方式\n\n    resp, err := http.DefaultClient.Do(req)\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n    checkError(err)\n\n    body, err := ioutil.ReadAll(resp.Body)\n    checkError(err)\n\n    fmt.Println(string(body))\n}\n```\n\n你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：\n\n```go\nfunc main() {\n    tr := http.Transport{DisableKeepAlives: true}\n    client := http.Client{Transport: &tr}\n\n    resp, err := client.Get(\"https://golang.google.cn/\")\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n    checkError(err)\n\n    fmt.Println(resp.StatusCode)    // 200\n\n    body, err := ioutil.ReadAll(resp.Body)\n    checkError(err)\n\n    fmt.Println(len(string(body)))\n}\n```\n\n根据需求选择使用场景：\n\n- 若你的程序要向同一服务器发大量请求，使用默认的保持长连接。\n- 若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 `fs.file-max` 的值。\n\n### 37. 将 JSON 中的数字解码为 interface 类型\n\n在 encode/decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：\n\n```go\nfunc main() {\n    var data = []byte(`{\"status\": 200}`)\n    var result map[string]interface{}\n\n    if err := json.Unmarshal(data, &result); err != nil {\n        log.Fatalln(err)\n    }\n\n    fmt.Printf(\"%T\\n\", result[\"status\"])    // float64\n    var status = result[\"status\"].(int)    // 类型断言错误\n    fmt.Println(\"Status value: \", status)\n}\n```\n\npanic: interface conversion: interface {} is float64, not int\n\n如果你尝试 decode 的 JSON 字段是整型，你可以：\n\n- 将 int 值转为 float 统一使用\n- 将 decode 后需要的 float 值转为 int 使用\n\n```go\n// 将 decode 的值转为 int 使用\nfunc main() {\n    var data = []byte(`{\"status\": 200}`)\n    var result map[string]interface{}\n\n    if err := json.Unmarshal(data, &result); err != nil {\n        log.Fatalln(err)\n    }\n\n    var status = uint64(result[\"status\"].(float64))\n    fmt.Println(\"Status value: \", status)\n}\n```\n\n- 使用 `Decoder` 类型来 decode JSON 数据，明确表示字段的值类型\n\n```go\n// 指定字段类型\nfunc main() {\n    var data = []byte(`{\"status\": 200}`)\n    var result map[string]interface{}\n\n    var decoder = json.NewDecoder(bytes.NewReader(data))\n    decoder.UseNumber()\n\n    if err := decoder.Decode(&result); err != nil {\n        log.Fatalln(err)\n    }\n\n    var status, _ = result[\"status\"].(json.Number).Int64()\n    fmt.Println(\"Status value: \", status)\n}\n\n // 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用\n // 将数据转为 decode 为 string\n func main() {\n     var data = []byte({\"status\": 200})\n      var result map[string]interface{}\n      var decoder = json.NewDecoder(bytes.NewReader(data))\n      decoder.UseNumber()\n      if err := decoder.Decode(&result); err != nil {\n          log.Fatalln(err)\n      }\n    var status uint64\n      err := json.Unmarshal([]byte(result[\"status\"].(json.Number).String()), &status);\n    checkError(err)\n       fmt.Println(\"Status value: \", status)\n}\n```\n\n\\- 使用 `struct` 类型将你需要的数据映射为数值型\n\n```go\n// struct 中指定字段类型\nfunc main() {\n      var data = []byte(`{\"status\": 200}`)\n      var result struct {\n          Status uint64 `json:\"status\"`\n      }\n\n      err := json.NewDecoder(bytes.NewReader(data)).Decode(&result)\n      checkError(err)\n    fmt.Printf(\"Result: %+v\", result)\n}\n```\n\n- 可以使用 `struct` 将数值类型映射为 `json.RawMessage` 原生数据类型\n  适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：\n\n```go\n// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型\nfunc main() {\n    records := [][]byte{\n        []byte(`{\"status\":200, \"tag\":\"one\"}`),\n        []byte(`{\"status\":\"ok\", \"tag\":\"two\"}`),\n    }\n\n    for idx, record := range records {\n        var result struct {\n            StatusCode uint64\n            StatusName string\n            Status     json.RawMessage `json:\"status\"`\n            Tag        string          `json:\"tag\"`\n        }\n\n        err := json.NewDecoder(bytes.NewReader(record)).Decode(&result)\n        checkError(err)\n\n        var name string\n        err = json.Unmarshal(result.Status, &name)\n        if err == nil {\n            result.StatusName = name\n        }\n\n        var code uint64\n        err = json.Unmarshal(result.Status, &code)\n        if err == nil {\n            result.StatusCode = code\n        }\n\n        fmt.Printf(\"[%v] result => %+v\\n\", idx, result)\n    }\n}\n```\n\n### 38. struct、array、slice 和 map 的值比较\n\n可以使用相等运算符 `==` 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：\n\n```go\ntype data struct {\n    num     int\n    fp      float32\n    complex complex64\n    str     string\n    char    rune\n    yes     bool\n    events  <-chan string\n    handler interface{}\n    ref     *byte\n    raw     [10]byte\n}\n\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\"v1 == v2: \", v1 == v2)    // true\n}\n```\n\n如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。\n\n```go\ntype data struct {\n    num    int\n    checks [10]func() bool        // 无法比较\n    doIt   func() bool        // 无法比较\n    m      map[string]string    // 无法比较\n    bytes  []byte            // 无法比较\n}\n\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n\n    fmt.Println(\"v1 == v2: \", v1 == v2)\n}\n```\n\ninvalid operation: v1 == v2 (struct containing [10]func() bool cannot be compared)\n\nGo 提供了一些库函数来比较那些无法使用 `==` 比较的变量，比如使用 \"reflect\" 包的 `DeepEqual()` ：\n\n```go\n// 比较相等运算符无法比较的元素\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\"v1 == v2: \", reflect.DeepEqual(v1, v2))    // true\n\n    m1 := map[string]string{\"one\": \"a\", \"two\": \"b\"}\n    m2 := map[string]string{\"two\": \"b\", \"one\": \"a\"}\n    fmt.Println(\"v1 == v2: \", reflect.DeepEqual(m1, m2))    // true\n\n    s1 := []int{1, 2, 3}\n    s2 := []int{1, 2, 3}\n       // 注意两个 slice 相等，值和顺序必须一致\n    fmt.Println(\"v1 == v2: \", reflect.DeepEqual(s1, s2))    // true\n}\n```\n\n这种比较方式可能比较慢，根据你的程序需求来使用。`DeepEqual()` 还有其他用法：\n\n```go\nfunc main() {\n    var b1 []byte = nil\n    b2 := []byte{}\n    fmt.Println(\"b1 == b2: \", reflect.DeepEqual(b1, b2))    // false\n}\n```\n\n**注意：**\n\n- `DeepEqual()` 并不总适合于比较 slice\n\n```go\nfunc main() {\n    var str = \"one\"\n    var in interface{} = \"one\"\n    fmt.Println(\"str == in: \", reflect.DeepEqual(str, in))    // true\n\n    v1 := []string{\"one\", \"two\"}\n    v2 := []string{\"two\", \"one\"}\n    fmt.Println(\"v1 == v2: \", reflect.DeepEqual(v1, v2))    // false\n\n    data := map[string]interface{}{\n        \"code\":  200,\n        \"value\": []string{\"one\", \"two\"},\n    }\n    encoded, _ := json.Marshal(data)\n    var decoded map[string]interface{}\n    json.Unmarshal(encoded, &decoded)\n    fmt.Println(\"data == decoded: \", reflect.DeepEqual(data, decoded))    // false\n}\n```\n\n如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 \"bytes\" 或 \"strings\" 包的 `ToUpper()` 和 `ToLower()` 函数。比较其他语言的 byte 或 string，应使用 `bytes.EqualFold()` 和 `strings.EqualFold()`\n\n如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 `reflect.DeepEqual()`、`bytes.Equal()`、 `bytes.Compare()`。这三个函数容易对程序造成 [timing attacks](http://en.wikipedia.org/wiki/Timing_attack)，此时应使用 \"crypto/subtle\" 包中的 `subtle.ConstantTimeCompare()` 等函数\n\n- `reflect.DeepEqual()` 认为空 slice 与 nil slice 并不相等，但注意 `byte.Equal()` 会认为二者相等：\n\n```go\nfunc main() {\n    var b1 []byte = nil\n    b2 := []byte{}\n\n    // b1 与 b2 长度相等、有相同的字节序\n    // nil 与 slice 在字节上是相同的\n    fmt.Println(\"b1 == b2: \", bytes.Equal(b1, b2))    // true\n}\n```\n\n### 39. 从 panic 中恢复\n\n在一个 defer 延迟执行的函数中调用 `recover()` ，它便能捕捉 / 中断 panic\n\n```go\n// 错误的 recover 调用示例\nfunc main() {\n    recover()    // 什么都不会捕捉\n    panic(\"not good\")    // 发生 panic，主程序退出\n    recover()    // 不会被执行\n    println(\"ok\")\n}\n\n// 正确的 recover 调用示例\nfunc main() {\n    defer func() {\n        fmt.Println(\"recovered: \", recover())\n    }()\n    panic(\"not good\")\n}\n```\n\n从上边可以看出，`recover()` 仅在 defer 执行的函数中调用才会生效。\n\n```go\n// 错误的调用示例\nfunc main() {\n    defer func() {\n        doRecover()\n    }()\n    panic(\"not good\")\n}\n\nfunc doRecover() {\n    fmt.Println(\"recobered: \", recover())\n}\n```\n\nrecobered:  panic: not good\n\n### 40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素\n\n在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：\n\n```go\nfunc main() {\n    data := []int{1, 2, 3}\n    for _, v := range data {\n        v *= 10        // data 中原有元素是不会被修改的\n    }\n    fmt.Println(\"data: \", data)    // data:  [1 2 3]\n}\n```\n\n如果要修改原有元素的值，应该使用索引直接访问：\n\n```go\nfunc main() {\n    data := []int{1, 2, 3}\n    for i, v := range data {\n        data[i] = v * 10\n    }\n    fmt.Println(\"data: \", data)    // data:  [10 20 30]\n}\n```\n\n如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：\n\n```go\nfunc main() {\n    data := []*struct{ num int }{{1}, {2}, {3},}\n    for _, v := range data {\n        v.num *= 10    // 直接使用指针更新\n    }\n    fmt.Println(data[0], data[1], data[2])    // &{10} &{20} &{30}\n}\n```\n\n### 41. slice 中隐藏的数据\n\n从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。\n\n```go\nfunc get() []byte {\n    raw := make([]byte, 10000)\n    fmt.Println(len(raw), cap(raw), &raw[0])    // 10000 10000 0xc420080000\n    return raw[:3]    // 重新分配容量为 10000 的 slice\n}\n\nfunc main() {\n    data := get()\n    fmt.Println(len(data), cap(data), &data[0])    // 3 10000 0xc420080000\n}\n```\n\n可以通过拷贝临时 slice 的数据，而不是重新切片来解决：\n\n```go\nfunc get() (res []byte) {\n    raw := make([]byte, 10000)\n    fmt.Println(len(raw), cap(raw), &raw[0])    // 10000 10000 0xc420080000\n    res = make([]byte, 3)\n    copy(res, raw[:3])\n    return\n}\n\nfunc main() {\n    data := get()\n    fmt.Println(len(data), cap(data), &data[0])    // 3 3 0xc4200160b8\n}\n```\n\n### 42. Slice 中数据的误用\n\n举个简单例子，重写文件路径（存储在 slice 中）\n\n分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：\n\n```go\n// 错误使用 slice 的拼接示例\nfunc main() {\n    path := []byte(\"AAAA/BBBBBBBBB\")\n    sepIndex := bytes.IndexByte(path, '/') // 4\n    println(sepIndex)\n\n    dir1 := path[:sepIndex]\n    dir2 := path[sepIndex+1:]\n    println(\"dir1: \", string(dir1))        // AAAA\n    println(\"dir2: \", string(dir2))        // BBBBBBBBB\n\n    dir1 = append(dir1, \"suffix\"...)\n       println(\"current path: \", string(path))    // AAAAsuffixBBBB\n\n    path = bytes.Join([][]byte{dir1, dir2}, []byte{'/'})\n    println(\"dir1: \", string(dir1))        // AAAAsuffix\n    println(\"dir2: \", string(dir2))        // uffixBBBB\n\n    println(\"new path: \", string(path))    // AAAAsuffix/uffixBBBB    // 错误结果\n}\n```\n\n拼接的结果不是正确的 `AAAAsuffix/BBBBBBBBB`，因为 dir1、 dir2 两个 slice 引用的数据都是 `path` 的底层数组，第 13 行修改 `dir1` 同时也修改了 `path`，也导致了 `dir2` 的修改\n\n解决方法：\n\n- 重新分配新的 slice 并拷贝你需要的数据\n- 使用完整的 slice 表达式：`input[low:high:max]`，容量便调整为 max - low\n\n```go\n// 使用 full slice expression\nfunc main() {\n\n    path := []byte(\"AAAA/BBBBBBBBB\")\n    sepIndex := bytes.IndexByte(path, '/') // 4\n    dir1 := path[:sepIndex:sepIndex]        // 此时 cap(dir1) 指定为4， 而不是先前的 16\n    dir2 := path[sepIndex+1:]\n    dir1 = append(dir1, \"suffix\"...)\n\n    path = bytes.Join([][]byte{dir1, dir2}, []byte{'/'})\n    println(\"dir1: \", string(dir1))        // AAAAsuffix\n    println(\"dir2: \", string(dir2))        // BBBBBBBBB\n    println(\"new path: \", string(path))    // AAAAsuffix/BBBBBBBBB\n}\n```\n\n第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组\n\n### 43. 旧 slice\n\n当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 \"旧\"（stale） slice 问题。\n\n某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。\n\n```go\n// 超过容量将重新分配数组来拷贝值、重新存储\nfunc main() {\n    s1 := []int{1, 2, 3}\n    fmt.Println(len(s1), cap(s1), s1)    // 3 3 [1 2 3 ]\n\n    s2 := s1[1:]\n    fmt.Println(len(s2), cap(s2), s2)    // 2 2 [2 3]\n\n    for i := range s2 {\n        s2[i] += 20\n    }\n    // 此时的 s1 与 s2 是指向同一个底层数组的\n    fmt.Println(s1)        // [1 22 23]\n    fmt.Println(s2)        // [22 23]\n\n    s2 = append(s2, 4)    // 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存\n\n    for i := range s2 {\n        s2[i] += 10\n    }\n    fmt.Println(s1)        // [1 22 23]    // 此时的 s1 不再更新，为旧数据\n    fmt.Println(s2)        // [32 33 14]\n}\n```\n\n### 44. 类型声明与方法\n\n从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：\n\n```go\n// 定义 Mutex 的自定义类型\ntype myMutex sync.Mutex\n\nfunc main() {\n    var mtx myMutex\n    mtx.Lock()\n    mtx.UnLock()\n}\n```\n\nmtx.Lock undefined (type myMutex has no field or method Lock)...\n\n如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：\n\n```go\n// 类型以字段形式直接嵌入\ntype myLocker struct {\n    sync.Mutex\n}\n\nfunc main() {\n    var locker myLocker\n    locker.Lock()\n    locker.Unlock()\n}\n```\n\ninterface 类型声明也保留它的方法集：\n\n```go\ntype myLocker sync.Locker\n\nfunc main() {\n    var locker myLocker\n    locker.Lock()\n    locker.Unlock()\n}\n```\n\n### 45. 跳出 for-switch 和 for-select 代码块\n\n没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：\n\n```go\n// break 配合 label 跳出指定代码块\nfunc main() {\nloop:\n    for {\n        switch {\n        case true:\n            fmt.Println(\"breaking out...\")\n            //break    // 死循环，一直打印 breaking out...\n            break loop\n        }\n    }\n    fmt.Println(\"out...\")\n}\n```\n\n`goto` 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。\n\n### 46. for 语句中的迭代变量与闭包函数\n\nfor 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：\n\n```go\nfunc main() {\n    data := []string{\"one\", \"two\", \"three\"}\n\n    for _, v := range data {\n        go func() {\n            fmt.Println(v)\n        }()\n    }\n\n    time.Sleep(3 * time.Second)\n    // 输出 three three three\n}\n```\n\n最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：\n\n```go\nfunc main() {\n    data := []string{\"one\", \"two\", \"three\"}\n\n    for _, v := range data {\n        vCopy := v\n        go func() {\n            fmt.Println(vCopy)\n        }()\n    }\n\n    time.Sleep(3 * time.Second)\n    // 输出 one two three\n}\n```\n\n另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：\n\n```go\nfunc main() {\n    data := []string{\"one\", \"two\", \"three\"}\n\n    for _, v := range data {\n        go func(in string) {\n            fmt.Println(in)\n        }(v)\n    }\n\n    time.Sleep(3 * time.Second)\n    // 输出 one two three\n}\n```\n\n注意下边这个稍复杂的 3 个示例区别：\n\n```go\ntype field struct {\n    name string\n}\n\nfunc (p *field) print() {\n    fmt.Println(p.name)\n}\n\n// 错误示例\nfunc main() {\n    data := []field{{\"one\"}, {\"two\"}, {\"three\"}}\n    for _, v := range data {\n        go v.print()\n    }\n    time.Sleep(3 * time.Second)\n    // 输出 three three three\n}\n\n// 正确示例\nfunc main() {\n    data := []field{{\"one\"}, {\"two\"}, {\"three\"}}\n    for _, v := range data {\n        v := v\n        go v.print()\n    }\n    time.Sleep(3 * time.Second)\n    // 输出 one two three\n}\n\n// 正确示例\nfunc main() {\n    data := []*field{{\"one\"}, {\"two\"}, {\"three\"}}\n    for _, v := range data {    // 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同\n        go v.print()\n    }\n    time.Sleep(3 * time.Second)\n    // 输出 one two three\n}\n```\n\n### 47. defer 函数的参数值\n\n对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：\n\n```go\n// 在 defer 函数中参数会提前求值\nfunc main() {\n    var i = 1\n    defer fmt.Println(\"result: \", func() int { return i * 2 }())\n    i++\n}\n```\n\nresult: 2\n\n### 48. defer 函数的执行时机\n\n对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。\n\n比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：\n\n```go\n// 命令行参数指定目录名\n// 遍历读取目录下的文件\nfunc main() {\n\n    if len(os.Args) != 2 {\n        os.Exit(1)\n    }\n\n    dir := os.Args[1]\n    start, err := os.Stat(dir)\n    if err != nil || !start.IsDir() {\n        os.Exit(2)\n    }\n\n    var targets []string\n    filepath.Walk(dir, func(fPath string, fInfo os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        if !fInfo.Mode().IsRegular() {\n            return nil\n        }\n\n        targets = append(targets, fPath)\n        return nil\n    })\n\n    for _, target := range targets {\n        f, err := os.Open(target)\n        if err != nil {\n            fmt.Println(\"bad target:\", target, \"error:\", err)    //error:too many open files\n            break\n        }\n        defer f.Close()    // 在每次 for 语句块结束时，不会关闭文件资源\n\n        // 使用 f 资源\n    }\n}\n```\n\n先创建 10000 个文件：\n\n```go\n#!/bin/bash\nfor n in {1..10000}; do\n    echo content > \"file${n}.txt\"\ndone\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079519-ec32c68a-4892-4e5c-bced-cd3d864c960f.png)\n\n\n\n解决办法：defer 延迟执行的函数写入匿名函数中：\n\n```go\n// 目录遍历正常\nfunc main() {\n    // ...\n\n    for _, target := range targets {\n        func() {\n            f, err := os.Open(target)\n            if err != nil {\n                fmt.Println(\"bad target:\", target, \"error:\", err)\n                return    // 在匿名函数内使用 return 代替 break 即可\n            }\n            defer f.Close()    // 匿名函数执行结束，调用关闭文件资源\n\n            // 使用 f 资源\n        }()\n    }\n}\n```\n\n当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 `f.Close()` 来关闭。\n\n### 49. 失败的类型断言\n\n在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：\n\n```go\n// 错误示例\nfunc main() {\n    var data interface{} = \"great\"\n\n    // data 混用\n    if data, ok := data.(int); ok {\n        fmt.Println(\"[is an int], data: \", data)\n    } else {\n        fmt.Println(\"[not an int], data: \", data)    // [isn't a int], data:  0\n    }\n}\n\n// 正确示例\nfunc main() {\n    var data interface{} = \"great\"\n\n    if res, ok := data.(int); ok {\n        fmt.Println(\"[is an int], data: \", res)\n    } else {\n        fmt.Println(\"[not an int], data: \", data)    // [not an int], data:  great\n    }\n}\n```\n\n### 50. 阻塞的 gorutinue 与资源泄露\n\n在 2012 年 Google I/O 大会上，Rob Pike 的 [Go Concurrency Patterns](https://talks.golang.org/2012/concurrency.slide#1) 演讲讨论 Go 的几种基本并发模式，如 [完整代码](https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike) 中从数据集中获取第一条数据的函数：\n\n```go\nfunc First(query string, replicas []Search) Result {\n    c := make(chan Result)\n    replicaSearch := func(i int) { c <- replicas[i](query) }\n    for i := range replicas {\n        go replicaSearch(i)\n    }\n    return <-c\n}\n```\n\n在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。\n\n返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？\n\n在 `First()` 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。\n\n为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：\n\n- 使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：\n\n```go\nfunc First(query string, replicas ...Search) Result {\n    c := make(chan Result,len(replicas))\n    searchReplica := func(i int) { c <- replicas[i](query) }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n    return <-c\n}\n```\n\n- 使用 `select` 语句，配合能保存一个缓冲值的 channel `default` 语句：\n  `default` 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine\n\n```go\nfunc First(query string, replicas ...Search) Result {\n    c := make(chan Result,1)\n    searchReplica := func(i int) {\n        select {\n        case c <- replicas[i](query):\n        default:\n        }\n    }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n    return <-c\n}\n```\n\n- 使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：\n\n```go\nfunc First(query string, replicas ...Search) Result {\n    c := make(chan Result)\n    done := make(chan struct{})\n    defer close(done)\n    searchReplica := func(i int) {\n        select {\n        case c <- replicas[i](query):\n        case <- done:\n        }\n    }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n\n    return <-c\n}\n```\n\nRob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。\n\n## 高级篇：51-57\n\n### 51. 使用指针作为方法的 receiver\n\n只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。\n\n但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：\n\n```go\ntype data struct {\n    name string\n}\n\ntype printer interface {\n    print()\n}\n\nfunc (p *data) print() {\n    fmt.Println(\"name: \", p.name)\n}\n\nfunc main() {\n    d1 := data{\"one\"}\n    d1.print()    // d1 变量可寻址，可直接调用指针 receiver 的方法\n\n    var in printer = data{\"two\"}\n    in.print()    // 类型不匹配\n\n    m := map[string]data{\n        \"x\": data{\"three\"},\n    }\n    m[\"x\"].print()    // m[\"x\"] 是不可寻址的    // 变动频繁\n}\n```\n\ncannot use data literal (type data) as type printer in assignment:\n\ndata does not implement printer (print method has pointer receiver)\n\ncannot call pointer method on m[\"x\"]\n\ncannot take the address of m[\"x\"]\n\n### 52. 更新 map 字段的值\n\n如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：\n\n```go\n// 无法直接更新 struct 的字段值\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]data{\n        \"x\": {\"Tom\"},\n    }\n    m[\"x\"].name = \"Jerry\"\n}\n```\n\ncannot assign to struct field m[\"x\"].name in map\n\n因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：\n\n```go\ntype data struct {\n    name string\n}\n\nfunc main() {\n    s := []data{{\"Tom\"}}\n    s[0].name = \"Jerry\"\n    fmt.Println(s)    // [{Jerry}]\n}\n```\n\n注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。\n\n更新 map 中 struct 元素的字段值，有 2 个方法：\n\n- 使用局部变量\n\n```go\n// 提取整个 struct 到局部变量中，修改字段值后再整个赋值\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]data{\n        \"x\": {\"Tom\"},\n    }\n    r := m[\"x\"]\n    r.name = \"Jerry\"\n    m[\"x\"] = r\n    fmt.Println(m)    // map[x:{Jerry}]\n}\n```\n\n- 使用指向元素的 map 指针\n\n```go\nfunc main() {\n    m := map[string]*data{\n        \"x\": {\"Tom\"},\n    }\n\n    m[\"x\"].name = \"Jerry\"    // 直接修改 m[\"x\"] 中的字段\n    fmt.Println(m[\"x\"])    // &{Jerry}\n}\n```\n\n但是要注意下边这种误用：\n\n```go\nfunc main() {\n    m := map[string]*data{\n        \"x\": {\"Tom\"},\n    }\n    m[\"z\"].name = \"what???\"\n    fmt.Println(m[\"x\"])\n}\n```\n\npanic: runtime error: invalid memory address or nil pointer dereference\n\n### 53. nil interface 和 nil interface 值\n\n虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil\n\n如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：\n\n```go\nfunc main() {\n    var data *byte\n    var in interface{}\n\n    fmt.Println(data, data == nil)    // <nil> true\n    fmt.Println(in, in == nil)    // <nil> true\n\n    in = data\n    fmt.Println(in, in == nil)    // <nil> false    // data 值为 nil，但 in 值不为 nil\n}\n```\n\n如果你的函数返回值类型是 interface，更要小心这个坑：\n\n```go\n// 错误示例\nfunc main() {\n    doIt := func(arg int) interface{} {\n        var result *struct{} = nil\n        if arg > 0 {\n            result = &struct{}{}\n        }\n        return result\n    }\n\n    if res := doIt(-1); res != nil {\n        fmt.Println(\"Good result: \", res)    // Good result:  <nil>\n        fmt.Printf(\"%T\\n\", res)            // *struct {}    // res 不是 nil，它的值为 nil\n        fmt.Printf(\"%v\\n\", res)            // <nil>\n    }\n}\n\n// 正确示例\nfunc main() {\n    doIt := func(arg int) interface{} {\n        var result *struct{} = nil\n        if arg > 0 {\n            result = &struct{}{}\n        } else {\n            return nil    // 明确指明返回 nil\n        }\n        return result\n    }\n\n    if res := doIt(-1); res != nil {\n        fmt.Println(\"Good result: \", res)\n    } else {\n        fmt.Println(\"Bad result: \", res)    // Bad result:  <nil>\n    }\n}\n```\n\n### 54. 堆栈变量\n\n你并不总是清楚你的变量是分配到了堆还是栈。\n\n在 C++ 中使用 `new` 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 `new()`、`make()` 来创建变量，变量为内存分配位置依旧归 Go 编译器管。\n\nGo 编译器会根据变量的大小及其 \"escape analysis\" 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C/C++ 中是不行的。\n\n在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置：\n\n\n\n ![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079583-c6b22446-874e-41ce-8898-39d36c0881b5.png)\n\n\n\n### 55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）\n\nGo 1.4 及以下版本，程序只会使用 1 个执行上下文 / OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。\n\nGo 1.5 版本将可执行上下文的数量设置为 `runtime.NumCPU()` 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 `GOMAXPROCS` 环境变量或者动态的使用 `runtime.GOMAXPROCS()` 来调整。\n\n误区：`GOMAXPROCS` 表示执行 goroutine 的 CPU 核心数，参考[文档](https://golang.org/pkg/runtime/)\n\n`GOMAXPROCS` 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256\n\n```go\nfunc main() {\n    fmt.Println(runtime.GOMAXPROCS(-1))    // 4\n    fmt.Println(runtime.NumCPU())    // 4\n    runtime.GOMAXPROCS(20)\n    fmt.Println(runtime.GOMAXPROCS(-1))    // 20\n    runtime.GOMAXPROCS(300)\n    fmt.Println(runtime.GOMAXPROCS(-1))    // Go 1.9.2 // 300\n}\n```\n\n### 56. 读写操作的重新排序\n\nGo 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：\n\n```go\nvar _ = runtime.GOMAXPROCS(3)\n\nvar a, b int\n\nfunc u1() {\n    a = 1\n    b = 2\n}\n\nfunc u2() {\n    a = 3\n    b = 4\n}\n\nfunc p() {\n    println(a)\n    println(b)\n}\n\nfunc main() {\n    go u1()    // 多个 goroutine 的执行顺序不定\n    go u2()\n    go p()\n    time.Sleep(1 * time.Second)\n}\n```\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-1ec1022c-6083-4b1a-93fd-982ef37ae959.png)\n\n\n\n如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。\n\n### 57. 优先调度\n\n你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 `for` 循环：\n\n```go\nfunc main() {\n    done := false\n\n    go func() {\n        done = true\n    }()\n\n    for !done {\n    }\n\n    println(\"done !\")\n}\n```\n\n`for` 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。\n\n调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：\n\n```go\nfunc main() {\n    done := false\n\n    go func() {\n        done = true\n    }()\n\n    for !done {\n        println(\"not done !\")    // 并不内联执行\n    }\n\n    println(\"done !\")\n}\n```\n\n可以添加 `-m` 参数来分析 `for` 代码块中调用的内联函数：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079553-0bfc962d-ba49-426c-b720-43d42581d3af.png)\n\n\n\n你也可以使用 runtime 包中的 `Gosched()` 来 手动启动调度器：\n\n```go\nfunc main() {\n    done := false\n\n    go func() {\n        done = true\n    }()\n\n    for !done {\n        runtime.Gosched()\n    }\n\n    println(\"done !\")\n}\n```\n\n\n\n运行效果：\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079699-1d179d4e-3e72-4be3-8595-67d600aa223e.png)\n\n\n\n## 总结\n\n感谢原作者 [kcqon](https://twitter.com/kcqon) 总结的这篇博客，让我受益匪浅。\n\n由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。\n"
        },
        {
          "name": "Golang 新手可能会踩的 50 个坑.pdf",
          "type": "blob",
          "size": 853.7744140625,
          "content": null
        },
        {
          "name": "Golang基础框架图.png",
          "type": "blob",
          "size": 2068.953125,
          "content": null
        },
        {
          "name": "Golang知识点归纳.png",
          "type": "blob",
          "size": 2198.8779296875,
          "content": null
        },
        {
          "name": "Golang精编100题.md",
          "type": "blob",
          "size": 26.6708984375,
          "content": "## 能力模型\n\n| 级别                                                         | 模型                               |\n| ------------------------------------------------------------ | ---------------------------------- |\n| 初级                                                         |                                    |\n| primary                                                      | 熟悉基本语法，能够看懂代码的意图； |\n| 在他人指导下能够完成用户故事的开发，编写的代码符合CleanCode规范； |                                    |\n| 中级                                                         |                                    |\n| intermediate                                                 | 能够独立完成用户故事的开发和测试； |\n| 能够嗅出代码的坏味道，并知道如何重构达成目标；               |                                    |\n| 高级                                                         |                                    |\n| senior                                                       | 能够开发出高质量高性能的代码；     |\n| 能够熟练使用高级特性，开发编程框架或测试框架；               |                                    |\n\n## 选择题\n\n### 1、**[primary]** 下面属于关键字的是（）\n\nA. func\n\nB. def\n\nC. struct\n\nD. class\n\n参考答案：AC\n\n### 2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）\n\nA. var str string\n\nB. str := \"\"\n\nC. str = \"\"\n\nD. var str = \"\"\n\n参考答案：AD\n\n### 3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）\n\nA. p.name\n\nB. (*p).name\n\nC. (&p).name\n\nD. p->name\n\n参考答案：AB\n\n### 4、**[primary]** 关于接口和类的说法，下面说法正确的是（）\n\nA. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口\n\nB. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理\n\nC. 类实现接口时，需要导入接口所在的包\n\nD. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口\n\n参考答案：ABD\n\n### 5、**[primary]** 关于字符串连接，下面语法正确的是（）\n\nA. str := ‘abc’ + ‘123’\n\nB. str := \"abc\" + \"123\"\n\nC. str ：= '123' + \"abc\"\n\nD. fmt.Sprintf(\"abc%d\", 123)\n\n参考答案：BD\n\n### 6、**[primary]** 关于协程，下面说法正确是（）\n\nA. 协程和线程都可以实现程序的并发执行\n\nB. 线程比协程更轻量级\n\nC. 协程不存在死锁问题\n\nD. 通过channel来进行协程间的通信\n\n参考答案：AD\n\n### 7、**[intermediate]** 关于init函数，下面说法正确的是（）\n\nA. 一个包中，可以包含多个init函数\n\nB. 程序编译时，先执行导入包的init函数，再执行本包内的init函数\n\nC. main包中，不能有init函数\n\nD. init函数可以被其他函数调用\n\n参考答案：AB\n\n### 8、**[primary]** 关于循环语句，下面说法正确的有（）\n\nA. 循环语句既支持for关键字，也支持while和do-while\n\nB. 关键字for的基本使用方法与C/C++中没有任何差异\n\nC. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环\n\nD. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量\n\n参考答案：CD\n\n### 9、**[intermediate]** 对于函数定义：\n\n```go\nfunc add(args ...int) int {\n        sum := 0\n        for _, arg := range args {\n            sum += arg\n        }\n        return sum\n}\n```\n\n```go\n下面对add函数调用正确的是（）\nA. add(1, 2)\nB. add(1, 3, 7)\nC. add([]int{1, 2})\nD. add([]int{1, 3, 7}...)\n```\n\n参考答案：ABD\n\n### 10、**[primary]** 关于类型转化，下面语法正确的是（）\n\nA.\n\n```GO\ntype MyInt int\nvar i int = 1\nvar j MyInt = i\n```\n\nB.\n\n```GO\ntype MyInt int\nvar i int = 1\nvar j MyInt = (MyInt)i\n```\n\nC.\n\n```GO\ntype MyInt int\nvar i int = 1\nvar j MyInt = MyInt(i)\n```\n\nD.\n\n```GO\ntype MyInt int\nvar i int = 1\nvar j MyInt = i.(MyInt)\n```\n\n参考答案：C\n\n### 11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）\n\nA. var i int = 10\n\nB. var i = 10\n\nC. i := 10\n\nD. i = 10\n\n参考答案：ABC\n\n### 12、**[primary]** 关于const常量定义，下面正确的使用方式是（）\n\nA.\n\n```GO\nconst Pi float64 = 3.14159265358979323846\nconst zero = 0.0\n```\n\nB.\n\n```GO\nconst (\n        size int64 = 1024\n        eof = -1\n)\n```\n\nC.\n\n```GO\nconst (\n        ERR_ELEM_EXIST error = errors.New(\"element already exists\")\n        ERR_ELEM_NT_EXIST error = errors.New(\"element not exists\")\n)\n```\n\nD.\n\n```GO\nconst u, v float32 = 0, 3\nconst a, b, c = 3, 4, \"foo\"\n```\n\n参考答案：ABD\n\n### 13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）\n\nA. b = true\n\nB. b = 1\n\nC. b = bool(1)\n\nD. b = (1 == 2)\n\n参考答案：BC\n\n### 14、**[intermediate]** 下面的程序的运行结果是（）\n\n\n\n```GO\nfunc main() {\n        if (true) {\n            defer fmt.Printf(\"1\")\n        } else {\n            defer fmt.Printf(\"2\")\n        }\n        fmt.Printf(\"3\")\n}\n```\n\nA. 321\n\nB. 32\n\nC. 31\n\nD. 13\n\n参考答案：C\n\n### 15、**[primary]** 关于switch语句，下面说法正确的有（）\n\nA. 条件表达式必须为常量或者整数\n\nB. 单个case中，可以出现多个结果选项\n\nC. 需要用break来明确退出一个case\n\nD. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case\n\n参考答案：BD\n\n### 16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）\n\nA. 方法施加的对象显式传递，没有被隐藏起来\n\nB. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数\n\nC. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达\n\nD. 方法施加的对象不需要非得是指针，也不用非得叫this\n\n参考答案：ACD\n\n### 17、**[intermediate]** golang中的引用类型包括（）\n\nA. 数组切片\n\nB. map\n\nC. channel\n\nD. interface\n\n参考答案：ABCD\n\n### 18、**[intermediate]** golang中的指针运算包括（）\n\nA. 可以对指针进行自增或自减运算\n\nB. 可以通过“&”取指针的地址\n\nC. 可以通过“*”取指针指向的数据\n\nD. 可以对指针进行下标运算\n\n参考答案：BC\n\n### 19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）\n\nA. main函数不能带参数\n\nB. main函数不能定义返回值\n\nC. main函数所在的包必须为main包\n\nD. main函数中可以使用flag包来获取和解析命令行参数\n\n参考答案：ABCD\n\n### 20、**[intermediate]** 下面赋值正确的是（）\n\nA. var x = nil\n\nB. var x interface{} = nil\n\nC. var x string = nil\n\nD. var x error = nil\n\n参考答案：BD\n\n\n\n### 21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）\n\nA. s := make([]int)\n\nB. s := make([]int, 0)\n\nC. s := make([]int, 5, 10)\n\nD. s := []int{1, 2, 3, 4, 5}\n\n\n\n参考答案：BCD\n\n\n\n### 22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）\n\nA.\n\n```GO\nfunc (s *Slice)Remove(value interface{}) error {\n        for i, v := range *s {\n            if isEqual(value, v) {\n                if i== len(*s) - 1 {\n                    *s = (*s)[:i]\n                }else {\n                    *s = append((*s)[:i],(*s)[i + 2:]...)\n                }\n                return nil\n            }\n        }\n        return ERR_ELEM_NT_EXIST\n}\n```\n\n\n\nB.\n\n```GO\nfunc (s *Slice)Remove(value interface{}) error {\n        for i, v := range *s {\n            if isEqual(value, v) {\n                *s = append((*s)[:i],(*s)[i + 1:])\n                return nil\n            }\n        }\n        return ERR_ELEM_NT_EXIST\n}\n```\n\n\n\nC.\n\n```GO\nfunc (s *Slice)Remove(value interface{}) error {\n        for i, v := range *s {\n            if isEqual(value, v) {\n                delete(*s, v)\n                return nil\n            }\n        }\n        return ERR_ELEM_NT_EXIST\n}\n```\n\n\n\nD.\n\n```GO\nfunc (s *Slice)Remove(value interface{}) error {\n        for i, v := range *s {\n            if isEqual(value, v) {\n                *s = append((*s)[:i],(*s)[i + 1:]...)\n                return nil\n            }\n        }\n        return ERR_ELEM_NT_EXIST\n}\n```\n\n\n\n参考答案：D\n\n\n\n### 23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）\n\nA.\n\n```GO\nx := []int{\n        1, 2, 3,\n        4, 5, 6,\n}\n```\n\n\n\nB.\n\n```go\nx := []int{\n        1, 2, 3,\n        4, 5, 6\n}\n```\n\n\n\nC.\n\n\n\n```GO\nx := []int{\n        1, 2, 3,\n        4, 5, 6}\n```\n\n\n\nD.\n\n\n\n```GO\nx := []int{1, 2, 3, 4, 5, 6,}\n```\n\n\n\n参考答案：ACD\n\n\n\n### 24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）\n\nA.\n\n\n\n```GO\ni := 1\ni++\n```\n\n\n\nB.\n\n\n\n```GO\ni := 1\nj = i++\n```\n\n\n\nC.\n\n\n\n```GO\ni := 1\n++i\n```\n\n\n\nD.\n\n\n\n```GO\ni := 1\ni--\n```\n\n\n\n参考答案：AD\n\n\n\n### 25、**[intermediate]** 关于函数声明，下面语法错误的是（）\n\nA. func f(a, b int) (value int, err error)\n\nB. func f(a int, b int) (value int, err error)\n\nC. func f(a, b int) (value int, error)\n\nD. func f(a int, b int) (int, int, error)\n\n\n\n参考答案：C\n\n\n\n### 26、**[intermediate]** 如果Add函数的调用代码为：\n\n\n\n```GO\nfunc main() {\n        var a Integer = 1\n        var b Integer = 2\n        var i interface{} = &a\n        sum := i.(*Integer).Add(b)\n        fmt.Println(sum)\n}\n```\n\n\n\n### 27、则Add函数定义正确的是（）\n\nA.\n\n\n\n```GO\ntype Integer int\nfunc (a Integer) Add(b Integer) Integer {\n        return a + b\n}\n```\n\n\n\nB.\n\n\n\n```GO\ntype Integer int\nfunc (a Integer) Add(b *Integer) Integer {\n        return a + *b\n}\n```\n\n\n\nC.\n\n\n\n```GO\ntype Integer int\nfunc (a *Integer) Add(b Integer) Integer {\n        return *a + b\n}\n```\n\n\n\nD.\n\n\n\n```GO\ntype Integer int\nfunc (a *Integer) Add(b *Integer) Integer {\n        return *a + *b\n}\n```\n\n\n\n参考答案：AC\n\n\n\n### 28、**[intermediate]** 如果Add函数的调用代码为：\n\n\n\n```GO\nfunc main() {\n        var a Integer = 1\n        var b Integer = 2\n        var i interface{} = a\n        sum := i.(Integer).Add(b)\n        fmt.Println(sum)\n}\n```\n\n\n\n### 29、则Add函数定义正确的是（）\n\nA.\n\n\n\n```GO\ntype Integer int\nfunc (a Integer) Add(b Integer) Integer {\n        return a + b\n}\n```\n\n\n\nB.\n\n\n\n```GO\ntype Integer int\nfunc (a Integer) Add(b *Integer) Integer {\n        return a + *b\n}\n```\n\n\n\nC.\n\n\n\n```GO\ntype Integer int\nfunc (a *Integer) Add(b Integer) Integer {\n        return *a + b\n}\n```\n\n\n\nD.\n\n\n\n```GO\ntype Integer int\nfunc (a *Integer) Add(b *Integer) Integer {\n        return *a + *b\n}\n```\n\n\n\n参考答案：A\n\n\n\n### 30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）\n\n\n\n```GO\ntype Fragment interface {\n        Exec(transInfo *TransInfo) error\n}\ntype GetPodAction struct {\n}\nfunc (g GetPodAction) Exec(transInfo *TransInfo) error {\n        ...\n        return nil\n}\n```\n\n\n\nA. var fragment Fragment = new(GetPodAction)\n\nB. var fragment Fragment = GetPodAction\n\nC. var fragment Fragment = &GetPodAction{}\n\nD. var fragment Fragment = GetPodAction{}\n\n\n\n参考答案：ACD\n\n\n\n### 31、**[intermediate]** 关于GoMock，下面说法正确的是（）\n\nA. GoMock可以对interface打桩\n\nB. GoMock可以对类的成员函数打桩\n\nC. GoMock可以对函数打桩\n\nD. GoMock打桩后的依赖注入可以通过GoStub完成\n\n\n\n参考答案：AD\n\n\n\n### 32、**[intermediate]** 关于接口，下面说法正确的是（）\n\nA. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值\n\nB. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A\n\nC. 接口查询是否成功，要在运行期才能够确定\n\nD. 接口赋值是否可行，要在运行期才能够确定\n\n\n\n参考答案：ABC\n\n\n\n### 33、**[primary]** 关于channel，下面语法正确的是（）\n\nA. var ch chan int\n\nB. ch := make(chan int)\n\nC. <- ch\n\nD. ch <-\n\n\n\n参考答案：ABC\n\n\n\n### 34、**[primary]** 关于同步锁，下面说法正确的是（）\n\nA. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex\n\nB. RWMutex在读锁占用的情况下，会阻止写，但不阻止读\n\nC. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占\n\nD. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应\n\n\n\n参考答案：ABC\n\n\n\n### 35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）\n\nA. 指针\n\nB. channel\n\nC. complex\n\nD. 函数\n\n\n\n参考答案：BCD\n\n\n\n### 36、**[intermediate]** 关于go vendor，下面说法正确的是（）\n\nA. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面\n\nB. 编译go代码会优先从vendor目录先寻找依赖包\n\nC. 可以指定引用某个特定版本的外部包\n\nD. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH/src下都可以通过编译\n\n\n\n参考答案：ABD\n\n\n\n### 37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）\n\nA. if flag == 1\n\nB. if flag\n\nC. if flag == false\n\nD. if !flag\n\n\n\n参考答案：BD\n\n\n\n### 38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）\n\nA. if value == 0\n\nB. if value\n\nC. if value != 0\n\nD. if !value\n\n\n\n参考答案：AC\n\n\n\n### 39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）\n\nA. 如果失败原因只有一个，则返回bool\n\nB. 如果失败原因超过一个，则返回error\n\nC. 如果没有失败原因，则不返回bool或error\n\nD. 如果重试几次可以避免失败，则不要立即返回bool或error\n\n\n\n参考答案：ABCD\n\n\n\n### 40、**[intermediate]** 关于异常设计，下面说法正确的是（）\n\nA. 在程序开发阶段，坚持速错，让程序异常崩溃\n\nB. 在程序部署后，应恢复异常避免程序终止\n\nC. 一切皆错误，不用进行异常设计\n\nD. 对于不应该出现的分支，使用异常处理\n\n\n\n参考答案：ABD\n\n\n\n### 41、**[intermediate]** 关于slice或map操作，下面正确的是（）\n\nA.\n\n\n\n```GO\nvar s []int\ns = append(s,1)\n```\n\n\n\nB.\n\n\n\n```GO\nvar m map[string]int\nm[\"one\"] = 1\n```\n\n\n\nC.\n\n\n\n```GO\nvar s []int\ns = make([]int, 0)\ns = append(s,1)\n```\n\n\n\nD.\n\n\n\n```GO\nvar m map[string]int\nm = make(map[string]int)\nm[\"one\"] = 1\n```\n\n\n\n参考答案：ACD\n\n\n\n### 42、**[intermediate]** 关于channel的特性，下面说法正确的是（）\n\nA. 给一个 nil channel 发送数据，造成永远阻塞\n\nB. 从一个 nil channel 接收数据，造成永远阻塞\n\nC. 给一个已经关闭的 channel 发送数据，引起 panic\n\nD. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值\n\n\n\n参考答案：ABCD\n\n\n\n### 43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）\n\nA. 无缓冲的channel是默认的缓冲为1的channel\n\nB. 无缓冲的channel和有缓冲的channel都是同步的\n\nC. 无缓冲的channel和有缓冲的channel都是非同步的\n\nD. 无缓冲的channel是同步的，而有缓冲的channel是非同步的\n\n\n\n参考答案：D\n\n\n\n### 44、**[intermediate]** 关于异常的触发，下面说法正确的是（）\n\nA. 空指针解析\n\nB. 下标越界\n\nC. 除数为0\n\nD. 调用panic函数\n\n\n\n参考答案：ABCD\n\n\n\n### 45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）\n\nA. array\n\nB. slice\n\nC. map\n\nD. channel\n\n\n\n参考答案：ABD\n\n\n\n### 46、**[intermediate]** 关于beego框架，下面说法正确的是（）\n\nA. beego是一个golang实现的轻量级HTTP框架\n\nB. beego可以通过注释路由、正则路由等多种方式完成url路由注入\n\nC. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译\n\nD. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持\n\n\n\n参考答案：ABC\n\n\n\n### 47、**[intermediate]** 关于goconvey，下面说法正确的是（）\n\nA. goconvey是一个支持golang的单元测试框架\n\nB. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面\n\nC. goconvey提供了丰富的断言简化测试用例的编写\n\nD. goconvey无法与go test集成\n\n\n\n参考答案：ABC\n\n\n\n### 48、**[intermediate]** 关于go vet，下面说法正确的是（）\n\nA. go vet是golang自带工具go tool vet的封装\n\nB. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测\n\nC. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包\n\nD. go vet可以检测出死代码\n\n\n\n参考答案：ACD\n\n\n\n### 49、**[intermediate]** 关于map，下面说法正确的是（）\n\nA. map反序列化时json.unmarshal的入参必须为map的地址\n\nB. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改\n\nC. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改\n\nD. 不能使用内置函数delete删除map的元素\n\n参考答案：A\n\n\n\n### 50、**[intermediate]** 关于GoStub，下面说法正确的是（）\n\nA. GoStub可以对全局变量打桩\n\nB. GoStub可以对函数打桩\n\nC. GoStub可以对类的成员方法打桩\n\nD. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为\n\n\n\n参考答案：ABD\n\n\n\n### 51、**[primary]** 关于select机制，下面说法正确的是（）\n\nA. select机制用来处理异步IO问题\n\nB. select机制最大的一条限制就是每个case语句里必须是一个IO操作\n\nC. golang在语言级别支持select关键字\n\nD. select关键字的用法与switch语句非常类似，后面要带判断条件\n\n\n\n参考答案：ABC\n\n\n\n### 52、**[primary]** 关于内存泄露，下面说法正确的是（）\n\nA. golang有自动垃圾回收，不存在内存泄露\n\nB. golang中检测内存泄露主要依靠的是pprof包\n\nC. 内存泄露可以在编译阶段发现\n\nD. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题\n\n\n\n参考答案：BD\n\n\n\n## 填空题\n\n\n\n### 1、**[primary]** 声明一个整型变量i__________\n\n\n\n参考答案：var i int\n\n\n\n### 2、**[primary]** 声明一个含有10个元素的整型数组a__________\n\n\n\n参考答案：var a [10]int\n\n\n\n### 3、**[primary]** 声明一个整型数组切片s__________\n\n\n\n参考答案：var s []int\n\n\n\n### 4、**[primary]** 声明一个整型指针变量p__________\n\n\n\n参考答案：var p *int\n\n\n\n### 5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________\n\n\n\n参考答案：var m map[string]int\n\n\n\n### 6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________\n\n\n\n参考答案：var f func(a int) int\n\n\n\n### 7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________\n\n\n\n参考答案：var ch <-chan int\n\n\n\n### 8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________\n\n\n\n参考答案：slice_test.go\n\n\n\n### 9、**[primary]** go test要求测试函数的前缀必须命名为__________\n\n\n\n参考答案：Test\n\n\n\n### 10、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfor i := 0; i < 5; i++ {\n        defer fmt.Printf(\"%d \", i)\n}\n```\n\n\n\n参考答案：4 3 2 1 0\n\n\n\n### 11、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc main() {\n        x := 1\n        {\n            x := 2\n            fmt.Print(x)\n        }\n        fmt.Println(x)\n}\n```\n\n\n\n参考答案：21\n\n\n\n### 12、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc main() {\n        strs := []string{\"one\", \"two\", \"three\"}\n\n        for _, s := range strs {\n            go func() {\n                time.Sleep(1 * time.Second)\n                fmt.Printf(\"%s \", s)\n            }()\n        }\n        time.Sleep(3 * time.Second)\n}\n```\n\n\n\n参考答案：three three three\n\n\n\n### 13、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc main() {\n        x := []string{\"a\", \"b\", \"c\"}\n        for v := range x {\n            fmt.Print(v)\n        }\n}\n```\n\n\n\n参考答案：012\n\n\n\n### 14、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc main() {\n        x := []string{\"a\", \"b\", \"c\"}\n        for _, v := range x {\n            fmt.Print(v)\n        }\n}\n```\n\n\n\n参考答案：abc\n\n\n\n### 15、**[primary]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc main() {\n       i := 1\n       j := 2\n       i, j = j, i\n       fmt.Printf(\"%d%d\\n\", i, j)\n}\n```\n\n\n\n参考答案：21\n\n\n\n### 16、**[primary]** 下面的程序的运行结果是__________\n\n\n\n```GO\nfunc incr(p *int) int {\n        *p++\n        return *p\n}\nfunc main() {\n        v := 1\n        incr(&v)\n        fmt.Println(v)\n}\n```\n\n\n\n参考答案：2\n\n\n\n### 17、**[primary]** 启动一个goroutine的关键字是__________\n\n\n\n参考答案：go\n\n\n\n### 18、**[intermediate]** 下面的程序的运行结果是__________\n\n\n\n```GO\ntype Slice []int\nfunc NewSlice() Slice {\n         return make(Slice, 0)\n}\nfunc (s* Slice) Add(elem int) *Slice {\n         *s = append(*s, elem)\n         fmt.Print(elem)\n         return s\n}\nfunc main() {\n         s := NewSlice()\n         defer s.Add(1).Add(2)\n         s.Add(3)\n}\n```\n\n\n\n参考答案：132\n\n\n\n## 判断题\n\n\n\n### 1、**[primary]** 数组是一个值类型（）\n\n\n\n参考答案：T\n\n\n\n### 2、**[primary]** 使用map不需要引入任何库（）\n\n\n\n参考答案：T\n\n\n\n### 3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）\n\n\n\n参考答案：F\n\n\n\n### 4、**[primary]** 指针是基础类型（）\n\n\n\n参考答案：F\n\n\n\n### 5、**[primary]** interface{}是可以指向任意对象的Any类型（）\n\n\n\n参考答案：T\n\n\n\n### 6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）\n\n\n\n```GO\nfile, err := os.Open(\"test.go\")\ndefer file.Close()\nif err != nil {\n        fmt.Println(\"open file failed:\", err)\n        return\n}\n...\n```\n\n\n\n参考答案：T\n\n\n\n### 7、**[primary]** Golang不支持自动垃圾回收（）\n\n\n\n参考答案：F\n\n\n\n### 8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）\n\n\n\n参考答案：T\n\n\n\n### 9、**[primary]** Golang可以复用C/C++的模块，这个功能叫Cgo（）\n\n\n\n参考答案：F\n\n\n\n### 10、**[primary]** 下面代码中两个斜点之间的代码，比如`json:\"x\"`，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）\n\n\n\n```GO\ntype Position struct {\n        X int `json:\"x\"`\n        Y int `json:\"y\"`\n        Z int `json:\"z\"`\n}\n```\n\n\n\n参考答案：T\n\n\n\n### 11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）\n\n\n\n参考答案：T\n\n\n\n### 12、**[primary]** 对于常量定义zero(const zero = 0.0)，zero是浮点型常量（）\n\n\n\n参考答案：F\n\n\n\n### 13、**[primary]** 对变量x的取反操作是~x（）\n\n\n\n参考答案：F\n\n\n\n### 14、**[primary]** 下面的程序的运行结果是xello（）\n\n\n\n```GO\nfunc main() {\n        str := \"hello\"\n        str[0] = 'x'\n        fmt.Println(str)\n}\n```\n\n\n\n参考答案：F\n\n\n\n### 15、**[primary]** golang支持goto语句（）\n\n\n\n参考答案：T\n\n\n\n### 16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）\n\n\n\n```GO\ntype TimesMatcher struct {\n        base int\n}\nfunc NewTimesMatcher(base int) *TimesMatcher{\n        return &TimesMatcher{base:base}\n}\nfunc main() {\n        p := NewTimesMatcher(3)\n        ...\n}\n```\n\n\n\n参考答案：F\n\n\n\n### 17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）\n\n\n\n参考答案：T\n\n\n\n### 18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）\n\n\n\n参考答案：T\n\n\n\n### 19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）\n\n\n\n参考答案：T\n\n\n\n### 20、**[primary]** 错误是业务过程的一部分，而异常不是（）\n\n\n\n参考答案：T\n\n\n\n### 21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）\n\n\n\n参考答案：F\n\n\n\n### 22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）\n\n\n\n参考答案：F\n\n\n\n### 23、**[primary]** 同级文件的包名不允许有多个（）\n\n\n\n参考答案：T\n\n\n\n### 24、**[intermediate]** 可以给任意类型添加相应的方法（）\n\n\n\n参考答案：F\n\n\n\n### 25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）\n\n\n\n参考答案：T\n\n\n\n### 26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）\n\n\n\n参考答案：T\n\n\n\n### 27、**[primary]** switch后面可以不跟表达式（）\n\n\n\n参考答案：T\n\n\n\n### 28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）\n\n\n\n参考答案：T\n\n\n\n### 29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）\n\n\n\n参考答案：T\n\n\n\n### 30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）\n\n\n\n```GO\nfunc deferDemo() error {\n        err := createResource1()\n        if err != nil {\n            return ERR_CREATE_RESOURCE1_FAILED\n        }\n        defer func() {\n            if err != nil {\n                destroyResource1()\n            }\n        }()\n\n        err = createResource2()\n        if err != nil {\n            return ERR_CREATE_RESOURCE2_FAILED\n        }\n        defer func() {\n            if err != nil {\n                destroyResource2()\n            }\n        }()\n\n        err = createResource3()\n        if err != nil {\n            return ERR_CREATE_RESOURCE3_FAILED\n        }\n        return nil\n}\n```\n\n\n\n参考答案：F\n\n\n\n### 31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）\n\n\n\n参考答案：F\n\n\n\n### 32、**[primary]** import后面的最后一个元素是包名（）\n\n\n\n参考答案：F\n"
        },
        {
          "name": "Go基础语法宝典.md",
          "type": "blob",
          "size": 84.2607421875,
          "content": "# 关键字\n\nGo语言设计的关键字，了解这些关键字有助于命名变量的冲突避免\n\n### go的二十五个关键字\n\n```\nbreak    default      func    interface    select\ncase     defer        go      map          struct\nchan     else         goto    package      switch\nconst    fallthrough  if      range        type\ncontinue for          import  return       var\n```\n\n### 简介\n\n- `var`和`const` 是 Go语言基础里面的变量和常量申明\n- `package`和`import` 用于分包和导入\n\n- `func` 用于定义函数和方法\n- `return` 用于从函数返回\n\n- `defer` 用于类似析构函数\n- `go` 用于并发\n\n- `select` 用于选择不同类型的通讯\n- `interface` 用于定义接口\n\n- `struct` 用于定义抽象数据类型\n- `break`、`case`、`continue`、`for`、`fallthrough`、`else`、`if`、`switch`、`goto`、`default` 用于流程控制\n\n- `chan`用于channel通讯\n- `type`用于声明自定义类型\n\n- `map`用于声明map类型数据\n- `range`用于读取slice、map、channel数据\n\n# 数据类型的定义\n\n## 定义变量\n\nGo语言里面定义变量有多种方式。\n\n使用`var`关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：\n\n```go\n//定义一个名称为“variableName”，类型为\"type\"的变量\nvar variableName type\n```\n\n定义多个变量\n\n```go\n//定义三个类型都是“type”的变量\nvar vname1, vname2, vname3 type\n```\n\n定义变量并初始化值\n\n```go\n//初始化“variableName”的变量为“value”值，类型是“type”\nvar variableName type = value\n```\n\n同时初始化多个变量\n\n```go\n/*\n    定义三个类型都是\"type\"的变量,并且分别初始化为相应的值\n    vname1为v1，vname2为v2，vname3为v3\n*/\nvar vname1, vname2, vname3 type= v1, v2, v3\n```\n\n是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：\n\n```go\n/*\n    定义三个变量，它们分别初始化为相应的值\n    vname1为v1，vname2为v2，vname3为v3\n    然后Go会根据其相应值的类型来初始化它们\n*/\nvar vname1, vname2, vname3 = v1, v2, v3\n```\n\n觉得上面的还是有些繁琐，继续简化：\n\n```go\n/*\n    定义三个变量，它们分别初始化为相应的值\n    vname1为v1，vname2为v2，vname3为v3\n    编译器会根据初始化的值自动推导出相应的类型\n*/\nvname1, vname2, vname3 := v1, v2, v3\n```\n\n现在是不是看上去非常简洁了？`:=`这个符号直接取代了`var`和`type`,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用`var`方式来定义全局变量。\n\n`_`（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值`35`赋予`b`，并同时丢弃`34`：\n\n```go\n_, b := 34, 35\n```\n\nGo对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了`i`但未使用。\n\n```go\npackage main\nfunc main() {\n    var i int\n}\n```\n\n## 常量\n\n所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。\n\n它的语法如下：\n\n```go\nconst constantName = value\n//如果需要，也可以明确指定常量的类型：\nconst Pi float32 = 3.1415926\n```\n\n下面是一些常量声明的例子：\n\n```go\nconst Pi = 3.1415926\nconst i = 10000\nconst MaxThread = 10\nconst prefix = \"astaxie_\"\n```\n\nGo 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给`float32`自动缩短为`32bit`，指定给`float64`自动缩短为`64bit`，详情参考 `http://golang.org/ref/spec#Constants` (需科学上网)\n\n## 内置基础类型\n\n### Boolean\n\n在Go中，布尔值的类型为`bool`，值是`true`或`false`，默认为`false`。\n\n```go\n//示例代码\nvar isActive bool  // 全局变量声明\nvar enabled, disabled = true, false  // 忽略类型的声明\nfunc test() {\n    var available bool  // 一般声明\n    valid := false      // 简短声明\n    available = true    // 赋值操作\n}\n```\n\n### 数值类型\n\n整数类型有无符号和带符号两种。Go同时支持`int`和`uint`，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：`rune`, `int8`, `int16`, `int32`, `int64`和`byte`, `uint8`, `uint16`, `uint32`, `uint64`。其中`rune`是`int32`的别称，`byte`是`uint8`的别称。\n\n需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。\n\n如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)\n\nvar a int8\n\nvar b int32\n\nc:=a + b\n\n另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。\n\n浮点数的类型有`float32`和`float64`两种（没有`float`类型），默认是`float64`。\n\nGo还支持复数。它的默认类型是`complex128`（64位实数+64位虚数）。如果需要小一些的，也有`complex64`(32位实数+32位虚数)。复数的形式为`RE + IMi`，其中`RE`是实数部分，`IM`是虚数部分，而最后的`i`是虚数单位。下面是一个使用复数的例子：\n\n```go\nvar c complex64 = 5+5i\n//output: (5+5i)\nfmt.Printf(\"Value is: %v\", c)\n```\n\n### 字符串\n\nGo中的字符串都是采用`UTF-8`字符集编码。字符串是用一对双引号（`\"\"`）或反引号（``` ```）括起来定义，它的类型是`string`。\n\n```go\n//示例代码\nvar frenchHello string  // 声明变量为字符串的一般方法\nvar emptyString string = \"\"  // 声明了一个字符串变量，初始化为空字符串\nfunc test() {\n    no, yes, maybe := \"no\", \"yes\", \"maybe\"  // 简短声明，同时声明多个变量\n    japaneseHello := \"Konichiwa\"  // 同上\n    frenchHello = \"Bonjour\"  // 常规赋值\n}\n```\n\n在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]\n\n```go\nvar s string = \"hello\"\ns[0] = 'c'\n```\n\n但如果真的想要修改怎么办呢？下面的代码可以实现：\n\n```go\ns := \"hello\"\nc := []byte(s)  // 将字符串 s 转换为 []byte 类型\nc[0] = 'c'\ns2 := string(c)  // 再转换回 string 类型\nfmt.Printf(\"%s\\n\", s2)\n```\n\nGo中可以使用`+`操作符来连接两个字符串：\n\n```go\ns := \"hello,\"\nm := \" world\"\na := s + m\nfmt.Printf(\"%s\\n\", a)\n```\n\n修改字符串也可写为：\n\n```go\ns := \"hello\"\ns = \"c\" + s[1:] // 字符串虽不能更改，但可进行切片操作\nfmt.Printf(\"%s\\n\", s)\n```\n\n如果要声明一个多行的字符串怎么办？可以通过```来声明：\n\n```go\nm := `hello\n    world`\n```\n\n\\``` 括起的字符串为`Raw`字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：\n\n```go\nhello\n    world\n```\n\n## 错误类型\n\nGo内置有一个`error`类型，专门用来处理错误信息，Go的`package`里面还专门有一个包`errors`来处理错误：\n\n```go\nerr := errors.New(\"emit macho dwarf: elf header corrupted\")\nif err != nil {\n    fmt.Print(err)\n}\n```\n\n## 分组声明\n\n在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。\n\n例如下面的代码：\n\n```go\nimport \"fmt\"\nimport \"os\"\nconst i = 100\nconst pi = 3.1415\nconst prefix = \"Go_\"\nvar i int\nvar pi float32\nvar prefix string\n```\n\n可以分组写成如下形式：\n\n```go\nimport(\n    \"fmt\"\n    \"os\"\n)\nconst(\n    i = 100\n    pi = 3.1415\n    prefix = \"Go_\"\n)\nvar(\n    i int\n    pi float32\n    prefix string\n)\n```\n\n## iota枚举\n\nGo里面有一个关键字`iota`，这个关键字用来声明`enum`的时候采用，它默认开始值是0，const中每增加一行加1：\n\n```go\npackage main\nimport (\n    \"fmt\"\n)\nconst (\n    x = iota // x == 0\n    y = iota // y == 1\n    z = iota // z == 2\n    w        // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用\"= iota\"\n)\nconst v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0\nconst (\n    h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同\n)\nconst (\n    a       = iota //a=0\n    b       = \"B\"\n    c       = iota             //c=2\n    d, e, f = iota, iota, iota //d=3,e=3,f=3\n    g       = iota             //g = 4\n)\nfunc main() {\n    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)\n}\n```\n\n除非被显式设置为其它值或`iota`，每个`const`分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是`iota`，则它也被设置为`iota`。\n\n## Go程序设计的一些规则\n\nGo之所以会那么简洁，是因为它有一些默认的行为：\n\n- 大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。\n- 大写字母开头的函数也是一样，相当于`class`中的带`public`关键词的公有函数；小写字母开头的就是有`private`关键词的私有函数。\n\n## `array`、`slice`、`map`\n\n### `array`\n\n`array`就是数组，它的定义方式如下：\n\n```go\nvar arr [n]type\n```\n\n在`[n]type`中，`n`表示数组的长度，`type`表示存储元素的类型。对数组的操作和其它语言类似，都是通过`[]`来进行读取或赋值：\n\n```go\nvar arr [10]int  // 声明了一个int类型的数组\narr[0] = 42      // 数组下标是从0开始的\narr[1] = 13      // 赋值操作\nfmt.Printf(\"The first element is %d\\n\", arr[0])  // 获取数据，返回42\nfmt.Printf(\"The last element is %d\\n\", arr[9]) //返回未赋值的最后一个元素，默认返回0\n```\n\n由于长度也是数组类型的一部分，因此`[3]int`与`[4]int`是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的`slice`类型了。\n\n数组可以使用另一种`:=`来声明\n\n```go\na := [3]int{1, 2, 3} // 声明了一个长度为3的int数组\nb := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0\nc := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度\n```\n\nGo支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：\n\n```go\n// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素\ndoubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}\n// 上面的声明可以简化，直接忽略内部的类型\neasyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}\n```\n\n### `slice`\n\n在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫`slice`\n\n`slice`并不是真正意义上的动态数组，而是一个引用类型。`slice`总是指向一个底层`array`，`slice`的声明也可以像`array`一样，只是不需要长度。\n\n```go\n// 和声明array一样，只是少了长度\nvar fslice []int\n```\n\n接下来可以声明一个`slice`，并初始化数据，如下所示：\n\n```go\nslice := []byte {'a', 'b', 'c', 'd'}\n```\n\n`slice`可以从一个数组或一个已经存在的`slice`中再次声明。`slice`通过`array[i:j]`来获取，其中`i`是数组的开始位置，`j`是结束位置，但不包含`array[j]`，它的长度是`j-i`。\n\n```go\n// 声明一个含有10个元素元素类型为byte的数组\nvar ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n// 声明两个含有byte的slice\nvar a, b []byte\n// a指向数组的第3个元素开始，并到第五个元素结束，\na = ar[2:5]\n//现在a含有的元素: ar[2]、ar[3]和ar[4]\n// b是数组ar的另一个slice\nb = ar[3:5]\n// b的元素是：ar[3]和ar[4]\n```\n\n注意`slice`和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用`...`自动计算长度，而声明`slice`时，方括号内没有任何字符。\n\n#### `slice`有一些简便的操作\n\n- `slice`的默认开始位置是0，`ar[:n]`等价于`ar[0:n]`\n- `slice`的第二个序列默认是数组的长度，`ar[n:]`等价于`ar[n:len(ar)]`\n\n- 如果从一个数组里面直接获取`slice`，可以这样`ar[:]`，因为默认第一个序列是0，第二个是数组的长度，即等价于`ar[0:len(ar)]`\n\n下面这个例子展示了更多关于`slice`的操作：\n\n```go\n// 声明一个数组\nvar array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n// 声明两个slice\nvar aSlice, bSlice []byte\n// 演示一些简便操作\naSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c\naSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j\naSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素\n// 从slice中获取slice\naSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7\nbSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f\nbSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f\nbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h\nbSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g\n```\n\n`slice`是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的`aSlice`和`bSlice`，如果修改了`aSlice`中元素的值，那么`bSlice`相对应的值也会改变。\n\n从概念上面来说`slice`像一个结构体，这个结构体包含了三个元素：\n\n- 一个指针，指向数组中`slice`指定的开始位置\n- 长度，即`slice`的长度\n\n- 最大长度，也就是`slice`开始位置到数组的最后位置的长度\n\n```go\nArray_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n    Slice_a := Array_a[2:5]\n```\n\n#### `slice`有几个有用的内置函数\n\n- `len` 获取`slice`的长度\n- `cap` 获取`slice`的最大容量\n\n- `append` 向`slice`里面追加一个或者多个元素，然后返回一个和`slice`一样类型的`slice`\n- `copy` 函数`copy`从源`slice`的`src`中复制元素到目标`dst`，并且返回复制的元素的个数\n\n注：`append`函数会改变`slice`所引用的数组的内容，从而影响到引用同一数组的其它`slice`。\n\n但当`slice`中没有剩余空间（即`(cap-len) == 0`）时，此时将动态分配新的数组空间。返回的`slice`数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的`slice`则不受影响。\n\n从Go1.2开始`slice`支持了三个参数的`slice`，之前一直采用这种方式在`slice`或者`array`基础上来获取一个`slice`\n\n```go\nvar array [10]int\nslice := array[2:4]\n```\n\n这个例子里面slice的容量是8，新版本里面可以指定这个容量\n\n```go\nslice = array[2:4:7]\n```\n\n上面这个的容量就是`7-2`，即5。这样这个产生的新的`slice`就没办法访问最后的三个元素。\n\n如果`slice`是这样的形式`array[:i:j]`，即第一个参数为空，默认值就是0。\n\n### `map`\n\n```go\nmap`也就是Python中字典的概念，它的格式为`map[keyType]valueType\n```\n\n看下面的代码，`map`的读取和设置也类似`slice`一样，通过`key`来操作，只是`slice`的`index`只能是｀int｀类型，而`map`多了很多类型，可以是`int`，可以是`string`及所有完全定义了`==`与`!=`操作的类型。\n\n```go\n// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化\nvar numbers map[string]int\n// 另一种map的声明方式\nnumbers = make(map[string]int)\nnumbers[\"one\"] = 1  //赋值\nnumbers[\"ten\"] = 10 //赋值\nnumbers[\"three\"] = 3\nfmt.Println(\"第三个数字是: \", numbers[\"three\"]) // 读取数据\n// 打印出来如:第三个数字是: 3\n```\n\n这个`map`就像平常看到的表格一样，左边列是`key`，右边列是值\n\n使用`map`过程中需要注意的几点：\n\n- `map`是无序的，每次打印出来的`map`都会不一样，它不能通过`index`获取，而必须通过`key`获取\n- `map`的长度是不固定的，也就是和`slice`一样，也是一种引用类型\n\n- 内置的`len`函数同样适用于`map`，返回`map`拥有的`key`的数量\n- `map`的值可以很方便的修改，通过`numbers[\"one\"]=11`可以很容易的把key为`one`的字典值改为`11`\n\n- `map`和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制\n\n`map`的初始化可以通过`key:val`的方式初始化值，同时`map`内置有判断是否存在`key`的方式\n\n通过`delete`删除`map`的元素：\n\n```go\n// 初始化一个字典\nrating := map[string]float32{\"C\":5, \"Go\":4.5, \"Python\":4.5, \"C++\":2 }\n// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true\ncsharpRating, ok := rating[\"C#\"]\nif ok {\n    fmt.Println(\"C# is in the map and its rating is \", csharpRating)\n} else {\n    fmt.Println(\"We have no rating associated with C# in the map\")\n}\ndelete(rating, \"C\")  // 删除key为C的元素\n```\n\n上面说过了，`map`也是一种引用类型，如果两个`map`同时指向一个底层，那么一个改变，另一个也相应的改变：\n\n```go\nm := make(map[string]string)\nm[\"Hello\"] = \"Bonjour\"\nm1 := m\nm1[\"Hello\"] = \"Salut\"  // 现在m[\"hello\"]的值已经是Salut了\n```\n\n## `make`、`new`操作\n\n`make`用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new`用于各种类型的内存分配。\n\n内建函数`new`本质上说跟其它语言中的同名函数功能一样：`new(T)`分配了零值填充的`T`类型的内存空间，并且返回其地址，即一个`*T`类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型`T`的零值。有一点非常重要：\n\n`new`返回指针。\n\n内建函数`make(T, args)`与`new(T)`有着不同的功能，make只能创建`slice`、`map`和`channel`，并且返回一个有初始值(非零)的`T`类型，而不是`*T`。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个`slice`，是一个包含指向数据（内部`array`）的指针、长度和容量的三项描述符；在这些项目被初始化之前，`slice`为`nil`。对于`slice`、`map`和`channel`来说，`make`初始化了内部的数据结构，填充适当的值。\n\n`make`返回初始化后的（非零）值。\n\n## 零值\n\n关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。\n\n此处罗列 部分类型 的 “零值”\n\n```go\nint     0\nint8    0\nint32   0\nint64   0\nuint    0x0\nrune    0 //rune的实际类型是 int32\nbyte    0x0 // byte的实际类型是 uint8\nfloat32 0 //长度为 4 byte\nfloat64 0 //长度为 8 byte\nbool    false\nstring  \"\"\n```\n\n# 流程控制\n\nGo中流程控制分三大类：条件判断，循环控制和无条件跳转。\n\n## if\n\n`if`也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。\n\nGo里面`if`条件判断语句中不需要括号，如下代码所示\n\n```go\nif x > 10 {\n    fmt.Println(\"x is greater than 10\")\n} else {\n    fmt.Println(\"x is less than 10\")\n}\n```\n\nGo的`if`还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示\n\n```go\n// 计算获取值x,然后根据x返回的大小，判断是否大于10。\nif x := computedValue(); x > 10 {\n    fmt.Println(\"x is greater than 10\")\n} else {\n    fmt.Println(\"x is less than 10\")\n}\n//这个地方如果这样调用就编译出错了，因为x是条件里面的变量\nfmt.Println(x)\n```\n\n多个条件的时候如下所示：\n\n```go\nif integer == 3 {\n    fmt.Println(\"The integer is equal to 3\")\n} else if integer < 3 {\n    fmt.Println(\"The integer is less than 3\")\n} else {\n    fmt.Println(\"The integer is greater than 3\")\n}\n```\n\n## goto\n\nGo有`goto`语句——请明智地使用它。用`goto`跳转到必须在当前函数内定义的标签。例如假设这样一个循环：\n\n```go\nfunc myFunc() {\n    i := 0\nHere:   //这行的第一个词，以冒号结束作为标签\n    println(i)\n    i++\n    goto Here   //跳转到Here去\n}\n```\n\n标签名是大小写敏感的。\n\n## for\n\nGo里面最强大的一个控制逻辑就是`for`，它既可以用来循环读取数据，又可以当作`while`来控制逻辑，还能迭代操作。它的语法如下：\n\n```go\nfor expression1; expression2; expression3 {\n    //...\n}\n```\n\n`expression1`、`expression2`和`expression3`都是表达式，其中`expression1`和`expression3`是变量声明或者函数调用返回值之类的，`expression2`是用来条件判断，`expression1`在循环开始之前调用，`expression3`在每轮循环结束之时调用。\n\n一个例子比上面讲那么多更有用，看看下面的例子吧：\n\n```go\npackage main\nimport \"fmt\"\nfunc main(){\n    sum := 0;\n    for index:=0; index < 10 ; index++ {\n        sum += index\n    }\n    fmt.Println(\"sum is equal to \", sum)\n}\n// 输出：sum is equal to 45\n```\n\n有些时候需要进行多个赋值操作，由于Go里面没有`,`操作符，那么可以使用平行赋值`i, j = i+1, j-1`\n\n有些时候如果忽略`expression1`和`expression3`：\n\n```go\nsum := 1\nfor ; sum < 1000;  {\n    sum += sum\n}\n```\n\n其中`;`也可以省略，那么就变成如下的代码了，这就是`while`的功能。\n\n```go\nsum := 1\nfor sum < 1000 {\n    sum += sum\n}\n```\n\n在循环里面有两个关键操作`break`和`continue`   ,`break`操作是跳出当前循环，`continue`是跳过本次循环。当嵌套过深的时候，`break`可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：\n\n```go\nfor index := 10; index>0; index-- {\n    if index == 5{\n        break // 或者continue\n    }\n    fmt.Println(index)\n}\n// break打印出来10、9、8、7、6\n// continue打印出来10、9、8、7、6、4、3、2、1\n```\n\n`break`和`continue`还可以跟着标号，用来跳到多重循环中的外层循环\n\n`for`配合`range`可以用于读取`slice`和`map`的数据：\n\n```go\nfor k,v:=range map {\n    fmt.Println(\"map's key:\",k)\n    fmt.Println(\"map's val:\",v)\n}\n```\n\n由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用`_`来丢弃不需要的返回值\n\n例如\n\n```go\nfor _, v := range map{\n    fmt.Println(\"map's val:\", v)\n}\n```\n\n## switch\n\n有些时候需要写很多的`if-else`来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候`switch`就能很好的解决这个问题。它的语法如下\n\n```go\nswitch sExpr {\ncase expr1:\n    some instructions\ncase expr2:\n    some other instructions\ncase expr3:\n    some other instructions\ndefault:\n    other code\n}\n```\n\n`sExpr`和`expr1`、`expr2`、`expr3`的类型必须一致。Go的`switch`非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果`switch`没有表达式，它会匹配`true`。\n\n```go\ni := 10\nswitch i {\ncase 1:\n    fmt.Println(\"i is equal to 1\")\ncase 2, 3, 4:\n    fmt.Println(\"i is equal to 2, 3 or 4\")\ncase 10:\n    fmt.Println(\"i is equal to 10\")\ndefault:\n    fmt.Println(\"All I know is that i is an integer\")\n}\n```\n\n在第5行中，把很多值聚合在了一个`case`里面，同时，Go里面`switch`默认相当于每个`case`最后带有`break`，匹配成功后不会自动向下执行其他case，而是跳出整个`switch`, 但是可以使用`fallthrough`强制执行后面的case代码。\n\n```go\ninteger := 6\nswitch integer {\ncase 4:\n    fmt.Println(\"The integer was <= 4\")\n    fallthrough\ncase 5:\n    fmt.Println(\"The integer was <= 5\")\n    fallthrough\ncase 6:\n    fmt.Println(\"The integer was <= 6\")\n    fallthrough\ncase 7:\n    fmt.Println(\"The integer was <= 7\")\n    fallthrough\ncase 8:\n    fmt.Println(\"The integer was <= 8\")\n    fallthrough\ndefault:\n    fmt.Println(\"default case\")\n}\n```\n\n上面的程序将输出\n\n```\nThe integer was <= 6\nThe integer was <= 7\nThe integer was <= 8\ndefault case\n```\n\n# 函数\n\n## 函数的定义\n\n函数是Go里面的核心设计，它通过关键字`func`来声明，它的格式如下：\n\n```go\nfunc funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {\n    //这里是处理逻辑代码\n    //返回多个值\n    return value1, value2\n}\n```\n\n上面的代码可以看出\n\n- 关键字`func`用来声明一个函数`funcName`\n- 函数可以有一个或者多个参数，每个参数后面带有类型，通过`,`分隔\n\n- 函数可以返回多个值\n- 上面返回值声明了两个变量`output1`和`output2`，如果不想声明也可以，直接就两个类型\n\n- 如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号\n- 如果没有返回值，那么就直接省略最后的返回信息\n\n- 如果有返回值， 那么必须在函数的外层添加return语句\n\n下面来看一个实际应用函数的例子（用来计算Max值）\n\n```go\npackage main\nimport \"fmt\"\n// 返回a、b中最大值.\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\nfunc main() {\n    x := 3\n    y := 4\n    z := 5\n    max_xy := max(x, y) //调用函数max(x, y)\n    max_xz := max(x, z) //调用函数max(x, z)\n    fmt.Printf(\"max(%d, %d) = %d\\n\", x, y, max_xy)\n    fmt.Printf(\"max(%d, %d) = %d\\n\", x, z, max_xz)\n    fmt.Printf(\"max(%d, %d) = %d\\n\", y, z, max(y,z)) // 也可在这直接调用它\n}\n```\n\n上面这个里面可以看到`max`函数有两个参数，它们的类型都是`int`，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。\n\n## 多个返回值\n\nGo语言比C更先进的特性，其中一点就是函数能够返回多个值。\n\n直接看例子\n\n```go\npackage main\nimport \"fmt\"\n//返回 A+B 和 A*B\nfunc SumAndProduct(A, B int) (int, int) {\n    return A+B, A*B\n}\nfunc main() {\n    x := 3\n    y := 4\n    xPLUSy, xTIMESy := SumAndProduct(x, y)\n    fmt.Printf(\"%d + %d = %d\\n\", x, y, xPLUSy)\n    fmt.Printf(\"%d * %d = %d\\n\", x, y, xTIMESy)\n}\n```\n\n上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。\n\n```go\nfunc SumAndProduct(A, B int) (add int, Multiplied int) {\n    add = A+B\n    Multiplied = A*B\n    return\n}\n```\n\n## 变参\n\nGo函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：\n\n```go\nfunc myfunc(arg ...int) {}\n```\n\n`arg ...int`告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是`int`。在函数体中，变量`arg`是一个`int`的`slice`：\n\n```go\nfor _, n := range arg {\n    fmt.Printf(\"And the number is: %d\\n\", n)\n}\n```\n\n## 传值与传指针\n\n传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。\n\n为了验证上面的说法，来看一个例子\n\n```go\npackage main\nimport \"fmt\"\n//简单的一个函数，实现了参数+1的操作\nfunc add1(a int) int {\n    a = a+1 // 改变了a的值\n    return a //返回一个新值\n}\nfunc main() {\n    x := 3\n    fmt.Println(\"x = \", x)  // 应该输出 \"x = 3\"\n    x1 := add1(x)  //调用add1(x)\n    fmt.Println(\"x+1 = \", x1) // 应该输出\"x+1 = 4\"\n    fmt.Println(\"x = \", x)    // 应该输出\"x = 3\"\n}\n```\n\n虽然调用了`add1`函数，并且在`add1`中执行`a = a+1`操作，但是上面例子中`x`变量的值没有发生变化\n\n理由很简单：因为当调用`add1`的时候，`add1`接收的参数其实是`x`的copy，而不是`x`本身。\n\n如果真的需要传这个`x`本身,该怎么办呢？\n\n这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有`add1`函数知道`x`变量所在的地址，才能修改`x`变量的值。所以需要将`x`所在地址`&x`传入函数，并将函数的参数的类型由`int`改为`*int`，即改为指针类型，才能在函数中修改`x`变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子\n\n```go\npackage main\nimport \"fmt\"\n//简单的一个函数，实现了参数+1的操作\nfunc add1(a *int) int { // 请注意，\n    *a = *a+1 // 修改了a的值\n    return *a // 返回新值\n}\nfunc main() {\n    x := 3\n    fmt.Println(\"x = \", x)  // 应该输出 \"x = 3\"\n    x1 := add1(&x)  // 调用 add1(&x) 传x的地址\n    fmt.Println(\"x+1 = \", x1) // 应该输出 \"x+1 = 4\"\n    fmt.Println(\"x = \", x)    // 应该输出 \"x = 4\"\n}\n```\n\n这样，就达到了修改`x`的目的。那么到底传指针有什么好处呢？\n\n- 传指针使得多个函数能操作同一个对象。\n- 传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。\n\n- Go语言中`channel`，`slice`，`map`这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变`slice`的长度，则仍需要取地址传递指针）\n\n## defer\n\nGo语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：\n\n```go\nfunc ReadWrite() bool {\n    file.Open(\"file\")\n// 做一些工作\n    if failureX {\n        file.Close()\n        return false\n    }\n    if failureY {\n        file.Close()\n        return false\n    }\n    file.Close()\n    return true\n}\n```\n\n上面有很多重复的代码，Go的`defer`有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在`defer`后指定的函数会在函数退出前调用。\n\n```go\nfunc ReadWrite() bool {\n    file.Open(\"file\")\n    defer file.Close()\n    if failureX {\n        return false\n    }\n    if failureY {\n        return false\n    }\n    return true\n}\n```\n\n如果有很多调用`defer`，那么`defer`是采用后进先出模式，所以如下代码会输出`4 3 2 1 0`\n\n```go\nfor i := 0; i < 5; i++ {\n    defer fmt.Printf(\"%d \", i)\n}\n```\n\n通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。\n\n## 函数作为值、类型\n\n在Go中函数也是一种变量，可以通过`type`来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型\n\n```go\ntype typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])\n```\n\n函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子\n\n```go\npackage main\nimport \"fmt\"\ntype testInt func(int) bool // 声明了一个函数类型\nfunc isOdd(integer int) bool {\n    if integer%2 == 0 {\n        return false\n    }\n    return true\n}\nfunc isEven(integer int) bool {\n    if integer%2 == 0 {\n        return true\n    }\n    return false\n}\n// 声明的函数类型在这个地方当做了一个参数\nfunc filter(slice []int, f testInt) []int {\n    var result []int\n    for _, value := range slice {\n        if f(value) {\n            result = append(result, value)\n        }\n    }\n    return result\n}\nfunc main(){\n    slice := []int {1, 2, 3, 4, 5, 7}\n    fmt.Println(\"slice = \", slice)\n    odd := filter(slice, isOdd)    // 函数当做值来传递了\n    fmt.Println(\"Odd elements of slice are: \", odd)\n    even := filter(slice, isEven)  // 函数当做值来传递了\n    fmt.Println(\"Even elements of slice are: \", even)\n}\n```\n\n函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到`testInt`这个类型是一个函数类型，然后两个`filter`函数的参数和返回值与`testInt`类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。\n\n## Panic和Recover\n\nGo没有像Java那样的异常机制，它不能抛出异常，而是使用了`panic`和`recover`机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有`panic`的东西。这是个强大的工具，请明智地使用它。\n\nPanic\n\n是一个内建函数，可以中断原有的控制流程，进入一个`panic`状态中。当函数`F`调用`panic`，函数F的执行被中断，但是`F`中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，`F`的行为就像调用了`panic`。这一过程继续向上，直到发生`panic`的`goroutine`中所有调用的函数返回，此时程序退出。`panic`可以直接调用`panic`产生。也可以由运行时错误产生，例如访问越界的数组。\n\nRecover\n\n是一个内建的函数，可以让进入`panic`状态的`goroutine`恢复过来。`recover`仅在延迟函数中有效。在正常的执行过程中，调用`recover`会返回`nil`，并且没有其它任何效果。如果当前的`goroutine`陷入`panic`状态，调用`recover`可以捕获到`panic`的输入值，并且恢复正常的执行。\n\n下面这个函数演示了如何在过程中使用`panic`\n\n```go\nvar user = os.Getenv(\"USER\")\nfunc init() {\n    if user == \"\" {\n        panic(\"no value for $USER\")\n    }\n}\n```\n\n下面这个函数检查作为其参数的函数在执行时是否会产生`panic`：\n\n```go\nfunc throwsPanic(f func()) (b bool) {\n    defer func() {\n        if x := recover(); x != nil {\n            b = true\n        }\n    }()\n    f() //执行函数f，如果f中出现了panic，那么就可以恢复回来\n    return\n}\n```\n\n注意：\n\n`defer`必须在`panic`语句之前。\n\n`recover`必须配合`defer`使用。\n\n## `main`函数和`init`函数\n\nGo里面有两个保留的函数：`init`函数（能够应用于所有的`package`）和`main`函数（只能应用于`package main`）。这两个函数在定义时不能有任何的参数和返回值。虽然一个`package`里面可以写任意多个`init`函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个`package`中每个文件只写一个`init`函数。\n\nGo程序会自动调用`init()`和`main()`，所以不需要在任何地方调用这两个函数。每个`package`中的`init`函数都是可选的，但`package main`就必须包含一个`main`函数。\n\n程序的初始化和执行都起始于`main`包。如果`main`包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到`fmt`包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行`init`函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对`main`包中的包级常量和变量进行初始化，然后执行`main`包中的`init`函数（如果存在的话），最后执行`main`函数。\n\n## import\n\n在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：\n\n```go\nimport(\n    \"fmt\"\n)\n```\n\n然后代码里面可以通过如下的方式调用\n\n```go\nfmt.Println(\"hello world\")\n```\n\n上面这个fmt是Go语言的标准库，其实是去`GOROOT`环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：\n\n### 1、相对路径\n\n```go\nimport \"./model\" //当前文件同一目录的model目录，但是不建议这种方式来import\n```\n\n### 2、绝对路径\n\n```go\nimport \"shorturl/model\" //加载gopath/src/shorturl/model模块\n```\n\n上面展示了一些import常用的几种方式，但是还有一些\n\n### 特殊的import\n\n#### 1、点操作\n\n有时候会看到如下的方式导入包\n\n```go\nimport(\n    . \"fmt\"\n)\n```\n\n这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(\"hello world\")可以省略的写成`Println(\"hello world\")`\n\n#### 2、别名操作\n\n别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字\n\n```go\nimport(\n        f \"fmt\"\n    )\n```\n\n别名操作的话调用包函数时前缀变成了前缀，即`f.Println(\"hello world\")`\n\n#### 3、_操作\n\n这个操作经常是让很多人费解的一个操作符，请看下面这个`import`\n\n```go\nimport (\n    \"database/sql\"\n    _ \"github.com/ziutek/mymysql/godrv\"\n)\n```\n\n`_`操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的`init函数`。\n\n# struct类型\n\n## struct类型的声明\n\nGo语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型`person`代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之`struct`。如下代码所示:\n\n```go\ntype person struct {\n    name string\n    age int\n}\n```\n\n声明一个`struct`如此简单，上面的类型包含有两个字段\n\n- 一个`string`类型的字段name，用来保存用户名称这个属性\n- 一个`int`类型的字段age，用来保存用户年龄这个属性\n\n使用`struct`看下面的代码\n\n```go\ntype person struct {\n    name string\n    age int\n}\nvar P person  // P现在就是person类型的变量了\nP.name = \"Astaxie\"  // 赋值\"Astaxie\"给P的name属性.\nP.age = 25  // 赋值\"25\"给变量P的age属性\nfmt.Printf(\"The person's name is %s\", P.name)  // 访问P的name属性.\n```\n\n除了上面这种P的声明使用之外，还有另外几种声明使用方式：\n\n1. 按照顺序提供初始化值\n   `P := person{\"Tom\", 25}`\n2. 通过`field:value`的方式初始化，这样可以任意顺序\n   `P := person{age:24, name:\"Tom\"}`\n\n1. 当然也可以通过`new`函数分配一个指针，此处P的类型为`*person`\n   `P := new(person)`\n\n看一个完整的使用`struct`的例子\n\n```go\npackage main\nimport \"fmt\"\n// 声明一个新的类型\ntype person struct {\n    name string\n    age int\n}\n// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差\n// struct也是传值的\nfunc Older(p1, p2 person) (person, int) {\n    if p1.age>p2.age {  // 比较p1和p2这两个人的年龄\n        return p1, p1.age-p2.age\n    }\n    return p2, p2.age-p1.age\n}\nfunc main() {\n    var tom person\n    // 赋值初始化\n    tom.name, tom.age = \"Tom\", 18\n    // 两个字段都写清楚的初始化\n    bob := person{age:25, name:\"Bob\"}\n    // 按照struct定义顺序初始化值\n    paul := person{\"Paul\", 43}\n    tb_Older, tb_diff := Older(tom, bob)\n    tp_Older, tp_diff := Older(tom, paul)\n    bp_Older, bp_diff := Older(bob, paul)\n    fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\",\n        tom.name, bob.name, tb_Older.name, tb_diff)\n    fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\",\n        tom.name, paul.name, tp_Older.name, tp_diff)\n    fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\",\n        bob.name, paul.name, bp_Older.name, bp_diff)\n}\n```\n\n## `struct`的匿名字段\n\n定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。\n\n当匿名字段是一个`struct`的时候，那么这个`struct`所拥有的全部字段都被隐式地引入了当前定义的这个`struct`。\n\n看一个例子，让上面说的这些更具体化\n\n```go\npackage main\nimport \"fmt\"\ntype Human struct {\n    name string\n    age int\n    weight int\n}\ntype Student struct {\n    Human  // 匿名字段，那么默认Student就包含了Human的所有字段\n    speciality string\n}\nfunc main() {\n    // 初始化一个学生\n    mark := Student{Human{\"Mark\", 25, 120}, \"Computer Science\"}\n    // 访问相应的字段\n    fmt.Println(\"His name is \", mark.name)\n    fmt.Println(\"His age is \", mark.age)\n    fmt.Println(\"His weight is \", mark.weight)\n    fmt.Println(\"His speciality is \", mark.speciality)\n    // 修改对应的备注信息\n    mark.speciality = \"AI\"\n    fmt.Println(\"Mark changed his speciality\")\n    fmt.Println(\"His speciality is \", mark.speciality)\n    // 修改他的年龄信息\n    fmt.Println(\"Mark become old\")\n    mark.age = 46\n    fmt.Println(\"His age is\", mark.age)\n    // 修改他的体重信息\n    fmt.Println(\"Mark is not an athlet anymore\")\n    mark.weight += 60\n    fmt.Println(\"His weight is\", mark.weight)\n}\n```\n\n看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。\n\n```go\nmark.Human = Human{\"Marcus\", 55, 220}\nmark.Human.age -= 1\n```\n\n通过匿名访问和修改字段相当的有用，但是不仅仅是`struct`字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子\n\n```go\npackage main\nimport \"fmt\"\ntype Skills []string\ntype Human struct {\n    name string\n    age int\n    weight int\n}\ntype Student struct {\n    Human  // 匿名字段，struct\n    Skills // 匿名字段，自定义的类型string slice\n    int    // 内置类型作为匿名字段\n    speciality string\n}\nfunc main() {\n    // 初始化学生Jane\n    jane := Student{Human:Human{\"Jane\", 35, 100}, speciality:\"Biology\"}\n    // 现在访问相应的字段\n    fmt.Println(\"Her name is \", jane.name)\n    fmt.Println(\"Her age is \", jane.age)\n    fmt.Println(\"Her weight is \", jane.weight)\n    fmt.Println(\"Her speciality is \", jane.speciality)\n    // 修改他的skill技能字段\n    jane.Skills = []string{\"anatomy\"}\n    fmt.Println(\"Her skills are \", jane.Skills)\n    fmt.Println(\"She acquired two new ones \")\n    jane.Skills = append(jane.Skills, \"physics\", \"golang\")\n    fmt.Println(\"Her skills now are \", jane.Skills)\n    // 修改匿名内置类型字段\n    jane.int = 3\n    fmt.Println(\"Her preferred number is\", jane.int)\n}\n```\n\n从上面例子看出来`struct`不仅仅能够将`struct`作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。\n\n这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？\n\nGo里面很简单的解决了这个问题，最外层的优先访问，也就是当通过`student.phone`访问的时候，是访问student里面的字段，而不是human里面的字段。\n\n这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子\n\n```go\npackage main\nimport \"fmt\"\ntype Human struct {\n    name string\n    age int\n    phone string  // Human类型拥有的字段\n}\ntype Employee struct {\n    Human  // 匿名字段Human\n    speciality string\n    phone string  // 雇员的phone字段\n}\nfunc main() {\n    Bob := Employee{Human{\"Bob\", 34, \"777-444-XXXX\"}, \"Designer\", \"333-222\"}\n    fmt.Println(\"Bob's work phone is:\", Bob.phone)\n    // 如果要访问Human的phone字段\n    fmt.Println(\"Bob's personal phone is:\", Bob.Human.phone)\n}\n```\n\n# method\n\n函数的另一种形态，带有接收者的函数，称为`method`\n\n## method\n\n现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现\n\n```go\npackage main\nimport \"fmt\"\ntype Rectangle struct {\n    width, height float64\n}\nfunc area(r Rectangle) float64 {\n    return r.width*r.height\n}\nfunc main() {\n    r1 := Rectangle{12, 2}\n    r2 := Rectangle{9, 4}\n    fmt.Println(\"Area of r1 is: \", area(r1))\n    fmt.Println(\"Area of r2 is: \", area(r2))\n}\n```\n\n这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。\n\n这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成`area_rectangle, area_circle, area_triangle...`\n\n 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。\n\n很显然，这样的实现并不优雅，并且从概念上来说\"面积\"是\"形状\"的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。\n\n基于上面的原因所以就有了`method`的概念，`method`是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在`func`后面增加了一个receiver(也就是method所依从的主体)。\n\n用上面提到的形状的例子来说，method `area()` 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。\n\n更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。\n\n用Rob Pike的话来说就是：\n\n\"A method is a function with an implicit first argument, called a receiver.\"\n\nmethod的语法如下：\n\n```go\nfunc (r ReceiverType) funcName(parameters) (results)\n```\n\n下面用最开始的例子用method来实现：\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"math\"\n)\ntype Rectangle struct {\n    width, height float64\n}\ntype Circle struct {\n    radius float64\n}\nfunc (r Rectangle) area() float64 {\n    return r.width*r.height\n}\nfunc (c Circle) area() float64 {\n    return c.radius * c.radius * math.Pi\n}\nfunc main() {\n    r1 := Rectangle{12, 2}\n    r2 := Rectangle{9, 4}\n    c1 := Circle{10}\n    c2 := Circle{25}\n    fmt.Println(\"Area of r1 is: \", r1.area())\n    fmt.Println(\"Area of r2 is: \", r2.area())\n    fmt.Println(\"Area of c1 is: \", c1.area())\n    fmt.Println(\"Area of c2 is: \", c2.area())\n}\n```\n\n在使用method的时候重要注意几点\n\n- 虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样\n- method里面可以访问接收者的字段\n\n- 调用method通过`.`访问，就像struct里面访问字段一样\n\n在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。\n\n值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。\n\n那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。\n\n```\ntype typeName typeLiteral\n```\n\n请看下面这个申明自定义类型的代码\n\n```go\ntype ages int\ntype money float32\ntype months map[string]int\nm := months {\n    \"January\":31,\n    \"February\":28,\n    ...\n    \"December\":31,\n}\n```\n\n这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到`method` 可以在任何的自定义类型中定义任意多的`method`，接下来让看一个复杂一点的例子\n\n```go\npackage main\nimport \"fmt\"\nconst(\n    WHITE = iota\n    BLACK\n    BLUE\n    RED\n    YELLOW\n)\ntype Color byte\ntype Box struct {\n    width, height, depth float64\n    color Color\n}\ntype BoxList []Box //a slice of boxes\nfunc (b Box) Volume() float64 {\n    return b.width * b.height * b.depth\n}\nfunc (b *Box) SetColor(c Color) {\n    b.color = c\n}\nfunc (bl BoxList) BiggestColor() Color {\n    v := 0.00\n    k := Color(WHITE)\n    for _, b := range bl {\n        if bv := b.Volume(); bv > v {\n            v = bv\n            k = b.color\n        }\n    }\n    return k\n}\nfunc (bl BoxList) PaintItBlack() {\n    for i := range bl {\n        bl[i].SetColor(BLACK)\n    }\n}\nfunc (c Color) String() string {\n    strings := []string {\"WHITE\", \"BLACK\", \"BLUE\", \"RED\", \"YELLOW\"}\n    return strings[c]\n}\nfunc main() {\n    boxes := BoxList {\n        Box{4, 4, 4, RED},\n        Box{10, 10, 1, YELLOW},\n        Box{1, 1, 20, BLACK},\n        Box{10, 10, 1, BLUE},\n        Box{10, 30, 1, WHITE},\n        Box{20, 20, 20, YELLOW},\n    }\n    fmt.Printf(\"We have %d boxes in our set\\n\", len(boxes))\n    fmt.Println(\"The volume of the first one is\", boxes[0].Volume(), \"cm³\")\n    fmt.Println(\"The color of the last one is\",boxes[len(boxes)-1].color.String())\n    fmt.Println(\"The biggest one is\", boxes.BiggestColor().String())\n    fmt.Println(\"Let's paint them all black\")\n    boxes.PaintItBlack()\n    fmt.Println(\"The color of the second one is\", boxes[1].color.String())\n    fmt.Println(\"Obviously, now, the biggest one is\", boxes.BiggestColor().String())\n}\n```\n\n上面的代码通过const定义了一些常量，然后定义了一些自定义类型\n\n- Color作为byte的别名\n- 定义了一个struct:Box，含有三个长宽高字段和一个颜色属性\n\n- 定义了一个slice:BoxList，含有Box\n\n然后以上面的自定义类型为接收者定义了一些method\n\n- Volume()定义了接收者为Box，返回Box的容量\n- SetColor(c Color)，把Box的颜色改为c\n\n- BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色\n- PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色\n\n- String()定义在Color上面，返回Color的具体颜色(字符串格式)\n\n上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。\n\n## 指针作为receiver\n\n现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。\n\n定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。\n\n这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解\n\n这里也许会问SetColor函数里面应该这样定义`*b.Color=c`,而不是`b.Color=c`,需要读取到指针相应的值。\n\n其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成`(&bl[i]).SetColor(BLACK)`，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。\n\n也就是说：\n\n如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&V去调用这个method\n\n类似的\n\n如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method\n\n所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C/C++编程经验的同学来说，真是解决了一个很大的痛苦。\n\n## method继承\n\n通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子\n\n```go\npackage main\nimport \"fmt\"\ntype Human struct {\n    name string\n    age int\n    phone string\n}\ntype Student struct {\n    Human //匿名字段\n    school string\n}\ntype Employee struct {\n    Human //匿名字段\n    company string\n}\n//在human上面定义了一个method\nfunc (h *Human) SayHi() {\n    fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)\n}\nfunc main() {\n    mark := Student{Human{\"Mark\", 25, \"222-222-YYYY\"}, \"MIT\"}\n    sam := Employee{Human{\"Sam\", 45, \"111-888-XXXX\"}, \"Golang Inc\"}\n    mark.SayHi()\n    sam.SayHi()\n}\n```\n\n## method重写\n\n上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子\n\n```go\npackage main\nimport \"fmt\"\ntype Human struct {\n    name string\n    age int\n    phone string\n}\ntype Student struct {\n    Human //匿名字段\n    school string\n}\ntype Employee struct {\n    Human //匿名字段\n    company string\n}\n//Human定义method\nfunc (h *Human) SayHi() {\n    fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)\n}\n//Employee的method重写Human的method\nfunc (e *Employee) SayHi() {\n    fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name,\n        e.company, e.phone) //Yes you can split into 2 lines here.\n}\nfunc main() {\n    mark := Student{Human{\"Mark\", 25, \"222-222-YYYY\"}, \"MIT\"}\n    sam := Employee{Human{\"Sam\", 45, \"111-888-XXXX\"}, \"Golang Inc\"}\n    mark.SayHi()\n    sam.SayHi()\n}\n```\n\n通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。\n\n# interface\n\nGo语言里面设计最精妙的应该算`interface`，它让面向对象，内容组织实现非常的方便\n\n## 什么是interface\n\n简单的说，`interface`是一组`method`签名的组合，通过`interface`来定义对象的一组行为。\n\n前面例子中`Student`和`Employee`都能`SayHi`，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能`say hi`\n\n继续做更多的扩展，`Student`和`Employee`实现另一个方法`Sing`，然后`Student`实现方法`BorrowMoney`而`Employee`实现`SpendSalary`。\n\n这样`Student`实现了三个方法：`SayHi`、`Sing`、`BorrowMoney`；而`Employee`实现了`SayHi`、`Sing`、`SpendSalary`。\n\n上面这些方法的组合称为`interface`(被对象`Student`和`Employee`实现)。例如`Student`和`Employee`都实现了`interface`：`SayHi`和`Sing`，也就是这两个对象是该`interface`类型。而`Employee`没有实现这个`interface：SayHi、Sing`和`BorrowMoney`，因为`Employee`没有实现`BorrowMoney`这个方法。\n\n## interface类型\n\n`interface`类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子\n\n```go\ntype Human struct {\n    name string\n    age int\n    phone string\n}\ntype Student struct {\n    Human //匿名字段Human\n    school string\n    loan float32\n}\ntype Employee struct {\n    Human //匿名字段Human\n    company string\n    money float32\n}\n//Human对象实现Sayhi方法\nfunc (h *Human) SayHi() {\n    fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)\n}\n// Human对象实现Sing方法\nfunc (h *Human) Sing(lyrics string) {\n    fmt.Println(\"La la, la la la, la la la la la...\", lyrics)\n}\n//Human对象实现Guzzle方法\nfunc (h *Human) Guzzle(beerStein string) {\n    fmt.Println(\"Guzzle Guzzle Guzzle...\", beerStein)\n}\n// Employee重载Human的Sayhi方法\nfunc (e *Employee) SayHi() {\n    fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name,\n        e.company, e.phone) //此句可以分成多行\n}\n//Student实现BorrowMoney方法\nfunc (s *Student) BorrowMoney(amount float32) {\n    s.loan += amount // (again and again and...)\n}\n//Employee实现SpendSalary方法\nfunc (e *Employee) SpendSalary(amount float32) {\n    e.money -= amount // More vodka please!!! Get me through the day!\n}\n// 定义interface\ntype Men interface {\n    SayHi()\n    Sing(lyrics string)\n    Guzzle(beerStein string)\n}\ntype YoungChap interface {\n    SayHi()\n    Sing(song string)\n    BorrowMoney(amount float32)\n}\ntype ElderlyGent interface {\n    SayHi()\n    Sing(song string)\n    SpendSalary(amount float32)\n}\n```\n\n通过上面的代码可以知道，interface可以被任意的对象实现。看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。\n\n最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。\n\n## interface值\n\n那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。\n\n因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。\n\n来看一下下面这个例子:\n\n```go\npackage main\nimport \"fmt\"\ntype Human struct {\n    name string\n    age int\n    phone string\n}\ntype Student struct {\n    Human //匿名字段\n    school string\n    loan float32\n}\ntype Employee struct {\n    Human //匿名字段\n    company string\n    money float32\n}\n//Human实现SayHi方法\nfunc (h Human) SayHi() {\n    fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)\n}\n//Human实现Sing方法\nfunc (h Human) Sing(lyrics string) {\n    fmt.Println(\"La la la la...\", lyrics)\n}\n//Employee重载Human的SayHi方法\nfunc (e Employee) SayHi() {\n    fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name,\n        e.company, e.phone)\n    }\n// Interface Men被Human,Student和Employee实现\n// 因为这三个类型都实现了这两个方法\ntype Men interface {\n    SayHi()\n    Sing(lyrics string)\n}\nfunc main() {\n    mike := Student{Human{\"Mike\", 25, \"222-222-XXX\"}, \"MIT\", 0.00}\n    paul := Student{Human{\"Paul\", 26, \"111-222-XXX\"}, \"Harvard\", 100}\n    sam := Employee{Human{\"Sam\", 36, \"444-222-XXX\"}, \"Golang Inc.\", 1000}\n    tom := Employee{Human{\"Tom\", 37, \"222-444-XXX\"}, \"Things Ltd.\", 5000}\n    //定义Men类型的变量i\n    var i Men\n    //i能存储Student\n    i = mike\n    fmt.Println(\"This is Mike, a Student:\")\n    i.SayHi()\n    i.Sing(\"November rain\")\n    //i也能存储Employee\n    i = tom\n    fmt.Println(\"This is tom, an Employee:\")\n    i.SayHi()\n    i.Sing(\"Born to be wild\")\n    //定义了slice Men\n    fmt.Println(\"Let's use a slice of Men and see what happens\")\n    x := make([]Men, 3)\n    //这三个都是不同类型的元素，但是他们实现了interface同一个接口\n    x[0], x[1], x[2] = paul, sam, mike\n    for _, value := range x{\n        value.SayHi()\n    }\n}\n```\n\n通过上面的代码，发现`interface`就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了`duck-typing`:即\"当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子\"。\n\n## 空interface\n\n空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。\n\n```go\n// 定义a为空接口\nvar a interface{}\nvar i int = 5\ns := \"Hello world\"\n// a可以存储任意类型的数值\na = i\na = s\n```\n\n一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回`interface{}`,那么也就可以返回任意类型的值。是不是很有用啊！\n\n## interface函数参数\n\ninterface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。\n\n举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:\n\n```go\ntype Stringer interface {\n     String() string\n}\n```\n\n也就是说，任何实现了String方法的类型都能作为参数被`fmt.Println`调用,来试一试\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"strconv\"\n)\ntype Human struct {\n    name string\n    age int\n    phone string\n}\n// 通过这个方法 Human 实现了 fmt.Stringer\nfunc (h Human) String() string {\n    return \"❰\"+h.name+\" - \"+strconv.Itoa(h.age)+\" years -  ✆ \" +h.phone+\"❱\"\n}\nfunc main() {\n    Bob := Human{\"Bob\", 39, \"000-7777-XXX\"}\n    fmt.Println(\"This Human is : \", Bob)\n}\n```\n\n\n\n现在再回顾一下前面的Box示例，发现Color结构也定义了一个`method：String`。其实这也是实现了`fmt.Stringer`这个`interface`，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现`Stringer`这个接口。如果没有实现这个接口，fmt将以默认的方式输出。\n\n```go\n//实现同样的功能\nfmt.Println(\"The biggest one is\", boxes.BiggestsColor().String())\nfmt.Println(\"The biggest one is\", boxes.BiggestsColor())\n```\n\n注：实现了`error`接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。\n\n## interface变量存储的类型\n\ninterface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：\n\n- Comma-ok断言\n\nGo语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。\n\n如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。\n\n通过一个例子来更加深入的理解。\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"strconv\"\n)\ntype Element interface{}\ntype List [] Element\ntype Person struct {\n    name string\n    age int\n}\n//定义了String方法，实现了fmt.Stringer\nfunc (p Person) String() string {\n    return \"(name: \" + p.name + \" - age: \"+strconv.Itoa(p.age)+ \" years)\"\n}\nfunc main() {\n    list := make(List, 3)\n    list[0] = 1 // an int\n    list[1] = \"Hello\" // a string\n    list[2] = Person{\"Dennis\", 70}\n    for index, element := range list {\n        if value, ok := element.(int); ok {\n            fmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n        } else if value, ok := element.(string); ok {\n            fmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n        } else if value, ok := element.(Person); ok {\n            fmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n        } else {\n            fmt.Printf(\"list[%d] is of a different type\\n\", index)\n        }\n    }\n}\n```\n\n是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。\n\n- switch测试\n\n重写上面的这个实现\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"strconv\"\n)\ntype Element interface{}\ntype List [] Element\ntype Person struct {\n    name string\n    age int\n}\n//打印\nfunc (p Person) String() string {\n    return \"(name: \" + p.name + \" - age: \"+strconv.Itoa(p.age)+ \" years)\"\n}\nfunc main() {\n    list := make(List, 3)\n    list[0] = 1 //an int\n    list[1] = \"Hello\" //a string\n    list[2] = Person{\"Dennis\", 70}\n    for index, element := range list{\n        switch value := element.(type) {\n            case int:\n            fmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n            case string:\n            fmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n            case Person:\n            fmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n            default:\n            fmt.Println(\"list[%d] is of a different type\", index)\n        }\n    }\n}\n```\n\n这里有一点需要强调的是：`element.(type)`语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用`comma-ok`。\n\n## 嵌入interface\n\nGo里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。\n\n可以看到源码包`container/heap`里面有这样的一个定义\n\n```go\ntype Interface interface {\n    sort.Interface //嵌入字段sort.Interface\n    Push(x interface{}) //a Push method to push elements into the heap\n    Pop() interface{} //a Pop elements that pops elements from the heap\n}\n```\n\n看到`sort.Interface`其实就是嵌入字段，把`sort.Interface`的所有`method`给隐式的包含进来了。也就是下面三个方法：\n\n```go\ntype Interface interface {\n    // Len is the number of elements in the collection.\n    Len() int\n    // Less returns whether the element with index i should sort\n    // before the element with index j.\n    Less(i, j int) bool\n    // Swap swaps the elements with indexes i and j.\n    Swap(i, j int)\n}\n```\n\n另一个例子就是io包下面的 `io.ReadWriter` ，它包含了io包下面的`Reader`和`Writer`两个`interface`：\n\n```go\n// io.ReadWriter\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n```\n\n# 反射\n\nGo语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是`reflect`包。如何运用`reflect`包，官方的这篇文章详细的讲解了`reflect`包的实现原理，`laws of reflection` 链接地址为 http://golang.org/doc/articles/laws_of_reflection.html\n\n使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了`空interface`)，首先需要把它转化成`reflect`对象(`reflect.Type`或者`reflect.Value`，根据不同的情况调用不同的函数)。这两种获取方式如下：\n\n```go\nt := reflect.TypeOf(i)    //得到类型的元数据,通过t能获取类型定义里面的所有元素\nv := reflect.ValueOf(i)   //得到实际的值，通过v获取存储在里面的值，还可以去改变值\n```\n\n转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如\n\n```go\ntag := t.Elem().Field(0).Tag  //获取定义在struct里面的标签\nname := v.Elem().Field(0).String()  //获取存储在第一个字段里面的值\n```\n\n获取反射值能返回相应的类型和数值\n\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", v.Type())\nfmt.Println(\"kind is float64:\", v.Kind() == reflect.Float64)\nfmt.Println(\"value:\", v.Float())\n```\n\n最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误\n\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nv.SetFloat(7.1)\n```\n\n如果要修改相应的值，必须这样写\n\n```go\nvar x float64 = 3.4\np := reflect.ValueOf(&x)\nv := p.Elem()\nv.SetFloat(7.1)\n```\n\n# 并发\n\nGo从语言层面支持了并行。\n\n## goroutine\n\n`goroutine`是`Go`并行设计的核心。`goroutine`说到底其实就是协程，但是它比线程更小，十几个`goroutine`可能体现在底层就是五六个线程，Go语言内部实现了这些`goroutine`之间的内存共享。执行`goroutine`只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。`goroutine`比`thread`更易用、更高效、更轻便。\n\n`goroutine`是通过Go的`runtime`管理的一个线程管理器。`goroutine`通过`go`关键字实现了，其实就是一个普通的函数。\n\n```go\ngo hello(a, b, c)\n```\n\n通过关键字go就启动了一个`goroutine`。来看一个例子\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"runtime\"\n)\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        runtime.Gosched()\n        fmt.Println(s)\n    }\n}\nfunc main() {\n    go say(\"world\") //开一个新的Goroutines执行\n    say(\"hello\") //当前Goroutines执行\n}\n// 以上程序执行后将输出：\n// hello\n// world\n// hello\n// world\n// hello\n// world\n// hello\n// world\n// hello\n```\n\n可以看到go关键字很方便的就实现了并发编程。\n\n上面的多个`goroutine`运行在同一个进程里面，共享内存数据，不过设计上要遵循：不要通过共享来通信，而要通过通信来共享。\n\n`runtime.Gosched()`表示让CPU把时间片让给别人,下次某个时候继续恢复执行该`goroutine`。\n\n默认情况下，在Go 1.5将标识并发系统线程个数的`runtime.GOMAXPROCS`的初始值由1改为了`运行环境的CPU核数`。\n\n但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 `runtime.GOMAXPROCS(n)` 告诉调度器同时使用多个线程。`GOMAXPROCS` 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果`n < 1`，不会改变当前设置。\n\n## channels\n\n`goroutine`运行在相同的地址空间，因此访问共享内存必须做好同步。那么`goroutine`之间如何进行数据的通信呢，Go提供了一个很好的通信机制`channel`。`channel`可以与`Unix shell` 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：`channel类型`。定义一个`channel`时，也需要定义发送到`channel`的值的类型。注意，必须使用`make` 创建`channel`：\n\n```go\nci := make(chan int)\ncs := make(chan string)\ncf := make(chan interface{})\n```\n\n`channel`通过操作符`<-`来接收和发送数据\n\n```go\nch <- v    // 发送v到channel ch.\nv := <-ch  // 从ch中接收数据，并赋值给v\n```\n\n把这些应用到例子中来：\n\n```go\npackage main\nimport \"fmt\"\nfunc sum(a []int, c chan int) {\n    total := 0\n    for _, v := range a {\n        total += v\n    }\n    c <- total  // send total to c\n}\nfunc main() {\n    a := []int{7, 2, 8, -9, 4, 0}\n    c := make(chan int)\n    go sum(a[:len(a)/2], c)\n    go sum(a[len(a)/2:], c)\n    x, y := <-c, <-c  // receive from c\n    fmt.Println(x, y, x + y)\n}\n```\n\n默认情况下，`channel`接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得`Goroutines`同步变的更加的简单，而不需要显式的`lock`。所谓阻塞，也就是如果读取（`value := <-ch`）它将会被阻塞，直到有数据接收。其次，任何发送（`ch<-5`）将会被阻塞，直到数据被读出。无缓冲`channel`是在多个`goroutine`之间同步很棒的工具。\n\n## Buffered Channels\n\n上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。`ch:= make(chan bool`, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。\n\n```go\nch := make(chan type, value)\n```\n\n当 `value = 0` 时，channel 是无缓冲阻塞读写的，当`value > 0` 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。\n\n看一下下面这个例子，可以在自己本机测试一下，修改相应的value值\n\n```go\npackage main\nimport \"fmt\"\nfunc main() {\n    c := make(chan int, 2)//修改2为1就报错，修改2为3可以正常运行\n    c <- 1\n    c <- 2\n    fmt.Println(<-c)\n    fmt.Println(<-c)\n}\n//修改为1报如下的错误:\n//fatal error: all goroutines are asleep - deadlock!\n```\n\n## Range和Close\n\n上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子\n\n```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc fibonacci(n int, c chan int) {\n    x, y := 1, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x + y\n    }\n    close(c)\n}\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n```\n\n`for i := range c`能够不断的读取`channel`里面的数据，直到该`channel`被显式的关闭。上面代码看到可以显式的关闭`channel`，生产者通过内置函数`close`关闭`channel`。关闭`channel`之后就无法再发送任何数据了，在消费方可以通过语法`v, ok := <-ch`测试`channel`是否被关闭。如果ok返回false，那么说明`channel`已经没有任何数据并且已经被关闭。\n\n记住应该在生产者的地方关闭`channel`，而不是消费的地方去关闭它，这样容易引起`panic`\n\n另外记住一点的就是`channel`不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束`range`循环之类的\n\n## Select\n\n上面介绍的都是只有一个`channel`的情况，那么如果存在多个`channel`的时候，该如何操作呢，Go里面提供了一个关键字`select`，通过`select`可以监听`channel`上的数据流动。\n\n`select`默认是阻塞的，只有当监听的`channel`中有发送或接收可以进行时才会运行，当多个`channel`都准备好的时候，`select`是随机的选择一个执行的。\n\n```go\npackage main\nimport \"fmt\"\nfunc fibonacci(c, quit chan int) {\n    x, y := 1, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x + y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n```\n\n在`select`里面还有`default`语法，`select`其实就是类似`switch`的功能，`default`就是当监听的`channel`都没有准备好的时候，默认执行的（`select`不再阻塞等待`channel`）。\n\n```go\nselect {\ncase i := <-c:\n    // use i\ndefault:\n    // 当c阻塞的时候执行这里\n}\n```\n\n## 超时\n\n有时候会出现`goroutine`阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用`select`来设置超时，通过如下的方式实现：\n\n```go\nfunc main() {\n    c := make(chan int)\n    o := make(chan bool)\n    go func() {\n        for {\n            select {\n                case v := <- c:\n                    println(v)\n                case <- time.After(5 * time.Second):\n                    println(\"timeout\")\n                    o <- true\n                    break\n            }\n        }\n    }()\n    <- o\n}\n```\n\n## runtime goroutine\n\n`runtime`包中有几个处理`goroutine`的函数：\n\n- `Goexit` : 退出当前执行的goroutine，但是defer函数还会继续调用\n- `Gosched`: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。\n\n- `NumCPU` : 返回 CPU 核数量\n- `NumGoroutine`: 返回正在执行和排队的任务总数\n\n- `GOMAXPROCS` : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。\n\n# 错误处理\n\nGo语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。\n\n在C语言里面是通过返回`-1`或者`NULL`之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而`Go`定义了一个叫做`error`的类型，来显式表达错误。在使用时，通过把返回的`error`变量与`nil`的比较，来判定操作是否成功。例如`os.Open`函数在打开文件失败时将返回一个不为`nil`的`error`变量\n\n```go\nfunc Open(name string) (file *File, err error)\n```\n\n下面这个例子通过调用`os.Open`打开一个文件，如果出现错误，那么就会调用`log.Fatal`来输出错误信息：\n\n```go\nf, err := os.Open(\"filename.ext\")\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n类似于`os.Open`函数，标准包中所有可能出错的API都会返回一个`error`变量，以方便错误处理，这个小节将详细地介绍`error`类型的设计，和讨论开发Web应用中如何更好地处理`error`。\n\n## Error类型\n\nerror类型是一个接口类型，这是它的定义：\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\nerror是一个内置的接口类型，可以在`/builtin/`包下面找到相应的定义。而在很多内部包里面用到的 `error`是`errors`包下面的实现的私有结构`errorString`\n\n```go\n// errorString is a trivial implementation of error.\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n可以通过`errors.New`把一个字符串转化为`errorString`，以得到一个满足接口`error`的对象，其内部实现如下：\n\n```go\n// New returns an error that formats as the given text.\nfunc New(text string) error {\n    return &errorString{text}\n}\n```\n\n下面这个例子演示了如何使用`errors.New`:\n\n```go\nfunc Sqrt(f float64) (float64, error) {\n    if f < 0 {\n        return 0, errors.New(\"math: square root of negative number\")\n    }\n    // implementation\n}\n```\n\n在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了`non-nil`的`error`对象，将此对象与`nil`比较，结果为`true`，所以`fmt.Println`(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：\n\n```go\nf, err := Sqrt(-1)\nif err != nil {\n    fmt.Println(err)\n}\n```\n\n## 自定义Error\n\n`error`是一个`interface`，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：\n\n```go\ntype SyntaxError struct {\n    msg    string // 错误描述\n    Offset int64  // 错误发生的位置\n}\n\nfunc (e *SyntaxError) Error() string { return e.msg }\n```\n\n`Offset`字段在调用`Error`的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:\n\n```go\nif err := dec.Decode(&val); err != nil {\n    if serr, ok := err.(*json.SyntaxError); ok {\n        line, col := findLine(f, serr.Offset)\n        return fmt.Errorf(\"%s:%d:%d: %v\", f.Name(), line, col, err)\n    }\n    return err\n}\n```\n\n需要注意的是，函数返回自定义错误时，返回值推荐设置为`error`类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：\n\n```go\nfunc Decode() *SyntaxError { // 错误，将可能导致上层调用者err!=nil的判断永远为true。\n    var err *SyntaxError     // 预声明错误变量\n    if 出错条件 {\n        err = &SyntaxError{}\n    }\n    return err               // 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true\n}\n```\n\n原因见 `http://golang.org/doc/faq#nil_error` (需科学上网)\n\n上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：\n\n```go\npackage net\n\ntype Error interface {\n    error\n    Timeout() bool   // Is the error a timeout?\n    Temporary() bool // Is the error temporary?\n}\n```\n\n在调用的地方，通过类型断言`err`是不是`net.Error`,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：\n\n```go\nif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n    time.Sleep(1e9)\n    continue\n}\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n## 错误处理\n\nGo在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。\n\n请看下面这个例子代码：\n\n```go\nfunc init() {\n    http.HandleFunc(\"/view\", viewRecord)\n}\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        http.Error(w, err.Error(), 500)\n        return\n    }\n    if err := viewTemplate.Execute(w, record); err != nil {\n        http.Error(w, err.Error(), 500)\n    }\n}\n```\n\n上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数`http.Error`，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的`HandleFunc`加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码\n\n```go\ntype appHandler func(http.ResponseWriter, *http.Request) error\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := fn(w, r); err != nil {\n        http.Error(w, err.Error(), 500)\n    }\n}\n```\n\n上面定义了自定义的路由器，然后可以通过如下方式来注册函数：\n\n```go\nfunc init() {\n    http.Handle(\"/view\", appHandler(viewRecord))\n}\n```\n\n当请求`/view`的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。\n\n```go\nfunc viewRecord(w http.ResponseWriter, r *http.Request) error {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        return err\n    }\n    return viewTemplate.Execute(w, record)\n}\n```\n\n上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：\n\n```go\ntype appError struct {\n    Error   error\n    Message string\n    Code    int\n}\n```\n\n这样自定义路由器可以改成如下方式：\n\n```go\ntype appHandler func(http.ResponseWriter, *http.Request) *appError\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if e := fn(w, r); e != nil { // e is *appError, not os.Error.\n        c := appengine.NewContext(r)\n        c.Errorf(\"%v\", e.Error)\n        http.Error(w, e.Message, e.Code)\n    }\n}\n```\n\n这样修改完自定义错误之后，逻辑处理可以改成如下方式：\n\n```go\nfunc viewRecord(w http.ResponseWriter, r *http.Request) *appError {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        return &appError{err, \"Record not found\", 404}\n    }\n    if err := viewTemplate.Execute(w, record); err != nil {\n        return &appError{err, \"Can't display record\", 500}\n    }\n    return nil\n}\n```\n\n如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。\n\n## 总结\n\n在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。\n"
        },
        {
          "name": "Go基础语法宝典.pdf",
          "type": "blob",
          "size": 1020.34375,
          "content": null
        },
        {
          "name": "Go自带库的使用说明.md",
          "type": "blob",
          "size": 84.1025390625,
          "content": "# Go 中的时间操作\n\nGolang中与时间有关的操作，主要涉及到 time 包，核心数据结构是 `time.Time`，如下：\n\n```go\ntype Time struct {\n    wall uint64\n    ext  int64\n    loc *Location\n}\n```\n\n### 1、获取时间相关函数\n\n#### 1.1 获取当前时间\n\n```go\n// 返回当前时间，注意此时返回的是 time.Time 类型\nnow := time.Now()\nfmt.Println(now)\n// 当前时间戳\nfmt.Println(now.Unix())\n// 纳秒级时间戳\nfmt.Println(now.UnixNano())\n// 时间戳小数部分 单位：纳秒\nfmt.Println(now.Nanosecond())\n```\n\n输出：\n\n```go\n2021-01-10 14:56:15.930562 +0800 CST m=+0.000124449\n1610261775\n1610261775930562000\n930562000\n```\n\n#### 1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作\n\n```go\nnow := time.Now()\n// 返回日期\nyear, month, day := now.Date()\nfmt.Printf(\"year:%d, month:%d, day:%d\\n\", year, month, day)\n// 年\nfmt.Println(now.Year())\n// 月\nfmt.Println(now.Month())\n// 日\nfmt.Println(now.Day())\n// 时分秒\nhour, minute, second := now.Clock()\nfmt.Printf(\"hour:%d, minute:%d, second:%d\\n\", hour, minute, second)\n// 时\nfmt.Println(now.Hour())\n// 分\nfmt.Println(now.Minute())\n// 秒\nfmt.Println(now.Second())\n// 返回星期\nfmt.Println(now.Weekday())\n//返回一年中对应的第几天\nfmt.Println(now.YearDay())\n//返回时区\nfmt.Println(now.Location())\n// 返回一年中第几天\nfmt.Println(now.YearDay())\n```\n\n#### 1.3 格式化时间\n\nGo 语言提供了时间类型格式化函数 `Format()`，需要注意的是 Go 语言格式化时间模板不是常见的 `Y-m-d H:i:s`，而是 2006-01-02 15:04:05，也很好记忆(2006 1 2 3 4 5)。\n\n```go\nnow := time.Now()\nfmt.Println(now.Format(\"2006-01-02 15:04:05\"))\nfmt.Println(now.Format(\"2006-01-02\"))\nfmt.Println(now.Format(\"15:04:05\"))\nfmt.Println(now.Format(\"2006/01/02 15:04\"))\nfmt.Println(now.Format(\"15:04 2006/01/02\"))\n```\n\n### 2、时间戳与日期字符串相互转化\n\n时间戳转成日期格式，需要先转成将时间戳转成 `time.Time` 类型再格式化成日期格式。\n\n#### 2.1 根据秒数、纳秒数返回 `time.Time` 类型\n\n```go\nnow := time.Now()\nlayout := \"2006-01-02 15:04:05\"\nt := time.Unix(now.Unix(),0)    // 参数分别是：秒数,纳秒数\nfmt.Println(t.Format(layout))\n```\n\n#### 2.2 根据指定时间返回 `time.Time` 类型，使用函数 `time.Date()`\n\n```go\nnow := time.Now()\nlayout := \"2006-01-02 15:04:05\"\n//根据指定时间返回 time.Time 类型\n//分别指定年，月，日，时，分，秒，纳秒，时区\nt := time.Date(2011, time.Month(3), 12, 15, 30, 20, 0, now.Location())\nfmt.Println(t.Format(layout))\n```\n\n#### 2.3 日期字符串解析成 `time.Time` 类型\n\n```go\nt, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", time.Now().Format(\"2006-01-02 15:04:05\"), time.Local)\nfmt.Println(t)  \n// 输出 2021-01-10 17:28:50 +0800 CST\n// time.Local 指定本地时间\n```\n\n解析的时候需要特别注意时区的问题：\n\n```go\nfmt.Println(time.Now())\nfmt.Println(time.Now().Location())\nt, _ := time.Parse(\"2006-01-02 15:04:05\", \"2021-01-10 15:01:02\")\nfmt.Println(t)\n```\n\n输出：\n\n```\n2021-01-10 17:22:10.951904 +0800 CST m=+0.000094166\nLocal\n2021-01-10 15:01:02 +0000 UTC\n```\n\n可以看到，`time.Now()` 使用的 CST(中国标准时间)，而 `time.Parse()` 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 `time.ParseInLocation()`，可以指定时区。![img](https://cdn.nlark.com/yuque/0/2021/gif/396745/1610587943191-e1905a90-4157-43d7-8623-c98b46969a36.gif)\n\n### 3、计算、比较日期\n\n讲到日期的计算就不得不提 time 包提供的一种新的类型 `Duration`，源码是这样定义的：\n\n```go\ntype Duration int64\n```\n\n底层类型是 int64，表示一段时间间隔，单位是 纳秒。\n\n#### 3.1 24小时之内的时间计算\n\n```go\nnow := time.Now()\nfmt.Println(now)\n// 1小时1分1s之后\nt1, _ := time.ParseDuration(\"1h1m1s\")\nfmt.Println(t1)\nm1 := now.Add(t1)\nfmt.Println(m1)\n// 1小时1分1s之前\nt2, _ := time.ParseDuration(\"-1h1m1s\")\nm2 := now.Add(t2)\nfmt.Println(m2)\n// 3小时之前\nt3, _ := time.ParseDuration(\"-1h\")\nm3 := now.Add(t3 * 3)\nfmt.Println(m3)\n// 10 分钟之后\nt4, _ := time.ParseDuration(\"10m\")\nm4 := now.Add(t4)\nfmt.Println(m4)\n// Sub 计算两个时间差\nsub1 := now.Sub(m3)\nfmt.Println(sub1.Hours())   // 相差小时数\nfmt.Println(sub1.Minutes()) // 相差分钟数\n```\n\n额外再介绍两个函数 `time.Since()`、`time.Until()`：\n\n```go\n// 返回当前时间与 t 的时间差，返回值是 Duration\ntime.Since(t Time) Duration\n// 返回 t 与当前时间的时间差，返回值是 Duration\ntime.Until(t Time) Duration\n\nnow := time.Now()\nfmt.Println(now)\nt1, _ := time.ParseDuration(\"-1h\")\nm1 := now.Add(t1)\nfmt.Println(m1)\nfmt.Println(time.Since(m1))\nfmt.Println(time.Until(m1))\n```\n\n输出：\n\n```\n2021-01-10 20:41:48.668232 +0800 CST m=+0.000095594\n2021-01-10 19:41:48.668232 +0800 CST m=-3599.999904406\n1h0m0.000199007s\n-1h0m0.000203035s\n```\n\n#### 3.2 24小时之外的时间计算\n\n涉及到一天以外的时间计算，就需要用到 `time.AddDate()`，函数原型：\n\n```go\nfunc (t Time) AddDate(years int, months int, days int) Time\n```\n\n比如想知道 一年一个月零一天 之后的时间，就可以这样：\n\n```go\nnow := time.Now()\nfmt.Println(now)\nm1 := now.AddDate(1,1,1)\nfmt.Println(m1)\n```\n\n再比如，想获得 2 天之前时间：\n\n```go\nnow := time.Now()\nfmt.Println(now)\nm1 := now.AddDate(0,0,-2)\nfmt.Println(m1)\n```\n\n#### 3.3 日期比较\n\n日期的比较总共有三种：之前、之后和相等。\n\n```go\n// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。\nfunc (t Time) Before(u Time) bool\n// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。\nfunc (t Time) After(u Time) bool\n// 比较时间是否相等，相等返回真；否则返回假。\nfunc (t Time) Equal(u Time) bool\n\nnow := time.Now()\nfmt.Println(now)\n// 1小时之后\nt1, _ := time.ParseDuration(\"1h\")\nm1 := now.Add(t1)\nfmt.Println(m1)\nfmt.Println(m1.After(now))\nfmt.Println(now.Before(m1))\nfmt.Println(now.Equal(m1))\n```\n\n输出：\n\n```\n2021-01-10 21:00:44.409785 +0800 CST m=+0.000186800\n2021-01-10 22:00:44.409785 +0800 CST m=+3600.000186800\ntrue\ntrue\nfalse\n```\n\n### 4、常见例子\n\n下面列举一些常见的例子和函数封装。\n\n#### 4.1 日期格式 转 时间戳\n\n```go\nfunc TimeStr2Time(fmtStr,valueStr, locStr string) int64 {\n    loc := time.Local\n    if locStr != \"\" {\n        loc, _ = time.LoadLocation(locStr) // 设置时区\n    }\n    if fmtStr == \"\" {\n        fmtStr = \"2006-01-02 15:04:05\"\n    }\n    t, _ := time.ParseInLocation(fmtStr, valueStr, loc)\n    return t.Unix()\n}\n```\n\n#### 4.2 获取当前时间日期格式\n\n```go\nfunc GetCurrentFormatStr(fmtStr string) string {\n    if fmtStr == \"\" {\n        fmtStr = \"2006-01-02 15:04:05\"\n    }\n    return time.Now().Format(fmtStr)\n}\n```\n\n#### 4.3 时间戳 to 日期格式\n\n```go\nfunc Sec2TimeStr(sec int64, fmtStr string) string {\n    if fmtStr == \"\" {\n        fmtStr = \"2006-01-02 15:04:05\"\n    }\n    return time.Unix(sec, 0).Format(fmtStr)\n}\n```\n\n# Go-regexp正则\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nconst text = \"My email is ccmouse@gmail.com\"\n\nfunc main() {\n\tcompile := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+`)\n\tmatch := compile.FindString(text)\n\tfmt.Println(match)\n}\n```\n\n# Go存储基础 — 文件 IO 操作\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059277-22fc4174-ea19-40a1-96a9-dc837804eaff.png)\n\n## 两大 IO 分类\n\n计算的体系架构，CPU，内存，网络，IO。那么 IO 是什么呢？一般理解成 Input、Output 的缩写，通俗话就是输入输出的意思。\n\nIO 分为网络和存储 IO 两种类型（**其实网络 IO 和磁盘 IO 在 Go 里面有着根本性区别**）。网络 IO 对应的是网络数据传输过程，网络是分布式系统的基石，通过网络把离散的物理节点连接起来，形成一个有机的系统。\n\n存储 IO 对应的就是数据存储到物理介质的过程，通常物理介质对应的是磁盘，磁盘上一般会分个区，然后在上面格式化个文件系统出来，所以普通程序员最常看见的是文件 IO 的形式。\n\n在 Golang 里可以归类出两种读写文件的方式：\n\n1. 标准库封装：操作对象 `File`;\n2. 系统调用 ：操作对象 `fd`;\n\n## 读写数据要素\n\n文件的读写最核心的要素是什么？\n\n通俗来讲：读文件，就是把磁盘上的文件的**特定位置**的数据读到**内存的 buffer** 。写文件，就是把**内存 buffer** 的数据写到磁盘的文件的**特定位置**。\n\n这里注意到两个关键词：\n\n1. 特定位置；\n2. 内存 buffer；\n\n**特定位置怎么理解？怎么指定所谓的**`特定位置`**？**\n\n很简单，用 `[ offset, length ]` 这两个参数就能标识一段位置。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059263-970193ad-ab90-4abd-8c62-bf040410e14d.png)\n\n也就是 IO 偏移和长度，Offset 和 Length。\n\n**内存 buffer 怎么理解？**\n\n归根结底，文件的数据和谁直接打交道？**内存**，写的时候是从内存写到磁盘文件的，读的时候是从磁盘文件读到内存的。\n\n本质上，下面的 IO 函数都离不开 Offset，Length，buffer 这三个要素。\n\n## 标准库封装\n\nGo 对文件进行读写非常简单，因为 Go 已经封装了一个非常便捷的使用接口，位于标准库 os 中。Go 标准库对文件 IO 的封装也就是 Go 推荐对文件进行 IO 时使用的操作方式。\n\n### 打开文件（Open）\n\n```go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n```\n\nOpen 文件之后，获取到一个句柄，也就是 `File` 结构，之后对文件的读写都是基于 `File` 结构之上进行的。\n\n```go\ntype File struct {\n    *file // os specific\n}\n```\n\n文件读写只需要针对这个句柄结构体做操作即可。\n\n另外有一点隐藏起来的知识点必须要提一下：**偏移**。也就是最开始强调的读写 3 要素之一的 Offset 。打开（`Open`）文件的时候，文件当前偏移量默认设置为 0，也就是说 IO 的起始位置就是文件的最开头。举个例子，如果这个时候，写 4K 的数据到文件，那么就是写 [0, 4K] 这个位置的数据，如果之前这上面已经有数据了，那么就会是覆盖写。\n\n除非 `Open` 文件的时候指定 `O_APPEND` 选项，偏移量会设置为文件末尾，那么 IO 都是从文件末尾开始。\n\n### 文件写操作（Write）\n\n文件 `File` 句柄对象有两个写方法：\n\n第一种：写一个 buffer 到文件 ，使用文件当前偏移\n\n```go\nfunc (f *File) Write(b []byte) (n int, err error)\n```\n\n**注意：该写操作会导致文件偏移量的增加。**\n\n第二种：从指定文件偏移，写入 buffer 到文件\n\n```go\nfunc (f *File) WriteAt(b []byte, off int64) (n int, err error)\n```\n\n**注意：该写操作不会更新文件偏移量**\n\n### 文件读操作（Read）\n\n和写对应，文件 `File` 句柄对象有两个读方法：\n\n第一种：从文件当前偏移读一个 buffer 的数据上来\n\n```go\nfunc (f *File) Read(b []byte) (n int, err error)\n```\n\n**注意：该读操作会导致文件偏移量的增加。**\n\n第二种：从指定文件偏移，读一个 buffer 大小的数据上来\n\n```go\nfunc (f *File) ReadAt(b []byte, off int64) (n int, err error)\n```\n\n**注意：该读操作不会更新文件偏移量**\n\n### 指定偏移量（Seek）\n\n```go\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error)\n```\n\n这个句柄方法允许用户指定文件的偏移位置。这个很容易理解，举个例子，文件刚开始是 0 字节，写 1M 的数据下去，大小变成 1M，Offset 往后挪 1M ，默认就是往后挪。\n\n现在 Seek 方法允许把写的偏移定位到任意位置，可以就可以从任意地方覆盖写入数据。\n\n所以在 Go 里面，文件 IO 非常简单，先 Open 一个文件，拿到 `File` 句柄，然后就可以使用这个句柄 Write ，Read，Seek 就能进行 IO 了。\n\n## 底层的原理\n\nGo 的标准库 `os` 提供了极其方便的封装，深入最原始的本质可以发现最核心的东西：**系统调用**。\n\nGo 标准库的文件存储 IO 就是基于系统调用之上的。可以稍微跟一下 `os.OpenFile` 的调用：\n\nos 库的 `OpenFile` 函数：\n\n```go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error) {\n    f, err := openFileNolog(name, flag, perm)\n    if err != nil {\n        return nil, err\n    }\n    f.appendMode = flag&O_APPEND != 0\n    return f, nil\n}\n```\n\n稍微看下 `openFileNolog` 函数：\n\n```go\nfunc openFileNolog(name string, flag int, perm FileMode) (*File, error) {\n    var r int\n    for {\n        var e error\n        r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))\n        if e == nil {\n            break\n        }\n        if runtime.GOOS == \"darwin\" && e == syscall.EINTR {\n            continue\n        }\n        return nil, &PathError{\"open\", name, e}\n    }\n    return newFile(uintptr(r), name, kindOpenFile), nil\n}\n```\n\n可以看到 `syscall.Open` ，这个函数获取到一个整数，也就是在 c 语言里最常见的 fd 句柄，而 `File` 结构体则仅仅是基于这个的一层封装而已。\n\n**思考下，为什么会有标准库封装这一层存在？**\n\n**划重点：为了屏蔽操作系统的区别**，使用这个标准库的所有操作都是跨平台的。换句话说，如果是特殊操作系统才有的特性，那么在 os 库里就找不到对应封装的 IO 操作。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059293-a7135eb0-0608-41ad-8262-cc658863c19d.png)\n\n那么怎么使用系统调用？\n\n直接使用 syscall 库，也就是系统调用。从名字也能看出来，系统调用是和操作系统强相关的，因为是操作系统提供的调用接口，所以系统调用会因为操作系统不同而导致不同的特性，不同的接口。\n\n所以，如果直接使用 syscall 库来使用系统调用，那么需要自己来承受系统带来的兼容性问题。\n\n## 系统调用\n\n系统调用在 syscall 里有一层最基础的封装：\n\n### 文件 Open\n\n```go\nfunc Open(path string, mode int, perm uint32) (fd int, err error) \n```\n\n### 文件 Read\n\n```go\nfunc Read(fd int, p []byte) (n int, err error) func Pread(fd int, p []byte, offset int64) (n int, err error) \n```\n\n文件读有两个接口，一个 `Read` 是从**当前默认偏移**读一个 buffer 数据，`Pread` 接口则是从指定位置读数据的接口。\n\n思考一个问题：`Pread` 从效果上来讲等于 `Seek` 和 `Read` 组合起来使用，那么是否可以认为 `Pread` 就可以被 `Seek` + `Read` 替代呢？\n\n不行！根本原因在于 `Seek` + `Read` 是在用户层就是两步操作，而 `Pread` 虽然是 `Seek` + `Read` 的效果，但是操作系统给到用户的语义是：`Pread` 是一个原子操作。还有一个重要区别，`Pread` 不会改变当前文件的偏移量（普通的 `Read` 调用会更新偏移量）。\n\n**所以，总结下，**`**Pread**` **和顺序调用** `**Seek**` **后调用** `**Read**`  **有两点重要区别：**\n\n1. `Pread` 对用户提供的语义是原子操作，在调用 `Pread` 时，无法中断 `Seek` 和 `Read` 操作；\n2. `Pread` 调用不会更新当前文件偏移量；\n\n### 文件 Write\n\n```go\nfunc Write(fd int, p []byte) (n int, err error) func Pwrite(fd int, p []byte, offset int64) (n int, err error) \n```\n\n文件写对应也是有两种接口，`Wrtie` 和 `Pwrite` 分别是对应 `Read` 和 `Pread` 。同样的，`Pwrite` 作用上也是相当于先调用 `Seek`  再调用 `Write` ，但是同样的也有**两点不同**：\n\n1. `Pwrite`  完成 `Seek` 和 `Write` 对外是原子操作的语义；\n2. `Pwrite` 调用不会更新当前文件偏移量；\n\n### 文件 Seek\n\n```go\nfunc Seek(fd int, offset int64, whence int) (off int64, err error) \n```\n\n这个函数调用允许用户指定偏移（这个会影响到 `Read` 和 `Write` 读写的位置）。一般来说，每个打开文件都有一个相关联的“当前文件偏移量”（ current file offset ）。读（`Read`）、写（`Write`）操作都是从**当前文件偏移量处**开始，并且 `Read` 和 `Write` 会导致偏移量增加，增加量就是所读写的字节数。\n\n**小结一下**：Go核心的 Open，Read，Write，Seek 几个系统调用，可以发现一个明显不同与标准 IO 库的区别：**系统调用操作对象是一个整数句柄**。`Open` 文件得到一个整数 fd，之后的所有 IO 都是针对这个 fd 来操作的。这个明显和标准库不同，os 标准库 OpenFile 得到的是一个 `File` 结构体，所有的 IO 也是针对这个结构体的。\n\n## 层次架构\n\n那么究竟封装的层次一般是什么样的呢， Unix 编程里面开篇就有一张如下图：\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059414-c1855d9c-8b70-473a-83ac-7889f7e0c8a9.png)\n\n这张图就非常形象的讲明白了整个 Unix 体系结构。\n\n- 内核是最核心的实现，包括了和 IO 设备，硬件交互等功能。与内核紧密的一层是内核提供给外部调用的系统调用，系统调用提供了用户态到内核态调用的一个通道；\n- 对于系统调用，各个语言的标准库会有一些封装，比如 **C 语言的 libc 库，Go 语言的 os ，syscall 库都是类似的地位，这个就是所谓的公共库**。这层封装的作用最主要是简化普通程序员使用效率，并且屏蔽系统细节，为跨平台提供基础（同样的，为了跨平台的特性，可能会阉割很多不兼容的功能，所以才会有直接调用系统掉调用的需求）；\n\n- 当然，右上角还看到一个缺口，应用程序除了可以使用公共函数库，**其实是可以直接调用系统调用的，但是由此带来的复杂性又应用自己承担**。这种需求也是很常见的，标准库封装了通用的东西，同样割舍了很多系统调用的功能，这种情况下，只能通过系统调用来获取；\n\n## 总结\n\n1. IO 大类分为网络 IO 和磁盘 IO，IO 对文件来说就是读写操作，写的时候**数据从内存到磁盘**，读的时候**数据从磁盘到内存**；\n2. Go 文件 IO 最常用的是 os 库，使用 Go 封装的标准库，`os.OpenFile` 打开，`File.Write`，`File.Read` 进行读写，操作对象都是 `File` 结构体；\n\n1. Go 标准库对 IO 的封装是为了屏蔽复杂的系统调用，提供跨平台的使用姿势。然后单独提供 `syscall` 库，让程序员自我决策使用要使用更丰富的系统调用功能，当然后果自负；\n2. Go 标准库 IO 操作对象是 `File` ，系统调用 IO 操作对象是 fd（非负整数）。\n\n1. `Open` 文件默认当前偏移量是 0 （文件最开始），加上 `O_APPEND` 参数之后偏移量会是文件末尾。通过 Seek 调用可以任意指定文件偏移，从而影响文件 IO 的位置；\n2. `Read`，`Write` 函数只有 buffer （buffer 有长度），偏移则使用当前文件偏移量；\n\n1. `Pread`，`Pwrite` 的系统调用效果等同于 `Seek` 偏移量然后 `Read`，`Write`，但是又大有不同。对外语义是原子操作，并且不更新当前文件偏移量；\n\n# Go-文件读写操作\n\n### 读写文件\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n/*在已存在文件清空原有内容进行追加*/\nfunc main() {\n\tfilePath := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err = %v\\n\", err)\n\t\treturn\n\t}\n\t/*关闭文件流*/\n\tdefer file.Close()\n\t/*读取*/\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tstr, err := reader.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Print(str)\n\t}\n\t/*写入文件*/\n\tstr := \"hello FCC您好！！！\\r\\n\"\n\twriter := bufio.NewWriter(file)\n\tfor i := 0; i < 5; i++ {\n\t\twriter.WriteString(str)\n\t}\n\t/*因为writer是带缓存的，需要通过flush到磁盘*/\n\twriter.Flush()\n}\n```\n\n### 文件内容拷贝至新文件\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\n/*将文件1的内容拷贝到文件2*/\nfunc main() {\n\tfile1Path := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile2Path := \"D:\\\\fcofficework\\\\DNS\\\\2.txt\"\n\tdata, err := ioutil.ReadFile(file1Path)\n\tif err != nil {\n\t\tfmt.Printf(\"read file err=%v\", err)\n\t\treturn\n\t}\n\terr = ioutil.WriteFile(file2Path, data, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"write file err=%v\\n\", err)\n\t}\n}\n```\n\n### 判断文件或者目录是否存在\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n/*判断文件以及目录是否存在*/\nfunc PathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\tfmt.Println(\"当前文件存在！\")\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\tfmt.Println(\"当前文件不存在！\")\n\t\treturn false, nil\n\t}\n\treturn false, nil\n}\n\nfunc main() {\n\tpath := \"D:\\\\fcofficework\\\\2.txt\"\n\tPathExists(path)\n}\n```\n\n### 文件的拷贝\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n/*文件的拷贝*/\n\nfunc CopyFile(dstFileName string, srcFileName string) (written int64, err error) {\n\tsrcFile, err := os.Open(srcFileName)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err=%v\\n\", err)\n\t}\n\treader := bufio.NewReader(srcFile)\n\n\tdstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err=%v\\n\", err)\n\t\treturn\n\t}\n\twriter := bufio.NewWriter(dstFile)\n\tdefer dstFile.Close()\n\treturn io.Copy(writer, reader)\n}\n\nfunc main() {\n\tsrcFile := \"D:\\\\Photos\\\\Datapicture\\\\mmexport1530688562488.jpg\"\n\tdstFile := \"D:\\\\Photos\\\\1.jpg\"\n\t_, err := CopyFile(dstFile, srcFile)\n\tif err == nil {\n\t\tfmt.Println(\"拷贝完成！\")\n\t} else {\n\t\tfmt.Println(\"拷贝失败，err=\", err)\n\t}\n}\n```\n\n### 读取文件并统计文件中字符的个数\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n/*统计文件的字符个数*/\n\ntype CharCount struct {\n\t/*英文的个数*/\n\tChCount int\n\t/*数字的个数*/\n\tNumCount int\n\t/*空格的个数*/\n\tSpaceCount int\n\t/*其他字符的个数*/\n\tOtherCount int\n}\n\nfunc main() {\n\tfileName := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile, err := os.Open(fileName)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err=%v\\n\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tvar count CharCount\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tstr, err := reader.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range str {\n\t\t\tswitch {\n\t\t\tcase v >= 'a' && v <= 'z':\n\t\t\t\tfallthrough\n\t\t\tcase v >= 'A' && v <= 'Z':\n\t\t\t\tcount.ChCount++\n\t\t\tcase v == ' ' || v == '\\t':\n\t\t\t\tcount.SpaceCount++\n\t\t\tcase v >= '0' && v <= '9':\n\t\t\t\tcount.NumCount++\n\t\t\tdefault:\n\t\t\t\tcount.OtherCount++\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"字符的个数为：%v 数字的个数为：%v 空格的个数为：%v 其他字符的个数为：%v\",\n\t\tcount.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)\n}\n```\n\n### 三种读取文件的方式\n\n#### 通过os读取\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"d:\\\\Photos\\\\Screenshots\\\\暗物质\\\\IMG_20180927_194619.jpg\")\n\tif err != nil {\n\t\tfmt.Println(\"open file err\", err)\n\t}\n\tfmt.Printf(\"file=%v\", file)\n\terr1 := file.Close()\n\tif err1 != nil {\n\t\tfmt.Println(\"close file err = \", err1)\n\t}\n}\n```\n\n#### 缓冲式读取文件\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n/*缓冲式读取文件*/\nfunc main() {\n\tfile, err := os.Open(\"d:\\\\Photos\\\\Screenshots\\\\暗物质\\\\IMG_20180927_194619.jpg\")\n\tif err != nil {\n\t\tfmt.Println(\"open file err\", err)\n\t}\n\tdefer file.Close()\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tstr, err := reader.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Print(str)\n\t}\n\tfmt.Println(\"文件读取结束!\")\n}\n```\n\n#### 通过ioutil读取\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tfile := \"D:\\\\fcofficework\\\\DNS\\\\authorized_keys\"\n\tcontent, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\tfmt.Printf(\"read file err=%v\", err)\n\t}\n\tfmt.Printf(\"%v\", string(content))\n}\n```\n\n### 文件写入的案例\n\n#### 在文件写入内容，没有则重新创建\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\n/*在文件写入内容，没有文件则重新创建*/\nfunc main() {\n\tfilePath := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err = %v\\n\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tstr := \"hello world\\r\\n\"\n\twriter := bufio.NewWriter(file)\n\tfor i := 0; i < 5; i++ {\n\t\twriter.WriteString(str)\n\t}\n\t/*因为writer是带缓存的，需要通过flush到磁盘*/\n\twriter.Flush()\n}\n```\n\n#### 在已存在文件清空原有内容重新写入\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\n/*在已存在文件清空原有内容重新写入*/\nfunc main() {\n\tfilePath := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err = %v\\n\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tstr := \"hello FCC\\r\\n\"\n\twriter := bufio.NewWriter(file)\n\tfor i := 0; i < 5; i++ {\n\t\twriter.WriteString(str)\n\t}\n\t/*因为writer是带缓存的，需要通过flush到磁盘*/\n\twriter.Flush()\n}\n```\n\n#### 在已存在文件清空原有内容进行追加\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\n/*在已存在文件清空原有内容进行追加*/\nfunc main() {\n\tfilePath := \"D:\\\\fcofficework\\\\DNS\\\\1.txt\"\n\tfile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"open file err = %v\\n\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tstr := \"hello FCC您好！！！\\r\\n\"\n\twriter := bufio.NewWriter(file)\n\tfor i := 0; i < 5; i++ {\n\t\twriter.WriteString(str)\n\t}\n\t/*因为writer是带缓存的，需要通过flush到磁盘*/\n\twriter.Flush()\n}\n```\n\n### 解析命令行参数\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n/*解析命令行参数*/\nfunc main() {\n\tfmt.Println(\"命令行参数有：\", len(os.Args))\n\tfor i, v := range os.Args {\n\t\tfmt.Printf(\"args[%v]=%v\\n\", i, v)\n\t}\n}\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\n/*解析命令行参数*/\nfunc main() {\n\tvar user string\n\tvar pwd string\n\tvar host string\n\tvar port int\n\tflag.StringVar(&user, \"u\", \"\", \"用户名，默认为空\")\n\tflag.StringVar(&pwd, \"pwd\", \"\", \"密码，默认为空\")\n\tflag.StringVar(&host, \"h\", \"localhost\", \"主机名，默认为空\")\n\tflag.IntVar(&port, \"port\", 3306, \"端口号，默认为空\")\n\t/*转换*/\n\tflag.Parse()\n\tfmt.Printf(\"user=%v pwd=%v host=%v port=%v\", user, pwd, host, port)\n}\n```\n\n# Go-json序列化\n\n### 序列化\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Monster struct {\n\tName     string  `json:\"name\"`\n\tAge      int     `json:\"age\"`\n\tBirthday string  `json:\"birthday\"`\n\tSal      float64 `json:\"sal\"`\n\tSkill    string  `json:\"skill\"`\n}\n\n/*结构体序列化*/\nfunc NewMinsterStruct() {\n\tmonster := Monster{\n\t\tName:     \"孙悟空\",\n\t\tAge:      500,\n\t\tBirthday: \"2011-11-11\",\n\t\tSal:      8000.0,\n\t\tSkill:    \"如意七十二变\",\n\t}\n\tdata, err := json.Marshal(&monster)\n\tif err != nil {\n\t\tfmt.Printf(\"序列化错误err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"Map序列化后=%v\\n\", string(data))\n}\n\n/*Map序列化*/\nfunc MapSerlizer() {\n\tvar a map[string]interface{}\n\ta = make(map[string]interface{})\n\ta[\"name\"] = \"牛魔王\"\n\ta[\"age\"] = 10\n\ta[\"address\"] = \"火云洞\"\n\tdata, err := json.Marshal(a)\n\tif err != nil {\n\t\tfmt.Printf(\"序列化错误err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"monster序列化后=%v\\n\", string(data))\n}\n\n/*切片序列化*/\nfunc SliceSerlizer() {\n\tvar slice []map[string]interface{}\n\tvar m1 map[string]interface{}\n\tm1 = make(map[string]interface{})\n\tm1[\"name\"] = \"TGH\"\n\tm1[\"age\"] = \"19\"\n\tm1[\"address\"] = \"北京\"\n\tslice = append(slice, m1)\n\n\tvar m2 map[string]interface{}\n\tm2 = make(map[string]interface{})\n\tm2[\"name\"] = \"FCC\"\n\tm2[\"age\"] = \"18\"\n\tm2[\"address\"] = [2]string{\"华府\", \"影视帝国\"}\n\tslice = append(slice, m2)\n\n\tdata, err := json.Marshal(slice)\n\tif err != nil {\n\t\tfmt.Printf(\"序列化错误err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"切片序列化后=%v\\n\", string(data))\n}\n\n/*基本数据类型序列化*/\nfunc FloatSerlize() {\n\tvar num1 float64 = 245.56\n\tdata, err := json.Marshal(num1)\n\tif err != nil {\n\t\tfmt.Printf(\"序列化错误err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"基本数据类型序列化后=%v\\n\", string(data))\n}\n\nfunc main() {\n\tNewMinsterStruct()\n\tMapSerlizer()\n\tSliceSerlizer()\n\tFloatSerlize()\n}\nMap序列化后={\"name\":\"孙悟空\",\"age\":500,\"birthday\":\"2011-11-11\",\"sal\":8000,\"skill\":\"如意七十二变\"}\nmonster序列化后={\"address\":\"火云洞\",\"age\":10,\"name\":\"牛魔王\"}\n切片序列化后=[{\"address\":\"北京\",\"age\":\"19\",\"name\":\"TGH\"},{\"address\":[\"华府\",\"影视帝国\"],\"age\":\"18\",\"name\":\"FCC\"}]\n基本数据类型序列化后=245.56\n```\n\n### 反序列化\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Monster struct {\n\tName     string  `json:\"name\"`\n\tAge      int     `json:\"age\"`\n\tBirthday string  `json:\"birthday\"`\n\tSal      float64 `json:\"sal\"`\n\tSkill    string  `json:\"skill\"`\n}\n\nfunc unmarshalStruct() {\n\tstr := \"{\\\"name\\\":\\\"孙悟空\\\",\\\"age\\\":500,\\\"birthday\\\":\\\"2011-11-11\\\",\\\"sal\\\":8000,\\\"skill\\\":\\\"如意七十二变\\\"}\"\n\tvar monster Monster\n\terr := json.Unmarshal([]byte(str), &monster)\n\tif err != nil {\n\t\tfmt.Printf(\"反序列化失败err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"反序列化后monster：%v\\n\", monster)\n}\n\nfunc unmarshallMap() {\n\tstr := \"{\\\"address\\\":\\\"火云洞\\\",\\\"age\\\":10,\\\"name\\\":\\\"牛魔王\\\"}\"\n\tvar a map[string]interface{}\n\terr := json.Unmarshal([]byte(str), &a)\n\tif err != nil {\n\t\tfmt.Printf(\"反序列化失败err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"反序列化Map后：%v\\n\", a)\n}\n\nfunc unmarshalSlice() {\n\tstr := \"[{\\\"address\\\":\\\"北京\\\",\\\"age\\\":\\\"19\\\",\\\"name\\\":\\\"TGH\\\"},\" +\n\t\t\"{\\\"address\\\":[\\\"华府\\\",\\\"影视帝国\\\"],\\\"age\\\":\\\"18\\\",\\\"name\\\":\\\"FCC\\\"}]\"\n\tvar slice []map[string]interface{}\n\terr := json.Unmarshal([]byte(str), &slice)\n\tif err != nil {\n\t\tfmt.Printf(\"反序列化失败err：%v\\n\", err)\n\t}\n\tfmt.Printf(\"反序列化Slice后：%v\\n\", slice)\n}\n\nfunc main() {\n\tunmarshalStruct()\n\tunmarshallMap()\n\tunmarshalSlice()\n}\n```\n\n输出结果：\n\n```go\n反序列化后monster：{孙悟空 500 2011-11-11 8000 如意七十二变} \n反序列化Map后：map[address:火云洞 age:10 name:牛魔王] \n反序列化Slice后：[map[address:北京 age:19 name:TGH] map[address:[华府 影视帝国] age:18 name:FCC]]\n```\n\n# Go-HTTP包的使用\n\nWeb是基于http协议的一个服务，Go语言里面提供了一个完善的net/http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。\n\n## http包建立Web服务器\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strings\"\n    \"log\"\n)\nfunc sayhelloName(w http.ResponseWriter, r *http.Request) {\n    r.ParseForm()  //解析参数，默认是不会解析的\n    fmt.Println(r.Form)  //这些信息是输出到服务器端的打印信息\n    fmt.Println(\"path\", r.URL.Path)\n    fmt.Println(\"scheme\", r.URL.Scheme)\n    fmt.Println(r.Form[\"url_long\"])\n    for k, v := range r.Form {\n        fmt.Println(\"key:\", k)\n        fmt.Println(\"val:\", strings.Join(v, \"\"))\n    }\n    fmt.Fprintf(w, \"Hello golang!\") //这个写入到w的是输出到客户端的\n}\nfunc main() {\n    http.HandleFunc(\"/\", sayhelloName) //设置访问的路由\n    err := http.ListenAndServe(\":8080\", nil) //设置监听的端口\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}\n```\n\n上面这个代码，build之后，然后执行web.exe,这个时候其实已经在8080端口监听http链接请求了。\n\n在浏览器输入`http://localhost:8080`\n\n可以看到浏览器页面输出了`Hello golang!`\n\n浏览器输入地址：\n\n```\nhttp://localhost:8080/?url_long=var1&url_long=var2\n```\n\n可以看看浏览器输出的是什么\n\n看到上面的代码，要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。\n\n## 使用http包请求页面\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n)\n\nfunc main() {\n\trequest, err := http.NewRequest(http.MethodGet, \"http://www.imooc.com\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trequest.Header.Add(\"User-Agent\",\n\t\t\"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\")\n\n\tclient := http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\tfmt.Println(\"Redirect:\", req)\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tresp, err := client.Do(request)\n\t//resp, err := http.DefaultClient.Do(request)\n\t//resp, err := http.Get(\"http://www.imooc.com\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\ts, err := httputil.DumpResponse(resp, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(string(s))\n}\n```\n\n程序运行打印出HTML内容\n\n![img](https://cdn.nlark.com/yuque/0/2020/png/396745/1603443525745-bf6b18f4-8ee9-45a8-8e21-67531abdf88b.png)\n\n# net/http包的坑——i/o timeout\n\n### 问题\n\n来看一段日常代码。\n\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net\"\n    \"net/http\"\n    \"time\"\n)\n\nvar tr *http.Transport\n\nfunc init() {\n    tr = &http.Transport{\n        MaxIdleConns: 100,\n        Dial: func(netw, addr string) (net.Conn, error) {\n            conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时\n            if err != nil {\n                return nil, err\n            }\n            err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时\n            if err != nil {\n                return nil, err\n            }\n            return conn, nil\n        },\n    }\n}\n\nfunc main() {\n    for {\n        _, err := Get(\"http://www.baidu.com/\")\n        if err != nil {\n            fmt.Println(err)\n            break\n        }\n    }\n}\n\n\nfunc Get(url string) ([]byte, error) {\n    m := make(map[string]interface{})\n    data, err := json.Marshal(m)\n    if err != nil {\n        return nil, err\n    }\n    body := bytes.NewReader(data)\n    req, _ := http.NewRequest(\"Get\", url, body)\n    req.Header.Add(\"content-type\", \"application/json\")\n\n    client := &http.Client{\n        Transport: tr,\n    }\n    res, err := client.Do(req)\n    if res != nil {\n        defer res.Body.Close()\n    }\n    if err != nil {\n        return nil, err\n    }\n    resBody, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        return nil, err\n    }\n    return resBody, nil\n}\n```\n\n做的事情，比较简单，就是循环去请求http://www.baidu.com/, 然后等待响应。\n\n看上去貌似没啥问题吧。\n\n代码跑起来，也确实能正常收发消息。\n\n但是这段代码跑一段时间，就会出现i/o timeout的报错。\n\n这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，这边对代码做了简化。\n\n实际生产中发生的现象是，golang服务在发起http调用时，虽然`http.Transport`设置了3s超时，会偶发出现i/o timeout的报错。\n\n但是查看下游服务的时候，发现下游服务其实100ms就已经返回了。\n\n### 排查\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1621351380664-f90f9eac-6fcd-4446-8a4e-d08df02ab269.png)\n\n五层网络协议对应的消息体变化分析\n\n就很奇怪了，明明服务端显示处理耗时才100ms，且客户端超时设的是3s, 怎么就出现超时报错i/o timeout呢？\n\n这里推测有两个可能。\n\n- 因为服务端打印的日志其实只是服务端应用层打印的日志。但客户端应用层发出数据后，中间还经过客户端的传输层，网络层，数据链路层和物理层，再经过服务端的物理层，数据链路层，网络层，传输层到服务端的应用层。服务端应用层处耗时100ms，再原路返回。那剩下的3s-100ms可能是耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。\n- 网络没问题，客户端到服务端链路整个收发流程大概耗时就是100ms左右。客户端处理逻辑问题导致超时。\n\n一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了，不死心就抓个包看下。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1621351368734-c0656d47-9e8b-41c1-bdbb-115362ceebe8.png)\n\n抓包结果\n\n分析下，从刚开始三次握手（画了红框的地方）。\n\n到最后出现超时报错i/o timeout（画了蓝框的地方）。\n\n从time那一列从7到10，确实间隔3s。而且看右下角的蓝框，是51169端口发到80端口的一次Reset连接。\n\n80端口是服务端的端口。换句话说就是客户端3s超时主动断开链接的。\n\n但是再仔细看下第一行三次握手到最后客户端超时主动断开连接的中间，其实有非常多次HTTP请求。\n\n回去看代码设置超时的方式。\n\n```go\ntr = &http.Transport{\n    MaxIdleConns: 100,\n    Dial: func(netw, addr string) (net.Conn, error) {\n        conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时\n        if err != nil {\n            return nil, err\n        }\n        err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时\n        if err != nil {\n            return nil, err\n        }\n        return conn, nil\n    },\n}\n```\n\n也就是说，这里的3s超时，其实是在建立连接之后开始算的，而不是单次调用开始算的超时。\n\n看注释里写的是\n\nSetDeadline sets the read and write deadlines associated with theconnection.\n\n### 超时原因\n\n大家知道HTTP是应用层协议，传输层用的是TCP协议。\n\nHTTP协议从1.0以前，默认用的是短连接，每次发起请求都会建立TCP连接。收发数据。然后断开连接。\n\nTCP连接每次都是三次握手。每次断开都要四次挥手。\n\n其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。\n\n于是乎，HTTP协议从1.1之后就默认使用长连接。具体相关信息可以看之前的[这篇文章](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect)。\n\n那么golang标准库里也兼容这种实现。\n\n通过建立一个连接池，针对每个域名建立一个TCP长连接，比如http://baidu.com和http://golang.com就是两个不同的域名。\n\n第一次访问http://baidu.com域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问http://baidu.com的时候会重新从连接池里把这个连接捞出来复用。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1621351347346-43a1b64f-2a30-46d4-8fbb-0e201084f4bd.png)\n\n复用长连接\n\n为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应一个读goroutine和一个写goroutine。正因为是同一个域名，所以最后才会泄漏3个goroutine，如果不同域名的话，那就会泄漏1+2*N个协程，N就是域名数。\n\n假设第一次请求要100ms，每次请求完http://baidu.com后都放入连接池中，下次继续复用，重复29次，耗时2900ms。\n\n第30次请求的时候，连接从建立开始到服务返回前就已经用了3000ms，刚好到设置的3s超时阈值，那么此时客户端就会报超时i/o timeout。\n\n虽然这时候服务端其实才花了100ms，但耐不住前面29次加起来的耗时已经很长。\n\n也就是说只要通过`http.Transport`设置了`err = conn.SetDeadline(time.Now().Add(time.Second * 3))`，并且用了长连接，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，程序会报超时错误。\n\n### 正确姿势\n\n原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。\n\n另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。\n\n基于这两点，改一下代码。\n\n```go\npackage main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"time\"\n)\n\nvar tr *http.Transport\n\nfunc init() {\n    tr = &http.Transport{\n        MaxIdleConns: 100,\n        // 下面的代码被干掉了\n        //Dial: func(netw, addr string) (net.Conn, error) {\n        //  conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时\n        //  if err != nil {\n        //      return nil, err\n        //  }\n        //  err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时\n        //  if err != nil {\n        //      return nil, err\n        //  }\n        //  return conn, nil\n        //},\n    }\n}\n\n\nfunc Get(url string) ([]byte, error) {\n    m := make(map[string]interface{})\n    data, err := json.Marshal(m)\n    if err != nil {\n        return nil, err\n    }\n    body := bytes.NewReader(data)\n    req, _ := http.NewRequest(\"Get\", url, body)\n    req.Header.Add(\"content-type\", \"application/json\")\n\n    client := &http.Client{\n        Transport: tr,\n        Timeout: 3*time.Second,  // 超时加在这里，是每次调用的超时\n    }\n    res, err := client.Do(req) \n    if res != nil {\n        defer res.Body.Close()\n    }\n    if err != nil {\n        return nil, err\n    }\n    resBody, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        return nil, err\n    }\n    return resBody, nil\n}\n\nfunc main() {\n    for {\n        _, err := Get(\"http://www.baidu.com/\")\n        if err != nil {\n            fmt.Println(err)\n            break\n        }\n    }\n}\n```\n\n看注释会发现，改动的点有两个\n\n- `http.Transport`里的建立连接时的一些超时设置干掉了。\n- 在发起http请求的时候会场景`http.Client`，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释\n\n```\nTimeout specifies a time limit forrequestsmade by this Client.\n```\n\n到这里，代码就改好了，实际生产中问题也就解决了。\n\n实例代码里，如果拿去跑的话，其实还会下面的错\n\n```\nGet http://www.baidu.com/: EOF\n```\n\n这个是因为调用得太猛了，http://www.baidu.com那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，毕竟每个人都像这么搞，服务器是会炸的。。。\n\n解决方案很简单，每次HTTP调用中间加个sleep间隔时间就好。\n\n到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。\n\n### 源码分析\n\n用的go版本是1.12.7。\n\n从发起一个网络请求开始跟。\n\n```go\nres, err := client.Do(req)\nfunc (c *Client) Do(req *Request) (*Response, error) {\n    return c.do(req)\n}\n\nfunc (c *Client) do(req *Request) {\n    // ...\n    if resp, didTimeout, err = c.send(req, deadline); err != nil {\n        // ...\n    }\n    // ...  \n}  \nfunc send(ireq *Request, rt RoundTripper, deadline time.Time) {\n    // ...    \n    resp, err = rt.RoundTrip(req)\n    // ...  \n} \n\n// 从这里进入 RoundTrip 逻辑\n/src/net/http/roundtrip.go: 16\nfunc (t *Transport) RoundTrip(req *Request) (*Response, error) {\n    return t.roundTrip(req)\n}\n\nfunc (t *Transport) roundTrip(req *Request) (*Response, error) {\n    // 尝试去获取一个空闲连接，用于发起 http 连接\n    pconn, err := t.getConn(treq, cm)\n    // ...\n}\n\n// 重点关注这个函数，返回是一个长连接\nfunc (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {\n    // 省略了大量逻辑，只关注下面两点\n    // 有空闲连接就返回\n    pc := <-t.getIdleConnCh(cm)\n\n    // 没有创建连接\n    pc, err := t.dialConn(ctx, cm)\n\n}\n```\n\n这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。\n\n最后一个上面的代码里有个`getConn`方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。\n\n- 如果有空闲连接，就拿空闲连接\n\n```go\n// /src/net/http/tansport.go:810\nfunc (t *Transport) getIdleConnCh(cm connectMethod) chan *persistConn {\n    // 返回放空闲连接的chan\n    ch, ok := t.idleConnCh[key]\n    // ...\n    return ch\n}\n```\n\n- 没有空闲连接，就创建长连接。\n\n```go\n// /src/net/http/tansport.go:1357\nfunc (t *Transport) dialConn() {\n  //...\n  conn, err := t.dial(ctx, \"tcp\", cm.addr())\n  // ...\n  go pconn.readLoop()\n  go pconn.writeLoop()\n  // ...\n}\n```\n\n当第一次发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个读goroutine和一个写goroutine。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1621351204844-99fdc650-2c23-4dae-ba04-ba54b561202a.png)\n\n读写协程\n\n注意上面代码里的`t.dial(ctx, \"tcp\", cm.addr())`，如果像文章开头那样设置了`http.Transport`的\n\n```go\nDial: func(netw, addr string) (net.Conn, error) {\n    conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时\n    if err != nil {\n        return nil, err\n    }\n    err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时\n    if err != nil {\n        return nil, err\n    }\n    return conn, nil\n},\n```\n\n\n\n那么这里就会在下面的dial里被执行到\n\n```go\nfunc (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, error) {\n    // ...\n    c, err := t.Dial(network, addr)\n    // ...\n}\n```\n\n这里面调用的设置超时，会执行到\n\n```go\n// /src/net/net.go\nfunc (c *conn) SetDeadline(t time.Time) error {\n    //...\n    c.fd.SetDeadline(t)\n    //...\n}\n\n//...\n\nfunc setDeadlineImpl(fd *FD, t time.Time, mode int) error {\n    // ...\n    runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)\n    return nil\n}\n\n\n//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline\nfunc poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {\n    // ...\n    // 设置一个定时器事件\n    rtf = netpollDeadline\n    // 并将事件注册到定时器里\n    modtimer(&pd.rt, pd.rd, 0, rtf, pd, pd.rseq)\n}  \n```\n\n上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个定时器事件，假设时间设了3s，那么这个事件会在3s后发生，然后执行注册事件的逻辑。而这个注册事件就是`netpollDeadline`。注意这个`netpollDeadline`，待会会提到。\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/396745/1621351188250-1127f116-5af1-4a96-ae6f-c326b52761f5.png)\n\n读写协程定时器事件\n\n设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。\n\n直到3s过后，这时候看读goroutine，会等待网络数据返回。\n\n```go\n// /src/net/http/tansport.go:1642\nfunc (pc *persistConn) readLoop() {\n    //...\n    for alive {\n        _, err := pc.br.Peek(1)  // 阻塞读取服务端返回的数据\n    //...\n}\n```\n\n然后就是一直跟代码。\n\n```go\nsrc/bufio/bufio.go: 129\nfunc (b *Reader) Peek(n int) ([]byte, error) {\n    // ...\n    b.fill() \n    // ...   \n}\n\nfunc (b *Reader) fill() {\n    // ...\n    n, err := b.rd.Read(b.buf[b.w:])\n    // ...\n}\n\n/src/net/http/transport.go: 1517\nfunc (pc *persistConn) Read(p []byte) (n int, err error) {\n    // ...\n    n, err = pc.conn.Read(p)\n    // ...\n}\n\n// /src/net/net.go: 173\nfunc (c *conn) Read(b []byte) (int, error) {\n    // ...\n    n, err := c.fd.Read(b)\n    // ...\n}\n\nfunc (fd *netFD) Read(p []byte) (n int, err error) {\n    n, err = fd.pfd.Read(p)\n    // ...\n}\n\n/src/internal/poll/fd_unix.go: \nfunc (fd *FD) Read(p []byte) (int, error) {\n    //...\n    if err = fd.pd.waitRead(fd.isFile); err == nil {\n        continue\n    }\n    // ...\n}\n\nfunc (pd *pollDesc) waitRead(isFile bool) error {\n    return pd.wait('r', isFile)\n}\n\nfunc (pd *pollDesc) wait(mode int, isFile bool) error {\n    // ...\n    res := runtime_pollWait(pd.runtimeCtx, mode)\n    return convertErr(res, isFile)\n}\n```\n\n直到跟到`runtime_pollWait`，这个可以简单认为是等待服务端数据返回。\n\n```go\n//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait\nfunc poll_runtime_pollWait(pd *pollDesc, mode int) int {\n\n    // 1.如果网络正常返回数据就跳出\n  for !netpollblock(pd, int32(mode), false) {\n    // 2.如果有出错情况也跳出\n        err = netpollcheckerr(pd, int32(mode))\n        if err != 0 {\n            return err\n        }\n    }\n    return 0\n}\n```\n\n整条链路跟下来，就是会一直等待数据，等待的结果只有两个\n\n- 有可以读的数据\n- 出现报错\n\n这里面的报错，又有那么两种\n\n- 连接关闭\n- 超时\n\n```go\nfunc netpollcheckerr(pd *pollDesc, mode int32) int {\n    if pd.closing {\n        return 1 // errClosing\n    }\n    if (mode == 'r' && pd.rd < 0) || (mode == 'w' && pd.wd < 0) {\n        return 2 // errTimeout\n    }\n    return 0\n}\n```\n\n其中提到的超时，就是指这里面返回的`数字2`，会通过下面的函数，转化为`ErrTimeout`， 而`ErrTimeout.Error()`其实就是i/o timeout。\n\n```go\nfunc convertErr(res int, isFile bool) error {\n    switch res {\n    case 0:\n        return nil\n    case 1:\n        return errClosing(isFile)\n    case 2:\n        return ErrTimeout // ErrTimeout.Error() 就是 \"i/o timeout\"\n    }\n    println(\"unreachable: \", res)\n    panic(\"unreachable\")\n}\n```\n\n那么问题来了。上面返回的超时错误，也就是返回2的时候的条件是怎么满足的？\n\n```go\nif (mode == 'r' && pd.rd < 0) || (mode == 'w' && pd.wd < 0) {\n    return 2 // errTimeout\n}\n```\n\n还记得刚刚提到的netpollDeadline吗？\n\n这里面放了定时器3s到点时执行的逻辑。\n\n```go\nfunc timerproc(tb *timersBucket) {\n    // 计时器到设定时间点了，触发之前注册函数\n    f(arg, seq) // 之前注册的是 netpollDeadline\n}\n\nfunc netpollDeadline(arg interface{}, seq uintptr) {\n    netpolldeadlineimpl(arg.(*pollDesc), seq, true, true)\n}\n\n/src/runtime/netpoll.go: 428\nfunc netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool) {\n    //...\n    if read {\n        pd.rd = -1\n        rg = netpollunblock(pd, 'r', false)\n    }\n    //...\n}\n```\n\n这里会设置`pd.rd=-1`，是指`poller descriptor.read deadline`，含义网络轮询器文件描述符的读超时时间， 在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的socket。\n\n这时候再回去看发生超时的条件就是`if (mode == 'r' && pd.rd < 0)`。\n\n至此。代码里就收到了io timeout的报错。\n\n### 总结\n\n- 不要在`http.Transport`中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名io timeout报错。\n- 请求的超时在创建`client`里设置。\n\n# Go中Unicode相关包\n\n### Go中Unicode相关包\n\nGo 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode/utf8 和 unicode/utf16。\n\n这里简单介绍下三个包的功能：\n\n- unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。\n- unicode/utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。\n\n- unicode/utf16：函数比较少，主要是 UTF-16 序列的编码和解码。\n\nGo 中字符串的写法。\n\n在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：\n\n```go\ns1 := \"徐新华\"\ns2 := \"\\u5F90\\u65B0\\u534E\"\ns3 := \"\\U00005F90\\U000065B0\\U0000534E\"\ns4 := \"\\xe5\\xbe\\x90\\xe6\\x96\\xb0\\xe5\\x8d\\x8e\"\n```\n\n简单来生活就是 \\u 紧跟四个十六进制数，\\U 紧跟八个十六进制数。其中 \\u 或 \\U 代表后面是 Unicode 码点。而 \\x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。\n\n下面的代码有利于理解：\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\nfunc main() {\n    s := `徐新华`\n    var (\n        buf = make([]byte, 4)\n        n   int\n    )\n    fmt.Println(\"字符\\tUnicode码点\\tUTF-8编码十六进制\\tUTF-8编码二进制\")\n    for _, r := range s {\n        n = utf8.EncodeRune(buf, r)\n        fmt.Printf(\"%q\\t%U\\t\\t%X\\t\\t%b\\n\", r, r, buf[:n], buf[:n])\n    }\n\n    s2 := \"\\u5F90\\u65B0\\u534E\"\n    s3 := \"\\U00005F90\\U000065B0\\U0000534E\"\n    s4 := \"\\xe5\\xbe\\x90\\xe6\\x96\\xb0\\xe5\\x8d\\x8e\"\n\n    fmt.Println(s2)\n    fmt.Println(s3)\n    fmt.Println(s4)\n}\n```\n\n运行结果：\n\n```go\n字符 Unicode码点 UTF-8编码十六进制 UTF-8编码二进制\n'徐' U+5F90  E5BE90  [11100101 10111110 10010000]\n'新' U+65B0  E696B0  [11100110 10010110 10110000]\n'华' U+534E  E58D8E  [11100101 10001101 10001110]\n徐新华\n徐新华\n徐新华\n```\n\n此外，关于字符串其他方面的处理，比如编码转换等，可以到 https://pkg.go.dev/golang.org/x/text 里找。\n\n### 大小端问题（Little endian 和 Big endian）\n\n一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是`5F`，另一个字节是`90`。存储的时候，`5F`在前，`90` 在后，这就是 Big endian 方式；`90`在前，`5F`在后，这是 Little endian 方式。\n\n这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。\n\n第一个字节在前，就是\"大端方式\"（Big endian），第二个字节在前就是\"小端方式\"（Little endian）。\n\n那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？\n\nUnicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。\n\n如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。\n\n但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。\n\n> UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。\n\n# Go 标准库之 unsafe 包\n\n## 1.  unsafe包\n\n## 1.1.  `ArbitraryType`\n\n`unsafe`包下定义了一个`ArbitratyType`类型，代表了任意的Go表达式。\n\n```go\ntype ArbitraryType int\n```\n\n## 1.2.  `Pointer`\n\n`Pointer`定义：\n\n```go\ntype Pointer *ArbitraryType\n```\n\n`Pointer`代表了一个指向任意类型的指针，有四种只适用对`Pointer`而不适用于其他类型的操作。\n\n- 任意类型的指针值可以被转换为一个`Pointer`\n- 一个`Pointer`可以被转换为任意类型的指针值\n\n- 一个`uintptr`可以被转换为一个`Pointer`\n- 一个`Pointer`也可以被转换为一个`uintptr`\n\n因此，`Pointer`可以跳过类型系统而直接指向任意类型。所以需要十分小心的使用。\n\n关于使用`Pointer`的规则，不使用这些规则的代码是不可用的，或者在未来是不可用的。\n\n### 1.2.1.  使用`Pointer`作为中间者将`*T1`转换为`*T2`\n\n前提是T2的大小不超过T1，而且两者的内存分布相同。\n\n```go\nfunc Float64bits(f float64) uint64 {  return *(*uint64)(unsafe.Pointer(&f))}\n```\n\n### 1.2.2.  把`Pointer`转换为`uintptr`\n\n把`Pointer`转换为`uintptr`将产生一个指向类型值的`int`变量。常用来打印一个`uintptr`。\n\n将`uintptr`转换为`Pointer`是不可用的。\n\n因为`uintptr`是一个整数值，而不是引用。就是说`uintptr`和指针没有任何关系。可以说是将`Pointer`指向的地址的值返回给`uintptr`，即使`uintptr`中的值对应的地址的对象更新了或者删除了，`uintptr`也不会改变。\n\n### 1.2.3.  把`Pointer`转为`uintptr`再转换回`Pointer`，其中带有`uintptr`数值运算\n\n如果`Pointer`指向一个分配的对象，那么如下转换可以把`Pointer`指针向后移动。\n\n```go\n p = unsafe.Pointer(uintptr(p) + offset)\n```\n\n最常用的是指向结构体中不同字段或者数组中的元素\n\n```go\n// equivalent to f := unsafe.Pointer(&s.f)\n f := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f))\n // equivalent to e := unsafe.Pointer(&x[i])\n e := unsafe.Pointer(uintptr(unsafe.Pointer(&x[0])) + i*unsafe.Sizeof(x[0]))\n```\n\n这可以用来向前或向后移动指针，通过加或者减`offset`。指针移动之后，也应该指向该内存范围中。\n\n将`Pointer`移动超过其对象的原始内存分配范围是不可用的，如：\n\n```go\n// INVALID: end points outside allocated space.\n var s thing\n end = unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Sizeof(s))\n \n // INVALID: end points outside allocated space.\n b := make([]byte, n)\n end = unsafe.Pointer(uintptr(unsafe.Pointer(&b[0])) + uintptr(n))\n```\n\n当然如下代码也是错误的，因为`uintptr`不可以储存在变量中：\n\n```go\n// INVALID: uintptr cannot be stored in variable\n// before conversion back to Pointer.\nu := uintptr(p)\np = unsafe.Pointer(u + offset)\nPointer`必须指向一个已经分配好的对象，而不能是`nil\n// INVALID: conversion of nil pointer\nu := unsafe.Pointer(nil)\np := unsafe.Pointer(uintptr(u) + offset)\n```\n\n### 1.2.4.  当调用`syscall.Syscall`时，需要把`Poiner`转换为`uintptr`\n\n`syscall`包下的`Syscall`函数把`uintptr`参数传递给操作系统，然后根据调用的相关信息，把相应的`uintptr`再转换为指针。\n\n如果一个指针参数必须被转换为`uintptr`作为参数的话，这个转换只能在调用函数中的参数表达式完成，因为`uintptr`是不能储存在变量中的。\n\n```go\nsyscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))\n```\n\n编译器处理函数调用中的指针时，该指针所指向的对象会被保留到函数调用结束，即使该对象在函数调用时并不使用。\n\n如下是错误的代码，因为`uintptr`不能保存在变量中\n\n```go\n// INVALID: uintptr cannot be stored in variable\n// before implicit conversion back to Pointer during system call.\nu := uintptr(unsafe.Pointer(p))\nsyscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))\n```\n\n### 1.2.5.  将`reflect.Value.Pointer`或者`reflect.Value.UnsafeAddr`的结果从`uintptr`转换为`Pointer`\n\n包`reflect`下`Value`的`Pointer`方法和`UnsafeAddr`方法返回的是`uintptr`而不是`Pointer`类型，以便于调用者不使用`usafe`包就可以转换为任意类型。这也意味着，这两个方法的返回值必须使用`Pointer`进行转换才可以使用：\n\n```go\np := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))\n```\n\n因为这两个函数调用的返回值是`uintptr`，所以也是不可以变量储存的。\n\n### 1.2.6.  `reflect.SliceHeader`或者`reflect.StringHeader`的`Data`字段同`Pointer`的相互转换\n\n前面说过，返回`uintptr`是为了调用者可以直接进行不同类型的转换，而不用导入`unsafe`包。这意味着，只有当指针解析为切片或者字符串时`SliceHeader`和`StringHeader`才可以被使用。\n\n```go\nvar s string\nhdr := (*reflect.StringHeader)(unsafe.Pointer(&s)) // case 1\nhdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)\nhdr.Len = n\n```\n\n通常情况下，`SliceHeader`和`StringHeader`只能作为`*SliceHeader`和`*StringHeader`使用，而不可以使用其结构体形式。\n\n```go\n // INVALID: a directly-declared header will not hold Data as a reference.\n var hdr reflect.StringHeader\n hdr.Data = uintptr(unsafe.Pointer(p))\n hdr.Len = n\n s := *(*string)(unsafe.Pointer(&hdr)) // p possibly already lost\n```\n\n## 1.3 `Sizeof`函数\n\n定义：\n\n```go\nfunc Sizeof(x ArbitraryType) uintptr\n```\n\n直接复制标准文档中的内容，下同。\n\n`Sizeof`返回类型v本身数据所占用的字节数。返回值是“顶层”的数据占有的字节数。例如，若v是一个切片，它会返回该切片描述符的大小，而非该切片底层引用的内存的大小。\n\n## 1.4 `Alignof`\n\n定义：\n\n```go\nfunc Alignof(v ArbitraryType) uintptr\n```\n\n`Alignof`返回类型v的对齐方式（即类型v在内存中占用的字节数）；若是结构体类型的字段的形式，它会返回字段f在该结构体中的对齐方式。\n\n## 1.5 `Offsetof`\n\n定义：\n\n```go\nfunc Offsetof(v ArbitraryType) uintptr\n```\n\n`Offsetof`返回类型v所代表的结构体字段在结构体中的偏移量，它必须为结构体类型的字段的形式。换句话说，它返回该结构起始处与该字段起始处之间的字节数。\n\n## 总结\n\n1.2中的`Pointer`和`uintptr`的区别：\n\n假设在内存中有一个变量`a := 1`\n\n那么`p := Pointer(&a)`中，p包含的就是a的实际地址，假设为`1000`，当a在内存中移动时，p中的地址值也会实时更新。\n\n而`uintprt(p)`只是`1000`，就是a的地址值，但是当a在内存中移动时，原来获取的`uintptr`值并不会发生变化，一直都是1000。\n\n也是因为这个原因，`syscall.Syscall`传入的`uintptr`如果代表一个对象的指针，那么该对象在内存中是一直被保留的，而且不能移动，否则的话`uintptr`指向的就不是原来的对象了，容易内存泄漏。\n\n还有一个就是`uintptr`不能保存在变量中，只能使用`Pointer`进行转换然后才能保存。\n\n# 编码分析\n\n## 背景\n\nHTTP 协议基于文本传输，字符编码将文本变为二进制，二进制编码将二进制变为文本。TCP 协议基于二进制传输，数据读取时需要处理字节序。本文将介绍常见的字符编码、二进制编码及字节序，并一探 Golang 中的实现。\n\n## 字符编码\n\n引言：如何把“Hello world”变成字节？\n\n- Step1：得到要表示的全量字符（字符表）\n- Step2：为每个字符指定一个整数编号（编码字符集）\n\n- Step3：将编号映射成有限长度比特值（字符编码表）\n\n字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。全世界共使用 5651 种语言，其中使用人数超过 5000 万的语言有 13 种，每种语言有自己的字符。汉语中，一个汉字就是一个字符。英语中，一个字母就是一个字符。甚至看不见的也可以是字符（如控制字符）。**字符的集合即为字符表**，如英文字母表，阿拉伯数字表。ASCII 码表中一共有 128 个字符。\n\n## 编码字符集（CCS:Coded Character Set）\n\n为字符表中的每个字符指定一个编号（**码点，Code Point**），即得到编码字符集。常见有 ASCII 字符集、Unicode 字符集、GB2312 字符集、BIG5 字符集、 GB18030 字符集等。ASCII 字符集中一共有 128 个字符，包括了 94 个可打印字符（英文大小写字母 52 个、阿拉伯数字 10 个、西文符号 32 个）和 34 个控制符或通信专用字符，码点值范围为[0, 128)，如下图所示。Unicode 字符集是一个很大的集合，现有容量将近 2^21 个字符，码点值范围为[0, 2^20+2^16)。\n\n![img](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502988-ada45336-1730-4863-a573-2b9db2127675.webp)\n\nASCII字符编码表\n\n## 字符编码表（CEF:Character Encoding Form）\n\n**编码字符集只定义了字符与码点的映射**，并没有规定码点的字节表示方式。由于 1 个字节可以表示 256 个编号，足以容纳 ASCII 字符集，因此**ASCII 编码的规则很简单：直接将码点值用 uint8 表示即可**。对于 Unicode 字符集，容纳 2^21 至少需要 3 字节。可以采用类似 ASCII 的编码规则：**直接将编码点值用 uint32 表示即可，这正是 UTF-32 编码**。\n\n这种一刀切的定长编码方式虽然简单粗暴，弊端也很明显：**对于纯英文文本，UTF-32 编码空间占用将是 ACSII 编码的 4 倍**，造成极大的空间浪费，几乎没什么人用。有没有更优雅的解决方案？当然，这就是 UTF-8 和 UTF-16，两种当前比较流行的 Unicode 编码方式。\n\n### UTF-8\n\n历史的经验，成功的设计往往具有包容性。UTF-8 是一个典型，漂亮的实现了**对 ASCII 码的向后兼容**，以保证可以被大众接受。UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长，随码点变换长度（从 1 字节到 4 字节）。text\n\n![img](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502972-eb8483f5-fb58-4b55-a2b8-a1f52f4d9914.webp)\n\n大道至简，优雅的设计一定是简单的，UTF-8 的编码规则也诠释了这一点。编码规则如下：\n\n1. <=127（U+7F）的码点采用单字节编码，与 ASCII 保持一致；\n2. \\>127（U+7F）的码点采用 N 字节（N 属于 2，3，4）编码，首字节的前 N 位为 1，第 N+1 位为 0，剩余 N-1 个字节的前两位都为 10，剩下的二进制位使用字符的码点来填充。\n\n其中(U+7F)表示 Unicode 的十六进制码点值，即 127。如果觉得编码规则抽象，结合下表更加清晰：\n\n| Unicode  码点范围     | 码点数量    | UTF-8 编码格式                      |\n| --------------------- | ----------- | ----------------------------------- |\n| 0000 0000 ~ 0000 007F | 2^7         | 0xxxxxxx                            |\n| 0000 0080 ~ 0000 07FF | 2^11 - 2^7  | 110xxxxx 10xxxxxx                   |\n| 0000 0800 ~ 0000 FFFF | 2^16 - 2^11 | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 0001 0000 ~ 0010 FFFF | 2^20        | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n举个例子，如“汉”的 Unicode 码点是 U+6C49（110 1100 0100 1001），根据上表可得需要 3 字节编码，填充码点值后得到 0xE6 0xB7 0x89（11100110 10110001 10001001）。\n\n根据编码规则，解码也很简单，关键是如何判断连续的字节数：**首字节连续 1 的个数即为字节数**。\n\n需要一提的是，**在 MySQL 中，utf8 是“虚假的 utf8”**，最大只支持 3 个字节，如果建表时选择 CHARSET=utf8，会导致很多特殊字符和 emoji 表情都无法插入。**utf8mb4 才是“真正的 utf8”**，mb4 即most bytes 4。为什么 MySQL 中 utf8 最大只支持 3 字节？历史原因，在 MySQL 刚开发那会儿，Unicode 空间只有 2^16，Unicode 委员会还在做 “65535 个字符足够全世界用了”的美梦呢。\n\n### UTF-16\n\n在 C/C++ 中遇到的wchar_t类型或 Java 中的char类型，这些类型占内存两个字节，因为 Unicode 中常用的字符都处于[U+0, U+FFFF]（基本平面）的范围之内，因此**两个字节几乎可以覆盖大部分的常用字符**，这正是 UTF-16 编码的一个前提。\n\n相比 UTF-32 与 UTF-8，**UTF-16 编码是一个折中：小于（U+FFFF）2^16 的码点（基本平面）使用 2 字节编码，大于（U+FFFF）2^16 的码点（辅助码点）使用 4 字节编码**。由于基础平面空间会占用 2 字节的所有比特位，无法像 UTF-8 那样留有“10”前缀。那么问题来了：**当遇到两个节时，如何判断是 2 字节编码还是 4 字节编码？**\n\nUTF-16 的编码的另一个前提：**在基本平面内，****[U+D800, U+DFFF]****是一个空段（空间大小为 2^11）**，这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。\n\n辅助平面容量为 2^20，至少需要 20 个二进制位，UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 2^10），称为**高位**（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 2^10），称为**低位**（L）。\n\n映射方式采用线性映射。Unicode3.0 中给出了辅助平面字符的转换公式：\n\nH = Math.floor((c-0x10000) / 0x400) + 0xD800\n\nL = (c - 0x10000) % 0x400 + 0xDC00\n\n也就是说，一个辅助平面的码点，被拆成两个基本平面的空段码点表示。如果双字节的值在[U+D800, U+DBFF]中，则要和后续相邻的双字节一同解码。具体编码规则为：\n\n1. <= (U+FFFF)的码点采用双字节编码，直接将码点使用 uint16 表示；\n2. \\> (U+FFFF)的码点采用 4 字节编码，作差计算码点溢出值，将溢出值用 uint20 表示后，前 10 位映射到[U+D800, U+DBFF]，后 10 位映射到[U+DC00, U+DFFF];\n\n小结: 定长编码的优点是转换规则简单直观，查找效率高，缺点是空间浪费，以及不可扩展。如果 Unicode 字符集进一步扩充，UTF-16 和 UTF-32 都将不可用，而 UTF-8 具有更强的可扩展性。\n\n## Golang 中字符编码\n\n不像 C++、Java 等语言支持五花八门的字符编码，Golang 遵从“大道至简”的原则：**全用 UTF-8**。所以 go 程序员再也不用担心乱码问题，甚至可以用汉字和表情包写代码，string 与字节数组转换也是直接转换。\n\n\n\n```go\nfunc TestTemp(t *testing.T) {\n    来自打工人的问候()\n}\n\nfunc 来自打工人的问候() {\n    问候语 := \"早安，打工人😁\"\n    fmt.Println(问候语)\n    bytes := []byte(问候语)\n    fmt.Println(hex.EncodeToString(bytes))\n}\n```\n\n// 执行结果-->\n\n```\n早安，打工人😁\ne697a9e5ae89efbc8ce68993e5b7a5e4babaf09f9881\n```\n\n值得一提的是，Golang 中 string 的底层模型就是字节数组，所以类型转换过程中无需编解码。也因此，**Golang 中 string 的底层模型是字节数组，其长度并非字符数，而是对应字节数**。如果要取字符数，需要先将字符串转换为字符数组。**字符类型（rune）实际上是 int32 的别名，即用 UTF-32 编码表示字符**。\n\n```go\nfunc TestTemp(t *testing.T) {\n    fmt.Println(len(\"早\")) // 3\n    fmt.Println(len([]byte(\"早\"))) // 3\n    fmt.Println(len([]rune(\"早\")) // 1\n}\n// rune is an alias for int32 and is equivalent to int32 in all ways. It is\n// used, by convention, to distinguish character values from integer values.\ntype rune = int32\n```\n\n再看一下 go 中 utf-8 编码的具体实现。首先获取字符的码点值，然后根据范围判断字节数，根据对应格式生成编码值。如果是无效的码点值，或码点值位于空段，则返回U+FFFD(即 �)。解码过程不再赘述。\n\n```go\n// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\n// It returns the number of bytes written.\nfunc EncodeRune(p []byte, r rune) int {\n    // Negative values are erroneous. Making it unsigned addresses the problem.\n    switch i := uint32(r); {\n    case i <= rune1Max:\n        p[0] = byte(r)\n        return 1\n    case i <= rune2Max:\n        _ = p[1] // eliminate bounds checks\n        p[0] = t2 | byte(r>>6)\n        p[1] = tx | byte(r)&maskx\n        return 2\n    case i > MaxRune, surrogateMin <= i && i <= surrogateMax:\n        r = RuneError\n        fallthrough\n    case i <= rune3Max:\n        _ = p[2] // eliminate bounds checks\n        p[0] = t3 | byte(r>>12)\n        p[1] = tx | byte(r>>6)&maskx\n        p[2] = tx | byte(r)&maskx\n        return 3\n    default:\n        _ = p[3] // eliminate bounds checks\n        p[0] = t4 | byte(r>>18)\n        p[1] = tx | byte(r>>12)&maskx\n        p[2] = tx | byte(r>>6)&maskx\n        p[3] = tx | byte(r)&maskx\n        return 4\n    }\n}\n\nconst(\n    t1 = 0b00000000\n    tx = 0b10000000\n    t2 = 0b11000000\n    t3 = 0b11100000\n    t4 = 0b11110000\n    t5 = 0b11111000\n    maskx = 0b00111111\n    mask2 = 0b00011111\n    mask3 = 0b00001111\n    mask4 = 0b00000111\n    rune1Max = 1<<7 - 1\n    rune2Max = 1<<11 - 1\n    rune3Max = 1<<16 - 1\n    RuneError = '\\uFFFD' // the \"error\" Rune or \"Unicode replacement character\"\n)\n\n// Code points in the surrogate range are not valid for UTF-8.\nconst (\n    surrogateMin = 0xD800\n    surrogateMax = 0xDFFF\n)\n```\n\n### 二进制编码\n\n引言：HTTP 是怎么传输二进制数据的？\n\n- Step1：定义字符集；\n- Step2：将二进制数据分组；\n\n- Step3：将每组映射为字符；\n\n字符编码是「文本」变为「二进制」的过程，那如何将任意「二进制」变为「文本」？答案是进行二进制编码，常见有 Hex 编码与 Base64 编码。\n\n显然**不能按字符编码直接解码**，因为字符编码的结果二进制是满足编码规律的，而非「任意」的，非法格式进行字符解码会出现乱码（比如对0b11xxxxxx进行 UTF-8 解码）。\n\n## Hex 编码\n\nHex 编码是最直观的二进制编码方式，所见即所得。上文中的十六进制表示就是用的 Hex 编码。规则如下：\n\n1. Hex 字符集为0123456789abcdef；\n2. 每 4bit 为 1 组(2^4=16)；\n\n1. 每组映射为一个 Hex 字符；\n\n计算机中二进制数据都是以字节为单位存储的，1 个字节 8bit，不会出现无法被 4 整除的情况。\n\n每个字节编码为 2 个 Hex 字符，即编码后的字符数是原始数据字节数的 2 倍。**在 ASCII 或 UTF-8 编码下，存储 Hex 结果字符串需要的空间是原始数据的 2 倍，存储效率为 50%。**\n\n## Base64 编码\n\nBase64 编码，顾名思义，是基于 64 个字符进行编码。规则如下：\n\n1. Base64 字符集（以标准 Base64 为例, 26 大写, 26 小写, 10 数字, 以及+、/）为ABC...YZabc...yz012...89+/；\n2. 每 6bit 为一组（2^6=64），即**每 3 个字节为 4 组**；\n3. 每组映射为一个 Base64 字符；\n\n如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？**标准编码(StdEncoding)**会先在末尾用 0x00 补齐再分组，并将最后 2 个或 1 个 6bit 分组（全为 0 填充）映射为'='，表示补齐的 0 字节数量。\n\n![img](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503267-8b0246bc-28ee-459b-8ad3-1d75de4e3f9d.webp)\n\n举个例子，以0x12 34 ab cd编码为标准 base64 为例：\n\n1. 不足 3 的倍数，先用两个 0 字节补齐 -->0x12 34 ab cd 00 00\n2. 0x12 34 ab编码为EjSr\n3. 0xcd 00 00二进制为0b1100 1101 0000 0000 0000 0000，分为 4 组后为110011 010000 000000 000000，编码结果为zQ==\n4. 最终编码结果为EjSrzQ==\n\n解码过程注意末尾字节的处理即可，此处不再赘述。\n\n1. EjSrzQ==-->0x12 34 ab cd 00 00-->0x12 34 ab cd\n\n**标准编码中编码结果字符长度一定是 4 的倍数，且是原始数据字节数的 4/3 倍**，因为会将字节数据补齐至 3 的倍数，每 3 个字节编码为 4 个字符。**在 ASCII 或 UTF-8 编码下，存储结果字符串需要的空间是原始数据的 4/3 倍，存储效率为 75%**。\n\n根据字符集的不同，Base64 编码有几个变种，除了标准编码（StdEncoding），常见的还有 URL 编码（URLEncoding）、原始标准编码（RawStdEncoding）以及原始 URL 编码（RawUrlEncoded）。\n\n简单来说，Raw 指的是无 Padding，URL 指的是用-和_取代编码结果中包含的 url 关键字+和/。不妨参考 Golang 中encoding/base64包中的描述：\n\n```go\n// StdEncoding is the standard base64 encoding, as defined in\n// RFC 4648.\nvar StdEncoding = NewEncoding(*encodeStd*)\n\n// URLEncoding is the alternate base64 encoding defined in RFC 4648.\n// It is typically used in URLs and file names.\nvar URLEncoding = NewEncoding(*encodeURL*)\n\n// RawStdEncoding is the standard raw, unpadded base64 encoding,\n// as defined in RFC 4648 section 3.2.\n// This is the same as StdEncoding but omits padding characters.\nvar RawStdEncoding = StdEncoding.WithPadding(*NoPadding*)\n\n// RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.\n// It is typically used in URLs and file names.\n// This is the same as URLEncoding but omits padding characters.\nvar RawURLEncoding = URLEncoding.WithPadding(*NoPadding*)\n```\n\n与标准编码不同的是，**原始编码中，字节数不足 3 的倍数时不会补齐字节数**，采用如下方案：\n\n1. 如果剩余 1 字节，则左移 4bit 后转换为 2 字符；\n2. 如果剩余 2 字节，则左移 2bit 后转化为 3 字符；\n\n即**原始编码方案中，结果字符串长度可以不是 4 的倍数**。\n\nHex 编码可以看成“Base16 编码”。随着字符数量的增加，存储效率也随之增加。如果有“Base256”编码，存储效率岂不就 100%了？很遗憾，主流字符编码中，单字节能表示的可打印字符只有 92 个。通过扩充多字节字符，或用组合字符实现 base256 意义不大。\n\n## Golang 中的二进制编码\n\n看一下 Golang 中 Base64 编码的实现。首先通过EncodedLen方法确定结果长度，生成输出buf，然后通过Encode方法将编码结果填充到buf并返回结果字符串。\n\n```go\n// EncodeToString returns the base64 encoding of src.\nfunc (enc *Encoding) EncodeToString(src []byte) string {\n    buf := make([]byte, enc.EncodedLen(len(src)))\n    enc.Encode(buf, src)\n    return string(buf)\n}\n```\n\n如前述，标准编码和原始编码（无 Padding）的结果长度不同：如果需要 Padding，直接根据字节数计算即可，反之则需要根据 bit 数计算。\n\n```go\n// EncodedLen returns the length in bytes of the base64 encoding\n// of an input buffer of length n.\nfunc (enc *Encoding) EncodedLen(n int) int {\n    if enc.padChar == *NoPadding* {\n        return (n*8 + 5) / 6 // minimum # chars at 6 bits per char\n    }\n    return (n + 2) / 3 * 4 // minimum # 4-char quanta, 3 bytes each\n}\n```\n\nEncode方法实现了编码细节。首先遍历字节数组，将每 3 个字节编码为 4 个字符。最后处理剩余的 1 或 2 个字节（如有）：首先使用移位运算进行 0bit 填充，然后进行字符转换。如前述，无 Padding 时，剩下 1 字节对应 2 字符，剩下 2 字节对应 3 字符，即至少会有 2 字符。最后在switch代码段中，根据剩余字节数填充第 3 个字符和 Padding 字符（如有）即可。\n\n```go\nfunc (enc *Encoding) Encode(dst, src []byte) {\n    if len(src) == 0 {\n        return\n    }\n    // enc is a pointer receiver, so the use of enc.encode within the hot\n    // loop below means a nil check at every operation. Lift that nil check\n    // outside of the loop to speed up the encoder.\n    _ = enc.encode\n    di, si := 0, 0\n    n := (len(src) / 3) * 3\n    for si < n {\n        // Convert 3x 8bit source bytes into 4 bytes\n        val := uint(src[si+0])<<16 | uint(src[si+1])<<8 | uint(src[si+2])\n        dst[di+0] = enc.encode[val>>18&0x3F]\n        dst[di+1] = enc.encode[val>>12&0x3F]\n        dst[di+2] = enc.encode[val>>6&0x3F]\n        dst[di+3] = enc.encode[val&0x3F]\n        si += 3\n        di += 4\n    }\n    remain := len(src) - si\n    if remain == 0 {\n        return\n    }\n    // Add the remaining small block\n    val := uint(src[si+0]) << 16\n    if remain == 2 {\n        val |= uint(src[si+1]) << 8\n    }\n    dst[di+0] = enc.encode[val>>18&0x3F]\n    dst[di+1] = enc.encode[val>>12&0x3F]\n    switch remain {\n    case 2:\n        dst[di+2] = enc.encode[val>>6&0x3F]\n        if enc.padChar != *NoPadding* {\n            dst[di+3] = byte(enc.padChar)\n        }\n    case 1:\n        if enc.padChar != *NoPadding* {\n            dst[di+2] = byte(enc.padChar)\n            dst[di+3] = byte(enc.padChar)\n        }\n    }\n}\n```\n\n### 字节序\n\n引言：拿到两个字节，如何解析为整形？\n\n- Step1：明确字节高低位顺序\n- Step2：按高低位权重计算结果\n\n上述二进制编码主要用于文本传输，能不能不进行编码，直接传输二进制？当然可以，基于二进制传输协议，如 TCP 协议。那么什么是文本传输，什么是二进制传输？简单来说，文本传输，内容为文本，自带描述信息（参数名），如 HTTP 中的字段都以 KV 形式存在。二进制传输，内容为二进制，**以预先定义好的格式拼在一起**，如 TCP 协议报文格式。\n\n![img](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503068-102c03a4-c199-46de-89b9-c782f90e6276.webp)\n\n### 大端与小端\n\n聊到二进制传输，一个避不开的话题是**字节序**。什么是字节序？假设读取到一个两字节的 uint16 0x04 0x00，如果从左往右（从高位往低位）解码，得到的是 1024，反过来（从低位往高位）解码则是 4，这就是字节序。**符合人类阅读习惯的（从高位往低位）是大端（BigEndian），反之为小端（LittleEndian）。**\n\n另一种大小端的定义：LittleEndian 将低序字节存储在低地址，BigEndian 将高序字节存储在低地址。理解起来有些抽象，本质上是一致的。\n\n![img](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503204-018229fe-0d8f-4474-a462-71454212094c.webp)\n\n为什么会有小端字节序，统一都用大端不好么？\n\n计算机不这么想，因为计算机中计算都是从低位开始的，电路先处理低位字节效率比较高。但是，人类还是习惯读写大端字节序。所以，**除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。**\n\n那什么时候程序员需要进行字节序处理呢？当多字节整形（uint16，uint32，uint64）需要和字节数组互相转换时。**字节数组是无字节序的，客户端写入啥，服务端就读取啥，不会出现逆序，写入和读取无需考虑字节序，这点大可放心**。**只有当多字节整形和字节数组互转时必须指明字节序。**\n\n## Golang 中的字节序\n\n以 uint16 与字节数组互转为例，看一下 Golang 中 encoding/binary 包中的字节序处理与实现。可见实现并不复杂，注意字节顺序即可。\n\n```go\nfunc TestEndian(t *testing.T) {\n    bytes := make([]byte, 2)\n    binary.LittleEndian.PutUint16(bytes, 1024) // 小端写 --> 0x0004\n    binary.BigEndian.PutUint16(bytes, 1024) // 大端写 --> 0x0400\n    binary.LittleEndian.Uint16(bytes) // 小端读 --> 4\n    binary.BigEndian.Uint16(bytes) // 大端读 --> 1024\n}\n\nfunc (littleEndian) PutUint16(b []byte, v uint16) {\n    _ = b[1] // early bounds check to guarantee safety of writes below\n    b[0] = byte(v)\n    b[1] = byte(v >> 8)\n}\n\nfunc (bigEndian) PutUint16(b []byte, v uint16) {\n    _ = b[1] // early bounds check to guarantee safety of writes below\n    b[0] = byte(v >> 8)\n    b[1] = byte(v)\n}\n\nfunc (littleEndian) Uint16(b []byte) uint16 {\n    _ = b[1] // bounds check hint to compiler; see golang.org/issue/14808\n    return uint16(b[0]) | uint16(b[1])<<8\n}\n\nfunc (bigEndian) Uint16(b []byte) uint16 {\n    _ = b[1] // bounds check hint to compiler; see golang.org/issue/14808\n    return uint16(b[1]) | uint16(b[0])<<8\n}\n```\n\n## 实战：加解密中的编码与字节序\n\n在加解密场景中，通常会对**明文**加密得到**密文**，对密文解密得到明文。比如对密码\"123456\"（明文）进行**对称加密**（如 SM4）得到\"G7EeTPnuvSU41T68qsuc_g\"（密文）。**明文和密文都是由可打印字符构成的文本**，通常明文人类可直接阅读其含义（不考虑二次加密），密文需要解密后才能理解含义。\n\n那么上述明文变成密文，期间经历了哪些编码过程呢？以加密为例：\n\n1. 将明文\"123456\"进行字符解码（如 UTF-8），得到**明文字节序列**0x31 32 33 34 35 36;\n2. 将明文字节序列输入 SM4 加密算法，输出**密文字节序列**0x1b b1 1e 4c f9 ee bd 25 38 d5 3e bc aa cb 9c fe；\n3. 将密文字节序列进行二进制编码（如 RawURLBase64），得到密文\"G7EeTPnuvSU41T68qsuc_g\"；\n\n同理，将\"G7EeTPnuvSU41T68qsuc_g\"解密成\"123456\"过程中，应与加密过程的编码方式对应：先进行 RawRULBase64 解码，再解密，最后再进行 UTF-8 编码。\n\n加解密算法的输入输出都是字节序列，所以要将明文、密文与字节序列进行转换。有两点需要注意：\n\n1. **明文解码为明文字节序列，解码方式因场景而定**。对于多次加密场景（如对“G7EeTPnuvSU41T68qsuc_g”再次加密），明文是 Base64 编码得到的，建议采用一致的方式解码。虽然也可以直接进行 UTF-8 解码，但会使加解密流程设计变得复杂。\n2. **密文字节序列编码为密文，必须用二进制编码，不能用字符编码**。使用字符编码会产生乱码（意味着数据丢失，无法逆向解码出原始数据）。上述密文序列密文序列进行 UTF-8 编码的结果是 �L���%8�>��˜�。\n\n合规要求，加解密场景中应使用**硬件加密机**。通常硬件加密机提供**基于 TCP 的字节流通信方式**，比如约定每次通信数据中的前 2 字节为数据长度，后面的为真实数据。发送时，需要将真实数据长度转为 2 字节拼在前面，接收时，需要先读取前两字节得到真实数据长度 N，再读取 N 字节得到真实数据。其中**长度与字节序列的转换需要关注字节序：发送方和接收方的字节序处理保持一致**即可，比如全用大端。下面给出了数据发送的示例代码：\n\n```go\nfunc (m *EncryptMachine) sendData(conn net.Conn, data []byte) error {\n    // add length\n    newData := m.addLength(data)\n    // send new data\n    return util.SocketWriteData(conn, newData)\n}\n\nfunc (m *EncryptMachine) addLength(data []byte) []byte {\n    lengthBytes := make([]byte, 2)\n    binary.BigEndian.PutUint16(lengthBytes, uint16(len(data)))\n    return append(lengthBytes, data...)\n}\n```\n\n## 总结\n\n编码虽然基础，但却容易出错，切莫眼高手低。希望本文能帮助大家进一步了解字符编码、二进制编码与字节序，避免踩坑。\n\n**未完，待续**\n\n\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 55.9755859375,
          "content": "# 👏👏👏最全空降Golang[资料补给包](https://github.com/0voice/Introduction-to-Golang#-%E8%B5%84%E6%96%99%E5%8C%85)（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享ppt\n\n<div  align=center>\n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128655088-7e2704a7-ce37-4e78-9b9c-a8865597f364.png\"/>\n  \n## —— 未来服务器端编程语言\n\n<br>\n\n\n [🏃‍♂<br>&nbsp;&nbsp;&nbsp; &nbsp;环境安装&nbsp;&nbsp;&nbsp;&nbsp; ](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%90%AD%E5%BB%BAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md)  |[📚<br>&nbsp;&nbsp;&nbsp; 知识归纳&nbsp;&nbsp;&nbsp; ](https://github.com/0voice/Introduction-to-Golang#step-3%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0go)|  [📕<br>&nbsp;&nbsp;&nbsp; 电子书籍&nbsp;&nbsp;&nbsp; ](https://github.com/0voice/Introduction-to-Golang#-%E4%B9%A6%E7%B1%8D) \n:-------: | :-------: | :---------:\n **[📖<br>精选文章](https://github.com/0voice/Introduction-to-Golang#-%E6%96%87%E7%AB%A0)**|**[💽<br>大佬视频](https://github.com/0voice/Introduction-to-Golang#-%E8%A7%86%E9%A2%91)**  |  **[🏗<br>开源项目](https://github.com/0voice/Introduction-to-Golang#-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%AE%B5%E4%BD%8D%E7%BA%AF%E5%B1%9E%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%E4%B8%8D%E5%88%86%E5%85%88%E5%90%8E)**\n**[📄<br>学术论文](https://github.com/0voice/Introduction-to-Golang#-%E8%AE%BA%E6%96%87%E4%B8%8E%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90)** | **[🖼<br>大会PPT](https://github.com/0voice/Introduction-to-Golang#-%E5%A4%A7%E5%8E%82%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%ABppt)** | **[☁<br>云原生](https://github.com/0voice/Introduction-to-Golang#-%E4%BA%91%E5%8E%9F%E7%94%9F)**\n\n</div>\n\n<br>\n\n## 📣【今日推荐阅读】[Go自带库的使用说明](https://github.com/0voice/Introduction-to-Golang/blob/main/Go%E8%87%AA%E5%B8%A6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.md)\n## 🔠【还不会入门，找我】[Go语言基础语法宝典](https://github.com/0voice/Introduction-to-Golang/blob/main/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9D%E5%85%B8.md)\n## 🗡【一册在手，天下我有】[Go 语言参考手册](https://github.com/0voice/Introduction-to-Golang/blob/main/Go%20%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.md)\n## 🤔【导图辅助，有如神助】[Golang 入门笔记](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.md)[（pdf版下载）](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.pdf)\n\n## 🧑‍🤝‍🧑 Rob Pike谈Google Go\n\n<div  align=center>\n<img width=\"50%\" height=\"50%\" src=\"https://user-images.githubusercontent.com/87457873/129528229-cb400b53-90a4-440b-982b-1af4b20fe7e4.png\"/>\n  \n**Google · Go语言之父**\n\n</div>\n\n##### [1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#1-rob%E4%BD%A0%E5%88%9B%E5%BB%BA%E4%BA%86google-go%E8%BF%99%E9%97%A8%E8%AF%AD%E8%A8%80%E4%BB%80%E4%B9%88%E6%98%AFgoogle-go%E8%83%BD%E7%AE%80%E6%98%8E%E6%89%BC%E8%A6%81%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgoogle-go%E5%90%97)\n\n##### [2. Go的主要特点是什么？有什么重要功能？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#2-go%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD)\n\n##### [3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#3-%E5%9C%A8%E6%88%91%E4%BB%AC%E7%BB%A7%E7%BB%AD%E8%AF%9D%E9%A2%98%E4%B9%8B%E5%89%8D%E8%83%BD%E5%90%A6%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88go%E7%BC%96%E8%AF%91%E5%99%A8%E8%83%BD%E8%BE%BE%E5%88%B0%E9%82%A3%E4%B9%88%E5%BF%AB%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E5%91%A2%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%95%E5%AE%9D)\n\n##### [4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#4-%E8%AE%A9%E6%88%91%E4%BB%AC%E5%BC%80%E5%A7%8B%E8%81%8A%E8%81%8Ago%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%90%A7go%E9%87%8C%E9%9D%A2%E6%9C%89%E7%BB%93%E6%9E%84struct%E6%9C%89%E7%B1%BB%E5%9E%8Btype%E9%82%A3%E4%B9%88go%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88)\n\n##### [5. 那么这些方法只是在包内部可见喽？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#5-%E9%82%A3%E4%B9%88%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AA%E6%98%AF%E5%9C%A8%E5%8C%85%E5%86%85%E9%83%A8%E5%8F%AF%E8%A7%81%E5%96%BD)\n\n##### [6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#6-%E4%BD%A0%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF%E6%88%91%E5%8F%AF%E4%BB%A5%E7%BB%99int%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95%E4%BD%86%E6%98%AF%E5%BF%85%E9%A1%BB%E5%85%88%E4%BD%BF%E7%94%A8typedef%E5%90%97)\n\n##### [7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#7-%E4%BD%A0%E4%BB%AC%E5%80%9F%E9%89%B4%E4%BA%86ruby%E9%87%8C%E5%BC%80%E6%94%BE%E7%B1%BB%E7%9A%84%E6%80%9D%E6%83%B3%E8%BF%99%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9Druby%E7%9A%84%E5%BC%80%E6%94%BE%E7%B1%BB%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%B9%B6%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%99%E6%98%AF%E6%9C%89%E7%A0%B4%E5%9D%8F%E6%80%A7%E7%9A%84%E4%BD%86%E6%98%AF%E4%BD%A0%E4%BB%AC%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E5%9B%A0%E4%B8%BA%E5%88%9B%E5%BB%BA%E4%BA%86%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF)\n\n##### [8. 你还提到了typedef，是叫typedef吧？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#8-%E4%BD%A0%E8%BF%98%E6%8F%90%E5%88%B0%E4%BA%86typedef%E6%98%AF%E5%8F%ABtypedef%E5%90%A7)\n\n##### [9. Typedef在C里是一种预处理指令吗？【编辑注/免责申明：C语言里的typedef与预处理无关】](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#9-typedef%E5%9C%A8c%E9%87%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%90%97%E7%BC%96%E8%BE%91%E6%B3%A8%E5%85%8D%E8%B4%A3%E7%94%B3%E6%98%8Ec%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84typedef%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86%E6%97%A0%E5%85%B3)\n\n##### [10. 我们从底层说起吧，在Go里最小的类型是什么？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#10-%E6%88%91%E4%BB%AC%E4%BB%8E%E5%BA%95%E5%B1%82%E8%AF%B4%E8%B5%B7%E5%90%A7%E5%9C%A8go%E9%87%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88)\n\n##### [11. 但是，int这样的类型是值类型对吧.](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#11-%E4%BD%86%E6%98%AFint%E8%BF%99%E6%A0%B7%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%90%A7)\n\n##### [12. 它们类似C++的引用吗？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#12-%E5%AE%83%E4%BB%AC%E7%B1%BB%E4%BC%BCc%E7%9A%84%E5%BC%95%E7%94%A8%E5%90%97)\n\n##### [13. 它是结构内部一个复合对象。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#13-%E5%AE%83%E6%98%AF%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%90%88%E5%AF%B9%E8%B1%A1)\n\n##### [14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#14-%E4%BD%A0%E6%8F%90%E5%88%B0%E8%BF%87%E6%8E%A5%E5%8F%A3%E6%AF%94%E8%BE%83%E6%9C%89%E8%B6%A3%E9%82%A3%E4%B8%8B%E9%9D%A2%E5%92%B1%E4%BB%AC%E5%B0%B1%E8%B0%88%E8%B0%88%E8%BF%99%E4%B8%80%E9%83%A8%E5%88%86)\n\n##### [15. 某种程度上有点类似结构化类型系统（structural typing)](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#15-%E6%9F%90%E7%A7%8D%E7%A8%8B%E5%BA%A6%E4%B8%8A%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9Fstructural-typing)\n\n##### [16. 你提到过类，但Go没有类，对吧。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#16-%E4%BD%A0%E6%8F%90%E5%88%B0%E8%BF%87%E7%B1%BB%E4%BD%86go%E6%B2%A1%E6%9C%89%E7%B1%BB%E5%AF%B9%E5%90%A7)\n\n##### [17. 但是没有类怎么去写代码？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#17-%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E7%B1%BB%E6%80%8E%E4%B9%88%E5%8E%BB%E5%86%99%E4%BB%A3%E7%A0%81)\n\n##### [18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#18-%E5%A6%82%E6%9E%9C%E6%88%91%E6%9C%89%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA%E8%A6%81%E5%AE%9E%E7%8E%B0%E8%80%8C%E4%B8%94%E6%83%B3%E6%94%BE%E5%9C%A8%E5%A4%9A%E4%B8%AAstructs%E9%87%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E5%85%B1%E4%BA%AB%E8%BF%99%E4%BA%9B%E8%A1%8C%E4%B8%BA)\n\n##### [19. 如果有多重继承命名冲突的问题该怎么办？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#19-%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E)\n\n##### [20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#20-%E5%9B%A0%E4%B8%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%A0%B9%E5%AF%B9%E8%B1%A1%E6%88%96%E6%A0%B9%E7%B1%BB%E5%A6%82%E6%9E%9C%E6%88%91%E6%83%B3%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E)\n\n##### [21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#21-go%E9%87%8C%E6%9C%89%E5%8F%AB%E5%81%9Agoroutines%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%AE%83%E4%BB%AC%E5%92%8Ccoroutines%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%B8%8D%E4%B8%80%E6%A0%B7%E4%B9%88)\n\n##### [22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#22-%E4%BD%A0%E6%8F%90%E5%88%B0%E4%BD%A0%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86mn%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%8D%B3m%E4%B8%AAcoroutines%E6%98%A0%E5%B0%84%E5%88%B0n%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8A)\n\n##### [23. Goroutines有用于通信的通道吗？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#23-goroutines%E6%9C%89%E7%94%A8%E4%BA%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E9%80%9A%E9%81%93%E5%90%97)\n\n##### [24. 你提到你们有缓存的同步通道和异步通道。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#24-%E4%BD%A0%E6%8F%90%E5%88%B0%E4%BD%A0%E4%BB%AC%E6%9C%89%E7%BC%93%E5%AD%98%E7%9A%84%E5%90%8C%E6%AD%A5%E9%80%9A%E9%81%93%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93)\n\n##### [25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#25-%E6%AF%8F%E4%B8%AAgoroutine%E5%B0%B1%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%BB%99%E8%AF%BB%E8%80%85%E8%A7%A3%E9%87%8A%E5%90%A7)\n\n##### [26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#26-%E5%AE%83%E4%BB%AC%E6%98%AF%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E4%BD%86%E6%98%AF%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%A0%B7%E9%83%BD%E9%A2%84%E5%88%86%E9%85%8D%E6%A0%88%E7%A9%BA%E9%97%B4%E5%9B%A0%E8%80%8C%E5%AE%83%E4%BB%AC%E9%9D%9E%E5%B8%B8%E8%80%97%E8%B4%B9%E8%B5%84goroutines%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%E5%91%A2)\n\n##### [27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#27-%E6%88%91%E4%BB%AC%E5%86%8D%E6%9D%A5%E8%B0%88%E8%B0%88%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%9C%80%E5%88%9D%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%B0%86go%E8%AF%AD%E8%A8%80%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E7%BA%A7%E8%AF%AD%E8%A8%80%E6%9D%A5%E6%8E%A8%E5%B9%BF%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E9%80%89%E6%8B%A9%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BD%86%E6%98%AF%E5%AE%83%E9%80%9F%E5%BA%A6%E5%B9%B6%E4%B8%8D%E5%BF%AB%E6%88%96%E8%80%85%E8%AF%B4%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%97%B4%E6%AD%87%E9%97%AE%E9%A2%98%E5%A6%82%E6%9E%9C%E7%94%A8%E5%AE%83%E5%86%99%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%9D%E8%BF%99%E6%98%AF%E9%9D%9E%E5%B8%B8%E7%83%A6%E4%BA%BA%E7%9A%84%E4%BD%A0%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E8%BF%99%E4%B8%80%E9%97%AE%E9%A2%98%E7%9A%84)\n\n##### [28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#28-%E6%9C%89%E6%B2%A1%E6%9C%89%E6%96%B9%E6%B3%95%E8%83%BD%E5%A4%9F%E9%81%BF%E5%85%8D%E7%9B%B4%E9%9D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%AF%94%E5%A6%82%E7%94%A8%E4%B8%80%E4%BA%9B%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%BC%93%E5%AD%98%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%95%B0%E6%8D%AE%E6%89%94%E8%BF%9B%E5%8E%BB)\n\n##### [29. 最后一个问题：Go是系统级语言还是应用级语言？](https://github.com/0voice/Introduction-to-Golang/blob/main/Rob%20Pike%E8%B0%88Google%20Go.md#29-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98go%E6%98%AF%E7%B3%BB%E7%BB%9F%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E5%BA%94%E7%94%A8%E7%BA%A7%E8%AF%AD%E8%A8%80)\n\n## 📚 资料包\n\n<div  align=center>\n  \n![128686978-0d16ca8a-d070-4c3b-a4d9-640b265acc8d](https://user-images.githubusercontent.com/87457873/128688161-b51fbcb9-7e6e-4247-9911-4b94a35246b3.png)\n  \n</div>\n\n---\n\n### 📕 书籍\n\n#### 入门\n\n[《Go 入门指南》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E3%80%8B.pdf)\n\n[《Go语言101》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E8%A8%80101%E3%80%8B.pdf)\n\n《Go语言趣学指南》\n\n《Go语言从入门到进阶实战》\n\n[《Go语言学习笔记》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B.pdf)\n\n[《Go语言入门经典》:hdcy](https://pan.baidu.com/s/15eMLovSIrdCLoILMjr4vBQ)\n\n[《Go语言编程》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E3%80%8B%E9%AB%98%E6%B8%85%E5%AE%8C%E6%95%B4%E7%89%88%E7%94%B5%E5%AD%90%E4%B9%A6.pdf)\n\n[《Go语言实战》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E3%80%8B.epub)\n\n[《Go Web 编程》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%20Web%20%E7%BC%96%E7%A8%8B%E3%80%8B.epub)\n\n[《Go语言编程入门与实战技巧》:sgro](https://pan.baidu.com/s/1DlkBN8dRWmCHymyD4pJMCg)\n\n#### 进阶\n\n[《Go 语言圣经》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%20%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E3%80%8B.pdf)\n\n[《Go专家编程》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E3%80%8B.pdf)\n\n[《Go 语法树入门》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E6%B3%95%E6%A0%91%E5%85%A5%E9%97%A8%E3%80%8B.pdf)\n\n[《Go语言程序设计》:flnj](https://pan.baidu.com/s/11WpEqd9Fa7Ur5dH1XJdGtg)\n\n[《Go语言高级编程》](https://github.com/0voice/Introduction-to-Golang/blob/main/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B.pdf)\n\n[《Go语言核心编程》:v9fl](https://pan.baidu.com/s/10QdNpX0fdMH571LA3M8asA)\n\n《Go语言高并发与微服务实战》\n\n[《Go并发编程实战》第2版：lsn0](https://pan.baidu.com/s/1fAjT7l16hY8ryXlknnSL-A)\n\n[《Go语言并发之道》:6ppw](https://pan.baidu.com/s/1w6SbSkcjqFN1WiG2oS7XaA)\n\n---\n\n### 📖 文章\n\n[当红开发语言Go，真的是未来的技术主流吗？](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/%E5%BD%93%E7%BA%A2%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80Go%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%98%AF%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%BB%E6%B5%81%E5%90%97%EF%BC%9F.md)\n\n[Go语言之goroutine协程详解](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Go%E8%AF%AD%E8%A8%80%E4%B9%8Bgoroutine%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3.md)\n\n[Golang之sync.Pool对象池对象重用机制总结](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Golang%E4%B9%8Bsync.Pool%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93.md)\n\n[Golang的GC和内存逃逸](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Golang%E7%9A%84GC%E5%92%8C%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8.md)\n\n[GO语言之垃圾回收机制](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/GO%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.md)\n\n[Go内存分配那些事，就这么简单](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81.md)\n\n[Go语言TCP Socket编程](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Go%E8%AF%AD%E8%A8%80TCP%20Socket%E7%BC%96%E7%A8%8B.md)\n\n[从源码角度看 Golang 的调度](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8B%20Golang%20%E7%9A%84%E8%B0%83%E5%BA%A6.md)\n\n[Protobuf入门](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Protobuf%E5%85%A5%E9%97%A8.md)\n\n[etcd的使用](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/etcd%E7%9A%84%E4%BD%BF%E7%94%A8.md)\n\n[深入理解 Go Map](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Go%20Map.md)\n\n[用go实现常见的数据结构](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md)\n\n[Go 程序是怎样跑起来的](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Go%20%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84.md)\n\n[go内存管理一：系统内存管理](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%80%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md)\n\n[go内存管理二：go内存管理](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BA%8C%EF%BC%9Ago%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md)\n\n[图解Go内存分配器](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/%E5%9B%BE%E8%A7%A3Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8.md)\n\n[Go常用命令](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%96%87%E7%AB%A0/Go%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md)\n\n---\n\n### 💽 视频\n\n<br>\n\n<div align=center>\n  \ntitle | Link\n:------ | :------:\n【golang云原生】 golang实现行程码、健康码识别 | [点击观看](https://www.bilibili.com/video/BV1V24y1R7DU/?spm_id_from=333.999.0.0&vd_source=608f212d9feca2c973f34c2fb5ed5906)\n【golang云原生】 golang 实现ping网络指令 | [点击观看](https://www.bilibili.com/video/BV1Te4y1b7GR/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】golang 借助公有云实现点播转直播 | [点击观看](https://www.bilibili.com/video/BV1Be411M7Km/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】如何使用gin框架构建web项目脚手架 | [点击观看](https://www.bilibili.com/video/BV1R8411W76M/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】 为什么jwt会被广泛应用 | [点击观看](https://www.bilibili.com/video/BV1Fe4y1B7Vr/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】 golang实现生产者消费者模式 | [点击观看](https://www.bilibili.com/video/BV1UG411g7mV/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】 go语言UDP网络编程之发送DNS请求 | [点击观看](https://www.bilibili.com/video/BV1kW4y1Y7RD/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】 go语言快速实现一个web互动直播（一） | [点击观看](https://www.bilibili.com/video/BV1g841147AK/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】go语言快速实现一个web互动直播（二） | [点击观看](https://www.bilibili.com/video/BV1CT411N76V/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】golang实现文件上传到对象存储 | [点击观看](https://www.bilibili.com/video/BV17g411e7Hh/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】论一款强大的验证组件在web开发中的重要性 | [点击观看](https://www.bilibili.com/video/BV1v14y1Y77r/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】golang配合公有云实现机器人流量的拦截 | [点击观看](https://www.bilibili.com/video/BV1DT411N7eg/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】golang面试题实现一个内存缓存系统 | [点击观看](https://www.bilibili.com/video/BV1eW4y1Y7in/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】最受欢迎的开源日志框架logrus实战应用 | [点击观看](https://www.bilibili.com/video/BV1wW4y1i75a/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n【golang云原生】基于公有云快速实现邮件推送 | [点击观看](https://www.bilibili.com/video/BV1te4y1n73d/?spm_id_from=333.999.0.0&vd_source=22dd8929751be7e4ede58924081f92cf)\n</div>\n\n---\n\n### 🏗 开源项目（段位纯属分类管理，不分先后）\n\n#### 王者段位\n\n<div align=center>\n\t\n项目 | 简介\n-------|-------------------\n[docker](https://github.com/docker/docker) | 无人不知的虚拟化平台，开源的应用容器引擎，借助该引擎，开发者可以打包他们的应用，移植到任何平台上。\n[golang](https://github.com/golang/go) | go本身，也是用go语言实现的，包括他的编译器，要研究go源代码的可以看此项目录 \n[kubernetes](https://github.com/kubernetes/kubernetes) | Google出品，用于调度和管理docker的开源容器管理系统，利用他，可以方便的管理你的docker实例，哪怕非常多，也是目前最流行的docker管理系统。 \n[gogs](https://github.com/gogits/gogs) |一款基于git的代码托管系统，类似于github和gitlab，不过其小巧易用，功能强大，部署方便，也有不少用户在使用。 \n[syncthing](https://github.com/syncthing/syncthing) | 开源的文件同步系统，它使用了其独有的对等自由块交换协议，速度很快，据说可以替换BitTorrent Sync。 \n[grafana](https://github.com/grafana/grafana) |一款开源监控度量的看板系统，可以接Graphite、Elasticsearch、InfluxDB等数据源，定制化很高。 \n[etcd](https://github.com/coreos/etcd) | 一款分布式的，可靠的K-V存储系统，使用简单，速度快，又安全。 \n[hub](https://github.com/github/hub) |一款更便捷使用github的工具，包装并且扩展了git，提供了很多特性和功能，使用和git差不多。 \n[influxdb](https://github.com/influxdata/influxdb) | 可伸缩的数据库，使用场景主要用来存储测量数据，事件点击以及其他等实时分析数据，用来做监控性能很不错。 \n[caddy](https://github.com/mholt/caddy) |快速的，跨平台的HTTP/2 Web服务器。 \n[beego](https://github.com/astaxie/beego) | 国产开源的高性能Web框架，让你快速的开发Go Web应用服务，谢大主笔。 \n[martini](https://github.com/go-martini/martini) |也是一款不错的Web框架。 \n[cayley](https://github.com/cayleygraph/cayley) |Google开源的图数据库，这是一个NoSql数据库，适合处理复杂的，但是结构化低的数据，适用于社交网络，推荐系统等。\n[nsq](https://github.com/nsqio/nsq) |一款开源的实时的，分布式的消息中间件系统。\n[codis](https://github.com/CodisLabs/codis) | Codis是一个分布式Redis解决方案，其实就是一个数据库代理，让你在使用Redis集群的时候，就像使用单机版的Redis是一样的，对开发者透明。 \n[delve](https://github.com/derekparker/delve) |这个Go开发者都知道，一款go应用开发的调试工具。 \n[cobra](https://github.com/spf13/cobra) |cobra是一个命令行go库，可以让你创建非常强大的，现代的CLI命令行应用。\n[megaease/easegress](https://github.com/megaease/easegress)|云本地流量编排系统\n\n\n</div>\n\n#### 大师段位\n\n项目 | 简介\n-------|-------------------\n[Viper](https://github.com/spf13/viper) | Viper 是一个完整的 Go 应用配置解决方案。\n[echo](https://github.com/labstack/echo) |高性能、极简主义的 Go Web 框架\n[uber-go/fx](https://github.com/uber-go/fx)|一个基于依赖注入的 Go 应用框架。 \t\n[Swagger](https://github.com/go-swagger/go-swagger) |生成器、UI 和验证 \n[Logrus](https://github.com/sirupsen/logrus) | Logrus 是一个适用于 Go(golang) 的结构化记录器，与标准库记录器完全 API 兼容。\n[mockery](https://github.com/vektra/mockery)| Golang 的模拟代码自动生成器\n[migrate](https://github.com/golang-migrate/migrate) |用 Go 编写的数据库迁移。作为 CLI 使用或作为库导入。 \t\n[NSQ](https://github.com/nsqio/go-nsq) |消息传递\t\t\n[sqlx](https://github.com/jmoiron/sqlx) |sqlx 是一个库，它在 Go 的标准 database/sql 库上提供了一组扩展。\t\n[Macaron](https://github.com/go-macaron/macaron)|一款具有高生产力和模块化设计的 Go Web 框架\n[Gin](https://github.com/gin-gonic/gin)|轻量 Web 框架\n[zinx](https://github.com/aceld/zinx)|TCP并发服务器框架\n[Negroni](https://github.com/urfave/negroni)|Web 中间件\n[csrf](https://github.com/gorilla/csrf)|CSRF 中间件\n[handlers](https://github.com/gorilla/handlers)|Go的net/http包的有用处理程序集合\n[SizedWaitGroup](https://github.com/remeh/sizedwaitgroup)|并发控制\n[concurrent](https://github.com/modern-go/concurrent)|并发工具包\n[grab](https://github.com/cavaliercoder/grab)|文件下载\n[go-netty](https://github.com/go-netty/go-netty)|网络框架\n\n#### 钻石段位\n\n项目 | 简介\n-------|-------------------\n[gorilla/websocket](https://github.com/gorilla/websocket)|Go的一个快速、经过良好测试和广泛使用的WebSocket实现。\n[nhooyr/websocket ](https://github.com/nhooyr/websocket)|常用的Go WebSocket库\n[websocketd](https://github.com/joewalnes/websocketd)|Go 开发的一键搭建 WebSocket 服务器命令行工具\n[ws](https://github.com/gobwas/ws)|WebSocket 开发包\n[melody](https://github.com/olahol/melody)|WebSocket 服务框架\n[neffos](https://github.com/kataras/neffos)|一个现代的、快速的、可扩展的websocket框架，带有优雅的Go API\n[fastws](https://github.com/dgrr/fastws)|fastttp和net/http的快速WebSocket实现。默认支持并发读写操作。\n[Centrifugo](https://github.com/centrifugal/centrifugo)|实时消息服务器，可以与任何语言编写的应用程序后端结合使用\n[goim](https://github.com/Terry-Mao/goim)|支持集群的 im 及实时推送服务\n[Tinode](https://github.com/tinode/chat)|即时消息服务器，通过 websocket/JSON 或 gRPC/TCP 等协议传输\n[WebRTC](https://github.com/pion/webrtc)|WebRTC 实现\n[Berty](https://github.com/berty/berty)|安全的点对点通讯软件\n[Keybase](https://github.com/keybase/client)|即时通讯工具 Keybase 全平台客户端\n[golang/protobuf](https://github.com/golang/protobuf)|Go 版本的 Protocol Buffers\n[gogo/protobuf](https://github.com/gogo/protobuf)|golang/protobuf 的扩展替代品\n[Objx](https://github.com/stretchr/objx)|操作 map、slice、JSON 等数据的包\n[gorilla/rpc](https://github.com/gorilla/rpc)|构建基于 HTTP 的 RPC 服务，比如 JSON-RPC\n[Twirp](https://github.com/twitchtv/twirp)|基于 Protobuf 的 RPC 框架，与 gRPC 类似\n\n#### 铂金段位\n\n项目 | 简介\n-------|-------------------\n[dubbo-go](https://github.com/apache/dubbo-go)|Apache Dubbo Go 语言实现，架起 Java 和 Golang 之间的桥梁，与 gRPC/Spring Cloud 生态互联互通，带领 Java 生态享受云原生时代的技术红利\n[NSQ](https://github.com/nsqio/nsq)|实时分布式消息平台\n[NATS](https://github.com/nats-io/nats-server)|云原生消息中间件\n[sarama](https://github.com/Shopify/sarama)|Kafka 客户端\n[InfluxDB](https://github.com/influxdata/influxdb)|时间序列数据库\n[Thanos](https://github.com/thanos-io/thanos)|支持 Prometheus 简化部署、高可用、分布式存储\n[CockroachDB](https://github.com/cockroachdb/cockroach)|分布式 SQL 数据库\n[RadonDB](https://github.com/radondb/radon)|基于 MySQL 研发的新一代分布式关系型数据库\n[TiDB](https://github.com/pingcap/tidb)|分布式关系型数据库，兼容 MySQL 协议\n[AresDB](https://github.com/uber/aresdb)|Uber 开源的 GPU 驱动的实时分析存储&查询引擎\n[leveldb](https://github.com/syndtr/goleveldb)| LevelDB 的 Go 实现\n[GCache](https://github.com/bluele/gcache)|golang的内存缓存库。支持多种驱逐政策:LRU、LFU、ARC\n[go-cache](https://github.com/patrickmn/go-cache)|Go的内存键:值存储/缓存(类似于Memcached)库，适用于单机应用程序。\n[groupcache](https://github.com/golang/groupcache)|分布式缓存\n[cachego](https://github.com/faabiosr/cachego)|支持 Redis、Bolt 等缓存接口\n[go-tagexpr](https://github.com/bytedance/go-tagexpr)|字节跳动开源的结构体标签表达式解释器\n[goav](https://github.com/giorgisio/goav)|FFmpeg 视频处理\n[rosedb](https://github.com/roseduan/rosedb)|基于 bitcask 的 k-v 存储模型，高效、快速、简洁\n\n---\n\n### 🖼 大厂实战分享ppt\n\n* [Go in TiDB](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%20in%20TiDB.pdf)\n* [Go 如何助力企业进行微服务转型](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%20%E5%A6%82%E4%BD%95%E5%8A%A9%E5%8A%9B%E4%BC%81%E4%B8%9A%E8%BF%9B%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BD%AC%E5%9E%8B.pdf)\n* [Golang 内存管理探微&mdash&mdash，如何高效使用 Golang 内存以及腾讯云实战-杨晖](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Golang%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%8E%A2%E5%BE%AE%26mdash%26mdash%EF%BC%8C%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%20Golang%20%E5%86%85%E5%AD%98%E4%BB%A5%E5%8F%8A%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%9E%E6%88%98-%E6%9D%A8%E6%99%96.pdf)\n* [Golang主动式内存缓存的优化探索之路](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Golang%E4%B8%BB%E5%8A%A8%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF.pdf)\n* [Golang在百万亿搜索引擎中的应用](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Golang%E5%9C%A8%E7%99%BE%E4%B8%87%E4%BA%BF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf)\n* [Golang在阿里巴巴调度系统Sigma中的实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Golang%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9FSigma%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)\n* [Go在大数据开发中的经验总结](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E5%9C%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93.pdf)\n* [Go在探探后端的工程实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E5%9C%A8%E6%8E%A2%E6%8E%A2%E5%90%8E%E7%AB%AF%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf)\n* [Go在证券行情系统中的应用](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E5%9C%A8%E8%AF%81%E5%88%B8%E8%A1%8C%E6%83%85%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf)\n* [Go微服务实战](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98.pdf)\n* [Go打造亿级实时分布式平台](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E6%89%93%E9%80%A0%E4%BA%BF%E7%BA%A7%E5%AE%9E%E6%97%B6%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0_2.pdf)\n* [Go语言在讯联扫码支付系统中的成功实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%AE%AF%E8%81%94%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%8A%9F%E5%AE%9E%E8%B7%B5.pdf)\n* [Go语言在证券期货行情系统中的实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%AF%81%E5%88%B8%E6%9C%9F%E8%B4%A7%E8%A1%8C%E6%83%85%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)\n* [Go语言的抢占式调度](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.pdf)\n* [Improving Go Backend Developer Experience in Grab](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Improving%20Go%20Backend%20Developer%20Experience%20in%20Grab.pdf)\n* [Processing XML and Spreadsheet Data in Go](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Processing%20XML%20and%20Spreadsheet%20Data%20in%20Go.pdf)\n* [The Zen of Go](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/The%20Zen%20of%20Go.pdf)\n* [Tracing in TiDB](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/Tracing%20in%20TiDB.pdf)\n* [goplus-gopher-china](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/goplus-gopher-china.pdf)\n* [云原生技术在2B交付中的实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%9C%A82B%E4%BA%A4%E4%BB%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)\n* [利用夜莺扩展能力打造全方位监控系统](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%88%A9%E7%94%A8%E5%A4%9C%E8%8E%BA%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E6%89%93%E9%80%A0%E5%85%A8%E6%96%B9%E4%BD%8D%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.pdf)\n* [基于 Golang 构建高可扩展的云原生 PaaS 平台](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%9F%BA%E4%BA%8E%20Golang%20%E6%9E%84%E5%BB%BA%E9%AB%98%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%20PaaS%20%E5%B9%B3%E5%8F%B0.pdf)\n* [基于Kubernetes的私有云实战](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%9F%BA%E4%BA%8EKubernetes%E7%9A%84%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%9E%E6%88%98.pdf)\n* [大规模场景下Kubernetes Service负载均衡性能优化](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%9C%BA%E6%99%AF%E4%B8%8BKubernetes%20Service%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.pdf)\n* [天猫DevOps转型实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%A4%A9%E7%8C%ABDevOps%E8%BD%AC%E5%9E%8B%E5%AE%9E%E8%B7%B5.pdf)\n* [如何用Go模拟CPU](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%A8%A1%E6%8B%9FCPU.pdf)\n* [字节跳动在 Go 网络库上的实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8%20Go%20%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)\n* [深入Go Module](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E6%B7%B1%E5%85%A5Go%20Module.pdf)\n* [深入理解BFE](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFE.pdf)\n* [罗辑思维Go语言微服务改造实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4Go%E8%AF%AD%E8%A8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5.pdf)\n* [谈如何构建易于拆分的单体应用](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E8%B0%88%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%98%93%E4%BA%8E%E6%8B%86%E5%88%86%E7%9A%84%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8.pdf)\n* [跨境电商的Go服务治理实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86%E7%9A%84Go%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%AE%9E%E8%B7%B5.pdf)\n* [阿里巴巴新一代基于 Go 的云原生应用引擎实践](https://github.com/0voice/Introduction-to-Golang/blob/main/Golang%20PPT/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9F%BA%E4%BA%8E%20Go%20%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%BC%95%E6%93%8E%E5%AE%9E%E8%B7%B5.pdf)\n\n---\n\n### 📄 论文与理论分析\n\n<div align=center>\n\t\nTitle|Translation（参考）|Company\n:---------------: | :------------: | :-------:\n[《Acme: A User Interface for Programmers》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/A%20User%20Interface%20for%20Programmers.pdf) | 程序员的用户界面 | AT&T,贝尔实验室\n[《Understanding Real-World Concurrency Bugs in Go》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/Understanding%20Real-World%20Concurrency%20Bugs%20in%20Go.pdf) | 了解真实go中的并发bug | 宾夕法尼亚州立大学\n[《A Formal Model of the Kubernetes Container Framework》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AA%20Formal%20Model%20of%20the%20Kubernetes%20Container%20Framework%E3%80%8B.pdf) | Kubernetes容器框架的形式化模型 | 奥斯陆大学\n[《Running Cloud Native Applications on DigitalOcean Kubernetes》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8ARunning%20Cloud%20Native%20Applications%20on%20DigitalOcean%20Kubernetes%E3%80%8B.pdf) | 在DigitalOcean Kubernetes上运行云本地应用 | 未知\n[《Kubernetes as an Availability Manager for Microservice Applications》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AKubernetes%20as%20an%20Availability%20Manager%20for%20Microservice%20Applications%E3%80%8B.pdf) | Kubernetes作为微服务应用程序的可用性管理器 | 康科迪亚大学\n[《Borg, Omega, and Kubernetes》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8ABorg%2C%20Omega%2C%20and%20Kubernetes%E3%80%8B.pdf) | Borg、Omega 和 Kubernetes | GOOGLE\n[《A Raft-based HTAP Database》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AA%20Raft-based%20HTAP%20Database%E3%80%8B.pdf)|基于raft的HTAP数据库|VLDB基金会论文集\n[《For Reproducible Environments and Containerized Applications》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AFor%20Reproducible%20Environments%20and%20Containerized%20Applications%E3%80%8B.pdf)|用于可复制环境和容器化应用程序 |圣克劳德州立大学\n[《Escape from Escape Analysis of Golang》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AEscape%20from%20Escape%20Analysis%20of%20Golang%E3%80%8B.pdf)|golang逃离分析 |清华大学\n[《Using gRPC with Go》](https://github.com/0voice/Introduction-to-Golang/blob/main/paper/%E3%80%8AUsing%20gRPC%20with%20Go%E3%80%8B.pdf)| 在Go中使用gRPC|未知\n\n\n</div>\n\n---\n\n\n### ☁ 云原生\n\n**这里我们讲云原生，主要目的是为了大家如何利用云原生技术，快速地使用go语言开发。而不是研究云原生本身的技术。**\n\n我们以**腾讯云**为例，列举腾讯云为我们提供的云原生接口项目：（列举部分我们常见的）\n\n* 实时音视频\n  * 混流转码\n  * 房间管理\n  * 其他接口\n  * 通话质量监控\n* 云点播\n  * [视频处理](https://github.com/0voice/Introduction-to-Golang/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/%E8%85%BE%E8%AE%AF%E4%BA%91/%E4%BA%91%E7%82%B9%E6%92%AD/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.md)\n  * 参数模板\n  * 其他接口\n  * 任务流\n  * 分发\n  * 媒资管理\n  * 视频上传\n  * 事件通知\n  * AI 样本管理\n  * 视频分类\n  * 任务管理\n  * 域名管理\n  * 数据统计\n* 视频处理\n  * 视频处理\n  * 工作流管理\n  * 其他接口\n  * 解析事件通知\n  * AI 样本管理\n  * 参数模板\n  * 任务管理\n* 腾讯云剪\n  * 平台管理\n  * 项目管理\n  * SaaS 平台管理\n  * Headless媒体合成\n  * 任务管理\n  * 视频编辑项目\n  * 媒体资源管理\n  * 媒资授权\n  * 团队管理\n  * 分类管理\n  * 登录态管理\n  * 其他接口\n* 智能编辑\n  * 画质重生任务\n  * 媒体质检任务\n  * 编辑理解\n  * 编辑处理\n* 即时通信 IM\n  * 获取云通信 IM 的 SDKAppid\n* 短信\n  * 短信统计\n  * 发送短信\n  * 拉取状态\n  * 短信模板\n  * 短信签名\n* 分布式消息队列\n  * 集群\n  * 命名空间\n  * 主题\n  * 消息\n  * CMQ管理\n  * CMQ消息\n  * 其他接口\n  * 生产消费\n* 消息队列 Ckafka\n  * 主题\n  * ACL\n  * 实例\n  * 路由\n  * 其他接口\n* 验证码\n  * 控制台\n  * 服务器\n* 文本内容安全\n* 图片内容检测\n  * 图片内容审核\n  * 图片内容检测\n* 音频内容检测\n  * 创建音频审核任务\n  * 查看任务详情\n  * 查看审核任务列表\n  * 短音频识别接口\n  * 取消任务\n* 视频内容安全\n  * 查看审核任务列表\n  * 查看任务详情\n  * 创建视频审核任务\n  * 取消任务\n* 文字识别\n  * 通用文字识别\n  * 卡证文字识别\n  * 票据单据识别\n  * 汽车场景识别\n  * 行业文档识别\n  * 智能扫码\n  * 营业执照核验\n  * 增值税发票核验\n* 图像分析\n  * 图像理解\n  * 图像处理\n  * 图像审核\n  * 图像质量检测\n* 智能识图\n  * 商品识别\n* 语音识别\n  * 语音流异步识别\n  * 录音文件识别\n  * 一句话识别\n  * 自学习\n  * 热词\n* 语音合成\n  * 长文本语音合成\n  * 通用语音合成\n* 智能语音服务\n  * 语音合成\n  * 其他接口\n  * 语音识别\n* 云直播\n  * 水印管理\n  * 证书管理\n  * 录制管理\n  * 直播流管理\n  * 延播管理\n  * 直播拉流\n  * 直播转码\n  * 截图鉴黄\n  * 鉴权管理\n  * 域名管理\n  * 直播回调\n  * 统计查询\n  * 实时日志\n  * 直播混流\n* 小程序 · 云直播\n  * live\n  * 其他接口\n  * 直播\n* 人脸识别\n  * 人脸检测与分析\n  * 五官定位\n  * 人脸比对\n  * 人员库管理\n  * 人脸搜索\n  * 人脸验证\n  * 人脸静态活体检测（高精度版）\n  * 人脸静态活体检测\n  * 人员查重\n* 内容安全\n  * 内容安全\n  * 图片内容安全\n  * 文本内容安全\n  * 自定义识别\n* 自然语言处理\n  * 向量技术\n  * 词法分析\n  * 句法分析\n  * 篇章分析\n  * 知识图谱\n  * 对话机器人<br>\n......\n\n\n## 📥 [源码下载](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%BA%90%E7%A0%81/go1.16.7.src.tar.gz)\n\nGo官网下载地址：https://golang.org/dl/\n\nGo官方镜像站（推荐）：https://golang.google.cn/dl/\n\n## 🏃‍♂ [开启Go语言学习之旅，从\"Hello World\"开始！](https://github.com/0voice/Introduction-to-Golang/blob/main/%E6%90%AD%E5%BB%BAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md)\n\n<div  align=center>\n  \n![image](https://user-images.githubusercontent.com/87457873/128685884-d52fd32f-ed6e-4b7b-b9ef-a78bef3354a4.png)\n\n</div>\n\n### Step 1：了解源代码目录结构\n  \n<div  align=center>\n\n![image](https://user-images.githubusercontent.com/87457873/128687226-8ac5bb7c-f09b-4cb3-afc0-cf18bff9d15a.png)\n  \n</div>\n\n<br>\n\n文件名 | 文件属性\n------ | ------\nAUTHORS|文件，官方 Go语言作者列表\nCONTRIBUTORS|文件，第三方贡献者列表\nLICENSE|文件，Go语言发布授权协议\nPATENTS|文件，专利\nREADME |文件，README文件，大家懂的。提一下，经常有人说：Go官网打不开啊，怎么办？其实，在README中说到了这个。该文件还提到，如果通过二进制安装，需要设置GOROOT环境变量；如果你将Go放在了/usr/local/go中，则可以不设置该环境变量（Windows下是C:\\go）。当然，建议不管什么时候都设置GOROOT。另外，确保$GOROOT/bin在PATH目录中。\nVERSION|文件，当前Go版本\napi|目录，包含所有API列表，方便IDE使用\ndoc|目录，Go语言的各种文档，官网上有的，这里基本会有，这也就是为什么说可以本地搭建”官网”。这里面有不少其他资源，比如gopher图标之类的。\nfavicon.ico |文件，官网logo\ninclude |目录，Go 基本工具依赖的库的头文件\nlib |目录，文档模板\nmisc|目录，其他的一些工具，相当于大杂烩，大部分是各种编辑器的Go语言支持，还有cgo的例子等\nrobots.txt |文件，搜索引擎robots文件\nsrc |目录，Go语言源码：基本工具（编译器等）、标准库\ntest |目录，包含很多测试程序（并非_test.go方式的单元测试，而是包含main包的测试），包括一些fixbug测试。可以通过这个学到一些特性的使用。\n\n### Step 2：Golang开发后台掌握哪些知识点？\n\n这里我给大家整理归纳为四大块，分别是**语法**、**中间件**、**后端开发**、**云原生**。\n\n我们通过这个四个板块的学习，逐步进阶成一个可以从事后端服务器开发的工程师。\n\n<div  align=center>\n  \n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128867223-af882655-eaa7-4523-b737-b3de4c4f5b56.png\"/>\n\n</div>\n\n下面我们简单介绍中间件和云原生：\n\n#### 中间件\n\nMySQL、Redis、MongoDB、Kafka这些常见的中间件，这里我们不做赘述。我们着重简述下Gin、etcd、ElasticSearch、gRPC。\n\n* **Gin**<br>\nGin是一个用Go (Golang)编写的HTTP web框架。它具有一个类似martinii的API，性能要好得多——快了40倍。<br>\n官方Github项目：https://github.com/gin-gonic/gin\n\n* **etcd**<br>\nEtcd是一种强一致性的分布式键值存储，它提供了一种可靠的方法来存储需要被分布式系统或机器集群访问的数据。它可以在网络分区期间优雅地处理leader选举，并且可以容忍机器故障，即使是leader节点。<br>\n官网：https://etcd.io/\n\n* **ElasticSearch**<br>\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。<br>\n官网：https://www.elastic.co/cn/elasticsearch/\n\n* **gRPC**<br>\ngRPC是一个现代的开源高性能远程过程调用(Remote Procedure Call, RPC)框架，可以在任何环境中运行。通过对负载平衡、跟踪、运行状况检查和身份验证的可插拔支持，它可以有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。<br>\n官网：https://grpc.io/\n\n#### 云原生\n\n* **微服务**<br>\n微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的API集相互通信。\n\n* **DevOps**<br>\nDevOps是一种重视“软件开发人员”和“IT运维技术人员”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 \n\n* **持续部署**<br>\n持续部署，是一种软件工程方法，意指在软件开发流程中，以自动化方式，频繁而且持续性的，将软件部署到生产环境中，使软件产品能够快速的发展。\n持续部署可以整合到持续整合与持续交付（Continuous delivery）的流程之中。\n\n* **容器化**<br>\n容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。 容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。\n\n### Step 3：如何高效地学习Go？\n\n想要高效地的学习Golang，单单知道学习哪几个板块，是远远不够的。我们还需要将每个板块的知识点进一步细化。<br>\n——**成功与失败之间，最重要的是不容忽视的细节**<br>\n\n那么开始进一步完善之前的知识点：\n\n<div  align=center>\n  \n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128875154-16e7ce3a-5817-4cb5-804a-1ad4b5bc5b5b.png\"/>\n\n</div>\n\n#### 语法\n* 语法基础\n\t* 错误处理\n\t* 包定义以及导入\n\t* 结构体\n\t* 反射原理\n\t* 值传递、引用传递、defer函数\n* 并发编程\n\t* goroutine\n\t* 锁\n\t* 通道channel\n\t* runtime包\n\t* Context使用原则\n* 网络编程\n\t* tcp/udp编程\n\t* http实现\n\t* websocket\n* 源码掌握\n\t* GC机制\n\t* 调度器\n\t* 定时器\n\t* map与切片\n* 第三方测试框架\n\t* goconvey\n\t* gostub\n\t* gomock\n\t* monkey\n\n<div  align=center>\n  \n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128885748-5d075c80-c5d2-4f3b-bb2c-1939970b1305.png\"/>\n\n</div>\n\n#### 中间件\n* MySQL\n  * golang的CRUD\n  * jmorion/sqlx包\n  * 连接池\n  * 异步mysql\n* Gin\n  * RESTful API\n  * URL查询参数\n  * query接收数组和Map\n  * 表单参数\n  * 上传文件\n  * 分组路由routel以及中间件授权\n  * json、struct、xml、yaml、protobuf渲染\n* Redis\n  * go-redis\n  * get/set/zset操作\n  * 连接池\n  * 分布式锁\n* MongoDB\n  * MongoDB-driver\n  * BSON解析\n  * CRUD操作\n  * 文档管理\n  * 连接池\n* Kafka\n  * saram包\n  * 同步、异步\n  * zstd压缩算法\n  * 横向扩展\n  * go实现生产消费者\n  * topic和partition\n  * 消息分发策略\n  * 分区副本机制\n* etcd\n  * 原理\n  * 分布式锁\n  * etcd操作\n  * 服务发现于注册\n* ElasticSearch\n  * es服务器\n  * go- elasticsearch包\n  * node于cluster\n  * Index于Document\n  * 检测与配置\n* gRPC\n  * protoc-gen-go开发包\n  * .proto文件\n  * gRPC Service Stub\n  * rpc接口设计\n  * 通信模式\n  * 拦截器\n  * 多路复用\n  * 负载均衡\n  * 安全认证\n\n<div  align=center>\n  \n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128963340-173a3516-c0ec-470b-8546-ef6a34683066.png\"/>\n\n</div>\n\n#### 后端开发\n* 游戏后端\n  * leaf框架\n  * 网关、协议、日志、网络模块\n* 流媒体Web后端\n  * Restful接口设计\n  * scheduler设计\n  * apidefs结构体\n  * mysql建库建表\n* 小程序后端\n  * 公众号开发流程\n  * 微信消息接收与解析\n  * 公众号验证URL+Token\n  * 内网环境接口测试\n  * 后端程序测试脚本\n* goadmin后台权限管理系统\n  * RESTful API设计\n  * Gin框架\n  * JWT认证\n  * 支持Swagger文档\n  * GORM对象关系映射\n  * 基于Casbin的RBAC访问控制模型\n* goim千万级高并发推送服务\n  * 单个、多个、广播消息推送\n  * 应用心跳、tcp、keepalive、http log pulling\n  * 异步消息推送\n  * 接入层多协议\n  * 可拓扑架构\n  * 注册发现服务\n  * 消息协议（protobuf）\n  * goim推送\n  * grpc编程\n* 腾讯云大数据\n  * TBDS\n  * 云数据仓库PostgreSQL\n  * 弹性MapReduce\n  * WeData数据开发平台\n\n<div  align=center>\n  \n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/128963600-fcca8120-e8e1-4a69-9562-e112e541e973.png\"/>\n\n</div>\n\n#### 云原生\n\n* 微服务\n  * go-micro原理\n  * rpc\n  * 服务间同步\n  * json/protobuf\n* DevOps\n  * 项目管理 CODING-PM\n  * 测试管理 CODING-TM\n  * 制品库 CODING-AR\n  * 代码托管 CODING-CR\n* 持续部署\n  * spinnake\n  * webhook外部对接\n  * 蓝绿分布/金丝雀发布\n  * SCF云函数\n  * 快速回滚\n* 容器化\n  * Docker化部署\n  * k8s集群\n  * CVM云服务器\n  * TKE容器服务\n\n## 🤝 鸣谢\n\n##### 本repo励志作为全网golang资料最全的repo，因此非常感谢各位贡献patch的朋友， 还有很多在issue里面出谋划策的朋友，为此衷心感谢。\n\n<a href=\"https://github.com/wangbojing\">\n    <img src=\"https://avatars.githubusercontent.com/u/18027560?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/wenchao1024\">\n    <img src=\"https://avatars.githubusercontent.com/u/87457873?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/aiyijing\">\n    <img src=\"https://avatars.githubusercontent.com/u/11643145?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/nathan-tw\">\n    <img src=\"https://avatars.githubusercontent.com/u/61750268?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/louis70109\">\n    <img src=\"https://avatars.githubusercontent.com/u/6940010?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/z774379121\">\n    <img src=\"https://avatars.githubusercontent.com/u/32691620?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/roseduan\">\n    <img src=\"https://avatars.githubusercontent.com/u/22375523?v=4\" width=\"40px\">\n</a> \n\n<a href=\"https://github.com/IanSmith123\">\n    <img src=\"https://avatars.githubusercontent.com/u/19611084?v=4\" width=\"40px\">\n</a>\n\n<br/>\n<br/>\n<h3 >零领工作</h3> \n\n---\n\n##### 实时提供，每周发布北京，上海，广州，深圳，杭州，南京，合肥，武汉，长沙，重庆，成都，西安，厦门的c/c++，golang方向的招聘岗位信息。 校招，社招，实习岗位都有的。 面经，八股，简历都有的\n\n<img src=\"https://img.0voice.com/public/0e59910091576beaebe20f303357edf7.jpg\" alt=\"零领工作\" style=\"width:300px;height:300px;\">\n\n<br/>\n<br/>\n\n\n"
        },
        {
          "name": "Rob Pike谈Google Go.md",
          "type": "blob",
          "size": 26.27734375,
          "content": "## 1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？\n\n我还是讲讲为什么要创建这门语言吧，和你的问题稍有些不同。我在Google做了一个有关编程语言的系列讲座，在Youtube上有，谈及了我早期所写的一个语言，叫做Newsqueak，那是八十年代的事，非常早。在做讲座期间，我开始思考为什么Newsqueak中的一些想法在我现在以C++为主的工作环境中无法使用。而且在Google我们经常要构建非常大的程序，光构建就要花很多时间，对依赖的管理也有问题，由于链接了本来并不需要的东西，二进制程序包变得很大，链接时间很长，编译时间也很长，而且C++的工作方式有点古老，其底层实际上C，C++已经有三十年的历史了，而C则更是有四十年了。用现今的硬件做计算，有很多新东西需要考虑：多核机器、网络化、分布式系统、云计算等等。\n\n## 2. Go的主要特点是什么？有什么重要功能？\n\n对于大多数人来说，他们对Go的第一印象是该语言将并发性作为语言原语，这对我们处理分布式计算和多核这类东西来说非常好、也非常重要。我猜许多人会认为Go是一门简单无趣的语言，没有什么特别的东西，因为其构想看起来一目了然。但实际上不能用第一印象来判断Go。很多用过Go的人会发现它是一门非常高产而且有表现力的语言，能够解决我们编写这门语言时期望其所能解决的所有问题。\n\nGo的编译过程很快，二进制程序包又比较小，它管理依赖的方式如同管理语言本身的东西一样。这里还有一个故事呢，但是在这里就不再展开讨论了，但是这门语言的并发性使其能够以非常简单的模式来处理非常复杂的操作及分布式计算环境。我想最重要的功能可能就是并发性了，后面我们可以谈谈该语言的类型系统，其与C++、Java这类传统面向对象类型系统的差异很大。\n\n## 3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？\n\n它之所以快，有两个原因。首先Go有两个编译器——两个单独的实现。一个是按照Plan 9（http://plan9.bell-labs.com/wiki/plan9/1/） 风格新写的编译器，它有自己独特的工作方式，是个全新的编译器。另一个编译器叫做GCC Go，它拥有GCC前端，这个编译器是Ian Taylor后来写的。所以Go有两个编译器，速度快是二者的共同特点，但是Plan 9风格编译器的速度是GCC Go的5倍，因为它从头到脚都是全新的，没有GCC后端，那些东西会花很多时间来产生真正的好代码。\n\nGCC Go编译器要产生更好的代码，所以速度慢些。不过真正重要的一点是Go编译器的依赖管理特性才是其编译速度快的真正原因。如果你去看一个C或C++程序，便会发现其头文件描述了函数库、对象代码等等东西。语言本身并不强制检查依赖，每一次你都必须分析代码以便清楚你的函数是怎样的。如果你编译过程中想用另一个类的C++程序，你必须先编译它所依赖的类和头文件等等等等。如果你所编译的C++程序有许多类，并且内部相关，你可能会把同一个头文件编译数百次甚至上千次。当然，你可以用预编译头文件及其他技巧来回避之一问题。\n\n但是语言本身并不能帮上你的忙，工具可能会让这一问题得到改善，可是最大的问题是并没有什么能保证你所编译的东西就是程序真正需要的东西。有可能你的程序包含了一个并不真正需要的头文件，但是你没办法知道，因为语言并没有强制检查。而Go有一个更加严格的依赖模型，它有一些叫做包（packages）的东西，你可以把它想象成Java类文件或着类似的东西，或者函数库什么的，虽然他们并不相同，但基本思路是一样的。关键问题是，如果这个东西依赖那个东西，而那个东西又依赖另外一个东西，比如A依赖于B，B又依赖于C，那么你必须首先编译最内层的依赖：即，你先编译C，然后编译B，最后编译A。\n\n但是如果A依赖B，但是A并不直接依赖于C，而是存在依赖传递，那么该怎么办呢？这时所有B需要从C拿到的信息都会被放在B的对象代码里。这样，当我编译A的时候，我不需要再管C了。于是事情就非常简单了：在你编译程序时，你只需将类型信息沿着依赖关系树向上遍历即可，如果你到达树的顶端，则只需编译紧邻的依赖，而不用管其它层级的依赖了。如果你要做算术运算，你会发现在Objective-C或C++或类似的语言里，虽然只包含了一个简单的头文件，但由于依赖传递的存在，你可能会编译数十万行程序。然而在Go中，你打开一个文件，里面或许只有20行，因为其中只描述了公共接口。\n\n如果一个依赖链里只有三个文件，Go的优势可能并不明显，但是如果你有成千上万个文件的时候，Go的速度优势会成指数增长。我们相信，如果用Go的话，我们应该能够在数秒内就编译完数百万行代码。然而如果是等量的用C++编写的程序，由于依赖管理问题，编译的开销会大得多，编译的时间将会长达若干分钟。因此，Go速度快的根源主要归功于对依赖的管理。\n\n## 4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？\n\nGo里的类型与其它传统编程语言里的类型是类似的。Go里的类型有整数、字符串、struct数据结构、以及数组（array），我们称之为切片（slice），它们类似于C的数组，但更易于使用，更加固定一些。你可以声明本地类型并予以命名，然后按照通常的方式来使用。Go和面向对象方式的不同之处在于，类型只是书写数据的一种方式，方法则是一个完全独立的概念。你可以把方法放在struct上，在Go里没有类的概念，取而代之的是结构，以及为此结构声明的一些方法。\n\n结构不能与类混为一谈。但是你也可以把方法放在数组、整数、浮点数或字符串上，实际上任何类型都可以有方法。因此，这里方法的概念比Java的方法更加泛化，在Java里方法是类的一部分，仅此而已。例如，你的整数上可以有方法，听上去似乎没什么用，但是如果你想在一个叫做Tuesday的整数常量上附加上to_string方法来打印出漂亮的星期格式；或者，你想重新格式化字符串使其能够以不同的方式打印出自己，这时你就会意识到它的作用。为什么非要把所有方法或者其它好东西都塞进类里面呢，为什么不让它们提供更广泛的服务呢？\n\n## 5. 那么这些方法只是在包内部可见喽？\n\n非也，实际上是这样，Go只允许你在包内为你所实现的类型定义方法。我不能引入你的类型然后直接把我的方法增加进去，但是我可以使用匿名属性（anonymous field）将其包裹起来，方法可不是你想加到哪就加到哪的，你要定义类型，然后才能把方法放在上面。正因为如此，我们在包里提供了另一种封装——接口（interface），但是如果你不明白谁能为对象增加方法的严格界限，就很难理解接口。\n\n## 6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？\n\n你要typedef一个整数类型，起个名字，如果你正在处理一星期中的七天，可以就叫它“Day”，你可以给你所声明的类型——Day增加方法，但是你不能直接给int增加方法。因为整数类型不是你定义的，不在你的包里，它是引入的但并不在你的包中定义，这就意味着你不能给其增加方法。你不能给不在你包里定义的类型增加方法。\n\n## 7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。\n\n它是安全可控的，而且很容易理解。最初我们觉得类型用起来可能不太方便，我们也希望像Ruby那样添加方法，但这又让接口比较难以理解。所以，我们只把方法取出来，而不是放进去，我们想不出有什么更好的办法，于是限制方法只能在本地类型上，不过这种思路确实很容易理解和使用。\n\n## 8. 你还提到了typedef，是叫typedef吧？\n\n应该叫“type”，你所说的类型——Day的定义方式是这样“type Day int”，这样你就有一个新类型了，你可以在其上增加方法、声明变量，但这个类型不同于int，不像C那样，只是同一事物另起了个名字而已，在Go里实际上你创建了一个不同于int的新类型，叫做“Day”，它拥有int的结构特性，但却有自己的方法集。\n\n### 9. Typedef在C里是一种预处理指令吗？【编辑注/免责申明：C语言里的typedef与预处理无关】\n\n那实际上就是个别名，但在Go里不是别名，是新类型。\n\n## 10. 我们从底层说起吧，在Go里最小的类型是什么？\n\n最小的类型应该是布尔类型（bool）吧。bool、int和float，然后是int32、float64之类有尺寸的类型、字符串、复杂类型，可能有遗漏，但这就是基本类型集了。你可以由这些类型构建结构、数组、映射（map），映射在Go里是内建类型不是函数库。然后我想就该是接口了，到了接口，有趣的东西才真正开始。\n\n## 11. 但是，int这样的类型是值类型对吧.\n\nInt是值类型。在Go里，任何类型都是值类型，和C一样，所有东西都是按值调用，但是你也可以用指针。如果你想引用某样东西，可以获取其地址，这样你就有了一个指针。Go也有指针但是比C指针有更多限制，Go里的指针是安全的，因为他们是类型安全的，所以你没法欺骗编译器，而且也没有指针运算，因此，如果你有个指向某物的指针，你无法将其移到对象外，也无法欺骗编译器。\n\n## 12. 它们类似C++的引用吗？\n\n是的，很像引用，但是你可以按照你预期的方式对它们进行写操作。而且你可以使用结构内部（如缓冲区）中间的某个地址，它和Java的引用不一样。在Java中，你必须在旁边分配一个缓冲区，这是额外的开销。在Go中，你实际上把该对象分配为结构的一部分，在同一内存块中，这对性能是非常重要的。\n\n## 13. 它是结构内部一个复合对象。\n\n是的，如果它是值而不是指针的话，是这样。当然你也可以把指针放在结构内部和外部，但是如果你有struct A，而把struct B放在struct A里，那么stuct B就是一块内存，而不像Java那样，这也是Java性能问题的原因之一。\n\n## 14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。\n\nGo里的接口真的非常、非常地简单。接口指明了两个不同事情：其一，它表明了类型的构思，接口类型是一个罗列了一组方法的类型，因此如果你要抽象一组方法来定义一个行为，那么就定义一个接口并声明这些方法。现在你就有了一个类型，我们就叫它接口类型吧，那么从现在起所有实现了接口中这些方法的类型——包括基本类型、结构、映射（map）或其它什么类型，都隐含符合该接口要求。其二，也是真正有意思的是，和大多数语言中的接口不同的是，Go里面没有“implements”声明。\n\n你无须说明“我的对象实现了这个接口”，只要你定义了接口中的那些方法，它就自动实现了该接口。有些人对此感到非常担忧，依我看他们想说的是：知道自己实现（Implement）了什么接口真的很重要。如果你真想确定自己实现了什么接口，还是有技巧可以做到这一点的。但是我们的想法与此截然不同，我们的想法是你不应该考虑实现什么接口，而是应该写下要做的东西，因为你不必事前就决定要实现哪个接口。可能后来你实际上实现了某个现在你尚不知晓的接口，因为该接口还未设计出来，但是现在你已经在实现它。\n\n后来你可能发现两个原先未曾考虑过相关性的类具有了相关性——我又用了类这个词，我思考Java太多了——两个structs都实现了一些非常有用的小子集中的相关方法，这时有办法能够操作这两个structs中的任意一个就显得非常有用了。这样你就可以声明一个接口，然后什么都不用管了，即使这些方法是在别人的代码中实现的也没问题，虽然你不能编辑这些代码。如果是Java，这些代码必须要声明实现你的接口，在某种意义上，实现是单向的。然而在Go里，实现是双向的。对于接口实际上有不少漂亮而简单的例子。\n\n我最爱用的一个真实例子就是“Reader”，Go里有个包叫做IO，IO包里有个Reader接口，它只有一个方法，该方法是read方法的标准声明，比如从操作系统或文件中读取内容。这个接口可以被系统中任何做read系统调用的东西所实现。显然，文件、网络、缓存、解压器、解密机、管道，甚至任何想访问数据的东西，都可以给其数据提供一个Reader接口，然后想从这些资源中读取数据的任何程序都可以通过该接口达到目的。这有点像我们前面说过的Plan 9，但是用不同的方式泛化的。\n\n与之类似，Writer也是比较好理解的另一个例子，Writer 由那些要做写操作的人来实现。那么在做格式化打印时，fpringf的第一参数不是file了，而是Writer。这样，fprintf可以给任何实现了write方法的东西做IO格式化的工作。有很多很好的例子：比如HTTP，如果你正在实现一个HTTP服务器，你仅须对connection做fprintf，便可将数据传递到客户端，不需要任何花哨的操作。你可以通过压缩器来进行写操作，你可以通过我所提到的任何东西来进行写操作：压缩器、加密机、缓存、网络连接、管道、文件，你都可以通过fprintf直接操作，因为它们都实现了write方法，因此，隐含都隐含符合writer接口要求。\n\n## 15. 某种程度上有点类似结构化类型系统（structural typing)\n\n不考虑它的行为的话，它是有点像结构化类型系统。不过它是完全抽象的，其意并不在拥有什么，而是能做什么。有了结构（struct）之后，就规定了其内存的样子，然后方法说明了结构的行为，再之后，接口则抽象了该结构及其它实现了相同方法的其他结构中的这些方法。这是一种鸭子类型系统（duck typing，一种动态类型系统，http://en.wikipedia.org/wiki/Duck_typing），而不是结构化类型系统。\n\n## 16. 你提到过类，但Go没有类，对吧。\n\nGo没有类。\n\n## 17. 但是没有类怎么去写代码？\n\n带方法的结构（stuct）很像是类。比较有意思的不同之处是，Go没有子类型继承，你必须学习Go的另类写法，Go有更强大、更有表现力的东西。不过Java程序员和C++程序员刚开始使用Go的时候会感到意外，因为他们实际上在用Go去编写Java程序或C++程序，这样的代码工作得并不好，你可以这样做，但这样就略显笨拙了。但是如果你退一步，对自己说“我该怎样用Go去编写这些东西呢？”，你会发现模式其实是不同的，用Go你可以用更短的程序来表达类似的想法，因为你不需要在所有子类里重复实现行为。这是个非常不同的环境，比你第一眼看上去的还要不同。\n\n## 18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？\n\n有一个叫做匿名域的概念，也就是所谓的嵌入。其工作方式是这样：如果你有一个结构（struct），而又有一些其它东西实现了你想要的行为，你可以把这些东西嵌入到你的结构（struct）里，这样，这个结构（struct）不仅仅可以获得被嵌入者的数据还可以获得它的方法。如果你有一些公共行为，比如某些类型里都有一个name方法，在Java里的话你会认为这是一组子类（继承来的方法），在Go里，你只需拿到一个拥有name方法的类型，放在所有你要实现这个方法的结构里，它们就会自动获得name方法，而不用在每个结构里都去写这个方法。这是个很简单的例子，但有不少有趣的结构化的东西使用到了嵌入。\n\n而且，你还可以把多个东西嵌入到一个单一结构中，你可以把它想象成多重继承，不过这会让人更加迷惑，实际在Go里它是很简单的，它只是一个集合，你可以放任何东西在里面，基本上联合了所有的方法，对每个方法集合，你只需写一行代码就可以拥有其所有行为。\n\n## 19. 如果有多重继承命名冲突的问题该怎么办？\n\n命名冲突实际上并没什么，Go是静态处理这一问题的。其规则是，如果有多层嵌入，则最高层优先；如果同一层有两个相同的名字或相同的方法，Go会给出一个简单的静态错误。你不用自己检查，只需留意这个错误即可。命名冲突是静态检查的，而且规则非常简单，在实践中命名冲突发生的也并不多。\n\n## 20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？\n\n接口一个有意思的地方是他们只是集合，方法的集合，那么就会有空集合，没有任何方法的接口，我们称之为空接口。系统中任何东西都符合空接口的要求。空接口有点类似于Java的Object，不同之处在于，int、float和string也符合空接口，Go并不需要一个实际的类，因为Go里没有类的概念，所有东西都是统一的，这有点像void*，只不过void*是针对指针而不是值。\n\n但是一个空接口值可以代表系统中的任何东西，非常具有普遍性。所以，如果创建一个空接口数组，实际上你就有了一个多态性容器，如果你想再把它拿出来，Go里面有类型开关，你可以在解包的时候询问里面的类型，因此可以安全的进行解包操作。\n\n## 21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？\n\nCoroutines和Goroutines是不同的，它们的名字反应了这一点。我们给它起了个新名，因为有太多术语了，进程（processes）、线程（threads）、轻量级线程、弦（chords），这些东西有数不清的名字，而Goroutines也并不新鲜，同样的概念在其它系统里已经都有了。但是这个概念和前面那些名字有很大不同，我希望我们自己起名字来命名它们。Goroutine背后的含义是：它是一个coroutine，但是它在阻塞之后会转移到其它coroutine，同一线程上的其它coroutines也会转移，因此它们不会阻塞。\n\n因此，从根本上讲Goroutines是coroutines的一个分支，可在足够多的操作线程上获得多路特性，不会有Goroutines会被其他coroutine阻塞。如果它们只是协作的话，只需一个线程即可。但是如果有很多IO操作的话，就会有许多操作系统动作，也就会有许多许多线程。但是Goroutines还是非常廉价的，它们可以有数十万之众，总体运行良好并只占用合理数量的内存，它们创建起来很廉价并有垃圾回收功能，一切都非常简单。\n\n## 22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？\n\n对的，但是coroutines的数量和线程的数量是按照程序所做工作动态决定的。\n\n## 23. Goroutines有用于通信的通道吗？\n\n是的，一旦有两个独立执行的功能，如果Goroutine们要相互协作它们就需要相互对话。所以就有了通道这个概念，它实际上是一个类型消息队列，你可以用它来发送值，如果你在Goroutine中持有通道的一端，那么你可以发送类型值给另外一端，那一端则会得到想要的东西。通道有同步和异步之分，我们尽可能使用同步通道，因为同步通道的构思非常好，你可以同时进行同步和通信，所有东西运行起来都步调一致。\n\n但是有时由于效率原因或调度原因，对消息进行缓存也是有意义的。你可以向通道发送整型消息、字符串、结构、指向结构的指针等任何东西，非常有意思的事，你可以在通道上发送另一个通道。这样，我就能够把与他人的通信发送给你，这是非常有意思的概念。\n\n## 24. 你提到你们有缓存的同步通道和异步通道。\n\n不对，同步是没有缓存的；异步和缓存是一个意思，因为有了缓存，我才能把值放在缓存的空间里进行保存。但是如果没有缓存，我必须等着别人把值拿走，因此无缓存和同步是一个意思。\n\n## 25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。\n\n对，但是轻量级的。\n\n## 26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？\n\n没错，Goroutines在被创建的时候，只有非常小的一个栈——4K，可能有点小吧，这个栈是在堆中的，当然，你知道如果在C语言里有这么一个小栈会发生什么，当你调用函数或分配数组之类的东西时，程序会马上溢出。在Go里则不会发生这样的事情，每个函数的开头都会有若干指令以检查栈指针是否达到其界限，如果到达界限，它会链接到其它块上，这种连接的栈叫做分段栈，如果你使用了比刚开始启动时更多的栈，你就有了这种栈块链接串，我们称之为分段栈。\n\n 由于只有若干指令，这种机制非常廉价。当然，你可以分配多个栈块，但是Go编译器更倾向于将大的东西移到堆上，因此实际上典型的用法是，你必须在达到4K边界之前调用几个方法，虽然这并不经常发生。但是有一点很重要：它们创建起来很廉价，因为仅有一次内存分配，而且分配的内存非常小，在创建一个新的Goroutine时你不用指明栈的尺寸，这是很好的一种抽象，你根本不用担心栈的大小问题。之后，栈会随需求增长或缩小，你不用担心递归会有问题，你也不用担心大的缓存或任何对程序员完全不可见的东西，一切由Go语言来打理，这是一门语言的整体构思。\n\n## 27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？\n\n我认为这是个非常难的问题，我们也还没有解决它，我们的垃圾回收器可以工作，但是有一些延迟问题，垃圾回收器可能会停顿，但是我们的看法是，我们相信尽管这是一个研究课题，虽还没解决但是我们正在努力。对于现今的并行机，通过把机器内核的一些碎片专门分给作为后台任务的垃圾回收来进行并行回收是可行的。在这一领域有很多工作要做，也取得了不少成功，但这是个很微妙的问题，我不认为而我们会把延迟降为0，但是我相信我们可以让延迟尽可能低，这样对于绝大多数系统软件来讲它不再是个问题。我不保证每个程序都不会有显著延迟，但是我想我们可以获得成功，而且这是Go语言中一个比较活跃的领域。\n\n## 28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。\n\nGo可以让你深入到内存布局，你可以分配自己的空间，如果你想的话可以自己做内存管理。虽然没有alloc和free方法，但是你可以声明一个缓存把东西放进去，这个技巧可用来避免产生不必要的垃圾。就像在C语言一样，在C里，如果你老是malloc和free，代价很大。因此，你分配一个对象数组并把它们链接在一起，形成一个链表，管理你自己的空间，而且还不用malloc和free，那么速度会很快。你可以做与Go所做相同的事情，因为Go赋予你与底层事物安全打交道的能力，因此不用欺骗类型系统来达到目的，你实际上可以自己来做。\n\n 前面我表达了这样的观点，在Java里，无论何时你在结构里嵌入其它东西，都是通过指针来实现的，但在Go里你可以把它放在一个单一结构中。因此如果你有一些需要若干缓存的数据结构，你可以把缓存放在结构的内存里，这不仅意味着高效（因为你不用间接得到缓存），而且还意味着单一结构可以在一步之内进行内存分配与垃圾回收。这样开销就会减少。因此，如果你考虑一下垃圾回收的实际情况，当你正在设计性能要求不高的东西时，你不应该总是考虑这个问题。但如果是高性能要求的，考虑到内存布局，尽管Go是具有真正垃圾回收特性的语言，它还是给了你工具，让你自己来控制有多少内存和产生了的垃圾。我想这是很多人容易忽略的。\n\n## 29. 最后一个问题：Go是系统级语言还是应用级语言？\n\n我们是把他设计为一种系统级语言，因为我们在Google所做的工作是系统级的，对吧？Web服务器和数据库系统、以及存储系统等，这些都是系统。但不是操作系统，我不知道Go是否能成为一个好的操作系统语言，但是也不能说它不会成为这样的语言。有趣的是由于我们设计语言时所采用的方法，Go最终成为了一个非常好的通用语言，这有点出乎我们意料。我想大多数用户并没有实际从系统观点来考虑过它，尽管很多人做过一点Web服务器或类似东西。\n\nGo用来做很多应用类的东西也非常不错，它将会有更好的函数库，越来越多的工具以及一些Go更有用的东西，Go是一个非常好的通用语言，它是我用过的最高产的语言。\n"
        },
        {
          "name": "Uber Go 语言编码规范中文版.md",
          "type": "blob",
          "size": 73.103515625,
          "content": "<!--\n\nEditing this document:\n\n- Discuss all changes in GitHub issues first.\n- Update the table of contents as new sections are added or removed.\n- Use tables for side-by-side code samples. See below.\n\nCode Samples:\n\nUse 2 spaces to indent. Horizontal real estate is important in side-by-side\nsamples.\n\nFor side-by-side code samples, use the following snippet.\n\n~~~\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nBAD CODE GOES HERE\n```\n\n</td><td>\n\n```go\nGOOD CODE GOES HERE\n```\n\n</td></tr>\n</tbody></table>\n~~~\n\n(You need the empty lines between the <td> and code samples for it to be\ntreated as Markdown.)\n\nIf you need to add labels or descriptions below the code samples, add another\nrow before the </tbody></table> line.\n\n~~~\n<tr>\n<td>DESCRIBE BAD CODE</td>\n<td>DESCRIBE GOOD CODE</td>\n</tr>\n~~~\n\n\n\n-->\n\n<!--\nchange.md\n\n# 2019-12-17\n- 函数选项：推荐 “Option” 接口的结构实现\n- 而不是用闭包捕获值。\n\n# 2019-11-26\n- 添加针对全局变量变异的指导。\n\n# 2020-01-11\n- 为`open（..）`调用添加缺少的参数。\n\n# 2020-02-03\n- 使用 `\"time\"` 处理时间的建议\n- 添加有关在公共结构中嵌入类型的指导。\n\n# 2020-02-25\n- 添加有关接口验证是否符合编译时检查的指导。\n\n# 2020-06-05\n- 添加避免使用内置名称的指导意见\n\n# 2020-06-10\n- 添加 init() 指导意见\n\n# 2020-06-16\n- 追加时优先指定切片容量\n- 添加有关指针接收器可调用性的说明\n\n# 2020-06-17\n- map和切片的联合指导\n\n# 2020-09-15\n- Remove main panic\n\n# 2021-03-17\n- 结构体初始化\n\n# 2021-04-19\n- 程序只能在`main()`中退出，最好最多退出一次\n\n-->\n\n## forked from [uber_go_guide_cn](https://github.com/xxjwxc/uber_go_guide_cn)\n\n## [uber-go/guide](https://github.com/uber-go/guide) 的中文翻译\n\n## [English](https://github.com/uber-go/guide/blob/master/style.md)\n\n## Uber Go 语言编码规范\n\n [Uber](https://www.uber.com/) 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 [zap](https://github.com/uber-go/zap)、[jaeger](https://github.com/jaegertracing/jaeger) 等。2018 年年末 Uber 将内部的 [Go 风格规范](https://github.com/uber-go/guide) 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。\n\n ## 版本\n\n  - 当前更新版本：2021-07-09 版本地址：[commit:#130](https://github.com/uber-go/guide/commit/b8745282405323881e13cd122d5222316a815349)\n\n## 目录\n\n- [uber-go/guide 的中文翻译](#uber-goguide-的中文翻译)\n- [English](#english)\n- [Uber Go 语言编码规范](#uber-go-语言编码规范)\n- [版本](#版本)\n- [目录](#目录)\n- [介绍](#介绍)\n- [指导原则](#指导原则)\n  - [指向 interface 的指针](#指向-interface-的指针)\n  - [Interface 合理性验证](#interface-合理性验证)\n  - [接收器 (receiver) 与接口](#接收器-receiver-与接口)\n  - [零值 Mutex 是有效的](#零值-mutex-是有效的)\n  - [在边界处拷贝 Slices 和 Maps](#在边界处拷贝-slices-和-maps)\n    - [接收 Slices 和 Maps](#接收-slices-和-maps)\n    - [返回 slices 或 maps](#返回-slices-或-maps)\n  - [使用 defer 释放资源](#使用-defer-释放资源)\n  - [Channel 的 size 要么是 1，要么是无缓冲的](#channel-的-size-要么是-1要么是无缓冲的)\n  - [枚举从 1 开始](#枚举从-1-开始)\n  - [使用 time 处理时间](#使用-time-处理时间)\n    - [使用 `time.Time` 表达瞬时时间](#使用-timetime-表达瞬时时间)\n    - [使用 `time.Duration` 表达时间段](#使用-timeduration-表达时间段)\n    - [对外部系统使用 `time.Time` 和 `time.Duration`](#对外部系统使用-timetime-和-timeduration)\n  - [错误类型](#错误类型)\n  - [错误包装 (Error Wrapping)](#错误包装-error-wrapping)\n  - [处理类型断言失败](#处理类型断言失败)\n  - [不要 panic](#不要-panic)\n  - [使用 go.uber.org/atomic](#使用-gouberorgatomic)\n  - [避免可变全局变量](#避免可变全局变量)\n  - [避免在公共结构中嵌入类型](#避免在公共结构中嵌入类型)\n  - [避免使用内置名称](#避免使用内置名称)\n  - [避免使用 `init()`](#避免使用-init)\n  - [追加时优先指定切片容量](#追加时优先指定切片容量)\n  - [主函数退出方式(Exit)](#主函数退出方式exit)\n    - [一次性退出](#一次性退出)\n- [性能](#性能)\n  - [优先使用 strconv 而不是 fmt](#优先使用-strconv-而不是-fmt)\n  - [避免字符串到字节的转换](#避免字符串到字节的转换)\n  - [指定容器容量](#指定容器容量)\n    - [指定Map容量提示](#指定map容量提示)\n    - [指定切片容量](#指定切片容量)\n- [规范](#规范)\n  - [一致性](#一致性)\n  - [相似的声明放在一组](#相似的声明放在一组)\n  - [import 分组](#import-分组)\n  - [包名](#包名)\n  - [函数名](#函数名)\n  - [导入别名](#导入别名)\n  - [函数分组与顺序](#函数分组与顺序)\n  - [减少嵌套](#减少嵌套)\n  - [不必要的 else](#不必要的-else)\n  - [顶层变量声明](#顶层变量声明)\n  - [对于未导出的顶层常量和变量，使用_作为前缀](#对于未导出的顶层常量和变量使用_作为前缀)\n  - [结构体中的嵌入](#结构体中的嵌入)\n  - [使用字段名初始化结构体](#使用字段名初始化结构体)\n  - [本地变量声明](#本地变量声明)\n  - [nil 是一个有效的 slice](#nil-是一个有效的-slice)\n  - [缩小变量作用域](#缩小变量作用域)\n  - [避免参数语义不明确(Avoid Naked Parameters)](#避免参数语义不明确avoid-naked-parameters)\n  - [使用原始字符串字面值，避免转义](#使用原始字符串字面值避免转义)\n  - [初始化结构体](#初始化结构体)\n    - [使用字段名初始化结构](#使用字段名初始化结构)\n    - [省略结构中的零值字段](#省略结构中的零值字段)\n    - [对零值结构使用 `var`](#对零值结构使用-var)\n    - [初始化 Struct 引用](#初始化-struct-引用)\n  - [初始化 Maps](#初始化-maps)\n  - [字符串 string format](#字符串-string-format)\n  - [命名 Printf 样式的函数](#命名-printf-样式的函数)\n- [编程模式](#编程模式)\n  - [表驱动测试](#表驱动测试)\n  - [功能选项](#功能选项)\n- [Linting](#linting)\n  - [Lint Runners](#lint-runners)\n- [Stargazers over time](#stargazers-over-time)\n\n## 介绍\n\n样式 (style) 是支配我们代码的惯例。术语`样式`有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。\n\n本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。\n\n该指南最初由 [Prashant Varanasi] 和 [Simon Newton] 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。\n\n[Prashant Varanasi]: https://github.com/prashantv\n[Simon Newton]: https://github.com/nomis52\n\n本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：\n\n1. [Effective Go](https://golang.org/doc/effective_go.html)\n2. [Go Common Mistakes](https://github.com/golang/go/wiki/CommonMistakes)\n3. [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)\n\n\n所有代码都应该通过`golint`和`go vet`的检查并无错误。我们建议您将编辑器设置为：\n\n- 保存时运行 `goimports`\n- 运行 `golint` 和 `go vet` 检查错误\n\n您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：\n<https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins>\n\n## 指导原则\n\n### 指向 interface 的指针\n\n您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。\n\n接口实质上在底层用两个字段表示：\n\n1. 一个指向某些特定类型信息的指针。您可以将其视为\"type\"。\n2. 数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。\n\n如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。\n\n```go\ntype F interface {\n  f()\n}\n\ntype S1 struct{}\n\nfunc (s S1) f() {}\n\ntype S2 struct{}\n\nfunc (s *S2) f() {}\n\n// f1.f()无法修改底层数据\n// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针\nvar f1 F = S1{}\nvar f2 F = &S2{}\n```\n\n### Interface 合理性验证\n\n在编译时验证接口的符合性。这包括：\n\n- 将实现特定接口的导出类型作为接口API 的一部分进行检查\n- 实现同一接口的(导出和非导出)类型属于实现类型的集合\n- 任何违反接口合理性检查的场景,都会终止编译,并通知给用户\n\n补充:上面3条是编译器对接口的检查机制,\n大体意思是错误使用接口会在编译期报错.\n所以可以利用这个机制让部分问题在编译期暴露.\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// 如果Handler没有实现http.Handler,会在运行时报错\ntype Handler struct {\n  // ...\n}\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  ...\n}\n```\n\n</td><td>\n\n```go\ntype Handler struct {\n  // ...\n}\n// 用于触发编译期的接口的合理性检查机制\n// 如果Handler没有实现http.Handler,会在编译期报错\nvar _ http.Handler = (*Handler)(nil)\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n```\n\n</td></tr>\n</tbody></table>\n\n如果 `*Handler` 与 `http.Handler` 的接口不匹配,\n那么语句 `var _ http.Handler = (*Handler)(nil)` 将无法编译通过.\n\n赋值的右边应该是断言类型的零值。\n对于指针类型（如 `*Handler`）、切片和映射，这是 `nil`；\n对于结构类型，这是空结构。\n\n```go\ntype LogHandler struct {\n  h   http.Handler\n  log *zap.Logger\n}\nvar _ http.Handler = LogHandler{}\nfunc (h LogHandler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n```\n\n### 接收器 (receiver) 与接口\n\n使用值接收器的方法既可以通过值调用，也可以通过指针调用。\n\n带指针接收器的方法只能通过指针或 [addressable values]调用.\n\n[addressable values]: https://golang.org/ref/spec#Method_values\n\n例如，\n\n```go\ntype S struct {\n  data string\n}\n\nfunc (s S) Read() string {\n  return s.data\n}\n\nfunc (s *S) Write(str string) {\n  s.data = str\n}\n\nsVals := map[int]S{1: {\"A\"}}\n\n// 你只能通过值调用 Read\nsVals[1].Read()\n\n// 这不能编译通过：\n//  sVals[1].Write(\"test\")\n\nsPtrs := map[int]*S{1: {\"A\"}}\n\n// 通过指针既可以调用 Read，也可以调用 Write 方法\nsPtrs[1].Read()\nsPtrs[1].Write(\"test\")\n```\n\n类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.\n\n```go\ntype F interface {\n  f()\n}\n\ntype S1 struct{}\n\nfunc (s S1) f() {}\n\ntype S2 struct{}\n\nfunc (s *S2) f() {}\n\ns1Val := S1{}\ns1Ptr := &S1{}\ns2Val := S2{}\ns2Ptr := &S2{}\n\nvar i F\ni = s1Val\ni = s1Ptr\ni = s2Ptr\n\n//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器\n//   i = s2Val\n```\n\n[Effective Go](https://golang.org/doc/effective_go.html) 中有一段关于 [pointers vs. values](https://golang.org/doc/effective_go.html#pointers_vs_values) 的精彩讲解。\n\n补充:\n\n- 一个类型可以有值接收器方法集和指针接收器方法集\n  - 值接收器方法集是指针接收器方法集的子集,反之不是\n- 规则\n  - 值对象只可以使用值接收器方法集\n  - 指针对象可以使用 值接收器方法集 + 指针接收器方法集\n- 接口的匹配(或者叫实现)\n  - 类型实现了接口的所有方法,叫匹配\n  - 具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口\n\n具体的匹配分两种:\n\n- 值方法集和接口匹配\n  - 给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集\n- 指针方法集和接口匹配\n  - 只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配\n  - 如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)\n\n为啥 i = s2Val 会报错,因为值方法集和接口不匹配.\n\n### 零值 Mutex 是有效的\n\n零值 `sync.Mutex` 和 `sync.RWMutex` 是有效的。所以指向 mutex 的指针基本是不必要的。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nmu := new(sync.Mutex)\nmu.Lock()\n```\n\n</td><td>\n\n```go\nvar mu sync.Mutex\nmu.Lock()\n```\n\n</td></tr>\n</tbody></table>\n\n如果你使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype SMap struct {\n  sync.Mutex\n\n  data map[string]string\n}\n\nfunc NewSMap() *SMap {\n  return &SMap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *SMap) Get(k string) string {\n  m.Lock()\n  defer m.Unlock()\n\n  return m.data[k]\n}\n```\n\n</td><td>\n\n```go\ntype SMap struct {\n  mu sync.Mutex\n\n  data map[string]string\n}\n\nfunc NewSMap() *SMap {\n  return &SMap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *SMap) Get(k string) string {\n  m.mu.Lock()\n  defer m.mu.Unlock()\n\n  return m.data[k]\n}\n```\n\n</td></tr>\n<tr><td>\n\n`Mutex` 字段， `Lock` 和 `Unlock` 方法是 `SMap` 导出的 API 中不刻意说明的一部分。\n\n </td><td>\n\nmutex 及其方法是 `SMap` 的实现细节，对其调用者不可见。\n\n </td></tr>\n </tbody></table>\n\n### 在边界处拷贝 Slices 和 Maps\n\nslices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。\n\n#### 接收 Slices 和 Maps\n\n请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。\n\n<table>\n<thead><tr><th>Bad</th> <th>Good</th></tr></thead>\n<tbody>\n<tr>\n<td>\n\n```go\nfunc (d *Driver) SetTrips(trips []Trip) {\n  d.trips = trips\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// 你是要修改 d1.trips 吗？\ntrips[0] = ...\n```\n\n</td>\n<td>\n\n```go\nfunc (d *Driver) SetTrips(trips []Trip) {\n  d.trips = make([]Trip, len(trips))\n  copy(d.trips, trips)\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// 这里我们修改 trips[0]，但不会影响到 d1.trips\ntrips[0] = ...\n```\n\n</td>\n</tr>\n\n</tbody>\n</table>\n\n#### 返回 slices 或 maps\n\n同样，请注意用户对暴露内部状态的 map 或 slice 的修改。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype Stats struct {\n  mu sync.Mutex\n\n  counters map[string]int\n}\n\n// Snapshot 返回当前状态。\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  return s.counters\n}\n\n// snapshot 不再受互斥锁保护\n// 因此对 snapshot 的任何访问都将受到数据竞争的影响\n// 影响 stats.counters\nsnapshot := stats.Snapshot()\n```\n\n</td><td>\n\n```go\ntype Stats struct {\n  mu sync.Mutex\n\n  counters map[string]int\n}\n\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  result := make(map[string]int, len(s.counters))\n  for k, v := range s.counters {\n    result[k] = v\n  }\n  return result\n}\n\n// snapshot 现在是一个拷贝\nsnapshot := stats.Snapshot()\n```\n\n</td></tr>\n</tbody></table>\n\n### 使用 defer 释放资源\n\n使用 defer 释放资源，诸如文件和锁。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\np.Lock()\nif p.count < 10 {\n  p.Unlock()\n  return p.count\n}\n\np.count++\nnewCount := p.count\np.Unlock()\n\nreturn newCount\n\n// 当有多个 return 分支时，很容易遗忘 unlock\n```\n\n</td><td>\n\n```go\np.Lock()\ndefer p.Unlock()\n\nif p.count < 10 {\n  return p.count\n}\n\np.count++\nreturn p.count\n\n// 更可读\n```\n\n</td></tr>\n</tbody></table>\n\nDefer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 `defer`。\n\n### Channel 的 size 要么是 1，要么是无缓冲的\n\nchannel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// 应该足以满足任何情况！\nc := make(chan int, 64)\n```\n\n</td><td>\n\n```go\n// 大小：1\nc := make(chan int, 1) // 或者\n// 无缓冲 channel，大小为 0\nc := make(chan int)\n```\n\n</td></tr>\n</tbody></table>\n\n### 枚举从 1 开始\n\n在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype Operation int\n\nconst (\n  Add Operation = iota\n  Subtract\n  Multiply\n)\n\n// Add=0, Subtract=1, Multiply=2\n```\n\n</td><td>\n\n```go\ntype Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\n// Add=1, Subtract=2, Multiply=3\n```\n\n</td></tr>\n</tbody></table>\n\n在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。\n\n```go\ntype LogOutput int\n\nconst (\n  LogToStdout LogOutput = iota\n  LogToFile\n  LogToRemote\n)\n\n// LogToStdout=0, LogToFile=1, LogToRemote=2\n```\n\n### 使用 time 处理时间\n\n时间处理很复杂。关于时间的错误假设通常包括以下几点。\n\n1. 一天有 24 小时\n2. 一小时有 60 分钟\n3. 一周有七天\n4. 一年 365 天\n5. [还有更多](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time)\n\n例如，*1* 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。\n\n因此，在处理时间时始终使用 [`\"time\"`] 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。\n\n[`\"time\"`]: https://golang.org/pkg/time/\n\n#### 使用 `time.Time` 表达瞬时时间\n\n在处理时间的瞬间时使用 [`time.Time`]，在比较、添加或减去时间时使用 `time.Time` 中的方法。\n\n[`time.Time`]: https://golang.org/pkg/time/#Time\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc isActive(now, start, stop int) bool {\n  return start <= now && now < stop\n}\n```\n\n</td><td>\n\n```go\nfunc isActive(now, start, stop time.Time) bool {\n  return (start.Before(now) || start.Equal(now)) && now.Before(stop)\n}\n```\n\n</td></tr>\n</tbody></table>\n\n#### 使用 `time.Duration` 表达时间段\n\n在处理时间段时使用 [`time.Duration`] .\n\n[`time.Duration`]: https://golang.org/pkg/time/#Duration\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc poll(delay int) {\n  for {\n    // ...\n    time.Sleep(time.Duration(delay) * time.Millisecond)\n  }\n}\npoll(10) // 是几秒钟还是几毫秒?\n```\n\n</td><td>\n\n```go\nfunc poll(delay time.Duration) {\n  for {\n    // ...\n    time.Sleep(delay)\n  }\n}\npoll(10*time.Second)\n```\n\n</td></tr>\n</tbody></table>\n\n回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 [`Time.AddDate`]。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 [`Time.Add`]。\n\n[`Time.AddDate`]: https://golang.org/pkg/time/#Time.AddDate\n[`Time.Add`]: https://golang.org/pkg/time/#Time.Add\n\n```go\nnewDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)\nmaybeNewDay := t.Add(24 * time.Hour)\n```\n\n#### 对外部系统使用 `time.Time` 和 `time.Duration` \n\n尽可能在与外部系统的交互中使用 `time.Duration` 和 `time.Time` 例如 :\n\n- Command-line 标志: [`flag`] 通过 [`time.ParseDuration`] 支持 `time.Duration`\n- JSON: [`encoding/json`] 通过其 [`UnmarshalJSON` method] 方法支持将 `time.Time` 编码为 [RFC 3339] 字符串\n- SQL: [`database/sql`] 支持将 `DATETIME` 或 `TIMESTAMP` 列转换为 `time.Time`，如果底层驱动程序支持则返回\n- YAML: [`gopkg.in/yaml.v2`] 支持将 `time.Time` 作为 [RFC 3339] 字符串，并通过 [`time.ParseDuration`] 支持 `time.Duration`。\n\n  [`flag`]: https://golang.org/pkg/flag/\n  [`time.ParseDuration`]: https://golang.org/pkg/time/#ParseDuration\n  [`encoding/json`]: https://golang.org/pkg/encoding/json/\n  [RFC 3339]: https://tools.ietf.org/html/rfc3339\n  [`UnmarshalJSON` method]: https://golang.org/pkg/time/#Time.UnmarshalJSON\n  [`database/sql`]: https://golang.org/pkg/database/sql/\n  [`gopkg.in/yaml.v2`]: https://godoc.org/gopkg.in/yaml.v2\n\n当不能在这些交互中使用 `time.Duration` 时，请使用 `int` 或 `float64`，并在字段名称中包含单位。\n\n例如，由于 `encoding/json` 不支持 `time.Duration`，因此该单位包含在字段的名称中。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// {\"interval\": 2}\ntype Config struct {\n  Interval int `json:\"interval\"`\n}\n```\n\n</td><td>\n\n```go\n// {\"intervalMillis\": 2000}\ntype Config struct {\n  IntervalMillis int `json:\"intervalMillis\"`\n}\n```\n\n</td></tr>\n</tbody></table>\n\n当在这些交互中不能使用 `time.Time` 时，除非达成一致，否则使用 `string` 和 [RFC 3339] 中定义的格式时间戳。默认情况下，[`Time.UnmarshalText`] 使用此格式，并可通过 [`time.RFC3339`] 在 `Time.Format` 和 `time.Parse` 中使用。\n\n[`Time.UnmarshalText`]: https://golang.org/pkg/time/#Time.UnmarshalText\n[`time.RFC3339`]: https://golang.org/pkg/time/#RFC3339\n\n尽管这在实践中并不成问题，但请记住，`\"time\"` 包不支持解析闰秒时间戳（[8728]），也不在计算中考虑闰秒（[15190]）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。\n\n[8728]: https://github.com/golang/go/issues/8728\n[15190]: https://github.com/golang/go/issues/15190\n\n<!-- TODO: section on String methods for enums -->\n\n### 错误类型\n\nGo 中有多种声明错误（Error) 的选项：\n\n- [`errors.New`] 对于简单静态字符串的错误\n- [`fmt.Errorf`] 用于格式化的错误字符串\n- 实现 `Error()` 方法的自定义类型\n-  用 [`\"pkg/errors\".Wrap`] 的 Wrapped errors\n\n返回错误时，请考虑以下因素以确定最佳选择：\n\n- 这是一个不需要额外信息的简单错误吗？如果是这样，[`errors.New`] 足够了。\n- 客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 `Error()` 方法。\n- 您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 [section on error wrapping](#错误包装 (Error-Wrapping)) 部分的内容。\n- 否则 [`fmt.Errorf`] 就可以了。\n\n  [`errors.New`]: https://golang.org/pkg/errors/#New\n  [`fmt.Errorf`]: https://golang.org/pkg/fmt/#Errorf\n  [`\"pkg/errors\".Wrap`]: https://godoc.org/github.com/pkg/errors#Wrap\n\n如果客户端需要检测错误，并且您已使用创建了一个简单的错误 [`errors.New`]，请使用一个错误变量。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// package foo\n\nfunc Open() error {\n  return errors.New(\"could not open\")\n}\n\n// package bar\n\nfunc use() {\n  if err := foo.Open(); err != nil {\n    if err.Error() == \"could not open\" {\n      // handle\n    } else {\n      panic(\"unknown error\")\n    }\n  }\n}\n```\n\n</td><td>\n\n```go\n// package foo\n\nvar ErrCouldNotOpen = errors.New(\"could not open\")\n\nfunc Open() error {\n  return ErrCouldNotOpen\n}\n\n// package bar\n\nif err := foo.Open(); err != nil {\n  if errors.Is(err, foo.ErrCouldNotOpen) {\n    // handle\n  } else {\n    panic(\"unknown error\")\n  }\n}\n```\n\n</td></tr>\n</tbody></table>\n\n如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc open(file string) error {\n  return fmt.Errorf(\"file %q not found\", file)\n}\n\nfunc use() {\n  if err := open(\"testfile.txt\"); err != nil {\n    if strings.Contains(err.Error(), \"not found\") {\n      // handle\n    } else {\n      panic(\"unknown error\")\n    }\n  }\n}\n```\n\n</td><td>\n\n```go\ntype errNotFound struct {\n  file string\n}\n\nfunc (e errNotFound) Error() string {\n  return fmt.Sprintf(\"file %q not found\", e.file)\n}\n\nfunc open(file string) error {\n  return errNotFound{file: file}\n}\n\nfunc use() {\n  if err := open(\"testfile.txt\"); err != nil {\n    if _, ok := err.(errNotFound); ok {\n      // handle\n    } else {\n      panic(\"unknown error\")\n    }\n  }\n}\n```\n\n</td></tr>\n</tbody></table>\n\n直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。\n\n```go\n// package foo\n\ntype errNotFound struct {\n  file string\n}\n\nfunc (e errNotFound) Error() string {\n  return fmt.Sprintf(\"file %q not found\", e.file)\n}\n\nfunc IsNotFoundError(err error) bool {\n  _, ok := err.(errNotFound)\n  return ok\n}\n\nfunc Open(file string) error {\n  return errNotFound{file: file}\n}\n\n// package bar\n\nif err := foo.Open(\"foo\"); err != nil {\n  if foo.IsNotFoundError(err) {\n    // handle\n  } else {\n    panic(\"unknown error\")\n  }\n}\n```\n\n<!-- TODO: Exposing the information to callers with accessor functions. -->\n\n### 错误包装 (Error Wrapping)\n\n一个（函数/方法）调用失败时，有三种主要的错误传播方式：\n\n- 如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。\n- 添加上下文，使用 [`\"pkg/errors\".Wrap`] 以便错误消息提供更多上下文 ,[`\"pkg/errors\".Cause`] 可用于提取原始错误。\n- 如果调用者不需要检测或处理的特定错误情况，使用 [`fmt.Errorf`]。\n\n建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。\n\n在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ns, err := store.New()\nif err != nil {\n    return fmt.Errorf(\n        \"failed to create new store: %v\", err)\n}\n```\n\n</td><td>\n\n```go\ns, err := store.New()\nif err != nil {\n    return fmt.Errorf(\n        \"new store: %v\", err)\n}\n```\n\n<tr><td>\n\n```\nfailed to x: failed to y: failed to create new store: the error\n```\n\n</td><td>\n\n```\nx: y: new store: the error\n```\n\n</td></tr>\n</tbody></table>\n\n但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用`err`标记，或在日志中以”Failed”为前缀）。\n\n另请参见 [Don't just check errors, handle them gracefully]. 不要只是检查错误，要优雅地处理错误\n\n[`\"pkg/errors\".Cause`]: https://godoc.org/github.com/pkg/errors#Cause\n[Don't just check errors, handle them gracefully]: https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully\n\n### 处理类型断言失败\n\n[type assertion] 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。\n\n[type assertion]: https://golang.org/ref/spec#Type_assertions\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nt := i.(string)\n```\n\n</td><td>\n\n```go\nt, ok := i.(string)\nif !ok {\n  // 优雅地处理错误\n}\n```\n\n</td></tr>\n</tbody></table>\n\n<!-- TODO: There are a few situations where the single assignment form is\nfine. -->\n\n### 不要 panic\n\n在生产环境中运行的代码必须避免出现 panic。panic 是 [cascading failures] 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。\n\n[cascading failures]: https://en.wikipedia.org/wiki/Cascading_failure\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc run(args []string) {\n  if len(args) == 0 {\n    panic(\"an argument is required\")\n  }\n  // ...\n}\n\nfunc main() {\n  run(os.Args[1:])\n}\n```\n\n</td><td>\n\n```go\nfunc run(args []string) error {\n  if len(args) == 0 {\n    return errors.New(\"an argument is required\")\n  }\n  // ...\n  return nil\n}\n\nfunc main() {\n  if err := run(os.Args[1:]); err != nil {\n    fmt.Fprintln(os.Stderr, err)\n    os.Exit(1)\n  }\n}\n```\n\n</td></tr>\n</tbody></table>\n\npanic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。\n\n```go\nvar _statusTemplate = template.Must(template.New(\"name\").Parse(\"_statusHTML\"))\n```\n\n即使在测试代码中，也优先使用`t.Fatal`或者`t.FailNow`而不是 panic 来确保失败被标记。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile(\"\", \"test\")\nif err != nil {\n  panic(\"failed to set up test\")\n}\n```\n\n</td><td>\n\n```go\n// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile(\"\", \"test\")\nif err != nil {\n  t.Fatal(\"failed to set up test\")\n}\n```\n\n</td></tr>\n</tbody></table>\n\n<!-- TODO: Explain how to use _test packages. -->\n\n### 使用 go.uber.org/atomic\n\n使用 [sync/atomic] 包的原子操作对原始类型 (`int32`, `int64`等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。\n\n[go.uber.org/atomic] 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的`atomic.Bool`类型。\n\n[go.uber.org/atomic]: https://godoc.org/go.uber.org/atomic\n[sync/atomic]: https://golang.org/pkg/sync/atomic/\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype foo struct {\n  running int32  // atomic\n}\n\nfunc (f* foo) start() {\n  if atomic.SwapInt32(&f.running, 1) == 1 {\n     // already running…\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running == 1  // race!\n}\n```\n\n</td><td>\n\n```go\ntype foo struct {\n  running atomic.Bool\n}\n\nfunc (f *foo) start() {\n  if f.running.Swap(true) {\n     // already running…\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running.Load()\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### 避免可变全局变量\n\n使用选择依赖注入方式避免改变全局变量。 \n既适用于函数指针又适用于其他值类型\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// sign.go\nvar _timeNow = time.Now\nfunc sign(msg string) string {\n  now := _timeNow()\n  return signWithTime(msg, now)\n}\n```\n\n</td><td>\n\n```go\n// sign.go\ntype signer struct {\n  now func() time.Time\n}\nfunc newSigner() *signer {\n  return &signer{\n    now: time.Now,\n  }\n}\nfunc (s *signer) Sign(msg string) string {\n  now := s.now()\n  return signWithTime(msg, now)\n}\n```\n</td></tr>\n<tr><td>\n\n```go\n// sign_test.go\nfunc TestSign(t *testing.T) {\n  oldTimeNow := _timeNow\n  _timeNow = func() time.Time {\n    return someFixedTime\n  }\n  defer func() { _timeNow = oldTimeNow }()\n  assert.Equal(t, want, sign(give))\n}\n```\n\n</td><td>\n\n```go\n// sign_test.go\nfunc TestSigner(t *testing.T) {\n  s := newSigner()\n  s.now = func() time.Time {\n    return someFixedTime\n  }\n  assert.Equal(t, want, s.Sign(give))\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### 避免在公共结构中嵌入类型\n\n这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。\n\n假设您使用共享的 `AbstractList` 实现了多种列表类型，请避免在具体的列表实现中嵌入 `AbstractList`。\n相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。\n\n```go\ntype AbstractList struct {}\n// 添加将实体添加到列表中。\nfunc (l *AbstractList) Add(e Entity) {\n  // ...\n}\n// 移除从列表中移除实体。\nfunc (l *AbstractList) Remove(e Entity) {\n  // ...\n}\n```\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// ConcreteList 是一个实体列表。\ntype ConcreteList struct {\n  *AbstractList\n}\n```\n\n</td><td>\n\n```go\n// ConcreteList 是一个实体列表。\ntype ConcreteList struct {\n  list *AbstractList\n}\n// 添加将实体添加到列表中。\nfunc (l *ConcreteList) Add(e Entity) {\n  l.list.Add(e)\n}\n// 移除从列表中移除实体。\nfunc (l *ConcreteList) Remove(e Entity) {\n  l.list.Remove(e)\n}\n```\n\n</td></tr>\n</tbody></table>\n\nGo 允许 [类型嵌入] 作为继承和组合之间的折衷。\n外部类型获取嵌入类型的方法的隐式副本。\n默认情况下，这些方法委托给嵌入实例的同一方法。\n\n[类型嵌入]: https://golang.org/doc/effective_go.html#embedding\n\n结构还获得与类型同名的字段。\n所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。\n\n很少需要嵌入类型。\n这是一种方便，可以帮助您避免编写冗长的委托方法。\n\n即使嵌入兼容的抽象列表 *interface*，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// AbstractList 是各种实体列表的通用实现。\ntype AbstractList interface {\n  Add(Entity)\n  Remove(Entity)\n}\n// ConcreteList 是一个实体列表。\ntype ConcreteList struct {\n  AbstractList\n}\n```\n\n</td><td>\n\n```go\n// ConcreteList 是一个实体列表。\ntype ConcreteList struct {\n  list AbstractList\n}\n// 添加将实体添加到列表中。\nfunc (l *ConcreteList) Add(e Entity) {\n  l.list.Add(e)\n}\n// 移除从列表中移除实体。\nfunc (l *ConcreteList) Remove(e Entity) {\n  l.list.Remove(e)\n}\n```\n\n</td></tr>\n</tbody></table>\n\n无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.\n\n- 向嵌入式接口添加方法是一个破坏性的改变。\n- 删除嵌入类型是一个破坏性的改变。\n- 即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。\n\n尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。\n\n### 避免使用内置名称\n\nGo语言规范[language specification] 概述了几个内置的，\n不应在Go项目中使用的名称标识[predeclared identifiers]。\n\n根据上下文的不同，将这些标识符作为名称重复使用，\n将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。\n在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。\n\n[language specification]: https://golang.org/ref/spec\n[predeclared identifiers]: https://golang.org/ref/spec#Predeclared_identifiers\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nvar error string\n// `error` 作用域隐式覆盖\n\n// or\n\nfunc handleErrorMessage(error string) {\n    // `error` 作用域隐式覆盖\n}\n```\n\n</td><td>\n\n```go\nvar errorMessage string\n// `error` 指向内置的非覆盖\n\n// or\n\nfunc handleErrorMessage(msg string) {\n    // `error` 指向内置的非覆盖\n}\n```\n\n</td></tr>\n<tr><td>\n\n```go\ntype Foo struct {\n    // 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。\n    error  error\n    string string\n}\n\nfunc (f Foo) Error() error {\n    // `error` 和 `f.error` 在视觉上是相似的\n    return f.error\n}\n\nfunc (f Foo) String() string {\n    // `string` and `f.string` 在视觉上是相似的\n    return f.string\n}\n```\n\n</td><td>\n\n```go\ntype Foo struct {\n    // `error` and `string` 现在是明确的。\n    err error\n    str string\n}\n\nfunc (f Foo) Error() error {\n    return f.err\n}\n\nfunc (f Foo) String() string {\n    return f.str\n}\n```\n</td></tr>\n</tbody></table>\n\n注意，编译器在使用预先分隔的标识符时不会生成错误，\n但是诸如`go vet`之类的工具会正确地指出这些和其他情况下的隐式问题。\n\n### 避免使用 `init()`\n\n尽可能避免使用`init()`。当`init()`是不可避免或可取的，代码应先尝试：\n\n1. 无论程序环境或调用如何，都要完全确定。\n2. 避免依赖于其他`init()`函数的顺序或副作用。虽然`init()`顺序是明确的，但代码可以更改，\n因此`init()`函数之间的关系可能会使代码变得脆弱和容易出错。\n3. 避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。\n4. 避免`I/O`，包括文件系统、网络和系统调用。\n\n不能满足这些要求的代码可能属于要作为`main()`调用的一部分（或程序生命周期中的其他地方），\n或者作为`main()`本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，\n而不是执行“init magic”\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype Foo struct {\n    // ...\n}\nvar _defaultFoo Foo\nfunc init() {\n    _defaultFoo = Foo{\n        // ...\n    }\n}\n```\n\n</td><td>\n\n```go\nvar _defaultFoo = Foo{\n    // ...\n}\n// or, 为了更好的可测试性:\nvar _defaultFoo = defaultFoo()\nfunc defaultFoo() Foo {\n    return Foo{\n        // ...\n    }\n}\n```\n\n</td></tr>\n<tr><td>\n\n```go\ntype Config struct {\n    // ...\n}\nvar _config Config\nfunc init() {\n    // Bad: 基于当前目录\n    cwd, _ := os.Getwd()\n    // Bad: I/O\n    raw, _ := ioutil.ReadFile(\n        path.Join(cwd, \"config\", \"config.yaml\"),\n    )\n    yaml.Unmarshal(raw, &_config)\n}\n```\n\n</td><td>\n\n```go\ntype Config struct {\n    // ...\n}\nfunc loadConfig() Config {\n    cwd, err := os.Getwd()\n    // handle err\n    raw, err := ioutil.ReadFile(\n        path.Join(cwd, \"config\", \"config.yaml\"),\n    )\n    // handle err\n    var config Config\n    yaml.Unmarshal(raw, &config)\n    return config\n}\n```\n\n</td></tr>\n</tbody></table>\n\n考虑到上述情况，在某些情况下，`init()`可能更可取或是必要的，可能包括：\n\n- 不能表示为单个赋值的复杂表达式。\n- 可插入的钩子，如`database/sql`、编码类型注册表等。\n- 对[Google Cloud Functions]和其他形式的确定性预计算的优化。\n\n  [Google Cloud Functions]: https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations\n\n### 追加时优先指定切片容量\n\n追加时优先指定切片容量\n\n在尽可能的情况下，在初始化要追加的切片时为`make()`提供一个容量值。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfor n := 0; n < b.N; n++ {\n  data := make([]int, 0)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n```\n\n</td><td>\n\n```go\nfor n := 0; n < b.N; n++ {\n  data := make([]int, 0, size)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n```\n\n</td></tr>\n<tr><td>\n\n```\nBenchmarkBad-4    100000000    2.48s\n```\n\n</td><td>\n\n```\nBenchmarkGood-4   100000000    0.21s\n```\n\n</td></tr>\n</tbody></table>\n\n### 主函数退出方式(Exit)\n\nGo程序使用[`os.Exit`] 或者 [`log.Fatal*`] 立即退出 (使用`panic`不是退出程序的好方法，请 [don't panic](#不要-panic).)\n\n  [`os.Exit`]: https://golang.org/pkg/os/#Exit\n  [`log.Fatal*`]: https://golang.org/pkg/log/#Fatal\n\n**仅在`main（）`**中调用其中一个 `os.Exit` 或者 `log.Fatal*`。所有其他函数应将错误返回到信号失败中。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc main() {\n  body := readFile(path)\n  fmt.Println(body)\n}\nfunc readFile(path string) string {\n  f, err := os.Open(path)\n  if err != nil {\n    log.Fatal(err)\n  }\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    log.Fatal(err)\n  }\n  return string(b)\n}\n```\n\n</td><td>\n\n```go\nfunc main() {\n  body, err := readFile(path)\n  if err != nil {\n    log.Fatal(err)\n  }\n  fmt.Println(body)\n}\nfunc readFile(path string) (string, error) {\n  f, err := os.Open(path)\n  if err != nil {\n    return \"\", err\n  }\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    return \"\", err\n  }\n  return string(b), nil\n}\n```\n\n</td></tr>\n</tbody></table>\n\n原则上：退出的具有多种功能的程序存在一些问题：\n\n- 不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。\n- 难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 `go test` 尚未运行的其他测试的风险。\n- 跳过清理：当函数退出程序时，会跳过已经进入`defer`队列里的函数调用。这增加了跳过重要清理任务的风险。\n#### 一次性退出\n\n如果可能的话，你的`main（）`函数中**最多一次** 调用 `os.Exit`或者`log.Fatal`。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。\n这会缩短 `main()`函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\npackage main\nfunc main() {\n  args := os.Args[1:]\n  if len(args) != 1 {\n    log.Fatal(\"missing file\")\n  }\n  name := args[0]\n  f, err := os.Open(name)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer f.Close()\n  // 如果我们调用log.Fatal 在这条线之后\n  // f.Close 将会被执行.\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    log.Fatal(err)\n  }\n  // ...\n}\n```\n\n</td><td>\n\n```go\npackage main\nfunc main() {\n  if err := run(); err != nil {\n    log.Fatal(err)\n  }\n}\nfunc run() error {\n  args := os.Args[1:]\n  if len(args) != 1 {\n    return errors.New(\"missing file\")\n  }\n  name := args[0]\n  f, err := os.Open(name)\n  if err != nil {\n    return err\n  }\n  defer f.Close()\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    return err\n  }\n  // ...\n}\n```\n\n</td></tr>\n</tbody></table>\n\n## 性能\n\n性能方面的特定准则只适用于高频场景。\n\n### 优先使用 strconv 而不是 fmt\n\n将原语转换为字符串或从字符串转换时，`strconv`速度比`fmt`快。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfor i := 0; i < b.N; i++ {\n  s := fmt.Sprint(rand.Int())\n}\n```\n\n</td><td>\n\n```go\nfor i := 0; i < b.N; i++ {\n  s := strconv.Itoa(rand.Int())\n}\n```\n\n</td></tr>\n<tr><td>\n\n```\nBenchmarkFmtSprint-4    143 ns/op    2 allocs/op\n```\n\n</td><td>\n\n```\nBenchmarkStrconv-4    64.2 ns/op    1 allocs/op\n```\n\n</td></tr>\n</tbody></table>\n\n\n\n### 避免字符串到字节的转换\n\n不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfor i := 0; i < b.N; i++ {\n  w.Write([]byte(\"Hello world\"))\n}\n```\n\n</td><td>\n\n```go\ndata := []byte(\"Hello world\")\nfor i := 0; i < b.N; i++ {\n  w.Write(data)\n}\n```\n\n</tr>\n<tr><td>\n\n```\nBenchmarkBad-4   50000000   22.2 ns/op\n```\n\n</td><td>\n\n```\nBenchmarkGood-4  500000000   3.25 ns/op\n```\n\n</td></tr>\n</tbody></table>\n\n### 指定容器容量\n\n尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。\n\n#### 指定Map容量提示\n\n在尽可能的情况下，在使用 `make()` 初始化的时候提供容量信息\n\n```go\nmake(map[T1]T2, hint)\n```\n\n向`make()`提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。\n\n\n注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。\n因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nm := make(map[string]os.FileInfo)\n\nfiles, _ := ioutil.ReadDir(\"./files\")\nfor _, f := range files {\n    m[f.Name()] = f\n}\n```\n\n</td><td>\n\n```go\n\nfiles, _ := ioutil.ReadDir(\"./files\")\n\nm := make(map[string]os.FileInfo, len(files))\nfor _, f := range files {\n    m[f.Name()] = f\n}\n```\n\n</td></tr>\n<tr><td>\n\n`m` 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。\n\n</td><td>\n\n`m` 是有大小提示创建的；在运行时可能会有更少的分配。\n\n</td></tr>\n</tbody></table>\n\n#### 指定切片容量\n\n在尽可能的情况下，在使用`make()`初始化切片时提供容量信息，特别是在追加切片时。\n\n```go\nmake([]T, length, capacity)\n```\n\n与maps不同，slice capacity不是一个提示：编译器将为提供给`make()`的slice的容量分配足够的内存，\n这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfor n := 0; n < b.N; n++ {\n  data := make([]int, 0)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n```\n\n</td><td>\n\n```go\nfor n := 0; n < b.N; n++ {\n  data := make([]int, 0, size)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n```\n\n</td></tr>\n<tr><td>\n\n```\nBenchmarkBad-4    100000000    2.48s\n```\n\n</td><td>\n\n```\nBenchmarkGood-4   100000000    0.21s\n```\n\n</td></tr>\n</tbody></table>\n\n## 规范\n\n### 一致性\n\n本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；\n\n但是最重要的是，**保持一致**.\n\n一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug\n\n相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。\n\n将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。\n\n### 相似的声明放在一组\n\nGo 语言支持将相似的声明放在一个组内。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nimport \"a\"\nimport \"b\"\n```\n\n</td><td>\n\n```go\nimport (\n  \"a\"\n  \"b\"\n)\n```\n\n</td></tr>\n</tbody></table>\n\n这同样适用于常量、变量和类型声明：\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n\nconst a = 1\nconst b = 2\n\nvar a = 1\nvar b = 2\n\ntype Area float64\ntype Volume float64\n```\n\n</td><td>\n\n```go\nconst (\n  a = 1\n  b = 2\n)\n\nvar (\n  a = 1\n  b = 2\n)\n\ntype (\n  Area float64\n  Volume float64\n)\n```\n\n</td></tr>\n</tbody></table>\n\n仅将相关的声明放在一组。不要将不相关的声明放在一组。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n  EnvVar = \"MY_ENV\"\n)\n```\n\n</td><td>\n\n```go\ntype Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\nconst EnvVar = \"MY_ENV\"\n```\n\n</td></tr>\n</tbody></table>\n\n分组使用的位置没有限制，例如：你可以在函数内部使用它们：\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc f() string {\n  var red = color.New(0xff0000)\n  var green = color.New(0x00ff00)\n  var blue = color.New(0x0000ff)\n\n  ...\n}\n```\n\n</td><td>\n\n```go\nfunc f() string {\n  var (\n    red   = color.New(0xff0000)\n    green = color.New(0x00ff00)\n    blue  = color.New(0x0000ff)\n  )\n\n  ...\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### import 分组\n\n导入应该分为两组：\n\n- 标准库\n- 其他库\n\n默认情况下，这是 goimports 应用的分组。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nimport (\n  \"fmt\"\n  \"os\"\n  \"go.uber.org/atomic\"\n  \"golang.org/x/sync/errgroup\"\n)\n```\n\n</td><td>\n\n```go\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"go.uber.org/atomic\"\n  \"golang.org/x/sync/errgroup\"\n)\n```\n\n</td></tr>\n</tbody></table>\n\n### 包名\n\n当命名包时，请按下面规则选择一个名称：\n\n- 全部小写。没有大写或下划线。\n- 大多数使用命名导入的情况下，不需要重命名。\n- 简短而简洁。请记住，在每个使用的地方都完整标识了该名称。\n- 不用复数。例如`net/url`，而不是`net/urls`。\n- 不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。\n\n另请参阅 [Package Names] 和 [Go 包样式指南].\n\n[Package Names]: https://blog.golang.org/package-names\n[Go 包样式指南]: https://rakyll.org/style-packages/\n\n### 函数名\n\n我们遵循 Go 社区关于使用 [MixedCaps 作为函数名] 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：`TestMyFunction_WhatIsBeingTested`.\n\n[MixedCaps 作为函数名]: https://golang.org/doc/effective_go.html#mixed-caps\n\n### 导入别名\n\n如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。\n\n```go\nimport (\n  \"net/http\"\n\n  client \"example.com/client-go\"\n  trace \"example.com/trace/v2\"\n)\n```\n\n在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nimport (\n  \"fmt\"\n  \"os\"\n\n  nettrace \"golang.net/x/trace\"\n)\n```\n\n</td><td>\n\n```go\nimport (\n  \"fmt\"\n  \"os\"\n  \"runtime/trace\"\n\n  nettrace \"golang.net/x/trace\"\n)\n```\n\n</td></tr>\n</tbody></table>\n\n### 函数分组与顺序\n\n- 函数应按粗略的调用顺序排序。\n- 同一文件中的函数应按接收者分组。\n\n因此，导出的函数应先出现在文件中，放在`struct`, `const`, `var`定义的后面。\n\n在定义类型之后，但在接收者的其余方法之前，可能会出现一个 `newXYZ()`/`NewXYZ()` \n\n由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\ntype something struct{ ... }\n\nfunc calcCost(n []int) int {...}\n\nfunc (s *something) Stop() {...}\n\nfunc newSomething() *something {\n    return &something{}\n}\n```\n\n</td><td>\n\n```go\ntype something struct{ ... }\n\nfunc newSomething() *something {\n    return &something{}\n}\n\nfunc (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\nfunc (s *something) Stop() {...}\n\nfunc calcCost(n []int) int {...}\n```\n\n</td></tr>\n</tbody></table>\n\n### 减少嵌套\n\n代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfor _, v := range data {\n  if v.F1 == 1 {\n    v = process(v)\n    if err := v.Call(); err == nil {\n      v.Send()\n    } else {\n      return err\n    }\n  } else {\n    log.Printf(\"Invalid v: %v\", v)\n  }\n}\n```\n\n</td><td>\n\n```go\nfor _, v := range data {\n  if v.F1 != 1 {\n    log.Printf(\"Invalid v: %v\", v)\n    continue\n  }\n\n  v = process(v)\n  if err := v.Call(); err != nil {\n    return err\n  }\n  v.Send()\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### 不必要的 else\n\n如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nvar a int\nif b {\n  a = 100\n} else {\n  a = 10\n}\n```\n\n</td><td>\n\n```go\na := 10\nif b {\n  a = 100\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### 顶层变量声明\n\n在顶层，使用标准`var`关键字。请勿指定类型，除非它与表达式的类型不同。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nvar _s string = F()\n\nfunc F() string { return \"A\" }\n```\n\n</td><td>\n\n```go\nvar _s = F()\n// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型\n// 还是那种类型\n\nfunc F() string { return \"A\" }\n```\n\n</td></tr>\n</tbody></table>\n\n如果表达式的类型与所需的类型不完全匹配，请指定类型。\n\n```go\ntype myError struct{}\n\nfunc (myError) Error() string { return \"error\" }\n\nfunc F() myError { return myError{} }\n\nvar _e error = F()\n// F 返回一个 myError 类型的实例，但是我们要 error 类型\n```\n\n### 对于未导出的顶层常量和变量，使用_作为前缀\n\n在未导出的顶级`vars`和`consts`， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。\n\n例外：未导出的错误值，应以`err`开头。\n\n基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// foo.go\n\nconst (\n  defaultPort = 8080\n  defaultUser = \"user\"\n)\n\n// bar.go\n\nfunc Bar() {\n  defaultPort := 9090\n  ...\n  fmt.Println(\"Default port\", defaultPort)\n\n  // We will not see a compile error if the first line of\n  // Bar() is deleted.\n}\n```\n\n</td><td>\n\n```go\n// foo.go\n\nconst (\n  _defaultPort = 8080\n  _defaultUser = \"user\"\n)\n```\n\n</td></tr>\n</tbody></table>\n\n### 结构体中的嵌入\n\n嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype Client struct {\n  version int\n  http.Client\n}\n```\n\n</td><td>\n\n```go\ntype Client struct {\n  http.Client\n\n  version int\n}\n```\n\n</td></tr>\n</tbody></table>\n\n内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。\n它应该在对用户不利影响的情况下完成这项工作（另请参见：`避免在公共结构中嵌入类型`[Avoid Embedding Types in Public Structs]）。\n\n[Avoid Embedding Types in Public Structs]: #avoid-embedding-types-in-public-structs\n\n嵌入 **不应该**:\n\n- 纯粹是为了美观或方便。\n- 使外部类型更难构造或使用。\n- 影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。\n- 作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。\n- 公开未导出的类型。\n- 影响外部类型的复制形式。\n- 更改外部类型的API或类型语义。\n- 嵌入内部类型的非规范形式。\n- 公开外部类型的实现详细信息。\n- 允许用户观察或控制类型内部。\n- 通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。\n\n简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，\n\"是否所有这些导出的内部方法/字段都将直接添加到外部类型\"\n如果答案是`some`或`no`，不要嵌入内部类型-而是使用字段。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\ntype A struct {\n    // Bad: A.Lock() and A.Unlock() 现在可用\n    // 不提供任何功能性好处，并允许用户控制有关A的内部细节。\n    sync.Mutex\n}\n```\n\n</td><td>\n\n```go\ntype countingWriteCloser struct {\n    // Good: Write() 在外层提供用于特定目的，\n    // 并且委托工作到内部类型的Write()中。\n    io.WriteCloser\n    count int\n}\nfunc (w *countingWriteCloser) Write(bs []byte) (int, error) {\n    w.count += len(bs)\n    return w.WriteCloser.Write(bs)\n}\n```\n\n</td></tr>\n<tr><td>\n\n```go\ntype Book struct {\n    // Bad: 指针更改零值的有用性\n    io.ReadWriter\n    // other fields\n}\n// later\nvar b Book\nb.Read(...)  // panic: nil pointer\nb.String()   // panic: nil pointer\nb.Write(...) // panic: nil pointer\n```\n\n</td><td>\n\n```go\ntype Book struct {\n    // Good: 有用的零值\n    bytes.Buffer\n    // other fields\n}\n// later\nvar b Book\nb.Read(...)  // ok\nb.String()   // ok\nb.Write(...) // ok\n```\n\n</td></tr>\n<tr><td>\n\n```go\ntype Client struct {\n    sync.Mutex\n    sync.WaitGroup\n    bytes.Buffer\n    url.URL\n}\n```\n\n</td><td>\n\n```go\ntype Client struct {\n    mtx sync.Mutex\n    wg  sync.WaitGroup\n    buf bytes.Buffer\n    url url.URL\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### 使用字段名初始化结构体\n\n初始化结构体时，应该指定字段名称。现在由 [`go vet`] 强制执行。\n\n[`go vet`]: https://golang.org/cmd/vet/\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nk := User{\"John\", \"Doe\", true}\n```\n\n</td><td>\n\n```go\nk := User{\n    FirstName: \"John\",\n    LastName: \"Doe\",\n    Admin: true,\n}\n```\n\n</td></tr>\n</tbody></table>\n\n例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。\n\n```go\ntests := []struct{\n  op Operation\n  want string\n}{\n  {Add, \"add\"},\n  {Subtract, \"subtract\"},\n}\n```\n\n### 本地变量声明\n\n如果将变量明确设置为某个值，则应使用短变量声明形式 (`:=`)。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nvar s = \"foo\"\n```\n\n</td><td>\n\n```go\ns := \"foo\"\n```\n\n</td></tr>\n</tbody></table>\n\n但是，在某些情况下，`var` 使用关键字时默认值会更清晰。例如，声明空切片。\n\n[Declaring Empty Slices]: https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nfunc f(list []int) {\n  filtered := []int{}\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n```\n\n</td><td>\n\n```go\nfunc f(list []int) {\n  var filtered []int\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n```\n\n</td></tr>\n</tbody></table>\n\n### nil 是一个有效的 slice\n\n`nil` 是一个有效的长度为 0 的 slice，这意味着，\n\n- 您不应明确返回长度为零的切片。应该返回`nil` 来代替。\n\n  <table>\n  <thead><tr><th>Bad</th><th>Good</th></tr></thead>\n  <tbody>\n  <tr><td>\n\n  ```go\n  if x == \"\" {\n    return []int{}\n  }\n  ```\n\n  </td><td>\n\n  ```go\n  if x == \"\" {\n    return nil\n  }\n  ```\n\n  </td></tr>\n  </tbody></table>\n\n- 要检查切片是否为空，请始终使用`len(s) == 0`。而非 `nil`。\n\n  <table>\n  <thead><tr><th>Bad</th><th>Good</th></tr></thead>\n  <tbody>\n  <tr><td>\n\n  ```go\n  func isEmpty(s []string) bool {\n    return s == nil\n  }\n  ```\n\n  </td><td>\n\n  ```go\n  func isEmpty(s []string) bool {\n    return len(s) == 0\n  }\n  ```\n\n  </td></tr>\n  </tbody></table>\n\n- 零值切片（用`var`声明的切片）可立即使用，无需调用`make()`创建。\n\n  <table>\n  <thead><tr><th>Bad</th><th>Good</th></tr></thead>\n  <tbody>\n  <tr><td>\n\n  ```go\n  nums := []int{}\n  // or, nums := make([]int)\n\n  if add1 {\n    nums = append(nums, 1)\n  }\n\n  if add2 {\n    nums = append(nums, 2)\n  }\n  ```\n\n  </td><td>\n\n  ```go\n  var nums []int\n\n  if add1 {\n    nums = append(nums, 1)\n  }\n\n  if add2 {\n    nums = append(nums, 2)\n  }\n  ```\n\n  </td></tr>\n  </tbody></table>\n\n记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。\n\n### 缩小变量作用域\n\n如果有可能，尽量缩小变量作用范围。除非它与 [减少嵌套](#减少嵌套)的规则冲突。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nerr := ioutil.WriteFile(name, data, 0644)\nif err != nil {\n return err\n}\n```\n\n</td><td>\n\n```go\nif err := ioutil.WriteFile(name, data, 0644); err != nil {\n return err\n}\n```\n\n</td></tr>\n</tbody></table>\n\n如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nif data, err := ioutil.ReadFile(name); err == nil {\n  err = cfg.Decode(data)\n  if err != nil {\n    return err\n  }\n\n  fmt.Println(cfg)\n  return nil\n} else {\n  return err\n}\n```\n\n</td><td>\n\n```go\ndata, err := ioutil.ReadFile(name)\nif err != nil {\n   return err\n}\n\nif err := cfg.Decode(data); err != nil {\n  return err\n}\n\nfmt.Println(cfg)\nreturn nil\n```\n\n</td></tr>\n</tbody></table>\n\n### 避免参数语义不明确(Avoid Naked Parameters)\n\n函数调用中的`意义不明确的参数`可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (`/* ... */`)\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// func printInfo(name string, isLocal, done bool)\n\nprintInfo(\"foo\", true, true)\n```\n\n</td><td>\n\n```go\n// func printInfo(name string, isLocal, done bool)\n\nprintInfo(\"foo\", true /* isLocal */, true /* done */)\n```\n\n</td></tr>\n</tbody></table>\n\n对于上面的示例代码，还有一种更好的处理方式是将上面的 `bool` 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。\n\n```go\ntype Region int\n\nconst (\n  UnknownRegion Region = iota\n  Local\n)\n\ntype Status int\n\nconst (\n  StatusReady Status= iota + 1\n  StatusDone\n  // Maybe we will have a StatusInProgress in the future.\n)\n\nfunc printInfo(name string, region Region, status Status)\n```\n\n### 使用原始字符串字面值，避免转义\n\nGo 支持使用 [原始字符串字面值](https://golang.org/ref/spec#raw_string_lit)，也就是 \" ` \" 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。\n\n可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nwantError := \"unknown name:\\\"test\\\"\"\n```\n\n</td><td>\n\n```go\nwantError := `unknown error:\"test\"`\n```\n\n</td></tr>\n</tbody></table>\n\n### 初始化结构体\n\n#### 使用字段名初始化结构\n\n初始化结构时，几乎应该始终指定字段名。目前由[`go vet`]强制执行。\n\n[`go vet`]: https://golang.org/cmd/vet/\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nk := User{\"John\", \"Doe\", true}\n```\n\n</td><td>\n\n```go\nk := User{\n    FirstName: \"John\",\n    LastName: \"Doe\",\n    Admin: true,\n}\n```\n\n</td></tr>\n</tbody></table>\n\n例外：当有3个或更少的字段时，测试表中的字段名*may*可以省略。\n\n```go\ntests := []struct{\n  op Operation\n  want string\n}{\n  {Add, \"add\"},\n  {Subtract, \"subtract\"},\n}\n```\n#### 省略结构中的零值字段\n\n初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。\n也就是，让我们自动将这些设置为零值\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nuser := User{\n  FirstName: \"John\",\n  LastName: \"Doe\",\n  MiddleName: \"\",\n  Admin: false,\n}\n```\n\n</td><td>\n\n```go\nuser := User{\n  FirstName: \"John\",\n  LastName: \"Doe\",\n}\n```\n\n</td></tr>\n</tbody></table>\n\n这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。\n\n在字段名提供有意义上下文的地方包含零值。例如，[表驱动测试](#表驱动测试) 中的测试用例可以受益于字段的名称，即使它们是零值的。\n\n```go\ntests := []struct{\n  give string\n  want int\n}{\n  {give: \"0\", want: 0},\n  // ...\n}\n```\n#### 对零值结构使用 `var`\n\n如果在声明中省略了结构的所有字段，请使用 `var` 声明结构。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nuser := User{}\n```\n\n</td><td>\n\n```go\nvar user User\n```\n\n</td></tr>\n</tbody></table>\n\n这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，\n并与我们更喜欢的[declare empty slices][Declaring empty slices]方式相匹配。\n\n#### 初始化 Struct 引用\n\n在初始化结构引用时，请使用`&T{}`代替`new(T)`，以使其与结构体初始化一致。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nsval := T{Name: \"foo\"}\n\n// inconsistent\nsptr := new(T)\nsptr.Name = \"bar\"\n```\n\n</td><td>\n\n```go\nsval := T{Name: \"foo\"}\n\nsptr := &T{Name: \"bar\"}\n```\n\n</td></tr>\n</tbody></table>\n\n### 初始化 Maps\n\n对于空 map 请使用 `make(..)` 初始化， 并且 map 是通过编程方式填充的。\n这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nvar (\n  // m1 读写安全;\n  // m2 在写入时会 panic\n  m1 = map[T1]T2{}\n  m2 map[T1]T2\n)\n```\n\n</td><td>\n\n```go\nvar (\n  // m1 读写安全;\n  // m2 在写入时会 panic\n  m1 = make(map[T1]T2)\n  m2 map[T1]T2\n)\n```\n\n</td></tr>\n<tr><td>\n\n声明和初始化看起来非常相似的。\n\n</td><td>\n\n声明和初始化看起来差别非常大。\n\n</td></tr>\n</tbody></table>\n\n在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 [指定Map容量提示](#指定Map容量提示)。\n\n\n另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。\n\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nm := make(map[T1]T2, 3)\nm[k1] = v1\nm[k2] = v2\nm[k3] = v3\n```\n\n</td><td>\n\n```go\nm := map[T1]T2{\n  k1: v1,\n  k2: v2,\n  k3: v3,\n}\n```\n\n</td></tr>\n</tbody></table>\n\n基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 `make` (如果可以，请尽量指定 map 容量)。\n\n### 字符串 string format\n\n如果你在函数外声明`Printf`-style 函数的格式字符串，请将其设置为`const`常量。\n\n这有助于`go vet`对格式字符串执行静态分析。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\nmsg := \"unexpected values %v, %v\\n\"\nfmt.Printf(msg, 1, 2)\n```\n\n</td><td>\n\n```go\nconst msg = \"unexpected values %v, %v\\n\"\nfmt.Printf(msg, 1, 2)\n```\n\n</td></tr>\n</tbody></table>\n\n### 命名 Printf 样式的函数\n\n声明`Printf`-style 函数时，请确保`go vet`可以检测到它并检查格式字符串。\n\n这意味着您应尽可能使用预定义的`Printf`-style 函数名称。`go vet`将默认检查这些。有关更多信息，请参见 [Printf 系列]。\n\n[Printf 系列]: https://golang.org/cmd/vet/#hdr-Printf_family\n\n如果不能使用预定义的名称，请以 f 结束选择的名称：`Wrapf`，而不是`Wrap`。`go vet`可以要求检查特定的 Printf 样式名称，但名称必须以`f`结尾。\n\n```shell\n$ go vet -printfuncs=wrapf,statusf\n```\n\n另请参阅 [go vet: Printf family check].\n\n[go vet: Printf family check]: https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/\n\n## 编程模式\n\n### 表驱动测试\n\n当测试逻辑是重复的时候，通过  [subtests] 使用 table 驱动的方式编写 case 代码看上去会更简洁。\n\n[subtests]: https://blog.golang.org/subtests\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// func TestSplitHostPort(t *testing.T)\n\nhost, port, err := net.SplitHostPort(\"192.0.2.0:8000\")\nrequire.NoError(t, err)\nassert.Equal(t, \"192.0.2.0\", host)\nassert.Equal(t, \"8000\", port)\n\nhost, port, err = net.SplitHostPort(\"192.0.2.0:http\")\nrequire.NoError(t, err)\nassert.Equal(t, \"192.0.2.0\", host)\nassert.Equal(t, \"http\", port)\n\nhost, port, err = net.SplitHostPort(\":8000\")\nrequire.NoError(t, err)\nassert.Equal(t, \"\", host)\nassert.Equal(t, \"8000\", port)\n\nhost, port, err = net.SplitHostPort(\"1:8\")\nrequire.NoError(t, err)\nassert.Equal(t, \"1\", host)\nassert.Equal(t, \"8\", port)\n```\n\n</td><td>\n\n```go\n// func TestSplitHostPort(t *testing.T)\n\ntests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  {\n    give:     \"192.0.2.0:8000\",\n    wantHost: \"192.0.2.0\",\n    wantPort: \"8000\",\n  },\n  {\n    give:     \"192.0.2.0:http\",\n    wantHost: \"192.0.2.0\",\n    wantPort: \"http\",\n  },\n  {\n    give:     \":8000\",\n    wantHost: \"\",\n    wantPort: \"8000\",\n  },\n  {\n    give:     \"1:8\",\n    wantHost: \"1\",\n    wantPort: \"8\",\n  },\n}\n\nfor _, tt := range tests {\n  t.Run(tt.give, func(t *testing.T) {\n    host, port, err := net.SplitHostPort(tt.give)\n    require.NoError(t, err)\n    assert.Equal(t, tt.wantHost, host)\n    assert.Equal(t, tt.wantPort, port)\n  })\n}\n```\n\n</td></tr>\n</tbody></table>\n\n很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。\n\n我们遵循这样的约定：将结构体切片称为`tests`。 每个测试用例称为`tt`。此外，我们鼓励使用`give`和`want`前缀说明每个测试用例的输入和输出值。\n\n```go\ntests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  // ...\n}\n\nfor _, tt := range tests {\n  // ...\n}\n```\n\n### 功能选项\n\n功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。\n\n将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。\n\n<table>\n<thead><tr><th>Bad</th><th>Good</th></tr></thead>\n<tbody>\n<tr><td>\n\n```go\n// package db\n\nfunc Open(\n  addr string,\n  cache bool,\n  logger *zap.Logger\n) (*Connection, error) {\n  // ...\n}\n```\n\n</td><td>\n\n```go\n// package db\n\ntype Option interface {\n  // ...\n}\n\nfunc WithCache(c bool) Option {\n  // ...\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  // ...\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  // ...\n}\n```\n\n</td></tr>\n<tr><td>\n\n必须始终提供缓存和记录器参数，即使用户希望使用默认值。\n\n```go\ndb.Open(addr, db.DefaultCache, zap.NewNop())\ndb.Open(addr, db.DefaultCache, log)\ndb.Open(addr, false /* cache */, zap.NewNop())\ndb.Open(addr, false /* cache */, log)\n```\n\n</td><td>\n\n只有在需要时才提供选项。\n\n```go\ndb.Open(addr)\ndb.Open(addr, db.WithLogger(log))\ndb.Open(addr, db.WithCache(false))\ndb.Open(\n  addr,\n  db.WithCache(false),\n  db.WithLogger(log),\n)\n```\n\n</td></tr>\n</tbody></table>\n\nOur suggested way of implementing this pattern is with an `Option` interface\nthat holds an unexported method, recording options on an unexported `options`\nstruct.\n\n我们建议实现此模式的方法是使用一个 `Option` 接口，该接口保存一个未导出的方法，在一个未导出的 `options` 结构上记录选项。\n\n```go\ntype options struct {\n  cache  bool\n  logger *zap.Logger\n}\n\ntype Option interface {\n  apply(*options)\n}\n\ntype cacheOption bool\n\nfunc (c cacheOption) apply(opts *options) {\n  opts.cache = bool(c)\n}\n\nfunc WithCache(c bool) Option {\n  return cacheOption(c)\n}\n\ntype loggerOption struct {\n  Log *zap.Logger\n}\n\nfunc (l loggerOption) apply(opts *options) {\n  opts.logger = l.Log\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  return loggerOption{Log: log}\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  options := options{\n    cache:  defaultCache,\n    logger: zap.NewNop(),\n  }\n\n  for _, o := range opts {\n    o.apply(&options)\n  }\n\n  // ...\n}\n```\n\n注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 `fmt.Stringer`，允许用户读取选项的字符串表示形式。\n\n还可以参考下面资料：\n\n- [Self-referential functions and the design of options]\n- [Functional options for friendly APIs]\n\n  [Self-referential functions and the design of options]: https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\n  [Functional options for friendly APIs]: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis\n\n<!-- TODO: replace this with parameter structs and functional options, when to\nuse one vs other -->\n\n## Linting\n\n比任何 \"blessed\" linter 集更重要的是，lint在一个代码库中始终保持一致。\n\n我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：\n\n- [errcheck] 以确保错误得到处理\n- [goimports] 格式化代码和管理 imports\n- [golint] 指出常见的文体错误\n- [govet] 分析代码中的常见错误\n- [staticcheck] 各种静态分析检查\n\n  [errcheck]: https://github.com/kisielk/errcheck\n  [goimports]: https://godoc.org/golang.org/x/tools/cmd/goimports\n  [golint]: https://github.com/golang/lint\n  [govet]: https://golang.org/cmd/vet/\n  [staticcheck]: https://staticcheck.io/\n\n\n### Lint Runners\n\n我们推荐 [golangci-lint] 作为go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件[.golangci.yml]和推荐的linter设置。\n\ngolangci-lint 有[various-linters]可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。\n\n[golangci-lint]: https://github.com/golangci/golangci-lint\n[.golangci.yml]: https://github.com/uber-go/guide/blob/master/.golangci.yml\n[various-linters]: https://golangci-lint.run/usage/linters/\n\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/xxjwxc/uber_go_guide_cn.svg)](https://starchart.cc/xxjwxc/uber_go_guide_cn)\n"
        },
        {
          "name": "hello world.go",
          "type": "blob",
          "size": 0.0888671875,
          "content": "package main\nimport \"fmt\"\nfunc main(){\n    fmt.Println(\"hello world . 你好 世界！\")\n}\n"
        },
        {
          "name": "paper",
          "type": "tree",
          "content": null
        },
        {
          "name": "云原生",
          "type": "tree",
          "content": null
        },
        {
          "name": "搭建Go语言开发环境",
          "type": "tree",
          "content": null
        },
        {
          "name": "文章",
          "type": "tree",
          "content": null
        },
        {
          "name": "源码",
          "type": "tree",
          "content": null
        },
        {
          "name": "电子书籍",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}