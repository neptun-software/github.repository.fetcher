{
  "metadata": {
    "timestamp": 1736567838596,
    "page": 421,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjQyOA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jwilder/dockerize",
      "stars": 5032,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0048828125,
          "content": ".git\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3388671875,
          "content": "### Go template\n# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n.idea\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# Created by .ignore support plugin (hsz.mobi)\n\ndockerize\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.4453125,
          "content": "FROM golang:1.23 AS binary\n\nWORKDIR /go/src/github.com/jwilder/dockerize\nCOPY *.go go.* /go/src/github.com/jwilder/dockerize/\n\nENV GO111MODULE=on\nRUN go mod tidy\n\nRUN CGO_ENABLED=0 GOOS=linux GO111MODULE=on go build -a -o /go/bin/dockerize .\n\nFROM gcr.io/distroless/static:nonroot\nLABEL MAINTAINER=\"Jason Wilder <mail@jasonwilder.com>\"\n\nUSER nonroot:nonroot\nCOPY --from=binary /go/bin/dockerize /bin/dockerize\n\nENTRYPOINT [\"/bin/dockerize\"]\nCMD [\"--help\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License\n\nCopyright (c) 2014-2018 Jason Wilder\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.541015625,
          "content": ".SILENT :\n.PHONY : dockerize clean fmt\n\nTAG:=`git describe --abbrev=0 --tags`\nLDFLAGS:=-X main.buildVersion=$(TAG)\nGO111MODULE:=on\n\nall: dockerize\n\ndeps:\n\tgo mod tidy\n\ndockerize:\n\techo \"Building dockerize\"\n\tgo install -ldflags \"$(LDFLAGS)\"\n\ndist-clean:\n\trm -rf dist\n\trm -f dockerize-*.tar.gz\n\ndist: deps dist-clean\n\tmkdir -p dist/alpine-linux/amd64 && GOOS=linux GOARCH=amd64 go build -ldflags \"$(LDFLAGS)\" -a -tags netgo -installsuffix netgo -o dist/alpine-linux/amd64/dockerize\n\tmkdir -p dist/alpine-linux/ppc64le && GOOS=linux GOARCH=ppc64le go build -ldflags \"$(LDFLAGS)\" -a -tags netgo -installsuffix netgo -o dist/alpine-linux/ppc64le/dockerize\n\tmkdir -p dist/linux/amd64 && GOOS=linux GOARCH=amd64 go build -ldflags \"$(LDFLAGS)\" -o dist/linux/amd64/dockerize\n\tmkdir -p dist/linux/386 && GOOS=linux GOARCH=386 go build -ldflags \"$(LDFLAGS)\" -o dist/linux/386/dockerize\n\tmkdir -p dist/linux/armel && GOOS=linux GOARCH=arm GOARM=5 go build -ldflags \"$(LDFLAGS)\" -o dist/linux/armel/dockerize\n\tmkdir -p dist/linux/armhf && GOOS=linux GOARCH=arm GOARM=6 go build -ldflags \"$(LDFLAGS)\" -o dist/linux/armhf/dockerize\n\tmkdir -p dist/linux/arm64 && GOOS=linux GOARCH=arm64 go build -ldflags \"$(LDFLAGS)\" -o dist/linux/arm64/dockerize\n\tmkdir -p dist/linux/ppc64le && GOOS=linux GOARCH=ppc64le go build -ldflags \"$(LDFLAGS)\" -o dist/linux/ppc64le/dockerize\n\tmkdir -p dist/darwin/amd64 && GOOS=darwin GOARCH=amd64 go build -ldflags \"$(LDFLAGS)\" -o dist/darwin/amd64/dockerize\n\tmkdir -p dist/darwin/amd64 && GOOS=darwin GOARCH=arm64 go build -ldflags \"$(LDFLAGS)\" -o dist/darwin/arm64/dockerize\n\tmkdir -p dist/linux/s390x && GOOS=linux GOARCH=s390x go build -ldflags \"$(LDFLAGS)\" -o dist/linux/s390x/dockerize\n\nrelease: dist\n\ttar -cvzf dockerize-alpine-linux-amd64-$(TAG).tar.gz -C dist/alpine-linux/amd64 dockerize\n\ttar -cvzf dockerize-alpine-linux-ppc64le-$(TAG).tar.gz -C dist/alpine-linux/ppc64le dockerize\n\ttar -cvzf dockerize-linux-amd64-$(TAG).tar.gz -C dist/linux/amd64 dockerize\n\ttar -cvzf dockerize-linux-386-$(TAG).tar.gz -C dist/linux/386 dockerize\n\ttar -cvzf dockerize-linux-armel-$(TAG).tar.gz -C dist/linux/armel dockerize\n\ttar -cvzf dockerize-linux-armhf-$(TAG).tar.gz -C dist/linux/armhf dockerize\n\ttar -cvzf dockerize-linux-arm64-$(TAG).tar.gz -C dist/linux/arm64 dockerize\n\ttar -cvzf dockerize-linux-ppc64le-$(TAG).tar.gz -C dist/linux/ppc64le dockerize\n\ttar -cvzf dockerize-darwin-amd64-$(TAG).tar.gz -C dist/darwin/amd64 dockerize\n\ttar -cvzf dockerize-darwin-arm64-$(TAG).tar.gz -C dist/darwin/arm64 dockerize\n\ttar -cvzf dockerize-linux-s390x-$(TAG).tar.gz -C dist/linux/s390x dockerize\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.90234375,
          "content": "dockerize ![version v0.9.1](https://img.shields.io/badge/version-v0.9.1-brightgreen.svg) ![License MIT](https://img.shields.io/badge/license-MIT-blue.svg)\n=============\n\nUtility to simplify running applications in docker containers.\n\ndockerize is a utility to simplify running applications in docker containers.  It allows you to:\n* generate application configuration files at container startup time from templates and container environment variables\n* Tail multiple log files to stdout and/or stderr\n* Wait for other services to be available using TCP, HTTP(S), unix before starting the main process.\n\nThe typical use case for dockerize is when you have an application that has one or more configuration files and you would like to control some of the values using environment variables.\n\nFor example, a Python application using Sqlalchemy might not be able to use environment variables directly.\nIt may require that the database URL be read from a python settings file with a variable named\n`SQLALCHEMY_DATABASE_URI`.  dockerize allows you to set an environment variable such as\n`DATABASE_URL` and update the python file when the container starts.\nIn addition, it can also delay the starting of the python application until the database container is running and listening on the TCP port.\n\nAnother use case is when the application logs to specific files on the filesystem and not stdout\nor stderr. This makes it difficult to troubleshoot the container using the `docker logs` command.\nFor example, nginx will log to `/var/log/nginx/access.log` and\n`/var/log/nginx/error.log` by default. While you can sometimes work around this, it's tedious to find a solution for every application. dockerize allows you to specify which logs files should be tailed and where they should be sent.\n\nSee [A Simple Way To Dockerize Applications](http://jasonwilder.com/blog/2014/10/13/a-simple-way-to-dockerize-applications/)\n\n\n## Installation\n\nDownload the latest version in your container:\n\n* [linux/amd64](https://github.com/jwilder/dockerize/releases/download/v0.9.1/dockerize-linux-amd64-v0.9.1.tar.gz)\n* [alpine/amd64](https://github.com/jwilder/dockerize/releases/download/v0.9.1/dockerize-alpine-linux-amd64-v0.9.1.tar.gz)\n* [darwin/amd64](https://github.com/jwilder/dockerize/releases/download/v0.9.1/dockerize-darwin-amd64-v0.9.1.tar.gz)\n\n\n### Docker Base Image\n\nThe `jwilder/dockerize` image is a base image based on `gcr.io/distroless/static`.  `dockerize` is installed in the `$PATH` and can be used directly.\n\n```\nFROM jwilder/dockerize\n...\nENTRYPOINT dockerize ...\n```\n\n### Ubuntu Images\n\n``` Dockerfile\nENV DOCKERIZE_VERSION v0.9.1\n\nRUN apt-get update \\\n    && apt-get install -y wget \\\n    && wget -O - https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz | tar xzf - -C /usr/local/bin \\\n    && apt-get autoremove -yqq --purge wget && rm -rf /var/lib/apt/lists/*\n```\n\n\n### For Alpine Images:\n\n``` Dockerfile\nENV DOCKERIZE_VERSION v0.9.1\n\nRUN apk update --no-cache \\\n    && apk add --no-cache wget openssl \\\n    && wget -O - https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz | tar xzf - -C /usr/local/bin \\\n    && apk del wget\n```\n\n## Usage\n\ndockerize works by wrapping the call to your application using the `ENTRYPOINT` or `CMD` directives.\n\nThis would generate `/etc/nginx/nginx.conf` from the template located at `/etc/nginx/nginx.tmpl` and\nsend `/var/log/nginx/access.log` to `STDOUT` and `/var/log/nginx/error.log` to `STDERR` after running\n`nginx`, only after waiting for the `web` host to respond on `tcp 8000`:\n\n``` Dockerfile\nCMD dockerize -template /etc/nginx/nginx.tmpl:/etc/nginx/nginx.conf -stdout /var/log/nginx/access.log -stderr /var/log/nginx/error.log -wait tcp://web:8000 nginx\n```\n\n### Command-line Options\n\nYou can specify multiple templates by passing using `-template` multiple times:\n\n```\n$ dockerize -template template1.tmpl:file1.cfg -template template2.tmpl:file3\n\n```\n\nTemplates can be generated to `STDOUT` by not specifying a dest:\n\n```\n$ dockerize -template template1.tmpl\n\n```\n\nTemplate may also be a directory. In this case all files within this directory are processed as template and stored with the same name in the destination directory.\nIf the destination directory is omitted, the output is sent to `STDOUT`. The files in the source directory are processed in sorted order (as returned by `ioutil.ReadDir`).\n\n```\n$ dockerize -template src_dir:dest_dir\n\n```\n\nIf the destination file already exists, dockerize will overwrite it. The -no-overwrite flag overrides this behaviour.\n\n```\n$ dockerize -no-overwrite -template template1.tmpl:file\n```\n\nYou can tail multiple files to `STDOUT` and `STDERR` by passing the options multiple times.\n\n```\n$ dockerize -stdout info.log -stdout perf.log\n\n```\n\nIf `inotify` does not work in your container, you can use `-poll` to poll for file changes instead.\n\n```\n$ dockerize -stdout info.log -stdout perf.log -poll\n\n```\n\nIf your file uses `{{` and `}}` as part of it's syntax, you can change the template escape characters using the `-delims`.\n\n```\n$ dockerize -delims \"<%:%>\"\n```\n\nHttp headers can be specified for http/https protocols.\n\n```\n$ dockerize -wait http://web:80 -wait-http-header \"Authorization:Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\"\n```\n\n## Waiting for other dependencies\n\nIt is common when using tools like [Docker Compose](https://docs.docker.com/compose/) to depend on services in other linked containers, however oftentimes relying on [links](https://docs.docker.com/compose/compose-file/#links) is not enough - whilst the container itself may have _started_, the _service(s)_ within it may not yet be ready - resulting in shell script hacks to work around race conditions.\n\nDockerize gives you the ability to wait for services on a specified protocol (`file`, `tcp`, `tcp4`, `tcp6`, `http`, `https` and `unix`) before starting your application:\n\n```\n$ dockerize -wait tcp://db:5432 -wait http://web:80 -wait file:///tmp/generated-file\n```\n\n### Timeout\n\nYou can optionally specify how long to wait for the services to become available by using the `-timeout #` argument (Default: 10 seconds).  If the timeout is reached and the service is still not available, the process exits with status code 1.\n\n```\n$ dockerize -wait tcp://db:5432 -wait http://web:80 -timeout 10s\n```\n\nSee [this issue](https://github.com/docker/compose/issues/374#issuecomment-126312313) for a deeper discussion, and why support isn't and won't be available in the Docker ecosystem itself.\n\n## Using Templates\n\nTemplates use Golang [text/template](http://golang.org/pkg/text/template/). You can access environment\nvariables within a template with `.Env`.\n\n```\n{{ .Env.PATH }} is my path\n```\n\nThere are a few built-in functions as well:\n\n  * `default $var $default` - Returns a default value for one that does not exist. `{{ default .Env.VERSION \"0.1.2\" }}`\n  * `contains $map $key` - Returns true if a string is within another string\n  * `exists $path` - Determines if a file path exists or not. `{{ exists \"/etc/default/myapp\" }}`\n  * `split $string $sep` - Splits a string into an array using a separator string. Alias for [`strings.Split`][go.string.Split]. `{{ split .Env.PATH \":\" }}`\n  * `replace $string $old $new $count` - Replaces all occurrences of a string within another string. Alias for [`strings.Replace`][go.string.Replace]. `{{ replace .Env.PATH \":\" }}`\n  * `parseUrl $url` - Parses a URL into it's [protocol, scheme, host, etc. parts][go.url.URL]. Alias for [`url.Parse`][go.url.Parse]\n  * `atoi $value` - Parses a string $value into an int. `{{ if (gt (atoi .Env.NUM_THREADS) 1) }}`\n  * `add $arg1 $arg` - Performs integer addition. `{{ add (atoi .Env.SHARD_NUM) -1 }}`\n  * `isTrue $value` - Parses a string $value to a boolean value. `{{ if isTrue .Env.ENABLED }}`\n  * `lower $value` - Lowercase a string.\n  * `upper $value` - Uppercase a string.\n  * `jsonQuery $json $query` - Returns the result of a selection query against a json document.\n  * `loop` - Create for loops.\n\n### jsonQuery\n\nObjects and fields are accessed by name. Array elements are accessed by index in square brackets (e.g. `[1]`). Nested elements are separated by dots (`.`).\n\n**Examples:**\n\nWith the following JSON in `.Env.SERVICES`\n\n```\n{\n  \"services\": [\n    {\n      \"name\": \"service1\",\n      \"port\": 8000,\n    },{\n      \"name\": \"service2\",\n      \"port\": 9000,\n    }\n  ]\n}\n```\n\nthe template expression `jsonQuery .Env.SERVICES \"services.[1].port\"` returns `9000`.\n\n### loop\n\n`loop` allows for creating for loop within a template.  It takes 1 to 3 arguments.\n\n```\n# Loop from 0...10\n{{ range loop 10 }}\ni = {{ . }}\n{{ end }}\n\n# Loop from 5...10\n{{ range $i := loop 5 10 }}\ni = {{ $i }}\n{{ end }}\n\n# Loop from 5...10 by 2\n{{ range $i := loop 5 10 2 }}\ni = {{ $i }}\n{{ end }}\n```\n\n## License\n\nMIT\n\n\n[go.string.Split]: https://golang.org/pkg/strings/#Split\n[go.string.Replace]: https://golang.org/pkg/strings/#Replace\n[go.url.Parse]: https://golang.org/pkg/net/url/#Parse\n[go.url.URL]: https://golang.org/pkg/net/url/#URL\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "exec.go",
          "type": "blob",
          "size": 1.5185546875,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n)\n\nfunc runCmd(ctx context.Context, cancel context.CancelFunc, cmd string, args ...string) {\n\tdefer wg.Done()\n\n\tprocess := exec.Command(cmd, args...)\n\tprocess.Stdin = os.Stdin\n\tprocess.Stdout = os.Stdout\n\tprocess.Stderr = os.Stderr\n\n\t// start the process\n\terr := process.Start()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error starting command: `%s` - %s\\n\", cmd, err)\n\t}\n\n\t// Setup signaling\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGKILL)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\tselect {\n\t\tcase sig := <-sigs:\n\t\t\tlog.Printf(\"Received signal: %s\\n\", sig)\n\t\t\tsignalProcessWithTimeout(process, sig)\n\t\t\tcancel()\n\t\tcase <-ctx.Done():\n\t\t\t// exit when context is done\n\t\t}\n\t}()\n\n\terr = process.Wait()\n\tcancel()\n\n\tif err == nil {\n\t\tlog.Println(\"Command finished successfully.\")\n\t} else {\n\t\tlog.Printf(\"Command exited with error: %s\\n\", err)\n\t\t// OPTIMIZE: This could be cleaner\n\t\tos.Exit(err.(*exec.ExitError).Sys().(syscall.WaitStatus).ExitStatus())\n\t}\n\n}\n\nfunc signalProcessWithTimeout(process *exec.Cmd, sig os.Signal) {\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tprocess.Process.Signal(sig) // pretty sure this doesn't do anything. It seems like the signal is automatically sent to the command?\n\t\tprocess.Wait()\n\t\tclose(done)\n\t}()\n\tselect {\n\tcase <-done:\n\t\treturn\n\tcase <-time.After(10 * time.Second):\n\t\tlog.Println(\"Killing command due to timeout.\")\n\t\tprocess.Process.Kill()\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.9482421875,
          "content": "module github.com/jwilder/dockerize\n\ngo 1.23.4\n\nrequire (\n\tgithub.com/Masterminds/sprig/v3 v3.3.0\n\tgithub.com/hpcloud/tail v1.0.0\n\tgithub.com/jwilder/gojq v0.0.0-20161018055142-c550732d4a52\n\tgolang.org/x/net v0.33.0\n)\n\nrequire (\n\tdario.cat/mergo v1.0.1 // indirect\n\tgithub.com/Masterminds/goutils v1.1.1 // indirect\n\tgithub.com/Masterminds/semver/v3 v3.3.1 // indirect\n\tgithub.com/elgs/gosplitargs v0.0.0-20241205072753-cbd889c0f906 // indirect\n\tgithub.com/fsnotify/fsnotify v1.8.0 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/huandu/xstrings v1.5.0 // indirect\n\tgithub.com/mitchellh/copystructure v1.2.0 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.2 // indirect\n\tgithub.com/shopspring/decimal v1.4.0 // indirect\n\tgithub.com/spf13/cast v1.7.1 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgopkg.in/fsnotify.v1 v1.4.7 // indirect\n\tgopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.861328125,
          "content": "dario.cat/mergo v1.0.1 h1:Ra4+bf83h2ztPIQYNP99R6m+Y7KfnARDfID+a+vLl4s=\ndario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\ngithub.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver/v3 v3.3.1 h1:QtNSWtVZ3nBfk8mAOu/B6v7FMJ+NHTIgUPi7rj+4nv4=\ngithub.com/Masterminds/semver/v3 v3.3.1/go.mod h1:4V+yj/TJE1HU9XfppCwVMZq3I84lprf4nC11bSS5beM=\ngithub.com/Masterminds/sprig/v3 v3.3.0 h1:mQh0Yrg1XPo6vjYXgtf5OtijNAKJRNcTdOOGZe3tPhs=\ngithub.com/Masterminds/sprig/v3 v3.3.0/go.mod h1:Zy1iXRYNqNLUolqCpL4uhk6SHUMAOSCzdgBfDb35Lz0=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/elgs/gosplitargs v0.0.0-20241205072753-cbd889c0f906 h1:Gfn+NcN3eAVFLXd9hN9sTd0vtsYXSGwVUKk6EHFVn3s=\ngithub.com/elgs/gosplitargs v0.0.0-20241205072753-cbd889c0f906/go.mod h1:w1WVg5EhY8yy+53iAGOaUp4JxlmV24K3D21BpFgxqcY=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/fsnotify/fsnotify v1.8.0 h1:dAwr6QBTBZIkG8roQaJjGof0pp0EeF+tNV7YBP3F/8M=\ngithub.com/fsnotify/fsnotify v1.8.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/huandu/xstrings v1.5.0 h1:2ag3IFq9ZDANvthTwTiqSSZLjDc+BedvHPAp5tJy2TI=\ngithub.com/huandu/xstrings v1.5.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/jwilder/gojq v0.0.0-20161018055142-c550732d4a52 h1:ZSTiJFRPQr2XRqfgvm2xpEsrsudezdk8ykBXXiJDfiQ=\ngithub.com/jwilder/gojq v0.0.0-20161018055142-c550732d4a52/go.mod h1:pD7F1lLmlib/2Vy3xild2aXjNnnSudq54IJGftfO4O0=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=\ngithub.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=\ngithub.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=\ngithub.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=\ngithub.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=\ngithub.com/spf13/cast v1.7.1 h1:cuNEagBQEHWN1FnbGEjCXL2szYEXqfJPbP2HNUaca9Y=\ngithub.com/spf13/cast v1.7.1/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/fsnotify.v1 v1.4.7 h1:xOHLXZwVvI9hhs+cLKq5+I5onOuwQLhQwiu63xxlHs4=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 8.0869140625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n)\n\nconst defaultWaitRetryInterval = time.Second\n\ntype sliceVar []string\ntype hostFlagsVar []string\n\ntype Context struct {\n}\n\ntype HttpHeader struct {\n\tname  string\n\tvalue string\n}\n\nfunc (c *Context) Env() map[string]string {\n\tenv := make(map[string]string)\n\tfor _, i := range os.Environ() {\n\t\tsep := strings.Index(i, \"=\")\n\t\tenv[i[0:sep]] = i[sep+1:]\n\t}\n\treturn env\n}\n\nvar (\n\tbuildVersion string\n\tversion      bool\n\tpoll         bool\n\twg           sync.WaitGroup\n\n\ttemplatesFlag     sliceVar\n\ttemplateDirsFlag  sliceVar\n\tstdoutTailFlag    sliceVar\n\tstderrTailFlag    sliceVar\n\theadersFlag       sliceVar\n\tdelimsFlag        string\n\tdelims            []string\n\theaders           []HttpHeader\n\turls              []url.URL\n\twaitFlag          hostFlagsVar\n\twaitRetryInterval time.Duration\n\twaitTimeoutFlag   time.Duration\n\tdependencyChan    chan struct{}\n\tnoOverwriteFlag   bool\n\n\tctx    context.Context\n\tcancel context.CancelFunc\n)\n\nfunc (i *hostFlagsVar) String() string {\n\treturn fmt.Sprint(*i)\n}\n\nfunc (i *hostFlagsVar) Set(value string) error {\n\t*i = append(*i, value)\n\treturn nil\n}\n\nfunc (s *sliceVar) Set(value string) error {\n\t*s = append(*s, value)\n\treturn nil\n}\n\nfunc (s *sliceVar) String() string {\n\treturn strings.Join(*s, \",\")\n}\n\nfunc waitForDependencies() {\n\tdependencyChan := make(chan struct{})\n\n\tgo func() {\n\t\tfor _, u := range urls {\n\t\t\tlog.Println(\"Waiting for:\", u.String())\n\n\t\t\tswitch u.Scheme {\n\t\t\tcase \"file\":\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func(u url.URL) {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\tticker := time.NewTicker(waitRetryInterval)\n\t\t\t\t\tdefer ticker.Stop()\n\t\t\t\t\tvar err error\n\t\t\t\t\tif _, err = os.Stat(u.Path); err == nil {\n\t\t\t\t\t\tlog.Printf(\"File %s had been generated\\n\", u.String())\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tfor range ticker.C {\n\t\t\t\t\t\tif _, err = os.Stat(u.Path); err == nil {\n\t\t\t\t\t\t\tlog.Printf(\"File %s had been generated\\n\", u.String())\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else if os.IsNotExist(err) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.Printf(\"Problem with check file %s exist: %v. Sleeping %s\\n\", u.String(), err.Error(), waitRetryInterval)\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}(u)\n\t\t\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\t\t\twaitForSocket(u.Scheme, u.Host, waitTimeoutFlag)\n\t\t\tcase \"unix\":\n\t\t\t\twaitForSocket(u.Scheme, u.Path, waitTimeoutFlag)\n\t\t\tcase \"http\", \"https\":\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func(u url.URL) {\n\t\t\t\t\tclient := &http.Client{\n\t\t\t\t\t\tTimeout: waitTimeoutFlag,\n\t\t\t\t\t}\n\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\tfor {\n\t\t\t\t\t\treq, err := http.NewRequest(\"GET\", u.String(), nil)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Printf(\"Problem with dial: %v. Sleeping %s\\n\", err.Error(), waitRetryInterval)\n\t\t\t\t\t\t\ttime.Sleep(waitRetryInterval)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif len(headers) > 0 {\n\t\t\t\t\t\t\tfor _, header := range headers {\n\t\t\t\t\t\t\t\treq.Header.Add(header.name, header.value)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresp, err := client.Do(req)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Printf(\"Problem with request: %s. Sleeping %s\\n\", err.Error(), waitRetryInterval)\n\t\t\t\t\t\t\ttime.Sleep(waitRetryInterval)\n\t\t\t\t\t\t} else if err == nil && resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\t\t\t\t\t\tlog.Printf(\"Received %d from %s\\n\", resp.StatusCode, u.String())\n\t\t\t\t\t\t\t// dispose the response body and close it.\n\t\t\t\t\t\t\tio.Copy(io.Discard, resp.Body)\n\t\t\t\t\t\t\tresp.Body.Close()\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.Printf(\"Received %d from %s. Sleeping %s\\n\", resp.StatusCode, u.String(), waitRetryInterval)\n\t\t\t\t\t\t\tio.Copy(io.Discard, resp.Body)\n\t\t\t\t\t\t\tresp.Body.Close()\n\t\t\t\t\t\t\ttime.Sleep(waitRetryInterval)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}(u)\n\t\t\tdefault:\n\t\t\t\tlog.Fatalf(\"invalid host protocol provided: %s. supported protocols are: tcp, tcp4, tcp6 and http\", u.Scheme)\n\t\t\t}\n\t\t}\n\t\twg.Wait()\n\t\tclose(dependencyChan)\n\t}()\n\n\tselect {\n\tcase <-dependencyChan:\n\t\tbreak\n\tcase <-time.After(waitTimeoutFlag):\n\t\tlog.Fatalf(\"Timeout after %s waiting on dependencies to become available: %v\", waitTimeoutFlag, waitFlag)\n\t}\n\n}\n\nfunc waitForSocket(scheme, addr string, timeout time.Duration) {\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tconn, err := net.DialTimeout(scheme, addr, waitTimeoutFlag)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Problem with dial: %v. Sleeping %s\\n\", err.Error(), waitRetryInterval)\n\t\t\t\ttime.Sleep(waitRetryInterval)\n\t\t\t}\n\t\t\tif conn != nil {\n\t\t\t\tlog.Printf(\"Connected to %s://%s\\n\", scheme, addr)\n\t\t\t\tconn.Close()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc usage() {\n\tprintln(`Usage: dockerize [options] [command]\n\nUtility to simplify running applications in docker containers\n\nOptions:`)\n\tflag.PrintDefaults()\n\n\tprintln(`\nArguments:\n  command - command to be executed\n  `)\n\n\tprintln(`Examples:\n`)\n\tprintln(`   Generate /etc/nginx/nginx.conf using nginx.tmpl as a template, tail /var/log/nginx/access.log\n   and /var/log/nginx/error.log, waiting for a website to become available on port 8000 and start nginx.`)\n\tprintln(`\n   dockerize -template nginx.tmpl:/etc/nginx/nginx.conf \\\n             -stdout /var/log/nginx/access.log \\\n             -stderr /var/log/nginx/error.log \\\n             -wait tcp://web:8000 nginx\n\t`)\n\n\tprintln(`For more information, see https://github.com/jwilder/dockerize`)\n}\n\nfunc main() {\n\n\tflag.BoolVar(&version, \"version\", false, \"show version\")\n\tflag.BoolVar(&poll, \"poll\", false, \"enable polling\")\n\n\tflag.Var(&templatesFlag, \"template\", \"Template (/template:/dest). Can be passed multiple times. Does also support directories\")\n\tflag.BoolVar(&noOverwriteFlag, \"no-overwrite\", false, \"Do not overwrite destination file if it already exists.\")\n\tflag.Var(&stdoutTailFlag, \"stdout\", \"Tails a file to stdout. Can be passed multiple times\")\n\tflag.Var(&stderrTailFlag, \"stderr\", \"Tails a file to stderr. Can be passed multiple times\")\n\tflag.StringVar(&delimsFlag, \"delims\", \"\", `template tag delimiters. default \"{{\":\"}}\" `)\n\tflag.Var(&headersFlag, \"wait-http-header\", \"HTTP headers, colon separated. e.g \\\"Accept-Encoding: gzip\\\". Can be passed multiple times\")\n\tflag.Var(&waitFlag, \"wait\", \"Host (tcp/tcp4/tcp6/http/https/unix/file) to wait for before this container starts. Can be passed multiple times. e.g. tcp://db:5432\")\n\tflag.DurationVar(&waitTimeoutFlag, \"timeout\", 10*time.Second, \"Host wait timeout\")\n\tflag.DurationVar(&waitRetryInterval, \"wait-retry-interval\", defaultWaitRetryInterval, \"Duration to wait before retrying\")\n\n\tflag.Usage = usage\n\tflag.Parse()\n\n\tif version {\n\t\tfmt.Println(buildVersion)\n\t\treturn\n\t}\n\n\tif flag.NArg() == 0 && flag.NFlag() == 0 {\n\t\tusage()\n\t\tos.Exit(1)\n\t}\n\n\tif delimsFlag != \"\" {\n\t\tdelims = strings.Split(delimsFlag, \":\")\n\t\tif len(delims) != 2 {\n\t\t\tlog.Fatalf(\"bad delimiters argument: %s. expected \\\"left:right\\\"\", delimsFlag)\n\t\t}\n\t}\n\n\tfor _, host := range waitFlag {\n\t\tu, err := url.Parse(host)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"bad hostname provided: %s. %s\", host, err.Error())\n\t\t}\n\t\turls = append(urls, *u)\n\t}\n\n\tfor _, h := range headersFlag {\n\t\t//validate headers need -wait options\n\t\tif len(waitFlag) == 0 {\n\t\t\tlog.Fatalf(\"-wait-http-header \\\"%s\\\" provided with no -wait option\", h)\n\t\t}\n\n\t\tconst errMsg = \"bad HTTP Headers argument: %s. expected \\\"headerName: headerValue\\\"\"\n\t\tif strings.Contains(h, \":\") {\n\t\t\tparts := strings.Split(h, \":\")\n\t\t\tif len(parts) != 2 {\n\t\t\t\tlog.Fatalf(errMsg, headersFlag)\n\t\t\t}\n\t\t\theaders = append(headers, HttpHeader{name: strings.TrimSpace(parts[0]), value: strings.TrimSpace(parts[1])})\n\t\t} else {\n\t\t\tlog.Fatalf(errMsg, headersFlag)\n\t\t}\n\n\t}\n\n\tfor _, t := range templatesFlag {\n\t\ttemplate, dest := t, \"\"\n\t\tif strings.Contains(t, \":\") {\n\t\t\tparts := strings.Split(t, \":\")\n\t\t\tif len(parts) != 2 {\n\t\t\t\tlog.Fatalf(\"bad template argument: %s. expected \\\"/template:/dest\\\"\", t)\n\t\t\t}\n\t\t\ttemplate, dest = parts[0], parts[1]\n\t\t}\n\n\t\tfi, err := os.Stat(template)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"unable to stat %s, error: %s\", template, err)\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tgenerateDir(template, dest)\n\t\t} else {\n\t\t\tgenerateFile(template, dest)\n\t\t}\n\t}\n\n\twaitForDependencies()\n\n\t// Setup context\n\tctx, cancel = context.WithCancel(context.Background())\n\n\tif flag.NArg() > 0 {\n\t\twg.Add(1)\n\t\tgo runCmd(ctx, cancel, flag.Arg(0), flag.Args()[1:]...)\n\t}\n\n\tfor _, out := range stdoutTailFlag {\n\t\twg.Add(1)\n\t\tgo tailFile(ctx, out, poll, os.Stdout)\n\t}\n\n\tfor _, err := range stderrTailFlag {\n\t\twg.Add(1)\n\t\tgo tailFile(ctx, err, poll, os.Stderr)\n\t}\n\n\twg.Wait()\n}\n"
        },
        {
          "name": "tail.go",
          "type": "blob",
          "size": 1.26171875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/hpcloud/tail\"\n\t\"golang.org/x/net/context\"\n)\n\nfunc tailFile(ctx context.Context, file string, poll bool, dest *os.File) {\n\tdefer wg.Done()\n\n\tvar isPipe bool\n\tvar errCount int\n\n\ts, err := os.Stat(file)\n\tif err != nil {\n\t\tlog.Printf(\"Warning: unable to stat %s: %s\", file, err)\n\t\terrCount++\n\t\tisPipe = false\n\t} else {\n\t\tisPipe = s.Mode()&os.ModeNamedPipe != 0\n\t}\n\n\tt, err := tail.TailFile(file, tail.Config{\n\t\tFollow: true,\n\t\tReOpen: true,\n\t\tPoll:   poll,\n\t\tLogger: tail.DiscardingLogger,\n\t\tPipe:   isPipe,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to tail %s: %s\", file, err)\n\t}\n\n\tdefer func() {\n\t\tt.Stop()\n\t\tt.Cleanup()\n\t}()\n\n\t// main loop\n\tfor {\n\t\tselect {\n\t\t// if the channel is done, then exit the loop\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t// get the next log line and echo it out\n\t\tcase line := <-t.Lines:\n\t\t\tif t.Err() != nil {\n\t\t\t\tlog.Printf(\"Warning: unable to tail %s: %s\", file, t.Err())\n\t\t\t\terrCount++\n\t\t\t\tif errCount > 30 {\n\t\t\t\t\tlog.Fatalf(\"Logged %d consecutive errors while tailing. Exiting\", errCount)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(2 * time.Second) // Sleep for 2 seconds before retrying\n\t\t\t} else if line == nil {\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tfmt.Fprintln(dest, line.Text)\n\t\t\t\terrCount = 0 // Zero the error count\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 4.2861328125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n\n\t\"github.com/Masterminds/sprig/v3\"\n\t\"github.com/jwilder/gojq\"\n)\n\nfunc exists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc contains(item map[string]string, key string) bool {\n\tif _, ok := item[key]; ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc defaultValue(args ...interface{}) (string, error) {\n\tif len(args) == 0 {\n\t\treturn \"\", fmt.Errorf(\"default called with no values!\")\n\t}\n\n\tif len(args) > 0 {\n\t\tif args[0] != nil {\n\t\t\treturn args[0].(string), nil\n\t\t}\n\t}\n\n\tif len(args) > 1 {\n\t\tif args[1] == nil {\n\t\t\treturn \"\", fmt.Errorf(\"default called with nil default value!\")\n\t\t}\n\n\t\tif _, ok := args[1].(string); !ok {\n\t\t\treturn \"\", fmt.Errorf(\"default is not a string value. hint: surround it w/ double quotes.\")\n\t\t}\n\n\t\treturn args[1].(string), nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"default called with no default value\")\n}\n\nfunc parseUrl(rawurl string) *url.URL {\n\tu, err := url.Parse(rawurl)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to parse url %s: %s\", rawurl, err)\n\t}\n\treturn u\n}\n\nfunc add(arg1, arg2 int) int {\n\treturn arg1 + arg2\n}\n\nfunc isTrue(s string) bool {\n\tb, err := strconv.ParseBool(strings.ToLower(s))\n\tif err == nil {\n\t\treturn b\n\t}\n\treturn false\n}\n\nfunc jsonQuery(jsonObj string, query string) (interface{}, error) {\n\tparser, err := gojq.NewStringQuery(jsonObj)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tres, err := parser.Query(query)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn res, nil\n}\n\nfunc loop(args ...int) (<-chan int, error) {\n\tvar start, stop, step int\n\tswitch len(args) {\n\tcase 1:\n\t\tstart, stop, step = 0, args[0], 1\n\tcase 2:\n\t\tstart, stop, step = args[0], args[1], 1\n\tcase 3:\n\t\tstart, stop, step = args[0], args[1], args[2]\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"wrong number of arguments, expected 1-3\"+\n\t\t\t\", but got %d\", len(args))\n\t}\n\n\tc := make(chan int)\n\tgo func() {\n\t\tfor i := start; i < stop; i += step {\n\t\t\tc <- i\n\t\t}\n\t\tclose(c)\n\t}()\n\treturn c, nil\n}\n\nfunc generateFile(templatePath, destPath string) bool {\n\ttemplateMap := template.FuncMap{\n\t\t\"contains\":  contains,\n\t\t\"exists\":    exists,\n\t\t\"split\":     strings.Split,\n\t\t\"replace\":   strings.Replace,\n\t\t\"default\":   defaultValue,\n\t\t\"parseUrl\":  parseUrl,\n\t\t\"atoi\":      strconv.Atoi,\n\t\t\"add\":       add,\n\t\t\"isTrue\":    isTrue,\n\t\t\"lower\":     strings.ToLower,\n\t\t\"upper\":     strings.ToUpper,\n\t\t\"jsonQuery\": jsonQuery,\n\t\t\"loop\":      loop,\n\t}\n\n\tcombinedFuncMap := sprig.TxtFuncMap()\n\tfor k, v := range templateMap {\n\t\tcombinedFuncMap[k] = v\n\t}\n\ttmpl := template.New(filepath.Base(templatePath)).Funcs(combinedFuncMap)\n\n\tif len(delims) > 0 {\n\t\ttmpl = tmpl.Delims(delims[0], delims[1])\n\t}\n\ttmpl, err := tmpl.ParseFiles(templatePath)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to parse template: %s\", err)\n\t}\n\n\t// Don't overwrite destination file if it exists and no-overwrite flag passed\n\tif _, err := os.Stat(destPath); err == nil && noOverwriteFlag {\n\t\treturn false\n\t}\n\n\tdest := os.Stdout\n\tif destPath != \"\" {\n\t\tdest, err = os.Create(destPath)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"unable to create %s\", err)\n\t\t}\n\t\tdefer dest.Close()\n\t}\n\n\terr = tmpl.ExecuteTemplate(dest, filepath.Base(templatePath), &Context{})\n\tif err != nil {\n\t\tlog.Fatalf(\"template error: %s\\n\", err)\n\t}\n\n\tif fi, err := os.Stat(destPath); err == nil {\n\t\tif err := dest.Chmod(fi.Mode()); err != nil {\n\t\t\tlog.Fatalf(\"unable to chmod temp file: %s\\n\", err)\n\t\t}\n\t\tif err := dest.Chown(int(fi.Sys().(*syscall.Stat_t).Uid), int(fi.Sys().(*syscall.Stat_t).Gid)); err != nil {\n\t\t\tlog.Fatalf(\"unable to chown temp file: %s\\n\", err)\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc generateDir(templateDir, destDir string) bool {\n\tif destDir != \"\" {\n\t\tfiDest, err := os.Stat(destDir)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"unable to stat %s, error: %s\", destDir, err)\n\t\t}\n\t\tif !fiDest.IsDir() {\n\t\t\tlog.Fatalf(\"if template is a directory, dest must also be a directory (or stdout)\")\n\t\t}\n\t}\n\n\tfiles, err := os.ReadDir(templateDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"bad directory: %s, error: %s\", templateDir, err)\n\t}\n\n\tfor _, file := range files {\n\t\tif destDir == \"\" {\n\t\t\tgenerateFile(filepath.Join(templateDir, file.Name()), \"\")\n\t\t} else {\n\t\t\tgenerateFile(filepath.Join(templateDir, file.Name()), filepath.Join(destDir, file.Name()))\n\t\t}\n\t}\n\n\treturn true\n}\n"
        }
      ]
    }
  ]
}