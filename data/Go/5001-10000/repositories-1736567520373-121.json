{
  "metadata": {
    "timestamp": 1736567520373,
    "page": 121,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ThreeDotsLabs/watermill",
      "stars": 7999,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.14453125,
          "content": ".idea\nvendor\ndocs/themes/\ndocs/node_modules/\ndocs/public/\ndocs/content/src-link\ndocs/content/middleware\ndocs/hugo_stats.json\n*.out\n*.log\n.mod-cache\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.18359375,
          "content": "service:\n  prepare:\n    - go run dev/consolidate-gomods/main.go >> go.mod\n    - GO111MODULE=on go mod vendor\n    - rm vendor/github.com/ThreeDotsLabs/watermill/ -rf\n\nrun:\n  concurrency: 8\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.70703125,
          "content": "# Contributors guide v0.1\n\n## How can I help?\n\nWe are always happy to help you in contributing to Watermill. If you have any ideas, please let us know on our [Discord server](https://watermill.io/support/).\n\nThere are multiple ways in which you can help us.\n\n### Existing issues\n\nYou can pick one of the existing issues. Most of the issues should have an estimation (S - small, M - medium, L - large).\n\n- [Good first issues list](https://github.com/ThreeDotsLabs/watermill/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) - simple issues to begin with\n- [Help wanted issues list](https://github.com/ThreeDotsLabs/watermill/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) - tasks that are already more or less clear, and you can start to implement them pretty quickly\n\n### New Pub/Sub implementations\n\nIf you have an idea to create a Pub/Sub based on some technology and it is not listed yet in our issues (because we don't know it, or it is just some crazy idea, like physical mail based Pub/Sub), feel free to add your own implementation.\nYou can do it in your private repository or if you want, we can move it to `ThreeDotsLabs/watermill-[name]`.\n\n*Please keep in mind that you will not be able to push changes directly to the master branch in a project in our organization*.\n\nWhen adding a new Pub/Sub implementation, you should start with this guide: [https://watermill.io/docs/pub-sub-implementing/](https://watermill.io/docs/pub-sub-implementing/).\n\n### New ideas\n\nIf you have any idea that is not covered in the issues list, please post a new issue describing it. \nIt's recommended to discuss your idea on [Discord](https://discord.gg/QV6VFg4YQE)/GitHub before creating production-ready implementation - in some situations, it may save a lot of your time before implementing something that can be simplified or done more easily. :)\n\nIn general, it's helpful to discuss a Proof of Concept to align with the idea.\n\n## Local development\n\nMakefile and docker-compose (for Pub/Subs) are your friends. You can run all tests locally (they are running in CI in the same way).\n\nUseful commands:\n- `make up` - docker-compose up\n- `make test` - tests\n- `make test_short` - run short tests (useful to perform a very fast check after changes)\n- `make fmt` - do goimports\n\n## Code standards\n\n- you should run `make fmt`\n- [CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)\n- [Effective Go](https://golang.org/doc/effective_go.html)\n- SOLID\n- code should be open for configuration and not coupled to any serialization method (for example: [AMQP marshaler](https://github.com/ThreeDotsLabs/watermill-amqp/blob/master/pkg/amqp/marshaler.go), [AMQP Config](https://github.com/ThreeDotsLabs/watermill-amqp/blob/master/pkg/amqp/config.go)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2019 Three Dots Labs\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.64453125,
          "content": "up:\n\ntest:\n\tgo test ./...\n\ntest_v:\n\tgo test -v ./...\n\ntest_short:\n\tgo test ./... -short\n\ntest_race:\n\tgo test ./... -short -race\n\ntest_stress:\n\tgo test -tags=stress -timeout=30m ./...\n\ntest_codecov:\n\tgo test -coverprofile=coverage.out -covermode=atomic ./...\n\ntest_reconnect:\n\tgo test -tags=reconnect ./...\n\nbuild:\n\tgo build ./...\n\nwait:\n\nfmt:\n\tgo fmt ./...\n\tgoimports -l -w .\n\ngenerate_gomod:\n\trm go.mod go.sum || true\n\tgo mod init github.com/ThreeDotsLabs/watermill\n\n\tgo install ./...\n\tsed -i '\\|go |d' go.mod\n\tgo mod edit -fmt\n\nupdate_examples_deps:\n\tgo run dev/update-examples-deps/main.go\n\nvalidate_examples:\n\t(cd dev/validate-examples/ && go run main.go)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.68359375,
          "content": "# Watermill\n<img align=\"right\" width=\"300\" src=\"https://watermill.io/img/gopher.svg\">\n\n[![CI Status](https://github.com/ThreeDotsLabs/watermill/actions/workflows/master.yml/badge.svg)](https://github.com/ThreeDotsLabs/watermill/actions/workflows/master.yml)\n[![Go Reference](https://pkg.go.dev/badge/github.com/ThreeDotsLabs/watermill.svg)](https://pkg.go.dev/github.com/ThreeDotsLabs/watermill)\n[![Go Report Card](https://goreportcard.com/badge/github.com/ThreeDotsLabs/watermill)](https://goreportcard.com/report/github.com/ThreeDotsLabs/watermill)\n[![codecov](https://codecov.io/gh/ThreeDotsLabs/watermill/branch/master/graph/badge.svg)](https://codecov.io/gh/ThreeDotsLabs/watermill)\n\nWatermill is a Go library for working efficiently with message streams. It is intended\nfor building event driven applications, enabling event sourcing, RPC over messages,\nsagas and basically whatever else comes to your mind. You can use conventional pub/sub\nimplementations like Kafka or RabbitMQ, but also HTTP or MySQL binlog if that fits your use case.\n\n## Goals\n\n* **Easy** to understand.\n* **Universal** - event-driven architecture, messaging, stream processing, CQRS - use it for whatever you need.\n* **Fast** (see [Benchmarks](#benchmarks)).\n* **Flexible** with middlewares, plugins and Pub/Sub configurations.\n* **Resilient** - using proven technologies and passing stress tests (see [Stability](#stability)).\n\n## Getting Started\n\nPick what you like the best or see in order:\n\n1. Follow the [Getting Started guide](https://watermill.io/docs/getting-started/).\n2. See examples below.\n3. Read the full documentation: https://watermill.io/\n\n## Our online hands-on training\n\n<a href=\"https://threedots.tech/event-driven/?utm_source=watermill-readme\"><img align=\"center\" width=\"400\" src=\"https://threedots.tech/event-driven-banner.png\"></a>\n\n## Examples\n\n* Basic\n    * [Your first app](_examples/basic/1-your-first-app) - **start here!**\n    * [Realtime feed](_examples/basic/2-realtime-feed)\n    * [Router](_examples/basic/3-router)\n    * [Metrics](_examples/basic/4-metrics)\n    * [CQRS with protobuf](_examples/basic/5-cqrs-protobuf)\n* [Pub/Subs usage](_examples/pubsubs)\n    * These examples are part of the [Getting started guide](https://watermill.io/docs/getting-started/) and show usage of a single Pub/Sub at a time.\n* Real-world examples\n    * [Exactly-once delivery counter](_examples/real-world-examples/exactly-once-delivery-counter)\n    * [Receiving webhooks](_examples/real-world-examples/receiving-webhooks)\n    * [Sending webhooks](_examples/real-world-examples/sending-webhooks)\n    * [Synchronizing Databases](_examples/real-world-examples/synchronizing-databases)\n    * [Persistent Event Log](_examples/real-world-examples/persistent-event-log)\n    * [Transactional Events](_examples/real-world-examples/transactional-events)\n    * [Real-time HTTP updates with Server-Sent Events](_examples/real-world-examples/server-sent-events)\n    * [Real-time HTTP updates with Server-Sent Events and htmx](_examples/real-world-examples/server-sent-events-htmx)\n* Complete projects\n    * [NATS example with live code reloading](https://github.com/ThreeDotsLabs/nats-example)\n    * [RabbitMQ, webhooks and Kafka integration](https://github.com/ThreeDotsLabs/event-driven-example)\n\n## Background\n\nBuilding distributed and scalable services is rarely as easy as some may suggest. There is a\nlot of hidden knowledge that comes with writing such systems. Just like you don't need to know the\nwhole TCP stack to create a HTTP REST server, you shouldn't need to study all of this knowledge to\nstart with building message-driven applications.\n\nWatermill's goal is to make communication with messages as easy to use as HTTP routers. It provides\nthe tools needed to begin working with event-driven architecture and allows you to learn the details\non the go.\n\nAt the heart of Watermill there is one simple interface:\n```go\nfunc(*Message) ([]*Message, error)\n```\n\nYour handler receives a message and decides whether to publish new message(s) or return\nan error. What happens next is up to the middlewares you've chosen.\n\nYou can find more about our motivations in our [*Introducing Watermill* blog post](https://threedots.tech/post/introducing-watermill/).\n\n## Pub/Subs\n\nAll publishers and subscribers have to implement an interface:\n\n```go\ntype Publisher interface {\n\tPublish(topic string, messages ...*Message) error\n\tClose() error\n}\n\ntype Subscriber interface {\n\tSubscribe(ctx context.Context, topic string) (<-chan *Message, error)\n\tClose() error\n}\n```\n\nSupported Pub/Subs:\n\n- AMQP Pub/Sub [(`github.com/ThreeDotsLabs/watermill-amqp/v2`)](https://github.com/ThreeDotsLabs/watermill-amqp/)\n- Bolt Pub/Sub [(`github.com/ThreeDotsLabs/watermill-bolt`)](https://github.com/ThreeDotsLabs/watermill-bolt/)\n- Firestore Pub/Sub [(`github.com/ThreeDotsLabs/watermill-firestore`)](https://github.com/ThreeDotsLabs/watermill-firestore/)\n- Google Cloud Pub/Sub [(`github.com/ThreeDotsLabs/watermill-googlecloud`)](https://github.com/ThreeDotsLabs/watermill-googlecloud/)\n- HTTP Pub/Sub [(`github.com/ThreeDotsLabs/watermill-http`)](https://github.com/ThreeDotsLabs/watermill-http/)\n- io.Reader/io.Writer Pub/Sub [(`github.com/ThreeDotsLabs/watermill-io`)](https://github.com/ThreeDotsLabs/watermill-io/)\n- Kafka Pub/Sub [(`github.com/ThreeDotsLabs/watermill-kafka/v2`)](https://github.com/ThreeDotsLabs/watermill-kafka/)\n- NATS Pub/Sub [(`github.com/ThreeDotsLabs/watermill-nats`)](https://github.com/ThreeDotsLabs/watermill-nats/)\n- Redis Stream Pub/Sub [(`github.com/ThreeDotsLabs/watermill-redisstream`)](https://github.com/ThreeDotsLabs/watermill-redisstream/)\n- SQL Pub/Sub [(`github.com/ThreeDotsLabs/watermill-sql/v2`)](https://github.com/ThreeDotsLabs/watermill-sql/)\n\nAll Pub/Subs implementation documentation can be found in the [documentation](https://watermill.io/pubsubs/).\n\n## Unofficial libraries\n\nCan't find your favorite Pub/Sub or library integration? Check [Awesome Watermill](https://watermill.io/docs/awesome/).\n\nIf you know another library or are an author of one, please [add it to the list](https://github.com/ThreeDotsLabs/watermill/edit/master/docs/content/docs/awesome.md).\n\n## Contributing\n\nPlease check our [contributing guide](CONTRIBUTING.md).\n\n## Stability\n\nWatermill v1.0.0 has been released and is production-ready. The public API is stable and will not change without changing the major version.\n\nTo ensure that all Pub/Subs are stable and safe to use in production, we created a [set of tests](https://github.com/ThreeDotsLabs/watermill/blob/master/pubsub/tests/test_pubsub.go#L34) that need to pass for each of the implementations before merging to master.\nAll tests are also executed in [*stress*](https://github.com/ThreeDotsLabs/watermill/blob/master/pubsub/tests/test_pubsub.go#L171) mode - that means that we are running all the tests **20x** in parallel.\n\nAll tests are run with the race condition detector enabled (`-race` flag in tests).\n\nFor more information about debugging tests, you should check [tests troubleshooting guide](http://watermill.io/docs/troubleshooting/#debugging-pubsub-tests).\n\n## Benchmarks\n\nInitial tools for benchmarking Pub/Subs can be found in [watermill-benchmark](https://github.com/ThreeDotsLabs/watermill-benchmark).\n\nAll benchmarks are being done on a single 16 CPU VM instance, running one binary and dependencies in Docker Compose.\n\nThese numbers are meant to serve as a rough estimate of how fast messages can be processed by different Pub/Subs.\nKeep in mind that the results can be vastly different, depending on the setup and configuration (both much lower and higher).\n\nHere's the short version for message size of 16 bytes.\n\n| Pub/Sub                         | Publish (messages / s) | Subscribe (messages / s) |\n|---------------------------------|------------------------|--------------------------|\n| GoChannel                       | 315,776                | 138,743                  |\n| Redis Streams                   | 59,158                 | 12,134                   |\n| NATS Jetstream (16 Subscribers) | 50,668                 | 34,713                   |\n| Kafka (one node)                | 41,492                 | 101,669                  |\n| SQL (MySQL, batch size=100)     | 6,371                  | 2,794                    |\n| SQL (PostgreSQL, batch size=1)  | 2,831                  | 9,460                    |\n| Google Cloud Pub/Sub            | 3,027                  | 28,589                   |\n| AMQP (RabbitMQ)                 | 2,770                  | 14,604                   |\n\n## Support\n\nIf you didn't find the answer to your question in [the documentation](https://watermill.io/), feel free to ask us directly!\n\nPlease join us on the `#watermill` channel on the [Three Dots Labs Discord](https://discord.gg/QV6VFg4YQE).\n\n## Why the name?\n\nIt processes streams!\n\n## License\n\n[MIT License](./LICENSE)\n"
        },
        {
          "name": "RELEASE-PROCEDURE.md",
          "type": "blob",
          "size": 0.4765625,
          "content": "# Release procedure\n\n1. Generate clean go.mod: `make generate_gomod`\n2. Push to master\n3. Update missing documentation\n4. Check snippets in documentation (sometimes `first_line_contains` or `last_line_contains` can change position and load too much)\n5. Add breaking changes to `UPGRADE-[new-version].md`\n6. Push to master\n7. [Add release in GitHub](https://github.com/ThreeDotsLabs/watermill/releases)\n8. Update Pub/Subs versions\n9. Update and validate examples: `make validate_examples`\n"
        },
        {
          "name": "UPGRADE-0.3.md",
          "type": "blob",
          "size": 0.943359375,
          "content": "# UPGRADE FROM 0.2.x to 0.3\n\n# `watermill/message`\n\n- `message.Message.Ack` and `message.Message.Nack` now return `bool` instead of `error`\n- `message.Subscriber.Subscribe` now accepts `context.Context` as the first argument\n- `message.Subscriber.Subscribe` now returns `<-chan *Message` instead of `chan *Message`\n- `message.Router.AddHandler` and `message.Router.AddNoPublisherHandler` now panic, instead of returning error\n\n# `watermill/message/infrastructure`\n\n- updated all Pub/Subs to new `message.Subscriber` interface\n- `gochannel.NewGoChannel` now accepts `gochannel.Config`, instead of positional parameters\n- `http.NewSubscriber` now accepts `http.SubscriberConfig`, instead of positional parameters\n\n# `watermill/message/router/middleware`\n\n- `metrics.NewMetrics` is removed, please use the [metrics](components/metrics) component instead\n\n# `watermill`\n\n- `watermill.LoggerAdapter` interface now requires a `With(fields LogFields) LoggerAdapter` method\n"
        },
        {
          "name": "UPGRADE-0.4.md",
          "type": "blob",
          "size": 2.1455078125,
          "content": "# UPGRADE FROM 0.3.x to 0.4\n\n## `watermill/components/cqrs`\n\n### `CommandHandler.HandlerName` and `EventHandler.HandlerName` was added to the interface.\n\nIf you are using metrics component, you may want to keep backward capability with handler names. In other cases, you can implement your own method of generating handler name.\n\nKeeping backward capability for **event handlers**:\n\n```\nfunc (h CommandHandler) HandlerName() string {\n    return fmt.Sprintf(\"command_processor-%s\", h)\n}\n```\n\nKeeping backward capability for **command handlers**:\n\n```\nfunc (h EventHandler) HandlerName() string {\n    return fmt.Sprintf(\"event_processor-%s\", ObjectName(h))\n}\n```\n\n### Added `CommandsSubscriberConstructor` and `EventsSubscriberConstructor`\n\nFrom now on, `CommandsSubscriberConstructor` and `EventsSubscriberConstructor` are passed to constructors in CQRS component.\n\nThey allow creating customized subscribers for every handler. For usage examples please check [_examples/cqrs-protobuf](_examples/cqrs-protobuf).\n\n\n### Added context to `CommandHandler.Handle`, `CommandBus.Send`, `EventHandler.Handle` and `EventBus.Send`\n\nAdded missing context, which is passed to Publish function and handlers.\n\n### Other\n\n- `NewCommandProcessor` and `NewEventProcessor` now return an error instead of panic\n- `DuplicateCommandHandlerError` is returned instead of panic when two handlers are handling the same command\n- `CommandProcessor.routerHandlerFunc` and `EventProcessor.routerHandlerFunc` are now private\n- using `GenerateCommandsTopic` and `GenerateEventsTopic` functions instead of constant topic to allow more flexibility\n\n\n## `watermill/message/infrastructure/amqp`\n\n### `Config.QueueBindConfig.RoutingKey` was replaced with `GenerateRoutingKey`\n\nFor backward compatibility, when using the constant value you should use a function:\n\n\n```\nfunc(topic string) string {\n    return \"routing_key\"\n}\n```\n\n\n## `message/router/middleware`\n\n- `PoisonQueue` is now `PoisonQueue(pub message.Publisher, topic string) (message.HandlerMiddleware, error)`, not a struct\n\n\n## `message/router.go`\n\n- From now on, when all handlers are stopped, the router will also stop (`TestRouter_stop_when_all_handlers_stopped` test)\n"
        },
        {
          "name": "UPGRADE-1.0.md",
          "type": "blob",
          "size": 1.5966796875,
          "content": "# Upgrade instructions from v0.4.X\n\nIn v1.0.0 we introduced a couple of breaking changes, to keep a stable API until version v2.\n\n## Migrating Pub/Subs\n\nAll Pub/Subs (excluding go-channel implementation) were moved to separated repositories.\nYou can replace all import paths, with provided `sed`:\n\n\tfind . -type f -iname '*.go' -exec sed -i -E \"s/github\\.com\\/ThreeDotsLabs\\/watermill\\/message\\/infrastructure\\/(amqp|googlecloud|http|io|kafka|nats|sql)/github.com\\/ThreeDotsLabs\\/watermill-\\1\\/pkg\\/\\1/\" \"{}\" +;\n\tfind . -type f -iname '*.go' -exec sed -i -E \"s/github\\.com\\/ThreeDotsLabs\\/watermill\\/message\\/infrastructure\\/gochannel/github\\.com\\/ThreeDotsLabs\\/watermill\\/pubsub\\/gochannel/\" \"{}\" +;\n\n# Breaking changes\n- `message.PubSub` interface was removed\n- `message.NewPubSub` constructor was removed\n- `message.NoPublishHandlerFunc` is now passed to `message.Router.AddNoPublisherHandler`, instead of `message.HandlerFunc`.\n- `message.Router.Run` now requires `context.Context` in parameter\n- `PrometheusMetricsBuilder.DecoratePubSub` was removed (because of `message.PubSub` interface removal)\n- `cars.ObjectName` was renamed to `cqrs.FullyQualifiedStructName`\n- `github.com/ThreeDotsLabs/watermill/message/infrastructure/gochannel` was moved to `github.com/ThreeDotsLabs/watermill/pubsub/gochannel`\n- `middleware.Retry` configuration parameters have been renamed\n- Universal Pub/Sub tests have been moved from `github.com/ThreeDotsLabs/watermill/message/infrastructure` to `github.com/ThreeDotsLabs/watermill/pubsub/tests`\n- All universal tests require now `TestContext`.\n- Removed `context` from `googlecloud.NewPublisher`\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.2734375,
          "content": "ignore:\n  - \"pubsub/tests\" # test helpers used to test Pub/Subs\n\ncomment: no # do not comment PR with the result\n\ncoverage:\n  precision: 0\n  status:\n    patch: false # do not run coverage on patch nor changes\n    project:\n      default:\n        target: auto\n        threshold: 5%\n"
        },
        {
          "name": "components",
          "type": "tree",
          "content": null
        },
        {
          "name": "dev",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.5263671875,
          "content": "// Watermill is a Golang library for working efficiently with message streams.\n//\n// It is intended for building event driven applications,\n// enabling event sourcing, RPC over messages, sagas\n// and basically whatever else comes to your mind.\n//\n// You can use conventional pub/sub implementations\n// like Kafka or RabbitMQ, but also HTTP or MySQL binlog if that fits your use case.\n//\n// Website with detailed documentation: https://watermill.io/\n//\n// Getting started guide: https://watermill.io/docs/getting-started/\npackage watermill\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.15234375,
          "content": "module github.com/ThreeDotsLabs/watermill\n\ngo 1.21\n\nrequire (\n\tgithub.com/cenkalti/backoff/v3 v3.2.2\n\tgithub.com/go-chi/chi/v5 v5.1.0\n\tgithub.com/gogo/protobuf v1.3.2\n\tgithub.com/golang/protobuf v1.5.4\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/hashicorp/go-multierror v1.1.1\n\tgithub.com/lithammer/shortuuid/v3 v3.0.7\n\tgithub.com/oklog/ulid v1.3.1\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/prometheus/client_golang v1.20.2\n\tgithub.com/sony/gobreaker v1.0.0\n\tgithub.com/stretchr/testify v1.9.0\n\tgoogle.golang.org/protobuf v1.34.2\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n\tgithub.com/klauspost/compress v1.17.9 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.55.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgolang.org/x/sys v0.24.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 8.7919921875,
          "content": "github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/cenkalti/backoff/v3 v3.2.2 h1:cfUAAO3yvKMYKPrvhDuHSwQnhZNk/RMHKdZqKTxfm6M=\ngithub.com/cenkalti/backoff/v3 v3.2.2/go.mod h1:cIeZDE3IrqwwJl6VUwCN6trj1oXrTS4rc0ij+ULvLYs=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-chi/chi/v5 v5.1.0 h1:acVI1TYaD+hhedDJ3r54HyA6sExp3HfXq7QWEEY/xMw=\ngithub.com/go-chi/chi/v5 v5.1.0/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/uuid v1.2.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=\ngithub.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\ngithub.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.17.9 h1:6KIumPrER1LHsvBVuDa0r5xaG0Es51mhhB9BQB2qeMA=\ngithub.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/lithammer/shortuuid/v3 v3.0.7 h1:trX0KTHy4Pbwo/6ia8fscyHoGA+mf1jWbPJVuvyJQQ8=\ngithub.com/lithammer/shortuuid/v3 v3.0.7/go.mod h1:vMk8ke37EmiewwolSO1NLW8vP4ZaKlRuDIi8tWWmAts=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/oklog/ulid v1.3.1 h1:EGfNDEx6MqHz8B3uNV6QAib1UR2Lm97sHi3ocA6ESJ4=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v1.20.2 h1:5ctymQzZlyOON1666svgwn3s6IKWgfbjsejTMiXIyjg=\ngithub.com/prometheus/client_golang v1.20.2/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.55.0 h1:KEi6DK7lXW/m7Ig5i47x0vRzuBsHuvJdi5ee6Y3G1dc=\ngithub.com/prometheus/common v0.55.0/go.mod h1:2SECS4xJG1kd8XF9IcM1gMX6510RAEL65zxzNImwdc8=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/sony/gobreaker v1.0.0 h1:feX5fGGXSl3dYd4aHZItw+FpHLvvoaqkawKjVNiFMNQ=\ngithub.com/sony/gobreaker v1.0.0/go.mod h1:ZKptC7FHNvhBz7dN2LGjPVBz2sZJmc0/PkyDJOjmxWY=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.24.0 h1:Twjiwq9dn6R1fQcyiK+wQyHWfaz/BJB+YIpzU/Cv3Xg=\ngolang.org/x/sys v0.24.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 6.47265625,
          "content": "package watermill\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// LogFields is the logger's key-value list of fields.\ntype LogFields map[string]interface{}\n\n// Add adds new fields to the list of LogFields.\nfunc (l LogFields) Add(newFields LogFields) LogFields {\n\tresultFields := make(LogFields, len(l)+len(newFields))\n\n\tfor field, value := range l {\n\t\tresultFields[field] = value\n\t}\n\tfor field, value := range newFields {\n\t\tresultFields[field] = value\n\t}\n\n\treturn resultFields\n}\n\n// Copy copies the LogFields.\nfunc (l LogFields) Copy() LogFields {\n\tcpy := make(LogFields, len(l))\n\tfor k, v := range l {\n\t\tcpy[k] = v\n\t}\n\n\treturn cpy\n}\n\n// LoggerAdapter is an interface, that you need to implement to support Watermill logging.\n// You can use StdLoggerAdapter as a reference implementation.\ntype LoggerAdapter interface {\n\tError(msg string, err error, fields LogFields)\n\tInfo(msg string, fields LogFields)\n\tDebug(msg string, fields LogFields)\n\tTrace(msg string, fields LogFields)\n\tWith(fields LogFields) LoggerAdapter\n}\n\n// NopLogger is a logger which discards all logs.\ntype NopLogger struct{}\n\nfunc (NopLogger) Error(msg string, err error, fields LogFields) {}\nfunc (NopLogger) Info(msg string, fields LogFields)             {}\nfunc (NopLogger) Debug(msg string, fields LogFields)            {}\nfunc (NopLogger) Trace(msg string, fields LogFields)            {}\nfunc (l NopLogger) With(fields LogFields) LoggerAdapter         { return l }\n\n// StdLoggerAdapter is a logger implementation, which sends all logs to provided standard output.\ntype StdLoggerAdapter struct {\n\tErrorLogger *log.Logger\n\tInfoLogger  *log.Logger\n\tDebugLogger *log.Logger\n\tTraceLogger *log.Logger\n\n\tfields LogFields\n}\n\n// NewStdLogger creates StdLoggerAdapter which sends all logs to stderr.\nfunc NewStdLogger(debug, trace bool) LoggerAdapter {\n\treturn NewStdLoggerWithOut(os.Stderr, debug, trace)\n}\n\n// NewStdLoggerWithOut creates StdLoggerAdapter which sends all logs to provided io.Writer.\nfunc NewStdLoggerWithOut(out io.Writer, debug bool, trace bool) LoggerAdapter {\n\tl := log.New(out, \"[watermill] \", log.LstdFlags|log.Lmicroseconds|log.Lshortfile)\n\ta := &StdLoggerAdapter{InfoLogger: l, ErrorLogger: l}\n\n\tif debug {\n\t\ta.DebugLogger = l\n\t}\n\tif trace {\n\t\ta.TraceLogger = l\n\t}\n\n\treturn a\n}\n\nfunc (l *StdLoggerAdapter) Error(msg string, err error, fields LogFields) {\n\tl.log(l.ErrorLogger, \"ERROR\", msg, fields.Add(LogFields{\"err\": err}))\n}\n\nfunc (l *StdLoggerAdapter) Info(msg string, fields LogFields) {\n\tl.log(l.InfoLogger, \"INFO \", msg, fields)\n}\n\nfunc (l *StdLoggerAdapter) Debug(msg string, fields LogFields) {\n\tl.log(l.DebugLogger, \"DEBUG\", msg, fields)\n}\n\nfunc (l *StdLoggerAdapter) Trace(msg string, fields LogFields) {\n\tl.log(l.TraceLogger, \"TRACE\", msg, fields)\n}\n\nfunc (l *StdLoggerAdapter) With(fields LogFields) LoggerAdapter {\n\treturn &StdLoggerAdapter{\n\t\tErrorLogger: l.ErrorLogger,\n\t\tInfoLogger:  l.InfoLogger,\n\t\tDebugLogger: l.DebugLogger,\n\t\tTraceLogger: l.TraceLogger,\n\t\tfields:      l.fields.Add(fields),\n\t}\n}\n\nfunc (l *StdLoggerAdapter) log(logger *log.Logger, level string, msg string, fields LogFields) {\n\tif logger == nil {\n\t\treturn\n\t}\n\n\tfieldsStr := \"\"\n\n\tallFields := l.fields.Add(fields)\n\n\tkeys := make([]string, len(allFields))\n\ti := 0\n\tfor field := range allFields {\n\t\tkeys[i] = field\n\t\ti++\n\t}\n\n\tsort.Strings(keys)\n\n\tfor _, key := range keys {\n\t\tvar valueStr string\n\t\tvalue := allFields[key]\n\n\t\tif stringer, ok := value.(fmt.Stringer); ok {\n\t\t\tvalueStr = stringer.String()\n\t\t} else {\n\t\t\tvalueStr = fmt.Sprintf(\"%v\", value)\n\t\t}\n\n\t\tif strings.Contains(valueStr, \" \") {\n\t\t\tvalueStr = `\"` + valueStr + `\"`\n\t\t}\n\n\t\tfieldsStr += key + \"=\" + valueStr + \" \"\n\t}\n\n\t_ = logger.Output(3, fmt.Sprintf(\"\\t\"+`level=%s msg=\"%s\" %s`, level, msg, fieldsStr))\n}\n\ntype LogLevel uint\n\nconst (\n\tTraceLogLevel LogLevel = iota + 1\n\tDebugLogLevel\n\tInfoLogLevel\n\tErrorLogLevel\n)\n\ntype CapturedMessage struct {\n\tLevel  LogLevel\n\tTime   time.Time\n\tFields LogFields\n\tMsg    string\n\tErr    error\n}\n\nfunc (c CapturedMessage) ContentEquals(other CapturedMessage) bool {\n\treturn c.Level == other.Level &&\n\t\treflect.DeepEqual(c.Fields, other.Fields) &&\n\t\tc.Msg == other.Msg &&\n\t\terrors.Is(c.Err, other.Err)\n}\n\n// CaptureLoggerAdapter is a logger which captures all logs.\n// This logger is mostly useful for testing logging.\ntype CaptureLoggerAdapter struct {\n\tcaptured map[LogLevel][]CapturedMessage\n\tfields   LogFields\n\tlock     *sync.Mutex\n}\n\nfunc NewCaptureLogger() *CaptureLoggerAdapter {\n\treturn &CaptureLoggerAdapter{\n\t\tcaptured: map[LogLevel][]CapturedMessage{},\n\t\tlock:     &sync.Mutex{},\n\t}\n}\n\nfunc (c *CaptureLoggerAdapter) With(fields LogFields) LoggerAdapter {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\treturn &CaptureLoggerAdapter{\n\t\tcaptured: c.captured, // we are passing the same map, so we'll capture logs from this instance as well\n\t\tfields:   c.fields.Copy().Add(fields),\n\t\tlock:     c.lock,\n\t}\n}\n\nfunc (c *CaptureLoggerAdapter) capture(level LogLevel, msg string, err error, fields LogFields) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tlogMsg := CapturedMessage{\n\t\tLevel:  level,\n\t\tTime:   time.Now(),\n\t\tFields: c.fields.Add(fields),\n\t\tMsg:    msg,\n\t\tErr:    err,\n\t}\n\n\tc.captured[level] = append(c.captured[level], logMsg)\n}\n\nfunc (c *CaptureLoggerAdapter) Captured() map[LogLevel][]CapturedMessage {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\treturn c.captured\n}\n\ntype Logfer interface {\n\tLogf(format string, a ...interface{})\n}\n\nfunc (c *CaptureLoggerAdapter) PrintCaptured(t Logfer) {\n\tfor level, messages := range c.Captured() {\n\t\tfor _, msg := range messages {\n\t\t\tt.Logf(\"%s %d %s %v\", msg.Time.Format(\"15:04:05.999999999\"), level, msg.Msg, msg.Fields)\n\t\t}\n\t}\n}\n\nfunc (c *CaptureLoggerAdapter) Has(msg CapturedMessage) bool {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tfor _, capturedMsg := range c.captured[msg.Level] {\n\t\tif msg.ContentEquals(capturedMsg) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c *CaptureLoggerAdapter) HasError(err error) bool {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tfor _, capturedMsg := range c.captured[ErrorLogLevel] {\n\t\tif capturedMsg.Err == err {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c *CaptureLoggerAdapter) Error(msg string, err error, fields LogFields) {\n\tc.capture(ErrorLogLevel, msg, err, fields)\n}\n\nfunc (c *CaptureLoggerAdapter) Info(msg string, fields LogFields) {\n\tc.capture(InfoLogLevel, msg, nil, fields)\n}\n\nfunc (c *CaptureLoggerAdapter) Debug(msg string, fields LogFields) {\n\tc.capture(DebugLogLevel, msg, nil, fields)\n}\n\nfunc (c *CaptureLoggerAdapter) Trace(msg string, fields LogFields) {\n\tc.capture(TraceLogLevel, msg, nil, fields)\n}\n"
        },
        {
          "name": "log_test.go",
          "type": "blob",
          "size": 3.7939453125,
          "content": "package watermill_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/ThreeDotsLabs/watermill\"\n)\n\nfunc TestLogFields_Copy(t *testing.T) {\n\tfields1 := watermill.LogFields{\"foo\": \"bar\"}\n\n\tfields2 := fields1.Copy()\n\tfields2[\"foo\"] = \"baz\"\n\n\tassert.Equal(t, fields1[\"foo\"], \"bar\")\n\tassert.Equal(t, fields2[\"foo\"], \"baz\")\n}\n\nfunc TestStdLogger_with(t *testing.T) {\n\tbuf := bytes.NewBuffer([]byte{})\n\tcleanLogger := watermill.NewStdLoggerWithOut(buf, true, true)\n\n\twithLogFieldsLogger := cleanLogger.With(watermill.LogFields{\"foo\": \"1\"})\n\n\tfor name, logger := range map[string]watermill.LoggerAdapter{\"clean\": cleanLogger, \"with\": withLogFieldsLogger} {\n\t\tlogger.Error(name, nil, watermill.LogFields{\"bar\": \"2\"})\n\t\tlogger.Info(name, watermill.LogFields{\"bar\": \"2\"})\n\t\tlogger.Debug(name, watermill.LogFields{\"bar\": \"2\"})\n\t\tlogger.Trace(name, watermill.LogFields{\"bar\": \"2\"})\n\t}\n\n\tcleanLoggerOut := buf.String()\n\tassert.Contains(t, cleanLoggerOut, `level=ERROR msg=\"clean\" bar=2 err=<nil>`)\n\tassert.Contains(t, cleanLoggerOut, `level=INFO  msg=\"clean\" bar=2`)\n\tassert.Contains(t, cleanLoggerOut, `level=TRACE msg=\"clean\" bar=2`)\n\n\tassert.Contains(t, cleanLoggerOut, `level=ERROR msg=\"with\" bar=2 err=<nil> foo=1`)\n\tassert.Contains(t, cleanLoggerOut, `level=INFO  msg=\"with\" bar=2 foo=1`)\n\tassert.Contains(t, cleanLoggerOut, `level=TRACE msg=\"with\" bar=2 foo=1`)\n}\n\ntype stringer struct{}\n\nfunc (s stringer) String() string {\n\treturn \"stringer\"\n}\n\nfunc TestStdLoggerAdapter_stringer_field(t *testing.T) {\n\tbuf := bytes.NewBuffer([]byte{})\n\tlogger := watermill.NewStdLoggerWithOut(buf, true, true)\n\n\tlogger.Info(\"foo\", watermill.LogFields{\"foo\": stringer{}})\n\n\tout := buf.String()\n\tassert.Contains(t, out, `foo=stringer`)\n}\n\nfunc TestStdLoggerAdapter_field_with_space(t *testing.T) {\n\tbuf := bytes.NewBuffer([]byte{})\n\tlogger := watermill.NewStdLoggerWithOut(buf, true, true)\n\n\tlogger.Info(\"foo\", watermill.LogFields{\"foo\": `bar baz`})\n\n\tout := buf.String()\n\tassert.Contains(t, out, `foo=\"bar baz\"`)\n}\n\nfunc TestCaptureLoggerAdapter(t *testing.T) {\n\tvar logger watermill.LoggerAdapter = watermill.NewCaptureLogger()\n\n\terr := errors.New(\"error\")\n\n\tlogger = logger.With(watermill.LogFields{\"default\": \"field\"})\n\tlogger.Error(\"error\", err, watermill.LogFields{\"bar\": \"2\"})\n\tlogger.Info(\"info\", watermill.LogFields{\"bar\": \"2\"})\n\tlogger.Debug(\"debug\", watermill.LogFields{\"bar\": \"2\"})\n\tlogger.Trace(\"trace\", watermill.LogFields{\"bar\": \"2\"})\n\n\texpectedLogs := map[watermill.LogLevel][]watermill.CapturedMessage{\n\t\twatermill.TraceLogLevel: {\n\t\t\twatermill.CapturedMessage{\n\t\t\t\tLevel:  watermill.TraceLogLevel,\n\t\t\t\tFields: watermill.LogFields{\"bar\": \"2\", \"default\": \"field\"},\n\t\t\t\tMsg:    \"trace\",\n\t\t\t\tErr:    error(nil),\n\t\t\t},\n\t\t},\n\t\twatermill.DebugLogLevel: {\n\t\t\twatermill.CapturedMessage{\n\t\t\t\tLevel:  watermill.DebugLogLevel,\n\t\t\t\tFields: watermill.LogFields{\"default\": \"field\", \"bar\": \"2\"},\n\t\t\t\tMsg:    \"debug\",\n\t\t\t\tErr:    error(nil),\n\t\t\t},\n\t\t},\n\t\twatermill.InfoLogLevel: {\n\t\t\twatermill.CapturedMessage{\n\t\t\t\tLevel:  watermill.InfoLogLevel,\n\t\t\t\tFields: watermill.LogFields{\"default\": \"field\", \"bar\": \"2\"},\n\t\t\t\tMsg:    \"info\",\n\t\t\t\tErr:    error(nil),\n\t\t\t},\n\t\t},\n\t\twatermill.ErrorLogLevel: {\n\t\t\twatermill.CapturedMessage{\n\t\t\t\tLevel:  watermill.ErrorLogLevel,\n\t\t\t\tFields: watermill.LogFields{\"default\": \"field\", \"bar\": \"2\"},\n\t\t\t\tMsg:    \"error\",\n\t\t\t\tErr:    err,\n\t\t\t},\n\t\t},\n\t}\n\n\tcapturedLogger := logger.(*watermill.CaptureLoggerAdapter)\n\n\tassert.Equal(t, len(expectedLogs), len(capturedLogger.Captured()))\n\tfor _, logs := range expectedLogs {\n\t\tfor _, log := range logs {\n\t\t\tassert.True(t, capturedLogger.Has(log))\n\t\t}\n\t}\n\n\tassert.False(t, capturedLogger.Has(watermill.CapturedMessage{\n\t\tLevel:  0,\n\t\tFields: nil,\n\t\tMsg:    \"\",\n\t\tErr:    nil,\n\t}))\n\n\tassert.True(t, capturedLogger.HasError(err))\n\tassert.False(t, capturedLogger.HasError(errors.New(\"foo\")))\n}\n"
        },
        {
          "name": "message",
          "type": "tree",
          "content": null
        },
        {
          "name": "netlify.toml",
          "type": "blob",
          "size": 0.908203125,
          "content": "[build]\n  command = \"./build.sh --copy && npm run build\"\n  base = \"docs/\"\n  publish = \"docs/public/\"\n\n[build.environment]\n  NODE_VERSION = \"20.11.0\"\n  NPM_VERSION = \"10.2.4\"\n  HUGO_VERSION = \"0.127.0\"\n\n[context.deploy-preview]\n  command = \"./build.sh --copy && npm run build:branch\"\n\n[context.branch-deploy]\n  command = \"./build.sh --copy && npm run build:branch\"\n\n[[redirects]]\n  from = \"/api/event\"\n  to = \"https://academy-api.threedots.tech/api/event\"\n  force = true\n  status = 200\n\n[[redirects]]\n  from = \"/docs/fanin\"\n  to = \"/advanced/fanin/\"\n  status = 301\n\n[[redirects]]\n  from = \"/docs/forwarder\"\n  to = \"/advanced/forwarder/\"\n  status = 301\n\n[[redirects]]\n  from = \"/docs/metrics\"\n  to = \"/advanced/metrics/\"\n  status = 301\n\n[[redirects]]\n  from = \"/docs/pub-sub-implementing\"\n  to = \"/development/pub-sub-implementing/\"\n  status = 301\n\n[[redirects]]\n  from = \"/pubsubs/amazonsqs/\"\n  to = \"/pubsubs/aws/\"\n  status = 301\n"
        },
        {
          "name": "pubsub",
          "type": "tree",
          "content": null
        },
        {
          "name": "slog.go",
          "type": "blob",
          "size": 3.0576171875,
          "content": "package watermill\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n)\n\n// LevelTrace must be added, because [slog] package does not have one by default. Generate it by subtracting 4 levels from [slog.Debug] following the example of [slog.LevelWarn] and [slog.LevelError] which are set to 4 and 8.\nconst LevelTrace = slog.LevelDebug - 4\n\nfunc slogAttrsFromFields(fields LogFields) []any {\n\tresult := make([]any, 0, len(fields)*2)\n\n\tfor key, value := range fields {\n\t\tresult = append(result, key, value)\n\t}\n\n\treturn result\n}\n\n// SlogLoggerAdapter wraps [slog.Logger].\ntype SlogLoggerAdapter struct {\n\tslog *slog.Logger\n\n\twatermillLevelToSlog map[slog.Level]slog.Level\n}\n\n// Error logs a message to [slog.LevelError].\nfunc (s *SlogLoggerAdapter) Error(msg string, err error, fields LogFields) {\n\ts.log(slog.LevelError, msg, append(slogAttrsFromFields(fields), \"error\", err)...)\n}\n\n// Info logs a message to [slog.LevelInfo].\nfunc (s *SlogLoggerAdapter) Info(msg string, fields LogFields) {\n\ts.log(slog.LevelInfo, msg, slogAttrsFromFields(fields)...)\n}\n\n// Debug logs a message to [slog.LevelDebug].\nfunc (s *SlogLoggerAdapter) Debug(msg string, fields LogFields) {\n\ts.log(slog.LevelDebug, msg, slogAttrsFromFields(fields)...)\n}\n\n// Trace logs a message to [LevelTrace].\nfunc (s *SlogLoggerAdapter) Trace(msg string, fields LogFields) {\n\ts.log(\n\t\tLevelTrace,\n\t\tmsg,\n\t\tslogAttrsFromFields(fields)...,\n\t)\n}\n\nfunc (s *SlogLoggerAdapter) log(level slog.Level, msg string, args ...any) {\n\tmappedLevel, ok := s.watermillLevelToSlog[level]\n\tif ok {\n\t\tlevel = mappedLevel\n\t}\n\n\ts.slog.Log(\n\t\t// Void context, following the slog example\n\t\t// as it treats context slightly differently from\n\t\t// normal usage, minding contextual\n\t\t// values, but ignoring contextual deadline.\n\t\t// See the [slog] package documentation\n\t\t// for more details.\n\t\tcontext.Background(),\n\t\tlevel,\n\t\tmsg,\n\t\targs...,\n\t)\n}\n\n// With return a [SlogLoggerAdapter] with a set of fields injected into all consequent logging messages.\nfunc (s *SlogLoggerAdapter) With(fields LogFields) LoggerAdapter {\n\treturn &SlogLoggerAdapter{slog: s.slog.With(slogAttrsFromFields(fields)...), watermillLevelToSlog: s.watermillLevelToSlog}\n}\n\n// NewSlogLogger creates an adapter to the standard library's structured logging package. A `nil` logger is substituted for the result of [slog.Default].\nfunc NewSlogLogger(logger *slog.Logger) LoggerAdapter {\n\tif logger == nil {\n\t\tlogger = slog.Default()\n\t}\n\treturn &SlogLoggerAdapter{\n\t\tslog: logger,\n\t}\n}\n\n// NewSlogLoggerWithLevelMapping creates an adapter to the standard library's structured logging package. A `nil` logger is substituted for the result of [slog.Default].\n// The `watermillLevelToSlog` parameter is a map that maps Watermill's log levels to the levels of the structured logger.\n// It's helpful, when want to for example log Watermill's info logs as debug in slog.\nfunc NewSlogLoggerWithLevelMapping(logger *slog.Logger, watermillLevelToSlog map[slog.Level]slog.Level) LoggerAdapter {\n\tif logger == nil {\n\t\tlogger = slog.Default()\n\t}\n\treturn &SlogLoggerAdapter{\n\t\tslog:                 logger,\n\t\twatermillLevelToSlog: watermillLevelToSlog,\n\t}\n}\n"
        },
        {
          "name": "slog_test.go",
          "type": "blob",
          "size": 2.404296875,
          "content": "package watermill\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"log/slog\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSlogLoggerAdapter(t *testing.T) {\n\tb := &bytes.Buffer{}\n\n\tlogger := NewSlogLogger(slog.New(slog.NewTextHandler(\n\t\tb, // output\n\t\t&slog.HandlerOptions{\n\t\t\tLevel: LevelTrace,\n\t\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\t\tif a.Key == \"time\" && len(groups) == 0 {\n\t\t\t\t\t// omit time stamp to make the test idempotent\n\t\t\t\t\ta.Value = slog.StringValue(\"[omit]\")\n\t\t\t\t}\n\t\t\t\treturn a\n\t\t\t},\n\t\t},\n\t)))\n\n\tlogger = logger.With(LogFields{\n\t\t\"common1\": \"commonvalue\",\n\t})\n\tlogger.Trace(\"test trace\", LogFields{\n\t\t\"field1\": \"value1\",\n\t})\n\tlogger.Error(\"test error\", errors.New(\"error message\"), LogFields{\n\t\t\"field2\": \"value2\",\n\t})\n\tlogger.Info(\"test info\", LogFields{\n\t\t\"field3\": \"value3\",\n\t})\n\n\tassert.Equal(t,\n\t\tstrings.TrimSpace(`\ntime=[omit] level=DEBUG-4 msg=\"test trace\" common1=commonvalue field1=value1\ntime=[omit] level=ERROR msg=\"test error\" common1=commonvalue field2=value2 error=\"error message\"\ntime=[omit] level=INFO msg=\"test info\" common1=commonvalue field3=value3\n      `),\n\t\tstrings.TrimSpace(b.String()),\n\t\t\"Logging output does not match saved template.\",\n\t)\n}\n\nfunc TestSlogLoggerAdapter_level_mapping(t *testing.T) {\n\tb := &bytes.Buffer{}\n\n\tlogger := NewSlogLoggerWithLevelMapping(\n\t\tslog.New(slog.NewTextHandler(\n\t\t\tb, // output\n\t\t\t&slog.HandlerOptions{\n\t\t\t\tLevel: LevelTrace,\n\t\t\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\t\t\tif a.Key == \"time\" && len(groups) == 0 {\n\t\t\t\t\t\t// omit time stamp to make the test idempotent\n\t\t\t\t\t\ta.Value = slog.StringValue(\"[omit]\")\n\t\t\t\t\t}\n\t\t\t\t\treturn a\n\t\t\t\t},\n\t\t\t},\n\t\t)),\n\t\tmap[slog.Level]slog.Level{\n\t\t\tslog.LevelInfo: slog.LevelDebug,\n\t\t},\n\t)\n\n\tlogger = logger.With(LogFields{\n\t\t\"common1\": \"commonvalue\",\n\t})\n\tlogger.Trace(\"test trace\", LogFields{\n\t\t\"field1\": \"value1\",\n\t})\n\tlogger.Error(\"test error\", errors.New(\"error message\"), LogFields{\n\t\t\"field2\": \"value2\",\n\t})\n\tlogger.Info(\"test info mapped to debug\", LogFields{\n\t\t\"field3\": \"value3\",\n\t})\n\n\tassert.Equal(t,\n\t\tstrings.TrimSpace(`\ntime=[omit] level=DEBUG-4 msg=\"test trace\" common1=commonvalue field1=value1\ntime=[omit] level=ERROR msg=\"test error\" common1=commonvalue field2=value2 error=\"error message\"\ntime=[omit] level=DEBUG msg=\"test info mapped to debug\" common1=commonvalue field3=value3\n      `),\n\t\tstrings.TrimSpace(b.String()),\n\t\t\"Logging output does not match saved template.\",\n\t)\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "uuid.go",
          "type": "blob",
          "size": 0.4306640625,
          "content": "package watermill\n\nimport (\n\t\"crypto/rand\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lithammer/shortuuid/v3\"\n\t\"github.com/oklog/ulid\"\n)\n\n// NewUUID returns a new UUID Version 4.\nfunc NewUUID() string {\n\treturn uuid.New().String()\n}\n\n// NewShortUUID returns a new short UUID.\nfunc NewShortUUID() string {\n\treturn shortuuid.New()\n}\n\n// NewULID returns a new ULID.\nfunc NewULID() string {\n\treturn ulid.MustNew(ulid.Now(), rand.Reader).String()\n}\n"
        },
        {
          "name": "uuid_test.go",
          "type": "blob",
          "size": 1.0009765625,
          "content": "package watermill_test\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/ThreeDotsLabs/watermill\"\n)\n\nfunc testUniqueness(t *testing.T, genFunc func() string) {\n\tproducers := 100\n\tuuidsPerProducer := 10000\n\n\tif testing.Short() {\n\t\tproducers = 10\n\t\tuuidsPerProducer = 1000\n\t}\n\n\tuuidsCount := producers * uuidsPerProducer\n\n\tuuids := make(chan string, uuidsCount)\n\tallGenerated := sync.WaitGroup{}\n\tallGenerated.Add(producers)\n\n\tfor i := 0; i < producers; i++ {\n\t\tgo func() {\n\t\t\tfor j := 0; j < uuidsPerProducer; j++ {\n\t\t\t\tuuids <- genFunc()\n\t\t\t}\n\t\t\tallGenerated.Done()\n\t\t}()\n\t}\n\n\tuniqueUUIDs := make(map[string]struct{}, uuidsCount)\n\n\tallGenerated.Wait()\n\tclose(uuids)\n\n\tfor uuid := range uuids {\n\t\tif _, ok := uniqueUUIDs[uuid]; ok {\n\t\t\tt.Error(uuid, \" has duplicate\")\n\t\t}\n\t\tuniqueUUIDs[uuid] = struct{}{}\n\t}\n}\n\nfunc TestUUID(t *testing.T) {\n\ttestUniqueness(t, watermill.NewUUID)\n}\n\nfunc TestShortUUID(t *testing.T) {\n\ttestUniqueness(t, watermill.NewShortUUID)\n}\n\nfunc TestULID(t *testing.T) {\n\ttestUniqueness(t, watermill.NewULID)\n}\n"
        }
      ]
    }
  ]
}