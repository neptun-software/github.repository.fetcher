{
  "metadata": {
    "timestamp": 1736567831791,
    "page": 414,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "caarlos0/env",
      "stars": 5060,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.4462890625,
          "content": "[*]\ncharset = utf-8\nend_of_line = lf\ntrim_trailing_whitespace = true\nmax_line_length = 120\n\n[{go.mod,go.sum,*.go}]\ninsert_final_newline = true\nindent_size = tab\nindent_style = tab\ntab_width = 4\n\n[Makefile]\nmax_line_length = off\ninsert_final_newline = true\nindent_size = tab\nindent_style = tab\ntab_width = 4\n\n[*.md]\nmax_line_length = off\ntrim_trailing_whitespace = false\nindent_size = tab\nindent_style = space\ntab_width = 2\n\n[.mailmap]\nmax_line_length = off\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": "coverage.txt\nbin\ncard.png\ndist\ncodecov*\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.5419921875,
          "content": "linters-settings:\n  gocritic:\n    enabled-checks:\n      - emptyStringTest\n      - evalOrder\n      - paramTypeCombine\n      - preferStringWriter\n      - sprintfQuotedString\n      - stringConcatSimplify\n      - yodaStyleExpr\n  revive:\n    rules:\n      - name: line-length-limit\n        arguments: [120]\n\nissues:\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - revive\n      text: \"line-length-limit:\"\n\nlinters:\n  enable:\n    - thelper\n    - gofumpt\n    - gocritic\n    - tparallel\n    - unconvert\n    - unparam\n    - wastedassign\n    - revive\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.1923828125,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema-pro.json\nversion: 2\nincludes:\n  - from_url:\n      url: https://raw.githubusercontent.com/caarlos0/.goreleaserfiles/main/lib.yml\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.7724609375,
          "content": "Carlos Alexandro Becker <caarlos0@users.noreply.github.com> Carlos A Becker <caarlos0@gmail.com>\nCarlos Alexandro Becker <caarlos0@users.noreply.github.com> Carlos A Becker <caarlos0@users.noreply.github.com>\nCarlos Alexandro Becker <caarlos0@users.noreply.github.com> Carlos Alexandro Becker <caarlos0@gmail.com>\nCarlos Alexandro Becker <caarlos0@users.noreply.github.com> Carlos Alexandro Becker <caarlos0@users.noreply.github.com>\nCarlos Alexandro Becker <caarlos0@users.noreply.github.com> Carlos Becker <caarlos0@gmail.com>\ndependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> dependabot-preview[bot] <27856297+dependabot-preview[bot]@users.noreply.github.com>\nactions-user <actions@github.com> github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0693359375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2024 Carlos Alexandro Becker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.6337890625,
          "content": "SOURCE_FILES?=./...\nTEST_PATTERN?=.\n\nexport GO111MODULE := on\n\nsetup:\n\tgo mod tidy\n.PHONY: setup\n\nbuild:\n\tgo build\n.PHONY: build\n\ntest:\n\tgo test -v -failfast -race -coverpkg=./... -covermode=atomic -coverprofile=coverage.txt $(SOURCE_FILES) -run $(TEST_PATTERN) -timeout=2m\n.PHONY: test\n\ncover: test\n\tgo tool cover -html=coverage.txt\n.PHONY: cover\n\nfmt:\n\tgofumpt -w -l .\n.PHONY: fmt\n\nlint:\n\tgolangci-lint run ./...\n.PHONY: lint\n\nci: build test\n.PHONY: ci\n\ncard:\n\twget -O card.png -c \"https://og.caarlos0.dev/**env**: parse envs to structs.png?theme=light&md=1&fontSize=100px&images=https://github.com/caarlos0.png\"\n.PHONY: card\n\n.DEFAULT_GOAL := ci\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.4609375,
          "content": "<p align=\"center\">\n  <img alt=\"GoReleaser Logo\" src=\"https://becker.software/env.png\" height=\"140\" />\n  <p align=\"center\">A simple, zero-dependencies library to parse environment variables into structs.</p>\n</p>\n\n###### Installation\n\n```bash\ngo get github.com/caarlos0/env/v11\n```\n\n###### Getting started\n\n```go\ntype config struct {\n  Home string `env:\"HOME\"`\n}\n\n// parse\nvar cfg config\nerr := env.Parse(&cfg)\n\n// parse with generics\ncfg, err := env.ParseAs[config]()\n```\n\nYou can see the full documentation and list of examples at [pkg.go.dev](https://pkg.go.dev/github.com/caarlos0/env/v11).\n\n---\n\n## Used and supported by\n\n<p>\n  <a href=\"https://encore.dev\">\n    <img src=\"https://user-images.githubusercontent.com/78424526/214602214-52e0483a-b5fc-4d4c-b03e-0b7b23e012df.svg\" width=\"120px\" alt=\"encore icon\" />\n  </a>\n  <br/>\n  <br/>\n  <b>Encore â€“ the platform for building Go-based cloud backends.</b>\n  <br/>\n</p>\n\n## Usage\n\n### Caveats\n\n> [!CAUTION]\n>\n> _Unexported fields_ will be **ignored** by `env`.\n> This is by design and will not change.\n\n### Functions\n\n- `Parse`: parse the current environment into a type\n- `ParseAs`: parse the current environment into a type using generics\n- `ParseWithOptions`: parse the current environment into a type with custom options\n- `ParseAsWithOptions`: parse the current environment into a type with custom options and using generics\n- `Must`: can be used to wrap `Parse.*` calls to panic on error\n- `GetFieldParams`: get the `env` parsed options for a type\n- `GetFieldParamsWithOptions`: get the `env` parsed options for a type with custom options\n\n### Supported types\n\nOut of the box all built-in types are supported, plus a few others that are commonly used.\n\nComplete list:\n\n- `bool`\n- `float32`\n- `float64`\n- `int16`\n- `int32`\n- `int64`\n- `int8`\n- `int`\n- `string`\n- `uint16`\n- `uint32`\n- `uint64`\n- `uint8`\n- `uint`\n- `time.Duration`\n- `time.Location`\n- `encoding.TextUnmarshaler`\n- `url.URL`\n\nPointers, slices and slices of pointers, and maps of those types are also supported.\n\nYou may also add custom parsers for your types.\n\n### Tags\n\nThe following tags are provided:\n\n- `env`: sets the environment variable name and optionally takes the tag options described below\n- `envDefault`: sets the default value for the field\n- `envPrefix`: can be used in a field that is a complex type to set a prefix to all environment variables used in it\n- `envSeparator`: sets the character to be used to separate items in slices and maps (default: `,`)\n- `envKeyValSeparator`: sets the character to be used to separate keys and their values in maps (default: `:`)\n\n### `env` tag options\n\nHere are all the options available for the `env` tag:\n\n- `,expand`: expands environment variables, e.g. `FOO_${BAR}`\n- `,file`: instructs that the content of the variable is a path to a file that should be read\n- `,init`: initialize nil pointers\n- `,notEmpty`: make the field errors if the environment variable is empty\n- `,required`: make the field errors if the environment variable is not set\n- `,unset`: unset the environment variable after use\n\n### Parse Options\n\nThere are a few options available in the functions that end with `WithOptions`:\n\n- `Environment`: keys and values to be used instead of `os.Environ()`\n- `TagName`: specifies another tag name to use rather than the default `env`\n- `PrefixTagName`: specifies another prefix tag name to use rather than the default `envPrefix`\n- `DefaultValueTagName`: specifies another default tag name to use rather than the default `envDefault`\n- `RequiredIfNoDef`: set all `env` fields as required if they do not declare `envDefault`\n- `OnSet`: allows to hook into the `env` parsing and do something when a value is set\n- `Prefix`: prefix to be used in all environment variables\n- `UseFieldNameByDefault`: defines whether or not `env` should use the field name by default if the `env` key is missing\n- `FuncMap`: custom parse functions for custom types\n\n### Documentation and examples\n\nExamples are live in [pkg.go.dev](https://pkg.go.dev/github.com/caarlos0/env/v11),\nand also in the [example test file](./example_test.go).\n\n## Current state\n\n`env` is considered feature-complete.\n\nI do not intent to add any new features unless they really make sense, and are\nrequested by many people.\n\nEventual bug fixes will keep being merged.\n\n## Badges\n\n[![Release](https://img.shields.io/github/release/caarlos0/env.svg?style=for-the-badge)](https://github.com/goreleaser/goreleaser/releases/latest)\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=for-the-badge)](/LICENSE.md)\n[![Build status](https://img.shields.io/github/actions/workflow/status/caarlos0/env/build.yml?style=for-the-badge&branch=main)](https://github.com/caarlos0/env/actions?workflow=build)\n[![Codecov branch](https://img.shields.io/codecov/c/github/caarlos0/env/main.svg?style=for-the-badge)](https://codecov.io/gh/caarlos0/env)\n[![Go docs](https://img.shields.io/badge/godoc-reference-blue.svg?style=for-the-badge)](http://godoc.org/github.com/caarlos0/env/v11)\n[![Powered By: GoReleaser](https://img.shields.io/badge/powered%20by-goreleaser-green.svg?style=for-the-badge)](https://github.com/goreleaser)\n[![Conventional Commits](https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg?style=for-the-badge)](https://conventionalcommits.org)\n\n## Related projects\n\n- [envdoc](https://github.com/g4s8/envdoc) - generate documentation for environment variables from `env` tags\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/caarlos0/env.svg)](https://starchart.cc/caarlos0/env)\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 20.9404296875,
          "content": "// Package env is a simple, zero-dependencies library to parse environment\n// variables into structs.\n//\n// Example:\n//\n//\ttype config struct {\n//\t\tHome string `env:\"HOME\"`\n//\t}\n//\t// parse\n//\tvar cfg config\n//\terr := env.Parse(&cfg)\n//\t// or parse with generics\n//\tcfg, err := env.ParseAs[config]()\n//\n// Check the examples and README for more detailed usage.\npackage env\n\nimport (\n\t\"encoding\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n)\n\n// nolint: gochecknoglobals\nvar (\n\tdefaultBuiltInParsers = map[reflect.Kind]ParserFunc{\n\t\treflect.Bool: func(v string) (interface{}, error) {\n\t\t\treturn strconv.ParseBool(v)\n\t\t},\n\t\treflect.String: func(v string) (interface{}, error) {\n\t\t\treturn v, nil\n\t\t},\n\t\treflect.Int: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseInt(v, 10, 32)\n\t\t\treturn int(i), err\n\t\t},\n\t\treflect.Int16: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseInt(v, 10, 16)\n\t\t\treturn int16(i), err\n\t\t},\n\t\treflect.Int32: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseInt(v, 10, 32)\n\t\t\treturn int32(i), err\n\t\t},\n\t\treflect.Int64: func(v string) (interface{}, error) {\n\t\t\treturn strconv.ParseInt(v, 10, 64)\n\t\t},\n\t\treflect.Int8: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseInt(v, 10, 8)\n\t\t\treturn int8(i), err\n\t\t},\n\t\treflect.Uint: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseUint(v, 10, 32)\n\t\t\treturn uint(i), err\n\t\t},\n\t\treflect.Uint16: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseUint(v, 10, 16)\n\t\t\treturn uint16(i), err\n\t\t},\n\t\treflect.Uint32: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseUint(v, 10, 32)\n\t\t\treturn uint32(i), err\n\t\t},\n\t\treflect.Uint64: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseUint(v, 10, 64)\n\t\t\treturn i, err\n\t\t},\n\t\treflect.Uint8: func(v string) (interface{}, error) {\n\t\t\ti, err := strconv.ParseUint(v, 10, 8)\n\t\t\treturn uint8(i), err\n\t\t},\n\t\treflect.Float64: func(v string) (interface{}, error) {\n\t\t\treturn strconv.ParseFloat(v, 64)\n\t\t},\n\t\treflect.Float32: func(v string) (interface{}, error) {\n\t\t\tf, err := strconv.ParseFloat(v, 32)\n\t\t\treturn float32(f), err\n\t\t},\n\t}\n)\n\nfunc defaultTypeParsers() map[reflect.Type]ParserFunc {\n\treturn map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(url.URL{}):       parseURL,\n\t\treflect.TypeOf(time.Nanosecond): parseDuration,\n\t\treflect.TypeOf(time.Location{}): parseLocation,\n\t}\n}\n\nfunc parseURL(v string) (interface{}, error) {\n\tu, err := url.Parse(v)\n\tif err != nil {\n\t\treturn nil, newParseValueError(\"unable to parse URL\", err)\n\t}\n\treturn *u, nil\n}\n\nfunc parseDuration(v string) (interface{}, error) {\n\td, err := time.ParseDuration(v)\n\tif err != nil {\n\t\treturn nil, newParseValueError(\"unable to parse duration\", err)\n\t}\n\treturn d, err\n}\n\nfunc parseLocation(v string) (interface{}, error) {\n\tloc, err := time.LoadLocation(v)\n\tif err != nil {\n\t\treturn nil, newParseValueError(\"unable to parse location\", err)\n\t}\n\treturn *loc, nil\n}\n\n// ParserFunc defines the signature of a function that can be used within\n// `Options`' `FuncMap`.\ntype ParserFunc func(v string) (interface{}, error)\n\n// OnSetFn is a hook that can be run when a value is set.\ntype OnSetFn func(tag string, value interface{}, isDefault bool)\n\n// processFieldFn is a function which takes all information about a field and processes it.\ntype processFieldFn func(\n\trefField reflect.Value,\n\trefTypeField reflect.StructField,\n\topts Options,\n\tfieldParams FieldParams,\n) error\n\n// Options for the parser.\ntype Options struct {\n\t// Environment keys and values that will be accessible for the service.\n\tEnvironment map[string]string\n\n\t// TagName specifies another tag name to use rather than the default 'env'.\n\tTagName string\n\n\t// PrefixTagName specifies another prefix tag name to use rather than the default 'envPrefix'.\n\tPrefixTagName string\n\n\t// DefaultValueTagName specifies another default tag name to use rather than the default 'envDefault'.\n\tDefaultValueTagName string\n\n\t// RequiredIfNoDef automatically sets all fields as required if they do not\n\t// declare 'envDefault'.\n\tRequiredIfNoDef bool\n\n\t// OnSet allows to run a function when a value is set.\n\tOnSet OnSetFn\n\n\t// Prefix define a prefix for every key.\n\tPrefix string\n\n\t// UseFieldNameByDefault defines whether or not `env` should use the field\n\t// name by default if the `env` key is missing.\n\t// Note that the field name will be \"converted\" to conform with environment\n\t// variable names conventions.\n\tUseFieldNameByDefault bool\n\n\t// Custom parse functions for different types.\n\tFuncMap map[reflect.Type]ParserFunc\n\n\t// Used internally. maps the env variable key to its resolved string value.\n\t// (for env var expansion)\n\trawEnvVars map[string]string\n}\n\nfunc (opts *Options) getRawEnv(s string) string {\n\tval := opts.rawEnvVars[s]\n\tif val == \"\" {\n\t\tval = opts.Environment[s]\n\t}\n\treturn os.Expand(val, opts.getRawEnv)\n}\n\nfunc defaultOptions() Options {\n\treturn Options{\n\t\tTagName:             \"env\",\n\t\tPrefixTagName:       \"envPrefix\",\n\t\tDefaultValueTagName: \"envDefault\",\n\t\tEnvironment:         toMap(os.Environ()),\n\t\tFuncMap:             defaultTypeParsers(),\n\t\trawEnvVars:          make(map[string]string),\n\t}\n}\n\nfunc mergeOptions[T any](target, source *T) {\n\ttargetPtr := reflect.ValueOf(target).Elem()\n\tsourcePtr := reflect.ValueOf(source).Elem()\n\n\ttargetType := targetPtr.Type()\n\tfor i := 0; i < targetPtr.NumField(); i++ {\n\t\tfieldName := targetType.Field(i).Name\n\t\ttargetField := targetPtr.Field(i)\n\t\tsourceField := sourcePtr.FieldByName(fieldName)\n\n\t\tif targetField.CanSet() && !isZero(sourceField) {\n\t\t\t// FuncMaps are being merged, while Environments must be overwritten\n\t\t\tif fieldName == \"FuncMap\" {\n\t\t\t\tif !sourceField.IsZero() {\n\t\t\t\t\titer := sourceField.MapRange()\n\t\t\t\t\tfor iter.Next() {\n\t\t\t\t\t\ttargetField.SetMapIndex(iter.Key(), iter.Value())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttargetField.Set(sourceField)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isZero(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Func, reflect.Map, reflect.Slice:\n\t\treturn v.IsNil()\n\tdefault:\n\t\tzero := reflect.Zero(v.Type())\n\t\treturn v.Interface() == zero.Interface()\n\t}\n}\n\nfunc customOptions(opts Options) Options {\n\tdefOpts := defaultOptions()\n\tmergeOptions(&defOpts, &opts)\n\treturn defOpts\n}\n\nfunc optionsWithSliceEnvPrefix(opts Options, index int) Options {\n\treturn Options{\n\t\tEnvironment:           opts.Environment,\n\t\tTagName:               opts.TagName,\n\t\tPrefixTagName:         opts.PrefixTagName,\n\t\tDefaultValueTagName:   opts.DefaultValueTagName,\n\t\tRequiredIfNoDef:       opts.RequiredIfNoDef,\n\t\tOnSet:                 opts.OnSet,\n\t\tPrefix:                fmt.Sprintf(\"%s%d_\", opts.Prefix, index),\n\t\tUseFieldNameByDefault: opts.UseFieldNameByDefault,\n\t\tFuncMap:               opts.FuncMap,\n\t\trawEnvVars:            opts.rawEnvVars,\n\t}\n}\n\nfunc optionsWithEnvPrefix(field reflect.StructField, opts Options) Options {\n\treturn Options{\n\t\tEnvironment:           opts.Environment,\n\t\tTagName:               opts.TagName,\n\t\tPrefixTagName:         opts.PrefixTagName,\n\t\tDefaultValueTagName:   opts.DefaultValueTagName,\n\t\tRequiredIfNoDef:       opts.RequiredIfNoDef,\n\t\tOnSet:                 opts.OnSet,\n\t\tPrefix:                opts.Prefix + field.Tag.Get(opts.PrefixTagName),\n\t\tUseFieldNameByDefault: opts.UseFieldNameByDefault,\n\t\tFuncMap:               opts.FuncMap,\n\t\trawEnvVars:            opts.rawEnvVars,\n\t}\n}\n\n// Parse parses a struct containing `env` tags and loads its values from\n// environment variables.\nfunc Parse(v interface{}) error {\n\treturn parseInternal(v, setField, defaultOptions())\n}\n\n// ParseWithOptions parses a struct containing `env` tags and loads its values from\n// environment variables.\nfunc ParseWithOptions(v interface{}, opts Options) error {\n\treturn parseInternal(v, setField, customOptions(opts))\n}\n\n// ParseAs parses the given struct type containing `env` tags and loads its\n// values from environment variables.\nfunc ParseAs[T any]() (T, error) {\n\tvar t T\n\terr := Parse(&t)\n\treturn t, err\n}\n\n// ParseWithOptions parses the given struct type containing `env` tags and\n// loads its values from environment variables.\nfunc ParseAsWithOptions[T any](opts Options) (T, error) {\n\tvar t T\n\terr := ParseWithOptions(&t, opts)\n\treturn t, err\n}\n\n// Must panic is if err is not nil, and returns t otherwise.\nfunc Must[T any](t T, err error) T {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}\n\n// GetFieldParams parses a struct containing `env` tags and returns information about\n// tags it found.\nfunc GetFieldParams(v interface{}) ([]FieldParams, error) {\n\treturn GetFieldParamsWithOptions(v, defaultOptions())\n}\n\n// GetFieldParamsWithOptions parses a struct containing `env` tags and returns information about\n// tags it found.\nfunc GetFieldParamsWithOptions(v interface{}, opts Options) ([]FieldParams, error) {\n\tvar result []FieldParams\n\terr := parseInternal(\n\t\tv,\n\t\tfunc(_ reflect.Value, _ reflect.StructField, _ Options, fieldParams FieldParams) error {\n\t\t\tif fieldParams.OwnKey != \"\" {\n\t\t\t\tresult = append(result, fieldParams)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tcustomOptions(opts),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc parseInternal(v interface{}, processField processFieldFn, opts Options) error {\n\tptrRef := reflect.ValueOf(v)\n\tif ptrRef.Kind() != reflect.Ptr {\n\t\treturn newAggregateError(NotStructPtrError{})\n\t}\n\tref := ptrRef.Elem()\n\tif ref.Kind() != reflect.Struct {\n\t\treturn newAggregateError(NotStructPtrError{})\n\t}\n\n\treturn doParse(ref, processField, opts)\n}\n\nfunc doParse(ref reflect.Value, processField processFieldFn, opts Options) error {\n\trefType := ref.Type()\n\n\tvar agrErr AggregateError\n\n\tfor i := 0; i < refType.NumField(); i++ {\n\t\trefField := ref.Field(i)\n\t\trefTypeField := refType.Field(i)\n\n\t\tif err := doParseField(refField, refTypeField, processField, opts); err != nil {\n\t\t\tif val, ok := err.(AggregateError); ok {\n\t\t\t\tagrErr.Errors = append(agrErr.Errors, val.Errors...)\n\t\t\t} else {\n\t\t\t\tagrErr.Errors = append(agrErr.Errors, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(agrErr.Errors) == 0 {\n\t\treturn nil\n\t}\n\n\treturn agrErr\n}\n\nfunc doParseField(\n\trefField reflect.Value,\n\trefTypeField reflect.StructField,\n\tprocessField processFieldFn,\n\topts Options,\n) error {\n\tif !refField.CanSet() {\n\t\treturn nil\n\t}\n\tif refField.Kind() == reflect.Ptr && refField.Elem().Kind() == reflect.Struct && !refField.IsNil() {\n\t\treturn parseInternal(refField.Interface(), processField, optionsWithEnvPrefix(refTypeField, opts))\n\t}\n\tif refField.Kind() == reflect.Struct && refField.CanAddr() && refField.Type().Name() == \"\" {\n\t\treturn parseInternal(refField.Addr().Interface(), processField, optionsWithEnvPrefix(refTypeField, opts))\n\t}\n\n\tparams, err := parseFieldParams(refTypeField, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif params.Ignored {\n\t\treturn nil\n\t}\n\n\tif err := processField(refField, refTypeField, opts, params); err != nil {\n\t\treturn err\n\t}\n\n\tif params.Init && isInvalidPtr(refField) {\n\t\trefField.Set(reflect.New(refField.Type().Elem()))\n\t\trefField = refField.Elem()\n\t}\n\n\tif refField.Kind() == reflect.Struct {\n\t\treturn doParse(refField, processField, optionsWithEnvPrefix(refTypeField, opts))\n\t}\n\n\tif isSliceOfStructs(refTypeField) {\n\t\treturn doParseSlice(refField, processField, optionsWithEnvPrefix(refTypeField, opts))\n\t}\n\n\treturn nil\n}\n\nfunc isSliceOfStructs(refTypeField reflect.StructField) bool {\n\tfield := refTypeField.Type\n\n\t// *[]struct\n\tif field.Kind() == reflect.Ptr {\n\t\tfield = field.Elem()\n\t\tif field.Kind() == reflect.Slice && field.Elem().Kind() == reflect.Struct {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// []struct{}\n\tif field.Kind() == reflect.Slice && field.Elem().Kind() == reflect.Struct {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc doParseSlice(ref reflect.Value, processField processFieldFn, opts Options) error {\n\tif opts.Prefix != \"\" && !strings.HasSuffix(opts.Prefix, string(underscore)) {\n\t\topts.Prefix += string(underscore)\n\t}\n\n\tvar environments []string\n\tfor environment := range opts.Environment {\n\t\tif strings.HasPrefix(environment, opts.Prefix) {\n\t\t\tenvironments = append(environments, environment)\n\t\t}\n\t}\n\n\tif len(environments) > 0 {\n\t\tcounter := 0\n\t\tfor finished := false; !finished; {\n\t\t\tfinished = true\n\t\t\tprefix := fmt.Sprintf(\"%s%d%c\", opts.Prefix, counter, underscore)\n\t\t\tfor _, variable := range environments {\n\t\t\t\tif strings.HasPrefix(variable, prefix) {\n\t\t\t\t\tcounter++\n\t\t\t\t\tfinished = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsliceType := ref.Type()\n\t\tvar initialized int\n\t\tif reflect.Ptr == ref.Kind() {\n\t\t\tsliceType = sliceType.Elem()\n\t\t\t// Due to the rest of code the pre-initialized slice has no chance for this situation\n\t\t\tinitialized = 0\n\t\t} else {\n\t\t\tinitialized = ref.Len()\n\t\t}\n\n\t\tvar capacity int\n\t\tif capacity = initialized; counter > initialized {\n\t\t\tcapacity = counter\n\t\t}\n\t\tresult := reflect.MakeSlice(sliceType, capacity, capacity)\n\t\tfor i := 0; i < capacity; i++ {\n\t\t\titem := result.Index(i)\n\t\t\tif i < initialized {\n\t\t\t\titem.Set(ref.Index(i))\n\t\t\t}\n\t\t\tif err := doParse(item, processField, optionsWithSliceEnvPrefix(opts, i)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif result.Len() > 0 {\n\t\t\tif reflect.Ptr == ref.Kind() {\n\t\t\t\tresultPtr := reflect.New(sliceType)\n\t\t\t\tresultPtr.Elem().Set(result)\n\t\t\t\tresult = resultPtr\n\t\t\t}\n\t\t\tref.Set(result)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc setField(refField reflect.Value, refTypeField reflect.StructField, opts Options, fieldParams FieldParams) error {\n\tvalue, err := get(fieldParams, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif value != \"\" {\n\t\treturn set(refField, refTypeField, value, opts.FuncMap)\n\t}\n\n\treturn nil\n}\n\nconst underscore rune = '_'\n\nfunc toEnvName(input string) string {\n\tvar output []rune\n\tfor i, c := range input {\n\t\tif c == underscore {\n\t\t\tcontinue\n\t\t}\n\t\tif len(output) > 0 && unicode.IsUpper(c) {\n\t\t\tif len(input) > i+1 {\n\t\t\t\tpeek := rune(input[i+1])\n\t\t\t\tif unicode.IsLower(peek) || unicode.IsLower(rune(input[i-1])) {\n\t\t\t\t\toutput = append(output, underscore)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutput = append(output, unicode.ToUpper(c))\n\t}\n\treturn string(output)\n}\n\n// FieldParams contains information about parsed field tags.\ntype FieldParams struct {\n\tOwnKey          string\n\tKey             string\n\tDefaultValue    string\n\tHasDefaultValue bool\n\tRequired        bool\n\tLoadFile        bool\n\tUnset           bool\n\tNotEmpty        bool\n\tExpand          bool\n\tInit            bool\n\tIgnored         bool\n}\n\nfunc parseFieldParams(field reflect.StructField, opts Options) (FieldParams, error) {\n\townKey, tags := parseKeyForOption(field.Tag.Get(opts.TagName))\n\tif ownKey == \"\" && opts.UseFieldNameByDefault {\n\t\townKey = toEnvName(field.Name)\n\t}\n\n\tdefaultValue, hasDefaultValue := field.Tag.Lookup(opts.DefaultValueTagName)\n\n\tresult := FieldParams{\n\t\tOwnKey:          ownKey,\n\t\tKey:             opts.Prefix + ownKey,\n\t\tRequired:        opts.RequiredIfNoDef,\n\t\tDefaultValue:    defaultValue,\n\t\tHasDefaultValue: hasDefaultValue,\n\t\tIgnored:         ownKey == \"-\",\n\t}\n\n\tfor _, tag := range tags {\n\t\tswitch tag {\n\t\tcase \"\":\n\t\t\tcontinue\n\t\tcase \"file\":\n\t\t\tresult.LoadFile = true\n\t\tcase \"required\":\n\t\t\tresult.Required = true\n\t\tcase \"unset\":\n\t\t\tresult.Unset = true\n\t\tcase \"notEmpty\":\n\t\t\tresult.NotEmpty = true\n\t\tcase \"expand\":\n\t\t\tresult.Expand = true\n\t\tcase \"init\":\n\t\t\tresult.Init = true\n\t\tcase \"-\":\n\t\t\tresult.Ignored = true\n\t\tdefault:\n\t\t\treturn FieldParams{}, newNoSupportedTagOptionError(tag)\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\nfunc get(fieldParams FieldParams, opts Options) (val string, err error) {\n\tvar exists, isDefault bool\n\n\tval, exists, isDefault = getOr(\n\t\tfieldParams.Key,\n\t\tfieldParams.DefaultValue,\n\t\tfieldParams.HasDefaultValue,\n\t\topts.Environment,\n\t)\n\n\tif fieldParams.Expand {\n\t\tval = os.Expand(val, opts.getRawEnv)\n\t}\n\n\topts.rawEnvVars[fieldParams.OwnKey] = val\n\n\tif fieldParams.Unset {\n\t\tdefer os.Unsetenv(fieldParams.Key)\n\t}\n\n\tif fieldParams.Required && !exists && fieldParams.OwnKey != \"\" {\n\t\treturn \"\", newVarIsNotSetError(fieldParams.Key)\n\t}\n\n\tif fieldParams.NotEmpty && val == \"\" {\n\t\treturn \"\", newEmptyVarError(fieldParams.Key)\n\t}\n\n\tif fieldParams.LoadFile && val != \"\" {\n\t\tfilename := val\n\t\tval, err = getFromFile(filename)\n\t\tif err != nil {\n\t\t\treturn \"\", newLoadFileContentError(filename, fieldParams.Key, err)\n\t\t}\n\t}\n\n\tif opts.OnSet != nil {\n\t\tif fieldParams.OwnKey != \"\" {\n\t\t\topts.OnSet(fieldParams.Key, val, isDefault)\n\t\t}\n\t}\n\treturn val, err\n}\n\n// split the env tag's key into the expected key and desired option, if any.\nfunc parseKeyForOption(key string) (string, []string) {\n\topts := strings.Split(key, \",\")\n\treturn opts[0], opts[1:]\n}\n\nfunc getFromFile(filename string) (value string, err error) {\n\tb, err := os.ReadFile(filename)\n\treturn string(b), err\n}\n\nfunc getOr(key, defaultValue string, defExists bool, envs map[string]string) (val string, exists, isDefault bool) {\n\tvalue, exists := envs[key]\n\tswitch {\n\tcase (!exists || key == \"\") && defExists:\n\t\treturn defaultValue, true, true\n\tcase exists && value == \"\" && defExists:\n\t\treturn defaultValue, true, true\n\tcase !exists:\n\t\treturn \"\", false, false\n\t}\n\n\treturn value, true, false\n}\n\nfunc set(field reflect.Value, sf reflect.StructField, value string, funcMap map[reflect.Type]ParserFunc) error {\n\tif tm := asTextUnmarshaler(field); tm != nil {\n\t\tif err := tm.UnmarshalText([]byte(value)); err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\ttypee := sf.Type\n\tfieldee := field\n\tif typee.Kind() == reflect.Ptr {\n\t\ttypee = typee.Elem()\n\t\tfieldee = field.Elem()\n\t}\n\n\tparserFunc, ok := funcMap[typee]\n\tif ok {\n\t\tval, err := parserFunc(value)\n\t\tif err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\n\t\tfieldee.Set(reflect.ValueOf(val))\n\t\treturn nil\n\t}\n\n\tparserFunc, ok = defaultBuiltInParsers[typee.Kind()]\n\tif ok {\n\t\tval, err := parserFunc(value)\n\t\tif err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\n\t\tfieldee.Set(reflect.ValueOf(val).Convert(typee))\n\t\treturn nil\n\t}\n\n\tswitch field.Kind() {\n\tcase reflect.Slice:\n\t\treturn handleSlice(field, value, sf, funcMap)\n\tcase reflect.Map:\n\t\treturn handleMap(field, value, sf, funcMap)\n\t}\n\n\treturn newNoParserError(sf)\n}\n\nfunc handleSlice(field reflect.Value, value string, sf reflect.StructField, funcMap map[reflect.Type]ParserFunc) error {\n\tseparator := sf.Tag.Get(\"envSeparator\")\n\tif separator == \"\" {\n\t\tseparator = \",\"\n\t}\n\tparts := strings.Split(value, separator)\n\n\ttypee := sf.Type.Elem()\n\tif typee.Kind() == reflect.Ptr {\n\t\ttypee = typee.Elem()\n\t}\n\n\tif _, ok := reflect.New(typee).Interface().(encoding.TextUnmarshaler); ok {\n\t\treturn parseTextUnmarshalers(field, parts, sf)\n\t}\n\n\tparserFunc, ok := funcMap[typee]\n\tif !ok {\n\t\tparserFunc, ok = defaultBuiltInParsers[typee.Kind()]\n\t\tif !ok {\n\t\t\treturn newNoParserError(sf)\n\t\t}\n\t}\n\n\tresult := reflect.MakeSlice(sf.Type, 0, len(parts))\n\tfor _, part := range parts {\n\t\tr, err := parserFunc(part)\n\t\tif err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\t\tv := reflect.ValueOf(r).Convert(typee)\n\t\tif sf.Type.Elem().Kind() == reflect.Ptr {\n\t\t\tv = reflect.New(typee)\n\t\t\tv.Elem().Set(reflect.ValueOf(r).Convert(typee))\n\t\t}\n\t\tresult = reflect.Append(result, v)\n\t}\n\tfield.Set(result)\n\treturn nil\n}\n\nfunc handleMap(field reflect.Value, value string, sf reflect.StructField, funcMap map[reflect.Type]ParserFunc) error {\n\tkeyType := sf.Type.Key()\n\tkeyParserFunc, ok := funcMap[keyType]\n\tif !ok {\n\t\tkeyParserFunc, ok = defaultBuiltInParsers[keyType.Kind()]\n\t\tif !ok {\n\t\t\treturn newNoParserError(sf)\n\t\t}\n\t}\n\n\telemType := sf.Type.Elem()\n\telemParserFunc, ok := funcMap[elemType]\n\tif !ok {\n\t\telemParserFunc, ok = defaultBuiltInParsers[elemType.Kind()]\n\t\tif !ok {\n\t\t\treturn newNoParserError(sf)\n\t\t}\n\t}\n\n\tseparator := sf.Tag.Get(\"envSeparator\")\n\tif separator == \"\" {\n\t\tseparator = \",\"\n\t}\n\n\tkeyValSeparator := sf.Tag.Get(\"envKeyValSeparator\")\n\tif keyValSeparator == \"\" {\n\t\tkeyValSeparator = \":\"\n\t}\n\n\tresult := reflect.MakeMap(sf.Type)\n\tfor _, part := range strings.Split(value, separator) {\n\t\tpairs := strings.SplitN(part, keyValSeparator, 2)\n\t\tif len(pairs) != 2 {\n\t\t\treturn newParseError(sf, fmt.Errorf(`%q should be in \"key%svalue\" format`, part, keyValSeparator))\n\t\t}\n\n\t\tkey, err := keyParserFunc(pairs[0])\n\t\tif err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\n\t\telem, err := elemParserFunc(pairs[1])\n\t\tif err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\n\t\tresult.SetMapIndex(reflect.ValueOf(key).Convert(keyType), reflect.ValueOf(elem).Convert(elemType))\n\t}\n\n\tfield.Set(result)\n\treturn nil\n}\n\nfunc asTextUnmarshaler(field reflect.Value) encoding.TextUnmarshaler {\n\tif field.Kind() == reflect.Ptr {\n\t\tif field.IsNil() {\n\t\t\tfield.Set(reflect.New(field.Type().Elem()))\n\t\t}\n\t} else if field.CanAddr() {\n\t\tfield = field.Addr()\n\t}\n\n\ttm, ok := field.Interface().(encoding.TextUnmarshaler)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn tm\n}\n\nfunc parseTextUnmarshalers(field reflect.Value, data []string, sf reflect.StructField) error {\n\ts := len(data)\n\telemType := field.Type().Elem()\n\tslice := reflect.MakeSlice(reflect.SliceOf(elemType), s, s)\n\tfor i, v := range data {\n\t\tsv := slice.Index(i)\n\t\tkind := sv.Kind()\n\t\tif kind == reflect.Ptr {\n\t\t\tsv = reflect.New(elemType.Elem())\n\t\t} else {\n\t\t\tsv = sv.Addr()\n\t\t}\n\t\ttm := sv.Interface().(encoding.TextUnmarshaler)\n\t\tif err := tm.UnmarshalText([]byte(v)); err != nil {\n\t\t\treturn newParseError(sf, err)\n\t\t}\n\t\tif kind == reflect.Ptr {\n\t\t\tslice.Index(i).Set(sv)\n\t\t}\n\t}\n\n\tfield.Set(slice)\n\n\treturn nil\n}\n\n// ToMap Converts list of env vars as provided by os.Environ() to map you\n// can use as Options.Environment field\nfunc ToMap(env []string) map[string]string {\n\treturn toMap(env)\n}\n\nfunc isInvalidPtr(v reflect.Value) bool {\n\treturn reflect.Ptr == v.Kind() && v.Elem().Kind() == reflect.Invalid\n}\n"
        },
        {
          "name": "env_test.go",
          "type": "blob",
          "size": 61.3779296875,
          "content": "// editorconfig-checker-disable-file\npackage env\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype unmarshaler struct {\n\ttime.Duration\n}\n\n// TextUnmarshaler implements encoding.TextUnmarshaler.\nfunc (d *unmarshaler) UnmarshalText(data []byte) (err error) {\n\tif len(data) != 0 {\n\t\td.Duration, err = time.ParseDuration(string(data))\n\t} else {\n\t\td.Duration = 0\n\t}\n\treturn err\n}\n\n// nolint: maligned\ntype Config struct {\n\tString     string    `env:\"STRING\"`\n\tStringPtr  *string   `env:\"STRING\"`\n\tStrings    []string  `env:\"STRINGS\"`\n\tStringPtrs []*string `env:\"STRINGS\"`\n\n\tBool     bool    `env:\"BOOL\"`\n\tBoolPtr  *bool   `env:\"BOOL\"`\n\tBools    []bool  `env:\"BOOLS\"`\n\tBoolPtrs []*bool `env:\"BOOLS\"`\n\n\tInt     int    `env:\"INT\"`\n\tIntPtr  *int   `env:\"INT\"`\n\tInts    []int  `env:\"INTS\"`\n\tIntPtrs []*int `env:\"INTS\"`\n\n\tInt8     int8    `env:\"INT8\"`\n\tInt8Ptr  *int8   `env:\"INT8\"`\n\tInt8s    []int8  `env:\"INT8S\"`\n\tInt8Ptrs []*int8 `env:\"INT8S\"`\n\n\tInt16     int16    `env:\"INT16\"`\n\tInt16Ptr  *int16   `env:\"INT16\"`\n\tInt16s    []int16  `env:\"INT16S\"`\n\tInt16Ptrs []*int16 `env:\"INT16S\"`\n\n\tInt32     int32    `env:\"INT32\"`\n\tInt32Ptr  *int32   `env:\"INT32\"`\n\tInt32s    []int32  `env:\"INT32S\"`\n\tInt32Ptrs []*int32 `env:\"INT32S\"`\n\n\tInt64     int64    `env:\"INT64\"`\n\tInt64Ptr  *int64   `env:\"INT64\"`\n\tInt64s    []int64  `env:\"INT64S\"`\n\tInt64Ptrs []*int64 `env:\"INT64S\"`\n\n\tUint     uint    `env:\"UINT\"`\n\tUintPtr  *uint   `env:\"UINT\"`\n\tUints    []uint  `env:\"UINTS\"`\n\tUintPtrs []*uint `env:\"UINTS\"`\n\n\tUint8     uint8    `env:\"UINT8\"`\n\tUint8Ptr  *uint8   `env:\"UINT8\"`\n\tUint8s    []uint8  `env:\"UINT8S\"`\n\tUint8Ptrs []*uint8 `env:\"UINT8S\"`\n\n\tUint16     uint16    `env:\"UINT16\"`\n\tUint16Ptr  *uint16   `env:\"UINT16\"`\n\tUint16s    []uint16  `env:\"UINT16S\"`\n\tUint16Ptrs []*uint16 `env:\"UINT16S\"`\n\n\tUint32     uint32    `env:\"UINT32\"`\n\tUint32Ptr  *uint32   `env:\"UINT32\"`\n\tUint32s    []uint32  `env:\"UINT32S\"`\n\tUint32Ptrs []*uint32 `env:\"UINT32S\"`\n\n\tUint64     uint64    `env:\"UINT64\"`\n\tUint64Ptr  *uint64   `env:\"UINT64\"`\n\tUint64s    []uint64  `env:\"UINT64S\"`\n\tUint64Ptrs []*uint64 `env:\"UINT64S\"`\n\n\tFloat32     float32    `env:\"FLOAT32\"`\n\tFloat32Ptr  *float32   `env:\"FLOAT32\"`\n\tFloat32s    []float32  `env:\"FLOAT32S\"`\n\tFloat32Ptrs []*float32 `env:\"FLOAT32S\"`\n\n\tFloat64     float64    `env:\"FLOAT64\"`\n\tFloat64Ptr  *float64   `env:\"FLOAT64\"`\n\tFloat64s    []float64  `env:\"FLOAT64S\"`\n\tFloat64Ptrs []*float64 `env:\"FLOAT64S\"`\n\n\tDuration     time.Duration    `env:\"DURATION\"`\n\tDurations    []time.Duration  `env:\"DURATIONS\"`\n\tDurationPtr  *time.Duration   `env:\"DURATION\"`\n\tDurationPtrs []*time.Duration `env:\"DURATIONS\"`\n\n\tLocation     time.Location    `env:\"LOCATION\"`\n\tLocations    []time.Location  `env:\"LOCATIONS\"`\n\tLocationPtr  *time.Location   `env:\"LOCATION\"`\n\tLocationPtrs []*time.Location `env:\"LOCATIONS\"`\n\n\tUnmarshaler     unmarshaler    `env:\"UNMARSHALER\"`\n\tUnmarshalerPtr  *unmarshaler   `env:\"UNMARSHALER\"`\n\tUnmarshalers    []unmarshaler  `env:\"UNMARSHALERS\"`\n\tUnmarshalerPtrs []*unmarshaler `env:\"UNMARSHALERS\"`\n\n\tURL     url.URL    `env:\"URL\"`\n\tURLPtr  *url.URL   `env:\"URL\"`\n\tURLs    []url.URL  `env:\"URLS\"`\n\tURLPtrs []*url.URL `env:\"URLS\"`\n\n\tStringWithDefault string `env:\"DATABASE_URL\" envDefault:\"postgres://localhost:5432/db\"`\n\n\tCustomSeparator []string `env:\"SEPSTRINGS\" envSeparator:\":\"`\n\n\tNonDefined struct {\n\t\tString string `env:\"NONDEFINED_STR\"`\n\t}\n\n\tNestedNonDefined struct {\n\t\tNonDefined struct {\n\t\t\tString string `env:\"STR\"`\n\t\t} `envPrefix:\"NONDEFINED_\"`\n\t} `envPrefix:\"PRF_\"`\n\n\tNotAnEnv   string\n\tunexported string `env:\"FOO\"`\n}\n\ntype ParentStruct struct {\n\tInnerStruct    *InnerStruct `env:\",init\"`\n\tNilInnerStruct *InnerStruct\n\tunexported     *InnerStruct\n\tIgnored        *http.Client\n}\n\ntype InnerStruct struct {\n\tInner  string `env:\"innervar\"`\n\tNumber uint   `env:\"innernum\"`\n}\n\ntype ForNestedStruct struct {\n\tNestedStruct\n}\n\ntype NestedStruct struct {\n\tNestedVar string `env:\"nestedvar\"`\n}\n\nfunc TestIssue245(t *testing.T) {\n\tt.Setenv(\"NAME_NOT_SET\", \"\")\n\ttype user struct {\n\t\tName string `env:\"NAME_NOT_SET\" envDefault:\"abcd\"`\n\t}\n\tcfg := user{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, cfg.Name, \"abcd\")\n}\n\nfunc TestParsesEnv(t *testing.T) {\n\ttos := func(v interface{}) string {\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n\n\ttoss := func(v ...interface{}) string {\n\t\tss := []string{}\n\t\tfor _, s := range v {\n\t\t\tss = append(ss, tos(s))\n\t\t}\n\t\treturn strings.Join(ss, \",\")\n\t}\n\n\tstr1 := \"str1\"\n\tstr2 := \"str2\"\n\tt.Setenv(\"STRING\", str1)\n\tt.Setenv(\"STRINGS\", toss(str1, str2))\n\n\tbool1 := true\n\tbool2 := false\n\tt.Setenv(\"BOOL\", tos(bool1))\n\tt.Setenv(\"BOOLS\", toss(bool1, bool2))\n\n\tint1 := -1\n\tint2 := 2\n\tt.Setenv(\"INT\", tos(int1))\n\tt.Setenv(\"INTS\", toss(int1, int2))\n\n\tvar int81 int8 = -2\n\tvar int82 int8 = 5\n\tt.Setenv(\"INT8\", tos(int81))\n\tt.Setenv(\"INT8S\", toss(int81, int82))\n\n\tvar int161 int16 = -24\n\tvar int162 int16 = 15\n\tt.Setenv(\"INT16\", tos(int161))\n\tt.Setenv(\"INT16S\", toss(int161, int162))\n\n\tvar int321 int32 = -14\n\tvar int322 int32 = 154\n\tt.Setenv(\"INT32\", tos(int321))\n\tt.Setenv(\"INT32S\", toss(int321, int322))\n\n\tvar int641 int64 = -12\n\tvar int642 int64 = 150\n\tt.Setenv(\"INT64\", tos(int641))\n\tt.Setenv(\"INT64S\", toss(int641, int642))\n\n\tvar uint1 uint = 1\n\tvar uint2 uint = 2\n\tt.Setenv(\"UINT\", tos(uint1))\n\tt.Setenv(\"UINTS\", toss(uint1, uint2))\n\n\tvar uint81 uint8 = 15\n\tvar uint82 uint8 = 51\n\tt.Setenv(\"UINT8\", tos(uint81))\n\tt.Setenv(\"UINT8S\", toss(uint81, uint82))\n\n\tvar uint161 uint16 = 532\n\tvar uint162 uint16 = 123\n\tt.Setenv(\"UINT16\", tos(uint161))\n\tt.Setenv(\"UINT16S\", toss(uint161, uint162))\n\n\tvar uint321 uint32 = 93\n\tvar uint322 uint32 = 14\n\tt.Setenv(\"UINT32\", tos(uint321))\n\tt.Setenv(\"UINT32S\", toss(uint321, uint322))\n\n\tvar uint641 uint64 = 5\n\tvar uint642 uint64 = 43\n\tt.Setenv(\"UINT64\", tos(uint641))\n\tt.Setenv(\"UINT64S\", toss(uint641, uint642))\n\n\tvar float321 float32 = 9.3\n\tvar float322 float32 = 1.1\n\tt.Setenv(\"FLOAT32\", tos(float321))\n\tt.Setenv(\"FLOAT32S\", toss(float321, float322))\n\n\tfloat641 := 1.53\n\tfloat642 := 0.5\n\tt.Setenv(\"FLOAT64\", tos(float641))\n\tt.Setenv(\"FLOAT64S\", toss(float641, float642))\n\n\tduration1 := time.Second\n\tduration2 := time.Second * 4\n\tt.Setenv(\"DURATION\", tos(duration1))\n\tt.Setenv(\"DURATIONS\", toss(duration1, duration2))\n\n\tlocation1 := time.UTC\n\tlocation2, errLoadLocation := time.LoadLocation(\"Europe/Berlin\")\n\tisNoErr(t, errLoadLocation)\n\tt.Setenv(\"LOCATION\", tos(location1))\n\tt.Setenv(\"LOCATIONS\", toss(location1, location2))\n\n\tunmarshaler1 := unmarshaler{time.Minute}\n\tunmarshaler2 := unmarshaler{time.Millisecond * 1232}\n\tt.Setenv(\"UNMARSHALER\", tos(unmarshaler1.Duration))\n\tt.Setenv(\"UNMARSHALERS\", toss(unmarshaler1.Duration, unmarshaler2.Duration))\n\n\turl1 := \"https://goreleaser.com\"\n\turl2 := \"https://caarlos0.dev\"\n\tt.Setenv(\"URL\", tos(url1))\n\tt.Setenv(\"URLS\", toss(url1, url2))\n\n\tt.Setenv(\"SEPSTRINGS\", str1+\":\"+str2)\n\n\tnonDefinedStr := \"nonDefinedStr\"\n\tt.Setenv(\"NONDEFINED_STR\", nonDefinedStr)\n\tt.Setenv(\"PRF_NONDEFINED_STR\", nonDefinedStr)\n\n\tt.Setenv(\"FOO\", str1)\n\n\tcfg := Config{}\n\tisNoErr(t, Parse(&cfg))\n\n\tisEqual(t, str1, cfg.String)\n\tisEqual(t, &str1, cfg.StringPtr)\n\tisEqual(t, str1, cfg.Strings[0])\n\tisEqual(t, str2, cfg.Strings[1])\n\tisEqual(t, &str1, cfg.StringPtrs[0])\n\tisEqual(t, &str2, cfg.StringPtrs[1])\n\n\tisEqual(t, bool1, cfg.Bool)\n\tisEqual(t, &bool1, cfg.BoolPtr)\n\tisEqual(t, bool1, cfg.Bools[0])\n\tisEqual(t, bool2, cfg.Bools[1])\n\tisEqual(t, &bool1, cfg.BoolPtrs[0])\n\tisEqual(t, &bool2, cfg.BoolPtrs[1])\n\n\tisEqual(t, int1, cfg.Int)\n\tisEqual(t, &int1, cfg.IntPtr)\n\tisEqual(t, int1, cfg.Ints[0])\n\tisEqual(t, int2, cfg.Ints[1])\n\tisEqual(t, &int1, cfg.IntPtrs[0])\n\tisEqual(t, &int2, cfg.IntPtrs[1])\n\n\tisEqual(t, int81, cfg.Int8)\n\tisEqual(t, &int81, cfg.Int8Ptr)\n\tisEqual(t, int81, cfg.Int8s[0])\n\tisEqual(t, int82, cfg.Int8s[1])\n\tisEqual(t, &int81, cfg.Int8Ptrs[0])\n\tisEqual(t, &int82, cfg.Int8Ptrs[1])\n\n\tisEqual(t, int161, cfg.Int16)\n\tisEqual(t, &int161, cfg.Int16Ptr)\n\tisEqual(t, int161, cfg.Int16s[0])\n\tisEqual(t, int162, cfg.Int16s[1])\n\tisEqual(t, &int161, cfg.Int16Ptrs[0])\n\tisEqual(t, &int162, cfg.Int16Ptrs[1])\n\n\tisEqual(t, int321, cfg.Int32)\n\tisEqual(t, &int321, cfg.Int32Ptr)\n\tisEqual(t, int321, cfg.Int32s[0])\n\tisEqual(t, int322, cfg.Int32s[1])\n\tisEqual(t, &int321, cfg.Int32Ptrs[0])\n\tisEqual(t, &int322, cfg.Int32Ptrs[1])\n\n\tisEqual(t, int641, cfg.Int64)\n\tisEqual(t, &int641, cfg.Int64Ptr)\n\tisEqual(t, int641, cfg.Int64s[0])\n\tisEqual(t, int642, cfg.Int64s[1])\n\tisEqual(t, &int641, cfg.Int64Ptrs[0])\n\tisEqual(t, &int642, cfg.Int64Ptrs[1])\n\n\tisEqual(t, uint1, cfg.Uint)\n\tisEqual(t, &uint1, cfg.UintPtr)\n\tisEqual(t, uint1, cfg.Uints[0])\n\tisEqual(t, uint2, cfg.Uints[1])\n\tisEqual(t, &uint1, cfg.UintPtrs[0])\n\tisEqual(t, &uint2, cfg.UintPtrs[1])\n\n\tisEqual(t, uint81, cfg.Uint8)\n\tisEqual(t, &uint81, cfg.Uint8Ptr)\n\tisEqual(t, uint81, cfg.Uint8s[0])\n\tisEqual(t, uint82, cfg.Uint8s[1])\n\tisEqual(t, &uint81, cfg.Uint8Ptrs[0])\n\tisEqual(t, &uint82, cfg.Uint8Ptrs[1])\n\n\tisEqual(t, uint161, cfg.Uint16)\n\tisEqual(t, &uint161, cfg.Uint16Ptr)\n\tisEqual(t, uint161, cfg.Uint16s[0])\n\tisEqual(t, uint162, cfg.Uint16s[1])\n\tisEqual(t, &uint161, cfg.Uint16Ptrs[0])\n\tisEqual(t, &uint162, cfg.Uint16Ptrs[1])\n\n\tisEqual(t, uint321, cfg.Uint32)\n\tisEqual(t, &uint321, cfg.Uint32Ptr)\n\tisEqual(t, uint321, cfg.Uint32s[0])\n\tisEqual(t, uint322, cfg.Uint32s[1])\n\tisEqual(t, &uint321, cfg.Uint32Ptrs[0])\n\tisEqual(t, &uint322, cfg.Uint32Ptrs[1])\n\n\tisEqual(t, uint641, cfg.Uint64)\n\tisEqual(t, &uint641, cfg.Uint64Ptr)\n\tisEqual(t, uint641, cfg.Uint64s[0])\n\tisEqual(t, uint642, cfg.Uint64s[1])\n\tisEqual(t, &uint641, cfg.Uint64Ptrs[0])\n\tisEqual(t, &uint642, cfg.Uint64Ptrs[1])\n\n\tisEqual(t, float321, cfg.Float32)\n\tisEqual(t, &float321, cfg.Float32Ptr)\n\tisEqual(t, float321, cfg.Float32s[0])\n\tisEqual(t, float322, cfg.Float32s[1])\n\tisEqual(t, &float321, cfg.Float32Ptrs[0])\n\n\tisEqual(t, float641, cfg.Float64)\n\tisEqual(t, &float641, cfg.Float64Ptr)\n\tisEqual(t, float641, cfg.Float64s[0])\n\tisEqual(t, float642, cfg.Float64s[1])\n\tisEqual(t, &float641, cfg.Float64Ptrs[0])\n\tisEqual(t, &float642, cfg.Float64Ptrs[1])\n\n\tisEqual(t, duration1, cfg.Duration)\n\tisEqual(t, &duration1, cfg.DurationPtr)\n\tisEqual(t, duration1, cfg.Durations[0])\n\tisEqual(t, duration2, cfg.Durations[1])\n\tisEqual(t, &duration1, cfg.DurationPtrs[0])\n\tisEqual(t, &duration2, cfg.DurationPtrs[1])\n\n\tisEqual(t, *location1, cfg.Location)\n\tisEqual(t, location1, cfg.LocationPtr)\n\tisEqual(t, *location1, cfg.Locations[0])\n\tisEqual(t, *location2, cfg.Locations[1])\n\tisEqual(t, location1, cfg.LocationPtrs[0])\n\tisEqual(t, location2, cfg.LocationPtrs[1])\n\n\tisEqual(t, unmarshaler1, cfg.Unmarshaler)\n\tisEqual(t, &unmarshaler1, cfg.UnmarshalerPtr)\n\tisEqual(t, unmarshaler1, cfg.Unmarshalers[0])\n\tisEqual(t, unmarshaler2, cfg.Unmarshalers[1])\n\tisEqual(t, &unmarshaler1, cfg.UnmarshalerPtrs[0])\n\tisEqual(t, &unmarshaler2, cfg.UnmarshalerPtrs[1])\n\n\tisEqual(t, url1, cfg.URL.String())\n\tisEqual(t, url1, cfg.URLPtr.String())\n\tisEqual(t, url1, cfg.URLs[0].String())\n\tisEqual(t, url2, cfg.URLs[1].String())\n\tisEqual(t, url1, cfg.URLPtrs[0].String())\n\tisEqual(t, url2, cfg.URLPtrs[1].String())\n\n\tisEqual(t, \"postgres://localhost:5432/db\", cfg.StringWithDefault)\n\tisEqual(t, nonDefinedStr, cfg.NonDefined.String)\n\tisEqual(t, nonDefinedStr, cfg.NestedNonDefined.NonDefined.String)\n\n\tisEqual(t, str1, cfg.CustomSeparator[0])\n\tisEqual(t, str2, cfg.CustomSeparator[1])\n\n\tisEqual(t, cfg.NotAnEnv, \"\")\n\n\tisEqual(t, cfg.unexported, \"\")\n}\n\nfunc TestParsesEnv_Map(t *testing.T) {\n\ttype config struct {\n\t\tMapStringString                map[string]string `env:\"MAP_STRING_STRING\" envSeparator:\",\"`\n\t\tMapStringInt64                 map[string]int64  `env:\"MAP_STRING_INT64\"`\n\t\tMapStringBool                  map[string]bool   `env:\"MAP_STRING_BOOL\" envSeparator:\";\"`\n\t\tCustomSeparatorMapStringString map[string]string `env:\"CUSTOM_SEPARATOR_MAP_STRING_STRING\" envSeparator:\",\" envKeyValSeparator:\"|\"`\n\t}\n\n\tmss := map[string]string{\n\t\t\"k1\": \"v1\",\n\t\t\"k2\": \"v2\",\n\t}\n\tt.Setenv(\"MAP_STRING_STRING\", \"k1:v1,k2:v2\")\n\n\tmsi := map[string]int64{\n\t\t\"k1\": 1,\n\t\t\"k2\": 2,\n\t}\n\tt.Setenv(\"MAP_STRING_INT64\", \"k1:1,k2:2\")\n\n\tmsb := map[string]bool{\n\t\t\"k1\": true,\n\t\t\"k2\": false,\n\t}\n\tt.Setenv(\"MAP_STRING_BOOL\", \"k1:true;k2:false\")\n\n\twithCustomSeparator := map[string]string{\n\t\t\"k1\": \"v1\",\n\t\t\"k2\": \"v2\",\n\t}\n\tt.Setenv(\"CUSTOM_SEPARATOR_MAP_STRING_STRING\", \"k1|v1,k2|v2\")\n\n\tvar cfg config\n\tisNoErr(t, Parse(&cfg))\n\n\tisEqual(t, mss, cfg.MapStringString)\n\tisEqual(t, msi, cfg.MapStringInt64)\n\tisEqual(t, msb, cfg.MapStringBool)\n\tisEqual(t, withCustomSeparator, cfg.CustomSeparatorMapStringString)\n}\n\nfunc TestParsesEnvInvalidMap(t *testing.T) {\n\ttype config struct {\n\t\tMapStringString map[string]string `env:\"MAP_STRING_STRING\" envSeparator:\",\"`\n\t}\n\n\tt.Setenv(\"MAP_STRING_STRING\", \"k1,k2:v2\")\n\n\tvar cfg config\n\terr := Parse(&cfg)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParseCustomMapType(t *testing.T) {\n\ttype custommap map[string]bool\n\n\ttype config struct {\n\t\tSecretKey custommap `env:\"SECRET_KEY\"`\n\t}\n\n\tt.Setenv(\"SECRET_KEY\", \"somesecretkey:1\")\n\n\tvar cfg config\n\tisNoErr(t, ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(custommap{}): func(_ string) (interface{}, error) {\n\t\t\treturn custommap(map[string]bool{}), nil\n\t\t},\n\t}}))\n}\n\nfunc TestParseMapCustomKeyType(t *testing.T) {\n\ttype CustomKey string\n\n\ttype config struct {\n\t\tSecretKey map[CustomKey]bool `env:\"SECRET\"`\n\t}\n\n\tt.Setenv(\"SECRET\", \"somesecretkey:1\")\n\n\tvar cfg config\n\tisNoErr(t, ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(CustomKey(\"\")): func(value string) (interface{}, error) {\n\t\t\treturn CustomKey(value), nil\n\t\t},\n\t}}))\n}\n\nfunc TestParseMapCustomKeyNoParser(t *testing.T) {\n\ttype CustomKey struct{}\n\n\ttype config struct {\n\t\tSecretKey map[CustomKey]bool `env:\"SECRET\"`\n\t}\n\n\tt.Setenv(\"SECRET\", \"somesecretkey:1\")\n\n\tvar cfg config\n\terr := Parse(&cfg)\n\tisTrue(t, errors.Is(err, NoParserError{}))\n}\n\nfunc TestParseMapCustomValueNoParser(t *testing.T) {\n\ttype Customval struct{}\n\n\ttype config struct {\n\t\tSecretKey map[string]Customval `env:\"SECRET\"`\n\t}\n\n\tt.Setenv(\"SECRET\", \"somesecretkey:1\")\n\n\tvar cfg config\n\terr := Parse(&cfg)\n\tisTrue(t, errors.Is(err, NoParserError{}))\n}\n\nfunc TestParseMapCustomKeyTypeError(t *testing.T) {\n\ttype CustomKey string\n\n\ttype config struct {\n\t\tSecretKey map[CustomKey]bool `env:\"SECRET\"`\n\t}\n\n\tt.Setenv(\"SECRET\", \"somesecretkey:1\")\n\n\tvar cfg config\n\terr := ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(CustomKey(\"\")): func(_ string) (interface{}, error) {\n\t\t\treturn nil, fmt.Errorf(\"custom error\")\n\t\t},\n\t}})\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParseMapCustomValueTypeError(t *testing.T) {\n\ttype Customval string\n\n\ttype config struct {\n\t\tSecretKey map[string]Customval `env:\"SECRET\"`\n\t}\n\n\tt.Setenv(\"SECRET\", \"somesecretkey:1\")\n\n\tvar cfg config\n\terr := ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(Customval(\"\")): func(_ string) (interface{}, error) {\n\t\t\treturn nil, fmt.Errorf(\"custom error\")\n\t\t},\n\t}})\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestSetenvAndTagOptsChain(t *testing.T) {\n\ttype config struct {\n\t\tKey1 string `mytag:\"KEY1,required\"`\n\t\tKey2 int    `mytag:\"KEY2,required\"`\n\t}\n\tenvs := map[string]string{\n\t\t\"KEY1\": \"VALUE1\",\n\t\t\"KEY2\": \"3\",\n\t}\n\n\tcfg := config{}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{TagName: \"mytag\", Environment: envs}))\n\tisEqual(t, \"VALUE1\", cfg.Key1)\n\tisEqual(t, 3, cfg.Key2)\n}\n\nfunc TestJSONTag(t *testing.T) {\n\ttype config struct {\n\t\tKey1 string `json:\"KEY1\"`\n\t\tKey2 int    `json:\"KEY2\"`\n\t}\n\n\tt.Setenv(\"KEY1\", \"VALUE7\")\n\tt.Setenv(\"KEY2\", \"5\")\n\n\tcfg := config{}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{TagName: \"json\"}))\n\tisEqual(t, \"VALUE7\", cfg.Key1)\n\tisEqual(t, 5, cfg.Key2)\n}\n\nfunc TestParsesEnvInner(t *testing.T) {\n\tt.Setenv(\"innervar\", \"someinnervalue\")\n\tt.Setenv(\"innernum\", \"8\")\n\tcfg := ParentStruct{\n\t\tInnerStruct: &InnerStruct{},\n\t\tunexported:  &InnerStruct{},\n\t}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"someinnervalue\", cfg.InnerStruct.Inner)\n\tisEqual(t, uint(8), cfg.InnerStruct.Number)\n}\n\nfunc TestParsesEnvInner_WhenInnerStructPointerIsNil(t *testing.T) {\n\tt.Setenv(\"innervar\", \"someinnervalue\")\n\tt.Setenv(\"innernum\", \"8\")\n\tcfg := ParentStruct{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"someinnervalue\", cfg.InnerStruct.Inner)\n\tisEqual(t, uint(8), cfg.InnerStruct.Number)\n}\n\nfunc TestParsesEnvInnerFails(t *testing.T) {\n\ttype config struct {\n\t\tFoo struct {\n\t\t\tNumber int `env:\"NUMBER\"`\n\t\t}\n\t}\n\tt.Setenv(\"NUMBER\", \"not-a-number\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Number\" of type \"int\": strconv.ParseInt: parsing \"not-a-number\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParsesEnvInnerFailsMultipleErrors(t *testing.T) {\n\ttype config struct {\n\t\tFoo struct {\n\t\t\tName   string `env:\"NAME,required\"`\n\t\t\tNumber int    `env:\"NUMBER\"`\n\t\t\tBar    struct {\n\t\t\t\tAge int `env:\"AGE,required\"`\n\t\t\t}\n\t\t}\n\t}\n\tt.Setenv(\"NUMBER\", \"not-a-number\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: required environment variable \"NAME\" is not set; parse error on field \"Number\" of type \"int\": strconv.ParseInt: parsing \"not-a-number\": invalid syntax; required environment variable \"AGE\" is not set`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n}\n\nfunc TestParsesEnvInnerNil(t *testing.T) {\n\tt.Setenv(\"innervar\", \"someinnervalue\")\n\tcfg := ParentStruct{}\n\tisNoErr(t, Parse(&cfg))\n}\n\nfunc TestParsesEnvInnerInvalid(t *testing.T) {\n\tt.Setenv(\"innernum\", \"-547\")\n\tcfg := ParentStruct{\n\t\tInnerStruct: &InnerStruct{},\n\t}\n\terr := Parse(&cfg)\n\tisErrorWithMessage(t, err, `env: parse error on field \"Number\" of type \"uint\": strconv.ParseUint: parsing \"-547\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParsesEnvNested(t *testing.T) {\n\tt.Setenv(\"nestedvar\", \"somenestedvalue\")\n\tvar cfg ForNestedStruct\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"somenestedvalue\", cfg.NestedVar)\n}\n\nfunc TestEmptyVars(t *testing.T) {\n\tcfg := Config{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"\", cfg.String)\n\tisEqual(t, false, cfg.Bool)\n\tisEqual(t, 0, cfg.Int)\n\tisEqual(t, uint(0), cfg.Uint)\n\tisEqual(t, uint64(0), cfg.Uint64)\n\tisEqual(t, int64(0), cfg.Int64)\n\tisEqual(t, 0, len(cfg.Strings))\n\tisEqual(t, 0, len(cfg.CustomSeparator))\n\tisEqual(t, 0, len(cfg.Ints))\n\tisEqual(t, 0, len(cfg.Bools))\n}\n\nfunc TestPassAnInvalidPtr(t *testing.T) {\n\tvar thisShouldBreak int\n\terr := Parse(&thisShouldBreak)\n\tisErrorWithMessage(t, err, \"env: expected a pointer to a Struct\")\n\tisTrue(t, errors.Is(err, NotStructPtrError{}))\n}\n\nfunc TestPassReference(t *testing.T) {\n\tcfg := Config{}\n\terr := Parse(cfg)\n\tisErrorWithMessage(t, err, \"env: expected a pointer to a Struct\")\n\tisTrue(t, errors.Is(err, NotStructPtrError{}))\n}\n\nfunc TestInvalidBool(t *testing.T) {\n\tt.Setenv(\"BOOL\", \"should-be-a-bool\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Bool\" of type \"bool\": strconv.ParseBool: parsing \"should-be-a-bool\": invalid syntax; parse error on field \"BoolPtr\" of type \"*bool\": strconv.ParseBool: parsing \"should-be-a-bool\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidInt(t *testing.T) {\n\tt.Setenv(\"INT\", \"should-be-an-int\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Int\" of type \"int\": strconv.ParseInt: parsing \"should-be-an-int\": invalid syntax; parse error on field \"IntPtr\" of type \"*int\": strconv.ParseInt: parsing \"should-be-an-int\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidUint(t *testing.T) {\n\tt.Setenv(\"UINT\", \"-44\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Uint\" of type \"uint\": strconv.ParseUint: parsing \"-44\": invalid syntax; parse error on field \"UintPtr\" of type \"*uint\": strconv.ParseUint: parsing \"-44\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidFloat32(t *testing.T) {\n\tt.Setenv(\"FLOAT32\", \"AAA\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Float32\" of type \"float32\": strconv.ParseFloat: parsing \"AAA\": invalid syntax; parse error on field \"Float32Ptr\" of type \"*float32\": strconv.ParseFloat: parsing \"AAA\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidFloat64(t *testing.T) {\n\tt.Setenv(\"FLOAT64\", \"AAA\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Float64\" of type \"float64\": strconv.ParseFloat: parsing \"AAA\": invalid syntax; parse error on field \"Float64Ptr\" of type \"*float64\": strconv.ParseFloat: parsing \"AAA\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidUint64(t *testing.T) {\n\tt.Setenv(\"UINT64\", \"AAA\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Uint64\" of type \"uint64\": strconv.ParseUint: parsing \"AAA\": invalid syntax; parse error on field \"Uint64Ptr\" of type \"*uint64\": strconv.ParseUint: parsing \"AAA\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidInt64(t *testing.T) {\n\tt.Setenv(\"INT64\", \"AAA\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Int64\" of type \"int64\": strconv.ParseInt: parsing \"AAA\": invalid syntax; parse error on field \"Int64Ptr\" of type \"*int64\": strconv.ParseInt: parsing \"AAA\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidInt64Slice(t *testing.T) {\n\tt.Setenv(\"BADINTS\", \"A,2,3\")\n\ttype config struct {\n\t\tBadFloats []int64 `env:\"BADINTS\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"BadFloats\" of type \"[]int64\": strconv.ParseInt: parsing \"A\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidUInt64Slice(t *testing.T) {\n\tt.Setenv(\"BADINTS\", \"A,2,3\")\n\ttype config struct {\n\t\tBadFloats []uint64 `env:\"BADINTS\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"BadFloats\" of type \"[]uint64\": strconv.ParseUint: parsing \"A\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidFloat32Slice(t *testing.T) {\n\tt.Setenv(\"BADFLOATS\", \"A,2.0,3.0\")\n\ttype config struct {\n\t\tBadFloats []float32 `env:\"BADFLOATS\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"BadFloats\" of type \"[]float32\": strconv.ParseFloat: parsing \"A\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidFloat64Slice(t *testing.T) {\n\tt.Setenv(\"BADFLOATS\", \"A,2.0,3.0\")\n\ttype config struct {\n\t\tBadFloats []float64 `env:\"BADFLOATS\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"BadFloats\" of type \"[]float64\": strconv.ParseFloat: parsing \"A\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidBoolsSlice(t *testing.T) {\n\tt.Setenv(\"BADBOOLS\", \"t,f,TRUE,faaaalse\")\n\ttype config struct {\n\t\tBadBools []bool `env:\"BADBOOLS\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"BadBools\" of type \"[]bool\": strconv.ParseBool: parsing \"faaaalse\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidDuration(t *testing.T) {\n\tt.Setenv(\"DURATION\", \"should-be-a-valid-duration\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Duration\" of type \"time.Duration\": unable to parse duration: time: invalid duration \"should-be-a-valid-duration\"; parse error on field \"DurationPtr\" of type \"*time.Duration\": unable to parse duration: time: invalid duration \"should-be-a-valid-duration\"`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidDurations(t *testing.T) {\n\tt.Setenv(\"DURATIONS\", \"1s,contains-an-invalid-duration,3s\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Durations\" of type \"[]time.Duration\": unable to parse duration: time: invalid duration \"contains-an-invalid-duration\"; parse error on field \"DurationPtrs\" of type \"[]*time.Duration\": unable to parse duration: time: invalid duration \"contains-an-invalid-duration\"`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidLocation(t *testing.T) {\n\tt.Setenv(\"LOCATION\", \"should-be-a-valid-location\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Location\" of type \"time.Location\": unable to parse location: unknown time zone should-be-a-valid-location; parse error on field \"LocationPtr\" of type \"*time.Location\": unable to parse location: unknown time zone should-be-a-valid-location`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestInvalidLocations(t *testing.T) {\n\tt.Setenv(\"LOCATIONS\", \"should-be-a-valid-location,UTC,Europe/Berlin\")\n\terr := Parse(&Config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Locations\" of type \"[]time.Location\": unable to parse location: unknown time zone should-be-a-valid-location; parse error on field \"LocationPtrs\" of type \"[]*time.Location\": unable to parse location: unknown time zone should-be-a-valid-location`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParseStructWithoutEnvTag(t *testing.T) {\n\tcfg := Config{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, cfg.NotAnEnv, \"\")\n}\n\nfunc TestParseStructWithInvalidFieldKind(t *testing.T) {\n\ttype config struct {\n\t\tWontWorkByte byte `env:\"BLAH\"`\n\t}\n\tt.Setenv(\"BLAH\", \"a\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"WontWorkByte\" of type \"uint8\": strconv.ParseUint: parsing \"a\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestUnsupportedSliceType(t *testing.T) {\n\ttype config struct {\n\t\tWontWork []map[int]int `env:\"WONTWORK\"`\n\t}\n\n\tt.Setenv(\"WONTWORK\", \"1,2,3\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: no parser found for field \"WontWork\" of type \"[]map[int]int\"`)\n\tisTrue(t, errors.Is(err, NoParserError{}))\n}\n\nfunc TestBadSeparator(t *testing.T) {\n\ttype config struct {\n\t\tWontWork []int `env:\"WONTWORK\" envSeparator:\":\"`\n\t}\n\n\tt.Setenv(\"WONTWORK\", \"1,2,3,4\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"WontWork\" of type \"[]int\": strconv.ParseInt: parsing \"1,2,3,4\": invalid syntax`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestNoErrorRequiredSet(t *testing.T) {\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,required\"`\n\t}\n\n\tcfg := &config{}\n\n\tt.Setenv(\"IS_REQUIRED\", \"\")\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"\", cfg.IsRequired)\n}\n\nfunc TestHook(t *testing.T) {\n\ttype config struct {\n\t\tSomething string `env:\"SOMETHING\" envDefault:\"important\"`\n\t\tAnother   string `env:\"ANOTHER\"`\n\t\tNope      string\n\t\tInner     struct{} `envPrefix:\"FOO_\"`\n\t}\n\n\tcfg := &config{}\n\tt.Setenv(\"ANOTHER\", \"1\")\n\n\ttype onSetArgs struct {\n\t\ttag       string\n\t\tkey       interface{}\n\t\tisDefault bool\n\t}\n\n\tvar onSetCalled []onSetArgs\n\n\tisNoErr(t, ParseWithOptions(cfg, Options{\n\t\tOnSet: func(tag string, value interface{}, isDefault bool) {\n\t\t\tonSetCalled = append(onSetCalled, onSetArgs{tag, value, isDefault})\n\t\t},\n\t}))\n\tisEqual(t, \"important\", cfg.Something)\n\tisEqual(t, \"1\", cfg.Another)\n\tisEqual(t, 2, len(onSetCalled))\n\tisEqual(t, onSetArgs{\"SOMETHING\", \"important\", true}, onSetCalled[0])\n\tisEqual(t, onSetArgs{\"ANOTHER\", \"1\", false}, onSetCalled[1])\n}\n\nfunc TestErrorRequiredWithDefault(t *testing.T) {\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,required\" envDefault:\"important\"`\n\t}\n\n\tcfg := &config{}\n\n\tt.Setenv(\"IS_REQUIRED\", \"\")\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"important\", cfg.IsRequired)\n}\n\nfunc TestErrorRequiredNotSet(t *testing.T) {\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,required\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: required environment variable \"IS_REQUIRED\" is not set`)\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n}\n\nfunc TestNoErrorNotEmptySet(t *testing.T) {\n\tt.Setenv(\"IS_REQUIRED\", \"1\")\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,notEmpty\"`\n\t}\n\tisNoErr(t, Parse(&config{}))\n}\n\nfunc TestNoErrorRequiredAndNotEmptySet(t *testing.T) {\n\tt.Setenv(\"IS_REQUIRED\", \"1\")\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,required,notEmpty\"`\n\t}\n\tisNoErr(t, Parse(&config{}))\n}\n\nfunc TestErrorNotEmptySet(t *testing.T) {\n\tt.Setenv(\"IS_REQUIRED\", \"\")\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,notEmpty\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: environment variable \"IS_REQUIRED\" should not be empty`)\n\tisTrue(t, errors.Is(err, EmptyVarError{}))\n}\n\nfunc TestErrorRequiredAndNotEmptySet(t *testing.T) {\n\tt.Setenv(\"IS_REQUIRED\", \"\")\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,notEmpty,required\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: environment variable \"IS_REQUIRED\" should not be empty`)\n\tisTrue(t, errors.Is(err, EmptyVarError{}))\n}\n\nfunc TestErrorRequiredNotSetWithDefault(t *testing.T) {\n\ttype config struct {\n\t\tIsRequired string `env:\"IS_REQUIRED,required\" envDefault:\"important\"`\n\t}\n\n\tcfg := &config{}\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"important\", cfg.IsRequired)\n}\n\nfunc TestParseExpandOption(t *testing.T) {\n\ttype config struct {\n\t\tHost        string `env:\"HOST\" envDefault:\"localhost\"`\n\t\tPort        int    `env:\"PORT,expand\" envDefault:\"3000\"`\n\t\tSecretKey   string `env:\"SECRET_KEY,expand\"`\n\t\tExpandKey   string `env:\"EXPAND_KEY\"`\n\t\tCompoundKey string `env:\"HOST_PORT,expand\" envDefault:\"${HOST}:${PORT}\"`\n\t\tDefault     string `env:\"DEFAULT,expand\" envDefault:\"def1\"`\n\t}\n\n\tt.Setenv(\"HOST\", \"localhost\")\n\tt.Setenv(\"PORT\", \"3000\")\n\tt.Setenv(\"EXPAND_KEY\", \"qwerty12345\")\n\tt.Setenv(\"SECRET_KEY\", \"${EXPAND_KEY}\")\n\n\tcfg := config{}\n\terr := Parse(&cfg)\n\n\tisNoErr(t, err)\n\tisEqual(t, \"localhost\", cfg.Host)\n\tisEqual(t, 3000, cfg.Port)\n\tisEqual(t, \"qwerty12345\", cfg.SecretKey)\n\tisEqual(t, \"qwerty12345\", cfg.ExpandKey)\n\tisEqual(t, \"localhost:3000\", cfg.CompoundKey)\n\tisEqual(t, \"def1\", cfg.Default)\n}\n\nfunc TestParseExpandWithDefaultOption(t *testing.T) {\n\ttype config struct {\n\t\tHost            string `env:\"HOST\" envDefault:\"localhost\"`\n\t\tPort            int    `env:\"PORT,expand\" envDefault:\"3000\"`\n\t\tOtherPort       int    `env:\"OTHER_PORT\" envDefault:\"4000\"`\n\t\tCompoundDefault string `env:\"HOST_PORT,expand\" envDefault:\"${HOST}:${PORT}\"`\n\t\tSimpleDefault   string `env:\"DEFAULT,expand\" envDefault:\"def1\"`\n\t\tMixedDefault    string `env:\"MIXED_DEFAULT,expand\" envDefault:\"$USER@${HOST}:${OTHER_PORT}\"`\n\t\tOverrideDefault string `env:\"OVERRIDE_DEFAULT,expand\"`\n\t\tDefaultIsExpand string `env:\"DEFAULT_IS_EXPAND,expand\" envDefault:\"$THIS_IS_EXPAND\"`\n\t\tNoDefault       string `env:\"NO_DEFAULT,expand\"`\n\t}\n\n\tt.Setenv(\"OTHER_PORT\", \"5000\")\n\tt.Setenv(\"USER\", \"jhon\")\n\tt.Setenv(\"THIS_IS_USED\", \"this is used instead\")\n\tt.Setenv(\"OVERRIDE_DEFAULT\", \"msg: ${THIS_IS_USED}\")\n\tt.Setenv(\"THIS_IS_EXPAND\", \"msg: ${THIS_IS_USED}\")\n\tt.Setenv(\"NO_DEFAULT\", \"$PORT:$OTHER_PORT\")\n\n\tcfg := config{}\n\terr := Parse(&cfg)\n\n\tisNoErr(t, err)\n\tisEqual(t, \"localhost\", cfg.Host)\n\tisEqual(t, 3000, cfg.Port)\n\tisEqual(t, 5000, cfg.OtherPort)\n\tisEqual(t, \"localhost:3000\", cfg.CompoundDefault)\n\tisEqual(t, \"def1\", cfg.SimpleDefault)\n\tisEqual(t, \"jhon@localhost:5000\", cfg.MixedDefault)\n\tisEqual(t, \"msg: this is used instead\", cfg.OverrideDefault)\n\tisEqual(t, \"3000:5000\", cfg.NoDefault)\n}\n\nfunc TestParseUnsetRequireOptions(t *testing.T) {\n\ttype config struct {\n\t\tPassword string `env:\"PASSWORD,unset,required\"`\n\t}\n\tcfg := config{}\n\n\terr := Parse(&cfg)\n\tisErrorWithMessage(t, err, `env: required environment variable \"PASSWORD\" is not set`)\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n\tt.Setenv(\"PASSWORD\", \"superSecret\")\n\tisNoErr(t, Parse(&cfg))\n\n\tisEqual(t, \"superSecret\", cfg.Password)\n\tunset, exists := os.LookupEnv(\"PASSWORD\")\n\tisEqual(t, \"\", unset)\n\tisEqual(t, false, exists)\n}\n\nfunc TestCustomParser(t *testing.T) {\n\ttype foo struct {\n\t\tname string\n\t}\n\n\ttype bar struct {\n\t\tName string `env:\"OTHER_CUSTOM\"`\n\t\tFoo  *foo   `env:\"BLAH_CUSTOM\"`\n\t}\n\n\ttype config struct {\n\t\tVar   foo  `env:\"VAR_CUSTOM\"`\n\t\tFoo   *foo `env:\"BLAH_CUSTOM\"`\n\t\tOther *bar\n\t}\n\n\tt.Setenv(\"VAR_CUSTOM\", \"test\")\n\tt.Setenv(\"OTHER_CUSTOM\", \"test2\")\n\tt.Setenv(\"BLAH_CUSTOM\", \"test3\")\n\n\truntest := func(t *testing.T) {\n\t\tt.Helper()\n\t\tcfg := &config{\n\t\t\tOther: &bar{},\n\t\t}\n\t\terr := ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\t\treflect.TypeOf(foo{}): func(v string) (interface{}, error) {\n\t\t\t\treturn foo{name: v}, nil\n\t\t\t},\n\t\t}})\n\n\t\tisNoErr(t, err)\n\t\tisEqual(t, cfg.Var.name, \"test\")\n\t\tisEqual(t, cfg.Foo.name, \"test3\")\n\t\tisEqual(t, cfg.Other.Name, \"test2\")\n\t\tisEqual(t, cfg.Other.Foo.name, \"test3\")\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(fmt.Sprintf(\"%d\", i), runtest)\n\t}\n}\n\nfunc TestIssue226(t *testing.T) {\n\ttype config struct {\n\t\tInner struct {\n\t\t\tAbc []byte `env:\"ABC\" envDefault:\"asdasd\"`\n\t\t\tDef []byte `env:\"DEF\" envDefault:\"a\"`\n\t\t}\n\t\tHij []byte `env:\"HIJ\"`\n\t\tLmn []byte `env:\"LMN\"`\n\t}\n\n\tt.Setenv(\"HIJ\", \"a\")\n\tt.Setenv(\"LMN\", \"b\")\n\n\tcfg := &config{}\n\tisNoErr(t, ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf([]byte{0}): func(v string) (interface{}, error) {\n\t\t\tif v == \"a\" {\n\t\t\t\treturn []byte(\"nope\"), nil\n\t\t\t}\n\t\t\treturn []byte(v), nil\n\t\t},\n\t}}))\n\tisEqual(t, cfg.Inner.Abc, []byte(\"asdasd\"))\n\tisEqual(t, cfg.Inner.Def, []byte(\"nope\"))\n\tisEqual(t, cfg.Hij, []byte(\"nope\"))\n\tisEqual(t, cfg.Lmn, []byte(\"b\"))\n}\n\nfunc TestParseWithOptionsNoPtr(t *testing.T) {\n\ttype foo struct{}\n\terr := ParseWithOptions(foo{}, Options{})\n\tisErrorWithMessage(t, err, \"env: expected a pointer to a Struct\")\n\tisTrue(t, errors.Is(err, NotStructPtrError{}))\n}\n\nfunc TestParseWithOptionsInvalidType(t *testing.T) {\n\tvar c int\n\terr := ParseWithOptions(&c, Options{})\n\tisErrorWithMessage(t, err, \"env: expected a pointer to a Struct\")\n\tisTrue(t, errors.Is(err, NotStructPtrError{}))\n}\n\nfunc TestCustomParserError(t *testing.T) {\n\ttype foo struct {\n\t\tname string\n\t}\n\n\tcustomParserFunc := func(_ string) (interface{}, error) {\n\t\treturn nil, errors.New(\"something broke\")\n\t}\n\n\tt.Run(\"single\", func(t *testing.T) {\n\t\ttype config struct {\n\t\t\tVar foo `env:\"VAR\"`\n\t\t}\n\n\t\tt.Setenv(\"VAR\", \"single\")\n\t\tcfg := &config{}\n\t\terr := ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\t\treflect.TypeOf(foo{}): customParserFunc,\n\t\t}})\n\n\t\tisEqual(t, cfg.Var.name, \"\")\n\t\tisErrorWithMessage(t, err, `env: parse error on field \"Var\" of type \"env.foo\": something broke`)\n\t\tisTrue(t, errors.Is(err, ParseError{}))\n\t})\n\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\ttype config struct {\n\t\t\tVar []foo `env:\"VAR2\"`\n\t\t}\n\t\tt.Setenv(\"VAR2\", \"slice,slace\")\n\n\t\tcfg := &config{}\n\t\terr := ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\t\treflect.TypeOf(foo{}): customParserFunc,\n\t\t}})\n\n\t\tisEqual(t, cfg.Var, nil)\n\t\tisErrorWithMessage(t, err, `env: parse error on field \"Var\" of type \"[]env.foo\": something broke`)\n\t\tisTrue(t, errors.Is(err, ParseError{}))\n\t})\n}\n\nfunc TestCustomParserBasicType(t *testing.T) {\n\ttype ConstT int32\n\n\ttype config struct {\n\t\tConst ConstT `env:\"CONST_\"`\n\t}\n\n\texp := ConstT(123)\n\tt.Setenv(\"CONST_\", fmt.Sprintf(\"%d\", exp))\n\n\tcustomParserFunc := func(v string) (interface{}, error) {\n\t\ti, err := strconv.Atoi(v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr := ConstT(i)\n\t\treturn r, nil\n\t}\n\n\tcfg := &config{}\n\terr := ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(ConstT(0)): customParserFunc,\n\t}})\n\n\tisNoErr(t, err)\n\tisEqual(t, exp, cfg.Const)\n}\n\nfunc TestCustomParserUint64Alias(t *testing.T) {\n\ttype T uint64\n\n\tvar one T = 1\n\n\ttype config struct {\n\t\tVal T `env:\"\" envDefault:\"1x\"`\n\t}\n\n\tparserCalled := false\n\n\ttParser := func(value string) (interface{}, error) {\n\t\tparserCalled = true\n\t\ttrimmed := strings.TrimSuffix(value, \"x\")\n\t\ti, err := strconv.Atoi(trimmed)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn T(i), nil\n\t}\n\n\tcfg := config{}\n\n\terr := ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(one): tParser,\n\t}})\n\n\tisTrue(t, parserCalled)\n\tisNoErr(t, err)\n\tisEqual(t, T(1), cfg.Val)\n}\n\nfunc TestTypeCustomParserBasicInvalid(t *testing.T) {\n\ttype ConstT int32\n\n\ttype config struct {\n\t\tConst ConstT `env:\"CONST_\"`\n\t}\n\n\tt.Setenv(\"CONST_\", \"foobar\")\n\n\tcustomParserFunc := func(_ string) (interface{}, error) {\n\t\treturn nil, errors.New(\"random error\")\n\t}\n\n\tcfg := &config{}\n\terr := ParseWithOptions(cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(ConstT(0)): customParserFunc,\n\t}})\n\n\tisEqual(t, cfg.Const, ConstT(0))\n\tisErrorWithMessage(t, err, `env: parse error on field \"Const\" of type \"env.ConstT\": random error`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestCustomParserNotCalledForNonAlias(t *testing.T) {\n\ttype T uint64\n\ttype U uint64\n\n\ttype config struct {\n\t\tVal   uint64 `env:\"\" envDefault:\"33\"`\n\t\tOther U      `env:\"OTHER_NAME\" envDefault:\"44\"`\n\t}\n\n\ttParserCalled := false\n\n\ttParser := func(_ string) (interface{}, error) {\n\t\ttParserCalled = true\n\t\treturn T(99), nil\n\t}\n\n\tcfg := config{}\n\n\terr := ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(T(0)): tParser,\n\t}})\n\n\tisFalse(t, tParserCalled)\n\tisNoErr(t, err)\n\tisEqual(t, uint64(33), cfg.Val)\n\tisEqual(t, U(44), cfg.Other)\n}\n\nfunc TestCustomParserBasicUnsupported(t *testing.T) {\n\ttype ConstT struct {\n\t\tA int\n\t}\n\n\ttype config struct {\n\t\tConst ConstT `env:\"CONST_\"`\n\t}\n\n\tt.Setenv(\"CONST_\", \"42\")\n\n\tcfg := &config{}\n\terr := Parse(cfg)\n\n\tisEqual(t, cfg.Const, ConstT{0})\n\tisErrorWithMessage(t, err, `env: no parser found for field \"Const\" of type \"env.ConstT\"`)\n\tisTrue(t, errors.Is(err, NoParserError{}))\n}\n\nfunc TestUnsupportedStructType(t *testing.T) {\n\ttype config struct {\n\t\tFoo http.Client `env:\"FOO\"`\n\t}\n\tt.Setenv(\"FOO\", \"foo\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: no parser found for field \"Foo\" of type \"http.Client\"`)\n\tisTrue(t, errors.Is(err, NoParserError{}))\n}\n\nfunc TestEmptyOption(t *testing.T) {\n\ttype config struct {\n\t\tVar string `env:\"VAR,\"`\n\t}\n\n\tcfg := &config{}\n\n\tt.Setenv(\"VAR\", \"\")\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"\", cfg.Var)\n}\n\nfunc TestErrorOptionNotRecognized(t *testing.T) {\n\ttype config struct {\n\t\tVar string `env:\"VAR,not_supported!\"`\n\t}\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: tag option \"not_supported!\" not supported`)\n\tisTrue(t, errors.Is(err, NoSupportedTagOptionError{}))\n}\n\nfunc TestTextUnmarshalerError(t *testing.T) {\n\ttype config struct {\n\t\tUnmarshaler unmarshaler `env:\"UNMARSHALER\"`\n\t}\n\tt.Setenv(\"UNMARSHALER\", \"invalid\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Unmarshaler\" of type \"env.unmarshaler\": time: invalid duration \"invalid\"`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestTextUnmarshalersError(t *testing.T) {\n\ttype config struct {\n\t\tUnmarshalers []unmarshaler `env:\"UNMARSHALERS\"`\n\t}\n\tt.Setenv(\"UNMARSHALERS\", \"1s,invalid\")\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"Unmarshalers\" of type \"[]env.unmarshaler\": time: invalid duration \"invalid\"`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestParseURL(t *testing.T) {\n\ttype config struct {\n\t\tExampleURL url.URL `env:\"EXAMPLE_URL\" envDefault:\"https://google.com\"`\n\t}\n\tvar cfg config\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"https://google.com\", cfg.ExampleURL.String())\n}\n\nfunc TestParseInvalidURL(t *testing.T) {\n\ttype config struct {\n\t\tExampleURL url.URL `env:\"EXAMPLE_URL_2\"`\n\t}\n\tt.Setenv(\"EXAMPLE_URL_2\", \"nope://s s/\")\n\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: parse error on field \"ExampleURL\" of type \"url.URL\": unable to parse URL: parse \"nope://s s/\": invalid character \" \" in host name`)\n\tisTrue(t, errors.Is(err, ParseError{}))\n}\n\nfunc TestIgnoresUnexported(t *testing.T) {\n\ttype unexportedConfig struct {\n\t\thome  string `env:\"HOME\"`\n\t\tHome2 string `env:\"HOME\"`\n\t}\n\tcfg := unexportedConfig{}\n\n\tt.Setenv(\"HOME\", \"/tmp/fakehome\")\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, cfg.home, \"\")\n\tisEqual(t, \"/tmp/fakehome\", cfg.Home2)\n}\n\ntype LogLevel int8\n\nfunc (l *LogLevel) UnmarshalText(text []byte) error {\n\ttxt := string(text)\n\tswitch txt {\n\tcase \"debug\":\n\t\t*l = DebugLevel\n\tcase \"info\":\n\t\t*l = InfoLevel\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown level: %q\", txt)\n\t}\n\n\treturn nil\n}\n\nconst (\n\tDebugLevel LogLevel = iota - 1\n\tInfoLevel\n)\n\nfunc TestPrecedenceUnmarshalText(t *testing.T) {\n\tt.Setenv(\"LOG_LEVEL\", \"debug\")\n\tt.Setenv(\"LOG_LEVELS\", \"debug,info\")\n\n\ttype config struct {\n\t\tLogLevel  LogLevel   `env:\"LOG_LEVEL\"`\n\t\tLogLevels []LogLevel `env:\"LOG_LEVELS\"`\n\t}\n\tvar cfg config\n\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, DebugLevel, cfg.LogLevel)\n\tisEqual(t, []LogLevel{DebugLevel, InfoLevel}, cfg.LogLevels)\n}\n\nfunc TestFile(t *testing.T) {\n\ttype config struct {\n\t\tSecretKey string `env:\"SECRET_KEY,file\"`\n\t}\n\n\tdir := t.TempDir()\n\tfile := filepath.Join(dir, \"sec_key\")\n\tisNoErr(t, os.WriteFile(file, []byte(\"secret\"), 0o660))\n\n\tt.Setenv(\"SECRET_KEY\", file)\n\n\tcfg := config{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"secret\", cfg.SecretKey)\n}\n\nfunc TestFileNoParam(t *testing.T) {\n\ttype config struct {\n\t\tSecretKey string `env:\"SECRET_KEY,file\"`\n\t}\n\n\tcfg := config{}\n\tisNoErr(t, Parse(&cfg))\n}\n\nfunc TestFileNoParamRequired(t *testing.T) {\n\ttype config struct {\n\t\tSecretKey string `env:\"SECRET_KEY,file,required\"`\n\t}\n\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, `env: required environment variable \"SECRET_KEY\" is not set`)\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n}\n\nfunc TestFileBadFile(t *testing.T) {\n\ttype config struct {\n\t\tSecretKey string `env:\"SECRET_KEY,file\"`\n\t}\n\n\tfilename := \"not-a-real-file\"\n\tt.Setenv(\"SECRET_KEY\", filename)\n\n\toserr := \"no such file or directory\"\n\tif runtime.GOOS == \"windows\" {\n\t\toserr = \"The system cannot find the file specified.\"\n\t}\n\n\terr := Parse(&config{})\n\tisErrorWithMessage(t, err, fmt.Sprintf(\"env: could not load content of file %q from variable SECRET_KEY: open %s: %s\", filename, filename, oserr))\n\tisTrue(t, errors.Is(err, LoadFileContentError{}))\n}\n\nfunc TestFileWithDefault(t *testing.T) {\n\ttype config struct {\n\t\tSecretKey string `env:\"SECRET_KEY,file,expand\" envDefault:\"${FILE}\"`\n\t}\n\n\tdir := t.TempDir()\n\tfile := filepath.Join(dir, \"sec_key\")\n\tisNoErr(t, os.WriteFile(file, []byte(\"secret\"), 0o660))\n\n\tt.Setenv(\"FILE\", file)\n\n\tcfg := config{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"secret\", cfg.SecretKey)\n}\n\nfunc TestCustomSliceType(t *testing.T) {\n\ttype customslice []byte\n\n\ttype config struct {\n\t\tSecretKey customslice `env:\"SECRET_KEY\"`\n\t}\n\n\tt.Setenv(\"SECRET_KEY\", \"somesecretkey\")\n\n\tvar cfg config\n\tisNoErr(t, ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(customslice{}): func(value string) (interface{}, error) {\n\t\t\treturn customslice(value), nil\n\t\t},\n\t}}))\n}\n\ntype MyTime time.Time\n\nfunc (t *MyTime) UnmarshalText(text []byte) error {\n\ttt, err := time.Parse(\"2006-01-02\", string(text))\n\t*t = MyTime(tt)\n\treturn err\n}\n\nfunc TestCustomTimeParser(t *testing.T) {\n\ttype config struct {\n\t\tSomeTime MyTime `env:\"SOME_TIME\"`\n\t}\n\n\tt.Setenv(\"SOME_TIME\", \"2021-05-06\")\n\n\tvar cfg config\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, 2021, time.Time(cfg.SomeTime).Year())\n\tisEqual(t, time.Month(5), time.Time(cfg.SomeTime).Month())\n\tisEqual(t, 6, time.Time(cfg.SomeTime).Day())\n}\n\nfunc TestRequiredIfNoDefOption(t *testing.T) {\n\ttype Tree struct {\n\t\tFruit string `env:\"FRUIT\"`\n\t}\n\ttype config struct {\n\t\tName  string `env:\"NAME\"`\n\t\tGenre string `env:\"GENRE\" envDefault:\"Unknown\"`\n\t\tTree\n\t}\n\tvar cfg config\n\n\tt.Run(\"missing\", func(t *testing.T) {\n\t\terr := ParseWithOptions(&cfg, Options{RequiredIfNoDef: true})\n\t\tisErrorWithMessage(t, err, `env: required environment variable \"NAME\" is not set; required environment variable \"FRUIT\" is not set`)\n\t\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n\t\tt.Setenv(\"NAME\", \"John\")\n\t\terr = ParseWithOptions(&cfg, Options{RequiredIfNoDef: true})\n\t\tisErrorWithMessage(t, err, `env: required environment variable \"FRUIT\" is not set`)\n\t\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n\t})\n\n\tt.Run(\"all set\", func(t *testing.T) {\n\t\tt.Setenv(\"NAME\", \"John\")\n\t\tt.Setenv(\"FRUIT\", \"Apple\")\n\n\t\t// should not trigger an error for the missing 'GENRE' env because it has a default value.\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{RequiredIfNoDef: true}))\n\t})\n}\n\nfunc TestRequiredIfNoDefNested(t *testing.T) {\n\ttype Server struct {\n\t\tHost string `env:\"HOST\"`\n\t\tPort uint16 `env:\"PORT\"`\n\t}\n\ttype API struct {\n\t\tServer\n\t\tToken string `env:\"TOKEN\"`\n\t}\n\ttype config struct {\n\t\tAPI API `envPrefix:\"SERVER_\"`\n\t}\n\n\tt.Run(\"missing\", func(t *testing.T) {\n\t\tvar cfg config\n\t\tt.Setenv(\"SERVER_HOST\", \"https://google.com\")\n\t\tt.Setenv(\"SERVER_TOKEN\", \"0xdeadfood\")\n\n\t\terr := ParseWithOptions(&cfg, Options{RequiredIfNoDef: true})\n\t\tisErrorWithMessage(t, err, `env: required environment variable \"SERVER_PORT\" is not set`)\n\t\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n\t})\n\n\tt.Run(\"all set\", func(t *testing.T) {\n\t\tvar cfg config\n\t\tt.Setenv(\"SERVER_HOST\", \"https://google.com\")\n\t\tt.Setenv(\"SERVER_PORT\", \"443\")\n\t\tt.Setenv(\"SERVER_TOKEN\", \"0xdeadfood\")\n\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{RequiredIfNoDef: true}))\n\t})\n}\n\nfunc TestPrefix(t *testing.T) {\n\ttype Config struct {\n\t\tHome string `env:\"HOME\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo   Config `envPrefix:\"FOO_\"`\n\t\tBar   Config `envPrefix:\"BAR_\"`\n\t\tClean Config\n\t}\n\tcfg := ComplexConfig{}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{\"FOO_HOME\": \"/foo\", \"BAR_HOME\": \"/bar\", \"HOME\": \"/clean\"}}))\n\tisEqual(t, \"/foo\", cfg.Foo.Home)\n\tisEqual(t, \"/bar\", cfg.Bar.Home)\n\tisEqual(t, \"/clean\", cfg.Clean.Home)\n}\n\nfunc TestPrefixPointers(t *testing.T) {\n\ttype Test struct {\n\t\tStr string `env:\"TEST\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo   *Test `envPrefix:\"FOO_\"`\n\t\tBar   *Test `envPrefix:\"BAR_\"`\n\t\tClean *Test\n\t}\n\n\tcfg := ComplexConfig{\n\t\tFoo:   &Test{},\n\t\tBar:   &Test{},\n\t\tClean: &Test{},\n\t}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{\"FOO_TEST\": \"kek\", \"BAR_TEST\": \"lel\", \"TEST\": \"clean\"}}))\n\tisEqual(t, \"kek\", cfg.Foo.Str)\n\tisEqual(t, \"lel\", cfg.Bar.Str)\n\tisEqual(t, \"clean\", cfg.Clean.Str)\n}\n\nfunc TestNestedPrefixPointer(t *testing.T) {\n\ttype ComplexConfig struct {\n\t\tFoo struct {\n\t\t\tStr string `env:\"STR\"`\n\t\t} `envPrefix:\"FOO_\"`\n\t}\n\tcfg := ComplexConfig{}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{\"FOO_STR\": \"foo_str\"}}))\n\tisEqual(t, \"foo_str\", cfg.Foo.Str)\n\n\ttype ComplexConfig2 struct {\n\t\tFoo struct {\n\t\t\tBar struct {\n\t\t\t\tStr string `env:\"STR\"`\n\t\t\t} `envPrefix:\"BAR_\"`\n\t\t\tBar2 string `env:\"BAR2\"`\n\t\t} `envPrefix:\"FOO_\"`\n\t}\n\tcfg2 := ComplexConfig2{}\n\tisNoErr(t, ParseWithOptions(&cfg2, Options{Environment: map[string]string{\"FOO_BAR_STR\": \"kek\", \"FOO_BAR2\": \"lel\"}}))\n\tisEqual(t, \"lel\", cfg2.Foo.Bar2)\n\tisEqual(t, \"kek\", cfg2.Foo.Bar.Str)\n}\n\nfunc TestComplePrefix(t *testing.T) {\n\ttype Config struct {\n\t\tHome string `env:\"HOME\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo   Config `envPrefix:\"FOO_\"`\n\t\tClean Config\n\t\tBar   Config `envPrefix:\"BAR_\"`\n\t\tBlah  string `env:\"BLAH\"`\n\t}\n\tcfg := ComplexConfig{}\n\tisNoErr(t, ParseWithOptions(&cfg, Options{\n\t\tPrefix: \"T_\",\n\t\tEnvironment: map[string]string{\n\t\t\t\"T_FOO_HOME\": \"/foo\",\n\t\t\t\"T_BAR_HOME\": \"/bar\",\n\t\t\t\"T_BLAH\":     \"blahhh\",\n\t\t\t\"T_HOME\":     \"/clean\",\n\t\t},\n\t}))\n\tisEqual(t, \"/foo\", cfg.Foo.Home)\n\tisEqual(t, \"/bar\", cfg.Bar.Home)\n\tisEqual(t, \"/clean\", cfg.Clean.Home)\n\tisEqual(t, \"blahhh\", cfg.Blah)\n}\n\nfunc TestNoEnvKey(t *testing.T) {\n\ttype Config struct {\n\t\tFoo      string\n\t\tFooBar   string\n\t\tHTTPPort int\n\t\tbar      string\n\t}\n\tvar cfg Config\n\tisNoErr(t, ParseWithOptions(&cfg, Options{\n\t\tUseFieldNameByDefault: true,\n\t\tEnvironment: map[string]string{\n\t\t\t\"FOO\":       \"fooval\",\n\t\t\t\"FOO_BAR\":   \"foobarval\",\n\t\t\t\"HTTP_PORT\": \"10\",\n\t\t},\n\t}))\n\tisEqual(t, \"fooval\", cfg.Foo)\n\tisEqual(t, \"foobarval\", cfg.FooBar)\n\tisEqual(t, 10, cfg.HTTPPort)\n\tisEqual(t, \"\", cfg.bar)\n}\n\nfunc TestToEnv(t *testing.T) {\n\tfor in, out := range map[string]string{\n\t\t\"Foo\":          \"FOO\",\n\t\t\"FooBar\":       \"FOO_BAR\",\n\t\t\"FOOBar\":       \"FOO_BAR\",\n\t\t\"Foo____Bar\":   \"FOO_BAR\",\n\t\t\"fooBar\":       \"FOO_BAR\",\n\t\t\"Foo_Bar\":      \"FOO_BAR\",\n\t\t\"Foo__Bar\":     \"FOO_BAR\",\n\t\t\"HTTPPort\":     \"HTTP_PORT\",\n\t\t\"SSHPort\":      \"SSH_PORT\",\n\t\t\"_SSH___Port_\": \"SSH_PORT\",\n\t\t\"_PortHTTP\":    \"PORT_HTTP\",\n\t} {\n\t\tt.Run(in, func(t *testing.T) {\n\t\t\tisEqual(t, out, toEnvName(in))\n\t\t})\n\t}\n}\n\nfunc TestErrorIs(t *testing.T) {\n\terr := newAggregateError(newParseError(reflect.StructField{}, nil))\n\tt.Run(\"is\", func(t *testing.T) {\n\t\tisTrue(t, errors.Is(err, ParseError{}))\n\t})\n\tt.Run(\"is not\", func(t *testing.T) {\n\t\tisFalse(t, errors.Is(err, NoParserError{}))\n\t})\n}\n\ntype FieldParamsConfig struct {\n\tSimple         []string `env:\"SIMPLE\"`\n\tWithoutEnv     string\n\tprivateWithEnv string `env:\"PRIVATE_WITH_ENV\"` //nolint:unused\n\tWithDefault    string `env:\"WITH_DEFAULT\" envDefault:\"default\"`\n\tRequired       string `env:\"REQUIRED,required\"`\n\tFile           string `env:\"FILE,file\"`\n\tUnset          string `env:\"UNSET,unset\"`\n\tNotEmpty       string `env:\"NOT_EMPTY,notEmpty\"`\n\tExpand         string `env:\"EXPAND,expand\"`\n\tNestedConfig   struct {\n\t\tSimple []string `env:\"SIMPLE\"`\n\t} `envPrefix:\"NESTED_\"`\n}\n\nfunc TestGetFieldParams(t *testing.T) {\n\tvar config FieldParamsConfig\n\tparams, err := GetFieldParams(&config)\n\tisNoErr(t, err)\n\n\texpectedParams := []FieldParams{\n\t\t{OwnKey: \"SIMPLE\", Key: \"SIMPLE\"},\n\t\t{OwnKey: \"WITH_DEFAULT\", Key: \"WITH_DEFAULT\", DefaultValue: \"default\", HasDefaultValue: true},\n\t\t{OwnKey: \"REQUIRED\", Key: \"REQUIRED\", Required: true},\n\t\t{OwnKey: \"FILE\", Key: \"FILE\", LoadFile: true},\n\t\t{OwnKey: \"UNSET\", Key: \"UNSET\", Unset: true},\n\t\t{OwnKey: \"NOT_EMPTY\", Key: \"NOT_EMPTY\", NotEmpty: true},\n\t\t{OwnKey: \"EXPAND\", Key: \"EXPAND\", Expand: true},\n\t\t{OwnKey: \"SIMPLE\", Key: \"NESTED_SIMPLE\"},\n\t}\n\tisTrue(t, len(params) == len(expectedParams))\n\tisTrue(t, areEqual(params, expectedParams))\n}\n\nfunc TestGetFieldParamsWithPrefix(t *testing.T) {\n\tvar config FieldParamsConfig\n\n\tparams, err := GetFieldParamsWithOptions(&config, Options{Prefix: \"FOO_\"})\n\tisNoErr(t, err)\n\n\texpectedParams := []FieldParams{\n\t\t{OwnKey: \"SIMPLE\", Key: \"FOO_SIMPLE\"},\n\t\t{OwnKey: \"WITH_DEFAULT\", Key: \"FOO_WITH_DEFAULT\", DefaultValue: \"default\", HasDefaultValue: true},\n\t\t{OwnKey: \"REQUIRED\", Key: \"FOO_REQUIRED\", Required: true},\n\t\t{OwnKey: \"FILE\", Key: \"FOO_FILE\", LoadFile: true},\n\t\t{OwnKey: \"UNSET\", Key: \"FOO_UNSET\", Unset: true},\n\t\t{OwnKey: \"NOT_EMPTY\", Key: \"FOO_NOT_EMPTY\", NotEmpty: true},\n\t\t{OwnKey: \"EXPAND\", Key: \"FOO_EXPAND\", Expand: true},\n\t\t{OwnKey: \"SIMPLE\", Key: \"FOO_NESTED_SIMPLE\"},\n\t}\n\tisTrue(t, len(params) == len(expectedParams))\n\tisTrue(t, areEqual(params, expectedParams))\n}\n\nfunc TestGetFieldParamsError(t *testing.T) {\n\tvar config FieldParamsConfig\n\n\t_, err := GetFieldParams(config)\n\tisErrorWithMessage(t, err, \"env: expected a pointer to a Struct\")\n\tisTrue(t, errors.Is(err, NotStructPtrError{}))\n}\n\ntype Conf struct {\n\tFoo string `env:\"FOO\" envDefault:\"bar\"`\n}\n\nfunc TestParseAs(t *testing.T) {\n\tconfig, err := ParseAs[Conf]()\n\tisNoErr(t, err)\n\tisEqual(t, \"bar\", config.Foo)\n}\n\nfunc TestParseAsWithOptions(t *testing.T) {\n\tconfig, err := ParseAsWithOptions[Conf](Options{\n\t\tEnvironment: map[string]string{\n\t\t\t\"FOO\": \"not bar\",\n\t\t},\n\t})\n\tisNoErr(t, err)\n\tisEqual(t, \"not bar\", config.Foo)\n}\n\ntype ConfRequired struct {\n\tFoo string `env:\"FOO,required\"`\n}\n\nfunc TestMust(t *testing.T) {\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tisErrorWithMessage(t, err.(error), `env: required environment variable \"FOO\" is not set`)\n\t\t}()\n\t\tconf := Must(ParseAs[ConfRequired]())\n\t\tisEqual(t, \"\", conf.Foo)\n\t})\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tt.Setenv(\"FOO\", \"bar\")\n\t\tconf := Must(ParseAs[ConfRequired]())\n\t\tisEqual(t, \"bar\", conf.Foo)\n\t})\n}\n\nfunc isTrue(tb testing.TB, b bool) {\n\ttb.Helper()\n\n\tif !b {\n\t\ttb.Fatalf(\"expected true, got false\")\n\t}\n}\n\nfunc isFalse(tb testing.TB, b bool) {\n\ttb.Helper()\n\n\tif b {\n\t\ttb.Fatalf(\"expected false, got true\")\n\t}\n}\n\nfunc isErrorWithMessage(tb testing.TB, err error, msg string) {\n\ttb.Helper()\n\n\tif err == nil {\n\t\ttb.Fatalf(\"expected error, got nil\")\n\t}\n\n\tif msg != err.Error() {\n\t\ttb.Fatalf(\"expected error message %q, got %q\", msg, err.Error())\n\t}\n}\n\nfunc isNoErr(tb testing.TB, err error) {\n\ttb.Helper()\n\n\tif err != nil {\n\t\ttb.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc isEqual(tb testing.TB, a, b interface{}) {\n\ttb.Helper()\n\n\tif areEqual(a, b) {\n\t\treturn\n\t}\n\n\ttb.Fatalf(\"expected %#v (type %T) == %#v (type %T)\", a, a, b, b)\n}\n\n// copied from https://github.com/matryer/is\nfunc areEqual(a, b interface{}) bool {\n\tif isNil(a) && isNil(b) {\n\t\treturn true\n\t}\n\tif isNil(a) || isNil(b) {\n\t\treturn false\n\t}\n\tif reflect.DeepEqual(a, b) {\n\t\treturn true\n\t}\n\taValue := reflect.ValueOf(a)\n\tbValue := reflect.ValueOf(b)\n\treturn aValue == bValue\n}\n\n// copied from https://github.com/matryer/is\nfunc isNil(object interface{}) bool {\n\tif object == nil {\n\t\treturn true\n\t}\n\tvalue := reflect.ValueOf(object)\n\tkind := value.Kind()\n\tif kind >= reflect.Chan && kind <= reflect.Slice && value.IsNil() {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc TestParseWithOptionsOverride(t *testing.T) {\n\ttype config struct {\n\t\tInterval time.Duration `env:\"INTERVAL\"`\n\t}\n\n\tt.Setenv(\"INTERVAL\", \"1\")\n\n\tvar cfg config\n\n\tisNoErr(t, ParseWithOptions(&cfg, Options{FuncMap: map[reflect.Type]ParserFunc{\n\t\treflect.TypeOf(time.Nanosecond): func(value string) (interface{}, error) {\n\t\t\tintervalI, err := strconv.Atoi(value)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn time.Duration(intervalI), nil\n\t\t},\n\t}}))\n}\n\ntype Password []byte\n\nfunc (p *Password) UnmarshalText(text []byte) error {\n\tout, err := base64.StdEncoding.DecodeString(string(text))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*p = out\n\treturn nil\n}\n\ntype UsernameAndPassword struct {\n\tUsername string    `env:\"USER\"`\n\tPassword *Password `env:\"PWD\"`\n}\n\nfunc TestBase64Password(t *testing.T) {\n\tt.Setenv(\"USER\", \"admin\")\n\tt.Setenv(\"PWD\", base64.StdEncoding.EncodeToString([]byte(\"admin123\")))\n\tvar c UsernameAndPassword\n\tisNoErr(t, Parse(&c))\n\tisEqual(t, \"admin\", c.Username)\n\tisEqual(t, \"admin123\", string(*c.Password))\n}\n\nfunc TestIssue304(t *testing.T) {\n\tt.Setenv(\"BACKEND_URL\", \"https://google.com\")\n\ttype Config struct {\n\t\tBackendURL string `envDefault:\"localhost:8000\"`\n\t}\n\tcfg, err := ParseAsWithOptions[Config](Options{\n\t\tUseFieldNameByDefault: true,\n\t})\n\tisNoErr(t, err)\n\tisEqual(t, \"https://google.com\", cfg.BackendURL)\n}\n\nfunc TestIssue234(t *testing.T) {\n\ttype Test struct {\n\t\tStr string `env:\"TEST\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo   *Test `envPrefix:\"FOO_\" env:\",init\"`\n\t\tBar   Test  `envPrefix:\"BAR_\"`\n\t\tClean *Test\n\t}\n\n\tt.Setenv(\"FOO_TEST\", \"kek\")\n\tt.Setenv(\"BAR_TEST\", \"lel\")\n\n\tcfg := ComplexConfig{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"kek\", cfg.Foo.Str)\n\tisEqual(t, \"lel\", cfg.Bar.Str)\n}\n\ntype Issue308 struct {\n\tInner Issue308Map `env:\"A_MAP\"`\n}\n\ntype Issue308Map map[string][]string\n\nfunc (rc *Issue308Map) UnmarshalText(b []byte) error {\n\tm := map[string][]string{}\n\tif err := json.Unmarshal(b, &m); err != nil {\n\t\treturn err\n\t}\n\t*rc = Issue308Map(m)\n\treturn nil\n}\n\nfunc TestIssue308(t *testing.T) {\n\tt.Setenv(\"A_MAP\", `{\"FOO\":[\"BAR\", \"ZAZ\"]}`)\n\n\tcfg := Issue308{}\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, Issue308Map{\"FOO\": []string{\"BAR\", \"ZAZ\"}}, cfg.Inner)\n}\n\nfunc TestIssue317(t *testing.T) {\n\ttype TestConfig struct {\n\t\tU1 *url.URL `env:\"U1\"`\n\t\tU2 *url.URL `env:\"U2,init\"`\n\t}\n\tcases := []struct {\n\t\tdesc                   string\n\t\tenvironment            map[string]string\n\t\texpectedU1, expectedU2 *url.URL\n\t}{\n\t\t{\n\t\t\tdesc:        \"unset\",\n\t\t\tenvironment: map[string]string{},\n\t\t\texpectedU1:  nil,\n\t\t\texpectedU2:  &url.URL{},\n\t\t},\n\t\t{\n\t\t\tdesc:        \"empty\",\n\t\t\tenvironment: map[string]string{\"U1\": \"\", \"U2\": \"\"},\n\t\t\texpectedU1:  nil,\n\t\t\texpectedU2:  &url.URL{},\n\t\t},\n\t\t{\n\t\t\tdesc:        \"set\",\n\t\t\tenvironment: map[string]string{\"U1\": \"https://example.com/\"},\n\t\t\texpectedU1:  &url.URL{Scheme: \"https\", Host: \"example.com\", Path: \"/\"},\n\t\t\texpectedU2:  &url.URL{},\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tcfg := TestConfig{}\n\t\t\terr := ParseWithOptions(&cfg, Options{Environment: tc.environment})\n\t\t\tisNoErr(t, err)\n\t\t\tisEqual(t, tc.expectedU1, cfg.U1)\n\t\t\tisEqual(t, tc.expectedU2, cfg.U2)\n\t\t})\n\t}\n}\n\nfunc TestIssue310(t *testing.T) {\n\ttype TestConfig struct {\n\t\tURL *url.URL\n\t}\n\tcfg, err := ParseAs[TestConfig]()\n\tisNoErr(t, err)\n\tisEqual(t, nil, cfg.URL)\n}\n\nfunc TestMultipleTagOptions(t *testing.T) {\n\ttype TestConfig struct {\n\t\tURL *url.URL `env:\"URL,init,unset\"`\n\t}\n\tt.Run(\"unset\", func(t *testing.T) {\n\t\tcfg, err := ParseAs[TestConfig]()\n\t\tisNoErr(t, err)\n\t\tisEqual(t, &url.URL{}, cfg.URL)\n\t})\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\tt.Setenv(\"URL\", \"\")\n\t\tcfg, err := ParseAs[TestConfig]()\n\t\tisNoErr(t, err)\n\t\tisEqual(t, &url.URL{}, cfg.URL)\n\t})\n\tt.Run(\"set\", func(t *testing.T) {\n\t\tt.Setenv(\"URL\", \"https://github.com/caarlos0\")\n\t\tcfg, err := ParseAs[TestConfig]()\n\t\tisNoErr(t, err)\n\t\tisEqual(t, &url.URL{Scheme: \"https\", Host: \"github.com\", Path: \"/caarlos0\"}, cfg.URL)\n\t\tisEqual(t, \"\", os.Getenv(\"URL\"))\n\t})\n}\n\nfunc TestIssue298(t *testing.T) {\n\ttype Test struct {\n\t\tStr string `env:\"STR\"`\n\t\tNum int    `env:\"NUM\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo *[]Test `envPrefix:\"FOO_\"`\n\t\tBar []Test  `envPrefix:\"BAR\"`\n\t\tBaz []Test  `env:\",init\"`\n\t}\n\n\tt.Setenv(\"FOO_0_STR\", \"f0t\")\n\tt.Setenv(\"FOO_0_NUM\", \"101\")\n\tt.Setenv(\"FOO_1_STR\", \"f1t\")\n\tt.Setenv(\"FOO_1_NUM\", \"111\")\n\n\tt.Setenv(\"BAR_0_STR\", \"b0t\")\n\t// t.Setenv(\"BAR_0_NUM\", \"202\") // Not overridden\n\tt.Setenv(\"BAR_1_STR\", \"b1t\")\n\tt.Setenv(\"BAR_1_NUM\", \"212\")\n\n\tt.Setenv(\"0_STR\", \"bt\")\n\tt.Setenv(\"1_NUM\", \"10\")\n\n\tsample := make([]Test, 1)\n\tsample[0].Str = \"overridden text\"\n\tsample[0].Num = 99999999\n\tcfg := ComplexConfig{Bar: sample}\n\n\tisNoErr(t, Parse(&cfg))\n\n\tisEqual(t, \"f0t\", (*cfg.Foo)[0].Str)\n\tisEqual(t, 101, (*cfg.Foo)[0].Num)\n\tisEqual(t, \"f1t\", (*cfg.Foo)[1].Str)\n\tisEqual(t, 111, (*cfg.Foo)[1].Num)\n\n\tisEqual(t, \"b0t\", cfg.Bar[0].Str)\n\tisEqual(t, 99999999, cfg.Bar[0].Num)\n\tisEqual(t, \"b1t\", cfg.Bar[1].Str)\n\tisEqual(t, 212, cfg.Bar[1].Num)\n\n\tisEqual(t, \"bt\", cfg.Baz[0].Str)\n\tisEqual(t, 0, cfg.Baz[0].Num)\n\tisEqual(t, \"\", cfg.Baz[1].Str)\n\tisEqual(t, 10, cfg.Baz[1].Num)\n}\n\nfunc TestIssue298ErrorNestedFieldRequiredNotSet(t *testing.T) {\n\ttype Test struct {\n\t\tStr string `env:\"STR,required\"`\n\t\tNum int    `env:\"NUM\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo *[]Test `envPrefix:\"FOO\"`\n\t}\n\n\tt.Setenv(\"FOO_0_NUM\", \"101\")\n\n\tcfg := ComplexConfig{}\n\terr := Parse(&cfg)\n\tisErrorWithMessage(t, err, `env: required environment variable \"FOO_0_STR\" is not set`)\n\tisTrue(t, errors.Is(err, VarIsNotSetError{}))\n}\n\nfunc TestIssue320(t *testing.T) {\n\ttype Test struct {\n\t\tStr string `env:\"STR\"`\n\t\tNum int    `env:\"NUM\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo *[]Test `envPrefix:\"FOO_\"`\n\t\tBar []Test  `envPrefix:\"BAR\"`\n\t\tBaz []Test  `env:\",init\"`\n\t}\n\n\tcfg := ComplexConfig{}\n\n\tisNoErr(t, Parse(&cfg))\n\n\tisEqual(t, cfg.Foo, nil)\n\tisEqual(t, cfg.Bar, nil)\n\tisEqual(t, cfg.Baz, nil)\n}\n\nfunc TestParseWithOptionsRenamedDefault(t *testing.T) {\n\ttype config struct {\n\t\tStr string `env:\"STR\" envDefault:\"foo\" myDefault:\"bar\"`\n\t}\n\n\tcfg := &config{}\n\tisNoErr(t, ParseWithOptions(cfg, Options{DefaultValueTagName: \"myDefault\"}))\n\tisEqual(t, \"bar\", cfg.Str)\n\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"foo\", cfg.Str)\n}\n\nfunc TestParseWithOptionsRenamedPrefix(t *testing.T) {\n\ttype Config struct {\n\t\tStr string `env:\"STR\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tFoo Config `envPrefix:\"FOO_\" myPrefix:\"BAR_\"`\n\t}\n\n\tt.Setenv(\"FOO_STR\", \"101\")\n\tt.Setenv(\"BAR_STR\", \"202\")\n\tt.Setenv(\"APP_BAR_STR\", \"303\")\n\n\tcfg := &ComplexConfig{}\n\tisNoErr(t, ParseWithOptions(cfg, Options{PrefixTagName: \"myPrefix\"}))\n\tisEqual(t, \"202\", cfg.Foo.Str)\n\n\tisNoErr(t, ParseWithOptions(cfg, Options{PrefixTagName: \"myPrefix\", Prefix: \"APP_\"}))\n\tisEqual(t, \"303\", cfg.Foo.Str)\n\n\tisNoErr(t, Parse(cfg))\n\tisEqual(t, \"101\", cfg.Foo.Str)\n}\n\nfunc TestFieldIgnored(t *testing.T) {\n\ttype Test struct {\n\t\tFoo string `env:\"FOO\"`\n\t\tBar string `env:\"BAR,-\"`\n\t}\n\ttype ComplexConfig struct {\n\t\tStr string `env:\"STR\"`\n\t\tFoo Test   `env:\"FOO\" envPrefix:\"FOO_\"`\n\t\tBar Test   `env:\"-\" envPrefix:\"BAR_\"`\n\t}\n\tt.Setenv(\"STR\", \"101\")\n\tt.Setenv(\"FOO_FOO\", \"202\")\n\tt.Setenv(\"FOO_BAR\", \"303\")\n\tt.Setenv(\"BAR_FOO\", \"404\")\n\tt.Setenv(\"BAR_BAR\", \"505\")\n\n\tvar cfg ComplexConfig\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, \"101\", cfg.Str)\n\tisEqual(t, \"202\", cfg.Foo.Foo)\n\tisEqual(t, \"\", cfg.Foo.Bar)\n\tisEqual(t, \"\", cfg.Bar.Foo)\n\tisEqual(t, \"\", cfg.Bar.Bar)\n}\n\nfunc TestNoEnvKeyIgnored(t *testing.T) {\n\ttype Config struct {\n\t\tFoo    string `env:\"-\"`\n\t\tFooBar string\n\t}\n\n\tt.Setenv(\"FOO\", \"101\")\n\tt.Setenv(\"FOO_BAR\", \"202\")\n\n\tvar cfg Config\n\tisNoErr(t, ParseWithOptions(&cfg, Options{UseFieldNameByDefault: true}))\n\tisEqual(t, \"\", cfg.Foo)\n\tisEqual(t, \"202\", cfg.FooBar)\n}\n\nfunc TestIssue339(t *testing.T) {\n\tt.Run(\"Should parse with bool ptr set and env undefined\", func(t *testing.T) {\n\t\texistingValue := true\n\t\tcfg := Config{\n\t\t\tBoolPtr: &existingValue,\n\t\t}\n\n\t\tisNoErr(t, Parse(&cfg))\n\n\t\tisEqual(t, &existingValue, cfg.BoolPtr)\n\t})\n\n\tt.Run(\"Should parse with bool ptr set and env defined\", func(t *testing.T) {\n\t\texistingValue := true\n\t\tcfg := Config{\n\t\t\tBoolPtr: &existingValue,\n\t\t}\n\n\t\tnewValue := false\n\t\tt.Setenv(\"BOOL\", strconv.FormatBool(newValue))\n\n\t\tisNoErr(t, Parse(&cfg))\n\n\t\tisEqual(t, &newValue, cfg.BoolPtr)\n\t})\n\n\tt.Run(\"Should parse with string ptr set and env undefined\", func(t *testing.T) {\n\t\texistingValue := \"one\"\n\t\tcfg := Config{\n\t\t\tStringPtr: &existingValue,\n\t\t}\n\n\t\tisNoErr(t, Parse(&cfg))\n\n\t\tisEqual(t, &existingValue, cfg.StringPtr)\n\t})\n\n\tt.Run(\"Should parse with string ptr set and env defined\", func(t *testing.T) {\n\t\texistingValue := \"one\"\n\t\tcfg := Config{\n\t\t\tStringPtr: &existingValue,\n\t\t}\n\n\t\tnewValue := \"two\"\n\t\tt.Setenv(\"STRING\", newValue)\n\n\t\tisNoErr(t, Parse(&cfg))\n\n\t\tisEqual(t, &newValue, cfg.StringPtr)\n\t})\n}\n\nfunc TestIssue350(t *testing.T) {\n\tt.Setenv(\"MAP\", \"url:https://foo.bar:2030\")\n\n\ttype Config struct {\n\t\tMap map[string]string `env:\"MAP\"`\n\t}\n\n\tvar cfg Config\n\tisNoErr(t, Parse(&cfg))\n\tisEqual(t, map[string]string{\"url\": \"https://foo.bar:2030\"}, cfg.Map)\n}\n\nfunc TestEnvBleed(t *testing.T) {\n\ttype Config struct {\n\t\tFoo string `env:\"FOO\"`\n\t}\n\n\tt.Setenv(\"FOO\", \"101\")\n\n\tt.Run(\"Default env with value\", func(t *testing.T) {\n\t\tvar cfg Config\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{}))\n\t\tisEqual(t, \"101\", cfg.Foo)\n\t})\n\n\tt.Run(\"Empty env without value\", func(t *testing.T) {\n\t\tvar cfg Config\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{}}))\n\t\tisEqual(t, \"\", cfg.Foo)\n\t})\n\n\tt.Run(\"Custom env with overwritten value\", func(t *testing.T) {\n\t\tvar cfg Config\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{\"FOO\": \"202\"}}))\n\t\tisEqual(t, \"202\", cfg.Foo)\n\t})\n\n\tt.Run(\"Custom env without value\", func(t *testing.T) {\n\t\tvar cfg Config\n\t\tisNoErr(t, ParseWithOptions(&cfg, Options{Environment: map[string]string{\"BAR\": \"202\"}}))\n\t\tisEqual(t, \"\", cfg.Foo)\n\t})\n}\n"
        },
        {
          "name": "env_tomap.go",
          "type": "blob",
          "size": 0.2314453125,
          "content": "//go:build !windows\n\npackage env\n\nimport \"strings\"\n\nfunc toMap(env []string) map[string]string {\n\tr := map[string]string{}\n\tfor _, e := range env {\n\t\tp := strings.SplitN(e, \"=\", 2)\n\t\tif len(p) == 2 {\n\t\t\tr[p[0]] = p[1]\n\t\t}\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "env_tomap_test.go",
          "type": "blob",
          "size": 0.34375,
          "content": "//go:build !windows\n\npackage env\n\nimport \"testing\"\n\nfunc TestUnix(t *testing.T) {\n\tenvVars := []string{\":=/test/unix\", \"PATH=:/test_val1:/test_val2\", \"VAR=REGULARVAR\", \"FOO=\", \"BAR\"}\n\tresult := ToMap(envVars)\n\tisEqual(t, map[string]string{\n\t\t\":\":    \"/test/unix\",\n\t\t\"PATH\": \":/test_val1:/test_val2\",\n\t\t\"VAR\":  \"REGULARVAR\",\n\t\t\"FOO\":  \"\",\n\t}, result)\n}\n"
        },
        {
          "name": "env_tomap_windows.go",
          "type": "blob",
          "size": 0.611328125,
          "content": "//go:build windows\n\npackage env\n\nimport \"strings\"\n\nfunc toMap(env []string) map[string]string {\n\tr := map[string]string{}\n\tfor _, e := range env {\n\t\tp := strings.SplitN(e, \"=\", 2)\n\n\t\t// On Windows, environment variables can start with '='. If so, Split at next character.\n\t\t// See env_windows.go in the Go source: https://github.com/golang/go/blob/master/src/syscall/env_windows.go#L58\n\t\tprefixEqualSign := false\n\t\tif len(e) > 0 && e[0] == '=' {\n\t\t\te = e[1:]\n\t\t\tprefixEqualSign = true\n\t\t}\n\t\tp = strings.SplitN(e, \"=\", 2)\n\t\tif prefixEqualSign {\n\t\t\tp[0] = \"=\" + p[0]\n\t\t}\n\n\t\tif len(p) == 2 {\n\t\t\tr[p[0]] = p[1]\n\t\t}\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "env_tomap_windows_test.go",
          "type": "blob",
          "size": 0.5498046875,
          "content": "//go:build windows\n\npackage env\n\nimport \"testing\"\n\n// On Windows, environment variables can start with '='.\n// This test verifies this behavior without relying on a Windows environment.\n// See env_windows.go in the Go source: https://github.com/golang/go/blob/master/src/syscall/env_windows.go#L58\nfunc TestToMapWindows(t *testing.T) {\n\tenvVars := []string{\"=::=::\\\\\", \"=C:=C:\\\\test\", \"VAR=REGULARVAR\", \"FOO=\", \"BAR\"}\n\tresult := ToMap(envVars)\n\tisEqual(t, map[string]string{\n\t\t\"=::\": \"::\\\\\",\n\t\t\"=C:\": \"C:\\\\test\",\n\t\t\"VAR\": \"REGULARVAR\",\n\t\t\"FOO\": \"\",\n\t}, result)\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 4.0693359375,
          "content": "package env\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// An aggregated error wrapper to combine gathered errors.\n// This allows either to display all errors or convert them individually\n// List of the available errors\n// ParseError\n// NotStructPtrError\n// NoParserError\n// NoSupportedTagOptionError\n// VarIsNotSetError\n// EmptyVarError\n// LoadFileContentError\n// ParseValueError\ntype AggregateError struct {\n\tErrors []error\n}\n\nfunc newAggregateError(initErr error) error {\n\treturn AggregateError{\n\t\t[]error{\n\t\t\tinitErr,\n\t\t},\n\t}\n}\n\nfunc (e AggregateError) Error() string {\n\tvar sb strings.Builder\n\n\tsb.WriteString(\"env:\")\n\n\tfor _, err := range e.Errors {\n\t\tsb.WriteString(fmt.Sprintf(\" %v;\", err.Error()))\n\t}\n\n\treturn strings.TrimRight(sb.String(), \";\")\n}\n\n// Unwrap implements std errors.Join go1.20 compatibility\nfunc (e AggregateError) Unwrap() []error {\n\treturn e.Errors\n}\n\n// Is conforms with errors.Is.\nfunc (e AggregateError) Is(err error) bool {\n\tfor _, ie := range e.Errors {\n\t\tif reflect.TypeOf(ie) == reflect.TypeOf(err) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// The error occurs when it's impossible to convert the value for given type.\ntype ParseError struct {\n\tName string\n\tType reflect.Type\n\tErr  error\n}\n\nfunc newParseError(sf reflect.StructField, err error) error {\n\treturn ParseError{sf.Name, sf.Type, err}\n}\n\nfunc (e ParseError) Error() string {\n\treturn fmt.Sprintf(\"parse error on field %q of type %q: %v\", e.Name, e.Type, e.Err)\n}\n\n// The error occurs when pass something that is not a pointer to a struct to Parse\ntype NotStructPtrError struct{}\n\nfunc (e NotStructPtrError) Error() string {\n\treturn \"expected a pointer to a Struct\"\n}\n\n// This error occurs when there is no parser provided for given type.\ntype NoParserError struct {\n\tName string\n\tType reflect.Type\n}\n\nfunc newNoParserError(sf reflect.StructField) error {\n\treturn NoParserError{sf.Name, sf.Type}\n}\n\nfunc (e NoParserError) Error() string {\n\treturn fmt.Sprintf(\"no parser found for field %q of type %q\", e.Name, e.Type)\n}\n\n// This error occurs when the given tag is not supported.\n// Built-in supported tags: \"\", \"file\", \"required\", \"unset\", \"notEmpty\",\n// \"expand\", \"envDefault\", and \"envSeparator\".\ntype NoSupportedTagOptionError struct {\n\tTag string\n}\n\nfunc newNoSupportedTagOptionError(tag string) error {\n\treturn NoSupportedTagOptionError{tag}\n}\n\nfunc (e NoSupportedTagOptionError) Error() string {\n\treturn fmt.Sprintf(\"tag option %q not supported\", e.Tag)\n}\n\n// This error occurs when the required variable is not set.\n//\n// Deprecated: use VarIsNotSetError.\ntype EnvVarIsNotSetError = VarIsNotSetError\n\n// This error occurs when the required variable is not set.\ntype VarIsNotSetError struct {\n\tKey string\n}\n\nfunc newVarIsNotSetError(key string) error {\n\treturn VarIsNotSetError{key}\n}\n\nfunc (e VarIsNotSetError) Error() string {\n\treturn fmt.Sprintf(`required environment variable %q is not set`, e.Key)\n}\n\n// This error occurs when the variable which must be not empty is existing but has an empty value\n//\n// Deprecated: use EmptyVarError.\ntype EmptyEnvVarError = EmptyVarError\n\n// This error occurs when the variable which must be not empty is existing but has an empty value\ntype EmptyVarError struct {\n\tKey string\n}\n\nfunc newEmptyVarError(key string) error {\n\treturn EmptyVarError{key}\n}\n\nfunc (e EmptyVarError) Error() string {\n\treturn fmt.Sprintf(\"environment variable %q should not be empty\", e.Key)\n}\n\n// This error occurs when it's impossible to load the value from the file.\ntype LoadFileContentError struct {\n\tFilename string\n\tKey      string\n\tErr      error\n}\n\nfunc newLoadFileContentError(filename, key string, err error) error {\n\treturn LoadFileContentError{filename, key, err}\n}\n\nfunc (e LoadFileContentError) Error() string {\n\treturn fmt.Sprintf(\"could not load content of file %q from variable %s: %v\", e.Filename, e.Key, e.Err)\n}\n\n// This error occurs when it's impossible to convert value using given parser.\ntype ParseValueError struct {\n\tMsg string\n\tErr error\n}\n\nfunc newParseValueError(message string, err error) error {\n\treturn ParseValueError{message, err}\n}\n\nfunc (e ParseValueError) Error() string {\n\treturn fmt.Sprintf(\"%s: %v\", e.Msg, e.Err)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 10.8955078125,
          "content": "package env\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n)\n\n// Basic package usage example.\nfunc Example() {\n\ttype Config struct {\n\t\tFoo string `env:\"FOO\"`\n\t}\n\n\tos.Setenv(\"FOO\", \"bar\")\n\n\t// parse:\n\tvar cfg1 Config\n\t_ = Parse(&cfg1)\n\n\t// parse with generics:\n\tcfg2, _ := ParseAs[Config]()\n\n\tfmt.Print(cfg1.Foo, cfg2.Foo)\n\t// Output: barbar\n}\n\n// Parse the environment into a struct.\nfunc ExampleParse() {\n\ttype Config struct {\n\t\tHome string `env:\"HOME\"`\n\t}\n\tos.Setenv(\"HOME\", \"/tmp/fakehome\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output:  {Home:/tmp/fakehome}\n}\n\n// Parse the environment into a struct using generics.\nfunc ExampleParseAs() {\n\ttype Config struct {\n\t\tHome string `env:\"HOME\"`\n\t}\n\tos.Setenv(\"HOME\", \"/tmp/fakehome\")\n\tcfg, err := ParseAs[Config]()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output:  {Home:/tmp/fakehome}\n}\n\nfunc ExampleParse_required() {\n\ttype Config struct {\n\t\tNope string `env:\"NOPE,required\"`\n\t}\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: env: required environment variable \"NOPE\" is not set\n\t// {Nope:}\n}\n\n// While `required` demands the environment variable to be set, it doesn't check\n// its value. If you want to make sure the environment is set and not empty, you\n// need to use the `notEmpty` tag option instead (`env:\"SOME_ENV,notEmpty\"`).\nfunc ExampleParse_notEmpty() {\n\ttype Config struct {\n\t\tNope string `env:\"NOPE,notEmpty\"`\n\t}\n\tos.Setenv(\"NOPE\", \"\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: env: environment variable \"NOPE\" should not be empty\n\t// {Nope:}\n}\n\n// The `env` tag option `unset` (e.g., `env:\"tagKey,unset\"`) can be added\n// to ensure that some environment variable is unset after reading it.\nfunc ExampleParse_unset() {\n\ttype Config struct {\n\t\tSecret string `env:\"SECRET,unset\"`\n\t}\n\tos.Setenv(\"SECRET\", \"1234\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v - %s\", cfg, os.Getenv(\"SECRET\"))\n\t// Output: {Secret:1234} -\n}\n\n// You can use `envSeparator` to define which character should be used to\n// separate array items in a string.\n// Similarly, you can use `envKeyValSeparator` to define which character should\n// be used to separate a key from a value in a map.\n// The defaults are `,` and `:`, respectively.\nfunc ExampleParse_separator() {\n\ttype Config struct {\n\t\tMap map[string]string `env:\"CUSTOM_MAP\" envSeparator:\"-\" envKeyValSeparator:\"|\"`\n\t}\n\tos.Setenv(\"CUSTOM_MAP\", \"k1|v1-k2|v2\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Map:map[k1:v1 k2:v2]}\n}\n\n// If you set the `expand` option, environment variables (either in `${var}` or\n// `$var` format) in the string will be replaced according with the actual\n// value of the variable. For example:\nfunc ExampleParse_expand() {\n\ttype Config struct {\n\t\tExpand1 string `env:\"EXPAND_1,expand\"`\n\t\tExpand2 string `env:\"EXPAND_2,expand\" envDefault:\"ABC_${EXPAND_1}\"`\n\t}\n\tos.Setenv(\"EXPANDING\", \"HI\")\n\tos.Setenv(\"EXPAND_1\", \"HELLO_${EXPANDING}\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Expand1:HELLO_HI Expand2:ABC_HELLO_HI}\n}\n\n// You can automatically initialize `nil` pointers regardless of if a variable\n// is set for them or not.\n// This behavior can be enabled by using the `init` tag option.\nfunc ExampleParse_init() {\n\ttype Inner struct {\n\t\tA string `env:\"OLA\" envDefault:\"HI\"`\n\t}\n\ttype Config struct {\n\t\tNilInner  *Inner\n\t\tInitInner *Inner `env:\",init\"`\n\t}\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Print(cfg.NilInner, cfg.InitInner)\n\t// Output: <nil> &{HI}\n}\n\n// You can define the default value for a field by either using the\n// `envDefault` tag, or when initializing the `struct`.\n//\n// Default values defined as `struct` tags will overwrite existing values\n// during `Parse`.\nfunc ExampleParse_setDefaults() {\n\ttype Config struct {\n\t\tFoo string `env:\"DEF_FOO\"`\n\t\tBar string `env:\"DEF_BAR\" envDefault:\"bar\"`\n\t}\n\tcfg := Config{\n\t\tFoo: \"foo\",\n\t}\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Foo:foo Bar:bar}\n}\n\n// You might want to listen to value sets and, for example, log something or do\n// some other kind of logic.\nfunc ExampleParseWithOptions_onSet() {\n\ttype config struct {\n\t\tHome         string `env:\"HOME,required\"`\n\t\tPort         int    `env:\"PORT\" envDefault:\"3000\"`\n\t\tIsProduction bool   `env:\"PRODUCTION\"`\n\t\tNoEnvTag     bool\n\t\tInner        struct{} `envPrefix:\"INNER_\"`\n\t}\n\tos.Setenv(\"HOME\", \"/tmp/fakehome\")\n\tvar cfg config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tOnSet: func(tag string, value interface{}, isDefault bool) {\n\t\t\tfmt.Printf(\"Set %s to %v (default? %v)\\n\", tag, value, isDefault)\n\t\t},\n\t}); err != nil {\n\t\tfmt.Println(\"failed:\", err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: Set HOME to /tmp/fakehome (default? false)\n\t// Set PORT to 3000 (default? true)\n\t// Set PRODUCTION to  (default? false)\n\t// {Home:/tmp/fakehome Port:3000 IsProduction:false NoEnvTag:false Inner:{}}\n}\n\n// By default, env supports anything that implements the `TextUnmarshaler`\n// interface, which includes `time.Time`.\n//\n// The upside is that depending on the format you need, you don't need to change\n// anything.\n//\n// The downside is that if you do need time in another format, you'll need to\n// create your own type and implement `TextUnmarshaler`.\nfunc ExampleParse_customTimeFormat() {\n\t// type MyTime time.Time\n\t//\n\t// func (t *MyTime) UnmarshalText(text []byte) error {\n\t// \ttt, err := time.Parse(\"2006-01-02\", string(text))\n\t// \t*t = MyTime(tt)\n\t// \treturn err\n\t// }\n\n\ttype Config struct {\n\t\tSomeTime MyTime `env:\"SOME_TIME\"`\n\t}\n\tos.Setenv(\"SOME_TIME\", \"2021-05-06\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Print(cfg.SomeTime)\n\t// Output: {0 63755856000 <nil>}\n}\n\n// Parse using extra options.\nfunc ExampleParseWithOptions_customTypes() {\n\ttype Thing struct {\n\t\tdesc string\n\t}\n\n\ttype Config struct {\n\t\tThing Thing `env:\"THING\"`\n\t}\n\n\tos.Setenv(\"THING\", \"my thing\")\n\n\tc := Config{}\n\terr := ParseWithOptions(&c, Options{\n\t\tFuncMap: map[reflect.Type]ParserFunc{\n\t\t\treflect.TypeOf(Thing{}): func(v string) (interface{}, error) {\n\t\t\t\treturn Thing{desc: v}, nil\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Print(c.Thing.desc)\n\t// Output: my thing\n}\n\n// Make all fields required by default.\nfunc ExampleParseWithOptions_allFieldsRequired() {\n\ttype Config struct {\n\t\tUsername string `env:\"EX_USERNAME\" envDefault:\"admin\"`\n\t\tPassword string `env:\"EX_PASSWORD\"`\n\t}\n\n\tvar cfg Config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tRequiredIfNoDef: true,\n\t}); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\\n\", cfg)\n\t// Output: env: required environment variable \"EX_PASSWORD\" is not set\n\t// {Username:admin Password:}\n}\n\n// Set a custom environment.\n// By default, `os.Environ()` is used.\nfunc ExampleParseWithOptions_setEnv() {\n\ttype Config struct {\n\t\tUsername string `env:\"EX_USERNAME\" envDefault:\"admin\"`\n\t\tPassword string `env:\"EX_PASSWORD\"`\n\t}\n\n\tvar cfg Config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tEnvironment: map[string]string{\n\t\t\t\"EX_USERNAME\": \"john\",\n\t\t\t\"EX_PASSWORD\": \"cena\",\n\t\t},\n\t}); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\\n\", cfg)\n\t// Output: {Username:john Password:cena}\n}\n\n// Handling slices of complex types.\nfunc ExampleParse_complexSlices() {\n\ttype Test struct {\n\t\tStr string `env:\"STR\"`\n\t\tNum int    `env:\"NUM\"`\n\t}\n\ttype Config struct {\n\t\tFoo []Test `envPrefix:\"FOO\"`\n\t}\n\n\tos.Setenv(\"FOO_0_STR\", \"a\")\n\tos.Setenv(\"FOO_0_NUM\", \"1\")\n\tos.Setenv(\"FOO_1_STR\", \"b\")\n\tos.Setenv(\"FOO_1_NUM\", \"2\")\n\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\\n\", cfg)\n\t// Output: {Foo:[{Str:a Num:1} {Str:b Num:2}]}\n}\n\n// Setting prefixes for inner types.\nfunc ExampleParse_prefix() {\n\ttype Inner struct {\n\t\tFoo string `env:\"FOO,required\"`\n\t}\n\ttype Config struct {\n\t\tA Inner `envPrefix:\"A_\"`\n\t\tB Inner `envPrefix:\"B_\"`\n\t}\n\tos.Setenv(\"A_FOO\", \"a\")\n\tos.Setenv(\"B_FOO\", \"b\")\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {A:{Foo:a} B:{Foo:b}}\n}\n\n// Setting prefixes for the entire config.\nfunc ExampleParseWithOptions_prefix() {\n\ttype Config struct {\n\t\tFoo string `env:\"FOO\"`\n\t}\n\tos.Setenv(\"MY_APP_FOO\", \"a\")\n\tvar cfg Config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tPrefix: \"MY_APP_\",\n\t}); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Foo:a}\n}\n\n// Use a different tag name than `env` and `envDefault`.\nfunc ExampleParseWithOptions_tagName() {\n\ttype Config struct {\n\t\tHome string `json:\"HOME\"`\n\t\tPage string `json:\"PAGE\" def:\"world\"`\n\t}\n\tos.Setenv(\"HOME\", \"hello\")\n\tvar cfg Config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tTagName:             \"json\",\n\t\tDefaultValueTagName: \"def\",\n\t}); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Home:hello Page:world}\n}\n\n// If you don't want to set the `env` tag on every field, you can use the\n// `UseFieldNameByDefault` option.\n//\n// It will use the field name to define the environment variable name.\n// So, `Foo` becomes `FOO`, `FooBar` becomes `FOO_BAR`, and so on.\nfunc ExampleParseWithOptions_useFieldName() {\n\ttype Config struct {\n\t\tFoo string\n\t}\n\tos.Setenv(\"FOO\", \"bar\")\n\tvar cfg Config\n\tif err := ParseWithOptions(&cfg, Options{\n\t\tUseFieldNameByDefault: true,\n\t}); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Foo:bar}\n}\n\n// The `env` tag option `file` (e.g., `env:\"tagKey,file\"`) can be added in\n// order to indicate that the value of the variable shall be loaded from a\n// file.\n//\n// The path of that file is given by the environment variable associated with\n// it.\nfunc ExampleParse_fromFile() {\n\tf, _ := os.CreateTemp(\"\", \"\")\n\t_, _ = f.WriteString(\"super secret\")\n\t_ = f.Close()\n\n\ttype Config struct {\n\t\tSecret string `env:\"SECRET,file\"`\n\t}\n\tos.Setenv(\"SECRET\", f.Name())\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: {Secret:super secret}\n}\n\n// TODO: envSeperator\n//\n\nfunc ExampleParse_errorHandling() {\n\ttype Config struct {\n\t\tUsername string `env:\"EX_ERR_USERNAME\" envDefault:\"admin\"`\n\t\tPassword string `env:\"EX_ERR_PASSWORD,notEmpty\"`\n\t}\n\n\tvar cfg Config\n\tif err := Parse(&cfg); err != nil {\n\t\tif errors.Is(err, EmptyVarError{}) {\n\t\t\tfmt.Println(\"oopsie\")\n\t\t}\n\t\taggErr := AggregateError{}\n\t\tif ok := errors.As(err, &aggErr); ok {\n\t\t\tfor _, er := range aggErr.Errors {\n\t\t\t\tswitch v := er.(type) {\n\t\t\t\t// Handle the error types you need:\n\t\t\t\t// ParseError\n\t\t\t\t// NotStructPtrError\n\t\t\t\t// NoParserError\n\t\t\t\t// NoSupportedTagOptionError\n\t\t\t\t// EnvVarIsNotSetError\n\t\t\t\t// EmptyEnvVarError\n\t\t\t\t// LoadFileContentError\n\t\t\t\t// ParseValueError\n\t\t\t\tcase EmptyVarError:\n\t\t\t\t\tfmt.Println(\"daisy\")\n\t\t\t\tdefault:\n\t\t\t\t\tfmt.Printf(\"Unknown error type %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Printf(\"%+v\", cfg)\n\t// Output: oopsie\n\t// daisy\n\t// {Username:admin Password:}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4697265625,
          "content": "module github.com/caarlos0/env/v11\n\n// v11.0.1 accidentally introduced a breaking change regarding the behavior of nil pointers.\n// You can now chose to auto-initialize them by setting the `init` tag option.\nretract v11.0.1\n\n// v11.2.0 accidentally introduced a breaking change regarding the behavior of nil slices of complex types.\nretract v11.2.0\n\n// v11.3.0 merges OS environment variables with environments set with Options instead of overriding them.\nretract v11.3.0\n\ngo 1.18\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        }
      ]
    }
  ]
}