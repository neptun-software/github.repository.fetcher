{
  "metadata": {
    "timestamp": 1736567687700,
    "page": 269,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "elazarl/goproxy",
      "stars": 6118,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": "bin\n*.swp\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 3.00390625,
          "content": "run:\n  timeout: 5m\n  modules-download-mode: readonly\n\n# List from https://golangci-lint.run/usage/linters/\nlinters:\n  enable:\n    # Default linters\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n    # Other linters\n    - asasalint\n    - asciicheck\n    - bidichk\n    - containedctx\n    - decorder\n    - dogsled\n    - durationcheck\n    - errchkjson\n    - errname\n    - errorlint\n    - exhaustive\n    - fatcontext\n    - forbidigo\n    - forcetypeassert\n    - gci\n    - gocheckcompilerdirectives\n    - gochecksumtype\n    - gocritic\n    - godot\n    - gofmt\n    - gofumpt\n    - goheader\n    - gomodguard\n    - goprintffuncname\n    - gosec\n    - gosmopolitan\n    - grouper\n    - iface\n    - importas\n    - interfacebloat\n    - lll\n    - loggercheck\n    - makezero\n    - mirror\n    - misspell\n    - nakedret\n    - nilerr\n    - noctx\n    - nolintlint\n    - perfsprint\n    - prealloc\n    - predeclared\n    - reassign\n    - revive\n    - stylecheck\n    - tagalign\n    - tenv\n    - testableexamples\n    - testifylint\n    - testpackage\n    - thelper\n    - tparallel\n    - unconvert\n    - usestdlibvars\n    - wastedassign\n    - whitespace\n    - exportloopref\n\n  disable:\n    - bodyclose\n    - canonicalheader\n    - contextcheck # Re-enable in V2\n    - copyloopvar\n    - cyclop\n    - depguard\n    - dupl\n    - dupword\n    - err113\n    - exhaustruct\n    - funlen\n    - ginkgolinter\n    - gochecknoglobals\n    - gochecknoinits\n    - gocognit\n    - goconst\n    - gocyclo\n    - godox\n    - goimports\n    - gomoddirectives\n    - inamedparam\n    - intrange\n    - ireturn\n    - maintidx\n    - mnd\n    - musttag\n    - nestif # TODO: Re-enable in V2\n    - nilnil\n    - nlreturn\n    - nonamedreturns\n    - nosprintfhostport\n    - paralleltest\n    - promlinter\n    - protogetter\n    - rowserrcheck\n    - sloglint\n    - spancheck\n    - sqlclosecheck\n    - tagliatelle\n    - unparam\n    - varnamelen\n    - wrapcheck\n    - wsl\n    - zerologlint\n\nlinters-settings:\n  gci:\n    sections:\n      - standard\n      - default\n    skip-generated: false\n    custom-order: true\n  gosec:\n    excludes:\n      - G402 # InsecureSkipVerify\n      - G102 # Binds to all network interfaces\n      - G403 # RSA keys should be at least 2048 bits\n      - G115 # Integer overflow conversion (uint64 -> int64)\n      - G404 # Use of weak random number generator (math/rand)\n      - G204 # Subprocess launched with a potential tainted input or cmd arguments\n\nissues:\n  exclude-rules:\n    - linters:\n        - gocritic\n      text: \"ifElseChain\"\n    - linters:\n        - lll\n      source: \"^// \"\n    - linters:\n        - revive\n      text: \"add-constant: \"\n    - linters:\n        - revive\n      text: \"unused-parameter: \"\n    - linters:\n        - revive\n      text: \"empty-block: \"\n    - linters:\n        - revive\n      text: \"var-naming: \" # TODO: Re-enable in V2\n    - linters:\n        - stylecheck\n      text: \" should be \" # TODO: Re-enable in V2\n    - linters:\n        - stylecheck\n      text: \"ST1003: should not use ALL_CAPS in Go names; use CamelCase instead\" # TODO: Re-enable in V2\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4521484375,
          "content": "Copyright (c) 2012 Elazar Leibovich. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Elazar Leibovich. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.4580078125,
          "content": "# GoProxy\n\n[![GoDoc](https://pkg.go.dev/badge/github.com/elazarl/goproxy)](https://pkg.go.dev/github.com/elazarl/goproxy)\n![Status](https://github.com/elazarl/goproxy/workflows/Go/badge.svg)\n\nGoProxy is a library to create a `customized` HTTP/HTTPS `proxy server` using\nGo (aka Golang), with several configurable settings available.\nThe target of this project is to offer an `optimized` proxy server, usable with\nreasonable amount of traffic, yet `customizable` and `programmable`.\n\nThe proxy itself is simply a `net/http` handler, so you can add multiple\nmiddlewares (panic recover, logging, compression, etc.) over it. It can be\neasily integrated with any other HTTP network library.\n\nIn order to use goproxy, one should set their browser (or any other client)\nto use goproxy as an HTTP proxy.\nHere is how you do that in [Chrome](https://www.wikihow.com/Connect-to-a-Proxy-Server)\nand in [Firefox](http://www.wikihow.com/Enter-Proxy-Settings-in-Firefox).\nIf you decide to start with the `base` example, the URL you should use as\nproxy is `localhost:8080`, which is the default one in our example.\n\n## Features\n- Perform certain actions only on `specific hosts`,  with a single equality comparison or with regex evaluation\n- Manipulate `requests` and `responses` before sending them to the browser\n- Use a `custom http.Transport` to perform requests to the target server\n- You can specify a `MITM certificates cache`, to reuse them later for other requests to the same host, thus saving CPU. Not enabled by default, but you should use it in production!\n- Redirect normal HTTP traffic to a `custom handler`, when the target is a `relative path` (e.g. `/ping`)\n- You can choose the logger to use, by implementing the `Logger` interface\n- You can `disable` the HTTP request headers `canonicalization`, by setting `PreventCanonicalization` to true\n\n## Proxy modes\n1. Regular HTTP proxy\n2. HTTPS through CONNECT\n3. HTTPS MITM (\"Man in the Middle\") proxy server, in which the server generate TLS certificates to parse request/response data and perform actions on them\n4. \"Hijacked\" proxy connection, where the configured handler can access the raw net.Conn data\n\n## Maintainers\n- [Elazar Leibovich](https://github.com/elazarl): Creator of the project, Software Engineer\n- [Erik Pellizzon](https://github.com/ErikPelli): Maintainer, Freelancer (open to collaborations!)\n\n## Contributions\nIf you have any trouble, suggestion, or if you find a bug, feel free to reach\nout by opening a GitHub `issue`.\nThis is an `open source` project managed by volunteers, and we're happy\nto discuss anything that can improve it.\n\nMake sure to explain everything, including the reason behind the issue\nand what you want to change, to make the problem easier to understand.\nYou can also directly open a `Pull Request`, if it's a small code change, but\nyou need to explain in the description everything.\nIf you open a pull request named `refactoring` with `5,000` lines changed,\nwe won't merge it... `:D`\n\nThe code for this project is released under the `BSD 3-Clause` license,\nmaking it useful for `commercial` uses as well.\n\n### Submit your case study\nSo, you have introduced & integrated GoProxy into one of your personal projects\nor a project inside the company you work for.\n\nWe're happy to learn about new `creative solutions` made with this library,\nso feel free to `contact` the maintainer listed above via e-mail, to explaining\nwhy you found this project useful for your needs.\n\nIf you have signed a `Non Disclosure Agreement` with the company, you\ncan propose them to write a `blog post` on their official website about\nthis topic, so this information will be public by their choice, and you can\n`share the link` of the blog post with us :)\n\nThe purpose of case studies is to share with the `community` why all the\n`contributors` to this project are `improving` the world with their help and\nwhat people are building using it.\n\n### Linter\nThe codebase uses an automatic lint check over your Pull Request code.\nBefore opening it, you should check if your changes respect it, by running\nthe linter in your local machine, so you won't have any surprise.\n\nTo install the linter:\n```sh\ngo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n```\n\nThis will create an executable in your `$GOPATH/bin` folder\n(`$GOPATH` is an environment variable, usually\nits value is equivalent to `~/go`, check its value in your machine if you\naren't sure about it).\nMake sure to include the bin folder in the path of your shell, to be able to\ndirectly use the `golangci-lint run` command.\n\n## A taste of GoProxy\n\nTo get a taste of `goproxy`, here you are a basic HTTP/HTTPS proxy\nthat just forward data to the destination:\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/elazarl/goproxy\"\n)\n\nfunc main() {\n    proxy := goproxy.NewProxyHttpServer()\n    proxy.Verbose = true\n    log.Fatal(http.ListenAndServe(\":8080\", proxy))\n}\n```\n\n### Request handler\nThis line will add `X-GoProxy: yxorPoG-X` header to all requests sent through the proxy,\nbefore sending them to the destination:\n\n```go\nproxy.OnRequest().DoFunc(\n    func(r *http.Request,ctx *goproxy.ProxyCtx)(*http.Request,*http.Response) {\n        r.Header.Set(\"X-GoProxy\",\"yxorPoG-X\")\n        return r,nil\n    })\n```\n\nWhen the `OnRequest()` input is empty, the function specified in `DoFunc`\nwill process all incoming requests to the proxy. In this case, it will add\na header to the request and return it to the caller.\nThe proxy will send the modified request to the destination.\nYou can also use `Do` instead of `DoFunc`, if you implement the specified\ninterface in your type.\n\n> ⚠️ Note we returned a nil value as the response.\n> If the returned response is not nil, goproxy will discard the request\n> and send the specified response to the client.\n\n### Conditional Request handler\nRefuse connections to www.reddit.com between 8 and 17 in the server\nlocal timezone:\n\n```go\nproxy.OnRequest(goproxy.DstHostIs(\"www.reddit.com\")).DoFunc(\n    func(req *http.Request,ctx *goproxy.ProxyCtx)(*http.Request,*http.Response) {\n        if h,_,_ := time.Now().Clock(); h >= 8 && h <= 17 {\n\t\t\tresp := goproxy.NewResponse(r, goproxy.ContentTypeText, http.StatusForbidden, \"Don't waste your time!\")\n            return req, resp\n        }\n        return req,nil\n})\n```\n\n`DstHostIs` returns a `ReqCondition`, which is a function receiving a `*http.Request`\nand returning a boolean that checks if the request satisfies the condition (and that will be processed).\n`DstHostIs(\"www.reddit.com\")` will return a `ReqCondition` that returns true\nwhen the request is directed to \"www.reddit.com\".\nThe host equality check is `case-insensitive`, to reflect the behaviour of DNS\nresolvers, so even if the user types \"www.rEdDit.com\", the comparison will\nsatisfy the condition.\nWhen the hour is between 8:00am and 5:59pm, we directly return\na response in `DoFunc()`, so the remote destination will not receive the\nrequest and the client will receive the `\"Don't waste your time!\"` response.\n\n### Let's start\n```go\nimport \"github.com/elazarl/goproxy\"\n```\n\nThere are some proxy usage examples in the `examples` folder, which\ncover the most common cases. Take a look at them and good luck!\n\n## Request & Response manipulation\n\nThere are 3  different types of handlers to manipulate the behavior of the proxy, as follows:\n\n```go\n// handler called after receiving HTTP CONNECT from the client, and\n// before proxy establishes connection with the destination host\nhttpsHandlers   []HttpsHandler\n\n// handler called before proxy sends HTTP request to destination host\nreqHandlers     []ReqHandler \n\n// handler called after proxy receives HTTP Response from destination host,\n// and before proxy forwards the Response to the client\nrespHandlers    []RespHandler \n```\n\nDepending on what you want to manipulate, the ways to add handlers to each of the previous lists are:\n\n```go\n// Add handlers to httpsHandlers \nproxy.OnRequest(some ReqConditions).HandleConnect(YourHandlerFunc())\n\n// Add handlers to reqHandlers\nproxy.OnRequest(some ReqConditions).Do(YourReqHandlerFunc())\n\n// Add handlers to respHandlers\nproxy.OnResponse(some RespConditions).Do(YourRespHandlerFunc())\n```\n\nExample:\n\n```go\n// This rejects the HTTPS request to *.reddit.com during HTTP CONNECT phase.\n// Reddit URL check is case-insensitive because of (?i), so the block will work also if the user types something like rEdDit.com.\nproxy.OnRequest(goproxy.ReqHostMatches(regexp.MustCompile(\"(?i)reddit.*:443$\"))).HandleConnect(goproxy.AlwaysReject)\n\n// Be careful about this example! It shows you a common error that you\n// need to avoid.\n// This will NOT reject the HTTPS request with URL ending with .gif because,\n// if the scheme is HTTPS, the proxy will receive only URL.Hostname\n// and URL.Port during the HTTP CONNECT phase.\nproxy.OnRequest(goproxy.UrlMatches(regexp.MustCompile(`.*gif$`))).HandleConnect(goproxy.AlwaysReject)\n\n// To fix the previous example, here there is the correct way to manipulate\n// an HTTP request using URL.Path (target path) as a condition.\nproxy.OnRequest(goproxy.UrlMatches(regexp.MustCompile(`.*gif$`))).Do(YourReqHandlerFunc())\n```\n\n## Error handling\n### Generic error\nIf an error occurs while handling a request through the proxy, by default\nthe proxy returns HTTP error `500` (Internal Server Error) with the `error\nmessage` as the `body` content.\n\nIf you want to override this behaviour, you can define your own\n`RespHandler` that changes the error response.\nAmong the context parameters, `ctx.Error` contains the `error` occurred,\nif any, or the `nil` value, if no error happened.\n\nYou can handle it as you wish, including returning a custom JSON as the body.\nExample of an error handler:\n```\nproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\tvar dnsError *net.DNSError\n\tif errors.As(ctx.Error, &dnsError) {\n\t\t// Do not leak our DNS server's address\n\t\tdnsError.Server = \"<server-redacted>\"\n\t\treturn goproxy.NewResponse(ctx.Req, goproxy.ContentTypeText, http.StatusBadGateway, dnsError.Error())\n\t}\n\treturn resp\n})\n```\n\n### Connection error\nIf an error occurs while sending data to the target remote server (or to\nthe proxy client), the `proxy.ConnectionErrHandler` is called to handle the\nerror, if present, else a `default handler` will be used.\nThe error is passed as `function parameter` and not inside the proxy context,\nso you don't have to check the ctx.Error field in this handler.\n\nIn this handler you have access to the raw connection with the proxy\nclient (as an `io.Writer`), so you could send any HTTP data over it,\nif needed, containing the error data.\nThere is no guarantee that the connection hasn't already been closed, so\nthe `Write()` could return an error.\n\nThe `connection` will be `automatically closed` by the proxy library after the\nerror handler call, so you don't have to worry about it.\n\n## Project Status\nThis project has been created `10 years` ago, and has reached a stage of\n`maturity`. It can be safely used in `production`, and many projects\nalready do that.\n\nIf there will be any `breaking change` in the future, a `new version` of the\nGo module will be released (e.g. v2).\n\n## Trusted, as a direct dependency, by:\n<p align=\"left\">\n<a href=\"https://github.com/stripe/goproxy\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/856813?s=50\" alt=\"Stripe\" title=\"Stripe\" /> </a>\n<a href=\"https://github.com/dependabot/goproxy\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/27347476?s=50\" alt=\"Dependabot\" title=\"Dependabot\" /> </a>\n<a href=\"https://github.com/go-git/go-git\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/57653224?s=50\" alt=\"Go Git\" title=\"Go Git\" /> </a>\n<a href=\"https://github.com/google/oss-rebuild\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/1342004?s=50\" alt=\"Google\" title=\"Google\" /> </a>\n<a href=\"https://github.com/grafana/grafana-plugin-sdk-go\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/7195757?s=50\" alt=\"Grafana\" title=\"Grafana\" /> </a>\n<a href=\"https://github.com/superfly/tokenizer\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/22525303?s=50\" alt=\"Fly.io\" title=\"Fly.io\" /> </a>\n<a href=\"https://github.com/kubernetes/minikube\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/13629408?s=50\" alt=\"Kubernetes / Minikube\" title=\"Kubernetes / Minikube\" /> </a>\n<a href=\"https://github.com/newrelic/newrelic-client-go\" target=\"_blank\" rel=\"noreferrer\"> <img src=\"https://avatars.githubusercontent.com/u/31739?s=50\" alt=\"New Relic\" title=\"New Relic\" /> </a>\n</p>\n"
        },
        {
          "name": "actions.go",
          "type": "blob",
          "size": 2.5322265625,
          "content": "package goproxy\n\nimport \"net/http\"\n\n// ReqHandler will \"tamper\" with the request coming to the proxy server\n// If Handle returns req,nil the proxy will send the returned request\n// to the destination server. If it returns nil,resp the proxy will\n// skip sending any requests, and will simply return the response `resp`\n// to the client.\ntype ReqHandler interface {\n\tHandle(req *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response)\n}\n\n// A wrapper that would convert a function to a ReqHandler interface type.\ntype FuncReqHandler func(req *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response)\n\n// FuncReqHandler.Handle(req,ctx) <=> FuncReqHandler(req,ctx).\nfunc (f FuncReqHandler) Handle(req *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response) {\n\treturn f(req, ctx)\n}\n\n// after the proxy have sent the request to the destination server, it will\n// \"filter\" the response through the RespHandlers it has.\n// The proxy server will send to the client the response returned by the RespHandler.\n// In case of error, resp will be nil, and ctx.RoundTrip.Error will contain the error.\ntype RespHandler interface {\n\tHandle(resp *http.Response, ctx *ProxyCtx) *http.Response\n}\n\n// A wrapper that would convert a function to a RespHandler interface type.\ntype FuncRespHandler func(resp *http.Response, ctx *ProxyCtx) *http.Response\n\n// FuncRespHandler.Handle(req,ctx) <=> FuncRespHandler(req,ctx).\nfunc (f FuncRespHandler) Handle(resp *http.Response, ctx *ProxyCtx) *http.Response {\n\treturn f(resp, ctx)\n}\n\n// When a client send a CONNECT request to a host, the request is filtered through\n// all the HttpsHandlers the proxy has, and if one returns true, the connection is\n// sniffed using Man in the Middle attack.\n// That is, the proxy will create a TLS connection with the client, another TLS\n// connection with the destination the client wished to connect to, and would\n// send back and forth all messages from the server to the client and vice versa.\n// The request and responses sent in this Man In the Middle channel are filtered\n// through the usual flow (request and response filtered through the ReqHandlers\n// and RespHandlers).\ntype HttpsHandler interface {\n\tHandleConnect(req string, ctx *ProxyCtx) (*ConnectAction, string)\n}\n\n// A wrapper that would convert a function to a HttpsHandler interface type.\ntype FuncHttpsHandler func(host string, ctx *ProxyCtx) (*ConnectAction, string)\n\n// FuncHttpsHandler should implement the RespHandler interface.\nfunc (f FuncHttpsHandler) HandleConnect(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n\treturn f(host, ctx)\n}\n"
        },
        {
          "name": "all.bash",
          "type": "blob",
          "size": 0.3173828125,
          "content": "#!/bin/bash\n\ngo test || exit\nfor action in $@; do go $action; done\n\nmkdir -p bin\nfind regretable examples/* ext/* -maxdepth 0 -type d | while read d; do\n\t(cd $d\n\tgo build -o ../../bin/$(basename $d)\n\tfind *_test.go -maxdepth 0 2>/dev/null|while read f;do\n\t\tfor action in $@; do go $action; done\n\t\tgo test\n\t\tbreak\n\tdone)\ndone\n"
        },
        {
          "name": "ca.pem",
          "type": "blob",
          "size": 2.076171875,
          "content": "-----BEGIN CERTIFICATE-----\nMIIF9DCCA9ygAwIBAgIJAODqYUwoVjJkMA0GCSqGSIb3DQEBCwUAMIGOMQswCQYD\nVQQGEwJJTDEPMA0GA1UECAwGQ2VudGVyMQwwCgYDVQQHDANMb2QxEDAOBgNVBAoM\nB0dvUHJveHkxEDAOBgNVBAsMB0dvUHJveHkxGjAYBgNVBAMMEWdvcHJveHkuZ2l0\naHViLmlvMSAwHgYJKoZIhvcNAQkBFhFlbGF6YXJsQGdtYWlsLmNvbTAeFw0xNzA0\nMDUyMDAwMTBaFw0zNzAzMzEyMDAwMTBaMIGOMQswCQYDVQQGEwJJTDEPMA0GA1UE\nCAwGQ2VudGVyMQwwCgYDVQQHDANMb2QxEDAOBgNVBAoMB0dvUHJveHkxEDAOBgNV\nBAsMB0dvUHJveHkxGjAYBgNVBAMMEWdvcHJveHkuZ2l0aHViLmlvMSAwHgYJKoZI\nhvcNAQkBFhFlbGF6YXJsQGdtYWlsLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIP\nADCCAgoCggIBAJ4Qy+H6hhoY1s0QRcvIhxrjSHaO/RbaFj3rwqcnpOgFq07gRdI9\n3c0TFKQJHpgv6feLRhEvX/YllFYu4J35lM9ZcYY4qlKFuStcX8Jm8fqpgtmAMBzP\nsqtqDi8M9RQGKENzU9IFOnCV7SAeh45scMuI3wz8wrjBcH7zquHkvqUSYZz035t9\nV6WTrHyTEvT4w+lFOVN2bA/6DAIxrjBiF6DhoJqnha0SZtDfv77XpwGG3EhA/qoh\nhiYrDruYK7zJdESQL44LwzMPupVigqalfv+YHfQjbhT951IVurW2NJgRyBE62dLr\nlHYdtT9tCTCrd+KJNMJ+jp9hAjdIu1Br/kifU4F4+4ZLMR9Ueji0GkkPKsYdyMnq\nj0p0PogyvP1l4qmboPImMYtaoFuYmMYlebgC9LN10bL91K4+jLt0I1YntEzrqgJo\nWsJztYDw543NzSy5W+/cq4XRYgtq1b0RWwuUiswezmMoeyHZ8BQJe2xMjAOllASD\nfqa8OK3WABHJpy4zUrnUBiMuPITzD/FuDx4C5IwwlC68gHAZblNqpBZCX0nFCtKj\nYOcI2So5HbQ2OC8QF+zGVuduHUSok4hSy2BBfZ1pfvziqBeetWJwFvapGB44nIHh\nWKNKvqOxLNIy7e+TGRiWOomrAWM18VSR9LZbBxpJK7PLSzWqYJYTRCZHAgMBAAGj\nUzBRMB0GA1UdDgQWBBR4uDD9Y6x7iUoHO+32ioOcw1ICZTAfBgNVHSMEGDAWgBR4\nuDD9Y6x7iUoHO+32ioOcw1ICZTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEB\nCwUAA4ICAQAaCEupzGGqcdh+L7BzhX7zyd7yzAKUoLxFrxaZY34Xyj3lcx1XoK6F\nAqsH2JM25GixgadzhNt92JP7vzoWeHZtLfstrPS638Y1zZi6toy4E49viYjFk5J0\nC6ZcFC04VYWWx6z0HwJuAS08tZ37JuFXpJGfXJOjZCQyxse0Lg0tuKLMeXDCk2Y3\nBa0noeuNyHRoWXXPyiUoeApkVCU5gIsyiJSWOjhJ5hpJG06rQNfNYexgKrrraEin\no0jmEMtJMx5TtD83hSnLCnFGBBq5lkE7jgXME1KsbIE3lJZzRX1mQwUK8CJDYxye\ni6M/dzSvy0SsPvz8fTAlprXRtWWtJQmxgWENp3Dv+0Pmux/l+ilk7KA4sMXGhsfr\nbvTOeWl1/uoFTPYiWR/ww7QEPLq23yDFY04Q7Un0qjIk8ExvaY8lCkXMgc8i7sGY\nVfvOYb0zm67EfAQl3TW8Ky5fl5CcxpVCD360Bzi6hwjYixa3qEeBggOixFQBFWft\n8wrkKTHpOQXjn4sDPtet8imm9UYEtzWrFX6T9MFYkBR0/yye0FIh9+YPiTA6WB86\nNCNwK5Yl6HuvF97CIH5CdgO+5C7KifUtqTOL8pQKbNwy0S3sNYvB+njGvRpR7pKV\nBUnFpB/Atptqr4CUlTXrc5IPLAqAfmwk5IKcwy3EXUbruf9Dwz69YA==\n-----END CERTIFICATE-----\n"
        },
        {
          "name": "certs.go",
          "type": "blob",
          "size": 6.0126953125,
          "content": "package goproxy\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n)\n\nvar GoproxyCa tls.Certificate\n\nfunc init() {\n\t// When we included the embedded certificate inside this file, we made\n\t// sure that it was valid.\n\t// If there is an error here, this is a really exceptional case that requires\n\t// a panic. It should NEVER happen!\n\tvar err error\n\tGoproxyCa, err = tls.X509KeyPair(CA_CERT, CA_KEY)\n\tif err != nil {\n\t\tpanic(\"Error parsing builtin CA: \" + err.Error())\n\t}\n\n\tif GoproxyCa.Leaf, err = x509.ParseCertificate(GoproxyCa.Certificate[0]); err != nil {\n\t\tpanic(\"Error parsing builtin CA leaf: \" + err.Error())\n\t}\n}\n\nvar tlsClientSkipVerify = &tls.Config{InsecureSkipVerify: true}\n\nvar defaultTLSConfig = &tls.Config{\n\tInsecureSkipVerify: true,\n}\n\nvar CA_CERT = []byte(`-----BEGIN CERTIFICATE-----\nMIIF9DCCA9ygAwIBAgIJAODqYUwoVjJkMA0GCSqGSIb3DQEBCwUAMIGOMQswCQYD\nVQQGEwJJTDEPMA0GA1UECAwGQ2VudGVyMQwwCgYDVQQHDANMb2QxEDAOBgNVBAoM\nB0dvUHJveHkxEDAOBgNVBAsMB0dvUHJveHkxGjAYBgNVBAMMEWdvcHJveHkuZ2l0\naHViLmlvMSAwHgYJKoZIhvcNAQkBFhFlbGF6YXJsQGdtYWlsLmNvbTAeFw0xNzA0\nMDUyMDAwMTBaFw0zNzAzMzEyMDAwMTBaMIGOMQswCQYDVQQGEwJJTDEPMA0GA1UE\nCAwGQ2VudGVyMQwwCgYDVQQHDANMb2QxEDAOBgNVBAoMB0dvUHJveHkxEDAOBgNV\nBAsMB0dvUHJveHkxGjAYBgNVBAMMEWdvcHJveHkuZ2l0aHViLmlvMSAwHgYJKoZI\nhvcNAQkBFhFlbGF6YXJsQGdtYWlsLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIP\nADCCAgoCggIBAJ4Qy+H6hhoY1s0QRcvIhxrjSHaO/RbaFj3rwqcnpOgFq07gRdI9\n3c0TFKQJHpgv6feLRhEvX/YllFYu4J35lM9ZcYY4qlKFuStcX8Jm8fqpgtmAMBzP\nsqtqDi8M9RQGKENzU9IFOnCV7SAeh45scMuI3wz8wrjBcH7zquHkvqUSYZz035t9\nV6WTrHyTEvT4w+lFOVN2bA/6DAIxrjBiF6DhoJqnha0SZtDfv77XpwGG3EhA/qoh\nhiYrDruYK7zJdESQL44LwzMPupVigqalfv+YHfQjbhT951IVurW2NJgRyBE62dLr\nlHYdtT9tCTCrd+KJNMJ+jp9hAjdIu1Br/kifU4F4+4ZLMR9Ueji0GkkPKsYdyMnq\nj0p0PogyvP1l4qmboPImMYtaoFuYmMYlebgC9LN10bL91K4+jLt0I1YntEzrqgJo\nWsJztYDw543NzSy5W+/cq4XRYgtq1b0RWwuUiswezmMoeyHZ8BQJe2xMjAOllASD\nfqa8OK3WABHJpy4zUrnUBiMuPITzD/FuDx4C5IwwlC68gHAZblNqpBZCX0nFCtKj\nYOcI2So5HbQ2OC8QF+zGVuduHUSok4hSy2BBfZ1pfvziqBeetWJwFvapGB44nIHh\nWKNKvqOxLNIy7e+TGRiWOomrAWM18VSR9LZbBxpJK7PLSzWqYJYTRCZHAgMBAAGj\nUzBRMB0GA1UdDgQWBBR4uDD9Y6x7iUoHO+32ioOcw1ICZTAfBgNVHSMEGDAWgBR4\nuDD9Y6x7iUoHO+32ioOcw1ICZTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEB\nCwUAA4ICAQAaCEupzGGqcdh+L7BzhX7zyd7yzAKUoLxFrxaZY34Xyj3lcx1XoK6F\nAqsH2JM25GixgadzhNt92JP7vzoWeHZtLfstrPS638Y1zZi6toy4E49viYjFk5J0\nC6ZcFC04VYWWx6z0HwJuAS08tZ37JuFXpJGfXJOjZCQyxse0Lg0tuKLMeXDCk2Y3\nBa0noeuNyHRoWXXPyiUoeApkVCU5gIsyiJSWOjhJ5hpJG06rQNfNYexgKrrraEin\no0jmEMtJMx5TtD83hSnLCnFGBBq5lkE7jgXME1KsbIE3lJZzRX1mQwUK8CJDYxye\ni6M/dzSvy0SsPvz8fTAlprXRtWWtJQmxgWENp3Dv+0Pmux/l+ilk7KA4sMXGhsfr\nbvTOeWl1/uoFTPYiWR/ww7QEPLq23yDFY04Q7Un0qjIk8ExvaY8lCkXMgc8i7sGY\nVfvOYb0zm67EfAQl3TW8Ky5fl5CcxpVCD360Bzi6hwjYixa3qEeBggOixFQBFWft\n8wrkKTHpOQXjn4sDPtet8imm9UYEtzWrFX6T9MFYkBR0/yye0FIh9+YPiTA6WB86\nNCNwK5Yl6HuvF97CIH5CdgO+5C7KifUtqTOL8pQKbNwy0S3sNYvB+njGvRpR7pKV\nBUnFpB/Atptqr4CUlTXrc5IPLAqAfmwk5IKcwy3EXUbruf9Dwz69YA==\n-----END CERTIFICATE-----`)\n\nvar CA_KEY = []byte(`-----BEGIN RSA PRIVATE KEY-----\n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\n-----END RSA PRIVATE KEY-----`)\n"
        },
        {
          "name": "certs",
          "type": "tree",
          "content": null
        },
        {
          "name": "chunked.go",
          "type": "blob",
          "size": 1.693359375,
          "content": "// Taken from $GOROOT/src/pkg/net/http/chunked\n// needed to write https responses to client.\npackage goproxy\n\nimport (\n\t\"io\"\n\t\"strconv\"\n)\n\n// newChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n// \"chunked\" format before writing them to w. Closing the returned chunkedWriter\n// sends the final 0-length chunk that marks the end of the stream.\n//\n// newChunkedWriter is not needed by normal applications. The http\n// package adds chunking automatically if handlers don't set a\n// Content-Length header. Using newChunkedWriter inside a handler\n// would result in double chunking or chunking with a Content-Length\n// length, both of which are wrong.\nfunc newChunkedWriter(w io.Writer) io.WriteCloser {\n\treturn &chunkedWriter{w}\n}\n\n// Writing to chunkedWriter translates to writing in HTTP chunked Transfer\n// Encoding wire format to the underlying Wire chunkedWriter.\ntype chunkedWriter struct {\n\tWire io.Writer\n}\n\n// Write the contents of data as one chunk to Wire.\n// NOTE: Note that the corresponding chunk-writing procedure in Conn.Write has\n// a bug since it does not check for success of io.WriteString.\nfunc (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n\t// Don't send 0-length data. It looks like EOF for chunked encoding.\n\tif len(data) == 0 {\n\t\treturn 0, nil\n\t}\n\n\thead := strconv.FormatInt(int64(len(data)), 16) + \"\\r\\n\"\n\n\tif _, err = io.WriteString(cw.Wire, head); err != nil {\n\t\treturn 0, err\n\t}\n\tif n, err = cw.Wire.Write(data); err != nil {\n\t\treturn n, err\n\t}\n\tif n != len(data) {\n\t\terr = io.ErrShortWrite\n\t\treturn n, err\n\t}\n\t_, err = io.WriteString(cw.Wire, \"\\r\\n\")\n\treturn n, err\n}\n\nfunc (cw *chunkedWriter) Close() error {\n\t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n\treturn err\n}\n"
        },
        {
          "name": "ctx.go",
          "type": "blob",
          "size": 2.9873046875,
          "content": "package goproxy\n\nimport (\n\t\"crypto/tls\"\n\t\"mime\"\n\t\"net/http\"\n)\n\n// ProxyCtx is the Proxy context, contains useful information about every request. It is passed to\n// every user function. Also used as a logger.\ntype ProxyCtx struct {\n\t// Will contain the client request from the proxy\n\tReq *http.Request\n\t// Will contain the remote server's response (if available. nil if the request wasn't send yet)\n\tResp         *http.Response\n\tRoundTripper RoundTripper\n\t// will contain the recent error that occurred while trying to send receive or parse traffic\n\tError error\n\t// A handle for the user to keep data in the context, from the call of ReqHandler to the\n\t// call of RespHandler\n\tUserData any\n\t// Will connect a request to a response\n\tSession   int64\n\tcertStore CertStorage\n\tProxy     *ProxyHttpServer\n}\n\ntype RoundTripper interface {\n\tRoundTrip(req *http.Request, ctx *ProxyCtx) (*http.Response, error)\n}\n\ntype CertStorage interface {\n\tFetch(hostname string, gen func() (*tls.Certificate, error)) (*tls.Certificate, error)\n}\n\ntype RoundTripperFunc func(req *http.Request, ctx *ProxyCtx) (*http.Response, error)\n\nfunc (f RoundTripperFunc) RoundTrip(req *http.Request, ctx *ProxyCtx) (*http.Response, error) {\n\treturn f(req, ctx)\n}\n\nfunc (ctx *ProxyCtx) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif ctx.RoundTripper != nil {\n\t\treturn ctx.RoundTripper.RoundTrip(req, ctx)\n\t}\n\treturn ctx.Proxy.Tr.RoundTrip(req)\n}\n\nfunc (ctx *ProxyCtx) printf(msg string, argv ...any) {\n\tctx.Proxy.Logger.Printf(\"[%03d] \"+msg+\"\\n\", append([]any{ctx.Session & 0xFFFF}, argv...)...)\n}\n\n// Logf prints a message to the proxy's log. Should be used in a ProxyHttpServer's filter\n// This message will be printed only if the Verbose field of the ProxyHttpServer is set to true\n//\n//\tproxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){\n//\t\tnr := atomic.AddInt32(&counter,1)\n//\t\tctx.Printf(\"So far %d requests\",nr)\n//\t\treturn r, nil\n//\t})\nfunc (ctx *ProxyCtx) Logf(msg string, argv ...any) {\n\tif ctx.Proxy.Verbose {\n\t\tctx.printf(\"INFO: \"+msg, argv...)\n\t}\n}\n\n// Warnf prints a message to the proxy's log. Should be used in a ProxyHttpServer's filter\n// This message will always be printed.\n//\n//\tproxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){\n//\t\tf,err := os.OpenFile(cachedContent)\n//\t\tif err != nil {\n//\t\t\tctx.Warnf(\"error open file %v: %v\",cachedContent,err)\n//\t\t\treturn r, nil\n//\t\t}\n//\t\treturn r, nil\n//\t})\nfunc (ctx *ProxyCtx) Warnf(msg string, argv ...any) {\n\tctx.printf(\"WARN: \"+msg, argv...)\n}\n\n// Will try to infer the character set of the request from the headers.\n// Returns the empty string if we don't know which character set it used.\n// Currently it will look for charset=<charset> in the Content-Type header of the request.\nfunc (ctx *ProxyCtx) Charset() string {\n\tcontentType := ctx.Resp.Header.Get(\"Content-Type\")\n\tif _, params, err := mime.ParseMediaType(contentType); err == nil {\n\t\tif cs, ok := params[\"charset\"]; ok {\n\t\t\treturn cs\n\t\t}\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "dispatcher.go",
          "type": "blob",
          "size": 13.51171875,
          "content": "package goproxy\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// ReqCondition.HandleReq will decide whether or not to use the ReqHandler on an HTTP request\n// before sending it to the remote server.\ntype ReqCondition interface {\n\tRespCondition\n\tHandleReq(req *http.Request, ctx *ProxyCtx) bool\n}\n\n// RespCondition.HandleReq will decide whether or not to use the RespHandler on an HTTP response\n// before sending it to the proxy client. Note that resp might be nil, in case there was an\n// error sending the request.\ntype RespCondition interface {\n\tHandleResp(resp *http.Response, ctx *ProxyCtx) bool\n}\n\n// ReqConditionFunc.HandleReq(req,ctx) <=> ReqConditionFunc(req,ctx).\ntype ReqConditionFunc func(req *http.Request, ctx *ProxyCtx) bool\n\n// RespConditionFunc.HandleResp(resp,ctx) <=> RespConditionFunc(resp,ctx).\ntype RespConditionFunc func(resp *http.Response, ctx *ProxyCtx) bool\n\nfunc (c ReqConditionFunc) HandleReq(req *http.Request, ctx *ProxyCtx) bool {\n\treturn c(req, ctx)\n}\n\n// ReqConditionFunc cannot test responses. It only satisfies RespCondition interface so that\n// to be usable as RespCondition.\nfunc (c ReqConditionFunc) HandleResp(resp *http.Response, ctx *ProxyCtx) bool {\n\treturn c(ctx.Req, ctx)\n}\n\nfunc (c RespConditionFunc) HandleResp(resp *http.Response, ctx *ProxyCtx) bool {\n\treturn c(resp, ctx)\n}\n\n// UrlHasPrefix returns a ReqCondition checking wether the destination URL the proxy client has requested\n// has the given prefix, with or without the host.\n// For example UrlHasPrefix(\"host/x\") will match requests of the form 'GET host/x', and will match\n// requests to url 'http://host/x'\nfunc UrlHasPrefix(prefix string) ReqConditionFunc {\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\t// Make sure to include the / as the first path character when we do a match\n\t\t// using the host\n\t\trelativePath := req.URL.Path\n\t\tif length := len(relativePath); length == 0 || (length > 0 && relativePath[0] != '/') {\n\t\t\trelativePath = \"/\" + relativePath\n\t\t}\n\t\t// We use the original value to distinguish between \"\" and \"/\" in the user specified string\n\t\treturn strings.HasPrefix(req.URL.Path, prefix) ||\n\t\t\tstrings.HasPrefix(req.URL.Host+relativePath, prefix) ||\n\t\t\t// Scheme value is something like \"https\", we must include the :// characters\n\t\t\tstrings.HasPrefix(req.URL.Scheme+\"://\"+req.URL.Host+relativePath, prefix)\n\t}\n}\n\n// UrlIs returns a ReqCondition, testing whether or not the request URL is one of the given strings\n// with or without the host prefix.\n// UrlIs(\"google.com/\",\"foo\") will match requests 'GET /' to 'google.com', requests `'GET google.com/' to\n// any host, and requests of the form 'GET foo'.\nfunc UrlIs(urls ...string) ReqConditionFunc {\n\turlSet := make(map[string]bool)\n\tfor _, u := range urls {\n\t\turlSet[u] = true\n\t}\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\t_, pathOk := urlSet[req.URL.Path]\n\t\t_, hostAndOk := urlSet[req.URL.Host+req.URL.Path]\n\t\treturn pathOk || hostAndOk\n\t}\n}\n\n// ReqHostMatches returns a ReqCondition, testing whether the host to which the request was directed to matches\n// any of the given regular expressions.\nfunc ReqHostMatches(regexps ...*regexp.Regexp) ReqConditionFunc {\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\tfor _, re := range regexps {\n\t\t\tif re.MatchString(req.Host) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\n// ReqHostIs returns a ReqCondition, testing whether the host to which the request is directed to equal\n// to one of the given strings.\nfunc ReqHostIs(hosts ...string) ReqConditionFunc {\n\thostSet := make(map[string]bool)\n\tfor _, h := range hosts {\n\t\thostSet[h] = true\n\t}\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\t_, ok := hostSet[req.URL.Host]\n\t\treturn ok\n\t}\n}\n\n// IsLocalHost checks whether the destination host is localhost.\nvar IsLocalHost ReqConditionFunc = func(req *http.Request, ctx *ProxyCtx) bool {\n\th := req.URL.Hostname()\n\tif h == \"localhost\" {\n\t\treturn true\n\t}\n\tif ip := net.ParseIP(h); ip != nil {\n\t\treturn ip.IsLoopback()\n\t}\n\n\t// In case of IPv6 without a port number Hostname() sometimes returns the invalid value.\n\tif ip := net.ParseIP(req.URL.Host); ip != nil {\n\t\treturn ip.IsLoopback()\n\t}\n\n\treturn false\n}\n\n// UrlMatches returns a ReqCondition testing whether the destination URL\n// of the request matches the given regexp, with or without prefix.\nfunc UrlMatches(re *regexp.Regexp) ReqConditionFunc {\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\treturn re.MatchString(req.URL.Path) ||\n\t\t\tre.MatchString(req.URL.Host+req.URL.Path)\n\t}\n}\n\n// DstHostIs returns a ReqCondition testing wether the host in the request url is the given string.\nfunc DstHostIs(host string) ReqConditionFunc {\n\t// Make sure to perform a case-insensitive host check\n\thost = strings.ToLower(host)\n\tvar port string\n\n\t// Check if the user specified a custom port that we need to match\n\tif strings.Contains(host, \":\") {\n\t\thostOnly, portOnly, err := net.SplitHostPort(host)\n\t\tif err == nil {\n\t\t\thost = hostOnly\n\t\t\tport = portOnly\n\t\t}\n\t}\n\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\t// Check port matching only if it was specified\n\t\tif port != \"\" && port != req.URL.Port() {\n\t\t\treturn false\n\t\t}\n\n\t\treturn strings.ToLower(req.URL.Hostname()) == host\n\t}\n}\n\n// SrcIpIs returns a ReqCondition testing whether the source IP of the request is one of the given strings.\nfunc SrcIpIs(ips ...string) ReqCondition {\n\treturn ReqConditionFunc(func(req *http.Request, ctx *ProxyCtx) bool {\n\t\tfor _, ip := range ips {\n\t\t\tif strings.HasPrefix(req.RemoteAddr, ip+\":\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// Not returns a ReqCondition negating the given ReqCondition.\nfunc Not(r ReqCondition) ReqConditionFunc {\n\treturn func(req *http.Request, ctx *ProxyCtx) bool {\n\t\treturn !r.HandleReq(req, ctx)\n\t}\n}\n\n// ContentTypeIs returns a RespCondition testing whether the HTTP response has Content-Type header equal\n// to one of the given strings.\nfunc ContentTypeIs(typ string, types ...string) RespCondition {\n\ttypes = append(types, typ)\n\treturn RespConditionFunc(func(resp *http.Response, ctx *ProxyCtx) bool {\n\t\tif resp == nil {\n\t\t\treturn false\n\t\t}\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tfor _, typ := range types {\n\t\t\tif contentType == typ || strings.HasPrefix(contentType, typ+\";\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// StatusCodeIs returns a RespCondition, testing whether or not the HTTP status\n// code is one of the given ints.\nfunc StatusCodeIs(codes ...int) RespCondition {\n\tcodeSet := make(map[int]bool)\n\tfor _, c := range codes {\n\t\tcodeSet[c] = true\n\t}\n\treturn RespConditionFunc(func(resp *http.Response, ctx *ProxyCtx) bool {\n\t\tif resp == nil {\n\t\t\treturn false\n\t\t}\n\t\t_, codeMatch := codeSet[resp.StatusCode]\n\t\treturn codeMatch\n\t})\n}\n\n// ProxyHttpServer.OnRequest Will return a temporary ReqProxyConds struct, aggregating the given condtions.\n// You will use the ReqProxyConds struct to register a ReqHandler, that would filter\n// the request, only if all the given ReqCondition matched.\n// Typical usage:\n//\n//\tproxy.OnRequest(UrlIs(\"example.com/foo\"),UrlMatches(regexp.MustParse(`.*\\.exampl.\\com\\./.*`)).Do(...)\nfunc (proxy *ProxyHttpServer) OnRequest(conds ...ReqCondition) *ReqProxyConds {\n\treturn &ReqProxyConds{proxy, conds}\n}\n\n// ReqProxyConds aggregate ReqConditions for a ProxyHttpServer.\n// Upon calling Do, it will register a ReqHandler that would\n// handle the request if all conditions on the HTTP request are met.\ntype ReqProxyConds struct {\n\tproxy    *ProxyHttpServer\n\treqConds []ReqCondition\n}\n\n// DoFunc is equivalent to proxy.OnRequest().Do(FuncReqHandler(f)).\nfunc (pcond *ReqProxyConds) DoFunc(f func(req *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response)) {\n\tpcond.Do(FuncReqHandler(f))\n}\n\n// ReqProxyConds.Do will register the ReqHandler on the proxy,\n// the ReqHandler will handle the HTTP request if all the conditions\n// aggregated in the ReqProxyConds are met. Typical usage:\n//\n//\tproxy.OnRequest().Do(handler) // will call handler.Handle(req,ctx) on every request to the proxy\n//\tproxy.OnRequest(cond1,cond2).Do(handler)\n//\t// given request to the proxy, will test if cond1.HandleReq(req,ctx) && cond2.HandleReq(req,ctx) are true\n//\t// if they are, will call handler.Handle(req,ctx)\nfunc (pcond *ReqProxyConds) Do(h ReqHandler) {\n\tpcond.proxy.reqHandlers = append(pcond.proxy.reqHandlers,\n\t\tFuncReqHandler(func(r *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response) {\n\t\t\tfor _, cond := range pcond.reqConds {\n\t\t\t\tif !cond.HandleReq(r, ctx) {\n\t\t\t\t\treturn r, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn h.Handle(r, ctx)\n\t\t}))\n}\n\n// HandleConnect is used when proxy receives an HTTP CONNECT request,\n// it'll then use the HttpsHandler to determine what should it\n// do with this request. The handler returns a ConnectAction struct, the Action field in the ConnectAction\n// struct returned will determine what to do with this request. ConnectAccept will simply accept the request\n// forwarding all bytes from the client to the remote host, ConnectReject will close the connection with the\n// client, and ConnectMitm, will assume the underlying connection is an HTTPS connection, and will use Man\n// in the Middle attack to eavesdrop the connection. All regular handler will be active on this eavesdropped\n// connection.\n// The ConnectAction struct contains possible tlsConfig that will be used for eavesdropping. If nil, the proxy\n// will use the default tls configuration.\n//\n//\tproxy.OnRequest().HandleConnect(goproxy.AlwaysReject) // rejects all CONNECT requests\nfunc (pcond *ReqProxyConds) HandleConnect(h HttpsHandler) {\n\tpcond.proxy.httpsHandlers = append(pcond.proxy.httpsHandlers,\n\t\tFuncHttpsHandler(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n\t\t\tfor _, cond := range pcond.reqConds {\n\t\t\t\tif !cond.HandleReq(ctx.Req, ctx) {\n\t\t\t\t\treturn nil, \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn h.HandleConnect(host, ctx)\n\t\t}))\n}\n\n// HandleConnectFunc is equivalent to HandleConnect,\n// for example, accepting CONNECT request if they contain a password in header\n//\n//\tio.WriteString(h,password)\n//\tpassHash := h.Sum(nil)\n//\tproxy.OnRequest().HandleConnectFunc(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n//\t\tc := sha1.New()\n//\t\tio.WriteString(c,ctx.Req.Header.Get(\"X-GoProxy-Auth\"))\n//\t\tif c.Sum(nil) == passHash {\n//\t\t\treturn OkConnect, host\n//\t\t}\n//\t\treturn RejectConnect, host\n//\t})\nfunc (pcond *ReqProxyConds) HandleConnectFunc(f func(host string, ctx *ProxyCtx) (*ConnectAction, string)) {\n\tpcond.HandleConnect(FuncHttpsHandler(f))\n}\n\nfunc (pcond *ReqProxyConds) HijackConnect(f func(req *http.Request, client net.Conn, ctx *ProxyCtx)) {\n\tpcond.proxy.httpsHandlers = append(pcond.proxy.httpsHandlers,\n\t\tFuncHttpsHandler(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n\t\t\tfor _, cond := range pcond.reqConds {\n\t\t\t\tif !cond.HandleReq(ctx.Req, ctx) {\n\t\t\t\t\treturn nil, \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &ConnectAction{Action: ConnectHijack, Hijack: f}, host\n\t\t}))\n}\n\n// ProxyConds is used to aggregate RespConditions for a ProxyHttpServer.\n// Upon calling ProxyConds.Do, it will register a RespHandler that would\n// handle the HTTP response from remote server if all conditions on the HTTP response are met.\ntype ProxyConds struct {\n\tproxy    *ProxyHttpServer\n\treqConds []ReqCondition\n\trespCond []RespCondition\n}\n\n// ProxyConds.DoFunc is equivalent to proxy.OnResponse().Do(FuncRespHandler(f)).\nfunc (pcond *ProxyConds) DoFunc(f func(resp *http.Response, ctx *ProxyCtx) *http.Response) {\n\tpcond.Do(FuncRespHandler(f))\n}\n\n// ProxyConds.Do will register the RespHandler on the proxy, h.Handle(resp,ctx) will be called on every\n// request that matches the conditions aggregated in pcond.\nfunc (pcond *ProxyConds) Do(h RespHandler) {\n\tpcond.proxy.respHandlers = append(pcond.proxy.respHandlers,\n\t\tFuncRespHandler(func(resp *http.Response, ctx *ProxyCtx) *http.Response {\n\t\t\tfor _, cond := range pcond.reqConds {\n\t\t\t\tif !cond.HandleReq(ctx.Req, ctx) {\n\t\t\t\t\treturn resp\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, cond := range pcond.respCond {\n\t\t\t\tif !cond.HandleResp(resp, ctx) {\n\t\t\t\t\treturn resp\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn h.Handle(resp, ctx)\n\t\t}))\n}\n\n// OnResponse is used when adding a response-filter to the HTTP proxy, usual pattern is\n//\n//\tproxy.OnResponse(cond1,cond2).Do(handler) // handler.Handle(resp,ctx) will be used\n//\t\t\t\t// if cond1.HandleResp(resp) && cond2.HandleResp(resp)\nfunc (proxy *ProxyHttpServer) OnResponse(conds ...RespCondition) *ProxyConds {\n\treturn &ProxyConds{proxy, make([]ReqCondition, 0), conds}\n}\n\n// AlwaysMitm is a HttpsHandler that always eavesdrop https connections, for example to\n// eavesdrop all https connections to www.google.com, we can use\n//\n//\tproxy.OnRequest(goproxy.ReqHostIs(\"www.google.com\")).HandleConnect(goproxy.AlwaysMitm)\nvar AlwaysMitm FuncHttpsHandler = func(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n\treturn MitmConnect, host\n}\n\n// AlwaysReject is a HttpsHandler that drops any CONNECT request, for example, this code will disallow\n// connections to hosts on any other port than 443\n//\n//\tproxy.OnRequest(goproxy.Not(goproxy.ReqHostMatches(regexp.MustCompile(\":443$\"))).\n//\t\tHandleConnect(goproxy.AlwaysReject)\nvar AlwaysReject FuncHttpsHandler = func(host string, ctx *ProxyCtx) (*ConnectAction, string) {\n\treturn RejectConnect, host\n}\n\n// HandleBytes will return a RespHandler that read the entire body of the request\n// to a byte array in memory, would run the user supplied f function on the byte arra,\n// and will replace the body of the original response with the resulting byte array.\nfunc HandleBytes(f func(b []byte, ctx *ProxyCtx) []byte) RespHandler {\n\treturn FuncRespHandler(func(resp *http.Response, ctx *ProxyCtx) *http.Response {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tctx.Warnf(\"Cannot read response %s\", err)\n\t\t\treturn resp\n\t\t}\n\t\tresp.Body.Close()\n\n\t\tresp.Body = io.NopCloser(bytes.NewBuffer(f(b, ctx)))\n\t\treturn resp\n\t})\n}\n"
        },
        {
          "name": "dispatcher_test.go",
          "type": "blob",
          "size": 0.8212890625,
          "content": "package goproxy_test\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/elazarl/goproxy\"\n)\n\nfunc TestIsLocalHost(t *testing.T) {\n\thosts := []string{\n\t\t\"localhost\",\n\t\t\"127.0.0.1\",\n\t\t\"127.0.0.7\",\n\t\t\"::ffff:127.0.0.1\",\n\t\t\"::ffff:127.0.0.7\",\n\t\t\"::1\",\n\t\t\"0:0:0:0:0:0:0:1\",\n\t}\n\tports := []string{\n\t\t\"\",\n\t\t\"80\",\n\t\t\"443\",\n\t}\n\n\tfor _, host := range hosts {\n\t\tfor _, port := range ports {\n\t\t\tif port == \"\" && strings.HasPrefix(host, \"::ffff:\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\taddr := host\n\t\t\tif port != \"\" {\n\t\t\t\taddr = net.JoinHostPort(host, port)\n\t\t\t}\n\t\t\tt.Run(addr, func(t *testing.T) {\n\t\t\t\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://\"+addr, http.NoBody)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif !goproxy.IsLocalHost(req, nil) {\n\t\t\t\t\tt.Fatal(\"expected true\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 3.6474609375,
          "content": "/*\nPackage goproxy provides a customizable HTTP proxy,\nsupporting hijacking HTTPS connection.\n\nThe intent of the proxy, is to be usable with reasonable amount of traffic\nyet, customizable and programmable.\n\nThe proxy itself is simply an `net/http` handler.\n\nTypical usage is\n\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest(..conditions..).Do(..requesthandler..)\n\tproxy.OnRequest(..conditions..).DoFunc(..requesthandlerFunction..)\n\tproxy.OnResponse(..conditions..).Do(..responesHandler..)\n\tproxy.OnResponse(..conditions..).DoFunc(..responesHandlerFunction..)\n\thttp.ListenAndServe(\":8080\", proxy)\n\nAdding a header to each request\n\n\tproxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){\n\t\tr.Header.Set(\"X-GoProxy\",\"1\")\n\t\treturn r, nil\n\t})\n\n> Note that the function is called before the proxy sends the request to the server\n\nFor printing the content type of all incoming responses\n\n\tproxy.OnResponse().DoFunc(func(r *http.Response, ctx *goproxy.ProxyCtx)*http.Response{\n\t\tprintln(ctx.Req.Host,\"->\",r.Header.Get(\"Content-Type\"))\n\t\treturn r\n\t})\n\nnote that we used the ProxyCtx context variable here. It contains the request\nand the response (Req and Resp, Resp is nil if unavailable) of this specific client\ninteraction with the proxy.\n\nTo print the content type of all responses from a certain url, we'll add a\nReqCondition to the OnResponse function:\n\n\tproxy.OnResponse(goproxy.UrlIs(\"golang.org/pkg\")).DoFunc(func(r *http.Response, ctx *goproxy.ProxyCtx)*http.Response{\n\t\tprintln(ctx.Req.Host,\"->\",r.Header.Get(\"Content-Type\"))\n\t\treturn r\n\t})\n\nWe can write the condition ourselves, conditions can be set on request and on response\n\n\tvar random = ReqConditionFunc(func(r *http.Request) bool {\n\t\treturn rand.Intn(1) == 0\n\t})\n\tvar hasGoProxyHeader = RespConditionFunc(func(resp *http.Response,req *http.Request)bool {\n\t\treturn resp.Header.Get(\"X-GoProxy\") != \"\"\n\t})\n\nCaution! If you give a RespCondition to the OnRequest function, you'll get a run time panic! It doesn't\nmake sense to read the response, if you still haven't got it!\n\nFinally, we have convenience function to throw a quick response\n\n\tproxy.OnResponse(hasGoProxyHeader).DoFunc(func(r*http.Response,ctx *goproxy.ProxyCtx)*http.Response {\n\t\tr.Body.Close()\n\t\treturn goproxy.NewResponse(\n\t\t\tctx.Req, goproxy.ContentTypeText, http.StatusForbidden, \"Can't see response with X-GoProxy header!\"\n\t\t)\n\t})\n\nwe close the body of the original response, and return a new 403 response with a short message.\n\nExample use cases:\n\n1. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-avgsize\n\nTo measure the average size of an Html served in your site. One can ask\nall the QA team to access the website by a proxy, and the proxy will\nmeasure the average size of all text/html responses from your host.\n\n2. [not yet implemented]\n\nAll requests to your web servers should be directed through the proxy,\nwhen the proxy will detect html pieces sent as a response to AJAX\nrequest, it'll send a warning email.\n\n3. https://github.com/elazarl/goproxy/blob/master/examples/goproxy-httpdump/\n\nGenerate a real traffic to your website by real users using through\nproxy. Record the traffic, and try it again for more real load testing.\n\n4. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-no-reddit-at-worktime\n\nWill allow browsing to reddit.com between 8:00am and 17:00pm\n\n5. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-jquery-version\n\nWill warn if multiple versions of jquery are used in the same domain.\n\n6. https://github.com/elazarl/goproxy/blob/master/examples/goproxy-upside-down-ternet/\n\nModifies image files in an HTTP response via goproxy's image extension found in ext/.\n*/\npackage goproxy\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2978515625,
          "content": "module github.com/elazarl/goproxy\n\ngo 1.20\n\nrequire (\n\tgithub.com/stretchr/testify v1.10.0\n\tgolang.org/x/net v0.34.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1630859375,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=\ngolang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "h2.go",
          "type": "blob",
          "size": 5.271484375,
          "content": "package goproxy\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"golang.org/x/net/http2\"\n)\n\nvar ErrInvalidH2Frame = errors.New(\"invalid H2 frame\")\n\n// H2Transport is an implementation of RoundTripper that abstracts an entire\n// HTTP/2 session, sending all client frames to the server and responses back\n// to the client.\ntype H2Transport struct {\n\tClientReader io.Reader\n\tClientWriter io.Writer\n\tTLSConfig    *tls.Config\n\tHost         string\n}\n\n// RoundTrip executes an HTTP/2 session (including all contained streams).\n// The request and response are ignored but any error encountered during the\n// proxying from the session is returned as a result of the invocation.\nfunc (r *H2Transport) RoundTrip(_ *http.Request) (*http.Response, error) {\n\traddr := r.Host\n\tif !strings.Contains(raddr, \":\") {\n\t\traddr += \":443\"\n\t}\n\trawServerTLS, err := dial(\"tcp\", raddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rawServerTLS.Close()\n\t// Ensure that we only advertise HTTP/2 as the accepted protocol.\n\tr.TLSConfig.NextProtos = []string{http2.NextProtoTLS}\n\t// Initiate TLS and check remote host name against certificate.\n\trawServerTLS = tls.Client(rawServerTLS, r.TLSConfig)\n\trawTLSConn, ok := rawServerTLS.(*tls.Conn)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid TLS connection\")\n\t}\n\tif err = rawTLSConn.Handshake(); err != nil {\n\t\treturn nil, err\n\t}\n\tif r.TLSConfig == nil || !r.TLSConfig.InsecureSkipVerify {\n\t\tif err = rawTLSConn.VerifyHostname(raddr[:strings.LastIndex(raddr, \":\")]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// Send new client preface to match the one parsed in req.\n\tif _, err := io.WriteString(rawServerTLS, http2.ClientPreface); err != nil {\n\t\treturn nil, err\n\t}\n\tserverTLSReader := bufio.NewReader(rawServerTLS)\n\tcToS := http2.NewFramer(rawServerTLS, r.ClientReader)\n\tsToC := http2.NewFramer(r.ClientWriter, serverTLSReader)\n\terrSToC := make(chan error)\n\terrCToS := make(chan error)\n\tgo func() {\n\t\tfor {\n\t\t\tif err := proxyFrame(sToC); err != nil {\n\t\t\t\terrSToC <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\tgo func() {\n\t\tfor {\n\t\t\tif err := proxyFrame(cToS); err != nil {\n\t\t\t\terrCToS <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase err := <-errSToC:\n\t\t\tif !errors.Is(err, io.EOF) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase err := <-errCToS:\n\t\t\tif !errors.Is(err, io.EOF) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc dial(network, addr string) (c net.Conn, err error) {\n\taddri, err := net.ResolveTCPAddr(network, addr)\n\tif err != nil {\n\t\treturn\n\t}\n\tc, err = net.DialTCP(network, nil, addri)\n\treturn\n}\n\n// proxyFrame reads a single frame from the Framer and, when successful, writes\n// a ~identical one back to the Framer.\nfunc proxyFrame(fr *http2.Framer) error {\n\tf, err := fr.ReadFrame()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch f.Header().Type {\n\tcase http2.FrameData:\n\t\ttf, ok := f.(*http2.DataFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\tterr := fr.WriteData(tf.StreamID, tf.StreamEnded(), tf.Data())\n\t\tif terr == nil && tf.StreamEnded() {\n\t\t\tterr = io.EOF\n\t\t}\n\t\treturn terr\n\tcase http2.FrameHeaders:\n\t\ttf, ok := f.(*http2.HeadersFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\tterr := fr.WriteHeaders(http2.HeadersFrameParam{\n\t\t\tStreamID:      tf.StreamID,\n\t\t\tBlockFragment: tf.HeaderBlockFragment(),\n\t\t\tEndStream:     tf.StreamEnded(),\n\t\t\tEndHeaders:    tf.HeadersEnded(),\n\t\t\tPadLength:     0,\n\t\t\tPriority:      tf.Priority,\n\t\t})\n\t\tif terr == nil && tf.StreamEnded() {\n\t\t\tterr = io.EOF\n\t\t}\n\t\treturn terr\n\tcase http2.FrameContinuation:\n\t\ttf, ok := f.(*http2.ContinuationFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WriteContinuation(tf.StreamID, tf.HeadersEnded(), tf.HeaderBlockFragment())\n\tcase http2.FrameGoAway:\n\t\ttf, ok := f.(*http2.GoAwayFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WriteGoAway(tf.StreamID, tf.ErrCode, tf.DebugData())\n\tcase http2.FramePing:\n\t\ttf, ok := f.(*http2.PingFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WritePing(tf.IsAck(), tf.Data)\n\tcase http2.FrameRSTStream:\n\t\ttf, ok := f.(*http2.RSTStreamFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WriteRSTStream(tf.StreamID, tf.ErrCode)\n\tcase http2.FrameSettings:\n\t\ttf, ok := f.(*http2.SettingsFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\tif tf.IsAck() {\n\t\t\treturn fr.WriteSettingsAck()\n\t\t}\n\t\tvar settings []http2.Setting\n\t\t// NOTE: If we want to parse headers, need to handle\n\t\t// settings where s.ID == http2.SettingHeaderTableSize and\n\t\t// accordingly update the Framer options.\n\t\tfor i := 0; i < tf.NumSettings(); i++ {\n\t\t\tsettings = append(settings, tf.Setting(i))\n\t\t}\n\t\treturn fr.WriteSettings(settings...)\n\tcase http2.FrameWindowUpdate:\n\t\ttf, ok := f.(*http2.WindowUpdateFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WriteWindowUpdate(tf.StreamID, tf.Increment)\n\tcase http2.FramePriority:\n\t\ttf, ok := f.(*http2.PriorityFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WritePriority(tf.StreamID, tf.PriorityParam)\n\tcase http2.FramePushPromise:\n\t\ttf, ok := f.(*http2.PushPromiseFrame)\n\t\tif !ok {\n\t\t\treturn ErrInvalidH2Frame\n\t\t}\n\t\treturn fr.WritePushPromise(http2.PushPromiseParam{\n\t\t\tStreamID:      tf.StreamID,\n\t\t\tPromiseID:     tf.PromiseID,\n\t\t\tBlockFragment: tf.HeaderBlockFragment(),\n\t\t\tEndHeaders:    tf.HeadersEnded(),\n\t\t\tPadLength:     0,\n\t\t})\n\tdefault:\n\t\treturn errors.New(\"Unsupported frame: \" + string(f.Header().Type))\n\t}\n}\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 2.6142578125,
          "content": "package goproxy\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync/atomic\"\n)\n\nfunc (proxy *ProxyHttpServer) handleHttp(w http.ResponseWriter, r *http.Request) {\n\tctx := &ProxyCtx{Req: r, Session: atomic.AddInt64(&proxy.sess, 1), Proxy: proxy}\n\n\tvar err error\n\tctx.Logf(\"Got request %v %v %v %v\", r.URL.Path, r.Host, r.Method, r.URL.String())\n\tif !r.URL.IsAbs() {\n\t\tproxy.NonproxyHandler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\tr, resp := proxy.filterRequest(r, ctx)\n\n\tif resp == nil {\n\t\tif isWebSocketRequest(r) {\n\t\t\tctx.Logf(\"Request looks like websocket upgrade.\")\n\t\t\tproxy.serveWebsocket(ctx, w, r)\n\t\t}\n\n\t\tif !proxy.KeepHeader {\n\t\t\tRemoveProxyHeaders(ctx, r)\n\t\t}\n\t\tresp, err = ctx.RoundTrip(r)\n\t\tif err != nil {\n\t\t\tctx.Error = err\n\t\t\tresp = proxy.filterResponse(nil, ctx)\n\t\t}\n\t\tif resp != nil {\n\t\t\tctx.Logf(\"Received response %v\", resp.Status)\n\t\t}\n\t}\n\n\tvar origBody io.ReadCloser\n\n\tif resp != nil {\n\t\torigBody = resp.Body\n\t\tdefer origBody.Close()\n\t}\n\n\tresp = proxy.filterResponse(resp, ctx)\n\n\tif resp == nil {\n\t\tvar errorString string\n\t\tif ctx.Error != nil {\n\t\t\terrorString = \"error read response \" + r.URL.Host + \" : \" + ctx.Error.Error()\n\t\t\tctx.Logf(errorString)\n\t\t\thttp.Error(w, ctx.Error.Error(), http.StatusInternalServerError)\n\t\t} else {\n\t\t\terrorString = \"error read response \" + r.URL.Host\n\t\t\tctx.Logf(errorString)\n\t\t\thttp.Error(w, errorString, http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\tctx.Logf(\"Copying response to client %v [%d]\", resp.Status, resp.StatusCode)\n\t// http.ResponseWriter will take care of filling the correct response length\n\t// Setting it now, might impose wrong value, contradicting the actual new\n\t// body the user returned.\n\t// We keep the original body to remove the header only if things changed.\n\t// This will prevent problems with HEAD requests where there's no body, yet,\n\t// the Content-Length header should be set.\n\tif origBody != resp.Body {\n\t\tresp.Header.Del(\"Content-Length\")\n\t}\n\tcopyHeaders(w.Header(), resp.Header, proxy.KeepDestinationHeaders)\n\tw.WriteHeader(resp.StatusCode)\n\tvar copyWriter io.Writer = w\n\t// Content-Type header may also contain charset definition, so here we need to check the prefix.\n\t// Transfer-Encoding can be a list of comma separated values, so we use Contains() for it.\n\tif strings.HasPrefix(w.Header().Get(\"content-type\"), \"text/event-stream\") ||\n\t\tstrings.Contains(w.Header().Get(\"transfer-encoding\"), \"chunked\") {\n\t\t// server-side events, flush the buffered data to the client.\n\t\tcopyWriter = &flushWriter{w: w}\n\t}\n\n\tnr, err := io.Copy(copyWriter, resp.Body)\n\tif err := resp.Body.Close(); err != nil {\n\t\tctx.Warnf(\"Can't close response body %v\", err)\n\t}\n\tctx.Logf(\"Copied %v bytes to client error=%v\", nr, err)\n}\n"
        },
        {
          "name": "https.go",
          "type": "blob",
          "size": 19.01171875,
          "content": "package goproxy\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/elazarl/goproxy/internal/http1parser\"\n\t\"github.com/elazarl/goproxy/internal/signer\"\n)\n\ntype ConnectActionLiteral int\n\nconst (\n\tConnectAccept = iota\n\tConnectReject\n\tConnectMitm\n\tConnectHijack\n\tConnectHTTPMitm\n\tConnectProxyAuthHijack\n)\n\nvar (\n\tOkConnect       = &ConnectAction{Action: ConnectAccept, TLSConfig: TLSConfigFromCA(&GoproxyCa)}\n\tMitmConnect     = &ConnectAction{Action: ConnectMitm, TLSConfig: TLSConfigFromCA(&GoproxyCa)}\n\tHTTPMitmConnect = &ConnectAction{Action: ConnectHTTPMitm, TLSConfig: TLSConfigFromCA(&GoproxyCa)}\n\tRejectConnect   = &ConnectAction{Action: ConnectReject, TLSConfig: TLSConfigFromCA(&GoproxyCa)}\n)\n\nvar _errorRespMaxLength int64 = 500\n\n// ConnectAction enables the caller to override the standard connect flow.\n// When Action is ConnectHijack, it is up to the implementer to send the\n// HTTP 200, or any other valid http response back to the client from within the\n// Hijack func.\ntype ConnectAction struct {\n\tAction    ConnectActionLiteral\n\tHijack    func(req *http.Request, client net.Conn, ctx *ProxyCtx)\n\tTLSConfig func(host string, ctx *ProxyCtx) (*tls.Config, error)\n}\n\nfunc stripPort(s string) string {\n\tvar ix int\n\tif strings.Contains(s, \"[\") && strings.Contains(s, \"]\") {\n\t\t// ipv6 address example: [2606:4700:4700::1111]:443\n\t\t// strip '[' and ']'\n\t\ts = strings.ReplaceAll(s, \"[\", \"\")\n\t\ts = strings.ReplaceAll(s, \"]\", \"\")\n\n\t\tix = strings.LastIndexAny(s, \":\")\n\t\tif ix == -1 {\n\t\t\treturn s\n\t\t}\n\t} else {\n\t\t// ipv4\n\t\tix = strings.IndexRune(s, ':')\n\t\tif ix == -1 {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn s[:ix]\n}\n\nfunc (proxy *ProxyHttpServer) dial(ctx context.Context, network, addr string) (c net.Conn, err error) {\n\tif proxy.Tr.DialContext != nil {\n\t\treturn proxy.Tr.DialContext(ctx, network, addr)\n\t}\n\treturn net.Dial(network, addr)\n}\n\nfunc (proxy *ProxyHttpServer) connectDial(ctx *ProxyCtx, network, addr string) (c net.Conn, err error) {\n\tif proxy.ConnectDialWithReq == nil && proxy.ConnectDial == nil {\n\t\treturn proxy.dial(ctx.Req.Context(), network, addr)\n\t}\n\n\tif proxy.ConnectDialWithReq != nil {\n\t\treturn proxy.ConnectDialWithReq(ctx.Req, network, addr)\n\t}\n\n\treturn proxy.ConnectDial(network, addr)\n}\n\ntype halfClosable interface {\n\tnet.Conn\n\tCloseWrite() error\n\tCloseRead() error\n}\n\nvar _ halfClosable = (*net.TCPConn)(nil)\n\nfunc (proxy *ProxyHttpServer) handleHttps(w http.ResponseWriter, r *http.Request) {\n\tctx := &ProxyCtx{Req: r, Session: atomic.AddInt64(&proxy.sess, 1), Proxy: proxy, certStore: proxy.CertStore}\n\n\thij, ok := w.(http.Hijacker)\n\tif !ok {\n\t\tpanic(\"httpserver does not support hijacking\")\n\t}\n\n\tproxyClient, _, e := hij.Hijack()\n\tif e != nil {\n\t\tpanic(\"Cannot hijack connection \" + e.Error())\n\t}\n\n\tctx.Logf(\"Running %d CONNECT handlers\", len(proxy.httpsHandlers))\n\ttodo, host := OkConnect, r.URL.Host\n\tfor i, h := range proxy.httpsHandlers {\n\t\tnewtodo, newhost := h.HandleConnect(host, ctx)\n\n\t\t// If found a result, break the loop immediately\n\t\tif newtodo != nil {\n\t\t\ttodo, host = newtodo, newhost\n\t\t\tctx.Logf(\"on %dth handler: %v %s\", i, todo, host)\n\t\t\tbreak\n\t\t}\n\t}\n\tswitch todo.Action {\n\tcase ConnectAccept:\n\t\tif !hasPort.MatchString(host) {\n\t\t\thost += \":80\"\n\t\t}\n\t\ttargetSiteCon, err := proxy.connectDial(ctx, \"tcp\", host)\n\t\tif err != nil {\n\t\t\tctx.Warnf(\"Error dialing to %s: %s\", host, err.Error())\n\t\t\thttpError(proxyClient, ctx, err)\n\t\t\treturn\n\t\t}\n\t\tctx.Logf(\"Accepting CONNECT to %s\", host)\n\t\t_, _ = proxyClient.Write([]byte(\"HTTP/1.0 200 Connection established\\r\\n\\r\\n\"))\n\n\t\ttargetTCP, targetOK := targetSiteCon.(halfClosable)\n\t\tproxyClientTCP, clientOK := proxyClient.(halfClosable)\n\t\tif targetOK && clientOK {\n\t\t\tgo func() {\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\twg.Add(2)\n\t\t\t\tgo copyAndClose(ctx, targetTCP, proxyClientTCP, &wg)\n\t\t\t\tgo copyAndClose(ctx, proxyClientTCP, targetTCP, &wg)\n\t\t\t\twg.Wait()\n\t\t\t\t// Make sure to close the underlying TCP socket.\n\t\t\t\t// CloseRead() and CloseWrite() keep it open until its timeout,\n\t\t\t\t// causing error when there are thousands of requests.\n\t\t\t\tproxyClientTCP.Close()\n\t\t\t\ttargetTCP.Close()\n\t\t\t}()\n\t\t} else {\n\t\t\t// There is a race with the runtime here. In the case where the\n\t\t\t// connection to the target site times out, we cannot control which\n\t\t\t// io.Copy loop will receive the timeout signal first. This means\n\t\t\t// that in some cases the error passed to the ConnErrorHandler will\n\t\t\t// be the timeout error, and in other cases it will be an error raised\n\t\t\t// by the use of a closed network connection.\n\t\t\t//\n\t\t\t// 2020/05/28 23:42:17 [001] WARN: Error copying to client: read tcp 127.0.0.1:33742->127.0.0.1:34763: i/o timeout\n\t\t\t// 2020/05/28 23:42:17 [001] WARN: Error copying to client: read tcp 127.0.0.1:45145->127.0.0.1:60494: use of closed\n\t\t\t//                                                          network connection\n\t\t\t//\n\t\t\t// It's also not possible to synchronize these connection closures due to\n\t\t\t// TCP connections which are half-closed. When this happens, only the one\n\t\t\t// side of the connection breaks out of its io.Copy loop. The other side\n\t\t\t// of the connection remains open until it either times out or is reset by\n\t\t\t// the client.\n\t\t\tgo func() {\n\t\t\t\terr := copyOrWarn(ctx, targetSiteCon, proxyClient)\n\t\t\t\tif err != nil && proxy.ConnectionErrHandler != nil {\n\t\t\t\t\tproxy.ConnectionErrHandler(proxyClient, ctx, err)\n\t\t\t\t}\n\t\t\t\t_ = targetSiteCon.Close()\n\t\t\t}()\n\n\t\t\tgo func() {\n\t\t\t\t_ = copyOrWarn(ctx, proxyClient, targetSiteCon)\n\t\t\t\t_ = proxyClient.Close()\n\t\t\t}()\n\t\t}\n\n\tcase ConnectHijack:\n\t\ttodo.Hijack(r, proxyClient, ctx)\n\tcase ConnectHTTPMitm:\n\t\t_, _ = proxyClient.Write([]byte(\"HTTP/1.0 200 OK\\r\\n\\r\\n\"))\n\t\tctx.Logf(\"Assuming CONNECT is plain HTTP tunneling, mitm proxying it\")\n\n\t\tvar targetSiteCon net.Conn\n\t\tvar remote *bufio.Reader\n\n\t\tclient := http1parser.NewRequestReader(proxy.PreventCanonicalization, proxyClient)\n\t\tfor !client.IsEOF() {\n\t\t\treq, err := client.ReadRequest()\n\t\t\tif err != nil && !errors.Is(err, io.EOF) {\n\t\t\t\tctx.Warnf(\"cannot read request of MITM HTTP client: %+#v\", err)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Take the original value before filtering the request\n\t\t\tcloseConn := req.Close\n\n\t\t\t// since we're converting the request, need to carry over the\n\t\t\t// original connecting IP as well\n\t\t\treq.RemoteAddr = r.RemoteAddr\n\t\t\tctx.Logf(\"req %v\", r.Host)\n\t\t\tctx.Req = req\n\n\t\t\treq, resp := proxy.filterRequest(req, ctx)\n\t\t\tif resp == nil {\n\t\t\t\t// Establish a connection with the remote server only if the proxy\n\t\t\t\t// doesn't produce a response\n\t\t\t\tif targetSiteCon == nil {\n\t\t\t\t\ttargetSiteCon, err = proxy.connectDial(ctx, \"tcp\", host)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tctx.Warnf(\"Error dialing to %s: %s\", host, err.Error())\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tremote = bufio.NewReader(targetSiteCon)\n\t\t\t\t}\n\n\t\t\t\tif err := req.Write(targetSiteCon); err != nil {\n\t\t\t\t\thttpError(proxyClient, ctx, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresp, err = func() (*http.Response, error) {\n\t\t\t\t\tdefer req.Body.Close()\n\t\t\t\t\treturn http.ReadResponse(remote, req)\n\t\t\t\t}()\n\t\t\t\tif err != nil {\n\t\t\t\t\thttpError(proxyClient, ctx, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tresp = proxy.filterResponse(resp, ctx)\n\t\t\terr = resp.Write(proxyClient)\n\t\t\t_ = resp.Body.Close()\n\t\t\tif err != nil {\n\t\t\t\thttpError(proxyClient, ctx, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif closeConn {\n\t\t\t\tctx.Logf(\"Non-persistent connection; closing\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\tcase ConnectMitm:\n\t\t_, _ = proxyClient.Write([]byte(\"HTTP/1.0 200 OK\\r\\n\\r\\n\"))\n\t\tctx.Logf(\"Assuming CONNECT is TLS, mitm proxying it\")\n\t\t// this goes in a separate goroutine, so that the net/http server won't think we're\n\t\t// still handling the request even after hijacking the connection. Those HTTP CONNECT\n\t\t// request can take forever, and the server will be stuck when \"closed\".\n\t\t// TODO: Allow Server.Close() mechanism to shut down this connection as nicely as possible\n\t\ttlsConfig := defaultTLSConfig\n\t\tif todo.TLSConfig != nil {\n\t\t\tvar err error\n\t\t\ttlsConfig, err = todo.TLSConfig(host, ctx)\n\t\t\tif err != nil {\n\t\t\t\thttpError(proxyClient, ctx, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgo func() {\n\t\t\t// TODO: cache connections to the remote website\n\t\t\trawClientTls := tls.Server(proxyClient, tlsConfig)\n\t\t\tdefer rawClientTls.Close()\n\t\t\tif err := rawClientTls.Handshake(); err != nil {\n\t\t\t\tctx.Warnf(\"Cannot handshake client %v %v\", r.Host, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tclientTlsReader := http1parser.NewRequestReader(proxy.PreventCanonicalization, rawClientTls)\n\t\t\tfor !clientTlsReader.IsEOF() {\n\t\t\t\treq, err := clientTlsReader.ReadRequest()\n\t\t\t\tctx := &ProxyCtx{\n\t\t\t\t\tReq:          req,\n\t\t\t\t\tSession:      atomic.AddInt64(&proxy.sess, 1),\n\t\t\t\t\tProxy:        proxy,\n\t\t\t\t\tUserData:     ctx.UserData,\n\t\t\t\t\tRoundTripper: ctx.RoundTripper,\n\t\t\t\t}\n\t\t\t\tif err != nil && !errors.Is(err, io.EOF) {\n\t\t\t\t\tctx.Warnf(\"Cannot read TLS request from mitm'd client %v %v\", r.Host, err)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// since we're converting the request, need to carry over the\n\t\t\t\t// original connecting IP as well\n\t\t\t\treq.RemoteAddr = r.RemoteAddr\n\t\t\t\tctx.Logf(\"req %v\", r.Host)\n\n\t\t\t\tif !strings.HasPrefix(req.URL.String(), \"https://\") {\n\t\t\t\t\treq.URL, err = url.Parse(\"https://\" + r.Host + req.URL.String())\n\t\t\t\t}\n\n\t\t\t\t// Take the original value before filtering the request\n\t\t\t\tcloseConn := req.Close\n\n\t\t\t\t// Bug fix which goproxy fails to provide request\n\t\t\t\t// information URL in the context when does HTTPS MITM\n\t\t\t\tctx.Req = req\n\n\t\t\t\treq, resp := proxy.filterRequest(req, ctx)\n\t\t\t\tif resp == nil {\n\t\t\t\t\tif req.Method == \"PRI\" {\n\t\t\t\t\t\t// Handle HTTP/2 connections.\n\n\t\t\t\t\t\t// NOTE: As of 1.22, golang's http module will not recognize or\n\t\t\t\t\t\t// parse the HTTP Body for PRI requests. This leaves the body of\n\t\t\t\t\t\t// the http2.ClientPreface (\"SM\\r\\n\\r\\n\") on the wire which we need\n\t\t\t\t\t\t// to clear before setting up the connection.\n\t\t\t\t\t\treader := clientTlsReader.Reader()\n\t\t\t\t\t\t_, err := reader.Discard(6)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"Failed to process HTTP2 client preface: %v\", err)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !proxy.AllowHTTP2 {\n\t\t\t\t\t\t\tctx.Warnf(\"HTTP2 connection failed: disallowed\")\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttr := H2Transport{reader, rawClientTls, tlsConfig.Clone(), host}\n\t\t\t\t\t\tif _, err := tr.RoundTrip(req); err != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"HTTP2 connection failed: %v\", err)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.Logf(\"Exiting on EOF\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif isWebSocketRequest(req) {\n\t\t\t\t\t\tctx.Logf(\"Request looks like websocket upgrade.\")\n\t\t\t\t\t\tif req.URL.Scheme == \"http\" {\n\t\t\t\t\t\t\tctx.Logf(\"Enforced HTTP websocket forwarding over TLS\")\n\t\t\t\t\t\t\tproxy.serveWebsocketHttpOverTLS(ctx, w, req, rawClientTls)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tproxy.serveWebsocketTLS(ctx, w, req, tlsConfig, rawClientTls)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tif req.URL != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"Illegal URL %s\", \"https://\"+r.Host+req.URL.Path)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.Warnf(\"Illegal URL %s\", \"https://\"+r.Host)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif !proxy.KeepHeader {\n\t\t\t\t\t\tRemoveProxyHeaders(ctx, req)\n\t\t\t\t\t}\n\t\t\t\t\tresp, err = func() (*http.Response, error) {\n\t\t\t\t\t\t// explicitly discard request body to avoid data races in certain RoundTripper implementations\n\t\t\t\t\t\t// see https://github.com/golang/go/issues/61596#issuecomment-1652345131\n\t\t\t\t\t\tdefer req.Body.Close()\n\t\t\t\t\t\treturn ctx.RoundTrip(req)\n\t\t\t\t\t}()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tctx.Warnf(\"Cannot read TLS response from mitm'd server %v\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tctx.Logf(\"resp %v\", resp.Status)\n\t\t\t\t}\n\t\t\t\tresp = proxy.filterResponse(resp, ctx)\n\n\t\t\t\t// Run defer inside a custom function to prevent response body memory leak\n\t\t\t\tif ok := func() bool {\n\t\t\t\t\tdefer resp.Body.Close()\n\n\t\t\t\t\ttext := resp.Status\n\t\t\t\t\tstatusCode := strconv.Itoa(resp.StatusCode) + \" \"\n\t\t\t\t\ttext = strings.TrimPrefix(text, statusCode)\n\t\t\t\t\t// always use 1.1 to support chunked encoding\n\t\t\t\t\tif _, err := io.WriteString(rawClientTls, \"HTTP/1.1\"+\" \"+statusCode+text+\"\\r\\n\"); err != nil {\n\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS response HTTP status from mitm'd client: %v\", err)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tif resp.Request.Method == http.MethodHead {\n\t\t\t\t\t\t// don't change Content-Length for HEAD request\n\t\t\t\t\t} else if (resp.StatusCode >= 100 && resp.StatusCode < 200) ||\n\t\t\t\t\t\tresp.StatusCode == http.StatusNoContent {\n\t\t\t\t\t\t// RFC7230: A server MUST NOT send a Content-Length header field in any response\n\t\t\t\t\t\t// with a status code of 1xx (Informational) or 204 (No Content)\n\t\t\t\t\t\tresp.Header.Del(\"Content-Length\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Since we don't know the length of resp, return chunked encoded response\n\t\t\t\t\t\t// TODO: use a more reasonable scheme\n\t\t\t\t\t\tresp.Header.Del(\"Content-Length\")\n\t\t\t\t\t\tresp.Header.Set(\"Transfer-Encoding\", \"chunked\")\n\t\t\t\t\t}\n\t\t\t\t\t// Force connection close otherwise chrome will keep CONNECT tunnel open forever\n\t\t\t\t\tresp.Header.Set(\"Connection\", \"close\")\n\t\t\t\t\tif err := resp.Header.Write(rawClientTls); err != nil {\n\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS response header from mitm'd client: %v\", err)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tif _, err = io.WriteString(rawClientTls, \"\\r\\n\"); err != nil {\n\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS response header end from mitm'd client: %v\", err)\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\tif resp.Request.Method == http.MethodHead ||\n\t\t\t\t\t\t(resp.StatusCode >= 100 && resp.StatusCode < 200) ||\n\t\t\t\t\t\tresp.StatusCode == http.StatusNoContent ||\n\t\t\t\t\t\tresp.StatusCode == http.StatusNotModified {\n\t\t\t\t\t\t// Don't write out a response body, when it's not allowed\n\t\t\t\t\t\t// in RFC7230\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunked := newChunkedWriter(rawClientTls)\n\t\t\t\t\t\tif _, err := io.Copy(chunked, resp.Body); err != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS response body from mitm'd client: %v\", err)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := chunked.Close(); err != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS chunked EOF from mitm'd client: %v\", err)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif _, err = io.WriteString(rawClientTls, \"\\r\\n\"); err != nil {\n\t\t\t\t\t\t\tctx.Warnf(\"Cannot write TLS response chunked trailer from mitm'd client: %v\", err)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t}(); !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif closeConn {\n\t\t\t\t\tctx.Logf(\"Non-persistent connection; closing\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.Logf(\"Exiting on EOF\")\n\t\t}()\n\tcase ConnectProxyAuthHijack:\n\t\t_, _ = proxyClient.Write([]byte(\"HTTP/1.1 407 Proxy Authentication Required\\r\\n\"))\n\t\ttodo.Hijack(r, proxyClient, ctx)\n\tcase ConnectReject:\n\t\tif ctx.Resp != nil {\n\t\t\tif err := ctx.Resp.Write(proxyClient); err != nil {\n\t\t\t\tctx.Warnf(\"Cannot write response that reject http CONNECT: %v\", err)\n\t\t\t}\n\t\t}\n\t\t_ = proxyClient.Close()\n\t}\n}\n\nfunc httpError(w io.WriteCloser, ctx *ProxyCtx, err error) {\n\tif ctx.Proxy.ConnectionErrHandler != nil {\n\t\tctx.Proxy.ConnectionErrHandler(w, ctx, err)\n\t} else {\n\t\terrorMessage := err.Error()\n\t\terrStr := fmt.Sprintf(\n\t\t\t\"HTTP/1.1 502 Bad Gateway\\r\\nContent-Type: text/plain\\r\\nContent-Length: %d\\r\\n\\r\\n%s\",\n\t\t\tlen(errorMessage),\n\t\t\terrorMessage,\n\t\t)\n\t\tif _, err := io.WriteString(w, errStr); err != nil {\n\t\t\tctx.Warnf(\"Error responding to client: %s\", err)\n\t\t}\n\t}\n\tif err := w.Close(); err != nil {\n\t\tctx.Warnf(\"Error closing client connection: %s\", err)\n\t}\n}\n\nfunc copyOrWarn(ctx *ProxyCtx, dst io.Writer, src io.Reader) error {\n\t_, err := io.Copy(dst, src)\n\tif err != nil && errors.Is(err, net.ErrClosed) {\n\t\t// Discard closed connection errors\n\t\terr = nil\n\t} else if err != nil {\n\t\tctx.Warnf(\"Error copying to client: %s\", err)\n\t}\n\treturn err\n}\n\nfunc copyAndClose(ctx *ProxyCtx, dst, src halfClosable, wg *sync.WaitGroup) {\n\t_, err := io.Copy(dst, src)\n\tif err != nil && !errors.Is(err, net.ErrClosed) {\n\t\tctx.Warnf(\"Error copying to client: %s\", err.Error())\n\t}\n\n\t_ = dst.CloseWrite()\n\t_ = src.CloseRead()\n\twg.Done()\n}\n\nfunc dialerFromEnv(proxy *ProxyHttpServer) func(network, addr string) (net.Conn, error) {\n\thttpsProxy := os.Getenv(\"HTTPS_PROXY\")\n\tif httpsProxy == \"\" {\n\t\thttpsProxy = os.Getenv(\"https_proxy\")\n\t}\n\tif httpsProxy == \"\" {\n\t\treturn nil\n\t}\n\treturn proxy.NewConnectDialToProxy(httpsProxy)\n}\n\nfunc (proxy *ProxyHttpServer) NewConnectDialToProxy(httpsProxy string) func(network, addr string) (net.Conn, error) {\n\treturn proxy.NewConnectDialToProxyWithHandler(httpsProxy, nil)\n}\n\nfunc (proxy *ProxyHttpServer) NewConnectDialToProxyWithHandler(\n\thttpsProxy string,\n\tconnectReqHandler func(req *http.Request),\n) func(network, addr string) (net.Conn, error) {\n\tu, err := url.Parse(httpsProxy)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif u.Scheme == \"\" || u.Scheme == \"http\" {\n\t\tif !strings.ContainsRune(u.Host, ':') {\n\t\t\tu.Host += \":80\"\n\t\t}\n\t\treturn func(network, addr string) (net.Conn, error) {\n\t\t\tconnectReq := &http.Request{\n\t\t\t\tMethod: http.MethodConnect,\n\t\t\t\tURL:    &url.URL{Opaque: addr},\n\t\t\t\tHost:   addr,\n\t\t\t\tHeader: make(http.Header),\n\t\t\t}\n\t\t\tif connectReqHandler != nil {\n\t\t\t\tconnectReqHandler(connectReq)\n\t\t\t}\n\t\t\tc, err := proxy.dial(context.Background(), network, u.Host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t_ = connectReq.Write(c)\n\t\t\t// Read response.\n\t\t\t// Okay to use and discard buffered reader here, because\n\t\t\t// TLS server will not speak until spoken to.\n\t\t\tbr := bufio.NewReader(c)\n\t\t\tresp, err := http.ReadResponse(br, connectReq)\n\t\t\tif err != nil {\n\t\t\t\t_ = c.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\tresp, err := io.ReadAll(io.LimitReader(resp.Body, _errorRespMaxLength))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t_ = c.Close()\n\t\t\t\treturn nil, errors.New(\"proxy refused connection\" + string(resp))\n\t\t\t}\n\t\t\treturn c, nil\n\t\t}\n\t}\n\tif u.Scheme == \"https\" || u.Scheme == \"wss\" {\n\t\tif !strings.ContainsRune(u.Host, ':') {\n\t\t\tu.Host += \":443\"\n\t\t}\n\t\treturn func(network, addr string) (net.Conn, error) {\n\t\t\tc, err := proxy.dial(context.Background(), network, u.Host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tc = tls.Client(c, proxy.Tr.TLSClientConfig)\n\t\t\tconnectReq := &http.Request{\n\t\t\t\tMethod: http.MethodConnect,\n\t\t\t\tURL:    &url.URL{Opaque: addr},\n\t\t\t\tHost:   addr,\n\t\t\t\tHeader: make(http.Header),\n\t\t\t}\n\t\t\tif connectReqHandler != nil {\n\t\t\t\tconnectReqHandler(connectReq)\n\t\t\t}\n\t\t\t_ = connectReq.Write(c)\n\t\t\t// Read response.\n\t\t\t// Okay to use and discard buffered reader here, because\n\t\t\t// TLS server will not speak until spoken to.\n\t\t\tbr := bufio.NewReader(c)\n\t\t\tresp, err := http.ReadResponse(br, connectReq)\n\t\t\tif err != nil {\n\t\t\t\t_ = c.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\tbody, err := io.ReadAll(io.LimitReader(resp.Body, _errorRespMaxLength))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t_ = c.Close()\n\t\t\t\treturn nil, errors.New(\"proxy refused connection\" + string(body))\n\t\t\t}\n\t\t\treturn c, nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc TLSConfigFromCA(ca *tls.Certificate) func(host string, ctx *ProxyCtx) (*tls.Config, error) {\n\treturn func(host string, ctx *ProxyCtx) (*tls.Config, error) {\n\t\tvar err error\n\t\tvar cert *tls.Certificate\n\n\t\thostname := stripPort(host)\n\t\tconfig := defaultTLSConfig.Clone()\n\t\tctx.Logf(\"signing for %s\", stripPort(host))\n\n\t\tgenCert := func() (*tls.Certificate, error) {\n\t\t\treturn signer.SignHost(*ca, []string{hostname})\n\t\t}\n\t\tif ctx.certStore != nil {\n\t\t\tcert, err = ctx.certStore.Fetch(hostname, genCert)\n\t\t} else {\n\t\t\tcert, err = genCert()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tctx.Warnf(\"Cannot sign host certificate with provided CA: %s\", err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tconfig.Certificates = append(config.Certificates, *cert)\n\t\treturn config, nil\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "key.pem",
          "type": "blob",
          "size": 3.1669921875,
          "content": "-----BEGIN RSA PRIVATE KEY-----\n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\n-----END RSA PRIVATE KEY-----\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.07421875,
          "content": "package goproxy\n\ntype Logger interface {\n\tPrintf(format string, v ...any)\n}\n"
        },
        {
          "name": "proxy.go",
          "type": "blob",
          "size": 5.5673828125,
          "content": "package goproxy\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"regexp\"\n)\n\n// The basic proxy type. Implements http.Handler.\ntype ProxyHttpServer struct {\n\t// session variable must be aligned in i386\n\t// see http://golang.org/src/pkg/sync/atomic/doc.go#L41\n\tsess int64\n\t// KeepDestinationHeaders indicates the proxy should retain any headers present in the http.Response before proxying\n\tKeepDestinationHeaders bool\n\t// setting Verbose to true will log information on each request sent to the proxy\n\tVerbose         bool\n\tLogger          Logger\n\tNonproxyHandler http.Handler\n\treqHandlers     []ReqHandler\n\trespHandlers    []RespHandler\n\thttpsHandlers   []HttpsHandler\n\tTr              *http.Transport\n\t// ConnectionErrHandler will be invoked to return a custom response\n\t// to clients (written using conn parameter), when goproxy fails to connect\n\t// to a target proxy.\n\t// The error is passed as function parameter and not inside the proxy\n\t// context, to avoid race conditions.\n\tConnectionErrHandler func(conn io.Writer, ctx *ProxyCtx, err error)\n\t// ConnectDial will be used to create TCP connections for CONNECT requests\n\t// if nil Tr.Dial will be used\n\tConnectDial        func(network string, addr string) (net.Conn, error)\n\tConnectDialWithReq func(req *http.Request, network string, addr string) (net.Conn, error)\n\tCertStore          CertStorage\n\tKeepHeader         bool\n\tAllowHTTP2         bool\n\t// When PreventCanonicalization is true, the header names present in\n\t// the request sent through the proxy are directly passed to the destination server,\n\t// instead of following the HTTP RFC for their canonicalization.\n\t// This is useful when the header name isn't treated as a case-insensitive\n\t// value by the target server, because they don't follow the specs.\n\tPreventCanonicalization bool\n\t// KeepAcceptEncoding, if true, prevents the proxy from dropping\n\t// Accept-Encoding headers from the client.\n\t//\n\t// Note that the outbound http.Transport may still choose to add\n\t// Accept-Encoding: gzip if the client did not explicitly send an\n\t// Accept-Encoding header. To disable this behavior, set\n\t// Tr.DisableCompression to true.\n\tKeepAcceptEncoding bool\n}\n\nvar hasPort = regexp.MustCompile(`:\\d+$`)\n\nfunc copyHeaders(dst, src http.Header, keepDestHeaders bool) {\n\tif !keepDestHeaders {\n\t\tfor k := range dst {\n\t\t\tdst.Del(k)\n\t\t}\n\t}\n\tfor k, vs := range src {\n\t\t// direct assignment to avoid canonicalization\n\t\tdst[k] = append([]string(nil), vs...)\n\t}\n}\n\nfunc (proxy *ProxyHttpServer) filterRequest(r *http.Request, ctx *ProxyCtx) (req *http.Request, resp *http.Response) {\n\treq = r\n\tfor _, h := range proxy.reqHandlers {\n\t\treq, resp = h.Handle(req, ctx)\n\t\t// non-nil resp means the handler decided to skip sending the request\n\t\t// and return canned response instead.\n\t\tif resp != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (proxy *ProxyHttpServer) filterResponse(respOrig *http.Response, ctx *ProxyCtx) (resp *http.Response) {\n\tresp = respOrig\n\tfor _, h := range proxy.respHandlers {\n\t\tctx.Resp = resp\n\t\tresp = h.Handle(resp, ctx)\n\t}\n\treturn\n}\n\n// RemoveProxyHeaders removes all proxy headers which should not propagate to the next hop.\nfunc RemoveProxyHeaders(ctx *ProxyCtx, r *http.Request) {\n\tr.RequestURI = \"\" // this must be reset when serving a request with the client\n\tctx.Logf(\"Sending request %v %v\", r.Method, r.URL.String())\n\tif !ctx.Proxy.KeepAcceptEncoding {\n\t\t// If no Accept-Encoding header exists, Transport will add the headers it can accept\n\t\t// and would wrap the response body with the relevant reader.\n\t\tr.Header.Del(\"Accept-Encoding\")\n\t}\n\t// curl can add that, see\n\t// https://jdebp.eu./FGA/web-proxy-connection-header.html\n\tr.Header.Del(\"Proxy-Connection\")\n\tr.Header.Del(\"Proxy-Authenticate\")\n\tr.Header.Del(\"Proxy-Authorization\")\n\t// Connection, Authenticate and Authorization are single hop Header:\n\t// http://www.w3.org/Protocols/rfc2616/rfc2616.txt\n\t// 14.10 Connection\n\t//   The Connection general-header field allows the sender to specify\n\t//   options that are desired for that particular connection and MUST NOT\n\t//   be communicated by proxies over further connections.\n\n\t// When server reads http request it sets req.Close to true if\n\t// \"Connection\" header contains \"close\".\n\t// https://github.com/golang/go/blob/master/src/net/http/request.go#L1080\n\t// Later, transfer.go adds \"Connection: close\" back when req.Close is true\n\t// https://github.com/golang/go/blob/master/src/net/http/transfer.go#L275\n\t// That's why tests that checks \"Connection: close\" removal fail\n\tif r.Header.Get(\"Connection\") == \"close\" {\n\t\tr.Close = false\n\t}\n\tr.Header.Del(\"Connection\")\n}\n\ntype flushWriter struct {\n\tw io.Writer\n}\n\nfunc (fw flushWriter) Write(p []byte) (int, error) {\n\tn, err := fw.w.Write(p)\n\tif f, ok := fw.w.(http.Flusher); ok {\n\t\t// only flush if the Writer implements the Flusher interface.\n\t\tf.Flush()\n\t}\n\n\treturn n, err\n}\n\n// Standard net/http function. Shouldn't be used directly, http.Serve will use it.\nfunc (proxy *ProxyHttpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodConnect {\n\t\tproxy.handleHttps(w, r)\n\t} else {\n\t\tproxy.handleHttp(w, r)\n\t}\n}\n\n// NewProxyHttpServer creates and returns a proxy server, logging to stderr by default.\nfunc NewProxyHttpServer() *ProxyHttpServer {\n\tproxy := ProxyHttpServer{\n\t\tLogger: log.New(os.Stderr, \"\", log.LstdFlags),\n\t\tNonproxyHandler: http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\t\thttp.Error(w, \"This is a proxy server. Does not respond to non-proxy requests.\", http.StatusInternalServerError)\n\t\t}),\n\t\tTr: &http.Transport{TLSClientConfig: tlsClientSkipVerify, Proxy: http.ProxyFromEnvironment},\n\t}\n\tproxy.ConnectDial = dialerFromEnv(&proxy)\n\treturn &proxy\n}\n"
        },
        {
          "name": "proxy_test.go",
          "type": "blob",
          "size": 29.7734375,
          "content": "package goproxy_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/elazarl/goproxy\"\n)\n\nvar (\n\thttps = httptest.NewTLSServer(nil)\n\tsrv   = httptest.NewServer(nil)\n\tfs    = httptest.NewServer(http.FileServer(http.Dir(\".\")))\n)\n\ntype QueryHandler struct{}\n\nfunc (QueryHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tif err := req.ParseForm(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, _ = io.WriteString(w, req.Form.Get(\"result\"))\n}\n\ntype HeadersHandler struct{}\n\n// This handlers returns a body with a string containing all the request headers it received.\nfunc (HeadersHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tvar sb strings.Builder\n\tfor name, values := range req.Header {\n\t\tfor _, value := range values {\n\t\t\tsb.WriteString(name)\n\t\t\tsb.WriteString(\": \")\n\t\t\tsb.WriteString(value)\n\t\t\tsb.WriteString(\";\")\n\t\t}\n\t}\n\t_, _ = io.WriteString(w, sb.String())\n}\n\nfunc init() {\n\thttp.DefaultServeMux.Handle(\"/bobo\", ConstantHanlder(\"bobo\"))\n\thttp.DefaultServeMux.Handle(\"/query\", QueryHandler{})\n\thttp.DefaultServeMux.Handle(\"/headers\", HeadersHandler{})\n}\n\ntype ConstantHanlder string\n\nfunc (h ConstantHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t_, _ = io.WriteString(w, string(h))\n}\n\nfunc get(url string, client *http.Client) ([]byte, error) {\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxt, err := io.ReadAll(resp.Body)\n\tdefer resp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn txt, nil\n}\n\nfunc getOrFail(t *testing.T, url string, client *http.Client) []byte {\n\tt.Helper()\n\ttxt, err := get(url, client)\n\tif err != nil {\n\t\tt.Fatal(\"Can't fetch url\", url, err)\n\t}\n\treturn txt\n}\n\nfunc getCert(t *testing.T, c *tls.Conn) []byte {\n\tt.Helper()\n\tif err := c.Handshake(); err != nil {\n\t\tt.Fatal(\"cannot handshake\", err)\n\t}\n\treturn c.ConnectionState().PeerCertificates[0].Raw\n}\n\nfunc localFile(url string) string {\n\treturn fs.URL + \"/\" + url\n}\n\nfunc TestSimpleHttpReqWithProxy(t *testing.T) {\n\tclient, s := oneShotProxy(goproxy.NewProxyHttpServer())\n\tdefer s.Close()\n\n\tif r := string(getOrFail(t, srv.URL+\"/bobo\", client)); r != \"bobo\" {\n\t\tt.Error(\"proxy server does not serve constant handlers\", r)\n\t}\n\tif r := string(getOrFail(t, srv.URL+\"/bobo\", client)); r != \"bobo\" {\n\t\tt.Error(\"proxy server does not serve constant handlers\", r)\n\t}\n\n\tif string(getOrFail(t, https.URL+\"/bobo\", client)) != \"bobo\" {\n\t\tt.Error(\"TLS server does not serve constant handlers, when proxy is used\")\n\t}\n}\n\nfunc oneShotProxy(proxy *goproxy.ProxyHttpServer) (client *http.Client, s *httptest.Server) {\n\ts = httptest.NewServer(proxy)\n\n\tproxyUrl, _ := url.Parse(s.URL)\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t},\n\t\tProxy: http.ProxyURL(proxyUrl),\n\t}\n\tclient = &http.Client{Transport: tr}\n\treturn\n}\n\nfunc TestSimpleHook(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest(goproxy.SrcIpIs(\"127.0.0.1\")).DoFunc(\n\t\tfunc(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\treq.URL.Path = \"/bobo\"\n\t\t\treturn req, nil\n\t\t},\n\t)\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif result := string(getOrFail(t, srv.URL+(\"/momo\"), client)); result != \"bobo\" {\n\t\tt.Error(\"Redirecting all requests from 127.0.0.1 to bobo, didn't work.\" +\n\t\t\t\" (Might break if Go's client sets RemoteAddr to IPv6 address). Got: \" +\n\t\t\tresult)\n\t}\n}\n\nfunc TestAlwaysHook(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\treq.URL.Path = \"/bobo\"\n\t\treturn req, nil\n\t})\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif result := string(getOrFail(t, srv.URL+(\"/momo\"), client)); result != \"bobo\" {\n\t\tt.Error(\"Redirecting all requests from 127.0.0.1 to bobo, didn't work.\" +\n\t\t\t\" (Might break if Go's client sets RemoteAddr to IPv6 address). Got: \" +\n\t\t\tresult)\n\t}\n}\n\nfunc TestReplaceResponse(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tresp.StatusCode = http.StatusOK\n\t\tresp.Body = io.NopCloser(bytes.NewBufferString(\"chico\"))\n\t\treturn resp\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif result := string(getOrFail(t, srv.URL+(\"/momo\"), client)); result != \"chico\" {\n\t\tt.Error(\"hooked response, should be chico, instead:\", result)\n\t}\n}\n\nfunc TestReplaceReponseForUrl(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse(goproxy.UrlIs(\"/koko\")).DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tresp.StatusCode = http.StatusOK\n\t\tresp.Body = io.NopCloser(bytes.NewBufferString(\"chico\"))\n\t\treturn resp\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif result := string(getOrFail(t, srv.URL+(\"/koko\"), client)); result != \"chico\" {\n\t\tt.Error(\"hooked 'koko', should be chico, instead:\", result)\n\t}\n\tif result := string(getOrFail(t, srv.URL+(\"/bobo\"), client)); result != \"bobo\" {\n\t\tt.Error(\"still, bobo should stay as usual, instead:\", result)\n\t}\n}\n\nfunc TestOneShotFileServer(t *testing.T) {\n\tclient, l := oneShotProxy(goproxy.NewProxyHttpServer())\n\tdefer l.Close()\n\n\tfile := \"test_data/panda.png\"\n\tinfo, err := os.Stat(file)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot find\", file)\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, fs.URL+\"/\"+file, nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\tif resp, err := client.Do(req); err == nil {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"got\", string(b))\n\t\t}\n\t\tif int64(len(b)) != info.Size() {\n\t\t\tt.Error(\"Expected Length\", file, info.Size(), \"actually\", len(b), \"starts\", string(b[:10]))\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Cannot read from fs server\", err)\n\t}\n}\n\nfunc TestContentType(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse(goproxy.ContentTypeIs(\"image/png\")).DoFunc(\n\t\tfunc(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\t\tresp.Header.Set(\"X-Shmoopi\", \"1\")\n\t\t\treturn resp\n\t\t},\n\t)\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tfor _, file := range []string{\"test_data/panda.png\", \"test_data/football.png\"} {\n\t\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, localFile(file), nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Cannot create request\", err)\n\t\t}\n\t\tif resp, err := client.Do(req); err != nil || resp.Header.Get(\"X-Shmoopi\") != \"1\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"pngs should have X-Shmoopi header = 1, actually\", resp.Header.Get(\"X-Shmoopi\"))\n\t\t\t} else {\n\t\t\t\tt.Error(\"error reading png\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, localFile(\"baby.jpg\"), nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\tif resp, err := client.Do(req); err != nil || resp.Header.Get(\"X-Shmoopi\") != \"\" {\n\t\tif err == nil {\n\t\t\tt.Error(\"Non png images should NOT have X-Shmoopi header at all\", resp.Header.Get(\"X-Shmoopi\"))\n\t\t} else {\n\t\t\tt.Error(\"error reading png\", err)\n\t\t}\n\t}\n}\n\nfunc panicOnErr(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatal(err.Error() + \":-\" + msg)\n\t}\n}\n\nfunc TestChangeResp(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\t_, _ = resp.Body.Read([]byte{0})\n\t\tresp.Body = io.NopCloser(new(bytes.Buffer))\n\t\treturn resp\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, localFile(\"test_data/panda.png\"), nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, _ = io.ReadAll(resp.Body)\n\treq, err = http.NewRequestWithContext(context.Background(), http.MethodGet, localFile(\"/bobo\"), nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\t_, err = client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSimpleMitm(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest(goproxy.ReqHostIs(https.Listener.Addr().String())).HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnRequest(goproxy.ReqHostIs(\"no such host exists\")).HandleConnect(goproxy.AlwaysMitm)\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tc, err := tls.Dial(\"tcp\", https.Listener.Addr().String(), &tls.Config{InsecureSkipVerify: true})\n\tif err != nil {\n\t\tt.Fatal(\"cannot dial to tcp server\", err)\n\t}\n\torigCert := getCert(t, c)\n\t_ = c.Close()\n\n\tc2, err := net.Dial(\"tcp\", l.Listener.Addr().String())\n\tif err != nil {\n\t\tt.Fatal(\"dialing to proxy\", err)\n\t}\n\tcreq, err := http.NewRequestWithContext(context.Background(), http.MethodConnect, https.URL, nil)\n\tif err != nil {\n\t\tt.Fatal(\"create new request\", creq)\n\t}\n\t_ = creq.Write(c2)\n\tc2buf := bufio.NewReader(c2)\n\tresp, err := http.ReadResponse(c2buf, creq)\n\tif err != nil || resp.StatusCode != http.StatusOK {\n\t\tt.Fatal(\"Cannot CONNECT through proxy\", err)\n\t}\n\tc2tls := tls.Client(c2, &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t})\n\tproxyCert := getCert(t, c2tls)\n\n\tif bytes.Equal(proxyCert, origCert) {\n\t\tt.Errorf(\"Certificate after mitm is not different\\n%v\\n%v\",\n\t\t\tbase64.StdEncoding.EncodeToString(origCert),\n\t\t\tbase64.StdEncoding.EncodeToString(proxyCert))\n\t}\n\n\tif resp := string(getOrFail(t, https.URL+\"/bobo\", client)); resp != \"bobo\" {\n\t\tt.Error(\"Wrong response when mitm\", resp, \"expected bobo\")\n\t}\n\tif resp := string(getOrFail(t, https.URL+\"/query?result=bar\", client)); resp != \"bar\" {\n\t\tt.Error(\"Wrong response when mitm\", resp, \"expected bar\")\n\t}\n}\n\nfunc TestMitmMutateRequest(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t// We inject a header in the request\n\t\treq.Header.Set(\"Mitm-Header-Inject\", \"true\")\n\t\treturn req, nil\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tr := string(getOrFail(t, https.URL+\"/headers\", client))\n\tif !strings.Contains(r, \"Mitm-Header-Inject: true\") {\n\t\tt.Error(\"Expected response body to contain the MITM injected header. Got instead: \", r)\n\t}\n}\n\nfunc TestConnectHandler(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\talthttps := httptest.NewTLSServer(ConstantHanlder(\"althttps\"))\n\tproxy.OnRequest().HandleConnectFunc(func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n\t\tu, _ := url.Parse(althttps.URL)\n\t\treturn goproxy.OkConnect, u.Host\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\tif resp := string(getOrFail(t, https.URL+\"/alturl\", client)); resp != \"althttps\" {\n\t\tt.Error(\"Proxy should redirect CONNECT requests to local althttps server, expected 'althttps' got \", resp)\n\t}\n}\n\nfunc TestMitmIsFiltered(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest(goproxy.ReqHostIs(https.Listener.Addr().String())).HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnRequest(goproxy.UrlIs(\"/momo\")).DoFunc(\n\t\tfunc(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\treturn nil, goproxy.TextResponse(req, \"koko\")\n\t\t},\n\t)\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif resp := string(getOrFail(t, https.URL+\"/momo\", client)); resp != \"koko\" {\n\t\tt.Error(\"Proxy should capture /momo to be koko and not\", resp)\n\t}\n\n\tif resp := string(getOrFail(t, https.URL+\"/bobo\", client)); resp != \"bobo\" {\n\t\tt.Error(\"But still /bobo should be bobo and not\", resp)\n\t}\n}\n\nfunc TestFirstHandlerMatches(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\treturn nil, goproxy.TextResponse(req, \"koko\")\n\t})\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\tpanic(\"should never get here, previous response is no null\")\n\t})\n\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tif resp := string(getOrFail(t, srv.URL+\"/\", client)); resp != \"koko\" {\n\t\tt.Error(\"should return always koko and not\", resp)\n\t}\n}\n\nfunc TestIcyResponse(t *testing.T) {\n\t// TODO: fix this test\n\t/*s := constantHttpServer([]byte(\"ICY 200 OK\\r\\n\\r\\nblablabla\"))\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.Verbose = true\n\t_, l := oneShotProxy(proxy, t)\n\tdefer l.Close()\n\treq, err := http.NewRequest(\"GET\", \"http://\"+s, nil)\n\tpanicOnErr(err, \"newReq\")\n\tproxyip := l.URL[len(\"http://\"):]\n\tprintln(\"got ip: \" + proxyip)\n\tc, err := net.Dial(\"tcp\", proxyip)\n\tpanicOnErr(err, \"dial\")\n\tdefer c.Close()\n\treq.WriteProxy(c)\n\traw, err := io.ReadAll(c)\n\tpanicOnErr(err, \"readAll\")\n\tif string(raw) != \"ICY 200 OK\\r\\n\\r\\nblablabla\" {\n\t\tt.Error(\"Proxy did not send the malformed response received\")\n\t}*/\n}\n\ntype VerifyNoProxyHeaders struct {\n\t*testing.T\n}\n\nfunc (v VerifyNoProxyHeaders) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Header.Get(\"Connection\") != \"\" || r.Header.Get(\"Proxy-Connection\") != \"\" ||\n\t\tr.Header.Get(\"Proxy-Authenticate\") != \"\" || r.Header.Get(\"Proxy-Authorization\") != \"\" {\n\t\tv.Error(\"Got Connection header from goproxy\", r.Header)\n\t}\n}\n\nfunc TestNoProxyHeaders(t *testing.T) {\n\ts := httptest.NewServer(VerifyNoProxyHeaders{t})\n\tclient, l := oneShotProxy(goproxy.NewProxyHttpServer())\n\tdefer l.Close()\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, s.URL, nil)\n\tpanicOnErr(err, \"bad request\")\n\treq.Header.Add(\"Proxy-Connection\", \"close\")\n\treq.Header.Add(\"Proxy-Authenticate\", \"auth\")\n\treq.Header.Add(\"Proxy-Authorization\", \"auth\")\n\t_, _ = client.Do(req)\n}\n\nfunc TestNoProxyHeadersHttps(t *testing.T) {\n\ts := httptest.NewTLSServer(VerifyNoProxyHeaders{t})\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, s.URL, nil)\n\tpanicOnErr(err, \"bad request\")\n\treq.Header.Add(\"Proxy-Connection\", \"close\")\n\t_, _ = client.Do(req)\n}\n\ntype VerifyAcceptEncodingHeader struct {\n\tReceivedHeaderValue string\n}\n\nfunc (v *VerifyAcceptEncodingHeader) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tv.ReceivedHeaderValue = r.Header.Get(\"Accept-Encoding\")\n}\n\nfunc TestAcceptEncoding(t *testing.T) {\n\tv := VerifyAcceptEncodingHeader{}\n\ts := httptest.NewServer(&v)\n\tfor i, tc := range []struct {\n\t\tkeepAcceptEncoding bool\n\t\tdisableCompression bool\n\t\tacceptEncoding     string\n\t\texpectedValue      string\n\t}{\n\t\t{false, false, \"\", \"gzip\"},\n\t\t{false, false, \"identity\", \"gzip\"},\n\t\t{false, true, \"\", \"\"},\n\t\t{false, true, \"identity\", \"\"},\n\t\t{true, false, \"\", \"gzip\"},\n\t\t{true, false, \"identity\", \"identity\"},\n\t\t{true, true, \"\", \"\"},\n\t\t{true, true, \"identity\", \"identity\"},\n\t} {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tproxy := goproxy.NewProxyHttpServer()\n\t\t\tproxy.KeepAcceptEncoding = tc.keepAcceptEncoding\n\t\t\tproxy.Tr.DisableCompression = tc.disableCompression\n\t\t\tclient, l := oneShotProxy(proxy)\n\t\t\tdefer l.Close()\n\t\t\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, s.URL, nil)\n\t\t\tpanicOnErr(err, \"bad request\")\n\t\t\t// fully control the Accept-Encoding header we send to the proxy\n\t\t\ttr, ok := client.Transport.(*http.Transport)\n\t\t\tif !ok {\n\t\t\t\tt.Fatal(\"invalid client transport\")\n\t\t\t}\n\t\t\ttr.DisableCompression = true\n\t\t\tif tc.acceptEncoding != \"\" {\n\t\t\t\treq.Header.Add(\"Accept-Encoding\", tc.acceptEncoding)\n\t\t\t}\n\t\t\t_, err = client.Do(req)\n\t\t\tpanicOnErr(err, \"bad response\")\n\t\t\tif v.ReceivedHeaderValue != tc.expectedValue {\n\t\t\t\tt.Errorf(\"%+v expected Accept-Encoding: %s, got %s\", tc, tc.expectedValue, v.ReceivedHeaderValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHeadReqHasContentLength(t *testing.T) {\n\tclient, l := oneShotProxy(goproxy.NewProxyHttpServer())\n\tdefer l.Close()\n\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodHead, localFile(\"test_data/panda.png\"), nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\n\tresp, err := client.Do(req)\n\tpanicOnErr(err, \"resp to HEAD\")\n\tif resp.Header.Get(\"Content-Length\") == \"\" {\n\t\tt.Error(\"Content-Length should exist on HEAD requests\")\n\t}\n}\n\nfunc TestChunkedResponse(t *testing.T) {\n\tl, err := net.Listen(\"tcp\", \":10234\")\n\tpanicOnErr(err, \"listen\")\n\tdefer l.Close()\n\tgo func() {\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tc, err := l.Accept()\n\t\t\tpanicOnErr(err, \"accept\")\n\t\t\t_, err = http.ReadRequest(bufio.NewReader(c))\n\t\t\tpanicOnErr(err, \"readrequest\")\n\t\t\t_, _ = io.WriteString(c, \"HTTP/1.1 200 OK\\r\\n\"+\n\t\t\t\t\"Content-Type: text/plain\\r\\n\"+\n\t\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\"+\n\t\t\t\t\"25\\r\\n\"+\n\t\t\t\t\"This is the data in the first chunk\\r\\n\\r\\n\"+\n\t\t\t\t\"1C\\r\\n\"+\n\t\t\t\t\"and this is the second one\\r\\n\\r\\n\"+\n\t\t\t\t\"3\\r\\n\"+\n\t\t\t\t\"con\\r\\n\"+\n\t\t\t\t\"8\\r\\n\"+\n\t\t\t\t\"sequence\\r\\n0\\r\\n\\r\\n\")\n\t\t\t_ = c.Close()\n\t\t}\n\t}()\n\n\tc, err := net.Dial(\"tcp\", \"localhost:10234\")\n\tpanicOnErr(err, \"dial\")\n\tdefer c.Close()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/\", nil)\n\t_ = req.Write(c)\n\tresp, err := http.ReadResponse(bufio.NewReader(c), req)\n\tpanicOnErr(err, \"readresp\")\n\tb, err := io.ReadAll(resp.Body)\n\tpanicOnErr(err, \"readall\")\n\texpected := \"This is the data in the first chunk\\r\\nand this is the second one\\r\\nconsequence\"\n\tif string(b) != expected {\n\t\tt.Errorf(\"Got `%v` expected `%v`\", string(b), expected)\n\t}\n\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tpanicOnErr(ctx.Error, \"error reading output\")\n\t\tb, err := io.ReadAll(resp.Body)\n\t\t_ = resp.Body.Close()\n\t\tpanicOnErr(err, \"readall onresp\")\n\t\tif enc := resp.Header.Get(\"Transfer-Encoding\"); enc != \"\" {\n\t\t\tt.Fatal(\"Chunked response should be received as plaintext\", enc)\n\t\t}\n\t\tresp.Body = io.NopCloser(bytes.NewBufferString(strings.ReplaceAll(string(b), \"e\", \"E\")))\n\t\treturn resp\n\t})\n\n\tclient, s := oneShotProxy(proxy)\n\tdefer s.Close()\n\n\treq, err = http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://localhost:10234/\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\n\tresp, err = client.Do(req)\n\tpanicOnErr(err, \"client.Get\")\n\tb, err = io.ReadAll(resp.Body)\n\tpanicOnErr(err, \"readall proxy\")\n\tif string(b) != strings.ReplaceAll(expected, \"e\", \"E\") {\n\t\tt.Error(\"expected\", expected, \"w/ e->E. Got\", string(b))\n\t}\n}\n\nfunc TestGoproxyThroughProxy(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy2 := goproxy.NewProxyHttpServer()\n\tdoubleString := func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tpanicOnErr(err, \"readAll resp\")\n\t\tresp.Body = io.NopCloser(bytes.NewBufferString(string(b) + \" \" + string(b)))\n\t\treturn resp\n\t}\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnResponse().DoFunc(doubleString)\n\n\t_, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tproxy2.ConnectDial = proxy2.NewConnectDialToProxy(l.URL)\n\n\tclient, l2 := oneShotProxy(proxy2)\n\tdefer l2.Close()\n\tif r := string(getOrFail(t, https.URL+\"/bobo\", client)); r != \"bobo bobo\" {\n\t\tt.Error(\"Expected bobo doubled twice, got\", r)\n\t}\n}\n\nfunc TestHttpProxyAddrsFromEnv(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tdoubleString := func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tpanicOnErr(err, \"readAll resp\")\n\t\tresp.Body = io.NopCloser(bytes.NewBufferString(string(b) + \" \" + string(b)))\n\t\treturn resp\n\t}\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnResponse().DoFunc(doubleString)\n\n\t_, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tt.Setenv(\"https_proxy\", l.URL)\n\tproxy2 := goproxy.NewProxyHttpServer()\n\n\tclient, l2 := oneShotProxy(proxy2)\n\tdefer l2.Close()\n\tif r := string(getOrFail(t, https.URL+\"/bobo\", client)); r != \"bobo bobo\" {\n\t\tt.Error(\"Expected bobo doubled twice, got\", r)\n\t}\n}\n\nfunc TestGoproxyHijackConnect(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest(goproxy.ReqHostIs(srv.Listener.Addr().String())).\n\t\tHijackConnect(func(req *http.Request, client net.Conn, ctx *goproxy.ProxyCtx) {\n\t\t\tt.Logf(\"URL %+#v\\nSTR %s\", req.URL, req.URL.String())\n\t\t\tgetReq, err := http.NewRequestWithContext(req.Context(), http.MethodGet, (&url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   req.URL.Host,\n\t\t\t\tPath:   \"/bobo\",\n\t\t\t}).String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Cannot create request\", err)\n\t\t\t}\n\t\t\thttpClient := &http.Client{}\n\t\t\tresp, err := httpClient.Do(getReq)\n\t\t\tpanicOnErr(err, \"http.Get(CONNECT url)\")\n\t\t\tpanicOnErr(resp.Write(client), \"resp.Write(client)\")\n\t\t\t_ = resp.Body.Close()\n\t\t\t_ = client.Close()\n\t\t})\n\tclient, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\tproxyAddr := l.Listener.Addr().String()\n\tconn, err := net.Dial(\"tcp\", proxyAddr)\n\tpanicOnErr(err, \"conn \"+proxyAddr)\n\tbuf := bufio.NewReader(conn)\n\twriteConnect(conn)\n\tif txt := readResponse(buf); txt != \"bobo\" {\n\t\tt.Error(\"Expected bobo for CONNECT /foo, got\", txt)\n\t}\n\n\tif r := string(getOrFail(t, https.URL+\"/bobo\", client)); r != \"bobo\" {\n\t\tt.Error(\"Expected bobo would keep working with CONNECT\", r)\n\t}\n}\n\nfunc readResponse(buf *bufio.Reader) string {\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, srv.URL, nil)\n\tpanicOnErr(err, \"NewRequest\")\n\tresp, err := http.ReadResponse(buf, req)\n\tpanicOnErr(err, \"resp.Read\")\n\tdefer resp.Body.Close()\n\ttxt, err := io.ReadAll(resp.Body)\n\tpanicOnErr(err, \"resp.Read\")\n\treturn string(txt)\n}\n\nfunc writeConnect(w io.Writer) {\n\t// this will let us use IP address of server as url in http.NewRequest by\n\t// passing it as //127.0.0.1:64584 (prefixed with //).\n\t// Passing IP address with port alone (without //) will raise error:\n\t// \"first path segment in URL cannot contain colon\" more details on this\n\t// here: https://github.com/golang/go/issues/18824\n\treq := &http.Request{\n\t\tMethod: http.MethodConnect,\n\t\tURL:    &url.URL{Opaque: srv.Listener.Addr().String()},\n\t\tHost:   srv.Listener.Addr().String(),\n\t\tHeader: make(http.Header),\n\t}\n\terr := req.Write(w)\n\tpanicOnErr(err, \"req(CONNECT).Write\")\n}\n\nfunc TestCurlMinusP(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().HandleConnectFunc(func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n\t\treturn goproxy.HTTPMitmConnect, host\n\t})\n\tcalled := false\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\tcalled = true\n\t\treturn req, nil\n\t})\n\t_, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tcmd := exec.CommandContext(ctx, \"curl\", \"-p\", \"-sS\", \"--proxy\", l.URL, srv.URL+\"/bobo\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\tif err := cmd.Run(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif output := out.String(); output != \"bobo\" {\n\t\tt.Error(\"Expected bobo, got\", output)\n\t}\n\tif !called {\n\t\tt.Error(\"handler not called\")\n\t}\n}\n\nfunc TestSelfRequest(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\t_, l := oneShotProxy(proxy)\n\tdefer l.Close()\n\tif !strings.Contains(string(getOrFail(t, l.URL, &http.Client{})), \"non-proxy\") {\n\t\tt.Fatal(\"non proxy requests should fail\")\n\t}\n}\n\nfunc TestHasGoproxyCA(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\ts := httptest.NewServer(proxy)\n\n\tproxyUrl, _ := url.Parse(s.URL)\n\tgoproxyCA := x509.NewCertPool()\n\tgoproxyCA.AddCert(goproxy.GoproxyCa.Leaf)\n\n\ttr := &http.Transport{TLSClientConfig: &tls.Config{RootCAs: goproxyCA}, Proxy: http.ProxyURL(proxyUrl)}\n\tclient := &http.Client{Transport: tr}\n\n\tif resp := string(getOrFail(t, https.URL+\"/bobo\", client)); resp != \"bobo\" {\n\t\tt.Error(\"Wrong response when mitm\", resp, \"expected bobo\")\n\t}\n}\n\ntype TestCertStorage struct {\n\tcerts  map[string]*tls.Certificate\n\thits   int\n\tmisses int\n}\n\nfunc (tcs *TestCertStorage) Fetch(hostname string, gen func() (*tls.Certificate, error)) (*tls.Certificate, error) {\n\tvar cert *tls.Certificate\n\tvar err error\n\tcert, ok := tcs.certs[hostname]\n\tif ok {\n\t\tlog.Printf(\"hit %v\\n\", cert == nil)\n\t\ttcs.hits++\n\t} else {\n\t\tcert, err = gen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlog.Printf(\"miss %v\\n\", cert == nil)\n\t\ttcs.certs[hostname] = cert\n\t\ttcs.misses++\n\t}\n\treturn cert, err\n}\n\nfunc (tcs *TestCertStorage) statHits() int {\n\treturn tcs.hits\n}\n\nfunc (tcs *TestCertStorage) statMisses() int {\n\treturn tcs.misses\n}\n\nfunc newTestCertStorage() *TestCertStorage {\n\ttcs := &TestCertStorage{}\n\ttcs.certs = make(map[string]*tls.Certificate)\n\n\treturn tcs\n}\n\nfunc TestProxyWithCertStorage(t *testing.T) {\n\ttcs := newTestCertStorage()\n\tt.Logf(\"TestProxyWithCertStorage started\")\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.CertStore = tcs\n\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\tproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\treq.URL.Path = \"/bobo\"\n\t\treturn req, nil\n\t})\n\n\ts := httptest.NewServer(proxy)\n\n\tproxyUrl, _ := url.Parse(s.URL)\n\tgoproxyCA := x509.NewCertPool()\n\tgoproxyCA.AddCert(goproxy.GoproxyCa.Leaf)\n\n\ttr := &http.Transport{TLSClientConfig: &tls.Config{RootCAs: goproxyCA}, Proxy: http.ProxyURL(proxyUrl)}\n\tclient := &http.Client{Transport: tr}\n\n\tif resp := string(getOrFail(t, https.URL+\"/bobo\", client)); resp != \"bobo\" {\n\t\tt.Error(\"Wrong response when mitm\", resp, \"expected bobo\")\n\t}\n\n\tif tcs.statHits() != 0 {\n\t\tt.Fatalf(\"Expected 0 cache hits, got %d\", tcs.statHits())\n\t}\n\tif tcs.statMisses() != 1 {\n\t\tt.Fatalf(\"Expected 1 cache miss, got %d\", tcs.statMisses())\n\t}\n\n\t// Another round - this time the certificate can be loaded\n\tif resp := string(getOrFail(t, https.URL+\"/bobo\", client)); resp != \"bobo\" {\n\t\tt.Error(\"Wrong response when mitm\", resp, \"expected bobo\")\n\t}\n\n\tif tcs.statHits() != 1 {\n\t\tt.Fatalf(\"Expected 1 cache hit, got %d\", tcs.statHits())\n\t}\n\tif tcs.statMisses() != 1 {\n\t\tt.Fatalf(\"Expected 1 cache miss, got %d\", tcs.statMisses())\n\t}\n}\n\nfunc TestHttpsMitmURLRewrite(t *testing.T) {\n\tscheme := \"https\"\n\n\ttestCases := []struct {\n\t\tHost      string\n\t\tRawPath   string\n\t\tAddOpaque bool\n\t}{\n\t\t{\n\t\t\tHost:      \"example.com\",\n\t\t\tRawPath:   \"/blah/v1/data/realtime\",\n\t\t\tAddOpaque: true,\n\t\t},\n\t\t{\n\t\t\tHost:    \"example.com:443\",\n\t\t\tRawPath: \"/blah/v1/data/realtime?encodedURL=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile\",\n\t\t},\n\t\t{\n\t\t\tHost:    \"example.com:443\",\n\t\t\tRawPath: \"/blah/v1/data/realtime?unencodedURL=https://www.googleapis.com/auth/userinfo.profile\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tproxy := goproxy.NewProxyHttpServer()\n\t\tproxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)\n\n\t\tproxy.OnRequest(goproxy.DstHostIs(tc.Host)).DoFunc(\n\t\t\tfunc(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\t\treturn nil, goproxy.TextResponse(req, \"Dummy response\")\n\t\t\t})\n\n\t\tclient, s := oneShotProxy(proxy)\n\t\tdefer s.Close()\n\n\t\tfullURL := scheme + \"://\" + tc.Host + tc.RawPath\n\t\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, fullURL, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif tc.AddOpaque {\n\t\t\treq.URL.Scheme = scheme\n\t\t\treq.URL.Opaque = \"//\" + tc.Host + tc.RawPath\n\t\t}\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tb, err := io.ReadAll(resp.Body)\n\t\t_ = resp.Body.Close()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tbody := string(b)\n\t\tif body != \"Dummy response\" {\n\t\t\tt.Errorf(\"Expected proxy to return dummy body content but got %s\", body)\n\t\t}\n\n\t\tif resp.StatusCode != http.StatusAccepted {\n\t\t\tt.Errorf(\"Expected status: %d, got: %d\", http.StatusAccepted, resp.StatusCode)\n\t\t}\n\t}\n}\n\nfunc TestSimpleHttpRequest(t *testing.T) {\n\tproxy := goproxy.NewProxyHttpServer()\n\n\tvar server *http.Server\n\tgo func() {\n\t\tt.Log(\"serving end proxy server at localhost:5000\")\n\t\tserver = &http.Server{\n\t\t\tAddr:              \"localhost:5000\",\n\t\t\tHandler:           proxy,\n\t\t\tReadHeaderTimeout: 10 * time.Second,\n\t\t}\n\t\terr := server.ListenAndServe()\n\t\tif err == nil {\n\t\t\tt.Error(\"Error shutdown should always return error\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\tu, _ := url.Parse(\"http://localhost:5000\")\n\ttr := &http.Transport{\n\t\tProxy: http.ProxyURL(u),\n\t\t// Disable HTTP/2.\n\t\tTLSNextProto: make(map[string]func(authority string, c *tls.Conn) http.RoundTripper),\n\t}\n\tclient := http.Client{Transport: tr}\n\n\treq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Error(\"Error requesting http site\", err)\n\t} else if resp.StatusCode != http.StatusOK {\n\t\tt.Error(\"Non-OK status requesting http site\", err)\n\t}\n\n\treq, err = http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://example.invalid\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot create request\", err)\n\t}\n\n\tresp, _ = client.Do(req)\n\tif resp == nil {\n\t\tt.Error(\"No response requesting invalid http site\")\n\t}\n\n\treturnNil := func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\treturn nil\n\t}\n\tproxy.OnResponse(goproxy.UrlMatches(regexp.MustCompile(\".*\"))).DoFunc(returnNil)\n\n\tresp, _ = client.Do(req)\n\tif resp == nil {\n\t\tt.Error(\"No response requesting invalid http site\")\n\t}\n\n\t_ = server.Shutdown(context.TODO())\n}\n\nfunc TestResponseContentLength(t *testing.T) {\n\t// target server\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, _ = w.Write([]byte(\"hello world\"))\n\t}))\n\tdefer srv.Close()\n\n\t// proxy server\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n\t\tbuf := &bytes.Buffer{}\n\t\tbuf.WriteString(\"change\")\n\t\tresp.Body = io.NopCloser(buf)\n\t\treturn resp\n\t})\n\tproxySrv := httptest.NewServer(proxy)\n\tdefer proxySrv.Close()\n\n\t// send request\n\tclient := &http.Client{}\n\tclient.Transport = &http.Transport{\n\t\tProxy: func(req *http.Request) (*url.URL, error) {\n\t\t\treturn url.Parse(proxySrv.URL)\n\t\t},\n\t}\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, srv.URL, nil)\n\tresp, _ := client.Do(req)\n\n\tbody, _ := io.ReadAll(resp.Body)\n\t_ = resp.Body.Close()\n\n\tif int64(len(body)) != resp.ContentLength {\n\t\tt.Logf(\"response body: %s\", string(body))\n\t\tt.Logf(\"response body Length: %d\", len(body))\n\t\tt.Logf(\"response Content-Length: %d\", resp.ContentLength)\n\t\tt.Fatalf(\"Wrong response Content-Length.\")\n\t}\n}\n"
        },
        {
          "name": "regretable",
          "type": "tree",
          "content": null
        },
        {
          "name": "responses.go",
          "type": "blob",
          "size": 1.2578125,
          "content": "package goproxy\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// Will generate a valid http response to the given request the response will have\n// the given contentType, and http status.\n// Typical usage, refuse to process requests to local addresses:\n//\n//\tproxy.OnRequest(IsLocalHost()).DoFunc(func(r *http.Request, ctx *goproxy.ProxyCtx) (*http.Request,*http.Response) {\n//\t\treturn nil,NewResponse(r,goproxy.ContentTypeHtml,http.StatusUnauthorized,\n//\t\t\t`<!doctype html><html><head><title>Can't use proxy for local addresses</title></head><body/></html>`)\n//\t})\nfunc NewResponse(r *http.Request, contentType string, status int, body string) *http.Response {\n\tresp := &http.Response{}\n\tresp.Request = r\n\tresp.TransferEncoding = r.TransferEncoding\n\tresp.Header = make(http.Header)\n\tresp.Header.Add(\"Content-Type\", contentType)\n\tresp.StatusCode = status\n\tresp.Status = http.StatusText(status)\n\tbuf := bytes.NewBufferString(body)\n\tresp.ContentLength = int64(buf.Len())\n\tresp.Body = io.NopCloser(buf)\n\treturn resp\n}\n\nconst (\n\tContentTypeText = \"text/plain\"\n\tContentTypeHtml = \"text/html\"\n)\n\n// Alias for NewResponse(r,ContentTypeText,http.StatusAccepted,text).\nfunc TextResponse(r *http.Request, text string) *http.Response {\n\treturn NewResponse(r, ContentTypeText, http.StatusAccepted, text)\n}\n"
        },
        {
          "name": "test_data",
          "type": "tree",
          "content": null
        },
        {
          "name": "transport",
          "type": "tree",
          "content": null
        },
        {
          "name": "websocket.go",
          "type": "blob",
          "size": 4.2451171875,
          "content": "package goproxy\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc headerContains(header http.Header, name string, value string) bool {\n\tfor _, v := range header[name] {\n\t\tfor _, s := range strings.Split(v, \",\") {\n\t\t\tif strings.EqualFold(value, strings.TrimSpace(s)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isWebSocketRequest(r *http.Request) bool {\n\treturn headerContains(r.Header, \"Connection\", \"upgrade\") &&\n\t\theaderContains(r.Header, \"Upgrade\", \"websocket\")\n}\n\nfunc (proxy *ProxyHttpServer) serveWebsocketTLS(\n\tctx *ProxyCtx,\n\tw http.ResponseWriter,\n\treq *http.Request,\n\ttlsConfig *tls.Config,\n\tclientConn *tls.Conn,\n) {\n\thost := req.URL.Host\n\t// Port is optional in req.URL.Host, in this case SplitHostPort returns\n\t// an error, and we add the default port\n\t_, port, err := net.SplitHostPort(req.URL.Host)\n\tif err != nil || port == \"\" {\n\t\thost = net.JoinHostPort(req.URL.Host, \"443\")\n\t}\n\ttargetURL := url.URL{Scheme: \"wss\", Host: host, Path: req.URL.Path}\n\n\t// Connect to upstream\n\ttargetConn, err := tls.Dial(\"tcp\", targetURL.Host, tlsConfig)\n\tif err != nil {\n\t\tctx.Warnf(\"Error dialing target site: %v\", err)\n\t\treturn\n\t}\n\tdefer targetConn.Close()\n\n\t// Perform handshake\n\tif err := proxy.websocketHandshake(ctx, req, targetConn, clientConn); err != nil {\n\t\tctx.Warnf(\"Websocket handshake error: %v\", err)\n\t\treturn\n\t}\n\n\t// Proxy wss connection\n\tproxy.proxyWebsocket(ctx, targetConn, clientConn)\n}\n\nfunc (proxy *ProxyHttpServer) serveWebsocketHttpOverTLS(\n\tctx *ProxyCtx,\n\tw http.ResponseWriter,\n\treq *http.Request,\n\tclientConn *tls.Conn,\n) {\n\thost := req.URL.Host\n\t// Port is optional in req.URL.Host, in this case SplitHostPort returns\n\t// an error, and we add the default port\n\t_, port, err := net.SplitHostPort(req.URL.Host)\n\tif err != nil || port == \"\" {\n\t\thost = net.JoinHostPort(req.URL.Host, \"80\")\n\t}\n\ttargetURL := url.URL{Scheme: \"ws\", Host: host, Path: req.URL.Path}\n\n\t// Connect to upstream\n\ttargetConn, err := proxy.connectDial(ctx, \"tcp\", targetURL.Host)\n\tif err != nil {\n\t\tctx.Warnf(\"Error dialing target site: %v\", err)\n\t\treturn\n\t}\n\tdefer targetConn.Close()\n\n\t// Perform handshake\n\tif err := proxy.websocketHandshake(ctx, req, targetConn, clientConn); err != nil {\n\t\tctx.Warnf(\"Websocket handshake error: %v\", err)\n\t\treturn\n\t}\n\n\t// Proxy wss connection\n\tproxy.proxyWebsocket(ctx, targetConn, clientConn)\n}\n\nfunc (proxy *ProxyHttpServer) serveWebsocket(ctx *ProxyCtx, w http.ResponseWriter, req *http.Request) {\n\ttargetURL := url.URL{Scheme: \"ws\", Host: req.URL.Host, Path: req.URL.Path}\n\n\ttargetConn, err := proxy.connectDial(ctx, \"tcp\", targetURL.Host)\n\tif err != nil {\n\t\tctx.Warnf(\"Error dialing target site: %v\", err)\n\t\treturn\n\t}\n\tdefer targetConn.Close()\n\n\t// Connect to Client\n\thj, ok := w.(http.Hijacker)\n\tif !ok {\n\t\tpanic(\"httpserver does not support hijacking\")\n\t}\n\tclientConn, _, err := hj.Hijack()\n\tif err != nil {\n\t\tctx.Warnf(\"Hijack error: %v\", err)\n\t\treturn\n\t}\n\n\t// Perform handshake\n\tif err := proxy.websocketHandshake(ctx, req, targetConn, clientConn); err != nil {\n\t\tctx.Warnf(\"Websocket handshake error: %v\", err)\n\t\treturn\n\t}\n\n\t// Proxy ws connection\n\tproxy.proxyWebsocket(ctx, targetConn, clientConn)\n}\n\nfunc (proxy *ProxyHttpServer) websocketHandshake(\n\tctx *ProxyCtx,\n\treq *http.Request,\n\ttargetSiteConn io.ReadWriter,\n\tclientConn io.ReadWriter,\n) error {\n\t// write handshake request to target\n\terr := req.Write(targetSiteConn)\n\tif err != nil {\n\t\tctx.Warnf(\"Error writing upgrade request: %v\", err)\n\t\treturn err\n\t}\n\n\ttargetTLSReader := bufio.NewReader(targetSiteConn)\n\n\t// Read handshake response from target\n\tresp, err := http.ReadResponse(targetTLSReader, req)\n\tif err != nil {\n\t\tctx.Warnf(\"Error reading handhsake response  %v\", err)\n\t\treturn err\n\t}\n\n\t// Run response through handlers\n\tresp = proxy.filterResponse(resp, ctx)\n\n\t// Proxy handshake back to client\n\terr = resp.Write(clientConn)\n\tif err != nil {\n\t\tctx.Warnf(\"Error writing handshake response: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (proxy *ProxyHttpServer) proxyWebsocket(ctx *ProxyCtx, dest io.ReadWriter, source io.ReadWriter) {\n\terrChan := make(chan error, 2)\n\tcp := func(dst io.Writer, src io.Reader) {\n\t\t_, err := io.Copy(dst, src)\n\t\tctx.Warnf(\"Websocket error: %v\", err)\n\t\terrChan <- err\n\t}\n\n\t// Start proxying websocket data\n\tgo cp(dest, source)\n\tgo cp(source, dest)\n\t<-errChan\n}\n"
        }
      ]
    }
  ]
}