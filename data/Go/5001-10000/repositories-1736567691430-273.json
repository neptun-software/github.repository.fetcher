{
  "metadata": {
    "timestamp": 1736567691430,
    "page": 273,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "asaskevich/govalidator",
      "stars": 6074,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2001953125,
          "content": "bin/\n.idea/\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2060546875,
          "content": "language: go\ndist: xenial\ngo:\n  - '1.10'\n  - '1.11'\n  - '1.12'\n  - '1.13'\n  - 'tip'\n\nscript:\n     - go test -coverpkg=./... -coverprofile=coverage.info -timeout=5s\n     - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 2.2822265625,
          "content": "# Contributor Code of Conduct\n\nThis project adheres to [The Code Manifesto](http://codemanifesto.com)\nas its guidelines for contributor interactions.\n\n## The Code Manifesto\n\nWe want to work in an ecosystem that empowers developers to reach their\npotential — one that encourages growth and effective collaboration. A space\nthat is safe for all.\n\nA space such as this benefits everyone that participates in it. It encourages\nnew developers to enter our field. It is through discussion and collaboration\nthat we grow, and through growth that we improve.\n\nIn the effort to create such a place, we hold to these values:\n\n1. **Discrimination limits us.** This includes discrimination on the basis of\n   race, gender, sexual orientation, gender identity, age, nationality,\n   technology and any other arbitrary exclusion of a group of people.\n2. **Boundaries honor us.** Your comfort levels are not everyone’s comfort\n   levels. Remember that, and if brought to your attention, heed it.\n3. **We are our biggest assets.** None of us were born masters of our trade.\n   Each of us has been helped along the way. Return that favor, when and where\n   you can.\n4. **We are resources for the future.** As an extension of #3, share what you\n   know. Make yourself a resource to help those that come after you.\n5. **Respect defines us.** Treat others as you wish to be treated. Make your\n   discussions, criticisms and debates from a position of respectfulness. Ask\n   yourself, is it true? Is it necessary? Is it constructive? Anything less is\n   unacceptable.\n6. **Reactions require grace.** Angry responses are valid, but abusive language\n   and vindictive actions are toxic. When something happens that offends you,\n   handle it assertively, but be respectful. Escalate reasonably, and try to\n   allow the offender an opportunity to explain themselves, and possibly\n   correct the issue.\n7. **Opinions are just that: opinions.** Each and every one of us, due to our\n   background and upbringing, have varying opinions. That is perfectly\n   acceptable. Remember this: if you respect your own opinions, you should\n   respect the opinions of others.\n8. **To err is human.** You might not intend it, but mistakes do happen and\n   contribute to build experience. Tolerate honest mistakes, and don't\n   hesitate to apologize if you make one yourself.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.166015625,
          "content": "#### Support\nIf you do have a contribution to the package, feel free to create a Pull Request or an Issue.\n\n#### What to contribute\nIf you don't know what to do, there are some features and functions that need to be done\n\n- [ ] Refactor code\n- [ ] Edit docs and [README](https://github.com/asaskevich/govalidator/README.md): spellcheck, grammar and typo check\n- [ ] Create actual list of contributors and projects that currently using this package\n- [ ] Resolve [issues and bugs](https://github.com/asaskevich/govalidator/issues)\n- [ ] Update actual [list of functions](https://github.com/asaskevich/govalidator#list-of-functions)\n- [ ] Update [list of validators](https://github.com/asaskevich/govalidator#validatestruct-2) that available for `ValidateStruct` and add new\n- [ ] Implement new validators: `IsFQDN`, `IsIMEI`, `IsPostalCode`, `IsISIN`, `IsISRC` etc\n- [x] Implement [validation by maps](https://github.com/asaskevich/govalidator/issues/224)\n- [ ] Implement fuzzing testing\n- [ ] Implement some struct/map/array utilities\n- [ ] Implement map/array validation\n- [ ] Implement benchmarking\n- [ ] Implement batch of examples\n- [ ] Look at forks for new features and fixes\n\n#### Advice\nFeel free to create what you want, but keep in mind when you implement new features:\n- Code must be clear and readable, names of variables/constants clearly describes what they are doing\n- Public functions must be documented and described in source file and added to README.md to the list of available functions\n- There are must be unit-tests for any new functions and improvements\n\n## Financial contributions\n\nWe also welcome financial contributions in full transparency on our [open collective](https://opencollective.com/govalidator).\nAnyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.\n\n\n## Credits\n\n\n### Contributors\n\nThank you to all the people who have already contributed to govalidator!\n<a href=\"https://github.com/asaskevich/govalidator/graphs/contributors\"><img src=\"https://opencollective.com/govalidator/contributors.svg?width=890\" /></a>\n\n\n### Backers\n\nThank you to all our backers! [[Become a backer](https://opencollective.com/govalidator#backer)]\n\n<a href=\"https://opencollective.com/govalidator#backers\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/backers.svg?width=890\"></a>\n\n\n### Sponsors\n\nThank you to all our sponsors! (please ask your company to also support this open source project by [becoming a sponsor](https://opencollective.com/govalidator#sponsor))\n\n<a href=\"https://opencollective.com/govalidator/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/9/avatar.svg\"></a>"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2020 Alex Saskevich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.591796875,
          "content": "govalidator\n===========\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/asaskevich/govalidator?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge) [![GoDoc](https://godoc.org/github.com/asaskevich/govalidator?status.png)](https://godoc.org/github.com/asaskevich/govalidator)\n[![Build Status](https://travis-ci.org/asaskevich/govalidator.svg?branch=master)](https://travis-ci.org/asaskevich/govalidator)\n[![Coverage](https://codecov.io/gh/asaskevich/govalidator/branch/master/graph/badge.svg)](https://codecov.io/gh/asaskevich/govalidator) [![Go Report Card](https://goreportcard.com/badge/github.com/asaskevich/govalidator)](https://goreportcard.com/report/github.com/asaskevich/govalidator) [![GoSearch](http://go-search.org/badge?id=github.com%2Fasaskevich%2Fgovalidator)](http://go-search.org/view?id=github.com%2Fasaskevich%2Fgovalidator) [![Backers on Open Collective](https://opencollective.com/govalidator/backers/badge.svg)](#backers) [![Sponsors on Open Collective](https://opencollective.com/govalidator/sponsors/badge.svg)](#sponsors) [![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fasaskevich%2Fgovalidator.svg?type=shield)](https://app.fossa.io/projects/git%2Bgithub.com%2Fasaskevich%2Fgovalidator?ref=badge_shield)\n\nA package of validators and sanitizers for strings, structs and collections. Based on [validator.js](https://github.com/chriso/validator.js).\n\n#### Installation\nMake sure that Go is installed on your computer.\nType the following command in your terminal:\n\n\tgo get github.com/asaskevich/govalidator/v11\n\nor you can get specified release of the package with `gopkg.in`:\n\n\tgo get gopkg.in/asaskevich/govalidator.v10\n\nAfter it the package is ready to use.\n\n\n#### Import package in your project\nAdd following line in your `*.go` file:\n```go\nimport \"github.com/asaskevich/govalidator/v11\"\n```\nIf you are unhappy to use long `govalidator`, you can do something like this:\n```go\nimport (\n  valid \"github.com/asaskevich/govalidator/v11\"\n)\n```\n\n#### Activate behavior to require all fields have a validation tag by default\n`SetFieldsRequiredByDefault` causes validation to fail when struct fields do not include validations or are not explicitly marked as exempt (using `valid:\"-\"` or `valid:\"email,optional\"`). A good place to activate this is a package init function or the main() function.\n\n`SetNilPtrAllowedByRequired` causes validation to pass when struct fields marked by `required` are set to nil. This is disabled by default for consistency, but some packages that need to be able to determine between `nil` and `zero value` state can use this. If disabled, both `nil` and `zero` values cause validation errors.\n\n```go\nimport \"github.com/asaskevich/govalidator/v11\"\n\nfunc init() {\n  govalidator.SetFieldsRequiredByDefault(true)\n}\n```\n\nHere's some code to explain it:\n```go\n// this struct definition will fail govalidator.ValidateStruct() (and the field values do not matter):\ntype exampleStruct struct {\n  Name  string ``\n  Email string `valid:\"email\"`\n}\n\n// this, however, will only fail when Email is empty or an invalid email address:\ntype exampleStruct2 struct {\n  Name  string `valid:\"-\"`\n  Email string `valid:\"email\"`\n}\n\n// lastly, this will only fail when Email is an invalid email address but not when it's empty:\ntype exampleStruct2 struct {\n  Name  string `valid:\"-\"`\n  Email string `valid:\"email,optional\"`\n}\n```\n\n#### Recent breaking changes (see [#123](https://github.com/asaskevich/govalidator/pull/123))\n##### Custom validator function signature\nA context was added as the second parameter, for structs this is the object being validated – this makes dependent validation possible.\n```go\nimport \"github.com/asaskevich/govalidator/v11\"\n\n// old signature\nfunc(i interface{}) bool\n\n// new signature\nfunc(i interface{}, o interface{}) bool\n```\n\n##### Adding a custom validator\nThis was changed to prevent data races when accessing custom validators.\n```go\nimport \"github.com/asaskevich/govalidator/v11\"\n\n// before\ngovalidator.CustomTypeTagMap[\"customByteArrayValidator\"] = func(i interface{}, o interface{}) bool {\n  // ...\n}\n\n// after\ngovalidator.CustomTypeTagMap.Set(\"customByteArrayValidator\", func(i interface{}, o interface{}) bool {\n  // ...\n})\n```\n\n#### List of functions:\n```go\nfunc Abs(value float64) float64\nfunc BlackList(str, chars string) string\nfunc ByteLength(str string, params ...string) bool\nfunc CamelCaseToUnderscore(str string) string\nfunc Contains(str, substring string) bool\nfunc Count(array []interface{}, iterator ConditionIterator) int\nfunc Each(array []interface{}, iterator Iterator)\nfunc ErrorByField(e error, field string) string\nfunc ErrorsByField(e error) map[string]string\nfunc Filter(array []interface{}, iterator ConditionIterator) []interface{}\nfunc Find(array []interface{}, iterator ConditionIterator) interface{}\nfunc GetLine(s string, index int) (string, error)\nfunc GetLines(s string) []string\nfunc HasLowerCase(str string) bool\nfunc HasUpperCase(str string) bool\nfunc HasWhitespace(str string) bool\nfunc HasWhitespaceOnly(str string) bool\nfunc InRange(value interface{}, left interface{}, right interface{}) bool\nfunc InRangeFloat32(value, left, right float32) bool\nfunc InRangeFloat64(value, left, right float64) bool\nfunc InRangeInt(value, left, right interface{}) bool\nfunc IsASCII(str string) bool\nfunc IsAlpha(str string) bool\nfunc IsAlphanumeric(str string) bool\nfunc IsBase64(str string) bool\nfunc IsByteLength(str string, min, max int) bool\nfunc IsCIDR(str string) bool\nfunc IsCRC32(str string) bool\nfunc IsCRC32b(str string) bool\nfunc IsCreditCard(str string) bool\nfunc IsDNSName(str string) bool\nfunc IsDataURI(str string) bool\nfunc IsDialString(str string) bool\nfunc IsDivisibleBy(str, num string) bool\nfunc IsEmail(str string) bool\nfunc IsExistingEmail(email string) bool\nfunc IsFilePath(str string) (bool, int)\nfunc IsFloat(str string) bool\nfunc IsFullWidth(str string) bool\nfunc IsHalfWidth(str string) bool\nfunc IsHash(str string, algorithm string) bool\nfunc IsHexadecimal(str string) bool\nfunc IsHexcolor(str string) bool\nfunc IsHost(str string) bool\nfunc IsIP(str string) bool\nfunc IsIPv4(str string) bool\nfunc IsIPv6(str string) bool\nfunc IsISBN(str string, version int) bool\nfunc IsISBN10(str string) bool\nfunc IsISBN13(str string) bool\nfunc IsISO3166Alpha2(str string) bool\nfunc IsISO3166Alpha3(str string) bool\nfunc IsISO4217(str string) bool\nfunc IsISO693Alpha2(str string) bool\nfunc IsISO693Alpha3b(str string) bool\nfunc IsIn(str string, params ...string) bool\nfunc IsInRaw(str string, params ...string) bool\nfunc IsInt(str string) bool\nfunc IsJSON(str string) bool\nfunc IsLatitude(str string) bool\nfunc IsLongitude(str string) bool\nfunc IsLowerCase(str string) bool\nfunc IsMAC(str string) bool\nfunc IsMD4(str string) bool\nfunc IsMD5(str string) bool\nfunc IsMagnetURI(str string) bool\nfunc IsMongoID(str string) bool\nfunc IsMultibyte(str string) bool\nfunc IsNatural(value float64) bool\nfunc IsNegative(value float64) bool\nfunc IsNonNegative(value float64) bool\nfunc IsNonPositive(value float64) bool\nfunc IsNotNull(str string) bool\nfunc IsNull(str string) bool\nfunc IsNumeric(str string) bool\nfunc IsPort(str string) bool\nfunc IsPositive(value float64) bool\nfunc IsPrintableASCII(str string) bool\nfunc IsRFC3339(str string) bool\nfunc IsRFC3339WithoutZone(str string) bool\nfunc IsRGBcolor(str string) bool\nfunc IsRegex(str string) bool\nfunc IsRequestURI(rawurl string) bool\nfunc IsRequestURL(rawurl string) bool\nfunc IsRipeMD128(str string) bool\nfunc IsRipeMD160(str string) bool\nfunc IsRsaPub(str string, params ...string) bool\nfunc IsRsaPublicKey(str string, keylen int) bool\nfunc IsSHA1(str string) bool\nfunc IsSHA256(str string) bool\nfunc IsSHA384(str string) bool\nfunc IsSHA512(str string) bool\nfunc IsSSN(str string) bool\nfunc IsSemver(str string) bool\nfunc IsTiger128(str string) bool\nfunc IsTiger160(str string) bool\nfunc IsTiger192(str string) bool\nfunc IsTime(str string, format string) bool\nfunc IsType(v interface{}, params ...string) bool\nfunc IsURL(str string) bool\nfunc IsUTFDigit(str string) bool\nfunc IsUTFLetter(str string) bool\nfunc IsUTFLetterNumeric(str string) bool\nfunc IsUTFNumeric(str string) bool\nfunc IsUUID(str string) bool\nfunc IsUUIDv3(str string) bool\nfunc IsUUIDv4(str string) bool\nfunc IsUUIDv5(str string) bool\nfunc IsULID(str string) bool\nfunc IsUnixTime(str string) bool\nfunc IsUpperCase(str string) bool\nfunc IsVariableWidth(str string) bool\nfunc IsWhole(value float64) bool\nfunc LeftTrim(str, chars string) string\nfunc Map(array []interface{}, iterator ResultIterator) []interface{}\nfunc Matches(str, pattern string) bool\nfunc MaxStringLength(str string, params ...string) bool\nfunc MinStringLength(str string, params ...string) bool\nfunc NormalizeEmail(str string) (string, error)\nfunc PadBoth(str string, padStr string, padLen int) string\nfunc PadLeft(str string, padStr string, padLen int) string\nfunc PadRight(str string, padStr string, padLen int) string\nfunc PrependPathToErrors(err error, path string) error\nfunc Range(str string, params ...string) bool\nfunc RemoveTags(s string) string\nfunc ReplacePattern(str, pattern, replace string) string\nfunc Reverse(s string) string\nfunc RightTrim(str, chars string) string\nfunc RuneLength(str string, params ...string) bool\nfunc SafeFileName(str string) string\nfunc SetFieldsRequiredByDefault(value bool)\nfunc SetNilPtrAllowedByRequired(value bool)\nfunc Sign(value float64) float64\nfunc StringLength(str string, params ...string) bool\nfunc StringMatches(s string, params ...string) bool\nfunc StripLow(str string, keepNewLines bool) string\nfunc ToBoolean(str string) (bool, error)\nfunc ToFloat(str string) (float64, error)\nfunc ToInt(value interface{}) (res int64, err error)\nfunc ToJSON(obj interface{}) (string, error)\nfunc ToString(obj interface{}) string\nfunc Trim(str, chars string) string\nfunc Truncate(str string, length int, ending string) string\nfunc TruncatingErrorf(str string, args ...interface{}) error\nfunc UnderscoreToCamelCase(s string) string\nfunc ValidateMap(inputMap map[string]interface{}, validationMap map[string]interface{}) (bool, error)\nfunc ValidateStruct(s interface{}) (bool, error)\nfunc WhiteList(str, chars string) string\ntype ConditionIterator\ntype CustomTypeValidator\ntype Error\nfunc (e Error) Error() string\ntype Errors\nfunc (es Errors) Error() string\nfunc (es Errors) Errors() []error\ntype ISO3166Entry\ntype ISO693Entry\ntype InterfaceParamValidator\ntype Iterator\ntype ParamValidator\ntype ResultIterator\ntype UnsupportedTypeError\nfunc (e *UnsupportedTypeError) Error() string\ntype Validator\n```\n\n#### Examples\n###### IsURL\n```go\nprintln(govalidator.IsURL(`http://user@pass:domain.com/path/page`))\n```\n###### IsType\n```go\nprintln(govalidator.IsType(\"Bob\", \"string\"))\nprintln(govalidator.IsType(1, \"int\"))\ni := 1\nprintln(govalidator.IsType(&i, \"*int\"))\n```\n\nIsType can be used through the tag `type` which is essential for map validation:\n```go\ntype User\tstruct {\n  Name string      `valid:\"type(string)\"`\n  Age  int         `valid:\"type(int)\"`\n  Meta interface{} `valid:\"type(string)\"`\n}\nresult, err := govalidator.ValidateStruct(User{\"Bob\", 20, \"meta\"})\nif err != nil {\n\tprintln(\"error: \" + err.Error())\n}\nprintln(result)\n```\n###### ToString\n```go\ntype User struct {\n\tFirstName string\n\tLastName string\n}\n\nstr := govalidator.ToString(&User{\"John\", \"Juan\"})\nprintln(str)\n```\n###### Each, Map, Filter, Count for slices\nEach iterates over the slice/array and calls Iterator for every item\n```go\ndata := []interface{}{1, 2, 3, 4, 5}\nvar fn govalidator.Iterator = func(value interface{}, index int) {\n\tprintln(value.(int))\n}\ngovalidator.Each(data, fn)\n```\n```go\ndata := []interface{}{1, 2, 3, 4, 5}\nvar fn govalidator.ResultIterator = func(value interface{}, index int) interface{} {\n\treturn value.(int) * 3\n}\n_ = govalidator.Map(data, fn) // result = []interface{}{1, 6, 9, 12, 15}\n```\n```go\ndata := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar fn govalidator.ConditionIterator = func(value interface{}, index int) bool {\n\treturn value.(int)%2 == 0\n}\n_ = govalidator.Filter(data, fn) // result = []interface{}{2, 4, 6, 8, 10}\n_ = govalidator.Count(data, fn) // result = 5\n```\n###### ValidateStruct [#2](https://github.com/asaskevich/govalidator/pull/2)\nIf you want to validate structs, you can use tag `valid` for any field in your structure. All validators used with this field in one tag are separated by comma. If you want to skip validation, place `-` in your tag. If you need a validator that is not on the list below, you can add it like this:\n```go\ngovalidator.TagMap[\"duck\"] = govalidator.Validator(func(str string) bool {\n\treturn str == \"duck\"\n})\n```\nFor completely custom validators (interface-based), see below.\n\nHere is a list of available validators for struct fields (validator - used function):\n```go\n\"email\":              IsEmail,\n\"url\":                IsURL,\n\"dialstring\":         IsDialString,\n\"requrl\":             IsRequestURL,\n\"requri\":             IsRequestURI,\n\"alpha\":              IsAlpha,\n\"utfletter\":          IsUTFLetter,\n\"alphanum\":           IsAlphanumeric,\n\"utfletternum\":       IsUTFLetterNumeric,\n\"numeric\":            IsNumeric,\n\"utfnumeric\":         IsUTFNumeric,\n\"utfdigit\":           IsUTFDigit,\n\"hexadecimal\":        IsHexadecimal,\n\"hexcolor\":           IsHexcolor,\n\"rgbcolor\":           IsRGBcolor,\n\"lowercase\":          IsLowerCase,\n\"uppercase\":          IsUpperCase,\n\"int\":                IsInt,\n\"float\":              IsFloat,\n\"null\":               IsNull,\n\"uuid\":               IsUUID,\n\"uuidv3\":             IsUUIDv3,\n\"uuidv4\":             IsUUIDv4,\n\"uuidv5\":             IsUUIDv5,\n\"creditcard\":         IsCreditCard,\n\"isbn10\":             IsISBN10,\n\"isbn13\":             IsISBN13,\n\"json\":               IsJSON,\n\"multibyte\":          IsMultibyte,\n\"ascii\":              IsASCII,\n\"printableascii\":     IsPrintableASCII,\n\"fullwidth\":          IsFullWidth,\n\"halfwidth\":          IsHalfWidth,\n\"variablewidth\":      IsVariableWidth,\n\"base64\":             IsBase64,\n\"datauri\":            IsDataURI,\n\"ip\":                 IsIP,\n\"port\":               IsPort,\n\"ipv4\":               IsIPv4,\n\"ipv6\":               IsIPv6,\n\"dns\":                IsDNSName,\n\"host\":               IsHost,\n\"mac\":                IsMAC,\n\"latitude\":           IsLatitude,\n\"longitude\":          IsLongitude,\n\"ssn\":                IsSSN,\n\"semver\":             IsSemver,\n\"rfc3339\":            IsRFC3339,\n\"rfc3339WithoutZone\": IsRFC3339WithoutZone,\n\"ISO3166Alpha2\":      IsISO3166Alpha2,\n\"ISO3166Alpha3\":      IsISO3166Alpha3,\n\"ulid\":               IsULID,\n```\nValidators with parameters\n\n```go\n\"range(min|max)\": Range,\n\"length(min|max)\": ByteLength,\n\"runelength(min|max)\": RuneLength,\n\"stringlength(min|max)\": StringLength,\n\"matches(pattern)\": StringMatches,\n\"in(string1|string2|...|stringN)\": IsIn,\n\"rsapub(keylength)\" : IsRsaPub,\n\"minstringlength(int): MinStringLength,\n\"maxstringlength(int): MaxStringLength,\n```\nValidators with parameters for any type\n\n```go\n\"type(type)\": IsType,\n```\n\nAnd here is small example of usage:\n```go\ntype Post struct {\n\tTitle    string `valid:\"alphanum,required\"`\n\tMessage  string `valid:\"duck,ascii\"`\n\tMessage2 string `valid:\"animal(dog)\"`\n\tAuthorIP string `valid:\"ipv4\"`\n\tDate     string `valid:\"-\"`\n}\npost := &Post{\n\tTitle:   \"My Example Post\",\n\tMessage: \"duck\",\n\tMessage2: \"dog\",\n\tAuthorIP: \"123.234.54.3\",\n}\n\n// Add your own struct validation tags\ngovalidator.TagMap[\"duck\"] = govalidator.Validator(func(str string) bool {\n\treturn str == \"duck\"\n})\n\n// Add your own struct validation tags with parameter\ngovalidator.ParamTagMap[\"animal\"] = govalidator.ParamValidator(func(str string, params ...string) bool {\n    species := params[0]\n    return str == species\n})\ngovalidator.ParamTagRegexMap[\"animal\"] = regexp.MustCompile(\"^animal\\\\((\\\\w+)\\\\)$\")\n\nresult, err := govalidator.ValidateStruct(post)\nif err != nil {\n\tprintln(\"error: \" + err.Error())\n}\nprintln(result)\n```\n###### ValidateMap [#2](https://github.com/asaskevich/govalidator/pull/338)\nIf you want to validate maps, you can use the map to be validated and a validation map that contain the same tags used in ValidateStruct, both maps have to be in the form `map[string]interface{}`\n\nSo here is small example of usage:\n```go\nvar mapTemplate = map[string]interface{}{\n\t\"name\":\"required,alpha\",\n\t\"family\":\"required,alpha\",\n\t\"email\":\"required,email\",\n\t\"cell-phone\":\"numeric\",\n\t\"address\":map[string]interface{}{\n\t\t\"line1\":\"required,alphanum\",\n\t\t\"line2\":\"alphanum\",\n\t\t\"postal-code\":\"numeric\",\n\t},\n}\n\nvar inputMap = map[string]interface{}{\n\t\"name\":\"Bob\",\n\t\"family\":\"Smith\",\n\t\"email\":\"foo@bar.baz\",\n\t\"address\":map[string]interface{}{\n\t\t\"line1\":\"\",\n\t\t\"line2\":\"\",\n\t\t\"postal-code\":\"\",\n\t},\n}\n\nresult, err := govalidator.ValidateMap(inputMap, mapTemplate)\nif err != nil {\n\tprintln(\"error: \" + err.Error())\n}\nprintln(result)\n```\n\n###### WhiteList\n```go\n// Remove all characters from string ignoring characters between \"a\" and \"z\"\nprintln(govalidator.WhiteList(\"a3a43a5a4a3a2a23a4a5a4a3a4\", \"a-z\") == \"aaaaaaaaaaaa\")\n```\n\n###### Custom validation functions\nCustom validation using your own domain specific validators is also available - here's an example of how to use it:\n```go\nimport \"github.com/asaskevich/govalidator/v11\"\n\ntype CustomByteArray [6]byte // custom types are supported and can be validated\n\ntype StructWithCustomByteArray struct {\n  ID              CustomByteArray `valid:\"customByteArrayValidator,customMinLengthValidator\"` // multiple custom validators are possible as well and will be evaluated in sequence\n  Email           string          `valid:\"email\"`\n  CustomMinLength int             `valid:\"-\"`\n}\n\ngovalidator.CustomTypeTagMap.Set(\"customByteArrayValidator\", func(i interface{}, context interface{}) bool {\n  switch v := context.(type) { // you can type switch on the context interface being validated\n  case StructWithCustomByteArray:\n    // you can check and validate against some other field in the context,\n    // return early or not validate against the context at all – your choice\n  case SomeOtherType:\n    // ...\n  default:\n    // expecting some other type? Throw/panic here or continue\n  }\n\n  switch v := i.(type) { // type switch on the struct field being validated\n  case CustomByteArray:\n    for _, e := range v { // this validator checks that the byte array is not empty, i.e. not all zeroes\n      if e != 0 {\n        return true\n      }\n    }\n  }\n  return false\n})\ngovalidator.CustomTypeTagMap.Set(\"customMinLengthValidator\", func(i interface{}, context interface{}) bool {\n  switch v := context.(type) { // this validates a field against the value in another field, i.e. dependent validation\n  case StructWithCustomByteArray:\n    return len(v.ID) >= v.CustomMinLength\n  }\n  return false\n})\n```\n\n###### Loop over Error()\nBy default .Error() returns all errors in a single String. To access each error you can do this:\n```go\n  if err != nil {\n    errs := err.(govalidator.Errors).Errors()\n    for _, e := range errs {\n      fmt.Println(e.Error())\n    }\n  }\n```\n\n###### Custom error messages\nCustom error messages are supported via annotations by adding the `~` separator - here's an example of how to use it:\n```go\ntype Ticket struct {\n  Id        int64     `json:\"id\"`\n  FirstName string    `json:\"firstname\" valid:\"required~First name is blank\"`\n}\n```\n\n#### Notes\nDocumentation is available here: [godoc.org](https://godoc.org/github.com/asaskevich/govalidator).\nFull information about code coverage is also available here: [govalidator on gocover.io](http://gocover.io/github.com/asaskevich/govalidator).\n\n#### Support\nIf you do have a contribution to the package, feel free to create a Pull Request or an Issue.\n\n#### What to contribute\nIf you don't know what to do, there are some features and functions that need to be done\n\n- [ ] Refactor code\n- [ ] Edit docs and [README](https://github.com/asaskevich/govalidator/README.md): spellcheck, grammar and typo check\n- [ ] Create actual list of contributors and projects that currently using this package\n- [ ] Resolve [issues and bugs](https://github.com/asaskevich/govalidator/issues)\n- [ ] Update actual [list of functions](https://github.com/asaskevich/govalidator#list-of-functions)\n- [ ] Update [list of validators](https://github.com/asaskevich/govalidator#validatestruct-2) that available for `ValidateStruct` and add new\n- [ ] Implement new validators: `IsFQDN`, `IsIMEI`, `IsPostalCode`, `IsISIN`, `IsISRC` etc\n- [x] Implement [validation by maps](https://github.com/asaskevich/govalidator/issues/224)\n- [ ] Implement fuzzing testing\n- [ ] Implement some struct/map/array utilities\n- [ ] Implement map/array validation\n- [ ] Implement benchmarking\n- [ ] Implement batch of examples\n- [ ] Look at forks for new features and fixes\n\n#### Advice\nFeel free to create what you want, but keep in mind when you implement new features:\n- Code must be clear and readable, names of variables/constants clearly describes what they are doing\n- Public functions must be documented and described in source file and added to README.md to the list of available functions\n- There are must be unit-tests for any new functions and improvements\n\n## Credits\n### Contributors\n\nThis project exists thanks to all the people who contribute. [[Contribute](CONTRIBUTING.md)].\n\n#### Special thanks to [contributors](https://github.com/asaskevich/govalidator/graphs/contributors)\n* [Daniel Lohse](https://github.com/annismckenzie)\n* [Attila Oláh](https://github.com/attilaolah)\n* [Daniel Korner](https://github.com/Dadie)\n* [Steven Wilkin](https://github.com/stevenwilkin)\n* [Deiwin Sarjas](https://github.com/deiwin)\n* [Noah Shibley](https://github.com/slugmobile)\n* [Nathan Davies](https://github.com/nathj07)\n* [Matt Sanford](https://github.com/mzsanford)\n* [Simon ccl1115](https://github.com/ccl1115)\n\n<a href=\"https://github.com/asaskevich/govalidator/graphs/contributors\"><img src=\"https://opencollective.com/govalidator/contributors.svg?width=890\" /></a>\n\n\n### Backers\n\nThank you to all our backers! 🙏 [[Become a backer](https://opencollective.com/govalidator#backer)]\n\n<a href=\"https://opencollective.com/govalidator#backers\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/backers.svg?width=890\"></a>\n\n\n### Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/govalidator#sponsor)]\n\n<a href=\"https://opencollective.com/govalidator/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/govalidator/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/govalidator/sponsor/9/avatar.svg\"></a>\n\n\n\n\n## License\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fasaskevich%2Fgovalidator.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fasaskevich%2Fgovalidator?ref=badge_large)\n"
        },
        {
          "name": "arrays.go",
          "type": "blob",
          "size": 2.8271484375,
          "content": "package govalidator\n\n// Iterator is the function that accepts element of slice/array and its index\ntype Iterator func(interface{}, int)\n\n// ResultIterator is the function that accepts element of slice/array and its index and returns any result\ntype ResultIterator func(interface{}, int) interface{}\n\n// ConditionIterator is the function that accepts element of slice/array and its index and returns boolean\ntype ConditionIterator func(interface{}, int) bool\n\n// ReduceIterator is the function that accepts two element of slice/array and returns result of merging those values\ntype ReduceIterator func(interface{}, interface{}) interface{}\n\n// Some validates that any item of array corresponds to ConditionIterator. Returns boolean.\nfunc Some(array []interface{}, iterator ConditionIterator) bool {\n\tres := false\n\tfor index, data := range array {\n\t\tres = res || iterator(data, index)\n\t}\n\treturn res\n}\n\n// Every validates that every item of array corresponds to ConditionIterator. Returns boolean.\nfunc Every(array []interface{}, iterator ConditionIterator) bool {\n\tres := true\n\tfor index, data := range array {\n\t\tres = res && iterator(data, index)\n\t}\n\treturn res\n}\n\n// Reduce boils down a list of values into a single value by ReduceIterator\nfunc Reduce(array []interface{}, iterator ReduceIterator, initialValue interface{}) interface{} {\n\tfor _, data := range array {\n\t\tinitialValue = iterator(initialValue, data)\n\t}\n\treturn initialValue\n}\n\n// Each iterates over the slice and apply Iterator to every item\nfunc Each(array []interface{}, iterator Iterator) {\n\tfor index, data := range array {\n\t\titerator(data, index)\n\t}\n}\n\n// Map iterates over the slice and apply ResultIterator to every item. Returns new slice as a result.\nfunc Map(array []interface{}, iterator ResultIterator) []interface{} {\n\tvar result = make([]interface{}, len(array))\n\tfor index, data := range array {\n\t\tresult[index] = iterator(data, index)\n\t}\n\treturn result\n}\n\n// Find iterates over the slice and apply ConditionIterator to every item. Returns first item that meet ConditionIterator or nil otherwise.\nfunc Find(array []interface{}, iterator ConditionIterator) interface{} {\n\tfor index, data := range array {\n\t\tif iterator(data, index) {\n\t\t\treturn data\n\t\t}\n\t}\n\treturn nil\n}\n\n// Filter iterates over the slice and apply ConditionIterator to every item. Returns new slice.\nfunc Filter(array []interface{}, iterator ConditionIterator) []interface{} {\n\tvar result = make([]interface{}, 0)\n\tfor index, data := range array {\n\t\tif iterator(data, index) {\n\t\t\tresult = append(result, data)\n\t\t}\n\t}\n\treturn result\n}\n\n// Count iterates over the slice and apply ConditionIterator to every item. Returns count of items that meets ConditionIterator.\nfunc Count(array []interface{}, iterator ConditionIterator) int {\n\tcount := 0\n\tfor index, data := range array {\n\t\tif iterator(data, index) {\n\t\t\tcount = count + 1\n\t\t}\n\t}\n\treturn count\n}\n"
        },
        {
          "name": "arrays_benchmark_test.go",
          "type": "blob",
          "size": 1.55078125,
          "content": "package govalidator\n\n// Benchmark testing is produced with randomly filled array of 1 million elements\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc randomInt(min, max int) int {\n\treturn min + rand.Intn(max-min)\n}\n\nfunc randomArray(n int) (res []interface{}) {\n\tres = make([]interface{}, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = randomInt(-1000, 1000)\n\t}\n\n\treturn\n}\n\nfunc BenchmarkEach(b *testing.B) {\n\tdata := randomArray(1000000)\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tacc := 0\n\t\tvar fn Iterator = func(value interface{}, index int) {\n\t\t\tacc = acc + value.(int)\n\t\t}\n\t\tEach(data, fn)\n\t}\n}\n\nfunc BenchmarkMap(b *testing.B) {\n\tdata := randomArray(1000000)\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tvar fn ResultIterator = func(value interface{}, index int) interface{} {\n\t\t\treturn value.(int) * 3\n\t\t}\n\t\t_ = Map(data, fn)\n\t}\n}\n\nfunc BenchmarkFind(b *testing.B) {\n\tdata := randomArray(1000000)\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tfindElement := 96\n\t\tvar fn1 ConditionIterator = func(value interface{}, index int) bool {\n\t\t\treturn value.(int) == findElement\n\t\t}\n\t\t_ = Find(data, fn1)\n\t}\n}\n\nfunc BenchmarkFilter(b *testing.B) {\n\tdata := randomArray(1000000)\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\t\treturn value.(int)%2 == 0\n\t\t}\n\t\t_ = Filter(data, fn)\n\t}\n}\n\nfunc BenchmarkCount(b *testing.B) {\n\tdata := randomArray(1000000)\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\t\treturn value.(int)%2 == 0\n\t\t}\n\t\t_ = Count(data, fn)\n\t}\n}\n"
        },
        {
          "name": "arrays_example_test.go",
          "type": "blob",
          "size": 1.03515625,
          "content": "package govalidator\n\nfunc ExampleFilter() {\n\tdata := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int)%2 == 0\n\t}\n\t_ = Filter(data, fn) // result = []interface{}{2, 4, 6, 8, 10}\n}\n\nfunc ExampleCount() {\n\tdata := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int)%2 == 0\n\t}\n\t_ = Count(data, fn) // result = 5\n}\n\nfunc ExampleMap() {\n\tdata := []interface{}{1, 2, 3, 4, 5}\n\tvar fn ResultIterator = func(value interface{}, index int) interface{} {\n\t\treturn value.(int) * 3\n\t}\n\t_ = Map(data, fn) // result = []interface{}{1, 6, 9, 12, 15}\n}\n\nfunc ExampleEach() {\n\tdata := []interface{}{1, 2, 3, 4, 5}\n\tvar fn Iterator = func(value interface{}, index int) {\n\t\tprintln(value.(int))\n\t}\n\tEach(data, fn)\n}\n\nfunc ExampleFind() {\n\tdata := []interface{}{1, 2, 3, 4, 5}\n\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int) == 4\n\t}\n\t_ = Find(data, fn) // result = 4\n}\n"
        },
        {
          "name": "arrays_test.go",
          "type": "blob",
          "size": 2.0576171875,
          "content": "package govalidator\n\nimport \"testing\"\n\nfunc TestEach(t *testing.T) {\n\t// TODO Maybe refactor?\n\tt.Parallel()\n\tacc := 0\n\tdata := []interface{}{1, 2, 3, 4, 5}\n\tvar fn Iterator = func(value interface{}, index int) {\n\t\tacc = acc + value.(int)\n\t}\n\tEach(data, fn)\n\tif acc != 15 {\n\t\tt.Errorf(\"Expected Each(..) to be %v, got %v\", 15, acc)\n\t}\n}\n\nfunc TestMap(t *testing.T) {\n\t// TODO Maybe refactor?\n\tt.Parallel()\n\tdata := []interface{}{1, 2, 3, 4, 5}\n\tvar fn ResultIterator = func(value interface{}, index int) interface{} {\n\t\treturn value.(int) * 3\n\t}\n\tresult := Map(data, fn)\n\tfor i, d := range result {\n\t\tif d != fn(data[i], i) {\n\t\t\tt.Errorf(\"Expected Map(..) to be %v, got %v\", fn(data[i], i), d)\n\t\t}\n\t}\n}\n\nfunc TestFind(t *testing.T) {\n\t// TODO Maybe refactor?\n\tt.Parallel()\n\tfindElement := 96\n\tdata := []interface{}{1, 2, 3, 4, findElement, 5}\n\tvar fn1 ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int) == findElement\n\t}\n\tvar fn2 ConditionIterator = func(value interface{}, index int) bool {\n\t\tvalue, _ = value.(string)\n\t\treturn value == \"govalidator\"\n\t}\n\tval1 := Find(data, fn1)\n\tval2 := Find(data, fn2)\n\tif val1 != findElement {\n\t\tt.Errorf(\"Expected Find(..) to be %v, got %v\", findElement, val1)\n\t}\n\tif val2 != nil {\n\t\tt.Errorf(\"Expected Find(..) to be %v, got %v\", nil, val2)\n\t}\n}\n\nfunc TestFilter(t *testing.T) {\n\t// TODO Maybe refactor?\n\tt.Parallel()\n\tdata := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tanswer := []interface{}{2, 4, 6, 8, 10}\n\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int)%2 == 0\n\t}\n\tresult := Filter(data, fn)\n\tfor i := range result {\n\t\tif result[i] != answer[i] {\n\t\t\tt.Errorf(\"Expected Filter(..) to be %v, got %v\", answer[i], result[i])\n\t\t}\n\t}\n}\n\nfunc TestCount(t *testing.T) {\n\t// TODO Maybe refactor?\n\tt.Parallel()\n\tdata := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tcount := 5\n\tvar fn ConditionIterator = func(value interface{}, index int) bool {\n\t\treturn value.(int)%2 == 0\n\t}\n\tresult := Count(data, fn)\n\tif result != count {\n\t\tt.Errorf(\"Expected Count(..) to be %v, got %v\", count, result)\n\t}\n}\n"
        },
        {
          "name": "converter.go",
          "type": "blob",
          "size": 1.7724609375,
          "content": "package govalidator\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\n// ToString convert the input to a string.\nfunc ToString(obj interface{}) string {\n\tres := fmt.Sprintf(\"%v\", obj)\n\treturn res\n}\n\n// ToJSON convert the input to a valid JSON string\nfunc ToJSON(obj interface{}) (string, error) {\n\tres, err := json.Marshal(obj)\n\tif err != nil {\n\t\tres = []byte(\"\")\n\t}\n\treturn string(res), err\n}\n\n// ToFloat convert the input string to a float, or 0.0 if the input is not a float.\nfunc ToFloat(value interface{}) (res float64, err error) {\n\tval := reflect.ValueOf(value)\n\n\tswitch value.(type) {\n\tcase int, int8, int16, int32, int64:\n\t\tres = float64(val.Int())\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\tres = float64(val.Uint())\n\tcase float32, float64:\n\t\tres = val.Float()\n\tcase string:\n\t\tres, err = strconv.ParseFloat(val.String(), 64)\n\t\tif err != nil {\n\t\t\tres = 0\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"ToInt: unknown interface type %T\", value)\n\t\tres = 0\n\t}\n\n\treturn\n}\n\n// ToInt convert the input string or any int type to an integer type 64, or 0 if the input is not an integer.\nfunc ToInt(value interface{}) (res int64, err error) {\n\tval := reflect.ValueOf(value)\n\n\tswitch value.(type) {\n\tcase int, int8, int16, int32, int64:\n\t\tres = val.Int()\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\tres = int64(val.Uint())\n\tcase float32, float64:\n\t\tres = int64(val.Float())\n\tcase string:\n\t\tif IsInt(val.String()) {\n\t\t\tres, err = strconv.ParseInt(val.String(), 0, 64)\n\t\t\tif err != nil {\n\t\t\t\tres = 0\n\t\t\t}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"ToInt: invalid numeric format %g\", value)\n\t\t\tres = 0\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"ToInt: unknown interface type %T\", value)\n\t\tres = 0\n\t}\n\n\treturn\n}\n\n// ToBoolean convert the input string to a boolean.\nfunc ToBoolean(str string) (bool, error) {\n\treturn strconv.ParseBool(str)\n}\n"
        },
        {
          "name": "converter_benchmark_test.go",
          "type": "blob",
          "size": 0.6435546875,
          "content": "package govalidator\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkToBoolean(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_, _ = ToBoolean(\"False    \")\n\t}\n}\n\nfunc BenchmarkToInt(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_, _ = ToInt(\"-22342342.2342\")\n\t}\n}\n\nfunc BenchmarkToFloat(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_, _ = ToFloat(\"-22342342.2342\")\n\t}\n}\n\nfunc BenchmarkToString(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tToString(randomArray(1000000))\n\t}\n}\n\nfunc BenchmarkToJson(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_, _ = ToJSON(randomArray(1000000))\n\t}\n}\n"
        },
        {
          "name": "converter_example_test.go",
          "type": "blob",
          "size": 0.9482421875,
          "content": "package govalidator\n\nimport \"time\"\n\nfunc ExampleToBoolean() {\n\t// Returns the boolean value represented by the string.\n\t// It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\n\t// Any other value returns an error.\n\t_, _ = ToBoolean(\"false\")  // false, nil\n\t_, _ = ToBoolean(\"T\")      // true, nil\n\t_, _ = ToBoolean(\"123123\") // false, error\n}\n\nfunc ExampleToInt() {\n\t_, _ = ToInt(1.0)     // 1, nil\n\t_, _ = ToInt(\"-124\")  // -124, nil\n\t_, _ = ToInt(\"false\") // 0, error\n}\n\nfunc ExampleToFloat() {\n\t_, _ = ToFloat(\"-124.2e123\") // -124.2e123, nil\n\t_, _ = ToFloat(\"false\")      // 0, error\n}\n\nfunc ExampleToString() {\n\t_ = ToString(new(interface{}))        // 0xc000090200\n\t_ = ToString(time.Second + time.Hour) // 1h1s\n\t_ = ToString(123)                     // 123\n}\n\nfunc ExampleToJSON() {\n\t_, _ = ToJSON([]int{1, 2, 3})          // [1, 2, 3]\n\t_, _ = ToJSON(map[int]int{1: 2, 2: 3}) // { \"1\": 2, \"2\": 3 }\n\t_, _ = ToJSON(func() {})               // error\n}\n"
        },
        {
          "name": "converter_test.go",
          "type": "blob",
          "size": 2.326171875,
          "content": "package govalidator\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestToInt(t *testing.T) {\n\ttests := []interface{}{\"1000\", \"-123\", \"abcdef\", \"100000000000000000000000000000000000000000000\", false}\n\texpected := []int64{1000, -123, 0, 0, 0}\n\tfor i := 0; i < len(tests); i++ {\n\t\tresult, _ := ToInt(tests[i])\n\t\tif result != expected[i] {\n\t\t\tt.Log(\"Case \", i, \": expected \", expected[i], \" when result is \", result)\n\t\t\tt.FailNow()\n\t\t}\n\t}\n}\n\nfunc TestToBoolean(t *testing.T) {\n\ttests := []string{\"true\", \"1\", \"True\", \"false\", \"0\", \"abcdef\"}\n\texpected := []bool{true, true, true, false, false, false}\n\tfor i := 0; i < len(tests); i++ {\n\t\tres, _ := ToBoolean(tests[i])\n\t\tif res != expected[i] {\n\t\t\tt.Log(\"Case \", i, \": expected \", expected[i], \" when result is \", res)\n\t\t\tt.FailNow()\n\t\t}\n\t}\n}\n\nfunc toString(t *testing.T, test interface{}, expected string) {\n\tres := ToString(test)\n\tif res != expected {\n\t\tt.Log(\"Case ToString: expected \", expected, \" when result is \", res)\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestToString(t *testing.T) {\n\ttoString(t, \"str123\", \"str123\")\n\ttoString(t, 123, \"123\")\n\ttoString(t, 12.3, \"12.3\")\n\ttoString(t, true, \"true\")\n\ttoString(t, 1.5+10i, \"(1.5+10i)\")\n\t// Sprintf function not guarantee that maps with equal keys always will be equal in string  representation\n\t//toString(t, struct{ Keys map[int]int }{Keys: map[int]int{1: 2, 3: 4}}, \"{map[1:2 3:4]}\")\n}\n\nfunc TestToFloat(t *testing.T) {\n\ttests := []string{\"\", \"123\", \"-.01\", \"10.\", \"string\", \"1.23e3\", \".23e10\"}\n\texpected := []float64{0, 123, -0.01, 10.0, 0, 1230, 0.23e10}\n\tfor i := 0; i < len(tests); i++ {\n\t\tres, _ := ToFloat(tests[i])\n\t\tif res != expected[i] {\n\t\t\tt.Log(\"Case \", i, \": expected \", expected[i], \" when result is \", res)\n\t\t\tt.FailNow()\n\t\t}\n\t}\n}\n\nfunc TestToJSON(t *testing.T) {\n\ttests := []interface{}{\"test\", map[string]string{\"a\": \"b\", \"b\": \"c\"}, func() error { return fmt.Errorf(\"Error\") }}\n\texpected := [][]string{\n\t\t{\"\\\"test\\\"\", \"<nil>\"},\n\t\t{\"{\\\"a\\\":\\\"b\\\",\\\"b\\\":\\\"c\\\"}\", \"<nil>\"},\n\t\t{\"\", \"json: unsupported type: func() error\"},\n\t}\n\tfor i, test := range tests {\n\t\tactual, err := ToJSON(test)\n\t\tif actual != expected[i][0] {\n\t\t\tt.Errorf(\"Expected toJSON(%v) to return '%v', got '%v'\", test, expected[i][0], actual)\n\t\t}\n\t\tif fmt.Sprintf(\"%v\", err) != expected[i][1] {\n\t\t\tt.Errorf(\"Expected error returned from toJSON(%v) to return '%v', got '%v'\", test, expected[i][1], fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1015625,
          "content": "package govalidator\n\n// A package of validators and sanitizers for strings, structures and collections.\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 0.9150390625,
          "content": "package govalidator\n\nimport (\n\t\"sort\"\n\t\"strings\"\n)\n\n// Errors is an array of multiple errors and conforms to the error interface.\ntype Errors []error\n\n// Errors returns itself.\nfunc (es Errors) Errors() []error {\n\treturn es\n}\n\nfunc (es Errors) Error() string {\n\tvar errs []string\n\tfor _, e := range es {\n\t\terrs = append(errs, e.Error())\n\t}\n\tsort.Strings(errs)\n\treturn strings.Join(errs, \";\")\n}\n\n// Error encapsulates a name, an error and whether there's a custom error message or not.\ntype Error struct {\n\tName                     string\n\tErr                      error\n\tCustomErrorMessageExists bool\n\n\t// Validator indicates the name of the validator that failed\n\tValidator string\n\tPath      []string\n}\n\nfunc (e Error) Error() string {\n\tif e.CustomErrorMessageExists {\n\t\treturn e.Err.Error()\n\t}\n\n\terrName := e.Name\n\tif len(e.Path) > 0 {\n\t\terrName = strings.Join(append(e.Path, e.Name), \".\")\n\t}\n\n\treturn errName + \": \" + e.Err.Error()\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 0.8896484375,
          "content": "package govalidator\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestErrorsToString(t *testing.T) {\n\tt.Parallel()\n\tcustomErr := &Error{Name: \"Custom Error Name\", Err: fmt.Errorf(\"stdlib error\")}\n\tcustomErrWithCustomErrorMessage := &Error{Name: \"Custom Error Name 2\", Err: fmt.Errorf(\"Bad stuff happened\"), CustomErrorMessageExists: true}\n\n\tvar tests = []struct {\n\t\tparam1   Errors\n\t\texpected string\n\t}{\n\t\t{Errors{}, \"\"},\n\t\t{Errors{fmt.Errorf(\"Error 1\")}, \"Error 1\"},\n\t\t{Errors{fmt.Errorf(\"Error 1\"), fmt.Errorf(\"Error 2\")}, \"Error 1;Error 2\"},\n\t\t{Errors{customErr, fmt.Errorf(\"Error 2\")}, \"Custom Error Name: stdlib error;Error 2\"},\n\t\t{Errors{fmt.Errorf(\"Error 123\"), customErrWithCustomErrorMessage}, \"Bad stuff happened;Error 123\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := test.param1.Error()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Error() to return '%v', got '%v'\", test.expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.052734375,
          "content": "module github.com/asaskevich/govalidator/v11\n\ngo 1.13\n"
        },
        {
          "name": "numerics.go",
          "type": "blob",
          "size": 2.5390625,
          "content": "package govalidator\n\nimport (\n\t\"math\"\n)\n\n// Abs returns absolute value of number\nfunc Abs(value float64) float64 {\n\treturn math.Abs(value)\n}\n\n// Sign returns signum of number: 1 in case of value > 0, -1 in case of value < 0, 0 otherwise\nfunc Sign(value float64) float64 {\n\tif value > 0 {\n\t\treturn 1\n\t} else if value < 0 {\n\t\treturn -1\n\t} else {\n\t\treturn 0\n\t}\n}\n\n// IsNegative returns true if value < 0\nfunc IsNegative(value float64) bool {\n\treturn value < 0\n}\n\n// IsPositive returns true if value > 0\nfunc IsPositive(value float64) bool {\n\treturn value > 0\n}\n\n// IsNonNegative returns true if value >= 0\nfunc IsNonNegative(value float64) bool {\n\treturn value >= 0\n}\n\n// IsNonPositive returns true if value <= 0\nfunc IsNonPositive(value float64) bool {\n\treturn value <= 0\n}\n\n// InRangeInt returns true if value lies between left and right border\nfunc InRangeInt(value, left, right interface{}) bool {\n\tvalue64, _ := ToInt(value)\n\tleft64, _ := ToInt(left)\n\tright64, _ := ToInt(right)\n\tif left64 > right64 {\n\t\tleft64, right64 = right64, left64\n\t}\n\treturn value64 >= left64 && value64 <= right64\n}\n\n// InRangeFloat32 returns true if value lies between left and right border\nfunc InRangeFloat32(value, left, right float32) bool {\n\tif left > right {\n\t\tleft, right = right, left\n\t}\n\treturn value >= left && value <= right\n}\n\n// InRangeFloat64 returns true if value lies between left and right border\nfunc InRangeFloat64(value, left, right float64) bool {\n\tif left > right {\n\t\tleft, right = right, left\n\t}\n\treturn value >= left && value <= right\n}\n\n// InRange returns true if value lies between left and right border, generic type to handle int, float32, float64 and string.\n// All types must the same type.\n// False if value doesn't lie in range or if it incompatible or not comparable\nfunc InRange(value interface{}, left interface{}, right interface{}) bool {\n\tswitch value.(type) {\n\tcase int:\n\t\tintValue, _ := ToInt(value)\n\t\tintLeft, _ := ToInt(left)\n\t\tintRight, _ := ToInt(right)\n\t\treturn InRangeInt(intValue, intLeft, intRight)\n\tcase float32, float64:\n\t\tintValue, _ := ToFloat(value)\n\t\tintLeft, _ := ToFloat(left)\n\t\tintRight, _ := ToFloat(right)\n\t\treturn InRangeFloat64(intValue, intLeft, intRight)\n\tcase string:\n\t\treturn value.(string) >= left.(string) && value.(string) <= right.(string)\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// IsWhole returns true if value is whole number\nfunc IsWhole(value float64) bool {\n\treturn math.Remainder(value, 1) == 0\n}\n\n// IsNatural returns true if value is natural number (positive and whole)\nfunc IsNatural(value float64) bool {\n\treturn IsWhole(value) && IsPositive(value)\n}\n"
        },
        {
          "name": "numerics_benchmark_test.go",
          "type": "blob",
          "size": 1.44140625,
          "content": "package govalidator\n\nimport \"testing\"\n\nfunc BenchmarkAbs(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = Abs(-123.3e1)\n\t}\n}\n\nfunc BenchmarkSign(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = Sign(-123.3e1)\n\t}\n}\n\nfunc BenchmarkIsNegative(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsNegative(-123.3e1)\n\t}\n}\n\nfunc BenchmarkIsPositive(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsPositive(-123.3e1)\n\t}\n}\n\nfunc BenchmarkIsNonNegative(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsNonNegative(-123.3e1)\n\t}\n}\n\nfunc BenchmarkIsNonPositive(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsNonPositive(-123.3e1)\n\t}\n}\n\nfunc BenchmarkInRangeInt(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = InRangeInt(10, -100, 100)\n\t}\n}\n\nfunc BenchmarkInRangeFloat32(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = InRangeFloat32(10, -100, 100)\n\t}\n}\n\nfunc BenchmarkInRangeFloat64(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = InRangeFloat64(10, -100, 100)\n\t}\n}\n\nfunc BenchmarkInRange(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = InRange(\"abc\", \"a\", \"cba\")\n\t}\n}\n\nfunc BenchmarkIsWhole(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsWhole(123.132)\n\t}\n}\n\nfunc BenchmarkIsNatural(b *testing.B) {\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = IsNatural(123.132)\n\t}\n}\n"
        },
        {
          "name": "numerics_example_test.go",
          "type": "blob",
          "size": 1.6025390625,
          "content": "package govalidator\n\nfunc ExampleAbs() {\n\t_ = Abs(-123.3e1) // 123.3e1\n\t_ = Abs(+0)       // 0\n\t_ = Abs(321)      // 321\n}\n\nfunc ExampleSign() {\n\t_ = Sign(-123) // -1\n\t_ = Sign(123)  // 1\n\t_ = Sign(0)    // 0\n}\n\nfunc ExampleIsNegative() {\n\t_ = IsNegative(-123) // true\n\t_ = IsNegative(0)    // false\n\t_ = IsNegative(123)  // false\n}\n\nfunc ExampleIsPositive() {\n\t_ = IsPositive(-123) // false\n\t_ = IsPositive(0)    // false\n\t_ = IsPositive(123)  // true\n}\n\nfunc ExampleIsNonNegative() {\n\t_ = IsNonNegative(-123) // false\n\t_ = IsNonNegative(0)    // true\n\t_ = IsNonNegative(123)  // true\n}\n\nfunc ExampleIsNonPositive() {\n\t_ = IsNonPositive(-123) // true\n\t_ = IsNonPositive(0)    // true\n\t_ = IsNonPositive(123)  // false\n}\n\nfunc ExampleInRangeInt() {\n\t_ = InRangeInt(10, -10, 10) // true\n\t_ = InRangeInt(10, 10, 20)  // true\n\t_ = InRangeInt(10, 11, 20)  // false\n}\n\nfunc ExampleInRangeFloat32() {\n\t_ = InRangeFloat32(10.02, -10.124, 10.234) // true\n\t_ = InRangeFloat32(10.123, 10.123, 20.431) // true\n\t_ = InRangeFloat32(10.235, 11.124, 20.235) // false\n}\n\nfunc ExampleInRangeFloat64() {\n\t_ = InRangeFloat64(10.02, -10.124, 10.234) // true\n\t_ = InRangeFloat64(10.123, 10.123, 20.431) // true\n\t_ = InRangeFloat64(10.235, 11.124, 20.235) // false\n}\n\nfunc ExampleInRange() {\n\t_ = InRange(10, 11, 20)             // false\n\t_ = InRange(10.02, -10.124, 10.234) // true\n\t_ = InRange(\"abc\", \"a\", \"cba\")      // true\n}\n\nfunc ExampleIsWhole() {\n\t_ = IsWhole(1.123) // false\n\t_ = IsWhole(1.0)   // true\n\t_ = IsWhole(10)    // true\n}\n\nfunc ExampleIsNatural() {\n\t_ = IsNatural(1.123) // false\n\t_ = IsNatural(1.0)   // true\n\t_ = IsNatural(-10)   // false\n}\n"
        },
        {
          "name": "numerics_test.go",
          "type": "blob",
          "size": 11.833984375,
          "content": "package govalidator\n\nimport \"testing\"\n\nfunc TestAbs(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected float64\n\t}{\n\t\t{0, 0},\n\t\t{-1, 1},\n\t\t{10, 10},\n\t\t{3.14, 3.14},\n\t\t{-96, 96},\n\t\t{-10e-12, 10e-12},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Abs(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Abs(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestSign(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected float64\n\t}{\n\t\t{0, 0},\n\t\t{-1, -1},\n\t\t{10, 1},\n\t\t{3.14, 1},\n\t\t{-96, -1},\n\t\t{-10e-12, -1},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Sign(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Sign(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNegative(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, false},\n\t\t{-1, true},\n\t\t{10, false},\n\t\t{3.14, false},\n\t\t{-96, true},\n\t\t{-10e-12, true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNegative(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNegative(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNonNegative(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, true},\n\t\t{-1, false},\n\t\t{10, true},\n\t\t{3.14, true},\n\t\t{-96, false},\n\t\t{-10e-12, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNonNegative(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNonNegative(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsPositive(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, false},\n\t\t{-1, false},\n\t\t{10, true},\n\t\t{3.14, true},\n\t\t{-96, false},\n\t\t{-10e-12, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsPositive(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsPositive(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNonPositive(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, true},\n\t\t{-1, true},\n\t\t{10, false},\n\t\t{3.14, false},\n\t\t{-96, true},\n\t\t{-10e-12, true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNonPositive(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNonPositive(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsWhole(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, true},\n\t\t{-1, true},\n\t\t{10, true},\n\t\t{3.14, false},\n\t\t{-96, true},\n\t\t{-10e-12, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsWhole(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsWhole(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNatural(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\texpected bool\n\t}{\n\t\t{0, false},\n\t\t{-1, false},\n\t\t{10, true},\n\t\t{3.14, false},\n\t\t{96, true},\n\t\t{-10e-12, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNatural(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNatural(%v) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestInRangeInt(t *testing.T) {\n\tt.Parallel()\n\n\tvar testAsInts = []struct {\n\t\tparam    int\n\t\tleft     int\n\t\tright    int\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsInts {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type int\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsInt8s = []struct {\n\t\tparam    int8\n\t\tleft     int8\n\t\tright    int8\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsInt8s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type int8\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsInt16s = []struct {\n\t\tparam    int16\n\t\tleft     int16\n\t\tright    int16\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsInt16s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type int16\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsInt32s = []struct {\n\t\tparam    int32\n\t\tleft     int32\n\t\tright    int32\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsInt32s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type int32\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsInt64s = []struct {\n\t\tparam    int64\n\t\tleft     int64\n\t\tright    int64\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsInt64s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type int64\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsUInts = []struct {\n\t\tparam    uint\n\t\tleft     uint\n\t\tright    uint\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{0, 0, 1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsUInts {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type uint\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsUInt8s = []struct {\n\t\tparam    uint8\n\t\tleft     uint8\n\t\tright    uint8\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{0, 0, 1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsUInt8s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type uint\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsUInt16s = []struct {\n\t\tparam    uint16\n\t\tleft     uint16\n\t\tright    uint16\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{0, 0, 1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsUInt16s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type uint\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsUInt32s = []struct {\n\t\tparam    uint32\n\t\tleft     uint32\n\t\tright    uint32\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{0, 0, 1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsUInt32s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type uint\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsUInt64s = []struct {\n\t\tparam    uint64\n\t\tleft     uint64\n\t\tright    uint64\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{0, 0, 1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testAsUInt64s {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type uint\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testAsStrings = []struct {\n\t\tparam    string\n\t\tleft     string\n\t\tright    string\n\t\texpected bool\n\t}{\n\t\t{\"0\", \"0\", \"0\", true},\n\t\t{\"1\", \"0\", \"0\", false},\n\t\t{\"-1\", \"0\", \"0\", false},\n\t\t{\"0\", \"-1\", \"1\", true},\n\t\t{\"0\", \"0\", \"1\", true},\n\t\t{\"0\", \"-1\", \"0\", true},\n\t\t{\"0\", \"0\", \"-1\", true},\n\t\t{\"0\", \"10\", \"5\", false},\n\t}\n\tfor _, test := range testAsStrings {\n\t\tactual := InRangeInt(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeInt(%v, %v, %v) to be %v, got %v using type string\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestInRangeFloat32(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float32\n\t\tleft     float32\n\t\tright    float32\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := InRangeFloat32(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeFloat32(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestInRangeFloat64(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    float64\n\t\tleft     float64\n\t\tright    float64\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := InRangeFloat64(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRangeFloat64(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestInRange(t *testing.T) {\n\tt.Parallel()\n\n\tvar testsInt = []struct {\n\t\tparam    int\n\t\tleft     int\n\t\tright    int\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testsInt {\n\t\tactual := InRange(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRange(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testsFloat32 = []struct {\n\t\tparam    float32\n\t\tleft     float32\n\t\tright    float32\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testsFloat32 {\n\t\tactual := InRange(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRange(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testsFloat64 = []struct {\n\t\tparam    float64\n\t\tleft     float64\n\t\tright    float64\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testsFloat64 {\n\t\tactual := InRange(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRange(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n\n\tvar testsTypeMix = []struct {\n\t\tparam    int\n\t\tleft     float64\n\t\tright    float64\n\t\texpected bool\n\t}{\n\t\t{0, 0, 0, true},\n\t\t{1, 0, 0, false},\n\t\t{-1, 0, 0, false},\n\t\t{0, -1, 1, true},\n\t\t{0, 0, 1, true},\n\t\t{0, -1, 0, true},\n\t\t{0, 0, -1, true},\n\t\t{0, 10, 5, false},\n\t}\n\tfor _, test := range testsTypeMix {\n\t\tactual := InRange(test.param, test.left, test.right)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected InRange(%v, %v, %v) to be %v, got %v\", test.param, test.left, test.right, test.expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "patterns.go",
          "type": "blob",
          "size": 8.30078125,
          "content": "package govalidator\n\nimport \"regexp\"\n\n// Basic regular expressions for validating strings\nconst (\n\tEmail             string = \"^(((([a-zA-Z]|\\\\d|[!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])+(\\\\.([a-zA-Z]|\\\\d|[!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])+)*)|((\\\\x22)((((\\\\x20|\\\\x09)*(\\\\x0d\\\\x0a))?(\\\\x20|\\\\x09)+)?(([\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f]|\\\\x21|[\\\\x23-\\\\x5b]|[\\\\x5d-\\\\x7e]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(\\\\([\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0d-\\\\x7f]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}]))))*(((\\\\x20|\\\\x09)*(\\\\x0d\\\\x0a))?(\\\\x20|\\\\x09)+)?(\\\\x22)))@((([a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(([a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])*([a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])))\\\\.)+(([a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(([a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])([a-zA-Z]|\\\\d|-|_|~|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])*([a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])))\\\\.?$\"\n\tCreditCard        string = \"^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\\\d{3})\\\\d{11}|6[27][0-9]{14})$\"\n\tISBN10            string = \"^(?:[0-9]{9}X|[0-9]{10})$\"\n\tISBN13            string = \"^(?:[0-9]{13})$\"\n\tUUID3             string = \"^[0-9a-f]{8}-[0-9a-f]{4}-3[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n\tUUID4             string = \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"\n\tUUID5             string = \"^[0-9a-f]{8}-[0-9a-f]{4}-5[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"\n\tUUID              string = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n\tAlpha             string = \"^[a-zA-Z]+$\"\n\tAlphanumeric      string = \"^[a-zA-Z0-9]+$\"\n\tNumeric           string = \"^[0-9]+$\"\n\tInt               string = \"^(?:[-+]?(?:0|[1-9][0-9]*))$\"\n\tFloat             string = \"^(?:[-+]?(?:[0-9]+))?(?:\\\\.[0-9]*)?(?:[eE][\\\\+\\\\-]?(?:[0-9]+))?$\"\n\tHexadecimal       string = \"^[0-9a-fA-F]+$\"\n\tHexcolor          string = \"^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$\"\n\tRGBcolor          string = \"^rgb\\\\(\\\\s*(0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*\\\\)$\"\n\tASCII             string = \"^[\\x00-\\x7F]+$\"\n\tMultibyte         string = \"[^\\x00-\\x7F]\"\n\tFullWidth         string = \"[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]\"\n\tHalfWidth         string = \"[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]\"\n\tBase64            string = \"^(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+\\\\/]{3}=|[A-Za-z0-9+\\\\/]{4})$\"\n\tPrintableASCII    string = \"^[\\x20-\\x7E]+$\"\n\tDataURI           string = \"^data:.+\\\\/(.+);base64$\"\n\tMagnetURI         string = \"^magnet:\\\\?xt=urn:[a-zA-Z0-9]+:[a-zA-Z0-9]{32,40}&dn=.+&tr=.+$\"\n\tLatitude          string = \"^[-+]?([1-8]?\\\\d(\\\\.\\\\d+)?|90(\\\\.0+)?)$\"\n\tLongitude         string = \"^[-+]?(180(\\\\.0+)?|((1[0-7]\\\\d)|([1-9]?\\\\d))(\\\\.\\\\d+)?)$\"\n\tDNSName           string = `^([a-zA-Z0-9_]{1}[a-zA-Z0-9_-]{0,62}){1}(\\.[a-zA-Z0-9_]{1}[a-zA-Z0-9_-]{0,62})*[\\._]?$`\n\tIP                string = `(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))`\n\tURLSchema         string = `((ftp|tcp|udp|wss?|https?):\\/\\/)`\n\tURLUsername       string = `(\\S+(:\\S*)?@)`\n\tURLPath           string = `((\\/|\\?|#)[^\\s]*)`\n\tURLPort           string = `(:(\\d{1,5}))`\n\tURLIP             string = `([1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3]|24\\d|25[0-5])(\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])){2}(?:\\.([0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-5]))`\n\tURLSubdomain      string = `((www\\.)|([a-zA-Z0-9]+([-_\\.]?[a-zA-Z0-9])*[a-zA-Z0-9]\\.[a-zA-Z0-9]+))`\n\tURL                      = `^` + URLSchema + `?` + URLUsername + `?` + `((` + URLIP + `|(\\[` + IP + `\\])|(([a-zA-Z0-9]([a-zA-Z0-9-_]+)?[a-zA-Z0-9]([-\\.][a-zA-Z0-9]+)*)|(` + URLSubdomain + `?))?(([a-zA-Z\\x{00a1}-\\x{ffff}0-9]+-?-?)*[a-zA-Z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.([a-zA-Z\\x{00a1}-\\x{ffff}]{1,}))?))\\.?` + URLPort + `?` + URLPath + `?$`\n\tSSN               string = `^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$`\n\tWinPath           string = `^[a-zA-Z]:\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$`\n\tUnixPath          string = `^(/[^/\\x00]*)+/?$`\n\tWinARPath         string = `^(?:(?:[a-zA-Z]:|\\\\\\\\[a-z0-9_.$●-]+\\\\[a-z0-9_.$●-]+)\\\\|\\\\?[^\\\\/:*?\"<>|\\r\\n]+\\\\?)(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$`\n\tUnixARPath        string = `^((\\.{0,2}/)?([^/\\x00]*))+/?$`\n\tSemver            string = \"^v?(?:0|[1-9]\\\\d*)\\\\.(?:0|[1-9]\\\\d*)\\\\.(?:0|[1-9]\\\\d*)(-(0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\\\.(0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\\\+[0-9a-zA-Z-]+(\\\\.[0-9a-zA-Z-]+)*)?$\"\n\ttagName           string = \"valid\"\n\thasLowerCase      string = \".*[[:lower:]]\"\n\thasUpperCase      string = \".*[[:upper:]]\"\n\thasWhitespace     string = \".*[[:space:]]\"\n\thasWhitespaceOnly string = \"^[[:space:]]+$\"\n\tIMEI              string = \"^[0-9a-f]{14}$|^\\\\d{15}$|^\\\\d{18}$\"\n\tIMSI              string = \"^\\\\d{14,15}$\"\n\tE164              string = `^\\+?[1-9]\\d{1,14}$`\n)\n\n// Used by IsFilePath func\nconst (\n\t// Unknown is unresolved OS type\n\tUnknown = iota\n\t// Win is Windows type\n\tWin\n\t// Unix is *nix OS types\n\tUnix\n)\n\nvar (\n\tuserRegexp          = regexp.MustCompile(\"^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~.-]+$\")\n\thostRegexp          = regexp.MustCompile(\"^[^\\\\s]+\\\\.[^\\\\s]+$\")\n\tuserDotRegexp       = regexp.MustCompile(\"(^[.]{1})|([.]{1}$)|([.]{2,})\")\n\trxEmail             = regexp.MustCompile(Email)\n\trxCreditCard        = regexp.MustCompile(CreditCard)\n\trxISBN10            = regexp.MustCompile(ISBN10)\n\trxISBN13            = regexp.MustCompile(ISBN13)\n\trxUUID3             = regexp.MustCompile(UUID3)\n\trxUUID4             = regexp.MustCompile(UUID4)\n\trxUUID5             = regexp.MustCompile(UUID5)\n\trxUUID              = regexp.MustCompile(UUID)\n\trxAlpha             = regexp.MustCompile(Alpha)\n\trxAlphanumeric      = regexp.MustCompile(Alphanumeric)\n\trxNumeric           = regexp.MustCompile(Numeric)\n\trxInt               = regexp.MustCompile(Int)\n\trxFloat             = regexp.MustCompile(Float)\n\trxHexadecimal       = regexp.MustCompile(Hexadecimal)\n\trxHexcolor          = regexp.MustCompile(Hexcolor)\n\trxRGBcolor          = regexp.MustCompile(RGBcolor)\n\trxASCII             = regexp.MustCompile(ASCII)\n\trxPrintableASCII    = regexp.MustCompile(PrintableASCII)\n\trxMultibyte         = regexp.MustCompile(Multibyte)\n\trxFullWidth         = regexp.MustCompile(FullWidth)\n\trxHalfWidth         = regexp.MustCompile(HalfWidth)\n\trxBase64            = regexp.MustCompile(Base64)\n\trxDataURI           = regexp.MustCompile(DataURI)\n\trxMagnetURI         = regexp.MustCompile(MagnetURI)\n\trxLatitude          = regexp.MustCompile(Latitude)\n\trxLongitude         = regexp.MustCompile(Longitude)\n\trxDNSName           = regexp.MustCompile(DNSName)\n\trxURL               = regexp.MustCompile(URL)\n\trxSSN               = regexp.MustCompile(SSN)\n\trxWinPath           = regexp.MustCompile(WinPath)\n\trxUnixPath          = regexp.MustCompile(UnixPath)\n\trxARWinPath         = regexp.MustCompile(WinARPath)\n\trxARUnixPath        = regexp.MustCompile(UnixARPath)\n\trxSemver            = regexp.MustCompile(Semver)\n\trxHasLowerCase      = regexp.MustCompile(hasLowerCase)\n\trxHasUpperCase      = regexp.MustCompile(hasUpperCase)\n\trxHasWhitespace     = regexp.MustCompile(hasWhitespace)\n\trxHasWhitespaceOnly = regexp.MustCompile(hasWhitespaceOnly)\n\trxIMEI              = regexp.MustCompile(IMEI)\n\trxIMSI              = regexp.MustCompile(IMSI)\n\trxE164              = regexp.MustCompile(E164)\n)\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 33.5048828125,
          "content": "package govalidator\n\nimport (\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"sync\"\n)\n\n// Validator is a wrapper for a validator function that returns bool and accepts string.\ntype Validator func(str string) bool\n\n// CustomTypeValidator is a wrapper for validator functions that returns bool and accepts any type.\n// The second parameter should be the context (in the case of validating a struct: the whole object being validated).\ntype CustomTypeValidator func(i interface{}, o interface{}) bool\n\n// ParamValidator is a wrapper for validator functions that accept additional parameters.\ntype ParamValidator func(str string, params ...string) bool\n\n// InterfaceParamValidator is a wrapper for functions that accept variants parameters for an interface value\ntype InterfaceParamValidator func(in interface{}, params ...string) bool\ntype tagOptionsMap map[string]tagOption\n\nfunc (t tagOptionsMap) orderedKeys() []string {\n\tvar keys []string\n\tfor k := range t {\n\t\tkeys = append(keys, k)\n\t}\n\n\tsort.Slice(keys, func(a, b int) bool {\n\t\treturn t[keys[a]].order < t[keys[b]].order\n\t})\n\n\treturn keys\n}\n\ntype tagOption struct {\n\tname               string\n\tcustomErrorMessage string\n\torder              int\n}\n\n// UnsupportedTypeError is a wrapper for reflect.Type\ntype UnsupportedTypeError struct {\n\tType reflect.Type\n}\n\n// stringValues is a slice of reflect.Value holding *reflect.StringValue.\n// It implements the methods to sort by string.\ntype stringValues []reflect.Value\n\n// InterfaceParamTagMap is a map of functions accept variants parameters for an interface value\nvar InterfaceParamTagMap = map[string]InterfaceParamValidator{\n\t\"type\": IsType,\n}\n\n// InterfaceParamTagRegexMap maps interface param tags to their respective regexes.\nvar InterfaceParamTagRegexMap = map[string]*regexp.Regexp{\n\t\"type\": regexp.MustCompile(`^type\\((.*)\\)$`),\n}\n\n// ParamTagMap is a map of functions accept variants parameters\nvar ParamTagMap = map[string]ParamValidator{\n\t\"length\":          ByteLength,\n\t\"range\":           Range,\n\t\"runelength\":      RuneLength,\n\t\"stringlength\":    StringLength,\n\t\"matches\":         StringMatches,\n\t\"in\":              IsInRaw,\n\t\"rsapub\":          IsRsaPub,\n\t\"minstringlength\": MinStringLength,\n\t\"maxstringlength\": MaxStringLength,\n}\n\n// ParamTagRegexMap maps param tags to their respective regexes.\nvar ParamTagRegexMap = map[string]*regexp.Regexp{\n\t\"range\":           regexp.MustCompile(\"^range\\\\((\\\\d+)\\\\|(\\\\d+)\\\\)$\"),\n\t\"length\":          regexp.MustCompile(\"^length\\\\((\\\\d+)\\\\|(\\\\d+)\\\\)$\"),\n\t\"runelength\":      regexp.MustCompile(\"^runelength\\\\((\\\\d+)\\\\|(\\\\d+)\\\\)$\"),\n\t\"stringlength\":    regexp.MustCompile(\"^stringlength\\\\((\\\\d+)\\\\|(\\\\d+)\\\\)$\"),\n\t\"in\":              regexp.MustCompile(`^in\\((.*)\\)`),\n\t\"matches\":         regexp.MustCompile(`^matches\\((.+)\\)$`),\n\t\"rsapub\":          regexp.MustCompile(\"^rsapub\\\\((\\\\d+)\\\\)$\"),\n\t\"minstringlength\": regexp.MustCompile(\"^minstringlength\\\\((\\\\d+)\\\\)$\"),\n\t\"maxstringlength\": regexp.MustCompile(\"^maxstringlength\\\\((\\\\d+)\\\\)$\"),\n}\n\ntype customTypeTagMap struct {\n\tvalidators map[string]CustomTypeValidator\n\n\tsync.RWMutex\n}\n\nfunc (tm *customTypeTagMap) Get(name string) (CustomTypeValidator, bool) {\n\ttm.RLock()\n\tdefer tm.RUnlock()\n\tv, ok := tm.validators[name]\n\treturn v, ok\n}\n\nfunc (tm *customTypeTagMap) Set(name string, ctv CustomTypeValidator) {\n\ttm.Lock()\n\tdefer tm.Unlock()\n\ttm.validators[name] = ctv\n}\n\n// CustomTypeTagMap is a map of functions that can be used as tags for ValidateStruct function.\n// Use this to validate compound or custom types that need to be handled as a whole, e.g.\n// `type UUID [16]byte` (this would be handled as an array of bytes).\nvar CustomTypeTagMap = &customTypeTagMap{validators: make(map[string]CustomTypeValidator)}\n\n// TagMap is a map of functions, that can be used as tags for ValidateStruct function.\nvar TagMap = map[string]Validator{\n\t\"email\":              IsEmail,\n\t\"url\":                IsURL,\n\t\"dialstring\":         IsDialString,\n\t\"requrl\":             IsRequestURL,\n\t\"requri\":             IsRequestURI,\n\t\"alpha\":              IsAlpha,\n\t\"utfletter\":          IsUTFLetter,\n\t\"alphanum\":           IsAlphanumeric,\n\t\"utfletternum\":       IsUTFLetterNumeric,\n\t\"numeric\":            IsNumeric,\n\t\"utfnumeric\":         IsUTFNumeric,\n\t\"utfdigit\":           IsUTFDigit,\n\t\"hexadecimal\":        IsHexadecimal,\n\t\"hexcolor\":           IsHexcolor,\n\t\"rgbcolor\":           IsRGBcolor,\n\t\"lowercase\":          IsLowerCase,\n\t\"uppercase\":          IsUpperCase,\n\t\"int\":                IsInt,\n\t\"float\":              IsFloat,\n\t\"null\":               IsNull,\n\t\"notnull\":            IsNotNull,\n\t\"uuid\":               IsUUID,\n\t\"uuidv3\":             IsUUIDv3,\n\t\"uuidv4\":             IsUUIDv4,\n\t\"uuidv5\":             IsUUIDv5,\n\t\"creditcard\":         IsCreditCard,\n\t\"isbn10\":             IsISBN10,\n\t\"isbn13\":             IsISBN13,\n\t\"json\":               IsJSON,\n\t\"multibyte\":          IsMultibyte,\n\t\"ascii\":              IsASCII,\n\t\"printableascii\":     IsPrintableASCII,\n\t\"fullwidth\":          IsFullWidth,\n\t\"halfwidth\":          IsHalfWidth,\n\t\"variablewidth\":      IsVariableWidth,\n\t\"base64\":             IsBase64,\n\t\"datauri\":            IsDataURI,\n\t\"ip\":                 IsIP,\n\t\"port\":               IsPort,\n\t\"ipv4\":               IsIPv4,\n\t\"ipv6\":               IsIPv6,\n\t\"dns\":                IsDNSName,\n\t\"host\":               IsHost,\n\t\"mac\":                IsMAC,\n\t\"latitude\":           IsLatitude,\n\t\"longitude\":          IsLongitude,\n\t\"ssn\":                IsSSN,\n\t\"semver\":             IsSemver,\n\t\"rfc3339\":            IsRFC3339,\n\t\"rfc3339WithoutZone\": IsRFC3339WithoutZone,\n\t\"ISO3166Alpha2\":      IsISO3166Alpha2,\n\t\"ISO3166Alpha3\":      IsISO3166Alpha3,\n\t\"ISO4217\":            IsISO4217,\n\t\"IMEI\":               IsIMEI,\n\t\"ulid\":               IsULID,\n}\n\n// ISO3166Entry stores country codes\ntype ISO3166Entry struct {\n\tEnglishShortName string\n\tFrenchShortName  string\n\tAlpha2Code       string\n\tAlpha3Code       string\n\tNumeric          string\n}\n\n//ISO3166List based on https://www.iso.org/obp/ui/#search/code/ Code Type \"Officially Assigned Codes\"\nvar ISO3166List = []ISO3166Entry{\n\t{\"Afghanistan\", \"Afghanistan (l')\", \"AF\", \"AFG\", \"004\"},\n\t{\"Albania\", \"Albanie (l')\", \"AL\", \"ALB\", \"008\"},\n\t{\"Antarctica\", \"Antarctique (l')\", \"AQ\", \"ATA\", \"010\"},\n\t{\"Algeria\", \"Algérie (l')\", \"DZ\", \"DZA\", \"012\"},\n\t{\"American Samoa\", \"Samoa américaines (les)\", \"AS\", \"ASM\", \"016\"},\n\t{\"Andorra\", \"Andorre (l')\", \"AD\", \"AND\", \"020\"},\n\t{\"Angola\", \"Angola (l')\", \"AO\", \"AGO\", \"024\"},\n\t{\"Antigua and Barbuda\", \"Antigua-et-Barbuda\", \"AG\", \"ATG\", \"028\"},\n\t{\"Azerbaijan\", \"Azerbaïdjan (l')\", \"AZ\", \"AZE\", \"031\"},\n\t{\"Argentina\", \"Argentine (l')\", \"AR\", \"ARG\", \"032\"},\n\t{\"Australia\", \"Australie (l')\", \"AU\", \"AUS\", \"036\"},\n\t{\"Austria\", \"Autriche (l')\", \"AT\", \"AUT\", \"040\"},\n\t{\"Bahamas (the)\", \"Bahamas (les)\", \"BS\", \"BHS\", \"044\"},\n\t{\"Bahrain\", \"Bahreïn\", \"BH\", \"BHR\", \"048\"},\n\t{\"Bangladesh\", \"Bangladesh (le)\", \"BD\", \"BGD\", \"050\"},\n\t{\"Armenia\", \"Arménie (l')\", \"AM\", \"ARM\", \"051\"},\n\t{\"Barbados\", \"Barbade (la)\", \"BB\", \"BRB\", \"052\"},\n\t{\"Belgium\", \"Belgique (la)\", \"BE\", \"BEL\", \"056\"},\n\t{\"Bermuda\", \"Bermudes (les)\", \"BM\", \"BMU\", \"060\"},\n\t{\"Bhutan\", \"Bhoutan (le)\", \"BT\", \"BTN\", \"064\"},\n\t{\"Bolivia (Plurinational State of)\", \"Bolivie (État plurinational de)\", \"BO\", \"BOL\", \"068\"},\n\t{\"Bosnia and Herzegovina\", \"Bosnie-Herzégovine (la)\", \"BA\", \"BIH\", \"070\"},\n\t{\"Botswana\", \"Botswana (le)\", \"BW\", \"BWA\", \"072\"},\n\t{\"Bouvet Island\", \"Bouvet (l'Île)\", \"BV\", \"BVT\", \"074\"},\n\t{\"Brazil\", \"Brésil (le)\", \"BR\", \"BRA\", \"076\"},\n\t{\"Belize\", \"Belize (le)\", \"BZ\", \"BLZ\", \"084\"},\n\t{\"British Indian Ocean Territory (the)\", \"Indien (le Territoire britannique de l'océan)\", \"IO\", \"IOT\", \"086\"},\n\t{\"Solomon Islands\", \"Salomon (Îles)\", \"SB\", \"SLB\", \"090\"},\n\t{\"Virgin Islands (British)\", \"Vierges britanniques (les Îles)\", \"VG\", \"VGB\", \"092\"},\n\t{\"Brunei Darussalam\", \"Brunéi Darussalam (le)\", \"BN\", \"BRN\", \"096\"},\n\t{\"Bulgaria\", \"Bulgarie (la)\", \"BG\", \"BGR\", \"100\"},\n\t{\"Myanmar\", \"Myanmar (le)\", \"MM\", \"MMR\", \"104\"},\n\t{\"Burundi\", \"Burundi (le)\", \"BI\", \"BDI\", \"108\"},\n\t{\"Belarus\", \"Bélarus (le)\", \"BY\", \"BLR\", \"112\"},\n\t{\"Cambodia\", \"Cambodge (le)\", \"KH\", \"KHM\", \"116\"},\n\t{\"Cameroon\", \"Cameroun (le)\", \"CM\", \"CMR\", \"120\"},\n\t{\"Canada\", \"Canada (le)\", \"CA\", \"CAN\", \"124\"},\n\t{\"Cabo Verde\", \"Cabo Verde\", \"CV\", \"CPV\", \"132\"},\n\t{\"Cayman Islands (the)\", \"Caïmans (les Îles)\", \"KY\", \"CYM\", \"136\"},\n\t{\"Central African Republic (the)\", \"République centrafricaine (la)\", \"CF\", \"CAF\", \"140\"},\n\t{\"Sri Lanka\", \"Sri Lanka\", \"LK\", \"LKA\", \"144\"},\n\t{\"Chad\", \"Tchad (le)\", \"TD\", \"TCD\", \"148\"},\n\t{\"Chile\", \"Chili (le)\", \"CL\", \"CHL\", \"152\"},\n\t{\"China\", \"Chine (la)\", \"CN\", \"CHN\", \"156\"},\n\t{\"Taiwan (Province of China)\", \"Taïwan (Province de Chine)\", \"TW\", \"TWN\", \"158\"},\n\t{\"Christmas Island\", \"Christmas (l'Île)\", \"CX\", \"CXR\", \"162\"},\n\t{\"Cocos (Keeling) Islands (the)\", \"Cocos (les Îles)/ Keeling (les Îles)\", \"CC\", \"CCK\", \"166\"},\n\t{\"Colombia\", \"Colombie (la)\", \"CO\", \"COL\", \"170\"},\n\t{\"Comoros (the)\", \"Comores (les)\", \"KM\", \"COM\", \"174\"},\n\t{\"Mayotte\", \"Mayotte\", \"YT\", \"MYT\", \"175\"},\n\t{\"Congo (the)\", \"Congo (le)\", \"CG\", \"COG\", \"178\"},\n\t{\"Congo (the Democratic Republic of the)\", \"Congo (la République démocratique du)\", \"CD\", \"COD\", \"180\"},\n\t{\"Cook Islands (the)\", \"Cook (les Îles)\", \"CK\", \"COK\", \"184\"},\n\t{\"Costa Rica\", \"Costa Rica (le)\", \"CR\", \"CRI\", \"188\"},\n\t{\"Croatia\", \"Croatie (la)\", \"HR\", \"HRV\", \"191\"},\n\t{\"Cuba\", \"Cuba\", \"CU\", \"CUB\", \"192\"},\n\t{\"Cyprus\", \"Chypre\", \"CY\", \"CYP\", \"196\"},\n\t{\"Czech Republic (the)\", \"tchèque (la République)\", \"CZ\", \"CZE\", \"203\"},\n\t{\"Benin\", \"Bénin (le)\", \"BJ\", \"BEN\", \"204\"},\n\t{\"Denmark\", \"Danemark (le)\", \"DK\", \"DNK\", \"208\"},\n\t{\"Dominica\", \"Dominique (la)\", \"DM\", \"DMA\", \"212\"},\n\t{\"Dominican Republic (the)\", \"dominicaine (la République)\", \"DO\", \"DOM\", \"214\"},\n\t{\"Ecuador\", \"Équateur (l')\", \"EC\", \"ECU\", \"218\"},\n\t{\"El Salvador\", \"El Salvador\", \"SV\", \"SLV\", \"222\"},\n\t{\"Equatorial Guinea\", \"Guinée équatoriale (la)\", \"GQ\", \"GNQ\", \"226\"},\n\t{\"Ethiopia\", \"Éthiopie (l')\", \"ET\", \"ETH\", \"231\"},\n\t{\"Eritrea\", \"Érythrée (l')\", \"ER\", \"ERI\", \"232\"},\n\t{\"Estonia\", \"Estonie (l')\", \"EE\", \"EST\", \"233\"},\n\t{\"Faroe Islands (the)\", \"Féroé (les Îles)\", \"FO\", \"FRO\", \"234\"},\n\t{\"Falkland Islands (the) [Malvinas]\", \"Falkland (les Îles)/Malouines (les Îles)\", \"FK\", \"FLK\", \"238\"},\n\t{\"South Georgia and the South Sandwich Islands\", \"Géorgie du Sud-et-les Îles Sandwich du Sud (la)\", \"GS\", \"SGS\", \"239\"},\n\t{\"Fiji\", \"Fidji (les)\", \"FJ\", \"FJI\", \"242\"},\n\t{\"Finland\", \"Finlande (la)\", \"FI\", \"FIN\", \"246\"},\n\t{\"Åland Islands\", \"Åland(les Îles)\", \"AX\", \"ALA\", \"248\"},\n\t{\"France\", \"France (la)\", \"FR\", \"FRA\", \"250\"},\n\t{\"French Guiana\", \"Guyane française (la )\", \"GF\", \"GUF\", \"254\"},\n\t{\"French Polynesia\", \"Polynésie française (la)\", \"PF\", \"PYF\", \"258\"},\n\t{\"French Southern Territories (the)\", \"Terres australes françaises (les)\", \"TF\", \"ATF\", \"260\"},\n\t{\"Djibouti\", \"Djibouti\", \"DJ\", \"DJI\", \"262\"},\n\t{\"Gabon\", \"Gabon (le)\", \"GA\", \"GAB\", \"266\"},\n\t{\"Georgia\", \"Géorgie (la)\", \"GE\", \"GEO\", \"268\"},\n\t{\"Gambia (the)\", \"Gambie (la)\", \"GM\", \"GMB\", \"270\"},\n\t{\"Palestine, State of\", \"Palestine, État de\", \"PS\", \"PSE\", \"275\"},\n\t{\"Germany\", \"Allemagne (l')\", \"DE\", \"DEU\", \"276\"},\n\t{\"Ghana\", \"Ghana (le)\", \"GH\", \"GHA\", \"288\"},\n\t{\"Gibraltar\", \"Gibraltar\", \"GI\", \"GIB\", \"292\"},\n\t{\"Kiribati\", \"Kiribati\", \"KI\", \"KIR\", \"296\"},\n\t{\"Greece\", \"Grèce (la)\", \"GR\", \"GRC\", \"300\"},\n\t{\"Greenland\", \"Groenland (le)\", \"GL\", \"GRL\", \"304\"},\n\t{\"Grenada\", \"Grenade (la)\", \"GD\", \"GRD\", \"308\"},\n\t{\"Guadeloupe\", \"Guadeloupe (la)\", \"GP\", \"GLP\", \"312\"},\n\t{\"Guam\", \"Guam\", \"GU\", \"GUM\", \"316\"},\n\t{\"Guatemala\", \"Guatemala (le)\", \"GT\", \"GTM\", \"320\"},\n\t{\"Guinea\", \"Guinée (la)\", \"GN\", \"GIN\", \"324\"},\n\t{\"Guyana\", \"Guyana (le)\", \"GY\", \"GUY\", \"328\"},\n\t{\"Haiti\", \"Haïti\", \"HT\", \"HTI\", \"332\"},\n\t{\"Heard Island and McDonald Islands\", \"Heard-et-Îles MacDonald (l'Île)\", \"HM\", \"HMD\", \"334\"},\n\t{\"Holy See (the)\", \"Saint-Siège (le)\", \"VA\", \"VAT\", \"336\"},\n\t{\"Honduras\", \"Honduras (le)\", \"HN\", \"HND\", \"340\"},\n\t{\"Hong Kong\", \"Hong Kong\", \"HK\", \"HKG\", \"344\"},\n\t{\"Hungary\", \"Hongrie (la)\", \"HU\", \"HUN\", \"348\"},\n\t{\"Iceland\", \"Islande (l')\", \"IS\", \"ISL\", \"352\"},\n\t{\"India\", \"Inde (l')\", \"IN\", \"IND\", \"356\"},\n\t{\"Indonesia\", \"Indonésie (l')\", \"ID\", \"IDN\", \"360\"},\n\t{\"Iran (Islamic Republic of)\", \"Iran (République Islamique d')\", \"IR\", \"IRN\", \"364\"},\n\t{\"Iraq\", \"Iraq (l')\", \"IQ\", \"IRQ\", \"368\"},\n\t{\"Ireland\", \"Irlande (l')\", \"IE\", \"IRL\", \"372\"},\n\t{\"Israel\", \"Israël\", \"IL\", \"ISR\", \"376\"},\n\t{\"Italy\", \"Italie (l')\", \"IT\", \"ITA\", \"380\"},\n\t{\"Côte d'Ivoire\", \"Côte d'Ivoire (la)\", \"CI\", \"CIV\", \"384\"},\n\t{\"Jamaica\", \"Jamaïque (la)\", \"JM\", \"JAM\", \"388\"},\n\t{\"Japan\", \"Japon (le)\", \"JP\", \"JPN\", \"392\"},\n\t{\"Kazakhstan\", \"Kazakhstan (le)\", \"KZ\", \"KAZ\", \"398\"},\n\t{\"Jordan\", \"Jordanie (la)\", \"JO\", \"JOR\", \"400\"},\n\t{\"Kenya\", \"Kenya (le)\", \"KE\", \"KEN\", \"404\"},\n\t{\"Korea (the Democratic People's Republic of)\", \"Corée (la République populaire démocratique de)\", \"KP\", \"PRK\", \"408\"},\n\t{\"Korea (the Republic of)\", \"Corée (la République de)\", \"KR\", \"KOR\", \"410\"},\n\t{\"Kuwait\", \"Koweït (le)\", \"KW\", \"KWT\", \"414\"},\n\t{\"Kyrgyzstan\", \"Kirghizistan (le)\", \"KG\", \"KGZ\", \"417\"},\n\t{\"Lao People's Democratic Republic (the)\", \"Lao, République démocratique populaire\", \"LA\", \"LAO\", \"418\"},\n\t{\"Lebanon\", \"Liban (le)\", \"LB\", \"LBN\", \"422\"},\n\t{\"Lesotho\", \"Lesotho (le)\", \"LS\", \"LSO\", \"426\"},\n\t{\"Latvia\", \"Lettonie (la)\", \"LV\", \"LVA\", \"428\"},\n\t{\"Liberia\", \"Libéria (le)\", \"LR\", \"LBR\", \"430\"},\n\t{\"Libya\", \"Libye (la)\", \"LY\", \"LBY\", \"434\"},\n\t{\"Liechtenstein\", \"Liechtenstein (le)\", \"LI\", \"LIE\", \"438\"},\n\t{\"Lithuania\", \"Lituanie (la)\", \"LT\", \"LTU\", \"440\"},\n\t{\"Luxembourg\", \"Luxembourg (le)\", \"LU\", \"LUX\", \"442\"},\n\t{\"Macao\", \"Macao\", \"MO\", \"MAC\", \"446\"},\n\t{\"Madagascar\", \"Madagascar\", \"MG\", \"MDG\", \"450\"},\n\t{\"Malawi\", \"Malawi (le)\", \"MW\", \"MWI\", \"454\"},\n\t{\"Malaysia\", \"Malaisie (la)\", \"MY\", \"MYS\", \"458\"},\n\t{\"Maldives\", \"Maldives (les)\", \"MV\", \"MDV\", \"462\"},\n\t{\"Mali\", \"Mali (le)\", \"ML\", \"MLI\", \"466\"},\n\t{\"Malta\", \"Malte\", \"MT\", \"MLT\", \"470\"},\n\t{\"Martinique\", \"Martinique (la)\", \"MQ\", \"MTQ\", \"474\"},\n\t{\"Mauritania\", \"Mauritanie (la)\", \"MR\", \"MRT\", \"478\"},\n\t{\"Mauritius\", \"Maurice\", \"MU\", \"MUS\", \"480\"},\n\t{\"Mexico\", \"Mexique (le)\", \"MX\", \"MEX\", \"484\"},\n\t{\"Monaco\", \"Monaco\", \"MC\", \"MCO\", \"492\"},\n\t{\"Mongolia\", \"Mongolie (la)\", \"MN\", \"MNG\", \"496\"},\n\t{\"Moldova (the Republic of)\", \"Moldova , République de\", \"MD\", \"MDA\", \"498\"},\n\t{\"Montenegro\", \"Monténégro (le)\", \"ME\", \"MNE\", \"499\"},\n\t{\"Montserrat\", \"Montserrat\", \"MS\", \"MSR\", \"500\"},\n\t{\"Morocco\", \"Maroc (le)\", \"MA\", \"MAR\", \"504\"},\n\t{\"Mozambique\", \"Mozambique (le)\", \"MZ\", \"MOZ\", \"508\"},\n\t{\"Oman\", \"Oman\", \"OM\", \"OMN\", \"512\"},\n\t{\"Namibia\", \"Namibie (la)\", \"NA\", \"NAM\", \"516\"},\n\t{\"Nauru\", \"Nauru\", \"NR\", \"NRU\", \"520\"},\n\t{\"Nepal\", \"Népal (le)\", \"NP\", \"NPL\", \"524\"},\n\t{\"Netherlands (the)\", \"Pays-Bas (les)\", \"NL\", \"NLD\", \"528\"},\n\t{\"Curaçao\", \"Curaçao\", \"CW\", \"CUW\", \"531\"},\n\t{\"Aruba\", \"Aruba\", \"AW\", \"ABW\", \"533\"},\n\t{\"Sint Maarten (Dutch part)\", \"Saint-Martin (partie néerlandaise)\", \"SX\", \"SXM\", \"534\"},\n\t{\"Bonaire, Sint Eustatius and Saba\", \"Bonaire, Saint-Eustache et Saba\", \"BQ\", \"BES\", \"535\"},\n\t{\"New Caledonia\", \"Nouvelle-Calédonie (la)\", \"NC\", \"NCL\", \"540\"},\n\t{\"Vanuatu\", \"Vanuatu (le)\", \"VU\", \"VUT\", \"548\"},\n\t{\"New Zealand\", \"Nouvelle-Zélande (la)\", \"NZ\", \"NZL\", \"554\"},\n\t{\"Nicaragua\", \"Nicaragua (le)\", \"NI\", \"NIC\", \"558\"},\n\t{\"Niger (the)\", \"Niger (le)\", \"NE\", \"NER\", \"562\"},\n\t{\"Nigeria\", \"Nigéria (le)\", \"NG\", \"NGA\", \"566\"},\n\t{\"Niue\", \"Niue\", \"NU\", \"NIU\", \"570\"},\n\t{\"Norfolk Island\", \"Norfolk (l'Île)\", \"NF\", \"NFK\", \"574\"},\n\t{\"Norway\", \"Norvège (la)\", \"NO\", \"NOR\", \"578\"},\n\t{\"Northern Mariana Islands (the)\", \"Mariannes du Nord (les Îles)\", \"MP\", \"MNP\", \"580\"},\n\t{\"United States Minor Outlying Islands (the)\", \"Îles mineures éloignées des États-Unis (les)\", \"UM\", \"UMI\", \"581\"},\n\t{\"Micronesia (Federated States of)\", \"Micronésie (États fédérés de)\", \"FM\", \"FSM\", \"583\"},\n\t{\"Marshall Islands (the)\", \"Marshall (Îles)\", \"MH\", \"MHL\", \"584\"},\n\t{\"Palau\", \"Palaos (les)\", \"PW\", \"PLW\", \"585\"},\n\t{\"Pakistan\", \"Pakistan (le)\", \"PK\", \"PAK\", \"586\"},\n\t{\"Panama\", \"Panama (le)\", \"PA\", \"PAN\", \"591\"},\n\t{\"Papua New Guinea\", \"Papouasie-Nouvelle-Guinée (la)\", \"PG\", \"PNG\", \"598\"},\n\t{\"Paraguay\", \"Paraguay (le)\", \"PY\", \"PRY\", \"600\"},\n\t{\"Peru\", \"Pérou (le)\", \"PE\", \"PER\", \"604\"},\n\t{\"Philippines (the)\", \"Philippines (les)\", \"PH\", \"PHL\", \"608\"},\n\t{\"Pitcairn\", \"Pitcairn\", \"PN\", \"PCN\", \"612\"},\n\t{\"Poland\", \"Pologne (la)\", \"PL\", \"POL\", \"616\"},\n\t{\"Portugal\", \"Portugal (le)\", \"PT\", \"PRT\", \"620\"},\n\t{\"Guinea-Bissau\", \"Guinée-Bissau (la)\", \"GW\", \"GNB\", \"624\"},\n\t{\"Timor-Leste\", \"Timor-Leste (le)\", \"TL\", \"TLS\", \"626\"},\n\t{\"Puerto Rico\", \"Porto Rico\", \"PR\", \"PRI\", \"630\"},\n\t{\"Qatar\", \"Qatar (le)\", \"QA\", \"QAT\", \"634\"},\n\t{\"Réunion\", \"Réunion (La)\", \"RE\", \"REU\", \"638\"},\n\t{\"Romania\", \"Roumanie (la)\", \"RO\", \"ROU\", \"642\"},\n\t{\"Russian Federation (the)\", \"Russie (la Fédération de)\", \"RU\", \"RUS\", \"643\"},\n\t{\"Rwanda\", \"Rwanda (le)\", \"RW\", \"RWA\", \"646\"},\n\t{\"Saint Barthélemy\", \"Saint-Barthélemy\", \"BL\", \"BLM\", \"652\"},\n\t{\"Saint Helena, Ascension and Tristan da Cunha\", \"Sainte-Hélène, Ascension et Tristan da Cunha\", \"SH\", \"SHN\", \"654\"},\n\t{\"Saint Kitts and Nevis\", \"Saint-Kitts-et-Nevis\", \"KN\", \"KNA\", \"659\"},\n\t{\"Anguilla\", \"Anguilla\", \"AI\", \"AIA\", \"660\"},\n\t{\"Saint Lucia\", \"Sainte-Lucie\", \"LC\", \"LCA\", \"662\"},\n\t{\"Saint Martin (French part)\", \"Saint-Martin (partie française)\", \"MF\", \"MAF\", \"663\"},\n\t{\"Saint Pierre and Miquelon\", \"Saint-Pierre-et-Miquelon\", \"PM\", \"SPM\", \"666\"},\n\t{\"Saint Vincent and the Grenadines\", \"Saint-Vincent-et-les Grenadines\", \"VC\", \"VCT\", \"670\"},\n\t{\"San Marino\", \"Saint-Marin\", \"SM\", \"SMR\", \"674\"},\n\t{\"Sao Tome and Principe\", \"Sao Tomé-et-Principe\", \"ST\", \"STP\", \"678\"},\n\t{\"Saudi Arabia\", \"Arabie saoudite (l')\", \"SA\", \"SAU\", \"682\"},\n\t{\"Senegal\", \"Sénégal (le)\", \"SN\", \"SEN\", \"686\"},\n\t{\"Serbia\", \"Serbie (la)\", \"RS\", \"SRB\", \"688\"},\n\t{\"Seychelles\", \"Seychelles (les)\", \"SC\", \"SYC\", \"690\"},\n\t{\"Sierra Leone\", \"Sierra Leone (la)\", \"SL\", \"SLE\", \"694\"},\n\t{\"Singapore\", \"Singapour\", \"SG\", \"SGP\", \"702\"},\n\t{\"Slovakia\", \"Slovaquie (la)\", \"SK\", \"SVK\", \"703\"},\n\t{\"Viet Nam\", \"Viet Nam (le)\", \"VN\", \"VNM\", \"704\"},\n\t{\"Slovenia\", \"Slovénie (la)\", \"SI\", \"SVN\", \"705\"},\n\t{\"Somalia\", \"Somalie (la)\", \"SO\", \"SOM\", \"706\"},\n\t{\"South Africa\", \"Afrique du Sud (l')\", \"ZA\", \"ZAF\", \"710\"},\n\t{\"Zimbabwe\", \"Zimbabwe (le)\", \"ZW\", \"ZWE\", \"716\"},\n\t{\"Spain\", \"Espagne (l')\", \"ES\", \"ESP\", \"724\"},\n\t{\"South Sudan\", \"Soudan du Sud (le)\", \"SS\", \"SSD\", \"728\"},\n\t{\"Sudan (the)\", \"Soudan (le)\", \"SD\", \"SDN\", \"729\"},\n\t{\"Western Sahara*\", \"Sahara occidental (le)*\", \"EH\", \"ESH\", \"732\"},\n\t{\"Suriname\", \"Suriname (le)\", \"SR\", \"SUR\", \"740\"},\n\t{\"Svalbard and Jan Mayen\", \"Svalbard et l'Île Jan Mayen (le)\", \"SJ\", \"SJM\", \"744\"},\n\t{\"Swaziland\", \"Swaziland (le)\", \"SZ\", \"SWZ\", \"748\"},\n\t{\"Sweden\", \"Suède (la)\", \"SE\", \"SWE\", \"752\"},\n\t{\"Switzerland\", \"Suisse (la)\", \"CH\", \"CHE\", \"756\"},\n\t{\"Syrian Arab Republic\", \"République arabe syrienne (la)\", \"SY\", \"SYR\", \"760\"},\n\t{\"Tajikistan\", \"Tadjikistan (le)\", \"TJ\", \"TJK\", \"762\"},\n\t{\"Thailand\", \"Thaïlande (la)\", \"TH\", \"THA\", \"764\"},\n\t{\"Togo\", \"Togo (le)\", \"TG\", \"TGO\", \"768\"},\n\t{\"Tokelau\", \"Tokelau (les)\", \"TK\", \"TKL\", \"772\"},\n\t{\"Tonga\", \"Tonga (les)\", \"TO\", \"TON\", \"776\"},\n\t{\"Trinidad and Tobago\", \"Trinité-et-Tobago (la)\", \"TT\", \"TTO\", \"780\"},\n\t{\"United Arab Emirates (the)\", \"Émirats arabes unis (les)\", \"AE\", \"ARE\", \"784\"},\n\t{\"Tunisia\", \"Tunisie (la)\", \"TN\", \"TUN\", \"788\"},\n\t{\"Turkey\", \"Turquie (la)\", \"TR\", \"TUR\", \"792\"},\n\t{\"Turkmenistan\", \"Turkménistan (le)\", \"TM\", \"TKM\", \"795\"},\n\t{\"Turks and Caicos Islands (the)\", \"Turks-et-Caïcos (les Îles)\", \"TC\", \"TCA\", \"796\"},\n\t{\"Tuvalu\", \"Tuvalu (les)\", \"TV\", \"TUV\", \"798\"},\n\t{\"Uganda\", \"Ouganda (l')\", \"UG\", \"UGA\", \"800\"},\n\t{\"Ukraine\", \"Ukraine (l')\", \"UA\", \"UKR\", \"804\"},\n\t{\"Macedonia (the former Yugoslav Republic of)\", \"Macédoine (l'ex‑République yougoslave de)\", \"MK\", \"MKD\", \"807\"},\n\t{\"Egypt\", \"Égypte (l')\", \"EG\", \"EGY\", \"818\"},\n\t{\"United Kingdom of Great Britain and Northern Ireland (the)\", \"Royaume-Uni de Grande-Bretagne et d'Irlande du Nord (le)\", \"GB\", \"GBR\", \"826\"},\n\t{\"Guernsey\", \"Guernesey\", \"GG\", \"GGY\", \"831\"},\n\t{\"Jersey\", \"Jersey\", \"JE\", \"JEY\", \"832\"},\n\t{\"Isle of Man\", \"Île de Man\", \"IM\", \"IMN\", \"833\"},\n\t{\"Tanzania, United Republic of\", \"Tanzanie, République-Unie de\", \"TZ\", \"TZA\", \"834\"},\n\t{\"United States of America (the)\", \"États-Unis d'Amérique (les)\", \"US\", \"USA\", \"840\"},\n\t{\"Virgin Islands (U.S.)\", \"Vierges des États-Unis (les Îles)\", \"VI\", \"VIR\", \"850\"},\n\t{\"Burkina Faso\", \"Burkina Faso (le)\", \"BF\", \"BFA\", \"854\"},\n\t{\"Uruguay\", \"Uruguay (l')\", \"UY\", \"URY\", \"858\"},\n\t{\"Uzbekistan\", \"Ouzbékistan (l')\", \"UZ\", \"UZB\", \"860\"},\n\t{\"Venezuela (Bolivarian Republic of)\", \"Venezuela (République bolivarienne du)\", \"VE\", \"VEN\", \"862\"},\n\t{\"Wallis and Futuna\", \"Wallis-et-Futuna\", \"WF\", \"WLF\", \"876\"},\n\t{\"Samoa\", \"Samoa (le)\", \"WS\", \"WSM\", \"882\"},\n\t{\"Yemen\", \"Yémen (le)\", \"YE\", \"YEM\", \"887\"},\n\t{\"Zambia\", \"Zambie (la)\", \"ZM\", \"ZMB\", \"894\"},\n}\n\n// ISO4217List is the list of ISO currency codes\nvar ISO4217List = []string{\n\t\"AED\", \"AFN\", \"ALL\", \"AMD\", \"ANG\", \"AOA\", \"ARS\", \"AUD\", \"AWG\", \"AZN\",\n\t\"BAM\", \"BBD\", \"BDT\", \"BGN\", \"BHD\", \"BIF\", \"BMD\", \"BND\", \"BOB\", \"BOV\", \"BRL\", \"BSD\", \"BTN\", \"BWP\", \"BYN\", \"BZD\",\n\t\"CAD\", \"CDF\", \"CHE\", \"CHF\", \"CHW\", \"CLF\", \"CLP\", \"CNY\", \"COP\", \"COU\", \"CRC\", \"CUC\", \"CUP\", \"CVE\", \"CZK\",\n\t\"DJF\", \"DKK\", \"DOP\", \"DZD\",\n\t\"EGP\", \"ERN\", \"ETB\", \"EUR\",\n\t\"FJD\", \"FKP\",\n\t\"GBP\", \"GEL\", \"GHS\", \"GIP\", \"GMD\", \"GNF\", \"GTQ\", \"GYD\",\n\t\"HKD\", \"HNL\", \"HRK\", \"HTG\", \"HUF\",\n\t\"IDR\", \"ILS\", \"INR\", \"IQD\", \"IRR\", \"ISK\",\n\t\"JMD\", \"JOD\", \"JPY\",\n\t\"KES\", \"KGS\", \"KHR\", \"KMF\", \"KPW\", \"KRW\", \"KWD\", \"KYD\", \"KZT\",\n\t\"LAK\", \"LBP\", \"LKR\", \"LRD\", \"LSL\", \"LYD\",\n\t\"MAD\", \"MDL\", \"MGA\", \"MKD\", \"MMK\", \"MNT\", \"MOP\", \"MRO\", \"MUR\", \"MVR\", \"MWK\", \"MXN\", \"MXV\", \"MYR\", \"MZN\",\n\t\"NAD\", \"NGN\", \"NIO\", \"NOK\", \"NPR\", \"NZD\",\n\t\"OMR\",\n\t\"PAB\", \"PEN\", \"PGK\", \"PHP\", \"PKR\", \"PLN\", \"PYG\",\n\t\"QAR\",\n\t\"RON\", \"RSD\", \"RUB\", \"RWF\",\n\t\"SAR\", \"SBD\", \"SCR\", \"SDG\", \"SEK\", \"SGD\", \"SHP\", \"SLL\", \"SOS\", \"SRD\", \"SSP\", \"STD\", \"STN\", \"SVC\", \"SYP\", \"SZL\",\n\t\"THB\", \"TJS\", \"TMT\", \"TND\", \"TOP\", \"TRY\", \"TTD\", \"TWD\", \"TZS\",\n\t\"UAH\", \"UGX\", \"USD\", \"USN\", \"UYI\", \"UYU\", \"UYW\", \"UZS\",\n\t\"VEF\", \"VES\", \"VND\", \"VUV\",\n\t\"WST\",\n\t\"XAF\", \"XAG\", \"XAU\", \"XBA\", \"XBB\", \"XBC\", \"XBD\", \"XCD\", \"XDR\", \"XOF\", \"XPD\", \"XPF\", \"XPT\", \"XSU\", \"XTS\", \"XUA\", \"XXX\",\n\t\"YER\",\n\t\"ZAR\", \"ZMW\", \"ZWL\",\n}\n\n// ISO693Entry stores ISO language codes\ntype ISO693Entry struct {\n\tAlpha3bCode string\n\tAlpha2Code  string\n\tEnglish     string\n}\n\n//ISO693List based on http://data.okfn.org/data/core/language-codes/r/language-codes-3b2.json\nvar ISO693List = []ISO693Entry{\n\t{Alpha3bCode: \"aar\", Alpha2Code: \"aa\", English: \"Afar\"},\n\t{Alpha3bCode: \"abk\", Alpha2Code: \"ab\", English: \"Abkhazian\"},\n\t{Alpha3bCode: \"afr\", Alpha2Code: \"af\", English: \"Afrikaans\"},\n\t{Alpha3bCode: \"aka\", Alpha2Code: \"ak\", English: \"Akan\"},\n\t{Alpha3bCode: \"alb\", Alpha2Code: \"sq\", English: \"Albanian\"},\n\t{Alpha3bCode: \"amh\", Alpha2Code: \"am\", English: \"Amharic\"},\n\t{Alpha3bCode: \"ara\", Alpha2Code: \"ar\", English: \"Arabic\"},\n\t{Alpha3bCode: \"arg\", Alpha2Code: \"an\", English: \"Aragonese\"},\n\t{Alpha3bCode: \"arm\", Alpha2Code: \"hy\", English: \"Armenian\"},\n\t{Alpha3bCode: \"asm\", Alpha2Code: \"as\", English: \"Assamese\"},\n\t{Alpha3bCode: \"ava\", Alpha2Code: \"av\", English: \"Avaric\"},\n\t{Alpha3bCode: \"ave\", Alpha2Code: \"ae\", English: \"Avestan\"},\n\t{Alpha3bCode: \"aym\", Alpha2Code: \"ay\", English: \"Aymara\"},\n\t{Alpha3bCode: \"aze\", Alpha2Code: \"az\", English: \"Azerbaijani\"},\n\t{Alpha3bCode: \"bak\", Alpha2Code: \"ba\", English: \"Bashkir\"},\n\t{Alpha3bCode: \"bam\", Alpha2Code: \"bm\", English: \"Bambara\"},\n\t{Alpha3bCode: \"baq\", Alpha2Code: \"eu\", English: \"Basque\"},\n\t{Alpha3bCode: \"bel\", Alpha2Code: \"be\", English: \"Belarusian\"},\n\t{Alpha3bCode: \"ben\", Alpha2Code: \"bn\", English: \"Bengali\"},\n\t{Alpha3bCode: \"bih\", Alpha2Code: \"bh\", English: \"Bihari languages\"},\n\t{Alpha3bCode: \"bis\", Alpha2Code: \"bi\", English: \"Bislama\"},\n\t{Alpha3bCode: \"bos\", Alpha2Code: \"bs\", English: \"Bosnian\"},\n\t{Alpha3bCode: \"bre\", Alpha2Code: \"br\", English: \"Breton\"},\n\t{Alpha3bCode: \"bul\", Alpha2Code: \"bg\", English: \"Bulgarian\"},\n\t{Alpha3bCode: \"bur\", Alpha2Code: \"my\", English: \"Burmese\"},\n\t{Alpha3bCode: \"cat\", Alpha2Code: \"ca\", English: \"Catalan; Valencian\"},\n\t{Alpha3bCode: \"cha\", Alpha2Code: \"ch\", English: \"Chamorro\"},\n\t{Alpha3bCode: \"che\", Alpha2Code: \"ce\", English: \"Chechen\"},\n\t{Alpha3bCode: \"chi\", Alpha2Code: \"zh\", English: \"Chinese\"},\n\t{Alpha3bCode: \"chu\", Alpha2Code: \"cu\", English: \"Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic\"},\n\t{Alpha3bCode: \"chv\", Alpha2Code: \"cv\", English: \"Chuvash\"},\n\t{Alpha3bCode: \"cor\", Alpha2Code: \"kw\", English: \"Cornish\"},\n\t{Alpha3bCode: \"cos\", Alpha2Code: \"co\", English: \"Corsican\"},\n\t{Alpha3bCode: \"cre\", Alpha2Code: \"cr\", English: \"Cree\"},\n\t{Alpha3bCode: \"cze\", Alpha2Code: \"cs\", English: \"Czech\"},\n\t{Alpha3bCode: \"dan\", Alpha2Code: \"da\", English: \"Danish\"},\n\t{Alpha3bCode: \"div\", Alpha2Code: \"dv\", English: \"Divehi; Dhivehi; Maldivian\"},\n\t{Alpha3bCode: \"dut\", Alpha2Code: \"nl\", English: \"Dutch; Flemish\"},\n\t{Alpha3bCode: \"dzo\", Alpha2Code: \"dz\", English: \"Dzongkha\"},\n\t{Alpha3bCode: \"eng\", Alpha2Code: \"en\", English: \"English\"},\n\t{Alpha3bCode: \"epo\", Alpha2Code: \"eo\", English: \"Esperanto\"},\n\t{Alpha3bCode: \"est\", Alpha2Code: \"et\", English: \"Estonian\"},\n\t{Alpha3bCode: \"ewe\", Alpha2Code: \"ee\", English: \"Ewe\"},\n\t{Alpha3bCode: \"fao\", Alpha2Code: \"fo\", English: \"Faroese\"},\n\t{Alpha3bCode: \"fij\", Alpha2Code: \"fj\", English: \"Fijian\"},\n\t{Alpha3bCode: \"fin\", Alpha2Code: \"fi\", English: \"Finnish\"},\n\t{Alpha3bCode: \"fre\", Alpha2Code: \"fr\", English: \"French\"},\n\t{Alpha3bCode: \"fry\", Alpha2Code: \"fy\", English: \"Western Frisian\"},\n\t{Alpha3bCode: \"ful\", Alpha2Code: \"ff\", English: \"Fulah\"},\n\t{Alpha3bCode: \"geo\", Alpha2Code: \"ka\", English: \"Georgian\"},\n\t{Alpha3bCode: \"ger\", Alpha2Code: \"de\", English: \"German\"},\n\t{Alpha3bCode: \"gla\", Alpha2Code: \"gd\", English: \"Gaelic; Scottish Gaelic\"},\n\t{Alpha3bCode: \"gle\", Alpha2Code: \"ga\", English: \"Irish\"},\n\t{Alpha3bCode: \"glg\", Alpha2Code: \"gl\", English: \"Galician\"},\n\t{Alpha3bCode: \"glv\", Alpha2Code: \"gv\", English: \"Manx\"},\n\t{Alpha3bCode: \"gre\", Alpha2Code: \"el\", English: \"Greek, Modern (1453-)\"},\n\t{Alpha3bCode: \"grn\", Alpha2Code: \"gn\", English: \"Guarani\"},\n\t{Alpha3bCode: \"guj\", Alpha2Code: \"gu\", English: \"Gujarati\"},\n\t{Alpha3bCode: \"hat\", Alpha2Code: \"ht\", English: \"Haitian; Haitian Creole\"},\n\t{Alpha3bCode: \"hau\", Alpha2Code: \"ha\", English: \"Hausa\"},\n\t{Alpha3bCode: \"heb\", Alpha2Code: \"he\", English: \"Hebrew\"},\n\t{Alpha3bCode: \"her\", Alpha2Code: \"hz\", English: \"Herero\"},\n\t{Alpha3bCode: \"hin\", Alpha2Code: \"hi\", English: \"Hindi\"},\n\t{Alpha3bCode: \"hmo\", Alpha2Code: \"ho\", English: \"Hiri Motu\"},\n\t{Alpha3bCode: \"hrv\", Alpha2Code: \"hr\", English: \"Croatian\"},\n\t{Alpha3bCode: \"hun\", Alpha2Code: \"hu\", English: \"Hungarian\"},\n\t{Alpha3bCode: \"ibo\", Alpha2Code: \"ig\", English: \"Igbo\"},\n\t{Alpha3bCode: \"ice\", Alpha2Code: \"is\", English: \"Icelandic\"},\n\t{Alpha3bCode: \"ido\", Alpha2Code: \"io\", English: \"Ido\"},\n\t{Alpha3bCode: \"iii\", Alpha2Code: \"ii\", English: \"Sichuan Yi; Nuosu\"},\n\t{Alpha3bCode: \"iku\", Alpha2Code: \"iu\", English: \"Inuktitut\"},\n\t{Alpha3bCode: \"ile\", Alpha2Code: \"ie\", English: \"Interlingue; Occidental\"},\n\t{Alpha3bCode: \"ina\", Alpha2Code: \"ia\", English: \"Interlingua (International Auxiliary Language Association)\"},\n\t{Alpha3bCode: \"ind\", Alpha2Code: \"id\", English: \"Indonesian\"},\n\t{Alpha3bCode: \"ipk\", Alpha2Code: \"ik\", English: \"Inupiaq\"},\n\t{Alpha3bCode: \"ita\", Alpha2Code: \"it\", English: \"Italian\"},\n\t{Alpha3bCode: \"jav\", Alpha2Code: \"jv\", English: \"Javanese\"},\n\t{Alpha3bCode: \"jpn\", Alpha2Code: \"ja\", English: \"Japanese\"},\n\t{Alpha3bCode: \"kal\", Alpha2Code: \"kl\", English: \"Kalaallisut; Greenlandic\"},\n\t{Alpha3bCode: \"kan\", Alpha2Code: \"kn\", English: \"Kannada\"},\n\t{Alpha3bCode: \"kas\", Alpha2Code: \"ks\", English: \"Kashmiri\"},\n\t{Alpha3bCode: \"kau\", Alpha2Code: \"kr\", English: \"Kanuri\"},\n\t{Alpha3bCode: \"kaz\", Alpha2Code: \"kk\", English: \"Kazakh\"},\n\t{Alpha3bCode: \"khm\", Alpha2Code: \"km\", English: \"Central Khmer\"},\n\t{Alpha3bCode: \"kik\", Alpha2Code: \"ki\", English: \"Kikuyu; Gikuyu\"},\n\t{Alpha3bCode: \"kin\", Alpha2Code: \"rw\", English: \"Kinyarwanda\"},\n\t{Alpha3bCode: \"kir\", Alpha2Code: \"ky\", English: \"Kirghiz; Kyrgyz\"},\n\t{Alpha3bCode: \"kom\", Alpha2Code: \"kv\", English: \"Komi\"},\n\t{Alpha3bCode: \"kon\", Alpha2Code: \"kg\", English: \"Kongo\"},\n\t{Alpha3bCode: \"kor\", Alpha2Code: \"ko\", English: \"Korean\"},\n\t{Alpha3bCode: \"kua\", Alpha2Code: \"kj\", English: \"Kuanyama; Kwanyama\"},\n\t{Alpha3bCode: \"kur\", Alpha2Code: \"ku\", English: \"Kurdish\"},\n\t{Alpha3bCode: \"lao\", Alpha2Code: \"lo\", English: \"Lao\"},\n\t{Alpha3bCode: \"lat\", Alpha2Code: \"la\", English: \"Latin\"},\n\t{Alpha3bCode: \"lav\", Alpha2Code: \"lv\", English: \"Latvian\"},\n\t{Alpha3bCode: \"lim\", Alpha2Code: \"li\", English: \"Limburgan; Limburger; Limburgish\"},\n\t{Alpha3bCode: \"lin\", Alpha2Code: \"ln\", English: \"Lingala\"},\n\t{Alpha3bCode: \"lit\", Alpha2Code: \"lt\", English: \"Lithuanian\"},\n\t{Alpha3bCode: \"ltz\", Alpha2Code: \"lb\", English: \"Luxembourgish; Letzeburgesch\"},\n\t{Alpha3bCode: \"lub\", Alpha2Code: \"lu\", English: \"Luba-Katanga\"},\n\t{Alpha3bCode: \"lug\", Alpha2Code: \"lg\", English: \"Ganda\"},\n\t{Alpha3bCode: \"mac\", Alpha2Code: \"mk\", English: \"Macedonian\"},\n\t{Alpha3bCode: \"mah\", Alpha2Code: \"mh\", English: \"Marshallese\"},\n\t{Alpha3bCode: \"mal\", Alpha2Code: \"ml\", English: \"Malayalam\"},\n\t{Alpha3bCode: \"mao\", Alpha2Code: \"mi\", English: \"Maori\"},\n\t{Alpha3bCode: \"mar\", Alpha2Code: \"mr\", English: \"Marathi\"},\n\t{Alpha3bCode: \"may\", Alpha2Code: \"ms\", English: \"Malay\"},\n\t{Alpha3bCode: \"mlg\", Alpha2Code: \"mg\", English: \"Malagasy\"},\n\t{Alpha3bCode: \"mlt\", Alpha2Code: \"mt\", English: \"Maltese\"},\n\t{Alpha3bCode: \"mon\", Alpha2Code: \"mn\", English: \"Mongolian\"},\n\t{Alpha3bCode: \"nau\", Alpha2Code: \"na\", English: \"Nauru\"},\n\t{Alpha3bCode: \"nav\", Alpha2Code: \"nv\", English: \"Navajo; Navaho\"},\n\t{Alpha3bCode: \"nbl\", Alpha2Code: \"nr\", English: \"Ndebele, South; South Ndebele\"},\n\t{Alpha3bCode: \"nde\", Alpha2Code: \"nd\", English: \"Ndebele, North; North Ndebele\"},\n\t{Alpha3bCode: \"ndo\", Alpha2Code: \"ng\", English: \"Ndonga\"},\n\t{Alpha3bCode: \"nep\", Alpha2Code: \"ne\", English: \"Nepali\"},\n\t{Alpha3bCode: \"nno\", Alpha2Code: \"nn\", English: \"Norwegian Nynorsk; Nynorsk, Norwegian\"},\n\t{Alpha3bCode: \"nob\", Alpha2Code: \"nb\", English: \"Bokmål, Norwegian; Norwegian Bokmål\"},\n\t{Alpha3bCode: \"nor\", Alpha2Code: \"no\", English: \"Norwegian\"},\n\t{Alpha3bCode: \"nya\", Alpha2Code: \"ny\", English: \"Chichewa; Chewa; Nyanja\"},\n\t{Alpha3bCode: \"oci\", Alpha2Code: \"oc\", English: \"Occitan (post 1500); Provençal\"},\n\t{Alpha3bCode: \"oji\", Alpha2Code: \"oj\", English: \"Ojibwa\"},\n\t{Alpha3bCode: \"ori\", Alpha2Code: \"or\", English: \"Oriya\"},\n\t{Alpha3bCode: \"orm\", Alpha2Code: \"om\", English: \"Oromo\"},\n\t{Alpha3bCode: \"oss\", Alpha2Code: \"os\", English: \"Ossetian; Ossetic\"},\n\t{Alpha3bCode: \"pan\", Alpha2Code: \"pa\", English: \"Panjabi; Punjabi\"},\n\t{Alpha3bCode: \"per\", Alpha2Code: \"fa\", English: \"Persian\"},\n\t{Alpha3bCode: \"pli\", Alpha2Code: \"pi\", English: \"Pali\"},\n\t{Alpha3bCode: \"pol\", Alpha2Code: \"pl\", English: \"Polish\"},\n\t{Alpha3bCode: \"por\", Alpha2Code: \"pt\", English: \"Portuguese\"},\n\t{Alpha3bCode: \"pus\", Alpha2Code: \"ps\", English: \"Pushto; Pashto\"},\n\t{Alpha3bCode: \"que\", Alpha2Code: \"qu\", English: \"Quechua\"},\n\t{Alpha3bCode: \"roh\", Alpha2Code: \"rm\", English: \"Romansh\"},\n\t{Alpha3bCode: \"rum\", Alpha2Code: \"ro\", English: \"Romanian; Moldavian; Moldovan\"},\n\t{Alpha3bCode: \"run\", Alpha2Code: \"rn\", English: \"Rundi\"},\n\t{Alpha3bCode: \"rus\", Alpha2Code: \"ru\", English: \"Russian\"},\n\t{Alpha3bCode: \"sag\", Alpha2Code: \"sg\", English: \"Sango\"},\n\t{Alpha3bCode: \"san\", Alpha2Code: \"sa\", English: \"Sanskrit\"},\n\t{Alpha3bCode: \"sin\", Alpha2Code: \"si\", English: \"Sinhala; Sinhalese\"},\n\t{Alpha3bCode: \"slo\", Alpha2Code: \"sk\", English: \"Slovak\"},\n\t{Alpha3bCode: \"slv\", Alpha2Code: \"sl\", English: \"Slovenian\"},\n\t{Alpha3bCode: \"sme\", Alpha2Code: \"se\", English: \"Northern Sami\"},\n\t{Alpha3bCode: \"smo\", Alpha2Code: \"sm\", English: \"Samoan\"},\n\t{Alpha3bCode: \"sna\", Alpha2Code: \"sn\", English: \"Shona\"},\n\t{Alpha3bCode: \"snd\", Alpha2Code: \"sd\", English: \"Sindhi\"},\n\t{Alpha3bCode: \"som\", Alpha2Code: \"so\", English: \"Somali\"},\n\t{Alpha3bCode: \"sot\", Alpha2Code: \"st\", English: \"Sotho, Southern\"},\n\t{Alpha3bCode: \"spa\", Alpha2Code: \"es\", English: \"Spanish; Castilian\"},\n\t{Alpha3bCode: \"srd\", Alpha2Code: \"sc\", English: \"Sardinian\"},\n\t{Alpha3bCode: \"srp\", Alpha2Code: \"sr\", English: \"Serbian\"},\n\t{Alpha3bCode: \"ssw\", Alpha2Code: \"ss\", English: \"Swati\"},\n\t{Alpha3bCode: \"sun\", Alpha2Code: \"su\", English: \"Sundanese\"},\n\t{Alpha3bCode: \"swa\", Alpha2Code: \"sw\", English: \"Swahili\"},\n\t{Alpha3bCode: \"swe\", Alpha2Code: \"sv\", English: \"Swedish\"},\n\t{Alpha3bCode: \"tah\", Alpha2Code: \"ty\", English: \"Tahitian\"},\n\t{Alpha3bCode: \"tam\", Alpha2Code: \"ta\", English: \"Tamil\"},\n\t{Alpha3bCode: \"tat\", Alpha2Code: \"tt\", English: \"Tatar\"},\n\t{Alpha3bCode: \"tel\", Alpha2Code: \"te\", English: \"Telugu\"},\n\t{Alpha3bCode: \"tgk\", Alpha2Code: \"tg\", English: \"Tajik\"},\n\t{Alpha3bCode: \"tgl\", Alpha2Code: \"tl\", English: \"Tagalog\"},\n\t{Alpha3bCode: \"tha\", Alpha2Code: \"th\", English: \"Thai\"},\n\t{Alpha3bCode: \"tib\", Alpha2Code: \"bo\", English: \"Tibetan\"},\n\t{Alpha3bCode: \"tir\", Alpha2Code: \"ti\", English: \"Tigrinya\"},\n\t{Alpha3bCode: \"ton\", Alpha2Code: \"to\", English: \"Tonga (Tonga Islands)\"},\n\t{Alpha3bCode: \"tsn\", Alpha2Code: \"tn\", English: \"Tswana\"},\n\t{Alpha3bCode: \"tso\", Alpha2Code: \"ts\", English: \"Tsonga\"},\n\t{Alpha3bCode: \"tuk\", Alpha2Code: \"tk\", English: \"Turkmen\"},\n\t{Alpha3bCode: \"tur\", Alpha2Code: \"tr\", English: \"Turkish\"},\n\t{Alpha3bCode: \"twi\", Alpha2Code: \"tw\", English: \"Twi\"},\n\t{Alpha3bCode: \"uig\", Alpha2Code: \"ug\", English: \"Uighur; Uyghur\"},\n\t{Alpha3bCode: \"ukr\", Alpha2Code: \"uk\", English: \"Ukrainian\"},\n\t{Alpha3bCode: \"urd\", Alpha2Code: \"ur\", English: \"Urdu\"},\n\t{Alpha3bCode: \"uzb\", Alpha2Code: \"uz\", English: \"Uzbek\"},\n\t{Alpha3bCode: \"ven\", Alpha2Code: \"ve\", English: \"Venda\"},\n\t{Alpha3bCode: \"vie\", Alpha2Code: \"vi\", English: \"Vietnamese\"},\n\t{Alpha3bCode: \"vol\", Alpha2Code: \"vo\", English: \"Volapük\"},\n\t{Alpha3bCode: \"wel\", Alpha2Code: \"cy\", English: \"Welsh\"},\n\t{Alpha3bCode: \"wln\", Alpha2Code: \"wa\", English: \"Walloon\"},\n\t{Alpha3bCode: \"wol\", Alpha2Code: \"wo\", English: \"Wolof\"},\n\t{Alpha3bCode: \"xho\", Alpha2Code: \"xh\", English: \"Xhosa\"},\n\t{Alpha3bCode: \"yid\", Alpha2Code: \"yi\", English: \"Yiddish\"},\n\t{Alpha3bCode: \"yor\", Alpha2Code: \"yo\", English: \"Yoruba\"},\n\t{Alpha3bCode: \"zha\", Alpha2Code: \"za\", English: \"Zhuang; Chuang\"},\n\t{Alpha3bCode: \"zul\", Alpha2Code: \"zu\", English: \"Zulu\"},\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 7.818359375,
          "content": "package govalidator\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"math\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\n// Contains checks if the string contains the substring.\nfunc Contains(str, substring string) bool {\n\treturn strings.Contains(str, substring)\n}\n\n// Matches checks if string matches the pattern (pattern is regular expression)\n// In case of error return false\nfunc Matches(str, pattern string) bool {\n\tmatch, _ := regexp.MatchString(pattern, str)\n\treturn match\n}\n\n// LeftTrim trims characters from the left side of the input.\n// If second argument is empty, it will remove leading spaces.\nfunc LeftTrim(str, chars string) string {\n\tif chars == \"\" {\n\t\treturn strings.TrimLeftFunc(str, unicode.IsSpace)\n\t}\n\tr, _ := regexp.Compile(\"^[\" + chars + \"]+\")\n\treturn r.ReplaceAllString(str, \"\")\n}\n\n// RightTrim trims characters from the right side of the input.\n// If second argument is empty, it will remove trailing spaces.\nfunc RightTrim(str, chars string) string {\n\tif chars == \"\" {\n\t\treturn strings.TrimRightFunc(str, unicode.IsSpace)\n\t}\n\tr, _ := regexp.Compile(\"[\" + chars + \"]+$\")\n\treturn r.ReplaceAllString(str, \"\")\n}\n\n// Trim trims characters from both sides of the input.\n// If second argument is empty, it will remove spaces.\nfunc Trim(str, chars string) string {\n\treturn LeftTrim(RightTrim(str, chars), chars)\n}\n\n// WhiteList removes characters that do not appear in the whitelist.\nfunc WhiteList(str, chars string) string {\n\tpattern := \"[^\" + chars + \"]+\"\n\tr, _ := regexp.Compile(pattern)\n\treturn r.ReplaceAllString(str, \"\")\n}\n\n// BlackList removes characters that appear in the blacklist.\nfunc BlackList(str, chars string) string {\n\tpattern := \"[\" + chars + \"]+\"\n\tr, _ := regexp.Compile(pattern)\n\treturn r.ReplaceAllString(str, \"\")\n}\n\n// StripLow removes characters with a numerical value < 32 and 127, mostly control characters.\n// If keep_new_lines is true, newline characters are preserved (\\n and \\r, hex 0xA and 0xD).\nfunc StripLow(str string, keepNewLines bool) string {\n\tchars := \"\"\n\tif keepNewLines {\n\t\tchars = \"\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F\"\n\t} else {\n\t\tchars = \"\\x00-\\x1F\\x7F\"\n\t}\n\treturn BlackList(str, chars)\n}\n\n// ReplacePattern replaces regular expression pattern in string\nfunc ReplacePattern(str, pattern, replace string) string {\n\tr, _ := regexp.Compile(pattern)\n\treturn r.ReplaceAllString(str, replace)\n}\n\n// Escape replaces <, >, & and \" with HTML entities.\nvar Escape = html.EscapeString\n\nfunc addSegment(inrune, segment []rune) []rune {\n\tif len(segment) == 0 {\n\t\treturn inrune\n\t}\n\tif len(inrune) != 0 {\n\t\tinrune = append(inrune, '_')\n\t}\n\tinrune = append(inrune, segment...)\n\treturn inrune\n}\n\n// UnderscoreToCamelCase converts from underscore separated form to camel case form.\n// Ex.: my_func => MyFunc\nfunc UnderscoreToCamelCase(s string) string {\n\treturn strings.Replace(strings.Title(strings.Replace(strings.ToLower(s), \"_\", \" \", -1)), \" \", \"\", -1)\n}\n\n// CamelCaseToUnderscore converts from camel case form to underscore separated form.\n// Ex.: MyFunc => my_func\nfunc CamelCaseToUnderscore(str string) string {\n\tvar output []rune\n\tvar segment []rune\n\tfor _, r := range str {\n\n\t\t// not treat number as separate segment\n\t\tif !unicode.IsLower(r) && string(r) != \"_\" && !unicode.IsNumber(r) {\n\t\t\toutput = addSegment(output, segment)\n\t\t\tsegment = nil\n\t\t}\n\t\tsegment = append(segment, unicode.ToLower(r))\n\t}\n\toutput = addSegment(output, segment)\n\treturn string(output)\n}\n\n// Reverse returns reversed string\nfunc Reverse(s string) string {\n\tr := []rune(s)\n\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n\n// GetLines splits string by \"\\n\" and return array of lines\nfunc GetLines(s string) []string {\n\treturn strings.Split(s, \"\\n\")\n}\n\n// GetLine returns specified line of multiline string\nfunc GetLine(s string, index int) (string, error) {\n\tlines := GetLines(s)\n\tif index < 0 || index >= len(lines) {\n\t\treturn \"\", errors.New(\"line index out of bounds\")\n\t}\n\treturn lines[index], nil\n}\n\n// RemoveTags removes all tags from HTML string\nfunc RemoveTags(s string) string {\n\treturn ReplacePattern(s, \"<[^>]*>\", \"\")\n}\n\n// SafeFileName returns safe string that can be used in file names\nfunc SafeFileName(str string) string {\n\tname := strings.ToLower(str)\n\tname = path.Clean(path.Base(name))\n\tname = strings.Trim(name, \" \")\n\tseparators, err := regexp.Compile(`[ &_=+:]`)\n\tif err == nil {\n\t\tname = separators.ReplaceAllString(name, \"-\")\n\t}\n\tlegal, err := regexp.Compile(`[^[:alnum:]-.]`)\n\tif err == nil {\n\t\tname = legal.ReplaceAllString(name, \"\")\n\t}\n\tfor strings.Contains(name, \"--\") {\n\t\tname = strings.Replace(name, \"--\", \"-\", -1)\n\t}\n\treturn name\n}\n\n// NormalizeEmail canonicalize an email address.\n// The local part of the email address is lowercased for all domains; the hostname is always lowercased and\n// the local part of the email address is always lowercased for hosts that are known to be case-insensitive (currently only GMail).\n// Normalization follows special rules for known providers: currently, GMail addresses have dots removed in the local part and\n// are stripped of tags (e.g. some.one+tag@gmail.com becomes someone@gmail.com) and all @googlemail.com addresses are\n// normalized to @gmail.com.\nfunc NormalizeEmail(str string) (string, error) {\n\tif !IsEmail(str) {\n\t\treturn \"\", fmt.Errorf(\"%s is not an email\", str)\n\t}\n\tparts := strings.Split(str, \"@\")\n\tparts[0] = strings.ToLower(parts[0])\n\tparts[1] = strings.ToLower(parts[1])\n\tif parts[1] == \"gmail.com\" || parts[1] == \"googlemail.com\" {\n\t\tparts[1] = \"gmail.com\"\n\t\tparts[0] = strings.Split(ReplacePattern(parts[0], `\\.`, \"\"), \"+\")[0]\n\t}\n\treturn strings.Join(parts, \"@\"), nil\n}\n\n// Truncate a string to the closest length without breaking words.\nfunc Truncate(str string, length int, ending string) string {\n\tvar aftstr, befstr string\n\tif len(str) > length {\n\t\twords := strings.Fields(str)\n\t\tbefore, present := 0, 0\n\t\tfor i := range words {\n\t\t\tbefstr = aftstr\n\t\t\tbefore = present\n\t\t\taftstr = aftstr + words[i] + \" \"\n\t\t\tpresent = len(aftstr)\n\t\t\tif present > length && i != 0 {\n\t\t\t\tif (length - before) < (present - length) {\n\t\t\t\t\treturn Trim(befstr, \" /\\\\.,\\\"'#!?&@+-\") + ending\n\t\t\t\t}\n\t\t\t\treturn Trim(aftstr, \" /\\\\.,\\\"'#!?&@+-\") + ending\n\t\t\t}\n\t\t}\n\t}\n\n\treturn str\n}\n\n// PadLeft pads left side of a string if size of string is less then indicated pad length\nfunc PadLeft(str string, padStr string, padLen int) string {\n\treturn buildPadStr(str, padStr, padLen, true, false)\n}\n\n// PadRight pads right side of a string if size of string is less then indicated pad length\nfunc PadRight(str string, padStr string, padLen int) string {\n\treturn buildPadStr(str, padStr, padLen, false, true)\n}\n\n// PadBoth pads both sides of a string if size of string is less then indicated pad length\nfunc PadBoth(str string, padStr string, padLen int) string {\n\treturn buildPadStr(str, padStr, padLen, true, true)\n}\n\n// PadString either left, right or both sides.\n// Note that padding string can be unicode and more then one character\nfunc buildPadStr(str string, padStr string, padLen int, padLeft bool, padRight bool) string {\n\n\t// When padded length is less then the current string size\n\tif padLen < utf8.RuneCountInString(str) {\n\t\treturn str\n\t}\n\n\tpadLen -= utf8.RuneCountInString(str)\n\n\ttargetLen := padLen\n\n\ttargetLenLeft := targetLen\n\ttargetLenRight := targetLen\n\tif padLeft && padRight {\n\t\ttargetLenLeft = padLen / 2\n\t\ttargetLenRight = padLen - targetLenLeft\n\t}\n\n\tstrToRepeatLen := utf8.RuneCountInString(padStr)\n\n\trepeatTimes := int(math.Ceil(float64(targetLen) / float64(strToRepeatLen)))\n\trepeatedString := strings.Repeat(padStr, repeatTimes)\n\n\tleftSide := \"\"\n\tif padLeft {\n\t\tleftSide = repeatedString[0:targetLenLeft]\n\t}\n\n\trightSide := \"\"\n\tif padRight {\n\t\trightSide = repeatedString[0:targetLenRight]\n\t}\n\n\treturn leftSide + str + rightSide\n}\n\n// TruncatingErrorf removes extra args from fmt.Errorf if not formatted in the str object\nfunc TruncatingErrorf(str string, args ...interface{}) error {\n\tn := strings.Count(str, \"%s\")\n\treturn fmt.Errorf(str, args[:n]...)\n}\n"
        },
        {
          "name": "utils_benchmark_test.go",
          "type": "blob",
          "size": 0.3447265625,
          "content": "package govalidator\n\nimport \"testing\"\n\nfunc BenchmarkContains(b *testing.B) {\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tContains(\"a0b01c012deffghijklmnopqrstu0123456vwxyz\", \"0123456789\")\n\t}\n}\n\nfunc BenchmarkMatches(b *testing.B) {\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tMatches(\"alfkjl12309fdjldfsa209jlksdfjLAKJjs9uJH234\", \"[\\\\w\\\\d]+\")\n\t}\n}\n"
        },
        {
          "name": "utils_example_test.go",
          "type": "blob",
          "size": 0.8232421875,
          "content": "package govalidator\n\nfunc ExampleTrim() {\n\t// Remove from left and right spaces and \"\\r\", \"\\n\", \"\\t\" characters\n\tprintln(Trim(\"   \\r\\r\\ntext\\r   \\t\\n\", \"\") == \"text\")\n\t// Remove from left and right characters that are between \"1\" and \"8\".\n\t// \"1-8\" is like full list \"12345678\".\n\tprintln(Trim(\"1234567890987654321\", \"1-8\") == \"909\")\n}\n\nfunc ExampleWhiteList() {\n\t// Remove all characters from string ignoring characters between \"a\" and \"z\"\n\tprintln(WhiteList(\"a3a43a5a4a3a2a23a4a5a4a3a4\", \"a-z\") == \"aaaaaaaaaaaa\")\n}\n\nfunc ExampleReplacePattern() {\n\t// Replace in \"http123123ftp://git534543hub.comio\" following (pattern \"(ftp|io|[0-9]+)\"):\n\t// - Sequence \"ftp\".\n\t// - Sequence \"io\".\n\t// - Sequence of digits.\n\t// with empty string.\n\tprintln(ReplacePattern(\"http123123ftp://git534543hub.comio\", \"(ftp|io|[0-9]+)\", \"\") == \"http://github.com\")\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 11.8486328125,
          "content": "package govalidator\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestContains(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected bool\n\t}{\n\t\t{\"abacada\", \"\", true},\n\t\t{\"abacada\", \"ritir\", false},\n\t\t{\"abacada\", \"a\", true},\n\t\t{\"abacada\", \"aca\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Contains(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Contains(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestMatches(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected bool\n\t}{\n\t\t{\"123456789\", \"[0-9]+\", true},\n\t\t{\"abacada\", \"cab$\", false},\n\t\t{\"111222333\", \"((111|222|333)+)+\", true},\n\t\t{\"abacaba\", \"((123+]\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Matches(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Matches(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestLeftTrim(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected string\n\t}{\n\t\t{\"  \\r\\n\\tfoo  \\r\\n\\t   \", \"\", \"foo  \\r\\n\\t   \"},\n\t\t{\"010100201000\", \"01\", \"201000\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := LeftTrim(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected LeftTrim(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRightTrim(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected string\n\t}{\n\t\t{\"  \\r\\n\\tfoo  \\r\\n\\t   \", \"\", \"  \\r\\n\\tfoo\"},\n\t\t{\"010100201000\", \"01\", \"0101002\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := RightTrim(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected RightTrim(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestTrim(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected string\n\t}{\n\t\t{\"  \\r\\n\\tfoo  \\r\\n\\t   \", \"\", \"foo\"},\n\t\t{\"010100201000\", \"01\", \"2\"},\n\t\t{\"1234567890987654321\", \"1-8\", \"909\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Trim(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Trim(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestWhiteList(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected string\n\t}{\n\t\t{\"abcdef\", \"abc\", \"abc\"},\n\t\t{\"aaaaaaaaaabbbbbbbbbb\", \"abc\", \"aaaaaaaaaabbbbbbbbbb\"},\n\t\t{\"a1b2c3\", \"abc\", \"abc\"},\n\t\t{\"   \", \"abc\", \"\"},\n\t\t{\"a3a43a5a4a3a2a23a4a5a4a3a4\", \"a-z\", \"aaaaaaaaaaaa\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := WhiteList(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected WhiteList(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestBlackList(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected string\n\t}{\n\t\t{\"abcdef\", \"abc\", \"def\"},\n\t\t{\"aaaaaaaaaabbbbbbbbbb\", \"abc\", \"\"},\n\t\t{\"a1b2c3\", \"abc\", \"123\"},\n\t\t{\"   \", \"abc\", \"   \"},\n\t\t{\"a3a43a5a4a3a2a23a4a5a4a3a4\", \"a-z\", \"34354322345434\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := BlackList(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected BlackList(%q,%q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestStripLow(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   bool\n\t\texpected string\n\t}{\n\t\t{\"foo\\x00\", false, \"foo\"},\n\t\t{\"\\x7Ffoo\\x02\", false, \"foo\"},\n\t\t{\"\\x01\\x09\", false, \"\"},\n\t\t{\"foo\\x0A\\x0D\", false, \"foo\"},\n\t\t{\"perch\\u00e9\", false, \"perch\\u00e9\"},\n\t\t{\"\\u20ac\", false, \"\\u20ac\"},\n\t\t{\"\\u2206\\x0A\", false, \"\\u2206\"},\n\t\t{\"foo\\x0A\\x0D\", true, \"foo\\x0A\\x0D\"},\n\t\t{\"\\x03foo\\x0A\\x0D\", true, \"foo\\x0A\\x0D\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := StripLow(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected StripLow(%q,%t) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestReplacePattern(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\tparam3   string\n\t\texpected string\n\t}{\n\t\t{\"ab123ba\", \"[0-9]+\", \"aca\", \"abacaba\"},\n\t\t{\"abacaba\", \"[0-9]+\", \"aca\", \"abacaba\"},\n\t\t{\"httpftp://github.comio\", \"(ftp|io)\", \"\", \"http://github.com\"},\n\t\t{\"aaaaaaaaaa\", \"a\", \"\", \"\"},\n\t\t{\"http123123ftp://git534543hub.comio\", \"(ftp|io|[0-9]+)\", \"\", \"http://github.com\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := ReplacePattern(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ReplacePattern(%q,%q,%q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestEscape(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{`<img alt=\"foo&bar\">`, \"&lt;img alt=&#34;foo&amp;bar&#34;&gt;\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Escape(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Escape(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestUnderscoreToCamelCase(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"a_b_c\", \"ABC\"},\n\t\t{\"my_func\", \"MyFunc\"},\n\t\t{\"1ab_cd\", \"1abCd\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := UnderscoreToCamelCase(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected UnderscoreToCamelCase(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestCamelCaseToUnderscore(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"MyFunc\", \"my_func\"},\n\t\t{\"ABC\", \"a_b_c\"},\n\t\t{\"1B\", \"1_b\"},\n\t\t{\"foo_bar\", \"foo_bar\"},\n\t\t{\"FooV2Bar\", \"foo_v2_bar\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := CamelCaseToUnderscore(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected CamelCaseToUnderscore(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"abc\", \"cba\"},\n\t\t{\"ｶﾀｶﾅ\", \"ﾅｶﾀｶ\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Reverse(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Reverse(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestGetLines(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected []string\n\t}{\n\t\t{\"abc\", []string{\"abc\"}},\n\t\t{\"a\\nb\\nc\", []string{\"a\", \"b\", \"c\"}},\n\t}\n\tfor _, test := range tests {\n\t\tactual := GetLines(test.param)\n\t\tif !reflect.DeepEqual(actual, test.expected) {\n\t\t\tt.Errorf(\"Expected GetLines(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestGetLine(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   int\n\t\texpected string\n\t}{\n\t\t{\"abc\", 0, \"abc\"},\n\t\t{\"a\\nb\\nc\", 0, \"a\"},\n\t\t{\"abc\", -1, \"\"},\n\t\t{\"abacaba\\n\", 1, \"\"},\n\t\t{\"abc\", 3, \"\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual, _ := GetLine(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected GetLine(%q, %d) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRemoveTags(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"abc\", \"abc\"},\n\t\t{\"<!-- Test -->\", \"\"},\n\t\t{\"<div><div><p><a>Text</a></p></div></div>\", \"Text\"},\n\t\t{`<a href=\"#\">Link</a>`, \"Link\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := RemoveTags(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected RemoveTags(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestSafeFileName(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"abc\", \"abc\"},\n\t\t{\"123456789     '_-?ASDF@£$%£%^é.html\", \"123456789-asdf.html\"},\n\t\t{\"ReadMe.md\", \"readme.md\"},\n\t\t{\"file:///c:/test.go\", \"test.go\"},\n\t\t{\"../../../Hello World!.txt\", \"hello-world.txt\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := SafeFileName(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected SafeFileName(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestNormalizeEmail(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{`test@me.com`, `test@me.com`},\n\t\t{`some.name@gmail.com`, `somename@gmail.com`},\n\t\t{`some.name@googlemail.com`, `somename@gmail.com`},\n\t\t{`some.name+extension@gmail.com`, `somename@gmail.com`},\n\t\t{`some.name+extension@googlemail.com`, `somename@gmail.com`},\n\t\t{`some.name.middlename+extension@gmail.com`, `somenamemiddlename@gmail.com`},\n\t\t{`some.name.middlename+extension@googlemail.com`, `somenamemiddlename@gmail.com`},\n\t\t{`some.name.midd.lena.me.+extension@gmail.com`, `somenamemiddlename@gmail.com`},\n\t\t{`some.name.midd.lena.me.+extension@googlemail.com`, `somenamemiddlename@gmail.com`},\n\t\t{`some.name+extension@unknown.com`, `some.name+extension@unknown.com`},\n\t\t// TODO: {`hans@m端ller.com`, `hans@m端ller.com`},\n\t\t{`hans`, ``},\n\t}\n\tfor _, test := range tests {\n\t\tactual, err := NormalizeEmail(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected NormalizeEmail(%q) to be %v, got %v, err %v\", test.param, test.expected, actual, err)\n\t\t}\n\t}\n}\n\nfunc TestTruncate(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   int\n\t\tparam3   string\n\t\texpected string\n\t}{\n\t\t{`Lorem ipsum dolor sit amet, consectetur adipiscing elit.`, 25, `...`, `Lorem ipsum dolor sit amet...`},\n\t\t{`Measuring programming progress by lines of code is like measuring aircraft building progress by weight.`, 35, ` new born babies!`, `Measuring programming progress by new born babies!`},\n\t\t{`Testestestestestestestestestest testestestestestestestestest`, 7, `...`, `Testestestestestestestestestest...`},\n\t\t{`Testing`, 7, `...`, `Testing`},\n\t}\n\tfor _, test := range tests {\n\t\tactual := Truncate(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected Truncate(%q, %d, %q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestPadLeft(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\tparam3   int\n\t\texpected string\n\t}{\n\t\t{\"こんにちは\", \"xyz\", 12, \"xyzxyzxこんにちは\"},\n\t\t{\"こんにちは\", \"xyz\", 11, \"xyzxyzこんにちは\"},\n\t\t{\"abc\", \"x\", 5, \"xxabc\"},\n\t\t{\"abc\", \"xyz\", 5, \"xyabc\"},\n\t\t{\"abcde\", \"xyz\", 5, \"abcde\"},\n\t\t{\"abcde\", \"xyz\", 4, \"abcde\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := PadLeft(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected PadLeft(%q,%q,%q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestPadRight(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\tparam3   int\n\t\texpected string\n\t}{\n\t\t{\"こんにちは\", \"xyz\", 12, \"こんにちはxyzxyzx\"},\n\t\t{\"こんにちは\", \"xyz\", 11, \"こんにちはxyzxyz\"},\n\t\t{\"abc\", \"x\", 5, \"abcxx\"},\n\t\t{\"abc\", \"xyz\", 5, \"abcxy\"},\n\t\t{\"abcde\", \"xyz\", 5, \"abcde\"},\n\t\t{\"abcde\", \"xyz\", 4, \"abcde\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := PadRight(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected PadRight(%q,%q,%q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestPadBoth(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\tparam3   int\n\t\texpected string\n\t}{\n\t\t{\"こんにちは\", \"xyz\", 12, \"xyzこんにちはxyzx\"},\n\t\t{\"こんにちは\", \"xyz\", 11, \"xyzこんにちはxyz\"},\n\t\t{\"abc\", \"x\", 5, \"xabcx\"},\n\t\t{\"abc\", \"xyz\", 5, \"xabcx\"},\n\t\t{\"abcde\", \"xyz\", 5, \"abcde\"},\n\t\t{\"abcde\", \"xyz\", 4, \"abcde\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := PadBoth(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected PadBoth(%q,%q,%q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "validator.go",
          "type": "blob",
          "size": 49.197265625,
          "content": "// Package govalidator is package of validators and sanitizers for strings, structs and collections.\npackage govalidator\n\nimport (\n\t\"bytes\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nvar (\n\tfieldsRequiredByDefault bool\n\tnilPtrAllowedByRequired = false\n\tnotNumberRegexp         = regexp.MustCompile(\"[^0-9]+\")\n\twhiteSpacesAndMinus     = regexp.MustCompile(`[\\s-]+`)\n\tparamsRegexp            = regexp.MustCompile(`\\(.*\\)$`)\n)\n\nconst maxURLRuneCount = 2083\nconst minURLRuneCount = 3\nconst rfc3339WithoutZone = \"2006-01-02T15:04:05\"\n\n// SetFieldsRequiredByDefault causes validation to fail when struct fields\n// do not include validations or are not explicitly marked as exempt (using `valid:\"-\"` or `valid:\"email,optional\"`).\n// This struct definition will fail govalidator.ValidateStruct() (and the field values do not matter):\n//     type exampleStruct struct {\n//         Name  string ``\n//         Email string `valid:\"email\"`\n// This, however, will only fail when Email is empty or an invalid email address:\n//     type exampleStruct2 struct {\n//         Name  string `valid:\"-\"`\n//         Email string `valid:\"email\"`\n// Lastly, this will only fail when Email is an invalid email address but not when it's empty:\n//     type exampleStruct2 struct {\n//         Name  string `valid:\"-\"`\n//         Email string `valid:\"email,optional\"`\nfunc SetFieldsRequiredByDefault(value bool) {\n\tfieldsRequiredByDefault = value\n}\n\n// SetNilPtrAllowedByRequired causes validation to pass for nil ptrs when a field is set to required.\n// The validation will still reject ptr fields in their zero value state. Example with this enabled:\n//     type exampleStruct struct {\n//         Name  *string `valid:\"required\"`\n// With `Name` set to \"\", this will be considered invalid input and will cause a validation error.\n// With `Name` set to nil, this will be considered valid by validation.\n// By default this is disabled.\nfunc SetNilPtrAllowedByRequired(value bool) {\n\tnilPtrAllowedByRequired = value\n}\n\n// IsEmail checks if the string is an email.\nfunc IsEmail(str string) bool {\n\t// TODO uppercase letters are not supported\n\treturn rxEmail.MatchString(str)\n}\n\n// IsExistingEmail checks if the string is an email of existing domain\nfunc IsExistingEmail(email string) bool {\n\n\tif len(email) < 6 || len(email) > 254 {\n\t\treturn false\n\t}\n\tat := strings.LastIndex(email, \"@\")\n\tif at <= 0 || at > len(email)-3 {\n\t\treturn false\n\t}\n\tuser := email[:at]\n\thost := email[at+1:]\n\tif len(user) > 64 {\n\t\treturn false\n\t}\n\tswitch host {\n\tcase \"localhost\", \"example.com\":\n\t\treturn true\n\t}\n\tif userDotRegexp.MatchString(user) || !userRegexp.MatchString(user) || !hostRegexp.MatchString(host) {\n\t\treturn false\n\t}\n\tif _, err := net.LookupMX(host); err != nil {\n\t\tif _, err := net.LookupIP(host); err != nil {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// IsURL checks if the string is an URL.\nfunc IsURL(str string) bool {\n\tif str == \"\" || utf8.RuneCountInString(str) >= maxURLRuneCount || len(str) <= minURLRuneCount || strings.HasPrefix(str, \".\") {\n\t\treturn false\n\t}\n\tstrTemp := str\n\tif strings.Contains(str, \":\") && !strings.Contains(str, \"://\") {\n\t\t// support no indicated urlscheme but with colon for port number\n\t\t// http:// is appended so url.Parse will succeed, strTemp used so it does not impact rxURL.MatchString\n\t\tstrTemp = \"http://\" + str\n\t}\n\tu, err := url.Parse(strTemp)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif strings.HasPrefix(u.Host, \".\") {\n\t\treturn false\n\t}\n\tif u.Host == \"\" && (u.Path != \"\" && !strings.Contains(u.Path, \".\")) {\n\t\treturn false\n\t}\n\treturn rxURL.MatchString(str)\n}\n\n// IsRequestURL checks if the string rawurl, assuming\n// it was received in an HTTP request, is a valid\n// URL confirm to RFC 3986\nfunc IsRequestURL(rawurl string) bool {\n\turl, err := url.ParseRequestURI(rawurl)\n\tif err != nil {\n\t\treturn false //Couldn't even parse the rawurl\n\t}\n\tif len(url.Scheme) == 0 {\n\t\treturn false //No Scheme found\n\t}\n\treturn true\n}\n\n// IsRequestURI checks if the string rawurl, assuming\n// it was received in an HTTP request, is an\n// absolute URI or an absolute path.\nfunc IsRequestURI(rawurl string) bool {\n\t_, err := url.ParseRequestURI(rawurl)\n\treturn err == nil\n}\n\n// IsAlpha checks if the string contains only letters (a-zA-Z). Empty string is valid.\nfunc IsAlpha(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxAlpha.MatchString(str)\n}\n\n//IsUTFLetter checks if the string contains only unicode letter characters.\n//Similar to IsAlpha but for all languages. Empty string is valid.\nfunc IsUTFLetter(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\n\tfor _, c := range str {\n\t\tif !unicode.IsLetter(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n\n}\n\n// IsAlphanumeric checks if the string contains only letters and numbers. Empty string is valid.\nfunc IsAlphanumeric(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxAlphanumeric.MatchString(str)\n}\n\n// IsUTFLetterNumeric checks if the string contains only unicode letters and numbers. Empty string is valid.\nfunc IsUTFLetterNumeric(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\tfor _, c := range str {\n\t\tif !unicode.IsLetter(c) && !unicode.IsNumber(c) { //letters && numbers are ok\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n\n}\n\n// IsNumeric checks if the string contains only numbers. Empty string is valid.\nfunc IsNumeric(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxNumeric.MatchString(str)\n}\n\n// IsUTFNumeric checks if the string contains only unicode numbers of any kind.\n// Numbers can be 0-9 but also Fractions ¾,Roman Ⅸ and Hangzhou 〩. Empty string is valid.\nfunc IsUTFNumeric(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\tif strings.IndexAny(str, \"+-\") > 0 {\n\t\treturn false\n\t}\n\tif len(str) > 1 {\n\t\tstr = strings.TrimPrefix(str, \"-\")\n\t\tstr = strings.TrimPrefix(str, \"+\")\n\t}\n\tfor _, c := range str {\n\t\tif !unicode.IsNumber(c) { //numbers && minus sign are ok\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n\n}\n\n// IsUTFDigit checks if the string contains only unicode radix-10 decimal digits. Empty string is valid.\nfunc IsUTFDigit(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\tif strings.IndexAny(str, \"+-\") > 0 {\n\t\treturn false\n\t}\n\tif len(str) > 1 {\n\t\tstr = strings.TrimPrefix(str, \"-\")\n\t\tstr = strings.TrimPrefix(str, \"+\")\n\t}\n\tfor _, c := range str {\n\t\tif !unicode.IsDigit(c) { //digits && minus sign are ok\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n\n}\n\n// IsHexadecimal checks if the string is a hexadecimal number.\nfunc IsHexadecimal(str string) bool {\n\treturn rxHexadecimal.MatchString(str)\n}\n\n// IsHexcolor checks if the string is a hexadecimal color.\nfunc IsHexcolor(str string) bool {\n\treturn rxHexcolor.MatchString(str)\n}\n\n// IsRGBcolor checks if the string is a valid RGB color in form rgb(RRR, GGG, BBB).\nfunc IsRGBcolor(str string) bool {\n\treturn rxRGBcolor.MatchString(str)\n}\n\n// IsLowerCase checks if the string is lowercase. Empty string is valid.\nfunc IsLowerCase(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn str == strings.ToLower(str)\n}\n\n// IsUpperCase checks if the string is uppercase. Empty string is valid.\nfunc IsUpperCase(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn str == strings.ToUpper(str)\n}\n\n// HasLowerCase checks if the string contains at least 1 lowercase. Empty string is valid.\nfunc HasLowerCase(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxHasLowerCase.MatchString(str)\n}\n\n// HasUpperCase checks if the string contains as least 1 uppercase. Empty string is valid.\nfunc HasUpperCase(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxHasUpperCase.MatchString(str)\n}\n\n// IsInt checks if the string is an integer. Empty string is valid.\nfunc IsInt(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxInt.MatchString(str)\n}\n\n// IsFloat checks if the string is a float.\nfunc IsFloat(str string) bool {\n\treturn str != \"\" && rxFloat.MatchString(str)\n}\n\n// IsDivisibleBy checks if the string is a number that's divisible by another.\n// If second argument is not valid integer or zero, it's return false.\n// Otherwise, if first argument is not valid integer or zero, it's return true (Invalid string converts to zero).\nfunc IsDivisibleBy(str, num string) bool {\n\tf, _ := ToFloat(str)\n\tp := int64(f)\n\tq, _ := ToInt(num)\n\tif q == 0 {\n\t\treturn false\n\t}\n\treturn (p == 0) || (p%q == 0)\n}\n\n// IsNull checks if the string is null.\nfunc IsNull(str string) bool {\n\treturn len(str) == 0\n}\n\n// IsNotNull checks if the string is not null.\nfunc IsNotNull(str string) bool {\n\treturn !IsNull(str)\n}\n\n// HasWhitespaceOnly checks the string only contains whitespace\nfunc HasWhitespaceOnly(str string) bool {\n\treturn len(str) > 0 && rxHasWhitespaceOnly.MatchString(str)\n}\n\n// HasWhitespace checks if the string contains any whitespace\nfunc HasWhitespace(str string) bool {\n\treturn len(str) > 0 && rxHasWhitespace.MatchString(str)\n}\n\n// IsByteLength checks if the string's length (in bytes) falls in a range.\nfunc IsByteLength(str string, min, max int) bool {\n\treturn len(str) >= min && len(str) <= max\n}\n\n// IsUUIDv3 checks if the string is a UUID version 3.\nfunc IsUUIDv3(str string) bool {\n\treturn rxUUID3.MatchString(str)\n}\n\n// IsUUIDv4 checks if the string is a UUID version 4.\nfunc IsUUIDv4(str string) bool {\n\treturn rxUUID4.MatchString(str)\n}\n\n// IsUUIDv5 checks if the string is a UUID version 5.\nfunc IsUUIDv5(str string) bool {\n\treturn rxUUID5.MatchString(str)\n}\n\n// IsUUID checks if the string is a UUID (version 3, 4 or 5).\nfunc IsUUID(str string) bool {\n\treturn rxUUID.MatchString(str)\n}\n\n// Byte to index table for O(1) lookups when unmarshaling.\n// We use 0xFF as sentinel value for invalid indexes.\nvar ulidDec = [...]byte{\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n\t0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14, 0x15, 0xFF,\n\t0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,\n\t0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,\n\t0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,\n\t0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n}\n\n// EncodedSize is the length of a text encoded ULID.\nconst ulidEncodedSize = 26\n\n// IsULID checks if the string is a ULID.\n//\n// Implementation got from:\n//   https://github.com/oklog/ulid (Apache-2.0 License)\n//\nfunc IsULID(str string) bool {\n\t// Check if a base32 encoded ULID is the right length.\n\tif len(str) != ulidEncodedSize {\n\t\treturn false\n\t}\n\n\t// Check if all the characters in a base32 encoded ULID are part of the\n\t// expected base32 character set.\n\tif ulidDec[str[0]] == 0xFF ||\n\t\tulidDec[str[1]] == 0xFF ||\n\t\tulidDec[str[2]] == 0xFF ||\n\t\tulidDec[str[3]] == 0xFF ||\n\t\tulidDec[str[4]] == 0xFF ||\n\t\tulidDec[str[5]] == 0xFF ||\n\t\tulidDec[str[6]] == 0xFF ||\n\t\tulidDec[str[7]] == 0xFF ||\n\t\tulidDec[str[8]] == 0xFF ||\n\t\tulidDec[str[9]] == 0xFF ||\n\t\tulidDec[str[10]] == 0xFF ||\n\t\tulidDec[str[11]] == 0xFF ||\n\t\tulidDec[str[12]] == 0xFF ||\n\t\tulidDec[str[13]] == 0xFF ||\n\t\tulidDec[str[14]] == 0xFF ||\n\t\tulidDec[str[15]] == 0xFF ||\n\t\tulidDec[str[16]] == 0xFF ||\n\t\tulidDec[str[17]] == 0xFF ||\n\t\tulidDec[str[18]] == 0xFF ||\n\t\tulidDec[str[19]] == 0xFF ||\n\t\tulidDec[str[20]] == 0xFF ||\n\t\tulidDec[str[21]] == 0xFF ||\n\t\tulidDec[str[22]] == 0xFF ||\n\t\tulidDec[str[23]] == 0xFF ||\n\t\tulidDec[str[24]] == 0xFF ||\n\t\tulidDec[str[25]] == 0xFF {\n\t\treturn false\n\t}\n\n\t// Check if the first character in a base32 encoded ULID will overflow. This\n\t// happens because the base32 representation encodes 130 bits, while the\n\t// ULID is only 128 bits.\n\t//\n\t// See https://github.com/oklog/ulid/issues/9 for details.\n\tif str[0] > '7' {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// IsCreditCard checks if the string is a credit card.\nfunc IsCreditCard(str string) bool {\n\tsanitized := whiteSpacesAndMinus.ReplaceAllString(str, \"\")\n\tif !rxCreditCard.MatchString(sanitized) {\n\t\treturn false\n\t}\n\t\n\tnumber, _ := ToInt(sanitized)\n\tnumber, lastDigit := number / 10, number % 10\t\n\n\tvar sum int64\n\tfor i:=0; number > 0; i++ {\n\t\tdigit := number % 10\n\t\t\n\t\tif i % 2 == 0 {\n\t\t\tdigit *= 2\n\t\t\tif digit > 9 {\n\t\t\t\tdigit -= 9\n\t\t\t}\n\t\t}\n\t\t\n\t\tsum += digit\n\t\tnumber = number / 10\n\t}\n\t\n\treturn (sum + lastDigit) % 10 == 0\n}\n\n// IsISBN10 checks if the string is an ISBN version 10.\nfunc IsISBN10(str string) bool {\n\treturn IsISBN(str, 10)\n}\n\n// IsISBN13 checks if the string is an ISBN version 13.\nfunc IsISBN13(str string) bool {\n\treturn IsISBN(str, 13)\n}\n\n// IsISBN checks if the string is an ISBN (version 10 or 13).\n// If version value is not equal to 10 or 13, it will be checks both variants.\nfunc IsISBN(str string, version int) bool {\n\tsanitized := whiteSpacesAndMinus.ReplaceAllString(str, \"\")\n\tvar checksum int32\n\tvar i int32\n\tif version == 10 {\n\t\tif !rxISBN10.MatchString(sanitized) {\n\t\t\treturn false\n\t\t}\n\t\tfor i = 0; i < 9; i++ {\n\t\t\tchecksum += (i + 1) * int32(sanitized[i]-'0')\n\t\t}\n\t\tif sanitized[9] == 'X' {\n\t\t\tchecksum += 10 * 10\n\t\t} else {\n\t\t\tchecksum += 10 * int32(sanitized[9]-'0')\n\t\t}\n\t\tif checksum%11 == 0 {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t} else if version == 13 {\n\t\tif !rxISBN13.MatchString(sanitized) {\n\t\t\treturn false\n\t\t}\n\t\tfactor := []int32{1, 3}\n\t\tfor i = 0; i < 12; i++ {\n\t\t\tchecksum += factor[i%2] * int32(sanitized[i]-'0')\n\t\t}\n\t\treturn (int32(sanitized[12]-'0'))-((10-(checksum%10))%10) == 0\n\t}\n\treturn IsISBN(str, 10) || IsISBN(str, 13)\n}\n\n// IsJSON checks if the string is valid JSON (note: uses json.Unmarshal).\nfunc IsJSON(str string) bool {\n\tvar js json.RawMessage\n\treturn json.Unmarshal([]byte(str), &js) == nil\n}\n\n// IsMultibyte checks if the string contains one or more multibyte chars. Empty string is valid.\nfunc IsMultibyte(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxMultibyte.MatchString(str)\n}\n\n// IsASCII checks if the string contains ASCII chars only. Empty string is valid.\nfunc IsASCII(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxASCII.MatchString(str)\n}\n\n// IsPrintableASCII checks if the string contains printable ASCII chars only. Empty string is valid.\nfunc IsPrintableASCII(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxPrintableASCII.MatchString(str)\n}\n\n// IsFullWidth checks if the string contains any full-width chars. Empty string is valid.\nfunc IsFullWidth(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxFullWidth.MatchString(str)\n}\n\n// IsHalfWidth checks if the string contains any half-width chars. Empty string is valid.\nfunc IsHalfWidth(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxHalfWidth.MatchString(str)\n}\n\n// IsVariableWidth checks if the string contains a mixture of full and half-width chars. Empty string is valid.\nfunc IsVariableWidth(str string) bool {\n\tif IsNull(str) {\n\t\treturn true\n\t}\n\treturn rxHalfWidth.MatchString(str) && rxFullWidth.MatchString(str)\n}\n\n// IsBase64 checks if a string is base64 encoded.\nfunc IsBase64(str string) bool {\n\treturn rxBase64.MatchString(str)\n}\n\n// IsFilePath checks is a string is Win or Unix file path and returns it's type.\nfunc IsFilePath(str string) (bool, int) {\n\tif rxWinPath.MatchString(str) {\n\t\t//check windows path limit see:\n\t\t//  http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath\n\t\tif len(str[3:]) > 32767 {\n\t\t\treturn false, Win\n\t\t}\n\t\treturn true, Win\n\t} else if rxUnixPath.MatchString(str) {\n\t\treturn true, Unix\n\t}\n\treturn false, Unknown\n}\n\n//IsWinFilePath checks both relative & absolute paths in Windows\nfunc IsWinFilePath(str string) bool {\n\tif rxARWinPath.MatchString(str) {\n\t\t//check windows path limit see:\n\t\t//  http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath\n\t\tif len(str[3:]) > 32767 {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\n//IsUnixFilePath checks both relative & absolute paths in Unix\nfunc IsUnixFilePath(str string) bool {\n\tif rxARUnixPath.MatchString(str) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsDataURI checks if a string is base64 encoded data URI such as an image\nfunc IsDataURI(str string) bool {\n\tdataURI := strings.Split(str, \",\")\n\tif !rxDataURI.MatchString(dataURI[0]) {\n\t\treturn false\n\t}\n\treturn IsBase64(dataURI[1])\n}\n\n// IsMagnetURI checks if a string is valid magnet URI\nfunc IsMagnetURI(str string) bool {\n\treturn rxMagnetURI.MatchString(str)\n}\n\n// IsISO3166Alpha2 checks if a string is valid two-letter country code\nfunc IsISO3166Alpha2(str string) bool {\n\tfor _, entry := range ISO3166List {\n\t\tif str == entry.Alpha2Code {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsISO3166Alpha3 checks if a string is valid three-letter country code\nfunc IsISO3166Alpha3(str string) bool {\n\tfor _, entry := range ISO3166List {\n\t\tif str == entry.Alpha3Code {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsISO693Alpha2 checks if a string is valid two-letter language code\nfunc IsISO693Alpha2(str string) bool {\n\tfor _, entry := range ISO693List {\n\t\tif str == entry.Alpha2Code {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsISO693Alpha3b checks if a string is valid three-letter language code\nfunc IsISO693Alpha3b(str string) bool {\n\tfor _, entry := range ISO693List {\n\t\tif str == entry.Alpha3bCode {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsDNSName will validate the given string as a DNS name\nfunc IsDNSName(str string) bool {\n\tif str == \"\" || len(strings.Replace(str, \".\", \"\", -1)) > 255 {\n\t\t// constraints already violated\n\t\treturn false\n\t}\n\treturn !IsIP(str) && rxDNSName.MatchString(str)\n}\n\n// IsHash checks if a string is a hash of type algorithm.\n// Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128', 'tiger160', 'tiger192', 'crc32', 'crc32b']\nfunc IsHash(str string, algorithm string) bool {\n\tvar len string\n\talgo := strings.ToLower(algorithm)\n\n\tif algo == \"crc32\" || algo == \"crc32b\" {\n\t\tlen = \"8\"\n\t} else if algo == \"md5\" || algo == \"md4\" || algo == \"ripemd128\" || algo == \"tiger128\" {\n\t\tlen = \"32\"\n\t} else if algo == \"sha1\" || algo == \"ripemd160\" || algo == \"tiger160\" {\n\t\tlen = \"40\"\n\t} else if algo == \"tiger192\" {\n\t\tlen = \"48\"\n\t} else if algo == \"sha3-224\" {\n\t\tlen = \"56\"\n\t} else if algo == \"sha256\" || algo == \"sha3-256\" {\n\t\tlen = \"64\"\n\t} else if algo == \"sha384\" || algo == \"sha3-384\" {\n\t\tlen = \"96\"\n\t} else if algo == \"sha512\" || algo == \"sha3-512\" {\n\t\tlen = \"128\"\n\t} else {\n\t\treturn false\n\t}\n\n\treturn Matches(str, \"^[a-f0-9]{\"+len+\"}$\")\n}\n\n// IsSHA3224 checks is a string is a SHA3-224 hash. Alias for `IsHash(str, \"sha3-224\")`\nfunc IsSHA3224(str string) bool {\n\treturn IsHash(str, \"sha3-224\")\n}\n\n// IsSHA3256 checks is a string is a SHA3-256 hash. Alias for `IsHash(str, \"sha3-256\")`\nfunc IsSHA3256(str string) bool {\n\treturn IsHash(str, \"sha3-256\")\n}\n\n// IsSHA3384 checks is a string is a SHA3-384 hash. Alias for `IsHash(str, \"sha3-384\")`\nfunc IsSHA3384(str string) bool {\n\treturn IsHash(str, \"sha3-384\")\n}\n\n// IsSHA3512 checks is a string is a SHA3-512 hash. Alias for `IsHash(str, \"sha3-512\")`\nfunc IsSHA3512(str string) bool {\n\treturn IsHash(str, \"sha3-512\")\n}\n\n// IsSHA512 checks is a string is a SHA512 hash. Alias for `IsHash(str, \"sha512\")`\nfunc IsSHA512(str string) bool {\n\treturn IsHash(str, \"sha512\")\n}\n\n// IsSHA384 checks is a string is a SHA384 hash. Alias for `IsHash(str, \"sha384\")`\nfunc IsSHA384(str string) bool {\n\treturn IsHash(str, \"sha384\")\n}\n\n// IsSHA256 checks is a string is a SHA256 hash. Alias for `IsHash(str, \"sha256\")`\nfunc IsSHA256(str string) bool {\n\treturn IsHash(str, \"sha256\")\n}\n\n// IsTiger192 checks is a string is a Tiger192 hash. Alias for `IsHash(str, \"tiger192\")`\nfunc IsTiger192(str string) bool {\n\treturn IsHash(str, \"tiger192\")\n}\n\n// IsTiger160 checks is a string is a Tiger160 hash. Alias for `IsHash(str, \"tiger160\")`\nfunc IsTiger160(str string) bool {\n\treturn IsHash(str, \"tiger160\")\n}\n\n// IsRipeMD160 checks is a string is a RipeMD160 hash. Alias for `IsHash(str, \"ripemd160\")`\nfunc IsRipeMD160(str string) bool {\n\treturn IsHash(str, \"ripemd160\")\n}\n\n// IsSHA1 checks is a string is a SHA-1 hash. Alias for `IsHash(str, \"sha1\")`\nfunc IsSHA1(str string) bool {\n\treturn IsHash(str, \"sha1\")\n}\n\n// IsTiger128 checks is a string is a Tiger128 hash. Alias for `IsHash(str, \"tiger128\")`\nfunc IsTiger128(str string) bool {\n\treturn IsHash(str, \"tiger128\")\n}\n\n// IsRipeMD128 checks is a string is a RipeMD128 hash. Alias for `IsHash(str, \"ripemd128\")`\nfunc IsRipeMD128(str string) bool {\n\treturn IsHash(str, \"ripemd128\")\n}\n\n// IsCRC32 checks is a string is a CRC32 hash. Alias for `IsHash(str, \"crc32\")`\nfunc IsCRC32(str string) bool {\n\treturn IsHash(str, \"crc32\")\n}\n\n// IsCRC32b checks is a string is a CRC32b hash. Alias for `IsHash(str, \"crc32b\")`\nfunc IsCRC32b(str string) bool {\n\treturn IsHash(str, \"crc32b\")\n}\n\n// IsMD5 checks is a string is a MD5 hash. Alias for `IsHash(str, \"md5\")`\nfunc IsMD5(str string) bool {\n\treturn IsHash(str, \"md5\")\n}\n\n// IsMD4 checks is a string is a MD4 hash. Alias for `IsHash(str, \"md4\")`\nfunc IsMD4(str string) bool {\n\treturn IsHash(str, \"md4\")\n}\n\n// IsDialString validates the given string for usage with the various Dial() functions\nfunc IsDialString(str string) bool {\n\tif h, p, err := net.SplitHostPort(str); err == nil && h != \"\" && p != \"\" && (IsDNSName(h) || IsIP(h)) && IsPort(p) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// IsIP checks if a string is either IP version 4 or 6. Alias for `net.ParseIP`\nfunc IsIP(str string) bool {\n\treturn net.ParseIP(str) != nil\n}\n\n// IsPort checks if a string represents a valid port\nfunc IsPort(str string) bool {\n\tif i, err := strconv.Atoi(str); err == nil && i > 0 && i < 65536 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsIPv4 checks if the string is an IP version 4.\nfunc IsIPv4(str string) bool {\n\tip := net.ParseIP(str)\n\treturn ip != nil && strings.Contains(str, \".\")\n}\n\n// IsIPv6 checks if the string is an IP version 6.\nfunc IsIPv6(str string) bool {\n\tip := net.ParseIP(str)\n\treturn ip != nil && strings.Contains(str, \":\")\n}\n\n// IsCIDR checks if the string is an valid CIDR notiation (IPV4 & IPV6)\nfunc IsCIDR(str string) bool {\n\t_, _, err := net.ParseCIDR(str)\n\treturn err == nil\n}\n\n// IsMAC checks if a string is valid MAC address.\n// Possible MAC formats:\n// 01:23:45:67:89:ab\n// 01:23:45:67:89:ab:cd:ef\n// 01-23-45-67-89-ab\n// 01-23-45-67-89-ab-cd-ef\n// 0123.4567.89ab\n// 0123.4567.89ab.cdef\nfunc IsMAC(str string) bool {\n\t_, err := net.ParseMAC(str)\n\treturn err == nil\n}\n\n// IsHost checks if the string is a valid IP (both v4 and v6) or a valid DNS name\nfunc IsHost(str string) bool {\n\treturn IsIP(str) || IsDNSName(str)\n}\n\n// IsMongoID checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\nfunc IsMongoID(str string) bool {\n\treturn rxHexadecimal.MatchString(str) && (len(str) == 24)\n}\n\n// IsLatitude checks if a string is valid latitude.\nfunc IsLatitude(str string) bool {\n\treturn rxLatitude.MatchString(str)\n}\n\n// IsLongitude checks if a string is valid longitude.\nfunc IsLongitude(str string) bool {\n\treturn rxLongitude.MatchString(str)\n}\n\n// IsIMEI checks if a string is valid IMEI\nfunc IsIMEI(str string) bool {\n\treturn rxIMEI.MatchString(str)\n}\n\n// IsIMSI checks if a string is valid IMSI\nfunc IsIMSI(str string) bool {\n\tif !rxIMSI.MatchString(str) {\n\t\treturn false\n\t}\n\n\tmcc, err := strconv.ParseInt(str[0:3], 10, 32)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tswitch mcc {\n\tcase 202, 204, 206, 208, 212, 213, 214, 216, 218, 219:\n\tcase 220, 221, 222, 226, 228, 230, 231, 232, 234, 235:\n\tcase 238, 240, 242, 244, 246, 247, 248, 250, 255, 257:\n\tcase 259, 260, 262, 266, 268, 270, 272, 274, 276, 278:\n\tcase 280, 282, 283, 284, 286, 288, 289, 290, 292, 293:\n\tcase 294, 295, 297, 302, 308, 310, 311, 312, 313, 314:\n\tcase 315, 316, 330, 332, 334, 338, 340, 342, 344, 346:\n\tcase 348, 350, 352, 354, 356, 358, 360, 362, 363, 364:\n\tcase 365, 366, 368, 370, 372, 374, 376, 400, 401, 402:\n\tcase 404, 405, 406, 410, 412, 413, 414, 415, 416, 417:\n\tcase 418, 419, 420, 421, 422, 424, 425, 426, 427, 428:\n\tcase 429, 430, 431, 432, 434, 436, 437, 438, 440, 441:\n\tcase 450, 452, 454, 455, 456, 457, 460, 461, 466, 467:\n\tcase 470, 472, 502, 505, 510, 514, 515, 520, 525, 528:\n\tcase 530, 536, 537, 539, 540, 541, 542, 543, 544, 545:\n\tcase 546, 547, 548, 549, 550, 551, 552, 553, 554, 555:\n\tcase 602, 603, 604, 605, 606, 607, 608, 609, 610, 611:\n\tcase 612, 613, 614, 615, 616, 617, 618, 619, 620, 621:\n\tcase 622, 623, 624, 625, 626, 627, 628, 629, 630, 631:\n\tcase 632, 633, 634, 635, 636, 637, 638, 639, 640, 641:\n\tcase 642, 643, 645, 646, 647, 648, 649, 650, 651, 652:\n\tcase 653, 654, 655, 657, 658, 659, 702, 704, 706, 708:\n\tcase 710, 712, 714, 716, 722, 724, 730, 732, 734, 736:\n\tcase 738, 740, 742, 744, 746, 748, 750, 995:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// IsRsaPublicKey checks if a string is valid public key with provided length\nfunc IsRsaPublicKey(str string, keylen int) bool {\n\tbb := bytes.NewBufferString(str)\n\tpemBytes, err := ioutil.ReadAll(bb)\n\tif err != nil {\n\t\treturn false\n\t}\n\tblock, _ := pem.Decode(pemBytes)\n\tif block != nil && block.Type != \"PUBLIC KEY\" {\n\t\treturn false\n\t}\n\tvar der []byte\n\n\tif block != nil {\n\t\tder = block.Bytes\n\t} else {\n\t\tder, err = base64.StdEncoding.DecodeString(str)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tkey, err := x509.ParsePKIXPublicKey(der)\n\tif err != nil {\n\t\treturn false\n\t}\n\tpubkey, ok := key.(*rsa.PublicKey)\n\tif !ok {\n\t\treturn false\n\t}\n\tbitlen := len(pubkey.N.Bytes()) * 8\n\treturn bitlen == int(keylen)\n}\n\n// IsRegex checks if a give string is a valid regex with RE2 syntax or not\nfunc IsRegex(str string) bool {\n\tif _, err := regexp.Compile(str); err == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc toJSONName(tag string) string {\n\tif tag == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// JSON name always comes first. If there's no options then split[0] is\n\t// JSON name, if JSON name is not set, then split[0] is an empty string.\n\tsplit := strings.SplitN(tag, \",\", 2)\n\n\tname := split[0]\n\n\t// However it is possible that the field is skipped when\n\t// (de-)serializing from/to JSON, in which case assume that there is no\n\t// tag name to use\n\tif name == \"-\" {\n\t\treturn \"\"\n\t}\n\treturn name\n}\n\nfunc prependPathToErrors(err error, path string) error {\n\tswitch err2 := err.(type) {\n\tcase Error:\n\t\terr2.Path = append([]string{path}, err2.Path...)\n\t\treturn err2\n\tcase Errors:\n\t\terrors := err2.Errors()\n\t\tfor i, err3 := range errors {\n\t\t\terrors[i] = prependPathToErrors(err3, path)\n\t\t}\n\t\treturn err2\n\t}\n\treturn err\n}\n\n// ValidateArray performs validation according to condition iterator that validates every element of the array\nfunc ValidateArray(array []interface{}, iterator ConditionIterator) bool {\n\treturn Every(array, iterator)\n}\n\n// ValidateMap use validation map for fields.\n// result will be equal to `false` if there are any errors.\n// s is the map containing the data to be validated.\n// m is the validation map in the form:\n//   map[string]interface{}{\"name\":\"required,alpha\",\"address\":map[string]interface{}{\"line1\":\"required,alphanum\"}}\nfunc ValidateMap(s map[string]interface{}, m map[string]interface{}) (bool, error) {\n\tif s == nil {\n\t\treturn true, nil\n\t}\n\tresult := true\n\tvar err error\n\tvar errs Errors\n\tvar index int\n\tval := reflect.ValueOf(s)\n\tfor key, value := range s {\n\t\tpresentResult := true\n\t\tvalidator, ok := m[key]\n\t\tif !ok {\n\t\t\tpresentResult = false\n\t\t\tvar err error\n\t\t\terr = fmt.Errorf(\"all map keys has to be present in the validation map; got %s\", key)\n\t\t\terr = prependPathToErrors(err, key)\n\t\t\terrs = append(errs, err)\n\t\t}\n\t\tvalueField := reflect.ValueOf(value)\n\t\tmapResult := true\n\t\ttypeResult := true\n\t\tstructResult := true\n\t\tresultField := true\n\t\tswitch subValidator := validator.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tvar err error\n\t\t\tif v, ok := value.(map[string]interface{}); !ok {\n\t\t\t\tmapResult = false\n\t\t\t\terr = fmt.Errorf(\"map validator has to be for the map type only; got %s\", valueField.Type().String())\n\t\t\t\terr = prependPathToErrors(err, key)\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else {\n\t\t\t\tmapResult, err = ValidateMap(v, subValidator)\n\t\t\t\tif err != nil {\n\t\t\t\t\tmapResult = false\n\t\t\t\t\terr = prependPathToErrors(err, key)\n\t\t\t\t\terrs = append(errs, err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase string:\n\t\t\tif (valueField.Kind() == reflect.Struct ||\n\t\t\t\t(valueField.Kind() == reflect.Ptr && valueField.Elem().Kind() == reflect.Struct)) &&\n\t\t\t\tsubValidator != \"-\" {\n\t\t\t\tvar err error\n\t\t\t\tstructResult, err = ValidateStruct(valueField.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = prependPathToErrors(err, key)\n\t\t\t\t\terrs = append(errs, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresultField, err = typeCheck(valueField, reflect.StructField{\n\t\t\t\tName:      key,\n\t\t\t\tPkgPath:   \"\",\n\t\t\t\tType:      val.Type(),\n\t\t\t\tTag:       reflect.StructTag(fmt.Sprintf(\"%s:%q\", tagName, subValidator)),\n\t\t\t\tOffset:    0,\n\t\t\t\tIndex:     []int{index},\n\t\t\t\tAnonymous: false,\n\t\t\t}, val, nil)\n\t\t\tif err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t}\n\t\tcase nil:\n\t\t\t// already handlerd when checked before\n\t\tdefault:\n\t\t\ttypeResult = false\n\t\t\terr = fmt.Errorf(\"map validator has to be either map[string]interface{} or string; got %s\", valueField.Type().String())\n\t\t\terr = prependPathToErrors(err, key)\n\t\t\terrs = append(errs, err)\n\t\t}\n\t\tresult = result && presentResult && typeResult && resultField && structResult && mapResult\n\t\tindex++\n\t}\n\t// checks required keys\n\trequiredResult := true\n\tfor key, value := range m {\n\t\tif schema, ok := value.(string); ok {\n\t\t\ttags := parseTagIntoMap(schema)\n\t\t\tif required, ok := tags[\"required\"]; ok {\n\t\t\t\tif _, ok := s[key]; !ok {\n\t\t\t\t\trequiredResult = false\n\t\t\t\t\tif required.customErrorMessage != \"\" {\n\t\t\t\t\t\terr = Error{key, fmt.Errorf(required.customErrorMessage), true, \"required\", []string{}}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = Error{key, fmt.Errorf(\"required field missing\"), false, \"required\", []string{}}\n\t\t\t\t\t}\n\t\t\t\t\terrs = append(errs, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\terr = errs\n\t}\n\treturn result && requiredResult, err\n}\n\n// ValidateStruct use tags for fields.\n// result will be equal to `false` if there are any errors.\n// todo currently there is no guarantee that errors will be returned in predictable order (tests may to fail)\nfunc ValidateStruct(s interface{}) (bool, error) {\n\tif s == nil {\n\t\treturn true, nil\n\t}\n\tresult := true\n\tvar err error\n\tval := reflect.ValueOf(s)\n\tif val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t}\n\t// we only accept structs\n\tif val.Kind() != reflect.Struct {\n\t\treturn false, fmt.Errorf(\"function only accepts structs; got %s\", val.Kind())\n\t}\n\tvar errs Errors\n\tfor i := 0; i < val.NumField(); i++ {\n\t\tvalueField := val.Field(i)\n\t\ttypeField := val.Type().Field(i)\n\t\tif typeField.PkgPath != \"\" {\n\t\t\tcontinue // Private field\n\t\t}\n\t\tstructResult := true\n\t\tif valueField.Kind() == reflect.Interface {\n\t\t\tvalueField = valueField.Elem()\n\t\t}\n\t\tif (valueField.Kind() == reflect.Struct ||\n\t\t\t(valueField.Kind() == reflect.Ptr && valueField.Elem().Kind() == reflect.Struct)) &&\n\t\t\ttypeField.Tag.Get(tagName) != \"-\" {\n\t\t\tvar err error\n\t\t\tstructResult, err = ValidateStruct(valueField.Interface())\n\t\t\tif err != nil {\n\t\t\t\terr = prependPathToErrors(err, typeField.Name)\n\t\t\t\terrs = append(errs, err)\n\t\t\t}\n\t\t}\n\t\tresultField, err2 := typeCheck(valueField, typeField, val, nil)\n\t\tif err2 != nil {\n\n\t\t\t// Replace structure name with JSON name if there is a tag on the variable\n\t\t\tjsonTag := toJSONName(typeField.Tag.Get(\"json\"))\n\t\t\tif jsonTag != \"\" {\n\t\t\t\tswitch jsonError := err2.(type) {\n\t\t\t\tcase Error:\n\t\t\t\t\tjsonError.Name = jsonTag\n\t\t\t\t\terr2 = jsonError\n\t\t\t\tcase Errors:\n\t\t\t\t\tfor i2, err3 := range jsonError {\n\t\t\t\t\t\tswitch customErr := err3.(type) {\n\t\t\t\t\t\tcase Error:\n\t\t\t\t\t\t\tcustomErr.Name = jsonTag\n\t\t\t\t\t\t\tjsonError[i2] = customErr\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\terr2 = jsonError\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terrs = append(errs, err2)\n\t\t}\n\t\tresult = result && resultField && structResult\n\t}\n\tif len(errs) > 0 {\n\t\terr = errs\n\t}\n\treturn result, err\n}\n\n// ValidateStructAsync performs async validation of the struct and returns results through the channels\nfunc ValidateStructAsync(s interface{}) (<-chan bool, <-chan error) {\n\tres := make(chan bool)\n\terrors := make(chan error)\n\n\tgo func() {\n\t\tdefer close(res)\n\t\tdefer close(errors)\n\n\t\tisValid, isFailed := ValidateStruct(s)\n\n\t\tres <- isValid\n\t\terrors <- isFailed\n\t}()\n\n\treturn res, errors\n}\n\n// ValidateMapAsync performs async validation of the map and returns results through the channels\nfunc ValidateMapAsync(s map[string]interface{}, m map[string]interface{}) (<-chan bool, <-chan error) {\n\tres := make(chan bool)\n\terrors := make(chan error)\n\n\tgo func() {\n\t\tdefer close(res)\n\t\tdefer close(errors)\n\n\t\tisValid, isFailed := ValidateMap(s, m)\n\n\t\tres <- isValid\n\t\terrors <- isFailed\n\t}()\n\n\treturn res, errors\n}\n\n// parseTagIntoMap parses a struct tag `valid:required~Some error message,length(2|3)` into map[string]string{\"required\": \"Some error message\", \"length(2|3)\": \"\"}\nfunc parseTagIntoMap(tag string) tagOptionsMap {\n\toptionsMap := make(tagOptionsMap)\n\toptions := strings.Split(tag, \",\")\n\n\tfor i, option := range options {\n\t\toption = strings.TrimSpace(option)\n\n\t\tvalidationOptions := strings.Split(option, \"~\")\n\t\tif !isValidTag(validationOptions[0]) {\n\t\t\tcontinue\n\t\t}\n\t\tif len(validationOptions) == 2 {\n\t\t\toptionsMap[validationOptions[0]] = tagOption{validationOptions[0], validationOptions[1], i}\n\t\t} else {\n\t\t\toptionsMap[validationOptions[0]] = tagOption{validationOptions[0], \"\", i}\n\t\t}\n\t}\n\treturn optionsMap\n}\n\nfunc isValidTag(s string) bool {\n\tif s == \"\" {\n\t\treturn false\n\t}\n\tfor _, c := range s {\n\t\tswitch {\n\t\tcase strings.ContainsRune(\"\\\\'\\\"!#$%&()*+-./:<=>?@[]^_{|}~ \", c):\n\t\t\t// Backslash and quote chars are reserved, but\n\t\t\t// otherwise any punctuation chars are allowed\n\t\t\t// in a tag name.\n\t\tdefault:\n\t\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// IsSSN will validate the given string as a U.S. Social Security Number\nfunc IsSSN(str string) bool {\n\tif str == \"\" || len(str) != 11 {\n\t\treturn false\n\t}\n\treturn rxSSN.MatchString(str)\n}\n\n// IsSemver checks if string is valid semantic version\nfunc IsSemver(str string) bool {\n\treturn rxSemver.MatchString(str)\n}\n\n// IsType checks if interface is of some type\nfunc IsType(v interface{}, params ...string) bool {\n\tif len(params) == 1 {\n\t\ttyp := params[0]\n\t\treturn strings.Replace(reflect.TypeOf(v).String(), \" \", \"\", -1) == strings.Replace(typ, \" \", \"\", -1)\n\t}\n\treturn false\n}\n\n// IsTime checks if string is valid according to given format\nfunc IsTime(str string, format string) bool {\n\t_, err := time.Parse(format, str)\n\treturn err == nil\n}\n\n// IsUnixTime checks if string is valid unix timestamp value\nfunc IsUnixTime(str string) bool {\n\tif _, err := strconv.Atoi(str); err == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsRFC3339 checks if string is valid timestamp value according to RFC3339\nfunc IsRFC3339(str string) bool {\n\treturn IsTime(str, time.RFC3339)\n}\n\n// IsRFC3339WithoutZone checks if string is valid timestamp value according to RFC3339 which excludes the timezone.\nfunc IsRFC3339WithoutZone(str string) bool {\n\treturn IsTime(str, rfc3339WithoutZone)\n}\n\n// IsISO4217 checks if string is valid ISO currency code\nfunc IsISO4217(str string) bool {\n\tfor _, currency := range ISO4217List {\n\t\tif str == currency {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// ByteLength checks string's length\nfunc ByteLength(str string, params ...string) bool {\n\tif len(params) == 2 {\n\t\tmin, _ := ToInt(params[0])\n\t\tmax, _ := ToInt(params[1])\n\t\treturn len(str) >= int(min) && len(str) <= int(max)\n\t}\n\n\treturn false\n}\n\n// RuneLength checks string's length\n// Alias for StringLength\nfunc RuneLength(str string, params ...string) bool {\n\treturn StringLength(str, params...)\n}\n\n// IsRsaPub checks whether string is valid RSA key\n// Alias for IsRsaPublicKey\nfunc IsRsaPub(str string, params ...string) bool {\n\tif len(params) == 1 {\n\t\tlen, _ := ToInt(params[0])\n\t\treturn IsRsaPublicKey(str, int(len))\n\t}\n\n\treturn false\n}\n\n// StringMatches checks if a string matches a given pattern.\nfunc StringMatches(s string, params ...string) bool {\n\tif len(params) == 1 {\n\t\tpattern := params[0]\n\t\treturn Matches(s, pattern)\n\t}\n\treturn false\n}\n\n// StringLength checks string's length (including multi byte strings)\nfunc StringLength(str string, params ...string) bool {\n\n\tif len(params) == 2 {\n\t\tstrLength := utf8.RuneCountInString(str)\n\t\tmin, _ := ToInt(params[0])\n\t\tmax, _ := ToInt(params[1])\n\t\treturn strLength >= int(min) && strLength <= int(max)\n\t}\n\n\treturn false\n}\n\n// MinStringLength checks string's minimum length (including multi byte strings)\nfunc MinStringLength(str string, params ...string) bool {\n\n\tif len(params) == 1 {\n\t\tstrLength := utf8.RuneCountInString(str)\n\t\tmin, _ := ToInt(params[0])\n\t\treturn strLength >= int(min)\n\t}\n\n\treturn false\n}\n\n// MaxStringLength checks string's maximum length (including multi byte strings)\nfunc MaxStringLength(str string, params ...string) bool {\n\n\tif len(params) == 1 {\n\t\tstrLength := utf8.RuneCountInString(str)\n\t\tmax, _ := ToInt(params[0])\n\t\treturn strLength <= int(max)\n\t}\n\n\treturn false\n}\n\n// Range checks string's length\nfunc Range(str string, params ...string) bool {\n\tif len(params) == 2 {\n\t\tvalue, _ := ToFloat(str)\n\t\tmin, _ := ToFloat(params[0])\n\t\tmax, _ := ToFloat(params[1])\n\t\treturn InRange(value, min, max)\n\t}\n\n\treturn false\n}\n\n// IsInRaw checks if string is in list of allowed values\nfunc IsInRaw(str string, params ...string) bool {\n\tif len(params) == 1 {\n\t\trawParams := params[0]\n\n\t\tparsedParams := strings.Split(rawParams, \"|\")\n\n\t\treturn IsIn(str, parsedParams...)\n\t}\n\n\treturn false\n}\n\n// IsIn checks if string str is a member of the set of strings params\nfunc IsIn(str string, params ...string) bool {\n\tfor _, param := range params {\n\t\tif str == param {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc checkRequired(v reflect.Value, t reflect.StructField, options tagOptionsMap) (bool, error) {\n\tif nilPtrAllowedByRequired {\n\t\tk := v.Kind()\n\t\tif (k == reflect.Ptr || k == reflect.Interface) && v.IsNil() {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\tif requiredOption, isRequired := options[\"required\"]; isRequired {\n\t\tif len(requiredOption.customErrorMessage) > 0 {\n\t\t\treturn false, Error{t.Name, fmt.Errorf(requiredOption.customErrorMessage), true, \"required\", []string{}}\n\t\t}\n\t\treturn false, Error{t.Name, fmt.Errorf(\"non zero value required\"), false, \"required\", []string{}}\n\t} else if _, isOptional := options[\"optional\"]; fieldsRequiredByDefault && !isOptional {\n\t\treturn false, Error{t.Name, fmt.Errorf(\"Missing required field\"), false, \"required\", []string{}}\n\t}\n\t// not required and empty is valid\n\treturn true, nil\n}\n\nfunc typeCheck(v reflect.Value, t reflect.StructField, o reflect.Value, options tagOptionsMap) (isValid bool, resultErr error) {\n\tif !v.IsValid() {\n\t\treturn false, nil\n\t}\n\n\ttag := t.Tag.Get(tagName)\n\n\t// checks if the field should be ignored\n\tswitch tag {\n\tcase \"\":\n\t\tif v.Kind() != reflect.Slice && v.Kind() != reflect.Map {\n\t\t\tif !fieldsRequiredByDefault {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\treturn false, Error{t.Name, fmt.Errorf(\"All fields are required to at least have one validation defined\"), false, \"required\", []string{}}\n\t\t}\n\tcase \"-\":\n\t\treturn true, nil\n\t}\n\n\tisRootType := false\n\tif options == nil {\n\t\tisRootType = true\n\t\toptions = parseTagIntoMap(tag)\n\t}\n\n\tif isEmptyValue(v) {\n\t\t// an empty value is not validated, checks only required\n\t\tisValid, resultErr = checkRequired(v, t, options)\n\t\tfor key := range options {\n\t\t\tdelete(options, key)\n\t\t}\n\t\treturn isValid, resultErr\n\t}\n\n\tvar customTypeErrors Errors\n\toptionsOrder := options.orderedKeys()\n\tfor _, validatorName := range optionsOrder {\n\t\tvalidatorStruct := options[validatorName]\n\t\tif validatefunc, ok := CustomTypeTagMap.Get(validatorName); ok {\n\t\t\tdelete(options, validatorName)\n\n\t\t\tif result := validatefunc(v.Interface(), o.Interface()); !result {\n\t\t\t\tif len(validatorStruct.customErrorMessage) > 0 {\n\t\t\t\t\tcustomTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: TruncatingErrorf(validatorStruct.customErrorMessage, fmt.Sprint(v), validatorName), CustomErrorMessageExists: true, Validator: stripParams(validatorName)})\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcustomTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: fmt.Errorf(\"%s does not validate as %s\", fmt.Sprint(v), validatorName), CustomErrorMessageExists: false, Validator: stripParams(validatorName)})\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(customTypeErrors.Errors()) > 0 {\n\t\treturn false, customTypeErrors\n\t}\n\n\tif isRootType {\n\t\t// Ensure that we've checked the value by all specified validators before report that the value is valid\n\t\tdefer func() {\n\t\t\tdelete(options, \"optional\")\n\t\t\tdelete(options, \"required\")\n\n\t\t\tif isValid && resultErr == nil && len(options) != 0 {\n\t\t\t\toptionsOrder := options.orderedKeys()\n\t\t\t\tfor _, validator := range optionsOrder {\n\t\t\t\t\tisValid = false\n\t\t\t\t\tresultErr = Error{t.Name, fmt.Errorf(\n\t\t\t\t\t\t\"The following validator is invalid or can't be applied to the field: %q\", validator), false, stripParams(validator), []string{}}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor _, validatorSpec := range optionsOrder {\n\t\tvalidatorStruct := options[validatorSpec]\n\t\tvar negate bool\n\t\tvalidator := validatorSpec\n\t\tcustomMsgExists := len(validatorStruct.customErrorMessage) > 0\n\n\t\t// checks whether the tag looks like '!something' or 'something'\n\t\tif validator[0] == '!' {\n\t\t\tvalidator = validator[1:]\n\t\t\tnegate = true\n\t\t}\n\n\t\t// checks for interface param validators\n\t\tfor key, value := range InterfaceParamTagRegexMap {\n\t\t\tps := value.FindStringSubmatch(validator)\n\t\t\tif len(ps) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvalidatefunc, ok := InterfaceParamTagMap[key]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdelete(options, validatorSpec)\n\n\t\t\tfield := fmt.Sprint(v)\n\t\t\tif result := validatefunc(v.Interface(), ps[1:]...); (!result && !negate) || (result && negate) {\n\t\t\t\tif customMsgExists {\n\t\t\t\t\treturn false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t}\n\t\t\t\tif negate {\n\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t}\n\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does not validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch v.Kind() {\n\tcase reflect.Bool,\n\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,\n\t\treflect.Float32, reflect.Float64,\n\t\treflect.String:\n\t\t// for each tag option checks the map of validator functions\n\t\tfor _, validatorSpec := range optionsOrder {\n\t\t\tvalidatorStruct := options[validatorSpec]\n\t\t\tvar negate bool\n\t\t\tvalidator := validatorSpec\n\t\t\tcustomMsgExists := len(validatorStruct.customErrorMessage) > 0\n\n\t\t\t// checks whether the tag looks like '!something' or 'something'\n\t\t\tif validator[0] == '!' {\n\t\t\t\tvalidator = validator[1:]\n\t\t\t\tnegate = true\n\t\t\t}\n\n\t\t\t// checks for param validators\n\t\t\tfor key, value := range ParamTagRegexMap {\n\t\t\t\tps := value.FindStringSubmatch(validator)\n\t\t\t\tif len(ps) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvalidatefunc, ok := ParamTagMap[key]\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tdelete(options, validatorSpec)\n\n\t\t\t\tswitch v.Kind() {\n\t\t\t\tcase reflect.String,\n\t\t\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\t\treflect.Float32, reflect.Float64:\n\n\t\t\t\t\tfield := fmt.Sprint(v) // make value into string, then validate with regex\n\t\t\t\t\tif result := validatefunc(field, ps[1:]...); (!result && !negate) || (result && negate) {\n\t\t\t\t\t\tif customMsgExists {\n\t\t\t\t\t\t\treturn false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif negate {\n\t\t\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does not validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t// type not yet supported, fail\n\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"Validator %s doesn't support kind %s\", validator, v.Kind()), false, stripParams(validatorSpec), []string{}}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif validatefunc, ok := TagMap[validator]; ok {\n\t\t\t\tdelete(options, validatorSpec)\n\n\t\t\t\tswitch v.Kind() {\n\t\t\t\tcase reflect.String,\n\t\t\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\t\treflect.Float32, reflect.Float64:\n\t\t\t\t\tfield := fmt.Sprint(v) // make value into string, then validate with regex\n\t\t\t\t\tif result := validatefunc(field); !result && !negate || result && negate {\n\t\t\t\t\t\tif customMsgExists {\n\t\t\t\t\t\t\treturn false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif negate {\n\t\t\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false, Error{t.Name, fmt.Errorf(\"%s does not validate as %s\", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t//Not Yet Supported Types (Fail here!)\n\t\t\t\t\terr := fmt.Errorf(\"Validator %s doesn't support kind %s for value %v\", validator, v.Kind(), v)\n\t\t\t\t\treturn false, Error{t.Name, err, false, stripParams(validatorSpec), []string{}}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true, nil\n\tcase reflect.Map:\n\t\tif v.Type().Key().Kind() != reflect.String {\n\t\t\treturn false, &UnsupportedTypeError{v.Type()}\n\t\t}\n\t\tvar sv stringValues\n\t\tsv = v.MapKeys()\n\t\tsort.Sort(sv)\n\t\tresult := true\n\t\tfor i, k := range sv {\n\t\t\tvar resultItem bool\n\t\t\tvar err error\n\t\t\tif v.MapIndex(k).Kind() != reflect.Struct {\n\t\t\t\tresultItem, err = typeCheck(v.MapIndex(k), t, o, options)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresultItem, err = ValidateStruct(v.MapIndex(k).Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = prependPathToErrors(err, t.Name+\".\"+sv[i].Interface().(string))\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = result && resultItem\n\t\t}\n\t\treturn result, nil\n\tcase reflect.Slice, reflect.Array:\n\t\tresult := true\n\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\tvar resultItem bool\n\t\t\tvar err error\n\t\t\tif v.Index(i).Kind() != reflect.Struct {\n\t\t\t\tresultItem, err = typeCheck(v.Index(i), t, o, options)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresultItem, err = ValidateStruct(v.Index(i).Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = prependPathToErrors(err, t.Name+\".\"+strconv.Itoa(i))\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = result && resultItem\n\t\t}\n\t\treturn result, nil\n\tcase reflect.Interface:\n\t\t// If the value is an interface then encode its element\n\t\tif v.IsNil() {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn ValidateStruct(v.Interface())\n\tcase reflect.Ptr:\n\t\t// If the value is a pointer then checks its element\n\t\tif v.IsNil() {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn typeCheck(v.Elem(), t, o, options)\n\tcase reflect.Struct:\n\t\treturn true, nil\n\tdefault:\n\t\treturn false, &UnsupportedTypeError{v.Type()}\n\t}\n}\n\nfunc stripParams(validatorString string) string {\n\treturn paramsRegexp.ReplaceAllString(validatorString, \"\")\n}\n\n// isEmptyValue checks whether value empty or not\nfunc isEmptyValue(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.String, reflect.Array:\n\t\treturn v.Len() == 0\n\tcase reflect.Map, reflect.Slice:\n\t\treturn v.Len() == 0 || v.IsNil()\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Ptr:\n\t\treturn v.IsNil()\n\t}\n\n\treturn reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface())\n}\n\n// ErrorByField returns error for specified field of the struct\n// validated by ValidateStruct or empty string if there are no errors\n// or this field doesn't exists or doesn't have any errors.\nfunc ErrorByField(e error, field string) string {\n\tif e == nil {\n\t\treturn \"\"\n\t}\n\treturn ErrorsByField(e)[field]\n}\n\n// ErrorsByField returns map of errors of the struct validated\n// by ValidateStruct or empty map if there are no errors.\nfunc ErrorsByField(e error) map[string]string {\n\tm := make(map[string]string)\n\tif e == nil {\n\t\treturn m\n\t}\n\t// prototype for ValidateStruct\n\n\tswitch e := e.(type) {\n\tcase Error:\n\t\tm[e.Name] = e.Err.Error()\n\tcase Errors:\n\t\tfor _, item := range e.Errors() {\n\t\t\tn := ErrorsByField(item)\n\t\t\tfor k, v := range n {\n\t\t\t\tm[k] = v\n\t\t\t}\n\t\t}\n\t}\n\n\treturn m\n}\n\n// Error returns string equivalent for reflect.Type\nfunc (e *UnsupportedTypeError) Error() string {\n\treturn \"validator: unsupported type: \" + e.Type.String()\n}\n\nfunc (sv stringValues) Len() int           { return len(sv) }\nfunc (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }\nfunc (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }\nfunc (sv stringValues) get(i int) string   { return sv[i].String() }\n\nfunc IsE164(str string) bool {\n\treturn rxE164.MatchString(str)\n}\n"
        },
        {
          "name": "validator_test.go",
          "type": "blob",
          "size": 99.9150390625,
          "content": "package govalidator\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc init() {\n\tCustomTypeTagMap.Set(\"customFalseValidator\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\treturn false\n\t}))\n\tCustomTypeTagMap.Set(\"customTrueValidator\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\treturn true\n\t}))\n}\n\nfunc TestIsAlpha(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", false},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", false},\n\t\t{\"abc〩\", false},\n\t\t{\"abc\", true},\n\t\t{\"소주\", false},\n\t\t{\"ABC\", true},\n\t\t{\"FoObAr\", true},\n\t\t{\"소aBC\", false},\n\t\t{\"소\", false},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", true},  //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", false}, //UTF-8(ASCII): 0\n\t\t{\"123\", false},\n\t\t{\"0123\", false},\n\t\t{\"-00123\", false},\n\t\t{\"0\", false},\n\t\t{\"-0\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", false},\n\t\t{\"〥〩\", false},\n\t\t{\"모자\", false},\n\t\t{\"ix\", true},\n\t\t{\"۳۵۶۰\", false},\n\t\t{\"1--\", false},\n\t\t{\"1-1\", false},\n\t\t{\"-\", false},\n\t\t{\"--\", false},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsAlpha(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsAlpha(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUTFLetter(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", false},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", false},\n\t\t{\"abc〩\", false},\n\t\t{\"\", true},\n\t\t{\"abc\", true},\n\t\t{\"소주\", true},\n\t\t{\"ABC\", true},\n\t\t{\"FoObAr\", true},\n\t\t{\"소aBC\", true},\n\t\t{\"소\", true},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", true},  //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", false}, //UTF-8(ASCII): 0\n\t\t{\"123\", false},\n\t\t{\"0123\", false},\n\t\t{\"-00123\", false},\n\t\t{\"0\", false},\n\t\t{\"-0\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", false},\n\t\t{\"〥〩\", false},\n\t\t{\"모자\", true},\n\t\t{\"ix\", true},\n\t\t{\"۳۵۶۰\", false},\n\t\t{\"1--\", false},\n\t\t{\"1-1\", false},\n\t\t{\"-\", false},\n\t\t{\"--\", false},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUTFLetter(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUTFLetter(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsAlphanumeric(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", false},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc123\", true},\n\t\t{\"ABC111\", true},\n\t\t{\"abc1\", true},\n\t\t{\"abc〩\", false},\n\t\t{\"abc\", true},\n\t\t{\"소주\", false},\n\t\t{\"ABC\", true},\n\t\t{\"FoObAr\", true},\n\t\t{\"소aBC\", false},\n\t\t{\"소\", false},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", true},  //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", true},  //UTF-8(ASCII): 0\n\t\t{\"123\", true},\n\t\t{\"0123\", true},\n\t\t{\"-00123\", false},\n\t\t{\"0\", true},\n\t\t{\"-0\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", false},\n\t\t{\"〥〩\", false},\n\t\t{\"모자\", false},\n\t\t{\"ix\", true},\n\t\t{\"۳۵۶۰\", false},\n\t\t{\"1--\", false},\n\t\t{\"1-1\", false},\n\t\t{\"-\", false},\n\t\t{\"--\", false},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsAlphanumeric(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsAlphanumeric(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUTFLetterNumeric(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", true},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", true},\n\t\t{\"abc〩\", true},\n\t\t{\"abc\", true},\n\t\t{\"소주\", true},\n\t\t{\"ABC\", true},\n\t\t{\"FoObAr\", true},\n\t\t{\"소aBC\", true},\n\t\t{\"소\", true},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", true},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", true},  //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", true},  //UTF-8(ASCII): 0\n\t\t{\"123\", true},\n\t\t{\"0123\", true},\n\t\t{\"-00123\", false},\n\t\t{\"0\", true},\n\t\t{\"-0\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", true},\n\t\t{\"〥〩\", true},\n\t\t{\"모자\", true},\n\t\t{\"ix\", true},\n\t\t{\"۳۵۶۰\", true},\n\t\t{\"1--\", false},\n\t\t{\"1-1\", false},\n\t\t{\"-\", false},\n\t\t{\"--\", false},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUTFLetterNumeric(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUTFLetterNumeric(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNumeric(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", false},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", false},\n\t\t{\"abc〩\", false},\n\t\t{\"abc\", false},\n\t\t{\"소주\", false},\n\t\t{\"ABC\", false},\n\t\t{\"FoObAr\", false},\n\t\t{\"소aBC\", false},\n\t\t{\"소\", false},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", false}, //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", true},  //UTF-8(ASCII): 0\n\t\t{\"123\", true},\n\t\t{\"0123\", true},\n\t\t{\"-00123\", false},\n\t\t{\"+00123\", false},\n\t\t{\"0\", true},\n\t\t{\"-0\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"12𐅪3\", false},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", false},\n\t\t{\"〥〩\", false},\n\t\t{\"모자\", false},\n\t\t{\"ix\", false},\n\t\t{\"۳۵۶۰\", false},\n\t\t{\"1--\", false},\n\t\t{\"1-1\", false},\n\t\t{\"-\", false},\n\t\t{\"--\", false},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNumeric(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNumeric(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUTFNumeric(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", true},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", false},\n\t\t{\"abc〩\", false},\n\t\t{\"abc\", false},\n\t\t{\"소주\", false},\n\t\t{\"ABC\", false},\n\t\t{\"FoObAr\", false},\n\t\t{\"소aBC\", false},\n\t\t{\"소\", false},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", false}, //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", true},  //UTF-8(ASCII): 0\n\t\t{\"123\", true},\n\t\t{\"0123\", true},\n\t\t{\"-00123\", true},\n\t\t{\"0\", true},\n\t\t{\"-0\", true},\n\t\t{\"--0\", false},\n\t\t{\"-0-\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"12𐅪3\", true},\n\t\t{\"-1¾\", true},\n\t\t{\"1¾\", true},\n\t\t{\"〥〩\", true},\n\t\t{\"모자\", false},\n\t\t{\"ix\", false},\n\t\t{\"۳۵۶۰\", true},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUTFNumeric(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUTFNumeric(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUTFDigit(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\n\t\t{\"\\n\", false},\n\t\t{\"\\r\", false},\n\t\t{\"Ⅸ\", false},\n\t\t{\"\", true},\n\t\t{\"   fooo   \", false},\n\t\t{\"abc!!!\", false},\n\t\t{\"abc1\", false},\n\t\t{\"abc〩\", false},\n\t\t{\"abc\", false},\n\t\t{\"소주\", false},\n\t\t{\"ABC\", false},\n\t\t{\"FoObAr\", false},\n\t\t{\"소aBC\", false},\n\t\t{\"소\", false},\n\t\t{\"달기&Co.\", false},\n\t\t{\"〩Hours\", false},\n\t\t{\"\\ufff0\", false},\n\t\t{\"\\u0070\", false}, //UTF-8(ASCII): p\n\t\t{\"\\u0026\", false}, //UTF-8(ASCII): &\n\t\t{\"\\u0030\", true},  //UTF-8(ASCII): 0\n\t\t{\"123\", true},\n\t\t{\"0123\", true},\n\t\t{\"-00123\", true},\n\t\t{\"0\", true},\n\t\t{\"-0\", true},\n\t\t{\"--0\", false},\n\t\t{\"-0-\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\".\", false},\n\t\t{\"12𐅪3\", false},\n\t\t{\"1483920\", true},\n\t\t{\"\", true},\n\t\t{\"۳۵۶۰\", true},\n\t\t{\"-29\", true},\n\t\t{\"-1¾\", false},\n\t\t{\"1¾\", false},\n\t\t{\"〥〩\", false},\n\t\t{\"모자\", false},\n\t\t{\"ix\", false},\n\t\t{\"۳۵۶۰\", true},\n\t\t{\"1++\", false},\n\t\t{\"1+1\", false},\n\t\t{\"+\", false},\n\t\t{\"++\", false},\n\t\t{\"+1\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUTFDigit(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUTFDigit(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsLowerCase(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc123\", true},\n\t\t{\"abc\", true},\n\t\t{\"a b c\", true},\n\t\t{\"abcß\", true},\n\t\t{\"abcẞ\", false},\n\t\t{\"ABCẞ\", false},\n\t\t{\"tr竪s 端ber\", true},\n\t\t{\"fooBar\", false},\n\t\t{\"123ABC\", false},\n\t\t{\"ABC123\", false},\n\t\t{\"ABC\", false},\n\t\t{\"S T R\", false},\n\t\t{\"fooBar\", false},\n\t\t{\"abacaba123\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsLowerCase(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsLowerCase(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUpperCase(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc123\", false},\n\t\t{\"abc\", false},\n\t\t{\"a b c\", false},\n\t\t{\"abcß\", false},\n\t\t{\"abcẞ\", false},\n\t\t{\"ABCẞ\", true},\n\t\t{\"tr竪s 端ber\", false},\n\t\t{\"fooBar\", false},\n\t\t{\"123ABC\", true},\n\t\t{\"ABC123\", true},\n\t\t{\"ABC\", true},\n\t\t{\"S T R\", true},\n\t\t{\"fooBar\", false},\n\t\t{\"abacaba123\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUpperCase(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUpperCase(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestHasLowerCase(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc123\", true},\n\t\t{\"abc\", true},\n\t\t{\"a b c\", true},\n\t\t{\"abcß\", true},\n\t\t{\"abcẞ\", true},\n\t\t{\"ABCẞ\", false},\n\t\t{\"tr竪s 端ber\", true},\n\t\t{\"fooBar\", true},\n\t\t{\"123ABC\", false},\n\t\t{\"ABC123\", false},\n\t\t{\"ABC\", false},\n\t\t{\"S T R\", false},\n\t\t{\"fooBar\", true},\n\t\t{\"abacaba123\", true},\n\t\t{\"FÒÔBÀŘ\", false},\n\t\t{\"fòôbàř\", true},\n\t\t{\"fÒÔBÀŘ\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := HasLowerCase(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected HasLowerCase(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestHasUpperCase(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc123\", false},\n\t\t{\"abc\", false},\n\t\t{\"a b c\", false},\n\t\t{\"abcß\", false},\n\t\t{\"abcẞ\", false},\n\t\t{\"ABCẞ\", true},\n\t\t{\"tr竪s 端ber\", false},\n\t\t{\"fooBar\", true},\n\t\t{\"123ABC\", true},\n\t\t{\"ABC123\", true},\n\t\t{\"ABC\", true},\n\t\t{\"S T R\", true},\n\t\t{\"fooBar\", true},\n\t\t{\"abacaba123\", false},\n\t\t{\"FÒÔBÀŘ\", true},\n\t\t{\"fòôbàř\", false},\n\t\t{\"Fòôbàř\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := HasUpperCase(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected HasUpperCase(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsInt(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"-2147483648\", true},          //Signed 32 Bit Min Int\n\t\t{\"2147483647\", true},           //Signed 32 Bit Max Int\n\t\t{\"-2147483649\", true},          //Signed 32 Bit Min Int - 1\n\t\t{\"2147483648\", true},           //Signed 32 Bit Max Int + 1\n\t\t{\"4294967295\", true},           //Unsigned 32 Bit Max Int\n\t\t{\"4294967296\", true},           //Unsigned 32 Bit Max Int + 1\n\t\t{\"-9223372036854775808\", true}, //Signed 64 Bit Min Int\n\t\t{\"9223372036854775807\", true},  //Signed 64 Bit Max Int\n\t\t{\"-9223372036854775809\", true}, //Signed 64 Bit Min Int - 1\n\t\t{\"9223372036854775808\", true},  //Signed 64 Bit Max Int + 1\n\t\t{\"18446744073709551615\", true}, //Unsigned 64 Bit Max Int\n\t\t{\"18446744073709551616\", true}, //Unsigned 64 Bit Max Int + 1\n\t\t{\"\", true},\n\t\t{\"123\", true},\n\t\t{\"0\", true},\n\t\t{\"-0\", true},\n\t\t{\"+0\", true},\n\t\t{\"01\", false},\n\t\t{\"123.123\", false},\n\t\t{\" \", false},\n\t\t{\"000\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsInt(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsInt(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsHash(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\talgo     string\n\t\texpected bool\n\t}{\n\t\t{\"3ca25ae354e192b26879f651a51d92aa8a34d8d3\", \"sha1\", true},\n\t\t{\"3ca25ae354e192b26879f651a51d34d8d3\", \"sha1\", false},\n\t\t{\"3ca25ae354e192b26879f651a51d92aa8a34d8d3\", \"Tiger160\", true},\n\t\t{\"3ca25ae354e192b26879f651a51d34d8d3\", \"ripemd160\", false},\n\t\t{\"579282cfb65ca1f109b78536effaf621b853c9f7079664a3fbe2b519f435898c\", \"sha256\", true},\n\t\t{\"579282cfb65ca1f109b78536effaf621b853c9f7079664a3fbe2b519f435898casfdsafsadfsdf\", \"sha256\", false},\n\t\t{\"bf547c3fc5841a377eb1519c2890344dbab15c40ae4150b4b34443d2212e5b04aa9d58865bf03d8ae27840fef430b891\", \"sha384\", true},\n\t\t{\"579282cfb65ca1f109b78536effaf621b853c9f7079664a3fbe2b519f435898casfdsafsadfsdf\", \"sha384\", false},\n\t\t{\"45bc5fa8cb45ee408c04b6269e9f1e1c17090c5ce26ffeeda2af097735b29953ce547e40ff3ad0d120e5361cc5f9cee35ea91ecd4077f3f589b4d439168f91b9\", \"sha512\", true},\n\t\t{\"579282cfb65ca1f109b78536effaf621b853c9f7079664a3fbe2b519f435898casfdsafsadfsdf\", \"sha512\", false},\n\t\t{\"46fc0125a148788a3ac1d649566fc04eb84a746f1a6e4fa7\", \"tiger192\", true},\n\t\t{\"46fc0125a148788a3ac1d649566fc04eb84a746f1a6$$%@^\", \"TIGER192\", false},\n\t\t{\"46fc0125a148788a3ac1d649566fc04eb84a746f1a6$$%@^\", \"SOMEHASH\", false},\n\t\t{\"b87f88c72702fff1748e58b87e9141a42c0dbedc29a78cb0d4a5cd81\", \"sha3-224\", true},\n\t\t{\"b87f88c72702fff1748e58b87e9141a42c0dbedc29a78cb0d4a5cd81g\", \"sha3-224\", false},\n\t\t{\"3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392\", \"sha3-256\", true},\n\t\t{\"3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392g\", \"sha3-256\", false},\n\t\t{\"720aea11019ef06440fbf05d87aa24680a2153df3907b23631e7177ce620fa1330ff07c0fddee54699a4c3ee0ee9d887\", \"sha3-384\", true},\n\t\t{\"720aea11019ef06440fbf05d87aa24680a2153df3907b23631e7177ce620fa1330ff07c0fddee54699a4c3ee0ee9d88\", \"sha3-384\", false},\n\t\t{\"75d527c368f2efe848ecf6b073a36767800805e9eef2b1857d5f984f036eb6df891d75f72d9b154518c1cd58835286d1da9a38deba3de98b5a53e5ed78a84976\", \"sha3-512\", true},\n\t\t{\"75d527c368f2efe848ecf6b073a36767800805e9eef2b1857d5f984f036eb6df891d75f72d9b154518c1cd58835286d1da9a38deba3de98b5a53e5ed78a8497\", \"sha3-512\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsHash(test.param, test.algo)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsHash(%q, %q) to be %v, got %v\", test.param, test.algo, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSHA3224(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"b87f88c72702fff1748e58b87e9141a42c0dbedc29a78cb0d4a5cd81\", true},\n\t\t{\"b87f88c72702fff1748e58b87e9141a42c0dbedc29a78cb0d4a5cd81g\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSHA3224(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSHA3224(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSHA3256(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392\", true},\n\t\t{\"3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f39\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSHA3256(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSHA3256(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSHA3384(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"720aea11019ef06440fbf05d87aa24680a2153df3907b23631e7177ce620fa1330ff07c0fddee54699a4c3ee0ee9d887\", true},\n\t\t{\"720aea11019ef06440fbf05d87aa24680a2153df3907b23631e7177ce620fa1330ff07c0fddee54699a4c3ee0ee9d88\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSHA3384(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSHA3384(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSHA3512(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"75d527c368f2efe848ecf6b073a36767800805e9eef2b1857d5f984f036eb6df891d75f72d9b154518c1cd58835286d1da9a38deba3de98b5a53e5ed78a84976\", true},\n\t\t{\"75d527c368f2efe848ecf6b073a36767800805e9eef2b1857d5f984f036eb6df891d75f72d9b154518c1cd58835286d1da9a38deba3de98b5a53e5ed78a8497\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSHA3512(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSHA3512(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsExistingEmail(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo@bar.com\", true},\n\t\t{\"foo@bar.com.au\", true},\n\t\t{\"foo+bar@bar.com\", true},\n\t\t{\"foo@bar.coffee..coffee\", false},\n\t\t{\"invalidemail@\", false},\n\t\t{\"invalid.com\", false},\n\t\t{\"@invalid.com\", false},\n\t\t{\"NathAn.daVIeS@DomaIn.cOM\", true},\n\t\t{\"NATHAN.DAVIES@DOMAIN.CO.UK\", true},\n\t\t{\"prasun.joshi@localhost\", true},\n\t\t{\"[prasun.joshi]@DomaIn.cOM\", false},\n\t\t{\"sizeofuserismorethansixtyfour0123sizeofuserismorethansixtyfour0123@DOMAIN.CO.UK\", false},\n\t\t{\"nosuchdomain@bar.nosuchdomainsuffix\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsExistingEmail(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsExistingEmail(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsEmail(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo@bar.com\", true},\n\t\t{\"x@x.x\", true},\n\t\t{\"foo@bar.com.au\", true},\n\t\t{\"foo+bar@bar.com\", true},\n\t\t{\"foo@bar.coffee\", true},\n\t\t{\"foo@bar.coffee..coffee\", false},\n\t\t{\"foo@bar.bar.coffee\", true},\n\t\t{\"foo@bar.中文网\", true},\n\t\t{\"invalidemail@\", false},\n\t\t{\"invalid.com\", false},\n\t\t{\"@invalid.com\", false},\n\t\t{\"test|123@m端ller.com\", true},\n\t\t{\"hans@m端ller.com\", true},\n\t\t{\"hans.m端ller@test.com\", true},\n\t\t{\"NathAn.daVIeS@DomaIn.cOM\", true},\n\t\t{\"NATHAN.DAVIES@DOMAIN.CO.UK\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsEmail(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsEmail(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsURL(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"http://foo.bar#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", true},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.ORG\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", true},\n\t\t{\"ftp.foo.bar\", true},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://user:pass@www.foobar.com/path/file\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"http://foobar.com/a-\", true},\n\t\t{\"http://foobar.پاکستان/\", true},\n\t\t{\"http://foobar.c_o_m\", false},\n\t\t{\"http://_foobar.com\", false},\n\t\t{\"http://foo_bar.com\", true},\n\t\t{\"http://user:pass@foo_bar_bar.bar_foo.com\", true},\n\t\t{\"\", false},\n\t\t{\"xyz://foobar.com\", false},\n\t\t// {\"invalid.\", false}, is it false like \"localhost.\"?\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", false},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", false},\n\t\t{\"http://www.foo---bar.com/\", false},\n\t\t{\"http://r6---snnvoxuioq6.googlevideo.com\", true},\n\t\t{\"mailto:someone@example.com\", true},\n\t\t{\"irc://irc.server.org/channel\", false},\n\t\t{\"irc://#channel@network\", true},\n\t\t{\"/abs/test/dir\", false},\n\t\t{\"./rel/test/dir\", false},\n\t\t{\"http://foo^bar.org\", false},\n\t\t{\"http://foo&*bar.org\", false},\n\t\t{\"http://foo&bar.org\", false},\n\t\t{\"http://foo bar.org\", false},\n\t\t{\"http://foo.bar.org\", true},\n\t\t{\"http://www.foo.bar.org\", true},\n\t\t{\"http://www.foo.co.uk\", true},\n\t\t{\"foo\", false},\n\t\t{\"http://.foo.com\", false},\n\t\t{\"http://,foo.com\", false},\n\t\t{\",foo.com\", false},\n\t\t{\"http://myservice.:9093/\", true},\n\t\t// according to issues #62 #66\n\t\t{\"https://pbs.twimg.com/profile_images/560826135676588032/j8fWrmYY_normal.jpeg\", true},\n\t\t// according to #125\n\t\t{\"http://prometheus-alertmanager.service.q:9093\", true},\n\t\t{\"aio1_alertmanager_container-63376c45:9093\", true},\n\t\t{\"https://www.logn-123-123.url.with.sigle.letter.d:12345/url/path/foo?bar=zzz#user\", true},\n\t\t{\"http://me.example.com\", true},\n\t\t{\"http://www.me.example.com\", true},\n\t\t{\"https://farm6.static.flickr.com\", true},\n\t\t{\"https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5\", true},\n\t\t{\"google\", false},\n\t\t// According to #87\n\t\t{\"http://hyphenated-host-name.example.co.in\", true},\n\t\t{\"http://cant-end-with-hyphen-.example.com\", false},\n\t\t{\"http://-cant-start-with-hyphen.example.com\", false},\n\t\t{\"http://www.domain-can-have-dashes.com\", true},\n\t\t{\"http://m.abcd.com/test.html\", true},\n\t\t{\"http://m.abcd.com/a/b/c/d/test.html?args=a&b=c\", true},\n\t\t{\"http://[::1]:9093\", true},\n\t\t{\"http://[::1]:909388\", false},\n\t\t{\"1200::AB00:1234::2552:7777:1313\", false},\n\t\t{\"http://[2001:db8:a0b:12f0::1]/index.html\", true},\n\t\t{\"http://[1200:0000:AB00:1234:0000:2552:7777:1313]\", true},\n\t\t{\"http://user:pass@[::1]:9093/a/b/c/?a=v#abc\", true},\n\t\t{\"https://127.0.0.1/a/b/c?a=v&c=11d\", true},\n\t\t{\"https://foo_bar.example.com\", true},\n\t\t{\"http://foo_bar.example.com\", true},\n\t\t{\"http://foo_bar_fizz_buzz.example.com\", true},\n\t\t{\"http://_cant_start_with_underescore\", false},\n\t\t{\"http://cant_end_with_underescore_\", false},\n\t\t{\"foo_bar.example.com\", true},\n\t\t{\"foo_bar_fizz_buzz.example.com\", true},\n\t\t{\"http://hello_world.example.com\", true},\n\t\t// According to #212\n\t\t{\"foo_bar-fizz-buzz:1313\", true},\n\t\t{\"foo_bar-fizz-buzz:13:13\", false},\n\t\t{\"foo_bar-fizz-buzz://1313\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsURL(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsURL(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestURL(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"http://foo.bar/#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", false},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", true},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"\", false},\n\t\t{\"xyz://foobar.com\", true},\n\t\t{\"invalid.\", false},\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", true},\n\t\t{\"http://www.foo_bar.com/\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", true},\n\t\t{\"http://www.foo---bar.com/\", true},\n\t\t{\"mailto:someone@example.com\", true},\n\t\t{\"irc://irc.server.org/channel\", true},\n\t\t{\"/abs/test/dir\", false},\n\t\t{\"./rel/test/dir\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsRequestURL(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsRequestURL(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestURI(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"http://foo.bar/#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", false},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", true},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"xyz://foobar.com\", true},\n\t\t{\"invalid.\", false},\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", true},\n\t\t{\"http://www.foo_bar.com/\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", true},\n\t\t{\"http://www.foo---bar.com/\", true},\n\t\t{\"mailto:someone@example.com\", true},\n\t\t{\"irc://irc.server.org/channel\", true},\n\t\t{\"/abs/test/dir\", true},\n\t\t{\"./rel/test/dir\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsRequestURI(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsRequestURI(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsFloat(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"  \", false},\n\t\t{\"-.123\", false},\n\t\t{\"abacaba\", false},\n\t\t{\"1f\", false},\n\t\t{\"-1f\", false},\n\t\t{\"+1f\", false},\n\t\t{\"123\", true},\n\t\t{\"123.\", true},\n\t\t{\"123.123\", true},\n\t\t{\"-123.123\", true},\n\t\t{\"+123.123\", true},\n\t\t{\"0.123\", true},\n\t\t{\"-0.123\", true},\n\t\t{\"+0.123\", true},\n\t\t{\".0\", true},\n\t\t{\"01.123\", true},\n\t\t{\"-0.22250738585072011e-307\", true},\n\t\t{\"+0.22250738585072011e-307\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsFloat(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsFloat(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsHexadecimal(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abcdefg\", false},\n\t\t{\"\", false},\n\t\t{\"..\", false},\n\t\t{\"deadBEEF\", true},\n\t\t{\"ff0044\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsHexadecimal(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsHexadecimal(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsHexcolor(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"#ff\", false},\n\t\t{\"fff0\", false},\n\t\t{\"#ff12FG\", false},\n\t\t{\"CCccCC\", true},\n\t\t{\"fff\", true},\n\t\t{\"#f00\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsHexcolor(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsHexcolor(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsRGBcolor(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"rgb(0,31,255)\", true},\n\t\t{\"rgb(1,349,275)\", false},\n\t\t{\"rgb(01,31,255)\", false},\n\t\t{\"rgb(0.6,31,255)\", false},\n\t\t{\"rgba(0,31,255)\", false},\n\t\t{\"rgb(0,  31, 255)\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsRGBcolor(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsRGBcolor(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNull(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abacaba\", false},\n\t\t{\"\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNull(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNull(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsNotNull(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abacaba\", true},\n\t\t{\"\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsNotNull(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNull(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsIMEI(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"990000862471854\", true},\n\t\t{\"351756051523999\", true},\n\t\t{\"9900008624718541\", false},\n\t\t{\"1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIMEI(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIMEI(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestHasWhitespaceOnly(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abacaba\", false},\n\t\t{\"\", false},\n\t\t{\"    \", true},\n\t\t{\"  \\r\\n  \", true},\n\t\t{\"\\014\\012\\011\\013\\015\", true},\n\t\t{\"\\014\\012\\011\\013 abc  \\015\", false},\n\t\t{\"\\f\\n\\t\\v\\r\\f\", true},\n\t\t{\"x\\n\\t\\t\\t\\t\", false},\n\t\t{\"\\f\\n\\t  \\n\\n\\n   \\v\\r\\f\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := HasWhitespaceOnly(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected HasWhitespaceOnly(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestHasWhitespace(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abacaba\", false},\n\t\t{\"\", false},\n\t\t{\"    \", true},\n\t\t{\"  \\r\\n  \", true},\n\t\t{\"\\014\\012\\011\\013\\015\", true},\n\t\t{\"\\014\\012\\011\\013 abc  \\015\", true},\n\t\t{\"\\f\\n\\t\\v\\r\\f\", true},\n\t\t{\"x\\n\\t\\t\\t\\t\", true},\n\t\t{\"\\f\\n\\t  \\n\\n\\n   \\v\\r\\f\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := HasWhitespace(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected HasWhitespace(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsDivisibleBy(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   string\n\t\texpected bool\n\t}{\n\t\t{\"4\", \"2\", true},\n\t\t{\"100\", \"10\", true},\n\t\t{\"\", \"1\", true},\n\t\t{\"123\", \"foo\", false},\n\t\t{\"123\", \"0\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsDivisibleBy(test.param1, test.param2)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsDivisibleBy(%q, %q) to be %v, got %v\", test.param1, test.param2, test.expected, actual)\n\t\t}\n\t}\n}\n\n// This small example illustrate how to work with IsDivisibleBy function.\nfunc ExampleIsDivisibleBy() {\n\tprintln(\"1024 is divisible by 64: \", IsDivisibleBy(\"1024\", \"64\"))\n}\n\nfunc TestIsByteLength(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam1   string\n\t\tparam2   int\n\t\tparam3   int\n\t\texpected bool\n\t}{\n\t\t{\"abacaba\", 100, -1, false},\n\t\t{\"abacaba\", 1, 3, false},\n\t\t{\"abacaba\", 1, 7, true},\n\t\t{\"abacaba\", 0, 8, true},\n\t\t{\"\\ufff0\", 1, 1, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsByteLength(test.param1, test.param2, test.param3)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsByteLength(%q, %q, %q) to be %v, got %v\", test.param1, test.param2, test.param3, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsJSON(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"145\", true},\n\t\t{\"asdf\", false},\n\t\t{\"123:f00\", false},\n\t\t{\"{\\\"Name\\\":\\\"Alice\\\",\\\"Body\\\":\\\"Hello\\\",\\\"Time\\\":1294706395881547000}\", true},\n\t\t{\"{}\", true},\n\t\t{\"{\\\"Key\\\":{\\\"Key\\\":{\\\"Key\\\":123}}}\", true},\n\t\t{\"[]\", true},\n\t\t{\"null\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsJSON(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsJSON(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsMultibyte(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"abc\", false},\n\t\t{\"123\", false},\n\t\t{\"<>@;.-=\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", true},\n\t\t{\"あいうえお foobar\", true},\n\t\t{\"test＠example.com\", true},\n\t\t{\"test＠example.com\", true},\n\t\t{\"1234abcDEｘｙｚ\", true},\n\t\t{\"ｶﾀｶﾅ\", true},\n\t\t{\"\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsMultibyte(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsMultibyte(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsASCII(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"ｆｏｏbar\", false},\n\t\t{\"ｘｙｚ０９８\", false},\n\t\t{\"１２３456\", false},\n\t\t{\"ｶﾀｶﾅ\", false},\n\t\t{\"foobar\", true},\n\t\t{\"0987654321\", true},\n\t\t{\"test@example.com\", true},\n\t\t{\"1234abcDEF\", true},\n\t\t{\"\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsASCII(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsASCII(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsPrintableASCII(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"ｆｏｏbar\", false},\n\t\t{\"ｘｙｚ０９８\", false},\n\t\t{\"１２３456\", false},\n\t\t{\"ｶﾀｶﾅ\", false},\n\t\t{\"foobar\", true},\n\t\t{\"0987654321\", true},\n\t\t{\"test@example.com\", true},\n\t\t{\"1234abcDEF\", true},\n\t\t{\"newline\\n\", false},\n\t\t{\"\\x19test\\x7F\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsPrintableASCII(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsPrintableASCII(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsFullWidth(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc\", false},\n\t\t{\"abc123\", false},\n\t\t{\"!\\\"#$%&()<>/+=-_? ~^|.,@`{}[]\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", true},\n\t\t{\"３ー０　ａ＠ｃｏｍ\", true},\n\t\t{\"Ｆｶﾀｶﾅﾞﾬ\", true},\n\t\t{\"Good＝Parts\", true},\n\t\t{\"\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsFullWidth(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsFullWidth(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsHalfWidth(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"あいうえお\", false},\n\t\t{\"００１１\", false},\n\t\t{\"!\\\"#$%&()<>/+=-_? ~^|.,@`{}[]\", true},\n\t\t{\"l-btn_02--active\", true},\n\t\t{\"abc123い\", true},\n\t\t{\"ｶﾀｶﾅﾞﾬ￩\", true},\n\t\t{\"\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsHalfWidth(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsHalfWidth(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsVariableWidth(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"ひらがなカタカナ漢字ABCDE\", true},\n\t\t{\"３ー０123\", true},\n\t\t{\"Ｆｶﾀｶﾅﾞﾬ\", true},\n\t\t{\"\", true},\n\t\t{\"Good＝Parts\", true},\n\t\t{\"abc\", false},\n\t\t{\"abc123\", false},\n\t\t{\"!\\\"#$%&()<>/+=-_? ~^|.,@`{}[]\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", false},\n\t\t{\"１２３４５６\", false},\n\t\t{\"ｶﾀｶﾅﾞﾬ\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsVariableWidth(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsVariableWidth(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUUID(t *testing.T) {\n\tt.Parallel()\n\n\t// Tests without version\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3xxx\", false},\n\t\t{\"a987fbc94bed3078cf079141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"987fbc9-4bed-3078-cf07a-9141ba07c9f3\", false},\n\t\t{\"aaaaaaaa-1111-1111-aaag-111111111111\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUUID(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUUID(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// UUID ver. 3\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"412452646\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-4078-8f07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUUIDv3(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUUIDv3(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// UUID ver. 4\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-5078-af07-9141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"57b73598-8764-4ad0-a76a-679bb6640eb1\", true},\n\t\t{\"625e63f3-58f5-40b7-83a1-a72ad31acffb\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUUIDv4(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUUIDv4(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// UUID ver. 5\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"9c858901-8a57-4791-81fe-4c455b099bc9\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"987fbc97-4bed-5078-af07-9141ba07c9f3\", true},\n\t\t{\"987fbc97-4bed-5078-9f07-9141ba07c9f3\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUUIDv5(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUUIDv5(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsULID(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3xxx\", false},\n\t\t{\"a987fbc94bed3078cf079141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"987fbc9-4bed-3078-cf07a-9141ba07c9f3\", false},\n\t\t{\"aaaaaaaa-1111-1111-aaag-111111111111\", false},\n\t\t{\"0000000000zzzzzzzzzzzzzzzz\", true},\n\t\t{\"0123456789zzzzzzzzzzzzzzzz\", true},\n\t\t{\"0123456789abcdefghjkmnpqrs\", true},\n\t\t{\"7zzzzzzzzzaaaaaaaaaaaaaaaa\", true},\n\t\t{\"7zanmkqfpyaaaaaaaaaaaaaaaa\", true},\n\t\t{\"7zanmkqfpyaaaaaaaaaaAAAAAA\", true},\n\t\t{\"8000000000zzzzzzzzzzzzzzzz\", false},\n\t\t{\"8000000001zzzzzzzzzzzzzzzz\", false},\n\t\t{\"8123456789zzzzzzzzzzzzzzzz\", false},\n\t\t{\"8123456789zzzzzzzzzzzzzzzL\", false},\n\t\t{\"8123456789zzzzzzzzzzzzzzzO\", false},\n\t\t{\"8123456789zzzzzzzzzzzzzzzu\", false},\n\t\t{\"8123456789zzzzzzzzzzzzzzzI\", false},\n\t}\n\tfor _, test := range tests {\n\t\ttc := test\n\t\tt.Run(fmt.Sprintf(\"%26.26s\", tc.param), func(t *testing.T) {\n\t\t\tactual := IsULID(tc.param)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected IsULID(%q) to be %v, got %v\", tc.param, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsCreditCard(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname   string\n\t\tnumber string\n\t\twant   bool\n\t}{\n\t\t{\"empty\", \"\", false},\n\t\t{\"not numbers\", \"credit card\", false},\n\t\t{\"invalid luhn algorithm\", \"4220855426213389\", false},\n\n\t\t{\"visa\", \"4220855426222389\", true},\n\t\t{\"visa spaces\", \"4220 8554 2622 2389\", true},\n\t\t{\"visa dashes\", \"4220-8554-2622-2389\", true},\n\t\t{\"mastercard\", \"5139288802098206\", true},\n\t\t{\"american express\", \"374953669708156\", true},\n\t\t{\"discover\", \"6011464355444102\", true},\n\t\t{\"jcb\", \"3548209662790989\", true},\n\n\t\t// below should be valid, do they respect international standards?\n\t\t// is our validator logic not correct?\n\t\t{\"diners club international\", \"30190239451016\", false},\n\t\t{\"rupay\", \"6521674451993089\", false},\n\t\t{\"mir\", \"2204151414444676\", false},\n\t\t{\"china unionPay\", \"624356436327468104\", false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := IsCreditCard(tt.number); got != tt.want {\n\t\t\t\tt.Errorf(\"IsCreditCard(%v) = %v, want %v\", tt.number, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIsISBN(t *testing.T) {\n\tt.Parallel()\n\n\t// Without version\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3836221195\", true},\n\t\t{\"1-61729-085-8\", true},\n\t\t{\"3 423 21412 0\", true},\n\t\t{\"3 401 01319 X\", true},\n\t\t{\"9784873113685\", true},\n\t\t{\"978-4-87311-368-5\", true},\n\t\t{\"978 3401013190\", true},\n\t\t{\"978-3-8362-2119-1\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISBN(test.param, -1)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISBN(%q, -1) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// ISBN 10\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3423214121\", false},\n\t\t{\"978-3836221191\", false},\n\t\t{\"3-423-21412-1\", false},\n\t\t{\"3 423 21412 1\", false},\n\t\t{\"3836221195\", true},\n\t\t{\"1-61729-085-8\", true},\n\t\t{\"3 423 21412 0\", true},\n\t\t{\"3 401 01319 X\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISBN10(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISBN10(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// ISBN 13\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3-8362-2119-5\", false},\n\t\t{\"01234567890ab\", false},\n\t\t{\"978 3 8362 2119 0\", false},\n\t\t{\"9784873113685\", true},\n\t\t{\"978-4-87311-368-5\", true},\n\t\t{\"978 3401013190\", true},\n\t\t{\"978-3-8362-2119-1\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISBN13(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISBN13(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsDataURI(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"data:image/png;base64,TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdC4=\", true},\n\t\t{\"data:text/plain;base64,Vml2YW11cyBmZXJtZW50dW0gc2VtcGVyIHBvcnRhLg==\", true},\n\t\t{\"image/gif;base64,U3VzcGVuZGlzc2UgbGVjdHVzIGxlbw==\", false},\n\t\t{\"data:image/gif;base64,MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuMPNS1Ufof9EW/M98FNw\" +\n\t\t\t\"UAKrwflsqVxaxQjBQnHQmiI7Vac40t8x7pIb8gLGV6wL7sBTJiPovJ0V7y7oc0Ye\" +\n\t\t\t\"rhKh0Rm4skP2z/jHwwZICgGzBvA0rH8xlhUiTvcwDCJ0kc+fh35hNt8srZQM4619\" +\n\t\t\t\"FTgB66Xmp4EtVyhpQV+t02g6NzK72oZI0vnAvqhpkxLeLiMCyrI416wHm5Tkukhx\" +\n\t\t\t\"QmcL2a6hNOyu0ixX/x2kSFXApEnVrJ+/IxGyfyw8kf4N2IZpW5nEP847lpfj0SZZ\" +\n\t\t\t\"Fwrd1mnfnDbYohX2zRptLy2ZUn06Qo9pkG5ntvFEPo9bfZeULtjYzIl6K8gJ2uGZ\" + \"HQIDAQAB\", true},\n\t\t{\"data:image/png;base64,12345\", false},\n\t\t{\"\", false},\n\t\t{\"data:text,:;base85,U3VzcGVuZGlzc2UgbGVjdHVzIGxlbw==\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsDataURI(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsDataURI(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsMagnetURI(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"magnet:?xt=urn:btih:06E2A9683BF4DA92C73A661AC56F0ECC9C63C5B4&dn=helloword2000&tr=udp://helloworld:1337/announce\", true},\n\t\t{\"magnet:?xt=urn:btih:3E30322D5BFC7444B7B1D8DD42404B75D0531DFB&dn=world&tr=udp://world.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:4ODKSDJBVMSDSNJVBCBFYFBKNRU875DW8D97DWC6&dn=helloworld&tr=udp://helloworld.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:1GSHJVBDVDVJFYEHKFHEFIO8573898434JBFEGHD&dn=foo&tr=udp://foo.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:MCJDCYUFHEUD6E2752T7UJNEKHSUGEJFGTFHVBJS&dn=bar&tr=udp://bar.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:LAKDHWDHEBFRFVUFJENBYYTEUY837562JH2GEFYH&dn=foobar&tr=udp://foobar.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:MKCJBHCBJDCU725TGEB3Y6RE8EJ2U267UNJFGUID&dn=test&tr=udp://test.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:UHWY2892JNEJ2GTEYOMDNU67E8ICGICYE92JDUGH&dn=baz&tr=udp://baz.com:1337\", true},\n\t\t{\"magnet:?xt=urn:btih:HS263FG8U3GFIDHWD7829BYFCIXB78XIHG7CWCUG&dn=foz&tr=udp://foz.com:1337\", true},\n\t\t{\"\", false},\n\t\t{\":?xt=urn:btih:06E2A9683BF4DA92C73A661AC56F0ECC9C63C5B4&dn=helloword2000&tr=udp://helloworld:1337/announce\", false},\n\t\t{\"magnett:?xt=urn:btih:3E30322D5BFC7444B7B1D8DD42404B75D0531DFB&dn=world&tr=udp://world.com:1337\", false},\n\t\t{\"xt=urn:btih:4ODKSDJBVMSDSNJVBCBFYFBKNRU875DW8D97DWC6&dn=helloworld&tr=udp://helloworld.com:1337\", false},\n\t\t{\"magneta:?xt=urn:btih:1GSHJVBDVDVJFYEHKFHEFIO8573898434JBFEGHD&dn=foo&tr=udp://foo.com:1337\", false},\n\t\t{\"magnet:?xt=uarn:btih:MCJDCYUFHEUD6E2752T7UJNEKHSUGEJFGTFHVBJS&dn=bar&tr=udp://bar.com:1337\", false},\n\t\t{\"magnet:?xt=urn:btihz&dn=foobar&tr=udp://foobar.com:1337\", false},\n\t\t{\"magnet:?xat=urn:btih:MKCJBHCBJDCU725TGEB3Y6RE8EJ2U267UNJFGUID&dn=test&tr=udp://test.com:1337\", false},\n\t\t{\"magnet::?xt=urn:btih:UHWY2892JNEJ2GTEYOMDNU67E8ICGICYE92JDUGH&dn=baz&tr=udp://baz.com:1337\", false},\n\t\t{\"magnet:?xt:btih:HS263FG8U3GFIDHWD7829BYFCIXB78XIHG7CWCUG&dn=foz&tr=udp://foz.com:1337\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsMagnetURI(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsMagnetURI(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsBase64(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdC4=\", true},\n\t\t{\"Vml2YW11cyBmZXJtZW50dW0gc2VtcGVyIHBvcnRhLg==\", true},\n\t\t{\"U3VzcGVuZGlzc2UgbGVjdHVzIGxlbw==\", true},\n\t\t{\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuMPNS1Ufof9EW/M98FNw\" +\n\t\t\t\"UAKrwflsqVxaxQjBQnHQmiI7Vac40t8x7pIb8gLGV6wL7sBTJiPovJ0V7y7oc0Ye\" +\n\t\t\t\"rhKh0Rm4skP2z/jHwwZICgGzBvA0rH8xlhUiTvcwDCJ0kc+fh35hNt8srZQM4619\" +\n\t\t\t\"FTgB66Xmp4EtVyhpQV+t02g6NzK72oZI0vnAvqhpkxLeLiMCyrI416wHm5Tkukhx\" +\n\t\t\t\"QmcL2a6hNOyu0ixX/x2kSFXApEnVrJ+/IxGyfyw8kf4N2IZpW5nEP847lpfj0SZZ\" +\n\t\t\t\"Fwrd1mnfnDbYohX2zRptLy2ZUn06Qo9pkG5ntvFEPo9bfZeULtjYzIl6K8gJ2uGZ\" + \"HQIDAQAB\", true},\n\t\t{\"12345\", false},\n\t\t{\"\", false},\n\t\t{\"Vml2YW11cyBmZXJtZtesting123\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsBase64(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsBase64(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsISO3166Alpha2(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"ABCD\", false},\n\t\t{\"A\", false},\n\t\t{\"AC\", false},\n\t\t{\"AP\", false},\n\t\t{\"GER\", false},\n\t\t{\"NU\", true},\n\t\t{\"DE\", true},\n\t\t{\"JP\", true},\n\t\t{\"JPN\", false},\n\t\t{\"ZWE\", false},\n\t\t{\"GER\", false},\n\t\t{\"DEU\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISO3166Alpha2(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISO3166Alpha2(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsISO3166Alpha3(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"ABCD\", false},\n\t\t{\"A\", false},\n\t\t{\"AC\", false},\n\t\t{\"AP\", false},\n\t\t{\"NU\", false},\n\t\t{\"DE\", false},\n\t\t{\"JP\", false},\n\t\t{\"ZWE\", true},\n\t\t{\"JPN\", true},\n\t\t{\"GER\", false},\n\t\t{\"DEU\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISO3166Alpha3(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISO3166Alpha3(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsISO693Alpha2(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"abcd\", false},\n\t\t{\"a\", false},\n\t\t{\"ac\", false},\n\t\t{\"ap\", false},\n\t\t{\"de\", true},\n\t\t{\"DE\", false},\n\t\t{\"mk\", true},\n\t\t{\"mac\", false},\n\t\t{\"sw\", true},\n\t\t{\"SW\", false},\n\t\t{\"ger\", false},\n\t\t{\"deu\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISO693Alpha2(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISO693Alpha2(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsISO693Alpha3b(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"abcd\", false},\n\t\t{\"a\", false},\n\t\t{\"ac\", false},\n\t\t{\"ap\", false},\n\t\t{\"de\", false},\n\t\t{\"DE\", false},\n\t\t{\"mkd\", false},\n\t\t{\"mac\", true},\n\t\t{\"sw\", false},\n\t\t{\"SW\", false},\n\t\t{\"ger\", true},\n\t\t{\"deu\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISO693Alpha3b(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISO693Alpha3b(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsIP(t *testing.T) {\n\tt.Parallel()\n\n\t// Without version\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", true},\n\t\t{\"0.0.0.0\", true},\n\t\t{\"255.255.255.255\", true},\n\t\t{\"1.2.3.4\", true},\n\t\t{\"::1\", true},\n\t\t{\"2001:db8:0000:1:1:1:1:1\", true},\n\t\t{\"300.0.0.0\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIP(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIP(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// IPv4\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", true},\n\t\t{\"0.0.0.0\", true},\n\t\t{\"255.255.255.255\", true},\n\t\t{\"1.2.3.4\", true},\n\t\t{\"::1\", false},\n\t\t{\"2001:db8:0000:1:1:1:1:1\", false},\n\t\t{\"300.0.0.0\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIPv4(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIPv4(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\t// IPv6\n\ttests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", false},\n\t\t{\"0.0.0.0\", false},\n\t\t{\"255.255.255.255\", false},\n\t\t{\"1.2.3.4\", false},\n\t\t{\"::1\", true},\n\t\t{\"2001:db8:0000:1:1:1:1:1\", true},\n\t\t{\"300.0.0.0\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIPv6(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIPv6(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsPort(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"1\", true},\n\t\t{\"65535\", true},\n\t\t{\"0\", false},\n\t\t{\"65536\", false},\n\t\t{\"65538\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := IsPort(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsPort(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsDNSName(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"localhost\", true},\n\t\t{\"a.bc\", true},\n\t\t{\"a.b.\", true},\n\t\t{\"a.b..\", false},\n\t\t{\"localhost.local\", true},\n\t\t{\"localhost.localdomain.intern\", true},\n\t\t{\"l.local.intern\", true},\n\t\t{\"ru.link.n.svpncloud.com\", true},\n\t\t{\"-localhost\", false},\n\t\t{\"localhost.-localdomain\", false},\n\t\t{\"localhost.localdomain.-int\", false},\n\t\t{\"_localhost\", true},\n\t\t{\"localhost._localdomain\", true},\n\t\t{\"localhost.localdomain._int\", true},\n\t\t{\"lÖcalhost\", false},\n\t\t{\"localhost.lÖcaldomain\", false},\n\t\t{\"localhost.localdomain.üntern\", false},\n\t\t{\"__\", true},\n\t\t{\"localhost/\", false},\n\t\t{\"127.0.0.1\", false},\n\t\t{\"[::1]\", false},\n\t\t{\"50.50.50.50\", false},\n\t\t{\"localhost.localdomain.intern:65535\", false},\n\t\t{\"漢字汉字\", false},\n\t\t{\"www.jubfvq1v3p38i51622y0dvmdk1mymowjyeu26gbtw9andgynj1gg8z3msb1kl5z6906k846pj3sulm4kiyk82ln5teqj9nsht59opr0cs5ssltx78lfyvml19lfq1wp4usbl0o36cmiykch1vywbttcus1p9yu0669h8fj4ll7a6bmop505908s1m83q2ec2qr9nbvql2589adma3xsq2o38os2z3dmfh2tth4is4ixyfasasasefqwe4t2ub2fz1rme.de\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := IsDNSName(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsDNS(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsHost(t *testing.T) {\n\tt.Parallel()\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"localhost\", true},\n\t\t{\"localhost.localdomain\", true},\n\t\t{\"2001:db8:0000:1:1:1:1:1\", true},\n\t\t{\"::1\", true},\n\t\t{\"play.golang.org\", true},\n\t\t{\"localhost.localdomain.intern:65535\", false},\n\t\t{\"-[::1]\", false},\n\t\t{\"-localhost\", false},\n\t\t{\".localhost\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsHost(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsHost(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n}\n\nfunc TestIsDialString(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"localhost.local:1\", true},\n\t\t{\"localhost.localdomain:9090\", true},\n\t\t{\"localhost.localdomain.intern:65535\", true},\n\t\t{\"127.0.0.1:30000\", true},\n\t\t{\"[::1]:80\", true},\n\t\t{\"[1200::AB00:1234::2552:7777:1313]:22\", false},\n\t\t{\"-localhost:1\", false},\n\t\t{\"localhost.-localdomain:9090\", false},\n\t\t{\"localhost.localdomain.-int:65535\", false},\n\t\t{\"localhost.loc:100000\", false},\n\t\t{\"漢字汉字:2\", false},\n\t\t{\"www.jubfvq1v3p38i51622y0dvmdk1mymowjyeu26gbtw9andgynj1gg8z3msb1kl5z6906k846pj3sulm4kiyk82ln5teqj9nsht59opr0cs5ssltx78lfyvml19lfq1wp4usbl0o36cmiykch1vywbttcus1p9yu0669h8fj4ll7a6bmop505908s1m83q2ec2qr9nbvql2589adma3xsq2o38os2z3dmfh2tth4is4ixyfasasasefqwe4t2ub2fz1rme.de:20000\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := IsDialString(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsDialString(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsMAC(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"3D:F2:C9:A6:B3:4F\", true},\n\t\t{\"3D-F2-C9-A6-B3:4F\", false},\n\t\t{\"123\", false},\n\t\t{\"\", false},\n\t\t{\"abacaba\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsMAC(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsMAC(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestFilePath(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t\tosType   int\n\t}{\n\t\t{\"c:\\\\\" + strings.Repeat(\"a\", 32767), true, Win}, //See http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath\n\t\t{\"c:\\\\\" + strings.Repeat(\"a\", 32768), false, Win},\n\t\t{\"c:\\\\path\\\\file (x86)\\bar\", true, Win},\n\t\t{\"c:\\\\path\\\\file\", true, Win},\n\t\t{\"c:\\\\path\\\\file:exe\", false, Unknown},\n\t\t{\"C:\\\\\", true, Win},\n\t\t{\"c:\\\\path\\\\file\\\\\", true, Win},\n\t\t{\"c:/path/file/\", false, Unknown},\n\t\t{\"/path/file/\", true, Unix},\n\t\t{\"/path/file:SAMPLE/\", true, Unix},\n\t\t{\"/path/file:/.txt\", true, Unix},\n\t\t{\"/path\", true, Unix},\n\t\t{\"/path/__bc/file.txt\", true, Unix},\n\t\t{\"/path/a--ac/file.txt\", true, Unix},\n\t\t{\"/_path/file.txt\", true, Unix},\n\t\t{\"/path/__bc/file.txt\", true, Unix},\n\t\t{\"/path/a--ac/file.txt\", true, Unix},\n\t\t{\"/__path/--file.txt\", true, Unix},\n\t\t{\"/path/a bc\", true, Unix},\n\t}\n\tfor _, test := range tests {\n\t\tactual, osType := IsFilePath(test.param)\n\t\tif actual != test.expected || osType != test.osType {\n\t\t\tt.Errorf(\"Expected IsFilePath(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsWinFilePath(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"c:\\\\\" + strings.Repeat(\"a\", 32767), true}, //See http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath\n\t\t{\"c:\\\\\" + strings.Repeat(\"a\", 32768), false},\n\t\t{\"c:\\\\path\\\\file (x86)\\\\bar\", true},\n\t\t{\"c:\\\\path\\\\file\", true},\n\t\t{\"c:\\\\path\\\\file:exe\", false},\n\t\t{\"C:\\\\\", true},\n\t\t{\"c:\\\\path\\\\file\\\\\", true},\n\t\t{\"..\\\\path\\\\file\\\\\", true},\n\t\t{\"c:/path/file/\", false},\n\t\t{\"a bc\", true},\n\t\t{\"abc.jd\", true},\n\t\t{\"abc.jd:$#%# dsd\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsWinFilePath(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsWinFilePath(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsUnixFilePath(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"c:/path/file/\", true},    //relative path\n\t\t{\"../path/file/\", true},    //relative path\n\t\t{\"../../path/file/\", true}, //relative path\n\t\t{\"./path/file/\", true},     //relative path\n\t\t{\"./file.dghdg\", true},     //relative path\n\t\t{\"/path/file/\", true},\n\t\t{\"/path/file:SAMPLE/\", true},\n\t\t{\"/path/file:/.txt\", true},\n\t\t{\"/path\", true},\n\t\t{\"/path/__bc/file.txt\", true},\n\t\t{\"/path/a--ac/file.txt\", true},\n\t\t{\"/_path/file.txt\", true},\n\t\t{\"/path/__bc/file.txt\", true},\n\t\t{\"/path/a--ac/file.txt\", true},\n\t\t{\"/__path/--file.txt\", true},\n\t\t{\"/path/a bc\", true},\n\t\t{\"a bc\", true},\n\t\t{\"abc.jd\", true},\n\t\t{\"abc.jd:$#%# dsd\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsUnixFilePath(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsUnixFilePath(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsLatitude(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"-90.000\", true},\n\t\t{\"+90\", true},\n\t\t{\"47.1231231\", true},\n\t\t{\"+99.9\", false},\n\t\t{\"108\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsLatitude(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsLatitude(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsLongitude(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"-180.000\", true},\n\t\t{\"180.1\", false},\n\t\t{\"+73.234\", true},\n\t\t{\"+382.3811\", false},\n\t\t{\"23.11111111\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsLongitude(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsLongitude(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSSN(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"00-90-8787\", false},\n\t\t{\"66690-76\", false},\n\t\t{\"191 60 2869\", true},\n\t\t{\"191-60-2869\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSSN(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSSN(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsMongoID(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"507f1f77bcf86cd799439011\", true},\n\t\t{\"507f1f77bcf86cd7994390\", false},\n\t\t{\"507f1f77bcf86cd79943901z\", false},\n\t\t{\"507f1f77bcf86cd799439011 \", false},\n\t\t{\"\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsMongoID(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsMongoID(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsSemver(t *testing.T) {\n\tt.Parallel()\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"v1.0.0\", true},\n\t\t{\"1.0.0\", true},\n\t\t{\"1.1.01\", false},\n\t\t{\"1.01.0\", false},\n\t\t{\"01.1.0\", false},\n\t\t{\"v1.1.01\", false},\n\t\t{\"v1.01.0\", false},\n\t\t{\"v01.1.0\", false},\n\t\t{\"1.0.0-alpha\", true},\n\t\t{\"1.0.0-alpha.1\", true},\n\t\t{\"1.0.0-0.3.7\", true},\n\t\t{\"1.0.0-0.03.7\", false},\n\t\t{\"1.0.0-00.3.7\", false},\n\t\t{\"1.0.0-x.7.z.92\", true},\n\t\t{\"1.0.0-alpha+001\", true},\n\t\t{\"1.0.0+20130313144700\", true},\n\t\t{\"1.0.0-beta+exp.sha.5114f85\", true},\n\t\t{\"1.0.0-beta+exp.sha.05114f85\", true},\n\t\t{\"1.0.0-+beta\", false},\n\t\t{\"1.0.0-b+-9+eta\", false},\n\t\t{\"v+1.8.0-b+-9+eta\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsSemver(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsSemver(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsTime(t *testing.T) {\n\tt.Parallel()\n\tvar tests = []struct {\n\t\tparam    string\n\t\tformat   string\n\t\texpected bool\n\t}{\n\t\t{\"2016-12-31 11:00\", time.RFC3339, false},\n\t\t{\"2016-12-31 11:00:00\", time.RFC3339, false},\n\t\t{\"2016-12-31T11:00\", time.RFC3339, false},\n\t\t{\"2016-12-31T11:00:00\", time.RFC3339, false},\n\t\t{\"2016-12-31T11:00:00Z\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00+01:00\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00-01:00\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00.05Z\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00.05-01:00\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00.05+01:00\", time.RFC3339, true},\n\t\t{\"2016-12-31T11:00:00\", rfc3339WithoutZone, true},\n\t\t{\"2016-12-31T11:00:00Z\", rfc3339WithoutZone, false},\n\t\t{\"2016-12-31T11:00:00+01:00\", rfc3339WithoutZone, false},\n\t\t{\"2016-12-31T11:00:00-01:00\", rfc3339WithoutZone, false},\n\t\t{\"2016-12-31T11:00:00.05Z\", rfc3339WithoutZone, false},\n\t\t{\"2016-12-31T11:00:00.05-01:00\", rfc3339WithoutZone, false},\n\t\t{\"2016-12-31T11:00:00.05+01:00\", rfc3339WithoutZone, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsTime(test.param, test.format)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsTime(%q, time.RFC3339) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsRFC3339(t *testing.T) {\n\tt.Parallel()\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"2016-12-31 11:00\", false},\n\t\t{\"2016-12-31 11:00:00\", false},\n\t\t{\"2016-12-31T11:00\", false},\n\t\t{\"2016-12-31T11:00:00\", false},\n\t\t{\"2016-12-31T11:00:00Z\", true},\n\t\t{\"2016-12-31T11:00:00+01:00\", true},\n\t\t{\"2016-12-31T11:00:00-01:00\", true},\n\t\t{\"2016-12-31T11:00:00.05Z\", true},\n\t\t{\"2016-12-31T11:00:00.05-01:00\", true},\n\t\t{\"2016-12-31T11:00:00.05+01:00\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsRFC3339(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsRFC3339(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsISO4217(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"ABCD\", false},\n\t\t{\"A\", false},\n\t\t{\"ZZZ\", false},\n\t\t{\"usd\", false},\n\t\t{\"USD\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsISO4217(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsISO4217(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestByteLength(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tvalue    string\n\t\tmin      string\n\t\tmax      string\n\t\texpected bool\n\t}{\n\t\t{\"123456\", \"0\", \"100\", true},\n\t\t{\"1239999\", \"0\", \"0\", false},\n\t\t{\"1239asdfasf99\", \"100\", \"200\", false},\n\t\t{\"1239999asdff29\", \"10\", \"30\", true},\n\t\t{\"你\", \"0\", \"1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := ByteLength(test.value, test.min, test.max)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ByteLength(%s, %s, %s) to be %v, got %v\", test.value, test.min, test.max, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRuneLength(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tvalue    string\n\t\tmin      string\n\t\tmax      string\n\t\texpected bool\n\t}{\n\t\t{\"123456\", \"0\", \"100\", true},\n\t\t{\"1239999\", \"0\", \"0\", false},\n\t\t{\"1239asdfasf99\", \"100\", \"200\", false},\n\t\t{\"1239999asdff29\", \"10\", \"30\", true},\n\t\t{\"你\", \"0\", \"1\", true},\n\t}\n\tfor _, test := range tests {\n\t\tactual := RuneLength(test.value, test.min, test.max)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected RuneLength(%s, %s, %s) to be %v, got %v\", test.value, test.min, test.max, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestStringLength(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tvalue    string\n\t\tmin      string\n\t\tmax      string\n\t\texpected bool\n\t}{\n\t\t{\"123456\", \"0\", \"100\", true},\n\t\t{\"1239999\", \"0\", \"0\", false},\n\t\t{\"1239asdfasf99\", \"100\", \"200\", false},\n\t\t{\"1239999asdff29\", \"10\", \"30\", true},\n\t\t{\"あいうえお\", \"0\", \"5\", true},\n\t\t{\"あいうえおか\", \"0\", \"5\", false},\n\t\t{\"あいうえお\", \"0\", \"0\", false},\n\t\t{\"あいうえ\", \"5\", \"10\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := StringLength(test.value, test.min, test.max)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected StringLength(%s, %s, %s) to be %v, got %v\", test.value, test.min, test.max, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsIn(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tvalue    string\n\t\tparams   []string\n\t\texpected bool\n\t}{\n\t\t{\"PRESENT\", []string{\"PRESENT\"}, true},\n\t\t{\"PRESENT\", []string{\"PRESENT\", \"PRÉSENTE\", \"NOTABSENT\"}, true},\n\t\t{\"PRÉSENTE\", []string{\"PRESENT\", \"PRÉSENTE\", \"NOTABSENT\"}, true},\n\t\t{\"PRESENT\", []string{}, false},\n\t\t{\"PRESENT\", nil, false},\n\t\t{\"ABSENT\", []string{\"PRESENT\", \"PRÉSENTE\", \"NOTABSENT\"}, false},\n\t\t{\"\", []string{\"PRESENT\", \"PRÉSENTE\", \"NOTABSENT\"}, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIn(test.value, test.params...)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIn(%s, %v) to be %v, got %v\", test.value, test.params, test.expected, actual)\n\t\t}\n\t}\n}\n\ntype Address struct {\n\tStreet string `valid:\"-\"`\n\tZip    string `json:\"zip\" valid:\"numeric,required\"`\n}\n\ntype User struct {\n\tName     string `valid:\"required\"`\n\tEmail    string `valid:\"required,email\"`\n\tPassword string `valid:\"required\"`\n\tAge      int    `valid:\"required,numeric,@#\\u0000\"`\n\tHome     *Address\n\tWork     []Address\n}\n\ntype UserValid struct {\n\tName     string `valid:\"required\"`\n\tEmail    string `valid:\"required,email\"`\n\tPassword string `valid:\"required\"`\n\tAge      int    `valid:\"required\"`\n\tHome     *Address\n\tWork     []Address `valid:\"required\"`\n}\n\ntype PrivateStruct struct {\n\tprivateField string `valid:\"required,alpha,d_k\"`\n\tNonZero      int\n\tListInt      []int\n\tListString   []string `valid:\"alpha\"`\n\tWork         [2]Address\n\tHome         Address\n\tMap          map[string]Address\n}\n\ntype NegationStruct struct {\n\tNotInt string `valid:\"!int\"`\n\tInt    string `valid:\"int\"`\n}\n\ntype LengthStruct struct {\n\tLength string `valid:\"length(10|20)\"`\n}\n\ntype StringLengthStruct struct {\n\tLength string `valid:\"stringlength(10|20)\"`\n}\n\ntype StringMatchesStruct struct {\n\tStringMatches string `valid:\"matches(^[0-9]{3}$)\"`\n}\n\n// TODO: this testcase should be fixed\n// type StringMatchesComplexStruct struct {\n// \tStringMatches string `valid:\"matches(^\\\\$\\\\([\\\"']\\\\w+[\\\"']\\\\)$)\"`\n// }\n\ntype IsInStruct struct {\n\tIsIn string `valid:\"in(PRESENT|PRÉSENTE|NOTABSENT)\"`\n}\n\ntype Post struct {\n\tTitle    string `valid:\"alpha,required\"`\n\tMessage  string `valid:\"ascii\"`\n\tAuthorIP string `valid:\"ipv4\"`\n}\n\ntype MissingValidationDeclarationStruct struct {\n\tName  string ``\n\tEmail string `valid:\"required,email\"`\n}\n\ntype FieldRequiredByDefault struct {\n\tEmail string `valid:\"email\"`\n}\n\ntype MultipleFieldsRequiredByDefault struct {\n\tUrl   string `valid:\"url\"`\n\tEmail string `valid:\"email\"`\n}\n\ntype FieldsRequiredByDefaultButExemptStruct struct {\n\tName  string `valid:\"-\"`\n\tEmail string `valid:\"email\"`\n}\n\ntype FieldsRequiredByDefaultButExemptOrOptionalStruct struct {\n\tName  string `valid:\"-\"`\n\tEmail string `valid:\"optional,email\"`\n}\n\ntype MessageWithSeveralFieldsStruct struct {\n\tTitle string `valid:\"length(1|10)\"`\n\tBody  string `valid:\"length(1|10)\"`\n}\n\nfunc TestValidateMissingValidationDeclarationStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    MissingValidationDeclarationStruct\n\t\texpected bool\n\t}{\n\t\t{MissingValidationDeclarationStruct{}, false},\n\t\t{MissingValidationDeclarationStruct{Name: \"TEST\", Email: \"test@example.com\"}, false},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestFieldRequiredByDefault(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    FieldRequiredByDefault\n\t\texpected bool\n\t}{\n\t\t{FieldRequiredByDefault{}, false},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestMultipleFieldsRequiredByDefault(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    MultipleFieldsRequiredByDefault\n\t\texpected bool\n\t}{\n\t\t{MultipleFieldsRequiredByDefault{}, false},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestFieldsRequiredByDefaultButExemptStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    FieldsRequiredByDefaultButExemptStruct\n\t\texpected bool\n\t}{\n\t\t{FieldsRequiredByDefaultButExemptStruct{}, false},\n\t\t{FieldsRequiredByDefaultButExemptStruct{Name: \"TEST\"}, false},\n\t\t{FieldsRequiredByDefaultButExemptStruct{Email: \"\"}, false},\n\t\t{FieldsRequiredByDefaultButExemptStruct{Email: \"test@example.com\"}, true},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestFieldsRequiredByDefaultButExemptOrOptionalStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    FieldsRequiredByDefaultButExemptOrOptionalStruct\n\t\texpected bool\n\t}{\n\t\t{FieldsRequiredByDefaultButExemptOrOptionalStruct{}, true},\n\t\t{FieldsRequiredByDefaultButExemptOrOptionalStruct{Name: \"TEST\"}, true},\n\t\t{FieldsRequiredByDefaultButExemptOrOptionalStruct{Email: \"\"}, true},\n\t\t{FieldsRequiredByDefaultButExemptOrOptionalStruct{Email: \"test@example.com\"}, true},\n\t\t{FieldsRequiredByDefaultButExemptOrOptionalStruct{Email: \"test@example\"}, false},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestInvalidValidator(t *testing.T) {\n\ttype InvalidStruct struct {\n\t\tField int `valid:\"someInvalidValidator\"`\n\t}\n\n\tinvalidStruct := InvalidStruct{1}\n\tif valid, err := ValidateStruct(&invalidStruct); valid || err == nil ||\n\t\terr.Error() != `Field: The following validator is invalid or can't be applied to the field: \"someInvalidValidator\"` {\n\t\tt.Errorf(\"Got an unexpected result for struct with invalid validator: %t %s\", valid, err)\n\t}\n}\n\nfunc TestCustomValidator(t *testing.T) {\n\ttype ValidStruct struct {\n\t\tField int `valid:\"customTrueValidator\"`\n\t}\n\n\ttype InvalidStruct struct {\n\t\tField int `valid:\"customFalseValidator~Value: %s Custom validator error: %s\"`\n\t}\n\n\ttype StructWithCustomAndBuiltinValidator struct {\n\t\tField int `valid:\"customTrueValidator,required\"`\n\t}\n\n\tif valid, err := ValidateStruct(&ValidStruct{Field: 1}); !valid || err != nil {\n\t\tt.Errorf(\"Got an unexpected result for struct with custom always true validator: %t %s\", valid, err)\n\t}\n\n\tif valid, err := ValidateStruct(&InvalidStruct{Field: 1}); valid || err == nil || err.Error() != \"Value: 1 Custom validator error: customFalseValidator\" {\n\t\tfmt.Println(err)\n\t\tt.Errorf(\"Got an unexpected result for struct with custom always false validator: %t %s\", valid, err)\n\t}\n\n\tmixedStruct := StructWithCustomAndBuiltinValidator{}\n\tif valid, err := ValidateStruct(&mixedStruct); valid || err == nil || err.Error() != \"Field: non zero value required\" {\n\t\tt.Errorf(\"Got an unexpected result for invalid struct with custom and built-in validators: %t %s\", valid, err)\n\t}\n\n\tmixedStruct.Field = 1\n\tif valid, err := ValidateStruct(&mixedStruct); !valid || err != nil {\n\t\tt.Errorf(\"Got an unexpected result for valid struct with custom and built-in validators: %t %s\", valid, err)\n\t}\n}\n\ntype CustomByteArray [6]byte\n\ntype StructWithCustomByteArray struct {\n\tID              CustomByteArray `valid:\"customByteArrayValidator,customMinLengthValidator\"`\n\tEmail           string          `valid:\"email\"`\n\tCustomMinLength int             `valid:\"-\"`\n}\n\nfunc TestStructWithCustomByteArray(t *testing.T) {\n\tt.Parallel()\n\n\t// add our custom byte array validator that fails when the byte array is pristine (all zeroes)\n\tCustomTypeTagMap.Set(\"customByteArrayValidator\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\tswitch v := o.(type) {\n\t\tcase StructWithCustomByteArray:\n\t\t\tif len(v.Email) > 0 {\n\t\t\t\tif v.Email != \"test@example.com\" {\n\t\t\t\t\tt.Errorf(\"v.Email should have been 'test@example.com' but was '%s'\", v.Email)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Errorf(\"Context object passed to custom validator should have been a StructWithCustomByteArray but was %T (%+v)\", o, o)\n\t\t}\n\n\t\tswitch v := i.(type) {\n\t\tcase CustomByteArray:\n\t\t\tfor _, e := range v { // checks if v is empty, i.e. all zeroes\n\t\t\t\tif e != 0 {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}))\n\tCustomTypeTagMap.Set(\"customMinLengthValidator\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\tswitch v := o.(type) {\n\t\tcase StructWithCustomByteArray:\n\t\t\treturn len(v.ID) >= v.CustomMinLength\n\t\t}\n\t\treturn false\n\t}))\n\ttestCustomByteArray := CustomByteArray{'1', '2', '3', '4', '5', '6'}\n\tvar tests = []struct {\n\t\tparam    StructWithCustomByteArray\n\t\texpected bool\n\t}{\n\t\t{StructWithCustomByteArray{}, false},\n\t\t{StructWithCustomByteArray{Email: \"test@example.com\"}, false},\n\t\t{StructWithCustomByteArray{ID: testCustomByteArray, Email: \"test@example.com\"}, true},\n\t\t{StructWithCustomByteArray{ID: testCustomByteArray, Email: \"test@example.com\", CustomMinLength: 7}, false},\n\t}\n\tSetFieldsRequiredByDefault(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\tSetFieldsRequiredByDefault(false)\n}\n\nfunc TestValidateNegationStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    NegationStruct\n\t\texpected bool\n\t}{\n\t\t{NegationStruct{\"a1\", \"11\"}, true},\n\t\t{NegationStruct{\"email@email.email\", \"11\"}, true},\n\t\t{NegationStruct{\"123456----\", \"11\"}, true},\n\t\t{NegationStruct{\"::1\", \"11\"}, true},\n\t\t{NegationStruct{\"123.123\", \"11\"}, true},\n\t\t{NegationStruct{\"a1\", \"a1\"}, false},\n\t\t{NegationStruct{\"11\", \"a1\"}, false},\n\t\t{NegationStruct{\"11\", \"11\"}, false},\n\t}\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestLengthStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{LengthStruct{\"11111\"}, false},\n\t\t{LengthStruct{\"11111111111111111110000000000000000\"}, false},\n\t\t{LengthStruct{\"11dfffdf0099\"}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStringLengthStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{StringLengthStruct{\"11111\"}, false},\n\t\t{StringLengthStruct{\"11111111111111111110000000000000000\"}, false},\n\t\t{StringLengthStruct{\"11dfffdf0099\"}, true},\n\t\t{StringLengthStruct{\"あいうえお\"}, false},\n\t\t{StringLengthStruct{\"あいうえおかきくけこ\"}, true},\n\t\t{StringLengthStruct{\"あいうえおかきくけこさしすせそたちつてと\"}, true},\n\t\t{StringLengthStruct{\"あいうえおかきくけこさしすせそたちつてとな\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStringMatchesStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{StringMatchesStruct{\"123\"}, true},\n\t\t{StringMatchesStruct{\"123456\"}, false},\n\t\t{StringMatchesStruct{\"123abcd\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsInStruct(t *testing.T) {\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{IsInStruct{\"PRESENT\"}, true},\n\t\t{IsInStruct{\"\"}, true},\n\t\t{IsInStruct{\" \"}, false},\n\t\t{IsInStruct{\"ABSENT\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRequiredIsInStruct(t *testing.T) {\n\ttype RequiredIsInStruct struct {\n\t\tIsIn string `valid:\"in(PRESENT|PRÉSENTE|NOTABSENT),required\"`\n\t}\n\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{RequiredIsInStruct{\"PRESENT\"}, true},\n\t\t{RequiredIsInStruct{\"\"}, false},\n\t\t{RequiredIsInStruct{\" \"}, false},\n\t\t{RequiredIsInStruct{\"ABSENT\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEmptyRequiredIsInStruct(t *testing.T) {\n\ttype EmptyRequiredIsInStruct struct {\n\t\tIsIn string `valid:\"in(),required\"`\n\t}\n\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{EmptyRequiredIsInStruct{\"PRESENT\"}, false},\n\t\t{EmptyRequiredIsInStruct{\"\"}, false},\n\t\t{EmptyRequiredIsInStruct{\" \"}, false},\n\t\t{EmptyRequiredIsInStruct{\"ABSENT\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEmptyStringPtr(t *testing.T) {\n\ttype EmptyIsInStruct struct {\n\t\tIsIn *string `valid:\"length(3|5),required\"`\n\t}\n\n\tvar empty = \"\"\n\tvar valid = \"123\"\n\tvar invalid = \"123456\"\n\n\tvar tests = []struct {\n\t\tparam       interface{}\n\t\texpected    bool\n\t\texpectedErr string\n\t}{\n\t\t{EmptyIsInStruct{&empty}, false, \"IsIn: non zero value required\"},\n\t\t{EmptyIsInStruct{nil}, true, \"\"},\n\t\t{EmptyIsInStruct{&valid}, true, \"\"},\n\t\t{EmptyIsInStruct{&invalid}, false, \"IsIn: 123456 does not validate as length(3|5)\"},\n\t}\n\n\tSetNilPtrAllowedByRequired(true)\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t\tif err != nil {\n\t\t\tif err.Error() != test.expectedErr {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q). Expected: %s Actual: %s\", test.param, test.expectedErr, err)\n\t\t\t}\n\t\t} else if test.expectedErr != \"\" {\n\t\t\tt.Errorf(\"Expected error on ValidateStruct(%q).\", test.param)\n\t\t}\n\t}\n\tSetNilPtrAllowedByRequired(false)\n}\n\nfunc TestNestedStruct(t *testing.T) {\n\ttype EvenMoreNestedStruct struct {\n\t\tBar string `valid:\"length(3|5)\"`\n\t}\n\ttype NestedStruct struct {\n\t\tFoo                 string `valid:\"length(3|5),required\"`\n\t\tEvenMoreNested      EvenMoreNestedStruct\n\t\tSliceEvenMoreNested []EvenMoreNestedStruct\n\t\tMapEvenMoreNested   map[string]EvenMoreNestedStruct\n\t}\n\ttype OuterStruct struct {\n\t\tNested NestedStruct\n\t}\n\n\tvar tests = []struct {\n\t\tparam       interface{}\n\t\texpected    bool\n\t\texpectedErr string\n\t}{\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"\",\n\t\t\t},\n\t\t}, false, \"Nested.Foo: non zero value required\"},\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"123\",\n\t\t\t},\n\t\t}, true, \"\"},\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"123456\",\n\t\t\t},\n\t\t}, false, \"Nested.Foo: 123456 does not validate as length(3|5)\"},\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"123\",\n\t\t\t\tEvenMoreNested: EvenMoreNestedStruct{\n\t\t\t\t\tBar: \"123456\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, false, \"Nested.EvenMoreNested.Bar: 123456 does not validate as length(3|5)\"},\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"123\",\n\t\t\t\tSliceEvenMoreNested: []EvenMoreNestedStruct{\n\t\t\t\t\t{\n\t\t\t\t\t\tBar: \"123456\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, false, \"Nested.SliceEvenMoreNested.0.Bar: 123456 does not validate as length(3|5)\"},\n\t\t{OuterStruct{\n\t\t\tNested: NestedStruct{\n\t\t\t\tFoo: \"123\",\n\t\t\t\tMapEvenMoreNested: map[string]EvenMoreNestedStruct{\n\t\t\t\t\t\"Foo\": {\n\t\t\t\t\t\tBar: \"123456\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, false, \"Nested.MapEvenMoreNested.Foo.Bar: 123456 does not validate as length(3|5)\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t\tif err != nil {\n\t\t\tif err.Error() != test.expectedErr {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q). Expected: %s Actual: %s\", test.param, test.expectedErr, err)\n\t\t\t}\n\t\t} else if test.expectedErr != \"\" {\n\t\t\tt.Errorf(\"Expected error on ValidateStruct(%q).\", test.param)\n\t\t}\n\t}\n}\n\nfunc TestFunkyIsInStruct(t *testing.T) {\n\ttype FunkyIsInStruct struct {\n\t\tIsIn string `valid:\"in(PRESENT|| |PRÉSENTE|NOTABSENT)\"`\n\t}\n\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{FunkyIsInStruct{\"PRESENT\"}, true},\n\t\t{FunkyIsInStruct{\"\"}, true},\n\t\t{FunkyIsInStruct{\" \"}, true},\n\t\t{FunkyIsInStruct{\"ABSENT\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: test case broken\n// func TestStringMatchesComplexStruct(t *testing.T) {\n// \tvar tests = []struct {\n// \t\tparam    interface{}\n// \t\texpected bool\n// \t}{\n// \t\t{StringMatchesComplexStruct{\"$()\"}, false},\n// \t\t{StringMatchesComplexStruct{\"$('AZERTY')\"}, true},\n// \t\t{StringMatchesComplexStruct{`$(\"AZERTY\")`}, true},\n// \t\t{StringMatchesComplexStruct{`$(\"\")`}, false},\n// \t\t{StringMatchesComplexStruct{\"AZERTY\"}, false},\n// \t\t{StringMatchesComplexStruct{\"$AZERTY\"}, false},\n// \t}\n\n// \tfor _, test := range tests {\n// \t\tactual, err := ValidateStruct(test.param)\n// \t\tif actual != test.expected {\n// \t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n// \t\t\tif err != nil {\n// \t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n\nfunc TestValidateStruct(t *testing.T) {\n\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{User{\"John\", \"john@yahoo.com\", \"123G#678\", 20, &Address{\"Street\", \"ABC456D89\"}, []Address{{\"Street\", \"123456\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{User{\"John\", \"john!yahoo.com\", \"12345678\", 20, &Address{\"Street\", \"ABC456D89\"}, []Address{{\"Street\", \"ABC456D89\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{User{\"John\", \"\", \"12345\", 0, &Address{\"Street\", \"123456789\"}, []Address{{\"Street\", \"ABC456D89\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{UserValid{\"John\", \"john@yahoo.com\", \"123G#678\", 20, &Address{\"Street\", \"123456\"}, []Address{{\"Street\", \"123456\"}, {\"Street\", \"123456\"}}}, true},\n\t\t{UserValid{\"John\", \"john!yahoo.com\", \"12345678\", 20, &Address{\"Street\", \"ABC456D89\"}, []Address{}}, false},\n\t\t{UserValid{\"John\", \"john@yahoo.com\", \"12345678\", 20, &Address{\"Street\", \"123456xxx\"}, []Address{{\"Street\", \"123456\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{UserValid{\"John\", \"john!yahoo.com\", \"12345678\", 20, &Address{\"Street\", \"ABC456D89\"}, []Address{{\"Street\", \"ABC456D89\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{UserValid{\"John\", \"\", \"12345\", 0, &Address{\"Street\", \"123456789\"}, []Address{{\"Street\", \"ABC456D89\"}, {\"Street\", \"123456\"}}}, false},\n\t\t{nil, true},\n\t\t{User{\"John\", \"john@yahoo.com\", \"123G#678\", 0, &Address{\"Street\", \"123456\"}, []Address{}}, false},\n\t\t{\"im not a struct\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tTagMap[\"d_k\"] = Validator(func(str string) bool {\n\t\treturn str == \"d_k\"\n\t})\n\tresult, err := ValidateStruct(PrivateStruct{\"d_k\", 0, []int{1, 2}, []string{\"hi\", \"super\"}, [2]Address{{\"Street\", \"123456\"},\n\t\t{\"Street\", \"123456\"}}, Address{\"Street\", \"123456\"}, map[string]Address{\"address\": {\"Street\", \"123456\"}}})\n\tif !result {\n\t\tt.Log(\"Case \", 6, \": expected \", true, \" when result is \", result)\n\t\tt.Error(err)\n\t\tt.FailNow()\n\t}\n}\n\ntype testByteArray [8]byte\ntype testByteMap map[byte]byte\ntype testByteSlice []byte\ntype testStringStringMap map[string]string\ntype testStringIntMap map[string]int\n\nfunc TestRequired(t *testing.T) {\n\n\ttestString := \"foobar\"\n\ttestEmptyString := \"\"\n\tvar tests = []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tstruct {\n\t\t\t\tPointer *string `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tPointer *string `valid:\"required\"`\n\t\t\t}{\n\t\t\t\tPointer: &testEmptyString,\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tPointer *string `valid:\"required\"`\n\t\t\t}{\n\t\t\t\tPointer: &testString,\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tAddr Address `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tAddr Address `valid:\"required\"`\n\t\t\t}{\n\t\t\t\tAddr: Address{\"\", \"123\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tPointer *Address `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tPointer *Address `valid:\"required\"`\n\t\t\t}{\n\t\t\t\tPointer: &Address{\"\", \"123\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestByteArray testByteArray `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestByteArray testByteArray `valid:\"required\"`\n\t\t\t}{\n\t\t\t\ttestByteArray{},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestByteArray testByteArray `valid:\"required\"`\n\t\t\t}{\n\t\t\t\ttestByteArray{'1', '2', '3', '4', '5', '6', '7', 'A'},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestByteMap testByteMap `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestByteSlice testByteSlice `valid:\"required\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestStringStringMap testStringStringMap `valid:\"required\"`\n\t\t\t}{\n\t\t\t\ttestStringStringMap{\"test\": \"test\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tstruct {\n\t\t\t\tTestIntMap testStringIntMap `valid:\"required\"`\n\t\t\t}{\n\t\t\t\ttestStringIntMap{\"test\": 42},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tactual, err := ValidateStruct(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ValidateStruct(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got Error on ValidateStruct(%q): %s\", test.param, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestErrorByField(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"message\", \"\"},\n\t\t{\"Message\", \"\"},\n\t\t{\"title\", \"\"},\n\t\t{\"Title\", \"My123 does not validate as alpha\"},\n\t\t{\"AuthorIP\", \"123 does not validate as ipv4\"},\n\t}\n\tpost := &Post{\"My123\", \"duck13126\", \"123\"}\n\t_, err := ValidateStruct(post)\n\n\tfor _, test := range tests {\n\t\tactual := ErrorByField(err, test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestErrorsByField(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"Title\", \"My123 does not validate as alpha\"},\n\t\t{\"AuthorIP\", \"123 does not validate as ipv4\"},\n\t}\n\tpost := &Post{Title: \"My123\", Message: \"duck13126\", AuthorIP: \"123\"}\n\t_, err := ValidateStruct(post)\n\terrs := ErrorsByField(err)\n\tif len(errs) != 2 {\n\t\tt.Errorf(\"There should only be 2 errors but got %v\", len(errs))\n\t}\n\n\tfor _, test := range tests {\n\t\tif actual, ok := errs[test.param]; !ok || actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorsByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\ttests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"Title\", \";:;message;:; does not validate as length(1|10)\"},\n\t\t{\"Body\", \";:;message;:; does not validate as length(1|10)\"},\n\t}\n\n\tmessage := &MessageWithSeveralFieldsStruct{Title: \";:;message;:;\", Body: \";:;message;:;\"}\n\t_, err = ValidateStruct(message)\n\terrs = ErrorsByField(err)\n\tif len(errs) != 2 {\n\t\tt.Errorf(\"There should only be 2 errors but got %v\", len(errs))\n\t}\n\n\tfor _, test := range tests {\n\t\tif actual, ok := errs[test.param]; !ok || actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorsByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\ttests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"CustomField\", \"An error occurred\"},\n\t}\n\n\terr = Error{\"CustomField\", fmt.Errorf(\"An error occurred\"), false, \"hello\", []string{}}\n\terrs = ErrorsByField(err)\n\n\tif len(errs) != 1 {\n\t\tt.Errorf(\"There should only be 1 errors but got %v\", len(errs))\n\t}\n\n\tfor _, test := range tests {\n\t\tif actual, ok := errs[test.param]; !ok || actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorsByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n\n\ttype StructWithCustomValidation struct {\n\t\tEmail string `valid:\"email\"`\n\t\tID    string `valid:\"falseValidation\"`\n\t}\n\n\tCustomTypeTagMap.Set(\"falseValidation\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\treturn false\n\t}))\n\n\ttests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"Email\", \"My123 does not validate as email\"},\n\t\t{\"ID\", \"duck13126 does not validate as falseValidation\"},\n\t}\n\ts := &StructWithCustomValidation{Email: \"My123\", ID: \"duck13126\"}\n\t_, err = ValidateStruct(s)\n\terrs = ErrorsByField(err)\n\tif len(errs) != 2 {\n\t\tt.Errorf(\"There should only be 2 errors but got %v\", len(errs))\n\t}\n\n\tfor _, test := range tests {\n\t\tif actual, ok := errs[test.param]; !ok || actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorsByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestValidateStructPointers(t *testing.T) {\n\t// Struct which uses pointers for values\n\ttype UserWithPointers struct {\n\t\tName         *string `valid:\"-\"`\n\t\tEmail        *string `valid:\"email\"`\n\t\tFavoriteFood *string `valid:\"length(0|32)\"`\n\t\tNerd         *bool   `valid:\"-\"`\n\t}\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected string\n\t}{\n\t\t{\"Name\", \"\"},\n\t\t{\"Email\", \"invalid does not validate as email\"},\n\t\t{\"FavoriteFood\", \"\"},\n\t\t{\"Nerd\", \"\"},\n\t}\n\n\tname := \"Herman\"\n\temail := \"invalid\"\n\tfood := \"Pizza\"\n\tnerd := true\n\tuser := &UserWithPointers{&name, &email, &food, &nerd}\n\t_, err := ValidateStruct(user)\n\n\tfor _, test := range tests {\n\t\tactual := ErrorByField(err, test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected ErrorByField(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc ExampleValidateStruct() {\n\ttype Post struct {\n\t\tTitle    string `valid:\"alphanum,required\"`\n\t\tMessage  string `valid:\"duck,ascii\"`\n\t\tAuthorIP string `valid:\"ipv4\"`\n\t}\n\tpost := &Post{\"My Example Post\", \"duck\", \"123.234.54.3\"}\n\n\t//Add your own struct validation tags\n\tTagMap[\"duck\"] = Validator(func(str string) bool {\n\t\treturn str == \"duck\"\n\t})\n\n\tresult, err := ValidateStruct(post)\n\tif err != nil {\n\t\tprintln(\"error: \" + err.Error())\n\t}\n\tprintln(result)\n}\n\nfunc TestValidateStructParamValidatorInt(t *testing.T) {\n\ttype Test1 struct {\n\t\tInt   int   `valid:\"range(1|10)\"`\n\t\tInt8  int8  `valid:\"range(1|10)\"`\n\t\tInt16 int16 `valid:\"range(1|10)\"`\n\t\tInt32 int32 `valid:\"range(1|10)\"`\n\t\tInt64 int64 `valid:\"range(1|10)\"`\n\n\t\tUint   uint   `valid:\"range(1|10)\"`\n\t\tUint8  uint8  `valid:\"range(1|10)\"`\n\t\tUint16 uint16 `valid:\"range(1|10)\"`\n\t\tUint32 uint32 `valid:\"range(1|10)\"`\n\t\tUint64 uint64 `valid:\"range(1|10)\"`\n\n\t\tFloat32 float32 `valid:\"range(1|10)\"`\n\t\tFloat64 float64 `valid:\"range(1|10)\"`\n\t}\n\ttest1Ok := &Test1{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}\n\ttest1NotOk := &Test1{11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11}\n\n\t_, err := ValidateStruct(test1Ok)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: %s\", err)\n\t}\n\n\t_, err = ValidateStruct(test1NotOk)\n\tif err == nil {\n\t\tt.Errorf(\"Test failed: nil\")\n\t}\n\n\ttype Test2 struct {\n\t\tInt   int   `valid:\"in(1|10)\"`\n\t\tInt8  int8  `valid:\"in(1|10)\"`\n\t\tInt16 int16 `valid:\"in(1|10)\"`\n\t\tInt32 int32 `valid:\"in(1|10)\"`\n\t\tInt64 int64 `valid:\"in(1|10)\"`\n\n\t\tUint   uint   `valid:\"in(1|10)\"`\n\t\tUint8  uint8  `valid:\"in(1|10)\"`\n\t\tUint16 uint16 `valid:\"in(1|10)\"`\n\t\tUint32 uint32 `valid:\"in(1|10)\"`\n\t\tUint64 uint64 `valid:\"in(1|10)\"`\n\n\t\tFloat32 float32 `valid:\"in(1|10)\"`\n\t\tFloat64 float64 `valid:\"in(1|10)\"`\n\t}\n\n\ttest2Ok1 := &Test2{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\ttest2Ok2 := &Test2{10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}\n\ttest2NotOk := &Test2{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}\n\n\t_, err = ValidateStruct(test2Ok1)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: %s\", err)\n\t}\n\n\t_, err = ValidateStruct(test2Ok2)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: %s\", err)\n\t}\n\n\t_, err = ValidateStruct(test2NotOk)\n\tif err == nil {\n\t\tt.Errorf(\"Test failed: nil\")\n\t}\n\n\ttype Test3 struct {\n\t\tInt   int   `valid:\"in(1|10),int\"`\n\t\tInt8  int8  `valid:\"in(1|10),int8\"`\n\t\tInt16 int16 `valid:\"in(1|10),int16\"`\n\t\tInt32 int32 `valid:\"in(1|10),int32\"`\n\t\tInt64 int64 `valid:\"in(1|10),int64\"`\n\n\t\tUint   uint   `valid:\"in(1|10),uint\"`\n\t\tUint8  uint8  `valid:\"in(1|10),uint8\"`\n\t\tUint16 uint16 `valid:\"in(1|10),uint16\"`\n\t\tUint32 uint32 `valid:\"in(1|10),uint32\"`\n\t\tUint64 uint64 `valid:\"in(1|10),uint64\"`\n\n\t\tFloat32 float32 `valid:\"in(1|10),float32\"`\n\t\tFloat64 float64 `valid:\"in(1|10),float64\"`\n\t}\n\n\ttest3Ok1 := &Test2{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\ttest3Ok2 := &Test2{10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}\n\ttest3NotOk := &Test2{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}\n\n\t_, err = ValidateStruct(test3Ok1)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: %s\", err)\n\t}\n\n\t_, err = ValidateStruct(test3Ok2)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: %s\", err)\n\t}\n\n\t_, err = ValidateStruct(test3NotOk)\n\tif err == nil {\n\t\tt.Errorf(\"Test failed: nil\")\n\t}\n}\n\nfunc TestValidateStructUpperAndLowerCaseWithNumTypeCheck(t *testing.T) {\n\n\ttype StructCapital struct {\n\t\tTotal float32 `valid:\"float,required\"`\n\t}\n\n\tstructCapital := &StructCapital{53.3535}\n\t_, err := ValidateStruct(structCapital)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: nil\")\n\t\tfmt.Println(err)\n\t}\n\n\ttype StructLower struct {\n\t\ttotal float32 `valid:\"float,required\"`\n\t}\n\n\tstructLower := &StructLower{53.3535}\n\t_, err = ValidateStruct(structLower)\n\tif err != nil {\n\t\tt.Errorf(\"Test failed: nil\")\n\t\tfmt.Println(err)\n\t}\n}\n\nfunc TestIsCIDR(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"193.168.3.20/7\", true},\n\t\t{\"2001:db8::/32\", true},\n\t\t{\"2001:0db8:85a3:0000:0000:8a2e:0370:7334/64\", true},\n\t\t{\"193.138.3.20/60\", false},\n\t\t{\"500.323.2.23/43\", false},\n\t\t{\"\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsCIDR(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsCIDR(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestOptionalCustomValidators(t *testing.T) {\n\n\tCustomTypeTagMap.Set(\"f2\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\t\treturn false\n\t}))\n\n\tvar val struct {\n\t\tWithCustomError    string `valid:\"f2~boom,optional\"`\n\t\tWithoutCustomError string `valid:\"f2,optional\"`\n\t\tOptionalFirst      string `valid:\"optional,f2\"`\n\t}\n\n\tok, err := ValidateStruct(val)\n\n\tif err != nil {\n\t\tt.Errorf(\"Expected nil err with optional validation, got %v\", err)\n\t}\n\n\tif !ok {\n\t\tt.Error(\"Expected validation to return true, got false\")\n\t}\n}\n\nfunc TestJSONValidator(t *testing.T) {\n\n\tvar val struct {\n\t\tWithJSONName      string `json:\"with_json_name\" valid:\"-,required\"`\n\t\tWithoutJSONName   string `valid:\"-,required\"`\n\t\tWithJSONOmit      string `json:\"with_other_json_name,omitempty\" valid:\"-,required\"`\n\t\tWithJSONOption    string `json:\",omitempty\" valid:\"-,required\"`\n\t\tWithEmptyJSONName string `json:\"-\" valid:\"-,required\"`\n\t}\n\n\t_, err := ValidateStruct(val)\n\n\tif err == nil {\n\t\tt.Error(\"Expected error but got no error\")\n\t}\n\n\tif Contains(err.Error(), \"WithJSONName\") {\n\t\tt.Errorf(\"Expected error message to contain with_json_name but actual error is: %s\", err.Error())\n\t}\n\n\tif !Contains(err.Error(), \"WithoutJSONName\") {\n\t\tt.Errorf(\"Expected error message to contain WithoutJSONName but actual error is: %s\", err.Error())\n\t}\n\n\tif Contains(err.Error(), \"omitempty\") {\n\t\tt.Errorf(\"Expected error message to not contain ',omitempty' but actual error is: %s\", err.Error())\n\t}\n\n\tif !Contains(err.Error(), \"WithEmptyJSONName\") {\n\t\tt.Errorf(\"Expected error message to contain WithEmptyJSONName but actual error is: %s\", err.Error())\n\t}\n}\n\nfunc TestValidatorIncludedInError(t *testing.T) {\n\tpost := Post{\n\t\tTitle:    \"\",\n\t\tMessage:  \"👍\",\n\t\tAuthorIP: \"xyz\",\n\t}\n\n\tvalidatorMap := map[string]string{\n\t\t\"Title\":    \"required\",\n\t\t\"Message\":  \"ascii\",\n\t\t\"AuthorIP\": \"ipv4\",\n\t}\n\n\tok, errors := ValidateStruct(post)\n\tif ok {\n\t\tt.Errorf(\"expected validation to fail %v\", ok)\n\t}\n\n\tfor _, e := range errors.(Errors) {\n\t\tcasted := e.(Error)\n\t\tif validatorMap[casted.Name] != casted.Validator {\n\t\t\tt.Errorf(\"expected validator for %s to be %s, but was %s\", casted.Name, validatorMap[casted.Name], casted.Validator)\n\t\t}\n\t}\n\n\t// checks to make sure that validators with arguments (like length(1|10)) don't include the arguments\n\t// in the validator name\n\tmessage := MessageWithSeveralFieldsStruct{\n\t\tTitle: \"\",\n\t\tBody:  \"asdfasdfasdfasdfasdf\",\n\t}\n\n\tvalidatorMap = map[string]string{\n\t\t\"Title\": \"length\",\n\t\t\"Body\":  \"length\",\n\t}\n\n\tok, errors = ValidateStruct(message)\n\tif ok {\n\t\tt.Errorf(\"expected validation to fail, %v\", ok)\n\t}\n\n\tfor _, e := range errors.(Errors) {\n\t\tcasted := e.(Error)\n\t\tif validatorMap[casted.Name] != casted.Validator {\n\t\t\tt.Errorf(\"expected validator for %s to be %s, but was %s\", casted.Name, validatorMap[casted.Name], casted.Validator)\n\t\t}\n\t}\n\n\t// make sure validators with custom messages don't show up in the validator string\n\ttype CustomMessage struct {\n\t\tText string `valid:\"length(1|10)~Custom message\"`\n\t}\n\tcs := CustomMessage{Text: \"asdfasdfasdfasdf\"}\n\n\tok, errors = ValidateStruct(&cs)\n\tif ok {\n\t\tt.Errorf(\"expected validation to fail, %v\", ok)\n\t}\n\n\tvalidator := errors.(Errors)[0].(Error).Validator\n\tif validator != \"length\" {\n\t\tt.Errorf(\"expected validator for Text to be length, but was %s\", validator)\n\t}\n\n}\n\nfunc TestIsRsaPublicKey(t *testing.T) {\n\tvar tests = []struct {\n\t\trsastr   string\n\t\tkeylen   int\n\t\texpected bool\n\t}{\n\t\t{`fubar`, 2048, false},\n\t\t{`MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvncDCeibmEkabJLmFec7x9y86RP6dIvkVxxbQoOJo06E+p7tH6vCmiGHKnuu\nXwKYLq0DKUE3t/HHsNdowfD9+NH8caLzmXqGBx45/Dzxnwqz0qYq7idK+Qff34qrk/YFoU7498U1Ee7PkKb7/VE9BmMEcI3uoKbeXCbJRI\nHoTp8bUXOpNTSUfwUNwJzbm2nsHo2xu6virKtAZLTsJFzTUmRd11MrWCvj59lWzt1/eIMN+ekjH8aXeLOOl54CL+kWp48C+V9BchyKCShZ\nB7ucimFvjHTtuxziXZQRO7HlcsBOa0WwvDJnRnskdyoD31s4F4jpKEYBJNWTo63v6lUvbQIDAQAB`, 2048, true},\n\t\t{`MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvncDCeibmEkabJLmFec7x9y86RP6dIvkVxxbQoOJo06E+p7tH6vCmiGHKnuu\nXwKYLq0DKUE3t/HHsNdowfD9+NH8caLzmXqGBx45/Dzxnwqz0qYq7idK+Qff34qrk/YFoU7498U1Ee7PkKb7/VE9BmMEcI3uoKbeXCbJRI\nHoTp8bUXOpNTSUfwUNwJzbm2nsHo2xu6virKtAZLTsJFzTUmRd11MrWCvj59lWzt1/eIMN+ekjH8aXeLOOl54CL+kWp48C+V9BchyKCShZ\nB7ucimFvjHTtuxziXZQRO7HlcsBOa0WwvDJnRnskdyoD31s4F4jpKEYBJNWTo63v6lUvbQIDAQAB`, 1024, false},\n\t\t{`-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvncDCeibmEkabJLmFec7\nx9y86RP6dIvkVxxbQoOJo06E+p7tH6vCmiGHKnuuXwKYLq0DKUE3t/HHsNdowfD9\n+NH8caLzmXqGBx45/Dzxnwqz0qYq7idK+Qff34qrk/YFoU7498U1Ee7PkKb7/VE9\nBmMEcI3uoKbeXCbJRIHoTp8bUXOpNTSUfwUNwJzbm2nsHo2xu6virKtAZLTsJFzT\nUmRd11MrWCvj59lWzt1/eIMN+ekjH8aXeLOOl54CL+kWp48C+V9BchyKCShZB7uc\nimFvjHTtuxziXZQRO7HlcsBOa0WwvDJnRnskdyoD31s4F4jpKEYBJNWTo63v6lUv\nbQIDAQAB\n-----END PUBLIC KEY-----`, 2048, true},\n\t\t{`-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvncDCeibmEkabJLmFec7\nx9y86RP6dIvkVxxbQoOJo06E+p7tH6vCmiGHKnuuXwKYLq0DKUE3t/HHsNdowfD9\n+NH8caLzmXqGBx45/Dzxnwqz0qYq7idK+Qff34qrk/YFoU7498U1Ee7PkKb7/VE9\nBmMEcI3uoKbeXCbJRIHoTp8bUXOpNTSUfwUNwJzbm2nsHo2xu6virKtAZLTsJFzT\nUmRd11MrWCvj59lWzt1/eIMN+ekjH8aXeLOOl54CL+kWp48C+V9BchyKCShZB7uc\nimFvjHTtuxziXZQRO7HlcsBOa0WwvDJnRnskdyoD31s4F4jpKEYBJNWTo63v6lUv\nbQIDAQAB\n-----END PUBLIC KEY-----`, 4096, false},\n\t}\n\tfor i, test := range tests {\n\t\tactual := IsRsaPublicKey(test.rsastr, test.keylen)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected TestIsRsaPublicKey(%d, %d) to be %v, got %v\", i, test.keylen, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsRegex(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"^$\", true},\n\t\t{\"$^\", true},\n\t\t{\"^^\", true},\n\t\t{\"$$\", true},\n\t\t{\"a+\", true},\n\t\t{\"a++\", false},\n\t\t{\"a*\", true},\n\t\t{\"a**\", false},\n\t\t{\"a+*\", false},\n\t\t{\"a*+\", false},\n\t\t{\"[a+]+\", true},\n\t\t{\"\\\\w+\", true},\n\t\t{\"\\\\y+\", false},\n\t\t{\"[asdf][qwer]\", true},\n\t\t{\"[asdf[\", false},\n\t\t{\"[asdf[]\", true},\n\t\t{\"[asdf[][]\", false},\n\t\t{\"(group2)(group3)\", true},\n\t\t{\"(invalid_paranthesis(asdf)\", false},\n\t\t{\"a?\", true},\n\t\t{\"a??\", true},\n\t\t{\"a???\", false},\n\t\t{\"a\\\\???\", true},\n\t\t{\"asdf\\\\/\", true},\n\t\t{\"asdf/\", true},\n\t\t{\"\\\\x61\", true},\n\t\t{\"\\\\xg1\", false},\n\t\t{\"\\\\x6h\", false},\n\t\t{\"[asdf[\", false},\n\t\t{\"[A-z]+\", true},\n\t\t{\"[z-A]+\", false},\n\t\t{\"[a-z-A]\", true},\n\t\t{\"a{3,6}\", true},\n\t\t{\"a{6,3|3,6}\", true},\n\t\t{\"a{6,3}\", false},\n\t\t{\"a|b\", true},\n\t\t{\"a|b|\", true},\n\t\t{\"a|b||\", true}, //But false in python RE\n\t\t{\"(?:)\", true},\n\t\t{\"(?)\", true}, //But false in python RE\n\t\t{\"?\", false},\n\t\t{\"(?::?)\", true},\n\t\t{\"(?:?)\", false},\n\t\t{\"(()?)\", true},\n\t\t{\"(?:?)\", false},\n\t\t{\"(A conditional matching)? (?(1)matched|not matched)\", false}, //But true in python RE\n\t\t{\"(A conditional matching)? (?(2)matched|not matched)\", false},\n\t\t{\"(?:A conditional matching)? (?(1)matched|not matched)\", false},\n\t\t{\"(?:[a-z]+)?\", true},\n\t\t{\"(?#[a-z]+)?\", false},\n\t\t{\"(?P<name>[a-z]+)\", true},\n\t\t{\"(?P<name<>>[a-z]+)\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsRegex(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsNumeric(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsIMSI(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"234150999999999\", true},\n\t\t{\"429011234567890\", true},\n\t\t{\"310150123456789\", true},\n\t\t{\"460001234567890\", true},\n\t\t{\"4600012345678\", false},\n\t\t{\"4600012345678901\", false},\n\t\t{\"462001234567890\", false},\n\t\t{\"1\", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsIMSI(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsIMSI(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestIsE164(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"+14155552671\", true},\n\t\t{\"+442071838750\", true},\n\t\t{\"+551155256325\", true},\n\t\t{\"+226071234567 \", false},\n\t\t{\"+06071234567 \", false},\n\t}\n\tfor _, test := range tests {\n\t\tactual := IsE164(test.param)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected IsURL(%q) to be %v, got %v\", test.param, test.expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "wercker.yml",
          "type": "blob",
          "size": 0.232421875,
          "content": "box: golang\nbuild:\n  steps:\n    - setup-go-workspace\n\n    - script:\n        name: go get\n        code: |\n          go version\n          go get -t ./...\n\n    - script:\n        name: go test\n        code: |\n          go test -race -v ./...\n"
        }
      ]
    }
  ]
}