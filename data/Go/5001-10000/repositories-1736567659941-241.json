{
  "metadata": {
    "timestamp": 1736567659941,
    "page": 241,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yuin/gopher-lua",
      "stars": 6380,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": ".idea\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Yusuke Inuzuka\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2353515625,
          "content": ".PHONY: build test glua\n\nbuild:\n\t./_tools/go-inline *.go && go fmt . &&  go build\n\nglua: *.go pm/*.go cmd/glua/glua.go\n\t./_tools/go-inline *.go && go fmt . && go build cmd/glua/glua.go\n\ntest:\n\t./_tools/go-inline *.go && go fmt . &&  go test\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 29.056640625,
          "content": "\n===============================================================================\nGopherLua: VM and compiler for Lua in Go.\n===============================================================================\n\n.. image:: https://pkg.go.dev/badge/github.com/yuin/gopher-lua.svg\n    :target: https://pkg.go.dev/github.com/yuin/gopher-lua\n\n.. image:: https://github.com/yuin/gopher-lua/workflows/test/badge.svg?branch=master&event=push\n    :target: https://github.com/yuin/gopher-lua/actions?query=workflow:test\n\n.. image:: https://coveralls.io/repos/github/yuin/gopher-lua/badge.svg?branch=master\n    :target: https://coveralls.io/github/yuin/gopher-lua\n\n.. image:: https://badges.gitter.im/Join%20Chat.svg\n    :alt: Join the chat at https://gitter.im/yuin/gopher-lua\n    :target: https://gitter.im/yuin/gopher-lua?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n\n|\n\n\nGopherLua is a Lua5.1(+ `goto` statement in Lua5.2) VM and compiler written in Go. GopherLua has a same goal\nwith Lua: **Be a scripting language with extensible semantics** . It provides\nGo APIs that allow you to easily embed a scripting language to your Go host\nprograms.\n\n.. contents::\n   :depth: 1\n\n----------------------------------------------------------------\nDesign principle\n----------------------------------------------------------------\n\n- Be a scripting language with extensible semantics.\n- User-friendly Go API\n    - The stack based API like the one used in the original Lua\n      implementation will cause a performance improvements in GopherLua\n      (It will reduce memory allocations and concrete type <-> interface conversions).\n      GopherLua API is **not** the stack based API.\n      GopherLua give preference to the user-friendliness over the performance.\n\n----------------------------------------------------------------\nHow about performance?\n----------------------------------------------------------------\nGopherLua is not fast but not too slow, I think.\n\nGopherLua has almost equivalent ( or little bit better ) performance as Python3 on micro benchmarks.\n\nThere are some benchmarks on the `wiki page <https://github.com/yuin/gopher-lua/wiki/Benchmarks>`_ .\n\n----------------------------------------------------------------\nInstallation\n----------------------------------------------------------------\n\n.. code-block:: bash\n\n   go get github.com/yuin/gopher-lua\n\nGopherLua supports >= Go1.9.\n\n----------------------------------------------------------------\nUsage\n----------------------------------------------------------------\nGopherLua APIs perform in much the same way as Lua, **but the stack is used only\nfor passing arguments and receiving returned values.**\n\nGopherLua supports channel operations. See **\"Goroutines\"** section.\n\nImport a package.\n\n.. code-block:: go\n\n   import (\n       \"github.com/yuin/gopher-lua\"\n   )\n\nRun scripts in the VM.\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoString(`print(\"hello\")`); err != nil {\n       panic(err)\n   }\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoFile(\"hello.lua\"); err != nil {\n       panic(err)\n   }\n\nRefer to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ and `Go doc <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\nNote that elements that are not commented in `Go doc <http://godoc.org/github.com/yuin/gopher-lua>`_ equivalent to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ , except GopherLua uses objects instead of Lua stack indices.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nData model\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAll data in a GopherLua program is an ``LValue`` . ``LValue`` is an interface\ntype that has following methods.\n\n- ``String() string``\n- ``Type() LValueType``\n\n\nObjects implement an LValue interface are\n\n================ ========================= ================== =======================\n Type name        Go type                   Type() value       Constants\n================ ========================= ================== =======================\n ``LNilType``      (constants)              ``LTNil``          ``LNil``\n ``LBool``         (constants)              ``LTBool``         ``LTrue``, ``LFalse``\n ``LNumber``        float64                 ``LTNumber``       ``-``\n ``LString``        string                  ``LTString``       ``-``\n ``LFunction``      struct pointer          ``LTFunction``     ``-``\n ``LUserData``      struct pointer          ``LTUserData``     ``-``\n ``LState``         struct pointer          ``LTThread``       ``-``\n ``LTable``         struct pointer          ``LTTable``        ``-``\n ``LChannel``       chan LValue             ``LTChannel``      ``-``\n================ ========================= ================== =======================\n\nYou can test an object type in Go way(type assertion) or using a ``Type()`` value.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if str, ok := lv.(lua.LString); ok {\n       // lv is LString\n       fmt.Println(string(str))\n   }\n   if lv.Type() != lua.LTString {\n       panic(\"string required.\")\n   }\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if tbl, ok := lv.(*lua.LTable); ok {\n       // lv is LTable\n       fmt.Println(L.ObjLen(tbl))\n   }\n\nNote that ``LBool`` , ``LNumber`` , ``LString`` is not a pointer.\n\nTo test ``LNilType`` and ``LBool``, You **must** use pre-defined constants.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n\n   if lv == lua.LTrue { // correct\n   }\n\n   if bl, ok := lv.(lua.LBool); ok && bool(bl) { // wrong\n   }\n\nIn Lua, both ``nil`` and ``false`` make a condition false. ``LVIsFalse`` and ``LVAsBool`` implement this specification.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if lua.LVIsFalse(lv) { // lv is nil or false\n   }\n\n   if lua.LVAsBool(lv) { // lv is neither nil nor false\n   }\n\nObjects that based on go structs(``LFunction``. ``LUserData``, ``LTable``)\nhave some public methods and fields. You can use these methods and fields for\nperformance and debugging, but there are some limitations.\n\n- Metatable does not work.\n- No error handlings.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCallstack & Registry size\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThe size of an ``LState``'s callstack controls the maximum call depth for Lua functions within a script (Go function calls do not count).\n\nThe registry of an ``LState`` implements stack storage for calling functions (both Lua and Go functions) and also for temporary variables in expressions. Its storage requirements will increase with callstack usage and also with code complexity.\n\nBoth the registry and the callstack can be set to either a fixed size or to auto size.\n\nWhen you have a large number of ``LStates`` instantiated in a process, it's worth taking the time to tune the registry and callstack options.\n\n+++++++++\nRegistry\n+++++++++\n\nThe registry can have an initial size, a maximum size and a step size configured on a per ``LState`` basis. This will allow the registry to grow as needed. It will not shrink again after growing.\n\n.. code-block:: go\n\n    L := lua.NewState(lua.Options{\n       RegistrySize: 1024 * 20,         // this is the initial size of the registry\n       RegistryMaxSize: 1024 * 80,      // this is the maximum size that the registry can grow to. If set to `0` (the default) then the registry will not auto grow\n       RegistryGrowStep: 32,            // this is how much to step up the registry by each time it runs out of space. The default is `32`.\n    })\n   defer L.Close()\n\nA registry which is too small for a given script will ultimately result in a panic. A registry which is too big will waste memory (which can be significant if many ``LStates`` are instantiated).\nAuto growing registries incur a small performance hit at the point they are resized but will not otherwise affect performance.\n\n+++++++++\nCallstack\n+++++++++\n\nThe callstack can operate in two different modes, fixed or auto size.\nA fixed size callstack has the highest performance and has a fixed memory overhead.\nAn auto sizing callstack will allocate and release callstack pages on demand which will ensure the minimum amount of memory is in use at any time. The downside is it will incur a small performance impact every time a new page of callframes is allocated.\nBy default an ``LState`` will allocate and free callstack frames in pages of 8, so the allocation overhead is not incurred on every function call. It is very likely that the performance impact of an auto resizing callstack will be negligible for most use cases.\n\n.. code-block:: go\n\n    L := lua.NewState(lua.Options{\n        CallStackSize: 120,                 // this is the maximum callstack size of this LState\n        MinimizeStackMemory: true,          // Defaults to `false` if not specified. If set, the callstack will auto grow and shrink as needed up to a max of `CallStackSize`. If not set, the callstack will be fixed at `CallStackSize`.\n    })\n   defer L.Close()\n\n++++++++++++++++\nOption defaults\n++++++++++++++++\n\nThe above examples show how to customize the callstack and registry size on a per ``LState`` basis. You can also adjust some defaults for when options are not specified by altering the values of ``lua.RegistrySize``, ``lua.RegistryGrowStep`` and ``lua.CallStackSize``.\n\nAn ``LState`` object that has been created by ``*LState#NewThread()`` inherits the callstack & registry size from the parent ``LState`` object.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nMiscellaneous lua.NewState options\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n- **Options.SkipOpenLibs bool(default false)**\n    - By default, GopherLua opens all built-in libraries when new LState is created.\n    - You can skip this behaviour by setting this to ``true`` .\n    - Using the various `OpenXXX(L *LState) int` functions you can open only those libraries that you require, for an example see below.\n- **Options.IncludeGoStackTrace bool(default false)**\n    - By default, GopherLua does not show Go stack traces when panics occur.\n    - You can get Go stack traces by setting this to ``true`` .\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAPI\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRefer to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ and `Go doc(LState methods) <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\n+++++++++++++++++++++++++++++++++++++++++\nCalling Go from Lua\n+++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: go\n\n   func Double(L *lua.LState) int {\n       lv := L.ToInt(1)             /* get argument */\n       L.Push(lua.LNumber(lv * 2)) /* push result */\n       return 1                     /* number of results */\n   }\n\n   func main() {\n       L := lua.NewState()\n       defer L.Close()\n       L.SetGlobal(\"double\", L.NewFunction(Double)) /* Original lua_setglobal uses stack... */\n   }\n\n.. code-block:: lua\n\n   print(double(20)) -- > \"40\"\n\nAny function registered with GopherLua is a ``lua.LGFunction``, defined in ``value.go``\n\n.. code-block:: go\n\n   type LGFunction func(*LState) int\n\nWorking with coroutines.\n\n.. code-block:: go\n\n   co, _ := L.NewThread() /* create a new thread */\n   fn := L.GetGlobal(\"coro\").(*lua.LFunction) /* get function from lua */\n   for {\n       st, err, values := L.Resume(co, fn)\n       if st == lua.ResumeError {\n           fmt.Println(\"yield break(error)\")\n           fmt.Println(err.Error())\n           break\n       }\n\n       for i, lv := range values {\n           fmt.Printf(\"%v : %v\\n\", i, lv)\n       }\n\n       if st == lua.ResumeOK {\n           fmt.Println(\"yield break(ok)\")\n           break\n       }\n   }\n\n+++++++++++++++++++++++++++++++++++++++++\nOpening a subset of builtin modules\n+++++++++++++++++++++++++++++++++++++++++\n\nThe following demonstrates how to open a subset of the built-in modules in Lua, say for example to avoid enabling modules with access to local files or system calls.\n\nmain.go\n\n.. code-block:: go\n\n    func main() {\n        L := lua.NewState(lua.Options{SkipOpenLibs: true})\n        defer L.Close()\n        for _, pair := range []struct {\n            n string\n            f lua.LGFunction\n        }{\n            {lua.LoadLibName, lua.OpenPackage}, // Must be first\n            {lua.BaseLibName, lua.OpenBase},\n            {lua.TabLibName, lua.OpenTable},\n        } {\n            if err := L.CallByParam(lua.P{\n                Fn:      L.NewFunction(pair.f),\n                NRet:    0,\n                Protect: true,\n            }, lua.LString(pair.n)); err != nil {\n                panic(err)\n            }\n        }\n        if err := L.DoFile(\"main.lua\"); err != nil {\n            panic(err)\n        }\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nCreating a module by Go\n+++++++++++++++++++++++++++++++++++++++++\n\nmymodule.go\n\n.. code-block:: go\n\n    package mymodule\n\n    import (\n        \"github.com/yuin/gopher-lua\"\n    )\n\n    func Loader(L *lua.LState) int {\n        // register functions to the table\n        mod := L.SetFuncs(L.NewTable(), exports)\n        // register other stuff\n        L.SetField(mod, \"name\", lua.LString(\"value\"))\n\n        // returns the module\n        L.Push(mod)\n        return 1\n    }\n\n    var exports = map[string]lua.LGFunction{\n        \"myfunc\": myfunc,\n    }\n\n    func myfunc(L *lua.LState) int {\n        return 0\n    }\n\nmymain.go\n\n.. code-block:: go\n\n    package main\n\n    import (\n        \"./mymodule\"\n        \"github.com/yuin/gopher-lua\"\n    )\n\n    func main() {\n        L := lua.NewState()\n        defer L.Close()\n        L.PreloadModule(\"mymodule\", mymodule.Loader)\n        if err := L.DoFile(\"main.lua\"); err != nil {\n            panic(err)\n        }\n    }\n\nmain.lua\n\n.. code-block:: lua\n\n    local m = require(\"mymodule\")\n    m.myfunc()\n    print(m.name)\n\n\n+++++++++++++++++++++++++++++++++++++++++\nCalling Lua from Go\n+++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoFile(\"double.lua\"); err != nil {\n       panic(err)\n   }\n   if err := L.CallByParam(lua.P{\n       Fn: L.GetGlobal(\"double\"),\n       NRet: 1,\n       Protect: true,\n       }, lua.LNumber(10)); err != nil {\n       panic(err)\n   }\n   ret := L.Get(-1) // returned value\n   L.Pop(1)  // remove received value\n\nIf ``Protect`` is false, GopherLua will panic instead of returning an ``error`` value.\n\n+++++++++++++++++++++++++++++++++++++++++\nUser-Defined types\n+++++++++++++++++++++++++++++++++++++++++\nYou can extend GopherLua with new types written in Go.\n``LUserData`` is provided for this purpose.\n\n.. code-block:: go\n\n    type Person struct {\n        Name string\n    }\n\n    const luaPersonTypeName = \"person\"\n\n    // Registers my person type to given L.\n    func registerPersonType(L *lua.LState) {\n        mt := L.NewTypeMetatable(luaPersonTypeName)\n        L.SetGlobal(\"person\", mt)\n        // static attributes\n        L.SetField(mt, \"new\", L.NewFunction(newPerson))\n        // methods\n        L.SetField(mt, \"__index\", L.SetFuncs(L.NewTable(), personMethods))\n    }\n\n    // Constructor\n    func newPerson(L *lua.LState) int {\n        person := &Person{L.CheckString(1)}\n        ud := L.NewUserData()\n        ud.Value = person\n        L.SetMetatable(ud, L.GetTypeMetatable(luaPersonTypeName))\n        L.Push(ud)\n        return 1\n    }\n\n    // Checks whether the first lua argument is a *LUserData with *Person and returns this *Person.\n    func checkPerson(L *lua.LState) *Person {\n        ud := L.CheckUserData(1)\n        if v, ok := ud.Value.(*Person); ok {\n            return v\n        }\n        L.ArgError(1, \"person expected\")\n        return nil\n    }\n\n    var personMethods = map[string]lua.LGFunction{\n        \"name\": personGetSetName,\n    }\n\n    // Getter and setter for the Person#Name\n    func personGetSetName(L *lua.LState) int {\n        p := checkPerson(L)\n        if L.GetTop() == 2 {\n            p.Name = L.CheckString(2)\n            return 0\n        }\n        L.Push(lua.LString(p.Name))\n        return 1\n    }\n\n    func main() {\n        L := lua.NewState()\n        defer L.Close()\n        registerPersonType(L)\n        if err := L.DoString(`\n            p = person.new(\"Steeve\")\n            print(p:name()) -- \"Steeve\"\n            p:name(\"Alice\")\n            print(p:name()) -- \"Alice\"\n        `); err != nil {\n            panic(err)\n        }\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nTerminating a running LState\n+++++++++++++++++++++++++++++++++++++++++\nGopherLua supports the `Go Concurrency Patterns: Context <https://blog.golang.org/context>`_ .\n\n\n.. code-block:: go\n\n    L := lua.NewState()\n    defer L.Close()\n    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n    defer cancel()\n    // set the context to our LState\n    L.SetContext(ctx)\n    err := L.DoString(`\n      local clock = os.clock\n      function sleep(n)  -- seconds\n        local t0 = clock()\n        while clock() - t0 <= n do end\n      end\n      sleep(3)\n    `)\n    // err.Error() contains \"context deadline exceeded\"\n\nWith coroutines\n\n.. code-block:: go\n\n\tL := lua.NewState()\n\tdefer L.Close()\n\tctx, cancel := context.WithCancel(context.Background())\n\tL.SetContext(ctx)\n\tdefer cancel()\n\tL.DoString(`\n\t    function coro()\n\t\t  local i = 0\n\t\t  while true do\n\t\t    coroutine.yield(i)\n\t\t\ti = i+1\n\t\t  end\n\t\t  return i\n\t    end\n\t`)\n\tco, cocancel := L.NewThread()\n\tdefer cocancel()\n\tfn := L.GetGlobal(\"coro\").(*LFunction)\n\n\t_, err, values := L.Resume(co, fn) // err is nil\n\n\tcancel() // cancel the parent context\n\n\t_, err, values = L.Resume(co, fn) // err is NOT nil : child context was canceled\n\n**Note that using a context causes performance degradation.**\n\n.. code-block::\n\n    time ./glua-with-context.exe fib.lua\n    9227465\n    0.01s user 0.11s system 1% cpu 7.505 total\n\n    time ./glua-without-context.exe fib.lua\n    9227465\n    0.01s user 0.01s system 0% cpu 5.306 total\n\n+++++++++++++++++++++++++++++++++++++++++\nSharing Lua byte code between LStates\n+++++++++++++++++++++++++++++++++++++++++\nCalling ``DoFile`` will load a Lua script, compile it to byte code and run the byte code in a ``LState``.\n\nIf you have multiple ``LStates`` which are all required to run the same script, you can share the byte code between them,\nwhich will save on memory.\nSharing byte code is safe as it is read only and cannot be altered by lua scripts.\n\n.. code-block:: go\n\n    // CompileLua reads the passed lua file from disk and compiles it.\n    func CompileLua(filePath string) (*lua.FunctionProto, error) {\n        file, err := os.Open(filePath)\n        defer file.Close()\n        if err != nil {\n            return nil, err\n        }\n        reader := bufio.NewReader(file)\n        chunk, err := parse.Parse(reader, filePath)\n        if err != nil {\n            return nil, err\n        }\n        proto, err := lua.Compile(chunk, filePath)\n        if err != nil {\n            return nil, err\n        }\n        return proto, nil\n    }\n\n    // DoCompiledFile takes a FunctionProto, as returned by CompileLua, and runs it in the LState. It is equivalent\n    // to calling DoFile on the LState with the original source file.\n    func DoCompiledFile(L *lua.LState, proto *lua.FunctionProto) error {\n        lfunc := L.NewFunctionFromProto(proto)\n        L.Push(lfunc)\n        return L.PCall(0, lua.MultRet, nil)\n    }\n\n    // Example shows how to share the compiled byte code from a lua script between multiple VMs.\n    func Example() {\n        codeToShare, err := CompileLua(\"mylua.lua\")\n        if err != nil {\n            panic(err)\n        }\n        a := lua.NewState()\n        b := lua.NewState()\n        c := lua.NewState()\n        DoCompiledFile(a, codeToShare)\n        DoCompiledFile(b, codeToShare)\n        DoCompiledFile(c, codeToShare)\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nGoroutines\n+++++++++++++++++++++++++++++++++++++++++\nThe ``LState`` is not goroutine-safe. It is recommended to use one LState per goroutine and communicate between goroutines by using channels.\n\nChannels are represented by ``channel`` objects in GopherLua. And a ``channel`` table provides functions for performing channel operations.\n\nSome objects can not be sent over channels due to having non-goroutine-safe objects inside itself.\n\n- a thread(state)\n- a function\n- an userdata\n- a table with a metatable\n\nYou **must not** send these objects from Go APIs to channels.\n\n\n\n.. code-block:: go\n\n    func receiver(ch, quit chan lua.LValue) {\n        L := lua.NewState()\n        defer L.Close()\n        L.SetGlobal(\"ch\", lua.LChannel(ch))\n        L.SetGlobal(\"quit\", lua.LChannel(quit))\n        if err := L.DoString(`\n        local exit = false\n        while not exit do\n          channel.select(\n            {\"|<-\", ch, function(ok, v)\n              if not ok then\n                print(\"channel closed\")\n                exit = true\n              else\n                print(\"received:\", v)\n              end\n            end},\n            {\"|<-\", quit, function(ok, v)\n                print(\"quit\")\n                exit = true\n            end}\n          )\n        end\n      `); err != nil {\n            panic(err)\n        }\n    }\n\n    func sender(ch, quit chan lua.LValue) {\n        L := lua.NewState()\n        defer L.Close()\n        L.SetGlobal(\"ch\", lua.LChannel(ch))\n        L.SetGlobal(\"quit\", lua.LChannel(quit))\n        if err := L.DoString(`\n        ch:send(\"1\")\n        ch:send(\"2\")\n      `); err != nil {\n            panic(err)\n        }\n        ch <- lua.LString(\"3\")\n        quit <- lua.LTrue\n    }\n\n    func main() {\n        ch := make(chan lua.LValue)\n        quit := make(chan lua.LValue)\n        go receiver(ch, quit)\n        go sender(ch, quit)\n        time.Sleep(3 * time.Second)\n    }\n\n'''''''''''''''\nGo API\n'''''''''''''''\n\n``ToChannel``, ``CheckChannel``, ``OptChannel`` are available.\n\nRefer to `Go doc(LState methods) <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\n'''''''''''''''\nLua API\n'''''''''''''''\n\n- **channel.make([buf:int]) -> ch:channel**\n    - Create new channel that has a buffer size of ``buf``. By default, ``buf`` is 0.\n\n- **channel.select(case:table [, case:table, case:table ...]) -> {index:int, recv:any, ok}**\n    - Same as the ``select`` statement in Go. It returns the index of the chosen case and, if that\n      case was a receive operation, the value received and a boolean indicating whether the channel has been closed.\n    - ``case`` is a table that outlined below.\n        - receiving: `{\"|<-\", ch:channel [, handler:func(ok, data:any)]}`\n        - sending: `{\"<-|\", ch:channel, data:any [, handler:func(data:any)]}`\n        - default: `{\"default\" [, handler:func()]}`\n\n``channel.select`` examples:\n\n.. code-block:: lua\n\n    local idx, recv, ok = channel.select(\n      {\"|<-\", ch1},\n      {\"|<-\", ch2}\n    )\n    if not ok then\n        print(\"closed\")\n    elseif idx == 1 then -- received from ch1\n        print(recv)\n    elseif idx == 2 then -- received from ch2\n        print(recv)\n    end\n\n.. code-block:: lua\n\n    channel.select(\n      {\"|<-\", ch1, function(ok, data)\n        print(ok, data)\n      end},\n      {\"<-|\", ch2, \"value\", function(data)\n        print(data)\n      end},\n      {\"default\", function()\n        print(\"default action\")\n      end}\n    )\n\n- **channel:send(data:any)**\n    - Send ``data`` over the channel.\n- **channel:receive() -> ok:bool, data:any**\n    - Receive some data over the channel.\n- **channel:close()**\n    - Close the channel.\n\n''''''''''''''''''''''''''''''\nThe LState pool pattern\n''''''''''''''''''''''''''''''\nTo create per-thread LState instances, You can use the ``sync.Pool`` like mechanism.\n\n.. code-block:: go\n\n    type lStatePool struct {\n        m     sync.Mutex\n        saved []*lua.LState\n    }\n\n    func (pl *lStatePool) Get() *lua.LState {\n        pl.m.Lock()\n        defer pl.m.Unlock()\n        n := len(pl.saved)\n        if n == 0 {\n            return pl.New()\n        }\n        x := pl.saved[n-1]\n        pl.saved = pl.saved[0 : n-1]\n        return x\n    }\n\n    func (pl *lStatePool) New() *lua.LState {\n        L := lua.NewState()\n        // setting the L up here.\n        // load scripts, set global variables, share channels, etc...\n        return L\n    }\n\n    func (pl *lStatePool) Put(L *lua.LState) {\n        pl.m.Lock()\n        defer pl.m.Unlock()\n        pl.saved = append(pl.saved, L)\n    }\n\n    func (pl *lStatePool) Shutdown() {\n        for _, L := range pl.saved {\n            L.Close()\n        }\n    }\n\n    // Global LState pool\n    var luaPool = &lStatePool{\n        saved: make([]*lua.LState, 0, 4),\n    }\n\nNow, you can get per-thread LState objects from the ``luaPool`` .\n\n.. code-block:: go\n\n    func MyWorker() {\n       L := luaPool.Get()\n       defer luaPool.Put(L)\n       /* your code here */\n    }\n\n    func main() {\n        defer luaPool.Shutdown()\n        go MyWorker()\n        go MyWorker()\n        /* etc... */\n    }\n\n\n----------------------------------------------------------------\nDifferences between Lua and GopherLua\n----------------------------------------------------------------\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nGoroutines\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- GopherLua supports channel operations.\n    - GopherLua has a type named ``channel``.\n    - The ``channel`` table provides functions for performing channel operations.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUnsupported functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``string.dump``\n- ``os.setlocale``\n- ``lua_Debug.namewhat``\n- ``package.loadlib``\n- debug hooks\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nMiscellaneous notes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``collectgarbage`` does not take any arguments and runs the garbage collector for the entire Go program.\n- ``file:setvbuf`` does not support a line buffering.\n- Daylight saving time is not supported.\n- GopherLua has a function to set an environment variable : ``os.setenv(name, value)``\n- GopherLua support ``goto`` and ``::label::`` statement in Lua5.2.\n    - `goto` is a keyword and not a valid variable name.\n\n----------------------------------------------------------------\nStandalone interpreter\n----------------------------------------------------------------\nLua has an interpreter called ``lua`` . GopherLua has an interpreter called ``glua`` .\n\n.. code-block:: bash\n\n   go get github.com/yuin/gopher-lua/cmd/glua\n\n``glua`` has same options as ``lua`` .\n\n----------------------------------------------------------------\nHow to Contribute\n----------------------------------------------------------------\nSee `Guidelines for contributors <https://github.com/yuin/gopher-lua/tree/master/.github/CONTRIBUTING.md>`_ .\n\n----------------------------------------------------------------\nLibraries for GopherLua\n----------------------------------------------------------------\n\n- `gopher-luar <https://github.com/layeh/gopher-luar>`_ : Simplifies data passing to and from gopher-lua\n- `gluamapper <https://github.com/yuin/gluamapper>`_ : Mapping a Lua table to a Go struct\n- `gluare <https://github.com/yuin/gluare>`_ : Regular expressions for gopher-lua\n- `gluahttp <https://github.com/cjoudrey/gluahttp>`_ : HTTP request module for gopher-lua\n- `gopher-json <https://github.com/layeh/gopher-json>`_ : A simple JSON encoder/decoder for gopher-lua\n- `gluayaml <https://github.com/kohkimakimoto/gluayaml>`_ : Yaml parser for gopher-lua\n- `glua-lfs <https://github.com/layeh/gopher-lfs>`_ : Partially implements the luafilesystem module for gopher-lua\n- `gluaurl <https://github.com/cjoudrey/gluaurl>`_ : A url parser/builder module for gopher-lua\n- `gluahttpscrape <https://github.com/felipejfc/gluahttpscrape>`_ : A simple HTML scraper module for gopher-lua\n- `gluaxmlpath <https://github.com/ailncode/gluaxmlpath>`_ : An xmlpath module for gopher-lua\n- `gmoonscript <https://github.com/rucuriousyet/gmoonscript>`_ : Moonscript Compiler for the Gopher Lua VM\n- `loguago <https://github.com/rucuriousyet/loguago>`_ : Zerolog wrapper for Gopher-Lua\n- `gluabit32 <https://github.com/PeerDB-io/gluabit32>`_ : [Port of Lua 5.2 bit32](https://www.lua.org/manual/5.2/manual.html#6.7)\n- `gluacrypto <https://github.com/tengattack/gluacrypto>`_ : A native Go implementation of crypto library for the GopherLua VM.\n- `gluasql <https://github.com/tengattack/gluasql>`_ : A native Go implementation of SQL client for the GopherLua VM.\n- `purr <https://github.com/leyafo/purr>`_ : A http mock testing tool.\n- `vadv/gopher-lua-libs <https://github.com/vadv/gopher-lua-libs>`_ : Some usefull libraries for GopherLua VM.\n- `gluasocket <https://gitlab.com/megalithic-llc/gluasocket>`_ : A native Go implementation of LuaSocket for the GopherLua VM.\n- `glua-async <https://github.com/CuberL/glua-async>`_ : An async/await implement for gopher-lua.\n- `gopherlua-debugger <https://github.com/edolphin-ydf/gopherlua-debugger>`_ : A debugger for gopher-lua\n- `gluamahonia <https://github.com/super1207/gluamahonia>`_ : An encoding converter for gopher-lua\n- `awesome-gopher-lua <https://github.com/Root-lee/awesome-gopher-lua>`_ : Collections of awesome libraries for GopherLua.\n\n----------------------------------------------------------------\nDonation\n----------------------------------------------------------------\n\nBTC: 1NEDSyUmo4SMTDP83JJQSWi1MvQUGGNMZB\n\n----------------------------------------------------------------\nLicense\n----------------------------------------------------------------\nMIT\n\n----------------------------------------------------------------\nAuthor\n----------------------------------------------------------------\nYusuke Inuzuka\n"
        },
        {
          "name": "_glua-tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "_lua5.1-tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "_state.go",
          "type": "blob",
          "size": 46.8955078125,
          "content": "package lua\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/yuin/gopher-lua/parse\"\n)\n\nconst MultRet = -1\nconst RegistryIndex = -10000\nconst EnvironIndex = -10001\nconst GlobalsIndex = -10002\n\n/* ApiError {{{ */\n\ntype ApiError struct {\n\tType       ApiErrorType\n\tObject     LValue\n\tStackTrace string\n\t// Underlying error. This attribute is set only if the Type is ApiErrorFile or ApiErrorSyntax\n\tCause error\n}\n\nfunc newApiError(code ApiErrorType, object LValue) *ApiError {\n\treturn &ApiError{code, object, \"\", nil}\n}\n\nfunc newApiErrorS(code ApiErrorType, message string) *ApiError {\n\treturn newApiError(code, LString(message))\n}\n\nfunc newApiErrorE(code ApiErrorType, err error) *ApiError {\n\treturn &ApiError{code, LString(err.Error()), \"\", err}\n}\n\nfunc (e *ApiError) Error() string {\n\tif len(e.StackTrace) > 0 {\n\t\treturn fmt.Sprintf(\"%s\\n%s\", e.Object.String(), e.StackTrace)\n\t}\n\treturn e.Object.String()\n}\n\ntype ApiErrorType int\n\nconst (\n\tApiErrorSyntax ApiErrorType = iota\n\tApiErrorFile\n\tApiErrorRun\n\tApiErrorError\n\tApiErrorPanic\n)\n\n/* }}} */\n\n/* ResumeState {{{ */\n\ntype ResumeState int\n\nconst (\n\tResumeOK ResumeState = iota\n\tResumeYield\n\tResumeError\n)\n\n/* }}} */\n\n/* P {{{ */\n\ntype P struct {\n\tFn      LValue\n\tNRet    int\n\tProtect bool\n\tHandler *LFunction\n}\n\n/* }}} */\n\n/* Options {{{ */\n\n// Options is a configuration that is used to create a new LState.\ntype Options struct {\n\t// Call stack size. This defaults to `lua.CallStackSize`.\n\tCallStackSize int\n\t// Data stack size. This defaults to `lua.RegistrySize`.\n\tRegistrySize int\n\t// Allow the registry to grow from the registry size specified up to a value of RegistryMaxSize. A value of 0\n\t// indicates no growth is permitted. The registry will not shrink again after any growth.\n\tRegistryMaxSize int\n\t// If growth is enabled, step up by an additional `RegistryGrowStep` each time to avoid having to resize too often.\n\t// This defaults to `lua.RegistryGrowStep`\n\tRegistryGrowStep int\n\t// Controls whether or not libraries are opened by default\n\tSkipOpenLibs bool\n\t// Tells whether a Go stacktrace should be included in a Lua stacktrace when panics occur.\n\tIncludeGoStackTrace bool\n\t// If `MinimizeStackMemory` is set, the call stack will be automatically grown or shrank up to a limit of\n\t// `CallStackSize` in order to minimize memory usage. This does incur a slight performance penalty.\n\tMinimizeStackMemory bool\n}\n\n/* }}} */\n\n/* Debug {{{ */\n\ntype Debug struct {\n\tframe           *callFrame\n\tName            string\n\tWhat            string\n\tSource          string\n\tCurrentLine     int\n\tNUpvalues       int\n\tLineDefined     int\n\tLastLineDefined int\n}\n\n/* }}} */\n\n/* callFrame {{{ */\n\ntype callFrame struct {\n\tIdx        int\n\tFn         *LFunction\n\tParent     *callFrame\n\tPc         int\n\tBase       int\n\tLocalBase  int\n\tReturnBase int\n\tNArgs      int\n\tNRet       int\n\tTailCall   int\n}\n\ntype callFrameStack interface {\n\tPush(v callFrame)\n\tPop() *callFrame\n\tLast() *callFrame\n\n\tSetSp(sp int)\n\tSp() int\n\tAt(sp int) *callFrame\n\n\tIsFull() bool\n\tIsEmpty() bool\n\n\tFreeAll()\n}\n\ntype fixedCallFrameStack struct {\n\tarray []callFrame\n\tsp    int\n}\n\nfunc newFixedCallFrameStack(size int) callFrameStack {\n\treturn &fixedCallFrameStack{\n\t\tarray: make([]callFrame, size),\n\t\tsp:    0,\n\t}\n}\n\nfunc (cs *fixedCallFrameStack) IsEmpty() bool { return cs.sp == 0 }\n\nfunc (cs *fixedCallFrameStack) IsFull() bool { return cs.sp == len(cs.array) }\n\nfunc (cs *fixedCallFrameStack) Clear() {\n\tcs.sp = 0\n}\n\nfunc (cs *fixedCallFrameStack) Push(v callFrame) {\n\tcs.array[cs.sp] = v\n\tcs.array[cs.sp].Idx = cs.sp\n\tcs.sp++\n}\n\nfunc (cs *fixedCallFrameStack) Sp() int {\n\treturn cs.sp\n}\n\nfunc (cs *fixedCallFrameStack) SetSp(sp int) {\n\tcs.sp = sp\n}\n\nfunc (cs *fixedCallFrameStack) Last() *callFrame {\n\tif cs.sp == 0 {\n\t\treturn nil\n\t}\n\treturn &cs.array[cs.sp-1]\n}\n\nfunc (cs *fixedCallFrameStack) At(sp int) *callFrame {\n\treturn &cs.array[sp]\n}\n\nfunc (cs *fixedCallFrameStack) Pop() *callFrame {\n\tcs.sp--\n\treturn &cs.array[cs.sp]\n}\n\nfunc (cs *fixedCallFrameStack) FreeAll() {\n\t// nothing to do for fixed callframestack\n}\n\n// FramesPerSegment should be a power of 2 constant for performance reasons. It will allow the go compiler to change\n// the divs and mods into bitshifts. Max is 256 due to current use of uint8 to count how many frames in a segment are\n// used.\nconst FramesPerSegment = 8\n\ntype callFrameStackSegment struct {\n\tarray [FramesPerSegment]callFrame\n}\ntype segIdx uint16\ntype autoGrowingCallFrameStack struct {\n\tsegments []*callFrameStackSegment\n\tsegIdx   segIdx\n\t// segSp is the number of frames in the current segment which are used. Full 'sp' value is segIdx * FramesPerSegment + segSp.\n\t// It points to the next stack slot to use, so 0 means to use the 0th element in the segment, and a value of\n\t// FramesPerSegment indicates that the segment is full and cannot accommodate another frame.\n\tsegSp uint8\n}\n\nvar segmentPool sync.Pool\n\nfunc newCallFrameStackSegment() *callFrameStackSegment {\n\tseg := segmentPool.Get()\n\tif seg == nil {\n\t\treturn &callFrameStackSegment{}\n\t}\n\treturn seg.(*callFrameStackSegment)\n}\n\nfunc freeCallFrameStackSegment(seg *callFrameStackSegment) {\n\tsegmentPool.Put(seg)\n}\n\n// newCallFrameStack allocates a new stack for a lua state, which will auto grow up to a max size of at least maxSize.\n// it will actually grow up to the next segment size multiple after maxSize, where the segment size is dictated by\n// FramesPerSegment.\nfunc newAutoGrowingCallFrameStack(maxSize int) callFrameStack {\n\tcs := &autoGrowingCallFrameStack{\n\t\tsegments: make([]*callFrameStackSegment, (maxSize+(FramesPerSegment-1))/FramesPerSegment),\n\t\tsegIdx:   0,\n\t}\n\tcs.segments[0] = newCallFrameStackSegment()\n\treturn cs\n}\n\nfunc (cs *autoGrowingCallFrameStack) IsEmpty() bool {\n\treturn cs.segIdx == 0 && cs.segSp == 0\n}\n\n// IsFull returns true if the stack cannot receive any more stack pushes without overflowing\nfunc (cs *autoGrowingCallFrameStack) IsFull() bool {\n\treturn int(cs.segIdx) == len(cs.segments) && cs.segSp >= FramesPerSegment\n}\n\nfunc (cs *autoGrowingCallFrameStack) Clear() {\n\tfor i := segIdx(1); i <= cs.segIdx; i++ {\n\t\tfreeCallFrameStackSegment(cs.segments[i])\n\t\tcs.segments[i] = nil\n\t}\n\tcs.segIdx = 0\n\tcs.segSp = 0\n}\n\nfunc (cs *autoGrowingCallFrameStack) FreeAll() {\n\tfor i := segIdx(0); i <= cs.segIdx; i++ {\n\t\tfreeCallFrameStackSegment(cs.segments[i])\n\t\tcs.segments[i] = nil\n\t}\n}\n\n// Push pushes the passed callFrame onto the stack. it panics if the stack is full, caller should call IsFull() before\n// invoking this to avoid this.\nfunc (cs *autoGrowingCallFrameStack) Push(v callFrame) {\n\tcurSeg := cs.segments[cs.segIdx]\n\tif cs.segSp >= FramesPerSegment {\n\t\t// segment full, push new segment if allowed\n\t\tif cs.segIdx < segIdx(len(cs.segments)-1) {\n\t\t\tcurSeg = newCallFrameStackSegment()\n\t\t\tcs.segIdx++\n\t\t\tcs.segments[cs.segIdx] = curSeg\n\t\t\tcs.segSp = 0\n\t\t} else {\n\t\t\tpanic(\"lua callstack overflow\")\n\t\t}\n\t}\n\tcurSeg.array[cs.segSp] = v\n\tcurSeg.array[cs.segSp].Idx = int(cs.segSp) + FramesPerSegment*int(cs.segIdx)\n\tcs.segSp++\n}\n\n// Sp retrieves the current stack depth, which is the number of frames currently pushed on the stack.\nfunc (cs *autoGrowingCallFrameStack) Sp() int {\n\treturn int(cs.segSp) + int(cs.segIdx)*FramesPerSegment\n}\n\n// SetSp can be used to rapidly unwind the stack, freeing all stack frames on the way. It should not be used to\n// allocate new stack space, use Push() for that.\nfunc (cs *autoGrowingCallFrameStack) SetSp(sp int) {\n\tdesiredSegIdx := segIdx(sp / FramesPerSegment)\n\tdesiredFramesInLastSeg := uint8(sp % FramesPerSegment)\n\tfor {\n\t\tif cs.segIdx <= desiredSegIdx {\n\t\t\tbreak\n\t\t}\n\t\tfreeCallFrameStackSegment(cs.segments[cs.segIdx])\n\t\tcs.segments[cs.segIdx] = nil\n\t\tcs.segIdx--\n\t}\n\tcs.segSp = desiredFramesInLastSeg\n}\n\nfunc (cs *autoGrowingCallFrameStack) Last() *callFrame {\n\tcurSeg := cs.segments[cs.segIdx]\n\tsegSp := cs.segSp\n\tif segSp == 0 {\n\t\tif cs.segIdx == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tcurSeg = cs.segments[cs.segIdx-1]\n\t\tsegSp = FramesPerSegment\n\t}\n\treturn &curSeg.array[segSp-1]\n}\n\nfunc (cs *autoGrowingCallFrameStack) At(sp int) *callFrame {\n\tsegIdx := segIdx(sp / FramesPerSegment)\n\tframeIdx := uint8(sp % FramesPerSegment)\n\treturn &cs.segments[segIdx].array[frameIdx]\n}\n\n// Pop pops off the most recent stack frame and returns it\nfunc (cs *autoGrowingCallFrameStack) Pop() *callFrame {\n\tcurSeg := cs.segments[cs.segIdx]\n\tif cs.segSp == 0 {\n\t\tif cs.segIdx == 0 {\n\t\t\t// stack empty\n\t\t\treturn nil\n\t\t}\n\t\tfreeCallFrameStackSegment(curSeg)\n\t\tcs.segments[cs.segIdx] = nil\n\t\tcs.segIdx--\n\t\tcs.segSp = FramesPerSegment\n\t\tcurSeg = cs.segments[cs.segIdx]\n\t}\n\tcs.segSp--\n\treturn &curSeg.array[cs.segSp]\n}\n\n/* }}} */\n\n/* registry {{{ */\n\ntype registryHandler interface {\n\tregistryOverflow()\n}\ntype registry struct {\n\tarray   []LValue\n\ttop     int\n\tgrowBy  int\n\tmaxSize int\n\talloc   *allocator\n\thandler registryHandler\n}\n\nfunc newRegistry(handler registryHandler, initialSize int, growBy int, maxSize int, alloc *allocator) *registry {\n\treturn &registry{make([]LValue, initialSize), 0, growBy, maxSize, alloc, handler}\n}\n\nfunc (rg *registry) checkSize(requiredSize int) { // +inline-start\n\tif requiredSize > cap(rg.array) {\n\t\trg.resize(requiredSize)\n\t}\n} // +inline-end\n\nfunc (rg *registry) resize(requiredSize int) { // +inline-start\n\tnewSize := requiredSize + rg.growBy // give some padding\n\tif newSize > rg.maxSize {\n\t\tnewSize = rg.maxSize\n\t}\n\tif newSize < requiredSize {\n\t\trg.handler.registryOverflow()\n\t\treturn\n\t}\n\trg.forceResize(newSize)\n} // +inline-end\n\nfunc (rg *registry) forceResize(newSize int) {\n\tnewSlice := make([]LValue, newSize)\n\tcopy(newSlice, rg.array[:rg.top]) // should we copy the area beyond top? there shouldn't be any valid values there so it shouldn't be necessary.\n\trg.array = newSlice\n}\n\nfunc (rg *registry) SetTop(topi int) { // +inline-start\n\t// +inline-call rg.checkSize topi\n\toldtopi := rg.top\n\trg.top = topi\n\tfor i := oldtopi; i < rg.top; i++ {\n\t\trg.array[i] = LNil\n\t}\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\tif rg.top < oldtopi {\n\t\tnilRange := rg.array[rg.top:oldtopi]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n\t//for i := rg.top; i < oldtop; i++ {\n\t//\trg.array[i] = LNil\n\t//}\n} // +inline-end\n\nfunc (rg *registry) Top() int {\n\treturn rg.top\n}\n\nfunc (rg *registry) Push(v LValue) {\n\tnewSize := rg.top + 1\n\t// +inline-call rg.checkSize newSize\n\trg.array[rg.top] = v\n\trg.top++\n}\n\nfunc (rg *registry) Pop() LValue {\n\tv := rg.array[rg.top-1]\n\trg.array[rg.top-1] = LNil\n\trg.top--\n\treturn v\n}\n\nfunc (rg *registry) Get(reg int) LValue {\n\treturn rg.array[reg]\n}\n\n// CopyRange will move a section of values from index `start` to index `regv`\n// It will move `n` values.\n// `limit` specifies the maximum end range that can be copied from. If it's set to -1, then it defaults to stopping at\n// the top of the registry (values beyond the top are not initialized, so if specifying an alternative `limit` you should\n// pass a value <= rg.top.\n// If start+n is beyond the limit, then nil values will be copied to the destination slots.\n// After the copy, the registry is truncated to be at the end of the copied range, ie the original of the copied values\n// are nilled out. (So top will be regv+n)\n// CopyRange should ideally be renamed to MoveRange.\nfunc (rg *registry) CopyRange(regv, start, limit, n int) { // +inline-start\n\tnewSize := regv + n\n\t// +inline-call rg.checkSize newSize\n\tif limit == -1 || limit > rg.top {\n\t\tlimit = rg.top\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tsrcIdx := start + i\n\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\trg.array[regv+i] = LNil\n\t\t} else {\n\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t}\n\t}\n\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\toldtop := rg.top\n\trg.top = regv + n\n\tif rg.top < oldtop {\n\t\tnilRange := rg.array[rg.top:oldtop]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n} // +inline-end\n\n// FillNil fills the registry with nil values from regm to regm+n and then sets the registry top to regm+n\nfunc (rg *registry) FillNil(regm, n int) { // +inline-start\n\tnewSize := regm + n\n\t// +inline-call rg.checkSize newSize\n\tfor i := 0; i < n; i++ {\n\t\trg.array[regm+i] = LNil\n\t}\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\toldtop := rg.top\n\trg.top = regm + n\n\tif rg.top < oldtop {\n\t\tnilRange := rg.array[rg.top:oldtop]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n} // +inline-end\n\nfunc (rg *registry) Insert(value LValue, reg int) {\n\ttop := rg.Top()\n\tif reg >= top {\n\t\t// +inline-call rg.Set reg value\n\t\treturn\n\t}\n\ttop--\n\tfor ; top >= reg; top-- {\n\t\t// FIXME consider using copy() here if Insert() is called enough\n\t\t// +inline-call rg.Set top+1 rg.Get(top)\n\t}\n\t// +inline-call rg.Set reg value\n}\n\nfunc (rg *registry) Set(regi int, vali LValue) { // +inline-start\n\tnewSize := regi + 1\n\t// +inline-call rg.checkSize newSize\n\trg.array[regi] = vali\n\tif regi >= rg.top {\n\t\trg.top = regi + 1\n\t}\n} // +inline-end\n\nfunc (rg *registry) SetNumber(regi int, vali LNumber) { // +inline-start\n\tnewSize := regi + 1\n\t// +inline-call rg.checkSize newSize\n\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\tif regi >= rg.top {\n\t\trg.top = regi + 1\n\t}\n} // +inline-end\n\nfunc (rg *registry) IsFull() bool {\n\treturn rg.top >= cap(rg.array)\n}\n\n/* }}} */\n\n/* Global {{{ */\n\nfunc newGlobal() *Global {\n\treturn &Global{\n\t\tMainThread: nil,\n\t\tRegistry:   newLTable(0, 32),\n\t\tGlobal:     newLTable(0, 64),\n\t\tbuiltinMts: make(map[int]LValue),\n\t\ttempFiles:  make([]*os.File, 0, 10),\n\t}\n}\n\n/* }}} */\n\n/* package local methods {{{ */\n\nfunc panicWithTraceback(L *LState) {\n\terr := newApiError(ApiErrorRun, L.Get(-1))\n\terr.StackTrace = L.stackTrace(0)\n\tpanic(err)\n}\n\nfunc panicWithoutTraceback(L *LState) {\n\terr := newApiError(ApiErrorRun, L.Get(-1))\n\tpanic(err)\n}\n\nfunc newLState(options Options) *LState {\n\tal := newAllocator(32)\n\tls := &LState{\n\t\tG:       newGlobal(),\n\t\tParent:  nil,\n\t\tPanic:   panicWithTraceback,\n\t\tDead:    false,\n\t\tOptions: options,\n\n\t\tstop:         0,\n\t\talloc:        al,\n\t\tcurrentFrame: nil,\n\t\twrapped:      false,\n\t\tuvcache:      nil,\n\t\thasErrorFunc: false,\n\t\tmainLoop:     mainLoop,\n\t\tctx:          nil,\n\t}\n\tif options.MinimizeStackMemory {\n\t\tls.stack = newAutoGrowingCallFrameStack(options.CallStackSize)\n\t} else {\n\t\tls.stack = newFixedCallFrameStack(options.CallStackSize)\n\t}\n\tls.reg = newRegistry(ls, options.RegistrySize, options.RegistryGrowStep, options.RegistryMaxSize, al)\n\tls.Env = ls.G.Global\n\treturn ls\n}\n\nfunc (ls *LState) printReg() {\n\tprintln(\"-------------------------\")\n\tprintln(\"thread:\", ls)\n\tprintln(\"top:\", ls.reg.Top())\n\tif ls.currentFrame != nil {\n\t\tprintln(\"function base:\", ls.currentFrame.Base)\n\t\tprintln(\"return base:\", ls.currentFrame.ReturnBase)\n\t} else {\n\t\tprintln(\"(vm not started)\")\n\t}\n\tprintln(\"local base:\", ls.currentLocalBase())\n\tfor i := 0; i < ls.reg.Top(); i++ {\n\t\tprintln(i, ls.reg.Get(i).String())\n\t}\n\tprintln(\"-------------------------\")\n}\n\nfunc (ls *LState) printCallStack() {\n\tprintln(\"-------------------------\")\n\tfor i := 0; i < ls.stack.Sp(); i++ {\n\t\tprint(i)\n\t\tprint(\" \")\n\t\tframe := ls.stack.At(i)\n\t\tif frame == nil {\n\t\t\tbreak\n\t\t}\n\t\tif frame.Fn.IsG {\n\t\t\tprintln(\"IsG:\", true, \"Frame:\", frame, \"Fn:\", frame.Fn)\n\t\t} else {\n\t\t\tprintln(\"IsG:\", false, \"Frame:\", frame, \"Fn:\", frame.Fn, \"pc:\", frame.Pc)\n\t\t}\n\t}\n\tprintln(\"-------------------------\")\n}\n\nfunc (ls *LState) closeAllUpvalues() { // +inline-start\n\tfor cf := ls.currentFrame; cf != nil; cf = cf.Parent {\n\t\tif !cf.Fn.IsG {\n\t\t\tls.closeUpvalues(cf.LocalBase)\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) raiseError(level int, format string, args ...interface{}) {\n\tif !ls.hasErrorFunc {\n\t\tls.closeAllUpvalues()\n\t}\n\tmessage := format\n\tif len(args) > 0 {\n\t\tmessage = fmt.Sprintf(format, args...)\n\t}\n\tif level > 0 {\n\t\tmessage = fmt.Sprintf(\"%v %v\", ls.where(level-1, true), message)\n\t}\n\tif ls.reg.IsFull() {\n\t\t// if the registry is full then it won't be possible to push a value, in this case, force a larger size\n\t\tls.reg.forceResize(ls.reg.Top() + 1)\n\t}\n\tls.reg.Push(LString(message))\n\tls.Panic(ls)\n}\n\nfunc (ls *LState) findLocal(frame *callFrame, no int) string {\n\tfn := frame.Fn\n\tif !fn.IsG {\n\t\tif name, ok := fn.LocalName(no, frame.Pc-1); ok {\n\t\t\treturn name\n\t\t}\n\t}\n\tvar top int\n\tif ls.currentFrame == frame {\n\t\ttop = ls.reg.Top()\n\t} else if frame.Idx+1 < ls.stack.Sp() {\n\t\ttop = ls.stack.At(frame.Idx + 1).Base\n\t} else {\n\t\treturn \"\"\n\t}\n\tif top-frame.LocalBase >= no {\n\t\treturn \"(*temporary)\"\n\t}\n\treturn \"\"\n}\n\nfunc (ls *LState) where(level int, skipg bool) string {\n\tdbg, ok := ls.GetStack(level)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tcf := dbg.frame\n\tproto := cf.Fn.Proto\n\tsourcename := \"[G]\"\n\tif proto != nil {\n\t\tsourcename = proto.SourceName\n\t} else if skipg {\n\t\treturn ls.where(level+1, skipg)\n\t}\n\tline := \"\"\n\tif proto != nil {\n\t\tline = fmt.Sprintf(\"%v:\", proto.DbgSourcePositions[cf.Pc-1])\n\t}\n\treturn fmt.Sprintf(\"%v:%v\", sourcename, line)\n}\n\nfunc (ls *LState) stackTrace(level int) string {\n\tbuf := []string{}\n\theader := \"stack traceback:\"\n\tif ls.currentFrame != nil {\n\t\ti := 0\n\t\tfor dbg, ok := ls.GetStack(i); ok; dbg, ok = ls.GetStack(i) {\n\t\t\tcf := dbg.frame\n\t\t\tbuf = append(buf, fmt.Sprintf(\"\\t%v in %v\", ls.Where(i), ls.formattedFrameFuncName(cf)))\n\t\t\tif !cf.Fn.IsG && cf.TailCall > 0 {\n\t\t\t\tfor tc := cf.TailCall; tc > 0; tc-- {\n\t\t\t\t\tbuf = append(buf, \"\\t(tailcall): ?\")\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\tbuf = append(buf, fmt.Sprintf(\"\\t%v: %v\", \"[G]\", \"?\"))\n\tbuf = buf[intMax(0, intMin(level, len(buf))):len(buf)]\n\tif len(buf) > 20 {\n\t\tnewbuf := make([]string, 0, 20)\n\t\tnewbuf = append(newbuf, buf[0:7]...)\n\t\tnewbuf = append(newbuf, \"\\t...\")\n\t\tnewbuf = append(newbuf, buf[len(buf)-7:len(buf)]...)\n\t\tbuf = newbuf\n\t}\n\treturn fmt.Sprintf(\"%s\\n%s\", header, strings.Join(buf, \"\\n\"))\n}\n\nfunc (ls *LState) formattedFrameFuncName(fr *callFrame) string {\n\tname, ischunk := ls.frameFuncName(fr)\n\tif ischunk {\n\t\treturn name\n\t}\n\tif name[0] != '(' && name[0] != '<' {\n\t\treturn fmt.Sprintf(\"function '%s'\", name)\n\t}\n\treturn fmt.Sprintf(\"function %s\", name)\n}\n\nfunc (ls *LState) rawFrameFuncName(fr *callFrame) string {\n\tname, _ := ls.frameFuncName(fr)\n\treturn name\n}\n\nfunc (ls *LState) frameFuncName(fr *callFrame) (string, bool) {\n\tframe := fr.Parent\n\tif frame == nil {\n\t\tif ls.Parent == nil {\n\t\t\treturn \"main chunk\", true\n\t\t} else {\n\t\t\treturn \"corountine\", true\n\t\t}\n\t}\n\tif !frame.Fn.IsG {\n\t\tpc := frame.Pc - 1\n\t\tfor _, call := range frame.Fn.Proto.DbgCalls {\n\t\t\tif call.Pc == pc {\n\t\t\t\tname := call.Name\n\t\t\t\tif (name == \"?\" || fr.TailCall > 0) && !fr.Fn.IsG {\n\t\t\t\t\tname = fmt.Sprintf(\"<%v:%v>\", fr.Fn.Proto.SourceName, fr.Fn.Proto.LineDefined)\n\t\t\t\t}\n\t\t\t\treturn name, false\n\t\t\t}\n\t\t}\n\t}\n\tif !fr.Fn.IsG {\n\t\treturn fmt.Sprintf(\"<%v:%v>\", fr.Fn.Proto.SourceName, fr.Fn.Proto.LineDefined), false\n\t}\n\treturn \"(anonymous)\", false\n}\n\nfunc (ls *LState) isStarted() bool {\n\treturn ls.currentFrame != nil\n}\n\nfunc (ls *LState) kill() {\n\tls.Dead = true\n\tif ls.ctxCancelFn != nil {\n\t\tls.ctxCancelFn()\n\t}\n}\n\nfunc (ls *LState) indexToReg(idx int) int {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treturn base + idx - 1\n\t} else if idx == 0 {\n\t\treturn -1\n\t} else {\n\t\ttidx := ls.reg.Top() + idx\n\t\tif tidx < base {\n\t\t\treturn -1\n\t\t}\n\t\treturn tidx\n\t}\n}\n\nfunc (ls *LState) currentLocalBase() int {\n\tbase := 0\n\tif ls.currentFrame != nil {\n\t\tbase = ls.currentFrame.LocalBase\n\t}\n\treturn base\n}\n\nfunc (ls *LState) currentEnv() *LTable {\n\treturn ls.Env\n\t/*\n\t\tif ls.currentFrame == nil {\n\t\t\treturn ls.Env\n\t\t}\n\t\treturn ls.currentFrame.Fn.Env\n\t*/\n}\n\nfunc (ls *LState) rkValue(idx int) LValue {\n\t/*\n\t\tif OpIsK(idx) {\n\t\t\treturn ls.currentFrame.Fn.Proto.Constants[opIndexK(idx)]\n\t\t}\n\t\treturn ls.reg.Get(ls.currentFrame.LocalBase + idx)\n\t*/\n\tif (idx & opBitRk) != 0 {\n\t\treturn ls.currentFrame.Fn.Proto.Constants[idx & ^opBitRk]\n\t}\n\treturn ls.reg.array[ls.currentFrame.LocalBase+idx]\n}\n\nfunc (ls *LState) rkString(idx int) string {\n\tif (idx & opBitRk) != 0 {\n\t\treturn ls.currentFrame.Fn.Proto.stringConstants[idx & ^opBitRk]\n\t}\n\treturn string(ls.reg.array[ls.currentFrame.LocalBase+idx].(LString))\n}\n\nfunc (ls *LState) closeUpvalues(idx int) { // +inline-start\n\tif ls.uvcache != nil {\n\t\tvar prev *Upvalue\n\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\tif uv.index >= idx {\n\t\t\t\tif prev != nil {\n\t\t\t\t\tprev.next = nil\n\t\t\t\t} else {\n\t\t\t\t\tls.uvcache = nil\n\t\t\t\t}\n\t\t\t\tuv.Close()\n\t\t\t}\n\t\t\tprev = uv\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) findUpvalue(idx int) *Upvalue {\n\tvar prev *Upvalue\n\tvar next *Upvalue\n\tif ls.uvcache != nil {\n\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\tif uv.index == idx {\n\t\t\t\treturn uv\n\t\t\t}\n\t\t\tif uv.index > idx {\n\t\t\t\tnext = uv\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tprev = uv\n\t\t}\n\t}\n\tuv := &Upvalue{reg: ls.reg, index: idx, closed: false}\n\tif prev != nil {\n\t\tprev.next = uv\n\t} else {\n\t\tls.uvcache = uv\n\t}\n\tif next != nil {\n\t\tuv.next = next\n\t}\n\treturn uv\n}\n\nfunc (ls *LState) metatable(lvalue LValue, rawget bool) LValue {\n\tvar metatable LValue = LNil\n\tswitch obj := lvalue.(type) {\n\tcase *LTable:\n\t\tmetatable = obj.Metatable\n\tcase *LUserData:\n\t\tmetatable = obj.Metatable\n\tdefault:\n\t\tif table, ok := ls.G.builtinMts[int(obj.Type())]; ok {\n\t\t\tmetatable = table\n\t\t}\n\t}\n\n\tif !rawget && metatable != LNil {\n\t\toldmt := metatable\n\t\tif tb, ok := metatable.(*LTable); ok {\n\t\t\tmetatable = tb.RawGetString(\"__metatable\")\n\t\t\tif metatable == LNil {\n\t\t\t\tmetatable = oldmt\n\t\t\t}\n\t\t}\n\t}\n\n\treturn metatable\n}\n\nfunc (ls *LState) metaOp1(lvalue LValue, event string) LValue {\n\tif mt := ls.metatable(lvalue, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\treturn tb.RawGetString(event)\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) metaOp2(value1, value2 LValue, event string) LValue {\n\tif mt := ls.metatable(value1, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\tif ret := tb.RawGetString(event); ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t}\n\tif mt := ls.metatable(value2, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\treturn tb.RawGetString(event)\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) metaCall(lvalue LValue) (*LFunction, bool) {\n\tif fn, ok := lvalue.(*LFunction); ok {\n\t\treturn fn, false\n\t}\n\tif fn, ok := ls.metaOp1(lvalue, \"__call\").(*LFunction); ok {\n\t\treturn fn, true\n\t}\n\treturn nil, false\n}\n\nfunc (ls *LState) initCallFrame(cf *callFrame) { // +inline-start\n\tif cf.Fn.IsG {\n\t\tls.reg.SetTop(cf.LocalBase + cf.NArgs)\n\t} else {\n\t\tproto := cf.Fn.Proto\n\t\tnargs := cf.NArgs\n\t\tnp := int(proto.NumParameters)\n\t\tif nargs < np {\n\t\t\t// default any missing arguments to nil\n\t\t\tnewSize := cf.LocalBase + np\n\t\t\t// +inline-call ls.reg.checkSize newSize\n\t\t\tfor i := nargs; i < np; i++ {\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\t\t\tnargs = np\n\t\t\tls.reg.top = newSize\n\t\t}\n\n\t\tif (proto.IsVarArg & VarArgIsVarArg) == 0 {\n\t\t\tif nargs < int(proto.NumUsedRegisters) {\n\t\t\t\tnargs = int(proto.NumUsedRegisters)\n\t\t\t}\n\t\t\tnewSize := cf.LocalBase + nargs\n\t\t\t// +inline-call ls.reg.checkSize newSize\n\t\t\tfor i := np; i < nargs; i++ {\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\t\t\tls.reg.top = cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t} else {\n\t\t\t/* swap vararg positions:\n\t\t\t\t\t   closure\n\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t   namedparam2\n\t\t\t\t\t   vararg1\n\t\t\t\t\t   vararg2\n\n\t\t\t           TO\n\n\t\t\t\t\t   closure\n\t\t\t\t\t   nil\n\t\t\t\t\t   nil\n\t\t\t\t\t   vararg1\n\t\t\t\t\t   vararg2\n\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t   namedparam2\n\t\t\t*/\n\t\t\tnvarargs := nargs - np\n\t\t\tif nvarargs < 0 {\n\t\t\t\tnvarargs = 0\n\t\t\t}\n\n\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np)\n\t\t\tfor i := 0; i < np; i++ {\n\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+i, ls.reg.Get(cf.LocalBase+i))\n\t\t\t\tls.reg.array[cf.LocalBase+nargs+i] = ls.reg.array[cf.LocalBase+i]\n\t\t\t\t//ls.reg.Set(cf.LocalBase+i, LNil)\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\n\t\t\tif CompatVarArg {\n\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np + 1)\n\t\t\t\tif (proto.IsVarArg & VarArgNeedsArg) != 0 {\n\t\t\t\t\targtb := newLTable(nvarargs, 0)\n\t\t\t\t\tfor i := 0; i < nvarargs; i++ {\n\t\t\t\t\t\targtb.RawSetInt(i+1, ls.reg.Get(cf.LocalBase+np+i))\n\t\t\t\t\t}\n\t\t\t\t\targtb.RawSetString(\"n\", LNumber(nvarargs))\n\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+np, argtb)\n\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = argtb\n\t\t\t\t} else {\n\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = LNil\n\t\t\t\t}\n\t\t\t}\n\t\t\tcf.LocalBase += nargs\n\t\t\tmaxreg := cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\tls.reg.SetTop(maxreg)\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) pushCallFrame(cf callFrame, fn LValue, meta bool) { // +inline-start\n\tif meta {\n\t\tcf.NArgs++\n\t\tls.reg.Insert(fn, cf.LocalBase)\n\t}\n\tif cf.Fn == nil {\n\t\tls.RaiseError(\"attempt to call a non-function object\")\n\t}\n\tif ls.stack.IsFull() {\n\t\tls.RaiseError(\"stack overflow\")\n\t}\n\tls.stack.Push(cf)\n\tnewcf := ls.stack.Last()\n\t// +inline-call ls.initCallFrame newcf\n\tls.currentFrame = newcf\n} // +inline-end\n\nfunc (ls *LState) callR(nargs, nret, rbase int) {\n\tbase := ls.reg.Top() - nargs - 1\n\tif rbase < 0 {\n\t\trbase = base\n\t}\n\tlv := ls.reg.Get(base)\n\tfn, meta := ls.metaCall(lv)\n\tls.pushCallFrame(callFrame{\n\t\tFn:         fn,\n\t\tPc:         0,\n\t\tBase:       base,\n\t\tLocalBase:  base + 1,\n\t\tReturnBase: rbase,\n\t\tNArgs:      nargs,\n\t\tNRet:       nret,\n\t\tParent:     ls.currentFrame,\n\t\tTailCall:   0,\n\t}, lv, meta)\n\tif ls.G.MainThread == nil {\n\t\tls.G.MainThread = ls\n\t\tls.G.CurrentThread = ls\n\t\tls.mainLoop(ls, nil)\n\t} else {\n\t\tls.mainLoop(ls, ls.currentFrame)\n\t}\n\tif nret != MultRet {\n\t\tls.reg.SetTop(rbase + nret)\n\t}\n}\n\nfunc (ls *LState) getField(obj LValue, key LValue) LValue {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tret := tb.RawGet(key)\n\t\t\tif ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__index\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key.String())\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(key)\n\t\t\tls.Call(2, 1)\n\t\t\treturn ls.reg.Pop()\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in gettable\")\n\treturn nil\n}\n\nfunc (ls *LState) getFieldString(obj LValue, key string) LValue {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tret := tb.RawGetString(key)\n\t\t\tif ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__index\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key)\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(LString(key))\n\t\t\tls.Call(2, 1)\n\t\t\treturn ls.reg.Pop()\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in gettable\")\n\treturn nil\n}\n\nfunc (ls *LState) setField(obj LValue, key LValue, value LValue) {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tif tb.RawGet(key) != LNil {\n\t\t\t\tls.RawSet(tb, key, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__newindex\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key.String())\n\t\t\t}\n\t\t\tls.RawSet(tb, key, value)\n\t\t\treturn\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(key)\n\t\t\tls.reg.Push(value)\n\t\t\tls.Call(3, 0)\n\t\t\treturn\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in settable\")\n}\n\nfunc (ls *LState) setFieldString(obj LValue, key string, value LValue) {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tif tb.RawGetString(key) != LNil {\n\t\t\t\ttb.RawSetString(key, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__newindex\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key)\n\t\t\t}\n\t\t\ttb.RawSetString(key, value)\n\t\t\treturn\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(LString(key))\n\t\t\tls.reg.Push(value)\n\t\t\tls.Call(3, 0)\n\t\t\treturn\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in settable\")\n}\n\n/* }}} */\n\n/* api methods {{{ */\n\nfunc NewState(opts ...Options) *LState {\n\tvar ls *LState\n\tif len(opts) == 0 {\n\t\tls = newLState(Options{\n\t\t\tCallStackSize: CallStackSize,\n\t\t\tRegistrySize:  RegistrySize,\n\t\t})\n\t\tls.OpenLibs()\n\t} else {\n\t\tif opts[0].CallStackSize < 1 {\n\t\t\topts[0].CallStackSize = CallStackSize\n\t\t}\n\t\tif opts[0].RegistrySize < 128 {\n\t\t\topts[0].RegistrySize = RegistrySize\n\t\t}\n\t\tif opts[0].RegistryMaxSize < opts[0].RegistrySize {\n\t\t\topts[0].RegistryMaxSize = 0 // disable growth if max size is smaller than initial size\n\t\t} else {\n\t\t\t// if growth enabled, grow step is set\n\t\t\tif opts[0].RegistryGrowStep < 1 {\n\t\t\t\topts[0].RegistryGrowStep = RegistryGrowStep\n\t\t\t}\n\t\t}\n\t\tls = newLState(opts[0])\n\t\tif !opts[0].SkipOpenLibs {\n\t\t\tls.OpenLibs()\n\t\t}\n\t}\n\treturn ls\n}\n\nfunc (ls *LState) IsClosed() bool {\n\treturn ls.stack == nil\n}\n\nfunc (ls *LState) Close() {\n\tatomic.AddInt32(&ls.stop, 1)\n\tfor _, file := range ls.G.tempFiles {\n\t\t// ignore errors in these operations\n\t\tfile.Close()\n\t\tos.Remove(file.Name())\n\t}\n\tls.stack.FreeAll()\n\tls.stack = nil\n}\n\n/* registry operations {{{ */\n\nfunc (ls *LState) GetTop() int {\n\treturn ls.reg.Top() - ls.currentLocalBase()\n}\n\nfunc (ls *LState) SetTop(idx int) {\n\tbase := ls.currentLocalBase()\n\tnewtop := ls.indexToReg(idx) + 1\n\tif newtop < base {\n\t\tls.reg.SetTop(base)\n\t} else {\n\t\tls.reg.SetTop(newtop)\n\t}\n}\n\nfunc (ls *LState) Replace(idx int, value LValue) {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treg := base + idx - 1\n\t\tif reg < ls.reg.Top() {\n\t\t\tls.reg.Set(reg, value)\n\t\t}\n\t} else if idx == 0 {\n\t} else if idx > RegistryIndex {\n\t\tif tidx := ls.reg.Top() + idx; tidx >= base {\n\t\t\tls.reg.Set(tidx, value)\n\t\t}\n\t} else {\n\t\tswitch idx {\n\t\tcase RegistryIndex:\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.G.Registry = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"registry must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tcase EnvironIndex:\n\t\t\tif ls.currentFrame == nil {\n\t\t\t\tls.RaiseError(\"no calling environment\")\n\t\t\t}\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.currentFrame.Fn.Env = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"environment must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tcase GlobalsIndex:\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.G.Global = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"_G must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tdefault:\n\t\t\tfn := ls.currentFrame.Fn\n\t\t\tindex := GlobalsIndex - idx - 1\n\t\t\tif index < len(fn.Upvalues) {\n\t\t\t\tfn.Upvalues[index].SetValue(value)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (ls *LState) Get(idx int) LValue {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treg := base + idx - 1\n\t\tif reg < ls.reg.Top() {\n\t\t\treturn ls.reg.Get(reg)\n\t\t}\n\t\treturn LNil\n\t} else if idx == 0 {\n\t\treturn LNil\n\t} else if idx > RegistryIndex {\n\t\ttidx := ls.reg.Top() + idx\n\t\tif tidx < base {\n\t\t\treturn LNil\n\t\t}\n\t\treturn ls.reg.Get(tidx)\n\t} else {\n\t\tswitch idx {\n\t\tcase RegistryIndex:\n\t\t\treturn ls.G.Registry\n\t\tcase EnvironIndex:\n\t\t\tif ls.currentFrame == nil {\n\t\t\t\treturn ls.Env\n\t\t\t}\n\t\t\treturn ls.currentFrame.Fn.Env\n\t\tcase GlobalsIndex:\n\t\t\treturn ls.G.Global\n\t\tdefault:\n\t\t\tfn := ls.currentFrame.Fn\n\t\t\tindex := GlobalsIndex - idx - 1\n\t\t\tif index < len(fn.Upvalues) {\n\t\t\t\treturn fn.Upvalues[index].Value()\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) Push(value LValue) {\n\tls.reg.Push(value)\n}\n\nfunc (ls *LState) Pop(n int) {\n\tfor i := 0; i < n; i++ {\n\t\tif ls.GetTop() == 0 {\n\t\t\tls.RaiseError(\"register underflow\")\n\t\t}\n\t\tls.reg.Pop()\n\t}\n}\n\nfunc (ls *LState) Insert(value LValue, index int) {\n\treg := ls.indexToReg(index)\n\ttop := ls.reg.Top()\n\tif reg >= top {\n\t\tls.reg.Set(reg, value)\n\t\treturn\n\t}\n\tif reg <= ls.currentLocalBase() {\n\t\treg = ls.currentLocalBase()\n\t}\n\ttop--\n\tfor ; top >= reg; top-- {\n\t\tls.reg.Set(top+1, ls.reg.Get(top))\n\t}\n\tls.reg.Set(reg, value)\n}\n\nfunc (ls *LState) Remove(index int) {\n\treg := ls.indexToReg(index)\n\ttop := ls.reg.Top()\n\tswitch {\n\tcase reg >= top:\n\t\treturn\n\tcase reg < ls.currentLocalBase():\n\t\treturn\n\tcase reg == top-1:\n\t\tls.Pop(1)\n\t\treturn\n\t}\n\tfor i := reg; i < top-1; i++ {\n\t\tls.reg.Set(i, ls.reg.Get(i+1))\n\t}\n\tls.reg.SetTop(top - 1)\n}\n\n/* }}} */\n\n/* object allocation {{{ */\n\nfunc (ls *LState) NewTable() *LTable {\n\treturn newLTable(defaultArrayCap, defaultHashCap)\n}\n\nfunc (ls *LState) CreateTable(acap, hcap int) *LTable {\n\treturn newLTable(acap, hcap)\n}\n\n// NewThread returns a new LState that shares with the original state all global objects.\n// If the original state has context.Context, the new state has a new child context of the original state and this function returns its cancel function.\nfunc (ls *LState) NewThread() (*LState, context.CancelFunc) {\n\tthread := newLState(ls.Options)\n\tthread.G = ls.G\n\tthread.Env = ls.Env\n\tvar f context.CancelFunc = nil\n\tif ls.ctx != nil {\n\t\tthread.mainLoop = mainLoopWithContext\n\t\tthread.ctx, f = context.WithCancel(ls.ctx)\n\t\tthread.ctxCancelFn = f\n\t}\n\treturn thread, f\n}\n\nfunc (ls *LState) NewFunctionFromProto(proto *FunctionProto) *LFunction {\n\treturn newLFunctionL(proto, ls.Env, int(proto.NumUpvalues))\n}\n\nfunc (ls *LState) NewUserData() *LUserData {\n\treturn &LUserData{\n\t\tEnv:       ls.currentEnv(),\n\t\tMetatable: LNil,\n\t}\n}\n\nfunc (ls *LState) NewFunction(fn LGFunction) *LFunction {\n\treturn newLFunctionG(fn, ls.currentEnv(), 0)\n}\n\nfunc (ls *LState) NewClosure(fn LGFunction, upvalues ...LValue) *LFunction {\n\tcl := newLFunctionG(fn, ls.currentEnv(), len(upvalues))\n\tfor i, lv := range upvalues {\n\t\tcl.Upvalues[i] = &Upvalue{}\n\t\tcl.Upvalues[i].Close()\n\t\tcl.Upvalues[i].SetValue(lv)\n\t}\n\treturn cl\n}\n\n/* }}} */\n\n/* toType {{{ */\n\nfunc (ls *LState) ToBool(n int) bool {\n\treturn LVAsBool(ls.Get(n))\n}\n\nfunc (ls *LState) ToInt(n int) int {\n\tif lv, ok := ls.Get(n).(LNumber); ok {\n\t\treturn int(lv)\n\t}\n\tif lv, ok := ls.Get(n).(LString); ok {\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn int(num)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (ls *LState) ToInt64(n int) int64 {\n\tif lv, ok := ls.Get(n).(LNumber); ok {\n\t\treturn int64(lv)\n\t}\n\tif lv, ok := ls.Get(n).(LString); ok {\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn int64(num)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (ls *LState) ToNumber(n int) LNumber {\n\treturn LVAsNumber(ls.Get(n))\n}\n\nfunc (ls *LState) ToString(n int) string {\n\treturn LVAsString(ls.Get(n))\n}\n\nfunc (ls *LState) ToTable(n int) *LTable {\n\tif lv, ok := ls.Get(n).(*LTable); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToFunction(n int) *LFunction {\n\tif lv, ok := ls.Get(n).(*LFunction); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToUserData(n int) *LUserData {\n\tif lv, ok := ls.Get(n).(*LUserData); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToThread(n int) *LState {\n\tif lv, ok := ls.Get(n).(*LState); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\n/* }}} */\n\n/* error & debug operations {{{ */\n\nfunc (ls *LState) registryOverflow() {\n\tls.RaiseError(\"registry overflow\")\n}\n\n// This function is equivalent to luaL_error( http://www.lua.org/manual/5.1/manual.html#luaL_error ).\nfunc (ls *LState) RaiseError(format string, args ...interface{}) {\n\tls.raiseError(1, format, args...)\n}\n\n// This function is equivalent to lua_error( http://www.lua.org/manual/5.1/manual.html#lua_error ).\nfunc (ls *LState) Error(lv LValue, level int) {\n\tif str, ok := lv.(LString); ok {\n\t\tls.raiseError(level, string(str))\n\t} else {\n\t\tif !ls.hasErrorFunc {\n\t\t\tls.closeAllUpvalues()\n\t\t}\n\t\tls.Push(lv)\n\t\tls.Panic(ls)\n\t}\n}\n\nfunc (ls *LState) GetInfo(what string, dbg *Debug, fn LValue) (LValue, error) {\n\tif !strings.HasPrefix(what, \">\") {\n\t\tfn = dbg.frame.Fn\n\t} else {\n\t\twhat = what[1:]\n\t}\n\tf, ok := fn.(*LFunction)\n\tif !ok {\n\t\treturn LNil, newApiErrorS(ApiErrorRun, \"can not get debug info(an object in not a function)\")\n\t}\n\n\tretfn := false\n\tfor _, c := range what {\n\t\tswitch c {\n\t\tcase 'f':\n\t\t\tretfn = true\n\t\tcase 'S':\n\t\t\tif dbg.frame != nil && dbg.frame.Parent == nil {\n\t\t\t\tdbg.What = \"main\"\n\t\t\t} else if f.IsG {\n\t\t\t\tdbg.What = \"G\"\n\t\t\t} else if dbg.frame != nil && dbg.frame.TailCall > 0 {\n\t\t\t\tdbg.What = \"tail\"\n\t\t\t} else {\n\t\t\t\tdbg.What = \"Lua\"\n\t\t\t}\n\t\t\tif !f.IsG {\n\t\t\t\tdbg.Source = f.Proto.SourceName\n\t\t\t\tdbg.LineDefined = f.Proto.LineDefined\n\t\t\t\tdbg.LastLineDefined = f.Proto.LastLineDefined\n\t\t\t}\n\t\tcase 'l':\n\t\t\tif !f.IsG && dbg.frame != nil {\n\t\t\t\tif dbg.frame.Pc > 0 {\n\t\t\t\t\tdbg.CurrentLine = f.Proto.DbgSourcePositions[dbg.frame.Pc-1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdbg.CurrentLine = -1\n\t\t\t}\n\t\tcase 'u':\n\t\t\tdbg.NUpvalues = len(f.Upvalues)\n\t\tcase 'n':\n\t\t\tif dbg.frame != nil {\n\t\t\t\tdbg.Name = ls.rawFrameFuncName(dbg.frame)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn LNil, newApiErrorS(ApiErrorRun, \"invalid what: \"+string(c))\n\t\t}\n\t}\n\n\tif retfn {\n\t\treturn f, nil\n\t}\n\treturn LNil, nil\n\n}\n\nfunc (ls *LState) GetStack(level int) (*Debug, bool) {\n\tframe := ls.currentFrame\n\tfor ; level > 0 && frame != nil; frame = frame.Parent {\n\t\tlevel--\n\t\tif !frame.Fn.IsG {\n\t\t\tlevel -= frame.TailCall\n\t\t}\n\t}\n\n\tif level == 0 && frame != nil {\n\t\treturn &Debug{frame: frame}, true\n\t} else if level < 0 && ls.stack.Sp() > 0 {\n\t\treturn &Debug{frame: ls.stack.At(0)}, true\n\t}\n\treturn &Debug{}, false\n}\n\nfunc (ls *LState) GetLocal(dbg *Debug, no int) (string, LValue) {\n\tframe := dbg.frame\n\tif name := ls.findLocal(frame, no); len(name) > 0 {\n\t\treturn name, ls.reg.Get(frame.LocalBase + no - 1)\n\t}\n\treturn \"\", LNil\n}\n\nfunc (ls *LState) SetLocal(dbg *Debug, no int, lv LValue) string {\n\tframe := dbg.frame\n\tif name := ls.findLocal(frame, no); len(name) > 0 {\n\t\tls.reg.Set(frame.LocalBase+no-1, lv)\n\t\treturn name\n\t}\n\treturn \"\"\n}\n\nfunc (ls *LState) GetUpvalue(fn *LFunction, no int) (string, LValue) {\n\tif fn.IsG {\n\t\treturn \"\", LNil\n\t}\n\n\tno--\n\tif no >= 0 && no < len(fn.Upvalues) {\n\t\treturn fn.Proto.DbgUpvalues[no], fn.Upvalues[no].Value()\n\t}\n\treturn \"\", LNil\n}\n\nfunc (ls *LState) SetUpvalue(fn *LFunction, no int, lv LValue) string {\n\tif fn.IsG {\n\t\treturn \"\"\n\t}\n\n\tno--\n\tif no >= 0 && no < len(fn.Upvalues) {\n\t\tfn.Upvalues[no].SetValue(lv)\n\t\treturn fn.Proto.DbgUpvalues[no]\n\t}\n\treturn \"\"\n}\n\n/* }}} */\n\n/* env operations {{{ */\n\nfunc (ls *LState) GetFEnv(obj LValue) LValue {\n\tswitch lv := obj.(type) {\n\tcase *LFunction:\n\t\treturn lv.Env\n\tcase *LUserData:\n\t\treturn lv.Env\n\tcase *LState:\n\t\treturn lv.Env\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) SetFEnv(obj LValue, env LValue) {\n\ttb, ok := env.(*LTable)\n\tif !ok {\n\t\tls.RaiseError(\"cannot use %v as an environment\", env.Type().String())\n\t}\n\n\tswitch lv := obj.(type) {\n\tcase *LFunction:\n\t\tlv.Env = tb\n\tcase *LUserData:\n\t\tlv.Env = tb\n\tcase *LState:\n\t\tlv.Env = tb\n\t}\n\t/* do nothing */\n}\n\n/* }}} */\n\n/* table operations {{{ */\n\nfunc (ls *LState) RawGet(tb *LTable, key LValue) LValue {\n\treturn tb.RawGet(key)\n}\n\nfunc (ls *LState) RawGetInt(tb *LTable, key int) LValue {\n\treturn tb.RawGetInt(key)\n}\n\nfunc (ls *LState) GetField(obj LValue, skey string) LValue {\n\treturn ls.getFieldString(obj, skey)\n}\n\nfunc (ls *LState) GetTable(obj LValue, key LValue) LValue {\n\treturn ls.getField(obj, key)\n}\n\nfunc (ls *LState) RawSet(tb *LTable, key LValue, value LValue) {\n\tif n, ok := key.(LNumber); ok && math.IsNaN(float64(n)) {\n\t\tls.RaiseError(\"table index is NaN\")\n\t} else if key == LNil {\n\t\tls.RaiseError(\"table index is nil\")\n\t}\n\ttb.RawSet(key, value)\n}\n\nfunc (ls *LState) RawSetInt(tb *LTable, key int, value LValue) {\n\ttb.RawSetInt(key, value)\n}\n\nfunc (ls *LState) SetField(obj LValue, key string, value LValue) {\n\tls.setFieldString(obj, key, value)\n}\n\nfunc (ls *LState) SetTable(obj LValue, key LValue, value LValue) {\n\tls.setField(obj, key, value)\n}\n\nfunc (ls *LState) ForEach(tb *LTable, cb func(LValue, LValue)) {\n\ttb.ForEach(cb)\n}\n\nfunc (ls *LState) GetGlobal(name string) LValue {\n\treturn ls.GetField(ls.Get(GlobalsIndex), name)\n}\n\nfunc (ls *LState) SetGlobal(name string, value LValue) {\n\tls.SetField(ls.Get(GlobalsIndex), name, value)\n}\n\nfunc (ls *LState) Next(tb *LTable, key LValue) (LValue, LValue) {\n\treturn tb.Next(key)\n}\n\n/* }}} */\n\n/* unary operations {{{ */\n\nfunc (ls *LState) ObjLen(v1 LValue) int {\n\tif v1.Type() == LTString {\n\t\treturn len(string(v1.(LString)))\n\t}\n\top := ls.metaOp1(v1, \"__len\")\n\tif op.Type() == LTFunction {\n\t\tls.Push(op)\n\t\tls.Push(v1)\n\t\tls.Call(1, 1)\n\t\tret := ls.reg.Pop()\n\t\tif ret.Type() == LTNumber {\n\t\t\treturn int(ret.(LNumber))\n\t\t}\n\t} else if v1.Type() == LTTable {\n\t\treturn v1.(*LTable).Len()\n\t}\n\treturn 0\n}\n\n/* }}} */\n\n/* binary operations {{{ */\n\nfunc (ls *LState) Concat(values ...LValue) string {\n\ttop := ls.reg.Top()\n\tfor _, value := range values {\n\t\tls.reg.Push(value)\n\t}\n\tret := stringConcat(ls, len(values), ls.reg.Top()-1)\n\tls.reg.SetTop(top)\n\treturn LVAsString(ret)\n}\n\nfunc (ls *LState) LessThan(lhs, rhs LValue) bool {\n\treturn lessThan(ls, lhs, rhs)\n}\n\nfunc (ls *LState) Equal(lhs, rhs LValue) bool {\n\treturn equals(ls, lhs, rhs, false)\n}\n\nfunc (ls *LState) RawEqual(lhs, rhs LValue) bool {\n\treturn equals(ls, lhs, rhs, true)\n}\n\n/* }}} */\n\n/* register operations {{{ */\n\nfunc (ls *LState) Register(name string, fn LGFunction) {\n\tls.SetGlobal(name, ls.NewFunction(fn))\n}\n\n/* }}} */\n\n/* load and function call operations {{{ */\n\nfunc (ls *LState) Load(reader io.Reader, name string) (*LFunction, error) {\n\tchunk, err := parse.Parse(reader, name)\n\tif err != nil {\n\t\treturn nil, newApiErrorE(ApiErrorSyntax, err)\n\t}\n\tproto, err := Compile(chunk, name)\n\tif err != nil {\n\t\treturn nil, newApiErrorE(ApiErrorSyntax, err)\n\t}\n\treturn newLFunctionL(proto, ls.currentEnv(), 0), nil\n}\n\nfunc (ls *LState) Call(nargs, nret int) {\n\tls.callR(nargs, nret, -1)\n}\n\nfunc (ls *LState) PCall(nargs, nret int, errfunc *LFunction) (err error) {\n\terr = nil\n\tsp := ls.stack.Sp()\n\tbase := ls.reg.Top() - nargs - 1\n\toldpanic := ls.Panic\n\tls.Panic = panicWithoutTraceback\n\tif errfunc != nil {\n\t\tls.hasErrorFunc = true\n\t}\n\tdefer func() {\n\t\tls.Panic = oldpanic\n\t\tls.hasErrorFunc = false\n\t\trcv := recover()\n\t\tif rcv != nil {\n\t\t\tif _, ok := rcv.(*ApiError); !ok {\n\t\t\t\terr = newApiErrorS(ApiErrorPanic, fmt.Sprint(rcv))\n\t\t\t\tif ls.Options.IncludeGoStackTrace {\n\t\t\t\t\tbuf := make([]byte, 4096)\n\t\t\t\t\truntime.Stack(buf, false)\n\t\t\t\t\terr.(*ApiError).StackTrace = strings.Trim(string(buf), \"\\000\") + \"\\n\" + ls.stackTrace(0)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = rcv.(*ApiError)\n\t\t\t}\n\t\t\tif errfunc != nil {\n\t\t\t\tls.Push(errfunc)\n\t\t\t\tls.Push(err.(*ApiError).Object)\n\t\t\t\tls.Panic = panicWithoutTraceback\n\t\t\t\tdefer func() {\n\t\t\t\t\tls.Panic = oldpanic\n\t\t\t\t\trcv := recover()\n\t\t\t\t\tif rcv != nil {\n\t\t\t\t\t\tif _, ok := rcv.(*ApiError); !ok {\n\t\t\t\t\t\t\terr = newApiErrorS(ApiErrorPanic, fmt.Sprint(rcv))\n\t\t\t\t\t\t\tif ls.Options.IncludeGoStackTrace {\n\t\t\t\t\t\t\t\tbuf := make([]byte, 4096)\n\t\t\t\t\t\t\t\truntime.Stack(buf, false)\n\t\t\t\t\t\t\t\terr.(*ApiError).StackTrace = strings.Trim(string(buf), \"\\000\") + ls.stackTrace(0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = rcv.(*ApiError)\n\t\t\t\t\t\t\terr.(*ApiError).StackTrace = ls.stackTrace(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tls.stack.SetSp(sp)\n\t\t\t\t\t\tls.currentFrame = ls.stack.Last()\n\t\t\t\t\t\tls.reg.SetTop(base)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tls.Call(1, 1)\n\t\t\t\terr = newApiError(ApiErrorError, ls.Get(-1))\n\t\t\t} else if len(err.(*ApiError).StackTrace) == 0 {\n\t\t\t\terr.(*ApiError).StackTrace = ls.stackTrace(0)\n\t\t\t}\n\t\t\tls.stack.SetSp(sp)\n\t\t\tls.currentFrame = ls.stack.Last()\n\t\t\tls.reg.SetTop(base)\n\t\t}\n\t\tls.stack.SetSp(sp)\n\t\tif sp == 0 {\n\t\t\tls.currentFrame = nil\n\t\t}\n\t}()\n\n\tls.Call(nargs, nret)\n\n\treturn\n}\n\nfunc (ls *LState) GPCall(fn LGFunction, data LValue) error {\n\tls.Push(newLFunctionG(fn, ls.currentEnv(), 0))\n\tls.Push(data)\n\treturn ls.PCall(1, MultRet, nil)\n}\n\nfunc (ls *LState) CallByParam(cp P, args ...LValue) error {\n\tls.Push(cp.Fn)\n\tfor _, arg := range args {\n\t\tls.Push(arg)\n\t}\n\n\tif cp.Protect {\n\t\treturn ls.PCall(len(args), cp.NRet, cp.Handler)\n\t}\n\tls.Call(len(args), cp.NRet)\n\treturn nil\n}\n\n/* }}} */\n\n/* metatable operations {{{ */\n\nfunc (ls *LState) GetMetatable(obj LValue) LValue {\n\treturn ls.metatable(obj, false)\n}\n\nfunc (ls *LState) SetMetatable(obj LValue, mt LValue) {\n\tswitch mt.(type) {\n\tcase *LNilType, *LTable:\n\tdefault:\n\t\tls.RaiseError(\"metatable must be a table or nil, but got %v\", mt.Type().String())\n\t}\n\n\tswitch v := obj.(type) {\n\tcase *LTable:\n\t\tv.Metatable = mt\n\tcase *LUserData:\n\t\tv.Metatable = mt\n\tdefault:\n\t\tls.G.builtinMts[int(obj.Type())] = mt\n\t}\n}\n\n/* }}} */\n\n/* coroutine operations {{{ */\n\nfunc (ls *LState) Status(th *LState) string {\n\tstatus := \"suspended\"\n\tif th.Dead {\n\t\tstatus = \"dead\"\n\t} else if ls.G.CurrentThread == th {\n\t\tstatus = \"running\"\n\t} else if ls.Parent == th {\n\t\tstatus = \"normal\"\n\t}\n\treturn status\n}\n\nfunc (ls *LState) Resume(th *LState, fn *LFunction, args ...LValue) (ResumeState, error, []LValue) {\n\tisstarted := th.isStarted()\n\tif !isstarted {\n\t\tbase := 0\n\t\tth.stack.Push(callFrame{\n\t\t\tFn:         fn,\n\t\t\tPc:         0,\n\t\t\tBase:       base,\n\t\t\tLocalBase:  base + 1,\n\t\t\tReturnBase: base,\n\t\t\tNArgs:      0,\n\t\t\tNRet:       MultRet,\n\t\t\tParent:     nil,\n\t\t\tTailCall:   0,\n\t\t})\n\t}\n\n\tif ls.G.CurrentThread == th {\n\t\treturn ResumeError, newApiErrorS(ApiErrorRun, \"can not resume a running thread\"), nil\n\t}\n\tif th.Dead {\n\t\treturn ResumeError, newApiErrorS(ApiErrorRun, \"can not resume a dead thread\"), nil\n\t}\n\tth.Parent = ls\n\tls.G.CurrentThread = th\n\tif !isstarted {\n\t\tcf := th.stack.Last()\n\t\tth.currentFrame = cf\n\t\tth.SetTop(0)\n\t\tfor _, arg := range args {\n\t\t\tth.Push(arg)\n\t\t}\n\t\tcf.NArgs = len(args)\n\t\tth.initCallFrame(cf)\n\t\tth.Panic = panicWithoutTraceback\n\t} else {\n\t\tfor _, arg := range args {\n\t\t\tth.Push(arg)\n\t\t}\n\t}\n\ttop := ls.GetTop()\n\tthreadRun(th)\n\thaserror := LVIsFalse(ls.Get(top + 1))\n\tret := make([]LValue, 0, ls.GetTop())\n\tfor idx := top + 2; idx <= ls.GetTop(); idx++ {\n\t\tret = append(ret, ls.Get(idx))\n\t}\n\tif len(ret) == 0 {\n\t\tret = append(ret, LNil)\n\t}\n\tls.SetTop(top)\n\n\tif haserror {\n\t\treturn ResumeError, newApiError(ApiErrorRun, ret[0]), nil\n\t} else if th.stack.IsEmpty() {\n\t\treturn ResumeOK, nil, ret\n\t}\n\treturn ResumeYield, nil, ret\n}\n\nfunc (ls *LState) Yield(values ...LValue) int {\n\tls.SetTop(0)\n\tfor _, lv := range values {\n\t\tls.Push(lv)\n\t}\n\treturn -1\n}\n\nfunc (ls *LState) XMoveTo(other *LState, n int) {\n\tif ls == other {\n\t\treturn\n\t}\n\ttop := ls.GetTop()\n\tn = intMin(n, top)\n\tfor i := n; i > 0; i-- {\n\t\tother.Push(ls.Get(top - i + 1))\n\t}\n\tls.SetTop(top - n)\n}\n\n/* }}} */\n\n/* GopherLua original APIs {{{ */\n\n// Set maximum memory size. This function can only be called from the main thread.\nfunc (ls *LState) SetMx(mx int) {\n\tif ls.Parent != nil {\n\t\tls.RaiseError(\"sub threads are not allowed to set a memory limit\")\n\t}\n\tgo func() {\n\t\tlimit := uint64(mx * 1024 * 1024) //MB\n\t\tvar s runtime.MemStats\n\t\tfor atomic.LoadInt32(&ls.stop) == 0 {\n\t\t\truntime.ReadMemStats(&s)\n\t\t\tif s.Alloc >= limit {\n\t\t\t\tfmt.Println(\"out of memory\")\n\t\t\t\tos.Exit(3)\n\t\t\t}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n}\n\n// SetContext set a context ctx to this LState. The provided ctx must be non-nil.\nfunc (ls *LState) SetContext(ctx context.Context) {\n\tls.mainLoop = mainLoopWithContext\n\tls.ctx = ctx\n}\n\n// Context returns the LState's context. To change the context, use WithContext.\nfunc (ls *LState) Context() context.Context {\n\treturn ls.ctx\n}\n\n// RemoveContext removes the context associated with this LState and returns this context.\nfunc (ls *LState) RemoveContext() context.Context {\n\toldctx := ls.ctx\n\tls.mainLoop = mainLoop\n\tls.ctx = nil\n\treturn oldctx\n}\n\n// Converts the Lua value at the given acceptable index to the chan LValue.\nfunc (ls *LState) ToChannel(n int) chan LValue {\n\tif lv, ok := ls.Get(n).(LChannel); ok {\n\t\treturn (chan LValue)(lv)\n\t}\n\treturn nil\n}\n\n// RemoveCallerFrame removes the stack frame above the current stack frame. This is useful in tail calls. It returns\n// the new current frame.\nfunc (ls *LState) RemoveCallerFrame() *callFrame {\n\tcs := ls.stack\n\tsp := cs.Sp()\n\tparentFrame := cs.At(sp - 2)\n\tcurrentFrame := cs.At(sp - 1)\n\tparentsParentFrame := parentFrame.Parent\n\t*parentFrame = *currentFrame\n\tparentFrame.Parent = parentsParentFrame\n\tparentFrame.Idx = sp - 2\n\tcs.Pop()\n\treturn parentFrame\n}\n\n/* }}} */\n\n/* }}} */\n\n//\n"
        },
        {
          "name": "_tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "_vm.go",
          "type": "blob",
          "size": 25.771484375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\nfunc mainLoop(L *LState, baseframe *callFrame) {\n\tvar inst uint32\n\tvar cf *callFrame\n\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tL.currentFrame = L.stack.Last()\n\tif L.currentFrame.Fn.IsG {\n\t\tcallGFunction(L, false)\n\t\treturn\n\t}\n\n\tfor {\n\t\tcf = L.currentFrame\n\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\tcf.Pc++\n\t\tif jumpTable[int(inst>>26)](L, inst, baseframe) == 1 {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc mainLoopWithContext(L *LState, baseframe *callFrame) {\n\tvar inst uint32\n\tvar cf *callFrame\n\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tL.currentFrame = L.stack.Last()\n\tif L.currentFrame.Fn.IsG {\n\t\tcallGFunction(L, false)\n\t\treturn\n\t}\n\n\tfor {\n\t\tcf = L.currentFrame\n\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\tcf.Pc++\n\t\tselect {\n\t\tcase <-L.ctx.Done():\n\t\t\tL.RaiseError(L.ctx.Err().Error())\n\t\t\treturn\n\t\tdefault:\n\t\t\tif jumpTable[int(inst>>26)](L, inst, baseframe) == 1 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// regv is the first target register to copy the return values to.\n// It can be reg.top, indicating that the copied values are going into new registers, or it can be below reg.top\n// Indicating that the values should be within the existing registers.\n// b is the available number of return values + 1.\n// n is the desired number of return values.\n// If n more than the available return values then the extra values are set to nil.\n// When this function returns the top of the registry will be set to regv+n.\nfunc copyReturnValues(L *LState, regv, start, n, b int) { // +inline-start\n\tif b == 1 {\n\t\t// +inline-call L.reg.FillNil  regv n\n\t} else {\n\t\t// +inline-call L.reg.CopyRange regv start -1 n\n\t\tif b > 1 && n > (b-1) {\n\t\t\t// +inline-call L.reg.FillNil  regv+b-1 n-(b-1)\n\t\t}\n\t}\n} // +inline-end\n\nfunc switchToParentThread(L *LState, nargs int, haserror bool, kill bool) {\n\tparent := L.Parent\n\tif parent == nil {\n\t\tL.RaiseError(\"can not yield from outside of a coroutine\")\n\t}\n\tL.G.CurrentThread = parent\n\tL.Parent = nil\n\tif !L.wrapped {\n\t\tif haserror {\n\t\t\tparent.Push(LFalse)\n\t\t} else {\n\t\t\tparent.Push(LTrue)\n\t\t}\n\t}\n\tL.XMoveTo(parent, nargs)\n\tL.stack.Pop()\n\toffset := L.currentFrame.LocalBase - L.currentFrame.ReturnBase\n\tL.currentFrame = L.stack.Last()\n\tL.reg.SetTop(L.reg.Top() - offset) // remove 'yield' function(including tailcalled functions)\n\tif kill {\n\t\tL.kill()\n\t}\n}\n\nfunc callGFunction(L *LState, tailcall bool) bool {\n\tframe := L.currentFrame\n\tgfnret := frame.Fn.GFunction(L)\n\tif tailcall {\n\t\tL.currentFrame = L.RemoveCallerFrame()\n\t}\n\n\tif gfnret < 0 {\n\t\tswitchToParentThread(L, L.GetTop(), false, false)\n\t\treturn true\n\t}\n\n\twantret := frame.NRet\n\tif wantret == MultRet {\n\t\twantret = gfnret\n\t}\n\n\tif tailcall && L.Parent != nil && L.stack.Sp() == 1 {\n\t\tswitchToParentThread(L, wantret, false, true)\n\t\treturn true\n\t}\n\n\t// +inline-call L.reg.CopyRange frame.ReturnBase L.reg.Top()-gfnret -1 wantret\n\tL.stack.Pop()\n\tL.currentFrame = L.stack.Last()\n\treturn false\n}\n\nfunc threadRun(L *LState) {\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tif rcv := recover(); rcv != nil {\n\t\t\tvar lv LValue\n\t\t\tif v, ok := rcv.(*ApiError); ok {\n\t\t\t\tlv = v.Object\n\t\t\t} else {\n\t\t\t\tlv = LString(fmt.Sprint(rcv))\n\t\t\t}\n\t\t\tif parent := L.Parent; parent != nil {\n\t\t\t\tif L.wrapped {\n\t\t\t\t\tL.Push(lv)\n\t\t\t\t\tparent.Panic(L)\n\t\t\t\t} else {\n\t\t\t\t\tL.SetTop(0)\n\t\t\t\t\tL.Push(lv)\n\t\t\t\t\tswitchToParentThread(L, 1, true, true)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(rcv)\n\t\t\t}\n\t\t}\n\t}()\n\tL.mainLoop(L, nil)\n}\n\ntype instFunc func(*LState, uint32, *callFrame) int\n\nvar jumpTable [opCodeMax + 1]instFunc\n\nfunc init() {\n\tjumpTable = [opCodeMax + 1]instFunc{\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_MOVE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tv := reg.Get(lbase + B)\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_MOVEN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := reg.Get(lbase + B)\n\t\t\t// +inline-call reg.Set lbase+A v\n\t\t\tcode := cf.Fn.Proto.Code\n\t\t\tpc := cf.Pc\n\t\t\tfor i := 0; i < C; i++ {\n\t\t\t\tinst = code[pc]\n\t\t\t\tpc++\n\t\t\t\tA = int(inst>>18) & 0xff //GETA\n\t\t\t\tB = int(inst & 0x1ff)    //GETB\n\t\t\t\tv := reg.Get(lbase + B)\n\t\t\t\t// +inline-call reg.Set lbase+A v\n\t\t\t}\n\t\t\tcf.Pc = pc\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADK\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\tv := cf.Fn.Proto.Constants[Bx]\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADBOOL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif B != 0 {\n\t\t\t\t// +inline-call reg.Set RA LTrue\n\t\t\t} else {\n\t\t\t\t// +inline-call reg.Set RA LFalse\n\t\t\t}\n\t\t\tif C != 0 {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADNIL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tfor i := RA; i <= lbase+B; i++ {\n\t\t\t\t// +inline-call reg.Set i LNil\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETUPVAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tv := cf.Fn.Upvalues[B].Value()\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETGLOBAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\t//reg.Set(RA, L.getField(cf.Fn.Env, cf.Fn.Proto.Constants[Bx]))\n\t\t\tv := L.getFieldString(cf.Fn.Env, cf.Fn.Proto.stringConstants[Bx])\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := L.getField(reg.Get(lbase+B), L.rkValue(C))\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETTABLEKS\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := L.getFieldString(reg.Get(lbase+B), L.rkString(C))\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETGLOBAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\t//L.setField(cf.Fn.Env, cf.Fn.Proto.Constants[Bx], reg.Get(RA))\n\t\t\tL.setFieldString(cf.Fn.Env, cf.Fn.Proto.stringConstants[Bx], reg.Get(RA))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETUPVAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tcf.Fn.Upvalues[B].SetValue(reg.Get(RA))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tL.setField(reg.Get(RA), L.rkValue(B), L.rkValue(C))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETTABLEKS\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tL.setFieldString(reg.Get(RA), L.rkString(B), L.rkValue(C))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NEWTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := newLTable(B, C)\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SELF\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tselfobj := reg.Get(lbase + B)\n\t\t\tv := L.getFieldString(selfobj, L.rkString(C))\n\t\t\t// +inline-call reg.Set RA v\n\t\t\t// +inline-call reg.Set RA+1 selfobj\n\t\t\treturn 0\n\t\t},\n\t\topArith, // OP_ADD\n\t\topArith, // OP_SUB\n\t\topArith, // OP_MUL\n\t\topArith, // OP_DIV\n\t\topArith, // OP_MOD\n\t\topArith, // OP_POW\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_UNM\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tunaryv := L.rkValue(B)\n\t\t\tif nm, ok := unaryv.(LNumber); ok {\n\t\t\t\t// +inline-call reg.Set RA -nm\n\t\t\t} else {\n\t\t\t\top := L.metaOp1(unaryv, \"__unm\")\n\t\t\t\tif op.Type() == LTFunction {\n\t\t\t\t\treg.Push(op)\n\t\t\t\t\treg.Push(unaryv)\n\t\t\t\t\tL.Call(1, 1)\n\t\t\t\t\t// +inline-call reg.Set RA reg.Pop()\n\t\t\t\t} else if str, ok1 := unaryv.(LString); ok1 {\n\t\t\t\t\tif num, err := parseNumber(string(str)); err == nil {\n\t\t\t\t\t\t// +inline-call reg.Set RA -num\n\t\t\t\t\t} else {\n\t\t\t\t\t\tL.RaiseError(\"__unm undefined\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"__unm undefined\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NOT\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tif LVIsFalse(reg.Get(lbase + B)) {\n\t\t\t\t// +inline-call reg.Set RA LTrue\n\t\t\t} else {\n\t\t\t\t// +inline-call reg.Set RA LFalse\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LEN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tswitch lv := L.rkValue(B).(type) {\n\t\t\tcase LString:\n\t\t\t\t// +inline-call reg.SetNumber RA LNumber(len(lv))\n\t\t\tdefault:\n\t\t\t\top := L.metaOp1(lv, \"__len\")\n\t\t\t\tif op.Type() == LTFunction {\n\t\t\t\t\treg.Push(op)\n\t\t\t\t\treg.Push(lv)\n\t\t\t\t\tL.Call(1, 1)\n\t\t\t\t\tret := reg.Pop()\n\t\t\t\t\tif ret.Type() == LTNumber {\n\t\t\t\t\t\tv, _ := ret.(LNumber)\n\t\t\t\t\t\t// +inline-call reg.SetNumber RA v\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// +inline-call reg.Set RA ret\n\t\t\t\t\t}\n\t\t\t\t} else if lv.Type() == LTTable {\n\t\t\t\t\t// +inline-call reg.SetNumber RA LNumber(lv.(*LTable).Len())\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"__len undefined\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CONCAT\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tRC := lbase + C\n\t\t\tRB := lbase + B\n\t\t\tv := stringConcat(L, RC-RB+1, RC)\n\t\t\t// +inline-call reg.Set RA v\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_JMP\n\t\t\tcf := L.currentFrame\n\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\tcf.Pc += Sbx\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_EQ\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tret := equals(L, L.rkValue(B), L.rkValue(C), false)\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LT\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tret := lessThan(L, L.rkValue(B), L.rkValue(C))\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LE\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tlhs := L.rkValue(B)\n\t\t\trhs := L.rkValue(C)\n\t\t\tret := false\n\n\t\t\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\t\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\t\t\tret = v1 <= v2\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif lhs.Type() != rhs.Type() {\n\t\t\t\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\t}\n\t\t\t\tswitch lhs.Type() {\n\t\t\t\tcase LTString:\n\t\t\t\t\tret = strCmp(string(lhs.(LString)), string(rhs.(LString))) <= 0\n\t\t\t\tdefault:\n\t\t\t\t\tswitch objectRational(L, lhs, rhs, \"__le\") {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tret = true\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tret = false\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tret = !objectRationalWithError(L, rhs, lhs, \"__lt\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TEST\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif LVAsBool(reg.Get(RA)) == (C == 0) {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TESTSET\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif value := reg.Get(lbase + B); LVAsBool(value) != (C == 0) {\n\t\t\t\t// +inline-call reg.Set RA value\n\t\t\t} else {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CALL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tnargs := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnargs = reg.Top() - (RA + 1)\n\t\t\t}\n\t\t\tlv := reg.Get(RA)\n\t\t\tnret := C - 1\n\t\t\tvar callable *LFunction\n\t\t\tvar meta bool\n\t\t\tif fn, ok := lv.(*LFunction); ok {\n\t\t\t\tcallable = fn\n\t\t\t\tmeta = false\n\t\t\t} else {\n\t\t\t\tcallable, meta = L.metaCall(lv)\n\t\t\t}\n\t\t\t// +inline-call L.pushCallFrame callFrame{Fn:callable,Pc:0,Base:RA,LocalBase:RA+1,ReturnBase:RA,NArgs:nargs,NRet:nret,Parent:cf,TailCall:0} lv meta\n\t\t\tif callable.IsG && callGFunction(L, false) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TAILCALL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tnargs := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnargs = reg.Top() - (RA + 1)\n\t\t\t}\n\t\t\tlv := reg.Get(RA)\n\t\t\tvar callable *LFunction\n\t\t\tvar meta bool\n\t\t\tif fn, ok := lv.(*LFunction); ok {\n\t\t\t\tcallable = fn\n\t\t\t\tmeta = false\n\t\t\t} else {\n\t\t\t\tcallable, meta = L.metaCall(lv)\n\t\t\t}\n\t\t\tif callable == nil {\n\t\t\t\tL.RaiseError(\"attempt to call a non-function object\")\n\t\t\t}\n\t\t\t// +inline-call L.closeUpvalues lbase\n\t\t\tif callable.IsG {\n\t\t\t\tluaframe := cf\n\t\t\t\tL.pushCallFrame(callFrame{\n\t\t\t\t\tFn:         callable,\n\t\t\t\t\tPc:         0,\n\t\t\t\t\tBase:       RA,\n\t\t\t\t\tLocalBase:  RA + 1,\n\t\t\t\t\tReturnBase: cf.ReturnBase,\n\t\t\t\t\tNArgs:      nargs,\n\t\t\t\t\tNRet:       cf.NRet,\n\t\t\t\t\tParent:     cf,\n\t\t\t\t\tTailCall:   0,\n\t\t\t\t}, lv, meta)\n\t\t\t\tif callGFunction(L, true) {\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t\tif L.currentFrame == nil || L.currentFrame.Fn.IsG || luaframe == baseframe {\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbase := cf.Base\n\t\t\t\tcf.Fn = callable\n\t\t\t\tcf.Pc = 0\n\t\t\t\tcf.Base = RA\n\t\t\t\tcf.LocalBase = RA + 1\n\t\t\t\tcf.ReturnBase = cf.ReturnBase\n\t\t\t\tcf.NArgs = nargs\n\t\t\t\tcf.NRet = cf.NRet\n\t\t\t\tcf.TailCall++\n\t\t\t\tlbase := cf.LocalBase\n\t\t\t\tif meta {\n\t\t\t\t\tcf.NArgs++\n\t\t\t\t\tL.reg.Insert(lv, cf.LocalBase)\n\t\t\t\t}\n\t\t\t\t// +inline-call L.initCallFrame cf\n\t\t\t\t// +inline-call L.reg.CopyRange base RA -1 reg.Top()-RA-1\n\t\t\t\tcf.Base = base\n\t\t\t\tcf.LocalBase = base + (cf.LocalBase - lbase + 1)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_RETURN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\t// +inline-call L.closeUpvalues lbase\n\t\t\tnret := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnret = reg.Top() - RA\n\t\t\t}\n\t\t\tn := cf.NRet\n\t\t\tif cf.NRet == MultRet {\n\t\t\t\tn = nret\n\t\t\t}\n\n\t\t\tif L.Parent != nil && L.stack.Sp() == 1 {\n\t\t\t\t// +inline-call copyReturnValues L reg.Top() RA n B\n\t\t\t\tswitchToParentThread(L, n, false, true)\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tislast := baseframe == L.stack.Pop() || L.stack.IsEmpty()\n\t\t\t// +inline-call copyReturnValues L cf.ReturnBase RA n B\n\t\t\tL.currentFrame = L.stack.Last()\n\t\t\tif islast || L.currentFrame == nil || L.currentFrame.Fn.IsG {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_FORLOOP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tif init, ok1 := reg.Get(RA).(LNumber); ok1 {\n\t\t\t\tif limit, ok2 := reg.Get(RA + 1).(LNumber); ok2 {\n\t\t\t\t\tif step, ok3 := reg.Get(RA + 2).(LNumber); ok3 {\n\t\t\t\t\t\tinit += step\n\t\t\t\t\t\tv := LNumber(init)\n\t\t\t\t\t\t// +inline-call reg.SetNumber RA v\n\t\t\t\t\t\tif (step > 0 && init <= limit) || (step <= 0 && init >= limit) {\n\t\t\t\t\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\t\t\t\t\tcf.Pc += Sbx\n\t\t\t\t\t\t\t// +inline-call reg.SetNumber RA+3 v\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// +inline-call reg.SetTop RA+1\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tL.RaiseError(\"for statement step must be a number\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"for statement limit must be a number\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"for statement init must be a number\")\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_FORPREP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\tif init, ok1 := reg.Get(RA).(LNumber); ok1 {\n\t\t\t\tif step, ok2 := reg.Get(RA + 2).(LNumber); ok2 {\n\t\t\t\t\t// +inline-call reg.SetNumber RA LNumber(init-step)\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"for statement step must be a number\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"for statement init must be a number\")\n\t\t\t}\n\t\t\tcf.Pc += Sbx\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TFORLOOP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tnret := C\n\t\t\t// +inline-call reg.SetTop RA+3+2\n\t\t\t// +inline-call reg.Set RA+3+2 reg.Get(RA+2)\n\t\t\t// +inline-call reg.Set RA+3+1 reg.Get(RA+1)\n\t\t\t// +inline-call reg.Set RA+3 reg.Get(RA)\n\t\t\tL.callR(2, nret, RA+3)\n\t\t\tif value := reg.Get(RA + 3); value != LNil {\n\t\t\t\t// +inline-call reg.Set RA+2 value\n\t\t\t\tpc := cf.Fn.Proto.Code[cf.Pc]\n\t\t\t\tcf.Pc += int(pc&0x3ffff) - opMaxArgSbx\n\t\t\t}\n\t\t\tcf.Pc++\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETLIST\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif C == 0 {\n\t\t\t\tC = int(cf.Fn.Proto.Code[cf.Pc])\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\toffset := (C - 1) * FieldsPerFlush\n\t\t\ttable := reg.Get(RA).(*LTable)\n\t\t\tnelem := B\n\t\t\tif B == 0 {\n\t\t\t\tnelem = reg.Top() - RA - 1\n\t\t\t}\n\t\t\tfor i := 1; i <= nelem; i++ {\n\t\t\t\ttable.RawSetInt(offset+i, reg.Get(RA+i))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CLOSE\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\t// +inline-call L.closeUpvalues RA\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CLOSURE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\tproto := cf.Fn.Proto.FunctionPrototypes[Bx]\n\t\t\tclosure := newLFunctionL(proto, cf.Fn.Env, int(proto.NumUpvalues))\n\t\t\t// +inline-call reg.Set RA closure\n\t\t\tfor i := 0; i < int(proto.NumUpvalues); i++ {\n\t\t\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\t\t\tcf.Pc++\n\t\t\t\tB := opGetArgB(inst)\n\t\t\t\tswitch opGetOpCode(inst) {\n\t\t\t\tcase OP_MOVE:\n\t\t\t\t\tclosure.Upvalues[i] = L.findUpvalue(lbase + B)\n\t\t\t\tcase OP_GETUPVAL:\n\t\t\t\t\tclosure.Upvalues[i] = cf.Fn.Upvalues[B]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_VARARG\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tnparams := int(cf.Fn.Proto.NumParameters)\n\t\t\tnvarargs := cf.NArgs - nparams\n\t\t\tif nvarargs < 0 {\n\t\t\t\tnvarargs = 0\n\t\t\t}\n\t\t\tnwant := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnwant = nvarargs\n\t\t\t}\n\t\t\t// +inline-call reg.CopyRange RA cf.Base+nparams+1 cf.LocalBase nwant\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NOP\n\t\t\treturn 0\n\t\t},\n\t}\n}\n\nfunc opArith(L *LState, inst uint32, baseframe *callFrame) int { //OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_POW\n\treg := L.reg\n\tcf := L.currentFrame\n\tlbase := cf.LocalBase\n\tA := int(inst>>18) & 0xff //GETA\n\tRA := lbase + A\n\topcode := int(inst >> 26) //GETOPCODE\n\tB := int(inst & 0x1ff)    //GETB\n\tC := int(inst>>9) & 0x1ff //GETC\n\tlhs := L.rkValue(B)\n\trhs := L.rkValue(C)\n\tv1, ok1 := lhs.(LNumber)\n\tv2, ok2 := rhs.(LNumber)\n\tif ok1 && ok2 {\n\t\tv := numberArith(L, opcode, LNumber(v1), LNumber(v2))\n\t\t// +inline-call reg.SetNumber RA v\n\t} else {\n\t\tv := objectArith(L, opcode, lhs, rhs)\n\t\t// +inline-call reg.Set RA v\n\t}\n\treturn 0\n}\n\nfunc luaModulo(lhs, rhs LNumber) LNumber {\n\tflhs := float64(lhs)\n\tfrhs := float64(rhs)\n\tv := math.Mod(flhs, frhs)\n\tif frhs > 0 && v < 0 || frhs < 0 && v > 0 {\n\t\tv += frhs\n\t}\n\treturn LNumber(v)\n}\n\nfunc numberArith(L *LState, opcode int, lhs, rhs LNumber) LNumber {\n\tswitch opcode {\n\tcase OP_ADD:\n\t\treturn lhs + rhs\n\tcase OP_SUB:\n\t\treturn lhs - rhs\n\tcase OP_MUL:\n\t\treturn lhs * rhs\n\tcase OP_DIV:\n\t\treturn lhs / rhs\n\tcase OP_MOD:\n\t\treturn luaModulo(lhs, rhs)\n\tcase OP_POW:\n\t\tflhs := float64(lhs)\n\t\tfrhs := float64(rhs)\n\t\treturn LNumber(math.Pow(flhs, frhs))\n\t}\n\tpanic(\"should not reach here\")\n\treturn LNumber(0)\n}\n\nfunc objectArith(L *LState, opcode int, lhs, rhs LValue) LValue {\n\tevent := \"\"\n\tswitch opcode {\n\tcase OP_ADD:\n\t\tevent = \"__add\"\n\tcase OP_SUB:\n\t\tevent = \"__sub\"\n\tcase OP_MUL:\n\t\tevent = \"__mul\"\n\tcase OP_DIV:\n\t\tevent = \"__div\"\n\tcase OP_MOD:\n\t\tevent = \"__mod\"\n\tcase OP_POW:\n\t\tevent = \"__pow\"\n\t}\n\top := L.metaOp2(lhs, rhs, event)\n\tif _, ok := op.(*LFunction); ok {\n\t\tL.reg.Push(op)\n\t\tL.reg.Push(lhs)\n\t\tL.reg.Push(rhs)\n\t\tL.Call(2, 1)\n\t\treturn L.reg.Pop()\n\t}\n\tif str, ok := lhs.(LString); ok {\n\t\tif lnum, err := parseNumber(string(str)); err == nil {\n\t\t\tlhs = lnum\n\t\t}\n\t}\n\tif str, ok := rhs.(LString); ok {\n\t\tif rnum, err := parseNumber(string(str)); err == nil {\n\t\t\trhs = rnum\n\t\t}\n\t}\n\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\treturn numberArith(L, opcode, LNumber(v1), LNumber(v2))\n\t\t}\n\t}\n\tL.RaiseError(fmt.Sprintf(\"cannot perform %v operation between %v and %v\",\n\t\tstrings.TrimLeft(event, \"_\"), lhs.Type().String(), rhs.Type().String()))\n\n\treturn LNil\n}\n\nfunc stringConcat(L *LState, total, last int) LValue {\n\trhs := L.reg.Get(last)\n\ttotal--\n\tfor i := last - 1; total > 0; {\n\t\tlhs := L.reg.Get(i)\n\t\tif !(LVCanConvToString(lhs) && LVCanConvToString(rhs)) {\n\t\t\top := L.metaOp2(lhs, rhs, \"__concat\")\n\t\t\tif op.Type() == LTFunction {\n\t\t\t\tL.reg.Push(op)\n\t\t\t\tL.reg.Push(lhs)\n\t\t\t\tL.reg.Push(rhs)\n\t\t\t\tL.Call(2, 1)\n\t\t\t\trhs = L.reg.Pop()\n\t\t\t\ttotal--\n\t\t\t\ti--\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"cannot perform concat operation between %v and %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\treturn LNil\n\t\t\t}\n\t\t} else {\n\t\t\tbuf := make([]string, total+1)\n\t\t\tbuf[total] = LVAsString(rhs)\n\t\t\tfor total > 0 {\n\t\t\t\tlhs = L.reg.Get(i)\n\t\t\t\tif !LVCanConvToString(lhs) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tbuf[total-1] = LVAsString(lhs)\n\t\t\t\ti--\n\t\t\t\ttotal--\n\t\t\t}\n\t\t\trhs = LString(strings.Join(buf, \"\"))\n\t\t}\n\t}\n\treturn rhs\n}\n\nfunc lessThan(L *LState, lhs, rhs LValue) bool {\n\t// optimization for numbers\n\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\treturn v1 < v2\n\t\t}\n\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t}\n\tif lhs.Type() != rhs.Type() {\n\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\treturn false\n\t}\n\tret := false\n\tswitch lhs.Type() {\n\tcase LTString:\n\t\tret = strCmp(string(lhs.(LString)), string(rhs.(LString))) < 0\n\tdefault:\n\t\tret = objectRationalWithError(L, lhs, rhs, \"__lt\")\n\t}\n\treturn ret\n}\n\nfunc equals(L *LState, lhs, rhs LValue, raw bool) bool {\n\tlt := lhs.Type()\n\tif lt != rhs.Type() {\n\t\treturn false\n\t}\n\n\tret := false\n\tswitch lt {\n\tcase LTNil:\n\t\tret = true\n\tcase LTNumber:\n\t\tv1, _ := lhs.(LNumber)\n\t\tv2, _ := rhs.(LNumber)\n\t\tret = v1 == v2\n\tcase LTBool:\n\t\tret = bool(lhs.(LBool)) == bool(rhs.(LBool))\n\tcase LTString:\n\t\tret = string(lhs.(LString)) == string(rhs.(LString))\n\tcase LTUserData, LTTable:\n\t\tif lhs == rhs {\n\t\t\tret = true\n\t\t} else if !raw {\n\t\t\tswitch objectRational(L, lhs, rhs, \"__eq\") {\n\t\t\tcase 1:\n\t\t\t\tret = true\n\t\t\tdefault:\n\t\t\t\tret = false\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tret = lhs == rhs\n\t}\n\treturn ret\n}\n\nfunc objectRationalWithError(L *LState, lhs, rhs LValue, event string) bool {\n\tswitch objectRational(L, lhs, rhs, event) {\n\tcase 1:\n\t\treturn true\n\tcase 0:\n\t\treturn false\n\t}\n\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\treturn false\n}\n\nfunc objectRational(L *LState, lhs, rhs LValue, event string) int {\n\tm1 := L.metaOp1(lhs, event)\n\tm2 := L.metaOp1(rhs, event)\n\tif m1.Type() == LTFunction && m1 == m2 {\n\t\tL.reg.Push(m1)\n\t\tL.reg.Push(lhs)\n\t\tL.reg.Push(rhs)\n\t\tL.Call(2, 1)\n\t\tif LVAsBool(L.reg.Pop()) {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t}\n\treturn -1\n}\n"
        },
        {
          "name": "alloc.go",
          "type": "blob",
          "size": 2.08984375,
          "content": "package lua\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\n// iface is an internal representation of the go-interface.\ntype iface struct {\n\titab unsafe.Pointer\n\tword unsafe.Pointer\n}\n\nconst preloadLimit LNumber = 128\n\nvar _fv float64\nvar _uv uintptr\n\nvar preloads [int(preloadLimit)]LValue\n\nfunc init() {\n\tfor i := 0; i < int(preloadLimit); i++ {\n\t\tpreloads[i] = LNumber(i)\n\t}\n}\n\n// allocator is a fast bulk memory allocator for the LValue.\ntype allocator struct {\n\tsize    int\n\tfptrs   []float64\n\tfheader *reflect.SliceHeader\n\n\tscratchValue  LValue\n\tscratchValueP *iface\n}\n\nfunc newAllocator(size int) *allocator {\n\tal := &allocator{\n\t\tsize:    size,\n\t\tfptrs:   make([]float64, 0, size),\n\t\tfheader: nil,\n\t}\n\tal.fheader = (*reflect.SliceHeader)(unsafe.Pointer(&al.fptrs))\n\tal.scratchValue = LNumber(0)\n\tal.scratchValueP = (*iface)(unsafe.Pointer(&al.scratchValue))\n\n\treturn al\n}\n\n// LNumber2I takes a number value and returns an interface LValue representing the same number.\n// Converting an LNumber to a LValue naively, by doing:\n// `var val LValue = myLNumber`\n// will result in an individual heap alloc of 8 bytes for the float value. LNumber2I amortizes the cost and memory\n// overhead of these allocs by allocating blocks of floats instead.\n// The downside of this is that all of the floats on a given block have to become eligible for gc before the block\n// as a whole can be gc-ed.\nfunc (al *allocator) LNumber2I(v LNumber) LValue {\n\t// first check for shared preloaded numbers\n\tif v >= 0 && v < preloadLimit && float64(v) == float64(int64(v)) {\n\t\treturn preloads[int(v)]\n\t}\n\n\t// check if we need a new alloc page\n\tif cap(al.fptrs) == len(al.fptrs) {\n\t\tal.fptrs = make([]float64, 0, al.size)\n\t\tal.fheader = (*reflect.SliceHeader)(unsafe.Pointer(&al.fptrs))\n\t}\n\n\t// alloc a new float, and store our value into it\n\tal.fptrs = append(al.fptrs, float64(v))\n\tfptr := &al.fptrs[len(al.fptrs)-1]\n\n\t// hack our scratch LValue to point to our allocated value\n\t// this scratch lvalue is copied when this function returns meaning the scratch value can be reused\n\t// on the next call\n\tal.scratchValueP.word = unsafe.Pointer(fptr)\n\n\treturn al.scratchValue\n}\n"
        },
        {
          "name": "ast",
          "type": "tree",
          "content": null
        },
        {
          "name": "auxlib.go",
          "type": "blob",
          "size": 9.1689453125,
          "content": "package lua\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\n/* checkType {{{ */\n\nfunc (ls *LState) CheckAny(n int) LValue {\n\tif n > ls.GetTop() {\n\t\tls.ArgError(n, \"value expected\")\n\t}\n\treturn ls.Get(n)\n}\n\nfunc (ls *LState) CheckInt(n int) int {\n\tv := ls.Get(n)\n\tif intv, ok := v.(LNumber); ok {\n\t\treturn int(intv)\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) CheckInt64(n int) int64 {\n\tv := ls.Get(n)\n\tif intv, ok := v.(LNumber); ok {\n\t\treturn int64(intv)\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) CheckNumber(n int) LNumber {\n\tv := ls.Get(n)\n\tif lv, ok := v.(LNumber); ok {\n\t\treturn lv\n\t}\n\tif lv, ok := v.(LString); ok {\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn num\n\t\t}\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) CheckString(n int) string {\n\tv := ls.Get(n)\n\tif lv, ok := v.(LString); ok {\n\t\treturn string(lv)\n\t} else if LVCanConvToString(v) {\n\t\treturn ls.ToString(n)\n\t}\n\tls.TypeError(n, LTString)\n\treturn \"\"\n}\n\nfunc (ls *LState) CheckBool(n int) bool {\n\tv := ls.Get(n)\n\tif lv, ok := v.(LBool); ok {\n\t\treturn bool(lv)\n\t}\n\tls.TypeError(n, LTBool)\n\treturn false\n}\n\nfunc (ls *LState) CheckTable(n int) *LTable {\n\tv := ls.Get(n)\n\tif lv, ok := v.(*LTable); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTTable)\n\treturn nil\n}\n\nfunc (ls *LState) CheckFunction(n int) *LFunction {\n\tv := ls.Get(n)\n\tif lv, ok := v.(*LFunction); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTFunction)\n\treturn nil\n}\n\nfunc (ls *LState) CheckUserData(n int) *LUserData {\n\tv := ls.Get(n)\n\tif lv, ok := v.(*LUserData); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTUserData)\n\treturn nil\n}\n\nfunc (ls *LState) CheckThread(n int) *LState {\n\tv := ls.Get(n)\n\tif lv, ok := v.(*LState); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTThread)\n\treturn nil\n}\n\nfunc (ls *LState) CheckType(n int, typ LValueType) {\n\tv := ls.Get(n)\n\tif v.Type() != typ {\n\t\tls.TypeError(n, typ)\n\t}\n}\n\nfunc (ls *LState) CheckTypes(n int, typs ...LValueType) {\n\tvt := ls.Get(n).Type()\n\tfor _, typ := range typs {\n\t\tif vt == typ {\n\t\t\treturn\n\t\t}\n\t}\n\tbuf := []string{}\n\tfor _, typ := range typs {\n\t\tbuf = append(buf, typ.String())\n\t}\n\tls.ArgError(n, strings.Join(buf, \" or \")+\" expected, got \"+ls.Get(n).Type().String())\n}\n\nfunc (ls *LState) CheckOption(n int, options []string) int {\n\tstr := ls.CheckString(n)\n\tfor i, v := range options {\n\t\tif v == str {\n\t\t\treturn i\n\t\t}\n\t}\n\tls.ArgError(n, fmt.Sprintf(\"invalid option: %s (must be one of %s)\", str, strings.Join(options, \",\")))\n\treturn 0\n}\n\n/* }}} */\n\n/* optType {{{ */\n\nfunc (ls *LState) OptInt(n int, d int) int {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif intv, ok := v.(LNumber); ok {\n\t\treturn int(intv)\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) OptInt64(n int, d int64) int64 {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif intv, ok := v.(LNumber); ok {\n\t\treturn int64(intv)\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) OptNumber(n int, d LNumber) LNumber {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(LNumber); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTNumber)\n\treturn 0\n}\n\nfunc (ls *LState) OptString(n int, d string) string {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(LString); ok {\n\t\treturn string(lv)\n\t}\n\tls.TypeError(n, LTString)\n\treturn \"\"\n}\n\nfunc (ls *LState) OptBool(n int, d bool) bool {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(LBool); ok {\n\t\treturn bool(lv)\n\t}\n\tls.TypeError(n, LTBool)\n\treturn false\n}\n\nfunc (ls *LState) OptTable(n int, d *LTable) *LTable {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(*LTable); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTTable)\n\treturn nil\n}\n\nfunc (ls *LState) OptFunction(n int, d *LFunction) *LFunction {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(*LFunction); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTFunction)\n\treturn nil\n}\n\nfunc (ls *LState) OptUserData(n int, d *LUserData) *LUserData {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn d\n\t}\n\tif lv, ok := v.(*LUserData); ok {\n\t\treturn lv\n\t}\n\tls.TypeError(n, LTUserData)\n\treturn nil\n}\n\n/* }}} */\n\n/* error operations {{{ */\n\nfunc (ls *LState) ArgError(n int, message string) {\n\tls.RaiseError(\"bad argument #%v to %v (%v)\", n, ls.rawFrameFuncName(ls.currentFrame), message)\n}\n\nfunc (ls *LState) TypeError(n int, typ LValueType) {\n\tls.RaiseError(\"bad argument #%v to %v (%v expected, got %v)\", n, ls.rawFrameFuncName(ls.currentFrame), typ.String(), ls.Get(n).Type().String())\n}\n\n/* }}} */\n\n/* debug operations {{{ */\n\nfunc (ls *LState) Where(level int) string {\n\treturn ls.where(level, false)\n}\n\n/* }}} */\n\n/* table operations {{{ */\n\nfunc (ls *LState) FindTable(obj *LTable, n string, size int) LValue {\n\tnames := strings.Split(n, \".\")\n\tcurobj := obj\n\tfor _, name := range names {\n\t\tif curobj.Type() != LTTable {\n\t\t\treturn LNil\n\t\t}\n\t\tnextobj := ls.RawGet(curobj, LString(name))\n\t\tif nextobj == LNil {\n\t\t\ttb := ls.CreateTable(0, size)\n\t\t\tls.RawSet(curobj, LString(name), tb)\n\t\t\tcurobj = tb\n\t\t} else if nextobj.Type() != LTTable {\n\t\t\treturn LNil\n\t\t} else {\n\t\t\tcurobj = nextobj.(*LTable)\n\t\t}\n\t}\n\treturn curobj\n}\n\n/* }}} */\n\n/* register operations {{{ */\n\nfunc (ls *LState) RegisterModule(name string, funcs map[string]LGFunction) LValue {\n\ttb := ls.FindTable(ls.Get(RegistryIndex).(*LTable), \"_LOADED\", 1)\n\tmod := ls.GetField(tb, name)\n\tif mod.Type() != LTTable {\n\t\tnewmod := ls.FindTable(ls.Get(GlobalsIndex).(*LTable), name, len(funcs))\n\t\tif newmodtb, ok := newmod.(*LTable); !ok {\n\t\t\tls.RaiseError(\"name conflict for module(%v)\", name)\n\t\t} else {\n\t\t\tfor fname, fn := range funcs {\n\t\t\t\tnewmodtb.RawSetString(fname, ls.NewFunction(fn))\n\t\t\t}\n\t\t\tls.SetField(tb, name, newmodtb)\n\t\t\treturn newmodtb\n\t\t}\n\t}\n\treturn mod\n}\n\nfunc (ls *LState) SetFuncs(tb *LTable, funcs map[string]LGFunction, upvalues ...LValue) *LTable {\n\tfor fname, fn := range funcs {\n\t\ttb.RawSetString(fname, ls.NewClosure(fn, upvalues...))\n\t}\n\treturn tb\n}\n\n/* }}} */\n\n/* metatable operations {{{ */\n\nfunc (ls *LState) NewTypeMetatable(typ string) *LTable {\n\tregtable := ls.Get(RegistryIndex)\n\tmt := ls.GetField(regtable, typ)\n\tif tb, ok := mt.(*LTable); ok {\n\t\treturn tb\n\t}\n\tmtnew := ls.NewTable()\n\tls.SetField(regtable, typ, mtnew)\n\treturn mtnew\n}\n\nfunc (ls *LState) GetMetaField(obj LValue, event string) LValue {\n\treturn ls.metaOp1(obj, event)\n}\n\nfunc (ls *LState) GetTypeMetatable(typ string) LValue {\n\treturn ls.GetField(ls.Get(RegistryIndex), typ)\n}\n\nfunc (ls *LState) CallMeta(obj LValue, event string) LValue {\n\top := ls.metaOp1(obj, event)\n\tif op.Type() == LTFunction {\n\t\tls.reg.Push(op)\n\t\tls.reg.Push(obj)\n\t\tls.Call(1, 1)\n\t\treturn ls.reg.Pop()\n\t}\n\treturn LNil\n}\n\n/* }}} */\n\n/* load and function call operations {{{ */\n\nfunc (ls *LState) LoadFile(path string) (*LFunction, error) {\n\tvar file *os.File\n\tvar err error\n\tif len(path) == 0 {\n\t\tfile = os.Stdin\n\t} else {\n\t\tfile, err = os.Open(path)\n\t\tdefer file.Close()\n\t\tif err != nil {\n\t\t\treturn nil, newApiErrorE(ApiErrorFile, err)\n\t\t}\n\t}\n\n\treader := bufio.NewReader(file)\n\t// get the first character.\n\tc, err := reader.ReadByte()\n\tif err != nil && err != io.EOF {\n\t\treturn nil, newApiErrorE(ApiErrorFile, err)\n\t}\n\tif c == byte('#') {\n\t\t// Unix exec. file?\n\t\t// skip first line\n\t\t_, err, _ = readBufioLine(reader)\n\t\tif err != nil {\n\t\t\treturn nil, newApiErrorE(ApiErrorFile, err)\n\t\t}\n\t}\n\n\tif err != io.EOF {\n\t\t// if the file is not empty,\n\t\t// unread the first character of the file or newline character(readBufioLine's last byte).\n\t\terr = reader.UnreadByte()\n\t\tif err != nil {\n\t\t\treturn nil, newApiErrorE(ApiErrorFile, err)\n\t\t}\n\t}\n\n\treturn ls.Load(reader, path)\n}\n\nfunc (ls *LState) LoadString(source string) (*LFunction, error) {\n\treturn ls.Load(strings.NewReader(source), \"<string>\")\n}\n\nfunc (ls *LState) DoFile(path string) error {\n\tif fn, err := ls.LoadFile(path); err != nil {\n\t\treturn err\n\t} else {\n\t\tls.Push(fn)\n\t\treturn ls.PCall(0, MultRet, nil)\n\t}\n}\n\nfunc (ls *LState) DoString(source string) error {\n\tif fn, err := ls.LoadString(source); err != nil {\n\t\treturn err\n\t} else {\n\t\tls.Push(fn)\n\t\treturn ls.PCall(0, MultRet, nil)\n\t}\n}\n\n/* }}} */\n\n/* GopherLua original APIs {{{ */\n\n// ToStringMeta returns string representation of given LValue.\n// This method calls the `__tostring` meta method if defined.\nfunc (ls *LState) ToStringMeta(lv LValue) LValue {\n\tif fn, ok := ls.metaOp1(lv, \"__tostring\").(*LFunction); ok {\n\t\tls.Push(fn)\n\t\tls.Push(lv)\n\t\tls.Call(1, 1)\n\t\treturn ls.reg.Pop()\n\t} else {\n\t\treturn LString(lv.String())\n\t}\n}\n\n// Set a module loader to the package.preload table.\nfunc (ls *LState) PreloadModule(name string, loader LGFunction) {\n\tpreload := ls.GetField(ls.GetField(ls.Get(EnvironIndex), \"package\"), \"preload\")\n\tif _, ok := preload.(*LTable); !ok {\n\t\tls.RaiseError(\"package.preload must be a table\")\n\t}\n\tls.SetField(preload, name, ls.NewFunction(loader))\n}\n\n// Checks whether the given index is an LChannel and returns this channel.\nfunc (ls *LState) CheckChannel(n int) chan LValue {\n\tv := ls.Get(n)\n\tif ch, ok := v.(LChannel); ok {\n\t\treturn (chan LValue)(ch)\n\t}\n\tls.TypeError(n, LTChannel)\n\treturn nil\n}\n\n// If the given index is a LChannel, returns this channel. If this argument is absent or is nil, returns ch. Otherwise, raises an error.\nfunc (ls *LState) OptChannel(n int, ch chan LValue) chan LValue {\n\tv := ls.Get(n)\n\tif v == LNil {\n\t\treturn ch\n\t}\n\tif ch, ok := v.(LChannel); ok {\n\t\treturn (chan LValue)(ch)\n\t}\n\tls.TypeError(n, LTChannel)\n\treturn nil\n}\n\n/* }}} */\n\n//\n"
        },
        {
          "name": "auxlib_test.go",
          "type": "blob",
          "size": 7.7607421875,
          "content": "package lua\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestCheckInt(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, 10, L.CheckInt(2))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.CheckInt(3)\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestCheckInt64(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, int64(10), L.CheckInt64(2))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.CheckInt64(3)\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestCheckNumber(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, LNumber(10), L.CheckNumber(2))\n\t\tL.Push(LString(\"11\"))\n\t\terrorIfNotEqual(t, LNumber(11), L.CheckNumber(3))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.CheckNumber(4)\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestCheckString(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LString(\"aaa\"))\n\t\terrorIfNotEqual(t, \"aaa\", L.CheckString(2))\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, \"10\", L.CheckString(3))\n\t\tL.Push(L.NewTable())\n\t\tL.CheckString(4)\n\t\treturn 0\n\t}, \"string expected, got table\")\n}\n\nfunc TestCheckBool(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LTrue)\n\t\terrorIfNotEqual(t, true, L.CheckBool(2))\n\t\tL.Push(LNumber(10))\n\t\tL.CheckBool(3)\n\t\treturn 0\n\t}, \"boolean expected, got number\")\n}\n\nfunc TestCheckTable(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\ttbl := L.NewTable()\n\t\tL.Push(tbl)\n\t\terrorIfNotEqual(t, tbl, L.CheckTable(2))\n\t\tL.Push(LNumber(10))\n\t\tL.CheckTable(3)\n\t\treturn 0\n\t}, \"table expected, got number\")\n}\n\nfunc TestCheckFunction(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tfn := L.NewFunction(func(l *LState) int { return 0 })\n\t\tL.Push(fn)\n\t\terrorIfNotEqual(t, fn, L.CheckFunction(2))\n\t\tL.Push(LNumber(10))\n\t\tL.CheckFunction(3)\n\t\treturn 0\n\t}, \"function expected, got number\")\n}\n\nfunc TestCheckUserData(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tud := L.NewUserData()\n\t\tL.Push(ud)\n\t\terrorIfNotEqual(t, ud, L.CheckUserData(2))\n\t\tL.Push(LNumber(10))\n\t\tL.CheckUserData(3)\n\t\treturn 0\n\t}, \"userdata expected, got number\")\n}\n\nfunc TestCheckThread(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tth, _ := L.NewThread()\n\t\tL.Push(th)\n\t\terrorIfNotEqual(t, th, L.CheckThread(2))\n\t\tL.Push(LNumber(10))\n\t\tL.CheckThread(3)\n\t\treturn 0\n\t}, \"thread expected, got number\")\n}\n\nfunc TestCheckChannel(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tch := make(chan LValue)\n\t\tL.Push(LChannel(ch))\n\t\terrorIfNotEqual(t, ch, L.CheckChannel(2))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.CheckChannel(3)\n\t\treturn 0\n\t}, \"channel expected, got string\")\n}\n\nfunc TestCheckType(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LNumber(10))\n\t\tL.CheckType(2, LTNumber)\n\t\tL.CheckType(2, LTString)\n\t\treturn 0\n\t}, \"string expected, got number\")\n}\n\nfunc TestCheckTypes(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LNumber(10))\n\t\tL.CheckTypes(2, LTString, LTBool, LTNumber)\n\t\tL.CheckTypes(2, LTString, LTBool)\n\t\treturn 0\n\t}, \"string or boolean expected, got number\")\n}\n\nfunc TestCheckOption(t *testing.T) {\n\topts := []string{\n\t\t\"opt1\",\n\t\t\"opt2\",\n\t\t\"opt3\",\n\t}\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Push(LString(\"opt1\"))\n\t\terrorIfNotEqual(t, 0, L.CheckOption(2, opts))\n\t\tL.Push(LString(\"opt5\"))\n\t\tL.CheckOption(3, opts)\n\t\treturn 0\n\t}, \"invalid option: opt5 \\\\(must be one of opt1,opt2,opt3\\\\)\")\n}\n\nfunc TestOptInt(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\terrorIfNotEqual(t, 99, L.OptInt(1, 99))\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, 10, L.OptInt(2, 99))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.OptInt(3, 99)\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestOptInt64(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\terrorIfNotEqual(t, int64(99), L.OptInt64(1, int64(99)))\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, int64(10), L.OptInt64(2, int64(99)))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.OptInt64(3, int64(99))\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestOptNumber(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\terrorIfNotEqual(t, LNumber(99), L.OptNumber(1, LNumber(99)))\n\t\tL.Push(LNumber(10))\n\t\terrorIfNotEqual(t, LNumber(10), L.OptNumber(2, LNumber(99)))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.OptNumber(3, LNumber(99))\n\t\treturn 0\n\t}, \"number expected, got string\")\n}\n\nfunc TestOptString(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\terrorIfNotEqual(t, \"bbb\", L.OptString(1, \"bbb\"))\n\t\tL.Push(LString(\"aaa\"))\n\t\terrorIfNotEqual(t, \"aaa\", L.OptString(2, \"bbb\"))\n\t\tL.Push(LNumber(10))\n\t\tL.OptString(3, \"bbb\")\n\t\treturn 0\n\t}, \"string expected, got number\")\n}\n\nfunc TestOptBool(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\terrorIfNotEqual(t, true, L.OptBool(1, true))\n\t\tL.Push(LTrue)\n\t\terrorIfNotEqual(t, true, L.OptBool(2, false))\n\t\tL.Push(LNumber(10))\n\t\tL.OptBool(3, false)\n\t\treturn 0\n\t}, \"boolean expected, got number\")\n}\n\nfunc TestOptTable(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tdeftbl := L.NewTable()\n\t\terrorIfNotEqual(t, deftbl, L.OptTable(1, deftbl))\n\t\ttbl := L.NewTable()\n\t\tL.Push(tbl)\n\t\terrorIfNotEqual(t, tbl, L.OptTable(2, deftbl))\n\t\tL.Push(LNumber(10))\n\t\tL.OptTable(3, deftbl)\n\t\treturn 0\n\t}, \"table expected, got number\")\n}\n\nfunc TestOptFunction(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tdeffn := L.NewFunction(func(l *LState) int { return 0 })\n\t\terrorIfNotEqual(t, deffn, L.OptFunction(1, deffn))\n\t\tfn := L.NewFunction(func(l *LState) int { return 0 })\n\t\tL.Push(fn)\n\t\terrorIfNotEqual(t, fn, L.OptFunction(2, deffn))\n\t\tL.Push(LNumber(10))\n\t\tL.OptFunction(3, deffn)\n\t\treturn 0\n\t}, \"function expected, got number\")\n}\n\nfunc TestOptUserData(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tdefud := L.NewUserData()\n\t\terrorIfNotEqual(t, defud, L.OptUserData(1, defud))\n\t\tud := L.NewUserData()\n\t\tL.Push(ud)\n\t\terrorIfNotEqual(t, ud, L.OptUserData(2, defud))\n\t\tL.Push(LNumber(10))\n\t\tL.OptUserData(3, defud)\n\t\treturn 0\n\t}, \"userdata expected, got number\")\n}\n\nfunc TestOptChannel(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tdefch := make(chan LValue)\n\t\terrorIfNotEqual(t, defch, L.OptChannel(1, defch))\n\t\tch := make(chan LValue)\n\t\tL.Push(LChannel(ch))\n\t\terrorIfNotEqual(t, ch, L.OptChannel(2, defch))\n\t\tL.Push(LString(\"aaa\"))\n\t\tL.OptChannel(3, defch)\n\t\treturn 0\n\t}, \"channel expected, got string\")\n}\n\nfunc TestLoadFileForShebang(t *testing.T) {\n\ttmpFile, err := os.CreateTemp(\"\", \"\")\n\terrorIfNotNil(t, err)\n\n\terr = os.WriteFile(tmpFile.Name(), []byte(`#!/path/to/lua\nprint(\"hello\")\n`), 0644)\n\terrorIfNotNil(t, err)\n\n\tdefer func() {\n\t\ttmpFile.Close()\n\t\tos.Remove(tmpFile.Name())\n\t}()\n\n\tL := NewState()\n\tdefer L.Close()\n\n\t_, err = L.LoadFile(tmpFile.Name())\n\terrorIfNotNil(t, err)\n}\n\nfunc TestLoadFileForEmptyFile(t *testing.T) {\n\ttmpFile, err := os.CreateTemp(\"\", \"\")\n\terrorIfNotNil(t, err)\n\n\tdefer func() {\n\t\ttmpFile.Close()\n\t\tos.Remove(tmpFile.Name())\n\t}()\n\n\tL := NewState()\n\tdefer L.Close()\n\n\t_, err = L.LoadFile(tmpFile.Name())\n\terrorIfNotNil(t, err)\n}\n"
        },
        {
          "name": "baselib.go",
          "type": "blob",
          "size": 11.505859375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n/* basic functions {{{ */\n\nfunc OpenBase(L *LState) int {\n\tglobal := L.Get(GlobalsIndex).(*LTable)\n\tL.SetGlobal(\"_G\", global)\n\tL.SetGlobal(\"_VERSION\", LString(LuaVersion))\n\tL.SetGlobal(\"_GOPHER_LUA_VERSION\", LString(PackageName+\" \"+PackageVersion))\n\tbasemod := L.RegisterModule(\"_G\", baseFuncs)\n\tglobal.RawSetString(\"ipairs\", L.NewClosure(baseIpairs, L.NewFunction(ipairsaux)))\n\tglobal.RawSetString(\"pairs\", L.NewClosure(basePairs, L.NewFunction(pairsaux)))\n\tL.Push(basemod)\n\treturn 1\n}\n\nvar baseFuncs = map[string]LGFunction{\n\t\"assert\":         baseAssert,\n\t\"collectgarbage\": baseCollectGarbage,\n\t\"dofile\":         baseDoFile,\n\t\"error\":          baseError,\n\t\"getfenv\":        baseGetFEnv,\n\t\"getmetatable\":   baseGetMetatable,\n\t\"load\":           baseLoad,\n\t\"loadfile\":       baseLoadFile,\n\t\"loadstring\":     baseLoadString,\n\t\"next\":           baseNext,\n\t\"pcall\":          basePCall,\n\t\"print\":          basePrint,\n\t\"rawequal\":       baseRawEqual,\n\t\"rawget\":         baseRawGet,\n\t\"rawset\":         baseRawSet,\n\t\"select\":         baseSelect,\n\t\"_printregs\":     base_PrintRegs,\n\t\"setfenv\":        baseSetFEnv,\n\t\"setmetatable\":   baseSetMetatable,\n\t\"tonumber\":       baseToNumber,\n\t\"tostring\":       baseToString,\n\t\"type\":           baseType,\n\t\"unpack\":         baseUnpack,\n\t\"xpcall\":         baseXPCall,\n\t// loadlib\n\t\"module\":  loModule,\n\t\"require\": loRequire,\n\t// hidden features\n\t\"newproxy\": baseNewProxy,\n}\n\nfunc baseAssert(L *LState) int {\n\tif !L.ToBool(1) {\n\t\tL.RaiseError(L.OptString(2, \"assertion failed!\"))\n\t\treturn 0\n\t}\n\treturn L.GetTop()\n}\n\nfunc baseCollectGarbage(L *LState) int {\n\truntime.GC()\n\treturn 0\n}\n\nfunc baseDoFile(L *LState) int {\n\tsrc := L.ToString(1)\n\ttop := L.GetTop()\n\tfn, err := L.LoadFile(src)\n\tif err != nil {\n\t\tL.Push(LString(err.Error()))\n\t\tL.Panic(L)\n\t}\n\tL.Push(fn)\n\tL.Call(0, MultRet)\n\treturn L.GetTop() - top\n}\n\nfunc baseError(L *LState) int {\n\tobj := L.CheckAny(1)\n\tlevel := L.OptInt(2, 1)\n\tL.Error(obj, level)\n\treturn 0\n}\n\nfunc baseGetFEnv(L *LState) int {\n\tvar value LValue\n\tif L.GetTop() == 0 {\n\t\tvalue = LNumber(1)\n\t} else {\n\t\tvalue = L.Get(1)\n\t}\n\n\tif fn, ok := value.(*LFunction); ok {\n\t\tif !fn.IsG {\n\t\t\tL.Push(fn.Env)\n\t\t} else {\n\t\t\tL.Push(L.G.Global)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif number, ok := value.(LNumber); ok {\n\t\tlevel := int(float64(number))\n\t\tif level <= 0 {\n\t\t\tL.Push(L.Env)\n\t\t} else {\n\t\t\tcf := L.currentFrame\n\t\t\tfor i := 0; i < level && cf != nil; i++ {\n\t\t\t\tcf = cf.Parent\n\t\t\t}\n\t\t\tif cf == nil || cf.Fn.IsG {\n\t\t\t\tL.Push(L.G.Global)\n\t\t\t} else {\n\t\t\t\tL.Push(cf.Fn.Env)\n\t\t\t}\n\t\t}\n\t\treturn 1\n\t}\n\n\tL.Push(L.G.Global)\n\treturn 1\n}\n\nfunc baseGetMetatable(L *LState) int {\n\tL.Push(L.GetMetatable(L.CheckAny(1)))\n\treturn 1\n}\n\nfunc ipairsaux(L *LState) int {\n\ttb := L.CheckTable(1)\n\ti := L.CheckInt(2)\n\ti++\n\tv := tb.RawGetInt(i)\n\tif v == LNil {\n\t\treturn 0\n\t} else {\n\t\tL.Pop(1)\n\t\tL.Push(LNumber(i))\n\t\tL.Push(LNumber(i))\n\t\tL.Push(v)\n\t\treturn 2\n\t}\n}\n\nfunc baseIpairs(L *LState) int {\n\ttb := L.CheckTable(1)\n\tL.Push(L.Get(UpvalueIndex(1)))\n\tL.Push(tb)\n\tL.Push(LNumber(0))\n\treturn 3\n}\n\nfunc loadaux(L *LState, reader io.Reader, chunkname string) int {\n\tif fn, err := L.Load(reader, chunkname); err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t} else {\n\t\tL.Push(fn)\n\t\treturn 1\n\t}\n}\n\nfunc baseLoad(L *LState) int {\n\tfn := L.CheckFunction(1)\n\tchunkname := L.OptString(2, \"?\")\n\ttop := L.GetTop()\n\tbuf := []string{}\n\tfor {\n\t\tL.SetTop(top)\n\t\tL.Push(fn)\n\t\tL.Call(0, 1)\n\t\tret := L.reg.Pop()\n\t\tif ret == LNil {\n\t\t\tbreak\n\t\t} else if LVCanConvToString(ret) {\n\t\t\tstr := ret.String()\n\t\t\tif len(str) > 0 {\n\t\t\t\tbuf = append(buf, string(str))\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tL.Push(LNil)\n\t\t\tL.Push(LString(\"reader function must return a string\"))\n\t\t\treturn 2\n\t\t}\n\t}\n\treturn loadaux(L, strings.NewReader(strings.Join(buf, \"\")), chunkname)\n}\n\nfunc baseLoadFile(L *LState) int {\n\tvar reader io.Reader\n\tvar chunkname string\n\tvar err error\n\tif L.GetTop() < 1 {\n\t\treader = os.Stdin\n\t\tchunkname = \"<stdin>\"\n\t} else {\n\t\tchunkname = L.CheckString(1)\n\t\treader, err = os.Open(chunkname)\n\t\tif err != nil {\n\t\t\tL.Push(LNil)\n\t\t\tL.Push(LString(fmt.Sprintf(\"can not open file: %v\", chunkname)))\n\t\t\treturn 2\n\t\t}\n\t\tdefer reader.(*os.File).Close()\n\t}\n\treturn loadaux(L, reader, chunkname)\n}\n\nfunc baseLoadString(L *LState) int {\n\treturn loadaux(L, strings.NewReader(L.CheckString(1)), L.OptString(2, \"<string>\"))\n}\n\nfunc baseNext(L *LState) int {\n\ttb := L.CheckTable(1)\n\tindex := LNil\n\tif L.GetTop() >= 2 {\n\t\tindex = L.Get(2)\n\t}\n\tkey, value := tb.Next(index)\n\tif key == LNil {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\tL.Push(key)\n\tL.Push(value)\n\treturn 2\n}\n\nfunc pairsaux(L *LState) int {\n\ttb := L.CheckTable(1)\n\tkey, value := tb.Next(L.Get(2))\n\tif key == LNil {\n\t\treturn 0\n\t} else {\n\t\tL.Pop(1)\n\t\tL.Push(key)\n\t\tL.Push(key)\n\t\tL.Push(value)\n\t\treturn 2\n\t}\n}\n\nfunc basePairs(L *LState) int {\n\ttb := L.CheckTable(1)\n\tL.Push(L.Get(UpvalueIndex(1)))\n\tL.Push(tb)\n\tL.Push(LNil)\n\treturn 3\n}\n\nfunc basePCall(L *LState) int {\n\tL.CheckAny(1)\n\tv := L.Get(1)\n\tif v.Type() != LTFunction && L.GetMetaField(v, \"__call\").Type() != LTFunction {\n\t\tL.Push(LFalse)\n\t\tL.Push(LString(\"attempt to call a \" + v.Type().String() + \" value\"))\n\t\treturn 2\n\t}\n\tnargs := L.GetTop() - 1\n\tif err := L.PCall(nargs, MultRet, nil); err != nil {\n\t\tL.Push(LFalse)\n\t\tif aerr, ok := err.(*ApiError); ok {\n\t\t\tL.Push(aerr.Object)\n\t\t} else {\n\t\t\tL.Push(LString(err.Error()))\n\t\t}\n\t\treturn 2\n\t} else {\n\t\tL.Insert(LTrue, 1)\n\t\treturn L.GetTop()\n\t}\n}\n\nfunc basePrint(L *LState) int {\n\ttop := L.GetTop()\n\tfor i := 1; i <= top; i++ {\n\t\tfmt.Print(L.ToStringMeta(L.Get(i)).String())\n\t\tif i != top {\n\t\t\tfmt.Print(\"\\t\")\n\t\t}\n\t}\n\tfmt.Println(\"\")\n\treturn 0\n}\n\nfunc base_PrintRegs(L *LState) int {\n\tL.printReg()\n\treturn 0\n}\n\nfunc baseRawEqual(L *LState) int {\n\tif L.CheckAny(1) == L.CheckAny(2) {\n\t\tL.Push(LTrue)\n\t} else {\n\t\tL.Push(LFalse)\n\t}\n\treturn 1\n}\n\nfunc baseRawGet(L *LState) int {\n\tL.Push(L.RawGet(L.CheckTable(1), L.CheckAny(2)))\n\treturn 1\n}\n\nfunc baseRawSet(L *LState) int {\n\tL.RawSet(L.CheckTable(1), L.CheckAny(2), L.CheckAny(3))\n\treturn 0\n}\n\nfunc baseSelect(L *LState) int {\n\tL.CheckTypes(1, LTNumber, LTString)\n\tswitch lv := L.Get(1).(type) {\n\tcase LNumber:\n\t\tidx := int(lv)\n\t\tnum := L.GetTop()\n\t\tif idx < 0 {\n\t\t\tidx = num + idx\n\t\t} else if idx > num {\n\t\t\tidx = num\n\t\t}\n\t\tif 1 > idx {\n\t\t\tL.ArgError(1, \"index out of range\")\n\t\t}\n\t\treturn num - idx\n\tcase LString:\n\t\tif string(lv) != \"#\" {\n\t\t\tL.ArgError(1, \"invalid string '\"+string(lv)+\"'\")\n\t\t}\n\t\tL.Push(LNumber(L.GetTop() - 1))\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc baseSetFEnv(L *LState) int {\n\tvar value LValue\n\tif L.GetTop() == 0 {\n\t\tvalue = LNumber(1)\n\t} else {\n\t\tvalue = L.Get(1)\n\t}\n\tenv := L.CheckTable(2)\n\n\tif fn, ok := value.(*LFunction); ok {\n\t\tif fn.IsG {\n\t\t\tL.RaiseError(\"cannot change the environment of given object\")\n\t\t} else {\n\t\t\tfn.Env = env\n\t\t\tL.Push(fn)\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tif number, ok := value.(LNumber); ok {\n\t\tlevel := int(float64(number))\n\t\tif level <= 0 {\n\t\t\tL.Env = env\n\t\t\treturn 0\n\t\t}\n\n\t\tcf := L.currentFrame\n\t\tfor i := 0; i < level && cf != nil; i++ {\n\t\t\tcf = cf.Parent\n\t\t}\n\t\tif cf == nil || cf.Fn.IsG {\n\t\t\tL.RaiseError(\"cannot change the environment of given object\")\n\t\t} else {\n\t\t\tcf.Fn.Env = env\n\t\t\tL.Push(cf.Fn)\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tL.RaiseError(\"cannot change the environment of given object\")\n\treturn 0\n}\n\nfunc baseSetMetatable(L *LState) int {\n\tL.CheckTypes(2, LTNil, LTTable)\n\tobj := L.Get(1)\n\tif obj == LNil {\n\t\tL.RaiseError(\"cannot set metatable to a nil object.\")\n\t}\n\tmt := L.Get(2)\n\tif m := L.metatable(obj, true); m != LNil {\n\t\tif tb, ok := m.(*LTable); ok && tb.RawGetString(\"__metatable\") != LNil {\n\t\t\tL.RaiseError(\"cannot change a protected metatable\")\n\t\t}\n\t}\n\tL.SetMetatable(obj, mt)\n\tL.SetTop(1)\n\treturn 1\n}\n\nfunc baseToNumber(L *LState) int {\n\tbase := L.OptInt(2, 10)\n\tnoBase := L.Get(2) == LNil\n\n\tswitch lv := L.CheckAny(1).(type) {\n\tcase LNumber:\n\t\tL.Push(lv)\n\tcase LString:\n\t\tstr := strings.Trim(string(lv), \" \\n\\t\")\n\t\tif strings.Index(str, \".\") > -1 {\n\t\t\tif v, err := strconv.ParseFloat(str, LNumberBit); err != nil {\n\t\t\t\tL.Push(LNil)\n\t\t\t} else {\n\t\t\t\tL.Push(LNumber(v))\n\t\t\t}\n\t\t} else {\n\t\t\tif noBase && strings.HasPrefix(strings.ToLower(str), \"0x\") {\n\t\t\t\tbase, str = 16, str[2:] // Hex number\n\t\t\t}\n\t\t\tif v, err := strconv.ParseInt(str, base, LNumberBit); err != nil {\n\t\t\t\tL.Push(LNil)\n\t\t\t} else {\n\t\t\t\tL.Push(LNumber(v))\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tL.Push(LNil)\n\t}\n\treturn 1\n}\n\nfunc baseToString(L *LState) int {\n\tv1 := L.CheckAny(1)\n\tL.Push(L.ToStringMeta(v1))\n\treturn 1\n}\n\nfunc baseType(L *LState) int {\n\tL.Push(LString(L.CheckAny(1).Type().String()))\n\treturn 1\n}\n\nfunc baseUnpack(L *LState) int {\n\ttb := L.CheckTable(1)\n\tstart := L.OptInt(2, 1)\n\tend := L.OptInt(3, tb.Len())\n\tfor i := start; i <= end; i++ {\n\t\tL.Push(tb.RawGetInt(i))\n\t}\n\tret := end - start + 1\n\tif ret < 0 {\n\t\treturn 0\n\t}\n\treturn ret\n}\n\nfunc baseXPCall(L *LState) int {\n\tfn := L.CheckFunction(1)\n\terrfunc := L.CheckFunction(2)\n\n\ttop := L.GetTop()\n\tL.Push(fn)\n\tif err := L.PCall(0, MultRet, errfunc); err != nil {\n\t\tL.Push(LFalse)\n\t\tif aerr, ok := err.(*ApiError); ok {\n\t\t\tL.Push(aerr.Object)\n\t\t} else {\n\t\t\tL.Push(LString(err.Error()))\n\t\t}\n\t\treturn 2\n\t} else {\n\t\tL.Insert(LTrue, top+1)\n\t\treturn L.GetTop() - top\n\t}\n}\n\n/* }}} */\n\n/* load lib {{{ */\n\nfunc loModule(L *LState) int {\n\tname := L.CheckString(1)\n\tloaded := L.GetField(L.Get(RegistryIndex), \"_LOADED\")\n\ttb := L.GetField(loaded, name)\n\tif _, ok := tb.(*LTable); !ok {\n\t\ttb = L.FindTable(L.Get(GlobalsIndex).(*LTable), name, 1)\n\t\tif tb == LNil {\n\t\t\tL.RaiseError(\"name conflict for module: %v\", name)\n\t\t}\n\t\tL.SetField(loaded, name, tb)\n\t}\n\tif L.GetField(tb, \"_NAME\") == LNil {\n\t\tL.SetField(tb, \"_M\", tb)\n\t\tL.SetField(tb, \"_NAME\", LString(name))\n\t\tnames := strings.Split(name, \".\")\n\t\tpname := \"\"\n\t\tif len(names) > 1 {\n\t\t\tpname = strings.Join(names[:len(names)-1], \".\") + \".\"\n\t\t}\n\t\tL.SetField(tb, \"_PACKAGE\", LString(pname))\n\t}\n\n\tcaller := L.currentFrame.Parent\n\tif caller == nil {\n\t\tL.RaiseError(\"no calling stack.\")\n\t} else if caller.Fn.IsG {\n\t\tL.RaiseError(\"module() can not be called from GFunctions.\")\n\t}\n\tL.SetFEnv(caller.Fn, tb)\n\n\ttop := L.GetTop()\n\tfor i := 2; i <= top; i++ {\n\t\tL.Push(L.Get(i))\n\t\tL.Push(tb)\n\t\tL.Call(1, 0)\n\t}\n\tL.Push(tb)\n\treturn 1\n}\n\nvar loopdetection = &LUserData{}\n\nfunc loRequire(L *LState) int {\n\tname := L.CheckString(1)\n\tloaded := L.GetField(L.Get(RegistryIndex), \"_LOADED\")\n\tlv := L.GetField(loaded, name)\n\tif LVAsBool(lv) {\n\t\tif lv == loopdetection {\n\t\t\tL.RaiseError(\"loop or previous error loading module: %s\", name)\n\t\t}\n\t\tL.Push(lv)\n\t\treturn 1\n\t}\n\tloaders, ok := L.GetField(L.Get(RegistryIndex), \"_LOADERS\").(*LTable)\n\tif !ok {\n\t\tL.RaiseError(\"package.loaders must be a table\")\n\t}\n\tmessages := []string{}\n\tvar modasfunc LValue\n\tfor i := 1; ; i++ {\n\t\tloader := L.RawGetInt(loaders, i)\n\t\tif loader == LNil {\n\t\t\tL.RaiseError(\"module %s not found:\\n\\t%s, \", name, strings.Join(messages, \"\\n\\t\"))\n\t\t}\n\t\tL.Push(loader)\n\t\tL.Push(LString(name))\n\t\tL.Call(1, 1)\n\t\tret := L.reg.Pop()\n\t\tswitch retv := ret.(type) {\n\t\tcase *LFunction:\n\t\t\tmodasfunc = retv\n\t\t\tgoto loopbreak\n\t\tcase LString:\n\t\t\tmessages = append(messages, string(retv))\n\t\t}\n\t}\nloopbreak:\n\tL.SetField(loaded, name, loopdetection)\n\tL.Push(modasfunc)\n\tL.Push(LString(name))\n\tL.Call(1, 1)\n\tret := L.reg.Pop()\n\tmodv := L.GetField(loaded, name)\n\tif ret != LNil && modv == loopdetection {\n\t\tL.SetField(loaded, name, ret)\n\t\tL.Push(ret)\n\t} else if modv == loopdetection {\n\t\tL.SetField(loaded, name, LTrue)\n\t\tL.Push(LTrue)\n\t} else {\n\t\tL.Push(modv)\n\t}\n\treturn 1\n}\n\n/* }}} */\n\n/* hidden features {{{ */\n\nfunc baseNewProxy(L *LState) int {\n\tud := L.NewUserData()\n\tL.SetTop(1)\n\tif L.Get(1) == LTrue {\n\t\tL.SetMetatable(ud, L.NewTable())\n\t} else if d, ok := L.Get(1).(*LUserData); ok {\n\t\tL.SetMetatable(ud, L.GetMetatable(d))\n\t}\n\tL.Push(ud)\n\treturn 1\n}\n\n/* }}} */\n\n//\n"
        },
        {
          "name": "baselib_test.go",
          "type": "blob",
          "size": 3.0673828125,
          "content": "package lua\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestOsDateFormatUTCWithTwoParam(t *testing.T) {\n\tt.Setenv(\"TZ\", \"Asia/Tokyo\")\n\tls := NewState()\n\n\tg := ls.GetGlobal(\"os\")\n\tfn := ls.GetField(g, \"date\")\n\n\tint64ptr := func(i int64) *int64 {\n\t\treturn &i\n\t}\n\tcases := []struct {\n\t\tName      string\n\t\tLocal     time.Time\n\t\tNow       time.Time\n\t\tFormat    string\n\t\tTimestamp *int64\n\t}{\n\t\t{\n\t\t\t\"UTCWithTwoParam\",\n\t\t\ttime.Now(),\n\t\t\ttime.Now().UTC(),\n\t\t\t\"!*t\",\n\t\t\tint64ptr(time.Now().UTC().Unix()),\n\t\t},\n\t\t{\n\t\t\t\"LocalWithTwoParam\",\n\t\t\ttime.Now(),\n\t\t\ttime.Now(),\n\t\t\t\"*t\",\n\t\t\tint64ptr(time.Now().Unix()),\n\t\t},\n\t\t{\n\t\t\t\"UTCWithOnlyFormatParam\",\n\t\t\ttime.Now(),\n\t\t\ttime.Now().UTC(),\n\t\t\t\"!*t\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"LocalWithOnlyFormatParam\",\n\t\t\ttime.Now(),\n\t\t\ttime.Now(),\n\t\t\t\"*t\",\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.Name, func(t *testing.T) {\n\t\t\targs := make([]LValue, 0)\n\t\t\targs = append(args, LString(c.Format))\n\t\t\tif c.Timestamp != nil {\n\t\t\t\targs = append(args, LNumber(*c.Timestamp))\n\t\t\t}\n\t\t\terr := ls.CallByParam(P{\n\t\t\t\tFn:      fn,\n\t\t\t\tNRet:    1,\n\t\t\t\tProtect: true,\n\t\t\t}, args...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tresult := ls.ToTable(-1)\n\n\t\t\tresultMap := make(map[string]string)\n\t\t\tresult.ForEach(func(key LValue, value LValue) {\n\t\t\t\tresultMap[key.String()] = value.String()\n\t\t\t\tassertOsDateFields(t, key, value, c.Now)\n\t\t\t})\n\t\t\tt.Logf(\"%v resultMap=%+v\\nnow=%+v\\nLocal=%+v\\nUTC=%v\", c.Name, resultMap, c.Now, c.Local, c.Now.UTC())\n\t\t})\n\t}\n}\n\nfunc TestOsDateFormatLocalWithTwoParam(t *testing.T) {\n\tt.Setenv(\"TZ\", \"Asia/Tokyo\")\n\tls := NewState()\n\n\tg := ls.GetGlobal(\"os\")\n\tfn := ls.GetField(g, \"date\")\n\n\tnowLocal := time.Now()\n\tnowUTC := nowLocal.UTC()\n\n\terr := ls.CallByParam(P{\n\t\tFn:      fn,\n\t\tNRet:    1,\n\t\tProtect: true,\n\t}, LString(\"*t\"), LNumber(nowLocal.Unix()))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult := ls.ToTable(-1)\n\n\tresultMap := make(map[string]string)\n\tresult.ForEach(func(key LValue, value LValue) {\n\t\tt.Logf(\"key=%v, value=%v\", key, value)\n\t\tresultMap[key.String()] = value.String()\n\t\tassertOsDateFields(t, key, value, nowLocal)\n\t})\n\tt.Logf(\"resultMap=%+v, nowLocal=%+v, nowUTC=%v\", resultMap, nowLocal, nowUTC)\n}\n\nfunc assertOsDateFields(t *testing.T, key LValue, value LValue, expect time.Time) {\n\tswitch key.String() {\n\tcase \"year\":\n\t\tif value.String() != strconv.Itoa(expect.Year()) {\n\t\t\tt.Errorf(\"year=%v, expect.Year=%v\", value.String(), expect.Year())\n\t\t}\n\tcase \"month\":\n\t\tif value.String() != strconv.Itoa(int(expect.Month())) {\n\t\t\tt.Errorf(\"month=%v, expect.Month=%v\", value.String(), expect.Month())\n\t\t}\n\tcase \"day\":\n\t\tif value.String() != strconv.Itoa(expect.Day()) {\n\t\t\tt.Errorf(\"day=%v, expect.Day=%v\", value.String(), expect.Day())\n\t\t}\n\tcase \"hour\":\n\t\tif value.String() != strconv.Itoa(expect.Hour()) {\n\t\t\tt.Errorf(\"hour=%v, expect.Hour=%v\", value.String(), expect.Hour())\n\t\t}\n\tcase \"min\":\n\t\tif value.String() != strconv.Itoa(expect.Minute()) {\n\t\t\tt.Errorf(\"min=%v, expect.Minute=%v\", value.String(), expect.Minute())\n\t\t}\n\tcase \"sec\":\n\t\tif value.String() != strconv.Itoa(expect.Second()) {\n\t\t\tt.Errorf(\"sec=%v, expect.Second=%v\", value.String(), expect.Second())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "channellib.go",
          "type": "blob",
          "size": 3.666015625,
          "content": "package lua\n\nimport (\n\t\"reflect\"\n)\n\nfunc checkChannel(L *LState, idx int) reflect.Value {\n\tch := L.CheckChannel(idx)\n\treturn reflect.ValueOf(ch)\n}\n\nfunc checkGoroutineSafe(L *LState, idx int) LValue {\n\tv := L.CheckAny(2)\n\tif !isGoroutineSafe(v) {\n\t\tL.ArgError(2, \"can not send a function, userdata, thread or table that has a metatable\")\n\t}\n\treturn v\n}\n\nfunc OpenChannel(L *LState) int {\n\tvar mod LValue\n\t//_, ok := L.G.builtinMts[int(LTChannel)]\n\t//\tif !ok {\n\tmod = L.RegisterModule(ChannelLibName, channelFuncs)\n\tmt := L.SetFuncs(L.NewTable(), channelMethods)\n\tmt.RawSetString(\"__index\", mt)\n\tL.G.builtinMts[int(LTChannel)] = mt\n\t//\t}\n\tL.Push(mod)\n\treturn 1\n}\n\nvar channelFuncs = map[string]LGFunction{\n\t\"make\":   channelMake,\n\t\"select\": channelSelect,\n}\n\nfunc channelMake(L *LState) int {\n\tbuffer := L.OptInt(1, 0)\n\tL.Push(LChannel(make(chan LValue, buffer)))\n\treturn 1\n}\n\nfunc channelSelect(L *LState) int {\n\t//TODO check case table size\n\tcases := make([]reflect.SelectCase, L.GetTop())\n\ttop := L.GetTop()\n\tfor i := 0; i < top; i++ {\n\t\tcas := reflect.SelectCase{\n\t\t\tDir:  reflect.SelectSend,\n\t\t\tChan: reflect.ValueOf(nil),\n\t\t\tSend: reflect.ValueOf(nil),\n\t\t}\n\t\ttbl := L.CheckTable(i + 1)\n\t\tdir, ok1 := tbl.RawGetInt(1).(LString)\n\t\tif !ok1 {\n\t\t\tL.ArgError(i+1, \"invalid select case\")\n\t\t}\n\t\tswitch string(dir) {\n\t\tcase \"<-|\":\n\t\t\tch, ok := tbl.RawGetInt(2).(LChannel)\n\t\t\tif !ok {\n\t\t\t\tL.ArgError(i+1, \"invalid select case\")\n\t\t\t}\n\t\t\tcas.Chan = reflect.ValueOf((chan LValue)(ch))\n\t\t\tv := tbl.RawGetInt(3)\n\t\t\tif !isGoroutineSafe(v) {\n\t\t\t\tL.ArgError(i+1, \"can not send a function, userdata, thread or table that has a metatable\")\n\t\t\t}\n\t\t\tcas.Send = reflect.ValueOf(v)\n\t\tcase \"|<-\":\n\t\t\tch, ok := tbl.RawGetInt(2).(LChannel)\n\t\t\tif !ok {\n\t\t\t\tL.ArgError(i+1, \"invalid select case\")\n\t\t\t}\n\t\t\tcas.Chan = reflect.ValueOf((chan LValue)(ch))\n\t\t\tcas.Dir = reflect.SelectRecv\n\t\tcase \"default\":\n\t\t\tcas.Dir = reflect.SelectDefault\n\t\tdefault:\n\t\t\tL.ArgError(i+1, \"invalid channel direction:\"+string(dir))\n\t\t}\n\t\tcases[i] = cas\n\t}\n\n\tif L.ctx != nil {\n\t\tcases = append(cases, reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(L.ctx.Done()),\n\t\t\tSend: reflect.ValueOf(nil),\n\t\t})\n\t}\n\n\tpos, recv, rok := reflect.Select(cases)\n\n\tif L.ctx != nil && pos == L.GetTop() {\n\t\treturn 0\n\t}\n\n\tlv := LNil\n\tif recv.Kind() != 0 {\n\t\tlv, _ = recv.Interface().(LValue)\n\t\tif lv == nil {\n\t\t\tlv = LNil\n\t\t}\n\t}\n\ttbl := L.Get(pos + 1).(*LTable)\n\tlast := tbl.RawGetInt(tbl.Len())\n\tif last.Type() == LTFunction {\n\t\tL.Push(last)\n\t\tswitch cases[pos].Dir {\n\t\tcase reflect.SelectRecv:\n\t\t\tif rok {\n\t\t\t\tL.Push(LTrue)\n\t\t\t} else {\n\t\t\t\tL.Push(LFalse)\n\t\t\t}\n\t\t\tL.Push(lv)\n\t\t\tL.Call(2, 0)\n\t\tcase reflect.SelectSend:\n\t\t\tL.Push(tbl.RawGetInt(3))\n\t\t\tL.Call(1, 0)\n\t\tcase reflect.SelectDefault:\n\t\t\tL.Call(0, 0)\n\t\t}\n\t}\n\tL.Push(LNumber(pos + 1))\n\tL.Push(lv)\n\tif rok {\n\t\tL.Push(LTrue)\n\t} else {\n\t\tL.Push(LFalse)\n\t}\n\treturn 3\n}\n\nvar channelMethods = map[string]LGFunction{\n\t\"receive\": channelReceive,\n\t\"send\":    channelSend,\n\t\"close\":   channelClose,\n}\n\nfunc channelReceive(L *LState) int {\n\trch := checkChannel(L, 1)\n\tvar v reflect.Value\n\tvar ok bool\n\tif L.ctx != nil {\n\t\tcases := []reflect.SelectCase{{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(L.ctx.Done()),\n\t\t\tSend: reflect.ValueOf(nil),\n\t\t}, {\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: rch,\n\t\t\tSend: reflect.ValueOf(nil),\n\t\t}}\n\t\t_, v, ok = reflect.Select(cases)\n\t} else {\n\t\tv, ok = rch.Recv()\n\t}\n\tif ok {\n\t\tL.Push(LTrue)\n\t\tL.Push(v.Interface().(LValue))\n\t} else {\n\t\tL.Push(LFalse)\n\t\tL.Push(LNil)\n\t}\n\treturn 2\n}\n\nfunc channelSend(L *LState) int {\n\trch := checkChannel(L, 1)\n\tv := checkGoroutineSafe(L, 2)\n\trch.Send(reflect.ValueOf(v))\n\treturn 0\n}\n\nfunc channelClose(L *LState) int {\n\trch := checkChannel(L, 1)\n\trch.Close()\n\treturn 0\n}\n\n//\n"
        },
        {
          "name": "channellib_test.go",
          "type": "blob",
          "size": 6.673828125,
          "content": "package lua\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestChannelMake(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfScriptFail(t, L, `\n    ch = channel.make()\n    `)\n\tobj := L.GetGlobal(\"ch\")\n\tch, ok := obj.(LChannel)\n\terrorIfFalse(t, ok, \"channel expected\")\n\terrorIfNotEqual(t, 0, reflect.ValueOf(ch).Cap())\n\tclose(ch)\n\n\terrorIfScriptFail(t, L, `\n    ch = channel.make(10)\n    `)\n\tobj = L.GetGlobal(\"ch\")\n\tch, _ = obj.(LChannel)\n\terrorIfNotEqual(t, 10, reflect.ValueOf(ch).Cap())\n\tclose(ch)\n}\n\nfunc TestChannelSelectError(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfScriptFail(t, L, `ch = channel.make()`)\n\terrorIfScriptNotFail(t, L, `channel.select({1,2,3})`, \"invalid select case\")\n\terrorIfScriptNotFail(t, L, `channel.select({\"<-|\", 1, 3})`, \"invalid select case\")\n\terrorIfScriptNotFail(t, L, `channel.select({\"<-|\", ch, function() end})`, \"can not send a function\")\n\terrorIfScriptNotFail(t, L, `channel.select({\"|<-\", 1, 3})`, \"invalid select case\")\n\terrorIfScriptNotFail(t, L, `channel.select({\"<-->\", 1, 3})`, \"invalid channel direction\")\n\terrorIfScriptFail(t, L, `ch:close()`)\n}\n\nfunc TestChannelSelect1(t *testing.T) {\n\tvar result LValue\n\tvar wg sync.WaitGroup\n\treceiver := func(ch, quit chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\tL.SetGlobal(\"quit\", LChannel(quit))\n\t\tif err := L.DoString(`\n    buf = \"\"\n    local exit = false\n    while not exit do\n      channel.select(\n        {\"|<-\", ch, function(ok, v)\n          if not ok then\n            buf = buf .. \"channel closed\"\n            exit = true\n          else\n            buf = buf .. \"received:\" .. v\n          end\n        end},\n        {\"|<-\", quit, function(ok, v)\n            buf = buf .. \"quit\"\n        end}\n      )\n    end\n  `); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tresult = L.GetGlobal(\"buf\")\n\t}\n\n\tsender := func(ch, quit chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\tL.SetGlobal(\"quit\", LChannel(quit))\n\t\tif err := L.DoString(`\n    ch:send(\"1\")\n    ch:send(\"2\")\n  `); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tch <- LString(\"3\")\n\t\tquit <- LTrue\n\t\ttime.Sleep(1 * time.Second)\n\t\tclose(ch)\n\t}\n\n\tch := make(chan LValue)\n\tquit := make(chan LValue)\n\twg.Add(2)\n\tgo receiver(ch, quit)\n\tgo sender(ch, quit)\n\twg.Wait()\n\tlstr, ok := result.(LString)\n\terrorIfFalse(t, ok, \"must be string\")\n\tstr := string(lstr)\n\terrorIfNotEqual(t, \"received:1received:2received:3quitchannel closed\", str)\n\n}\n\nfunc TestChannelSelect2(t *testing.T) {\n\tvar wg sync.WaitGroup\n\treceiver := func(ch, quit chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\tL.SetGlobal(\"quit\", LChannel(quit))\n\t\terrorIfScriptFail(t, L, `\n           idx, rcv, ok = channel.select(\n               {\"|<-\", ch},\n               {\"|<-\", quit}\n           )\n           assert(idx == 1)\n           assert(rcv == \"1\")\n           assert(ok)\n           idx, rcv, ok = channel.select(\n               {\"|<-\", ch},\n               {\"|<-\", quit}\n           )\n           assert(idx == 1)\n           assert(rcv == nil)\n           assert(not ok)\n       `)\n\t}\n\n\tsender := func(ch, quit chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\tL.SetGlobal(\"quit\", LChannel(quit))\n\t\terrorIfScriptFail(t, L, `ch:send(\"1\")`)\n\t\terrorIfScriptFail(t, L, `ch:close()`)\n\t}\n\n\tch := make(chan LValue)\n\tquit := make(chan LValue)\n\twg.Add(2)\n\tgo receiver(ch, quit)\n\tgo sender(ch, quit)\n\twg.Wait()\n}\n\nfunc TestChannelSelect3(t *testing.T) {\n\tvar wg sync.WaitGroup\n\treceiver := func(ch chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\terrorIfScriptFail(t, L, `\n           ok = true\n           while ok do\n             idx, rcv, ok = channel.select(\n                 {\"|<-\", ch}\n             )\n           end\n       `)\n\t}\n\n\tsender := func(ch chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\terrorIfScriptFail(t, L, `\n           ok = false\n           channel.select(\n               {\"<-|\", ch, \"1\", function(v)\n                 ok = true\n               end}\n           )\n           assert(ok)\n           idx, rcv, ok = channel.select(\n               {\"<-|\", ch, \"1\"}\n           )\n           assert(idx == 1)\n           ch:close()\n       `)\n\t}\n\n\tch := make(chan LValue)\n\twg.Add(2)\n\tgo receiver(ch)\n\ttime.Sleep(1)\n\tgo sender(ch)\n\twg.Wait()\n}\n\nfunc TestChannelSelect4(t *testing.T) {\n\tvar wg sync.WaitGroup\n\treceiver := func(ch chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\terrorIfScriptFail(t, L, `\n           idx, rcv, ok = channel.select(\n                 {\"|<-\", ch},\n                 {\"default\"}\n           )\n           assert(idx == 2)\n           called = false\n           idx, rcv, ok = channel.select(\n                 {\"|<-\", ch},\n                 {\"default\", function()\n                    called = true\n                 end}\n           )\n           assert(called)\n           ch:close()\n       `)\n\t}\n\n\tch := make(chan LValue)\n\twg.Add(1)\n\tgo receiver(ch)\n\twg.Wait()\n}\n\nfunc TestChannelSendReceive1(t *testing.T) {\n\tvar wg sync.WaitGroup\n\treceiver := func(ch chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\terrorIfScriptFail(t, L, `\n          local ok, v = ch:receive()\n          assert(ok)\n          assert(v == \"1\")\n        `)\n\t\ttime.Sleep(1 * time.Second)\n\t\terrorIfScriptFail(t, L, `\n          local ok, v = ch:receive()\n          assert(not ok)\n          assert(v == nil)\n        `)\n\t}\n\tsender := func(ch chan LValue) {\n\t\tdefer wg.Done()\n\t\tL := NewState()\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(ch))\n\t\terrorIfScriptFail(t, L, `ch:send(\"1\")`)\n\t\terrorIfScriptNotFail(t, L, `ch:send(function() end)`, \"can not send a function\")\n\t\terrorIfScriptFail(t, L, `ch:close()`)\n\t}\n\tch := make(chan LValue)\n\twg.Add(2)\n\tgo receiver(ch)\n\tgo sender(ch)\n\twg.Wait()\n}\n\nfunc TestCancelChannelReceive(t *testing.T) {\n\tdone := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tdefer close(done)\n\t\tL := NewState()\n\t\tL.SetContext(ctx)\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(make(chan LValue)))\n\t\terrorIfScriptNotFail(t, L, `ch:receive()`, context.Canceled.Error())\n\t}()\n\ttime.Sleep(time.Second)\n\tcancel()\n\t<-done\n}\n\nfunc TestCancelChannelReceive2(t *testing.T) {\n\tdone := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tdefer close(done)\n\t\tL := NewState()\n\t\tL.SetContext(ctx)\n\t\tdefer L.Close()\n\t\tL.SetGlobal(\"ch\", LChannel(make(chan LValue)))\n\t\terrorIfScriptNotFail(t, L, `channel.select({\"|<-\", ch})`, context.Canceled.Error())\n\t}()\n\ttime.Sleep(time.Second)\n\tcancel()\n\t<-done\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "compile.go",
          "type": "blob",
          "size": 49.8212890625,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/yuin/gopher-lua/ast\"\n)\n\n/* internal constants & structs  {{{ */\n\nconst maxRegisters = 200\n\ntype expContextType int\n\nconst (\n\tecGlobal expContextType = iota\n\tecUpvalue\n\tecLocal\n\tecTable\n\tecVararg\n\tecMethod\n\tecNone\n)\n\nconst regNotDefined = opMaxArgsA + 1\nconst labelNoJump = 0\n\ntype expcontext struct {\n\tctype expContextType\n\treg   int\n\t// varargopt >= 0: wants varargopt+1 results, i.e  a = func()\n\t// varargopt = -1: ignore results             i.e  func()\n\t// varargopt = -2: receive all results        i.e  a = {func()}\n\tvarargopt int\n}\n\ntype assigncontext struct {\n\tec       *expcontext\n\tkeyrk    int\n\tvaluerk  int\n\tkeyks    bool\n\tneedmove bool\n}\n\ntype lblabels struct {\n\tt int\n\tf int\n\te int\n\tb bool\n}\n\ntype constLValueExpr struct {\n\tast.ExprBase\n\n\tValue LValue\n}\n\n// }}}\n\n/* utilities {{{ */\nvar _ecnone0 = &expcontext{ecNone, regNotDefined, 0}\nvar _ecnonem1 = &expcontext{ecNone, regNotDefined, -1}\nvar _ecnonem2 = &expcontext{ecNone, regNotDefined, -2}\nvar ecfuncdef = &expcontext{ecMethod, regNotDefined, 0}\n\nfunc ecupdate(ec *expcontext, ctype expContextType, reg, varargopt int) {\n\tif ec == _ecnone0 || ec == _ecnonem1 || ec == _ecnonem2 {\n\t\tpanic(\"can not update ec cache\")\n\t}\n\tec.ctype = ctype\n\tec.reg = reg\n\tec.varargopt = varargopt\n}\n\nfunc ecnone(varargopt int) *expcontext {\n\tswitch varargopt {\n\tcase 0:\n\t\treturn _ecnone0\n\tcase -1:\n\t\treturn _ecnonem1\n\tcase -2:\n\t\treturn _ecnonem2\n\t}\n\treturn &expcontext{ecNone, regNotDefined, varargopt}\n}\n\nfunc shouldmove(ec *expcontext, reg int) bool {\n\treturn ec.ctype == ecLocal && ec.reg != regNotDefined && ec.reg != reg\n}\n\nfunc sline(pos ast.PositionHolder) int {\n\treturn pos.Line()\n}\n\nfunc eline(pos ast.PositionHolder) int {\n\tline := pos.LastLine()\n\tif line == 0 {\n\t\treturn pos.Line()\n\t}\n\treturn line\n}\n\nfunc savereg(ec *expcontext, reg int) int {\n\tif ec.ctype != ecLocal || ec.reg == regNotDefined {\n\t\treturn reg\n\t}\n\treturn ec.reg\n}\n\nfunc raiseCompileError(context *funcContext, line int, format string, args ...interface{}) {\n\tmsg := fmt.Sprintf(format, args...)\n\tpanic(&CompileError{context: context, Line: line, Message: msg})\n}\n\nfunc isVarArgReturnExpr(expr ast.Expr) bool {\n\tswitch ex := expr.(type) {\n\tcase *ast.FuncCallExpr:\n\t\treturn !ex.AdjustRet\n\tcase *ast.Comma3Expr:\n\t\treturn !ex.AdjustRet\n\t}\n\treturn false\n}\n\nfunc lnumberValue(expr ast.Expr) (LNumber, bool) {\n\tif ex, ok := expr.(*ast.NumberExpr); ok {\n\t\tlv, err := parseNumber(ex.Value)\n\t\tif err != nil {\n\t\t\tlv = LNumber(math.NaN())\n\t\t}\n\t\treturn lv, true\n\t} else if ex, ok := expr.(*constLValueExpr); ok {\n\t\treturn ex.Value.(LNumber), true\n\t}\n\treturn 0, false\n}\n\n/* utilities }}} */\n\ntype gotoLabelDesc struct { // {{{\n\tId                 int\n\tName               string\n\tPc                 int\n\tLine               int\n\tNumActiveLocalVars int\n}\n\nfunc newLabelDesc(id int, name string, pc, line, n int) *gotoLabelDesc {\n\treturn &gotoLabelDesc{\n\t\tId:                 id,\n\t\tName:               name,\n\t\tPc:                 pc,\n\t\tLine:               line,\n\t\tNumActiveLocalVars: n,\n\t}\n}\n\nfunc (l *gotoLabelDesc) SetNumActiveLocalVars(n int) {\n\tl.NumActiveLocalVars = n\n} // }}}\n\ntype CompileError struct { // {{{\n\tcontext *funcContext\n\tLine    int\n\tMessage string\n}\n\nfunc (e *CompileError) Error() string {\n\treturn fmt.Sprintf(\"compile error near line(%v) %v: %v\", e.Line, e.context.Proto.SourceName, e.Message)\n} // }}}\n\ntype codeStore struct { // {{{\n\tcodes []uint32\n\tlines []int\n\tpc    int\n}\n\nfunc (cd *codeStore) Add(inst uint32, line int) {\n\tif l := len(cd.codes); l <= 0 || cd.pc == l {\n\t\tcd.codes = append(cd.codes, inst)\n\t\tcd.lines = append(cd.lines, line)\n\t} else {\n\t\tcd.codes[cd.pc] = inst\n\t\tcd.lines[cd.pc] = line\n\t}\n\tcd.pc++\n}\n\nfunc (cd *codeStore) AddABC(op int, a int, b int, c int, line int) {\n\tcd.Add(opCreateABC(op, a, b, c), line)\n}\n\nfunc (cd *codeStore) AddABx(op int, a int, bx int, line int) {\n\tcd.Add(opCreateABx(op, a, bx), line)\n}\n\nfunc (cd *codeStore) AddASbx(op int, a int, sbx int, line int) {\n\tcd.Add(opCreateASbx(op, a, sbx), line)\n}\n\nfunc (cd *codeStore) PropagateKMV(top int, save *int, reg *int, inc int) {\n\tlastinst := cd.Last()\n\tif opGetArgA(lastinst) >= top {\n\t\tswitch opGetOpCode(lastinst) {\n\t\tcase OP_LOADK:\n\t\t\tcindex := opGetArgBx(lastinst)\n\t\t\tif cindex <= opMaxIndexRk {\n\t\t\t\tcd.Pop()\n\t\t\t\t*save = opRkAsk(cindex)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase OP_MOVE:\n\t\t\tcd.Pop()\n\t\t\t*save = opGetArgB(lastinst)\n\t\t\treturn\n\t\t}\n\t}\n\t*save = *reg\n\t*reg = *reg + inc\n}\n\nfunc (cd *codeStore) PropagateMV(top int, save *int, reg *int, inc int) {\n\tlastinst := cd.Last()\n\tif opGetArgA(lastinst) >= top {\n\t\tswitch opGetOpCode(lastinst) {\n\t\tcase OP_MOVE:\n\t\t\tcd.Pop()\n\t\t\t*save = opGetArgB(lastinst)\n\t\t\treturn\n\t\t}\n\t}\n\t*save = *reg\n\t*reg = *reg + inc\n}\n\nfunc (cd *codeStore) AddLoadNil(a, b, line int) {\n\tlast := cd.Last()\n\tif opGetOpCode(last) == OP_LOADNIL && (opGetArgB(last)+1) == a {\n\t\tcd.SetB(cd.LastPC(), b)\n\t} else {\n\t\tcd.AddABC(OP_LOADNIL, a, b, 0, line)\n\t}\n}\n\nfunc (cd *codeStore) SetOpCode(pc int, v int) {\n\topSetOpCode(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) SetA(pc int, v int) {\n\topSetArgA(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) SetB(pc int, v int) {\n\topSetArgB(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) SetC(pc int, v int) {\n\topSetArgC(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) SetBx(pc int, v int) {\n\topSetArgBx(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) SetSbx(pc int, v int) {\n\topSetArgSbx(&cd.codes[pc], v)\n}\n\nfunc (cd *codeStore) At(pc int) uint32 {\n\treturn cd.codes[pc]\n}\n\nfunc (cd *codeStore) List() []uint32 {\n\treturn cd.codes[:cd.pc]\n}\n\nfunc (cd *codeStore) PosList() []int {\n\treturn cd.lines[:cd.pc]\n}\n\nfunc (cd *codeStore) LastPC() int {\n\treturn cd.pc - 1\n}\n\nfunc (cd *codeStore) Last() uint32 {\n\tif cd.pc == 0 {\n\t\treturn opInvalidInstruction\n\t}\n\treturn cd.codes[cd.pc-1]\n}\n\nfunc (cd *codeStore) Pop() {\n\tcd.pc--\n} /* }}} Code */\n\n/* {{{ VarNamePool */\n\ntype varNamePoolValue struct {\n\tIndex int\n\tName  string\n}\n\ntype varNamePool struct {\n\tnames  []string\n\toffset int\n}\n\nfunc newVarNamePool(offset int) *varNamePool {\n\treturn &varNamePool{make([]string, 0, 16), offset}\n}\n\nfunc (vp *varNamePool) Names() []string {\n\treturn vp.names\n}\n\nfunc (vp *varNamePool) List() []varNamePoolValue {\n\tresult := make([]varNamePoolValue, len(vp.names), len(vp.names))\n\tfor i, name := range vp.names {\n\t\tresult[i].Index = i + vp.offset\n\t\tresult[i].Name = name\n\t}\n\treturn result\n}\n\nfunc (vp *varNamePool) LastIndex() int {\n\treturn vp.offset + len(vp.names)\n}\n\nfunc (vp *varNamePool) Find(name string) int {\n\tfor i := len(vp.names) - 1; i >= 0; i-- {\n\t\tif vp.names[i] == name {\n\t\t\treturn i + vp.offset\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc (vp *varNamePool) RegisterUnique(name string) int {\n\tindex := vp.Find(name)\n\tif index < 0 {\n\t\treturn vp.Register(name)\n\t}\n\treturn index\n}\n\nfunc (vp *varNamePool) Register(name string) int {\n\tvp.names = append(vp.names, name)\n\treturn len(vp.names) - 1 + vp.offset\n}\n\n/* }}} VarNamePool */\n\n/* FuncContext {{{ */\n\ntype codeBlock struct {\n\tLocalVars      *varNamePool\n\tBreakLabel     int\n\tParent         *codeBlock\n\tRefUpvalue     bool\n\tLineStart      int\n\tLastLine       int\n\tlabels         map[string]*gotoLabelDesc\n\tfirstGotoIndex int\n}\n\nfunc newCodeBlock(localvars *varNamePool, blabel int, parent *codeBlock, pos ast.PositionHolder, firstGotoIndex int) *codeBlock {\n\tbl := &codeBlock{localvars, blabel, parent, false, 0, 0, map[string]*gotoLabelDesc{}, firstGotoIndex}\n\tif pos != nil {\n\t\tbl.LineStart = pos.Line()\n\t\tbl.LastLine = pos.LastLine()\n\t}\n\treturn bl\n}\n\nfunc (b *codeBlock) AddLabel(label *gotoLabelDesc) *gotoLabelDesc {\n\tif old, ok := b.labels[label.Name]; ok {\n\t\treturn old\n\t}\n\tb.labels[label.Name] = label\n\treturn nil\n}\n\nfunc (b *codeBlock) GetLabel(label string) *gotoLabelDesc {\n\tif v, ok := b.labels[label]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (b *codeBlock) LocalVarsCount() int {\n\tcount := 0\n\tfor block := b; block != nil; block = block.Parent {\n\t\tcount += len(block.LocalVars.Names())\n\t}\n\treturn count\n}\n\ntype funcContext struct {\n\tProto           *FunctionProto\n\tCode            *codeStore\n\tParent          *funcContext\n\tUpvalues        *varNamePool\n\tBlock           *codeBlock\n\tBlocks          []*codeBlock\n\tregTop          int\n\tlabelId         int\n\tlabelPc         map[int]int\n\tgotosCount      int\n\tunresolvedGotos map[int]*gotoLabelDesc\n}\n\nfunc newFuncContext(sourcename string, parent *funcContext) *funcContext {\n\tfc := &funcContext{\n\t\tProto:           newFunctionProto(sourcename),\n\t\tCode:            &codeStore{make([]uint32, 0, 1024), make([]int, 0, 1024), 0},\n\t\tParent:          parent,\n\t\tUpvalues:        newVarNamePool(0),\n\t\tBlock:           newCodeBlock(newVarNamePool(0), labelNoJump, nil, nil, 0),\n\t\tregTop:          0,\n\t\tlabelId:         1,\n\t\tlabelPc:         map[int]int{},\n\t\tgotosCount:      0,\n\t\tunresolvedGotos: map[int]*gotoLabelDesc{},\n\t}\n\tfc.Blocks = []*codeBlock{fc.Block}\n\treturn fc\n}\n\nfunc (fc *funcContext) CheckUnresolvedGoto() {\n\tfor i := fc.Block.firstGotoIndex; i < fc.gotosCount; i++ {\n\t\tgotoLabel, ok := fc.unresolvedGotos[i]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\traiseCompileError(fc, fc.Proto.LastLineDefined, \"no visible label '%s' for <goto> at line %d\", gotoLabel.Name, gotoLabel.Line)\n\t}\n}\n\nfunc (fc *funcContext) AddUnresolvedGoto(label *gotoLabelDesc) {\n\tfc.unresolvedGotos[fc.gotosCount] = label\n\tfc.gotosCount++\n}\n\nfunc (fc *funcContext) AddNamedLabel(label *gotoLabelDesc) {\n\tif old := fc.Block.AddLabel(label); old != nil {\n\t\traiseCompileError(fc, label.Line+1, \"label '%s' already defined on line %d\", label.Name, old.Line)\n\t}\n\tfc.SetLabelPc(label.Id, label.Pc)\n}\n\nfunc (fc *funcContext) GetNamedLabel(name string) *gotoLabelDesc {\n\treturn fc.Block.GetLabel(name)\n}\n\nfunc (fc *funcContext) ResolveGoto(from, to *gotoLabelDesc, index int) {\n\tif from.NumActiveLocalVars < to.NumActiveLocalVars {\n\t\tvarName := fc.Block.LocalVars.Names()[len(fc.Block.LocalVars.Names())-1]\n\t\traiseCompileError(fc, to.Line+1, \"<goto %s> at line %d jumps into the scope of local '%s'\", to.Name, from.Line, varName)\n\t}\n\tfc.Code.SetSbx(from.Pc, to.Id)\n\tdelete(fc.unresolvedGotos, index)\n}\n\nfunc (fc *funcContext) FindLabel(block *codeBlock, gotoLabel *gotoLabelDesc, i int) bool {\n\ttarget := block.GetLabel(gotoLabel.Name)\n\tif target != nil {\n\t\tif gotoLabel.NumActiveLocalVars > target.NumActiveLocalVars && block.RefUpvalue {\n\t\t\tfc.Code.SetA(gotoLabel.Pc-1, target.NumActiveLocalVars)\n\t\t}\n\t\tfc.ResolveGoto(gotoLabel, target, i)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (fc *funcContext) ResolveCurrentBlockGotosWithParentBlock() {\n\tblockActiveLocalVars := fc.Block.Parent.LocalVarsCount()\n\tfor i := fc.Block.firstGotoIndex; i < fc.gotosCount; i++ {\n\t\tgotoLabel, ok := fc.unresolvedGotos[i]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif gotoLabel.NumActiveLocalVars > blockActiveLocalVars {\n\t\t\tif fc.Block.RefUpvalue {\n\t\t\t\tfc.Code.SetA(gotoLabel.Pc-1, blockActiveLocalVars)\n\t\t\t}\n\t\t\tgotoLabel.SetNumActiveLocalVars(blockActiveLocalVars)\n\t\t}\n\t\tfc.FindLabel(fc.Block.Parent, gotoLabel, i)\n\t}\n}\n\nfunc (fc *funcContext) ResolveForwardGoto(target *gotoLabelDesc) {\n\tfor i := fc.Block.firstGotoIndex; i <= fc.gotosCount; i++ {\n\t\tgotoLabel, ok := fc.unresolvedGotos[i]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif gotoLabel.Name == target.Name {\n\t\t\tfc.ResolveGoto(gotoLabel, target, i)\n\t\t}\n\t}\n}\n\nfunc (fc *funcContext) NewLabel() int {\n\tret := fc.labelId\n\tfc.labelId++\n\treturn ret\n}\n\nfunc (fc *funcContext) SetLabelPc(label int, pc int) {\n\tfc.labelPc[label] = pc\n}\n\nfunc (fc *funcContext) GetLabelPc(label int) int {\n\treturn fc.labelPc[label]\n}\n\nfunc (fc *funcContext) ConstIndex(value LValue) int {\n\tctype := value.Type()\n\tfor i, lv := range fc.Proto.Constants {\n\t\tif lv.Type() == ctype && lv == value {\n\t\t\treturn i\n\t\t}\n\t}\n\tfc.Proto.Constants = append(fc.Proto.Constants, value)\n\tv := len(fc.Proto.Constants) - 1\n\tif v > opMaxArgBx {\n\t\traiseCompileError(fc, fc.Proto.LineDefined, \"too many constants\")\n\t}\n\treturn v\n}\nfunc (fc *funcContext) BlockLocalVarsCount() int {\n\tcount := 0\n\tfor block := fc.Block; block != nil; block = block.Parent {\n\t\tcount += len(block.LocalVars.Names())\n\t}\n\treturn count\n}\n\nfunc (fc *funcContext) RegisterLocalVar(name string) int {\n\tret := fc.Block.LocalVars.Register(name)\n\tfc.Proto.DbgLocals = append(fc.Proto.DbgLocals, &DbgLocalInfo{Name: name, StartPc: fc.Code.LastPC() + 1})\n\tfc.SetRegTop(fc.RegTop() + 1)\n\treturn ret\n}\n\nfunc (fc *funcContext) FindLocalVarAndBlock(name string) (int, *codeBlock) {\n\tfor block := fc.Block; block != nil; block = block.Parent {\n\t\tif index := block.LocalVars.Find(name); index > -1 {\n\t\t\treturn index, block\n\t\t}\n\t}\n\treturn -1, nil\n}\n\nfunc (fc *funcContext) FindLocalVar(name string) int {\n\tidx, _ := fc.FindLocalVarAndBlock(name)\n\treturn idx\n}\n\nfunc (fc *funcContext) LocalVars() []varNamePoolValue {\n\tresult := make([]varNamePoolValue, 0, 32)\n\tfor _, block := range fc.Blocks {\n\t\tresult = append(result, block.LocalVars.List()...)\n\t}\n\treturn result\n}\n\nfunc (fc *funcContext) EnterBlock(blabel int, pos ast.PositionHolder) {\n\tfc.Block = newCodeBlock(newVarNamePool(fc.RegTop()), blabel, fc.Block, pos, fc.gotosCount)\n\tfc.Blocks = append(fc.Blocks, fc.Block)\n}\n\nfunc (fc *funcContext) CloseUpvalues() int {\n\tn := -1\n\tif fc.Block.RefUpvalue {\n\t\tn = fc.Block.Parent.LocalVars.LastIndex()\n\t\tfc.Code.AddABC(OP_CLOSE, n, 0, 0, fc.Block.LastLine)\n\t}\n\treturn n\n}\n\nfunc (fc *funcContext) LeaveBlock() int {\n\tclosed := fc.CloseUpvalues()\n\tfc.EndScope()\n\n\tif fc.Block.Parent != nil {\n\t\tfc.ResolveCurrentBlockGotosWithParentBlock()\n\t}\n\tfc.Block = fc.Block.Parent\n\tfc.SetRegTop(fc.Block.LocalVars.LastIndex())\n\treturn closed\n}\n\nfunc (fc *funcContext) EndScope() {\n\tfor _, vr := range fc.Block.LocalVars.List() {\n\t\tfc.Proto.DbgLocals[vr.Index].EndPc = fc.Code.LastPC()\n\t}\n}\n\nfunc (fc *funcContext) SetRegTop(top int) {\n\tif top > maxRegisters {\n\t\traiseCompileError(fc, fc.Proto.LineDefined, \"too many local variables\")\n\t}\n\tfc.regTop = top\n}\n\nfunc (fc *funcContext) RegTop() int {\n\treturn fc.regTop\n}\n\n/* FuncContext }}} */\n\nfunc compileChunk(context *funcContext, chunk []ast.Stmt, untilFollows bool) { // {{{\n\tfor i, stmt := range chunk {\n\t\tlastStmt := true\n\t\tfor j := i + 1; j < len(chunk); j++ {\n\t\t\t_, ok := chunk[j].(*ast.LabelStmt)\n\t\t\tif !ok {\n\t\t\t\tlastStmt = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcompileStmt(context, stmt, lastStmt && !untilFollows)\n\t}\n} // }}}\n\nfunc compileBlock(context *funcContext, chunk []ast.Stmt) { // {{{\n\tif len(chunk) == 0 {\n\t\treturn\n\t}\n\tph := &ast.Node{}\n\tph.SetLine(sline(chunk[0]))\n\tph.SetLastLine(eline(chunk[len(chunk)-1]))\n\tcontext.EnterBlock(labelNoJump, ph)\n\tfor i, stmt := range chunk {\n\t\tlastStmt := true\n\t\tfor j := i + 1; j < len(chunk); j++ {\n\t\t\t_, ok := chunk[j].(*ast.LabelStmt)\n\t\t\tif !ok {\n\t\t\t\tlastStmt = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcompileStmt(context, stmt, lastStmt)\n\t}\n\tcontext.LeaveBlock()\n} // }}}\n\nfunc compileStmt(context *funcContext, stmt ast.Stmt, isLastStmt bool) { // {{{\n\tswitch st := stmt.(type) {\n\tcase *ast.AssignStmt:\n\t\tcompileAssignStmt(context, st)\n\tcase *ast.LocalAssignStmt:\n\t\tcompileLocalAssignStmt(context, st)\n\tcase *ast.FuncCallStmt:\n\t\tcompileFuncCallExpr(context, context.RegTop(), st.Expr.(*ast.FuncCallExpr), ecnone(-1))\n\tcase *ast.DoBlockStmt:\n\t\tcontext.EnterBlock(labelNoJump, st)\n\t\tcompileChunk(context, st.Stmts, false)\n\t\tcontext.LeaveBlock()\n\tcase *ast.WhileStmt:\n\t\tcompileWhileStmt(context, st)\n\tcase *ast.RepeatStmt:\n\t\tcompileRepeatStmt(context, st)\n\tcase *ast.FuncDefStmt:\n\t\tcompileFuncDefStmt(context, st)\n\tcase *ast.ReturnStmt:\n\t\tcompileReturnStmt(context, st)\n\tcase *ast.IfStmt:\n\t\tcompileIfStmt(context, st)\n\tcase *ast.BreakStmt:\n\t\tcompileBreakStmt(context, st)\n\tcase *ast.NumberForStmt:\n\t\tcompileNumberForStmt(context, st)\n\tcase *ast.GenericForStmt:\n\t\tcompileGenericForStmt(context, st)\n\tcase *ast.LabelStmt:\n\t\tcompileLabelStmt(context, st, isLastStmt)\n\tcase *ast.GotoStmt:\n\t\tcompileGotoStmt(context, st)\n\t}\n} // }}}\n\nfunc compileAssignStmtLeft(context *funcContext, stmt *ast.AssignStmt) (int, []*assigncontext) { // {{{\n\treg := context.RegTop()\n\tacs := make([]*assigncontext, 0, len(stmt.Lhs))\n\tfor _, lhs := range stmt.Lhs {\n\t\tswitch st := lhs.(type) {\n\t\tcase *ast.IdentExpr:\n\t\t\tidenttype := getIdentRefType(context, context, st)\n\t\t\tec := &expcontext{identtype, regNotDefined, 0}\n\t\t\tswitch identtype {\n\t\t\tcase ecGlobal:\n\t\t\t\tcontext.ConstIndex(LString(st.Value))\n\t\t\tcase ecUpvalue:\n\t\t\t\tcontext.Upvalues.RegisterUnique(st.Value)\n\t\t\tcase ecLocal:\n\t\t\t\tec.reg = context.FindLocalVar(st.Value)\n\t\t\t}\n\t\t\tacs = append(acs, &assigncontext{ec, 0, 0, false, false})\n\t\tcase *ast.AttrGetExpr:\n\t\t\tac := &assigncontext{&expcontext{ecTable, regNotDefined, 0}, 0, 0, false, false}\n\t\t\tcompileExprWithKMVPropagation(context, st.Object, &reg, &ac.ec.reg)\n\t\t\tac.keyrk = reg\n\t\t\treg += compileExpr(context, reg, st.Key, ecnone(0))\n\t\t\tif _, ok := st.Key.(*ast.StringExpr); ok {\n\t\t\t\tac.keyks = true\n\t\t\t}\n\t\t\tacs = append(acs, ac)\n\n\t\tdefault:\n\t\t\tpanic(\"invalid left expression.\")\n\t\t}\n\t}\n\treturn reg, acs\n} // }}}\n\nfunc compileAssignStmtRight(context *funcContext, stmt *ast.AssignStmt, reg int, acs []*assigncontext) (int, []*assigncontext) { // {{{\n\tlennames := len(stmt.Lhs)\n\tlenexprs := len(stmt.Rhs)\n\tnamesassigned := 0\n\n\tfor namesassigned < lennames {\n\t\tac := acs[namesassigned]\n\t\tec := ac.ec\n\t\tvar expr ast.Expr = nil\n\t\tif namesassigned >= lenexprs {\n\t\t\texpr = &ast.NilExpr{}\n\t\t\texpr.SetLine(sline(stmt.Lhs[namesassigned]))\n\t\t\texpr.SetLastLine(eline(stmt.Lhs[namesassigned]))\n\t\t} else if isVarArgReturnExpr(stmt.Rhs[namesassigned]) && (lenexprs-namesassigned-1) <= 0 {\n\t\t\tvarargopt := lennames - namesassigned - 1\n\t\t\tregstart := reg\n\t\t\treginc := compileExpr(context, reg, stmt.Rhs[namesassigned], ecnone(varargopt))\n\t\t\treg += reginc\n\t\t\tfor i := namesassigned; i < namesassigned+int(reginc); i++ {\n\t\t\t\tacs[i].needmove = true\n\t\t\t\tif acs[i].ec.ctype == ecTable {\n\t\t\t\t\tacs[i].valuerk = regstart + (i - namesassigned)\n\t\t\t\t}\n\t\t\t}\n\t\t\tnamesassigned = lennames\n\t\t\tcontinue\n\t\t}\n\n\t\tif expr == nil {\n\t\t\texpr = stmt.Rhs[namesassigned]\n\t\t}\n\t\tidx := reg\n\t\treginc := compileExpr(context, reg, expr, ec)\n\t\tif ec.ctype == ecTable {\n\t\t\tif _, ok := expr.(*ast.LogicalOpExpr); !ok {\n\t\t\t\tcontext.Code.PropagateKMV(context.RegTop(), &ac.valuerk, &reg, reginc)\n\t\t\t} else {\n\t\t\t\tac.valuerk = idx\n\t\t\t\treg += reginc\n\t\t\t}\n\t\t} else {\n\t\t\tac.needmove = reginc != 0\n\t\t\treg += reginc\n\t\t}\n\t\tnamesassigned += 1\n\t}\n\n\trightreg := reg - 1\n\n\t// extra right exprs\n\tfor i := namesassigned; i < lenexprs; i++ {\n\t\tvarargopt := -1\n\t\tif i != lenexprs-1 {\n\t\t\tvarargopt = 0\n\t\t}\n\t\treg += compileExpr(context, reg, stmt.Rhs[i], ecnone(varargopt))\n\t}\n\treturn rightreg, acs\n} // }}}\n\nfunc compileAssignStmt(context *funcContext, stmt *ast.AssignStmt) { // {{{\n\tcode := context.Code\n\tlennames := len(stmt.Lhs)\n\treg, acs := compileAssignStmtLeft(context, stmt)\n\treg, acs = compileAssignStmtRight(context, stmt, reg, acs)\n\n\tfor i := lennames - 1; i >= 0; i-- {\n\t\tex := stmt.Lhs[i]\n\t\tswitch acs[i].ec.ctype {\n\t\tcase ecLocal:\n\t\t\tif acs[i].needmove {\n\t\t\t\tcode.AddABC(OP_MOVE, context.FindLocalVar(ex.(*ast.IdentExpr).Value), reg, 0, sline(ex))\n\t\t\t\treg -= 1\n\t\t\t}\n\t\tcase ecGlobal:\n\t\t\tcode.AddABx(OP_SETGLOBAL, reg, context.ConstIndex(LString(ex.(*ast.IdentExpr).Value)), sline(ex))\n\t\t\treg -= 1\n\t\tcase ecUpvalue:\n\t\t\tcode.AddABC(OP_SETUPVAL, reg, context.Upvalues.RegisterUnique(ex.(*ast.IdentExpr).Value), 0, sline(ex))\n\t\t\treg -= 1\n\t\tcase ecTable:\n\t\t\topcode := OP_SETTABLE\n\t\t\tif acs[i].keyks {\n\t\t\t\topcode = OP_SETTABLEKS\n\t\t\t}\n\t\t\tcode.AddABC(opcode, acs[i].ec.reg, acs[i].keyrk, acs[i].valuerk, sline(ex))\n\t\t\tif !opIsK(acs[i].valuerk) {\n\t\t\t\treg -= 1\n\t\t\t}\n\t\t}\n\t}\n} // }}}\n\nfunc compileRegAssignment(context *funcContext, names []string, exprs []ast.Expr, reg int, nvars int, line int) { // {{{\n\tlennames := len(names)\n\tlenexprs := len(exprs)\n\tnamesassigned := 0\n\tec := &expcontext{}\n\n\tfor namesassigned < lennames && namesassigned < lenexprs {\n\t\tif isVarArgReturnExpr(exprs[namesassigned]) && (lenexprs-namesassigned-1) <= 0 {\n\n\t\t\tvarargopt := nvars - namesassigned\n\t\t\tecupdate(ec, ecVararg, reg, varargopt-1)\n\t\t\tcompileExpr(context, reg, exprs[namesassigned], ec)\n\t\t\treg += varargopt\n\t\t\tnamesassigned = lennames\n\t\t} else {\n\t\t\tecupdate(ec, ecLocal, reg, 0)\n\t\t\tcompileExpr(context, reg, exprs[namesassigned], ec)\n\t\t\treg += 1\n\t\t\tnamesassigned += 1\n\t\t}\n\t}\n\n\t// extra left names\n\tif lennames > namesassigned {\n\t\trestleft := lennames - namesassigned - 1\n\t\tcontext.Code.AddLoadNil(reg, reg+restleft, line)\n\t\treg += restleft\n\t}\n\n\t// extra right exprs\n\tfor i := namesassigned; i < lenexprs; i++ {\n\t\tvarargopt := -1\n\t\tif i != lenexprs-1 {\n\t\t\tvarargopt = 0\n\t\t}\n\t\tecupdate(ec, ecNone, reg, varargopt)\n\t\treg += compileExpr(context, reg, exprs[i], ec)\n\t}\n} // }}}\n\nfunc compileLocalAssignStmt(context *funcContext, stmt *ast.LocalAssignStmt) { // {{{\n\treg := context.RegTop()\n\tif len(stmt.Names) == 1 && len(stmt.Exprs) == 1 {\n\t\tif _, ok := stmt.Exprs[0].(*ast.FunctionExpr); ok {\n\t\t\tcontext.RegisterLocalVar(stmt.Names[0])\n\t\t\tcompileRegAssignment(context, stmt.Names, stmt.Exprs, reg, len(stmt.Names), sline(stmt))\n\t\t\treturn\n\t\t}\n\t}\n\n\tcompileRegAssignment(context, stmt.Names, stmt.Exprs, reg, len(stmt.Names), sline(stmt))\n\tfor _, name := range stmt.Names {\n\t\tcontext.RegisterLocalVar(name)\n\t}\n} // }}}\n\nfunc compileReturnStmt(context *funcContext, stmt *ast.ReturnStmt) { // {{{\n\tlenexprs := len(stmt.Exprs)\n\tcode := context.Code\n\treg := context.RegTop()\n\ta := reg\n\tlastisvaarg := false\n\n\tif lenexprs == 1 {\n\t\tswitch ex := stmt.Exprs[0].(type) {\n\t\tcase *ast.IdentExpr:\n\t\t\tif idx := context.FindLocalVar(ex.Value); idx > -1 {\n\t\t\t\tcode.AddABC(OP_RETURN, idx, 2, 0, sline(stmt))\n\t\t\t\treturn\n\t\t\t}\n\t\tcase *ast.FuncCallExpr:\n\t\t\tif ex.AdjustRet { // return (func())\n\t\t\t\treg += compileExpr(context, reg, ex, ecnone(0))\n\t\t\t} else {\n\t\t\t\treg += compileExpr(context, reg, ex, ecnone(-2))\n\t\t\t\tcode.SetOpCode(code.LastPC(), OP_TAILCALL)\n\t\t\t}\n\t\t\tcode.AddABC(OP_RETURN, a, 0, 0, sline(stmt))\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor i, expr := range stmt.Exprs {\n\t\tif i == lenexprs-1 && isVarArgReturnExpr(expr) {\n\t\t\tcompileExpr(context, reg, expr, ecnone(-2))\n\t\t\tlastisvaarg = true\n\t\t} else {\n\t\t\treg += compileExpr(context, reg, expr, ecnone(0))\n\t\t}\n\t}\n\tcount := reg - a + 1\n\tif lastisvaarg {\n\t\tcount = 0\n\t}\n\tcontext.Code.AddABC(OP_RETURN, a, count, 0, sline(stmt))\n} // }}}\n\nfunc compileIfStmt(context *funcContext, stmt *ast.IfStmt) { // {{{\n\tthenlabel := context.NewLabel()\n\telselabel := context.NewLabel()\n\tendlabel := context.NewLabel()\n\n\tcompileBranchCondition(context, context.RegTop(), stmt.Condition, thenlabel, elselabel, false)\n\tcontext.SetLabelPc(thenlabel, context.Code.LastPC())\n\tcompileBlock(context, stmt.Then)\n\tif len(stmt.Else) > 0 {\n\t\tcontext.Code.AddASbx(OP_JMP, 0, endlabel, sline(stmt))\n\t}\n\tcontext.SetLabelPc(elselabel, context.Code.LastPC())\n\tif len(stmt.Else) > 0 {\n\t\tcompileBlock(context, stmt.Else)\n\t\tcontext.SetLabelPc(endlabel, context.Code.LastPC())\n\t}\n\n} // }}}\n\nfunc compileBranchCondition(context *funcContext, reg int, expr ast.Expr, thenlabel, elselabel int, hasnextcond bool) { // {{{\n\t// TODO folding constants?\n\tcode := context.Code\n\tflip := 0\n\tjumplabel := elselabel\n\tif hasnextcond {\n\t\tflip = 1\n\t\tjumplabel = thenlabel\n\t}\n\n\tswitch ex := expr.(type) {\n\tcase *ast.FalseExpr, *ast.NilExpr:\n\t\tif !hasnextcond {\n\t\t\tcode.AddASbx(OP_JMP, 0, elselabel, sline(expr))\n\t\t\treturn\n\t\t}\n\tcase *ast.TrueExpr, *ast.NumberExpr, *ast.StringExpr:\n\t\tif !hasnextcond {\n\t\t\treturn\n\t\t}\n\tcase *ast.UnaryNotOpExpr:\n\t\tcompileBranchCondition(context, reg, ex.Expr, elselabel, thenlabel, !hasnextcond)\n\t\treturn\n\tcase *ast.LogicalOpExpr:\n\t\tswitch ex.Operator {\n\t\tcase \"and\":\n\t\t\tnextcondlabel := context.NewLabel()\n\t\t\tcompileBranchCondition(context, reg, ex.Lhs, nextcondlabel, elselabel, false)\n\t\t\tcontext.SetLabelPc(nextcondlabel, context.Code.LastPC())\n\t\t\tcompileBranchCondition(context, reg, ex.Rhs, thenlabel, elselabel, hasnextcond)\n\t\tcase \"or\":\n\t\t\tnextcondlabel := context.NewLabel()\n\t\t\tcompileBranchCondition(context, reg, ex.Lhs, thenlabel, nextcondlabel, true)\n\t\t\tcontext.SetLabelPc(nextcondlabel, context.Code.LastPC())\n\t\t\tcompileBranchCondition(context, reg, ex.Rhs, thenlabel, elselabel, hasnextcond)\n\t\t}\n\t\treturn\n\tcase *ast.RelationalOpExpr:\n\t\tcompileRelationalOpExprAux(context, reg, ex, flip, jumplabel)\n\t\treturn\n\t}\n\n\ta := reg\n\tcompileExprWithMVPropagation(context, expr, &reg, &a)\n\tcode.AddABC(OP_TEST, a, 0, 0^flip, sline(expr))\n\tcode.AddASbx(OP_JMP, 0, jumplabel, sline(expr))\n} // }}}\n\nfunc compileWhileStmt(context *funcContext, stmt *ast.WhileStmt) { // {{{\n\tthenlabel := context.NewLabel()\n\telselabel := context.NewLabel()\n\tcondlabel := context.NewLabel()\n\n\tcontext.SetLabelPc(condlabel, context.Code.LastPC())\n\tcompileBranchCondition(context, context.RegTop(), stmt.Condition, thenlabel, elselabel, false)\n\tcontext.SetLabelPc(thenlabel, context.Code.LastPC())\n\tcontext.EnterBlock(elselabel, stmt)\n\tcompileChunk(context, stmt.Stmts, false)\n\tcontext.CloseUpvalues()\n\tcontext.Code.AddASbx(OP_JMP, 0, condlabel, eline(stmt))\n\tcontext.LeaveBlock()\n\tcontext.SetLabelPc(elselabel, context.Code.LastPC())\n} // }}}\n\nfunc compileRepeatStmt(context *funcContext, stmt *ast.RepeatStmt) { // {{{\n\tinitlabel := context.NewLabel()\n\tthenlabel := context.NewLabel()\n\telselabel := context.NewLabel()\n\n\tcontext.SetLabelPc(initlabel, context.Code.LastPC())\n\tcontext.SetLabelPc(elselabel, context.Code.LastPC())\n\tcontext.EnterBlock(thenlabel, stmt)\n\tcompileChunk(context, stmt.Stmts, true)\n\tcompileBranchCondition(context, context.RegTop(), stmt.Condition, thenlabel, elselabel, false)\n\n\tcontext.SetLabelPc(thenlabel, context.Code.LastPC())\n\tn := context.LeaveBlock()\n\n\tif n > -1 {\n\t\tlabel := context.NewLabel()\n\t\tcontext.Code.AddASbx(OP_JMP, 0, label, eline(stmt))\n\t\tcontext.SetLabelPc(elselabel, context.Code.LastPC())\n\t\tcontext.Code.AddABC(OP_CLOSE, n, 0, 0, eline(stmt))\n\t\tcontext.Code.AddASbx(OP_JMP, 0, initlabel, eline(stmt))\n\t\tcontext.SetLabelPc(label, context.Code.LastPC())\n\t}\n\n} // }}}\n\nfunc compileBreakStmt(context *funcContext, stmt *ast.BreakStmt) { // {{{\n\tfor block := context.Block; block != nil; block = block.Parent {\n\t\tif label := block.BreakLabel; label != labelNoJump {\n\t\t\tif block.RefUpvalue {\n\t\t\t\tcontext.Code.AddABC(OP_CLOSE, block.Parent.LocalVars.LastIndex(), 0, 0, sline(stmt))\n\t\t\t}\n\t\t\tcontext.Code.AddASbx(OP_JMP, 0, label, sline(stmt))\n\t\t\treturn\n\t\t}\n\t}\n\traiseCompileError(context, sline(stmt), \"no loop to break\")\n} // }}}\n\nfunc compileFuncDefStmt(context *funcContext, stmt *ast.FuncDefStmt) { // {{{\n\tif stmt.Name.Func == nil {\n\t\treg := context.RegTop()\n\t\tvar treg, kreg int\n\t\tcompileExprWithKMVPropagation(context, stmt.Name.Receiver, &reg, &treg)\n\t\tkreg = loadRk(context, &reg, stmt.Func, LString(stmt.Name.Method))\n\t\tcompileExpr(context, reg, stmt.Func, ecfuncdef)\n\t\tcontext.Code.AddABC(OP_SETTABLE, treg, kreg, reg, sline(stmt.Name.Receiver))\n\t} else {\n\t\tastmt := &ast.AssignStmt{Lhs: []ast.Expr{stmt.Name.Func}, Rhs: []ast.Expr{stmt.Func}}\n\t\tastmt.SetLine(sline(stmt.Func))\n\t\tastmt.SetLastLine(eline(stmt.Func))\n\t\tcompileAssignStmt(context, astmt)\n\t}\n} // }}}\n\nfunc compileNumberForStmt(context *funcContext, stmt *ast.NumberForStmt) { // {{{\n\tcode := context.Code\n\tendlabel := context.NewLabel()\n\tec := &expcontext{}\n\n\tcontext.EnterBlock(endlabel, stmt)\n\treg := context.RegTop()\n\trindex := context.RegisterLocalVar(\"(for index)\")\n\tecupdate(ec, ecLocal, rindex, 0)\n\tcompileExpr(context, reg, stmt.Init, ec)\n\n\treg = context.RegTop()\n\trlimit := context.RegisterLocalVar(\"(for limit)\")\n\tecupdate(ec, ecLocal, rlimit, 0)\n\tcompileExpr(context, reg, stmt.Limit, ec)\n\n\treg = context.RegTop()\n\trstep := context.RegisterLocalVar(\"(for step)\")\n\tif stmt.Step == nil {\n\t\tstmt.Step = &ast.NumberExpr{Value: \"1\"}\n\t\tstmt.Step.SetLine(sline(stmt.Init))\n\t}\n\tecupdate(ec, ecLocal, rstep, 0)\n\tcompileExpr(context, reg, stmt.Step, ec)\n\n\tcode.AddASbx(OP_FORPREP, rindex, 0, sline(stmt))\n\n\tcontext.RegisterLocalVar(stmt.Name)\n\n\tbodypc := code.LastPC()\n\tcompileChunk(context, stmt.Stmts, false)\n\n\tcontext.LeaveBlock()\n\n\tflpc := code.LastPC()\n\tcode.AddASbx(OP_FORLOOP, rindex, bodypc-(flpc+1), sline(stmt))\n\n\tcontext.SetLabelPc(endlabel, code.LastPC())\n\tcode.SetSbx(bodypc, flpc-bodypc)\n\n} // }}}\n\nfunc compileGenericForStmt(context *funcContext, stmt *ast.GenericForStmt) { // {{{\n\tcode := context.Code\n\tendlabel := context.NewLabel()\n\tbodylabel := context.NewLabel()\n\tfllabel := context.NewLabel()\n\tnnames := len(stmt.Names)\n\n\tcontext.EnterBlock(endlabel, stmt)\n\trgen := context.RegisterLocalVar(\"(for generator)\")\n\tcontext.RegisterLocalVar(\"(for state)\")\n\tcontext.RegisterLocalVar(\"(for control)\")\n\n\tcompileRegAssignment(context, stmt.Names, stmt.Exprs, context.RegTop()-3, 3, sline(stmt))\n\n\tcode.AddASbx(OP_JMP, 0, fllabel, sline(stmt))\n\n\tfor _, name := range stmt.Names {\n\t\tcontext.RegisterLocalVar(name)\n\t}\n\n\tcontext.SetLabelPc(bodylabel, code.LastPC())\n\tcompileChunk(context, stmt.Stmts, false)\n\n\tcontext.LeaveBlock()\n\n\tcontext.SetLabelPc(fllabel, code.LastPC())\n\tcode.AddABC(OP_TFORLOOP, rgen, 0, nnames, sline(stmt))\n\tcode.AddASbx(OP_JMP, 0, bodylabel, sline(stmt))\n\n\tcontext.SetLabelPc(endlabel, code.LastPC())\n} // }}}\n\nfunc compileLabelStmt(context *funcContext, stmt *ast.LabelStmt, isLastStmt bool) { // {{{\n\tlabelId := context.NewLabel()\n\tlabel := newLabelDesc(labelId, stmt.Name, context.Code.LastPC(), sline(stmt), context.BlockLocalVarsCount())\n\tcontext.AddNamedLabel(label)\n\tif isLastStmt {\n\t\tlabel.SetNumActiveLocalVars(context.Block.Parent.LocalVarsCount())\n\t}\n\tcontext.ResolveForwardGoto(label)\n} // }}}\n\nfunc compileGotoStmt(context *funcContext, stmt *ast.GotoStmt) { // {{{\n\tcontext.Code.AddABC(OP_CLOSE, 0, 0, 0, sline(stmt))\n\tcontext.Code.AddASbx(OP_JMP, 0, labelNoJump, sline(stmt))\n\tlabel := newLabelDesc(-1, stmt.Label, context.Code.LastPC(), sline(stmt), context.BlockLocalVarsCount())\n\tcontext.AddUnresolvedGoto(label)\n\tcontext.FindLabel(context.Block, label, context.gotosCount-1)\n} // }}}\n\nfunc compileExpr(context *funcContext, reg int, expr ast.Expr, ec *expcontext) int { // {{{\n\tcode := context.Code\n\tsreg := savereg(ec, reg)\n\tsused := 1\n\tif sreg < reg {\n\t\tsused = 0\n\t}\n\n\tswitch ex := expr.(type) {\n\tcase *ast.StringExpr:\n\t\tcode.AddABx(OP_LOADK, sreg, context.ConstIndex(LString(ex.Value)), sline(ex))\n\t\treturn sused\n\tcase *ast.NumberExpr:\n\t\tnum, err := parseNumber(ex.Value)\n\t\tif err != nil {\n\t\t\tnum = LNumber(math.NaN())\n\t\t}\n\t\tcode.AddABx(OP_LOADK, sreg, context.ConstIndex(num), sline(ex))\n\t\treturn sused\n\tcase *constLValueExpr:\n\t\tcode.AddABx(OP_LOADK, sreg, context.ConstIndex(ex.Value), sline(ex))\n\t\treturn sused\n\tcase *ast.NilExpr:\n\t\tcode.AddLoadNil(sreg, sreg, sline(ex))\n\t\treturn sused\n\tcase *ast.FalseExpr:\n\t\tcode.AddABC(OP_LOADBOOL, sreg, 0, 0, sline(ex))\n\t\treturn sused\n\tcase *ast.TrueExpr:\n\t\tcode.AddABC(OP_LOADBOOL, sreg, 1, 0, sline(ex))\n\t\treturn sused\n\tcase *ast.IdentExpr:\n\t\tswitch getIdentRefType(context, context, ex) {\n\t\tcase ecGlobal:\n\t\t\tcode.AddABx(OP_GETGLOBAL, sreg, context.ConstIndex(LString(ex.Value)), sline(ex))\n\t\tcase ecUpvalue:\n\t\t\tcode.AddABC(OP_GETUPVAL, sreg, context.Upvalues.RegisterUnique(ex.Value), 0, sline(ex))\n\t\tcase ecLocal:\n\t\t\tb := context.FindLocalVar(ex.Value)\n\t\t\tcode.AddABC(OP_MOVE, sreg, b, 0, sline(ex))\n\t\t}\n\t\treturn sused\n\tcase *ast.Comma3Expr:\n\t\tif context.Proto.IsVarArg == 0 {\n\t\t\traiseCompileError(context, sline(ex), \"cannot use '...' outside a vararg function\")\n\t\t}\n\t\tcontext.Proto.IsVarArg &= ^VarArgNeedsArg\n\t\tcode.AddABC(OP_VARARG, sreg, 2+ec.varargopt, 0, sline(ex))\n\t\tif context.RegTop() > (sreg+2+ec.varargopt) || ec.varargopt < -1 {\n\t\t\treturn 0\n\t\t}\n\t\treturn (sreg + 1 + ec.varargopt) - reg\n\tcase *ast.AttrGetExpr:\n\t\ta := sreg\n\t\tb := reg\n\t\tcompileExprWithMVPropagation(context, ex.Object, &reg, &b)\n\t\tc := reg\n\t\tcompileExprWithKMVPropagation(context, ex.Key, &reg, &c)\n\t\topcode := OP_GETTABLE\n\t\tif _, ok := ex.Key.(*ast.StringExpr); ok {\n\t\t\topcode = OP_GETTABLEKS\n\t\t}\n\t\tcode.AddABC(opcode, a, b, c, sline(ex))\n\t\treturn sused\n\tcase *ast.TableExpr:\n\t\tcompileTableExpr(context, reg, ex, ec)\n\t\treturn 1\n\tcase *ast.ArithmeticOpExpr:\n\t\tcompileArithmeticOpExpr(context, reg, ex, ec)\n\t\treturn sused\n\tcase *ast.StringConcatOpExpr:\n\t\tcompileStringConcatOpExpr(context, reg, ex, ec)\n\t\treturn sused\n\tcase *ast.UnaryMinusOpExpr, *ast.UnaryNotOpExpr, *ast.UnaryLenOpExpr:\n\t\tcompileUnaryOpExpr(context, reg, ex, ec)\n\t\treturn sused\n\tcase *ast.RelationalOpExpr:\n\t\tcompileRelationalOpExpr(context, reg, ex, ec)\n\t\treturn sused\n\tcase *ast.LogicalOpExpr:\n\t\tcompileLogicalOpExpr(context, reg, ex, ec)\n\t\treturn sused\n\tcase *ast.FuncCallExpr:\n\t\treturn compileFuncCallExpr(context, reg, ex, ec)\n\tcase *ast.FunctionExpr:\n\t\tchildcontext := newFuncContext(context.Proto.SourceName, context)\n\t\tcompileFunctionExpr(childcontext, ex, ec)\n\t\tprotono := len(context.Proto.FunctionPrototypes)\n\t\tcontext.Proto.FunctionPrototypes = append(context.Proto.FunctionPrototypes, childcontext.Proto)\n\t\tcode.AddABx(OP_CLOSURE, sreg, protono, sline(ex))\n\t\tfor _, upvalue := range childcontext.Upvalues.List() {\n\t\t\tlocalidx, block := context.FindLocalVarAndBlock(upvalue.Name)\n\t\t\tif localidx > -1 {\n\t\t\t\tcode.AddABC(OP_MOVE, 0, localidx, 0, sline(ex))\n\t\t\t\tblock.RefUpvalue = true\n\t\t\t} else {\n\t\t\t\tupvalueidx := context.Upvalues.Find(upvalue.Name)\n\t\t\t\tif upvalueidx < 0 {\n\t\t\t\t\tupvalueidx = context.Upvalues.RegisterUnique(upvalue.Name)\n\t\t\t\t}\n\t\t\t\tcode.AddABC(OP_GETUPVAL, 0, upvalueidx, 0, sline(ex))\n\t\t\t}\n\t\t}\n\t\treturn sused\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"expr %v not implemented.\", reflect.TypeOf(ex).Elem().Name()))\n\t}\n\n} // }}}\n\nfunc compileExprWithPropagation(context *funcContext, expr ast.Expr, reg *int, save *int, propergator func(int, *int, *int, int)) { // {{{\n\treginc := compileExpr(context, *reg, expr, ecnone(0))\n\tif _, ok := expr.(*ast.LogicalOpExpr); ok {\n\t\t*save = *reg\n\t\t*reg = *reg + reginc\n\t} else {\n\t\tpropergator(context.RegTop(), save, reg, reginc)\n\t}\n} // }}}\n\nfunc compileExprWithKMVPropagation(context *funcContext, expr ast.Expr, reg *int, save *int) { // {{{\n\tcompileExprWithPropagation(context, expr, reg, save, context.Code.PropagateKMV)\n} // }}}\n\nfunc compileExprWithMVPropagation(context *funcContext, expr ast.Expr, reg *int, save *int) { // {{{\n\tcompileExprWithPropagation(context, expr, reg, save, context.Code.PropagateMV)\n} // }}}\n\nfunc constFold(exp ast.Expr) ast.Expr { // {{{\n\tswitch expr := exp.(type) {\n\tcase *ast.ArithmeticOpExpr:\n\t\tlvalue, lisconst := lnumberValue(constFold(expr.Lhs))\n\t\trvalue, risconst := lnumberValue(constFold(expr.Rhs))\n\t\tif lisconst && risconst {\n\t\t\tswitch expr.Operator {\n\t\t\tcase \"+\":\n\t\t\t\treturn &constLValueExpr{Value: lvalue + rvalue}\n\t\t\tcase \"-\":\n\t\t\t\treturn &constLValueExpr{Value: lvalue - rvalue}\n\t\t\tcase \"*\":\n\t\t\t\treturn &constLValueExpr{Value: lvalue * rvalue}\n\t\t\tcase \"/\":\n\t\t\t\treturn &constLValueExpr{Value: lvalue / rvalue}\n\t\t\tcase \"%\":\n\t\t\t\treturn &constLValueExpr{Value: luaModulo(lvalue, rvalue)}\n\t\t\tcase \"^\":\n\t\t\t\treturn &constLValueExpr{Value: LNumber(math.Pow(float64(lvalue), float64(rvalue)))}\n\t\t\tdefault:\n\t\t\t\tpanic(fmt.Sprintf(\"unknown binop: %v\", expr.Operator))\n\t\t\t}\n\t\t} else {\n\t\t\treturn expr\n\t\t}\n\tcase *ast.UnaryMinusOpExpr:\n\t\texpr.Expr = constFold(expr.Expr)\n\t\tif value, ok := lnumberValue(expr.Expr); ok {\n\t\t\treturn &constLValueExpr{Value: LNumber(-value)}\n\t\t}\n\t\treturn expr\n\tdefault:\n\n\t\treturn exp\n\t}\n} // }}}\n\nfunc compileFunctionExpr(context *funcContext, funcexpr *ast.FunctionExpr, ec *expcontext) { // {{{\n\tcontext.Proto.LineDefined = sline(funcexpr)\n\tcontext.Proto.LastLineDefined = eline(funcexpr)\n\tif len(funcexpr.ParList.Names) > maxRegisters {\n\t\traiseCompileError(context, context.Proto.LineDefined, \"register overflow\")\n\t}\n\tcontext.Proto.NumParameters = uint8(len(funcexpr.ParList.Names))\n\tif ec.ctype == ecMethod {\n\t\tcontext.Proto.NumParameters += 1\n\t\tcontext.RegisterLocalVar(\"self\")\n\t}\n\tfor _, name := range funcexpr.ParList.Names {\n\t\tcontext.RegisterLocalVar(name)\n\t}\n\tif funcexpr.ParList.HasVargs {\n\t\tif CompatVarArg {\n\t\t\tcontext.Proto.IsVarArg = VarArgHasArg | VarArgNeedsArg\n\t\t\tif context.Parent != nil {\n\t\t\t\tcontext.RegisterLocalVar(\"arg\")\n\t\t\t}\n\t\t}\n\t\tcontext.Proto.IsVarArg |= VarArgIsVarArg\n\t}\n\n\tcompileChunk(context, funcexpr.Stmts, false)\n\n\tcontext.Code.AddABC(OP_RETURN, 0, 1, 0, eline(funcexpr))\n\tcontext.EndScope()\n\tcontext.CheckUnresolvedGoto()\n\tcontext.Proto.Code = context.Code.List()\n\tcontext.Proto.DbgSourcePositions = context.Code.PosList()\n\tcontext.Proto.DbgUpvalues = context.Upvalues.Names()\n\tcontext.Proto.NumUpvalues = uint8(len(context.Proto.DbgUpvalues))\n\tfor _, clv := range context.Proto.Constants {\n\t\tsv := \"\"\n\t\tif slv, ok := clv.(LString); ok {\n\t\t\tsv = string(slv)\n\t\t}\n\t\tcontext.Proto.stringConstants = append(context.Proto.stringConstants, sv)\n\t}\n\tpatchCode(context)\n} // }}}\n\nfunc compileTableExpr(context *funcContext, reg int, ex *ast.TableExpr, ec *expcontext) { // {{{\n\tcode := context.Code\n\t/*\n\t\ttablereg := savereg(ec, reg)\n\t\tif tablereg == reg {\n\t\t\treg += 1\n\t\t}\n\t*/\n\ttablereg := reg\n\treg++\n\tcode.AddABC(OP_NEWTABLE, tablereg, 0, 0, sline(ex))\n\ttablepc := code.LastPC()\n\tregbase := reg\n\n\tarraycount := 0\n\tlastvararg := false\n\tfor i, field := range ex.Fields {\n\t\tislast := i == len(ex.Fields)-1\n\t\tif field.Key == nil {\n\t\t\tif islast && isVarArgReturnExpr(field.Value) {\n\t\t\t\treg += compileExpr(context, reg, field.Value, ecnone(-2))\n\t\t\t\tlastvararg = true\n\t\t\t} else {\n\t\t\t\treg += compileExpr(context, reg, field.Value, ecnone(0))\n\t\t\t\tarraycount += 1\n\t\t\t}\n\t\t} else {\n\t\t\tregorg := reg\n\t\t\tb := reg\n\t\t\tcompileExprWithKMVPropagation(context, field.Key, &reg, &b)\n\t\t\tc := reg\n\t\t\tcompileExprWithKMVPropagation(context, field.Value, &reg, &c)\n\t\t\topcode := OP_SETTABLE\n\t\t\tif _, ok := field.Key.(*ast.StringExpr); ok {\n\t\t\t\topcode = OP_SETTABLEKS\n\t\t\t}\n\t\t\tcode.AddABC(opcode, tablereg, b, c, sline(ex))\n\t\t\treg = regorg\n\t\t}\n\t\tflush := arraycount % FieldsPerFlush\n\t\tif (arraycount != 0 && (flush == 0 || islast)) || lastvararg {\n\t\t\treg = regbase\n\t\t\tnum := flush\n\t\t\tif num == 0 {\n\t\t\t\tnum = FieldsPerFlush\n\t\t\t}\n\t\t\tc := (arraycount-1)/FieldsPerFlush + 1\n\t\t\tb := num\n\t\t\tif islast && isVarArgReturnExpr(field.Value) {\n\t\t\t\tb = 0\n\t\t\t}\n\t\t\tline := field.Value\n\t\t\tif field.Key != nil {\n\t\t\t\tline = field.Key\n\t\t\t}\n\t\t\tif c > 511 {\n\t\t\t\tc = 0\n\t\t\t}\n\t\t\tcode.AddABC(OP_SETLIST, tablereg, b, c, sline(line))\n\t\t\tif c == 0 {\n\t\t\t\tcode.Add(uint32(c), sline(line))\n\t\t\t}\n\t\t}\n\t}\n\tcode.SetB(tablepc, int2Fb(arraycount))\n\tcode.SetC(tablepc, int2Fb(len(ex.Fields)-arraycount))\n\tif shouldmove(ec, tablereg) {\n\t\tcode.AddABC(OP_MOVE, ec.reg, tablereg, 0, sline(ex))\n\t}\n} // }}}\n\nfunc compileArithmeticOpExpr(context *funcContext, reg int, expr *ast.ArithmeticOpExpr, ec *expcontext) { // {{{\n\texp := constFold(expr)\n\tif ex, ok := exp.(*constLValueExpr); ok {\n\t\texp.SetLine(sline(expr))\n\t\tcompileExpr(context, reg, ex, ec)\n\t\treturn\n\t}\n\texpr, _ = exp.(*ast.ArithmeticOpExpr)\n\ta := savereg(ec, reg)\n\tb := reg\n\tcompileExprWithKMVPropagation(context, expr.Lhs, &reg, &b)\n\tc := reg\n\tcompileExprWithKMVPropagation(context, expr.Rhs, &reg, &c)\n\n\top := 0\n\tswitch expr.Operator {\n\tcase \"+\":\n\t\top = OP_ADD\n\tcase \"-\":\n\t\top = OP_SUB\n\tcase \"*\":\n\t\top = OP_MUL\n\tcase \"/\":\n\t\top = OP_DIV\n\tcase \"%\":\n\t\top = OP_MOD\n\tcase \"^\":\n\t\top = OP_POW\n\t}\n\tcontext.Code.AddABC(op, a, b, c, sline(expr))\n} // }}}\n\nfunc compileStringConcatOpExpr(context *funcContext, reg int, expr *ast.StringConcatOpExpr, ec *expcontext) { // {{{\n\tcode := context.Code\n\tcrange := 1\n\tfor current := expr.Rhs; current != nil; {\n\t\tif ex, ok := current.(*ast.StringConcatOpExpr); ok {\n\t\t\tcrange += 1\n\t\t\tcurrent = ex.Rhs\n\t\t} else {\n\t\t\tcurrent = nil\n\t\t}\n\t}\n\ta := savereg(ec, reg)\n\tbasereg := reg\n\treg += compileExpr(context, reg, expr.Lhs, ecnone(0))\n\treg += compileExpr(context, reg, expr.Rhs, ecnone(0))\n\tfor pc := code.LastPC(); pc != 0 && opGetOpCode(code.At(pc)) == OP_CONCAT; pc-- {\n\t\tcode.Pop()\n\t}\n\tcode.AddABC(OP_CONCAT, a, basereg, basereg+crange, sline(expr))\n} // }}}\n\nfunc compileUnaryOpExpr(context *funcContext, reg int, expr ast.Expr, ec *expcontext) { // {{{\n\topcode := 0\n\tcode := context.Code\n\tvar operandexpr ast.Expr\n\tswitch ex := expr.(type) {\n\tcase *ast.UnaryMinusOpExpr:\n\t\texp := constFold(ex)\n\t\tif lvexpr, ok := exp.(*constLValueExpr); ok {\n\t\t\texp.SetLine(sline(expr))\n\t\t\tcompileExpr(context, reg, lvexpr, ec)\n\t\t\treturn\n\t\t}\n\t\tex, _ = exp.(*ast.UnaryMinusOpExpr)\n\t\toperandexpr = ex.Expr\n\t\topcode = OP_UNM\n\tcase *ast.UnaryNotOpExpr:\n\t\tswitch ex.Expr.(type) {\n\t\tcase *ast.TrueExpr:\n\t\t\tcode.AddABC(OP_LOADBOOL, savereg(ec, reg), 0, 0, sline(expr))\n\t\t\treturn\n\t\tcase *ast.FalseExpr, *ast.NilExpr:\n\t\t\tcode.AddABC(OP_LOADBOOL, savereg(ec, reg), 1, 0, sline(expr))\n\t\t\treturn\n\t\tdefault:\n\t\t\topcode = OP_NOT\n\t\t\toperandexpr = ex.Expr\n\t\t}\n\tcase *ast.UnaryLenOpExpr:\n\t\topcode = OP_LEN\n\t\toperandexpr = ex.Expr\n\t}\n\n\ta := savereg(ec, reg)\n\tb := reg\n\tcompileExprWithMVPropagation(context, operandexpr, &reg, &b)\n\tcode.AddABC(opcode, a, b, 0, sline(expr))\n} // }}}\n\nfunc compileRelationalOpExprAux(context *funcContext, reg int, expr *ast.RelationalOpExpr, flip int, label int) { // {{{\n\tcode := context.Code\n\tb := reg\n\tcompileExprWithKMVPropagation(context, expr.Lhs, &reg, &b)\n\tc := reg\n\tcompileExprWithKMVPropagation(context, expr.Rhs, &reg, &c)\n\tswitch expr.Operator {\n\tcase \"<\":\n\t\tcode.AddABC(OP_LT, 0^flip, b, c, sline(expr))\n\tcase \">\":\n\t\tcode.AddABC(OP_LT, 0^flip, c, b, sline(expr))\n\tcase \"<=\":\n\t\tcode.AddABC(OP_LE, 0^flip, b, c, sline(expr))\n\tcase \">=\":\n\t\tcode.AddABC(OP_LE, 0^flip, c, b, sline(expr))\n\tcase \"==\":\n\t\tcode.AddABC(OP_EQ, 0^flip, b, c, sline(expr))\n\tcase \"~=\":\n\t\tcode.AddABC(OP_EQ, 1^flip, b, c, sline(expr))\n\t}\n\tcode.AddASbx(OP_JMP, 0, label, sline(expr))\n} // }}}\n\nfunc compileRelationalOpExpr(context *funcContext, reg int, expr *ast.RelationalOpExpr, ec *expcontext) { // {{{\n\ta := savereg(ec, reg)\n\tcode := context.Code\n\tjumplabel := context.NewLabel()\n\tcompileRelationalOpExprAux(context, reg, expr, 1, jumplabel)\n\tcode.AddABC(OP_LOADBOOL, a, 0, 1, sline(expr))\n\tcontext.SetLabelPc(jumplabel, code.LastPC())\n\tcode.AddABC(OP_LOADBOOL, a, 1, 0, sline(expr))\n} // }}}\n\nfunc compileLogicalOpExpr(context *funcContext, reg int, expr *ast.LogicalOpExpr, ec *expcontext) { // {{{\n\ta := savereg(ec, reg)\n\tcode := context.Code\n\tendlabel := context.NewLabel()\n\tlb := &lblabels{context.NewLabel(), context.NewLabel(), endlabel, false}\n\tnextcondlabel := context.NewLabel()\n\tif expr.Operator == \"and\" {\n\t\tcompileLogicalOpExprAux(context, reg, expr.Lhs, ec, nextcondlabel, endlabel, false, lb)\n\t\tcontext.SetLabelPc(nextcondlabel, code.LastPC())\n\t\tcompileLogicalOpExprAux(context, reg, expr.Rhs, ec, endlabel, endlabel, false, lb)\n\t} else {\n\t\tcompileLogicalOpExprAux(context, reg, expr.Lhs, ec, endlabel, nextcondlabel, true, lb)\n\t\tcontext.SetLabelPc(nextcondlabel, code.LastPC())\n\t\tcompileLogicalOpExprAux(context, reg, expr.Rhs, ec, endlabel, endlabel, false, lb)\n\t}\n\n\tif lb.b {\n\t\tcontext.SetLabelPc(lb.f, code.LastPC())\n\t\tcode.AddABC(OP_LOADBOOL, a, 0, 1, sline(expr))\n\t\tcontext.SetLabelPc(lb.t, code.LastPC())\n\t\tcode.AddABC(OP_LOADBOOL, a, 1, 0, sline(expr))\n\t}\n\n\tlastinst := code.Last()\n\tif opGetOpCode(lastinst) == OP_JMP && opGetArgSbx(lastinst) == endlabel {\n\t\tcode.Pop()\n\t}\n\n\tcontext.SetLabelPc(endlabel, code.LastPC())\n} // }}}\n\nfunc compileLogicalOpExprAux(context *funcContext, reg int, expr ast.Expr, ec *expcontext, thenlabel, elselabel int, hasnextcond bool, lb *lblabels) { // {{{\n\t// TODO folding constants?\n\tcode := context.Code\n\tflip := 0\n\tjumplabel := elselabel\n\tif hasnextcond {\n\t\tflip = 1\n\t\tjumplabel = thenlabel\n\t}\n\n\tswitch ex := expr.(type) {\n\tcase *ast.FalseExpr:\n\t\tif elselabel == lb.e {\n\t\t\tcode.AddASbx(OP_JMP, 0, lb.f, sline(expr))\n\t\t\tlb.b = true\n\t\t} else {\n\t\t\tcode.AddASbx(OP_JMP, 0, elselabel, sline(expr))\n\t\t}\n\t\treturn\n\tcase *ast.NilExpr:\n\t\tif elselabel == lb.e {\n\t\t\tcompileExpr(context, reg, expr, ec)\n\t\t\tcode.AddASbx(OP_JMP, 0, lb.e, sline(expr))\n\t\t} else {\n\t\t\tcode.AddASbx(OP_JMP, 0, elselabel, sline(expr))\n\t\t}\n\t\treturn\n\tcase *ast.TrueExpr:\n\t\tif thenlabel == lb.e {\n\t\t\tcode.AddASbx(OP_JMP, 0, lb.t, sline(expr))\n\t\t\tlb.b = true\n\t\t} else {\n\t\t\tcode.AddASbx(OP_JMP, 0, thenlabel, sline(expr))\n\t\t}\n\t\treturn\n\tcase *ast.NumberExpr, *ast.StringExpr:\n\t\tif thenlabel == lb.e {\n\t\t\tcompileExpr(context, reg, expr, ec)\n\t\t\tcode.AddASbx(OP_JMP, 0, lb.e, sline(expr))\n\t\t} else {\n\t\t\tcode.AddASbx(OP_JMP, 0, thenlabel, sline(expr))\n\t\t}\n\t\treturn\n\tcase *ast.LogicalOpExpr:\n\t\tswitch ex.Operator {\n\t\tcase \"and\":\n\t\t\tnextcondlabel := context.NewLabel()\n\t\t\tcompileLogicalOpExprAux(context, reg, ex.Lhs, ec, nextcondlabel, elselabel, false, lb)\n\t\t\tcontext.SetLabelPc(nextcondlabel, context.Code.LastPC())\n\t\t\tcompileLogicalOpExprAux(context, reg, ex.Rhs, ec, thenlabel, elselabel, hasnextcond, lb)\n\t\tcase \"or\":\n\t\t\tnextcondlabel := context.NewLabel()\n\t\t\tcompileLogicalOpExprAux(context, reg, ex.Lhs, ec, thenlabel, nextcondlabel, true, lb)\n\t\t\tcontext.SetLabelPc(nextcondlabel, context.Code.LastPC())\n\t\t\tcompileLogicalOpExprAux(context, reg, ex.Rhs, ec, thenlabel, elselabel, hasnextcond, lb)\n\t\t}\n\t\treturn\n\tcase *ast.RelationalOpExpr:\n\t\tif thenlabel == elselabel {\n\t\t\tflip ^= 1\n\t\t\tjumplabel = lb.t\n\t\t\tlb.b = true\n\t\t} else if thenlabel == lb.e {\n\t\t\tjumplabel = lb.t\n\t\t\tlb.b = true\n\t\t} else if elselabel == lb.e {\n\t\t\tjumplabel = lb.f\n\t\t\tlb.b = true\n\t\t}\n\t\tcompileRelationalOpExprAux(context, reg, ex, flip, jumplabel)\n\t\treturn\n\t}\n\n\ta := reg\n\tsreg := savereg(ec, a)\n\tisLastAnd := elselabel == lb.e && thenlabel != elselabel\n\tisLastOr := thenlabel == lb.e && hasnextcond\n\n\tif ident, ok := expr.(*ast.IdentExpr); ok && (isLastAnd || isLastOr) && getIdentRefType(context, context, ident) == ecLocal {\n\t\tb := context.FindLocalVar(ident.Value)\n\t\top := OP_TESTSET\n\t\tif sreg == b {\n\t\t\top = OP_TEST\n\t\t}\n\t\tcode.AddABC(op, sreg, b, 0^flip, sline(expr))\n\t} else if !hasnextcond && thenlabel == elselabel {\n\t\treg += compileExpr(context, reg, expr, &expcontext{ec.ctype, intMax(a, sreg), ec.varargopt})\n\t\tlast := context.Code.Last()\n\t\tif opGetOpCode(last) == OP_MOVE && opGetArgA(last) == a {\n\t\t\tcontext.Code.SetA(context.Code.LastPC(), sreg)\n\t\t} else {\n\t\t\tcontext.Code.AddABC(OP_MOVE, sreg, a, 0, sline(expr))\n\t\t}\n\t} else {\n\t\treg += compileExpr(context, reg, expr, ecnone(0))\n\t\tif !hasnextcond {\n\t\t\tcode.AddABC(OP_TEST, a, 0, 0^flip, sline(expr))\n\t\t} else {\n\t\t\tcode.AddABC(OP_TESTSET, sreg, a, 0^flip, sline(expr))\n\t\t}\n\t}\n\tcode.AddASbx(OP_JMP, 0, jumplabel, sline(expr))\n} // }}}\n\nfunc compileFuncCallExpr(context *funcContext, reg int, expr *ast.FuncCallExpr, ec *expcontext) int { // {{{\n\tfuncreg := reg\n\tif ec.ctype == ecLocal && ec.reg == (int(context.Proto.NumParameters)-1) {\n\t\tfuncreg = ec.reg\n\t\treg = ec.reg\n\t}\n\targc := len(expr.Args)\n\tislastvararg := false\n\tname := \"(anonymous)\"\n\n\tif expr.Func != nil { // hoge.func()\n\t\treg += compileExpr(context, reg, expr.Func, ecnone(0))\n\t\tname = getExprName(context, expr.Func)\n\t} else { // hoge:method()\n\t\tb := reg\n\t\tcompileExprWithMVPropagation(context, expr.Receiver, &reg, &b)\n\t\tc := loadRk(context, &reg, expr, LString(expr.Method))\n\t\tcontext.Code.AddABC(OP_SELF, funcreg, b, c, sline(expr))\n\t\t// increments a register for an implicit \"self\"\n\t\treg = b + 1\n\t\treg2 := funcreg + 2\n\t\tif reg2 > reg {\n\t\t\treg = reg2\n\t\t}\n\t\targc += 1\n\t\tname = string(expr.Method)\n\t}\n\n\tfor i, ar := range expr.Args {\n\t\tislastvararg = (i == len(expr.Args)-1) && isVarArgReturnExpr(ar)\n\t\tif islastvararg {\n\t\t\tcompileExpr(context, reg, ar, ecnone(-2))\n\t\t} else {\n\t\t\treg += compileExpr(context, reg, ar, ecnone(0))\n\t\t}\n\t}\n\tb := argc + 1\n\tif islastvararg {\n\t\tb = 0\n\t}\n\tcontext.Code.AddABC(OP_CALL, funcreg, b, ec.varargopt+2, sline(expr))\n\tcontext.Proto.DbgCalls = append(context.Proto.DbgCalls, DbgCall{Pc: context.Code.LastPC(), Name: name})\n\n\tif ec.varargopt == 0 && shouldmove(ec, funcreg) {\n\t\tcontext.Code.AddABC(OP_MOVE, ec.reg, funcreg, 0, sline(expr))\n\t\treturn 1\n\t}\n\tif context.RegTop() > (funcreg+2+ec.varargopt) || ec.varargopt < -1 {\n\t\treturn 0\n\t}\n\treturn ec.varargopt + 1\n} // }}}\n\nfunc loadRk(context *funcContext, reg *int, expr ast.Expr, cnst LValue) int { // {{{\n\tcindex := context.ConstIndex(cnst)\n\tif cindex <= opMaxIndexRk {\n\t\treturn opRkAsk(cindex)\n\t} else {\n\t\tret := *reg\n\t\t*reg++\n\t\tcontext.Code.AddABx(OP_LOADK, ret, cindex, sline(expr))\n\t\treturn ret\n\t}\n} // }}}\n\nfunc getIdentRefType(context *funcContext, current *funcContext, expr *ast.IdentExpr) expContextType { // {{{\n\tif current == nil {\n\t\treturn ecGlobal\n\t} else if current.FindLocalVar(expr.Value) > -1 {\n\t\tif current == context {\n\t\t\treturn ecLocal\n\t\t}\n\t\treturn ecUpvalue\n\t}\n\treturn getIdentRefType(context, current.Parent, expr)\n} // }}}\n\nfunc getExprName(context *funcContext, expr ast.Expr) string { // {{{\n\tswitch ex := expr.(type) {\n\tcase *ast.IdentExpr:\n\t\treturn ex.Value\n\tcase *ast.AttrGetExpr:\n\t\tswitch kex := ex.Key.(type) {\n\t\tcase *ast.StringExpr:\n\t\t\treturn kex.Value\n\t\t}\n\t\treturn \"?\"\n\t}\n\treturn \"?\"\n} // }}}\n\nfunc patchCode(context *funcContext) { // {{{\n\tmaxreg := 1\n\tif np := int(context.Proto.NumParameters); np > 1 {\n\t\tmaxreg = np\n\t}\n\tmoven := 0\n\tcode := context.Code.List()\n\tfor pc := 0; pc < len(code); pc++ {\n\t\tinst := code[pc]\n\t\tcurop := opGetOpCode(inst)\n\t\tswitch curop {\n\t\tcase OP_CLOSURE:\n\t\t\tpc += int(context.Proto.FunctionPrototypes[opGetArgBx(inst)].NumUpvalues)\n\t\t\tmoven = 0\n\t\t\tcontinue\n\t\tcase OP_SETGLOBAL, OP_SETUPVAL, OP_EQ, OP_LT, OP_LE, OP_TEST,\n\t\t\tOP_TAILCALL, OP_RETURN, OP_FORPREP, OP_FORLOOP, OP_TFORLOOP,\n\t\t\tOP_SETLIST, OP_CLOSE:\n\t\t\t/* nothing to do */\n\t\tcase OP_CALL:\n\t\t\tif reg := opGetArgA(inst) + opGetArgC(inst) - 2; reg > maxreg {\n\t\t\t\tmaxreg = reg\n\t\t\t}\n\t\tcase OP_VARARG:\n\t\t\tif reg := opGetArgA(inst) + opGetArgB(inst) - 1; reg > maxreg {\n\t\t\t\tmaxreg = reg\n\t\t\t}\n\t\tcase OP_SELF:\n\t\t\tif reg := opGetArgA(inst) + 1; reg > maxreg {\n\t\t\t\tmaxreg = reg\n\t\t\t}\n\t\tcase OP_LOADNIL:\n\t\t\tif reg := opGetArgB(inst); reg > maxreg {\n\t\t\t\tmaxreg = reg\n\t\t\t}\n\t\tcase OP_JMP: // jump to jump optimization\n\t\t\tdistance := 0\n\t\t\tcount := 0 // avoiding infinite loops\n\t\t\tfor jmp := inst; opGetOpCode(jmp) == OP_JMP && count < 5; jmp = context.Code.At(pc + distance + 1) {\n\t\t\t\td := context.GetLabelPc(opGetArgSbx(jmp)) - pc\n\t\t\t\tif d > opMaxArgSbx {\n\t\t\t\t\tif distance == 0 {\n\t\t\t\t\t\traiseCompileError(context, context.Proto.LineDefined, \"too long to jump.\")\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdistance = d\n\t\t\t\tcount++\n\t\t\t}\n\t\t\tif distance == 0 {\n\t\t\t\tcontext.Code.SetOpCode(pc, OP_NOP)\n\t\t\t} else {\n\t\t\t\tcontext.Code.SetSbx(pc, distance)\n\t\t\t}\n\t\tdefault:\n\t\t\tif reg := opGetArgA(inst); reg > maxreg {\n\t\t\t\tmaxreg = reg\n\t\t\t}\n\t\t}\n\n\t\t// bulk move optimization(reducing op dipatch costs)\n\t\tif curop == OP_MOVE {\n\t\t\tmoven++\n\t\t} else {\n\t\t\tif moven > 1 {\n\t\t\t\tcontext.Code.SetOpCode(pc-moven, OP_MOVEN)\n\t\t\t\tcontext.Code.SetC(pc-moven, intMin(moven-1, opMaxArgsC))\n\t\t\t}\n\t\t\tmoven = 0\n\t\t}\n\t}\n\tmaxreg++\n\tif maxreg > maxRegisters {\n\t\traiseCompileError(context, context.Proto.LineDefined, \"register overflow(too many local variables)\")\n\t}\n\tcontext.Proto.NumUsedRegisters = uint8(maxreg)\n} // }}}\n\nfunc Compile(chunk []ast.Stmt, name string) (proto *FunctionProto, err error) { // {{{\n\tdefer func() {\n\t\tif rcv := recover(); rcv != nil {\n\t\t\tif _, ok := rcv.(*CompileError); ok {\n\t\t\t\terr = rcv.(error)\n\t\t\t} else {\n\t\t\t\tpanic(rcv)\n\t\t\t}\n\t\t}\n\t}()\n\terr = nil\n\tparlist := &ast.ParList{HasVargs: true, Names: []string{}}\n\tfuncexpr := &ast.FunctionExpr{ParList: parlist, Stmts: chunk}\n\tif len(chunk) > 0 {\n\t\tfuncexpr.SetLastLine(sline(chunk[0]))\n\t\tfuncexpr.SetLastLine(eline(chunk[len(chunk)-1]) + 1)\n\t}\n\tcontext := newFuncContext(name, nil)\n\tcompileFunctionExpr(context, funcexpr, ecnone(0))\n\tproto = context.Proto\n\treturn\n} // }}}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 0.8671875,
          "content": "package lua\n\nimport (\n\t\"os\"\n)\n\nvar CompatVarArg = true\nvar FieldsPerFlush = 50\nvar RegistrySize = 256 * 20\nvar RegistryGrowStep = 32\nvar CallStackSize = 256\nvar MaxTableGetLoop = 100\nvar MaxArrayIndex = 67108864\n\ntype LNumber float64\n\nconst LNumberBit = 64\nconst LNumberScanFormat = \"%f\"\nconst LuaVersion = \"Lua 5.1\"\n\nvar LuaPath = \"LUA_PATH\"\nvar LuaLDir string\nvar LuaPathDefault string\nvar LuaOS string\nvar LuaDirSep string\nvar LuaPathSep = \";\"\nvar LuaPathMark = \"?\"\nvar LuaExecDir = \"!\"\nvar LuaIgMark = \"-\"\n\nfunc init() {\n\tif os.PathSeparator == '/' { // unix-like\n\t\tLuaOS = \"unix\"\n\t\tLuaLDir = \"/usr/local/share/lua/5.1\"\n\t\tLuaDirSep = \"/\"\n\t\tLuaPathDefault = \"./?.lua;\" + LuaLDir + \"/?.lua;\" + LuaLDir + \"/?/init.lua\"\n\t} else { // windows\n\t\tLuaOS = \"windows\"\n\t\tLuaLDir = \"!\\\\lua\"\n\t\tLuaDirSep = \"\\\\\"\n\t\tLuaPathDefault = \".\\\\?.lua;\" + LuaLDir + \"\\\\?.lua;\" + LuaLDir + \"\\\\?\\\\init.lua\"\n\t}\n}\n"
        },
        {
          "name": "coroutinelib.go",
          "type": "blob",
          "size": 1.9404296875,
          "content": "package lua\n\nfunc OpenCoroutine(L *LState) int {\n\t// TODO: Tie module name to contents of linit.go?\n\tmod := L.RegisterModule(CoroutineLibName, coFuncs)\n\tL.Push(mod)\n\treturn 1\n}\n\nvar coFuncs = map[string]LGFunction{\n\t\"create\":  coCreate,\n\t\"yield\":   coYield,\n\t\"resume\":  coResume,\n\t\"running\": coRunning,\n\t\"status\":  coStatus,\n\t\"wrap\":    coWrap,\n}\n\nfunc coCreate(L *LState) int {\n\tfn := L.CheckFunction(1)\n\tnewthread, _ := L.NewThread()\n\tbase := 0\n\tnewthread.stack.Push(callFrame{\n\t\tFn:         fn,\n\t\tPc:         0,\n\t\tBase:       base,\n\t\tLocalBase:  base + 1,\n\t\tReturnBase: base,\n\t\tNArgs:      0,\n\t\tNRet:       MultRet,\n\t\tParent:     nil,\n\t\tTailCall:   0,\n\t})\n\tL.Push(newthread)\n\treturn 1\n}\n\nfunc coYield(L *LState) int {\n\treturn -1\n}\n\nfunc coResume(L *LState) int {\n\tth := L.CheckThread(1)\n\tif L.G.CurrentThread == th {\n\t\tmsg := \"can not resume a running thread\"\n\t\tif th.wrapped {\n\t\t\tL.RaiseError(msg)\n\t\t\treturn 0\n\t\t}\n\t\tL.Push(LFalse)\n\t\tL.Push(LString(msg))\n\t\treturn 2\n\t}\n\tif th.Dead {\n\t\tmsg := \"can not resume a dead thread\"\n\t\tif th.wrapped {\n\t\t\tL.RaiseError(msg)\n\t\t\treturn 0\n\t\t}\n\t\tL.Push(LFalse)\n\t\tL.Push(LString(msg))\n\t\treturn 2\n\t}\n\tth.Parent = L\n\tL.G.CurrentThread = th\n\tif !th.isStarted() {\n\t\tcf := th.stack.Last()\n\t\tth.currentFrame = cf\n\t\tth.SetTop(0)\n\t\tnargs := L.GetTop() - 1\n\t\tL.XMoveTo(th, nargs)\n\t\tcf.NArgs = nargs\n\t\tth.initCallFrame(cf)\n\t\tth.Panic = panicWithoutTraceback\n\t} else {\n\t\tnargs := L.GetTop() - 1\n\t\tL.XMoveTo(th, nargs)\n\t}\n\ttop := L.GetTop()\n\tthreadRun(th)\n\treturn L.GetTop() - top\n}\n\nfunc coRunning(L *LState) int {\n\tif L.G.MainThread == L {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\tL.Push(L.G.CurrentThread)\n\treturn 1\n}\n\nfunc coStatus(L *LState) int {\n\tL.Push(LString(L.Status(L.CheckThread(1))))\n\treturn 1\n}\n\nfunc wrapaux(L *LState) int {\n\tL.Insert(L.ToThread(UpvalueIndex(1)), 1)\n\treturn coResume(L)\n}\n\nfunc coWrap(L *LState) int {\n\tcoCreate(L)\n\tL.CheckThread(L.GetTop()).wrapped = true\n\tv := L.Get(L.GetTop())\n\tL.Pop(1)\n\tL.Push(L.NewClosure(wrapaux, v))\n\treturn 1\n}\n\n//\n"
        },
        {
          "name": "debuglib.go",
          "type": "blob",
          "size": 3.330078125,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc OpenDebug(L *LState) int {\n\tdbgmod := L.RegisterModule(DebugLibName, debugFuncs)\n\tL.Push(dbgmod)\n\treturn 1\n}\n\nvar debugFuncs = map[string]LGFunction{\n\t\"getfenv\":      debugGetFEnv,\n\t\"getinfo\":      debugGetInfo,\n\t\"getlocal\":     debugGetLocal,\n\t\"getmetatable\": debugGetMetatable,\n\t\"getupvalue\":   debugGetUpvalue,\n\t\"setfenv\":      debugSetFEnv,\n\t\"setlocal\":     debugSetLocal,\n\t\"setmetatable\": debugSetMetatable,\n\t\"setupvalue\":   debugSetUpvalue,\n\t\"traceback\":    debugTraceback,\n}\n\nfunc debugGetFEnv(L *LState) int {\n\tL.Push(L.GetFEnv(L.CheckAny(1)))\n\treturn 1\n}\n\nfunc debugGetInfo(L *LState) int {\n\tL.CheckTypes(1, LTFunction, LTNumber)\n\targ1 := L.Get(1)\n\twhat := L.OptString(2, \"Slunf\")\n\tvar dbg *Debug\n\tvar fn LValue\n\tvar err error\n\tvar ok bool\n\tswitch lv := arg1.(type) {\n\tcase *LFunction:\n\t\tdbg = &Debug{}\n\t\tfn, err = L.GetInfo(\">\"+what, dbg, lv)\n\tcase LNumber:\n\t\tdbg, ok = L.GetStack(int(lv))\n\t\tif !ok {\n\t\t\tL.Push(LNil)\n\t\t\treturn 1\n\t\t}\n\t\tfn, err = L.GetInfo(what, dbg, LNil)\n\t}\n\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\ttbl := L.NewTable()\n\tif len(dbg.Name) > 0 {\n\t\ttbl.RawSetString(\"name\", LString(dbg.Name))\n\t} else {\n\t\ttbl.RawSetString(\"name\", LNil)\n\t}\n\ttbl.RawSetString(\"what\", LString(dbg.What))\n\ttbl.RawSetString(\"source\", LString(dbg.Source))\n\ttbl.RawSetString(\"currentline\", LNumber(dbg.CurrentLine))\n\ttbl.RawSetString(\"nups\", LNumber(dbg.NUpvalues))\n\ttbl.RawSetString(\"linedefined\", LNumber(dbg.LineDefined))\n\ttbl.RawSetString(\"lastlinedefined\", LNumber(dbg.LastLineDefined))\n\ttbl.RawSetString(\"func\", fn)\n\tL.Push(tbl)\n\treturn 1\n}\n\nfunc debugGetLocal(L *LState) int {\n\tlevel := L.CheckInt(1)\n\tidx := L.CheckInt(2)\n\tdbg, ok := L.GetStack(level)\n\tif !ok {\n\t\tL.ArgError(1, \"level out of range\")\n\t}\n\tname, value := L.GetLocal(dbg, idx)\n\tif len(name) > 0 {\n\t\tL.Push(LString(name))\n\t\tL.Push(value)\n\t\treturn 2\n\t}\n\tL.Push(LNil)\n\treturn 1\n}\n\nfunc debugGetMetatable(L *LState) int {\n\tL.Push(L.GetMetatable(L.CheckAny(1)))\n\treturn 1\n}\n\nfunc debugGetUpvalue(L *LState) int {\n\tfn := L.CheckFunction(1)\n\tidx := L.CheckInt(2)\n\tname, value := L.GetUpvalue(fn, idx)\n\tif len(name) > 0 {\n\t\tL.Push(LString(name))\n\t\tL.Push(value)\n\t\treturn 2\n\t}\n\tL.Push(LNil)\n\treturn 1\n}\n\nfunc debugSetFEnv(L *LState) int {\n\tL.SetFEnv(L.CheckAny(1), L.CheckAny(2))\n\treturn 0\n}\n\nfunc debugSetLocal(L *LState) int {\n\tlevel := L.CheckInt(1)\n\tidx := L.CheckInt(2)\n\tvalue := L.CheckAny(3)\n\tdbg, ok := L.GetStack(level)\n\tif !ok {\n\t\tL.ArgError(1, \"level out of range\")\n\t}\n\tname := L.SetLocal(dbg, idx, value)\n\tif len(name) > 0 {\n\t\tL.Push(LString(name))\n\t} else {\n\t\tL.Push(LNil)\n\t}\n\treturn 1\n}\n\nfunc debugSetMetatable(L *LState) int {\n\tL.CheckTypes(2, LTNil, LTTable)\n\tobj := L.Get(1)\n\tmt := L.Get(2)\n\tL.SetMetatable(obj, mt)\n\tL.SetTop(1)\n\treturn 1\n}\n\nfunc debugSetUpvalue(L *LState) int {\n\tfn := L.CheckFunction(1)\n\tidx := L.CheckInt(2)\n\tvalue := L.CheckAny(3)\n\tname := L.SetUpvalue(fn, idx, value)\n\tif len(name) > 0 {\n\t\tL.Push(LString(name))\n\t} else {\n\t\tL.Push(LNil)\n\t}\n\treturn 1\n}\n\nfunc debugTraceback(L *LState) int {\n\tmsg := \"\"\n\tlevel := L.OptInt(2, 1)\n\tls := L\n\tif L.GetTop() > 0 {\n\t\tif s, ok := L.Get(1).(LString); ok {\n\t\t\tmsg = string(s)\n\t\t}\n\t\tif l, ok := L.Get(1).(*LState); ok {\n\t\t\tls = l\n\t\t\tmsg = \"\"\n\t\t}\n\t}\n\n\ttraceback := strings.TrimSpace(ls.stackTrace(level))\n\tif len(msg) > 0 {\n\t\ttraceback = fmt.Sprintf(\"%s\\n%s\", msg, traceback)\n\t}\n\tL.Push(LString(traceback))\n\treturn 1\n}\n"
        },
        {
          "name": "function.go",
          "type": "blob",
          "size": 4.0107421875,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\tVarArgHasArg   uint8 = 1\n\tVarArgIsVarArg uint8 = 2\n\tVarArgNeedsArg uint8 = 4\n)\n\ntype DbgLocalInfo struct {\n\tName    string\n\tStartPc int\n\tEndPc   int\n}\n\ntype DbgCall struct {\n\tName string\n\tPc   int\n}\n\ntype FunctionProto struct {\n\tSourceName         string\n\tLineDefined        int\n\tLastLineDefined    int\n\tNumUpvalues        uint8\n\tNumParameters      uint8\n\tIsVarArg           uint8\n\tNumUsedRegisters   uint8\n\tCode               []uint32\n\tConstants          []LValue\n\tFunctionPrototypes []*FunctionProto\n\n\tDbgSourcePositions []int\n\tDbgLocals          []*DbgLocalInfo\n\tDbgCalls           []DbgCall\n\tDbgUpvalues        []string\n\n\tstringConstants []string\n}\n\n/* Upvalue {{{ */\n\ntype Upvalue struct {\n\tnext   *Upvalue\n\treg    *registry\n\tindex  int\n\tvalue  LValue\n\tclosed bool\n}\n\nfunc (uv *Upvalue) Value() LValue {\n\t//if uv.IsClosed() {\n\tif uv.closed || uv.reg == nil {\n\t\treturn uv.value\n\t}\n\t//return uv.reg.Get(uv.index)\n\treturn uv.reg.array[uv.index]\n}\n\nfunc (uv *Upvalue) SetValue(value LValue) {\n\tif uv.IsClosed() {\n\t\tuv.value = value\n\t} else {\n\t\tuv.reg.Set(uv.index, value)\n\t}\n}\n\nfunc (uv *Upvalue) Close() {\n\tvalue := uv.Value()\n\tuv.closed = true\n\tuv.value = value\n}\n\nfunc (uv *Upvalue) IsClosed() bool {\n\treturn uv.closed || uv.reg == nil\n}\n\nfunc UpvalueIndex(i int) int {\n\treturn GlobalsIndex - i\n}\n\n/* }}} */\n\n/* FunctionProto {{{ */\n\nfunc newFunctionProto(name string) *FunctionProto {\n\treturn &FunctionProto{\n\t\tSourceName:         name,\n\t\tLineDefined:        0,\n\t\tLastLineDefined:    0,\n\t\tNumUpvalues:        0,\n\t\tNumParameters:      0,\n\t\tIsVarArg:           0,\n\t\tNumUsedRegisters:   2,\n\t\tCode:               make([]uint32, 0, 128),\n\t\tConstants:          make([]LValue, 0, 32),\n\t\tFunctionPrototypes: make([]*FunctionProto, 0, 16),\n\n\t\tDbgSourcePositions: make([]int, 0, 128),\n\t\tDbgLocals:          make([]*DbgLocalInfo, 0, 16),\n\t\tDbgCalls:           make([]DbgCall, 0, 128),\n\t\tDbgUpvalues:        make([]string, 0, 16),\n\n\t\tstringConstants: make([]string, 0, 32),\n\t}\n}\n\nfunc (fp *FunctionProto) String() string {\n\treturn fp.str(1, 0)\n}\n\nfunc (fp *FunctionProto) str(level int, count int) string {\n\tindent := strings.Repeat(\"  \", level-1)\n\tbuf := []string{}\n\tbuf = append(buf, fmt.Sprintf(\"%v; function [%v] definition (level %v)\\n\",\n\t\tindent, count, level))\n\tbuf = append(buf, fmt.Sprintf(\"%v; %v upvalues, %v params, %v stacks\\n\",\n\t\tindent, fp.NumUpvalues, fp.NumParameters, fp.NumUsedRegisters))\n\tfor reg, linfo := range fp.DbgLocals {\n\t\tbuf = append(buf, fmt.Sprintf(\"%v.local %v ; %v\\n\", indent, linfo.Name, reg))\n\t}\n\tfor reg, upvalue := range fp.DbgUpvalues {\n\t\tbuf = append(buf, fmt.Sprintf(\"%v.upvalue %v ; %v\\n\", indent, upvalue, reg))\n\t}\n\tfor reg, conzt := range fp.Constants {\n\t\tbuf = append(buf, fmt.Sprintf(\"%v.const %v ; %v\\n\", indent, conzt.String(), reg))\n\t}\n\tbuf = append(buf, \"\\n\")\n\n\tprotono := 0\n\tfor no, code := range fp.Code {\n\t\tinst := opGetOpCode(code)\n\t\tif inst == OP_CLOSURE {\n\t\t\tbuf = append(buf, \"\\n\")\n\t\t\tbuf = append(buf, fp.FunctionPrototypes[protono].str(level+1, protono))\n\t\t\tbuf = append(buf, \"\\n\")\n\t\t\tprotono++\n\t\t}\n\t\tbuf = append(buf, fmt.Sprintf(\"%v[%03d] %v (line:%v)\\n\",\n\t\t\tindent, no+1, opToString(code), fp.DbgSourcePositions[no]))\n\n\t}\n\tbuf = append(buf, fmt.Sprintf(\"%v; end of function\\n\", indent))\n\treturn strings.Join(buf, \"\")\n}\n\n/* }}} */\n\n/* LFunction {{{ */\n\nfunc newLFunctionL(proto *FunctionProto, env *LTable, nupvalue int) *LFunction {\n\treturn &LFunction{\n\t\tIsG: false,\n\t\tEnv: env,\n\n\t\tProto:     proto,\n\t\tGFunction: nil,\n\t\tUpvalues:  make([]*Upvalue, nupvalue),\n\t}\n}\n\nfunc newLFunctionG(gfunc LGFunction, env *LTable, nupvalue int) *LFunction {\n\treturn &LFunction{\n\t\tIsG: true,\n\t\tEnv: env,\n\n\t\tProto:     nil,\n\t\tGFunction: gfunc,\n\t\tUpvalues:  make([]*Upvalue, nupvalue),\n\t}\n}\n\nfunc (fn *LFunction) LocalName(regno, pc int) (string, bool) {\n\tif fn.IsG {\n\t\treturn \"\", false\n\t}\n\tp := fn.Proto\n\tfor i := 0; i < len(p.DbgLocals) && p.DbgLocals[i].StartPc < pc; i++ {\n\t\tif pc < p.DbgLocals[i].EndPc {\n\t\t\tregno--\n\t\t\tif regno == 0 {\n\t\t\t\treturn p.DbgLocals[i].Name, true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n/* }}} */\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.30078125,
          "content": "module github.com/yuin/gopher-lua\n\ngo 1.17\n\nrequire github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e\n\nrequire (\n\tgithub.com/chzyer/logex v1.1.10 // indirect\n\tgithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1 // indirect\n\tgolang.org/x/sys v0.0.0-20190204203706-41f3e6584952 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.80078125,
          "content": "github.com/chzyer/logex v1.1.10 h1:Swpa1K6QvQznwJRcfTfQJmTE72DqScAa40E+fbHEXEE=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e h1:fY5BOSpyZCqRo5OhCuC+XN+r/bBCmeuuJtjz+bCNIf8=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1 h1:q763qf9huN11kDQavWsoZXJNW3xEE4JJyHa5Q25/sd8=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952 h1:FDfvYgoVsA7TTZSbgiqjAbfPbK47CNHdWl3h/PJtii0=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n"
        },
        {
          "name": "iolib.go",
          "type": "blob",
          "size": 15.62109375,
          "content": "package lua\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nvar ioFuncs = map[string]LGFunction{\n\t\"close\":   ioClose,\n\t\"flush\":   ioFlush,\n\t\"lines\":   ioLines,\n\t\"input\":   ioInput,\n\t\"output\":  ioOutput,\n\t\"open\":    ioOpenFile,\n\t\"popen\":   ioPopen,\n\t\"read\":    ioRead,\n\t\"type\":    ioType,\n\t\"tmpfile\": ioTmpFile,\n\t\"write\":   ioWrite,\n}\n\nconst lFileClass = \"FILE*\"\n\ntype lFile struct {\n\tfp     *os.File\n\tpp     *exec.Cmd\n\twriter io.Writer\n\treader *bufio.Reader\n\tstdout io.ReadCloser\n\tclosed bool\n}\n\ntype lFileType int\n\nconst (\n\tlFileFile lFileType = iota\n\tlFileProcess\n)\n\nconst fileDefOutIndex = 1\nconst fileDefInIndex = 2\nconst fileDefaultWriteBuffer = 4096\nconst fileDefaultReadBuffer = 4096\n\nfunc checkFile(L *LState) *lFile {\n\tud := L.CheckUserData(1)\n\tif file, ok := ud.Value.(*lFile); ok {\n\t\treturn file\n\t}\n\tL.ArgError(1, \"file expected\")\n\treturn nil\n}\n\nfunc errorIfFileIsClosed(L *LState, file *lFile) {\n\tif file.closed {\n\t\tL.ArgError(1, \"file is closed\")\n\t}\n}\n\nfunc newFile(L *LState, file *os.File, path string, flag int, perm os.FileMode, writable, readable bool) (*LUserData, error) {\n\tud := L.NewUserData()\n\tvar err error\n\tif file == nil {\n\t\tfile, err = os.OpenFile(path, flag, perm)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tlfile := &lFile{fp: file, pp: nil, writer: nil, reader: nil, stdout: nil, closed: false}\n\tud.Value = lfile\n\tif writable {\n\t\tlfile.writer = file\n\t}\n\tif readable {\n\t\tlfile.reader = bufio.NewReaderSize(file, fileDefaultReadBuffer)\n\t}\n\tL.SetMetatable(ud, L.GetTypeMetatable(lFileClass))\n\treturn ud, nil\n}\n\nfunc newProcess(L *LState, cmd string, writable, readable bool) (*LUserData, error) {\n\tud := L.NewUserData()\n\tc, args := popenArgs(cmd)\n\tpp := exec.Command(c, args...)\n\tlfile := &lFile{fp: nil, pp: pp, writer: nil, reader: nil, stdout: nil, closed: false}\n\tud.Value = lfile\n\n\tvar err error\n\tif writable {\n\t\tlfile.writer, err = pp.StdinPipe()\n\t}\n\tif readable {\n\t\tlfile.stdout, err = pp.StdoutPipe()\n\t\tlfile.reader = bufio.NewReaderSize(lfile.stdout, fileDefaultReadBuffer)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = pp.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tL.SetMetatable(ud, L.GetTypeMetatable(lFileClass))\n\treturn ud, nil\n}\n\nfunc (file *lFile) Type() lFileType {\n\tif file.fp == nil {\n\t\treturn lFileProcess\n\t}\n\treturn lFileFile\n}\n\nfunc (file *lFile) Name() string {\n\tswitch file.Type() {\n\tcase lFileFile:\n\t\treturn fmt.Sprintf(\"file %s\", file.fp.Name())\n\tcase lFileProcess:\n\t\treturn fmt.Sprintf(\"process %s\", file.pp.Path)\n\t}\n\treturn \"\"\n}\n\nfunc (file *lFile) AbandonReadBuffer() error {\n\tif file.Type() == lFileFile && file.reader != nil {\n\t\t_, err := file.fp.Seek(-int64(file.reader.Buffered()), 1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfile.reader = bufio.NewReaderSize(file.fp, fileDefaultReadBuffer)\n\t}\n\treturn nil\n}\n\nfunc fileDefOut(L *LState) *LUserData {\n\treturn L.Get(UpvalueIndex(1)).(*LTable).RawGetInt(fileDefOutIndex).(*LUserData)\n}\n\nfunc fileDefIn(L *LState) *LUserData {\n\treturn L.Get(UpvalueIndex(1)).(*LTable).RawGetInt(fileDefInIndex).(*LUserData)\n}\n\nfunc fileIsWritable(L *LState, file *lFile) int {\n\tif file.writer == nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(fmt.Sprintf(\"%s is opened for only reading.\", file.Name())))\n\t\tL.Push(LNumber(1)) // C-Lua compatibility: Original Lua pushes errno to the stack\n\t\treturn 3\n\t}\n\treturn 0\n}\n\nfunc fileIsReadable(L *LState, file *lFile) int {\n\tif file.reader == nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(fmt.Sprintf(\"%s is opened for only writing.\", file.Name())))\n\t\tL.Push(LNumber(1)) // C-Lua compatibility: Original Lua pushes errno to the stack\n\t\treturn 3\n\t}\n\treturn 0\n}\n\nvar stdFiles = []struct {\n\tname     string\n\tfile     *os.File\n\twritable bool\n\treadable bool\n}{\n\t{\"stdout\", os.Stdout, true, false},\n\t{\"stdin\", os.Stdin, false, true},\n\t{\"stderr\", os.Stderr, true, false},\n}\n\nfunc OpenIo(L *LState) int {\n\tmod := L.RegisterModule(IoLibName, map[string]LGFunction{}).(*LTable)\n\tmt := L.NewTypeMetatable(lFileClass)\n\tmt.RawSetString(\"__index\", mt)\n\tL.SetFuncs(mt, fileMethods)\n\tmt.RawSetString(\"lines\", L.NewClosure(fileLines, L.NewFunction(fileLinesIter)))\n\n\tfor _, finfo := range stdFiles {\n\t\tfile, _ := newFile(L, finfo.file, \"\", 0, os.FileMode(0), finfo.writable, finfo.readable)\n\t\tmod.RawSetString(finfo.name, file)\n\t}\n\tuv := L.CreateTable(2, 0)\n\tuv.RawSetInt(fileDefOutIndex, mod.RawGetString(\"stdout\"))\n\tuv.RawSetInt(fileDefInIndex, mod.RawGetString(\"stdin\"))\n\tfor name, fn := range ioFuncs {\n\t\tmod.RawSetString(name, L.NewClosure(fn, uv))\n\t}\n\tmod.RawSetString(\"lines\", L.NewClosure(ioLines, uv, L.NewClosure(ioLinesIter, uv)))\n\t// Modifications are being made in-place rather than returned?\n\tL.Push(mod)\n\treturn 1\n}\n\nvar fileMethods = map[string]LGFunction{\n\t\"__tostring\": fileToString,\n\t\"write\":      fileWrite,\n\t\"close\":      fileClose,\n\t\"flush\":      fileFlush,\n\t\"lines\":      fileLines,\n\t\"read\":       fileRead,\n\t\"seek\":       fileSeek,\n\t\"setvbuf\":    fileSetVBuf,\n}\n\nfunc fileToString(L *LState) int {\n\tfile := checkFile(L)\n\tif file.Type() == lFileFile {\n\t\tif file.closed {\n\t\t\tL.Push(LString(\"file (closed)\"))\n\t\t} else {\n\t\t\tL.Push(LString(\"file\"))\n\t\t}\n\t} else {\n\t\tif file.closed {\n\t\t\tL.Push(LString(\"process (closed)\"))\n\t\t} else {\n\t\t\tL.Push(LString(\"process\"))\n\t\t}\n\t}\n\treturn 1\n}\n\nfunc fileWriteAux(L *LState, file *lFile, idx int) int {\n\tif n := fileIsWritable(L, file); n != 0 {\n\t\treturn n\n\t}\n\terrorIfFileIsClosed(L, file)\n\ttop := L.GetTop()\n\tout := file.writer\n\tvar err error\n\tfor i := idx; i <= top; i++ {\n\t\tL.CheckTypes(i, LTNumber, LTString)\n\t\ts := LVAsString(L.Get(i))\n\t\tif _, err = out.Write(unsafeFastStringToReadOnlyBytes(s)); err != nil {\n\t\t\tgoto errreturn\n\t\t}\n\t}\n\n\tfile.AbandonReadBuffer()\n\tL.Push(LTrue)\n\treturn 1\nerrreturn:\n\n\tfile.AbandonReadBuffer()\n\tL.Push(LNil)\n\tL.Push(LString(err.Error()))\n\tL.Push(LNumber(1)) // C-Lua compatibility: Original Lua pushes errno to the stack\n\treturn 3\n}\n\nfunc fileCloseAux(L *LState, file *lFile) int {\n\tfile.closed = true\n\tvar err error\n\tif file.writer != nil {\n\t\tif bwriter, ok := file.writer.(*bufio.Writer); ok {\n\t\t\tif err = bwriter.Flush(); err != nil {\n\t\t\t\tgoto errreturn\n\t\t\t}\n\t\t}\n\t}\n\tfile.AbandonReadBuffer()\n\n\tswitch file.Type() {\n\tcase lFileFile:\n\t\tif err = file.fp.Close(); err != nil {\n\t\t\tgoto errreturn\n\t\t}\n\t\tL.Push(LTrue)\n\t\treturn 1\n\tcase lFileProcess:\n\t\tif file.stdout != nil {\n\t\t\tfile.stdout.Close() // ignore errors\n\t\t}\n\t\terr = file.pp.Wait()\n\t\tvar exitStatus int // Initialised to zero value = 0\n\t\tif err != nil {\n\t\t\tif e2, ok := err.(*exec.ExitError); ok {\n\t\t\t\tif s, ok := e2.Sys().(syscall.WaitStatus); ok {\n\t\t\t\t\texitStatus = s.ExitStatus()\n\t\t\t\t} else {\n\t\t\t\t\terr = errors.New(\"Unimplemented for system where exec.ExitError.Sys() is not syscall.WaitStatus.\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\texitStatus = 0\n\t\t}\n\t\tL.Push(LNumber(exitStatus))\n\t\treturn 1\n\t}\n\nerrreturn:\n\tL.RaiseError(err.Error())\n\treturn 0\n}\n\nfunc fileFlushAux(L *LState, file *lFile) int {\n\tif n := fileIsWritable(L, file); n != 0 {\n\t\treturn n\n\t}\n\terrorIfFileIsClosed(L, file)\n\n\tif bwriter, ok := file.writer.(*bufio.Writer); ok {\n\t\tif err := bwriter.Flush(); err != nil {\n\t\t\tL.Push(LNil)\n\t\t\tL.Push(LString(err.Error()))\n\t\t\treturn 2\n\t\t}\n\t}\n\tL.Push(LTrue)\n\treturn 1\n}\n\nfunc fileReadAux(L *LState, file *lFile, idx int) int {\n\tif n := fileIsReadable(L, file); n != 0 {\n\t\treturn n\n\t}\n\terrorIfFileIsClosed(L, file)\n\tif L.GetTop() == idx-1 {\n\t\tL.Push(LString(\"*l\"))\n\t}\n\tvar err error\n\ttop := L.GetTop()\n\tfor i := idx; i <= top; i++ {\n\t\tswitch lv := L.Get(i).(type) {\n\t\tcase LNumber:\n\t\t\tsize := int64(lv)\n\t\t\tif size == 0 {\n\t\t\t\t_, err = file.reader.ReadByte()\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tL.Push(LNil)\n\t\t\t\t\tgoto normalreturn\n\t\t\t\t}\n\t\t\t\tfile.reader.UnreadByte()\n\t\t\t}\n\t\t\tvar buf []byte\n\t\t\tvar iseof bool\n\t\t\tbuf, err, iseof = readBufioSize(file.reader, size)\n\t\t\tif iseof {\n\t\t\t\tL.Push(LNil)\n\t\t\t\tgoto normalreturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tgoto errreturn\n\t\t\t}\n\t\t\tL.Push(LString(string(buf)))\n\t\tcase LString:\n\t\t\toptions := L.CheckString(i)\n\t\t\tif len(options) > 0 && options[0] != '*' {\n\t\t\t\tL.ArgError(2, \"invalid options:\"+options)\n\t\t\t}\n\t\t\tfor _, opt := range options[1:] {\n\t\t\t\tswitch opt {\n\t\t\t\tcase 'n':\n\t\t\t\t\tvar v LNumber\n\t\t\t\t\t_, err = fmt.Fscanf(file.reader, LNumberScanFormat, &v)\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tL.Push(LNil)\n\t\t\t\t\t\tgoto normalreturn\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tgoto errreturn\n\t\t\t\t\t}\n\t\t\t\t\tL.Push(v)\n\t\t\t\tcase 'a':\n\t\t\t\t\tvar buf []byte\n\t\t\t\t\tbuf, err = io.ReadAll(file.reader)\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tL.Push(emptyLString)\n\t\t\t\t\t\tgoto normalreturn\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tgoto errreturn\n\t\t\t\t\t}\n\t\t\t\t\tL.Push(LString(string(buf)))\n\t\t\t\tcase 'l':\n\t\t\t\t\tvar buf []byte\n\t\t\t\t\tvar iseof bool\n\t\t\t\t\tbuf, err, iseof = readBufioLine(file.reader)\n\t\t\t\t\tif iseof {\n\t\t\t\t\t\tL.Push(LNil)\n\t\t\t\t\t\tgoto normalreturn\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tgoto errreturn\n\t\t\t\t\t}\n\t\t\t\t\tL.Push(LString(string(buf)))\n\t\t\t\tdefault:\n\t\t\t\t\tL.ArgError(2, \"invalid options:\"+string(opt))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nnormalreturn:\n\treturn L.GetTop() - top\n\nerrreturn:\n\tL.Push(LNil)\n\tL.Push(LString(err.Error()))\n\tL.Push(LNumber(1)) // C-Lua compatibility: Original Lua pushes errno to the stack\n\treturn 3\n}\n\nvar fileSeekOptions = []string{\"set\", \"cur\", \"end\"}\n\nfunc fileSeek(L *LState) int {\n\tfile := checkFile(L)\n\tif file.Type() != lFileFile {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(\"can not seek a process.\"))\n\t\treturn 2\n\t}\n\n\ttop := L.GetTop()\n\tif top == 1 {\n\t\tL.Push(LString(\"cur\"))\n\t\tL.Push(LNumber(0))\n\t} else if top == 2 {\n\t\tL.Push(LNumber(0))\n\t}\n\n\tvar pos int64\n\tvar err error\n\n\terr = file.AbandonReadBuffer()\n\tif err != nil {\n\t\tgoto errreturn\n\t}\n\n\tpos, err = file.fp.Seek(L.CheckInt64(3), L.CheckOption(2, fileSeekOptions))\n\tif err != nil {\n\t\tgoto errreturn\n\t}\n\n\tL.Push(LNumber(pos))\n\treturn 1\n\nerrreturn:\n\tL.Push(LNil)\n\tL.Push(LString(err.Error()))\n\treturn 2\n}\n\nfunc fileWrite(L *LState) int {\n\treturn fileWriteAux(L, checkFile(L), 2)\n}\n\nfunc fileClose(L *LState) int {\n\treturn fileCloseAux(L, checkFile(L))\n}\n\nfunc fileFlush(L *LState) int {\n\treturn fileFlushAux(L, checkFile(L))\n}\n\nfunc fileLinesIter(L *LState) int {\n\tvar file *lFile\n\tif ud, ok := L.Get(1).(*LUserData); ok {\n\t\tfile = ud.Value.(*lFile)\n\t} else {\n\t\tfile = L.Get(UpvalueIndex(2)).(*LUserData).Value.(*lFile)\n\t}\n\tbuf, _, err := file.reader.ReadLine()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tL.Push(LNil)\n\t\t\treturn 1\n\t\t}\n\t\tL.RaiseError(err.Error())\n\t}\n\tL.Push(LString(string(buf)))\n\treturn 1\n}\n\nfunc fileLines(L *LState) int {\n\tfile := checkFile(L)\n\tud := L.CheckUserData(1)\n\tif n := fileIsReadable(L, file); n != 0 {\n\t\treturn 0\n\t}\n\tL.Push(L.NewClosure(fileLinesIter, L.Get(UpvalueIndex(1)), ud))\n\treturn 1\n}\n\nfunc fileRead(L *LState) int {\n\treturn fileReadAux(L, checkFile(L), 2)\n}\n\nvar filebufOptions = []string{\"no\", \"full\"}\n\nfunc fileSetVBuf(L *LState) int {\n\tvar err error\n\tvar writer io.Writer\n\tfile := checkFile(L)\n\tif n := fileIsWritable(L, file); n != 0 {\n\t\treturn n\n\t}\n\tswitch filebufOptions[L.CheckOption(2, filebufOptions)] {\n\tcase \"no\":\n\t\tswitch file.Type() {\n\t\tcase lFileFile:\n\t\t\tfile.writer = file.fp\n\t\tcase lFileProcess:\n\t\t\tfile.writer, err = file.pp.StdinPipe()\n\t\t\tif err != nil {\n\t\t\t\tgoto errreturn\n\t\t\t}\n\t\t}\n\tcase \"full\", \"line\": // TODO line buffer not supported\n\t\tbufsize := L.OptInt(3, fileDefaultWriteBuffer)\n\t\tswitch file.Type() {\n\t\tcase lFileFile:\n\t\t\tfile.writer = bufio.NewWriterSize(file.fp, bufsize)\n\t\tcase lFileProcess:\n\t\t\twriter, err = file.pp.StdinPipe()\n\t\t\tif err != nil {\n\t\t\t\tgoto errreturn\n\t\t\t}\n\t\t\tfile.writer = bufio.NewWriterSize(writer, bufsize)\n\t\t}\n\t}\n\tL.Push(LTrue)\n\treturn 1\nerrreturn:\n\tL.Push(LNil)\n\tL.Push(LString(err.Error()))\n\treturn 2\n}\n\nfunc ioInput(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.Push(fileDefIn(L))\n\t\treturn 1\n\t}\n\tswitch lv := L.Get(1).(type) {\n\tcase LString:\n\t\tfile, err := newFile(L, nil, string(lv), os.O_RDONLY, 0600, false, true)\n\t\tif err != nil {\n\t\t\tL.RaiseError(err.Error())\n\t\t}\n\t\tL.Get(UpvalueIndex(1)).(*LTable).RawSetInt(fileDefInIndex, file)\n\t\tL.Push(file)\n\t\treturn 1\n\tcase *LUserData:\n\t\tif _, ok := lv.Value.(*lFile); ok {\n\t\t\tL.Get(UpvalueIndex(1)).(*LTable).RawSetInt(fileDefInIndex, lv)\n\t\t\tL.Push(lv)\n\t\t\treturn 1\n\t\t}\n\n\t}\n\tL.ArgError(1, \"string or file expedted, but got \"+L.Get(1).Type().String())\n\treturn 0\n}\n\nfunc ioClose(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\treturn fileCloseAux(L, fileDefOut(L).Value.(*lFile))\n\t}\n\treturn fileClose(L)\n}\n\nfunc ioFlush(L *LState) int {\n\treturn fileFlushAux(L, fileDefOut(L).Value.(*lFile))\n}\n\nfunc ioLinesIter(L *LState) int {\n\tvar file *lFile\n\ttoclose := false\n\tif ud, ok := L.Get(1).(*LUserData); ok {\n\t\tfile = ud.Value.(*lFile)\n\t} else {\n\t\tfile = L.Get(UpvalueIndex(2)).(*LUserData).Value.(*lFile)\n\t\ttoclose = true\n\t}\n\tbuf, _, err := file.reader.ReadLine()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tif toclose {\n\t\t\t\tfileCloseAux(L, file)\n\t\t\t}\n\t\t\tL.Push(LNil)\n\t\t\treturn 1\n\t\t}\n\t\tL.RaiseError(err.Error())\n\t}\n\tL.Push(LString(string(buf)))\n\treturn 1\n}\n\nfunc ioLines(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.Push(L.Get(UpvalueIndex(2)))\n\t\tL.Push(fileDefIn(L))\n\t\treturn 2\n\t}\n\n\tpath := L.CheckString(1)\n\tud, err := newFile(L, nil, path, os.O_RDONLY, os.FileMode(0600), false, true)\n\tif err != nil {\n\t\treturn 0\n\t}\n\tL.Push(L.NewClosure(ioLinesIter, L.Get(UpvalueIndex(1)), ud))\n\treturn 1\n}\n\nvar ioOpenOpions = []string{\"r\", \"rb\", \"w\", \"wb\", \"a\", \"ab\", \"r+\", \"rb+\", \"w+\", \"wb+\", \"a+\", \"ab+\"}\n\nfunc ioOpenFile(L *LState) int {\n\tpath := L.CheckString(1)\n\tif L.GetTop() == 1 {\n\t\tL.Push(LString(\"r\"))\n\t}\n\tmode := os.O_RDONLY\n\tperm := 0600\n\twritable := true\n\treadable := true\n\tswitch ioOpenOpions[L.CheckOption(2, ioOpenOpions)] {\n\tcase \"r\", \"rb\":\n\t\tmode = os.O_RDONLY\n\t\twritable = false\n\tcase \"w\", \"wb\":\n\t\tmode = os.O_WRONLY | os.O_TRUNC | os.O_CREATE\n\t\treadable = false\n\tcase \"a\", \"ab\":\n\t\tmode = os.O_WRONLY | os.O_APPEND | os.O_CREATE\n\tcase \"r+\", \"rb+\":\n\t\tmode = os.O_RDWR\n\tcase \"w+\", \"wb+\":\n\t\tmode = os.O_RDWR | os.O_TRUNC | os.O_CREATE\n\tcase \"a+\", \"ab+\":\n\t\tmode = os.O_APPEND | os.O_RDWR | os.O_CREATE\n\t}\n\tfile, err := newFile(L, nil, path, mode, os.FileMode(perm), writable, readable)\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\tL.Push(LNumber(1)) // C-Lua compatibility: Original Lua pushes errno to the stack\n\t\treturn 3\n\t}\n\tL.Push(file)\n\treturn 1\n\n}\n\nvar ioPopenOptions = []string{\"r\", \"w\"}\n\nfunc ioPopen(L *LState) int {\n\tcmd := L.CheckString(1)\n\tif L.GetTop() == 1 {\n\t\tL.Push(LString(\"r\"))\n\t} else if L.GetTop() > 1 && (L.Get(2)).Type() == LTNil {\n\t\tL.SetTop(1)\n\t\tL.Push(LString(\"r\"))\n\t}\n\tvar file *LUserData\n\tvar err error\n\n\tswitch ioPopenOptions[L.CheckOption(2, ioPopenOptions)] {\n\tcase \"r\":\n\t\tfile, err = newProcess(L, cmd, false, true)\n\tcase \"w\":\n\t\tfile, err = newProcess(L, cmd, true, false)\n\t}\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t}\n\tL.Push(file)\n\treturn 1\n}\n\nfunc ioRead(L *LState) int {\n\treturn fileReadAux(L, fileDefIn(L).Value.(*lFile), 1)\n}\n\nfunc ioType(L *LState) int {\n\tud, udok := L.Get(1).(*LUserData)\n\tif !udok {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\tfile, ok := ud.Value.(*lFile)\n\tif !ok {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\tif file.closed {\n\t\tL.Push(LString(\"closed file\"))\n\t\treturn 1\n\t}\n\tL.Push(LString(\"file\"))\n\treturn 1\n}\n\nfunc ioTmpFile(L *LState) int {\n\tfile, err := os.CreateTemp(\"\", \"\")\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t}\n\tL.G.tempFiles = append(L.G.tempFiles, file)\n\tud, _ := newFile(L, file, \"\", 0, os.FileMode(0), true, true)\n\tL.Push(ud)\n\treturn 1\n}\n\nfunc ioOutput(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.Push(fileDefOut(L))\n\t\treturn 1\n\t}\n\tswitch lv := L.Get(1).(type) {\n\tcase LString:\n\t\tfile, err := newFile(L, nil, string(lv), os.O_WRONLY|os.O_CREATE, 0600, true, false)\n\t\tif err != nil {\n\t\t\tL.RaiseError(err.Error())\n\t\t}\n\t\tL.Get(UpvalueIndex(1)).(*LTable).RawSetInt(fileDefOutIndex, file)\n\t\tL.Push(file)\n\t\treturn 1\n\tcase *LUserData:\n\t\tif _, ok := lv.Value.(*lFile); ok {\n\t\t\tL.Get(UpvalueIndex(1)).(*LTable).RawSetInt(fileDefOutIndex, lv)\n\t\t\tL.Push(lv)\n\t\t\treturn 1\n\t\t}\n\n\t}\n\tL.ArgError(1, \"string or file expedted, but got \"+L.Get(1).Type().String())\n\treturn 0\n}\n\nfunc ioWrite(L *LState) int {\n\treturn fileWriteAux(L, fileDefOut(L).Value.(*lFile), 1)\n}\n\n//\n"
        },
        {
          "name": "linit.go",
          "type": "blob",
          "size": 1.6435546875,
          "content": "package lua\n\nconst (\n\t// BaseLibName is here for consistency; the base functions have no namespace/library.\n\tBaseLibName = \"\"\n\t// LoadLibName is here for consistency; the loading system has no namespace/library.\n\tLoadLibName = \"package\"\n\t// TabLibName is the name of the table Library.\n\tTabLibName = \"table\"\n\t// IoLibName is the name of the io Library.\n\tIoLibName = \"io\"\n\t// OsLibName is the name of the os Library.\n\tOsLibName = \"os\"\n\t// StringLibName is the name of the string Library.\n\tStringLibName = \"string\"\n\t// MathLibName is the name of the math Library.\n\tMathLibName = \"math\"\n\t// DebugLibName is the name of the debug Library.\n\tDebugLibName = \"debug\"\n\t// ChannelLibName is the name of the channel Library.\n\tChannelLibName = \"channel\"\n\t// CoroutineLibName is the name of the coroutine Library.\n\tCoroutineLibName = \"coroutine\"\n)\n\ntype luaLib struct {\n\tlibName string\n\tlibFunc LGFunction\n}\n\nvar luaLibs = []luaLib{\n\tluaLib{LoadLibName, OpenPackage},\n\tluaLib{BaseLibName, OpenBase},\n\tluaLib{TabLibName, OpenTable},\n\tluaLib{IoLibName, OpenIo},\n\tluaLib{OsLibName, OpenOs},\n\tluaLib{StringLibName, OpenString},\n\tluaLib{MathLibName, OpenMath},\n\tluaLib{DebugLibName, OpenDebug},\n\tluaLib{ChannelLibName, OpenChannel},\n\tluaLib{CoroutineLibName, OpenCoroutine},\n}\n\n// OpenLibs loads the built-in libraries. It is equivalent to running OpenLoad,\n// then OpenBase, then iterating over the other OpenXXX functions in any order.\nfunc (ls *LState) OpenLibs() {\n\t// NB: Map iteration order in Go is deliberately randomised, so must open Load/Base\n\t// prior to iterating.\n\tfor _, lib := range luaLibs {\n\t\tls.Push(ls.NewFunction(lib.libFunc))\n\t\tls.Push(LString(lib.libName))\n\t\tls.Call(1, 0)\n\t}\n}\n"
        },
        {
          "name": "loadlib.go",
          "type": "blob",
          "size": 2.8779296875,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n/* load lib {{{ */\n\nvar loLoaders = []LGFunction{loLoaderPreload, loLoaderLua}\n\nfunc loGetPath(env string, defpath string) string {\n\tpath := os.Getenv(env)\n\tif len(path) == 0 {\n\t\tpath = defpath\n\t}\n\tpath = strings.Replace(path, \";;\", \";\"+defpath+\";\", -1)\n\tif os.PathSeparator != '/' {\n\t\tdir, err := filepath.Abs(filepath.Dir(os.Args[0]))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tpath = strings.Replace(path, \"!\", dir, -1)\n\t}\n\treturn path\n}\n\nfunc loFindFile(L *LState, name, pname string) (string, string) {\n\tname = strings.Replace(name, \".\", string(os.PathSeparator), -1)\n\tlv := L.GetField(L.GetField(L.Get(EnvironIndex), \"package\"), pname)\n\tpath, ok := lv.(LString)\n\tif !ok {\n\t\tL.RaiseError(\"package.%s must be a string\", pname)\n\t}\n\tmessages := []string{}\n\tfor _, pattern := range strings.Split(string(path), \";\") {\n\t\tluapath := strings.Replace(pattern, \"?\", name, -1)\n\t\tif _, err := os.Stat(luapath); err == nil {\n\t\t\treturn luapath, \"\"\n\t\t} else {\n\t\t\tmessages = append(messages, err.Error())\n\t\t}\n\t}\n\treturn \"\", strings.Join(messages, \"\\n\\t\")\n}\n\nfunc OpenPackage(L *LState) int {\n\tpackagemod := L.RegisterModule(LoadLibName, loFuncs)\n\n\tL.SetField(packagemod, \"preload\", L.NewTable())\n\n\tloaders := L.CreateTable(len(loLoaders), 0)\n\tfor i, loader := range loLoaders {\n\t\tL.RawSetInt(loaders, i+1, L.NewFunction(loader))\n\t}\n\tL.SetField(packagemod, \"loaders\", loaders)\n\tL.SetField(L.Get(RegistryIndex), \"_LOADERS\", loaders)\n\n\tloaded := L.NewTable()\n\tL.SetField(packagemod, \"loaded\", loaded)\n\tL.SetField(L.Get(RegistryIndex), \"_LOADED\", loaded)\n\n\tL.SetField(packagemod, \"path\", LString(loGetPath(LuaPath, LuaPathDefault)))\n\tL.SetField(packagemod, \"cpath\", emptyLString)\n\n\tL.SetField(packagemod, \"config\", LString(LuaDirSep+\"\\n\"+LuaPathSep+\n\t\t\"\\n\"+LuaPathMark+\"\\n\"+LuaExecDir+\"\\n\"+LuaIgMark+\"\\n\"))\n\n\tL.Push(packagemod)\n\treturn 1\n}\n\nvar loFuncs = map[string]LGFunction{\n\t\"loadlib\": loLoadLib,\n\t\"seeall\":  loSeeAll,\n}\n\nfunc loLoaderPreload(L *LState) int {\n\tname := L.CheckString(1)\n\tpreload := L.GetField(L.GetField(L.Get(EnvironIndex), \"package\"), \"preload\")\n\tif _, ok := preload.(*LTable); !ok {\n\t\tL.RaiseError(\"package.preload must be a table\")\n\t}\n\tlv := L.GetField(preload, name)\n\tif lv == LNil {\n\t\tL.Push(LString(fmt.Sprintf(\"no field package.preload['%s']\", name)))\n\t\treturn 1\n\t}\n\tL.Push(lv)\n\treturn 1\n}\n\nfunc loLoaderLua(L *LState) int {\n\tname := L.CheckString(1)\n\tpath, msg := loFindFile(L, name, \"path\")\n\tif len(path) == 0 {\n\t\tL.Push(LString(msg))\n\t\treturn 1\n\t}\n\tfn, err1 := L.LoadFile(path)\n\tif err1 != nil {\n\t\tL.RaiseError(err1.Error())\n\t}\n\tL.Push(fn)\n\treturn 1\n}\n\nfunc loLoadLib(L *LState) int {\n\tL.RaiseError(\"loadlib is not supported\")\n\treturn 0\n}\n\nfunc loSeeAll(L *LState) int {\n\tmod := L.CheckTable(1)\n\tmt := L.GetMetatable(mod)\n\tif mt == LNil {\n\t\tmt = L.CreateTable(0, 1)\n\t\tL.SetMetatable(mod, mt)\n\t}\n\tL.SetField(mt, \"__index\", L.Get(GlobalsIndex))\n\treturn 0\n}\n\n/* }}} */\n\n//\n"
        },
        {
          "name": "mathlib.go",
          "type": "blob",
          "size": 4.4580078125,
          "content": "package lua\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n)\n\nfunc OpenMath(L *LState) int {\n\tmod := L.RegisterModule(MathLibName, mathFuncs).(*LTable)\n\tmod.RawSetString(\"pi\", LNumber(math.Pi))\n\tmod.RawSetString(\"huge\", LNumber(math.MaxFloat64))\n\tL.Push(mod)\n\treturn 1\n}\n\nvar mathFuncs = map[string]LGFunction{\n\t\"abs\":        mathAbs,\n\t\"acos\":       mathAcos,\n\t\"asin\":       mathAsin,\n\t\"atan\":       mathAtan,\n\t\"atan2\":      mathAtan2,\n\t\"ceil\":       mathCeil,\n\t\"cos\":        mathCos,\n\t\"cosh\":       mathCosh,\n\t\"deg\":        mathDeg,\n\t\"exp\":        mathExp,\n\t\"floor\":      mathFloor,\n\t\"fmod\":       mathFmod,\n\t\"frexp\":      mathFrexp,\n\t\"ldexp\":      mathLdexp,\n\t\"log\":        mathLog,\n\t\"log10\":      mathLog10,\n\t\"max\":        mathMax,\n\t\"min\":        mathMin,\n\t\"mod\":        mathMod,\n\t\"modf\":       mathModf,\n\t\"pow\":        mathPow,\n\t\"rad\":        mathRad,\n\t\"random\":     mathRandom,\n\t\"randomseed\": mathRandomseed,\n\t\"sin\":        mathSin,\n\t\"sinh\":       mathSinh,\n\t\"sqrt\":       mathSqrt,\n\t\"tan\":        mathTan,\n\t\"tanh\":       mathTanh,\n}\n\nfunc mathAbs(L *LState) int {\n\tL.Push(LNumber(math.Abs(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathAcos(L *LState) int {\n\tL.Push(LNumber(math.Acos(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathAsin(L *LState) int {\n\tL.Push(LNumber(math.Asin(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathAtan(L *LState) int {\n\tL.Push(LNumber(math.Atan(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathAtan2(L *LState) int {\n\tL.Push(LNumber(math.Atan2(float64(L.CheckNumber(1)), float64(L.CheckNumber(2)))))\n\treturn 1\n}\n\nfunc mathCeil(L *LState) int {\n\tL.Push(LNumber(math.Ceil(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathCos(L *LState) int {\n\tL.Push(LNumber(math.Cos(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathCosh(L *LState) int {\n\tL.Push(LNumber(math.Cosh(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathDeg(L *LState) int {\n\tL.Push(LNumber(float64(L.CheckNumber(1)) * 180 / math.Pi))\n\treturn 1\n}\n\nfunc mathExp(L *LState) int {\n\tL.Push(LNumber(math.Exp(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathFloor(L *LState) int {\n\tL.Push(LNumber(math.Floor(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathFmod(L *LState) int {\n\tL.Push(LNumber(math.Mod(float64(L.CheckNumber(1)), float64(L.CheckNumber(2)))))\n\treturn 1\n}\n\nfunc mathFrexp(L *LState) int {\n\tv1, v2 := math.Frexp(float64(L.CheckNumber(1)))\n\tL.Push(LNumber(v1))\n\tL.Push(LNumber(v2))\n\treturn 2\n}\n\nfunc mathLdexp(L *LState) int {\n\tL.Push(LNumber(math.Ldexp(float64(L.CheckNumber(1)), L.CheckInt(2))))\n\treturn 1\n}\n\nfunc mathLog(L *LState) int {\n\tL.Push(LNumber(math.Log(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathLog10(L *LState) int {\n\tL.Push(LNumber(math.Log10(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathMax(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.RaiseError(\"wrong number of arguments\")\n\t}\n\tmax := L.CheckNumber(1)\n\ttop := L.GetTop()\n\tfor i := 2; i <= top; i++ {\n\t\tv := L.CheckNumber(i)\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\tL.Push(max)\n\treturn 1\n}\n\nfunc mathMin(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.RaiseError(\"wrong number of arguments\")\n\t}\n\tmin := L.CheckNumber(1)\n\ttop := L.GetTop()\n\tfor i := 2; i <= top; i++ {\n\t\tv := L.CheckNumber(i)\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\tL.Push(min)\n\treturn 1\n}\n\nfunc mathMod(L *LState) int {\n\tlhs := L.CheckNumber(1)\n\trhs := L.CheckNumber(2)\n\tL.Push(luaModulo(lhs, rhs))\n\treturn 1\n}\n\nfunc mathModf(L *LState) int {\n\tv1, v2 := math.Modf(float64(L.CheckNumber(1)))\n\tL.Push(LNumber(v1))\n\tL.Push(LNumber(v2))\n\treturn 2\n}\n\nfunc mathPow(L *LState) int {\n\tL.Push(LNumber(math.Pow(float64(L.CheckNumber(1)), float64(L.CheckNumber(2)))))\n\treturn 1\n}\n\nfunc mathRad(L *LState) int {\n\tL.Push(LNumber(float64(L.CheckNumber(1)) * math.Pi / 180))\n\treturn 1\n}\n\nfunc mathRandom(L *LState) int {\n\tswitch L.GetTop() {\n\tcase 0:\n\t\tL.Push(LNumber(rand.Float64()))\n\tcase 1:\n\t\tn := L.CheckInt(1)\n\t\tL.Push(LNumber(rand.Intn(n) + 1))\n\tdefault:\n\t\tmin := L.CheckInt(1)\n\t\tmax := L.CheckInt(2) + 1\n\t\tL.Push(LNumber(rand.Intn(max-min) + min))\n\t}\n\treturn 1\n}\n\nfunc mathRandomseed(L *LState) int {\n\trand.Seed(L.CheckInt64(1))\n\treturn 0\n}\n\nfunc mathSin(L *LState) int {\n\tL.Push(LNumber(math.Sin(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathSinh(L *LState) int {\n\tL.Push(LNumber(math.Sinh(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathSqrt(L *LState) int {\n\tL.Push(LNumber(math.Sqrt(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathTan(L *LState) int {\n\tL.Push(LNumber(math.Tan(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\nfunc mathTanh(L *LState) int {\n\tL.Push(LNumber(math.Tanh(float64(L.CheckNumber(1)))))\n\treturn 1\n}\n\n//\n"
        },
        {
          "name": "opcode.go",
          "type": "blob",
          "size": 13.2783203125,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n)\n\n/*\n  gopherlua uses Lua 5.1.4's opcodes.\n  Lua 5.1.4 opcodes layout:\n\n          instruction = 32bit(fixed length)\n\n  +---------------------------------------------+\n  |0-5(6bits)|6-13(8bit)|14-22(9bit)|23-31(9bit)|\n  |==========+==========+===========+===========|\n  |  opcode  |    A     |     C     |    B      |\n  |----------+----------+-----------+-----------|\n  |  opcode  |    A     |      Bx(unsigned)     |\n  |----------+----------+-----------+-----------|\n  |  opcode  |    A     |      sBx(signed)      |\n  +---------------------------------------------+\n*/\n\nconst opInvalidInstruction = ^uint32(0)\n\nconst opSizeCode = 6\nconst opSizeA = 8\nconst opSizeB = 9\nconst opSizeC = 9\nconst opSizeBx = 18\nconst opSizesBx = 18\n\nconst opMaxArgsA = (1 << opSizeA) - 1\nconst opMaxArgsB = (1 << opSizeB) - 1\nconst opMaxArgsC = (1 << opSizeC) - 1\nconst opMaxArgBx = (1 << opSizeBx) - 1\nconst opMaxArgSbx = opMaxArgBx >> 1\n\nconst (\n\tOP_MOVE     int = iota /*      A B     R(A) := R(B)                            */\n\tOP_MOVEN               /*      A B     R(A) := R(B); followed by R(C) MOVE ops */\n\tOP_LOADK               /*     A Bx    R(A) := Kst(Bx)                          */\n\tOP_LOADBOOL            /*  A B C   R(A) := (Bool)B; if (C) pc++                */\n\tOP_LOADNIL             /*   A B     R(A) := ... := R(B) := nil                 */\n\tOP_GETUPVAL            /*  A B     R(A) := UpValue[B]                          */\n\n\tOP_GETGLOBAL  /* A Bx    R(A) := Gbl[Kst(Bx)]                            */\n\tOP_GETTABLE   /*  A B C   R(A) := R(B)[RK(C)]                             */\n\tOP_GETTABLEKS /*  A B C   R(A) := R(B)[RK(C)] ; RK(C) is constant string */\n\n\tOP_SETGLOBAL  /* A Bx    Gbl[Kst(Bx)] := R(A)                            */\n\tOP_SETUPVAL   /*  A B     UpValue[B] := R(A)                              */\n\tOP_SETTABLE   /*  A B C   R(A)[RK(B)] := RK(C)                            */\n\tOP_SETTABLEKS /*  A B C   R(A)[RK(B)] := RK(C) ; RK(B) is constant string */\n\n\tOP_NEWTABLE /*  A B C   R(A) := {} (size = BC)                         */\n\n\tOP_SELF /*      A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]             */\n\n\tOP_ADD /*       A B C   R(A) := RK(B) + RK(C)                           */\n\tOP_SUB /*       A B C   R(A) := RK(B) - RK(C)                           */\n\tOP_MUL /*       A B C   R(A) := RK(B) * RK(C)                           */\n\tOP_DIV /*       A B C   R(A) := RK(B) / RK(C)                           */\n\tOP_MOD /*       A B C   R(A) := RK(B) % RK(C)                           */\n\tOP_POW /*       A B C   R(A) := RK(B) ^ RK(C)                           */\n\tOP_UNM /*       A B     R(A) := -R(B)                                   */\n\tOP_NOT /*       A B     R(A) := not R(B)                                */\n\tOP_LEN /*       A B     R(A) := length of R(B)                          */\n\n\tOP_CONCAT /*    A B C   R(A) := R(B).. ... ..R(C)                       */\n\n\tOP_JMP /*       sBx     pc+=sBx                                 */\n\n\tOP_EQ /*        A B C   if ((RK(B) == RK(C)) ~= A) then pc++            */\n\tOP_LT /*        A B C   if ((RK(B) <  RK(C)) ~= A) then pc++            */\n\tOP_LE /*        A B C   if ((RK(B) <= RK(C)) ~= A) then pc++            */\n\n\tOP_TEST    /*      A C     if not (R(A) <=> C) then pc++                   */\n\tOP_TESTSET /*   A B C   if (R(B) <=> C) then R(A) := R(B) else pc++     */\n\n\tOP_CALL     /*      A B C   R(A) ... R(A+C-2) := R(A)(R(A+1) ... R(A+B-1)) */\n\tOP_TAILCALL /*  A B C   return R(A)(R(A+1) ... R(A+B-1))              */\n\tOP_RETURN   /*    A B     return R(A) ... R(A+B-2)      (see note)      */\n\n\tOP_FORLOOP /*   A sBx   R(A)+=R(A+2);\n\t     if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/\n\tOP_FORPREP /*   A sBx   R(A)-=R(A+2); pc+=sBx                           */\n\n\tOP_TFORLOOP /*  A C     R(A+3) ... R(A+3+C) := R(A)(R(A+1) R(A+2));\n\t    if R(A+3) ~= nil then { pc++; R(A+2)=R(A+3); }  */\n\tOP_SETLIST /*   A B C   R(A)[(C-1)*FPF+i] := R(A+i) 1 <= i <= B        */\n\n\tOP_CLOSE   /*     A       close all variables in the stack up to (>=) R(A)*/\n\tOP_CLOSURE /*   A Bx    R(A) := closure(KPROTO[Bx] R(A) ... R(A+n))  */\n\n\tOP_VARARG /*     A B     R(A) R(A+1) ... R(A+B-1) = vararg            */\n\n\tOP_NOP /* NOP */\n)\nconst opCodeMax = OP_NOP\n\ntype opArgMode int\n\nconst (\n\topArgModeN opArgMode = iota\n\topArgModeU\n\topArgModeR\n\topArgModeK\n)\n\ntype opType int\n\nconst (\n\topTypeABC = iota\n\topTypeABx\n\topTypeASbx\n)\n\ntype opProp struct {\n\tName     string\n\tIsTest   bool\n\tSetRegA  bool\n\tModeArgB opArgMode\n\tModeArgC opArgMode\n\tType     opType\n}\n\nvar opProps = []opProp{\n\topProp{\"MOVE\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"MOVEN\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"LOADK\", false, true, opArgModeK, opArgModeN, opTypeABx},\n\topProp{\"LOADBOOL\", false, true, opArgModeU, opArgModeU, opTypeABC},\n\topProp{\"LOADNIL\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"GETUPVAL\", false, true, opArgModeU, opArgModeN, opTypeABC},\n\topProp{\"GETGLOBAL\", false, true, opArgModeK, opArgModeN, opTypeABx},\n\topProp{\"GETTABLE\", false, true, opArgModeR, opArgModeK, opTypeABC},\n\topProp{\"GETTABLEKS\", false, true, opArgModeR, opArgModeK, opTypeABC},\n\topProp{\"SETGLOBAL\", false, false, opArgModeK, opArgModeN, opTypeABx},\n\topProp{\"SETUPVAL\", false, false, opArgModeU, opArgModeN, opTypeABC},\n\topProp{\"SETTABLE\", false, false, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"SETTABLEKS\", false, false, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"NEWTABLE\", false, true, opArgModeU, opArgModeU, opTypeABC},\n\topProp{\"SELF\", false, true, opArgModeR, opArgModeK, opTypeABC},\n\topProp{\"ADD\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"SUB\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"MUL\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"DIV\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"MOD\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"POW\", false, true, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"UNM\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"NOT\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"LEN\", false, true, opArgModeR, opArgModeN, opTypeABC},\n\topProp{\"CONCAT\", false, true, opArgModeR, opArgModeR, opTypeABC},\n\topProp{\"JMP\", false, false, opArgModeR, opArgModeN, opTypeASbx},\n\topProp{\"EQ\", true, false, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"LT\", true, false, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"LE\", true, false, opArgModeK, opArgModeK, opTypeABC},\n\topProp{\"TEST\", true, true, opArgModeR, opArgModeU, opTypeABC},\n\topProp{\"TESTSET\", true, true, opArgModeR, opArgModeU, opTypeABC},\n\topProp{\"CALL\", false, true, opArgModeU, opArgModeU, opTypeABC},\n\topProp{\"TAILCALL\", false, true, opArgModeU, opArgModeU, opTypeABC},\n\topProp{\"RETURN\", false, false, opArgModeU, opArgModeN, opTypeABC},\n\topProp{\"FORLOOP\", false, true, opArgModeR, opArgModeN, opTypeASbx},\n\topProp{\"FORPREP\", false, true, opArgModeR, opArgModeN, opTypeASbx},\n\topProp{\"TFORLOOP\", true, false, opArgModeN, opArgModeU, opTypeABC},\n\topProp{\"SETLIST\", false, false, opArgModeU, opArgModeU, opTypeABC},\n\topProp{\"CLOSE\", false, false, opArgModeN, opArgModeN, opTypeABC},\n\topProp{\"CLOSURE\", false, true, opArgModeU, opArgModeN, opTypeABx},\n\topProp{\"VARARG\", false, true, opArgModeU, opArgModeN, opTypeABC},\n\topProp{\"NOP\", false, false, opArgModeR, opArgModeN, opTypeASbx},\n}\n\nfunc opGetOpCode(inst uint32) int {\n\treturn int(inst >> 26)\n}\n\nfunc opSetOpCode(inst *uint32, opcode int) {\n\t*inst = (*inst & 0x3ffffff) | uint32(opcode<<26)\n}\n\nfunc opGetArgA(inst uint32) int {\n\treturn int(inst>>18) & 0xff\n}\n\nfunc opSetArgA(inst *uint32, arg int) {\n\t*inst = (*inst & 0xfc03ffff) | uint32((arg&0xff)<<18)\n}\n\nfunc opGetArgB(inst uint32) int {\n\treturn int(inst & 0x1ff)\n}\n\nfunc opSetArgB(inst *uint32, arg int) {\n\t*inst = (*inst & 0xfffffe00) | uint32(arg&0x1ff)\n}\n\nfunc opGetArgC(inst uint32) int {\n\treturn int(inst>>9) & 0x1ff\n}\n\nfunc opSetArgC(inst *uint32, arg int) {\n\t*inst = (*inst & 0xfffc01ff) | uint32((arg&0x1ff)<<9)\n}\n\nfunc opGetArgBx(inst uint32) int {\n\treturn int(inst & 0x3ffff)\n}\n\nfunc opSetArgBx(inst *uint32, arg int) {\n\t*inst = (*inst & 0xfffc0000) | uint32(arg&0x3ffff)\n}\n\nfunc opGetArgSbx(inst uint32) int {\n\treturn opGetArgBx(inst) - opMaxArgSbx\n}\n\nfunc opSetArgSbx(inst *uint32, arg int) {\n\topSetArgBx(inst, arg+opMaxArgSbx)\n}\n\nfunc opCreateABC(op int, a int, b int, c int) uint32 {\n\tvar inst uint32 = 0\n\topSetOpCode(&inst, op)\n\topSetArgA(&inst, a)\n\topSetArgB(&inst, b)\n\topSetArgC(&inst, c)\n\treturn inst\n}\n\nfunc opCreateABx(op int, a int, bx int) uint32 {\n\tvar inst uint32 = 0\n\topSetOpCode(&inst, op)\n\topSetArgA(&inst, a)\n\topSetArgBx(&inst, bx)\n\treturn inst\n}\n\nfunc opCreateASbx(op int, a int, sbx int) uint32 {\n\tvar inst uint32 = 0\n\topSetOpCode(&inst, op)\n\topSetArgA(&inst, a)\n\topSetArgSbx(&inst, sbx)\n\treturn inst\n}\n\nconst opBitRk = 1 << (opSizeB - 1)\nconst opMaxIndexRk = opBitRk - 1\n\nfunc opIsK(value int) bool {\n\treturn bool((value & opBitRk) != 0)\n}\n\nfunc opIndexK(value int) int {\n\treturn value & ^opBitRk\n}\n\nfunc opRkAsk(value int) int {\n\treturn value | opBitRk\n}\n\nfunc opToString(inst uint32) string {\n\top := opGetOpCode(inst)\n\tif op > opCodeMax {\n\t\treturn \"\"\n\t}\n\tprop := &(opProps[op])\n\n\targa := opGetArgA(inst)\n\targb := opGetArgB(inst)\n\targc := opGetArgC(inst)\n\targbx := opGetArgBx(inst)\n\targsbx := opGetArgSbx(inst)\n\n\tbuf := \"\"\n\tswitch prop.Type {\n\tcase opTypeABC:\n\t\tbuf = fmt.Sprintf(\"%s      |  %d, %d, %d\", prop.Name, arga, argb, argc)\n\tcase opTypeABx:\n\t\tbuf = fmt.Sprintf(\"%s      |  %d, %d\", prop.Name, arga, argbx)\n\tcase opTypeASbx:\n\t\tbuf = fmt.Sprintf(\"%s      |  %d, %d\", prop.Name, arga, argsbx)\n\t}\n\n\tswitch op {\n\tcase OP_MOVE:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := R(%v)\", arga, argb)\n\tcase OP_MOVEN:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := R(%v); followed by %v MOVE ops\", arga, argb, argc)\n\tcase OP_LOADK:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := Kst(%v)\", arga, argbx)\n\tcase OP_LOADBOOL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := (Bool)%v; if (%v) pc++\", arga, argb, argc)\n\tcase OP_LOADNIL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := ... := R(%v) := nil\", arga, argb)\n\tcase OP_GETUPVAL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := UpValue[%v]\", arga, argb)\n\tcase OP_GETGLOBAL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := Gbl[Kst(%v)]\", arga, argbx)\n\tcase OP_GETTABLE:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := R(%v)[RK(%v)]\", arga, argb, argc)\n\tcase OP_GETTABLEKS:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := R(%v)[RK(%v)] ; RK(%v) is constant string\", arga, argb, argc, argc)\n\tcase OP_SETGLOBAL:\n\t\tbuf += fmt.Sprintf(\"; Gbl[Kst(%v)] := R(%v)\", argbx, arga)\n\tcase OP_SETUPVAL:\n\t\tbuf += fmt.Sprintf(\"; UpValue[%v] := R(%v)\", argb, arga)\n\tcase OP_SETTABLE:\n\t\tbuf += fmt.Sprintf(\"; R(%v)[RK(%v)] := RK(%v)\", arga, argb, argc)\n\tcase OP_SETTABLEKS:\n\t\tbuf += fmt.Sprintf(\"; R(%v)[RK(%v)] := RK(%v) ; RK(%v) is constant string\", arga, argb, argc, argb)\n\tcase OP_NEWTABLE:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := {} (size = BC)\", arga)\n\tcase OP_SELF:\n\t\tbuf += fmt.Sprintf(\"; R(%v+1) := R(%v); R(%v) := R(%v)[RK(%v)]\", arga, argb, arga, argb, argc)\n\tcase OP_ADD:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) + RK(%v)\", arga, argb, argc)\n\tcase OP_SUB:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) - RK(%v)\", arga, argb, argc)\n\tcase OP_MUL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) * RK(%v)\", arga, argb, argc)\n\tcase OP_DIV:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) / RK(%v)\", arga, argb, argc)\n\tcase OP_MOD:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) %% RK(%v)\", arga, argb, argc)\n\tcase OP_POW:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := RK(%v) ^ RK(%v)\", arga, argb, argc)\n\tcase OP_UNM:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := -R(%v)\", arga, argb)\n\tcase OP_NOT:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := not R(%v)\", arga, argb)\n\tcase OP_LEN:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := length of R(%v)\", arga, argb)\n\tcase OP_CONCAT:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := R(%v).. ... ..R(%v)\", arga, argb, argc)\n\tcase OP_JMP:\n\t\tbuf += fmt.Sprintf(\"; pc+=%v\", argsbx)\n\tcase OP_EQ:\n\t\tbuf += fmt.Sprintf(\"; if ((RK(%v) == RK(%v)) ~= %v) then pc++\", argb, argc, arga)\n\tcase OP_LT:\n\t\tbuf += fmt.Sprintf(\"; if ((RK(%v) <  RK(%v)) ~= %v) then pc++\", argb, argc, arga)\n\tcase OP_LE:\n\t\tbuf += fmt.Sprintf(\"; if ((RK(%v) <= RK(%v)) ~= %v) then pc++\", argb, argc, arga)\n\tcase OP_TEST:\n\t\tbuf += fmt.Sprintf(\"; if not (R(%v) <=> %v) then pc++\", arga, argc)\n\tcase OP_TESTSET:\n\t\tbuf += fmt.Sprintf(\"; if (R(%v) <=> %v) then R(%v) := R(%v) else pc++\", argb, argc, arga, argb)\n\tcase OP_CALL:\n\t\tbuf += fmt.Sprintf(\"; R(%v) ... R(%v+%v-2) := R(%v)(R(%v+1) ... R(%v+%v-1))\", arga, arga, argc, arga, arga, arga, argb)\n\tcase OP_TAILCALL:\n\t\tbuf += fmt.Sprintf(\"; return R(%v)(R(%v+1) ... R(%v+%v-1))\", arga, arga, arga, argb)\n\tcase OP_RETURN:\n\t\tbuf += fmt.Sprintf(\"; return R(%v) ... R(%v+%v-2)\", arga, arga, argb)\n\tcase OP_FORLOOP:\n\t\tbuf += fmt.Sprintf(\"; R(%v)+=R(%v+2); if R(%v) <?= R(%v+1) then { pc+=%v; R(%v+3)=R(%v) }\", arga, arga, arga, arga, argsbx, arga, arga)\n\tcase OP_FORPREP:\n\t\tbuf += fmt.Sprintf(\"; R(%v)-=R(%v+2); pc+=%v\", arga, arga, argsbx)\n\tcase OP_TFORLOOP:\n\t\tbuf += fmt.Sprintf(\"; R(%v+3) ... R(%v+3+%v) := R(%v)(R(%v+1) R(%v+2)); if R(%v+3) ~= nil then { pc++; R(%v+2)=R(%v+3); }\", arga, arga, argc, arga, arga, arga, arga, arga, arga)\n\tcase OP_SETLIST:\n\t\tbuf += fmt.Sprintf(\"; R(%v)[(%v-1)*FPF+i] := R(%v+i) 1 <= i <= %v\", arga, argc, arga, argb)\n\tcase OP_CLOSE:\n\t\tbuf += fmt.Sprintf(\"; close all variables in the stack up to (>=) R(%v)\", arga)\n\tcase OP_CLOSURE:\n\t\tbuf += fmt.Sprintf(\"; R(%v) := closure(KPROTO[%v] R(%v) ... R(%v+n))\", arga, argbx, arga, arga)\n\tcase OP_VARARG:\n\t\tbuf += fmt.Sprintf(\";  R(%v) R(%v+1) ... R(%v+%v-1) = vararg\", arga, arga, arga, argb)\n\tcase OP_NOP:\n\t\t/* nothing to do */\n\t}\n\treturn buf\n}\n"
        },
        {
          "name": "oslib.go",
          "type": "blob",
          "size": 4.6123046875,
          "content": "package lua\n\nimport (\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar startedAt time.Time\n\nfunc init() {\n\tstartedAt = time.Now()\n}\n\nfunc getIntField(L *LState, tb *LTable, key string, v int) int {\n\tret := tb.RawGetString(key)\n\n\tswitch lv := ret.(type) {\n\tcase LNumber:\n\t\treturn int(lv)\n\tcase LString:\n\t\tslv := string(lv)\n\t\tslv = strings.TrimLeft(slv, \" \")\n\t\tif strings.HasPrefix(slv, \"0\") && !strings.HasPrefix(slv, \"0x\") && !strings.HasPrefix(slv, \"0X\") {\n\t\t\t// Standard lua interpreter only support decimal and hexadecimal\n\t\t\tslv = strings.TrimLeft(slv, \"0\")\n\t\t\tif slv == \"\" {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t\tif num, err := parseNumber(slv); err == nil {\n\t\t\treturn int(num)\n\t\t}\n\tdefault:\n\t\treturn v\n\t}\n\n\treturn v\n}\n\nfunc getBoolField(L *LState, tb *LTable, key string, v bool) bool {\n\tret := tb.RawGetString(key)\n\tif lb, ok := ret.(LBool); ok {\n\t\treturn bool(lb)\n\t}\n\treturn v\n}\n\nfunc OpenOs(L *LState) int {\n\tosmod := L.RegisterModule(OsLibName, osFuncs)\n\tL.Push(osmod)\n\treturn 1\n}\n\nvar osFuncs = map[string]LGFunction{\n\t\"clock\":     osClock,\n\t\"difftime\":  osDiffTime,\n\t\"execute\":   osExecute,\n\t\"exit\":      osExit,\n\t\"date\":      osDate,\n\t\"getenv\":    osGetEnv,\n\t\"remove\":    osRemove,\n\t\"rename\":    osRename,\n\t\"setenv\":    osSetEnv,\n\t\"setlocale\": osSetLocale,\n\t\"time\":      osTime,\n\t\"tmpname\":   osTmpname,\n}\n\nfunc osClock(L *LState) int {\n\tL.Push(LNumber(float64(time.Now().Sub(startedAt)) / float64(time.Second)))\n\treturn 1\n}\n\nfunc osDiffTime(L *LState) int {\n\tL.Push(LNumber(L.CheckInt64(1) - L.CheckInt64(2)))\n\treturn 1\n}\n\nfunc osExecute(L *LState) int {\n\tvar procAttr os.ProcAttr\n\tprocAttr.Files = []*os.File{os.Stdin, os.Stdout, os.Stderr}\n\tcmd, args := popenArgs(L.CheckString(1))\n\targs = append([]string{cmd}, args...)\n\tprocess, err := os.StartProcess(cmd, args, &procAttr)\n\tif err != nil {\n\t\tL.Push(LNumber(1))\n\t\treturn 1\n\t}\n\n\tps, err := process.Wait()\n\tif err != nil || !ps.Success() {\n\t\tL.Push(LNumber(1))\n\t\treturn 1\n\t}\n\tL.Push(LNumber(0))\n\treturn 1\n}\n\nfunc osExit(L *LState) int {\n\tL.Close()\n\tos.Exit(L.OptInt(1, 0))\n\treturn 1\n}\n\nfunc osDate(L *LState) int {\n\tt := time.Now()\n\tisUTC := false\n\tcfmt := \"%c\"\n\tif L.GetTop() >= 1 {\n\t\tcfmt = L.CheckString(1)\n\t\tif strings.HasPrefix(cfmt, \"!\") {\n\t\t\tcfmt = strings.TrimLeft(cfmt, \"!\")\n\t\t\tisUTC = true\n\t\t}\n\t\tif L.GetTop() >= 2 {\n\t\t\tt = time.Unix(L.CheckInt64(2), 0)\n\t\t}\n\t\tif isUTC {\n\t\t\tt = t.UTC()\n\t\t}\n\t\tif strings.HasPrefix(cfmt, \"*t\") {\n\t\t\tret := L.NewTable()\n\t\t\tret.RawSetString(\"year\", LNumber(t.Year()))\n\t\t\tret.RawSetString(\"month\", LNumber(t.Month()))\n\t\t\tret.RawSetString(\"day\", LNumber(t.Day()))\n\t\t\tret.RawSetString(\"hour\", LNumber(t.Hour()))\n\t\t\tret.RawSetString(\"min\", LNumber(t.Minute()))\n\t\t\tret.RawSetString(\"sec\", LNumber(t.Second()))\n\t\t\tret.RawSetString(\"wday\", LNumber(t.Weekday()+1))\n\t\t\t// TODO yday & dst\n\t\t\tret.RawSetString(\"yday\", LNumber(0))\n\t\t\tret.RawSetString(\"isdst\", LFalse)\n\t\t\tL.Push(ret)\n\t\t\treturn 1\n\t\t}\n\t}\n\tL.Push(LString(strftime(t, cfmt)))\n\treturn 1\n}\n\nfunc osGetEnv(L *LState) int {\n\tv := os.Getenv(L.CheckString(1))\n\tif len(v) == 0 {\n\t\tL.Push(LNil)\n\t} else {\n\t\tL.Push(LString(v))\n\t}\n\treturn 1\n}\n\nfunc osRemove(L *LState) int {\n\terr := os.Remove(L.CheckString(1))\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t} else {\n\t\tL.Push(LTrue)\n\t\treturn 1\n\t}\n}\n\nfunc osRename(L *LState) int {\n\terr := os.Rename(L.CheckString(1), L.CheckString(2))\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t} else {\n\t\tL.Push(LTrue)\n\t\treturn 1\n\t}\n}\n\nfunc osSetLocale(L *LState) int {\n\t// setlocale is not supported\n\tL.Push(LFalse)\n\treturn 1\n}\n\nfunc osSetEnv(L *LState) int {\n\terr := os.Setenv(L.CheckString(1), L.CheckString(2))\n\tif err != nil {\n\t\tL.Push(LNil)\n\t\tL.Push(LString(err.Error()))\n\t\treturn 2\n\t} else {\n\t\tL.Push(LTrue)\n\t\treturn 1\n\t}\n}\n\nfunc osTime(L *LState) int {\n\tif L.GetTop() == 0 {\n\t\tL.Push(LNumber(time.Now().Unix()))\n\t} else {\n\t\tlv := L.CheckAny(1)\n\t\tif lv == LNil {\n\t\t\tL.Push(LNumber(time.Now().Unix()))\n\t\t} else {\n\t\t\ttbl, ok := lv.(*LTable)\n\t\t\tif !ok {\n\t\t\t\tL.TypeError(1, LTTable)\n\t\t\t}\n\t\t\tsec := getIntField(L, tbl, \"sec\", 0)\n\t\t\tmin := getIntField(L, tbl, \"min\", 0)\n\t\t\thour := getIntField(L, tbl, \"hour\", 12)\n\t\t\tday := getIntField(L, tbl, \"day\", -1)\n\t\t\tmonth := getIntField(L, tbl, \"month\", -1)\n\t\t\tyear := getIntField(L, tbl, \"year\", -1)\n\t\t\tisdst := getBoolField(L, tbl, \"isdst\", false)\n\t\t\tt := time.Date(year, time.Month(month), day, hour, min, sec, 0, time.Local)\n\t\t\t// TODO dst\n\t\t\tif false {\n\t\t\t\tprint(isdst)\n\t\t\t}\n\t\t\tL.Push(LNumber(t.Unix()))\n\t\t}\n\t}\n\treturn 1\n}\n\nfunc osTmpname(L *LState) int {\n\tfile, err := os.CreateTemp(\"\", \"\")\n\tif err != nil {\n\t\tL.RaiseError(\"unable to generate a unique filename\")\n\t}\n\tfile.Close()\n\tos.Remove(file.Name()) // ignore errors\n\tL.Push(LString(file.Name()))\n\treturn 1\n}\n\n//\n"
        },
        {
          "name": "oslib_test.go",
          "type": "blob",
          "size": 0.755859375,
          "content": "package lua\n\nimport (\n\t\"testing\"\n)\n\n// correctly gc-ed. There was a bug in gopher lua where local vars were not being gc-ed in all circumstances.\nfunc TestOsWrite(t *testing.T) {\n\ts := `\n\t\tlocal function write(filename, content)\n\t\tlocal f = assert(io.open(filename, \"w\"))\n\t\t  f:write(content)\n\t\t  assert(f:close())\n\t\tend\n\n\t\tlocal filename = os.tmpname()\n\t\twrite(filename, \"abc\")\n\t\twrite(filename, \"d\")\n\t\tlocal f = assert(io.open(filename, \"r\"))\n\t\tlocal content = f:read(\"*all\"):gsub(\"%s+\", \"\")\n\t\tf:close()\n\t\tos.remove(filename)\n\t\tlocal expected = \"d\"\n\t\tif content ~= expected then\n\t\t\terror(string.format(\"Invalid content: Expecting \\\"%s\\\", got \\\"%s\\\"\", expected, content))\n\t\tend\n`\n\tL := NewState()\n\tdefer L.Close()\n\tif err := L.DoString(s); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "package.go",
          "type": "blob",
          "size": 0.259765625,
          "content": "// GopherLua: VM and compiler for Lua in Go\npackage lua\n\nconst PackageName = \"GopherLua\"\nconst PackageVersion = \"0.1\"\nconst PackageAuthors = \"Yusuke Inuzuka\"\nconst PackageCopyRight = PackageName + \" \" + PackageVersion + \" Copyright (C) 2015 -2017 \" + PackageAuthors\n"
        },
        {
          "name": "parse",
          "type": "tree",
          "content": null
        },
        {
          "name": "pm",
          "type": "tree",
          "content": null
        },
        {
          "name": "script_test.go",
          "type": "blob",
          "size": 4.5556640625,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/yuin/gopher-lua/parse\"\n)\n\nconst maxMemory = 40\n\nvar gluaTests []string = []string{\n\t\"base.lua\",\n\t\"coroutine.lua\",\n\t\"db.lua\",\n\t\"issues.lua\",\n\t\"os.lua\",\n\t\"table.lua\",\n\t\"vm.lua\",\n\t\"math.lua\",\n\t\"strings.lua\",\n\t\"goto.lua\",\n}\n\nvar luaTests []string = []string{\n\t\"attrib.lua\",\n\t\"calls.lua\",\n\t\"closure.lua\",\n\t\"constructs.lua\",\n\t\"events.lua\",\n\t\"literals.lua\",\n\t\"locals.lua\",\n\t\"math.lua\",\n\t\"sort.lua\",\n\t\"strings.lua\",\n\t\"vararg.lua\",\n\t\"pm.lua\",\n\t\"files.lua\",\n}\n\nfunc testScriptCompile(t *testing.T, script string) {\n\tfile, err := os.Open(script)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tchunk, err2 := parse.Parse(file, script)\n\tif err2 != nil {\n\t\tt.Fatal(err2)\n\t\treturn\n\t}\n\tparse.Dump(chunk)\n\tproto, err3 := Compile(chunk, script)\n\tif err3 != nil {\n\t\tt.Fatal(err3)\n\t\treturn\n\t}\n\tnop := func(s string) {}\n\tnop(proto.String())\n}\n\nfunc testScriptDir(t *testing.T, tests []string, directory string) {\n\tif err := os.Chdir(directory); err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Chdir(\"..\")\n\tfor _, script := range tests {\n\t\tfmt.Printf(\"testing %s/%s\\n\", directory, script)\n\t\ttestScriptCompile(t, script)\n\t\tL := NewState(Options{\n\t\t\tRegistrySize:        1024 * 20,\n\t\t\tCallStackSize:       1024,\n\t\t\tIncludeGoStackTrace: true,\n\t\t})\n\t\tL.SetMx(maxMemory)\n\t\tif err := L.DoFile(script); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tL.Close()\n\t}\n}\n\nvar numActiveUserDatas int32 = 0\n\ntype finalizerStub struct{ x byte }\n\nfunc allocFinalizerUserData(L *LState) int {\n\tud := L.NewUserData()\n\tatomic.AddInt32(&numActiveUserDatas, 1)\n\ta := finalizerStub{}\n\tud.Value = &a\n\truntime.SetFinalizer(&a, func(aa *finalizerStub) {\n\t\tatomic.AddInt32(&numActiveUserDatas, -1)\n\t})\n\tL.Push(ud)\n\treturn 1\n}\n\nfunc sleep(L *LState) int {\n\ttime.Sleep(time.Duration(L.CheckInt(1)) * time.Millisecond)\n\treturn 0\n}\n\nfunc countFinalizers(L *LState) int {\n\tL.Push(LNumber(numActiveUserDatas))\n\treturn 1\n}\n\n// TestLocalVarFree verifies that tables and user user datas which are no longer referenced by the lua script are\n// correctly gc-ed. There was a bug in gopher lua where local vars were not being gc-ed in all circumstances.\nfunc TestLocalVarFree(t *testing.T) {\n\ts := `\n\t\tfunction Test(a, b, c)\n\t\t\tlocal a = { v = allocFinalizer() }\n\t\t\tlocal b = { v = allocFinalizer() }\n\t\t\treturn a\n\t\tend\n\t\tTest(1,2,3)\n\t\tfor i = 1, 100 do\n\t\t\tcollectgarbage()\n\t\t\tif countFinalizers() == 0 then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tsleep(100)\n\t\tend\n\t\terror(\"user datas not finalized after 100 gcs\")\n`\n\tL := NewState()\n\tL.SetGlobal(\"allocFinalizer\", L.NewFunction(allocFinalizerUserData))\n\tL.SetGlobal(\"sleep\", L.NewFunction(sleep))\n\tL.SetGlobal(\"countFinalizers\", L.NewFunction(countFinalizers))\n\tdefer L.Close()\n\tif err := L.DoString(s); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestGlua(t *testing.T) {\n\ttestScriptDir(t, gluaTests, \"_glua-tests\")\n}\n\nfunc TestLua(t *testing.T) {\n\ttestScriptDir(t, luaTests, \"_lua5.1-tests\")\n}\n\nfunc TestMergingLoadNilBug(t *testing.T) {\n\t// there was a bug where a multiple load nils were being incorrectly merged, and the following code exposed it\n\ts := `\n    function test()\n        local a = 0\n        local b = 1\n        local c = 2\n        local d = 3\n        local e = 4\t\t-- reg 4\n        local f = 5\n        local g = 6\n        local h = 7\n\n        if e == 4 then\n            e = nil\t\t-- should clear reg 4, but clears regs 4-8 by mistake\n        end\n        if f == nil then\n            error(\"bad f\")\n        end\n        if g == nil then\n            error(\"bad g\")\n        end\n        if h == nil then\n            error(\"bad h\")\n        end\n    end\n\n    test()\n`\n\n\tL := NewState()\n\tdefer L.Close()\n\tif err := L.DoString(s); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestMergingLoadNil(t *testing.T) {\n\t// multiple nil assignments to consecutive registers should be merged\n\ts := `\n\t\tfunction test()\n\t\t\tlocal a = 0\n\t\t\tlocal b = 1\n\t\t\tlocal c = 2\n\n\t\t\t-- this should generate just one LOADNIL byte code instruction\n\t\t\ta = nil\n\t\t\tb = nil\n\t\t\tc = nil\n\n\t\t\tprint(a,b,c)\n\t\tend\n\n\t\ttest()`\n\n\tchunk, err := parse.Parse(strings.NewReader(s), \"test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcompiled, err := Compile(chunk, \"test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(compiled.FunctionPrototypes) != 1 {\n\t\tt.Fatal(\"expected 1 function prototype\")\n\t}\n\n\t// there should be exactly 1 LOADNIL instruction in the byte code generated for the above\n\t// anymore, and the LOADNIL merging is not working correctly\n\tcount := 0\n\tfor _, instr := range compiled.FunctionPrototypes[0].Code {\n\t\tif opGetOpCode(instr) == OP_LOADNIL {\n\t\t\tcount++\n\t\t}\n\t}\n\n\tif count != 1 {\n\t\tt.Fatalf(\"expected 1 LOADNIL instruction, found %d\", count)\n\t}\n}\n"
        },
        {
          "name": "state.go",
          "type": "blob",
          "size": 52.5546875,
          "content": "package lua\n\n////////////////////////////////////////////////////////\n// This file was generated by go-inline. DO NOT EDIT. //\n////////////////////////////////////////////////////////\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/yuin/gopher-lua/parse\"\n)\n\nconst MultRet = -1\nconst RegistryIndex = -10000\nconst EnvironIndex = -10001\nconst GlobalsIndex = -10002\n\n/* ApiError {{{ */\n\ntype ApiError struct {\n\tType       ApiErrorType\n\tObject     LValue\n\tStackTrace string\n\t// Underlying error. This attribute is set only if the Type is ApiErrorFile or ApiErrorSyntax\n\tCause error\n}\n\nfunc newApiError(code ApiErrorType, object LValue) *ApiError {\n\treturn &ApiError{code, object, \"\", nil}\n}\n\nfunc newApiErrorS(code ApiErrorType, message string) *ApiError {\n\treturn newApiError(code, LString(message))\n}\n\nfunc newApiErrorE(code ApiErrorType, err error) *ApiError {\n\treturn &ApiError{code, LString(err.Error()), \"\", err}\n}\n\nfunc (e *ApiError) Error() string {\n\tif len(e.StackTrace) > 0 {\n\t\treturn fmt.Sprintf(\"%s\\n%s\", e.Object.String(), e.StackTrace)\n\t}\n\treturn e.Object.String()\n}\n\ntype ApiErrorType int\n\nconst (\n\tApiErrorSyntax ApiErrorType = iota\n\tApiErrorFile\n\tApiErrorRun\n\tApiErrorError\n\tApiErrorPanic\n)\n\n/* }}} */\n\n/* ResumeState {{{ */\n\ntype ResumeState int\n\nconst (\n\tResumeOK ResumeState = iota\n\tResumeYield\n\tResumeError\n)\n\n/* }}} */\n\n/* P {{{ */\n\ntype P struct {\n\tFn      LValue\n\tNRet    int\n\tProtect bool\n\tHandler *LFunction\n}\n\n/* }}} */\n\n/* Options {{{ */\n\n// Options is a configuration that is used to create a new LState.\ntype Options struct {\n\t// Call stack size. This defaults to `lua.CallStackSize`.\n\tCallStackSize int\n\t// Data stack size. This defaults to `lua.RegistrySize`.\n\tRegistrySize int\n\t// Allow the registry to grow from the registry size specified up to a value of RegistryMaxSize. A value of 0\n\t// indicates no growth is permitted. The registry will not shrink again after any growth.\n\tRegistryMaxSize int\n\t// If growth is enabled, step up by an additional `RegistryGrowStep` each time to avoid having to resize too often.\n\t// This defaults to `lua.RegistryGrowStep`\n\tRegistryGrowStep int\n\t// Controls whether or not libraries are opened by default\n\tSkipOpenLibs bool\n\t// Tells whether a Go stacktrace should be included in a Lua stacktrace when panics occur.\n\tIncludeGoStackTrace bool\n\t// If `MinimizeStackMemory` is set, the call stack will be automatically grown or shrank up to a limit of\n\t// `CallStackSize` in order to minimize memory usage. This does incur a slight performance penalty.\n\tMinimizeStackMemory bool\n}\n\n/* }}} */\n\n/* Debug {{{ */\n\ntype Debug struct {\n\tframe           *callFrame\n\tName            string\n\tWhat            string\n\tSource          string\n\tCurrentLine     int\n\tNUpvalues       int\n\tLineDefined     int\n\tLastLineDefined int\n}\n\n/* }}} */\n\n/* callFrame {{{ */\n\ntype callFrame struct {\n\tIdx        int\n\tFn         *LFunction\n\tParent     *callFrame\n\tPc         int\n\tBase       int\n\tLocalBase  int\n\tReturnBase int\n\tNArgs      int\n\tNRet       int\n\tTailCall   int\n}\n\ntype callFrameStack interface {\n\tPush(v callFrame)\n\tPop() *callFrame\n\tLast() *callFrame\n\n\tSetSp(sp int)\n\tSp() int\n\tAt(sp int) *callFrame\n\n\tIsFull() bool\n\tIsEmpty() bool\n\n\tFreeAll()\n}\n\ntype fixedCallFrameStack struct {\n\tarray []callFrame\n\tsp    int\n}\n\nfunc newFixedCallFrameStack(size int) callFrameStack {\n\treturn &fixedCallFrameStack{\n\t\tarray: make([]callFrame, size),\n\t\tsp:    0,\n\t}\n}\n\nfunc (cs *fixedCallFrameStack) IsEmpty() bool { return cs.sp == 0 }\n\nfunc (cs *fixedCallFrameStack) IsFull() bool { return cs.sp == len(cs.array) }\n\nfunc (cs *fixedCallFrameStack) Clear() {\n\tcs.sp = 0\n}\n\nfunc (cs *fixedCallFrameStack) Push(v callFrame) {\n\tcs.array[cs.sp] = v\n\tcs.array[cs.sp].Idx = cs.sp\n\tcs.sp++\n}\n\nfunc (cs *fixedCallFrameStack) Sp() int {\n\treturn cs.sp\n}\n\nfunc (cs *fixedCallFrameStack) SetSp(sp int) {\n\tcs.sp = sp\n}\n\nfunc (cs *fixedCallFrameStack) Last() *callFrame {\n\tif cs.sp == 0 {\n\t\treturn nil\n\t}\n\treturn &cs.array[cs.sp-1]\n}\n\nfunc (cs *fixedCallFrameStack) At(sp int) *callFrame {\n\treturn &cs.array[sp]\n}\n\nfunc (cs *fixedCallFrameStack) Pop() *callFrame {\n\tcs.sp--\n\treturn &cs.array[cs.sp]\n}\n\nfunc (cs *fixedCallFrameStack) FreeAll() {\n\t// nothing to do for fixed callframestack\n}\n\n// FramesPerSegment should be a power of 2 constant for performance reasons. It will allow the go compiler to change\n// the divs and mods into bitshifts. Max is 256 due to current use of uint8 to count how many frames in a segment are\n// used.\nconst FramesPerSegment = 8\n\ntype callFrameStackSegment struct {\n\tarray [FramesPerSegment]callFrame\n}\ntype segIdx uint16\ntype autoGrowingCallFrameStack struct {\n\tsegments []*callFrameStackSegment\n\tsegIdx   segIdx\n\t// segSp is the number of frames in the current segment which are used. Full 'sp' value is segIdx * FramesPerSegment + segSp.\n\t// It points to the next stack slot to use, so 0 means to use the 0th element in the segment, and a value of\n\t// FramesPerSegment indicates that the segment is full and cannot accommodate another frame.\n\tsegSp uint8\n}\n\nvar segmentPool sync.Pool\n\nfunc newCallFrameStackSegment() *callFrameStackSegment {\n\tseg := segmentPool.Get()\n\tif seg == nil {\n\t\treturn &callFrameStackSegment{}\n\t}\n\treturn seg.(*callFrameStackSegment)\n}\n\nfunc freeCallFrameStackSegment(seg *callFrameStackSegment) {\n\tsegmentPool.Put(seg)\n}\n\n// newCallFrameStack allocates a new stack for a lua state, which will auto grow up to a max size of at least maxSize.\n// it will actually grow up to the next segment size multiple after maxSize, where the segment size is dictated by\n// FramesPerSegment.\nfunc newAutoGrowingCallFrameStack(maxSize int) callFrameStack {\n\tcs := &autoGrowingCallFrameStack{\n\t\tsegments: make([]*callFrameStackSegment, (maxSize+(FramesPerSegment-1))/FramesPerSegment),\n\t\tsegIdx:   0,\n\t}\n\tcs.segments[0] = newCallFrameStackSegment()\n\treturn cs\n}\n\nfunc (cs *autoGrowingCallFrameStack) IsEmpty() bool {\n\treturn cs.segIdx == 0 && cs.segSp == 0\n}\n\n// IsFull returns true if the stack cannot receive any more stack pushes without overflowing\nfunc (cs *autoGrowingCallFrameStack) IsFull() bool {\n\treturn int(cs.segIdx) == len(cs.segments) && cs.segSp >= FramesPerSegment\n}\n\nfunc (cs *autoGrowingCallFrameStack) Clear() {\n\tfor i := segIdx(1); i <= cs.segIdx; i++ {\n\t\tfreeCallFrameStackSegment(cs.segments[i])\n\t\tcs.segments[i] = nil\n\t}\n\tcs.segIdx = 0\n\tcs.segSp = 0\n}\n\nfunc (cs *autoGrowingCallFrameStack) FreeAll() {\n\tfor i := segIdx(0); i <= cs.segIdx; i++ {\n\t\tfreeCallFrameStackSegment(cs.segments[i])\n\t\tcs.segments[i] = nil\n\t}\n}\n\n// Push pushes the passed callFrame onto the stack. it panics if the stack is full, caller should call IsFull() before\n// invoking this to avoid this.\nfunc (cs *autoGrowingCallFrameStack) Push(v callFrame) {\n\tcurSeg := cs.segments[cs.segIdx]\n\tif cs.segSp >= FramesPerSegment {\n\t\t// segment full, push new segment if allowed\n\t\tif cs.segIdx < segIdx(len(cs.segments)-1) {\n\t\t\tcurSeg = newCallFrameStackSegment()\n\t\t\tcs.segIdx++\n\t\t\tcs.segments[cs.segIdx] = curSeg\n\t\t\tcs.segSp = 0\n\t\t} else {\n\t\t\tpanic(\"lua callstack overflow\")\n\t\t}\n\t}\n\tcurSeg.array[cs.segSp] = v\n\tcurSeg.array[cs.segSp].Idx = int(cs.segSp) + FramesPerSegment*int(cs.segIdx)\n\tcs.segSp++\n}\n\n// Sp retrieves the current stack depth, which is the number of frames currently pushed on the stack.\nfunc (cs *autoGrowingCallFrameStack) Sp() int {\n\treturn int(cs.segSp) + int(cs.segIdx)*FramesPerSegment\n}\n\n// SetSp can be used to rapidly unwind the stack, freeing all stack frames on the way. It should not be used to\n// allocate new stack space, use Push() for that.\nfunc (cs *autoGrowingCallFrameStack) SetSp(sp int) {\n\tdesiredSegIdx := segIdx(sp / FramesPerSegment)\n\tdesiredFramesInLastSeg := uint8(sp % FramesPerSegment)\n\tfor {\n\t\tif cs.segIdx <= desiredSegIdx {\n\t\t\tbreak\n\t\t}\n\t\tfreeCallFrameStackSegment(cs.segments[cs.segIdx])\n\t\tcs.segments[cs.segIdx] = nil\n\t\tcs.segIdx--\n\t}\n\tcs.segSp = desiredFramesInLastSeg\n}\n\nfunc (cs *autoGrowingCallFrameStack) Last() *callFrame {\n\tcurSeg := cs.segments[cs.segIdx]\n\tsegSp := cs.segSp\n\tif segSp == 0 {\n\t\tif cs.segIdx == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tcurSeg = cs.segments[cs.segIdx-1]\n\t\tsegSp = FramesPerSegment\n\t}\n\treturn &curSeg.array[segSp-1]\n}\n\nfunc (cs *autoGrowingCallFrameStack) At(sp int) *callFrame {\n\tsegIdx := segIdx(sp / FramesPerSegment)\n\tframeIdx := uint8(sp % FramesPerSegment)\n\treturn &cs.segments[segIdx].array[frameIdx]\n}\n\n// Pop pops off the most recent stack frame and returns it\nfunc (cs *autoGrowingCallFrameStack) Pop() *callFrame {\n\tcurSeg := cs.segments[cs.segIdx]\n\tif cs.segSp == 0 {\n\t\tif cs.segIdx == 0 {\n\t\t\t// stack empty\n\t\t\treturn nil\n\t\t}\n\t\tfreeCallFrameStackSegment(curSeg)\n\t\tcs.segments[cs.segIdx] = nil\n\t\tcs.segIdx--\n\t\tcs.segSp = FramesPerSegment\n\t\tcurSeg = cs.segments[cs.segIdx]\n\t}\n\tcs.segSp--\n\treturn &curSeg.array[cs.segSp]\n}\n\n/* }}} */\n\n/* registry {{{ */\n\ntype registryHandler interface {\n\tregistryOverflow()\n}\ntype registry struct {\n\tarray   []LValue\n\ttop     int\n\tgrowBy  int\n\tmaxSize int\n\talloc   *allocator\n\thandler registryHandler\n}\n\nfunc newRegistry(handler registryHandler, initialSize int, growBy int, maxSize int, alloc *allocator) *registry {\n\treturn &registry{make([]LValue, initialSize), 0, growBy, maxSize, alloc, handler}\n}\n\nfunc (rg *registry) checkSize(requiredSize int) { // +inline-start\n\tif requiredSize > cap(rg.array) {\n\t\trg.resize(requiredSize)\n\t}\n} // +inline-end\n\nfunc (rg *registry) resize(requiredSize int) { // +inline-start\n\tnewSize := requiredSize + rg.growBy // give some padding\n\tif newSize > rg.maxSize {\n\t\tnewSize = rg.maxSize\n\t}\n\tif newSize < requiredSize {\n\t\trg.handler.registryOverflow()\n\t\treturn\n\t}\n\trg.forceResize(newSize)\n} // +inline-end\n\nfunc (rg *registry) forceResize(newSize int) {\n\tnewSlice := make([]LValue, newSize)\n\tcopy(newSlice, rg.array[:rg.top]) // should we copy the area beyond top? there shouldn't be any valid values there so it shouldn't be necessary.\n\trg.array = newSlice\n}\n\nfunc (rg *registry) SetTop(topi int) { // +inline-start\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := topi\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\toldtopi := rg.top\n\trg.top = topi\n\tfor i := oldtopi; i < rg.top; i++ {\n\t\trg.array[i] = LNil\n\t}\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\tif rg.top < oldtopi {\n\t\tnilRange := rg.array[rg.top:oldtopi]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n\t//for i := rg.top; i < oldtop; i++ {\n\t//\trg.array[i] = LNil\n\t//}\n} // +inline-end\n\nfunc (rg *registry) Top() int {\n\treturn rg.top\n}\n\nfunc (rg *registry) Push(v LValue) {\n\tnewSize := rg.top + 1\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := newSize\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\trg.array[rg.top] = v\n\trg.top++\n}\n\nfunc (rg *registry) Pop() LValue {\n\tv := rg.array[rg.top-1]\n\trg.array[rg.top-1] = LNil\n\trg.top--\n\treturn v\n}\n\nfunc (rg *registry) Get(reg int) LValue {\n\treturn rg.array[reg]\n}\n\n// CopyRange will move a section of values from index `start` to index `regv`\n// It will move `n` values.\n// `limit` specifies the maximum end range that can be copied from. If it's set to -1, then it defaults to stopping at\n// the top of the registry (values beyond the top are not initialized, so if specifying an alternative `limit` you should\n// pass a value <= rg.top.\n// If start+n is beyond the limit, then nil values will be copied to the destination slots.\n// After the copy, the registry is truncated to be at the end of the copied range, ie the original of the copied values\n// are nilled out. (So top will be regv+n)\n// CopyRange should ideally be renamed to MoveRange.\nfunc (rg *registry) CopyRange(regv, start, limit, n int) { // +inline-start\n\tnewSize := regv + n\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := newSize\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\tif limit == -1 || limit > rg.top {\n\t\tlimit = rg.top\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tsrcIdx := start + i\n\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\trg.array[regv+i] = LNil\n\t\t} else {\n\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t}\n\t}\n\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\toldtop := rg.top\n\trg.top = regv + n\n\tif rg.top < oldtop {\n\t\tnilRange := rg.array[rg.top:oldtop]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n} // +inline-end\n\n// FillNil fills the registry with nil values from regm to regm+n and then sets the registry top to regm+n\nfunc (rg *registry) FillNil(regm, n int) { // +inline-start\n\tnewSize := regm + n\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := newSize\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\trg.array[regm+i] = LNil\n\t}\n\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\toldtop := rg.top\n\trg.top = regm + n\n\tif rg.top < oldtop {\n\t\tnilRange := rg.array[rg.top:oldtop]\n\t\tfor i := range nilRange {\n\t\t\tnilRange[i] = nil\n\t\t}\n\t}\n} // +inline-end\n\nfunc (rg *registry) Insert(value LValue, reg int) {\n\ttop := rg.Top()\n\tif reg >= top {\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t{\n\t\t\tregi := reg\n\t\t\tvali := value\n\t\t\tnewSize := regi + 1\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\trg.array[regi] = vali\n\t\t\tif regi >= rg.top {\n\t\t\t\trg.top = regi + 1\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\ttop--\n\tfor ; top >= reg; top-- {\n\t\t// FIXME consider using copy() here if Insert() is called enough\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t{\n\t\t\tregi := top + 1\n\t\t\tvali := rg.Get(top)\n\t\t\tnewSize := regi + 1\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\trg.array[regi] = vali\n\t\t\tif regi >= rg.top {\n\t\t\t\trg.top = regi + 1\n\t\t\t}\n\t\t}\n\t}\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t{\n\t\tregi := reg\n\t\tvali := value\n\t\tnewSize := regi + 1\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t{\n\t\t\trequiredSize := newSize\n\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\trg.resize(requiredSize)\n\t\t\t}\n\t\t}\n\t\trg.array[regi] = vali\n\t\tif regi >= rg.top {\n\t\t\trg.top = regi + 1\n\t\t}\n\t}\n}\n\nfunc (rg *registry) Set(regi int, vali LValue) { // +inline-start\n\tnewSize := regi + 1\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := newSize\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\trg.array[regi] = vali\n\tif regi >= rg.top {\n\t\trg.top = regi + 1\n\t}\n} // +inline-end\n\nfunc (rg *registry) SetNumber(regi int, vali LNumber) { // +inline-start\n\tnewSize := regi + 1\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t{\n\t\trequiredSize := newSize\n\t\tif requiredSize > cap(rg.array) {\n\t\t\trg.resize(requiredSize)\n\t\t}\n\t}\n\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\tif regi >= rg.top {\n\t\trg.top = regi + 1\n\t}\n} // +inline-end\n\nfunc (rg *registry) IsFull() bool {\n\treturn rg.top >= cap(rg.array)\n}\n\n/* }}} */\n\n/* Global {{{ */\n\nfunc newGlobal() *Global {\n\treturn &Global{\n\t\tMainThread: nil,\n\t\tRegistry:   newLTable(0, 32),\n\t\tGlobal:     newLTable(0, 64),\n\t\tbuiltinMts: make(map[int]LValue),\n\t\ttempFiles:  make([]*os.File, 0, 10),\n\t}\n}\n\n/* }}} */\n\n/* package local methods {{{ */\n\nfunc panicWithTraceback(L *LState) {\n\terr := newApiError(ApiErrorRun, L.Get(-1))\n\terr.StackTrace = L.stackTrace(0)\n\tpanic(err)\n}\n\nfunc panicWithoutTraceback(L *LState) {\n\terr := newApiError(ApiErrorRun, L.Get(-1))\n\tpanic(err)\n}\n\nfunc newLState(options Options) *LState {\n\tal := newAllocator(32)\n\tls := &LState{\n\t\tG:       newGlobal(),\n\t\tParent:  nil,\n\t\tPanic:   panicWithTraceback,\n\t\tDead:    false,\n\t\tOptions: options,\n\n\t\tstop:         0,\n\t\talloc:        al,\n\t\tcurrentFrame: nil,\n\t\twrapped:      false,\n\t\tuvcache:      nil,\n\t\thasErrorFunc: false,\n\t\tmainLoop:     mainLoop,\n\t\tctx:          nil,\n\t}\n\tif options.MinimizeStackMemory {\n\t\tls.stack = newAutoGrowingCallFrameStack(options.CallStackSize)\n\t} else {\n\t\tls.stack = newFixedCallFrameStack(options.CallStackSize)\n\t}\n\tls.reg = newRegistry(ls, options.RegistrySize, options.RegistryGrowStep, options.RegistryMaxSize, al)\n\tls.Env = ls.G.Global\n\treturn ls\n}\n\nfunc (ls *LState) printReg() {\n\tprintln(\"-------------------------\")\n\tprintln(\"thread:\", ls)\n\tprintln(\"top:\", ls.reg.Top())\n\tif ls.currentFrame != nil {\n\t\tprintln(\"function base:\", ls.currentFrame.Base)\n\t\tprintln(\"return base:\", ls.currentFrame.ReturnBase)\n\t} else {\n\t\tprintln(\"(vm not started)\")\n\t}\n\tprintln(\"local base:\", ls.currentLocalBase())\n\tfor i := 0; i < ls.reg.Top(); i++ {\n\t\tprintln(i, ls.reg.Get(i).String())\n\t}\n\tprintln(\"-------------------------\")\n}\n\nfunc (ls *LState) printCallStack() {\n\tprintln(\"-------------------------\")\n\tfor i := 0; i < ls.stack.Sp(); i++ {\n\t\tprint(i)\n\t\tprint(\" \")\n\t\tframe := ls.stack.At(i)\n\t\tif frame == nil {\n\t\t\tbreak\n\t\t}\n\t\tif frame.Fn.IsG {\n\t\t\tprintln(\"IsG:\", true, \"Frame:\", frame, \"Fn:\", frame.Fn)\n\t\t} else {\n\t\t\tprintln(\"IsG:\", false, \"Frame:\", frame, \"Fn:\", frame.Fn, \"pc:\", frame.Pc)\n\t\t}\n\t}\n\tprintln(\"-------------------------\")\n}\n\nfunc (ls *LState) closeAllUpvalues() { // +inline-start\n\tfor cf := ls.currentFrame; cf != nil; cf = cf.Parent {\n\t\tif !cf.Fn.IsG {\n\t\t\tls.closeUpvalues(cf.LocalBase)\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) raiseError(level int, format string, args ...interface{}) {\n\tif !ls.hasErrorFunc {\n\t\tls.closeAllUpvalues()\n\t}\n\tmessage := format\n\tif len(args) > 0 {\n\t\tmessage = fmt.Sprintf(format, args...)\n\t}\n\tif level > 0 {\n\t\tmessage = fmt.Sprintf(\"%v %v\", ls.where(level-1, true), message)\n\t}\n\tif ls.reg.IsFull() {\n\t\t// if the registry is full then it won't be possible to push a value, in this case, force a larger size\n\t\tls.reg.forceResize(ls.reg.Top() + 1)\n\t}\n\tls.reg.Push(LString(message))\n\tls.Panic(ls)\n}\n\nfunc (ls *LState) findLocal(frame *callFrame, no int) string {\n\tfn := frame.Fn\n\tif !fn.IsG {\n\t\tif name, ok := fn.LocalName(no, frame.Pc-1); ok {\n\t\t\treturn name\n\t\t}\n\t}\n\tvar top int\n\tif ls.currentFrame == frame {\n\t\ttop = ls.reg.Top()\n\t} else if frame.Idx+1 < ls.stack.Sp() {\n\t\ttop = ls.stack.At(frame.Idx + 1).Base\n\t} else {\n\t\treturn \"\"\n\t}\n\tif top-frame.LocalBase >= no {\n\t\treturn \"(*temporary)\"\n\t}\n\treturn \"\"\n}\n\nfunc (ls *LState) where(level int, skipg bool) string {\n\tdbg, ok := ls.GetStack(level)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tcf := dbg.frame\n\tproto := cf.Fn.Proto\n\tsourcename := \"[G]\"\n\tif proto != nil {\n\t\tsourcename = proto.SourceName\n\t} else if skipg {\n\t\treturn ls.where(level+1, skipg)\n\t}\n\tline := \"\"\n\tif proto != nil {\n\t\tline = fmt.Sprintf(\"%v:\", proto.DbgSourcePositions[cf.Pc-1])\n\t}\n\treturn fmt.Sprintf(\"%v:%v\", sourcename, line)\n}\n\nfunc (ls *LState) stackTrace(level int) string {\n\tbuf := []string{}\n\theader := \"stack traceback:\"\n\tif ls.currentFrame != nil {\n\t\ti := 0\n\t\tfor dbg, ok := ls.GetStack(i); ok; dbg, ok = ls.GetStack(i) {\n\t\t\tcf := dbg.frame\n\t\t\tbuf = append(buf, fmt.Sprintf(\"\\t%v in %v\", ls.Where(i), ls.formattedFrameFuncName(cf)))\n\t\t\tif !cf.Fn.IsG && cf.TailCall > 0 {\n\t\t\t\tfor tc := cf.TailCall; tc > 0; tc-- {\n\t\t\t\t\tbuf = append(buf, \"\\t(tailcall): ?\")\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\tbuf = append(buf, fmt.Sprintf(\"\\t%v: %v\", \"[G]\", \"?\"))\n\tbuf = buf[intMax(0, intMin(level, len(buf))):len(buf)]\n\tif len(buf) > 20 {\n\t\tnewbuf := make([]string, 0, 20)\n\t\tnewbuf = append(newbuf, buf[0:7]...)\n\t\tnewbuf = append(newbuf, \"\\t...\")\n\t\tnewbuf = append(newbuf, buf[len(buf)-7:len(buf)]...)\n\t\tbuf = newbuf\n\t}\n\treturn fmt.Sprintf(\"%s\\n%s\", header, strings.Join(buf, \"\\n\"))\n}\n\nfunc (ls *LState) formattedFrameFuncName(fr *callFrame) string {\n\tname, ischunk := ls.frameFuncName(fr)\n\tif ischunk {\n\t\treturn name\n\t}\n\tif name[0] != '(' && name[0] != '<' {\n\t\treturn fmt.Sprintf(\"function '%s'\", name)\n\t}\n\treturn fmt.Sprintf(\"function %s\", name)\n}\n\nfunc (ls *LState) rawFrameFuncName(fr *callFrame) string {\n\tname, _ := ls.frameFuncName(fr)\n\treturn name\n}\n\nfunc (ls *LState) frameFuncName(fr *callFrame) (string, bool) {\n\tframe := fr.Parent\n\tif frame == nil {\n\t\tif ls.Parent == nil {\n\t\t\treturn \"main chunk\", true\n\t\t} else {\n\t\t\treturn \"corountine\", true\n\t\t}\n\t}\n\tif !frame.Fn.IsG {\n\t\tpc := frame.Pc - 1\n\t\tfor _, call := range frame.Fn.Proto.DbgCalls {\n\t\t\tif call.Pc == pc {\n\t\t\t\tname := call.Name\n\t\t\t\tif (name == \"?\" || fr.TailCall > 0) && !fr.Fn.IsG {\n\t\t\t\t\tname = fmt.Sprintf(\"<%v:%v>\", fr.Fn.Proto.SourceName, fr.Fn.Proto.LineDefined)\n\t\t\t\t}\n\t\t\t\treturn name, false\n\t\t\t}\n\t\t}\n\t}\n\tif !fr.Fn.IsG {\n\t\treturn fmt.Sprintf(\"<%v:%v>\", fr.Fn.Proto.SourceName, fr.Fn.Proto.LineDefined), false\n\t}\n\treturn \"(anonymous)\", false\n}\n\nfunc (ls *LState) isStarted() bool {\n\treturn ls.currentFrame != nil\n}\n\nfunc (ls *LState) kill() {\n\tls.Dead = true\n\tif ls.ctxCancelFn != nil {\n\t\tls.ctxCancelFn()\n\t}\n}\n\nfunc (ls *LState) indexToReg(idx int) int {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treturn base + idx - 1\n\t} else if idx == 0 {\n\t\treturn -1\n\t} else {\n\t\ttidx := ls.reg.Top() + idx\n\t\tif tidx < base {\n\t\t\treturn -1\n\t\t}\n\t\treturn tidx\n\t}\n}\n\nfunc (ls *LState) currentLocalBase() int {\n\tbase := 0\n\tif ls.currentFrame != nil {\n\t\tbase = ls.currentFrame.LocalBase\n\t}\n\treturn base\n}\n\nfunc (ls *LState) currentEnv() *LTable {\n\treturn ls.Env\n\t/*\n\t\tif ls.currentFrame == nil {\n\t\t\treturn ls.Env\n\t\t}\n\t\treturn ls.currentFrame.Fn.Env\n\t*/\n}\n\nfunc (ls *LState) rkValue(idx int) LValue {\n\t/*\n\t\tif OpIsK(idx) {\n\t\t\treturn ls.currentFrame.Fn.Proto.Constants[opIndexK(idx)]\n\t\t}\n\t\treturn ls.reg.Get(ls.currentFrame.LocalBase + idx)\n\t*/\n\tif (idx & opBitRk) != 0 {\n\t\treturn ls.currentFrame.Fn.Proto.Constants[idx & ^opBitRk]\n\t}\n\treturn ls.reg.array[ls.currentFrame.LocalBase+idx]\n}\n\nfunc (ls *LState) rkString(idx int) string {\n\tif (idx & opBitRk) != 0 {\n\t\treturn ls.currentFrame.Fn.Proto.stringConstants[idx & ^opBitRk]\n\t}\n\treturn string(ls.reg.array[ls.currentFrame.LocalBase+idx].(LString))\n}\n\nfunc (ls *LState) closeUpvalues(idx int) { // +inline-start\n\tif ls.uvcache != nil {\n\t\tvar prev *Upvalue\n\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\tif uv.index >= idx {\n\t\t\t\tif prev != nil {\n\t\t\t\t\tprev.next = nil\n\t\t\t\t} else {\n\t\t\t\t\tls.uvcache = nil\n\t\t\t\t}\n\t\t\t\tuv.Close()\n\t\t\t}\n\t\t\tprev = uv\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) findUpvalue(idx int) *Upvalue {\n\tvar prev *Upvalue\n\tvar next *Upvalue\n\tif ls.uvcache != nil {\n\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\tif uv.index == idx {\n\t\t\t\treturn uv\n\t\t\t}\n\t\t\tif uv.index > idx {\n\t\t\t\tnext = uv\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tprev = uv\n\t\t}\n\t}\n\tuv := &Upvalue{reg: ls.reg, index: idx, closed: false}\n\tif prev != nil {\n\t\tprev.next = uv\n\t} else {\n\t\tls.uvcache = uv\n\t}\n\tif next != nil {\n\t\tuv.next = next\n\t}\n\treturn uv\n}\n\nfunc (ls *LState) metatable(lvalue LValue, rawget bool) LValue {\n\tvar metatable LValue = LNil\n\tswitch obj := lvalue.(type) {\n\tcase *LTable:\n\t\tmetatable = obj.Metatable\n\tcase *LUserData:\n\t\tmetatable = obj.Metatable\n\tdefault:\n\t\tif table, ok := ls.G.builtinMts[int(obj.Type())]; ok {\n\t\t\tmetatable = table\n\t\t}\n\t}\n\n\tif !rawget && metatable != LNil {\n\t\toldmt := metatable\n\t\tif tb, ok := metatable.(*LTable); ok {\n\t\t\tmetatable = tb.RawGetString(\"__metatable\")\n\t\t\tif metatable == LNil {\n\t\t\t\tmetatable = oldmt\n\t\t\t}\n\t\t}\n\t}\n\n\treturn metatable\n}\n\nfunc (ls *LState) metaOp1(lvalue LValue, event string) LValue {\n\tif mt := ls.metatable(lvalue, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\treturn tb.RawGetString(event)\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) metaOp2(value1, value2 LValue, event string) LValue {\n\tif mt := ls.metatable(value1, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\tif ret := tb.RawGetString(event); ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t}\n\tif mt := ls.metatable(value2, true); mt != LNil {\n\t\tif tb, ok := mt.(*LTable); ok {\n\t\t\treturn tb.RawGetString(event)\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) metaCall(lvalue LValue) (*LFunction, bool) {\n\tif fn, ok := lvalue.(*LFunction); ok {\n\t\treturn fn, false\n\t}\n\tif fn, ok := ls.metaOp1(lvalue, \"__call\").(*LFunction); ok {\n\t\treturn fn, true\n\t}\n\treturn nil, false\n}\n\nfunc (ls *LState) initCallFrame(cf *callFrame) { // +inline-start\n\tif cf.Fn.IsG {\n\t\tls.reg.SetTop(cf.LocalBase + cf.NArgs)\n\t} else {\n\t\tproto := cf.Fn.Proto\n\t\tnargs := cf.NArgs\n\t\tnp := int(proto.NumParameters)\n\t\tif nargs < np {\n\t\t\t// default any missing arguments to nil\n\t\t\tnewSize := cf.LocalBase + np\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := ls.reg\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := nargs; i < np; i++ {\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\t\t\tnargs = np\n\t\t\tls.reg.top = newSize\n\t\t}\n\n\t\tif (proto.IsVarArg & VarArgIsVarArg) == 0 {\n\t\t\tif nargs < int(proto.NumUsedRegisters) {\n\t\t\t\tnargs = int(proto.NumUsedRegisters)\n\t\t\t}\n\t\t\tnewSize := cf.LocalBase + nargs\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := ls.reg\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := np; i < nargs; i++ {\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\t\t\tls.reg.top = cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t} else {\n\t\t\t/* swap vararg positions:\n\t\t\t\t\t   closure\n\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t   namedparam2\n\t\t\t\t\t   vararg1\n\t\t\t\t\t   vararg2\n\n\t\t\t           TO\n\n\t\t\t\t\t   closure\n\t\t\t\t\t   nil\n\t\t\t\t\t   nil\n\t\t\t\t\t   vararg1\n\t\t\t\t\t   vararg2\n\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t   namedparam2\n\t\t\t*/\n\t\t\tnvarargs := nargs - np\n\t\t\tif nvarargs < 0 {\n\t\t\t\tnvarargs = 0\n\t\t\t}\n\n\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np)\n\t\t\tfor i := 0; i < np; i++ {\n\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+i, ls.reg.Get(cf.LocalBase+i))\n\t\t\t\tls.reg.array[cf.LocalBase+nargs+i] = ls.reg.array[cf.LocalBase+i]\n\t\t\t\t//ls.reg.Set(cf.LocalBase+i, LNil)\n\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t}\n\n\t\t\tif CompatVarArg {\n\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np + 1)\n\t\t\t\tif (proto.IsVarArg & VarArgNeedsArg) != 0 {\n\t\t\t\t\targtb := newLTable(nvarargs, 0)\n\t\t\t\t\tfor i := 0; i < nvarargs; i++ {\n\t\t\t\t\t\targtb.RawSetInt(i+1, ls.reg.Get(cf.LocalBase+np+i))\n\t\t\t\t\t}\n\t\t\t\t\targtb.RawSetString(\"n\", LNumber(nvarargs))\n\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+np, argtb)\n\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = argtb\n\t\t\t\t} else {\n\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = LNil\n\t\t\t\t}\n\t\t\t}\n\t\t\tcf.LocalBase += nargs\n\t\t\tmaxreg := cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\tls.reg.SetTop(maxreg)\n\t\t}\n\t}\n} // +inline-end\n\nfunc (ls *LState) pushCallFrame(cf callFrame, fn LValue, meta bool) { // +inline-start\n\tif meta {\n\t\tcf.NArgs++\n\t\tls.reg.Insert(fn, cf.LocalBase)\n\t}\n\tif cf.Fn == nil {\n\t\tls.RaiseError(\"attempt to call a non-function object\")\n\t}\n\tif ls.stack.IsFull() {\n\t\tls.RaiseError(\"stack overflow\")\n\t}\n\tls.stack.Push(cf)\n\tnewcf := ls.stack.Last()\n\t// this section is inlined by go-inline\n\t// source function is 'func (ls *LState) initCallFrame(cf *callFrame) ' in '_state.go'\n\t{\n\t\tcf := newcf\n\t\tif cf.Fn.IsG {\n\t\t\tls.reg.SetTop(cf.LocalBase + cf.NArgs)\n\t\t} else {\n\t\t\tproto := cf.Fn.Proto\n\t\t\tnargs := cf.NArgs\n\t\t\tnp := int(proto.NumParameters)\n\t\t\tif nargs < np {\n\t\t\t\t// default any missing arguments to nil\n\t\t\t\tnewSize := cf.LocalBase + np\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := ls.reg\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor i := nargs; i < np; i++ {\n\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t}\n\t\t\t\tnargs = np\n\t\t\t\tls.reg.top = newSize\n\t\t\t}\n\n\t\t\tif (proto.IsVarArg & VarArgIsVarArg) == 0 {\n\t\t\t\tif nargs < int(proto.NumUsedRegisters) {\n\t\t\t\t\tnargs = int(proto.NumUsedRegisters)\n\t\t\t\t}\n\t\t\t\tnewSize := cf.LocalBase + nargs\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := ls.reg\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor i := np; i < nargs; i++ {\n\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t}\n\t\t\t\tls.reg.top = cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t} else {\n\t\t\t\t/* swap vararg positions:\n\t\t\t\t\t\t   closure\n\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t   namedparam2\n\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t   vararg2\n\n\t\t\t\t           TO\n\n\t\t\t\t\t\t   closure\n\t\t\t\t\t\t   nil\n\t\t\t\t\t\t   nil\n\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t   vararg2\n\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t   namedparam2\n\t\t\t\t*/\n\t\t\t\tnvarargs := nargs - np\n\t\t\t\tif nvarargs < 0 {\n\t\t\t\t\tnvarargs = 0\n\t\t\t\t}\n\n\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np)\n\t\t\t\tfor i := 0; i < np; i++ {\n\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+i, ls.reg.Get(cf.LocalBase+i))\n\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+i] = ls.reg.array[cf.LocalBase+i]\n\t\t\t\t\t//ls.reg.Set(cf.LocalBase+i, LNil)\n\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t}\n\n\t\t\t\tif CompatVarArg {\n\t\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np + 1)\n\t\t\t\t\tif (proto.IsVarArg & VarArgNeedsArg) != 0 {\n\t\t\t\t\t\targtb := newLTable(nvarargs, 0)\n\t\t\t\t\t\tfor i := 0; i < nvarargs; i++ {\n\t\t\t\t\t\t\targtb.RawSetInt(i+1, ls.reg.Get(cf.LocalBase+np+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t\targtb.RawSetString(\"n\", LNumber(nvarargs))\n\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+np, argtb)\n\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = argtb\n\t\t\t\t\t} else {\n\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = LNil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcf.LocalBase += nargs\n\t\t\t\tmaxreg := cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t\tls.reg.SetTop(maxreg)\n\t\t\t}\n\t\t}\n\t}\n\tls.currentFrame = newcf\n} // +inline-end\n\nfunc (ls *LState) callR(nargs, nret, rbase int) {\n\tbase := ls.reg.Top() - nargs - 1\n\tif rbase < 0 {\n\t\trbase = base\n\t}\n\tlv := ls.reg.Get(base)\n\tfn, meta := ls.metaCall(lv)\n\tls.pushCallFrame(callFrame{\n\t\tFn:         fn,\n\t\tPc:         0,\n\t\tBase:       base,\n\t\tLocalBase:  base + 1,\n\t\tReturnBase: rbase,\n\t\tNArgs:      nargs,\n\t\tNRet:       nret,\n\t\tParent:     ls.currentFrame,\n\t\tTailCall:   0,\n\t}, lv, meta)\n\tif ls.G.MainThread == nil {\n\t\tls.G.MainThread = ls\n\t\tls.G.CurrentThread = ls\n\t\tls.mainLoop(ls, nil)\n\t} else {\n\t\tls.mainLoop(ls, ls.currentFrame)\n\t}\n\tif nret != MultRet {\n\t\tls.reg.SetTop(rbase + nret)\n\t}\n}\n\nfunc (ls *LState) getField(obj LValue, key LValue) LValue {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tret := tb.RawGet(key)\n\t\t\tif ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__index\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key.String())\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(key)\n\t\t\tls.Call(2, 1)\n\t\t\treturn ls.reg.Pop()\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in gettable\")\n\treturn nil\n}\n\nfunc (ls *LState) getFieldString(obj LValue, key string) LValue {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tret := tb.RawGetString(key)\n\t\t\tif ret != LNil {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__index\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key)\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(LString(key))\n\t\t\tls.Call(2, 1)\n\t\t\treturn ls.reg.Pop()\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in gettable\")\n\treturn nil\n}\n\nfunc (ls *LState) setField(obj LValue, key LValue, value LValue) {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tif tb.RawGet(key) != LNil {\n\t\t\t\tls.RawSet(tb, key, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__newindex\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key.String())\n\t\t\t}\n\t\t\tls.RawSet(tb, key, value)\n\t\t\treturn\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(key)\n\t\t\tls.reg.Push(value)\n\t\t\tls.Call(3, 0)\n\t\t\treturn\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in settable\")\n}\n\nfunc (ls *LState) setFieldString(obj LValue, key string, value LValue) {\n\tcurobj := obj\n\tfor i := 0; i < MaxTableGetLoop; i++ {\n\t\ttb, istable := curobj.(*LTable)\n\t\tif istable {\n\t\t\tif tb.RawGetString(key) != LNil {\n\t\t\t\ttb.RawSetString(key, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tmetaindex := ls.metaOp1(curobj, \"__newindex\")\n\t\tif metaindex == LNil {\n\t\t\tif !istable {\n\t\t\t\tls.RaiseError(\"attempt to index a non-table object(%v) with key '%s'\", curobj.Type().String(), key)\n\t\t\t}\n\t\t\ttb.RawSetString(key, value)\n\t\t\treturn\n\t\t}\n\t\tif metaindex.Type() == LTFunction {\n\t\t\tls.reg.Push(metaindex)\n\t\t\tls.reg.Push(curobj)\n\t\t\tls.reg.Push(LString(key))\n\t\t\tls.reg.Push(value)\n\t\t\tls.Call(3, 0)\n\t\t\treturn\n\t\t} else {\n\t\t\tcurobj = metaindex\n\t\t}\n\t}\n\tls.RaiseError(\"too many recursions in settable\")\n}\n\n/* }}} */\n\n/* api methods {{{ */\n\nfunc NewState(opts ...Options) *LState {\n\tvar ls *LState\n\tif len(opts) == 0 {\n\t\tls = newLState(Options{\n\t\t\tCallStackSize: CallStackSize,\n\t\t\tRegistrySize:  RegistrySize,\n\t\t})\n\t\tls.OpenLibs()\n\t} else {\n\t\tif opts[0].CallStackSize < 1 {\n\t\t\topts[0].CallStackSize = CallStackSize\n\t\t}\n\t\tif opts[0].RegistrySize < 128 {\n\t\t\topts[0].RegistrySize = RegistrySize\n\t\t}\n\t\tif opts[0].RegistryMaxSize < opts[0].RegistrySize {\n\t\t\topts[0].RegistryMaxSize = 0 // disable growth if max size is smaller than initial size\n\t\t} else {\n\t\t\t// if growth enabled, grow step is set\n\t\t\tif opts[0].RegistryGrowStep < 1 {\n\t\t\t\topts[0].RegistryGrowStep = RegistryGrowStep\n\t\t\t}\n\t\t}\n\t\tls = newLState(opts[0])\n\t\tif !opts[0].SkipOpenLibs {\n\t\t\tls.OpenLibs()\n\t\t}\n\t}\n\treturn ls\n}\n\nfunc (ls *LState) IsClosed() bool {\n\treturn ls.stack == nil\n}\n\nfunc (ls *LState) Close() {\n\tatomic.AddInt32(&ls.stop, 1)\n\tfor _, file := range ls.G.tempFiles {\n\t\t// ignore errors in these operations\n\t\tfile.Close()\n\t\tos.Remove(file.Name())\n\t}\n\tls.stack.FreeAll()\n\tls.stack = nil\n}\n\n/* registry operations {{{ */\n\nfunc (ls *LState) GetTop() int {\n\treturn ls.reg.Top() - ls.currentLocalBase()\n}\n\nfunc (ls *LState) SetTop(idx int) {\n\tbase := ls.currentLocalBase()\n\tnewtop := ls.indexToReg(idx) + 1\n\tif newtop < base {\n\t\tls.reg.SetTop(base)\n\t} else {\n\t\tls.reg.SetTop(newtop)\n\t}\n}\n\nfunc (ls *LState) Replace(idx int, value LValue) {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treg := base + idx - 1\n\t\tif reg < ls.reg.Top() {\n\t\t\tls.reg.Set(reg, value)\n\t\t}\n\t} else if idx == 0 {\n\t} else if idx > RegistryIndex {\n\t\tif tidx := ls.reg.Top() + idx; tidx >= base {\n\t\t\tls.reg.Set(tidx, value)\n\t\t}\n\t} else {\n\t\tswitch idx {\n\t\tcase RegistryIndex:\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.G.Registry = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"registry must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tcase EnvironIndex:\n\t\t\tif ls.currentFrame == nil {\n\t\t\t\tls.RaiseError(\"no calling environment\")\n\t\t\t}\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.currentFrame.Fn.Env = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"environment must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tcase GlobalsIndex:\n\t\t\tif tb, ok := value.(*LTable); ok {\n\t\t\t\tls.G.Global = tb\n\t\t\t} else {\n\t\t\t\tls.RaiseError(\"_G must be a table(%v)\", value.Type().String())\n\t\t\t}\n\t\tdefault:\n\t\t\tfn := ls.currentFrame.Fn\n\t\t\tindex := GlobalsIndex - idx - 1\n\t\t\tif index < len(fn.Upvalues) {\n\t\t\t\tfn.Upvalues[index].SetValue(value)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (ls *LState) Get(idx int) LValue {\n\tbase := ls.currentLocalBase()\n\tif idx > 0 {\n\t\treg := base + idx - 1\n\t\tif reg < ls.reg.Top() {\n\t\t\treturn ls.reg.Get(reg)\n\t\t}\n\t\treturn LNil\n\t} else if idx == 0 {\n\t\treturn LNil\n\t} else if idx > RegistryIndex {\n\t\ttidx := ls.reg.Top() + idx\n\t\tif tidx < base {\n\t\t\treturn LNil\n\t\t}\n\t\treturn ls.reg.Get(tidx)\n\t} else {\n\t\tswitch idx {\n\t\tcase RegistryIndex:\n\t\t\treturn ls.G.Registry\n\t\tcase EnvironIndex:\n\t\t\tif ls.currentFrame == nil {\n\t\t\t\treturn ls.Env\n\t\t\t}\n\t\t\treturn ls.currentFrame.Fn.Env\n\t\tcase GlobalsIndex:\n\t\t\treturn ls.G.Global\n\t\tdefault:\n\t\t\tfn := ls.currentFrame.Fn\n\t\t\tindex := GlobalsIndex - idx - 1\n\t\t\tif index < len(fn.Upvalues) {\n\t\t\t\treturn fn.Upvalues[index].Value()\n\t\t\t}\n\t\t\treturn LNil\n\t\t}\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) Push(value LValue) {\n\tls.reg.Push(value)\n}\n\nfunc (ls *LState) Pop(n int) {\n\tfor i := 0; i < n; i++ {\n\t\tif ls.GetTop() == 0 {\n\t\t\tls.RaiseError(\"register underflow\")\n\t\t}\n\t\tls.reg.Pop()\n\t}\n}\n\nfunc (ls *LState) Insert(value LValue, index int) {\n\treg := ls.indexToReg(index)\n\ttop := ls.reg.Top()\n\tif reg >= top {\n\t\tls.reg.Set(reg, value)\n\t\treturn\n\t}\n\tif reg <= ls.currentLocalBase() {\n\t\treg = ls.currentLocalBase()\n\t}\n\ttop--\n\tfor ; top >= reg; top-- {\n\t\tls.reg.Set(top+1, ls.reg.Get(top))\n\t}\n\tls.reg.Set(reg, value)\n}\n\nfunc (ls *LState) Remove(index int) {\n\treg := ls.indexToReg(index)\n\ttop := ls.reg.Top()\n\tswitch {\n\tcase reg >= top:\n\t\treturn\n\tcase reg < ls.currentLocalBase():\n\t\treturn\n\tcase reg == top-1:\n\t\tls.Pop(1)\n\t\treturn\n\t}\n\tfor i := reg; i < top-1; i++ {\n\t\tls.reg.Set(i, ls.reg.Get(i+1))\n\t}\n\tls.reg.SetTop(top - 1)\n}\n\n/* }}} */\n\n/* object allocation {{{ */\n\nfunc (ls *LState) NewTable() *LTable {\n\treturn newLTable(defaultArrayCap, defaultHashCap)\n}\n\nfunc (ls *LState) CreateTable(acap, hcap int) *LTable {\n\treturn newLTable(acap, hcap)\n}\n\n// NewThread returns a new LState that shares with the original state all global objects.\n// If the original state has context.Context, the new state has a new child context of the original state and this function returns its cancel function.\nfunc (ls *LState) NewThread() (*LState, context.CancelFunc) {\n\tthread := newLState(ls.Options)\n\tthread.G = ls.G\n\tthread.Env = ls.Env\n\tvar f context.CancelFunc = nil\n\tif ls.ctx != nil {\n\t\tthread.mainLoop = mainLoopWithContext\n\t\tthread.ctx, f = context.WithCancel(ls.ctx)\n\t\tthread.ctxCancelFn = f\n\t}\n\treturn thread, f\n}\n\nfunc (ls *LState) NewFunctionFromProto(proto *FunctionProto) *LFunction {\n\treturn newLFunctionL(proto, ls.Env, int(proto.NumUpvalues))\n}\n\nfunc (ls *LState) NewUserData() *LUserData {\n\treturn &LUserData{\n\t\tEnv:       ls.currentEnv(),\n\t\tMetatable: LNil,\n\t}\n}\n\nfunc (ls *LState) NewFunction(fn LGFunction) *LFunction {\n\treturn newLFunctionG(fn, ls.currentEnv(), 0)\n}\n\nfunc (ls *LState) NewClosure(fn LGFunction, upvalues ...LValue) *LFunction {\n\tcl := newLFunctionG(fn, ls.currentEnv(), len(upvalues))\n\tfor i, lv := range upvalues {\n\t\tcl.Upvalues[i] = &Upvalue{}\n\t\tcl.Upvalues[i].Close()\n\t\tcl.Upvalues[i].SetValue(lv)\n\t}\n\treturn cl\n}\n\n/* }}} */\n\n/* toType {{{ */\n\nfunc (ls *LState) ToBool(n int) bool {\n\treturn LVAsBool(ls.Get(n))\n}\n\nfunc (ls *LState) ToInt(n int) int {\n\tif lv, ok := ls.Get(n).(LNumber); ok {\n\t\treturn int(lv)\n\t}\n\tif lv, ok := ls.Get(n).(LString); ok {\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn int(num)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (ls *LState) ToInt64(n int) int64 {\n\tif lv, ok := ls.Get(n).(LNumber); ok {\n\t\treturn int64(lv)\n\t}\n\tif lv, ok := ls.Get(n).(LString); ok {\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn int64(num)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (ls *LState) ToNumber(n int) LNumber {\n\treturn LVAsNumber(ls.Get(n))\n}\n\nfunc (ls *LState) ToString(n int) string {\n\treturn LVAsString(ls.Get(n))\n}\n\nfunc (ls *LState) ToTable(n int) *LTable {\n\tif lv, ok := ls.Get(n).(*LTable); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToFunction(n int) *LFunction {\n\tif lv, ok := ls.Get(n).(*LFunction); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToUserData(n int) *LUserData {\n\tif lv, ok := ls.Get(n).(*LUserData); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\nfunc (ls *LState) ToThread(n int) *LState {\n\tif lv, ok := ls.Get(n).(*LState); ok {\n\t\treturn lv\n\t}\n\treturn nil\n}\n\n/* }}} */\n\n/* error & debug operations {{{ */\n\nfunc (ls *LState) registryOverflow() {\n\tls.RaiseError(\"registry overflow\")\n}\n\n// This function is equivalent to luaL_error( http://www.lua.org/manual/5.1/manual.html#luaL_error ).\nfunc (ls *LState) RaiseError(format string, args ...interface{}) {\n\tls.raiseError(1, format, args...)\n}\n\n// This function is equivalent to lua_error( http://www.lua.org/manual/5.1/manual.html#lua_error ).\nfunc (ls *LState) Error(lv LValue, level int) {\n\tif str, ok := lv.(LString); ok {\n\t\tls.raiseError(level, string(str))\n\t} else {\n\t\tif !ls.hasErrorFunc {\n\t\t\tls.closeAllUpvalues()\n\t\t}\n\t\tls.Push(lv)\n\t\tls.Panic(ls)\n\t}\n}\n\nfunc (ls *LState) GetInfo(what string, dbg *Debug, fn LValue) (LValue, error) {\n\tif !strings.HasPrefix(what, \">\") {\n\t\tfn = dbg.frame.Fn\n\t} else {\n\t\twhat = what[1:]\n\t}\n\tf, ok := fn.(*LFunction)\n\tif !ok {\n\t\treturn LNil, newApiErrorS(ApiErrorRun, \"can not get debug info(an object in not a function)\")\n\t}\n\n\tretfn := false\n\tfor _, c := range what {\n\t\tswitch c {\n\t\tcase 'f':\n\t\t\tretfn = true\n\t\tcase 'S':\n\t\t\tif dbg.frame != nil && dbg.frame.Parent == nil {\n\t\t\t\tdbg.What = \"main\"\n\t\t\t} else if f.IsG {\n\t\t\t\tdbg.What = \"G\"\n\t\t\t} else if dbg.frame != nil && dbg.frame.TailCall > 0 {\n\t\t\t\tdbg.What = \"tail\"\n\t\t\t} else {\n\t\t\t\tdbg.What = \"Lua\"\n\t\t\t}\n\t\t\tif !f.IsG {\n\t\t\t\tdbg.Source = f.Proto.SourceName\n\t\t\t\tdbg.LineDefined = f.Proto.LineDefined\n\t\t\t\tdbg.LastLineDefined = f.Proto.LastLineDefined\n\t\t\t}\n\t\tcase 'l':\n\t\t\tif !f.IsG && dbg.frame != nil {\n\t\t\t\tif dbg.frame.Pc > 0 {\n\t\t\t\t\tdbg.CurrentLine = f.Proto.DbgSourcePositions[dbg.frame.Pc-1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdbg.CurrentLine = -1\n\t\t\t}\n\t\tcase 'u':\n\t\t\tdbg.NUpvalues = len(f.Upvalues)\n\t\tcase 'n':\n\t\t\tif dbg.frame != nil {\n\t\t\t\tdbg.Name = ls.rawFrameFuncName(dbg.frame)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn LNil, newApiErrorS(ApiErrorRun, \"invalid what: \"+string(c))\n\t\t}\n\t}\n\n\tif retfn {\n\t\treturn f, nil\n\t}\n\treturn LNil, nil\n\n}\n\nfunc (ls *LState) GetStack(level int) (*Debug, bool) {\n\tframe := ls.currentFrame\n\tfor ; level > 0 && frame != nil; frame = frame.Parent {\n\t\tlevel--\n\t\tif !frame.Fn.IsG {\n\t\t\tlevel -= frame.TailCall\n\t\t}\n\t}\n\n\tif level == 0 && frame != nil {\n\t\treturn &Debug{frame: frame}, true\n\t} else if level < 0 && ls.stack.Sp() > 0 {\n\t\treturn &Debug{frame: ls.stack.At(0)}, true\n\t}\n\treturn &Debug{}, false\n}\n\nfunc (ls *LState) GetLocal(dbg *Debug, no int) (string, LValue) {\n\tframe := dbg.frame\n\tif name := ls.findLocal(frame, no); len(name) > 0 {\n\t\treturn name, ls.reg.Get(frame.LocalBase + no - 1)\n\t}\n\treturn \"\", LNil\n}\n\nfunc (ls *LState) SetLocal(dbg *Debug, no int, lv LValue) string {\n\tframe := dbg.frame\n\tif name := ls.findLocal(frame, no); len(name) > 0 {\n\t\tls.reg.Set(frame.LocalBase+no-1, lv)\n\t\treturn name\n\t}\n\treturn \"\"\n}\n\nfunc (ls *LState) GetUpvalue(fn *LFunction, no int) (string, LValue) {\n\tif fn.IsG {\n\t\treturn \"\", LNil\n\t}\n\n\tno--\n\tif no >= 0 && no < len(fn.Upvalues) {\n\t\treturn fn.Proto.DbgUpvalues[no], fn.Upvalues[no].Value()\n\t}\n\treturn \"\", LNil\n}\n\nfunc (ls *LState) SetUpvalue(fn *LFunction, no int, lv LValue) string {\n\tif fn.IsG {\n\t\treturn \"\"\n\t}\n\n\tno--\n\tif no >= 0 && no < len(fn.Upvalues) {\n\t\tfn.Upvalues[no].SetValue(lv)\n\t\treturn fn.Proto.DbgUpvalues[no]\n\t}\n\treturn \"\"\n}\n\n/* }}} */\n\n/* env operations {{{ */\n\nfunc (ls *LState) GetFEnv(obj LValue) LValue {\n\tswitch lv := obj.(type) {\n\tcase *LFunction:\n\t\treturn lv.Env\n\tcase *LUserData:\n\t\treturn lv.Env\n\tcase *LState:\n\t\treturn lv.Env\n\t}\n\treturn LNil\n}\n\nfunc (ls *LState) SetFEnv(obj LValue, env LValue) {\n\ttb, ok := env.(*LTable)\n\tif !ok {\n\t\tls.RaiseError(\"cannot use %v as an environment\", env.Type().String())\n\t}\n\n\tswitch lv := obj.(type) {\n\tcase *LFunction:\n\t\tlv.Env = tb\n\tcase *LUserData:\n\t\tlv.Env = tb\n\tcase *LState:\n\t\tlv.Env = tb\n\t}\n\t/* do nothing */\n}\n\n/* }}} */\n\n/* table operations {{{ */\n\nfunc (ls *LState) RawGet(tb *LTable, key LValue) LValue {\n\treturn tb.RawGet(key)\n}\n\nfunc (ls *LState) RawGetInt(tb *LTable, key int) LValue {\n\treturn tb.RawGetInt(key)\n}\n\nfunc (ls *LState) GetField(obj LValue, skey string) LValue {\n\treturn ls.getFieldString(obj, skey)\n}\n\nfunc (ls *LState) GetTable(obj LValue, key LValue) LValue {\n\treturn ls.getField(obj, key)\n}\n\nfunc (ls *LState) RawSet(tb *LTable, key LValue, value LValue) {\n\tif n, ok := key.(LNumber); ok && math.IsNaN(float64(n)) {\n\t\tls.RaiseError(\"table index is NaN\")\n\t} else if key == LNil {\n\t\tls.RaiseError(\"table index is nil\")\n\t}\n\ttb.RawSet(key, value)\n}\n\nfunc (ls *LState) RawSetInt(tb *LTable, key int, value LValue) {\n\ttb.RawSetInt(key, value)\n}\n\nfunc (ls *LState) SetField(obj LValue, key string, value LValue) {\n\tls.setFieldString(obj, key, value)\n}\n\nfunc (ls *LState) SetTable(obj LValue, key LValue, value LValue) {\n\tls.setField(obj, key, value)\n}\n\nfunc (ls *LState) ForEach(tb *LTable, cb func(LValue, LValue)) {\n\ttb.ForEach(cb)\n}\n\nfunc (ls *LState) GetGlobal(name string) LValue {\n\treturn ls.GetField(ls.Get(GlobalsIndex), name)\n}\n\nfunc (ls *LState) SetGlobal(name string, value LValue) {\n\tls.SetField(ls.Get(GlobalsIndex), name, value)\n}\n\nfunc (ls *LState) Next(tb *LTable, key LValue) (LValue, LValue) {\n\treturn tb.Next(key)\n}\n\n/* }}} */\n\n/* unary operations {{{ */\n\nfunc (ls *LState) ObjLen(v1 LValue) int {\n\tif v1.Type() == LTString {\n\t\treturn len(string(v1.(LString)))\n\t}\n\top := ls.metaOp1(v1, \"__len\")\n\tif op.Type() == LTFunction {\n\t\tls.Push(op)\n\t\tls.Push(v1)\n\t\tls.Call(1, 1)\n\t\tret := ls.reg.Pop()\n\t\tif ret.Type() == LTNumber {\n\t\t\treturn int(ret.(LNumber))\n\t\t}\n\t} else if v1.Type() == LTTable {\n\t\treturn v1.(*LTable).Len()\n\t}\n\treturn 0\n}\n\n/* }}} */\n\n/* binary operations {{{ */\n\nfunc (ls *LState) Concat(values ...LValue) string {\n\ttop := ls.reg.Top()\n\tfor _, value := range values {\n\t\tls.reg.Push(value)\n\t}\n\tret := stringConcat(ls, len(values), ls.reg.Top()-1)\n\tls.reg.SetTop(top)\n\treturn LVAsString(ret)\n}\n\nfunc (ls *LState) LessThan(lhs, rhs LValue) bool {\n\treturn lessThan(ls, lhs, rhs)\n}\n\nfunc (ls *LState) Equal(lhs, rhs LValue) bool {\n\treturn equals(ls, lhs, rhs, false)\n}\n\nfunc (ls *LState) RawEqual(lhs, rhs LValue) bool {\n\treturn equals(ls, lhs, rhs, true)\n}\n\n/* }}} */\n\n/* register operations {{{ */\n\nfunc (ls *LState) Register(name string, fn LGFunction) {\n\tls.SetGlobal(name, ls.NewFunction(fn))\n}\n\n/* }}} */\n\n/* load and function call operations {{{ */\n\nfunc (ls *LState) Load(reader io.Reader, name string) (*LFunction, error) {\n\tchunk, err := parse.Parse(reader, name)\n\tif err != nil {\n\t\treturn nil, newApiErrorE(ApiErrorSyntax, err)\n\t}\n\tproto, err := Compile(chunk, name)\n\tif err != nil {\n\t\treturn nil, newApiErrorE(ApiErrorSyntax, err)\n\t}\n\treturn newLFunctionL(proto, ls.currentEnv(), 0), nil\n}\n\nfunc (ls *LState) Call(nargs, nret int) {\n\tls.callR(nargs, nret, -1)\n}\n\nfunc (ls *LState) PCall(nargs, nret int, errfunc *LFunction) (err error) {\n\terr = nil\n\tsp := ls.stack.Sp()\n\tbase := ls.reg.Top() - nargs - 1\n\toldpanic := ls.Panic\n\tls.Panic = panicWithoutTraceback\n\tif errfunc != nil {\n\t\tls.hasErrorFunc = true\n\t}\n\tdefer func() {\n\t\tls.Panic = oldpanic\n\t\tls.hasErrorFunc = false\n\t\trcv := recover()\n\t\tif rcv != nil {\n\t\t\tif _, ok := rcv.(*ApiError); !ok {\n\t\t\t\terr = newApiErrorS(ApiErrorPanic, fmt.Sprint(rcv))\n\t\t\t\tif ls.Options.IncludeGoStackTrace {\n\t\t\t\t\tbuf := make([]byte, 4096)\n\t\t\t\t\truntime.Stack(buf, false)\n\t\t\t\t\terr.(*ApiError).StackTrace = strings.Trim(string(buf), \"\\000\") + \"\\n\" + ls.stackTrace(0)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = rcv.(*ApiError)\n\t\t\t}\n\t\t\tif errfunc != nil {\n\t\t\t\tls.Push(errfunc)\n\t\t\t\tls.Push(err.(*ApiError).Object)\n\t\t\t\tls.Panic = panicWithoutTraceback\n\t\t\t\tdefer func() {\n\t\t\t\t\tls.Panic = oldpanic\n\t\t\t\t\trcv := recover()\n\t\t\t\t\tif rcv != nil {\n\t\t\t\t\t\tif _, ok := rcv.(*ApiError); !ok {\n\t\t\t\t\t\t\terr = newApiErrorS(ApiErrorPanic, fmt.Sprint(rcv))\n\t\t\t\t\t\t\tif ls.Options.IncludeGoStackTrace {\n\t\t\t\t\t\t\t\tbuf := make([]byte, 4096)\n\t\t\t\t\t\t\t\truntime.Stack(buf, false)\n\t\t\t\t\t\t\t\terr.(*ApiError).StackTrace = strings.Trim(string(buf), \"\\000\") + ls.stackTrace(0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = rcv.(*ApiError)\n\t\t\t\t\t\t\terr.(*ApiError).StackTrace = ls.stackTrace(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tls.stack.SetSp(sp)\n\t\t\t\t\t\tls.currentFrame = ls.stack.Last()\n\t\t\t\t\t\tls.reg.SetTop(base)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tls.Call(1, 1)\n\t\t\t\terr = newApiError(ApiErrorError, ls.Get(-1))\n\t\t\t} else if len(err.(*ApiError).StackTrace) == 0 {\n\t\t\t\terr.(*ApiError).StackTrace = ls.stackTrace(0)\n\t\t\t}\n\t\t\tls.stack.SetSp(sp)\n\t\t\tls.currentFrame = ls.stack.Last()\n\t\t\tls.reg.SetTop(base)\n\t\t}\n\t\tls.stack.SetSp(sp)\n\t\tif sp == 0 {\n\t\t\tls.currentFrame = nil\n\t\t}\n\t}()\n\n\tls.Call(nargs, nret)\n\n\treturn\n}\n\nfunc (ls *LState) GPCall(fn LGFunction, data LValue) error {\n\tls.Push(newLFunctionG(fn, ls.currentEnv(), 0))\n\tls.Push(data)\n\treturn ls.PCall(1, MultRet, nil)\n}\n\nfunc (ls *LState) CallByParam(cp P, args ...LValue) error {\n\tls.Push(cp.Fn)\n\tfor _, arg := range args {\n\t\tls.Push(arg)\n\t}\n\n\tif cp.Protect {\n\t\treturn ls.PCall(len(args), cp.NRet, cp.Handler)\n\t}\n\tls.Call(len(args), cp.NRet)\n\treturn nil\n}\n\n/* }}} */\n\n/* metatable operations {{{ */\n\nfunc (ls *LState) GetMetatable(obj LValue) LValue {\n\treturn ls.metatable(obj, false)\n}\n\nfunc (ls *LState) SetMetatable(obj LValue, mt LValue) {\n\tswitch mt.(type) {\n\tcase *LNilType, *LTable:\n\tdefault:\n\t\tls.RaiseError(\"metatable must be a table or nil, but got %v\", mt.Type().String())\n\t}\n\n\tswitch v := obj.(type) {\n\tcase *LTable:\n\t\tv.Metatable = mt\n\tcase *LUserData:\n\t\tv.Metatable = mt\n\tdefault:\n\t\tls.G.builtinMts[int(obj.Type())] = mt\n\t}\n}\n\n/* }}} */\n\n/* coroutine operations {{{ */\n\nfunc (ls *LState) Status(th *LState) string {\n\tstatus := \"suspended\"\n\tif th.Dead {\n\t\tstatus = \"dead\"\n\t} else if ls.G.CurrentThread == th {\n\t\tstatus = \"running\"\n\t} else if ls.Parent == th {\n\t\tstatus = \"normal\"\n\t}\n\treturn status\n}\n\nfunc (ls *LState) Resume(th *LState, fn *LFunction, args ...LValue) (ResumeState, error, []LValue) {\n\tisstarted := th.isStarted()\n\tif !isstarted {\n\t\tbase := 0\n\t\tth.stack.Push(callFrame{\n\t\t\tFn:         fn,\n\t\t\tPc:         0,\n\t\t\tBase:       base,\n\t\t\tLocalBase:  base + 1,\n\t\t\tReturnBase: base,\n\t\t\tNArgs:      0,\n\t\t\tNRet:       MultRet,\n\t\t\tParent:     nil,\n\t\t\tTailCall:   0,\n\t\t})\n\t}\n\n\tif ls.G.CurrentThread == th {\n\t\treturn ResumeError, newApiErrorS(ApiErrorRun, \"can not resume a running thread\"), nil\n\t}\n\tif th.Dead {\n\t\treturn ResumeError, newApiErrorS(ApiErrorRun, \"can not resume a dead thread\"), nil\n\t}\n\tth.Parent = ls\n\tls.G.CurrentThread = th\n\tif !isstarted {\n\t\tcf := th.stack.Last()\n\t\tth.currentFrame = cf\n\t\tth.SetTop(0)\n\t\tfor _, arg := range args {\n\t\t\tth.Push(arg)\n\t\t}\n\t\tcf.NArgs = len(args)\n\t\tth.initCallFrame(cf)\n\t\tth.Panic = panicWithoutTraceback\n\t} else {\n\t\tfor _, arg := range args {\n\t\t\tth.Push(arg)\n\t\t}\n\t}\n\ttop := ls.GetTop()\n\tthreadRun(th)\n\thaserror := LVIsFalse(ls.Get(top + 1))\n\tret := make([]LValue, 0, ls.GetTop())\n\tfor idx := top + 2; idx <= ls.GetTop(); idx++ {\n\t\tret = append(ret, ls.Get(idx))\n\t}\n\tif len(ret) == 0 {\n\t\tret = append(ret, LNil)\n\t}\n\tls.SetTop(top)\n\n\tif haserror {\n\t\treturn ResumeError, newApiError(ApiErrorRun, ret[0]), nil\n\t} else if th.stack.IsEmpty() {\n\t\treturn ResumeOK, nil, ret\n\t}\n\treturn ResumeYield, nil, ret\n}\n\nfunc (ls *LState) Yield(values ...LValue) int {\n\tls.SetTop(0)\n\tfor _, lv := range values {\n\t\tls.Push(lv)\n\t}\n\treturn -1\n}\n\nfunc (ls *LState) XMoveTo(other *LState, n int) {\n\tif ls == other {\n\t\treturn\n\t}\n\ttop := ls.GetTop()\n\tn = intMin(n, top)\n\tfor i := n; i > 0; i-- {\n\t\tother.Push(ls.Get(top - i + 1))\n\t}\n\tls.SetTop(top - n)\n}\n\n/* }}} */\n\n/* GopherLua original APIs {{{ */\n\n// Set maximum memory size. This function can only be called from the main thread.\nfunc (ls *LState) SetMx(mx int) {\n\tif ls.Parent != nil {\n\t\tls.RaiseError(\"sub threads are not allowed to set a memory limit\")\n\t}\n\tgo func() {\n\t\tlimit := uint64(mx * 1024 * 1024) //MB\n\t\tvar s runtime.MemStats\n\t\tfor atomic.LoadInt32(&ls.stop) == 0 {\n\t\t\truntime.ReadMemStats(&s)\n\t\t\tif s.Alloc >= limit {\n\t\t\t\tfmt.Println(\"out of memory\")\n\t\t\t\tos.Exit(3)\n\t\t\t}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n}\n\n// SetContext set a context ctx to this LState. The provided ctx must be non-nil.\nfunc (ls *LState) SetContext(ctx context.Context) {\n\tls.mainLoop = mainLoopWithContext\n\tls.ctx = ctx\n}\n\n// Context returns the LState's context. To change the context, use WithContext.\nfunc (ls *LState) Context() context.Context {\n\treturn ls.ctx\n}\n\n// RemoveContext removes the context associated with this LState and returns this context.\nfunc (ls *LState) RemoveContext() context.Context {\n\toldctx := ls.ctx\n\tls.mainLoop = mainLoop\n\tls.ctx = nil\n\treturn oldctx\n}\n\n// Converts the Lua value at the given acceptable index to the chan LValue.\nfunc (ls *LState) ToChannel(n int) chan LValue {\n\tif lv, ok := ls.Get(n).(LChannel); ok {\n\t\treturn (chan LValue)(lv)\n\t}\n\treturn nil\n}\n\n// RemoveCallerFrame removes the stack frame above the current stack frame. This is useful in tail calls. It returns\n// the new current frame.\nfunc (ls *LState) RemoveCallerFrame() *callFrame {\n\tcs := ls.stack\n\tsp := cs.Sp()\n\tparentFrame := cs.At(sp - 2)\n\tcurrentFrame := cs.At(sp - 1)\n\tparentsParentFrame := parentFrame.Parent\n\t*parentFrame = *currentFrame\n\tparentFrame.Parent = parentsParentFrame\n\tparentFrame.Idx = sp - 2\n\tcs.Pop()\n\treturn parentFrame\n}\n\n/* }}} */\n\n/* }}} */\n\n//\n"
        },
        {
          "name": "state_test.go",
          "type": "blob",
          "size": 19.30078125,
          "content": "package lua\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLStateIsClosed(t *testing.T) {\n\tL := NewState()\n\tL.Close()\n\terrorIfNotEqual(t, true, L.IsClosed())\n}\n\nfunc TestCallStackOverflowWhenFixed(t *testing.T) {\n\tL := NewState(Options{\n\t\tCallStackSize: 3,\n\t})\n\tdefer L.Close()\n\n\t// expect fixed stack implementation by default (for backwards compatibility)\n\tstack := L.stack\n\tif _, ok := stack.(*fixedCallFrameStack); !ok {\n\t\tt.Errorf(\"expected fixed callframe stack by default\")\n\t}\n\n\terrorIfScriptNotFail(t, L, `\n    local function recurse(count)\n      if count > 0 then\n        recurse(count - 1)\n      end\n    end\n    local function c()\n      print(_printregs())\n      recurse(9)\n    end\n    c()\n    `, \"stack overflow\")\n}\n\nfunc TestCallStackOverflowWhenAutoGrow(t *testing.T) {\n\tL := NewState(Options{\n\t\tCallStackSize:       3,\n\t\tMinimizeStackMemory: true,\n\t})\n\tdefer L.Close()\n\n\t// expect auto growing stack implementation when MinimizeStackMemory is set\n\tstack := L.stack\n\tif _, ok := stack.(*autoGrowingCallFrameStack); !ok {\n\t\tt.Errorf(\"expected fixed callframe stack by default\")\n\t}\n\n\terrorIfScriptNotFail(t, L, `\n    local function recurse(count)\n      if count > 0 then\n        recurse(count - 1)\n      end\n    end\n    local function c()\n      print(_printregs())\n      recurse(9)\n    end\n    c()\n    `, \"stack overflow\")\n}\n\nfunc TestSkipOpenLibs(t *testing.T) {\n\tL := NewState(Options{SkipOpenLibs: true})\n\tdefer L.Close()\n\terrorIfScriptNotFail(t, L, `print(\"\")`,\n\t\t\"attempt to call a non-function object\")\n\tL2 := NewState()\n\tdefer L2.Close()\n\terrorIfScriptFail(t, L2, `print(\"\")`)\n}\n\nfunc TestGetAndReplace(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LString(\"a\"))\n\tL.Replace(1, LString(\"b\"))\n\tL.Replace(0, LString(\"c\"))\n\terrorIfNotEqual(t, LNil, L.Get(0))\n\terrorIfNotEqual(t, LNil, L.Get(-10))\n\terrorIfNotEqual(t, L.Env, L.Get(EnvironIndex))\n\terrorIfNotEqual(t, LString(\"b\"), L.Get(1))\n\tL.Push(LString(\"c\"))\n\tL.Push(LString(\"d\"))\n\tL.Replace(-2, LString(\"e\"))\n\terrorIfNotEqual(t, LString(\"e\"), L.Get(-2))\n\tregistry := L.NewTable()\n\tL.Replace(RegistryIndex, registry)\n\tL.G.Registry = registry\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Replace(RegistryIndex, LNil)\n\t\treturn 0\n\t}, \"registry must be a table\")\n\terrorIfGFuncFail(t, L, func(L *LState) int {\n\t\tenv := L.NewTable()\n\t\tL.Replace(EnvironIndex, env)\n\t\terrorIfNotEqual(t, env, L.Get(EnvironIndex))\n\t\treturn 0\n\t})\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Replace(EnvironIndex, LNil)\n\t\treturn 0\n\t}, \"environment must be a table\")\n\terrorIfGFuncFail(t, L, func(L *LState) int {\n\t\tgbl := L.NewTable()\n\t\tL.Replace(GlobalsIndex, gbl)\n\t\terrorIfNotEqual(t, gbl, L.G.Global)\n\t\treturn 0\n\t})\n\terrorIfGFuncNotFail(t, L, func(L *LState) int {\n\t\tL.Replace(GlobalsIndex, LNil)\n\t\treturn 0\n\t}, \"_G must be a table\")\n\n\tL2 := NewState()\n\tdefer L2.Close()\n\tclo := L2.NewClosure(func(L2 *LState) int {\n\t\tL2.Replace(UpvalueIndex(1), LNumber(3))\n\t\terrorIfNotEqual(t, LNumber(3), L2.Get(UpvalueIndex(1)))\n\t\treturn 0\n\t}, LNumber(1), LNumber(2))\n\tL2.SetGlobal(\"clo\", clo)\n\terrorIfScriptFail(t, L2, `clo()`)\n}\n\nfunc TestRemove(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LString(\"a\"))\n\tL.Push(LString(\"b\"))\n\tL.Push(LString(\"c\"))\n\n\tL.Remove(4)\n\terrorIfNotEqual(t, LString(\"a\"), L.Get(1))\n\terrorIfNotEqual(t, LString(\"b\"), L.Get(2))\n\terrorIfNotEqual(t, LString(\"c\"), L.Get(3))\n\terrorIfNotEqual(t, 3, L.GetTop())\n\n\tL.Remove(3)\n\terrorIfNotEqual(t, LString(\"a\"), L.Get(1))\n\terrorIfNotEqual(t, LString(\"b\"), L.Get(2))\n\terrorIfNotEqual(t, LNil, L.Get(3))\n\terrorIfNotEqual(t, 2, L.GetTop())\n\tL.Push(LString(\"c\"))\n\n\tL.Remove(-10)\n\terrorIfNotEqual(t, LString(\"a\"), L.Get(1))\n\terrorIfNotEqual(t, LString(\"b\"), L.Get(2))\n\terrorIfNotEqual(t, LString(\"c\"), L.Get(3))\n\terrorIfNotEqual(t, 3, L.GetTop())\n\n\tL.Remove(2)\n\terrorIfNotEqual(t, LString(\"a\"), L.Get(1))\n\terrorIfNotEqual(t, LString(\"c\"), L.Get(2))\n\terrorIfNotEqual(t, LNil, L.Get(3))\n\terrorIfNotEqual(t, 2, L.GetTop())\n}\n\nfunc TestToInt(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewTable())\n\terrorIfNotEqual(t, 10, L.ToInt(1))\n\terrorIfNotEqual(t, 99, L.ToInt(2))\n\terrorIfNotEqual(t, 0, L.ToInt(3))\n}\n\nfunc TestToInt64(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewTable())\n\terrorIfNotEqual(t, int64(10), L.ToInt64(1))\n\terrorIfNotEqual(t, int64(99), L.ToInt64(2))\n\terrorIfNotEqual(t, int64(0), L.ToInt64(3))\n}\n\nfunc TestToNumber(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewTable())\n\terrorIfNotEqual(t, LNumber(10), L.ToNumber(1))\n\terrorIfNotEqual(t, LNumber(99.9), L.ToNumber(2))\n\terrorIfNotEqual(t, LNumber(0), L.ToNumber(3))\n}\n\nfunc TestToString(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewTable())\n\terrorIfNotEqual(t, \"10\", L.ToString(1))\n\terrorIfNotEqual(t, \"99.9\", L.ToString(2))\n\terrorIfNotEqual(t, \"\", L.ToString(3))\n}\n\nfunc TestToTable(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewTable())\n\terrorIfFalse(t, L.ToTable(1) == nil, \"index 1 must be nil\")\n\terrorIfFalse(t, L.ToTable(2) == nil, \"index 2 must be nil\")\n\terrorIfNotEqual(t, L.Get(3), L.ToTable(3))\n}\n\nfunc TestToFunction(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewFunction(func(L *LState) int { return 0 }))\n\terrorIfFalse(t, L.ToFunction(1) == nil, \"index 1 must be nil\")\n\terrorIfFalse(t, L.ToFunction(2) == nil, \"index 2 must be nil\")\n\terrorIfNotEqual(t, L.Get(3), L.ToFunction(3))\n}\n\nfunc TestToUserData(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tL.Push(L.NewUserData())\n\terrorIfFalse(t, L.ToUserData(1) == nil, \"index 1 must be nil\")\n\terrorIfFalse(t, L.ToUserData(2) == nil, \"index 2 must be nil\")\n\terrorIfNotEqual(t, L.Get(3), L.ToUserData(3))\n}\n\nfunc TestToChannel(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Push(LNumber(10))\n\tL.Push(LString(\"99.9\"))\n\tvar ch chan LValue\n\tL.Push(LChannel(ch))\n\terrorIfFalse(t, L.ToChannel(1) == nil, \"index 1 must be nil\")\n\terrorIfFalse(t, L.ToChannel(2) == nil, \"index 2 must be nil\")\n\terrorIfNotEqual(t, ch, L.ToChannel(3))\n}\n\nfunc TestObjLen(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfNotEqual(t, 3, L.ObjLen(LString(\"abc\")))\n\ttbl := L.NewTable()\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\terrorIfNotEqual(t, 2, L.ObjLen(tbl))\n\tmt := L.NewTable()\n\tL.SetField(mt, \"__len\", L.NewFunction(func(L *LState) int {\n\t\ttbl := L.CheckTable(1)\n\t\tL.Push(LNumber(tbl.Len() + 1))\n\t\treturn 1\n\t}))\n\tL.SetMetatable(tbl, mt)\n\terrorIfNotEqual(t, 3, L.ObjLen(tbl))\n\terrorIfNotEqual(t, 0, L.ObjLen(LNumber(10)))\n}\n\nfunc TestConcat(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrorIfNotEqual(t, \"a1c\", L.Concat(LString(\"a\"), LNumber(1), LString(\"c\")))\n}\n\nfunc TestPCall(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tL.Register(\"f1\", func(L *LState) int {\n\t\tpanic(\"panic!\")\n\t\treturn 0\n\t})\n\terrorIfScriptNotFail(t, L, `f1()`, \"panic!\")\n\tL.Push(L.GetGlobal(\"f1\"))\n\terr := L.PCall(0, 0, L.NewFunction(func(L *LState) int {\n\t\tL.Push(LString(\"by handler\"))\n\t\treturn 1\n\t}))\n\terrorIfFalse(t, strings.Contains(err.Error(), \"by handler\"), \"\")\n\n\tL.Push(L.GetGlobal(\"f1\"))\n\terr = L.PCall(0, 0, L.NewFunction(func(L *LState) int {\n\t\tL.RaiseError(\"error!\")\n\t\treturn 1\n\t}))\n\terrorIfFalse(t, strings.Contains(err.Error(), \"error!\"), \"\")\n\n\tL.Push(L.GetGlobal(\"f1\"))\n\terr = L.PCall(0, 0, L.NewFunction(func(L *LState) int {\n\t\tpanic(\"panicc!\")\n\t\treturn 1\n\t}))\n\terrorIfFalse(t, strings.Contains(err.Error(), \"panicc!\"), \"\")\n\n\t// Issue #452, expected to be revert back to previous call stack after any error.\n\tcurrentFrame, currentTop, currentSp := L.currentFrame, L.GetTop(), L.stack.Sp()\n\tL.Push(L.GetGlobal(\"f1\"))\n\terr = L.PCall(0, 0, nil)\n\terrorIfFalse(t, err != nil, \"\")\n\terrorIfFalse(t, L.currentFrame == currentFrame, \"\")\n\terrorIfFalse(t, L.GetTop() == currentTop, \"\")\n\terrorIfFalse(t, L.stack.Sp() == currentSp, \"\")\n\n\tcurrentFrame, currentTop, currentSp = L.currentFrame, L.GetTop(), L.stack.Sp()\n\tL.Push(L.GetGlobal(\"f1\"))\n\terr = L.PCall(0, 0, L.NewFunction(func(L *LState) int {\n\t\tL.RaiseError(\"error!\")\n\t\treturn 1\n\t}))\n\terrorIfFalse(t, err != nil, \"\")\n\terrorIfFalse(t, L.currentFrame == currentFrame, \"\")\n\terrorIfFalse(t, L.GetTop() == currentTop, \"\")\n\terrorIfFalse(t, L.stack.Sp() == currentSp, \"\")\n}\n\nfunc TestCoroutineApi1(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tco, _ := L.NewThread()\n\terrorIfScriptFail(t, L, `\n      function coro(v)\n        assert(v == 10)\n        local ret1, ret2 = coroutine.yield(1,2,3)\n        assert(ret1 == 11)\n        assert(ret2 == 12)\n        coroutine.yield(4)\n        return 5\n      end\n    `)\n\tfn := L.GetGlobal(\"coro\").(*LFunction)\n\tst, err, values := L.Resume(co, fn, LNumber(10))\n\terrorIfNotEqual(t, ResumeYield, st)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, 3, len(values))\n\terrorIfNotEqual(t, LNumber(1), values[0].(LNumber))\n\terrorIfNotEqual(t, LNumber(2), values[1].(LNumber))\n\terrorIfNotEqual(t, LNumber(3), values[2].(LNumber))\n\n\tst, err, values = L.Resume(co, fn, LNumber(11), LNumber(12))\n\terrorIfNotEqual(t, ResumeYield, st)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, 1, len(values))\n\terrorIfNotEqual(t, LNumber(4), values[0].(LNumber))\n\n\tst, err, values = L.Resume(co, fn)\n\terrorIfNotEqual(t, ResumeOK, st)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, 1, len(values))\n\terrorIfNotEqual(t, LNumber(5), values[0].(LNumber))\n\n\tL.Register(\"myyield\", func(L *LState) int {\n\t\treturn L.Yield(L.ToNumber(1))\n\t})\n\terrorIfScriptFail(t, L, `\n      function coro_error()\n        coroutine.yield(1,2,3)\n        myyield(4)\n        assert(false, \"--failed--\")\n      end\n    `)\n\tfn = L.GetGlobal(\"coro_error\").(*LFunction)\n\tco, _ = L.NewThread()\n\tst, err, values = L.Resume(co, fn)\n\terrorIfNotEqual(t, ResumeYield, st)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, 3, len(values))\n\terrorIfNotEqual(t, LNumber(1), values[0].(LNumber))\n\terrorIfNotEqual(t, LNumber(2), values[1].(LNumber))\n\terrorIfNotEqual(t, LNumber(3), values[2].(LNumber))\n\n\tst, err, values = L.Resume(co, fn)\n\terrorIfNotEqual(t, ResumeYield, st)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, 1, len(values))\n\terrorIfNotEqual(t, LNumber(4), values[0].(LNumber))\n\n\tst, err, values = L.Resume(co, fn)\n\terrorIfNotEqual(t, ResumeError, st)\n\terrorIfNil(t, err)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"--failed--\"), \"error message must be '--failed--'\")\n\tst, err, values = L.Resume(co, fn)\n\terrorIfNotEqual(t, ResumeError, st)\n\terrorIfNil(t, err)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"can not resume a dead thread\"), \"can not resume a dead thread\")\n\n}\n\nfunc TestContextTimeout(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n\tdefer cancel()\n\tL.SetContext(ctx)\n\terrorIfNotEqual(t, ctx, L.Context())\n\terr := L.DoString(`\n\t  local clock = os.clock\n      function sleep(n)  -- seconds\n        local t0 = clock()\n        while clock() - t0 <= n do end\n      end\n\t  sleep(3)\n\t`)\n\terrorIfNil(t, err)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"context deadline exceeded\"), \"execution must be canceled\")\n\n\toldctx := L.RemoveContext()\n\terrorIfNotEqual(t, ctx, oldctx)\n\terrorIfNotNil(t, L.ctx)\n}\n\nfunc TestContextCancel(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tctx, cancel := context.WithCancel(context.Background())\n\terrch := make(chan error, 1)\n\tL.SetContext(ctx)\n\tgo func() {\n\t\terrch <- L.DoString(`\n\t    local clock = os.clock\n        function sleep(n)  -- seconds\n          local t0 = clock()\n          while clock() - t0 <= n do end\n        end\n\t    sleep(3)\n\t  `)\n\t}()\n\ttime.Sleep(1 * time.Second)\n\tcancel()\n\terr := <-errch\n\terrorIfNil(t, err)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"context canceled\"), \"execution must be canceled\")\n}\n\nfunc TestContextWithCroutine(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\tctx, cancel := context.WithCancel(context.Background())\n\tL.SetContext(ctx)\n\tdefer cancel()\n\tL.DoString(`\n\t    function coro()\n\t\t  local i = 0\n\t\t  while true do\n\t\t    coroutine.yield(i)\n\t\t\ti = i+1\n\t\t  end\n\t\t  return i\n\t    end\n\t`)\n\tco, cocancel := L.NewThread()\n\tdefer cocancel()\n\tfn := L.GetGlobal(\"coro\").(*LFunction)\n\t_, err, values := L.Resume(co, fn)\n\terrorIfNotNil(t, err)\n\terrorIfNotEqual(t, LNumber(0), values[0])\n\t// cancel the parent context\n\tcancel()\n\t_, err, values = L.Resume(co, fn)\n\terrorIfNil(t, err)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"context canceled\"), \"coroutine execution must be canceled when the parent context is canceled\")\n\n}\n\nfunc TestPCallAfterFail(t *testing.T) {\n\tL := NewState()\n\tdefer L.Close()\n\terrFn := L.NewFunction(func(L *LState) int {\n\t\tL.RaiseError(\"error!\")\n\t\treturn 0\n\t})\n\tchangeError := L.NewFunction(func(L *LState) int {\n\t\tL.Push(errFn)\n\t\terr := L.PCall(0, 0, nil)\n\t\tif err != nil {\n\t\t\tL.RaiseError(\"A New Error\")\n\t\t}\n\t\treturn 0\n\t})\n\tL.Push(changeError)\n\terr := L.PCall(0, 0, nil)\n\terrorIfFalse(t, strings.Contains(err.Error(), \"A New Error\"), \"error not propogated correctly\")\n}\n\nfunc TestRegistryFixedOverflow(t *testing.T) {\n\tstate := NewState()\n\tdefer state.Close()\n\treg := state.reg\n\texpectedPanic := false\n\t// should be non auto grow by default\n\terrorIfFalse(t, reg.maxSize == 0, \"state should default to non-auto growing implementation\")\n\t// fill the stack and check we get a panic\n\ttest := LString(\"test\")\n\tfor i := 0; i < len(reg.array); i++ {\n\t\treg.Push(test)\n\t}\n\tdefer func() {\n\t\trcv := recover()\n\t\tif rcv != nil {\n\t\t\tif expectedPanic {\n\t\t\t\terrorIfFalse(t, rcv.(error).Error() != \"registry overflow\", \"expected registry overflow exception, got \"+rcv.(error).Error())\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"did not expect registry overflow\")\n\t\t\t}\n\t\t} else if expectedPanic {\n\t\t\tt.Errorf(\"expected registry overflow exception, but didn't get panic\")\n\t\t}\n\t}()\n\texpectedPanic = true\n\treg.Push(test)\n}\n\nfunc TestRegistryAutoGrow(t *testing.T) {\n\tstate := NewState(Options{RegistryMaxSize: 300, RegistrySize: 200, RegistryGrowStep: 25})\n\tdefer state.Close()\n\texpectedPanic := false\n\tdefer func() {\n\t\trcv := recover()\n\t\tif rcv != nil {\n\t\t\tif expectedPanic {\n\t\t\t\terrorIfFalse(t, rcv.(error).Error() != \"registry overflow\", \"expected registry overflow exception, got \"+rcv.(error).Error())\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"did not expect registry overflow\")\n\t\t\t}\n\t\t} else if expectedPanic {\n\t\t\tt.Errorf(\"expected registry overflow exception, but didn't get panic\")\n\t\t}\n\t}()\n\treg := state.reg\n\ttest := LString(\"test\")\n\tfor i := 0; i < 300; i++ {\n\t\treg.Push(test)\n\t}\n\texpectedPanic = true\n\treg.Push(test)\n}\n\n// This test exposed a panic caused by accessing an unassigned var in the lua registry.\n// The panic was caused by initCallFrame. It was calling resize() on the registry after it had written some values\n// directly to the reg's array, but crucially, before it had updated \"top\". This meant when the resize occurred, the\n// values beyond top where not copied, and were lost, leading to a later uninitialised value being found in the registry.\nfunc TestUninitializedVarAccess(t *testing.T) {\n\tL := NewState(Options{\n\t\tRegistrySize:    128,\n\t\tRegistryMaxSize: 256,\n\t})\n\tdefer L.Close()\n\t// This test needs to trigger a resize when the local vars are allocated, so we need it to\n\t// be 128 for the padding amount in the test function to work. If it's larger, we will need\n\t// more padding to force the error.\n\terrorIfNotEqual(t, cap(L.reg.array), 128)\n\tctx, cancel := context.WithCancel(context.Background())\n\tL.SetContext(ctx)\n\tdefer cancel()\n\terrorIfScriptFail(t, L, `\n\t\tlocal function test(arg1, arg2, arg3)\n\t\t\t-- padding to cause a registry resize when the local vars for this func are reserved\n\t\t\tlocal a0,b0,c0,d0,e0,f0,g0,h0,i0,j0,k0,l0,m0,n0,o0,p0,q0,r0,s0,t0,u0,v0,w0,x0,y0,z0\n\t\t\tlocal a1,b1,c1,d1,e1,f1,g1,h1,i1,j1,k1,l1,m1,n1,o1,p1,q1,r1,s1,t1,u1,v1,w1,x1,y1,z1\n\t\t\tlocal a2,b2,c2,d2,e2,f2,g2,h2,i2,j2,k2,l2,m2,n2,o2,p2,q2,r2,s2,t2,u2,v2,w2,x2,y2,z2\n\t\t\tlocal a3,b3,c3,d3,e3,f3,g3,h3,i3,j3,k3,l3,m3,n3,o3,p3,q3,r3,s3,t3,u3,v3,w3,x3,y3,z3\n\t\t\tlocal a4,b4,c4,d4,e4,f4,g4,h4,i4,j4,k4,l4,m4,n4,o4,p4,q4,r4,s4,t4,u4,v4,w4,x4,y4,z4\n\t\t\tif arg3 == nil then\n\t\t\t\treturn 1\n\t\t\tend\n\t\t\treturn 0\n\t\tend\n\n\t\ttest(1,2)\n\t`)\n}\n\nfunc BenchmarkCallFrameStackPushPopAutoGrow(t *testing.B) {\n\tstack := newAutoGrowingCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkCallFrameStackPushPopFixed(t *testing.B) {\n\tstack := newFixedCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Pop()\n\t\t}\n\t}\n}\n\n// this test will intentionally not incur stack growth in order to bench the performance when no allocations happen\nfunc BenchmarkCallFrameStackPushPopShallowAutoGrow(t *testing.B) {\n\tstack := newAutoGrowingCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 8\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkCallFrameStackPushPopShallowFixed(t *testing.B) {\n\tstack := newFixedCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 8\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkCallFrameStackPushPopFixedNoInterface(t *testing.B) {\n\tstack := newFixedCallFrameStack(256).(*fixedCallFrameStack)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkCallFrameStackUnwindAutoGrow(t *testing.B) {\n\tstack := newAutoGrowingCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tstack.SetSp(0)\n\t}\n}\n\nfunc BenchmarkCallFrameStackUnwindFixed(t *testing.B) {\n\tstack := newFixedCallFrameStack(256)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tstack.SetSp(0)\n\t}\n}\n\nfunc BenchmarkCallFrameStackUnwindFixedNoInterface(t *testing.B) {\n\tstack := newFixedCallFrameStack(256).(*fixedCallFrameStack)\n\n\tt.ResetTimer()\n\n\tconst Iterations = 256\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < Iterations; i++ {\n\t\t\tstack.Push(callFrame{})\n\t\t}\n\t\tstack.SetSp(0)\n\t}\n}\n\ntype registryTestHandler int\n\nfunc (registryTestHandler) registryOverflow() {\n\tpanic(\"registry overflow\")\n}\n\n// test pushing and popping from the registry\nfunc BenchmarkRegistryPushPopAutoGrow(t *testing.B) {\n\tal := newAllocator(32)\n\tsz := 256 * 20\n\treg := newRegistry(registryTestHandler(0), sz/2, 64, sz, al)\n\tvalue := LString(\"test\")\n\n\tt.ResetTimer()\n\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < sz; i++ {\n\t\t\treg.Push(value)\n\t\t}\n\t\tfor i := 0; i < sz; i++ {\n\t\t\treg.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkRegistryPushPopFixed(t *testing.B) {\n\tal := newAllocator(32)\n\tsz := 256 * 20\n\treg := newRegistry(registryTestHandler(0), sz, 0, sz, al)\n\tvalue := LString(\"test\")\n\n\tt.ResetTimer()\n\n\tfor j := 0; j < t.N; j++ {\n\t\tfor i := 0; i < sz; i++ {\n\t\t\treg.Push(value)\n\t\t}\n\t\tfor i := 0; i < sz; i++ {\n\t\t\treg.Pop()\n\t\t}\n\t}\n}\n\nfunc BenchmarkRegistrySetTop(t *testing.B) {\n\tal := newAllocator(32)\n\tsz := 256 * 20\n\treg := newRegistry(registryTestHandler(0), sz, 32, sz*2, al)\n\n\tt.ResetTimer()\n\n\tfor j := 0; j < t.N; j++ {\n\t\treg.SetTop(sz)\n\t\treg.SetTop(0)\n\t}\n}\n"
        },
        {
          "name": "stringlib.go",
          "type": "blob",
          "size": 9.384765625,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/yuin/gopher-lua/pm\"\n)\n\nconst emptyLString LString = LString(\"\")\n\nfunc OpenString(L *LState) int {\n\tvar mod *LTable\n\t//_, ok := L.G.builtinMts[int(LTString)]\n\t//if !ok {\n\tmod = L.RegisterModule(StringLibName, strFuncs).(*LTable)\n\tgmatch := L.NewClosure(strGmatch, L.NewFunction(strGmatchIter))\n\tmod.RawSetString(\"gmatch\", gmatch)\n\tmod.RawSetString(\"gfind\", gmatch)\n\tmod.RawSetString(\"__index\", mod)\n\tL.G.builtinMts[int(LTString)] = mod\n\t//}\n\tL.Push(mod)\n\treturn 1\n}\n\nvar strFuncs = map[string]LGFunction{\n\t\"byte\":    strByte,\n\t\"char\":    strChar,\n\t\"dump\":    strDump,\n\t\"find\":    strFind,\n\t\"format\":  strFormat,\n\t\"gsub\":    strGsub,\n\t\"len\":     strLen,\n\t\"lower\":   strLower,\n\t\"match\":   strMatch,\n\t\"rep\":     strRep,\n\t\"reverse\": strReverse,\n\t\"sub\":     strSub,\n\t\"upper\":   strUpper,\n}\n\nfunc strByte(L *LState) int {\n\tstr := L.CheckString(1)\n\tstart := L.OptInt(2, 1) - 1\n\tend := L.OptInt(3, -1)\n\tl := len(str)\n\tif start < 0 {\n\t\tstart = l + start + 1\n\t}\n\tif end < 0 {\n\t\tend = l + end + 1\n\t}\n\n\tif L.GetTop() == 2 {\n\t\tif start < 0 || start >= l {\n\t\t\treturn 0\n\t\t}\n\t\tL.Push(LNumber(str[start]))\n\t\treturn 1\n\t}\n\n\tstart = intMax(start, 0)\n\tend = intMin(end, l)\n\tif end < 0 || end <= start || start >= l {\n\t\treturn 0\n\t}\n\n\tfor i := start; i < end; i++ {\n\t\tL.Push(LNumber(str[i]))\n\t}\n\treturn end - start\n}\n\nfunc strChar(L *LState) int {\n\ttop := L.GetTop()\n\tbytes := make([]byte, L.GetTop())\n\tfor i := 1; i <= top; i++ {\n\t\tbytes[i-1] = uint8(L.CheckInt(i))\n\t}\n\tL.Push(LString(string(bytes)))\n\treturn 1\n}\n\nfunc strDump(L *LState) int {\n\tL.RaiseError(\"GopherLua does not support the string.dump\")\n\treturn 0\n}\n\nfunc strFind(L *LState) int {\n\tstr := L.CheckString(1)\n\tpattern := L.CheckString(2)\n\tif len(pattern) == 0 {\n\t\tL.Push(LNumber(1))\n\t\tL.Push(LNumber(0))\n\t\treturn 2\n\t}\n\tinit := luaIndex2StringIndex(str, L.OptInt(3, 1), true)\n\tplain := false\n\tif L.GetTop() == 4 {\n\t\tplain = LVAsBool(L.Get(4))\n\t}\n\n\tif plain {\n\t\tpos := strings.Index(str[init:], pattern)\n\t\tif pos < 0 {\n\t\t\tL.Push(LNil)\n\t\t\treturn 1\n\t\t}\n\t\tL.Push(LNumber(init+pos) + 1)\n\t\tL.Push(LNumber(init + pos + len(pattern)))\n\t\treturn 2\n\t}\n\n\tmds, err := pm.Find(pattern, unsafeFastStringToReadOnlyBytes(str), init, 1)\n\tif err != nil {\n\t\tL.RaiseError(err.Error())\n\t}\n\tif len(mds) == 0 {\n\t\tL.Push(LNil)\n\t\treturn 1\n\t}\n\tmd := mds[0]\n\tL.Push(LNumber(md.Capture(0) + 1))\n\tL.Push(LNumber(md.Capture(1)))\n\tfor i := 2; i < md.CaptureLength(); i += 2 {\n\t\tif md.IsPosCapture(i) {\n\t\t\tL.Push(LNumber(md.Capture(i)))\n\t\t} else {\n\t\t\tL.Push(LString(str[md.Capture(i):md.Capture(i+1)]))\n\t\t}\n\t}\n\treturn md.CaptureLength()/2 + 1\n}\n\nfunc strFormat(L *LState) int {\n\tstr := L.CheckString(1)\n\targs := make([]interface{}, L.GetTop()-1)\n\ttop := L.GetTop()\n\tfor i := 2; i <= top; i++ {\n\t\targs[i-2] = L.Get(i)\n\t}\n\tnpat := strings.Count(str, \"%\") - strings.Count(str, \"%%\")\n\tL.Push(LString(fmt.Sprintf(str, args[:intMin(npat, len(args))]...)))\n\treturn 1\n}\n\nfunc strGsub(L *LState) int {\n\tstr := L.CheckString(1)\n\tpat := L.CheckString(2)\n\tL.CheckTypes(3, LTString, LTTable, LTFunction)\n\trepl := L.CheckAny(3)\n\tlimit := L.OptInt(4, -1)\n\n\tmds, err := pm.Find(pat, unsafeFastStringToReadOnlyBytes(str), 0, limit)\n\tif err != nil {\n\t\tL.RaiseError(err.Error())\n\t}\n\tif len(mds) == 0 {\n\t\tL.SetTop(1)\n\t\tL.Push(LNumber(0))\n\t\treturn 2\n\t}\n\tswitch lv := repl.(type) {\n\tcase LString:\n\t\tL.Push(LString(strGsubStr(L, str, string(lv), mds)))\n\tcase *LTable:\n\t\tL.Push(LString(strGsubTable(L, str, lv, mds)))\n\tcase *LFunction:\n\t\tL.Push(LString(strGsubFunc(L, str, lv, mds)))\n\t}\n\tL.Push(LNumber(len(mds)))\n\treturn 2\n}\n\ntype replaceInfo struct {\n\tIndicies []int\n\tString   string\n}\n\nfunc checkCaptureIndex(L *LState, m *pm.MatchData, idx int) {\n\tif idx <= 2 {\n\t\treturn\n\t}\n\tif idx >= m.CaptureLength() {\n\t\tL.RaiseError(\"invalid capture index\")\n\t}\n}\n\nfunc capturedString(L *LState, m *pm.MatchData, str string, idx int) string {\n\tcheckCaptureIndex(L, m, idx)\n\tif idx >= m.CaptureLength() && idx == 2 {\n\t\tidx = 0\n\t}\n\tif m.IsPosCapture(idx) {\n\t\treturn fmt.Sprint(m.Capture(idx))\n\t} else {\n\t\treturn str[m.Capture(idx):m.Capture(idx+1)]\n\t}\n\n}\n\nfunc strGsubDoReplace(str string, info []replaceInfo) string {\n\toffset := 0\n\tbuf := []byte(str)\n\tfor _, replace := range info {\n\t\toldlen := len(buf)\n\t\tb1 := append([]byte(\"\"), buf[0:offset+replace.Indicies[0]]...)\n\t\tb2 := []byte(\"\")\n\t\tindex2 := offset + replace.Indicies[1]\n\t\tif index2 <= len(buf) {\n\t\t\tb2 = append(b2, buf[index2:len(buf)]...)\n\t\t}\n\t\tbuf = append(b1, replace.String...)\n\t\tbuf = append(buf, b2...)\n\t\toffset += len(buf) - oldlen\n\t}\n\treturn string(buf)\n}\n\nfunc strGsubStr(L *LState, str string, repl string, matches []*pm.MatchData) string {\n\tinfoList := make([]replaceInfo, 0, len(matches))\n\tfor _, match := range matches {\n\t\tstart, end := match.Capture(0), match.Capture(1)\n\t\tsc := newFlagScanner('%', \"\", \"\", repl)\n\t\tfor c, eos := sc.Next(); !eos; c, eos = sc.Next() {\n\t\t\tif !sc.ChangeFlag {\n\t\t\t\tif sc.HasFlag {\n\t\t\t\t\tif c >= '0' && c <= '9' {\n\t\t\t\t\t\tsc.AppendString(capturedString(L, match, str, 2*(int(c)-48)))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsc.AppendChar('%')\n\t\t\t\t\t\tsc.AppendChar(c)\n\t\t\t\t\t}\n\t\t\t\t\tsc.HasFlag = false\n\t\t\t\t} else {\n\t\t\t\t\tsc.AppendChar(c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinfoList = append(infoList, replaceInfo{[]int{start, end}, sc.String()})\n\t}\n\n\treturn strGsubDoReplace(str, infoList)\n}\n\nfunc strGsubTable(L *LState, str string, repl *LTable, matches []*pm.MatchData) string {\n\tinfoList := make([]replaceInfo, 0, len(matches))\n\tfor _, match := range matches {\n\t\tidx := 0\n\t\tif match.CaptureLength() > 2 { // has captures\n\t\t\tidx = 2\n\t\t}\n\t\tvar value LValue\n\t\tif match.IsPosCapture(idx) {\n\t\t\tvalue = L.GetTable(repl, LNumber(match.Capture(idx)))\n\t\t} else {\n\t\t\tvalue = L.GetField(repl, str[match.Capture(idx):match.Capture(idx+1)])\n\t\t}\n\t\tif !LVIsFalse(value) {\n\t\t\tinfoList = append(infoList, replaceInfo{[]int{match.Capture(0), match.Capture(1)}, LVAsString(value)})\n\t\t}\n\t}\n\treturn strGsubDoReplace(str, infoList)\n}\n\nfunc strGsubFunc(L *LState, str string, repl *LFunction, matches []*pm.MatchData) string {\n\tinfoList := make([]replaceInfo, 0, len(matches))\n\tfor _, match := range matches {\n\t\tstart, end := match.Capture(0), match.Capture(1)\n\t\tL.Push(repl)\n\t\tnargs := 0\n\t\tif match.CaptureLength() > 2 { // has captures\n\t\t\tfor i := 2; i < match.CaptureLength(); i += 2 {\n\t\t\t\tif match.IsPosCapture(i) {\n\t\t\t\t\tL.Push(LNumber(match.Capture(i)))\n\t\t\t\t} else {\n\t\t\t\t\tL.Push(LString(capturedString(L, match, str, i)))\n\t\t\t\t}\n\t\t\t\tnargs++\n\t\t\t}\n\t\t} else {\n\t\t\tL.Push(LString(capturedString(L, match, str, 0)))\n\t\t\tnargs++\n\t\t}\n\t\tL.Call(nargs, 1)\n\t\tret := L.reg.Pop()\n\t\tif !LVIsFalse(ret) {\n\t\t\tinfoList = append(infoList, replaceInfo{[]int{start, end}, LVAsString(ret)})\n\t\t}\n\t}\n\treturn strGsubDoReplace(str, infoList)\n}\n\ntype strMatchData struct {\n\tstr     string\n\tpos     int\n\tmatches []*pm.MatchData\n}\n\nfunc strGmatchIter(L *LState) int {\n\tmd := L.CheckUserData(1).Value.(*strMatchData)\n\tstr := md.str\n\tmatches := md.matches\n\tidx := md.pos\n\tmd.pos += 1\n\tif idx == len(matches) {\n\t\treturn 0\n\t}\n\tL.Push(L.Get(1))\n\tmatch := matches[idx]\n\tif match.CaptureLength() == 2 {\n\t\tL.Push(LString(str[match.Capture(0):match.Capture(1)]))\n\t\treturn 1\n\t}\n\n\tfor i := 2; i < match.CaptureLength(); i += 2 {\n\t\tif match.IsPosCapture(i) {\n\t\t\tL.Push(LNumber(match.Capture(i)))\n\t\t} else {\n\t\t\tL.Push(LString(str[match.Capture(i):match.Capture(i+1)]))\n\t\t}\n\t}\n\treturn match.CaptureLength()/2 - 1\n}\n\nfunc strGmatch(L *LState) int {\n\tstr := L.CheckString(1)\n\tpattern := L.CheckString(2)\n\tmds, err := pm.Find(pattern, []byte(str), 0, -1)\n\tif err != nil {\n\t\tL.RaiseError(err.Error())\n\t}\n\tL.Push(L.Get(UpvalueIndex(1)))\n\tud := L.NewUserData()\n\tud.Value = &strMatchData{str, 0, mds}\n\tL.Push(ud)\n\treturn 2\n}\n\nfunc strLen(L *LState) int {\n\tstr := L.CheckString(1)\n\tL.Push(LNumber(len(str)))\n\treturn 1\n}\n\nfunc strLower(L *LState) int {\n\tstr := L.CheckString(1)\n\tL.Push(LString(strings.ToLower(str)))\n\treturn 1\n}\n\nfunc strMatch(L *LState) int {\n\tstr := L.CheckString(1)\n\tpattern := L.CheckString(2)\n\toffset := L.OptInt(3, 1)\n\tl := len(str)\n\tif offset < 0 {\n\t\toffset = l + offset + 1\n\t}\n\toffset--\n\tif offset < 0 {\n\t\toffset = 0\n\t}\n\n\tmds, err := pm.Find(pattern, unsafeFastStringToReadOnlyBytes(str), offset, 1)\n\tif err != nil {\n\t\tL.RaiseError(err.Error())\n\t}\n\tif len(mds) == 0 {\n\t\tL.Push(LNil)\n\t\treturn 0\n\t}\n\tmd := mds[0]\n\tnsubs := md.CaptureLength() / 2\n\tswitch nsubs {\n\tcase 1:\n\t\tL.Push(LString(str[md.Capture(0):md.Capture(1)]))\n\t\treturn 1\n\tdefault:\n\t\tfor i := 2; i < md.CaptureLength(); i += 2 {\n\t\t\tif md.IsPosCapture(i) {\n\t\t\t\tL.Push(LNumber(md.Capture(i)))\n\t\t\t} else {\n\t\t\t\tL.Push(LString(str[md.Capture(i):md.Capture(i+1)]))\n\t\t\t}\n\t\t}\n\t\treturn nsubs - 1\n\t}\n}\n\nfunc strRep(L *LState) int {\n\tstr := L.CheckString(1)\n\tn := L.CheckInt(2)\n\tif n < 0 {\n\t\tL.Push(emptyLString)\n\t} else {\n\t\tL.Push(LString(strings.Repeat(str, n)))\n\t}\n\treturn 1\n}\n\nfunc strReverse(L *LState) int {\n\tstr := L.CheckString(1)\n\tbts := []byte(str)\n\tout := make([]byte, len(bts))\n\tfor i, j := 0, len(bts)-1; j >= 0; i, j = i+1, j-1 {\n\t\tout[i] = bts[j]\n\t}\n\tL.Push(LString(string(out)))\n\treturn 1\n}\n\nfunc strSub(L *LState) int {\n\tstr := L.CheckString(1)\n\tstart := luaIndex2StringIndex(str, L.CheckInt(2), true)\n\tend := luaIndex2StringIndex(str, L.OptInt(3, -1), false)\n\tl := len(str)\n\tif start >= l || end < start {\n\t\tL.Push(emptyLString)\n\t} else {\n\t\tL.Push(LString(str[start:end]))\n\t}\n\treturn 1\n}\n\nfunc strUpper(L *LState) int {\n\tstr := L.CheckString(1)\n\tL.Push(LString(strings.ToUpper(str)))\n\treturn 1\n}\n\nfunc luaIndex2StringIndex(str string, i int, start bool) int {\n\tif start && i != 0 {\n\t\ti -= 1\n\t}\n\tl := len(str)\n\tif i < 0 {\n\t\ti = l + i + 1\n\t}\n\ti = intMax(0, i)\n\tif !start && i > l {\n\t\ti = l\n\t}\n\treturn i\n}\n\n//\n"
        },
        {
          "name": "table.go",
          "type": "blob",
          "size": 8.08984375,
          "content": "package lua\n\nconst defaultArrayCap = 32\nconst defaultHashCap = 32\n\ntype lValueArraySorter struct {\n\tL      *LState\n\tFn     *LFunction\n\tValues []LValue\n}\n\nfunc (lv lValueArraySorter) Len() int {\n\treturn len(lv.Values)\n}\n\nfunc (lv lValueArraySorter) Swap(i, j int) {\n\tlv.Values[i], lv.Values[j] = lv.Values[j], lv.Values[i]\n}\n\nfunc (lv lValueArraySorter) Less(i, j int) bool {\n\tif lv.Fn != nil {\n\t\tlv.L.Push(lv.Fn)\n\t\tlv.L.Push(lv.Values[i])\n\t\tlv.L.Push(lv.Values[j])\n\t\tlv.L.Call(2, 1)\n\t\treturn LVAsBool(lv.L.reg.Pop())\n\t}\n\treturn lessThan(lv.L, lv.Values[i], lv.Values[j])\n}\n\nfunc newLTable(acap int, hcap int) *LTable {\n\tif acap < 0 {\n\t\tacap = 0\n\t}\n\tif hcap < 0 {\n\t\thcap = 0\n\t}\n\ttb := &LTable{}\n\ttb.Metatable = LNil\n\tif acap != 0 {\n\t\ttb.array = make([]LValue, 0, acap)\n\t}\n\tif hcap != 0 {\n\t\ttb.strdict = make(map[string]LValue, hcap)\n\t}\n\treturn tb\n}\n\n// Len returns length of this LTable without using __len.\nfunc (tb *LTable) Len() int {\n\tif tb.array == nil {\n\t\treturn 0\n\t}\n\tvar prev LValue = LNil\n\tfor i := len(tb.array) - 1; i >= 0; i-- {\n\t\tv := tb.array[i]\n\t\tif prev == LNil && v != LNil {\n\t\t\treturn i + 1\n\t\t}\n\t\tprev = v\n\t}\n\treturn 0\n}\n\n// Append appends a given LValue to this LTable.\nfunc (tb *LTable) Append(value LValue) {\n\tif value == LNil {\n\t\treturn\n\t}\n\tif tb.array == nil {\n\t\ttb.array = make([]LValue, 0, defaultArrayCap)\n\t}\n\tif len(tb.array) == 0 || tb.array[len(tb.array)-1] != LNil {\n\t\ttb.array = append(tb.array, value)\n\t} else {\n\t\ti := len(tb.array) - 2\n\t\tfor ; i >= 0; i-- {\n\t\t\tif tb.array[i] != LNil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttb.array[i+1] = value\n\t}\n}\n\n// Insert inserts a given LValue at position `i` in this table.\nfunc (tb *LTable) Insert(i int, value LValue) {\n\tif tb.array == nil {\n\t\ttb.array = make([]LValue, 0, defaultArrayCap)\n\t}\n\tif i > len(tb.array) {\n\t\ttb.RawSetInt(i, value)\n\t\treturn\n\t}\n\tif i <= 0 {\n\t\ttb.RawSet(LNumber(i), value)\n\t\treturn\n\t}\n\ti -= 1\n\ttb.array = append(tb.array, LNil)\n\tcopy(tb.array[i+1:], tb.array[i:])\n\ttb.array[i] = value\n}\n\n// MaxN returns a maximum number key that nil value does not exist before it.\nfunc (tb *LTable) MaxN() int {\n\tif tb.array == nil {\n\t\treturn 0\n\t}\n\tfor i := len(tb.array) - 1; i >= 0; i-- {\n\t\tif tb.array[i] != LNil {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn 0\n}\n\n// Remove removes from this table the element at a given position.\nfunc (tb *LTable) Remove(pos int) LValue {\n\tif tb.array == nil {\n\t\treturn LNil\n\t}\n\tlarray := len(tb.array)\n\tif larray == 0 {\n\t\treturn LNil\n\t}\n\ti := pos - 1\n\toldval := LNil\n\tswitch {\n\tcase i >= larray:\n\t\t// nothing to do\n\tcase i == larray-1 || i < 0:\n\t\toldval = tb.array[larray-1]\n\t\ttb.array = tb.array[:larray-1]\n\tdefault:\n\t\toldval = tb.array[i]\n\t\tcopy(tb.array[i:], tb.array[i+1:])\n\t\ttb.array[larray-1] = nil\n\t\ttb.array = tb.array[:larray-1]\n\t}\n\treturn oldval\n}\n\n// RawSet sets a given LValue to a given index without the __newindex metamethod.\n// It is recommended to use `RawSetString` or `RawSetInt` for performance\n// if you already know the given LValue is a string or number.\nfunc (tb *LTable) RawSet(key LValue, value LValue) {\n\tswitch v := key.(type) {\n\tcase LNumber:\n\t\tif isArrayKey(v) {\n\t\t\tif tb.array == nil {\n\t\t\t\ttb.array = make([]LValue, 0, defaultArrayCap)\n\t\t\t}\n\t\t\tindex := int(v) - 1\n\t\t\talen := len(tb.array)\n\t\t\tswitch {\n\t\t\tcase index == alen:\n\t\t\t\ttb.array = append(tb.array, value)\n\t\t\tcase index > alen:\n\t\t\t\tfor i := 0; i < (index - alen); i++ {\n\t\t\t\t\ttb.array = append(tb.array, LNil)\n\t\t\t\t}\n\t\t\t\ttb.array = append(tb.array, value)\n\t\t\tcase index < alen:\n\t\t\t\ttb.array[index] = value\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tcase LString:\n\t\ttb.RawSetString(string(v), value)\n\t\treturn\n\t}\n\n\ttb.RawSetH(key, value)\n}\n\n// RawSetInt sets a given LValue at a position `key` without the __newindex metamethod.\nfunc (tb *LTable) RawSetInt(key int, value LValue) {\n\tif key < 1 || key >= MaxArrayIndex {\n\t\ttb.RawSetH(LNumber(key), value)\n\t\treturn\n\t}\n\tif tb.array == nil {\n\t\ttb.array = make([]LValue, 0, 32)\n\t}\n\tindex := key - 1\n\talen := len(tb.array)\n\tswitch {\n\tcase index == alen:\n\t\ttb.array = append(tb.array, value)\n\tcase index > alen:\n\t\tfor i := 0; i < (index - alen); i++ {\n\t\t\ttb.array = append(tb.array, LNil)\n\t\t}\n\t\ttb.array = append(tb.array, value)\n\tcase index < alen:\n\t\ttb.array[index] = value\n\t}\n}\n\n// RawSetString sets a given LValue to a given string index without the __newindex metamethod.\nfunc (tb *LTable) RawSetString(key string, value LValue) {\n\tif tb.strdict == nil {\n\t\ttb.strdict = make(map[string]LValue, defaultHashCap)\n\t}\n\tif tb.keys == nil {\n\t\ttb.keys = []LValue{}\n\t\ttb.k2i = map[LValue]int{}\n\t}\n\n\tif value == LNil {\n\t\t// TODO tb.keys and tb.k2i should also be removed\n\t\tdelete(tb.strdict, key)\n\t} else {\n\t\ttb.strdict[key] = value\n\t\tlkey := LString(key)\n\t\tif _, ok := tb.k2i[lkey]; !ok {\n\t\t\ttb.k2i[lkey] = len(tb.keys)\n\t\t\ttb.keys = append(tb.keys, lkey)\n\t\t}\n\t}\n}\n\n// RawSetH sets a given LValue to a given index without the __newindex metamethod.\nfunc (tb *LTable) RawSetH(key LValue, value LValue) {\n\tif s, ok := key.(LString); ok {\n\t\ttb.RawSetString(string(s), value)\n\t\treturn\n\t}\n\tif tb.dict == nil {\n\t\ttb.dict = make(map[LValue]LValue, len(tb.strdict))\n\t}\n\tif tb.keys == nil {\n\t\ttb.keys = []LValue{}\n\t\ttb.k2i = map[LValue]int{}\n\t}\n\n\tif value == LNil {\n\t\t// TODO tb.keys and tb.k2i should also be removed\n\t\tdelete(tb.dict, key)\n\t} else {\n\t\ttb.dict[key] = value\n\t\tif _, ok := tb.k2i[key]; !ok {\n\t\t\ttb.k2i[key] = len(tb.keys)\n\t\t\ttb.keys = append(tb.keys, key)\n\t\t}\n\t}\n}\n\n// RawGet returns an LValue associated with a given key without __index metamethod.\nfunc (tb *LTable) RawGet(key LValue) LValue {\n\tswitch v := key.(type) {\n\tcase LNumber:\n\t\tif isArrayKey(v) {\n\t\t\tif tb.array == nil {\n\t\t\t\treturn LNil\n\t\t\t}\n\t\t\tindex := int(v) - 1\n\t\t\tif index >= len(tb.array) {\n\t\t\t\treturn LNil\n\t\t\t}\n\t\t\treturn tb.array[index]\n\t\t}\n\tcase LString:\n\t\tif tb.strdict == nil {\n\t\t\treturn LNil\n\t\t}\n\t\tif ret, ok := tb.strdict[string(v)]; ok {\n\t\t\treturn ret\n\t\t}\n\t\treturn LNil\n\t}\n\tif tb.dict == nil {\n\t\treturn LNil\n\t}\n\tif v, ok := tb.dict[key]; ok {\n\t\treturn v\n\t}\n\treturn LNil\n}\n\n// RawGetInt returns an LValue at position `key` without __index metamethod.\nfunc (tb *LTable) RawGetInt(key int) LValue {\n\tif tb.array == nil {\n\t\treturn LNil\n\t}\n\tindex := int(key) - 1\n\tif index >= len(tb.array) || index < 0 {\n\t\treturn LNil\n\t}\n\treturn tb.array[index]\n}\n\n// RawGet returns an LValue associated with a given key without __index metamethod.\nfunc (tb *LTable) RawGetH(key LValue) LValue {\n\tif s, sok := key.(LString); sok {\n\t\tif tb.strdict == nil {\n\t\t\treturn LNil\n\t\t}\n\t\tif v, vok := tb.strdict[string(s)]; vok {\n\t\t\treturn v\n\t\t}\n\t\treturn LNil\n\t}\n\tif tb.dict == nil {\n\t\treturn LNil\n\t}\n\tif v, ok := tb.dict[key]; ok {\n\t\treturn v\n\t}\n\treturn LNil\n}\n\n// RawGetString returns an LValue associated with a given key without __index metamethod.\nfunc (tb *LTable) RawGetString(key string) LValue {\n\tif tb.strdict == nil {\n\t\treturn LNil\n\t}\n\tif v, vok := tb.strdict[string(key)]; vok {\n\t\treturn v\n\t}\n\treturn LNil\n}\n\n// ForEach iterates over this table of elements, yielding each in turn to a given function.\nfunc (tb *LTable) ForEach(cb func(LValue, LValue)) {\n\tif tb.array != nil {\n\t\tfor i, v := range tb.array {\n\t\t\tif v != LNil {\n\t\t\t\tcb(LNumber(i+1), v)\n\t\t\t}\n\t\t}\n\t}\n\tif tb.strdict != nil {\n\t\tfor k, v := range tb.strdict {\n\t\t\tif v != LNil {\n\t\t\t\tcb(LString(k), v)\n\t\t\t}\n\t\t}\n\t}\n\tif tb.dict != nil {\n\t\tfor k, v := range tb.dict {\n\t\t\tif v != LNil {\n\t\t\t\tcb(k, v)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// This function is equivalent to lua_next ( http://www.lua.org/manual/5.1/manual.html#lua_next ).\nfunc (tb *LTable) Next(key LValue) (LValue, LValue) {\n\tinit := false\n\tif key == LNil {\n\t\tkey = LNumber(0)\n\t\tinit = true\n\t}\n\n\tif init || key != LNumber(0) {\n\t\tif kv, ok := key.(LNumber); ok && isInteger(kv) && int(kv) >= 0 && kv < LNumber(MaxArrayIndex) {\n\t\t\tindex := int(kv)\n\t\t\tif tb.array != nil {\n\t\t\t\tfor ; index < len(tb.array); index++ {\n\t\t\t\t\tif v := tb.array[index]; v != LNil {\n\t\t\t\t\t\treturn LNumber(index + 1), v\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tb.array == nil || index == len(tb.array) {\n\t\t\t\tif (tb.dict == nil || len(tb.dict) == 0) && (tb.strdict == nil || len(tb.strdict) == 0) {\n\t\t\t\t\treturn LNil, LNil\n\t\t\t\t}\n\t\t\t\tkey = tb.keys[0]\n\t\t\t\tif v := tb.RawGetH(key); v != LNil {\n\t\t\t\t\treturn key, v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := tb.k2i[key] + 1; i < len(tb.keys); i++ {\n\t\tkey := tb.keys[i]\n\t\tif v := tb.RawGetH(key); v != LNil {\n\t\t\treturn key, v\n\t\t}\n\t}\n\treturn LNil, LNil\n}\n"
        },
        {
          "name": "table_test.go",
          "type": "blob",
          "size": 5.3349609375,
          "content": "package lua\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTableNewLTable(t *testing.T) {\n\ttbl := newLTable(-1, -2)\n\terrorIfNotEqual(t, 0, cap(tbl.array))\n\n\ttbl = newLTable(10, 9)\n\terrorIfNotEqual(t, 10, cap(tbl.array))\n}\n\nfunc TestTableLen(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.RawSetInt(10, LNil)\n\ttbl.RawSetInt(9, LNumber(10))\n\ttbl.RawSetInt(8, LNil)\n\ttbl.RawSetInt(7, LNumber(10))\n\terrorIfNotEqual(t, 9, tbl.Len())\n\n\ttbl = newLTable(0, 0)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\terrorIfNotEqual(t, 3, tbl.Len())\n}\n\nfunc TestTableLenType(t *testing.T) {\n\tL := NewState(Options{})\n\terr := L.DoString(`\n        mt = {\n            __index = mt,\n            __len = function (self)\n                return {hello = \"world\"}\n            end\n        }\n\n        v = {}\n        v.__index = v\n\n        setmetatable(v, mt)\n\n        assert(#v ~= 0, \"#v should return a table reference in this case\")\n\n        print(#v)\n    `)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTableAppend(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.RawSetInt(1, LNumber(1))\n\ttbl.RawSetInt(2, LNumber(2))\n\ttbl.RawSetInt(3, LNumber(3))\n\terrorIfNotEqual(t, 3, tbl.Len())\n\n\ttbl.RawSetInt(1, LNil)\n\ttbl.RawSetInt(2, LNil)\n\terrorIfNotEqual(t, 3, tbl.Len())\n\n\ttbl.Append(LNumber(4))\n\terrorIfNotEqual(t, 4, tbl.Len())\n\n\ttbl.RawSetInt(3, LNil)\n\ttbl.RawSetInt(4, LNil)\n\terrorIfNotEqual(t, 0, tbl.Len())\n\n\ttbl.Append(LNumber(5))\n\terrorIfNotEqual(t, 1, tbl.Len())\n}\n\nfunc TestTableInsert(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\n\ttbl.Insert(5, LFalse)\n\terrorIfNotEqual(t, LFalse, tbl.RawGetInt(5))\n\terrorIfNotEqual(t, 5, tbl.Len())\n\n\ttbl.Insert(-10, LFalse)\n\terrorIfNotEqual(t, LFalse, tbl.RawGet(LNumber(-10)))\n\terrorIfNotEqual(t, 5, tbl.Len())\n\n\ttbl = newLTable(0, 0)\n\ttbl.Append(LNumber(1))\n\ttbl.Append(LNumber(2))\n\ttbl.Append(LNumber(3))\n\ttbl.Insert(1, LNumber(10))\n\terrorIfNotEqual(t, LNumber(10), tbl.RawGetInt(1))\n\terrorIfNotEqual(t, LNumber(1), tbl.RawGetInt(2))\n\terrorIfNotEqual(t, LNumber(2), tbl.RawGetInt(3))\n\terrorIfNotEqual(t, LNumber(3), tbl.RawGetInt(4))\n\terrorIfNotEqual(t, 4, tbl.Len())\n\n\ttbl = newLTable(0, 0)\n\ttbl.Insert(5, LNumber(10))\n\terrorIfNotEqual(t, LNumber(10), tbl.RawGetInt(5))\n\n}\n\nfunc TestTableMaxN(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\ttbl.Append(LTrue)\n\terrorIfNotEqual(t, 3, tbl.MaxN())\n\n\ttbl = newLTable(0, 0)\n\terrorIfNotEqual(t, 0, tbl.MaxN())\n\n\ttbl = newLTable(10, 0)\n\terrorIfNotEqual(t, 0, tbl.MaxN())\n}\n\nfunc TestTableRemove(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\terrorIfNotEqual(t, LNil, tbl.Remove(10))\n\ttbl.Append(LTrue)\n\terrorIfNotEqual(t, LNil, tbl.Remove(10))\n\n\ttbl.Append(LFalse)\n\ttbl.Append(LTrue)\n\terrorIfNotEqual(t, LFalse, tbl.Remove(2))\n\terrorIfNotEqual(t, 2, tbl.MaxN())\n\ttbl.Append(LFalse)\n\terrorIfNotEqual(t, LFalse, tbl.Remove(-1))\n\terrorIfNotEqual(t, 2, tbl.MaxN())\n\n}\n\nfunc TestTableRawSetInt(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.RawSetInt(MaxArrayIndex+1, LTrue)\n\terrorIfNotEqual(t, 0, tbl.MaxN())\n\terrorIfNotEqual(t, LTrue, tbl.RawGet(LNumber(MaxArrayIndex+1)))\n\n\ttbl.RawSetInt(1, LTrue)\n\ttbl.RawSetInt(3, LTrue)\n\terrorIfNotEqual(t, 3, tbl.MaxN())\n\terrorIfNotEqual(t, LTrue, tbl.RawGetInt(1))\n\terrorIfNotEqual(t, LNil, tbl.RawGetInt(2))\n\terrorIfNotEqual(t, LTrue, tbl.RawGetInt(3))\n\ttbl.RawSetInt(2, LTrue)\n\terrorIfNotEqual(t, LTrue, tbl.RawGetInt(1))\n\terrorIfNotEqual(t, LTrue, tbl.RawGetInt(2))\n\terrorIfNotEqual(t, LTrue, tbl.RawGetInt(3))\n}\n\nfunc TestTableRawSetH(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.RawSetH(LString(\"key\"), LTrue)\n\ttbl.RawSetH(LString(\"key\"), LNil)\n\t_, found := tbl.dict[LString(\"key\")]\n\terrorIfNotEqual(t, false, found)\n\n\ttbl.RawSetH(LTrue, LTrue)\n\ttbl.RawSetH(LTrue, LNil)\n\t_, foundb := tbl.dict[LTrue]\n\terrorIfNotEqual(t, false, foundb)\n}\n\nfunc TestTableRawGetH(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\terrorIfNotEqual(t, LNil, tbl.RawGetH(LNumber(1)))\n\terrorIfNotEqual(t, LNil, tbl.RawGetH(LString(\"key0\")))\n\ttbl.RawSetH(LString(\"key0\"), LTrue)\n\ttbl.RawSetH(LString(\"key1\"), LFalse)\n\ttbl.RawSetH(LNumber(1), LTrue)\n\terrorIfNotEqual(t, LTrue, tbl.RawGetH(LString(\"key0\")))\n\terrorIfNotEqual(t, LTrue, tbl.RawGetH(LNumber(1)))\n\terrorIfNotEqual(t, LNil, tbl.RawGetH(LString(\"notexist\")))\n\terrorIfNotEqual(t, LNil, tbl.RawGetH(LTrue))\n}\n\nfunc TestTableForEach(t *testing.T) {\n\ttbl := newLTable(0, 0)\n\ttbl.Append(LNumber(1))\n\ttbl.Append(LNumber(2))\n\ttbl.Append(LNumber(3))\n\ttbl.Append(LNil)\n\ttbl.Append(LNumber(5))\n\n\ttbl.RawSetH(LString(\"a\"), LString(\"a\"))\n\ttbl.RawSetH(LString(\"b\"), LString(\"b\"))\n\ttbl.RawSetH(LString(\"c\"), LString(\"c\"))\n\n\ttbl.RawSetH(LTrue, LString(\"true\"))\n\ttbl.RawSetH(LFalse, LString(\"false\"))\n\n\ttbl.ForEach(func(key, value LValue) {\n\t\tswitch k := key.(type) {\n\t\tcase LBool:\n\t\t\tswitch bool(k) {\n\t\t\tcase true:\n\t\t\t\terrorIfNotEqual(t, LString(\"true\"), value)\n\t\t\tcase false:\n\t\t\t\terrorIfNotEqual(t, LString(\"false\"), value)\n\t\t\tdefault:\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\tcase LNumber:\n\t\t\tswitch int(k) {\n\t\t\tcase 1:\n\t\t\t\terrorIfNotEqual(t, LNumber(1), value)\n\t\t\tcase 2:\n\t\t\t\terrorIfNotEqual(t, LNumber(2), value)\n\t\t\tcase 3:\n\t\t\t\terrorIfNotEqual(t, LNumber(3), value)\n\t\t\tcase 4:\n\t\t\t\terrorIfNotEqual(t, LNumber(5), value)\n\t\t\tdefault:\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\tcase LString:\n\t\t\tswitch string(k) {\n\t\t\tcase \"a\":\n\t\t\t\terrorIfNotEqual(t, LString(\"a\"), value)\n\t\t\tcase \"b\":\n\t\t\t\terrorIfNotEqual(t, LString(\"b\"), value)\n\t\t\tcase \"c\":\n\t\t\t\terrorIfNotEqual(t, LString(\"c\"), value)\n\t\t\tdefault:\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "tablelib.go",
          "type": "blob",
          "size": 1.794921875,
          "content": "package lua\n\nimport (\n\t\"sort\"\n)\n\nfunc OpenTable(L *LState) int {\n\ttabmod := L.RegisterModule(TabLibName, tableFuncs)\n\tL.Push(tabmod)\n\treturn 1\n}\n\nvar tableFuncs = map[string]LGFunction{\n\t\"getn\":   tableGetN,\n\t\"concat\": tableConcat,\n\t\"insert\": tableInsert,\n\t\"maxn\":   tableMaxN,\n\t\"remove\": tableRemove,\n\t\"sort\":   tableSort,\n}\n\nfunc tableSort(L *LState) int {\n\ttbl := L.CheckTable(1)\n\tsorter := lValueArraySorter{L, nil, tbl.array}\n\tif L.GetTop() != 1 {\n\t\tsorter.Fn = L.CheckFunction(2)\n\t}\n\tsort.Sort(sorter)\n\treturn 0\n}\n\nfunc tableGetN(L *LState) int {\n\tL.Push(LNumber(L.CheckTable(1).Len()))\n\treturn 1\n}\n\nfunc tableMaxN(L *LState) int {\n\tL.Push(LNumber(L.CheckTable(1).MaxN()))\n\treturn 1\n}\n\nfunc tableRemove(L *LState) int {\n\ttbl := L.CheckTable(1)\n\tif L.GetTop() == 1 {\n\t\tL.Push(tbl.Remove(-1))\n\t} else {\n\t\tL.Push(tbl.Remove(L.CheckInt(2)))\n\t}\n\treturn 1\n}\n\nfunc tableConcat(L *LState) int {\n\ttbl := L.CheckTable(1)\n\tsep := LString(L.OptString(2, \"\"))\n\ti := L.OptInt(3, 1)\n\tj := L.OptInt(4, tbl.Len())\n\tif L.GetTop() == 3 {\n\t\tif i > tbl.Len() || i < 1 {\n\t\t\tL.Push(emptyLString)\n\t\t\treturn 1\n\t\t}\n\t}\n\ti = intMax(intMin(i, tbl.Len()), 1)\n\tj = intMin(intMin(j, tbl.Len()), tbl.Len())\n\tif i > j {\n\t\tL.Push(emptyLString)\n\t\treturn 1\n\t}\n\t//TODO should flushing?\n\tretbottom := L.GetTop()\n\tfor ; i <= j; i++ {\n\t\tv := tbl.RawGetInt(i)\n\t\tif !LVCanConvToString(v) {\n\t\t\tL.RaiseError(\"invalid value (%s) at index %d in table for concat\", v.Type().String(), i)\n\t\t}\n\t\tL.Push(v)\n\t\tif i != j {\n\t\t\tL.Push(sep)\n\t\t}\n\t}\n\tL.Push(stringConcat(L, L.GetTop()-retbottom, L.reg.Top()-1))\n\treturn 1\n}\n\nfunc tableInsert(L *LState) int {\n\ttbl := L.CheckTable(1)\n\tnargs := L.GetTop()\n\tif nargs == 1 {\n\t\tL.RaiseError(\"wrong number of arguments\")\n\t}\n\n\tif L.GetTop() == 2 {\n\t\ttbl.Append(L.Get(2))\n\t\treturn 0\n\t}\n\ttbl.Insert(int(L.CheckInt(2)), L.CheckAny(3))\n\treturn 0\n}\n\n//\n"
        },
        {
          "name": "testutils_test.go",
          "type": "blob",
          "size": 2.0595703125,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc positionString(level int) string {\n\t_, file, line, _ := runtime.Caller(level + 1)\n\treturn fmt.Sprintf(\"%v:%v:\", filepath.Base(file), line)\n}\n\nfunc errorIfNotEqual(t *testing.T, v1, v2 interface{}) {\n\tif v1 != v2 {\n\t\tt.Errorf(\"%v '%v' expected, but got '%v'\", positionString(1), v1, v2)\n\t}\n}\n\nfunc errorIfFalse(t *testing.T, cond bool, msg string, args ...interface{}) {\n\tif !cond {\n\t\tif len(args) > 0 {\n\t\t\tt.Errorf(\"%v %v\", positionString(1), fmt.Sprintf(msg, args...))\n\t\t} else {\n\t\t\tt.Errorf(\"%v %v\", positionString(1), msg)\n\t\t}\n\t}\n}\n\nfunc errorIfNotNil(t *testing.T, v1 interface{}) {\n\tif fmt.Sprint(v1) != \"<nil>\" {\n\t\tt.Errorf(\"%v nil expected, but got '%v'\", positionString(1), v1)\n\t}\n}\n\nfunc errorIfNil(t *testing.T, v1 interface{}) {\n\tif fmt.Sprint(v1) == \"<nil>\" {\n\t\tt.Errorf(\"%v non-nil value expected, but got nil\", positionString(1))\n\t}\n}\n\nfunc errorIfScriptFail(t *testing.T, L *LState, script string) {\n\tif err := L.DoString(script); err != nil {\n\t\tt.Errorf(\"%v %v\", positionString(1), err.Error())\n\t}\n}\n\nfunc errorIfGFuncFail(t *testing.T, L *LState, f LGFunction) {\n\tif err := L.GPCall(f, LNil); err != nil {\n\t\tt.Errorf(\"%v %v\", positionString(1), err.Error())\n\t}\n}\n\nfunc errorIfScriptNotFail(t *testing.T, L *LState, script string, pattern string) {\n\tif err := L.DoString(script); err != nil {\n\t\treg := regexp.MustCompile(pattern)\n\t\tif len(reg.FindStringIndex(err.Error())) == 0 {\n\t\t\tt.Errorf(\"%v error message '%v' does not contains given pattern string '%v'.\", positionString(1), err.Error(), pattern)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\tt.Errorf(\"%v script should fail\", positionString(1))\n}\n\nfunc errorIfGFuncNotFail(t *testing.T, L *LState, f LGFunction, pattern string) {\n\tif err := L.GPCall(f, LNil); err != nil {\n\t\treg := regexp.MustCompile(pattern)\n\t\tif len(reg.FindStringIndex(err.Error())) == 0 {\n\t\t\tt.Errorf(\"%v error message '%v' does not contains given pattern string '%v'.\", positionString(1), err.Error(), pattern)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\tt.Errorf(\"%v LGFunction should fail\", positionString(1))\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 5.12109375,
          "content": "package lua\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc intMin(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\nfunc intMax(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\nfunc defaultFormat(v interface{}, f fmt.State, c rune) {\n\tbuf := make([]string, 0, 10)\n\tbuf = append(buf, \"%\")\n\tfor i := 0; i < 128; i++ {\n\t\tif f.Flag(i) {\n\t\t\tbuf = append(buf, string(rune(i)))\n\t\t}\n\t}\n\n\tif w, ok := f.Width(); ok {\n\t\tbuf = append(buf, strconv.Itoa(w))\n\t}\n\tif p, ok := f.Precision(); ok {\n\t\tbuf = append(buf, \".\"+strconv.Itoa(p))\n\t}\n\tbuf = append(buf, string(c))\n\tformat := strings.Join(buf, \"\")\n\tfmt.Fprintf(f, format, v)\n}\n\ntype flagScanner struct {\n\tflag       byte\n\tstart      string\n\tend        string\n\tbuf        []byte\n\tstr        string\n\tLength     int\n\tPos        int\n\tHasFlag    bool\n\tChangeFlag bool\n}\n\nfunc newFlagScanner(flag byte, start, end, str string) *flagScanner {\n\treturn &flagScanner{flag, start, end, make([]byte, 0, len(str)), str, len(str), 0, false, false}\n}\n\nfunc (fs *flagScanner) AppendString(str string) { fs.buf = append(fs.buf, str...) }\n\nfunc (fs *flagScanner) AppendChar(ch byte) { fs.buf = append(fs.buf, ch) }\n\nfunc (fs *flagScanner) String() string { return string(fs.buf) }\n\nfunc (fs *flagScanner) Next() (byte, bool) {\n\tc := byte('\\000')\n\tfs.ChangeFlag = false\n\tif fs.Pos == fs.Length {\n\t\tif fs.HasFlag {\n\t\t\tfs.AppendString(fs.end)\n\t\t}\n\t\treturn c, true\n\t} else {\n\t\tc = fs.str[fs.Pos]\n\t\tif c == fs.flag {\n\t\t\tif fs.Pos < (fs.Length-1) && fs.str[fs.Pos+1] == fs.flag {\n\t\t\t\tfs.HasFlag = false\n\t\t\t\tfs.AppendChar(fs.flag)\n\t\t\t\tfs.Pos += 2\n\t\t\t\treturn fs.Next()\n\t\t\t} else if fs.Pos != fs.Length-1 {\n\t\t\t\tif fs.HasFlag {\n\t\t\t\t\tfs.AppendString(fs.end)\n\t\t\t\t}\n\t\t\t\tfs.AppendString(fs.start)\n\t\t\t\tfs.ChangeFlag = true\n\t\t\t\tfs.HasFlag = true\n\t\t\t}\n\t\t}\n\t}\n\tfs.Pos++\n\treturn c, false\n}\n\nvar cDateFlagToGo = map[byte]string{\n\t'a': \"mon\", 'A': \"Monday\", 'b': \"Jan\", 'B': \"January\", 'c': \"02 Jan 06 15:04 MST\", 'd': \"02\",\n\t'F': \"2006-01-02\", 'H': \"15\", 'I': \"03\", 'm': \"01\", 'M': \"04\", 'p': \"PM\", 'P': \"pm\", 'S': \"05\",\n\t'x': \"15/04/05\", 'X': \"15:04:05\", 'y': \"06\", 'Y': \"2006\", 'z': \"-0700\", 'Z': \"MST\"}\n\nfunc strftime(t time.Time, cfmt string) string {\n\tsc := newFlagScanner('%', \"\", \"\", cfmt)\n\tfor c, eos := sc.Next(); !eos; c, eos = sc.Next() {\n\t\tif !sc.ChangeFlag {\n\t\t\tif sc.HasFlag {\n\t\t\t\tif v, ok := cDateFlagToGo[c]; ok {\n\t\t\t\t\tsc.AppendString(t.Format(v))\n\t\t\t\t} else {\n\t\t\t\t\tswitch c {\n\t\t\t\t\tcase 'w':\n\t\t\t\t\t\tsc.AppendString(fmt.Sprint(int(t.Weekday())))\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsc.AppendChar('%')\n\t\t\t\t\t\tsc.AppendChar(c)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsc.HasFlag = false\n\t\t\t} else {\n\t\t\t\tsc.AppendChar(c)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sc.String()\n}\n\nfunc isInteger(v LNumber) bool {\n\treturn float64(v) == float64(int64(v))\n\t//_, frac := math.Modf(float64(v))\n\t//return frac == 0.0\n}\n\nfunc isArrayKey(v LNumber) bool {\n\treturn isInteger(v) && v < LNumber(int((^uint(0))>>1)) && v > LNumber(0) && v < LNumber(MaxArrayIndex)\n}\n\nfunc parseNumber(number string) (LNumber, error) {\n\tvar value LNumber\n\tnumber = strings.Trim(number, \" \\t\\n\")\n\tif v, err := strconv.ParseInt(number, 0, LNumberBit); err != nil {\n\t\tif v2, err2 := strconv.ParseFloat(number, LNumberBit); err2 != nil {\n\t\t\treturn LNumber(0), err2\n\t\t} else {\n\t\t\tvalue = LNumber(v2)\n\t\t}\n\t} else {\n\t\tvalue = LNumber(v)\n\t}\n\treturn value, nil\n}\n\nfunc popenArgs(arg string) (string, []string) {\n\tcmd := \"/bin/sh\"\n\targs := []string{\"-c\"}\n\tif LuaOS == \"windows\" {\n\t\tcmd = \"C:\\\\Windows\\\\system32\\\\cmd.exe\"\n\t\targs = []string{\"/c\"}\n\t}\n\targs = append(args, arg)\n\treturn cmd, args\n}\n\nfunc isGoroutineSafe(lv LValue) bool {\n\tswitch v := lv.(type) {\n\tcase *LFunction, *LUserData, *LState:\n\t\treturn false\n\tcase *LTable:\n\t\treturn v.Metatable == LNil\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc readBufioSize(reader *bufio.Reader, size int64) ([]byte, error, bool) {\n\tresult := []byte{}\n\tread := int64(0)\n\tvar err error\n\tvar n int\n\tfor read != size {\n\t\tbuf := make([]byte, size-read)\n\t\tn, err = reader.Read(buf)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tread += int64(n)\n\t\tresult = append(result, buf[:n]...)\n\t}\n\te := err\n\tif e != nil && e == io.EOF {\n\t\te = nil\n\t}\n\n\treturn result, e, len(result) == 0 && err == io.EOF\n}\n\nfunc readBufioLine(reader *bufio.Reader) ([]byte, error, bool) {\n\tresult := []byte{}\n\tvar buf []byte\n\tvar err error\n\tvar isprefix bool = true\n\tfor isprefix {\n\t\tbuf, isprefix, err = reader.ReadLine()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tresult = append(result, buf...)\n\t}\n\te := err\n\tif e != nil && e == io.EOF {\n\t\te = nil\n\t}\n\n\treturn result, e, len(result) == 0 && err == io.EOF\n}\n\nfunc int2Fb(val int) int {\n\te := 0\n\tx := val\n\tfor x >= 16 {\n\t\tx = (x + 1) >> 1\n\t\te++\n\t}\n\tif x < 8 {\n\t\treturn x\n\t}\n\treturn ((e + 1) << 3) | (x - 8)\n}\n\nfunc strCmp(s1, s2 string) int {\n\tlen1 := len(s1)\n\tlen2 := len(s2)\n\tfor i := 0; ; i++ {\n\t\tc1 := -1\n\t\tif i < len1 {\n\t\t\tc1 = int(s1[i])\n\t\t}\n\t\tc2 := -1\n\t\tif i != len2 {\n\t\t\tc2 = int(s2[i])\n\t\t}\n\t\tswitch {\n\t\tcase c1 < c2:\n\t\t\treturn -1\n\t\tcase c1 > c2:\n\t\t\treturn +1\n\t\tcase c1 < 0:\n\t\t\treturn 0\n\t\t}\n\t}\n}\n\nfunc unsafeFastStringToReadOnlyBytes(s string) (bs []byte) {\n\tsh := (*reflect.StringHeader)(unsafe.Pointer(&s))\n\tbh := (*reflect.SliceHeader)(unsafe.Pointer(&bs))\n\tbh.Data = sh.Data\n\tbh.Cap = sh.Len\n\tbh.Len = sh.Len\n\treturn\n}\n"
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 4.5302734375,
          "content": "package lua\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype LValueType int\n\nconst (\n\tLTNil LValueType = iota\n\tLTBool\n\tLTNumber\n\tLTString\n\tLTFunction\n\tLTUserData\n\tLTThread\n\tLTTable\n\tLTChannel\n)\n\nvar lValueNames = [9]string{\"nil\", \"boolean\", \"number\", \"string\", \"function\", \"userdata\", \"thread\", \"table\", \"channel\"}\n\nfunc (vt LValueType) String() string {\n\treturn lValueNames[int(vt)]\n}\n\ntype LValue interface {\n\tString() string\n\tType() LValueType\n}\n\n// LVIsFalse returns true if a given LValue is a nil or false otherwise false.\nfunc LVIsFalse(v LValue) bool { return v == LNil || v == LFalse }\n\n// LVIsFalse returns false if a given LValue is a nil or false otherwise true.\nfunc LVAsBool(v LValue) bool { return v != LNil && v != LFalse }\n\n// LVAsString returns string representation of a given LValue\n// if the LValue is a string or number, otherwise an empty string.\nfunc LVAsString(v LValue) string {\n\tswitch sn := v.(type) {\n\tcase LString, LNumber:\n\t\treturn sn.String()\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// LVCanConvToString returns true if a given LValue is a string or number\n// otherwise false.\nfunc LVCanConvToString(v LValue) bool {\n\tswitch v.(type) {\n\tcase LString, LNumber:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// LVAsNumber tries to convert a given LValue to a number.\nfunc LVAsNumber(v LValue) LNumber {\n\tswitch lv := v.(type) {\n\tcase LNumber:\n\t\treturn lv\n\tcase LString:\n\t\tif num, err := parseNumber(string(lv)); err == nil {\n\t\t\treturn num\n\t\t}\n\t}\n\treturn LNumber(0)\n}\n\ntype LNilType struct{}\n\nfunc (nl *LNilType) String() string   { return \"nil\" }\nfunc (nl *LNilType) Type() LValueType { return LTNil }\n\nvar LNil = LValue(&LNilType{})\n\ntype LBool bool\n\nfunc (bl LBool) String() string {\n\tif bool(bl) {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\nfunc (bl LBool) Type() LValueType { return LTBool }\n\nvar LTrue = LBool(true)\nvar LFalse = LBool(false)\n\ntype LString string\n\nfunc (st LString) String() string   { return string(st) }\nfunc (st LString) Type() LValueType { return LTString }\n\n// fmt.Formatter interface\nfunc (st LString) Format(f fmt.State, c rune) {\n\tswitch c {\n\tcase 'd', 'i':\n\t\tif nm, err := parseNumber(string(st)); err != nil {\n\t\t\tdefaultFormat(nm, f, 'd')\n\t\t} else {\n\t\t\tdefaultFormat(string(st), f, 's')\n\t\t}\n\tdefault:\n\t\tdefaultFormat(string(st), f, c)\n\t}\n}\n\nfunc (nm LNumber) String() string {\n\tif isInteger(nm) {\n\t\treturn fmt.Sprint(int64(nm))\n\t}\n\treturn fmt.Sprint(float64(nm))\n}\n\nfunc (nm LNumber) Type() LValueType { return LTNumber }\n\n// fmt.Formatter interface\nfunc (nm LNumber) Format(f fmt.State, c rune) {\n\tswitch c {\n\tcase 'q', 's':\n\t\tdefaultFormat(nm.String(), f, c)\n\tcase 'b', 'c', 'd', 'o', 'x', 'X', 'U':\n\t\tdefaultFormat(int64(nm), f, c)\n\tcase 'e', 'E', 'f', 'F', 'g', 'G':\n\t\tdefaultFormat(float64(nm), f, c)\n\tcase 'i':\n\t\tdefaultFormat(int64(nm), f, 'd')\n\tdefault:\n\t\tif isInteger(nm) {\n\t\t\tdefaultFormat(int64(nm), f, c)\n\t\t} else {\n\t\t\tdefaultFormat(float64(nm), f, c)\n\t\t}\n\t}\n}\n\ntype LTable struct {\n\tMetatable LValue\n\n\tarray   []LValue\n\tdict    map[LValue]LValue\n\tstrdict map[string]LValue\n\tkeys    []LValue\n\tk2i     map[LValue]int\n}\n\nfunc (tb *LTable) String() string   { return fmt.Sprintf(\"table: %p\", tb) }\nfunc (tb *LTable) Type() LValueType { return LTTable }\n\ntype LFunction struct {\n\tIsG       bool\n\tEnv       *LTable\n\tProto     *FunctionProto\n\tGFunction LGFunction\n\tUpvalues  []*Upvalue\n}\ntype LGFunction func(*LState) int\n\nfunc (fn *LFunction) String() string   { return fmt.Sprintf(\"function: %p\", fn) }\nfunc (fn *LFunction) Type() LValueType { return LTFunction }\n\ntype Global struct {\n\tMainThread    *LState\n\tCurrentThread *LState\n\tRegistry      *LTable\n\tGlobal        *LTable\n\n\tbuiltinMts map[int]LValue\n\ttempFiles  []*os.File\n\tgccount    int32\n}\n\ntype LState struct {\n\tG       *Global\n\tParent  *LState\n\tEnv     *LTable\n\tPanic   func(*LState)\n\tDead    bool\n\tOptions Options\n\n\tstop         int32\n\treg          *registry\n\tstack        callFrameStack\n\talloc        *allocator\n\tcurrentFrame *callFrame\n\twrapped      bool\n\tuvcache      *Upvalue\n\thasErrorFunc bool\n\tmainLoop     func(*LState, *callFrame)\n\tctx          context.Context\n\tctxCancelFn  context.CancelFunc\n}\n\nfunc (ls *LState) String() string   { return fmt.Sprintf(\"thread: %p\", ls) }\nfunc (ls *LState) Type() LValueType { return LTThread }\n\ntype LUserData struct {\n\tValue     interface{}\n\tEnv       *LTable\n\tMetatable LValue\n}\n\nfunc (ud *LUserData) String() string   { return fmt.Sprintf(\"userdata: %p\", ud) }\nfunc (ud *LUserData) Type() LValueType { return LTUserData }\n\ntype LChannel chan LValue\n\nfunc (ch LChannel) String() string   { return fmt.Sprintf(\"channel: %p\", ch) }\nfunc (ch LChannel) Type() LValueType { return LTChannel }\n"
        },
        {
          "name": "vm.go",
          "type": "blob",
          "size": 65.3525390625,
          "content": "package lua\n\n////////////////////////////////////////////////////////\n// This file was generated by go-inline. DO NOT EDIT. //\n////////////////////////////////////////////////////////\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\nfunc mainLoop(L *LState, baseframe *callFrame) {\n\tvar inst uint32\n\tvar cf *callFrame\n\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tL.currentFrame = L.stack.Last()\n\tif L.currentFrame.Fn.IsG {\n\t\tcallGFunction(L, false)\n\t\treturn\n\t}\n\n\tfor {\n\t\tcf = L.currentFrame\n\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\tcf.Pc++\n\t\tif jumpTable[int(inst>>26)](L, inst, baseframe) == 1 {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc mainLoopWithContext(L *LState, baseframe *callFrame) {\n\tvar inst uint32\n\tvar cf *callFrame\n\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tL.currentFrame = L.stack.Last()\n\tif L.currentFrame.Fn.IsG {\n\t\tcallGFunction(L, false)\n\t\treturn\n\t}\n\n\tfor {\n\t\tcf = L.currentFrame\n\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\tcf.Pc++\n\t\tselect {\n\t\tcase <-L.ctx.Done():\n\t\t\tL.RaiseError(L.ctx.Err().Error())\n\t\t\treturn\n\t\tdefault:\n\t\t\tif jumpTable[int(inst>>26)](L, inst, baseframe) == 1 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// regv is the first target register to copy the return values to.\n// It can be reg.top, indicating that the copied values are going into new registers, or it can be below reg.top\n// Indicating that the values should be within the existing registers.\n// b is the available number of return values + 1.\n// n is the desired number of return values.\n// If n more than the available return values then the extra values are set to nil.\n// When this function returns the top of the registry will be set to regv+n.\nfunc copyReturnValues(L *LState, regv, start, n, b int) { // +inline-start\n\tif b == 1 {\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t{\n\t\t\trg := L.reg\n\t\t\tregm := regv\n\t\t\tnewSize := regm + n\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\trg.array[regm+i] = LNil\n\t\t\t}\n\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\toldtop := rg.top\n\t\t\trg.top = regm + n\n\t\t\tif rg.top < oldtop {\n\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\tfor i := range nilRange {\n\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t\t{\n\t\t\trg := L.reg\n\t\t\tlimit := -1\n\t\t\tnewSize := regv + n\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif limit == -1 || limit > rg.top {\n\t\t\t\tlimit = rg.top\n\t\t\t}\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tsrcIdx := start + i\n\t\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\t\trg.array[regv+i] = LNil\n\t\t\t\t} else {\n\t\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\toldtop := rg.top\n\t\t\trg.top = regv + n\n\t\t\tif rg.top < oldtop {\n\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\tfor i := range nilRange {\n\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif b > 1 && n > (b-1) {\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := L.reg\n\t\t\t\tregm := regv + b - 1\n\t\t\t\tn := n - (b - 1)\n\t\t\t\tnewSize := regm + n\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\trg.array[regm+i] = LNil\n\t\t\t\t}\n\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\toldtop := rg.top\n\t\t\t\trg.top = regm + n\n\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} // +inline-end\n\nfunc switchToParentThread(L *LState, nargs int, haserror bool, kill bool) {\n\tparent := L.Parent\n\tif parent == nil {\n\t\tL.RaiseError(\"can not yield from outside of a coroutine\")\n\t}\n\tL.G.CurrentThread = parent\n\tL.Parent = nil\n\tif !L.wrapped {\n\t\tif haserror {\n\t\t\tparent.Push(LFalse)\n\t\t} else {\n\t\t\tparent.Push(LTrue)\n\t\t}\n\t}\n\tL.XMoveTo(parent, nargs)\n\tL.stack.Pop()\n\toffset := L.currentFrame.LocalBase - L.currentFrame.ReturnBase\n\tL.currentFrame = L.stack.Last()\n\tL.reg.SetTop(L.reg.Top() - offset) // remove 'yield' function(including tailcalled functions)\n\tif kill {\n\t\tL.kill()\n\t}\n}\n\nfunc callGFunction(L *LState, tailcall bool) bool {\n\tframe := L.currentFrame\n\tgfnret := frame.Fn.GFunction(L)\n\tif tailcall {\n\t\tL.currentFrame = L.RemoveCallerFrame()\n\t}\n\n\tif gfnret < 0 {\n\t\tswitchToParentThread(L, L.GetTop(), false, false)\n\t\treturn true\n\t}\n\n\twantret := frame.NRet\n\tif wantret == MultRet {\n\t\twantret = gfnret\n\t}\n\n\tif tailcall && L.Parent != nil && L.stack.Sp() == 1 {\n\t\tswitchToParentThread(L, wantret, false, true)\n\t\treturn true\n\t}\n\n\t// this section is inlined by go-inline\n\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t{\n\t\trg := L.reg\n\t\tregv := frame.ReturnBase\n\t\tstart := L.reg.Top() - gfnret\n\t\tlimit := -1\n\t\tn := wantret\n\t\tnewSize := regv + n\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t{\n\t\t\trequiredSize := newSize\n\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\trg.resize(requiredSize)\n\t\t\t}\n\t\t}\n\t\tif limit == -1 || limit > rg.top {\n\t\t\tlimit = rg.top\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tsrcIdx := start + i\n\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\trg.array[regv+i] = LNil\n\t\t\t} else {\n\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t}\n\t\t}\n\n\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\toldtop := rg.top\n\t\trg.top = regv + n\n\t\tif rg.top < oldtop {\n\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\tfor i := range nilRange {\n\t\t\t\tnilRange[i] = nil\n\t\t\t}\n\t\t}\n\t}\n\tL.stack.Pop()\n\tL.currentFrame = L.stack.Last()\n\treturn false\n}\n\nfunc threadRun(L *LState) {\n\tif L.stack.IsEmpty() {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tif rcv := recover(); rcv != nil {\n\t\t\tvar lv LValue\n\t\t\tif v, ok := rcv.(*ApiError); ok {\n\t\t\t\tlv = v.Object\n\t\t\t} else {\n\t\t\t\tlv = LString(fmt.Sprint(rcv))\n\t\t\t}\n\t\t\tif parent := L.Parent; parent != nil {\n\t\t\t\tif L.wrapped {\n\t\t\t\t\tL.Push(lv)\n\t\t\t\t\tparent.Panic(L)\n\t\t\t\t} else {\n\t\t\t\t\tL.SetTop(0)\n\t\t\t\t\tL.Push(lv)\n\t\t\t\t\tswitchToParentThread(L, 1, true, true)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(rcv)\n\t\t\t}\n\t\t}\n\t}()\n\tL.mainLoop(L, nil)\n}\n\ntype instFunc func(*LState, uint32, *callFrame) int\n\nvar jumpTable [opCodeMax + 1]instFunc\n\nfunc init() {\n\tjumpTable = [opCodeMax + 1]instFunc{\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_MOVE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tv := reg.Get(lbase + B)\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_MOVEN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := reg.Get(lbase + B)\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := lbase + A\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode := cf.Fn.Proto.Code\n\t\t\tpc := cf.Pc\n\t\t\tfor i := 0; i < C; i++ {\n\t\t\t\tinst = code[pc]\n\t\t\t\tpc++\n\t\t\t\tA = int(inst>>18) & 0xff //GETA\n\t\t\t\tB = int(inst & 0x1ff)    //GETB\n\t\t\t\tv := reg.Get(lbase + B)\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := lbase + A\n\t\t\t\t\tvali := v\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcf.Pc = pc\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADK\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\tv := cf.Fn.Proto.Constants[Bx]\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADBOOL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif B != 0 {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := LTrue\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := LFalse\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif C != 0 {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LOADNIL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tfor i := RA; i <= lbase+B; i++ {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := i\n\t\t\t\t\tvali := LNil\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETUPVAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tv := cf.Fn.Upvalues[B].Value()\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETGLOBAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\t//reg.Set(RA, L.getField(cf.Fn.Env, cf.Fn.Proto.Constants[Bx]))\n\t\t\tv := L.getFieldString(cf.Fn.Env, cf.Fn.Proto.stringConstants[Bx])\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := L.getField(reg.Get(lbase+B), L.rkValue(C))\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_GETTABLEKS\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := L.getFieldString(reg.Get(lbase+B), L.rkString(C))\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETGLOBAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\t//L.setField(cf.Fn.Env, cf.Fn.Proto.Constants[Bx], reg.Get(RA))\n\t\t\tL.setFieldString(cf.Fn.Env, cf.Fn.Proto.stringConstants[Bx], reg.Get(RA))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETUPVAL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tcf.Fn.Upvalues[B].SetValue(reg.Get(RA))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tL.setField(reg.Get(RA), L.rkValue(B), L.rkValue(C))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETTABLEKS\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tL.setFieldString(reg.Get(RA), L.rkString(B), L.rkValue(C))\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NEWTABLE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tv := newLTable(B, C)\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SELF\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tselfobj := reg.Get(lbase + B)\n\t\t\tv := L.getFieldString(selfobj, L.rkString(C))\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA + 1\n\t\t\t\tvali := selfobj\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\topArith, // OP_ADD\n\t\topArith, // OP_SUB\n\t\topArith, // OP_MUL\n\t\topArith, // OP_DIV\n\t\topArith, // OP_MOD\n\t\topArith, // OP_POW\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_UNM\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tunaryv := L.rkValue(B)\n\t\t\tif nm, ok := unaryv.(LNumber); ok {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := -nm\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\top := L.metaOp1(unaryv, \"__unm\")\n\t\t\t\tif op.Type() == LTFunction {\n\t\t\t\t\treg.Push(op)\n\t\t\t\t\treg.Push(unaryv)\n\t\t\t\t\tL.Call(1, 1)\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trg := reg\n\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\tvali := reg.Pop()\n\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if str, ok1 := unaryv.(LString); ok1 {\n\t\t\t\t\tif num, err := parseNumber(string(str)); err == nil {\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\t\tvali := -num\n\t\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tL.RaiseError(\"__unm undefined\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"__unm undefined\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NOT\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tif LVIsFalse(reg.Get(lbase + B)) {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := LTrue\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := LFalse\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LEN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tswitch lv := L.rkValue(B).(type) {\n\t\t\tcase LString:\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := LNumber(len(lv))\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\top := L.metaOp1(lv, \"__len\")\n\t\t\t\tif op.Type() == LTFunction {\n\t\t\t\t\treg.Push(op)\n\t\t\t\t\treg.Push(lv)\n\t\t\t\t\tL.Call(1, 1)\n\t\t\t\t\tret := reg.Pop()\n\t\t\t\t\tif ret.Type() == LTNumber {\n\t\t\t\t\t\tv, _ := ret.(LNumber)\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\t\tvali := v\n\t\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\t\tvali := ret\n\t\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if lv.Type() == LTTable {\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trg := reg\n\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\tvali := LNumber(lv.(*LTable).Len())\n\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"__len undefined\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CONCAT\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tRC := lbase + C\n\t\t\tRB := lbase + B\n\t\t\tv := stringConcat(L, RC-RB+1, RC)\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := v\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_JMP\n\t\t\tcf := L.currentFrame\n\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\tcf.Pc += Sbx\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_EQ\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tret := equals(L, L.rkValue(B), L.rkValue(C), false)\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LT\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tret := lessThan(L, L.rkValue(B), L.rkValue(C))\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_LE\n\t\t\tcf := L.currentFrame\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tlhs := L.rkValue(B)\n\t\t\trhs := L.rkValue(C)\n\t\t\tret := false\n\n\t\t\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\t\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\t\t\tret = v1 <= v2\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif lhs.Type() != rhs.Type() {\n\t\t\t\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\t}\n\t\t\t\tswitch lhs.Type() {\n\t\t\t\tcase LTString:\n\t\t\t\t\tret = strCmp(string(lhs.(LString)), string(rhs.(LString))) <= 0\n\t\t\t\tdefault:\n\t\t\t\t\tswitch objectRational(L, lhs, rhs, \"__le\") {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tret = true\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tret = false\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tret = !objectRationalWithError(L, rhs, lhs, \"__lt\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv := 1\n\t\t\tif ret {\n\t\t\t\tv = 0\n\t\t\t}\n\t\t\tif v == A {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TEST\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif LVAsBool(reg.Get(RA)) == (C == 0) {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TESTSET\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif value := reg.Get(lbase + B); LVAsBool(value) != (C == 0) {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA\n\t\t\t\t\tvali := value\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CALL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tnargs := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnargs = reg.Top() - (RA + 1)\n\t\t\t}\n\t\t\tlv := reg.Get(RA)\n\t\t\tnret := C - 1\n\t\t\tvar callable *LFunction\n\t\t\tvar meta bool\n\t\t\tif fn, ok := lv.(*LFunction); ok {\n\t\t\t\tcallable = fn\n\t\t\t\tmeta = false\n\t\t\t} else {\n\t\t\t\tcallable, meta = L.metaCall(lv)\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (ls *LState) pushCallFrame(cf callFrame, fn LValue, meta bool) ' in '_state.go'\n\t\t\t{\n\t\t\t\tls := L\n\t\t\t\tcf := callFrame{Fn: callable, Pc: 0, Base: RA, LocalBase: RA + 1, ReturnBase: RA, NArgs: nargs, NRet: nret, Parent: cf, TailCall: 0}\n\t\t\t\tfn := lv\n\t\t\t\tif meta {\n\t\t\t\t\tcf.NArgs++\n\t\t\t\t\tls.reg.Insert(fn, cf.LocalBase)\n\t\t\t\t}\n\t\t\t\tif cf.Fn == nil {\n\t\t\t\t\tls.RaiseError(\"attempt to call a non-function object\")\n\t\t\t\t}\n\t\t\t\tif ls.stack.IsFull() {\n\t\t\t\t\tls.RaiseError(\"stack overflow\")\n\t\t\t\t}\n\t\t\t\tls.stack.Push(cf)\n\t\t\t\tnewcf := ls.stack.Last()\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (ls *LState) initCallFrame(cf *callFrame) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\tcf := newcf\n\t\t\t\t\tif cf.Fn.IsG {\n\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + cf.NArgs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto := cf.Fn.Proto\n\t\t\t\t\t\tnargs := cf.NArgs\n\t\t\t\t\t\tnp := int(proto.NumParameters)\n\t\t\t\t\t\tif nargs < np {\n\t\t\t\t\t\t\t// default any missing arguments to nil\n\t\t\t\t\t\t\tnewSize := cf.LocalBase + np\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := ls.reg\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := nargs; i < np; i++ {\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnargs = np\n\t\t\t\t\t\t\tls.reg.top = newSize\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (proto.IsVarArg & VarArgIsVarArg) == 0 {\n\t\t\t\t\t\t\tif nargs < int(proto.NumUsedRegisters) {\n\t\t\t\t\t\t\t\tnargs = int(proto.NumUsedRegisters)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewSize := cf.LocalBase + nargs\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := ls.reg\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := np; i < nargs; i++ {\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tls.reg.top = cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* swap vararg positions:\n\t\t\t\t\t\t\t\t\t   closure\n\t\t\t\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t\t\t\t   namedparam2\n\t\t\t\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t\t\t\t   vararg2\n\n\t\t\t\t\t\t\t           TO\n\n\t\t\t\t\t\t\t\t\t   closure\n\t\t\t\t\t\t\t\t\t   nil\n\t\t\t\t\t\t\t\t\t   nil\n\t\t\t\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t\t\t\t   vararg2\n\t\t\t\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t\t\t\t   namedparam2\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tnvarargs := nargs - np\n\t\t\t\t\t\t\tif nvarargs < 0 {\n\t\t\t\t\t\t\t\tnvarargs = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np)\n\t\t\t\t\t\t\tfor i := 0; i < np; i++ {\n\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+i, ls.reg.Get(cf.LocalBase+i))\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+i] = ls.reg.array[cf.LocalBase+i]\n\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+i, LNil)\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif CompatVarArg {\n\t\t\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np + 1)\n\t\t\t\t\t\t\t\tif (proto.IsVarArg & VarArgNeedsArg) != 0 {\n\t\t\t\t\t\t\t\t\targtb := newLTable(nvarargs, 0)\n\t\t\t\t\t\t\t\t\tfor i := 0; i < nvarargs; i++ {\n\t\t\t\t\t\t\t\t\t\targtb.RawSetInt(i+1, ls.reg.Get(cf.LocalBase+np+i))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\targtb.RawSetString(\"n\", LNumber(nvarargs))\n\t\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+np, argtb)\n\t\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = argtb\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = LNil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcf.LocalBase += nargs\n\t\t\t\t\t\t\tmaxreg := cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t\t\t\t\tls.reg.SetTop(maxreg)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tls.currentFrame = newcf\n\t\t\t}\n\t\t\tif callable.IsG && callGFunction(L, false) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TAILCALL\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tnargs := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnargs = reg.Top() - (RA + 1)\n\t\t\t}\n\t\t\tlv := reg.Get(RA)\n\t\t\tvar callable *LFunction\n\t\t\tvar meta bool\n\t\t\tif fn, ok := lv.(*LFunction); ok {\n\t\t\t\tcallable = fn\n\t\t\t\tmeta = false\n\t\t\t} else {\n\t\t\t\tcallable, meta = L.metaCall(lv)\n\t\t\t}\n\t\t\tif callable == nil {\n\t\t\t\tL.RaiseError(\"attempt to call a non-function object\")\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (ls *LState) closeUpvalues(idx int) ' in '_state.go'\n\t\t\t{\n\t\t\t\tls := L\n\t\t\t\tidx := lbase\n\t\t\t\tif ls.uvcache != nil {\n\t\t\t\t\tvar prev *Upvalue\n\t\t\t\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\t\t\t\tif uv.index >= idx {\n\t\t\t\t\t\t\tif prev != nil {\n\t\t\t\t\t\t\t\tprev.next = nil\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tls.uvcache = nil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuv.Close()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = uv\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif callable.IsG {\n\t\t\t\tluaframe := cf\n\t\t\t\tL.pushCallFrame(callFrame{\n\t\t\t\t\tFn:         callable,\n\t\t\t\t\tPc:         0,\n\t\t\t\t\tBase:       RA,\n\t\t\t\t\tLocalBase:  RA + 1,\n\t\t\t\t\tReturnBase: cf.ReturnBase,\n\t\t\t\t\tNArgs:      nargs,\n\t\t\t\t\tNRet:       cf.NRet,\n\t\t\t\t\tParent:     cf,\n\t\t\t\t\tTailCall:   0,\n\t\t\t\t}, lv, meta)\n\t\t\t\tif callGFunction(L, true) {\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t\tif L.currentFrame == nil || L.currentFrame.Fn.IsG || luaframe == baseframe {\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbase := cf.Base\n\t\t\t\tcf.Fn = callable\n\t\t\t\tcf.Pc = 0\n\t\t\t\tcf.Base = RA\n\t\t\t\tcf.LocalBase = RA + 1\n\t\t\t\tcf.ReturnBase = cf.ReturnBase\n\t\t\t\tcf.NArgs = nargs\n\t\t\t\tcf.NRet = cf.NRet\n\t\t\t\tcf.TailCall++\n\t\t\t\tlbase := cf.LocalBase\n\t\t\t\tif meta {\n\t\t\t\t\tcf.NArgs++\n\t\t\t\t\tL.reg.Insert(lv, cf.LocalBase)\n\t\t\t\t}\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (ls *LState) initCallFrame(cf *callFrame) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\tls := L\n\t\t\t\t\tif cf.Fn.IsG {\n\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + cf.NArgs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto := cf.Fn.Proto\n\t\t\t\t\t\tnargs := cf.NArgs\n\t\t\t\t\t\tnp := int(proto.NumParameters)\n\t\t\t\t\t\tif nargs < np {\n\t\t\t\t\t\t\t// default any missing arguments to nil\n\t\t\t\t\t\t\tnewSize := cf.LocalBase + np\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := ls.reg\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := nargs; i < np; i++ {\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnargs = np\n\t\t\t\t\t\t\tls.reg.top = newSize\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (proto.IsVarArg & VarArgIsVarArg) == 0 {\n\t\t\t\t\t\t\tif nargs < int(proto.NumUsedRegisters) {\n\t\t\t\t\t\t\t\tnargs = int(proto.NumUsedRegisters)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewSize := cf.LocalBase + nargs\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := ls.reg\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := np; i < nargs; i++ {\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tls.reg.top = cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* swap vararg positions:\n\t\t\t\t\t\t\t\t\t   closure\n\t\t\t\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t\t\t\t   namedparam2\n\t\t\t\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t\t\t\t   vararg2\n\n\t\t\t\t\t\t\t           TO\n\n\t\t\t\t\t\t\t\t\t   closure\n\t\t\t\t\t\t\t\t\t   nil\n\t\t\t\t\t\t\t\t\t   nil\n\t\t\t\t\t\t\t\t\t   vararg1\n\t\t\t\t\t\t\t\t\t   vararg2\n\t\t\t\t\t\t\t\t\t   namedparam1 <- lbase\n\t\t\t\t\t\t\t\t\t   namedparam2\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tnvarargs := nargs - np\n\t\t\t\t\t\t\tif nvarargs < 0 {\n\t\t\t\t\t\t\t\tnvarargs = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np)\n\t\t\t\t\t\t\tfor i := 0; i < np; i++ {\n\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+i, ls.reg.Get(cf.LocalBase+i))\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+i] = ls.reg.array[cf.LocalBase+i]\n\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+i, LNil)\n\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+i] = LNil\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif CompatVarArg {\n\t\t\t\t\t\t\t\tls.reg.SetTop(cf.LocalBase + nargs + np + 1)\n\t\t\t\t\t\t\t\tif (proto.IsVarArg & VarArgNeedsArg) != 0 {\n\t\t\t\t\t\t\t\t\targtb := newLTable(nvarargs, 0)\n\t\t\t\t\t\t\t\t\tfor i := 0; i < nvarargs; i++ {\n\t\t\t\t\t\t\t\t\t\targtb.RawSetInt(i+1, ls.reg.Get(cf.LocalBase+np+i))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\targtb.RawSetString(\"n\", LNumber(nvarargs))\n\t\t\t\t\t\t\t\t\t//ls.reg.Set(cf.LocalBase+nargs+np, argtb)\n\t\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = argtb\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tls.reg.array[cf.LocalBase+nargs+np] = LNil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcf.LocalBase += nargs\n\t\t\t\t\t\t\tmaxreg := cf.LocalBase + int(proto.NumUsedRegisters)\n\t\t\t\t\t\t\tls.reg.SetTop(maxreg)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := L.reg\n\t\t\t\t\tregv := base\n\t\t\t\t\tstart := RA\n\t\t\t\t\tlimit := -1\n\t\t\t\t\tn := reg.Top() - RA - 1\n\t\t\t\t\tnewSize := regv + n\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif limit == -1 || limit > rg.top {\n\t\t\t\t\t\tlimit = rg.top\n\t\t\t\t\t}\n\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\tsrcIdx := start + i\n\t\t\t\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\t\t\t\trg.array[regv+i] = LNil\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\toldtop := rg.top\n\t\t\t\t\trg.top = regv + n\n\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcf.Base = base\n\t\t\t\tcf.LocalBase = base + (cf.LocalBase - lbase + 1)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_RETURN\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (ls *LState) closeUpvalues(idx int) ' in '_state.go'\n\t\t\t{\n\t\t\t\tls := L\n\t\t\t\tidx := lbase\n\t\t\t\tif ls.uvcache != nil {\n\t\t\t\t\tvar prev *Upvalue\n\t\t\t\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\t\t\t\tif uv.index >= idx {\n\t\t\t\t\t\t\tif prev != nil {\n\t\t\t\t\t\t\t\tprev.next = nil\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tls.uvcache = nil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuv.Close()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = uv\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnret := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnret = reg.Top() - RA\n\t\t\t}\n\t\t\tn := cf.NRet\n\t\t\tif cf.NRet == MultRet {\n\t\t\t\tn = nret\n\t\t\t}\n\n\t\t\tif L.Parent != nil && L.stack.Sp() == 1 {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func copyReturnValues(L *LState, regv, start, n, b int) ' in '_vm.go'\n\t\t\t\t{\n\t\t\t\t\tregv := reg.Top()\n\t\t\t\t\tstart := RA\n\t\t\t\t\tb := B\n\t\t\t\t\tif b == 1 {\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\t\tregm := regv\n\t\t\t\t\t\t\tnewSize := regm + n\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\t\trg.array[regm+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\t\trg.top = regm + n\n\t\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\t\tlimit := -1\n\t\t\t\t\t\t\tnewSize := regv + n\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif limit == -1 || limit > rg.top {\n\t\t\t\t\t\t\t\tlimit = rg.top\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\t\tsrcIdx := start + i\n\t\t\t\t\t\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\t\t\t\t\t\trg.array[regv+i] = LNil\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\t\trg.top = regv + n\n\t\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif b > 1 && n > (b-1) {\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\t\t\tregm := regv + b - 1\n\t\t\t\t\t\t\t\tn := n - (b - 1)\n\t\t\t\t\t\t\t\tnewSize := regm + n\n\t\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\t\t\trg.array[regm+i] = LNil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\t\t\trg.top = regm + n\n\t\t\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitchToParentThread(L, n, false, true)\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tislast := baseframe == L.stack.Pop() || L.stack.IsEmpty()\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func copyReturnValues(L *LState, regv, start, n, b int) ' in '_vm.go'\n\t\t\t{\n\t\t\t\tregv := cf.ReturnBase\n\t\t\t\tstart := RA\n\t\t\t\tb := B\n\t\t\t\tif b == 1 {\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\tregm := regv\n\t\t\t\t\t\tnewSize := regm + n\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\trg.array[regm+i] = LNil\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\trg.top = regm + n\n\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\tlimit := -1\n\t\t\t\t\t\tnewSize := regv + n\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif limit == -1 || limit > rg.top {\n\t\t\t\t\t\t\tlimit = rg.top\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\tsrcIdx := start + i\n\t\t\t\t\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\t\t\t\t\trg.array[regv+i] = LNil\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\trg.top = regv + n\n\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif b > 1 && n > (b-1) {\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) FillNil(regm, n int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := L.reg\n\t\t\t\t\t\t\tregm := regv + b - 1\n\t\t\t\t\t\t\tn := n - (b - 1)\n\t\t\t\t\t\t\tnewSize := regm + n\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\t\t\t\trg.array[regm+i] = LNil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\t\toldtop := rg.top\n\t\t\t\t\t\t\trg.top = regm + n\n\t\t\t\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tL.currentFrame = L.stack.Last()\n\t\t\tif islast || L.currentFrame == nil || L.currentFrame.Fn.IsG {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_FORLOOP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tif init, ok1 := reg.Get(RA).(LNumber); ok1 {\n\t\t\t\tif limit, ok2 := reg.Get(RA + 1).(LNumber); ok2 {\n\t\t\t\t\tif step, ok3 := reg.Get(RA + 2).(LNumber); ok3 {\n\t\t\t\t\t\tinit += step\n\t\t\t\t\t\tv := LNumber(init)\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\t\tvali := v\n\t\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step > 0 && init <= limit) || (step <= 0 && init >= limit) {\n\t\t\t\t\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\t\t\t\t\tcf.Pc += Sbx\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\t\tregi := RA + 3\n\t\t\t\t\t\t\t\tvali := v\n\t\t\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t// source function is 'func (rg *registry) SetTop(topi int) ' in '_state.go'\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trg := reg\n\t\t\t\t\t\t\t\ttopi := RA + 1\n\t\t\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequiredSize := topi\n\t\t\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\toldtopi := rg.top\n\t\t\t\t\t\t\t\trg.top = topi\n\t\t\t\t\t\t\t\tfor i := oldtopi; i < rg.top; i++ {\n\t\t\t\t\t\t\t\t\trg.array[i] = LNil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\t\t\t\t\tif rg.top < oldtopi {\n\t\t\t\t\t\t\t\t\tnilRange := rg.array[rg.top:oldtopi]\n\t\t\t\t\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//for i := rg.top; i < oldtop; i++ {\n\t\t\t\t\t\t\t\t//\trg.array[i] = LNil\n\t\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tL.RaiseError(\"for statement step must be a number\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"for statement limit must be a number\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"for statement init must be a number\")\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_FORPREP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tSbx := int(inst&0x3ffff) - opMaxArgSbx //GETSBX\n\t\t\tif init, ok1 := reg.Get(RA).(LNumber); ok1 {\n\t\t\t\tif step, ok2 := reg.Get(RA + 2).(LNumber); ok2 {\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trg := reg\n\t\t\t\t\t\tregi := RA\n\t\t\t\t\t\tvali := LNumber(init - step)\n\t\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tL.RaiseError(\"for statement step must be a number\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"for statement init must be a number\")\n\t\t\t}\n\t\t\tcf.Pc += Sbx\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_TFORLOOP\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tnret := C\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) SetTop(topi int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\ttopi := RA + 3 + 2\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := topi\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toldtopi := rg.top\n\t\t\t\trg.top = topi\n\t\t\t\tfor i := oldtopi; i < rg.top; i++ {\n\t\t\t\t\trg.array[i] = LNil\n\t\t\t\t}\n\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\tif rg.top < oldtopi {\n\t\t\t\t\tnilRange := rg.array[rg.top:oldtopi]\n\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//for i := rg.top; i < oldtop; i++ {\n\t\t\t\t//\trg.array[i] = LNil\n\t\t\t\t//}\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA + 3 + 2\n\t\t\t\tvali := reg.Get(RA + 2)\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA + 3 + 1\n\t\t\t\tvali := reg.Get(RA + 1)\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA + 3\n\t\t\t\tvali := reg.Get(RA)\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tL.callR(2, nret, RA+3)\n\t\t\tif value := reg.Get(RA + 3); value != LNil {\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trg := reg\n\t\t\t\t\tregi := RA + 2\n\t\t\t\t\tvali := value\n\t\t\t\t\tnewSize := regi + 1\n\t\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t\t{\n\t\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trg.array[regi] = vali\n\t\t\t\t\tif regi >= rg.top {\n\t\t\t\t\t\trg.top = regi + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpc := cf.Fn.Proto.Code[cf.Pc]\n\t\t\t\tcf.Pc += int(pc&0x3ffff) - opMaxArgSbx\n\t\t\t}\n\t\t\tcf.Pc++\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_SETLIST\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff)    //GETB\n\t\t\tC := int(inst>>9) & 0x1ff //GETC\n\t\t\tif C == 0 {\n\t\t\t\tC = int(cf.Fn.Proto.Code[cf.Pc])\n\t\t\t\tcf.Pc++\n\t\t\t}\n\t\t\toffset := (C - 1) * FieldsPerFlush\n\t\t\ttable := reg.Get(RA).(*LTable)\n\t\t\tnelem := B\n\t\t\tif B == 0 {\n\t\t\t\tnelem = reg.Top() - RA - 1\n\t\t\t}\n\t\t\tfor i := 1; i <= nelem; i++ {\n\t\t\t\ttable.RawSetInt(offset+i, reg.Get(RA+i))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CLOSE\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (ls *LState) closeUpvalues(idx int) ' in '_state.go'\n\t\t\t{\n\t\t\t\tls := L\n\t\t\t\tidx := RA\n\t\t\t\tif ls.uvcache != nil {\n\t\t\t\t\tvar prev *Upvalue\n\t\t\t\t\tfor uv := ls.uvcache; uv != nil; uv = uv.next {\n\t\t\t\t\t\tif uv.index >= idx {\n\t\t\t\t\t\t\tif prev != nil {\n\t\t\t\t\t\t\t\tprev.next = nil\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tls.uvcache = nil\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuv.Close()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = uv\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_CLOSURE\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tBx := int(inst & 0x3ffff) //GETBX\n\t\t\tproto := cf.Fn.Proto.FunctionPrototypes[Bx]\n\t\t\tclosure := newLFunctionL(proto, cf.Fn.Env, int(proto.NumUpvalues))\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregi := RA\n\t\t\t\tvali := closure\n\t\t\t\tnewSize := regi + 1\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trg.array[regi] = vali\n\t\t\t\tif regi >= rg.top {\n\t\t\t\t\trg.top = regi + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := 0; i < int(proto.NumUpvalues); i++ {\n\t\t\t\tinst = cf.Fn.Proto.Code[cf.Pc]\n\t\t\t\tcf.Pc++\n\t\t\t\tB := opGetArgB(inst)\n\t\t\t\tswitch opGetOpCode(inst) {\n\t\t\t\tcase OP_MOVE:\n\t\t\t\t\tclosure.Upvalues[i] = L.findUpvalue(lbase + B)\n\t\t\t\tcase OP_GETUPVAL:\n\t\t\t\t\tclosure.Upvalues[i] = cf.Fn.Upvalues[B]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_VARARG\n\t\t\treg := L.reg\n\t\t\tcf := L.currentFrame\n\t\t\tlbase := cf.LocalBase\n\t\t\tA := int(inst>>18) & 0xff //GETA\n\t\t\tRA := lbase + A\n\t\t\tB := int(inst & 0x1ff) //GETB\n\t\t\tnparams := int(cf.Fn.Proto.NumParameters)\n\t\t\tnvarargs := cf.NArgs - nparams\n\t\t\tif nvarargs < 0 {\n\t\t\t\tnvarargs = 0\n\t\t\t}\n\t\t\tnwant := B - 1\n\t\t\tif B == 0 {\n\t\t\t\tnwant = nvarargs\n\t\t\t}\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) CopyRange(regv, start, limit, n int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trg := reg\n\t\t\t\tregv := RA\n\t\t\t\tstart := cf.Base + nparams + 1\n\t\t\t\tlimit := cf.LocalBase\n\t\t\t\tn := nwant\n\t\t\t\tnewSize := regv + n\n\t\t\t\t// this section is inlined by go-inline\n\t\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t\t{\n\t\t\t\t\trequiredSize := newSize\n\t\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif limit == -1 || limit > rg.top {\n\t\t\t\t\tlimit = rg.top\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\tsrcIdx := start + i\n\t\t\t\t\tif srcIdx >= limit || srcIdx < 0 {\n\t\t\t\t\t\trg.array[regv+i] = LNil\n\t\t\t\t\t} else {\n\t\t\t\t\t\trg.array[regv+i] = rg.array[srcIdx]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// values beyond top don't need to be valid LValues, so setting them to nil is fine\n\t\t\t\t// setting them to nil rather than LNil lets us invoke the golang memclr opto\n\t\t\t\toldtop := rg.top\n\t\t\t\trg.top = regv + n\n\t\t\t\tif rg.top < oldtop {\n\t\t\t\t\tnilRange := rg.array[rg.top:oldtop]\n\t\t\t\t\tfor i := range nilRange {\n\t\t\t\t\t\tnilRange[i] = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(L *LState, inst uint32, baseframe *callFrame) int { //OP_NOP\n\t\t\treturn 0\n\t\t},\n\t}\n}\n\nfunc opArith(L *LState, inst uint32, baseframe *callFrame) int { //OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_POW\n\treg := L.reg\n\tcf := L.currentFrame\n\tlbase := cf.LocalBase\n\tA := int(inst>>18) & 0xff //GETA\n\tRA := lbase + A\n\topcode := int(inst >> 26) //GETOPCODE\n\tB := int(inst & 0x1ff)    //GETB\n\tC := int(inst>>9) & 0x1ff //GETC\n\tlhs := L.rkValue(B)\n\trhs := L.rkValue(C)\n\tv1, ok1 := lhs.(LNumber)\n\tv2, ok2 := rhs.(LNumber)\n\tif ok1 && ok2 {\n\t\tv := numberArith(L, opcode, LNumber(v1), LNumber(v2))\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) SetNumber(regi int, vali LNumber) ' in '_state.go'\n\t\t{\n\t\t\trg := reg\n\t\t\tregi := RA\n\t\t\tvali := v\n\t\t\tnewSize := regi + 1\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\trg.array[regi] = rg.alloc.LNumber2I(vali)\n\t\t\tif regi >= rg.top {\n\t\t\t\trg.top = regi + 1\n\t\t\t}\n\t\t}\n\t} else {\n\t\tv := objectArith(L, opcode, lhs, rhs)\n\t\t// this section is inlined by go-inline\n\t\t// source function is 'func (rg *registry) Set(regi int, vali LValue) ' in '_state.go'\n\t\t{\n\t\t\trg := reg\n\t\t\tregi := RA\n\t\t\tvali := v\n\t\t\tnewSize := regi + 1\n\t\t\t// this section is inlined by go-inline\n\t\t\t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go'\n\t\t\t{\n\t\t\t\trequiredSize := newSize\n\t\t\t\tif requiredSize > cap(rg.array) {\n\t\t\t\t\trg.resize(requiredSize)\n\t\t\t\t}\n\t\t\t}\n\t\t\trg.array[regi] = vali\n\t\t\tif regi >= rg.top {\n\t\t\t\trg.top = regi + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc luaModulo(lhs, rhs LNumber) LNumber {\n\tflhs := float64(lhs)\n\tfrhs := float64(rhs)\n\tv := math.Mod(flhs, frhs)\n\tif frhs > 0 && v < 0 || frhs < 0 && v > 0 {\n\t\tv += frhs\n\t}\n\treturn LNumber(v)\n}\n\nfunc numberArith(L *LState, opcode int, lhs, rhs LNumber) LNumber {\n\tswitch opcode {\n\tcase OP_ADD:\n\t\treturn lhs + rhs\n\tcase OP_SUB:\n\t\treturn lhs - rhs\n\tcase OP_MUL:\n\t\treturn lhs * rhs\n\tcase OP_DIV:\n\t\treturn lhs / rhs\n\tcase OP_MOD:\n\t\treturn luaModulo(lhs, rhs)\n\tcase OP_POW:\n\t\tflhs := float64(lhs)\n\t\tfrhs := float64(rhs)\n\t\treturn LNumber(math.Pow(flhs, frhs))\n\t}\n\tpanic(\"should not reach here\")\n\treturn LNumber(0)\n}\n\nfunc objectArith(L *LState, opcode int, lhs, rhs LValue) LValue {\n\tevent := \"\"\n\tswitch opcode {\n\tcase OP_ADD:\n\t\tevent = \"__add\"\n\tcase OP_SUB:\n\t\tevent = \"__sub\"\n\tcase OP_MUL:\n\t\tevent = \"__mul\"\n\tcase OP_DIV:\n\t\tevent = \"__div\"\n\tcase OP_MOD:\n\t\tevent = \"__mod\"\n\tcase OP_POW:\n\t\tevent = \"__pow\"\n\t}\n\top := L.metaOp2(lhs, rhs, event)\n\tif _, ok := op.(*LFunction); ok {\n\t\tL.reg.Push(op)\n\t\tL.reg.Push(lhs)\n\t\tL.reg.Push(rhs)\n\t\tL.Call(2, 1)\n\t\treturn L.reg.Pop()\n\t}\n\tif str, ok := lhs.(LString); ok {\n\t\tif lnum, err := parseNumber(string(str)); err == nil {\n\t\t\tlhs = lnum\n\t\t}\n\t}\n\tif str, ok := rhs.(LString); ok {\n\t\tif rnum, err := parseNumber(string(str)); err == nil {\n\t\t\trhs = rnum\n\t\t}\n\t}\n\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\treturn numberArith(L, opcode, LNumber(v1), LNumber(v2))\n\t\t}\n\t}\n\tL.RaiseError(fmt.Sprintf(\"cannot perform %v operation between %v and %v\",\n\t\tstrings.TrimLeft(event, \"_\"), lhs.Type().String(), rhs.Type().String()))\n\n\treturn LNil\n}\n\nfunc stringConcat(L *LState, total, last int) LValue {\n\trhs := L.reg.Get(last)\n\ttotal--\n\tfor i := last - 1; total > 0; {\n\t\tlhs := L.reg.Get(i)\n\t\tif !(LVCanConvToString(lhs) && LVCanConvToString(rhs)) {\n\t\t\top := L.metaOp2(lhs, rhs, \"__concat\")\n\t\t\tif op.Type() == LTFunction {\n\t\t\t\tL.reg.Push(op)\n\t\t\t\tL.reg.Push(lhs)\n\t\t\t\tL.reg.Push(rhs)\n\t\t\t\tL.Call(2, 1)\n\t\t\t\trhs = L.reg.Pop()\n\t\t\t\ttotal--\n\t\t\t\ti--\n\t\t\t} else {\n\t\t\t\tL.RaiseError(\"cannot perform concat operation between %v and %v\", lhs.Type().String(), rhs.Type().String())\n\t\t\t\treturn LNil\n\t\t\t}\n\t\t} else {\n\t\t\tbuf := make([]string, total+1)\n\t\t\tbuf[total] = LVAsString(rhs)\n\t\t\tfor total > 0 {\n\t\t\t\tlhs = L.reg.Get(i)\n\t\t\t\tif !LVCanConvToString(lhs) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tbuf[total-1] = LVAsString(lhs)\n\t\t\t\ti--\n\t\t\t\ttotal--\n\t\t\t}\n\t\t\trhs = LString(strings.Join(buf, \"\"))\n\t\t}\n\t}\n\treturn rhs\n}\n\nfunc lessThan(L *LState, lhs, rhs LValue) bool {\n\t// optimization for numbers\n\tif v1, ok1 := lhs.(LNumber); ok1 {\n\t\tif v2, ok2 := rhs.(LNumber); ok2 {\n\t\t\treturn v1 < v2\n\t\t}\n\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t}\n\tif lhs.Type() != rhs.Type() {\n\t\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\t\treturn false\n\t}\n\tret := false\n\tswitch lhs.Type() {\n\tcase LTString:\n\t\tret = strCmp(string(lhs.(LString)), string(rhs.(LString))) < 0\n\tdefault:\n\t\tret = objectRationalWithError(L, lhs, rhs, \"__lt\")\n\t}\n\treturn ret\n}\n\nfunc equals(L *LState, lhs, rhs LValue, raw bool) bool {\n\tlt := lhs.Type()\n\tif lt != rhs.Type() {\n\t\treturn false\n\t}\n\n\tret := false\n\tswitch lt {\n\tcase LTNil:\n\t\tret = true\n\tcase LTNumber:\n\t\tv1, _ := lhs.(LNumber)\n\t\tv2, _ := rhs.(LNumber)\n\t\tret = v1 == v2\n\tcase LTBool:\n\t\tret = bool(lhs.(LBool)) == bool(rhs.(LBool))\n\tcase LTString:\n\t\tret = string(lhs.(LString)) == string(rhs.(LString))\n\tcase LTUserData, LTTable:\n\t\tif lhs == rhs {\n\t\t\tret = true\n\t\t} else if !raw {\n\t\t\tswitch objectRational(L, lhs, rhs, \"__eq\") {\n\t\t\tcase 1:\n\t\t\t\tret = true\n\t\t\tdefault:\n\t\t\t\tret = false\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tret = lhs == rhs\n\t}\n\treturn ret\n}\n\nfunc objectRationalWithError(L *LState, lhs, rhs LValue, event string) bool {\n\tswitch objectRational(L, lhs, rhs, event) {\n\tcase 1:\n\t\treturn true\n\tcase 0:\n\t\treturn false\n\t}\n\tL.RaiseError(\"attempt to compare %v with %v\", lhs.Type().String(), rhs.Type().String())\n\treturn false\n}\n\nfunc objectRational(L *LState, lhs, rhs LValue, event string) int {\n\tm1 := L.metaOp1(lhs, event)\n\tm2 := L.metaOp1(rhs, event)\n\tif m1.Type() == LTFunction && m1 == m2 {\n\t\tL.reg.Push(m1)\n\t\tL.reg.Push(lhs)\n\t\tL.reg.Push(rhs)\n\t\tL.Call(2, 1)\n\t\tif LVAsBool(L.reg.Pop()) {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t}\n\treturn -1\n}\n"
        }
      ]
    }
  ]
}