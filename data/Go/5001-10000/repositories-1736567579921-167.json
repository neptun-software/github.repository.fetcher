{
  "metadata": {
    "timestamp": 1736567579921,
    "page": 167,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dunglas/frankenphp",
      "stars": 7352,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.1494140625,
          "content": "# ignored\n**/*\n\n# authorized\n!**/Caddyfile\n!**/*.go\n!**/go.*\n!**/*.c\n!**/*.h\n!testdata/*.php\n!testdata/*.txt\n!build-static.sh\n!app.tar\n!app_checksum.txt\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1337890625,
          "content": "/caddy/frankenphp/frankenphp\n/internal/testserver/testserver\n/internal/testcli/testcli\n/dist\n.idea/\n.vscode/\n__debug_bin\nfrankenphp.test\n"
        },
        {
          "name": ".hadolint.yaml",
          "type": "blob",
          "size": 0.0556640625,
          "content": "---\nignored:\n  - DL3006\n  - DL3008\n  - DL3018\n  - DL3022\n"
        },
        {
          "name": ".markdown-lint.yaml",
          "type": "blob",
          "size": 0.048828125,
          "content": "---\nno-hard-tabs: false\nMD013: false\nMD033: false\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.154296875,
          "content": "# Contributing\n\n## Compiling PHP\n\n### With Docker (Linux)\n\nBuild the dev Docker image:\n\n```console\ndocker build -t frankenphp-dev -f dev.Dockerfile .\ndocker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -p 8080:8080 -p 443:443 -p 443:443/udp -v $PWD:/go/src/app -it frankenphp-dev\n```\n\nThe image contains the usual development tools (Go, GDB, Valgrind, Neovim...).  \n\nIf docker version is lower than 23.0, build is failed by dockerignore [pattern issue](https://github.com/moby/moby/pull/42676). Add directories to `.dockerignore`.\n\n```patch\n !testdata/*.php\n !testdata/*.txt\n+!caddy\n+!internal\n```\n\n### Without Docker (Linux and macOS)\n\n[Follow the instructions to compile from sources](https://frankenphp.dev/docs/compile/) and pass the `--debug` configuration flag.\n\n## Running the test suite\n\n```console\ngo test -tags watcher -race -v ./...\n```\n\n## Caddy module\n\nBuild Caddy with the FrankenPHP Caddy module:\n\n```console\ncd caddy/frankenphp/\ngo build -tags watcher,brotli,nobadger,nomysql,nopgx\ncd ../../\n```\n\nRun the Caddy with the FrankenPHP Caddy module:\n\n```console\ncd testdata/\n../caddy/frankenphp/frankenphp run\n```\n\nThe server is listening on `127.0.0.1:8080`:\n\n```console\ncurl -vk https://localhost/phpinfo.php\n```\n\n## Minimal test server\n\nBuild the minimal test server:\n\n```console\ncd internal/testserver/\ngo build\ncd ../../\n```\n\nRun the test server:\n\n```console\ncd testdata/\n../internal/testserver/testserver\n```\n\nThe server is listening on `127.0.0.1:8080`:\n\n```console\ncurl -v http://127.0.0.1:8080/phpinfo.php\n```\n\n## Building Docker Images Locally\n\nPrint bake plan:\n\n```console\ndocker buildx bake -f docker-bake.hcl --print\n```\n\nBuild FrankenPHP images for amd64 locally:\n\n```console\ndocker buildx bake -f docker-bake.hcl --pull --load --set \"*.platform=linux/amd64\"\n```\n\nBuild FrankenPHP images for arm64 locally:\n\n```console\ndocker buildx bake -f docker-bake.hcl --pull --load --set \"*.platform=linux/arm64\"\n```\n\nBuild FrankenPHP images from scratch for arm64 & amd64 and push to Docker Hub:\n\n```console\ndocker buildx bake -f docker-bake.hcl --pull --no-cache --push\n```\n\n## Debugging Segmentation Faults With Static Builds\n\n1. Download the debug version of the FrankenPHP binary from GitHub or create your custom static build including debug symbols:\n\n    ```console\n    docker buildx bake \\\n        --load \\\n        --set static-builder.args.DEBUG_SYMBOLS=1 \\\n        --set \"static-builder.platform=linux/amd64\" \\\n        static-builder\n    docker cp $(docker create --name static-builder dunglas/frankenphp:static-builder):/go/src/app/dist/frankenphp-linux-$(uname -m) frankenphp\n    ```\n\n2. Replace your current version of `frankenphp` by the debug FrankenPHP executable\n3. Start FrankenPHP as usual (alternatively, you can directly start FrankenPHP with GDB: `gdb --args frankenphp run`)\n4. Attach to the process with GDB:\n\n    ```console\n    gdb -p `pidof frankenphp`\n    ```\n\n5. If necessary, type `continue` in the GDB shell\n6. Make FrankenPHP crash\n7. Type `bt` in the GDB shell\n8. Copy the output\n\n## Debugging Segmentation Faults in GitHub Actions\n\n1. Open `.github/workflows/tests.yml`\n2. Enable PHP debug symbols\n\n    ```patch\n        - uses: shivammathur/setup-php@v2\n          # ...\n          env:\n            phpts: ts\n    +       debug: true\n    ```\n\n3. Enable `tmate` to connect to the container\n\n    ```patch\n        -\n          name: Set CGO flags\n          run: echo \"CGO_CFLAGS=$(php-config --includes)\" >> \"$GITHUB_ENV\"\n    +   -\n    +     run: |\n    +       sudo apt install gdb\n    +       mkdir -p /home/runner/.config/gdb/\n    +       printf \"set auto-load safe-path /\\nhandle SIG34 nostop noprint pass\" > /home/runner/.config/gdb/gdbinit\n    +   -\n    +     uses: mxschmitt/action-tmate@v3\n    ```\n\n4. Connect to the container\n5. Open `frankenphp.go`\n6. Enable `cgosymbolizer`\n\n    ```patch\n    -\t//_ \"github.com/ianlancetaylor/cgosymbolizer\"\n    +\t_ \"github.com/ianlancetaylor/cgosymbolizer\"\n    ```\n\n7. Download the module: `go get`\n8. In the container, you can use GDB and the like:\n\n    ```console\n    go test -tags watcher -c -ldflags=-w\n    gdb --args frankenphp.test -test.run ^MyTest$\n    ```\n\n9. When the bug is fixed, revert all these changes\n\n## Misc Dev Resources\n\n* [PHP embedding in uWSGI](https://github.com/unbit/uwsgi/blob/master/plugins/php/php_plugin.c)\n* [PHP embedding in NGINX Unit](https://github.com/nginx/unit/blob/master/src/nxt_php_sapi.c)\n* [PHP embedding in Go (go-php)](https://github.com/deuill/go-php)\n* [PHP embedding in Go (GoEmPHP)](https://github.com/mikespook/goemphp)\n* [PHP embedding in C++](https://gist.github.com/paresy/3cbd4c6a469511ac7479aa0e7c42fea7)\n* [Extending and Embedding PHP by Sara Golemon](https://books.google.fr/books?id=zMbGvK17_tYC&pg=PA254&lpg=PA254#v=onepage&q&f=false)\n* [What the heck is TSRMLS_CC, anyway?](http://blog.golemon.com/2006/06/what-heck-is-tsrmlscc-anyway.html)\n* [SDL bindings](https://pkg.go.dev/github.com/veandco/go-sdl2@v0.4.21/sdl#Main)\n\n## Docker-Related Resources\n\n* [Bake file definition](https://docs.docker.com/build/customize/bake/file-definition/)\n* [docker buildx build](https://docs.docker.com/engine/reference/commandline/buildx_build/)\n\n## Useful Command\n\n```console\napk add strace util-linux gdb\nstrace -e 'trace=!futex,epoll_ctl,epoll_pwait,tgkill,rt_sigreturn' -p 1\n```\n\n## Translating the Documentation\n\nTo translate the documentation and the site in a new language,\nfollow these steps:\n\n1. Create a new directory named with the language's 2-character ISO code in this repository's `docs/` directory\n2. Copy all the `.md` files in the root of the `docs/` directory into the new directory (always use the English version as source for translation, as it's always up to date)\n3. Copy the `README.md` and `CONTRIBUTING.md` files from the root directory to the new directory\n4. Translate the content of the files, but don't change the filenames, also don't translate strings starting with `> [!` (it's special markup for GitHub)\n5. Create a Pull Request with the translations\n6. In the [site repository](https://github.com/dunglas/frankenphp-website/tree/main), copy and translate the translation files in the `content/`, `data/` and `i18n/` directories\n7. Translate the values in the created YAML file\n8. Open a Pull Request on the site repository\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 3.841796875,
          "content": "# syntax=docker/dockerfile:1\n#checkov:skip=CKV_DOCKER_2\n#checkov:skip=CKV_DOCKER_3\n#checkov:skip=CKV_DOCKER_7\nFROM php-base AS common\n\nWORKDIR /app\n\nRUN apt-get update && \\\n\tapt-get -y --no-install-recommends install \\\n\t\tmailcap \\\n\t\tlibcap2-bin \\\n\t&& \\\n\tapt-get clean && \\\n\trm -rf /var/lib/apt/lists/*\n\nRUN set -eux; \\\n\tmkdir -p \\\n\t\t/app/public \\\n\t\t/config/caddy \\\n\t\t/data/caddy \\\n\t\t/etc/caddy; \\\n\tsed -i 's/php/frankenphp run/g' /usr/local/bin/docker-php-entrypoint; \\\n\techo '<?php phpinfo();' > /app/public/index.php\n\nCOPY --link caddy/frankenphp/Caddyfile /etc/caddy/Caddyfile\nRUN curl -sSLf \\\n\t\t-o /usr/local/bin/install-php-extensions \\\n\t\thttps://github.com/mlocati/docker-php-extension-installer/releases/latest/download/install-php-extensions && \\\n\tchmod +x /usr/local/bin/install-php-extensions\n\nCMD [\"--config\", \"/etc/caddy/Caddyfile\", \"--adapter\", \"caddyfile\"]\nHEALTHCHECK CMD curl -f http://localhost:2019/metrics || exit 1\n\n# See https://caddyserver.com/docs/conventions#file-locations for details\nENV XDG_CONFIG_HOME=/config\nENV XDG_DATA_HOME=/data\n\nEXPOSE 80\nEXPOSE 443\nEXPOSE 443/udp\nEXPOSE 2019\n\nLABEL org.opencontainers.image.title=FrankenPHP\nLABEL org.opencontainers.image.description=\"The modern PHP app server\"\nLABEL org.opencontainers.image.url=https://frankenphp.dev\nLABEL org.opencontainers.image.source=https://github.com/dunglas/frankenphp\nLABEL org.opencontainers.image.licenses=MIT\nLABEL org.opencontainers.image.vendor=\"KÃ©vin Dunglas\"\n\n\nFROM common AS builder\n\nARG FRANKENPHP_VERSION='dev'\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n\nCOPY --from=golang-base /usr/local/go /usr/local/go\n\nENV PATH=/usr/local/go/bin:$PATH\n\n# This is required to link the FrankenPHP binary to the PHP binary\nRUN apt-get update && \\\n\tapt-get -y --no-install-recommends install \\\n    cmake \\\n\tlibargon2-dev \\\n\tlibbrotli-dev \\\n\tlibcurl4-openssl-dev \\\n\tlibonig-dev \\\n\tlibreadline-dev \\\n\tlibsodium-dev \\\n\tlibsqlite3-dev \\\n\tlibssl-dev \\\n\tlibxml2-dev \\\n\tzlib1g-dev \\\n\t&& \\\n\tapt-get clean\n\nWORKDIR /go/src/app\n\nCOPY --link go.mod go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app/caddy\nCOPY --link caddy/go.mod caddy/go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app\nCOPY --link *.* ./\nCOPY --link caddy caddy\nCOPY --link internal internal\nCOPY --link testdata testdata\n\n# Install e-dant/watcher (necessary for file watching)\nWORKDIR /usr/local/src/watcher\nRUN curl -s https://api.github.com/repos/e-dant/watcher/releases/latest | \\\n\t\tgrep tarball_url | \\\n\t\tawk '{ print $2 }' | \\\n\t\tsed 's/,$//' | \\\n\t\tsed 's/\"//g' | \\\n\t\txargs curl -L | \\\n    tar xz --strip-components 1 && \\\n    cmake -S . -B build -DCMAKE_BUILD_TYPE=Release && \\\n\tcmake --build build && \\\n\tcmake --install build && \\\n    ldconfig\n\n# See https://github.com/docker-library/php/blob/master/8.3/bookworm/zts/Dockerfile#L57-L59 for PHP values\nENV CGO_CFLAGS=\"-DFRANKENPHP_VERSION=$FRANKENPHP_VERSION $PHP_CFLAGS\"\nENV CGO_CPPFLAGS=$PHP_CPPFLAGS\nENV CGO_LDFLAGS=\"-L/usr/local/lib -lssl -lcrypto -lreadline -largon2 -lcurl -lonig -lz $PHP_LDFLAGS\"\n\nRUN echo $CGO_LDFLAGS\n\nWORKDIR /go/src/app/caddy/frankenphp\nRUN GOBIN=/usr/local/bin go install -tags 'nobadger,nomysql,nopgx' -ldflags \"-w -s -X 'github.com/caddyserver/caddy/v2.CustomVersion=FrankenPHP $FRANKENPHP_VERSION PHP $PHP_VERSION Caddy'\" && \\\n\tsetcap cap_net_bind_service=+ep /usr/local/bin/frankenphp && \\\n\tcp Caddyfile /etc/caddy/Caddyfile && \\\n\tfrankenphp version\n\nWORKDIR /go/src/app\n\n\nFROM common AS runner\n\nENV GODEBUG=cgocheck=0\n\n# copy watcher shared library\nCOPY --from=builder /usr/local/lib/libwatcher* /usr/local/lib/\n# fix for the file watcher on arm\nRUN apt-get install -y --no-install-recommends libstdc++6 && \\\n\tapt-get clean && \\\n\tldconfig\n\nCOPY --from=builder /usr/local/bin/frankenphp /usr/local/bin/frankenphp\nRUN setcap cap_net_bind_service=+ep /usr/local/bin/frankenphp && \\\n\tfrankenphp version\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT license\n\nCopyright (c) 2022-present KÃ©vin Dunglas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.7578125,
          "content": "# FrankenPHP: Modern App Server for PHP\n\n<h1 align=\"center\"><a href=\"https://frankenphp.dev\"><img src=\"frankenphp.png\" alt=\"FrankenPHP\" width=\"600\"></a></h1>\n\nFrankenPHP is a modern application server for PHP built on top of the [Caddy](https://caddyserver.com/) web server.\n\nFrankenPHP gives superpowers to your PHP apps thanks to its stunning features: [*Early Hints*](https://frankenphp.dev/docs/early-hints/), [worker mode](https://frankenphp.dev/docs/worker/), [real-time capabilities](https://frankenphp.dev/docs/mercure/), automatic HTTPS, HTTP/2, and HTTP/3 support...\n\nFrankenPHP works with any PHP app and makes your Laravel and Symfony projects faster than ever thanks to their official integrations with the worker mode.\n\nFrankenPHP can also be used as a standalone Go library to embed PHP in any app using `net/http`.\n\n[**Learn more** on *frankenphp.dev*](https://frankenphp.dev) and in this slide deck:\n\n<a href=\"https://dunglas.dev/2022/10/frankenphp-the-modern-php-app-server-written-in-go/\"><img src=\"https://dunglas.dev/wp-content/uploads/2022/10/frankenphp.png\" alt=\"Slides\" width=\"600\"></a>\n\n## Getting Started\n\n### Docker\n\n```console\ndocker run -v .:/app/public \\\n    -p 80:80 -p 443:443 -p 443:443/udp \\\n    dunglas/frankenphp\n```\n\nGo to `https://localhost`, and enjoy!\n\n> [!TIP]\n>\n> Do not attempt to use `https://127.0.0.1`. Use `https://localhost` and accept the self-signed certificate.\n> Use the [`SERVER_NAME` environment variable](docs/config.md#environment-variables) to change the domain to use.\n\n### Standalone Binary\n\nIf you prefer not to use Docker, we provide standalone FrankenPHP binaries for Linux and macOS\ncontaining [PHP 8.4](https://www.php.net/releases/8.4/en.php) and most popular PHP extensions.\n\nOn Windows, use [WSL](https://learn.microsoft.com/windows/wsl/) to run FrankenPHP.\n\n[Download FrankenPHP](https://github.com/dunglas/frankenphp/releases) or copy this line into your\nterminal to automatically install the version appropriate for your platform:\n\n```console\ncurl https://frankenphp.dev/install.sh | sh\nmv frankenphp /usr/local/bin/\n```\n\nTo serve the content of the current directory, run:\n\n```console\nfrankenphp php-server\n```\n\nYou can also run command-line scripts with:\n\n```console\nfrankenphp php-cli /path/to/your/script.php\n```\n\n## Docs\n\n* [Classic mode](https://frankenphp.dev/docs/classic/)\n* [Worker mode](https://frankenphp.dev/docs/worker/)\n* [Early Hints support (103 HTTP status code)](https://frankenphp.dev/docs/early-hints/)\n* [Real-time](https://frankenphp.dev/docs/mercure/)\n* [Configuration](https://frankenphp.dev/docs/config/)\n* [Docker images](https://frankenphp.dev/docs/docker/)\n* [Deploy in production](https://frankenphp.dev/docs/production/)\n* [Performance optimization](https://frankenphp.dev/docs/performance/)\n* [Create **standalone**, self-executable PHP apps](https://frankenphp.dev/docs/embed/)\n* [Create static binaries](https://frankenphp.dev/docs/static/)\n* [Compile from sources](https://frankenphp.dev/docs/compile/)\n* [Laravel integration](https://frankenphp.dev/docs/laravel/)\n* [Known issues](https://frankenphp.dev/docs/known-issues/)\n* [Demo app (Symfony) and benchmarks](https://github.com/dunglas/frankenphp-demo)\n* [Go library documentation](https://pkg.go.dev/github.com/dunglas/frankenphp)\n* [Contributing and debugging](https://frankenphp.dev/docs/contributing/)\n\n## Examples and Skeletons\n\n* [Symfony](https://github.com/dunglas/symfony-docker)\n* [API Platform](https://api-platform.com/docs/symfony)\n* [Laravel](https://frankenphp.dev/docs/laravel/)\n* [Sulu](https://sulu.io/blog/running-sulu-with-frankenphp)\n* [WordPress](https://github.com/StephenMiracle/frankenwp)\n* [Drupal](https://github.com/dunglas/frankenphp-drupal)\n* [Joomla](https://github.com/alexandreelise/frankenphp-joomla)\n* [TYPO3](https://github.com/ochorocho/franken-typo3)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.8935546875,
          "content": "# Security Policy\n\n## Supported Versions\n\nOnly the latest version is supported.\nPlease ensure that you're always using the latest release.\n\nBinaries and Docker images are rebuilt nightly using the latest versions of dependencies.\n\n## Reporting a Vulnerability\n\nIf you believe you have discovered a security issue directly affecting FrankenPHP,\nplease do **NOT** report it publicly.\n\nPlease write a detailed vulnerability report and send it [through GitHub](https://github.com/dunglas/frankenphp/security/advisories/new) or to [kevin+frankenphp-security@dunglas.dev](mailto:kevin+frankenphp-security@dunglas.dev?subject=Security%20issue%20affecting%20FrankenPHP).\n\nOnly vulnerabilities directly affecting FrankenPHP should be reported to this project.\nFlaws affecting components used by FrankenPHP (PHP, Caddy, Go...) or using FrankenPHP (Laravel Octane, PHP Runtime...) should be reported to the relevant projects.\n"
        },
        {
          "name": "alpine.Dockerfile",
          "type": "blob",
          "size": 4.421875,
          "content": "# syntax=docker/dockerfile:1\n#checkov:skip=CKV_DOCKER_2\n#checkov:skip=CKV_DOCKER_3\n#checkov:skip=CKV_DOCKER_7\nFROM php-base AS common\n\nARG TARGETARCH\n\nWORKDIR /app\n\nRUN apk add --no-cache \\\n\tca-certificates \\\n\tlibcap \\\n\tmailcap\n\nRUN set -eux; \\\n\tmkdir -p \\\n\t\t/app/public \\\n\t\t/config/caddy \\\n\t\t/data/caddy \\\n\t\t/etc/caddy; \\\n\tsed -i 's/php/frankenphp run/g' /usr/local/bin/docker-php-entrypoint; \\\n\techo '<?php phpinfo();' > /app/public/index.php\n\nCOPY --link caddy/frankenphp/Caddyfile /etc/caddy/Caddyfile\nRUN curl -sSLf \\\n\t\t-o /usr/local/bin/install-php-extensions \\\n\t\thttps://github.com/mlocati/docker-php-extension-installer/releases/latest/download/install-php-extensions && \\\n\tchmod +x /usr/local/bin/install-php-extensions\n\nCMD [\"--config\", \"/etc/caddy/Caddyfile\", \"--adapter\", \"caddyfile\"]\nHEALTHCHECK CMD curl -f http://localhost:2019/metrics || exit 1\n\n# See https://caddyserver.com/docs/conventions#file-locations for details\nENV XDG_CONFIG_HOME=/config\nENV XDG_DATA_HOME=/data\n\nEXPOSE 80\nEXPOSE 443\nEXPOSE 443/udp\nEXPOSE 2019\n\nLABEL org.opencontainers.image.title=FrankenPHP\nLABEL org.opencontainers.image.description=\"The modern PHP app server\"\nLABEL org.opencontainers.image.url=https://frankenphp.dev\nLABEL org.opencontainers.image.source=https://github.com/dunglas/frankenphp\nLABEL org.opencontainers.image.licenses=MIT\nLABEL org.opencontainers.image.vendor=\"KÃ©vin Dunglas\"\n\n\nFROM common AS builder\n\nARG FRANKENPHP_VERSION='dev'\nARG NO_COMPRESS=''\nSHELL [\"/bin/ash\", \"-eo\", \"pipefail\", \"-c\"]\n\nCOPY --link --from=golang-base /usr/local/go /usr/local/go\n\nENV PATH=/usr/local/go/bin:$PATH\n\n# hadolint ignore=SC2086\nRUN apk add --no-cache --virtual .build-deps \\\n\t$PHPIZE_DEPS \\\n\targon2-dev \\\n\t# Needed for the custom Go build\n\tbash \\\n\tbrotli-dev \\\n\tcoreutils \\\n\tcurl-dev \\\n\t# Needed for the custom Go build\n\tgit \\\n\tgnu-libiconv-dev \\\n\tlibsodium-dev \\\n\t# Needed for the file watcher \\\n\tcmake \\\n\tlibstdc++ \\\n\tlibxml2-dev \\\n\tlinux-headers \\\n\toniguruma-dev \\\n\topenssl-dev \\\n\treadline-dev \\\n\tsqlite-dev \\\n\tupx\n\n# FIXME: temporary workaround for https://github.com/golang/go/issues/68285\nWORKDIR /\nRUN git clone https://go.googlesource.com/go goroot\nWORKDIR /goroot\n# Revert https://github.com/golang/go/commit/3560cf0afb3c29300a6c88ccd98256949ca7a6f6 to prevent the crash with musl\nRUN git config --global user.email \"build@example.com\" && \\\n\tgit config --global user.name \"Build\" && \\\n\tgit checkout \"$(go env GOVERSION)\" && \\\n\tgit revert 3560cf0afb3c29300a6c88ccd98256949ca7a6f6\nWORKDIR /goroot/src\nENV GOHOSTARCH=\"$TARGETARCH\"\nRUN ./make.bash\nENV PATH=\"/goroot/bin:$PATH\"\nRUN go version\n\nWORKDIR /go/src/app\n\nCOPY --link go.mod go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app/caddy\nCOPY caddy/go.mod caddy/go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app\nCOPY --link *.* ./\nCOPY --link caddy caddy\nCOPY --link internal internal\nCOPY --link testdata testdata\n\n# Install e-dant/watcher (necessary for file watching)\nWORKDIR /usr/local/src/watcher\nRUN curl -s https://api.github.com/repos/e-dant/watcher/releases/latest | \\\n\t\tgrep tarball_url | \\\n\t\tawk '{ print $2 }' | \\\n\t\tsed 's/,$//' | \\\n\t\tsed 's/\"//g' | \\\n\t\txargs curl -L | \\\n    tar xz --strip-components 1 && \\\n    cmake -S . -B build -DCMAKE_BUILD_TYPE=Release && \\\n\tcmake --build build && \\\n\tcmake --install build\n\n# See https://github.com/docker-library/php/blob/master/8.3/alpine3.20/zts/Dockerfile#L53-L55\nENV CGO_CFLAGS=\"-DFRANKENPHP_VERSION=$FRANKENPHP_VERSION $PHP_CFLAGS\"\nENV CGO_CPPFLAGS=$PHP_CPPFLAGS\nENV CGO_LDFLAGS=\"-lssl -lcrypto -lreadline -largon2 -lcurl -lonig -lz $PHP_LDFLAGS\"\n\nWORKDIR /go/src/app/caddy/frankenphp\nRUN GOBIN=/usr/local/bin go install -tags 'nobadger,nomysql,nopgx' -ldflags \"-w -s -extldflags '-Wl,-z,stack-size=0x80000' -X 'github.com/caddyserver/caddy/v2.CustomVersion=FrankenPHP $FRANKENPHP_VERSION PHP $PHP_VERSION Caddy'\" && \\\n\tsetcap cap_net_bind_service=+ep /usr/local/bin/frankenphp && \\\n\t([ -z \"${NO_COMPRESS}\" ] && upx --best /usr/local/bin/frankenphp || true) && \\\n\tfrankenphp version\n\nWORKDIR /go/src/app\n\n\nFROM common AS runner\n\nENV GODEBUG=cgocheck=0\n\n# copy watcher shared library (libgcc and libstdc++ are needed for the watcher)\nCOPY --from=builder /usr/local/lib/libwatcher* /usr/local/lib/\nRUN apk add --no-cache libstdc++ && \\\n\tldconfig /usr/local/lib\n\nCOPY --from=builder /usr/local/bin/frankenphp /usr/local/bin/frankenphp\nRUN setcap cap_net_bind_service=+ep /usr/local/bin/frankenphp && \\\n\tfrankenphp version\n"
        },
        {
          "name": "app.tar",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "app_checksum.txt",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "backoff.go",
          "type": "blob",
          "size": 1.1357421875,
          "content": "package frankenphp\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype exponentialBackoff struct {\n\tbackoff                time.Duration\n\tfailureCount           int\n\tmu                     sync.RWMutex\n\tmaxBackoff             time.Duration\n\tminBackoff             time.Duration\n\tmaxConsecutiveFailures int\n}\n\n// recordSuccess resets the backoff and failureCount\nfunc (e *exponentialBackoff) recordSuccess() {\n\te.mu.Lock()\n\te.failureCount = 0\n\te.backoff = e.minBackoff\n\te.mu.Unlock()\n}\n\n// recordFailure increments the failure count and increases the backoff, it returns true if maxConsecutiveFailures has been reached\nfunc (e *exponentialBackoff) recordFailure() bool {\n\te.mu.Lock()\n\te.failureCount += 1\n\tif e.backoff < e.minBackoff {\n\t\te.backoff = e.minBackoff\n\t}\n\n\te.backoff = min(e.backoff*2, e.maxBackoff)\n\n\te.mu.Unlock()\n\treturn e.failureCount >= e.maxConsecutiveFailures\n}\n\n// wait sleeps for the backoff duration if failureCount is non-zero.\n// NOTE: this is not tested and should be kept 'obviously correct' (i.e., simple)\nfunc (e *exponentialBackoff) wait() {\n\te.mu.RLock()\n\tif e.failureCount == 0 {\n\t\te.mu.RUnlock()\n\n\t\treturn\n\t}\n\te.mu.RUnlock()\n\n\ttime.Sleep(e.backoff)\n}\n"
        },
        {
          "name": "backoff_test.go",
          "type": "blob",
          "size": 1.1162109375,
          "content": "package frankenphp\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestExponentialBackoff_Reset(t *testing.T) {\n\te := &exponentialBackoff{\n\t\tmaxBackoff:             5 * time.Second,\n\t\tminBackoff:             500 * time.Millisecond,\n\t\tmaxConsecutiveFailures: 3,\n\t}\n\n\tassert.False(t, e.recordFailure())\n\tassert.False(t, e.recordFailure())\n\te.recordSuccess()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\tassert.Equal(t, 0, e.failureCount, \"expected failureCount to be reset to 0\")\n\tassert.Equal(t, e.backoff, e.minBackoff, \"expected backoff to be reset to minBackoff\")\n}\n\nfunc TestExponentialBackoff_Trigger(t *testing.T) {\n\te := &exponentialBackoff{\n\t\tmaxBackoff:             500 * 3 * time.Millisecond,\n\t\tminBackoff:             500 * time.Millisecond,\n\t\tmaxConsecutiveFailures: 3,\n\t}\n\n\tassert.False(t, e.recordFailure())\n\tassert.False(t, e.recordFailure())\n\tassert.True(t, e.recordFailure())\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\tassert.Equal(t, e.failureCount, e.maxConsecutiveFailures, \"expected failureCount to be maxConsecutiveFailures\")\n\tassert.Equal(t, e.backoff, e.maxBackoff, \"expected backoff to be maxBackoff\")\n}\n"
        },
        {
          "name": "build-static.sh",
          "type": "blob",
          "size": 10.3369140625,
          "content": "#!/bin/bash\n\nset -o errexit\nset -x\n\nif ! type \"git\" >/dev/null 2>&1; then\n\techo \"The \\\"git\\\" command must be installed.\"\n\texit 1\nfi\n\narch=\"$(uname -m)\"\nos=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\n# FIXME: re-enable PHP errors when SPC will be compatible with PHP 8.4\nspcCommand=\"php -ddisplay_errors=Off ./bin/spc\"\nmd5binary=\"md5sum\"\nif [ \"${os}\" = \"darwin\" ]; then\n\tos=\"mac\"\n\tmd5binary=\"md5 -q\"\nfi\n\nif [ \"${os}\" = \"linux\" ] && ! type \"cmake\" >/dev/null 2>&1; then\n\techo \"The \\\"cmake\\\" command must be installed.\"\n\texit 1\nfi\n\nif [ \"${os}\" = \"linux\" ] && { [[ \"${arch}\" =~ \"aarch\" ]] || [[ \"${arch}\" =~ \"arm\" ]]; }; then\n\tfpic=\"-fPIC\"\n\tfpie=\"-fPIE\"\n\n\tif [ -z \"${DEBUG_SYMBOLS}\" ]; then\n\t\texport SPC_PHP_DEFAULT_OPTIMIZE_CFLAGS=\"-g -fstack-protector-strong -fPIC -fPIE -Os -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\"\n\tfi\nelse\n\tfpic=\"-fpic\"\n\tfpie=\"-fpie\"\nfi\n\nif [ -z \"${PHP_EXTENSIONS}\" ]; then\n\tif [ -n \"${EMBED}\" ] && [ -f \"${EMBED}/composer.json\" ]; then\n\t\tcd \"${EMBED}\"\n\t\t# read the composer.json file and extract the required PHP extensions\n\t\t# remove internal extensions from the list: https://github.com/crazywhalecc/static-php-cli/blob/4b16631d45a57370b4747df15c8f105130e96d03/src/globals/defines.php#L26-L34\n\t\tPHP_EXTENSIONS=\"$(composer check-platform-reqs --no-dev 2>/dev/null | grep ^ext | sed -e 's/^ext-core//' -e 's/^ext-hash//' -e 's/^ext-json//' -e 's/^ext-pcre//' -e 's/^ext-reflection//' -e 's/^ext-spl//' -e 's/^ext-standard//' -e 's/^ext-//' -e 's/ .*//' | xargs | tr ' ' ',')\"\n\t\texport PHP_EXTENSIONS\n\t\tcd -\n\telse\n\t\texport PHP_EXTENSIONS=\"apcu,bcmath,bz2,calendar,ctype,curl,dba,dom,exif,fileinfo,filter,ftp,gd,gmp,gettext,iconv,igbinary,imagick,intl,ldap,mbregex,mbstring,mysqli,mysqlnd,opcache,openssl,parallel,pcntl,pdo,pdo_mysql,pdo_pgsql,pdo_sqlite,pgsql,phar,posix,protobuf,readline,redis,session,shmop,simplexml,soap,sockets,sodium,sqlite3,ssh2,sysvmsg,sysvsem,sysvshm,tidy,tokenizer,xlswriter,xml,xmlreader,xmlwriter,zip,zlib,yaml,zstd\"\n\tfi\nfi\n\nif [ -z \"${PHP_EXTENSION_LIBS}\" ]; then\n\texport PHP_EXTENSION_LIBS=\"bzip2,freetype,libavif,libjpeg,liblz4,libwebp,libzip,nghttp2\"\nfi\n\n# The Brotli library must always be built as it is required by http://github.com/dunglas/caddy-cbrotli\nif ! echo \"${PHP_EXTENSION_LIBS}\" | grep -q \"\\bbrotli\\b\"; then\n\texport PHP_EXTENSION_LIBS=\"${PHP_EXTENSION_LIBS},brotli\"\nfi\n\nif [ -z \"${PHP_VERSION}\" ]; then\n\texport PHP_VERSION=\"8.4\"\nfi\n\nif [ -z \"${FRANKENPHP_VERSION}\" ]; then\n\tFRANKENPHP_VERSION=\"$(git rev-parse --verify HEAD)\"\n\texport FRANKENPHP_VERSION\nelif [ -d \".git/\" ]; then\n\tCURRENT_REF=\"$(git rev-parse --abbrev-ref HEAD)\"\n\texport CURRENT_REF\n\n\tif echo \"${FRANKENPHP_VERSION}\" | grep -F -q \".\"; then\n\t\t# Tag\n\n\t\t# Trim \"v\" prefix if any\n\t\tFRANKENPHP_VERSION=${FRANKENPHP_VERSION#v}\n\t\texport FRANKENPHP_VERSION\n\n\t\tgit checkout \"v${FRANKENPHP_VERSION}\"\n\telse\n\t\tgit checkout \"${FRANKENPHP_VERSION}\"\n\tfi\nfi\n\nbin=\"frankenphp-${os}-${arch}\"\n\nif [ -n \"${CLEAN}\" ]; then\n\trm -Rf dist/\n\tgo clean -cache\nfi\n\ncache_key=\"${PHP_VERSION}-${PHP_EXTENSIONS}-${PHP_EXTENSION_LIBS}\"\n\n# Build libphp if necessary\nif [ -f dist/cache_key ] && [ \"$(cat dist/cache_key)\" = \"${cache_key}\" ] && [ -f \"dist/static-php-cli/buildroot/lib/libphp.a\" ]; then\n\tcd dist/static-php-cli\nelse\n\tmkdir -p dist/\n\tcd dist/\n\techo -n \"${cache_key}\" >cache_key\n\n\tif [ -d \"static-php-cli/\" ]; then\n\t\tcd static-php-cli/\n\t\tgit pull\n\telse\n\t\tgit clone --depth 1 https://github.com/crazywhalecc/static-php-cli\n\t\tcd static-php-cli/\n\tfi\n\n\tif type \"brew\" >/dev/null 2>&1; then\n\t\tif ! type \"composer\" >/dev/null; then\n\t\t\tpackages=\"composer\"\n\t\tfi\n\t\tif ! type \"go\" >/dev/null 2>&1; then\n\t\t\tpackages=\"${packages} go\"\n\t\tfi\n\t\tif [ -n \"${RELEASE}\" ] && ! type \"gh\" >/dev/null 2>&1; then\n\t\t\tpackages=\"${packages} gh\"\n\t\tfi\n\n\t\tif [ -n \"${packages}\" ]; then\n\t\t\t# shellcheck disable=SC2086\n\t\t\tbrew install --formula --quiet ${packages}\n\t\tfi\n\tfi\n\n\tcomposer install --no-dev -a\n\n\tif [ \"${os}\" = \"linux\" ]; then\n\t\textraOpts=\"--disable-opcache-jit\"\n\tfi\n\n\tif [ -n \"${DEBUG_SYMBOLS}\" ]; then\n\t\textraOpts=\"${extraOpts} --no-strip\"\n\tfi\n\n\t${spcCommand} doctor --auto-fix\n\t${spcCommand} download --with-php=\"${PHP_VERSION}\" --for-extensions=\"${PHP_EXTENSIONS}\" --for-libs=\"${PHP_EXTENSION_LIBS}\" --ignore-cache-sources=php-src --prefer-pre-built\n\t# shellcheck disable=SC2086\n\t${spcCommand} build --debug --enable-zts --build-embed ${extraOpts} \"${PHP_EXTENSIONS}\" --with-libs=\"${PHP_EXTENSION_LIBS}\"\nfi\n\nif ! type \"go\" >/dev/null 2>&1; then\n\techo \"The \\\"go\\\" command must be installed.\"\n\texit 1\nfi\n\nXCADDY_COMMAND=\"xcaddy\"\nif ! type \"$XCADDY_COMMAND\" >/dev/null 2>&1; then\n\tgo install github.com/caddyserver/xcaddy/cmd/xcaddy@latest\n\tXCADDY_COMMAND=\"$(go env GOPATH)/bin/xcaddy\"\nfi\n\ncurlGitHubHeaders=(--header \"X-GitHub-Api-Version: 2022-11-28\")\nif [ \"${GITHUB_TOKEN}\" ]; then\n\tcurlGitHubHeaders+=(--header \"Authorization: Bearer ${GITHUB_TOKEN}\")\nfi\n\n# Compile e-dant/watcher as a static library\nmkdir -p watcher\ncd watcher\ncurl -f --retry 5 \"${curlGitHubHeaders[@]}\" https://api.github.com/repos/e-dant/watcher/releases/latest |\n\tgrep tarball_url |\n\tawk '{ print $2 }' |\n\tsed 's/,$//' |\n\tsed 's/\"//g' |\n\txargs curl -fL --retry 5 \"${curlGitHubHeaders[@]}\" |\n\ttar xz --strip-components 1\ncd watcher-c\ncc -c -o libwatcher-c.o ./src/watcher-c.cpp -I ./include -I ../include -std=c++17 -Wall -Wextra \"${fpic}\"\nar rcs libwatcher-c.a libwatcher-c.o\ncp libwatcher-c.a ../../buildroot/lib/libwatcher-c.a\nmkdir -p ../../buildroot/include/wtr\ncp -R include/wtr/watcher-c.h ../../buildroot/include/wtr/watcher-c.h\ncd ../../\n\n# See https://github.com/docker-library/php/blob/master/8.3/alpine3.20/zts/Dockerfile#L53-L55\nCGO_CFLAGS=\"-DFRANKENPHP_VERSION=${FRANKENPHP_VERSION} -I${PWD}/buildroot/include/ $(${spcCommand} spc-config \"${PHP_EXTENSIONS}\" --with-libs=\"${PHP_EXTENSION_LIBS}\" --includes)\"\nif [ -n \"${DEBUG_SYMBOLS}\" ]; then\n\tCGO_CFLAGS=\"-g ${CGO_CFLAGS}\"\nelse\n\tCGO_CFLAGS=\"-fstack-protector-strong ${fpic} ${fpie} -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 ${CGO_CFLAGS}\"\nfi\nexport CGO_CFLAGS\nexport CGO_CPPFLAGS=\"${CGO_CFLAGS}\"\n\nif [ \"${os}\" = \"mac\" ]; then\n\texport CGO_LDFLAGS=\"-framework CoreFoundation -framework SystemConfiguration\"\nelif [ \"${os}\" = \"linux\" ] && [ -z \"${DEBUG_SYMBOLS}\" ]; then\n\tCGO_LDFLAGS=\"-Wl,-O1 -pie\"\nfi\n\nCGO_LDFLAGS=\"${CGO_LDFLAGS} ${PWD}/buildroot/lib/libbrotlicommon.a ${PWD}/buildroot/lib/libbrotlienc.a ${PWD}/buildroot/lib/libbrotlidec.a ${PWD}/buildroot/lib/libwatcher-c.a $(${spcCommand} spc-config \"${PHP_EXTENSIONS}\" --with-libs=\"${PHP_EXTENSION_LIBS}\" --libs)\"\nif [ \"${os}\" = \"linux\" ]; then\n\tif echo \"${PHP_EXTENSIONS}\" | grep -qE \"\\b(intl|imagick|grpc|v8js|protobuf|mongodb|tbb)\\b\"; then\n\t\tCGO_LDFLAGS=\"${CGO_LDFLAGS} -lstdc++\"\n\tfi\nfi\n\nexport CGO_LDFLAGS\n\nLIBPHP_VERSION=\"$(./buildroot/bin/php-config --version)\"\n\ncd ../\n\nif [ \"${os}\" = \"linux\" ]; then\n\tif [ -n \"${MIMALLOC}\" ]; then\n\t\t# Replace musl's mallocng by mimalloc\n\t\t# The default musl allocator is slow, especially when used by multi-threaded apps,\n\t\t# and triggers weird bugs\n\t\t# Adapted from https://www.tweag.io/blog/2023-08-10-rust-static-link-with-mimalloc/\n\n\t\techo 'The USE_MIMALLOC environment variable is EXPERIMENTAL.'\n\t\techo 'This option can be removed or its behavior modified at any time.'\n\n\t\tif [ ! -f \"mimalloc/out/libmimalloc.a\" ]; then\n\t\t\tif [ -d \"mimalloc\" ]; then\n\t\t\t\tcd mimalloc/\n\t\t\t\tgit reset --hard\n\t\t\t\tgit clean -xdf\n\t\t\t\tgit fetch --tags\n\t\t\telse\n\t\t\t\tgit clone https://github.com/microsoft/mimalloc.git\n\t\t\t\tcd mimalloc/\n\t\t\tfi\n\n\t\t\tgit checkout \"$(git describe --tags \"$(git rev-list --tags --max-count=1 || true)\" || true)\"\n\n\t\t\tcurl -fL --retry 5 https://raw.githubusercontent.com/tweag/rust-alpine-mimalloc/1a756444a5c1484d26af9cd39187752728416ba8/mimalloc.diff -o mimalloc.diff\n\t\t\tpatch -p1 <mimalloc.diff\n\n\t\t\tmkdir -p out/\n\t\t\tcd out/\n\t\t\tif [ -n \"${DEBUG_SYMBOLS}\" ]; then\n\t\t\t\tcmake \\\n\t\t\t\t\t-DCMAKE_BUILD_TYPE=Debug \\\n\t\t\t\t\t-DMI_BUILD_SHARED=OFF \\\n\t\t\t\t\t-DMI_BUILD_OBJECT=OFF \\\n\t\t\t\t\t-DMI_BUILD_TESTS=OFF \\\n\t\t\t\t\t../\n\t\t\telse\n\t\t\t\tcmake \\\n\t\t\t\t\t-DCMAKE_BUILD_TYPE=Release \\\n\t\t\t\t\t-DMI_BUILD_SHARED=OFF \\\n\t\t\t\t\t-DMI_BUILD_OBJECT=OFF \\\n\t\t\t\t\t-DMI_BUILD_TESTS=OFF \\\n\t\t\t\t\t../\n\t\t\tfi\n\t\t\tmake -j\"$(nproc || true)\"\n\n\t\t\tcd ../../\n\t\tfi\n\n\t\tif [ -n \"${DEBUG_SYMBOLS}\" ]; then\n\t\t\tlibmimalloc_path=mimalloc/out/libmimalloc-debug.a\n\t\telse\n\t\t\tlibmimalloc_path=mimalloc/out/libmimalloc.a\n\t\tfi\n\n\t\t# Patch musl library to use mimalloc\n\t\tfor libc_path in \"/usr/local/musl/lib/libc.a\" \"/usr/local/musl/$(uname -m)-linux-musl/lib/libc.a\" \"/usr/lib/libc.a\"; do\n\t\t\tif [ ! -f \"${libc_path}\" ] || [ -f \"${libc_path}.unpatched\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t{\n\t\t\t\techo \"CREATE libc.a\"\n\t\t\t\techo \"ADDLIB ${libc_path}\"\n\t\t\t\techo \"DELETE aligned_alloc.lo calloc.lo donate.lo free.lo libc_calloc.lo lite_malloc.lo malloc.lo malloc_usable_size.lo memalign.lo posix_memalign.lo realloc.lo reallocarray.lo valloc.lo\"\n\t\t\t\techo \"ADDLIB ${libmimalloc_path}\"\n\t\t\t\techo \"SAVE\"\n\t\t\t} | ar -M\n\t\t\tmv \"${libc_path}\" \"${libc_path}.unpatched\"\n\t\t\tmv libc.a \"${libc_path}\"\n\t\tdone\n\tfi\n\n\t# Increase the default stack size to prevents issues with code including many files such as Symfony containers\n\textraExtldflags=\"-Wl,-z,stack-size=0x80000\"\nfi\n\nif [ -z \"${DEBUG_SYMBOLS}\" ]; then\n\textraLdflags=\"-w -s\"\nfi\n\ncd ../\n\n# Embed PHP app, if any\nif [ -n \"${EMBED}\" ] && [ -d \"${EMBED}\" ]; then\n\ttar -cf app.tar -C \"${EMBED}\" .\n\t${md5binary} app.tar | awk '{printf $1}' >app_checksum.txt\nfi\n\nif [ -z \"${XCADDY_ARGS}\" ]; then\n\tXCADDY_ARGS=\"--with github.com/dunglas/caddy-cbrotli --with github.com/dunglas/mercure/caddy --with github.com/dunglas/vulcain/caddy\"\nfi\n\nXCADDY_DEBUG=0\nif [ -n \"${DEBUG_SYMBOLS}\" ]; then\n\tXCADDY_DEBUG=1\nfi\n\ngo env\ncd caddy/\n# shellcheck disable=SC2086\nCGO_ENABLED=1 \\\n\tXCADDY_GO_BUILD_FLAGS=\"-buildmode=pie -tags cgo,netgo,osusergo,static_build,nobadger,nomysql,nopgx -ldflags \\\"-linkmode=external -extldflags '-static-pie ${extraExtldflags}' ${extraLdflags} -X 'github.com/caddyserver/caddy/v2.CustomVersion=FrankenPHP ${FRANKENPHP_VERSION} PHP ${LIBPHP_VERSION} Caddy'\\\"\" \\\n\tXCADDY_DEBUG=\"${XCADDY_DEBUG}\" \\\n\t${XCADDY_COMMAND} build \\\n\t--output \"../dist/${bin}\" \\\n\t${XCADDY_ARGS} \\\n\t--with github.com/dunglas/frankenphp=.. \\\n\t--with github.com/dunglas/frankenphp/caddy=.\ncd ..\n\nif [ -d \"${EMBED}\" ]; then\n\ttruncate -s 0 app.tar\n\ttruncate -s 0 app_checksum.txt\nfi\n\nif type \"upx\" >/dev/null 2>&1 && [ -z \"${DEBUG_SYMBOLS}\" ] && [ -z \"${NO_COMPRESS}\" ]; then\n\tupx --best \"dist/${bin}\"\nfi\n\n\"dist/${bin}\" version\n\nif [ -n \"${RELEASE}\" ]; then\n\tgh release upload \"v${FRANKENPHP_VERSION}\" \"dist/${bin}\" --repo dunglas/frankenphp --clobber\nfi\n\nif [ -n \"${CURRENT_REF}\" ]; then\n\tgit checkout \"${CURRENT_REF}\"\nfi\n"
        },
        {
          "name": "caddy",
          "type": "tree",
          "content": null
        },
        {
          "name": "cgi.go",
          "type": "blob",
          "size": 8.439453125,
          "content": "package frankenphp\n\n// #include <php_variables.h>\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\nvar knownServerKeys = []string{\n\t\"CONTENT_LENGTH\",\n\t\"DOCUMENT_ROOT\",\n\t\"DOCUMENT_URI\",\n\t\"GATEWAY_INTERFACE\",\n\t\"HTTP_HOST\",\n\t\"HTTPS\",\n\t\"PATH_INFO\",\n\t\"PHP_SELF\",\n\t\"REMOTE_ADDR\",\n\t\"REMOTE_HOST\",\n\t\"REMOTE_PORT\",\n\t\"REQUEST_SCHEME\",\n\t\"SCRIPT_FILENAME\",\n\t\"SCRIPT_NAME\",\n\t\"SERVER_NAME\",\n\t\"SERVER_PORT\",\n\t\"SERVER_PROTOCOL\",\n\t\"SERVER_SOFTWARE\",\n\t\"SSL_PROTOCOL\",\n\t\"AUTH_TYPE\",\n\t\"REMOTE_IDENT\",\n\t\"CONTENT_TYPE\",\n\t\"PATH_TRANSLATED\",\n\t\"QUERY_STRING\",\n\t\"REMOTE_USER\",\n\t\"REQUEST_METHOD\",\n\t\"REQUEST_URI\",\n}\n\n// computeKnownVariables returns a set of CGI environment variables for the request.\n//\n// TODO: handle this case https://github.com/caddyserver/caddy/issues/3718\n// Inspired by https://github.com/caddyserver/caddy/blob/master/modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go\nfunc addKnownVariablesToServer(thread *phpThread, request *http.Request, fc *FrankenPHPContext, trackVarsArray *C.zval) {\n\tkeys := getKnownVariableKeys(thread)\n\t// Separate remote IP and port; more lenient than net.SplitHostPort\n\tvar ip, port string\n\tif idx := strings.LastIndex(request.RemoteAddr, \":\"); idx > -1 {\n\t\tip = request.RemoteAddr[:idx]\n\t\tport = request.RemoteAddr[idx+1:]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\n\t// Remove [] from IPv6 addresses\n\tip = strings.Replace(ip, \"[\", \"\", 1)\n\tip = strings.Replace(ip, \"]\", \"\", 1)\n\n\tvar https string\n\tvar sslProtocol string\n\tvar rs string\n\tif request.TLS == nil {\n\t\trs = \"http\"\n\t\thttps = \"\"\n\t\tsslProtocol = \"\"\n\t} else {\n\t\trs = \"https\"\n\t\thttps = \"on\"\n\n\t\t// and pass the protocol details in a manner compatible with apache's mod_ssl\n\t\t// (which is why these have an SSL_ prefix and not TLS_).\n\t\tif v, ok := tlsProtocolStrings[request.TLS.Version]; ok {\n\t\t\tsslProtocol = v\n\t\t} else {\n\t\t\tsslProtocol = \"\"\n\t\t}\n\t}\n\n\treqHost, reqPort, _ := net.SplitHostPort(request.Host)\n\n\tif reqHost == \"\" {\n\t\t// whatever, just assume there was no port\n\t\treqHost = request.Host\n\t}\n\n\tif reqPort == \"\" {\n\t\t// compliance with the CGI specification requires that\n\t\t// the SERVER_PORT variable MUST be set to the TCP/IP port number on which this request is received from the client\n\t\t// even if the port is the default port for the scheme and could otherwise be omitted from a URI.\n\t\t// https://tools.ietf.org/html/rfc3875#section-4.1.15\n\t\tswitch rs {\n\t\tcase \"https\":\n\t\t\treqPort = \"443\"\n\t\tcase \"http\":\n\t\t\treqPort = \"80\"\n\t\t}\n\t}\n\n\tserverPort := reqPort\n\tcontentLength := request.Header.Get(\"Content-Length\")\n\n\tvar requestURI string\n\tif fc.originalRequest != nil {\n\t\trequestURI = fc.originalRequest.URL.RequestURI()\n\t} else {\n\t\trequestURI = request.URL.RequestURI()\n\t}\n\n\tC.frankenphp_register_bulk(\n\t\ttrackVarsArray,\n\t\tpackCgiVariable(keys[\"REMOTE_ADDR\"], ip),\n\t\tpackCgiVariable(keys[\"REMOTE_HOST\"], ip),\n\t\tpackCgiVariable(keys[\"REMOTE_PORT\"], port),\n\t\tpackCgiVariable(keys[\"DOCUMENT_ROOT\"], fc.documentRoot),\n\t\tpackCgiVariable(keys[\"PATH_INFO\"], fc.pathInfo),\n\t\tpackCgiVariable(keys[\"PHP_SELF\"], request.URL.Path),\n\t\tpackCgiVariable(keys[\"DOCUMENT_URI\"], fc.docURI),\n\t\tpackCgiVariable(keys[\"SCRIPT_FILENAME\"], fc.scriptFilename),\n\t\tpackCgiVariable(keys[\"SCRIPT_NAME\"], fc.scriptName),\n\t\tpackCgiVariable(keys[\"HTTPS\"], https),\n\t\tpackCgiVariable(keys[\"SSL_PROTOCOL\"], sslProtocol),\n\t\tpackCgiVariable(keys[\"REQUEST_SCHEME\"], rs),\n\t\tpackCgiVariable(keys[\"SERVER_NAME\"], reqHost),\n\t\tpackCgiVariable(keys[\"SERVER_PORT\"], serverPort),\n\t\t// Variables defined in CGI 1.1 spec\n\t\t// Some variables are unused but cleared explicitly to prevent\n\t\t// the parent environment from interfering.\n\t\t// These values can not be overridden\n\t\tpackCgiVariable(keys[\"CONTENT_LENGTH\"], contentLength),\n\t\tpackCgiVariable(keys[\"GATEWAY_INTERFACE\"], \"CGI/1.1\"),\n\t\tpackCgiVariable(keys[\"SERVER_PROTOCOL\"], request.Proto),\n\t\tpackCgiVariable(keys[\"SERVER_SOFTWARE\"], \"FrankenPHP\"),\n\t\tpackCgiVariable(keys[\"HTTP_HOST\"], request.Host),\n\t\t// These values are always empty but must be defined:\n\t\tpackCgiVariable(keys[\"AUTH_TYPE\"], \"\"),\n\t\tpackCgiVariable(keys[\"REMOTE_IDENT\"], \"\"),\n\t\t// Request uri of the original request\n\t\tpackCgiVariable(keys[\"REQUEST_URI\"], requestURI),\n\t)\n\n\t// These values are already present in the SG(request_info), so we'll register them from there\n\tC.frankenphp_register_variables_from_request_info(\n\t\ttrackVarsArray,\n\t\tkeys[\"CONTENT_TYPE\"],\n\t\tkeys[\"PATH_TRANSLATED\"],\n\t\tkeys[\"QUERY_STRING\"],\n\t\tkeys[\"REMOTE_USER\"],\n\t\tkeys[\"REQUEST_METHOD\"],\n\t)\n}\n\nfunc packCgiVariable(key *C.zend_string, value string) C.ht_key_value_pair {\n\treturn C.ht_key_value_pair{key, toUnsafeChar(value), C.size_t(len(value))}\n}\n\nfunc addHeadersToServer(request *http.Request, fc *FrankenPHPContext, trackVarsArray *C.zval) {\n\tfor field, val := range request.Header {\n\t\tk, ok := headerKeyCache.Get(field)\n\t\tif !ok {\n\t\t\tk = \"HTTP_\" + headerNameReplacer.Replace(strings.ToUpper(field)) + \"\\x00\"\n\t\t\theaderKeyCache.SetIfAbsent(field, k)\n\t\t}\n\n\t\tif _, ok := fc.env[k]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tv := strings.Join(val, \", \")\n\t\tC.frankenphp_register_variable_safe(toUnsafeChar(k), toUnsafeChar(v), C.size_t(len(v)), trackVarsArray)\n\t}\n}\n\nfunc addPreparedEnvToServer(fc *FrankenPHPContext, trackVarsArray *C.zval) {\n\tfor k, v := range fc.env {\n\t\tC.frankenphp_register_variable_safe(toUnsafeChar(k), toUnsafeChar(v), C.size_t(len(v)), trackVarsArray)\n\t}\n\tfc.env = nil\n}\n\nfunc getKnownVariableKeys(thread *phpThread) map[string]*C.zend_string {\n\tif thread.knownVariableKeys != nil {\n\t\treturn thread.knownVariableKeys\n\t}\n\tthreadServerKeys := make(map[string]*C.zend_string)\n\tfor _, k := range knownServerKeys {\n\t\tthreadServerKeys[k] = C.frankenphp_init_persistent_string(toUnsafeChar(k), C.size_t(len(k)))\n\t}\n\tthread.knownVariableKeys = threadServerKeys\n\treturn threadServerKeys\n}\n\n//export go_register_variables\nfunc go_register_variables(threadIndex C.uintptr_t, trackVarsArray *C.zval) {\n\tthread := phpThreads[threadIndex]\n\tr := thread.getActiveRequest()\n\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\n\taddKnownVariablesToServer(thread, r, fc, trackVarsArray)\n\taddHeadersToServer(r, fc, trackVarsArray)\n\taddPreparedEnvToServer(fc, trackVarsArray)\n}\n\n//export go_frankenphp_release_known_variable_keys\nfunc go_frankenphp_release_known_variable_keys(threadIndex C.uintptr_t) {\n\tthread := phpThreads[threadIndex]\n\tif thread.knownVariableKeys == nil {\n\t\treturn\n\t}\n\tfor _, v := range thread.knownVariableKeys {\n\t\tC.frankenphp_release_zend_string(v)\n\t}\n\tthread.knownVariableKeys = nil\n}\n\n// splitPos returns the index where path should\n// be split based on SplitPath.\n//\n// Adapted from https://github.com/caddyserver/caddy/blob/master/modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go\n// Copyright 2015 Matthew Holt and The Caddy Authors\nfunc splitPos(fc *FrankenPHPContext, path string) int {\n\tif len(fc.splitPath) == 0 {\n\t\treturn 0\n\t}\n\n\tlowerPath := strings.ToLower(path)\n\tfor _, split := range fc.splitPath {\n\t\tif idx := strings.Index(lowerPath, strings.ToLower(split)); idx > -1 {\n\t\t\treturn idx + len(split)\n\t\t}\n\t}\n\treturn -1\n}\n\n// Map of supported protocols to Apache ssl_mod format\n// Note that these are slightly different from SupportedProtocols in caddytls/config.go\nvar tlsProtocolStrings = map[uint16]string{\n\ttls.VersionTLS10: \"TLSv1\",\n\ttls.VersionTLS11: \"TLSv1.1\",\n\ttls.VersionTLS12: \"TLSv1.2\",\n\ttls.VersionTLS13: \"TLSv1.3\",\n}\n\nvar headerNameReplacer = strings.NewReplacer(\" \", \"_\", \"-\", \"_\")\n\n// SanitizedPathJoin performs filepath.Join(root, reqPath) that\n// is safe against directory traversal attacks. It uses logic\n// similar to that in the Go standard library, specifically\n// in the implementation of http.Dir. The root is assumed to\n// be a trusted path, but reqPath is not; and the output will\n// never be outside of root. The resulting path can be used\n// with the local file system.\n//\n// Adapted from https://github.com/caddyserver/caddy/blob/master/modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go\n// Copyright 2015 Matthew Holt and The Caddy Authors\nfunc sanitizedPathJoin(root, reqPath string) string {\n\tif root == \"\" {\n\t\troot = \".\"\n\t}\n\n\tpath := filepath.Join(root, filepath.Clean(\"/\"+reqPath))\n\n\t// filepath.Join also cleans the path, and cleaning strips\n\t// the trailing slash, so we need to re-add it afterward.\n\t// if the length is 1, then it's a path to the root,\n\t// and that should return \".\", so we don't append the separator.\n\tif strings.HasSuffix(reqPath, \"/\") && len(reqPath) > 1 {\n\t\tpath += separator\n\t}\n\n\treturn path\n}\n\nconst separator = string(filepath.Separator)\n\nfunc toUnsafeChar(s string) *C.char {\n\tsData := unsafe.StringData(s)\n\treturn (*C.char)(unsafe.Pointer(sData))\n}\n"
        },
        {
          "name": "dev-alpine.Dockerfile",
          "type": "blob",
          "size": 1.62890625,
          "content": "# syntax=docker/dockerfile:1\n#checkov:skip=CKV_DOCKER_2\n#checkov:skip=CKV_DOCKER_3\nFROM golang:1.22-alpine\n\nENV CFLAGS=\"-ggdb3\"\nENV PHPIZE_DEPS=\"\\\n\tautoconf \\\n\tdpkg-dev \\\n\tfile \\\n\tg++ \\\n\tgcc \\\n\tlibc-dev \\\n\tmake \\\n\tpkgconfig \\\n\tre2c\"\n\nSHELL [\"/bin/ash\", \"-eo\", \"pipefail\", \"-c\"]\n\nRUN apk add --no-cache \\\n\t$PHPIZE_DEPS \\\n\targon2-dev \\\n\tbrotli-dev \\\n\tcurl-dev \\\n\toniguruma-dev \\\n\treadline-dev \\\n\tlibsodium-dev \\\n\tsqlite-dev \\\n\topenssl-dev \\\n\tlibxml2-dev \\\n\tzlib-dev \\\n\tbison \\\n\tnss-tools \\\n\t# file watcher\n\tlibstdc++ \\\n\tlinux-headers \\\n\t# Dev tools \\\n\tgit \\\n\tclang \\\n\tcmake \\\n\tllvm \\\n\tgdb \\\n\tvalgrind \\\n\tneovim \\\n\tzsh \\\n\tlibtool && \\\n\techo 'set auto-load safe-path /' > /root/.gdbinit\n\nWORKDIR /usr/local/src/php\nRUN git clone --branch=PHP-8.4 https://github.com/php/php-src.git . && \\\n\t# --enable-embed is only necessary to generate libphp.so, we don't use this SAPI directly\n\t./buildconf --force && \\\n\t./configure \\\n\t\t--enable-embed \\\n\t\t--enable-zts \\\n\t\t--disable-zend-signals \\\n\t\t--enable-zend-max-execution-timers \\\n\t\t--enable-debug && \\\n\tmake -j\"$(nproc)\" && \\\n\tmake install && \\\n\tldconfig /etc/ld.so.conf.d && \\\n\tcp php.ini-development /usr/local/lib/php.ini && \\\n\techo \"zend_extension=opcache.so\" >> /usr/local/lib/php.ini && \\\n\techo \"opcache.enable=1\" >> /usr/local/lib/php.ini && \\\n\tphp --version\n\n# Install e-dant/watcher (necessary for file watching)\nWORKDIR /usr/local/src/watcher\nRUN git clone https://github.com/e-dant/watcher . && \\\n    cmake -S . -B build -DCMAKE_BUILD_TYPE=Release && \\\n\tcmake --build build/ && \\\n\tcmake --install build\n\nWORKDIR /go/src/app\nCOPY . .\n\nWORKDIR /go/src/app/caddy/frankenphp\nRUN go build\n\nWORKDIR /go/src/app\nCMD [ \"zsh\" ]\n"
        },
        {
          "name": "dev.Dockerfile",
          "type": "blob",
          "size": 1.7890625,
          "content": "# syntax=docker/dockerfile:1\n#checkov:skip=CKV_DOCKER_2\n#checkov:skip=CKV_DOCKER_3\nFROM golang:1.22\n\nENV CFLAGS=\"-ggdb3\"\nENV PHPIZE_DEPS=\"\\\n\tautoconf \\\n\tdpkg-dev \\\n\tfile \\\n\tg++ \\\n\tgcc \\\n\tlibc-dev \\\n\tmake \\\n\tpkg-config \\\n\tre2c\"\n\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n\n# hadolint ignore=DL3009\nRUN apt-get update && \\\n\tapt-get -y --no-install-recommends install \\\n\t$PHPIZE_DEPS \\\n\tlibargon2-dev \\\n\tlibbrotli-dev \\\n\tlibcurl4-openssl-dev \\\n\tlibonig-dev \\\n\tlibreadline-dev \\\n\tlibsodium-dev \\\n\tlibsqlite3-dev \\\n\tlibssl-dev \\\n\tlibxml2-dev \\\n\tzlib1g-dev \\\n\tbison \\\n\tlibnss3-tools \\\n\t# Dev tools \\\n\tgit \\\n\tclang \\\n\tcmake \\\n\tllvm \\\n\tgdb \\\n\tvalgrind \\\n\tneovim \\\n\tzsh \\\n\tlibtool-bin && \\\n\techo 'set auto-load safe-path /' > /root/.gdbinit && \\\n\techo '* soft core unlimited' >> /etc/security/limits.conf \\\n\t&& \\\n\tapt-get clean \n\nWORKDIR /usr/local/src/php\nRUN git clone --branch=PHP-8.4 https://github.com/php/php-src.git . && \\\n\t# --enable-embed is only necessary to generate libphp.so, we don't use this SAPI directly\n\t./buildconf --force && \\\n\t./configure \\\n\t\t--enable-embed \\\n\t\t--enable-zts \\\n\t\t--disable-zend-signals \\\n\t\t--enable-zend-max-execution-timers \\\n\t\t--enable-debug && \\\n\tmake -j\"$(nproc)\" && \\\n\tmake install && \\\n\tldconfig && \\\n\tcp php.ini-development /usr/local/lib/php.ini && \\\n\techo \"zend_extension=opcache.so\" >> /usr/local/lib/php.ini && \\\n\techo \"opcache.enable=1\" >> /usr/local/lib/php.ini && \\\n\tphp --version\n\n# Install e-dant/watcher (necessary for file watching)\nWORKDIR /usr/local/src/watcher\nRUN git clone https://github.com/e-dant/watcher . && \\\n\tcmake -S . -B build -DCMAKE_BUILD_TYPE=Release && \\\n\tcmake --build build/ && \\\n\tcmake --install build\n\nWORKDIR /go/src/app\nCOPY . .\n\nWORKDIR /go/src/app/caddy/frankenphp\nRUN go build -buildvcs=false -tags 'nobadger,nomysql,nopgx'\n\nWORKDIR /go/src/app\nCMD [ \"zsh\" ]\n"
        },
        {
          "name": "docker-bake.hcl",
          "type": "blob",
          "size": 4.8525390625,
          "content": "variable \"IMAGE_NAME\" {\n    default = \"dunglas/frankenphp\"\n}\n\nvariable \"VERSION\" {\n    default = \"dev\"\n}\n\nvariable \"PHP_VERSION\" {\n    default = \"8.2,8.3,8.4\"\n}\n\nvariable \"GO_VERSION\" {\n    default = \"1.23\"\n}\n\nvariable \"SHA\" {}\n\nvariable \"LATEST\" {\n    default = true\n}\n\nvariable \"CACHE\" {\n    default = \"\"\n}\n\nvariable DEFAULT_PHP_VERSION {\n    default = \"8.4\"\n}\n\nfunction \"tag\" {\n    params = [version, os, php-version, tgt]\n    result = [\n        version == \"\" ? \"\" : \"${IMAGE_NAME}:${trimprefix(\"${version}${tgt == \"builder\" ? \"-builder\" : \"\"}-php${php-version}-${os}\", \"latest-\")}\",\n        php-version == DEFAULT_PHP_VERSION && os == \"bookworm\" && version != \"\" ? \"${IMAGE_NAME}:${trimprefix(\"${version}${tgt == \"builder\" ? \"-builder\" : \"\"}\", \"latest-\")}\" : \"\",\n        php-version == DEFAULT_PHP_VERSION && version != \"\" ? \"${IMAGE_NAME}:${trimprefix(\"${version}${tgt == \"builder\" ? \"-builder\" : \"\"}-${os}\", \"latest-\")}\" : \"\",\n        os == \"bookworm\" && version != \"\" ? \"${IMAGE_NAME}:${trimprefix(\"${version}${tgt == \"builder\" ? \"-builder\" : \"\"}-php${php-version}\", \"latest-\")}\" : \"\",\n    ]\n}\n\n# cleanTag ensures that the tag is a valid Docker tag\n# cleanTag ensures that the tag is a valid Docker tag\n# see https://github.com/distribution/distribution/blob/v2.8.2/reference/regexp.go#L37\nfunction \"clean_tag\" {\n    params = [tag]\n    result = substr(regex_replace(regex_replace(tag, \"[^\\\\w.-]\", \"-\"), \"^([^\\\\w])\", \"r$0\"), 0, 127)\n}\n\n# semver adds semver-compliant tag if a semver version number is passed, or returns the revision itself\n# see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nfunction \"semver\" {\n  params = [rev]\n  result = __semver(_semver(regexall(\"^v?(?P<major>0|[1-9]\\\\d*)\\\\.(?P<minor>0|[1-9]\\\\d*)\\\\.(?P<patch>0|[1-9]\\\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\", rev)))\n}\n\nfunction \"_semver\" {\n    params = [matches]\n    result = length(matches) == 0 ? {} : matches[0]\n}\n\nfunction \"__semver\" {\n    params = [v]\n    result = v == {} ? [clean_tag(VERSION)] : v.prerelease == null ? [v.major, \"${v.major}.${v.minor}\", \"${v.major}.${v.minor}.${v.patch}\"] : [\"${v.major}.${v.minor}.${v.patch}-${v.prerelease}\"]\n}\n\nfunction \"php_version\" {\n    params = [v]\n    result = _php_version(v, regexall(\"(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\", v)[0])\n}\n\nfunction \"_php_version\" {\n    params = [v, m]\n    result = \"${m.major}.${m.minor}\" == DEFAULT_PHP_VERSION ? [v, \"${m.major}.${m.minor}\", \"${m.major}\"] : [v, \"${m.major}.${m.minor}\"]\n}\n\ntarget \"default\" {\n    name = \"${tgt}-php-${replace(php-version, \".\", \"-\")}-${os}\"\n    matrix = {\n        os = [\"bookworm\", \"alpine\"]\n        php-version = split(\",\", PHP_VERSION)\n        tgt = [\"builder\", \"runner\"]\n    }\n    contexts = {\n        php-base = \"docker-image://php:${php-version}-zts-${os}\"\n        golang-base = \"docker-image://golang:${GO_VERSION}-${os}\"\n    }\n    dockerfile = os == \"alpine\" ? \"alpine.Dockerfile\" : \"Dockerfile\"\n    context = \"./\"\n    target = tgt\n    # arm/v6 is only available for Alpine: https://github.com/docker-library/golang/issues/502\n    platforms = os == \"alpine\" ? [\n        \"linux/amd64\",\n        \"linux/386\",\n        # FIXME: armv6 doesn't build in GitHub actions because we use a custom Go build\n        #\"linux/arm/v6\",\n        \"linux/arm/v7\",\n        \"linux/arm64\",\n    ] : [\n        \"linux/amd64\",\n        \"linux/386\",\n        \"linux/arm/v7\",\n        \"linux/arm64\"\n    ]\n    tags = distinct(flatten(\n        [for pv in php_version(php-version) : flatten([\n            LATEST ? tag(\"latest\", os, pv, tgt) : [],\n            tag(SHA == \"\" || VERSION != \"dev\" ? \"\" : \"sha-${substr(SHA, 0, 7)}\", os, pv, tgt),\n            VERSION == \"dev\" ? [] : [for v in semver(VERSION) : tag(v, os, pv, tgt)]\n        ])\n    ]))\n    labels = {\n        \"org.opencontainers.image.created\" = \"${timestamp()}\"\n        \"org.opencontainers.image.version\" = VERSION\n        \"org.opencontainers.image.revision\" = SHA\n    }\n    args = {\n        FRANKENPHP_VERSION = VERSION\n    }\n}\n\ntarget \"static-builder\" {\n    contexts = {\n        golang-base = \"docker-image://golang:${GO_VERSION}-alpine\"\n    }\n    dockerfile = \"static-builder.Dockerfile\"\n    context = \"./\"\n    platforms = [\n        \"linux/amd64\",\n        \"linux/arm64\",\n    ]\n    tags = distinct(flatten([\n        LATEST ? \"${IMAGE_NAME}:static-builder\" : \"\",\n        SHA == \"\" || VERSION != \"dev\" ? \"\" : \"${IMAGE_NAME}:static-builder-sha-${substr(SHA, 0, 7)}\",\n        VERSION == \"dev\" ? [] : [for v in semver(VERSION) : \"${IMAGE_NAME}:static-builder-${v}\"]\n    ]))\n    labels = {\n        \"org.opencontainers.image.created\" = \"${timestamp()}\"\n        \"org.opencontainers.image.version\" = VERSION\n        \"org.opencontainers.image.revision\" = SHA\n    }\n    args = {\n        FRANKENPHP_VERSION = VERSION\n    }\n    secret = [\"id=github-token,env=GITHUB_TOKEN\"]\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "embed.go",
          "type": "blob",
          "size": 5.240234375,
          "content": "package frankenphp\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t_ \"embed\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\n// EmbeddedAppPath contains the path of the embedded PHP application (empty if none)\nvar EmbeddedAppPath string\n\n//go:embed app.tar\nvar embeddedApp []byte\n\n//go:embed app_checksum.txt\nvar embeddedAppChecksum []byte\n\nfunc init() {\n\tif len(embeddedApp) == 0 {\n\t\t// No embedded app\n\t\treturn\n\t}\n\n\tappPath := filepath.Join(os.TempDir(), \"frankenphp_\"+string(embeddedAppChecksum))\n\n\tif err := untar(appPath); err != nil {\n\t\t_ = os.RemoveAll(appPath)\n\t\tpanic(err)\n\t}\n\n\tEmbeddedAppPath = appPath\n}\n\n// untar reads the tar file from r and writes it into dir.\n//\n// Adapted from https://github.com/golang/build/blob/master/cmd/buildlet/buildlet.go\nfunc untar(dir string) (err error) {\n\tt0 := time.Now()\n\tnFiles := 0\n\tmadeDir := map[string]bool{}\n\n\ttr := tar.NewReader(bytes.NewReader(embeddedApp))\n\tloggedChtimesError := false\n\tfor {\n\t\tf, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"tar error: %w\", err)\n\t\t}\n\t\tif f.Typeflag == tar.TypeXGlobalHeader {\n\t\t\t// golang.org/issue/22748: git archive exports\n\t\t\t// a global header ('g') which after Go 1.9\n\t\t\t// (for a bit?) contained an empty filename.\n\t\t\t// Ignore it.\n\t\t\tcontinue\n\t\t}\n\t\trel, err := nativeRelPath(f.Name)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"tar file contained invalid name %q: %v\", f.Name, err)\n\t\t}\n\t\tabs := filepath.Join(dir, rel)\n\n\t\tfi := f.FileInfo()\n\t\tmode := fi.Mode()\n\t\tswitch {\n\t\tcase mode.IsRegular():\n\t\t\t// Make the directory. This is redundant because it should\n\t\t\t// already be made by a directory entry in the tar\n\t\t\t// beforehand. Thus, don't check for errors; the next\n\t\t\t// write will fail with the same error.\n\t\t\tdir := filepath.Dir(abs)\n\t\t\tif !madeDir[dir] {\n\t\t\t\tif err := os.MkdirAll(filepath.Dir(abs), mode.Perm()); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tmadeDir[dir] = true\n\t\t\t}\n\t\t\tif runtime.GOOS == \"darwin\" && mode&0111 != 0 {\n\t\t\t\t// See comment in writeFile.\n\t\t\t\terr := os.Remove(abs)\n\t\t\t\tif err != nil && !errors.Is(err, fs.ErrNotExist) {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := os.Stat(abs); os.IsNotExist(err) {\n\t\t\t\twf, err := os.OpenFile(abs, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode.Perm())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tn, err := io.Copy(wf, tr)\n\t\t\t\tif closeErr := wf.Close(); closeErr != nil && err == nil {\n\t\t\t\t\terr = closeErr\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing to %s: %v\", abs, err)\n\t\t\t\t}\n\t\t\t\tif n != f.Size {\n\t\t\t\t\treturn fmt.Errorf(\"only wrote %d bytes to %s; expected %d\", n, abs, f.Size)\n\t\t\t\t}\n\t\t\t\tmodTime := f.ModTime\n\t\t\t\tif modTime.After(t0) {\n\t\t\t\t\t// Clamp modtimes at system time. See\n\t\t\t\t\t// golang.org/issue/19062 when clock on\n\t\t\t\t\t// buildlet was behind the gitmirror server\n\t\t\t\t\t// doing the git-archive.\n\t\t\t\t\tmodTime = t0\n\t\t\t\t}\n\t\t\t\tif !modTime.IsZero() {\n\t\t\t\t\tif err := os.Chtimes(abs, modTime, modTime); err != nil && !loggedChtimesError {\n\t\t\t\t\t\t// benign error. Gerrit doesn't even set the\n\t\t\t\t\t\t// modtime in these, and we don't end up relying\n\t\t\t\t\t\t// on it anywhere (the gomote push command relies\n\t\t\t\t\t\t// on digests only), so this is a little pointless\n\t\t\t\t\t\t// for now.\n\t\t\t\t\t\tlog.Printf(\"error changing modtime: %v (further Chtimes errors suppressed)\", err)\n\t\t\t\t\t\tloggedChtimesError = true // once is enough\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnFiles++\n\t\tcase mode.IsDir():\n\t\t\tif err := os.MkdirAll(abs, mode.Perm()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmadeDir[abs] = true\n\t\tcase mode&os.ModeSymlink != 0:\n\t\t\t// TODO: ignore these for now. They were breaking x/build tests.\n\t\t\t// Implement these if/when we ever have a test that needs them.\n\t\t\t// But maybe we'd have to skip creating them on Windows for some builders\n\t\t\t// without permissions.\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"tar file entry %s contained unsupported file type %v\", f.Name, mode)\n\t\t}\n\t}\n\treturn nil\n}\n\n// nativeRelPath verifies that p is a non-empty relative path\n// using either slashes or the buildlet's native path separator,\n// and returns it canonicalized to the native path separator.\nfunc nativeRelPath(p string) (string, error) {\n\tif p == \"\" {\n\t\treturn \"\", errors.New(\"path not provided\")\n\t}\n\n\tif filepath.Separator != '/' && strings.Contains(p, string(filepath.Separator)) {\n\t\tclean := filepath.Clean(p)\n\t\tif filepath.IsAbs(clean) {\n\t\t\treturn \"\", fmt.Errorf(\"path %q is not relative\", p)\n\t\t}\n\t\tif clean == \"..\" || strings.HasPrefix(clean, \"..\"+string(filepath.Separator)) {\n\t\t\treturn \"\", fmt.Errorf(\"path %q refers to a parent directory\", p)\n\t\t}\n\t\tif strings.HasPrefix(p, string(filepath.Separator)) || filepath.VolumeName(clean) != \"\" {\n\t\t\t// On Windows, this catches semi-relative paths like \"C:\" (meaning âthe\n\t\t\t// current working directory on volume C:â) and \"\\windows\" (meaning âthe\n\t\t\t// windows subdirectory of the current drive letterâ).\n\t\t\treturn \"\", fmt.Errorf(\"path %q is relative to volume\", p)\n\t\t}\n\t\treturn p, nil\n\t}\n\n\tclean := path.Clean(p)\n\tif path.IsAbs(clean) {\n\t\treturn \"\", fmt.Errorf(\"path %q is not relative\", p)\n\t}\n\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n\t\treturn \"\", fmt.Errorf(\"path %q refers to a parent directory\", p)\n\t}\n\tcanon := filepath.FromSlash(p)\n\tif filepath.VolumeName(canon) != \"\" {\n\t\treturn \"\", fmt.Errorf(\"path %q begins with a native volume name\", p)\n\t}\n\treturn canon, nil\n}\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 1.8203125,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"os\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\n//export go_putenv\nfunc go_putenv(str *C.char, length C.int) C.bool {\n\tenvString := C.GoStringN(str, length)\n\n\t// Check if '=' is present in the string\n\tif key, val, found := strings.Cut(envString, \"=\"); found {\n\t\treturn os.Setenv(key, val) == nil\n\t}\n\n\t// No '=', unset the environment variable\n\treturn os.Unsetenv(envString) == nil\n}\n\n//export go_getfullenv\nfunc go_getfullenv(threadIndex C.uintptr_t) (*C.go_string, C.size_t) {\n\tthread := phpThreads[threadIndex]\n\n\tenv := os.Environ()\n\tgoStrings := make([]C.go_string, len(env)*2)\n\n\tfor i, envVar := range env {\n\t\tkey, val, _ := strings.Cut(envVar, \"=\")\n\t\tgoStrings[i*2] = C.go_string{C.size_t(len(key)), thread.pinString(key)}\n\t\tgoStrings[i*2+1] = C.go_string{C.size_t(len(val)), thread.pinString(val)}\n\t}\n\n\tvalue := unsafe.SliceData(goStrings)\n\tthread.Pin(value)\n\n\treturn value, C.size_t(len(env))\n}\n\n//export go_getenv\nfunc go_getenv(threadIndex C.uintptr_t, name *C.go_string) (C.bool, *C.go_string) {\n\tthread := phpThreads[threadIndex]\n\n\t// Create a byte slice from C string with a specified length\n\tenvName := C.GoStringN(name.data, C.int(name.len))\n\n\t// Get the environment variable value\n\tenvValue, exists := os.LookupEnv(envName)\n\tif !exists {\n\t\t// Environment variable does not exist\n\t\treturn false, nil // Return 0 to indicate failure\n\t}\n\n\t// Convert Go string to C string\n\tvalue := &C.go_string{C.size_t(len(envValue)), thread.pinString(envValue)}\n\tthread.Pin(value)\n\n\treturn true, value // Return 1 to indicate success\n}\n\n//export go_sapi_getenv\nfunc go_sapi_getenv(threadIndex C.uintptr_t, name *C.go_string) *C.char {\n\tenvName := C.GoStringN(name.data, C.int(name.len))\n\n\tenvValue, exists := os.LookupEnv(envName)\n\tif !exists {\n\t\treturn nil\n\t}\n\n\treturn phpThreads[threadIndex].pinCString(envValue)\n}\n"
        },
        {
          "name": "frankenphp.c",
          "type": "blob",
          "size": 35.4873046875,
          "content": "#include <SAPI.h>\n#include <Zend/zend_alloc.h>\n#include <Zend/zend_exceptions.h>\n#include <Zend/zend_interfaces.h>\n#include <Zend/zend_types.h>\n#include <errno.h>\n#include <ext/spl/spl_exceptions.h>\n#include <ext/standard/head.h>\n#include <inttypes.h>\n#include <php.h>\n#include <php_config.h>\n#include <php_ini.h>\n#include <php_main.h>\n#include <php_output.h>\n#include <php_variables.h>\n#include <pthread.h>\n#include <sapi/embed/php_embed.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#if defined(__linux__)\n#include <sys/prctl.h>\n#elif defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <pthread_np.h>\n#endif\n\n#include \"_cgo_export.h\"\n#include \"frankenphp_arginfo.h\"\n\n#if defined(PHP_WIN32) && defined(ZTS)\nZEND_TSRMLS_CACHE_DEFINE()\n#endif\n\n/* Timeouts are currently fundamentally broken with ZTS except on Linux and\n * FreeBSD: https://bugs.php.net/bug.php?id=79464 */\n#ifndef ZEND_MAX_EXECUTION_TIMERS\nstatic const char HARDCODED_INI[] = \"max_execution_time=0\\n\"\n                                    \"max_input_time=-1\\n\\0\";\n#endif\n\nstatic const char *MODULES_TO_RELOAD[] = {\"filter\", \"session\", NULL};\n\nfrankenphp_version frankenphp_get_version() {\n  return (frankenphp_version){\n      PHP_MAJOR_VERSION, PHP_MINOR_VERSION, PHP_RELEASE_VERSION,\n      PHP_EXTRA_VERSION, PHP_VERSION,       PHP_VERSION_ID,\n  };\n}\n\nfrankenphp_config frankenphp_get_config() {\n  return (frankenphp_config){\n      frankenphp_get_version(),\n#ifdef ZTS\n      true,\n#else\n      false,\n#endif\n#ifdef ZEND_SIGNALS\n      true,\n#else\n      false,\n#endif\n#ifdef ZEND_MAX_EXECUTION_TIMERS\n      true,\n#else\n      false,\n#endif\n  };\n}\n\ntypedef struct frankenphp_server_context {\n  bool has_main_request;\n  bool has_active_request;\n  bool worker_ready;\n  char *cookie_data;\n  bool finished;\n} frankenphp_server_context;\n\n__thread bool should_filter_var = 0;\n__thread frankenphp_server_context *local_ctx = NULL;\n__thread uintptr_t thread_index;\n__thread zval *os_environment = NULL;\n\nstatic void frankenphp_free_request_context() {\n  frankenphp_server_context *ctx = SG(server_context);\n\n  free(ctx->cookie_data);\n  ctx->cookie_data = NULL;\n\n  /* Is freed via thread.Unpin() */\n  SG(request_info).auth_password = NULL;\n  SG(request_info).auth_user = NULL;\n  SG(request_info).request_method = NULL;\n  SG(request_info).query_string = NULL;\n  SG(request_info).content_type = NULL;\n  SG(request_info).path_translated = NULL;\n  SG(request_info).request_uri = NULL;\n}\n\nstatic void frankenphp_destroy_super_globals() {\n  zend_try {\n    for (int i = 0; i < NUM_TRACK_VARS; i++) {\n      zval_ptr_dtor_nogc(&PG(http_globals)[i]);\n    }\n  }\n  zend_end_try();\n}\n\n/* Adapted from php_request_shutdown */\nstatic void frankenphp_worker_request_shutdown() {\n  /* Flush all output buffers */\n  zend_try { php_output_end_all(); }\n  zend_end_try();\n\n  /* TODO: store the list of modules to reload in a global module variable */\n  const char **module_name;\n  zend_module_entry *module;\n  for (module_name = MODULES_TO_RELOAD; *module_name; module_name++) {\n    if ((module = zend_hash_str_find_ptr(&module_registry, *module_name,\n                                         strlen(*module_name)))) {\n      module->request_shutdown_func(module->type, module->module_number);\n    }\n  }\n\n  /* Shutdown output layer (send the set HTTP headers, cleanup output handlers,\n   * etc.) */\n  zend_try { php_output_deactivate(); }\n  zend_end_try();\n\n  /* SAPI related shutdown (free stuff) */\n  frankenphp_free_request_context();\n  zend_try { sapi_deactivate(); }\n  zend_end_try();\n\n  zend_set_memory_limit(PG(memory_limit));\n  /* TODO: remove next line when https://github.com/php/php-src/pull/14499 will\n   * be available */\n  SG(rfc1867_uploaded_files) = NULL;\n}\n\nPHPAPI void get_full_env(zval *track_vars_array) {\n  struct go_getfullenv_return full_env = go_getfullenv(thread_index);\n\n  for (int i = 0; i < full_env.r1; i++) {\n    go_string key = full_env.r0[i * 2];\n    go_string val = full_env.r0[i * 2 + 1];\n\n    // create PHP strings for key and value\n    zend_string *key_str = zend_string_init(key.data, key.len, 0);\n    zend_string *val_str = zend_string_init(val.data, val.len, 0);\n\n    // add to the associative array\n    add_assoc_str(track_vars_array, ZSTR_VAL(key_str), val_str);\n\n    // release the key string\n    zend_string_release(key_str);\n  }\n}\n\n/* Adapted from php_request_startup() */\nstatic int frankenphp_worker_request_startup() {\n  int retval = SUCCESS;\n\n  zend_try {\n    frankenphp_destroy_super_globals();\n    php_output_activate();\n\n    /* initialize global variables */\n    PG(header_is_being_sent) = 0;\n    PG(connection_status) = PHP_CONNECTION_NORMAL;\n\n    /* Keep the current execution context */\n    sapi_activate();\n\n#ifdef ZEND_MAX_EXECUTION_TIMERS\n    if (PG(max_input_time) == -1) {\n      zend_set_timeout(EG(timeout_seconds), 1);\n    } else {\n      zend_set_timeout(PG(max_input_time), 1);\n    }\n#endif\n\n    if (PG(expose_php)) {\n      sapi_add_header(SAPI_PHP_VERSION_HEADER,\n                      sizeof(SAPI_PHP_VERSION_HEADER) - 1, 1);\n    }\n\n    if (PG(output_handler) && PG(output_handler)[0]) {\n      zval oh;\n\n      ZVAL_STRING(&oh, PG(output_handler));\n      php_output_start_user(&oh, 0, PHP_OUTPUT_HANDLER_STDFLAGS);\n      zval_ptr_dtor(&oh);\n    } else if (PG(output_buffering)) {\n      php_output_start_user(NULL,\n                            PG(output_buffering) > 1 ? PG(output_buffering) : 0,\n                            PHP_OUTPUT_HANDLER_STDFLAGS);\n    } else if (PG(implicit_flush)) {\n      php_output_set_implicit_flush(1);\n    }\n\n    php_hash_environment();\n\n    zend_is_auto_global(ZSTR_KNOWN(ZEND_STR_AUTOGLOBAL_SERVER));\n\n    /* Unfinish the request */\n    frankenphp_server_context *ctx = SG(server_context);\n    ctx->finished = false;\n\n    /* TODO: store the list of modules to reload in a global module variable */\n    const char **module_name;\n    zend_module_entry *module;\n    for (module_name = MODULES_TO_RELOAD; *module_name; module_name++) {\n      if ((module = zend_hash_str_find_ptr(&module_registry, *module_name,\n                                           sizeof(*module_name) - 1)) &&\n          module->request_startup_func) {\n        module->request_startup_func(module->type, module->module_number);\n      }\n    }\n  }\n  zend_catch { retval = FAILURE; }\n  zend_end_try();\n\n  SG(sapi_started) = 1;\n\n  return retval;\n}\n\nPHP_FUNCTION(frankenphp_finish_request) { /* {{{ */\n  if (zend_parse_parameters_none() == FAILURE) {\n    RETURN_THROWS();\n  }\n\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (ctx->finished) {\n    RETURN_FALSE;\n  }\n\n  php_output_end_all();\n  php_header();\n\n  if (ctx->has_active_request) {\n    go_frankenphp_finish_php_request(thread_index);\n  }\n\n  ctx->finished = true;\n\n  RETURN_TRUE;\n} /* }}} */\n\n/* {{{ Call go's putenv to prevent race conditions */\nPHP_FUNCTION(frankenphp_putenv) {\n  char *setting;\n  size_t setting_len;\n\n  ZEND_PARSE_PARAMETERS_START(1, 1)\n  Z_PARAM_STRING(setting, setting_len)\n  ZEND_PARSE_PARAMETERS_END();\n\n  // Cast str_len to int (ensure it fits in an int)\n  if (setting_len > INT_MAX) {\n    php_error(E_WARNING, \"String length exceeds maximum integer value\");\n    RETURN_FALSE;\n  }\n\n  if (go_putenv(setting, (int)setting_len)) {\n    RETURN_TRUE;\n  } else {\n    RETURN_FALSE;\n  }\n} /* }}} */\n\n/* {{{ Call go's getenv to prevent race conditions */\nPHP_FUNCTION(frankenphp_getenv) {\n  char *name = NULL;\n  size_t name_len = 0;\n  bool local_only = 0;\n\n  ZEND_PARSE_PARAMETERS_START(0, 2)\n  Z_PARAM_OPTIONAL\n  Z_PARAM_STRING_OR_NULL(name, name_len)\n  Z_PARAM_BOOL(local_only)\n  ZEND_PARSE_PARAMETERS_END();\n\n  if (!name) {\n    array_init(return_value);\n    get_full_env(return_value);\n\n    return;\n  }\n\n  go_string gname = {name_len, name};\n\n  struct go_getenv_return result = go_getenv(thread_index, &gname);\n\n  if (result.r0) {\n    // Return the single environment variable as a string\n    RETVAL_STRINGL(result.r1->data, result.r1->len);\n  } else {\n    // Environment variable does not exist\n    RETVAL_FALSE;\n  }\n} /* }}} */\n\n/* {{{ Fetch all HTTP request headers */\nPHP_FUNCTION(frankenphp_request_headers) {\n  if (zend_parse_parameters_none() == FAILURE) {\n    RETURN_THROWS();\n  }\n\n  frankenphp_server_context *ctx = SG(server_context);\n  struct go_apache_request_headers_return headers =\n      go_apache_request_headers(thread_index, ctx->has_active_request);\n\n  array_init_size(return_value, headers.r1);\n\n  for (size_t i = 0; i < headers.r1; i++) {\n    go_string key = headers.r0[i * 2];\n    go_string val = headers.r0[i * 2 + 1];\n\n    add_assoc_stringl_ex(return_value, key.data, key.len, val.data, val.len);\n  }\n}\n/* }}} */\n\n/* add_response_header and apache_response_headers are copied from\n * https://github.com/php/php-src/blob/master/sapi/cli/php_cli_server.c\n * Copyright (c) The PHP Group\n * Licensed under The PHP License\n * Original authors: Moriyoshi Koizumi <moriyoshi@php.net> and Xinchen Hui\n * <laruence@php.net>\n */\nstatic void add_response_header(sapi_header_struct *h,\n                                zval *return_value) /* {{{ */\n{\n  if (h->header_len > 0) {\n    char *s;\n    size_t len = 0;\n    ALLOCA_FLAG(use_heap)\n\n    char *p = strchr(h->header, ':');\n    if (NULL != p) {\n      len = p - h->header;\n    }\n    if (len > 0) {\n      while (len != 0 &&\n             (h->header[len - 1] == ' ' || h->header[len - 1] == '\\t')) {\n        len--;\n      }\n      if (len) {\n        s = do_alloca(len + 1, use_heap);\n        memcpy(s, h->header, len);\n        s[len] = 0;\n        do {\n          p++;\n        } while (*p == ' ' || *p == '\\t');\n        add_assoc_stringl_ex(return_value, s, len, p,\n                             h->header_len - (p - h->header));\n        free_alloca(s, use_heap);\n      }\n    }\n  }\n}\n/* }}} */\n\nPHP_FUNCTION(frankenphp_response_headers) /* {{{ */\n{\n  if (zend_parse_parameters_none() == FAILURE) {\n    RETURN_THROWS();\n  }\n\n  array_init(return_value);\n  zend_llist_apply_with_argument(\n      &SG(sapi_headers).headers,\n      (llist_apply_with_arg_func_t)add_response_header, return_value);\n}\n/* }}} */\n\nPHP_FUNCTION(frankenphp_handle_request) {\n  zend_fcall_info fci;\n  zend_fcall_info_cache fcc;\n\n  ZEND_PARSE_PARAMETERS_START(1, 1)\n  Z_PARAM_FUNC(fci, fcc)\n  ZEND_PARSE_PARAMETERS_END();\n\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (!ctx->has_main_request) {\n    /* not a worker, throw an error */\n    zend_throw_exception(\n        spl_ce_RuntimeException,\n        \"frankenphp_handle_request() called while not in worker mode\", 0);\n    RETURN_THROWS();\n  }\n\n  if (!ctx->worker_ready) {\n    /* Clean the first dummy request created to initialize the worker */\n    frankenphp_worker_request_shutdown();\n\n    ctx->worker_ready = true;\n  }\n\n#ifdef ZEND_MAX_EXECUTION_TIMERS\n  /* Disable timeouts while waiting for a request to handle */\n  zend_unset_timeout();\n#endif\n\n  bool request = go_frankenphp_worker_handle_request_start(thread_index);\n  if (frankenphp_worker_request_startup() == FAILURE\n      /* Shutting down */\n      || !request) {\n    RETURN_FALSE;\n  }\n\n#ifdef ZEND_MAX_EXECUTION_TIMERS\n  /*\n   * Reset default timeout\n   */\n  if (PG(max_input_time) != -1) {\n    zend_set_timeout(INI_INT(\"max_execution_time\"), 0);\n  }\n#endif\n\n  /* Call the PHP func */\n  zval retval = {0};\n  fci.size = sizeof fci;\n  fci.retval = &retval;\n  if (zend_call_function(&fci, &fcc) == SUCCESS) {\n    zval_ptr_dtor(&retval);\n  }\n\n  /*\n   * If an exception occured, print the message to the client before closing the\n   * connection\n   */\n  if (EG(exception)) {\n    zend_exception_error(EG(exception), E_ERROR);\n  }\n\n  frankenphp_worker_request_shutdown();\n  ctx->has_active_request = false;\n  go_frankenphp_finish_worker_request(thread_index);\n\n  RETURN_TRUE;\n}\n\nPHP_FUNCTION(headers_send) {\n  zend_long response_code = 200;\n\n  ZEND_PARSE_PARAMETERS_START(0, 1)\n  Z_PARAM_OPTIONAL\n  Z_PARAM_LONG(response_code)\n  ZEND_PARSE_PARAMETERS_END();\n\n  int previous_status_code = SG(sapi_headers).http_response_code;\n  SG(sapi_headers).http_response_code = response_code;\n\n  if (response_code >= 100 && response_code < 200) {\n    int ret = sapi_module.send_headers(&SG(sapi_headers));\n    SG(sapi_headers).http_response_code = previous_status_code;\n\n    RETURN_LONG(ret);\n  }\n\n  RETURN_LONG(sapi_send_headers());\n}\n\nPHP_MINIT_FUNCTION(frankenphp) {\n  zend_function *func;\n\n  // Override putenv\n  func = zend_hash_str_find_ptr(CG(function_table), \"putenv\",\n                                sizeof(\"putenv\") - 1);\n  if (func != NULL && func->type == ZEND_INTERNAL_FUNCTION) {\n    ((zend_internal_function *)func)->handler = ZEND_FN(frankenphp_putenv);\n  } else {\n    php_error(E_WARNING, \"Failed to find built-in putenv function\");\n  }\n\n  // Override getenv\n  func = zend_hash_str_find_ptr(CG(function_table), \"getenv\",\n                                sizeof(\"getenv\") - 1);\n  if (func != NULL && func->type == ZEND_INTERNAL_FUNCTION) {\n    ((zend_internal_function *)func)->handler = ZEND_FN(frankenphp_getenv);\n  } else {\n    php_error(E_WARNING, \"Failed to find built-in getenv function\");\n  }\n\n  return SUCCESS;\n}\n\nstatic zend_module_entry frankenphp_module = {\n    STANDARD_MODULE_HEADER,\n    \"frankenphp\",\n    ext_functions,         /* function table */\n    PHP_MINIT(frankenphp), /* initialization */\n    NULL,                  /* shutdown */\n    NULL,                  /* request initialization */\n    NULL,                  /* request shutdown */\n    NULL,                  /* information */\n    TOSTRING(FRANKENPHP_VERSION),\n    STANDARD_MODULE_PROPERTIES};\n\nstatic void frankenphp_request_shutdown() {\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (ctx->has_main_request && ctx->has_active_request) {\n    frankenphp_destroy_super_globals();\n  }\n\n  php_request_shutdown((void *)0);\n  frankenphp_free_request_context();\n\n  memset(local_ctx, 0, sizeof(frankenphp_server_context));\n}\n\nint frankenphp_update_server_context(\n    bool create, bool has_main_request, bool has_active_request,\n\n    const char *request_method, char *query_string, zend_long content_length,\n    char *path_translated, char *request_uri, const char *content_type,\n    char *auth_user, char *auth_password, int proto_num) {\n  frankenphp_server_context *ctx;\n\n  if (create) {\n    ctx = local_ctx;\n\n    ctx->worker_ready = false;\n    ctx->cookie_data = NULL;\n    ctx->finished = false;\n\n    SG(server_context) = ctx;\n  } else {\n    ctx = (frankenphp_server_context *)SG(server_context);\n  }\n\n  // It is not reset by zend engine, set it to 200.\n  SG(sapi_headers).http_response_code = 200;\n\n  ctx->has_main_request = has_main_request;\n  ctx->has_active_request = has_active_request;\n\n  SG(request_info).auth_password = auth_password;\n  SG(request_info).auth_user = auth_user;\n  SG(request_info).request_method = request_method;\n  SG(request_info).query_string = query_string;\n  SG(request_info).content_type = content_type;\n  SG(request_info).content_length = content_length;\n  SG(request_info).path_translated = path_translated;\n  SG(request_info).request_uri = request_uri;\n  SG(request_info).proto_num = proto_num;\n\n  return SUCCESS;\n}\n\nstatic int frankenphp_startup(sapi_module_struct *sapi_module) {\n  php_import_environment_variables = get_full_env;\n\n  return php_module_startup(sapi_module, &frankenphp_module);\n}\n\nstatic int frankenphp_deactivate(void) {\n  /* TODO: flush everything */\n  return SUCCESS;\n}\n\nstatic size_t frankenphp_ub_write(const char *str, size_t str_length) {\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (ctx->finished) {\n    /* TODO: maybe log a warning that we tried to write to a finished request?\n     */\n    return 0;\n  }\n\n  struct go_ub_write_return result =\n      go_ub_write(thread_index, (char *)str, str_length);\n\n  if (result.r1) {\n    php_handle_aborted_connection();\n  }\n\n  return result.r0;\n}\n\nstatic int frankenphp_send_headers(sapi_headers_struct *sapi_headers) {\n  if (SG(request_info).no_headers == 1) {\n    return SAPI_HEADER_SENT_SUCCESSFULLY;\n  }\n\n  int status;\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (!ctx->has_active_request) {\n    return SAPI_HEADER_SEND_FAILED;\n  }\n\n  if (SG(sapi_headers).http_status_line) {\n    status = atoi((SG(sapi_headers).http_status_line) + 9);\n  } else {\n    status = SG(sapi_headers).http_response_code;\n\n    if (!status) {\n      status = 200;\n    }\n  }\n\n  go_write_headers(thread_index, status, &sapi_headers->headers);\n\n  return SAPI_HEADER_SENT_SUCCESSFULLY;\n}\n\nstatic void frankenphp_sapi_flush(void *server_context) {\n  frankenphp_server_context *ctx = (frankenphp_server_context *)server_context;\n\n  if (ctx && ctx->has_active_request && go_sapi_flush(thread_index)) {\n    php_handle_aborted_connection();\n  }\n}\n\nstatic size_t frankenphp_read_post(char *buffer, size_t count_bytes) {\n  frankenphp_server_context *ctx = SG(server_context);\n\n  return ctx->has_active_request\n             ? go_read_post(thread_index, buffer, count_bytes)\n             : 0;\n}\n\nstatic char *frankenphp_read_cookies(void) {\n  frankenphp_server_context *ctx = SG(server_context);\n\n  if (!ctx->has_active_request) {\n    return \"\";\n  }\n\n  ctx->cookie_data = go_read_cookies(thread_index);\n\n  return ctx->cookie_data;\n}\n\n/* all variables with well defined keys can safely be registered like this */\nvoid frankenphp_register_trusted_var(zend_string *z_key, char *value,\n                                     size_t val_len, HashTable *ht) {\n  if (value == NULL) {\n    zval empty;\n    ZVAL_EMPTY_STRING(&empty);\n    zend_hash_update_ind(ht, z_key, &empty);\n    return;\n  }\n  size_t new_val_len = val_len;\n\n  if (!should_filter_var ||\n      sapi_module.input_filter(PARSE_SERVER, ZSTR_VAL(z_key), &value,\n                               new_val_len, &new_val_len)) {\n    zval z_value;\n    ZVAL_STRINGL_FAST(&z_value, value, new_val_len);\n    zend_hash_update_ind(ht, z_key, &z_value);\n  }\n}\n\n/* Register known $_SERVER variables in bulk to avoid cgo overhead */\nvoid frankenphp_register_bulk(\n    zval *track_vars_array, ht_key_value_pair remote_addr,\n    ht_key_value_pair remote_host, ht_key_value_pair remote_port,\n    ht_key_value_pair document_root, ht_key_value_pair path_info,\n    ht_key_value_pair php_self, ht_key_value_pair document_uri,\n    ht_key_value_pair script_filename, ht_key_value_pair script_name,\n    ht_key_value_pair https, ht_key_value_pair ssl_protocol,\n    ht_key_value_pair request_scheme, ht_key_value_pair server_name,\n    ht_key_value_pair server_port, ht_key_value_pair content_length,\n    ht_key_value_pair gateway_interface, ht_key_value_pair server_protocol,\n    ht_key_value_pair server_software, ht_key_value_pair http_host,\n    ht_key_value_pair auth_type, ht_key_value_pair remote_ident,\n    ht_key_value_pair request_uri) {\n  HashTable *ht = Z_ARRVAL_P(track_vars_array);\n  frankenphp_register_trusted_var(remote_addr.key, remote_addr.val,\n                                  remote_addr.val_len, ht);\n  frankenphp_register_trusted_var(remote_host.key, remote_host.val,\n                                  remote_host.val_len, ht);\n  frankenphp_register_trusted_var(remote_port.key, remote_port.val,\n                                  remote_port.val_len, ht);\n  frankenphp_register_trusted_var(document_root.key, document_root.val,\n                                  document_root.val_len, ht);\n  frankenphp_register_trusted_var(path_info.key, path_info.val,\n                                  path_info.val_len, ht);\n  frankenphp_register_trusted_var(php_self.key, php_self.val, php_self.val_len,\n                                  ht);\n  frankenphp_register_trusted_var(document_uri.key, document_uri.val,\n                                  document_uri.val_len, ht);\n  frankenphp_register_trusted_var(script_filename.key, script_filename.val,\n                                  script_filename.val_len, ht);\n  frankenphp_register_trusted_var(script_name.key, script_name.val,\n                                  script_name.val_len, ht);\n  frankenphp_register_trusted_var(https.key, https.val, https.val_len, ht);\n  frankenphp_register_trusted_var(ssl_protocol.key, ssl_protocol.val,\n                                  ssl_protocol.val_len, ht);\n  frankenphp_register_trusted_var(request_scheme.key, request_scheme.val,\n                                  request_scheme.val_len, ht);\n  frankenphp_register_trusted_var(server_name.key, server_name.val,\n                                  server_name.val_len, ht);\n  frankenphp_register_trusted_var(server_port.key, server_port.val,\n                                  server_port.val_len, ht);\n  frankenphp_register_trusted_var(content_length.key, content_length.val,\n                                  content_length.val_len, ht);\n  frankenphp_register_trusted_var(gateway_interface.key, gateway_interface.val,\n                                  gateway_interface.val_len, ht);\n  frankenphp_register_trusted_var(server_protocol.key, server_protocol.val,\n                                  server_protocol.val_len, ht);\n  frankenphp_register_trusted_var(server_software.key, server_software.val,\n                                  server_software.val_len, ht);\n  frankenphp_register_trusted_var(http_host.key, http_host.val,\n                                  http_host.val_len, ht);\n  frankenphp_register_trusted_var(auth_type.key, auth_type.val,\n                                  auth_type.val_len, ht);\n  frankenphp_register_trusted_var(remote_ident.key, remote_ident.val,\n                                  remote_ident.val_len, ht);\n  frankenphp_register_trusted_var(request_uri.key, request_uri.val,\n                                  request_uri.val_len, ht);\n}\n\n/** Persistent strings are ignored by the PHP GC, we have to release these\n * ourselves **/\nzend_string *frankenphp_init_persistent_string(const char *string, size_t len) {\n  return zend_string_init(string, len, 1);\n}\n\nvoid frankenphp_release_zend_string(zend_string *z_string) {\n  zend_string_release(z_string);\n}\n\nstatic void\nfrankenphp_register_variable_from_request_info(zend_string *zKey, char *value,\n                                               bool must_be_present,\n                                               zval *track_vars_array) {\n  if (value != NULL) {\n    frankenphp_register_trusted_var(zKey, value, strlen(value),\n                                    Z_ARRVAL_P(track_vars_array));\n  } else if (must_be_present) {\n    frankenphp_register_trusted_var(zKey, \"\", 0, Z_ARRVAL_P(track_vars_array));\n  }\n}\n\nvoid frankenphp_register_variables_from_request_info(\n    zval *track_vars_array, zend_string *content_type,\n    zend_string *path_translated, zend_string *query_string,\n    zend_string *auth_user, zend_string *request_method) {\n  frankenphp_register_variable_from_request_info(\n      content_type, (char *)SG(request_info).content_type, false,\n      track_vars_array);\n  frankenphp_register_variable_from_request_info(\n      path_translated, (char *)SG(request_info).path_translated, false,\n      track_vars_array);\n  frankenphp_register_variable_from_request_info(\n      query_string, SG(request_info).query_string, true, track_vars_array);\n  frankenphp_register_variable_from_request_info(\n      auth_user, (char *)SG(request_info).auth_user, false, track_vars_array);\n  frankenphp_register_variable_from_request_info(\n      request_method, (char *)SG(request_info).request_method, false,\n      track_vars_array);\n}\n\n/* variables with user-defined keys must be registered safely\n * see: php_variables.c -> php_register_variable_ex (#1106) */\nvoid frankenphp_register_variable_safe(char *key, char *val, size_t val_len,\n                                       zval *track_vars_array) {\n  if (key == NULL) {\n    return;\n  }\n  if (val == NULL) {\n    val = \"\";\n  }\n  size_t new_val_len = val_len;\n  if (!should_filter_var ||\n      sapi_module.input_filter(PARSE_SERVER, key, &val, new_val_len,\n                               &new_val_len)) {\n    php_register_variable_safe(key, val, new_val_len, track_vars_array);\n  }\n}\n\nstatic void frankenphp_register_variables(zval *track_vars_array) {\n  /* https://www.php.net/manual/en/reserved.variables.server.php */\n\n  /* In CGI mode, we consider the environment to be a part of the server\n   * variables.\n   */\n\n  frankenphp_server_context *ctx = SG(server_context);\n\n  /* in non-worker mode we import the os environment regularly */\n  if (!ctx->has_main_request) {\n    get_full_env(track_vars_array);\n    // php_import_environment_variables(track_vars_array);\n    go_register_variables(thread_index, track_vars_array);\n    return;\n  }\n\n  /* In worker mode we cache the os environment */\n  if (os_environment == NULL) {\n    os_environment = malloc(sizeof(zval));\n    array_init(os_environment);\n    get_full_env(os_environment);\n    // php_import_environment_variables(os_environment);\n  }\n  zend_hash_copy(Z_ARR_P(track_vars_array), Z_ARR_P(os_environment),\n                 (copy_ctor_func_t)zval_add_ref);\n\n  go_register_variables(thread_index, track_vars_array);\n}\n\nstatic void frankenphp_log_message(const char *message, int syslog_type_int) {\n  go_log((char *)message, syslog_type_int);\n}\n\nstatic char *frankenphp_getenv(const char *name, size_t name_len) {\n  go_string gname = {name_len, (char *)name};\n\n  return go_sapi_getenv(thread_index, &gname);\n}\n\nsapi_module_struct frankenphp_sapi_module = {\n    \"frankenphp\", /* name */\n    \"FrankenPHP\", /* pretty name */\n\n    frankenphp_startup,          /* startup */\n    php_module_shutdown_wrapper, /* shutdown */\n\n    NULL,                  /* activate */\n    frankenphp_deactivate, /* deactivate */\n\n    frankenphp_ub_write,   /* unbuffered write */\n    frankenphp_sapi_flush, /* flush */\n    NULL,                  /* get uid */\n    frankenphp_getenv,     /* getenv */\n\n    php_error, /* error handler */\n\n    NULL,                    /* header handler */\n    frankenphp_send_headers, /* send headers handler */\n    NULL,                    /* send header handler */\n\n    frankenphp_read_post,    /* read POST data */\n    frankenphp_read_cookies, /* read Cookies */\n\n    frankenphp_register_variables, /* register server variables */\n    frankenphp_log_message,        /* Log message */\n    NULL,                          /* Get request time */\n    NULL,                          /* Child terminate */\n\n    STANDARD_SAPI_MODULE_PROPERTIES};\n\n/* Sets thread name for profiling and debugging.\n *\n * Adapted from https://github.com/Pithikos/C-Thread-Pool\n * Copyright: Johan Hanssen Seferidis\n * License: MIT\n */\nstatic void set_thread_name(char *thread_name) {\n#if defined(__linux__)\n  /* Use prctl instead to prevent using _GNU_SOURCE flag and implicit\n   * declaration */\n  prctl(PR_SET_NAME, thread_name);\n#elif defined(__APPLE__) && defined(__MACH__)\n  pthread_setname_np(thread_name);\n#elif defined(__FreeBSD__) || defined(__OpenBSD__)\n  pthread_set_name_np(pthread_self(), thread_name);\n#endif\n}\n\nstatic void *php_thread(void *arg) {\n  thread_index = (uintptr_t)arg;\n  char thread_name[16] = {0};\n  snprintf(thread_name, 16, \"php-%\" PRIxPTR, thread_index);\n  set_thread_name(thread_name);\n\n#ifdef ZTS\n  /* initial resource fetch */\n  (void)ts_resource(0);\n#ifdef PHP_WIN32\n  ZEND_TSRMLS_CACHE_UPDATE();\n#endif\n#endif\n\n  local_ctx = malloc(sizeof(frankenphp_server_context));\n\n  /* check if a default filter is set in php.ini and only filter if\n   * it is, this is deprecated and will be removed in PHP 9 */\n  char *default_filter;\n  cfg_get_string(\"filter.default\", &default_filter);\n  should_filter_var = default_filter != NULL;\n\n  // loop until Go signals to stop\n  char *scriptName = NULL;\n  while ((scriptName = go_frankenphp_before_script_execution(thread_index))) {\n    go_frankenphp_after_script_execution(thread_index,\n                                         frankenphp_execute_script(scriptName));\n  }\n\n  go_frankenphp_release_known_variable_keys(thread_index);\n\n#ifdef ZTS\n  ts_free_thread();\n#endif\n\n  go_frankenphp_on_thread_shutdown(thread_index);\n\n  return NULL;\n}\n\nstatic void *php_main(void *arg) {\n  /*\n   * SIGPIPE must be masked in non-Go threads:\n   * https://pkg.go.dev/os/signal#hdr-Go_programs_that_use_cgo_or_SWIG\n   */\n  sigset_t set;\n  sigemptyset(&set);\n  sigaddset(&set, SIGPIPE);\n\n  if (pthread_sigmask(SIG_BLOCK, &set, NULL) != 0) {\n    perror(\"failed to block SIGPIPE\");\n    exit(EXIT_FAILURE);\n  }\n\n  set_thread_name(\"php-main\");\n\n#ifdef ZTS\n#if (PHP_VERSION_ID >= 80300)\n  php_tsrm_startup_ex((intptr_t)arg);\n#else\n  php_tsrm_startup();\n#endif\n  /*tsrm_error_set(TSRM_ERROR_LEVEL_INFO, NULL);*/\n#ifdef PHP_WIN32\n  ZEND_TSRMLS_CACHE_UPDATE();\n#endif\n#endif\n\n  sapi_startup(&frankenphp_sapi_module);\n\n#ifndef ZEND_MAX_EXECUTION_TIMERS\n#if (PHP_VERSION_ID >= 80300)\n  frankenphp_sapi_module.ini_entries = HARDCODED_INI;\n#else\n  frankenphp_sapi_module.ini_entries = malloc(sizeof(HARDCODED_INI));\n  if (frankenphp_sapi_module.ini_entries == NULL) {\n    perror(\"malloc failed\");\n    exit(EXIT_FAILURE);\n  }\n  memcpy(frankenphp_sapi_module.ini_entries, HARDCODED_INI,\n         sizeof(HARDCODED_INI));\n#endif\n#endif\n\n  frankenphp_sapi_module.startup(&frankenphp_sapi_module);\n\n  go_frankenphp_main_thread_is_ready();\n\n  /* channel closed, shutdown gracefully */\n  frankenphp_sapi_module.shutdown(&frankenphp_sapi_module);\n\n  sapi_shutdown();\n#ifdef ZTS\n  tsrm_shutdown();\n#endif\n\n#if (PHP_VERSION_ID < 80300)\n  if (frankenphp_sapi_module.ini_entries) {\n    free(frankenphp_sapi_module.ini_entries);\n    frankenphp_sapi_module.ini_entries = NULL;\n  }\n#endif\n  go_frankenphp_shutdown_main_thread();\n  return NULL;\n}\n\nint frankenphp_new_main_thread(int num_threads) {\n  pthread_t thread;\n\n  if (pthread_create(&thread, NULL, &php_main, (void *)(intptr_t)num_threads) !=\n      0) {\n    return -1;\n  }\n\n  return pthread_detach(thread);\n}\n\nbool frankenphp_new_php_thread(uintptr_t thread_index) {\n  pthread_t thread;\n  if (pthread_create(&thread, NULL, &php_thread, (void *)thread_index) != 0) {\n    return false;\n  }\n  pthread_detach(thread);\n  return true;\n}\n\nint frankenphp_request_startup() {\n  if (php_request_startup() == SUCCESS) {\n    return SUCCESS;\n  }\n\n  php_request_shutdown((void *)0);\n\n  return FAILURE;\n}\n\nint frankenphp_execute_script(char *file_name) {\n  if (frankenphp_request_startup() == FAILURE) {\n\n    return FAILURE;\n  }\n\n  int status = SUCCESS;\n\n  zend_file_handle file_handle;\n  zend_stream_init_filename(&file_handle, file_name);\n\n  file_handle.primary_script = 1;\n\n  zend_first_try {\n    EG(exit_status) = 0;\n    php_execute_script(&file_handle);\n    status = EG(exit_status);\n  }\n  zend_catch { status = EG(exit_status); }\n  zend_end_try();\n\n  // free the cached os environment before shutting down the script\n  if (os_environment != NULL) {\n    zval_ptr_dtor(os_environment);\n    free(os_environment);\n    os_environment = NULL;\n  }\n\n  zend_destroy_file_handle(&file_handle);\n\n  frankenphp_free_request_context();\n  frankenphp_request_shutdown();\n\n  return status;\n}\n\n/* Use global variables to store CLI arguments to prevent useless allocations */\nstatic char *cli_script;\nstatic int cli_argc;\nstatic char **cli_argv;\n\n/*\n * CLI code is adapted from\n * https://github.com/php/php-src/blob/master/sapi/cli/php_cli.c Copyright (c)\n * The PHP Group Licensed under The PHP License Original uthors: Edin Kadribasic\n * <edink@php.net>, Marcus Boerger <helly@php.net> and Johannes Schlueter\n * <johannes@php.net> Parts based on CGI SAPI Module by Rasmus Lerdorf, Stig\n * Bakken and Zeev Suraski\n */\nstatic void cli_register_file_handles(bool no_close) /* {{{ */\n{\n  php_stream *s_in, *s_out, *s_err;\n  php_stream_context *sc_in = NULL, *sc_out = NULL, *sc_err = NULL;\n  zend_constant ic, oc, ec;\n\n  s_in = php_stream_open_wrapper_ex(\"php://stdin\", \"rb\", 0, NULL, sc_in);\n  s_out = php_stream_open_wrapper_ex(\"php://stdout\", \"wb\", 0, NULL, sc_out);\n  s_err = php_stream_open_wrapper_ex(\"php://stderr\", \"wb\", 0, NULL, sc_err);\n\n  if (s_in == NULL || s_out == NULL || s_err == NULL) {\n    if (s_in)\n      php_stream_close(s_in);\n    if (s_out)\n      php_stream_close(s_out);\n    if (s_err)\n      php_stream_close(s_err);\n    return;\n  }\n\n  if (no_close) {\n    s_in->flags |= PHP_STREAM_FLAG_NO_CLOSE;\n    s_out->flags |= PHP_STREAM_FLAG_NO_CLOSE;\n    s_err->flags |= PHP_STREAM_FLAG_NO_CLOSE;\n  }\n\n  /*s_in_process = s_in;*/\n\n  php_stream_to_zval(s_in, &ic.value);\n  php_stream_to_zval(s_out, &oc.value);\n  php_stream_to_zval(s_err, &ec.value);\n\n  ZEND_CONSTANT_SET_FLAGS(&ic, CONST_CS, 0);\n  ic.name = zend_string_init_interned(\"STDIN\", sizeof(\"STDIN\") - 1, 0);\n  zend_register_constant(&ic);\n\n  ZEND_CONSTANT_SET_FLAGS(&oc, CONST_CS, 0);\n  oc.name = zend_string_init_interned(\"STDOUT\", sizeof(\"STDOUT\") - 1, 0);\n  zend_register_constant(&oc);\n\n  ZEND_CONSTANT_SET_FLAGS(&ec, CONST_CS, 0);\n  ec.name = zend_string_init_interned(\"STDERR\", sizeof(\"STDERR\") - 1, 0);\n  zend_register_constant(&ec);\n}\n/* }}} */\n\nstatic void sapi_cli_register_variables(zval *track_vars_array) /* {{{ */\n{\n  size_t len;\n  char *docroot = \"\";\n\n  /*\n   * In CGI mode, we consider the environment to be a part of the server\n   * variables\n   */\n  php_import_environment_variables(track_vars_array);\n\n  /* Build the special-case PHP_SELF variable for the CLI version */\n  len = strlen(cli_script);\n  if (sapi_module.input_filter(PARSE_SERVER, \"PHP_SELF\", &cli_script, len,\n                               &len)) {\n    php_register_variable_safe(\"PHP_SELF\", cli_script, len, track_vars_array);\n  }\n  if (sapi_module.input_filter(PARSE_SERVER, \"SCRIPT_NAME\", &cli_script, len,\n                               &len)) {\n    php_register_variable_safe(\"SCRIPT_NAME\", cli_script, len,\n                               track_vars_array);\n  }\n  /* filenames are empty for stdin */\n  if (sapi_module.input_filter(PARSE_SERVER, \"SCRIPT_FILENAME\", &cli_script,\n                               len, &len)) {\n    php_register_variable_safe(\"SCRIPT_FILENAME\", cli_script, len,\n                               track_vars_array);\n  }\n  if (sapi_module.input_filter(PARSE_SERVER, \"PATH_TRANSLATED\", &cli_script,\n                               len, &len)) {\n    php_register_variable_safe(\"PATH_TRANSLATED\", cli_script, len,\n                               track_vars_array);\n  }\n  /* just make it available */\n  len = 0U;\n  if (sapi_module.input_filter(PARSE_SERVER, \"DOCUMENT_ROOT\", &docroot, len,\n                               &len)) {\n    php_register_variable_safe(\"DOCUMENT_ROOT\", docroot, len, track_vars_array);\n  }\n}\n/* }}} */\n\nstatic void *execute_script_cli(void *arg) {\n  void *exit_status;\n\n  /*\n   * The SAPI name \"cli\" is hardcoded into too many programs... let's usurp it.\n   */\n  php_embed_module.name = \"cli\";\n  php_embed_module.pretty_name = \"PHP CLI embedded in FrankenPHP\";\n  php_embed_module.register_server_variables = sapi_cli_register_variables;\n\n  php_embed_init(cli_argc, cli_argv);\n\n  cli_register_file_handles(false);\n  zend_first_try {\n    zend_file_handle file_handle;\n    zend_stream_init_filename(&file_handle, cli_script);\n\n    CG(skip_shebang) = 1;\n    php_execute_script(&file_handle);\n  }\n  zend_end_try();\n\n  exit_status = (void *)(intptr_t)EG(exit_status);\n\n  php_embed_shutdown();\n\n  return exit_status;\n}\n\nint frankenphp_execute_script_cli(char *script, int argc, char **argv) {\n  pthread_t thread;\n  int err;\n  void *exit_status;\n\n  cli_script = script;\n  cli_argc = argc;\n  cli_argv = argv;\n\n  /*\n   * Start the script in a dedicated thread to prevent conflicts between Go and\n   * PHP signal handlers\n   */\n  err = pthread_create(&thread, NULL, execute_script_cli, NULL);\n  if (err != 0) {\n    return err;\n  }\n\n  err = pthread_join(thread, &exit_status);\n  if (err != 0) {\n    return err;\n  }\n\n  return (intptr_t)exit_status;\n}\n\nint frankenphp_execute_php_function(const char *php_function) {\n  zval retval = {0};\n  zend_fcall_info fci = {0};\n  zend_fcall_info_cache fci_cache = {0};\n  zend_string *func_name =\n      zend_string_init(php_function, strlen(php_function), 0);\n  ZVAL_STR(&fci.function_name, func_name);\n  fci.size = sizeof fci;\n  fci.retval = &retval;\n  int success = 0;\n\n  zend_try { success = zend_call_function(&fci, &fci_cache) == SUCCESS; }\n  zend_end_try();\n\n  zend_string_release(func_name);\n\n  return success;\n}\n\nint frankenphp_reset_opcache(void) {\n  if (zend_hash_str_exists(CG(function_table), \"opcache_reset\",\n                           sizeof(\"opcache_reset\") - 1)) {\n    return frankenphp_execute_php_function(\"opcache_reset\");\n  }\n  return 0;\n}\n"
        },
        {
          "name": "frankenphp.go",
          "type": "blob",
          "size": 18.78515625,
          "content": "// Package frankenphp embeds PHP in Go projects and provides a SAPI for net/http.\n//\n// This is the core of the [FrankenPHP app server], and can be used in any Go program.\n//\n// [FrankenPHP app server]: https://frankenphp.dev\npackage frankenphp\n\n// Use PHP includes corresponding to your PHP installation by running:\n//\n//   export CGO_CFLAGS=$(php-config --includes)\n//   export CGO_LDFLAGS=\"$(php-config --ldflags) $(php-config --libs)\"\n//\n// We also set these flags for hardening: https://github.com/docker-library/php/blob/master/8.2/bookworm/zts/Dockerfile#L57-L59\n\n// #cgo darwin pkg-config: libxml-2.0\n// #cgo CFLAGS: -Wall -Werror\n// #cgo CFLAGS: -I/usr/local/include -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib\n// #cgo linux CFLAGS: -D_GNU_SOURCE\n// #cgo darwin LDFLAGS: -L/opt/homebrew/opt/libiconv/lib -liconv\n// #cgo linux LDFLAGS: -lresolv\n// #cgo LDFLAGS: -L/usr/local/lib -L/usr/lib -lphp -ldl -lm -lutil\n// #include <stdlib.h>\n// #include <stdint.h>\n// #include <php_variables.h>\n// #include <zend_llist.h>\n// #include <SAPI.h>\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/maypok86/otter\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\t// debug on Linux\n\t//_ \"github.com/ianlancetaylor/cgosymbolizer\"\n)\n\ntype contextKeyStruct struct{}\n\nvar contextKey = contextKeyStruct{}\n\nvar (\n\tInvalidRequestError         = errors.New(\"not a FrankenPHP request\")\n\tAlreadyStartedError         = errors.New(\"FrankenPHP is already started\")\n\tInvalidPHPVersionError      = errors.New(\"FrankenPHP is only compatible with PHP 8.2+\")\n\tNotEnoughThreads            = errors.New(\"the number of threads must be superior to the number of workers\")\n\tMainThreadCreationError     = errors.New(\"error creating the main thread\")\n\tRequestContextCreationError = errors.New(\"error during request context creation\")\n\tScriptExecutionError        = errors.New(\"error during PHP script execution\")\n\tNotRunningError             = errors.New(\"FrankenPHP is not running. For proper configuration visit: https://frankenphp.dev/docs/config/#caddyfile-config\")\n\n\trequestChan chan *http.Request\n\tisRunning   bool\n\n\tloggerMu sync.RWMutex\n\tlogger   *zap.Logger\n\n\tmetrics Metrics = nullMetrics{}\n)\n\ntype syslogLevel int\n\nconst (\n\temerg   syslogLevel = iota // system is unusable\n\talert                      // action must be taken immediately\n\tcrit                       // critical conditions\n\terr                        // error conditions\n\twarning                    // warning conditions\n\tnotice                     // normal but significant condition\n\tinfo                       // informational\n\tdebug                      // debug-level messages\n)\n\nfunc (l syslogLevel) String() string {\n\tswitch l {\n\tcase emerg:\n\t\treturn \"emerg\"\n\tcase alert:\n\t\treturn \"alert\"\n\tcase crit:\n\t\treturn \"crit\"\n\tcase err:\n\t\treturn \"err\"\n\tcase warning:\n\t\treturn \"warning\"\n\tcase notice:\n\t\treturn \"notice\"\n\tcase debug:\n\t\treturn \"debug\"\n\tdefault:\n\t\treturn \"info\"\n\t}\n}\n\n// FrankenPHPContext provides contextual information about the Request to handle.\ntype FrankenPHPContext struct {\n\tdocumentRoot    string\n\tsplitPath       []string\n\tenv             PreparedEnv\n\tlogger          *zap.Logger\n\toriginalRequest *http.Request\n\n\tdocURI         string\n\tpathInfo       string\n\tscriptName     string\n\tscriptFilename string\n\n\t// Whether the request is already closed by us\n\tclosed sync.Once\n\n\tresponseWriter http.ResponseWriter\n\texitStatus     int\n\n\tdone      chan interface{}\n\tstartedAt time.Time\n}\n\nfunc clientHasClosed(r *http.Request) bool {\n\tselect {\n\tcase <-r.Context().Done():\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// NewRequestWithContext creates a new FrankenPHP request context.\nfunc NewRequestWithContext(r *http.Request, opts ...RequestOption) (*http.Request, error) {\n\tfc := &FrankenPHPContext{\n\t\tdone: make(chan interface{}),\n\t}\n\tfor _, o := range opts {\n\t\tif err := o(fc); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif fc.documentRoot == \"\" {\n\t\tif EmbeddedAppPath != \"\" {\n\t\t\tfc.documentRoot = EmbeddedAppPath\n\t\t} else {\n\t\t\tvar err error\n\t\t\tif fc.documentRoot, err = os.Getwd(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif fc.splitPath == nil {\n\t\tfc.splitPath = []string{\".php\"}\n\t}\n\n\tif fc.env == nil {\n\t\tfc.env = make(map[string]string)\n\t}\n\n\tif fc.logger == nil {\n\t\tfc.logger = getLogger()\n\t}\n\n\tif splitPos := splitPos(fc, r.URL.Path); splitPos > -1 {\n\t\tfc.docURI = r.URL.Path[:splitPos]\n\t\tfc.pathInfo = r.URL.Path[splitPos:]\n\n\t\t// Strip PATH_INFO from SCRIPT_NAME\n\t\tfc.scriptName = strings.TrimSuffix(r.URL.Path, fc.pathInfo)\n\n\t\t// Ensure the SCRIPT_NAME has a leading slash for compliance with RFC3875\n\t\t// Info: https://tools.ietf.org/html/rfc3875#section-4.1.13\n\t\tif fc.scriptName != \"\" && !strings.HasPrefix(fc.scriptName, \"/\") {\n\t\t\tfc.scriptName = \"/\" + fc.scriptName\n\t\t}\n\t}\n\n\t// SCRIPT_FILENAME is the absolute path of SCRIPT_NAME\n\tfc.scriptFilename = sanitizedPathJoin(fc.documentRoot, fc.scriptName)\n\n\tc := context.WithValue(r.Context(), contextKey, fc)\n\n\treturn r.WithContext(c), nil\n}\n\n// FromContext extracts the FrankenPHPContext from a context.\nfunc FromContext(ctx context.Context) (fctx *FrankenPHPContext, ok bool) {\n\tfctx, ok = ctx.Value(contextKey).(*FrankenPHPContext)\n\treturn\n}\n\ntype PHPVersion struct {\n\tMajorVersion   int\n\tMinorVersion   int\n\tReleaseVersion int\n\tExtraVersion   string\n\tVersion        string\n\tVersionID      int\n}\n\ntype PHPConfig struct {\n\tVersion                PHPVersion\n\tZTS                    bool\n\tZendSignals            bool\n\tZendMaxExecutionTimers bool\n}\n\n// Version returns infos about the PHP version.\nfunc Version() PHPVersion {\n\tcVersion := C.frankenphp_get_version()\n\n\treturn PHPVersion{\n\t\tint(cVersion.major_version),\n\t\tint(cVersion.minor_version),\n\t\tint(cVersion.release_version),\n\t\tC.GoString(cVersion.extra_version),\n\t\tC.GoString(cVersion.version),\n\t\tint(cVersion.version_id),\n\t}\n}\n\nfunc Config() PHPConfig {\n\tcConfig := C.frankenphp_get_config()\n\n\treturn PHPConfig{\n\t\tVersion:                Version(),\n\t\tZTS:                    bool(cConfig.zts),\n\t\tZendSignals:            bool(cConfig.zend_signals),\n\t\tZendMaxExecutionTimers: bool(cConfig.zend_max_execution_timers),\n\t}\n}\n\n// MaxThreads is internally used during tests. It is written to, but never read and may go away in the future.\nvar MaxThreads int\n\nfunc calculateMaxThreads(opt *opt) (int, int, error) {\n\tmaxProcs := runtime.GOMAXPROCS(0) * 2\n\n\tvar numWorkers int\n\tfor i, w := range opt.workers {\n\t\tif w.num <= 0 {\n\t\t\t// https://github.com/dunglas/frankenphp/issues/126\n\t\t\topt.workers[i].num = maxProcs\n\t\t}\n\t\tmetrics.TotalWorkers(w.fileName, w.num)\n\n\t\tnumWorkers += opt.workers[i].num\n\t}\n\n\tif opt.numThreads <= 0 {\n\t\tif numWorkers >= maxProcs {\n\t\t\t// Start at least as many threads as workers, and keep a free thread to handle requests in non-worker mode\n\t\t\topt.numThreads = numWorkers + 1\n\t\t} else {\n\t\t\topt.numThreads = maxProcs\n\t\t}\n\t} else if opt.numThreads <= numWorkers {\n\t\treturn opt.numThreads, numWorkers, NotEnoughThreads\n\t}\n\n\tmetrics.TotalThreads(opt.numThreads)\n\tMaxThreads = opt.numThreads\n\n\treturn opt.numThreads, numWorkers, nil\n}\n\n// Init starts the PHP runtime and the configured workers.\nfunc Init(options ...Option) error {\n\tif isRunning {\n\t\treturn AlreadyStartedError\n\t}\n\tisRunning = true\n\n\t// Ignore all SIGPIPE signals to prevent weird issues with systemd: https://github.com/dunglas/frankenphp/issues/1020\n\t// Docker/Moby has a similar hack: https://github.com/moby/moby/blob/d828b032a87606ae34267e349bf7f7ccb1f6495a/cmd/dockerd/docker.go#L87-L90\n\tsignal.Ignore(syscall.SIGPIPE)\n\n\topt := &opt{}\n\tfor _, o := range options {\n\t\tif err := o(opt); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif opt.logger == nil {\n\t\tl, err := zap.NewDevelopment()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tloggerMu.Lock()\n\t\tlogger = l\n\t\tloggerMu.Unlock()\n\t} else {\n\t\tloggerMu.Lock()\n\t\tlogger = opt.logger\n\t\tloggerMu.Unlock()\n\t}\n\n\tif opt.metrics != nil {\n\t\tmetrics = opt.metrics\n\t}\n\n\ttotalThreadCount, workerThreadCount, err := calculateMaxThreads(opt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig := Config()\n\n\tif config.Version.MajorVersion < 8 || (config.Version.MajorVersion == 8 && config.Version.MinorVersion < 2) {\n\t\treturn InvalidPHPVersionError\n\t}\n\n\tif config.ZTS {\n\t\tif !config.ZendMaxExecutionTimers && runtime.GOOS == \"linux\" {\n\t\t\tlogger.Warn(`Zend Max Execution Timers are not enabled, timeouts (e.g. \"max_execution_time\") are disabled, recompile PHP with the \"--enable-zend-max-execution-timers\" configuration option to fix this issue`)\n\t\t}\n\t} else {\n\t\ttotalThreadCount = 1\n\t\tlogger.Warn(`ZTS is not enabled, only 1 thread will be available, recompile PHP using the \"--enable-zts\" configuration option or performance will be degraded`)\n\t}\n\n\trequestChan = make(chan *http.Request, opt.numThreads)\n\tif err := initPHPThreads(totalThreadCount); err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < totalThreadCount-workerThreadCount; i++ {\n\t\tthread := getInactivePHPThread()\n\t\tconvertToRegularThread(thread)\n\t}\n\n\tif err := initWorkers(opt.workers); err != nil {\n\t\treturn err\n\t}\n\n\tif c := logger.Check(zapcore.InfoLevel, \"FrankenPHP started ð\"); c != nil {\n\t\tc.Write(zap.String(\"php_version\", Version().Version), zap.Int(\"num_threads\", totalThreadCount))\n\t}\n\tif EmbeddedAppPath != \"\" {\n\t\tif c := logger.Check(zapcore.InfoLevel, \"embedded PHP app ð¦\"); c != nil {\n\t\t\tc.Write(zap.String(\"path\", EmbeddedAppPath))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Shutdown stops the workers and the PHP runtime.\nfunc Shutdown() {\n\tif !isRunning {\n\t\treturn\n\t}\n\n\tdrainWorkers()\n\tdrainPHPThreads()\n\tmetrics.Shutdown()\n\trequestChan = nil\n\n\t// Remove the installed app\n\tif EmbeddedAppPath != \"\" {\n\t\t_ = os.RemoveAll(EmbeddedAppPath)\n\t}\n\n\tlogger.Debug(\"FrankenPHP shut down\")\n\tisRunning = false\n}\n\nfunc getLogger() *zap.Logger {\n\tloggerMu.RLock()\n\tdefer loggerMu.RUnlock()\n\n\treturn logger\n}\n\nfunc updateServerContext(thread *phpThread, request *http.Request, create bool, isWorkerRequest bool) error {\n\tfc, ok := FromContext(request.Context())\n\tif !ok {\n\t\treturn InvalidRequestError\n\t}\n\n\tauthUser, authPassword, ok := request.BasicAuth()\n\tvar cAuthUser, cAuthPassword *C.char\n\tif ok && authPassword != \"\" {\n\t\tcAuthPassword = thread.pinCString(authPassword)\n\t}\n\tif ok && authUser != \"\" {\n\t\tcAuthUser = thread.pinCString(authUser)\n\t}\n\n\tcMethod := thread.pinCString(request.Method)\n\tcQueryString := thread.pinCString(request.URL.RawQuery)\n\tcontentLengthStr := request.Header.Get(\"Content-Length\")\n\tcontentLength := 0\n\tif contentLengthStr != \"\" {\n\t\tvar err error\n\t\tcontentLength, err = strconv.Atoi(contentLengthStr)\n\t\tif err != nil || contentLength < 0 {\n\t\t\treturn fmt.Errorf(\"invalid Content-Length header: %w\", err)\n\t\t}\n\t}\n\n\tcontentType := request.Header.Get(\"Content-Type\")\n\tvar cContentType *C.char\n\tif contentType != \"\" {\n\t\tcContentType = thread.pinCString(contentType)\n\t}\n\n\t// compliance with the CGI specification requires that\n\t// PATH_TRANSLATED should only exist if PATH_INFO is defined.\n\t// Info: https://www.ietf.org/rfc/rfc3875 Page 14\n\tvar cPathTranslated *C.char\n\tif fc.pathInfo != \"\" {\n\t\tcPathTranslated = thread.pinCString(sanitizedPathJoin(fc.documentRoot, fc.pathInfo)) // Info: http://www.oreilly.com/openbook/cgi/ch02_04.html\n\t}\n\n\tcRequestUri := thread.pinCString(request.URL.RequestURI())\n\tisBootingAWorkerScript := fc.responseWriter == nil\n\n\tret := C.frankenphp_update_server_context(\n\t\tC.bool(create),\n\t\tC.bool(isWorkerRequest || isBootingAWorkerScript),\n\t\tC.bool(!isBootingAWorkerScript),\n\n\t\tcMethod,\n\t\tcQueryString,\n\t\tC.zend_long(contentLength),\n\t\tcPathTranslated,\n\t\tcRequestUri,\n\t\tcContentType,\n\t\tcAuthUser,\n\t\tcAuthPassword,\n\t\tC.int(request.ProtoMajor*1000+request.ProtoMinor),\n\t)\n\n\tif ret > 0 {\n\t\treturn RequestContextCreationError\n\t}\n\n\treturn nil\n}\n\n// ServeHTTP executes a PHP script according to the given context.\nfunc ServeHTTP(responseWriter http.ResponseWriter, request *http.Request) error {\n\tif !isRunning {\n\t\treturn NotRunningError\n\t}\n\n\tif !requestIsValid(request, responseWriter) {\n\t\treturn nil\n\t}\n\n\tfc, ok := FromContext(request.Context())\n\tif !ok {\n\t\treturn InvalidRequestError\n\t}\n\n\tfc.responseWriter = responseWriter\n\tfc.startedAt = time.Now()\n\n\t// Detect if a worker is available to handle this request\n\tif worker, ok := workers[fc.scriptFilename]; ok {\n\t\tworker.handleRequest(request, fc)\n\t\treturn nil\n\t}\n\n\tmetrics.StartRequest()\n\n\tselect {\n\tcase <-mainThread.done:\n\tcase requestChan <- request:\n\t\t<-fc.done\n\t}\n\n\tmetrics.StopRequest()\n\n\treturn nil\n}\n\nfunc maybeCloseContext(fc *FrankenPHPContext) {\n\tfc.closed.Do(func() {\n\t\tclose(fc.done)\n\t})\n}\n\n//export go_ub_write\nfunc go_ub_write(threadIndex C.uintptr_t, cBuf *C.char, length C.int) (C.size_t, C.bool) {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\tfc, _ := FromContext(r.Context())\n\n\tvar writer io.Writer\n\tif fc.responseWriter == nil {\n\t\tvar b bytes.Buffer\n\t\t// log the output of the worker\n\t\twriter = &b\n\t} else {\n\t\twriter = fc.responseWriter\n\t}\n\n\ti, e := writer.Write(unsafe.Slice((*byte)(unsafe.Pointer(cBuf)), length))\n\tif e != nil {\n\t\tif c := fc.logger.Check(zapcore.ErrorLevel, \"write error\"); c != nil {\n\t\t\tc.Write(zap.Error(e))\n\t\t}\n\t}\n\n\tif fc.responseWriter == nil {\n\t\tfc.logger.Info(writer.(*bytes.Buffer).String())\n\t}\n\n\treturn C.size_t(i), C.bool(clientHasClosed(r))\n}\n\n// There are around 60 common request headers according to https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields\n// Give some space for custom headers\nvar headerKeyCache = func() otter.Cache[string, string] {\n\tc, err := otter.MustBuilder[string, string](256).Build()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn c\n}()\n\n//export go_apache_request_headers\nfunc go_apache_request_headers(threadIndex C.uintptr_t, hasActiveRequest bool) (*C.go_string, C.size_t) {\n\tthread := phpThreads[threadIndex]\n\n\tif !hasActiveRequest {\n\t\t// worker mode, not handling a request\n\t\tmfc := thread.getActiveRequest().Context().Value(contextKey).(*FrankenPHPContext)\n\n\t\tif c := mfc.logger.Check(zapcore.DebugLevel, \"apache_request_headers() called in non-HTTP context\"); c != nil {\n\t\t\tc.Write(zap.String(\"worker\", mfc.scriptFilename))\n\t\t}\n\n\t\treturn nil, 0\n\t}\n\tr := thread.getActiveRequest()\n\n\theaders := make([]C.go_string, 0, len(r.Header)*2)\n\n\tfor field, val := range r.Header {\n\t\tfd := unsafe.StringData(field)\n\t\tthread.Pin(fd)\n\n\t\tcv := strings.Join(val, \", \")\n\t\tvd := unsafe.StringData(cv)\n\t\tthread.Pin(vd)\n\n\t\theaders = append(\n\t\t\theaders,\n\t\t\tC.go_string{C.size_t(len(field)), (*C.char)(unsafe.Pointer(fd))},\n\t\t\tC.go_string{C.size_t(len(cv)), (*C.char)(unsafe.Pointer(vd))},\n\t\t)\n\t}\n\n\tsd := unsafe.SliceData(headers)\n\tthread.Pin(sd)\n\n\treturn sd, C.size_t(len(r.Header))\n}\n\nfunc addHeader(fc *FrankenPHPContext, cString *C.char, length C.int) {\n\tparts := strings.SplitN(C.GoStringN(cString, length), \": \", 2)\n\tif len(parts) != 2 {\n\t\tif c := fc.logger.Check(zapcore.DebugLevel, \"invalid header\"); c != nil {\n\t\t\tc.Write(zap.String(\"header\", parts[0]))\n\t\t}\n\n\t\treturn\n\t}\n\n\tfc.responseWriter.Header().Add(parts[0], parts[1])\n}\n\n//export go_write_headers\nfunc go_write_headers(threadIndex C.uintptr_t, status C.int, headers *C.zend_llist) {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\n\tif fc.responseWriter == nil {\n\t\treturn\n\t}\n\n\tcurrent := headers.head\n\tfor current != nil {\n\t\th := (*C.sapi_header_struct)(unsafe.Pointer(&(current.data)))\n\n\t\taddHeader(fc, h.header, C.int(h.header_len))\n\t\tcurrent = current.next\n\t}\n\n\tfc.responseWriter.WriteHeader(int(status))\n\n\tif status >= 100 && status < 200 {\n\t\t// Clear headers, it's not automatically done by ResponseWriter.WriteHeader() for 1xx responses\n\t\th := fc.responseWriter.Header()\n\t\tfor k := range h {\n\t\t\tdelete(h, k)\n\t\t}\n\t}\n}\n\n//export go_sapi_flush\nfunc go_sapi_flush(threadIndex C.uintptr_t) bool {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\n\tif fc.responseWriter == nil || clientHasClosed(r) {\n\t\treturn true\n\t}\n\n\tif err := http.NewResponseController(fc.responseWriter).Flush(); err != nil {\n\t\tif c := fc.logger.Check(zapcore.ErrorLevel, \"the current responseWriter is not a flusher\"); c != nil {\n\t\t\tc.Write(zap.Error(err))\n\t\t}\n\t}\n\n\treturn false\n}\n\n//export go_read_post\nfunc go_read_post(threadIndex C.uintptr_t, cBuf *C.char, countBytes C.size_t) (readBytes C.size_t) {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\n\tp := unsafe.Slice((*byte)(unsafe.Pointer(cBuf)), countBytes)\n\tvar err error\n\tfor readBytes < countBytes && err == nil {\n\t\tvar n int\n\t\tn, err = r.Body.Read(p[readBytes:])\n\t\treadBytes += C.size_t(n)\n\t}\n\n\treturn\n}\n\n//export go_read_cookies\nfunc go_read_cookies(threadIndex C.uintptr_t) *C.char {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\n\tcookies := r.Cookies()\n\tif len(cookies) == 0 {\n\t\treturn nil\n\t}\n\tcookieStrings := make([]string, len(cookies))\n\tfor i, cookie := range cookies {\n\t\tcookieStrings[i] = cookie.String()\n\t}\n\n\t// freed in frankenphp_free_request_context()\n\treturn C.CString(strings.Join(cookieStrings, \"; \"))\n}\n\n//export go_log\nfunc go_log(message *C.char, level C.int) {\n\tl := getLogger()\n\tm := C.GoString(message)\n\n\tvar le syslogLevel\n\tif level < C.int(emerg) || level > C.int(debug) {\n\t\tle = info\n\t} else {\n\t\tle = syslogLevel(level)\n\t}\n\n\tswitch le {\n\tcase emerg, alert, crit, err:\n\t\tif c := l.Check(zapcore.ErrorLevel, m); c != nil {\n\t\t\tc.Write(zap.Stringer(\"syslog_level\", syslogLevel(level)))\n\t\t}\n\n\tcase warning:\n\t\tif c := l.Check(zapcore.WarnLevel, m); c != nil {\n\t\t\tc.Write(zap.Stringer(\"syslog_level\", syslogLevel(level)))\n\t\t}\n\n\tcase debug:\n\t\tif c := l.Check(zapcore.DebugLevel, m); c != nil {\n\t\t\tc.Write(zap.Stringer(\"syslog_level\", syslogLevel(level)))\n\t\t}\n\n\tdefault:\n\t\tif c := l.Check(zapcore.InfoLevel, m); c != nil {\n\t\t\tc.Write(zap.Stringer(\"syslog_level\", syslogLevel(level)))\n\t\t}\n\t}\n}\n\n// ExecuteScriptCLI executes the PHP script passed as parameter.\n// It returns the exit status code of the script.\nfunc ExecuteScriptCLI(script string, args []string) int {\n\tcScript := C.CString(script)\n\tdefer C.free(unsafe.Pointer(cScript))\n\n\targc, argv := convertArgs(args)\n\tdefer freeArgs(argv)\n\n\treturn int(C.frankenphp_execute_script_cli(cScript, argc, (**C.char)(unsafe.Pointer(&argv[0]))))\n}\n\nfunc convertArgs(args []string) (C.int, []*C.char) {\n\targc := C.int(len(args))\n\targv := make([]*C.char, argc)\n\tfor i, arg := range args {\n\t\targv[i] = C.CString(arg)\n\t}\n\treturn argc, argv\n}\n\nfunc freeArgs(argv []*C.char) {\n\tfor _, arg := range argv {\n\t\tC.free(unsafe.Pointer(arg))\n\t}\n}\n\nfunc executePHPFunction(functionName string) bool {\n\tcFunctionName := C.CString(functionName)\n\tdefer C.free(unsafe.Pointer(cFunctionName))\n\n\treturn C.frankenphp_execute_php_function(cFunctionName) == 1\n}\n\n// Ensure that the request path does not contain null bytes\nfunc requestIsValid(r *http.Request, rw http.ResponseWriter) bool {\n\tif !strings.Contains(r.URL.Path, \"\\x00\") {\n\t\treturn true\n\t}\n\trejectRequest(rw, \"Invalid request path\")\n\treturn false\n}\n\nfunc rejectRequest(rw http.ResponseWriter, message string) {\n\trw.WriteHeader(http.StatusBadRequest)\n\t_, _ = rw.Write([]byte(message))\n\trw.(http.Flusher).Flush()\n}\n"
        },
        {
          "name": "frankenphp.h",
          "type": "blob",
          "size": 2.9150390625,
          "content": "#ifndef _FRANKENPPHP_H\n#define _FRANKENPPHP_H\n\n#include <Zend/zend_types.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef FRANKENPHP_VERSION\n#define FRANKENPHP_VERSION dev\n#endif\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\ntypedef struct go_string {\n  size_t len;\n  char *data;\n} go_string;\n\ntypedef struct ht_key_value_pair {\n  zend_string *key;\n  char *val;\n  size_t val_len;\n} ht_key_value_pair;\n\ntypedef struct php_variable {\n  const char *var;\n  size_t data_len;\n  char *data;\n} php_variable;\n\ntypedef struct frankenphp_version {\n  unsigned char major_version;\n  unsigned char minor_version;\n  unsigned char release_version;\n  const char *extra_version;\n  const char *version;\n  unsigned long version_id;\n} frankenphp_version;\nfrankenphp_version frankenphp_get_version();\n\ntypedef struct frankenphp_config {\n  frankenphp_version version;\n  bool zts;\n  bool zend_signals;\n  bool zend_max_execution_timers;\n} frankenphp_config;\nfrankenphp_config frankenphp_get_config();\n\nint frankenphp_new_main_thread(int num_threads);\nbool frankenphp_new_php_thread(uintptr_t thread_index);\n\nint frankenphp_update_server_context(\n    bool create, bool has_main_request, bool has_active_request,\n\n    const char *request_method, char *query_string, zend_long content_length,\n    char *path_translated, char *request_uri, const char *content_type,\n    char *auth_user, char *auth_password, int proto_num);\nint frankenphp_request_startup();\nint frankenphp_execute_script(char *file_name);\n\nint frankenphp_execute_script_cli(char *script, int argc, char **argv);\n\nint frankenphp_execute_php_function(const char *php_function);\n\nvoid frankenphp_register_variables_from_request_info(\n    zval *track_vars_array, zend_string *content_type,\n    zend_string *path_translated, zend_string *query_string,\n    zend_string *auth_user, zend_string *request_method);\nvoid frankenphp_register_variable_safe(char *key, char *var, size_t val_len,\n                                       zval *track_vars_array);\nzend_string *frankenphp_init_persistent_string(const char *string, size_t len);\nvoid frankenphp_release_zend_string(zend_string *z_string);\nint frankenphp_reset_opcache(void);\n\nvoid frankenphp_register_bulk(\n    zval *track_vars_array, ht_key_value_pair remote_addr,\n    ht_key_value_pair remote_host, ht_key_value_pair remote_port,\n    ht_key_value_pair document_root, ht_key_value_pair path_info,\n    ht_key_value_pair php_self, ht_key_value_pair document_uri,\n    ht_key_value_pair script_filename, ht_key_value_pair script_name,\n    ht_key_value_pair https, ht_key_value_pair ssl_protocol,\n    ht_key_value_pair request_scheme, ht_key_value_pair server_name,\n    ht_key_value_pair server_port, ht_key_value_pair content_length,\n    ht_key_value_pair gateway_interface, ht_key_value_pair server_protocol,\n    ht_key_value_pair server_software, ht_key_value_pair http_host,\n    ht_key_value_pair auth_type, ht_key_value_pair remote_ident,\n    ht_key_value_pair request_uri);\n\n#endif\n"
        },
        {
          "name": "frankenphp.png",
          "type": "blob",
          "size": 176.333984375,
          "content": null
        },
        {
          "name": "frankenphp.stub.php",
          "type": "blob",
          "size": 0.64453125,
          "content": "<?php\n\n/** @generate-class-entries */\n\nfunction frankenphp_handle_request(callable $callback): bool {}\n\nfunction headers_send(int $status = 200): int {}\n\nfunction frankenphp_finish_request(): bool {}\n\n/**\n * @alias frankenphp_finish_request\n */\nfunction fastcgi_finish_request(): bool {}\n\nfunction frankenphp_request_headers(): array {}\n\n/**\n * @alias frankenphp_request_headers\n */\nfunction apache_request_headers(): array {}\n\n/**\n * @alias frankenphp_request_headers\n*/\nfunction getallheaders(): array {}\n\nfunction frankenphp_response_headers(): array|bool {}\n\n/**\n * @alias frankenphp_response_headers\n */\nfunction apache_response_headers(): array|bool {}\n\n"
        },
        {
          "name": "frankenphp_arginfo.h",
          "type": "blob",
          "size": 2.240234375,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: 05ebde17137c559e891362fba6524fad1e0a2dfe */\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_frankenphp_handle_request, 0, 1,\n                                        _IS_BOOL, 0)\nZEND_ARG_TYPE_INFO(0, callback, IS_CALLABLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_headers_send, 0, 0, IS_LONG, 0)\nZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, status, IS_LONG, 0, \"200\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_frankenphp_finish_request, 0, 0,\n                                        _IS_BOOL, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_fastcgi_finish_request arginfo_frankenphp_finish_request\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_frankenphp_request_headers, 0,\n                                        0, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_apache_request_headers arginfo_frankenphp_request_headers\n\n#define arginfo_getallheaders arginfo_frankenphp_request_headers\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_frankenphp_response_headers, 0,\n                                        0, MAY_BE_ARRAY | MAY_BE_BOOL)\nZEND_END_ARG_INFO()\n\n#define arginfo_apache_response_headers arginfo_frankenphp_response_headers\n\nZEND_FUNCTION(frankenphp_handle_request);\nZEND_FUNCTION(headers_send);\nZEND_FUNCTION(frankenphp_finish_request);\nZEND_FUNCTION(frankenphp_request_headers);\nZEND_FUNCTION(frankenphp_response_headers);\n\n// clang-format off\nstatic const zend_function_entry ext_functions[] = {\n  ZEND_FE(frankenphp_handle_request, arginfo_frankenphp_handle_request)\n  ZEND_FE(headers_send, arginfo_headers_send)\n  ZEND_FE(frankenphp_finish_request, arginfo_frankenphp_finish_request)\n  ZEND_FALIAS(fastcgi_finish_request, frankenphp_finish_request, arginfo_fastcgi_finish_request)\n  ZEND_FE(frankenphp_request_headers, arginfo_frankenphp_request_headers)\n  ZEND_FALIAS(apache_request_headers, frankenphp_request_headers, arginfo_apache_request_headers)\n  ZEND_FALIAS(getallheaders, frankenphp_request_headers, arginfo_getallheaders)\n  ZEND_FE(frankenphp_response_headers, arginfo_frankenphp_response_headers)\n  ZEND_FALIAS(apache_response_headers, frankenphp_response_headers, arginfo_apache_response_headers)\n  ZEND_FE_END\n};\n// clang-format on\n"
        },
        {
          "name": "frankenphp_test.go",
          "type": "blob",
          "size": 33.1103515625,
          "content": "// In all tests, headers added to requests are copied on the heap using strings.Clone.\n// This was originally a workaround for https://github.com/golang/go/issues/65286#issuecomment-1920087884 (fixed in Go 1.22),\n// but this allows to catch panics occuring in real life but not when the string is in the internal binary memory.\n\npackage frankenphp_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/dunglas/frankenphp/internal/fastabs\"\n\t\"io\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/http/httptest\"\n\t\"net/http/httptrace\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/dunglas/frankenphp\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\ntype testOptions struct {\n\tworkerScript        string\n\twatch               []string\n\tnbWorkers           int\n\tenv                 map[string]string\n\tnbParrallelRequests int\n\trealServer          bool\n\tlogger              *zap.Logger\n\tinitOpts            []frankenphp.Option\n}\n\nfunc runTest(t *testing.T, test func(func(http.ResponseWriter, *http.Request), *httptest.Server, int), opts *testOptions) {\n\tif opts == nil {\n\t\topts = &testOptions{}\n\t}\n\tif opts.nbParrallelRequests == 0 {\n\t\topts.nbParrallelRequests = 100\n\t}\n\n\tcwd, _ := os.Getwd()\n\ttestDataDir := cwd + \"/testdata/\"\n\n\tif opts.logger == nil {\n\t\topts.logger = zaptest.NewLogger(t)\n\t}\n\n\tinitOpts := []frankenphp.Option{frankenphp.WithLogger(opts.logger)}\n\tif opts.workerScript != \"\" {\n\t\tinitOpts = append(initOpts, frankenphp.WithWorkers(testDataDir+opts.workerScript, opts.nbWorkers, opts.env, opts.watch))\n\t}\n\tinitOpts = append(initOpts, opts.initOpts...)\n\n\terr := frankenphp.Init(initOpts...)\n\trequire.Nil(t, err)\n\tdefer frankenphp.Shutdown()\n\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(testDataDir, false))\n\t\tassert.NoError(t, err)\n\n\t\terr = frankenphp.ServeHTTP(w, req)\n\t\tassert.NoError(t, err)\n\t}\n\n\tvar ts *httptest.Server\n\tif opts.realServer {\n\t\tts = httptest.NewServer(http.HandlerFunc(handler))\n\t\tdefer ts.Close()\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(opts.nbParrallelRequests)\n\tfor i := 0; i < opts.nbParrallelRequests; i++ {\n\t\tgo func(i int) {\n\t\t\ttest(handler, ts, i)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n}\n\nfunc TestHelloWorld_module(t *testing.T) { testHelloWorld(t, nil) }\nfunc TestHelloWorld_worker(t *testing.T) {\n\ttestHelloWorld(t, &testOptions{workerScript: \"index.php\"})\n}\nfunc testHelloWorld(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/index.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\tassert.Equal(t, fmt.Sprintf(\"I am by birth a Genevese (%d)\", i), string(body))\n\t}, opts)\n}\n\nfunc TestFinishRequest_module(t *testing.T) { testFinishRequest(t, nil) }\nfunc TestFinishRequest_worker(t *testing.T) {\n\ttestFinishRequest(t, &testOptions{workerScript: \"finish-request.php\"})\n}\nfunc testFinishRequest(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/finish-request.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\tassert.Equal(t, fmt.Sprintf(\"This is output %d\\n\", i), string(body))\n\t}, opts)\n}\n\nfunc TestServerVariable_module(t *testing.T) {\n\ttestServerVariable(t, nil)\n}\nfunc TestServerVariable_worker(t *testing.T) {\n\ttestServerVariable(t, &testOptions{workerScript: \"server-variable.php\"})\n}\nfunc testServerVariable(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"POST\", fmt.Sprintf(\"http://example.com/server-variable.php/baz/bat?foo=a&bar=b&i=%d#hash\", i), strings.NewReader(\"foo\"))\n\t\treq.SetBasicAuth(strings.Clone(\"kevin\"), strings.Clone(\"password\"))\n\t\treq.Header.Add(strings.Clone(\"Content-Type\"), strings.Clone(\"text/plain\"))\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tstrBody := string(body)\n\n\t\tassert.Contains(t, strBody, \"[REMOTE_HOST]\")\n\t\tassert.Contains(t, strBody, \"[REMOTE_USER] => kevin\")\n\t\tassert.Contains(t, strBody, \"[PHP_AUTH_USER] => kevin\")\n\t\tassert.Contains(t, strBody, \"[PHP_AUTH_PW] => password\")\n\t\tassert.Contains(t, strBody, \"[HTTP_AUTHORIZATION] => Basic a2V2aW46cGFzc3dvcmQ=\")\n\t\tassert.Contains(t, strBody, \"[DOCUMENT_ROOT]\")\n\t\tassert.Contains(t, strBody, \"[PHP_SELF] => /server-variable.php/baz/bat\")\n\t\tassert.Contains(t, strBody, \"[CONTENT_TYPE] => text/plain\")\n\t\tassert.Contains(t, strBody, fmt.Sprintf(\"[QUERY_STRING] => foo=a&bar=b&i=%d#hash\", i))\n\t\tassert.Contains(t, strBody, fmt.Sprintf(\"[REQUEST_URI] => /server-variable.php/baz/bat?foo=a&bar=b&i=%d#hash\", i))\n\t\tassert.Contains(t, strBody, \"[CONTENT_LENGTH]\")\n\t\tassert.Contains(t, strBody, \"[REMOTE_ADDR]\")\n\t\tassert.Contains(t, strBody, \"[REMOTE_PORT]\")\n\t\tassert.Contains(t, strBody, \"[REQUEST_SCHEME] => http\")\n\t\tassert.Contains(t, strBody, \"[DOCUMENT_URI]\")\n\t\tassert.Contains(t, strBody, \"[AUTH_TYPE]\")\n\t\tassert.Contains(t, strBody, \"[REMOTE_IDENT]\")\n\t\tassert.Contains(t, strBody, \"[REQUEST_METHOD] => POST\")\n\t\tassert.Contains(t, strBody, \"[SERVER_NAME] => example.com\")\n\t\tassert.Contains(t, strBody, \"[SERVER_PROTOCOL] => HTTP/1.1\")\n\t\tassert.Contains(t, strBody, \"[SCRIPT_FILENAME]\")\n\t\tassert.Contains(t, strBody, \"[SERVER_SOFTWARE] => FrankenPHP\")\n\t\tassert.Contains(t, strBody, \"[REQUEST_TIME_FLOAT]\")\n\t\tassert.Contains(t, strBody, \"[REQUEST_TIME]\")\n\t\tassert.Contains(t, strBody, \"[SERVER_PORT] => 80\")\n\t}, opts)\n}\n\nfunc TestPathInfo_module(t *testing.T) { testPathInfo(t, nil) }\nfunc TestPathInfo_worker(t *testing.T) {\n\ttestPathInfo(t, &testOptions{workerScript: \"server-variable.php\"})\n}\nfunc testPathInfo(t *testing.T, opts *testOptions) {\n\tcwd, _ := os.Getwd()\n\ttestDataDir := cwd + strings.Clone(\"/testdata/\")\n\tpath := strings.Clone(\"/server-variable.php/pathinfo\")\n\n\trunTest(t, func(_ func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\t\trequestURI := r.URL.RequestURI()\n\t\t\tr.URL.Path = path\n\n\t\t\trewriteRequest, err := frankenphp.NewRequestWithContext(r,\n\t\t\t\tfrankenphp.WithRequestDocumentRoot(testDataDir, false),\n\t\t\t\tfrankenphp.WithRequestEnv(map[string]string{\"REQUEST_URI\": requestURI}),\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\terr = frankenphp.ServeHTTP(w, rewriteRequest)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/pathinfo/%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tstrBody := string(body)\n\n\t\tassert.Contains(t, strBody, \"[PATH_INFO] => /pathinfo\")\n\t\tassert.Contains(t, strBody, fmt.Sprintf(\"[REQUEST_URI] => /pathinfo/%d\", i))\n\t\tassert.Contains(t, strBody, \"[PATH_TRANSLATED] =>\")\n\t\tassert.Contains(t, strBody, \"[SCRIPT_NAME] => /server-variable.php\")\n\n\t}, opts)\n}\n\nfunc TestHeaders_module(t *testing.T) { testHeaders(t, nil) }\nfunc TestHeaders_worker(t *testing.T) { testHeaders(t, &testOptions{workerScript: \"headers.php\"}) }\nfunc testHeaders(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/headers.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, \"Hello\", string(body))\n\t\tassert.Equal(t, 201, resp.StatusCode)\n\t\tassert.Equal(t, \"bar\", resp.Header.Get(\"Foo\"))\n\t\tassert.Equal(t, \"bar2\", resp.Header.Get(\"Foo2\"))\n\t\tassert.Empty(t, resp.Header.Get(\"Invalid\"))\n\t\tassert.Equal(t, fmt.Sprintf(\"%d\", i), resp.Header.Get(\"I\"))\n\t}, opts)\n}\n\nfunc TestResponseHeaders_module(t *testing.T) { testResponseHeaders(t, nil) }\nfunc TestResponseHeaders_worker(t *testing.T) {\n\ttestResponseHeaders(t, &testOptions{workerScript: \"response-headers.php\"})\n}\nfunc testResponseHeaders(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/response-headers.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tif i%3 != 0 {\n\t\t\tassert.Equal(t, i+100, resp.StatusCode)\n\t\t} else {\n\t\t\tassert.Equal(t, 200, resp.StatusCode)\n\t\t}\n\n\t\tassert.Contains(t, string(body), \"'X-Powered-By' => 'PH\")\n\t\tassert.Contains(t, string(body), \"'Foo' => 'bar',\")\n\t\tassert.Contains(t, string(body), \"'Foo2' => 'bar2',\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"'I' => '%d',\", i))\n\t\tassert.NotContains(t, string(body), \"Invalid\")\n\t}, opts)\n}\n\nfunc TestInput_module(t *testing.T) { testInput(t, nil) }\nfunc TestInput_worker(t *testing.T) { testInput(t, &testOptions{workerScript: \"input.php\"}) }\nfunc testInput(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"POST\", \"http://example.com/input.php\", strings.NewReader(fmt.Sprintf(\"post data %d\", i)))\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, fmt.Sprintf(\"post data %d\", i), string(body))\n\t\tassert.Equal(t, \"bar\", resp.Header.Get(\"Foo\"))\n\t}, opts)\n}\n\nfunc TestPostSuperGlobals_module(t *testing.T) { testPostSuperGlobals(t, nil) }\nfunc TestPostSuperGlobals_worker(t *testing.T) {\n\ttestPostSuperGlobals(t, &testOptions{workerScript: \"super-globals.php\"})\n}\nfunc testPostSuperGlobals(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\tformData := url.Values{\"baz\": {\"bat\"}, \"i\": {fmt.Sprintf(\"%d\", i)}}\n\t\treq := httptest.NewRequest(\"POST\", fmt.Sprintf(\"http://example.com/super-globals.php?foo=bar&iG=%d\", i), strings.NewReader(formData.Encode()))\n\t\treq.Header.Set(\"Content-Type\", strings.Clone(\"application/x-www-form-urlencoded\"))\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"'foo' => 'bar'\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"'i' => '%d'\", i))\n\t\tassert.Contains(t, string(body), \"'baz' => 'bat'\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"'iG' => '%d'\", i))\n\t}, opts)\n}\n\nfunc TestCookies_module(t *testing.T) { testCookies(t, nil) }\nfunc TestCookies_worker(t *testing.T) { testCookies(t, &testOptions{workerScript: \"cookies.php\"}) }\nfunc testCookies(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/cookies.php\", nil)\n\t\treq.AddCookie(&http.Cookie{Name: \"foo\", Value: \"bar\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"i\", Value: fmt.Sprintf(\"%d\", i)})\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"'foo' => 'bar'\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"'i' => '%d'\", i))\n\t}, opts)\n}\n\nfunc TestSession_module(t *testing.T) { testSession(t, nil) }\nfunc TestSession_worker(t *testing.T) {\n\ttestSession(t, &testOptions{workerScript: \"session.php\"})\n}\nfunc testSession(t *testing.T, opts *testOptions) {\n\tif opts == nil {\n\t\topts = &testOptions{}\n\t}\n\topts.realServer = true\n\n\trunTest(t, func(_ func(http.ResponseWriter, *http.Request), ts *httptest.Server, i int) {\n\t\tjar, err := cookiejar.New(&cookiejar.Options{})\n\t\tassert.NoError(t, err)\n\n\t\tclient := &http.Client{Jar: jar}\n\n\t\tresp1, err := client.Get(ts.URL + \"/session.php\")\n\t\tassert.NoError(t, err)\n\n\t\tbody1, _ := io.ReadAll(resp1.Body)\n\t\tassert.Equal(t, \"Count: 0\\n\", string(body1))\n\n\t\tresp2, err := client.Get(ts.URL + \"/session.php\")\n\t\tassert.NoError(t, err)\n\n\t\tbody2, _ := io.ReadAll(resp2.Body)\n\t\tassert.Equal(t, \"Count: 1\\n\", string(body2))\n\t}, opts)\n}\n\nfunc TestPhpInfo_module(t *testing.T) { testPhpInfo(t, nil) }\nfunc TestPhpInfo_worker(t *testing.T) { testPhpInfo(t, &testOptions{workerScript: \"phpinfo.php\"}) }\nfunc testPhpInfo(t *testing.T, opts *testOptions) {\n\tvar logOnce sync.Once\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/phpinfo.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tlogOnce.Do(func() {\n\t\t\tt.Log(string(body))\n\t\t})\n\n\t\tassert.Contains(t, string(body), \"frankenphp\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"i=%d\", i))\n\t}, opts)\n}\n\nfunc TestPersistentObject_module(t *testing.T) { testPersistentObject(t, nil) }\nfunc TestPersistentObject_worker(t *testing.T) {\n\ttestPersistentObject(t, &testOptions{workerScript: \"persistent-object.php\"})\n}\nfunc testPersistentObject(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/persistent-object.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, fmt.Sprintf(`request: %d\nclass exists: 1\nid: obj1\nobject id: 1`, i), string(body))\n\t}, opts)\n}\n\nfunc TestAutoloader_module(t *testing.T) { testAutoloader(t, nil) }\nfunc TestAutoloader_worker(t *testing.T) {\n\ttestAutoloader(t, &testOptions{workerScript: \"autoloader.php\"})\n}\nfunc testAutoloader(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/autoloader.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, fmt.Sprintf(`request %d\nmy_autoloader`, i), string(body))\n\t}, opts)\n}\n\nfunc TestLog_module(t *testing.T) { testLog(t, &testOptions{}) }\nfunc TestLog_worker(t *testing.T) {\n\ttestLog(t, &testOptions{workerScript: \"log.php\"})\n}\nfunc testLog(t *testing.T, opts *testOptions) {\n\tlogger, logs := observer.New(zapcore.InfoLevel)\n\topts.logger = zap.New(logger)\n\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/log.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tfor logs.FilterMessage(fmt.Sprintf(\"request %d\", i)).Len() <= 0 {\n\t\t}\n\t}, opts)\n}\n\nfunc TestConnectionAbort_module(t *testing.T) { testConnectionAbort(t, &testOptions{}) }\nfunc TestConnectionAbort_worker(t *testing.T) {\n\ttestConnectionAbort(t, &testOptions{workerScript: \"connectionStatusLog.php\"})\n}\nfunc testConnectionAbort(t *testing.T, opts *testOptions) {\n\ttestFinish := func(finish string) {\n\t\tt.Run(fmt.Sprintf(\"finish=%s\", finish), func(t *testing.T) {\n\t\t\tlogger, logs := observer.New(zapcore.InfoLevel)\n\t\t\topts.logger = zap.New(logger)\n\n\t\t\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\t\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/connectionStatusLog.php?i=%d&finish=%s\", i, finish), nil)\n\t\t\t\tw := httptest.NewRecorder()\n\n\t\t\t\tctx, cancel := context.WithCancel(req.Context())\n\t\t\t\treq = req.WithContext(ctx)\n\t\t\t\tcancel()\n\t\t\t\thandler(w, req)\n\n\t\t\t\tfor logs.FilterMessage(fmt.Sprintf(\"request %d: 1\", i)).Len() <= 0 {\n\t\t\t\t}\n\t\t\t}, opts)\n\t\t})\n\t}\n\n\ttestFinish(\"0\")\n\ttestFinish(\"1\")\n}\n\nfunc TestException_module(t *testing.T) { testException(t, &testOptions{}) }\nfunc TestException_worker(t *testing.T) {\n\ttestException(t, &testOptions{workerScript: \"exception.php\"})\n}\nfunc testException(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/exception.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"hello\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(`Uncaught Exception: request %d`, i))\n\t}, opts)\n}\n\nfunc TestEarlyHints_module(t *testing.T) { testEarlyHints(t, &testOptions{}) }\nfunc TestEarlyHints_worker(t *testing.T) {\n\ttestEarlyHints(t, &testOptions{workerScript: \"early-hints.php\"})\n}\nfunc testEarlyHints(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\tvar earlyHintReceived bool\n\t\ttrace := &httptrace.ClientTrace{\n\t\t\tGot1xxResponse: func(code int, header textproto.MIMEHeader) error {\n\t\t\t\tswitch code {\n\t\t\t\tcase http.StatusEarlyHints:\n\t\t\t\t\tassert.Equal(t, \"</style.css>; rel=preload; as=style\", header.Get(\"Link\"))\n\t\t\t\t\tassert.Equal(t, strconv.Itoa(i), header.Get(\"Request\"))\n\n\t\t\t\t\tearlyHintReceived = true\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/early-hints.php?i=%d\", i), nil)\n\t\tw := NewRecorder()\n\t\tw.ClientTrace = trace\n\t\thandler(w, req)\n\n\t\tassert.Equal(t, strconv.Itoa(i), w.Header().Get(\"Request\"))\n\t\tassert.Equal(t, \"\", w.Header().Get(\"Link\"))\n\n\t\tassert.True(t, earlyHintReceived)\n\t}, opts)\n}\n\ntype streamResponseRecorder struct {\n\t*httptest.ResponseRecorder\n\twriteCallback func(buf []byte)\n}\n\nfunc (srr *streamResponseRecorder) Write(buf []byte) (int, error) {\n\tsrr.writeCallback(buf)\n\n\treturn srr.ResponseRecorder.Write(buf)\n}\n\nfunc TestFlush_module(t *testing.T) { testFlush(t, &testOptions{}) }\nfunc TestFlush_worker(t *testing.T) {\n\ttestFlush(t, &testOptions{workerScript: \"flush.php\"})\n}\nfunc testFlush(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\tvar j int\n\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/flush.php?i=%d\", i), nil)\n\t\tw := &streamResponseRecorder{httptest.NewRecorder(), func(buf []byte) {\n\t\t\tif j == 0 {\n\t\t\t\tassert.Equal(t, []byte(\"He\"), buf)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, []byte(fmt.Sprintf(\"llo %d\", i)), buf)\n\t\t\t}\n\n\t\t\tj++\n\t\t}}\n\t\thandler(w, req)\n\n\t\tassert.Equal(t, 2, j)\n\t}, opts)\n}\n\nfunc TestLargeRequest_module(t *testing.T) {\n\ttestLargeRequest(t, &testOptions{})\n}\nfunc TestLargeRequest_worker(t *testing.T) {\n\ttestLargeRequest(t, &testOptions{workerScript: \"large-request.php\"})\n}\nfunc testLargeRequest(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\n\t\t\t\"POST\",\n\t\t\tfmt.Sprintf(\"http://example.com/large-request.php?i=%d\", i),\n\t\t\tstrings.NewReader(strings.Repeat(\"f\", 6_048_576)),\n\t\t)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"Request body size: 6048576 (%d)\", i))\n\t}, opts)\n}\n\nfunc TestVersion(t *testing.T) {\n\tv := frankenphp.Version()\n\n\tassert.GreaterOrEqual(t, v.MajorVersion, 8)\n\tassert.GreaterOrEqual(t, v.MinorVersion, 0)\n\tassert.GreaterOrEqual(t, v.ReleaseVersion, 0)\n\tassert.GreaterOrEqual(t, v.VersionID, 0)\n\tassert.NotEmpty(t, v.Version, 0)\n}\n\nfunc TestFiberNoCgo_module(t *testing.T) { testFiberNoCgo(t, &testOptions{}) }\nfunc TestFiberNonCgo_worker(t *testing.T) {\n\ttestFiberNoCgo(t, &testOptions{workerScript: \"fiber-no-cgo.php\"})\n}\nfunc testFiberNoCgo(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/fiber-no-cgo.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, string(body), fmt.Sprintf(\"Fiber %d\", i))\n\t}, opts)\n}\n\nfunc TestFiberBasic_module(t *testing.T) { testFiberBasic(t, &testOptions{}) }\nfunc TestFiberBasic_worker(t *testing.T) {\n\ttestFiberBasic(t, &testOptions{workerScript: \"fiber-basic.php\"})\n}\nfunc testFiberBasic(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/fiber-basic.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, string(body), fmt.Sprintf(\"Fiber %d\", i))\n\t}, opts)\n}\n\nfunc TestRequestHeaders_module(t *testing.T) { testRequestHeaders(t, &testOptions{}) }\nfunc TestRequestHeaders_worker(t *testing.T) {\n\ttestRequestHeaders(t, &testOptions{workerScript: \"request-headers.php\"})\n}\nfunc testRequestHeaders(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/request-headers.php?i=%d\", i), nil)\n\t\treq.Header.Add(strings.Clone(\"Content-Type\"), strings.Clone(\"text/plain\"))\n\t\treq.Header.Add(strings.Clone(\"Frankenphp-I\"), strings.Clone(strconv.Itoa(i)))\n\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"[Content-Type] => text/plain\")\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[Frankenphp-I] => %d\", i))\n\t}, opts)\n}\n\nfunc TestFailingWorker(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/failing-worker.php\", nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\tassert.Contains(t, string(body), \"ok\")\n\t}, &testOptions{workerScript: \"failing-worker.php\"})\n}\n\nfunc TestEnv(t *testing.T) {\n\ttestEnv(t, &testOptions{})\n}\nfunc TestEnvWorker(t *testing.T) {\n\ttestEnv(t, &testOptions{workerScript: \"test-env.php\"})\n}\nfunc testEnv(t *testing.T, opts *testOptions) {\n\tassert.NoError(t, os.Setenv(\"EMPTY\", \"\"))\n\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/test-env.php?var=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\t// execute the script as regular php script\n\t\tcmd := exec.Command(\"php\", \"testdata/test-env.php\", strconv.Itoa(i))\n\t\tstdoutStderr, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\t// php is not installed or other issue, use the hardcoded output below:\n\t\t\tstdoutStderr = []byte(\"Set MY_VAR successfully.\\nMY_VAR = HelloWorld\\nUnset MY_VAR successfully.\\nMY_VAR is unset.\\nMY_VAR set to empty successfully.\\nMY_VAR = \\nUnset NON_EXISTING_VAR successfully.\\n\")\n\t\t}\n\n\t\tassert.Equal(t, string(stdoutStderr), string(body))\n\t}, opts)\n}\n\nfunc TestFileUpload_module(t *testing.T) { testFileUpload(t, &testOptions{}) }\nfunc TestFileUpload_worker(t *testing.T) {\n\ttestFileUpload(t, &testOptions{workerScript: \"file-upload.php\"})\n}\nfunc testFileUpload(t *testing.T, opts *testOptions) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\trequestBody := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(requestBody)\n\t\tpart, _ := writer.CreateFormFile(\"file\", \"foo.txt\")\n\t\t_, err := part.Write([]byte(\"bar\"))\n\t\trequire.NoError(t, err)\n\n\t\twriter.Close()\n\n\t\treq := httptest.NewRequest(\"POST\", \"http://example.com/file-upload.php\", requestBody)\n\t\treq.Header.Add(\"Content-Type\", writer.FormDataContentType())\n\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"Upload OK\")\n\t}, opts)\n}\n\nfunc TestExecuteScriptCLI(t *testing.T) {\n\tif _, err := os.Stat(\"internal/testcli/testcli\"); err != nil {\n\t\tt.Skip(\"internal/testcli/testcli has not been compiled, run `cd internal/testcli/ && go build`\")\n\t}\n\n\tcmd := exec.Command(\"internal/testcli/testcli\", \"testdata/command.php\", \"foo\", \"bar\")\n\tstdoutStderr, err := cmd.CombinedOutput()\n\tassert.Error(t, err)\n\n\tvar exitError *exec.ExitError\n\tif errors.As(err, &exitError) {\n\t\tassert.Equal(t, 3, exitError.ExitCode())\n\t}\n\n\tstdoutStderrStr := string(stdoutStderr)\n\n\tassert.Contains(t, stdoutStderrStr, `\"foo\"`)\n\tassert.Contains(t, stdoutStderrStr, `\"bar\"`)\n\tassert.Contains(t, stdoutStderrStr, \"From the CLI\")\n}\n\nfunc ExampleServeHTTP() {\n\tif err := frankenphp.Init(); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer frankenphp.Shutdown()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(\"/path/to/document/root\", false))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif err := frankenphp.ServeHTTP(w, req); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc ExampleExecuteScriptCLI() {\n\tif len(os.Args) <= 1 {\n\t\tlog.Println(\"Usage: my-program script.php\")\n\t\tos.Exit(1)\n\t}\n\n\tos.Exit(frankenphp.ExecuteScriptCLI(os.Args[1], os.Args))\n}\n\nfunc BenchmarkHelloWorld(b *testing.B) {\n\tif err := frankenphp.Init(frankenphp.WithLogger(zap.NewNop())); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer frankenphp.Shutdown()\n\tcwd, _ := os.Getwd()\n\ttestDataDir := cwd + \"/testdata/\"\n\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(testDataDir, false))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif err := frankenphp.ServeHTTP(w, req); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\treq := httptest.NewRequest(\"GET\", \"http://example.com/index.php\", nil)\n\tw := httptest.NewRecorder()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler(w, req)\n\t}\n}\n\nfunc BenchmarkEcho(b *testing.B) {\n\tif err := frankenphp.Init(frankenphp.WithLogger(zap.NewNop())); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer frankenphp.Shutdown()\n\tcwd, _ := os.Getwd()\n\ttestDataDir := cwd + \"/testdata/\"\n\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(testDataDir, false))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err := frankenphp.ServeHTTP(w, req); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tconst body = `{\n\t\t\"squadName\": \"Super hero squad\",\n\t\t\"homeTown\": \"Metro City\",\n\t\t\"formed\": 2016,\n\t\t\"secretBase\": \"Super tower\",\n\t\t\"active\": true,\n\t\t\"members\": [\n\t\t  {\n\t\t\t\"name\": \"Molecule Man\",\n\t\t\t\"age\": 29,\n\t\t\t\"secretIdentity\": \"Dan Jukes\",\n\t\t\t\"powers\": [\"Radiation resistance\", \"Turning tiny\", \"Radiation blast\"]\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"Madame Uppercut\",\n\t\t\t\"age\": 39,\n\t\t\t\"secretIdentity\": \"Jane Wilson\",\n\t\t\t\"powers\": [\n\t\t\t  \"Million tonne punch\",\n\t\t\t  \"Damage resistance\",\n\t\t\t  \"Superhuman reflexes\"\n\t\t\t]\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"Eternal Flame\",\n\t\t\t\"age\": 1000000,\n\t\t\t\"secretIdentity\": \"Unknown\",\n\t\t\t\"powers\": [\n\t\t\t  \"Immortality\",\n\t\t\t  \"Heat Immunity\",\n\t\t\t  \"Inferno\",\n\t\t\t  \"Teleportation\",\n\t\t\t  \"Interdimensional travel\"\n\t\t\t]\n\t\t  }\n\t\t]\n\t  }`\n\n\tr := strings.NewReader(body)\n\treq := httptest.NewRequest(\"POST\", \"http://example.com/echo.php\", r)\n\tw := httptest.NewRecorder()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr.Reset(body)\n\t\thandler(w, req)\n\t}\n}\n\nfunc BenchmarkServerSuperGlobal(b *testing.B) {\n\tif err := frankenphp.Init(frankenphp.WithLogger(zap.NewNop())); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer frankenphp.Shutdown()\n\tcwd, _ := os.Getwd()\n\ttestDataDir := cwd + \"/testdata/\"\n\n\t// Mimicks headers of a request sent by Firefox to GitHub\n\theaders := http.Header{}\n\theaders.Add(strings.Clone(\"Accept\"), strings.Clone(\"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\"))\n\theaders.Add(strings.Clone(\"Accept-Encoding\"), strings.Clone(\"gzip, deflate, br\"))\n\theaders.Add(strings.Clone(\"Accept-Language\"), strings.Clone(\"fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3\"))\n\theaders.Add(strings.Clone(\"Cache-Control\"), strings.Clone(\"no-cache\"))\n\theaders.Add(strings.Clone(\"Connection\"), strings.Clone(\"keep-alive\"))\n\theaders.Add(strings.Clone(\"Cookie\"), strings.Clone(\"user_session=myrandomuuid; __Host-user_session_same_site=myotherrandomuuid; dotcom_user=dunglas; logged_in=yes; _foo=barbarbarbarbarbar; _device_id=anotherrandomuuid; color_mode=foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar; preferred_color_mode=light; tz=Europe%2FParis; has_recent_activity=1\"))\n\theaders.Add(strings.Clone(\"DNT\"), strings.Clone(\"1\"))\n\theaders.Add(strings.Clone(\"Host\"), strings.Clone(\"example.com\"))\n\theaders.Add(strings.Clone(\"Pragma\"), strings.Clone(\"no-cache\"))\n\theaders.Add(strings.Clone(\"Sec-Fetch-Dest\"), strings.Clone(\"document\"))\n\theaders.Add(strings.Clone(\"Sec-Fetch-Mode\"), strings.Clone(\"navigate\"))\n\theaders.Add(strings.Clone(\"Sec-Fetch-Site\"), strings.Clone(\"cross-site\"))\n\theaders.Add(strings.Clone(\"Sec-GPC\"), strings.Clone(\"1\"))\n\theaders.Add(strings.Clone(\"Upgrade-Insecure-Requests\"), strings.Clone(\"1\"))\n\theaders.Add(strings.Clone(\"User-Agent\"), strings.Clone(\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:122.0) Gecko/20100101 Firefox/122.0\"))\n\n\t// Env vars available in a typical Docker container\n\tenv := map[string]string{\n\t\t\"HOSTNAME\":        \"a88e81aa22e4\",\n\t\t\"PHP_INI_DIR\":     \"/usr/local/etc/php\",\n\t\t\"HOME\":            \"/root\",\n\t\t\"GODEBUG\":         \"cgocheck=0\",\n\t\t\"PHP_LDFLAGS\":     \"-Wl,-O1 -pie\",\n\t\t\"PHP_CFLAGS\":      \"-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\",\n\t\t\"PHP_VERSION\":     \"8.3.2\",\n\t\t\"GPG_KEYS\":        \"1198C0117593497A5EC5C199286AF1F9897469DC C28D937575603EB4ABB725861C0779DC5C0A9DE4 AFD8691FDAEDF03BDF6E460563F15A9B715376CA\",\n\t\t\"PHP_CPPFLAGS\":    \"-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\",\n\t\t\"PHP_ASC_URL\":     \"https://www.php.net/distributions/php-8.3.2.tar.xz.asc\",\n\t\t\"PHP_URL\":         \"https://www.php.net/distributions/php-8.3.2.tar.xz\",\n\t\t\"PATH\":            \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\t\"XDG_CONFIG_HOME\": \"/config\",\n\t\t\"XDG_DATA_HOME\":   \"/data\",\n\t\t\"PHPIZE_DEPS\":     \"autoconf dpkg-dev file g++ gcc libc-dev make pkg-config re2c\",\n\t\t\"PWD\":             \"/app\",\n\t\t\"PHP_SHA256\":      \"4ffa3e44afc9c590e28dc0d2d31fc61f0139f8b335f11880a121b9f9b9f0634e\",\n\t}\n\n\tpreparedEnv := frankenphp.PrepareEnv(env)\n\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(testDataDir, false), frankenphp.WithRequestPreparedEnv(preparedEnv))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tr.Header = headers\n\t\tif err := frankenphp.ServeHTTP(w, req); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\treq := httptest.NewRequest(\"GET\", \"http://example.com/server-variable.php\", nil)\n\tw := httptest.NewRecorder()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler(w, req)\n\t}\n}\n\nfunc TestRejectInvalidHeaders_module(t *testing.T) { testRejectInvalidHeaders(t, &testOptions{}) }\nfunc TestRejectInvalidHeaders_worker(t *testing.T) {\n\ttestRejectInvalidHeaders(t, &testOptions{workerScript: \"headers.php\"})\n}\nfunc testRejectInvalidHeaders(t *testing.T, opts *testOptions) {\n\tinvalidHeaders := [][]string{\n\t\t{\"Content-Length\", \"-1\"},\n\t\t{\"Content-Length\", \"something\"},\n\t}\n\tfor _, header := range invalidHeaders {\n\t\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, _ int) {\n\t\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/headers.php\", nil)\n\t\t\treq.Header.Add(header[0], header[1])\n\n\t\t\tw := httptest.NewRecorder()\n\t\t\thandler(w, req)\n\n\t\t\tresp := w.Result()\n\t\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\t\tassert.Equal(t, 400, resp.StatusCode)\n\t\t\tassert.Contains(t, string(body), \"invalid\")\n\t\t}, opts)\n\t}\n}\n\n// To run this fuzzing test use: go test -fuzz FuzzRequest\n// TODO: Cover more potential cases\nfunc FuzzRequest(f *testing.F) {\n\tabsPath, _ := fastabs.FastAbs(\"./testdata/\")\n\n\tf.Add(\"hello world\")\n\tf.Add(\"ðððð¤©ð¥²ð¤ªððððð§\")\n\tf.Add(\"%00%11%%22%%33%%44%%55%%66%%77%%88%%99%%aa%%bb%%cc%%dd%%ee%%ff\")\n\tf.Add(\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n\tf.Fuzz(func(t *testing.T, fuzzedString string) {\n\t\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, _ int) {\n\t\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/server-variable\", nil)\n\t\t\treq.URL = &url.URL{RawQuery: \"test=\" + fuzzedString, Path: \"/server-variable.php/\" + fuzzedString}\n\t\t\treq.Header.Add(strings.Clone(\"Fuzzed\"), strings.Clone(fuzzedString))\n\t\t\treq.Header.Add(strings.Clone(\"Content-Type\"), fuzzedString)\n\n\t\t\tw := httptest.NewRecorder()\n\t\t\thandler(w, req)\n\n\t\t\tresp := w.Result()\n\t\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\t\t// The response status must be 400 if the request path contains null bytes\n\t\t\tif strings.Contains(req.URL.Path, \"\\x00\") {\n\t\t\t\tassert.Equal(t, 400, resp.StatusCode)\n\t\t\t\tassert.Contains(t, string(body), \"Invalid request path\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// The fuzzed string must be present in the path\n\t\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[PATH_INFO] => /%s\", fuzzedString))\n\t\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[PATH_TRANSLATED] => %s\", filepath.Join(absPath, fuzzedString)))\n\n\t\t\t// Headers should always be present even if empty\n\t\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[CONTENT_TYPE] => %s\", fuzzedString))\n\t\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[HTTP_FUZZED] => %s\", fuzzedString))\n\n\t\t}, &testOptions{workerScript: \"request-headers.php\"})\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.044921875,
          "content": "module github.com/dunglas/frankenphp\n\ngo 1.22.0\n\ntoolchain go1.23.3\n\nretract v1.0.0-rc.1 // Human error\n\nrequire (\n\tgithub.com/maypok86/otter v1.2.4\n\tgithub.com/prometheus/client_golang v1.20.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgo.uber.org/zap v1.27.0\n\tgolang.org/x/net v0.34.0\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dolthub/maphash v0.1.0 // indirect\n\tgithub.com/gammazero/deque v1.0.0 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.61.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgithub.com/rogpeppe/go-internal v1.12.0 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/protobuf v1.36.2 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.6376953125,
          "content": "github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dolthub/maphash v0.1.0 h1:bsQ7JsF4FkkWyrP3oCnFJgrCUAFbFf3kOl4L/QxPDyQ=\ngithub.com/dolthub/maphash v0.1.0/go.mod h1:gkg4Ch4CdCDu5h6PMriVLawB7koZ+5ijb9puGMV50a4=\ngithub.com/gammazero/deque v1.0.0 h1:LTmimT8H7bXkkCy6gZX7zNLtkbz4NdS2z8LZuor3j34=\ngithub.com/gammazero/deque v1.0.0/go.mod h1:iflpYvtGfM3U8S8j+sZEKIak3SAKYpA5/SQewgfXDKo=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/klauspost/compress v1.17.9 h1:6KIumPrER1LHsvBVuDa0r5xaG0Es51mhhB9BQB2qeMA=\ngithub.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/maypok86/otter v1.2.4 h1:HhW1Pq6VdJkmWwcZZq19BlEQkHtI8xgsQzBVXJU0nfc=\ngithub.com/maypok86/otter v1.2.4/go.mod h1:mKLfoI7v1HOmQMwFgX4QkRk23mX6ge3RDvjdHOWG4R4=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=\ngithub.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.61.0 h1:3gv/GThfX0cV2lpO7gkTUwZru38mxevy90Bj8YFSRQQ=\ngithub.com/prometheus/common v0.61.0/go.mod h1:zr29OCN/2BsJRaFwG8QOBr41D6kkchKbpeNH7pAjb/s=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngolang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=\ngolang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngoogle.golang.org/protobuf v1.36.2 h1:R8FeyR1/eLmkutZOM5CWghmo5itiG9z0ktFlTVLuTmU=\ngoogle.golang.org/protobuf v1.36.2/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 2.0263671875,
          "content": "#!/bin/sh\n\nset -e\n\nif [ -z \"${BIN_DIR}\" ]; then\n\tBIN_DIR=$(pwd)\nfi\n\nTHE_ARCH_BIN=\"\"\nDEST=${BIN_DIR}/frankenphp\n\nOS=$(uname -s)\nARCH=$(uname -m)\n\nif type \"tput\" >/dev/null 2>&1; then\n\tbold=$(tput bold || true)\n\titalic=$(tput sitm || true)\n\tnormal=$(tput sgr0 || true)\nfi\n\ncase ${OS} in\nLinux*)\n\tcase ${ARCH} in\n\taarch64)\n\t\tTHE_ARCH_BIN=\"frankenphp-linux-aarch64\"\n\t\t;;\n\tx86_64)\n\t\tTHE_ARCH_BIN=\"frankenphp-linux-x86_64\"\n\t\t;;\n\t*)\n\t\tTHE_ARCH_BIN=\"\"\n\t\t;;\n\tesac\n\t;;\nDarwin*)\n\tcase ${ARCH} in\n\tarm64)\n\t\tTHE_ARCH_BIN=\"frankenphp-mac-arm64\"\n\t\t;;\n\t*)\n\t\tTHE_ARCH_BIN=\"frankenphp-mac-x86_64\"\n\t\t;;\n\tesac\n\t;;\nWindows | MINGW64_NT*)\n\techo \"â Use WSL to run FrankenPHP on Windows: https://learn.microsoft.com/windows/wsl/\"\n\texit 1\n\t;;\n*)\n\tTHE_ARCH_BIN=\"\"\n\t;;\nesac\n\nif [ -z \"${THE_ARCH_BIN}\" ]; then\n\techo \"â FrankenPHP is not supported on ${OS} and ${ARCH}\"\n\texit 1\nfi\n\nSUDO=\"\"\n\necho \"ð¦ Downloading ${bold}FrankenPHP${normal} for ${OS} (${ARCH}):\"\n\n# check if $DEST is writable and suppress an error message\ntouch \"${DEST}\" 2>/dev/null\n\n# we need sudo powers to write to DEST\nif [ $? -eq 1 ]; then\n\techo \"â You do not have permission to write to ${italic}${DEST}${normal}, enter your password to grant sudo powers\"\n\tSUDO=\"sudo\"\nfi\n\nif type \"curl\" >/dev/null 2>&1; then\n\tcurl -L --progress-bar \"https://github.com/dunglas/frankenphp/releases/latest/download/${THE_ARCH_BIN}\" -o \"${DEST}\"\nelif type \"wget\" >/dev/null 2>&1; then\n\t${SUDO} wget \"https://github.com/dunglas/frankenphp/releases/latest/download/${THE_ARCH_BIN}\" -O \"${DEST}\"\nelse\n\techo \"â Please install ${italic}curl${normal} or ${italic}wget${normal} to download FrankenPHP\"\n\texit 1\nfi\n\n${SUDO} chmod +x \"${DEST}\"\n\necho\necho \"ð¥³ FrankenPHP downloaded successfully to ${italic}${DEST}${normal}\"\necho \"ð§ Move the binary to ${italic}/usr/local/bin/${normal} or another directory in your ${italic}PATH${normal} to use it globally:\"\necho \"   ${bold}sudo mv ${DEST} /usr/local/bin/${normal}\"\necho\necho \"â­ If you like FrankenPHP, please give it a star on GitHub: ${italic}https://github.com/dunglas/frankenphp${normal}\"\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "metrics.go",
          "type": "blob",
          "size": 8.5224609375,
          "content": "package frankenphp\n\nimport (\n\t\"github.com/dunglas/frankenphp/internal/fastabs\"\n\t\"regexp\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\n\nvar metricsNameRegex = regexp.MustCompile(`\\W+`)\nvar metricsNameFixRegex = regexp.MustCompile(`^_+|_+$`)\n\nconst (\n\tStopReasonCrash = iota\n\tStopReasonRestart\n\tStopReasonShutdown\n)\n\ntype StopReason int\n\ntype Metrics interface {\n\t// StartWorker collects started workers\n\tStartWorker(name string)\n\t// ReadyWorker collects ready workers\n\tReadyWorker(name string)\n\t// StopWorker collects stopped workers\n\tStopWorker(name string, reason StopReason)\n\t// TotalWorkers collects expected workers\n\tTotalWorkers(name string, num int)\n\t// TotalThreads collects total threads\n\tTotalThreads(num int)\n\t// StartRequest collects started requests\n\tStartRequest()\n\t// StopRequest collects stopped requests\n\tStopRequest()\n\t// StopWorkerRequest collects stopped worker requests\n\tStopWorkerRequest(name string, duration time.Duration)\n\t// StartWorkerRequest collects started worker requests\n\tStartWorkerRequest(name string)\n\tShutdown()\n}\n\ntype nullMetrics struct{}\n\nfunc (n nullMetrics) StartWorker(string) {\n}\n\nfunc (n nullMetrics) ReadyWorker(string) {\n}\n\nfunc (n nullMetrics) StopWorker(string, StopReason) {\n}\n\nfunc (n nullMetrics) TotalWorkers(string, int) {\n}\n\nfunc (n nullMetrics) TotalThreads(int) {\n}\n\nfunc (n nullMetrics) StartRequest() {\n}\n\nfunc (n nullMetrics) StopRequest() {\n}\n\nfunc (n nullMetrics) StopWorkerRequest(string, time.Duration) {\n}\n\nfunc (n nullMetrics) StartWorkerRequest(string) {\n}\n\nfunc (n nullMetrics) Shutdown() {\n}\n\ntype PrometheusMetrics struct {\n\tregistry           prometheus.Registerer\n\ttotalThreads       prometheus.Counter\n\tbusyThreads        prometheus.Gauge\n\ttotalWorkers       map[string]prometheus.Gauge\n\tbusyWorkers        map[string]prometheus.Gauge\n\treadyWorkers       map[string]prometheus.Gauge\n\tworkerCrashes      map[string]prometheus.Counter\n\tworkerRestarts     map[string]prometheus.Counter\n\tworkerRequestTime  map[string]prometheus.Counter\n\tworkerRequestCount map[string]prometheus.Counter\n\tmu                 sync.Mutex\n}\n\nfunc (m *PrometheusMetrics) StartWorker(name string) {\n\tm.busyThreads.Inc()\n\n\t// tests do not register workers before starting them\n\tif _, ok := m.totalWorkers[name]; !ok {\n\t\treturn\n\t}\n\tm.totalWorkers[name].Inc()\n}\n\nfunc (m *PrometheusMetrics) ReadyWorker(name string) {\n\tif _, ok := m.totalWorkers[name]; !ok {\n\t\treturn\n\t}\n\n\tm.readyWorkers[name].Inc()\n}\n\nfunc (m *PrometheusMetrics) StopWorker(name string, reason StopReason) {\n\tm.busyThreads.Dec()\n\n\t// tests do not register workers before starting them\n\tif _, ok := m.totalWorkers[name]; !ok {\n\t\treturn\n\t}\n\tm.totalWorkers[name].Dec()\n\tm.readyWorkers[name].Dec()\n\n\tif reason == StopReasonCrash {\n\t\tm.workerCrashes[name].Inc()\n\t} else if reason == StopReasonRestart {\n\t\tm.workerRestarts[name].Inc()\n\t} else if reason == StopReasonShutdown {\n\t\tm.totalWorkers[name].Dec()\n\t}\n}\n\nfunc (m *PrometheusMetrics) getIdentity(name string) (string, error) {\n\tactualName, err := fastabs.FastAbs(name)\n\tif err != nil {\n\t\treturn name, err\n\t}\n\n\treturn actualName, nil\n}\n\nfunc (m *PrometheusMetrics) TotalWorkers(name string, _ int) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tidentity, err := m.getIdentity(name)\n\tif err != nil {\n\t\t// do not create metrics, let error propagate when worker is started\n\t\treturn\n\t}\n\n\tsubsystem := getWorkerNameForMetrics(name)\n\n\tif _, ok := m.totalWorkers[identity]; !ok {\n\t\tm.totalWorkers[identity] = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"total_workers\",\n\t\t\tHelp:      \"Total number of PHP workers for this worker\",\n\t\t})\n\t\tm.registry.MustRegister(m.totalWorkers[identity])\n\t}\n\n\tif _, ok := m.workerCrashes[identity]; !ok {\n\t\tm.workerCrashes[identity] = prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"worker_crashes\",\n\t\t\tHelp:      \"Number of PHP worker crashes for this worker\",\n\t\t})\n\t\tm.registry.MustRegister(m.workerCrashes[identity])\n\t}\n\n\tif _, ok := m.workerRestarts[identity]; !ok {\n\t\tm.workerRestarts[identity] = prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"worker_restarts\",\n\t\t\tHelp:      \"Number of PHP worker restarts for this worker\",\n\t\t})\n\t\tm.registry.MustRegister(m.workerRestarts[identity])\n\t}\n\n\tif _, ok := m.readyWorkers[identity]; !ok {\n\t\tm.readyWorkers[identity] = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"ready_workers\",\n\t\t\tHelp:      \"Running workers that have successfully called frankenphp_handle_request at least once\",\n\t\t})\n\t\tm.registry.MustRegister(m.readyWorkers[identity])\n\t}\n\n\tif _, ok := m.busyWorkers[identity]; !ok {\n\t\tm.busyWorkers[identity] = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"busy_workers\",\n\t\t\tHelp:      \"Number of busy PHP workers for this worker\",\n\t\t})\n\t\tm.registry.MustRegister(m.busyWorkers[identity])\n\t}\n\n\tif _, ok := m.workerRequestTime[identity]; !ok {\n\t\tm.workerRequestTime[identity] = prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"worker_request_time\",\n\t\t})\n\t\tm.registry.MustRegister(m.workerRequestTime[identity])\n\t}\n\n\tif _, ok := m.workerRequestCount[identity]; !ok {\n\t\tm.workerRequestCount[identity] = prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tNamespace: \"frankenphp\",\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"worker_request_count\",\n\t\t})\n\t\tm.registry.MustRegister(m.workerRequestCount[identity])\n\t}\n}\n\nfunc (m *PrometheusMetrics) TotalThreads(num int) {\n\tm.totalThreads.Add(float64(num))\n}\n\nfunc (m *PrometheusMetrics) StartRequest() {\n\tm.busyThreads.Inc()\n}\n\nfunc (m *PrometheusMetrics) StopRequest() {\n\tm.busyThreads.Dec()\n}\n\nfunc (m *PrometheusMetrics) StopWorkerRequest(name string, duration time.Duration) {\n\tif _, ok := m.workerRequestTime[name]; !ok {\n\t\treturn\n\t}\n\n\tm.workerRequestCount[name].Inc()\n\tm.busyWorkers[name].Dec()\n\tm.workerRequestTime[name].Add(duration.Seconds())\n}\n\nfunc (m *PrometheusMetrics) StartWorkerRequest(name string) {\n\tif _, ok := m.busyWorkers[name]; !ok {\n\t\treturn\n\t}\n\tm.busyWorkers[name].Inc()\n}\n\nfunc (m *PrometheusMetrics) Shutdown() {\n\tm.registry.Unregister(m.totalThreads)\n\tm.registry.Unregister(m.busyThreads)\n\n\tfor _, g := range m.totalWorkers {\n\t\tm.registry.Unregister(g)\n\t}\n\n\tfor _, g := range m.busyWorkers {\n\t\tm.registry.Unregister(g)\n\t}\n\n\tfor _, c := range m.workerRequestTime {\n\t\tm.registry.Unregister(c)\n\t}\n\n\tfor _, c := range m.workerRequestCount {\n\t\tm.registry.Unregister(c)\n\t}\n\n\tfor _, c := range m.workerCrashes {\n\t\tm.registry.Unregister(c)\n\t}\n\n\tfor _, c := range m.workerRestarts {\n\t\tm.registry.Unregister(c)\n\t}\n\n\tfor _, g := range m.readyWorkers {\n\t\tm.registry.Unregister(g)\n\t}\n\n\tm.totalThreads = prometheus.NewCounter(prometheus.CounterOpts{\n\t\tName: \"frankenphp_total_threads\",\n\t\tHelp: \"Total number of PHP threads\",\n\t})\n\tm.busyThreads = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"frankenphp_busy_threads\",\n\t\tHelp: \"Number of busy PHP threads\",\n\t})\n\tm.totalWorkers = map[string]prometheus.Gauge{}\n\tm.busyWorkers = map[string]prometheus.Gauge{}\n\tm.workerRequestTime = map[string]prometheus.Counter{}\n\tm.workerRequestCount = map[string]prometheus.Counter{}\n\tm.workerRestarts = map[string]prometheus.Counter{}\n\tm.workerCrashes = map[string]prometheus.Counter{}\n\tm.readyWorkers = map[string]prometheus.Gauge{}\n\n\tm.registry.MustRegister(m.totalThreads)\n\tm.registry.MustRegister(m.busyThreads)\n}\n\nfunc getWorkerNameForMetrics(name string) string {\n\tname = metricsNameRegex.ReplaceAllString(name, \"_\")\n\tname = metricsNameFixRegex.ReplaceAllString(name, \"\")\n\n\treturn name\n}\n\nfunc NewPrometheusMetrics(registry prometheus.Registerer) *PrometheusMetrics {\n\tif registry == nil {\n\t\tregistry = prometheus.NewRegistry()\n\t}\n\n\tm := &PrometheusMetrics{\n\t\tregistry: registry,\n\t\ttotalThreads: prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tName: \"frankenphp_total_threads\",\n\t\t\tHelp: \"Total number of PHP threads\",\n\t\t}),\n\t\tbusyThreads: prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tName: \"frankenphp_busy_threads\",\n\t\t\tHelp: \"Number of busy PHP threads\",\n\t\t}),\n\t\ttotalWorkers:       map[string]prometheus.Gauge{},\n\t\tbusyWorkers:        map[string]prometheus.Gauge{},\n\t\tworkerRequestTime:  map[string]prometheus.Counter{},\n\t\tworkerRequestCount: map[string]prometheus.Counter{},\n\t\tworkerRestarts:     map[string]prometheus.Counter{},\n\t\tworkerCrashes:      map[string]prometheus.Counter{},\n\t\treadyWorkers:       map[string]prometheus.Gauge{},\n\t}\n\n\tm.registry.MustRegister(m.totalThreads)\n\tm.registry.MustRegister(m.busyThreads)\n\n\treturn m\n}\n"
        },
        {
          "name": "metrics_test.go",
          "type": "blob",
          "size": 2.216796875,
          "content": "package frankenphp\n\nimport (\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/stretchr/testify/require\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetWorkerNameForMetrics(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"worker-1\", \"worker_1\"},\n\t\t{\"worker@name\", \"worker_name\"},\n\t\t{\"worker name\", \"worker_name\"},\n\t\t{\"worker/name\", \"worker_name\"},\n\t\t{\"worker.name\", \"worker_name\"},\n\t\t{\"////worker////name...//worker\", \"worker_name_worker\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := getWorkerNameForMetrics(test.input)\n\t\tassert.Equal(t, test.expected, result)\n\t}\n}\n\nfunc createPrometheusMetrics() *PrometheusMetrics {\n\treturn &PrometheusMetrics{\n\t\tregistry:           prometheus.NewRegistry(),\n\t\ttotalThreads:       prometheus.NewCounter(prometheus.CounterOpts{Name: \"total_threads\"}),\n\t\tbusyThreads:        prometheus.NewGauge(prometheus.GaugeOpts{Name: \"busy_threads\"}),\n\t\ttotalWorkers:       make(map[string]prometheus.Gauge),\n\t\tbusyWorkers:        make(map[string]prometheus.Gauge),\n\t\tworkerRequestTime:  make(map[string]prometheus.Counter),\n\t\tworkerRequestCount: make(map[string]prometheus.Counter),\n\t\tworkerCrashes:      make(map[string]prometheus.Counter),\n\t\tworkerRestarts:     make(map[string]prometheus.Counter),\n\t\treadyWorkers:       make(map[string]prometheus.Gauge),\n\t\tmu:                 sync.Mutex{},\n\t}\n}\n\nfunc TestPrometheusMetrics_TotalWorkers(t *testing.T) {\n\tm := createPrometheusMetrics()\n\n\ttests := []struct {\n\t\tname   string\n\t\tworker string\n\t\tnum    int\n\t}{\n\t\t{\"SetWorkers\", \"test_worker\", 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tm.TotalWorkers(tt.worker, tt.num)\n\t\t\tactualName, _ := m.getIdentity(tt.worker)\n\t\t\t_, ok := m.totalWorkers[actualName]\n\t\t\trequire.True(t, ok)\n\t\t})\n\t}\n}\n\nfunc TestPrometheusMetrics_StopWorkerRequest(t *testing.T) {\n\tm := createPrometheusMetrics()\n\tm.StopWorkerRequest(\"test_worker\", 2*time.Second)\n\n\tname := \"test_worker\"\n\t_, ok := m.workerRequestTime[name]\n\trequire.False(t, ok)\n}\n\nfunc TestPrometheusMetrics_StartWorkerRequest(t *testing.T) {\n\tm := createPrometheusMetrics()\n\tm.StartWorkerRequest(\"test_worker\")\n\n\tname := \"test_worker\"\n\t_, ok := m.workerRequestCount[name]\n\trequire.False(t, ok)\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 1.14453125,
          "content": "package frankenphp\n\nimport (\n\t\"go.uber.org/zap\"\n)\n\n// Option instances allow to configure FrankenPHP.\ntype Option func(h *opt) error\n\n// opt contains the available options.\n//\n// If you change this, also update the Caddy module and the documentation.\ntype opt struct {\n\tnumThreads int\n\tworkers    []workerOpt\n\tlogger     *zap.Logger\n\tmetrics    Metrics\n}\n\ntype workerOpt struct {\n\tfileName string\n\tnum      int\n\tenv      PreparedEnv\n\twatch    []string\n}\n\n// WithNumThreads configures the number of PHP threads to start.\nfunc WithNumThreads(numThreads int) Option {\n\treturn func(o *opt) error {\n\t\to.numThreads = numThreads\n\n\t\treturn nil\n\t}\n}\n\nfunc WithMetrics(m Metrics) Option {\n\treturn func(o *opt) error {\n\t\to.metrics = m\n\n\t\treturn nil\n\t}\n}\n\n// WithWorkers configures the PHP workers to start.\nfunc WithWorkers(fileName string, num int, env map[string]string, watch []string) Option {\n\treturn func(o *opt) error {\n\t\to.workers = append(o.workers, workerOpt{fileName, num, PrepareEnv(env), watch})\n\n\t\treturn nil\n\t}\n}\n\n// WithLogger configures the global logger to use.\nfunc WithLogger(l *zap.Logger) Option {\n\treturn func(o *opt) error {\n\t\to.logger = l\n\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "phpmainthread.go",
          "type": "blob",
          "size": 2.5283203125,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"sync\"\n\n\t\"go.uber.org/zap\"\n)\n\n// represents the main PHP thread\n// the thread needs to keep running as long as all other threads are running\ntype phpMainThread struct {\n\tstate      *threadState\n\tdone       chan struct{}\n\tnumThreads int\n}\n\nvar (\n\tphpThreads []*phpThread\n\tmainThread *phpMainThread\n)\n\n// reserve a fixed number of PHP threads on the Go side\nfunc initPHPThreads(numThreads int) error {\n\tmainThread = &phpMainThread{\n\t\tstate:      newThreadState(),\n\t\tdone:       make(chan struct{}),\n\t\tnumThreads: numThreads,\n\t}\n\tphpThreads = make([]*phpThread, numThreads)\n\n\t// initialize all threads as inactive\n\t// this needs to happen before starting the main thread\n\t// since some extensions access environment variables on startup\n\tfor i := 0; i < numThreads; i++ {\n\t\tphpThreads[i] = newPHPThread(i)\n\t\tconvertToInactiveThread(phpThreads[i])\n\t}\n\n\tif err := mainThread.start(); err != nil {\n\t\treturn err\n\t}\n\n\t// start the underlying C threads\n\tready := sync.WaitGroup{}\n\tready.Add(numThreads)\n\tfor _, thread := range phpThreads {\n\t\tgo func() {\n\t\t\tif !C.frankenphp_new_php_thread(C.uintptr_t(thread.threadIndex)) {\n\t\t\t\tlogger.Panic(\"unable to create thread\", zap.Int(\"threadIndex\", thread.threadIndex))\n\t\t\t}\n\t\t\tthread.state.waitFor(stateInactive)\n\t\t\tready.Done()\n\t\t}()\n\t}\n\tready.Wait()\n\n\treturn nil\n}\n\nfunc drainPHPThreads() {\n\tdoneWG := sync.WaitGroup{}\n\tdoneWG.Add(len(phpThreads))\n\tfor _, thread := range phpThreads {\n\t\tthread.handlerMu.Lock()\n\t\t_ = thread.state.requestSafeStateChange(stateShuttingDown)\n\t\tclose(thread.drainChan)\n\t}\n\tclose(mainThread.done)\n\tfor _, thread := range phpThreads {\n\t\tgo func(thread *phpThread) {\n\t\t\tthread.state.waitFor(stateDone)\n\t\t\tthread.handlerMu.Unlock()\n\t\t\tdoneWG.Done()\n\t\t}(thread)\n\t}\n\tdoneWG.Wait()\n\tmainThread.state.set(stateShuttingDown)\n\tmainThread.state.waitFor(stateDone)\n\tphpThreads = nil\n}\n\nfunc (mainThread *phpMainThread) start() error {\n\tif C.frankenphp_new_main_thread(C.int(mainThread.numThreads)) != 0 {\n\t\treturn MainThreadCreationError\n\t}\n\tmainThread.state.waitFor(stateReady)\n\treturn nil\n}\n\nfunc getInactivePHPThread() *phpThread {\n\tfor _, thread := range phpThreads {\n\t\tif thread.state.is(stateInactive) {\n\t\t\treturn thread\n\t\t}\n\t}\n\tpanic(\"not enough threads reserved\")\n}\n\n//export go_frankenphp_main_thread_is_ready\nfunc go_frankenphp_main_thread_is_ready() {\n\tmainThread.state.set(stateReady)\n\tmainThread.state.waitFor(stateShuttingDown)\n}\n\n//export go_frankenphp_shutdown_main_thread\nfunc go_frankenphp_shutdown_main_thread() {\n\tmainThread.state.set(stateDone)\n}\n"
        },
        {
          "name": "phpmainthread_test.go",
          "type": "blob",
          "size": 4.349609375,
          "content": "package frankenphp\n\nimport (\n\t\"io\"\n\t\"math/rand/v2\"\n\t\"net/http/httptest\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/zap\"\n)\n\nvar testDataPath, _ = filepath.Abs(\"./testdata\")\n\nfunc TestStartAndStopTheMainThreadWithOneInactiveThread(t *testing.T) {\n\tlogger = zap.NewNop()                // the logger needs to not be nil\n\tassert.NoError(t, initPHPThreads(1)) // reserve 1 thread\n\n\tassert.Len(t, phpThreads, 1)\n\tassert.Equal(t, 0, phpThreads[0].threadIndex)\n\tassert.True(t, phpThreads[0].state.is(stateInactive))\n\n\tdrainPHPThreads()\n\tassert.Nil(t, phpThreads)\n}\n\nfunc TestTransitionRegularThreadToWorkerThread(t *testing.T) {\n\tlogger = zap.NewNop()\n\tassert.NoError(t, initPHPThreads(1))\n\n\t// transition to regular thread\n\tconvertToRegularThread(phpThreads[0])\n\tassert.IsType(t, &regularThread{}, phpThreads[0].handler)\n\n\t// transition to worker thread\n\tworker := getDummyWorker(\"transition-worker-1.php\")\n\tconvertToWorkerThread(phpThreads[0], worker)\n\tassert.IsType(t, &workerThread{}, phpThreads[0].handler)\n\tassert.Len(t, worker.threads, 1)\n\n\t// transition back to inactive thread\n\tconvertToInactiveThread(phpThreads[0])\n\tassert.IsType(t, &inactiveThread{}, phpThreads[0].handler)\n\tassert.Len(t, worker.threads, 0)\n\n\tdrainPHPThreads()\n\tassert.Nil(t, phpThreads)\n}\n\nfunc TestTransitionAThreadBetween2DifferentWorkers(t *testing.T) {\n\tlogger = zap.NewNop()\n\tassert.NoError(t, initPHPThreads(1))\n\tfirstWorker := getDummyWorker(\"transition-worker-1.php\")\n\tsecondWorker := getDummyWorker(\"transition-worker-2.php\")\n\n\t// convert to first worker thread\n\tconvertToWorkerThread(phpThreads[0], firstWorker)\n\tfirstHandler := phpThreads[0].handler.(*workerThread)\n\tassert.Same(t, firstWorker, firstHandler.worker)\n\tassert.Len(t, firstWorker.threads, 1)\n\tassert.Len(t, secondWorker.threads, 0)\n\n\t// convert to second worker thread\n\tconvertToWorkerThread(phpThreads[0], secondWorker)\n\tsecondHandler := phpThreads[0].handler.(*workerThread)\n\tassert.Same(t, secondWorker, secondHandler.worker)\n\tassert.Len(t, firstWorker.threads, 0)\n\tassert.Len(t, secondWorker.threads, 1)\n\n\tdrainPHPThreads()\n\tassert.Nil(t, phpThreads)\n}\n\nfunc TestTransitionThreadsWhileDoingRequests(t *testing.T) {\n\tnumThreads := 10\n\tnumRequestsPerThread := 100\n\tisRunning := atomic.Bool{}\n\tisRunning.Store(true)\n\twg := sync.WaitGroup{}\n\tworker1Path := testDataPath + \"/transition-worker-1.php\"\n\tworker2Path := testDataPath + \"/transition-worker-2.php\"\n\n\tassert.NoError(t, Init(\n\t\tWithNumThreads(numThreads),\n\t\tWithWorkers(worker1Path, 1, map[string]string{\"ENV1\": \"foo\"}, []string{}),\n\t\tWithWorkers(worker2Path, 1, map[string]string{\"ENV1\": \"foo\"}, []string{}),\n\t\tWithLogger(zap.NewNop()),\n\t))\n\n\t// randomly transition threads between regular, inactive and 2 worker threads\n\tgo func() {\n\t\tfor {\n\t\t\tfor i := 0; i < numThreads; i++ {\n\t\t\t\tswitch rand.IntN(4) {\n\t\t\t\tcase 0:\n\t\t\t\t\tconvertToRegularThread(phpThreads[i])\n\t\t\t\tcase 1:\n\t\t\t\t\tconvertToWorkerThread(phpThreads[i], workers[worker1Path])\n\t\t\t\tcase 2:\n\t\t\t\t\tconvertToWorkerThread(phpThreads[i], workers[worker2Path])\n\t\t\t\tcase 3:\n\t\t\t\t\tconvertToInactiveThread(phpThreads[i])\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tif !isRunning.Load() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// randomly do requests to the 3 endpoints\n\twg.Add(numThreads)\n\tfor i := 0; i < numThreads; i++ {\n\t\tgo func(i int) {\n\t\t\tfor j := 0; j < numRequestsPerThread; j++ {\n\t\t\t\tswitch rand.IntN(3) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertRequestBody(t, \"http://localhost/transition-worker-1.php\", \"Hello from worker 1\")\n\t\t\t\tcase 1:\n\t\t\t\t\tassertRequestBody(t, \"http://localhost/transition-worker-2.php\", \"Hello from worker 2\")\n\t\t\t\tcase 2:\n\t\t\t\t\tassertRequestBody(t, \"http://localhost/transition-regular.php\", \"Hello from regular thread\")\n\t\t\t\t}\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tisRunning.Store(false)\n\tShutdown()\n}\n\nfunc getDummyWorker(fileName string) *worker {\n\tif workers == nil {\n\t\tworkers = make(map[string]*worker)\n\t}\n\tworker, _ := newWorker(workerOpt{\n\t\tfileName: testDataPath + \"/\" + fileName,\n\t\tnum:      1,\n\t})\n\treturn worker\n}\n\nfunc assertRequestBody(t *testing.T, url string, expected string) {\n\tr := httptest.NewRequest(\"GET\", url, nil)\n\tw := httptest.NewRecorder()\n\n\treq, err := NewRequestWithContext(r, WithRequestDocumentRoot(testDataPath, false))\n\tassert.NoError(t, err)\n\terr = ServeHTTP(w, req)\n\tassert.NoError(t, err)\n\tresp := w.Result()\n\tbody, _ := io.ReadAll(resp.Body)\n\tassert.Equal(t, expected, string(body))\n}\n"
        },
        {
          "name": "phpthread.go",
          "type": "blob",
          "size": 3.2119140625,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"net/http\"\n\t\"runtime\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\n// representation of the actual underlying PHP thread\n// identified by the index in the phpThreads slice\ntype phpThread struct {\n\truntime.Pinner\n\n\tthreadIndex       int\n\tknownVariableKeys map[string]*C.zend_string\n\trequestChan       chan *http.Request\n\tdrainChan         chan struct{}\n\thandlerMu         *sync.Mutex\n\thandler           threadHandler\n\tstate             *threadState\n}\n\n// interface that defines how the callbacks from the C thread should be handled\ntype threadHandler interface {\n\tbeforeScriptExecution() string\n\tafterScriptExecution(exitStatus int)\n\tgetActiveRequest() *http.Request\n}\n\nfunc newPHPThread(threadIndex int) *phpThread {\n\treturn &phpThread{\n\t\tthreadIndex: threadIndex,\n\t\tdrainChan:   make(chan struct{}),\n\t\trequestChan: make(chan *http.Request),\n\t\thandlerMu:   &sync.Mutex{},\n\t\tstate:       newThreadState(),\n\t}\n}\n\n// change the thread handler safely\n// must be called from outside the PHP thread\nfunc (thread *phpThread) setHandler(handler threadHandler) {\n\tlogger.Debug(\"setHandler\")\n\tthread.handlerMu.Lock()\n\tdefer thread.handlerMu.Unlock()\n\tif !thread.state.requestSafeStateChange(stateTransitionRequested) {\n\t\t// no state change allowed == shutdown\n\t\treturn\n\t}\n\tclose(thread.drainChan)\n\tthread.state.waitFor(stateTransitionInProgress)\n\tthread.handler = handler\n\tthread.drainChan = make(chan struct{})\n\tthread.state.set(stateTransitionComplete)\n}\n\n// transition to a new handler safely\n// is triggered by setHandler and executed on the PHP thread\nfunc (thread *phpThread) transitionToNewHandler() string {\n\tthread.state.set(stateTransitionInProgress)\n\tthread.state.waitFor(stateTransitionComplete)\n\t// execute beforeScriptExecution of the new handler\n\treturn thread.handler.beforeScriptExecution()\n}\n\nfunc (thread *phpThread) getActiveRequest() *http.Request {\n\treturn thread.handler.getActiveRequest()\n}\n\n// Pin a string that is not null-terminated\n// PHP's zend_string may contain null-bytes\nfunc (thread *phpThread) pinString(s string) *C.char {\n\tsData := unsafe.StringData(s)\n\tif sData == nil {\n\t\treturn nil\n\t}\n\tthread.Pin(sData)\n\n\treturn (*C.char)(unsafe.Pointer(sData))\n}\n\n// C strings must be null-terminated\nfunc (thread *phpThread) pinCString(s string) *C.char {\n\treturn thread.pinString(s + \"\\x00\")\n}\n\n//export go_frankenphp_before_script_execution\nfunc go_frankenphp_before_script_execution(threadIndex C.uintptr_t) *C.char {\n\tthread := phpThreads[threadIndex]\n\tscriptName := thread.handler.beforeScriptExecution()\n\n\t// if no scriptName is passed, shut down\n\tif scriptName == \"\" {\n\t\treturn nil\n\t}\n\t// return the name of the PHP script that should be executed\n\treturn thread.pinCString(scriptName)\n}\n\n//export go_frankenphp_after_script_execution\nfunc go_frankenphp_after_script_execution(threadIndex C.uintptr_t, exitStatus C.int) {\n\tthread := phpThreads[threadIndex]\n\tif exitStatus < 0 {\n\t\tpanic(ScriptExecutionError)\n\t}\n\tthread.handler.afterScriptExecution(int(exitStatus))\n\n\t// unpin all memory used during script execution\n\tthread.Unpin()\n}\n\n//export go_frankenphp_on_thread_shutdown\nfunc go_frankenphp_on_thread_shutdown(threadIndex C.uintptr_t) {\n\tphpThreads[threadIndex].Unpin()\n\tphpThreads[threadIndex].state.set(stateDone)\n}\n"
        },
        {
          "name": "recorder_test.go",
          "type": "blob",
          "size": 7.5048828125,
          "content": "// Remove me when https://github.com/golang/go/pull/56151 will be merged\n\n// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage frankenphp_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptrace\"\n\t\"net/textproto\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"golang.org/x/net/http/httpguts\"\n)\n\n// ResponseRecorder is an implementation of http.ResponseWriter that\n// records its mutations for later inspection in tests.\ntype ResponseRecorder struct {\n\t// Code is the HTTP response code set by WriteHeader.\n\t//\n\t// Note that if a Handler never calls WriteHeader or Write,\n\t// this might end up being 0, rather than the implicit\n\t// http.StatusOK. To get the implicit value, use the Result\n\t// method.\n\tCode int\n\n\t// HeaderMap contains the headers explicitly set by the Handler.\n\t// It is an internal detail.\n\t//\n\t// Deprecated: HeaderMap exists for historical compatibility\n\t// and should not be used. To access the headers returned by a handler,\n\t// use the Response.Header map as returned by the Result method.\n\tHeaderMap http.Header\n\n\t// Body is the buffer to which the Handler's Write calls are sent.\n\t// If nil, the Writes are silently discarded.\n\tBody *bytes.Buffer\n\n\t// Flushed is whether the Handler called Flush.\n\tFlushed bool\n\n\t// ClientTrace is used to trace 1XX responses\n\tClientTrace *httptrace.ClientTrace\n\n\tresult      *http.Response // cache of Result's return value\n\tsnapHeader  http.Header    // snapshot of HeaderMap at first Write\n\twroteHeader bool\n}\n\n// NewRecorder returns an initialized ResponseRecorder.\nfunc NewRecorder() *ResponseRecorder {\n\treturn &ResponseRecorder{\n\t\tHeaderMap: make(http.Header),\n\t\tBody:      new(bytes.Buffer),\n\t\tCode:      200,\n\t}\n}\n\n// DefaultRemoteAddr is the default remote address to return in RemoteAddr if\n// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.\nconst DefaultRemoteAddr = \"1.2.3.4\"\n\n// Header implements http.ResponseWriter. It returns the response\n// headers to mutate within a handler. To test the headers that were\n// written after a handler completes, use the Result method and see\n// the returned Response value's Header.\nfunc (rw *ResponseRecorder) Header() http.Header {\n\tm := rw.HeaderMap\n\tif m == nil {\n\t\tm = make(http.Header)\n\t\trw.HeaderMap = m\n\t}\n\treturn m\n}\n\n// writeHeader writes a header if it was not written yet and\n// detects Content-Type if needed.\n//\n// bytes or str are the beginning of the response body.\n// We pass both to avoid unnecessarily generate garbage\n// in rw.WriteString which was created for performance reasons.\n// Non-nil bytes win.\nfunc (rw *ResponseRecorder) writeHeader(b []byte, str string) {\n\tif rw.wroteHeader {\n\t\treturn\n\t}\n\tif len(str) > 512 {\n\t\tstr = str[:512]\n\t}\n\n\tm := rw.Header()\n\n\t_, hasType := m[\"Content-Type\"]\n\thasTE := m.Get(\"Transfer-Encoding\") != \"\"\n\tif !hasType && !hasTE {\n\t\tif b == nil {\n\t\t\tb = []byte(str)\n\t\t}\n\t\tm.Set(\"Content-Type\", http.DetectContentType(b))\n\t}\n\n\trw.WriteHeader(200)\n}\n\n// Write implements http.ResponseWriter. The data in buf is written to\n// rw.Body, if not nil.\nfunc (rw *ResponseRecorder) Write(buf []byte) (int, error) {\n\trw.writeHeader(buf, \"\")\n\tif rw.Body != nil {\n\t\trw.Body.Write(buf)\n\t}\n\treturn len(buf), nil\n}\n\n// WriteString implements io.StringWriter. The data in str is written\n// to rw.Body, if not nil.\nfunc (rw *ResponseRecorder) WriteString(str string) (int, error) {\n\trw.writeHeader(nil, str)\n\tif rw.Body != nil {\n\t\trw.Body.WriteString(str)\n\t}\n\treturn len(str), nil\n}\n\nfunc checkWriteHeaderCode(code int) {\n\t// Issue 22880: require valid WriteHeader status codes.\n\t// For now, we only enforce that it's three digits.\n\t// In the future we might block things over 599 (600 and above aren't defined\n\t// at https://httpwg.org/specs/rfc7231.html#status.codes)\n\t// and we might block under 200 (once we have more mature 1xx support).\n\t// But for now any three digits.\n\t//\n\t// We used to send \"HTTP/1.1 000 0\" on the wire in responses but there's\n\t// no equivalent bogus thing we can realistically send in HTTP/2,\n\t// so we'll consistently panic instead and help people find their bugs\n\t// early. (We can't return an error from WriteHeader even if we wanted to.)\n\tif code < 100 || code > 999 {\n\t\tpanic(fmt.Sprintf(\"invalid WriteHeader code %v\", code))\n\t}\n}\n\n// WriteHeader implements http.ResponseWriter.\nfunc (rw *ResponseRecorder) WriteHeader(code int) {\n\tif rw.wroteHeader {\n\t\treturn\n\t}\n\n\tcheckWriteHeaderCode(code)\n\n\tif rw.ClientTrace != nil && code >= 100 && code < 200 {\n\t\tif code == 100 {\n\t\t\trw.ClientTrace.Got100Continue()\n\t\t}\n\t\t// treat 101 as a terminal status, see issue 26161\n\t\tif code != http.StatusSwitchingProtocols {\n\t\t\tif err := rw.ClientTrace.Got1xxResponse(code, textproto.MIMEHeader(rw.HeaderMap)); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\trw.Code = code\n\trw.wroteHeader = true\n\tif rw.HeaderMap == nil {\n\t\trw.HeaderMap = make(http.Header)\n\t}\n\trw.snapHeader = rw.HeaderMap.Clone()\n}\n\n// Flush implements http.Flusher. To test whether Flush was\n// called, see rw.Flushed.\nfunc (rw *ResponseRecorder) Flush() {\n\tif !rw.wroteHeader {\n\t\trw.WriteHeader(200)\n\t}\n\trw.Flushed = true\n}\n\n// Result returns the response generated by the handler.\n//\n// The returned Response will have at least its StatusCode,\n// Header, Body, and optionally Trailer populated.\n// More fields may be populated in the future, so callers should\n// not DeepEqual the result in tests.\n//\n// The Response.Header is a snapshot of the headers at the time of the\n// first write call, or at the time of this call, if the handler never\n// did a write.\n//\n// The Response.Body is guaranteed to be non-nil and Body.Read call is\n// guaranteed to not return any error other than io.EOF.\n//\n// Result must only be called after the handler has finished running.\nfunc (rw *ResponseRecorder) Result() *http.Response {\n\tif rw.result != nil {\n\t\treturn rw.result\n\t}\n\tif rw.snapHeader == nil {\n\t\trw.snapHeader = rw.HeaderMap.Clone()\n\t}\n\tres := &http.Response{\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tStatusCode: rw.Code,\n\t\tHeader:     rw.snapHeader,\n\t}\n\trw.result = res\n\tif res.StatusCode == 0 {\n\t\tres.StatusCode = 200\n\t}\n\tres.Status = fmt.Sprintf(\"%03d %s\", res.StatusCode, http.StatusText(res.StatusCode))\n\tif rw.Body != nil {\n\t\tres.Body = io.NopCloser(bytes.NewReader(rw.Body.Bytes()))\n\t} else {\n\t\tres.Body = http.NoBody\n\t}\n\tres.ContentLength = parseContentLength(res.Header.Get(\"Content-Length\"))\n\n\tif trailers, ok := rw.snapHeader[\"Trailer\"]; ok {\n\t\tres.Trailer = make(http.Header, len(trailers))\n\t\tfor _, k := range trailers {\n\t\t\tfor _, k := range strings.Split(k, \",\") {\n\t\t\t\tk = http.CanonicalHeaderKey(textproto.TrimString(k))\n\t\t\t\tif !httpguts.ValidTrailerHeader(k) {\n\t\t\t\t\t// Ignore since forbidden by RFC 7230, section 4.1.2.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvv, ok := rw.HeaderMap[k]\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvv2 := make([]string, len(vv))\n\t\t\t\tcopy(vv2, vv)\n\t\t\t\tres.Trailer[k] = vv2\n\t\t\t}\n\t\t}\n\t}\n\tfor k, vv := range rw.HeaderMap {\n\t\tif !strings.HasPrefix(k, http.TrailerPrefix) {\n\t\t\tcontinue\n\t\t}\n\t\tif res.Trailer == nil {\n\t\t\tres.Trailer = make(http.Header)\n\t\t}\n\t\tfor _, v := range vv {\n\t\t\tres.Trailer.Add(strings.TrimPrefix(k, http.TrailerPrefix), v)\n\t\t}\n\t}\n\treturn res\n}\n\n// parseContentLength trims whitespace from s and returns -1 if no value\n// is set, or the value if it's >= 0.\n//\n// This a modified version of same function found in net/http/transfer.go. This\n// one just ignores an invalid header.\nfunc parseContentLength(cl string) int64 {\n\tcl = textproto.TrimString(cl)\n\tif cl == \"\" {\n\t\treturn -1\n\t}\n\tn, err := strconv.ParseUint(cl, 10, 63)\n\tif err != nil {\n\t\treturn -1\n\t}\n\treturn int64(n)\n}\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 1.4462890625,
          "content": "#!/usr/bin/env bash\n\n# Creates the tags for the library and the Caddy module.\n\nset -o nounset\nset -o errexit\ntrap 'echo \"Aborting due to errexit on line $LINENO. Exit code: $?\" >&2' ERR\nset -o errtrace\nset -o pipefail\nset -o xtrace\n\nif ! type \"git\" >/dev/null; then\n\techo \"The \\\"git\\\" command must be installed.\"\n\texit 1\nfi\n\nif ! type \"gh\" >/dev/null; then\n\techo \"The \\\"gh\\\" command must be installed.\"\n\texit 1\nfi\n\nif ! type \"brew\" >/dev/null; then\n\techo \"The \\\"brew\\\" command must be installed.\"\n\texit 1\nfi\n\nif [[ $# -ne 1 ]]; then\n\techo \"Usage: ./release.sh version\" >&2\n\texit 1\nfi\n\n# Adapted from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nif [[ ! $1 =~ ^(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(-((0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*))*))?(\\+([0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*))?$ ]]; then\n\techo \"Invalid version number: $1\" >&2\n\texit 1\nfi\n\ngit checkout main\ngit pull\n\ncd caddy/\ngo get \"github.com/dunglas/frankenphp@v$1\"\ncd -\n\ngit commit -S -a -m \"chore: prepare release $1\" || echo \"skip\"\n\ngit tag -s -m \"Version $1\" \"v$1\"\ngit tag -s -m \"Version $1\" \"caddy/v$1\"\ngit push --follow-tags\n\ntags=$(git tag --list --sort=-version:refname 'v*')\nprevious_tag=$(awk 'NR==2 {print;exit}' <<<\"${tags}\")\n\ngh release create --draft --generate-notes --latest --notes-start-tag \"${previous_tag}\" --verify-tag \"v$1\"\nbrew bump-formula-pr dunglas/frankenphp/frankenphp --version \"$1\"\n"
        },
        {
          "name": "reload_test.sh",
          "type": "blob",
          "size": 0.3447265625,
          "content": "#!/bin/bash\nfor ((i = 0; i < 100; i++)); do\n\tcurl --no-progress-meter -o /dev/null http://localhost:2019/config/apps/frankenphp -: --no-progress-meter -o /dev/null -H 'Cache-Control: must-revalidate' -H 'Content-Type: application/json' --data-binary '{\"workers\":[{\"file_name\":\"./index.php\"}]}' -X PATCH http://localhost:2019/config/apps/frankenphp\ndone\n"
        },
        {
          "name": "request_options.go",
          "type": "blob",
          "size": 3.4404296875,
          "content": "package frankenphp\n\nimport (\n\t\"github.com/dunglas/frankenphp/internal/fastabs\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"go.uber.org/zap\"\n)\n\n// RequestOption instances allow to configure a FrankenPHP Request.\ntype RequestOption func(h *FrankenPHPContext) error\n\nvar (\n\tdocumentRootCache    sync.Map\n\tdocumentRootCacheLen atomic.Uint32\n)\n\n// WithRequestDocumentRoot sets the root directory of the PHP application.\n// if resolveSymlink is true, oath declared as root directory will be resolved\n// to its absolute value after the evaluation of any symbolic links.\n// Due to the nature of PHP opcache, root directory path is cached: when\n// using a symlinked directory as root this could generate errors when\n// symlink is changed without PHP being restarted; enabling this\n// directive will set $_SERVER['DOCUMENT_ROOT'] to the real directory path.\nfunc WithRequestDocumentRoot(documentRoot string, resolveSymlink bool) RequestOption {\n\treturn func(o *FrankenPHPContext) (err error) {\n\t\tv, ok := documentRootCache.Load(documentRoot)\n\t\tif !ok {\n\t\t\t// make sure file root is absolute\n\t\t\tv, err = fastabs.FastAbs(documentRoot)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// prevent the cache to grow forever, this is a totally arbitrary value\n\t\t\tif documentRootCacheLen.Load() < 1024 {\n\t\t\t\tdocumentRootCache.LoadOrStore(documentRoot, v)\n\t\t\t\tdocumentRootCacheLen.Add(1)\n\t\t\t}\n\t\t}\n\n\t\tif resolveSymlink {\n\t\t\tif v, err = filepath.EvalSymlinks(v.(string)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\to.documentRoot = v.(string)\n\n\t\treturn nil\n\t}\n}\n\n// WithRequestResolvedDocumentRoot is similar to WithRequestDocumentRoot\n// but doesn't do any checks or resolving on the path to improve performance.\nfunc WithRequestResolvedDocumentRoot(documentRoot string) RequestOption {\n\treturn func(o *FrankenPHPContext) error {\n\t\to.documentRoot = documentRoot\n\n\t\treturn nil\n\t}\n}\n\n// WithRequestSplitPath contains a list of split path strings.\n//\n// The path in the URL will be split into two, with the first piece ending\n// with the value of splitPath. The first piece will be assumed as the\n// actual resource (CGI script) name, and the second piece will be set to\n// PATH_INFO for the CGI script to use.\n//\n// Future enhancements should be careful to avoid CVE-2019-11043,\n// which can be mitigated with use of a try_files-like behavior\n// that 404s if the FastCGI path info is not found.\nfunc WithRequestSplitPath(splitPath []string) RequestOption {\n\treturn func(o *FrankenPHPContext) error {\n\t\to.splitPath = splitPath\n\n\t\treturn nil\n\t}\n}\n\ntype PreparedEnv = map[string]string\n\nfunc PrepareEnv(env map[string]string) PreparedEnv {\n\tpreparedEnv := make(PreparedEnv, len(env))\n\tfor k, v := range env {\n\t\tpreparedEnv[k+\"\\x00\"] = v\n\t}\n\n\treturn preparedEnv\n}\n\n// WithRequestEnv set CGI-like environment variables that will be available in $_SERVER.\n// Values set with WithEnv always have priority over automatically populated values.\nfunc WithRequestEnv(env map[string]string) RequestOption {\n\treturn WithRequestPreparedEnv(PrepareEnv(env))\n}\n\nfunc WithRequestPreparedEnv(env PreparedEnv) RequestOption {\n\treturn func(o *FrankenPHPContext) error {\n\t\to.env = env\n\n\t\treturn nil\n\t}\n}\n\nfunc WithOriginalRequest(r *http.Request) RequestOption {\n\treturn func(o *FrankenPHPContext) error {\n\t\to.originalRequest = r\n\n\t\treturn nil\n\t}\n}\n\n// WithRequestLogger sets the logger associated with the current request\nfunc WithRequestLogger(logger *zap.Logger) RequestOption {\n\treturn func(o *FrankenPHPContext) error {\n\t\to.logger = logger\n\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "state.go",
          "type": "blob",
          "size": 2.8994140625,
          "content": "package frankenphp\n\nimport (\n\t\"slices\"\n\t\"strconv\"\n\t\"sync\"\n)\n\ntype stateID uint8\n\nconst (\n\t// lifecycle states of a thread\n\tstateBooting stateID = iota\n\tstateShuttingDown\n\tstateDone\n\n\t// these states are safe to transition from at any time\n\tstateInactive\n\tstateReady\n\n\t// states necessary for restarting workers\n\tstateRestarting\n\tstateYielding\n\n\t// states necessary for transitioning between different handlers\n\tstateTransitionRequested\n\tstateTransitionInProgress\n\tstateTransitionComplete\n)\n\ntype threadState struct {\n\tcurrentState stateID\n\tmu           sync.RWMutex\n\tsubscribers  []stateSubscriber\n}\n\ntype stateSubscriber struct {\n\tstates []stateID\n\tch     chan struct{}\n}\n\nfunc newThreadState() *threadState {\n\treturn &threadState{\n\t\tcurrentState: stateBooting,\n\t\tsubscribers:  []stateSubscriber{},\n\t\tmu:           sync.RWMutex{},\n\t}\n}\n\nfunc (ts *threadState) is(state stateID) bool {\n\tts.mu.RLock()\n\tok := ts.currentState == state\n\tts.mu.RUnlock()\n\n\treturn ok\n}\n\nfunc (ts *threadState) compareAndSwap(compareTo stateID, swapTo stateID) bool {\n\tts.mu.Lock()\n\tok := ts.currentState == compareTo\n\tif ok {\n\t\tts.currentState = swapTo\n\t\tts.notifySubscribers(swapTo)\n\t}\n\tts.mu.Unlock()\n\n\treturn ok\n}\n\nfunc (ts *threadState) name() string {\n\t// TODO: return the actual name for logging/metrics\n\treturn \"state:\" + strconv.Itoa(int(ts.get()))\n}\n\nfunc (ts *threadState) get() stateID {\n\tts.mu.RLock()\n\tid := ts.currentState\n\tts.mu.RUnlock()\n\n\treturn id\n}\n\nfunc (ts *threadState) set(nextState stateID) {\n\tts.mu.Lock()\n\tts.currentState = nextState\n\tts.notifySubscribers(nextState)\n\tts.mu.Unlock()\n}\n\nfunc (ts *threadState) notifySubscribers(nextState stateID) {\n\tif len(ts.subscribers) == 0 {\n\t\treturn\n\t}\n\tnewSubscribers := []stateSubscriber{}\n\t// notify subscribers to the state change\n\tfor _, sub := range ts.subscribers {\n\t\tif !slices.Contains(sub.states, nextState) {\n\t\t\tnewSubscribers = append(newSubscribers, sub)\n\t\t\tcontinue\n\t\t}\n\t\tclose(sub.ch)\n\t}\n\tts.subscribers = newSubscribers\n}\n\n// block until the thread reaches a certain state\nfunc (ts *threadState) waitFor(states ...stateID) {\n\tts.mu.Lock()\n\tif slices.Contains(states, ts.currentState) {\n\t\tts.mu.Unlock()\n\t\treturn\n\t}\n\tsub := stateSubscriber{\n\t\tstates: states,\n\t\tch:     make(chan struct{}),\n\t}\n\tts.subscribers = append(ts.subscribers, sub)\n\tts.mu.Unlock()\n\t<-sub.ch\n}\n\n// safely request a state change from a different goroutine\nfunc (ts *threadState) requestSafeStateChange(nextState stateID) bool {\n\tts.mu.Lock()\n\tswitch ts.currentState {\n\t// disallow state changes if shutting down\n\tcase stateShuttingDown, stateDone:\n\t\tts.mu.Unlock()\n\t\treturn false\n\t// ready and inactive are safe states to transition from\n\tcase stateReady, stateInactive:\n\t\tts.currentState = nextState\n\t\tts.notifySubscribers(nextState)\n\t\tts.mu.Unlock()\n\t\treturn true\n\t}\n\tts.mu.Unlock()\n\n\t// wait for the state to change to a safe state\n\tts.waitFor(stateReady, stateInactive, stateShuttingDown)\n\treturn ts.requestSafeStateChange(nextState)\n}\n"
        },
        {
          "name": "state_test.go",
          "type": "blob",
          "size": 1.4365234375,
          "content": "package frankenphp\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test2GoroutinesYieldToEachOtherViaStates(t *testing.T) {\n\tthreadState := &threadState{currentState: stateBooting}\n\n\tgo func() {\n\t\tthreadState.waitFor(stateInactive)\n\t\tassert.True(t, threadState.is(stateInactive))\n\t\tthreadState.set(stateReady)\n\t}()\n\n\tthreadState.set(stateInactive)\n\tthreadState.waitFor(stateReady)\n\tassert.True(t, threadState.is(stateReady))\n}\n\nfunc TestStateShouldHaveCorrectAmountOfSubscribers(t *testing.T) {\n\tthreadState := &threadState{currentState: stateBooting}\n\n\t// 3 subscribers waiting for different states\n\tgo threadState.waitFor(stateInactive)\n\tgo threadState.waitFor(stateInactive, stateShuttingDown)\n\tgo threadState.waitFor(stateShuttingDown)\n\n\tassertNumberOfSubscribers(t, threadState, 3)\n\n\tthreadState.set(stateInactive)\n\tassertNumberOfSubscribers(t, threadState, 1)\n\n\tassert.True(t, threadState.compareAndSwap(stateInactive, stateShuttingDown))\n\tassertNumberOfSubscribers(t, threadState, 0)\n}\n\nfunc assertNumberOfSubscribers(t *testing.T, threadState *threadState, expected int) {\n\tmaxWaits := 10_000 // wait for 1 second max\n\n\tfor i := 0; i < maxWaits; i++ {\n\t\ttime.Sleep(100 * time.Microsecond)\n\t\tthreadState.mu.RLock()\n\t\tif len(threadState.subscribers) == expected {\n\t\t\tthreadState.mu.RUnlock()\n\t\t\tbreak\n\t\t}\n\t\tthreadState.mu.RUnlock()\n\t}\n\tthreadState.mu.RLock()\n\tassert.Len(t, threadState.subscribers, expected)\n\tthreadState.mu.RUnlock()\n}\n"
        },
        {
          "name": "static-builder.Dockerfile",
          "type": "blob",
          "size": 2.6220703125,
          "content": "# syntax=docker/dockerfile:1\n#checkov:skip=CKV_DOCKER_2\n#checkov:skip=CKV_DOCKER_3\n#checkov:skip=CKV_DOCKER_7\nFROM golang-base\n\nARG TARGETARCH\n\nARG FRANKENPHP_VERSION=''\nENV FRANKENPHP_VERSION=${FRANKENPHP_VERSION}\n\nARG PHP_VERSION=''\nENV PHP_VERSION=${PHP_VERSION}\n\nARG PHP_EXTENSIONS=''\nARG PHP_EXTENSION_LIBS=''\nARG XCADDY_ARGS=''\nARG CLEAN=''\nARG EMBED=''\nARG DEBUG_SYMBOLS=''\nARG MIMALLOC=''\nARG NO_COMPRESS=''\n\nSHELL [\"/bin/ash\", \"-eo\", \"pipefail\", \"-c\"]\n\nLABEL org.opencontainers.image.title=FrankenPHP\nLABEL org.opencontainers.image.description=\"The modern PHP app server\"\nLABEL org.opencontainers.image.url=https://frankenphp.dev\nLABEL org.opencontainers.image.source=https://github.com/dunglas/frankenphp\nLABEL org.opencontainers.image.licenses=MIT\nLABEL org.opencontainers.image.vendor=\"KÃ©vin Dunglas\"\n\nRUN apk update; \\\n\tapk add --no-cache \\\n\t\talpine-sdk \\\n\t\tautoconf \\\n\t\tautomake \\\n\t\tbash \\\n\t\tbinutils \\\n\t\tbison \\\n\t\tbuild-base \\\n\t\tcmake \\\n\t\tcurl \\\n\t\tfile \\\n\t\tflex \\\n\t\tg++ \\\n\t\tgcc \\\n\t\tgit \\\n\t\tjq \\\n\t\tlibgcc \\\n\t\tlibstdc++ \\\n\t\tlibtool \\\n\t\tlinux-headers \\\n\t\tm4 \\\n\t\tmake \\\n\t\tpkgconfig \\\n\t\tphp83 \\\n\t\tphp83-common \\\n\t\tphp83-ctype \\\n\t\tphp83-curl \\\n\t\tphp83-dom \\\n\t\tphp83-mbstring \\\n\t\tphp83-openssl \\\n\t\tphp83-pcntl \\\n\t\tphp83-phar \\\n\t\tphp83-posix \\\n\t\tphp83-session \\\n\t\tphp83-sodium \\\n\t\tphp83-tokenizer \\\n\t\tphp83-xml \\\n\t\tphp83-xmlwriter \\\n\t\tupx \\\n\t\twget \\\n\t\txz ; \\\n\tln -sf /usr/bin/php83 /usr/bin/php\n\n# FIXME: temporary workaround for https://github.com/golang/go/issues/68285\nWORKDIR /\nRUN git clone https://go.googlesource.com/go goroot\nWORKDIR /goroot\n# Revert https://github.com/golang/go/commit/3560cf0afb3c29300a6c88ccd98256949ca7a6f6 to prevent the crash with musl\nRUN git config --global user.email \"build@example.com\" && \\\n\tgit config --global user.name \"Build\" && \\\n\tgit checkout \"$(go env GOVERSION)\" && \\\n\tgit revert 3560cf0afb3c29300a6c88ccd98256949ca7a6f6\nWORKDIR /goroot/src\nENV GOHOSTARCH=\"$TARGETARCH\"\nRUN ./make.bash\nENV PATH=\"/goroot/bin:$PATH\"\nRUN go version && \\\n\tgo install github.com/caddyserver/xcaddy/cmd/xcaddy@latest\n\n# https://getcomposer.org/doc/03-cli.md#composer-allow-superuser\nENV COMPOSER_ALLOW_SUPERUSER=1\nCOPY --from=composer/composer:2-bin /composer /usr/bin/composer\n\nWORKDIR /go/src/app\nCOPY go.mod go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app/caddy\nCOPY caddy/go.mod caddy/go.sum ./\nRUN go mod graph | awk '{if ($1 !~ \"@\") print $2}' | xargs go get\n\nWORKDIR /go/src/app\nCOPY --link *.* ./\nCOPY --link caddy caddy\nCOPY --link internal internal\n\nRUN --mount=type=secret,id=github-token GITHUB_TOKEN=$(cat /run/secrets/github-token) ./build-static.sh && \\\n\trm -Rf dist/static-php-cli/source/*\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "thread-inactive.go",
          "type": "blob",
          "size": 1.1474609375,
          "content": "package frankenphp\n\nimport (\n\t\"net/http\"\n)\n\n// representation of a thread with no work assigned to it\n// implements the threadHandler interface\ntype inactiveThread struct {\n\tthread *phpThread\n}\n\nfunc convertToInactiveThread(thread *phpThread) {\n\tif thread.handler == nil {\n\t\tthread.handler = &inactiveThread{thread: thread}\n\t\treturn\n\t}\n\tthread.setHandler(&inactiveThread{thread: thread})\n}\n\nfunc (handler *inactiveThread) beforeScriptExecution() string {\n\tthread := handler.thread\n\n\tswitch thread.state.get() {\n\tcase stateTransitionRequested:\n\t\treturn thread.transitionToNewHandler()\n\tcase stateBooting, stateTransitionComplete:\n\t\tthread.state.set(stateInactive)\n\t\t// wait for external signal to start or shut down\n\t\tthread.state.waitFor(stateTransitionRequested, stateShuttingDown)\n\t\treturn handler.beforeScriptExecution()\n\tcase stateShuttingDown:\n\t\t// signal to stop\n\t\treturn \"\"\n\t}\n\tpanic(\"unexpected state: \" + thread.state.name())\n}\n\nfunc (thread *inactiveThread) afterScriptExecution(exitStatus int) {\n\tpanic(\"inactive threads should not execute scripts\")\n}\n\nfunc (thread *inactiveThread) getActiveRequest() *http.Request {\n\tpanic(\"inactive threads have no requests\")\n}\n"
        },
        {
          "name": "thread-regular.go",
          "type": "blob",
          "size": 2.029296875,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"net/http\"\n)\n\n// representation of a non-worker PHP thread\n// executes PHP scripts in a web context\n// implements the threadHandler interface\ntype regularThread struct {\n\tstate         *threadState\n\tthread        *phpThread\n\tactiveRequest *http.Request\n}\n\nfunc convertToRegularThread(thread *phpThread) {\n\tthread.setHandler(&regularThread{\n\t\tthread: thread,\n\t\tstate:  thread.state,\n\t})\n}\n\n// beforeScriptExecution returns the name of the script or an empty string on shutdown\nfunc (handler *regularThread) beforeScriptExecution() string {\n\tswitch handler.state.get() {\n\tcase stateTransitionRequested:\n\t\treturn handler.thread.transitionToNewHandler()\n\tcase stateTransitionComplete:\n\t\thandler.state.set(stateReady)\n\t\treturn handler.waitForRequest()\n\tcase stateReady:\n\t\treturn handler.waitForRequest()\n\tcase stateShuttingDown:\n\t\t// signal to stop\n\t\treturn \"\"\n\t}\n\tpanic(\"unexpected state: \" + handler.state.name())\n}\n\n// return true if the worker should continue to run\nfunc (handler *regularThread) afterScriptExecution(exitStatus int) {\n\thandler.afterRequest(exitStatus)\n}\n\nfunc (handler *regularThread) getActiveRequest() *http.Request {\n\treturn handler.activeRequest\n}\n\nfunc (handler *regularThread) waitForRequest() string {\n\tselect {\n\tcase <-handler.thread.drainChan:\n\t\t// go back to beforeScriptExecution\n\t\treturn handler.beforeScriptExecution()\n\n\tcase r := <-requestChan:\n\t\thandler.activeRequest = r\n\t\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\n\t\tif err := updateServerContext(handler.thread, r, true, false); err != nil {\n\t\t\trejectRequest(fc.responseWriter, err.Error())\n\t\t\thandler.afterRequest(0)\n\t\t\t// go back to beforeScriptExecution\n\t\t\treturn handler.beforeScriptExecution()\n\t\t}\n\n\t\t// set the scriptFilename that should be executed\n\t\treturn fc.scriptFilename\n\t}\n}\n\nfunc (handler *regularThread) afterRequest(exitStatus int) {\n\tfc := handler.activeRequest.Context().Value(contextKey).(*FrankenPHPContext)\n\tfc.exitStatus = exitStatus\n\tmaybeCloseContext(fc)\n\thandler.activeRequest = nil\n}\n"
        },
        {
          "name": "thread-worker.go",
          "type": "blob",
          "size": 6.5908203125,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// representation of a thread assigned to a worker script\n// executes the PHP worker script in a loop\n// implements the threadHandler interface\ntype workerThread struct {\n\tstate         *threadState\n\tthread        *phpThread\n\tworker        *worker\n\tfakeRequest   *http.Request\n\tworkerRequest *http.Request\n\tbackoff       *exponentialBackoff\n}\n\nfunc convertToWorkerThread(thread *phpThread, worker *worker) {\n\tthread.setHandler(&workerThread{\n\t\tstate:  thread.state,\n\t\tthread: thread,\n\t\tworker: worker,\n\t\tbackoff: &exponentialBackoff{\n\t\t\tmaxBackoff:             1 * time.Second,\n\t\t\tminBackoff:             100 * time.Millisecond,\n\t\t\tmaxConsecutiveFailures: 6,\n\t\t},\n\t})\n\tworker.attachThread(thread)\n}\n\n// beforeScriptExecution returns the name of the script or an empty string on shutdown\nfunc (handler *workerThread) beforeScriptExecution() string {\n\tswitch handler.state.get() {\n\tcase stateTransitionRequested:\n\t\thandler.worker.detachThread(handler.thread)\n\t\treturn handler.thread.transitionToNewHandler()\n\tcase stateRestarting:\n\t\thandler.state.set(stateYielding)\n\t\thandler.state.waitFor(stateReady, stateShuttingDown)\n\t\treturn handler.beforeScriptExecution()\n\tcase stateReady, stateTransitionComplete:\n\t\tsetupWorkerScript(handler, handler.worker)\n\t\treturn handler.worker.fileName\n\tcase stateShuttingDown:\n\t\t// signal to stop\n\t\treturn \"\"\n\t}\n\tpanic(\"unexpected state: \" + handler.state.name())\n}\n\nfunc (handler *workerThread) afterScriptExecution(exitStatus int) {\n\ttearDownWorkerScript(handler, exitStatus)\n}\n\nfunc (handler *workerThread) getActiveRequest() *http.Request {\n\tif handler.workerRequest != nil {\n\t\treturn handler.workerRequest\n\t}\n\n\treturn handler.fakeRequest\n}\n\nfunc setupWorkerScript(handler *workerThread, worker *worker) {\n\thandler.backoff.wait()\n\tmetrics.StartWorker(worker.fileName)\n\n\t// Create a dummy request to set up the worker\n\tr, err := http.NewRequest(http.MethodGet, filepath.Base(worker.fileName), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tr, err = NewRequestWithContext(\n\t\tr,\n\t\tWithRequestDocumentRoot(filepath.Dir(worker.fileName), false),\n\t\tWithRequestPreparedEnv(worker.env),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := updateServerContext(handler.thread, r, true, false); err != nil {\n\t\tpanic(err)\n\t}\n\n\thandler.fakeRequest = r\n\tif c := logger.Check(zapcore.DebugLevel, \"starting\"); c != nil {\n\t\tc.Write(zap.String(\"worker\", worker.fileName), zap.Int(\"thread\", handler.thread.threadIndex))\n\t}\n}\n\nfunc tearDownWorkerScript(handler *workerThread, exitStatus int) {\n\t// if the worker request is not nil, the script might have crashed\n\t// make sure to close the worker request context\n\tif handler.workerRequest != nil {\n\t\tfc := handler.workerRequest.Context().Value(contextKey).(*FrankenPHPContext)\n\t\tmaybeCloseContext(fc)\n\t\thandler.workerRequest = nil\n\t}\n\n\tfc := handler.fakeRequest.Context().Value(contextKey).(*FrankenPHPContext)\n\tfc.exitStatus = exitStatus\n\n\tdefer func() {\n\t\thandler.fakeRequest = nil\n\t}()\n\n\t// on exit status 0 we just run the worker script again\n\tworker := handler.worker\n\tif fc.exitStatus == 0 {\n\t\t// TODO: make the max restart configurable\n\t\tmetrics.StopWorker(worker.fileName, StopReasonRestart)\n\t\thandler.backoff.recordSuccess()\n\t\tif c := logger.Check(zapcore.DebugLevel, \"restarting\"); c != nil {\n\t\t\tc.Write(zap.String(\"worker\", worker.fileName))\n\t\t}\n\t\treturn\n\t}\n\n\t// TODO: error status\n\n\t// on exit status 1 we apply an exponential backoff when restarting\n\tmetrics.StopWorker(worker.fileName, StopReasonCrash)\n\tif handler.backoff.recordFailure() {\n\t\tif !watcherIsEnabled {\n\t\t\tlogger.Panic(\"too many consecutive worker failures\", zap.String(\"worker\", worker.fileName), zap.Int(\"failures\", handler.backoff.failureCount))\n\t\t}\n\t\tlogger.Warn(\"many consecutive worker failures\", zap.String(\"worker\", worker.fileName), zap.Int(\"failures\", handler.backoff.failureCount))\n\t}\n}\n\nfunc (handler *workerThread) waitForWorkerRequest() bool {\n\t// unpin any memory left over from previous requests\n\thandler.thread.Unpin()\n\n\tif c := logger.Check(zapcore.DebugLevel, \"waiting for request\"); c != nil {\n\t\tc.Write(zap.String(\"worker\", handler.worker.fileName))\n\t}\n\n\tif handler.state.compareAndSwap(stateTransitionComplete, stateReady) {\n\t\tmetrics.ReadyWorker(handler.worker.fileName)\n\t}\n\n\tvar r *http.Request\n\tselect {\n\tcase <-handler.thread.drainChan:\n\t\tif c := logger.Check(zapcore.DebugLevel, \"shutting down\"); c != nil {\n\t\t\tc.Write(zap.String(\"worker\", handler.worker.fileName))\n\t\t}\n\n\t\t// execute opcache_reset if the restart was triggered by the watcher\n\t\tif watcherIsEnabled && handler.state.is(stateRestarting) {\n\t\t\tC.frankenphp_reset_opcache()\n\t\t}\n\n\t\treturn false\n\tcase r = <-handler.thread.requestChan:\n\tcase r = <-handler.worker.requestChan:\n\t}\n\n\thandler.workerRequest = r\n\n\tif c := logger.Check(zapcore.DebugLevel, \"request handling started\"); c != nil {\n\t\tc.Write(zap.String(\"worker\", handler.worker.fileName), zap.String(\"url\", r.RequestURI))\n\t}\n\n\tif err := updateServerContext(handler.thread, r, false, true); err != nil {\n\t\t// Unexpected error or invalid request\n\t\tif c := logger.Check(zapcore.DebugLevel, \"unexpected error\"); c != nil {\n\t\t\tc.Write(zap.String(\"worker\", handler.worker.fileName), zap.String(\"url\", r.RequestURI), zap.Error(err))\n\t\t}\n\t\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\t\trejectRequest(fc.responseWriter, err.Error())\n\t\tmaybeCloseContext(fc)\n\t\thandler.workerRequest = nil\n\n\t\treturn handler.waitForWorkerRequest()\n\t}\n\treturn true\n}\n\n//export go_frankenphp_worker_handle_request_start\nfunc go_frankenphp_worker_handle_request_start(threadIndex C.uintptr_t) C.bool {\n\thandler := phpThreads[threadIndex].handler.(*workerThread)\n\treturn C.bool(handler.waitForWorkerRequest())\n}\n\n//export go_frankenphp_finish_worker_request\nfunc go_frankenphp_finish_worker_request(threadIndex C.uintptr_t) {\n\tthread := phpThreads[threadIndex]\n\tr := thread.getActiveRequest()\n\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\n\tmaybeCloseContext(fc)\n\tthread.handler.(*workerThread).workerRequest = nil\n\n\tif c := fc.logger.Check(zapcore.DebugLevel, \"request handling finished\"); c != nil {\n\t\tc.Write(zap.String(\"worker\", fc.scriptFilename), zap.String(\"url\", r.RequestURI))\n\t}\n}\n\n// when frankenphp_finish_request() is directly called from PHP\n//\n//export go_frankenphp_finish_php_request\nfunc go_frankenphp_finish_php_request(threadIndex C.uintptr_t) {\n\tr := phpThreads[threadIndex].getActiveRequest()\n\tfc := r.Context().Value(contextKey).(*FrankenPHPContext)\n\tmaybeCloseContext(fc)\n\n\tif c := fc.logger.Check(zapcore.DebugLevel, \"request handling finished\"); c != nil {\n\t\tc.Write(zap.String(\"url\", r.RequestURI))\n\t}\n}\n"
        },
        {
          "name": "watcher_test.go",
          "type": "blob",
          "size": 2.6142578125,
          "content": "//go:build !nowatcher\n\npackage frankenphp_test\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// we have to wait a few milliseconds for the watcher debounce to take effect\nconst pollingTime = 250\n\n// in tests checking for no reload: we will poll 3x250ms = 0.75s\nconst minTimesToPollForChanges = 3\n\n// in tests checking for a reload: we will poll a maximum of 60x250ms = 15s\nconst maxTimesToPollForChanges = 60\n\nfunc TestWorkersShouldReloadOnMatchingPattern(t *testing.T) {\n\twatch := []string{\"./testdata/**/*.txt\"}\n\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\trequestBodyHasReset := pollForWorkerReset(t, handler, maxTimesToPollForChanges)\n\t\tassert.True(t, requestBodyHasReset)\n\t}, &testOptions{nbParrallelRequests: 1, nbWorkers: 1, workerScript: \"worker-with-watcher.php\", watch: watch})\n}\n\nfunc TestWorkersShouldNotReloadOnExcludingPattern(t *testing.T) {\n\twatch := []string{\"./testdata/**/*.php\"}\n\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\trequestBodyHasReset := pollForWorkerReset(t, handler, minTimesToPollForChanges)\n\t\tassert.False(t, requestBodyHasReset)\n\t}, &testOptions{nbParrallelRequests: 1, nbWorkers: 1, workerScript: \"worker-with-watcher.php\", watch: watch})\n}\n\nfunc fetchBody(method string, url string, handler func(http.ResponseWriter, *http.Request)) string {\n\treq := httptest.NewRequest(method, url, nil)\n\tw := httptest.NewRecorder()\n\thandler(w, req)\n\tresp := w.Result()\n\tbody, _ := io.ReadAll(resp.Body)\n\n\treturn string(body)\n}\n\nfunc pollForWorkerReset(t *testing.T, handler func(http.ResponseWriter, *http.Request), limit int) bool {\n\t// first we make an initial request to start the request counter\n\tbody := fetchBody(\"GET\", \"http://example.com/worker-with-watcher.php\", handler)\n\tassert.Equal(t, \"requests:1\", body)\n\n\t// now we spam file updates and check if the request counter resets\n\tfor i := 0; i < limit; i++ {\n\t\tupdateTestFile(\"./testdata/files/test.txt\", \"updated\", t)\n\t\ttime.Sleep(pollingTime * time.Millisecond)\n\t\tbody := fetchBody(\"GET\", \"http://example.com/worker-with-watcher.php\", handler)\n\t\tif body == \"requests:1\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc updateTestFile(fileName string, content string, t *testing.T) {\n\tabsFileName, err := filepath.Abs(fileName)\n\tassert.NoError(t, err)\n\tdirName := filepath.Dir(absFileName)\n\tif _, err := os.Stat(dirName); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(dirName, 0700)\n\t\tassert.NoError(t, err)\n\t}\n\tbytes := []byte(content)\n\terr = os.WriteFile(absFileName, bytes, 0644)\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "worker.go",
          "type": "blob",
          "size": 3.7841796875,
          "content": "package frankenphp\n\n// #include \"frankenphp.h\"\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"github.com/dunglas/frankenphp/internal/fastabs\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/dunglas/frankenphp/internal/watcher\"\n)\n\n// represents a worker script and can have many threads assigned to it\ntype worker struct {\n\tfileName    string\n\tnum         int\n\tenv         PreparedEnv\n\trequestChan chan *http.Request\n\tthreads     []*phpThread\n\tthreadMutex sync.RWMutex\n}\n\nvar (\n\tworkers          map[string]*worker\n\twatcherIsEnabled bool\n)\n\nfunc initWorkers(opt []workerOpt) error {\n\tworkers = make(map[string]*worker, len(opt))\n\tworkersReady := sync.WaitGroup{}\n\tdirectoriesToWatch := getDirectoriesToWatch(opt)\n\twatcherIsEnabled = len(directoriesToWatch) > 0\n\n\tfor _, o := range opt {\n\t\tworker, err := newWorker(o)\n\t\tworker.threads = make([]*phpThread, 0, o.num)\n\t\tworkersReady.Add(o.num)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < worker.num; i++ {\n\t\t\tthread := getInactivePHPThread()\n\t\t\tconvertToWorkerThread(thread, worker)\n\t\t\tgo func() {\n\t\t\t\tthread.state.waitFor(stateReady)\n\t\t\t\tworkersReady.Done()\n\t\t\t}()\n\t\t}\n\t}\n\n\tworkersReady.Wait()\n\n\tif !watcherIsEnabled {\n\t\treturn nil\n\t}\n\n\tif err := watcher.InitWatcher(directoriesToWatch, restartWorkers, getLogger()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc newWorker(o workerOpt) (*worker, error) {\n\tabsFileName, err := fastabs.FastAbs(o.fileName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"worker filename is invalid %q: %w\", o.fileName, err)\n\t}\n\n\tif o.env == nil {\n\t\to.env = make(PreparedEnv, 1)\n\t}\n\n\to.env[\"FRANKENPHP_WORKER\\x00\"] = \"1\"\n\tw := &worker{\n\t\tfileName:    absFileName,\n\t\tnum:         o.num,\n\t\tenv:         o.env,\n\t\trequestChan: make(chan *http.Request),\n\t}\n\tworkers[absFileName] = w\n\n\treturn w, nil\n}\n\nfunc drainWorkers() {\n\twatcher.DrainWatcher()\n}\n\nfunc restartWorkers() {\n\tready := sync.WaitGroup{}\n\tthreadsToRestart := make([]*phpThread, 0)\n\tfor _, worker := range workers {\n\t\tworker.threadMutex.RLock()\n\t\tready.Add(len(worker.threads))\n\t\tfor _, thread := range worker.threads {\n\t\t\tif !thread.state.requestSafeStateChange(stateRestarting) {\n\t\t\t\t// no state change allowed = shutdown\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tclose(thread.drainChan)\n\t\t\tthreadsToRestart = append(threadsToRestart, thread)\n\t\t\tgo func(thread *phpThread) {\n\t\t\t\tthread.state.waitFor(stateYielding)\n\t\t\t\tready.Done()\n\t\t\t}(thread)\n\t\t}\n\t\tworker.threadMutex.RUnlock()\n\t}\n\n\tready.Wait()\n\n\tfor _, thread := range threadsToRestart {\n\t\tthread.drainChan = make(chan struct{})\n\t\tthread.state.set(stateReady)\n\t}\n}\n\nfunc getDirectoriesToWatch(workerOpts []workerOpt) []string {\n\tdirectoriesToWatch := []string{}\n\tfor _, w := range workerOpts {\n\t\tdirectoriesToWatch = append(directoriesToWatch, w.watch...)\n\t}\n\treturn directoriesToWatch\n}\n\nfunc (worker *worker) attachThread(thread *phpThread) {\n\tworker.threadMutex.Lock()\n\tworker.threads = append(worker.threads, thread)\n\tworker.threadMutex.Unlock()\n}\n\nfunc (worker *worker) detachThread(thread *phpThread) {\n\tworker.threadMutex.Lock()\n\tfor i, t := range worker.threads {\n\t\tif t == thread {\n\t\t\tworker.threads = append(worker.threads[:i], worker.threads[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tworker.threadMutex.Unlock()\n}\n\nfunc (worker *worker) handleRequest(r *http.Request, fc *FrankenPHPContext) {\n\tmetrics.StartWorkerRequest(fc.scriptFilename)\n\n\t// dispatch requests to all worker threads in order\n\tworker.threadMutex.RLock()\n\tfor _, thread := range worker.threads {\n\t\tselect {\n\t\tcase thread.requestChan <- r:\n\t\t\tworker.threadMutex.RUnlock()\n\t\t\t<-fc.done\n\t\t\tmetrics.StopWorkerRequest(worker.fileName, time.Since(fc.startedAt))\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t}\n\tworker.threadMutex.RUnlock()\n\n\t// if no thread was available, fan the request out to all threads\n\t// TODO: theoretically there could be autoscaling of threads here\n\tworker.requestChan <- r\n\t<-fc.done\n\tmetrics.StopWorkerRequest(worker.fileName, time.Since(fc.startedAt))\n}\n"
        },
        {
          "name": "worker_test.go",
          "type": "blob",
          "size": 5.2236328125,
          "content": "package frankenphp_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/dunglas/frankenphp\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\nfunc TestWorker(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\tformData := url.Values{\"baz\": {\"bat\"}}\n\t\treq := httptest.NewRequest(\"POST\", \"http://example.com/worker.php?foo=bar\", strings.NewReader(formData.Encode()))\n\t\treq.Header.Set(\"Content-Type\", strings.Clone(\"application/x-www-form-urlencoded\"))\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"Requests handled: %d\", i*2))\n\n\t\tformData2 := url.Values{\"baz2\": {\"bat2\"}}\n\t\treq2 := httptest.NewRequest(\"POST\", \"http://example.com/worker.php?foo2=bar2\", strings.NewReader(formData2.Encode()))\n\t\treq2.Header.Set(\"Content-Type\", strings.Clone(\"application/x-www-form-urlencoded\"))\n\n\t\tw2 := httptest.NewRecorder()\n\t\thandler(w2, req2)\n\n\t\tresp2 := w2.Result()\n\t\tbody2, _ := io.ReadAll(resp2.Body)\n\n\t\tassert.Contains(t, string(body2), fmt.Sprintf(\"Requests handled: %d\", i*2+1))\n\t}, &testOptions{workerScript: \"worker.php\", nbWorkers: 1, nbParrallelRequests: 1})\n}\n\nfunc TestWorkerDie(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/die.php\", nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\t}, &testOptions{workerScript: \"die.php\", nbWorkers: 1, nbParrallelRequests: 10})\n}\n\nfunc TestNonWorkerModeAlwaysWorks(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/index.php\", nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"I am by birth a Genevese\")\n\t}, &testOptions{workerScript: \"phpinfo.php\"})\n}\n\nfunc TestCannotCallHandleRequestInNonWorkerMode(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/non-worker.php\", nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"<b>Fatal error</b>:  Uncaught RuntimeException: frankenphp_handle_request() called while not in worker mode\")\n\t}, nil)\n}\n\nfunc TestWorkerEnv(t *testing.T) {\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/worker-env.php?i=%d\", i), nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Equal(t, fmt.Sprintf(\"bar%d\", i), string(body))\n\t}, &testOptions{workerScript: \"worker-env.php\", nbWorkers: 1, env: map[string]string{\"FOO\": \"bar\"}, nbParrallelRequests: 10})\n}\n\nfunc TestWorkerGetOpt(t *testing.T) {\n\tobs, logs := observer.New(zapcore.InfoLevel)\n\tlogger := zap.New(obs)\n\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", fmt.Sprintf(\"http://example.com/worker-getopt.php?i=%d\", i), nil)\n\t\treq.Header.Add(\"Request\", strconv.Itoa(i))\n\t\tw := httptest.NewRecorder()\n\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[HTTP_REQUEST] => %d\", i))\n\t\tassert.Contains(t, string(body), fmt.Sprintf(\"[REQUEST_URI] => /worker-getopt.php?i=%d\", i))\n\t}, &testOptions{logger: logger, workerScript: \"worker-getopt.php\", env: map[string]string{\"FOO\": \"bar\"}})\n\n\tfor _, l := range logs.FilterFieldKey(\"exit_status\").All() {\n\t\tassert.Failf(t, \"unexpected exit status\", \"exit status: %d\", l.ContextMap()[\"exit_status\"])\n\t}\n}\n\nfunc ExampleServeHTTP_workers() {\n\tif err := frankenphp.Init(\n\t\tfrankenphp.WithWorkers(\"worker1.php\", 4, map[string]string{\"ENV1\": \"foo\"}, []string{}),\n\t\tfrankenphp.WithWorkers(\"worker2.php\", 2, map[string]string{\"ENV2\": \"bar\"}, []string{}),\n\t); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer frankenphp.Shutdown()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\treq, err := frankenphp.NewRequestWithContext(r, frankenphp.WithRequestDocumentRoot(\"/path/to/document/root\", false))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif err := frankenphp.ServeHTTP(w, req); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc TestWorkerHasOSEnvironmentVariableInSERVER(t *testing.T) {\n\tos.Setenv(\"CUSTOM_OS_ENV_VARIABLE\", \"custom_env_variable_value\")\n\trunTest(t, func(handler func(http.ResponseWriter, *http.Request), _ *httptest.Server, i int) {\n\t\treq := httptest.NewRequest(\"GET\", \"http://example.com/worker.php\", nil)\n\t\tw := httptest.NewRecorder()\n\t\thandler(w, req)\n\n\t\tresp := w.Result()\n\t\tbody, _ := io.ReadAll(resp.Body)\n\n\t\tassert.Contains(t, string(body), \"CUSTOM_OS_ENV_VARIABLE\")\n\t\tassert.Contains(t, string(body), \"custom_env_variable_value\")\n\t}, &testOptions{workerScript: \"worker.php\", nbWorkers: 1, nbParrallelRequests: 1})\n}\n"
        }
      ]
    }
  ]
}