{
  "metadata": {
    "timestamp": 1736567834577,
    "page": 416,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "schollz/find",
      "stars": 5051,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0556640625,
          "content": "static/* linguist-vendored\r\ntesting/* linguist-vendored\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.96484375,
          "content": "# Byte-compiled / optimized / DLL files\nvenv/\ndata/floorplans/\ntilestache/baselayers/temp/\ndata/production/\ndata/analysis/\ndata/images/\ndocumentation/site\nfind\nfindserver\n\n__pycache__/\nwww/sphinx-api/_build/\nwww/sphinx/_build/\nwww/stats/\nwww/stats2/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n*.log\nnohup.out\n\n# Databases\n*.db.*\n*.db\ndata/*\n\n# Data\n*.p\n\n# Temp files\n*~\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.025390625,
          "content": "language: go\n\ngo:\n  - tip\n"
        },
        {
          "name": "BENCHMARKS.md",
          "type": "blob",
          "size": 6.373046875,
          "content": "# Benchmarks 05/07/2016\n\nCurrent coverage (`go test -cover`): 34.1%.\n\nTo test first start process on one terminal `./gofind`, and then in another window `./testing/testdb.sh`. Then you can close `./gofind` and run with `go test -bench=. -test.benchmem`.\n\n### i7-3370 @ 3.4GHz\n\n2,058 fingerprints\n```\nBenchmarkTrackFingerprintRoute-8             100          15239873 ns/op         1520979 B/op        386 allocs/op\nBenchmarkLearnFingerprintRoute-8             100          14811166 ns/op         1523019 B/op        337 allocs/op\nBenchmarkPutFingerprintInDatabase-8          100          18666458 ns/op         1498315 B/op        237 allocs/op\nBenchmarkGetFingerprintInDatabase-8         1000           2126121 ns/op           53762 B/op         97 allocs/op\nBenchmarkLoadFingerprint-8                100000             15466 ns/op            2457 B/op         32 allocs/op\nBenchmarkLoadCompressedFingerprint-8       30000             80320 ns/op           44846 B/op         40 allocs/op\nBenchmarkDumpFingerprint-8                200000             11307 ns/op            2372 B/op         44 allocs/op\nBenchmarkDumpCompressedFingerprint-8         500           3260405 ns/op         1463900 B/op        127 allocs/op\nBenchmarkLoadParameters-8                    100          22610022 ns/op         2662599 B/op       3769 allocs/op\nBenchmarkGetParameters-8                     100          14269609 ns/op          952125 B/op       5592 allocs/op\nBenchmarkCalculatePosteriors1-8            30000             49136 ns/op            2712 B/op         12 allocs/op\nBenchmarkOptimizePriors-8                      3         364207766 ns/op        33952237 B/op      57270 allocs/op\nBenchmarkOptimizePriorsThreaded-8              5         234406160 ns/op        32756854 B/op      60000 allocs/op\nBenchmarkOptimizePriorsThreadedNot-8           5         248316460 ns/op        32395744 B/op      51277 allocs/op\nBenchmarkCrossValidation-8                   100          26085247 ns/op         1025146 B/op       4295 allocs/op\nBenchmarkCalculatePriors-8                   100          14561229 ns/op          482638 B/op       1405 allocs/op\n```\n\n# Benchmarks 05/01/2016\n\nCurrent coverage (`go test -cover`): 34.1%.\n\nTo test first start process on one terminal `./gofind`, and then in another window `./testing/testdb.sh`. Then you can close `./gofind` and run with `go test -bench=. -test.benchmem`.\n\n### i7-3370 @ 3.4GHz\n\n2,058 fingerprints\n```\nBenchmarkPutFingerprintInDatabase-8          100          18653644 ns/op         1498396 B/op        237 allocs/op\nBenchmarkGetFingerprintInDatabase-8          500           3347812 ns/op           52653 B/op         91 allocs/op\nBenchmarkLoadFingerprint-8                100000             12204 ns/op            2457 B/op         32 allocs/op\nBenchmarkLoadCompressedFingerprint-8       30000             55108 ns/op           44846 B/op         40 allocs/op\nBenchmarkDumpFingerprint-8                200000              8032 ns/op            2372 B/op         44 allocs/op\nBenchmarkDumpCompressedFingerprint-8        1000           1400471 ns/op         1463938 B/op        128 allocs/op\nBenchmarkLoadParameters-8                    100          15343887 ns/op         2661374 B/op       3771 allocs/op\nBenchmarkGetParameters-8                     100          13094985 ns/op          733550 B/op       4273 allocs/op\nBenchmarkCalculatePosteriors1-8            30000             48986 ns/op            2711 B/op         12 allocs/op\nBenchmarkOptimizePriors-8                     10         169952320 ns/op        26243536 B/op      45237 allocs/op\nBenchmarkOptimizePriorsThreaded-8              5         215925640 ns/op        27777283 B/op     103140 allocs/op\nBenchmarkOptimizePriorsThreadedNot-8          10         183357620 ns/op        25007952 B/op      40562 allocs/op\nBenchmarkCrossValidation-8                   100          16531952 ns/op          819349 B/op       3355 allocs/op\nBenchmarkCalculatePriors-8                   200           9649543 ns/op          371202 B/op       1109 allocs/op\n```\n\n\n\n\n# Benchmarks 04/16/2016\n\nCurrent coverage (`go test -cover`): 21.2%.\n\nTo test first start process on one terminal `./gofind`, and then in another window `./testing/testdb.sh`. Then you can close `./gofind` and run with `go test -bench=. -test.benchmem`.\n\n### i7-3370 @ 3.4GHz\n\n2,058 fingerprints\n```\nBenchmarkPutFingerprintInDatabase-8          100          19446095 ns/op         1496173 B/op        212 allocs/op\nBenchmarkGetFingerprintInDatabase-8         1000           1544347 ns/op           53459 B/op         94 allocs/op\nBenchmarkLoadFingerprint-8                200000             10224 ns/op            2481 B/op         32 allocs/op\nBenchmarkLoadCompressedFingerprint-8       50000             48337 ns/op           44866 B/op         40 allocs/op\nBenchmarkDumpFingerprint-8                200000              6906 ns/op            2388 B/op         44 allocs/op\nBenchmarkDumpCompressedFingerprint-8        2000            894943 ns/op         1463963 B/op        119 allocs/op\nBenchmarkLoadParameters-8                    100          13045162 ns/op         1616906 B/op       3752 allocs/op\nBenchmarkGetParameters-8                      50          34637830 ns/op         5575188 B/op      33086 allocs/op\nBenchmarkCalculatePosteriors1-8            50000             31700 ns/op            2687 B/op         12 allocs/op\nBenchmarkOptimizePriors-8                      2         863536600 ns/op        180279556 B/op    335850 allocs/op\nBenchmarkOptimizePriorsThreaded-8              3         424329900 ns/op        159378608 B/op    326170 allocs/op\nBenchmarkOptimizePriorsThreadedNot-8           3         454433666 ns/op        155175656 B/op    233557 allocs/op\nBenchmarkCrossValidation-8                    10         102343250 ns/op         6530782 B/op      26685 allocs/op\nBenchmarkCalculatePriors-8                   100          15477659 ns/op          954329 B/op       4706 allocs/op\n```\n\n\n\n### [Python](https://github.com/schollz/find/tree/python3) vs. GO\n\nBoth benchmarked using `testing/testdb.sh` which has 344 fingerprints in 3 locations using Intel i7-3370.\n\n| Version | Fingerprints sent to /learn | Optimizing priors through /calculate |\n|---------|-----------------------------|--------------------------------------|\n| [Python](https://github.com/schollz/find/tree/python3)  | 15 fingerprints/sec         | 3 calculations/min                   |\n| Go      | 76 fingerprints/sec         | 619 calculations/min                 |\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.744140625,
          "content": "# sudo docker build -t finddocker .\n# sudo docker run -it -p 18003:8003 -p 11883:1883 -v /path/to/host/data/folder:/data finddocker bash\nFROM ubuntu:16.04\n\n# Get basics\nRUN apt-get update\nRUN apt-get -y upgrade\nRUN apt-get install -y git wget curl vim\n\n# Add Python stuff\nRUN apt-get install -y python3 python3-dev python3-pip\nRUN apt-get install -y python3-scipy python3-numpy\nRUN python3 -m pip install scikit-learn\n\n# Install SVM\nWORKDIR \"/tmp\"\nRUN wget http://www.csie.ntu.edu.tw/~cjlin/cgi-bin/libsvm.cgi?+http://www.csie.ntu.edu.tw/~cjlin/libsvm+tar.gz -O libsvm.tar.gz\nRUN tar -xvzf libsvm.tar.gz\nRUN mv libsvm-*/* ./\nRUN make\nRUN cp svm-scale /usr/local/bin/\nRUN cp svm-predict /usr/local/bin/\nRUN cp svm-train /usr/local/bin/\nRUN rm -rf *\n\n# Install mosquitto\nRUN apt-get install -y mosquitto-clients mosquitto\n\n# Install Go\nRUN wget https://storage.googleapis.com/golang/go1.9.2.linux-amd64.tar.gz\nRUN tar -C /usr/local -xzf go1.9.2.linux-amd64.tar.gz\nRUN rm go1.9*\nENV PATH=\"/usr/local/go/bin:${PATH}\"\nRUN mkdir /usr/local/work\nENV GOPATH /usr/local/work\n\n# Install FIND\nRUN go get github.com/schollz/find\nWORKDIR \"/usr/local/work/src/github.com/schollz/find\"\nRUN rm supervisord.conf\nRUN go build -v\nRUN echo \"\\ninclude_dir /usr/local/work/src/github.com/schollz/find/mosquitto\" >> /etc/mosquitto/mosquitto.conf\n\n# Setup supervisor\nRUN apt-get update\nRUN apt-get install -y supervisor\n\n# Add supervisor\nCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\n\n# Add Tini\nENV TINI_VERSION v0.13.0\nADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini\nRUN chmod +x /tini\nENTRYPOINT [\"/tini\", \"--\"]\n\n# Default MQTT connection settings\nENV MQTT_SERVER=localhost:1883 MQTT_USERNAME=admin MQTT_PASSWORD=123\n\n# Startup\nCMD [\"/usr/bin/supervisord\"]\n\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 9.84765625,
          "content": "# FAQ\n\n\nIf you have any questions, please contact:\n\n* Email: [zack@hypercubeplatforms.com](mailto:zack@hypercubeplatforms.com)\n* Twitter: [@zack_118](https://twitter.com/intent/tweet?screen_name=zack_118)\n* Gitter: [Join room](https://gitter.im/schollz/find)\n* Github Issues: [Open an issue](https://github.com/schollz/find/issues/new)\n\n###  Can I use an iPhone?\n\n**No.** We currently do not support iPhone. Unfortunately, the information about the WiFi scanning has to come from the use of the [`Apple80211` library](https://stackoverflow.com/questions/9684341/iphone-get-a-list-of-all-ssids-without-private-library/9684945#9684945). This is private library which means that [a user would have to jail break their device in order to use it](https://stackoverflow.com/questions/6341547/ios-can-i-manually-associate-wifi-network-with-geographic-location/6341893#6341893). We do not want to distribute an app that would require users to jailbreak their phones, so we will have to avoid developing for iOS until Apple removes this restriction. Sorry!\n\n###  Doesn't this already exist?\n\n**Yes - but not satisfyingly.** Most solutions are not open-source, or they require external hardware (beacons, etc.), or they are expensive, or they just don't work very well. But don't take my word for it, try it yourself. Here are some of the programs I found that are similar:\n\nIf you are looking for a more **commercial, large-scale deployable application**, look at these up-and-coming solutions:\n\n-   [MazeMap Indoor Navigation] - a Norway-based and Cisco-partnered enterprise that takes your CAD floor plans and generates a nice user-interface with similar indoor-positioning capabilities.\n-   [Meridian Kits] - a SF and Portland based company (part of Aruba Networks) that offers specialized App SDK environments for building internal positioning systems into workplaces, businesses and hospitals\n-   [MPact Platform] - Motorola is working on a internal positioning system that takes advantage of BlueTooth beacons and Wi-Fi for internal positioning for large applications\n\nIf you are looking for a **free single-user, single-home application**, perhaps you can find solutions with these apps:\n\n-   [Google Maps Floor Plan Maker] - not sure how it works (and have not tested) but claims to be able to navigate within small businesses. Reviewed okay.\n-   [WiFi Indoor Localization] - single-floor grid-based learning system that uses Wi-Fi to train on the names of mac addresses. In my hands it did not work well below 20ft resolution. Reviewed okay.\n-   [Indoor Positioning] - Selective learning, not tested by me, but also grid-based. Not reviewed.\n-   [BuildNGO - Indoor Navi] - Offers Android app that requires online service for uploading floor plans to their server and uses learning based on Max signal, may require Bluetooth as well.\n-   [Wifarer] - Uses Beacons and WiFi for Indoor positioning, but trainable and limited to select museums. Reviewed well, but no training available.\n-   [Indoor GPS] - Perfunctory application that trains on a route, instead of a location and offers SDK but still lots of work to be done. Reviewed okay.\n\n  [MazeMap Indoor Navigation]: http://mazemap.com/what-it-is\n  [Meridian Kits]: http://www.meridianapps.com\n  [MPact Platform]: http://newsroom.motorolasolutions.com/Press-Releases/Communicate-to-Shoppers-at-the-Right-Time-with-First-of-its-Kind-Location-Based-Platform-from-Motor-49e1.aspx\n  [Google Maps Floor Plan Maker]: https://play.google.com/store/apps/details?id=com.google.android.apps.insight.surveyor&hl=en\n  [WiFi Indoor Localization]: https://play.google.com/store/apps/details?id=com.hfalan.wifilocalization&hl=en\n  [Indoor Positioning]: https://play.google.com/store/apps/details?id=com.bombao.projetwifi&hl=en\n  [BuildNGO - Indoor Navi]: https://play.google.com/store/apps/details?id=com.sails.buildngo&hl=en\n  [Wifarer]: https://play.google.com/store/apps/details?id=com.wifarer.android&hl=en\n  [Indoor GPS]: https://play.google.com/store/apps/details?id=com.ladiesman217.indoorgps&hl=en\n\n\n###  What's the point of this?\n\n**The point is to eventually incorporate FIND into home automation.** **FIND** can replace motion sensors to provide positional and user-specific information. Anything that you would do with a motion sensor you can do with **FIND**. Anything you can do with GPS information you can do with **FIND** information. Except here you get internal positioning so you could tell apart one table from another in a cafeteria, or one bookshelf from another in a library.\n\n As Wi-Fi singleboard computers get smaller and smartphones become more ubiquitous there will be more and more opportunities to harness WiFi signals into something useful for other applications.\n\n### How does it work?\n\n**The basis of this system is to catalog all the fingerprints about the\nWifi routers in the area (MAC addresses and signal values) and then\nclassify them according to their location.** Take a look at a typical set of fingerprints\n (taken from the library at Duke University):\n\n![Distributions](https://www.internalpositioning.com/guide/img/fingerprint_library.png)\n\nThe distributions in Wifi RSSI signal as interpreted by an Android\ndevice is shown for each router. Each router is differentiated by color.\nDifferent locations give different distributions of router signals,\nwhether these locations differ by a several meters or the same location\nbetween floors.\n\n**FIND** works by taking these differences between the WiFi data from different places to *classify* a location. Positioning is accomplished by first learning the distributions of WiFi signals for a given location and then classifying it during tracking. Learning only takes ~10 minutes and will last almost indefinitely. The WiFi fingerprints are also the same across all devices so that learning using one device is guaranteed to work across all devices.\n\n### Does the smartphone version use up the battery quickly?\n\n**No.** One important benefit of using WiFi-based technologies as they are relatively cheap sensors in the smartphone/computer. They are cheap in a monetary sense, as well as a power supply sense. Normally, a GPS sensor that is probed every 2 seconds will quickly drain your battery. Probing the WiFi every 2 seconds will take hours to drain your battery and is less taxing than many apps.\n\n### Can it replace motion sensors?\n\n**Yes...probably.** Replacing motion sensors with FIND has the added benefit of automatically providing *user information* as well as the position/time information. The main disadvantage is that there is time delay of 1-5 seconds to register, so timing applications are not as good. It is possible to increase the scan speed to accomplish better timing applications but it will drain the life of the battery faster.\n\n\n### Does it use a [Wi-Fi location database](https://en.wikipedia.org/wiki/Wi-Fi_positioning_system#Public_Wi-Fi_location_databases)?\n\n**No.** There is no dependency on external resources like Wi-Fi location databases. However, these type of databases can add additional information that might be worthwhile to explore to also integrate into **FIND**.\n\n\n###  Do I need to be on Wifi to submit fingerprints?\n\n**Yes, unless you have a data connection**. You also need to have Wifi enabled, otherwise you have no way of scanning wifi!\n\n###  Can I run the server at home on the LAN connection?\n\n**Yes.** You can setup your own server to host locally. Setting up your server can be done by [building the program yourself](https://github.com/schollz/find#setup-optional) or simply [downloading the latest prebuilt version](https://github.com/schollz/find/releases/tag/v2.0) for you OS.\n\n###  Can I track myself on a map?\n\n**Not yet**. This is something we would like to implement and we are working on. There is more information about our longterm roadmap [here](https://www.internalpositioning.com/).\n\n\n###  Can I use an Android?\n\n**Yes.** All Android devices are supported. You can [download the app from Google Play](https://play.google.com/store/apps/details?id=com.hcp.find) or [use the source code to build the app yourself](https://github.com/schollz/find/tree/android).\n\n###  What is the minimum distance that can be resolved?\n\n**It depends.** This system harnesses the available WiFi routers. If you have very few WiFi routers in the vicinity (i.e. <3 in 50 meters) then your resolution will suffer. Otherwise, you can typically get less than 10 square feet in location resolution.\n\n###  Can you run the server on a Raspberry Pi?\n\n**Yes.** Its been tested and runs great on a Raspberry Pi model B+, and model 3. Also, all the releases include [a ARM release for running on a Raspberry pi](https://github.com/schollz/find/releases).\n\n### Is there a good minimum time to leave the app to train a location?\n\n### Can it pick up locations between floors?\n\n**Yes.** Yes it will pick up floors no problem. Floors tend to attenuate the signal, so there is a noticeable difference when you are in the same position, but on different floors. For example, check this out [this graphic](https://camo.githubusercontent.com/aa8ce49f332c0d1dcf0baa58c9a1d59672f8ce22/68747470733a2f2f7777772e696e7465726e616c706f736974696f6e696e672e636f6d2f67756964652f696d672f66696e6765727072696e745f6c6962726172792e706e67). Location x54 and location x49 are exactly the same place, but different floors, in a library. The blue signals are much more attenuated in x49 than x54 and thus are distinguished.\n\n### What is a good amount of time to train a location?\n\n**2 to 5 minutes**. Optimally you want to send ~100 pieces of information to the server. It transmits about 20 per minute, so you should give it some time to train well.\n\n### Can I help develop?\n\n**Yes!** We host our code on [Github](https://github.com/schollz/find) and will accept Pull requests and Feature requests.\n\n### Does it work with [home-assistant.io](https://home-assistant.io/)?\n\n**Yes.** See [here](https://community.home-assistant.io/t/anyone-seen-this-find-internal-positioning/772/2?u=schollz) for the discussion on how to use it with home-assistant.io.\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 3.3984375,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  name = \"github.com/boj/redistore\"\n  packages = [\".\"]\n  revision = \"fc113767cd6b051980f260d6dbe84b2740c46ab0\"\n  version = \"v1.2\"\n\n[[projects]]\n  name = \"github.com/boltdb/bolt\"\n  packages = [\".\"]\n  revision = \"2f1ce7a837dcb8da3ec595b1dac9d0632f0f99e8\"\n  version = \"v1.3.1\"\n\n[[projects]]\n  name = \"github.com/davecgh/go-spew\"\n  packages = [\"spew\"]\n  revision = \"346938d642f2ec3594ed81d874461961cd0faa76\"\n  version = \"v1.1.0\"\n\n[[projects]]\n  name = \"github.com/garyburd/redigo\"\n  packages = [\"internal\",\"redis\"]\n  revision = \"433969511232c397de61b1442f9fd49ec06ae9ba\"\n  version = \"v1.1.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/gin-contrib/sse\"\n  packages = [\".\"]\n  revision = \"22d885f9ecc78bf4ee5d72b937e4bbcdc58e8cae\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/gin-gonic/contrib\"\n  packages = [\"sessions\"]\n  revision = \"5aa1e38d1d932e45fa5032bd1b8739e1a548e596\"\n\n[[projects]]\n  name = \"github.com/gin-gonic/gin\"\n  packages = [\".\",\"binding\",\"render\"]\n  revision = \"d459835d2b077e44f7c9b453505ee29881d5d12d\"\n  version = \"v1.2\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/golang/protobuf\"\n  packages = [\"proto\"]\n  revision = \"130e6b02ab059e7b717a096f397c5b60111cae74\"\n\n[[projects]]\n  name = \"github.com/gorilla/context\"\n  packages = [\".\"]\n  revision = \"1ea25387ff6f684839d82767c1733ff4d4d15d0a\"\n  version = \"v1.1\"\n\n[[projects]]\n  name = \"github.com/gorilla/securecookie\"\n  packages = [\".\"]\n  revision = \"667fe4e3466a040b780561fe9b51a83a3753eefc\"\n  version = \"v1.1\"\n\n[[projects]]\n  name = \"github.com/gorilla/sessions\"\n  packages = [\".\"]\n  revision = \"ca9ada44574153444b00d3fd9c8559e4cc95f896\"\n  version = \"v1.1\"\n\n[[projects]]\n  name = \"github.com/mattn/go-isatty\"\n  packages = [\".\"]\n  revision = \"0360b2af4f38e8d38c7fce2a9f4e702702d73a39\"\n  version = \"v0.0.3\"\n\n[[projects]]\n  name = \"github.com/pmezard/go-difflib\"\n  packages = [\"difflib\"]\n  revision = \"792786c7400a136282c1664665ae0a8db921c6c2\"\n  version = \"v1.0.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/pquerna/ffjson\"\n  packages = [\"fflib/v1\",\"fflib/v1/internal\"]\n  revision = \"d49c2bc1aa135aad0c6f4fc2056623ec78f5d5ac\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/schollz/org.eclipse.paho.mqtt.golang\"\n  packages = [\".\",\"packets\"]\n  revision = \"6d626954dc988ae6c25b0fdaabdb64f144c438b0\"\n\n[[projects]]\n  name = \"github.com/stretchr/testify\"\n  packages = [\"assert\"]\n  revision = \"69483b4bd14f5845b5a1e55bca19e954e827f1d0\"\n  version = \"v1.1.4\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/ugorji/go\"\n  packages = [\"codec\"]\n  revision = \"54210f4e076c57f351166f0ed60e67d3fca57a36\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/net\"\n  packages = [\"websocket\"]\n  revision = \"0a9397675ba34b2845f758fe3cd68828369c6517\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/sys\"\n  packages = [\"unix\"]\n  revision = \"314a259e304ff91bd6985da2a7149bbf91237993\"\n\n[[projects]]\n  name = \"gopkg.in/go-playground/validator.v8\"\n  packages = [\".\"]\n  revision = \"5f1438d3fca68893a817e4a66806cea46a9e4ebf\"\n  version = \"v8.18.2\"\n\n[[projects]]\n  branch = \"v2\"\n  name = \"gopkg.in/yaml.v2\"\n  packages = [\".\"]\n  revision = \"eb3733d160e74a9c7e442f435eb3bea458e1d19f\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  inputs-digest = \"e22879c1e2da2838c8d0852a9ff36e5535faa93051d0ccb77488d2f1654fb51c\"\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.97265625,
          "content": "\n# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n\n[[constraint]]\n  name = \"github.com/boltdb/bolt\"\n  version = \"1.3.1\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/gin-gonic/contrib\"\n\n[[constraint]]\n  name = \"github.com/gin-gonic/gin\"\n  version = \"1.2.0\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/pquerna/ffjson\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/schollz/org.eclipse.paho.mqtt.golang\"\n\n[[constraint]]\n  name = \"github.com/stretchr/testify\"\n  version = \"1.1.4\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 33.7587890625,
          "content": "\n\n                    GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version 3, 19 November 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU Affero General Public License is a free, copyleft license for\nsoftware and other kinds of works, specifically designed to ensure\ncooperation with the community in the case of network server software.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nour General Public Licenses are intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  Developers that use our General Public Licenses protect your rights\nwith two steps: (1) assert copyright on the software, and (2) offer\nyou this License which gives you legal permission to copy, distribute\nand/or modify the software.\n\n  A secondary benefit of defending all users' freedom is that\nimprovements made in alternate versions of the program, if they\nreceive widespread use, become available for other developers to\nincorporate.  Many developers of free software are heartened and\nencouraged by the resulting cooperation.  However, in the case of\nsoftware used on network servers, this result may fail to come about.\nThe GNU General Public License permits making a modified version and\nletting the public access it on a server without ever releasing its\nsource code to the public.\n\n  The GNU Affero General Public License is designed specifically to\nensure that, in such cases, the modified source code becomes available\nto the community.  It requires the operator of a network server to\nprovide the source code of the modified version running there to the\nusers of that server.  Therefore, public use of a modified version, on\na publicly accessible server, gives the public access to the source\ncode of the modified version.\n\n  An older license, called the Affero General Public License and\npublished by Affero, was designed to accomplish similar goals.  This is\na different license, not a version of the Affero GPL, but Affero has\nreleased a new version of the Affero GPL which permits relicensing under\nthis license.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU Affero General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Remote Network Interaction; Use with the GNU General Public License.\n\n  Notwithstanding any other provision of this License, if you modify the\nProgram, your modified version must prominently offer all users\ninteracting with it remotely through a computer network (if your version\nsupports such interaction) an opportunity to receive the Corresponding\nSource of your version by providing access to the Corresponding Source\nfrom a network server at no charge, through some standard or customary\nmeans of facilitating copying of software.  This Corresponding Source\nshall include the Corresponding Source for any work covered by version 3\nof the GNU General Public License that is incorporated pursuant to the\nfollowing paragraph.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the work with which it is combined will remain governed by version\n3 of the GNU General Public License.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU Affero General Public License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU Affero General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU Affero General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU Affero General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    The Framework for Internal Navigation and Discovery (FIND) is a system for internal positioning using WiFi fingerprints.\n    Copyright (C) 2015-2016  Zack Scholl\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If your software can interact with users remotely through a computer\nnetwork, you should also make sure that it provides a way for users to\nget its source.  For example, if your program is a web application, its\ninterface could display a \"Source\" link that leads users to an archive\nof the code.  There are many ways you could offer source, and different\nsolutions will be better for different programs; see section 13 for the\nspecific requirements.\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU AGPL, see\n<http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.62109375,
          "content": "SOURCEDIR=.\r\nSOURCES := $(shell find $(SOURCEDIR) -name '*.go')\r\n\r\nBINARY=findserver\r\n\r\nVERSION=2.4.2\r\nBUILD_TIME=`date +%FT%T%z`\r\nBUILD=`git rev-parse HEAD`\r\n\r\nLDFLAGS=-ldflags \"-X main.VersionNum=${VERSION} -X main.Build=${BUILD} -X main.BuildTime=${BUILD_TIME}\"\r\n\r\n.DEFAULT_GOAL: $(BINARY)\r\n\r\n$(BINARY): $(SOURCES)\r\n\tgo build ${LDFLAGS} -o ${BINARY}\r\n\r\n.PHONY: install\r\ninstall:\r\n\tgo install ${LDFLAGS} ./...\r\n\r\n.PHONY: clean\r\nclean:\r\n\tif [ -f ${BINARY} ] ; then rm ${BINARY} ; fi\r\n\trm -rf builds\r\n\trm -rf find\r\n\trm -rf findserver*\r\n\r\n.PHONY: binaries\r\nbinaries:\r\n\trm -rf builds\r\n\tmkdir builds\r\n\t# Build Windows\r\n\tenv GOOS=windows GOARCH=amd64 go build ${LDFLAGS} -o findserver.exe -v *.go\r\n\tzip -r find_${VERSION}_windows_amd64.zip findserver.exe LICENSE ./templates/* ./data/.datagoeshere ./static/* rf.py\r\n\tmv find_${VERSION}_windows_amd64.zip builds/\r\n\trm findserver.exe\r\n\t# Build Linux\r\n\tenv GOOS=linux GOARCH=amd64 go build ${LDFLAGS} -o findserver -v *.go\r\n\tzip -r find_${VERSION}_linux_amd64.zip findserver LICENSE ./templates/* ./data/.datagoeshere ./static/* rf.py\r\n\tmv find_${VERSION}_linux_amd64.zip builds/\r\n\trm findserver\r\n\t# Build OS X\r\n\tenv GOOS=darwin GOARCH=amd64 go build ${LDFLAGS} -o findserver -v *.go\r\n\tzip -r find_${VERSION}_osx.zip findserver LICENSE ./templates/* ./data/.datagoeshere ./static/* rf.py\r\n\tmv find_${VERSION}_osx.zip builds/\r\n\trm findserver\r\n\t# Build Raspberry Pi / Chromebook\r\n\tenv GOOS=linux GOARCH=arm go build ${LDFLAGS} -o findserver -v *.go\r\n\tzip -r find_${VERSION}_linux_arm.zip findserver LICENSE ./templates/* ./data/.datagoeshere ./static/* rf.py\r\n\tmv find_${VERSION}_linux_arm.zip builds/\r\n\trm findserver\r\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.0966796875,
          "content": "FIND\r\nCopyright 2015-2016 Zack Scholl\r\n\r\nThis product includes software developed by Zack Scholl.\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.9111328125,
          "content": "# ![](https://raw.githubusercontent.com/schollz/find/master/static/img/FIND_icon_larger.png) FIND\n\n[![Version 2.4](https://img.shields.io/badge/version-2.4-brightgreen.svg?style=flat-square)](https://www.internalpositioning.com/guide/development/) \n[![Github All Releases](https://img.shields.io/github/downloads/schollz/find/total.svg?style=flat-square)](https://github.com/schollz/find/releases)\n[![FIND documentation](https://img.shields.io/badge/find-documentation-blue.svg?style=flat-square)](https://www.internalpositioning.com/) \n![Coverage](https://img.shields.io/badge/coverage-57%25-orange.svg?style=flat-square) \n[![Donate](https://img.shields.io/badge/donate-$-brown.svg?style=flat-square)](https://www.paypal.me/ZackScholl/5.00)\n[![Say Thanks](https://img.shields.io/badge/Say%20Thanks-!-yellow.svg?style=flat-square)](https://saythanks.io/to/schollz)\n\n\n[![](https://raw.githubusercontent.com/schollz/find/master/static/splash.gif)](https://www.internalpositioning.com/)\n\n**Keywords**: indoor GPS, WiFi positioning, indoor mapping, indoor navigation, indoor positioning\n\n# There is a new version, [FIND3](https://github.com/schollz/find3). It has [numerous improvements](https://www.internalpositioning.com/doc/overview.md#new-version) over this version.\n\n# About\n\n**The Framework for Internal Navigation and Discovery** (_FIND_) allows you to use your (Android) smartphone or WiFi-enabled computer (laptop or Raspberry Pi or etc.) to determine your position within your home or office. You can easily use this system in place of motion sensors as its resolution will allow your phone to distinguish whether you are in the living room, the kitchen or the bedroom, etc. The position information can then be used in a variety of ways including home automation, way-finding, or tracking!\n\n> Simply put, FIND will allow you to replace _tons_ of motion sensors with a _single_ smartphone!\n\nThe system is built on two main components - [a server](https://ml.internalpositioning.com/) and a fingerprinting device. The fingerprinting device ([computer program](https://github.com/schollz/find/releases/tag/v0.5) or [android app](https://play.google.com/store/apps/details?id=com.hcp.find)) sends the specified data to the machine learning server which stores the fingerprints and analyzes them. It then returns the result to the device and stores the result on the server for accessing via a web browser or triggering via hooks.\n\n**FAQ (abbreviated)**:\n\n- How does it work? It uses already available WiFi information to classify locations. [See here for more detailed information](https://www.internalpositioning.com/faq/#how-does-it-work).\n- Doesn't this already exist? [Yes, kinda](https://www.internalpositioning.com/faq/#doesnt-this-already-exist).\n- What's the point? This short piece of code can do [home automation](https://www.internalpositioning.com/faq/#can-i-run-the-server-at-home-on-the-lan-connection) and [replace motion sensors](https://www.internalpositioning.com/faq/#can-it-replace-motion-sensors) and [more](https://www.internalpositioning.com/faq/#whats-the-point-of-this).\n- Can I use an iPhone? [Sorry, no](https://www.internalpositioning.com/faq/#can-i-use-an-iphone).\n- Does it work on a Raspberry Pi? [Yes](https://www.internalpositioning.com/faq/#can-you-run-the-server-on-a-raspberry-pi).\n- Does it work with [home-assistant.io](https://home-assistant.io/)? [Yes](https://www.internalpositioning.com/faq/#does-it-work-with-home-assistantio).\n- Can I help? [Yes, please](https://github.com/schollz/find/issues).\n- How do I try it? It's easy. Just [download and run](https://github.com/schollz/find#usage).\n\nMore questions? See the [unabbreviated FAQ](https://www.internalpositioning.com/faq/).\n\n# Quickstart\n\nIf you'd like to install things yourself, see [the documentation](https://www.internalpositioning.com/setup/). You don't need to do this to try it though. Follow the 3 steps below to get started quickly.\n\n## 1\\. Download the software\n\n**Android users:** [download the current version of the app](https://play.google.com/store/apps/details?id=com.hcp.find). _Sorry iPhone users but [the Apple store prevents apps that access WiFi information](https://www.internalpositioning.com/faq/#can-i-use-an-iphone), so I will be unable to release a iPhone version._\n\n**OR**\n\n**Computer users:** you can [download the current version of the fingerprinting program](https://github.com/schollz/find/releases/tag/v0.5), available for Rasbperry Pi, OSX, Linux, and Windows.\n\n## 2\\. Gather fingerprint data\n\nFirst, to get started using **FIND** you will need to gather fingerprint data in your locations.\n\n**Android users:** When you start up the app you will be asked for a username (enter whatever you want) and you'll be assigned a unique group name. Simply click \"Learn\" and you'll be prompted for a location name. After you enter a location, the app will connect to the server and then submit fingerprints.\n\n<center><img src=\"https://i.imgur.com/fbcYom5.png\" width=\"200px\">\n<img src=\"https://i.imgur.com/Ab9eXIk.png\" width=\"200px\"></center>\n\n<br>\n\n**Computer users:** To start learning locations simply use `./fingerprint -e`.\n\n## 3\\. Track yourself\n\nOnce you've collected data in a few locations, you can track yourself.\n\n**Android users:** Just press the \"Track\" button when you're ready to track.\n\n**Computer users:** Type in `./fingerprint` to start tracking yourself.\n\n# More information\n\nSee the documentation at <https://www.internalpositioning.com>.\n\n# Acknowledgements\n\n![](https://i.imgur.com/Ze51DJ6.png) Funding from [Duke University Colab](https://colab.duke.edu/)\n\nThanks to [tscholl2](https://github.com/tscholl2), [sjsafranek](https://github.com/sjsafranek), and [jschools](https://github.com/jschools) for their help in guiding the development of **FIND** and creating the early versions of FIND with me! Thanks to Rishabh Rajgarhia and [CanvasJS](http://canvasjs.com/) for help implementing a nice graph. Thanks [arafsheikh](https://github.com/arafsheikh) for adding interface selection, [Pugio](https://github.com/Pugio) and [ScottSWu](https://github.com/ScottSWu) for adding OS X/Windows support for the fingerprint program, including a better [Windows scanning utility](https://github.com/ScottSWu/windows-wlan-util/releases)! Thanks [Thom-x](https://github.com/Thom-x) for the Dockerfile. Thanks [certifiedloud](https://github.com/certifiedloud) for implementing the change to `DELETE` requests and implementing sockets for unix. Thanks [bebus77](https://github.com/bebus77) for making a awesome generic struct for OS support on the fingerprinting program! Thanks [christoph-wagner](https://github.com/Christoph-Wagner) for help with polling interval on app. Thanks to [patorjk](http://patorjk.com/software/taag/) and [asciiworld](http://www.asciiworld.com/) for the ASCII art. Thanks to [Imgur](https://imgur.com/a/yjvci) for [hosting](https://imgur.com/a/3yGjV) images.\n\n## Donate\n\nLike this? Help me keep it alive [by donating $5](https://www.paypal.me/ZackScholl/5.00) to [pay for server costs](http://rpiai.com/donate/).\n"
        },
        {
          "name": "RF.py",
          "type": "blob",
          "size": 2.4677734375,
          "content": "import json\nimport os\nimport pickle\nimport sklearn\nimport random\nimport numpy\nimport copy\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.pipeline import make_pipeline\nfrom random import shuffle\n\n__author__ = \"Huy Tu\"\n__email__  = \"hqtu@ncsu.edu\"\n__githubID__ = \"HuyTu7\"\n\n#random.seed(123)\nclass RF(object):\n\tdef __init__(self):\n\t\tself.size = 0\n\t\tself.data = []\n\t\tself.trainX = numpy.array([])\n\t\tself.trainY = []\n\t\tself.testX = numpy.array([])\n\t\tself.testY = []\n\t\tself.macs = set()\n\t\tself.locations = set()\n\n\tdef get_data(self, fname):\n\t\titem = {}\n\t\twith open(fname, 'r') as f_in:\n\t\t\tfor line in f_in:\n\t\t\t\tsignal_data = json.loads(line)\n\t\t\t\titem[\"wifi-fingerprint\"] = signal_data[\"wifi-fingerprint\"]\n\t\t\t\titem[\"location\"] = signal_data[\"location\"]\n\t\t\t\tself.locations.add(signal_data[\"location\"])\n\t\t\t\tself.data.append(copy.deepcopy(item))\n\t\t\t\tfor signal in signal_data[\"wifi-fingerprint\"]:\n\t\t\t\t\tself.macs.add(signal[\"mac\"])\n\t\tself.size = len(self.data)\n\t\tself.macs = list(self.macs)\n\t\tself.locations = list(self.locations)\n\t\treturn self.data\n\n\n\tdef splitDataset(self, dataset, splitRatio):\n\t\ttrainSize = int(len(dataset)*splitRatio)\n\t\tself.trainX.shape=(0, len(self.macs))\n\t\tself.testX.shape=(0, len(self.macs))\n\t\tindex = 0\n\t\txs = [i for i in range(len(dataset))]\n\t\tshuffle(xs)\n\t\twhile index < len(xs):\n\t\t\titem = numpy.zeros(len(self.macs))\n\t\t\tfor signal in dataset[xs[index]]['wifi-fingerprint']:\n\t\t\t\titem[self.macs.index(signal['mac'])] = signal['rssi']\n\t\t\tif index < trainSize:\t\t\t\t\n\t\t\t\tself.trainX = numpy.concatenate((self.trainX, [item]),axis=0)\n\t\t\t\tself.trainY.append(self.locations.index(dataset[xs[index]][\"location\"]))\n\t\t\telse:\n\t\t\t\tself.testX = numpy.concatenate((self.testX, [item]),axis=0)\t\t\t\t\n\t\t\t\tself.testY.append(self.locations.index(dataset[xs[index]][\"location\"]))\n\t\t\tindex += 1\n\t\n\t'''def makeMatrix(self, dataset, index):\n\t\titem = [] \n\t\tdataT = dataset[index]\n\t\tdataTest = dataT[\"wifi-fingerprint\"]\n\t\tvalue = -1\n\t\tfor i in range(len(self.macs)):\n\t\t\tfor j in range(len(dataTest)):\n\t\t\t\tif self.macs[i] == dataTest[j][\"mac\"]:\n\t\t\t\t\tvalue = dataTest[j][\"rssi\"] \n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tvalue = 0\n\t\t\titem.append(value)\n\t\treturn item '''\n\n\tdef randomFC(self):\n\t\tclf = RandomForestClassifier(n_estimators=500, n_jobs = -1)\n\t\tclf.fit(self.trainX, self.trainY)\n\t\tprint(self.locations)\n\t\tprint(clf.score(self.testX, self.testY))\t\t\n\t\t\n\t\nrandomF = RF()\ndata = randomF.get_data(\"data/hackduke.rf.data\")\nrandomF.splitDataset(data, 0.6)\nrandomF.randomFC()"
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 30.8876953125,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// api.go handles functions that return JSON responses.\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar startTime time.Time\n\nfunc init() {\n\tstartTime = time.Now()\n}\n\nfunc getStatus(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"uptime\": time.Since(startTime).Seconds(), \"registered\": startTime.String(), \"status\": \"standard\", \"num_cores\": runtime.NumCPU(), \"success\": true})\n}\n\n// UserPositionJSON stores the a users time, location and bayes after calculatePosterior()\ntype UserPositionJSON struct {\n\tTime     interface{}        `json:\"time\"`\n\tLocation interface{}        `json:\"location\"`\n\tBayes    map[string]float64 `json:\"bayes\"`\n\tSvm      map[string]float64 `json:\"svm\"`\n\tRf       map[string]float64 `json:\"rf\"`\n}\n\nfunc getLocationList(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tif group == \"noneasdf\" {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You need to specify group\", \"success\": false})\n\t\treturn\n\t}\n\tif !groupExists(group) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You should insert a fingerprint first, see documentation\", \"success\": false})\n\t\treturn\n\t}\n\tps, _ := openParameters(group)\n\tlocationCount := make(map[string]map[string]int)\n\tfor n := range ps.NetworkLocs {\n\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\tlocationCount[loc] = make(map[string]int)\n\t\t\tlocationCount[loc][\"count\"] = ps.Results[n].TotalLocations[loc]\n\t\t\tlocationCount[loc][\"accuracy\"] = ps.Results[n].Accuracy[loc]\n\t\t}\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\":   fmt.Sprintf(\"Found %d unique locations in group %s\", len(ps.UniqueLocs), group),\n\t\t\"locations\": locationCount,\n\t\t\"success\":   true})\n}\n\nfunc apiGetLastFingerprint(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tuser := c.DefaultQuery(\"user\", \"noneasdf\")\n\tif group != \"noneasdf\" {\n\t\tif !groupExists(group) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You should insert a fingerprint first, see documentation\", \"success\": false})\n\t\t\treturn\n\t\t}\n\t\tif user == \"noneasdf\" {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You need to specify user\", \"success\": false})\n\t\t\treturn\n\t\t}\n\t\tc.String(http.StatusOK, getLastFingerprint(group, user))\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You need to specify group\", \"success\": false})\n\t}\n}\n\nfunc getLastFingerprint(group string, user string) string {\n\tgroup = strings.ToLower(group)\n\tuser = strings.ToLower(user)\n\tsentAs := \"\"\n\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar v2 Fingerprint\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tv3 := loadFingerprint(v)\n\t\t\tif v3.Username == user {\n\t\t\t\tv2 = v3\n\t\t\t\ttimestampString := string(k)\n\t\t\t\ttimestampUnixNano, _ := strconv.ParseInt(timestampString, 10, 64)\n\t\t\t\tUTCfromUnixNano := time.Unix(0, timestampUnixNano)\n\t\t\t\tv2.Timestamp = UTCfromUnixNano.UnixNano()\n\t\t\t\tsentAs = \"sent as /track\\n\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"User \" + user + \" not found\")\n\t})\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-learn\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\ttimestampString := string(k)\n\t\t\ttimestampUnixNano, _ := strconv.ParseInt(timestampString, 10, 64)\n\t\t\tUTCfromUnixNano := time.Unix(0, timestampUnixNano).UnixNano()\n\t\t\tif UTCfromUnixNano < v2.Timestamp {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tv3 := loadFingerprint(v)\n\t\t\tif v2.Username == user {\n\t\t\t\tv2 = v3\n\t\t\t\tv2.Timestamp = UTCfromUnixNano\n\t\t\t\tsentAs = \"sent as /learn\\n\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"User \" + user + \" not found\")\n\t})\n\tdb.Close()\n\n\tbJson, _ := json.MarshalIndent(v2, \"\", \" \")\n\treturn sentAs + string(bJson)\n}\n\nfunc getHistoricalUserPositions(group string, user string, n int) []UserPositionJSON {\n\tgroup = strings.ToLower(group)\n\tuser = strings.ToLower(user)\n\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar fingerprints []Fingerprint\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\tnumFound := 0\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tif v2.Username == user {\n\t\t\t\ttimestampString := string(k)\n\t\t\t\ttimestampUnixNano, _ := strconv.ParseInt(timestampString, 10, 64)\n\t\t\t\tUTCfromUnixNano := time.Unix(0, timestampUnixNano)\n\t\t\t\tv2.Timestamp = UTCfromUnixNano.UnixNano()\n\t\t\t\tfingerprints = append(fingerprints, v2)\n\t\t\t\tnumFound++\n\t\t\t\tif numFound >= n {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"User \" + user + \" not found\")\n\t})\n\tdb.Close()\n\n\tDebug.Printf(\"Got history of %d fingerprints\\n\", len(fingerprints))\n\tuserJSONs := make([]UserPositionJSON, len(fingerprints))\n\tfor i, fingerprint := range fingerprints {\n\t\tvar userJSON UserPositionJSON\n\t\tUTCfromUnixNano := time.Unix(0, fingerprint.Timestamp)\n\t\tuserJSON.Time = UTCfromUnixNano.String()\n\t\tlocation, bayes := calculatePosterior(fingerprint, *NewFullParameters())\n\t\tuserJSON.Location = location\n\t\tuserJSON.Bayes = bayes\n\t\t// Process SVM if needed\n\t\tif RuntimeArgs.Svm {\n\t\t\t_, userJSON.Svm = classify(fingerprint)\n\t\t}\n\t\t// Process RF if needed\n\t\tif RuntimeArgs.RandomForests {\n\t\t\tuserJSON.Rf = rfClassify(group, fingerprint)\n\t\t}\n\t\tuserJSONs[i] = userJSON\n\t}\n\treturn userJSONs\n}\n\nfunc getCurrentPositionOfAllUsers(group string) map[string]UserPositionJSON {\n\tgroup = strings.ToLower(group)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tuserPositions := make(map[string]UserPositionJSON)\n\tuserFingerprints := make(map[string]Fingerprint)\n\tnumUsersFound := 0\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Database not found\")\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tif _, ok := userPositions[v2.Username]; !ok {\n\t\t\t\ttimestampString := string(k)\n\t\t\t\ttimestampUnixNano, _ := strconv.ParseInt(timestampString, 10, 64)\n\t\t\t\tUTCfromUnixNano := time.Unix(0, timestampUnixNano)\n\t\t\t\tfoo := UserPositionJSON{Time: UTCfromUnixNano.String()}\n\t\t\t\tuserPositions[v2.Username] = foo\n\t\t\t\tuserFingerprints[v2.Username] = v2\n\t\t\t\tnumUsersFound++\n\t\t\t}\n\t\t\tif numUsersFound > 40 {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\tif err != nil {\n\t\treturn userPositions\n\t}\n\n\tfor user := range userPositions {\n\t\tlocation, bayes := calculatePosterior(userFingerprints[user], *NewFullParameters())\n\t\tfoo := userPositions[user]\n\t\tfoo.Location = location\n\t\tfoo.Bayes = bayes\n\t\t// Process SVM if needed\n\t\tif RuntimeArgs.Svm {\n\t\t\t_, foo.Svm = classify(userFingerprints[user])\n\t\t}\n\t\tif RuntimeArgs.RandomForests {\n\t\t\tfoo.Rf = rfClassify(group, userFingerprints[user])\n\t\t}\n\t\tgo setUserPositionCache(group+user, foo)\n\t\tuserPositions[user] = foo\n\t}\n\n\treturn userPositions\n}\n\nfunc getCurrentPositionOfUser(group string, user string) UserPositionJSON {\n\tgroup = strings.ToLower(group)\n\tuser = strings.ToLower(user)\n\tval, ok := getUserPositionCache(group + user)\n\tif ok {\n\t\treturn val\n\t}\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar userFingerprint Fingerprint\n\tvar userJSON UserPositionJSON\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\ti := 0\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\ti++\n\t\t\tif i > 10000 {\n\t\t\t\treturn fmt.Errorf(\"Too deep!\")\n\t\t\t}\n\t\t\tif v2.Username == user {\n\t\t\t\ttimestampString := string(k)\n\t\t\t\ttimestampUnixNano, _ := strconv.ParseInt(timestampString, 10, 64)\n\t\t\t\tUTCfromUnixNano := time.Unix(0, timestampUnixNano)\n\t\t\t\tuserJSON.Time = UTCfromUnixNano.String()\n\t\t\t\tuserFingerprint = v2\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"User \" + user + \" not found\")\n\t})\n\tdb.Close()\n\tif err != nil {\n\t\treturn userJSON\n\t}\n\tlocation, bayes := calculatePosterior(userFingerprint, *NewFullParameters())\n\tuserJSON.Location = location\n\tuserJSON.Bayes = bayes\n\t// Process SVM if needed\n\tif RuntimeArgs.Svm {\n\t\t_, userJSON.Svm = classify(userFingerprint)\n\t}\n\tif RuntimeArgs.RandomForests {\n\t\tuserJSON.Rf = rfClassify(group, userFingerprint)\n\t}\n\tgo setUserPositionCache(group+user, userJSON)\n\treturn userJSON\n}\n\nfunc calculate(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tif group != \"noneasdf\" {\n\t\tif !groupExists(group) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You should insert a fingerprint first, see documentation\", \"success\": false})\n\t\t\treturn\n\t\t}\n\t\tgroup = strings.ToLower(group)\n\t\toptimizePriorsThreaded(group)\n\t\tif RuntimeArgs.Svm {\n\t\t\tdumpFingerprintsSVM(group)\n\t\t\terr := calculateSVM(group)\n\t\t\tif err != nil {\n\t\t\t\tWarning.Println(\"Encountered error when calculating SVM\")\n\t\t\t\tWarning.Println(err)\n\t\t\t}\n\t\t}\n\t\tif RuntimeArgs.RandomForests {\n\t\t\trfLearn(group)\n\t\t}\n\t\tgo resetCache(\"userPositionCache\")\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Parameters optimized.\", \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc userLocations(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE, UPDATE\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tusers := strings.Split(c.DefaultQuery(\"users\", \"noneasdf\"), \",\")\n\tgroup = strings.ToLower(group)\n\tif group != \"noneasdf\" {\n\t\tif !groupExists(group) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You should insert fingerprints before tracking, see documentation\", \"success\": false})\n\t\t\treturn\n\t\t}\n\t\tif users[0] == \"noneasdf\" {\n\t\t\tusers = getUsers(group)\n\t\t}\n\t\tpeople := make(map[string]UserPositionJSON)\n\t\tfor _, user := range users {\n\t\t\tpeople[user] = getCurrentPositionOfUser(group, user)\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Correctly found\", \"success\": true, \"users\": people})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc getUserLocations(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tuserQuery := c.DefaultQuery(\"user\", \"noneasdf\")\n\tusersQuery := c.DefaultQuery(\"users\", \"noneasdf\")\n\tnQuery := c.DefaultQuery(\"n\", \"noneasdf\")\n\tgroup = strings.ToLower(group)\n\tif group != \"noneasdf\" {\n\t\tif !groupExists(group) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"You should insert fingerprints before tracking, see documentation\", \"success\": false})\n\t\t\treturn\n\t\t}\n\t\tpeople := make(map[string][]UserPositionJSON)\n\t\tusers := strings.Split(strings.ToLower(usersQuery), \",\")\n\t\tif users[0] == \"noneasdf\" {\n\t\t\tusers = []string{userQuery}\n\t\t}\n\t\tif users[0] == \"noneasdf\" {\n\t\t\tusers = getUsers(group)\n\t\t}\n\t\tfor _, user := range users {\n\t\t\tif _, ok := people[user]; !ok {\n\t\t\t\tpeople[user] = []UserPositionJSON{}\n\t\t\t}\n\t\t\tif nQuery != \"noneasdf\" {\n\t\t\t\tnumber, _ := strconv.ParseInt(nQuery, 10, 0)\n\t\t\t\tDebug.Println(\"Getting history for \" + user)\n\t\t\t\tpeople[user] = append(people[user], getHistoricalUserPositions(group, user, int(number))...)\n\t\t\t} else {\n\t\t\t\tpeople[user] = append(people[user], getCurrentPositionOfUser(group, user))\n\t\t\t}\n\t\t}\n\t\tmessage := \"Correctly found locations.\"\n\t\tif len(people) == 0 {\n\t\t\tmessage = \"No users found for username \" + strings.Join(users, \" or \")\n\t\t\tpeople = nil\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": message, \"success\": true, \"users\": people})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc migrateDatabase(c *gin.Context) {\n\tfromDB := strings.ToLower(c.DefaultQuery(\"from\", \"noneasdf\"))\n\ttoDB := strings.ToLower(c.DefaultQuery(\"to\", \"noneasdf\"))\n\tDebug.Printf(\"Migrating %s to %s.\\n\", fromDB, toDB)\n\tif !exists(path.Join(RuntimeArgs.SourcePath, fromDB+\".db\")) {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Can't migrate from \" + fromDB + \", it does not exist.\"})\n\t\treturn\n\t}\n\tif !exists(path.Join(RuntimeArgs.SourcePath, toDB)) {\n\t\tCopyFile(path.Join(RuntimeArgs.SourcePath, fromDB+\".db\"), path.Join(RuntimeArgs.SourcePath, toDB+\".db\"))\n\t} else {\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, fromDB+\".db\"), 0664, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\tdb2, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, toDB+\".db\"), 0664, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer db2.Close()\n\n\t\tdb2.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\t\t\tbucket.Put(k, v)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\treturn nil\n\t\t})\n\n\t\tdb2.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints-track\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\t\t\tbucket.Put(k, v)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\treturn nil\n\t\t})\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Successfully migrated \" + fromDB + \" to \" + toDB})\n}\n\nfunc deleteDatabase(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.TrimSpace(strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\")))\n\tif exists(path.Join(RuntimeArgs.SourcePath, group+\".db\")) {\n\t\tos.Remove(path.Join(RuntimeArgs.SourcePath, group+\".db\"))\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Successfully deleted \" + group})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Group does not exist\"})\n\t}\n}\n\nfunc putMixinOverride(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"PUT\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tnewMixin := c.DefaultQuery(\"mixin\", \"none\")\n\tif group != \"noneasdf\" {\n\t\tnewMixinFloat, err := strconv.ParseFloat(newMixin, 64)\n\t\tif err == nil {\n\t\t\terr2 := setMixinOverride(group, newMixinFloat)\n\t\t\tif err2 == nil {\n\t\t\t\toptimizePriorsThreaded(strings.ToLower(group))\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Overriding mixin for \" + group + \", now set to \" + newMixin})\n\t\t\t} else {\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": err2.Error()})\n\t\t\t}\n\t\t} else {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t}\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc putCutoffOverride(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"PUT\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tnewCutoff := c.DefaultQuery(\"cutoff\", \"none\")\n\tDebug.Println(group)\n\tDebug.Println(newCutoff)\n\tif group != \"noneasdf\" {\n\t\tnewCutoffFloat, err := strconv.ParseFloat(newCutoff, 64)\n\t\tif err == nil {\n\t\t\terr2 := setCutoffOverride(group, newCutoffFloat)\n\t\t\tif err2 == nil {\n\t\t\t\toptimizePriorsThreaded(strings.ToLower(group))\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Overriding cutoff for \" + group + \", now set to \" + newCutoff})\n\t\t\t} else {\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": err2.Error()})\n\t\t\t}\n\t\t} else {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t}\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc editNetworkName(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\toldname := c.DefaultQuery(\"oldname\", \"none\")\n\tnewname := c.DefaultQuery(\"newname\", \"none\")\n\tif group != \"noneasdf\" {\n\t\tDebug.Println(\"Attempting renaming \", group, oldname, newname)\n\t\trenameNetwork(group, oldname, newname)\n\t\toptimizePriors(group)\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Finished\"})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc editName(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tlocation := c.DefaultQuery(\"location\", \"none\")\n\tnewname := c.DefaultQuery(\"newname\", \"none\")\n\tif group != \"noneasdf\" {\n\t\ttoUpdate := make(map[string]string)\n\t\tnumChanges := 0\n\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Location == location {\n\t\t\t\t\t\tv2.Location = newname\n\t\t\t\t\t\ttoUpdate[string(k)] = string(dumpFingerprint(v2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tfor k, v := range toUpdate {\n\t\t\t\tbucket.Put([]byte(k), []byte(v))\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tnumChanges += len(toUpdate)\n\n\t\ttoUpdate = make(map[string]string)\n\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Location == location {\n\t\t\t\t\t\tv2.Location = newname\n\t\t\t\t\t\ttoUpdate[string(k)] = string(dumpFingerprint(v2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints-track\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tfor k, v := range toUpdate {\n\t\t\t\tbucket.Put([]byte(k), []byte(v))\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Close()\n\t\tnumChanges += len(toUpdate)\n\t\toptimizePriorsThreaded(strings.ToLower(group))\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Changed name of \" + strconv.Itoa(numChanges) + \" things\", \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc editUserName(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tuser := strings.ToLower(c.DefaultQuery(\"user\", \"none\"))\n\tnewname := strings.ToLower(c.DefaultQuery(\"newname\", \"none\"))\n\tif group != \"noneasdf\" {\n\t\ttoUpdate := make(map[string]string)\n\t\tnumChanges := 0\n\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Username == user {\n\t\t\t\t\t\tv2.Username = newname\n\t\t\t\t\t\ttoUpdate[string(k)] = string(dumpFingerprint(v2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tfor k, v := range toUpdate {\n\t\t\t\tbucket.Put([]byte(k), []byte(v))\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tnumChanges += len(toUpdate)\n\n\t\ttoUpdate = make(map[string]string)\n\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Username == user {\n\t\t\t\t\t\tv2.Username = newname\n\t\t\t\t\t\ttoUpdate[string(k)] = string(dumpFingerprint(v2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"fingerprints-track\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t\t}\n\n\t\t\tfor k, v := range toUpdate {\n\t\t\t\tbucket.Put([]byte(k), []byte(v))\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Close()\n\t\tnumChanges += len(toUpdate)\n\n\t\t// reset the cache (cache.go)\n\t\tgo resetCache(\"usersCache\")\n\t\tgo resetCache(\"userPositionCache\")\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Changed name of \" + strconv.Itoa(numChanges) + \" things\", \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc deleteLocation(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tlocation := strings.ToLower(c.DefaultQuery(\"location\", \"none\"))\n\tif group != \"noneasdf\" {\n\t\tnumChanges := 0\n\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Location == location {\n\t\t\t\t\t\tb.Delete(k)\n\t\t\t\t\t\tnumChanges++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Close()\n\t\toptimizePriorsThreaded(strings.ToLower(group))\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Deleted \" + strconv.Itoa(numChanges) + \" locations\", \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\nfunc deleteLocations(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tlocationsQuery := strings.ToLower(c.DefaultQuery(\"names\", \"none\"))\n\tif group != \"noneasdf\" && locationsQuery != \"none\" {\n\t\tlocations := strings.Split(strings.ToLower(locationsQuery), \",\")\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tnumChanges := 0\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tfor _, location := range locations {\n\t\t\t\t\t\tif v2.Location == location {\n\t\t\t\t\t\t\tb.Delete(k)\n\t\t\t\t\t\t\tnumChanges++\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tdb.Close()\n\t\toptimizePriorsThreaded(strings.ToLower(group))\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Deleted \" + strconv.Itoa(numChanges) + \" locations\", \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Need to provide group and location list. DELETE /locations?group=X&names=Y,Z,W\"})\n\t}\n}\n\nfunc deleteUser(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\tuser := strings.ToLower(c.DefaultQuery(\"user\", \"noneasdf\"))\n\tif group != \"noneasdf\" && user != \"noneasdf\" {\n\t\tnumChanges := 0\n\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tdb.Update(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\t\tif b != nil {\n\t\t\t\tc := b.Cursor()\n\t\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\t\tif v2.Username == user {\n\t\t\t\t\t\tb.Delete(k)\n\t\t\t\t\t\tnumChanges++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tdb.Close()\n\n\t\t// reset the cache (cache.go)\n\t\tgo resetCache(\"usersCache\")\n\t\tgo resetCache(\"userPositionCache\")\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Deletes \" + strconv.Itoa(numChanges) + \" things \" + \" with user \" + user, \"success\": true})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n\t}\n}\n\ntype whereAmIJson struct {\n\tGroup string `json:\"group\"`\n\tUser  string `json:\"user\"`\n}\n\nfunc whereAmI(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tvar jsonData whereAmIJson\n\tif c.BindJSON(&jsonData) == nil {\n\t\tdefer timeTrack(time.Now(), \"getUniqueMacs\")\n\t\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, jsonData.Group+\".db\"), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t\tlocations := []string{}\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\t// Assume bucket exists and has keys\n\t\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\t\tc := b.Cursor()\n\t\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\t\tv2 := loadFingerprint(v)\n\t\t\t\tif v2.Username == jsonData.User {\n\t\t\t\t\tlocations = append(locations, v2.Location)\n\t\t\t\t}\n\t\t\t\tif len(locations) > 2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\t// jsonLocations, _ := json.Marshal(locations)\n\t\tmessage := \"Found user\"\n\t\tif len(locations) == 0 {\n\t\t\tmessage = \"No locations found.\"\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": message, \"group\": jsonData.Group, \"user\": jsonData.User, \"locations\": locations})\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Could not bind JSON - did you not send it as a JSON?\", \"success\": false})\n\t}\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 4.9873046875,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tgin.SetMode(gin.ReleaseMode)\n\t_, err := exec.Command(\"cp\", []string{\"data/testdb.db.backup\", \"data/testdb.db\"}...).Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc TestGetStatus(t *testing.T) {\n\trouter := gin.New()\n\trouter.PUT(\"/foo\", getStatus)\n\n\treq, _ := http.NewRequest(\"PUT\", \"/foo\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.Contains(resp.Body.String(), \"\\\"success\\\":true\"), true)\n}\n\nfunc TestMigrateDatabase(t *testing.T) {\n\trouter := gin.New()\n\trouter.PUT(\"/foo\", migrateDatabase)\n\n\treq, _ := http.NewRequest(\"PUT\", \"/foo?from=testdb&to=newdb\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), \"{\\\"message\\\":\\\"Successfully migrated testdb to newdb\\\",\\\"success\\\":true}\")\n\tos.Remove(\"data/newdb.db\")\n}\n\nfunc TestDeleteDatabase(t *testing.T) {\n\tCopyFile(\"./data/testdb.db\", \"./data/deleteme.db\")\n\n\trouter := gin.New()\n\trouter.DELETE(\"/foo\", deleteDatabase)\n\n\treq, _ := http.NewRequest(\"DELETE\", \"/foo?group=deleteme\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), \"{\\\"message\\\":\\\"Successfully deleted deleteme\\\",\\\"success\\\":true}\")\n}\n\nfunc TestCalculate(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", calculate)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), \"{\\\"message\\\":\\\"Parameters optimized.\\\",\\\"success\\\":true}\")\n}\n\nfunc TestUserLocations(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", userLocations)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.Contains(resp.Body.String(), \"{\\\"message\\\":\\\"Correctly found\\\",\\\"success\\\":true,\"), true)\n}\n\nfunc TestGetUserLocations(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", getUserLocations)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), \"{\\\"message\\\":\\\"Error parsing request\\\",\\\"success\\\":false}\")\n}\n\nfunc TestGetUserLocations2(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", getUserLocations)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb&user=zack\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tassert.Equal(t, strings.Contains(resp.Body.String(), \"{\\\"message\\\":\\\"Correctly found locations.\\\"\"), true)\n}\n\nfunc TestPutMixinOverrideBad(t *testing.T) {\n\trouter := gin.New()\n\trouter.PUT(\"/foo\", putMixinOverride)\n\n\treq, _ := http.NewRequest(\"PUT\", \"/foo?group=testdb&mixin=100\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := `{\"message\":\"mixin must be between 0 and 1\",\"success\":false}`\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n\nfunc TestPutMixinOverrideGood(t *testing.T) {\n\trouter := gin.New()\n\trouter.PUT(\"/foo\", putMixinOverride)\n\n\treq, _ := http.NewRequest(\"PUT\", \"/foo?group=testdb&mixin=0\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := `{\"message\":\"Overriding mixin for testdb, now set to 0\",\"success\":true}`\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n\nfunc TestEditNetworkName(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", editNetworkName)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb&oldname=0&newname=home\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Finished\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n\nfunc TestEditName(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", editName)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb&location=zakhome%20floor%202%20office&newname=office\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Changed name of 175 things\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n\nfunc TestEditUserName(t *testing.T) {\n\trouter := gin.New()\n\trouter.GET(\"/foo\", editUserName)\n\n\treq, _ := http.NewRequest(\"GET\", \"/foo?group=testdb&user=zack&newname=zack2\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Changed name of 344 things\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n\nfunc TestDeleteUser(t *testing.T) {\n\trouter := gin.New()\n\trouter.DELETE(\"/foo\", deleteUser)\n\n\treq, _ := http.NewRequest(\"DELETE\", \"/foo?group=testdb&user=zack2@gmail.com\", nil)\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Deletes 0 things  with user zack2@gmail.com\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, strings.TrimSpace(resp.Body.String()), response)\n}\n"
        },
        {
          "name": "backup.go",
          "type": "blob",
          "size": 1.8330078125,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// backup.go contains functions for dumping a backup database.\n\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc dumpFingerprints(group string) error {\n\t// Debug.Println(\"Making dump-\" + group + \" directory\")\n\terr := os.MkdirAll(path.Join(RuntimeArgs.SourcePath, \"dump-\"+group), 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Debug.Println(\"Opening db\")\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0664, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Debug.Println(\"Opening file for learning fingerprints\")\n\t// Debug.Println(path.Join(RuntimeArgs.SourcePath, \"dump-\"+group, \"learning\"))\n\tf, err := os.OpenFile(path.Join(RuntimeArgs.SourcePath, \"dump-\"+group, \"learning\"), os.O_WRONLY|os.O_CREATE, 0664)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Debug.Println(\"Writing fingerprints to file\")\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tif _, err = f.WriteString(string(decompressByte(v)) + \"\\n\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tf.Close()\n\n\t// Debug.Println(\"Opening file for tracking fingerprints\")\n\tf, err = os.OpenFile(path.Join(RuntimeArgs.SourcePath, \"dump-\"+group, \"tracking\"), os.O_WRONLY|os.O_CREATE, 0664)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Debug.Println(\"Writing fingerprints to file\")\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tif _, err = f.WriteString(string(decompressByte(v)) + \"\\n\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tf.Close()\n\t// Debug.Println(\"Returning\")\n\n\treturn nil\n}\n"
        },
        {
          "name": "backup_test.go",
          "type": "blob",
          "size": 0.15625,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBackup(t *testing.T) {\n\tassert.Equal(t, dumpFingerprints(\"testdb\"), nil)\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 3.1240234375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// cache.go handles the global variables for caching and the clearing.\n\npackage main\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar psCache = struct {\n\tsync.RWMutex\n\tm map[string]FullParameters\n}{m: make(map[string]FullParameters)}\n\nvar usersCache = struct {\n\tsync.RWMutex\n\tm map[string][]string\n}{m: make(map[string][]string)}\n\nvar userPositionCache = struct {\n\tsync.RWMutex\n\tm map[string]UserPositionJSON\n}{m: make(map[string]UserPositionJSON)}\n\nvar isLearning = struct {\n\tsync.RWMutex\n\tm map[string]bool\n}{m: make(map[string]bool)}\n\nfunc init() {\n\tgo clearCache()\n\tgo clearCacheFast()\n}\n\nfunc clearCacheFast() {\n\tfor {\n\t\tgo resetCache(\"userCache\")\n\t\ttime.Sleep(time.Second * 30)\n\t}\n}\n\nfunc clearCache() {\n\tfor {\n\t\t//Debug.Println(\"Resetting cache\")\n\t\tgo resetCache(\"isLearning\")\n\t\tgo resetCache(\"psCache\")\n\t\tgo resetCache(\"userPositionCache\")\n\t\ttime.Sleep(time.Second * 600)\n\t}\n}\n\nfunc resetCache(cache string) {\n\tif cache == \"userCache\" {\n\t\tusersCache.Lock()\n\t\tusersCache.m = make(map[string][]string)\n\t\tusersCache.Unlock()\n\t} else if cache == \"userPositionCache\" {\n\t\tuserPositionCache.Lock()\n\t\tuserPositionCache.m = make(map[string]UserPositionJSON)\n\t\tuserPositionCache.Unlock()\n\t} else if cache == \"psCache\" {\n\t\tpsCache.Lock()\n\t\tpsCache.m = make(map[string]FullParameters)\n\t\tpsCache.Unlock()\n\t} else if cache == \"isLearning\" {\n\t\tisLearning.Lock()\n\t\tisLearning.m = make(map[string]bool)\n\t\tisLearning.Unlock()\n\t}\n}\n\nfunc getLearningCache(group string) (bool, bool) {\n\t//Debug.Println(\"getLearningCache\")\n\tisLearning.RLock()\n\tcached, ok := isLearning.m[group]\n\tisLearning.RUnlock()\n\treturn cached, ok\n}\n\nfunc setLearningCache(group string, val bool) {\n\tisLearning.Lock()\n\tisLearning.m[group] = val\n\tisLearning.Unlock()\n}\n\nfunc getUserCache(group string) ([]string, bool) {\n\t//Debug.Println(\"Getting userCache\")\n\tusersCache.RLock()\n\tcached, ok := usersCache.m[group]\n\tusersCache.RUnlock()\n\treturn cached, ok\n}\n\nfunc setUserCache(group string, users []string) {\n\tusersCache.Lock()\n\tusersCache.m[group] = users\n\tusersCache.Unlock()\n}\n\nfunc appendUserCache(group string, user string) {\n\tusersCache.Lock()\n\tif _, ok := usersCache.m[group]; ok {\n\t\tif len(usersCache.m[group]) == 0 {\n\t\t\tusersCache.m[group] = append([]string{}, strings.ToLower(user))\n\t\t}\n\t}\n\tusersCache.Unlock()\n}\n\nfunc getPsCache(group string) (FullParameters, bool) {\n\t//Debug.Println(\"Getting pscache\")\n\tpsCache.RLock()\n\tpsCached, ok := psCache.m[group]\n\tpsCache.RUnlock()\n\treturn psCached, ok\n}\n\nfunc setPsCache(group string, ps FullParameters) {\n\t//Debug.Println(\"Setting pscache\")\n\tpsCache.Lock()\n\tpsCache.m[group] = ps\n\tpsCache.Unlock()\n\treturn\n}\n\nfunc getUserPositionCache(group string) (UserPositionJSON, bool) {\n\t//Debug.Println(\"getUserPositionCache\")\n\tuserPositionCache.RLock()\n\tcached, ok := userPositionCache.m[group]\n\tuserPositionCache.RUnlock()\n\treturn cached, ok\n}\n\nfunc setUserPositionCache(group string, p UserPositionJSON) {\n\t//Debug.Println(\"setUserPositionCache\")\n\tuserPositionCache.Lock()\n\tuserPositionCache.m[group] = p\n\tuserPositionCache.Unlock()\n\treturn\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 2.1083984375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUserCache(t *testing.T) {\n\tsetUserCache(\"zack\", []string{\"bob\", \"bill\", \"jane\"})\n\tusers, _ := getUserCache(\"zack\")\n\tassert.Equal(t, users, []string{\"bob\", \"bill\", \"jane\"})\n}\n\nfunc TestResetCache(t *testing.T) {\n\tsetUserCache(\"zack\", []string{\"bob\", \"bill\", \"jane\"})\n\tresetCache(\"userCache\")\n\t_, ok := getUserCache(\"zack\")\n\tassert.Equal(t, ok, false)\n}\n\nfunc BenchmarkSetCache(b *testing.B) {\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsetUserCache(\"zack\", []string{\"bob\", \"bill\", \"jane\"})\n\t}\n}\n\nfunc BenchmarkResetCache(b *testing.B) {\n\tsetUserCache(\"zack\", []string{\"bob\", \"bill\", \"jane\"})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tresetCache(\"userCache)\")\n\t}\n}\n\n// BenchmarkCache needs to have precomputed parameters for testdb (run Optimize after loading testdb.sh)\nfunc BenchmarkGetPSCache(b *testing.B) {\n\tvar ps FullParameters\n\tdb, err := bolt.Open(path.Join(\"data\", \"testdb.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"fullParameters\"))\n\t\tps = loadParameters(v)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdb.Close()\n\tsetPsCache(\"testdb\", ps)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgetPsCache(\"testdb\")\n\t}\n\n}\n\n// BenchmarkCache needs to have precomputed parameters for testdb (run Optimize after loading testdb.sh)\nfunc BenchmarkSetPSCache(b *testing.B) {\n\tvar ps FullParameters\n\tdb, err := bolt.Open(path.Join(\"data\", \"testdb.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"fullParameters\"))\n\t\tps = loadParameters(v)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdb.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsetPsCache(\"testdb\", ps)\n\t}\n\n}\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 4.6630859375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// db.go contains generic functions for parsing data from the database.\n// This file is not exhaustive of all database functions, if they pertain to a\n// specific property (fingerprinting/priors/parameters), it will instead be in respective file.\n\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc groupExists(group string) bool {\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, strings.ToLower(group)+\".db\")); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc renameNetwork(group string, oldName string, newName string) {\n\tDebug.Println(\"Opening parameters\")\n\tps, _ := openParameters(group)\n\tDebug.Println(\"Opening persistent parameters\")\n\tpersistentPs, _ := openPersistentParameters(group)\n\tDebug.Println(\"Looping network macs\")\n\tfor n := range ps.NetworkMacs {\n\t\tif n == oldName {\n\t\t\tmacs := []string{}\n\t\t\tDebug.Println(\"Looping macs for \", n)\n\t\t\tfor mac := range ps.NetworkMacs[n] {\n\t\t\t\tmacs = append(macs, mac)\n\t\t\t}\n\t\t\tDebug.Println(\"Adding to persistentPs\")\n\t\t\tpersistentPs.NetworkRenamed[newName] = macs\n\t\t\tdelete(persistentPs.NetworkRenamed, oldName)\n\t\t\tbreak\n\t\t}\n\t}\n\tDebug.Println(\"Saving persistentPs\")\n\tsavePersistentParameters(group, persistentPs)\n}\n\nfunc getUsers(group string) []string {\n\tval, ok := getUserCache(group)\n\tif ok {\n\t\treturn val\n\t}\n\n\tuniqueUsers := []string{}\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints-track\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tif !stringInSlice(v2.Username, uniqueUsers) {\n\t\t\t\tuniqueUsers = append(uniqueUsers, v2.Username)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tgo setUserCache(group, uniqueUsers)\n\treturn uniqueUsers\n}\n\nfunc getUniqueMacs(group string) []string {\n\tdefer timeTrack(time.Now(), \"getUniqueMacs\")\n\tuniqueMacs := []string{}\n\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t\tif !stringInSlice(router.Mac, uniqueMacs) {\n\t\t\t\t\tuniqueMacs = append(uniqueMacs, router.Mac)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn uniqueMacs\n}\n\nfunc getUniqueLocations(group string) (uniqueLocs []string) {\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tif !stringInSlice(v2.Location, uniqueLocs) {\n\t\t\t\tuniqueLocs = append(uniqueLocs, v2.Location)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn uniqueLocs\n}\n\nfunc getMacCount(group string) (macCount map[string]int) {\n\tmacCount = make(map[string]int)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t\tif _, ok := macCount[router.Mac]; !ok {\n\t\t\t\t\tmacCount[router.Mac] = 0\n\t\t\t\t}\n\t\t\t\tmacCount[router.Mac]++\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn\n}\n\nfunc getMacCountByLoc(group string) (macCountByLoc map[string]map[string]int) {\n\tmacCountByLoc = make(map[string]map[string]int)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tif _, ok := macCountByLoc[v2.Location]; !ok {\n\t\t\t\tmacCountByLoc[v2.Location] = make(map[string]int)\n\t\t\t}\n\t\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t\tif _, ok := macCountByLoc[v2.Location][router.Mac]; !ok {\n\t\t\t\t\tmacCountByLoc[v2.Location][router.Mac] = 0\n\t\t\t\t}\n\t\t\t\tmacCountByLoc[v2.Location][router.Mac]++\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn\n}\n"
        },
        {
          "name": "fingerprint.go",
          "type": "blob",
          "size": 9.9296875,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// fingerprint.go contains structures and functions for handling fingerprints.\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"strconv\"\n\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// Fingerprint is the prototypical information from the fingerprinting device\n// IF you change Fingerprint, follow these steps to re-generate fingerprint_ffjson.go\n// find ./ -name \"*.go\" -type f | xargs sed -i  's/package main/package main/g'\n// Uncomment json.Marshal/Unmarshal functions\n// $GOPATH/bin/ffjson fingerprint.go\n// find ./ -name \"*.go\" -type f | xargs sed -i  's/package main/package main/g'\n// Comment json.Marshal/Unmarshal functions\ntype Fingerprint struct {\n\tGroup           string   `json:\"group\"`\n\tUsername        string   `json:\"username\"`\n\tLocation        string   `json:\"location\"`\n\tTimestamp       int64    `json:\"timestamp\"`\n\tWifiFingerprint []Router `json:\"wifi-fingerprint\"`\n}\n\n// Router is the router information for each invdividual mac address\ntype Router struct {\n\tMac  string `json:\"mac\"`\n\tRssi int    `json:\"rssi\"`\n}\n\nvar jsonExample = `{\n\t\"group\": \"whatevergroup\",\n\t\"username\": \"iamauser\",\n\t\"location\": null,\n\t\"wififingerprint\": [{\n\t\t\"mac\": \"AA:AA:AA:AA:AA:AA\",\n\t\t\"rssi\": -45\n\t}, {\n\t\t\"mac\": \"BB:BB:BB:BB:BB:BB\",\n\t\t\"rssi\": -55\n\t}]\n}`\n\n// compression 9 us -> 900 us\nfunc dumpFingerprint(res Fingerprint) []byte {\n\tdumped, _ := res.MarshalJSON()\n\t//dumped, _ := json.Marshal(res)\n\treturn compressByte(dumped)\n}\n\n// compression 30 us -> 600 us\nfunc loadFingerprint(jsonByte []byte) Fingerprint {\n\tres := Fingerprint{}\n\t//json.Unmarshal(decompressByte(jsonByte), res)\n\tres.UnmarshalJSON(decompressByte(jsonByte))\n\tfilterFingerprint(&res)\n\treturn res\n}\n\nfunc filterFingerprint(res *Fingerprint) {\n\tif RuntimeArgs.Filtering {\n\t\tnewFingerprint := make([]Router, len(res.WifiFingerprint))\n\t\tcurNum := 0\n\t\tfor i := range res.WifiFingerprint {\n\t\t\tif ok2, ok := RuntimeArgs.FilterMacs[res.WifiFingerprint[i].Mac]; ok && ok2 {\n\t\t\t\tnewFingerprint[curNum] = res.WifiFingerprint[i]\n\t\t\t\tnewFingerprint[curNum].Mac = newFingerprint[curNum].Mac[0:len(newFingerprint[curNum].Mac)-1] + \"0\"\n\t\t\t\tcurNum++\n\t\t\t}\n\t\t}\n\t\tnewFingerprint = newFingerprint[0:curNum]\n\t\tres.WifiFingerprint = newFingerprint\n\t}\n}\n\nfunc cleanFingerprint(res *Fingerprint) {\n\tres.Group = strings.TrimSpace(strings.ToLower(res.Group))\n\tres.Location = strings.TrimSpace(strings.ToLower(res.Location))\n\tres.Username = strings.TrimSpace(strings.ToLower(res.Username))\n\tdeleteIndex := -1\n\tfor r := range res.WifiFingerprint {\n\t\tif res.WifiFingerprint[r].Rssi >= 0 { // https://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\t\t\tres.WifiFingerprint[r].Rssi = int(res.WifiFingerprint[r].Rssi/2) - 100\n\t\t}\n\t\tif res.WifiFingerprint[r].Mac == \"00:00:00:00:00:00\" {\n\t\t\tdeleteIndex = r\n\t\t}\n\t}\n\tif deleteIndex > -1 {\n\t\tres.WifiFingerprint[deleteIndex] = res.WifiFingerprint[len(res.WifiFingerprint)-1]\n\t\tres.WifiFingerprint = res.WifiFingerprint[:len(res.WifiFingerprint)-1]\n\t}\n}\n\nfunc putFingerprintIntoDatabase(res Fingerprint, database string) error {\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, res.Group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err2 := tx.CreateBucketIfNotExists([]byte(database))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err2)\n\t\t}\n\n\t\tif res.Timestamp == 0 {\n\t\t\tres.Timestamp = time.Now().UnixNano()\n\t\t}\n\t\terr2 = bucket.Put([]byte(strconv.FormatInt(res.Timestamp, 10)), dumpFingerprint(res))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err2)\n\t\t}\n\t\treturn err2\n\t})\n\tdb.Close()\n\treturn err\n}\n\nfunc trackFingerprintPOST(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\tvar jsonFingerprint Fingerprint\n\tif c.BindJSON(&jsonFingerprint) == nil {\n\t\tmessage, success, locationGuess, bayes, svm, rf := trackFingerprint(jsonFingerprint)\n\t\tif success {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": message, \"success\": true, \"location\": locationGuess, \"bayes\": bayes, \"svm\": svm, \"rf\": rf})\n\t\t} else {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": message, \"success\": false})\n\t\t}\n\t} else {\n\t\tWarning.Println(\"Could not bind JSON\")\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Could not bind JSON\", \"success\": false})\n\t}\n}\n\nfunc learnFingerprintPOST(c *gin.Context) {\n\tc.Writer.Header().Set(\"Content-Type\", \"application/json\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Writer.Header().Set(\"Access-Control-Max-Age\", \"86400\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"GET\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max\")\n\tc.Writer.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\tvar jsonFingerprint Fingerprint\n\tif c.BindJSON(&jsonFingerprint) == nil {\n\t\tmessage, success := learnFingerprint(jsonFingerprint)\n\t\tDebug.Println(message)\n\t\tif !success {\n\t\t\tDebug.Println(jsonFingerprint)\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": message, \"success\": success})\n\t} else {\n\t\tWarning.Println(\"Could not bind JSON\")\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Could not bind JSON\", \"success\": false})\n\t}\n}\n\nfunc learnFingerprint(jsonFingerprint Fingerprint) (string, bool) {\n\tcleanFingerprint(&jsonFingerprint)\n\tif len(jsonFingerprint.Group) == 0 {\n\t\treturn \"Need to define your group name in request, see API\", false\n\t}\n\tif len(jsonFingerprint.WifiFingerprint) == 0 {\n\t\treturn \"No fingerprints found to insert, see API\", false\n\t}\n\tputFingerprintIntoDatabase(jsonFingerprint, \"fingerprints\")\n\tgo setLearningCache(strings.ToLower(jsonFingerprint.Group), true)\n\tmessage := \"Inserted fingerprint containing \" + strconv.Itoa(len(jsonFingerprint.WifiFingerprint)) + \" APs for \" + jsonFingerprint.Username + \" (\" + jsonFingerprint.Group + \") at \" + jsonFingerprint.Location\n\treturn message, true\n}\n\nfunc trackFingerprint(jsonFingerprint Fingerprint) (string, bool, string, map[string]float64, map[string]float64, map[string]float64) {\n\t// Classify with filter fingerprint\n\tfullFingerprint := jsonFingerprint\n\tfilterFingerprint(&jsonFingerprint)\n\n\tbayes := make(map[string]float64)\n\tsvmData := make(map[string]float64)\n\tcleanFingerprint(&jsonFingerprint)\n\tif !groupExists(jsonFingerprint.Group) || len(jsonFingerprint.Group) == 0 {\n\t\treturn \"You should insert fingerprints before tracking\", false, \"\", bayes, make(map[string]float64), make(map[string]float64)\n\t}\n\tif len(jsonFingerprint.WifiFingerprint) == 0 {\n\t\treturn \"No fingerprints found to track, see API\", false, \"\", bayes, make(map[string]float64), make(map[string]float64)\n\t}\n\tif len(jsonFingerprint.Username) == 0 {\n\t\treturn \"No username defined, see API\", false, \"\", bayes, make(map[string]float64), make(map[string]float64)\n\t}\n\twasLearning, ok := getLearningCache(strings.ToLower(jsonFingerprint.Group))\n\tif ok {\n\t\tif wasLearning {\n\t\t\tDebug.Println(\"Was learning, calculating priors\")\n\t\t\tgroup := strings.ToLower(jsonFingerprint.Group)\n\t\t\tgo setLearningCache(group, false)\n\t\t\toptimizePriorsThreaded(group)\n\t\t\tif RuntimeArgs.Svm {\n\t\t\t\tdumpFingerprintsSVM(group)\n\t\t\t\tcalculateSVM(group)\n\t\t\t}\n\t\t\tif RuntimeArgs.RandomForests {\n\t\t\t\trfLearn(group)\n\t\t\t}\n\t\t\tgo appendUserCache(group, jsonFingerprint.Username)\n\t\t}\n\t}\n\tlocationGuess1, bayes := calculatePosterior(jsonFingerprint, *NewFullParameters())\n\tpercentGuess1 := float64(0)\n\ttotal := float64(0)\n\tfor _, locBayes := range bayes {\n\t\ttotal += math.Exp(locBayes)\n\t\tif locBayes > percentGuess1 {\n\t\t\tpercentGuess1 = locBayes\n\t\t}\n\t}\n\tpercentGuess1 = math.Exp(bayes[locationGuess1]) / total * 100.0\n\n\tjsonFingerprint.Location = locationGuess1\n\n\t// Insert full fingerprint\n\tputFingerprintIntoDatabase(fullFingerprint, \"fingerprints-track\")\n\n\tDebug.Println(\"Tracking fingerprint containing \" + strconv.Itoa(len(jsonFingerprint.WifiFingerprint)) + \" APs for \" + jsonFingerprint.Username + \" (\" + jsonFingerprint.Group + \") at \" + jsonFingerprint.Location + \" (guess)\")\n\tmessage := \"Current location: \" + locationGuess1 //+ \" (\" + strconv.Itoa(int(percentGuess1)) + \"% confidence)\"\n\n\t// Process SVM if needed\n\tif RuntimeArgs.Svm {\n\t\tlocationGuess2, svmData2 := classify(jsonFingerprint)\n\t\tpercentGuess2 := int(100 * math.Exp(svmData2[locationGuess2]))\n\t\tif percentGuess2 > 100 {\n\t\t\tpercentGuess2 = percentGuess2 / 10\n\t\t}\n\t\t//message = \"NB: \" + locationGuess1 + \" (\" + strconv.Itoa(int(percentGuess1)) + \"%)\" + \", SVM: \" + locationGuess2 + \" (\" + strconv.Itoa(int(percentGuess2)) + \"%)\"\n\t\tsvmData = svmData2\n\t}\n\n\t// Send MQTT if needed\n\tif RuntimeArgs.Mqtt {\n\t\ttype FingerprintResponse struct {\n\t\t\tLocationGuess string             `json:\"location\"`\n\t\t\tTimestamp     int64              `json:\"time\"`\n\t\t\tBayes         map[string]float64 `json:\"bayes\"`\n\t\t\tSvm           map[string]float64 `json:\"svm\"`\n\t\t}\n\t\tmqttMessage, _ := json.Marshal(FingerprintResponse{\n\t\t\tLocationGuess: locationGuess1,\n\t\t\tTimestamp:     time.Now().UnixNano(),\n\t\t\tBayes:         bayes,\n\t\t\tSvm:           svmData,\n\t\t})\n\t\tgo sendMQTTLocation(string(mqttMessage), jsonFingerprint.Group, jsonFingerprint.Username)\n\t}\n\n\t// Send out the final responses\n\tvar userJSON UserPositionJSON\n\tuserJSON.Location = locationGuess1\n\tuserJSON.Bayes = bayes\n\tuserJSON.Svm = svmData\n\tuserJSON.Time = time.Now().String()\n\tif RuntimeArgs.RandomForests {\n\t\tuserJSON.Rf = rfClassify(strings.ToLower(jsonFingerprint.Group), jsonFingerprint)\n\t}\n\tgo setUserPositionCache(strings.ToLower(jsonFingerprint.Group)+strings.ToLower(jsonFingerprint.Username), userJSON)\n\n\treturn message, true, locationGuess1, bayes, svmData, userJSON.Rf\n\n}\n"
        },
        {
          "name": "fingerprint_ffjson.go",
          "type": "blob",
          "size": 14.5986328125,
          "content": "// DO NOT EDIT!\n// Code generated by ffjson <https://github.com/pquerna/ffjson>\n// source: fingerprint.go\n// DO NOT EDIT!\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\tfflib \"github.com/pquerna/ffjson/fflib/v1\"\n)\n\nfunc (mj *Fingerprint) MarshalJSON() ([]byte, error) {\n\tvar buf fflib.Buffer\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn buf.Bytes(), nil\n\t}\n\terr := mj.MarshalJSONBuf(&buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\nfunc (mj *Fingerprint) MarshalJSONBuf(buf fflib.EncodingBuffer) error {\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn nil\n\t}\n\tvar err error\n\tvar obj []byte\n\t_ = obj\n\t_ = err\n\tbuf.WriteString(`{\"group\":`)\n\tfflib.WriteJsonString(buf, string(mj.Group))\n\tbuf.WriteString(`,\"username\":`)\n\tfflib.WriteJsonString(buf, string(mj.Username))\n\tbuf.WriteString(`,\"location\":`)\n\tfflib.WriteJsonString(buf, string(mj.Location))\n\tbuf.WriteString(`,\"timestamp\":`)\n\tfflib.FormatBits2(buf, uint64(mj.Timestamp), 10, mj.Timestamp < 0)\n\tbuf.WriteString(`,\"wifi-fingerprint\":`)\n\tif mj.WifiFingerprint != nil {\n\t\tbuf.WriteString(`[`)\n\t\tfor i, v := range mj.WifiFingerprint {\n\t\t\tif i != 0 {\n\t\t\t\tbuf.WriteString(`,`)\n\t\t\t}\n\n\t\t\t{\n\n\t\t\t\terr = v.MarshalJSONBuf(buf)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(`]`)\n\t} else {\n\t\tbuf.WriteString(`null`)\n\t}\n\tbuf.WriteByte('}')\n\treturn nil\n}\n\nconst (\n\tffj_t_Fingerprintbase = iota\n\tffj_t_Fingerprintno_such_key\n\n\tffj_t_Fingerprint_Group\n\n\tffj_t_Fingerprint_Username\n\n\tffj_t_Fingerprint_Location\n\n\tffj_t_Fingerprint_Timestamp\n\n\tffj_t_Fingerprint_WifiFingerprint\n)\n\nvar ffj_key_Fingerprint_Group = []byte(\"group\")\n\nvar ffj_key_Fingerprint_Username = []byte(\"username\")\n\nvar ffj_key_Fingerprint_Location = []byte(\"location\")\n\nvar ffj_key_Fingerprint_Timestamp = []byte(\"timestamp\")\n\nvar ffj_key_Fingerprint_WifiFingerprint = []byte(\"wifi-fingerprint\")\n\nfunc (uj *Fingerprint) UnmarshalJSON(input []byte) error {\n\tfs := fflib.NewFFLexer(input)\n\treturn uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)\n}\n\nfunc (uj *Fingerprint) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {\n\tvar err error = nil\n\tcurrentKey := ffj_t_Fingerprintbase\n\t_ = currentKey\n\ttok := fflib.FFTok_init\n\twantedTok := fflib.FFTok_init\n\nmainparse:\n\tfor {\n\t\ttok = fs.Scan()\n\t\t//\tprintln(fmt.Sprintf(\"debug: tok: %v  state: %v\", tok, state))\n\t\tif tok == fflib.FFTok_error {\n\t\t\tgoto tokerror\n\t\t}\n\n\t\tswitch state {\n\n\t\tcase fflib.FFParse_map_start:\n\t\t\tif tok != fflib.FFTok_left_bracket {\n\t\t\t\twantedTok = fflib.FFTok_left_bracket\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_key\n\t\t\tcontinue\n\n\t\tcase fflib.FFParse_after_value:\n\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\tstate = fflib.FFParse_want_key\n\t\t\t} else if tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t} else {\n\t\t\t\twantedTok = fflib.FFTok_comma\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_key:\n\t\t\t// json {} ended. goto exit. woo.\n\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t}\n\t\t\tif tok != fflib.FFTok_string {\n\t\t\t\twantedTok = fflib.FFTok_string\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\t\tkn := fs.Output.Bytes()\n\t\t\tif len(kn) <= 0 {\n\t\t\t\t// \"\" case. hrm.\n\t\t\t\tcurrentKey = ffj_t_Fingerprintno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t} else {\n\t\t\t\tswitch kn[0] {\n\n\t\t\t\tcase 'g':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Fingerprint_Group, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Group\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Fingerprint_Location, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Location\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 't':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Fingerprint_Timestamp, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Timestamp\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'u':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Fingerprint_Username, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Username\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'w':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Fingerprint_WifiFingerprint, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_WifiFingerprint\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif fflib.AsciiEqualFold(ffj_key_Fingerprint_WifiFingerprint, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_WifiFingerprint\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_Fingerprint_Timestamp, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Timestamp\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_Fingerprint_Location, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Location\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_Fingerprint_Username, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Username\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_Fingerprint_Group, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Fingerprint_Group\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tcurrentKey = ffj_t_Fingerprintno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_colon:\n\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\twantedTok = fflib.FFTok_colon\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_value\n\t\t\tcontinue\n\t\tcase fflib.FFParse_want_value:\n\n\t\t\tif tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {\n\t\t\t\tswitch currentKey {\n\n\t\t\t\tcase ffj_t_Fingerprint_Group:\n\t\t\t\t\tgoto handle_Group\n\n\t\t\t\tcase ffj_t_Fingerprint_Username:\n\t\t\t\t\tgoto handle_Username\n\n\t\t\t\tcase ffj_t_Fingerprint_Location:\n\t\t\t\t\tgoto handle_Location\n\n\t\t\t\tcase ffj_t_Fingerprint_Timestamp:\n\t\t\t\t\tgoto handle_Timestamp\n\n\t\t\t\tcase ffj_t_Fingerprint_WifiFingerprint:\n\t\t\t\t\tgoto handle_WifiFingerprint\n\n\t\t\t\tcase ffj_t_Fingerprintno_such_key:\n\t\t\t\t\terr = fs.SkipField(tok)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto wantedvalue\n\t\t\t}\n\t\t}\n\t}\n\nhandle_Group:\n\n\t/* handler: uj.Group type=string kind=string quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\tuj.Group = string(string(outBuf))\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Username:\n\n\t/* handler: uj.Username type=string kind=string quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\tuj.Username = string(string(outBuf))\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Location:\n\n\t/* handler: uj.Location type=string kind=string quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\tuj.Location = string(string(outBuf))\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Timestamp:\n\n\t/* handler: uj.Timestamp type=int64 kind=int64 quoted=false*/\n\n\t{\n\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int64\", tok))\n\t\t}\n\t}\n\n\t{\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\tif err != nil {\n\t\t\t\treturn fs.WrapErr(err)\n\t\t\t}\n\n\t\t\tuj.Timestamp = int64(tval)\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_WifiFingerprint:\n\n\t/* handler: uj.WifiFingerprint type=[]find.Router kind=slice quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.WifiFingerprint = nil\n\t\t} else {\n\n\t\t\tuj.WifiFingerprint = make([]Router, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar tmp_uj__WifiFingerprint Router\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_brace {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: tmp_uj__WifiFingerprint type=find.Router kind=struct quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t\terr = tmp_uj__WifiFingerprint.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t}\n\n\t\t\t\tuj.WifiFingerprint = append(uj.WifiFingerprint, tmp_uj__WifiFingerprint)\n\t\t\t\twantVal = false\n\t\t\t}\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nwantedvalue:\n\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\nwrongtokenerror:\n\treturn fs.WrapErr(fmt.Errorf(\"ffjson: wanted token: %v, but got token: %v output=%s\", wantedTok, tok, fs.Output.String()))\ntokerror:\n\tif fs.BigError != nil {\n\t\treturn fs.WrapErr(fs.BigError)\n\t}\n\terr = fs.Error.ToError()\n\tif err != nil {\n\t\treturn fs.WrapErr(err)\n\t}\n\tpanic(\"ffjson-generated: unreachable, please report bug.\")\ndone:\n\treturn nil\n}\n\nfunc (mj *Router) MarshalJSON() ([]byte, error) {\n\tvar buf fflib.Buffer\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn buf.Bytes(), nil\n\t}\n\terr := mj.MarshalJSONBuf(&buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\nfunc (mj *Router) MarshalJSONBuf(buf fflib.EncodingBuffer) error {\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn nil\n\t}\n\tvar err error\n\tvar obj []byte\n\t_ = obj\n\t_ = err\n\tbuf.WriteString(`{\"mac\":`)\n\tfflib.WriteJsonString(buf, string(mj.Mac))\n\tbuf.WriteString(`,\"rssi\":`)\n\tfflib.FormatBits2(buf, uint64(mj.Rssi), 10, mj.Rssi < 0)\n\tbuf.WriteByte('}')\n\treturn nil\n}\n\nconst (\n\tffj_t_Routerbase = iota\n\tffj_t_Routerno_such_key\n\n\tffj_t_Router_Mac\n\n\tffj_t_Router_Rssi\n)\n\nvar ffj_key_Router_Mac = []byte(\"mac\")\n\nvar ffj_key_Router_Rssi = []byte(\"rssi\")\n\nfunc (uj *Router) UnmarshalJSON(input []byte) error {\n\tfs := fflib.NewFFLexer(input)\n\treturn uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)\n}\n\nfunc (uj *Router) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {\n\tvar err error = nil\n\tcurrentKey := ffj_t_Routerbase\n\t_ = currentKey\n\ttok := fflib.FFTok_init\n\twantedTok := fflib.FFTok_init\n\nmainparse:\n\tfor {\n\t\ttok = fs.Scan()\n\t\t//\tprintln(fmt.Sprintf(\"debug: tok: %v  state: %v\", tok, state))\n\t\tif tok == fflib.FFTok_error {\n\t\t\tgoto tokerror\n\t\t}\n\n\t\tswitch state {\n\n\t\tcase fflib.FFParse_map_start:\n\t\t\tif tok != fflib.FFTok_left_bracket {\n\t\t\t\twantedTok = fflib.FFTok_left_bracket\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_key\n\t\t\tcontinue\n\n\t\tcase fflib.FFParse_after_value:\n\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\tstate = fflib.FFParse_want_key\n\t\t\t} else if tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t} else {\n\t\t\t\twantedTok = fflib.FFTok_comma\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_key:\n\t\t\t// json {} ended. goto exit. woo.\n\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t}\n\t\t\tif tok != fflib.FFTok_string {\n\t\t\t\twantedTok = fflib.FFTok_string\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\t\tkn := fs.Output.Bytes()\n\t\t\tif len(kn) <= 0 {\n\t\t\t\t// \"\" case. hrm.\n\t\t\t\tcurrentKey = ffj_t_Routerno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t} else {\n\t\t\t\tswitch kn[0] {\n\n\t\t\t\tcase 'm':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Router_Mac, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Router_Mac\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'r':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_Router_Rssi, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_Router_Rssi\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_Router_Rssi, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Router_Rssi\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_Router_Mac, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_Router_Mac\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tcurrentKey = ffj_t_Routerno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_colon:\n\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\twantedTok = fflib.FFTok_colon\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_value\n\t\t\tcontinue\n\t\tcase fflib.FFParse_want_value:\n\n\t\t\tif tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {\n\t\t\t\tswitch currentKey {\n\n\t\t\t\tcase ffj_t_Router_Mac:\n\t\t\t\t\tgoto handle_Mac\n\n\t\t\t\tcase ffj_t_Router_Rssi:\n\t\t\t\t\tgoto handle_Rssi\n\n\t\t\t\tcase ffj_t_Routerno_such_key:\n\t\t\t\t\terr = fs.SkipField(tok)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto wantedvalue\n\t\t\t}\n\t\t}\n\t}\n\nhandle_Mac:\n\n\t/* handler: uj.Mac type=string kind=string quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\tuj.Mac = string(string(outBuf))\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Rssi:\n\n\t/* handler: uj.Rssi type=int kind=int quoted=false*/\n\n\t{\n\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t}\n\t}\n\n\t{\n\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\n\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\tif err != nil {\n\t\t\t\treturn fs.WrapErr(err)\n\t\t\t}\n\n\t\t\tuj.Rssi = int(tval)\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nwantedvalue:\n\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\nwrongtokenerror:\n\treturn fs.WrapErr(fmt.Errorf(\"ffjson: wanted token: %v, but got token: %v output=%s\", wantedTok, tok, fs.Output.String()))\ntokerror:\n\tif fs.BigError != nil {\n\t\treturn fs.WrapErr(fs.BigError)\n\t}\n\terr = fs.Error.ToError()\n\tif err != nil {\n\t\treturn fs.WrapErr(err)\n\t}\n\tpanic(\"ffjson-generated: unreachable, please report bug.\")\ndone:\n\treturn nil\n}\n"
        },
        {
          "name": "fingerprint_test.go",
          "type": "blob",
          "size": 16.9794921875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tInit(ioutil.Discard, ioutil.Discard, ioutil.Discard, ioutil.Discard, ioutil.Discard)\n}\n\nfunc TestTrackFingerprintRoute(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\n\trouter := gin.New()\n\trouter.POST(\"/foo\", trackFingerprintPOST)\n\n\treq, _ := http.NewRequest(\"POST\", \"/foo\", bytes.NewBufferString(jsonTest))\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\n\tassert.Equal(t, strings.Contains(resp.Body.String(), \"Current location: zakhome floor 2 office\"), true)\n}\n\nfunc BenchmarkTrackFingerprintRoute(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"testdb\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\n\trouter := gin.New()\n\trouter.POST(\"/foo\", trackFingerprintPOST)\n\n\tfor i := 0; i < b.N; i++ {\n\t\treq, _ := http.NewRequest(\"POST\", \"/foo\", bytes.NewBufferString(jsonTest))\n\t\tresp := httptest.NewRecorder()\n\t\trouter.ServeHTTP(resp, req)\n\t}\n}\n\nfunc BenchmarkLearnFingerprintRoute(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"testdb\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\n\trouter := gin.New()\n\trouter.POST(\"/foo\", learnFingerprintPOST)\n\n\tfor i := 0; i < b.N; i++ {\n\t\treq, _ := http.NewRequest(\"POST\", \"/foo\", bytes.NewBufferString(jsonTest))\n\t\tresp := httptest.NewRecorder()\n\t\trouter.ServeHTTP(resp, req)\n\t}\n}\n\n// Example1 measures compressed vs uncompressed size\nfunc TestCompression(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tbFingerprint := dumpFingerprint(res)\n\tloadedFingerprint := loadFingerprint(bFingerprint)\n\tdumped, _ := json.Marshal(loadedFingerprint)\n\tbFingerprint2 := dumpFingerprint(loadedFingerprint)\n\tisGood := 100*len(dumped)/len(bFingerprint2) == 244 || 100*len(dumped)/len(bFingerprint2) == 246\n\tassert.Equal(t, isGood, true)\n}\n\nfunc BenchmarkPutFingerprintInDatabase(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"testdbfoo\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tos.Remove(path.Join(RuntimeArgs.SourcePath, \"testdbfoo.db\"))\n\tputFingerprintIntoDatabase(res, \"fingerprints\") // create it for the first time\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tputFingerprintIntoDatabase(res, \"fingerprints\")\n\t}\n}\n\nfunc BenchmarkGetFingerprintInDatabase(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tgroup := \"testdb\"\n\t\tdb, _ := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\t\tdb.View(func(tx *bolt.Tx) error {\n\t\t\t// Assume bucket exists and has keys\n\t\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\t\tc := b.Cursor()\n\t\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\t\tloadFingerprint(v)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tdb.Close()\n\t}\n}\n\nfunc BenchmarkLoadFingerprint(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tbFingerprint, _ := res.MarshalJSON()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tres := Fingerprint{}\n\t\tres.UnmarshalJSON(bFingerprint)\n\t}\n}\n\nfunc BenchmarkLoadCompressedFingerprint(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tbFingerprintUncompressed, _ := res.MarshalJSON()\n\tbFingerprint := compressByte(bFingerprintUncompressed)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tres := Fingerprint{}\n\t\tdecompressed := decompressByte(bFingerprint)\n\t\tres.UnmarshalJSON(decompressed)\n\t}\n}\n\nfunc BenchmarkDumpFingerprint(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tres.MarshalJSON()\n\t}\n}\n\nfunc BenchmarkDumpCompressedFingerprint(b *testing.B) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tdumped, _ := res.MarshalJSON()\n\t\tcompressByte(dumped)\n\t}\n}\n\nfunc TestLearnFingerprintPOST(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\n\trouter := gin.New()\n\trouter.POST(\"/foo\", learnFingerprintPOST)\n\n\treq, _ := http.NewRequest(\"POST\", \"/foo\", bytes.NewBuffer([]byte(jsonTest)))\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Inserted fingerprint containing 18 APs for zack (find) at zakhome floor 2 office\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, response, strings.TrimSpace(resp.Body.String()))\n}\n\nfunc TestLearnFingerprint(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tmessage, _ := learnFingerprint(res)\n\tassert.Equal(t, strings.TrimSpace(message), \"Inserted fingerprint containing 18 APs for zack (find) at zakhome floor 2 office\")\n}\n\nfunc TestTrackFingerprintPOST(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\n\trouter := gin.New()\n\trouter.POST(\"/foo\", learnFingerprintPOST)\n\n\treq, _ := http.NewRequest(\"POST\", \"/foo\", bytes.NewBuffer([]byte(jsonTest)))\n\tresp := httptest.NewRecorder()\n\trouter.ServeHTTP(resp, req)\n\tresponse := \"{\\\"message\\\":\\\"Inserted fingerprint containing 18 APs for zack (find) at zakhome floor 2 office\\\",\\\"success\\\":true}\"\n\tassert.Equal(t, response, strings.TrimSpace(resp.Body.String()))\n}\n\nfunc TestTrackFingerprintFunction(t *testing.T) {\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"Find\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tres := Fingerprint{}\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\tmessage, _, _, _, _, _ := trackFingerprint(res)\n\tassert.Equal(t, strings.TrimSpace(message), \"Current location: zakhome floor 2 office\")\n}\n\n//\n// func BenchmarkParseDate(b *testing.B) {\n// \tfor i := 0; i < b.N; i++ {\n// \t\tParseDate(\"02/17/2016 3:05pm\")\n// \t}\n// }\n"
        },
        {
          "name": "macs.json",
          "type": "blob",
          "size": 0.3837890625,
          "content": "{\n\"ac:86:74:6b:9b:80\":true,\n\"ac:86:74:6b:9b:81\":true,\n\"ac:86:74:6b:9b:82\":true,\n\"ac:86:74:6b:9b:83\":true,\n\"ac:86:74:6b:9b:84\":true,\n\"ac:86:74:6b:9b:60\":true,\n\"ac:86:74:6b:9b:61\":true,\n\"ac:86:74:6b:9b:62\":true,\n\"ac:86:74:6b:9b:63\":true,\n\"ac:86:74:6b:9b:a0\":true,\n\"ac:86:74:6b:9b:a1\":true,\n\"ac:86:74:6b:9b:a2\":true,\n\"ac:86:74:6b:9b:a3\":true,\n\"ac:86:74:6b:9b:a4\":true,\n\"c4:0a:cb:b3:d6:0b\":true\n}\n"
        },
        {
          "name": "mqtt.go",
          "type": "blob",
          "size": 6.6279296875,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// mqtt.go contains functions for performing MQTT transactions.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/gin-gonic/gin\"\n\n\tMQTT \"github.com/schollz/org.eclipse.paho.mqtt.golang\"\n)\n\nvar adminClient *MQTT.Client\n\nfunc setupMqtt() {\n\tserver := \"tcp://\" + RuntimeArgs.MqttServer\n        opts := MQTT.NewClientOptions()\n\n        if RuntimeArgs.MqttExisting {\n                opts.AddBroker(server).SetClientID(RandStringBytesMaskImprSrc(5)).SetCleanSession(true)\n        } else {\n                updateMosquittoConfig()\n                opts.AddBroker(server).SetClientID(RandStringBytesMaskImprSrc(5)).SetUsername(RuntimeArgs.MqttAdmin).SetPassword(RuntimeArgs.MqttAdminPassword).SetCleanSession(true)\n        }\n\n\topts.OnConnect = func(c *MQTT.Client) {\n\t\tif token := c.Subscribe(\"#\", 1, messageReceived); token.Wait() && token.Error() != nil {\n\t\t\tpanic(token.Error())\n\t\t}\n\t}\n\n\tadminClient = MQTT.NewClient(opts)\n\n\tif token := adminClient.Connect(); token.Wait() && token.Error() != nil {\n\t\tDebug.Println(token.Error())\n\t}\n\tDebug.Println(\"Finished setup\")\n}\n\nfunc putMQTT(c *gin.Context) {\n\tgroup := strings.ToLower(c.DefaultQuery(\"group\", \"noneasdf\"))\n\treset := strings.ToLower(c.DefaultQuery(\"reset\", \"noneasdf\"))\n\tif !RuntimeArgs.Mqtt {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"MQTT is not enabled on this server\"})\n\t\treturn\n\t}\n\tif group != \"noneasdf\" {\n\t\tpassword, err := getMQTT(group)\n\t\tif len(password) == 0 || reset == \"true\" {\n\t\t\tpassword, err = setMQTT(group)\n\t\t\tif err == nil {\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"You have successfuly set your password.\", \"password\": password})\n\t\t\t\tupdateMosquittoConfig()\n\t\t\t} else {\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\t}\n\t\t} else {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Your password exists.\", \"password\": password})\n\t\t}\n\t} else {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Usage: PUT /mqtt?group=X or reset using PUT /mqtt?group=X&reset=true\"})\n\t}\n}\n\nfunc setMQTT(group string) (string, error) {\n\tpassword := RandStringBytesMaskImprSrc(6)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.Cwd, \"global.db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"mqtt\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t}\n\n\t\terr = bucket.Put([]byte(group), []byte(password))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\t\treturn err\n\t})\n\treturn password, err\n}\n\nfunc getMQTT(group string) (string, error) {\n\tpassword := \"\"\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.Cwd, \"global.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"mqtt\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(group))\n\t\tpassword = string(v)\n\t\treturn nil\n\t})\n\treturn password, nil\n}\n\nfunc updateMosquittoConfig() {\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.Cwd, \"global.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\tacl := \"user \" + RuntimeArgs.MqttAdmin + \"\\ntopic readwrite #\\n\\n\"\n\tpasswd := \"admin:\" + RuntimeArgs.MqttAdminPassword + \"\\n\"\n\tconf := \"allow_anonymous false\\n\\nacl_file \" + path.Join(RuntimeArgs.Cwd, \"mosquitto\") + \"/acl\\n\\npassword_file \" + path.Join(RuntimeArgs.Cwd, \"mosquitto\") + \"/passwd\"\n\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"mqtt\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"No such bucket yet\")\n\t\t}\n\n\t\tc := b.Cursor()\n\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tgroup := string(k)\n\t\t\tpass := string(v)\n\t\t\tacl = acl + \"user \" + group + \"\\ntopic readwrite \" + group + \"/#\\n\\n\"\n\t\t\tpasswd = passwd + group + \":\" + pass + \"\\n\"\n\t\t}\n\n\t\treturn nil\n\t})\n\tos.MkdirAll(path.Join(RuntimeArgs.Cwd, \"mosquitto\"), 0644)\n\tioutil.WriteFile(path.Join(RuntimeArgs.Cwd, \"mosquitto/acl\"), []byte(acl), 0644)\n\tioutil.WriteFile(path.Join(RuntimeArgs.Cwd, \"mosquitto/passwd\"), []byte(passwd), 0644)\n\tioutil.WriteFile(path.Join(RuntimeArgs.Cwd, \"mosquitto/mosquitto.conf\"), []byte(conf), 0644)\n\n\tcmd := \"mosquitto_passwd\"\n\targs := []string{\"-U\", path.Join(RuntimeArgs.Cwd, \"mosquitto/passwd\")}\n\tif err := exec.Command(cmd, args...).Run(); err != nil {\n\t\tWarning.Println(err)\n\t}\n\tcmd = \"kill\"\n\targs = []string{\"-HUP\", RuntimeArgs.MosquittoPID}\n\tif err = exec.Command(cmd, args...).Run(); err != nil {\n\t\tWarning.Println(err)\n\t}\n}\n\nfunc sendMQTTLocation(message string, group string, user string) error {\n\tpubTopic := strings.Join([]string{group, \"/location/\", user}, \"\")\n\n\tif token := adminClient.Publish(pubTopic, 1, false, message); token.Wait() && token.Error() != nil {\n\t\treturn fmt.Errorf(\"Failed to send message\")\n\t}\n\treturn nil\n}\n\nfunc messageReceived(client *MQTT.Client, msg MQTT.Message) {\n\tjsonFingerprint, route, err := mqttBuildFingerprint(msg.Topic(), msg.Payload())\n\tif err != nil {\n\t\treturn\n\t}\n\tDebug.Println(\"Got valid MQTT request for group \" + jsonFingerprint.Group + \", user \" + jsonFingerprint.Username)\n\tif route == \"track\" {\n\t\ttrackFingerprint(jsonFingerprint)\n\t} else {\n\t\tlearnFingerprint(jsonFingerprint)\n\t}\n}\n\nfunc mqttBuildFingerprint(topic string, message []byte) (jsonFingerprint Fingerprint, route string, err error) {\n\terr = nil\n\troute = \"track\"\n\ttopics := strings.Split(strings.ToLower(topic), \"/\")\n\tjsonFingerprint.Location = \"\"\n\tif len(topics) < 3 || (topics[1] != \"track\" && topics[1] != \"learn\") {\n\t\terr = fmt.Errorf(\"Must define track or learn\")\n\t\treturn\n\t}\n\troute = topics[1]\n\tif route == \"track\" && len(topics) != 3 {\n\t\terr = fmt.Errorf(\"Track needs a user name\")\n\t\treturn\n\t}\n\tif route == \"learn\" {\n\t\tif len(topics) != 4 {\n\t\t\terr = fmt.Errorf(\"Track needs a user name and location\")\n\t\t\treturn\n\t\t} else {\n\t\t\tjsonFingerprint.Location = topics[3]\n\t\t}\n\t}\n\tjsonFingerprint.Group = topics[0]\n\tjsonFingerprint.Username = topics[2]\n\trouters := []Router{}\n\tfor i := 0; i < len(message); i += 14 {\n\t\tif (i + 14) > len(message) {\n\t\t\tbreak\n\t\t}\n\t\tmac := string(message[i:i+2]) + \":\" + string(message[i+2:i+4]) + \":\" + string(message[i+4:i+6]) + \":\" + string(message[i+6:i+8]) + \":\" + string(message[i+8:i+10]) + \":\" + string(message[i+10:i+12])\n\t\tval, _ := strconv.Atoi(string(message[i+12 : i+14]))\n\t\trssi := -1 * val\n\t\trouters = append(routers, Router{Mac: mac, Rssi: rssi})\n\t}\n\tjsonFingerprint.WifiFingerprint = routers\n\treturn\n}\n"
        },
        {
          "name": "mqtt_test.go",
          "type": "blob",
          "size": 1.9892578125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestProcessMQTTFingerprintTrack(t *testing.T) {\n\tfingerprint, _, _ := mqttBuildFingerprint(\"group/track/user\", []byte(\"002369d4479f7380377387563666001a1e46cd1178001a1e46cd1075a063912b9e6556803773baf7d842\"))\n\tjson, _ := json.Marshal(fingerprint)\n\tassert.Equal(t, string(json), \"{\\\"group\\\":\\\"group\\\",\\\"username\\\":\\\"user\\\",\\\"location\\\":\\\"\\\",\\\"timestamp\\\":0,\\\"wifi-fingerprint\\\":[{\\\"mac\\\":\\\"00:23:69:d4:47:9f\\\",\\\"rssi\\\":-73},{\\\"mac\\\":\\\"80:37:73:87:56:36\\\",\\\"rssi\\\":-66},{\\\"mac\\\":\\\"00:1a:1e:46:cd:11\\\",\\\"rssi\\\":-78},{\\\"mac\\\":\\\"00:1a:1e:46:cd:10\\\",\\\"rssi\\\":-75},{\\\"mac\\\":\\\"a0:63:91:2b:9e:65\\\",\\\"rssi\\\":-56},{\\\"mac\\\":\\\"80:37:73:ba:f7:d8\\\",\\\"rssi\\\":-42}]}\")\n}\n\nfunc TestProcessMQTTFingerprintTrackError(t *testing.T) {\n\tfingerprint, _, _ := mqttBuildFingerprint(\"group/track/user\", []byte(\"002369d4479f7380377387563666001a1e46cd1178001a1e46cd1075a063912b9e6556803773ba\"))\n\tjson, _ := json.Marshal(fingerprint)\n\tassert.Equal(t, string(json), \"{\\\"group\\\":\\\"group\\\",\\\"username\\\":\\\"user\\\",\\\"location\\\":\\\"\\\",\\\"timestamp\\\":0,\\\"wifi-fingerprint\\\":[{\\\"mac\\\":\\\"00:23:69:d4:47:9f\\\",\\\"rssi\\\":-73},{\\\"mac\\\":\\\"80:37:73:87:56:36\\\",\\\"rssi\\\":-66},{\\\"mac\\\":\\\"00:1a:1e:46:cd:11\\\",\\\"rssi\\\":-78},{\\\"mac\\\":\\\"00:1a:1e:46:cd:10\\\",\\\"rssi\\\":-75},{\\\"mac\\\":\\\"a0:63:91:2b:9e:65\\\",\\\"rssi\\\":-56}]}\")\n}\n\nfunc TestProcessMQTTFingerprintLearn(t *testing.T) {\n\tfingerprint, _, _ := mqttBuildFingerprint(\"group/learn/user/location\", []byte(\"002369d4479f7380377387563666001a1e46cd1178001a1e46cd1075a063912b9e6556803773baf7d842\"))\n\tjson, _ := json.Marshal(fingerprint)\n\tassert.Equal(t, string(json), \"{\\\"group\\\":\\\"group\\\",\\\"username\\\":\\\"user\\\",\\\"location\\\":\\\"location\\\",\\\"timestamp\\\":0,\\\"wifi-fingerprint\\\":[{\\\"mac\\\":\\\"00:23:69:d4:47:9f\\\",\\\"rssi\\\":-73},{\\\"mac\\\":\\\"80:37:73:87:56:36\\\",\\\"rssi\\\":-66},{\\\"mac\\\":\\\"00:1a:1e:46:cd:11\\\",\\\"rssi\\\":-78},{\\\"mac\\\":\\\"00:1a:1e:46:cd:10\\\",\\\"rssi\\\":-75},{\\\"mac\\\":\\\"a0:63:91:2b:9e:65\\\",\\\"rssi\\\":-56},{\\\"mac\\\":\\\"80:37:73:ba:f7:d8\\\",\\\"rssi\\\":-42}]}\")\n}\n"
        },
        {
          "name": "network.go",
          "type": "blob",
          "size": 2.533203125,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// network.go contains structures and functions for creating networks from slices.\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n)\n\nfunc hasNetwork(network map[string]map[string]bool, macs []string) (string, bool) {\n\tfor n := range network {\n\t\tfor _, val := range macs {\n\t\t\tif network[n][val] {\n\t\t\t\treturn n, true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"none\", false\n}\n\nfunc buildNetwork(network map[string]map[string]bool, macs []string) map[string]map[string]bool {\n\tif len(network) == 0 {\n\t\tnetwork[\"0\"] = make(map[string]bool)\n\t\tfor _, val := range macs {\n\t\t\tnetwork[\"0\"][val] = true\n\t\t}\n\t\treturn network\n\t}\n\tnetworkName, inNetworkAlready := hasNetwork(network, macs)\n\tif inNetworkAlready {\n\t\tfor _, val := range macs {\n\t\t\tnetwork[networkName][val] = true\n\t\t}\n\n\t} else {\n\t\t// Iterate network to get new name\n\t\tcurVal := 0\n\t\tfor n := range network {\n\t\t\tnum, _ := strconv.Atoi(n)\n\t\t\tif num > curVal {\n\t\t\t\tcurVal = num\n\t\t\t}\n\t\t}\n\t\tcurVal++\n\t\tnetworkName := strconv.Itoa(curVal)\n\t\tnetwork[networkName] = make(map[string]bool)\n\t\tfor _, val := range macs {\n\t\t\tnetwork[networkName][val] = true\n\t\t}\n\t}\n\treturn network\n}\n\nfunc mergeNetwork(network map[string]map[string]bool) map[string]map[string]bool {\n\tfor {\n\t\tn, m, canMerge := hasMerge(network)\n\n\t\tif canMerge {\n\t\t\tfor k := range network[m] {\n\t\t\t\tnetwork[n][k] = true\n\t\t\t}\n\t\t\tdelete(network, m)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn network\n\n}\n\nfunc hasMerge(network map[string]map[string]bool) (string, string, bool) {\n\tfor n := range network {\n\t\tfor m := range network {\n\t\t\tif m != n {\n\t\t\t\tfor j := range network[n] {\n\t\t\t\t\tfor k := range network[m] {\n\t\t\t\t\t\tif j == k {\n\t\t\t\t\t\t\treturn n, m, true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"none\", \"none\", false\n}\n\nfunc dumpNetwork(network map[string]map[string]bool) []byte {\n\tjsonByte, _ := json.Marshal(network)\n\treturn jsonByte\n}\n\nfunc loadNetwork(jsonByte []byte) map[string]map[string]bool {\n\tres2 := make(map[string]map[string]bool)\n\tjson.Unmarshal(jsonByte, &res2)\n\treturn res2\n}\n\n// network := make(map[string]map[string]bool)\n// macs := []string{\"test\", \"test2\", \"test3\", \"test4\"}\n// fmt.Println(buildNetwork(network, macs))\n// macs = []string{\"test6\", \"test5\", \"test7\"}\n// fmt.Println(buildNetwork(network, macs))\n// macs = []string{\"test6\", \"test9\", \"test10\"}\n// fmt.Println(buildNetwork(network, macs))\n// fmt.Println(mergeNetwork(network))\n// n2 := dumpNetwork(network)\n// fmt.Println(string(n2))\n// n2a := loadNetwork(n2)\n// fmt.Println(n2a)\n"
        },
        {
          "name": "network_test.go",
          "type": "blob",
          "size": 0.9921875,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBuildNetwork(t *testing.T) {\n\tnewNetwork := make(map[string]map[string]bool)\n\tnewNetwork = buildNetwork(newNetwork, []string{\"pie\", \"ice cream\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"pie\", \"cocolate syrup\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"orange juice\", \"water\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"water\", \"coffee\"})\n\tassert.Equal(t, newNetwork[\"0\"], map[string]bool{\"ice cream\": true, \"cocolate syrup\": true, \"pie\": true})\n}\n\nfunc TestHasNetwork(t *testing.T) {\n\tnewNetwork := make(map[string]map[string]bool)\n\tnewNetwork = buildNetwork(newNetwork, []string{\"pie\", \"ice cream\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"pie\", \"cocolate syrup\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"orange juice\", \"water\"})\n\tnewNetwork = buildNetwork(newNetwork, []string{\"water\", \"coffee\"})\n\tnetwork, _ := hasNetwork(newNetwork, []string{\"water\"})\n\tassert.Equal(t, network, \"1\")\n}\n"
        },
        {
          "name": "parameters.go",
          "type": "blob",
          "size": 11.7021484375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// parameters.go contains structures and functions for setting and getting Naive-Bayes parameters.\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// PersistentParameters are not reloaded each time\ntype PersistentParameters struct {\n\tNetworkRenamed map[string][]string\n}\n\n// PriorParameters contains the network-specific bayesian priors and Mac frequency, as well as special variables\ntype PriorParameters struct {\n\tP        map[string]map[string][]float32 // standard P\n\tNP       map[string]map[string][]float32 // standard nP\n\tMacFreq  map[string]map[string]float32   // Frequency of a mac in a certain location\n\tNMacFreq map[string]map[string]float32   // Frequency of a mac, in everywhere BUT a certain location\n\tSpecial  map[string]float64\n}\n\n// ResultsParameters contains the information about the accuracy from crossValidation\ntype ResultsParameters struct {\n\tAccuracy         map[string]int            // accuracy measurement for a given location\n\tTotalLocations   map[string]int            // number of locations\n\tCorrectLocations map[string]int            // number of times guessed correctly\n\tGuess            map[string]map[string]int // correct -> guess -> times\n}\n\n// FullParameters is the full parameter set for a given group\ntype FullParameters struct {\n\tNetworkMacs    map[string]map[string]bool // map of networks and then the associated macs in each\n\tNetworkLocs    map[string]map[string]bool // map of the networks, and then the associated locations in each\n\tMacVariability map[string]float32         // variability of macs\n\tMacCount       map[string]int             // number of each mac\n\tMacCountByLoc  map[string]map[string]int  // number of each mac, by location\n\tUniqueLocs     []string\n\tUniqueMacs     []string\n\tPriors         map[string]PriorParameters   // generate priors for each network\n\tResults        map[string]ResultsParameters // generate priors for each network\n\tLoaded         bool                         // flag to determine if parameters have been loaded\n}\n\n// NewFullParameters generates a blank FullParameters\nfunc NewFullParameters() *FullParameters {\n\treturn &FullParameters{\n\t\tNetworkMacs:    make(map[string]map[string]bool),\n\t\tNetworkLocs:    make(map[string]map[string]bool),\n\t\tMacCount:       make(map[string]int),\n\t\tMacCountByLoc:  make(map[string]map[string]int),\n\t\tUniqueMacs:     []string{},\n\t\tUniqueLocs:     []string{},\n\t\tPriors:         make(map[string]PriorParameters),\n\t\tMacVariability: make(map[string]float32),\n\t\tResults:        make(map[string]ResultsParameters),\n\t\tLoaded:         false,\n\t}\n}\n\n// NewPriorParameters generates a blank PriorParameters\nfunc NewPriorParameters() *PriorParameters {\n\treturn &PriorParameters{\n\t\tP:        make(map[string]map[string][]float32),\n\t\tNP:       make(map[string]map[string][]float32),\n\t\tMacFreq:  make(map[string]map[string]float32),\n\t\tNMacFreq: make(map[string]map[string]float32),\n\t\tSpecial:  make(map[string]float64),\n\t}\n}\n\n// NewResultsParameters generates a blank ResultsParameters\nfunc NewResultsParameters() *ResultsParameters {\n\treturn &ResultsParameters{\n\t\tAccuracy:         make(map[string]int),\n\t\tTotalLocations:   make(map[string]int),\n\t\tCorrectLocations: make(map[string]int),\n\t\tGuess:            make(map[string]map[string]int),\n\t}\n}\n\n// NewPersistentParameters returns the peristent parameters initialization\nfunc NewPersistentParameters() *PersistentParameters {\n\treturn &PersistentParameters{\n\t\tNetworkRenamed: make(map[string][]string),\n\t}\n}\n\nfunc dumpParameters(res FullParameters) []byte {\n\tjsonByte, _ := res.MarshalJSON()\n\treturn compressByte(jsonByte)\n}\n\nfunc loadParameters(jsonByte []byte) FullParameters {\n\tvar res2 FullParameters\n\tres2.UnmarshalJSON(decompressByte(jsonByte))\n\treturn res2\n}\n\nfunc saveParameters(group string, res FullParameters) error {\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err2 := tx.CreateBucketIfNotExists([]byte(\"resources\"))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err2)\n\t\t}\n\n\t\terr2 = bucket.Put([]byte(\"fullParameters\"), dumpParameters(res))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err2)\n\t\t}\n\t\treturn err2\n\t})\n\treturn err\n}\n\nfunc openParameters(group string) (FullParameters, error) {\n\tpsCached, ok := getPsCache(group)\n\tif ok {\n\t\treturn psCached, nil\n\t}\n\n\tvar ps = *NewFullParameters()\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"fullParameters\"))\n\t\tps = loadParameters(v)\n\t\treturn nil\n\t})\n\n\tgo setPsCache(group, ps)\n\treturn ps, err\n}\n\nfunc openPersistentParameters(group string) (PersistentParameters, error) {\n\tvar persistentPs = *NewPersistentParameters()\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"persistentParameters\"))\n\t\tjson.Unmarshal(v, &persistentPs)\n\t\treturn nil\n\t})\n\treturn persistentPs, err\n}\n\nfunc savePersistentParameters(group string, res PersistentParameters) error {\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err2 := tx.CreateBucketIfNotExists([]byte(\"resources\"))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t}\n\n\t\tjsonByte, _ := json.Marshal(res)\n\t\terr2 = bucket.Put([]byte(\"persistentParameters\"), jsonByte)\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\t\treturn err2\n\t})\n\tDebug.Println(\"Saved\")\n\treturn err\n}\n\nfunc getParameters(group string, ps *FullParameters, fingerprintsInMemory map[string]Fingerprint, fingerprintsOrdering []string) {\n\tpersistentPs, err := openPersistentParameters(group)\n\tps.NetworkMacs = make(map[string]map[string]bool)\n\tps.NetworkLocs = make(map[string]map[string]bool)\n\tps.UniqueMacs = []string{}\n\tps.UniqueLocs = []string{}\n\tps.MacCount = make(map[string]int)\n\tps.MacCountByLoc = make(map[string]map[string]int)\n\tps.Loaded = true\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Get all parameters that don't need a network graph\n\tfor _, v1 := range fingerprintsOrdering {\n\t\tv2 := fingerprintsInMemory[v1]\n\n\t\t// unique locs\n\t\tif !stringInSlice(v2.Location, ps.UniqueLocs) {\n\t\t\tps.UniqueLocs = append(ps.UniqueLocs, v2.Location)\n\t\t}\n\n\t\t// mac by location count\n\t\tif _, ok := ps.MacCountByLoc[v2.Location]; !ok {\n\t\t\tps.MacCountByLoc[v2.Location] = make(map[string]int)\n\t\t}\n\n\t\t// building network\n\t\tmacs := []string{}\n\n\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t// building network\n\t\t\tmacs = append(macs, router.Mac)\n\n\t\t\t// unique macs\n\t\t\tif !stringInSlice(router.Mac, ps.UniqueMacs) {\n\t\t\t\tps.UniqueMacs = append(ps.UniqueMacs, router.Mac)\n\t\t\t}\n\n\t\t\t// mac count\n\t\t\tif _, ok := ps.MacCount[router.Mac]; !ok {\n\t\t\t\tps.MacCount[router.Mac] = 0\n\t\t\t}\n\t\t\tps.MacCount[router.Mac]++\n\n\t\t\t// mac by location count\n\t\t\tif _, ok := ps.MacCountByLoc[v2.Location][router.Mac]; !ok {\n\t\t\t\tps.MacCountByLoc[v2.Location][router.Mac] = 0\n\t\t\t}\n\t\t\tps.MacCountByLoc[v2.Location][router.Mac]++\n\t\t}\n\n\t\t// building network\n\t\tps.NetworkMacs = buildNetwork(ps.NetworkMacs, macs)\n\t}\n\n\tps.NetworkMacs = mergeNetwork(ps.NetworkMacs)\n\n\t// Rename the NetworkMacs\n\tif len(persistentPs.NetworkRenamed) > 0 {\n\t\tnewNames := []string{}\n\t\tfor k := range persistentPs.NetworkRenamed {\n\t\t\tnewNames = append(newNames, k)\n\t\t}\n\t\tfor n := range ps.NetworkMacs {\n\t\t\trenamed := false\n\t\t\tfor mac := range ps.NetworkMacs[n] {\n\t\t\t\tfor renamedN := range persistentPs.NetworkRenamed {\n\t\t\t\t\tif stringInSlice(mac, persistentPs.NetworkRenamed[renamedN]) && !stringInSlice(n, newNames) {\n\t\t\t\t\t\tps.NetworkMacs[renamedN] = make(map[string]bool)\n\t\t\t\t\t\tfor k, v := range ps.NetworkMacs[n] {\n\t\t\t\t\t\t\tps.NetworkMacs[renamedN][k] = v\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete(ps.NetworkMacs, n)\n\t\t\t\t\t\trenamed = true\n\t\t\t\t\t}\n\t\t\t\t\tif renamed {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif renamed {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the locations for each graph (Has to have network built first)\n\tfor _, v1 := range fingerprintsOrdering {\n\t\tv2 := fingerprintsInMemory[v1]\n\t\tmacs := []string{}\n\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\tmacs = append(macs, router.Mac)\n\t\t}\n\t\tnetworkName, inNetwork := hasNetwork(ps.NetworkMacs, macs)\n\t\tif inNetwork {\n\t\t\tif _, ok := ps.NetworkLocs[networkName]; !ok {\n\t\t\t\tps.NetworkLocs[networkName] = make(map[string]bool)\n\t\t\t}\n\t\t\tif _, ok := ps.NetworkLocs[networkName][v2.Location]; !ok {\n\t\t\t\tps.NetworkLocs[networkName][v2.Location] = true\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc getMixinOverride(group string) (float64, error) {\n\tgroup = strings.ToLower(group)\n\toverride := float64(-1)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tdefer db.Close()\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"mixinOverride\"))\n\t\tif len(v) == 0 {\n\t\t\treturn fmt.Errorf(\"No mixin override\")\n\t\t}\n\t\toverride, err = strconv.ParseFloat(string(v), 64)\n\t\treturn err\n\t})\n\treturn override, err\n}\n\nfunc getCutoffOverride(group string) (float64, error) {\n\tgroup = strings.ToLower(group)\n\toverride := float64(-1)\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tdefer db.Close()\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"cutoffOverride\"))\n\t\tif len(v) == 0 {\n\t\t\treturn fmt.Errorf(\"No mixin override\")\n\t\t}\n\t\toverride, err = strconv.ParseFloat(string(v), 64)\n\t\treturn err\n\t})\n\treturn override, err\n}\n\nfunc setMixinOverride(group string, mixin float64) error {\n\tif (mixin < 0 || mixin > 1) && mixin != -1 {\n\t\treturn fmt.Errorf(\"mixin must be between 0 and 1\")\n\t}\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tdefer db.Close()\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err2 := tx.CreateBucketIfNotExists([]byte(\"resources\"))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err2)\n\t\t}\n\n\t\terr2 = bucket.Put([]byte(\"mixinOverride\"), []byte(strconv.FormatFloat(mixin, 'E', -1, 64)))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err2)\n\t\t}\n\t\treturn err2\n\t})\n\treturn err\n}\n\nfunc setCutoffOverride(group string, cutoff float64) error {\n\tif (cutoff < 0 || cutoff > 1) && cutoff != -1 {\n\t\treturn fmt.Errorf(\"cutoff must be between 0 and 1\")\n\t}\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tdefer db.Close()\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err2 := tx.CreateBucketIfNotExists([]byte(\"resources\"))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err2)\n\t\t}\n\n\t\terr2 = bucket.Put([]byte(\"cutoffOverride\"), []byte(strconv.FormatFloat(cutoff, 'E', -1, 64)))\n\t\tif err2 != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err2)\n\t\t}\n\t\treturn err2\n\t})\n\treturn err\n}\n"
        },
        {
          "name": "parameters_ffjson.go",
          "type": "blob",
          "size": 76.7568359375,
          "content": "// DO NOT EDIT!\n// Code generated by ffjson <https://github.com/pquerna/ffjson>\n// source: parameters.go\n// DO NOT EDIT!\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\tfflib \"github.com/pquerna/ffjson/fflib/v1\"\n)\n\nfunc (mj *FullParameters) MarshalJSON() ([]byte, error) {\n\tvar buf fflib.Buffer\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn buf.Bytes(), nil\n\t}\n\terr := mj.MarshalJSONBuf(&buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\nfunc (mj *FullParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn nil\n\t}\n\tvar err error\n\tvar obj []byte\n\t_ = obj\n\t_ = err\n\tbuf.WriteString(`{\"NetworkMacs\":`)\n\t/* Falling back. type=map[string]map[string]bool kind=map */\n\terr = buf.Encode(mj.NetworkMacs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"NetworkLocs\":`)\n\t/* Falling back. type=map[string]map[string]bool kind=map */\n\terr = buf.Encode(mj.NetworkLocs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif mj.MacVariability == nil {\n\t\tbuf.WriteString(`,\"MacVariability\":null`)\n\t} else {\n\t\tbuf.WriteString(`,\"MacVariability\":{ `)\n\t\tfor key, value := range mj.MacVariability {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.AppendFloat(buf, float64(value), 'g', -1, 32)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tif mj.MacCount == nil {\n\t\tbuf.WriteString(`,\"MacCount\":null`)\n\t} else {\n\t\tbuf.WriteString(`,\"MacCount\":{ `)\n\t\tfor key, value := range mj.MacCount {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.FormatBits2(buf, uint64(value), 10, value < 0)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tbuf.WriteString(`,\"MacCountByLoc\":`)\n\t/* Falling back. type=map[string]map[string]int kind=map */\n\terr = buf.Encode(mj.MacCountByLoc)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"UniqueLocs\":`)\n\tif mj.UniqueLocs != nil {\n\t\tbuf.WriteString(`[`)\n\t\tfor i, v := range mj.UniqueLocs {\n\t\t\tif i != 0 {\n\t\t\t\tbuf.WriteString(`,`)\n\t\t\t}\n\t\t\tfflib.WriteJsonString(buf, string(v))\n\t\t}\n\t\tbuf.WriteString(`]`)\n\t} else {\n\t\tbuf.WriteString(`null`)\n\t}\n\tbuf.WriteString(`,\"UniqueMacs\":`)\n\tif mj.UniqueMacs != nil {\n\t\tbuf.WriteString(`[`)\n\t\tfor i, v := range mj.UniqueMacs {\n\t\t\tif i != 0 {\n\t\t\t\tbuf.WriteString(`,`)\n\t\t\t}\n\t\t\tfflib.WriteJsonString(buf, string(v))\n\t\t}\n\t\tbuf.WriteString(`]`)\n\t} else {\n\t\tbuf.WriteString(`null`)\n\t}\n\tbuf.WriteString(`,\"Priors\":`)\n\t/* Falling back. type=map[string]gofind.PriorParameters kind=map */\n\terr = buf.Encode(mj.Priors)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"Results\":`)\n\t/* Falling back. type=map[string]gofind.ResultsParameters kind=map */\n\terr = buf.Encode(mj.Results)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif mj.Loaded {\n\t\tbuf.WriteString(`,\"Loaded\":true`)\n\t} else {\n\t\tbuf.WriteString(`,\"Loaded\":false`)\n\t}\n\tbuf.WriteByte('}')\n\treturn nil\n}\n\nconst (\n\tffj_t_FullParametersbase = iota\n\tffj_t_FullParametersno_such_key\n\n\tffj_t_FullParameters_NetworkMacs\n\n\tffj_t_FullParameters_NetworkLocs\n\n\tffj_t_FullParameters_MacVariability\n\n\tffj_t_FullParameters_MacCount\n\n\tffj_t_FullParameters_MacCountByLoc\n\n\tffj_t_FullParameters_UniqueLocs\n\n\tffj_t_FullParameters_UniqueMacs\n\n\tffj_t_FullParameters_Priors\n\n\tffj_t_FullParameters_Results\n\n\tffj_t_FullParameters_Loaded\n)\n\nvar ffj_key_FullParameters_NetworkMacs = []byte(\"NetworkMacs\")\n\nvar ffj_key_FullParameters_NetworkLocs = []byte(\"NetworkLocs\")\n\nvar ffj_key_FullParameters_MacVariability = []byte(\"MacVariability\")\n\nvar ffj_key_FullParameters_MacCount = []byte(\"MacCount\")\n\nvar ffj_key_FullParameters_MacCountByLoc = []byte(\"MacCountByLoc\")\n\nvar ffj_key_FullParameters_UniqueLocs = []byte(\"UniqueLocs\")\n\nvar ffj_key_FullParameters_UniqueMacs = []byte(\"UniqueMacs\")\n\nvar ffj_key_FullParameters_Priors = []byte(\"Priors\")\n\nvar ffj_key_FullParameters_Results = []byte(\"Results\")\n\nvar ffj_key_FullParameters_Loaded = []byte(\"Loaded\")\n\nfunc (uj *FullParameters) UnmarshalJSON(input []byte) error {\n\tfs := fflib.NewFFLexer(input)\n\treturn uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)\n}\n\nfunc (uj *FullParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {\n\tvar err error = nil\n\tcurrentKey := ffj_t_FullParametersbase\n\t_ = currentKey\n\ttok := fflib.FFTok_init\n\twantedTok := fflib.FFTok_init\n\nmainparse:\n\tfor {\n\t\ttok = fs.Scan()\n\t\t//\tprintln(fmt.Sprintf(\"debug: tok: %v  state: %v\", tok, state))\n\t\tif tok == fflib.FFTok_error {\n\t\t\tgoto tokerror\n\t\t}\n\n\t\tswitch state {\n\n\t\tcase fflib.FFParse_map_start:\n\t\t\tif tok != fflib.FFTok_left_bracket {\n\t\t\t\twantedTok = fflib.FFTok_left_bracket\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_key\n\t\t\tcontinue\n\n\t\tcase fflib.FFParse_after_value:\n\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\tstate = fflib.FFParse_want_key\n\t\t\t} else if tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t} else {\n\t\t\t\twantedTok = fflib.FFTok_comma\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_key:\n\t\t\t// json {} ended. goto exit. woo.\n\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t}\n\t\t\tif tok != fflib.FFTok_string {\n\t\t\t\twantedTok = fflib.FFTok_string\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\t\tkn := fs.Output.Bytes()\n\t\t\tif len(kn) <= 0 {\n\t\t\t\t// \"\" case. hrm.\n\t\t\t\tcurrentKey = ffj_t_FullParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t} else {\n\t\t\t\tswitch kn[0] {\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_Loaded, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Loaded\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'M':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_MacVariability, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacVariability\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\n\t\t\t\t\t} else if bytes.Equal(ffj_key_FullParameters_MacCount, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacCount\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\n\t\t\t\t\t} else if bytes.Equal(ffj_key_FullParameters_MacCountByLoc, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacCountByLoc\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'N':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_NetworkMacs, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_NetworkMacs\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\n\t\t\t\t\t} else if bytes.Equal(ffj_key_FullParameters_NetworkLocs, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_NetworkLocs\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'P':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_Priors, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Priors\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_Results, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Results\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_FullParameters_UniqueLocs, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_UniqueLocs\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\n\t\t\t\t\t} else if bytes.Equal(ffj_key_FullParameters_UniqueMacs, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_FullParameters_UniqueMacs\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_FullParameters_Loaded, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Loaded\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_Results, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Results\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_Priors, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_Priors\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_UniqueMacs, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_UniqueMacs\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_UniqueLocs, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_UniqueLocs\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacCountByLoc, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacCountByLoc\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacCount, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacCount\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacVariability, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_MacVariability\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_NetworkLocs, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_NetworkLocs\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_FullParameters_NetworkMacs, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_FullParameters_NetworkMacs\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tcurrentKey = ffj_t_FullParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_colon:\n\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\twantedTok = fflib.FFTok_colon\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_value\n\t\t\tcontinue\n\t\tcase fflib.FFParse_want_value:\n\n\t\t\tif tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {\n\t\t\t\tswitch currentKey {\n\n\t\t\t\tcase ffj_t_FullParameters_NetworkMacs:\n\t\t\t\t\tgoto handle_NetworkMacs\n\n\t\t\t\tcase ffj_t_FullParameters_NetworkLocs:\n\t\t\t\t\tgoto handle_NetworkLocs\n\n\t\t\t\tcase ffj_t_FullParameters_MacVariability:\n\t\t\t\t\tgoto handle_MacVariability\n\n\t\t\t\tcase ffj_t_FullParameters_MacCount:\n\t\t\t\t\tgoto handle_MacCount\n\n\t\t\t\tcase ffj_t_FullParameters_MacCountByLoc:\n\t\t\t\t\tgoto handle_MacCountByLoc\n\n\t\t\t\tcase ffj_t_FullParameters_UniqueLocs:\n\t\t\t\t\tgoto handle_UniqueLocs\n\n\t\t\t\tcase ffj_t_FullParameters_UniqueMacs:\n\t\t\t\t\tgoto handle_UniqueMacs\n\n\t\t\t\tcase ffj_t_FullParameters_Priors:\n\t\t\t\t\tgoto handle_Priors\n\n\t\t\t\tcase ffj_t_FullParameters_Results:\n\t\t\t\t\tgoto handle_Results\n\n\t\t\t\tcase ffj_t_FullParameters_Loaded:\n\t\t\t\t\tgoto handle_Loaded\n\n\t\t\t\tcase ffj_t_FullParametersno_such_key:\n\t\t\t\t\terr = fs.SkipField(tok)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto wantedvalue\n\t\t\t}\n\t\t}\n\t}\n\nhandle_NetworkMacs:\n\n\t/* handler: uj.NetworkMacs type=map[string]map[string]bool kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.NetworkMacs = nil\n\t\t} else {\n\n\t\t\tuj.NetworkMacs = make(map[string]map[string]bool, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__NetworkMacs map[string]bool\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__NetworkMacs type=map[string]bool kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__NetworkMacs = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__NetworkMacs = make(map[string]bool, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__NetworkMacs bool\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__NetworkMacs type=bool kind=bool quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_bool && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for bool\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttmpb := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tif bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NetworkMacs = true\n\n\t\t\t\t\t\t\t\t\t} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NetworkMacs = false\n\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\terr = errors.New(\"unexpected bytes for true/false value\")\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__NetworkMacs[k] = tmp_tmp_uj__NetworkMacs\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.NetworkMacs[k] = tmp_uj__NetworkMacs\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_NetworkLocs:\n\n\t/* handler: uj.NetworkLocs type=map[string]map[string]bool kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.NetworkLocs = nil\n\t\t} else {\n\n\t\t\tuj.NetworkLocs = make(map[string]map[string]bool, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__NetworkLocs map[string]bool\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__NetworkLocs type=map[string]bool kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__NetworkLocs = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__NetworkLocs = make(map[string]bool, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__NetworkLocs bool\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__NetworkLocs type=bool kind=bool quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_bool && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for bool\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttmpb := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tif bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NetworkLocs = true\n\n\t\t\t\t\t\t\t\t\t} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NetworkLocs = false\n\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\terr = errors.New(\"unexpected bytes for true/false value\")\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__NetworkLocs[k] = tmp_tmp_uj__NetworkLocs\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.NetworkLocs[k] = tmp_uj__NetworkLocs\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_MacVariability:\n\n\t/* handler: uj.MacVariability type=map[string]float32 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.MacVariability = nil\n\t\t} else {\n\n\t\t\tuj.MacVariability = make(map[string]float32, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__MacVariability float32\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__MacVariability type=float32 kind=float32 quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float32\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__MacVariability = float32(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.MacVariability[k] = tmp_uj__MacVariability\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_MacCount:\n\n\t/* handler: uj.MacCount type=map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.MacCount = nil\n\t\t} else {\n\n\t\t\tuj.MacCount = make(map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__MacCount int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__MacCount type=int kind=int quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__MacCount = int(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.MacCount[k] = tmp_uj__MacCount\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_MacCountByLoc:\n\n\t/* handler: uj.MacCountByLoc type=map[string]map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.MacCountByLoc = nil\n\t\t} else {\n\n\t\t\tuj.MacCountByLoc = make(map[string]map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__MacCountByLoc map[string]int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__MacCountByLoc type=map[string]int kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__MacCountByLoc = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__MacCountByLoc = make(map[string]int, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__MacCountByLoc int\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__MacCountByLoc type=int kind=int quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__MacCountByLoc = int(tval)\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__MacCountByLoc[k] = tmp_tmp_uj__MacCountByLoc\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.MacCountByLoc[k] = tmp_uj__MacCountByLoc\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_UniqueLocs:\n\n\t/* handler: uj.UniqueLocs type=[]string kind=slice quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.UniqueLocs = nil\n\t\t} else {\n\n\t\t\tuj.UniqueLocs = make([]string, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar tmp_uj__UniqueLocs string\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_brace {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: tmp_uj__UniqueLocs type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\ttmp_uj__UniqueLocs = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.UniqueLocs = append(uj.UniqueLocs, tmp_uj__UniqueLocs)\n\t\t\t\twantVal = false\n\t\t\t}\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_UniqueMacs:\n\n\t/* handler: uj.UniqueMacs type=[]string kind=slice quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.UniqueMacs = nil\n\t\t} else {\n\n\t\t\tuj.UniqueMacs = make([]string, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar tmp_uj__UniqueMacs string\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_brace {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: tmp_uj__UniqueMacs type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\ttmp_uj__UniqueMacs = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.UniqueMacs = append(uj.UniqueMacs, tmp_uj__UniqueMacs)\n\t\t\t\twantVal = false\n\t\t\t}\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Priors:\n\n\t/* handler: uj.Priors type=map[string]gofind.PriorParameters kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.Priors = nil\n\t\t} else {\n\n\t\t\tuj.Priors = make(map[string]PriorParameters, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__Priors PriorParameters\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__Priors type=gofind.PriorParameters kind=struct quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t\terr = tmp_uj__Priors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t}\n\n\t\t\t\tuj.Priors[k] = tmp_uj__Priors\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Results:\n\n\t/* handler: uj.Results type=map[string]gofind.ResultsParameters kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.Results = nil\n\t\t} else {\n\n\t\t\tuj.Results = make(map[string]ResultsParameters, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__Results ResultsParameters\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__Results type=gofind.ResultsParameters kind=struct quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t\terr = tmp_uj__Results.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t}\n\n\t\t\t\tuj.Results[k] = tmp_uj__Results\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Loaded:\n\n\t/* handler: uj.Loaded type=bool kind=bool quoted=false*/\n\n\t{\n\t\tif tok != fflib.FFTok_bool && tok != fflib.FFTok_null {\n\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for bool\", tok))\n\t\t}\n\t}\n\n\t{\n\t\tif tok == fflib.FFTok_null {\n\n\t\t} else {\n\t\t\ttmpb := fs.Output.Bytes()\n\n\t\t\tif bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {\n\n\t\t\t\tuj.Loaded = true\n\n\t\t\t} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {\n\n\t\t\t\tuj.Loaded = false\n\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"unexpected bytes for true/false value\")\n\t\t\t\treturn fs.WrapErr(err)\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nwantedvalue:\n\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\nwrongtokenerror:\n\treturn fs.WrapErr(fmt.Errorf(\"ffjson: wanted token: %v, but got token: %v output=%s\", wantedTok, tok, fs.Output.String()))\ntokerror:\n\tif fs.BigError != nil {\n\t\treturn fs.WrapErr(fs.BigError)\n\t}\n\terr = fs.Error.ToError()\n\tif err != nil {\n\t\treturn fs.WrapErr(err)\n\t}\n\tpanic(\"ffjson-generated: unreachable, please report bug.\")\ndone:\n\treturn nil\n}\n\nfunc (mj *PriorParameters) MarshalJSON() ([]byte, error) {\n\tvar buf fflib.Buffer\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn buf.Bytes(), nil\n\t}\n\terr := mj.MarshalJSONBuf(&buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\nfunc (mj *PriorParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn nil\n\t}\n\tvar err error\n\tvar obj []byte\n\t_ = obj\n\t_ = err\n\tbuf.WriteString(`{\"P\":`)\n\t/* Falling back. type=map[string]map[string][]float32 kind=map */\n\terr = buf.Encode(mj.P)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"NP\":`)\n\t/* Falling back. type=map[string]map[string][]float32 kind=map */\n\terr = buf.Encode(mj.NP)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"MacFreq\":`)\n\t/* Falling back. type=map[string]map[string]float32 kind=map */\n\terr = buf.Encode(mj.MacFreq)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteString(`,\"NMacFreq\":`)\n\t/* Falling back. type=map[string]map[string]float32 kind=map */\n\terr = buf.Encode(mj.NMacFreq)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif mj.Special == nil {\n\t\tbuf.WriteString(`,\"Special\":null`)\n\t} else {\n\t\tbuf.WriteString(`,\"Special\":{ `)\n\t\tfor key, value := range mj.Special {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.AppendFloat(buf, float64(value), 'g', -1, 64)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tbuf.WriteByte('}')\n\treturn nil\n}\n\nconst (\n\tffj_t_PriorParametersbase = iota\n\tffj_t_PriorParametersno_such_key\n\n\tffj_t_PriorParameters_P\n\n\tffj_t_PriorParameters_NP\n\n\tffj_t_PriorParameters_MacFreq\n\n\tffj_t_PriorParameters_NMacFreq\n\n\tffj_t_PriorParameters_Special\n)\n\nvar ffj_key_PriorParameters_P = []byte(\"P\")\n\nvar ffj_key_PriorParameters_NP = []byte(\"NP\")\n\nvar ffj_key_PriorParameters_MacFreq = []byte(\"MacFreq\")\n\nvar ffj_key_PriorParameters_NMacFreq = []byte(\"NMacFreq\")\n\nvar ffj_key_PriorParameters_Special = []byte(\"Special\")\n\nfunc (uj *PriorParameters) UnmarshalJSON(input []byte) error {\n\tfs := fflib.NewFFLexer(input)\n\treturn uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)\n}\n\nfunc (uj *PriorParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {\n\tvar err error = nil\n\tcurrentKey := ffj_t_PriorParametersbase\n\t_ = currentKey\n\ttok := fflib.FFTok_init\n\twantedTok := fflib.FFTok_init\n\nmainparse:\n\tfor {\n\t\ttok = fs.Scan()\n\t\t//\tprintln(fmt.Sprintf(\"debug: tok: %v  state: %v\", tok, state))\n\t\tif tok == fflib.FFTok_error {\n\t\t\tgoto tokerror\n\t\t}\n\n\t\tswitch state {\n\n\t\tcase fflib.FFParse_map_start:\n\t\t\tif tok != fflib.FFTok_left_bracket {\n\t\t\t\twantedTok = fflib.FFTok_left_bracket\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_key\n\t\t\tcontinue\n\n\t\tcase fflib.FFParse_after_value:\n\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\tstate = fflib.FFParse_want_key\n\t\t\t} else if tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t} else {\n\t\t\t\twantedTok = fflib.FFTok_comma\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_key:\n\t\t\t// json {} ended. goto exit. woo.\n\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t}\n\t\t\tif tok != fflib.FFTok_string {\n\t\t\t\twantedTok = fflib.FFTok_string\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\t\tkn := fs.Output.Bytes()\n\t\t\tif len(kn) <= 0 {\n\t\t\t\t// \"\" case. hrm.\n\t\t\t\tcurrentKey = ffj_t_PriorParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t} else {\n\t\t\t\tswitch kn[0] {\n\n\t\t\t\tcase 'M':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_PriorParameters_MacFreq, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_MacFreq\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'N':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_PriorParameters_NP, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_NP\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\n\t\t\t\t\t} else if bytes.Equal(ffj_key_PriorParameters_NMacFreq, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_NMacFreq\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'P':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_PriorParameters_P, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_P\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'S':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_PriorParameters_Special, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_Special\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_PriorParameters_Special, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_Special\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_NMacFreq, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_NMacFreq\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_MacFreq, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_MacFreq\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_NP, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_NP\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_P, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_PriorParameters_P\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tcurrentKey = ffj_t_PriorParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_colon:\n\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\twantedTok = fflib.FFTok_colon\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_value\n\t\t\tcontinue\n\t\tcase fflib.FFParse_want_value:\n\n\t\t\tif tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {\n\t\t\t\tswitch currentKey {\n\n\t\t\t\tcase ffj_t_PriorParameters_P:\n\t\t\t\t\tgoto handle_P\n\n\t\t\t\tcase ffj_t_PriorParameters_NP:\n\t\t\t\t\tgoto handle_NP\n\n\t\t\t\tcase ffj_t_PriorParameters_MacFreq:\n\t\t\t\t\tgoto handle_MacFreq\n\n\t\t\t\tcase ffj_t_PriorParameters_NMacFreq:\n\t\t\t\t\tgoto handle_NMacFreq\n\n\t\t\t\tcase ffj_t_PriorParameters_Special:\n\t\t\t\t\tgoto handle_Special\n\n\t\t\t\tcase ffj_t_PriorParametersno_such_key:\n\t\t\t\t\terr = fs.SkipField(tok)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto wantedvalue\n\t\t\t}\n\t\t}\n\t}\n\nhandle_P:\n\n\t/* handler: uj.P type=map[string]map[string][]float32 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.P = nil\n\t\t} else {\n\n\t\t\tuj.P = make(map[string]map[string][]float32, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__P map[string][]float32\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__P type=map[string][]float32 kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__P = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__P = make(map[string][]float32, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__P []float32\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__P type=[]float32 kind=slice quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__P = nil\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__P = make([]float32, 0)\n\n\t\t\t\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\t\t\t\tvar tmp_tmp_tmp_uj__P float32\n\n\t\t\t\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_right_brace {\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t/* handler: tmp_tmp_tmp_uj__P type=float32 kind=float32 quoted=false*/\n\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float32\", tok))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)\n\n\t\t\t\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\ttmp_tmp_tmp_uj__P = float32(tval)\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__P = append(tmp_tmp_uj__P, tmp_tmp_tmp_uj__P)\n\t\t\t\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__P[k] = tmp_tmp_uj__P\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.P[k] = tmp_uj__P\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_NP:\n\n\t/* handler: uj.NP type=map[string]map[string][]float32 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.NP = nil\n\t\t} else {\n\n\t\t\tuj.NP = make(map[string]map[string][]float32, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__NP map[string][]float32\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__NP type=map[string][]float32 kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__NP = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__NP = make(map[string][]float32, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__NP []float32\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__NP type=[]float32 kind=slice quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NP = nil\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NP = make([]float32, 0)\n\n\t\t\t\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\t\t\t\tvar tmp_tmp_tmp_uj__NP float32\n\n\t\t\t\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_right_brace {\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t/* handler: tmp_tmp_tmp_uj__NP type=float32 kind=float32 quoted=false*/\n\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float32\", tok))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)\n\n\t\t\t\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\ttmp_tmp_tmp_uj__NP = float32(tval)\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NP = append(tmp_tmp_uj__NP, tmp_tmp_tmp_uj__NP)\n\t\t\t\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__NP[k] = tmp_tmp_uj__NP\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.NP[k] = tmp_uj__NP\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_MacFreq:\n\n\t/* handler: uj.MacFreq type=map[string]map[string]float32 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.MacFreq = nil\n\t\t} else {\n\n\t\t\tuj.MacFreq = make(map[string]map[string]float32, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__MacFreq map[string]float32\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__MacFreq type=map[string]float32 kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__MacFreq = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__MacFreq = make(map[string]float32, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__MacFreq float32\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__MacFreq type=float32 kind=float32 quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float32\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__MacFreq = float32(tval)\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__MacFreq[k] = tmp_tmp_uj__MacFreq\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.MacFreq[k] = tmp_uj__MacFreq\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_NMacFreq:\n\n\t/* handler: uj.NMacFreq type=map[string]map[string]float32 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.NMacFreq = nil\n\t\t} else {\n\n\t\t\tuj.NMacFreq = make(map[string]map[string]float32, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__NMacFreq map[string]float32\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__NMacFreq type=map[string]float32 kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__NMacFreq = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__NMacFreq = make(map[string]float32, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__NMacFreq float32\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__NMacFreq type=float32 kind=float32 quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float32\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__NMacFreq = float32(tval)\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__NMacFreq[k] = tmp_tmp_uj__NMacFreq\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.NMacFreq[k] = tmp_uj__NMacFreq\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Special:\n\n\t/* handler: uj.Special type=map[string]float64 kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.Special = nil\n\t\t} else {\n\n\t\t\tuj.Special = make(map[string]float64, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__Special float64\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__Special type=float64 kind=float64 quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for float64\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__Special = float64(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.Special[k] = tmp_uj__Special\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nwantedvalue:\n\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\nwrongtokenerror:\n\treturn fs.WrapErr(fmt.Errorf(\"ffjson: wanted token: %v, but got token: %v output=%s\", wantedTok, tok, fs.Output.String()))\ntokerror:\n\tif fs.BigError != nil {\n\t\treturn fs.WrapErr(fs.BigError)\n\t}\n\terr = fs.Error.ToError()\n\tif err != nil {\n\t\treturn fs.WrapErr(err)\n\t}\n\tpanic(\"ffjson-generated: unreachable, please report bug.\")\ndone:\n\treturn nil\n}\n\nfunc (mj *ResultsParameters) MarshalJSON() ([]byte, error) {\n\tvar buf fflib.Buffer\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn buf.Bytes(), nil\n\t}\n\terr := mj.MarshalJSONBuf(&buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\nfunc (mj *ResultsParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {\n\tif mj == nil {\n\t\tbuf.WriteString(\"null\")\n\t\treturn nil\n\t}\n\tvar err error\n\tvar obj []byte\n\t_ = obj\n\t_ = err\n\tif mj.Accuracy == nil {\n\t\tbuf.WriteString(`{\"Accuracy\":null`)\n\t} else {\n\t\tbuf.WriteString(`{\"Accuracy\":{ `)\n\t\tfor key, value := range mj.Accuracy {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.FormatBits2(buf, uint64(value), 10, value < 0)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tif mj.TotalLocations == nil {\n\t\tbuf.WriteString(`,\"TotalLocations\":null`)\n\t} else {\n\t\tbuf.WriteString(`,\"TotalLocations\":{ `)\n\t\tfor key, value := range mj.TotalLocations {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.FormatBits2(buf, uint64(value), 10, value < 0)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tif mj.CorrectLocations == nil {\n\t\tbuf.WriteString(`,\"CorrectLocations\":null`)\n\t} else {\n\t\tbuf.WriteString(`,\"CorrectLocations\":{ `)\n\t\tfor key, value := range mj.CorrectLocations {\n\t\t\tfflib.WriteJsonString(buf, key)\n\t\t\tbuf.WriteString(`:`)\n\t\t\tfflib.FormatBits2(buf, uint64(value), 10, value < 0)\n\t\t\tbuf.WriteByte(',')\n\t\t}\n\t\tbuf.Rewind(1)\n\t\tbuf.WriteByte('}')\n\t}\n\tbuf.WriteString(`,\"Guess\":`)\n\t/* Falling back. type=map[string]map[string]int kind=map */\n\terr = buf.Encode(mj.Guess)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.WriteByte('}')\n\treturn nil\n}\n\nconst (\n\tffj_t_ResultsParametersbase = iota\n\tffj_t_ResultsParametersno_such_key\n\n\tffj_t_ResultsParameters_Accuracy\n\n\tffj_t_ResultsParameters_TotalLocations\n\n\tffj_t_ResultsParameters_CorrectLocations\n\n\tffj_t_ResultsParameters_Guess\n)\n\nvar ffj_key_ResultsParameters_Accuracy = []byte(\"Accuracy\")\n\nvar ffj_key_ResultsParameters_TotalLocations = []byte(\"TotalLocations\")\n\nvar ffj_key_ResultsParameters_CorrectLocations = []byte(\"CorrectLocations\")\n\nvar ffj_key_ResultsParameters_Guess = []byte(\"Guess\")\n\nfunc (uj *ResultsParameters) UnmarshalJSON(input []byte) error {\n\tfs := fflib.NewFFLexer(input)\n\treturn uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)\n}\n\nfunc (uj *ResultsParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {\n\tvar err error = nil\n\tcurrentKey := ffj_t_ResultsParametersbase\n\t_ = currentKey\n\ttok := fflib.FFTok_init\n\twantedTok := fflib.FFTok_init\n\nmainparse:\n\tfor {\n\t\ttok = fs.Scan()\n\t\t//\tprintln(fmt.Sprintf(\"debug: tok: %v  state: %v\", tok, state))\n\t\tif tok == fflib.FFTok_error {\n\t\t\tgoto tokerror\n\t\t}\n\n\t\tswitch state {\n\n\t\tcase fflib.FFParse_map_start:\n\t\t\tif tok != fflib.FFTok_left_bracket {\n\t\t\t\twantedTok = fflib.FFTok_left_bracket\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_key\n\t\t\tcontinue\n\n\t\tcase fflib.FFParse_after_value:\n\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\tstate = fflib.FFParse_want_key\n\t\t\t} else if tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t} else {\n\t\t\t\twantedTok = fflib.FFTok_comma\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_key:\n\t\t\t// json {} ended. goto exit. woo.\n\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\tgoto done\n\t\t\t}\n\t\t\tif tok != fflib.FFTok_string {\n\t\t\t\twantedTok = fflib.FFTok_string\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\n\t\t\tkn := fs.Output.Bytes()\n\t\t\tif len(kn) <= 0 {\n\t\t\t\t// \"\" case. hrm.\n\t\t\t\tcurrentKey = ffj_t_ResultsParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t} else {\n\t\t\t\tswitch kn[0] {\n\n\t\t\t\tcase 'A':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_ResultsParameters_Accuracy, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_Accuracy\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'C':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_ResultsParameters_CorrectLocations, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_CorrectLocations\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'G':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_ResultsParameters_Guess, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_Guess\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\tcase 'T':\n\n\t\t\t\t\tif bytes.Equal(ffj_key_ResultsParameters_TotalLocations, kn) {\n\t\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_TotalLocations\n\t\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\t\tgoto mainparse\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_ResultsParameters_Guess, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_Guess\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_ResultsParameters_CorrectLocations, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_CorrectLocations\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.EqualFoldRight(ffj_key_ResultsParameters_TotalLocations, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_TotalLocations\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tif fflib.SimpleLetterEqualFold(ffj_key_ResultsParameters_Accuracy, kn) {\n\t\t\t\t\tcurrentKey = ffj_t_ResultsParameters_Accuracy\n\t\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\n\t\t\t\tcurrentKey = ffj_t_ResultsParametersno_such_key\n\t\t\t\tstate = fflib.FFParse_want_colon\n\t\t\t\tgoto mainparse\n\t\t\t}\n\n\t\tcase fflib.FFParse_want_colon:\n\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\twantedTok = fflib.FFTok_colon\n\t\t\t\tgoto wrongtokenerror\n\t\t\t}\n\t\t\tstate = fflib.FFParse_want_value\n\t\t\tcontinue\n\t\tcase fflib.FFParse_want_value:\n\n\t\t\tif tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {\n\t\t\t\tswitch currentKey {\n\n\t\t\t\tcase ffj_t_ResultsParameters_Accuracy:\n\t\t\t\t\tgoto handle_Accuracy\n\n\t\t\t\tcase ffj_t_ResultsParameters_TotalLocations:\n\t\t\t\t\tgoto handle_TotalLocations\n\n\t\t\t\tcase ffj_t_ResultsParameters_CorrectLocations:\n\t\t\t\t\tgoto handle_CorrectLocations\n\n\t\t\t\tcase ffj_t_ResultsParameters_Guess:\n\t\t\t\t\tgoto handle_Guess\n\n\t\t\t\tcase ffj_t_ResultsParametersno_such_key:\n\t\t\t\t\terr = fs.SkipField(tok)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t}\n\t\t\t\t\tstate = fflib.FFParse_after_value\n\t\t\t\t\tgoto mainparse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto wantedvalue\n\t\t\t}\n\t\t}\n\t}\n\nhandle_Accuracy:\n\n\t/* handler: uj.Accuracy type=map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.Accuracy = nil\n\t\t} else {\n\n\t\t\tuj.Accuracy = make(map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__Accuracy int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__Accuracy type=int kind=int quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__Accuracy = int(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.Accuracy[k] = tmp_uj__Accuracy\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_TotalLocations:\n\n\t/* handler: uj.TotalLocations type=map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.TotalLocations = nil\n\t\t} else {\n\n\t\t\tuj.TotalLocations = make(map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__TotalLocations int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__TotalLocations type=int kind=int quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__TotalLocations = int(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.TotalLocations[k] = tmp_uj__TotalLocations\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_CorrectLocations:\n\n\t/* handler: uj.CorrectLocations type=map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.CorrectLocations = nil\n\t\t} else {\n\n\t\t\tuj.CorrectLocations = make(map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__CorrectLocations int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__CorrectLocations type=int kind=int quoted=false*/\n\n\t\t\t\t{\n\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_uj__CorrectLocations = int(tval)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.CorrectLocations[k] = tmp_uj__CorrectLocations\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nhandle_Guess:\n\n\t/* handler: uj.Guess type=map[string]map[string]int kind=map quoted=false*/\n\n\t{\n\n\t\t{\n\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t}\n\t\t}\n\n\t\tif tok == fflib.FFTok_null {\n\t\t\tuj.Guess = nil\n\t\t} else {\n\n\t\t\tuj.Guess = make(map[string]map[string]int, 0)\n\n\t\t\twantVal := true\n\n\t\t\tfor {\n\n\t\t\t\tvar k string\n\n\t\t\t\tvar tmp_uj__Guess map[string]int\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\tgoto tokerror\n\t\t\t\t}\n\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\twantVal = true\n\t\t\t\t}\n\n\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Expect ':' after key\n\t\t\t\ttok = fs.Scan()\n\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t}\n\n\t\t\t\ttok = fs.Scan()\n\t\t\t\t/* handler: tmp_uj__Guess type=map[string]int kind=map quoted=false*/\n\n\t\t\t\t{\n\n\t\t\t\t\t{\n\t\t\t\t\t\tif tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for \", tok))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif tok == fflib.FFTok_null {\n\t\t\t\t\t\ttmp_uj__Guess = nil\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttmp_uj__Guess = make(map[string]int, 0)\n\n\t\t\t\t\t\twantVal := true\n\n\t\t\t\t\t\tfor {\n\n\t\t\t\t\t\t\tvar k string\n\n\t\t\t\t\t\t\tvar tmp_tmp_uj__Guess int\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok == fflib.FFTok_error {\n\t\t\t\t\t\t\t\tgoto tokerror\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tok == fflib.FFTok_right_bracket {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif tok == fflib.FFTok_comma {\n\t\t\t\t\t\t\t\tif wantVal == true {\n\t\t\t\t\t\t\t\t\t// TODO(pquerna): this isn't an ideal error message, this handles\n\t\t\t\t\t\t\t\t\t// things like [,,,] as an array value.\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twantVal = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* handler: k type=string kind=string quoted=false*/\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif tok != fflib.FFTok_string && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for string\", tok))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\toutBuf := fs.Output.Bytes()\n\n\t\t\t\t\t\t\t\t\tk = string(string(outBuf))\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Expect ':' after key\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\tif tok != fflib.FFTok_colon {\n\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"wanted colon token, but got token: %v\", tok))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttok = fs.Scan()\n\t\t\t\t\t\t\t/* handler: tmp_tmp_uj__Guess type=int kind=int quoted=false*/\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif tok != fflib.FFTok_integer && tok != fflib.FFTok_null {\n\t\t\t\t\t\t\t\t\treturn fs.WrapErr(fmt.Errorf(\"cannot unmarshal %s into Go value for int\", tok))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tif tok == fflib.FFTok_null {\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ttval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn fs.WrapErr(err)\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttmp_tmp_uj__Guess = int(tval)\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp_uj__Guess[k] = tmp_tmp_uj__Guess\n\n\t\t\t\t\t\t\twantVal = false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuj.Guess[k] = tmp_uj__Guess\n\n\t\t\t\twantVal = false\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstate = fflib.FFParse_after_value\n\tgoto mainparse\n\nwantedvalue:\n\treturn fs.WrapErr(fmt.Errorf(\"wanted value token, but got token: %v\", tok))\nwrongtokenerror:\n\treturn fs.WrapErr(fmt.Errorf(\"ffjson: wanted token: %v, but got token: %v output=%s\", wantedTok, tok, fs.Output.String()))\ntokerror:\n\tif fs.BigError != nil {\n\t\treturn fs.WrapErr(fs.BigError)\n\t}\n\terr = fs.Error.ToError()\n\tif err != nil {\n\t\treturn fs.WrapErr(err)\n\t}\n\tpanic(\"ffjson-generated: unreachable, please report bug.\")\ndone:\n\treturn nil\n}\n"
        },
        {
          "name": "parameters_test.go",
          "type": "blob",
          "size": 1.3994140625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc BenchmarkLoadParameters(b *testing.B) {\n\tvar ps FullParameters = *NewFullParameters()\n\tdb, err := bolt.Open(path.Join(\"data\", \"testdb.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdefer db.Close()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr = db.View(func(tx *bolt.Tx) error {\n\t\t\t// Assume bucket exists and has keys\n\t\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\t\tif b == nil {\n\t\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t\t}\n\t\t\tv := b.Get([]byte(\"fullParameters\"))\n\t\t\tps = loadParameters(v)\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tError.Println(err)\n\t\t}\n\n\t}\n}\n\nfunc BenchmarkGetParameters(b *testing.B) {\n\tgroup := \"testdb\"\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(v)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(v))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t}\n}\n"
        },
        {
          "name": "posterior.go",
          "type": "blob",
          "size": 5.2568359375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// posteriors.go contains variables for calcualting Naive-Bayes posteriors.\n\npackage main\n\nimport \"math\"\n\n// calculatePosterior takes a Fingerprint and a Parameter set and returns the noramlized Bayes probabilities of possible locations\nfunc calculatePosterior(res Fingerprint, ps FullParameters) (string, map[string]float64) {\n\tif !ps.Loaded {\n\t\tps, _ = openParameters(res.Group)\n\t}\n\tmacs := []string{}\n\tW := make(map[string]int)\n\tfor v2 := range res.WifiFingerprint {\n\t\tmacs = append(macs, res.WifiFingerprint[v2].Mac)\n\t\tW[res.WifiFingerprint[v2].Mac] = res.WifiFingerprint[v2].Rssi\n\t}\n\tn, inNetworkAlready := hasNetwork(ps.NetworkMacs, macs)\n\t// Debug.Println(n, inNetworkAlready, ps.NetworkLocs[n])\n\tif !inNetworkAlready {\n\t\tWarning.Println(\"Not in network\")\n\t\tDebug.Println(n, inNetworkAlready, ps.NetworkLocs[n], res)\n\t}\n\n\tif len(ps.NetworkLocs[n]) == 1 {\n\t\tfor key := range ps.NetworkLocs[n] {\n\t\t\tPBayesMix := make(map[string]float64)\n\t\t\tPBayesMix[key] = 1\n\t\t\treturn key, PBayesMix\n\t\t}\n\t}\n\n\tPBayes1 := make(map[string]float64)\n\tPBayes2 := make(map[string]float64)\n\tPA := 1.0 / float64(len(ps.NetworkLocs[n]))\n\tPnA := (float64(len(ps.NetworkLocs[n])) - 1.0) / float64(len(ps.NetworkLocs[n]))\n\tfor loc := range ps.NetworkLocs[n] {\n\t\tPBayes1[loc] = float64(0)\n\t\tPBayes2[loc] = float64(0)\n\t\tfor mac := range W {\n\t\t\tweight := float64(0)\n\t\t\tnweight := float64(0)\n\t\t\tif _, ok := ps.Priors[n].MacFreq[loc][mac]; ok {\n\t\t\t\tweight = float64(ps.Priors[n].MacFreq[loc][mac])\n\t\t\t} else {\n\t\t\t\tweight = float64(ps.Priors[n].Special[\"MacFreqMin\"])\n\t\t\t}\n\t\t\tif _, ok := ps.Priors[n].NMacFreq[loc][mac]; ok {\n\t\t\t\tnweight = float64(ps.Priors[n].NMacFreq[loc][mac])\n\t\t\t} else {\n\t\t\t\tnweight = float64(ps.Priors[n].Special[\"NMacFreqMin\"])\n\t\t\t}\n\t\t\tPBayes1[loc] += math.Log(weight*PA) - math.Log(weight*PA+PnA*nweight)\n\n\t\t\tif float64(ps.MacVariability[mac]) >= ps.Priors[n].Special[\"VarabilityCutoff\"] && W[mac] > MinRssi {\n\t\t\t\tind := int(W[mac] - MinRssi)\n\t\t\t\tif len(ps.Priors[n].P[loc][mac]) > 0 {\n\t\t\t\t\tPBA := float64(ps.Priors[n].P[loc][mac][ind])\n\t\t\t\t\tPBnA := float64(ps.Priors[n].NP[loc][mac][ind])\n\t\t\t\t\tif PBA > 0 {\n\t\t\t\t\t\tPBayes2[loc] += (math.Log(PBA*PA) - math.Log(PBA*PA+PBnA*PnA))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPBayes2[loc] += -1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPBayes1 = normalizeBayes(PBayes1)\n\tPBayes2 = normalizeBayes(PBayes2)\n\tPBayesMix := make(map[string]float64)\n\tbestLocation := \"\"\n\tmaxVal := float64(-100)\n\tfor key := range PBayes1 {\n\t\tPBayesMix[key] = ps.Priors[n].Special[\"MixIn\"]*PBayes1[key] + (1-ps.Priors[n].Special[\"MixIn\"])*PBayes2[key]\n\t\tif PBayesMix[key] > maxVal {\n\t\t\tmaxVal = PBayesMix[key]\n\t\t\tbestLocation = key\n\t\t}\n\t}\n\treturn bestLocation, PBayesMix\n}\n\n// calculatePosteriorThreadSafe is exactly the same as calculatePosterior except it does not do the mixin calculation\n// as it is used for optimizing priors.\nfunc calculatePosteriorThreadSafe(res Fingerprint, ps FullParameters, cutoff float64) (map[string]float64, map[string]float64) {\n\tif !ps.Loaded {\n\t\tps, _ = openParameters(res.Group)\n\t}\n\tmacs := []string{}\n\tW := make(map[string]int)\n\tfor v2 := range res.WifiFingerprint {\n\t\tmacs = append(macs, res.WifiFingerprint[v2].Mac)\n\t\tW[res.WifiFingerprint[v2].Mac] = res.WifiFingerprint[v2].Rssi\n\t}\n\tn, inNetworkAlready := hasNetwork(ps.NetworkMacs, macs)\n\t// Debug.Println(n, inNetworkAlready, ps.NetworkLocs[n])\n\tif !inNetworkAlready {\n\t\tWarning.Println(\"Not in network\")\n\t\tDebug.Println(n, inNetworkAlready, ps.NetworkLocs[n], res)\n\t}\n\n\tPBayes1 := make(map[string]float64)\n\tPBayes2 := make(map[string]float64)\n\tPA := 1.0 / float64(len(ps.NetworkLocs[n]))\n\tPnA := (float64(len(ps.NetworkLocs[n])) - 1.0) / float64(len(ps.NetworkLocs[n]))\n\tfor loc := range ps.NetworkLocs[n] {\n\t\tPBayes1[loc] = float64(0)\n\t\tPBayes2[loc] = float64(0)\n\t\tfor mac := range W {\n\t\t\tweight := float64(0)\n\t\t\tnweight := float64(0)\n\t\t\tif _, ok := ps.Priors[n].MacFreq[loc][mac]; ok {\n\t\t\t\tweight = float64(ps.Priors[n].MacFreq[loc][mac])\n\t\t\t} else {\n\t\t\t\tweight = float64(ps.Priors[n].Special[\"MacFreqMin\"])\n\t\t\t}\n\t\t\tif _, ok := ps.Priors[n].NMacFreq[loc][mac]; ok {\n\t\t\t\tnweight = float64(ps.Priors[n].NMacFreq[loc][mac])\n\t\t\t} else {\n\t\t\t\tnweight = float64(ps.Priors[n].Special[\"NMacFreqMin\"])\n\t\t\t}\n\t\t\tPBayes1[loc] += math.Log(weight*PA) - math.Log(weight*PA+PnA*nweight)\n\n\t\t\tif float64(ps.MacVariability[mac]) >= cutoff && W[mac] > MinRssi {\n\t\t\t\tind := int(W[mac] - MinRssi)\n\t\t\t\tif len(ps.Priors[n].P[loc][mac]) > 0 {\n\t\t\t\t\tPBA := float64(ps.Priors[n].P[loc][mac][ind])\n\t\t\t\t\tPBnA := float64(ps.Priors[n].NP[loc][mac][ind])\n\t\t\t\t\tif PBA > 0 {\n\t\t\t\t\t\tPBayes2[loc] += (math.Log(PBA*PA) - math.Log(PBA*PA+PBnA*PnA))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPBayes2[loc] += -1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPBayes1 = normalizeBayes(PBayes1)\n\tPBayes2 = normalizeBayes(PBayes2)\n\treturn PBayes1, PBayes2\n}\n\n// normalizeBayes takes the bayes map and normalizes to standard normal.\nfunc normalizeBayes(bayes map[string]float64) map[string]float64 {\n\tvals := make([]float64, len(bayes))\n\ti := 0\n\tfor _, val := range bayes {\n\t\tvals[i] = val\n\t\ti++\n\t}\n\tmean := average64(vals)\n\tsd := standardDeviation64(vals)\n\tfor key := range bayes {\n\t\tif sd < 1e-5 {\n\t\t\tbayes[key] = 0\n\t\t} else {\n\t\t\tbayes[key] = (bayes[key] - mean) / sd\n\t\t}\n\t\tif math.IsNaN(bayes[key]) {\n\t\t\tbayes[key] = 0\n\t\t}\n\t}\n\treturn bayes\n}\n"
        },
        {
          "name": "posterior_test.go",
          "type": "blob",
          "size": 1.7578125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// BenchmarkCalculatePosteriors1 needs to have precomputed parameters for testdb (run Optimize after loading testdb.sh)\nfunc BenchmarkCalculatePosteriors1(b *testing.B) {\n\tres := Fingerprint{}\n\tjsonTest := `{\"username\": \"zack\", \"group\": \"testdb\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n\tjson.Unmarshal([]byte(jsonTest), &res)\n\n\tvar ps FullParameters\n\tdb, err := bolt.Open(path.Join(\"data\", \"testdb.db\"), 0600, nil)\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"fullParameters\"))\n\t\tps = loadParameters(v)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tError.Println(err)\n\t}\n\tdb.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tcalculatePosterior(res, ps)\n\t}\n\n}\n"
        },
        {
          "name": "priors.go",
          "type": "blob",
          "size": 11.0712890625,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// priors.go contains variables for calcualting priors.\n\npackage main\n\nimport (\n\t\"log\"\n\t\"math\"\n\t\"path\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// PdfType dictates the width of gaussian smoothing\nvar PdfType []float32\n\n// MaxRssi is the maximum level of signal\nvar MaxRssi int\n\n// MinRssi is the minimum level of signal\nvar MinRssi int\n\n// RssiPartitions are the calculated number of partitions from MinRssi and MaxRssi\nvar RssiPartitions int\n\n// Absentee is the base level of probability for any signal\nvar Absentee float32\n\n// RssiRange is the calculated partitions in array form\nvar RssiRange []float32\n\n// FoldCrossValidation is the amount of data left out during learning to be used in cross validation\nvar FoldCrossValidation float64\n\nfunc init() {\n\tPdfType = []float32{.1995, .1760, .1210, .0648, .027, 0.005}\n\tAbsentee = 1e-6\n\tMinRssi = -110\n\tMaxRssi = 5\n\tRssiPartitions = MaxRssi - MinRssi + 1\n\tRssiRange = make([]float32, RssiPartitions)\n\tfor i := 0; i < len(RssiRange); i++ {\n\t\tRssiRange[i] = float32(MinRssi + i)\n\t}\n\tFoldCrossValidation = 4\n}\n\n// deprecated\nfunc optimizePriors(group string) {\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(k)] = loadFingerprint(v)\n\t\t\t// fmt.Println(fingerprintsInMemory[string(k)].Location, string(k))\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(k))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t// fmt.Println(string(dumpParameters(ps)))\n\t// ps, _ = openParameters(\"findtest\")\n\tvar results = *NewResultsParameters()\n\tfor n := range ps.Priors {\n\t\tps.Results[n] = results\n\t}\n\t// fmt.Println(ps.Results)\n\t// ps.Priors[\"0\"].Special[\"MixIn\"] = 1.0\n\t// fmt.Println(crossValidation(group, \"0\", &ps))\n\t// fmt.Println(ps.Results)\n\n\t// loop through these parameters\n\tmixins := []float64{0.1, 0.3, 0.5, 0.7, 0.9}\n\tcutoffs := []float64{0.005}\n\n\tfor n := range ps.Priors {\n\t\tbestResult := float64(0)\n\t\tbestMixin := float64(0)\n\t\tbestCutoff := float64(0)\n\t\tfor _, cutoff := range cutoffs {\n\t\t\tfor _, mixin := range mixins {\n\t\t\t\tps.Priors[n].Special[\"MixIn\"] = mixin\n\t\t\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = cutoff\n\t\t\t\tavgAccuracy := crossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t\t\t\t// avgAccuracy := crossValidation(group, n, &ps)\n\t\t\t\tif avgAccuracy > bestResult {\n\t\t\t\t\tbestResult = avgAccuracy\n\t\t\t\t\tbestCutoff = cutoff\n\t\t\t\t\tbestMixin = mixin\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tps.Priors[n].Special[\"MixIn\"] = bestMixin\n\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = bestCutoff\n\t\t// Final validation\n\t\tcrossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t\t// crossValidation(group, n, &ps)\n\t}\n\n\tgo saveParameters(group, ps)\n\tgo setPsCache(group, ps)\n}\n\nfunc regenerateEverything(group string) {\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(v)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(v))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tps, _ = openParameters(group)\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tvar results = *NewResultsParameters()\n\tfor n := range ps.Priors {\n\t\tps.Results[n] = results\n\t}\n\tfor n := range ps.Priors {\n\t\tcrossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t}\n\tsaveParameters(group, ps)\n}\n\nfunc crossValidation(group string, n string, ps *FullParameters, fingerprintsInMemory map[string]Fingerprint, fingerprintsOrdering []string) float64 {\n\tfor loc := range ps.NetworkLocs[n] {\n\t\tps.Results[n].TotalLocations[loc] = 0\n\t\tps.Results[n].CorrectLocations[loc] = 0\n\t\tps.Results[n].Accuracy[loc] = 0\n\t\tps.Results[n].Guess[loc] = make(map[string]int)\n\t}\n\n\tit := float64(-1)\n\tfor _, v1 := range fingerprintsOrdering {\n\t\tv2 := fingerprintsInMemory[v1]\n\t\tit++\n\t\tif math.Mod(it, FoldCrossValidation) == 0 {\n\t\t\tif len(v2.WifiFingerprint) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := ps.NetworkLocs[n][v2.Location]; ok {\n\t\t\t\tlocationGuess, _ := calculatePosterior(v2, *ps)\n\t\t\t\tps.Results[n].TotalLocations[v2.Location]++\n\t\t\t\tif locationGuess == v2.Location {\n\t\t\t\t\tps.Results[n].CorrectLocations[v2.Location]++\n\t\t\t\t}\n\t\t\t\tif _, ok := ps.Results[n].Guess[v2.Location]; !ok {\n\t\t\t\t\tps.Results[n].Guess[v2.Location] = make(map[string]int)\n\t\t\t\t}\n\t\t\t\tif _, ok := ps.Results[n].Guess[v2.Location][locationGuess]; !ok {\n\t\t\t\t\tps.Results[n].Guess[v2.Location][locationGuess] = 0\n\t\t\t\t}\n\t\t\t\tps.Results[n].Guess[v2.Location][locationGuess]++\n\t\t\t}\n\t\t}\n\t}\n\n\taverage := float64(0)\n\tfor loc := range ps.NetworkLocs[n] {\n\t\tif ps.Results[n].TotalLocations[loc] > 0 {\n\t\t\t// fmt.Println(ps.Results[n].CorrectLocations[loc], ps.Results[n].TotalLocations[loc])\n\t\t\tps.Results[n].Accuracy[loc] = int(100.0 * ps.Results[n].CorrectLocations[loc] / ps.Results[n].TotalLocations[loc])\n\t\t\taverage += float64(ps.Results[n].Accuracy[loc])\n\t\t}\n\t}\n\taverage = average / float64(len(ps.NetworkLocs[n]))\n\n\treturn average\n}\n\n// calculatePriors generates the prior data for Naive-Bayes classification. Now deprecated, use calculatePriorsThreaded instead.\nfunc calculatePriors(group string, ps *FullParameters, fingerprintsInMemory map[string]Fingerprint, fingerprintsOrdering []string) {\n\t// defer timeTrack(time.Now(), \"calculatePriors\")\n\tps.Priors = make(map[string]PriorParameters)\n\tfor n := range ps.NetworkLocs {\n\t\tvar newPrior = *NewPriorParameters()\n\t\tps.Priors[n] = newPrior\n\t}\n\n\t// Initialization\n\tps.MacVariability = make(map[string]float32)\n\tfor n := range ps.Priors {\n\t\tps.Priors[n].Special[\"MacFreqMin\"] = float64(100)\n\t\tps.Priors[n].Special[\"NMacFreqMin\"] = float64(100)\n\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\tps.Priors[n].P[loc] = make(map[string][]float32)\n\t\t\tps.Priors[n].NP[loc] = make(map[string][]float32)\n\t\t\tps.Priors[n].MacFreq[loc] = make(map[string]float32)\n\t\t\tps.Priors[n].NMacFreq[loc] = make(map[string]float32)\n\t\t\tfor mac := range ps.NetworkMacs[n] {\n\t\t\t\tps.Priors[n].P[loc][mac] = make([]float32, RssiPartitions)\n\t\t\t\tps.Priors[n].NP[loc][mac] = make([]float32, RssiPartitions)\n\t\t\t}\n\t\t}\n\t}\n\n\tit := float64(-1)\n\tfor _, v1 := range fingerprintsOrdering {\n\t\tv2 := fingerprintsInMemory[v1]\n\t\tit++\n\t\tif math.Mod(it, FoldCrossValidation) != 0 { // cross-validation\n\t\t\tmacs := []string{}\n\t\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t\tmacs = append(macs, router.Mac)\n\t\t\t}\n\n\t\t\tnetworkName, inNetwork := hasNetwork(ps.NetworkMacs, macs)\n\t\t\tif inNetwork {\n\t\t\t\tfor _, router := range v2.WifiFingerprint {\n\t\t\t\t\tif router.Rssi > MinRssi {\n\t\t\t\t\t\tps.Priors[networkName].P[v2.Location][router.Mac][router.Rssi-MinRssi] += PdfType[0]\n\t\t\t\t\t\tfor i, val := range PdfType {\n\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\tps.Priors[networkName].P[v2.Location][router.Mac][router.Rssi-MinRssi-i] += val\n\t\t\t\t\t\t\t\tps.Priors[networkName].P[v2.Location][router.Mac][router.Rssi-MinRssi+i] += val\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWarning.Println(router.Rssi)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// Calculate the nP\n\tfor n := range ps.Priors {\n\t\tfor locN := range ps.NetworkLocs[n] {\n\t\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\t\tif loc != locN {\n\t\t\t\t\tfor mac := range ps.NetworkMacs[n] {\n\t\t\t\t\t\tfor i := range ps.Priors[n].P[locN][mac] {\n\t\t\t\t\t\t\tif ps.Priors[n].P[loc][mac][i] > 0 {\n\t\t\t\t\t\t\t\tps.Priors[n].NP[locN][mac][i] += ps.Priors[n].P[loc][mac][i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add in absentee, normalize P and nP and determine MacVariability\n\tfor n := range ps.Priors {\n\t\tmacAverages := make(map[string][]float32)\n\n\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\tfor mac := range ps.NetworkMacs[n] {\n\t\t\t\tfor i := range ps.Priors[n].P[loc][mac] {\n\t\t\t\t\tps.Priors[n].P[loc][mac][i] += Absentee\n\t\t\t\t\tps.Priors[n].NP[loc][mac][i] += Absentee\n\t\t\t\t}\n\t\t\t\ttotal := float32(0)\n\t\t\t\tfor _, val := range ps.Priors[n].P[loc][mac] {\n\t\t\t\t\ttotal += val\n\t\t\t\t}\n\t\t\t\taverageMac := float32(0)\n\t\t\t\tfor i, val := range ps.Priors[n].P[loc][mac] {\n\t\t\t\t\tif val > float32(0) {\n\t\t\t\t\t\tps.Priors[n].P[loc][mac][i] = val / total\n\t\t\t\t\t\taverageMac += RssiRange[i] * ps.Priors[n].P[loc][mac][i]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif averageMac < float32(0) {\n\t\t\t\t\tif _, ok := macAverages[mac]; !ok {\n\t\t\t\t\t\tmacAverages[mac] = []float32{}\n\t\t\t\t\t}\n\t\t\t\t\tmacAverages[mac] = append(macAverages[mac], averageMac)\n\t\t\t\t}\n\n\t\t\t\ttotal = float32(0)\n\t\t\t\tfor i := range ps.Priors[n].NP[loc][mac] {\n\t\t\t\t\ttotal += ps.Priors[n].NP[loc][mac][i]\n\t\t\t\t}\n\t\t\t\tif total > 0 {\n\t\t\t\t\tfor i := range ps.Priors[n].NP[loc][mac] {\n\t\t\t\t\t\tps.Priors[n].NP[loc][mac][i] = ps.Priors[n].NP[loc][mac][i] / total\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine MacVariability\n\t\tfor mac := range macAverages {\n\t\t\tif len(macAverages[mac]) <= 2 {\n\t\t\t\tps.MacVariability[mac] = float32(1)\n\t\t\t} else {\n\t\t\t\tmaxVal := float32(-10000)\n\t\t\t\tfor _, val := range macAverages[mac] {\n\t\t\t\t\tif val > maxVal {\n\t\t\t\t\t\tmaxVal = val\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor i, val := range macAverages[mac] {\n\t\t\t\t\tmacAverages[mac][i] = maxVal / val\n\t\t\t\t}\n\t\t\t\tps.MacVariability[mac] = standardDeviation(macAverages[mac])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Determine mac frequencies and normalize\n\tfor n := range ps.Priors {\n\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\tmaxCount := 0\n\t\t\tfor mac := range ps.MacCountByLoc[loc] {\n\t\t\t\tif ps.MacCountByLoc[loc][mac] > maxCount {\n\t\t\t\t\tmaxCount = ps.MacCountByLoc[loc][mac]\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor mac := range ps.MacCountByLoc[loc] {\n\t\t\t\tps.Priors[n].MacFreq[loc][mac] = float32(ps.MacCountByLoc[loc][mac]) / float32(maxCount)\n\t\t\t\tif float64(ps.Priors[n].MacFreq[loc][mac]) < ps.Priors[n].Special[\"MacFreqMin\"] {\n\t\t\t\t\tps.Priors[n].Special[\"MacFreqMin\"] = float64(ps.Priors[n].MacFreq[loc][mac])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Deteremine negative mac frequencies and normalize\n\tfor n := range ps.Priors {\n\t\tfor loc1 := range ps.Priors[n].MacFreq {\n\t\t\tsum := float32(0)\n\t\t\tfor loc2 := range ps.Priors[n].MacFreq {\n\t\t\t\tif loc2 != loc1 {\n\t\t\t\t\tfor mac := range ps.Priors[n].MacFreq[loc2] {\n\t\t\t\t\t\tps.Priors[n].NMacFreq[loc1][mac] += ps.Priors[n].MacFreq[loc2][mac]\n\t\t\t\t\t\tsum++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Normalize\n\t\t\tif sum > 0 {\n\t\t\t\tfor mac := range ps.Priors[n].MacFreq[loc1] {\n\t\t\t\t\tps.Priors[n].NMacFreq[loc1][mac] = ps.Priors[n].NMacFreq[loc1][mac] / sum\n\t\t\t\t\tif float64(ps.Priors[n].NMacFreq[loc1][mac]) < ps.Priors[n].Special[\"NMacFreqMin\"] {\n\t\t\t\t\t\tps.Priors[n].Special[\"NMacFreqMin\"] = float64(ps.Priors[n].NMacFreq[loc1][mac])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor n := range ps.Priors {\n\t\tps.Priors[n].Special[\"MixIn\"] = 0.5\n\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = 0\n\t}\n\n}\n"
        },
        {
          "name": "priorsThreaded.go",
          "type": "blob",
          "size": 11.6484375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// priorsThreaded.go contains the main Prior-calculation function which is multi-threaded\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"path\"\n\t\"runtime\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// following this:https://play.golang.org/p/hK2h-irKyz\ntype resultA struct {\n\tmixin         float64\n\tlocationGuess string\n\tlocationTrue  string\n\tn             string\n}\n\ntype jobA struct {\n\tmixin        float64\n\tlocs         []string\n\tbayes1       []float64\n\tbayes2       []float64\n\tn            string\n\tlocationTrue string\n}\n\n// MaxParallelism returns the maximum parallelism https://stackoverflow.com/questions/13234749/golang-how-to-verify-number-of-processors-on-which-a-go-program-is-running\nfunc MaxParallelism() int {\n\tmaxProcs := runtime.GOMAXPROCS(0)\n\tnumCPU := runtime.NumCPU()\n\tif maxProcs < numCPU {\n\t\treturn maxProcs\n\t}\n\treturn numCPU\n}\n\nfunc worker(id int, jobs <-chan jobA, results chan<- resultA) {\n\tfor j := range jobs {\n\t\tmaxVal := float64(-1)\n\t\tlocationGuess := \"\"\n\t\tfor i, loc := range j.locs {\n\t\t\tPBayesMix := j.mixin*j.bayes1[i] + (1-j.mixin)*j.bayes2[i]\n\t\t\tif PBayesMix > maxVal {\n\t\t\t\tmaxVal = PBayesMix\n\t\t\t\tlocationGuess = loc\n\t\t\t}\n\t\t}\n\t\tresults <- resultA{locationGuess: locationGuess,\n\t\t\tlocationTrue: j.locationTrue,\n\t\t\tmixin:        j.mixin,\n\t\t\tn:            j.n}\n\t}\n}\n\n// optimizePriorsThreaded generates the optimized prior data for Naive-Bayes classification.\nfunc optimizePriorsThreaded(group string) error {\n\t// Debug.Println(\"Optimizing priors for \" + group)\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t\treturn err\n\t}\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"No fingerprint bucket\")\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(k)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(k))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar ps = *NewFullParameters()\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\n\tvar results = *NewResultsParameters()\n\tfor n := range ps.Priors {\n\t\tps.Results[n] = results\n\t}\n\n\t// loop through these parameters\n\tmixins := []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}\n\tmixinOverride, _ := getMixinOverride(group)\n\tif mixinOverride >= 0 && mixinOverride <= 1 {\n\t\tmixins = []float64{mixinOverride}\n\t}\n\n\t// Choose cutoff\n\tcutoffs := []float64{0.005, 0.05, 0.1}\n\tcutoffOverride, _ := getCutoffOverride(group)\n\tif cutoffOverride >= 0 && cutoffOverride <= 1 {\n\t\tcutoffs = []float64{cutoffOverride}\n\t}\n\n\tbestMixin := make(map[string]float64)\n\tbestResult := make(map[string]float64)\n\tbestCutoff := make(map[string]float64)\n\tfor n := range ps.Priors {\n\t\tbestResult[n] = 0\n\t\tbestMixin[n] = 0\n\t\tbestCutoff[n] = 0\n\t}\n\n\tfor _, cutoff := range cutoffs {\n\n\t\t//                 network      id      loc    value\n\t\tPBayes1 := make(map[string]map[string]map[string]float64)\n\t\tPBayes2 := make(map[string]map[string]map[string]float64)\n\t\ttotalJobs := 0\n\t\tfor n := range ps.Priors {\n\t\t\tit := float64(-1)\n\t\t\tPBayes1[n] = make(map[string]map[string]float64)\n\t\t\tPBayes2[n] = make(map[string]map[string]float64)\n\t\t\tPBayes1[n] = make(map[string]map[string]float64)\n\t\t\tPBayes2[n] = make(map[string]map[string]float64)\n\t\t\tfor _, v1 := range fingerprintsOrdering {\n\t\t\t\tit++\n\t\t\t\tif math.Mod(it, FoldCrossValidation) != 0 {\n\t\t\t\t\t_, ok := ps.NetworkLocs[n][fingerprintsInMemory[v1].Location]\n\t\t\t\t\tif len(fingerprintsInMemory[v1].WifiFingerprint) == 0 || !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\ttotalJobs++\n\t\t\t\t\tPBayes1[n][v1], PBayes2[n][v1] = calculatePosteriorThreadSafe(fingerprintsInMemory[v1], ps, cutoff)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumJobs := len(mixins) * totalJobs\n\t\truntime.GOMAXPROCS(MaxParallelism())\n\t\tchanJobs := make(chan jobA, 1+numJobs)\n\t\tchanResults := make(chan resultA, 1+numJobs)\n\t\tfor w := 1; w <= MaxParallelism(); w++ {\n\t\t\tgo worker(w, chanJobs, chanResults)\n\t\t}\n\n\t\tfinalResults := make(map[string]map[float64]ResultsParameters)\n\t\tfor n := range ps.Priors {\n\t\t\tfinalResults[n] = make(map[float64]ResultsParameters)\n\t\t\tfor _, mixin := range mixins {\n\n\t\t\t\tfinalResults[n][mixin] = *NewResultsParameters()\n\t\t\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\t\t\tfinalResults[n][mixin].TotalLocations[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].CorrectLocations[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].Accuracy[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].Guess[loc] = make(map[string]int)\n\t\t\t\t}\n\t\t\t\t// Loop through each fingerprint\n\t\t\t\tfor id := range PBayes1[n] {\n\t\t\t\t\tlocs := []string{}\n\t\t\t\t\tbayes1 := []float64{}\n\t\t\t\t\tbayes2 := []float64{}\n\t\t\t\t\tfor key := range PBayes1[n][id] {\n\t\t\t\t\t\tlocs = append(locs, key)\n\t\t\t\t\t\tbayes1 = append(bayes1, PBayes1[n][id][key])\n\t\t\t\t\t\tbayes2 = append(bayes2, PBayes2[n][id][key])\n\t\t\t\t\t}\n\t\t\t\t\ttrueLoc := fingerprintsInMemory[id].Location\n\t\t\t\t\tchanJobs <- jobA{n: n,\n\t\t\t\t\t\tmixin:        mixin,\n\t\t\t\t\t\tlocs:         locs,\n\t\t\t\t\t\tlocationTrue: trueLoc,\n\t\t\t\t\t\tbayes1:       bayes1,\n\t\t\t\t\t\tbayes2:       bayes2}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(chanJobs)\n\n\t\tfor a := 1; a <= numJobs; a++ {\n\t\t\tt := <-chanResults\n\t\t\tfinalResults[t.n][t.mixin].TotalLocations[t.locationTrue]++\n\t\t\tif t.locationGuess == t.locationTrue {\n\t\t\t\tfinalResults[t.n][t.mixin].CorrectLocations[t.locationTrue]++\n\t\t\t}\n\t\t\tif _, ok := finalResults[t.n][t.mixin].Guess[t.locationTrue]; !ok {\n\t\t\t\tfinalResults[t.n][t.mixin].Guess[t.locationTrue] = make(map[string]int)\n\t\t\t}\n\t\t\tif _, ok := finalResults[t.n][t.mixin].Guess[t.locationTrue][t.locationGuess]; !ok {\n\t\t\t\tfinalResults[t.n][t.mixin].Guess[t.locationTrue][t.locationGuess] = 0\n\t\t\t}\n\t\t\tfinalResults[t.n][t.mixin].Guess[t.locationTrue][t.locationGuess]++\n\t\t}\n\n\t\tfor n := range ps.Priors {\n\t\t\tfor mixin := range finalResults[n] {\n\t\t\t\taverage := float64(0)\n\t\t\t\tit := 0\n\t\t\t\tfor loc := range finalResults[n][mixin].TotalLocations {\n\t\t\t\t\tif finalResults[n][mixin].TotalLocations[loc] > 0 {\n\t\t\t\t\t\tfinalResults[n][mixin].Accuracy[loc] = int(100.0 * finalResults[n][mixin].CorrectLocations[loc] / finalResults[n][mixin].TotalLocations[loc])\n\t\t\t\t\t\t// Debug.Println(n, mixin, cutoff, loc, finalResults[n][mixin].Accuracy[loc])\n\t\t\t\t\t\taverage += float64(finalResults[n][mixin].Accuracy[loc])\n\t\t\t\t\t\tit++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taverage = average / float64(it)\n\t\t\t\t// fmt.Println(mixin, average)\n\t\t\t\tif average > bestResult[n] {\n\t\t\t\t\tbestResult[n] = average\n\t\t\t\t\tbestMixin[n] = mixin\n\t\t\t\t\tbestCutoff[n] = cutoff\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Load new priors and calculate new cross Validation\n\tfor n := range ps.Priors {\n\t\tps.Priors[n].Special[\"MixIn\"] = bestMixin[n]\n\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = bestCutoff[n]\n\t\tcrossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t}\n\n\t// Debug.Println(getUsers(group))\n\tgo resetCache(\"usersCache\")\n\tgo saveParameters(group, ps)\n\tgo setPsCache(group, ps)\n\n\treturn nil\n}\n\nfunc optimizePriorsThreadedNot(group string) {\n\t// generate the fingerprintsInMemory\n\t// Debug.Println(\"Optimizing priors for \" + group)\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(k)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(k))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\n\tvar results = *NewResultsParameters()\n\tfor n := range ps.Priors {\n\t\tps.Results[n] = results\n\t}\n\n\t// loop through these parameters\n\tmixins := []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}\n\t// cutoff := 0.1\n\tcutoffs := []float64{0.005, 0.05, 0.1}\n\tbestMixin := make(map[string]float64)\n\tbestResult := make(map[string]float64)\n\tbestCutoff := make(map[string]float64)\n\tfor n := range ps.Priors {\n\t\tbestResult[n] = 0\n\t\tbestMixin[n] = 0\n\t\tbestCutoff[n] = 0\n\t}\n\n\tfor _, cutoff := range cutoffs {\n\n\t\t//                 network      id      loc    value\n\t\tPBayes1 := make(map[string]map[string]map[string]float64)\n\t\tPBayes2 := make(map[string]map[string]map[string]float64)\n\t\ttotalJobs := 0\n\t\tfor n := range ps.Priors {\n\t\t\tit := float64(-1)\n\t\t\tPBayes1[n] = make(map[string]map[string]float64)\n\t\t\tPBayes2[n] = make(map[string]map[string]float64)\n\t\t\tPBayes1[n] = make(map[string]map[string]float64)\n\t\t\tPBayes2[n] = make(map[string]map[string]float64)\n\t\t\tfor _, v1 := range fingerprintsOrdering {\n\t\t\t\tit++\n\t\t\t\tif math.Mod(it, FoldCrossValidation) != 0 {\n\t\t\t\t\t_, ok := ps.NetworkLocs[n][fingerprintsInMemory[v1].Location]\n\t\t\t\t\tif len(fingerprintsInMemory[v1].WifiFingerprint) == 0 || !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\ttotalJobs++\n\t\t\t\t\tPBayes1[n][v1], PBayes2[n][v1] = calculatePosteriorThreadSafe(fingerprintsInMemory[v1], ps, cutoff)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinalResults := make(map[string]map[float64]ResultsParameters)\n\t\tbestMixin := make(map[string]float64)\n\t\tbestResult := make(map[string]float64)\n\t\tfor n := range ps.Priors {\n\t\t\tbestResult[n] = 0\n\t\t\tbestMixin[n] = 0\n\t\t\tfinalResults[n] = make(map[float64]ResultsParameters)\n\t\t\tfor _, mixin := range mixins {\n\n\t\t\t\tfinalResults[n][mixin] = *NewResultsParameters()\n\t\t\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\t\t\tfinalResults[n][mixin].TotalLocations[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].CorrectLocations[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].Accuracy[loc] = 0\n\t\t\t\t\tfinalResults[n][mixin].Guess[loc] = make(map[string]int)\n\t\t\t\t}\n\t\t\t\t// Loop through each fingerprint\n\t\t\t\tfor id := range PBayes1[n] {\n\t\t\t\t\tmaxVal := float64(-1)\n\t\t\t\t\tlocationGuess := \"\"\n\t\t\t\t\tfor key := range PBayes1[n][id] {\n\t\t\t\t\t\tPBayesMix := mixin*PBayes1[n][id][key] + (1-mixin)*PBayes2[n][id][key]\n\t\t\t\t\t\tif PBayesMix > maxVal {\n\t\t\t\t\t\t\tmaxVal = PBayesMix\n\t\t\t\t\t\t\tlocationGuess = key\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlocationTrue := fingerprintsInMemory[id].Location\n\t\t\t\t\t\tfinalResults[n][mixin].TotalLocations[locationTrue]++\n\t\t\t\t\t\tif locationGuess == locationTrue {\n\t\t\t\t\t\t\tfinalResults[n][mixin].CorrectLocations[locationTrue]++\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif _, ok := finalResults[n][mixin].Guess[locationTrue]; !ok {\n\t\t\t\t\t\t\tfinalResults[n][mixin].Guess[locationTrue] = make(map[string]int)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif _, ok := finalResults[n][mixin].Guess[locationTrue][locationGuess]; !ok {\n\t\t\t\t\t\t\tfinalResults[n][mixin].Guess[locationTrue][locationGuess] = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinalResults[n][mixin].Guess[locationTrue][locationGuess]++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taverage := float64(0)\n\t\t\t\tit := 0\n\t\t\t\tfor loc := range finalResults[n][mixin].TotalLocations {\n\t\t\t\t\tif finalResults[n][mixin].TotalLocations[loc] > 0 {\n\t\t\t\t\t\tfinalResults[n][mixin].Accuracy[loc] = int(100.0 * finalResults[n][mixin].CorrectLocations[loc] / finalResults[n][mixin].TotalLocations[loc])\n\t\t\t\t\t\taverage += float64(finalResults[n][mixin].Accuracy[loc])\n\t\t\t\t\t\tit++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taverage = average / float64(it)\n\t\t\t\t// fmt.Println(mixin, average, a)\n\t\t\t\tif average > bestResult[n] {\n\t\t\t\t\tbestResult[n] = average\n\t\t\t\t\tbestMixin[n] = mixin\n\t\t\t\t\tbestCutoff[n] = cutoff\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Load new priors and calculate new cross Validation\n\tfor n := range ps.Priors {\n\t\tps.Priors[n].Special[\"MixIn\"] = bestMixin[n]\n\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = bestCutoff[n]\n\t\tcrossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t}\n\tgo saveParameters(group, ps)\n\tgo setPsCache(group, ps)\n\t// Debug.Println(\"Analyzed \", totalJobs, \" fingerprints\")\n}\n"
        },
        {
          "name": "priors_test.go",
          "type": "blob",
          "size": 2.6630859375,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPriorsThreaded(t *testing.T) {\n\tassert.Equal(t, optimizePriorsThreaded(\"testdb\"), nil)\n}\n\n// func ExampleTestPriors() {\n// \t// optimizePriors(\"testdb\")\n// \tfmt.Println(\"OK\")\n// \t// Output: OK\n// }\n\n//go test -test.bench BenchmarkOptimizePriors -test.benchmem\nfunc BenchmarkOptimizePriors(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\toptimizePriors(\"testdb\")\n\t}\n}\n\nfunc BenchmarkOptimizePriorsThreaded(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\toptimizePriorsThreaded(\"testdb\")\n\t}\n}\n\nfunc BenchmarkOptimizePriorsThreadedNot(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\toptimizePriorsThreadedNot(\"testdb\")\n\t}\n}\n\nfunc BenchmarkCrossValidation(b *testing.B) {\n\tgroup := \"testdb\"\n\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(k)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(k))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\tvar results = *NewResultsParameters()\n\tfor n := range ps.Priors {\n\t\tps.Results[n] = results\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor n := range ps.Priors {\n\t\t\tps.Priors[n].Special[\"MixIn\"] = 0.5\n\t\t\tps.Priors[n].Special[\"VarabilityCutoff\"] = 0.005\n\t\t\tcrossValidation(group, n, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc BenchmarkCalculatePriors(b *testing.B) {\n\tgroup := \"testdb\"\n\t// generate the fingerprintsInMemory\n\tfingerprintsInMemory := make(map[string]Fingerprint)\n\tvar fingerprintsOrdering []string\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfingerprintsInMemory[string(v)] = loadFingerprint(v)\n\t\t\tfingerprintsOrdering = append(fingerprintsOrdering, string(v))\n\t\t}\n\t\treturn nil\n\t})\n\tdb.Close()\n\n\tvar ps = *NewFullParameters()\n\tgetParameters(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tcalculatePriors(group, &ps, fingerprintsInMemory, fingerprintsOrdering)\n\t}\n}\n"
        },
        {
          "name": "rf.go",
          "type": "blob",
          "size": 2.1669921875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc RandomString(strlen int) string {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tconst chars = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n\tresult := make([]byte, strlen)\n\tfor i := 0; i < strlen; i++ {\n\t\tresult[i] = chars[rand.Intn(len(chars))]\n\t}\n\treturn string(result)\n}\n\nfunc rfLearn(group string) float64 {\n\ttempFile := group + \".rf.json\"\n\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0664, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\n\tDebug.Println(\"Writing \" + tempFile)\n\tf, err := os.OpenFile(path.Join(RuntimeArgs.SourcePath, tempFile), os.O_WRONLY|os.O_CREATE, 0664)\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tbJSON, _ := json.Marshal(v2)\n\t\t\tf.WriteString(string(bJSON) + \"\\n\")\n\t\t}\n\t\treturn nil\n\t})\n\tf.Close()\n\n\t// Do learning\n\tconn, _ := net.Dial(\"tcp\", \"127.0.0.1:\"+RuntimeArgs.RFPort)\n\t// send to socket\n\tfmt.Fprintf(conn, group+\"=\")\n\t// listen for reply\n\tout, _ := bufio.NewReader(conn).ReadString('\\n')\n\n\tclassificationSuccess, err := strconv.ParseFloat(strings.TrimSpace(string(out)), 64)\n\tif err != nil {\n\t\tError.Println(string(out))\n\t}\n\tDebug.Printf(\"RF classification success for '%s' is %2.2f\", group, classificationSuccess)\n\tos.Remove(tempFile)\n\treturn classificationSuccess\n}\n\nfunc rfClassify(group string, fingerprint Fingerprint) map[string]float64 {\n\tvar m map[string]float64\n\ttempFile := RandomString(10)\n\td1, _ := json.Marshal(fingerprint)\n\terr := ioutil.WriteFile(tempFile+\".rftemp\", d1, 0644)\n\tif err != nil {\n\t\tError.Println(\"Could not write file: \" + err.Error())\n\t\treturn m\n\t}\n\n\t// connect to this socket\n\tconn, _ := net.Dial(\"tcp\", \"127.0.0.1:\"+RuntimeArgs.RFPort)\n\t// send to socket\n\tfmt.Fprintf(conn, group+\"=\"+tempFile)\n\t// listen for reply\n\tmessage, _ := bufio.NewReader(conn).ReadString('\\n')\n\n\terr = json.Unmarshal([]byte(message), &m)\n\tif err != nil {\n\t\t// do nothing\n\t}\n\n\tos.Remove(tempFile + \".rftemp\")\n\treturn m\n}\n"
        },
        {
          "name": "rf.py",
          "type": "blob",
          "size": 8.12890625,
          "content": "import json\nimport sys\nimport os\nimport pickle\nimport sklearn\nimport random\nimport numpy\nimport socket\nimport threading\nimport argparse\nfrom random import shuffle\n\nimport socketserver\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.pipeline import make_pipeline\n\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.gaussian_process import GaussianProcessClassifier\nfrom sklearn.gaussian_process.kernels import RBF\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\n\n\nDEBUG = False\n\nrandom.seed(123)\n\n\nclass RF(object):\n    #data = []\n\n    def __init__(self):\n        self.size = 0\n        self.data = []\n        self.nameX = []\n        self.trainX = numpy.array([])\n        self.testX = numpy.array([])\n        self.nameY = []\n        self.trainY = []\n        self.testY = []\n        self.macSet = set()\n        self.locationSet = set()\n\n    def get_data(self, fname, splitRatio):\n        # First go through once and get set of macs/locations\n        X = []\n        with open(\"data/\" + fname + \".rf.json\", 'r') as f_in:\n            for fingerprint in f_in:\n                try:\n                    data = json.loads(fingerprint)\n                except:\n                    pass\n                X.append(data)\n                self.locationSet.add(data['location'])\n                for signal in data['wifi-fingerprint']:\n                    self.macSet.add(signal['mac'])\n\n        if DEBUG:\n            print(\"Loaded %d fingerprints\" % len(X))\n\n        # Convert them to lists, for indexing\n        self.nameX = list(self.macSet)\n        self.nameY = list(self.locationSet)\n\n        # Go through the data again, in a random way\n        shuffle(X)\n        # Split the dataset for training / learning\n        trainSize = int(len(X) * splitRatio)\n        if DEBUG:\n            print(\"Training size is %d fingerprints\" % trainSize)\n        # Initialize X, Y matricies for training and testing\n        self.trainX = numpy.zeros((trainSize, len(self.nameX)))\n        self.testX = numpy.zeros((len(X) - trainSize, len(self.nameX)))\n        self.trainY = [0] * trainSize\n        self.testY = [0] * (len(X) - trainSize)\n        curRowTrain = 0\n        curRowTest = 0\n        for i in range(len(X)):\n            newRow = numpy.zeros(len(self.nameX))\n            for signal in X[i]['wifi-fingerprint']:\n                newRow[self.nameX.index(signal['mac'])] = signal['rssi']\n            if i < trainSize:  # do training\n                self.trainX[curRowTrain, :] = newRow\n                self.trainY[curRowTrain] = self.nameY.index(X[i]['location'])\n                curRowTrain = curRowTrain + 1\n            else:\n                self.testX[curRowTest, :] = newRow\n                self.testY[curRowTest] = self.nameY.index(X[i]['location'])\n                curRowTest = curRowTest + 1\n\n    def learn(self, dataFile, splitRatio):\n        self.get_data(dataFile, splitRatio)\n        if DEBUG:\n            names = [\n                \"Nearest Neighbors\",\n                \"Linear SVM\",\n                \"RBF SVM\",\n                \"Gaussian Process\",\n                \"Decision Tree\",\n                \"Random Forest\",\n                \"Neural Net\",\n                \"AdaBoost\",\n                \"Naive Bayes\",\n                \"QDA\"]\n            classifiers = [\n                KNeighborsClassifier(3),\n                SVC(kernel=\"linear\", C=0.025),\n                SVC(gamma=2, C=1),\n                GaussianProcessClassifier(1.0 * RBF(1.0), warm_start=True),\n                DecisionTreeClassifier(max_depth=5),\n                RandomForestClassifier(max_depth=5, n_estimators=10, max_features=1),\n                MLPClassifier(alpha=1),\n                AdaBoostClassifier(),\n                GaussianNB(),\n                QuadraticDiscriminantAnalysis()]\n            for name, clf in zip(names, classifiers):\n                try:\n                    clf.fit(self.trainX, self.trainY)\n                    score = clf.score(self.testX, self.testY)\n                    print(name, score)\n                except:\n                    pass\n\n        # for max_feature in [\"auto\",\"log2\",None,\"sqrt\"]:\n        # \tfor n_estimator in range(1,30,1):\n        # \t\tfor min_samples_split in range(2,10):\n        # \t\t\tclf = RandomForestClassifier(n_estimators=n_estimator,\n        # \t\t\t\tmax_features=max_feature,\n        # \t\t\t\tmax_depth=None,\n        # \t\t\t\tmin_samples_split=min_samples_split,\n        # \t\t\t\trandom_state=0)\n        # \t\t\tclf.fit(self.trainX, self.trainY)\n        # \t\t\tprint(max_feature,n_estimator,min_samples_split,clf.score(self.testX, self.testY))\n\n        clf = RandomForestClassifier(\n            n_estimators=10,\n            max_depth=None,\n            min_samples_split=2,\n            random_state=0)\n        clf.fit(self.trainX, self.trainY)\n        score = clf.score(self.testX, self.testY)\n        with open('data/' + dataFile + '.rf.pkl', 'wb') as fid:\n            pickle.dump([clf, self.nameX, self.nameY], fid)\n        return score\n\n    def classify(self, groupName, fingerpintFile):\n        with open('data/' + groupName + '.rf.pkl', 'rb') as pickle_file:\n            [clf, self.nameX, self.nameY] = pickle.load(pickle_file)\n\n        # As before, we need a row that defines the macs\n        newRow = numpy.zeros(len(self.nameX))\n        data = {}\n        with open(fingerpintFile, 'r') as f_in:\n            for line in f_in:\n                data = json.loads(line)\n        if len(data) == 0:\n            return\n        for signal in data['wifi-fingerprint']:\n            # Only add the mac if it exists in the learning model\n            if signal['mac'] in self.nameX:\n                newRow[self.nameX.index(signal['mac'])] = signal['rssi']\n\n        prediction = clf.predict_proba(newRow.reshape(1, -1))\n        predictionJson = {}\n        for i in range(len(prediction[0])):\n            predictionJson[self.nameY[i]] = prediction[0][i]\n        return predictionJson\n\n\nclass EchoRequestHandler(socketserver.BaseRequestHandler):\n\n    def handle(self):\n        # Echo the back to the client\n        data = self.request.recv(1024)\n        data = data.decode('utf-8').strip()\n        print(\"received data:'%s'\" % data)\n        group = data.split('=')[0].strip()\n        filename = data.split('=')[1].strip()\n        payload = \"error\".encode('utf-8')\n        if len(group) == 0:\n            self.request.send(payload)\n            return\n        randomF = RF()\n        if len(filename) == 0:\n            payload = json.dumps(randomF.learn(group, 0.9)).encode('utf-8')\n        else:\n            payload = json.dumps(\n                randomF.classify(\n                    group,\n                    filename +\n                    \".rftemp\")).encode('utf-8')\n        self.request.send(payload)\n        return\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-p\",\n        \"--port\",\n        type=int,\n        help=\"select the port to run on\")\n    parser.add_argument(\"-g\", \"--group\", type=str, help=\"select a group\")\n    parser.add_argument(\n        \"-f\",\n        \"--file\",\n        type=str,\n        help=\"select a file with fingerprints\")\n    parser.add_argument(\"-d\", \"--debug\", help=\"debug mode\")\n    args = parser.parse_args()\n    DEBUG = args.debug\n    if args.port is not None:\n        socketserver.TCPServer.allow_reuse_address = True\n        address = ('localhost', args.port)  # let the kernel give us a port\n        server = socketserver.TCPServer(address, EchoRequestHandler)\n        ip, port = server.server_address  # find out what port we were given\n        server.serve_forever()\n    elif args.file is not None and args.group is not None:\n        randomF = RF()\n        print(randomF.classify(args.group, args.file))\n    elif args.group is not None:\n        randomF = RF()\n        print(randomF.learn(args.group, 0.5))\n    else:\n        print(\"\"\"Usage:\n\nTo just run as TCP server:\n\n\tpython3 rf.py --port 5009\n\nTo just learn:\n\n\tpython3 rf.py --group GROUP\n\nTo classify\n\n\tpython3 rf.py --group GROUP --file FILEWITHFINGERPRINTS\n\"\"\")\n"
        },
        {
          "name": "routes.go",
          "type": "blob",
          "size": 8.58203125,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// routes.go contains the functions that handle the web page views\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// slash returns the dashboard, if logged in, else it redirects to login page.\nfunc slash(c *gin.Context) {\n\tvar group string\n\tloginGroup := sessions.Default(c)\n\tgroupCookie := loginGroup.Get(\"group\")\n\tif groupCookie == nil {\n\t\tc.Redirect(302, \"/login\")\n\t} else {\n\t\tgroup = groupCookie.(string)\n\t\tc.Redirect(302, \"/dashboard/\"+group)\n\t}\n}\n\n// slashLogin handles a login with url parameter and returns dashboard if successful, else login.\nfunc slashLogin(c *gin.Context) {\n\tloginGroup := sessions.Default(c)\n\tgroup := c.DefaultQuery(\"group\", \"noneasdf\")\n\tif group == \"noneasdf\" {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{})\n\t} else {\n\t\tloginGroup.Set(\"group\", group)\n\t\tloginGroup.Save()\n\t\tc.Redirect(302, \"/dashboard/\"+group)\n\t}\n}\n\n// slashLogin handles a POST login and returns dashboard if successful, else login.\nfunc slashLoginPOST(c *gin.Context) {\n\tloginGroup := sessions.Default(c)\n\tgroup := strings.ToLower(c.PostForm(\"group\"))\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); err == nil {\n\t\tloginGroup.Set(\"group\", group)\n\t\tloginGroup.Save()\n\t\tc.Redirect(302, \"/dashboard/\"+group)\n\t} else {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"Incorrect login.\",\n\t\t})\n\t}\n}\n\n// slashLogout handles a logout\nfunc slashLogout(c *gin.Context) {\n\tvar group string\n\tloginGroup := sessions.Default(c)\n\tgroupCookie := loginGroup.Get(\"group\")\n\tif groupCookie == nil {\n\t\tc.Redirect(302, \"/login\")\n\t} else {\n\t\tgroup = groupCookie.(string)\n\t\tfmt.Println(group)\n\t\tloginGroup.Clear()\n\t\tloginGroup.Save()\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"Message\": \"You are now logged out.\",\n\t\t})\n\t}\n}\n\n// slashDashboard displays the dashboard\nfunc slashDashboard(c *gin.Context) {\n\t// skipUsers := c.DefaultQuery(\"skip\", \"\")\n\t// skipAllUsers := false\n\t// if len(skipUsers) > 0 {\n\t// \tskipAllUsers = true\n\t// }\n\tfilterUser := c.DefaultQuery(\"user\", \"\")\n\tfilterUsers := c.DefaultQuery(\"users\", \"\")\n\tfilterUserMap := make(map[string]bool)\n\tif len(filterUser) > 0 {\n\t\tu := strings.Replace(strings.TrimSpace(filterUser), \":\", \"\", -1)\n\t\tfilterUserMap[u] = true\n\t}\n\tif len(filterUsers) > 0 {\n\t\tfor _, user := range strings.Split(filterUsers, \",\") {\n\t\t\tu := strings.Replace(strings.TrimSpace(user), \":\", \"\", -1)\n\t\t\tfilterUserMap[u] = true\n\t\t}\n\t}\n\tgroup := c.Param(\"group\")\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); os.IsNotExist(err) {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"First download the app or CLI program to insert some fingerprints.\",\n\t\t})\n\t\treturn\n\t}\n\tps, _ := openParameters(group)\n\tvar users []string\n\tfor user := range filterUserMap {\n\t\tusers = append(users, user)\n\t}\n\tpeople := make(map[string]UserPositionJSON)\n\tif len(users) == 0 {\n\t\tpeople = getCurrentPositionOfAllUsers(group)\n\t} else {\n\t\tfor _, user := range users {\n\t\t\tpeople[user] = getCurrentPositionOfUser(group, user)\n\t\t}\n\t}\n\ttype DashboardData struct {\n\t\tNetworks         []string\n\t\tLocations        map[string][]string\n\t\tLocationAccuracy map[string]int\n\t\tLocationCount    map[string]int\n\t\tMixin            map[string]float64\n\t\tVarabilityCutoff map[string]float64\n\t\tUsers            map[string]UserPositionJSON\n\t}\n\tvar dash DashboardData\n\tdash.Networks = []string{}\n\tdash.Locations = make(map[string][]string)\n\tdash.LocationAccuracy = make(map[string]int)\n\tdash.LocationCount = make(map[string]int)\n\tdash.Mixin = make(map[string]float64)\n\tdash.VarabilityCutoff = make(map[string]float64)\n\n\tfor n := range ps.NetworkLocs {\n\t\tdash.Mixin[n] = ps.Priors[n].Special[\"MixIn\"]\n\t\tdash.VarabilityCutoff[n] = ps.Priors[n].Special[\"VarabilityCutoff\"]\n\t\tdash.Networks = append(dash.Networks, n)\n\t\tdash.Locations[n] = []string{}\n\t\tfor loc := range ps.NetworkLocs[n] {\n\t\t\tdash.Locations[n] = append(dash.Locations[n], loc)\n\t\t\tdash.LocationAccuracy[loc] = ps.Results[n].Accuracy[loc]\n\t\t\tdash.LocationCount[loc] = ps.Results[n].TotalLocations[loc]\n\t\t}\n\t}\n\tc.HTML(http.StatusOK, \"dashboard.tmpl\", gin.H{\n\t\t\"Message\": RuntimeArgs.Message,\n\t\t\"Group\":   group,\n\t\t\"Dash\":    dash,\n\t\t\"Users\":   people,\n\t})\n}\n\n// slash Location returns location (to be deprecated)\nfunc slashLocation(c *gin.Context) {\n\tgroup := c.Param(\"group\")\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); os.IsNotExist(err) {\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": \"false\", \"message\": \"First download the app or CLI program to insert some fingerprints.\"})\n\t\treturn\n\t}\n\tuser := c.Param(\"user\")\n\tuserJSON := getCurrentPositionOfUser(group, user)\n\tc.JSON(http.StatusOK, userJSON)\n}\n\n// slashExplore returns a chart of the data\nfunc slashExplore(c *gin.Context) {\n\tgroup := c.Param(\"group\")\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); os.IsNotExist(err) {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"First download the app or CLI program to insert some fingerprints.\",\n\t\t})\n\t\treturn\n\t}\n\tnetwork := c.Param(\"network\")\n\tlocation := c.Param(\"location\")\n\tps, _ := openParameters(group)\n\t// TODO: check if network and location exists in the ps, if not return 404\n\tdatas := []template.JS{}\n\tnames := []template.JS{}\n\tindexNames := []template.JS{}\n\t// Sort locations\n\tmacs := []string{}\n\tfor m := range ps.Priors[network].P[location] {\n\t\tif float64(ps.MacVariability[m]) > ps.Priors[network].Special[\"VarabilityCutoff\"] {\n\t\t\tmacs = append(macs, m)\n\t\t}\n\t}\n\tsort.Strings(macs)\n\tit := 0\n\tfor _, m := range macs {\n\t\tn := ps.Priors[network].P[location][m]\n\t\tnames = append(names, template.JS(string(m)))\n\t\tjsonByte, _ := json.Marshal(n)\n\t\tdatas = append(datas, template.JS(string(jsonByte)))\n\t\tindexNames = append(indexNames, template.JS(strconv.Itoa(it)))\n\t\tit++\n\t}\n\trsiRange, _ := json.Marshal(RssiRange)\n\tc.HTML(http.StatusOK, \"plot.tmpl\", gin.H{\n\t\t\"RssiRange\":  template.JS(string(rsiRange)),\n\t\t\"Datas\":      datas,\n\t\t\"Names\":      names,\n\t\t\"IndexNames\": indexNames,\n\t})\n}\n\n// slashExplore returns a chart of the data (canvas.js)\nfunc slashExplore2(c *gin.Context) {\n\tgroup := c.Param(\"group\")\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); os.IsNotExist(err) {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"First download the app or CLI program to insert some fingerprints.\",\n\t\t})\n\t\treturn\n\t}\n\n\tnetwork := c.Param(\"network\")\n\tlocation := c.Param(\"location\")\n\tps, _ := openParameters(group)\n\tfmt.Println(ps.UniqueLocs)\n\tlookUpLocation := false\n\n\tfor _, loc := range ps.UniqueLocs {\n\t\tif location == loc {\n\t\t\tlookUpLocation = true\n\t\t}\n\t}\n\n\ttype macDatum struct {\n\t\tName   string    `json:\"name\"`\n\t\tPoints []float32 `json:\"data\"`\n\t}\n\n\ttype macDatas struct {\n\t\tMacs []macDatum `json:\"macs\"`\n\t}\n\n\tvar data macDatas\n\tdata.Macs = []macDatum{}\n\n\tif lookUpLocation {\n\t\t// Sort locations\n\t\tmacs := []string{}\n\t\tfor m := range ps.Priors[network].P[location] {\n\t\t\tif float64(ps.MacVariability[m]) > ps.Priors[network].Special[\"VarabilityCutoff\"] {\n\t\t\t\tmacs = append(macs, m)\n\t\t\t}\n\t\t}\n\t\tsort.Strings(macs)\n\n\t\tfor _, m := range macs {\n\t\t\tn := ps.Priors[network].P[location][m]\n\t\t\tdata.Macs = append(data.Macs, macDatum{Name: m, Points: n})\n\t\t}\n\t} else {\n\t\tm := location\n\t\tfor loc := range ps.Priors[network].P {\n\t\t\tn := ps.Priors[network].P[loc][m]\n\t\t\tdata.Macs = append(data.Macs, macDatum{Name: strings.Replace(loc, \" \", \"%20\", -1), Points: n})\n\t\t}\n\t}\n\n\tc.HTML(http.StatusOK, \"plot2.tmpl\", gin.H{\n\t\t\"Data\":    data,\n\t\t\"Rssi\":    RssiRange,\n\t\t\"Title\":   group + \"/\" + network + \"/\" + location,\n\t\t\"Group\":   strings.Replace(group, \" \", \"%20\", -1),\n\t\t\"Network\": strings.Replace(network, \" \", \"%20\", -1),\n\t\t\"Legend\":  !lookUpLocation,\n\t})\n}\n\n// slashPie returns a Pie chart\nfunc slashPie(c *gin.Context) {\n\tgroup := c.Param(\"group\")\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, group+\".db\")); os.IsNotExist(err) {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"First download the app or CLI program to insert some fingerprints.\",\n\t\t})\n\t\treturn\n\t}\n\n\tnetwork := c.Param(\"network\")\n\tlocation := c.Param(\"location\")\n\tps, _ := openParameters(group)\n\tvals := []int{}\n\tnames := []string{}\n\tfmt.Println(ps.Results[network].Guess[location])\n\tfor guessloc, val := range ps.Results[network].Guess[location] {\n\t\tnames = append(names, guessloc)\n\t\tvals = append(vals, val)\n\t}\n\tnamesJSON, _ := json.Marshal(names)\n\tvalsJSON, _ := json.Marshal(vals)\n\tc.HTML(http.StatusOK, \"pie.tmpl\", gin.H{\n\t\t\"Names\": template.JS(namesJSON),\n\t\t\"Vals\":  template.JS(valsJSON),\n\t})\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 8.2802734375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// server.go handles Flag parsing and starts the Gin-Tonic webserver.\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// RuntimeArgs contains all runtime\n// arguments available\nvar RuntimeArgs struct {\n\tRFPort            string\n\tFilterMacFile     string\n\tExternalIP        string\n\tPort              string\n\tServerCRT         string\n\tServerKey         string\n\tSourcePath        string\n\tSocket            string\n\tCwd               string\n\tMqttServer        string\n\tMqttAdmin         string\n\tMosquittoPID      string\n\tMqttAdminPassword string\n\tDump              string\n\tMessage           string\n\tMqtt              bool\n\tMqttExisting      bool\n\tSvm               bool\n\tRandomForests     bool\n\tFiltering         bool\n\tFilterMacs        map[string]bool\n}\n\n// VersionNum keeps track of the version\nvar VersionNum string\nvar BuildTime string\nvar Build string\n\n// init initiates the paths in RuntimeArgs\nfunc init() {\n\tcwd, _ := os.Getwd()\n\tRuntimeArgs.Cwd = cwd\n\tRuntimeArgs.SourcePath = path.Join(RuntimeArgs.Cwd, \"data\")\n\tRuntimeArgs.Message = \"\"\n}\n\nfunc main() {\n\t// _, executableFile, _, _ := runtime.Caller(0) // get full path of this file\n\tif len(Build) == 0 {\n\t\tBuild = \"devdevdevdevdevdevdev\"\n\t}\n\t// Bing flags for changing parameters of FIND\n\tflag.StringVar(&RuntimeArgs.Port, \"p\", \":8003\", \"port to bind\")\n\tflag.StringVar(&RuntimeArgs.Socket, \"s\", \"\", \"unix socket\")\n\tflag.StringVar(&RuntimeArgs.ServerCRT, \"crt\", \"\", \"location of ssl crt\")\n\tflag.StringVar(&RuntimeArgs.ServerKey, \"key\", \"\", \"location of ssl key\")\n\tflag.StringVar(&RuntimeArgs.MqttServer, \"mqtt\", \"\", \"ADDRESS:PORT of mosquitto server\")\n\tflag.StringVar(&RuntimeArgs.MqttAdmin, \"mqttadmin\", \"\", \"admin to read all messages\")\n\tflag.StringVar(&RuntimeArgs.MqttAdminPassword, \"mqttadminpass\", \"\", \"admin to read all messages\")\n\tflag.StringVar(&RuntimeArgs.MosquittoPID, \"mosquitto\", \"\", \"mosquitto PID (`pgrep mosquitto`)\")\n\tflag.StringVar(&RuntimeArgs.Dump, \"dump\", \"\", \"group to dump to folder\")\n\tflag.StringVar(&RuntimeArgs.Message, \"message\", \"\", \"message to display to all users\")\n\tflag.StringVar(&RuntimeArgs.SourcePath, \"data\", \"\", \"path to data folder\")\n\tflag.StringVar(&RuntimeArgs.RFPort, \"rf\", \"\", \"port for random forests calculations\")\n\tflag.StringVar(&RuntimeArgs.FilterMacFile, \"filter\", \"\", \"JSON file for macs to filter\")\n\tflag.CommandLine.Usage = func() {\n\t\tfmt.Println(`find (version ` + VersionNum + ` (` + Build[0:8] + `), built ` + BuildTime + `)\nExample: 'findserver yourserver.com'\nExample: 'findserver -p :8080 localhost:8080'\nExample (mosquitto): 'findserver -mqtt 127.0.0.1:1883 -mqttadmin admin -mqttadminpass somepass -mosquitto ` + \"`pgrep mosquitto`\" + `\nOptions:`)\n\t\tflag.CommandLine.PrintDefaults()\n\t}\n\tflag.Parse()\n\tRuntimeArgs.ExternalIP = flag.Arg(0)\n\tif RuntimeArgs.ExternalIP == \"\" {\n\t\tRuntimeArgs.ExternalIP = GetLocalIP() + RuntimeArgs.Port\n\t}\n\n\tif RuntimeArgs.SourcePath == \"\" {\n\t\tRuntimeArgs.SourcePath = path.Join(RuntimeArgs.Cwd, \"data\")\n\t}\n\tfmt.Println(RuntimeArgs.SourcePath)\n\n\t// Check whether all the MQTT variables are passed to initiate the MQTT routines\n\tif len(RuntimeArgs.MqttServer) > 0 && len(RuntimeArgs.MqttAdmin) > 0 && len(RuntimeArgs.MosquittoPID) > 0 {\n\t\tRuntimeArgs.Mqtt = true\n\t\tsetupMqtt()\n\t} else {\n                if len(RuntimeArgs.MqttServer) > 0 {\n                        RuntimeArgs.Mqtt = true\n                        RuntimeArgs.MqttExisting = true\n                        setupMqtt()\n                } else {\n\t\t        RuntimeArgs.Mqtt = false\n                }\n\t}\n\n\t// Check whether random forests are used\n\tif len(RuntimeArgs.RFPort) > 0 {\n\t\tRuntimeArgs.RandomForests = true\n\t}\n\n\t// Check whether macs should be filtered\n\tif len(RuntimeArgs.FilterMacFile) > 0 {\n\t\tb, err := ioutil.ReadFile(RuntimeArgs.FilterMacFile)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tRuntimeArgs.FilterMacs = make(map[string]bool)\n\t\tjson.Unmarshal(b, &RuntimeArgs.FilterMacs)\n\t\tfmt.Printf(\"Filtering %+v\", RuntimeArgs.FilterMacs)\n\t\tRuntimeArgs.Filtering = true\n\t}\n\t// Check whether we are just dumping the database\n\tif len(RuntimeArgs.Dump) > 0 {\n\t\terr := dumpFingerprints(strings.ToLower(RuntimeArgs.Dump))\n\t\tif err == nil {\n\t\t\tfmt.Println(\"Successfully dumped.\")\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tos.Exit(1)\n\t}\n\n\t// Check if there is a message from the admin\n\tif _, err := os.Stat(path.Join(RuntimeArgs.Cwd, \"message.txt\")); err == nil {\n\t\tmessageByte, _ := ioutil.ReadFile(path.Join(RuntimeArgs.Cwd, \"message.txt\"))\n\t\tRuntimeArgs.Message = string(messageByte)\n\t}\n\n\t// Check whether SVM libraries are available\n\tcmdOut, _ := exec.Command(\"svm-scale\", \"\").CombinedOutput()\n\tif len(cmdOut) == 0 {\n\t\tRuntimeArgs.Svm = false\n\t\tfmt.Println(\"SVM is not detected.\")\n\t\tfmt.Println(`To install:\nsudo apt-get install g++\nwget http://www.csie.ntu.edu.tw/~cjlin/cgi-bin/libsvm.cgi?+http://www.csie.ntu.edu.tw/~cjlin/libsvm+tar.gz\ntar -xvf libsvm-*.tar.gz\ncd libsvm-*\nmake\ncp svm-scale /usr/local/bin/\ncp svm-predict /usr/local/bin/\ncp svm-train /usr/local/bin/`)\n\t} else {\n\t\tRuntimeArgs.Svm = true\n\t}\n\n\t// Setup Gin-Gonic\n\tgin.SetMode(gin.ReleaseMode)\n\tr := gin.Default()\n\n\t// Load templates\n\tr.LoadHTMLGlob(path.Join(RuntimeArgs.Cwd, \"templates/*\"))\n\n\t// Load static files (if they are not hosted by external service)\n\tr.Static(\"static/\", path.Join(RuntimeArgs.Cwd, \"static/\"))\n\n\t// Create cookie store to keep track of logged in user\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\t// 404-page redirects to login\n\tr.NoRoute(func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"login.tmpl\", gin.H{\n\t\t\t\"ErrorMessage\": \"Please login first.\",\n\t\t})\n\t})\n\n\t// r.PUT(\"/message\", putMessage)\n\n\t// Routes for logging in and viewing dashboards (routes.go)\n\tr.GET(\"/\", slash)\n\tr.GET(\"/login\", slashLogin)\n\tr.POST(\"/login\", slashLoginPOST)\n\tr.GET(\"/logout\", slashLogout)\n\tr.GET(\"/dashboard/:group\", slashDashboard)\n\tr.GET(\"/explore/:group/:network/:location\", slashExplore2)\n\tr.GET(\"/pie/:group/:network/:location\", slashPie)\n\n\t// Routes for performing fingerprinting (fingerprint.go)\n\tr.POST(\"/learn\", learnFingerprintPOST)\n\tr.POST(\"/track\", trackFingerprintPOST)\n\n\t// Routes for MQTT (mqtt.go)\n\tr.PUT(\"/mqtt\", putMQTT)\n\n\t// Routes for API access (api.go)\n\tr.GET(\"/location\", getUserLocations)\n\tr.GET(\"/locations\", getLocationList)\n\tr.GET(\"/editname\", editName)\n\tr.GET(\"/editusername\", editUserName)\n\tr.GET(\"/editnetworkname\", editNetworkName)\n\tr.DELETE(\"/location\", deleteLocation)\n\tr.DELETE(\"/locations\", deleteLocations)\n\tr.DELETE(\"/user\", deleteUser)\n\tr.DELETE(\"/database\", deleteDatabase)\n\tr.GET(\"/calculate\", calculate)\n\tr.GET(\"/status\", getStatus)\n\tr.GET(\"/userlocs\", userLocations) // to be deprecated\n\tr.GET(\"/whereami\", whereAmI)      // to be deprecated\n\tr.PUT(\"/mixin\", putMixinOverride)\n\tr.PUT(\"/cutoff\", putCutoffOverride)\n\tr.PUT(\"/database\", migrateDatabase)\n\tr.GET(\"/lastfingerprint\", apiGetLastFingerprint)\n\n\t// Load and display the logo\n\tdat, _ := ioutil.ReadFile(\"./static/logo.txt\")\n\tfmt.Println(string(dat))\n\n\t// Check whether user is providing certificates\n\tif RuntimeArgs.Socket != \"\" {\n\t\tr.RunUnix(RuntimeArgs.Socket)\n\t} else if RuntimeArgs.ServerCRT != \"\" && RuntimeArgs.ServerKey != \"\" {\n\t\tfmt.Println(`(version ` + VersionNum + ` build ` + Build[0:8] + `) is up and running on https://` + RuntimeArgs.ExternalIP)\n\t\tfmt.Println(\"-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----\")\n\t\tr.RunTLS(RuntimeArgs.Port, RuntimeArgs.ServerCRT, RuntimeArgs.ServerKey)\n\t} else {\n\t\tfmt.Println(`(version ` + VersionNum + ` build ` + Build[0:8] + `) is up and running on http://` + RuntimeArgs.ExternalIP)\n\t\tfmt.Println(\"-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----\")\n\t\tr.Run(RuntimeArgs.Port)\n\t}\n}\n\n// // putMessage usage: curl -G -X PUT \"http://localhost:8003/message\" --data-urlencode \"text=hello world\"\n// func putMessage(c *gin.Context) {\n// \tnewText := c.DefaultQuery(\"text\", \"none\")\n// \tif newText != \"none\" {\n// \t\tRuntimeArgs.Message = newText\n// \t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Message set as '\" + newText + \"'\"})\n// \t} else {\n// \t\tc.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"Error parsing request\"})\n// \t}\n// }\n"
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        },
        {
          "name": "supervisord.conf",
          "type": "blob",
          "size": 1.111328125,
          "content": "[supervisord]\nnodaemon=true\n\n[program:mosquitto]\ncommand=mosquitto -c /etc/mosquitto/mosquitto.conf\npriority=1\nstdout_logfile=/usr/local/work/src/github.com/schollz/find/mosquitto.out\nstdout_logfile_maxbytes=0\nstderr_logfile=/usr/local/work/src/github.com/schollz/find/mosquitto.err\nstderr_logfile_maxbytes=0\n\n[program:findserver]\ndirectory=/usr/local/work/src/github.com/schollz/find\ncommand=/usr/local/work/src/github.com/schollz/find/find -rf 5009 -mqtt %(ENV_MQTT_SERVER)s -mqttadmin %(ENV_MQTT_USERNAME)s -mqttadminpass %(ENV_MQTT_PASSWORD)s -mosquitto `pgrep mosquitto` -data /data\npriority=999\nstdout_logfile=/usr/local/work/src/github.com/schollz/find/log.out\nstdout_logfile_maxbytes=0\nstderr_logfile=/usr/local/work/src/github.com/schollz/find/log.err\nstderr_logfile_maxbytes=0\n\n[program:rftcp]\ndirectory=/usr/local/work/src/github.com/schollz/find\ncommand=/usr/bin/python3 /usr/local/work/src/github.com/schollz/find/rf.py -p 5009\npriority=999\nstdout_logfile=/usr/local/work/src/github.com/schollz/find/rf.out\nstdout_logfile_maxbytes=0\nstderr_logfile=/usr/local/work/src/github.com/schollz/find/rf.err\nstderr_logfile_maxbytes=0\n"
        },
        {
          "name": "svm.go",
          "type": "blob",
          "size": 9.7822265625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// # sudo apt-get install g++\n// # wget http://www.csie.ntu.edu.tw/~cjlin/cgi-bin/libsvm.cgi?+http://www.csie.ntu.edu.tw/~cjlin/libsvm+tar.gz\n// # tar -xvf libsvm-3.18.tar.gz\n// # cd libsvm-3.18\n// # make\n//\n// cp ~/Documents/find/svm ./\n// cat svm | shuf > svm.shuffled\n// ./svm-scale -l 0 -u 1 svm.shuffled > svm.shuffled.scaled\n// head -n 500 svm.shuffled.scaled > learning\n// tail -n 1500 svm.shuffled.scaled > testing\n// ./svm-train -s 0 -t 0 -b 1 learning > /dev/null\n// ./svm-predict -b 1 testing learning.model out\n\ntype Svm struct {\n\tData     string\n\tMac      map[string]string\n\tLocation map[string]string\n}\n\nfunc dumpFingerprintsSVM(group string) error {\n\tmacs := make(map[string]int)\n\tlocations := make(map[string]int)\n\tmacsFromID := make(map[string]string)\n\tlocationsFromID := make(map[string]string)\n\tmacI := 1\n\tlocationI := 1\n\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0755, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tdb.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tfor _, fingerprint := range v2.WifiFingerprint {\n\t\t\t\tif _, ok := macs[fingerprint.Mac]; !ok {\n\t\t\t\t\tmacs[fingerprint.Mac] = macI\n\t\t\t\t\tmacsFromID[strconv.Itoa(macI)] = fingerprint.Mac\n\t\t\t\t\tmacI++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, ok := locations[v2.Location]; !ok {\n\t\t\t\tlocations[v2.Location] = locationI\n\t\t\t\tlocationsFromID[strconv.Itoa(locationI)] = v2.Location\n\t\t\t\tlocationI++\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tsvmData := \"\"\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"fingerprints\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tv2 := loadFingerprint(v)\n\t\t\tsvmData = svmData + makeSVMLine(v2, macs, locations)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"resources\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t\t}\n\t\terr = bucket.Put([]byte(\"svmData\"), []byte(svmData))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\n\t\ts, _ := json.Marshal(macsFromID)\n\t\terr = bucket.Put([]byte(\"macsFromID\"), s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\n\t\ts, _ = json.Marshal(locationsFromID)\n\t\terr = bucket.Put([]byte(\"locationsFromID\"), s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\n\t\ts, _ = json.Marshal(macs)\n\t\terr = bucket.Put([]byte(\"macs\"), s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\n\t\ts, _ = json.Marshal(locations)\n\t\terr = bucket.Put([]byte(\"locations\"), s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could add to bucket: %s\", err)\n\t\t}\n\n\t\treturn err\n\t})\n\n\treturn err\n}\n\nfunc calculateSVM(group string) error {\n\tdefer timeTrack(time.Now(), \"TIMEING\")\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, group+\".db\"), 0755, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\tsvmData := \"\"\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"svmData\"))\n\t\tsvmData = string(v)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif len(svmData) == 0 {\n\t\treturn fmt.Errorf(\"No data\")\n\t}\n\n\tlines := strings.Split(svmData, \"\\n\")\n\tlist := rand.Perm(len(lines))\n\tlearningSet := \"\"\n\ttestingSet := \"\"\n\tfullSet := \"\"\n\tfor i := range list {\n\t\tif len(lines[list[i]]) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif i < len(list)/2 {\n\t\t\tlearningSet = learningSet + lines[list[i]] + \"\\n\"\n\t\t\tfullSet = fullSet + lines[list[i]] + \"\\n\"\n\t\t} else {\n\t\t\tfullSet = fullSet + lines[list[i]] + \"\\n\"\n\t\t\ttestingSet = testingSet + lines[list[i]] + \"\\n\"\n\t\t}\n\t}\n\n\ttempFileFull := RandStringBytesMaskImprSrc(16) + \".full\"\n\ttempFileTrain := RandStringBytesMaskImprSrc(16) + \".learning\"\n\ttempFileTest := RandStringBytesMaskImprSrc(16) + \".testing\"\n\ttempFileOut := RandStringBytesMaskImprSrc(16) + \".out\"\n\td1 := []byte(learningSet)\n\terr = ioutil.WriteFile(tempFileTrain, d1, 0644)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\td1 = []byte(testingSet)\n\terr = ioutil.WriteFile(tempFileTest, d1, 0644)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\td1 = []byte(fullSet)\n\terr = ioutil.WriteFile(tempFileFull, d1, 0644)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// cmd := \"svm-scale\"\n\t// args := \"-l 0 -u 1 \" + tempFileTrain\n\t// Debug.Println(cmd, args)\n\t// outCmd, err := exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t// err = ioutil.WriteFile(tempFileTrain+\".scaled\", outCmd, 0644)\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t//\n\t// cmd = \"svm-scale\"\n\t// args = \"-l 0 -u 1 \" + tempFileTest\n\t// Debug.Println(cmd, args)\n\t// outCmd, err = exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t// err = ioutil.WriteFile(tempFileTest+\".scaled\", outCmd, 0644)\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t//\n\t// cmd = \"svm-scale\"\n\t// args = \"-l 0 -u 1 \" + tempFileFull\n\t// Debug.Println(cmd, args)\n\t// outCmd, err = exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t// err = ioutil.WriteFile(tempFileFull+\".scaled\", outCmd, 0644)\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\n\tcmd := \"svm-train\"\n\targs := \"-s 0 -t 0 -b 1 \" + tempFileFull + \" \" + RuntimeArgs.SourcePath + \"/\" + group + \".model\"\n\tDebug.Println(cmd, args)\n\tif _, err = exec.Command(cmd, strings.Split(args, \" \")...).Output(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcmd = \"svm-train\"\n\targs = \"-s 0 -t 0 -b 1 \" + tempFileTrain + \" \" + tempFileTrain + \".model\"\n\tDebug.Println(cmd, args)\n\tif _, err = exec.Command(cmd, strings.Split(args, \" \")...).Output(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcmd = \"svm-predict\"\n\targs = \"-b 1 \" + tempFileTest + \" \" + tempFileTrain + \".model \" + tempFileOut\n\tDebug.Println(cmd, args)\n\toutCmd, err := exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tDebug.Printf(\"%s SVM: %s\", group, strings.TrimSpace(string(outCmd)))\n\n\t// os.Remove(tempFileTrain + \".scaled\")\n\t// os.Remove(tempFileTest + \".scaled\")\n\t// os.Remove(tempFileFull + \".scaled\")\n\tos.Remove(tempFileTrain)\n\tos.Remove(tempFileTrain + \".model\")\n\tos.Remove(tempFileTest)\n\tos.Remove(tempFileFull)\n\tos.Remove(tempFileOut)\n\treturn nil\n}\n\nfunc classify(jsonFingerprint Fingerprint) (string, map[string]float64) {\n\tif _, err := os.Stat(path.Join(RuntimeArgs.SourcePath, strings.ToLower(jsonFingerprint.Group)+\".model\")); os.IsNotExist(err) {\n\t\treturn \"\", make(map[string]float64)\n\t}\n\tdb, err := bolt.Open(path.Join(RuntimeArgs.SourcePath, jsonFingerprint.Group+\".db\"), 0755, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\n\tvar locations map[string]int\n\tvar macs map[string]int\n\tvar locationsFromID map[string]string\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Assume bucket exists and has keys\n\t\tb := tx.Bucket([]byte(\"resources\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Resources dont exist\")\n\t\t}\n\t\tv := b.Get([]byte(\"locations\"))\n\t\tjson.Unmarshal(v, &locations)\n\t\tv = b.Get([]byte(\"locationsFromID\"))\n\t\tjson.Unmarshal(v, &locationsFromID)\n\t\tv = b.Get([]byte(\"macs\"))\n\t\tjson.Unmarshal(v, &macs)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsvmData := makeSVMLine(jsonFingerprint, macs, locations)\n\tif len(svmData) < 5 {\n\t\tWarning.Println(svmData)\n\t\treturn \"\", make(map[string]float64)\n\t}\n\t// Debug.Println(svmData)\n\n\ttempFileTest := RandStringBytesMaskImprSrc(6) + \".testing\"\n\ttempFileOut := RandStringBytesMaskImprSrc(6) + \".out\"\n\td1 := []byte(svmData)\n\terr = ioutil.WriteFile(tempFileTest, d1, 0644)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// cmd := \"svm-scale\"\n\t// args := \"-l 0 -u 1 \" + tempFileTest\n\t// outCmd, err := exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\t// err = ioutil.WriteFile(tempFileTest+\".scaled\", outCmd, 0644)\n\t// if err != nil {\n\t// \tpanic(err)\n\t// }\n\n\tcmd := \"svm-predict\"\n\targs := \"-b 1 \" + tempFileTest + \" data/\" + jsonFingerprint.Group + \".model \" + tempFileOut\n\t_, err = exec.Command(cmd, strings.Split(args, \" \")...).Output()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdat, err := ioutil.ReadFile(tempFileOut)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tlines := strings.Split(string(dat), \"\\n\")\n\tlabels := strings.Split(lines[0], \" \")\n\tprobabilities := strings.Split(lines[1], \" \")\n\tP := make(map[string]float64)\n\tbestLocation := \"\"\n\tbestP := float64(0)\n\tfor i := range labels {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tPval, _ := strconv.ParseFloat(probabilities[i], 64)\n\t\tif Pval > bestP {\n\t\t\tbestLocation = locationsFromID[labels[i]]\n\t\t\tbestP = Pval\n\t\t}\n\t\tP[locationsFromID[labels[i]]] = math.Log(float64(Pval))\n\t}\n\tos.Remove(tempFileTest)\n\t// os.Remove(tempFileTest + \".scaled\")\n\tos.Remove(tempFileOut)\n\t// Debug.Println(P)\n\treturn bestLocation, P\n}\n\nfunc makeSVMLine(v2 Fingerprint, macs map[string]int, locations map[string]int) string {\n\tm := make(map[int]int)\n\tfor _, fingerprint := range v2.WifiFingerprint {\n\t\tif _, ok := macs[fingerprint.Mac]; ok {\n\t\t\tm[macs[fingerprint.Mac]] = fingerprint.Rssi\n\t\t}\n\t}\n\tvar keys []int\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Ints(keys)\n\n\tsvmData := \"\"\n\t// for i := 0; i < 3; i++ {\n\tif _, ok := locations[v2.Location]; ok {\n\t\tsvmData = svmData + strconv.Itoa(locations[v2.Location]) + \" \"\n\t} else {\n\t\tsvmData = svmData + \"1 \"\n\t}\n\tfor _, k := range keys {\n\t\tsvmData = svmData + strconv.Itoa(k) + \":\" + strconv.Itoa(m[k]) + \" \"\n\t}\n\tsvmData = svmData + \"\\n\"\n\t// }\n\n\treturn svmData\n}\n\n// cp ~/Documents/find/svm ./\n// cat svm | shuf > svm.shuffled\n// ./svm-scale -l 0 -u 1 svm.shuffled > svm.shuffled.scaled\n// head -n 500 svm.shuffled.scaled > learning\n// tail -n 1500 svm.shuffled.scaled > testing\n// ./svm-train -s 0 -t 0 -b 1 learning > /dev/null\n// ./svm-predict -b 1 testing learning.model out\n"
        },
        {
          "name": "svm_test.go",
          "type": "blob",
          "size": 1.3310546875,
          "content": "package main\n\n// func TestDumpFingerprintsSVM(t *testing.T) {\n// \tassert.Equal(t, dumpFingerprintsSVM(\"testdb\"), nil)\n// }\n//\n// func TestCalculateSVM(t *testing.T) {\n// \tassert.Equal(t, calculateSVM(\"testdb\"), nil)\n// }\n//\n// func BenchmarkClassifySVM(b *testing.B) {\n// \tjsonTest := `{\"username\": \"zack\", \"group\": \"testdb\", \"wifi-fingerprint\": [{\"rssi\": -45, \"mac\": \"80:37:73:ba:f7:d8\"}, {\"rssi\": -58, \"mac\": \"80:37:73:ba:f7:dc\"}, {\"rssi\": -61, \"mac\": \"a0:63:91:2b:9e:65\"}, {\"rssi\": -68, \"mac\": \"a0:63:91:2b:9e:64\"}, {\"rssi\": -70, \"mac\": \"70:73:cb:bd:9f:b5\"}, {\"rssi\": -75, \"mac\": \"d4:05:98:57:b3:10\"}, {\"rssi\": -75, \"mac\": \"00:23:69:d4:47:9f\"}, {\"rssi\": -76, \"mac\": \"30:46:9a:a0:28:c4\"}, {\"rssi\": -81, \"mac\": \"2c:b0:5d:36:e3:b8\"}, {\"rssi\": -82, \"mac\": \"00:1a:1e:46:cd:10\"}, {\"rssi\": -82, \"mac\": \"20:aa:4b:b8:31:c8\"}, {\"rssi\": -83, \"mac\": \"e8:ed:05:55:21:10\"}, {\"rssi\": -83, \"mac\": \"ec:1a:59:4a:9c:ed\"}, {\"rssi\": -88, \"mac\": \"b8:3e:59:78:35:99\"}, {\"rssi\": -84, \"mac\": \"e0:46:9a:6d:02:ea\"}, {\"rssi\": -84, \"mac\": \"00:1a:1e:46:cd:11\"}, {\"rssi\": -84, \"mac\": \"f8:35:dd:0a:da:be\"}, {\"rssi\": -84, \"mac\": \"b4:75:0e:03:cd:69\"}], \"location\": \"zakhome floor 2 office\", \"time\": 1439596533831, \"password\": \"frusciante_0128\"}`\n// \tres := Fingerprint{}\n// \tjson.Unmarshal([]byte(jsonTest), &res)\n// \tb.ResetTimer()\n// \tfor i := 0; i < b.N; i++ {\n// \t\tclassify(res)\n// \t}\n// }\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_rf.py",
          "type": "blob",
          "size": 0.791015625,
          "content": "import socket\nimport time\n\na = time.time()\nfor i in range(1):\n    # Connect to the server\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 5006))\n\n    # Send the data\n    message = 'r3=9u6ugjhl4x'\n    print ('Sending : \"%s\"' % message)\n    len_sent = s.send(message.encode('utf-8'))\n\n    # Receive a response\n    response = s.recv(1024)\n    print ('Received: \"%s\"' % response)\n\n    # Clean up\n    s.close()\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 5006))\n\n    # Send the data\n    message = 'r3='\n    print ('Sending : \"%s\"' % message)\n    len_sent = s.send(message.encode('utf-8'))\n\n    # Receive a response\n    response = s.recv(1024)\n    print ('Received: \"%s\"' % response)\n\n    # Clean up\n    s.close()\nprint(time.time()-a)\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 7.271484375,
          "content": "// Copyright 2015-2016 Zack Scholl. All rights reserved.\n// Use of this source code is governed by a AGPL\n// license that can be found in the LICENSE file.\n\n// utils.go is a collection of generic functions that are not specific to FIND.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"log\"\n)\n\nvar (\n\t// Trace is a logging handler\n\tTrace *log.Logger\n\t// Info is a logging handler\n\tInfo *log.Logger\n\t// Warning is a logging handler\n\tWarning *log.Logger\n\t// Debug is a logging handler\n\tDebug *log.Logger\n\t// Error is a logging handler\n\tError *log.Logger\n)\n\n// Init function for generating the logging handlers\nfunc Init(\n\ttraceHandle io.Writer,\n\tinfoHandle io.Writer,\n\tdebugHandle io.Writer,\n\twarningHandle io.Writer,\n\terrorHandle io.Writer) {\n\n\tTrace = log.New(traceHandle,\n\t\t\"TRACE : \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n\n\tInfo = log.New(infoHandle,\n\t\t\"INFO : \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n\n\tDebug = log.New(debugHandle,\n\t\t\"DEBUG: \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n\n\tWarning = log.New(warningHandle,\n\t\t\"WARN : \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n\n\tError = log.New(errorHandle,\n\t\t\"ERR  : \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n}\n\nfunc init() {\n\tInit(ioutil.Discard, os.Stdout, os.Stdout, os.Stdout, os.Stderr)\n\n\t// Trace.Println(\"I have something standard to say\")\n\t// Info.Println(\"Special Information\")\n\t// Warning.Println(\"There is something you need to know about\")\n\t// Error.Println(\"Something has failed\")\n}\n\n// GetLocalIP returns the local ip address\nfunc GetLocalIP() string {\n\taddrs, err := net.InterfaceAddrs()\n\tif err != nil {\n\t\treturn \"localhost\"\n\t}\n\tbestIP := \"localhost\"\n\tfor _, address := range addrs {\n\t\t// check the address type and if it is not a loopback the display it\n\t\tif ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {\n\t\t\tif ipnet.IP.To4() != nil && (strings.Contains(ipnet.IP.String(), \"192.168.1\") || strings.Contains(ipnet.IP.String(), \"192.168\")) {\n\t\t\t\treturn ipnet.IP.String()\n\t\t\t}\n\t\t}\n\t}\n\treturn bestIP\n}\n\n// stringInSlice returns boolean of whether a string is in a slice.\nfunc stringInSlice(s string, strings []string) bool {\n\tfor _, k := range strings {\n\t\tif s == k {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// timeTrack can be defered to provide function timing.\nfunc timeTrack(start time.Time, name string) {\n\telapsed := time.Since(start)\n\tDebug.Println(name, \" took \", elapsed)\n}\n\n// getMD5Hash returns a md5 hash of string.\nfunc getMD5Hash(text string) string {\n\thasher := md5.New()\n\thasher.Write([]byte(text))\n\treturn hex.EncodeToString(hasher.Sum(nil))\n}\n\n// average64 computes the average of a float64 slice.\nfunc average64(vals []float64) float64 {\n\tsum := float64(0)\n\tfor _, val := range vals {\n\t\tsum += float64(val)\n\t}\n\treturn sum / float64(len(vals))\n}\n\n// standardDeviation64 computes the standard deviation of a float64 slice.\nfunc standardDeviation64(vals []float64) float64 {\n\tmeanVal := average64(vals)\n\n\tsum := float64(0)\n\tfor _, val := range vals {\n\t\tsum += math.Pow(float64(val)-meanVal, 2)\n\t}\n\tsum = sum / (float64(len(vals)) - 1)\n\tsd := math.Sqrt(sum)\n\n\treturn float64(sd)\n}\n\n// standardDeviation comptues the standard deviation of a float32 slice.\nfunc standardDeviation(vals []float32) float32 {\n\tsum := float64(0)\n\tfor _, val := range vals {\n\t\tsum += float64(val)\n\t}\n\tmeanVal := sum / float64(len(vals))\n\n\tsum = float64(0)\n\tfor _, val := range vals {\n\t\tsum += math.Pow(float64(val)-meanVal, 2)\n\t}\n\tsum = sum / (float64(len(vals)) - 1)\n\tsd := math.Sqrt(sum)\n\n\treturn float32(sd)\n}\n\n// compressByte returns a compressed byte slice.\nfunc compressByte(src []byte) []byte {\n\tcompressedData := new(bytes.Buffer)\n\tcompress(src, compressedData, 9)\n\treturn compressedData.Bytes()\n}\n\n// decompressByte returns a decompressed byte slice.\nfunc decompressByte(src []byte) []byte {\n\tcompressedData := bytes.NewBuffer(src)\n\tdeCompressedData := new(bytes.Buffer)\n\tdecompress(compressedData, deCompressedData)\n\treturn deCompressedData.Bytes()\n}\n\n// compress uses flate to compress a byte slice to a corresponding level\nfunc compress(src []byte, dest io.Writer, level int) {\n\tcompressor, _ := flate.NewWriter(dest, level)\n\tcompressor.Write(src)\n\tcompressor.Close()\n}\n\n// compress uses flate to decompress an io.Reader\nfunc decompress(src io.Reader, dest io.Writer) {\n\tdecompressor := flate.NewReader(src)\n\tio.Copy(dest, decompressor)\n\tdecompressor.Close()\n}\n\n// src is seeds the random generator for generating random strings\nvar src = rand.NewSource(time.Now().UnixNano())\n\nconst letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nconst (\n\tletterIdxBits = 6                    // 6 bits to represent a letter index\n\tletterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits\n\tletterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits\n)\n\n// RandStringBytesMaskImprSrc prints a random string\nfunc RandStringBytesMaskImprSrc(n int) string {\n\tb := make([]byte, n)\n\t// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!\n\tfor i, cache, remain := n-1, src.Int63(), letterIdxMax; i >= 0; {\n\t\tif remain == 0 {\n\t\t\tcache, remain = src.Int63(), letterIdxMax\n\t\t}\n\t\tif idx := int(cache & letterIdxMask); idx < len(letterBytes) {\n\t\t\tb[i] = letterBytes[idx]\n\t\t\ti--\n\t\t}\n\t\tcache >>= letterIdxBits\n\t\tremain--\n\t}\n\n\treturn string(b)\n}\n\n// exists returns whether the given file or directory exists or not\n// from http://stackoverflow.com/questions/10510691/how-to-check-whether-a-file-or-directory-denoted-by-a-path-exists-in-golang\nfunc exists(path string) bool {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// CopyFile copies a file from src to dst. If src and dst files exist, and are\n// the same, then return success. Otherise, attempt to create a hard link\n// between the two files. If that fail, copy the file contents from src to dst.\n// from http://stackoverflow.com/questions/21060945/simple-way-to-copy-a-file-in-golang\nfunc CopyFile(src, dst string) (err error) {\n\tsfi, err := os.Stat(src)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !sfi.Mode().IsRegular() {\n\t\t// cannot copy non-regular files (e.g., directories,\n\t\t// symlinks, devices, etc.)\n\t\treturn fmt.Errorf(\"CopyFile: non-regular source file %s (%q)\", sfi.Name(), sfi.Mode().String())\n\t}\n\tdfi, err := os.Stat(dst)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tif !(dfi.Mode().IsRegular()) {\n\t\t\treturn fmt.Errorf(\"CopyFile: non-regular destination file %s (%q)\", dfi.Name(), dfi.Mode().String())\n\t\t}\n\t\tif os.SameFile(sfi, dfi) {\n\t\t\treturn\n\t\t}\n\t}\n\tif err = os.Link(src, dst); err == nil {\n\t\treturn\n\t}\n\terr = copyFileContents(src, dst)\n\treturn\n}\n\n// copyFileContents copies the contents of the file named src to the file named\n// by dst. The file will be created if it does not already exist. If the\n// destination file exists, all it's contents will be replaced by the contents\n// of the source file.\n// from http://stackoverflow.com/questions/21060945/simple-way-to-copy-a-file-in-golang\nfunc copyFileContents(src, dst string) (err error) {\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer in.Close()\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tcerr := out.Close()\n\t\tif err == nil {\n\t\t\terr = cerr\n\t\t}\n\t}()\n\tif _, err = io.Copy(out, in); err != nil {\n\t\treturn\n\t}\n\terr = out.Sync()\n\treturn\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}