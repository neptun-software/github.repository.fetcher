{
  "metadata": {
    "timestamp": 1736567696209,
    "page": 278,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spf13/afero",
      "stars": 6034,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.169921875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_size = 4\nindent_style = space\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.go]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": "sftpfs/file1\nsftpfs/test/\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.3017578125,
          "content": "linters-settings:\n    gci:\n        sections:\n            - standard\n            - default\n            - prefix(github.com/spf13/afero)\n\nlinters:\n    disable-all: true\n    enable:\n        - gci\n        - gofmt\n        - gofumpt\n        - staticcheck\n\nissues:\n    exclude-dirs:\n        - gcsfs/internal/stiface\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 9.90234375,
          "content": "                                Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.0517578125,
          "content": "![afero logo-sm](https://cloud.githubusercontent.com/assets/173412/11490338/d50e16dc-97a5-11e5-8b12-019a300d0fcb.png)\n\nA FileSystem Abstraction System for Go\n\n[![Test](https://github.com/spf13/afero/actions/workflows/test.yml/badge.svg)](https://github.com/spf13/afero/actions/workflows/test.yml) [![GoDoc](https://godoc.org/github.com/spf13/afero?status.svg)](https://godoc.org/github.com/spf13/afero) [![Join the chat at https://gitter.im/spf13/afero](https://badges.gitter.im/Dev%20Chat.svg)](https://gitter.im/spf13/afero?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n# Overview\n\nAfero is a filesystem framework providing a simple, uniform and universal API\ninteracting with any filesystem, as an abstraction layer providing interfaces,\ntypes and methods. Afero has an exceptionally clean interface and simple design\nwithout needless constructors or initialization methods.\n\nAfero is also a library providing a base set of interoperable backend\nfilesystems that make it easy to work with, while retaining all the power\nand benefit of the os and ioutil packages.\n\nAfero provides significant improvements over using the os package alone, most\nnotably the ability to create mock and testing filesystems without relying on the disk.\n\nIt is suitable for use in any situation where you would consider using the OS\npackage as it provides an additional abstraction that makes it easy to use a\nmemory backed file system during testing. It also adds support for the http\nfilesystem for full interoperability.\n\n\n## Afero Features\n\n* A single consistent API for accessing a variety of filesystems\n* Interoperation between a variety of file system types\n* A set of interfaces to encourage and enforce interoperability between backends\n* An atomic cross platform memory backed file system\n* Support for compositional (union) file systems by combining multiple file systems acting as one\n* Specialized backends which modify existing filesystems (Read Only, Regexp filtered)\n* A set of utility functions ported from io, ioutil & hugo to be afero aware\n* Wrapper for go 1.16 filesystem abstraction `io/fs.FS`\n\n# Using Afero\n\nAfero is easy to use and easier to adopt.\n\nA few different ways you could use Afero:\n\n* Use the interfaces alone to define your own file system.\n* Wrapper for the OS packages.\n* Define different filesystems for different parts of your application.\n* Use Afero for mock filesystems while testing\n\n## Step 1: Install Afero\n\nFirst use go get to install the latest version of the library.\n\n    $ go get github.com/spf13/afero\n\nNext include Afero in your application.\n```go\nimport \"github.com/spf13/afero\"\n```\n\n## Step 2: Declare a backend\n\nFirst define a package variable and set it to a pointer to a filesystem.\n```go\nvar AppFs = afero.NewMemMapFs()\n\nor\n\nvar AppFs = afero.NewOsFs()\n```\nIt is important to note that if you repeat the composite literal you\nwill be using a completely new and isolated filesystem. In the case of\nOsFs it will still use the same underlying filesystem but will reduce\nthe ability to drop in other filesystems as desired.\n\n## Step 3: Use it like you would the OS package\n\nThroughout your application use any function and method like you normally\nwould.\n\nSo if my application before had:\n```go\nos.Open(\"/tmp/foo\")\n```\nWe would replace it with:\n```go\nAppFs.Open(\"/tmp/foo\")\n```\n\n`AppFs` being the variable we defined above.\n\n\n## List of all available functions\n\nFile System Methods Available:\n```go\nChmod(name string, mode os.FileMode) : error\nChown(name string, uid, gid int) : error\nChtimes(name string, atime time.Time, mtime time.Time) : error\nCreate(name string) : File, error\nMkdir(name string, perm os.FileMode) : error\nMkdirAll(path string, perm os.FileMode) : error\nName() : string\nOpen(name string) : File, error\nOpenFile(name string, flag int, perm os.FileMode) : File, error\nRemove(name string) : error\nRemoveAll(path string) : error\nRename(oldname, newname string) : error\nStat(name string) : os.FileInfo, error\n```\nFile Interfaces and Methods Available:\n```go\nio.Closer\nio.Reader\nio.ReaderAt\nio.Seeker\nio.Writer\nio.WriterAt\n\nName() : string\nReaddir(count int) : []os.FileInfo, error\nReaddirnames(n int) : []string, error\nStat() : os.FileInfo, error\nSync() : error\nTruncate(size int64) : error\nWriteString(s string) : ret int, err error\n```\nIn some applications it may make sense to define a new package that\nsimply exports the file system variable for easy access from anywhere.\n\n## Using Afero's utility functions\n\nAfero provides a set of functions to make it easier to use the underlying file systems.\nThese functions have been primarily ported from io & ioutil with some developed for Hugo.\n\nThe afero utilities support all afero compatible backends.\n\nThe list of utilities includes:\n\n```go\nDirExists(path string) (bool, error)\nExists(path string) (bool, error)\nFileContainsBytes(filename string, subslice []byte) (bool, error)\nGetTempDir(subPath string) string\nIsDir(path string) (bool, error)\nIsEmpty(path string) (bool, error)\nReadDir(dirname string) ([]os.FileInfo, error)\nReadFile(filename string) ([]byte, error)\nSafeWriteReader(path string, r io.Reader) (err error)\nTempDir(dir, prefix string) (name string, err error)\nTempFile(dir, prefix string) (f File, err error)\nWalk(root string, walkFn filepath.WalkFunc) error\nWriteFile(filename string, data []byte, perm os.FileMode) error\nWriteReader(path string, r io.Reader) (err error)\n```\nFor a complete list see [Afero's GoDoc](https://godoc.org/github.com/spf13/afero)\n\nThey are available under two different approaches to use. You can either call\nthem directly where the first parameter of each function will be the file\nsystem, or you can declare a new `Afero`, a custom type used to bind these\nfunctions as methods to a given filesystem.\n\n### Calling utilities directly\n\n```go\nfs := new(afero.MemMapFs)\nf, err := afero.TempFile(fs,\"\", \"ioutil-test\")\n\n```\n\n### Calling via Afero\n\n```go\nfs := afero.NewMemMapFs()\nafs := &afero.Afero{Fs: fs}\nf, err := afs.TempFile(\"\", \"ioutil-test\")\n```\n\n## Using Afero for Testing\n\nThere is a large benefit to using a mock filesystem for testing. It has a\ncompletely blank state every time it is initialized and can be easily\nreproducible regardless of OS. You could create files to your heart’s content\nand the file access would be fast while also saving you from all the annoying\nissues with deleting temporary files, Windows file locking, etc. The MemMapFs\nbackend is perfect for testing.\n\n* Much faster than performing I/O operations on disk\n* Avoid security issues and permissions\n* Far more control. 'rm -rf /' with confidence\n* Test setup is far more easier to do\n* No test cleanup needed\n\nOne way to accomplish this is to define a variable as mentioned above.\nIn your application this will be set to afero.NewOsFs() during testing you\ncan set it to afero.NewMemMapFs().\n\nIt wouldn't be uncommon to have each test initialize a blank slate memory\nbackend. To do this I would define my `appFS = afero.NewOsFs()` somewhere\nappropriate in my application code. This approach ensures that Tests are order\nindependent, with no test relying on the state left by an earlier test.\n\nThen in my tests I would initialize a new MemMapFs for each test:\n```go\nfunc TestExist(t *testing.T) {\n\tappFS := afero.NewMemMapFs()\n\t// create test files and directories\n\tappFS.MkdirAll(\"src/a\", 0755)\n\tafero.WriteFile(appFS, \"src/a/b\", []byte(\"file b\"), 0644)\n\tafero.WriteFile(appFS, \"src/c\", []byte(\"file c\"), 0644)\n\tname := \"src/c\"\n\t_, err := appFS.Stat(name)\n\tif os.IsNotExist(err) {\n\t\tt.Errorf(\"file \\\"%s\\\" does not exist.\\n\", name)\n\t}\n}\n```\n\n# Available Backends\n\n## Operating System Native\n\n### OsFs\n\nThe first is simply a wrapper around the native OS calls. This makes it\nvery easy to use as all of the calls are the same as the existing OS\ncalls. It also makes it trivial to have your code use the OS during\noperation and a mock filesystem during testing or as needed.\n\n```go\nappfs := afero.NewOsFs()\nappfs.MkdirAll(\"src/a\", 0755)\n```\n\n## Memory Backed Storage\n\n### MemMapFs\n\nAfero also provides a fully atomic memory backed filesystem perfect for use in\nmocking and to speed up unnecessary disk io when persistence isn’t\nnecessary. It is fully concurrent and will work within go routines\nsafely.\n\n```go\nmm := afero.NewMemMapFs()\nmm.MkdirAll(\"src/a\", 0755)\n```\n\n#### InMemoryFile\n\nAs part of MemMapFs, Afero also provides an atomic, fully concurrent memory\nbacked file implementation. This can be used in other memory backed file\nsystems with ease. Plans are to add a radix tree memory stored file\nsystem using InMemoryFile.\n\n## Network Interfaces\n\n### SftpFs\n\nAfero has experimental support for secure file transfer protocol (sftp). Which can\nbe used to perform file operations over a encrypted channel.\n\n### GCSFs\n\nAfero has experimental support for Google Cloud Storage (GCS). You can either set the\n`GOOGLE_APPLICATION_CREDENTIALS_JSON` env variable to your JSON credentials or use `opts` in\n`NewGcsFS` to configure access to your GCS bucket.\n\nSome known limitations of the existing implementation:\n* No Chmod support - The GCS ACL could probably be mapped to *nix style permissions but that would add another level of complexity and is ignored in this version.\n* No Chtimes support - Could be simulated with attributes (gcs a/m-times are set implicitly) but that's is left for another version.\n* Not thread safe - Also assumes all file operations are done through the same instance of the GcsFs. File operations between different GcsFs instances are not guaranteed to be consistent.\n\n\n## Filtering Backends\n\n### BasePathFs\n\nThe BasePathFs restricts all operations to a given path within an Fs.\nThe given file name to the operations on this Fs will be prepended with\nthe base path before calling the source Fs.\n\n```go\nbp := afero.NewBasePathFs(afero.NewOsFs(), \"/base/path\")\n```\n\n### ReadOnlyFs\n\nA thin wrapper around the source Fs providing a read only view.\n\n```go\nfs := afero.NewReadOnlyFs(afero.NewOsFs())\n_, err := fs.Create(\"/file.txt\")\n// err = syscall.EPERM\n```\n\n# RegexpFs\n\nA filtered view on file names, any file NOT matching\nthe passed regexp will be treated as non-existing.\nFiles not matching the regexp provided will not be created.\nDirectories are not filtered.\n\n```go\nfs := afero.NewRegexpFs(afero.NewMemMapFs(), regexp.MustCompile(`\\.txt$`))\n_, err := fs.Create(\"/file.html\")\n// err = syscall.ENOENT\n```\n\n### HttpFs\n\nAfero provides an http compatible backend which can wrap any of the existing\nbackends.\n\nThe Http package requires a slightly specific version of Open which\nreturns an http.File type.\n\nAfero provides an httpFs file system which satisfies this requirement.\nAny Afero FileSystem can be used as an httpFs.\n\n```go\nhttpFs := afero.NewHttpFs(<ExistingFS>)\nfileserver := http.FileServer(httpFs.Dir(<PATH>))\nhttp.Handle(\"/\", fileserver)\n```\n\n## Composite Backends\n\nAfero provides the ability have two filesystems (or more) act as a single\nfile system.\n\n### CacheOnReadFs\n\nThe CacheOnReadFs will lazily make copies of any accessed files from the base\nlayer into the overlay. Subsequent reads will be pulled from the overlay\ndirectly permitting the request is within the cache duration of when it was\ncreated in the overlay.\n\nIf the base filesystem is writeable, any changes to files will be\ndone first to the base, then to the overlay layer. Write calls to open file\nhandles like `Write()` or `Truncate()` to the overlay first.\n\nTo writing files to the overlay only, you can use the overlay Fs directly (not\nvia the union Fs).\n\nCache files in the layer for the given time.Duration, a cache duration of 0\nmeans \"forever\" meaning the file will not be re-requested from the base ever.\n\nA read-only base will make the overlay also read-only but still copy files\nfrom the base to the overlay when they're not present (or outdated) in the\ncaching layer.\n\n```go\nbase := afero.NewOsFs()\nlayer := afero.NewMemMapFs()\nufs := afero.NewCacheOnReadFs(base, layer, 100 * time.Second)\n```\n\n### CopyOnWriteFs()\n\nThe CopyOnWriteFs is a read only base file system with a potentially\nwriteable layer on top.\n\nRead operations will first look in the overlay and if not found there, will\nserve the file from the base.\n\nChanges to the file system will only be made in the overlay.\n\nAny attempt to modify a file found only in the base will copy the file to the\noverlay layer before modification (including opening a file with a writable\nhandle).\n\nRemoving and Renaming files present only in the base layer is not currently\npermitted. If a file is present in the base layer and the overlay, only the\noverlay will be removed/renamed.\n\n```go\n\tbase := afero.NewOsFs()\n\troBase := afero.NewReadOnlyFs(base)\n\tufs := afero.NewCopyOnWriteFs(roBase, afero.NewMemMapFs())\n\n\tfh, _ = ufs.Create(\"/home/test/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n```\n\nIn this example all write operations will only occur in memory (MemMapFs)\nleaving the base filesystem (OsFs) untouched.\n\n\n## Desired/possible backends\n\nThe following is a short list of possible backends we hope someone will\nimplement:\n\n* SSH\n* S3\n\n# About the project\n\n## What's in the name\n\nAfero comes from the latin roots Ad-Facere.\n\n**\"Ad\"** is a prefix meaning \"to\".\n\n**\"Facere\"** is a form of the root \"faciō\" making \"make or do\".\n\nThe literal meaning of afero is \"to make\" or \"to do\" which seems very fitting\nfor a library that allows one to make files and directories and do things with them.\n\nThe English word that shares the same roots as Afero is \"affair\". Affair shares\nthe same concept but as a noun it means \"something that is made or done\" or \"an\nobject of a particular type\".\n\nIt's also nice that unlike some of my other libraries (hugo, cobra, viper) it\nGoogles very well.\n\n## Release Notes\n\nSee the [Releases Page](https://github.com/spf13/afero/releases).\n\n## Contributing\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\n## Contributors\n\nNames in no particular order:\n\n* [spf13](https://github.com/spf13)\n* [jaqx0r](https://github.com/jaqx0r)\n* [mbertschler](https://github.com/mbertschler)\n* [xor-gate](https://github.com/xor-gate)\n\n## License\n\nAfero is released under the Apache 2.0 license. See\n[LICENSE.txt](https://github.com/spf13/afero/blob/master/LICENSE.txt)\n"
        },
        {
          "name": "afero.go",
          "type": "blob",
          "size": 3.2763671875,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2013 tsuru authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package afero provides types and methods for interacting with the filesystem,\n// as an abstraction layer.\n\n// Afero also provides a few implementations that are mostly interoperable. One that\n// uses the operating system filesystem, one that uses memory to store files\n// (cross platform) and an interface that should be implemented if you want to\n// provide your own filesystem.\n\npackage afero\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Afero struct {\n\tFs\n}\n\n// File represents a file in the filesystem.\ntype File interface {\n\tio.Closer\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tio.Writer\n\tio.WriterAt\n\n\tName() string\n\tReaddir(count int) ([]os.FileInfo, error)\n\tReaddirnames(n int) ([]string, error)\n\tStat() (os.FileInfo, error)\n\tSync() error\n\tTruncate(size int64) error\n\tWriteString(s string) (ret int, err error)\n}\n\n// Fs is the filesystem interface.\n//\n// Any simulated or real filesystem should implement this interface.\ntype Fs interface {\n\t// Create creates a file in the filesystem, returning the file and an\n\t// error, if any happens.\n\tCreate(name string) (File, error)\n\n\t// Mkdir creates a directory in the filesystem, return an error if any\n\t// happens.\n\tMkdir(name string, perm os.FileMode) error\n\n\t// MkdirAll creates a directory path and all parents that does not exist\n\t// yet.\n\tMkdirAll(path string, perm os.FileMode) error\n\n\t// Open opens a file, returning it or an error, if any happens.\n\tOpen(name string) (File, error)\n\n\t// OpenFile opens a file using the given flags and the given mode.\n\tOpenFile(name string, flag int, perm os.FileMode) (File, error)\n\n\t// Remove removes a file identified by name, returning an error, if any\n\t// happens.\n\tRemove(name string) error\n\n\t// RemoveAll removes a directory path and any children it contains. It\n\t// does not fail if the path does not exist (return nil).\n\tRemoveAll(path string) error\n\n\t// Rename renames a file.\n\tRename(oldname, newname string) error\n\n\t// Stat returns a FileInfo describing the named file, or an error, if any\n\t// happens.\n\tStat(name string) (os.FileInfo, error)\n\n\t// The name of this FileSystem\n\tName() string\n\n\t// Chmod changes the mode of the named file to mode.\n\tChmod(name string, mode os.FileMode) error\n\n\t// Chown changes the uid and gid of the named file.\n\tChown(name string, uid, gid int) error\n\n\t// Chtimes changes the access and modification times of the named file\n\tChtimes(name string, atime time.Time, mtime time.Time) error\n}\n\nvar (\n\tErrFileClosed        = errors.New(\"File is closed\")\n\tErrOutOfRange        = errors.New(\"out of range\")\n\tErrTooLarge          = errors.New(\"too large\")\n\tErrFileNotFound      = os.ErrNotExist\n\tErrFileExists        = os.ErrExist\n\tErrDestinationExists = os.ErrExist\n)\n"
        },
        {
          "name": "afero_test.go",
          "type": "blob",
          "size": 16.20703125,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2009 The Go Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\tiofs \"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nvar (\n\ttestName = \"test.txt\"\n\tFss      = []Fs{&MemMapFs{}, &OsFs{}}\n)\n\nvar testRegistry map[Fs][]string = make(map[Fs][]string)\n\nfunc testDir(fs Fs) string {\n\tname, err := TempDir(fs, \"\", \"afero\")\n\tif err != nil {\n\t\tpanic(fmt.Sprint(\"unable to work with test dir\", err))\n\t}\n\ttestRegistry[fs] = append(testRegistry[fs], name)\n\n\treturn name\n}\n\nfunc tmpFile(fs Fs) File {\n\tx, err := TempFile(fs, \"\", \"afero\")\n\tif err != nil {\n\t\tpanic(fmt.Sprint(\"unable to work with temp file\", err))\n\t}\n\n\ttestRegistry[fs] = append(testRegistry[fs], x.Name())\n\n\treturn x\n}\n\n// Read with length 0 should not return EOF.\nfunc TestRead0(t *testing.T) {\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\t\tf.WriteString(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n\n\t\tvar b []byte\n\t\t// b := make([]byte, 0)\n\t\tn, err := f.Read(b)\n\t\tif n != 0 || err != nil {\n\t\t\tt.Errorf(\"%v: Read(0) = %d, %v, want 0, nil\", fs.Name(), n, err)\n\t\t}\n\t\tf.Seek(0, 0)\n\t\tb = make([]byte, 100)\n\t\tn, err = f.Read(b)\n\t\tif n <= 0 || err != nil {\n\t\t\tt.Errorf(\"%v: Read(100) = %d, %v, want >0, nil\", fs.Name(), n, err)\n\t\t}\n\t}\n}\n\nfunc TestOpenFile(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttmp := testDir(fs)\n\t\tpath := filepath.Join(tmp, testName)\n\n\t\tf, err := fs.OpenFile(path, os.O_RDWR|os.O_CREATE, 0o600)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"OpenFile (O_CREATE) failed:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tio.WriteString(f, \"initial\")\n\t\tf.Close()\n\n\t\tf, err = fs.OpenFile(path, os.O_WRONLY|os.O_APPEND, 0o600)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"OpenFile (O_APPEND) failed:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tio.WriteString(f, \"|append\")\n\t\tf.Close()\n\n\t\tf, _ = fs.OpenFile(path, os.O_RDONLY, 0o600)\n\t\tcontents, _ := io.ReadAll(f)\n\t\texpectedContents := \"initial|append\"\n\t\tif string(contents) != expectedContents {\n\t\t\tt.Errorf(\"%v: appending, expected '%v', got: '%v'\", fs.Name(), expectedContents, string(contents))\n\t\t}\n\t\tf.Close()\n\n\t\tf, err = fs.OpenFile(path, os.O_RDWR|os.O_TRUNC, 0o600)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"OpenFile (O_TRUNC) failed:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tcontents, _ = io.ReadAll(f)\n\t\tif string(contents) != \"\" {\n\t\t\tt.Errorf(\"%v: expected truncated file, got: '%v'\", fs.Name(), string(contents))\n\t\t}\n\t\tf.Close()\n\t}\n}\n\nfunc TestCreate(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttmp := testDir(fs)\n\t\tpath := filepath.Join(tmp, testName)\n\n\t\tf, err := fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"Create failed:\", err)\n\t\t\tf.Close()\n\t\t\tcontinue\n\t\t}\n\t\tio.WriteString(f, \"initial\")\n\t\tf.Close()\n\n\t\tf, err = fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"Create failed:\", err)\n\t\t\tf.Close()\n\t\t\tcontinue\n\t\t}\n\t\tsecondContent := \"second create\"\n\t\tio.WriteString(f, secondContent)\n\t\tf.Close()\n\n\t\tf, err = fs.Open(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"Open failed:\", err)\n\t\t\tf.Close()\n\t\t\tcontinue\n\t\t}\n\t\tbuf, err := ReadAll(f)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name(), \"ReadAll failed:\", err)\n\t\t\tf.Close()\n\t\t\tcontinue\n\t\t}\n\t\tif string(buf) != secondContent {\n\t\t\tt.Error(fs.Name(), \"Content should be\", \"\\\"\"+secondContent+\"\\\" but is \\\"\"+string(buf)+\"\\\"\")\n\t\t\tf.Close()\n\t\t\tcontinue\n\t\t}\n\t\tf.Close()\n\t}\n}\n\nfunc TestMemFileRead(t *testing.T) {\n\tf := tmpFile(new(MemMapFs))\n\t// f := MemFileCreate(\"testfile\")\n\tf.WriteString(\"abcd\")\n\tf.Seek(0, 0)\n\tb := make([]byte, 8)\n\tn, err := f.Read(b)\n\tif n != 4 {\n\t\tt.Errorf(\"didn't read all bytes: %v %v %v\", n, err, b)\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"err is not nil: %v %v %v\", n, err, b)\n\t}\n\tn, err = f.Read(b)\n\tif n != 0 {\n\t\tt.Errorf(\"read more bytes: %v %v %v\", n, err, b)\n\t}\n\tif err != io.EOF {\n\t\tt.Errorf(\"error is not EOF: %v %v %v\", n, err, b)\n\t}\n}\n\nfunc TestRename(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttDir := testDir(fs)\n\t\tfrom := filepath.Join(tDir, \"/renamefrom\")\n\t\tto := filepath.Join(tDir, \"/renameto\")\n\t\texists := filepath.Join(tDir, \"/renameexists\")\n\t\tfile, err := fs.Create(from)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: open %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\tif err = file.Close(); err != nil {\n\t\t\tt.Errorf(\"%s: close %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\tfile, err = fs.Create(exists)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: open %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\tif err = file.Close(); err != nil {\n\t\t\tt.Errorf(\"%s: close %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\terr = fs.Rename(from, to)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: rename %q, %q failed: %v\", fs.Name(), to, from, err)\n\t\t}\n\t\tfile, err = fs.Create(from)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: open %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\tif err = file.Close(); err != nil {\n\t\t\tt.Errorf(\"%s: close %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t\terr = fs.Rename(from, exists)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: rename %q, %q failed: %v\", fs.Name(), exists, from, err)\n\t\t}\n\t\tnames, err := readDirNames(fs, tDir)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: readDirNames error: %v\", fs.Name(), err)\n\t\t}\n\t\tfound := false\n\t\tfor _, e := range names {\n\t\t\tif e == \"renamefrom\" {\n\t\t\t\tt.Error(\"File is still called renamefrom\")\n\t\t\t}\n\t\t\tif e == \"renameto\" {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Error(\"File was not renamed to renameto\")\n\t\t}\n\n\t\t_, err = fs.Stat(to)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: stat %q failed: %v\", fs.Name(), to, err)\n\t\t}\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\tfor _, fs := range Fss {\n\n\t\tx, err := TempFile(fs, \"\", \"afero\")\n\t\tif err != nil {\n\t\t\tt.Error(fmt.Sprint(\"unable to work with temp file\", err))\n\t\t}\n\n\t\tpath := x.Name()\n\t\tx.Close()\n\n\t\ttDir := filepath.Dir(path)\n\n\t\terr = fs.Remove(path)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%v: Remove() failed: %v\", fs.Name(), err)\n\t\t\tcontinue\n\t\t}\n\n\t\t_, err = fs.Stat(path)\n\t\tif !os.IsNotExist(err) {\n\t\t\tt.Errorf(\"%v: Remove() didn't remove file\", fs.Name())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Deleting non-existent file should raise error\n\t\terr = fs.Remove(path)\n\t\tif !os.IsNotExist(err) {\n\t\t\tt.Errorf(\"%v: Remove() didn't raise error for non-existent file\", fs.Name())\n\t\t}\n\n\t\tf, err := fs.Open(tDir)\n\t\tif err != nil {\n\t\t\tt.Error(\"TestDir should still exist:\", err)\n\t\t}\n\n\t\tnames, err := f.Readdirnames(-1)\n\t\tif err != nil {\n\t\t\tt.Error(\"Readdirnames failed:\", err)\n\t\t}\n\n\t\tfor _, e := range names {\n\t\t\tif e == testName {\n\t\t\t\tt.Error(\"File was not removed from parent directory\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTruncate(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\n\t\tcheckSize(t, f, 0)\n\t\tf.Write([]byte(\"hello, world\\n\"))\n\t\tcheckSize(t, f, 13)\n\t\tf.Truncate(10)\n\t\tcheckSize(t, f, 10)\n\t\tf.Truncate(1024)\n\t\tcheckSize(t, f, 1024)\n\t\tf.Truncate(0)\n\t\tcheckSize(t, f, 0)\n\t\t_, err := f.Write([]byte(\"surprise!\"))\n\t\tif err == nil {\n\t\t\tcheckSize(t, f, 13+9) // wrote at offset past where hello, world was.\n\t\t}\n\t}\n}\n\nfunc TestSeek(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\n\t\tconst data = \"hello, world\\n\"\n\t\tio.WriteString(f, data)\n\n\t\ttype test struct {\n\t\t\tin     int64\n\t\t\twhence int\n\t\t\tout    int64\n\t\t}\n\t\ttests := []test{\n\t\t\t{0, 1, int64(len(data))},\n\t\t\t{0, 0, 0},\n\t\t\t{5, 0, 5},\n\t\t\t{0, 2, int64(len(data))},\n\t\t\t{0, 0, 0},\n\t\t\t{-1, 2, int64(len(data)) - 1},\n\t\t\t{1 << 33, 0, 1 << 33},\n\t\t\t{1 << 33, 2, 1<<33 + int64(len(data))},\n\t\t}\n\t\tfor i, tt := range tests {\n\t\t\toff, err := f.Seek(tt.in, tt.whence)\n\t\t\tif off != tt.out || err != nil {\n\t\t\t\tif e, ok := err.(*os.PathError); ok && e.Err == syscall.EINVAL && tt.out > 1<<32 {\n\t\t\t\t\t// Reiserfs rejects the big seeks.\n\t\t\t\t\t// http://code.google.com/p/go/issues/detail?id=91\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"#%d: Seek(%v, %v) = %v, %v want %v, nil\", i, tt.in, tt.whence, off, err, tt.out)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadAt(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\n\t\tconst data = \"hello, world\\n\"\n\t\tio.WriteString(f, data)\n\n\t\tb := make([]byte, 5)\n\t\tn, err := f.ReadAt(b, 7)\n\t\tif err != nil || n != len(b) {\n\t\t\tt.Fatalf(\"ReadAt 7: %d, %v\", n, err)\n\t\t}\n\t\tif string(b) != \"world\" {\n\t\t\tt.Fatalf(\"ReadAt 7: have %q want %q\", string(b), \"world\")\n\t\t}\n\t}\n}\n\nfunc TestWriteAt(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\n\t\tconst data = \"hello, world\\n\"\n\t\tio.WriteString(f, data)\n\n\t\tn, err := f.WriteAt([]byte(\"WORLD\"), 7)\n\t\tif err != nil || n != 5 {\n\t\t\tt.Fatalf(\"WriteAt 7: %d, %v\", n, err)\n\t\t}\n\n\t\tf2, err := fs.Open(f.Name())\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%v: ReadFile %s: %v\", fs.Name(), f.Name(), err)\n\t\t}\n\t\tdefer f2.Close()\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(f2)\n\t\tb := buf.Bytes()\n\t\tif string(b) != \"hello, WORLD\\n\" {\n\t\t\tt.Fatalf(\"after write: have %q want %q\", string(b), \"hello, WORLD\\n\")\n\t\t}\n\n\t}\n}\n\nfunc setupTestDir(t *testing.T, fs Fs) string {\n\tpath := testDir(fs)\n\treturn setupTestFiles(t, fs, path)\n}\n\nfunc setupTestDirRoot(t *testing.T, fs Fs) string {\n\tpath := testDir(fs)\n\tsetupTestFiles(t, fs, path)\n\treturn path\n}\n\nfunc setupTestDirReusePath(t *testing.T, fs Fs, path string) string {\n\ttestRegistry[fs] = append(testRegistry[fs], path)\n\treturn setupTestFiles(t, fs, path)\n}\n\nfunc setupTestFiles(t *testing.T, fs Fs, path string) string {\n\ttestSubDir := filepath.Join(path, \"more\", \"subdirectories\", \"for\", \"testing\", \"we\")\n\terr := fs.MkdirAll(testSubDir, 0o700)\n\tif err != nil && !os.IsExist(err) {\n\t\tt.Fatal(err)\n\t}\n\n\tf, err := fs.Create(filepath.Join(testSubDir, \"testfile1\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 1 content\")\n\tf.Close()\n\n\tf, err = fs.Create(filepath.Join(testSubDir, \"testfile2\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 2 content\")\n\tf.Close()\n\n\tf, err = fs.Create(filepath.Join(testSubDir, \"testfile3\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 3 content\")\n\tf.Close()\n\n\tf, err = fs.Create(filepath.Join(testSubDir, \"testfile4\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 4 content\")\n\tf.Close()\n\treturn testSubDir\n}\n\nfunc TestReaddirnames(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttestSubDir := setupTestDir(t, fs)\n\t\ttDir := filepath.Dir(testSubDir)\n\n\t\troot, err := fs.Open(tDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(fs.Name(), tDir, err)\n\t\t}\n\t\tdefer root.Close()\n\n\t\tnamesRoot, err := root.Readdirnames(-1)\n\t\tif err != nil {\n\t\t\tt.Fatal(fs.Name(), namesRoot, err)\n\t\t}\n\n\t\tsub, err := fs.Open(testSubDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer sub.Close()\n\n\t\tnamesSub, err := sub.Readdirnames(-1)\n\t\tif err != nil {\n\t\t\tt.Fatal(fs.Name(), namesSub, err)\n\t\t}\n\n\t\tfindNames(fs, t, tDir, testSubDir, namesRoot, namesSub)\n\t}\n}\n\nfunc TestReaddirSimple(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttestSubDir := setupTestDir(t, fs)\n\t\ttDir := filepath.Dir(testSubDir)\n\n\t\troot, err := fs.Open(tDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer root.Close()\n\n\t\trootInfo, err := root.Readdir(1)\n\t\tif err != nil {\n\t\t\tt.Log(myFileInfo(rootInfo))\n\t\t\tt.Error(err)\n\t\t}\n\n\t\trootInfo, err = root.Readdir(5)\n\t\tif err != io.EOF {\n\t\t\tt.Log(myFileInfo(rootInfo))\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tsub, err := fs.Open(testSubDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer sub.Close()\n\n\t\tsubInfo, err := sub.Readdir(5)\n\t\tif err != nil {\n\t\t\tt.Log(myFileInfo(subInfo))\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestReaddir(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tconst nums = 6\n\tfor num := 0; num < nums; num++ {\n\t\toutputs := make([]string, len(Fss))\n\t\tinfos := make([]string, len(Fss))\n\t\tfor i, fs := range Fss {\n\t\t\ttestSubDir := setupTestDir(t, fs)\n\t\t\troot, err := fs.Open(testSubDir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tinfosn := make([]string, nums)\n\n\t\t\tfor j := 0; j < nums; j++ {\n\t\t\t\tinfo, err := root.Readdir(num)\n\t\t\t\toutputs[i] += fmt.Sprintf(\"%v  Error: %v\\n\", myFileInfo(info), err)\n\t\t\t\ts := fmt.Sprintln(len(info), err)\n\t\t\t\tinfosn[j] = s\n\t\t\t\tinfos[i] += s\n\t\t\t}\n\t\t\troot.Close()\n\n\t\t\t// Also check fs.ReadDirFile interface if implemented\n\t\t\tif _, ok := root.(iofs.ReadDirFile); ok {\n\t\t\t\troot, err = fs.Open(testSubDir)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tdefer root.Close()\n\n\t\t\t\tfor j := 0; j < nums; j++ {\n\t\t\t\t\tdirEntries, err := root.(iofs.ReadDirFile).ReadDir(num)\n\t\t\t\t\ts := fmt.Sprintln(len(dirEntries), err)\n\t\t\t\t\tif s != infosn[j] {\n\t\t\t\t\t\tt.Fatalf(\"%s: %s != %s\", fs.Name(), s, infosn[j])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfail := false\n\t\tfor i, o := range infos {\n\t\t\tif i == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif o != infos[i-1] {\n\t\t\t\tfail = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif fail {\n\t\t\tt.Log(\"Readdir outputs not equal for Readdir(\", num, \")\")\n\t\t\tfor i, o := range outputs {\n\t\t\t\tt.Log(Fss[i].Name())\n\t\t\t\tt.Log(o)\n\t\t\t}\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\n// https://github.com/spf13/afero/issues/169\nfunc TestReaddirRegularFile(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\tf := tmpFile(fs)\n\t\tdefer f.Close()\n\n\t\t_, err := f.Readdirnames(-1)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error\")\n\t\t}\n\n\t\t_, err = f.Readdir(-1)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error\")\n\t\t}\n\t}\n}\n\ntype myFileInfo []os.FileInfo\n\nfunc (m myFileInfo) String() string {\n\tout := \"Fileinfos:\\n\"\n\tfor _, e := range m {\n\t\tout += \"  \" + e.Name() + \"\\n\"\n\t}\n\treturn out\n}\n\nfunc TestReaddirAll(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tfor _, fs := range Fss {\n\t\ttestSubDir := setupTestDir(t, fs)\n\t\ttDir := filepath.Dir(testSubDir)\n\n\t\troot, err := fs.Open(tDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer root.Close()\n\n\t\trootInfo, err := root.Readdir(-1)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tnamesRoot := []string{}\n\t\tfor _, e := range rootInfo {\n\t\t\tnamesRoot = append(namesRoot, e.Name())\n\t\t}\n\n\t\tsub, err := fs.Open(testSubDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer sub.Close()\n\n\t\tsubInfo, err := sub.Readdir(-1)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tnamesSub := []string{}\n\t\tfor _, e := range subInfo {\n\t\t\tnamesSub = append(namesSub, e.Name())\n\t\t}\n\n\t\tfindNames(fs, t, tDir, testSubDir, namesRoot, namesSub)\n\t}\n}\n\nfunc findNames(fs Fs, t *testing.T, tDir, testSubDir string, root, sub []string) {\n\tvar foundRoot bool\n\tfor _, e := range root {\n\t\tf, err := fs.Open(filepath.Join(tDir, e))\n\t\tif err != nil {\n\t\t\tt.Error(\"Open\", filepath.Join(tDir, e), \":\", err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tif equal(e, \"we\") {\n\t\t\tfoundRoot = true\n\t\t}\n\t}\n\tif !foundRoot {\n\t\tt.Logf(\"Names root: %v\", root)\n\t\tt.Logf(\"Names sub: %v\", sub)\n\t\tt.Error(\"Didn't find subdirectory we\")\n\t}\n\n\tvar found1, found2 bool\n\tfor _, e := range sub {\n\t\tf, err := fs.Open(filepath.Join(testSubDir, e))\n\t\tif err != nil {\n\t\t\tt.Error(\"Open\", filepath.Join(testSubDir, e), \":\", err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tif equal(e, \"testfile1\") {\n\t\t\tfound1 = true\n\t\t}\n\t\tif equal(e, \"testfile2\") {\n\t\t\tfound2 = true\n\t\t}\n\t}\n\n\tif !found1 {\n\t\tt.Logf(\"Names root: %v\", root)\n\t\tt.Logf(\"Names sub: %v\", sub)\n\t\tt.Error(\"Didn't find testfile1\")\n\t}\n\tif !found2 {\n\t\tt.Logf(\"Names root: %v\", root)\n\t\tt.Logf(\"Names sub: %v\", sub)\n\t\tt.Error(\"Didn't find testfile2\")\n\t}\n}\n\nfunc removeAllTestFiles(t *testing.T) {\n\tfor fs, list := range testRegistry {\n\t\tfor _, path := range list {\n\t\t\tif err := fs.RemoveAll(path); err != nil {\n\t\t\t\tt.Error(fs.Name(), err)\n\t\t\t}\n\t\t}\n\t}\n\ttestRegistry = make(map[Fs][]string)\n}\n\nfunc equal(name1, name2 string) (r bool) {\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tr = strings.EqualFold(name1, name2)\n\tdefault:\n\t\tr = name1 == name2\n\t}\n\treturn\n}\n\nfunc checkSize(t *testing.T, f File, size int64) {\n\tdir, err := f.Stat()\n\tif err != nil {\n\t\tt.Fatalf(\"Stat %q (looking for size %d): %s\", f.Name(), size, err)\n\t}\n\tif dir.Size() != size {\n\t\tt.Errorf(\"Stat %q: size %d want %d\", f.Name(), dir.Size(), size)\n\t}\n}\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.26953125,
          "content": "# This currently does nothing. We have moved to GitHub action, but this is kept\n# until spf13 has disabled this project in AppVeyor.\nversion: '{build}'\nclone_folder: C:\\gopath\\src\\github.com\\spf13\\afero\nenvironment:\n  GOPATH: C:\\gopath\nbuild_script:\n- cmd: >-\n    go version\n\n"
        },
        {
          "name": "basepath.go",
          "type": "blob",
          "size": 6.126953125,
          "content": "package afero\n\nimport (\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\t_ Lstater        = (*BasePathFs)(nil)\n\t_ fs.ReadDirFile = (*BasePathFile)(nil)\n)\n\n// The BasePathFs restricts all operations to a given path within an Fs.\n// The given file name to the operations on this Fs will be prepended with\n// the base path before calling the base Fs.\n// Any file name (after filepath.Clean()) outside this base path will be\n// treated as non existing file.\n//\n// Note that it does not clean the error messages on return, so you may\n// reveal the real path on errors.\ntype BasePathFs struct {\n\tsource Fs\n\tpath   string\n}\n\ntype BasePathFile struct {\n\tFile\n\tpath string\n}\n\nfunc (f *BasePathFile) Name() string {\n\tsourcename := f.File.Name()\n\treturn strings.TrimPrefix(sourcename, filepath.Clean(f.path))\n}\n\nfunc (f *BasePathFile) ReadDir(n int) ([]fs.DirEntry, error) {\n\tif rdf, ok := f.File.(fs.ReadDirFile); ok {\n\t\treturn rdf.ReadDir(n)\n\t}\n\treturn readDirFile{f.File}.ReadDir(n)\n}\n\nfunc NewBasePathFs(source Fs, path string) Fs {\n\treturn &BasePathFs{source: source, path: path}\n}\n\n// on a file outside the base path it returns the given file name and an error,\n// else the given file with the base path prepended\nfunc (b *BasePathFs) RealPath(name string) (path string, err error) {\n\tif err := validateBasePathName(name); err != nil {\n\t\treturn name, err\n\t}\n\n\tbpath := filepath.Clean(b.path)\n\tpath = filepath.Clean(filepath.Join(bpath, name))\n\tif !strings.HasPrefix(path, bpath) {\n\t\treturn name, os.ErrNotExist\n\t}\n\n\treturn path, nil\n}\n\nfunc validateBasePathName(name string) error {\n\tif runtime.GOOS != \"windows\" {\n\t\t// Not much to do here;\n\t\t// the virtual file paths all look absolute on *nix.\n\t\treturn nil\n\t}\n\n\t// On Windows a common mistake would be to provide an absolute OS path\n\t// We could strip out the base part, but that would not be very portable.\n\tif filepath.IsAbs(name) {\n\t\treturn os.ErrNotExist\n\t}\n\n\treturn nil\n}\n\nfunc (b *BasePathFs) Chtimes(name string, atime, mtime time.Time) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"chtimes\", Path: name, Err: err}\n\t}\n\treturn b.source.Chtimes(name, atime, mtime)\n}\n\nfunc (b *BasePathFs) Chmod(name string, mode os.FileMode) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"chmod\", Path: name, Err: err}\n\t}\n\treturn b.source.Chmod(name, mode)\n}\n\nfunc (b *BasePathFs) Chown(name string, uid, gid int) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"chown\", Path: name, Err: err}\n\t}\n\treturn b.source.Chown(name, uid, gid)\n}\n\nfunc (b *BasePathFs) Name() string {\n\treturn \"BasePathFs\"\n}\n\nfunc (b *BasePathFs) Stat(name string) (fi os.FileInfo, err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn nil, &os.PathError{Op: \"stat\", Path: name, Err: err}\n\t}\n\treturn b.source.Stat(name)\n}\n\nfunc (b *BasePathFs) Rename(oldname, newname string) (err error) {\n\tif oldname, err = b.RealPath(oldname); err != nil {\n\t\treturn &os.PathError{Op: \"rename\", Path: oldname, Err: err}\n\t}\n\tif newname, err = b.RealPath(newname); err != nil {\n\t\treturn &os.PathError{Op: \"rename\", Path: newname, Err: err}\n\t}\n\treturn b.source.Rename(oldname, newname)\n}\n\nfunc (b *BasePathFs) RemoveAll(name string) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"remove_all\", Path: name, Err: err}\n\t}\n\treturn b.source.RemoveAll(name)\n}\n\nfunc (b *BasePathFs) Remove(name string) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"remove\", Path: name, Err: err}\n\t}\n\treturn b.source.Remove(name)\n}\n\nfunc (b *BasePathFs) OpenFile(name string, flag int, mode os.FileMode) (f File, err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn nil, &os.PathError{Op: \"openfile\", Path: name, Err: err}\n\t}\n\tsourcef, err := b.source.OpenFile(name, flag, mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BasePathFile{sourcef, b.path}, nil\n}\n\nfunc (b *BasePathFs) Open(name string) (f File, err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: err}\n\t}\n\tsourcef, err := b.source.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BasePathFile{File: sourcef, path: b.path}, nil\n}\n\nfunc (b *BasePathFs) Mkdir(name string, mode os.FileMode) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"mkdir\", Path: name, Err: err}\n\t}\n\treturn b.source.Mkdir(name, mode)\n}\n\nfunc (b *BasePathFs) MkdirAll(name string, mode os.FileMode) (err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn &os.PathError{Op: \"mkdir\", Path: name, Err: err}\n\t}\n\treturn b.source.MkdirAll(name, mode)\n}\n\nfunc (b *BasePathFs) Create(name string) (f File, err error) {\n\tif name, err = b.RealPath(name); err != nil {\n\t\treturn nil, &os.PathError{Op: \"create\", Path: name, Err: err}\n\t}\n\tsourcef, err := b.source.Create(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BasePathFile{File: sourcef, path: b.path}, nil\n}\n\nfunc (b *BasePathFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tname, err := b.RealPath(name)\n\tif err != nil {\n\t\treturn nil, false, &os.PathError{Op: \"lstat\", Path: name, Err: err}\n\t}\n\tif lstater, ok := b.source.(Lstater); ok {\n\t\treturn lstater.LstatIfPossible(name)\n\t}\n\tfi, err := b.source.Stat(name)\n\treturn fi, false, err\n}\n\nfunc (b *BasePathFs) SymlinkIfPossible(oldname, newname string) error {\n\toldname, err := b.RealPath(oldname)\n\tif err != nil {\n\t\treturn &os.LinkError{Op: \"symlink\", Old: oldname, New: newname, Err: err}\n\t}\n\tnewname, err = b.RealPath(newname)\n\tif err != nil {\n\t\treturn &os.LinkError{Op: \"symlink\", Old: oldname, New: newname, Err: err}\n\t}\n\tif linker, ok := b.source.(Linker); ok {\n\t\treturn linker.SymlinkIfPossible(oldname, newname)\n\t}\n\treturn &os.LinkError{Op: \"symlink\", Old: oldname, New: newname, Err: ErrNoSymlink}\n}\n\nfunc (b *BasePathFs) ReadlinkIfPossible(name string) (string, error) {\n\tname, err := b.RealPath(name)\n\tif err != nil {\n\t\treturn \"\", &os.PathError{Op: \"readlink\", Path: name, Err: err}\n\t}\n\tif reader, ok := b.source.(LinkReader); ok {\n\t\treturn reader.ReadlinkIfPossible(name)\n\t}\n\treturn \"\", &os.PathError{Op: \"readlink\", Path: name, Err: ErrNoReadlink}\n}\n"
        },
        {
          "name": "basepath_test.go",
          "type": "blob",
          "size": 4.6376953125,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc TestBasePath(t *testing.T) {\n\tbaseFs := &MemMapFs{}\n\tbaseFs.MkdirAll(\"/base/path/tmp\", 0o777)\n\tbp := NewBasePathFs(baseFs, \"/base/path\")\n\n\tif _, err := bp.Create(\"/tmp/foo\"); err != nil {\n\t\tt.Errorf(\"Failed to set real path\")\n\t}\n\n\tif fh, err := bp.Create(\"../tmp/bar\"); err == nil {\n\t\tt.Errorf(\"succeeded in creating %s ...\", fh.Name())\n\t}\n}\n\nfunc TestBasePathRoot(t *testing.T) {\n\tbaseFs := &MemMapFs{}\n\tbaseFs.MkdirAll(\"/base/path/foo/baz\", 0o777)\n\tbaseFs.MkdirAll(\"/base/path/boo/\", 0o777)\n\tbp := NewBasePathFs(baseFs, \"/base/path\")\n\n\trd, err := ReadDir(bp, string(os.PathSeparator))\n\n\tif len(rd) != 2 {\n\t\tt.Errorf(\"base path doesn't respect root\")\n\t}\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestRealPath(t *testing.T) {\n\tfs := NewOsFs()\n\tbaseDir, err := TempDir(fs, \"\", \"base\")\n\tif err != nil {\n\t\tt.Fatal(\"error creating tempDir\", err)\n\t}\n\tdefer fs.RemoveAll(baseDir)\n\tanotherDir, err := TempDir(fs, \"\", \"another\")\n\tif err != nil {\n\t\tt.Fatal(\"error creating tempDir\", err)\n\t}\n\tdefer fs.RemoveAll(anotherDir)\n\n\tbp := NewBasePathFs(fs, baseDir).(*BasePathFs)\n\n\tsubDir := filepath.Join(baseDir, \"s1\")\n\n\trealPath, err := bp.RealPath(\"/s1\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error %s\", err)\n\t}\n\n\tif realPath != subDir {\n\t\tt.Errorf(\"Expected \\n%s got \\n%s\", subDir, realPath)\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\t_, err = bp.RealPath(anotherDir)\n\n\t\tif err != os.ErrNotExist {\n\t\t\tt.Errorf(\"Expected os.ErrNotExist\")\n\t\t}\n\n\t} else {\n\t\t// on *nix we have no way of just looking at the path and tell that anotherDir\n\t\t// is not inside the base file system.\n\t\t// The user will receive an os.ErrNotExist later.\n\t\tsurrealPath, err := bp.RealPath(anotherDir)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Got error %s\", err)\n\t\t}\n\n\t\texcpected := filepath.Join(baseDir, anotherDir)\n\n\t\tif surrealPath != excpected {\n\t\t\tt.Errorf(\"Expected \\n%s got \\n%s\", excpected, surrealPath)\n\t\t}\n\t}\n}\n\nfunc TestNestedBasePaths(t *testing.T) {\n\ttype dirSpec struct {\n\t\tDir1, Dir2, Dir3 string\n\t}\n\tdirSpecs := []dirSpec{\n\t\t{Dir1: \"/\", Dir2: \"/\", Dir3: \"/\"},\n\t\t{Dir1: \"/\", Dir2: \"/path2\", Dir3: \"/\"},\n\t\t{Dir1: \"/path1/dir\", Dir2: \"/path2/dir/\", Dir3: \"/path3/dir\"},\n\t\t{Dir1: \"C:/path1\", Dir2: \"path2/dir\", Dir3: \"/path3/dir/\"},\n\t}\n\n\tfor _, ds := range dirSpecs {\n\t\tmemFs := NewMemMapFs()\n\t\tlevel1Fs := NewBasePathFs(memFs, ds.Dir1)\n\t\tlevel2Fs := NewBasePathFs(level1Fs, ds.Dir2)\n\t\tlevel3Fs := NewBasePathFs(level2Fs, ds.Dir3)\n\n\t\ttype spec struct {\n\t\t\tBaseFs   Fs\n\t\t\tFileName string\n\t\t}\n\t\tspecs := []spec{\n\t\t\t{BaseFs: level3Fs, FileName: \"f.txt\"},\n\t\t\t{BaseFs: level2Fs, FileName: \"f.txt\"},\n\t\t\t{BaseFs: level1Fs, FileName: \"f.txt\"},\n\t\t}\n\n\t\tfor _, s := range specs {\n\t\t\tif err := s.BaseFs.MkdirAll(s.FileName, 0o755); err != nil {\n\t\t\t\tt.Errorf(\"Got error %s\", err.Error())\n\t\t\t}\n\t\t\tif _, err := s.BaseFs.Stat(s.FileName); err != nil {\n\t\t\t\tt.Errorf(\"Got error %s\", err.Error())\n\t\t\t}\n\n\t\t\tif s.BaseFs == level3Fs {\n\t\t\t\tpathToExist := filepath.Join(ds.Dir3, s.FileName)\n\t\t\t\tif _, err := level2Fs.Stat(pathToExist); err != nil {\n\t\t\t\t\tt.Errorf(\"Got error %s (path %s)\", err.Error(), pathToExist)\n\t\t\t\t}\n\t\t\t} else if s.BaseFs == level2Fs {\n\t\t\t\tpathToExist := filepath.Join(ds.Dir2, ds.Dir3, s.FileName)\n\t\t\t\tif _, err := level1Fs.Stat(pathToExist); err != nil {\n\t\t\t\t\tt.Errorf(\"Got error %s (path %s)\", err.Error(), pathToExist)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBasePathOpenFile(t *testing.T) {\n\tbaseFs := &MemMapFs{}\n\tbaseFs.MkdirAll(\"/base/path/tmp\", 0o777)\n\tbp := NewBasePathFs(baseFs, \"/base/path\")\n\tf, err := bp.OpenFile(\"/tmp/file.txt\", os.O_CREATE, 0o600)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open file: %v\", err)\n\t}\n\tif filepath.Dir(f.Name()) != filepath.Clean(\"/tmp\") {\n\t\tt.Fatalf(\"realpath leaked: %s\", f.Name())\n\t}\n}\n\nfunc TestBasePathCreate(t *testing.T) {\n\tbaseFs := &MemMapFs{}\n\tbaseFs.MkdirAll(\"/base/path/tmp\", 0o777)\n\tbp := NewBasePathFs(baseFs, \"/base/path\")\n\tf, err := bp.Create(\"/tmp/file.txt\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create file: %v\", err)\n\t}\n\tif filepath.Dir(f.Name()) != filepath.Clean(\"/tmp\") {\n\t\tt.Fatalf(\"realpath leaked: %s\", f.Name())\n\t}\n}\n\nfunc TestBasePathTempFile(t *testing.T) {\n\tbaseFs := &MemMapFs{}\n\tbaseFs.MkdirAll(\"/base/path/tmp\", 0o777)\n\tbp := NewBasePathFs(baseFs, \"/base/path\")\n\n\ttDir, err := TempDir(bp, \"/tmp\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to TempDir: %v\", err)\n\t}\n\tif filepath.Dir(tDir) != filepath.Clean(\"/tmp\") {\n\t\tt.Fatalf(\"Tempdir realpath leaked: %s\", tDir)\n\t}\n\ttempFile, err := TempFile(bp, tDir, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to TempFile: %v\", err)\n\t}\n\tdefer tempFile.Close()\n\tif expected, actual := tDir, filepath.Dir(tempFile.Name()); expected != actual {\n\t\tt.Fatalf(\"TempFile realpath leaked: expected %s, got %s\", expected, actual)\n\t}\n}\n"
        },
        {
          "name": "cacheOnReadFs.go",
          "type": "blob",
          "size": 7.3193359375,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\n// If the cache duration is 0, cache time will be unlimited, i.e. once\n// a file is in the layer, the base will never be read again for this file.\n//\n// For cache times greater than 0, the modification time of a file is\n// checked. Note that a lot of file system implementations only allow a\n// resolution of a second for timestamps... or as the godoc for os.Chtimes()\n// states: \"The underlying filesystem may truncate or round the values to a\n// less precise time unit.\"\n//\n// This caching union will forward all write calls also to the base file\n// system first. To prevent writing to the base Fs, wrap it in a read-only\n// filter - Note: this will also make the overlay read-only, for writing files\n// in the overlay, use the overlay Fs directly, not via the union Fs.\ntype CacheOnReadFs struct {\n\tbase      Fs\n\tlayer     Fs\n\tcacheTime time.Duration\n}\n\nfunc NewCacheOnReadFs(base Fs, layer Fs, cacheTime time.Duration) Fs {\n\treturn &CacheOnReadFs{base: base, layer: layer, cacheTime: cacheTime}\n}\n\ntype cacheState int\n\nconst (\n\t// not present in the overlay, unknown if it exists in the base:\n\tcacheMiss cacheState = iota\n\t// present in the overlay and in base, base file is newer:\n\tcacheStale\n\t// present in the overlay - with cache time == 0 it may exist in the base,\n\t// with cacheTime > 0 it exists in the base and is same age or newer in the\n\t// overlay\n\tcacheHit\n\t// happens if someone writes directly to the overlay without\n\t// going through this union\n\tcacheLocal\n)\n\nfunc (u *CacheOnReadFs) cacheStatus(name string) (state cacheState, fi os.FileInfo, err error) {\n\tvar lfi, bfi os.FileInfo\n\tlfi, err = u.layer.Stat(name)\n\tif err == nil {\n\t\tif u.cacheTime == 0 {\n\t\t\treturn cacheHit, lfi, nil\n\t\t}\n\t\tif lfi.ModTime().Add(u.cacheTime).Before(time.Now()) {\n\t\t\tbfi, err = u.base.Stat(name)\n\t\t\tif err != nil {\n\t\t\t\treturn cacheLocal, lfi, nil\n\t\t\t}\n\t\t\tif bfi.ModTime().After(lfi.ModTime()) {\n\t\t\t\treturn cacheStale, bfi, nil\n\t\t\t}\n\t\t}\n\t\treturn cacheHit, lfi, nil\n\t}\n\n\tif err == syscall.ENOENT || os.IsNotExist(err) {\n\t\treturn cacheMiss, nil, nil\n\t}\n\n\treturn cacheMiss, nil, err\n}\n\nfunc (u *CacheOnReadFs) copyToLayer(name string) error {\n\treturn copyToLayer(u.base, u.layer, name)\n}\n\nfunc (u *CacheOnReadFs) copyFileToLayer(name string, flag int, perm os.FileMode) error {\n\treturn copyFileToLayer(u.base, u.layer, name, flag, perm)\n}\n\nfunc (u *CacheOnReadFs) Chtimes(name string, atime, mtime time.Time) error {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit:\n\t\terr = u.base.Chtimes(name, atime, mtime)\n\tcase cacheStale, cacheMiss:\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = u.base.Chtimes(name, atime, mtime)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.Chtimes(name, atime, mtime)\n}\n\nfunc (u *CacheOnReadFs) Chmod(name string, mode os.FileMode) error {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit:\n\t\terr = u.base.Chmod(name, mode)\n\tcase cacheStale, cacheMiss:\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = u.base.Chmod(name, mode)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.Chmod(name, mode)\n}\n\nfunc (u *CacheOnReadFs) Chown(name string, uid, gid int) error {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit:\n\t\terr = u.base.Chown(name, uid, gid)\n\tcase cacheStale, cacheMiss:\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = u.base.Chown(name, uid, gid)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.Chown(name, uid, gid)\n}\n\nfunc (u *CacheOnReadFs) Stat(name string) (os.FileInfo, error) {\n\tst, fi, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch st {\n\tcase cacheMiss:\n\t\treturn u.base.Stat(name)\n\tdefault: // cacheStale has base, cacheHit and cacheLocal the layer os.FileInfo\n\t\treturn fi, nil\n\t}\n}\n\nfunc (u *CacheOnReadFs) Rename(oldname, newname string) error {\n\tst, _, err := u.cacheStatus(oldname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit:\n\t\terr = u.base.Rename(oldname, newname)\n\tcase cacheStale, cacheMiss:\n\t\tif err := u.copyToLayer(oldname); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = u.base.Rename(oldname, newname)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.Rename(oldname, newname)\n}\n\nfunc (u *CacheOnReadFs) Remove(name string) error {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit, cacheStale, cacheMiss:\n\t\terr = u.base.Remove(name)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.Remove(name)\n}\n\nfunc (u *CacheOnReadFs) RemoveAll(name string) error {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch st {\n\tcase cacheLocal:\n\tcase cacheHit, cacheStale, cacheMiss:\n\t\terr = u.base.RemoveAll(name)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.RemoveAll(name)\n}\n\nfunc (u *CacheOnReadFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tst, _, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch st {\n\tcase cacheLocal, cacheHit:\n\tdefault:\n\t\tif err := u.copyFileToLayer(name, flag, perm); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif flag&(os.O_WRONLY|syscall.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC) != 0 {\n\t\tbfi, err := u.base.OpenFile(name, flag, perm)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlfi, err := u.layer.OpenFile(name, flag, perm)\n\t\tif err != nil {\n\t\t\tbfi.Close() // oops, what if O_TRUNC was set and file opening in the layer failed...?\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &UnionFile{Base: bfi, Layer: lfi}, nil\n\t}\n\treturn u.layer.OpenFile(name, flag, perm)\n}\n\nfunc (u *CacheOnReadFs) Open(name string) (File, error) {\n\tst, fi, err := u.cacheStatus(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch st {\n\tcase cacheLocal:\n\t\treturn u.layer.Open(name)\n\n\tcase cacheMiss:\n\t\tbfi, err := u.base.Stat(name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif bfi.IsDir() {\n\t\t\treturn u.base.Open(name)\n\t\t}\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn u.layer.Open(name)\n\n\tcase cacheStale:\n\t\tif !fi.IsDir() {\n\t\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn u.layer.Open(name)\n\t\t}\n\tcase cacheHit:\n\t\tif !fi.IsDir() {\n\t\t\treturn u.layer.Open(name)\n\t\t}\n\t}\n\t// the dirs from cacheHit, cacheStale fall down here:\n\tbfile, _ := u.base.Open(name)\n\tlfile, err := u.layer.Open(name)\n\tif err != nil && bfile == nil {\n\t\treturn nil, err\n\t}\n\treturn &UnionFile{Base: bfile, Layer: lfile}, nil\n}\n\nfunc (u *CacheOnReadFs) Mkdir(name string, perm os.FileMode) error {\n\terr := u.base.Mkdir(name, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.MkdirAll(name, perm) // yes, MkdirAll... we cannot assume it exists in the cache\n}\n\nfunc (u *CacheOnReadFs) Name() string {\n\treturn \"CacheOnReadFs\"\n}\n\nfunc (u *CacheOnReadFs) MkdirAll(name string, perm os.FileMode) error {\n\terr := u.base.MkdirAll(name, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn u.layer.MkdirAll(name, perm)\n}\n\nfunc (u *CacheOnReadFs) Create(name string) (File, error) {\n\tbfh, err := u.base.Create(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlfh, err := u.layer.Create(name)\n\tif err != nil {\n\t\t// oops, see comment about OS_TRUNC above, should we remove? then we have to\n\t\t// remember if the file did not exist before\n\t\tbfh.Close()\n\t\treturn nil, err\n\t}\n\treturn &UnionFile{Base: bfh, Layer: lfh}, nil\n}\n"
        },
        {
          "name": "composite_test.go",
          "type": "blob",
          "size": 11.029296875,
          "content": "package afero\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar tempDirs []string\n\nfunc NewTempOsBaseFs(t *testing.T) Fs {\n\tname, err := TempDir(NewOsFs(), \"\", \"\")\n\tif err != nil {\n\t\tt.Error(\"error creating tempDir\", err)\n\t}\n\n\ttempDirs = append(tempDirs, name)\n\n\treturn NewBasePathFs(NewOsFs(), name)\n}\n\nfunc CleanupTempDirs(t *testing.T) {\n\tosfs := NewOsFs()\n\ttype ev struct {\n\t\tpath string\n\t\te    error\n\t}\n\n\terrs := []ev{}\n\n\tfor _, x := range tempDirs {\n\t\terr := osfs.RemoveAll(x)\n\t\tif err != nil {\n\t\t\terrs = append(errs, ev{path: x, e: err})\n\t\t}\n\t}\n\n\tfor _, e := range errs {\n\t\tfmt.Println(\"error removing tempDir\", e.path, e.e)\n\t}\n\n\tif len(errs) > 0 {\n\t\tt.Error(\"error cleaning up tempDirs\")\n\t}\n\ttempDirs = []string{}\n}\n\nfunc TestUnionCreateExisting(t *testing.T) {\n\tbase := &MemMapFs{}\n\troBase := &ReadOnlyFs{source: base}\n\tufs := NewCopyOnWriteFs(roBase, &MemMapFs{})\n\n\tbase.MkdirAll(\"/home/test\", 0o777)\n\tfh, _ := base.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, err := ufs.OpenFile(\"/home/test/file.txt\", os.O_RDWR, 0o666)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open file r/w: %s\", err)\n\t}\n\n\t_, err = fh.Write([]byte(\"####\"))\n\tif err != nil {\n\t\tt.Errorf(\"Failed to write file: %s\", err)\n\t}\n\tfh.Seek(0, 0)\n\tdata, err := io.ReadAll(fh)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to read file: %s\", err)\n\t}\n\tif string(data) != \"#### is a test\" {\n\t\tt.Errorf(\"Got wrong data\")\n\t}\n\tfh.Close()\n\n\tfh, _ = base.Open(\"/home/test/file.txt\")\n\tdata, _ = io.ReadAll(fh)\n\tif string(data) != \"This is a test\" {\n\t\tt.Errorf(\"Got wrong data in base file\")\n\t}\n\tfh.Close()\n\n\tfh, err = ufs.Create(\"/home/test/file.txt\")\n\tswitch err {\n\tcase nil:\n\t\tif fi, _ := fh.Stat(); fi.Size() != 0 {\n\t\t\tt.Errorf(\"Create did not truncate file\")\n\t\t}\n\t\tfh.Close()\n\tdefault:\n\t\tt.Errorf(\"Create failed on existing file\")\n\t}\n}\n\nfunc TestUnionMergeReaddir(t *testing.T) {\n\tbase := &MemMapFs{}\n\troBase := &ReadOnlyFs{source: base}\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: &MemMapFs{}}\n\n\tbase.MkdirAll(\"/home/test\", 0o777)\n\tfh, _ := base.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Create(\"/home/test/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Open(\"/home/test\")\n\tfiles, err := fh.Readdirnames(-1)\n\tif err != nil {\n\t\tt.Errorf(\"Readdirnames failed\")\n\t}\n\tif len(files) != 2 {\n\t\tt.Errorf(\"Got wrong number of files: %v\", files)\n\t}\n}\n\nfunc TestExistingDirectoryCollisionReaddir(t *testing.T) {\n\tbase := &MemMapFs{}\n\troBase := &ReadOnlyFs{source: base}\n\toverlay := &MemMapFs{}\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: overlay}\n\n\tbase.MkdirAll(\"/home/test\", 0o777)\n\tfh, _ := base.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\toverlay.MkdirAll(\"home/test\", 0o777)\n\tfh, _ = overlay.Create(\"/home/test/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Create(\"/home/test/file3.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Open(\"/home/test\")\n\tfiles, err := fh.Readdirnames(-1)\n\tif err != nil {\n\t\tt.Errorf(\"Readdirnames failed\")\n\t}\n\tif len(files) != 3 {\n\t\tt.Errorf(\"Got wrong number of files in union: %v\", files)\n\t}\n\n\tfh, _ = overlay.Open(\"/home/test\")\n\tfiles, err = fh.Readdirnames(-1)\n\tif err != nil {\n\t\tt.Errorf(\"Readdirnames failed\")\n\t}\n\tif len(files) != 2 {\n\t\tt.Errorf(\"Got wrong number of files in overlay: %v\", files)\n\t}\n}\n\nfunc TestNestedDirBaseReaddir(t *testing.T) {\n\tbase := &MemMapFs{}\n\troBase := &ReadOnlyFs{source: base}\n\toverlay := &MemMapFs{}\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: overlay}\n\n\tbase.MkdirAll(\"/home/test/foo/bar\", 0o777)\n\tfh, _ := base.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = base.Create(\"/home/test/foo/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\tfh, _ = base.Create(\"/home/test/foo/bar/file3.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\toverlay.MkdirAll(\"/\", 0o777)\n\n\t// Opening something only in the base\n\tfh, _ = ufs.Open(\"/home/test/foo\")\n\tlist, err := fh.Readdir(-1)\n\tif err != nil {\n\t\tt.Errorf(\"Readdir failed %s\", err)\n\t}\n\tif len(list) != 2 {\n\t\tfor _, x := range list {\n\t\t\tfmt.Println(x.Name())\n\t\t}\n\t\tt.Errorf(\"Got wrong number of files in union: %v\", len(list))\n\t}\n}\n\nfunc TestNestedDirOverlayReaddir(t *testing.T) {\n\tbase := &MemMapFs{}\n\troBase := &ReadOnlyFs{source: base}\n\toverlay := &MemMapFs{}\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: overlay}\n\n\tbase.MkdirAll(\"/\", 0o777)\n\toverlay.MkdirAll(\"/home/test/foo/bar\", 0o777)\n\tfh, _ := overlay.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\tfh, _ = overlay.Create(\"/home/test/foo/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\tfh, _ = overlay.Create(\"/home/test/foo/bar/file3.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\t// Opening nested dir only in the overlay\n\tfh, _ = ufs.Open(\"/home/test/foo\")\n\tlist, err := fh.Readdir(-1)\n\tif err != nil {\n\t\tt.Errorf(\"Readdir failed %s\", err)\n\t}\n\tif len(list) != 2 {\n\t\tfor _, x := range list {\n\t\t\tfmt.Println(x.Name())\n\t\t}\n\t\tt.Errorf(\"Got wrong number of files in union: %v\", len(list))\n\t}\n}\n\nfunc TestNestedDirOverlayOsFsReaddir(t *testing.T) {\n\tdefer CleanupTempDirs(t)\n\tbase := NewTempOsBaseFs(t)\n\troBase := &ReadOnlyFs{source: base}\n\toverlay := NewTempOsBaseFs(t)\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: overlay}\n\n\tbase.MkdirAll(\"/\", 0o777)\n\toverlay.MkdirAll(\"/home/test/foo/bar\", 0o777)\n\tfh, _ := overlay.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\tfh, _ = overlay.Create(\"/home/test/foo/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\tfh, _ = overlay.Create(\"/home/test/foo/bar/file3.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\t// Opening nested dir only in the overlay\n\tfh, _ = ufs.Open(\"/home/test/foo\")\n\tlist, err := fh.Readdir(-1)\n\tfh.Close()\n\tif err != nil {\n\t\tt.Errorf(\"Readdir failed %s\", err)\n\t}\n\tif len(list) != 2 {\n\t\tfor _, x := range list {\n\t\t\tfmt.Println(x.Name())\n\t\t}\n\t\tt.Errorf(\"Got wrong number of files in union: %v\", len(list))\n\t}\n}\n\nfunc TestCopyOnWriteFsWithOsFs(t *testing.T) {\n\tdefer CleanupTempDirs(t)\n\tbase := NewTempOsBaseFs(t)\n\troBase := &ReadOnlyFs{source: base}\n\toverlay := NewTempOsBaseFs(t)\n\n\tufs := &CopyOnWriteFs{base: roBase, layer: overlay}\n\n\tbase.MkdirAll(\"/home/test\", 0o777)\n\tfh, _ := base.Create(\"/home/test/file.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\toverlay.MkdirAll(\"home/test\", 0o777)\n\tfh, _ = overlay.Create(\"/home/test/file2.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Create(\"/home/test/file3.txt\")\n\tfh.WriteString(\"This is a test\")\n\tfh.Close()\n\n\tfh, _ = ufs.Open(\"/home/test\")\n\tfiles, err := fh.Readdirnames(-1)\n\tfh.Close()\n\tif err != nil {\n\t\tt.Errorf(\"Readdirnames failed\")\n\t}\n\tif len(files) != 3 {\n\t\tt.Errorf(\"Got wrong number of files in union: %v\", files)\n\t}\n\n\tfh, _ = overlay.Open(\"/home/test\")\n\tfiles, err = fh.Readdirnames(-1)\n\tfh.Close()\n\tif err != nil {\n\t\tt.Errorf(\"Readdirnames failed\")\n\t}\n\tif len(files) != 2 {\n\t\tt.Errorf(\"Got wrong number of files in overlay: %v\", files)\n\t}\n}\n\nfunc TestUnionCacheWrite(t *testing.T) {\n\tbase := &MemMapFs{}\n\tlayer := &MemMapFs{}\n\n\tufs := NewCacheOnReadFs(base, layer, 0)\n\n\tbase.Mkdir(\"/data\", 0o777)\n\n\tfh, err := ufs.Create(\"/data/file.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create file\")\n\t}\n\t_, err = fh.Write([]byte(\"This is a test\"))\n\tif err != nil {\n\t\tt.Errorf(\"Failed to write file\")\n\t}\n\n\tfh.Seek(0, io.SeekStart)\n\tbuf := make([]byte, 4)\n\t_, _ = fh.Read(buf)\n\tfh.Write([]byte(\" IS A\"))\n\tfh.Close()\n\n\tbaseData, _ := ReadFile(base, \"/data/file.txt\")\n\tlayerData, _ := ReadFile(layer, \"/data/file.txt\")\n\tif string(baseData) != string(layerData) {\n\t\tt.Errorf(\"Different data: %s <=> %s\", baseData, layerData)\n\t}\n}\n\nfunc TestUnionCacheExpire(t *testing.T) {\n\tbase := &MemMapFs{}\n\tlayer := &MemMapFs{}\n\tufs := &CacheOnReadFs{base: base, layer: layer, cacheTime: 1 * time.Second}\n\n\tbase.Mkdir(\"/data\", 0o777)\n\n\tfh, err := ufs.Create(\"/data/file.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create file\")\n\t}\n\t_, err = fh.Write([]byte(\"This is a test\"))\n\tif err != nil {\n\t\tt.Errorf(\"Failed to write file\")\n\t}\n\tfh.Close()\n\n\tfh, _ = base.Create(\"/data/file.txt\")\n\t// sleep some time, so we really get a different time.Now() on write...\n\ttime.Sleep(2 * time.Second)\n\tfh.WriteString(\"Another test\")\n\tfh.Close()\n\n\tdata, _ := ReadFile(ufs, \"/data/file.txt\")\n\tif string(data) != \"Another test\" {\n\t\tt.Errorf(\"cache time failed: <%s>\", data)\n\t}\n}\n\nfunc TestCacheOnReadFsNotInLayer(t *testing.T) {\n\tbase := NewMemMapFs()\n\tlayer := NewMemMapFs()\n\tfs := NewCacheOnReadFs(base, layer, 0)\n\n\tfh, err := base.Create(\"/file.txt\")\n\tif err != nil {\n\t\tt.Fatal(\"unable to create file: \", err)\n\t}\n\n\ttxt := []byte(\"This is a test\")\n\tfh.Write(txt)\n\tfh.Close()\n\n\tfh, err = fs.Open(\"/file.txt\")\n\tif err != nil {\n\t\tt.Fatal(\"could not open file: \", err)\n\t}\n\n\tb, err := ReadAll(fh)\n\tfh.Close()\n\n\tif err != nil {\n\t\tt.Fatal(\"could not read file: \", err)\n\t} else if !bytes.Equal(txt, b) {\n\t\tt.Fatalf(\"wanted file text %q, got %q\", txt, b)\n\t}\n\n\tfh, err = layer.Open(\"/file.txt\")\n\tif err != nil {\n\t\tt.Fatal(\"could not open file from layer: \", err)\n\t}\n\tfh.Close()\n}\n\n// #194\nfunc TestUnionFileReaddirEmpty(t *testing.T) {\n\tosFs := NewOsFs()\n\n\tbase := NewMemMapFs()\n\toverlay := NewMemMapFs()\n\tufs := &CopyOnWriteFs{base: base, layer: overlay}\n\tmem := NewMemMapFs()\n\n\t// The OS file will return io.EOF on end of directory.\n\tfor _, fs := range []Fs{osFs, ufs, mem} {\n\t\tbaseDir, err := TempDir(fs, \"\", \"empty-dir\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tf, err := fs.Open(baseDir)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tnames, err := f.Readdirnames(1)\n\t\tif err != io.EOF {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(names) != 0 {\n\t\t\tt.Fatal(\"should be empty\")\n\t\t}\n\n\t\tf.Close()\n\n\t\tfs.RemoveAll(baseDir)\n\t}\n}\n\n// #197\nfunc TestUnionFileReaddirDuplicateEmpty(t *testing.T) {\n\tbase := NewMemMapFs()\n\tdir, err := TempDir(base, \"\", \"empty-dir\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Overlay shares same empty directory as base\n\toverlay := NewMemMapFs()\n\terr = overlay.Mkdir(dir, 0o700)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tufs := &CopyOnWriteFs{base: base, layer: overlay}\n\n\tf, err := ufs.Open(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\tnames, err := f.Readdirnames(0)\n\n\tif err == io.EOF {\n\t\tt.Errorf(\"unexpected io.EOF error\")\n\t}\n\n\tif len(names) != 0 {\n\t\tt.Fatal(\"should be empty\")\n\t}\n}\n\nfunc TestUnionFileReaddirAskForTooMany(t *testing.T) {\n\tbase := &MemMapFs{}\n\toverlay := &MemMapFs{}\n\n\tconst testFiles = 5\n\tfor i := 0; i < testFiles; i++ {\n\t\tWriteFile(base, fmt.Sprintf(\"file%d.txt\", i), []byte(\"afero\"), 0o777)\n\t}\n\n\tufs := &CopyOnWriteFs{base: base, layer: overlay}\n\n\tf, err := ufs.Open(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer f.Close()\n\n\t// Read part of all files\n\twantNames := 3\n\tnames, err := f.Readdirnames(wantNames)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(names) != wantNames {\n\t\tt.Fatalf(\"got %d names %v, want %d\", len(names), names, wantNames)\n\t}\n\n\t// Try to read more files than remaining\n\twantNames = testFiles - len(names)\n\tnames, err = f.Readdirnames(wantNames + 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(names) != wantNames {\n\t\tt.Fatalf(\"got %d names %v, want %d\", len(names), names, wantNames)\n\t}\n\n\t// End of directory\n\t_, err = f.Readdirnames(3)\n\tif err != io.EOF {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "const_bsds.go",
          "type": "blob",
          "size": 0.787109375,
          "content": "// Copyright © 2016 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build aix || darwin || openbsd || freebsd || netbsd || dragonfly || zos\n// +build aix darwin openbsd freebsd netbsd dragonfly zos\n\npackage afero\n\nimport (\n\t\"syscall\"\n)\n\nconst BADFD = syscall.EBADF\n"
        },
        {
          "name": "const_win_unix.go",
          "type": "blob",
          "size": 0.80078125,
          "content": "// Copyright © 2016 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//go:build !darwin && !openbsd && !freebsd && !dragonfly && !netbsd && !aix && !zos\n// +build !darwin,!openbsd,!freebsd,!dragonfly,!netbsd,!aix,!zos\n\npackage afero\n\nimport (\n\t\"syscall\"\n)\n\nconst BADFD = syscall.EBADFD\n"
        },
        {
          "name": "copyOnWriteFs.go",
          "type": "blob",
          "size": 7.5810546875,
          "content": "package afero\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar _ Lstater = (*CopyOnWriteFs)(nil)\n\n// The CopyOnWriteFs is a union filesystem: a read only base file system with\n// a possibly writeable layer on top. Changes to the file system will only\n// be made in the overlay: Changing an existing file in the base layer which\n// is not present in the overlay will copy the file to the overlay (\"changing\"\n// includes also calls to e.g. Chtimes(), Chmod() and Chown()).\n//\n// Reading directories is currently only supported via Open(), not OpenFile().\ntype CopyOnWriteFs struct {\n\tbase  Fs\n\tlayer Fs\n}\n\nfunc NewCopyOnWriteFs(base Fs, layer Fs) Fs {\n\treturn &CopyOnWriteFs{base: base, layer: layer}\n}\n\n// Returns true if the file is not in the overlay\nfunc (u *CopyOnWriteFs) isBaseFile(name string) (bool, error) {\n\tif _, err := u.layer.Stat(name); err == nil {\n\t\treturn false, nil\n\t}\n\t_, err := u.base.Stat(name)\n\tif err != nil {\n\t\tif oerr, ok := err.(*os.PathError); ok {\n\t\t\tif oerr.Err == os.ErrNotExist || oerr.Err == syscall.ENOENT || oerr.Err == syscall.ENOTDIR {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\t\tif err == syscall.ENOENT {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\treturn true, err\n}\n\nfunc (u *CopyOnWriteFs) copyToLayer(name string) error {\n\treturn copyToLayer(u.base, u.layer, name)\n}\n\nfunc (u *CopyOnWriteFs) Chtimes(name string, atime, mtime time.Time) error {\n\tb, err := u.isBaseFile(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b {\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn u.layer.Chtimes(name, atime, mtime)\n}\n\nfunc (u *CopyOnWriteFs) Chmod(name string, mode os.FileMode) error {\n\tb, err := u.isBaseFile(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b {\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn u.layer.Chmod(name, mode)\n}\n\nfunc (u *CopyOnWriteFs) Chown(name string, uid, gid int) error {\n\tb, err := u.isBaseFile(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b {\n\t\tif err := u.copyToLayer(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn u.layer.Chown(name, uid, gid)\n}\n\nfunc (u *CopyOnWriteFs) Stat(name string) (os.FileInfo, error) {\n\tfi, err := u.layer.Stat(name)\n\tif err != nil {\n\t\tisNotExist := u.isNotExist(err)\n\t\tif isNotExist {\n\t\t\treturn u.base.Stat(name)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn fi, nil\n}\n\nfunc (u *CopyOnWriteFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tllayer, ok1 := u.layer.(Lstater)\n\tlbase, ok2 := u.base.(Lstater)\n\n\tif ok1 {\n\t\tfi, b, err := llayer.LstatIfPossible(name)\n\t\tif err == nil {\n\t\t\treturn fi, b, nil\n\t\t}\n\n\t\tif !u.isNotExist(err) {\n\t\t\treturn nil, b, err\n\t\t}\n\t}\n\n\tif ok2 {\n\t\tfi, b, err := lbase.LstatIfPossible(name)\n\t\tif err == nil {\n\t\t\treturn fi, b, nil\n\t\t}\n\t\tif !u.isNotExist(err) {\n\t\t\treturn nil, b, err\n\t\t}\n\t}\n\n\tfi, err := u.Stat(name)\n\n\treturn fi, false, err\n}\n\nfunc (u *CopyOnWriteFs) SymlinkIfPossible(oldname, newname string) error {\n\tif slayer, ok := u.layer.(Linker); ok {\n\t\treturn slayer.SymlinkIfPossible(oldname, newname)\n\t}\n\n\treturn &os.LinkError{Op: \"symlink\", Old: oldname, New: newname, Err: ErrNoSymlink}\n}\n\nfunc (u *CopyOnWriteFs) ReadlinkIfPossible(name string) (string, error) {\n\tif rlayer, ok := u.layer.(LinkReader); ok {\n\t\treturn rlayer.ReadlinkIfPossible(name)\n\t}\n\n\tif rbase, ok := u.base.(LinkReader); ok {\n\t\treturn rbase.ReadlinkIfPossible(name)\n\t}\n\n\treturn \"\", &os.PathError{Op: \"readlink\", Path: name, Err: ErrNoReadlink}\n}\n\nfunc (u *CopyOnWriteFs) isNotExist(err error) bool {\n\tif e, ok := err.(*os.PathError); ok {\n\t\terr = e.Err\n\t}\n\tif err == os.ErrNotExist || err == syscall.ENOENT || err == syscall.ENOTDIR {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Renaming files present only in the base layer is not permitted\nfunc (u *CopyOnWriteFs) Rename(oldname, newname string) error {\n\tb, err := u.isBaseFile(oldname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b {\n\t\treturn syscall.EPERM\n\t}\n\treturn u.layer.Rename(oldname, newname)\n}\n\n// Removing files present only in the base layer is not permitted. If\n// a file is present in the base layer and the overlay, only the overlay\n// will be removed.\nfunc (u *CopyOnWriteFs) Remove(name string) error {\n\terr := u.layer.Remove(name)\n\tswitch err {\n\tcase syscall.ENOENT:\n\t\t_, err = u.base.Stat(name)\n\t\tif err == nil {\n\t\t\treturn syscall.EPERM\n\t\t}\n\t\treturn syscall.ENOENT\n\tdefault:\n\t\treturn err\n\t}\n}\n\nfunc (u *CopyOnWriteFs) RemoveAll(name string) error {\n\terr := u.layer.RemoveAll(name)\n\tswitch err {\n\tcase syscall.ENOENT:\n\t\t_, err = u.base.Stat(name)\n\t\tif err == nil {\n\t\t\treturn syscall.EPERM\n\t\t}\n\t\treturn syscall.ENOENT\n\tdefault:\n\t\treturn err\n\t}\n}\n\nfunc (u *CopyOnWriteFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tb, err := u.isBaseFile(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif flag&(os.O_WRONLY|os.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC) != 0 {\n\t\tif b {\n\t\t\tif err = u.copyToLayer(name); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn u.layer.OpenFile(name, flag, perm)\n\t\t}\n\n\t\tdir := filepath.Dir(name)\n\t\tisaDir, err := IsDir(u.base, dir)\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif isaDir {\n\t\t\tif err = u.layer.MkdirAll(dir, 0o777); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn u.layer.OpenFile(name, flag, perm)\n\t\t}\n\n\t\tisaDir, err = IsDir(u.layer, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif isaDir {\n\t\t\treturn u.layer.OpenFile(name, flag, perm)\n\t\t}\n\n\t\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: syscall.ENOTDIR} // ...or os.ErrNotExist?\n\t}\n\tif b {\n\t\treturn u.base.OpenFile(name, flag, perm)\n\t}\n\treturn u.layer.OpenFile(name, flag, perm)\n}\n\n// This function handles the 9 different possibilities caused\n// by the union which are the intersection of the following...\n//\n//\tlayer: doesn't exist, exists as a file, and exists as a directory\n//\tbase:  doesn't exist, exists as a file, and exists as a directory\nfunc (u *CopyOnWriteFs) Open(name string) (File, error) {\n\t// Since the overlay overrides the base we check that first\n\tb, err := u.isBaseFile(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If overlay doesn't exist, return the base (base state irrelevant)\n\tif b {\n\t\treturn u.base.Open(name)\n\t}\n\n\t// If overlay is a file, return it (base state irrelevant)\n\tdir, err := IsDir(u.layer, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !dir {\n\t\treturn u.layer.Open(name)\n\t}\n\n\t// Overlay is a directory, base state now matters.\n\t// Base state has 3 states to check but 2 outcomes:\n\t// A. It's a file or non-readable in the base (return just the overlay)\n\t// B. It's an accessible directory in the base (return a UnionFile)\n\n\t// If base is file or nonreadable, return overlay\n\tdir, err = IsDir(u.base, name)\n\tif !dir || err != nil {\n\t\treturn u.layer.Open(name)\n\t}\n\n\t// Both base & layer are directories\n\t// Return union file (if opens are without error)\n\tbfile, bErr := u.base.Open(name)\n\tlfile, lErr := u.layer.Open(name)\n\n\t// If either have errors at this point something is very wrong. Return nil and the errors\n\tif bErr != nil || lErr != nil {\n\t\treturn nil, fmt.Errorf(\"BaseErr: %v\\nOverlayErr: %v\", bErr, lErr)\n\t}\n\n\treturn &UnionFile{Base: bfile, Layer: lfile}, nil\n}\n\nfunc (u *CopyOnWriteFs) Mkdir(name string, perm os.FileMode) error {\n\tdir, err := IsDir(u.base, name)\n\tif err != nil {\n\t\treturn u.layer.MkdirAll(name, perm)\n\t}\n\tif dir {\n\t\treturn ErrFileExists\n\t}\n\treturn u.layer.MkdirAll(name, perm)\n}\n\nfunc (u *CopyOnWriteFs) Name() string {\n\treturn \"CopyOnWriteFs\"\n}\n\nfunc (u *CopyOnWriteFs) MkdirAll(name string, perm os.FileMode) error {\n\tdir, err := IsDir(u.base, name)\n\tif err != nil {\n\t\treturn u.layer.MkdirAll(name, perm)\n\t}\n\tif dir {\n\t\t// This is in line with how os.MkdirAll behaves.\n\t\treturn nil\n\t}\n\treturn u.layer.MkdirAll(name, perm)\n}\n\nfunc (u *CopyOnWriteFs) Create(name string) (File, error) {\n\treturn u.OpenFile(name, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0o666)\n}\n"
        },
        {
          "name": "copyOnWriteFs_test.go",
          "type": "blob",
          "size": 1.3388671875,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestCopyOnWrite(t *testing.T) {\n\tosFs := NewOsFs()\n\twriteDir, err := TempDir(osFs, \"\", \"copy-on-write-test\")\n\tif err != nil {\n\t\tt.Fatal(\"error creating tempDir\", err)\n\t}\n\tdefer osFs.RemoveAll(writeDir)\n\n\tcompositeFs := NewCopyOnWriteFs(NewReadOnlyFs(NewOsFs()), osFs)\n\n\tdir := filepath.Join(writeDir, \"some/path\")\n\n\terr = compositeFs.MkdirAll(dir, 0o744)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = compositeFs.Create(filepath.Join(dir, \"newfile\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// https://github.com/spf13/afero/issues/189\n\t// We want the composite file system to behave like the OS file system\n\t// on Mkdir and MkdirAll\n\tfor _, fs := range []Fs{osFs, compositeFs} {\n\t\terr = fs.Mkdir(dir, 0o744)\n\t\tif err == nil || !os.IsExist(err) {\n\t\t\tt.Errorf(\"Mkdir: Got %q for %T\", err, fs)\n\t\t}\n\n\t\t// MkdirAll does not return an error when the directory already exists\n\t\terr = fs.MkdirAll(dir, 0o744)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"MkdirAll:  Got %q for %T\", err, fs)\n\t\t}\n\n\t}\n}\n\nfunc TestCopyOnWriteFileInMemMapBase(t *testing.T) {\n\tbase := &MemMapFs{}\n\tlayer := &MemMapFs{}\n\n\tif err := WriteFile(base, \"base.txt\", []byte(\"base\"), 0o755); err != nil {\n\t\tt.Fatalf(\"Failed to write file: %s\", err)\n\t}\n\n\tufs := NewCopyOnWriteFs(base, layer)\n\n\t_, err := ufs.Stat(\"base.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "gcsfs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.708984375,
          "content": "module github.com/spf13/afero\n\ngo 1.21\n\nrequire (\n\tcloud.google.com/go/storage v1.49.0\n\tgithub.com/pkg/sftp v1.13.7\n\tgolang.org/x/crypto v0.32.0\n\tgolang.org/x/oauth2 v0.25.0\n\tgolang.org/x/text v0.21.0\n\tgoogle.golang.org/api v0.215.0\n)\n\nrequire (\n\tcel.dev/expr v0.16.1 // indirect\n\tcloud.google.com/go v0.116.0 // indirect\n\tcloud.google.com/go/auth v0.13.0 // indirect\n\tcloud.google.com/go/auth/oauth2adapt v0.2.6 // indirect\n\tcloud.google.com/go/compute/metadata v0.6.0 // indirect\n\tcloud.google.com/go/iam v1.2.2 // indirect\n\tcloud.google.com/go/monitoring v1.21.2 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.25.0 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1 // indirect\n\tgithub.com/census-instrumentation/opencensus-proto v0.4.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78 // indirect\n\tgithub.com/envoyproxy/go-control-plane v0.13.1 // indirect\n\tgithub.com/envoyproxy/protoc-gen-validate v1.1.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/google/s2a-go v0.1.8 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.14.1 // indirect\n\tgithub.com/kr/fs v0.1.0 // indirect\n\tgithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 // indirect\n\tgo.opencensus.io v0.24.0 // indirect\n\tgo.opentelemetry.io/contrib/detectors/gcp v1.29.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect\n\tgo.opentelemetry.io/otel v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/sdk v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/sdk/metric v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.29.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/time v0.8.0 // indirect\n\tgoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697 // indirect\n\tgoogle.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241223144023-3abc09e42ca8 // indirect\n\tgoogle.golang.org/grpc v1.67.3 // indirect\n\tgoogle.golang.org/protobuf v1.36.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 22.8330078125,
          "content": "cel.dev/expr v0.16.1 h1:NR0+oFYzR1CqLFhTAqg3ql59G9VfN8fKq1TCHJ6gq1g=\ncel.dev/expr v0.16.1/go.mod h1:AsGA5zb3WruAEQeQng1RZdGEXmBj0jvMWh6l5SnNuC8=\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.116.0 h1:B3fRrSDkLRt5qSHWe40ERJvhvnQwdZiHu0bJOpldweE=\ncloud.google.com/go v0.116.0/go.mod h1:cEPSRWPzZEswwdr9BxE6ChEn01dWlTaF05LiC2Xs70U=\ncloud.google.com/go/auth v0.13.0 h1:8Fu8TZy167JkW8Tj3q7dIkr2v4cndv41ouecJx0PAHs=\ncloud.google.com/go/auth v0.13.0/go.mod h1:COOjD9gwfKNKz+IIduatIhYJQIc0mG3H102r/EMxX6Q=\ncloud.google.com/go/auth/oauth2adapt v0.2.6 h1:V6a6XDu2lTwPZWOawrAa9HUK+DB2zfJyTuciBG5hFkU=\ncloud.google.com/go/auth/oauth2adapt v0.2.6/go.mod h1:AlmsELtlEBnaNTL7jCj8VQFLy6mbZv0s4Q7NGBeQ5E8=\ncloud.google.com/go/compute/metadata v0.6.0 h1:A6hENjEsCDtC1k8byVsgwvVcioamEHvZ4j01OwKxG9I=\ncloud.google.com/go/compute/metadata v0.6.0/go.mod h1:FjyFAW1MW0C203CEOMDTu3Dk1FlqW3Rga40jzHL4hfg=\ncloud.google.com/go/iam v1.2.2 h1:ozUSofHUGf/F4tCNy/mu9tHLTaxZFLOUiKzjcgWHGIA=\ncloud.google.com/go/iam v1.2.2/go.mod h1:0Ys8ccaZHdI1dEUilwzqng/6ps2YB6vRsjIe00/+6JY=\ncloud.google.com/go/logging v1.12.0 h1:ex1igYcGFd4S/RZWOCU51StlIEuey5bjqwH9ZYjHibk=\ncloud.google.com/go/logging v1.12.0/go.mod h1:wwYBt5HlYP1InnrtYI0wtwttpVU1rifnMT7RejksUAM=\ncloud.google.com/go/longrunning v0.6.2 h1:xjDfh1pQcWPEvnfjZmwjKQEcHnpz6lHjfy7Fo0MK+hc=\ncloud.google.com/go/longrunning v0.6.2/go.mod h1:k/vIs83RN4bE3YCswdXC5PFfWVILjm3hpEUlSko4PiI=\ncloud.google.com/go/monitoring v1.21.2 h1:FChwVtClH19E7pJ+e0xUhJPGksctZNVOk2UhMmblmdU=\ncloud.google.com/go/monitoring v1.21.2/go.mod h1:hS3pXvaG8KgWTSz+dAdyzPrGUYmi2Q+WFX8g2hqVEZU=\ncloud.google.com/go/storage v1.49.0 h1:zenOPBOWHCnojRd9aJZAyQXBYqkJkdQS42dxL55CIMw=\ncloud.google.com/go/storage v1.49.0/go.mod h1:k1eHhhpLvrPjVGfo0mOUPEJ4Y2+a/Hv5PiwehZI9qGU=\ncloud.google.com/go/trace v1.11.2 h1:4ZmaBdL8Ng/ajrgKqY5jfvzqMXbrDcBsUGXOT9aqTtI=\ncloud.google.com/go/trace v1.11.2/go.mod h1:bn7OwXd4pd5rFuAnTrzBuoZ4ax2XQeG3qNgYmfCy0Io=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.25.0 h1:3c8yed4lgqTt+oTQ+JNMDo+F4xprBf+O/il4ZC0nRLw=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.25.0/go.mod h1:obipzmGjfSjam60XLwGfqUkJsfiheAl+TUjG+4yzyPM=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1 h1:UQ0AhxogsIRZDkElkblfnwjc3IaltCm2HUMvezQaL7s=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1/go.mod h1:jyqM3eLpJ3IbIFDTKVz2rF9T/xWGW0rIriGwnz8l9Tk=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/cloudmock v0.48.1 h1:oTX4vsorBZo/Zdum6OKPA4o7544hm6smoRv1QjpTwGo=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/cloudmock v0.48.1/go.mod h1:0wEl7vrAD8mehJyohS9HZy+WyEOaQO2mJx86Cvh93kM=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1 h1:8nn+rsCvTq9axyEh382S0PFLBeaFwNsT43IrPWzctRU=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1/go.mod h1:viRWSEhtMZqz1rhwmOVKkWl6SwmVowfL9O2YR5gI2PE=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1 h1:iKLQ0xPNFxR/2hzXZMrBo8f1j86j5WHzznCCQxV/b8g=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78 h1:QVw89YDxXxEe+l8gU8ETbOasdwEV+avkR75ZzsVV9WI=\ngithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78/go.mod h1:W+zGtBO5Y1IgJhy4+A9GOqVhqLpfZi+vwmdNXUehLA8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/go-control-plane v0.13.1 h1:vPfJZCkob6yTMEgS+0TwfTUfbHjfy/6vOJ8hUWX/uXE=\ngithub.com/envoyproxy/go-control-plane v0.13.1/go.mod h1:X45hY0mufo6Fd0KW3rqsGvQMw58jvjymeCzBU3mWyHw=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/envoyproxy/protoc-gen-validate v1.1.0 h1:tntQDh69XqOCOZsDz0lVJQez/2L6Uu2PdjCQwWCJ3bM=\ngithub.com/envoyproxy/protoc-gen-validate v1.1.0/go.mod h1:sXRDRVmzEbkM7CVcM06s9shE/m23dg3wzjl0UWqJ2q4=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/martian/v3 v3.3.3 h1:DIhPTQrbPkgs2yJYdXU/eNACCG5DVQjySNRNlflZ9Fc=\ngithub.com/google/martian/v3 v3.3.3/go.mod h1:iEPrYcgCF7jA9OtScMFQyAlZZ4YXTKEtJ1E6RWzmBA0=\ngithub.com/google/s2a-go v0.1.8 h1:zZDs9gcbt9ZPLV0ndSyQk6Kacx2g/X+SKYovpnz3SMM=\ngithub.com/google/s2a-go v0.1.8/go.mod h1:6iNWHTpQ+nfNRN5E00MSdfDwVesa8hhS32PhPO8deJA=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4 h1:XYIDZApgAnrN1c855gTgghdIA6Stxb52D5RnLI1SLyw=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4/go.mod h1:YKe7cfqYXjKGpGvmSg28/fFvhNzinZQm8DGnaburhGA=\ngithub.com/googleapis/gax-go/v2 v2.14.1 h1:hb0FFeiPaQskmvakKu5EbCbpntQn48jyHuvrkurSS/Q=\ngithub.com/googleapis/gax-go/v2 v2.14.1/go.mod h1:Hb/NubMaVM88SrNkvl8X/o8XWwDJEPqouaLeN2IUxoA=\ngithub.com/kr/fs v0.1.0 h1:Jskdu9ieNAYnjxsi0LbQp1ulIKZV1LAFgK1tWhpZgl8=\ngithub.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\ngithub.com/pkg/sftp v1.13.7 h1:uv+I3nNJvlKZIQGSr8JVQLNHFU9YhhNpvC14Y6KgmSM=\ngithub.com/pkg/sftp v1.13.7/go.mod h1:KMKI0t3T6hfA+lTR/ssZdunHo+uwq7ghoN09/FSu3DY=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 h1:GFCKgmp0tecUJ0sJuv4pzYCqS9+RGSn52M3FUwPs+uo=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10/go.mod h1:t/avpk3KcrXxUnYOhZhMXJlSEyie6gQbtLq5NM3loB8=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngo.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/contrib/detectors/gcp v1.29.0 h1:TiaiXB4DpGD3sdzNlYQxruQngn5Apwzi1X0DRhuGvDQ=\ngo.opentelemetry.io/contrib/detectors/gcp v1.29.0/go.mod h1:GW2aWZNwR2ZxDLdv8OyC2G8zkRoQBuURgV7RPQgcPoU=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 h1:r6I7RJCN86bpD/FQwedZ0vSixDpwuWREjW9oRMsmqDc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0/go.mod h1:B9yO6b04uB80CzjedvewuqDhxJxi11s7/GtiGa8bAjI=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 h1:TT4fX+nBOA/+LUkobKGW1ydGcn+G3vRw9+g5HwCphpk=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0/go.mod h1:L7UH0GbB0p47T4Rri3uHjbpCFYrVrwc1I25QhNPiGK8=\ngo.opentelemetry.io/otel v1.29.0 h1:PdomN/Al4q/lN6iBJEN3AwPvUiHPMlt93c8bqTG5Llw=\ngo.opentelemetry.io/otel v1.29.0/go.mod h1:N/WtXPs1CNCUEx+Agz5uouwCba+i+bJGFicT8SR4NP8=\ngo.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.29.0 h1:WDdP9acbMYjbKIyJUhTvtzj601sVJOqgWdUxSdR/Ysc=\ngo.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.29.0/go.mod h1:BLbf7zbNIONBLPwvFnwNHGj4zge8uTCM/UPIVW1Mq2I=\ngo.opentelemetry.io/otel/metric v1.29.0 h1:vPf/HFWTNkPu1aYeIsc98l4ktOQaL6LeSoeV2g+8YLc=\ngo.opentelemetry.io/otel/metric v1.29.0/go.mod h1:auu/QWieFVWx+DmQOUMgj0F8LHWdgalxXqvp7BII/W8=\ngo.opentelemetry.io/otel/sdk v1.29.0 h1:vkqKjk7gwhS8VaWb0POZKmIEDimRCMsopNYnriHyryo=\ngo.opentelemetry.io/otel/sdk v1.29.0/go.mod h1:pM8Dx5WKnvxLCb+8lG1PRNIDxu9g9b9g59Qr7hfAAok=\ngo.opentelemetry.io/otel/sdk/metric v1.29.0 h1:K2CfmJohnRgvZ9UAj2/FhIf/okdWcNdBwe1m8xFXiSY=\ngo.opentelemetry.io/otel/sdk/metric v1.29.0/go.mod h1:6zZLdCl2fkauYoZIOn/soQIDSWFmNSRcICarHfuhNJQ=\ngo.opentelemetry.io/otel/trace v1.29.0 h1:J/8ZNK4XgR7a21DZUAsbF8pZ5Jcw1VhACmnYt39JTi4=\ngo.opentelemetry.io/otel/trace v1.29.0/go.mod h1:eHl3w0sp3paPkYstJOmAimxhiFXPg+MMTlEh3nsQgWQ=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.17.0/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=\ngolang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=\ngolang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.25.0 h1:CY4y7XT9v0cRI9oupztF8AgiIu99L/ksR/Xp/6jrZ70=\ngolang.org/x/oauth2 v0.25.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.15.0/go.mod h1:BDl952bC7+uMoWR75FIrCDx79TPU9oHkTZ9yRbYOrX0=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.8.0 h1:9i3RxcPv3PZnitoVGMPDKZSq1xW1gK1Xy3ArNOGZfEg=\ngolang.org/x/time v0.8.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.215.0 h1:jdYF4qnyczlEz2ReWIsosNLDuzXyvFHJtI5gcr0J7t0=\ngoogle.golang.org/api v0.215.0/go.mod h1:fta3CVtuJYOEdugLNWm6WodzOS8KdFckABwN4I40hzY=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697 h1:ToEetK57OidYuqD4Q5w+vfEnPvPpuTwedCNVohYJfNk=\ngoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697/go.mod h1:JJrvXBWRZaFMxBufik1a4RpFw4HhgVtBBWQeQgUj2cc=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576 h1:CkkIfIt50+lT6NHAVoRYEyAvQGFM7xEwXUUywFvEb3Q=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576/go.mod h1:1R3kvZ1dtP3+4p4d3G8uJ8rFk/fWlScl38vanWACI08=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241223144023-3abc09e42ca8 h1:TqExAhdPaB60Ux47Cn0oLV07rGnxZzIsaRhQaqS666A=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241223144023-3abc09e42ca8/go.mod h1:lcTa1sDdWEIHMWlITnIczmw5w60CF9ffkb8Z+DVmmjA=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=\ngoogle.golang.org/grpc v1.67.3 h1:OgPcDAFKHnH8X3O4WcO4XUc8GRDeKsKReqbQtiCj7N8=\ngoogle.golang.org/grpc v1.67.3/go.mod h1:YGaHCc6Oap+FzBJTZLBzkGSYt/cvGPFTPxkn7QfSU8s=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "httpFs.go",
          "type": "blob",
          "size": 2.6640625,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype httpDir struct {\n\tbasePath string\n\tfs       HttpFs\n}\n\nfunc (d httpDir) Open(name string) (http.File, error) {\n\tif filepath.Separator != '/' && strings.ContainsRune(name, filepath.Separator) ||\n\t\tstrings.Contains(name, \"\\x00\") {\n\t\treturn nil, errors.New(\"http: invalid character in file path\")\n\t}\n\tdir := string(d.basePath)\n\tif dir == \"\" {\n\t\tdir = \".\"\n\t}\n\n\tf, err := d.fs.Open(filepath.Join(dir, filepath.FromSlash(path.Clean(\"/\"+name))))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\ntype HttpFs struct {\n\tsource Fs\n}\n\nfunc NewHttpFs(source Fs) *HttpFs {\n\treturn &HttpFs{source: source}\n}\n\nfunc (h HttpFs) Dir(s string) *httpDir {\n\treturn &httpDir{basePath: s, fs: h}\n}\n\nfunc (h HttpFs) Name() string { return \"h HttpFs\" }\n\nfunc (h HttpFs) Create(name string) (File, error) {\n\treturn h.source.Create(name)\n}\n\nfunc (h HttpFs) Chmod(name string, mode os.FileMode) error {\n\treturn h.source.Chmod(name, mode)\n}\n\nfunc (h HttpFs) Chown(name string, uid, gid int) error {\n\treturn h.source.Chown(name, uid, gid)\n}\n\nfunc (h HttpFs) Chtimes(name string, atime time.Time, mtime time.Time) error {\n\treturn h.source.Chtimes(name, atime, mtime)\n}\n\nfunc (h HttpFs) Mkdir(name string, perm os.FileMode) error {\n\treturn h.source.Mkdir(name, perm)\n}\n\nfunc (h HttpFs) MkdirAll(path string, perm os.FileMode) error {\n\treturn h.source.MkdirAll(path, perm)\n}\n\nfunc (h HttpFs) Open(name string) (http.File, error) {\n\tf, err := h.source.Open(name)\n\tif err == nil {\n\t\tif httpfile, ok := f.(http.File); ok {\n\t\t\treturn httpfile, nil\n\t\t}\n\t}\n\treturn nil, err\n}\n\nfunc (h HttpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\treturn h.source.OpenFile(name, flag, perm)\n}\n\nfunc (h HttpFs) Remove(name string) error {\n\treturn h.source.Remove(name)\n}\n\nfunc (h HttpFs) RemoveAll(path string) error {\n\treturn h.source.RemoveAll(path)\n}\n\nfunc (h HttpFs) Rename(oldname, newname string) error {\n\treturn h.source.Rename(oldname, newname)\n}\n\nfunc (h HttpFs) Stat(name string) (os.FileInfo, error) {\n\treturn h.source.Stat(name)\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "iofs.go",
          "type": "blob",
          "size": 6.390625,
          "content": "//go:build go1.16\n// +build go1.16\n\npackage afero\n\nimport (\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/spf13/afero/internal/common\"\n)\n\n// IOFS adopts afero.Fs to stdlib io/fs.FS\ntype IOFS struct {\n\tFs\n}\n\nfunc NewIOFS(fs Fs) IOFS {\n\treturn IOFS{Fs: fs}\n}\n\nvar (\n\t_ fs.FS         = IOFS{}\n\t_ fs.GlobFS     = IOFS{}\n\t_ fs.ReadDirFS  = IOFS{}\n\t_ fs.ReadFileFS = IOFS{}\n\t_ fs.StatFS     = IOFS{}\n\t_ fs.SubFS      = IOFS{}\n)\n\nfunc (iofs IOFS) Open(name string) (fs.File, error) {\n\tconst op = \"open\"\n\n\t// by convention for fs.FS implementations we should perform this check\n\tif !fs.ValidPath(name) {\n\t\treturn nil, iofs.wrapError(op, name, fs.ErrInvalid)\n\t}\n\n\tfile, err := iofs.Fs.Open(name)\n\tif err != nil {\n\t\treturn nil, iofs.wrapError(op, name, err)\n\t}\n\n\t// file should implement fs.ReadDirFile\n\tif _, ok := file.(fs.ReadDirFile); !ok {\n\t\tfile = readDirFile{file}\n\t}\n\n\treturn file, nil\n}\n\nfunc (iofs IOFS) Glob(pattern string) ([]string, error) {\n\tconst op = \"glob\"\n\n\t// afero.Glob does not perform this check but it's required for implementations\n\tif _, err := path.Match(pattern, \"\"); err != nil {\n\t\treturn nil, iofs.wrapError(op, pattern, err)\n\t}\n\n\titems, err := Glob(iofs.Fs, pattern)\n\tif err != nil {\n\t\treturn nil, iofs.wrapError(op, pattern, err)\n\t}\n\n\treturn items, nil\n}\n\nfunc (iofs IOFS) ReadDir(name string) ([]fs.DirEntry, error) {\n\tf, err := iofs.Fs.Open(name)\n\tif err != nil {\n\t\treturn nil, iofs.wrapError(\"readdir\", name, err)\n\t}\n\n\tdefer f.Close()\n\n\tif rdf, ok := f.(fs.ReadDirFile); ok {\n\t\titems, err := rdf.ReadDir(-1)\n\t\tif err != nil {\n\t\t\treturn nil, iofs.wrapError(\"readdir\", name, err)\n\t\t}\n\t\tsort.Slice(items, func(i, j int) bool { return items[i].Name() < items[j].Name() })\n\t\treturn items, nil\n\t}\n\n\titems, err := f.Readdir(-1)\n\tif err != nil {\n\t\treturn nil, iofs.wrapError(\"readdir\", name, err)\n\t}\n\tsort.Sort(byName(items))\n\n\tret := make([]fs.DirEntry, len(items))\n\tfor i := range items {\n\t\tret[i] = common.FileInfoDirEntry{FileInfo: items[i]}\n\t}\n\n\treturn ret, nil\n}\n\nfunc (iofs IOFS) ReadFile(name string) ([]byte, error) {\n\tconst op = \"readfile\"\n\n\tif !fs.ValidPath(name) {\n\t\treturn nil, iofs.wrapError(op, name, fs.ErrInvalid)\n\t}\n\n\tbytes, err := ReadFile(iofs.Fs, name)\n\tif err != nil {\n\t\treturn nil, iofs.wrapError(op, name, err)\n\t}\n\n\treturn bytes, nil\n}\n\nfunc (iofs IOFS) Sub(dir string) (fs.FS, error) { return IOFS{NewBasePathFs(iofs.Fs, dir)}, nil }\n\nfunc (IOFS) wrapError(op, path string, err error) error {\n\tif _, ok := err.(*fs.PathError); ok {\n\t\treturn err // don't need to wrap again\n\t}\n\n\treturn &fs.PathError{\n\t\tOp:   op,\n\t\tPath: path,\n\t\tErr:  err,\n\t}\n}\n\n// readDirFile provides adapter from afero.File to fs.ReadDirFile needed for correct Open\ntype readDirFile struct {\n\tFile\n}\n\nvar _ fs.ReadDirFile = readDirFile{}\n\nfunc (r readDirFile) ReadDir(n int) ([]fs.DirEntry, error) {\n\titems, err := r.File.Readdir(n)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret := make([]fs.DirEntry, len(items))\n\tfor i := range items {\n\t\tret[i] = common.FileInfoDirEntry{FileInfo: items[i]}\n\t}\n\n\treturn ret, nil\n}\n\n// FromIOFS adopts io/fs.FS to use it as afero.Fs\n// Note that io/fs.FS is read-only so all mutating methods will return fs.PathError with fs.ErrPermission\n// To store modifications you may use afero.CopyOnWriteFs\ntype FromIOFS struct {\n\tfs.FS\n}\n\nvar _ Fs = FromIOFS{}\n\nfunc (f FromIOFS) Create(name string) (File, error) { return nil, notImplemented(\"create\", name) }\n\nfunc (f FromIOFS) Mkdir(name string, perm os.FileMode) error { return notImplemented(\"mkdir\", name) }\n\nfunc (f FromIOFS) MkdirAll(path string, perm os.FileMode) error {\n\treturn notImplemented(\"mkdirall\", path)\n}\n\nfunc (f FromIOFS) Open(name string) (File, error) {\n\tfile, err := f.FS.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fromIOFSFile{File: file, name: name}, nil\n}\n\nfunc (f FromIOFS) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\treturn f.Open(name)\n}\n\nfunc (f FromIOFS) Remove(name string) error {\n\treturn notImplemented(\"remove\", name)\n}\n\nfunc (f FromIOFS) RemoveAll(path string) error {\n\treturn notImplemented(\"removeall\", path)\n}\n\nfunc (f FromIOFS) Rename(oldname, newname string) error {\n\treturn notImplemented(\"rename\", oldname)\n}\n\nfunc (f FromIOFS) Stat(name string) (os.FileInfo, error) { return fs.Stat(f.FS, name) }\n\nfunc (f FromIOFS) Name() string { return \"fromiofs\" }\n\nfunc (f FromIOFS) Chmod(name string, mode os.FileMode) error {\n\treturn notImplemented(\"chmod\", name)\n}\n\nfunc (f FromIOFS) Chown(name string, uid, gid int) error {\n\treturn notImplemented(\"chown\", name)\n}\n\nfunc (f FromIOFS) Chtimes(name string, atime time.Time, mtime time.Time) error {\n\treturn notImplemented(\"chtimes\", name)\n}\n\ntype fromIOFSFile struct {\n\tfs.File\n\tname string\n}\n\nfunc (f fromIOFSFile) ReadAt(p []byte, off int64) (n int, err error) {\n\treaderAt, ok := f.File.(io.ReaderAt)\n\tif !ok {\n\t\treturn -1, notImplemented(\"readat\", f.name)\n\t}\n\n\treturn readerAt.ReadAt(p, off)\n}\n\nfunc (f fromIOFSFile) Seek(offset int64, whence int) (int64, error) {\n\tseeker, ok := f.File.(io.Seeker)\n\tif !ok {\n\t\treturn -1, notImplemented(\"seek\", f.name)\n\t}\n\n\treturn seeker.Seek(offset, whence)\n}\n\nfunc (f fromIOFSFile) Write(p []byte) (n int, err error) {\n\treturn -1, notImplemented(\"write\", f.name)\n}\n\nfunc (f fromIOFSFile) WriteAt(p []byte, off int64) (n int, err error) {\n\treturn -1, notImplemented(\"writeat\", f.name)\n}\n\nfunc (f fromIOFSFile) Name() string { return f.name }\n\nfunc (f fromIOFSFile) Readdir(count int) ([]os.FileInfo, error) {\n\trdfile, ok := f.File.(fs.ReadDirFile)\n\tif !ok {\n\t\treturn nil, notImplemented(\"readdir\", f.name)\n\t}\n\n\tentries, err := rdfile.ReadDir(count)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret := make([]os.FileInfo, len(entries))\n\tfor i := range entries {\n\t\tret[i], err = entries[i].Info()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn ret, nil\n}\n\nfunc (f fromIOFSFile) Readdirnames(n int) ([]string, error) {\n\trdfile, ok := f.File.(fs.ReadDirFile)\n\tif !ok {\n\t\treturn nil, notImplemented(\"readdir\", f.name)\n\t}\n\n\tentries, err := rdfile.ReadDir(n)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret := make([]string, len(entries))\n\tfor i := range entries {\n\t\tret[i] = entries[i].Name()\n\t}\n\n\treturn ret, nil\n}\n\nfunc (f fromIOFSFile) Sync() error { return nil }\n\nfunc (f fromIOFSFile) Truncate(size int64) error {\n\treturn notImplemented(\"truncate\", f.name)\n}\n\nfunc (f fromIOFSFile) WriteString(s string) (ret int, err error) {\n\treturn -1, notImplemented(\"writestring\", f.name)\n}\n\nfunc notImplemented(op, path string) error {\n\treturn &fs.PathError{Op: op, Path: path, Err: fs.ErrPermission}\n}\n"
        },
        {
          "name": "iofs_test.go",
          "type": "blob",
          "size": 11.58984375,
          "content": "//go:build go1.16\n// +build go1.16\n\npackage afero\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"testing/fstest\"\n\t\"time\"\n\n\t\"github.com/spf13/afero/internal/common\"\n)\n\nfunc TestIOFS(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\t// TODO(bep): some of the \"bad path\" tests in fstest.TestFS fail on Windows\n\t\tt.Skip(\"Skipping on Windows\")\n\t}\n\tt.Parallel()\n\n\tt.Run(\"use MemMapFs\", func(t *testing.T) {\n\t\tmmfs := NewMemMapFs()\n\n\t\terr := mmfs.MkdirAll(\"dir1/dir2\", os.ModePerm)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"MkdirAll failed:\", err)\n\t\t}\n\n\t\tf, err := mmfs.OpenFile(\"dir1/dir2/test.txt\", os.O_RDWR|os.O_CREATE, os.ModePerm)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"OpenFile (O_CREATE) failed:\", err)\n\t\t}\n\n\t\tf.Close()\n\n\t\tif err := fstest.TestFS(NewIOFS(mmfs), \"dir1/dir2/test.txt\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\tt.Run(\"use OsFs\", func(t *testing.T) {\n\t\tosfs := NewBasePathFs(NewOsFs(), t.TempDir())\n\n\t\terr := osfs.MkdirAll(\"dir1/dir2\", os.ModePerm)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"MkdirAll failed:\", err)\n\t\t}\n\n\t\tf, err := osfs.OpenFile(\"dir1/dir2/test.txt\", os.O_RDWR|os.O_CREATE, os.ModePerm)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"OpenFile (O_CREATE) failed:\", err)\n\t\t}\n\n\t\tf.Close()\n\n\t\tif err := fstest.TestFS(NewIOFS(osfs), \"dir1/dir2/test.txt\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n}\n\nfunc TestIOFSNativeDirEntryWhenPossible(t *testing.T) {\n\tt.Parallel()\n\n\tosfs := NewBasePathFs(NewOsFs(), t.TempDir())\n\n\terr := osfs.MkdirAll(\"dir1/dir2\", os.ModePerm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst numFiles = 10\n\n\tvar fileNumbers []int\n\tfor i := 0; i < numFiles; i++ {\n\t\tfileNumbers = append(fileNumbers, i)\n\t}\n\trand.Shuffle(len(fileNumbers), func(i, j int) {\n\t\tfileNumbers[i], fileNumbers[j] = fileNumbers[j], fileNumbers[i]\n\t})\n\n\tfor _, i := range fileNumbers {\n\t\tf, err := osfs.Create(fmt.Sprintf(\"dir1/dir2/test%d.txt\", i))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tf.Close()\n\t}\n\n\tdir2, err := osfs.Open(\"dir1/dir2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer dir2.Close()\n\n\tassertDirEntries := func(entries []fs.DirEntry, ordered bool) {\n\t\tif len(entries) != numFiles {\n\t\t\tt.Fatalf(\"expected %d, got %d\", numFiles, len(entries))\n\t\t}\n\t\tfor i, entry := range entries {\n\t\t\tif _, ok := entry.(common.FileInfoDirEntry); ok {\n\t\t\t\tt.Fatal(\"DirEntry not native\")\n\t\t\t}\n\t\t\tif ordered && entry.Name() != fmt.Sprintf(\"test%d.txt\", i) {\n\t\t\t\tt.Fatalf(\"expected %s, got %s\", fmt.Sprintf(\"test%d.txt\", i), entry.Name())\n\t\t\t}\n\t\t}\n\t}\n\n\tdirEntries, err := dir2.(fs.ReadDirFile).ReadDir(-1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassertDirEntries(dirEntries, false)\n\n\tiofs := NewIOFS(osfs)\n\n\tdirEntries, err = iofs.ReadDir(\"dir1/dir2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassertDirEntries(dirEntries, true)\n\n\tfileCount := 0\n\terr = fs.WalkDir(iofs, \"\", func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !d.IsDir() {\n\t\t\tfileCount++\n\t\t}\n\n\t\tif _, ok := d.(common.FileInfoDirEntry); ok {\n\t\t\tt.Fatal(\"DirEntry not native\")\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif fileCount != numFiles {\n\t\tt.Fatalf(\"expected %d, got %d\", numFiles, fileCount)\n\t}\n}\n\nfunc TestFromIOFS(t *testing.T) {\n\tt.Parallel()\n\n\tfsys := fstest.MapFS{\n\t\t\"test.txt\": {\n\t\t\tData:    []byte(\"File in root\"),\n\t\t\tMode:    fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t\t\"dir1\": {\n\t\t\tMode:    fs.ModeDir | fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t\t\"dir1/dir2\": {\n\t\t\tMode:    fs.ModeDir | fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t\t\"dir1/dir2/hello.txt\": {\n\t\t\tData:    []byte(\"Hello world\"),\n\t\t\tMode:    fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t}\n\n\tfromIOFS := FromIOFS{fsys}\n\n\tt.Run(\"Create\", func(t *testing.T) {\n\t\t_, err := fromIOFS.Create(\"test\")\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Mkdir\", func(t *testing.T) {\n\t\terr := fromIOFS.Mkdir(\"test\", 0)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"MkdirAll\", func(t *testing.T) {\n\t\terr := fromIOFS.Mkdir(\"test\", 0)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Open\", func(t *testing.T) {\n\t\tt.Run(\"non existing file\", func(t *testing.T) {\n\t\t\t_, err := fromIOFS.Open(\"nonexisting\")\n\t\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\t\tt.Errorf(\"Expected error to be fs.ErrNotExist, got %[1]T (%[1]v)\", err)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"directory\", func(t *testing.T) {\n\t\t\tdirFile, err := fromIOFS.Open(\"dir1\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"dir1 open failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer dirFile.Close()\n\n\t\t\tdirStat, err := dirFile.Stat()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"dir1 stat failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !dirStat.IsDir() {\n\t\t\t\tt.Errorf(\"dir1 stat told that it is not a directory\")\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"simple file\", func(t *testing.T) {\n\t\t\tfile, err := fromIOFS.Open(\"test.txt\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"test.txt open failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer file.Close()\n\n\t\t\tfileStat, err := file.Stat()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"test.txt stat failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif fileStat.IsDir() {\n\t\t\t\tt.Errorf(\"test.txt stat told that it is a directory\")\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Remove\", func(t *testing.T) {\n\t\terr := fromIOFS.Remove(\"test\")\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Rename\", func(t *testing.T) {\n\t\terr := fromIOFS.Rename(\"test\", \"test2\")\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Stat\", func(t *testing.T) {\n\t\tt.Run(\"non existing file\", func(t *testing.T) {\n\t\t\t_, err := fromIOFS.Stat(\"nonexisting\")\n\t\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\t\tt.Errorf(\"Expected error to be fs.ErrNotExist, got %[1]T (%[1]v)\", err)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"directory\", func(t *testing.T) {\n\t\t\tstat, err := fromIOFS.Stat(\"dir1/dir2\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"dir1/dir2 stat failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !stat.IsDir() {\n\t\t\t\tt.Errorf(\"dir1/dir2 stat told that it is not a directory\")\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"file\", func(t *testing.T) {\n\t\t\tstat, err := fromIOFS.Stat(\"dir1/dir2/hello.txt\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"dir1/dir2 stat failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif stat.IsDir() {\n\t\t\t\tt.Errorf(\"dir1/dir2/hello.txt stat told that it is a directory\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif lenFile := len(fsys[\"dir1/dir2/hello.txt\"].Data); int64(lenFile) != stat.Size() {\n\t\t\t\tt.Errorf(\"dir1/dir2/hello.txt stat told invalid size: expected %d, got %d\", lenFile, stat.Size())\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Chmod\", func(t *testing.T) {\n\t\terr := fromIOFS.Chmod(\"test\", os.ModePerm)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Chown\", func(t *testing.T) {\n\t\terr := fromIOFS.Chown(\"test\", 0, 0)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Chtimes\", func(t *testing.T) {\n\t\terr := fromIOFS.Chtimes(\"test\", time.Now(), time.Now())\n\t\tassertPermissionError(t, err)\n\t})\n}\n\nfunc TestFromIOFS_File(t *testing.T) {\n\tt.Parallel()\n\n\tfsys := fstest.MapFS{\n\t\t\"test.txt\": {\n\t\t\tData:    []byte(\"File in root\"),\n\t\t\tMode:    fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t\t\"dir1\": {\n\t\t\tMode:    fs.ModeDir | fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t\t\"dir2\": {\n\t\t\tMode:    fs.ModeDir | fs.ModePerm,\n\t\t\tModTime: time.Now(),\n\t\t},\n\t}\n\n\tfromIOFS := FromIOFS{fsys}\n\n\tfile, err := fromIOFS.Open(\"test.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"test.txt open failed: %v\", err)\n\t\treturn\n\t}\n\n\tdefer file.Close()\n\n\tfileStat, err := file.Stat()\n\tif err != nil {\n\t\tt.Errorf(\"test.txt stat failed: %v\", err)\n\t\treturn\n\t}\n\n\tif fileStat.IsDir() {\n\t\tt.Errorf(\"test.txt stat told that it is a directory\")\n\t\treturn\n\t}\n\n\tt.Run(\"ReadAt\", func(t *testing.T) {\n\t\t// MapFS files implements io.ReaderAt\n\t\tb := make([]byte, 2)\n\t\t_, err := file.ReadAt(b, 2)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"ReadAt failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif expectedData := fsys[\"test.txt\"].Data[2:4]; !bytes.Equal(b, expectedData) {\n\t\t\tt.Errorf(\"Unexpected content read: %s, expected %s\", b, expectedData)\n\t\t}\n\t})\n\n\tt.Run(\"Seek\", func(t *testing.T) {\n\t\tn, err := file.Seek(2, io.SeekStart)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Seek failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif n != 2 {\n\t\t\tt.Errorf(\"Seek returned unexpected value: %d, expected 2\", n)\n\t\t}\n\t})\n\n\tt.Run(\"Write\", func(t *testing.T) {\n\t\t_, err := file.Write(nil)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"WriteAt\", func(t *testing.T) {\n\t\t_, err := file.WriteAt(nil, 0)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"Name\", func(t *testing.T) {\n\t\tif name := file.Name(); name != \"test.txt\" {\n\t\t\tt.Errorf(\"expected file.Name() == test.txt, got %s\", name)\n\t\t}\n\t})\n\n\tt.Run(\"Readdir\", func(t *testing.T) {\n\t\tt.Run(\"not directory\", func(t *testing.T) {\n\t\t\t_, err := file.Readdir(-1)\n\t\t\tassertPermissionError(t, err)\n\t\t})\n\n\t\tt.Run(\"root directory\", func(t *testing.T) {\n\t\t\troot, err := fromIOFS.Open(\".\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"root open failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer root.Close()\n\n\t\t\titems, err := root.Readdir(-1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Readdir error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\texpectedItems := []struct {\n\t\t\t\tName  string\n\t\t\t\tIsDir bool\n\t\t\t\tSize  int64\n\t\t\t}{\n\t\t\t\t{Name: \"dir1\", IsDir: true, Size: 0},\n\t\t\t\t{Name: \"dir2\", IsDir: true, Size: 0},\n\t\t\t\t{Name: \"test.txt\", IsDir: false, Size: int64(len(fsys[\"test.txt\"].Data))},\n\t\t\t}\n\n\t\t\tif len(expectedItems) != len(items) {\n\t\t\t\tt.Errorf(\"Items count mismatch, expected %d, got %d\", len(expectedItems), len(items))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor i, item := range items {\n\t\t\t\tif item.Name() != expectedItems[i].Name {\n\t\t\t\t\tt.Errorf(\"Item %d: expected name %s, got %s\", i, expectedItems[i].Name, item.Name())\n\t\t\t\t}\n\n\t\t\t\tif item.IsDir() != expectedItems[i].IsDir {\n\t\t\t\t\tt.Errorf(\"Item %d: expected IsDir %t, got %t\", i, expectedItems[i].IsDir, item.IsDir())\n\t\t\t\t}\n\n\t\t\t\tif item.Size() != expectedItems[i].Size {\n\t\t\t\t\tt.Errorf(\"Item %d: expected IsDir %d, got %d\", i, expectedItems[i].Size, item.Size())\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Readdirnames\", func(t *testing.T) {\n\t\tt.Run(\"not directory\", func(t *testing.T) {\n\t\t\t_, err := file.Readdirnames(-1)\n\t\t\tassertPermissionError(t, err)\n\t\t})\n\n\t\tt.Run(\"root directory\", func(t *testing.T) {\n\t\t\troot, err := fromIOFS.Open(\".\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"root open failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer root.Close()\n\n\t\t\titems, err := root.Readdirnames(-1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Readdirnames error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\texpectedItems := []string{\"dir1\", \"dir2\", \"test.txt\"}\n\n\t\t\tif len(expectedItems) != len(items) {\n\t\t\t\tt.Errorf(\"Items count mismatch, expected %d, got %d\", len(expectedItems), len(items))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor i, item := range items {\n\t\t\t\tif item != expectedItems[i] {\n\t\t\t\t\tt.Errorf(\"Item %d: expected name %s, got %s\", i, expectedItems[i], item)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Truncate\", func(t *testing.T) {\n\t\terr := file.Truncate(1)\n\t\tassertPermissionError(t, err)\n\t})\n\n\tt.Run(\"WriteString\", func(t *testing.T) {\n\t\t_, err := file.WriteString(\"a\")\n\t\tassertPermissionError(t, err)\n\t})\n}\n\nfunc assertPermissionError(t *testing.T, err error) {\n\tt.Helper()\n\n\tvar perr *fs.PathError\n\tif !errors.As(err, &perr) {\n\t\tt.Errorf(\"Expected *fs.PathError, got %[1]T (%[1]v)\", err)\n\t\treturn\n\t}\n\n\tif perr.Err != fs.ErrPermission {\n\t\tt.Errorf(\"Expected (*fs.PathError).Err == fs.ErrPermisson, got %[1]T (%[1]v)\", err)\n\t}\n}\n\nfunc BenchmarkWalkDir(b *testing.B) {\n\tosfs := NewBasePathFs(NewOsFs(), b.TempDir())\n\n\tcreateSomeFiles := func(dirname string) {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tf, err := osfs.Create(filepath.Join(dirname, fmt.Sprintf(\"test%d.txt\", i)))\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tf.Close()\n\t\t}\n\t}\n\n\tdepth := 10\n\tfor level := depth; level > 0; level-- {\n\t\tdirname := \"\"\n\t\tfor i := 0; i < level; i++ {\n\t\t\tdirname = filepath.Join(dirname, fmt.Sprintf(\"dir%d\", i))\n\t\t\terr := osfs.MkdirAll(dirname, 0o755)\n\t\t\tif err != nil && !os.IsExist(err) {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tcreateSomeFiles(dirname)\n\t}\n\n\tiofs := NewIOFS(osfs)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr := fs.WalkDir(iofs, \"\", func(path string, d fs.DirEntry, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ioutil.go",
          "type": "blob",
          "size": 6.9638671875,
          "content": "// Copyright ©2015 The Go Authors\n// Copyright ©2015 Steve Francia <spf@spf13.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// byName implements sort.Interface.\ntype byName []os.FileInfo\n\nfunc (f byName) Len() int           { return len(f) }\nfunc (f byName) Less(i, j int) bool { return f[i].Name() < f[j].Name() }\nfunc (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n\n// ReadDir reads the directory named by dirname and returns\n// a list of sorted directory entries.\nfunc (a Afero) ReadDir(dirname string) ([]os.FileInfo, error) {\n\treturn ReadDir(a.Fs, dirname)\n}\n\nfunc ReadDir(fs Fs, dirname string) ([]os.FileInfo, error) {\n\tf, err := fs.Open(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, err := f.Readdir(-1)\n\tf.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsort.Sort(byName(list))\n\treturn list, nil\n}\n\n// ReadFile reads the file named by filename and returns the contents.\n// A successful call returns err == nil, not err == EOF. Because ReadFile\n// reads the whole file, it does not treat an EOF from Read as an error\n// to be reported.\nfunc (a Afero) ReadFile(filename string) ([]byte, error) {\n\treturn ReadFile(a.Fs, filename)\n}\n\nfunc ReadFile(fs Fs, filename string) ([]byte, error) {\n\tf, err := fs.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\t// It's a good but not certain bet that FileInfo will tell us exactly how much to\n\t// read, so let's try it but be prepared for the answer to be wrong.\n\tvar n int64\n\n\tif fi, err := f.Stat(); err == nil {\n\t\t// Don't preallocate a huge buffer, just in case.\n\t\tif size := fi.Size(); size < 1e9 {\n\t\t\tn = size\n\t\t}\n\t}\n\t// As initial capacity for readAll, use n + a little extra in case Size is zero,\n\t// and to avoid another allocation after Read has filled the buffer.  The readAll\n\t// call will read into its allocated internal buffer cheaply.  If the size was\n\t// wrong, we'll either waste some space off the end or reallocate as needed, but\n\t// in the overwhelmingly common case we'll get it just right.\n\treturn readAll(f, n+bytes.MinRead)\n}\n\n// readAll reads from r until an error or EOF and returns the data it read\n// from the internal buffer allocated with a specified capacity.\nfunc readAll(r io.Reader, capacity int64) (b []byte, err error) {\n\tbuf := bytes.NewBuffer(make([]byte, 0, capacity))\n\t// If the buffer overflows, we will get bytes.ErrTooLarge.\n\t// Return that as an error. Any other panic remains.\n\tdefer func() {\n\t\te := recover()\n\t\tif e == nil {\n\t\t\treturn\n\t\t}\n\t\tif panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {\n\t\t\terr = panicErr\n\t\t} else {\n\t\t\tpanic(e)\n\t\t}\n\t}()\n\t_, err = buf.ReadFrom(r)\n\treturn buf.Bytes(), err\n}\n\n// ReadAll reads from r until an error or EOF and returns the data it read.\n// A successful call returns err == nil, not err == EOF. Because ReadAll is\n// defined to read from src until EOF, it does not treat an EOF from Read\n// as an error to be reported.\nfunc ReadAll(r io.Reader) ([]byte, error) {\n\treturn readAll(r, bytes.MinRead)\n}\n\n// WriteFile writes data to a file named by filename.\n// If the file does not exist, WriteFile creates it with permissions perm;\n// otherwise WriteFile truncates it before writing.\nfunc (a Afero) WriteFile(filename string, data []byte, perm os.FileMode) error {\n\treturn WriteFile(a.Fs, filename, data, perm)\n}\n\nfunc WriteFile(fs Fs, filename string, data []byte, perm os.FileMode) error {\n\tf, err := fs.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tn, err := f.Write(data)\n\tif err == nil && n < len(data) {\n\t\terr = io.ErrShortWrite\n\t}\n\tif err1 := f.Close(); err == nil {\n\t\terr = err1\n\t}\n\treturn err\n}\n\n// Random number state.\n// We generate random temporary file names so that there's a good\n// chance the file doesn't exist yet - keeps the number of tries in\n// TempFile to a minimum.\nvar (\n\trandNum uint32\n\trandmu  sync.Mutex\n)\n\nfunc reseed() uint32 {\n\treturn uint32(time.Now().UnixNano() + int64(os.Getpid()))\n}\n\nfunc nextRandom() string {\n\trandmu.Lock()\n\tr := randNum\n\tif r == 0 {\n\t\tr = reseed()\n\t}\n\tr = r*1664525 + 1013904223 // constants from Numerical Recipes\n\trandNum = r\n\trandmu.Unlock()\n\treturn strconv.Itoa(int(1e9 + r%1e9))[1:]\n}\n\n// TempFile creates a new temporary file in the directory dir,\n// opens the file for reading and writing, and returns the resulting *os.File.\n// The filename is generated by taking pattern and adding a random\n// string to the end. If pattern includes a \"*\", the random string\n// replaces the last \"*\".\n// If dir is the empty string, TempFile uses the default directory\n// for temporary files (see os.TempDir).\n// Multiple programs calling TempFile simultaneously\n// will not choose the same file. The caller can use f.Name()\n// to find the pathname of the file. It is the caller's responsibility\n// to remove the file when no longer needed.\nfunc (a Afero) TempFile(dir, pattern string) (f File, err error) {\n\treturn TempFile(a.Fs, dir, pattern)\n}\n\nfunc TempFile(fs Fs, dir, pattern string) (f File, err error) {\n\tif dir == \"\" {\n\t\tdir = os.TempDir()\n\t}\n\n\tvar prefix, suffix string\n\tif pos := strings.LastIndex(pattern, \"*\"); pos != -1 {\n\t\tprefix, suffix = pattern[:pos], pattern[pos+1:]\n\t} else {\n\t\tprefix = pattern\n\t}\n\n\tnconflict := 0\n\tfor i := 0; i < 10000; i++ {\n\t\tname := filepath.Join(dir, prefix+nextRandom()+suffix)\n\t\tf, err = fs.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0o600)\n\t\tif os.IsExist(err) {\n\t\t\tif nconflict++; nconflict > 10 {\n\t\t\t\trandmu.Lock()\n\t\t\t\trandNum = reseed()\n\t\t\t\trandmu.Unlock()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}\n\n// TempDir creates a new temporary directory in the directory dir\n// with a name beginning with prefix and returns the path of the\n// new directory.  If dir is the empty string, TempDir uses the\n// default directory for temporary files (see os.TempDir).\n// Multiple programs calling TempDir simultaneously\n// will not choose the same directory.  It is the caller's responsibility\n// to remove the directory when no longer needed.\nfunc (a Afero) TempDir(dir, prefix string) (name string, err error) {\n\treturn TempDir(a.Fs, dir, prefix)\n}\n\nfunc TempDir(fs Fs, dir, prefix string) (name string, err error) {\n\tif dir == \"\" {\n\t\tdir = os.TempDir()\n\t}\n\n\tnconflict := 0\n\tfor i := 0; i < 10000; i++ {\n\t\ttry := filepath.Join(dir, prefix+nextRandom())\n\t\terr = fs.Mkdir(try, 0o700)\n\t\tif os.IsExist(err) {\n\t\t\tif nconflict++; nconflict > 10 {\n\t\t\t\trandmu.Lock()\n\t\t\t\trandNum = reseed()\n\t\t\t\trandmu.Unlock()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tname = try\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}\n"
        },
        {
          "name": "ioutil_test.go",
          "type": "blob",
          "size": 4.4326171875,
          "content": "// ©2015 The Go Authors\n// Copyright ©2015 Steve Francia <spf@spf13.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc checkSizePath(t *testing.T, path string, size int64) {\n\tdir, err := testFS.Stat(path)\n\tif err != nil {\n\t\tt.Fatalf(\"Stat %q (looking for size %d): %s\", path, size, err)\n\t}\n\tif dir.Size() != size {\n\t\tt.Errorf(\"Stat %q: size %d want %d\", path, dir.Size(), size)\n\t}\n}\n\nfunc TestReadFile(t *testing.T) {\n\ttestFS = &MemMapFs{}\n\tfsutil := &Afero{Fs: testFS}\n\n\ttestFS.Create(\"this_exists.go\")\n\tfilename := \"rumpelstilzchen\"\n\t_, err := fsutil.ReadFile(filename)\n\tif err == nil {\n\t\tt.Fatalf(\"ReadFile %s: error expected, none found\", filename)\n\t}\n\n\tfilename = \"this_exists.go\"\n\tcontents, err := fsutil.ReadFile(filename)\n\tif err != nil {\n\t\tt.Fatalf(\"ReadFile %s: %v\", filename, err)\n\t}\n\n\tcheckSizePath(t, filename, int64(len(contents)))\n}\n\nfunc TestWriteFile(t *testing.T) {\n\ttestFS = &MemMapFs{}\n\tfsutil := &Afero{Fs: testFS}\n\tf, err := fsutil.TempFile(\"\", \"ioutil-test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilename := f.Name()\n\tdata := \"Programming today is a race between software engineers striving to \" +\n\t\t\"build bigger and better idiot-proof programs, and the Universe trying \" +\n\t\t\"to produce bigger and better idiots. So far, the Universe is winning.\"\n\n\tif err := fsutil.WriteFile(filename, []byte(data), 0o644); err != nil {\n\t\tt.Fatalf(\"WriteFile %s: %v\", filename, err)\n\t}\n\n\tcontents, err := fsutil.ReadFile(filename)\n\tif err != nil {\n\t\tt.Fatalf(\"ReadFile %s: %v\", filename, err)\n\t}\n\n\tif string(contents) != data {\n\t\tt.Fatalf(\"contents = %q\\nexpected = %q\", string(contents), data)\n\t}\n\n\t// cleanup\n\tf.Close()\n\ttestFS.Remove(filename) // ignore error\n}\n\nfunc TestReadDir(t *testing.T) {\n\ttestFS = &MemMapFs{}\n\ttestFS.Mkdir(\"/i-am-a-dir\", 0o777)\n\ttestFS.Create(\"/this_exists.go\")\n\tdirname := \"rumpelstilzchen\"\n\t_, err := ReadDir(testFS, dirname)\n\tif err == nil {\n\t\tt.Fatalf(\"ReadDir %s: error expected, none found\", dirname)\n\t}\n\n\tdirname = \"..\"\n\tlist, err := ReadDir(testFS, dirname)\n\tif err != nil {\n\t\tt.Fatalf(\"ReadDir %s: %v\", dirname, err)\n\t}\n\n\tfoundFile := false\n\tfoundSubDir := false\n\tfor _, dir := range list {\n\t\tswitch {\n\t\tcase !dir.IsDir() && dir.Name() == \"this_exists.go\":\n\t\t\tfoundFile = true\n\t\tcase dir.IsDir() && dir.Name() == \"i-am-a-dir\":\n\t\t\tfoundSubDir = true\n\t\t}\n\t}\n\tif !foundFile {\n\t\tt.Fatalf(\"ReadDir %s: this_exists.go file not found\", dirname)\n\t}\n\tif !foundSubDir {\n\t\tt.Fatalf(\"ReadDir %s: i-am-a-dir directory not found\", dirname)\n\t}\n}\n\nfunc TestTempFile(t *testing.T) {\n\ttype args struct {\n\t\tdir     string\n\t\tpattern string\n\t}\n\ttests := map[string]struct {\n\t\targs args\n\t\twant func(*testing.T, string)\n\t}{\n\t\t\"foo\": { // simple file name\n\t\t\targs: args{\n\t\t\t\tdir:     \"\",\n\t\t\t\tpattern: \"foo\",\n\t\t\t},\n\t\t\twant: func(t *testing.T, base string) {\n\t\t\t\tif !strings.HasPrefix(base, \"foo\") || len(base) <= len(\"foo\") {\n\t\t\t\t\tt.Errorf(\"TempFile() file = %s, invalid file name\", base)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t\"foo.bar\": { // file name w/ ext\n\t\t\targs: args{\n\t\t\t\tdir:     \"\",\n\t\t\t\tpattern: \"foo.bar\",\n\t\t\t},\n\t\t\twant: func(t *testing.T, base string) {\n\t\t\t\tif !strings.HasPrefix(base, \"foo.bar\") || len(base) <= len(\"foo.bar\") {\n\t\t\t\t\tt.Errorf(\"TempFile() file = %v, invalid file name\", base)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t\"foo-*.bar\": { // file name with wild card\n\t\t\targs: args{\n\t\t\t\tdir:     \"\",\n\t\t\t\tpattern: \"foo-*.bar\",\n\t\t\t},\n\t\t\twant: func(t *testing.T, base string) {\n\t\t\t\tif !(strings.HasPrefix(base, \"foo-\") || strings.HasPrefix(base, \"bar\")) ||\n\t\t\t\t\tlen(base) <= len(\"foo-*.bar\") {\n\t\t\t\t\tt.Errorf(\"TempFile() file = %v, invalid file name\", base)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tfile, err := TempFile(NewMemMapFs(), tt.args.dir, tt.args.pattern)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"TempFile() error = %v, none expected\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif file == nil {\n\t\t\t\tt.Errorf(\"TempFile() file = %v, should not be nil\", file)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttt.want(t, filepath.Base(file.Name()))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "lstater.go",
          "type": "blob",
          "size": 1.01171875,
          "content": "// Copyright © 2018 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"os\"\n)\n\n// Lstater is an optional interface in Afero. It is only implemented by the\n// filesystems saying so.\n// It will call Lstat if the filesystem iself is, or it delegates to, the os filesystem.\n// Else it will call Stat.\n// In addtion to the FileInfo, it will return a boolean telling whether Lstat was called or not.\ntype Lstater interface {\n\tLstatIfPossible(name string) (os.FileInfo, bool, error)\n}\n"
        },
        {
          "name": "lstater_test.go",
          "type": "blob",
          "size": 2.984375,
          "content": "// Copyright ©2018 Steve Francia <spf@spf13.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestLstatIfPossible(t *testing.T) {\n\twd, _ := os.Getwd()\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\tosFs := &OsFs{}\n\n\tworkDir, err := TempDir(osFs, \"\", \"afero-lstate\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tosFs.RemoveAll(workDir)\n\t}()\n\n\tmemWorkDir := \"/lstate\"\n\n\tmemFs := NewMemMapFs()\n\toverlayFs1 := &CopyOnWriteFs{base: osFs, layer: memFs}\n\toverlayFs2 := &CopyOnWriteFs{base: memFs, layer: osFs}\n\toverlayFsMemOnly := &CopyOnWriteFs{base: memFs, layer: NewMemMapFs()}\n\tbasePathFs := &BasePathFs{source: osFs, path: workDir}\n\tbasePathFsMem := &BasePathFs{source: memFs, path: memWorkDir}\n\troFs := &ReadOnlyFs{source: osFs}\n\troFsMem := &ReadOnlyFs{source: memFs}\n\n\tpathFileMem := filepath.Join(memWorkDir, \"aferom.txt\")\n\n\tWriteFile(osFs, filepath.Join(workDir, \"afero.txt\"), []byte(\"Hi, Afero!\"), 0o777)\n\tWriteFile(memFs, filepath.Join(pathFileMem), []byte(\"Hi, Afero!\"), 0o777)\n\n\tos.Chdir(workDir)\n\tif err := os.Symlink(\"afero.txt\", \"symafero.txt\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpathFile := filepath.Join(workDir, \"afero.txt\")\n\tpathSymlink := filepath.Join(workDir, \"symafero.txt\")\n\n\tcheckLstat := func(l Lstater, name string, shouldLstat bool) os.FileInfo {\n\t\tstatFile, isLstat, err := l.LstatIfPossible(name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Lstat check failed: %s\", err)\n\t\t}\n\t\tif isLstat != shouldLstat {\n\t\t\tt.Fatalf(\"Lstat status was %t for %s\", isLstat, name)\n\t\t}\n\t\treturn statFile\n\t}\n\n\ttestLstat := func(l Lstater, pathFile, pathSymlink string) {\n\t\tshouldLstat := pathSymlink != \"\"\n\t\tstatRegular := checkLstat(l, pathFile, shouldLstat)\n\t\tstatSymlink := checkLstat(l, pathSymlink, shouldLstat)\n\t\tif statRegular == nil || statSymlink == nil {\n\t\t\tt.Fatal(\"got nil FileInfo\")\n\t\t}\n\n\t\tsymSym := statSymlink.Mode()&os.ModeSymlink == os.ModeSymlink\n\t\tif symSym == (pathSymlink == \"\") {\n\t\t\tt.Fatal(\"expected the FileInfo to describe the symlink\")\n\t\t}\n\n\t\t_, _, err := l.LstatIfPossible(\"this-should-not-exist.txt\")\n\t\tif err == nil || !os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"expected file to not exist, got %s\", err)\n\t\t}\n\t}\n\n\ttestLstat(osFs, pathFile, pathSymlink)\n\ttestLstat(overlayFs1, pathFile, pathSymlink)\n\ttestLstat(overlayFs2, pathFile, pathSymlink)\n\ttestLstat(basePathFs, \"afero.txt\", \"symafero.txt\")\n\ttestLstat(overlayFsMemOnly, pathFileMem, \"\")\n\ttestLstat(basePathFsMem, \"aferom.txt\", \"\")\n\ttestLstat(roFs, pathFile, pathSymlink)\n\ttestLstat(roFsMem, pathFileMem, \"\")\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 2.8017578125,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2009 The Go Authors. All rights reserved.\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// Glob returns the names of all files matching pattern or nil\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// This was adapted from (http://golang.org/pkg/path/filepath) and uses several\n// built-ins from that package.\nfunc Glob(fs Fs, pattern string) (matches []string, err error) {\n\tif !hasMeta(pattern) {\n\t\t// Lstat not supported by a ll filesystems.\n\t\tif _, err = lstatIfPossible(fs, pattern); err != nil {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn []string{pattern}, nil\n\t}\n\n\tdir, file := filepath.Split(pattern)\n\tswitch dir {\n\tcase \"\":\n\t\tdir = \".\"\n\tcase string(filepath.Separator):\n\t// nothing\n\tdefault:\n\t\tdir = dir[0 : len(dir)-1] // chop off trailing separator\n\t}\n\n\tif !hasMeta(dir) {\n\t\treturn glob(fs, dir, file, nil)\n\t}\n\n\tvar m []string\n\tm, err = Glob(fs, dir)\n\tif err != nil {\n\t\treturn\n\t}\n\tfor _, d := range m {\n\t\tmatches, err = glob(fs, d, file, matches)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\nfunc glob(fs Fs, dir, pattern string, matches []string) (m []string, e error) {\n\tm = matches\n\tfi, err := fs.Stat(dir)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !fi.IsDir() {\n\t\treturn\n\t}\n\td, err := fs.Open(dir)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer d.Close()\n\n\tnames, _ := d.Readdirnames(-1)\n\tsort.Strings(names)\n\n\tfor _, n := range names {\n\t\tmatched, err := filepath.Match(pattern, n)\n\t\tif err != nil {\n\t\t\treturn m, err\n\t\t}\n\t\tif matched {\n\t\t\tm = append(m, filepath.Join(dir, n))\n\t\t}\n\t}\n\treturn\n}\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by Match.\nfunc hasMeta(path string) bool {\n\t// TODO(niemeyer): Should other magic characters be added here?\n\treturn strings.ContainsAny(path, \"*?[\")\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 4.189453125,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2009 The Go Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n)\n\n// contains returns true if vector contains the string s.\nfunc contains(vector []string, s string) bool {\n\tfor _, elem := range vector {\n\t\tif elem == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc setupGlobDirRoot(t *testing.T, fs Fs) string {\n\tpath := testDir(fs)\n\tsetupGlobFiles(t, fs, path)\n\treturn path\n}\n\nfunc setupGlobDirReusePath(t *testing.T, fs Fs, path string) string {\n\ttestRegistry[fs] = append(testRegistry[fs], path)\n\treturn setupGlobFiles(t, fs, path)\n}\n\nfunc setupGlobFiles(t *testing.T, fs Fs, path string) string {\n\ttestSubDir := filepath.Join(path, \"globs\", \"bobs\")\n\terr := fs.MkdirAll(testSubDir, 0o700)\n\tif err != nil && !os.IsExist(err) {\n\t\tt.Fatal(err)\n\t}\n\n\tf, err := fs.Create(filepath.Join(testSubDir, \"/matcher\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 1 content\")\n\tf.Close()\n\n\tf, err = fs.Create(filepath.Join(testSubDir, \"/../submatcher\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 2 content\")\n\tf.Close()\n\n\tf, err = fs.Create(filepath.Join(testSubDir, \"/../../match\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.WriteString(\"Testfile 3 content\")\n\tf.Close()\n\n\treturn testSubDir\n}\n\nfunc TestGlob(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tvar testDir string\n\tfor i, fs := range Fss {\n\t\tif i == 0 {\n\t\t\ttestDir = setupGlobDirRoot(t, fs)\n\t\t} else {\n\t\t\tsetupGlobDirReusePath(t, fs, testDir)\n\t\t}\n\t}\n\n\tglobTests := []struct {\n\t\tpattern, result string\n\t}{\n\t\t{testDir + \"/globs/bobs/matcher\", testDir + \"/globs/bobs/matcher\"},\n\t\t{testDir + \"/globs/*/mat?her\", testDir + \"/globs/bobs/matcher\"},\n\t\t{testDir + \"/globs/bobs/../*\", testDir + \"/globs/submatcher\"},\n\t\t{testDir + \"/match\", testDir + \"/match\"},\n\t}\n\n\tfor _, fs := range Fss {\n\n\t\tfor _, tt := range globTests {\n\t\t\tpattern := tt.pattern\n\t\t\tresult := tt.result\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tpattern = filepath.Clean(pattern)\n\t\t\t\tresult = filepath.Clean(result)\n\t\t\t}\n\t\t\tmatches, err := Glob(fs, pattern)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Glob error for %q: %s\", pattern, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !contains(matches, result) {\n\t\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", pattern, matches, result)\n\t\t\t}\n\t\t}\n\t\tfor _, pattern := range []string{\"no_match\", \"../*/no_match\"} {\n\t\t\tmatches, err := Glob(fs, pattern)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Glob error for %q: %s\", pattern, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(matches) != 0 {\n\t\t\t\tt.Errorf(\"Glob(%#q) = %#v want []\", pattern, matches)\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfunc TestGlobSymlink(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\n\tfs := &OsFs{}\n\ttestDir := setupGlobDirRoot(t, fs)\n\n\terr := os.Symlink(\"target\", filepath.Join(testDir, \"symlink\"))\n\tif err != nil {\n\t\tt.Skipf(\"skipping on %s\", runtime.GOOS)\n\t}\n\n\tglobSymlinkTests := []struct {\n\t\tpath, dest string\n\t\tbrokenLink bool\n\t}{\n\t\t{\"test1\", \"link1\", false},\n\t\t{\"test2\", \"link2\", true},\n\t}\n\n\tfor _, tt := range globSymlinkTests {\n\t\tpath := filepath.Join(testDir, tt.path)\n\t\tdest := filepath.Join(testDir, tt.dest)\n\t\tf, err := fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := f.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = os.Symlink(path, dest)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tt.brokenLink {\n\t\t\t// Break the symlink.\n\t\t\tfs.Remove(path)\n\t\t}\n\t\tmatches, err := Glob(fs, dest)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"GlobSymlink error for %q: %s\", dest, err)\n\t\t}\n\t\tif !contains(matches, dest) {\n\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", dest, matches, dest)\n\t\t}\n\t}\n}\n\nfunc TestGlobError(t *testing.T) {\n\tfor _, fs := range Fss {\n\t\t_, err := Glob(fs, \"[7]\")\n\t\tif err != nil {\n\t\t\tt.Error(\"expected error for bad pattern; got none\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "mem",
          "type": "tree",
          "content": null
        },
        {
          "name": "memmap.go",
          "type": "blob",
          "size": 9.8837890625,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/spf13/afero/mem\"\n)\n\nconst chmodBits = os.ModePerm | os.ModeSetuid | os.ModeSetgid | os.ModeSticky // Only a subset of bits are allowed to be changed. Documented under os.Chmod()\n\ntype MemMapFs struct {\n\tmu   sync.RWMutex\n\tdata map[string]*mem.FileData\n\tinit sync.Once\n}\n\nfunc NewMemMapFs() Fs {\n\treturn &MemMapFs{}\n}\n\nfunc (m *MemMapFs) getData() map[string]*mem.FileData {\n\tm.init.Do(func() {\n\t\tm.data = make(map[string]*mem.FileData)\n\t\t// Root should always exist, right?\n\t\t// TODO: what about windows?\n\t\troot := mem.CreateDir(FilePathSeparator)\n\t\tmem.SetMode(root, os.ModeDir|0o755)\n\t\tm.data[FilePathSeparator] = root\n\t})\n\treturn m.data\n}\n\nfunc (*MemMapFs) Name() string { return \"MemMapFS\" }\n\nfunc (m *MemMapFs) Create(name string) (File, error) {\n\tname = normalizePath(name)\n\tm.mu.Lock()\n\tfile := mem.CreateFile(name)\n\tm.getData()[name] = file\n\tm.registerWithParent(file, 0)\n\tm.mu.Unlock()\n\treturn mem.NewFileHandle(file), nil\n}\n\nfunc (m *MemMapFs) unRegisterWithParent(fileName string) error {\n\tf, err := m.lockfreeOpen(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparent := m.findParent(f)\n\tif parent == nil {\n\t\tlog.Panic(\"parent of \", f.Name(), \" is nil\")\n\t}\n\n\tparent.Lock()\n\tmem.RemoveFromMemDir(parent, f)\n\tparent.Unlock()\n\treturn nil\n}\n\nfunc (m *MemMapFs) findParent(f *mem.FileData) *mem.FileData {\n\tpdir, _ := filepath.Split(f.Name())\n\tpdir = filepath.Clean(pdir)\n\tpfile, err := m.lockfreeOpen(pdir)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn pfile\n}\n\nfunc (m *MemMapFs) findDescendants(name string) []*mem.FileData {\n\tfData := m.getData()\n\tdescendants := make([]*mem.FileData, 0, len(fData))\n\tfor p, dFile := range fData {\n\t\tif strings.HasPrefix(p, name+FilePathSeparator) {\n\t\t\tdescendants = append(descendants, dFile)\n\t\t}\n\t}\n\n\tsort.Slice(descendants, func(i, j int) bool {\n\t\tcur := len(strings.Split(descendants[i].Name(), FilePathSeparator))\n\t\tnext := len(strings.Split(descendants[j].Name(), FilePathSeparator))\n\t\treturn cur < next\n\t})\n\n\treturn descendants\n}\n\nfunc (m *MemMapFs) registerWithParent(f *mem.FileData, perm os.FileMode) {\n\tif f == nil {\n\t\treturn\n\t}\n\tparent := m.findParent(f)\n\tif parent == nil {\n\t\tpdir := filepath.Dir(filepath.Clean(f.Name()))\n\t\terr := m.lockfreeMkdir(pdir, perm)\n\t\tif err != nil {\n\t\t\t// log.Println(\"Mkdir error:\", err)\n\t\t\treturn\n\t\t}\n\t\tparent, err = m.lockfreeOpen(pdir)\n\t\tif err != nil {\n\t\t\t// log.Println(\"Open after Mkdir error:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tparent.Lock()\n\tmem.InitializeDir(parent)\n\tmem.AddToMemDir(parent, f)\n\tparent.Unlock()\n}\n\nfunc (m *MemMapFs) lockfreeMkdir(name string, perm os.FileMode) error {\n\tname = normalizePath(name)\n\tx, ok := m.getData()[name]\n\tif ok {\n\t\t// Only return ErrFileExists if it's a file, not a directory.\n\t\ti := mem.FileInfo{FileData: x}\n\t\tif !i.IsDir() {\n\t\t\treturn ErrFileExists\n\t\t}\n\t} else {\n\t\titem := mem.CreateDir(name)\n\t\tmem.SetMode(item, os.ModeDir|perm)\n\t\tm.getData()[name] = item\n\t\tm.registerWithParent(item, perm)\n\t}\n\treturn nil\n}\n\nfunc (m *MemMapFs) Mkdir(name string, perm os.FileMode) error {\n\tperm &= chmodBits\n\tname = normalizePath(name)\n\n\tm.mu.RLock()\n\t_, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif ok {\n\t\treturn &os.PathError{Op: \"mkdir\", Path: name, Err: ErrFileExists}\n\t}\n\n\tm.mu.Lock()\n\t// Dobule check that it doesn't exist.\n\tif _, ok := m.getData()[name]; ok {\n\t\tm.mu.Unlock()\n\t\treturn &os.PathError{Op: \"mkdir\", Path: name, Err: ErrFileExists}\n\t}\n\titem := mem.CreateDir(name)\n\tmem.SetMode(item, os.ModeDir|perm)\n\tm.getData()[name] = item\n\tm.registerWithParent(item, perm)\n\tm.mu.Unlock()\n\n\treturn m.setFileMode(name, perm|os.ModeDir)\n}\n\nfunc (m *MemMapFs) MkdirAll(path string, perm os.FileMode) error {\n\terr := m.Mkdir(path, perm)\n\tif err != nil {\n\t\tif err.(*os.PathError).Err == ErrFileExists {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Handle some relative paths\nfunc normalizePath(path string) string {\n\tpath = filepath.Clean(path)\n\n\tswitch path {\n\tcase \".\":\n\t\treturn FilePathSeparator\n\tcase \"..\":\n\t\treturn FilePathSeparator\n\tdefault:\n\t\treturn path\n\t}\n}\n\nfunc (m *MemMapFs) Open(name string) (File, error) {\n\tf, err := m.open(name)\n\tif f != nil {\n\t\treturn mem.NewReadOnlyFileHandle(f), err\n\t}\n\treturn nil, err\n}\n\nfunc (m *MemMapFs) openWrite(name string) (File, error) {\n\tf, err := m.open(name)\n\tif f != nil {\n\t\treturn mem.NewFileHandle(f), err\n\t}\n\treturn nil, err\n}\n\nfunc (m *MemMapFs) open(name string) (*mem.FileData, error) {\n\tname = normalizePath(name)\n\n\tm.mu.RLock()\n\tf, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif !ok {\n\t\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: ErrFileNotFound}\n\t}\n\treturn f, nil\n}\n\nfunc (m *MemMapFs) lockfreeOpen(name string) (*mem.FileData, error) {\n\tname = normalizePath(name)\n\tf, ok := m.getData()[name]\n\tif ok {\n\t\treturn f, nil\n\t} else {\n\t\treturn nil, ErrFileNotFound\n\t}\n}\n\nfunc (m *MemMapFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tperm &= chmodBits\n\tchmod := false\n\tfile, err := m.openWrite(name)\n\tif err == nil && (flag&os.O_EXCL > 0) {\n\t\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: ErrFileExists}\n\t}\n\tif os.IsNotExist(err) && (flag&os.O_CREATE > 0) {\n\t\tfile, err = m.Create(name)\n\t\tchmod = true\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif flag == os.O_RDONLY {\n\t\tfile = mem.NewReadOnlyFileHandle(file.(*mem.File).Data())\n\t}\n\tif flag&os.O_APPEND > 0 {\n\t\t_, err = file.Seek(0, io.SeekEnd)\n\t\tif err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif flag&os.O_TRUNC > 0 && flag&(os.O_RDWR|os.O_WRONLY) > 0 {\n\t\terr = file.Truncate(0)\n\t\tif err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif chmod {\n\t\treturn file, m.setFileMode(name, perm)\n\t}\n\treturn file, nil\n}\n\nfunc (m *MemMapFs) Remove(name string) error {\n\tname = normalizePath(name)\n\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tif _, ok := m.getData()[name]; ok {\n\t\terr := m.unRegisterWithParent(name)\n\t\tif err != nil {\n\t\t\treturn &os.PathError{Op: \"remove\", Path: name, Err: err}\n\t\t}\n\t\tdelete(m.getData(), name)\n\t} else {\n\t\treturn &os.PathError{Op: \"remove\", Path: name, Err: os.ErrNotExist}\n\t}\n\treturn nil\n}\n\nfunc (m *MemMapFs) RemoveAll(path string) error {\n\tpath = normalizePath(path)\n\tm.mu.Lock()\n\tm.unRegisterWithParent(path)\n\tm.mu.Unlock()\n\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tfor p := range m.getData() {\n\t\tif p == path || strings.HasPrefix(p, path+FilePathSeparator) {\n\t\t\tm.mu.RUnlock()\n\t\t\tm.mu.Lock()\n\t\t\tdelete(m.getData(), p)\n\t\t\tm.mu.Unlock()\n\t\t\tm.mu.RLock()\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *MemMapFs) Rename(oldname, newname string) error {\n\toldname = normalizePath(oldname)\n\tnewname = normalizePath(newname)\n\n\tif oldname == newname {\n\t\treturn nil\n\t}\n\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tif _, ok := m.getData()[oldname]; ok {\n\t\tm.mu.RUnlock()\n\t\tm.mu.Lock()\n\t\terr := m.unRegisterWithParent(oldname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfileData := m.getData()[oldname]\n\t\tmem.ChangeFileName(fileData, newname)\n\t\tm.getData()[newname] = fileData\n\n\t\terr = m.renameDescendants(oldname, newname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdelete(m.getData(), oldname)\n\n\t\tm.registerWithParent(fileData, 0)\n\t\tm.mu.Unlock()\n\t\tm.mu.RLock()\n\t} else {\n\t\treturn &os.PathError{Op: \"rename\", Path: oldname, Err: ErrFileNotFound}\n\t}\n\treturn nil\n}\n\nfunc (m *MemMapFs) renameDescendants(oldname, newname string) error {\n\tdescendants := m.findDescendants(oldname)\n\tremoves := make([]string, 0, len(descendants))\n\tfor _, desc := range descendants {\n\t\tdescNewName := strings.Replace(desc.Name(), oldname, newname, 1)\n\t\terr := m.unRegisterWithParent(desc.Name())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tremoves = append(removes, desc.Name())\n\t\tmem.ChangeFileName(desc, descNewName)\n\t\tm.getData()[descNewName] = desc\n\n\t\tm.registerWithParent(desc, 0)\n\t}\n\tfor _, r := range removes {\n\t\tdelete(m.getData(), r)\n\t}\n\n\treturn nil\n}\n\nfunc (m *MemMapFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tfileInfo, err := m.Stat(name)\n\treturn fileInfo, false, err\n}\n\nfunc (m *MemMapFs) Stat(name string) (os.FileInfo, error) {\n\tf, err := m.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfi := mem.GetFileInfo(f.(*mem.File).Data())\n\treturn fi, nil\n}\n\nfunc (m *MemMapFs) Chmod(name string, mode os.FileMode) error {\n\tmode &= chmodBits\n\n\tm.mu.RLock()\n\tf, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif !ok {\n\t\treturn &os.PathError{Op: \"chmod\", Path: name, Err: ErrFileNotFound}\n\t}\n\tprevOtherBits := mem.GetFileInfo(f).Mode() & ^chmodBits\n\n\tmode = prevOtherBits | mode\n\treturn m.setFileMode(name, mode)\n}\n\nfunc (m *MemMapFs) setFileMode(name string, mode os.FileMode) error {\n\tname = normalizePath(name)\n\n\tm.mu.RLock()\n\tf, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif !ok {\n\t\treturn &os.PathError{Op: \"chmod\", Path: name, Err: ErrFileNotFound}\n\t}\n\n\tm.mu.Lock()\n\tmem.SetMode(f, mode)\n\tm.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (m *MemMapFs) Chown(name string, uid, gid int) error {\n\tname = normalizePath(name)\n\n\tm.mu.RLock()\n\tf, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif !ok {\n\t\treturn &os.PathError{Op: \"chown\", Path: name, Err: ErrFileNotFound}\n\t}\n\n\tmem.SetUID(f, uid)\n\tmem.SetGID(f, gid)\n\n\treturn nil\n}\n\nfunc (m *MemMapFs) Chtimes(name string, atime time.Time, mtime time.Time) error {\n\tname = normalizePath(name)\n\n\tm.mu.RLock()\n\tf, ok := m.getData()[name]\n\tm.mu.RUnlock()\n\tif !ok {\n\t\treturn &os.PathError{Op: \"chtimes\", Path: name, Err: ErrFileNotFound}\n\t}\n\n\tm.mu.Lock()\n\tmem.SetModTime(f, mtime)\n\tm.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (m *MemMapFs) List() {\n\tfor _, x := range m.data {\n\t\ty := mem.FileInfo{FileData: x}\n\t\tfmt.Println(x.Name(), y.Size())\n\t}\n}\n"
        },
        {
          "name": "memmap_test.go",
          "type": "blob",
          "size": 20.2041015625,
          "content": "package afero\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNormalizePath(t *testing.T) {\n\ttype test struct {\n\t\tinput    string\n\t\texpected string\n\t}\n\n\tdata := []test{\n\t\t{\".\", FilePathSeparator},\n\t\t{\"./\", FilePathSeparator},\n\t\t{\"..\", FilePathSeparator},\n\t\t{\"../\", FilePathSeparator},\n\t\t{\"./..\", FilePathSeparator},\n\t\t{\"./../\", FilePathSeparator},\n\t}\n\n\tfor i, d := range data {\n\t\tcpath := normalizePath(d.input)\n\t\tif d.expected != cpath {\n\t\t\tt.Errorf(\"Test %d failed. Expected %q got %q\", i, d.expected, cpath)\n\t\t}\n\t}\n}\n\nfunc TestPathErrors(t *testing.T) {\n\tpath := filepath.Join(\".\", \"some\", \"path\")\n\tpath2 := filepath.Join(\".\", \"different\", \"path\")\n\tfs := NewMemMapFs()\n\tperm := os.FileMode(0o755)\n\tuid := 1000\n\tgid := 1000\n\n\t// relevant functions:\n\t// func (m *MemMapFs) Chmod(name string, mode os.FileMode) error\n\t// func (m *MemMapFs) Chtimes(name string, atime time.Time, mtime time.Time) error\n\t// func (m *MemMapFs) Create(name string) (File, error)\n\t// func (m *MemMapFs) Mkdir(name string, perm os.FileMode) error\n\t// func (m *MemMapFs) MkdirAll(path string, perm os.FileMode) error\n\t// func (m *MemMapFs) Open(name string) (File, error)\n\t// func (m *MemMapFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)\n\t// func (m *MemMapFs) Remove(name string) error\n\t// func (m *MemMapFs) Rename(oldname, newname string) error\n\t// func (m *MemMapFs) Stat(name string) (os.FileInfo, error)\n\n\terr := fs.Chmod(path, perm)\n\tcheckPathError(t, err, \"Chmod\")\n\n\terr = fs.Chown(path, uid, gid)\n\tcheckPathError(t, err, \"Chown\")\n\n\terr = fs.Chtimes(path, time.Now(), time.Now())\n\tcheckPathError(t, err, \"Chtimes\")\n\n\t// fs.Create doesn't return an error\n\n\terr = fs.Mkdir(path2, perm)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\terr = fs.Mkdir(path2, perm)\n\tcheckPathError(t, err, \"Mkdir\")\n\n\terr = fs.MkdirAll(path2, perm)\n\tif err != nil {\n\t\tt.Error(\"MkdirAll:\", err)\n\t}\n\n\t_, err = fs.Open(path)\n\tcheckPathError(t, err, \"Open\")\n\n\t_, err = fs.OpenFile(path, os.O_RDWR, perm)\n\tcheckPathError(t, err, \"OpenFile\")\n\n\terr = fs.Remove(path)\n\tcheckPathError(t, err, \"Remove\")\n\n\terr = fs.RemoveAll(path)\n\tif err != nil {\n\t\tt.Error(\"RemoveAll:\", err)\n\t}\n\n\terr = fs.Rename(path, path2)\n\tcheckPathError(t, err, \"Rename\")\n\n\t_, err = fs.Stat(path)\n\tcheckPathError(t, err, \"Stat\")\n}\n\nfunc checkPathError(t *testing.T, err error, op string) {\n\tpathErr, ok := err.(*os.PathError)\n\tif !ok {\n\t\tt.Error(op+\":\", err, \"is not a os.PathError\")\n\t\treturn\n\t}\n\t_, ok = pathErr.Err.(*os.PathError)\n\tif ok {\n\t\tt.Error(op+\":\", err, \"contains another os.PathError\")\n\t}\n}\n\n// Ensure os.O_EXCL is correctly handled.\nfunc TestOpenFileExcl(t *testing.T) {\n\tconst fileName = \"/myFileTest\"\n\tconst fileMode = os.FileMode(0o765)\n\n\tfs := NewMemMapFs()\n\n\t// First creation should succeed.\n\tf, err := fs.OpenFile(fileName, os.O_CREATE|os.O_EXCL, fileMode)\n\tif err != nil {\n\t\tt.Errorf(\"OpenFile Create Excl failed: %s\", err)\n\t\treturn\n\t}\n\tf.Close()\n\n\t// Second creation should fail.\n\t_, err = fs.OpenFile(fileName, os.O_CREATE|os.O_EXCL, fileMode)\n\tif err == nil {\n\t\tt.Errorf(\"OpenFile Create Excl should have failed, but it didn't\")\n\t}\n\tcheckPathError(t, err, \"Open\")\n}\n\n// Ensure Permissions are set on OpenFile/Mkdir/MkdirAll\nfunc TestPermSet(t *testing.T) {\n\tconst fileName = \"/myFileTest\"\n\tconst dirPath = \"/myDirTest\"\n\tconst dirPathAll = \"/my/path/to/dir\"\n\n\tconst fileMode = os.FileMode(0o765)\n\t// directories will also have the directory bit set\n\tconst dirMode = fileMode | os.ModeDir\n\n\tfs := NewMemMapFs()\n\n\t// Test Openfile\n\tf, err := fs.OpenFile(fileName, os.O_CREATE, fileMode)\n\tif err != nil {\n\t\tt.Errorf(\"OpenFile Create failed: %s\", err)\n\t\treturn\n\t}\n\tf.Close()\n\n\ts, err := fs.Stat(fileName)\n\tif err != nil {\n\t\tt.Errorf(\"Stat failed: %s\", err)\n\t\treturn\n\t}\n\tif s.Mode().String() != fileMode.String() {\n\t\tt.Errorf(\"Permissions Incorrect: %s != %s\", s.Mode().String(), fileMode.String())\n\t\treturn\n\t}\n\n\t// Test Mkdir\n\terr = fs.Mkdir(dirPath, dirMode)\n\tif err != nil {\n\t\tt.Errorf(\"MkDir Create failed: %s\", err)\n\t\treturn\n\t}\n\ts, err = fs.Stat(dirPath)\n\tif err != nil {\n\t\tt.Errorf(\"Stat failed: %s\", err)\n\t\treturn\n\t}\n\t// sets File\n\tif s.Mode().String() != dirMode.String() {\n\t\tt.Errorf(\"Permissions Incorrect: %s != %s\", s.Mode().String(), dirMode.String())\n\t\treturn\n\t}\n\n\t// Test MkdirAll\n\terr = fs.MkdirAll(dirPathAll, dirMode)\n\tif err != nil {\n\t\tt.Errorf(\"MkDir Create failed: %s\", err)\n\t\treturn\n\t}\n\ts, err = fs.Stat(dirPathAll)\n\tif err != nil {\n\t\tt.Errorf(\"Stat failed: %s\", err)\n\t\treturn\n\t}\n\tif s.Mode().String() != dirMode.String() {\n\t\tt.Errorf(\"Permissions Incorrect: %s != %s\", s.Mode().String(), dirMode.String())\n\t\treturn\n\t}\n}\n\n// Fails if multiple file objects use the same file.at counter in MemMapFs\nfunc TestMultipleOpenFiles(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tconst fileName = \"afero-demo2.txt\"\n\n\tdata := make([][]byte, len(Fss))\n\n\tfor i, fs := range Fss {\n\t\tdir := testDir(fs)\n\t\tpath := filepath.Join(dir, fileName)\n\t\tfh1, err := fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(\"fs.Create failed: \" + err.Error())\n\t\t}\n\t\t_, err = fh1.Write([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\tt.Error(\"fh.Write failed: \" + err.Error())\n\t\t}\n\t\t_, err = fh1.Seek(0, io.SeekStart)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tfh2, err := fs.OpenFile(path, os.O_RDWR, 0o777)\n\t\tif err != nil {\n\t\t\tt.Error(\"fs.OpenFile failed: \" + err.Error())\n\t\t}\n\t\t_, err = fh2.Seek(0, io.SeekEnd)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t_, err = fh2.Write([]byte(\"data\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\terr = fh2.Close()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\t_, err = fh1.Write([]byte(\"data\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\terr = fh1.Close()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t// the file now should contain \"datadata\"\n\t\tdata[i], err = ReadFile(fs, path)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n\tfor i, fs := range Fss {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif string(data[0]) != string(data[i]) {\n\t\t\tt.Errorf(\"%s and %s don't behave the same\\n\"+\n\t\t\t\t\"%s: \\\"%s\\\"\\n%s: \\\"%s\\\"\\n\",\n\t\t\t\tFss[0].Name(), fs.Name(), Fss[0].Name(), data[0], fs.Name(), data[i])\n\t\t}\n\t}\n}\n\n// Test if file.Write() fails when opened as read only\nfunc TestReadOnly(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tconst fileName = \"afero-demo.txt\"\n\n\tfor _, fs := range Fss {\n\t\tdir := testDir(fs)\n\t\tpath := filepath.Join(dir, fileName)\n\n\t\tf, err := fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"fs.Create failed: \"+err.Error())\n\t\t}\n\t\t_, err = f.Write([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"Write failed: \"+err.Error())\n\t\t}\n\t\tf.Close()\n\n\t\tf, err = fs.Open(path)\n\t\tif err != nil {\n\t\t\tt.Error(\"fs.Open failed: \" + err.Error())\n\t\t}\n\t\t_, err = f.Write([]byte(\"data\"))\n\t\tif err == nil {\n\t\t\tt.Error(fs.Name()+\":\", \"No write error\")\n\t\t}\n\t\tf.Close()\n\n\t\tf, err = fs.OpenFile(path, os.O_RDONLY, 0o644)\n\t\tif err != nil {\n\t\t\tt.Error(\"fs.Open failed: \" + err.Error())\n\t\t}\n\t\t_, err = f.Write([]byte(\"data\"))\n\t\tif err == nil {\n\t\t\tt.Error(fs.Name()+\":\", \"No write error\")\n\t\t}\n\t\tf.Close()\n\t}\n}\n\nfunc TestWriteCloseTime(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tconst fileName = \"afero-demo.txt\"\n\n\tfor _, fs := range Fss {\n\t\tdir := testDir(fs)\n\t\tpath := filepath.Join(dir, fileName)\n\n\t\tf, err := fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"fs.Create failed: \"+err.Error())\n\t\t}\n\t\tf.Close()\n\n\t\tf, err = fs.Create(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"fs.Create failed: \"+err.Error())\n\t\t}\n\t\tfi, err := f.Stat()\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"Stat failed: \"+err.Error())\n\t\t}\n\t\ttimeBefore := fi.ModTime()\n\n\t\t// sorry for the delay, but we have to make sure time advances,\n\t\t// also on non Un*x systems...\n\t\tswitch runtime.GOOS {\n\t\tcase \"windows\":\n\t\t\ttime.Sleep(2 * time.Second)\n\t\tcase \"darwin\":\n\t\t\ttime.Sleep(1 * time.Second)\n\t\tdefault: // depending on the FS, this may work with < 1 second, on my old ext3 it does not\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\t_, err = f.Write([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"Write failed: \"+err.Error())\n\t\t}\n\t\tf.Close()\n\t\tfi, err = fs.Stat(path)\n\t\tif err != nil {\n\t\t\tt.Error(fs.Name()+\":\", \"fs.Stat failed: \"+err.Error())\n\t\t}\n\t\tif fi.ModTime().Equal(timeBefore) {\n\t\t\tt.Error(fs.Name()+\":\", \"ModTime was not set on Close()\")\n\t\t}\n\t}\n}\n\n// This test should be run with the race detector on:\n// go test -race -v -timeout 10s -run TestRacingDeleteAndClose\nfunc TestRacingDeleteAndClose(t *testing.T) {\n\tfs := NewMemMapFs()\n\tpathname := \"testfile\"\n\tf, err := fs.Create(pathname)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tin := make(chan bool)\n\n\tgo func() {\n\t\t<-in\n\t\tf.Close()\n\t}()\n\tgo func() {\n\t\t<-in\n\t\tfs.Remove(pathname)\n\t}()\n\tclose(in)\n}\n\n// This test should be run with the race detector on:\n// go test -run TestMemFsDataRace -race\nfunc TestMemFsDataRace(t *testing.T) {\n\tconst dir = \"test_dir\"\n\tfs := NewMemMapFs()\n\n\tif err := fs.MkdirAll(dir, 0o777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst n = 1000\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tfname := filepath.Join(dir, fmt.Sprintf(\"%d.txt\", i))\n\t\t\tif err := WriteFile(fs, fname, []byte(\"\"), 0o777); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif err := fs.Remove(fname); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t}()\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\tbreak loop\n\t\tdefault:\n\t\t\t_, err := ReadDir(fs, dir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// root is a directory\nfunc TestMemFsRootDirMode(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\tinfo, err := fs.Stat(\"/\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !info.IsDir() {\n\t\tt.Error(\"should be a directory\")\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Errorf(\"FileMode is not directory, is %s\", info.Mode().String())\n\t}\n}\n\n// MkdirAll creates intermediate directories with correct mode\nfunc TestMemFsMkdirAllMode(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\terr := fs.MkdirAll(\"/a/b/c\", 0o755)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinfo, err := fs.Stat(\"/a\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Error(\"/a: mode is not directory\")\n\t}\n\tif !info.ModTime().After(time.Now().Add(-1 * time.Hour)) {\n\t\tt.Errorf(\"/a: mod time not set, got %s\", info.ModTime())\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Errorf(\"/a: wrong permissions, expected drwxr-xr-x, got %s\", info.Mode())\n\t}\n\tinfo, err = fs.Stat(\"/a/b\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Error(\"/a/b: mode is not directory\")\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Errorf(\"/a/b: wrong permissions, expected drwxr-xr-x, got %s\", info.Mode())\n\t}\n\tif !info.ModTime().After(time.Now().Add(-1 * time.Hour)) {\n\t\tt.Errorf(\"/a/b: mod time not set, got %s\", info.ModTime())\n\t}\n\tinfo, err = fs.Stat(\"/a/b/c\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Error(\"/a/b/c: mode is not directory\")\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Errorf(\"/a/b/c: wrong permissions, expected drwxr-xr-x, got %s\", info.Mode())\n\t}\n\tif !info.ModTime().After(time.Now().Add(-1 * time.Hour)) {\n\t\tt.Errorf(\"/a/b/c: mod time not set, got %s\", info.ModTime())\n\t}\n}\n\n// MkdirAll does not change permissions of already-existing directories\nfunc TestMemFsMkdirAllNoClobber(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\terr := fs.MkdirAll(\"/a/b/c\", 0o755)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinfo, err := fs.Stat(\"/a/b\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Errorf(\"/a/b: wrong permissions, expected drwxr-xr-x, got %s\", info.Mode())\n\t}\n\terr = fs.MkdirAll(\"/a/b/c/d/e/f\", 0o710)\n\t// '/a/b' is unchanged\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinfo, err = fs.Stat(\"/a/b\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Errorf(\"/a/b: wrong permissions, expected drwxr-xr-x, got %s\", info.Mode())\n\t}\n\t// new directories created with proper permissions\n\tinfo, err = fs.Stat(\"/a/b/c/d\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o710) {\n\t\tt.Errorf(\"/a/b/c/d: wrong permissions, expected drwx--x---, got %s\", info.Mode())\n\t}\n\tinfo, err = fs.Stat(\"/a/b/c/d/e\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o710) {\n\t\tt.Errorf(\"/a/b/c/d/e: wrong permissions, expected drwx--x---, got %s\", info.Mode())\n\t}\n\tinfo, err = fs.Stat(\"/a/b/c/d/e/f\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o710) {\n\t\tt.Errorf(\"/a/b/c/d/e/f: wrong permissions, expected drwx--x---, got %s\", info.Mode())\n\t}\n}\n\nfunc TestMemFsDirMode(t *testing.T) {\n\tfs := NewMemMapFs()\n\terr := fs.Mkdir(\"/testDir1\", 0o644)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\terr = fs.MkdirAll(\"/sub/testDir2\", 0o644)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tinfo, err := fs.Stat(\"/testDir1\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !info.IsDir() {\n\t\tt.Error(\"should be a directory\")\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Error(\"FileMode is not directory\")\n\t}\n\tinfo, err = fs.Stat(\"/sub/testDir2\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !info.IsDir() {\n\t\tt.Error(\"should be a directory\")\n\t}\n\tif !info.Mode().IsDir() {\n\t\tt.Error(\"FileMode is not directory\")\n\t}\n}\n\nfunc TestMemFsUnexpectedEOF(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\n\tif err := WriteFile(fs, \"file.txt\", []byte(\"abc\"), 0o777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tf, err := fs.Open(\"file.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\t// Seek beyond the end.\n\t_, err = f.Seek(512, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbuff := make([]byte, 256)\n\t_, err = io.ReadAtLeast(f, buff, 256)\n\n\tif err != io.ErrUnexpectedEOF {\n\t\tt.Fatal(\"Expected ErrUnexpectedEOF\")\n\t}\n}\n\nfunc TestMemFsChmod(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\tconst file = \"hello\"\n\tif err := fs.Mkdir(file, 0o700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tinfo, err := fs.Stat(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode().String() != \"drwx------\" {\n\t\tt.Fatal(\"mkdir failed to create a directory: mode =\", info.Mode())\n\t}\n\n\terr = fs.Chmod(file, 0)\n\tif err != nil {\n\t\tt.Error(\"Failed to run chmod:\", err)\n\t}\n\n\tinfo, err = fs.Stat(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode().String() != \"d---------\" {\n\t\tt.Error(\"chmod should not change file type. New mode =\", info.Mode())\n\t}\n}\n\n// can't use Mkdir to get around which permissions we're allowed to set\nfunc TestMemFsMkdirModeIllegal(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\terr := fs.Mkdir(\"/a\", os.ModeSocket|0o755)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinfo, err := fs.Stat(\"/a\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(os.ModeDir|0o755) {\n\t\tt.Fatalf(\"should not be able to use Mkdir to set illegal mode: %s\", info.Mode().String())\n\t}\n}\n\n// can't use OpenFile to get around which permissions we're allowed to set\nfunc TestMemFsOpenFileModeIllegal(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\tfile, err := fs.OpenFile(\"/a\", os.O_CREATE, os.ModeSymlink|0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer file.Close()\n\tinfo, err := fs.Stat(\"/a\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif info.Mode() != os.FileMode(0o644) {\n\t\tt.Fatalf(\"should not be able to use OpenFile to set illegal mode: %s\", info.Mode().String())\n\t}\n}\n\n// LstatIfPossible should always return false, since MemMapFs does not\n// support symlinks.\nfunc TestMemFsLstatIfPossible(t *testing.T) {\n\tt.Parallel()\n\n\tfs := NewMemMapFs()\n\n\t// We assert that fs implements Lstater\n\tfsAsserted, ok := fs.(Lstater)\n\tif !ok {\n\t\tt.Fatalf(\"The filesytem does not implement Lstater\")\n\t}\n\n\tfile, err := fs.OpenFile(\"/a.txt\", os.O_CREATE, 0o644)\n\tif err != nil {\n\t\tt.Fatalf(\"Error when opening file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\t_, lstatCalled, err := fsAsserted.LstatIfPossible(\"/a.txt\")\n\tif err != nil {\n\t\tt.Fatalf(\"Function returned err: %v\", err)\n\t}\n\tif lstatCalled {\n\t\tt.Fatalf(\"Function indicated lstat was called. This should never be true.\")\n\t}\n}\n\nfunc TestMemMapFsConfurrentMkdir(t *testing.T) {\n\tconst dir = \"test_dir\"\n\tconst n = 1000\n\tmfs := NewMemMapFs().(*MemMapFs)\n\n\tallFilePaths := make([]string, 0, n)\n\n\t// run concurrency test\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < n; i++ {\n\t\tfp := filepath.Join(\n\t\t\tdir,\n\t\t\tfmt.Sprintf(\"%02d\", n%10),\n\t\t\tfmt.Sprintf(\"%d.txt\", i),\n\t\t)\n\t\tallFilePaths = append(allFilePaths, fp)\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tif err := mfs.MkdirAll(filepath.Dir(fp), 0o755); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\n\t\t\twt, err := mfs.Create(fp)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := wt.Close(); err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// write 30 bytes\n\t\t\tfor j := 0; j < 10; j++ {\n\t\t\t\t_, err := wt.Write([]byte(\"000\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Test1: find all files by full path access\n\tfor _, fp := range allFilePaths {\n\t\tinfo, err := mfs.Stat(fp)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tif info.Size() != 30 {\n\t\t\tt.Errorf(\"file size should be 30, but got %d\", info.Size())\n\t\t}\n\n\t}\n\n\t// Test2: find all files by walk\n\tfoundFiles := make([]string, 0, n)\n\twErr := Walk(mfs, dir, func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil // skip dir\n\t\t}\n\t\tif strings.HasSuffix(info.Name(), \".txt\") {\n\t\t\tfoundFiles = append(foundFiles, path)\n\t\t}\n\t\treturn nil\n\t})\n\tif wErr != nil {\n\t\tt.Error(wErr)\n\t}\n\tif len(foundFiles) != n {\n\t\tt.Errorf(\"found %d files, but expect %d\", len(foundFiles), n)\n\t}\n}\n\nfunc TestMemFsRenameDir(t *testing.T) {\n\tconst srcPath = \"/src\"\n\tconst dstPath = \"/dst\"\n\tconst subDir = \"dir\"\n\tconst subFile = \"file.txt\"\n\n\tfs := NewMemMapFs()\n\n\terr := fs.MkdirAll(srcPath+FilePathSeparator+subDir, 0o777)\n\tif err != nil {\n\t\tt.Fatalf(\"MkDirAll failed: %s\", err)\n\t}\n\n\tf, err := fs.Create(srcPath + FilePathSeparator + subFile)\n\tif err != nil {\n\t\tt.Fatalf(\"Create failed: %s\", err)\n\t}\n\tif err = f.Close(); err != nil {\n\t\tt.Fatalf(\"Close failed: %s\", err)\n\t}\n\n\terr = fs.Rename(srcPath, dstPath)\n\tif err != nil {\n\t\tt.Fatalf(\"Rename failed: %s\", err)\n\t}\n\n\t_, err = fs.Stat(srcPath + FilePathSeparator + subDir)\n\tif err == nil {\n\t\tt.Fatalf(\"SubDir still exists in the source dir\")\n\t}\n\n\t_, err = fs.Stat(srcPath + FilePathSeparator + subFile)\n\tif err == nil {\n\t\tt.Fatalf(\"SubFile still exists in the source dir\")\n\t}\n\n\t_, err = fs.Stat(dstPath + FilePathSeparator + subDir)\n\tif err != nil {\n\t\tt.Fatalf(\"SubDir stat in the destination dir: %s\", err)\n\t}\n\n\t_, err = fs.Stat(dstPath + FilePathSeparator + subFile)\n\tif err != nil {\n\t\tt.Fatalf(\"SubFile stat in the destination dir: %s\", err)\n\t}\n\n\terr = fs.Mkdir(srcPath, 0o777)\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot recreate the source dir: %s\", err)\n\t}\n\n\terr = fs.Mkdir(srcPath+FilePathSeparator+subDir, 0o777)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot recreate the subdir in the source dir: %s\", err)\n\t}\n}\n\nfunc TestMemMapFsRename(t *testing.T) {\n\tt.Parallel()\n\n\tfs := &MemMapFs{}\n\ttDir := testDir(fs)\n\trFrom := \"/renamefrom\"\n\trTo := \"/renameto\"\n\trExists := \"/renameexists\"\n\n\ttype test struct {\n\t\tdirs   []string\n\t\tfrom   string\n\t\tto     string\n\t\texists string\n\t}\n\n\tparts := strings.Split(tDir, \"/\")\n\troot := \"/\"\n\tif len(parts) > 1 {\n\t\troot = filepath.Join(\"/\", parts[1])\n\t}\n\n\ttestData := make([]test, 0, len(parts))\n\n\ti := len(parts)\n\tfor i > 0 {\n\t\tprefix := strings.Join(parts[:i], \"/\")\n\t\tsuffix := strings.Join(parts[i:], \"/\")\n\t\ttestData = append(testData, test{\n\t\t\tdirs: []string{\n\t\t\t\tfilepath.Join(prefix, rFrom, suffix),\n\t\t\t\tfilepath.Join(prefix, rExists, suffix),\n\t\t\t},\n\t\t\tfrom:   filepath.Join(prefix, rFrom),\n\t\t\tto:     filepath.Join(prefix, rTo),\n\t\t\texists: filepath.Join(prefix, rExists),\n\t\t})\n\t\ti--\n\t}\n\n\tfor _, data := range testData {\n\t\terr := fs.RemoveAll(root)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: RemoveAll %q failed: %v\", fs.Name(), root, err)\n\t\t}\n\n\t\tfor _, dir := range data.dirs {\n\t\t\terr = fs.MkdirAll(dir, os.FileMode(0o775))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s: MkdirAll %q failed: %v\", fs.Name(), dir, err)\n\t\t\t}\n\t\t}\n\n\t\tdataCnt := len(fs.getData())\n\t\terr = fs.Rename(data.from, data.to)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: rename %q, %q failed: %v\", fs.Name(), data.from, data.to, err)\n\t\t}\n\t\terr = fs.Mkdir(data.from, os.FileMode(0o775))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: Mkdir %q failed: %v\", fs.Name(), data.from, err)\n\t\t}\n\n\t\terr = fs.Rename(data.from, data.exists)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: rename %q, %q failed: %v\", fs.Name(), data.from, data.exists, err)\n\t\t}\n\n\t\tfor p := range fs.getData() {\n\t\t\tif strings.Contains(p, data.from) {\n\t\t\t\tt.Errorf(\"File was not renamed to renameto: %v\", p)\n\t\t\t}\n\t\t}\n\n\t\t_, err = fs.Stat(data.to)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: stat %q failed: %v\", fs.Name(), data.to, err)\n\t\t}\n\n\t\tif dataCnt != len(fs.getData()) {\n\t\t\tt.Errorf(\"invalid data len: expected %v, get %v\", dataCnt, len(fs.getData()))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "os.go",
          "type": "blob",
          "size": 2.8583984375,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2013 tsuru authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"os\"\n\t\"time\"\n)\n\nvar _ Lstater = (*OsFs)(nil)\n\n// OsFs is a Fs implementation that uses functions provided by the os package.\n//\n// For details in any method, check the documentation of the os package\n// (http://golang.org/pkg/os/).\ntype OsFs struct{}\n\nfunc NewOsFs() Fs {\n\treturn &OsFs{}\n}\n\nfunc (OsFs) Name() string { return \"OsFs\" }\n\nfunc (OsFs) Create(name string) (File, error) {\n\tf, e := os.Create(name)\n\tif f == nil {\n\t\t// while this looks strange, we need to return a bare nil (of type nil) not\n\t\t// a nil value of type *os.File or nil won't be nil\n\t\treturn nil, e\n\t}\n\treturn f, e\n}\n\nfunc (OsFs) Mkdir(name string, perm os.FileMode) error {\n\treturn os.Mkdir(name, perm)\n}\n\nfunc (OsFs) MkdirAll(path string, perm os.FileMode) error {\n\treturn os.MkdirAll(path, perm)\n}\n\nfunc (OsFs) Open(name string) (File, error) {\n\tf, e := os.Open(name)\n\tif f == nil {\n\t\t// while this looks strange, we need to return a bare nil (of type nil) not\n\t\t// a nil value of type *os.File or nil won't be nil\n\t\treturn nil, e\n\t}\n\treturn f, e\n}\n\nfunc (OsFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tf, e := os.OpenFile(name, flag, perm)\n\tif f == nil {\n\t\t// while this looks strange, we need to return a bare nil (of type nil) not\n\t\t// a nil value of type *os.File or nil won't be nil\n\t\treturn nil, e\n\t}\n\treturn f, e\n}\n\nfunc (OsFs) Remove(name string) error {\n\treturn os.Remove(name)\n}\n\nfunc (OsFs) RemoveAll(path string) error {\n\treturn os.RemoveAll(path)\n}\n\nfunc (OsFs) Rename(oldname, newname string) error {\n\treturn os.Rename(oldname, newname)\n}\n\nfunc (OsFs) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (OsFs) Chmod(name string, mode os.FileMode) error {\n\treturn os.Chmod(name, mode)\n}\n\nfunc (OsFs) Chown(name string, uid, gid int) error {\n\treturn os.Chown(name, uid, gid)\n}\n\nfunc (OsFs) Chtimes(name string, atime time.Time, mtime time.Time) error {\n\treturn os.Chtimes(name, atime, mtime)\n}\n\nfunc (OsFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tfi, err := os.Lstat(name)\n\treturn fi, true, err\n}\n\nfunc (OsFs) SymlinkIfPossible(oldname, newname string) error {\n\treturn os.Symlink(oldname, newname)\n}\n\nfunc (OsFs) ReadlinkIfPossible(name string) (string, error) {\n\treturn os.Readlink(name)\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 2.859375,
          "content": "// Copyright ©2015 The Go Authors\n// Copyright ©2015 Steve Francia <spf@spf13.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n)\n\n// readDirNames reads the directory named by dirname and returns\n// a sorted list of directory entries.\n// adapted from https://golang.org/src/path/filepath/path.go\nfunc readDirNames(fs Fs, dirname string) ([]string, error) {\n\tf, err := fs.Open(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnames, err := f.Readdirnames(-1)\n\tf.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsort.Strings(names)\n\treturn names, nil\n}\n\n// walk recursively descends path, calling walkFn\n// adapted from https://golang.org/src/path/filepath/path.go\nfunc walk(fs Fs, path string, info os.FileInfo, walkFn filepath.WalkFunc) error {\n\terr := walkFn(path, info, nil)\n\tif err != nil {\n\t\tif info.IsDir() && err == filepath.SkipDir {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif !info.IsDir() {\n\t\treturn nil\n\t}\n\n\tnames, err := readDirNames(fs, path)\n\tif err != nil {\n\t\treturn walkFn(path, info, err)\n\t}\n\n\tfor _, name := range names {\n\t\tfilename := filepath.Join(path, name)\n\t\tfileInfo, err := lstatIfPossible(fs, filename)\n\t\tif err != nil {\n\t\t\tif err := walkFn(filename, fileInfo, err); err != nil && err != filepath.SkipDir {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr = walk(fs, filename, fileInfo, walkFn)\n\t\t\tif err != nil {\n\t\t\t\tif !fileInfo.IsDir() || err != filepath.SkipDir {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// if the filesystem supports it, use Lstat, else use fs.Stat\nfunc lstatIfPossible(fs Fs, path string) (os.FileInfo, error) {\n\tif lfs, ok := fs.(Lstater); ok {\n\t\tfi, _, err := lfs.LstatIfPossible(path)\n\t\treturn fi, err\n\t}\n\treturn fs.Stat(path)\n}\n\n// Walk walks the file tree rooted at root, calling walkFn for each file or\n// directory in the tree, including root. All errors that arise visiting files\n// and directories are filtered by walkFn. The files are walked in lexical\n// order, which makes the output deterministic but means that for very\n// large directories Walk can be inefficient.\n// Walk does not follow symbolic links.\n\nfunc (a Afero) Walk(root string, walkFn filepath.WalkFunc) error {\n\treturn Walk(a.Fs, root, walkFn)\n}\n\nfunc Walk(fs Fs, root string, walkFn filepath.WalkFunc) error {\n\tinfo, err := lstatIfPossible(fs, root)\n\tif err != nil {\n\t\treturn walkFn(root, nil, err)\n\t}\n\treturn walk(fs, root, info, walkFn)\n}\n"
        },
        {
          "name": "path_test.go",
          "type": "blob",
          "size": 1.5712890625,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n// Copyright 2009 The Go Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestWalk(t *testing.T) {\n\tdefer removeAllTestFiles(t)\n\tvar testDir string\n\tfor i, fs := range Fss {\n\t\tif i == 0 {\n\t\t\ttestDir = setupTestDirRoot(t, fs)\n\t\t} else {\n\t\t\tsetupTestDirReusePath(t, fs, testDir)\n\t\t}\n\t}\n\n\toutputs := make([]string, len(Fss))\n\tfor i, fs := range Fss {\n\t\twalkFn := func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\tt.Error(\"walkFn err:\", err)\n\t\t\t}\n\t\t\tvar size int64\n\t\t\tif !info.IsDir() {\n\t\t\t\tsize = info.Size()\n\t\t\t}\n\t\t\toutputs[i] += fmt.Sprintln(path, info.Name(), size, info.IsDir(), err)\n\t\t\treturn nil\n\t\t}\n\t\terr := Walk(fs, testDir, walkFn)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\tfail := false\n\tfor i, o := range outputs {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif o != outputs[i-1] {\n\t\t\tfail = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif fail {\n\t\tt.Log(\"Walk outputs not equal!\")\n\t\tfor i, o := range outputs {\n\t\t\tt.Log(Fss[i].Name() + \"\\n\" + o)\n\t\t}\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "readonlyfs.go",
          "type": "blob",
          "size": 2.0703125,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar _ Lstater = (*ReadOnlyFs)(nil)\n\ntype ReadOnlyFs struct {\n\tsource Fs\n}\n\nfunc NewReadOnlyFs(source Fs) Fs {\n\treturn &ReadOnlyFs{source: source}\n}\n\nfunc (r *ReadOnlyFs) ReadDir(name string) ([]os.FileInfo, error) {\n\treturn ReadDir(r.source, name)\n}\n\nfunc (r *ReadOnlyFs) Chtimes(n string, a, m time.Time) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) Chmod(n string, m os.FileMode) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) Chown(n string, uid, gid int) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) Name() string {\n\treturn \"ReadOnlyFilter\"\n}\n\nfunc (r *ReadOnlyFs) Stat(name string) (os.FileInfo, error) {\n\treturn r.source.Stat(name)\n}\n\nfunc (r *ReadOnlyFs) LstatIfPossible(name string) (os.FileInfo, bool, error) {\n\tif lsf, ok := r.source.(Lstater); ok {\n\t\treturn lsf.LstatIfPossible(name)\n\t}\n\tfi, err := r.Stat(name)\n\treturn fi, false, err\n}\n\nfunc (r *ReadOnlyFs) SymlinkIfPossible(oldname, newname string) error {\n\treturn &os.LinkError{Op: \"symlink\", Old: oldname, New: newname, Err: ErrNoSymlink}\n}\n\nfunc (r *ReadOnlyFs) ReadlinkIfPossible(name string) (string, error) {\n\tif srdr, ok := r.source.(LinkReader); ok {\n\t\treturn srdr.ReadlinkIfPossible(name)\n\t}\n\n\treturn \"\", &os.PathError{Op: \"readlink\", Path: name, Err: ErrNoReadlink}\n}\n\nfunc (r *ReadOnlyFs) Rename(o, n string) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) RemoveAll(p string) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) Remove(n string) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tif flag&(os.O_WRONLY|syscall.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC) != 0 {\n\t\treturn nil, syscall.EPERM\n\t}\n\treturn r.source.OpenFile(name, flag, perm)\n}\n\nfunc (r *ReadOnlyFs) Open(n string) (File, error) {\n\treturn r.source.Open(n)\n}\n\nfunc (r *ReadOnlyFs) Mkdir(n string, p os.FileMode) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) MkdirAll(n string, p os.FileMode) error {\n\treturn syscall.EPERM\n}\n\nfunc (r *ReadOnlyFs) Create(n string) (File, error) {\n\treturn nil, syscall.EPERM\n}\n"
        },
        {
          "name": "regexpfs.go",
          "type": "blob",
          "size": 4.2666015625,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"regexp\"\n\t\"syscall\"\n\t\"time\"\n)\n\n// The RegexpFs filters files (not directories) by regular expression. Only\n// files matching the given regexp will be allowed, all others get a ENOENT error (\n// \"No such file or directory\").\ntype RegexpFs struct {\n\tre     *regexp.Regexp\n\tsource Fs\n}\n\nfunc NewRegexpFs(source Fs, re *regexp.Regexp) Fs {\n\treturn &RegexpFs{source: source, re: re}\n}\n\ntype RegexpFile struct {\n\tf  File\n\tre *regexp.Regexp\n}\n\nfunc (r *RegexpFs) matchesName(name string) error {\n\tif r.re == nil {\n\t\treturn nil\n\t}\n\tif r.re.MatchString(name) {\n\t\treturn nil\n\t}\n\treturn syscall.ENOENT\n}\n\nfunc (r *RegexpFs) dirOrMatches(name string) error {\n\tdir, err := IsDir(r.source, name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif dir {\n\t\treturn nil\n\t}\n\treturn r.matchesName(name)\n}\n\nfunc (r *RegexpFs) Chtimes(name string, a, m time.Time) error {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn err\n\t}\n\treturn r.source.Chtimes(name, a, m)\n}\n\nfunc (r *RegexpFs) Chmod(name string, mode os.FileMode) error {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn err\n\t}\n\treturn r.source.Chmod(name, mode)\n}\n\nfunc (r *RegexpFs) Chown(name string, uid, gid int) error {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn err\n\t}\n\treturn r.source.Chown(name, uid, gid)\n}\n\nfunc (r *RegexpFs) Name() string {\n\treturn \"RegexpFs\"\n}\n\nfunc (r *RegexpFs) Stat(name string) (os.FileInfo, error) {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn nil, err\n\t}\n\treturn r.source.Stat(name)\n}\n\nfunc (r *RegexpFs) Rename(oldname, newname string) error {\n\tdir, err := IsDir(r.source, oldname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif dir {\n\t\treturn nil\n\t}\n\tif err := r.matchesName(oldname); err != nil {\n\t\treturn err\n\t}\n\tif err := r.matchesName(newname); err != nil {\n\t\treturn err\n\t}\n\treturn r.source.Rename(oldname, newname)\n}\n\nfunc (r *RegexpFs) RemoveAll(p string) error {\n\tdir, err := IsDir(r.source, p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !dir {\n\t\tif err := r.matchesName(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn r.source.RemoveAll(p)\n}\n\nfunc (r *RegexpFs) Remove(name string) error {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn err\n\t}\n\treturn r.source.Remove(name)\n}\n\nfunc (r *RegexpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {\n\tif err := r.dirOrMatches(name); err != nil {\n\t\treturn nil, err\n\t}\n\treturn r.source.OpenFile(name, flag, perm)\n}\n\nfunc (r *RegexpFs) Open(name string) (File, error) {\n\tdir, err := IsDir(r.source, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !dir {\n\t\tif err := r.matchesName(name); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tf, err := r.source.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &RegexpFile{f: f, re: r.re}, nil\n}\n\nfunc (r *RegexpFs) Mkdir(n string, p os.FileMode) error {\n\treturn r.source.Mkdir(n, p)\n}\n\nfunc (r *RegexpFs) MkdirAll(n string, p os.FileMode) error {\n\treturn r.source.MkdirAll(n, p)\n}\n\nfunc (r *RegexpFs) Create(name string) (File, error) {\n\tif err := r.matchesName(name); err != nil {\n\t\treturn nil, err\n\t}\n\treturn r.source.Create(name)\n}\n\nfunc (f *RegexpFile) Close() error {\n\treturn f.f.Close()\n}\n\nfunc (f *RegexpFile) Read(s []byte) (int, error) {\n\treturn f.f.Read(s)\n}\n\nfunc (f *RegexpFile) ReadAt(s []byte, o int64) (int, error) {\n\treturn f.f.ReadAt(s, o)\n}\n\nfunc (f *RegexpFile) Seek(o int64, w int) (int64, error) {\n\treturn f.f.Seek(o, w)\n}\n\nfunc (f *RegexpFile) Write(s []byte) (int, error) {\n\treturn f.f.Write(s)\n}\n\nfunc (f *RegexpFile) WriteAt(s []byte, o int64) (int, error) {\n\treturn f.f.WriteAt(s, o)\n}\n\nfunc (f *RegexpFile) Name() string {\n\treturn f.f.Name()\n}\n\nfunc (f *RegexpFile) Readdir(c int) (fi []os.FileInfo, err error) {\n\tvar rfi []os.FileInfo\n\trfi, err = f.f.Readdir(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, i := range rfi {\n\t\tif i.IsDir() || f.re.MatchString(i.Name()) {\n\t\t\tfi = append(fi, i)\n\t\t}\n\t}\n\treturn fi, nil\n}\n\nfunc (f *RegexpFile) Readdirnames(c int) (n []string, err error) {\n\tfi, err := f.Readdir(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range fi {\n\t\tn = append(n, s.Name())\n\t}\n\treturn n, nil\n}\n\nfunc (f *RegexpFile) Stat() (os.FileInfo, error) {\n\treturn f.f.Stat()\n}\n\nfunc (f *RegexpFile) Sync() error {\n\treturn f.f.Sync()\n}\n\nfunc (f *RegexpFile) Truncate(s int64) error {\n\treturn f.f.Truncate(s)\n}\n\nfunc (f *RegexpFile) WriteString(s string) (int, error) {\n\treturn f.f.WriteString(s)\n}\n"
        },
        {
          "name": "ro_regexp_test.go",
          "type": "blob",
          "size": 2.1005859375,
          "content": "package afero\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestFilterReadOnly(t *testing.T) {\n\tfs := &ReadOnlyFs{source: &MemMapFs{}}\n\t_, err := fs.Create(\"/file.txt\")\n\tif err == nil {\n\t\tt.Errorf(\"Did not fail to create file\")\n\t}\n\t// t.Logf(\"ERR=%s\", err)\n}\n\nfunc TestFilterReadonlyRemoveAndRead(t *testing.T) {\n\tmfs := &MemMapFs{}\n\tfh, _ := mfs.Create(\"/file.txt\")\n\tfh.Write([]byte(\"content here\"))\n\tfh.Close()\n\n\tfs := NewReadOnlyFs(mfs)\n\terr := fs.Remove(\"/file.txt\")\n\tif err == nil {\n\t\tt.Errorf(\"Did not fail to remove file\")\n\t}\n\n\tfh, err = fs.Open(\"/file.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open file: %s\", err)\n\t}\n\n\tbuf := make([]byte, len(\"content here\"))\n\t_, err = fh.Read(buf)\n\tfh.Close()\n\tif string(buf) != \"content here\" {\n\t\tt.Errorf(\"Failed to read file: %s\", err)\n\t}\n\n\terr = mfs.Remove(\"/file.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"Failed to remove file\")\n\t}\n\n\tfh, err = fs.Open(\"/file.txt\")\n\tif err == nil {\n\t\tfh.Close()\n\t\tt.Errorf(\"File still present\")\n\t}\n}\n\nfunc TestFilterRegexp(t *testing.T) {\n\tfs := NewRegexpFs(&MemMapFs{}, regexp.MustCompile(`\\.txt$`))\n\t_, err := fs.Create(\"/file.html\")\n\tif err == nil {\n\t\tt.Errorf(\"Did not fail to create file\")\n\t}\n\t// t.Logf(\"ERR=%s\", err)\n}\n\nfunc TestFilterRORegexpChain(t *testing.T) {\n\trofs := &ReadOnlyFs{source: &MemMapFs{}}\n\tfs := &RegexpFs{re: regexp.MustCompile(`\\.txt$`), source: rofs}\n\t_, err := fs.Create(\"/file.txt\")\n\tif err == nil {\n\t\tt.Errorf(\"Did not fail to create file\")\n\t}\n\t// t.Logf(\"ERR=%s\", err)\n}\n\nfunc TestFilterRegexReadDir(t *testing.T) {\n\tmfs := &MemMapFs{}\n\tfs1 := &RegexpFs{re: regexp.MustCompile(`\\.txt$`), source: mfs}\n\tfs := &RegexpFs{re: regexp.MustCompile(`^a`), source: fs1}\n\n\tmfs.MkdirAll(\"/dir/sub\", 0o777)\n\tfor _, name := range []string{\"afile.txt\", \"afile.html\", \"bfile.txt\"} {\n\t\tfor _, dir := range []string{\"/dir/\", \"/dir/sub/\"} {\n\t\t\tfh, _ := mfs.Create(dir + name)\n\t\t\tfh.Close()\n\t\t}\n\t}\n\n\tfiles, _ := ReadDir(fs, \"/dir\")\n\tif len(files) != 2 { // afile.txt, sub\n\t\tt.Errorf(\"Got wrong number of files: %#v\", files)\n\t}\n\n\tf, _ := fs.Open(\"/dir/sub\")\n\tnames, _ := f.Readdirnames(-1)\n\tif len(names) != 1 {\n\t\tt.Errorf(\"Got wrong number of names: %v\", names)\n\t}\n}\n"
        },
        {
          "name": "sftpfs",
          "type": "tree",
          "content": null
        },
        {
          "name": "symlink.go",
          "type": "blob",
          "size": 1.9892578125,
          "content": "// Copyright © 2018 Steve Francia <spf@spf13.com>.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"errors\"\n)\n\n// Symlinker is an optional interface in Afero. It is only implemented by the\n// filesystems saying so.\n// It indicates support for 3 symlink related interfaces that implement the\n// behaviors of the os methods:\n//   - Lstat\n//   - Symlink, and\n//   - Readlink\ntype Symlinker interface {\n\tLstater\n\tLinker\n\tLinkReader\n}\n\n// Linker is an optional interface in Afero. It is only implemented by the\n// filesystems saying so.\n// It will call Symlink if the filesystem itself is, or it delegates to, the os filesystem,\n// or the filesystem otherwise supports Symlink's.\ntype Linker interface {\n\tSymlinkIfPossible(oldname, newname string) error\n}\n\n// ErrNoSymlink is the error that will be wrapped in an os.LinkError if a file system\n// does not support Symlink's either directly or through its delegated filesystem.\n// As expressed by support for the Linker interface.\nvar ErrNoSymlink = errors.New(\"symlink not supported\")\n\n// LinkReader is an optional interface in Afero. It is only implemented by the\n// filesystems saying so.\ntype LinkReader interface {\n\tReadlinkIfPossible(name string) (string, error)\n}\n\n// ErrNoReadlink is the error that will be wrapped in an os.Path if a file system\n// does not support the readlink operation either directly or through its delegated filesystem.\n// As expressed by support for the LinkReader interface.\nvar ErrNoReadlink = errors.New(\"readlink not supported\")\n"
        },
        {
          "name": "symlink_test.go",
          "type": "blob",
          "size": 5.03515625,
          "content": "package afero\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSymlinkIfPossible(t *testing.T) {\n\twd, _ := os.Getwd()\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\tosFs := &OsFs{}\n\n\tworkDir, err := TempDir(osFs, \"\", \"afero-symlink\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tosFs.RemoveAll(workDir)\n\t}()\n\n\tmemWorkDir := \"/sym\"\n\n\tmemFs := NewMemMapFs()\n\toverlayFs1 := &CopyOnWriteFs{base: osFs, layer: memFs}\n\toverlayFs2 := &CopyOnWriteFs{base: memFs, layer: osFs}\n\toverlayFsMemOnly := &CopyOnWriteFs{base: memFs, layer: NewMemMapFs()}\n\tbasePathFs := &BasePathFs{source: osFs, path: workDir}\n\tbasePathFsMem := &BasePathFs{source: memFs, path: memWorkDir}\n\troFs := &ReadOnlyFs{source: osFs}\n\troFsMem := &ReadOnlyFs{source: memFs}\n\n\tpathFileMem := filepath.Join(memWorkDir, \"aferom.txt\")\n\tosPath := filepath.Join(workDir, \"afero.txt\")\n\n\tWriteFile(osFs, osPath, []byte(\"Hi, Afero!\"), 0o777)\n\tWriteFile(memFs, filepath.Join(pathFileMem), []byte(\"Hi, Afero!\"), 0o777)\n\n\ttestLink := func(l Linker, source, destination string, output *string) {\n\t\tif fs, ok := l.(Fs); ok {\n\t\t\tdir := filepath.Dir(destination)\n\t\t\tif dir != \"\" {\n\t\t\t\tfs.MkdirAll(dir, 0o777)\n\t\t\t}\n\t\t}\n\n\t\terr := l.SymlinkIfPossible(source, destination)\n\t\tif (err == nil) && (output != nil) {\n\t\t\tt.Fatalf(\"Error creating symlink, succeeded when expecting error %v\", *output)\n\t\t} else if (err != nil) && (output == nil) {\n\t\t\tt.Fatalf(\"Error creating symlink, expected success, got %v\", err)\n\t\t} else if err != nil && err.Error() != *output && !strings.HasSuffix(err.Error(), *output) {\n\t\t\tt.Fatalf(\"Error creating symlink, expected error '%v', instead got output '%v'\", *output, err)\n\t\t} else {\n\t\t\t// test passed, if expecting a successful link, check the link with lstat if able\n\t\t\tif output == nil {\n\t\t\t\tif lst, ok := l.(Lstater); ok {\n\t\t\t\t\t_, ok, err := lst.LstatIfPossible(destination)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Fatalf(\"Error calling lstat on file after successful link, got: %v\", err)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Fatalf(\"Error calling lstat on file after successful link, result didn't use lstat (not link)\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnotSupported := ErrNoSymlink.Error()\n\n\ttestLink(osFs, osPath, filepath.Join(workDir, \"os/link.txt\"), nil)\n\ttestLink(overlayFs1, osPath, filepath.Join(workDir, \"overlay/link1.txt\"), &notSupported)\n\ttestLink(overlayFs2, pathFileMem, filepath.Join(workDir, \"overlay2/link2.txt\"), nil)\n\ttestLink(overlayFsMemOnly, pathFileMem, filepath.Join(memWorkDir, \"overlay3/link.txt\"), &notSupported)\n\ttestLink(basePathFs, \"afero.txt\", \"basepath/link.txt\", nil)\n\ttestLink(basePathFsMem, pathFileMem, \"link/file.txt\", &notSupported)\n\ttestLink(roFs, osPath, filepath.Join(workDir, \"ro/link.txt\"), &notSupported)\n\ttestLink(roFsMem, pathFileMem, filepath.Join(memWorkDir, \"ro/link.txt\"), &notSupported)\n}\n\nfunc TestReadlinkIfPossible(t *testing.T) {\n\twd, _ := os.Getwd()\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\tosFs := &OsFs{}\n\n\tworkDir, err := TempDir(osFs, \"\", \"afero-readlink\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tosFs.RemoveAll(workDir)\n\t}()\n\n\tmemWorkDir := \"/read\"\n\n\tmemFs := NewMemMapFs()\n\toverlayFs1 := &CopyOnWriteFs{base: osFs, layer: memFs}\n\toverlayFs2 := &CopyOnWriteFs{base: memFs, layer: osFs}\n\toverlayFsMemOnly := &CopyOnWriteFs{base: memFs, layer: NewMemMapFs()}\n\tbasePathFs := &BasePathFs{source: osFs, path: workDir}\n\tbasePathFsMem := &BasePathFs{source: memFs, path: memWorkDir}\n\troFs := &ReadOnlyFs{source: osFs}\n\troFsMem := &ReadOnlyFs{source: memFs}\n\n\tpathFileMem := filepath.Join(memWorkDir, \"aferom.txt\")\n\tosPath := filepath.Join(workDir, \"afero.txt\")\n\n\tWriteFile(osFs, osPath, []byte(\"Hi, Afero!\"), 0o777)\n\tWriteFile(memFs, filepath.Join(pathFileMem), []byte(\"Hi, Afero!\"), 0o777)\n\n\tcreateLink := func(l Linker, source, destination string) error {\n\t\tif fs, ok := l.(Fs); ok {\n\t\t\tdir := filepath.Dir(destination)\n\t\t\tif dir != \"\" {\n\t\t\t\tfs.MkdirAll(dir, 0o777)\n\t\t\t}\n\t\t}\n\n\t\treturn l.SymlinkIfPossible(source, destination)\n\t}\n\n\ttestRead := func(r LinkReader, name string, output *string) {\n\t\t_, err := r.ReadlinkIfPossible(name)\n\t\tif (err != nil) && (output == nil) {\n\t\t\tt.Fatalf(\"Error reading link, expected success, got error: %v\", err)\n\t\t} else if (err == nil) && (output != nil) {\n\t\t\tt.Fatalf(\"Error reading link, succeeded when expecting error: %v\", *output)\n\t\t} else if err != nil && err.Error() != *output && !strings.HasSuffix(err.Error(), *output) {\n\t\t\tt.Fatalf(\"Error reading link, expected error '%v', instead received '%v'\", *output, err)\n\t\t}\n\t}\n\n\tnotSupported := ErrNoReadlink.Error()\n\n\terr = createLink(osFs, osPath, filepath.Join(workDir, \"os/link.txt\"))\n\tif err != nil {\n\t\tt.Fatal(\"Error creating test link: \", err)\n\t}\n\n\ttestRead(osFs, filepath.Join(workDir, \"os/link.txt\"), nil)\n\ttestRead(overlayFs1, filepath.Join(workDir, \"os/link.txt\"), nil)\n\ttestRead(overlayFs2, filepath.Join(workDir, \"os/link.txt\"), nil)\n\ttestRead(overlayFsMemOnly, pathFileMem, &notSupported)\n\ttestRead(basePathFs, \"os/link.txt\", nil)\n\ttestRead(basePathFsMem, pathFileMem, &notSupported)\n\ttestRead(roFs, filepath.Join(workDir, \"os/link.txt\"), nil)\n\ttestRead(roFsMem, pathFileMem, &notSupported)\n}\n"
        },
        {
          "name": "tarfs",
          "type": "tree",
          "content": null
        },
        {
          "name": "unionFile.go",
          "type": "blob",
          "size": 6.853515625,
          "content": "package afero\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n)\n\n// The UnionFile implements the afero.File interface and will be returned\n// when reading a directory present at least in the overlay or opening a file\n// for writing.\n//\n// The calls to\n// Readdir() and Readdirnames() merge the file os.FileInfo / names from the\n// base and the overlay - for files present in both layers, only those\n// from the overlay will be used.\n//\n// When opening files for writing (Create() / OpenFile() with the right flags)\n// the operations will be done in both layers, starting with the overlay. A\n// successful read in the overlay will move the cursor position in the base layer\n// by the number of bytes read.\ntype UnionFile struct {\n\tBase   File\n\tLayer  File\n\tMerger DirsMerger\n\toff    int\n\tfiles  []os.FileInfo\n}\n\nfunc (f *UnionFile) Close() error {\n\t// first close base, so we have a newer timestamp in the overlay. If we'd close\n\t// the overlay first, we'd get a cacheStale the next time we access this file\n\t// -> cache would be useless ;-)\n\tif f.Base != nil {\n\t\tf.Base.Close()\n\t}\n\tif f.Layer != nil {\n\t\treturn f.Layer.Close()\n\t}\n\treturn BADFD\n}\n\nfunc (f *UnionFile) Read(s []byte) (int, error) {\n\tif f.Layer != nil {\n\t\tn, err := f.Layer.Read(s)\n\t\tif (err == nil || err == io.EOF) && f.Base != nil {\n\t\t\t// advance the file position also in the base file, the next\n\t\t\t// call may be a write at this position (or a seek with SEEK_CUR)\n\t\t\tif _, seekErr := f.Base.Seek(int64(n), io.SeekCurrent); seekErr != nil {\n\t\t\t\t// only overwrite err in case the seek fails: we need to\n\t\t\t\t// report an eventual io.EOF to the caller\n\t\t\t\terr = seekErr\n\t\t\t}\n\t\t}\n\t\treturn n, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Read(s)\n\t}\n\treturn 0, BADFD\n}\n\nfunc (f *UnionFile) ReadAt(s []byte, o int64) (int, error) {\n\tif f.Layer != nil {\n\t\tn, err := f.Layer.ReadAt(s, o)\n\t\tif (err == nil || err == io.EOF) && f.Base != nil {\n\t\t\t_, err = f.Base.Seek(o+int64(n), io.SeekStart)\n\t\t}\n\t\treturn n, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.ReadAt(s, o)\n\t}\n\treturn 0, BADFD\n}\n\nfunc (f *UnionFile) Seek(o int64, w int) (pos int64, err error) {\n\tif f.Layer != nil {\n\t\tpos, err = f.Layer.Seek(o, w)\n\t\tif (err == nil || err == io.EOF) && f.Base != nil {\n\t\t\t_, err = f.Base.Seek(o, w)\n\t\t}\n\t\treturn pos, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Seek(o, w)\n\t}\n\treturn 0, BADFD\n}\n\nfunc (f *UnionFile) Write(s []byte) (n int, err error) {\n\tif f.Layer != nil {\n\t\tn, err = f.Layer.Write(s)\n\t\tif err == nil && f.Base != nil { // hmm, do we have fixed size files where a write may hit the EOF mark?\n\t\t\t_, err = f.Base.Write(s)\n\t\t}\n\t\treturn n, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Write(s)\n\t}\n\treturn 0, BADFD\n}\n\nfunc (f *UnionFile) WriteAt(s []byte, o int64) (n int, err error) {\n\tif f.Layer != nil {\n\t\tn, err = f.Layer.WriteAt(s, o)\n\t\tif err == nil && f.Base != nil {\n\t\t\t_, err = f.Base.WriteAt(s, o)\n\t\t}\n\t\treturn n, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.WriteAt(s, o)\n\t}\n\treturn 0, BADFD\n}\n\nfunc (f *UnionFile) Name() string {\n\tif f.Layer != nil {\n\t\treturn f.Layer.Name()\n\t}\n\treturn f.Base.Name()\n}\n\n// DirsMerger is how UnionFile weaves two directories together.\n// It takes the FileInfo slices from the layer and the base and returns a\n// single view.\ntype DirsMerger func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error)\n\nvar defaultUnionMergeDirsFn = func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error) {\n\tfiles := make(map[string]os.FileInfo)\n\n\tfor _, fi := range lofi {\n\t\tfiles[fi.Name()] = fi\n\t}\n\n\tfor _, fi := range bofi {\n\t\tif _, exists := files[fi.Name()]; !exists {\n\t\t\tfiles[fi.Name()] = fi\n\t\t}\n\t}\n\n\trfi := make([]os.FileInfo, len(files))\n\n\ti := 0\n\tfor _, fi := range files {\n\t\trfi[i] = fi\n\t\ti++\n\t}\n\n\treturn rfi, nil\n}\n\n// Readdir will weave the two directories together and\n// return a single view of the overlayed directories.\n// At the end of the directory view, the error is io.EOF if c > 0.\nfunc (f *UnionFile) Readdir(c int) (ofi []os.FileInfo, err error) {\n\tvar merge DirsMerger = f.Merger\n\tif merge == nil {\n\t\tmerge = defaultUnionMergeDirsFn\n\t}\n\n\tif f.off == 0 {\n\t\tvar lfi []os.FileInfo\n\t\tif f.Layer != nil {\n\t\t\tlfi, err = f.Layer.Readdir(-1)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tvar bfi []os.FileInfo\n\t\tif f.Base != nil {\n\t\t\tbfi, err = f.Base.Readdir(-1)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t}\n\t\tmerged, err := merge(lfi, bfi)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tf.files = append(f.files, merged...)\n\t}\n\tfiles := f.files[f.off:]\n\n\tif c <= 0 {\n\t\treturn files, nil\n\t}\n\n\tif len(files) == 0 {\n\t\treturn nil, io.EOF\n\t}\n\n\tif c > len(files) {\n\t\tc = len(files)\n\t}\n\n\tdefer func() { f.off += c }()\n\treturn files[:c], nil\n}\n\nfunc (f *UnionFile) Readdirnames(c int) ([]string, error) {\n\trfi, err := f.Readdir(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar names []string\n\tfor _, fi := range rfi {\n\t\tnames = append(names, fi.Name())\n\t}\n\treturn names, nil\n}\n\nfunc (f *UnionFile) Stat() (os.FileInfo, error) {\n\tif f.Layer != nil {\n\t\treturn f.Layer.Stat()\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Stat()\n\t}\n\treturn nil, BADFD\n}\n\nfunc (f *UnionFile) Sync() (err error) {\n\tif f.Layer != nil {\n\t\terr = f.Layer.Sync()\n\t\tif err == nil && f.Base != nil {\n\t\t\terr = f.Base.Sync()\n\t\t}\n\t\treturn err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Sync()\n\t}\n\treturn BADFD\n}\n\nfunc (f *UnionFile) Truncate(s int64) (err error) {\n\tif f.Layer != nil {\n\t\terr = f.Layer.Truncate(s)\n\t\tif err == nil && f.Base != nil {\n\t\t\terr = f.Base.Truncate(s)\n\t\t}\n\t\treturn err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.Truncate(s)\n\t}\n\treturn BADFD\n}\n\nfunc (f *UnionFile) WriteString(s string) (n int, err error) {\n\tif f.Layer != nil {\n\t\tn, err = f.Layer.WriteString(s)\n\t\tif err == nil && f.Base != nil {\n\t\t\t_, err = f.Base.WriteString(s)\n\t\t}\n\t\treturn n, err\n\t}\n\tif f.Base != nil {\n\t\treturn f.Base.WriteString(s)\n\t}\n\treturn 0, BADFD\n}\n\nfunc copyFile(base Fs, layer Fs, name string, bfh File) error {\n\t// First make sure the directory exists\n\texists, err := Exists(layer, filepath.Dir(name))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !exists {\n\t\terr = layer.MkdirAll(filepath.Dir(name), 0o777) // FIXME?\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Create the file on the overlay\n\tlfh, err := layer.Create(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tn, err := io.Copy(lfh, bfh)\n\tif err != nil {\n\t\t// If anything fails, clean up the file\n\t\tlayer.Remove(name)\n\t\tlfh.Close()\n\t\treturn err\n\t}\n\n\tbfi, err := bfh.Stat()\n\tif err != nil || bfi.Size() != n {\n\t\tlayer.Remove(name)\n\t\tlfh.Close()\n\t\treturn syscall.EIO\n\t}\n\n\terr = lfh.Close()\n\tif err != nil {\n\t\tlayer.Remove(name)\n\t\tlfh.Close()\n\t\treturn err\n\t}\n\treturn layer.Chtimes(name, bfi.ModTime(), bfi.ModTime())\n}\n\nfunc copyToLayer(base Fs, layer Fs, name string) error {\n\tbfh, err := base.Open(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer bfh.Close()\n\n\treturn copyFile(base, layer, name, bfh)\n}\n\nfunc copyFileToLayer(base Fs, layer Fs, name string, flag int, perm os.FileMode) error {\n\tbfh, err := base.OpenFile(name, flag, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer bfh.Close()\n\n\treturn copyFile(base, layer, name, bfh)\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 7.1630859375,
          "content": "// Copyright ©2015 Steve Francia <spf@spf13.com>\n// Portions Copyright ©2015 The Hugo Authors\n// Portions Copyright 2016-present Bjørn Erik Pedersen <bjorn.erik.pedersen@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage afero\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"golang.org/x/text/runes\"\n\t\"golang.org/x/text/transform\"\n\t\"golang.org/x/text/unicode/norm\"\n)\n\n// Filepath separator defined by os.Separator.\nconst FilePathSeparator = string(filepath.Separator)\n\n// Takes a reader and a path and writes the content\nfunc (a Afero) WriteReader(path string, r io.Reader) (err error) {\n\treturn WriteReader(a.Fs, path, r)\n}\n\nfunc WriteReader(fs Fs, path string, r io.Reader) (err error) {\n\tdir, _ := filepath.Split(path)\n\tospath := filepath.FromSlash(dir)\n\n\tif ospath != \"\" {\n\t\terr = fs.MkdirAll(ospath, 0o777) // rwx, rw, r\n\t\tif err != nil {\n\t\t\tif err != os.ErrExist {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tfile, err := fs.Create(path)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, r)\n\treturn\n}\n\n// Same as WriteReader but checks to see if file/directory already exists.\nfunc (a Afero) SafeWriteReader(path string, r io.Reader) (err error) {\n\treturn SafeWriteReader(a.Fs, path, r)\n}\n\nfunc SafeWriteReader(fs Fs, path string, r io.Reader) (err error) {\n\tdir, _ := filepath.Split(path)\n\tospath := filepath.FromSlash(dir)\n\n\tif ospath != \"\" {\n\t\terr = fs.MkdirAll(ospath, 0o777) // rwx, rw, r\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\texists, err := Exists(fs, path)\n\tif err != nil {\n\t\treturn\n\t}\n\tif exists {\n\t\treturn fmt.Errorf(\"%v already exists\", path)\n\t}\n\n\tfile, err := fs.Create(path)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, r)\n\treturn\n}\n\nfunc (a Afero) GetTempDir(subPath string) string {\n\treturn GetTempDir(a.Fs, subPath)\n}\n\n// GetTempDir returns the default temp directory with trailing slash\n// if subPath is not empty then it will be created recursively with mode 777 rwx rwx rwx\nfunc GetTempDir(fs Fs, subPath string) string {\n\taddSlash := func(p string) string {\n\t\tif FilePathSeparator != p[len(p)-1:] {\n\t\t\tp = p + FilePathSeparator\n\t\t}\n\t\treturn p\n\t}\n\tdir := addSlash(os.TempDir())\n\n\tif subPath != \"\" {\n\t\t// preserve windows backslash :-(\n\t\tif FilePathSeparator == \"\\\\\" {\n\t\t\tsubPath = strings.Replace(subPath, \"\\\\\", \"____\", -1)\n\t\t}\n\t\tdir = dir + UnicodeSanitize((subPath))\n\t\tif FilePathSeparator == \"\\\\\" {\n\t\t\tdir = strings.Replace(dir, \"____\", \"\\\\\", -1)\n\t\t}\n\n\t\tif exists, _ := Exists(fs, dir); exists {\n\t\t\treturn addSlash(dir)\n\t\t}\n\n\t\terr := fs.MkdirAll(dir, 0o777)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdir = addSlash(dir)\n\t}\n\treturn dir\n}\n\n// Rewrite string to remove non-standard path characters\nfunc UnicodeSanitize(s string) string {\n\tsource := []rune(s)\n\ttarget := make([]rune, 0, len(source))\n\n\tfor _, r := range source {\n\t\tif unicode.IsLetter(r) ||\n\t\t\tunicode.IsDigit(r) ||\n\t\t\tunicode.IsMark(r) ||\n\t\t\tr == '.' ||\n\t\t\tr == '/' ||\n\t\t\tr == '\\\\' ||\n\t\t\tr == '_' ||\n\t\t\tr == '-' ||\n\t\t\tr == '%' ||\n\t\t\tr == ' ' ||\n\t\t\tr == '#' {\n\t\t\ttarget = append(target, r)\n\t\t}\n\t}\n\n\treturn string(target)\n}\n\n// Transform characters with accents into plain forms.\nfunc NeuterAccents(s string) string {\n\tt := transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)), norm.NFC)\n\tresult, _, _ := transform.String(t, string(s))\n\n\treturn result\n}\n\nfunc (a Afero) FileContainsBytes(filename string, subslice []byte) (bool, error) {\n\treturn FileContainsBytes(a.Fs, filename, subslice)\n}\n\n// Check if a file contains a specified byte slice.\nfunc FileContainsBytes(fs Fs, filename string, subslice []byte) (bool, error) {\n\tf, err := fs.Open(filename)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer f.Close()\n\n\treturn readerContainsAny(f, subslice), nil\n}\n\nfunc (a Afero) FileContainsAnyBytes(filename string, subslices [][]byte) (bool, error) {\n\treturn FileContainsAnyBytes(a.Fs, filename, subslices)\n}\n\n// Check if a file contains any of the specified byte slices.\nfunc FileContainsAnyBytes(fs Fs, filename string, subslices [][]byte) (bool, error) {\n\tf, err := fs.Open(filename)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer f.Close()\n\n\treturn readerContainsAny(f, subslices...), nil\n}\n\n// readerContains reports whether any of the subslices is within r.\nfunc readerContainsAny(r io.Reader, subslices ...[]byte) bool {\n\tif r == nil || len(subslices) == 0 {\n\t\treturn false\n\t}\n\n\tlargestSlice := 0\n\n\tfor _, sl := range subslices {\n\t\tif len(sl) > largestSlice {\n\t\t\tlargestSlice = len(sl)\n\t\t}\n\t}\n\n\tif largestSlice == 0 {\n\t\treturn false\n\t}\n\n\tbufflen := largestSlice * 4\n\thalflen := bufflen / 2\n\tbuff := make([]byte, bufflen)\n\tvar err error\n\tvar n, i int\n\n\tfor {\n\t\ti++\n\t\tif i == 1 {\n\t\t\tn, err = io.ReadAtLeast(r, buff[:halflen], halflen)\n\t\t} else {\n\t\t\tif i != 2 {\n\t\t\t\t// shift left to catch overlapping matches\n\t\t\t\tcopy(buff[:], buff[halflen:])\n\t\t\t}\n\t\t\tn, err = io.ReadAtLeast(r, buff[halflen:], halflen)\n\t\t}\n\n\t\tif n > 0 {\n\t\t\tfor _, sl := range subslices {\n\t\t\t\tif bytes.Contains(buff, sl) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (a Afero) DirExists(path string) (bool, error) {\n\treturn DirExists(a.Fs, path)\n}\n\n// DirExists checks if a path exists and is a directory.\nfunc DirExists(fs Fs, path string) (bool, error) {\n\tfi, err := fs.Stat(path)\n\tif err == nil && fi.IsDir() {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc (a Afero) IsDir(path string) (bool, error) {\n\treturn IsDir(a.Fs, path)\n}\n\n// IsDir checks if a given path is a directory.\nfunc IsDir(fs Fs, path string) (bool, error) {\n\tfi, err := fs.Stat(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn fi.IsDir(), nil\n}\n\nfunc (a Afero) IsEmpty(path string) (bool, error) {\n\treturn IsEmpty(a.Fs, path)\n}\n\n// IsEmpty checks if a given file or directory is empty.\nfunc IsEmpty(fs Fs, path string) (bool, error) {\n\tif b, _ := Exists(fs, path); !b {\n\t\treturn false, fmt.Errorf(\"%q path does not exist\", path)\n\t}\n\tfi, err := fs.Stat(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif fi.IsDir() {\n\t\tf, err := fs.Open(path)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdefer f.Close()\n\t\tlist, err := f.Readdir(-1)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn len(list) == 0, nil\n\t}\n\treturn fi.Size() == 0, nil\n}\n\nfunc (a Afero) Exists(path string) (bool, error) {\n\treturn Exists(a.Fs, path)\n}\n\n// Check if a file or directory exists.\nfunc Exists(fs Fs, path string) (bool, error) {\n\t_, err := fs.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc FullBaseFsPath(basePathFs *BasePathFs, relativePath string) string {\n\tcombinedPath := filepath.Join(basePathFs.path, relativePath)\n\tif parent, ok := basePathFs.source.(*BasePathFs); ok {\n\t\treturn FullBaseFsPath(parent, combinedPath)\n\t}\n\n\treturn combinedPath\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 12.572265625,
          "content": "// Copyright ©2015 Steve Francia <spf@spf13.com>\n// Portions Copyright ©2015 The Hugo Authors\n//\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage afero\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar testFS = new(MemMapFs)\n\nfunc TestDirExists(t *testing.T) {\n\ttype test struct {\n\t\tinput    string\n\t\texpected bool\n\t}\n\n\t// First create a couple directories so there is something in the filesystem\n\t// testFS := new(MemMapFs)\n\ttestFS.MkdirAll(\"/foo/bar\", 0o777)\n\n\tdata := []test{\n\t\t{\".\", true},\n\t\t{\"./\", true},\n\t\t{\"..\", true},\n\t\t{\"../\", true},\n\t\t{\"./..\", true},\n\t\t{\"./../\", true},\n\t\t{\"/foo/\", true},\n\t\t{\"/foo\", true},\n\t\t{\"/foo/bar\", true},\n\t\t{\"/foo/bar/\", true},\n\t\t{\"/\", true},\n\t\t{\"/some-really-random-directory-name\", false},\n\t\t{\"/some/really/random/directory/name\", false},\n\t\t{\"./some-really-random-local-directory-name\", false},\n\t\t{\"./some/really/random/local/directory/name\", false},\n\t}\n\n\tfor i, d := range data {\n\t\texists, _ := DirExists(testFS, filepath.FromSlash(d.input))\n\t\tif d.expected != exists {\n\t\t\tt.Errorf(\"Test %d %q failed. Expected %t got %t\", i, d.input, d.expected, exists)\n\t\t}\n\t}\n}\n\nfunc TestIsDir(t *testing.T) {\n\ttestFS = new(MemMapFs)\n\n\ttype test struct {\n\t\tinput    string\n\t\texpected bool\n\t}\n\tdata := []test{\n\t\t{\"./\", true},\n\t\t{\"/\", true},\n\t\t{\"./this-directory-does-not-existi\", false},\n\t\t{\"/this-absolute-directory/does-not-exist\", false},\n\t}\n\n\tfor i, d := range data {\n\n\t\texists, _ := IsDir(testFS, d.input)\n\t\tif d.expected != exists {\n\t\t\tt.Errorf(\"Test %d failed. Expected %t got %t\", i, d.expected, exists)\n\t\t}\n\t}\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\ttestFS = new(MemMapFs)\n\n\tzeroSizedFile, _ := createZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(zeroSizedFile)\n\tnonZeroSizedFile, _ := createNonZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(nonZeroSizedFile)\n\temptyDirectory, _ := createEmptyTempDir()\n\tdefer deleteTempDir(emptyDirectory)\n\tnonEmptyZeroLengthFilesDirectory, _ := createTempDirWithZeroLengthFiles()\n\tdefer deleteTempDir(nonEmptyZeroLengthFilesDirectory)\n\tnonEmptyNonZeroLengthFilesDirectory, _ := createTempDirWithNonZeroLengthFiles()\n\tdefer deleteTempDir(nonEmptyNonZeroLengthFilesDirectory)\n\tnonExistentFile := os.TempDir() + \"/this-file-does-not-exist.txt\"\n\tnonExistentDir := os.TempDir() + \"/this/direcotry/does/not/exist/\"\n\n\tfileDoesNotExist := fmt.Errorf(\"%q path does not exist\", nonExistentFile)\n\tdirDoesNotExist := fmt.Errorf(\"%q path does not exist\", nonExistentDir)\n\n\ttype test struct {\n\t\tinput          string\n\t\texpectedResult bool\n\t\texpectedErr    error\n\t}\n\n\tdata := []test{\n\t\t{zeroSizedFile.Name(), true, nil},\n\t\t{nonZeroSizedFile.Name(), false, nil},\n\t\t{emptyDirectory, true, nil},\n\t\t{nonEmptyZeroLengthFilesDirectory, false, nil},\n\t\t{nonEmptyNonZeroLengthFilesDirectory, false, nil},\n\t\t{nonExistentFile, false, fileDoesNotExist},\n\t\t{nonExistentDir, false, dirDoesNotExist},\n\t}\n\tfor i, d := range data {\n\t\texists, err := IsEmpty(testFS, d.input)\n\t\tif d.expectedResult != exists {\n\t\t\tt.Errorf(\"Test %d %q failed exists. Expected result %t got %t\", i, d.input, d.expectedResult, exists)\n\t\t}\n\t\tif d.expectedErr != nil {\n\t\t\tif d.expectedErr.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"Test %d failed with err. Expected %q(%#v) got %q(%#v)\", i, d.expectedErr, d.expectedErr, err, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif d.expectedErr != err {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected error %q(%#v) got %q(%#v)\", i, d.expectedErr, d.expectedErr, err, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReaderContains(t *testing.T) {\n\tfor i, this := range []struct {\n\t\tv1     string\n\t\tv2     [][]byte\n\t\texpect bool\n\t}{\n\t\t{\"abc\", [][]byte{[]byte(\"a\")}, true},\n\t\t{\"abc\", [][]byte{[]byte(\"b\")}, true},\n\t\t{\"abcdefg\", [][]byte{[]byte(\"efg\")}, true},\n\t\t{\"abc\", [][]byte{[]byte(\"d\")}, false},\n\t\t{\"abc\", [][]byte{[]byte(\"d\"), []byte(\"e\")}, false},\n\t\t{\"abc\", [][]byte{[]byte(\"d\"), []byte(\"a\")}, true},\n\t\t{\"abc\", [][]byte{[]byte(\"b\"), []byte(\"e\")}, true},\n\t\t{\"\", nil, false},\n\t\t{\"\", [][]byte{[]byte(\"a\")}, false},\n\t\t{\"a\", [][]byte{[]byte(\"\")}, false},\n\t\t{\"\", [][]byte{[]byte(\"\")}, false},\n\t} {\n\t\tresult := readerContainsAny(strings.NewReader(this.v1), this.v2...)\n\t\tif result != this.expect {\n\t\t\tt.Errorf(\"[%d] readerContains: got %t but expected %t\", i, result, this.expect)\n\t\t}\n\t}\n\n\tif readerContainsAny(nil, []byte(\"a\")) {\n\t\tt.Error(\"readerContains with nil reader\")\n\t}\n\n\tif readerContainsAny(nil, nil) {\n\t\tt.Error(\"readerContains with nil arguments\")\n\t}\n}\n\nfunc createZeroSizedFileInTempDir() (File, error) {\n\tfilePrefix := \"_path_test_\"\n\tf, e := TempFile(testFS, \"\", filePrefix) // dir is os.TempDir()\n\tif e != nil {\n\t\t// if there was an error no file was created.\n\t\t// => no requirement to delete the file\n\t\treturn nil, e\n\t}\n\treturn f, nil\n}\n\nfunc createNonZeroSizedFileInTempDir() (File, error) {\n\tf, err := createZeroSizedFileInTempDir()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbyteString := []byte(\"byteString\")\n\terr = WriteFile(testFS, f.Name(), byteString, 0o644)\n\tif err != nil {\n\t\t// delete the file\n\t\tdeleteFileInTempDir(f)\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\nfunc deleteFileInTempDir(f File) {\n\terr := testFS.Remove(f.Name())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc createEmptyTempDir() (string, error) {\n\tdirPrefix := \"_dir_prefix_\"\n\td, e := TempDir(testFS, \"\", dirPrefix) // will be in os.TempDir()\n\tif e != nil {\n\t\t// no directory to delete - it was never created\n\t\treturn \"\", e\n\t}\n\treturn d, nil\n}\n\nfunc createTempDirWithZeroLengthFiles() (string, error) {\n\td, dirErr := createEmptyTempDir()\n\tif dirErr != nil {\n\t\treturn \"\", dirErr\n\t}\n\tfilePrefix := \"_path_test_\"\n\t_, fileErr := TempFile(testFS, d, filePrefix) // dir is os.TempDir()\n\tif fileErr != nil {\n\t\t// if there was an error no file was created.\n\t\t// but we need to remove the directory to clean-up\n\t\tdeleteTempDir(d)\n\t\treturn \"\", fileErr\n\t}\n\t// the dir now has one, zero length file in it\n\treturn d, nil\n}\n\nfunc createTempDirWithNonZeroLengthFiles() (string, error) {\n\td, dirErr := createEmptyTempDir()\n\tif dirErr != nil {\n\t\treturn \"\", dirErr\n\t}\n\tfilePrefix := \"_path_test_\"\n\tf, fileErr := TempFile(testFS, d, filePrefix) // dir is os.TempDir()\n\tif fileErr != nil {\n\t\t// if there was an error no file was created.\n\t\t// but we need to remove the directory to clean-up\n\t\tdeleteTempDir(d)\n\t\treturn \"\", fileErr\n\t}\n\tbyteString := []byte(\"byteString\")\n\tfileErr = WriteFile(testFS, f.Name(), byteString, 0o644)\n\tif fileErr != nil {\n\t\t// delete the file\n\t\tdeleteFileInTempDir(f)\n\t\t// also delete the directory\n\t\tdeleteTempDir(d)\n\t\treturn \"\", fileErr\n\t}\n\n\t// the dir now has one, zero length file in it\n\treturn d, nil\n}\n\nfunc TestExists(t *testing.T) {\n\tzeroSizedFile, _ := createZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(zeroSizedFile)\n\tnonZeroSizedFile, _ := createNonZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(nonZeroSizedFile)\n\temptyDirectory, _ := createEmptyTempDir()\n\tdefer deleteTempDir(emptyDirectory)\n\tnonExistentFile := os.TempDir() + \"/this-file-does-not-exist.txt\"\n\tnonExistentDir := os.TempDir() + \"/this/direcotry/does/not/exist/\"\n\n\ttype test struct {\n\t\tinput          string\n\t\texpectedResult bool\n\t\texpectedErr    error\n\t}\n\n\tdata := []test{\n\t\t{zeroSizedFile.Name(), true, nil},\n\t\t{nonZeroSizedFile.Name(), true, nil},\n\t\t{emptyDirectory, true, nil},\n\t\t{nonExistentFile, false, nil},\n\t\t{nonExistentDir, false, nil},\n\t}\n\tfor i, d := range data {\n\t\texists, err := Exists(testFS, d.input)\n\t\tif d.expectedResult != exists {\n\t\t\tt.Errorf(\"Test %d failed. Expected result %t got %t\", i, d.expectedResult, exists)\n\t\t}\n\t\tif d.expectedErr != err {\n\t\t\tt.Errorf(\"Test %d failed. Expected %q got %q\", i, d.expectedErr, err)\n\t\t}\n\t}\n}\n\nfunc TestSafeWriteToDisk(t *testing.T) {\n\temptyFile, _ := createZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(emptyFile)\n\ttmpDir, _ := createEmptyTempDir()\n\tdefer deleteTempDir(tmpDir)\n\n\trandomString := \"This is a random string!\"\n\treader := strings.NewReader(randomString)\n\n\tfileExists := fmt.Errorf(\"%v already exists\", emptyFile.Name())\n\n\ttype test struct {\n\t\tfilename    string\n\t\texpectedErr error\n\t}\n\n\tnow := time.Now().Unix()\n\tnowStr := strconv.FormatInt(now, 10)\n\tdata := []test{\n\t\t{emptyFile.Name(), fileExists},\n\t\t{tmpDir + \"/\" + nowStr, nil},\n\t}\n\n\tfor i, d := range data {\n\t\te := SafeWriteReader(testFS, d.filename, reader)\n\t\tif d.expectedErr != nil {\n\t\t\tif d.expectedErr.Error() != e.Error() {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected error %q but got %q\", i, d.expectedErr.Error(), e.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tif d.expectedErr != e {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected %q but got %q\", i, d.expectedErr, e)\n\t\t\t}\n\t\t\tcontents, _ := ReadFile(testFS, d.filename)\n\t\t\tif randomString != string(contents) {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected contents %q but got %q\", i, randomString, string(contents))\n\t\t\t}\n\t\t}\n\t\treader.Seek(0, 0)\n\t}\n}\n\nfunc TestWriteToDisk(t *testing.T) {\n\temptyFile, _ := createZeroSizedFileInTempDir()\n\tdefer deleteFileInTempDir(emptyFile)\n\ttmpDir, _ := createEmptyTempDir()\n\tdefer deleteTempDir(tmpDir)\n\n\trandomString := \"This is a random string!\"\n\treader := strings.NewReader(randomString)\n\n\ttype test struct {\n\t\tfilename    string\n\t\texpectedErr error\n\t}\n\n\tnow := time.Now().Unix()\n\tnowStr := strconv.FormatInt(now, 10)\n\tdata := []test{\n\t\t{emptyFile.Name(), nil},\n\t\t{tmpDir + \"/\" + nowStr, nil},\n\t}\n\n\tfor i, d := range data {\n\t\te := WriteReader(testFS, d.filename, reader)\n\t\tif d.expectedErr != e {\n\t\t\tt.Errorf(\"Test %d failed. WriteToDisk Error Expected %q but got %q\", i, d.expectedErr, e)\n\t\t}\n\t\tcontents, e := ReadFile(testFS, d.filename)\n\t\tif e != nil {\n\t\t\tt.Errorf(\"Test %d failed. Could not read file %s. Reason: %s\\n\", i, d.filename, e)\n\t\t}\n\t\tif randomString != string(contents) {\n\t\t\tt.Errorf(\"Test %d failed. Expected contents %q but got %q\", i, randomString, string(contents))\n\t\t}\n\t\treader.Seek(0, 0)\n\t}\n}\n\nfunc TestGetTempDir(t *testing.T) {\n\tdir := os.TempDir()\n\tif FilePathSeparator != dir[len(dir)-1:] {\n\t\tdir = dir + FilePathSeparator\n\t}\n\ttestDir := \"hugoTestFolder\" + FilePathSeparator\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", dir},\n\t\t{testDir + \"  Foo bar  \", dir + testDir + \"  Foo bar  \" + FilePathSeparator},\n\t\t{testDir + \"Foo.Bar/foo_Bar-Foo\", dir + testDir + \"Foo.Bar/foo_Bar-Foo\" + FilePathSeparator},\n\t\t{testDir + \"fOO,bar:foo%bAR\", dir + testDir + \"fOObarfoo%bAR\" + FilePathSeparator},\n\t\t{testDir + \"FOo/BaR.html\", dir + testDir + \"FOo/BaR.html\" + FilePathSeparator},\n\t\t{testDir + \"трям/трям\", dir + testDir + \"трям/трям\" + FilePathSeparator},\n\t\t{testDir + \"은행\", dir + testDir + \"은행\" + FilePathSeparator},\n\t\t{testDir + \"Банковский кассир\", dir + testDir + \"Банковский кассир\" + FilePathSeparator},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput := GetTempDir(new(MemMapFs), test.input)\n\t\tif output != test.expected {\n\t\t\tt.Errorf(\"Expected %#v, got %#v\\n\", test.expected, output)\n\t\t}\n\t}\n}\n\n// This function is very dangerous. Don't use it.\nfunc deleteTempDir(d string) {\n\terr := os.RemoveAll(d)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestFullBaseFsPath(t *testing.T) {\n\ttype dirSpec struct {\n\t\tDir1, Dir2, Dir3 string\n\t}\n\tdirSpecs := []dirSpec{\n\t\t{Dir1: \"/\", Dir2: \"/\", Dir3: \"/\"},\n\t\t{Dir1: \"/\", Dir2: \"/path2\", Dir3: \"/\"},\n\t\t{Dir1: \"/path1/dir\", Dir2: \"/path2/dir/\", Dir3: \"/path3/dir\"},\n\t\t{Dir1: \"C:/path1\", Dir2: \"path2/dir\", Dir3: \"/path3/dir/\"},\n\t}\n\n\tfor _, ds := range dirSpecs {\n\t\tmemFs := NewMemMapFs()\n\t\tlevel1Fs := NewBasePathFs(memFs, ds.Dir1)\n\t\tlevel2Fs := NewBasePathFs(level1Fs, ds.Dir2)\n\t\tlevel3Fs := NewBasePathFs(level2Fs, ds.Dir3)\n\n\t\ttype spec struct {\n\t\t\tBaseFs       Fs\n\t\t\tFileName     string\n\t\t\tExpectedPath string\n\t\t}\n\t\tspecs := []spec{\n\t\t\t{BaseFs: level3Fs, FileName: \"f.txt\", ExpectedPath: filepath.Join(ds.Dir1, ds.Dir2, ds.Dir3, \"f.txt\")},\n\t\t\t{BaseFs: level3Fs, FileName: \"\", ExpectedPath: filepath.Join(ds.Dir1, ds.Dir2, ds.Dir3, \"\")},\n\t\t\t{BaseFs: level2Fs, FileName: \"f.txt\", ExpectedPath: filepath.Join(ds.Dir1, ds.Dir2, \"f.txt\")},\n\t\t\t{BaseFs: level2Fs, FileName: \"\", ExpectedPath: filepath.Join(ds.Dir1, ds.Dir2, \"\")},\n\t\t\t{BaseFs: level1Fs, FileName: \"f.txt\", ExpectedPath: filepath.Join(ds.Dir1, \"f.txt\")},\n\t\t\t{BaseFs: level1Fs, FileName: \"\", ExpectedPath: filepath.Join(ds.Dir1, \"\")},\n\t\t}\n\n\t\tfor _, s := range specs {\n\t\t\tif actualPath := FullBaseFsPath(s.BaseFs.(*BasePathFs), s.FileName); actualPath != s.ExpectedPath {\n\t\t\t\tt.Errorf(\"Expected \\n%s got \\n%s\", s.ExpectedPath, actualPath)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "zipfs",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}