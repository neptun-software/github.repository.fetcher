{
  "metadata": {
    "timestamp": 1736567807869,
    "page": 393,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bwmarrin/discordgo",
      "stars": 5188,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": "# IDE-specific metadata\n.idea/\n\n# Environment variables. Useful for examples.\n.env\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2119140625,
          "content": "linters:\n  disable-all: true\n  enable:\n    # - staticcheck\n    # - unused\n    - golint\n\nlinters-settings:\n  staticcheck:\n    go: \"1.13\"\n\n    checks: [\"all\"]\n\n  unused:\n    go: \"1.13\"\n\nissues:\n  include:\n    - EXC0002\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3544921875,
          "content": "language: go\ngo:\n    - 1.13.x\n    - 1.14.x\n    - 1.15.x\n    - 1.16.x\n    - 1.17.x\n    - 1.18.x\nenv:\n    - GO111MODULE=on\ninstall:\n    - go get github.com/bwmarrin/discordgo\n    - go get -v .\n    - go get -v golang.org/x/lint/golint\nscript:\n    - diff <(gofmt -d .) <(echo -n)\n    - go vet -x ./...\n    - golint -set_exit_status ./...\n    - go test -v -race ./...\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.830078125,
          "content": "# Getting started\n\nTo start off you can check out existing Pull Requests and Issues to get a gasp of what problems we’re currently solving and what features you can implement.\n\n## Issues\n\nOur issues are mostly used for bugs, however we welcome refactoring and conceptual issues.\n\nAny other conversation would belong and would be moved into “Discussions”.\n\n## Discussions\n\nWe use discussions for ideas, polls, announcements and help questions.\n\nDon’t hesitate to ask, we always would try to help.\n\n## Pull Requests\n\nIf you want to help us by improving existing or adding new features, you create what’s called a Pull Request (aka PR). It allows us to review your code, suggest changes and merge it.\n\nHere are some tips on how to make a good first PR:\n\n- When creating a PR, please consider a distinctive name and description for it, so the maintainers can understand what your PR changes / adds / removes.\n- It’s always a good idea to link documentation when implementing a new feature / endpoint\n- If you’re resolving an issue, don’t forget to [link it](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue) in the description.\n- Enable the checkbox to allow maintainers to edit your PR and make commits in the PR branch when necessary.\n- We may ask for changes, usually through suggestions or pull request comments. You can apply suggestions right in the UI. Any other change needs to be done manually.\n- Don’t forget to mark PR comments resolved when you’re done applying the changes.\n- Be patient and don’t close and reopen your PR when no one responds, sometimes it might be held for a while. There might be a lot of reasons: release preparation, the feature is not significant, maintainers are busy, etc.\n\n\nWhen your changes are still incomplete (i.e. in Work In Progress state), you can still create a PR, but consider making it a draft. \nTo make a draft PR, you can change the type of PR by clicking to a triangle next to the “Create Pull Request” button.\n\nOnce you’re done, you can mark it as “Ready for review”, and we’ll get right on it.\n\n\n# Code style\n\nTo standardize and make things less messy we have a certain code style, that is persistent throughout the codebase.\n\n## Naming\n\n### REST methods\n\nWhen naming a REST method, while it might seem counterintuitive, we specify the entity before the action verb (for GET endpoints we don’t specify one however). Here’s an example:\n\n> Endpoint name: Get Channel Message\n>\n> Method name: `ChannelMessage`\n\n> Endpoint name: Edit Channel Message\n>\n> Method name: `ChannelMessageEdit`\n\n### Parameter structures\n\nWhen making a complex REST endpoint, sometimes you might need to implement a `Param` structure. This structure contains parameters for certain endpoint/set of endpoints.\n\n- If an endpoint/set of endpoints have mostly same parameters, it’s a good idea to use a single `Param` structure for them. Here’s an example:\n    \n    > Endpoint: `GuildMemberEdit`\n    >\n    > `Param` structure: `GuildMemberParams` \n- If an endpoint/set of endpoints have differentiating parameters, `Param` structure can be named after the endpoint’s verb. Here’s an example:\n    \n    > Endpoint: `ChannelMessageSendComplex`\n    >\n    > `Param` structure: `MessageSend`\n    \n    > Endpoint: `ChannelMessageEditComplex`\n    >\n    > `Param` structure: `MessageEdit` \n\n### Events\n\nWhen naming an event, we follow gateway’s internal naming (which often matches with the official event name in the docs). Here’s an example:\n\n> Event name: Interaction Create (`INTERACTION_CREATE`)\n>\n> Structure name: `InteractionCreate`\n\n## Returns\n\nIn our REST functions we usually favor named returns instead of regular anonymous returns. This helps readability.\n\nAdditionally we try to avoid naked return statements for functions with a long body. Since it’s easier to loose track of the return result.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.447265625,
          "content": "Copyright (c) 2015, Bruce Marriner\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of discordgo nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.201171875,
          "content": "# DiscordGo\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/bwmarrin/discordgo.svg)](https://pkg.go.dev/github.com/bwmarrin/discordgo) [![Go Report Card](https://goreportcard.com/badge/github.com/bwmarrin/discordgo)](https://goreportcard.com/report/github.com/bwmarrin/discordgo) [![CI](https://github.com/bwmarrin/discordgo/actions/workflows/ci.yml/badge.svg)](https://github.com/bwmarrin/discordgo/actions/workflows/ci.yml) [![Discord Gophers](https://img.shields.io/badge/Discord%20Gophers-%23discordgo-blue.svg)](https://discord.gg/golang) [![Discord API](https://img.shields.io/badge/Discord%20API-%23go_discordgo-blue.svg)](https://discord.com/invite/discord-api)\n\n<img align=\"right\" alt=\"DiscordGo logo\" src=\"docs/img/discordgo.svg\" width=\"400\">\n\nDiscordGo is a [Go](https://golang.org/) package that provides low level \nbindings to the [Discord](https://discord.com/) chat client API. DiscordGo \nhas nearly complete support for all of the Discord API endpoints, websocket\ninterface, and voice interface.\n\nIf you would like to help the DiscordGo package please use \n[this link](https://discord.com/oauth2/authorize?client_id=173113690092994561&scope=bot)\nto add the official DiscordGo test bot **dgo** to your server. This provides \nindispensable help to this project.\n\n* See [dgVoice](https://github.com/bwmarrin/dgvoice) package for an example of\nadditional voice helper functions and features for DiscordGo.\n\n* See [dca](https://github.com/bwmarrin/dca) for an **experimental** stand alone\ntool that wraps `ffmpeg` to create opus encoded audio appropriate for use with\nDiscord (and DiscordGo).\n\n**For help with this package or general Go discussion, please join the [Discord \nGophers](https://discord.gg/golang) chat server.**\n\n## Getting Started\n\n### Installing\n\nThis assumes you already have a working Go environment, if not please see\n[this page](https://golang.org/doc/install) first.\n\n`go get` *will always pull the latest tagged release from the master branch.*\n\n```sh\ngo get github.com/bwmarrin/discordgo\n```\n\n### Usage\n\nImport the package into your project.\n\n```go\nimport \"github.com/bwmarrin/discordgo\"\n```\n\nConstruct a new Discord client which can be used to access the variety of \nDiscord API functions and to set callback functions for Discord events.\n\n```go\ndiscord, err := discordgo.New(\"Bot \" + \"authentication token\")\n```\n\nSee Documentation and Examples below for more detailed information.\n\n\n## Documentation\n\n**NOTICE**: This library and the Discord API are unfinished.\nBecause of that there may be major changes to library in the future.\n\nThe DiscordGo code is fairly well documented at this point and is currently\nthe only documentation available. Go reference (below) presents that information in a nice format.\n\n- [![Go Reference](https://pkg.go.dev/badge/github.com/bwmarrin/discordgo.svg)](https://pkg.go.dev/github.com/bwmarrin/discordgo) \n- Hand crafted documentation coming eventually.\n\n\n## Examples\n\nBelow is a list of examples and other projects using DiscordGo.  Please submit \nan issue if you would like your project added or removed from this list. \n\n- [DiscordGo Examples](https://github.com/bwmarrin/discordgo/tree/master/examples) - A collection of example programs written with DiscordGo\n- [Awesome DiscordGo](https://github.com/bwmarrin/discordgo/wiki/Awesome-DiscordGo) - A curated list of high quality projects using DiscordGo\n\n## Troubleshooting\nFor help with common problems please reference the \n[Troubleshooting](https://github.com/bwmarrin/discordgo/wiki/Troubleshooting) \nsection of the project wiki.\n\n\n## Contributing\nContributions are very welcomed, however please follow the below guidelines.\n\n- First open an issue describing the bug or enhancement so it can be\ndiscussed.  \n- Try to match current naming conventions as closely as possible.  \n- This package is intended to be a low level direct mapping of the Discord API, \nso please avoid adding enhancements outside of that scope without first \ndiscussing it.\n- Create a Pull Request with your changes against the master branch.\n\n\n## List of Discord APIs\n\nSee [this chart](https://abal.moe/Discord/Libraries.html) for a feature \ncomparison and list of other Discord API libraries.\n\n## Special Thanks\n\n[Chris Rhodes](https://github.com/iopred) - For the DiscordGo logo and tons of PRs.\n"
        },
        {
          "name": "components.go",
          "type": "blob",
          "size": 8.7900390625,
          "content": "package discordgo\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// ComponentType is type of component.\ntype ComponentType uint\n\n// MessageComponent types.\nconst (\n\tActionsRowComponent            ComponentType = 1\n\tButtonComponent                ComponentType = 2\n\tSelectMenuComponent            ComponentType = 3\n\tTextInputComponent             ComponentType = 4\n\tUserSelectMenuComponent        ComponentType = 5\n\tRoleSelectMenuComponent        ComponentType = 6\n\tMentionableSelectMenuComponent ComponentType = 7\n\tChannelSelectMenuComponent     ComponentType = 8\n)\n\n// MessageComponent is a base interface for all message components.\ntype MessageComponent interface {\n\tjson.Marshaler\n\tType() ComponentType\n}\n\ntype unmarshalableMessageComponent struct {\n\tMessageComponent\n}\n\n// UnmarshalJSON is a helper function to unmarshal MessageComponent object.\nfunc (umc *unmarshalableMessageComponent) UnmarshalJSON(src []byte) error {\n\tvar v struct {\n\t\tType ComponentType `json:\"type\"`\n\t}\n\terr := json.Unmarshal(src, &v)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch v.Type {\n\tcase ActionsRowComponent:\n\t\tumc.MessageComponent = &ActionsRow{}\n\tcase ButtonComponent:\n\t\tumc.MessageComponent = &Button{}\n\tcase SelectMenuComponent, ChannelSelectMenuComponent, UserSelectMenuComponent,\n\t\tRoleSelectMenuComponent, MentionableSelectMenuComponent:\n\t\tumc.MessageComponent = &SelectMenu{}\n\tcase TextInputComponent:\n\t\tumc.MessageComponent = &TextInput{}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown component type: %d\", v.Type)\n\t}\n\treturn json.Unmarshal(src, umc.MessageComponent)\n}\n\n// MessageComponentFromJSON is a helper function for unmarshaling message components\nfunc MessageComponentFromJSON(b []byte) (MessageComponent, error) {\n\tvar u unmarshalableMessageComponent\n\terr := u.UnmarshalJSON(b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal into MessageComponent: %w\", err)\n\t}\n\treturn u.MessageComponent, nil\n}\n\n// ActionsRow is a container for components within one row.\ntype ActionsRow struct {\n\tComponents []MessageComponent `json:\"components\"`\n}\n\n// MarshalJSON is a method for marshaling ActionsRow to a JSON object.\nfunc (r ActionsRow) MarshalJSON() ([]byte, error) {\n\ttype actionsRow ActionsRow\n\n\treturn Marshal(struct {\n\t\tactionsRow\n\t\tType ComponentType `json:\"type\"`\n\t}{\n\t\tactionsRow: actionsRow(r),\n\t\tType:       r.Type(),\n\t})\n}\n\n// UnmarshalJSON is a helper function to unmarshal Actions Row.\nfunc (r *ActionsRow) UnmarshalJSON(data []byte) error {\n\tvar v struct {\n\t\tRawComponents []unmarshalableMessageComponent `json:\"components\"`\n\t}\n\terr := json.Unmarshal(data, &v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr.Components = make([]MessageComponent, len(v.RawComponents))\n\tfor i, v := range v.RawComponents {\n\t\tr.Components[i] = v.MessageComponent\n\t}\n\n\treturn err\n}\n\n// Type is a method to get the type of a component.\nfunc (r ActionsRow) Type() ComponentType {\n\treturn ActionsRowComponent\n}\n\n// ButtonStyle is style of button.\ntype ButtonStyle uint\n\n// Button styles.\nconst (\n\t// PrimaryButton is a button with blurple color.\n\tPrimaryButton ButtonStyle = 1\n\t// SecondaryButton is a button with grey color.\n\tSecondaryButton ButtonStyle = 2\n\t// SuccessButton is a button with green color.\n\tSuccessButton ButtonStyle = 3\n\t// DangerButton is a button with red color.\n\tDangerButton ButtonStyle = 4\n\t// LinkButton is a special type of button which navigates to a URL. Has grey color.\n\tLinkButton ButtonStyle = 5\n\t// PremiumButton is a special type of button with a blurple color that links to a SKU.\n\tPremiumButton ButtonStyle = 6\n)\n\n// ComponentEmoji represents button emoji, if it does have one.\ntype ComponentEmoji struct {\n\tName     string `json:\"name,omitempty\"`\n\tID       string `json:\"id,omitempty\"`\n\tAnimated bool   `json:\"animated,omitempty\"`\n}\n\n// Button represents button component.\ntype Button struct {\n\tLabel    string          `json:\"label\"`\n\tStyle    ButtonStyle     `json:\"style\"`\n\tDisabled bool            `json:\"disabled\"`\n\tEmoji    *ComponentEmoji `json:\"emoji,omitempty\"`\n\n\t// NOTE: Only button with LinkButton style can have link. Also, URL is mutually exclusive with CustomID.\n\tURL      string `json:\"url,omitempty\"`\n\tCustomID string `json:\"custom_id,omitempty\"`\n\t// Identifier for a purchasable SKU. Only available when using premium-style buttons.\n\tSKUID string `json:\"sku_id,omitempty\"`\n}\n\n// MarshalJSON is a method for marshaling Button to a JSON object.\nfunc (b Button) MarshalJSON() ([]byte, error) {\n\ttype button Button\n\n\tif b.Style == 0 {\n\t\tb.Style = PrimaryButton\n\t}\n\n\treturn Marshal(struct {\n\t\tbutton\n\t\tType ComponentType `json:\"type\"`\n\t}{\n\t\tbutton: button(b),\n\t\tType:   b.Type(),\n\t})\n}\n\n// Type is a method to get the type of a component.\nfunc (Button) Type() ComponentType {\n\treturn ButtonComponent\n}\n\n// SelectMenuOption represents an option for a select menu.\ntype SelectMenuOption struct {\n\tLabel       string          `json:\"label,omitempty\"`\n\tValue       string          `json:\"value\"`\n\tDescription string          `json:\"description\"`\n\tEmoji       *ComponentEmoji `json:\"emoji,omitempty\"`\n\t// Determines whenever option is selected by default or not.\n\tDefault bool `json:\"default\"`\n}\n\n// SelectMenuDefaultValueType represents the type of an entity selected by default in auto-populated select menus.\ntype SelectMenuDefaultValueType string\n\n// SelectMenuDefaultValue types.\nconst (\n\tSelectMenuDefaultValueUser    SelectMenuDefaultValueType = \"user\"\n\tSelectMenuDefaultValueRole    SelectMenuDefaultValueType = \"role\"\n\tSelectMenuDefaultValueChannel SelectMenuDefaultValueType = \"channel\"\n)\n\n// SelectMenuDefaultValue represents an entity selected by default in auto-populated select menus.\ntype SelectMenuDefaultValue struct {\n\t// ID of the entity.\n\tID string `json:\"id\"`\n\t// Type of the entity.\n\tType SelectMenuDefaultValueType `json:\"type\"`\n}\n\n// SelectMenuType represents select menu type.\ntype SelectMenuType ComponentType\n\n// SelectMenu types.\nconst (\n\tStringSelectMenu      = SelectMenuType(SelectMenuComponent)\n\tUserSelectMenu        = SelectMenuType(UserSelectMenuComponent)\n\tRoleSelectMenu        = SelectMenuType(RoleSelectMenuComponent)\n\tMentionableSelectMenu = SelectMenuType(MentionableSelectMenuComponent)\n\tChannelSelectMenu     = SelectMenuType(ChannelSelectMenuComponent)\n)\n\n// SelectMenu represents select menu component.\ntype SelectMenu struct {\n\t// Type of the select menu.\n\tMenuType SelectMenuType `json:\"type,omitempty\"`\n\t// CustomID is a developer-defined identifier for the select menu.\n\tCustomID string `json:\"custom_id,omitempty\"`\n\t// The text which will be shown in the menu if there's no default options or all options was deselected and component was closed.\n\tPlaceholder string `json:\"placeholder\"`\n\t// This value determines the minimal amount of selected items in the menu.\n\tMinValues *int `json:\"min_values,omitempty\"`\n\t// This value determines the maximal amount of selected items in the menu.\n\t// If MaxValues or MinValues are greater than one then the user can select multiple items in the component.\n\tMaxValues int `json:\"max_values,omitempty\"`\n\t// List of default values for auto-populated select menus.\n\t// NOTE: Number of entries should be in the range defined by MinValues and MaxValues.\n\tDefaultValues []SelectMenuDefaultValue `json:\"default_values,omitempty\"`\n\n\tOptions  []SelectMenuOption `json:\"options,omitempty\"`\n\tDisabled bool               `json:\"disabled\"`\n\n\t// NOTE: Can only be used in SelectMenu with Channel menu type.\n\tChannelTypes []ChannelType `json:\"channel_types,omitempty\"`\n}\n\n// Type is a method to get the type of a component.\nfunc (s SelectMenu) Type() ComponentType {\n\tif s.MenuType != 0 {\n\t\treturn ComponentType(s.MenuType)\n\t}\n\treturn SelectMenuComponent\n}\n\n// MarshalJSON is a method for marshaling SelectMenu to a JSON object.\nfunc (s SelectMenu) MarshalJSON() ([]byte, error) {\n\ttype selectMenu SelectMenu\n\n\treturn Marshal(struct {\n\t\tselectMenu\n\t\tType ComponentType `json:\"type\"`\n\t}{\n\t\tselectMenu: selectMenu(s),\n\t\tType:       s.Type(),\n\t})\n}\n\n// TextInput represents text input component.\ntype TextInput struct {\n\tCustomID    string         `json:\"custom_id\"`\n\tLabel       string         `json:\"label\"`\n\tStyle       TextInputStyle `json:\"style\"`\n\tPlaceholder string         `json:\"placeholder,omitempty\"`\n\tValue       string         `json:\"value,omitempty\"`\n\tRequired    bool           `json:\"required\"`\n\tMinLength   int            `json:\"min_length,omitempty\"`\n\tMaxLength   int            `json:\"max_length,omitempty\"`\n}\n\n// Type is a method to get the type of a component.\nfunc (TextInput) Type() ComponentType {\n\treturn TextInputComponent\n}\n\n// MarshalJSON is a method for marshaling TextInput to a JSON object.\nfunc (m TextInput) MarshalJSON() ([]byte, error) {\n\ttype inputText TextInput\n\n\treturn Marshal(struct {\n\t\tinputText\n\t\tType ComponentType `json:\"type\"`\n\t}{\n\t\tinputText: inputText(m),\n\t\tType:      m.Type(),\n\t})\n}\n\n// TextInputStyle is style of text in TextInput component.\ntype TextInputStyle uint\n\n// Text styles\nconst (\n\tTextInputShort     TextInputStyle = 1\n\tTextInputParagraph TextInputStyle = 2\n)\n"
        },
        {
          "name": "discord.go",
          "type": "blob",
          "size": 2.263671875,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains high level helper functions and easy entry points for the\n// entire discordgo package.  These functions are being developed and are very\n// experimental at this point.  They will most likely change so please use the\n// low level functions if that's a problem.\n\n// Package discordgo provides Discord binding for Go\npackage discordgo\n\nimport (\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// VERSION of DiscordGo, follows Semantic Versioning. (http://semver.org/)\nconst VERSION = \"0.28.1\"\n\n// New creates a new Discord session with provided token.\n// If the token is for a bot, it must be prefixed with \"Bot \"\n// \t\te.g. \"Bot ...\"\n// Or if it is an OAuth2 token, it must be prefixed with \"Bearer \"\n//\t\te.g. \"Bearer ...\"\nfunc New(token string) (s *Session, err error) {\n\n\t// Create an empty Session interface.\n\ts = &Session{\n\t\tState:                              NewState(),\n\t\tRatelimiter:                        NewRatelimiter(),\n\t\tStateEnabled:                       true,\n\t\tCompress:                           true,\n\t\tShouldReconnectOnError:             true,\n\t\tShouldReconnectVoiceOnSessionError: true,\n\t\tShouldRetryOnRateLimit:             true,\n\t\tShardID:                            0,\n\t\tShardCount:                         1,\n\t\tMaxRestRetries:                     3,\n\t\tClient:                             &http.Client{Timeout: (20 * time.Second)},\n\t\tDialer:                             websocket.DefaultDialer,\n\t\tUserAgent:                          \"DiscordBot (https://github.com/bwmarrin/discordgo, v\" + VERSION + \")\",\n\t\tsequence:                           new(int64),\n\t\tLastHeartbeatAck:                   time.Now().UTC(),\n\t}\n\n\t// Initialize the Identify Package with defaults\n\t// These can be modified prior to calling Open()\n\ts.Identify.Compress = true\n\ts.Identify.LargeThreshold = 250\n\ts.Identify.Properties.OS = runtime.GOOS\n\ts.Identify.Properties.Browser = \"DiscordGo v\" + VERSION\n\ts.Identify.Intents = IntentsAllWithoutPrivileged\n\ts.Identify.Token = token\n\ts.Token = token\n\n\treturn\n}\n"
        },
        {
          "name": "discord_test.go",
          "type": "blob",
          "size": 8.138671875,
          "content": "package discordgo\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\n//////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////// VARS NEEDED FOR TESTING\nvar (\n\tdg    *Session // Stores a global discordgo user session\n\tdgBot *Session // Stores a global discordgo bot session\n\n\tenvOAuth2Token  = os.Getenv(\"DG_OAUTH2_TOKEN\")  // Token to use when authenticating using OAuth2 token\n\tenvBotToken     = os.Getenv(\"DGB_TOKEN\")        // Token to use when authenticating the bot account\n\tenvGuild        = os.Getenv(\"DG_GUILD\")         // Guild ID to use for tests\n\tenvChannel      = os.Getenv(\"DG_CHANNEL\")       // Channel ID to use for tests\n\tenvVoiceChannel = os.Getenv(\"DG_VOICE_CHANNEL\") // Channel ID to use for tests\n\tenvAdmin        = os.Getenv(\"DG_ADMIN\")         // User ID of admin user to use for tests\n)\n\nfunc TestMain(m *testing.M) {\n\tfmt.Println(\"Init is being called.\")\n\tif envBotToken != \"\" {\n\t\tif d, err := New(envBotToken); err == nil {\n\t\t\tdgBot = d\n\t\t}\n\t}\n\n\tif envOAuth2Token == \"\" {\n\t\tenvOAuth2Token = os.Getenv(\"DGU_TOKEN\")\n\t}\n\n\tif envOAuth2Token != \"\" {\n\t\tif d, err := New(envOAuth2Token); err == nil {\n\t\t\tdg = d\n\t\t}\n\t}\n\n\tos.Exit(m.Run())\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////// START OF TESTS\n\n// TestNewToken tests the New() function with a Token.\nfunc TestNewToken(t *testing.T) {\n\n\tif envOAuth2Token == \"\" {\n\t\tt.Skip(\"Skipping New(token), DGU_TOKEN not set\")\n\t}\n\n\td, err := New(envOAuth2Token)\n\tif err != nil {\n\t\tt.Fatalf(\"New(envToken) returned error: %+v\", err)\n\t}\n\n\tif d == nil {\n\t\tt.Fatal(\"New(envToken), d is nil, should be Session{}\")\n\t}\n\n\tif d.Token == \"\" {\n\t\tt.Fatal(\"New(envToken), d.Token is empty, should be a valid Token.\")\n\t}\n}\n\nfunc TestOpenClose(t *testing.T) {\n\tif envOAuth2Token == \"\" {\n\t\tt.Skip(\"Skipping TestClose, DGU_TOKEN not set\")\n\t}\n\n\td, err := New(envOAuth2Token)\n\tif err != nil {\n\t\tt.Fatalf(\"TestClose, New(envToken) returned error: %+v\", err)\n\t}\n\n\tif err = d.Open(); err != nil {\n\t\tt.Fatalf(\"TestClose, d.Open failed: %+v\", err)\n\t}\n\n\t// We need a better way to know the session is ready for use,\n\t// this is totally gross.\n\tstart := time.Now()\n\tfor {\n\t\td.RLock()\n\t\tif d.DataReady {\n\t\t\td.RUnlock()\n\t\t\tbreak\n\t\t}\n\t\td.RUnlock()\n\n\t\tif time.Since(start) > 10*time.Second {\n\t\t\tt.Fatal(\"DataReady never became true.yy\")\n\t\t}\n\t\truntime.Gosched()\n\t}\n\n\t// TODO find a better way\n\t// Add a small sleep here to make sure heartbeat and other events\n\t// have enough time to get fired.  Need a way to actually check\n\t// those events.\n\ttime.Sleep(2 * time.Second)\n\n\t// UpdateStatus - maybe we move this into wsapi_test.go but the websocket\n\t// created here is needed.  This helps tests that the websocket was setup\n\t// and it is working.\n\tif err = d.UpdateGameStatus(0, time.Now().String()); err != nil {\n\t\tt.Errorf(\"UpdateStatus error: %+v\", err)\n\t}\n\n\tif err = d.Close(); err != nil {\n\t\tt.Fatalf(\"TestClose, d.Close failed: %+v\", err)\n\t}\n}\n\nfunc TestAddHandler(t *testing.T) {\n\n\ttestHandlerCalled := int32(0)\n\ttestHandler := func(s *Session, m *MessageCreate) {\n\t\tatomic.AddInt32(&testHandlerCalled, 1)\n\t}\n\n\tinterfaceHandlerCalled := int32(0)\n\tinterfaceHandler := func(s *Session, i interface{}) {\n\t\tatomic.AddInt32(&interfaceHandlerCalled, 1)\n\t}\n\n\tbogusHandlerCalled := int32(0)\n\tbogusHandler := func(s *Session, se *Session) {\n\t\tatomic.AddInt32(&bogusHandlerCalled, 1)\n\t}\n\n\td := Session{}\n\td.AddHandler(testHandler)\n\td.AddHandler(testHandler)\n\n\td.AddHandler(interfaceHandler)\n\td.AddHandler(bogusHandler)\n\n\td.handleEvent(messageCreateEventType, &MessageCreate{})\n\td.handleEvent(messageDeleteEventType, &MessageDelete{})\n\n\t<-time.After(500 * time.Millisecond)\n\n\t// testHandler will be called twice because it was added twice.\n\tif atomic.LoadInt32(&testHandlerCalled) != 2 {\n\t\tt.Fatalf(\"testHandler was not called twice.\")\n\t}\n\n\t// interfaceHandler will be called twice, once for each event.\n\tif atomic.LoadInt32(&interfaceHandlerCalled) != 2 {\n\t\tt.Fatalf(\"interfaceHandler was not called twice.\")\n\t}\n\n\tif atomic.LoadInt32(&bogusHandlerCalled) != 0 {\n\t\tt.Fatalf(\"bogusHandler was called.\")\n\t}\n}\n\nfunc TestRemoveHandler(t *testing.T) {\n\n\ttestHandlerCalled := int32(0)\n\ttestHandler := func(s *Session, m *MessageCreate) {\n\t\tatomic.AddInt32(&testHandlerCalled, 1)\n\t}\n\n\td := Session{}\n\tr := d.AddHandler(testHandler)\n\n\td.handleEvent(messageCreateEventType, &MessageCreate{})\n\n\tr()\n\n\td.handleEvent(messageCreateEventType, &MessageCreate{})\n\n\t<-time.After(500 * time.Millisecond)\n\n\t// testHandler will be called once, as it was removed in between calls.\n\tif atomic.LoadInt32(&testHandlerCalled) != 1 {\n\t\tt.Fatalf(\"testHandler was not called once.\")\n\t}\n}\n\nfunc TestScheduledEvents(t *testing.T) {\n\tif dgBot == nil {\n\t\tt.Skip(\"Skipping, dgBot not set.\")\n\t}\n\n\tbeginAt := time.Now().Add(1 * time.Hour)\n\tendAt := time.Now().Add(2 * time.Hour)\n\tevent, err := dgBot.GuildScheduledEventCreate(envGuild, &GuildScheduledEventParams{\n\t\tName:               \"Test Event\",\n\t\tPrivacyLevel:       GuildScheduledEventPrivacyLevelGuildOnly,\n\t\tScheduledStartTime: &beginAt,\n\t\tScheduledEndTime:   &endAt,\n\t\tDescription:        \"Awesome Test Event created on livestream\",\n\t\tEntityType:         GuildScheduledEventEntityTypeExternal,\n\t\tEntityMetadata: &GuildScheduledEventEntityMetadata{\n\t\t\tLocation: \"https://discord.com\",\n\t\t},\n\t})\n\tdefer dgBot.GuildScheduledEventDelete(envGuild, event.ID)\n\n\tif err != nil || event.Name != \"Test Event\" {\n\t\tt.Fatal(err)\n\t}\n\n\tevents, err := dgBot.GuildScheduledEvents(envGuild, true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar foundEvent *GuildScheduledEvent\n\tfor _, e := range events {\n\t\tif e.ID == event.ID {\n\t\t\tfoundEvent = e\n\t\t\tbreak\n\t\t}\n\t}\n\tif foundEvent.Name != event.Name {\n\t\tt.Fatal(\"err on GuildScheduledEvents endpoint. Missing Scheduled Event\")\n\t}\n\n\tgetEvent, err := dgBot.GuildScheduledEvent(envGuild, event.ID, true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif getEvent.Name != event.Name {\n\t\tt.Fatal(\"err on GuildScheduledEvent endpoint. Mismatched Scheduled Event\")\n\t}\n\n\teventUpdated, err := dgBot.GuildScheduledEventEdit(envGuild, event.ID, &GuildScheduledEventParams{Name: \"Test Event Updated\"})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif eventUpdated.Name != \"Test Event Updated\" {\n\t\tt.Fatal(\"err on GuildScheduledEventUpdate endpoint. Scheduled Event Name mismatch\")\n\t}\n\n\t// Usage of 1 and 1 is just the pseudo data with the purpose to run all branches in the function without crashes.\n\t// see https://github.com/bwmarrin/discordgo/pull/1032#discussion_r815438303 for more details.\n\tusers, err := dgBot.GuildScheduledEventUsers(envGuild, event.ID, 1, true, \"1\", \"1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(users) != 0 {\n\t\tt.Fatal(\"err on GuildScheduledEventUsers. Mismatch of event maybe occurred\")\n\t}\n\n\terr = dgBot.GuildScheduledEventDelete(envGuild, event.ID)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestComplexScheduledEvents(t *testing.T) {\n\tif dgBot == nil {\n\t\tt.Skip(\"Skipping, dgBot not set.\")\n\t}\n\n\tbeginAt := time.Now().Add(1 * time.Hour)\n\tendAt := time.Now().Add(2 * time.Hour)\n\tevent, err := dgBot.GuildScheduledEventCreate(envGuild, &GuildScheduledEventParams{\n\t\tName:               \"Test Voice Event\",\n\t\tPrivacyLevel:       GuildScheduledEventPrivacyLevelGuildOnly,\n\t\tScheduledStartTime: &beginAt,\n\t\tScheduledEndTime:   &endAt,\n\t\tDescription:        \"Test event on voice channel\",\n\t\tEntityType:         GuildScheduledEventEntityTypeVoice,\n\t\tChannelID:          envVoiceChannel,\n\t})\n\tif err != nil || event.Name != \"Test Voice Event\" {\n\t\tt.Fatal(err)\n\t}\n\tdefer dgBot.GuildScheduledEventDelete(envGuild, event.ID)\n\n\t_, err = dgBot.GuildScheduledEventEdit(envGuild, event.ID, &GuildScheduledEventParams{\n\t\tEntityType: GuildScheduledEventEntityTypeExternal,\n\t\tEntityMetadata: &GuildScheduledEventEntityMetadata{\n\t\t\tLocation: \"https://discord.com\",\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(\"err on GuildScheduledEventEdit. Change of entity type to external failed\")\n\t}\n\n\t_, err = dgBot.GuildScheduledEventEdit(envGuild, event.ID, &GuildScheduledEventParams{\n\t\tChannelID:      envVoiceChannel,\n\t\tEntityType:     GuildScheduledEventEntityTypeVoice,\n\t\tEntityMetadata: nil,\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(\"err on GuildScheduledEventEdit. Change of entity type to voice failed\")\n\t}\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "endpoints.go",
          "type": "blob",
          "size": 15.775390625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains variables for all known Discord end points.  All functions\n// throughout the Discordgo package use these variables for all connections\n// to Discord.  These are all exported and you may modify them if needed.\n\npackage discordgo\n\nimport \"strconv\"\n\n// APIVersion is the Discord API version used for the REST and Websocket API.\nvar APIVersion = \"9\"\n\n// Known Discord API Endpoints.\nvar (\n\tEndpointStatus     = \"https://status.discord.com/api/v2/\"\n\tEndpointSm         = EndpointStatus + \"scheduled-maintenances/\"\n\tEndpointSmActive   = EndpointSm + \"active.json\"\n\tEndpointSmUpcoming = EndpointSm + \"upcoming.json\"\n\n\tEndpointDiscord        = \"https://discord.com/\"\n\tEndpointAPI            = EndpointDiscord + \"api/v\" + APIVersion + \"/\"\n\tEndpointGuilds         = EndpointAPI + \"guilds/\"\n\tEndpointChannels       = EndpointAPI + \"channels/\"\n\tEndpointUsers          = EndpointAPI + \"users/\"\n\tEndpointGateway        = EndpointAPI + \"gateway\"\n\tEndpointGatewayBot     = EndpointGateway + \"/bot\"\n\tEndpointWebhooks       = EndpointAPI + \"webhooks/\"\n\tEndpointStickers       = EndpointAPI + \"stickers/\"\n\tEndpointStageInstances = EndpointAPI + \"stage-instances\"\n\tEndpointSKUs           = EndpointAPI + \"skus\"\n\n\tEndpointCDN             = \"https://cdn.discordapp.com/\"\n\tEndpointCDNAttachments  = EndpointCDN + \"attachments/\"\n\tEndpointCDNAvatars      = EndpointCDN + \"avatars/\"\n\tEndpointCDNIcons        = EndpointCDN + \"icons/\"\n\tEndpointCDNSplashes     = EndpointCDN + \"splashes/\"\n\tEndpointCDNChannelIcons = EndpointCDN + \"channel-icons/\"\n\tEndpointCDNBanners      = EndpointCDN + \"banners/\"\n\tEndpointCDNGuilds       = EndpointCDN + \"guilds/\"\n\tEndpointCDNRoleIcons    = EndpointCDN + \"role-icons/\"\n\n\tEndpointVoice        = EndpointAPI + \"/voice/\"\n\tEndpointVoiceRegions = EndpointVoice + \"regions\"\n\n\tEndpointUser               = func(uID string) string { return EndpointUsers + uID }\n\tEndpointUserAvatar         = func(uID, aID string) string { return EndpointCDNAvatars + uID + \"/\" + aID + \".png\" }\n\tEndpointUserAvatarAnimated = func(uID, aID string) string { return EndpointCDNAvatars + uID + \"/\" + aID + \".gif\" }\n\tEndpointDefaultUserAvatar  = func(idx int) string {\n\t\treturn EndpointCDN + \"embed/avatars/\" + strconv.Itoa(idx) + \".png\"\n\t}\n\tEndpointUserBanner = func(uID, cID string) string {\n\t\treturn EndpointCDNBanners + uID + \"/\" + cID + \".png\"\n\t}\n\tEndpointUserBannerAnimated = func(uID, cID string) string {\n\t\treturn EndpointCDNBanners + uID + \"/\" + cID + \".gif\"\n\t}\n\n\tEndpointUserGuilds                    = func(uID string) string { return EndpointUsers + uID + \"/guilds\" }\n\tEndpointUserGuild                     = func(uID, gID string) string { return EndpointUsers + uID + \"/guilds/\" + gID }\n\tEndpointUserGuildMember               = func(uID, gID string) string { return EndpointUserGuild(uID, gID) + \"/member\" }\n\tEndpointUserChannels                  = func(uID string) string { return EndpointUsers + uID + \"/channels\" }\n\tEndpointUserApplicationRoleConnection = func(aID string) string { return EndpointUsers + \"@me/applications/\" + aID + \"/role-connection\" }\n\tEndpointUserConnections               = func(uID string) string { return EndpointUsers + uID + \"/connections\" }\n\n\tEndpointGuild                    = func(gID string) string { return EndpointGuilds + gID }\n\tEndpointGuildAutoModeration      = func(gID string) string { return EndpointGuild(gID) + \"/auto-moderation\" }\n\tEndpointGuildAutoModerationRules = func(gID string) string { return EndpointGuildAutoModeration(gID) + \"/rules\" }\n\tEndpointGuildAutoModerationRule  = func(gID, rID string) string { return EndpointGuildAutoModerationRules(gID) + \"/\" + rID }\n\tEndpointGuildThreads             = func(gID string) string { return EndpointGuild(gID) + \"/threads\" }\n\tEndpointGuildActiveThreads       = func(gID string) string { return EndpointGuildThreads(gID) + \"/active\" }\n\tEndpointGuildPreview             = func(gID string) string { return EndpointGuilds + gID + \"/preview\" }\n\tEndpointGuildChannels            = func(gID string) string { return EndpointGuilds + gID + \"/channels\" }\n\tEndpointGuildMembers             = func(gID string) string { return EndpointGuilds + gID + \"/members\" }\n\tEndpointGuildMembersSearch       = func(gID string) string { return EndpointGuildMembers(gID) + \"/search\" }\n\tEndpointGuildMember              = func(gID, uID string) string { return EndpointGuilds + gID + \"/members/\" + uID }\n\tEndpointGuildMemberRole          = func(gID, uID, rID string) string { return EndpointGuilds + gID + \"/members/\" + uID + \"/roles/\" + rID }\n\tEndpointGuildBans                = func(gID string) string { return EndpointGuilds + gID + \"/bans\" }\n\tEndpointGuildBan                 = func(gID, uID string) string { return EndpointGuilds + gID + \"/bans/\" + uID }\n\tEndpointGuildIntegrations        = func(gID string) string { return EndpointGuilds + gID + \"/integrations\" }\n\tEndpointGuildIntegration         = func(gID, iID string) string { return EndpointGuilds + gID + \"/integrations/\" + iID }\n\tEndpointGuildRoles               = func(gID string) string { return EndpointGuilds + gID + \"/roles\" }\n\tEndpointGuildRole                = func(gID, rID string) string { return EndpointGuilds + gID + \"/roles/\" + rID }\n\tEndpointGuildInvites             = func(gID string) string { return EndpointGuilds + gID + \"/invites\" }\n\tEndpointGuildWidget              = func(gID string) string { return EndpointGuilds + gID + \"/widget\" }\n\tEndpointGuildEmbed               = EndpointGuildWidget\n\tEndpointGuildPrune               = func(gID string) string { return EndpointGuilds + gID + \"/prune\" }\n\tEndpointGuildIcon                = func(gID, hash string) string { return EndpointCDNIcons + gID + \"/\" + hash + \".png\" }\n\tEndpointGuildIconAnimated        = func(gID, hash string) string { return EndpointCDNIcons + gID + \"/\" + hash + \".gif\" }\n\tEndpointGuildSplash              = func(gID, hash string) string { return EndpointCDNSplashes + gID + \"/\" + hash + \".png\" }\n\tEndpointGuildWebhooks            = func(gID string) string { return EndpointGuilds + gID + \"/webhooks\" }\n\tEndpointGuildAuditLogs           = func(gID string) string { return EndpointGuilds + gID + \"/audit-logs\" }\n\tEndpointGuildEmojis              = func(gID string) string { return EndpointGuilds + gID + \"/emojis\" }\n\tEndpointGuildEmoji               = func(gID, eID string) string { return EndpointGuilds + gID + \"/emojis/\" + eID }\n\tEndpointGuildBanner              = func(gID, hash string) string { return EndpointCDNBanners + gID + \"/\" + hash + \".png\" }\n\tEndpointGuildBannerAnimated      = func(gID, hash string) string { return EndpointCDNBanners + gID + \"/\" + hash + \".gif\" }\n\tEndpointGuildStickers            = func(gID string) string { return EndpointGuilds + gID + \"/stickers\" }\n\tEndpointGuildSticker             = func(gID, sID string) string { return EndpointGuilds + gID + \"/stickers/\" + sID }\n\tEndpointStageInstance            = func(cID string) string { return EndpointStageInstances + \"/\" + cID }\n\tEndpointGuildScheduledEvents     = func(gID string) string { return EndpointGuilds + gID + \"/scheduled-events\" }\n\tEndpointGuildScheduledEvent      = func(gID, eID string) string { return EndpointGuilds + gID + \"/scheduled-events/\" + eID }\n\tEndpointGuildScheduledEventUsers = func(gID, eID string) string { return EndpointGuildScheduledEvent(gID, eID) + \"/users\" }\n\tEndpointGuildOnboarding          = func(gID string) string { return EndpointGuilds + gID + \"/onboarding\" }\n\tEndpointGuildTemplate            = func(tID string) string { return EndpointGuilds + \"templates/\" + tID }\n\tEndpointGuildTemplates           = func(gID string) string { return EndpointGuilds + gID + \"/templates\" }\n\tEndpointGuildTemplateSync        = func(gID, tID string) string { return EndpointGuilds + gID + \"/templates/\" + tID }\n\tEndpointGuildMemberAvatar        = func(gId, uID, aID string) string {\n\t\treturn EndpointCDNGuilds + gId + \"/users/\" + uID + \"/avatars/\" + aID + \".png\"\n\t}\n\tEndpointGuildMemberAvatarAnimated = func(gId, uID, aID string) string {\n\t\treturn EndpointCDNGuilds + gId + \"/users/\" + uID + \"/avatars/\" + aID + \".gif\"\n\t}\n\n\tEndpointRoleIcon = func(rID, hash string) string {\n\t\treturn EndpointCDNRoleIcons + rID + \"/\" + hash + \".png\"\n\t}\n\n\tEndpointChannel                             = func(cID string) string { return EndpointChannels + cID }\n\tEndpointChannelThreads                      = func(cID string) string { return EndpointChannel(cID) + \"/threads\" }\n\tEndpointChannelActiveThreads                = func(cID string) string { return EndpointChannelThreads(cID) + \"/active\" }\n\tEndpointChannelPublicArchivedThreads        = func(cID string) string { return EndpointChannelThreads(cID) + \"/archived/public\" }\n\tEndpointChannelPrivateArchivedThreads       = func(cID string) string { return EndpointChannelThreads(cID) + \"/archived/private\" }\n\tEndpointChannelJoinedPrivateArchivedThreads = func(cID string) string { return EndpointChannel(cID) + \"/users/@me/threads/archived/private\" }\n\tEndpointChannelPermissions                  = func(cID string) string { return EndpointChannels + cID + \"/permissions\" }\n\tEndpointChannelPermission                   = func(cID, tID string) string { return EndpointChannels + cID + \"/permissions/\" + tID }\n\tEndpointChannelInvites                      = func(cID string) string { return EndpointChannels + cID + \"/invites\" }\n\tEndpointChannelTyping                       = func(cID string) string { return EndpointChannels + cID + \"/typing\" }\n\tEndpointChannelMessages                     = func(cID string) string { return EndpointChannels + cID + \"/messages\" }\n\tEndpointChannelMessage                      = func(cID, mID string) string { return EndpointChannels + cID + \"/messages/\" + mID }\n\tEndpointChannelMessageThread                = func(cID, mID string) string { return EndpointChannelMessage(cID, mID) + \"/threads\" }\n\tEndpointChannelMessagesBulkDelete           = func(cID string) string { return EndpointChannel(cID) + \"/messages/bulk-delete\" }\n\tEndpointChannelMessagesPins                 = func(cID string) string { return EndpointChannel(cID) + \"/pins\" }\n\tEndpointChannelMessagePin                   = func(cID, mID string) string { return EndpointChannel(cID) + \"/pins/\" + mID }\n\tEndpointChannelMessageCrosspost             = func(cID, mID string) string { return EndpointChannel(cID) + \"/messages/\" + mID + \"/crosspost\" }\n\tEndpointChannelFollow                       = func(cID string) string { return EndpointChannel(cID) + \"/followers\" }\n\tEndpointThreadMembers                       = func(tID string) string { return EndpointChannel(tID) + \"/thread-members\" }\n\tEndpointThreadMember                        = func(tID, mID string) string { return EndpointThreadMembers(tID) + \"/\" + mID }\n\n\tEndpointGroupIcon = func(cID, hash string) string { return EndpointCDNChannelIcons + cID + \"/\" + hash + \".png\" }\n\n\tEndpointSticker            = func(sID string) string { return EndpointStickers + sID }\n\tEndpointNitroStickersPacks = EndpointAPI + \"/sticker-packs\"\n\n\tEndpointChannelWebhooks = func(cID string) string { return EndpointChannel(cID) + \"/webhooks\" }\n\tEndpointWebhook         = func(wID string) string { return EndpointWebhooks + wID }\n\tEndpointWebhookToken    = func(wID, token string) string { return EndpointWebhooks + wID + \"/\" + token }\n\tEndpointWebhookMessage  = func(wID, token, messageID string) string {\n\t\treturn EndpointWebhookToken(wID, token) + \"/messages/\" + messageID\n\t}\n\n\tEndpointMessageReactionsAll = func(cID, mID string) string {\n\t\treturn EndpointChannelMessage(cID, mID) + \"/reactions\"\n\t}\n\tEndpointMessageReactions = func(cID, mID, eID string) string {\n\t\treturn EndpointChannelMessage(cID, mID) + \"/reactions/\" + eID\n\t}\n\tEndpointMessageReaction = func(cID, mID, eID, uID string) string {\n\t\treturn EndpointMessageReactions(cID, mID, eID) + \"/\" + uID\n\t}\n\n\tEndpointPoll = func(cID, mID string) string {\n\t\treturn EndpointChannel(cID) + \"/polls/\" + mID\n\t}\n\tEndpointPollAnswerVoters = func(cID, mID string, aID int) string {\n\t\treturn EndpointPoll(cID, mID) + \"/answers/\" + strconv.Itoa(aID)\n\t}\n\tEndpointPollExpire = func(cID, mID string) string {\n\t\treturn EndpointPoll(cID, mID) + \"/expire\"\n\t}\n\n\tEndpointApplicationSKUs = func(aID string) string {\n\t\treturn EndpointApplication(aID) + \"/skus\"\n\t}\n\n\tEndpointEntitlements = func(aID string) string {\n\t\treturn EndpointApplication(aID) + \"/entitlements\"\n\t}\n\tEndpointEntitlement = func(aID, eID string) string {\n\t\treturn EndpointEntitlements(aID) + \"/\" + eID\n\t}\n\tEndpointEntitlementConsume = func(aID, eID string) string {\n\t\treturn EndpointEntitlement(aID, eID) + \"/consume\"\n\t}\n\n\tEndpointSubscriptions = func(skuID string) string {\n\t\treturn EndpointSKUs + \"/\" + skuID + \"/subscriptions\"\n\t}\n\tEndpointSubscription = func(skuID, subID string) string {\n\t\treturn EndpointSubscriptions(skuID) + \"/\" + subID\n\t}\n\n\tEndpointApplicationGlobalCommands = func(aID string) string {\n\t\treturn EndpointApplication(aID) + \"/commands\"\n\t}\n\tEndpointApplicationGlobalCommand = func(aID, cID string) string {\n\t\treturn EndpointApplicationGlobalCommands(aID) + \"/\" + cID\n\t}\n\n\tEndpointApplicationGuildCommands = func(aID, gID string) string {\n\t\treturn EndpointApplication(aID) + \"/guilds/\" + gID + \"/commands\"\n\t}\n\tEndpointApplicationGuildCommand = func(aID, gID, cID string) string {\n\t\treturn EndpointApplicationGuildCommands(aID, gID) + \"/\" + cID\n\t}\n\tEndpointApplicationCommandPermissions = func(aID, gID, cID string) string {\n\t\treturn EndpointApplicationGuildCommand(aID, gID, cID) + \"/permissions\"\n\t}\n\tEndpointApplicationCommandsGuildPermissions = func(aID, gID string) string {\n\t\treturn EndpointApplicationGuildCommands(aID, gID) + \"/permissions\"\n\t}\n\tEndpointInteraction = func(aID, iToken string) string {\n\t\treturn EndpointAPI + \"interactions/\" + aID + \"/\" + iToken\n\t}\n\tEndpointInteractionResponse = func(iID, iToken string) string {\n\t\treturn EndpointInteraction(iID, iToken) + \"/callback\"\n\t}\n\tEndpointInteractionResponseActions = func(aID, iToken string) string {\n\t\treturn EndpointWebhookMessage(aID, iToken, \"@original\")\n\t}\n\tEndpointFollowupMessage = func(aID, iToken string) string {\n\t\treturn EndpointWebhookToken(aID, iToken)\n\t}\n\tEndpointFollowupMessageActions = func(aID, iToken, mID string) string {\n\t\treturn EndpointWebhookMessage(aID, iToken, mID)\n\t}\n\n\tEndpointGuildCreate = EndpointAPI + \"guilds\"\n\n\tEndpointInvite = func(iID string) string { return EndpointAPI + \"invites/\" + iID }\n\n\tEndpointEmoji         = func(eID string) string { return EndpointCDN + \"emojis/\" + eID + \".png\" }\n\tEndpointEmojiAnimated = func(eID string) string { return EndpointCDN + \"emojis/\" + eID + \".gif\" }\n\n\tEndpointApplications                      = EndpointAPI + \"applications\"\n\tEndpointApplication                       = func(aID string) string { return EndpointApplications + \"/\" + aID }\n\tEndpointApplicationRoleConnectionMetadata = func(aID string) string { return EndpointApplication(aID) + \"/role-connections/metadata\" }\n\n\tEndpointApplicationEmojis = func(aID string) string { return EndpointApplication(aID) + \"/emojis\" }\n\tEndpointApplicationEmoji  = func(aID, eID string) string { return EndpointApplication(aID) + \"/emojis/\" + eID }\n\n\tEndpointOAuth2                  = EndpointAPI + \"oauth2/\"\n\tEndpointOAuth2Applications      = EndpointOAuth2 + \"applications\"\n\tEndpointOAuth2Application       = func(aID string) string { return EndpointOAuth2Applications + \"/\" + aID }\n\tEndpointOAuth2ApplicationsBot   = func(aID string) string { return EndpointOAuth2Applications + \"/\" + aID + \"/bot\" }\n\tEndpointOAuth2ApplicationAssets = func(aID string) string { return EndpointOAuth2Applications + \"/\" + aID + \"/assets\" }\n\n\t// TODO: Deprecated, remove in the next release\n\tEndpointOauth2                  = EndpointOAuth2\n\tEndpointOauth2Applications      = EndpointOAuth2Applications\n\tEndpointOauth2Application       = EndpointOAuth2Application\n\tEndpointOauth2ApplicationsBot   = EndpointOAuth2ApplicationsBot\n\tEndpointOauth2ApplicationAssets = EndpointOAuth2ApplicationAssets\n)\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 7.0322265625,
          "content": "package discordgo\n\n// EventHandler is an interface for Discord events.\ntype EventHandler interface {\n\t// Type returns the type of event this handler belongs to.\n\tType() string\n\n\t// Handle is called whenever an event of Type() happens.\n\t// It is the receivers responsibility to type assert that the interface\n\t// is the expected struct.\n\tHandle(*Session, interface{})\n}\n\n// EventInterfaceProvider is an interface for providing empty interfaces for\n// Discord events.\ntype EventInterfaceProvider interface {\n\t// Type is the type of event this handler belongs to.\n\tType() string\n\n\t// New returns a new instance of the struct this event handler handles.\n\t// This is called once per event.\n\t// The struct is provided to all handlers of the same Type().\n\tNew() interface{}\n}\n\n// interfaceEventType is the event handler type for interface{} events.\nconst interfaceEventType = \"__INTERFACE__\"\n\n// interfaceEventHandler is an event handler for interface{} events.\ntype interfaceEventHandler func(*Session, interface{})\n\n// Type returns the event type for interface{} events.\nfunc (eh interfaceEventHandler) Type() string {\n\treturn interfaceEventType\n}\n\n// Handle is the handler for an interface{} event.\nfunc (eh interfaceEventHandler) Handle(s *Session, i interface{}) {\n\teh(s, i)\n}\n\nvar registeredInterfaceProviders = map[string]EventInterfaceProvider{}\n\n// registerInterfaceProvider registers a provider so that DiscordGo can\n// access it's New() method.\nfunc registerInterfaceProvider(eh EventInterfaceProvider) {\n\tif _, ok := registeredInterfaceProviders[eh.Type()]; ok {\n\t\treturn\n\t\t// XXX:\n\t\t// if we should error here, we need to do something with it.\n\t\t// fmt.Errorf(\"event %s already registered\", eh.Type())\n\t}\n\tregisteredInterfaceProviders[eh.Type()] = eh\n\treturn\n}\n\n// eventHandlerInstance is a wrapper around an event handler, as functions\n// cannot be compared directly.\ntype eventHandlerInstance struct {\n\teventHandler EventHandler\n}\n\n// addEventHandler adds an event handler that will be fired anytime\n// the Discord WSAPI matching eventHandler.Type() fires.\nfunc (s *Session) addEventHandler(eventHandler EventHandler) func() {\n\ts.handlersMu.Lock()\n\tdefer s.handlersMu.Unlock()\n\n\tif s.handlers == nil {\n\t\ts.handlers = map[string][]*eventHandlerInstance{}\n\t}\n\n\tehi := &eventHandlerInstance{eventHandler}\n\ts.handlers[eventHandler.Type()] = append(s.handlers[eventHandler.Type()], ehi)\n\n\treturn func() {\n\t\ts.removeEventHandlerInstance(eventHandler.Type(), ehi)\n\t}\n}\n\n// addEventHandler adds an event handler that will be fired the next time\n// the Discord WSAPI matching eventHandler.Type() fires.\nfunc (s *Session) addEventHandlerOnce(eventHandler EventHandler) func() {\n\ts.handlersMu.Lock()\n\tdefer s.handlersMu.Unlock()\n\n\tif s.onceHandlers == nil {\n\t\ts.onceHandlers = map[string][]*eventHandlerInstance{}\n\t}\n\n\tehi := &eventHandlerInstance{eventHandler}\n\ts.onceHandlers[eventHandler.Type()] = append(s.onceHandlers[eventHandler.Type()], ehi)\n\n\treturn func() {\n\t\ts.removeEventHandlerInstance(eventHandler.Type(), ehi)\n\t}\n}\n\n// AddHandler allows you to add an event handler that will be fired anytime\n// the Discord WSAPI event that matches the function fires.\n// The first parameter is a *Session, and the second parameter is a pointer\n// to a struct corresponding to the event for which you want to listen.\n//\n// eg:\n//     Session.AddHandler(func(s *discordgo.Session, m *discordgo.MessageCreate) {\n//     })\n//\n// or:\n//     Session.AddHandler(func(s *discordgo.Session, m *discordgo.PresenceUpdate) {\n//     })\n//\n// List of events can be found at this page, with corresponding names in the\n// library for each event: https://discord.com/developers/docs/topics/gateway#event-names\n// There are also synthetic events fired by the library internally which are\n// available for handling, like Connect, Disconnect, and RateLimit.\n// events.go contains all of the Discord WSAPI and synthetic events that can be handled.\n//\n// The return value of this method is a function, that when called will remove the\n// event handler.\nfunc (s *Session) AddHandler(handler interface{}) func() {\n\teh := handlerForInterface(handler)\n\n\tif eh == nil {\n\t\ts.log(LogError, \"Invalid handler type, handler will never be called\")\n\t\treturn func() {}\n\t}\n\n\treturn s.addEventHandler(eh)\n}\n\n// AddHandlerOnce allows you to add an event handler that will be fired the next time\n// the Discord WSAPI event that matches the function fires.\n// See AddHandler for more details.\nfunc (s *Session) AddHandlerOnce(handler interface{}) func() {\n\teh := handlerForInterface(handler)\n\n\tif eh == nil {\n\t\ts.log(LogError, \"Invalid handler type, handler will never be called\")\n\t\treturn func() {}\n\t}\n\n\treturn s.addEventHandlerOnce(eh)\n}\n\n// removeEventHandler instance removes an event handler instance.\nfunc (s *Session) removeEventHandlerInstance(t string, ehi *eventHandlerInstance) {\n\ts.handlersMu.Lock()\n\tdefer s.handlersMu.Unlock()\n\n\thandlers := s.handlers[t]\n\tfor i := range handlers {\n\t\tif handlers[i] == ehi {\n\t\t\ts.handlers[t] = append(handlers[:i], handlers[i+1:]...)\n\t\t}\n\t}\n\n\tonceHandlers := s.onceHandlers[t]\n\tfor i := range onceHandlers {\n\t\tif onceHandlers[i] == ehi {\n\t\t\ts.onceHandlers[t] = append(onceHandlers[:i], onceHandlers[i+1:]...)\n\t\t}\n\t}\n}\n\n// Handles calling permanent and once handlers for an event type.\nfunc (s *Session) handle(t string, i interface{}) {\n\tfor _, eh := range s.handlers[t] {\n\t\tif s.SyncEvents {\n\t\t\teh.eventHandler.Handle(s, i)\n\t\t} else {\n\t\t\tgo eh.eventHandler.Handle(s, i)\n\t\t}\n\t}\n\n\tif len(s.onceHandlers[t]) > 0 {\n\t\tfor _, eh := range s.onceHandlers[t] {\n\t\t\tif s.SyncEvents {\n\t\t\t\teh.eventHandler.Handle(s, i)\n\t\t\t} else {\n\t\t\t\tgo eh.eventHandler.Handle(s, i)\n\t\t\t}\n\t\t}\n\t\ts.onceHandlers[t] = nil\n\t}\n}\n\n// Handles an event type by calling internal methods, firing handlers and firing the\n// interface{} event.\nfunc (s *Session) handleEvent(t string, i interface{}) {\n\ts.handlersMu.RLock()\n\tdefer s.handlersMu.RUnlock()\n\n\t// All events are dispatched internally first.\n\ts.onInterface(i)\n\n\t// Then they are dispatched to anyone handling interface{} events.\n\ts.handle(interfaceEventType, i)\n\n\t// Finally they are dispatched to any typed handlers.\n\ts.handle(t, i)\n}\n\n// setGuildIds will set the GuildID on all the members of a guild.\n// This is done as event data does not have it set.\nfunc setGuildIds(g *Guild) {\n\tfor _, c := range g.Channels {\n\t\tc.GuildID = g.ID\n\t}\n\n\tfor _, m := range g.Members {\n\t\tm.GuildID = g.ID\n\t}\n\n\tfor _, vs := range g.VoiceStates {\n\t\tvs.GuildID = g.ID\n\t}\n}\n\n// onInterface handles all internal events and routes them to the appropriate internal handler.\nfunc (s *Session) onInterface(i interface{}) {\n\tswitch t := i.(type) {\n\tcase *Ready:\n\t\tfor _, g := range t.Guilds {\n\t\t\tsetGuildIds(g)\n\t\t}\n\t\ts.onReady(t)\n\tcase *GuildCreate:\n\t\tsetGuildIds(t.Guild)\n\tcase *GuildUpdate:\n\t\tsetGuildIds(t.Guild)\n\tcase *VoiceServerUpdate:\n\t\tgo s.onVoiceServerUpdate(t)\n\tcase *VoiceStateUpdate:\n\t\tgo s.onVoiceStateUpdate(t)\n\t}\n\terr := s.State.OnInterface(s, i)\n\tif err != nil {\n\t\ts.log(LogDebug, \"error dispatching internal event, %s\", err)\n\t}\n}\n\n// onReady handles the ready event.\nfunc (s *Session) onReady(r *Ready) {\n\n\t// Store the SessionID within the Session struct.\n\ts.sessionID = r.SessionID\n}\n"
        },
        {
          "name": "eventhandlers.go",
          "type": "blob",
          "size": 57.4541015625,
          "content": "// Code generated by \\\"eventhandlers\\\"; DO NOT EDIT\n// See events.go\n\npackage discordgo\n\n// Following are all the event types.\n// Event type values are used to match the events returned by Discord.\n// EventTypes surrounded by __ are synthetic and are internal to DiscordGo.\nconst (\n\tapplicationCommandPermissionsUpdateEventType = \"APPLICATION_COMMAND_PERMISSIONS_UPDATE\"\n\tautoModerationActionExecutionEventType       = \"AUTO_MODERATION_ACTION_EXECUTION\"\n\tautoModerationRuleCreateEventType            = \"AUTO_MODERATION_RULE_CREATE\"\n\tautoModerationRuleDeleteEventType            = \"AUTO_MODERATION_RULE_DELETE\"\n\tautoModerationRuleUpdateEventType            = \"AUTO_MODERATION_RULE_UPDATE\"\n\tchannelCreateEventType                       = \"CHANNEL_CREATE\"\n\tchannelDeleteEventType                       = \"CHANNEL_DELETE\"\n\tchannelPinsUpdateEventType                   = \"CHANNEL_PINS_UPDATE\"\n\tchannelUpdateEventType                       = \"CHANNEL_UPDATE\"\n\tconnectEventType                             = \"__CONNECT__\"\n\tdisconnectEventType                          = \"__DISCONNECT__\"\n\tentitlementCreateEventType                   = \"ENTITLEMENT_CREATE\"\n\tentitlementDeleteEventType                   = \"ENTITLEMENT_DELETE\"\n\tentitlementUpdateEventType                   = \"ENTITLEMENT_UPDATE\"\n\teventEventType                               = \"__EVENT__\"\n\tguildAuditLogEntryCreateEventType            = \"GUILD_AUDIT_LOG_ENTRY_CREATE\"\n\tguildBanAddEventType                         = \"GUILD_BAN_ADD\"\n\tguildBanRemoveEventType                      = \"GUILD_BAN_REMOVE\"\n\tguildCreateEventType                         = \"GUILD_CREATE\"\n\tguildDeleteEventType                         = \"GUILD_DELETE\"\n\tguildEmojisUpdateEventType                   = \"GUILD_EMOJIS_UPDATE\"\n\tguildIntegrationsUpdateEventType             = \"GUILD_INTEGRATIONS_UPDATE\"\n\tguildMemberAddEventType                      = \"GUILD_MEMBER_ADD\"\n\tguildMemberRemoveEventType                   = \"GUILD_MEMBER_REMOVE\"\n\tguildMemberUpdateEventType                   = \"GUILD_MEMBER_UPDATE\"\n\tguildMembersChunkEventType                   = \"GUILD_MEMBERS_CHUNK\"\n\tguildRoleCreateEventType                     = \"GUILD_ROLE_CREATE\"\n\tguildRoleDeleteEventType                     = \"GUILD_ROLE_DELETE\"\n\tguildRoleUpdateEventType                     = \"GUILD_ROLE_UPDATE\"\n\tguildScheduledEventCreateEventType           = \"GUILD_SCHEDULED_EVENT_CREATE\"\n\tguildScheduledEventDeleteEventType           = \"GUILD_SCHEDULED_EVENT_DELETE\"\n\tguildScheduledEventUpdateEventType           = \"GUILD_SCHEDULED_EVENT_UPDATE\"\n\tguildScheduledEventUserAddEventType          = \"GUILD_SCHEDULED_EVENT_USER_ADD\"\n\tguildScheduledEventUserRemoveEventType       = \"GUILD_SCHEDULED_EVENT_USER_REMOVE\"\n\tguildUpdateEventType                         = \"GUILD_UPDATE\"\n\tintegrationCreateEventType                   = \"INTEGRATION_CREATE\"\n\tintegrationDeleteEventType                   = \"INTEGRATION_DELETE\"\n\tintegrationUpdateEventType                   = \"INTEGRATION_UPDATE\"\n\tinteractionCreateEventType                   = \"INTERACTION_CREATE\"\n\tinviteCreateEventType                        = \"INVITE_CREATE\"\n\tinviteDeleteEventType                        = \"INVITE_DELETE\"\n\tmessageCreateEventType                       = \"MESSAGE_CREATE\"\n\tmessageDeleteEventType                       = \"MESSAGE_DELETE\"\n\tmessageDeleteBulkEventType                   = \"MESSAGE_DELETE_BULK\"\n\tmessagePollVoteAddEventType                  = \"MESSAGE_POLL_VOTE_ADD\"\n\tmessagePollVoteRemoveEventType               = \"MESSAGE_POLL_VOTE_REMOVE\"\n\tmessageReactionAddEventType                  = \"MESSAGE_REACTION_ADD\"\n\tmessageReactionRemoveEventType               = \"MESSAGE_REACTION_REMOVE\"\n\tmessageReactionRemoveAllEventType            = \"MESSAGE_REACTION_REMOVE_ALL\"\n\tmessageUpdateEventType                       = \"MESSAGE_UPDATE\"\n\tpresenceUpdateEventType                      = \"PRESENCE_UPDATE\"\n\tpresencesReplaceEventType                    = \"PRESENCES_REPLACE\"\n\trateLimitEventType                           = \"__RATE_LIMIT__\"\n\treadyEventType                               = \"READY\"\n\tresumedEventType                             = \"RESUMED\"\n\tstageInstanceEventCreateEventType            = \"STAGE_INSTANCE_EVENT_CREATE\"\n\tstageInstanceEventDeleteEventType            = \"STAGE_INSTANCE_EVENT_DELETE\"\n\tstageInstanceEventUpdateEventType            = \"STAGE_INSTANCE_EVENT_UPDATE\"\n\tthreadCreateEventType                        = \"THREAD_CREATE\"\n\tthreadDeleteEventType                        = \"THREAD_DELETE\"\n\tthreadListSyncEventType                      = \"THREAD_LIST_SYNC\"\n\tthreadMemberUpdateEventType                  = \"THREAD_MEMBER_UPDATE\"\n\tthreadMembersUpdateEventType                 = \"THREAD_MEMBERS_UPDATE\"\n\tthreadUpdateEventType                        = \"THREAD_UPDATE\"\n\ttypingStartEventType                         = \"TYPING_START\"\n\tuserUpdateEventType                          = \"USER_UPDATE\"\n\tvoiceServerUpdateEventType                   = \"VOICE_SERVER_UPDATE\"\n\tvoiceStateUpdateEventType                    = \"VOICE_STATE_UPDATE\"\n\twebhooksUpdateEventType                      = \"WEBHOOKS_UPDATE\"\n)\n\n// applicationCommandPermissionsUpdateEventHandler is an event handler for ApplicationCommandPermissionsUpdate events.\ntype applicationCommandPermissionsUpdateEventHandler func(*Session, *ApplicationCommandPermissionsUpdate)\n\n// Type returns the event type for ApplicationCommandPermissionsUpdate events.\nfunc (eh applicationCommandPermissionsUpdateEventHandler) Type() string {\n\treturn applicationCommandPermissionsUpdateEventType\n}\n\n// New returns a new instance of ApplicationCommandPermissionsUpdate.\nfunc (eh applicationCommandPermissionsUpdateEventHandler) New() interface{} {\n\treturn &ApplicationCommandPermissionsUpdate{}\n}\n\n// Handle is the handler for ApplicationCommandPermissionsUpdate events.\nfunc (eh applicationCommandPermissionsUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ApplicationCommandPermissionsUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// autoModerationActionExecutionEventHandler is an event handler for AutoModerationActionExecution events.\ntype autoModerationActionExecutionEventHandler func(*Session, *AutoModerationActionExecution)\n\n// Type returns the event type for AutoModerationActionExecution events.\nfunc (eh autoModerationActionExecutionEventHandler) Type() string {\n\treturn autoModerationActionExecutionEventType\n}\n\n// New returns a new instance of AutoModerationActionExecution.\nfunc (eh autoModerationActionExecutionEventHandler) New() interface{} {\n\treturn &AutoModerationActionExecution{}\n}\n\n// Handle is the handler for AutoModerationActionExecution events.\nfunc (eh autoModerationActionExecutionEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*AutoModerationActionExecution); ok {\n\t\teh(s, t)\n\t}\n}\n\n// autoModerationRuleCreateEventHandler is an event handler for AutoModerationRuleCreate events.\ntype autoModerationRuleCreateEventHandler func(*Session, *AutoModerationRuleCreate)\n\n// Type returns the event type for AutoModerationRuleCreate events.\nfunc (eh autoModerationRuleCreateEventHandler) Type() string {\n\treturn autoModerationRuleCreateEventType\n}\n\n// New returns a new instance of AutoModerationRuleCreate.\nfunc (eh autoModerationRuleCreateEventHandler) New() interface{} {\n\treturn &AutoModerationRuleCreate{}\n}\n\n// Handle is the handler for AutoModerationRuleCreate events.\nfunc (eh autoModerationRuleCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*AutoModerationRuleCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// autoModerationRuleDeleteEventHandler is an event handler for AutoModerationRuleDelete events.\ntype autoModerationRuleDeleteEventHandler func(*Session, *AutoModerationRuleDelete)\n\n// Type returns the event type for AutoModerationRuleDelete events.\nfunc (eh autoModerationRuleDeleteEventHandler) Type() string {\n\treturn autoModerationRuleDeleteEventType\n}\n\n// New returns a new instance of AutoModerationRuleDelete.\nfunc (eh autoModerationRuleDeleteEventHandler) New() interface{} {\n\treturn &AutoModerationRuleDelete{}\n}\n\n// Handle is the handler for AutoModerationRuleDelete events.\nfunc (eh autoModerationRuleDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*AutoModerationRuleDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// autoModerationRuleUpdateEventHandler is an event handler for AutoModerationRuleUpdate events.\ntype autoModerationRuleUpdateEventHandler func(*Session, *AutoModerationRuleUpdate)\n\n// Type returns the event type for AutoModerationRuleUpdate events.\nfunc (eh autoModerationRuleUpdateEventHandler) Type() string {\n\treturn autoModerationRuleUpdateEventType\n}\n\n// New returns a new instance of AutoModerationRuleUpdate.\nfunc (eh autoModerationRuleUpdateEventHandler) New() interface{} {\n\treturn &AutoModerationRuleUpdate{}\n}\n\n// Handle is the handler for AutoModerationRuleUpdate events.\nfunc (eh autoModerationRuleUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*AutoModerationRuleUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// channelCreateEventHandler is an event handler for ChannelCreate events.\ntype channelCreateEventHandler func(*Session, *ChannelCreate)\n\n// Type returns the event type for ChannelCreate events.\nfunc (eh channelCreateEventHandler) Type() string {\n\treturn channelCreateEventType\n}\n\n// New returns a new instance of ChannelCreate.\nfunc (eh channelCreateEventHandler) New() interface{} {\n\treturn &ChannelCreate{}\n}\n\n// Handle is the handler for ChannelCreate events.\nfunc (eh channelCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ChannelCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// channelDeleteEventHandler is an event handler for ChannelDelete events.\ntype channelDeleteEventHandler func(*Session, *ChannelDelete)\n\n// Type returns the event type for ChannelDelete events.\nfunc (eh channelDeleteEventHandler) Type() string {\n\treturn channelDeleteEventType\n}\n\n// New returns a new instance of ChannelDelete.\nfunc (eh channelDeleteEventHandler) New() interface{} {\n\treturn &ChannelDelete{}\n}\n\n// Handle is the handler for ChannelDelete events.\nfunc (eh channelDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ChannelDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// channelPinsUpdateEventHandler is an event handler for ChannelPinsUpdate events.\ntype channelPinsUpdateEventHandler func(*Session, *ChannelPinsUpdate)\n\n// Type returns the event type for ChannelPinsUpdate events.\nfunc (eh channelPinsUpdateEventHandler) Type() string {\n\treturn channelPinsUpdateEventType\n}\n\n// New returns a new instance of ChannelPinsUpdate.\nfunc (eh channelPinsUpdateEventHandler) New() interface{} {\n\treturn &ChannelPinsUpdate{}\n}\n\n// Handle is the handler for ChannelPinsUpdate events.\nfunc (eh channelPinsUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ChannelPinsUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// channelUpdateEventHandler is an event handler for ChannelUpdate events.\ntype channelUpdateEventHandler func(*Session, *ChannelUpdate)\n\n// Type returns the event type for ChannelUpdate events.\nfunc (eh channelUpdateEventHandler) Type() string {\n\treturn channelUpdateEventType\n}\n\n// New returns a new instance of ChannelUpdate.\nfunc (eh channelUpdateEventHandler) New() interface{} {\n\treturn &ChannelUpdate{}\n}\n\n// Handle is the handler for ChannelUpdate events.\nfunc (eh channelUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ChannelUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// connectEventHandler is an event handler for Connect events.\ntype connectEventHandler func(*Session, *Connect)\n\n// Type returns the event type for Connect events.\nfunc (eh connectEventHandler) Type() string {\n\treturn connectEventType\n}\n\n// Handle is the handler for Connect events.\nfunc (eh connectEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*Connect); ok {\n\t\teh(s, t)\n\t}\n}\n\n// disconnectEventHandler is an event handler for Disconnect events.\ntype disconnectEventHandler func(*Session, *Disconnect)\n\n// Type returns the event type for Disconnect events.\nfunc (eh disconnectEventHandler) Type() string {\n\treturn disconnectEventType\n}\n\n// Handle is the handler for Disconnect events.\nfunc (eh disconnectEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*Disconnect); ok {\n\t\teh(s, t)\n\t}\n}\n\n// entitlementCreateEventHandler is an event handler for EntitlementCreate events.\ntype entitlementCreateEventHandler func(*Session, *EntitlementCreate)\n\n// Type returns the event type for EntitlementCreate events.\nfunc (eh entitlementCreateEventHandler) Type() string {\n\treturn entitlementCreateEventType\n}\n\n// New returns a new instance of EntitlementCreate.\nfunc (eh entitlementCreateEventHandler) New() interface{} {\n\treturn &EntitlementCreate{}\n}\n\n// Handle is the handler for EntitlementCreate events.\nfunc (eh entitlementCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*EntitlementCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// entitlementDeleteEventHandler is an event handler for EntitlementDelete events.\ntype entitlementDeleteEventHandler func(*Session, *EntitlementDelete)\n\n// Type returns the event type for EntitlementDelete events.\nfunc (eh entitlementDeleteEventHandler) Type() string {\n\treturn entitlementDeleteEventType\n}\n\n// New returns a new instance of EntitlementDelete.\nfunc (eh entitlementDeleteEventHandler) New() interface{} {\n\treturn &EntitlementDelete{}\n}\n\n// Handle is the handler for EntitlementDelete events.\nfunc (eh entitlementDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*EntitlementDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// entitlementUpdateEventHandler is an event handler for EntitlementUpdate events.\ntype entitlementUpdateEventHandler func(*Session, *EntitlementUpdate)\n\n// Type returns the event type for EntitlementUpdate events.\nfunc (eh entitlementUpdateEventHandler) Type() string {\n\treturn entitlementUpdateEventType\n}\n\n// New returns a new instance of EntitlementUpdate.\nfunc (eh entitlementUpdateEventHandler) New() interface{} {\n\treturn &EntitlementUpdate{}\n}\n\n// Handle is the handler for EntitlementUpdate events.\nfunc (eh entitlementUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*EntitlementUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// eventEventHandler is an event handler for Event events.\ntype eventEventHandler func(*Session, *Event)\n\n// Type returns the event type for Event events.\nfunc (eh eventEventHandler) Type() string {\n\treturn eventEventType\n}\n\n// Handle is the handler for Event events.\nfunc (eh eventEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*Event); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildAuditLogEntryCreateEventHandler is an event handler for GuildAuditLogEntryCreate events.\ntype guildAuditLogEntryCreateEventHandler func(*Session, *GuildAuditLogEntryCreate)\n\n// Type returns the event type for GuildAuditLogEntryCreate events.\nfunc (eh guildAuditLogEntryCreateEventHandler) Type() string {\n\treturn guildAuditLogEntryCreateEventType\n}\n\n// New returns a new instance of GuildAuditLogEntryCreate.\nfunc (eh guildAuditLogEntryCreateEventHandler) New() interface{} {\n\treturn &GuildAuditLogEntryCreate{}\n}\n\n// Handle is the handler for GuildAuditLogEntryCreate events.\nfunc (eh guildAuditLogEntryCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildAuditLogEntryCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildBanAddEventHandler is an event handler for GuildBanAdd events.\ntype guildBanAddEventHandler func(*Session, *GuildBanAdd)\n\n// Type returns the event type for GuildBanAdd events.\nfunc (eh guildBanAddEventHandler) Type() string {\n\treturn guildBanAddEventType\n}\n\n// New returns a new instance of GuildBanAdd.\nfunc (eh guildBanAddEventHandler) New() interface{} {\n\treturn &GuildBanAdd{}\n}\n\n// Handle is the handler for GuildBanAdd events.\nfunc (eh guildBanAddEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildBanAdd); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildBanRemoveEventHandler is an event handler for GuildBanRemove events.\ntype guildBanRemoveEventHandler func(*Session, *GuildBanRemove)\n\n// Type returns the event type for GuildBanRemove events.\nfunc (eh guildBanRemoveEventHandler) Type() string {\n\treturn guildBanRemoveEventType\n}\n\n// New returns a new instance of GuildBanRemove.\nfunc (eh guildBanRemoveEventHandler) New() interface{} {\n\treturn &GuildBanRemove{}\n}\n\n// Handle is the handler for GuildBanRemove events.\nfunc (eh guildBanRemoveEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildBanRemove); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildCreateEventHandler is an event handler for GuildCreate events.\ntype guildCreateEventHandler func(*Session, *GuildCreate)\n\n// Type returns the event type for GuildCreate events.\nfunc (eh guildCreateEventHandler) Type() string {\n\treturn guildCreateEventType\n}\n\n// New returns a new instance of GuildCreate.\nfunc (eh guildCreateEventHandler) New() interface{} {\n\treturn &GuildCreate{}\n}\n\n// Handle is the handler for GuildCreate events.\nfunc (eh guildCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildDeleteEventHandler is an event handler for GuildDelete events.\ntype guildDeleteEventHandler func(*Session, *GuildDelete)\n\n// Type returns the event type for GuildDelete events.\nfunc (eh guildDeleteEventHandler) Type() string {\n\treturn guildDeleteEventType\n}\n\n// New returns a new instance of GuildDelete.\nfunc (eh guildDeleteEventHandler) New() interface{} {\n\treturn &GuildDelete{}\n}\n\n// Handle is the handler for GuildDelete events.\nfunc (eh guildDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildEmojisUpdateEventHandler is an event handler for GuildEmojisUpdate events.\ntype guildEmojisUpdateEventHandler func(*Session, *GuildEmojisUpdate)\n\n// Type returns the event type for GuildEmojisUpdate events.\nfunc (eh guildEmojisUpdateEventHandler) Type() string {\n\treturn guildEmojisUpdateEventType\n}\n\n// New returns a new instance of GuildEmojisUpdate.\nfunc (eh guildEmojisUpdateEventHandler) New() interface{} {\n\treturn &GuildEmojisUpdate{}\n}\n\n// Handle is the handler for GuildEmojisUpdate events.\nfunc (eh guildEmojisUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildEmojisUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildIntegrationsUpdateEventHandler is an event handler for GuildIntegrationsUpdate events.\ntype guildIntegrationsUpdateEventHandler func(*Session, *GuildIntegrationsUpdate)\n\n// Type returns the event type for GuildIntegrationsUpdate events.\nfunc (eh guildIntegrationsUpdateEventHandler) Type() string {\n\treturn guildIntegrationsUpdateEventType\n}\n\n// New returns a new instance of GuildIntegrationsUpdate.\nfunc (eh guildIntegrationsUpdateEventHandler) New() interface{} {\n\treturn &GuildIntegrationsUpdate{}\n}\n\n// Handle is the handler for GuildIntegrationsUpdate events.\nfunc (eh guildIntegrationsUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildIntegrationsUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildMemberAddEventHandler is an event handler for GuildMemberAdd events.\ntype guildMemberAddEventHandler func(*Session, *GuildMemberAdd)\n\n// Type returns the event type for GuildMemberAdd events.\nfunc (eh guildMemberAddEventHandler) Type() string {\n\treturn guildMemberAddEventType\n}\n\n// New returns a new instance of GuildMemberAdd.\nfunc (eh guildMemberAddEventHandler) New() interface{} {\n\treturn &GuildMemberAdd{}\n}\n\n// Handle is the handler for GuildMemberAdd events.\nfunc (eh guildMemberAddEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildMemberAdd); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildMemberRemoveEventHandler is an event handler for GuildMemberRemove events.\ntype guildMemberRemoveEventHandler func(*Session, *GuildMemberRemove)\n\n// Type returns the event type for GuildMemberRemove events.\nfunc (eh guildMemberRemoveEventHandler) Type() string {\n\treturn guildMemberRemoveEventType\n}\n\n// New returns a new instance of GuildMemberRemove.\nfunc (eh guildMemberRemoveEventHandler) New() interface{} {\n\treturn &GuildMemberRemove{}\n}\n\n// Handle is the handler for GuildMemberRemove events.\nfunc (eh guildMemberRemoveEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildMemberRemove); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildMemberUpdateEventHandler is an event handler for GuildMemberUpdate events.\ntype guildMemberUpdateEventHandler func(*Session, *GuildMemberUpdate)\n\n// Type returns the event type for GuildMemberUpdate events.\nfunc (eh guildMemberUpdateEventHandler) Type() string {\n\treturn guildMemberUpdateEventType\n}\n\n// New returns a new instance of GuildMemberUpdate.\nfunc (eh guildMemberUpdateEventHandler) New() interface{} {\n\treturn &GuildMemberUpdate{}\n}\n\n// Handle is the handler for GuildMemberUpdate events.\nfunc (eh guildMemberUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildMemberUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildMembersChunkEventHandler is an event handler for GuildMembersChunk events.\ntype guildMembersChunkEventHandler func(*Session, *GuildMembersChunk)\n\n// Type returns the event type for GuildMembersChunk events.\nfunc (eh guildMembersChunkEventHandler) Type() string {\n\treturn guildMembersChunkEventType\n}\n\n// New returns a new instance of GuildMembersChunk.\nfunc (eh guildMembersChunkEventHandler) New() interface{} {\n\treturn &GuildMembersChunk{}\n}\n\n// Handle is the handler for GuildMembersChunk events.\nfunc (eh guildMembersChunkEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildMembersChunk); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildRoleCreateEventHandler is an event handler for GuildRoleCreate events.\ntype guildRoleCreateEventHandler func(*Session, *GuildRoleCreate)\n\n// Type returns the event type for GuildRoleCreate events.\nfunc (eh guildRoleCreateEventHandler) Type() string {\n\treturn guildRoleCreateEventType\n}\n\n// New returns a new instance of GuildRoleCreate.\nfunc (eh guildRoleCreateEventHandler) New() interface{} {\n\treturn &GuildRoleCreate{}\n}\n\n// Handle is the handler for GuildRoleCreate events.\nfunc (eh guildRoleCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildRoleCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildRoleDeleteEventHandler is an event handler for GuildRoleDelete events.\ntype guildRoleDeleteEventHandler func(*Session, *GuildRoleDelete)\n\n// Type returns the event type for GuildRoleDelete events.\nfunc (eh guildRoleDeleteEventHandler) Type() string {\n\treturn guildRoleDeleteEventType\n}\n\n// New returns a new instance of GuildRoleDelete.\nfunc (eh guildRoleDeleteEventHandler) New() interface{} {\n\treturn &GuildRoleDelete{}\n}\n\n// Handle is the handler for GuildRoleDelete events.\nfunc (eh guildRoleDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildRoleDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildRoleUpdateEventHandler is an event handler for GuildRoleUpdate events.\ntype guildRoleUpdateEventHandler func(*Session, *GuildRoleUpdate)\n\n// Type returns the event type for GuildRoleUpdate events.\nfunc (eh guildRoleUpdateEventHandler) Type() string {\n\treturn guildRoleUpdateEventType\n}\n\n// New returns a new instance of GuildRoleUpdate.\nfunc (eh guildRoleUpdateEventHandler) New() interface{} {\n\treturn &GuildRoleUpdate{}\n}\n\n// Handle is the handler for GuildRoleUpdate events.\nfunc (eh guildRoleUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildRoleUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildScheduledEventCreateEventHandler is an event handler for GuildScheduledEventCreate events.\ntype guildScheduledEventCreateEventHandler func(*Session, *GuildScheduledEventCreate)\n\n// Type returns the event type for GuildScheduledEventCreate events.\nfunc (eh guildScheduledEventCreateEventHandler) Type() string {\n\treturn guildScheduledEventCreateEventType\n}\n\n// New returns a new instance of GuildScheduledEventCreate.\nfunc (eh guildScheduledEventCreateEventHandler) New() interface{} {\n\treturn &GuildScheduledEventCreate{}\n}\n\n// Handle is the handler for GuildScheduledEventCreate events.\nfunc (eh guildScheduledEventCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildScheduledEventCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildScheduledEventDeleteEventHandler is an event handler for GuildScheduledEventDelete events.\ntype guildScheduledEventDeleteEventHandler func(*Session, *GuildScheduledEventDelete)\n\n// Type returns the event type for GuildScheduledEventDelete events.\nfunc (eh guildScheduledEventDeleteEventHandler) Type() string {\n\treturn guildScheduledEventDeleteEventType\n}\n\n// New returns a new instance of GuildScheduledEventDelete.\nfunc (eh guildScheduledEventDeleteEventHandler) New() interface{} {\n\treturn &GuildScheduledEventDelete{}\n}\n\n// Handle is the handler for GuildScheduledEventDelete events.\nfunc (eh guildScheduledEventDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildScheduledEventDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildScheduledEventUpdateEventHandler is an event handler for GuildScheduledEventUpdate events.\ntype guildScheduledEventUpdateEventHandler func(*Session, *GuildScheduledEventUpdate)\n\n// Type returns the event type for GuildScheduledEventUpdate events.\nfunc (eh guildScheduledEventUpdateEventHandler) Type() string {\n\treturn guildScheduledEventUpdateEventType\n}\n\n// New returns a new instance of GuildScheduledEventUpdate.\nfunc (eh guildScheduledEventUpdateEventHandler) New() interface{} {\n\treturn &GuildScheduledEventUpdate{}\n}\n\n// Handle is the handler for GuildScheduledEventUpdate events.\nfunc (eh guildScheduledEventUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildScheduledEventUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildScheduledEventUserAddEventHandler is an event handler for GuildScheduledEventUserAdd events.\ntype guildScheduledEventUserAddEventHandler func(*Session, *GuildScheduledEventUserAdd)\n\n// Type returns the event type for GuildScheduledEventUserAdd events.\nfunc (eh guildScheduledEventUserAddEventHandler) Type() string {\n\treturn guildScheduledEventUserAddEventType\n}\n\n// New returns a new instance of GuildScheduledEventUserAdd.\nfunc (eh guildScheduledEventUserAddEventHandler) New() interface{} {\n\treturn &GuildScheduledEventUserAdd{}\n}\n\n// Handle is the handler for GuildScheduledEventUserAdd events.\nfunc (eh guildScheduledEventUserAddEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildScheduledEventUserAdd); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildScheduledEventUserRemoveEventHandler is an event handler for GuildScheduledEventUserRemove events.\ntype guildScheduledEventUserRemoveEventHandler func(*Session, *GuildScheduledEventUserRemove)\n\n// Type returns the event type for GuildScheduledEventUserRemove events.\nfunc (eh guildScheduledEventUserRemoveEventHandler) Type() string {\n\treturn guildScheduledEventUserRemoveEventType\n}\n\n// New returns a new instance of GuildScheduledEventUserRemove.\nfunc (eh guildScheduledEventUserRemoveEventHandler) New() interface{} {\n\treturn &GuildScheduledEventUserRemove{}\n}\n\n// Handle is the handler for GuildScheduledEventUserRemove events.\nfunc (eh guildScheduledEventUserRemoveEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildScheduledEventUserRemove); ok {\n\t\teh(s, t)\n\t}\n}\n\n// guildUpdateEventHandler is an event handler for GuildUpdate events.\ntype guildUpdateEventHandler func(*Session, *GuildUpdate)\n\n// Type returns the event type for GuildUpdate events.\nfunc (eh guildUpdateEventHandler) Type() string {\n\treturn guildUpdateEventType\n}\n\n// New returns a new instance of GuildUpdate.\nfunc (eh guildUpdateEventHandler) New() interface{} {\n\treturn &GuildUpdate{}\n}\n\n// Handle is the handler for GuildUpdate events.\nfunc (eh guildUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*GuildUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// integrationCreateEventHandler is an event handler for IntegrationCreate events.\ntype integrationCreateEventHandler func(*Session, *IntegrationCreate)\n\n// Type returns the event type for IntegrationCreate events.\nfunc (eh integrationCreateEventHandler) Type() string {\n\treturn integrationCreateEventType\n}\n\n// New returns a new instance of IntegrationCreate.\nfunc (eh integrationCreateEventHandler) New() interface{} {\n\treturn &IntegrationCreate{}\n}\n\n// Handle is the handler for IntegrationCreate events.\nfunc (eh integrationCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*IntegrationCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// integrationDeleteEventHandler is an event handler for IntegrationDelete events.\ntype integrationDeleteEventHandler func(*Session, *IntegrationDelete)\n\n// Type returns the event type for IntegrationDelete events.\nfunc (eh integrationDeleteEventHandler) Type() string {\n\treturn integrationDeleteEventType\n}\n\n// New returns a new instance of IntegrationDelete.\nfunc (eh integrationDeleteEventHandler) New() interface{} {\n\treturn &IntegrationDelete{}\n}\n\n// Handle is the handler for IntegrationDelete events.\nfunc (eh integrationDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*IntegrationDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// integrationUpdateEventHandler is an event handler for IntegrationUpdate events.\ntype integrationUpdateEventHandler func(*Session, *IntegrationUpdate)\n\n// Type returns the event type for IntegrationUpdate events.\nfunc (eh integrationUpdateEventHandler) Type() string {\n\treturn integrationUpdateEventType\n}\n\n// New returns a new instance of IntegrationUpdate.\nfunc (eh integrationUpdateEventHandler) New() interface{} {\n\treturn &IntegrationUpdate{}\n}\n\n// Handle is the handler for IntegrationUpdate events.\nfunc (eh integrationUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*IntegrationUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// interactionCreateEventHandler is an event handler for InteractionCreate events.\ntype interactionCreateEventHandler func(*Session, *InteractionCreate)\n\n// Type returns the event type for InteractionCreate events.\nfunc (eh interactionCreateEventHandler) Type() string {\n\treturn interactionCreateEventType\n}\n\n// New returns a new instance of InteractionCreate.\nfunc (eh interactionCreateEventHandler) New() interface{} {\n\treturn &InteractionCreate{}\n}\n\n// Handle is the handler for InteractionCreate events.\nfunc (eh interactionCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*InteractionCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// inviteCreateEventHandler is an event handler for InviteCreate events.\ntype inviteCreateEventHandler func(*Session, *InviteCreate)\n\n// Type returns the event type for InviteCreate events.\nfunc (eh inviteCreateEventHandler) Type() string {\n\treturn inviteCreateEventType\n}\n\n// New returns a new instance of InviteCreate.\nfunc (eh inviteCreateEventHandler) New() interface{} {\n\treturn &InviteCreate{}\n}\n\n// Handle is the handler for InviteCreate events.\nfunc (eh inviteCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*InviteCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// inviteDeleteEventHandler is an event handler for InviteDelete events.\ntype inviteDeleteEventHandler func(*Session, *InviteDelete)\n\n// Type returns the event type for InviteDelete events.\nfunc (eh inviteDeleteEventHandler) Type() string {\n\treturn inviteDeleteEventType\n}\n\n// New returns a new instance of InviteDelete.\nfunc (eh inviteDeleteEventHandler) New() interface{} {\n\treturn &InviteDelete{}\n}\n\n// Handle is the handler for InviteDelete events.\nfunc (eh inviteDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*InviteDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageCreateEventHandler is an event handler for MessageCreate events.\ntype messageCreateEventHandler func(*Session, *MessageCreate)\n\n// Type returns the event type for MessageCreate events.\nfunc (eh messageCreateEventHandler) Type() string {\n\treturn messageCreateEventType\n}\n\n// New returns a new instance of MessageCreate.\nfunc (eh messageCreateEventHandler) New() interface{} {\n\treturn &MessageCreate{}\n}\n\n// Handle is the handler for MessageCreate events.\nfunc (eh messageCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageDeleteEventHandler is an event handler for MessageDelete events.\ntype messageDeleteEventHandler func(*Session, *MessageDelete)\n\n// Type returns the event type for MessageDelete events.\nfunc (eh messageDeleteEventHandler) Type() string {\n\treturn messageDeleteEventType\n}\n\n// New returns a new instance of MessageDelete.\nfunc (eh messageDeleteEventHandler) New() interface{} {\n\treturn &MessageDelete{}\n}\n\n// Handle is the handler for MessageDelete events.\nfunc (eh messageDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageDeleteBulkEventHandler is an event handler for MessageDeleteBulk events.\ntype messageDeleteBulkEventHandler func(*Session, *MessageDeleteBulk)\n\n// Type returns the event type for MessageDeleteBulk events.\nfunc (eh messageDeleteBulkEventHandler) Type() string {\n\treturn messageDeleteBulkEventType\n}\n\n// New returns a new instance of MessageDeleteBulk.\nfunc (eh messageDeleteBulkEventHandler) New() interface{} {\n\treturn &MessageDeleteBulk{}\n}\n\n// Handle is the handler for MessageDeleteBulk events.\nfunc (eh messageDeleteBulkEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageDeleteBulk); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messagePollVoteAddEventHandler is an event handler for MessagePollVoteAdd events.\ntype messagePollVoteAddEventHandler func(*Session, *MessagePollVoteAdd)\n\n// Type returns the event type for MessagePollVoteAdd events.\nfunc (eh messagePollVoteAddEventHandler) Type() string {\n\treturn messagePollVoteAddEventType\n}\n\n// New returns a new instance of MessagePollVoteAdd.\nfunc (eh messagePollVoteAddEventHandler) New() interface{} {\n\treturn &MessagePollVoteAdd{}\n}\n\n// Handle is the handler for MessagePollVoteAdd events.\nfunc (eh messagePollVoteAddEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessagePollVoteAdd); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messagePollVoteRemoveEventHandler is an event handler for MessagePollVoteRemove events.\ntype messagePollVoteRemoveEventHandler func(*Session, *MessagePollVoteRemove)\n\n// Type returns the event type for MessagePollVoteRemove events.\nfunc (eh messagePollVoteRemoveEventHandler) Type() string {\n\treturn messagePollVoteRemoveEventType\n}\n\n// New returns a new instance of MessagePollVoteRemove.\nfunc (eh messagePollVoteRemoveEventHandler) New() interface{} {\n\treturn &MessagePollVoteRemove{}\n}\n\n// Handle is the handler for MessagePollVoteRemove events.\nfunc (eh messagePollVoteRemoveEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessagePollVoteRemove); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageReactionAddEventHandler is an event handler for MessageReactionAdd events.\ntype messageReactionAddEventHandler func(*Session, *MessageReactionAdd)\n\n// Type returns the event type for MessageReactionAdd events.\nfunc (eh messageReactionAddEventHandler) Type() string {\n\treturn messageReactionAddEventType\n}\n\n// New returns a new instance of MessageReactionAdd.\nfunc (eh messageReactionAddEventHandler) New() interface{} {\n\treturn &MessageReactionAdd{}\n}\n\n// Handle is the handler for MessageReactionAdd events.\nfunc (eh messageReactionAddEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageReactionAdd); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageReactionRemoveEventHandler is an event handler for MessageReactionRemove events.\ntype messageReactionRemoveEventHandler func(*Session, *MessageReactionRemove)\n\n// Type returns the event type for MessageReactionRemove events.\nfunc (eh messageReactionRemoveEventHandler) Type() string {\n\treturn messageReactionRemoveEventType\n}\n\n// New returns a new instance of MessageReactionRemove.\nfunc (eh messageReactionRemoveEventHandler) New() interface{} {\n\treturn &MessageReactionRemove{}\n}\n\n// Handle is the handler for MessageReactionRemove events.\nfunc (eh messageReactionRemoveEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageReactionRemove); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageReactionRemoveAllEventHandler is an event handler for MessageReactionRemoveAll events.\ntype messageReactionRemoveAllEventHandler func(*Session, *MessageReactionRemoveAll)\n\n// Type returns the event type for MessageReactionRemoveAll events.\nfunc (eh messageReactionRemoveAllEventHandler) Type() string {\n\treturn messageReactionRemoveAllEventType\n}\n\n// New returns a new instance of MessageReactionRemoveAll.\nfunc (eh messageReactionRemoveAllEventHandler) New() interface{} {\n\treturn &MessageReactionRemoveAll{}\n}\n\n// Handle is the handler for MessageReactionRemoveAll events.\nfunc (eh messageReactionRemoveAllEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageReactionRemoveAll); ok {\n\t\teh(s, t)\n\t}\n}\n\n// messageUpdateEventHandler is an event handler for MessageUpdate events.\ntype messageUpdateEventHandler func(*Session, *MessageUpdate)\n\n// Type returns the event type for MessageUpdate events.\nfunc (eh messageUpdateEventHandler) Type() string {\n\treturn messageUpdateEventType\n}\n\n// New returns a new instance of MessageUpdate.\nfunc (eh messageUpdateEventHandler) New() interface{} {\n\treturn &MessageUpdate{}\n}\n\n// Handle is the handler for MessageUpdate events.\nfunc (eh messageUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*MessageUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// presenceUpdateEventHandler is an event handler for PresenceUpdate events.\ntype presenceUpdateEventHandler func(*Session, *PresenceUpdate)\n\n// Type returns the event type for PresenceUpdate events.\nfunc (eh presenceUpdateEventHandler) Type() string {\n\treturn presenceUpdateEventType\n}\n\n// New returns a new instance of PresenceUpdate.\nfunc (eh presenceUpdateEventHandler) New() interface{} {\n\treturn &PresenceUpdate{}\n}\n\n// Handle is the handler for PresenceUpdate events.\nfunc (eh presenceUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*PresenceUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// presencesReplaceEventHandler is an event handler for PresencesReplace events.\ntype presencesReplaceEventHandler func(*Session, *PresencesReplace)\n\n// Type returns the event type for PresencesReplace events.\nfunc (eh presencesReplaceEventHandler) Type() string {\n\treturn presencesReplaceEventType\n}\n\n// New returns a new instance of PresencesReplace.\nfunc (eh presencesReplaceEventHandler) New() interface{} {\n\treturn &PresencesReplace{}\n}\n\n// Handle is the handler for PresencesReplace events.\nfunc (eh presencesReplaceEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*PresencesReplace); ok {\n\t\teh(s, t)\n\t}\n}\n\n// rateLimitEventHandler is an event handler for RateLimit events.\ntype rateLimitEventHandler func(*Session, *RateLimit)\n\n// Type returns the event type for RateLimit events.\nfunc (eh rateLimitEventHandler) Type() string {\n\treturn rateLimitEventType\n}\n\n// Handle is the handler for RateLimit events.\nfunc (eh rateLimitEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*RateLimit); ok {\n\t\teh(s, t)\n\t}\n}\n\n// readyEventHandler is an event handler for Ready events.\ntype readyEventHandler func(*Session, *Ready)\n\n// Type returns the event type for Ready events.\nfunc (eh readyEventHandler) Type() string {\n\treturn readyEventType\n}\n\n// New returns a new instance of Ready.\nfunc (eh readyEventHandler) New() interface{} {\n\treturn &Ready{}\n}\n\n// Handle is the handler for Ready events.\nfunc (eh readyEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*Ready); ok {\n\t\teh(s, t)\n\t}\n}\n\n// resumedEventHandler is an event handler for Resumed events.\ntype resumedEventHandler func(*Session, *Resumed)\n\n// Type returns the event type for Resumed events.\nfunc (eh resumedEventHandler) Type() string {\n\treturn resumedEventType\n}\n\n// New returns a new instance of Resumed.\nfunc (eh resumedEventHandler) New() interface{} {\n\treturn &Resumed{}\n}\n\n// Handle is the handler for Resumed events.\nfunc (eh resumedEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*Resumed); ok {\n\t\teh(s, t)\n\t}\n}\n\n// stageInstanceEventCreateEventHandler is an event handler for StageInstanceEventCreate events.\ntype stageInstanceEventCreateEventHandler func(*Session, *StageInstanceEventCreate)\n\n// Type returns the event type for StageInstanceEventCreate events.\nfunc (eh stageInstanceEventCreateEventHandler) Type() string {\n\treturn stageInstanceEventCreateEventType\n}\n\n// New returns a new instance of StageInstanceEventCreate.\nfunc (eh stageInstanceEventCreateEventHandler) New() interface{} {\n\treturn &StageInstanceEventCreate{}\n}\n\n// Handle is the handler for StageInstanceEventCreate events.\nfunc (eh stageInstanceEventCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*StageInstanceEventCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// stageInstanceEventDeleteEventHandler is an event handler for StageInstanceEventDelete events.\ntype stageInstanceEventDeleteEventHandler func(*Session, *StageInstanceEventDelete)\n\n// Type returns the event type for StageInstanceEventDelete events.\nfunc (eh stageInstanceEventDeleteEventHandler) Type() string {\n\treturn stageInstanceEventDeleteEventType\n}\n\n// New returns a new instance of StageInstanceEventDelete.\nfunc (eh stageInstanceEventDeleteEventHandler) New() interface{} {\n\treturn &StageInstanceEventDelete{}\n}\n\n// Handle is the handler for StageInstanceEventDelete events.\nfunc (eh stageInstanceEventDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*StageInstanceEventDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// stageInstanceEventUpdateEventHandler is an event handler for StageInstanceEventUpdate events.\ntype stageInstanceEventUpdateEventHandler func(*Session, *StageInstanceEventUpdate)\n\n// Type returns the event type for StageInstanceEventUpdate events.\nfunc (eh stageInstanceEventUpdateEventHandler) Type() string {\n\treturn stageInstanceEventUpdateEventType\n}\n\n// New returns a new instance of StageInstanceEventUpdate.\nfunc (eh stageInstanceEventUpdateEventHandler) New() interface{} {\n\treturn &StageInstanceEventUpdate{}\n}\n\n// Handle is the handler for StageInstanceEventUpdate events.\nfunc (eh stageInstanceEventUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*StageInstanceEventUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadCreateEventHandler is an event handler for ThreadCreate events.\ntype threadCreateEventHandler func(*Session, *ThreadCreate)\n\n// Type returns the event type for ThreadCreate events.\nfunc (eh threadCreateEventHandler) Type() string {\n\treturn threadCreateEventType\n}\n\n// New returns a new instance of ThreadCreate.\nfunc (eh threadCreateEventHandler) New() interface{} {\n\treturn &ThreadCreate{}\n}\n\n// Handle is the handler for ThreadCreate events.\nfunc (eh threadCreateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadCreate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadDeleteEventHandler is an event handler for ThreadDelete events.\ntype threadDeleteEventHandler func(*Session, *ThreadDelete)\n\n// Type returns the event type for ThreadDelete events.\nfunc (eh threadDeleteEventHandler) Type() string {\n\treturn threadDeleteEventType\n}\n\n// New returns a new instance of ThreadDelete.\nfunc (eh threadDeleteEventHandler) New() interface{} {\n\treturn &ThreadDelete{}\n}\n\n// Handle is the handler for ThreadDelete events.\nfunc (eh threadDeleteEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadDelete); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadListSyncEventHandler is an event handler for ThreadListSync events.\ntype threadListSyncEventHandler func(*Session, *ThreadListSync)\n\n// Type returns the event type for ThreadListSync events.\nfunc (eh threadListSyncEventHandler) Type() string {\n\treturn threadListSyncEventType\n}\n\n// New returns a new instance of ThreadListSync.\nfunc (eh threadListSyncEventHandler) New() interface{} {\n\treturn &ThreadListSync{}\n}\n\n// Handle is the handler for ThreadListSync events.\nfunc (eh threadListSyncEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadListSync); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadMemberUpdateEventHandler is an event handler for ThreadMemberUpdate events.\ntype threadMemberUpdateEventHandler func(*Session, *ThreadMemberUpdate)\n\n// Type returns the event type for ThreadMemberUpdate events.\nfunc (eh threadMemberUpdateEventHandler) Type() string {\n\treturn threadMemberUpdateEventType\n}\n\n// New returns a new instance of ThreadMemberUpdate.\nfunc (eh threadMemberUpdateEventHandler) New() interface{} {\n\treturn &ThreadMemberUpdate{}\n}\n\n// Handle is the handler for ThreadMemberUpdate events.\nfunc (eh threadMemberUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadMemberUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadMembersUpdateEventHandler is an event handler for ThreadMembersUpdate events.\ntype threadMembersUpdateEventHandler func(*Session, *ThreadMembersUpdate)\n\n// Type returns the event type for ThreadMembersUpdate events.\nfunc (eh threadMembersUpdateEventHandler) Type() string {\n\treturn threadMembersUpdateEventType\n}\n\n// New returns a new instance of ThreadMembersUpdate.\nfunc (eh threadMembersUpdateEventHandler) New() interface{} {\n\treturn &ThreadMembersUpdate{}\n}\n\n// Handle is the handler for ThreadMembersUpdate events.\nfunc (eh threadMembersUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadMembersUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// threadUpdateEventHandler is an event handler for ThreadUpdate events.\ntype threadUpdateEventHandler func(*Session, *ThreadUpdate)\n\n// Type returns the event type for ThreadUpdate events.\nfunc (eh threadUpdateEventHandler) Type() string {\n\treturn threadUpdateEventType\n}\n\n// New returns a new instance of ThreadUpdate.\nfunc (eh threadUpdateEventHandler) New() interface{} {\n\treturn &ThreadUpdate{}\n}\n\n// Handle is the handler for ThreadUpdate events.\nfunc (eh threadUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*ThreadUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// typingStartEventHandler is an event handler for TypingStart events.\ntype typingStartEventHandler func(*Session, *TypingStart)\n\n// Type returns the event type for TypingStart events.\nfunc (eh typingStartEventHandler) Type() string {\n\treturn typingStartEventType\n}\n\n// New returns a new instance of TypingStart.\nfunc (eh typingStartEventHandler) New() interface{} {\n\treturn &TypingStart{}\n}\n\n// Handle is the handler for TypingStart events.\nfunc (eh typingStartEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*TypingStart); ok {\n\t\teh(s, t)\n\t}\n}\n\n// userUpdateEventHandler is an event handler for UserUpdate events.\ntype userUpdateEventHandler func(*Session, *UserUpdate)\n\n// Type returns the event type for UserUpdate events.\nfunc (eh userUpdateEventHandler) Type() string {\n\treturn userUpdateEventType\n}\n\n// New returns a new instance of UserUpdate.\nfunc (eh userUpdateEventHandler) New() interface{} {\n\treturn &UserUpdate{}\n}\n\n// Handle is the handler for UserUpdate events.\nfunc (eh userUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*UserUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// voiceServerUpdateEventHandler is an event handler for VoiceServerUpdate events.\ntype voiceServerUpdateEventHandler func(*Session, *VoiceServerUpdate)\n\n// Type returns the event type for VoiceServerUpdate events.\nfunc (eh voiceServerUpdateEventHandler) Type() string {\n\treturn voiceServerUpdateEventType\n}\n\n// New returns a new instance of VoiceServerUpdate.\nfunc (eh voiceServerUpdateEventHandler) New() interface{} {\n\treturn &VoiceServerUpdate{}\n}\n\n// Handle is the handler for VoiceServerUpdate events.\nfunc (eh voiceServerUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*VoiceServerUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// voiceStateUpdateEventHandler is an event handler for VoiceStateUpdate events.\ntype voiceStateUpdateEventHandler func(*Session, *VoiceStateUpdate)\n\n// Type returns the event type for VoiceStateUpdate events.\nfunc (eh voiceStateUpdateEventHandler) Type() string {\n\treturn voiceStateUpdateEventType\n}\n\n// New returns a new instance of VoiceStateUpdate.\nfunc (eh voiceStateUpdateEventHandler) New() interface{} {\n\treturn &VoiceStateUpdate{}\n}\n\n// Handle is the handler for VoiceStateUpdate events.\nfunc (eh voiceStateUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*VoiceStateUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\n// webhooksUpdateEventHandler is an event handler for WebhooksUpdate events.\ntype webhooksUpdateEventHandler func(*Session, *WebhooksUpdate)\n\n// Type returns the event type for WebhooksUpdate events.\nfunc (eh webhooksUpdateEventHandler) Type() string {\n\treturn webhooksUpdateEventType\n}\n\n// New returns a new instance of WebhooksUpdate.\nfunc (eh webhooksUpdateEventHandler) New() interface{} {\n\treturn &WebhooksUpdate{}\n}\n\n// Handle is the handler for WebhooksUpdate events.\nfunc (eh webhooksUpdateEventHandler) Handle(s *Session, i interface{}) {\n\tif t, ok := i.(*WebhooksUpdate); ok {\n\t\teh(s, t)\n\t}\n}\n\nfunc handlerForInterface(handler interface{}) EventHandler {\n\tswitch v := handler.(type) {\n\tcase func(*Session, interface{}):\n\t\treturn interfaceEventHandler(v)\n\tcase func(*Session, *ApplicationCommandPermissionsUpdate):\n\t\treturn applicationCommandPermissionsUpdateEventHandler(v)\n\tcase func(*Session, *AutoModerationActionExecution):\n\t\treturn autoModerationActionExecutionEventHandler(v)\n\tcase func(*Session, *AutoModerationRuleCreate):\n\t\treturn autoModerationRuleCreateEventHandler(v)\n\tcase func(*Session, *AutoModerationRuleDelete):\n\t\treturn autoModerationRuleDeleteEventHandler(v)\n\tcase func(*Session, *AutoModerationRuleUpdate):\n\t\treturn autoModerationRuleUpdateEventHandler(v)\n\tcase func(*Session, *ChannelCreate):\n\t\treturn channelCreateEventHandler(v)\n\tcase func(*Session, *ChannelDelete):\n\t\treturn channelDeleteEventHandler(v)\n\tcase func(*Session, *ChannelPinsUpdate):\n\t\treturn channelPinsUpdateEventHandler(v)\n\tcase func(*Session, *ChannelUpdate):\n\t\treturn channelUpdateEventHandler(v)\n\tcase func(*Session, *Connect):\n\t\treturn connectEventHandler(v)\n\tcase func(*Session, *Disconnect):\n\t\treturn disconnectEventHandler(v)\n\tcase func(*Session, *EntitlementCreate):\n\t\treturn entitlementCreateEventHandler(v)\n\tcase func(*Session, *EntitlementDelete):\n\t\treturn entitlementDeleteEventHandler(v)\n\tcase func(*Session, *EntitlementUpdate):\n\t\treturn entitlementUpdateEventHandler(v)\n\tcase func(*Session, *Event):\n\t\treturn eventEventHandler(v)\n\tcase func(*Session, *GuildAuditLogEntryCreate):\n\t\treturn guildAuditLogEntryCreateEventHandler(v)\n\tcase func(*Session, *GuildBanAdd):\n\t\treturn guildBanAddEventHandler(v)\n\tcase func(*Session, *GuildBanRemove):\n\t\treturn guildBanRemoveEventHandler(v)\n\tcase func(*Session, *GuildCreate):\n\t\treturn guildCreateEventHandler(v)\n\tcase func(*Session, *GuildDelete):\n\t\treturn guildDeleteEventHandler(v)\n\tcase func(*Session, *GuildEmojisUpdate):\n\t\treturn guildEmojisUpdateEventHandler(v)\n\tcase func(*Session, *GuildIntegrationsUpdate):\n\t\treturn guildIntegrationsUpdateEventHandler(v)\n\tcase func(*Session, *GuildMemberAdd):\n\t\treturn guildMemberAddEventHandler(v)\n\tcase func(*Session, *GuildMemberRemove):\n\t\treturn guildMemberRemoveEventHandler(v)\n\tcase func(*Session, *GuildMemberUpdate):\n\t\treturn guildMemberUpdateEventHandler(v)\n\tcase func(*Session, *GuildMembersChunk):\n\t\treturn guildMembersChunkEventHandler(v)\n\tcase func(*Session, *GuildRoleCreate):\n\t\treturn guildRoleCreateEventHandler(v)\n\tcase func(*Session, *GuildRoleDelete):\n\t\treturn guildRoleDeleteEventHandler(v)\n\tcase func(*Session, *GuildRoleUpdate):\n\t\treturn guildRoleUpdateEventHandler(v)\n\tcase func(*Session, *GuildScheduledEventCreate):\n\t\treturn guildScheduledEventCreateEventHandler(v)\n\tcase func(*Session, *GuildScheduledEventDelete):\n\t\treturn guildScheduledEventDeleteEventHandler(v)\n\tcase func(*Session, *GuildScheduledEventUpdate):\n\t\treturn guildScheduledEventUpdateEventHandler(v)\n\tcase func(*Session, *GuildScheduledEventUserAdd):\n\t\treturn guildScheduledEventUserAddEventHandler(v)\n\tcase func(*Session, *GuildScheduledEventUserRemove):\n\t\treturn guildScheduledEventUserRemoveEventHandler(v)\n\tcase func(*Session, *GuildUpdate):\n\t\treturn guildUpdateEventHandler(v)\n\tcase func(*Session, *IntegrationCreate):\n\t\treturn integrationCreateEventHandler(v)\n\tcase func(*Session, *IntegrationDelete):\n\t\treturn integrationDeleteEventHandler(v)\n\tcase func(*Session, *IntegrationUpdate):\n\t\treturn integrationUpdateEventHandler(v)\n\tcase func(*Session, *InteractionCreate):\n\t\treturn interactionCreateEventHandler(v)\n\tcase func(*Session, *InviteCreate):\n\t\treturn inviteCreateEventHandler(v)\n\tcase func(*Session, *InviteDelete):\n\t\treturn inviteDeleteEventHandler(v)\n\tcase func(*Session, *MessageCreate):\n\t\treturn messageCreateEventHandler(v)\n\tcase func(*Session, *MessageDelete):\n\t\treturn messageDeleteEventHandler(v)\n\tcase func(*Session, *MessageDeleteBulk):\n\t\treturn messageDeleteBulkEventHandler(v)\n\tcase func(*Session, *MessagePollVoteAdd):\n\t\treturn messagePollVoteAddEventHandler(v)\n\tcase func(*Session, *MessagePollVoteRemove):\n\t\treturn messagePollVoteRemoveEventHandler(v)\n\tcase func(*Session, *MessageReactionAdd):\n\t\treturn messageReactionAddEventHandler(v)\n\tcase func(*Session, *MessageReactionRemove):\n\t\treturn messageReactionRemoveEventHandler(v)\n\tcase func(*Session, *MessageReactionRemoveAll):\n\t\treturn messageReactionRemoveAllEventHandler(v)\n\tcase func(*Session, *MessageUpdate):\n\t\treturn messageUpdateEventHandler(v)\n\tcase func(*Session, *PresenceUpdate):\n\t\treturn presenceUpdateEventHandler(v)\n\tcase func(*Session, *PresencesReplace):\n\t\treturn presencesReplaceEventHandler(v)\n\tcase func(*Session, *RateLimit):\n\t\treturn rateLimitEventHandler(v)\n\tcase func(*Session, *Ready):\n\t\treturn readyEventHandler(v)\n\tcase func(*Session, *Resumed):\n\t\treturn resumedEventHandler(v)\n\tcase func(*Session, *StageInstanceEventCreate):\n\t\treturn stageInstanceEventCreateEventHandler(v)\n\tcase func(*Session, *StageInstanceEventDelete):\n\t\treturn stageInstanceEventDeleteEventHandler(v)\n\tcase func(*Session, *StageInstanceEventUpdate):\n\t\treturn stageInstanceEventUpdateEventHandler(v)\n\tcase func(*Session, *ThreadCreate):\n\t\treturn threadCreateEventHandler(v)\n\tcase func(*Session, *ThreadDelete):\n\t\treturn threadDeleteEventHandler(v)\n\tcase func(*Session, *ThreadListSync):\n\t\treturn threadListSyncEventHandler(v)\n\tcase func(*Session, *ThreadMemberUpdate):\n\t\treturn threadMemberUpdateEventHandler(v)\n\tcase func(*Session, *ThreadMembersUpdate):\n\t\treturn threadMembersUpdateEventHandler(v)\n\tcase func(*Session, *ThreadUpdate):\n\t\treturn threadUpdateEventHandler(v)\n\tcase func(*Session, *TypingStart):\n\t\treturn typingStartEventHandler(v)\n\tcase func(*Session, *UserUpdate):\n\t\treturn userUpdateEventHandler(v)\n\tcase func(*Session, *VoiceServerUpdate):\n\t\treturn voiceServerUpdateEventHandler(v)\n\tcase func(*Session, *VoiceStateUpdate):\n\t\treturn voiceStateUpdateEventHandler(v)\n\tcase func(*Session, *WebhooksUpdate):\n\t\treturn webhooksUpdateEventHandler(v)\n\t}\n\n\treturn nil\n}\n\nfunc init() {\n\tregisterInterfaceProvider(applicationCommandPermissionsUpdateEventHandler(nil))\n\tregisterInterfaceProvider(autoModerationActionExecutionEventHandler(nil))\n\tregisterInterfaceProvider(autoModerationRuleCreateEventHandler(nil))\n\tregisterInterfaceProvider(autoModerationRuleDeleteEventHandler(nil))\n\tregisterInterfaceProvider(autoModerationRuleUpdateEventHandler(nil))\n\tregisterInterfaceProvider(channelCreateEventHandler(nil))\n\tregisterInterfaceProvider(channelDeleteEventHandler(nil))\n\tregisterInterfaceProvider(channelPinsUpdateEventHandler(nil))\n\tregisterInterfaceProvider(channelUpdateEventHandler(nil))\n\tregisterInterfaceProvider(entitlementCreateEventHandler(nil))\n\tregisterInterfaceProvider(entitlementDeleteEventHandler(nil))\n\tregisterInterfaceProvider(entitlementUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildAuditLogEntryCreateEventHandler(nil))\n\tregisterInterfaceProvider(guildBanAddEventHandler(nil))\n\tregisterInterfaceProvider(guildBanRemoveEventHandler(nil))\n\tregisterInterfaceProvider(guildCreateEventHandler(nil))\n\tregisterInterfaceProvider(guildDeleteEventHandler(nil))\n\tregisterInterfaceProvider(guildEmojisUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildIntegrationsUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildMemberAddEventHandler(nil))\n\tregisterInterfaceProvider(guildMemberRemoveEventHandler(nil))\n\tregisterInterfaceProvider(guildMemberUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildMembersChunkEventHandler(nil))\n\tregisterInterfaceProvider(guildRoleCreateEventHandler(nil))\n\tregisterInterfaceProvider(guildRoleDeleteEventHandler(nil))\n\tregisterInterfaceProvider(guildRoleUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildScheduledEventCreateEventHandler(nil))\n\tregisterInterfaceProvider(guildScheduledEventDeleteEventHandler(nil))\n\tregisterInterfaceProvider(guildScheduledEventUpdateEventHandler(nil))\n\tregisterInterfaceProvider(guildScheduledEventUserAddEventHandler(nil))\n\tregisterInterfaceProvider(guildScheduledEventUserRemoveEventHandler(nil))\n\tregisterInterfaceProvider(guildUpdateEventHandler(nil))\n\tregisterInterfaceProvider(integrationCreateEventHandler(nil))\n\tregisterInterfaceProvider(integrationDeleteEventHandler(nil))\n\tregisterInterfaceProvider(integrationUpdateEventHandler(nil))\n\tregisterInterfaceProvider(interactionCreateEventHandler(nil))\n\tregisterInterfaceProvider(inviteCreateEventHandler(nil))\n\tregisterInterfaceProvider(inviteDeleteEventHandler(nil))\n\tregisterInterfaceProvider(messageCreateEventHandler(nil))\n\tregisterInterfaceProvider(messageDeleteEventHandler(nil))\n\tregisterInterfaceProvider(messageDeleteBulkEventHandler(nil))\n\tregisterInterfaceProvider(messagePollVoteAddEventHandler(nil))\n\tregisterInterfaceProvider(messagePollVoteRemoveEventHandler(nil))\n\tregisterInterfaceProvider(messageReactionAddEventHandler(nil))\n\tregisterInterfaceProvider(messageReactionRemoveEventHandler(nil))\n\tregisterInterfaceProvider(messageReactionRemoveAllEventHandler(nil))\n\tregisterInterfaceProvider(messageUpdateEventHandler(nil))\n\tregisterInterfaceProvider(presenceUpdateEventHandler(nil))\n\tregisterInterfaceProvider(presencesReplaceEventHandler(nil))\n\tregisterInterfaceProvider(readyEventHandler(nil))\n\tregisterInterfaceProvider(resumedEventHandler(nil))\n\tregisterInterfaceProvider(stageInstanceEventCreateEventHandler(nil))\n\tregisterInterfaceProvider(stageInstanceEventDeleteEventHandler(nil))\n\tregisterInterfaceProvider(stageInstanceEventUpdateEventHandler(nil))\n\tregisterInterfaceProvider(threadCreateEventHandler(nil))\n\tregisterInterfaceProvider(threadDeleteEventHandler(nil))\n\tregisterInterfaceProvider(threadListSyncEventHandler(nil))\n\tregisterInterfaceProvider(threadMemberUpdateEventHandler(nil))\n\tregisterInterfaceProvider(threadMembersUpdateEventHandler(nil))\n\tregisterInterfaceProvider(threadUpdateEventHandler(nil))\n\tregisterInterfaceProvider(typingStartEventHandler(nil))\n\tregisterInterfaceProvider(userUpdateEventHandler(nil))\n\tregisterInterfaceProvider(voiceServerUpdateEventHandler(nil))\n\tregisterInterfaceProvider(voiceStateUpdateEventHandler(nil))\n\tregisterInterfaceProvider(webhooksUpdateEventHandler(nil))\n}\n"
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 13.5478515625,
          "content": "package discordgo\n\nimport (\n\t\"encoding/json\"\n)\n\n// This file contains all the possible structs that can be\n// handled by AddHandler/EventHandler.\n// DO NOT ADD ANYTHING BUT EVENT HANDLER STRUCTS TO THIS FILE.\n//go:generate go run tools/cmd/eventhandlers/main.go\n\n// Connect is the data for a Connect event.\n// This is a synthetic event and is not dispatched by Discord.\ntype Connect struct{}\n\n// Disconnect is the data for a Disconnect event.\n// This is a synthetic event and is not dispatched by Discord.\ntype Disconnect struct{}\n\n// RateLimit is the data for a RateLimit event.\n// This is a synthetic event and is not dispatched by Discord.\ntype RateLimit struct {\n\t*TooManyRequests\n\tURL string\n}\n\n// Event provides a basic initial struct for all websocket events.\ntype Event struct {\n\tOperation int             `json:\"op\"`\n\tSequence  int64           `json:\"s\"`\n\tType      string          `json:\"t\"`\n\tRawData   json.RawMessage `json:\"d\"`\n\t// Struct contains one of the other types in this file.\n\tStruct interface{} `json:\"-\"`\n}\n\n// A Ready stores all data for the websocket READY event.\ntype Ready struct {\n\tVersion         int          `json:\"v\"`\n\tSessionID       string       `json:\"session_id\"`\n\tUser            *User        `json:\"user\"`\n\tShard           *[2]int      `json:\"shard\"`\n\tApplication     *Application `json:\"application\"`\n\tGuilds          []*Guild     `json:\"guilds\"`\n\tPrivateChannels []*Channel   `json:\"private_channels\"`\n}\n\n// ChannelCreate is the data for a ChannelCreate event.\ntype ChannelCreate struct {\n\t*Channel\n}\n\n// ChannelUpdate is the data for a ChannelUpdate event.\ntype ChannelUpdate struct {\n\t*Channel\n\tBeforeUpdate *Channel `json:\"-\"`\n}\n\n// ChannelDelete is the data for a ChannelDelete event.\ntype ChannelDelete struct {\n\t*Channel\n}\n\n// ChannelPinsUpdate stores data for a ChannelPinsUpdate event.\ntype ChannelPinsUpdate struct {\n\tLastPinTimestamp string `json:\"last_pin_timestamp\"`\n\tChannelID        string `json:\"channel_id\"`\n\tGuildID          string `json:\"guild_id,omitempty\"`\n}\n\n// ThreadCreate is the data for a ThreadCreate event.\ntype ThreadCreate struct {\n\t*Channel\n\tNewlyCreated bool `json:\"newly_created\"`\n}\n\n// ThreadUpdate is the data for a ThreadUpdate event.\ntype ThreadUpdate struct {\n\t*Channel\n\tBeforeUpdate *Channel `json:\"-\"`\n}\n\n// ThreadDelete is the data for a ThreadDelete event.\ntype ThreadDelete struct {\n\t*Channel\n}\n\n// ThreadListSync is the data for a ThreadListSync event.\ntype ThreadListSync struct {\n\t// The id of the guild\n\tGuildID string `json:\"guild_id\"`\n\t// The parent channel ids whose threads are being synced.\n\t// If omitted, then threads were synced for the entire guild.\n\t// This array may contain channel_ids that have no active threads as well, so you know to clear that data.\n\tChannelIDs []string `json:\"channel_ids\"`\n\t// All active threads in the given channels that the current user can access\n\tThreads []*Channel `json:\"threads\"`\n\t// All thread member objects from the synced threads for the current user,\n\t// indicating which threads the current user has been added to\n\tMembers []*ThreadMember `json:\"members\"`\n}\n\n// ThreadMemberUpdate is the data for a ThreadMemberUpdate event.\ntype ThreadMemberUpdate struct {\n\t*ThreadMember\n\tGuildID string `json:\"guild_id\"`\n}\n\n// ThreadMembersUpdate is the data for a ThreadMembersUpdate event.\ntype ThreadMembersUpdate struct {\n\tID             string              `json:\"id\"`\n\tGuildID        string              `json:\"guild_id\"`\n\tMemberCount    int                 `json:\"member_count\"`\n\tAddedMembers   []AddedThreadMember `json:\"added_members\"`\n\tRemovedMembers []string            `json:\"removed_member_ids\"`\n}\n\n// GuildCreate is the data for a GuildCreate event.\ntype GuildCreate struct {\n\t*Guild\n}\n\n// GuildUpdate is the data for a GuildUpdate event.\ntype GuildUpdate struct {\n\t*Guild\n}\n\n// GuildDelete is the data for a GuildDelete event.\ntype GuildDelete struct {\n\t*Guild\n\tBeforeDelete *Guild `json:\"-\"`\n}\n\n// GuildBanAdd is the data for a GuildBanAdd event.\ntype GuildBanAdd struct {\n\tUser    *User  `json:\"user\"`\n\tGuildID string `json:\"guild_id\"`\n}\n\n// GuildBanRemove is the data for a GuildBanRemove event.\ntype GuildBanRemove struct {\n\tUser    *User  `json:\"user\"`\n\tGuildID string `json:\"guild_id\"`\n}\n\n// GuildMemberAdd is the data for a GuildMemberAdd event.\ntype GuildMemberAdd struct {\n\t*Member\n}\n\n// GuildMemberUpdate is the data for a GuildMemberUpdate event.\ntype GuildMemberUpdate struct {\n\t*Member\n\tBeforeUpdate *Member `json:\"-\"`\n}\n\n// GuildMemberRemove is the data for a GuildMemberRemove event.\ntype GuildMemberRemove struct {\n\t*Member\n}\n\n// GuildRoleCreate is the data for a GuildRoleCreate event.\ntype GuildRoleCreate struct {\n\t*GuildRole\n}\n\n// GuildRoleUpdate is the data for a GuildRoleUpdate event.\ntype GuildRoleUpdate struct {\n\t*GuildRole\n}\n\n// A GuildRoleDelete is the data for a GuildRoleDelete event.\ntype GuildRoleDelete struct {\n\tRoleID  string `json:\"role_id\"`\n\tGuildID string `json:\"guild_id\"`\n}\n\n// A GuildEmojisUpdate is the data for a guild emoji update event.\ntype GuildEmojisUpdate struct {\n\tGuildID string   `json:\"guild_id\"`\n\tEmojis  []*Emoji `json:\"emojis\"`\n}\n\n// A GuildMembersChunk is the data for a GuildMembersChunk event.\ntype GuildMembersChunk struct {\n\tGuildID    string      `json:\"guild_id\"`\n\tMembers    []*Member   `json:\"members\"`\n\tChunkIndex int         `json:\"chunk_index\"`\n\tChunkCount int         `json:\"chunk_count\"`\n\tNotFound   []string    `json:\"not_found,omitempty\"`\n\tPresences  []*Presence `json:\"presences,omitempty\"`\n\tNonce      string      `json:\"nonce,omitempty\"`\n}\n\n// GuildIntegrationsUpdate is the data for a GuildIntegrationsUpdate event.\ntype GuildIntegrationsUpdate struct {\n\tGuildID string `json:\"guild_id\"`\n}\n\n// StageInstanceEventCreate is the data for a StageInstanceEventCreate event.\ntype StageInstanceEventCreate struct {\n\t*StageInstance\n}\n\n// StageInstanceEventUpdate is the data for a StageInstanceEventUpdate event.\ntype StageInstanceEventUpdate struct {\n\t*StageInstance\n}\n\n// StageInstanceEventDelete is the data for a StageInstanceEventDelete event.\ntype StageInstanceEventDelete struct {\n\t*StageInstance\n}\n\n// GuildScheduledEventCreate is the data for a GuildScheduledEventCreate event.\ntype GuildScheduledEventCreate struct {\n\t*GuildScheduledEvent\n}\n\n// GuildScheduledEventUpdate is the data for a GuildScheduledEventUpdate event.\ntype GuildScheduledEventUpdate struct {\n\t*GuildScheduledEvent\n}\n\n// GuildScheduledEventDelete is the data for a GuildScheduledEventDelete event.\ntype GuildScheduledEventDelete struct {\n\t*GuildScheduledEvent\n}\n\n// GuildScheduledEventUserAdd is the data for a GuildScheduledEventUserAdd event.\ntype GuildScheduledEventUserAdd struct {\n\tGuildScheduledEventID string `json:\"guild_scheduled_event_id\"`\n\tUserID                string `json:\"user_id\"`\n\tGuildID               string `json:\"guild_id\"`\n}\n\n// GuildScheduledEventUserRemove is the data for a GuildScheduledEventUserRemove event.\ntype GuildScheduledEventUserRemove struct {\n\tGuildScheduledEventID string `json:\"guild_scheduled_event_id\"`\n\tUserID                string `json:\"user_id\"`\n\tGuildID               string `json:\"guild_id\"`\n}\n\n// IntegrationCreate is the data for a IntegrationCreate event.\ntype IntegrationCreate struct {\n\t*Integration\n\tGuildID string `json:\"guild_id\"`\n}\n\n// IntegrationUpdate is the data for a IntegrationUpdate event.\ntype IntegrationUpdate struct {\n\t*Integration\n\tGuildID string `json:\"guild_id\"`\n}\n\n// IntegrationDelete is the data for a IntegrationDelete event.\ntype IntegrationDelete struct {\n\tID            string `json:\"id\"`\n\tGuildID       string `json:\"guild_id\"`\n\tApplicationID string `json:\"application_id,omitempty\"`\n}\n\n// MessageCreate is the data for a MessageCreate event.\ntype MessageCreate struct {\n\t*Message\n}\n\n// UnmarshalJSON is a helper function to unmarshal MessageCreate object.\nfunc (m *MessageCreate) UnmarshalJSON(b []byte) error {\n\treturn json.Unmarshal(b, &m.Message)\n}\n\n// MessageUpdate is the data for a MessageUpdate event.\ntype MessageUpdate struct {\n\t*Message\n\t// BeforeUpdate will be nil if the Message was not previously cached in the state cache.\n\tBeforeUpdate *Message `json:\"-\"`\n}\n\n// UnmarshalJSON is a helper function to unmarshal MessageUpdate object.\nfunc (m *MessageUpdate) UnmarshalJSON(b []byte) error {\n\treturn json.Unmarshal(b, &m.Message)\n}\n\n// MessageDelete is the data for a MessageDelete event.\ntype MessageDelete struct {\n\t*Message\n\tBeforeDelete *Message `json:\"-\"`\n}\n\n// UnmarshalJSON is a helper function to unmarshal MessageDelete object.\nfunc (m *MessageDelete) UnmarshalJSON(b []byte) error {\n\treturn json.Unmarshal(b, &m.Message)\n}\n\n// MessageReactionAdd is the data for a MessageReactionAdd event.\ntype MessageReactionAdd struct {\n\t*MessageReaction\n\tMember *Member `json:\"member,omitempty\"`\n}\n\n// MessageReactionRemove is the data for a MessageReactionRemove event.\ntype MessageReactionRemove struct {\n\t*MessageReaction\n}\n\n// MessageReactionRemoveAll is the data for a MessageReactionRemoveAll event.\ntype MessageReactionRemoveAll struct {\n\t*MessageReaction\n}\n\n// PresencesReplace is the data for a PresencesReplace event.\ntype PresencesReplace []*Presence\n\n// PresenceUpdate is the data for a PresenceUpdate event.\ntype PresenceUpdate struct {\n\tPresence\n\tGuildID string `json:\"guild_id\"`\n}\n\n// Resumed is the data for a Resumed event.\ntype Resumed struct {\n\tTrace []string `json:\"_trace\"`\n}\n\n// TypingStart is the data for a TypingStart event.\ntype TypingStart struct {\n\tUserID    string `json:\"user_id\"`\n\tChannelID string `json:\"channel_id\"`\n\tGuildID   string `json:\"guild_id,omitempty\"`\n\tTimestamp int    `json:\"timestamp\"`\n}\n\n// UserUpdate is the data for a UserUpdate event.\ntype UserUpdate struct {\n\t*User\n}\n\n// VoiceServerUpdate is the data for a VoiceServerUpdate event.\ntype VoiceServerUpdate struct {\n\tToken    string `json:\"token\"`\n\tGuildID  string `json:\"guild_id\"`\n\tEndpoint string `json:\"endpoint\"`\n}\n\n// VoiceStateUpdate is the data for a VoiceStateUpdate event.\ntype VoiceStateUpdate struct {\n\t*VoiceState\n\t// BeforeUpdate will be nil if the VoiceState was not previously cached in the state cache.\n\tBeforeUpdate *VoiceState `json:\"-\"`\n}\n\n// MessageDeleteBulk is the data for a MessageDeleteBulk event\ntype MessageDeleteBulk struct {\n\tMessages  []string `json:\"ids\"`\n\tChannelID string   `json:\"channel_id\"`\n\tGuildID   string   `json:\"guild_id\"`\n}\n\n// WebhooksUpdate is the data for a WebhooksUpdate event\ntype WebhooksUpdate struct {\n\tGuildID   string `json:\"guild_id\"`\n\tChannelID string `json:\"channel_id\"`\n}\n\n// InteractionCreate is the data for a InteractionCreate event\ntype InteractionCreate struct {\n\t*Interaction\n}\n\n// UnmarshalJSON is a helper function to unmarshal Interaction object.\nfunc (i *InteractionCreate) UnmarshalJSON(b []byte) error {\n\treturn json.Unmarshal(b, &i.Interaction)\n}\n\n// InviteCreate is the data for a InviteCreate event\ntype InviteCreate struct {\n\t*Invite\n\tChannelID string `json:\"channel_id\"`\n\tGuildID   string `json:\"guild_id\"`\n}\n\n// InviteDelete is the data for a InviteDelete event\ntype InviteDelete struct {\n\tChannelID string `json:\"channel_id\"`\n\tGuildID   string `json:\"guild_id\"`\n\tCode      string `json:\"code\"`\n}\n\n// ApplicationCommandPermissionsUpdate is the data for an ApplicationCommandPermissionsUpdate event\ntype ApplicationCommandPermissionsUpdate struct {\n\t*GuildApplicationCommandPermissions\n}\n\n// AutoModerationRuleCreate is the data for an AutoModerationRuleCreate event.\ntype AutoModerationRuleCreate struct {\n\t*AutoModerationRule\n}\n\n// AutoModerationRuleUpdate is the data for an AutoModerationRuleUpdate event.\ntype AutoModerationRuleUpdate struct {\n\t*AutoModerationRule\n}\n\n// AutoModerationRuleDelete is the data for an AutoModerationRuleDelete event.\ntype AutoModerationRuleDelete struct {\n\t*AutoModerationRule\n}\n\n// AutoModerationActionExecution is the data for an AutoModerationActionExecution event.\ntype AutoModerationActionExecution struct {\n\tGuildID              string                        `json:\"guild_id\"`\n\tAction               AutoModerationAction          `json:\"action\"`\n\tRuleID               string                        `json:\"rule_id\"`\n\tRuleTriggerType      AutoModerationRuleTriggerType `json:\"rule_trigger_type\"`\n\tUserID               string                        `json:\"user_id\"`\n\tChannelID            string                        `json:\"channel_id\"`\n\tMessageID            string                        `json:\"message_id\"`\n\tAlertSystemMessageID string                        `json:\"alert_system_message_id\"`\n\tContent              string                        `json:\"content\"`\n\tMatchedKeyword       string                        `json:\"matched_keyword\"`\n\tMatchedContent       string                        `json:\"matched_content\"`\n}\n\n// GuildAuditLogEntryCreate is the data for a GuildAuditLogEntryCreate event.\ntype GuildAuditLogEntryCreate struct {\n\t*AuditLogEntry\n\tGuildID string `json:\"guild_id\"`\n}\n\n// MessagePollVoteAdd is the data for a MessagePollVoteAdd event.\ntype MessagePollVoteAdd struct {\n\tUserID    string `json:\"user_id\"`\n\tChannelID string `json:\"channel_id\"`\n\tMessageID string `json:\"message_id\"`\n\tGuildID   string `json:\"guild_id,omitempty\"`\n\tAnswerID  int    `json:\"answer_id\"`\n}\n\n// MessagePollVoteRemove is the data for a MessagePollVoteRemove event.\ntype MessagePollVoteRemove struct {\n\tUserID    string `json:\"user_id\"`\n\tChannelID string `json:\"channel_id\"`\n\tMessageID string `json:\"message_id\"`\n\tGuildID   string `json:\"guild_id,omitempty\"`\n\tAnswerID  int    `json:\"answer_id\"`\n}\n\n// EntitlementCreate is the data for an EntitlementCreate event.\ntype EntitlementCreate struct {\n\t*Entitlement\n}\n\n// EntitlementUpdate is the data for an EntitlementUpdate event.\ntype EntitlementUpdate struct {\n\t*Entitlement\n}\n\n// EntitlementDelete is the data for an EntitlementDelete event.\n// NOTE: Entitlements are not deleted when they expire.\ntype EntitlementDelete struct {\n\t*Entitlement\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1484375,
          "content": "module github.com/bwmarrin/discordgo\n\ngo 1.13\n\nrequire (\n\tgithub.com/gorilla/websocket v1.4.2\n\tgolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.9755859375,
          "content": "github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b h1:7mWr3k41Qtv8XlltBkDkl8LoP3mpSgBW8BUoxtEdbXg=\ngolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68 h1:nxC68pudNYkKU6jWhgrqdreuFiOQWj1Fs7T3VrH4Pjw=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n"
        },
        {
          "name": "interactions.go",
          "type": "blob",
          "size": 24.3662109375,
          "content": "package discordgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/ed25519\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// InteractionDeadline is the time allowed to respond to an interaction.\nconst InteractionDeadline = time.Second * 3\n\n// ApplicationCommandType represents the type of application command.\ntype ApplicationCommandType uint8\n\n// Application command types\nconst (\n\t// ChatApplicationCommand is default command type. They are slash commands (i.e. called directly from the chat).\n\tChatApplicationCommand ApplicationCommandType = 1\n\t// UserApplicationCommand adds command to user context menu.\n\tUserApplicationCommand ApplicationCommandType = 2\n\t// MessageApplicationCommand adds command to message context menu.\n\tMessageApplicationCommand ApplicationCommandType = 3\n)\n\n// ApplicationCommand represents an application's slash command.\ntype ApplicationCommand struct {\n\tID                string                 `json:\"id,omitempty\"`\n\tApplicationID     string                 `json:\"application_id,omitempty\"`\n\tGuildID           string                 `json:\"guild_id,omitempty\"`\n\tVersion           string                 `json:\"version,omitempty\"`\n\tType              ApplicationCommandType `json:\"type,omitempty\"`\n\tName              string                 `json:\"name\"`\n\tNameLocalizations *map[Locale]string     `json:\"name_localizations,omitempty\"`\n\n\t// NOTE: DefaultPermission will be soon deprecated. Use DefaultMemberPermissions and Contexts instead.\n\tDefaultPermission        *bool  `json:\"default_permission,omitempty\"`\n\tDefaultMemberPermissions *int64 `json:\"default_member_permissions,string,omitempty\"`\n\tNSFW                     *bool  `json:\"nsfw,omitempty\"`\n\n\t// Deprecated: use Contexts instead.\n\tDMPermission     *bool                         `json:\"dm_permission,omitempty\"`\n\tContexts         *[]InteractionContextType     `json:\"contexts,omitempty\"`\n\tIntegrationTypes *[]ApplicationIntegrationType `json:\"integration_types,omitempty\"`\n\n\t// NOTE: Chat commands only. Otherwise it mustn't be set.\n\n\tDescription              string                      `json:\"description,omitempty\"`\n\tDescriptionLocalizations *map[Locale]string          `json:\"description_localizations,omitempty\"`\n\tOptions                  []*ApplicationCommandOption `json:\"options\"`\n}\n\n// ApplicationCommandOptionType indicates the type of a slash command's option.\ntype ApplicationCommandOptionType uint8\n\n// Application command option types.\nconst (\n\tApplicationCommandOptionSubCommand      ApplicationCommandOptionType = 1\n\tApplicationCommandOptionSubCommandGroup ApplicationCommandOptionType = 2\n\tApplicationCommandOptionString          ApplicationCommandOptionType = 3\n\tApplicationCommandOptionInteger         ApplicationCommandOptionType = 4\n\tApplicationCommandOptionBoolean         ApplicationCommandOptionType = 5\n\tApplicationCommandOptionUser            ApplicationCommandOptionType = 6\n\tApplicationCommandOptionChannel         ApplicationCommandOptionType = 7\n\tApplicationCommandOptionRole            ApplicationCommandOptionType = 8\n\tApplicationCommandOptionMentionable     ApplicationCommandOptionType = 9\n\tApplicationCommandOptionNumber          ApplicationCommandOptionType = 10\n\tApplicationCommandOptionAttachment      ApplicationCommandOptionType = 11\n)\n\nfunc (t ApplicationCommandOptionType) String() string {\n\tswitch t {\n\tcase ApplicationCommandOptionSubCommand:\n\t\treturn \"SubCommand\"\n\tcase ApplicationCommandOptionSubCommandGroup:\n\t\treturn \"SubCommandGroup\"\n\tcase ApplicationCommandOptionString:\n\t\treturn \"String\"\n\tcase ApplicationCommandOptionInteger:\n\t\treturn \"Integer\"\n\tcase ApplicationCommandOptionBoolean:\n\t\treturn \"Boolean\"\n\tcase ApplicationCommandOptionUser:\n\t\treturn \"User\"\n\tcase ApplicationCommandOptionChannel:\n\t\treturn \"Channel\"\n\tcase ApplicationCommandOptionRole:\n\t\treturn \"Role\"\n\tcase ApplicationCommandOptionMentionable:\n\t\treturn \"Mentionable\"\n\tcase ApplicationCommandOptionNumber:\n\t\treturn \"Number\"\n\tcase ApplicationCommandOptionAttachment:\n\t\treturn \"Attachment\"\n\t}\n\treturn fmt.Sprintf(\"ApplicationCommandOptionType(%d)\", t)\n}\n\n// ApplicationCommandOption represents an option/subcommand/subcommands group.\ntype ApplicationCommandOption struct {\n\tType                     ApplicationCommandOptionType `json:\"type\"`\n\tName                     string                       `json:\"name\"`\n\tNameLocalizations        map[Locale]string            `json:\"name_localizations,omitempty\"`\n\tDescription              string                       `json:\"description,omitempty\"`\n\tDescriptionLocalizations map[Locale]string            `json:\"description_localizations,omitempty\"`\n\t// NOTE: This feature was on the API, but at some point developers decided to remove it.\n\t// So I commented it, until it will be officially on the docs.\n\t// Default     bool                              `json:\"default\"`\n\n\tChannelTypes []ChannelType               `json:\"channel_types\"`\n\tRequired     bool                        `json:\"required\"`\n\tOptions      []*ApplicationCommandOption `json:\"options\"`\n\n\t// NOTE: mutually exclusive with Choices.\n\tAutocomplete bool                              `json:\"autocomplete\"`\n\tChoices      []*ApplicationCommandOptionChoice `json:\"choices\"`\n\t// Minimal value of number/integer option.\n\tMinValue *float64 `json:\"min_value,omitempty\"`\n\t// Maximum value of number/integer option.\n\tMaxValue float64 `json:\"max_value,omitempty\"`\n\t// Minimum length of string option.\n\tMinLength *int `json:\"min_length,omitempty\"`\n\t// Maximum length of string option.\n\tMaxLength int `json:\"max_length,omitempty\"`\n}\n\n// ApplicationCommandOptionChoice represents a slash command option choice.\ntype ApplicationCommandOptionChoice struct {\n\tName              string            `json:\"name\"`\n\tNameLocalizations map[Locale]string `json:\"name_localizations,omitempty\"`\n\tValue             interface{}       `json:\"value\"`\n}\n\n// ApplicationCommandPermissions represents a single user or role permission for a command.\ntype ApplicationCommandPermissions struct {\n\tID         string                           `json:\"id\"`\n\tType       ApplicationCommandPermissionType `json:\"type\"`\n\tPermission bool                             `json:\"permission\"`\n}\n\n// GuildAllChannelsID is a helper function which returns guild_id-1.\n// It is used in ApplicationCommandPermissions to target all the channels within a guild.\nfunc GuildAllChannelsID(guild string) (id string, err error) {\n\tvar v uint64\n\tv, err = strconv.ParseUint(guild, 10, 64)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn strconv.FormatUint(v-1, 10), nil\n}\n\n// ApplicationCommandPermissionsList represents a list of ApplicationCommandPermissions, needed for serializing to JSON.\ntype ApplicationCommandPermissionsList struct {\n\tPermissions []*ApplicationCommandPermissions `json:\"permissions\"`\n}\n\n// GuildApplicationCommandPermissions represents all permissions for a single guild command.\ntype GuildApplicationCommandPermissions struct {\n\tID            string                           `json:\"id\"`\n\tApplicationID string                           `json:\"application_id\"`\n\tGuildID       string                           `json:\"guild_id\"`\n\tPermissions   []*ApplicationCommandPermissions `json:\"permissions\"`\n}\n\n// ApplicationCommandPermissionType indicates whether a permission is user or role based.\ntype ApplicationCommandPermissionType uint8\n\n// Application command permission types.\nconst (\n\tApplicationCommandPermissionTypeRole    ApplicationCommandPermissionType = 1\n\tApplicationCommandPermissionTypeUser    ApplicationCommandPermissionType = 2\n\tApplicationCommandPermissionTypeChannel ApplicationCommandPermissionType = 3\n)\n\n// InteractionType indicates the type of an interaction event.\ntype InteractionType uint8\n\n// Interaction types\nconst (\n\tInteractionPing                           InteractionType = 1\n\tInteractionApplicationCommand             InteractionType = 2\n\tInteractionMessageComponent               InteractionType = 3\n\tInteractionApplicationCommandAutocomplete InteractionType = 4\n\tInteractionModalSubmit                    InteractionType = 5\n)\n\nfunc (t InteractionType) String() string {\n\tswitch t {\n\tcase InteractionPing:\n\t\treturn \"Ping\"\n\tcase InteractionApplicationCommand:\n\t\treturn \"ApplicationCommand\"\n\tcase InteractionMessageComponent:\n\t\treturn \"MessageComponent\"\n\tcase InteractionModalSubmit:\n\t\treturn \"ModalSubmit\"\n\t}\n\treturn fmt.Sprintf(\"InteractionType(%d)\", t)\n}\n\n// InteractionContextType represents the context in which interaction can be used or was triggered from.\ntype InteractionContextType uint\n\nconst (\n\t// InteractionContextGuild indicates that interaction can be used within guilds.\n\tInteractionContextGuild InteractionContextType = 0\n\t// InteractionContextBotDM indicates that interaction can be used within DMs with the bot.\n\tInteractionContextBotDM InteractionContextType = 1\n\t// InteractionContextPrivateChannel indicates that interaction can be used within group DMs and DMs with other users.\n\tInteractionContextPrivateChannel InteractionContextType = 2\n)\n\n// Interaction represents data of an interaction.\ntype Interaction struct {\n\tID        string          `json:\"id\"`\n\tAppID     string          `json:\"application_id\"`\n\tType      InteractionType `json:\"type\"`\n\tData      InteractionData `json:\"data\"`\n\tGuildID   string          `json:\"guild_id\"`\n\tChannelID string          `json:\"channel_id\"`\n\n\t// The message on which interaction was used.\n\t// NOTE: this field is only filled when a button click triggered the interaction. Otherwise it will be nil.\n\tMessage *Message `json:\"message\"`\n\n\t// Bitwise set of permissions the app or bot has within the channel the interaction was sent from\n\tAppPermissions int64 `json:\"app_permissions,string\"`\n\n\t// The member who invoked this interaction.\n\t// NOTE: this field is only filled when the slash command was invoked in a guild;\n\t// if it was invoked in a DM, the `User` field will be filled instead.\n\t// Make sure to check for `nil` before using this field.\n\tMember *Member `json:\"member\"`\n\t// The user who invoked this interaction.\n\t// NOTE: this field is only filled when the slash command was invoked in a DM;\n\t// if it was invoked in a guild, the `Member` field will be filled instead.\n\t// Make sure to check for `nil` before using this field.\n\tUser *User `json:\"user\"`\n\n\t// The user's discord client locale.\n\tLocale Locale `json:\"locale\"`\n\t// The guild's locale. This defaults to EnglishUS\n\t// NOTE: this field is only filled when the interaction was invoked in a guild.\n\tGuildLocale *Locale `json:\"guild_locale\"`\n\n\tContext                      InteractionContextType                `json:\"context\"`\n\tAuthorizingIntegrationOwners map[ApplicationIntegrationType]string `json:\"authorizing_integration_owners\"`\n\n\tToken   string `json:\"token\"`\n\tVersion int    `json:\"version\"`\n\n\t// Any entitlements for the invoking user, representing access to premium SKUs.\n\t// NOTE: this field is only filled in monetized apps\n\tEntitlements []*Entitlement `json:\"entitlements\"`\n}\n\ntype interaction Interaction\n\ntype rawInteraction struct {\n\tinteraction\n\tData json.RawMessage `json:\"data\"`\n}\n\n// UnmarshalJSON is a method for unmarshalling JSON object to Interaction.\nfunc (i *Interaction) UnmarshalJSON(raw []byte) error {\n\tvar tmp rawInteraction\n\terr := json.Unmarshal(raw, &tmp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*i = Interaction(tmp.interaction)\n\n\tswitch tmp.Type {\n\tcase InteractionApplicationCommand, InteractionApplicationCommandAutocomplete:\n\t\tv := ApplicationCommandInteractionData{}\n\t\terr = json.Unmarshal(tmp.Data, &v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti.Data = v\n\tcase InteractionMessageComponent:\n\t\tv := MessageComponentInteractionData{}\n\t\terr = json.Unmarshal(tmp.Data, &v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti.Data = v\n\tcase InteractionModalSubmit:\n\t\tv := ModalSubmitInteractionData{}\n\t\terr = json.Unmarshal(tmp.Data, &v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti.Data = v\n\t}\n\treturn nil\n}\n\n// MessageComponentData is helper function to assert the inner InteractionData to MessageComponentInteractionData.\n// Make sure to check that the Type of the interaction is InteractionMessageComponent before calling.\nfunc (i Interaction) MessageComponentData() (data MessageComponentInteractionData) {\n\tif i.Type != InteractionMessageComponent {\n\t\tpanic(\"MessageComponentData called on interaction of type \" + i.Type.String())\n\t}\n\treturn i.Data.(MessageComponentInteractionData)\n}\n\n// ApplicationCommandData is helper function to assert the inner InteractionData to ApplicationCommandInteractionData.\n// Make sure to check that the Type of the interaction is InteractionApplicationCommand before calling.\nfunc (i Interaction) ApplicationCommandData() (data ApplicationCommandInteractionData) {\n\tif i.Type != InteractionApplicationCommand && i.Type != InteractionApplicationCommandAutocomplete {\n\t\tpanic(\"ApplicationCommandData called on interaction of type \" + i.Type.String())\n\t}\n\treturn i.Data.(ApplicationCommandInteractionData)\n}\n\n// ModalSubmitData is helper function to assert the inner InteractionData to ModalSubmitInteractionData.\n// Make sure to check that the Type of the interaction is InteractionModalSubmit before calling.\nfunc (i Interaction) ModalSubmitData() (data ModalSubmitInteractionData) {\n\tif i.Type != InteractionModalSubmit {\n\t\tpanic(\"ModalSubmitData called on interaction of type \" + i.Type.String())\n\t}\n\treturn i.Data.(ModalSubmitInteractionData)\n}\n\n// InteractionData is a common interface for all types of interaction data.\ntype InteractionData interface {\n\tType() InteractionType\n}\n\n// ApplicationCommandInteractionData contains the data of application command interaction.\ntype ApplicationCommandInteractionData struct {\n\tID          string                                     `json:\"id\"`\n\tName        string                                     `json:\"name\"`\n\tCommandType ApplicationCommandType                     `json:\"type\"`\n\tResolved    *ApplicationCommandInteractionDataResolved `json:\"resolved\"`\n\n\t// Slash command options\n\tOptions []*ApplicationCommandInteractionDataOption `json:\"options\"`\n\t// Target (user/message) id on which context menu command was called.\n\t// The details are stored in Resolved according to command type.\n\tTargetID string `json:\"target_id\"`\n}\n\n// GetOption finds and returns an application command option by its name.\nfunc (d ApplicationCommandInteractionData) GetOption(name string) (option *ApplicationCommandInteractionDataOption) {\n\tfor _, opt := range d.Options {\n\t\tif opt.Name == name {\n\t\t\toption = opt\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn\n}\n\n// ApplicationCommandInteractionDataResolved contains resolved data of command execution.\n// Partial Member objects are missing user, deaf and mute fields.\n// Partial Channel objects only have id, name, type and permissions fields.\ntype ApplicationCommandInteractionDataResolved struct {\n\tUsers       map[string]*User              `json:\"users\"`\n\tMembers     map[string]*Member            `json:\"members\"`\n\tRoles       map[string]*Role              `json:\"roles\"`\n\tChannels    map[string]*Channel           `json:\"channels\"`\n\tMessages    map[string]*Message           `json:\"messages\"`\n\tAttachments map[string]*MessageAttachment `json:\"attachments\"`\n}\n\n// Type returns the type of interaction data.\nfunc (ApplicationCommandInteractionData) Type() InteractionType {\n\treturn InteractionApplicationCommand\n}\n\n// MessageComponentInteractionData contains the data of message component interaction.\ntype MessageComponentInteractionData struct {\n\tCustomID      string                                  `json:\"custom_id\"`\n\tComponentType ComponentType                           `json:\"component_type\"`\n\tResolved      MessageComponentInteractionDataResolved `json:\"resolved\"`\n\n\t// NOTE: Only filled when ComponentType is SelectMenuComponent (3). Otherwise is nil.\n\tValues []string `json:\"values\"`\n}\n\n// MessageComponentInteractionDataResolved contains the resolved data of selected option.\ntype MessageComponentInteractionDataResolved struct {\n\tUsers    map[string]*User    `json:\"users\"`\n\tMembers  map[string]*Member  `json:\"members\"`\n\tRoles    map[string]*Role    `json:\"roles\"`\n\tChannels map[string]*Channel `json:\"channels\"`\n}\n\n// Type returns the type of interaction data.\nfunc (MessageComponentInteractionData) Type() InteractionType {\n\treturn InteractionMessageComponent\n}\n\n// ModalSubmitInteractionData contains the data of modal submit interaction.\ntype ModalSubmitInteractionData struct {\n\tCustomID   string             `json:\"custom_id\"`\n\tComponents []MessageComponent `json:\"-\"`\n}\n\n// Type returns the type of interaction data.\nfunc (ModalSubmitInteractionData) Type() InteractionType {\n\treturn InteractionModalSubmit\n}\n\n// UnmarshalJSON is a helper function to correctly unmarshal Components.\nfunc (d *ModalSubmitInteractionData) UnmarshalJSON(data []byte) error {\n\ttype modalSubmitInteractionData ModalSubmitInteractionData\n\tvar v struct {\n\t\tmodalSubmitInteractionData\n\t\tRawComponents []unmarshalableMessageComponent `json:\"components\"`\n\t}\n\terr := json.Unmarshal(data, &v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*d = ModalSubmitInteractionData(v.modalSubmitInteractionData)\n\td.Components = make([]MessageComponent, len(v.RawComponents))\n\tfor i, v := range v.RawComponents {\n\t\td.Components[i] = v.MessageComponent\n\t}\n\treturn err\n}\n\n// ApplicationCommandInteractionDataOption represents an option of a slash command.\ntype ApplicationCommandInteractionDataOption struct {\n\tName string                       `json:\"name\"`\n\tType ApplicationCommandOptionType `json:\"type\"`\n\t// NOTE: Contains the value specified by Type.\n\tValue   interface{}                                `json:\"value,omitempty\"`\n\tOptions []*ApplicationCommandInteractionDataOption `json:\"options,omitempty\"`\n\n\t// NOTE: autocomplete interaction only.\n\tFocused bool `json:\"focused,omitempty\"`\n}\n\n// GetOption finds and returns an application command option by its name.\nfunc (o ApplicationCommandInteractionDataOption) GetOption(name string) (option *ApplicationCommandInteractionDataOption) {\n\tfor _, opt := range o.Options {\n\t\tif opt.Name == name {\n\t\t\toption = opt\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn\n}\n\n// IntValue is a utility function for casting option value to integer\nfunc (o ApplicationCommandInteractionDataOption) IntValue() int64 {\n\tif o.Type != ApplicationCommandOptionInteger {\n\t\tpanic(\"IntValue called on data option of type \" + o.Type.String())\n\t}\n\treturn int64(o.Value.(float64))\n}\n\n// UintValue is a utility function for casting option value to unsigned integer\nfunc (o ApplicationCommandInteractionDataOption) UintValue() uint64 {\n\tif o.Type != ApplicationCommandOptionInteger {\n\t\tpanic(\"UintValue called on data option of type \" + o.Type.String())\n\t}\n\treturn uint64(o.Value.(float64))\n}\n\n// FloatValue is a utility function for casting option value to float\nfunc (o ApplicationCommandInteractionDataOption) FloatValue() float64 {\n\tif o.Type != ApplicationCommandOptionNumber {\n\t\tpanic(\"FloatValue called on data option of type \" + o.Type.String())\n\t}\n\treturn o.Value.(float64)\n}\n\n// StringValue is a utility function for casting option value to string\nfunc (o ApplicationCommandInteractionDataOption) StringValue() string {\n\tif o.Type != ApplicationCommandOptionString {\n\t\tpanic(\"StringValue called on data option of type \" + o.Type.String())\n\t}\n\treturn o.Value.(string)\n}\n\n// BoolValue is a utility function for casting option value to bool\nfunc (o ApplicationCommandInteractionDataOption) BoolValue() bool {\n\tif o.Type != ApplicationCommandOptionBoolean {\n\t\tpanic(\"BoolValue called on data option of type \" + o.Type.String())\n\t}\n\treturn o.Value.(bool)\n}\n\n// ChannelValue is a utility function for casting option value to channel object.\n// s : Session object, if not nil, function additionally fetches all channel's data\nfunc (o ApplicationCommandInteractionDataOption) ChannelValue(s *Session) *Channel {\n\tif o.Type != ApplicationCommandOptionChannel {\n\t\tpanic(\"ChannelValue called on data option of type \" + o.Type.String())\n\t}\n\tchanID := o.Value.(string)\n\n\tif s == nil {\n\t\treturn &Channel{ID: chanID}\n\t}\n\n\tch, err := s.State.Channel(chanID)\n\tif err != nil {\n\t\tch, err = s.Channel(chanID)\n\t\tif err != nil {\n\t\t\treturn &Channel{ID: chanID}\n\t\t}\n\t}\n\n\treturn ch\n}\n\n// RoleValue is a utility function for casting option value to role object.\n// s : Session object, if not nil, function additionally fetches all role's data\nfunc (o ApplicationCommandInteractionDataOption) RoleValue(s *Session, gID string) *Role {\n\tif o.Type != ApplicationCommandOptionRole && o.Type != ApplicationCommandOptionMentionable {\n\t\tpanic(\"RoleValue called on data option of type \" + o.Type.String())\n\t}\n\troleID := o.Value.(string)\n\n\tif s == nil || gID == \"\" {\n\t\treturn &Role{ID: roleID}\n\t}\n\n\tr, err := s.State.Role(gID, roleID)\n\tif err != nil {\n\t\troles, err := s.GuildRoles(gID)\n\t\tif err == nil {\n\t\t\tfor _, r = range roles {\n\t\t\t\tif r.ID == roleID {\n\t\t\t\t\treturn r\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn &Role{ID: roleID}\n\t}\n\n\treturn r\n}\n\n// UserValue is a utility function for casting option value to user object.\n// s : Session object, if not nil, function additionally fetches all user's data\nfunc (o ApplicationCommandInteractionDataOption) UserValue(s *Session) *User {\n\tif o.Type != ApplicationCommandOptionUser && o.Type != ApplicationCommandOptionMentionable {\n\t\tpanic(\"UserValue called on data option of type \" + o.Type.String())\n\t}\n\tuserID := o.Value.(string)\n\n\tif s == nil {\n\t\treturn &User{ID: userID}\n\t}\n\n\tu, err := s.User(userID)\n\tif err != nil {\n\t\treturn &User{ID: userID}\n\t}\n\n\treturn u\n}\n\n// InteractionResponseType is type of interaction response.\ntype InteractionResponseType uint8\n\n// Interaction response types.\nconst (\n\t// InteractionResponsePong is for ACK ping event.\n\tInteractionResponsePong InteractionResponseType = 1\n\t// InteractionResponseChannelMessageWithSource is for responding with a message, showing the user's input.\n\tInteractionResponseChannelMessageWithSource InteractionResponseType = 4\n\t// InteractionResponseDeferredChannelMessageWithSource acknowledges that the event was received, and that a follow-up will come later.\n\tInteractionResponseDeferredChannelMessageWithSource InteractionResponseType = 5\n\t// InteractionResponseDeferredMessageUpdate acknowledges that the message component interaction event was received, and message will be updated later.\n\tInteractionResponseDeferredMessageUpdate InteractionResponseType = 6\n\t// InteractionResponseUpdateMessage is for updating the message to which message component was attached.\n\tInteractionResponseUpdateMessage InteractionResponseType = 7\n\t// InteractionApplicationCommandAutocompleteResult shows autocompletion results. Autocomplete interaction only.\n\tInteractionApplicationCommandAutocompleteResult InteractionResponseType = 8\n\t// InteractionResponseModal is for responding to an interaction with a modal window.\n\tInteractionResponseModal InteractionResponseType = 9\n)\n\n// InteractionResponse represents a response for an interaction event.\ntype InteractionResponse struct {\n\tType InteractionResponseType  `json:\"type,omitempty\"`\n\tData *InteractionResponseData `json:\"data,omitempty\"`\n}\n\n// InteractionResponseData is response data for an interaction.\ntype InteractionResponseData struct {\n\tTTS             bool                    `json:\"tts\"`\n\tContent         string                  `json:\"content\"`\n\tComponents      []MessageComponent      `json:\"components\"`\n\tEmbeds          []*MessageEmbed         `json:\"embeds\"`\n\tAllowedMentions *MessageAllowedMentions `json:\"allowed_mentions,omitempty\"`\n\tFiles           []*File                 `json:\"-\"`\n\tAttachments     *[]*MessageAttachment   `json:\"attachments,omitempty\"`\n\tPoll            *Poll                   `json:\"poll,omitempty\"`\n\n\t// NOTE: only MessageFlagsSuppressEmbeds and MessageFlagsEphemeral can be set.\n\tFlags MessageFlags `json:\"flags,omitempty\"`\n\n\t// NOTE: autocomplete interaction only.\n\tChoices []*ApplicationCommandOptionChoice `json:\"choices,omitempty\"`\n\n\t// NOTE: modal interaction only.\n\n\tCustomID string `json:\"custom_id,omitempty\"`\n\tTitle    string `json:\"title,omitempty\"`\n}\n\n// VerifyInteraction implements message verification of the discord interactions api\n// signing algorithm, as documented here:\n// https://discord.com/developers/docs/interactions/receiving-and-responding#security-and-authorization\nfunc VerifyInteraction(r *http.Request, key ed25519.PublicKey) bool {\n\tvar msg bytes.Buffer\n\n\tsignature := r.Header.Get(\"X-Signature-Ed25519\")\n\tif signature == \"\" {\n\t\treturn false\n\t}\n\n\tsig, err := hex.DecodeString(signature)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(sig) != ed25519.SignatureSize {\n\t\treturn false\n\t}\n\n\ttimestamp := r.Header.Get(\"X-Signature-Timestamp\")\n\tif timestamp == \"\" {\n\t\treturn false\n\t}\n\n\tmsg.WriteString(timestamp)\n\n\tdefer r.Body.Close()\n\tvar body bytes.Buffer\n\n\t// at the end of the function, copy the original body back into the request\n\tdefer func() {\n\t\tr.Body = ioutil.NopCloser(&body)\n\t}()\n\n\t// copy body into buffers\n\t_, err = io.Copy(&msg, io.TeeReader(r.Body, &body))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn ed25519.Verify(key, msg.Bytes(), sig)\n}\n"
        },
        {
          "name": "interactions_test.go",
          "type": "blob",
          "size": 1.958984375,
          "content": "package discordgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/ed25519\"\n\t\"encoding/hex\"\n\t\"net/http/httptest\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestVerifyInteraction(t *testing.T) {\n\tpubkey, privkey, err := ed25519.GenerateKey(nil)\n\tif err != nil {\n\t\tt.Errorf(\"error generating signing keypair: %s\", err)\n\t}\n\ttimestamp := \"1608597133\"\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tbody := \"body\"\n\t\trequest := httptest.NewRequest(\"POST\", \"http://localhost/interaction\", strings.NewReader(body))\n\t\trequest.Header.Set(\"X-Signature-Timestamp\", timestamp)\n\n\t\tvar msg bytes.Buffer\n\t\tmsg.WriteString(timestamp)\n\t\tmsg.WriteString(body)\n\t\tsignature := ed25519.Sign(privkey, msg.Bytes())\n\t\trequest.Header.Set(\"X-Signature-Ed25519\", hex.EncodeToString(signature[:ed25519.SignatureSize]))\n\n\t\tif !VerifyInteraction(request, pubkey) {\n\t\t\tt.Error(\"expected true, got false\")\n\t\t}\n\t})\n\n\tt.Run(\"failure/modified body\", func(t *testing.T) {\n\t\tbody := \"body\"\n\t\trequest := httptest.NewRequest(\"POST\", \"http://localhost/interaction\", strings.NewReader(\"WRONG\"))\n\t\trequest.Header.Set(\"X-Signature-Timestamp\", timestamp)\n\n\t\tvar msg bytes.Buffer\n\t\tmsg.WriteString(timestamp)\n\t\tmsg.WriteString(body)\n\t\tsignature := ed25519.Sign(privkey, msg.Bytes())\n\t\trequest.Header.Set(\"X-Signature-Ed25519\", hex.EncodeToString(signature[:ed25519.SignatureSize]))\n\n\t\tif VerifyInteraction(request, pubkey) {\n\t\t\tt.Error(\"expected false, got true\")\n\t\t}\n\t})\n\n\tt.Run(\"failure/modified timestamp\", func(t *testing.T) {\n\t\tbody := \"body\"\n\t\trequest := httptest.NewRequest(\"POST\", \"http://localhost/interaction\", strings.NewReader(\"WRONG\"))\n\t\trequest.Header.Set(\"X-Signature-Timestamp\", strconv.FormatInt(time.Now().Add(time.Minute).Unix(), 10))\n\n\t\tvar msg bytes.Buffer\n\t\tmsg.WriteString(timestamp)\n\t\tmsg.WriteString(body)\n\t\tsignature := ed25519.Sign(privkey, msg.Bytes())\n\t\trequest.Header.Set(\"X-Signature-Ed25519\", hex.EncodeToString(signature[:ed25519.SignatureSize]))\n\n\t\tif VerifyInteraction(request, pubkey) {\n\t\t\tt.Error(\"expected false, got true\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "locales.go",
          "type": "blob",
          "size": 2.2412109375,
          "content": "package discordgo\n\n// Locale represents the accepted languages for Discord.\n// https://discord.com/developers/docs/reference#locales\ntype Locale string\n\n// String returns the human-readable string of the locale\nfunc (l Locale) String() string {\n\tif name, ok := Locales[l]; ok {\n\t\treturn name\n\t}\n\treturn Unknown.String()\n}\n\n// All defined locales in Discord\nconst (\n\tEnglishUS    Locale = \"en-US\"\n\tEnglishGB    Locale = \"en-GB\"\n\tBulgarian    Locale = \"bg\"\n\tChineseCN    Locale = \"zh-CN\"\n\tChineseTW    Locale = \"zh-TW\"\n\tCroatian     Locale = \"hr\"\n\tCzech        Locale = \"cs\"\n\tDanish       Locale = \"da\"\n\tDutch        Locale = \"nl\"\n\tFinnish      Locale = \"fi\"\n\tFrench       Locale = \"fr\"\n\tGerman       Locale = \"de\"\n\tGreek        Locale = \"el\"\n\tHindi        Locale = \"hi\"\n\tHungarian    Locale = \"hu\"\n\tItalian      Locale = \"it\"\n\tJapanese     Locale = \"ja\"\n\tKorean       Locale = \"ko\"\n\tLithuanian   Locale = \"lt\"\n\tNorwegian    Locale = \"no\"\n\tPolish       Locale = \"pl\"\n\tPortugueseBR Locale = \"pt-BR\"\n\tRomanian     Locale = \"ro\"\n\tRussian      Locale = \"ru\"\n\tSpanishES    Locale = \"es-ES\"\n\tSpanishLATAM Locale = \"es-419\"\n\tSwedish      Locale = \"sv-SE\"\n\tThai         Locale = \"th\"\n\tTurkish      Locale = \"tr\"\n\tUkrainian    Locale = \"uk\"\n\tVietnamese   Locale = \"vi\"\n\tUnknown      Locale = \"\"\n)\n\n// Locales is a map of all the languages codes to their names.\nvar Locales = map[Locale]string{\n\tEnglishUS:    \"English (United States)\",\n\tEnglishGB:    \"English (Great Britain)\",\n\tBulgarian:    \"Bulgarian\",\n\tChineseCN:    \"Chinese (China)\",\n\tChineseTW:    \"Chinese (Taiwan)\",\n\tCroatian:     \"Croatian\",\n\tCzech:        \"Czech\",\n\tDanish:       \"Danish\",\n\tDutch:        \"Dutch\",\n\tFinnish:      \"Finnish\",\n\tFrench:       \"French\",\n\tGerman:       \"German\",\n\tGreek:        \"Greek\",\n\tHindi:        \"Hindi\",\n\tHungarian:    \"Hungarian\",\n\tItalian:      \"Italian\",\n\tJapanese:     \"Japanese\",\n\tKorean:       \"Korean\",\n\tLithuanian:   \"Lithuanian\",\n\tNorwegian:    \"Norwegian\",\n\tPolish:       \"Polish\",\n\tPortugueseBR: \"Portuguese (Brazil)\",\n\tRomanian:     \"Romanian\",\n\tRussian:      \"Russian\",\n\tSpanishES:    \"Spanish (Spain)\",\n\tSpanishLATAM: \"Spanish (LATAM)\",\n\tSwedish:      \"Swedish\",\n\tThai:         \"Thai\",\n\tTurkish:      \"Turkish\",\n\tUkrainian:    \"Ukrainian\",\n\tVietnamese:   \"Vietnamese\",\n\tUnknown:      \"unknown\",\n}\n"
        },
        {
          "name": "logging.go",
          "type": "blob",
          "size": 2.7900390625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains code related to discordgo package logging\n\npackage discordgo\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"runtime\"\n\t\"strings\"\n)\n\nconst (\n\n\t// LogError level is used for critical errors that could lead to data loss\n\t// or panic that would not be returned to a calling function.\n\tLogError int = iota\n\n\t// LogWarning level is used for very abnormal events and errors that are\n\t// also returned to a calling function.\n\tLogWarning\n\n\t// LogInformational level is used for normal non-error activity\n\tLogInformational\n\n\t// LogDebug level is for very detailed non-error activity.  This is\n\t// very spammy and will impact performance.\n\tLogDebug\n)\n\n// Logger can be used to replace the standard logging for discordgo\nvar Logger func(msgL, caller int, format string, a ...interface{})\n\n// msglog provides package wide logging consistency for discordgo\n// the format, a...  portion this command follows that of fmt.Printf\n//   msgL   : LogLevel of the message\n//   caller : 1 + the number of callers away from the message source\n//   format : Printf style message format\n//   a ...  : comma separated list of values to pass\nfunc msglog(msgL, caller int, format string, a ...interface{}) {\n\n\tif Logger != nil {\n\t\tLogger(msgL, caller, format, a...)\n\t} else {\n\n\t\tpc, file, line, _ := runtime.Caller(caller)\n\n\t\tfiles := strings.Split(file, \"/\")\n\t\tfile = files[len(files)-1]\n\n\t\tname := runtime.FuncForPC(pc).Name()\n\t\tfns := strings.Split(name, \".\")\n\t\tname = fns[len(fns)-1]\n\n\t\tmsg := fmt.Sprintf(format, a...)\n\n\t\tlog.Printf(\"[DG%d] %s:%d:%s() %s\\n\", msgL, file, line, name, msg)\n\t}\n}\n\n// helper function that wraps msglog for the Session struct\n// This adds a check to insure the message is only logged\n// if the session log level is equal or higher than the\n// message log level\nfunc (s *Session) log(msgL int, format string, a ...interface{}) {\n\n\tif msgL > s.LogLevel {\n\t\treturn\n\t}\n\n\tmsglog(msgL, 2, format, a...)\n}\n\n// helper function that wraps msglog for the VoiceConnection struct\n// This adds a check to insure the message is only logged\n// if the voice connection log level is equal or higher than the\n// message log level\nfunc (v *VoiceConnection) log(msgL int, format string, a ...interface{}) {\n\n\tif msgL > v.LogLevel {\n\t\treturn\n\t}\n\n\tmsglog(msgL, 2, format, a...)\n}\n\n// printJSON is a helper function to display JSON data in an easy to read format.\n/* NOT USED ATM\nfunc printJSON(body []byte) {\n\tvar prettyJSON bytes.Buffer\n\terror := json.Indent(&prettyJSON, body, \"\", \"\\t\")\n\tif error != nil {\n\t\tlog.Print(\"JSON parse error: \", error)\n\t}\n\tlog.Println(string(prettyJSON.Bytes()))\n}\n*/\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 21.7607421875,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains code related to the Message struct\n\npackage discordgo\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n)\n\n// MessageType is the type of Message\n// https://discord.com/developers/docs/resources/channel#message-object-message-types\ntype MessageType int\n\n// Block contains the valid known MessageType values\nconst (\n\tMessageTypeDefault                               MessageType = 0\n\tMessageTypeRecipientAdd                          MessageType = 1\n\tMessageTypeRecipientRemove                       MessageType = 2\n\tMessageTypeCall                                  MessageType = 3\n\tMessageTypeChannelNameChange                     MessageType = 4\n\tMessageTypeChannelIconChange                     MessageType = 5\n\tMessageTypeChannelPinnedMessage                  MessageType = 6\n\tMessageTypeGuildMemberJoin                       MessageType = 7\n\tMessageTypeUserPremiumGuildSubscription          MessageType = 8\n\tMessageTypeUserPremiumGuildSubscriptionTierOne   MessageType = 9\n\tMessageTypeUserPremiumGuildSubscriptionTierTwo   MessageType = 10\n\tMessageTypeUserPremiumGuildSubscriptionTierThree MessageType = 11\n\tMessageTypeChannelFollowAdd                      MessageType = 12\n\tMessageTypeGuildDiscoveryDisqualified            MessageType = 14\n\tMessageTypeGuildDiscoveryRequalified             MessageType = 15\n\tMessageTypeThreadCreated                         MessageType = 18\n\tMessageTypeReply                                 MessageType = 19\n\tMessageTypeChatInputCommand                      MessageType = 20\n\tMessageTypeThreadStarterMessage                  MessageType = 21\n\tMessageTypeContextMenuCommand                    MessageType = 23\n)\n\n// A Message stores all data related to a specific Discord message.\ntype Message struct {\n\t// The ID of the message.\n\tID string `json:\"id\"`\n\n\t// The ID of the channel in which the message was sent.\n\tChannelID string `json:\"channel_id\"`\n\n\t// The ID of the guild in which the message was sent.\n\tGuildID string `json:\"guild_id,omitempty\"`\n\n\t// The content of the message.\n\tContent string `json:\"content\"`\n\n\t// The time at which the messsage was sent.\n\t// CAUTION: this field may be removed in a\n\t// future API version; it is safer to calculate\n\t// the creation time via the ID.\n\tTimestamp time.Time `json:\"timestamp\"`\n\n\t// The time at which the last edit of the message\n\t// occurred, if it has been edited.\n\tEditedTimestamp *time.Time `json:\"edited_timestamp\"`\n\n\t// The roles mentioned in the message.\n\tMentionRoles []string `json:\"mention_roles\"`\n\n\t// Whether the message is text-to-speech.\n\tTTS bool `json:\"tts\"`\n\n\t// Whether the message mentions everyone.\n\tMentionEveryone bool `json:\"mention_everyone\"`\n\n\t// The author of the message. This is not guaranteed to be a\n\t// valid user (webhook-sent messages do not possess a full author).\n\tAuthor *User `json:\"author\"`\n\n\t// A list of attachments present in the message.\n\tAttachments []*MessageAttachment `json:\"attachments\"`\n\n\t// A list of components attached to the message.\n\tComponents []MessageComponent `json:\"-\"`\n\n\t// A list of embeds present in the message.\n\tEmbeds []*MessageEmbed `json:\"embeds\"`\n\n\t// A list of users mentioned in the message.\n\tMentions []*User `json:\"mentions\"`\n\n\t// A list of reactions to the message.\n\tReactions []*MessageReactions `json:\"reactions\"`\n\n\t// Whether the message is pinned or not.\n\tPinned bool `json:\"pinned\"`\n\n\t// The type of the message.\n\tType MessageType `json:\"type\"`\n\n\t// The webhook ID of the message, if it was generated by a webhook\n\tWebhookID string `json:\"webhook_id\"`\n\n\t// Member properties for this message's author,\n\t// contains only partial information\n\tMember *Member `json:\"member\"`\n\n\t// Channels specifically mentioned in this message\n\t// Not all channel mentions in a message will appear in mention_channels.\n\t// Only textual channels that are visible to everyone in a lurkable guild will ever be included.\n\t// Only crossposted messages (via Channel Following) currently include mention_channels at all.\n\t// If no mentions in the message meet these requirements, this field will not be sent.\n\tMentionChannels []*Channel `json:\"mention_channels\"`\n\n\t// Is sent with Rich Presence-related chat embeds\n\tActivity *MessageActivity `json:\"activity\"`\n\n\t// Is sent with Rich Presence-related chat embeds\n\tApplication *MessageApplication `json:\"application\"`\n\n\t// MessageReference contains reference data sent with crossposted or reply messages.\n\t// This does not contain the reference *to* this message; this is for when *this* message references another.\n\t// To generate a reference to this message, use (*Message).Reference().\n\tMessageReference *MessageReference `json:\"message_reference\"`\n\n\t// The message associated with the message_reference\n\t// NOTE: This field is only returned for messages with a type of 19 (REPLY) or 21 (THREAD_STARTER_MESSAGE).\n\t// If the message is a reply but the referenced_message field is not present,\n\t// the backend did not attempt to fetch the message that was being replied to, so its state is unknown.\n\t// If the field exists but is null, the referenced message was deleted.\n\tReferencedMessage *Message `json:\"referenced_message\"`\n\n\t// Deprecated, use InteractionMetadata.\n\t// Is sent when the message is a response to an Interaction, without an existing message.\n\t// This means responses to message component interactions do not include this property,\n\t// instead including a MessageReference, as components exist on preexisting messages.\n\tInteraction *MessageInteraction `json:\"interaction\"`\n\n\tInteractionMetadata *MessageInteractionMetadata `json:\"interaction_metadata\"`\n\n\t// The flags of the message, which describe extra features of a message.\n\t// This is a combination of bit masks; the presence of a certain permission can\n\t// be checked by performing a bitwise AND between this int and the flag.\n\tFlags MessageFlags `json:\"flags\"`\n\n\t// The thread that was started from this message, includes thread member object\n\tThread *Channel `json:\"thread,omitempty\"`\n\n\t// An array of StickerItem objects, representing sent stickers, if there were any.\n\tStickerItems []*StickerItem `json:\"sticker_items\"`\n\n\t// A poll object.\n\tPoll *Poll `json:\"poll\"`\n}\n\n// UnmarshalJSON is a helper function to unmarshal the Message.\nfunc (m *Message) UnmarshalJSON(data []byte) error {\n\ttype message Message\n\tvar v struct {\n\t\tmessage\n\t\tRawComponents []unmarshalableMessageComponent `json:\"components\"`\n\t}\n\terr := json.Unmarshal(data, &v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*m = Message(v.message)\n\tm.Components = make([]MessageComponent, len(v.RawComponents))\n\tfor i, v := range v.RawComponents {\n\t\tm.Components[i] = v.MessageComponent\n\t}\n\treturn err\n}\n\n// GetCustomEmojis pulls out all the custom (Non-unicode) emojis from a message and returns a Slice of the Emoji struct.\nfunc (m *Message) GetCustomEmojis() []*Emoji {\n\tvar toReturn []*Emoji\n\temojis := EmojiRegex.FindAllString(m.Content, -1)\n\tif len(emojis) < 1 {\n\t\treturn toReturn\n\t}\n\tfor _, em := range emojis {\n\t\tparts := strings.Split(em, \":\")\n\t\ttoReturn = append(toReturn, &Emoji{\n\t\t\tID:       parts[2][:len(parts[2])-1],\n\t\t\tName:     parts[1],\n\t\t\tAnimated: strings.HasPrefix(em, \"<a:\"),\n\t\t})\n\t}\n\treturn toReturn\n}\n\n// MessageFlags is the flags of \"message\" (see MessageFlags* consts)\n// https://discord.com/developers/docs/resources/channel#message-object-message-flags\ntype MessageFlags int\n\n// Valid MessageFlags values\nconst (\n\t// MessageFlagsCrossPosted This message has been published to subscribed channels (via Channel Following).\n\tMessageFlagsCrossPosted MessageFlags = 1 << 0\n\t// MessageFlagsIsCrossPosted this message originated from a message in another channel (via Channel Following).\n\tMessageFlagsIsCrossPosted MessageFlags = 1 << 1\n\t// MessageFlagsSuppressEmbeds do not include any embeds when serializing this message.\n\tMessageFlagsSuppressEmbeds MessageFlags = 1 << 2\n\t// TODO: deprecated, remove when compatibility is not needed\n\tMessageFlagsSupressEmbeds MessageFlags = 1 << 2\n\t// MessageFlagsSourceMessageDeleted the source message for this crosspost has been deleted (via Channel Following).\n\tMessageFlagsSourceMessageDeleted MessageFlags = 1 << 3\n\t// MessageFlagsUrgent this message came from the urgent message system.\n\tMessageFlagsUrgent MessageFlags = 1 << 4\n\t// MessageFlagsHasThread this message has an associated thread, with the same id as the message.\n\tMessageFlagsHasThread MessageFlags = 1 << 5\n\t// MessageFlagsEphemeral this message is only visible to the user who invoked the Interaction.\n\tMessageFlagsEphemeral MessageFlags = 1 << 6\n\t// MessageFlagsLoading this message is an Interaction Response and the bot is \"thinking\".\n\tMessageFlagsLoading MessageFlags = 1 << 7\n\t// MessageFlagsFailedToMentionSomeRolesInThread this message failed to mention some roles and add their members to the thread.\n\tMessageFlagsFailedToMentionSomeRolesInThread MessageFlags = 1 << 8\n\t// MessageFlagsSuppressNotifications this message will not trigger push and desktop notifications.\n\tMessageFlagsSuppressNotifications MessageFlags = 1 << 12\n\t// MessageFlagsIsVoiceMessage this message is a voice message.\n\tMessageFlagsIsVoiceMessage MessageFlags = 1 << 13\n)\n\n// File stores info about files you e.g. send in messages.\ntype File struct {\n\tName        string\n\tContentType string\n\tReader      io.Reader\n}\n\n// MessageSend stores all parameters you can send with ChannelMessageSendComplex.\ntype MessageSend struct {\n\tContent         string                  `json:\"content,omitempty\"`\n\tEmbeds          []*MessageEmbed         `json:\"embeds\"`\n\tTTS             bool                    `json:\"tts\"`\n\tComponents      []MessageComponent      `json:\"components\"`\n\tFiles           []*File                 `json:\"-\"`\n\tAllowedMentions *MessageAllowedMentions `json:\"allowed_mentions,omitempty\"`\n\tReference       *MessageReference       `json:\"message_reference,omitempty\"`\n\tStickerIDs      []string                `json:\"sticker_ids\"`\n\tFlags           MessageFlags            `json:\"flags,omitempty\"`\n\tPoll            *Poll                   `json:\"poll,omitempty\"`\n\n\t// TODO: Remove this when compatibility is not required.\n\tFile *File `json:\"-\"`\n\n\t// TODO: Remove this when compatibility is not required.\n\tEmbed *MessageEmbed `json:\"-\"`\n}\n\n// MessageEdit is used to chain parameters via ChannelMessageEditComplex, which\n// is also where you should get the instance from.\ntype MessageEdit struct {\n\tContent         *string                 `json:\"content,omitempty\"`\n\tComponents      *[]MessageComponent     `json:\"components,omitempty\"`\n\tEmbeds          *[]*MessageEmbed        `json:\"embeds,omitempty\"`\n\tAllowedMentions *MessageAllowedMentions `json:\"allowed_mentions,omitempty\"`\n\tFlags           MessageFlags            `json:\"flags,omitempty\"`\n\t// Files to append to the message\n\tFiles []*File `json:\"-\"`\n\t// Overwrite existing attachments\n\tAttachments *[]*MessageAttachment `json:\"attachments,omitempty\"`\n\n\tID      string\n\tChannel string\n\n\t// TODO: Remove this when compatibility is not required.\n\tEmbed *MessageEmbed `json:\"-\"`\n}\n\n// NewMessageEdit returns a MessageEdit struct, initialized\n// with the Channel and ID.\nfunc NewMessageEdit(channelID string, messageID string) *MessageEdit {\n\treturn &MessageEdit{\n\t\tChannel: channelID,\n\t\tID:      messageID,\n\t}\n}\n\n// SetContent is the same as setting the variable Content,\n// except it doesn't take a pointer.\nfunc (m *MessageEdit) SetContent(str string) *MessageEdit {\n\tm.Content = &str\n\treturn m\n}\n\n// SetEmbed is a convenience function for setting the embed,\n// so you can chain commands.\nfunc (m *MessageEdit) SetEmbed(embed *MessageEmbed) *MessageEdit {\n\tm.Embeds = &[]*MessageEmbed{embed}\n\treturn m\n}\n\n// SetEmbeds is a convenience function for setting the embeds,\n// so you can chain commands.\nfunc (m *MessageEdit) SetEmbeds(embeds []*MessageEmbed) *MessageEdit {\n\tm.Embeds = &embeds\n\treturn m\n}\n\n// AllowedMentionType describes the types of mentions used\n// in the MessageAllowedMentions type.\ntype AllowedMentionType string\n\n// The types of mentions used in MessageAllowedMentions.\nconst (\n\tAllowedMentionTypeRoles    AllowedMentionType = \"roles\"\n\tAllowedMentionTypeUsers    AllowedMentionType = \"users\"\n\tAllowedMentionTypeEveryone AllowedMentionType = \"everyone\"\n)\n\n// MessageAllowedMentions allows the user to specify which mentions\n// Discord is allowed to parse in this message. This is useful when\n// sending user input as a message, as it prevents unwanted mentions.\n// If this type is used, all mentions must be explicitly whitelisted,\n// either by putting an AllowedMentionType in the Parse slice\n// (allowing all mentions of that type) or, in the case of roles and\n// users, explicitly allowing those mentions on an ID-by-ID basis.\n// For more information on this functionality, see:\n// https://discordapp.com/developers/docs/resources/channel#allowed-mentions-object-allowed-mentions-reference\ntype MessageAllowedMentions struct {\n\t// The mention types that are allowed to be parsed in this message.\n\t// Please note that this is purposely **not** marked as omitempty,\n\t// so if a zero-value MessageAllowedMentions object is provided no\n\t// mentions will be allowed.\n\tParse []AllowedMentionType `json:\"parse\"`\n\n\t// A list of role IDs to allow. This cannot be used when specifying\n\t// AllowedMentionTypeRoles in the Parse slice.\n\tRoles []string `json:\"roles,omitempty\"`\n\n\t// A list of user IDs to allow. This cannot be used when specifying\n\t// AllowedMentionTypeUsers in the Parse slice.\n\tUsers []string `json:\"users,omitempty\"`\n\n\t// For replies, whether to mention the author of the message being replied to\n\tRepliedUser bool `json:\"replied_user\"`\n}\n\n// A MessageAttachment stores data for message attachments.\ntype MessageAttachment struct {\n\tID          string `json:\"id\"`\n\tURL         string `json:\"url\"`\n\tProxyURL    string `json:\"proxy_url\"`\n\tFilename    string `json:\"filename\"`\n\tContentType string `json:\"content_type\"`\n\tWidth       int    `json:\"width\"`\n\tHeight      int    `json:\"height\"`\n\tSize        int    `json:\"size\"`\n\tEphemeral   bool   `json:\"ephemeral\"`\n}\n\n// MessageEmbedFooter is a part of a MessageEmbed struct.\ntype MessageEmbedFooter struct {\n\tText         string `json:\"text,omitempty\"`\n\tIconURL      string `json:\"icon_url,omitempty\"`\n\tProxyIconURL string `json:\"proxy_icon_url,omitempty\"`\n}\n\n// MessageEmbedImage is a part of a MessageEmbed struct.\ntype MessageEmbedImage struct {\n\tURL      string `json:\"url\"`\n\tProxyURL string `json:\"proxy_url,omitempty\"`\n\tWidth    int    `json:\"width,omitempty\"`\n\tHeight   int    `json:\"height,omitempty\"`\n}\n\n// MessageEmbedThumbnail is a part of a MessageEmbed struct.\ntype MessageEmbedThumbnail struct {\n\tURL      string `json:\"url\"`\n\tProxyURL string `json:\"proxy_url,omitempty\"`\n\tWidth    int    `json:\"width,omitempty\"`\n\tHeight   int    `json:\"height,omitempty\"`\n}\n\n// MessageEmbedVideo is a part of a MessageEmbed struct.\ntype MessageEmbedVideo struct {\n\tURL    string `json:\"url,omitempty\"`\n\tWidth  int    `json:\"width,omitempty\"`\n\tHeight int    `json:\"height,omitempty\"`\n}\n\n// MessageEmbedProvider is a part of a MessageEmbed struct.\ntype MessageEmbedProvider struct {\n\tURL  string `json:\"url,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\n// MessageEmbedAuthor is a part of a MessageEmbed struct.\ntype MessageEmbedAuthor struct {\n\tURL          string `json:\"url,omitempty\"`\n\tName         string `json:\"name\"`\n\tIconURL      string `json:\"icon_url,omitempty\"`\n\tProxyIconURL string `json:\"proxy_icon_url,omitempty\"`\n}\n\n// MessageEmbedField is a part of a MessageEmbed struct.\ntype MessageEmbedField struct {\n\tName   string `json:\"name\"`\n\tValue  string `json:\"value\"`\n\tInline bool   `json:\"inline,omitempty\"`\n}\n\n// An MessageEmbed stores data for message embeds.\ntype MessageEmbed struct {\n\tURL         string                 `json:\"url,omitempty\"`\n\tType        EmbedType              `json:\"type,omitempty\"`\n\tTitle       string                 `json:\"title,omitempty\"`\n\tDescription string                 `json:\"description,omitempty\"`\n\tTimestamp   string                 `json:\"timestamp,omitempty\"`\n\tColor       int                    `json:\"color,omitempty\"`\n\tFooter      *MessageEmbedFooter    `json:\"footer,omitempty\"`\n\tImage       *MessageEmbedImage     `json:\"image,omitempty\"`\n\tThumbnail   *MessageEmbedThumbnail `json:\"thumbnail,omitempty\"`\n\tVideo       *MessageEmbedVideo     `json:\"video,omitempty\"`\n\tProvider    *MessageEmbedProvider  `json:\"provider,omitempty\"`\n\tAuthor      *MessageEmbedAuthor    `json:\"author,omitempty\"`\n\tFields      []*MessageEmbedField   `json:\"fields,omitempty\"`\n}\n\n// EmbedType is the type of embed\n// https://discord.com/developers/docs/resources/channel#embed-object-embed-types\ntype EmbedType string\n\n// Block of valid EmbedTypes\nconst (\n\tEmbedTypeRich    EmbedType = \"rich\"\n\tEmbedTypeImage   EmbedType = \"image\"\n\tEmbedTypeVideo   EmbedType = \"video\"\n\tEmbedTypeGifv    EmbedType = \"gifv\"\n\tEmbedTypeArticle EmbedType = \"article\"\n\tEmbedTypeLink    EmbedType = \"link\"\n)\n\n// MessageReactions holds a reactions object for a message.\ntype MessageReactions struct {\n\tCount int    `json:\"count\"`\n\tMe    bool   `json:\"me\"`\n\tEmoji *Emoji `json:\"emoji\"`\n}\n\n// MessageActivity is sent with Rich Presence-related chat embeds\ntype MessageActivity struct {\n\tType    MessageActivityType `json:\"type\"`\n\tPartyID string              `json:\"party_id\"`\n}\n\n// MessageActivityType is the type of message activity\ntype MessageActivityType int\n\n// Constants for the different types of Message Activity\nconst (\n\tMessageActivityTypeJoin        MessageActivityType = 1\n\tMessageActivityTypeSpectate    MessageActivityType = 2\n\tMessageActivityTypeListen      MessageActivityType = 3\n\tMessageActivityTypeJoinRequest MessageActivityType = 5\n)\n\n// MessageApplication is sent with Rich Presence-related chat embeds\ntype MessageApplication struct {\n\tID          string `json:\"id\"`\n\tCoverImage  string `json:\"cover_image\"`\n\tDescription string `json:\"description\"`\n\tIcon        string `json:\"icon\"`\n\tName        string `json:\"name\"`\n}\n\n// MessageReference contains reference data sent with crossposted messages\ntype MessageReference struct {\n\tMessageID       string `json:\"message_id\"`\n\tChannelID       string `json:\"channel_id,omitempty\"`\n\tGuildID         string `json:\"guild_id,omitempty\"`\n\tFailIfNotExists *bool  `json:\"fail_if_not_exists,omitempty\"`\n}\n\nfunc (m *Message) reference(failIfNotExists bool) *MessageReference {\n\treturn &MessageReference{\n\t\tGuildID:         m.GuildID,\n\t\tChannelID:       m.ChannelID,\n\t\tMessageID:       m.ID,\n\t\tFailIfNotExists: &failIfNotExists,\n\t}\n}\n\n// Reference returns a MessageReference of the given message.\nfunc (m *Message) Reference() *MessageReference {\n\treturn m.reference(true)\n}\n\n// SoftReference returns a MessageReference of the given message.\n// If the message doesn't exist it will instead be sent as a non-reply message.\nfunc (m *Message) SoftReference() *MessageReference {\n\treturn m.reference(false)\n}\n\n// ContentWithMentionsReplaced will replace all @<id> mentions with the\n// username of the mention.\nfunc (m *Message) ContentWithMentionsReplaced() (content string) {\n\tcontent = m.Content\n\n\tfor _, user := range m.Mentions {\n\t\tcontent = strings.NewReplacer(\n\t\t\t\"<@\"+user.ID+\">\", \"@\"+user.Username,\n\t\t\t\"<@!\"+user.ID+\">\", \"@\"+user.Username,\n\t\t).Replace(content)\n\t}\n\treturn\n}\n\nvar patternChannels = regexp.MustCompile(\"<#[^>]*>\")\n\n// ContentWithMoreMentionsReplaced will replace all @<id> mentions with the\n// username of the mention, but also role IDs and more.\nfunc (m *Message) ContentWithMoreMentionsReplaced(s *Session) (content string, err error) {\n\tcontent = m.Content\n\n\tif !s.StateEnabled {\n\t\tcontent = m.ContentWithMentionsReplaced()\n\t\treturn\n\t}\n\n\tchannel, err := s.State.Channel(m.ChannelID)\n\tif err != nil {\n\t\tcontent = m.ContentWithMentionsReplaced()\n\t\treturn\n\t}\n\n\tfor _, user := range m.Mentions {\n\t\tnick := user.Username\n\n\t\tmember, err := s.State.Member(channel.GuildID, user.ID)\n\t\tif err == nil && member.Nick != \"\" {\n\t\t\tnick = member.Nick\n\t\t}\n\n\t\tcontent = strings.NewReplacer(\n\t\t\t\"<@\"+user.ID+\">\", \"@\"+user.Username,\n\t\t\t\"<@!\"+user.ID+\">\", \"@\"+nick,\n\t\t).Replace(content)\n\t}\n\tfor _, roleID := range m.MentionRoles {\n\t\trole, err := s.State.Role(channel.GuildID, roleID)\n\t\tif err != nil || !role.Mentionable {\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent = strings.Replace(content, \"<@&\"+role.ID+\">\", \"@\"+role.Name, -1)\n\t}\n\n\tcontent = patternChannels.ReplaceAllStringFunc(content, func(mention string) string {\n\t\tchannel, err := s.State.Channel(mention[2 : len(mention)-1])\n\t\tif err != nil || channel.Type == ChannelTypeGuildVoice {\n\t\t\treturn mention\n\t\t}\n\n\t\treturn \"#\" + channel.Name\n\t})\n\treturn\n}\n\n// MessageInteraction contains information about the application command interaction which generated the message.\ntype MessageInteraction struct {\n\tID   string          `json:\"id\"`\n\tType InteractionType `json:\"type\"`\n\tName string          `json:\"name\"`\n\tUser *User           `json:\"user\"`\n\n\t// Member is only present when the interaction is from a guild.\n\tMember *Member `json:\"member\"`\n}\n\n// MessageInteractionMetadata contains metadata of an interaction, including relevant user info.\ntype MessageInteractionMetadata struct {\n\t// ID of the interaction.\n\tID string `json:\"id\"`\n\t// Type of the interaction.\n\tType InteractionType `json:\"type\"`\n\t// User who triggered the interaction.\n\tUser *User `json:\"user\"`\n\t// IDs for installation context(s) related to an interaction.\n\tAuthorizingIntegrationOwners map[ApplicationIntegrationType]string `json:\"authorizing_integration_owners\"`\n\t// ID of the original response message.\n\t// NOTE: present only on followup messages.\n\tOriginalResponseMessageID string `json:\"original_response_message_id,omitempty\"`\n\t// ID of the message that contained interactive component.\n\t// NOTE: present only on message component interactions.\n\tInteractedMessageID string `json:\"interacted_message_id,omitempty\"`\n\t// Metadata for interaction that was used to open a modal.\n\t// NOTE: present only on modal submit interactions.\n\tTriggeringInteractionMetadata *MessageInteractionMetadata `json:\"triggering_interaction_metadata,omitempty\"`\n}\n"
        },
        {
          "name": "message_test.go",
          "type": "blob",
          "size": 1.1044921875,
          "content": "package discordgo\n\nimport (\n\t\"testing\"\n)\n\nfunc TestContentWithMoreMentionsReplaced(t *testing.T) {\n\ts := &Session{StateEnabled: true, State: NewState()}\n\n\tuser := &User{\n\t\tID:       \"user\",\n\t\tUsername: \"User Name\",\n\t}\n\n\ts.State.GuildAdd(&Guild{ID: \"guild\"})\n\ts.State.RoleAdd(\"guild\", &Role{\n\t\tID:          \"role\",\n\t\tName:        \"Role Name\",\n\t\tMentionable: true,\n\t})\n\ts.State.MemberAdd(&Member{\n\t\tUser:    user,\n\t\tNick:    \"User Nick\",\n\t\tGuildID: \"guild\",\n\t})\n\ts.State.ChannelAdd(&Channel{\n\t\tName:    \"Channel Name\",\n\t\tGuildID: \"guild\",\n\t\tID:      \"channel\",\n\t})\n\tm := &Message{\n\t\tContent:      \"<@&role> <@!user> <@user> <#channel>\",\n\t\tChannelID:    \"channel\",\n\t\tMentionRoles: []string{\"role\"},\n\t\tMentions:     []*User{user},\n\t}\n\tif result, _ := m.ContentWithMoreMentionsReplaced(s); result != \"@Role Name @User Nick @User Name #Channel Name\" {\n\t\tt.Error(result)\n\t}\n}\nfunc TestGettingEmojisFromMessage(t *testing.T) {\n\tmsg := \"test test <:kitty14:811736565172011058> <:kitty4:811736468812595260>\"\n\tm := &Message{\n\t\tContent: msg,\n\t}\n\temojis := m.GetCustomEmojis()\n\tif len(emojis) < 1 {\n\t\tt.Error(\"No emojis found.\")\n\t\treturn\n\t}\n\n}\n"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 0.3369140625,
          "content": "site_name: DiscordGo\nsite_author: Bruce Marriner\nsite_url: http://bwmarrin.github.io/discordgo/\nrepo_url: https://github.com/bwmarrin/discordgo\n\ndev_addr: 0.0.0.0:8000\ntheme: yeti\n\nmarkdown_extensions:\n    - smarty\n    - toc:\n        permalink: True\n    - sane_lists\n\npages:\n    - 'Home': 'index.md'\n    - 'Getting Started': 'GettingStarted.md'\n"
        },
        {
          "name": "oauth2.go",
          "type": "blob",
          "size": 4.69140625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains functions related to Discord OAuth2 endpoints\n\npackage discordgo\n\n// ------------------------------------------------------------------------------------------------\n// Code specific to Discord OAuth2 Applications\n// ------------------------------------------------------------------------------------------------\n\n// The MembershipState represents whether the user is in the team or has been invited into it\ntype MembershipState int\n\n// Constants for the different stages of the MembershipState\nconst (\n\tMembershipStateInvited  MembershipState = 1\n\tMembershipStateAccepted MembershipState = 2\n)\n\n// A TeamMember struct stores values for a single Team Member, extending the normal User data - note that the user field is partial\ntype TeamMember struct {\n\tUser            *User           `json:\"user\"`\n\tTeamID          string          `json:\"team_id\"`\n\tMembershipState MembershipState `json:\"membership_state\"`\n\tPermissions     []string        `json:\"permissions\"`\n}\n\n// A Team struct stores the members of a Discord Developer Team as well as some metadata about it\ntype Team struct {\n\tID          string        `json:\"id\"`\n\tName        string        `json:\"name\"`\n\tDescription string        `json:\"description\"`\n\tIcon        string        `json:\"icon\"`\n\tOwnerID     string        `json:\"owner_user_id\"`\n\tMembers     []*TeamMember `json:\"members\"`\n}\n\n// Application returns an Application structure of a specific Application\n//   appID : The ID of an Application\nfunc (s *Session) Application(appID string) (st *Application, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointOAuth2Application(appID), nil, EndpointOAuth2Application(\"\"))\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// Applications returns all applications for the authenticated user\nfunc (s *Session) Applications() (st []*Application, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointOAuth2Applications, nil, EndpointOAuth2Applications)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ApplicationCreate creates a new Application\n//    name : Name of Application / Bot\n//    uris : Redirect URIs (Not required)\nfunc (s *Session) ApplicationCreate(ap *Application) (st *Application, err error) {\n\n\tdata := struct {\n\t\tName        string `json:\"name\"`\n\t\tDescription string `json:\"description\"`\n\t}{ap.Name, ap.Description}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointOAuth2Applications, data, EndpointOAuth2Applications)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ApplicationUpdate updates an existing Application\n//   var : desc\nfunc (s *Session) ApplicationUpdate(appID string, ap *Application) (st *Application, err error) {\n\n\tdata := struct {\n\t\tName        string `json:\"name\"`\n\t\tDescription string `json:\"description\"`\n\t}{ap.Name, ap.Description}\n\n\tbody, err := s.RequestWithBucketID(\"PUT\", EndpointOAuth2Application(appID), data, EndpointOAuth2Application(\"\"))\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ApplicationDelete deletes an existing Application\n//   appID : The ID of an Application\nfunc (s *Session) ApplicationDelete(appID string) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointOAuth2Application(appID), nil, EndpointOAuth2Application(\"\"))\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\n// Asset struct stores values for an asset of an application\ntype Asset struct {\n\tType int    `json:\"type\"`\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\n// ApplicationAssets returns an application's assets\nfunc (s *Session) ApplicationAssets(appID string) (ass []*Asset, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointOAuth2ApplicationAssets(appID), nil, EndpointOAuth2ApplicationAssets(\"\"))\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &ass)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Code specific to Discord OAuth2 Application Bots\n// ------------------------------------------------------------------------------------------------\n\n// ApplicationBotCreate creates an Application Bot Account\n//\n//   appID : The ID of an Application\n//\n// NOTE: func name may change, if I can think up something better.\nfunc (s *Session) ApplicationBotCreate(appID string) (st *User, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointOAuth2ApplicationsBot(appID), nil, EndpointOAuth2ApplicationsBot(\"\"))\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n"
        },
        {
          "name": "oauth2_test.go",
          "type": "blob",
          "size": 1.3720703125,
          "content": "package discordgo_test\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/bwmarrin/discordgo\"\n)\n\nfunc ExampleApplication() {\n\n\t// Authentication Token pulled from environment variable DGU_TOKEN\n\tToken := os.Getenv(\"DGU_TOKEN\")\n\tif Token == \"\" {\n\t\treturn\n\t}\n\n\t// Create a new Discordgo session\n\tdg, err := discordgo.New(Token)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\t// Create an new Application\n\tap := &discordgo.Application{}\n\tap.Name = \"TestApp\"\n\tap.Description = \"TestDesc\"\n\tap, err = dg.ApplicationCreate(ap)\n\tlog.Printf(\"ApplicationCreate: err: %+v, app: %+v\\n\", err, ap)\n\n\t// Get a specific Application by it's ID\n\tap, err = dg.Application(ap.ID)\n\tlog.Printf(\"Application: err: %+v, app: %+v\\n\", err, ap)\n\n\t// Update an existing Application with new values\n\tap.Description = \"Whooooa\"\n\tap, err = dg.ApplicationUpdate(ap.ID, ap)\n\tlog.Printf(\"ApplicationUpdate: err: %+v, app: %+v\\n\", err, ap)\n\n\t// create a new bot account for this application\n\tbot, err := dg.ApplicationBotCreate(ap.ID)\n\tlog.Printf(\"BotCreate: err: %+v, bot: %+v\\n\", err, bot)\n\n\t// Get a list of all applications for the authenticated user\n\tapps, err := dg.Applications()\n\tlog.Printf(\"Applications: err: %+v, apps : %+v\\n\", err, apps)\n\tfor k, v := range apps {\n\t\tlog.Printf(\"Applications: %d : %+v\\n\", k, v)\n\t}\n\n\t// Delete the application we created.\n\terr = dg.ApplicationDelete(ap.ID)\n\tlog.Printf(\"Delete: err: %+v\\n\", err)\n\n\treturn\n}\n"
        },
        {
          "name": "ratelimit.go",
          "type": "blob",
          "size": 4.91015625,
          "content": "package discordgo\n\nimport (\n\t\"math\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// customRateLimit holds information for defining a custom rate limit\ntype customRateLimit struct {\n\tsuffix   string\n\trequests int\n\treset    time.Duration\n}\n\n// RateLimiter holds all ratelimit buckets\ntype RateLimiter struct {\n\tsync.Mutex\n\tglobal           *int64\n\tbuckets          map[string]*Bucket\n\tglobalRateLimit  time.Duration\n\tcustomRateLimits []*customRateLimit\n}\n\n// NewRatelimiter returns a new RateLimiter\nfunc NewRatelimiter() *RateLimiter {\n\n\treturn &RateLimiter{\n\t\tbuckets: make(map[string]*Bucket),\n\t\tglobal:  new(int64),\n\t\tcustomRateLimits: []*customRateLimit{\n\t\t\t{\n\t\t\t\tsuffix:   \"//reactions//\",\n\t\t\t\trequests: 1,\n\t\t\t\treset:    200 * time.Millisecond,\n\t\t\t},\n\t\t},\n\t}\n}\n\n// GetBucket retrieves or creates a bucket\nfunc (r *RateLimiter) GetBucket(key string) *Bucket {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tif bucket, ok := r.buckets[key]; ok {\n\t\treturn bucket\n\t}\n\n\tb := &Bucket{\n\t\tRemaining: 1,\n\t\tKey:       key,\n\t\tglobal:    r.global,\n\t}\n\n\t// Check if there is a custom ratelimit set for this bucket ID.\n\tfor _, rl := range r.customRateLimits {\n\t\tif strings.HasSuffix(b.Key, rl.suffix) {\n\t\t\tb.customRateLimit = rl\n\t\t\tbreak\n\t\t}\n\t}\n\n\tr.buckets[key] = b\n\treturn b\n}\n\n// GetWaitTime returns the duration you should wait for a Bucket\nfunc (r *RateLimiter) GetWaitTime(b *Bucket, minRemaining int) time.Duration {\n\t// If we ran out of calls and the reset time is still ahead of us\n\t// then we need to take it easy and relax a little\n\tif b.Remaining < minRemaining && b.reset.After(time.Now()) {\n\t\treturn b.reset.Sub(time.Now())\n\t}\n\n\t// Check for global ratelimits\n\tsleepTo := time.Unix(0, atomic.LoadInt64(r.global))\n\tif now := time.Now(); now.Before(sleepTo) {\n\t\treturn sleepTo.Sub(now)\n\t}\n\n\treturn 0\n}\n\n// LockBucket Locks until a request can be made\nfunc (r *RateLimiter) LockBucket(bucketID string) *Bucket {\n\treturn r.LockBucketObject(r.GetBucket(bucketID))\n}\n\n// LockBucketObject Locks an already resolved bucket until a request can be made\nfunc (r *RateLimiter) LockBucketObject(b *Bucket) *Bucket {\n\tb.Lock()\n\n\tif wait := r.GetWaitTime(b, 1); wait > 0 {\n\t\ttime.Sleep(wait)\n\t}\n\n\tb.Remaining--\n\treturn b\n}\n\n// Bucket represents a ratelimit bucket, each bucket gets ratelimited individually (-global ratelimits)\ntype Bucket struct {\n\tsync.Mutex\n\tKey       string\n\tRemaining int\n\tlimit     int\n\treset     time.Time\n\tglobal    *int64\n\n\tlastReset       time.Time\n\tcustomRateLimit *customRateLimit\n\tUserdata        interface{}\n}\n\n// Release unlocks the bucket and reads the headers to update the buckets ratelimit info\n// and locks up the whole thing in case if there's a global ratelimit.\nfunc (b *Bucket) Release(headers http.Header) error {\n\tdefer b.Unlock()\n\n\t// Check if the bucket uses a custom ratelimiter\n\tif rl := b.customRateLimit; rl != nil {\n\t\tif time.Now().Sub(b.lastReset) >= rl.reset {\n\t\t\tb.Remaining = rl.requests - 1\n\t\t\tb.lastReset = time.Now()\n\t\t}\n\t\tif b.Remaining < 1 {\n\t\t\tb.reset = time.Now().Add(rl.reset)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif headers == nil {\n\t\treturn nil\n\t}\n\n\tremaining := headers.Get(\"X-RateLimit-Remaining\")\n\treset := headers.Get(\"X-RateLimit-Reset\")\n\tglobal := headers.Get(\"X-RateLimit-Global\")\n\tresetAfter := headers.Get(\"X-RateLimit-Reset-After\")\n\n\t// Update global and per bucket reset time if the proper headers are available\n\t// If global is set, then it will block all buckets until after Retry-After\n\t// If Retry-After without global is provided it will use that for the new reset\n\t// time since it's more accurate than X-RateLimit-Reset.\n\t// If Retry-After after is not proided, it will update the reset time from X-RateLimit-Reset\n\tif resetAfter != \"\" {\n\t\tparsedAfter, err := strconv.ParseFloat(resetAfter, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\twhole, frac := math.Modf(parsedAfter)\n\t\tresetAt := time.Now().Add(time.Duration(whole) * time.Second).Add(time.Duration(frac*1000) * time.Millisecond)\n\n\t\t// Lock either this single bucket or all buckets\n\t\tif global != \"\" {\n\t\t\tatomic.StoreInt64(b.global, resetAt.UnixNano())\n\t\t} else {\n\t\t\tb.reset = resetAt\n\t\t}\n\t} else if reset != \"\" {\n\t\t// Calculate the reset time by using the date header returned from discord\n\t\tdiscordTime, err := http.ParseTime(headers.Get(\"Date\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tunix, err := strconv.ParseFloat(reset, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Calculate the time until reset and add it to the current local time\n\t\t// some extra time is added because without it i still encountered 429's.\n\t\t// The added amount is the lowest amount that gave no 429's\n\t\t// in 1k requests\n\t\twhole, frac := math.Modf(unix)\n\t\tdelta := time.Unix(int64(whole), 0).Add(time.Duration(frac*1000)*time.Millisecond).Sub(discordTime) + time.Millisecond*250\n\t\tb.reset = time.Now().Add(delta)\n\t}\n\n\t// Udpate remaining if header is present\n\tif remaining != \"\" {\n\t\tparsedRemaining, err := strconv.ParseInt(remaining, 10, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.Remaining = int(parsedRemaining)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "ratelimit_test.go",
          "type": "blob",
          "size": 2.8671875,
          "content": "package discordgo\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\n// This test takes ~2 seconds to run\nfunc TestRatelimitReset(t *testing.T) {\n\trl := NewRatelimiter()\n\n\tsendReq := func(endpoint string) {\n\t\tbucket := rl.LockBucket(endpoint)\n\n\t\theaders := http.Header(make(map[string][]string))\n\n\t\theaders.Set(\"X-RateLimit-Remaining\", \"0\")\n\t\t// Reset for approx 2 seconds from now\n\t\theaders.Set(\"X-RateLimit-Reset\", fmt.Sprint(float64(time.Now().Add(time.Second*2).UnixNano())/1e9))\n\t\theaders.Set(\"Date\", time.Now().Format(time.RFC850))\n\n\t\terr := bucket.Release(headers)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Release returned error: %v\", err)\n\t\t}\n\t}\n\n\tsent := time.Now()\n\tsendReq(\"/guilds/99/channels\")\n\tsendReq(\"/guilds/55/channels\")\n\tsendReq(\"/guilds/66/channels\")\n\n\tsendReq(\"/guilds/99/channels\")\n\tsendReq(\"/guilds/55/channels\")\n\tsendReq(\"/guilds/66/channels\")\n\n\t// We hit the same endpoint 2 times, so we should only be ratelimited 2 second\n\t// And always less than 4 seconds (unless you're on a stoneage computer or using swap or something...)\n\tif time.Since(sent) >= time.Second && time.Since(sent) < time.Second*4 {\n\t\tt.Log(\"OK\", time.Since(sent))\n\t} else {\n\t\tt.Error(\"Did not ratelimit correctly, got:\", time.Since(sent))\n\t}\n}\n\n// This test takes ~1 seconds to run\nfunc TestRatelimitGlobal(t *testing.T) {\n\trl := NewRatelimiter()\n\n\tsendReq := func(endpoint string) {\n\t\tbucket := rl.LockBucket(endpoint)\n\n\t\theaders := http.Header(make(map[string][]string))\n\n\t\theaders.Set(\"X-RateLimit-Global\", \"1\")\n\t\t// Reset for approx 1 seconds from now\n\t\theaders.Set(\"X-RateLimit-Reset-After\", \"1\")\n\n\t\terr := bucket.Release(headers)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Release returned error: %v\", err)\n\t\t}\n\t}\n\n\tsent := time.Now()\n\n\t// This should trigger a global ratelimit\n\tsendReq(\"/guilds/99/channels\")\n\ttime.Sleep(time.Millisecond * 100)\n\n\t// This shouldn't go through in less than 1 second\n\tsendReq(\"/guilds/55/channels\")\n\n\tif time.Since(sent) >= time.Second && time.Since(sent) < time.Second*2 {\n\t\tt.Log(\"OK\", time.Since(sent))\n\t} else {\n\t\tt.Error(\"Did not ratelimit correctly, got:\", time.Since(sent))\n\t}\n}\n\nfunc BenchmarkRatelimitSingleEndpoint(b *testing.B) {\n\trl := NewRatelimiter()\n\tfor i := 0; i < b.N; i++ {\n\t\tsendBenchReq(\"/guilds/99/channels\", rl)\n\t}\n}\n\nfunc BenchmarkRatelimitParallelMultiEndpoints(b *testing.B) {\n\trl := NewRatelimiter()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\ti := 0\n\t\tfor pb.Next() {\n\t\t\tsendBenchReq(\"/guilds/\"+strconv.Itoa(i)+\"/channels\", rl)\n\t\t\ti++\n\t\t}\n\t})\n}\n\n// Does not actually send requests, but locks the bucket and releases it with made-up headers\nfunc sendBenchReq(endpoint string, rl *RateLimiter) {\n\tbucket := rl.LockBucket(endpoint)\n\n\theaders := http.Header(make(map[string][]string))\n\n\theaders.Set(\"X-RateLimit-Remaining\", \"10\")\n\theaders.Set(\"X-RateLimit-Reset\", fmt.Sprint(float64(time.Now().UnixNano())/1e9))\n\theaders.Set(\"Date\", time.Now().Format(time.RFC850))\n\n\tbucket.Release(headers)\n}\n"
        },
        {
          "name": "restapi.go",
          "type": "blob",
          "size": 123.3994140625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains functions for interacting with the Discord REST/JSON API\n// at the lowest level.\n\npackage discordgo\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t_ \"image/jpeg\" // For JPEG decoding\n\t_ \"image/png\"  // For PNG decoding\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"context\"\n)\n\n// All error constants\nvar (\n\tErrJSONUnmarshal           = errors.New(\"json unmarshal\")\n\tErrStatusOffline           = errors.New(\"You can't set your Status to offline\")\n\tErrVerificationLevelBounds = errors.New(\"VerificationLevel out of bounds, should be between 0 and 3\")\n\tErrPruneDaysBounds         = errors.New(\"the number of days should be more than or equal to 1\")\n\tErrGuildNoIcon             = errors.New(\"guild does not have an icon set\")\n\tErrGuildNoSplash           = errors.New(\"guild does not have a splash set\")\n\tErrUnauthorized            = errors.New(\"HTTP request was unauthorized. This could be because the provided token was not a bot token. Please add \\\"Bot \\\" to the start of your token. https://discord.com/developers/docs/reference#authentication-example-bot-token-authorization-header\")\n)\n\nvar (\n\t// Marshal defines function used to encode JSON payloads\n\tMarshal func(v interface{}) ([]byte, error) = json.Marshal\n\t// Unmarshal defines function used to decode JSON payloads\n\tUnmarshal func(src []byte, v interface{}) error = json.Unmarshal\n)\n\n// RESTError stores error information about a request with a bad response code.\n// Message is not always present, there are cases where api calls can fail\n// without returning a json message.\ntype RESTError struct {\n\tRequest      *http.Request\n\tResponse     *http.Response\n\tResponseBody []byte\n\n\tMessage *APIErrorMessage // Message may be nil.\n}\n\n// newRestError returns a new REST API error.\nfunc newRestError(req *http.Request, resp *http.Response, body []byte) *RESTError {\n\trestErr := &RESTError{\n\t\tRequest:      req,\n\t\tResponse:     resp,\n\t\tResponseBody: body,\n\t}\n\n\t// Attempt to decode the error and assume no message was provided if it fails\n\tvar msg *APIErrorMessage\n\terr := Unmarshal(body, &msg)\n\tif err == nil {\n\t\trestErr.Message = msg\n\t}\n\n\treturn restErr\n}\n\n// Error returns a Rest API Error with its status code and body.\nfunc (r RESTError) Error() string {\n\treturn \"HTTP \" + r.Response.Status + \", \" + string(r.ResponseBody)\n}\n\n// RateLimitError is returned when a request exceeds a rate limit\n// and ShouldRetryOnRateLimit is false. The request may be manually\n// retried after waiting the duration specified by RetryAfter.\ntype RateLimitError struct {\n\t*RateLimit\n}\n\n// Error returns a rate limit error with rate limited endpoint and retry time.\nfunc (e RateLimitError) Error() string {\n\treturn \"Rate limit exceeded on \" + e.URL + \", retry after \" + e.RetryAfter.String()\n}\n\n// RequestConfig is an HTTP request configuration.\ntype RequestConfig struct {\n\tRequest                *http.Request\n\tShouldRetryOnRateLimit bool\n\tMaxRestRetries         int\n\tClient                 *http.Client\n}\n\n// newRequestConfig returns a new HTTP request configuration based on parameters in Session.\nfunc newRequestConfig(s *Session, req *http.Request) *RequestConfig {\n\treturn &RequestConfig{\n\t\tShouldRetryOnRateLimit: s.ShouldRetryOnRateLimit,\n\t\tMaxRestRetries:         s.MaxRestRetries,\n\t\tClient:                 s.Client,\n\t\tRequest:                req,\n\t}\n}\n\n// RequestOption is a function which mutates request configuration.\n// It can be supplied as an argument to any REST method.\ntype RequestOption func(cfg *RequestConfig)\n\n// WithClient changes the HTTP client used for the request.\nfunc WithClient(client *http.Client) RequestOption {\n\treturn func(cfg *RequestConfig) {\n\t\tif client != nil {\n\t\t\tcfg.Client = client\n\t\t}\n\t}\n}\n\n// WithRetryOnRatelimit controls whether session will retry the request on rate limit.\nfunc WithRetryOnRatelimit(retry bool) RequestOption {\n\treturn func(cfg *RequestConfig) {\n\t\tcfg.ShouldRetryOnRateLimit = retry\n\t}\n}\n\n// WithRestRetries changes maximum amount of retries if request fails.\nfunc WithRestRetries(max int) RequestOption {\n\treturn func(cfg *RequestConfig) {\n\t\tcfg.MaxRestRetries = max\n\t}\n}\n\n// WithHeader sets a header in the request.\nfunc WithHeader(key, value string) RequestOption {\n\treturn func(cfg *RequestConfig) {\n\t\tcfg.Request.Header.Set(key, value)\n\t}\n}\n\n// WithAuditLogReason changes audit log reason associated with the request.\nfunc WithAuditLogReason(reason string) RequestOption {\n\treturn WithHeader(\"X-Audit-Log-Reason\", reason)\n}\n\n// WithLocale changes accepted locale of the request.\nfunc WithLocale(locale Locale) RequestOption {\n\treturn WithHeader(\"X-Discord-Locale\", string(locale))\n}\n\n// WithContext changes context of the request.\nfunc WithContext(ctx context.Context) RequestOption {\n\treturn func(cfg *RequestConfig) {\n\t\tcfg.Request = cfg.Request.WithContext(ctx)\n\t}\n}\n\n// Request is the same as RequestWithBucketID but the bucket id is the same as the urlStr\nfunc (s *Session) Request(method, urlStr string, data interface{}, options ...RequestOption) (response []byte, err error) {\n\treturn s.RequestWithBucketID(method, urlStr, data, strings.SplitN(urlStr, \"?\", 2)[0], options...)\n}\n\n// RequestWithBucketID makes a (GET/POST/...) Requests to Discord REST API with JSON data.\nfunc (s *Session) RequestWithBucketID(method, urlStr string, data interface{}, bucketID string, options ...RequestOption) (response []byte, err error) {\n\tvar body []byte\n\tif data != nil {\n\t\tbody, err = Marshal(data)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn s.request(method, urlStr, \"application/json\", body, bucketID, 0, options...)\n}\n\n// request makes a (GET/POST/...) Requests to Discord REST API.\n// Sequence is the sequence number, if it fails with a 502 it will\n// retry with sequence+1 until it either succeeds or sequence >= session.MaxRestRetries\nfunc (s *Session) request(method, urlStr, contentType string, b []byte, bucketID string, sequence int, options ...RequestOption) (response []byte, err error) {\n\tif bucketID == \"\" {\n\t\tbucketID = strings.SplitN(urlStr, \"?\", 2)[0]\n\t}\n\treturn s.RequestWithLockedBucket(method, urlStr, contentType, b, s.Ratelimiter.LockBucket(bucketID), sequence, options...)\n}\n\n// RequestWithLockedBucket makes a request using a bucket that's already been locked\nfunc (s *Session) RequestWithLockedBucket(method, urlStr, contentType string, b []byte, bucket *Bucket, sequence int, options ...RequestOption) (response []byte, err error) {\n\tif s.Debug {\n\t\tlog.Printf(\"API REQUEST %8s :: %s\\n\", method, urlStr)\n\t\tlog.Printf(\"API REQUEST  PAYLOAD :: [%s]\\n\", string(b))\n\t}\n\n\treq, err := http.NewRequest(method, urlStr, bytes.NewBuffer(b))\n\tif err != nil {\n\t\tbucket.Release(nil)\n\t\treturn\n\t}\n\n\t// Not used on initial login..\n\t// TODO: Verify if a login, otherwise complain about no-token\n\tif s.Token != \"\" {\n\t\treq.Header.Set(\"authorization\", s.Token)\n\t}\n\n\t// Discord's API returns a 400 Bad Request is Content-Type is set, but the\n\t// request body is empty.\n\tif b != nil {\n\t\treq.Header.Set(\"Content-Type\", contentType)\n\t}\n\n\t// TODO: Make a configurable static variable.\n\treq.Header.Set(\"User-Agent\", s.UserAgent)\n\n\tcfg := newRequestConfig(s, req)\n\tfor _, opt := range options {\n\t\topt(cfg)\n\t}\n\treq = cfg.Request\n\n\tif s.Debug {\n\t\tfor k, v := range req.Header {\n\t\t\tlog.Printf(\"API REQUEST   HEADER :: [%s] = %+v\\n\", k, v)\n\t\t}\n\t}\n\n\tresp, err := cfg.Client.Do(req)\n\tif err != nil {\n\t\tbucket.Release(nil)\n\t\treturn\n\t}\n\tdefer func() {\n\t\terr2 := resp.Body.Close()\n\t\tif s.Debug && err2 != nil {\n\t\t\tlog.Println(\"error closing resp body\")\n\t\t}\n\t}()\n\n\terr = bucket.Release(resp.Header)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresponse, err = ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif s.Debug {\n\n\t\tlog.Printf(\"API RESPONSE  STATUS :: %s\\n\", resp.Status)\n\t\tfor k, v := range resp.Header {\n\t\t\tlog.Printf(\"API RESPONSE  HEADER :: [%s] = %+v\\n\", k, v)\n\t\t}\n\t\tlog.Printf(\"API RESPONSE    BODY :: [%s]\\n\\n\\n\", response)\n\t}\n\n\tswitch resp.StatusCode {\n\tcase http.StatusOK:\n\tcase http.StatusCreated:\n\tcase http.StatusNoContent:\n\tcase http.StatusBadGateway:\n\t\t// Retry sending request if possible\n\t\tif sequence < cfg.MaxRestRetries {\n\n\t\t\ts.log(LogInformational, \"%s Failed (%s), Retrying...\", urlStr, resp.Status)\n\t\t\tresponse, err = s.RequestWithLockedBucket(method, urlStr, contentType, b, s.Ratelimiter.LockBucketObject(bucket), sequence+1, options...)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"Exceeded Max retries HTTP %s, %s\", resp.Status, response)\n\t\t}\n\tcase 429: // TOO MANY REQUESTS - Rate limiting\n\t\trl := TooManyRequests{}\n\t\terr = Unmarshal(response, &rl)\n\t\tif err != nil {\n\t\t\ts.log(LogError, \"rate limit unmarshal error, %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif cfg.ShouldRetryOnRateLimit {\n\t\t\ts.log(LogInformational, \"Rate Limiting %s, retry in %v\", urlStr, rl.RetryAfter)\n\t\t\ts.handleEvent(rateLimitEventType, &RateLimit{TooManyRequests: &rl, URL: urlStr})\n\n\t\t\ttime.Sleep(rl.RetryAfter)\n\t\t\t// we can make the above smarter\n\t\t\t// this method can cause longer delays than required\n\n\t\t\tresponse, err = s.RequestWithLockedBucket(method, urlStr, contentType, b, s.Ratelimiter.LockBucketObject(bucket), sequence, options...)\n\t\t} else {\n\t\t\terr = &RateLimitError{&RateLimit{TooManyRequests: &rl, URL: urlStr}}\n\t\t}\n\tcase http.StatusUnauthorized:\n\t\tif strings.Index(s.Token, \"Bot \") != 0 {\n\t\t\ts.log(LogInformational, ErrUnauthorized.Error())\n\t\t\terr = ErrUnauthorized\n\t\t}\n\t\tfallthrough\n\tdefault: // Error condition\n\t\terr = newRestError(req, resp, response)\n\t}\n\n\treturn\n}\n\nfunc unmarshal(data []byte, v interface{}) error {\n\terr := Unmarshal(data, v)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%w: %s\", ErrJSONUnmarshal, err)\n\t}\n\n\treturn nil\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Users\n// ------------------------------------------------------------------------------------------------\n\n// User returns the user details of the given userID\n// userID    : A user ID or \"@me\" which is a shortcut of current user ID\nfunc (s *Session) User(userID string, options ...RequestOption) (st *User, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointUser(userID), nil, EndpointUsers, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserAvatar is deprecated. Please use UserAvatarDecode\n// userID    : A user ID or \"@me\" which is a shortcut of current user ID\nfunc (s *Session) UserAvatar(userID string, options ...RequestOption) (img image.Image, err error) {\n\tu, err := s.User(userID, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\timg, err = s.UserAvatarDecode(u, options...)\n\treturn\n}\n\n// UserAvatarDecode returns an image.Image of a user's Avatar\n// user : The user which avatar should be retrieved\nfunc (s *Session) UserAvatarDecode(u *User, options ...RequestOption) (img image.Image, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointUserAvatar(u.ID, u.Avatar), nil, EndpointUserAvatar(\"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\timg, _, err = image.Decode(bytes.NewReader(body))\n\treturn\n}\n\n// UserUpdate updates current user settings.\nfunc (s *Session) UserUpdate(username, avatar, banner string, options ...RequestOption) (st *User, err error) {\n\n\t// NOTE: Avatar must be either the hash/id of existing Avatar or\n\t// data:image/png;base64,BASE64_STRING_OF_NEW_AVATAR_PNG\n\t// to set a new avatar.\n\t// If left blank, avatar will be set to null/blank\n\n\tdata := struct {\n\t\tUsername string `json:\"username,omitempty\"`\n\t\tAvatar   string `json:\"avatar,omitempty\"`\n\t\tBanner   string `json:\"banner,omitempty\"`\n\t}{username, avatar, banner}\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointUser(\"@me\"), data, EndpointUsers, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserConnections returns the user's connections\nfunc (s *Session) UserConnections(options ...RequestOption) (conn []*UserConnection, err error) {\n\tresponse, err := s.RequestWithBucketID(\"GET\", EndpointUserConnections(\"@me\"), nil, EndpointUserConnections(\"@me\"), options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = unmarshal(response, &conn)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\n// UserChannelCreate creates a new User (Private) Channel with another User\n// recipientID : A user ID for the user to which this channel is opened with.\nfunc (s *Session) UserChannelCreate(recipientID string, options ...RequestOption) (st *Channel, err error) {\n\n\tdata := struct {\n\t\tRecipientID string `json:\"recipient_id\"`\n\t}{recipientID}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointUserChannels(\"@me\"), data, EndpointUserChannels(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserGuildMember returns a guild member object for the current user in the given Guild.\n// guildID : ID of the guild\nfunc (s *Session) UserGuildMember(guildID string, options ...RequestOption) (st *Member, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointUserGuildMember(\"@me\", guildID), nil, EndpointUserGuildMember(\"@me\", guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserGuilds returns an array of UserGuild structures for all guilds.\n// limit       : The number guilds that can be returned. (max 200)\n// beforeID    : If provided all guilds returned will be before given ID.\n// afterID     : If provided all guilds returned will be after given ID.\n// withCounts  : Whether to include approximate member and presence counts or not.\nfunc (s *Session) UserGuilds(limit int, beforeID, afterID string, withCounts bool, options ...RequestOption) (st []*UserGuild, err error) {\n\n\tv := url.Values{}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif afterID != \"\" {\n\t\tv.Set(\"after\", afterID)\n\t}\n\tif beforeID != \"\" {\n\t\tv.Set(\"before\", beforeID)\n\t}\n\tif withCounts {\n\t\tv.Set(\"with_counts\", \"true\")\n\t}\n\n\turi := EndpointUserGuilds(\"@me\")\n\n\tif len(v) > 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointUserGuilds(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserChannelPermissions returns the permission of a user in a channel.\n// userID        : The ID of the user to calculate permissions for.\n// channelID     : The ID of the channel to calculate permission for.\n// fetchOptions  : Options used to fetch guild, member or channel if they are not present in state.\n//\n// NOTE: This function is now deprecated and will be removed in the future.\n// Please see the same function inside state.go\nfunc (s *Session) UserChannelPermissions(userID, channelID string, fetchOptions ...RequestOption) (apermissions int64, err error) {\n\t// Try to just get permissions from state.\n\tapermissions, err = s.State.UserChannelPermissions(userID, channelID)\n\tif err == nil {\n\t\treturn\n\t}\n\n\t// Otherwise try get as much data from state as possible, falling back to the network.\n\tchannel, err := s.State.Channel(channelID)\n\tif err != nil || channel == nil {\n\t\tchannel, err = s.Channel(channelID, fetchOptions...)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tguild, err := s.State.Guild(channel.GuildID)\n\tif err != nil || guild == nil {\n\t\tguild, err = s.Guild(channel.GuildID, fetchOptions...)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif userID == guild.OwnerID {\n\t\tapermissions = PermissionAll\n\t\treturn\n\t}\n\n\tmember, err := s.State.Member(guild.ID, userID)\n\tif err != nil || member == nil {\n\t\tmember, err = s.GuildMember(guild.ID, userID, fetchOptions...)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn memberPermissions(guild, channel, userID, member.Roles), nil\n}\n\n// Calculates the permissions for a member.\n// https://support.discord.com/hc/en-us/articles/206141927-How-is-the-permission-hierarchy-structured-\nfunc memberPermissions(guild *Guild, channel *Channel, userID string, roles []string) (apermissions int64) {\n\tif userID == guild.OwnerID {\n\t\tapermissions = PermissionAll\n\t\treturn\n\t}\n\n\tfor _, role := range guild.Roles {\n\t\tif role.ID == guild.ID {\n\t\t\tapermissions |= role.Permissions\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor _, role := range guild.Roles {\n\t\tfor _, roleID := range roles {\n\t\t\tif role.ID == roleID {\n\t\t\t\tapermissions |= role.Permissions\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif apermissions&PermissionAdministrator == PermissionAdministrator {\n\t\tapermissions |= PermissionAll\n\t}\n\n\t// Apply @everyone overrides from the channel.\n\tfor _, overwrite := range channel.PermissionOverwrites {\n\t\tif guild.ID == overwrite.ID {\n\t\t\tapermissions &= ^overwrite.Deny\n\t\t\tapermissions |= overwrite.Allow\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar denies, allows int64\n\t// Member overwrites can override role overrides, so do two passes\n\tfor _, overwrite := range channel.PermissionOverwrites {\n\t\tfor _, roleID := range roles {\n\t\t\tif overwrite.Type == PermissionOverwriteTypeRole && roleID == overwrite.ID {\n\t\t\t\tdenies |= overwrite.Deny\n\t\t\t\tallows |= overwrite.Allow\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tapermissions &= ^denies\n\tapermissions |= allows\n\n\tfor _, overwrite := range channel.PermissionOverwrites {\n\t\tif overwrite.Type == PermissionOverwriteTypeMember && overwrite.ID == userID {\n\t\t\tapermissions &= ^overwrite.Deny\n\t\t\tapermissions |= overwrite.Allow\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif apermissions&PermissionAdministrator == PermissionAdministrator {\n\t\tapermissions |= PermissionAllChannel\n\t}\n\n\treturn apermissions\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Guilds\n// ------------------------------------------------------------------------------------------------\n\n// Guild returns a Guild structure of a specific Guild.\n// guildID   : The ID of a Guild\nfunc (s *Session) Guild(guildID string, options ...RequestOption) (st *Guild, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuild(guildID), nil, EndpointGuild(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildWithCounts returns a Guild structure of a specific Guild with approximate member and presence counts.\n// guildID    : The ID of a Guild\nfunc (s *Session) GuildWithCounts(guildID string, options ...RequestOption) (st *Guild, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuild(guildID)+\"?with_counts=true\", nil, EndpointGuild(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildPreview returns a GuildPreview structure of a specific public Guild.\n// guildID   : The ID of a Guild\nfunc (s *Session) GuildPreview(guildID string, options ...RequestOption) (st *GuildPreview, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildPreview(guildID), nil, EndpointGuildPreview(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildCreate creates a new Guild\n// name      : A name for the Guild (2-100 characters)\nfunc (s *Session) GuildCreate(name string, options ...RequestOption) (st *Guild, err error) {\n\n\tdata := struct {\n\t\tName string `json:\"name\"`\n\t}{name}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildCreate, data, EndpointGuildCreate, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildEdit edits a new Guild\n// guildID   : The ID of a Guild\n// g \t\t : A GuildParams struct with the values Name, Region and VerificationLevel defined.\nfunc (s *Session) GuildEdit(guildID string, g *GuildParams, options ...RequestOption) (st *Guild, err error) {\n\n\t// Bounds checking for VerificationLevel, interval: [0, 4]\n\tif g.VerificationLevel != nil {\n\t\tval := *g.VerificationLevel\n\t\tif val < 0 || val > 4 {\n\t\t\terr = ErrVerificationLevelBounds\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Bounds checking for regions\n\tif g.Region != \"\" {\n\t\tisValid := false\n\t\tregions, _ := s.VoiceRegions(options...)\n\t\tfor _, r := range regions {\n\t\t\tif g.Region == r.ID {\n\t\t\t\tisValid = true\n\t\t\t}\n\t\t}\n\t\tif !isValid {\n\t\t\tvar valid []string\n\t\t\tfor _, r := range regions {\n\t\t\t\tvalid = append(valid, r.ID)\n\t\t\t}\n\t\t\terr = fmt.Errorf(\"Region not a valid region (%q)\", valid)\n\t\t\treturn\n\t\t}\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuild(guildID), g, EndpointGuild(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildDelete deletes a Guild.\n// guildID   : The ID of a Guild\nfunc (s *Session) GuildDelete(guildID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuild(guildID), nil, EndpointGuild(guildID), options...)\n\treturn\n}\n\n// GuildLeave leaves a Guild.\n// guildID   : The ID of a Guild\nfunc (s *Session) GuildLeave(guildID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointUserGuild(\"@me\", guildID), nil, EndpointUserGuild(\"\", guildID), options...)\n\treturn\n}\n\n// GuildBans returns an array of GuildBan structures for bans in the given guild.\n// guildID   : The ID of a Guild\n// limit     : Max number of bans to return (max 1000)\n// beforeID  : If not empty all returned users will be after the given id\n// afterID   : If not empty all returned users will be before the given id\nfunc (s *Session) GuildBans(guildID string, limit int, beforeID, afterID string, options ...RequestOption) (st []*GuildBan, err error) {\n\turi := EndpointGuildBans(guildID)\n\n\tv := url.Values{}\n\tif limit != 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif beforeID != \"\" {\n\t\tv.Set(\"before\", beforeID)\n\t}\n\tif afterID != \"\" {\n\t\tv.Set(\"after\", afterID)\n\t}\n\n\tif len(v) > 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildBans(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildBanCreate bans the given user from the given guild.\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\n// days      : The number of days of previous comments to delete.\nfunc (s *Session) GuildBanCreate(guildID, userID string, days int, options ...RequestOption) (err error) {\n\treturn s.GuildBanCreateWithReason(guildID, userID, \"\", days, options...)\n}\n\n// GuildBan finds ban by given guild and user id and returns GuildBan structure\nfunc (s *Session) GuildBan(guildID, userID string, options ...RequestOption) (st *GuildBan, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildBan(guildID, userID), nil, EndpointGuildBan(guildID, userID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildBanCreateWithReason bans the given user from the given guild also providing a reaso.\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\n// reason    : The reason for this ban\n// days      : The number of days of previous comments to delete.\nfunc (s *Session) GuildBanCreateWithReason(guildID, userID, reason string, days int, options ...RequestOption) (err error) {\n\n\turi := EndpointGuildBan(guildID, userID)\n\n\tqueryParams := url.Values{}\n\tif days > 0 {\n\t\tqueryParams.Set(\"delete_message_days\", strconv.Itoa(days))\n\t}\n\tif reason != \"\" {\n\t\tqueryParams.Set(\"reason\", reason)\n\t}\n\n\tif len(queryParams) > 0 {\n\t\turi += \"?\" + queryParams.Encode()\n\t}\n\n\t_, err = s.RequestWithBucketID(\"PUT\", uri, nil, EndpointGuildBan(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildBanDelete removes the given user from the guild bans\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\nfunc (s *Session) GuildBanDelete(guildID, userID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildBan(guildID, userID), nil, EndpointGuildBan(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMembers returns a list of members for a guild.\n// guildID  : The ID of a Guild.\n// after    : The id of the member to return members after\n// limit    : max number of members to return (max 1000)\nfunc (s *Session) GuildMembers(guildID string, after string, limit int, options ...RequestOption) (st []*Member, err error) {\n\n\turi := EndpointGuildMembers(guildID)\n\n\tv := url.Values{}\n\n\tif after != \"\" {\n\t\tv.Set(\"after\", after)\n\t}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tif len(v) > 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildMembers(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildMembersSearch returns a list of guild member objects whose username or nickname starts with a provided string\n// guildID  : The ID of a Guild\n// query    : Query string to match username(s) and nickname(s) against\n// limit    : Max number of members to return (default 1, min 1, max 1000)\nfunc (s *Session) GuildMembersSearch(guildID, query string, limit int, options ...RequestOption) (st []*Member, err error) {\n\n\turi := EndpointGuildMembersSearch(guildID)\n\n\tqueryParams := url.Values{}\n\tqueryParams.Set(\"query\", query)\n\tif limit > 1 {\n\t\tqueryParams.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri+\"?\"+queryParams.Encode(), nil, uri, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildMember returns a member of a guild.\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\nfunc (s *Session) GuildMember(guildID, userID string, options ...RequestOption) (st *Member, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildMember(guildID, userID), nil, EndpointGuildMember(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\t// The returned object doesn't have the GuildID attribute so we will set it here.\n\tst.GuildID = guildID\n\treturn\n}\n\n// GuildMemberAdd force joins a user to the guild.\n// guildID       : The ID of a Guild.\n// userID        : The ID of a User.\n// data          : Parameters of the user to add.\nfunc (s *Session) GuildMemberAdd(guildID, userID string, data *GuildMemberAddParams, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"PUT\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn err\n}\n\n// GuildMemberDelete removes the given user from the given guild.\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\nfunc (s *Session) GuildMemberDelete(guildID, userID string, options ...RequestOption) (err error) {\n\n\treturn s.GuildMemberDeleteWithReason(guildID, userID, \"\", options...)\n}\n\n// GuildMemberDeleteWithReason removes the given user from the given guild.\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User\n// reason    : The reason for the kick\nfunc (s *Session) GuildMemberDeleteWithReason(guildID, userID, reason string, options ...RequestOption) (err error) {\n\n\turi := EndpointGuildMember(guildID, userID)\n\tif reason != \"\" {\n\t\turi += \"?reason=\" + url.QueryEscape(reason)\n\t}\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", uri, nil, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberEdit edits and returns updated member.\n// guildID  : The ID of a Guild.\n// userID   : The ID of a User.\n// data     : Updated GuildMember data.\nfunc (s *Session) GuildMemberEdit(guildID, userID string, data *GuildMemberParams, options ...RequestOption) (st *Member, err error) {\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildMemberEditComplex edits the nickname and roles of a member.\n// NOTE: deprecated, use GuildMemberEdit instead.\n//\n// guildID  : The ID of a Guild.\n// userID   : The ID of a User.\n// data     : A GuildMemberEditData struct with the new nickname and roles\nfunc (s *Session) GuildMemberEditComplex(guildID, userID string, data *GuildMemberParams, options ...RequestOption) (st *Member, err error) {\n\treturn s.GuildMemberEdit(guildID, userID, data, options...)\n}\n\n// GuildMemberMove moves a guild member from one voice channel to another/none\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// channelID : The ID of a channel to move user to or nil to remove from voice channel\n//\n// NOTE : I am not entirely set on the name of this function and it may change\n// prior to the final 1.0.0 release of Discordgo\nfunc (s *Session) GuildMemberMove(guildID string, userID string, channelID *string, options ...RequestOption) (err error) {\n\tdata := struct {\n\t\tChannelID *string `json:\"channel_id\"`\n\t}{channelID}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberNickname updates the nickname of a guild member\n// guildID   : The ID of a guild\n// userID    : The ID of a user\n// userID    : The ID of a user or \"@me\" which is a shortcut of the current user ID\n// nickname  : The nickname of the member, \"\" will reset their nickname\nfunc (s *Session) GuildMemberNickname(guildID, userID, nickname string, options ...RequestOption) (err error) {\n\n\tdata := struct {\n\t\tNick string `json:\"nick\"`\n\t}{nickname}\n\n\tif userID == \"@me\" {\n\t\tuserID += \"/nick\"\n\t}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberMute server mutes a guild member\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// mute      : boolean value for if the user should be muted\nfunc (s *Session) GuildMemberMute(guildID string, userID string, mute bool, options ...RequestOption) (err error) {\n\tdata := struct {\n\t\tMute bool `json:\"mute\"`\n\t}{mute}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberTimeout times out a guild member\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// until     : The timestamp for how long a member should be timed out. Set to nil to remove timeout.\nfunc (s *Session) GuildMemberTimeout(guildID string, userID string, until *time.Time, options ...RequestOption) (err error) {\n\tdata := struct {\n\t\tCommunicationDisabledUntil *time.Time `json:\"communication_disabled_until\"`\n\t}{until}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberDeafen server deafens a guild member\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// deaf      : boolean value for if the user should be deafened\nfunc (s *Session) GuildMemberDeafen(guildID string, userID string, deaf bool, options ...RequestOption) (err error) {\n\tdata := struct {\n\t\tDeaf bool `json:\"deaf\"`\n\t}{deaf}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildMember(guildID, userID), data, EndpointGuildMember(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildMemberRoleAdd adds the specified role to a given member\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// roleID    : The ID of a Role to be assigned to the user.\nfunc (s *Session) GuildMemberRoleAdd(guildID, userID, roleID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"PUT\", EndpointGuildMemberRole(guildID, userID, roleID), nil, EndpointGuildMemberRole(guildID, \"\", \"\"), options...)\n\n\treturn\n}\n\n// GuildMemberRoleRemove removes the specified role to a given member\n// guildID   : The ID of a Guild.\n// userID    : The ID of a User.\n// roleID    : The ID of a Role to be removed from the user.\nfunc (s *Session) GuildMemberRoleRemove(guildID, userID, roleID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildMemberRole(guildID, userID, roleID), nil, EndpointGuildMemberRole(guildID, \"\", \"\"), options...)\n\n\treturn\n}\n\n// GuildChannels returns an array of Channel structures for all channels of a\n// given guild.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildChannels(guildID string, options ...RequestOption) (st []*Channel, err error) {\n\n\tbody, err := s.request(\"GET\", EndpointGuildChannels(guildID), \"\", nil, EndpointGuildChannels(guildID), 0, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildChannelCreateData is provided to GuildChannelCreateComplex\ntype GuildChannelCreateData struct {\n\tName                 string                 `json:\"name\"`\n\tType                 ChannelType            `json:\"type\"`\n\tTopic                string                 `json:\"topic,omitempty\"`\n\tBitrate              int                    `json:\"bitrate,omitempty\"`\n\tUserLimit            int                    `json:\"user_limit,omitempty\"`\n\tRateLimitPerUser     int                    `json:\"rate_limit_per_user,omitempty\"`\n\tPosition             int                    `json:\"position,omitempty\"`\n\tPermissionOverwrites []*PermissionOverwrite `json:\"permission_overwrites,omitempty\"`\n\tParentID             string                 `json:\"parent_id,omitempty\"`\n\tNSFW                 bool                   `json:\"nsfw,omitempty\"`\n}\n\n// GuildChannelCreateComplex creates a new channel in the given guild\n// guildID      : The ID of a Guild\n// data         : A data struct describing the new Channel, Name and Type are mandatory, other fields depending on the type\nfunc (s *Session) GuildChannelCreateComplex(guildID string, data GuildChannelCreateData, options ...RequestOption) (st *Channel, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildChannels(guildID), data, EndpointGuildChannels(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildChannelCreate creates a new channel in the given guild\n// guildID   : The ID of a Guild.\n// name      : Name of the channel (2-100 chars length)\n// ctype     : Type of the channel\nfunc (s *Session) GuildChannelCreate(guildID, name string, ctype ChannelType, options ...RequestOption) (st *Channel, err error) {\n\treturn s.GuildChannelCreateComplex(guildID, GuildChannelCreateData{\n\t\tName: name,\n\t\tType: ctype,\n\t}, options...)\n}\n\n// GuildChannelsReorder updates the order of channels in a guild\n// guildID   : The ID of a Guild.\n// channels  : Updated channels.\nfunc (s *Session) GuildChannelsReorder(guildID string, channels []*Channel, options ...RequestOption) (err error) {\n\n\tdata := make([]struct {\n\t\tID       string `json:\"id\"`\n\t\tPosition int    `json:\"position\"`\n\t}, len(channels))\n\n\tfor i, c := range channels {\n\t\tdata[i].ID = c.ID\n\t\tdata[i].Position = c.Position\n\t}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildChannels(guildID), data, EndpointGuildChannels(guildID), options...)\n\treturn\n}\n\n// GuildInvites returns an array of Invite structures for the given guild\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildInvites(guildID string, options ...RequestOption) (st []*Invite, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildInvites(guildID), nil, EndpointGuildInvites(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildRoles returns all roles for a given guild.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildRoles(guildID string, options ...RequestOption) (st []*Role, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildRoles(guildID), nil, EndpointGuildRoles(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn // TODO return pointer\n}\n\n// GuildRoleCreate creates a new Guild Role and returns it.\n// guildID : The ID of a Guild.\n// data    : New Role parameters.\nfunc (s *Session) GuildRoleCreate(guildID string, data *RoleParams, options ...RequestOption) (st *Role, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildRoles(guildID), data, EndpointGuildRoles(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildRoleEdit updates an existing Guild Role and returns updated Role data.\n// guildID   : The ID of a Guild.\n// roleID    : The ID of a Role.\n// data \t\t : Updated Role data.\nfunc (s *Session) GuildRoleEdit(guildID, roleID string, data *RoleParams, options ...RequestOption) (st *Role, err error) {\n\n\t// Prevent sending a color int that is too big.\n\tif data.Color != nil && *data.Color > 0xFFFFFF {\n\t\treturn nil, fmt.Errorf(\"color value cannot be larger than 0xFFFFFF\")\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuildRole(guildID, roleID), data, EndpointGuildRole(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildRoleReorder reoders guild roles\n// guildID   : The ID of a Guild.\n// roles     : A list of ordered roles.\nfunc (s *Session) GuildRoleReorder(guildID string, roles []*Role, options ...RequestOption) (st []*Role, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuildRoles(guildID), roles, EndpointGuildRoles(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildRoleDelete deletes an existing role.\n// guildID   : The ID of a Guild.\n// roleID    : The ID of a Role.\nfunc (s *Session) GuildRoleDelete(guildID, roleID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildRole(guildID, roleID), nil, EndpointGuildRole(guildID, \"\"), options...)\n\n\treturn\n}\n\n// GuildPruneCount Returns the number of members that would be removed in a prune operation.\n// Requires 'KICK_MEMBER' permission.\n// guildID\t: The ID of a Guild.\n// days\t\t: The number of days to count prune for (1 or more).\nfunc (s *Session) GuildPruneCount(guildID string, days uint32, options ...RequestOption) (count uint32, err error) {\n\tcount = 0\n\n\tif days <= 0 {\n\t\terr = ErrPruneDaysBounds\n\t\treturn\n\t}\n\n\tp := struct {\n\t\tPruned uint32 `json:\"pruned\"`\n\t}{}\n\n\turi := EndpointGuildPrune(guildID) + \"?days=\" + strconv.FormatUint(uint64(days), 10)\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildPrune(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &p)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcount = p.Pruned\n\n\treturn\n}\n\n// GuildPrune Begin as prune operation. Requires the 'KICK_MEMBERS' permission.\n// Returns an object with one 'pruned' key indicating the number of members that were removed in the prune operation.\n// guildID\t: The ID of a Guild.\n// days\t\t: The number of days to count prune for (1 or more).\nfunc (s *Session) GuildPrune(guildID string, days uint32, options ...RequestOption) (count uint32, err error) {\n\n\tcount = 0\n\n\tif days <= 0 {\n\t\terr = ErrPruneDaysBounds\n\t\treturn\n\t}\n\n\tdata := struct {\n\t\tdays uint32\n\t}{days}\n\n\tp := struct {\n\t\tPruned uint32 `json:\"pruned\"`\n\t}{}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildPrune(guildID), data, EndpointGuildPrune(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &p)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcount = p.Pruned\n\n\treturn\n}\n\n// GuildIntegrations returns an array of Integrations for a guild.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildIntegrations(guildID string, options ...RequestOption) (st []*Integration, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildIntegrations(guildID), nil, EndpointGuildIntegrations(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildIntegrationCreate creates a Guild Integration.\n// guildID          : The ID of a Guild.\n// integrationType  : The Integration type.\n// integrationID    : The ID of an integration.\nfunc (s *Session) GuildIntegrationCreate(guildID, integrationType, integrationID string, options ...RequestOption) (err error) {\n\n\tdata := struct {\n\t\tType string `json:\"type\"`\n\t\tID   string `json:\"id\"`\n\t}{integrationType, integrationID}\n\n\t_, err = s.RequestWithBucketID(\"POST\", EndpointGuildIntegrations(guildID), data, EndpointGuildIntegrations(guildID), options...)\n\treturn\n}\n\n// GuildIntegrationEdit edits a Guild Integration.\n// guildID              : The ID of a Guild.\n// integrationType      : The Integration type.\n// integrationID        : The ID of an integration.\n// expireBehavior\t      : The behavior when an integration subscription lapses (see the integration object documentation).\n// expireGracePeriod    : Period (in seconds) where the integration will ignore lapsed subscriptions.\n// enableEmoticons\t    : Whether emoticons should be synced for this integration (twitch only currently).\nfunc (s *Session) GuildIntegrationEdit(guildID, integrationID string, expireBehavior, expireGracePeriod int, enableEmoticons bool, options ...RequestOption) (err error) {\n\n\tdata := struct {\n\t\tExpireBehavior    int  `json:\"expire_behavior\"`\n\t\tExpireGracePeriod int  `json:\"expire_grace_period\"`\n\t\tEnableEmoticons   bool `json:\"enable_emoticons\"`\n\t}{expireBehavior, expireGracePeriod, enableEmoticons}\n\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildIntegration(guildID, integrationID), data, EndpointGuildIntegration(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildIntegrationDelete removes the given integration from the Guild.\n// guildID          : The ID of a Guild.\n// integrationID    : The ID of an integration.\nfunc (s *Session) GuildIntegrationDelete(guildID, integrationID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildIntegration(guildID, integrationID), nil, EndpointGuildIntegration(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildIcon returns an image.Image of a guild icon.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildIcon(guildID string, options ...RequestOption) (img image.Image, err error) {\n\tg, err := s.Guild(guildID, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif g.Icon == \"\" {\n\t\terr = ErrGuildNoIcon\n\t\treturn\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildIcon(guildID, g.Icon), nil, EndpointGuildIcon(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\timg, _, err = image.Decode(bytes.NewReader(body))\n\treturn\n}\n\n// GuildSplash returns an image.Image of a guild splash image.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildSplash(guildID string, options ...RequestOption) (img image.Image, err error) {\n\tg, err := s.Guild(guildID, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif g.Splash == \"\" {\n\t\terr = ErrGuildNoSplash\n\t\treturn\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildSplash(guildID, g.Splash), nil, EndpointGuildSplash(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\timg, _, err = image.Decode(bytes.NewReader(body))\n\treturn\n}\n\n// GuildEmbed returns the embed for a Guild.\n// guildID   : The ID of a Guild.\nfunc (s *Session) GuildEmbed(guildID string, options ...RequestOption) (st *GuildEmbed, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildEmbed(guildID), nil, EndpointGuildEmbed(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildEmbedEdit edits the embed of a Guild.\n// guildID   : The ID of a Guild.\n// data      : New GuildEmbed data.\nfunc (s *Session) GuildEmbedEdit(guildID string, data *GuildEmbed, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"PATCH\", EndpointGuildEmbed(guildID), data, EndpointGuildEmbed(guildID), options...)\n\treturn\n}\n\n// GuildAuditLog returns the audit log for a Guild.\n// guildID     : The ID of a Guild.\n// userID      : If provided the log will be filtered for the given ID.\n// beforeID    : If provided all log entries returned will be before the given ID.\n// actionType  : If provided the log will be filtered for the given Action Type.\n// limit       : The number messages that can be returned. (default 50, min 1, max 100)\nfunc (s *Session) GuildAuditLog(guildID, userID, beforeID string, actionType, limit int, options ...RequestOption) (st *GuildAuditLog, err error) {\n\n\turi := EndpointGuildAuditLogs(guildID)\n\n\tv := url.Values{}\n\tif userID != \"\" {\n\t\tv.Set(\"user_id\", userID)\n\t}\n\tif beforeID != \"\" {\n\t\tv.Set(\"before\", beforeID)\n\t}\n\tif actionType > 0 {\n\t\tv.Set(\"action_type\", strconv.Itoa(actionType))\n\t}\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif len(v) > 0 {\n\t\turi = fmt.Sprintf(\"%s?%s\", uri, v.Encode())\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildAuditLogs(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildEmojis returns all emoji\n// guildID : The ID of a Guild.\nfunc (s *Session) GuildEmojis(guildID string, options ...RequestOption) (emoji []*Emoji, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildEmojis(guildID), nil, EndpointGuildEmojis(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// GuildEmoji returns specified emoji.\n// guildID : The ID of a Guild\n// emojiID : The ID of an Emoji to retrieve\nfunc (s *Session) GuildEmoji(guildID, emojiID string, options ...RequestOption) (emoji *Emoji, err error) {\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", EndpointGuildEmoji(guildID, emojiID), nil, EndpointGuildEmoji(guildID, emojiID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// GuildEmojiCreate creates a new Emoji.\n// guildID : The ID of a Guild.\n// data    : New Emoji data.\nfunc (s *Session) GuildEmojiCreate(guildID string, data *EmojiParams, options ...RequestOption) (emoji *Emoji, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildEmojis(guildID), data, EndpointGuildEmojis(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// GuildEmojiEdit modifies and returns updated Emoji.\n// guildID : The ID of a Guild.\n// emojiID : The ID of an Emoji.\n// data    : Updated Emoji data.\nfunc (s *Session) GuildEmojiEdit(guildID, emojiID string, data *EmojiParams, options ...RequestOption) (emoji *Emoji, err error) {\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuildEmoji(guildID, emojiID), data, EndpointGuildEmojis(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// GuildEmojiDelete deletes an Emoji.\n// guildID : The ID of a Guild.\n// emojiID : The ID of an Emoji.\nfunc (s *Session) GuildEmojiDelete(guildID, emojiID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildEmoji(guildID, emojiID), nil, EndpointGuildEmojis(guildID), options...)\n\treturn\n}\n\n// ApplicationEmojis returns all emojis for the given application\n// appID : ID of the application\nfunc (s *Session) ApplicationEmojis(appID string, options ...RequestOption) (emojis []*Emoji, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointApplicationEmojis(appID), nil, EndpointApplicationEmojis(appID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvar temp struct {\n\t\tItems []*Emoji `json:\"items\"`\n\t}\n\n\terr = unmarshal(body, &temp)\n\tif err != nil {\n\t\treturn\n\t}\n\n\temojis = temp.Items\n\treturn\n}\n\n// ApplicationEmoji returns the emoji for the given application.\n// appID   : ID of the application\n// emojiID : ID of an Emoji to retrieve\nfunc (s *Session) ApplicationEmoji(appID, emojiID string, options ...RequestOption) (emoji *Emoji, err error) {\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", EndpointApplicationEmoji(appID, emojiID), nil, EndpointApplicationEmoji(appID, emojiID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// ApplicationEmojiCreate creates a new Emoji for the given application.\n// appID : ID of the application\n// data  : New Emoji data\nfunc (s *Session) ApplicationEmojiCreate(appID string, data *EmojiParams, options ...RequestOption) (emoji *Emoji, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointApplicationEmojis(appID), data, EndpointApplicationEmojis(appID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// ApplicationEmojiEdit modifies and returns updated Emoji for the given application.\n// appID   : ID of the application\n// emojiID : ID of an Emoji\n// data    : Updated Emoji data\nfunc (s *Session) ApplicationEmojiEdit(appID string, emojiID string, data *EmojiParams, options ...RequestOption) (emoji *Emoji, err error) {\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointApplicationEmoji(appID, emojiID), data, EndpointApplicationEmojis(appID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &emoji)\n\treturn\n}\n\n// ApplicationEmojiDelete deletes an Emoji for the given application.\n// appID   : ID of the application\n// emojiID : ID of an Emoji\nfunc (s *Session) ApplicationEmojiDelete(appID, emojiID string, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointApplicationEmoji(appID, emojiID), nil, EndpointApplicationEmojis(appID), options...)\n\treturn\n}\n\n// GuildTemplate returns a GuildTemplate for the given code\n// templateCode: The Code of a GuildTemplate\nfunc (s *Session) GuildTemplate(templateCode string, options ...RequestOption) (st *GuildTemplate, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildTemplate(templateCode), nil, EndpointGuildTemplate(templateCode), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildCreateWithTemplate creates a guild based on a GuildTemplate\n// templateCode: The Code of a GuildTemplate\n// name: The name of the guild (2-100) characters\n// icon: base64 encoded 128x128 image for the guild icon\nfunc (s *Session) GuildCreateWithTemplate(templateCode, name, icon string, options ...RequestOption) (st *Guild, err error) {\n\n\tdata := struct {\n\t\tName string `json:\"name\"`\n\t\tIcon string `json:\"icon\"`\n\t}{name, icon}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildTemplate(templateCode), data, EndpointGuildTemplate(templateCode), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildTemplates returns all of GuildTemplates\n// guildID: The ID of the guild\nfunc (s *Session) GuildTemplates(guildID string, options ...RequestOption) (st []*GuildTemplate, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildTemplates(guildID), nil, EndpointGuildTemplates(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildTemplateCreate creates a template for the guild\n// guildID : The ID of the guild\n// data    : Template metadata\nfunc (s *Session) GuildTemplateCreate(guildID string, data *GuildTemplateParams, options ...RequestOption) (st *GuildTemplate) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildTemplates(guildID), data, EndpointGuildTemplates(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildTemplateSync syncs the template to the guild's current state\n// guildID: The ID of the guild\n// templateCode: The code of the template\nfunc (s *Session) GuildTemplateSync(guildID, templateCode string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"PUT\", EndpointGuildTemplateSync(guildID, templateCode), nil, EndpointGuildTemplateSync(guildID, \"\"), options...)\n\treturn\n}\n\n// GuildTemplateEdit modifies the template's metadata\n// guildID      : The ID of the guild\n// templateCode : The code of the template\n// data         : New template metadata\nfunc (s *Session) GuildTemplateEdit(guildID, templateCode string, data *GuildTemplateParams, options ...RequestOption) (st *GuildTemplate, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuildTemplateSync(guildID, templateCode), data, EndpointGuildTemplateSync(guildID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildTemplateDelete deletes the template\n// guildID: The ID of the guild\n// templateCode: The code of the template\nfunc (s *Session) GuildTemplateDelete(guildID, templateCode string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildTemplateSync(guildID, templateCode), nil, EndpointGuildTemplateSync(guildID, \"\"), options...)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Channels\n// ------------------------------------------------------------------------------------------------\n\n// Channel returns a Channel structure of a specific Channel.\n// channelID  : The ID of the Channel you want returned.\nfunc (s *Session) Channel(channelID string, options ...RequestOption) (st *Channel, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointChannel(channelID), nil, EndpointChannel(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelEdit edits the given channel and returns the updated Channel data.\n// channelID  : The ID of a Channel.\n// data       : New Channel data.\nfunc (s *Session) ChannelEdit(channelID string, data *ChannelEdit, options ...RequestOption) (st *Channel, err error) {\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointChannel(channelID), data, EndpointChannel(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n\n}\n\n// ChannelEditComplex edits an existing channel, replacing the parameters entirely with ChannelEdit struct\n// NOTE: deprecated, use ChannelEdit instead\n// channelID     : The ID of a Channel\n// data          : The channel struct to send\nfunc (s *Session) ChannelEditComplex(channelID string, data *ChannelEdit, options ...RequestOption) (st *Channel, err error) {\n\treturn s.ChannelEdit(channelID, data, options...)\n}\n\n// ChannelDelete deletes the given channel\n// channelID  : The ID of a Channel\nfunc (s *Session) ChannelDelete(channelID string, options ...RequestOption) (st *Channel, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"DELETE\", EndpointChannel(channelID), nil, EndpointChannel(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelTyping broadcasts to all members that authenticated user is typing in\n// the given channel.\n// channelID  : The ID of a Channel\nfunc (s *Session) ChannelTyping(channelID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"POST\", EndpointChannelTyping(channelID), nil, EndpointChannelTyping(channelID), options...)\n\treturn\n}\n\n// ChannelMessages returns an array of Message structures for messages within\n// a given channel.\n// channelID : The ID of a Channel.\n// limit     : The number messages that can be returned. (max 100)\n// beforeID  : If provided all messages returned will be before given ID.\n// afterID   : If provided all messages returned will be after given ID.\n// aroundID  : If provided all messages returned will be around given ID.\nfunc (s *Session) ChannelMessages(channelID string, limit int, beforeID, afterID, aroundID string, options ...RequestOption) (st []*Message, err error) {\n\n\turi := EndpointChannelMessages(channelID)\n\n\tv := url.Values{}\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif afterID != \"\" {\n\t\tv.Set(\"after\", afterID)\n\t}\n\tif beforeID != \"\" {\n\t\tv.Set(\"before\", beforeID)\n\t}\n\tif aroundID != \"\" {\n\t\tv.Set(\"around\", aroundID)\n\t}\n\tif len(v) > 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointChannelMessages(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelMessage gets a single message by ID from a given channel.\n// channeld  : The ID of a Channel\n// messageID : the ID of a Message\nfunc (s *Session) ChannelMessage(channelID, messageID string, options ...RequestOption) (st *Message, err error) {\n\n\tresponse, err := s.RequestWithBucketID(\"GET\", EndpointChannelMessage(channelID, messageID), nil, EndpointChannelMessage(channelID, \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &st)\n\treturn\n}\n\n// ChannelMessageSend sends a message to the given channel.\n// channelID : The ID of a Channel.\n// content   : The message to send.\nfunc (s *Session) ChannelMessageSend(channelID string, content string, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{\n\t\tContent: content,\n\t}, options...)\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\n// ChannelMessageSendComplex sends a message to the given channel.\n// channelID : The ID of a Channel.\n// data      : The message struct to send.\nfunc (s *Session) ChannelMessageSendComplex(channelID string, data *MessageSend, options ...RequestOption) (st *Message, err error) {\n\t// TODO: Remove this when compatibility is not required.\n\tif data.Embed != nil {\n\t\tif data.Embeds == nil {\n\t\t\tdata.Embeds = []*MessageEmbed{data.Embed}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"cannot specify both Embed and Embeds\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor _, embed := range data.Embeds {\n\t\tif embed.Type == \"\" {\n\t\t\tembed.Type = \"rich\"\n\t\t}\n\t}\n\tendpoint := EndpointChannelMessages(channelID)\n\n\t// TODO: Remove this when compatibility is not required.\n\tfiles := data.Files\n\tif data.File != nil {\n\t\tif files == nil {\n\t\t\tfiles = []*File{data.File}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"cannot specify both File and Files\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif data.StickerIDs != nil {\n\t\tif len(data.StickerIDs) > 3 {\n\t\t\terr = fmt.Errorf(\"cannot send more than 3 stickers\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar response []byte\n\tif len(files) > 0 {\n\t\tcontentType, body, encodeErr := MultipartBodyWithJSON(data, files)\n\t\tif encodeErr != nil {\n\t\t\treturn st, encodeErr\n\t\t}\n\t\tresponse, err = s.request(\"POST\", endpoint, contentType, body, endpoint, 0, options...)\n\t} else {\n\t\tresponse, err = s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &st)\n\treturn\n}\n\n// ChannelMessageSendTTS sends a message to the given channel with Text to Speech.\n// channelID : The ID of a Channel.\n// content   : The message to send.\nfunc (s *Session) ChannelMessageSendTTS(channelID string, content string, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{\n\t\tContent: content,\n\t\tTTS:     true,\n\t}, options...)\n}\n\n// ChannelMessageSendEmbed sends a message to the given channel with embedded data.\n// channelID : The ID of a Channel.\n// embed     : The embed data to send.\nfunc (s *Session) ChannelMessageSendEmbed(channelID string, embed *MessageEmbed, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendEmbeds(channelID, []*MessageEmbed{embed}, options...)\n}\n\n// ChannelMessageSendEmbeds sends a message to the given channel with multiple embedded data.\n// channelID : The ID of a Channel.\n// embeds    : The embeds data to send.\nfunc (s *Session) ChannelMessageSendEmbeds(channelID string, embeds []*MessageEmbed, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{\n\t\tEmbeds: embeds,\n\t}, options...)\n}\n\n// ChannelMessageSendReply sends a message to the given channel with reference data.\n// channelID : The ID of a Channel.\n// content   : The message to send.\n// reference : The message reference to send.\nfunc (s *Session) ChannelMessageSendReply(channelID string, content string, reference *MessageReference, options ...RequestOption) (*Message, error) {\n\tif reference == nil {\n\t\treturn nil, fmt.Errorf(\"reply attempted with nil message reference\")\n\t}\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{\n\t\tContent:   content,\n\t\tReference: reference,\n\t}, options...)\n}\n\n// ChannelMessageSendEmbedReply sends a message to the given channel with reference data and embedded data.\n// channelID : The ID of a Channel.\n// embed   : The embed data to send.\n// reference : The message reference to send.\nfunc (s *Session) ChannelMessageSendEmbedReply(channelID string, embed *MessageEmbed, reference *MessageReference, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendEmbedsReply(channelID, []*MessageEmbed{embed}, reference, options...)\n}\n\n// ChannelMessageSendEmbedsReply sends a message to the given channel with reference data and multiple embedded data.\n// channelID : The ID of a Channel.\n// embeds    : The embeds data to send.\n// reference : The message reference to send.\nfunc (s *Session) ChannelMessageSendEmbedsReply(channelID string, embeds []*MessageEmbed, reference *MessageReference, options ...RequestOption) (*Message, error) {\n\tif reference == nil {\n\t\treturn nil, fmt.Errorf(\"reply attempted with nil message reference\")\n\t}\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{\n\t\tEmbeds:    embeds,\n\t\tReference: reference,\n\t}, options...)\n}\n\n// ChannelMessageEdit edits an existing message, replacing it entirely with\n// the given content.\n// channelID  : The ID of a Channel\n// messageID  : The ID of a Message\n// content    : The contents of the message\nfunc (s *Session) ChannelMessageEdit(channelID, messageID, content string, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageEditComplex(NewMessageEdit(channelID, messageID).SetContent(content), options...)\n}\n\n// ChannelMessageEditComplex edits an existing message, replacing it entirely with\n// the given MessageEdit struct\nfunc (s *Session) ChannelMessageEditComplex(m *MessageEdit, options ...RequestOption) (st *Message, err error) {\n\t// TODO: Remove this when compatibility is not required.\n\tif m.Embed != nil {\n\t\tif m.Embeds == nil {\n\t\t\tm.Embeds = &[]*MessageEmbed{m.Embed}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"cannot specify both Embed and Embeds\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif m.Embeds != nil {\n\t\tfor _, embed := range *m.Embeds {\n\t\t\tif embed.Type == \"\" {\n\t\t\t\tembed.Type = \"rich\"\n\t\t\t}\n\t\t}\n\t}\n\n\tendpoint := EndpointChannelMessage(m.Channel, m.ID)\n\n\tvar response []byte\n\tif len(m.Files) > 0 {\n\t\tcontentType, body, encodeErr := MultipartBodyWithJSON(m, m.Files)\n\t\tif encodeErr != nil {\n\t\t\treturn st, encodeErr\n\t\t}\n\t\tresponse, err = s.request(\"PATCH\", endpoint, contentType, body, EndpointChannelMessage(m.Channel, \"\"), 0, options...)\n\t} else {\n\t\tresponse, err = s.RequestWithBucketID(\"PATCH\", endpoint, m, EndpointChannelMessage(m.Channel, \"\"), options...)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &st)\n\treturn\n}\n\n// ChannelMessageEditEmbed edits an existing message with embedded data.\n// channelID : The ID of a Channel\n// messageID : The ID of a Message\n// embed     : The embed data to send\nfunc (s *Session) ChannelMessageEditEmbed(channelID, messageID string, embed *MessageEmbed, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageEditEmbeds(channelID, messageID, []*MessageEmbed{embed}, options...)\n}\n\n// ChannelMessageEditEmbeds edits an existing message with multiple embedded data.\n// channelID : The ID of a Channel\n// messageID : The ID of a Message\n// embeds    : The embeds data to send\nfunc (s *Session) ChannelMessageEditEmbeds(channelID, messageID string, embeds []*MessageEmbed, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageEditComplex(NewMessageEdit(channelID, messageID).SetEmbeds(embeds), options...)\n}\n\n// ChannelMessageDelete deletes a message from the Channel.\nfunc (s *Session) ChannelMessageDelete(channelID, messageID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointChannelMessage(channelID, messageID), nil, EndpointChannelMessage(channelID, \"\"), options...)\n\treturn\n}\n\n// ChannelMessagesBulkDelete bulk deletes the messages from the channel for the provided messageIDs.\n// If only one messageID is in the slice call channelMessageDelete function.\n// If the slice is empty do nothing.\n// channelID : The ID of the channel for the messages to delete.\n// messages  : The IDs of the messages to be deleted. A slice of string IDs. A maximum of 100 messages.\nfunc (s *Session) ChannelMessagesBulkDelete(channelID string, messages []string, options ...RequestOption) (err error) {\n\n\tif len(messages) == 0 {\n\t\treturn\n\t}\n\n\tif len(messages) == 1 {\n\t\terr = s.ChannelMessageDelete(channelID, messages[0], options...)\n\t\treturn\n\t}\n\n\tif len(messages) > 100 {\n\t\tmessages = messages[:100]\n\t}\n\n\tdata := struct {\n\t\tMessages []string `json:\"messages\"`\n\t}{messages}\n\n\t_, err = s.RequestWithBucketID(\"POST\", EndpointChannelMessagesBulkDelete(channelID), data, EndpointChannelMessagesBulkDelete(channelID), options...)\n\treturn\n}\n\n// ChannelMessagePin pins a message within a given channel.\n// channelID: The ID of a channel.\n// messageID: The ID of a message.\nfunc (s *Session) ChannelMessagePin(channelID, messageID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"PUT\", EndpointChannelMessagePin(channelID, messageID), nil, EndpointChannelMessagePin(channelID, \"\"), options...)\n\treturn\n}\n\n// ChannelMessageUnpin unpins a message within a given channel.\n// channelID: The ID of a channel.\n// messageID: The ID of a message.\nfunc (s *Session) ChannelMessageUnpin(channelID, messageID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointChannelMessagePin(channelID, messageID), nil, EndpointChannelMessagePin(channelID, \"\"), options...)\n\treturn\n}\n\n// ChannelMessagesPinned returns an array of Message structures for pinned messages\n// within a given channel\n// channelID : The ID of a Channel.\nfunc (s *Session) ChannelMessagesPinned(channelID string, options ...RequestOption) (st []*Message, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointChannelMessagesPins(channelID), nil, EndpointChannelMessagesPins(channelID), options...)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelFileSend sends a file to the given channel.\n// channelID : The ID of a Channel.\n// name: The name of the file.\n// io.Reader : A reader for the file contents.\nfunc (s *Session) ChannelFileSend(channelID, name string, r io.Reader, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{File: &File{Name: name, Reader: r}}, options...)\n}\n\n// ChannelFileSendWithMessage sends a file to the given channel with an message.\n// DEPRECATED. Use ChannelMessageSendComplex instead.\n// channelID : The ID of a Channel.\n// content: Optional Message content.\n// name: The name of the file.\n// io.Reader : A reader for the file contents.\nfunc (s *Session) ChannelFileSendWithMessage(channelID, content string, name string, r io.Reader, options ...RequestOption) (*Message, error) {\n\treturn s.ChannelMessageSendComplex(channelID, &MessageSend{File: &File{Name: name, Reader: r}, Content: content}, options...)\n}\n\n// ChannelInvites returns an array of Invite structures for the given channel\n// channelID   : The ID of a Channel\nfunc (s *Session) ChannelInvites(channelID string, options ...RequestOption) (st []*Invite, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointChannelInvites(channelID), nil, EndpointChannelInvites(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelInviteCreate creates a new invite for the given channel.\n// channelID   : The ID of a Channel\n// i           : An Invite struct with the values MaxAge, MaxUses and Temporary defined.\nfunc (s *Session) ChannelInviteCreate(channelID string, i Invite, options ...RequestOption) (st *Invite, err error) {\n\n\tdata := struct {\n\t\tMaxAge    int  `json:\"max_age\"`\n\t\tMaxUses   int  `json:\"max_uses\"`\n\t\tTemporary bool `json:\"temporary\"`\n\t\tUnique    bool `json:\"unique\"`\n\t}{i.MaxAge, i.MaxUses, i.Temporary, i.Unique}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointChannelInvites(channelID), data, EndpointChannelInvites(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelPermissionSet creates a Permission Override for the given channel.\n// NOTE: This func name may changed.  Using Set instead of Create because\n// you can both create a new override or update an override with this function.\nfunc (s *Session) ChannelPermissionSet(channelID, targetID string, targetType PermissionOverwriteType, allow, deny int64, options ...RequestOption) (err error) {\n\n\tdata := struct {\n\t\tID    string                  `json:\"id\"`\n\t\tType  PermissionOverwriteType `json:\"type\"`\n\t\tAllow int64                   `json:\"allow,string\"`\n\t\tDeny  int64                   `json:\"deny,string\"`\n\t}{targetID, targetType, allow, deny}\n\n\t_, err = s.RequestWithBucketID(\"PUT\", EndpointChannelPermission(channelID, targetID), data, EndpointChannelPermission(channelID, \"\"), options...)\n\treturn\n}\n\n// ChannelPermissionDelete deletes a specific permission override for the given channel.\n// NOTE: Name of this func may change.\nfunc (s *Session) ChannelPermissionDelete(channelID, targetID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointChannelPermission(channelID, targetID), nil, EndpointChannelPermission(channelID, \"\"), options...)\n\treturn\n}\n\n// ChannelMessageCrosspost cross posts a message in a news channel to followers\n// of the channel\n// channelID   : The ID of a Channel\n// messageID   : The ID of a Message\nfunc (s *Session) ChannelMessageCrosspost(channelID, messageID string, options ...RequestOption) (st *Message, err error) {\n\n\tendpoint := EndpointChannelMessageCrosspost(channelID, messageID)\n\n\tbody, err := s.RequestWithBucketID(\"POST\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ChannelNewsFollow follows a news channel in the targetID\n// channelID   : The ID of a News Channel\n// targetID    : The ID of a Channel where the News Channel should post to\nfunc (s *Session) ChannelNewsFollow(channelID, targetID string, options ...RequestOption) (st *ChannelFollow, err error) {\n\n\tendpoint := EndpointChannelFollow(channelID)\n\n\tdata := struct {\n\t\tWebhookChannelID string `json:\"webhook_channel_id\"`\n\t}{targetID}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Invites\n// ------------------------------------------------------------------------------------------------\n\n// Invite returns an Invite structure of the given invite\n// inviteID : The invite code\nfunc (s *Session) Invite(inviteID string, options ...RequestOption) (st *Invite, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointInvite(inviteID), nil, EndpointInvite(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// InviteWithCounts returns an Invite structure of the given invite including approximate member counts\n// inviteID : The invite code\nfunc (s *Session) InviteWithCounts(inviteID string, options ...RequestOption) (st *Invite, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointInvite(inviteID)+\"?with_counts=true\", nil, EndpointInvite(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// InviteComplex returns an Invite structure of the given invite including specified fields.\n// inviteID                  : The invite code\n// guildScheduledEventID     : If specified, includes specified guild scheduled event.\n// withCounts                : Whether to include approximate member counts or not\n// withExpiration            : Whether to include expiration time or not\nfunc (s *Session) InviteComplex(inviteID, guildScheduledEventID string, withCounts, withExpiration bool, options ...RequestOption) (st *Invite, err error) {\n\tendpoint := EndpointInvite(inviteID)\n\tv := url.Values{}\n\tif guildScheduledEventID != \"\" {\n\t\tv.Set(\"guild_scheduled_event_id\", guildScheduledEventID)\n\t}\n\tif withCounts {\n\t\tv.Set(\"with_counts\", \"true\")\n\t}\n\tif withExpiration {\n\t\tv.Set(\"with_expiration\", \"true\")\n\t}\n\n\tif len(v) != 0 {\n\t\tendpoint += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint, nil, EndpointInvite(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// InviteDelete deletes an existing invite\n// inviteID   : the code of an invite\nfunc (s *Session) InviteDelete(inviteID string, options ...RequestOption) (st *Invite, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"DELETE\", EndpointInvite(inviteID), nil, EndpointInvite(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// InviteAccept accepts an Invite to a Guild or Channel\n// inviteID : The invite code\nfunc (s *Session) InviteAccept(inviteID string, options ...RequestOption) (st *Invite, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointInvite(inviteID), nil, EndpointInvite(\"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Voice\n// ------------------------------------------------------------------------------------------------\n\n// VoiceRegions returns the voice server regions\nfunc (s *Session) VoiceRegions(options ...RequestOption) (st []*VoiceRegion, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointVoiceRegions, nil, EndpointVoiceRegions, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to Discord Websockets\n// ------------------------------------------------------------------------------------------------\n\n// Gateway returns the websocket Gateway address\nfunc (s *Session) Gateway(options ...RequestOption) (gateway string, err error) {\n\n\tresponse, err := s.RequestWithBucketID(\"GET\", EndpointGateway, nil, EndpointGateway, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\ttemp := struct {\n\t\tURL string `json:\"url\"`\n\t}{}\n\n\terr = unmarshal(response, &temp)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tgateway = temp.URL\n\n\t// Ensure the gateway always has a trailing slash.\n\t// MacOS will fail to connect if we add query params without a trailing slash on the base domain.\n\tif !strings.HasSuffix(gateway, \"/\") {\n\t\tgateway += \"/\"\n\t}\n\n\treturn\n}\n\n// GatewayBot returns the websocket Gateway address and the recommended number of shards\nfunc (s *Session) GatewayBot(options ...RequestOption) (st *GatewayBotResponse, err error) {\n\n\tresponse, err := s.RequestWithBucketID(\"GET\", EndpointGatewayBot, nil, EndpointGatewayBot, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &st)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Ensure the gateway always has a trailing slash.\n\t// MacOS will fail to connect if we add query params without a trailing slash on the base domain.\n\tif !strings.HasSuffix(st.URL, \"/\") {\n\t\tst.URL += \"/\"\n\t}\n\n\treturn\n}\n\n// Functions specific to Webhooks\n\n// WebhookCreate returns a new Webhook.\n// channelID: The ID of a Channel.\n// name     : The name of the webhook.\n// avatar   : The avatar of the webhook.\nfunc (s *Session) WebhookCreate(channelID, name, avatar string, options ...RequestOption) (st *Webhook, err error) {\n\n\tdata := struct {\n\t\tName   string `json:\"name\"`\n\t\tAvatar string `json:\"avatar,omitempty\"`\n\t}{name, avatar}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointChannelWebhooks(channelID), data, EndpointChannelWebhooks(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// ChannelWebhooks returns all webhooks for a given channel.\n// channelID: The ID of a channel.\nfunc (s *Session) ChannelWebhooks(channelID string, options ...RequestOption) (st []*Webhook, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointChannelWebhooks(channelID), nil, EndpointChannelWebhooks(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// GuildWebhooks returns all webhooks for a given guild.\n// guildID: The ID of a Guild.\nfunc (s *Session) GuildWebhooks(guildID string, options ...RequestOption) (st []*Webhook, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointGuildWebhooks(guildID), nil, EndpointGuildWebhooks(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// Webhook returns a webhook for a given ID\n// webhookID: The ID of a webhook.\nfunc (s *Session) Webhook(webhookID string, options ...RequestOption) (st *Webhook, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointWebhook(webhookID), nil, EndpointWebhooks, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// WebhookWithToken returns a webhook for a given ID\n// webhookID: The ID of a webhook.\n// token    : The auth token for the webhook.\nfunc (s *Session) WebhookWithToken(webhookID, token string, options ...RequestOption) (st *Webhook, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointWebhookToken(webhookID, token), nil, EndpointWebhookToken(\"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// WebhookEdit updates an existing Webhook.\n// webhookID: The ID of a webhook.\n// name     : The name of the webhook.\n// avatar   : The avatar of the webhook.\nfunc (s *Session) WebhookEdit(webhookID, name, avatar, channelID string, options ...RequestOption) (st *Webhook, err error) {\n\n\tdata := struct {\n\t\tName      string `json:\"name,omitempty\"`\n\t\tAvatar    string `json:\"avatar,omitempty\"`\n\t\tChannelID string `json:\"channel_id,omitempty\"`\n\t}{name, avatar, channelID}\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointWebhook(webhookID), data, EndpointWebhooks, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// WebhookEditWithToken updates an existing Webhook with an auth token.\n// webhookID: The ID of a webhook.\n// token    : The auth token for the webhook.\n// name     : The name of the webhook.\n// avatar   : The avatar of the webhook.\nfunc (s *Session) WebhookEditWithToken(webhookID, token, name, avatar string, options ...RequestOption) (st *Webhook, err error) {\n\n\tdata := struct {\n\t\tName   string `json:\"name,omitempty\"`\n\t\tAvatar string `json:\"avatar,omitempty\"`\n\t}{name, avatar}\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PATCH\", EndpointWebhookToken(webhookID, token), data, EndpointWebhookToken(\"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\n// WebhookDelete deletes a webhook for a given ID\n// webhookID: The ID of a webhook.\nfunc (s *Session) WebhookDelete(webhookID string, options ...RequestOption) (err error) {\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointWebhook(webhookID), nil, EndpointWebhooks, options...)\n\n\treturn\n}\n\n// WebhookDeleteWithToken deletes a webhook for a given ID with an auth token.\n// webhookID: The ID of a webhook.\n// token    : The auth token for the webhook.\nfunc (s *Session) WebhookDeleteWithToken(webhookID, token string, options ...RequestOption) (st *Webhook, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"DELETE\", EndpointWebhookToken(webhookID, token), nil, EndpointWebhookToken(\"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\n\treturn\n}\n\nfunc (s *Session) webhookExecute(webhookID, token string, wait bool, threadID string, data *WebhookParams, options ...RequestOption) (st *Message, err error) {\n\turi := EndpointWebhookToken(webhookID, token)\n\n\tv := url.Values{}\n\tif wait {\n\t\tv.Set(\"wait\", \"true\")\n\t}\n\n\tif threadID != \"\" {\n\t\tv.Set(\"thread_id\", threadID)\n\t}\n\tif len(v) != 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tvar response []byte\n\tif len(data.Files) > 0 {\n\t\tcontentType, body, encodeErr := MultipartBodyWithJSON(data, data.Files)\n\t\tif encodeErr != nil {\n\t\t\treturn st, encodeErr\n\t\t}\n\n\t\tresponse, err = s.request(\"POST\", uri, contentType, body, uri, 0, options...)\n\t} else {\n\t\tresponse, err = s.RequestWithBucketID(\"POST\", uri, data, uri, options...)\n\t}\n\tif !wait || err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &st)\n\treturn\n}\n\n// WebhookExecute executes a webhook.\n// webhookID: The ID of a webhook.\n// token    : The auth token for the webhook\n// wait     : Waits for server confirmation of message send and ensures that the return struct is populated (it is nil otherwise)\nfunc (s *Session) WebhookExecute(webhookID, token string, wait bool, data *WebhookParams, options ...RequestOption) (st *Message, err error) {\n\treturn s.webhookExecute(webhookID, token, wait, \"\", data, options...)\n}\n\n// WebhookThreadExecute executes a webhook in a thread.\n// webhookID: The ID of a webhook.\n// token    : The auth token for the webhook\n// wait     : Waits for server confirmation of message send and ensures that the return struct is populated (it is nil otherwise)\n// threadID :\tSends a message to the specified thread within a webhook's channel. The thread will automatically be unarchived.\nfunc (s *Session) WebhookThreadExecute(webhookID, token string, wait bool, threadID string, data *WebhookParams, options ...RequestOption) (st *Message, err error) {\n\treturn s.webhookExecute(webhookID, token, wait, threadID, data, options...)\n}\n\n// WebhookMessage gets a webhook message.\n// webhookID : The ID of a webhook\n// token     : The auth token for the webhook\n// messageID : The ID of message to get\nfunc (s *Session) WebhookMessage(webhookID, token, messageID string, options ...RequestOption) (message *Message, err error) {\n\turi := EndpointWebhookMessage(webhookID, token, messageID)\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointWebhookToken(\"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = Unmarshal(body, &message)\n\n\treturn\n}\n\n// WebhookMessageEdit edits a webhook message and returns a new one.\n// webhookID : The ID of a webhook\n// token     : The auth token for the webhook\n// messageID : The ID of message to edit\nfunc (s *Session) WebhookMessageEdit(webhookID, token, messageID string, data *WebhookEdit, options ...RequestOption) (st *Message, err error) {\n\turi := EndpointWebhookMessage(webhookID, token, messageID)\n\n\tvar response []byte\n\tif len(data.Files) > 0 {\n\t\tcontentType, body, err := MultipartBodyWithJSON(data, data.Files)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresponse, err = s.request(\"PATCH\", uri, contentType, body, uri, 0, options...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tresponse, err = s.RequestWithBucketID(\"PATCH\", uri, data, EndpointWebhookToken(\"\", \"\"), options...)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = unmarshal(response, &st)\n\treturn\n}\n\n// WebhookMessageDelete deletes a webhook message.\n// webhookID : The ID of a webhook\n// token     : The auth token for the webhook\n// messageID : The ID of a message to edit\nfunc (s *Session) WebhookMessageDelete(webhookID, token, messageID string, options ...RequestOption) (err error) {\n\turi := EndpointWebhookMessage(webhookID, token, messageID)\n\n\t_, err = s.RequestWithBucketID(\"DELETE\", uri, nil, EndpointWebhookToken(\"\", \"\"), options...)\n\treturn\n}\n\n// MessageReactionAdd creates an emoji reaction to a message.\n// channelID : The channel ID.\n// messageID : The message ID.\n// emojiID   : Either the unicode emoji for the reaction, or a guild emoji identifier in name:id format (e.g. \"hello:1234567654321\")\nfunc (s *Session) MessageReactionAdd(channelID, messageID, emojiID string, options ...RequestOption) error {\n\n\t// emoji such as  #⃣ need to have # escaped\n\temojiID = strings.Replace(emojiID, \"#\", \"%23\", -1)\n\t_, err := s.RequestWithBucketID(\"PUT\", EndpointMessageReaction(channelID, messageID, emojiID, \"@me\"), nil, EndpointMessageReaction(channelID, \"\", \"\", \"\"), options...)\n\n\treturn err\n}\n\n// MessageReactionRemove deletes an emoji reaction to a message.\n// channelID : The channel ID.\n// messageID : The message ID.\n// emojiID   : Either the unicode emoji for the reaction, or a guild emoji identifier.\n// userID\t : @me or ID of the user to delete the reaction for.\nfunc (s *Session) MessageReactionRemove(channelID, messageID, emojiID, userID string, options ...RequestOption) error {\n\n\t// emoji such as  #⃣ need to have # escaped\n\temojiID = strings.Replace(emojiID, \"#\", \"%23\", -1)\n\t_, err := s.RequestWithBucketID(\"DELETE\", EndpointMessageReaction(channelID, messageID, emojiID, userID), nil, EndpointMessageReaction(channelID, \"\", \"\", \"\"), options...)\n\n\treturn err\n}\n\n// MessageReactionsRemoveAll deletes all reactions from a message\n// channelID : The channel ID\n// messageID : The message ID.\nfunc (s *Session) MessageReactionsRemoveAll(channelID, messageID string, options ...RequestOption) error {\n\n\t_, err := s.RequestWithBucketID(\"DELETE\", EndpointMessageReactionsAll(channelID, messageID), nil, EndpointMessageReactionsAll(channelID, messageID), options...)\n\n\treturn err\n}\n\n// MessageReactionsRemoveEmoji deletes all reactions of a certain emoji from a message\n// channelID : The channel ID\n// messageID : The message ID\n// emojiID   : The emoji ID\nfunc (s *Session) MessageReactionsRemoveEmoji(channelID, messageID, emojiID string, options ...RequestOption) error {\n\n\t// emoji such as  #⃣ need to have # escaped\n\temojiID = strings.Replace(emojiID, \"#\", \"%23\", -1)\n\t_, err := s.RequestWithBucketID(\"DELETE\", EndpointMessageReactions(channelID, messageID, emojiID), nil, EndpointMessageReactions(channelID, messageID, emojiID), options...)\n\n\treturn err\n}\n\n// MessageReactions gets all the users reactions for a specific emoji.\n// channelID : The channel ID.\n// messageID : The message ID.\n// emojiID   : Either the unicode emoji for the reaction, or a guild emoji identifier.\n// limit    : max number of users to return (max 100)\n// beforeID  : If provided all reactions returned will be before given ID.\n// afterID   : If provided all reactions returned will be after given ID.\nfunc (s *Session) MessageReactions(channelID, messageID, emojiID string, limit int, beforeID, afterID string, options ...RequestOption) (st []*User, err error) {\n\t// emoji such as  #⃣ need to have # escaped\n\temojiID = strings.Replace(emojiID, \"#\", \"%23\", -1)\n\turi := EndpointMessageReactions(channelID, messageID, emojiID)\n\n\tv := url.Values{}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tif afterID != \"\" {\n\t\tv.Set(\"after\", afterID)\n\t}\n\tif beforeID != \"\" {\n\t\tv.Set(\"before\", beforeID)\n\t}\n\n\tif len(v) > 0 {\n\t\turi += \"?\" + v.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointMessageReaction(channelID, \"\", \"\", \"\"), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to threads\n// ------------------------------------------------------------------------------------------------\n\n// MessageThreadStartComplex creates a new thread from an existing message.\n// channelID : Channel to create thread in\n// messageID : Message to start thread from\n// data : Parameters of the thread\nfunc (s *Session) MessageThreadStartComplex(channelID, messageID string, data *ThreadStart, options ...RequestOption) (ch *Channel, err error) {\n\tendpoint := EndpointChannelMessageThread(channelID, messageID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &ch)\n\treturn\n}\n\n// MessageThreadStart creates a new thread from an existing message.\n// channelID       : Channel to create thread in\n// messageID       : Message to start thread from\n// name            : Name of the thread\n// archiveDuration : Auto archive duration (in minutes)\nfunc (s *Session) MessageThreadStart(channelID, messageID string, name string, archiveDuration int, options ...RequestOption) (ch *Channel, err error) {\n\treturn s.MessageThreadStartComplex(channelID, messageID, &ThreadStart{\n\t\tName:                name,\n\t\tAutoArchiveDuration: archiveDuration,\n\t}, options...)\n}\n\n// ThreadStartComplex creates a new thread.\n// channelID : Channel to create thread in\n// data : Parameters of the thread\nfunc (s *Session) ThreadStartComplex(channelID string, data *ThreadStart, options ...RequestOption) (ch *Channel, err error) {\n\tendpoint := EndpointChannelThreads(channelID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &ch)\n\treturn\n}\n\n// ThreadStart creates a new thread.\n// channelID       : Channel to create thread in\n// name            : Name of the thread\n// archiveDuration : Auto archive duration (in minutes)\nfunc (s *Session) ThreadStart(channelID, name string, typ ChannelType, archiveDuration int, options ...RequestOption) (ch *Channel, err error) {\n\treturn s.ThreadStartComplex(channelID, &ThreadStart{\n\t\tName:                name,\n\t\tType:                typ,\n\t\tAutoArchiveDuration: archiveDuration,\n\t}, options...)\n}\n\n// ForumThreadStartComplex starts a new thread (creates a post) in a forum channel.\n// channelID   : Channel to create thread in.\n// threadData  : Parameters of the thread.\n// messageData : Parameters of the starting message.\nfunc (s *Session) ForumThreadStartComplex(channelID string, threadData *ThreadStart, messageData *MessageSend, options ...RequestOption) (th *Channel, err error) {\n\tendpoint := EndpointChannelThreads(channelID)\n\n\t// TODO: Remove this when compatibility is not required.\n\tif messageData.Embed != nil {\n\t\tif messageData.Embeds == nil {\n\t\t\tmessageData.Embeds = []*MessageEmbed{messageData.Embed}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"cannot specify both Embed and Embeds\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor _, embed := range messageData.Embeds {\n\t\tif embed.Type == \"\" {\n\t\t\tembed.Type = \"rich\"\n\t\t}\n\t}\n\n\t// TODO: Remove this when compatibility is not required.\n\tfiles := messageData.Files\n\tif messageData.File != nil {\n\t\tif files == nil {\n\t\t\tfiles = []*File{messageData.File}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"cannot specify both File and Files\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tdata := struct {\n\t\t*ThreadStart\n\t\tMessage *MessageSend `json:\"message\"`\n\t}{ThreadStart: threadData, Message: messageData}\n\n\tvar response []byte\n\tif len(files) > 0 {\n\t\tcontentType, body, encodeErr := MultipartBodyWithJSON(data, files)\n\t\tif encodeErr != nil {\n\t\t\treturn th, encodeErr\n\t\t}\n\n\t\tresponse, err = s.request(\"POST\", endpoint, contentType, body, endpoint, 0, options...)\n\t} else {\n\t\tresponse, err = s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(response, &th)\n\treturn\n}\n\n// ForumThreadStart starts a new thread (post) in a forum channel.\n// channelID       : Channel to create thread in.\n// name            : Name of the thread.\n// archiveDuration : Auto archive duration.\n// content         : Content of the starting message.\nfunc (s *Session) ForumThreadStart(channelID, name string, archiveDuration int, content string, options ...RequestOption) (th *Channel, err error) {\n\treturn s.ForumThreadStartComplex(channelID, &ThreadStart{\n\t\tName:                name,\n\t\tAutoArchiveDuration: archiveDuration,\n\t}, &MessageSend{Content: content}, options...)\n}\n\n// ForumThreadStartEmbed starts a new thread (post) in a forum channel.\n// channelID       : Channel to create thread in.\n// name            : Name of the thread.\n// archiveDuration : Auto archive duration.\n// embed           : Embed data of the starting message.\nfunc (s *Session) ForumThreadStartEmbed(channelID, name string, archiveDuration int, embed *MessageEmbed, options ...RequestOption) (th *Channel, err error) {\n\treturn s.ForumThreadStartComplex(channelID, &ThreadStart{\n\t\tName:                name,\n\t\tAutoArchiveDuration: archiveDuration,\n\t}, &MessageSend{Embeds: []*MessageEmbed{embed}}, options...)\n}\n\n// ForumThreadStartEmbeds starts a new thread (post) in a forum channel.\n// channelID       : Channel to create thread in.\n// name            : Name of the thread.\n// archiveDuration : Auto archive duration.\n// embeds          : Embeds data of the starting message.\nfunc (s *Session) ForumThreadStartEmbeds(channelID, name string, archiveDuration int, embeds []*MessageEmbed, options ...RequestOption) (th *Channel, err error) {\n\treturn s.ForumThreadStartComplex(channelID, &ThreadStart{\n\t\tName:                name,\n\t\tAutoArchiveDuration: archiveDuration,\n\t}, &MessageSend{Embeds: embeds}, options...)\n}\n\n// ThreadJoin adds current user to a thread\nfunc (s *Session) ThreadJoin(id string, options ...RequestOption) error {\n\tendpoint := EndpointThreadMember(id, \"@me\")\n\t_, err := s.RequestWithBucketID(\"PUT\", endpoint, nil, endpoint, options...)\n\treturn err\n}\n\n// ThreadLeave removes current user to a thread\nfunc (s *Session) ThreadLeave(id string, options ...RequestOption) error {\n\tendpoint := EndpointThreadMember(id, \"@me\")\n\t_, err := s.RequestWithBucketID(\"DELETE\", endpoint, nil, endpoint, options...)\n\treturn err\n}\n\n// ThreadMemberAdd adds another member to a thread\nfunc (s *Session) ThreadMemberAdd(threadID, memberID string, options ...RequestOption) error {\n\tendpoint := EndpointThreadMember(threadID, memberID)\n\t_, err := s.RequestWithBucketID(\"PUT\", endpoint, nil, endpoint, options...)\n\treturn err\n}\n\n// ThreadMemberRemove removes another member from a thread\nfunc (s *Session) ThreadMemberRemove(threadID, memberID string, options ...RequestOption) error {\n\tendpoint := EndpointThreadMember(threadID, memberID)\n\t_, err := s.RequestWithBucketID(\"DELETE\", endpoint, nil, endpoint, options...)\n\treturn err\n}\n\n// ThreadMember returns thread member object for the specified member of a thread.\n// withMember : Whether to include a guild member object.\nfunc (s *Session) ThreadMember(threadID, memberID string, withMember bool, options ...RequestOption) (member *ThreadMember, err error) {\n\turi := EndpointThreadMember(threadID, memberID)\n\n\tqueryParams := url.Values{}\n\tif withMember {\n\t\tqueryParams.Set(\"with_member\", \"true\")\n\t}\n\n\tif len(queryParams) > 0 {\n\t\turi += \"?\" + queryParams.Encode()\n\t}\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", uri, nil, uri, options...)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &member)\n\treturn\n}\n\n// ThreadMembers returns all members of specified thread.\n// limit      : Max number of thread members to return (1-100). Defaults to 100.\n// afterID    : Get thread members after this user ID.\n// withMember : Whether to include a guild member object for each thread member.\nfunc (s *Session) ThreadMembers(threadID string, limit int, withMember bool, afterID string, options ...RequestOption) (members []*ThreadMember, err error) {\n\turi := EndpointThreadMembers(threadID)\n\n\tqueryParams := url.Values{}\n\tif withMember {\n\t\tqueryParams.Set(\"with_member\", \"true\")\n\t}\n\tif limit > 0 {\n\t\tqueryParams.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif afterID != \"\" {\n\t\tqueryParams.Set(\"after\", afterID)\n\t}\n\n\tif len(queryParams) > 0 {\n\t\turi += \"?\" + queryParams.Encode()\n\t}\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", uri, nil, uri, options...)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &members)\n\treturn\n}\n\n// ThreadsActive returns all active threads for specified channel.\nfunc (s *Session) ThreadsActive(channelID string, options ...RequestOption) (threads *ThreadsList, err error) {\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", EndpointChannelActiveThreads(channelID), nil, EndpointChannelActiveThreads(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &threads)\n\treturn\n}\n\n// GuildThreadsActive returns all active threads for specified guild.\nfunc (s *Session) GuildThreadsActive(guildID string, options ...RequestOption) (threads *ThreadsList, err error) {\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", EndpointGuildActiveThreads(guildID), nil, EndpointGuildActiveThreads(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &threads)\n\treturn\n}\n\n// ThreadsArchived returns archived threads for specified channel.\n// before : If specified returns only threads before the timestamp\n// limit  : Optional maximum amount of threads to return.\nfunc (s *Session) ThreadsArchived(channelID string, before *time.Time, limit int, options ...RequestOption) (threads *ThreadsList, err error) {\n\tendpoint := EndpointChannelPublicArchivedThreads(channelID)\n\tv := url.Values{}\n\tif before != nil {\n\t\tv.Set(\"before\", before.Format(time.RFC3339))\n\t}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tif len(v) > 0 {\n\t\tendpoint += \"?\" + v.Encode()\n\t}\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &threads)\n\treturn\n}\n\n// ThreadsPrivateArchived returns archived private threads for specified channel.\n// before : If specified returns only threads before the timestamp\n// limit  : Optional maximum amount of threads to return.\nfunc (s *Session) ThreadsPrivateArchived(channelID string, before *time.Time, limit int, options ...RequestOption) (threads *ThreadsList, err error) {\n\tendpoint := EndpointChannelPrivateArchivedThreads(channelID)\n\tv := url.Values{}\n\tif before != nil {\n\t\tv.Set(\"before\", before.Format(time.RFC3339))\n\t}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tif len(v) > 0 {\n\t\tendpoint += \"?\" + v.Encode()\n\t}\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &threads)\n\treturn\n}\n\n// ThreadsPrivateJoinedArchived returns archived joined private threads for specified channel.\n// before : If specified returns only threads before the timestamp\n// limit  : Optional maximum amount of threads to return.\nfunc (s *Session) ThreadsPrivateJoinedArchived(channelID string, before *time.Time, limit int, options ...RequestOption) (threads *ThreadsList, err error) {\n\tendpoint := EndpointChannelJoinedPrivateArchivedThreads(channelID)\n\tv := url.Values{}\n\tif before != nil {\n\t\tv.Set(\"before\", before.Format(time.RFC3339))\n\t}\n\n\tif limit > 0 {\n\t\tv.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tif len(v) > 0 {\n\t\tendpoint += \"?\" + v.Encode()\n\t}\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &threads)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to application (slash) commands\n// ------------------------------------------------------------------------------------------------\n\n// ApplicationCommandCreate creates a global application command and returns it.\n// appID       : The application ID.\n// guildID     : Guild ID to create guild-specific application command. If empty - creates global application command.\n// cmd         : New application command data.\nfunc (s *Session) ApplicationCommandCreate(appID string, guildID string, cmd *ApplicationCommand, options ...RequestOption) (ccmd *ApplicationCommand, err error) {\n\tendpoint := EndpointApplicationGlobalCommands(appID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommands(appID, guildID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"POST\", endpoint, *cmd, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &ccmd)\n\n\treturn\n}\n\n// ApplicationCommandEdit edits application command and returns new command data.\n// appID       : The application ID.\n// cmdID       : Application command ID to edit.\n// guildID     : Guild ID to edit guild-specific application command. If empty - edits global application command.\n// cmd         : Updated application command data.\nfunc (s *Session) ApplicationCommandEdit(appID, guildID, cmdID string, cmd *ApplicationCommand, options ...RequestOption) (updated *ApplicationCommand, err error) {\n\tendpoint := EndpointApplicationGlobalCommand(appID, cmdID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommand(appID, guildID, cmdID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", endpoint, *cmd, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &updated)\n\n\treturn\n}\n\n// ApplicationCommandBulkOverwrite Creates commands overwriting existing commands. Returns a list of commands.\n// appID    : The application ID.\n// commands : The commands to create.\nfunc (s *Session) ApplicationCommandBulkOverwrite(appID string, guildID string, commands []*ApplicationCommand, options ...RequestOption) (createdCommands []*ApplicationCommand, err error) {\n\tendpoint := EndpointApplicationGlobalCommands(appID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommands(appID, guildID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"PUT\", endpoint, commands, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &createdCommands)\n\n\treturn\n}\n\n// ApplicationCommandDelete deletes application command by ID.\n// appID       : The application ID.\n// cmdID       : Application command ID to delete.\n// guildID     : Guild ID to delete guild-specific application command. If empty - deletes global application command.\nfunc (s *Session) ApplicationCommandDelete(appID, guildID, cmdID string, options ...RequestOption) error {\n\tendpoint := EndpointApplicationGlobalCommand(appID, cmdID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommand(appID, guildID, cmdID)\n\t}\n\n\t_, err := s.RequestWithBucketID(\"DELETE\", endpoint, nil, endpoint, options...)\n\n\treturn err\n}\n\n// ApplicationCommand retrieves an application command by given ID.\n// appID       : The application ID.\n// cmdID       : Application command ID.\n// guildID     : Guild ID to retrieve guild-specific application command. If empty - retrieves global application command.\nfunc (s *Session) ApplicationCommand(appID, guildID, cmdID string, options ...RequestOption) (cmd *ApplicationCommand, err error) {\n\tendpoint := EndpointApplicationGlobalCommand(appID, cmdID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommand(appID, guildID, cmdID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &cmd)\n\n\treturn\n}\n\n// ApplicationCommands retrieves all commands in application.\n// appID       : The application ID.\n// guildID     : Guild ID to retrieve all guild-specific application commands. If empty - retrieves global application commands.\nfunc (s *Session) ApplicationCommands(appID, guildID string, options ...RequestOption) (cmd []*ApplicationCommand, err error) {\n\tendpoint := EndpointApplicationGlobalCommands(appID)\n\tif guildID != \"\" {\n\t\tendpoint = EndpointApplicationGuildCommands(appID, guildID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint+\"?with_localizations=true\", nil, \"GET \"+endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &cmd)\n\n\treturn\n}\n\n// GuildApplicationCommandsPermissions returns permissions for application commands in a guild.\n// appID       : The application ID\n// guildID     : Guild ID to retrieve application commands permissions for.\nfunc (s *Session) GuildApplicationCommandsPermissions(appID, guildID string, options ...RequestOption) (permissions []*GuildApplicationCommandPermissions, err error) {\n\tendpoint := EndpointApplicationCommandsGuildPermissions(appID, guildID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &permissions)\n\treturn\n}\n\n// ApplicationCommandPermissions returns all permissions of an application command\n// appID       : The Application ID\n// guildID     : The guild ID containing the application command\n// cmdID       : The command ID to retrieve the permissions of\nfunc (s *Session) ApplicationCommandPermissions(appID, guildID, cmdID string, options ...RequestOption) (permissions *GuildApplicationCommandPermissions, err error) {\n\tendpoint := EndpointApplicationCommandPermissions(appID, guildID, cmdID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &permissions)\n\treturn\n}\n\n// ApplicationCommandPermissionsEdit edits the permissions of an application command\n// appID       : The Application ID\n// guildID     : The guild ID containing the application command\n// cmdID       : The command ID to edit the permissions of\n// permissions : An object containing a list of permissions for the application command\n//\n// NOTE: Requires OAuth2 token with applications.commands.permissions.update scope\nfunc (s *Session) ApplicationCommandPermissionsEdit(appID, guildID, cmdID string, permissions *ApplicationCommandPermissionsList, options ...RequestOption) (err error) {\n\tendpoint := EndpointApplicationCommandPermissions(appID, guildID, cmdID)\n\n\t_, err = s.RequestWithBucketID(\"PUT\", endpoint, permissions, endpoint, options...)\n\treturn\n}\n\n// ApplicationCommandPermissionsBatchEdit edits the permissions of a batch of commands\n// appID       : The Application ID\n// guildID     : The guild ID to batch edit commands of\n// permissions : A list of permissions paired with a command ID, guild ID, and application ID per application command\n//\n// NOTE: This endpoint has been disabled with updates to command permissions (Permissions v2). Please use ApplicationCommandPermissionsEdit instead.\nfunc (s *Session) ApplicationCommandPermissionsBatchEdit(appID, guildID string, permissions []*GuildApplicationCommandPermissions, options ...RequestOption) (err error) {\n\tendpoint := EndpointApplicationCommandsGuildPermissions(appID, guildID)\n\n\t_, err = s.RequestWithBucketID(\"PUT\", endpoint, permissions, endpoint, options...)\n\treturn\n}\n\n// InteractionRespond creates the response to an interaction.\n// interaction : Interaction instance.\n// resp        : Response message data.\nfunc (s *Session) InteractionRespond(interaction *Interaction, resp *InteractionResponse, options ...RequestOption) error {\n\tendpoint := EndpointInteractionResponse(interaction.ID, interaction.Token)\n\n\tif resp.Data != nil && len(resp.Data.Files) > 0 {\n\t\tcontentType, body, err := MultipartBodyWithJSON(resp, resp.Data.Files)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = s.request(\"POST\", endpoint, contentType, body, endpoint, 0, options...)\n\t\treturn err\n\t}\n\n\t_, err := s.RequestWithBucketID(\"POST\", endpoint, *resp, endpoint, options...)\n\treturn err\n}\n\n// InteractionResponse gets the response to an interaction.\n// interaction : Interaction instance.\nfunc (s *Session) InteractionResponse(interaction *Interaction, options ...RequestOption) (*Message, error) {\n\treturn s.WebhookMessage(interaction.AppID, interaction.Token, \"@original\", options...)\n}\n\n// InteractionResponseEdit edits the response to an interaction.\n// interaction : Interaction instance.\n// newresp     : Updated response message data.\nfunc (s *Session) InteractionResponseEdit(interaction *Interaction, newresp *WebhookEdit, options ...RequestOption) (*Message, error) {\n\treturn s.WebhookMessageEdit(interaction.AppID, interaction.Token, \"@original\", newresp, options...)\n}\n\n// InteractionResponseDelete deletes the response to an interaction.\n// interaction : Interaction instance.\nfunc (s *Session) InteractionResponseDelete(interaction *Interaction, options ...RequestOption) error {\n\tendpoint := EndpointInteractionResponseActions(interaction.AppID, interaction.Token)\n\n\t_, err := s.RequestWithBucketID(\"DELETE\", endpoint, nil, endpoint, options...)\n\n\treturn err\n}\n\n// FollowupMessageCreate creates the followup message for an interaction.\n// interaction : Interaction instance.\n// wait        : Waits for server confirmation of message send and ensures that the return struct is populated (it is nil otherwise)\n// data        : Data of the message to send.\nfunc (s *Session) FollowupMessageCreate(interaction *Interaction, wait bool, data *WebhookParams, options ...RequestOption) (*Message, error) {\n\treturn s.WebhookExecute(interaction.AppID, interaction.Token, wait, data, options...)\n}\n\n// FollowupMessageEdit edits a followup message of an interaction.\n// interaction : Interaction instance.\n// messageID   : The followup message ID.\n// data        : Data to update the message\nfunc (s *Session) FollowupMessageEdit(interaction *Interaction, messageID string, data *WebhookEdit, options ...RequestOption) (*Message, error) {\n\treturn s.WebhookMessageEdit(interaction.AppID, interaction.Token, messageID, data, options...)\n}\n\n// FollowupMessageDelete deletes a followup message of an interaction.\n// interaction : Interaction instance.\n// messageID   : The followup message ID.\nfunc (s *Session) FollowupMessageDelete(interaction *Interaction, messageID string, options ...RequestOption) error {\n\treturn s.WebhookMessageDelete(interaction.AppID, interaction.Token, messageID, options...)\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to stage instances\n// ------------------------------------------------------------------------------------------------\n\n// StageInstanceCreate creates and returns a new Stage instance associated to a Stage channel.\n// data : Parameters needed to create a stage instance.\n// data : The data of the Stage instance to create\nfunc (s *Session) StageInstanceCreate(data *StageInstanceParams, options ...RequestOption) (si *StageInstance, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointStageInstances, data, EndpointStageInstances, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &si)\n\treturn\n}\n\n// StageInstance will retrieve a Stage instance by ID of the Stage channel.\n// channelID : The ID of the Stage channel\nfunc (s *Session) StageInstance(channelID string, options ...RequestOption) (si *StageInstance, err error) {\n\tbody, err := s.RequestWithBucketID(\"GET\", EndpointStageInstance(channelID), nil, EndpointStageInstance(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &si)\n\treturn\n}\n\n// StageInstanceEdit will edit a Stage instance by ID of the Stage channel.\n// channelID : The ID of the Stage channel\n// data : The data to edit the Stage instance\nfunc (s *Session) StageInstanceEdit(channelID string, data *StageInstanceParams, options ...RequestOption) (si *StageInstance, err error) {\n\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointStageInstance(channelID), data, EndpointStageInstance(channelID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &si)\n\treturn\n}\n\n// StageInstanceDelete will delete a Stage instance by ID of the Stage channel.\n// channelID : The ID of the Stage channel\nfunc (s *Session) StageInstanceDelete(channelID string, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointStageInstance(channelID), nil, EndpointStageInstance(channelID), options...)\n\treturn\n}\n\n// ------------------------------------------------------------------------------------------------\n// Functions specific to guilds scheduled events\n// ------------------------------------------------------------------------------------------------\n\n// GuildScheduledEvents returns an array of GuildScheduledEvent for a guild\n// guildID        : The ID of a Guild\n// userCount      : Whether to include the user count in the response\nfunc (s *Session) GuildScheduledEvents(guildID string, userCount bool, options ...RequestOption) (st []*GuildScheduledEvent, err error) {\n\turi := EndpointGuildScheduledEvents(guildID)\n\tif userCount {\n\t\turi += \"?with_user_count=true\"\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildScheduledEvents(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildScheduledEvent returns a specific GuildScheduledEvent in a guild\n// guildID        : The ID of a Guild\n// eventID        : The ID of the event\n// userCount      : Whether to include the user count in the response\nfunc (s *Session) GuildScheduledEvent(guildID, eventID string, userCount bool, options ...RequestOption) (st *GuildScheduledEvent, err error) {\n\turi := EndpointGuildScheduledEvent(guildID, eventID)\n\tif userCount {\n\t\turi += \"?with_user_count=true\"\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildScheduledEvent(guildID, eventID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildScheduledEventCreate creates a GuildScheduledEvent for a guild and returns it\n// guildID   : The ID of a Guild\n// eventID   : The ID of the event\nfunc (s *Session) GuildScheduledEventCreate(guildID string, event *GuildScheduledEventParams, options ...RequestOption) (st *GuildScheduledEvent, err error) {\n\tbody, err := s.RequestWithBucketID(\"POST\", EndpointGuildScheduledEvents(guildID), event, EndpointGuildScheduledEvents(guildID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildScheduledEventEdit updates a specific event for a guild and returns it.\n// guildID   : The ID of a Guild\n// eventID   : The ID of the event\nfunc (s *Session) GuildScheduledEventEdit(guildID, eventID string, event *GuildScheduledEventParams, options ...RequestOption) (st *GuildScheduledEvent, err error) {\n\tbody, err := s.RequestWithBucketID(\"PATCH\", EndpointGuildScheduledEvent(guildID, eventID), event, EndpointGuildScheduledEvent(guildID, eventID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildScheduledEventDelete deletes a specific GuildScheduledEvent in a guild\n// guildID   : The ID of a Guild\n// eventID   : The ID of the event\nfunc (s *Session) GuildScheduledEventDelete(guildID, eventID string, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointGuildScheduledEvent(guildID, eventID), nil, EndpointGuildScheduledEvent(guildID, eventID), options...)\n\treturn\n}\n\n// GuildScheduledEventUsers returns an array of GuildScheduledEventUser for a particular event in a guild\n// guildID    : The ID of a Guild\n// eventID    : The ID of the event\n// limit      : The maximum number of users to return (Max 100)\n// withMember : Whether to include the member object in the response\n// beforeID   : If is not empty all returned users entries will be before the given ID\n// afterID    : If is not empty all returned users entries will be after the given ID\nfunc (s *Session) GuildScheduledEventUsers(guildID, eventID string, limit int, withMember bool, beforeID, afterID string, options ...RequestOption) (st []*GuildScheduledEventUser, err error) {\n\turi := EndpointGuildScheduledEventUsers(guildID, eventID)\n\n\tqueryParams := url.Values{}\n\tif withMember {\n\t\tqueryParams.Set(\"with_member\", \"true\")\n\t}\n\tif limit > 0 {\n\t\tqueryParams.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\tif beforeID != \"\" {\n\t\tqueryParams.Set(\"before\", beforeID)\n\t}\n\tif afterID != \"\" {\n\t\tqueryParams.Set(\"after\", afterID)\n\t}\n\n\tif len(queryParams) > 0 {\n\t\turi += \"?\" + queryParams.Encode()\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", uri, nil, EndpointGuildScheduledEventUsers(guildID, eventID), options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// GuildOnboarding returns onboarding configuration of a guild.\n// guildID   : The ID of the guild\nfunc (s *Session) GuildOnboarding(guildID string, options ...RequestOption) (onboarding *GuildOnboarding, err error) {\n\tendpoint := EndpointGuildOnboarding(guildID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &onboarding)\n\treturn\n}\n\n// GuildOnboardingEdit edits onboarding configuration of a guild.\n// guildID   : The ID of the guild\n// o         : New GuildOnboarding data\nfunc (s *Session) GuildOnboardingEdit(guildID string, o *GuildOnboarding, options ...RequestOption) (onboarding *GuildOnboarding, err error) {\n\tendpoint := EndpointGuildOnboarding(guildID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PUT\", endpoint, o, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &onboarding)\n\treturn\n}\n\n// ----------------------------------------------------------------------\n// Functions specific to auto moderation\n// ----------------------------------------------------------------------\n\n// AutoModerationRules returns a list of auto moderation rules.\n// guildID : ID of the guild\nfunc (s *Session) AutoModerationRules(guildID string, options ...RequestOption) (st []*AutoModerationRule, err error) {\n\tendpoint := EndpointGuildAutoModerationRules(guildID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// AutoModerationRule returns an auto moderation rule.\n// guildID : ID of the guild\n// ruleID  : ID of the auto moderation rule\nfunc (s *Session) AutoModerationRule(guildID, ruleID string, options ...RequestOption) (st *AutoModerationRule, err error) {\n\tendpoint := EndpointGuildAutoModerationRule(guildID, ruleID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// AutoModerationRuleCreate creates an auto moderation rule with the given data and returns it.\n// guildID : ID of the guild\n// rule    : Rule data\nfunc (s *Session) AutoModerationRuleCreate(guildID string, rule *AutoModerationRule, options ...RequestOption) (st *AutoModerationRule, err error) {\n\tendpoint := EndpointGuildAutoModerationRules(guildID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"POST\", endpoint, rule, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// AutoModerationRuleEdit edits and returns the updated auto moderation rule.\n// guildID : ID of the guild\n// ruleID  : ID of the auto moderation rule\n// rule    : New rule data\nfunc (s *Session) AutoModerationRuleEdit(guildID, ruleID string, rule *AutoModerationRule, options ...RequestOption) (st *AutoModerationRule, err error) {\n\tendpoint := EndpointGuildAutoModerationRule(guildID, ruleID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PATCH\", endpoint, rule, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// AutoModerationRuleDelete deletes an auto moderation rule.\n// guildID : ID of the guild\n// ruleID  : ID of the auto moderation rule\nfunc (s *Session) AutoModerationRuleDelete(guildID, ruleID string, options ...RequestOption) (err error) {\n\tendpoint := EndpointGuildAutoModerationRule(guildID, ruleID)\n\t_, err = s.RequestWithBucketID(\"DELETE\", endpoint, nil, endpoint, options...)\n\treturn\n}\n\n// ApplicationRoleConnectionMetadata returns application role connection metadata.\n// appID : ID of the application\nfunc (s *Session) ApplicationRoleConnectionMetadata(appID string) (st []*ApplicationRoleConnectionMetadata, err error) {\n\tendpoint := EndpointApplicationRoleConnectionMetadata(appID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ApplicationRoleConnectionMetadataUpdate updates and returns application role connection metadata.\n// appID    : ID of the application\n// metadata : New metadata\nfunc (s *Session) ApplicationRoleConnectionMetadataUpdate(appID string, metadata []*ApplicationRoleConnectionMetadata) (st []*ApplicationRoleConnectionMetadata, err error) {\n\tendpoint := EndpointApplicationRoleConnectionMetadata(appID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PUT\", endpoint, metadata, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// UserApplicationRoleConnection returns user role connection to the specified application.\n// appID : ID of the application\nfunc (s *Session) UserApplicationRoleConnection(appID string) (st *ApplicationRoleConnection, err error) {\n\tendpoint := EndpointUserApplicationRoleConnection(appID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n\n}\n\n// UserApplicationRoleConnectionUpdate updates and returns user role connection to the specified application.\n// appID      : ID of the application\n// connection : New ApplicationRoleConnection data\nfunc (s *Session) UserApplicationRoleConnectionUpdate(appID string, rconn *ApplicationRoleConnection) (st *ApplicationRoleConnection, err error) {\n\tendpoint := EndpointUserApplicationRoleConnection(appID)\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"PUT\", endpoint, rconn, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &st)\n\treturn\n}\n\n// ----------------------------------------------------------------------\n// Functions specific to polls\n// ----------------------------------------------------------------------\n\n// PollAnswerVoters returns users who voted for a particular answer in a poll on the specified message.\n// channelID : ID of the channel.\n// messageID : ID of the message.\n// answerID  : ID of the answer.\nfunc (s *Session) PollAnswerVoters(channelID, messageID string, answerID int) (voters []*User, err error) {\n\tendpoint := EndpointPollAnswerVoters(channelID, messageID, answerID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvar r struct {\n\t\tUsers []*User `json:\"users\"`\n\t}\n\n\terr = unmarshal(body, &r)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvoters = r.Users\n\treturn\n}\n\n// PollExpire expires poll on the specified message.\n// channelID : ID of the channel.\n// messageID : ID of the message.\nfunc (s *Session) PollExpire(channelID, messageID string) (msg *Message, err error) {\n\tendpoint := EndpointPollExpire(channelID, messageID)\n\n\tvar body []byte\n\tbody, err = s.RequestWithBucketID(\"POST\", endpoint, nil, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &msg)\n\treturn\n}\n\n// ----------------------------------------------------------------------\n// Functions specific to monetization\n// ----------------------------------------------------------------------\n\n// SKUs returns all SKUs for a given application.\n// appID : The ID of the application.\nfunc (s *Session) SKUs(appID string) (skus []*SKU, err error) {\n\tendpoint := EndpointApplicationSKUs(appID)\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint, nil, endpoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &skus)\n\treturn\n}\n\n// Entitlements returns all Entitlements for a given app, active and expired.\n// appID\t\t\t: The ID of the application.\n// filterOptions\t: Optional filter options; otherwise set it to nil.\nfunc (s *Session) Entitlements(appID string, filterOptions *EntitlementFilterOptions, options ...RequestOption) (entitlements []*Entitlement, err error) {\n\tendpoint := EndpointEntitlements(appID)\n\n\tqueryParams := url.Values{}\n\tif filterOptions != nil {\n\t\tif filterOptions.UserID != \"\" {\n\t\t\tqueryParams.Set(\"user_id\", filterOptions.UserID)\n\t\t}\n\t\tif filterOptions.SkuIDs != nil && len(filterOptions.SkuIDs) > 0 {\n\t\t\tqueryParams.Set(\"sku_ids\", strings.Join(filterOptions.SkuIDs, \",\"))\n\t\t}\n\t\tif filterOptions.Before != nil {\n\t\t\tqueryParams.Set(\"before\", filterOptions.Before.Format(time.RFC3339))\n\t\t}\n\t\tif filterOptions.After != nil {\n\t\t\tqueryParams.Set(\"after\", filterOptions.After.Format(time.RFC3339))\n\t\t}\n\t\tif filterOptions.Limit > 0 {\n\t\t\tqueryParams.Set(\"limit\", strconv.Itoa(filterOptions.Limit))\n\t\t}\n\t\tif filterOptions.GuildID != \"\" {\n\t\t\tqueryParams.Set(\"guild_id\", filterOptions.GuildID)\n\t\t}\n\t\tif filterOptions.ExcludeEnded {\n\t\t\tqueryParams.Set(\"exclude_ended\", \"true\")\n\t\t}\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint+\"?\"+queryParams.Encode(), nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &entitlements)\n\treturn\n}\n\n// EntitlementConsume marks a given One-Time Purchase for the user as consumed.\nfunc (s *Session) EntitlementConsume(appID, entitlementID string, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"POST\", EndpointEntitlementConsume(appID, entitlementID), nil, EndpointEntitlementConsume(appID, \"\"), options...)\n\treturn\n}\n\n// EntitlementTestCreate creates a test entitlement to a given SKU for a given guild or user.\n// Discord will act as though that user or guild has entitlement to your premium offering.\nfunc (s *Session) EntitlementTestCreate(appID string, data *EntitlementTest, options ...RequestOption) (err error) {\n\tendpoint := EndpointEntitlements(appID)\n\n\t_, err = s.RequestWithBucketID(\"POST\", endpoint, data, endpoint, options...)\n\treturn\n}\n\n// EntitlementTestDelete deletes a currently-active test entitlement. Discord will act as though\n// that user or guild no longer has entitlement to your premium offering.\nfunc (s *Session) EntitlementTestDelete(appID, entitlementID string, options ...RequestOption) (err error) {\n\t_, err = s.RequestWithBucketID(\"DELETE\", EndpointEntitlement(appID, entitlementID), nil, EndpointEntitlement(appID, \"\"), options...)\n\treturn\n}\n\n// Subscriptions returns all subscriptions containing the SKU.\n// skuID : The ID of the SKU.\n// userID : User ID for which to return subscriptions. Required except for OAuth queries.\n// before : Optional timestamp to retrieve subscriptions before this time.\n// after : Optional timestamp to retrieve subscriptions after this time.\n// limit : Optional maximum number of subscriptions to return (1-100, default 50).\nfunc (s *Session) Subscriptions(skuID string, userID string, before, after *time.Time, limit int, options ...RequestOption) (subscriptions []*Subscription, err error) {\n\tendpoint := EndpointSubscriptions(skuID)\n\n\tqueryParams := url.Values{}\n\tif before != nil {\n\t\tqueryParams.Set(\"before\", before.Format(time.RFC3339))\n\t}\n\tif after != nil {\n\t\tqueryParams.Set(\"after\", after.Format(time.RFC3339))\n\t}\n\tif userID != \"\" {\n\t\tqueryParams.Set(\"user_id\", userID)\n\t}\n\tif limit > 0 {\n\t\tqueryParams.Set(\"limit\", strconv.Itoa(limit))\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint+\"?\"+queryParams.Encode(), nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &subscriptions)\n\treturn\n}\n\n// Subscription returns a subscription by its SKU and subscription ID.\n// skuID : The ID of the SKU.\n// subscriptionID : The ID of the subscription.\n// userID : User ID for which to return the subscription. Required except for OAuth queries.\nfunc (s *Session) Subscription(skuID, subscriptionID, userID string, options ...RequestOption) (subscription *Subscription, err error) {\n\tendpoint := EndpointSubscription(skuID, subscriptionID)\n\n\tqueryParams := url.Values{}\n\tif userID != \"\" {\n\t\t// Unlike stated in the documentation, the user_id parameter is required here.\n\t\tqueryParams.Set(\"user_id\", userID)\n\t}\n\n\tbody, err := s.RequestWithBucketID(\"GET\", endpoint+\"?\"+queryParams.Encode(), nil, endpoint, options...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = unmarshal(body, &subscription)\n\treturn\n}\n"
        },
        {
          "name": "restapi_test.go",
          "type": "blob",
          "size": 5.7958984375,
          "content": "package discordgo\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"testing\"\n)\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////// START OF TESTS\n\n// TestChannelMessageSend tests the ChannelMessageSend() function. This should not return an error.\nfunc TestChannelMessageSend(t *testing.T) {\n\n\tif envChannel == \"\" {\n\t\tt.Skip(\"Skipping, DG_CHANNEL not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.ChannelMessageSend(envChannel, \"Running REST API Tests!\")\n\tif err != nil {\n\t\tt.Errorf(\"ChannelMessageSend returned error: %+v\", err)\n\t}\n}\n\n/*\n// removed for now, only works on BOT accounts now\nfunc TestUserAvatar(t *testing.T) {\n\n\tif dg == nil {\n\t\tt.Skip(\"Cannot TestUserAvatar, dg not set.\")\n\t}\n\n\tu, err := dg.User(\"@me\")\n\tif err != nil {\n\t\tt.Error(\"error fetching @me user,\", err)\n\t}\n\n\ta, err := dg.UserAvatar(u.ID)\n\tif err != nil {\n\t\tif err.Error() == `HTTP 404 NOT FOUND, {\"code\": 0, \"message\": \"404: Not Found\"}` {\n\t\t\tt.Skip(\"Skipped, @me doesn't have an Avatar\")\n\t\t}\n\t\tt.Errorf(err.Error())\n\t}\n\n\tif a == nil {\n\t\tt.Errorf(\"a == nil, should be image.Image\")\n\t}\n}\n*/\n\n/* Running this causes an error due to 2/hour rate limit on username changes\nfunc TestUserUpdate(t *testing.T) {\n\tif dg == nil {\n\t\tt.Skip(\"Cannot test logout, dg not set.\")\n\t}\n\n\tu, err := dg.User(\"@me\")\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\ts, err := dg.UserUpdate(envEmail, envPassword, \"testname\", u.Avatar, \"\")\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif s.Username != \"testname\" {\n\t\tt.Error(\"Username != testname\")\n\t}\n\ts, err = dg.UserUpdate(envEmail, envPassword, u.Username, u.Avatar, \"\")\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif s.Username != u.Username {\n\t\tt.Error(\"Username != \" + u.Username)\n\t}\n}\n*/\n\n//func (s *Session) UserChannelCreate(recipientID string) (st *Channel, err error) {\n\nfunc TestUserChannelCreate(t *testing.T) {\n\tif dg == nil {\n\t\tt.Skip(\"Cannot TestUserChannelCreate, dg not set.\")\n\t}\n\n\tif envAdmin == \"\" {\n\t\tt.Skip(\"Skipped, DG_ADMIN not set.\")\n\t}\n\n\t_, err := dg.UserChannelCreate(envAdmin)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\t// TODO make sure the channel was added\n}\n\nfunc TestUserGuilds(t *testing.T) {\n\tif dg == nil {\n\t\tt.Skip(\"Cannot TestUserGuilds, dg not set.\")\n\t}\n\n\t_, err := dg.UserGuilds(10, \"\", \"\", false)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n}\n\nfunc TestGateway(t *testing.T) {\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\t_, err := dg.Gateway()\n\tif err != nil {\n\t\tt.Errorf(\"Gateway() returned error: %+v\", err)\n\t}\n}\n\nfunc TestGatewayBot(t *testing.T) {\n\n\tif dgBot == nil {\n\t\tt.Skip(\"Skipping, dgBot not set.\")\n\t}\n\t_, err := dgBot.GatewayBot()\n\tif err != nil {\n\t\tt.Errorf(\"GatewayBot() returned error: %+v\", err)\n\t}\n}\n\nfunc TestVoiceRegions(t *testing.T) {\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.VoiceRegions()\n\tif err != nil {\n\t\tt.Errorf(\"VoiceRegions() returned error: %+v\", err)\n\t}\n}\nfunc TestGuildRoles(t *testing.T) {\n\n\tif envGuild == \"\" {\n\t\tt.Skip(\"Skipping, DG_GUILD not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.GuildRoles(envGuild)\n\tif err != nil {\n\t\tt.Errorf(\"GuildRoles(envGuild) returned error: %+v\", err)\n\t}\n\n}\n\nfunc TestGuildMemberNickname(t *testing.T) {\n\n\tif envGuild == \"\" {\n\t\tt.Skip(\"Skipping, DG_GUILD not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\terr := dg.GuildMemberNickname(envGuild, \"@me/nick\", \"B1nzyRocks\")\n\tif err != nil {\n\t\tt.Errorf(\"GuildNickname returned error: %+v\", err)\n\t}\n}\n\n// TestChannelMessageSend2 tests the ChannelMessageSend() function. This should not return an error.\nfunc TestChannelMessageSend2(t *testing.T) {\n\n\tif envChannel == \"\" {\n\t\tt.Skip(\"Skipping, DG_CHANNEL not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.ChannelMessageSend(envChannel, \"All done running REST API Tests!\")\n\tif err != nil {\n\t\tt.Errorf(\"ChannelMessageSend returned error: %+v\", err)\n\t}\n}\n\n// TestGuildPruneCount tests GuildPruneCount() function. This should not return an error.\nfunc TestGuildPruneCount(t *testing.T) {\n\n\tif envGuild == \"\" {\n\t\tt.Skip(\"Skipping, DG_GUILD not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.GuildPruneCount(envGuild, 1)\n\tif err != nil {\n\t\tt.Errorf(\"GuildPruneCount returned error: %+v\", err)\n\t}\n}\n\n/*\n// TestGuildPrune tests GuildPrune() function. This should not return an error.\nfunc TestGuildPrune(t *testing.T) {\n\n\tif envGuild == \"\" {\n\t\tt.Skip(\"Skipping, DG_GUILD not set.\")\n\t}\n\n\tif dg == nil {\n\t\tt.Skip(\"Skipping, dg not set.\")\n\t}\n\n\t_, err := dg.GuildPrune(envGuild, 1)\n\tif err != nil {\n\t\tt.Errorf(\"GuildPrune returned error: %+v\", err)\n\t}\n}\n*/\n\nfunc Test_unmarshal(t *testing.T) {\n\terr := unmarshal([]byte{}, &struct{}{})\n\tif !errors.Is(err, ErrJSONUnmarshal) {\n\t\tt.Errorf(\"Unexpected error type: %T\", err)\n\t}\n}\n\nfunc TestWithContext(t *testing.T) {\n\t// Set up a test context.\n\ttype key struct{}\n\tctx := context.WithValue(context.Background(), key{}, \"value\")\n\n\t// Set up a test client.\n\tsession, err := New(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestErr := errors.New(\"test\")\n\n\t// Intercept the request to assert the context.\n\tsession.Client.Transport = roundTripperFunc(func(r *http.Request) (*http.Response, error) {\n\t\tval, _ := r.Context().Value(key{}).(string)\n\t\tif val != \"value\" {\n\t\t\tt.Errorf(\"missing value in context (got %q, wanted %q)\", val, \"value\")\n\t\t}\n\t\treturn nil, testErr\n\t})\n\n\t// Run any client method using WithContext.\n\t_, err = session.User(\"\", WithContext(ctx))\n\n\t// Verify that the assertion code was actually run.\n\tif !errors.Is(err, testErr) {\n\t\tt.Errorf(\"unexpected error %v returned from client\", err)\n\t}\n}\n\n// roundTripperFunc implements http.RoundTripper.\ntype roundTripperFunc func(*http.Request) (*http.Response, error)\n\nfunc (f roundTripperFunc) RoundTrip(req *http.Request) (*http.Response, error) {\n\treturn f(req)\n}\n"
        },
        {
          "name": "state.go",
          "type": "blob",
          "size": 27.2119140625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains code related to state tracking.  If enabled, state\n// tracking will capture the initial READY packet and many other websocket\n// events and maintain an in-memory state of guilds, channels, users, and\n// so forth.  This information can be accessed through the Session.State struct.\n\npackage discordgo\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"sync\"\n)\n\n// ErrNilState is returned when the state is nil.\nvar ErrNilState = errors.New(\"state not instantiated, please use discordgo.New() or assign Session.State\")\n\n// ErrStateNotFound is returned when the state cache\n// requested is not found\nvar ErrStateNotFound = errors.New(\"state cache not found\")\n\n// ErrMessageIncompletePermissions is returned when the message\n// requested for permissions does not contain enough data to\n// generate the permissions.\nvar ErrMessageIncompletePermissions = errors.New(\"message incomplete, unable to determine permissions\")\n\n// A State contains the current known state.\n// As discord sends this in a READY blob, it seems reasonable to simply\n// use that struct as the data store.\ntype State struct {\n\tsync.RWMutex\n\tReady\n\n\t// MaxMessageCount represents how many messages per channel the state will store.\n\tMaxMessageCount    int\n\tTrackChannels      bool\n\tTrackThreads       bool\n\tTrackEmojis        bool\n\tTrackMembers       bool\n\tTrackThreadMembers bool\n\tTrackRoles         bool\n\tTrackVoice         bool\n\tTrackPresences     bool\n\n\tguildMap   map[string]*Guild\n\tchannelMap map[string]*Channel\n\tmemberMap  map[string]map[string]*Member\n}\n\n// NewState creates an empty state.\nfunc NewState() *State {\n\treturn &State{\n\t\tReady: Ready{\n\t\t\tPrivateChannels: []*Channel{},\n\t\t\tGuilds:          []*Guild{},\n\t\t},\n\t\tTrackChannels:      true,\n\t\tTrackThreads:       true,\n\t\tTrackEmojis:        true,\n\t\tTrackMembers:       true,\n\t\tTrackThreadMembers: true,\n\t\tTrackRoles:         true,\n\t\tTrackVoice:         true,\n\t\tTrackPresences:     true,\n\t\tguildMap:           make(map[string]*Guild),\n\t\tchannelMap:         make(map[string]*Channel),\n\t\tmemberMap:          make(map[string]map[string]*Member),\n\t}\n}\n\nfunc (s *State) createMemberMap(guild *Guild) {\n\tmembers := make(map[string]*Member)\n\tfor _, m := range guild.Members {\n\t\tmembers[m.User.ID] = m\n\t}\n\ts.memberMap[guild.ID] = members\n}\n\n// GuildAdd adds a guild to the current world state, or\n// updates it if it already exists.\nfunc (s *State) GuildAdd(guild *Guild) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// Update the channels to point to the right guild, adding them to the channelMap as we go\n\tfor _, c := range guild.Channels {\n\t\ts.channelMap[c.ID] = c\n\t}\n\n\t// Add all the threads to the state in case of thread sync list.\n\tfor _, t := range guild.Threads {\n\t\ts.channelMap[t.ID] = t\n\t}\n\n\t// If this guild contains a new member slice, we must regenerate the member map so the pointers stay valid\n\tif guild.Members != nil {\n\t\ts.createMemberMap(guild)\n\t} else if _, ok := s.memberMap[guild.ID]; !ok {\n\t\t// Even if we have no new member slice, we still initialize the member map for this guild if it doesn't exist\n\t\ts.memberMap[guild.ID] = make(map[string]*Member)\n\t}\n\n\tif g, ok := s.guildMap[guild.ID]; ok {\n\t\t// We are about to replace `g` in the state with `guild`, but first we need to\n\t\t// make sure we preserve any fields that the `guild` doesn't contain from `g`.\n\t\tif guild.MemberCount == 0 {\n\t\t\tguild.MemberCount = g.MemberCount\n\t\t}\n\t\tif guild.Roles == nil {\n\t\t\tguild.Roles = g.Roles\n\t\t}\n\t\tif guild.Emojis == nil {\n\t\t\tguild.Emojis = g.Emojis\n\t\t}\n\t\tif guild.Members == nil {\n\t\t\tguild.Members = g.Members\n\t\t}\n\t\tif guild.Presences == nil {\n\t\t\tguild.Presences = g.Presences\n\t\t}\n\t\tif guild.Channels == nil {\n\t\t\tguild.Channels = g.Channels\n\t\t}\n\t\tif guild.Threads == nil {\n\t\t\tguild.Threads = g.Threads\n\t\t}\n\t\tif guild.VoiceStates == nil {\n\t\t\tguild.VoiceStates = g.VoiceStates\n\t\t}\n\t\t*g = *guild\n\t\treturn nil\n\t}\n\n\ts.Guilds = append(s.Guilds, guild)\n\ts.guildMap[guild.ID] = guild\n\n\treturn nil\n}\n\n// GuildRemove removes a guild from current world state.\nfunc (s *State) GuildRemove(guild *Guild) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\t_, err := s.Guild(guild.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tdelete(s.guildMap, guild.ID)\n\n\tfor i, g := range s.Guilds {\n\t\tif g.ID == guild.ID {\n\t\t\ts.Guilds = append(s.Guilds[:i], s.Guilds[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Guild gets a guild by ID.\n// Useful for querying if @me is in a guild:\n//     _, err := discordgo.Session.State.Guild(guildID)\n//     isInGuild := err == nil\nfunc (s *State) Guild(guildID string) (*Guild, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tif g, ok := s.guildMap[guildID]; ok {\n\t\treturn g, nil\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\nfunc (s *State) presenceAdd(guildID string, presence *Presence) error {\n\tguild, ok := s.guildMap[guildID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\n\tfor i, p := range guild.Presences {\n\t\tif p.User.ID == presence.User.ID {\n\t\t\t//guild.Presences[i] = presence\n\n\t\t\t//Update status\n\t\t\tguild.Presences[i].Activities = presence.Activities\n\t\t\tif presence.Status != \"\" {\n\t\t\t\tguild.Presences[i].Status = presence.Status\n\t\t\t}\n\t\t\tif presence.ClientStatus.Desktop != \"\" {\n\t\t\t\tguild.Presences[i].ClientStatus.Desktop = presence.ClientStatus.Desktop\n\t\t\t}\n\t\t\tif presence.ClientStatus.Mobile != \"\" {\n\t\t\t\tguild.Presences[i].ClientStatus.Mobile = presence.ClientStatus.Mobile\n\t\t\t}\n\t\t\tif presence.ClientStatus.Web != \"\" {\n\t\t\t\tguild.Presences[i].ClientStatus.Web = presence.ClientStatus.Web\n\t\t\t}\n\n\t\t\t//Update the optionally sent user information\n\t\t\t//ID Is a mandatory field so you should not need to check if it is empty\n\t\t\tguild.Presences[i].User.ID = presence.User.ID\n\n\t\t\tif presence.User.Avatar != \"\" {\n\t\t\t\tguild.Presences[i].User.Avatar = presence.User.Avatar\n\t\t\t}\n\t\t\tif presence.User.Discriminator != \"\" {\n\t\t\t\tguild.Presences[i].User.Discriminator = presence.User.Discriminator\n\t\t\t}\n\t\t\tif presence.User.Email != \"\" {\n\t\t\t\tguild.Presences[i].User.Email = presence.User.Email\n\t\t\t}\n\t\t\tif presence.User.Token != \"\" {\n\t\t\t\tguild.Presences[i].User.Token = presence.User.Token\n\t\t\t}\n\t\t\tif presence.User.Username != \"\" {\n\t\t\t\tguild.Presences[i].User.Username = presence.User.Username\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tguild.Presences = append(guild.Presences, presence)\n\treturn nil\n}\n\n// PresenceAdd adds a presence to the current world state, or\n// updates it if it already exists.\nfunc (s *State) PresenceAdd(guildID string, presence *Presence) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\treturn s.presenceAdd(guildID, presence)\n}\n\n// PresenceRemove removes a presence from the current world state.\nfunc (s *State) PresenceRemove(guildID string, presence *Presence) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i, p := range guild.Presences {\n\t\tif p.User.ID == presence.User.ID {\n\t\t\tguild.Presences = append(guild.Presences[:i], guild.Presences[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrStateNotFound\n}\n\n// Presence gets a presence by ID from a guild.\nfunc (s *State) Presence(guildID, userID string) (*Presence, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, p := range guild.Presences {\n\t\tif p.User.ID == userID {\n\t\t\treturn p, nil\n\t\t}\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// TODO: Consider moving Guild state update methods onto *Guild.\n\nfunc (s *State) memberAdd(member *Member) error {\n\tguild, ok := s.guildMap[member.GuildID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\n\tmembers, ok := s.memberMap[member.GuildID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\n\tm, ok := members[member.User.ID]\n\tif !ok {\n\t\tmembers[member.User.ID] = member\n\t\tguild.Members = append(guild.Members, member)\n\t} else {\n\t\t// We are about to replace `m` in the state with `member`, but first we need to\n\t\t// make sure we preserve any fields that the `member` doesn't contain from `m`.\n\t\tif member.JoinedAt.IsZero() {\n\t\t\tmember.JoinedAt = m.JoinedAt\n\t\t}\n\t\t*m = *member\n\t}\n\treturn nil\n}\n\n// MemberAdd adds a member to the current world state, or\n// updates it if it already exists.\nfunc (s *State) MemberAdd(member *Member) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\treturn s.memberAdd(member)\n}\n\n// MemberRemove removes a member from current world state.\nfunc (s *State) MemberRemove(member *Member) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tguild, err := s.Guild(member.GuildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tmembers, ok := s.memberMap[member.GuildID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\n\t_, ok = members[member.User.ID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\tdelete(members, member.User.ID)\n\n\tfor i, m := range guild.Members {\n\t\tif m.User.ID == member.User.ID {\n\t\t\tguild.Members = append(guild.Members[:i], guild.Members[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrStateNotFound\n}\n\n// Member gets a member by ID from a guild.\nfunc (s *State) Member(guildID, userID string) (*Member, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tmembers, ok := s.memberMap[guildID]\n\tif !ok {\n\t\treturn nil, ErrStateNotFound\n\t}\n\n\tm, ok := members[userID]\n\tif ok {\n\t\treturn m, nil\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// RoleAdd adds a role to the current world state, or\n// updates it if it already exists.\nfunc (s *State) RoleAdd(guildID string, role *Role) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i, r := range guild.Roles {\n\t\tif r.ID == role.ID {\n\t\t\tguild.Roles[i] = role\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tguild.Roles = append(guild.Roles, role)\n\treturn nil\n}\n\n// RoleRemove removes a role from current world state by ID.\nfunc (s *State) RoleRemove(guildID, roleID string) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i, r := range guild.Roles {\n\t\tif r.ID == roleID {\n\t\t\tguild.Roles = append(guild.Roles[:i], guild.Roles[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrStateNotFound\n}\n\n// Role gets a role by ID from a guild.\nfunc (s *State) Role(guildID, roleID string) (*Role, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tfor _, r := range guild.Roles {\n\t\tif r.ID == roleID {\n\t\t\treturn r, nil\n\t\t}\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// ChannelAdd adds a channel to the current world state, or\n// updates it if it already exists.\n// Channels may exist either as PrivateChannels or inside\n// a guild.\nfunc (s *State) ChannelAdd(channel *Channel) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// If the channel exists, replace it\n\tif c, ok := s.channelMap[channel.ID]; ok {\n\t\tif channel.Messages == nil {\n\t\t\tchannel.Messages = c.Messages\n\t\t}\n\t\tif channel.PermissionOverwrites == nil {\n\t\t\tchannel.PermissionOverwrites = c.PermissionOverwrites\n\t\t}\n\t\tif channel.ThreadMetadata == nil {\n\t\t\tchannel.ThreadMetadata = c.ThreadMetadata\n\t\t}\n\n\t\t*c = *channel\n\t\treturn nil\n\t}\n\n\tif channel.Type == ChannelTypeDM || channel.Type == ChannelTypeGroupDM {\n\t\ts.PrivateChannels = append(s.PrivateChannels, channel)\n\t\ts.channelMap[channel.ID] = channel\n\t\treturn nil\n\t}\n\n\tguild, ok := s.guildMap[channel.GuildID]\n\tif !ok {\n\t\treturn ErrStateNotFound\n\t}\n\n\tif channel.IsThread() {\n\t\tguild.Threads = append(guild.Threads, channel)\n\t} else {\n\t\tguild.Channels = append(guild.Channels, channel)\n\t}\n\n\ts.channelMap[channel.ID] = channel\n\n\treturn nil\n}\n\n// ChannelRemove removes a channel from current world state.\nfunc (s *State) ChannelRemove(channel *Channel) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\t_, err := s.Channel(channel.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif channel.Type == ChannelTypeDM || channel.Type == ChannelTypeGroupDM {\n\t\ts.Lock()\n\t\tdefer s.Unlock()\n\n\t\tfor i, c := range s.PrivateChannels {\n\t\t\tif c.ID == channel.ID {\n\t\t\t\ts.PrivateChannels = append(s.PrivateChannels[:i], s.PrivateChannels[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tdelete(s.channelMap, channel.ID)\n\t\treturn nil\n\t}\n\n\tguild, err := s.Guild(channel.GuildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tif channel.IsThread() {\n\t\tfor i, t := range guild.Threads {\n\t\t\tif t.ID == channel.ID {\n\t\t\t\tguild.Threads = append(guild.Threads[:i], guild.Threads[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor i, c := range guild.Channels {\n\t\t\tif c.ID == channel.ID {\n\t\t\t\tguild.Channels = append(guild.Channels[:i], guild.Channels[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete(s.channelMap, channel.ID)\n\n\treturn nil\n}\n\n// ThreadListSync syncs guild threads with provided ones.\nfunc (s *State) ThreadListSync(tls *ThreadListSync) error {\n\tguild, err := s.Guild(tls.GuildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// This algorithm filters out archived or\n\t// threads which are children of channels in channelIDs\n\t// and then it adds all synced threads to guild threads and cache\n\tindex := 0\nouter:\n\tfor _, t := range guild.Threads {\n\t\tif !t.ThreadMetadata.Archived && tls.ChannelIDs != nil {\n\t\t\tfor _, v := range tls.ChannelIDs {\n\t\t\t\tif t.ParentID == v {\n\t\t\t\t\tdelete(s.channelMap, t.ID)\n\t\t\t\t\tcontinue outer\n\t\t\t\t}\n\t\t\t}\n\t\t\tguild.Threads[index] = t\n\t\t\tindex++\n\t\t} else {\n\t\t\tdelete(s.channelMap, t.ID)\n\t\t}\n\t}\n\tguild.Threads = guild.Threads[:index]\n\tfor _, t := range tls.Threads {\n\t\ts.channelMap[t.ID] = t\n\t\tguild.Threads = append(guild.Threads, t)\n\t}\n\n\tfor _, m := range tls.Members {\n\t\tif c, ok := s.channelMap[m.ID]; ok {\n\t\t\tc.Member = m\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ThreadMembersUpdate updates thread members list\nfunc (s *State) ThreadMembersUpdate(tmu *ThreadMembersUpdate) error {\n\tthread, err := s.Channel(tmu.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor idx, member := range thread.Members {\n\t\tfor _, removedMember := range tmu.RemovedMembers {\n\t\t\tif member.ID == removedMember {\n\t\t\t\tthread.Members = append(thread.Members[:idx], thread.Members[idx+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, addedMember := range tmu.AddedMembers {\n\t\tthread.Members = append(thread.Members, addedMember.ThreadMember)\n\t\tif addedMember.Member != nil {\n\t\t\terr = s.memberAdd(addedMember.Member)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif addedMember.Presence != nil {\n\t\t\terr = s.presenceAdd(tmu.GuildID, addedMember.Presence)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tthread.MemberCount = tmu.MemberCount\n\n\treturn nil\n}\n\n// ThreadMemberUpdate sets or updates member data for the current user.\nfunc (s *State) ThreadMemberUpdate(mu *ThreadMemberUpdate) error {\n\tthread, err := s.Channel(mu.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tthread.Member = mu.ThreadMember\n\treturn nil\n}\n\n// Channel gets a channel by ID, it will look in all guilds and private channels.\nfunc (s *State) Channel(channelID string) (*Channel, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tif c, ok := s.channelMap[channelID]; ok {\n\t\treturn c, nil\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// Emoji returns an emoji for a guild and emoji id.\nfunc (s *State) Emoji(guildID, emojiID string) (*Emoji, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tfor _, e := range guild.Emojis {\n\t\tif e.ID == emojiID {\n\t\t\treturn e, nil\n\t\t}\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// EmojiAdd adds an emoji to the current world state.\nfunc (s *State) EmojiAdd(guildID string, emoji *Emoji) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i, e := range guild.Emojis {\n\t\tif e.ID == emoji.ID {\n\t\t\tguild.Emojis[i] = emoji\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tguild.Emojis = append(guild.Emojis, emoji)\n\treturn nil\n}\n\n// EmojisAdd adds multiple emojis to the world state.\nfunc (s *State) EmojisAdd(guildID string, emojis []*Emoji) error {\n\tfor _, e := range emojis {\n\t\tif err := s.EmojiAdd(guildID, e); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// MessageAdd adds a message to the current world state, or updates it if it exists.\n// If the channel cannot be found, the message is discarded.\n// Messages are kept in state up to s.MaxMessageCount per channel.\nfunc (s *State) MessageAdd(message *Message) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tc, err := s.Channel(message.ChannelID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// If the message exists, merge in the new message contents.\n\tfor _, m := range c.Messages {\n\t\tif m.ID == message.ID {\n\t\t\tif message.Content != \"\" {\n\t\t\t\tm.Content = message.Content\n\t\t\t}\n\t\t\tif message.EditedTimestamp != nil {\n\t\t\t\tm.EditedTimestamp = message.EditedTimestamp\n\t\t\t}\n\t\t\tif message.Mentions != nil {\n\t\t\t\tm.Mentions = message.Mentions\n\t\t\t}\n\t\t\tif message.Embeds != nil {\n\t\t\t\tm.Embeds = message.Embeds\n\t\t\t}\n\t\t\tif message.Attachments != nil {\n\t\t\t\tm.Attachments = message.Attachments\n\t\t\t}\n\t\t\tif !message.Timestamp.IsZero() {\n\t\t\t\tm.Timestamp = message.Timestamp\n\t\t\t}\n\t\t\tif message.Author != nil {\n\t\t\t\tm.Author = message.Author\n\t\t\t}\n\t\t\tif message.Components != nil {\n\t\t\t\tm.Components = message.Components\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tc.Messages = append(c.Messages, message)\n\n\tif len(c.Messages) > s.MaxMessageCount {\n\t\tc.Messages = c.Messages[len(c.Messages)-s.MaxMessageCount:]\n\t}\n\n\treturn nil\n}\n\n// MessageRemove removes a message from the world state.\nfunc (s *State) MessageRemove(message *Message) error {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\treturn s.messageRemoveByID(message.ChannelID, message.ID)\n}\n\n// messageRemoveByID removes a message by channelID and messageID from the world state.\nfunc (s *State) messageRemoveByID(channelID, messageID string) error {\n\tc, err := s.Channel(channelID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i, m := range c.Messages {\n\t\tif m.ID == messageID {\n\t\t\tc.Messages = append(c.Messages[:i], c.Messages[i+1:]...)\n\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrStateNotFound\n}\n\nfunc (s *State) voiceStateUpdate(update *VoiceStateUpdate) error {\n\tguild, err := s.Guild(update.GuildID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// Handle Leaving Channel\n\tif update.ChannelID == \"\" {\n\t\tfor i, state := range guild.VoiceStates {\n\t\t\tif state.UserID == update.UserID {\n\t\t\t\tguild.VoiceStates = append(guild.VoiceStates[:i], guild.VoiceStates[i+1:]...)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor i, state := range guild.VoiceStates {\n\t\t\tif state.UserID == update.UserID {\n\t\t\t\tguild.VoiceStates[i] = update.VoiceState\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tguild.VoiceStates = append(guild.VoiceStates, update.VoiceState)\n\t}\n\n\treturn nil\n}\n\n// VoiceState gets a VoiceState by guild and user ID.\nfunc (s *State) VoiceState(guildID, userID string) (*VoiceState, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\tguild, err := s.Guild(guildID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, state := range guild.VoiceStates {\n\t\tif state.UserID == userID {\n\t\t\treturn state, nil\n\t\t}\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// Message gets a message by channel and message ID.\nfunc (s *State) Message(channelID, messageID string) (*Message, error) {\n\tif s == nil {\n\t\treturn nil, ErrNilState\n\t}\n\n\tc, err := s.Channel(channelID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\n\tfor _, m := range c.Messages {\n\t\tif m.ID == messageID {\n\t\t\treturn m, nil\n\t\t}\n\t}\n\n\treturn nil, ErrStateNotFound\n}\n\n// OnReady takes a Ready event and updates all internal state.\nfunc (s *State) onReady(se *Session, r *Ready) (err error) {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// We must track at least the current user for Voice, even\n\t// if state is disabled, store the bare essentials.\n\tif !se.StateEnabled {\n\t\tready := Ready{\n\t\t\tVersion:     r.Version,\n\t\t\tSessionID:   r.SessionID,\n\t\t\tUser:        r.User,\n\t\t\tShard:       r.Shard,\n\t\t\tApplication: r.Application,\n\t\t}\n\n\t\ts.Ready = ready\n\n\t\treturn nil\n\t}\n\n\ts.Ready = *r\n\n\tfor _, g := range s.Guilds {\n\t\ts.guildMap[g.ID] = g\n\t\ts.createMemberMap(g)\n\n\t\tfor _, c := range g.Channels {\n\t\t\ts.channelMap[c.ID] = c\n\t\t}\n\t}\n\n\tfor _, c := range s.PrivateChannels {\n\t\ts.channelMap[c.ID] = c\n\t}\n\n\treturn nil\n}\n\n// OnInterface handles all events related to states.\nfunc (s *State) OnInterface(se *Session, i interface{}) (err error) {\n\tif s == nil {\n\t\treturn ErrNilState\n\t}\n\n\tr, ok := i.(*Ready)\n\tif ok {\n\t\treturn s.onReady(se, r)\n\t}\n\n\tif !se.StateEnabled {\n\t\treturn nil\n\t}\n\n\tswitch t := i.(type) {\n\tcase *GuildCreate:\n\t\terr = s.GuildAdd(t.Guild)\n\tcase *GuildUpdate:\n\t\terr = s.GuildAdd(t.Guild)\n\tcase *GuildDelete:\n\t\tvar old *Guild\n\t\told, err = s.Guild(t.ID)\n\t\tif err == nil {\n\t\t\toldCopy := *old\n\t\t\tt.BeforeDelete = &oldCopy\n\t\t}\n\n\t\terr = s.GuildRemove(t.Guild)\n\tcase *GuildMemberAdd:\n\t\tvar guild *Guild\n\t\t// Updates the MemberCount of the guild.\n\t\tguild, err = s.Guild(t.Member.GuildID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tguild.MemberCount++\n\n\t\t// Caches member if tracking is enabled.\n\t\tif s.TrackMembers {\n\t\t\terr = s.MemberAdd(t.Member)\n\t\t}\n\tcase *GuildMemberUpdate:\n\t\tif s.TrackMembers {\n\t\t\tvar old *Member\n\t\t\told, err = s.Member(t.GuildID, t.User.ID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeUpdate = &oldCopy\n\t\t\t}\n\n\t\t\terr = s.MemberAdd(t.Member)\n\t\t}\n\tcase *GuildMemberRemove:\n\t\tvar guild *Guild\n\t\t// Updates the MemberCount of the guild.\n\t\tguild, err = s.Guild(t.Member.GuildID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tguild.MemberCount--\n\n\t\t// Removes member from the cache if tracking is enabled.\n\t\tif s.TrackMembers {\n\t\t\terr = s.MemberRemove(t.Member)\n\t\t}\n\tcase *GuildMembersChunk:\n\t\tif s.TrackMembers {\n\t\t\tfor i := range t.Members {\n\t\t\t\tt.Members[i].GuildID = t.GuildID\n\t\t\t\terr = s.MemberAdd(t.Members[i])\n\t\t\t}\n\t\t}\n\n\t\tif s.TrackPresences {\n\t\t\tfor _, p := range t.Presences {\n\t\t\t\terr = s.PresenceAdd(t.GuildID, p)\n\t\t\t}\n\t\t}\n\tcase *GuildRoleCreate:\n\t\tif s.TrackRoles {\n\t\t\terr = s.RoleAdd(t.GuildID, t.Role)\n\t\t}\n\tcase *GuildRoleUpdate:\n\t\tif s.TrackRoles {\n\t\t\terr = s.RoleAdd(t.GuildID, t.Role)\n\t\t}\n\tcase *GuildRoleDelete:\n\t\tif s.TrackRoles {\n\t\t\terr = s.RoleRemove(t.GuildID, t.RoleID)\n\t\t}\n\tcase *GuildEmojisUpdate:\n\t\tif s.TrackEmojis {\n\t\t\tvar guild *Guild\n\t\t\tguild, err = s.Guild(t.GuildID)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Lock()\n\t\t\tdefer s.Unlock()\n\t\t\tguild.Emojis = t.Emojis\n\t\t}\n\tcase *ChannelCreate:\n\t\tif s.TrackChannels {\n\t\t\terr = s.ChannelAdd(t.Channel)\n\t\t}\n\tcase *ChannelUpdate:\n\t\tif s.TrackChannels {\n\t\t\told, err := s.Channel(t.ID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeUpdate = &oldCopy\n\t\t\t}\n\t\t\terr = s.ChannelAdd(t.Channel)\n\t\t}\n\tcase *ChannelDelete:\n\t\tif s.TrackChannels {\n\t\t\terr = s.ChannelRemove(t.Channel)\n\t\t}\n\tcase *ThreadCreate:\n\t\tif s.TrackThreads {\n\t\t\terr = s.ChannelAdd(t.Channel)\n\t\t}\n\tcase *ThreadUpdate:\n\t\tif s.TrackThreads {\n\t\t\told, err := s.Channel(t.ID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeUpdate = &oldCopy\n\t\t\t}\n\t\t\terr = s.ChannelAdd(t.Channel)\n\t\t}\n\tcase *ThreadDelete:\n\t\tif s.TrackThreads {\n\t\t\terr = s.ChannelRemove(t.Channel)\n\t\t}\n\tcase *ThreadMemberUpdate:\n\t\tif s.TrackThreads {\n\t\t\terr = s.ThreadMemberUpdate(t)\n\t\t}\n\tcase *ThreadMembersUpdate:\n\t\tif s.TrackThreadMembers {\n\t\t\terr = s.ThreadMembersUpdate(t)\n\t\t}\n\tcase *ThreadListSync:\n\t\tif s.TrackThreads {\n\t\t\terr = s.ThreadListSync(t)\n\t\t}\n\tcase *MessageCreate:\n\t\tif s.MaxMessageCount != 0 {\n\t\t\terr = s.MessageAdd(t.Message)\n\t\t}\n\tcase *MessageUpdate:\n\t\tif s.MaxMessageCount != 0 {\n\t\t\tvar old *Message\n\t\t\told, err = s.Message(t.ChannelID, t.ID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeUpdate = &oldCopy\n\t\t\t}\n\n\t\t\terr = s.MessageAdd(t.Message)\n\t\t}\n\tcase *MessageDelete:\n\t\tif s.MaxMessageCount != 0 {\n\t\t\tvar old *Message\n\t\t\told, err = s.Message(t.ChannelID, t.ID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeDelete = &oldCopy\n\t\t\t}\n\n\t\t\terr = s.MessageRemove(t.Message)\n\t\t}\n\tcase *MessageDeleteBulk:\n\t\tif s.MaxMessageCount != 0 {\n\t\t\tfor _, mID := range t.Messages {\n\t\t\t\ts.messageRemoveByID(t.ChannelID, mID)\n\t\t\t}\n\t\t}\n\tcase *VoiceStateUpdate:\n\t\tif s.TrackVoice {\n\t\t\tvar old *VoiceState\n\t\t\told, err = s.VoiceState(t.GuildID, t.UserID)\n\t\t\tif err == nil {\n\t\t\t\toldCopy := *old\n\t\t\t\tt.BeforeUpdate = &oldCopy\n\t\t\t}\n\n\t\t\terr = s.voiceStateUpdate(t)\n\t\t}\n\tcase *PresenceUpdate:\n\t\tif s.TrackPresences {\n\t\t\ts.PresenceAdd(t.GuildID, &t.Presence)\n\t\t}\n\t\tif s.TrackMembers {\n\t\t\tif t.Status == StatusOffline {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar m *Member\n\t\t\tm, err = s.Member(t.GuildID, t.User.ID)\n\n\t\t\tif err != nil {\n\t\t\t\t// Member not found; this is a user coming online\n\t\t\t\tm = &Member{\n\t\t\t\t\tGuildID: t.GuildID,\n\t\t\t\t\tUser:    t.User,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif t.User.Username != \"\" {\n\t\t\t\t\tm.User.Username = t.User.Username\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = s.MemberAdd(m)\n\t\t}\n\n\t}\n\n\treturn\n}\n\n// UserChannelPermissions returns the permission of a user in a channel.\n// userID    : The ID of the user to calculate permissions for.\n// channelID : The ID of the channel to calculate permission for.\nfunc (s *State) UserChannelPermissions(userID, channelID string) (apermissions int64, err error) {\n\tif s == nil {\n\t\treturn 0, ErrNilState\n\t}\n\n\tchannel, err := s.Channel(channelID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tguild, err := s.Guild(channel.GuildID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tmember, err := s.Member(guild.ID, userID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn memberPermissions(guild, channel, userID, member.Roles), nil\n}\n\n// MessagePermissions returns the permissions of the author of the message\n// in the channel in which it was sent.\nfunc (s *State) MessagePermissions(message *Message) (apermissions int64, err error) {\n\tif s == nil {\n\t\treturn 0, ErrNilState\n\t}\n\n\tif message.Author == nil || message.Member == nil {\n\t\treturn 0, ErrMessageIncompletePermissions\n\t}\n\n\tchannel, err := s.Channel(message.ChannelID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tguild, err := s.Guild(channel.GuildID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn memberPermissions(guild, channel, message.Author.ID, message.Member.Roles), nil\n}\n\n// UserColor returns the color of a user in a channel.\n// While colors are defined at a Guild level, determining for a channel is more useful in message handlers.\n// 0 is returned in cases of error, which is the color of @everyone.\n// userID    : The ID of the user to calculate the color for.\n// channelID   : The ID of the channel to calculate the color for.\nfunc (s *State) UserColor(userID, channelID string) int {\n\tif s == nil {\n\t\treturn 0\n\t}\n\n\tchannel, err := s.Channel(channelID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\tguild, err := s.Guild(channel.GuildID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\tmember, err := s.Member(guild.ID, userID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\treturn firstRoleColorColor(guild, member.Roles)\n}\n\n// MessageColor returns the color of the author's name as displayed\n// in the client associated with this message.\nfunc (s *State) MessageColor(message *Message) int {\n\tif s == nil {\n\t\treturn 0\n\t}\n\n\tif message.Member == nil || message.Member.Roles == nil {\n\t\treturn 0\n\t}\n\n\tchannel, err := s.Channel(message.ChannelID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\tguild, err := s.Guild(channel.GuildID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\treturn firstRoleColorColor(guild, message.Member.Roles)\n}\n\nfunc firstRoleColorColor(guild *Guild, memberRoles []string) int {\n\troles := Roles(guild.Roles)\n\tsort.Sort(roles)\n\n\tfor _, role := range roles {\n\t\tfor _, roleID := range memberRoles {\n\t\t\tif role.ID == roleID {\n\t\t\t\tif role.Color != 0 {\n\t\t\t\t\treturn role.Color\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, role := range roles {\n\t\tif role.ID == guild.ID {\n\t\t\treturn role.Color\n\t\t}\n\t}\n\n\treturn 0\n}\n"
        },
        {
          "name": "structs.go",
          "type": "blob",
          "size": 123.9521484375,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains all structures for the discordgo package.  These\n// may be moved about later into separate files but I find it easier to have\n// them all located together.\n\npackage discordgo\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// A Session represents a connection to the Discord API.\ntype Session struct {\n\tsync.RWMutex\n\n\t// General configurable settings.\n\n\t// Authentication token for this session\n\t// TODO: Remove Below, Deprecated, Use Identify struct\n\tToken string\n\n\tMFA bool\n\n\t// Debug for printing JSON request/responses\n\tDebug    bool // Deprecated, will be removed.\n\tLogLevel int\n\n\t// Should the session reconnect the websocket on errors.\n\tShouldReconnectOnError bool\n\n\t// Should voice connections reconnect on a session reconnect.\n\tShouldReconnectVoiceOnSessionError bool\n\n\t// Should the session retry requests when rate limited.\n\tShouldRetryOnRateLimit bool\n\n\t// Identify is sent during initial handshake with the discord gateway.\n\t// https://discord.com/developers/docs/topics/gateway#identify\n\tIdentify Identify\n\n\t// TODO: Remove Below, Deprecated, Use Identify struct\n\t// Should the session request compressed websocket data.\n\tCompress bool\n\n\t// Sharding\n\tShardID    int\n\tShardCount int\n\n\t// Should state tracking be enabled.\n\t// State tracking is the best way for getting the users\n\t// active guilds and the members of the guilds.\n\tStateEnabled bool\n\n\t// Whether or not to call event handlers synchronously.\n\t// e.g. false = launch event handlers in their own goroutines.\n\tSyncEvents bool\n\n\t// Exposed but should not be modified by User.\n\n\t// Whether the Data Websocket is ready\n\tDataReady bool // NOTE: Maye be deprecated soon\n\n\t// Max number of REST API retries\n\tMaxRestRetries int\n\n\t// Status stores the current status of the websocket connection\n\t// this is being tested, may stay, may go away.\n\tstatus int32\n\n\t// Whether the Voice Websocket is ready\n\tVoiceReady bool // NOTE: Deprecated.\n\n\t// Whether the UDP Connection is ready\n\tUDPReady bool // NOTE: Deprecated\n\n\t// Stores a mapping of guild id's to VoiceConnections\n\tVoiceConnections map[string]*VoiceConnection\n\n\t// Managed state object, updated internally with events when\n\t// StateEnabled is true.\n\tState *State\n\n\t// The http client used for REST requests\n\tClient *http.Client\n\n\t// The dialer used for WebSocket connection\n\tDialer *websocket.Dialer\n\n\t// The user agent used for REST APIs\n\tUserAgent string\n\n\t// Stores the last HeartbeatAck that was received (in UTC)\n\tLastHeartbeatAck time.Time\n\n\t// Stores the last Heartbeat sent (in UTC)\n\tLastHeartbeatSent time.Time\n\n\t// used to deal with rate limits\n\tRatelimiter *RateLimiter\n\n\t// Event handlers\n\thandlersMu   sync.RWMutex\n\thandlers     map[string][]*eventHandlerInstance\n\tonceHandlers map[string][]*eventHandlerInstance\n\n\t// The websocket connection.\n\twsConn *websocket.Conn\n\n\t// When nil, the session is not listening.\n\tlistening chan interface{}\n\n\t// sequence tracks the current gateway api websocket sequence number\n\tsequence *int64\n\n\t// stores sessions current Discord Gateway\n\tgateway string\n\n\t// stores session ID of current Gateway connection\n\tsessionID string\n\n\t// used to make sure gateway websocket writes do not happen concurrently\n\twsMutex sync.Mutex\n}\n\n// ApplicationIntegrationType dictates where application can be installed and its available interaction contexts.\ntype ApplicationIntegrationType uint\n\nconst (\n\t// ApplicationIntegrationGuildInstall indicates that app is installable to guilds.\n\tApplicationIntegrationGuildInstall ApplicationIntegrationType = 0\n\t// ApplicationIntegrationUserInstall indicates that app is installable to users.\n\tApplicationIntegrationUserInstall ApplicationIntegrationType = 1\n)\n\n// ApplicationInstallParams represents application's installation parameters\n// for default in-app oauth2 authorization link.\ntype ApplicationInstallParams struct {\n\tScopes      []string `json:\"scopes\"`\n\tPermissions int64    `json:\"permissions,string\"`\n}\n\n// ApplicationIntegrationTypeConfig represents application's configuration for a particular integration type.\ntype ApplicationIntegrationTypeConfig struct {\n\tOAuth2InstallParams *ApplicationInstallParams `json:\"oauth2_install_params,omitempty\"`\n}\n\n// Application stores values for a Discord Application\ntype Application struct {\n\tID                     string                                                           `json:\"id,omitempty\"`\n\tName                   string                                                           `json:\"name\"`\n\tIcon                   string                                                           `json:\"icon,omitempty\"`\n\tDescription            string                                                           `json:\"description,omitempty\"`\n\tRPCOrigins             []string                                                         `json:\"rpc_origins,omitempty\"`\n\tBotPublic              bool                                                             `json:\"bot_public,omitempty\"`\n\tBotRequireCodeGrant    bool                                                             `json:\"bot_require_code_grant,omitempty\"`\n\tTermsOfServiceURL      string                                                           `json:\"terms_of_service_url\"`\n\tPrivacyProxyURL        string                                                           `json:\"privacy_policy_url\"`\n\tOwner                  *User                                                            `json:\"owner\"`\n\tSummary                string                                                           `json:\"summary\"`\n\tVerifyKey              string                                                           `json:\"verify_key\"`\n\tTeam                   *Team                                                            `json:\"team\"`\n\tGuildID                string                                                           `json:\"guild_id\"`\n\tPrimarySKUID           string                                                           `json:\"primary_sku_id\"`\n\tSlug                   string                                                           `json:\"slug\"`\n\tCoverImage             string                                                           `json:\"cover_image\"`\n\tFlags                  int                                                              `json:\"flags,omitempty\"`\n\tIntegrationTypesConfig map[ApplicationIntegrationType]*ApplicationIntegrationTypeConfig `json:\"integration_types,omitempty\"`\n}\n\n// ApplicationRoleConnectionMetadataType represents the type of application role connection metadata.\ntype ApplicationRoleConnectionMetadataType int\n\n// Application role connection metadata types.\nconst (\n\tApplicationRoleConnectionMetadataIntegerLessThanOrEqual     ApplicationRoleConnectionMetadataType = 1\n\tApplicationRoleConnectionMetadataIntegerGreaterThanOrEqual  ApplicationRoleConnectionMetadataType = 2\n\tApplicationRoleConnectionMetadataIntegerEqual               ApplicationRoleConnectionMetadataType = 3\n\tApplicationRoleConnectionMetadataIntegerNotEqual            ApplicationRoleConnectionMetadataType = 4\n\tApplicationRoleConnectionMetadataDatetimeLessThanOrEqual    ApplicationRoleConnectionMetadataType = 5\n\tApplicationRoleConnectionMetadataDatetimeGreaterThanOrEqual ApplicationRoleConnectionMetadataType = 6\n\tApplicationRoleConnectionMetadataBooleanEqual               ApplicationRoleConnectionMetadataType = 7\n\tApplicationRoleConnectionMetadataBooleanNotEqual            ApplicationRoleConnectionMetadataType = 8\n)\n\n// ApplicationRoleConnectionMetadata stores application role connection metadata.\ntype ApplicationRoleConnectionMetadata struct {\n\tType                     ApplicationRoleConnectionMetadataType `json:\"type\"`\n\tKey                      string                                `json:\"key\"`\n\tName                     string                                `json:\"name\"`\n\tNameLocalizations        map[Locale]string                     `json:\"name_localizations\"`\n\tDescription              string                                `json:\"description\"`\n\tDescriptionLocalizations map[Locale]string                     `json:\"description_localizations\"`\n}\n\n// ApplicationRoleConnection represents the role connection that an application has attached to a user.\ntype ApplicationRoleConnection struct {\n\tPlatformName     string            `json:\"platform_name\"`\n\tPlatformUsername string            `json:\"platform_username\"`\n\tMetadata         map[string]string `json:\"metadata\"`\n}\n\n// UserConnection is a Connection returned from the UserConnections endpoint\ntype UserConnection struct {\n\tID           string         `json:\"id\"`\n\tName         string         `json:\"name\"`\n\tType         string         `json:\"type\"`\n\tRevoked      bool           `json:\"revoked\"`\n\tIntegrations []*Integration `json:\"integrations\"`\n}\n\n// Integration stores integration information\ntype Integration struct {\n\tID                string             `json:\"id\"`\n\tName              string             `json:\"name\"`\n\tType              string             `json:\"type\"`\n\tEnabled           bool               `json:\"enabled\"`\n\tSyncing           bool               `json:\"syncing\"`\n\tRoleID            string             `json:\"role_id\"`\n\tEnableEmoticons   bool               `json:\"enable_emoticons\"`\n\tExpireBehavior    ExpireBehavior     `json:\"expire_behavior\"`\n\tExpireGracePeriod int                `json:\"expire_grace_period\"`\n\tUser              *User              `json:\"user\"`\n\tAccount           IntegrationAccount `json:\"account\"`\n\tSyncedAt          time.Time          `json:\"synced_at\"`\n}\n\n// ExpireBehavior of Integration\n// https://discord.com/developers/docs/resources/guild#integration-object-integration-expire-behaviors\ntype ExpireBehavior int\n\n// Block of valid ExpireBehaviors\nconst (\n\tExpireBehaviorRemoveRole ExpireBehavior = 0\n\tExpireBehaviorKick       ExpireBehavior = 1\n)\n\n// IntegrationAccount is integration account information\n// sent by the UserConnections endpoint\ntype IntegrationAccount struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\n// A VoiceRegion stores data for a specific voice region server.\n// https://discord.com/developers/docs/resources/voice#voice-region-object\ntype VoiceRegion struct {\n\tID         string `json:\"id\"`\n\tName       string `json:\"name\"`\n\tOptimal    bool   `json:\"optimal\"`\n\tDeprecated bool   `json:\"deprecated\"`\n\tCustom     bool   `json:\"custom\"`\n}\n\n// InviteTargetType indicates the type of target of an invite\n// https://discord.com/developers/docs/resources/invite#invite-object-invite-target-types\ntype InviteTargetType uint8\n\n// Invite target types\nconst (\n\tInviteTargetStream              InviteTargetType = 1\n\tInviteTargetEmbeddedApplication InviteTargetType = 2\n)\n\n// A Invite stores all data related to a specific Discord Guild or Channel invite.\ntype Invite struct {\n\tGuild             *Guild           `json:\"guild\"`\n\tChannel           *Channel         `json:\"channel\"`\n\tInviter           *User            `json:\"inviter\"`\n\tCode              string           `json:\"code\"`\n\tCreatedAt         time.Time        `json:\"created_at\"`\n\tMaxAge            int              `json:\"max_age\"`\n\tUses              int              `json:\"uses\"`\n\tMaxUses           int              `json:\"max_uses\"`\n\tRevoked           bool             `json:\"revoked\"`\n\tTemporary         bool             `json:\"temporary\"`\n\tUnique            bool             `json:\"unique\"`\n\tTargetUser        *User            `json:\"target_user\"`\n\tTargetType        InviteTargetType `json:\"target_type\"`\n\tTargetApplication *Application     `json:\"target_application\"`\n\n\t// will only be filled when using InviteWithCounts\n\tApproximatePresenceCount int `json:\"approximate_presence_count\"`\n\tApproximateMemberCount   int `json:\"approximate_member_count\"`\n\n\tExpiresAt *time.Time `json:\"expires_at\"`\n}\n\n// ChannelType is the type of a Channel\ntype ChannelType int\n\n// Block contains known ChannelType values\nconst (\n\tChannelTypeGuildText          ChannelType = 0\n\tChannelTypeDM                 ChannelType = 1\n\tChannelTypeGuildVoice         ChannelType = 2\n\tChannelTypeGroupDM            ChannelType = 3\n\tChannelTypeGuildCategory      ChannelType = 4\n\tChannelTypeGuildNews          ChannelType = 5\n\tChannelTypeGuildStore         ChannelType = 6\n\tChannelTypeGuildNewsThread    ChannelType = 10\n\tChannelTypeGuildPublicThread  ChannelType = 11\n\tChannelTypeGuildPrivateThread ChannelType = 12\n\tChannelTypeGuildStageVoice    ChannelType = 13\n\tChannelTypeGuildDirectory     ChannelType = 14\n\tChannelTypeGuildForum         ChannelType = 15\n\tChannelTypeGuildMedia         ChannelType = 16\n)\n\n// ChannelFlags represent flags of a channel/thread.\ntype ChannelFlags int\n\n// Block containing known ChannelFlags values.\nconst (\n\t// ChannelFlagPinned indicates whether the thread is pinned in the forum channel.\n\t// NOTE: forum threads only.\n\tChannelFlagPinned ChannelFlags = 1 << 1\n\t// ChannelFlagRequireTag indicates whether a tag is required to be specified when creating a thread.\n\t// NOTE: forum channels only.\n\tChannelFlagRequireTag ChannelFlags = 1 << 4\n)\n\n// ForumSortOrderType represents sort order of a forum channel.\ntype ForumSortOrderType int\n\nconst (\n\t// ForumSortOrderLatestActivity sorts posts by activity.\n\tForumSortOrderLatestActivity ForumSortOrderType = 0\n\t// ForumSortOrderCreationDate sorts posts by creation time (from most recent to oldest).\n\tForumSortOrderCreationDate ForumSortOrderType = 1\n)\n\n// ForumLayout represents layout of a forum channel.\ntype ForumLayout int\n\nconst (\n\t// ForumLayoutNotSet represents no default layout.\n\tForumLayoutNotSet ForumLayout = 0\n\t// ForumLayoutListView displays forum posts as a list.\n\tForumLayoutListView ForumLayout = 1\n\t// ForumLayoutGalleryView displays forum posts as a collection of tiles.\n\tForumLayoutGalleryView ForumLayout = 2\n)\n\n// A Channel holds all data related to an individual Discord channel.\ntype Channel struct {\n\t// The ID of the channel.\n\tID string `json:\"id\"`\n\n\t// The ID of the guild to which the channel belongs, if it is in a guild.\n\t// Else, this ID is empty (e.g. DM channels).\n\tGuildID string `json:\"guild_id\"`\n\n\t// The name of the channel.\n\tName string `json:\"name\"`\n\n\t// The topic of the channel.\n\tTopic string `json:\"topic\"`\n\n\t// The type of the channel.\n\tType ChannelType `json:\"type\"`\n\n\t// The ID of the last message sent in the channel. This is not\n\t// guaranteed to be an ID of a valid message.\n\tLastMessageID string `json:\"last_message_id\"`\n\n\t// The timestamp of the last pinned message in the channel.\n\t// nil if the channel has no pinned messages.\n\tLastPinTimestamp *time.Time `json:\"last_pin_timestamp\"`\n\n\t// An approximate count of messages in a thread, stops counting at 50\n\tMessageCount int `json:\"message_count\"`\n\t// An approximate count of users in a thread, stops counting at 50\n\tMemberCount int `json:\"member_count\"`\n\n\t// Whether the channel is marked as NSFW.\n\tNSFW bool `json:\"nsfw\"`\n\n\t// Icon of the group DM channel.\n\tIcon string `json:\"icon\"`\n\n\t// The position of the channel, used for sorting in client.\n\tPosition int `json:\"position\"`\n\n\t// The bitrate of the channel, if it is a voice channel.\n\tBitrate int `json:\"bitrate\"`\n\n\t// The recipients of the channel. This is only populated in DM channels.\n\tRecipients []*User `json:\"recipients\"`\n\n\t// The messages in the channel. This is only present in state-cached channels,\n\t// and State.MaxMessageCount must be non-zero.\n\tMessages []*Message `json:\"-\"`\n\n\t// A list of permission overwrites present for the channel.\n\tPermissionOverwrites []*PermissionOverwrite `json:\"permission_overwrites\"`\n\n\t// The user limit of the voice channel.\n\tUserLimit int `json:\"user_limit\"`\n\n\t// The ID of the parent channel, if the channel is under a category. For threads - id of the channel thread was created in.\n\tParentID string `json:\"parent_id\"`\n\n\t// Amount of seconds a user has to wait before sending another message or creating another thread (0-21600)\n\t// bots, as well as users with the permission manage_messages or manage_channel, are unaffected\n\tRateLimitPerUser int `json:\"rate_limit_per_user\"`\n\n\t// ID of the creator of the group DM or thread\n\tOwnerID string `json:\"owner_id\"`\n\n\t// ApplicationID of the DM creator Zeroed if guild channel or not a bot user\n\tApplicationID string `json:\"application_id\"`\n\n\t// Thread-specific fields not needed by other channels\n\tThreadMetadata *ThreadMetadata `json:\"thread_metadata,omitempty\"`\n\t// Thread member object for the current user, if they have joined the thread, only included on certain API endpoints\n\tMember *ThreadMember `json:\"thread_member\"`\n\n\t// All thread members. State channels only.\n\tMembers []*ThreadMember `json:\"-\"`\n\n\t// Channel flags.\n\tFlags ChannelFlags `json:\"flags\"`\n\n\t// The set of tags that can be used in a forum channel.\n\tAvailableTags []ForumTag `json:\"available_tags\"`\n\n\t// The IDs of the set of tags that have been applied to a thread in a forum channel.\n\tAppliedTags []string `json:\"applied_tags\"`\n\n\t// Emoji to use as the default reaction to a forum post.\n\tDefaultReactionEmoji ForumDefaultReaction `json:\"default_reaction_emoji\"`\n\n\t// The initial RateLimitPerUser to set on newly created threads in a channel.\n\t// This field is copied to the thread at creation time and does not live update.\n\tDefaultThreadRateLimitPerUser int `json:\"default_thread_rate_limit_per_user\"`\n\n\t// The default sort order type used to order posts in forum channels.\n\t// Defaults to null, which indicates a preferred sort order hasn't been set by a channel admin.\n\tDefaultSortOrder *ForumSortOrderType `json:\"default_sort_order\"`\n\n\t// The default forum layout view used to display posts in forum channels.\n\t// Defaults to ForumLayoutNotSet, which indicates a layout view has not been set by a channel admin.\n\tDefaultForumLayout ForumLayout `json:\"default_forum_layout\"`\n}\n\n// Mention returns a string which mentions the channel\nfunc (c *Channel) Mention() string {\n\treturn fmt.Sprintf(\"<#%s>\", c.ID)\n}\n\n// IsThread is a helper function to determine if channel is a thread or not\nfunc (c *Channel) IsThread() bool {\n\treturn c.Type == ChannelTypeGuildPublicThread || c.Type == ChannelTypeGuildPrivateThread || c.Type == ChannelTypeGuildNewsThread\n}\n\n// A ChannelEdit holds Channel Field data for a channel edit.\ntype ChannelEdit struct {\n\tName                          string                 `json:\"name,omitempty\"`\n\tTopic                         string                 `json:\"topic,omitempty\"`\n\tNSFW                          *bool                  `json:\"nsfw,omitempty\"`\n\tPosition                      *int                   `json:\"position,omitempty\"`\n\tBitrate                       int                    `json:\"bitrate,omitempty\"`\n\tUserLimit                     int                    `json:\"user_limit,omitempty\"`\n\tPermissionOverwrites          []*PermissionOverwrite `json:\"permission_overwrites,omitempty\"`\n\tParentID                      string                 `json:\"parent_id,omitempty\"`\n\tRateLimitPerUser              *int                   `json:\"rate_limit_per_user,omitempty\"`\n\tFlags                         *ChannelFlags          `json:\"flags,omitempty\"`\n\tDefaultThreadRateLimitPerUser *int                   `json:\"default_thread_rate_limit_per_user,omitempty\"`\n\n\t// NOTE: threads only\n\n\tArchived            *bool `json:\"archived,omitempty\"`\n\tAutoArchiveDuration int   `json:\"auto_archive_duration,omitempty\"`\n\tLocked              *bool `json:\"locked,omitempty\"`\n\tInvitable           *bool `json:\"invitable,omitempty\"`\n\n\t// NOTE: forum channels only\n\n\tAvailableTags        *[]ForumTag           `json:\"available_tags,omitempty\"`\n\tDefaultReactionEmoji *ForumDefaultReaction `json:\"default_reaction_emoji,omitempty\"`\n\tDefaultSortOrder     *ForumSortOrderType   `json:\"default_sort_order,omitempty\"` // TODO: null\n\tDefaultForumLayout   *ForumLayout          `json:\"default_forum_layout,omitempty\"`\n\n\t// NOTE: forum threads only\n\tAppliedTags *[]string `json:\"applied_tags,omitempty\"`\n}\n\n// A ChannelFollow holds data returned after following a news channel\ntype ChannelFollow struct {\n\tChannelID string `json:\"channel_id\"`\n\tWebhookID string `json:\"webhook_id\"`\n}\n\n// PermissionOverwriteType represents the type of resource on which\n// a permission overwrite acts.\ntype PermissionOverwriteType int\n\n// The possible permission overwrite types.\nconst (\n\tPermissionOverwriteTypeRole   PermissionOverwriteType = 0\n\tPermissionOverwriteTypeMember PermissionOverwriteType = 1\n)\n\n// A PermissionOverwrite holds permission overwrite data for a Channel\ntype PermissionOverwrite struct {\n\tID    string                  `json:\"id\"`\n\tType  PermissionOverwriteType `json:\"type\"`\n\tDeny  int64                   `json:\"deny,string\"`\n\tAllow int64                   `json:\"allow,string\"`\n}\n\n// ThreadStart stores all parameters you can use with MessageThreadStartComplex or ThreadStartComplex\ntype ThreadStart struct {\n\tName                string      `json:\"name\"`\n\tAutoArchiveDuration int         `json:\"auto_archive_duration,omitempty\"`\n\tType                ChannelType `json:\"type,omitempty\"`\n\tInvitable           bool        `json:\"invitable\"`\n\tRateLimitPerUser    int         `json:\"rate_limit_per_user,omitempty\"`\n\n\t// NOTE: forum threads only\n\tAppliedTags []string `json:\"applied_tags,omitempty\"`\n}\n\n// ThreadMetadata contains a number of thread-specific channel fields that are not needed by other channel types.\ntype ThreadMetadata struct {\n\t// Whether the thread is archived\n\tArchived bool `json:\"archived\"`\n\t// Duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080\n\tAutoArchiveDuration int `json:\"auto_archive_duration\"`\n\t// Timestamp when the thread's archive status was last changed, used for calculating recent activity\n\tArchiveTimestamp time.Time `json:\"archive_timestamp\"`\n\t// Whether the thread is locked; when a thread is locked, only users with MANAGE_THREADS can unarchive it\n\tLocked bool `json:\"locked\"`\n\t// Whether non-moderators can add other non-moderators to a thread; only available on private threads\n\tInvitable bool `json:\"invitable\"`\n}\n\n// ThreadMember is used to indicate whether a user has joined a thread or not.\n// NOTE: ID and UserID are empty (omitted) on the member sent within each thread in the GUILD_CREATE event.\ntype ThreadMember struct {\n\t// The id of the thread\n\tID string `json:\"id,omitempty\"`\n\t// The id of the user\n\tUserID string `json:\"user_id,omitempty\"`\n\t// The time the current user last joined the thread\n\tJoinTimestamp time.Time `json:\"join_timestamp\"`\n\t// Any user-thread settings, currently only used for notifications\n\tFlags int `json:\"flags\"`\n\t// Additional information about the user.\n\t// NOTE: only present if the withMember parameter is set to true\n\t// when calling Session.ThreadMembers or Session.ThreadMember.\n\tMember *Member `json:\"member,omitempty\"`\n}\n\n// ThreadsList represents a list of threads alongisde with thread member objects for the current user.\ntype ThreadsList struct {\n\tThreads []*Channel      `json:\"threads\"`\n\tMembers []*ThreadMember `json:\"members\"`\n\tHasMore bool            `json:\"has_more\"`\n}\n\n// AddedThreadMember holds information about the user who was added to the thread\ntype AddedThreadMember struct {\n\t*ThreadMember\n\tMember   *Member   `json:\"member\"`\n\tPresence *Presence `json:\"presence\"`\n}\n\n// ForumDefaultReaction specifies emoji to use as the default reaction to a forum post.\n// NOTE: Exactly one of EmojiID and EmojiName must be set.\ntype ForumDefaultReaction struct {\n\t// The id of a guild's custom emoji.\n\tEmojiID string `json:\"emoji_id,omitempty\"`\n\t// The unicode character of the emoji.\n\tEmojiName string `json:\"emoji_name,omitempty\"`\n}\n\n// ForumTag represents a tag that is able to be applied to a thread in a forum channel.\ntype ForumTag struct {\n\tID        string `json:\"id,omitempty\"`\n\tName      string `json:\"name\"`\n\tModerated bool   `json:\"moderated\"`\n\tEmojiID   string `json:\"emoji_id,omitempty\"`\n\tEmojiName string `json:\"emoji_name,omitempty\"`\n}\n\n// Emoji struct holds data related to Emoji's\ntype Emoji struct {\n\tID            string   `json:\"id\"`\n\tName          string   `json:\"name\"`\n\tRoles         []string `json:\"roles\"`\n\tUser          *User    `json:\"user\"`\n\tRequireColons bool     `json:\"require_colons\"`\n\tManaged       bool     `json:\"managed\"`\n\tAnimated      bool     `json:\"animated\"`\n\tAvailable     bool     `json:\"available\"`\n}\n\n// EmojiRegex is the regex used to find and identify emojis in messages\nvar (\n\tEmojiRegex = regexp.MustCompile(`<(a|):[A-z0-9_~]+:[0-9]{18,20}>`)\n)\n\n// MessageFormat returns a correctly formatted Emoji for use in Message content and embeds\nfunc (e *Emoji) MessageFormat() string {\n\tif e.ID != \"\" && e.Name != \"\" {\n\t\tif e.Animated {\n\t\t\treturn \"<a:\" + e.APIName() + \">\"\n\t\t}\n\n\t\treturn \"<:\" + e.APIName() + \">\"\n\t}\n\n\treturn e.APIName()\n}\n\n// APIName returns an correctly formatted API name for use in the MessageReactions endpoints.\nfunc (e *Emoji) APIName() string {\n\tif e.ID != \"\" && e.Name != \"\" {\n\t\treturn e.Name + \":\" + e.ID\n\t}\n\tif e.Name != \"\" {\n\t\treturn e.Name\n\t}\n\treturn e.ID\n}\n\n// EmojiParams represents parameters needed to create or update an Emoji.\ntype EmojiParams struct {\n\t// Name of the emoji\n\tName string `json:\"name,omitempty\"`\n\t// A base64 encoded emoji image, has to be smaller than 256KB.\n\t// NOTE: can be only set on creation.\n\tImage string `json:\"image,omitempty\"`\n\t// Roles for which this emoji will be available.\n\t// NOTE: can not be used with application emoji endpoints.\n\tRoles []string `json:\"roles,omitempty\"`\n}\n\n// StickerFormat is the file format of the Sticker.\ntype StickerFormat int\n\n// Defines all known Sticker types.\nconst (\n\tStickerFormatTypePNG    StickerFormat = 1\n\tStickerFormatTypeAPNG   StickerFormat = 2\n\tStickerFormatTypeLottie StickerFormat = 3\n\tStickerFormatTypeGIF    StickerFormat = 4\n)\n\n// StickerType is the type of sticker.\ntype StickerType int\n\n// Defines Sticker types.\nconst (\n\tStickerTypeStandard StickerType = 1\n\tStickerTypeGuild    StickerType = 2\n)\n\n// Sticker represents a sticker object that can be sent in a Message.\ntype Sticker struct {\n\tID          string        `json:\"id\"`\n\tPackID      string        `json:\"pack_id\"`\n\tName        string        `json:\"name\"`\n\tDescription string        `json:\"description\"`\n\tTags        string        `json:\"tags\"`\n\tType        StickerType   `json:\"type\"`\n\tFormatType  StickerFormat `json:\"format_type\"`\n\tAvailable   bool          `json:\"available\"`\n\tGuildID     string        `json:\"guild_id\"`\n\tUser        *User         `json:\"user\"`\n\tSortValue   int           `json:\"sort_value\"`\n}\n\n// StickerItem represents the smallest amount of data required to render a sticker. A partial sticker object.\ntype StickerItem struct {\n\tID         string        `json:\"id\"`\n\tName       string        `json:\"name\"`\n\tFormatType StickerFormat `json:\"format_type\"`\n}\n\n// StickerPack represents a pack of standard stickers.\ntype StickerPack struct {\n\tID             string     `json:\"id\"`\n\tStickers       []*Sticker `json:\"stickers\"`\n\tName           string     `json:\"name\"`\n\tSKUID          string     `json:\"sku_id\"`\n\tCoverStickerID string     `json:\"cover_sticker_id\"`\n\tDescription    string     `json:\"description\"`\n\tBannerAssetID  string     `json:\"banner_asset_id\"`\n}\n\n// VerificationLevel type definition\ntype VerificationLevel int\n\n// Constants for VerificationLevel levels from 0 to 4 inclusive\nconst (\n\tVerificationLevelNone     VerificationLevel = 0\n\tVerificationLevelLow      VerificationLevel = 1\n\tVerificationLevelMedium   VerificationLevel = 2\n\tVerificationLevelHigh     VerificationLevel = 3\n\tVerificationLevelVeryHigh VerificationLevel = 4\n)\n\n// ExplicitContentFilterLevel type definition\ntype ExplicitContentFilterLevel int\n\n// Constants for ExplicitContentFilterLevel levels from 0 to 2 inclusive\nconst (\n\tExplicitContentFilterDisabled            ExplicitContentFilterLevel = 0\n\tExplicitContentFilterMembersWithoutRoles ExplicitContentFilterLevel = 1\n\tExplicitContentFilterAllMembers          ExplicitContentFilterLevel = 2\n)\n\n// GuildNSFWLevel type definition\ntype GuildNSFWLevel int\n\n// Constants for GuildNSFWLevel levels from 0 to 3 inclusive\nconst (\n\tGuildNSFWLevelDefault       GuildNSFWLevel = 0\n\tGuildNSFWLevelExplicit      GuildNSFWLevel = 1\n\tGuildNSFWLevelSafe          GuildNSFWLevel = 2\n\tGuildNSFWLevelAgeRestricted GuildNSFWLevel = 3\n)\n\n// MfaLevel type definition\ntype MfaLevel int\n\n// Constants for MfaLevel levels from 0 to 1 inclusive\nconst (\n\tMfaLevelNone     MfaLevel = 0\n\tMfaLevelElevated MfaLevel = 1\n)\n\n// PremiumTier type definition\ntype PremiumTier int\n\n// Constants for PremiumTier levels from 0 to 3 inclusive\nconst (\n\tPremiumTierNone PremiumTier = 0\n\tPremiumTier1    PremiumTier = 1\n\tPremiumTier2    PremiumTier = 2\n\tPremiumTier3    PremiumTier = 3\n)\n\n// A Guild holds all data related to a specific Discord Guild.  Guilds are also\n// sometimes referred to as Servers in the Discord client.\ntype Guild struct {\n\t// The ID of the guild.\n\tID string `json:\"id\"`\n\n\t// The name of the guild. (2–100 characters)\n\tName string `json:\"name\"`\n\n\t// The hash of the guild's icon. Use Session.GuildIcon\n\t// to retrieve the icon itself.\n\tIcon string `json:\"icon\"`\n\n\t// The voice region of the guild.\n\tRegion string `json:\"region\"`\n\n\t// The ID of the AFK voice channel.\n\tAfkChannelID string `json:\"afk_channel_id\"`\n\n\t// The user ID of the owner of the guild.\n\tOwnerID string `json:\"owner_id\"`\n\n\t// If we are the owner of the guild\n\tOwner bool `json:\"owner\"`\n\n\t// The time at which the current user joined the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tJoinedAt time.Time `json:\"joined_at\"`\n\n\t// The hash of the guild's discovery splash.\n\tDiscoverySplash string `json:\"discovery_splash\"`\n\n\t// The hash of the guild's splash.\n\tSplash string `json:\"splash\"`\n\n\t// The timeout, in seconds, before a user is considered AFK in voice.\n\tAfkTimeout int `json:\"afk_timeout\"`\n\n\t// The number of members in the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tMemberCount int `json:\"member_count\"`\n\n\t// The verification level required for the guild.\n\tVerificationLevel VerificationLevel `json:\"verification_level\"`\n\n\t// Whether the guild is considered large. This is\n\t// determined by a member threshold in the identify packet,\n\t// and is currently hard-coded at 250 members in the library.\n\tLarge bool `json:\"large\"`\n\n\t// The default message notification setting for the guild.\n\tDefaultMessageNotifications MessageNotifications `json:\"default_message_notifications\"`\n\n\t// A list of roles in the guild.\n\tRoles []*Role `json:\"roles\"`\n\n\t// A list of the custom emojis present in the guild.\n\tEmojis []*Emoji `json:\"emojis\"`\n\n\t// A list of the custom stickers present in the guild.\n\tStickers []*Sticker `json:\"stickers\"`\n\n\t// A list of the members in the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tMembers []*Member `json:\"members\"`\n\n\t// A list of partial presence objects for members in the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tPresences []*Presence `json:\"presences\"`\n\n\t// The maximum number of presences for the guild (the default value, currently 25000, is in effect when null is returned)\n\tMaxPresences int `json:\"max_presences\"`\n\n\t// The maximum number of members for the guild\n\tMaxMembers int `json:\"max_members\"`\n\n\t// A list of channels in the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tChannels []*Channel `json:\"channels\"`\n\n\t// A list of all active threads in the guild that current user has permission to view\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events and thus is only present in state-cached guilds.\n\tThreads []*Channel `json:\"threads\"`\n\n\t// A list of voice states for the guild.\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tVoiceStates []*VoiceState `json:\"voice_states\"`\n\n\t// Whether this guild is currently unavailable (most likely due to outage).\n\t// This field is only present in GUILD_CREATE events and websocket\n\t// update events, and thus is only present in state-cached guilds.\n\tUnavailable bool `json:\"unavailable\"`\n\n\t// The explicit content filter level\n\tExplicitContentFilter ExplicitContentFilterLevel `json:\"explicit_content_filter\"`\n\n\t// The NSFW Level of the guild\n\tNSFWLevel GuildNSFWLevel `json:\"nsfw_level\"`\n\n\t// The list of enabled guild features\n\tFeatures []GuildFeature `json:\"features\"`\n\n\t// Required MFA level for the guild\n\tMfaLevel MfaLevel `json:\"mfa_level\"`\n\n\t// The application id of the guild if bot created.\n\tApplicationID string `json:\"application_id\"`\n\n\t// Whether or not the Server Widget is enabled\n\tWidgetEnabled bool `json:\"widget_enabled\"`\n\n\t// The Channel ID for the Server Widget\n\tWidgetChannelID string `json:\"widget_channel_id\"`\n\n\t// The Channel ID to which system messages are sent (eg join and leave messages)\n\tSystemChannelID string `json:\"system_channel_id\"`\n\n\t// The System channel flags\n\tSystemChannelFlags SystemChannelFlag `json:\"system_channel_flags\"`\n\n\t// The ID of the rules channel ID, used for rules.\n\tRulesChannelID string `json:\"rules_channel_id\"`\n\n\t// the vanity url code for the guild\n\tVanityURLCode string `json:\"vanity_url_code\"`\n\n\t// the description for the guild\n\tDescription string `json:\"description\"`\n\n\t// The hash of the guild's banner\n\tBanner string `json:\"banner\"`\n\n\t// The premium tier of the guild\n\tPremiumTier PremiumTier `json:\"premium_tier\"`\n\n\t// The total number of users currently boosting this server\n\tPremiumSubscriptionCount int `json:\"premium_subscription_count\"`\n\n\t// The preferred locale of a guild with the \"PUBLIC\" feature; used in server discovery and notices from Discord; defaults to \"en-US\"\n\tPreferredLocale string `json:\"preferred_locale\"`\n\n\t// The id of the channel where admins and moderators of guilds with the \"PUBLIC\" feature receive notices from Discord\n\tPublicUpdatesChannelID string `json:\"public_updates_channel_id\"`\n\n\t// The maximum amount of users in a video channel\n\tMaxVideoChannelUsers int `json:\"max_video_channel_users\"`\n\n\t// Approximate number of members in this guild, returned from the GET /guild/<id> endpoint when with_counts is true\n\tApproximateMemberCount int `json:\"approximate_member_count\"`\n\n\t// Approximate number of non-offline members in this guild, returned from the GET /guild/<id> endpoint when with_counts is true\n\tApproximatePresenceCount int `json:\"approximate_presence_count\"`\n\n\t// Permissions of our user\n\tPermissions int64 `json:\"permissions,string\"`\n\n\t// Stage instances in the guild\n\tStageInstances []*StageInstance `json:\"stage_instances\"`\n}\n\n// A GuildPreview holds data related to a specific public Discord Guild, even if the user is not in the guild.\ntype GuildPreview struct {\n\t// The ID of the guild.\n\tID string `json:\"id\"`\n\n\t// The name of the guild. (2–100 characters)\n\tName string `json:\"name\"`\n\n\t// The hash of the guild's icon. Use Session.GuildIcon\n\t// to retrieve the icon itself.\n\tIcon string `json:\"icon\"`\n\n\t// The hash of the guild's splash.\n\tSplash string `json:\"splash\"`\n\n\t// The hash of the guild's discovery splash.\n\tDiscoverySplash string `json:\"discovery_splash\"`\n\n\t// A list of the custom emojis present in the guild.\n\tEmojis []*Emoji `json:\"emojis\"`\n\n\t// The list of enabled guild features\n\tFeatures []string `json:\"features\"`\n\n\t// Approximate number of members in this guild\n\t// NOTE: this field is only filled when using GuildWithCounts\n\tApproximateMemberCount int `json:\"approximate_member_count\"`\n\n\t// Approximate number of non-offline members in this guild\n\t// NOTE: this field is only filled when using GuildWithCounts\n\tApproximatePresenceCount int `json:\"approximate_presence_count\"`\n\n\t// the description for the guild\n\tDescription string `json:\"description\"`\n}\n\n// IconURL returns a URL to the guild's icon.\n//\n//\tsize:    The size of the desired icon image as a power of two\n//\t         Image size can be any power of two between 16 and 4096.\nfunc (g *GuildPreview) IconURL(size string) string {\n\treturn iconURL(g.Icon, EndpointGuildIcon(g.ID, g.Icon), EndpointGuildIconAnimated(g.ID, g.Icon), size)\n}\n\n// GuildScheduledEvent is a representation of a scheduled event in a guild. Only for retrieval of the data.\n// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event\ntype GuildScheduledEvent struct {\n\t// The ID of the scheduled event\n\tID string `json:\"id\"`\n\t// The guild id which the scheduled event belongs to\n\tGuildID string `json:\"guild_id\"`\n\t// The channel id in which the scheduled event will be hosted, or null if scheduled entity type is EXTERNAL\n\tChannelID string `json:\"channel_id\"`\n\t// The id of the user that created the scheduled event\n\tCreatorID string `json:\"creator_id\"`\n\t// The name of the scheduled event (1-100 characters)\n\tName string `json:\"name\"`\n\t// The description of the scheduled event (1-1000 characters)\n\tDescription string `json:\"description\"`\n\t// The time the scheduled event will start\n\tScheduledStartTime time.Time `json:\"scheduled_start_time\"`\n\t// The time the scheduled event will end, required only when entity_type is EXTERNAL\n\tScheduledEndTime *time.Time `json:\"scheduled_end_time\"`\n\t// The privacy level of the scheduled event\n\tPrivacyLevel GuildScheduledEventPrivacyLevel `json:\"privacy_level\"`\n\t// The status of the scheduled event\n\tStatus GuildScheduledEventStatus `json:\"status\"`\n\t// Type of the entity where event would be hosted\n\t// See field requirements\n\t// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-field-requirements-by-entity-type\n\tEntityType GuildScheduledEventEntityType `json:\"entity_type\"`\n\t// The id of an entity associated with a guild scheduled event\n\tEntityID string `json:\"entity_id\"`\n\t// Additional metadata for the guild scheduled event\n\tEntityMetadata GuildScheduledEventEntityMetadata `json:\"entity_metadata\"`\n\t// The user that created the scheduled event\n\tCreator *User `json:\"creator\"`\n\t// The number of users subscribed to the scheduled event\n\tUserCount int `json:\"user_count\"`\n\t// The cover image hash of the scheduled event\n\t// see https://discord.com/developers/docs/reference#image-formatting for more\n\t// information about image formatting\n\tImage string `json:\"image\"`\n}\n\n// GuildScheduledEventParams are the parameters allowed for creating or updating a scheduled event\n// https://discord.com/developers/docs/resources/guild-scheduled-event#create-guild-scheduled-event\ntype GuildScheduledEventParams struct {\n\t// The channel id in which the scheduled event will be hosted, or null if scheduled entity type is EXTERNAL\n\tChannelID string `json:\"channel_id,omitempty\"`\n\t// The name of the scheduled event (1-100 characters)\n\tName string `json:\"name,omitempty\"`\n\t// The description of the scheduled event (1-1000 characters)\n\tDescription string `json:\"description,omitempty\"`\n\t// The time the scheduled event will start\n\tScheduledStartTime *time.Time `json:\"scheduled_start_time,omitempty\"`\n\t// The time the scheduled event will end, required only when entity_type is EXTERNAL\n\tScheduledEndTime *time.Time `json:\"scheduled_end_time,omitempty\"`\n\t// The privacy level of the scheduled event\n\tPrivacyLevel GuildScheduledEventPrivacyLevel `json:\"privacy_level,omitempty\"`\n\t// The status of the scheduled event\n\tStatus GuildScheduledEventStatus `json:\"status,omitempty\"`\n\t// Type of the entity where event would be hosted\n\t// See field requirements\n\t// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-field-requirements-by-entity-type\n\tEntityType GuildScheduledEventEntityType `json:\"entity_type,omitempty\"`\n\t// Additional metadata for the guild scheduled event\n\tEntityMetadata *GuildScheduledEventEntityMetadata `json:\"entity_metadata,omitempty\"`\n\t// The cover image hash of the scheduled event\n\t// see https://discord.com/developers/docs/reference#image-formatting for more\n\t// information about image formatting\n\tImage string `json:\"image,omitempty\"`\n}\n\n// MarshalJSON is a helper function to marshal GuildScheduledEventParams\nfunc (p GuildScheduledEventParams) MarshalJSON() ([]byte, error) {\n\ttype guildScheduledEventParams GuildScheduledEventParams\n\n\tif p.EntityType == GuildScheduledEventEntityTypeExternal && p.ChannelID == \"\" {\n\t\treturn Marshal(struct {\n\t\t\tguildScheduledEventParams\n\t\t\tChannelID json.RawMessage `json:\"channel_id\"`\n\t\t}{\n\t\t\tguildScheduledEventParams: guildScheduledEventParams(p),\n\t\t\tChannelID:                 json.RawMessage(\"null\"),\n\t\t})\n\t}\n\n\treturn Marshal(guildScheduledEventParams(p))\n}\n\n// GuildScheduledEventEntityMetadata holds additional metadata for guild scheduled event.\ntype GuildScheduledEventEntityMetadata struct {\n\t// location of the event (1-100 characters)\n\t// required for events with 'entity_type': EXTERNAL\n\tLocation string `json:\"location\"`\n}\n\n// GuildScheduledEventPrivacyLevel is the privacy level of a scheduled event.\n// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-privacy-level\ntype GuildScheduledEventPrivacyLevel int\n\nconst (\n\t// GuildScheduledEventPrivacyLevelGuildOnly makes the scheduled\n\t// event is only accessible to guild members\n\tGuildScheduledEventPrivacyLevelGuildOnly GuildScheduledEventPrivacyLevel = 2\n)\n\n// GuildScheduledEventStatus is the status of a scheduled event\n// Valid Guild Scheduled Event Status Transitions :\n// SCHEDULED --> ACTIVE --> COMPLETED\n// SCHEDULED --> CANCELED\n// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-status\ntype GuildScheduledEventStatus int\n\nconst (\n\t// GuildScheduledEventStatusScheduled represents the current event is in scheduled state\n\tGuildScheduledEventStatusScheduled GuildScheduledEventStatus = 1\n\t// GuildScheduledEventStatusActive represents the current event is in active state\n\tGuildScheduledEventStatusActive GuildScheduledEventStatus = 2\n\t// GuildScheduledEventStatusCompleted represents the current event is in completed state\n\tGuildScheduledEventStatusCompleted GuildScheduledEventStatus = 3\n\t// GuildScheduledEventStatusCanceled represents the current event is in canceled state\n\tGuildScheduledEventStatusCanceled GuildScheduledEventStatus = 4\n)\n\n// GuildScheduledEventEntityType is the type of entity associated with a guild scheduled event.\n// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-entity-types\ntype GuildScheduledEventEntityType int\n\nconst (\n\t// GuildScheduledEventEntityTypeStageInstance represents a stage channel\n\tGuildScheduledEventEntityTypeStageInstance GuildScheduledEventEntityType = 1\n\t// GuildScheduledEventEntityTypeVoice represents a voice channel\n\tGuildScheduledEventEntityTypeVoice GuildScheduledEventEntityType = 2\n\t// GuildScheduledEventEntityTypeExternal represents an external event\n\tGuildScheduledEventEntityTypeExternal GuildScheduledEventEntityType = 3\n)\n\n// GuildScheduledEventUser is a user subscribed to a scheduled event.\n// https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-user-object\ntype GuildScheduledEventUser struct {\n\tGuildScheduledEventID string  `json:\"guild_scheduled_event_id\"`\n\tUser                  *User   `json:\"user\"`\n\tMember                *Member `json:\"member\"`\n}\n\n// GuildOnboardingMode defines the criteria used to satisfy constraints that are required for enabling onboarding.\n// https://discord.com/developers/docs/resources/guild#guild-onboarding-object-onboarding-mode\ntype GuildOnboardingMode int\n\n// Block containing known GuildOnboardingMode values.\nconst (\n\t// GuildOnboardingModeDefault counts default channels towards constraints.\n\tGuildOnboardingModeDefault GuildOnboardingMode = 0\n\t// GuildOnboardingModeAdvanced counts default channels and questions towards constraints.\n\tGuildOnboardingModeAdvanced GuildOnboardingMode = 1\n)\n\n// GuildOnboarding represents the onboarding flow for a guild.\n// https://discord.com/developers/docs/resources/guild#guild-onboarding-object\ntype GuildOnboarding struct {\n\t// ID of the guild this onboarding flow is part of.\n\tGuildID string `json:\"guild_id,omitempty\"`\n\n\t// Prompts shown during onboarding and in the customize community (Channels & Roles) tab.\n\tPrompts *[]GuildOnboardingPrompt `json:\"prompts,omitempty\"`\n\n\t// Channel IDs that members get opted into automatically.\n\tDefaultChannelIDs []string `json:\"default_channel_ids,omitempty\"`\n\n\t// Whether onboarding is enabled in the guild.\n\tEnabled *bool `json:\"enabled,omitempty\"`\n\n\t// Mode of onboarding.\n\tMode *GuildOnboardingMode `json:\"mode,omitempty\"`\n}\n\n// GuildOnboardingPromptType is the type of an onboarding prompt.\n// https://discord.com/developers/docs/resources/guild#guild-onboarding-object-prompt-types\ntype GuildOnboardingPromptType int\n\n// Block containing known GuildOnboardingPromptType values.\nconst (\n\tGuildOnboardingPromptTypeMultipleChoice GuildOnboardingPromptType = 0\n\tGuildOnboardingPromptTypeDropdown       GuildOnboardingPromptType = 1\n)\n\n// GuildOnboardingPrompt is a prompt shown during onboarding and in the customize community (Channels & Roles) tab.\n// https://discord.com/developers/docs/resources/guild#guild-onboarding-object-onboarding-prompt-structure\ntype GuildOnboardingPrompt struct {\n\t// ID of the prompt.\n\t// NOTE: always requires to be a valid snowflake (e.g. \"0\"), see\n\t// https://github.com/discord/discord-api-docs/issues/6320 for more information.\n\tID string `json:\"id,omitempty\"`\n\n\t// Type of the prompt.\n\tType GuildOnboardingPromptType `json:\"type\"`\n\n\t// Options available within the prompt.\n\tOptions []GuildOnboardingPromptOption `json:\"options\"`\n\n\t// Title of the prompt.\n\tTitle string `json:\"title\"`\n\n\t// Indicates whether users are limited to selecting one option for the prompt.\n\tSingleSelect bool `json:\"single_select\"`\n\n\t// Indicates whether the prompt is required before a user completes the onboarding flow.\n\tRequired bool `json:\"required\"`\n\n\t// Indicates whether the prompt is present in the onboarding flow.\n\t// If false, the prompt will only appear in the customize community (Channels & Roles) tab.\n\tInOnboarding bool `json:\"in_onboarding\"`\n}\n\n// GuildOnboardingPromptOption is an option available within an onboarding prompt.\n// https://discord.com/developers/docs/resources/guild#guild-onboarding-object-prompt-option-structure\ntype GuildOnboardingPromptOption struct {\n\t// ID of the prompt option.\n\tID string `json:\"id,omitempty\"`\n\n\t// IDs for channels a member is added to when the option is selected.\n\tChannelIDs []string `json:\"channel_ids\"`\n\n\t// IDs for roles assigned to a member when the option is selected.\n\tRoleIDs []string `json:\"role_ids\"`\n\n\t// Emoji of the option.\n\t// NOTE: when creating or updating a prompt option\n\t// EmojiID, EmojiName and EmojiAnimated should be used instead.\n\tEmoji *Emoji `json:\"emoji,omitempty\"`\n\n\t// Title of the option.\n\tTitle string `json:\"title\"`\n\n\t// Description of the option.\n\tDescription string `json:\"description\"`\n\n\t// ID of the option's emoji.\n\t// NOTE: only used when creating or updating a prompt option.\n\tEmojiID string `json:\"emoji_id,omitempty\"`\n\t// Name of the option's emoji.\n\t// NOTE: only used when creating or updating a prompt option.\n\tEmojiName string `json:\"emoji_name,omitempty\"`\n\t// Whether the option's emoji is animated.\n\t// NOTE: only used when creating or updating a prompt option.\n\tEmojiAnimated *bool `json:\"emoji_animated,omitempty\"`\n}\n\n// A GuildTemplate represents a replicable template for guild creation\ntype GuildTemplate struct {\n\t// The unique code for the guild template\n\tCode string `json:\"code\"`\n\n\t// The name of the template\n\tName string `json:\"name,omitempty\"`\n\n\t// The description for the template\n\tDescription *string `json:\"description,omitempty\"`\n\n\t// The number of times this template has been used\n\tUsageCount int `json:\"usage_count\"`\n\n\t// The ID of the user who created the template\n\tCreatorID string `json:\"creator_id\"`\n\n\t// The user who created the template\n\tCreator *User `json:\"creator\"`\n\n\t// The timestamp of when the template was created\n\tCreatedAt time.Time `json:\"created_at\"`\n\n\t// The timestamp of when the template was last synced\n\tUpdatedAt time.Time `json:\"updated_at\"`\n\n\t// The ID of the guild the template was based on\n\tSourceGuildID string `json:\"source_guild_id\"`\n\n\t// The guild 'snapshot' this template contains\n\tSerializedSourceGuild *Guild `json:\"serialized_source_guild\"`\n\n\t// Whether the template has unsynced changes\n\tIsDirty bool `json:\"is_dirty\"`\n}\n\n// GuildTemplateParams stores the data needed to create or update a GuildTemplate.\ntype GuildTemplateParams struct {\n\t// The name of the template (1-100 characters)\n\tName string `json:\"name,omitempty\"`\n\t// The description of the template (0-120 characters)\n\tDescription string `json:\"description,omitempty\"`\n}\n\n// MessageNotifications is the notification level for a guild\n// https://discord.com/developers/docs/resources/guild#guild-object-default-message-notification-level\ntype MessageNotifications int\n\n// Block containing known MessageNotifications values\nconst (\n\tMessageNotificationsAllMessages  MessageNotifications = 0\n\tMessageNotificationsOnlyMentions MessageNotifications = 1\n)\n\n// SystemChannelFlag is the type of flags in the system channel (see SystemChannelFlag* consts)\n// https://discord.com/developers/docs/resources/guild#guild-object-system-channel-flags\ntype SystemChannelFlag int\n\n// Block containing known SystemChannelFlag values\nconst (\n\tSystemChannelFlagsSuppressJoinNotifications          SystemChannelFlag = 1 << 0\n\tSystemChannelFlagsSuppressPremium                    SystemChannelFlag = 1 << 1\n\tSystemChannelFlagsSuppressGuildReminderNotifications SystemChannelFlag = 1 << 2\n\tSystemChannelFlagsSuppressJoinNotificationReplies    SystemChannelFlag = 1 << 3\n)\n\n// IconURL returns a URL to the guild's icon.\n//\n//\tsize:    The size of the desired icon image as a power of two\n//\t         Image size can be any power of two between 16 and 4096.\nfunc (g *Guild) IconURL(size string) string {\n\treturn iconURL(g.Icon, EndpointGuildIcon(g.ID, g.Icon), EndpointGuildIconAnimated(g.ID, g.Icon), size)\n}\n\n// BannerURL returns a URL to the guild's banner.\n//\n//\tsize:    The size of the desired banner image as a power of two\n//\t         Image size can be any power of two between 16 and 4096.\nfunc (g *Guild) BannerURL(size string) string {\n\treturn bannerURL(g.Banner, EndpointGuildBanner(g.ID, g.Banner), EndpointGuildBannerAnimated(g.ID, g.Banner), size)\n}\n\n// A UserGuild holds a brief version of a Guild\ntype UserGuild struct {\n\tID          string         `json:\"id\"`\n\tName        string         `json:\"name\"`\n\tIcon        string         `json:\"icon\"`\n\tOwner       bool           `json:\"owner\"`\n\tPermissions int64          `json:\"permissions,string\"`\n\tFeatures    []GuildFeature `json:\"features\"`\n\n\t// Approximate number of members in this guild.\n\t// NOTE: this field is only filled when withCounts is true.\n\tApproximateMemberCount int `json:\"approximate_member_count\"`\n\n\t// Approximate number of non-offline members in this guild.\n\t// NOTE: this field is only filled when withCounts is true.\n\tApproximatePresenceCount int `json:\"approximate_presence_count\"`\n}\n\n// GuildFeature indicates the presence of a feature in a guild\ntype GuildFeature string\n\n// Constants for GuildFeature\nconst (\n\tGuildFeatureAnimatedBanner                GuildFeature = \"ANIMATED_BANNER\"\n\tGuildFeatureAnimatedIcon                  GuildFeature = \"ANIMATED_ICON\"\n\tGuildFeatureAutoModeration                GuildFeature = \"AUTO_MODERATION\"\n\tGuildFeatureBanner                        GuildFeature = \"BANNER\"\n\tGuildFeatureCommunity                     GuildFeature = \"COMMUNITY\"\n\tGuildFeatureDiscoverable                  GuildFeature = \"DISCOVERABLE\"\n\tGuildFeatureFeaturable                    GuildFeature = \"FEATURABLE\"\n\tGuildFeatureInviteSplash                  GuildFeature = \"INVITE_SPLASH\"\n\tGuildFeatureMemberVerificationGateEnabled GuildFeature = \"MEMBER_VERIFICATION_GATE_ENABLED\"\n\tGuildFeatureMonetizationEnabled           GuildFeature = \"MONETIZATION_ENABLED\"\n\tGuildFeatureMoreStickers                  GuildFeature = \"MORE_STICKERS\"\n\tGuildFeatureNews                          GuildFeature = \"NEWS\"\n\tGuildFeaturePartnered                     GuildFeature = \"PARTNERED\"\n\tGuildFeaturePreviewEnabled                GuildFeature = \"PREVIEW_ENABLED\"\n\tGuildFeaturePrivateThreads                GuildFeature = \"PRIVATE_THREADS\"\n\tGuildFeatureRoleIcons                     GuildFeature = \"ROLE_ICONS\"\n\tGuildFeatureTicketedEventsEnabled         GuildFeature = \"TICKETED_EVENTS_ENABLED\"\n\tGuildFeatureVanityURL                     GuildFeature = \"VANITY_URL\"\n\tGuildFeatureVerified                      GuildFeature = \"VERIFIED\"\n\tGuildFeatureVipRegions                    GuildFeature = \"VIP_REGIONS\"\n\tGuildFeatureWelcomeScreenEnabled          GuildFeature = \"WELCOME_SCREEN_ENABLED\"\n)\n\n// A GuildParams stores all the data needed to update discord guild settings\ntype GuildParams struct {\n\tName                        string             `json:\"name,omitempty\"`\n\tRegion                      string             `json:\"region,omitempty\"`\n\tVerificationLevel           *VerificationLevel `json:\"verification_level,omitempty\"`\n\tDefaultMessageNotifications int                `json:\"default_message_notifications,omitempty\"` // TODO: Separate type?\n\tExplicitContentFilter       int                `json:\"explicit_content_filter,omitempty\"`\n\tAfkChannelID                string             `json:\"afk_channel_id,omitempty\"`\n\tAfkTimeout                  int                `json:\"afk_timeout,omitempty\"`\n\tIcon                        string             `json:\"icon,omitempty\"`\n\tOwnerID                     string             `json:\"owner_id,omitempty\"`\n\tSplash                      string             `json:\"splash,omitempty\"`\n\tDiscoverySplash             string             `json:\"discovery_splash,omitempty\"`\n\tBanner                      string             `json:\"banner,omitempty\"`\n\tSystemChannelID             string             `json:\"system_channel_id,omitempty\"`\n\tSystemChannelFlags          SystemChannelFlag  `json:\"system_channel_flags,omitempty\"`\n\tRulesChannelID              string             `json:\"rules_channel_id,omitempty\"`\n\tPublicUpdatesChannelID      string             `json:\"public_updates_channel_id,omitempty\"`\n\tPreferredLocale             Locale             `json:\"preferred_locale,omitempty\"`\n\tFeatures                    []GuildFeature     `json:\"features,omitempty\"`\n\tDescription                 string             `json:\"description,omitempty\"`\n\tPremiumProgressBarEnabled   *bool              `json:\"premium_progress_bar_enabled,omitempty\"`\n}\n\n// A Role stores information about Discord guild member roles.\ntype Role struct {\n\t// The ID of the role.\n\tID string `json:\"id\"`\n\n\t// The name of the role.\n\tName string `json:\"name\"`\n\n\t// Whether this role is managed by an integration, and\n\t// thus cannot be manually added to, or taken from, members.\n\tManaged bool `json:\"managed\"`\n\n\t// Whether this role is mentionable.\n\tMentionable bool `json:\"mentionable\"`\n\n\t// Whether this role is hoisted (shows up separately in member list).\n\tHoist bool `json:\"hoist\"`\n\n\t// The hex color of this role.\n\tColor int `json:\"color\"`\n\n\t// The position of this role in the guild's role hierarchy.\n\tPosition int `json:\"position\"`\n\n\t// The permissions of the role on the guild (doesn't include channel overrides).\n\t// This is a combination of bit masks; the presence of a certain permission can\n\t// be checked by performing a bitwise AND between this int and the permission.\n\tPermissions int64 `json:\"permissions,string\"`\n\n\t// The hash of the role icon. Use Role.IconURL to retrieve the icon's URL.\n\tIcon string `json:\"icon\"`\n\n\t// The emoji assigned to this role.\n\tUnicodeEmoji string `json:\"unicode_emoji\"`\n\n\t// The flags of the role, which describe its extra features.\n\t// This is a combination of bit masks; the presence of a certain flag can\n\t// be checked by performing a bitwise AND between this int and the flag.\n\tFlags RoleFlags `json:\"flags\"`\n}\n\n// RoleFlags represent the flags of a Role.\n// https://discord.com/developers/docs/topics/permissions#role-object-role-flags\ntype RoleFlags int\n\n// Block containing known RoleFlags values.\nconst (\n\t// RoleFlagInPrompt indicates whether the Role is selectable by members in an onboarding prompt.\n\tRoleFlagInPrompt RoleFlags = 1 << 0\n)\n\n// Mention returns a string which mentions the role\nfunc (r *Role) Mention() string {\n\treturn fmt.Sprintf(\"<@&%s>\", r.ID)\n}\n\n// IconURL returns the URL of the role's icon.\n//\n//\tsize:    The size of the desired role icon as a power of two\n//\t         Image size can be any power of two between 16 and 4096.\nfunc (r *Role) IconURL(size string) string {\n\tif r.Icon == \"\" {\n\t\treturn \"\"\n\t}\n\n\tURL := EndpointRoleIcon(r.ID, r.Icon)\n\n\tif size != \"\" {\n\t\treturn URL + \"?size=\" + size\n\t}\n\treturn URL\n}\n\n// RoleParams represents the parameters needed to create or update a Role\ntype RoleParams struct {\n\t// The role's name\n\tName string `json:\"name,omitempty\"`\n\t// The color the role should have (as a decimal, not hex)\n\tColor *int `json:\"color,omitempty\"`\n\t// Whether to display the role's users separately\n\tHoist *bool `json:\"hoist,omitempty\"`\n\t// The overall permissions number of the role\n\tPermissions *int64 `json:\"permissions,omitempty,string\"`\n\t// Whether this role is mentionable\n\tMentionable *bool `json:\"mentionable,omitempty\"`\n\t// The role's unicode emoji.\n\t// NOTE: can only be set if the guild has the ROLE_ICONS feature.\n\tUnicodeEmoji *string `json:\"unicode_emoji,omitempty\"`\n\t// The role's icon image encoded in base64.\n\t// NOTE: can only be set if the guild has the ROLE_ICONS feature.\n\tIcon *string `json:\"icon,omitempty\"`\n}\n\n// Roles are a collection of Role\ntype Roles []*Role\n\nfunc (r Roles) Len() int {\n\treturn len(r)\n}\n\nfunc (r Roles) Less(i, j int) bool {\n\treturn r[i].Position > r[j].Position\n}\n\nfunc (r Roles) Swap(i, j int) {\n\tr[i], r[j] = r[j], r[i]\n}\n\n// A VoiceState stores the voice states of Guilds\ntype VoiceState struct {\n\tGuildID                 string     `json:\"guild_id\"`\n\tChannelID               string     `json:\"channel_id\"`\n\tUserID                  string     `json:\"user_id\"`\n\tMember                  *Member    `json:\"member\"`\n\tSessionID               string     `json:\"session_id\"`\n\tDeaf                    bool       `json:\"deaf\"`\n\tMute                    bool       `json:\"mute\"`\n\tSelfDeaf                bool       `json:\"self_deaf\"`\n\tSelfMute                bool       `json:\"self_mute\"`\n\tSelfStream              bool       `json:\"self_stream\"`\n\tSelfVideo               bool       `json:\"self_video\"`\n\tSuppress                bool       `json:\"suppress\"`\n\tRequestToSpeakTimestamp *time.Time `json:\"request_to_speak_timestamp\"`\n}\n\n// A Presence stores the online, offline, or idle and game status of Guild members.\ntype Presence struct {\n\tUser         *User        `json:\"user\"`\n\tStatus       Status       `json:\"status\"`\n\tActivities   []*Activity  `json:\"activities\"`\n\tSince        *int         `json:\"since\"`\n\tClientStatus ClientStatus `json:\"client_status\"`\n}\n\n// A TimeStamps struct contains start and end times used in the rich presence \"playing ..\" Game\ntype TimeStamps struct {\n\tEndTimestamp   int64 `json:\"end,omitempty\"`\n\tStartTimestamp int64 `json:\"start,omitempty\"`\n}\n\n// UnmarshalJSON unmarshals JSON into TimeStamps struct\nfunc (t *TimeStamps) UnmarshalJSON(b []byte) error {\n\ttemp := struct {\n\t\tEnd   float64 `json:\"end,omitempty\"`\n\t\tStart float64 `json:\"start,omitempty\"`\n\t}{}\n\terr := Unmarshal(b, &temp)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.EndTimestamp = int64(temp.End)\n\tt.StartTimestamp = int64(temp.Start)\n\treturn nil\n}\n\n// An Assets struct contains assets and labels used in the rich presence \"playing ..\" Game\ntype Assets struct {\n\tLargeImageID string `json:\"large_image,omitempty\"`\n\tSmallImageID string `json:\"small_image,omitempty\"`\n\tLargeText    string `json:\"large_text,omitempty\"`\n\tSmallText    string `json:\"small_text,omitempty\"`\n}\n\n// MemberFlags represent flags of a guild member.\n// https://discord.com/developers/docs/resources/guild#guild-member-object-guild-member-flags\ntype MemberFlags int\n\n// Block containing known MemberFlags values.\nconst (\n\t// MemberFlagDidRejoin indicates whether the Member has left and rejoined the guild.\n\tMemberFlagDidRejoin MemberFlags = 1 << 0\n\t// MemberFlagCompletedOnboarding indicates whether the Member has completed onboarding.\n\tMemberFlagCompletedOnboarding MemberFlags = 1 << 1\n\t// MemberFlagBypassesVerification indicates whether the Member is exempt from guild verification requirements.\n\tMemberFlagBypassesVerification MemberFlags = 1 << 2\n\t// MemberFlagStartedOnboarding indicates whether the Member has started onboarding.\n\tMemberFlagStartedOnboarding MemberFlags = 1 << 3\n)\n\n// A Member stores user information for Guild members. A guild\n// member represents a certain user's presence in a guild.\ntype Member struct {\n\t// The guild ID on which the member exists.\n\tGuildID string `json:\"guild_id\"`\n\n\t// The time at which the member joined the guild.\n\tJoinedAt time.Time `json:\"joined_at\"`\n\n\t// The nickname of the member, if they have one.\n\tNick string `json:\"nick\"`\n\n\t// Whether the member is deafened at a guild level.\n\tDeaf bool `json:\"deaf\"`\n\n\t// Whether the member is muted at a guild level.\n\tMute bool `json:\"mute\"`\n\n\t// The hash of the avatar for the guild member, if any.\n\tAvatar string `json:\"avatar\"`\n\n\t// The underlying user on which the member is based.\n\tUser *User `json:\"user\"`\n\n\t// A list of IDs of the roles which are possessed by the member.\n\tRoles []string `json:\"roles\"`\n\n\t// When the user used their Nitro boost on the server\n\tPremiumSince *time.Time `json:\"premium_since\"`\n\n\t// The flags of this member. This is a combination of bit masks; the presence of a certain\n\t// flag can be checked by performing a bitwise AND between this int and the flag.\n\tFlags MemberFlags `json:\"flags\"`\n\n\t// Is true while the member hasn't accepted the membership screen.\n\tPending bool `json:\"pending\"`\n\n\t// Total permissions of the member in the channel, including overrides, returned when in the interaction object.\n\tPermissions int64 `json:\"permissions,string\"`\n\n\t// The time at which the member's timeout will expire.\n\t// Time in the past or nil if the user is not timed out.\n\tCommunicationDisabledUntil *time.Time `json:\"communication_disabled_until\"`\n}\n\n// Mention creates a member mention\nfunc (m *Member) Mention() string {\n\treturn \"<@!\" + m.User.ID + \">\"\n}\n\n// AvatarURL returns the URL of the member's avatar\n//\n//\tsize:    The size of the user's avatar as a power of two\n//\t         if size is an empty string, no size parameter will\n//\t         be added to the URL.\nfunc (m *Member) AvatarURL(size string) string {\n\tif m.Avatar == \"\" {\n\t\treturn m.User.AvatarURL(size)\n\t}\n\t// The default/empty avatar case should be handled by the above condition\n\treturn avatarURL(m.Avatar, \"\", EndpointGuildMemberAvatar(m.GuildID, m.User.ID, m.Avatar),\n\t\tEndpointGuildMemberAvatarAnimated(m.GuildID, m.User.ID, m.Avatar), size)\n\n}\n\n// DisplayName returns the member's guild nickname if they have one,\n// otherwise it returns their discord display name.\nfunc (m *Member) DisplayName() string {\n\tif m.Nick != \"\" {\n\t\treturn m.Nick\n\t}\n\treturn m.User.GlobalName\n}\n\n// ClientStatus stores the online, offline, idle, or dnd status of each device of a Guild member.\ntype ClientStatus struct {\n\tDesktop Status `json:\"desktop\"`\n\tMobile  Status `json:\"mobile\"`\n\tWeb     Status `json:\"web\"`\n}\n\n// Status type definition\ntype Status string\n\n// Constants for Status with the different current available status\nconst (\n\tStatusOnline       Status = \"online\"\n\tStatusIdle         Status = \"idle\"\n\tStatusDoNotDisturb Status = \"dnd\"\n\tStatusInvisible    Status = \"invisible\"\n\tStatusOffline      Status = \"offline\"\n)\n\n// A TooManyRequests struct holds information received from Discord\n// when receiving a HTTP 429 response.\ntype TooManyRequests struct {\n\tBucket     string        `json:\"bucket\"`\n\tMessage    string        `json:\"message\"`\n\tRetryAfter time.Duration `json:\"retry_after\"`\n}\n\n// UnmarshalJSON helps support translation of a milliseconds-based float\n// into a time.Duration on TooManyRequests.\nfunc (t *TooManyRequests) UnmarshalJSON(b []byte) error {\n\tu := struct {\n\t\tBucket     string  `json:\"bucket\"`\n\t\tMessage    string  `json:\"message\"`\n\t\tRetryAfter float64 `json:\"retry_after\"`\n\t}{}\n\terr := Unmarshal(b, &u)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.Bucket = u.Bucket\n\tt.Message = u.Message\n\twhole, frac := math.Modf(u.RetryAfter)\n\tt.RetryAfter = time.Duration(whole)*time.Second + time.Duration(frac*1000)*time.Millisecond\n\treturn nil\n}\n\n// A ReadState stores data on the read state of channels.\ntype ReadState struct {\n\tMentionCount  int    `json:\"mention_count\"`\n\tLastMessageID string `json:\"last_message_id\"`\n\tID            string `json:\"id\"`\n}\n\n// A GuildRole stores data for guild roles.\ntype GuildRole struct {\n\tRole    *Role  `json:\"role\"`\n\tGuildID string `json:\"guild_id\"`\n}\n\n// A GuildBan stores data for a guild ban.\ntype GuildBan struct {\n\tReason string `json:\"reason\"`\n\tUser   *User  `json:\"user\"`\n}\n\n// AutoModerationRule stores data for an auto moderation rule.\ntype AutoModerationRule struct {\n\tID              string                         `json:\"id,omitempty\"`\n\tGuildID         string                         `json:\"guild_id,omitempty\"`\n\tName            string                         `json:\"name,omitempty\"`\n\tCreatorID       string                         `json:\"creator_id,omitempty\"`\n\tEventType       AutoModerationRuleEventType    `json:\"event_type,omitempty\"`\n\tTriggerType     AutoModerationRuleTriggerType  `json:\"trigger_type,omitempty\"`\n\tTriggerMetadata *AutoModerationTriggerMetadata `json:\"trigger_metadata,omitempty\"`\n\tActions         []AutoModerationAction         `json:\"actions,omitempty\"`\n\tEnabled         *bool                          `json:\"enabled,omitempty\"`\n\tExemptRoles     *[]string                      `json:\"exempt_roles,omitempty\"`\n\tExemptChannels  *[]string                      `json:\"exempt_channels,omitempty\"`\n}\n\n// AutoModerationRuleEventType indicates in what event context a rule should be checked.\ntype AutoModerationRuleEventType int\n\n// Auto moderation rule event types.\nconst (\n\t// AutoModerationEventMessageSend is checked when a member sends or edits a message in the guild\n\tAutoModerationEventMessageSend AutoModerationRuleEventType = 1\n)\n\n// AutoModerationRuleTriggerType represents the type of content which can trigger the rule.\ntype AutoModerationRuleTriggerType int\n\n// Auto moderation rule trigger types.\nconst (\n\tAutoModerationEventTriggerKeyword       AutoModerationRuleTriggerType = 1\n\tAutoModerationEventTriggerHarmfulLink   AutoModerationRuleTriggerType = 2\n\tAutoModerationEventTriggerSpam          AutoModerationRuleTriggerType = 3\n\tAutoModerationEventTriggerKeywordPreset AutoModerationRuleTriggerType = 4\n)\n\n// AutoModerationKeywordPreset represents an internally pre-defined wordset.\ntype AutoModerationKeywordPreset uint\n\n// Auto moderation keyword presets.\nconst (\n\tAutoModerationKeywordPresetProfanity     AutoModerationKeywordPreset = 1\n\tAutoModerationKeywordPresetSexualContent AutoModerationKeywordPreset = 2\n\tAutoModerationKeywordPresetSlurs         AutoModerationKeywordPreset = 3\n)\n\n// AutoModerationTriggerMetadata represents additional metadata used to determine whether rule should be triggered.\ntype AutoModerationTriggerMetadata struct {\n\t// Substrings which will be searched for in content.\n\t// NOTE: should be only used with keyword trigger type.\n\tKeywordFilter []string `json:\"keyword_filter,omitempty\"`\n\t// Regular expression patterns which will be matched against content (maximum of 10).\n\t// NOTE: should be only used with keyword trigger type.\n\tRegexPatterns []string `json:\"regex_patterns,omitempty\"`\n\n\t// Internally pre-defined wordsets which will be searched for in content.\n\t// NOTE: should be only used with keyword preset trigger type.\n\tPresets []AutoModerationKeywordPreset `json:\"presets,omitempty\"`\n\n\t// Substrings which should not trigger the rule.\n\t// NOTE: should be only used with keyword or keyword preset trigger type.\n\tAllowList *[]string `json:\"allow_list,omitempty\"`\n\n\t// Total number of unique role and user mentions allowed per message.\n\t// NOTE: should be only used with mention spam trigger type.\n\tMentionTotalLimit int `json:\"mention_total_limit,omitempty\"`\n}\n\n// AutoModerationActionType represents an action which will execute whenever a rule is triggered.\ntype AutoModerationActionType int\n\n// Auto moderation actions types.\nconst (\n\tAutoModerationRuleActionBlockMessage     AutoModerationActionType = 1\n\tAutoModerationRuleActionSendAlertMessage AutoModerationActionType = 2\n\tAutoModerationRuleActionTimeout          AutoModerationActionType = 3\n)\n\n// AutoModerationActionMetadata represents additional metadata needed during execution for a specific action type.\ntype AutoModerationActionMetadata struct {\n\t// Channel to which user content should be logged.\n\t// NOTE: should be only used with send alert message action type.\n\tChannelID string `json:\"channel_id,omitempty\"`\n\n\t// Timeout duration in seconds (maximum of 2419200 - 4 weeks).\n\t// NOTE: should be only used with timeout action type.\n\tDuration int `json:\"duration_seconds,omitempty\"`\n\n\t// Additional explanation that will be shown to members whenever their message is blocked (maximum of 150 characters).\n\t// NOTE: should be only used with block message action type.\n\tCustomMessage string `json:\"custom_message,omitempty\"`\n}\n\n// AutoModerationAction stores data for an auto moderation action.\ntype AutoModerationAction struct {\n\tType     AutoModerationActionType      `json:\"type\"`\n\tMetadata *AutoModerationActionMetadata `json:\"metadata,omitempty\"`\n}\n\n// A GuildEmbed stores data for a guild embed.\ntype GuildEmbed struct {\n\tEnabled   *bool  `json:\"enabled,omitempty\"`\n\tChannelID string `json:\"channel_id,omitempty\"`\n}\n\n// A GuildAuditLog stores data for a guild audit log.\n// https://discord.com/developers/docs/resources/audit-log#audit-log-object-audit-log-structure\ntype GuildAuditLog struct {\n\tWebhooks        []*Webhook       `json:\"webhooks,omitempty\"`\n\tUsers           []*User          `json:\"users,omitempty\"`\n\tAuditLogEntries []*AuditLogEntry `json:\"audit_log_entries\"`\n\tIntegrations    []*Integration   `json:\"integrations\"`\n}\n\n// AuditLogEntry for a GuildAuditLog\n// https://discord.com/developers/docs/resources/audit-log#audit-log-entry-object-audit-log-entry-structure\ntype AuditLogEntry struct {\n\tTargetID   string            `json:\"target_id\"`\n\tChanges    []*AuditLogChange `json:\"changes\"`\n\tUserID     string            `json:\"user_id\"`\n\tID         string            `json:\"id\"`\n\tActionType *AuditLogAction   `json:\"action_type\"`\n\tOptions    *AuditLogOptions  `json:\"options\"`\n\tReason     string            `json:\"reason\"`\n}\n\n// AuditLogChange for an AuditLogEntry\ntype AuditLogChange struct {\n\tNewValue interface{}        `json:\"new_value\"`\n\tOldValue interface{}        `json:\"old_value\"`\n\tKey      *AuditLogChangeKey `json:\"key\"`\n}\n\n// AuditLogChangeKey value for AuditLogChange\n// https://discord.com/developers/docs/resources/audit-log#audit-log-change-object-audit-log-change-key\ntype AuditLogChangeKey string\n\n// Block of valid AuditLogChangeKey\nconst (\n\t// AuditLogChangeKeyAfkChannelID is sent when afk channel changed (snowflake) - guild\n\tAuditLogChangeKeyAfkChannelID AuditLogChangeKey = \"afk_channel_id\"\n\t// AuditLogChangeKeyAfkTimeout is sent when afk timeout duration changed (int) - guild\n\tAuditLogChangeKeyAfkTimeout AuditLogChangeKey = \"afk_timeout\"\n\t// AuditLogChangeKeyAllow is sent when a permission on a text or voice channel was allowed for a role (string) - role\n\tAuditLogChangeKeyAllow AuditLogChangeKey = \"allow\"\n\t// AudirChangeKeyApplicationID is sent when application id of the added or removed webhook or bot (snowflake) - channel\n\tAuditLogChangeKeyApplicationID AuditLogChangeKey = \"application_id\"\n\t// AuditLogChangeKeyArchived is sent when thread was archived/unarchived (bool) - thread\n\tAuditLogChangeKeyArchived AuditLogChangeKey = \"archived\"\n\t// AuditLogChangeKeyAsset is sent when asset is changed (string) - sticker\n\tAuditLogChangeKeyAsset AuditLogChangeKey = \"asset\"\n\t// AuditLogChangeKeyAutoArchiveDuration is sent when auto archive duration changed (int) - thread\n\tAuditLogChangeKeyAutoArchiveDuration AuditLogChangeKey = \"auto_archive_duration\"\n\t// AuditLogChangeKeyAvailable is sent when availability of sticker changed (bool) - sticker\n\tAuditLogChangeKeyAvailable AuditLogChangeKey = \"available\"\n\t// AuditLogChangeKeyAvatarHash is sent when user avatar changed (string) - user\n\tAuditLogChangeKeyAvatarHash AuditLogChangeKey = \"avatar_hash\"\n\t// AuditLogChangeKeyBannerHash is sent when guild banner changed (string) - guild\n\tAuditLogChangeKeyBannerHash AuditLogChangeKey = \"banner_hash\"\n\t// AuditLogChangeKeyBitrate is sent when voice channel bitrate changed (int) - channel\n\tAuditLogChangeKeyBitrate AuditLogChangeKey = \"bitrate\"\n\t// AuditLogChangeKeyChannelID is sent when channel for invite code or guild scheduled event changed (snowflake) - invite or guild scheduled event\n\tAuditLogChangeKeyChannelID AuditLogChangeKey = \"channel_id\"\n\t// AuditLogChangeKeyCode is sent when invite code changed (string) - invite\n\tAuditLogChangeKeyCode AuditLogChangeKey = \"code\"\n\t// AuditLogChangeKeyColor is sent when role color changed (int) - role\n\tAuditLogChangeKeyColor AuditLogChangeKey = \"color\"\n\t// AuditLogChangeKeyCommunicationDisabledUntil is sent when member timeout state changed (ISO8601 timestamp) - member\n\tAuditLogChangeKeyCommunicationDisabledUntil AuditLogChangeKey = \"communication_disabled_until\"\n\t// AuditLogChangeKeyDeaf is sent when user server deafened/undeafened (bool) - member\n\tAuditLogChangeKeyDeaf AuditLogChangeKey = \"deaf\"\n\t// AuditLogChangeKeyDefaultAutoArchiveDuration is sent when default auto archive duration for newly created threads changed (int) - channel\n\tAuditLogChangeKeyDefaultAutoArchiveDuration AuditLogChangeKey = \"default_auto_archive_duration\"\n\t// AuditLogChangeKeyDefaultMessageNotification is sent when default message notification level changed (int) - guild\n\tAuditLogChangeKeyDefaultMessageNotification AuditLogChangeKey = \"default_message_notifications\"\n\t// AuditLogChangeKeyDeny is sent when a permission on a text or voice channel was denied for a role (string) - role\n\tAuditLogChangeKeyDeny AuditLogChangeKey = \"deny\"\n\t// AuditLogChangeKeyDescription is sent when description changed (string) - guild, sticker, or guild scheduled event\n\tAuditLogChangeKeyDescription AuditLogChangeKey = \"description\"\n\t// AuditLogChangeKeyDiscoverySplashHash is sent when discovery splash changed (string) - guild\n\tAuditLogChangeKeyDiscoverySplashHash AuditLogChangeKey = \"discovery_splash_hash\"\n\t// AuditLogChangeKeyEnableEmoticons is sent when integration emoticons enabled/disabled (bool) - integration\n\tAuditLogChangeKeyEnableEmoticons AuditLogChangeKey = \"enable_emoticons\"\n\t// AuditLogChangeKeyEntityType is sent when entity type of guild scheduled event was changed (int) - guild scheduled event\n\tAuditLogChangeKeyEntityType AuditLogChangeKey = \"entity_type\"\n\t// AuditLogChangeKeyExpireBehavior is sent when integration expiring subscriber behavior changed (int) - integration\n\tAuditLogChangeKeyExpireBehavior AuditLogChangeKey = \"expire_behavior\"\n\t// AuditLogChangeKeyExpireGracePeriod is sent when integration expire grace period changed (int) - integration\n\tAuditLogChangeKeyExpireGracePeriod AuditLogChangeKey = \"expire_grace_period\"\n\t// AuditLogChangeKeyExplicitContentFilter is sent when change in whose messages are scanned and deleted for explicit content in the server is made (int) - guild\n\tAuditLogChangeKeyExplicitContentFilter AuditLogChangeKey = \"explicit_content_filter\"\n\t// AuditLogChangeKeyFormatType is sent when format type of sticker changed (int - sticker format type) - sticker\n\tAuditLogChangeKeyFormatType AuditLogChangeKey = \"format_type\"\n\t// AuditLogChangeKeyGuildID is sent when guild sticker is in changed (snowflake) - sticker\n\tAuditLogChangeKeyGuildID AuditLogChangeKey = \"guild_id\"\n\t// AuditLogChangeKeyHoist is sent when role is now displayed/no longer displayed separate from online users (bool) - role\n\tAuditLogChangeKeyHoist AuditLogChangeKey = \"hoist\"\n\t// AuditLogChangeKeyIconHash is sent when icon changed (string) - guild or role\n\tAuditLogChangeKeyIconHash AuditLogChangeKey = \"icon_hash\"\n\t// AuditLogChangeKeyID is sent when the id of the changed entity - sometimes used in conjunction with other keys (snowflake) - any\n\tAuditLogChangeKeyID AuditLogChangeKey = \"id\"\n\t// AuditLogChangeKeyInvitable is sent when private thread is now invitable/uninvitable (bool) - thread\n\tAuditLogChangeKeyInvitable AuditLogChangeKey = \"invitable\"\n\t// AuditLogChangeKeyInviterID is sent when person who created invite code changed (snowflake) - invite\n\tAuditLogChangeKeyInviterID AuditLogChangeKey = \"inviter_id\"\n\t// AuditLogChangeKeyLocation is sent when channel id for guild scheduled event changed (string) - guild scheduled event\n\tAuditLogChangeKeyLocation AuditLogChangeKey = \"location\"\n\t// AuditLogChangeKeyLocked is sent when thread was locked/unlocked (bool) - thread\n\tAuditLogChangeKeyLocked AuditLogChangeKey = \"locked\"\n\t// AuditLogChangeKeyMaxAge is sent when invite code expiration time changed (int) - invite\n\tAuditLogChangeKeyMaxAge AuditLogChangeKey = \"max_age\"\n\t// AuditLogChangeKeyMaxUses is sent when max number of times invite code can be used changed (int) - invite\n\tAuditLogChangeKeyMaxUses AuditLogChangeKey = \"max_uses\"\n\t// AuditLogChangeKeyMentionable is sent when role is now mentionable/unmentionable (bool) - role\n\tAuditLogChangeKeyMentionable AuditLogChangeKey = \"mentionable\"\n\t// AuditLogChangeKeyMfaLevel is sent when two-factor auth requirement changed (int - mfa level) - guild\n\tAuditLogChangeKeyMfaLevel AuditLogChangeKey = \"mfa_level\"\n\t// AuditLogChangeKeyMute is sent when user server muted/unmuted (bool) - member\n\tAuditLogChangeKeyMute AuditLogChangeKey = \"mute\"\n\t// AuditLogChangeKeyName is sent when name changed (string) - any\n\tAuditLogChangeKeyName AuditLogChangeKey = \"name\"\n\t// AuditLogChangeKeyNick is sent when user nickname changed (string) - member\n\tAuditLogChangeKeyNick AuditLogChangeKey = \"nick\"\n\t// AuditLogChangeKeyNSFW is sent when channel nsfw restriction changed (bool) - channel\n\tAuditLogChangeKeyNSFW AuditLogChangeKey = \"nsfw\"\n\t// AuditLogChangeKeyOwnerID is sent when owner changed (snowflake) - guild\n\tAuditLogChangeKeyOwnerID AuditLogChangeKey = \"owner_id\"\n\t// AuditLogChangeKeyPermissionOverwrite is sent when permissions on a channel changed (array of channel overwrite objects) - channel\n\tAuditLogChangeKeyPermissionOverwrite AuditLogChangeKey = \"permission_overwrites\"\n\t// AuditLogChangeKeyPermissions is sent when permissions for a role changed (string) - role\n\tAuditLogChangeKeyPermissions AuditLogChangeKey = \"permissions\"\n\t// AuditLogChangeKeyPosition is sent when text or voice channel position changed (int) - channel\n\tAuditLogChangeKeyPosition AuditLogChangeKey = \"position\"\n\t// AuditLogChangeKeyPreferredLocale is sent when preferred locale changed (string) - guild\n\tAuditLogChangeKeyPreferredLocale AuditLogChangeKey = \"preferred_locale\"\n\t// AuditLogChangeKeyPrivacylevel is sent when privacy level of the stage instance changed (integer - privacy level) - stage instance or guild scheduled event\n\tAuditLogChangeKeyPrivacylevel AuditLogChangeKey = \"privacy_level\"\n\t// AuditLogChangeKeyPruneDeleteDays is sent when number of days after which inactive and role-unassigned members are kicked changed (int) - guild\n\tAuditLogChangeKeyPruneDeleteDays AuditLogChangeKey = \"prune_delete_days\"\n\t// AuditLogChangeKeyPublicUpdatesChannelID is sent when id of the public updates channel changed (snowflake) - guild\n\tAuditLogChangeKeyPublicUpdatesChannelID AuditLogChangeKey = \"public_updates_channel_id\"\n\t// AuditLogChangeKeyRateLimitPerUser is sent when amount of seconds a user has to wait before sending another message changed (int) - channel\n\tAuditLogChangeKeyRateLimitPerUser AuditLogChangeKey = \"rate_limit_per_user\"\n\t// AuditLogChangeKeyRegion is sent when region changed (string) - guild\n\tAuditLogChangeKeyRegion AuditLogChangeKey = \"region\"\n\t// AuditLogChangeKeyRulesChannelID is sent when id of the rules channel changed (snowflake) - guild\n\tAuditLogChangeKeyRulesChannelID AuditLogChangeKey = \"rules_channel_id\"\n\t// AuditLogChangeKeySplashHash is sent when invite splash page artwork changed (string) - guild\n\tAuditLogChangeKeySplashHash AuditLogChangeKey = \"splash_hash\"\n\t// AuditLogChangeKeyStatus is sent when status of guild scheduled event was changed (int - guild scheduled event status) - guild scheduled event\n\tAuditLogChangeKeyStatus AuditLogChangeKey = \"status\"\n\t// AuditLogChangeKeySystemChannelID is sent when id of the system channel changed (snowflake) - guild\n\tAuditLogChangeKeySystemChannelID AuditLogChangeKey = \"system_channel_id\"\n\t// AuditLogChangeKeyTags is sent when related emoji of sticker changed (string) - sticker\n\tAuditLogChangeKeyTags AuditLogChangeKey = \"tags\"\n\t// AuditLogChangeKeyTemporary is sent when invite code is now temporary or never expires (bool) - invite\n\tAuditLogChangeKeyTemporary AuditLogChangeKey = \"temporary\"\n\t// TODO: remove when compatibility is not required\n\tAuditLogChangeKeyTempoary = AuditLogChangeKeyTemporary\n\t// AuditLogChangeKeyTopic is sent when text channel topic or stage instance topic changed (string) - channel or stage instance\n\tAuditLogChangeKeyTopic AuditLogChangeKey = \"topic\"\n\t// AuditLogChangeKeyType is sent when type of entity created (int or string) - any\n\tAuditLogChangeKeyType AuditLogChangeKey = \"type\"\n\t// AuditLogChangeKeyUnicodeEmoji is sent when role unicode emoji changed (string) - role\n\tAuditLogChangeKeyUnicodeEmoji AuditLogChangeKey = \"unicode_emoji\"\n\t// AuditLogChangeKeyUserLimit is sent when new user limit in a voice channel set (int) - voice channel\n\tAuditLogChangeKeyUserLimit AuditLogChangeKey = \"user_limit\"\n\t// AuditLogChangeKeyUses is sent when number of times invite code used changed (int) - invite\n\tAuditLogChangeKeyUses AuditLogChangeKey = \"uses\"\n\t// AuditLogChangeKeyVanityURLCode is sent when guild invite vanity url changed (string) - guild\n\tAuditLogChangeKeyVanityURLCode AuditLogChangeKey = \"vanity_url_code\"\n\t// AuditLogChangeKeyVerificationLevel is sent when required verification level changed (int - verification level) - guild\n\tAuditLogChangeKeyVerificationLevel AuditLogChangeKey = \"verification_level\"\n\t// AuditLogChangeKeyWidgetChannelID is sent when channel id of the server widget changed (snowflake) - guild\n\tAuditLogChangeKeyWidgetChannelID AuditLogChangeKey = \"widget_channel_id\"\n\t// AuditLogChangeKeyWidgetEnabled is sent when server widget enabled/disabled (bool) - guild\n\tAuditLogChangeKeyWidgetEnabled AuditLogChangeKey = \"widget_enabled\"\n\t// AuditLogChangeKeyRoleAdd is sent when new role added (array of partial role objects) - guild\n\tAuditLogChangeKeyRoleAdd AuditLogChangeKey = \"$add\"\n\t// AuditLogChangeKeyRoleRemove is sent when role removed (array of partial role objects) - guild\n\tAuditLogChangeKeyRoleRemove AuditLogChangeKey = \"$remove\"\n)\n\n// AuditLogOptions optional data for the AuditLog\n// https://discord.com/developers/docs/resources/audit-log#audit-log-entry-object-optional-audit-entry-info\ntype AuditLogOptions struct {\n\tDeleteMemberDays              string               `json:\"delete_member_days\"`\n\tMembersRemoved                string               `json:\"members_removed\"`\n\tChannelID                     string               `json:\"channel_id\"`\n\tMessageID                     string               `json:\"message_id\"`\n\tCount                         string               `json:\"count\"`\n\tID                            string               `json:\"id\"`\n\tType                          *AuditLogOptionsType `json:\"type\"`\n\tRoleName                      string               `json:\"role_name\"`\n\tApplicationID                 string               `json:\"application_id\"`\n\tAutoModerationRuleName        string               `json:\"auto_moderation_rule_name\"`\n\tAutoModerationRuleTriggerType string               `json:\"auto_moderation_rule_trigger_type\"`\n\tIntegrationType               string               `json:\"integration_type\"`\n}\n\n// AuditLogOptionsType of the AuditLogOption\n// https://discord.com/developers/docs/resources/audit-log#audit-log-entry-object-optional-audit-entry-info\ntype AuditLogOptionsType string\n\n// Valid Types for AuditLogOptionsType\nconst (\n\tAuditLogOptionsTypeRole   AuditLogOptionsType = \"0\"\n\tAuditLogOptionsTypeMember AuditLogOptionsType = \"1\"\n)\n\n// AuditLogAction is the Action of the AuditLog (see AuditLogAction* consts)\n// https://discord.com/developers/docs/resources/audit-log#audit-log-entry-object-audit-log-events\ntype AuditLogAction int\n\n// Block contains Discord Audit Log Action Types\nconst (\n\tAuditLogActionGuildUpdate AuditLogAction = 1\n\n\tAuditLogActionChannelCreate          AuditLogAction = 10\n\tAuditLogActionChannelUpdate          AuditLogAction = 11\n\tAuditLogActionChannelDelete          AuditLogAction = 12\n\tAuditLogActionChannelOverwriteCreate AuditLogAction = 13\n\tAuditLogActionChannelOverwriteUpdate AuditLogAction = 14\n\tAuditLogActionChannelOverwriteDelete AuditLogAction = 15\n\n\tAuditLogActionMemberKick       AuditLogAction = 20\n\tAuditLogActionMemberPrune      AuditLogAction = 21\n\tAuditLogActionMemberBanAdd     AuditLogAction = 22\n\tAuditLogActionMemberBanRemove  AuditLogAction = 23\n\tAuditLogActionMemberUpdate     AuditLogAction = 24\n\tAuditLogActionMemberRoleUpdate AuditLogAction = 25\n\tAuditLogActionMemberMove       AuditLogAction = 26\n\tAuditLogActionMemberDisconnect AuditLogAction = 27\n\tAuditLogActionBotAdd           AuditLogAction = 28\n\n\tAuditLogActionRoleCreate AuditLogAction = 30\n\tAuditLogActionRoleUpdate AuditLogAction = 31\n\tAuditLogActionRoleDelete AuditLogAction = 32\n\n\tAuditLogActionInviteCreate AuditLogAction = 40\n\tAuditLogActionInviteUpdate AuditLogAction = 41\n\tAuditLogActionInviteDelete AuditLogAction = 42\n\n\tAuditLogActionWebhookCreate AuditLogAction = 50\n\tAuditLogActionWebhookUpdate AuditLogAction = 51\n\tAuditLogActionWebhookDelete AuditLogAction = 52\n\n\tAuditLogActionEmojiCreate AuditLogAction = 60\n\tAuditLogActionEmojiUpdate AuditLogAction = 61\n\tAuditLogActionEmojiDelete AuditLogAction = 62\n\n\tAuditLogActionMessageDelete     AuditLogAction = 72\n\tAuditLogActionMessageBulkDelete AuditLogAction = 73\n\tAuditLogActionMessagePin        AuditLogAction = 74\n\tAuditLogActionMessageUnpin      AuditLogAction = 75\n\n\tAuditLogActionIntegrationCreate   AuditLogAction = 80\n\tAuditLogActionIntegrationUpdate   AuditLogAction = 81\n\tAuditLogActionIntegrationDelete   AuditLogAction = 82\n\tAuditLogActionStageInstanceCreate AuditLogAction = 83\n\tAuditLogActionStageInstanceUpdate AuditLogAction = 84\n\tAuditLogActionStageInstanceDelete AuditLogAction = 85\n\n\tAuditLogActionStickerCreate AuditLogAction = 90\n\tAuditLogActionStickerUpdate AuditLogAction = 91\n\tAuditLogActionStickerDelete AuditLogAction = 92\n\n\tAuditLogGuildScheduledEventCreate AuditLogAction = 100\n\tAuditLogGuildScheduledEventUpdate AuditLogAction = 101\n\tAuditLogGuildScheduledEventDelete AuditLogAction = 102\n\n\tAuditLogActionThreadCreate AuditLogAction = 110\n\tAuditLogActionThreadUpdate AuditLogAction = 111\n\tAuditLogActionThreadDelete AuditLogAction = 112\n\n\tAuditLogActionApplicationCommandPermissionUpdate AuditLogAction = 121\n\n\tAuditLogActionAutoModerationRuleCreate                AuditLogAction = 140\n\tAuditLogActionAutoModerationRuleUpdate                AuditLogAction = 141\n\tAuditLogActionAutoModerationRuleDelete                AuditLogAction = 142\n\tAuditLogActionAutoModerationBlockMessage              AuditLogAction = 143\n\tAuditLogActionAutoModerationFlagToChannel             AuditLogAction = 144\n\tAuditLogActionAutoModerationUserCommunicationDisabled AuditLogAction = 145\n\n\tAuditLogActionCreatorMonetizationRequestCreated AuditLogAction = 150\n\tAuditLogActionCreatorMonetizationTermsAccepted  AuditLogAction = 151\n\n\tAuditLogActionOnboardingPromptCreate AuditLogAction = 163\n\tAuditLogActionOnboardingPromptUpdate AuditLogAction = 164\n\tAuditLogActionOnboardingPromptDelete AuditLogAction = 165\n\tAuditLogActionOnboardingCreate       AuditLogAction = 166\n\tAuditLogActionOnboardingUpdate       AuditLogAction = 167\n\n\tAuditLogActionHomeSettingsCreate = 190\n\tAuditLogActionHomeSettingsUpdate = 191\n)\n\n// GuildMemberParams stores data needed to update a member\n// https://discord.com/developers/docs/resources/guild#modify-guild-member\ntype GuildMemberParams struct {\n\t// Value to set user's nickname to.\n\tNick string `json:\"nick,omitempty\"`\n\t// Array of role ids the member is assigned.\n\tRoles *[]string `json:\"roles,omitempty\"`\n\t// ID of channel to move user to (if they are connected to voice).\n\t// Set to \"\" to remove user from a voice channel.\n\tChannelID *string `json:\"channel_id,omitempty\"`\n\t// Whether the user is muted in voice channels.\n\tMute *bool `json:\"mute,omitempty\"`\n\t// Whether the user is deafened in voice channels.\n\tDeaf *bool `json:\"deaf,omitempty\"`\n\t// When the user's timeout will expire and the user will be able\n\t// to communicate in the guild again (up to 28 days in the future).\n\t// Set to time.Time{} to remove timeout.\n\tCommunicationDisabledUntil *time.Time `json:\"communication_disabled_until,omitempty\"`\n}\n\n// MarshalJSON is a helper function to marshal GuildMemberParams.\nfunc (p GuildMemberParams) MarshalJSON() (res []byte, err error) {\n\ttype guildMemberParams GuildMemberParams\n\tv := struct {\n\t\tguildMemberParams\n\t\tChannelID                  json.RawMessage `json:\"channel_id,omitempty\"`\n\t\tCommunicationDisabledUntil json.RawMessage `json:\"communication_disabled_until,omitempty\"`\n\t}{guildMemberParams: guildMemberParams(p)}\n\n\tif p.ChannelID != nil {\n\t\tif *p.ChannelID == \"\" {\n\t\t\tv.ChannelID = json.RawMessage(`null`)\n\t\t} else {\n\t\t\tres, err = json.Marshal(p.ChannelID)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.ChannelID = res\n\t\t}\n\t}\n\n\tif p.CommunicationDisabledUntil != nil {\n\t\tif p.CommunicationDisabledUntil.IsZero() {\n\t\t\tv.CommunicationDisabledUntil = json.RawMessage(`null`)\n\t\t} else {\n\t\t\tres, err = json.Marshal(p.CommunicationDisabledUntil)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.CommunicationDisabledUntil = res\n\t\t}\n\t}\n\n\treturn json.Marshal(v)\n}\n\n// GuildMemberAddParams stores data needed to add a user to a guild.\n// NOTE: All fields are optional, except AccessToken.\ntype GuildMemberAddParams struct {\n\t// Valid access_token for the user.\n\tAccessToken string `json:\"access_token\"`\n\t// Value to set users nickname to.\n\tNick string `json:\"nick,omitempty\"`\n\t// A list of role ID's to set on the member.\n\tRoles []string `json:\"roles,omitempty\"`\n\t// Whether the user is muted.\n\tMute bool `json:\"mute,omitempty\"`\n\t// Whether the user is deafened.\n\tDeaf bool `json:\"deaf,omitempty\"`\n}\n\n// An APIErrorMessage is an api error message returned from discord\ntype APIErrorMessage struct {\n\tCode    int    `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\n// MessageReaction stores the data for a message reaction.\ntype MessageReaction struct {\n\tUserID    string `json:\"user_id\"`\n\tMessageID string `json:\"message_id\"`\n\tEmoji     Emoji  `json:\"emoji\"`\n\tChannelID string `json:\"channel_id\"`\n\tGuildID   string `json:\"guild_id,omitempty\"`\n}\n\n// GatewayBotResponse stores the data for the gateway/bot response\ntype GatewayBotResponse struct {\n\tURL               string             `json:\"url\"`\n\tShards            int                `json:\"shards\"`\n\tSessionStartLimit SessionInformation `json:\"session_start_limit\"`\n}\n\n// SessionInformation provides the information for max concurrency sharding\ntype SessionInformation struct {\n\tTotal          int `json:\"total,omitempty\"`\n\tRemaining      int `json:\"remaining,omitempty\"`\n\tResetAfter     int `json:\"reset_after,omitempty\"`\n\tMaxConcurrency int `json:\"max_concurrency,omitempty\"`\n}\n\n// GatewayStatusUpdate is sent by the client to indicate a presence or status update\n// https://discord.com/developers/docs/topics/gateway#update-status-gateway-status-update-structure\ntype GatewayStatusUpdate struct {\n\tSince  int      `json:\"since\"`\n\tGame   Activity `json:\"game\"`\n\tStatus string   `json:\"status\"`\n\tAFK    bool     `json:\"afk\"`\n}\n\n// Activity defines the Activity sent with GatewayStatusUpdate\n// https://discord.com/developers/docs/topics/gateway#activity-object\ntype Activity struct {\n\tName          string       `json:\"name\"`\n\tType          ActivityType `json:\"type\"`\n\tURL           string       `json:\"url,omitempty\"`\n\tCreatedAt     time.Time    `json:\"created_at\"`\n\tApplicationID string       `json:\"application_id,omitempty\"`\n\tState         string       `json:\"state,omitempty\"`\n\tDetails       string       `json:\"details,omitempty\"`\n\tTimestamps    TimeStamps   `json:\"timestamps,omitempty\"`\n\tEmoji         Emoji        `json:\"emoji,omitempty\"`\n\tParty         Party        `json:\"party,omitempty\"`\n\tAssets        Assets       `json:\"assets,omitempty\"`\n\tSecrets       Secrets      `json:\"secrets,omitempty\"`\n\tInstance      bool         `json:\"instance,omitempty\"`\n\tFlags         int          `json:\"flags,omitempty\"`\n}\n\n// UnmarshalJSON is a custom unmarshaljson to make CreatedAt a time.Time instead of an int\nfunc (activity *Activity) UnmarshalJSON(b []byte) error {\n\ttemp := struct {\n\t\tName          string       `json:\"name\"`\n\t\tType          ActivityType `json:\"type\"`\n\t\tURL           string       `json:\"url,omitempty\"`\n\t\tCreatedAt     int64        `json:\"created_at\"`\n\t\tApplicationID json.Number  `json:\"application_id,omitempty\"`\n\t\tState         string       `json:\"state,omitempty\"`\n\t\tDetails       string       `json:\"details,omitempty\"`\n\t\tTimestamps    TimeStamps   `json:\"timestamps,omitempty\"`\n\t\tEmoji         Emoji        `json:\"emoji,omitempty\"`\n\t\tParty         Party        `json:\"party,omitempty\"`\n\t\tAssets        Assets       `json:\"assets,omitempty\"`\n\t\tSecrets       Secrets      `json:\"secrets,omitempty\"`\n\t\tInstance      bool         `json:\"instance,omitempty\"`\n\t\tFlags         int          `json:\"flags,omitempty\"`\n\t}{}\n\terr := Unmarshal(b, &temp)\n\tif err != nil {\n\t\treturn err\n\t}\n\tactivity.ApplicationID = temp.ApplicationID.String()\n\tactivity.CreatedAt = time.Unix(0, temp.CreatedAt*1000000)\n\tactivity.Assets = temp.Assets\n\tactivity.Details = temp.Details\n\tactivity.Emoji = temp.Emoji\n\tactivity.Flags = temp.Flags\n\tactivity.Instance = temp.Instance\n\tactivity.Name = temp.Name\n\tactivity.Party = temp.Party\n\tactivity.Secrets = temp.Secrets\n\tactivity.State = temp.State\n\tactivity.Timestamps = temp.Timestamps\n\tactivity.Type = temp.Type\n\tactivity.URL = temp.URL\n\treturn nil\n}\n\n// Party defines the Party field in the Activity struct\n// https://discord.com/developers/docs/topics/gateway#activity-object\ntype Party struct {\n\tID   string `json:\"id,omitempty\"`\n\tSize []int  `json:\"size,omitempty\"`\n}\n\n// Secrets defines the Secrets field for the Activity struct\n// https://discord.com/developers/docs/topics/gateway#activity-object\ntype Secrets struct {\n\tJoin     string `json:\"join,omitempty\"`\n\tSpectate string `json:\"spectate,omitempty\"`\n\tMatch    string `json:\"match,omitempty\"`\n}\n\n// ActivityType is the type of Activity (see ActivityType* consts) in the Activity struct\n// https://discord.com/developers/docs/topics/gateway#activity-object-activity-types\ntype ActivityType int\n\n// Valid ActivityType values\nconst (\n\tActivityTypeGame      ActivityType = 0\n\tActivityTypeStreaming ActivityType = 1\n\tActivityTypeListening ActivityType = 2\n\tActivityTypeWatching  ActivityType = 3\n\tActivityTypeCustom    ActivityType = 4\n\tActivityTypeCompeting ActivityType = 5\n)\n\n// Identify is sent during initial handshake with the discord gateway.\n// https://discord.com/developers/docs/topics/gateway#identify\ntype Identify struct {\n\tToken          string              `json:\"token\"`\n\tProperties     IdentifyProperties  `json:\"properties\"`\n\tCompress       bool                `json:\"compress\"`\n\tLargeThreshold int                 `json:\"large_threshold\"`\n\tShard          *[2]int             `json:\"shard,omitempty\"`\n\tPresence       GatewayStatusUpdate `json:\"presence,omitempty\"`\n\tIntents        Intent              `json:\"intents\"`\n}\n\n// IdentifyProperties contains the \"properties\" portion of an Identify packet\n// https://discord.com/developers/docs/topics/gateway#identify-identify-connection-properties\ntype IdentifyProperties struct {\n\tOS              string `json:\"$os\"`\n\tBrowser         string `json:\"$browser\"`\n\tDevice          string `json:\"$device\"`\n\tReferer         string `json:\"$referer\"`\n\tReferringDomain string `json:\"$referring_domain\"`\n}\n\n// StageInstance holds information about a live stage.\n// https://discord.com/developers/docs/resources/stage-instance#stage-instance-resource\ntype StageInstance struct {\n\t// The id of this Stage instance\n\tID string `json:\"id\"`\n\t// The guild id of the associated Stage channel\n\tGuildID string `json:\"guild_id\"`\n\t// The id of the associated Stage channel\n\tChannelID string `json:\"channel_id\"`\n\t// The topic of the Stage instance (1-120 characters)\n\tTopic string `json:\"topic\"`\n\t// The privacy level of the Stage instance\n\t// https://discord.com/developers/docs/resources/stage-instance#stage-instance-object-privacy-level\n\tPrivacyLevel StageInstancePrivacyLevel `json:\"privacy_level\"`\n\t// Whether or not Stage Discovery is disabled (deprecated)\n\tDiscoverableDisabled bool `json:\"discoverable_disabled\"`\n\t// The id of the scheduled event for this Stage instance\n\tGuildScheduledEventID string `json:\"guild_scheduled_event_id\"`\n}\n\n// StageInstanceParams represents the parameters needed to create or edit a stage instance\ntype StageInstanceParams struct {\n\t// ChannelID represents the id of the Stage channel\n\tChannelID string `json:\"channel_id,omitempty\"`\n\t// Topic of the Stage instance (1-120 characters)\n\tTopic string `json:\"topic,omitempty\"`\n\t// PrivacyLevel of the Stage instance (default GUILD_ONLY)\n\tPrivacyLevel StageInstancePrivacyLevel `json:\"privacy_level,omitempty\"`\n\t// SendStartNotification will notify @everyone that a Stage instance has started\n\tSendStartNotification bool `json:\"send_start_notification,omitempty\"`\n}\n\n// StageInstancePrivacyLevel represents the privacy level of a Stage instance\n// https://discord.com/developers/docs/resources/stage-instance#stage-instance-object-privacy-level\ntype StageInstancePrivacyLevel int\n\nconst (\n\t// StageInstancePrivacyLevelPublic The Stage instance is visible publicly. (deprecated)\n\tStageInstancePrivacyLevelPublic StageInstancePrivacyLevel = 1\n\t// StageInstancePrivacyLevelGuildOnly The Stage instance is visible to only guild members.\n\tStageInstancePrivacyLevelGuildOnly StageInstancePrivacyLevel = 2\n)\n\n// PollLayoutType represents the layout of a poll.\ntype PollLayoutType int\n\n// Valid PollLayoutType values.\nconst (\n\tPollLayoutTypeDefault PollLayoutType = 1\n)\n\n// PollMedia contains common data used by question and answers.\ntype PollMedia struct {\n\tText  string          `json:\"text,omitempty\"`\n\tEmoji *ComponentEmoji `json:\"emoji,omitempty\"` // TODO: rename the type\n}\n\n// PollAnswer represents a single answer in a poll.\ntype PollAnswer struct {\n\t// NOTE: should not be set on creation.\n\tAnswerID int        `json:\"answer_id,omitempty\"`\n\tMedia    *PollMedia `json:\"poll_media\"`\n}\n\n// PollAnswerCount stores counted poll votes for a single answer.\ntype PollAnswerCount struct {\n\tID      int  `json:\"id\"`\n\tCount   int  `json:\"count\"`\n\tMeVoted bool `json:\"me_voted\"`\n}\n\n// PollResults contains voting results on a poll.\ntype PollResults struct {\n\tFinalized    bool               `json:\"is_finalized\"`\n\tAnswerCounts []*PollAnswerCount `json:\"answer_counts\"`\n}\n\n// Poll contains all poll related data.\ntype Poll struct {\n\tQuestion         PollMedia      `json:\"question\"`\n\tAnswers          []PollAnswer   `json:\"answers\"`\n\tAllowMultiselect bool           `json:\"allow_multiselect\"`\n\tLayoutType       PollLayoutType `json:\"layout_type,omitempty\"`\n\n\t// NOTE: should be set only on creation, when fetching use Expiry.\n\tDuration int `json:\"duration,omitempty\"`\n\n\t// NOTE: available only when fetching.\n\n\tResults *PollResults `json:\"results,omitempty\"`\n\t// NOTE: as Discord documentation notes, this field might be null even when fetching.\n\tExpiry *time.Time `json:\"expiry,omitempty\"`\n}\n\n// SKUType is the type of SKU (see SKUType* consts)\n// https://discord.com/developers/docs/monetization/skus\ntype SKUType int\n\n// Valid SKUType values\nconst (\n\tSKUTypeDurable      SKUType = 2\n\tSKUTypeConsumable   SKUType = 3\n\tSKUTypeSubscription SKUType = 5\n\t// SKUTypeSubscriptionGroup is a system-generated group for each subscription SKU.\n\tSKUTypeSubscriptionGroup SKUType = 6\n)\n\n// SKUFlags is a bitfield of flags used to differentiate user and server subscriptions (see SKUFlag* consts)\n// https://discord.com/developers/docs/monetization/skus#sku-object-sku-flags\ntype SKUFlags int\n\nconst (\n\t// SKUFlagAvailable indicates that the SKU is available for purchase.\n\tSKUFlagAvailable SKUFlags = 1 << 2\n\t// SKUFlagGuildSubscription indicates that the SKU is a guild subscription.\n\tSKUFlagGuildSubscription SKUFlags = 1 << 7\n\t// SKUFlagUserSubscription indicates that the SKU is a user subscription.\n\tSKUFlagUserSubscription SKUFlags = 1 << 8\n)\n\n// SKU (stock-keeping units) represent premium offerings\ntype SKU struct {\n\t// The ID of the SKU\n\tID string `json:\"id\"`\n\n\t// The Type of the SKU\n\tType SKUType `json:\"type\"`\n\n\t// The ID of the parent application\n\tApplicationID string `json:\"application_id\"`\n\n\t// Customer-facing name of the SKU.\n\tName string `json:\"name\"`\n\n\t// System-generated URL slug based on the SKU's name.\n\tSlug string `json:\"slug\"`\n\n\t// SKUFlags combined as a bitfield. The presence of a certain flag can be checked\n\t// by performing a bitwise AND operation between this int and the flag.\n\tFlags SKUFlags `json:\"flags\"`\n}\n\n// Subscription represents a user making recurring payments for at least one SKU over an ongoing period.\n// https://discord.com/developers/docs/resources/subscription#subscription-object\ntype Subscription struct {\n\t// ID of the subscription\n\tID string `json:\"id\"`\n\n\t// ID of the user who is subscribed\n\tUserID string `json:\"user_id\"`\n\n\t// List of SKUs subscribed to\n\tSKUIDs []string `json:\"sku_ids\"`\n\n\t// List of entitlements granted for this subscription\n\tEntitlementIDs []string `json:\"entitlement_ids\"`\n\n\t// Start of the current subscription period\n\tCurrentPeriodStart time.Time `json:\"current_period_start\"`\n\n\t// End of the current subscription period\n\tCurrentPeriodEnd time.Time `json:\"current_period_end\"`\n\n\t// Current status of the subscription\n\tStatus SubscriptionStatus `json:\"status\"`\n\n\t// When the subscription was canceled. Only present if the subscription has been canceled.\n\tCanceledAt *time.Time `json:\"canceled_at,omitempty\"`\n\n\t// ISO3166-1 alpha-2 country code of the payment source used to purchase the subscription. Missing unless queried with a private OAuth scope.\n\tCountry string `json:\"country,omitempty\"`\n}\n\n// SubscriptionStatus is the current status of a Subscription Object\n// https://discord.com/developers/docs/resources/subscription#subscription-statuses\ntype SubscriptionStatus int\n\n// Valid SubscriptionStatus values\nconst (\n\tSubscriptionStatusActive   = 0\n\tSubscriptionStatusEnding   = 1\n\tSubscriptionStatusInactive = 2\n)\n\n// EntitlementType is the type of entitlement (see EntitlementType* consts)\n// https://discord.com/developers/docs/monetization/entitlements#entitlement-object-entitlement-types\ntype EntitlementType int\n\n// Valid EntitlementType values\nconst (\n\tEntitlementTypePurchase                = 1\n\tEntitlementTypePremiumSubscription     = 2\n\tEntitlementTypeDeveloperGift           = 3\n\tEntitlementTypeTestModePurchase        = 4\n\tEntitlementTypeFreePurchase            = 5\n\tEntitlementTypeUserGift                = 6\n\tEntitlementTypePremiumPurchase         = 7\n\tEntitlementTypeApplicationSubscription = 8\n)\n\n// Entitlement represents that a user or guild has access to a premium offering\n// in your application.\ntype Entitlement struct {\n\t// The ID of the entitlement\n\tID string `json:\"id\"`\n\n\t// The ID of the SKU\n\tSKUID string `json:\"sku_id\"`\n\n\t// The ID of the parent application\n\tApplicationID string `json:\"application_id\"`\n\n\t// The ID of the user that is granted access to the entitlement's sku\n\t// Only available for user subscriptions.\n\tUserID string `json:\"user_id,omitempty\"`\n\n\t// The type of the entitlement\n\tType EntitlementType `json:\"type\"`\n\n\t// The entitlement was deleted\n\tDeleted bool `json:\"deleted\"`\n\n\t// The start date at which the entitlement is valid.\n\t// Not present when using test entitlements.\n\tStartsAt *time.Time `json:\"starts_at,omitempty\"`\n\n\t// The date at which the entitlement is no longer valid.\n\t// Not present when using test entitlements or when receiving an ENTITLEMENT_CREATE event.\n\tEndsAt *time.Time `json:\"ends_at,omitempty\"`\n\n\t// The ID of the guild that is granted access to the entitlement's sku.\n\t// Only available for guild subscriptions.\n\tGuildID string `json:\"guild_id,omitempty\"`\n\n\t// Whether or not the entitlement has been consumed.\n\t// Only available for consumable items.\n\tConsumed *bool `json:\"consumed,omitempty\"`\n\n\t// The SubscriptionID of the entitlement.\n\t// Not present when using test entitlements.\n\tSubscriptionID string `json:\"subscription_id,omitempty\"`\n}\n\n// EntitlementOwnerType is the type of entitlement (see EntitlementOwnerType* consts)\ntype EntitlementOwnerType int\n\n// Valid EntitlementOwnerType values\nconst (\n\tEntitlementOwnerTypeGuildSubscription EntitlementOwnerType = 1\n\tEntitlementOwnerTypeUserSubscription  EntitlementOwnerType = 2\n)\n\n// EntitlementTest is used to test granting an entitlement to a user or guild\ntype EntitlementTest struct {\n\t// The ID of the SKU to grant the entitlement to\n\tSKUID string `json:\"sku_id\"`\n\n\t// The ID of the guild or user to grant the entitlement to\n\tOwnerID string `json:\"owner_id\"`\n\n\t// OwnerType is the type of which the entitlement should be created\n\tOwnerType EntitlementOwnerType `json:\"owner_type\"`\n}\n\n// EntitlementFilterOptions are the options for filtering Entitlements\ntype EntitlementFilterOptions struct {\n\t// Optional user ID to look up for.\n\tUserID string\n\n\t// Optional array of SKU IDs to check for.\n\tSkuIDs []string\n\n\t// Optional timestamp to retrieve Entitlements before this time.\n\tBefore *time.Time\n\n\t// Optional timestamp to retrieve Entitlements after this time.\n\tAfter *time.Time\n\n\t// Optional maximum number of entitlements to return (1-100, default 100).\n\tLimit int\n\n\t// Optional guild ID to look up for.\n\tGuildID string\n\n\t// Optional whether or not ended entitlements should be omitted.\n\tExcludeEnded bool\n}\n\n// Constants for the different bit offsets of text channel permissions\nconst (\n\t// Deprecated: PermissionReadMessages has been replaced with PermissionViewChannel for text and voice channels\n\tPermissionReadMessages = 1 << 10\n\n\t// Allows for sending messages in a channel and creating threads in a forum (does not allow sending messages in threads).\n\tPermissionSendMessages = 1 << 11\n\n\t// Allows for sending of /tts messages.\n\tPermissionSendTTSMessages = 1 << 12\n\n\t// Allows for deletion of other users messages.\n\tPermissionManageMessages = 1 << 13\n\n\t// Links sent by users with this permission will be auto-embedded.\n\tPermissionEmbedLinks = 1 << 14\n\n\t// Allows for uploading images and files.\n\tPermissionAttachFiles = 1 << 15\n\n\t// Allows for reading of message history.\n\tPermissionReadMessageHistory = 1 << 16\n\n\t// Allows for using the @everyone tag to notify all users in a channel, and the @here tag to notify all online users in a channel.\n\tPermissionMentionEveryone = 1 << 17\n\n\t// Allows the usage of custom emojis from other servers.\n\tPermissionUseExternalEmojis = 1 << 18\n\n\t// Deprecated: PermissionUseSlashCommands has been replaced by PermissionUseApplicationCommands\n\tPermissionUseSlashCommands = 1 << 31\n\n\t// Allows members to use application commands, including slash commands and context menu commands.\n\tPermissionUseApplicationCommands = 1 << 31\n\n\t// Allows for deleting and archiving threads, and viewing all private threads.\n\tPermissionManageThreads = 1 << 34\n\n\t// Allows for creating public and announcement threads.\n\tPermissionCreatePublicThreads = 1 << 35\n\n\t// Allows for creating private threads.\n\tPermissionCreatePrivateThreads = 1 << 36\n\n\t// Allows the usage of custom stickers from other servers.\n\tPermissionUseExternalStickers = 1 << 37\n\n\t// Allows for sending messages in threads.\n\tPermissionSendMessagesInThreads = 1 << 38\n\n\t// Allows sending voice messages.\n\tPermissionSendVoiceMessages = 1 << 46\n\n\t// Allows sending polls.\n\tPermissionSendPolls = 1 << 49\n\n\t// Allows user-installed apps to send public responses. When disabled, users will still be allowed to use their apps but the responses will be ephemeral. This only applies to apps not also installed to the server.\n\tPermissionUseExternalApps = 1 << 50\n)\n\n// Constants for the different bit offsets of voice permissions\nconst (\n\t// Allows for using priority speaker in a voice channel.\n\tPermissionVoicePrioritySpeaker = 1 << 8\n\n\t// Allows the user to go live.\n\tPermissionVoiceStreamVideo = 1 << 9\n\n\t// Allows for joining of a voice channel.\n\tPermissionVoiceConnect = 1 << 20\n\n\t// Allows for speaking in a voice channel.\n\tPermissionVoiceSpeak = 1 << 21\n\n\t// Allows for muting members in a voice channel.\n\tPermissionVoiceMuteMembers = 1 << 22\n\n\t// Allows for deafening of members in a voice channel.\n\tPermissionVoiceDeafenMembers = 1 << 23\n\n\t// Allows for moving of members between voice channels.\n\tPermissionVoiceMoveMembers = 1 << 24\n\n\t// Allows for using voice-activity-detection in a voice channel.\n\tPermissionVoiceUseVAD = 1 << 25\n\n\t// Allows for requesting to speak in stage channels.\n\tPermissionVoiceRequestToSpeak = 1 << 32\n\n\t// Deprecated: PermissionUseActivities has been replaced by PermissionUseEmbeddedActivities.\n\tPermissionUseActivities = 1 << 39\n\n\t// Allows for using Activities (applications with the EMBEDDED flag) in a voice channel.\n\tPermissionUseEmbeddedActivities = 1 << 39\n\n\t// Allows for using soundboard in a voice channel.\n\tPermissionUseSoundboard = 1 << 42\n\n\t// Allows the usage of custom soundboard sounds from other servers.\n\tPermissionUseExternalSounds = 1 << 45\n)\n\n// Constants for general management.\nconst (\n\t// Allows for modification of own nickname.\n\tPermissionChangeNickname = 1 << 26\n\n\t// Allows for modification of other users nicknames.\n\tPermissionManageNicknames = 1 << 27\n\n\t// Allows management and editing of roles.\n\tPermissionManageRoles = 1 << 28\n\n\t// Allows management and editing of webhooks.\n\tPermissionManageWebhooks = 1 << 29\n\n\t// Deprecated: PermissionManageEmojis has been replaced by PermissionManageGuildExpressions.\n\tPermissionManageEmojis = 1 << 30\n\n\t// Allows for editing and deleting emojis, stickers, and soundboard sounds created by all users.\n\tPermissionManageGuildExpressions = 1 << 30\n\n\t// Allows for editing and deleting scheduled events created by all users.\n\tPermissionManageEvents = 1 << 33\n\n\t// Allows for viewing role subscription insights.\n\tPermissionViewCreatorMonetizationAnalytics = 1 << 41\n\n\t// Allows for creating emojis, stickers, and soundboard sounds, and editing and deleting those created by the current user.\n\tPermissionCreateGuildExpressions = 1 << 43\n\n\t// Allows for creating scheduled events, and editing and deleting those created by the current user.\n\tPermissionCreateEvents = 1 << 44\n)\n\n// Constants for the different bit offsets of general permissions\nconst (\n\t// Allows creation of instant invites.\n\tPermissionCreateInstantInvite = 1 << 0\n\n\t// Allows kicking members.\n\tPermissionKickMembers = 1 << 1\n\n\t// Allows banning members.\n\tPermissionBanMembers = 1 << 2\n\n\t// Allows all permissions and bypasses channel permission overwrites.\n\tPermissionAdministrator = 1 << 3\n\n\t// Allows management and editing of channels.\n\tPermissionManageChannels = 1 << 4\n\n\t// Deprecated: PermissionManageServer has been replaced by PermissionManageGuild.\n\tPermissionManageServer = 1 << 5\n\n\t// Allows management and editing of the guild.\n\tPermissionManageGuild = 1 << 5\n\n\t// Allows for the addition of reactions to messages.\n\tPermissionAddReactions = 1 << 6\n\n\t// Allows for viewing of audit logs.\n\tPermissionViewAuditLogs = 1 << 7\n\n\t// Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels.\n\tPermissionViewChannel = 1 << 10\n\n\t// Allows for viewing guild insights.\n\tPermissionViewGuildInsights = 1 << 19\n\n\t// Allows for timing out users to prevent them from sending or reacting to messages in chat and threads, and from speaking in voice and stage channels.\n\tPermissionModerateMembers = 1 << 40\n\n\tPermissionAllText = PermissionViewChannel |\n\t\tPermissionSendMessages |\n\t\tPermissionSendTTSMessages |\n\t\tPermissionManageMessages |\n\t\tPermissionEmbedLinks |\n\t\tPermissionAttachFiles |\n\t\tPermissionReadMessageHistory |\n\t\tPermissionMentionEveryone\n\tPermissionAllVoice = PermissionViewChannel |\n\t\tPermissionVoiceConnect |\n\t\tPermissionVoiceSpeak |\n\t\tPermissionVoiceMuteMembers |\n\t\tPermissionVoiceDeafenMembers |\n\t\tPermissionVoiceMoveMembers |\n\t\tPermissionVoiceUseVAD |\n\t\tPermissionVoicePrioritySpeaker\n\tPermissionAllChannel = PermissionAllText |\n\t\tPermissionAllVoice |\n\t\tPermissionCreateInstantInvite |\n\t\tPermissionManageRoles |\n\t\tPermissionManageChannels |\n\t\tPermissionAddReactions |\n\t\tPermissionViewAuditLogs\n\tPermissionAll = PermissionAllChannel |\n\t\tPermissionKickMembers |\n\t\tPermissionBanMembers |\n\t\tPermissionManageServer |\n\t\tPermissionAdministrator |\n\t\tPermissionManageWebhooks |\n\t\tPermissionManageEmojis\n)\n\n// Block contains Discord JSON Error Response codes\nconst (\n\tErrCodeGeneralError = 0\n\n\tErrCodeUnknownAccount                        = 10001\n\tErrCodeUnknownApplication                    = 10002\n\tErrCodeUnknownChannel                        = 10003\n\tErrCodeUnknownGuild                          = 10004\n\tErrCodeUnknownIntegration                    = 10005\n\tErrCodeUnknownInvite                         = 10006\n\tErrCodeUnknownMember                         = 10007\n\tErrCodeUnknownMessage                        = 10008\n\tErrCodeUnknownOverwrite                      = 10009\n\tErrCodeUnknownProvider                       = 10010\n\tErrCodeUnknownRole                           = 10011\n\tErrCodeUnknownToken                          = 10012\n\tErrCodeUnknownUser                           = 10013\n\tErrCodeUnknownEmoji                          = 10014\n\tErrCodeUnknownWebhook                        = 10015\n\tErrCodeUnknownWebhookService                 = 10016\n\tErrCodeUnknownSession                        = 10020\n\tErrCodeUnknownBan                            = 10026\n\tErrCodeUnknownSKU                            = 10027\n\tErrCodeUnknownStoreListing                   = 10028\n\tErrCodeUnknownEntitlement                    = 10029\n\tErrCodeUnknownBuild                          = 10030\n\tErrCodeUnknownLobby                          = 10031\n\tErrCodeUnknownBranch                         = 10032\n\tErrCodeUnknownStoreDirectoryLayout           = 10033\n\tErrCodeUnknownRedistributable                = 10036\n\tErrCodeUnknownGiftCode                       = 10038\n\tErrCodeUnknownStream                         = 10049\n\tErrCodeUnknownPremiumServerSubscribeCooldown = 10050\n\tErrCodeUnknownGuildTemplate                  = 10057\n\tErrCodeUnknownDiscoveryCategory              = 10059\n\tErrCodeUnknownSticker                        = 10060\n\tErrCodeUnknownInteraction                    = 10062\n\tErrCodeUnknownApplicationCommand             = 10063\n\tErrCodeUnknownApplicationCommandPermissions  = 10066\n\tErrCodeUnknownStageInstance                  = 10067\n\tErrCodeUnknownGuildMemberVerificationForm    = 10068\n\tErrCodeUnknownGuildWelcomeScreen             = 10069\n\tErrCodeUnknownGuildScheduledEvent            = 10070\n\tErrCodeUnknownGuildScheduledEventUser        = 10071\n\tErrUnknownTag                                = 10087\n\n\tErrCodeBotsCannotUseEndpoint                                            = 20001\n\tErrCodeOnlyBotsCanUseEndpoint                                           = 20002\n\tErrCodeExplicitContentCannotBeSentToTheDesiredRecipients                = 20009\n\tErrCodeYouAreNotAuthorizedToPerformThisActionOnThisApplication          = 20012\n\tErrCodeThisActionCannotBePerformedDueToSlowmodeRateLimit                = 20016\n\tErrCodeOnlyTheOwnerOfThisAccountCanPerformThisAction                    = 20018\n\tErrCodeMessageCannotBeEditedDueToAnnouncementRateLimits                 = 20022\n\tErrCodeChannelHasHitWriteRateLimit                                      = 20028\n\tErrCodeTheWriteActionYouArePerformingOnTheServerHasHitTheWriteRateLimit = 20029\n\tErrCodeStageTopicContainsNotAllowedWordsForPublicStages                 = 20031\n\tErrCodeGuildPremiumSubscriptionLevelTooLow                              = 20035\n\n\tErrCodeMaximumGuildsReached                                     = 30001\n\tErrCodeMaximumPinsReached                                       = 30003\n\tErrCodeMaximumNumberOfRecipientsReached                         = 30004\n\tErrCodeMaximumGuildRolesReached                                 = 30005\n\tErrCodeMaximumNumberOfWebhooksReached                           = 30007\n\tErrCodeMaximumNumberOfEmojisReached                             = 30008\n\tErrCodeTooManyReactions                                         = 30010\n\tErrCodeMaximumNumberOfGuildChannelsReached                      = 30013\n\tErrCodeMaximumNumberOfAttachmentsInAMessageReached              = 30015\n\tErrCodeMaximumNumberOfInvitesReached                            = 30016\n\tErrCodeMaximumNumberOfAnimatedEmojisReached                     = 30018\n\tErrCodeMaximumNumberOfServerMembersReached                      = 30019\n\tErrCodeMaximumNumberOfGuildDiscoverySubcategoriesReached        = 30030\n\tErrCodeGuildAlreadyHasATemplate                                 = 30031\n\tErrCodeMaximumNumberOfThreadParticipantsReached                 = 30033\n\tErrCodeMaximumNumberOfBansForNonGuildMembersHaveBeenExceeded    = 30035\n\tErrCodeMaximumNumberOfBansFetchesHasBeenReached                 = 30037\n\tErrCodeMaximumNumberOfUncompletedGuildScheduledEventsReached    = 30038\n\tErrCodeMaximumNumberOfStickersReached                           = 30039\n\tErrCodeMaximumNumberOfPruneRequestsHasBeenReached               = 30040\n\tErrCodeMaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached  = 30042\n\tErrCodeMaximumNumberOfEditsToMessagesOlderThanOneHourReached    = 30046\n\tErrCodeMaximumNumberOfPinnedThreadsInForumChannelHasBeenReached = 30047\n\tErrCodeMaximumNumberOfTagsInForumChannelHasBeenReached          = 30048\n\n\tErrCodeUnauthorized                           = 40001\n\tErrCodeActionRequiredVerifiedAccount          = 40002\n\tErrCodeOpeningDirectMessagesTooFast           = 40003\n\tErrCodeSendMessagesHasBeenTemporarilyDisabled = 40004\n\tErrCodeRequestEntityTooLarge                  = 40005\n\tErrCodeFeatureTemporarilyDisabledServerSide   = 40006\n\tErrCodeUserIsBannedFromThisGuild              = 40007\n\tErrCodeTargetIsNotConnectedToVoice            = 40032\n\tErrCodeMessageAlreadyCrossposted              = 40033\n\tErrCodeAnApplicationWithThatNameAlreadyExists = 40041\n\tErrCodeInteractionHasAlreadyBeenAcknowledged  = 40060\n\tErrCodeTagNamesMustBeUnique                   = 40061\n\n\tErrCodeMissingAccess                                                = 50001\n\tErrCodeInvalidAccountType                                           = 50002\n\tErrCodeCannotExecuteActionOnDMChannel                               = 50003\n\tErrCodeEmbedDisabled                                                = 50004\n\tErrCodeGuildWidgetDisabled                                          = 50004\n\tErrCodeCannotEditFromAnotherUser                                    = 50005\n\tErrCodeCannotSendEmptyMessage                                       = 50006\n\tErrCodeCannotSendMessagesToThisUser                                 = 50007\n\tErrCodeCannotSendMessagesInVoiceChannel                             = 50008\n\tErrCodeChannelVerificationLevelTooHigh                              = 50009\n\tErrCodeOAuth2ApplicationDoesNotHaveBot                              = 50010\n\tErrCodeOAuth2ApplicationLimitReached                                = 50011\n\tErrCodeInvalidOAuthState                                            = 50012\n\tErrCodeMissingPermissions                                           = 50013\n\tErrCodeInvalidAuthenticationToken                                   = 50014\n\tErrCodeTooFewOrTooManyMessagesToDelete                              = 50016\n\tErrCodeCanOnlyPinMessageToOriginatingChannel                        = 50019\n\tErrCodeInviteCodeWasEitherInvalidOrTaken                            = 50020\n\tErrCodeCannotExecuteActionOnSystemMessage                           = 50021\n\tErrCodeCannotExecuteActionOnThisChannelType                         = 50024\n\tErrCodeInvalidOAuth2AccessTokenProvided                             = 50025\n\tErrCodeMissingRequiredOAuth2Scope                                   = 50026\n\tErrCodeInvalidWebhookTokenProvided                                  = 50027\n\tErrCodeInvalidRole                                                  = 50028\n\tErrCodeInvalidRecipients                                            = 50033\n\tErrCodeMessageProvidedTooOldForBulkDelete                           = 50034\n\tErrCodeInvalidFormBody                                              = 50035\n\tErrCodeInviteAcceptedToGuildApplicationsBotNotIn                    = 50036\n\tErrCodeInvalidAPIVersionProvided                                    = 50041\n\tErrCodeFileUploadedExceedsTheMaximumSize                            = 50045\n\tErrCodeInvalidFileUploaded                                          = 50046\n\tErrCodeInvalidGuild                                                 = 50055\n\tErrCodeInvalidMessageType                                           = 50068\n\tErrCodeCannotDeleteAChannelRequiredForCommunityGuilds               = 50074\n\tErrCodeInvalidStickerSent                                           = 50081\n\tErrCodePerformedOperationOnArchivedThread                           = 50083\n\tErrCodeBeforeValueIsEarlierThanThreadCreationDate                   = 50085\n\tErrCodeCommunityServerChannelsMustBeTextChannels                    = 50086\n\tErrCodeThisServerIsNotAvailableInYourLocation                       = 50095\n\tErrCodeThisServerNeedsMonetizationEnabledInOrderToPerformThisAction = 50097\n\tErrCodeThisServerNeedsMoreBoostsToPerformThisAction                 = 50101\n\tErrCodeTheRequestBodyContainsInvalidJSON                            = 50109\n\n\tErrCodeNoUsersWithDiscordTagExist = 80004\n\n\tErrCodeReactionBlocked = 90001\n\n\tErrCodeAPIResourceIsCurrentlyOverloaded = 130000\n\n\tErrCodeTheStageIsAlreadyOpen = 150006\n\n\tErrCodeCannotReplyWithoutPermissionToReadMessageHistory = 160002\n\tErrCodeThreadAlreadyCreatedForThisMessage               = 160004\n\tErrCodeThreadIsLocked                                   = 160005\n\tErrCodeMaximumNumberOfActiveThreadsReached              = 160006\n\tErrCodeMaximumNumberOfActiveAnnouncementThreadsReached  = 160007\n\n\tErrCodeInvalidJSONForUploadedLottieFile                    = 170001\n\tErrCodeUploadedLottiesCannotContainRasterizedImages        = 170002\n\tErrCodeStickerMaximumFramerateExceeded                     = 170003\n\tErrCodeStickerFrameCountExceedsMaximumOfOneThousandFrames  = 170004\n\tErrCodeLottieAnimationMaximumDimensionsExceeded            = 170005\n\tErrCodeStickerFrameRateOutOfRange                          = 170006\n\tErrCodeStickerAnimationDurationExceedsMaximumOfFiveSeconds = 170007\n\n\tErrCodeCannotUpdateAFinishedEvent             = 180000\n\tErrCodeFailedToCreateStageNeededForStageEvent = 180002\n\n\tErrCodeCannotEnableOnboardingRequirementsAreNotMet  = 350000\n\tErrCodeCannotUpdateOnboardingWhileBelowRequirements = 350001\n)\n\n// Intent is the type of a Gateway Intent\n// https://discord.com/developers/docs/topics/gateway#gateway-intents\ntype Intent int\n\n// Constants for the different bit offsets of intents\nconst (\n\tIntentGuilds                      Intent = 1 << 0\n\tIntentGuildMembers                Intent = 1 << 1\n\tIntentGuildModeration             Intent = 1 << 2\n\tIntentGuildEmojis                 Intent = 1 << 3\n\tIntentGuildIntegrations           Intent = 1 << 4\n\tIntentGuildWebhooks               Intent = 1 << 5\n\tIntentGuildInvites                Intent = 1 << 6\n\tIntentGuildVoiceStates            Intent = 1 << 7\n\tIntentGuildPresences              Intent = 1 << 8\n\tIntentGuildMessages               Intent = 1 << 9\n\tIntentGuildMessageReactions       Intent = 1 << 10\n\tIntentGuildMessageTyping          Intent = 1 << 11\n\tIntentDirectMessages              Intent = 1 << 12\n\tIntentDirectMessageReactions      Intent = 1 << 13\n\tIntentDirectMessageTyping         Intent = 1 << 14\n\tIntentMessageContent              Intent = 1 << 15\n\tIntentGuildScheduledEvents        Intent = 1 << 16\n\tIntentAutoModerationConfiguration Intent = 1 << 20\n\tIntentAutoModerationExecution     Intent = 1 << 21\n\n\t// TODO: remove when compatibility is not needed\n\n\tIntentGuildBans Intent = IntentGuildModeration\n\n\tIntentsGuilds                 Intent = 1 << 0\n\tIntentsGuildMembers           Intent = 1 << 1\n\tIntentsGuildBans              Intent = 1 << 2\n\tIntentsGuildEmojis            Intent = 1 << 3\n\tIntentsGuildIntegrations      Intent = 1 << 4\n\tIntentsGuildWebhooks          Intent = 1 << 5\n\tIntentsGuildInvites           Intent = 1 << 6\n\tIntentsGuildVoiceStates       Intent = 1 << 7\n\tIntentsGuildPresences         Intent = 1 << 8\n\tIntentsGuildMessages          Intent = 1 << 9\n\tIntentsGuildMessageReactions  Intent = 1 << 10\n\tIntentsGuildMessageTyping     Intent = 1 << 11\n\tIntentsDirectMessages         Intent = 1 << 12\n\tIntentsDirectMessageReactions Intent = 1 << 13\n\tIntentsDirectMessageTyping    Intent = 1 << 14\n\tIntentsMessageContent         Intent = 1 << 15\n\tIntentsGuildScheduledEvents   Intent = 1 << 16\n\n\tIntentsAllWithoutPrivileged = IntentGuilds |\n\t\tIntentGuildBans |\n\t\tIntentGuildEmojis |\n\t\tIntentGuildIntegrations |\n\t\tIntentGuildWebhooks |\n\t\tIntentGuildInvites |\n\t\tIntentGuildVoiceStates |\n\t\tIntentGuildMessages |\n\t\tIntentGuildMessageReactions |\n\t\tIntentGuildMessageTyping |\n\t\tIntentDirectMessages |\n\t\tIntentDirectMessageReactions |\n\t\tIntentDirectMessageTyping |\n\t\tIntentGuildScheduledEvents |\n\t\tIntentAutoModerationConfiguration |\n\t\tIntentAutoModerationExecution\n\n\tIntentsAll = IntentsAllWithoutPrivileged |\n\t\tIntentGuildMembers |\n\t\tIntentGuildPresences |\n\t\tIntentMessageContent\n\n\tIntentsNone Intent = 0\n)\n\n// MakeIntent used to help convert a gateway intent value for use in the Identify structure;\n// this was useful to help support the use of a pointer type when intents were optional.\n// This is now a no-op, and is not necessary to use.\nfunc MakeIntent(intents Intent) Intent {\n\treturn intents\n}\n"
        },
        {
          "name": "structs_test.go",
          "type": "blob",
          "size": 0.8388671875,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage discordgo\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMember_DisplayName(t *testing.T) {\n\tuser := &User{\n\t\tGlobalName: \"Global\",\n\t}\n\tt.Run(\"no server nickname set\", func(t *testing.T) {\n\t\tm := &Member{\n\t\t\tNick: \"\",\n\t\t\tUser: user,\n\t\t}\n\t\tif dn := m.DisplayName(); dn != user.GlobalName {\n\t\t\tt.Errorf(\"Member.DisplayName() = %v, want %v\", dn, user.GlobalName)\n\t\t}\n\t})\n\tt.Run(\"server nickname set\", func(t *testing.T) {\n\t\tm := &Member{\n\t\t\tNick: \"Server\",\n\t\t\tUser: user,\n\t\t}\n\t\tif dn := m.DisplayName(); dn != m.Nick {\n\t\t\tt.Errorf(\"Member.DisplayName() = %v, want %v\", dn, m.Nick)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "user.go",
          "type": "blob",
          "size": 5.0458984375,
          "content": "package discordgo\n\nimport (\n\t\"strconv\"\n)\n\n// UserFlags is the flags of \"user\" (see UserFlags* consts)\n// https://discord.com/developers/docs/resources/user#user-object-user-flags\ntype UserFlags int\n\n// Valid UserFlags values\nconst (\n\tUserFlagDiscordEmployee           UserFlags = 1 << 0\n\tUserFlagDiscordPartner            UserFlags = 1 << 1\n\tUserFlagHypeSquadEvents           UserFlags = 1 << 2\n\tUserFlagBugHunterLevel1           UserFlags = 1 << 3\n\tUserFlagHouseBravery              UserFlags = 1 << 6\n\tUserFlagHouseBrilliance           UserFlags = 1 << 7\n\tUserFlagHouseBalance              UserFlags = 1 << 8\n\tUserFlagEarlySupporter            UserFlags = 1 << 9\n\tUserFlagTeamUser                  UserFlags = 1 << 10\n\tUserFlagSystem                    UserFlags = 1 << 12\n\tUserFlagBugHunterLevel2           UserFlags = 1 << 14\n\tUserFlagVerifiedBot               UserFlags = 1 << 16\n\tUserFlagVerifiedBotDeveloper      UserFlags = 1 << 17\n\tUserFlagDiscordCertifiedModerator UserFlags = 1 << 18\n\tUserFlagBotHTTPInteractions       UserFlags = 1 << 19\n\tUserFlagActiveBotDeveloper        UserFlags = 1 << 22\n)\n\n// UserPremiumType is the type of premium (nitro) subscription a user has (see UserPremiumType* consts).\n// https://discord.com/developers/docs/resources/user#user-object-premium-types\ntype UserPremiumType int\n\n// Valid UserPremiumType values.\nconst (\n\tUserPremiumTypeNone         UserPremiumType = 0\n\tUserPremiumTypeNitroClassic UserPremiumType = 1\n\tUserPremiumTypeNitro        UserPremiumType = 2\n\tUserPremiumTypeNitroBasic   UserPremiumType = 3\n)\n\n// A User stores all data for an individual Discord user.\ntype User struct {\n\t// The ID of the user.\n\tID string `json:\"id\"`\n\n\t// The email of the user. This is only present when\n\t// the application possesses the email scope for the user.\n\tEmail string `json:\"email\"`\n\n\t// The user's username.\n\tUsername string `json:\"username\"`\n\n\t// The hash of the user's avatar. Use Session.UserAvatar\n\t// to retrieve the avatar itself.\n\tAvatar string `json:\"avatar\"`\n\n\t// The user's chosen language option.\n\tLocale string `json:\"locale\"`\n\n\t// The discriminator of the user (4 numbers after name).\n\tDiscriminator string `json:\"discriminator\"`\n\n\t// The user's display name, if it is set.\n\t// For bots, this is the application name.\n\tGlobalName string `json:\"global_name\"`\n\n\t// The token of the user. This is only present for\n\t// the user represented by the current session.\n\tToken string `json:\"token\"`\n\n\t// Whether the user's email is verified.\n\tVerified bool `json:\"verified\"`\n\n\t// Whether the user has multi-factor authentication enabled.\n\tMFAEnabled bool `json:\"mfa_enabled\"`\n\n\t// The hash of the user's banner image.\n\tBanner string `json:\"banner\"`\n\n\t// User's banner color, encoded as an integer representation of hexadecimal color code\n\tAccentColor int `json:\"accent_color\"`\n\n\t// Whether the user is a bot.\n\tBot bool `json:\"bot\"`\n\n\t// The public flags on a user's account.\n\t// This is a combination of bit masks; the presence of a certain flag can\n\t// be checked by performing a bitwise AND between this int and the flag.\n\tPublicFlags UserFlags `json:\"public_flags\"`\n\n\t// The type of Nitro subscription on a user's account.\n\t// Only available when the request is authorized via a Bearer token.\n\tPremiumType UserPremiumType `json:\"premium_type\"`\n\n\t// Whether the user is an Official Discord System user (part of the urgent message system).\n\tSystem bool `json:\"system\"`\n\n\t// The flags on a user's account.\n\t// Only available when the request is authorized via a Bearer token.\n\tFlags int `json:\"flags\"`\n}\n\n// String returns a unique identifier of the form username#discriminator\n// or just username, if the discriminator is set to \"0\".\nfunc (u *User) String() string {\n\t// If the user has been migrated from the legacy username system, their discriminator is \"0\".\n\t// See https://support-dev.discord.com/hc/en-us/articles/13667755828631\n\tif u.Discriminator == \"0\" {\n\t\treturn u.Username\n\t}\n\n\treturn u.Username + \"#\" + u.Discriminator\n}\n\n// Mention return a string which mentions the user\nfunc (u *User) Mention() string {\n\treturn \"<@\" + u.ID + \">\"\n}\n\n// AvatarURL returns a URL to the user's avatar.\n//\n//\tsize:    The size of the user's avatar as a power of two\n//\t         if size is an empty string, no size parameter will\n//\t         be added to the URL.\nfunc (u *User) AvatarURL(size string) string {\n\treturn avatarURL(\n\t\tu.Avatar,\n\t\tEndpointDefaultUserAvatar(u.DefaultAvatarIndex()),\n\t\tEndpointUserAvatar(u.ID, u.Avatar),\n\t\tEndpointUserAvatarAnimated(u.ID, u.Avatar),\n\t\tsize,\n\t)\n}\n\n// BannerURL returns the URL of the users's banner image.\n//\n//\tsize:    The size of the desired banner image as a power of two\n//\t         Image size can be any power of two between 16 and 4096.\nfunc (u *User) BannerURL(size string) string {\n\treturn bannerURL(u.Banner, EndpointUserBanner(u.ID, u.Banner), EndpointUserBannerAnimated(u.ID, u.Banner), size)\n}\n\n// DefaultAvatarIndex returns the index of the user's default avatar.\nfunc (u *User) DefaultAvatarIndex() int {\n\tif u.Discriminator == \"0\" {\n\t\tid, _ := strconv.ParseUint(u.ID, 10, 64)\n\t\treturn int((id >> 22) % 6)\n\t}\n\n\tid, _ := strconv.Atoi(u.Discriminator)\n\treturn id % 5\n}\n"
        },
        {
          "name": "user_test.go",
          "type": "blob",
          "size": 0.6201171875,
          "content": "package discordgo\n\nimport \"testing\"\n\nfunc TestUser_String(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname string\n\t\tu    *User\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"User with a discriminator\",\n\t\t\tu: &User{\n\t\t\t\tUsername:      \"bob\",\n\t\t\t\tDiscriminator: \"8192\",\n\t\t\t},\n\t\t\twant: \"bob#8192\",\n\t\t},\n\t\t{\n\t\t\tname: \"User with discriminator set to 0\",\n\t\t\tu: &User{\n\t\t\t\tUsername:      \"aldiwildan\",\n\t\t\t\tDiscriminator: \"0\",\n\t\t\t},\n\t\t\twant: \"aldiwildan\",\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := tc.u.String(); got != tc.want {\n\t\t\t\tt.Errorf(\"User.String() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.6552734375,
          "content": "package discordgo\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/textproto\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// SnowflakeTimestamp returns the creation time of a Snowflake ID relative to the creation of Discord.\nfunc SnowflakeTimestamp(ID string) (t time.Time, err error) {\n\ti, err := strconv.ParseInt(ID, 10, 64)\n\tif err != nil {\n\t\treturn\n\t}\n\ttimestamp := (i >> 22) + 1420070400000\n\tt = time.Unix(0, timestamp*1000000)\n\treturn\n}\n\n// MultipartBodyWithJSON returns the contentType and body for a discord request\n// data  : The object to encode for payload_json in the multipart request\n// files : Files to include in the request\nfunc MultipartBodyWithJSON(data interface{}, files []*File) (requestContentType string, requestBody []byte, err error) {\n\tbody := &bytes.Buffer{}\n\tbodywriter := multipart.NewWriter(body)\n\n\tpayload, err := Marshal(data)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvar p io.Writer\n\n\th := make(textproto.MIMEHeader)\n\th.Set(\"Content-Disposition\", `form-data; name=\"payload_json\"`)\n\th.Set(\"Content-Type\", \"application/json\")\n\n\tp, err = bodywriter.CreatePart(h)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif _, err = p.Write(payload); err != nil {\n\t\treturn\n\t}\n\n\tfor i, file := range files {\n\t\th := make(textproto.MIMEHeader)\n\t\th.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"files[%d]\"; filename=\"%s\"`, i, quoteEscaper.Replace(file.Name)))\n\t\tcontentType := file.ContentType\n\t\tif contentType == \"\" {\n\t\t\tcontentType = \"application/octet-stream\"\n\t\t}\n\t\th.Set(\"Content-Type\", contentType)\n\n\t\tp, err = bodywriter.CreatePart(h)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif _, err = io.Copy(p, file.Reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = bodywriter.Close()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn bodywriter.FormDataContentType(), body.Bytes(), nil\n}\n\nfunc avatarURL(avatarHash, defaultAvatarURL, staticAvatarURL, animatedAvatarURL, size string) string {\n\tvar URL string\n\tif avatarHash == \"\" {\n\t\tURL = defaultAvatarURL\n\t} else if strings.HasPrefix(avatarHash, \"a_\") {\n\t\tURL = animatedAvatarURL\n\t} else {\n\t\tURL = staticAvatarURL\n\t}\n\n\tif size != \"\" {\n\t\treturn URL + \"?size=\" + size\n\t}\n\treturn URL\n}\n\nfunc bannerURL(bannerHash, staticBannerURL, animatedBannerURL, size string) string {\n\tvar URL string\n\tif bannerHash == \"\" {\n\t\treturn \"\"\n\t} else if strings.HasPrefix(bannerHash, \"a_\") {\n\t\tURL = animatedBannerURL\n\t} else {\n\t\tURL = staticBannerURL\n\t}\n\n\tif size != \"\" {\n\t\treturn URL + \"?size=\" + size\n\t}\n\treturn URL\n}\n\nfunc iconURL(iconHash, staticIconURL, animatedIconURL, size string) string {\n\tvar URL string\n\tif iconHash == \"\" {\n\t\treturn \"\"\n\t} else if strings.HasPrefix(iconHash, \"a_\") {\n\t\tURL = animatedIconURL\n\t} else {\n\t\tURL = staticIconURL\n\t}\n\n\tif size != \"\" {\n\t\treturn URL + \"?size=\" + size\n\t}\n\treturn URL\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.498046875,
          "content": "package discordgo\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSnowflakeTimestamp(t *testing.T) {\n\t// #discordgo channel ID :)\n\tid := \"155361364909621248\"\n\tparsedTimestamp, err := SnowflakeTimestamp(id)\n\n\tif err != nil {\n\t\tt.Errorf(\"returned error incorrect: got %v, want nil\", err)\n\t}\n\n\tcorrectTimestamp := time.Date(2016, time.March, 4, 17, 10, 35, 869*1000000, time.UTC)\n\tif !parsedTimestamp.Equal(correctTimestamp) {\n\t\tt.Errorf(\"parsed time incorrect: got %v, want %v\", parsedTimestamp, correctTimestamp)\n\t}\n}\n"
        },
        {
          "name": "voice.go",
          "type": "blob",
          "size": 23.81640625,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains code related to Discord voice suppport\n\npackage discordgo\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/crypto/nacl/secretbox\"\n)\n\n// ------------------------------------------------------------------------------------------------\n// Code related to both VoiceConnection Websocket and UDP connections.\n// ------------------------------------------------------------------------------------------------\n\n// A VoiceConnection struct holds all the data and functions related to a Discord Voice Connection.\ntype VoiceConnection struct {\n\tsync.RWMutex\n\n\tDebug        bool // If true, print extra logging -- DEPRECATED\n\tLogLevel     int\n\tReady        bool // If true, voice is ready to send/receive audio\n\tUserID       string\n\tGuildID      string\n\tChannelID    string\n\tdeaf         bool\n\tmute         bool\n\tspeaking     bool\n\treconnecting bool // If true, voice connection is trying to reconnect\n\n\tOpusSend chan []byte  // Chan for sending opus audio\n\tOpusRecv chan *Packet // Chan for receiving opus audio\n\n\twsConn  *websocket.Conn\n\twsMutex sync.Mutex\n\tudpConn *net.UDPConn\n\tsession *Session\n\n\tsessionID string\n\ttoken     string\n\tendpoint  string\n\n\t// Used to send a close signal to goroutines\n\tclose chan struct{}\n\n\t// Used to allow blocking until connected\n\tconnected chan bool\n\n\t// Used to pass the sessionid from onVoiceStateUpdate\n\t// sessionRecv chan string UNUSED ATM\n\n\top4 voiceOP4\n\top2 voiceOP2\n\n\tvoiceSpeakingUpdateHandlers []VoiceSpeakingUpdateHandler\n}\n\n// VoiceSpeakingUpdateHandler type provides a function definition for the\n// VoiceSpeakingUpdate event\ntype VoiceSpeakingUpdateHandler func(vc *VoiceConnection, vs *VoiceSpeakingUpdate)\n\n// Speaking sends a speaking notification to Discord over the voice websocket.\n// This must be sent as true prior to sending audio and should be set to false\n// once finished sending audio.\n// b : Send true if speaking, false if not.\nfunc (v *VoiceConnection) Speaking(b bool) (err error) {\n\n\tv.log(LogDebug, \"called (%t)\", b)\n\n\ttype voiceSpeakingData struct {\n\t\tSpeaking bool `json:\"speaking\"`\n\t\tDelay    int  `json:\"delay\"`\n\t}\n\n\ttype voiceSpeakingOp struct {\n\t\tOp   int               `json:\"op\"` // Always 5\n\t\tData voiceSpeakingData `json:\"d\"`\n\t}\n\n\tif v.wsConn == nil {\n\t\treturn fmt.Errorf(\"no VoiceConnection websocket\")\n\t}\n\n\tdata := voiceSpeakingOp{5, voiceSpeakingData{b, 0}}\n\tv.wsMutex.Lock()\n\terr = v.wsConn.WriteJSON(data)\n\tv.wsMutex.Unlock()\n\n\tv.Lock()\n\tdefer v.Unlock()\n\tif err != nil {\n\t\tv.speaking = false\n\t\tv.log(LogError, \"Speaking() write json error, %s\", err)\n\t\treturn\n\t}\n\n\tv.speaking = b\n\n\treturn\n}\n\n// ChangeChannel sends Discord a request to change channels within a Guild\n// !!! NOTE !!! This function may be removed in favour of just using ChannelVoiceJoin\nfunc (v *VoiceConnection) ChangeChannel(channelID string, mute, deaf bool) (err error) {\n\n\tv.log(LogInformational, \"called\")\n\n\tdata := voiceChannelJoinOp{4, voiceChannelJoinData{&v.GuildID, &channelID, mute, deaf}}\n\tv.session.wsMutex.Lock()\n\terr = v.session.wsConn.WriteJSON(data)\n\tv.session.wsMutex.Unlock()\n\tif err != nil {\n\t\treturn\n\t}\n\tv.ChannelID = channelID\n\tv.deaf = deaf\n\tv.mute = mute\n\tv.speaking = false\n\n\treturn\n}\n\n// Disconnect disconnects from this voice channel and closes the websocket\n// and udp connections to Discord.\nfunc (v *VoiceConnection) Disconnect() (err error) {\n\n\t// Send a OP4 with a nil channel to disconnect\n\tv.Lock()\n\tif v.sessionID != \"\" {\n\t\tdata := voiceChannelJoinOp{4, voiceChannelJoinData{&v.GuildID, nil, true, true}}\n\t\tv.session.wsMutex.Lock()\n\t\terr = v.session.wsConn.WriteJSON(data)\n\t\tv.session.wsMutex.Unlock()\n\t\tv.sessionID = \"\"\n\t}\n\tv.Unlock()\n\n\t// Close websocket and udp connections\n\tv.Close()\n\n\tv.log(LogInformational, \"Deleting VoiceConnection %s\", v.GuildID)\n\n\tv.session.Lock()\n\tdelete(v.session.VoiceConnections, v.GuildID)\n\tv.session.Unlock()\n\n\treturn\n}\n\n// Close closes the voice ws and udp connections\nfunc (v *VoiceConnection) Close() {\n\n\tv.log(LogInformational, \"called\")\n\n\tv.Lock()\n\tdefer v.Unlock()\n\n\tv.Ready = false\n\tv.speaking = false\n\n\tif v.close != nil {\n\t\tv.log(LogInformational, \"closing v.close\")\n\t\tclose(v.close)\n\t\tv.close = nil\n\t}\n\n\tif v.udpConn != nil {\n\t\tv.log(LogInformational, \"closing udp\")\n\t\terr := v.udpConn.Close()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error closing udp connection, %s\", err)\n\t\t}\n\t\tv.udpConn = nil\n\t}\n\n\tif v.wsConn != nil {\n\t\tv.log(LogInformational, \"sending close frame\")\n\n\t\t// To cleanly close a connection, a client should send a close\n\t\t// frame and wait for the server to close the connection.\n\t\tv.wsMutex.Lock()\n\t\terr := v.wsConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\tv.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error closing websocket, %s\", err)\n\t\t}\n\n\t\t// TODO: Wait for Discord to actually close the connection.\n\t\ttime.Sleep(1 * time.Second)\n\n\t\tv.log(LogInformational, \"closing websocket\")\n\t\terr = v.wsConn.Close()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error closing websocket, %s\", err)\n\t\t}\n\n\t\tv.wsConn = nil\n\t}\n}\n\n// AddHandler adds a Handler for VoiceSpeakingUpdate events.\nfunc (v *VoiceConnection) AddHandler(h VoiceSpeakingUpdateHandler) {\n\tv.Lock()\n\tdefer v.Unlock()\n\n\tv.voiceSpeakingUpdateHandlers = append(v.voiceSpeakingUpdateHandlers, h)\n}\n\n// VoiceSpeakingUpdate is a struct for a VoiceSpeakingUpdate event.\ntype VoiceSpeakingUpdate struct {\n\tUserID   string `json:\"user_id\"`\n\tSSRC     int    `json:\"ssrc\"`\n\tSpeaking bool   `json:\"speaking\"`\n}\n\n// ------------------------------------------------------------------------------------------------\n// Unexported Internal Functions Below.\n// ------------------------------------------------------------------------------------------------\n\n// A voiceOP4 stores the data for the voice operation 4 websocket event\n// which provides us with the NaCl SecretBox encryption key\ntype voiceOP4 struct {\n\tSecretKey [32]byte `json:\"secret_key\"`\n\tMode      string   `json:\"mode\"`\n}\n\n// A voiceOP2 stores the data for the voice operation 2 websocket event\n// which is sort of like the voice READY packet\ntype voiceOP2 struct {\n\tSSRC              uint32        `json:\"ssrc\"`\n\tPort              int           `json:\"port\"`\n\tModes             []string      `json:\"modes\"`\n\tHeartbeatInterval time.Duration `json:\"heartbeat_interval\"`\n\tIP                string        `json:\"ip\"`\n}\n\n// WaitUntilConnected waits for the Voice Connection to\n// become ready, if it does not become ready it returns an err\nfunc (v *VoiceConnection) waitUntilConnected() error {\n\n\tv.log(LogInformational, \"called\")\n\n\ti := 0\n\tfor {\n\t\tv.RLock()\n\t\tready := v.Ready\n\t\tv.RUnlock()\n\t\tif ready {\n\t\t\treturn nil\n\t\t}\n\n\t\tif i > 10 {\n\t\t\treturn fmt.Errorf(\"timeout waiting for voice\")\n\t\t}\n\n\t\ttime.Sleep(1 * time.Second)\n\t\ti++\n\t}\n}\n\n// Open opens a voice connection.  This should be called\n// after VoiceChannelJoin is used and the data VOICE websocket events\n// are captured.\nfunc (v *VoiceConnection) open() (err error) {\n\n\tv.log(LogInformational, \"called\")\n\n\tv.Lock()\n\tdefer v.Unlock()\n\n\t// Don't open a websocket if one is already open\n\tif v.wsConn != nil {\n\t\tv.log(LogWarning, \"refusing to overwrite non-nil websocket\")\n\t\treturn\n\t}\n\n\t// TODO temp? loop to wait for the SessionID\n\ti := 0\n\tfor {\n\t\tif v.sessionID != \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\tif i > 20 { // only loop for up to 1 second total\n\t\t\treturn fmt.Errorf(\"did not receive voice Session ID in time\")\n\t\t}\n\t\t// Release the lock, so sessionID can be populated upon receiving a VoiceStateUpdate event.\n\t\tv.Unlock()\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\ti++\n\t\tv.Lock()\n\t}\n\n\t// Connect to VoiceConnection Websocket\n\tvg := \"wss://\" + strings.TrimSuffix(v.endpoint, \":80\")\n\tv.log(LogInformational, \"connecting to voice endpoint %s\", vg)\n\tv.wsConn, _, err = v.session.Dialer.Dial(vg, nil)\n\tif err != nil {\n\t\tv.log(LogWarning, \"error connecting to voice endpoint %s, %s\", vg, err)\n\t\tv.log(LogDebug, \"voice struct: %#v\\n\", v)\n\t\treturn\n\t}\n\n\ttype voiceHandshakeData struct {\n\t\tServerID  string `json:\"server_id\"`\n\t\tUserID    string `json:\"user_id\"`\n\t\tSessionID string `json:\"session_id\"`\n\t\tToken     string `json:\"token\"`\n\t}\n\ttype voiceHandshakeOp struct {\n\t\tOp   int                `json:\"op\"` // Always 0\n\t\tData voiceHandshakeData `json:\"d\"`\n\t}\n\tdata := voiceHandshakeOp{0, voiceHandshakeData{v.GuildID, v.UserID, v.sessionID, v.token}}\n\n\tv.wsMutex.Lock()\n\terr = v.wsConn.WriteJSON(data)\n\tv.wsMutex.Unlock()\n\tif err != nil {\n\t\tv.log(LogWarning, \"error sending init packet, %s\", err)\n\t\treturn\n\t}\n\n\tv.close = make(chan struct{})\n\tgo v.wsListen(v.wsConn, v.close)\n\n\t// add loop/check for Ready bool here?\n\t// then return false if not ready?\n\t// but then wsListen will also err.\n\n\treturn\n}\n\n// wsListen listens on the voice websocket for messages and passes them\n// to the voice event handler.  This is automatically called by the Open func\nfunc (v *VoiceConnection) wsListen(wsConn *websocket.Conn, close <-chan struct{}) {\n\n\tv.log(LogInformational, \"called\")\n\n\tfor {\n\t\t_, message, err := v.wsConn.ReadMessage()\n\t\tif err != nil {\n\t\t\t// 4014 indicates a manual disconnection by someone in the guild;\n\t\t\t// we shouldn't reconnect.\n\t\t\tif websocket.IsCloseError(err, 4014) {\n\t\t\t\tv.log(LogInformational, \"received 4014 manual disconnection\")\n\n\t\t\t\t// Abandon the voice WS connection\n\t\t\t\tv.Lock()\n\t\t\t\tv.wsConn = nil\n\t\t\t\tv.Unlock()\n\n\t\t\t\t// Wait for VOICE_SERVER_UPDATE.\n\t\t\t\t// When the bot is moved by the user to another voice channel,\n\t\t\t\t// VOICE_SERVER_UPDATE is received after the code 4014.\n\t\t\t\tfor i := 0; i < 5; i++ { // TODO: temp, wait for VoiceServerUpdate.\n\t\t\t\t\t<-time.After(1 * time.Second)\n\n\t\t\t\t\tv.RLock()\n\t\t\t\t\treconnected := v.wsConn != nil\n\t\t\t\t\tv.RUnlock()\n\t\t\t\t\tif !reconnected {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tv.log(LogInformational, \"successfully reconnected after 4014 manual disconnection\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// When VOICE_SERVER_UPDATE is not received, disconnect as usual.\n\t\t\t\tv.log(LogInformational, \"disconnect due to 4014 manual disconnection\")\n\n\t\t\t\tv.session.Lock()\n\t\t\t\tdelete(v.session.VoiceConnections, v.GuildID)\n\t\t\t\tv.session.Unlock()\n\n\t\t\t\tv.Close()\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Detect if we have been closed manually. If a Close() has already\n\t\t\t// happened, the websocket we are listening on will be different to the\n\t\t\t// current session.\n\t\t\tv.RLock()\n\t\t\tsameConnection := v.wsConn == wsConn\n\t\t\tv.RUnlock()\n\t\t\tif sameConnection {\n\n\t\t\t\tv.log(LogError, \"voice endpoint %s websocket closed unexpectantly, %s\", v.endpoint, err)\n\n\t\t\t\t// Start reconnect goroutine then exit.\n\t\t\t\tgo v.reconnect()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Pass received message to voice event handler\n\t\tselect {\n\t\tcase <-close:\n\t\t\treturn\n\t\tdefault:\n\t\t\tgo v.onEvent(message)\n\t\t}\n\t}\n}\n\n// wsEvent handles any voice websocket events. This is only called by the\n// wsListen() function.\nfunc (v *VoiceConnection) onEvent(message []byte) {\n\n\tv.log(LogDebug, \"received: %s\", string(message))\n\n\tvar e Event\n\tif err := json.Unmarshal(message, &e); err != nil {\n\t\tv.log(LogError, \"unmarshall error, %s\", err)\n\t\treturn\n\t}\n\n\tswitch e.Operation {\n\n\tcase 2: // READY\n\n\t\tif err := json.Unmarshal(e.RawData, &v.op2); err != nil {\n\t\t\tv.log(LogError, \"OP2 unmarshall error, %s, %s\", err, string(e.RawData))\n\t\t\treturn\n\t\t}\n\n\t\t// Start the voice websocket heartbeat to keep the connection alive\n\t\tgo v.wsHeartbeat(v.wsConn, v.close, v.op2.HeartbeatInterval)\n\t\t// TODO monitor a chan/bool to verify this was successful\n\n\t\t// Start the UDP connection\n\t\terr := v.udpOpen()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error opening udp connection, %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Start the opusSender.\n\t\t// TODO: Should we allow 48000/960 values to be user defined?\n\t\tif v.OpusSend == nil {\n\t\t\tv.OpusSend = make(chan []byte, 2)\n\t\t}\n\t\tgo v.opusSender(v.udpConn, v.close, v.OpusSend, 48000, 960)\n\n\t\t// Start the opusReceiver\n\t\tif !v.deaf {\n\t\t\tif v.OpusRecv == nil {\n\t\t\t\tv.OpusRecv = make(chan *Packet, 2)\n\t\t\t}\n\n\t\t\tgo v.opusReceiver(v.udpConn, v.close, v.OpusRecv)\n\t\t}\n\n\t\treturn\n\n\tcase 3: // HEARTBEAT response\n\t\t// add code to use this to track latency?\n\t\treturn\n\n\tcase 4: // udp encryption secret key\n\t\tv.Lock()\n\t\tdefer v.Unlock()\n\n\t\tv.op4 = voiceOP4{}\n\t\tif err := json.Unmarshal(e.RawData, &v.op4); err != nil {\n\t\t\tv.log(LogError, \"OP4 unmarshall error, %s, %s\", err, string(e.RawData))\n\t\t\treturn\n\t\t}\n\t\treturn\n\n\tcase 5:\n\t\tif len(v.voiceSpeakingUpdateHandlers) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tvoiceSpeakingUpdate := &VoiceSpeakingUpdate{}\n\t\tif err := json.Unmarshal(e.RawData, voiceSpeakingUpdate); err != nil {\n\t\t\tv.log(LogError, \"OP5 unmarshall error, %s, %s\", err, string(e.RawData))\n\t\t\treturn\n\t\t}\n\n\t\tfor _, h := range v.voiceSpeakingUpdateHandlers {\n\t\t\th(v, voiceSpeakingUpdate)\n\t\t}\n\n\tdefault:\n\t\tv.log(LogDebug, \"unknown voice operation, %d, %s\", e.Operation, string(e.RawData))\n\t}\n\n\treturn\n}\n\ntype voiceHeartbeatOp struct {\n\tOp   int `json:\"op\"` // Always 3\n\tData int `json:\"d\"`\n}\n\n// NOTE :: When a guild voice server changes how do we shut this down\n// properly, so a new connection can be setup without fuss?\n//\n// wsHeartbeat sends regular heartbeats to voice Discord so it knows the client\n// is still connected.  If you do not send these heartbeats Discord will\n// disconnect the websocket connection after a few seconds.\nfunc (v *VoiceConnection) wsHeartbeat(wsConn *websocket.Conn, close <-chan struct{}, i time.Duration) {\n\n\tif close == nil || wsConn == nil {\n\t\treturn\n\t}\n\n\tvar err error\n\tticker := time.NewTicker(i * time.Millisecond)\n\tdefer ticker.Stop()\n\tfor {\n\t\tv.log(LogDebug, \"sending heartbeat packet\")\n\t\tv.wsMutex.Lock()\n\t\terr = wsConn.WriteJSON(voiceHeartbeatOp{3, int(time.Now().Unix())})\n\t\tv.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error sending heartbeat to voice endpoint %s, %s\", v.endpoint, err)\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// continue loop and send heartbeat\n\t\tcase <-close:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// ------------------------------------------------------------------------------------------------\n// Code related to the VoiceConnection UDP connection\n// ------------------------------------------------------------------------------------------------\n\ntype voiceUDPData struct {\n\tAddress string `json:\"address\"` // Public IP of machine running this code\n\tPort    uint16 `json:\"port\"`    // UDP Port of machine running this code\n\tMode    string `json:\"mode\"`    // always \"xsalsa20_poly1305\"\n}\n\ntype voiceUDPD struct {\n\tProtocol string       `json:\"protocol\"` // Always \"udp\" ?\n\tData     voiceUDPData `json:\"data\"`\n}\n\ntype voiceUDPOp struct {\n\tOp   int       `json:\"op\"` // Always 1\n\tData voiceUDPD `json:\"d\"`\n}\n\n// udpOpen opens a UDP connection to the voice server and completes the\n// initial required handshake.  This connection is left open in the session\n// and can be used to send or receive audio.  This should only be called\n// from voice.wsEvent OP2\nfunc (v *VoiceConnection) udpOpen() (err error) {\n\n\tv.Lock()\n\tdefer v.Unlock()\n\n\tif v.wsConn == nil {\n\t\treturn fmt.Errorf(\"nil voice websocket\")\n\t}\n\n\tif v.udpConn != nil {\n\t\treturn fmt.Errorf(\"udp connection already open\")\n\t}\n\n\tif v.close == nil {\n\t\treturn fmt.Errorf(\"nil close channel\")\n\t}\n\n\tif v.endpoint == \"\" {\n\t\treturn fmt.Errorf(\"empty endpoint\")\n\t}\n\n\thost := v.op2.IP + \":\" + strconv.Itoa(v.op2.Port)\n\taddr, err := net.ResolveUDPAddr(\"udp\", host)\n\tif err != nil {\n\t\tv.log(LogWarning, \"error resolving udp host %s, %s\", host, err)\n\t\treturn\n\t}\n\n\tv.log(LogInformational, \"connecting to udp addr %s\", addr.String())\n\tv.udpConn, err = net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\tv.log(LogWarning, \"error connecting to udp addr %s, %s\", addr.String(), err)\n\t\treturn\n\t}\n\n\t// Create a 74 byte array to store the packet data\n\tsb := make([]byte, 74)\n\tbinary.BigEndian.PutUint16(sb, 1)              // Packet type (0x1 is request, 0x2 is response)\n\tbinary.BigEndian.PutUint16(sb[2:], 70)         // Packet length (excluding type and length fields)\n\tbinary.BigEndian.PutUint32(sb[4:], v.op2.SSRC) // The SSRC code from the Op 2 VoiceConnection event\n\n\t// And send that data over the UDP connection to Discord.\n\t_, err = v.udpConn.Write(sb)\n\tif err != nil {\n\t\tv.log(LogWarning, \"udp write error to %s, %s\", addr.String(), err)\n\t\treturn\n\t}\n\n\t// Create a 74 byte array and listen for the initial handshake response\n\t// from Discord.  Once we get it parse the IP and PORT information out\n\t// of the response.  This should be our public IP and PORT as Discord\n\t// saw us.\n\trb := make([]byte, 74)\n\trlen, _, err := v.udpConn.ReadFromUDP(rb)\n\tif err != nil {\n\t\tv.log(LogWarning, \"udp read error, %s, %s\", addr.String(), err)\n\t\treturn\n\t}\n\n\tif rlen < 74 {\n\t\tv.log(LogWarning, \"received udp packet too small\")\n\t\treturn fmt.Errorf(\"received udp packet too small\")\n\t}\n\n\t// Loop over position 8 through 71 to grab the IP address.\n\tvar ip string\n\tfor i := 8; i < len(rb)-2; i++ {\n\t\tif rb[i] == 0 {\n\t\t\tbreak\n\t\t}\n\t\tip += string(rb[i])\n\t}\n\n\t// Grab port from position 72 and 73\n\tport := binary.BigEndian.Uint16(rb[len(rb)-2:])\n\n\t// Take the data from above and send it back to Discord to finalize\n\t// the UDP connection handshake.\n\tdata := voiceUDPOp{1, voiceUDPD{\"udp\", voiceUDPData{ip, port, \"xsalsa20_poly1305\"}}}\n\n\tv.wsMutex.Lock()\n\terr = v.wsConn.WriteJSON(data)\n\tv.wsMutex.Unlock()\n\tif err != nil {\n\t\tv.log(LogWarning, \"udp write error, %#v, %s\", data, err)\n\t\treturn\n\t}\n\n\t// start udpKeepAlive\n\tgo v.udpKeepAlive(v.udpConn, v.close, 5*time.Second)\n\t// TODO: find a way to check that it fired off okay\n\n\treturn\n}\n\n// udpKeepAlive sends a udp packet to keep the udp connection open\n// This is still a bit of a \"proof of concept\"\nfunc (v *VoiceConnection) udpKeepAlive(udpConn *net.UDPConn, close <-chan struct{}, i time.Duration) {\n\n\tif udpConn == nil || close == nil {\n\t\treturn\n\t}\n\n\tvar err error\n\tvar sequence uint64\n\n\tpacket := make([]byte, 8)\n\n\tticker := time.NewTicker(i)\n\tdefer ticker.Stop()\n\tfor {\n\n\t\tbinary.LittleEndian.PutUint64(packet, sequence)\n\t\tsequence++\n\n\t\t_, err = udpConn.Write(packet)\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"write error, %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// continue loop and send keepalive\n\t\tcase <-close:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// opusSender will listen on the given channel and send any\n// pre-encoded opus audio to Discord.  Supposedly.\nfunc (v *VoiceConnection) opusSender(udpConn *net.UDPConn, close <-chan struct{}, opus <-chan []byte, rate, size int) {\n\n\tif udpConn == nil || close == nil {\n\t\treturn\n\t}\n\n\t// VoiceConnection is now ready to receive audio packets\n\t// TODO: this needs reviewed as I think there must be a better way.\n\tv.Lock()\n\tv.Ready = true\n\tv.Unlock()\n\tdefer func() {\n\t\tv.Lock()\n\t\tv.Ready = false\n\t\tv.Unlock()\n\t}()\n\n\tvar sequence uint16\n\tvar timestamp uint32\n\tvar recvbuf []byte\n\tvar ok bool\n\tudpHeader := make([]byte, 12)\n\tvar nonce [24]byte\n\n\t// build the parts that don't change in the udpHeader\n\tudpHeader[0] = 0x80\n\tudpHeader[1] = 0x78\n\tbinary.BigEndian.PutUint32(udpHeader[8:], v.op2.SSRC)\n\n\t// start a send loop that loops until buf chan is closed\n\tticker := time.NewTicker(time.Millisecond * time.Duration(size/(rate/1000)))\n\tdefer ticker.Stop()\n\tfor {\n\n\t\t// Get data from chan.  If chan is closed, return.\n\t\tselect {\n\t\tcase <-close:\n\t\t\treturn\n\t\tcase recvbuf, ok = <-opus:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// else, continue loop\n\t\t}\n\n\t\tv.RLock()\n\t\tspeaking := v.speaking\n\t\tv.RUnlock()\n\t\tif !speaking {\n\t\t\terr := v.Speaking(true)\n\t\t\tif err != nil {\n\t\t\t\tv.log(LogError, \"error sending speaking packet, %s\", err)\n\t\t\t}\n\t\t}\n\n\t\t// Add sequence and timestamp to udpPacket\n\t\tbinary.BigEndian.PutUint16(udpHeader[2:], sequence)\n\t\tbinary.BigEndian.PutUint32(udpHeader[4:], timestamp)\n\n\t\t// encrypt the opus data\n\t\tcopy(nonce[:], udpHeader)\n\t\tv.RLock()\n\t\tsendbuf := secretbox.Seal(udpHeader, recvbuf, &nonce, &v.op4.SecretKey)\n\t\tv.RUnlock()\n\n\t\t// block here until we're exactly at the right time :)\n\t\t// Then send rtp audio packet to Discord over UDP\n\t\tselect {\n\t\tcase <-close:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\t// continue\n\t\t}\n\t\t_, err := udpConn.Write(sendbuf)\n\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"udp write error, %s\", err)\n\t\t\tv.log(LogDebug, \"voice struct: %#v\\n\", v)\n\t\t\treturn\n\t\t}\n\n\t\tif (sequence) == 0xFFFF {\n\t\t\tsequence = 0\n\t\t} else {\n\t\t\tsequence++\n\t\t}\n\n\t\tif (timestamp + uint32(size)) >= 0xFFFFFFFF {\n\t\t\ttimestamp = 0\n\t\t} else {\n\t\t\ttimestamp += uint32(size)\n\t\t}\n\t}\n}\n\n// A Packet contains the headers and content of a received voice packet.\ntype Packet struct {\n\tSSRC      uint32\n\tSequence  uint16\n\tTimestamp uint32\n\tType      []byte\n\tOpus      []byte\n\tPCM       []int16\n}\n\n// opusReceiver listens on the UDP socket for incoming packets\n// and sends them across the given channel\n// NOTE :: This function may change names later.\nfunc (v *VoiceConnection) opusReceiver(udpConn *net.UDPConn, close <-chan struct{}, c chan *Packet) {\n\n\tif udpConn == nil || close == nil {\n\t\treturn\n\t}\n\n\trecvbuf := make([]byte, 1024)\n\tvar nonce [24]byte\n\n\tfor {\n\t\trlen, err := udpConn.Read(recvbuf)\n\t\tif err != nil {\n\t\t\t// Detect if we have been closed manually. If a Close() has already\n\t\t\t// happened, the udp connection we are listening on will be different\n\t\t\t// to the current session.\n\t\t\tv.RLock()\n\t\t\tsameConnection := v.udpConn == udpConn\n\t\t\tv.RUnlock()\n\t\t\tif sameConnection {\n\n\t\t\t\tv.log(LogError, \"udp read error, %s, %s\", v.endpoint, err)\n\t\t\t\tv.log(LogDebug, \"voice struct: %#v\\n\", v)\n\n\t\t\t\tgo v.reconnect()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase <-close:\n\t\t\treturn\n\t\tdefault:\n\t\t\t// continue loop\n\t\t}\n\n\t\t// For now, skip anything except audio.\n\t\tif rlen < 12 || (recvbuf[0] != 0x80 && recvbuf[0] != 0x90) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// build a audio packet struct\n\t\tp := Packet{}\n\t\tp.Type = recvbuf[0:2]\n\t\tp.Sequence = binary.BigEndian.Uint16(recvbuf[2:4])\n\t\tp.Timestamp = binary.BigEndian.Uint32(recvbuf[4:8])\n\t\tp.SSRC = binary.BigEndian.Uint32(recvbuf[8:12])\n\t\t// decrypt opus data\n\t\tcopy(nonce[:], recvbuf[0:12])\n\n\t\tif opus, ok := secretbox.Open(nil, recvbuf[12:rlen], &nonce, &v.op4.SecretKey); ok {\n\t\t\tp.Opus = opus\n\t\t} else {\n\t\t\tcontinue\n\t\t}\n\n\t\t// extension bit set, and not a RTCP packet\n\t\tif ((recvbuf[0] & 0x10) == 0x10) && ((recvbuf[1] & 0x80) == 0) {\n\t\t\t// get extended header length\n\t\t\textlen := binary.BigEndian.Uint16(p.Opus[2:4])\n\t\t\t// 4 bytes (ext header header) + 4*extlen (ext header data)\n\t\t\tshift := int(4 + 4*extlen)\n\t\t\tif len(p.Opus) > shift {\n\t\t\t\tp.Opus = p.Opus[shift:]\n\t\t\t}\n\t\t}\n\n\t\tif c != nil {\n\t\t\tselect {\n\t\t\tcase c <- &p:\n\t\t\tcase <-close:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Reconnect will close down a voice connection then immediately try to\n// reconnect to that session.\n// NOTE : This func is messy and a WIP while I find what works.\n// It will be cleaned up once a proven stable option is flushed out.\n// aka: this is ugly shit code, please don't judge too harshly.\nfunc (v *VoiceConnection) reconnect() {\n\n\tv.log(LogInformational, \"called\")\n\n\tv.Lock()\n\tif v.reconnecting {\n\t\tv.log(LogInformational, \"already reconnecting to channel %s, exiting\", v.ChannelID)\n\t\tv.Unlock()\n\t\treturn\n\t}\n\tv.reconnecting = true\n\tv.Unlock()\n\n\tdefer func() {\n\t\tv.Lock()\n\t\tv.reconnecting = false\n\t\tv.Unlock()\n\t}()\n\n\t// Close any currently open connections\n\tv.Close()\n\n\twait := time.Duration(1)\n\tfor {\n\n\t\t<-time.After(wait * time.Second)\n\t\twait *= 2\n\t\tif wait > 600 {\n\t\t\twait = 600\n\t\t}\n\n\t\tif v.session.DataReady == false || v.session.wsConn == nil {\n\t\t\tv.log(LogInformational, \"cannot reconnect to channel %s with unready session\", v.ChannelID)\n\t\t\tcontinue\n\t\t}\n\n\t\tv.log(LogInformational, \"trying to reconnect to channel %s\", v.ChannelID)\n\n\t\t_, err := v.session.ChannelVoiceJoin(v.GuildID, v.ChannelID, v.mute, v.deaf)\n\t\tif err == nil {\n\t\t\tv.log(LogInformational, \"successfully reconnected to channel %s\", v.ChannelID)\n\t\t\treturn\n\t\t}\n\n\t\tv.log(LogInformational, \"error reconnecting to channel %s, %s\", v.ChannelID, err)\n\n\t\t// if the reconnect above didn't work lets just send a disconnect\n\t\t// packet to reset things.\n\t\t// Send a OP4 with a nil channel to disconnect\n\t\tdata := voiceChannelJoinOp{4, voiceChannelJoinData{&v.GuildID, nil, true, true}}\n\t\tv.session.wsMutex.Lock()\n\t\terr = v.session.wsConn.WriteJSON(data)\n\t\tv.session.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\tv.log(LogError, \"error sending disconnect packet, %s\", err)\n\t\t}\n\n\t}\n}\n"
        },
        {
          "name": "webhook.go",
          "type": "blob",
          "size": 2.3525390625,
          "content": "package discordgo\n\n// Webhook stores the data for a webhook.\ntype Webhook struct {\n\tID        string      `json:\"id\"`\n\tType      WebhookType `json:\"type\"`\n\tGuildID   string      `json:\"guild_id\"`\n\tChannelID string      `json:\"channel_id\"`\n\tUser      *User       `json:\"user\"`\n\tName      string      `json:\"name\"`\n\tAvatar    string      `json:\"avatar\"`\n\tToken     string      `json:\"token\"`\n\n\t// ApplicationID is the bot/OAuth2 application that created this webhook\n\tApplicationID string `json:\"application_id,omitempty\"`\n}\n\n// WebhookType is the type of Webhook (see WebhookType* consts) in the Webhook struct\n// https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-types\ntype WebhookType int\n\n// Valid WebhookType values\nconst (\n\tWebhookTypeIncoming        WebhookType = 1\n\tWebhookTypeChannelFollower WebhookType = 2\n)\n\n// WebhookParams is a struct for webhook params, used in the WebhookExecute command.\ntype WebhookParams struct {\n\tContent         string                  `json:\"content,omitempty\"`\n\tUsername        string                  `json:\"username,omitempty\"`\n\tAvatarURL       string                  `json:\"avatar_url,omitempty\"`\n\tTTS             bool                    `json:\"tts,omitempty\"`\n\tFiles           []*File                 `json:\"-\"`\n\tComponents      []MessageComponent      `json:\"components\"`\n\tEmbeds          []*MessageEmbed         `json:\"embeds,omitempty\"`\n\tAttachments     []*MessageAttachment    `json:\"attachments,omitempty\"`\n\tAllowedMentions *MessageAllowedMentions `json:\"allowed_mentions,omitempty\"`\n\t// Only MessageFlagsSuppressEmbeds and MessageFlagsEphemeral can be set.\n\t// MessageFlagsEphemeral can only be set when using Followup Message Create endpoint.\n\tFlags MessageFlags `json:\"flags,omitempty\"`\n\t// Name of the thread to create.\n\t// NOTE: can only be set if the webhook channel is a forum.\n\tThreadName string `json:\"thread_name,omitempty\"`\n}\n\n// WebhookEdit stores data for editing of a webhook message.\ntype WebhookEdit struct {\n\tContent         *string                 `json:\"content,omitempty\"`\n\tComponents      *[]MessageComponent     `json:\"components,omitempty\"`\n\tEmbeds          *[]*MessageEmbed        `json:\"embeds,omitempty\"`\n\tFiles           []*File                 `json:\"-\"`\n\tAttachments     *[]*MessageAttachment   `json:\"attachments,omitempty\"`\n\tAllowedMentions *MessageAllowedMentions `json:\"allowed_mentions,omitempty\"`\n}\n"
        },
        {
          "name": "wsapi.go",
          "type": "blob",
          "size": 27.96875,
          "content": "// Discordgo - Discord bindings for Go\n// Available at https://github.com/bwmarrin/discordgo\n\n// Copyright 2015-2016 Bruce Marriner <bruce@sqls.net>.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains low level functions for interacting with the Discord\n// data websocket interface.\n\npackage discordgo\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// ErrWSAlreadyOpen is thrown when you attempt to open\n// a websocket that already is open.\nvar ErrWSAlreadyOpen = errors.New(\"web socket already opened\")\n\n// ErrWSNotFound is thrown when you attempt to use a websocket\n// that doesn't exist\nvar ErrWSNotFound = errors.New(\"no websocket connection exists\")\n\n// ErrWSShardBounds is thrown when you try to use a shard ID that is\n// more than the total shard count\nvar ErrWSShardBounds = errors.New(\"ShardID must be less than ShardCount\")\n\ntype resumePacket struct {\n\tOp   int `json:\"op\"`\n\tData struct {\n\t\tToken     string `json:\"token\"`\n\t\tSessionID string `json:\"session_id\"`\n\t\tSequence  int64  `json:\"seq\"`\n\t} `json:\"d\"`\n}\n\n// Open creates a websocket connection to Discord.\n// See: https://discord.com/developers/docs/topics/gateway#connecting\nfunc (s *Session) Open() error {\n\ts.log(LogInformational, \"called\")\n\n\tvar err error\n\n\t// Prevent Open or other major Session functions from\n\t// being called while Open is still running.\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// If the websock is already open, bail out here.\n\tif s.wsConn != nil {\n\t\treturn ErrWSAlreadyOpen\n\t}\n\n\t// Get the gateway to use for the Websocket connection\n\tif s.gateway == \"\" {\n\t\ts.gateway, err = s.Gateway()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the version and encoding to the URL\n\t\ts.gateway = s.gateway + \"?v=\" + APIVersion + \"&encoding=json\"\n\t}\n\n\t// Connect to the Gateway\n\ts.log(LogInformational, \"connecting to gateway %s\", s.gateway)\n\theader := http.Header{}\n\theader.Add(\"accept-encoding\", \"zlib\")\n\ts.wsConn, _, err = s.Dialer.Dial(s.gateway, header)\n\tif err != nil {\n\t\ts.log(LogError, \"error connecting to gateway %s, %s\", s.gateway, err)\n\t\ts.gateway = \"\" // clear cached gateway\n\t\ts.wsConn = nil // Just to be safe.\n\t\treturn err\n\t}\n\n\ts.wsConn.SetCloseHandler(func(code int, text string) error {\n\t\treturn nil\n\t})\n\n\tdefer func() {\n\t\t// because of this, all code below must set err to the error\n\t\t// when exiting with an error :)  Maybe someone has a better\n\t\t// way :)\n\t\tif err != nil {\n\t\t\ts.wsConn.Close()\n\t\t\ts.wsConn = nil\n\t\t}\n\t}()\n\n\t// The first response from Discord should be an Op 10 (Hello) Packet.\n\t// When processed by onEvent the heartbeat goroutine will be started.\n\tmt, m, err := s.wsConn.ReadMessage()\n\tif err != nil {\n\t\treturn err\n\t}\n\te, err := s.onEvent(mt, m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.Operation != 10 {\n\t\terr = fmt.Errorf(\"expecting Op 10, got Op %d instead\", e.Operation)\n\t\treturn err\n\t}\n\ts.log(LogInformational, \"Op 10 Hello Packet received from Discord\")\n\ts.LastHeartbeatAck = time.Now().UTC()\n\tvar h helloOp\n\tif err = json.Unmarshal(e.RawData, &h); err != nil {\n\t\terr = fmt.Errorf(\"error unmarshalling helloOp, %s\", err)\n\t\treturn err\n\t}\n\n\t// Now we send either an Op 2 Identity if this is a brand new\n\t// connection or Op 6 Resume if we are resuming an existing connection.\n\tsequence := atomic.LoadInt64(s.sequence)\n\tif s.sessionID == \"\" && sequence == 0 {\n\n\t\t// Send Op 2 Identity Packet\n\t\terr = s.identify()\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"error sending identify packet to gateway, %s, %s\", s.gateway, err)\n\t\t\treturn err\n\t\t}\n\n\t} else {\n\n\t\t// Send Op 6 Resume Packet\n\t\tp := resumePacket{}\n\t\tp.Op = 6\n\t\tp.Data.Token = s.Token\n\t\tp.Data.SessionID = s.sessionID\n\t\tp.Data.Sequence = sequence\n\n\t\ts.log(LogInformational, \"sending resume packet to gateway\")\n\t\ts.wsMutex.Lock()\n\t\terr = s.wsConn.WriteJSON(p)\n\t\ts.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"error sending gateway resume packet, %s, %s\", s.gateway, err)\n\t\t\treturn err\n\t\t}\n\n\t}\n\n\t// A basic state is a hard requirement for Voice.\n\t// We create it here so the below READY/RESUMED packet can populate\n\t// the state :)\n\t// XXX: Move to New() func?\n\tif s.State == nil {\n\t\tstate := NewState()\n\t\tstate.TrackChannels = false\n\t\tstate.TrackEmojis = false\n\t\tstate.TrackMembers = false\n\t\tstate.TrackRoles = false\n\t\tstate.TrackVoice = false\n\t\ts.State = state\n\t}\n\n\t// Now Discord should send us a READY or RESUMED packet.\n\tmt, m, err = s.wsConn.ReadMessage()\n\tif err != nil {\n\t\treturn err\n\t}\n\te, err = s.onEvent(mt, m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.Type != `READY` && e.Type != `RESUMED` {\n\t\t// This is not fatal, but it does not follow their API documentation.\n\t\ts.log(LogWarning, \"Expected READY/RESUMED, instead got:\\n%#v\\n\", e)\n\t}\n\ts.log(LogInformational, \"First Packet:\\n%#v\\n\", e)\n\n\ts.log(LogInformational, \"We are now connected to Discord, emitting connect event\")\n\ts.handleEvent(connectEventType, &Connect{})\n\n\t// A VoiceConnections map is a hard requirement for Voice.\n\t// XXX: can this be moved to when opening a voice connection?\n\tif s.VoiceConnections == nil {\n\t\ts.log(LogInformational, \"creating new VoiceConnections map\")\n\t\ts.VoiceConnections = make(map[string]*VoiceConnection)\n\t}\n\n\t// Create listening chan outside of listen, as it needs to happen inside the\n\t// mutex lock and needs to exist before calling heartbeat and listen\n\t// go rountines.\n\ts.listening = make(chan interface{})\n\n\t// Start sending heartbeats and reading messages from Discord.\n\tgo s.heartbeat(s.wsConn, s.listening, h.HeartbeatInterval)\n\tgo s.listen(s.wsConn, s.listening)\n\n\ts.log(LogInformational, \"exiting\")\n\treturn nil\n}\n\n// listen polls the websocket connection for events, it will stop when the\n// listening channel is closed, or an error occurs.\nfunc (s *Session) listen(wsConn *websocket.Conn, listening <-chan interface{}) {\n\n\ts.log(LogInformational, \"called\")\n\n\tfor {\n\n\t\tmessageType, message, err := wsConn.ReadMessage()\n\n\t\tif err != nil {\n\n\t\t\t// Detect if we have been closed manually. If a Close() has already\n\t\t\t// happened, the websocket we are listening on will be different to\n\t\t\t// the current session.\n\t\t\ts.RLock()\n\t\t\tsameConnection := s.wsConn == wsConn\n\t\t\ts.RUnlock()\n\n\t\t\tif sameConnection {\n\n\t\t\t\ts.log(LogWarning, \"error reading from gateway %s websocket, %s\", s.gateway, err)\n\t\t\t\t// There has been an error reading, close the websocket so that\n\t\t\t\t// OnDisconnect event is emitted.\n\t\t\t\terr := s.Close()\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.log(LogWarning, \"error closing session connection, %s\", err)\n\t\t\t\t}\n\n\t\t\t\ts.log(LogInformational, \"calling reconnect() now\")\n\t\t\t\ts.reconnect()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\n\t\tcase <-listening:\n\t\t\treturn\n\n\t\tdefault:\n\t\t\ts.onEvent(messageType, message)\n\n\t\t}\n\t}\n}\n\ntype heartbeatOp struct {\n\tOp   int   `json:\"op\"`\n\tData int64 `json:\"d\"`\n}\n\ntype helloOp struct {\n\tHeartbeatInterval time.Duration `json:\"heartbeat_interval\"`\n}\n\n// FailedHeartbeatAcks is the Number of heartbeat intervals to wait until forcing a connection restart.\nconst FailedHeartbeatAcks time.Duration = 5 * time.Millisecond\n\n// HeartbeatLatency returns the latency between heartbeat acknowledgement and heartbeat send.\nfunc (s *Session) HeartbeatLatency() time.Duration {\n\n\treturn s.LastHeartbeatAck.Sub(s.LastHeartbeatSent)\n\n}\n\n// heartbeat sends regular heartbeats to Discord so it knows the client\n// is still connected.  If you do not send these heartbeats Discord will\n// disconnect the websocket connection after a few seconds.\nfunc (s *Session) heartbeat(wsConn *websocket.Conn, listening <-chan interface{}, heartbeatIntervalMsec time.Duration) {\n\n\ts.log(LogInformational, \"called\")\n\n\tif listening == nil || wsConn == nil {\n\t\treturn\n\t}\n\n\tvar err error\n\tticker := time.NewTicker(heartbeatIntervalMsec * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\ts.RLock()\n\t\tlast := s.LastHeartbeatAck\n\t\ts.RUnlock()\n\t\tsequence := atomic.LoadInt64(s.sequence)\n\t\ts.log(LogDebug, \"sending gateway websocket heartbeat seq %d\", sequence)\n\t\ts.wsMutex.Lock()\n\t\ts.LastHeartbeatSent = time.Now().UTC()\n\t\terr = wsConn.WriteJSON(heartbeatOp{1, sequence})\n\t\ts.wsMutex.Unlock()\n\t\tif err != nil || time.Now().UTC().Sub(last) > (heartbeatIntervalMsec*FailedHeartbeatAcks) {\n\t\t\tif err != nil {\n\t\t\t\ts.log(LogError, \"error sending heartbeat to gateway %s, %s\", s.gateway, err)\n\t\t\t} else {\n\t\t\t\ts.log(LogError, \"haven't gotten a heartbeat ACK in %v, triggering a reconnection\", time.Now().UTC().Sub(last))\n\t\t\t}\n\t\t\ts.Close()\n\t\t\ts.reconnect()\n\t\t\treturn\n\t\t}\n\t\ts.Lock()\n\t\ts.DataReady = true\n\t\ts.Unlock()\n\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// continue loop and send heartbeat\n\t\tcase <-listening:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// UpdateStatusData is provided to UpdateStatusComplex()\ntype UpdateStatusData struct {\n\tIdleSince  *int        `json:\"since\"`\n\tActivities []*Activity `json:\"activities\"`\n\tAFK        bool        `json:\"afk\"`\n\tStatus     string      `json:\"status\"`\n}\n\ntype updateStatusOp struct {\n\tOp   int              `json:\"op\"`\n\tData UpdateStatusData `json:\"d\"`\n}\n\nfunc newUpdateStatusData(idle int, activityType ActivityType, name, url string) *UpdateStatusData {\n\tusd := &UpdateStatusData{\n\t\tStatus: \"online\",\n\t}\n\n\tif idle > 0 {\n\t\tusd.IdleSince = &idle\n\t}\n\n\tif name != \"\" {\n\t\tusd.Activities = []*Activity{{\n\t\t\tName: name,\n\t\t\tType: activityType,\n\t\t\tURL:  url,\n\t\t}}\n\t}\n\n\treturn usd\n}\n\n// UpdateGameStatus is used to update the user's status.\n// If idle>0 then set status to idle.\n// If name!=\"\" then set game.\n// if otherwise, set status to active, and no activity.\nfunc (s *Session) UpdateGameStatus(idle int, name string) (err error) {\n\treturn s.UpdateStatusComplex(*newUpdateStatusData(idle, ActivityTypeGame, name, \"\"))\n}\n\n// UpdateWatchStatus is used to update the user's watch status.\n// If idle>0 then set status to idle.\n// If name!=\"\" then set movie/stream.\n// if otherwise, set status to active, and no activity.\nfunc (s *Session) UpdateWatchStatus(idle int, name string) (err error) {\n\treturn s.UpdateStatusComplex(*newUpdateStatusData(idle, ActivityTypeWatching, name, \"\"))\n}\n\n// UpdateStreamingStatus is used to update the user's streaming status.\n// If idle>0 then set status to idle.\n// If name!=\"\" then set game.\n// If name!=\"\" and url!=\"\" then set the status type to streaming with the URL set.\n// if otherwise, set status to active, and no game.\nfunc (s *Session) UpdateStreamingStatus(idle int, name string, url string) (err error) {\n\tgameType := ActivityTypeGame\n\tif url != \"\" {\n\t\tgameType = ActivityTypeStreaming\n\t}\n\treturn s.UpdateStatusComplex(*newUpdateStatusData(idle, gameType, name, url))\n}\n\n// UpdateListeningStatus is used to set the user to \"Listening to...\"\n// If name!=\"\" then set to what user is listening to\n// Else, set user to active and no activity.\nfunc (s *Session) UpdateListeningStatus(name string) (err error) {\n\treturn s.UpdateStatusComplex(*newUpdateStatusData(0, ActivityTypeListening, name, \"\"))\n}\n\n// UpdateCustomStatus is used to update the user's custom status.\n// If state!=\"\" then set the custom status.\n// Else, set user to active and remove the custom status.\nfunc (s *Session) UpdateCustomStatus(state string) (err error) {\n\tdata := UpdateStatusData{\n\t\tStatus: \"online\",\n\t}\n\n\tif state != \"\" {\n\t\t// Discord requires a non-empty activity name, therefore we provide \"Custom Status\" as a placeholder.\n\t\tdata.Activities = []*Activity{{\n\t\t\tName:  \"Custom Status\",\n\t\t\tType:  ActivityTypeCustom,\n\t\t\tState: state,\n\t\t}}\n\t}\n\n\treturn s.UpdateStatusComplex(data)\n}\n\n// UpdateStatusComplex allows for sending the raw status update data untouched by discordgo.\nfunc (s *Session) UpdateStatusComplex(usd UpdateStatusData) (err error) {\n\t// The comment does say \"untouched by discordgo\", but we might need to lie a bit here.\n\t// The Discord documentation lists `activities` as being nullable, but in practice this\n\t// doesn't seem to be the case. I had filed an issue about this at\n\t// https://github.com/discord/discord-api-docs/issues/2559, but as of writing this\n\t// haven't had any movement on it, so at this point I'm assuming this is an error,\n\t// and am fixing this bug accordingly. Because sending `null` for `activities` instantly\n\t// disconnects us, I think that disallowing it from being sent in `UpdateStatusComplex`\n\t// isn't that big of an issue.\n\tif usd.Activities == nil {\n\t\tusd.Activities = make([]*Activity, 0)\n\t}\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\tif s.wsConn == nil {\n\t\treturn ErrWSNotFound\n\t}\n\n\ts.wsMutex.Lock()\n\terr = s.wsConn.WriteJSON(updateStatusOp{3, usd})\n\ts.wsMutex.Unlock()\n\n\treturn\n}\n\ntype requestGuildMembersData struct {\n\t// TODO: Deprecated. Use string instead of []string\n\tGuildIDs  []string  `json:\"guild_id\"`\n\tQuery     *string   `json:\"query,omitempty\"`\n\tUserIDs   *[]string `json:\"user_ids,omitempty\"`\n\tLimit     int       `json:\"limit\"`\n\tNonce     string    `json:\"nonce,omitempty\"`\n\tPresences bool      `json:\"presences\"`\n}\n\ntype requestGuildMembersOp struct {\n\tOp   int                     `json:\"op\"`\n\tData requestGuildMembersData `json:\"d\"`\n}\n\n// RequestGuildMembers requests guild members from the gateway\n// The gateway responds with GuildMembersChunk events\n// guildID   : Single Guild ID to request members of\n// query     : String that username starts with, leave empty to return all members\n// limit     : Max number of items to return, or 0 to request all members matched\n// nonce     : Nonce to identify the Guild Members Chunk response\n// presences : Whether to request presences of guild members\nfunc (s *Session) RequestGuildMembers(guildID, query string, limit int, nonce string, presences bool) error {\n\treturn s.RequestGuildMembersBatch([]string{guildID}, query, limit, nonce, presences)\n}\n\n// RequestGuildMembersList requests guild members from the gateway\n// The gateway responds with GuildMembersChunk events\n// guildID   : Single Guild ID to request members of\n// userIDs   : IDs of users to fetch\n// limit     : Max number of items to return, or 0 to request all members matched\n// nonce     : Nonce to identify the Guild Members Chunk response\n// presences : Whether to request presences of guild members\nfunc (s *Session) RequestGuildMembersList(guildID string, userIDs []string, limit int, nonce string, presences bool) error {\n\treturn s.RequestGuildMembersBatchList([]string{guildID}, userIDs, limit, nonce, presences)\n}\n\n// RequestGuildMembersBatch requests guild members from the gateway\n// The gateway responds with GuildMembersChunk events\n// guildID   : Slice of guild IDs to request members of\n// query     : String that username starts with, leave empty to return all members\n// limit     : Max number of items to return, or 0 to request all members matched\n// nonce     : Nonce to identify the Guild Members Chunk response\n// presences : Whether to request presences of guild members\n//\n// NOTE: this function is deprecated, please use RequestGuildMembers instead\nfunc (s *Session) RequestGuildMembersBatch(guildIDs []string, query string, limit int, nonce string, presences bool) (err error) {\n\tdata := requestGuildMembersData{\n\t\tGuildIDs:  guildIDs,\n\t\tQuery:     &query,\n\t\tLimit:     limit,\n\t\tNonce:     nonce,\n\t\tPresences: presences,\n\t}\n\terr = s.requestGuildMembers(data)\n\treturn\n}\n\n// RequestGuildMembersBatchList requests guild members from the gateway\n// The gateway responds with GuildMembersChunk events\n// guildID   : Slice of guild IDs to request members of\n// userIDs   : IDs of users to fetch\n// limit     : Max number of items to return, or 0 to request all members matched\n// nonce     : Nonce to identify the Guild Members Chunk response\n// presences : Whether to request presences of guild members\n//\n// NOTE: this function is deprecated, please use RequestGuildMembersList instead\nfunc (s *Session) RequestGuildMembersBatchList(guildIDs []string, userIDs []string, limit int, nonce string, presences bool) (err error) {\n\tdata := requestGuildMembersData{\n\t\tGuildIDs:  guildIDs,\n\t\tUserIDs:   &userIDs,\n\t\tLimit:     limit,\n\t\tNonce:     nonce,\n\t\tPresences: presences,\n\t}\n\terr = s.requestGuildMembers(data)\n\treturn\n}\n\n// GatewayWriteStruct allows for sending raw gateway structs over the gateway.\nfunc (s *Session) GatewayWriteStruct(data interface{}) (err error) {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tif s.wsConn == nil {\n\t\treturn ErrWSNotFound\n\t}\n\n\ts.wsMutex.Lock()\n\terr = s.wsConn.WriteJSON(data)\n\ts.wsMutex.Unlock()\n\n\treturn err\n}\n\nfunc (s *Session) requestGuildMembers(data requestGuildMembersData) (err error) {\n\ts.log(LogInformational, \"called\")\n\n\ts.RLock()\n\tdefer s.RUnlock()\n\tif s.wsConn == nil {\n\t\treturn ErrWSNotFound\n\t}\n\n\ts.wsMutex.Lock()\n\terr = s.wsConn.WriteJSON(requestGuildMembersOp{8, data})\n\ts.wsMutex.Unlock()\n\n\treturn\n}\n\n// onEvent is the \"event handler\" for all messages received on the\n// Discord Gateway API websocket connection.\n//\n// If you use the AddHandler() function to register a handler for a\n// specific event this function will pass the event along to that handler.\n//\n// If you use the AddHandler() function to register a handler for the\n// \"OnEvent\" event then all events will be passed to that handler.\nfunc (s *Session) onEvent(messageType int, message []byte) (*Event, error) {\n\n\tvar err error\n\tvar reader io.Reader\n\treader = bytes.NewBuffer(message)\n\n\t// If this is a compressed message, uncompress it.\n\tif messageType == websocket.BinaryMessage {\n\n\t\tz, err2 := zlib.NewReader(reader)\n\t\tif err2 != nil {\n\t\t\ts.log(LogError, \"error uncompressing websocket message, %s\", err)\n\t\t\treturn nil, err2\n\t\t}\n\n\t\tdefer func() {\n\t\t\terr3 := z.Close()\n\t\t\tif err3 != nil {\n\t\t\t\ts.log(LogWarning, \"error closing zlib, %s\", err)\n\t\t\t}\n\t\t}()\n\n\t\treader = z\n\t}\n\n\t// Decode the event into an Event struct.\n\tvar e *Event\n\tdecoder := json.NewDecoder(reader)\n\tif err = decoder.Decode(&e); err != nil {\n\t\ts.log(LogError, \"error decoding websocket message, %s\", err)\n\t\treturn e, err\n\t}\n\n\ts.log(LogDebug, \"Op: %d, Seq: %d, Type: %s, Data: %s\\n\\n\", e.Operation, e.Sequence, e.Type, string(e.RawData))\n\n\t// Ping request.\n\t// Must respond with a heartbeat packet within 5 seconds\n\tif e.Operation == 1 {\n\t\ts.log(LogInformational, \"sending heartbeat in response to Op1\")\n\t\ts.wsMutex.Lock()\n\t\terr = s.wsConn.WriteJSON(heartbeatOp{1, atomic.LoadInt64(s.sequence)})\n\t\ts.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\ts.log(LogError, \"error sending heartbeat in response to Op1\")\n\t\t\treturn e, err\n\t\t}\n\n\t\treturn e, nil\n\t}\n\n\t// Reconnect\n\t// Must immediately disconnect from gateway and reconnect to new gateway.\n\tif e.Operation == 7 {\n\t\ts.log(LogInformational, \"Closing and reconnecting in response to Op7\")\n\t\ts.CloseWithCode(websocket.CloseServiceRestart)\n\t\ts.reconnect()\n\t\treturn e, nil\n\t}\n\n\t// Invalid Session\n\t// Must respond with a Identify packet.\n\tif e.Operation == 9 {\n\n\t\ts.log(LogInformational, \"sending identify packet to gateway in response to Op9\")\n\n\t\terr = s.identify()\n\t\tif err != nil {\n\t\t\ts.log(LogWarning, \"error sending gateway identify packet, %s, %s\", s.gateway, err)\n\t\t\treturn e, err\n\t\t}\n\n\t\treturn e, nil\n\t}\n\n\tif e.Operation == 10 {\n\t\t// Op10 is handled by Open()\n\t\treturn e, nil\n\t}\n\n\tif e.Operation == 11 {\n\t\ts.Lock()\n\t\ts.LastHeartbeatAck = time.Now().UTC()\n\t\ts.Unlock()\n\t\ts.log(LogDebug, \"got heartbeat ACK\")\n\t\treturn e, nil\n\t}\n\n\t// Do not try to Dispatch a non-Dispatch Message\n\tif e.Operation != 0 {\n\t\t// But we probably should be doing something with them.\n\t\t// TEMP\n\t\ts.log(LogWarning, \"unknown Op: %d, Seq: %d, Type: %s, Data: %s, message: %s\", e.Operation, e.Sequence, e.Type, string(e.RawData), string(message))\n\t\treturn e, nil\n\t}\n\n\t// Store the message sequence\n\tatomic.StoreInt64(s.sequence, e.Sequence)\n\n\t// Map event to registered event handlers and pass it along to any registered handlers.\n\tif eh, ok := registeredInterfaceProviders[e.Type]; ok {\n\t\te.Struct = eh.New()\n\n\t\t// Attempt to unmarshal our event.\n\t\tif err = json.Unmarshal(e.RawData, e.Struct); err != nil {\n\t\t\ts.log(LogError, \"error unmarshalling %s event, %s\", e.Type, err)\n\t\t}\n\n\t\t// Send event to any registered event handlers for it's type.\n\t\t// Because the above doesn't cancel this, in case of an error\n\t\t// the struct could be partially populated or at default values.\n\t\t// However, most errors are due to a single field and I feel\n\t\t// it's better to pass along what we received than nothing at all.\n\t\t// TODO: Think about that decision :)\n\t\t// Either way, READY events must fire, even with errors.\n\t\ts.handleEvent(e.Type, e.Struct)\n\t} else {\n\t\ts.log(LogWarning, \"unknown event: Op: %d, Seq: %d, Type: %s, Data: %s\", e.Operation, e.Sequence, e.Type, string(e.RawData))\n\t}\n\n\t// For legacy reasons, we send the raw event also, this could be useful for handling unknown events.\n\ts.handleEvent(eventEventType, e)\n\n\treturn e, nil\n}\n\n// ------------------------------------------------------------------------------------------------\n// Code related to voice connections that initiate over the data websocket\n// ------------------------------------------------------------------------------------------------\n\ntype voiceChannelJoinData struct {\n\tGuildID   *string `json:\"guild_id\"`\n\tChannelID *string `json:\"channel_id\"`\n\tSelfMute  bool    `json:\"self_mute\"`\n\tSelfDeaf  bool    `json:\"self_deaf\"`\n}\n\ntype voiceChannelJoinOp struct {\n\tOp   int                  `json:\"op\"`\n\tData voiceChannelJoinData `json:\"d\"`\n}\n\n// ChannelVoiceJoin joins the session user to a voice channel.\n//\n//    gID     : Guild ID of the channel to join.\n//    cID     : Channel ID of the channel to join.\n//    mute    : If true, you will be set to muted upon joining.\n//    deaf    : If true, you will be set to deafened upon joining.\nfunc (s *Session) ChannelVoiceJoin(gID, cID string, mute, deaf bool) (voice *VoiceConnection, err error) {\n\n\ts.log(LogInformational, \"called\")\n\n\ts.RLock()\n\tvoice, _ = s.VoiceConnections[gID]\n\ts.RUnlock()\n\n\tif voice == nil {\n\t\tvoice = &VoiceConnection{}\n\t\ts.Lock()\n\t\ts.VoiceConnections[gID] = voice\n\t\ts.Unlock()\n\t}\n\n\tvoice.Lock()\n\tvoice.GuildID = gID\n\tvoice.ChannelID = cID\n\tvoice.deaf = deaf\n\tvoice.mute = mute\n\tvoice.session = s\n\tvoice.Unlock()\n\n\terr = s.ChannelVoiceJoinManual(gID, cID, mute, deaf)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// doesn't exactly work perfect yet.. TODO\n\terr = voice.waitUntilConnected()\n\tif err != nil {\n\t\ts.log(LogWarning, \"error waiting for voice to connect, %s\", err)\n\t\tvoice.Close()\n\t\treturn\n\t}\n\n\treturn\n}\n\n// ChannelVoiceJoinManual initiates a voice session to a voice channel, but does not complete it.\n//\n// This should only be used when the VoiceServerUpdate will be intercepted and used elsewhere.\n//\n//    gID     : Guild ID of the channel to join.\n//    cID     : Channel ID of the channel to join, leave empty to disconnect.\n//    mute    : If true, you will be set to muted upon joining.\n//    deaf    : If true, you will be set to deafened upon joining.\nfunc (s *Session) ChannelVoiceJoinManual(gID, cID string, mute, deaf bool) (err error) {\n\n\ts.log(LogInformational, \"called\")\n\n\tvar channelID *string\n\tif cID == \"\" {\n\t\tchannelID = nil\n\t} else {\n\t\tchannelID = &cID\n\t}\n\n\t// Send the request to Discord that we want to join the voice channel\n\tdata := voiceChannelJoinOp{4, voiceChannelJoinData{&gID, channelID, mute, deaf}}\n\ts.wsMutex.Lock()\n\terr = s.wsConn.WriteJSON(data)\n\ts.wsMutex.Unlock()\n\treturn\n}\n\n// onVoiceStateUpdate handles Voice State Update events on the data websocket.\nfunc (s *Session) onVoiceStateUpdate(st *VoiceStateUpdate) {\n\n\t// If we don't have a connection for the channel, don't bother\n\tif st.ChannelID == \"\" {\n\t\treturn\n\t}\n\n\t// Check if we have a voice connection to update\n\ts.RLock()\n\tvoice, exists := s.VoiceConnections[st.GuildID]\n\ts.RUnlock()\n\tif !exists {\n\t\treturn\n\t}\n\n\t// We only care about events that are about us.\n\tif s.State.User.ID != st.UserID {\n\t\treturn\n\t}\n\n\t// Store the SessionID for later use.\n\tvoice.Lock()\n\tvoice.UserID = st.UserID\n\tvoice.sessionID = st.SessionID\n\tvoice.ChannelID = st.ChannelID\n\tvoice.Unlock()\n}\n\n// onVoiceServerUpdate handles the Voice Server Update data websocket event.\n//\n// This is also fired if the Guild's voice region changes while connected\n// to a voice channel.  In that case, need to re-establish connection to\n// the new region endpoint.\nfunc (s *Session) onVoiceServerUpdate(st *VoiceServerUpdate) {\n\n\ts.log(LogInformational, \"called\")\n\n\ts.RLock()\n\tvoice, exists := s.VoiceConnections[st.GuildID]\n\ts.RUnlock()\n\n\t// If no VoiceConnection exists, just skip this\n\tif !exists {\n\t\treturn\n\t}\n\n\t// If currently connected to voice ws/udp, then disconnect.\n\t// Has no effect if not connected.\n\tvoice.Close()\n\n\t// Store values for later use\n\tvoice.Lock()\n\tvoice.token = st.Token\n\tvoice.endpoint = st.Endpoint\n\tvoice.GuildID = st.GuildID\n\tvoice.Unlock()\n\n\t// Open a connection to the voice server\n\terr := voice.open()\n\tif err != nil {\n\t\ts.log(LogError, \"onVoiceServerUpdate voice.open, %s\", err)\n\t}\n}\n\ntype identifyOp struct {\n\tOp   int      `json:\"op\"`\n\tData Identify `json:\"d\"`\n}\n\n// identify sends the identify packet to the gateway\nfunc (s *Session) identify() error {\n\ts.log(LogDebug, \"called\")\n\n\t// TODO: This is a temporary block of code to help\n\t// maintain backwards compatibility\n\tif s.Compress == false {\n\t\ts.Identify.Compress = false\n\t}\n\n\t// TODO: This is a temporary block of code to help\n\t// maintain backwards compatibility\n\tif s.Token != \"\" && s.Identify.Token == \"\" {\n\t\ts.Identify.Token = s.Token\n\t}\n\n\t// TODO: Below block should be refactored so ShardID and ShardCount\n\t// can be deprecated and their usage moved to the Session.Identify\n\t// struct\n\tif s.ShardCount > 1 {\n\n\t\tif s.ShardID >= s.ShardCount {\n\t\t\treturn ErrWSShardBounds\n\t\t}\n\n\t\ts.Identify.Shard = &[2]int{s.ShardID, s.ShardCount}\n\t}\n\n\t// Send Identify packet to Discord\n\top := identifyOp{2, s.Identify}\n\ts.log(LogDebug, \"Identify Packet: \\n%#v\", op)\n\ts.wsMutex.Lock()\n\terr := s.wsConn.WriteJSON(op)\n\ts.wsMutex.Unlock()\n\n\treturn err\n}\n\nfunc (s *Session) reconnect() {\n\n\ts.log(LogInformational, \"called\")\n\n\tvar err error\n\n\tif s.ShouldReconnectOnError {\n\n\t\twait := time.Duration(1)\n\n\t\tfor {\n\t\t\ts.log(LogInformational, \"trying to reconnect to gateway\")\n\n\t\t\terr = s.Open()\n\t\t\tif err == nil {\n\t\t\t\ts.log(LogInformational, \"successfully reconnected to gateway\")\n\n\t\t\t\t// I'm not sure if this is actually needed.\n\t\t\t\t// if the gw reconnect works properly, voice should stay alive\n\t\t\t\t// However, there seems to be cases where something \"weird\"\n\t\t\t\t// happens.  So we're doing this for now just to improve\n\t\t\t\t// stability in those edge cases.\n\t\t\t\tif s.ShouldReconnectVoiceOnSessionError {\n\t\t\t\t\ts.RLock()\n\t\t\t\t\tdefer s.RUnlock()\n\t\t\t\t\tfor _, v := range s.VoiceConnections {\n\n\t\t\t\t\t\ts.log(LogInformational, \"reconnecting voice connection to guild %s\", v.GuildID)\n\t\t\t\t\t\tgo v.reconnect()\n\n\t\t\t\t\t\t// This is here just to prevent violently spamming the\n\t\t\t\t\t\t// voice reconnects\n\t\t\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Certain race conditions can call reconnect() twice. If this happens, we\n\t\t\t// just break out of the reconnect loop\n\t\t\tif err == ErrWSAlreadyOpen {\n\t\t\t\ts.log(LogInformational, \"Websocket already exists, no need to reconnect\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ts.log(LogError, \"error reconnecting to gateway, %s\", err)\n\n\t\t\t<-time.After(wait * time.Second)\n\t\t\twait *= 2\n\t\t\tif wait > 600 {\n\t\t\t\twait = 600\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Close closes a websocket and stops all listening/heartbeat goroutines.\n// TODO: Add support for Voice WS/UDP\nfunc (s *Session) Close() error {\n\treturn s.CloseWithCode(websocket.CloseNormalClosure)\n}\n\n// CloseWithCode closes a websocket using the provided closeCode and stops all\n// listening/heartbeat goroutines.\n// TODO: Add support for Voice WS/UDP connections\nfunc (s *Session) CloseWithCode(closeCode int) (err error) {\n\n\ts.log(LogInformational, \"called\")\n\ts.Lock()\n\n\ts.DataReady = false\n\n\tif s.listening != nil {\n\t\ts.log(LogInformational, \"closing listening channel\")\n\t\tclose(s.listening)\n\t\ts.listening = nil\n\t}\n\n\t// TODO: Close all active Voice Connections too\n\t// this should force stop any reconnecting voice channels too\n\n\tif s.wsConn != nil {\n\n\t\ts.log(LogInformational, \"sending close frame\")\n\t\t// To cleanly close a connection, a client should send a close\n\t\t// frame and wait for the server to close the connection.\n\t\ts.wsMutex.Lock()\n\t\terr := s.wsConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(closeCode, \"\"))\n\t\ts.wsMutex.Unlock()\n\t\tif err != nil {\n\t\t\ts.log(LogInformational, \"error closing websocket, %s\", err)\n\t\t}\n\n\t\t// TODO: Wait for Discord to actually close the connection.\n\t\ttime.Sleep(1 * time.Second)\n\n\t\ts.log(LogInformational, \"closing gateway websocket\")\n\t\terr = s.wsConn.Close()\n\t\tif err != nil {\n\t\t\ts.log(LogInformational, \"error closing websocket, %s\", err)\n\t\t}\n\n\t\ts.wsConn = nil\n\t}\n\n\ts.Unlock()\n\n\ts.log(LogInformational, \"emit disconnect event\")\n\ts.handleEvent(disconnectEventType, &Disconnect{})\n\n\treturn\n}\n"
        }
      ]
    }
  ]
}