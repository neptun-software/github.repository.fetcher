{
  "metadata": {
    "timestamp": 1736567584577,
    "page": 169,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TomWright/dasel",
      "stars": 7301,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": ".idea/\ndasel"
        },
        {
          "name": ".pre-commit-hooks.yaml",
          "type": "blob",
          "size": 0.681640625,
          "content": "- id: dasel-validate-docker\n  name: Validate JSON, YAML, XML, TOML files\n  description: Validate JSON files\n  language: docker_image\n  types_or:\n    - json\n    - yaml\n    - xml\n    - toml\n  entry: ghcr.io/tomwright/dasel\n  args:\n    - validate\n\n- id: dasel-validate-bin\n  name: Validate JSON, YAML, XML, TOML\n  description: Validate JSON, YAML, XML, TOML files\n  language: system\n  types_or:\n    - json\n    - yaml\n    - xml\n    - toml\n  entry: dasel\n  args:\n    - validate\n\n- id: dasel-validate\n  name: Validate JSON, YAML, XML, TOML\n  description: Validate JSON, YAML, XML, TOML files\n  language: golang\n  types_or:\n    - json\n    - yaml\n    - xml\n    - toml\n  entry: dasel\n  args:\n    - validate\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 19.6318359375,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n- Nothing yet\n\n## [v2.8.1] - 2024-06-30\n\n### Fixed\n- Fixed a bug related to yaml aliases.\n\n## [v2.8.0] - 2024-06-28\n\n### Fixed\n\n- Fixed a bug that could cause a panic. \n- `type()` now returns `null` instead of `unknown` for null values.\n- Added YAML support for merge tag/aliases. Thanks to [pmeier](https://github.com/pmeier). [Issue 285](https://github.com/TomWright/dasel/issues/285).\n\n## [v2.7.0] - 2024-03-14\n\n### Added\n\n- `null()` function. [See docs](https://daseldocs.tomwright.me/functions/null)\n\n### Fixed\n\n- Dasel now correctly handles `null` values.\n\n## [v2.6.0] - 2024-02-15\n\n### Added\n\n- Support for `--indent` flag.\n- More descriptive errors when dasel fails to open a file.\n\n### Changed\n\n- Docker build improvements in workflows.\n\n## [v2.5.0] - 2023-11-28\n\n### Added\n\n- Add `man` that generates manpages for all dasel subcommands.\n\n### Fixed\n\n- Fixed an issue when [parsing empty input documents](https://github.com/TomWright/dasel/issues/374).\n\n## [v2.4.1] - 2023-10-18\n\n### Fixed\n\n- JSON output now acts as expected regarding the EscapeHTML flag.\n\n## [v2.4.0] - 2023-10-18\n\n### Added\n\n- `orDefault()` function. [See docs](https://daseldocs.tomwright.me/functions/ordefault)\n- `--csv-comma` flag to change the csv separator.\n- `--csv-write-comma` flag to change the csv separator specifically for writes.\n- `--csv-comment` flag to change the csv comment character.\n- `--csv-crlf` flag to enable or disable CRLF output when working with csv files.\n\n### Fixed\n\n- Resolved an issue with YAML parser that was causing strings to be read as booleans.\n- Fix a parsing issue with CSV types that forced you to expand and merge in order for it selects to work [Issue 364](https://github.com/TomWright/dasel/issues/364). \n\n## [v2.3.6] - 2023-08-30\n\n### Fixed\n\n- XML is now formatted correctly. (https://github.com/TomWright/dasel/issues/354)\n\n## [v2.3.5] - 2023-08-29\n\n### Changed\n\n- Small internal optimisation (https://github.com/TomWright/dasel/pull/341)\n- Update to go 1.21\n- Upgrade dependencies\n\n### Fixed\n\n- Resolved an issue with YAML parser that was causing strings to be read as numbers.\n- Timestamps can now be resolved as expected in YAML.\n\n## [v2.3.4] - 2023-06-01\n\n### Fixed\n\n- `len` function now works with new map type.\n- `keys` function now works with new map type.\n\n## [v2.3.3] - 2023-05-31\n\n### Fixed\n\n- Errors when selecting data are now correctly handled.\n\n## [v2.3.2] - 2023-05-31\n\n### Fixed\n\n- Restored previous octal, binary and hex number parsing support in YAML and `put` command.\n\n## [v2.3.1] - 2023-05-29\n\n### Fixed\n\n- `version` command now outputs correct version information (only affected v2 onwards)\n\n## [v2.3.0] - 2023-05-29\n\n### Changed\n\n- Maps are now ordered internally.\n- JSON and YAML maps maintain ordering on read/write.\n- `all()` func now works with strings.\n- `index()` func now works with strings.\n\n### Fixed\n\n- Multi-document output should now be displayed correctly.\n- Index shorthand selector now works with multiple indexes.\n- Null values are now correctly handled.\n\n## [v2.2.0] - 2023-04-17\n\n### Added\n\n- `keys()` function.\n\n## [v2.1.2] - 2023-03-27\n\n### Added\n\n- Join function.\n- String function.\n\n### Fixed\n\n- Null error caused by null values in arrays. See [PR 307](https://github.com/TomWright/dasel/pull/307).\n\n## [v2.1.1] - 2023-01-19\n\n### Fixed\n\n- Changed go module to `github.com/tomwright/dasel/v2` to ensure it works correctly with go modules.\n\n## [v2.1.0] - 2023-01-11\n\n### Added\n\n- Ability to jump to a parent x levels up with `parent(x)`. Defaults to 1 level.\n\n## [v2.0.2] - 2022-12-07\n\n### Fixed\n\n- Argument parsing issue that caused files to be written to the wrong place. See [discussion 268](https://github.com/TomWright/dasel/discussions/268).\n\n## [v2.0.1] - 2022-12-07\n\n### Added\n\n- `float` type in `put` command.\n\n### Fixed\n\n- Output values are now correctly de-referenced. This fixed issues with encoded values not appearing correctly.\n- Escape characters in selector strings now work as expected.\n\n## [v2.0.0] - 2022-12-02\n\nSee [documentation](https://daseldocs.tomwright.me) for all changes.\n\n- Selector syntax \n\n## [v1.27.3] - 2022-10-18\n\n### Fixed\n\n- The compact flag now works with the XML parser.\n\n## [v1.27.2] - 2022-10-18\n\n### Fixed\n\n- Help text for select and delete commands now contain all available parsers.\n- Errors now implement the `Is` interface so they are easier to use from go.\n- Floats are now formatted in decimal format instead of scientific notification when writing to CSV ([Issue 245](https://github.com/TomWright/dasel/issues/245), [Issue 229](https://github.com/TomWright/dasel/issues/229))\n\n## [v1.27.1] - 2022-09-28\n\n### Fixed\n\n- Improved selector comparison parsing to allow matching on values containing special characters.\n\n## [v1.27.0] - 2022-09-26\n\n### Added\n\n- New `value-file` flag allows you to `put` values read from a file ([Issue 246](https://github.com/TomWright/dasel/issues/246))\n\n## [v1.26.1] - 2022-08-24\n\n### Fixed\n\n- Make the completion command available for use ([Issue 216](https://github.com/TomWright/dasel/issues/216))\n- Make the `__complete` command available for use\n\n## [v1.26.0] - 2022-07-09\n\n### Added\n\n- Search optional selector - `(#:key=value)`\n\n## [v1.25.1] - 2022-06-29\n\n### Added\n\n- Pre-commit hooks for validate command.\n\n## [v1.25.0] - 2022-06-26\n\n### Added\n\n- Support for struct type usage in go package.\n- Validate command.\n\n## [v1.24.3] - 2022-04-23\n\n### Added\n\n- Gzip compressed binaries on releases.\n\n## [v1.24.2] - 2022-04-22\n\n### Fixed\n\n- Update a package to avoid a High Vulnerability in golang.org/x/crypto with CVE ID [CVE-2022-27191](https://github.com/advisories/GHSA-8c26-wmh5-6g9v)\n\n## [v1.24.1] - 2022-03-28\n\n### Changed\n\n- `storage` package has been moved outside the `internal` package.\n\n### Fixed\n\n- New funcs added in `v1.24.0` can now be used as expected since you can now access the `storage.ReadWriteOption`.\n\n## [v1.24.0] - 2022-03-18\n\n### Added\n\n- `Node.NewFromFile` func to load a root node from a file.\n- `Node.NewFromReader` func to load a root node from an `io.Reader`.\n- `Node.WriteToFile` func to write results to a file.\n- `Node.Write` func to write results to an `io.Writer`.\n\n## [v1.23.0] - 2022-03-10\n\n### Fixed\n\n- Update github.com/pelletier/go-toml to consume fix for https://github.com/TomWright/dasel/issues/191.\n\n### Added\n\n- Sprig functions to output formatter template.\n\n## [v1.22.1] - 2021-11-09\n\n### Fixed\n\n- Cleaned up error output\n\n## [v1.22.0] - 2021-11-09\n\n### Added\n\n- Type selector `[@]`.\n\n### Fixed\n\n- Errors are now written to stderr as expected.\n\n## [v1.21.2] - 2021-10-21\n\n### Added\n\n- Linux arm32 build target.\n\n## [v1.21.1] - 2021-09-30\n\n### Changed\n- `--escape-html` flag now defaults to false.\n\n## [v1.21.0] - 2021-09-29\n\n### Added\n- `--escape-html` flag.\n\n### Fixed\n- `put document` and `put object` are now aware of the `--merge-input-documents` flag.\n\n## [v1.20.1] - 2021-09-28\n\n### Added\n\n- `buster-slim` and `alpine` tags to built docker images.\n\n### Fixed\n\n- Different encodings in XML files are now [handled as expected](https://github.com/TomWright/dasel/issues/164).\n\n## [v1.20.0] - 2021-08-30\n\n### Added\n\n- `-v`, `--value` flag to workaround [dash issue](https://github.com/TomWright/dasel/issues/117).\n\n### Fixed\n\n- Fixed an issue in which unicode characters could cause issues when parsing selectors.\n\n## [v1.19.0] - 2021-08-14\n\n### Added\n\n- `--colour`,`--color` flag to enable colourised output in select command.\n\n## [v1.18.0] - 2021-08-11\n\n### Added\n\n- `--format` flag to `select` command.\n\n## [v1.17.0] - 2021-08-08\n\n### Added\n\n- Support for `!=` comparison operator in dynamic and search selectors.\n- Support for `-`/`keyValue` key in dynamic selectors.\n\n## [v1.16.1] - 2021-08-02\n\n### Fixed\n\n- Fixed a bug that stopped the delete command editing files in place.\n\n## [v1.16.0] - 2021-08-01\n\n### Added\n\n- Delete command.\n\n## [v1.15.0] - 2021-05-06\n\n### Added\n\n- `--merge-input-documents` flag.\n\n### Changed\n\n- Optional `noupdater` build tag to disable the self-update command.\n\n### Fixed\n\n- Empty XML documents are now parsed correctly.\n  - https://github.com/TomWright/dasel/issues/131\n\n## [v1.14.1] - 2021-04-15\n\n### Added\n\n- arm64 build support.\n\n## [v1.14.0] - 2021-04-11\n\n### Added\n\n- `.[#]` length selector.\n- `>` comparison operator.\n- `>=` comparison operator.\n- `<` comparison operator.\n- `<=` comparison operator.\n\n## [v1.13.6] - 2021-03-29\n\n### Changed\n\n- Development versions of dasel will now include more specific version information where possible.\n\n### Fixed\n\n- Fix an issue that stopped dasel being able to output CSV documents when parsed from JSON. \n\n## [v1.13.5] - 2021-03-22\n\n### Fixed\n\n- Empty map values are now initialised as `map[string]interface{}` rather than `map[interface{}]interface{}`.\n\n## [v1.13.4] - 2021-03-11\n\n### Fixed\n\n- Empty document input is now treated different in select and put commands.\n  - https://github.com/TomWright/dasel/issues/99\n  - https://github.com/TomWright/dasel/issues/102\n\n## [v1.13.3] - 2021-03-05\n\n### Fixed\n\n- Blank YAML and CSV input is now treated as an empty document.\n\n### Changed\n\n- Blank JSON input is now treated as an empty document.\n\n## [v1.13.2] - 2021-02-25\n\n### Changed\n\n- Improved information provided in `UnsupportedTypeForSelector` errors.\n- Upgrade to go 1.16.\n\n### Fixed\n\n- Make sure the `-n`,`--null` flag has an effect in multi-select queries.\n\n## [v1.13.1] - 2021-02-18\n\n### Fixed\n\n- Added `CGO_ENABLED=0` build flag to ensure linux_amd64 builds are statically linked.\n\n## [v1.13.0] - 2021-02-11\n\n### Added\n\n- `--length` flag to select command.\n\n## [v1.12.2] - 2021-01-05\n\n### Fixed\n\n- Fix a bug that stopped the write parser being properly detected when writing to the input file.\n\n## [v1.12.1] - 2021-01-05\n\n### Changed\n\n- Build workflows now updated to run on ubuntu-latest and use a matrix to build assets for `linux`, `darwin` and\n`windows` for both `amd64` and `386`.\n\n### Fixed\n\n- Release asset for macos/darwin is now named `dasel_darwin_amd64` instead of `dasel_macos_amd64`.\n- Self-updater now identifies `dev` version as development.\n\n## [v1.12.0] - 2021-01-02\n\n### Added\n\n- Add `-c`, `--compact` flag to remove pretty-print formatting from JSON output.\n- Defined `storage.IndentOption(indent string) ReadWriteOption`.\n- Defined `storage.PrettyPrintOption(enabled bool) ReadWriteOption`.\n\n### Changed\n\n- Changed `storage.Parser` funcs to allow the passing of `...ReadWriteOption`.\n\n## [v1.11.0] - 2020-12-22\n\n### Added\n\n- Benchmark info now contains graphs.\n- `update` command to self-update dasel.\n\n### Changed\n\n- Benchmark info now directly compares dasel, jq and yq.\n\n## [v1.10.0] - 2020-12-19\n\n### Added\n\n- Add `dasel put document` command.\n- Benchmark information.\n\n### Fixed\n\n- `-r`,`--read` and `-w`,`--write` flags are now used in `dasel put object`.\n- Fix issues that occurred when writing to the root node.\n\n### Changed\n\n- Command names and descriptions.\n\n## [v1.9.1] - 2020-12-12\n\n### Fixed\n\n- Stopped parsing XML entities in strings.\n\n## [v1.9.0] - 2020-12-12\n\n### Added\n\n- Add keys/index selector in multi queries.\n- Add `-n`,`--null` flag.\n\n## [v1.8.0] - 2020-12-01\n\n### Added\n\n- Add ability to use `ANY_INDEX` (`[*]`) and `DYNAMIC` (`(x=y)`) selectors on maps/objects.\n\n## [v1.7.0] - 2020-11-30\n\n### Added\n\n- Add `-r`,`--read` and `-w`,`--write` flags to specifically choose input/output parsers. This allows you to convert data between formats.\n\n## [v1.6.2] - 2020-11-18\n\n### Added\n\n- Add support for multi-document JSON files.\n\n## [v1.6.1] - 2020-11-17\n\n### Changed\n\n- Remove some validation on `dasel put object` to allow you to put empty objects.\n\n## [v1.6.0] - 2020-11-17\n\n### Added\n\n- Add search selector to allow recursive searching from the current node.\n\n## [v1.5.1] - 2020-11-14\n\n### Fixed\n\n- Fixed an issue that stopped new values being saved.\n\n## [v1.5.0] - 2020-11-12\n\n### Added\n\n- Add ability to use `\\` as an escape character in selectors.\n\n## [v1.4.1] - 2020-11-11\n\n### Fixed\n\n- Fix an issue when parsing dynamic selectors.\n\n## [v1.4.0] - 2020-11-08\n\n### Added\n\n- Add `-m`,`--multiple` flag to deal with multi-value queries.\n- Add `ANY_INDEX` or `[*]` selector.\n- Add `NextMultiple` property to the `Node` struct - this is used when processing multi-value queries.\n- Add `Node.QueryMultiple` func.\n- Add `Node.PutMultiple` func.\n\n## [v1.3.0] - 2020-11-08\n\n### Added\n\n- Add support for CSV files.\n\n## [v1.2.0] - 2020-11-07\n\n### Added\n\n- Add support for multi-document YAML files.\n- Add CodeQL step in github actions.\n\n### Changed\n\n- Docker image is now pushed to ghcr instead of github packages.\n\n## [v1.1.0] - 2020-11-01\n\n### Added\n\n- Add sub-selector support in dynamic selectors.\n\n## [v1.0.4] - 2020-10-30\n\n### Added\n\n- Add `--plain` flag to tell dasel to output un-formatted values.\n\n## [v1.0.3] - 2020-10-29\n\n### Changed\n\n- Command output is now followed by a newline.\n\n## [v1.0.2] - 2020-10-28\n\n### Added\n\n- Docker image is now built and pushed when a new release is tagged.\n\n## [v1.0.1] - 2020-10-28\n\n### Added\n\n- Add support for XML.\n\n### Changed\n\n- Add `-` as an alias for `stdin`/`stdout` in `--file` and `--output` flags.\n- Selector can now be given as the first argument making the flag itself optional.\n- `select` is now the default command.\n\n## [v1.0.0] - 2020-10-27\n\n### Added\n\n- Add lots of tests.\n- Add docs.\n- Got accepted to go-awesome.\n\n## [v0.0.5] - 2020-09-27\n\n### Added\n\n- Add support for TOML.\n\n## [v0.0.4] - 2020-09-27\n\n### Added\n\n- Ability to check against the node value in a dynamic selector.\n- Code coverage.\n\n### Changed\n\n- Use reflection instead of fixed type checks.\n\n## [v0.0.3] - 2020-09-24\n\n### Changed\n\n- Use reflection instead of fixed type checks.\n- Extract commands into their own functions to make them testable.\n\n## [v0.0.2] - 2020-09-23\n\n### Added\n\n- Add ability to pipe data in/out of dasel.\n- Add dasel put command.\n\n## [v0.0.1] - 2020-09-22\n\n### Added\n\n- Everything!\n\n[unreleased]: https://github.com/TomWright/dasel/compare/v2.8.1...HEAD\n[v2.8.1]: https://github.com/TomWright/dasel/compare/v2.8.0...v2.8.1\n[v2.8.0]: https://github.com/TomWright/dasel/compare/v2.7.0...v2.8.0\n[v2.7.0]: https://github.com/TomWright/dasel/compare/v2.6.0...v2.7.0\n[v2.6.0]: https://github.com/TomWright/dasel/compare/v2.5.0...v2.6.0\n[v2.5.0]: https://github.com/TomWright/dasel/compare/v2.4.1...v2.5.0\n[v2.4.1]: https://github.com/TomWright/dasel/compare/v2.4.0...v2.4.1\n[v2.4.0]: https://github.com/TomWright/dasel/compare/v2.3.6...v2.4.0\n[v2.3.6]: https://github.com/TomWright/dasel/compare/v2.3.5...v2.3.6\n[v2.3.5]: https://github.com/TomWright/dasel/compare/v2.3.4...v2.3.5\n[v2.3.4]: https://github.com/TomWright/dasel/compare/v2.3.3...v2.3.4\n[v2.3.3]: https://github.com/TomWright/dasel/compare/v2.3.2...v2.3.3\n[v2.3.2]: https://github.com/TomWright/dasel/compare/v2.3.1...v2.3.2\n[v2.3.1]: https://github.com/TomWright/dasel/compare/v2.3.0...v2.3.1\n[v2.3.0]: https://github.com/TomWright/dasel/compare/v2.2.0...v2.3.0\n[v2.2.0]: https://github.com/TomWright/dasel/compare/v2.1.2...v2.2.0\n[v2.1.2]: https://github.com/TomWright/dasel/compare/v2.1.1...v2.1.2\n[v2.1.1]: https://github.com/TomWright/dasel/compare/v2.1.0...v2.1.1\n[v2.1.0]: https://github.com/TomWright/dasel/compare/v2.0.2...v2.1.0\n[v2.0.2]: https://github.com/TomWright/dasel/compare/v2.0.1...v2.0.2\n[v2.0.1]: https://github.com/TomWright/dasel/compare/v2.0.0...v2.0.1\n[v2.0.0]: https://github.com/TomWright/dasel/compare/v1.27.3...v2.0.0\n[v1.27.3]: https://github.com/TomWright/dasel/compare/v1.27.2...v1.27.3\n[v1.27.2]: https://github.com/TomWright/dasel/compare/v1.27.1...v1.27.2\n[v1.27.1]: https://github.com/TomWright/dasel/compare/v1.27.0...v1.27.1\n[v1.27.0]: https://github.com/TomWright/dasel/compare/v1.26.1...v1.27.0\n[v1.26.1]: https://github.com/TomWright/dasel/compare/v1.26.0...v1.26.1\n[v1.26.0]: https://github.com/TomWright/dasel/compare/v1.25.1...v1.26.0\n[v1.25.1]: https://github.com/TomWright/dasel/compare/v1.25.0...v1.25.1\n[v1.25.0]: https://github.com/TomWright/dasel/compare/v1.24.3...v1.25.0\n[v1.24.3]: https://github.com/TomWright/dasel/compare/v1.24.2...v1.24.3\n[v1.24.2]: https://github.com/TomWright/dasel/compare/v1.24.1...v1.24.2\n[v1.24.1]: https://github.com/TomWright/dasel/compare/v1.24.0...v1.24.1\n[v1.24.0]: https://github.com/TomWright/dasel/compare/v1.23.0...v1.24.0\n[v1.23.0]: https://github.com/TomWright/dasel/compare/v1.22.1...v1.23.0\n[v1.22.1]: https://github.com/TomWright/dasel/compare/v1.22.0...v1.22.1\n[v1.22.0]: https://github.com/TomWright/dasel/compare/v1.21.2...v1.22.0\n[v1.21.2]: https://github.com/TomWright/dasel/compare/v1.21.1...v1.21.2\n[v1.21.1]: https://github.com/TomWright/dasel/compare/v1.21.0...v1.21.1\n[v1.21.0]: https://github.com/TomWright/dasel/compare/v1.20.1...v1.21.0\n[v1.20.1]: https://github.com/TomWright/dasel/compare/v1.20.0...v1.20.1\n[v1.20.0]: https://github.com/TomWright/dasel/compare/v1.19.0...v1.20.0\n[v1.19.0]: https://github.com/TomWright/dasel/compare/v1.18.0...v1.19.0\n[v1.18.0]: https://github.com/TomWright/dasel/compare/v1.17.0...v1.18.0\n[v1.17.0]: https://github.com/TomWright/dasel/compare/v1.16.1...v1.17.0\n[v1.16.1]: https://github.com/TomWright/dasel/compare/v1.16.0...v1.16.1\n[v1.16.0]: https://github.com/TomWright/dasel/compare/v1.15.0...v1.16.0\n[v1.15.0]: https://github.com/TomWright/dasel/compare/v1.14.1...v1.15.0\n[v1.14.1]: https://github.com/TomWright/dasel/compare/v1.14.0...v1.14.1\n[v1.14.0]: https://github.com/TomWright/dasel/compare/v1.13.6...v1.14.0\n[v1.13.6]: https://github.com/TomWright/dasel/compare/v1.13.5...v1.13.6\n[v1.13.5]: https://github.com/TomWright/dasel/compare/v1.13.4...v1.13.5\n[v1.13.4]: https://github.com/TomWright/dasel/compare/v1.13.3...v1.13.4\n[v1.13.3]: https://github.com/TomWright/dasel/compare/v1.13.2...v1.13.3\n[v1.13.2]: https://github.com/TomWright/dasel/compare/v1.13.1...v1.13.2\n[v1.13.1]: https://github.com/TomWright/dasel/compare/v1.13.0...v1.13.1\n[v1.13.0]: https://github.com/TomWright/dasel/compare/v1.12.2...v1.13.0\n[v1.12.2]: https://github.com/TomWright/dasel/compare/v1.12.1...v1.12.2\n[v1.12.1]: https://github.com/TomWright/dasel/compare/v1.12.0...v1.12.1\n[v1.12.0]: https://github.com/TomWright/dasel/compare/v1.11.0...v1.12.0\n[v1.11.0]: https://github.com/TomWright/dasel/compare/v1.10.0...v1.11.0\n[v1.10.0]: https://github.com/TomWright/dasel/compare/v1.9.1...v1.10.0\n[v1.9.1]: https://github.com/TomWright/dasel/compare/v1.9.0...v1.9.1\n[v1.9.0]: https://github.com/TomWright/dasel/compare/v1.8.0...v1.9.0\n[v1.8.0]: https://github.com/TomWright/dasel/compare/v1.7.0...v1.8.0\n[v1.7.0]: https://github.com/TomWright/dasel/compare/v1.6.2...v1.7.0\n[v1.6.2]: https://github.com/TomWright/dasel/compare/v1.6.1...v1.6.2\n[v1.6.1]: https://github.com/TomWright/dasel/compare/v1.6.0...v1.6.1\n[v1.6.0]: https://github.com/TomWright/dasel/compare/v1.5.1...v1.6.0\n[v1.5.1]: https://github.com/TomWright/dasel/compare/v1.5.0...v1.5.1\n[v1.5.0]: https://github.com/TomWright/dasel/compare/v1.4.1...v1.5.0\n[v1.4.1]: https://github.com/TomWright/dasel/compare/v1.4.0...v1.4.1\n[v1.4.0]: https://github.com/TomWright/dasel/compare/v1.3.0...v1.4.0\n[v1.3.0]: https://github.com/TomWright/dasel/compare/v1.2.0...v1.3.0\n[v1.1.0]: https://github.com/TomWright/dasel/compare/v1.0.4...v1.1.0\n[v1.0.4]: https://github.com/TomWright/dasel/compare/v1.0.3...v1.0.4\n[v1.0.3]: https://github.com/TomWright/dasel/compare/v1.0.2...v1.0.3\n[v1.0.2]: https://github.com/TomWright/dasel/compare/v1.0.1...v1.0.2\n[v1.0.1]: https://github.com/TomWright/dasel/compare/v1.0.0...v1.0.1\n[v1.0.0]: https://github.com/TomWright/dasel/compare/v0.0.5...v1.0.0\n[v0.0.5]: https://github.com/TomWright/dasel/compare/v0.0.4...v0.0.5\n[v0.0.4]: https://github.com/TomWright/dasel/compare/v0.0.3...v0.0.4\n[v0.0.3]: https://github.com/TomWright/dasel/compare/v0.0.2...v0.0.3\n[v0.0.2]: https://github.com/TomWright/dasel/compare/v0.0.1...v0.0.2\n[v0.0.1]: https://github.com/TomWright/dasel/releases/tag/v0.0.1\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2763671875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n- Using welcoming and inclusive language\n- Being respectful of differing viewpoints and experiences\n- Gracefully accepting constructive criticism\n- Focusing on what is best for the community\n- Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n- Trolling, insulting/derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n- Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at contact@tomwright.me. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.443359375,
          "content": "ARG GOLANG_VERSION=1\nARG TARGET_BASE_IMAGE=debian:bookworm-slim\nFROM golang:${GOLANG_VERSION} AS builder\n\nARG MAJOR_VERSION=v2\nARG RELEASE_VERSION=master\nARG CGO_ENABLED=0\n\nCOPY . .\n\nRUN go build -o /dasel -ldflags=\"-X 'github.com/tomwright/dasel/${MAJOR_VERSION}/internal.Version=${RELEASE_VERSION}'\" ./cmd/dasel\n\nFROM ${TARGET_BASE_IMAGE}\n\nCOPY --from=builder --chmod=755 /dasel /usr/local/bin/dasel\n\nENTRYPOINT [\"/usr/local/bin/dasel\"]\nCMD [\"--help\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2020 Tom Wright\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.8173828125,
          "content": "# dasel\n\n[![Gitbook](https://badges.aleen42.com/src/gitbook_1.svg)](https://daseldocs.tomwright.me)\n[![Go Report Card](https://goreportcard.com/badge/github.com/TomWright/dasel/v2)](https://goreportcard.com/report/github.com/TomWright/dasel/v2)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/tomwright/dasel)](https://pkg.go.dev/github.com/tomwright/dasel/v2)\n![Test](https://github.com/TomWright/dasel/workflows/Test/badge.svg)\n![Build](https://github.com/TomWright/dasel/workflows/Build/badge.svg)\n[![codecov](https://codecov.io/gh/TomWright/dasel/branch/master/graph/badge.svg)](https://codecov.io/gh/TomWright/dasel)\n[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge.svg)](https://github.com/avelino/awesome-go)\n![GitHub All Releases Downloads](https://img.shields.io/github/downloads/TomWright/dasel/total)\n![GitHub License](https://img.shields.io/github/license/TomWright/dasel)\n[![GitHub tag (latest by date)](https://img.shields.io/github/v/tag/TomWright/dasel?label=latest%20release)](https://github.com/TomWright/dasel/releases/latest)\n[![Homebrew tag (latest by date)](https://img.shields.io/homebrew/v/dasel)](https://formulae.brew.sh/formula/dasel)\n\nDasel (short for data-selector) allows you to query and modify data structures using selector strings.\n\nComparable to [jq](https://github.com/stedolan/jq) / [yq](https://github.com/kislyuk/yq), but supports JSON, YAML, TOML, XML and CSV with zero runtime dependencies.\n\n## One tool to rule them all\n\nSay good bye to learning new tools just to work with a different data format.\n\nDasel uses a standard selector syntax no matter the data format. This means that once you learn how to use dasel you immediately have the ability to query/modify any of the supported data types without any additional tools or effort.\n\n![Update Kubernetes Manifest](demo.gif)\n<details>\n<summary>Commands executed in the demo</summary>\n\n```bash\n# Piping data into dasel\necho '{\"demo\": \"Integrating with github releases...\"}' | dasel -r json 'demo'\n\n# Fetch dasel releases from github api\ncurl -L \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    https://api.github.com/repos/TomWright/dasel/releases > releases.json\nless releases.json\n\n# Extract and structure release data by version with download URL's by asset name\ndasel -f releases.json -w yaml 'all().mapOf(version,tag_name,download,assets.all().mapOf(name,name,url,browser_download_url).merge()).merge()' > releases_download.yaml\nless releases_download.yaml\n\n# Restructure the above data into CSV format, destructuring into rows.\ndasel -f releases_download.yaml -w csv 'all().download.all().mapOf(version,parent(2).version,name,name,url,url).merge()' > releases_download.csv\nless releases_download.csv\n\n# Fetch the first CSV row and output as JSON\ndasel -f releases_download.csv -w json 'first()'\n```\n</details>\n\n## Table of contents\n\n- [Dasel](#dasel)\n- [One tool to rule them all](#one-tool-to-rule-them-all)\n- [Quickstart](#quickstart)\n- [Completion](#completion)\n- [Issue vs discussion](#issue-vs-discussion)\n- [Features](#features)\n- [Table of contents](#table-of-contents)\n- [Documentation](#documentation)\n- [Playground](#playground)\n- [Benchmarks](#benchmarks)\n- [Pre-Commit](#pre-commit)\n\n## Quickstart\n\nDasel is available on [homebrew](https://daseldocs.tomwright.me/installation#homebrew), [ASDF](https://daseldocs.tomwright.me/installation#asdf), [scoop](https://daseldocs.tomwright.me/installation#scoop), [docker](https://daseldocs.tomwright.me/installation#docker), [Nix](https://daseldocs.tomwright.me/installation#nix) or as [compiled binaries](https://daseldocs.tomwright.me/installation#manual) from the [latest release](https://github.com/TomWright/dasel/releases/latest).\n\n```bash\nbrew install dasel\n```\n\nYou can also install a [development version](https://daseldocs.tomwright.me/installation#development-version) with:\n\n```bash\ngo install github.com/tomwright/dasel/v2/cmd/dasel@master\n```\n\nFor more information see the [installation documentation](https://daseldocs.tomwright.me/installation).\n\n### Select\n\n```bash\necho '{\"name\": \"Tom\"}' | dasel -r json 'name'\n\"Tom\"\n```\n\nSee [select documentation](https://daseldocs.tomwright.me/commands/select).\n\n### Convert json to yaml\n\n```bash\necho '{\"name\": \"Tom\"}' | dasel -r json -w yaml\nname: Tom\n```\n\nSee [select documentation](https://daseldocs.tomwright.me/commands/select).\n\n### Put\n\n```bash\necho '{\"name\": \"Tom\"}' | dasel put -r json -t string -v 'contact@tomwright.me' 'email'\n{\n  \"email\": \"contact@tomwright.me\",\n  \"name\": \"Tom\"\n}\n```\n\nSee [put documentation](https://daseldocs.tomwright.me/commands/put).\n\n### Delete\n\n```bash\necho '{\n  \"email\": \"contact@tomwright.me\",\n  \"name\": \"Tom\"\n}' | dasel delete -r json '.email'\n{\n  \"name\": \"Tom\"\n}\n```\n\nSee [delete documentation](https://daseldocs.tomwright.me/commands/delete).\n\n## Completion\n\nIf you want to use completion from the terminal you can do the following (using zsh in this example):\n\nAdd the following to `~/.zshrc` and reload your terminal.\n```bash\nexport fpath=(~/zsh/site-functions $fpath)\nmkdir -p ~/zsh/site-functions\ndasel completion zsh > ~/zsh/site-functions/_dasel\ncompinit\n```\n\n## Pre-Commit\n\nAdd `dasel` hooks to `.pre-commit-config.yaml` file\n\n```yaml\n- repo: https://github.com/TomWright/dasel\n  rev: v1.25.1\n  hooks:\n    - id: dasel-validate\n```\n\nfor a native execution of dasel, or use:\n\n- `dasel-validate-docker` pre-commit hook for executing dasel using the official [Docker images](https://daseldocs.tomwright.me/installation#docker)\n- `dasel-validate-bin` pre-commit hook for executing dasel using the official [binary](https://daseldocs.tomwright.me/installation)\n\n## Issue vs Discussion\n\nI have enabled [discussions](https://github.com/TomWright/dasel/discussions) on this repository.\n\nI am aware there may be some confusion when deciding where you should communicate when reporting issues, asking questions or raising feature requests so this section aims to help us align on that.\n\nPlease [raise an issue](https://github.com/TomWright/dasel/issues) if:\n\n- You find a bug.\n- You have a feature request and can clearly describe your request.\n\nPlease [open a discussion](https://github.com/TomWright/dasel/discussions) if:\n\n- You have a question.\n- You're not sure how to achieve something with dasel.\n- You have an idea but don't quite know how you would like it to work.\n- You have achieved something cool with dasel and want to show it off.\n- Anything else!\n\n## Features\n\n- [Query/select data from structured data files](https://daseldocs.tomwright.me/commands/select).\n- [Update data in structured data files](https://daseldocs.tomwright.me/commands/put).\n- Create data files.\n- [Supports multiple data formats/types](https://daseldocs.tomwright.me/supported-file-formats).\n- [Convert between data formats/types](https://daseldocs.tomwright.me/examples/change-file-format).\n- Uses a [standard query/selector syntax](https://daseldocs.tomwright.me/functions/selector-overview) across all data formats.\n- Zero runtime dependencies.\n- [Available on Linux, Mac and Windows](https://daseldocs.tomwright.me/installation).\n- Available to [import and use in your own projects](https://pkg.go.dev/github.com/tomwright/dasel/v2).\n- [Run via Docker](https://daseldocs.tomwright.me/installation#docker).\n- [Faster than jq/yq](#benchmarks).\n- [Pre-commit hooks](#pre-commit).\n\n## Documentation\n\nThe official dasel docs can be found at [daseldocs.tomwright.me](https://daseldocs.tomwright.me).\n\n## Playground\n\nYou can test out dasel commands using the [playground](https://dasel.tomwright.me).\n\nSource code for the playground can be found at [github.com/TomWright/daselplayground](https://github.com/TomWright/daselplayground).\n\n## Benchmarks\n\nIn my tests dasel has been up to 3x faster than jq and 15x faster than yq.\n\nSee the [benchmark directory](./benchmark/README.md).\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/TomWright/dasel.svg)](https://starchart.cc/TomWright/dasel)\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yaml",
          "type": "blob",
          "size": 0.40234375,
          "content": "comment: no # do not comment PR with the result\n\ncoverage:\n  range: 50..90 # coverage lower than 50 is red, higher than 90 green, between color code\n\n  status:\n    project: # settings affecting project coverage\n      default:\n        target: auto # auto % coverage target\n        threshold: 5%  # allow for 5% reduction of coverage without failing\n\n    # do not run coverage on patch nor changes\n    patch: false"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 5.591796875,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Context has scope over the entire query.\n// Each individual function has its own step within the context.\n// The context holds the entire data structure we're accessing/modifying.\ntype Context struct {\n\tselector          string\n\tselectorResolver  SelectorResolver\n\tsteps             []*Step\n\tdata              Value\n\tfunctions         *FunctionCollection\n\tcreateWhenMissing bool\n\tmetadata          map[string]interface{}\n}\n\nfunc (c *Context) WithMetadata(key string, value interface{}) *Context {\n\tif c.metadata == nil {\n\t\tc.metadata = map[string]interface{}{}\n\t}\n\tc.metadata[key] = value\n\treturn c\n}\n\nfunc (c *Context) Metadata(key string) interface{} {\n\tif c.metadata == nil {\n\t\treturn nil\n\t}\n\tif val, ok := c.metadata[key]; ok {\n\t\treturn val\n\t}\n\treturn nil\n}\n\nfunc newContextWithFunctions(value interface{}, selector string, functions *FunctionCollection) *Context {\n\tvar v Value\n\tif val, ok := value.(Value); ok {\n\t\tv = val\n\t} else {\n\t\tvar reflectVal reflect.Value\n\t\tif val, ok := value.(reflect.Value); ok {\n\t\t\treflectVal = val\n\t\t} else {\n\t\t\treflectVal = reflect.ValueOf(value)\n\t\t}\n\n\t\tv = Value{\n\t\t\tValue: reflectVal,\n\t\t}\n\t}\n\n\tv.Value = makeAddressable(v.Value)\n\n\t// v.SetMapIndex(reflect.ValueOf(\"users\"), v.MapIndex(ValueOf(\"users\")))\n\t// v.MapIndex(\"users\")\n\n\tv.setFn = func(value Value) {\n\t\tv.Unpack().Set(value.Value)\n\t}\n\n\tif v.Metadata(\"key\") == nil {\n\t\tv.WithMetadata(\"key\", \"root\")\n\t}\n\n\treturn &Context{\n\t\tselector: selector,\n\t\tdata:     v,\n\t\tsteps: []*Step{\n\t\t\t{\n\t\t\t\tselector: Selector{\n\t\t\t\t\tfuncName: \"root\",\n\t\t\t\t\tfuncArgs: []string{},\n\t\t\t\t},\n\t\t\t\tindex:  0,\n\t\t\t\toutput: Values{v},\n\t\t\t},\n\t\t},\n\t\tfunctions:        functions,\n\t\tselectorResolver: NewSelectorResolver(selector, functions),\n\t}\n}\n\nfunc newSelectContext(value interface{}, selector string) *Context {\n\treturn newContextWithFunctions(value, selector, standardFunctions())\n}\n\nfunc newPutContext(value interface{}, selector string) *Context {\n\treturn newContextWithFunctions(value, selector, standardFunctions()).\n\t\tWithCreateWhenMissing(true)\n}\n\nfunc newDeleteContext(value interface{}, selector string) *Context {\n\treturn newContextWithFunctions(value, selector, standardFunctions())\n}\n\nfunc derefValue(v Value) Value {\n\tres := ValueOf(deref(v.Value))\n\tres.metadata = v.metadata\n\treturn res\n}\n\nfunc derefValues(values Values) Values {\n\tresults := make(Values, len(values))\n\tfor k, v := range values {\n\t\tresults[k] = derefValue(v)\n\t}\n\treturn results\n}\n\n// Select resolves the given selector and returns the resulting values.\nfunc Select(root interface{}, selector string) (Values, error) {\n\tc := newSelectContext(root, selector)\n\tvalues, err := c.Run()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn derefValues(values), nil\n}\n\n// Put resolves the given selector and writes the given value in their place.\n// The root value may be changed in-place. If this is not desired you should copy the input\n// value before passing it to Put.\nfunc Put(root interface{}, selector string, value interface{}) (Value, error) {\n\ttoSet := ValueOf(value)\n\tc := newPutContext(root, selector)\n\tvalues, err := c.Run()\n\tif err != nil {\n\t\treturn Value{}, err\n\t}\n\tfor _, v := range values {\n\t\tv.Set(toSet)\n\t}\n\treturn c.Data(), nil\n}\n\n// Delete resolves the given selector and deletes any found values.\n// The root value may be changed in-place. If this is not desired you should copy the input\n// value before passing it to Delete.\nfunc Delete(root interface{}, selector string) (Value, error) {\n\tc := newDeleteContext(root, selector)\n\tvalues, err := c.Run()\n\tif err != nil {\n\t\treturn Value{}, err\n\t}\n\tfor _, v := range values {\n\t\tv.Delete()\n\t}\n\treturn c.Data(), nil\n}\n\nfunc (c *Context) subSelectContext(value interface{}, selector string) *Context {\n\tsubC := newContextWithFunctions(value, selector, c.functions)\n\tsubC.metadata = c.metadata\n\treturn subC\n}\n\nfunc (c *Context) subSelect(value interface{}, selector string) (Values, error) {\n\treturn c.subSelectContext(value, selector).Run()\n}\n\n// WithSelector updates c with the given selector.\nfunc (c *Context) WithSelector(s string) *Context {\n\tc.selector = s\n\tc.selectorResolver = NewSelectorResolver(s, c.functions)\n\treturn c\n}\n\n// WithCreateWhenMissing updates c with the given create value.\n// If this value is true, elements (such as properties) will be initialised instead\n// of return not found errors.\nfunc (c *Context) WithCreateWhenMissing(create bool) *Context {\n\tc.createWhenMissing = create\n\treturn c\n}\n\n// CreateWhenMissing returns true if the internal createWhenMissing value is true.\nfunc (c *Context) CreateWhenMissing() bool {\n\treturn c.createWhenMissing\n}\n\n// Data returns the root element of the context.\nfunc (c *Context) Data() Value {\n\treturn derefValue(c.data)\n}\n\n// Run calls Next repeatedly until no more steps are left.\n// Returns the final Step.\nfunc (c *Context) Run() (Values, error) {\n\tvar res *Step\n\tfor {\n\t\tstep, err := c.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif step == nil {\n\t\t\tbreak\n\t\t}\n\t\tres = step\n\t}\n\treturn res.output, nil\n}\n\n// Next returns the next Step, or nil if we have reached the final Selector.\nfunc (c *Context) Next() (*Step, error) {\n\tnextSelector, err := c.selectorResolver.Next()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not resolve selector: %w\", err)\n\t}\n\n\tif nextSelector == nil {\n\t\treturn nil, nil\n\t}\n\n\tnextStep := &Step{\n\t\tcontext:  c,\n\t\tselector: *nextSelector,\n\t\tindex:    len(c.steps),\n\t\toutput:   nil,\n\t}\n\n\tc.steps = append(c.steps, nextStep)\n\n\tif err := nextStep.execute(); err != nil {\n\t\treturn nextStep, err\n\t}\n\n\treturn nextStep, nil\n}\n\n// Step returns the step at the given index.\nfunc (c *Context) Step(i int) *Step {\n\tif i < 0 || i > (len(c.steps)-1) {\n\t\treturn nil\n\t}\n\treturn c.steps[i]\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 2.1357421875,
          "content": "package dasel\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc sameSlice(x, y []interface{}) bool {\n\tif len(x) != len(y) {\n\t\treturn false\n\t}\n\n\tif reflect.DeepEqual(x, y) {\n\t\treturn true\n\t}\n\n\t// Test for equality ignoring ordering\n\tdiff := make([]interface{}, len(y))\n\tcopy(diff, y)\n\tfor _, xv := range x {\n\t\tfor di, dv := range diff {\n\t\t\tif reflect.DeepEqual(xv, dv) {\n\t\t\t\tdiff = append(diff[0:di], diff[di+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len(diff) == 0\n}\n\nfunc selectTest(selector string, original interface{}, exp []interface{}) func(t *testing.T) {\n\treturn func(t *testing.T) {\n\t\tc := newSelectContext(original, selector)\n\n\t\tvalues, err := c.Run()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tgot := values.Interfaces()\n\t\tif !sameSlice(exp, got) {\n\t\t\tt.Errorf(\"expected %v, got %v\", exp, got)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc selectTestAssert(selector string, original interface{}, assertFn func(t *testing.T, got []any)) func(t *testing.T) {\n\treturn func(t *testing.T) {\n\t\tc := newSelectContext(original, selector)\n\n\t\tvalues, err := c.Run()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tgot := values.Interfaces()\n\t\tassertFn(t, got)\n\t}\n}\n\nfunc selectTestErr(selector string, original interface{}, expErr error) func(t *testing.T) {\n\treturn func(t *testing.T) {\n\t\tc := newSelectContext(original, selector)\n\n\t\t_, err := c.Run()\n\n\t\tif !errors.Is(err, expErr) {\n\t\t\tt.Errorf(\"expected error: %v, got %v\", expErr, err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestContext_Step(t *testing.T) {\n\tstep1 := &Step{index: 0}\n\tstep2 := &Step{index: 1}\n\tc := &Context{\n\t\tsteps: []*Step{\n\t\t\tstep1, step2,\n\t\t},\n\t}\n\texpSteps := map[int]*Step{\n\t\t-1: nil,\n\t\t0:  step1,\n\t\t1:  step2,\n\t\t2:  nil,\n\t}\n\n\tfor index, exp := range expSteps {\n\t\tgot := c.Step(index)\n\t\tif exp != got {\n\t\t\tt.Errorf(\"expected %v, got %v\", exp, got)\n\t\t}\n\t}\n}\n\nfunc TestContext_WithMetadata(t *testing.T) {\n\tc := (&Context{}).\n\t\tWithMetadata(\"x\", 1).\n\t\tWithMetadata(\"y\", 2)\n\n\texpMetadata := map[string]interface{}{\n\t\t\"x\": 1,\n\t\t\"y\": 2,\n\t\t\"z\": nil,\n\t}\n\n\tfor index, exp := range expMetadata {\n\t\tgot := c.Metadata(index)\n\t\tif exp != got {\n\t\t\tt.Errorf(\"expected %v, got %v\", exp, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "demo.gif",
          "type": "blob",
          "size": 1544.638671875,
          "content": null
        },
        {
          "name": "dencoding",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 2.9990234375,
          "content": "package dasel\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// ErrMissingPreviousNode is returned when findValue doesn't have access to the previous node.\nvar ErrMissingPreviousNode = errors.New(\"missing previous node\")\n\n// UnknownComparisonOperatorErr is returned when\ntype UnknownComparisonOperatorErr struct {\n\tOperator string\n}\n\n// Error returns the error message.\nfunc (e UnknownComparisonOperatorErr) Error() string {\n\treturn fmt.Sprintf(\"unknown comparison operator: %s\", e.Operator)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e UnknownComparisonOperatorErr) Is(err error) bool {\n\t_, ok := err.(*UnknownComparisonOperatorErr)\n\treturn ok\n}\n\n// InvalidIndexErr is returned when a selector targets an index that does not exist.\ntype InvalidIndexErr struct {\n\tIndex string\n}\n\n// Error returns the error message.\nfunc (e InvalidIndexErr) Error() string {\n\treturn fmt.Sprintf(\"invalid index: %s\", e.Index)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e InvalidIndexErr) Is(err error) bool {\n\t_, ok := err.(*InvalidIndexErr)\n\treturn ok\n}\n\n// UnsupportedSelector is returned when a specific selector type is used in the wrong context.\ntype UnsupportedSelector struct {\n\tSelector string\n}\n\n// Error returns the error message.\nfunc (e UnsupportedSelector) Error() string {\n\treturn fmt.Sprintf(\"selector is not supported here: %s\", e.Selector)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e UnsupportedSelector) Is(err error) bool {\n\t_, ok := err.(*UnsupportedSelector)\n\treturn ok\n}\n\n// ValueNotFound is returned when a selector string cannot be fully resolved.\ntype ValueNotFound struct {\n\tSelector      string\n\tPreviousValue reflect.Value\n}\n\n// Error returns the error message.\nfunc (e ValueNotFound) Error() string {\n\treturn fmt.Sprintf(\"no value found for selector: %s: %v\", e.Selector, e.PreviousValue)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e ValueNotFound) Is(err error) bool {\n\t_, ok := err.(*ValueNotFound)\n\treturn ok\n}\n\n// UnexpectedPreviousNilValue is returned when the previous node contains a nil value.\ntype UnexpectedPreviousNilValue struct {\n\tSelector string\n}\n\n// Error returns the error message.\nfunc (e UnexpectedPreviousNilValue) Error() string {\n\treturn fmt.Sprintf(\"previous value is nil: %s\", e.Selector)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e UnexpectedPreviousNilValue) Is(err error) bool {\n\t_, ok := err.(*UnexpectedPreviousNilValue)\n\treturn ok\n}\n\n// UnhandledCheckType is returned when the a check doesn't know how to deal with the given type\ntype UnhandledCheckType struct {\n\tValue interface{}\n}\n\n// Error returns the error message.\nfunc (e UnhandledCheckType) Error() string {\n\treturn fmt.Sprintf(\"unhandled check type: %T\", e.Value)\n}\n\n// Is implements the errors interface, so the errors.Is() function can be used.\nfunc (e UnhandledCheckType) Is(err error) bool {\n\t_, ok := err.(*UnhandledCheckType)\n\treturn ok\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 3.9541015625,
          "content": "package dasel_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/tomwright/dasel/v2\"\n)\n\nfunc TestErrorMessages(t *testing.T) {\n\ttests := []struct {\n\t\tIn  error\n\t\tOut string\n\t}{\n\t\t{In: dasel.ErrMissingPreviousNode, Out: \"missing previous node\"},\n\t\t{In: &dasel.UnknownComparisonOperatorErr{Operator: \"<\"}, Out: \"unknown comparison operator: <\"},\n\t\t{In: &dasel.InvalidIndexErr{Index: \"1\"}, Out: \"invalid index: 1\"},\n\t\t{In: &dasel.UnsupportedSelector{Selector: \"...\"}, Out: \"selector is not supported here: ...\"},\n\t\t{In: &dasel.ValueNotFound{\n\t\t\tSelector: \".name\",\n\t\t}, Out: \"no value found for selector: .name: <invalid reflect.Value>\"},\n\t\t{In: &dasel.ValueNotFound{\n\t\t\tSelector:      \".name\",\n\t\t\tPreviousValue: reflect.ValueOf(map[string]interface{}{}),\n\t\t}, Out: \"no value found for selector: .name: map[]\"},\n\t\t{In: &dasel.UnexpectedPreviousNilValue{Selector: \".name\"}, Out: \"previous value is nil: .name\"},\n\t\t{In: &dasel.UnhandledCheckType{Value: \"\"}, Out: \"unhandled check type: string\"},\n\t}\n\n\tfor _, testCase := range tests {\n\t\ttc := testCase\n\t\tt.Run(\"ErrorMessage\", func(t *testing.T) {\n\t\t\tif exp, got := tc.Out, tc.In.Error(); exp != got {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", exp, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorsIs(t *testing.T) {\n\ttype args struct {\n\t\tErr    error\n\t\tTarget error\n\t}\n\n\ttests := []struct {\n\t\tIn  args\n\t\tOut bool\n\t}{\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.UnknownComparisonOperatorErr{},\n\t\t\t\tTarget: &dasel.UnknownComparisonOperatorErr{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.UnknownComparisonOperatorErr{}),\n\t\t\t\tTarget: &dasel.UnknownComparisonOperatorErr{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.UnknownComparisonOperatorErr{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.InvalidIndexErr{},\n\t\t\t\tTarget: &dasel.InvalidIndexErr{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.InvalidIndexErr{}),\n\t\t\t\tTarget: &dasel.InvalidIndexErr{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.InvalidIndexErr{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.UnsupportedSelector{},\n\t\t\t\tTarget: &dasel.UnsupportedSelector{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.UnsupportedSelector{}),\n\t\t\t\tTarget: &dasel.UnsupportedSelector{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.UnsupportedSelector{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.ValueNotFound{},\n\t\t\t\tTarget: &dasel.ValueNotFound{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.ValueNotFound{}),\n\t\t\t\tTarget: &dasel.ValueNotFound{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.ValueNotFound{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.UnexpectedPreviousNilValue{},\n\t\t\t\tTarget: &dasel.UnexpectedPreviousNilValue{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.UnexpectedPreviousNilValue{}),\n\t\t\t\tTarget: &dasel.UnexpectedPreviousNilValue{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.UnexpectedPreviousNilValue{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    &dasel.UnhandledCheckType{},\n\t\t\t\tTarget: &dasel.UnhandledCheckType{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    fmt.Errorf(\"some error: %w\", &dasel.UnhandledCheckType{}),\n\t\t\t\tTarget: &dasel.UnhandledCheckType{},\n\t\t\t},\n\t\t\tOut: true,\n\t\t},\n\t\t{\n\t\t\tIn: args{\n\t\t\t\tErr:    errors.New(\"some error\"),\n\t\t\t\tTarget: &dasel.UnhandledCheckType{},\n\t\t\t},\n\t\t\tOut: false,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\ttc := testCase\n\t\tt.Run(\"ErrorMessage\", func(t *testing.T) {\n\t\t\tif exp, got := tc.Out, errors.Is(tc.In.Err, tc.In.Target); exp != got {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", exp, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "func.go",
          "type": "blob",
          "size": 4.1318359375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype ErrUnknownFunction struct {\n\tFunction string\n}\n\nfunc (e ErrUnknownFunction) Error() string {\n\treturn fmt.Sprintf(\"unknown function: %s\", e.Function)\n}\n\nfunc (e ErrUnknownFunction) Is(other error) bool {\n\t_, ok := other.(*ErrUnknownFunction)\n\treturn ok\n}\n\ntype ErrUnexpectedFunctionArgs struct {\n\tFunction string\n\tArgs     []string\n\tMessage  string\n}\n\nfunc (e ErrUnexpectedFunctionArgs) Error() string {\n\treturn fmt.Sprintf(\"unexpected function args: %s(%s): %s\", e.Function, strings.Join(e.Args, \", \"), e.Message)\n}\n\nfunc (e ErrUnexpectedFunctionArgs) Is(other error) bool {\n\to, ok := other.(*ErrUnexpectedFunctionArgs)\n\tif !ok {\n\t\treturn false\n\t}\n\tif o.Function != \"\" && o.Function != e.Function {\n\t\treturn false\n\t}\n\tif o.Message != \"\" && o.Message != e.Message {\n\t\treturn false\n\t}\n\tif o.Args != nil && !reflect.DeepEqual(o.Args, e.Args) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc standardFunctions() *FunctionCollection {\n\tcollection := &FunctionCollection{}\n\tcollection.Add(\n\t\t// Generic\n\t\tThisFunc,\n\t\tLenFunc,\n\t\tKeyFunc,\n\t\tKeysFunc,\n\t\tMergeFunc,\n\t\tCountFunc,\n\t\tMapOfFunc,\n\t\tTypeFunc,\n\t\tJoinFunc,\n\t\tStringFunc,\n\t\tNullFunc,\n\n\t\t// Selectors\n\t\tIndexFunc,\n\t\tAllFunc,\n\t\tFirstFunc,\n\t\tLastFunc,\n\t\tPropertyFunc,\n\t\tAppendFunc,\n\t\tOrDefaultFunc,\n\n\t\t// Filters\n\t\tFilterFunc,\n\t\tFilterOrFunc,\n\n\t\t// Comparisons\n\t\tEqualFunc,\n\t\tMoreThanFunc,\n\t\tLessThanFunc,\n\t\tAndFunc,\n\t\tOrFunc,\n\t\tNotFunc,\n\n\t\t// Metadata\n\t\tMetadataFunc,\n\t\tParentFunc,\n\t)\n\treturn collection\n}\n\n// SelectorFunc is a function that can be executed in a selector.\ntype SelectorFunc func(c *Context, step *Step, args []string) (Values, error)\n\ntype FunctionCollection struct {\n\tfunctions []Function\n}\n\nfunc (fc *FunctionCollection) ParseSelector(part string) *Selector {\n\tfor _, f := range fc.functions {\n\t\tif s := f.AlternativeSelector(part); s != nil {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (fc *FunctionCollection) Add(fs ...Function) {\n\tfc.functions = append(fc.functions, fs...)\n}\n\nfunc (fc *FunctionCollection) GetAll() map[string]SelectorFunc {\n\tres := make(map[string]SelectorFunc)\n\tfor _, f := range fc.functions {\n\t\tres[f.Name()] = f.Run\n\t}\n\treturn res\n}\n\nfunc (fc *FunctionCollection) Get(name string) (SelectorFunc, error) {\n\tif f, ok := fc.GetAll()[name]; ok {\n\t\treturn f, nil\n\t}\n\treturn nil, &ErrUnknownFunction{Function: name}\n}\n\ntype Function interface {\n\tName() string\n\tRun(c *Context, s *Step, args []string) (Values, error)\n\tAlternativeSelector(part string) *Selector\n}\n\ntype BasicFunction struct {\n\tname                  string\n\trunFn                 func(c *Context, s *Step, args []string) (Values, error)\n\talternativeSelectorFn func(part string) *Selector\n}\n\nfunc (bf BasicFunction) Name() string {\n\treturn bf.name\n}\n\nfunc (bf BasicFunction) Run(c *Context, s *Step, args []string) (Values, error) {\n\treturn bf.runFn(c, s, args)\n}\n\nfunc (bf BasicFunction) AlternativeSelector(part string) *Selector {\n\tif bf.alternativeSelectorFn == nil {\n\t\treturn nil\n\t}\n\treturn bf.alternativeSelectorFn(part)\n}\n\nfunc requireNoArgs(name string, args []string) error {\n\tif len(args) > 0 {\n\t\treturn &ErrUnexpectedFunctionArgs{\n\t\t\tFunction: name,\n\t\t\tArgs:     args,\n\t\t\tMessage:  \"0 arguments expected\",\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc requireExactlyXArgs(name string, args []string, x int) error {\n\tif len(args) != x {\n\t\treturn &ErrUnexpectedFunctionArgs{\n\t\t\tFunction: name,\n\t\t\tArgs:     args,\n\t\t\tMessage:  fmt.Sprintf(\"exactly %d arguments expected\", x),\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc requireXOrMoreArgs(name string, args []string, x int) error {\n\tif len(args) < x {\n\t\treturn &ErrUnexpectedFunctionArgs{\n\t\t\tFunction: name,\n\t\t\tArgs:     args,\n\t\t\tMessage:  fmt.Sprintf(\"expected %d or more arguments\", x),\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc requireXOrLessArgs(name string, args []string, x int) error {\n\tif len(args) > x {\n\t\treturn &ErrUnexpectedFunctionArgs{\n\t\t\tFunction: name,\n\t\t\tArgs:     args,\n\t\t\tMessage:  fmt.Sprintf(\"expected %d or less arguments\", x),\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc requireModulusXArgs(name string, args []string, x int) error {\n\tif len(args)%x != 0 {\n\t\treturn &ErrUnexpectedFunctionArgs{\n\t\t\tFunction: name,\n\t\t\tArgs:     args,\n\t\t\tMessage:  fmt.Sprintf(\"expected arguments in groups of %d\", x),\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "func_all.go",
          "type": "blob",
          "size": 1,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"github.com/tomwright/dasel/v2/dencoding\"\n\t\"reflect\"\n)\n\nvar AllFunc = BasicFunction{\n\tname: \"all\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"all\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tfor _, r := range val.String() {\n\t\t\t\t\tres = append(res, ValueOf(string(r)))\n\t\t\t\t}\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\t\t\tres = append(res, val.Index(i))\n\t\t\t\t}\n\t\t\tcase reflect.Map:\n\t\t\t\tfor _, key := range val.MapKeys() {\n\t\t\t\t\tres = append(res, val.MapIndex(key))\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif val.IsDencodingMap() {\n\t\t\t\t\tfor _, k := range val.Interface().(*dencoding.Map).Keys() {\n\t\t\t\t\t\tres = append(res, val.dencodingMapIndex(ValueOf(k)))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, fmt.Errorf(\"cannot use all selector on non slice/array/map types\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_all_test.go",
          "type": "blob",
          "size": 0.6533203125,
          "content": "package dasel\n\nimport \"testing\"\n\nfunc TestAllFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"all(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"all\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"RootAllSlice\",\n\t\tselectTest(\n\t\t\t\"all()\",\n\t\t\t[]interface{}{\"red\", \"green\", \"blue\"},\n\t\t\t[]interface{}{\"red\", \"green\", \"blue\"},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"NestedAllSlice\",\n\t\tselectTest(\n\t\t\t\"colours.all()\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"colours\": []interface{}{\"red\", \"green\", \"blue\"},\n\t\t\t},\n\t\t\t[]interface{}{\"red\", \"green\", \"blue\"},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"AllString\",\n\t\tselectTest(\n\t\t\t\"all()\",\n\t\t\t\"asd\",\n\t\t\t[]interface{}{\"a\", \"s\", \"d\"},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_and.go",
          "type": "blob",
          "size": 0.9638671875,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar AndFunc = BasicFunction{\n\tname: \"and\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"and\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\trunComparison := func(value Value, selector string) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"and expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\treturn IsTruthy(gotValues[0]), nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := true\n\t\t\tfor _, cmp := range args {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif !pass {\n\t\t\t\t\tvalPassed = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, Value{Value: reflect.ValueOf(valPassed)})\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_and_test.go",
          "type": "blob",
          "size": 0.794921875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAndFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"and()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"and\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"NoneEqualMoreThan\",\n\t\tselectTest(\n\t\t\t\"numbers.all().and(equal(.,2),moreThan(.,2))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"numbers\": []interface{}{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse, false, false, false, false, false, false, false, false, false,\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"SomeEqualMoreThan\",\n\t\tselectTest(\n\t\t\t\"numbers.all().and(equal(.,4),moreThan(.,2))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"numbers\": []interface{}{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse, false, false, false, true, false, false, false, false, false,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_append.go",
          "type": "blob",
          "size": 0.8193359375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar AppendFunc = BasicFunction{\n\tname: \"append\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"append\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tif c.CreateWhenMissing() {\n\t\t\tinput = input.initEmptySlices()\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tval = val.Append()\n\t\t\t\tvalue := val.Index(val.Len() - 1)\n\t\t\t\tres = append(res, value)\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"cannot use append selector on non slice/array types\")\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n\talternativeSelectorFn: func(part string) *Selector {\n\t\tif part == \"[]\" {\n\t\t\treturn &Selector{\n\t\t\t\tfuncName: \"append\",\n\t\t\t\tfuncArgs: []string{},\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "func_count.go",
          "type": "blob",
          "size": 0.203125,
          "content": "package dasel\n\nvar CountFunc = BasicFunction{\n\tname: \"count\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tinput := s.inputs()\n\n\t\treturn Values{\n\t\t\tValueOf(len(input)),\n\t\t}, nil\n\t},\n}\n"
        },
        {
          "name": "func_count_test.go",
          "type": "blob",
          "size": 0.4873046875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCountFunc(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"string\": \"hello\",\n\t\t\"slice\": []interface{}{\n\t\t\t1, 2, 3,\n\t\t},\n\t\t\"falseBool\": false,\n\t\t\"trueBool\":  true,\n\t}\n\n\tt.Run(\n\t\t\"RootObject\",\n\t\tselectTest(\n\t\t\t\"count()\",\n\t\t\tdata,\n\t\t\t[]interface{}{1},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"All\",\n\t\tselectTest(\n\t\t\t\"all().count()\",\n\t\t\tdata,\n\t\t\t[]interface{}{4},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"NestedAll\",\n\t\tselectTest(\n\t\t\t\"slice.all().count()\",\n\t\t\tdata,\n\t\t\t[]interface{}{3},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_equal.go",
          "type": "blob",
          "size": 1.5322265625,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"github.com/tomwright/dasel/v2/util\"\n\t\"reflect\"\n)\n\nvar EqualFunc = BasicFunction{\n\tname: \"equal\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"equal\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := requireModulusXArgs(\"equal\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\ttype comparison struct {\n\t\t\tselector string\n\t\t\tvalue    string\n\t\t}\n\n\t\tcomparisons := make([]comparison, 0)\n\n\t\tcurrentComparison := comparison{}\n\n\t\tfor i, v := range args {\n\t\t\tswitch i % 2 {\n\t\t\tcase 0:\n\t\t\t\tcurrentComparison.selector = v\n\t\t\tcase 1:\n\t\t\t\tcurrentComparison.value = v\n\t\t\t\tcomparisons = append(comparisons, currentComparison)\n\t\t\t\tcurrentComparison = comparison{}\n\t\t\t}\n\t\t}\n\n\t\trunComparison := func(value Value, cmp comparison) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, cmp.selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"equal expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tgotValue := util.ToString(gotValues[0].Interface())\n\t\t\treturn gotValue == cmp.value, nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := true\n\t\t\tfor _, cmp := range comparisons {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif !pass {\n\t\t\t\t\tvalPassed = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, Value{Value: reflect.ValueOf(valPassed)})\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_equal_test.go",
          "type": "blob",
          "size": 1.318359375,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"equal()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"equal\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Single Equal\",\n\t\tselectTest(\n\t\t\t\"name.all().equal(key(),first)\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Multi Equal\",\n\t\tselectTest(\n\t\t\t\"name.all().equal(key(),first,key(),first)\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Single Equal Optional Field\",\n\t\tselectTest(\n\t\t\t\"all().equal(primary,true)\",\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"red\",\n\t\t\t\t\t\"hex\":     \"ff0000\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"green\",\n\t\t\t\t\t\"hex\":     \"00ff00\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"blue\",\n\t\t\t\t\t\"hex\":     \"0000ff\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"orange\",\n\t\t\t\t\t\"hex\":     \"ffa500\",\n\t\t\t\t\t\"primary\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\ttrue, true, true, false,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_filter.go",
          "type": "blob",
          "size": 0.9521484375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n)\n\nvar FilterFunc = BasicFunction{\n\tname: \"filter\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"filter\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\trunComparison := func(value Value, selector string) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"filter expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\treturn IsTruthy(gotValues[0]), nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := true\n\t\t\tfor _, cmp := range args {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif !pass {\n\t\t\t\t\tvalPassed = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif valPassed {\n\t\t\t\tres = append(res, val)\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_filter_or.go",
          "type": "blob",
          "size": 0.95703125,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n)\n\nvar FilterOrFunc = BasicFunction{\n\tname: \"filterOr\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"filterOr\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\trunComparison := func(value Value, selector string) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"filter expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\treturn IsTruthy(gotValues[0]), nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := false\n\t\t\tfor _, cmp := range args {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif pass {\n\t\t\t\t\tvalPassed = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif valPassed {\n\t\t\t\tres = append(res, val)\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_filter_or_test.go",
          "type": "blob",
          "size": 1.1845703125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFilterOrFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"filterOr()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"filterOr\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Filter Equal Key\",\n\t\tselectTest(\n\t\t\t\"name.all().filterOr(equal(key(),first))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Multiple Filter Or Equal Key\",\n\t\tselectTest(\n\t\t\t\"name.all().filterOr(equal(key(),first),equal(key(),last))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t\t\"Wright\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"MoreThanEqual\",\n\t\tselectTest(\n\t\t\t\"nums.all().filterOr(moreThan(.,3),equal(.,3))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"nums\": []interface{}{0, 1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\t[]interface{}{3, 4, 5},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"LessThanEqual\",\n\t\tselectTest(\n\t\t\t\"nums.all().filterOr(lessThan(.,3),equal(.,3))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"nums\": []interface{}{0, 1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\t[]interface{}{0, 1, 2, 3},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_filter_test.go",
          "type": "blob",
          "size": 3.478515625,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFilterFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"filter()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"filter\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Filter Equal Key\",\n\t\tselectTest(\n\t\t\t\"name.all().filter(equal(key(),first))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Multiple Filter Equal Key\",\n\t\tselectTest(\n\t\t\t\"name.all().filter(equal(key(),first),equal(key(),last))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Filter Equal Prop\",\n\t\tselectTest(\n\t\t\t\"all().filter(equal(primary,true)).name\",\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"red\",\n\t\t\t\t\t\"hex\":     \"ff0000\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"green\",\n\t\t\t\t\t\"hex\":     \"00ff00\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"blue\",\n\t\t\t\t\t\"hex\":     \"0000ff\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"orange\",\n\t\t\t\t\t\"hex\":     \"ffa500\",\n\t\t\t\t\t\"primary\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"red\", \"green\", \"blue\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"FilterNestedProp\",\n\t\tselectTest(\n\t\t\t\"all().filter(equal(flags.banned,false)).name\",\n\t\t\t[]map[string]interface{}{\n\t\t\t\t{\n\t\t\t\t\t\"flags\": map[string]interface{}{\n\t\t\t\t\t\t\"banned\": false,\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"Tom\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"flags\": map[string]interface{}{\n\t\t\t\t\t\t\"banned\": true,\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"Jim\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Filter And\",\n\t\tselectTest(\n\t\t\t\"all().filter(and(equal(primary,true),equal(name,red))).name\",\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"red\",\n\t\t\t\t\t\"hex\":     \"ff0000\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"green\",\n\t\t\t\t\t\"hex\":     \"00ff00\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"blue\",\n\t\t\t\t\t\"hex\":     \"0000ff\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"orange\",\n\t\t\t\t\t\"hex\":     \"ffa500\",\n\t\t\t\t\t\"primary\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"red\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Filter And\",\n\t\tselectTest(\n\t\t\t\"all().filter(and(equal(primary,true),equal(name,orange))).name\",\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"red\",\n\t\t\t\t\t\"hex\":     \"ff0000\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"green\",\n\t\t\t\t\t\"hex\":     \"00ff00\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"blue\",\n\t\t\t\t\t\"hex\":     \"0000ff\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"orange\",\n\t\t\t\t\t\"hex\":     \"ffa500\",\n\t\t\t\t\t\"primary\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Filter Or\",\n\t\tselectTest(\n\t\t\t\"all().filter(or(equal(primary,true),equal(name,orange))).name\",\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"red\",\n\t\t\t\t\t\"hex\":     \"ff0000\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"green\",\n\t\t\t\t\t\"hex\":     \"00ff00\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"blue\",\n\t\t\t\t\t\"hex\":     \"0000ff\",\n\t\t\t\t\t\"primary\": true,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":    \"orange\",\n\t\t\t\t\t\"hex\":     \"ffa500\",\n\t\t\t\t\t\"primary\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"red\", \"green\", \"blue\", \"orange\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_first.go",
          "type": "blob",
          "size": 0.689453125,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar FirstFunc = BasicFunction{\n\tname: \"first\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"first\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tif val.Len() == 0 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"index out of range: %w\", &ErrIndexNotFound{Index: 0})\n\t\t\t\t}\n\t\t\t\tvalue := val.Index(0)\n\t\t\t\tres = append(res, value)\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"cannot use first selector on non slice/array types: %w\", &ErrIndexNotFound{Index: 0})\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_first_test.go",
          "type": "blob",
          "size": 0.7626953125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFirstFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"first(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"first\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\n\tt.Run(\"NotFound\", selectTestErr(\n\t\t\"first()\",\n\t\t[]interface{}{},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 0,\n\t\t}),\n\t)\n\n\tt.Run(\"NotFoundOnInvalidType\", selectTestErr(\n\t\t\"x.first()\",\n\t\tmap[string]interface{}{\"x\": \"y\"},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 0,\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{\n\t\t\"name\": map[string]interface{}{\n\t\t\t\"first\": \"Tom\",\n\t\t\t\"last\":  \"Wright\",\n\t\t},\n\t\t\"colours\": []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t},\n\t}\n\n\tt.Run(\n\t\t\"First\",\n\t\tselectTest(\n\t\t\t\"colours.first()\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"red\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_index.go",
          "type": "blob",
          "size": 2.1103515625,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype ErrIndexNotFound struct {\n\tIndex int\n}\n\nfunc (e ErrIndexNotFound) Error() string {\n\treturn fmt.Sprintf(\"index not found: %d\", e.Index)\n}\n\nfunc (e ErrIndexNotFound) Is(other error) bool {\n\to, ok := other.(*ErrIndexNotFound)\n\tif !ok {\n\t\treturn false\n\t}\n\tif o.Index >= 0 && o.Index != e.Index {\n\t\treturn false\n\t}\n\treturn true\n}\n\nvar IndexFunc = BasicFunction{\n\tname: \"index\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"index\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tfor _, indexStr := range args {\n\t\t\t\tisOptional := strings.HasSuffix(indexStr, \"?\")\n\t\t\t\tif isOptional {\n\t\t\t\t\tindexStr = strings.TrimSuffix(indexStr, \"?\")\n\t\t\t\t}\n\n\t\t\t\tindex, err := strconv.Atoi(indexStr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif isOptional {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, fmt.Errorf(\"invalid index: %w\", err)\n\t\t\t\t}\n\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.String:\n\t\t\t\t\trunes := []rune(val.String())\n\t\t\t\t\tif index < 0 || index > len(runes)-1 {\n\t\t\t\t\t\tif isOptional {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"index out of range: %w\", &ErrIndexNotFound{Index: index})\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, ValueOf(string(runes[index])))\n\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\tif index < 0 || index > val.Len()-1 {\n\t\t\t\t\t\tif isOptional {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"index out of range: %w\", &ErrIndexNotFound{Index: index})\n\t\t\t\t\t}\n\t\t\t\t\tvalue := val.Index(index)\n\t\t\t\t\tres = append(res, value)\n\t\t\t\tdefault:\n\t\t\t\t\treturn nil, fmt.Errorf(\"cannot use index selector on non slice/array types: %w\", &ErrIndexNotFound{Index: index})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n\talternativeSelectorFn: func(part string) *Selector {\n\t\tif part != \"[]\" && strings.HasPrefix(part, \"[\") && strings.HasSuffix(part, \"]\") {\n\t\t\tstrings.Split(strings.TrimPrefix(strings.TrimSuffix(part, \"]\"), \"[\"), \",\")\n\t\t\treturn &Selector{\n\t\t\t\tfuncName: \"index\",\n\t\t\t\tfuncArgs: strings.Split(strings.TrimPrefix(strings.TrimSuffix(part, \"]\"), \"[\"), \",\"),\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "func_index_test.go",
          "type": "blob",
          "size": 1.2744140625,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestIndexFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"index()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"index\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\"NotFound\", selectTestErr(\n\t\t\"[0]\",\n\t\t[]interface{}{},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 0,\n\t\t}),\n\t)\n\n\tt.Run(\"NotFoundOnInvalidType\", selectTestErr(\n\t\t\"[0]\",\n\t\tmap[string]interface{}{},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 0,\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{\n\t\t\"name\": map[string]interface{}{\n\t\t\t\"first\": \"Tom\",\n\t\t\t\"last\":  \"Wright\",\n\t\t},\n\t\t\"colours\": []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t},\n\t}\n\n\tt.Run(\n\t\t\"Index\",\n\t\tselectTest(\n\t\t\t\"colours.index(1)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"green\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"IndexString\",\n\t\tselectTest(\n\t\t\t\"colours.index(1).index(1)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"r\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"IndexMulti\",\n\t\tselectTest(\n\t\t\t\"colours.index(0,1,2)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"red\",\n\t\t\t\t\"green\",\n\t\t\t\t\"blue\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"IndexShorthand\",\n\t\tselectTest(\n\t\t\t\"colours.[1]\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"green\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"IndexShorthandMulti\",\n\t\tselectTest(\n\t\t\t\"colours.[0,1,2]\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"red\",\n\t\t\t\t\"green\",\n\t\t\t\t\"blue\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_join.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "package dasel\n\nimport (\n\t\"github.com/tomwright/dasel/v2/util\"\n\t\"strings\"\n)\n\nvar JoinFunc = BasicFunction{\n\tname: \"join\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"join\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tgetValues := func(value Value, selector string) ([]string, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn []string{}, err\n\t\t\t}\n\n\t\t\tres := make([]string, len(gotValues))\n\t\t\tfor k, v := range gotValues {\n\t\t\t\tres[k] = util.ToString(v.Interface())\n\t\t\t}\n\t\t\treturn res, nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tseparator := args[0]\n\t\targs = args[1:]\n\n\t\t// No args - join all input values\n\t\tif len(args) == 0 {\n\t\t\tvalues := make([]string, len(input))\n\t\t\tfor k, v := range input {\n\t\t\t\tvalues[k] = util.ToString(v.Interface())\n\t\t\t}\n\t\t\tres = append(res, ValueOf(strings.Join(values, separator)))\n\t\t\treturn res, nil\n\t\t}\n\n\t\t// There are args - use each as a selector and join any resulting values.\n\t\tvalues := make([]string, 0)\n\t\tfor _, val := range input {\n\t\t\tfor _, cmp := range args {\n\t\t\t\tvals, err := getValues(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvalues = append(values, vals...)\n\t\t\t}\n\t\t}\n\t\tres = append(res, ValueOf(strings.Join(values, separator)))\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_join_test.go",
          "type": "blob",
          "size": 4.1611328125,
          "content": "package dasel\n\nimport (\n\t\"github.com/tomwright/dasel/v2/dencoding\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestJoinFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"join()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"join\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\toriginal := dencoding.NewMap().\n\t\tSet(\"name\", dencoding.NewMap().\n\t\t\tSet(\"first\", \"Tom\").\n\t\t\tSet(\"last\", \"Wright\")).\n\t\tSet(\"colours\", []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t})\n\n\tt.Run(\n\t\t\"JoinCommaSeparator\",\n\t\tselectTestAssert(\n\t\t\t\"name.all().join(\\\\,)\",\n\t\t\toriginal,\n\t\t\tfunc(t *testing.T, got []any) {\n\t\t\t\trequired := []string{\"Tom\", \"Wright\"}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstr, ok := got[0].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"expected 1st result to be a string, got %T\", got[0])\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tgotStrs := strings.Split(str, \",\")\n\t\t\t\tfor _, req := range required {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, got := range gotStrs {\n\t\t\t\t\t\tif got == req {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", required, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"JoinNewlineSeparator\",\n\t\tselectTestAssert(\n\t\t\t\"name.all().join(\\\\\\n)\",\n\t\t\toriginal,\n\t\t\tfunc(t *testing.T, got []any) {\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstr, ok := got[0].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"expected 1st result to be a string, got %T\", got[0])\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\texp := \"Tom\\nWright\"\n\t\t\t\tif exp != str {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", exp, str)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t//gotStrs := strings.Split(str, \",\")\n\t\t\t\t//for _, req := range required {\n\t\t\t\t//\tfound := false\n\t\t\t\t//\tfor _, got := range gotStrs {\n\t\t\t\t//\t\tif got == req {\n\t\t\t\t//\t\t\tfound = true\n\t\t\t\t//\t\t\tcontinue\n\t\t\t\t//\t\t}\n\t\t\t\t//\t}\n\t\t\t\t//\tif !found {\n\t\t\t\t//\t\tt.Errorf(\"expected %v, got %v\", required, got)\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if len(got) != 1 {\n\t\t\t\t//\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t//\treturn\n\t\t\t\t//}\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"JoinSpaceSeparator\",\n\t\tselectTestAssert(\n\t\t\t\"name.all().join( )\",\n\t\t\toriginal,\n\t\t\tfunc(t *testing.T, got []any) {\n\t\t\t\trequired := []string{\"Tom\", \"Wright\"}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstr, ok := got[0].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"expected 1st result to be a string, got %T\", got[0])\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tgotStrs := strings.Split(str, \" \")\n\t\t\t\tfor _, req := range required {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, got := range gotStrs {\n\t\t\t\t\t\tif got == req {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", required, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"JoinWithSeparatorsAndSelectors\",\n\t\tselectTest(\n\t\t\t\"name.join( ,last,first)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"Wright Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"JoinInMap\",\n\t\tselectTest(\n\t\t\t\"mapOf(first,name.first,last,name.last,full,name.join( ,string(Mr),first,last))\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"full\":  \"Mr Tom Wright\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"JoinManyLists\",\n\t\tselectTestAssert(\n\t\t\t\"all().join(\\\\,,all())\",\n\t\t\tdencoding.NewMap().\n\t\t\t\tSet(\"x\", []interface{}{1, 2, 3}).\n\t\t\t\tSet(\"y\", []interface{}{4, 5, 6}).\n\t\t\t\tSet(\"z\", []interface{}{7, 8, 9}),\n\t\t\tfunc(t *testing.T, got []any) {\n\t\t\t\trequired := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstr, ok := got[0].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"expected 1st result to be a string, got %T\", got[0])\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tgotStrs := strings.Split(str, \",\")\n\t\t\t\tfor _, req := range required {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, got := range gotStrs {\n\t\t\t\t\t\tif got == req {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", required, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif len(got) != 1 {\n\t\t\t\t\tt.Errorf(\"expected 1 result, got %v\", got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_key.go",
          "type": "blob",
          "size": 0.392578125,
          "content": "package dasel\n\nvar KeyFunc = BasicFunction{\n\tname: \"key\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"key\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, i := range input {\n\t\t\tp := i.Metadata(\"key\")\n\t\t\tif p == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres = append(res, ValueOf(p))\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_keys.go",
          "type": "blob",
          "size": 2.3115234375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"github.com/tomwright/dasel/v2/dencoding\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype ErrInvalidType struct {\n\tExpectedTypes []string\n\tCurrentType   string\n}\n\nfunc (e *ErrInvalidType) Error() string {\n\treturn fmt.Sprintf(\"unexpected types: expect %s, get %s\", strings.Join(e.ExpectedTypes, \" \"), e.CurrentType)\n}\n\nfunc (e *ErrInvalidType) Is(other error) bool {\n\to, ok := other.(*ErrInvalidType)\n\tif !ok {\n\t\treturn false\n\t}\n\tif len(e.ExpectedTypes) != len(o.ExpectedTypes) {\n\t\treturn false\n\t}\n\tif e.CurrentType != o.CurrentType {\n\t\treturn false\n\t}\n\tfor i, t := range e.ExpectedTypes {\n\t\tif t != o.ExpectedTypes[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nvar KeysFunc = BasicFunction{\n\tname: \"keys\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"keys\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, len(input))\n\n\t\tfor i, val := range input {\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tlist := make([]any, 0, val.Len())\n\n\t\t\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\t\t\tlist = append(list, i)\n\t\t\t\t}\n\n\t\t\t\tres[i] = ValueOf(list)\n\t\t\tcase reflect.Map:\n\t\t\t\tkeys := val.MapKeys()\n\n\t\t\t\t// we expect map keys to be string first so that we can sort them\n\t\t\t\tlist, ok := getStringList(keys)\n\t\t\t\tif !ok {\n\t\t\t\t\tlist = getAnyList(keys)\n\t\t\t\t}\n\n\t\t\t\tres[i] = ValueOf(list)\n\t\t\tdefault:\n\t\t\t\tif val.IsDencodingMap() {\n\t\t\t\t\tdencodingMap := val.Interface().(*dencoding.Map)\n\t\t\t\t\tmapKeys := dencodingMap.Keys()\n\t\t\t\t\tlist := make([]any, 0, len(mapKeys))\n\t\t\t\t\tfor _, k := range mapKeys {\n\t\t\t\t\t\tlist = append(list, k)\n\t\t\t\t\t}\n\t\t\t\t\tres[i] = ValueOf(list)\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, &ErrInvalidType{\n\t\t\t\t\t\tExpectedTypes: []string{\"slice\", \"array\", \"map\"},\n\t\t\t\t\t\tCurrentType:   val.Kind().String(),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n\nfunc getStringList(values []Value) ([]any, bool) {\n\tstringList := make([]string, len(values))\n\tfor i, v := range values {\n\t\tif v.Kind() != reflect.String {\n\t\t\treturn nil, false\n\t\t}\n\t\tstringList[i] = v.String()\n\t}\n\n\tsort.Strings(stringList)\n\n\tanyList := make([]any, len(stringList))\n\tfor i, v := range stringList {\n\t\tanyList[i] = v\n\t}\n\n\treturn anyList, true\n}\n\nfunc getAnyList(values []Value) []any {\n\tanyList := make([]any, len(values))\n\tfor i, v := range values {\n\t\tanyList[i] = v.Interface()\n\t}\n\treturn anyList\n}\n"
        },
        {
          "name": "func_keys_test.go",
          "type": "blob",
          "size": 0.9951171875,
          "content": "package dasel\n\nimport (\n\t\"github.com/tomwright/dasel/v2/dencoding\"\n\t\"testing\"\n)\n\nfunc TestKeysFunc(t *testing.T) {\n\ttestdata := map[string]any{\n\t\t\"object\": map[string]any{\n\t\t\t\"c\": 3, \"a\": 1, \"b\": 2,\n\t\t},\n\t\t\"list\":   []any{111, 222, 333},\n\t\t\"string\": \"something\",\n\t\t\"dencodingMap\": dencoding.NewMap().\n\t\t\tSet(\"a\", 1).\n\t\t\tSet(\"b\", 2).\n\t\t\tSet(\"c\", 3),\n\t}\n\n\tt.Run(\n\t\t\"root\",\n\t\tselectTest(\n\t\t\t\"keys()\",\n\t\t\ttestdata,\n\t\t\t[]any{[]any{\"dencodingMap\", \"list\", \"object\", \"string\"}},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"List\",\n\t\tselectTest(\n\t\t\t\"list.keys()\",\n\t\t\ttestdata,\n\t\t\t[]any{[]any{0, 1, 2}},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Object\",\n\t\tselectTest(\n\t\t\t\"object.keys()\",\n\t\t\ttestdata,\n\t\t\t[]any{[]any{\"a\", \"b\", \"c\"}}, // sorted\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Dencoding Map\",\n\t\tselectTest(\n\t\t\t\"dencodingMap.keys()\",\n\t\t\ttestdata,\n\t\t\t[]any{[]any{\"a\", \"b\", \"c\"}}, // sorted\n\t\t),\n\t)\n\n\tt.Run(\"InvalidType\",\n\t\tselectTestErr(\n\t\t\t\"string.keys()\",\n\t\t\ttestdata,\n\t\t\t&ErrInvalidType{\n\t\t\t\tExpectedTypes: []string{\"slice\", \"array\", \"map\"},\n\t\t\t\tCurrentType:   \"string\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_last.go",
          "type": "blob",
          "size": 0.7197265625,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar LastFunc = BasicFunction{\n\tname: \"last\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"last\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tindex := val.Len() - 1\n\t\t\t\tif val.Len() == 0 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"index out of range: %w\", &ErrIndexNotFound{Index: index})\n\t\t\t\t}\n\t\t\t\tvalue := val.Index(index)\n\t\t\t\tres = append(res, value)\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"cannot use last selector on non slice/array types: %w\", &ErrIndexNotFound{Index: 0})\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_last_test.go",
          "type": "blob",
          "size": 0.7578125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLastFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"last(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"last\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\n\tt.Run(\"NotFound\", selectTestErr(\n\t\t\"last()\",\n\t\t[]interface{}{},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: -1,\n\t\t}),\n\t)\n\n\tt.Run(\"NotFoundOnInvalidType\", selectTestErr(\n\t\t\"x.last()\",\n\t\tmap[string]interface{}{\"x\": \"y\"},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 0,\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{\n\t\t\"name\": map[string]interface{}{\n\t\t\t\"first\": \"Tom\",\n\t\t\t\"last\":  \"Wright\",\n\t\t},\n\t\t\"colours\": []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t},\n\t}\n\n\tt.Run(\n\t\t\"Last\",\n\t\tselectTest(\n\t\t\t\"colours.last()\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"blue\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_len.go",
          "type": "blob",
          "size": 0.3427734375,
          "content": "package dasel\n\nvar LenFunc = BasicFunction{\n\tname: \"len\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"len\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tres = append(res, ValueOf(val.Len()))\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_len_test.go",
          "type": "blob",
          "size": 0.7314453125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLenFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"len(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"len\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\n\tdata := map[string]interface{}{\n\t\t\"string\": \"hello\",\n\t\t\"slice\": []interface{}{\n\t\t\t1, 2, 3,\n\t\t},\n\t\t\"falseBool\": false,\n\t\t\"trueBool\":  true,\n\t}\n\n\tt.Run(\n\t\t\"String\",\n\t\tselectTest(\n\t\t\t\"string.len()\",\n\t\t\tdata,\n\t\t\t[]interface{}{5},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"Slice\",\n\t\tselectTest(\n\t\t\t\"slice.len()\",\n\t\t\tdata,\n\t\t\t[]interface{}{3},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"False Bool\",\n\t\tselectTest(\n\t\t\t\"falseBool.len()\",\n\t\t\tdata,\n\t\t\t[]interface{}{0},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"True Bool\",\n\t\tselectTest(\n\t\t\t\"trueBool.len()\",\n\t\t\tdata,\n\t\t\t[]interface{}{1},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_less_than.go",
          "type": "blob",
          "size": 1.666015625,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"github.com/tomwright/dasel/v2/util\"\n\t\"reflect\"\n\t\"sort\"\n)\n\nvar LessThanFunc = BasicFunction{\n\tname: \"lessThan\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireExactlyXArgs(\"lessThan\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\ttype comparison struct {\n\t\t\tselector string\n\t\t\tvalue    string\n\t\t}\n\n\t\tcomparisons := make([]comparison, 0)\n\n\t\tcurrentComparison := comparison{}\n\n\t\tfor i, v := range args {\n\t\t\tswitch i % 2 {\n\t\t\tcase 0:\n\t\t\t\tcurrentComparison.selector = v\n\t\t\tcase 1:\n\t\t\t\tcurrentComparison.value = v\n\t\t\t\tcomparisons = append(comparisons, currentComparison)\n\t\t\t\tcurrentComparison = comparison{}\n\t\t\t}\n\t\t}\n\n\t\trunComparison := func(value Value, cmp comparison) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, cmp.selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"equal expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tgotValue := util.ToString(gotValues[0].Interface())\n\n\t\t\t// The values are equal\n\t\t\tif gotValue == cmp.value {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tsortedVals := []string{gotValue, cmp.value}\n\t\t\tsort.Strings(sortedVals)\n\n\t\t\tif sortedVals[0] == gotValue {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\treturn false, nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := true\n\t\t\tfor _, cmp := range comparisons {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif !pass {\n\t\t\t\t\tvalPassed = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, Value{Value: reflect.ValueOf(valPassed)})\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_less_than_test.go",
          "type": "blob",
          "size": 0.529296875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLessThanFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"lessThan()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"lessThan\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Less Than\",\n\t\tselectTest(\n\t\t\t\"nums.all().lessThan(.,5)\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"nums\": []any{\n\t\t\t\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_map_of.go",
          "type": "blob",
          "size": 1.3046875,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar MapOfFunc = BasicFunction{\n\tname: \"mapOf\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"mapOf\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := requireModulusXArgs(\"mapOf\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\ttype pair struct {\n\t\t\tkey      string\n\t\t\tselector string\n\t\t}\n\n\t\tpairs := make([]pair, 0)\n\n\t\tcurrentPair := pair{}\n\n\t\tfor i, v := range args {\n\t\t\tswitch i % 2 {\n\t\t\tcase 0:\n\t\t\t\tcurrentPair.key = v\n\t\t\tcase 1:\n\t\t\t\tcurrentPair.selector = v\n\t\t\t\tpairs = append(pairs, currentPair)\n\t\t\t\tcurrentPair = pair{}\n\t\t\t}\n\t\t}\n\n\t\tgetValue := func(value Value, p pair) (Value, error) {\n\t\t\tgotValues, err := c.subSelect(value, p.selector)\n\t\t\tif err != nil {\n\t\t\t\treturn Value{}, err\n\t\t\t}\n\n\t\t\tif len(gotValues) != 1 {\n\t\t\t\treturn Value{}, fmt.Errorf(\"mapOf expects selector to return exactly 1 value\")\n\t\t\t}\n\n\t\t\treturn gotValues[0], nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tresult := reflect.MakeMap(mapStringInterfaceType)\n\n\t\t\tfor _, p := range pairs {\n\t\t\t\tgotValue, err := getValue(val, p)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tresult.SetMapIndex(reflect.ValueOf(p.key), gotValue.Value)\n\t\t\t}\n\n\t\t\tres = append(res, ValueOf(result))\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_map_of_test.go",
          "type": "blob",
          "size": 0.5546875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMapOfFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"mapOf()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"mapOf\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Single Equal\",\n\t\tselectTest(\n\t\t\t\"mapOf(firstName,name.first,lastName,name.last)\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"firstName\": \"Tom\",\n\t\t\t\t\t\"lastName\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_merge.go",
          "type": "blob",
          "size": 1.0244140625,
          "content": "package dasel\n\nimport \"reflect\"\n\nvar MergeFunc = BasicFunction{\n\tname: \"merge\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tif len(args) == 0 {\n\t\t\t// Merge all inputs into a slice.\n\t\t\tresSlice := reflect.MakeSlice(sliceInterfaceType, len(input), len(input))\n\t\t\tfor i, val := range input {\n\t\t\t\tresSlice.Index(i).Set(val.Value)\n\t\t\t}\n\t\t\tresPointer := reflect.New(resSlice.Type())\n\t\t\tresPointer.Elem().Set(resSlice)\n\n\t\t\tres = append(res, ValueOf(resPointer))\n\t\t\treturn res, nil\n\t\t}\n\n\t\t// Merge all inputs into a slice.\n\t\tresSlice := reflect.MakeSlice(sliceInterfaceType, 0, 0)\n\t\tfor _, val := range input {\n\t\t\tfor _, a := range args {\n\t\t\t\tgotValues, err := c.subSelect(val, a)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tfor _, gotVal := range gotValues {\n\t\t\t\t\tresSlice = reflect.Append(resSlice, gotVal.Value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresPointer := reflect.New(resSlice.Type())\n\t\tresPointer.Elem().Set(resSlice)\n\n\t\tres = append(res, ValueOf(resPointer))\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_merge_test.go",
          "type": "blob",
          "size": 1.35546875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMergeFunc(t *testing.T) {\n\n\tt.Run(\n\t\t\"MergeWithArgs\",\n\t\tselectTest(\n\t\t\t\"merge(name.first,firstNames.all())\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t\t\"firstNames\": []interface{}{\n\t\t\t\t\t\"Jim\",\n\t\t\t\t\t\"Bob\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t[]interface{}{\n\t\t\t\t\t\"Tom\",\n\t\t\t\t\t\"Jim\",\n\t\t\t\t\t\"Bob\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"MergeWithArgsAll\",\n\t\tselectTest(\n\t\t\t\"merge(name.first,firstNames.all()).all()\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t\t\"firstNames\": []interface{}{\n\t\t\t\t\t\"Jim\",\n\t\t\t\t\t\"Bob\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t\t\"Jim\",\n\t\t\t\t\"Bob\",\n\t\t\t},\n\t\t),\n\t)\n\n\t// Flaky test due to ordering.\n\t// t.Run(\n\t// \t\"MergeNoArgs\",\n\t// \tselectTest(\n\t// \t\t\"name.all().merge()\",\n\t// \t\tmap[string]interface{}{\n\t// \t\t\t\"name\": map[string]interface{}{\n\t// \t\t\t\t\"first\": \"Tom\",\n\t// \t\t\t\t\"last\":  \"Wright\",\n\t// \t\t\t},\n\t// \t\t},\n\t// \t\t[]interface{}{\n\t// \t\t\t[]interface{}{\n\t// \t\t\t\t\"Tom\",\n\t// \t\t\t\t\"Wright\",\n\t// \t\t\t},\n\t// \t\t},\n\t// \t),\n\t// )\n\n\tt.Run(\n\t\t\"MergeNoArgsAll\",\n\t\tselectTest(\n\t\t\t\"name.all().merge().all()\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t\t\"Wright\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_metadata.go",
          "type": "blob",
          "size": 0.404296875,
          "content": "package dasel\n\nvar MetadataFunc = BasicFunction{\n\tname: \"metadata\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"metadata\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tfor _, a := range args {\n\t\t\t\tres = append(res, ValueOf(val.Metadata(a)))\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_metadata_test.go",
          "type": "blob",
          "size": 0.2353515625,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMetadataFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"metadata()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"metadata\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n}\n"
        },
        {
          "name": "func_more_than.go",
          "type": "blob",
          "size": 1.6669921875,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"github.com/tomwright/dasel/v2/util\"\n\t\"reflect\"\n\t\"sort\"\n)\n\nvar MoreThanFunc = BasicFunction{\n\tname: \"moreThan\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireExactlyXArgs(\"moreThan\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\ttype comparison struct {\n\t\t\tselector string\n\t\t\tvalue    string\n\t\t}\n\n\t\tcomparisons := make([]comparison, 0)\n\n\t\tcurrentComparison := comparison{}\n\n\t\tfor i, v := range args {\n\t\t\tswitch i % 2 {\n\t\t\tcase 0:\n\t\t\t\tcurrentComparison.selector = v\n\t\t\tcase 1:\n\t\t\t\tcurrentComparison.value = v\n\t\t\t\tcomparisons = append(comparisons, currentComparison)\n\t\t\t\tcurrentComparison = comparison{}\n\t\t\t}\n\t\t}\n\n\t\trunComparison := func(value Value, cmp comparison) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, cmp.selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"equal expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tgotValue := util.ToString(gotValues[0].Interface())\n\n\t\t\t// The values are equal\n\t\t\tif gotValue == cmp.value {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tsortedVals := []string{gotValue, cmp.value}\n\t\t\tsort.Strings(sortedVals)\n\n\t\t\tif sortedVals[0] == cmp.value {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\treturn false, nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := true\n\t\t\tfor _, cmp := range comparisons {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif !pass {\n\t\t\t\t\tvalPassed = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, Value{Value: reflect.ValueOf(valPassed)})\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_more_than_test.go",
          "type": "blob",
          "size": 0.5302734375,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMoreThanFunc(t *testing.T) {\n\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"moreThan()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"moreThan\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"More Than\",\n\t\tselectTest(\n\t\t\t\"nums.all().moreThan(.,5)\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"nums\": []any{\n\t\t\t\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_not.go",
          "type": "blob",
          "size": 0.912109375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar NotFunc = BasicFunction{\n\tname: \"not\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"not\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\trunComparison := func(value Value, selector string) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"not expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\treturn IsTruthy(gotValues[0].Interface()), nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tfor _, selector := range args {\n\t\t\t\ttruthy, err := runComparison(val, selector)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tres = append(res, Value{Value: reflect.ValueOf(!truthy)})\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_not_test.go",
          "type": "blob",
          "size": 0.7451171875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNotFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"not()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"not\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"Single Equal\",\n\t\tselectTest(\n\t\t\t\"name.all().not(equal(key(),first))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Not Banned\",\n\t\tselectTest(\n\t\t\t\"all().filter(not(equal(banned,true))).name\",\n\t\t\t[]map[string]interface{}{\n\t\t\t\t{\n\t\t\t\t\t\"name\":   \"Tom\",\n\t\t\t\t\t\"banned\": true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\":   \"Jess\",\n\t\t\t\t\t\"banned\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Jess\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_null.go",
          "type": "blob",
          "size": 0.38671875,
          "content": "package dasel\n\nimport (\n\t\"reflect\"\n)\n\nvar NullFunc = BasicFunction{\n\tname: \"null\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"null\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, len(input))\n\n\t\tfor k, _ := range args {\n\t\t\tres[k] = ValueOf(reflect.ValueOf(new(any)).Elem())\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_null_test.go",
          "type": "blob",
          "size": 0.36328125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNullFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"null(1)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"null\",\n\t\t\tArgs:     []string{\"1\"},\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{}\n\n\tt.Run(\n\t\t\"Null\",\n\t\tselectTest(\n\t\t\t\"null()\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\tnil,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_or.go",
          "type": "blob",
          "size": 0.958984375,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar OrFunc = BasicFunction{\n\tname: \"or\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"or\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\trunComparison := func(value Value, selector string) (bool, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif len(gotValues) > 1 {\n\t\t\t\treturn false, fmt.Errorf(\"or expects selector to return a single value\")\n\t\t\t}\n\n\t\t\tif len(gotValues) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\treturn IsTruthy(gotValues[0]), nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tvalPassed := false\n\t\t\tfor _, cmp := range args {\n\t\t\t\tpass, err := runComparison(val, cmp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif pass {\n\t\t\t\t\tvalPassed = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, Value{Value: reflect.ValueOf(valPassed)})\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_or_default.go",
          "type": "blob",
          "size": 1.5,
          "content": "package dasel\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar OrDefaultFunc = BasicFunction{\n\tname: \"orDefault\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireExactlyXArgs(\"orDefault\", args, 2); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tif c.CreateWhenMissing() {\n\t\t\tinput = input.initEmptydencodingMaps()\n\t\t}\n\n\t\trunSubselect := func(value Value, selector string, defaultSelector string) (Value, error) {\n\t\t\tgotValues, err := c.subSelect(value, selector)\n\t\t\tnotFound := false\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, &ErrPropertyNotFound{}) {\n\t\t\t\t\tnotFound = true\n\t\t\t\t} else if errors.Is(err, &ErrIndexNotFound{Index: -1}) {\n\t\t\t\t\tnotFound = true\n\t\t\t\t} else {\n\t\t\t\t\treturn Value{}, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !notFound {\n\t\t\t\t// Check result of first query\n\t\t\t\tif len(gotValues) != 1 {\n\t\t\t\t\treturn Value{}, fmt.Errorf(\"orDefault expects selector to return exactly 1 value\")\n\t\t\t\t}\n\n\t\t\t\t// Consider nil values as not found\n\t\t\t\tif gotValues[0].IsNil() {\n\t\t\t\t\tnotFound = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif notFound {\n\t\t\t\tgotValues, err = c.subSelect(value, defaultSelector)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn Value{}, err\n\t\t\t\t}\n\t\t\t\tif len(gotValues) != 1 {\n\t\t\t\t\treturn Value{}, fmt.Errorf(\"orDefault expects selector to return exactly 1 value\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn gotValues[0], nil\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tresolvedValue, err := runSubselect(val, args[0], args[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tres = append(res, resolvedValue)\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_or_default_test.go",
          "type": "blob",
          "size": 1.33203125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestOrDefaultFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"orDefault()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"orDefault\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\"OriginalAndDefaultNotFoundProperty\", selectTestErr(\n\t\t\"orDefault(a,b)\",\n\t\tmap[string]interface{}{\"x\": \"y\"},\n\t\t&ErrPropertyNotFound{\n\t\t\tProperty: \"b\",\n\t\t}),\n\t)\n\n\tt.Run(\"OriginalAndDefaultNotFoundIndex\", selectTestErr(\n\t\t\"orDefault(x.[1],x.[2])\",\n\t\tmap[string]interface{}{\"x\": []int{1}},\n\t\t&ErrIndexNotFound{\n\t\t\tIndex: 2,\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{\n\t\t\"name\": map[string]interface{}{\n\t\t\t\"first\": \"Tom\",\n\t\t\t\"last\":  \"Wright\",\n\t\t},\n\t\t\"colours\": []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t},\n\t}\n\n\tt.Run(\n\t\t\"FirstNameOrLastName\",\n\t\tselectTest(\n\t\t\t\"orDefault(name.first,name.last)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"MiddleNameOrDefault\",\n\t\tselectTest(\n\t\t\t\"orDefault(name.middle,string(default))\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"default\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"FirstColourOrSecondColour\",\n\t\tselectTest(\n\t\t\t\"orDefault(colours.[0],colours.[2])\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"red\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"FourthColourOrDefault\",\n\t\tselectTest(\n\t\t\t\"orDefault(colours.[3],string(default))\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"default\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_or_test.go",
          "type": "blob",
          "size": 0.775390625,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestOrFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"or()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"or\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"NoneEqualMoreThan\",\n\t\tselectTest(\n\t\t\t\"numbers.all().or(equal(.,2),moreThan(.,2))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"numbers\": []interface{}{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse, false, true, true, true, true, true, true, true, true,\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"SomeEqualMoreThan\",\n\t\tselectTest(\n\t\t\t\"numbers.all().or(equal(.,0),moreThan(.,2))\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"numbers\": []interface{}{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\ttrue, false, false, true, true, true, true, true, true, true,\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_parent.go",
          "type": "blob",
          "size": 0.8740234375,
          "content": "package dasel\n\nimport (\n\t\"strconv\"\n)\n\nvar ParentFunc = BasicFunction{\n\tname: \"parent\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrLessArgs(\"parent\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlevels := 1\n\t\tif len(args) > 0 {\n\t\t\targ, err := strconv.Atoi(args[0])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlevels = arg\n\t\t}\n\t\tif levels < 1 {\n\t\t\tlevels = 1\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tgetParent := func(v Value, levels int) (Value, bool) {\n\t\t\tres := v\n\t\t\tfor i := 0; i < levels; i++ {\n\t\t\t\tp := res.Metadata(\"parent\")\n\t\t\t\tif p == nil {\n\t\t\t\t\treturn res, false\n\t\t\t\t}\n\t\t\t\tif pv, ok := p.(Value); ok {\n\t\t\t\t\tres = pv\n\t\t\t\t} else {\n\t\t\t\t\treturn res, false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res, true\n\t\t}\n\n\t\tfor _, i := range input {\n\t\t\tif pv, ok := getParent(i, levels); ok {\n\t\t\t\tres = append(res, pv)\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_parent_test.go",
          "type": "blob",
          "size": 1.5927734375,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParentFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"parent(x,x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"parent\",\n\t\t\tArgs:     []string{\"x\", \"x\"},\n\t\t}),\n\t)\n\n\tt.Run(\n\t\t\"SimpleParent\",\n\t\tselectTest(\n\t\t\t\"name.first.parent()\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"SimpleParent2Levels\",\n\t\tselectTest(\n\t\t\t\"user.name.first.parent(2).deleted\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"user\": map[string]interface{}{\n\t\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t\t},\n\t\t\t\t\t\"deleted\": false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tfalse,\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"MultiParent\",\n\t\tselectTest(\n\t\t\t\"name.all().parent()\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"FilteredParent\",\n\t\tselectTest(\n\t\t\t\"all().flags.filter(equal(banned,false)).parent().name\",\n\t\t\t[]map[string]interface{}{\n\t\t\t\t{\n\t\t\t\t\t\"flags\": map[string]interface{}{\n\t\t\t\t\t\t\"banned\": false,\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"Tom\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"flags\": map[string]interface{}{\n\t\t\t\t\t\t\"banned\": true,\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"Jim\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_property.go",
          "type": "blob",
          "size": 2.1875,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype ErrPropertyNotFound struct {\n\tProperty string\n}\n\nfunc (e ErrPropertyNotFound) Error() string {\n\treturn fmt.Sprintf(\"property not found: %s\", e.Property)\n}\n\nfunc (e ErrPropertyNotFound) Is(other error) bool {\n\to, ok := other.(*ErrPropertyNotFound)\n\tif !ok {\n\t\treturn false\n\t}\n\tif o.Property != \"\" && o.Property != e.Property {\n\t\treturn false\n\t}\n\treturn true\n}\n\nvar PropertyFunc = BasicFunction{\n\tname: \"property\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireXOrMoreArgs(\"property\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tif c.CreateWhenMissing() {\n\t\t\tinput = input.initEmptydencodingMaps()\n\t\t}\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tfor _, property := range args {\n\t\t\t\tisOptional := strings.HasSuffix(property, \"?\")\n\t\t\t\tif isOptional {\n\t\t\t\t\tproperty = strings.TrimSuffix(property, \"?\")\n\t\t\t\t}\n\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Map:\n\t\t\t\t\tindex := val.MapIndex(ValueOf(property))\n\t\t\t\t\tif index.IsEmpty() {\n\t\t\t\t\t\tif isOptional {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !c.CreateWhenMissing() {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"could not access map index: %w\", &ErrPropertyNotFound{Property: property})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = index.asUninitialised()\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, index)\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tvalue := val.FieldByName(property)\n\t\t\t\t\tif value.IsEmpty() {\n\t\t\t\t\t\tif isOptional {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"could not access struct field: %w\", &ErrPropertyNotFound{Property: property})\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, value)\n\t\t\t\tdefault:\n\t\t\t\t\tif val.IsDencodingMap() {\n\t\t\t\t\t\tindex := val.dencodingMapIndex(ValueOf(property))\n\t\t\t\t\t\tif index.IsEmpty() {\n\t\t\t\t\t\t\tif isOptional {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !c.CreateWhenMissing() {\n\t\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"could not access map index: %w\", &ErrPropertyNotFound{Property: property})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex = index.asUninitialised()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = append(res, index)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"cannot use property selector on non map/struct types: %s: %w\", val.Kind().String(), &ErrPropertyNotFound{Property: property})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_property_test.go",
          "type": "blob",
          "size": 1.5263671875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestPropertyFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"property()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"property\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\tt.Run(\"NotFound\", selectTestErr(\n\t\t\"asd\",\n\t\tmap[string]interface{}{\"x\": \"y\"},\n\t\t&ErrPropertyNotFound{\n\t\t\tProperty: \"asd\",\n\t\t}),\n\t)\n\n\tt.Run(\"NotFoundOnString\", selectTestErr(\n\t\t\"x.asd\",\n\t\tmap[string]interface{}{\"x\": \"y\"},\n\t\t&ErrPropertyNotFound{\n\t\t\tProperty: \"asd\",\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{\n\t\t\"name\": map[string]interface{}{\n\t\t\t\"first\": \"Tom\",\n\t\t\t\"last\":  \"Wright\",\n\t\t},\n\t\t\"colours\": []interface{}{\n\t\t\t\"red\", \"green\", \"blue\",\n\t\t},\n\t}\n\n\tt.Run(\n\t\t\"SingleLevelProperty\",\n\t\tselectTest(\n\t\t\t\"name\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"SingleLevelPropertyFunc\",\n\t\tselectTest(\n\t\t\t\"property(name)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"NestedPropertyFunc\",\n\t\tselectTest(\n\t\t\t\"property(name).property(first)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"NestedMultiPropertyFunc\",\n\t\tselectTest(\n\t\t\t\"property(name).property(first,last)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t\t\"Wright\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"NestedMultiMissingPropertyFunc\",\n\t\tselectTest(\n\t\t\t\"property(name).property(first,last,middle?)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t\t\"Wright\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_string.go",
          "type": "blob",
          "size": 0.4072265625,
          "content": "package dasel\n\nimport \"github.com/tomwright/dasel/v2/util\"\n\nvar StringFunc = BasicFunction{\n\tname: \"string\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireExactlyXArgs(\"string\", args, 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, len(input))\n\n\t\tfor k, v := range args {\n\t\t\tres[k] = ValueOf(util.ToString(v))\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_string_test.go",
          "type": "blob",
          "size": 0.4736328125,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStringFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"string()\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"string\",\n\t\t\tArgs:     []string{},\n\t\t}),\n\t)\n\n\toriginal := map[string]interface{}{}\n\n\tt.Run(\n\t\t\"String\",\n\t\tselectTest(\n\t\t\t\"string(x)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\"x\",\n\t\t\t},\n\t\t),\n\t)\n\n\tt.Run(\n\t\t\"Comma\",\n\t\tselectTest(\n\t\t\t\"string(\\\\,)\",\n\t\t\toriginal,\n\t\t\t[]interface{}{\n\t\t\t\t\",\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_this.go",
          "type": "blob",
          "size": 0.2294921875,
          "content": "package dasel\n\nvar ThisFunc = BasicFunction{\n\tname: \"this\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"this\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn s.inputs(), nil\n\t},\n}\n"
        },
        {
          "name": "func_this_test.go",
          "type": "blob",
          "size": 0.669921875,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestThisFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"this(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"this\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\tt.Run(\n\t\t\"SimpleThis\",\n\t\tselectTest(\n\t\t\t\"name.this().first\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"BlankSelectorThis\",\n\t\tselectTest(\n\t\t\t\".name.first\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": map[string]interface{}{\n\t\t\t\t\t\"first\": \"Tom\",\n\t\t\t\t\t\"last\":  \"Wright\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t[]interface{}{\n\t\t\t\t\"Tom\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "func_type.go",
          "type": "blob",
          "size": 0.9541015625,
          "content": "package dasel\n\nimport \"reflect\"\n\nvar TypeFunc = BasicFunction{\n\tname: \"type\",\n\trunFn: func(c *Context, s *Step, args []string) (Values, error) {\n\t\tif err := requireNoArgs(\"type\", args); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinput := s.inputs()\n\n\t\tres := make(Values, 0)\n\n\t\tfor _, val := range input {\n\t\t\tresStr := \"unknown\"\n\n\t\t\tif val.IsNil() {\n\t\t\t\tresStr = \"null\"\n\t\t\t} else if val.IsDencodingMap() {\n\t\t\t\tresStr = \"object\"\n\t\t\t} else {\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\tresStr = \"array\"\n\t\t\t\tcase reflect.Map, reflect.Struct:\n\t\t\t\t\tresStr = \"object\"\n\t\t\t\tcase reflect.String:\n\t\t\t\t\tresStr = \"string\"\n\t\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\t\treflect.Float32, reflect.Float64:\n\t\t\t\t\tresStr = \"number\"\n\t\t\t\tcase reflect.Bool:\n\t\t\t\t\tresStr = \"bool\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = append(res, ValueOf(resStr))\n\t\t}\n\n\t\treturn res, nil\n\t},\n}\n"
        },
        {
          "name": "func_type_test.go",
          "type": "blob",
          "size": 1.1650390625,
          "content": "package dasel\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeFunc(t *testing.T) {\n\tt.Run(\"Args\", selectTestErr(\n\t\t\"type(x)\",\n\t\tmap[string]interface{}{},\n\t\t&ErrUnexpectedFunctionArgs{\n\t\t\tFunction: \"type\",\n\t\t\tArgs:     []string{\"x\"},\n\t\t}),\n\t)\n\n\tdata := map[string]interface{}{\n\t\t\"string\": \"hello\",\n\t\t\"slice\": []interface{}{\n\t\t\t1, 2, 3,\n\t\t},\n\t\t\"map\": map[string]interface{}{\n\t\t\t\"x\": 1,\n\t\t},\n\t\t\"int\":   int(1),\n\t\t\"float\": float32(1),\n\t\t\"bool\":  true,\n\t\t\"null\":  nil,\n\t}\n\n\tt.Run(\n\t\t\"String\",\n\t\tselectTest(\n\t\t\t\"string.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"string\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"Slice\",\n\t\tselectTest(\n\t\t\t\"slice.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"array\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"map\",\n\t\tselectTest(\n\t\t\t\"map.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"object\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"int\",\n\t\tselectTest(\n\t\t\t\"int.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"number\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"float\",\n\t\tselectTest(\n\t\t\t\"float.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"number\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"bool\",\n\t\tselectTest(\n\t\t\t\"bool.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"bool\",\n\t\t\t},\n\t\t),\n\t)\n\tt.Run(\n\t\t\"null\",\n\t\tselectTest(\n\t\t\t\"null.type()\",\n\t\t\tdata,\n\t\t\t[]interface{}{\n\t\t\t\t\"null\",\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5849609375,
          "content": "module github.com/tomwright/dasel/v2\n\ngo 1.21\n\nrequire (\n\tgithub.com/alecthomas/chroma/v2 v2.14.0\n\tgithub.com/clbanning/mxj/v2 v2.7.0\n\tgithub.com/pelletier/go-toml/v2 v2.2.2\n\tgithub.com/spf13/cobra v1.8.1\n\tgolang.org/x/net v0.30.0\n\tgolang.org/x/text v0.19.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.4 // indirect\n\tgithub.com/dlclark/regexp2 v1.11.0 // indirect\n\tgithub.com/google/go-cmp v0.5.9 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/spf13/pflag v1.0.5 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.193359375,
          "content": "github.com/alecthomas/assert/v2 v2.7.0 h1:QtqSACNS3tF7oasA8CU6A6sXZSBDqnm7RfpLl9bZqbE=\ngithub.com/alecthomas/assert/v2 v2.7.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=\ngithub.com/alecthomas/chroma/v2 v2.14.0 h1:R3+wzpnUArGcQz7fCETQBzO5n9IMNi13iIs46aU4V9E=\ngithub.com/alecthomas/chroma/v2 v2.14.0/go.mod h1:QolEbTfmUHIMVpBqxeDnNBj2uoeI4EbYP4i6n68SG4I=\ngithub.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=\ngithub.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=\ngithub.com/clbanning/mxj/v2 v2.7.0 h1:WA/La7UGCanFe5NpHF0Q3DNtnCsVoxbPKuyBNHWRyME=\ngithub.com/clbanning/mxj/v2 v2.7.0/go.mod h1:hNiWqW14h+kc+MdF9C6/YoRfjEJoR3ou6tn/Qo+ve2s=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dlclark/regexp2 v1.11.0 h1:G/nrcoOa7ZXlpoa/91N3X7mM3r8eIlMBBJZvsz/mxKI=\ngithub.com/dlclark/regexp2 v1.11.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=\ngithub.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=\ngithub.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.org/x/net v0.30.0 h1:AcW1SDZMkb8IpzCdQUaIq2sP4sZ4zw+55h6ynffypl4=\ngolang.org/x/net v0.30.0/go.mod h1:2wGyMJ5iFasEhkwi13ChkO/t1ECNC4X4eBKkVFyYFlU=\ngolang.org/x/text v0.19.0 h1:kTxAhCbGbxhK0IwgSKiMO5awPoDQ0RpfiVYBfK860YM=\ngolang.org/x/text v0.19.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "selector.go",
          "type": "blob",
          "size": 4.5439453125,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype ErrBadSelectorSyntax struct {\n\tPart    string\n\tMessage string\n}\n\nfunc (e ErrBadSelectorSyntax) Error() string {\n\treturn fmt.Sprintf(\"bad syntax: %s, around %s\", e.Message, e.Part)\n}\n\nfunc (e ErrBadSelectorSyntax) Is(other error) bool {\n\to, ok := other.(*ErrBadSelectorSyntax)\n\tif !ok {\n\t\treturn false\n\t}\n\tif o.Part != \"\" && o.Part != e.Part {\n\t\treturn false\n\t}\n\tif o.Message != \"\" && o.Message != e.Message {\n\t\treturn false\n\t}\n\treturn true\n}\n\ntype Selector struct {\n\tfuncName string\n\tfuncArgs []string\n}\n\ntype SelectorResolver interface {\n\tOriginal() string\n\tNext() (*Selector, error)\n}\n\nfunc NewSelectorResolver(selector string, functions *FunctionCollection) SelectorResolver {\n\treturn &standardSelectorResolver{\n\t\tfunctions:    functions,\n\t\toriginal:     selector,\n\t\treader:       strings.NewReader(selector),\n\t\tseparator:    '.',\n\t\topenFunc:     '(',\n\t\tcloseFunc:    ')',\n\t\targSeparator: ',',\n\t\tescapeChar:   '\\\\',\n\t}\n}\n\ntype standardSelectorResolver struct {\n\tfunctions    *FunctionCollection\n\toriginal     string\n\treader       *strings.Reader\n\tseparator    rune\n\topenFunc     rune\n\tcloseFunc    rune\n\targSeparator rune\n\tescapeChar   rune\n}\n\nfunc (r *standardSelectorResolver) Original() string {\n\treturn r.original\n}\n\n// nextPart returns the next part.\n// It returns true if there are more parts to the selector, or false if we reached the end.\nfunc (r *standardSelectorResolver) nextPart() (string, bool) {\n\tb := &strings.Builder{}\n\tbracketDepth := 0\n\tescaped := false\n\tfor {\n\t\treadRune, _, err := r.reader.ReadRune()\n\t\tif err == io.EOF {\n\t\t\treturn b.String(), false\n\t\t}\n\t\tif escaped {\n\t\t\tb.WriteRune(readRune)\n\t\t\tescaped = false\n\t\t\tcontinue\n\t\t} else if readRune == r.escapeChar {\n\t\t\tb.WriteRune(readRune)\n\t\t\tescaped = true\n\t\t\tcontinue\n\t\t} else if readRune == r.openFunc {\n\t\t\tbracketDepth++\n\t\t} else if readRune == r.closeFunc {\n\t\t\tbracketDepth--\n\t\t}\n\t\tif readRune == r.separator && bracketDepth == 0 {\n\t\t\treturn b.String(), true\n\t\t}\n\t\tb.WriteRune(readRune)\n\t}\n}\n\nfunc (r *standardSelectorResolver) Next() (*Selector, error) {\n\tnextPart, moreParts := r.nextPart()\n\tif nextPart == \"\" && !moreParts {\n\t\treturn nil, nil\n\t}\n\tif nextPart == \"\" && moreParts {\n\t\treturn &Selector{\n\t\t\tfuncName: \"this\",\n\t\t\tfuncArgs: []string{},\n\t\t}, nil\n\t}\n\n\tif r.functions != nil {\n\t\tif s := r.functions.ParseSelector(nextPart); s != nil {\n\t\t\treturn s, nil\n\t\t}\n\t}\n\n\tvar hasOpenedFunc, hasClosedFunc = false, false\n\tbracketDepth := 0\n\n\tvar funcNameBuilder = &strings.Builder{}\n\tvar argBuilder = &strings.Builder{}\n\n\tnextPartReader := strings.NewReader(nextPart)\n\n\tfuncName := \"\"\n\targs := make([]string, 0)\n\n\tescaped := false\n\tfor {\n\t\tnextRune, _, err := nextPartReader.ReadRune()\n\t\tif err == io.EOF {\n\t\t\tif funcNameBuilder.Len() > 0 {\n\t\t\t\tfuncName = funcNameBuilder.String()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not read selector: %w\", err)\n\t\t}\n\n\t\tswitch {\n\t\tcase nextRune == r.escapeChar && !escaped:\n\t\t\tescaped = true\n\t\t\tcontinue\n\n\t\tcase nextRune == r.openFunc && !escaped:\n\t\t\tif !hasOpenedFunc {\n\t\t\t\thasOpenedFunc = true\n\t\t\t\tfuncName = funcNameBuilder.String()\n\t\t\t\tif funcName == \"\" {\n\t\t\t\t\treturn nil, &ErrBadSelectorSyntax{\n\t\t\t\t\t\tPart:    nextPart,\n\t\t\t\t\t\tMessage: \"function name required before open bracket\",\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targBuilder.WriteRune(nextRune)\n\t\t\t}\n\t\t\tbracketDepth++\n\n\t\tcase nextRune == r.closeFunc && !escaped:\n\t\t\tif bracketDepth > 1 {\n\t\t\t\targBuilder.WriteRune(nextRune)\n\t\t\t} else if bracketDepth == 1 {\n\t\t\t\thasClosedFunc = true\n\t\t\t\targ := argBuilder.String()\n\t\t\t\tif arg != \"\" {\n\t\t\t\t\targs = append(args, argBuilder.String())\n\t\t\t\t}\n\t\t\t} else if bracketDepth < 1 {\n\t\t\t\treturn nil, &ErrBadSelectorSyntax{\n\t\t\t\t\tPart:    nextPart,\n\t\t\t\t\tMessage: \"too many closing brackets\",\n\t\t\t\t}\n\t\t\t}\n\t\t\tbracketDepth--\n\n\t\tcase hasOpenedFunc && nextRune == r.argSeparator && !escaped:\n\t\t\tif bracketDepth > 1 {\n\t\t\t\targBuilder.WriteRune(nextRune)\n\t\t\t} else if bracketDepth == 1 {\n\t\t\t\targ := argBuilder.String()\n\t\t\t\targBuilder.Reset()\n\t\t\t\tif arg != \"\" {\n\t\t\t\t\targs = append(args, arg)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase hasOpenedFunc:\n\t\t\tif escaped {\n\t\t\t\tescaped = false\n\t\t\t}\n\t\t\targBuilder.WriteRune(nextRune)\n\n\t\tcase hasClosedFunc:\n\t\t\t// Do not allow anything after the closeFunc\n\t\t\treturn nil, &ErrBadSelectorSyntax{\n\t\t\t\tPart:    nextPart,\n\t\t\t\tMessage: \"selector function must end after closing bracket\",\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif escaped {\n\t\t\t\tescaped = false\n\t\t\t}\n\t\t\tfuncNameBuilder.WriteRune(nextRune)\n\t\t}\n\t}\n\n\tif !hasOpenedFunc {\n\t\treturn &Selector{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{funcName},\n\t\t}, nil\n\t}\n\n\treturn &Selector{\n\t\tfuncName: funcName,\n\t\tfuncArgs: args,\n\t}, nil\n\n}\n"
        },
        {
          "name": "selector_test.go",
          "type": "blob",
          "size": 2.8330078125,
          "content": "package dasel\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc collectAll(r SelectorResolver) ([]Selector, error) {\n\tres := make([]Selector, 0)\n\n\tfor {\n\t\ts, err := r.Next()\n\t\tif err != nil {\n\t\t\treturn res, err\n\t\t}\n\t\tif s == nil {\n\t\t\tbreak\n\t\t}\n\t\tres = append(res, *s)\n\t}\n\n\treturn res, nil\n}\n\nfunc TestStandardSelectorResolver_Next(t *testing.T) {\n\tr := NewSelectorResolver(\"index(1).property(user).name.property(first,last?)\", nil)\n\n\tgot, err := collectAll(r)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\texp := []Selector{\n\t\t{\n\t\t\tfuncName: \"index\",\n\t\t\tfuncArgs: []string{\"1\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"user\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"name\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"first\", \"last?\"},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(exp, got) {\n\t\tt.Errorf(\"exp: %v, got: %v\", exp, got)\n\t}\n}\n\nfunc TestStandardSelectorResolver_Next_Nested(t *testing.T) {\n\tr := NewSelectorResolver(\"nested(a().b(),c(),d()).nested(a().b(),c(),d())\", nil)\n\n\tgot, err := collectAll(r)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\texp := []Selector{\n\t\t{\n\t\t\tfuncName: \"nested\",\n\t\t\tfuncArgs: []string{\"a().b()\", \"c()\", \"d()\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"nested\",\n\t\t\tfuncArgs: []string{\"a().b()\", \"c()\", \"d()\"},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(exp, got) {\n\t\tt.Errorf(\"exp: %v, got: %v\", exp, got)\n\t}\n}\n\nfunc TestStandardSelectorResolver_Next_ExtraClosingBracket(t *testing.T) {\n\tr := NewSelectorResolver(\"all().filter(not(equal(x,true))))\", nil)\n\n\texpErr := &ErrBadSelectorSyntax{\n\t\tPart:    \"filter(not(equal(x,true))))\",\n\t\tMessage: \"too many closing brackets\",\n\t}\n\n\t_, err := collectAll(r)\n\n\tif !errors.Is(err, expErr) {\n\t\tt.Errorf(\"expected error: %v, got %v\", expErr, err)\n\t\treturn\n\t}\n}\n\nfunc TestStandardSelectorResolver_Next_EscapedDot(t *testing.T) {\n\tr := NewSelectorResolver(\"plugins.io\\\\.containerd\\\\.grpc\\\\.v1\\\\.cri.registry\", nil)\n\n\tgot, err := collectAll(r)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\texp := []Selector{\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"plugins\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"io.containerd.grpc.v1.cri\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"registry\"},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(exp, got) {\n\t\tt.Errorf(\"exp: %v, got: %v\", exp, got)\n\t}\n}\n\nfunc TestStandardSelectorResolver_Next_EscapedEverything(t *testing.T) {\n\tr := NewSelectorResolver(\"a.b\\\\(\\\\.asdw\\\\\\\\\\\\].c(\\\\))\", nil)\n\n\tgot, err := collectAll(r)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\texp := []Selector{\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"a\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"property\",\n\t\t\tfuncArgs: []string{\"b(.asdw\\\\]\"},\n\t\t},\n\t\t{\n\t\t\tfuncName: \"c\",\n\t\t\tfuncArgs: []string{\")\"},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(exp, got) {\n\t\tt.Errorf(\"exp: %v, got: %v\", exp, got)\n\t}\n}\n"
        },
        {
          "name": "step.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "package dasel\n\n// Step is a single step in the query.\n// Each function call has its own step.\n// Each value in the output is simply a pointer to the actual data point in the context data.\ntype Step struct {\n\tcontext  *Context\n\tselector Selector\n\tindex    int\n\toutput   Values\n}\n\nfunc (s *Step) Selector() Selector {\n\treturn s.selector\n}\n\nfunc (s *Step) Index() int {\n\treturn s.index\n}\n\nfunc (s *Step) Output() Values {\n\treturn s.output\n}\n\nfunc (s *Step) execute() error {\n\tf, err := s.context.functions.Get(s.selector.funcName)\n\tif err != nil {\n\t\treturn err\n\t}\n\toutput, err := f(s.context, s, s.selector.funcArgs)\n\ts.output = output\n\treturn err\n}\n\nfunc (s *Step) inputs() Values {\n\tprevStep := s.context.Step(s.index - 1)\n\tif prevStep == nil {\n\t\treturn Values{}\n\t}\n\treturn prevStep.output\n}\n"
        },
        {
          "name": "storage",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "truthy.go",
          "type": "blob",
          "size": 0.818359375,
          "content": "package dasel\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc IsTruthy(value interface{}) bool {\n\tswitch v := value.(type) {\n\tcase Value:\n\t\treturn IsTruthy(v.Unpack().Interface())\n\n\tcase reflect.Value:\n\t\treturn IsTruthy(unpackReflectValue(v).Interface())\n\n\tcase bool:\n\t\treturn v\n\n\tcase string:\n\t\tv = strings.ToLower(strings.TrimSpace(v))\n\t\tswitch v {\n\t\tcase \"false\", \"no\", \"0\":\n\t\t\treturn false\n\t\tdefault:\n\t\t\treturn v != \"\"\n\t\t}\n\n\tcase []byte:\n\t\treturn IsTruthy(string(v))\n\n\tcase int:\n\t\treturn v > 0\n\tcase int8:\n\t\treturn v > 0\n\tcase int16:\n\t\treturn v > 0\n\tcase int32:\n\t\treturn v > 0\n\tcase int64:\n\t\treturn v > 0\n\n\tcase uint:\n\t\treturn v > 0\n\tcase uint8:\n\t\treturn v > 0\n\tcase uint16:\n\t\treturn v > 0\n\tcase uint32:\n\t\treturn v > 0\n\tcase uint64:\n\t\treturn v > 0\n\n\tcase float32:\n\t\treturn v >= 1\n\tcase float64:\n\t\treturn v >= 1\n\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "truthy_test.go",
          "type": "blob",
          "size": 2.5205078125,
          "content": "package dasel\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestIsTruthy(t *testing.T) {\n\n\ttype testDef struct {\n\t\tname string\n\t\tin   interface{}\n\t\tout  bool\n\t}\n\n\tbaseData := []testDef{\n\t\t{\"bool:true\", true, true},\n\t\t{\"bool:false\", false, false},\n\t\t{\"string:lowercaseTrue\", \"true\", true},\n\t\t{\"string:lowercaseFalse\", \"false\", false},\n\t\t{\"string:uppercaseTrue\", \"TRUE\", true},\n\t\t{\"string:uppercaseFalse\", \"FALSE\", false},\n\t\t{\"string:lowercaseYes\", \"yes\", true},\n\t\t{\"string:lowercaseNo\", \"no\", false},\n\t\t{\"string:uppercaseYes\", \"YES\", true},\n\t\t{\"string:lowercaseNo\", \"NO\", false},\n\t\t{\"[]byte:lowercaseTrue\", []byte(\"true\"), true},\n\t\t{\"[]byte:lowercaseFalse\", []byte(\"false\"), false},\n\t\t{\"[]byte:uppercaseTrue\", []byte(\"TRUE\"), true},\n\t\t{\"[]byte:uppercaseFalse\", []byte(\"FALSE\"), false},\n\t\t{\"[]byte:lowercaseYes\", []byte(\"yes\"), true},\n\t\t{\"[]byte:lowercaseNo\", []byte(\"no\"), false},\n\t\t{\"[]byte:uppercaseYes\", []byte(\"YES\"), true},\n\t\t{\"[]byte:lowercaseNo\", []byte(\"NO\"), false},\n\t\t{\"int:0\", int(0), false},\n\t\t{\"int8:0\", int8(0), false},\n\t\t{\"int16:0\", int16(0), false},\n\t\t{\"int32:0\", int32(0), false},\n\t\t{\"int64:0\", int64(0), false},\n\t\t{\"int:-1\", int(-1), false},\n\t\t{\"int8:-1\", int8(-1), false},\n\t\t{\"int16:-1\", int16(-1), false},\n\t\t{\"int32:-1\", int32(-1), false},\n\t\t{\"int64:-1\", int64(-1), false},\n\t\t{\"uint:0\", uint(0), false},\n\t\t{\"uint8:0\", uint8(0), false},\n\t\t{\"uint16:0\", uint16(0), false},\n\t\t{\"uint32:0\", uint32(0), false},\n\t\t{\"uint64:0\", uint64(0), false},\n\t\t{\"int:1\", int(1), true},\n\t\t{\"int8:1\", int8(1), true},\n\t\t{\"int16:1\", int16(1), true},\n\t\t{\"int32:1\", int32(1), true},\n\t\t{\"int64:1\", int64(1), true},\n\t\t{\"uint:1\", uint(1), true},\n\t\t{\"uint8:1\", uint8(1), true},\n\t\t{\"uint16:1\", uint16(1), true},\n\t\t{\"uint32:1\", uint32(1), true},\n\t\t{\"uint64:1\", uint64(1), true},\n\t\t{\"float32:0\", float32(0), false},\n\t\t{\"float64:0\", float64(0), false},\n\t\t{\"float32:-1\", float32(-1), false},\n\t\t{\"float64:-1\", float64(-1), false},\n\t\t{\"float32:1\", float32(1), true},\n\t\t{\"float64:1\", float64(1), true},\n\t\t{\"unhandled:[]string\", []string{}, false},\n\t}\n\n\ttestData := make([]testDef, 0)\n\n\tfor _, td := range baseData {\n\t\ttestData = append(\n\t\t\ttestData,\n\t\t\ttd,\n\t\t\ttestDef{\n\t\t\t\tname: fmt.Sprintf(\"reflect.Value:%s\", td.name),\n\t\t\t\tin:   reflect.ValueOf(td.in),\n\t\t\t\tout:  td.out,\n\t\t\t},\n\t\t\ttestDef{\n\t\t\t\tname: fmt.Sprintf(\"dasel.Value:%s\", td.name),\n\t\t\t\tin:   ValueOf(td.in),\n\t\t\t\tout:  td.out,\n\t\t\t},\n\t\t)\n\t}\n\n\tfor _, test := range testData {\n\t\ttc := test\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif exp, got := tc.out, IsTruthy(tc.in); exp != got {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", exp, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 12.56640625,
          "content": "package dasel\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/tomwright/dasel/v2/dencoding\"\n\t\"github.com/tomwright/dasel/v2/util\"\n)\n\n// Value is a wrapper around reflect.Value that adds some handy helper funcs.\ntype Value struct {\n\treflect.Value\n\tsetFn    func(value Value)\n\tdeleteFn func()\n\tmetadata map[string]interface{}\n}\n\n// ValueOf wraps value in a Value.\nfunc ValueOf(value interface{}) Value {\n\tswitch v := value.(type) {\n\tcase Value:\n\t\treturn v\n\tcase reflect.Value:\n\t\treturn Value{\n\t\t\tValue: v,\n\t\t}\n\tdefault:\n\t\treturn Value{\n\t\t\tValue: reflect.ValueOf(value),\n\t\t}\n\t}\n}\n\n// Metadata returns the metadata with a key of key for v.\nfunc (v Value) Metadata(key string) interface{} {\n\tif v.metadata == nil {\n\t\treturn nil\n\t}\n\tif m, ok := v.metadata[key]; ok {\n\t\treturn m\n\t}\n\treturn nil\n}\n\n// WithMetadata sets the given value into the values metadata.\nfunc (v Value) WithMetadata(key string, value interface{}) Value {\n\tif v.metadata == nil {\n\t\tv.metadata = map[string]interface{}{}\n\t}\n\tv.metadata[key] = value\n\treturn v\n}\n\n// Interface returns the interface{} value of v.\nfunc (v Value) Interface() interface{} {\n\treturn v.Unpack().Interface()\n}\n\n// Len returns v's length.\nfunc (v Value) Len() int {\n\tif v.IsDencodingMap() {\n\t\treturn len(v.Interface().(*dencoding.Map).Keys())\n\t}\n\tswitch v.Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Unpack().Len()\n\tcase reflect.Bool:\n\t\tif v.Interface() == true {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tdefault:\n\t\treturn len(util.ToString(v.Interface()))\n\t}\n}\n\n// String returns the string v's underlying value, as a string.\nfunc (v Value) String() string {\n\treturn v.Unpack().String()\n}\n\n// IsEmpty returns true is v represents an empty reflect.Value.\nfunc (v Value) IsEmpty() bool {\n\treturn isEmptyReflectValue(unpackReflectValue(v.Value))\n}\n\nfunc (v Value) IsNil() bool {\n\tswitch v.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:\n\t\treturn v.Value.IsNil()\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isEmptyReflectValue(v reflect.Value) bool {\n\tif (v == reflect.Value{}) {\n\t\treturn true\n\t}\n\treturn v.Kind() == reflect.String && v.Interface() == UninitialisedPlaceholder\n}\n\n// Kind returns the underlying type of v.\nfunc (v Value) Kind() reflect.Kind {\n\treturn v.Unpack().Kind()\n}\n\nfunc containsKind(kinds []reflect.Kind, kind reflect.Kind) bool {\n\tfor _, v := range kinds {\n\t\tif v == kind {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar dencodingMapType = reflect.TypeOf(&dencoding.Map{})\n\nfunc isDencodingMap(value reflect.Value) bool {\n\treturn value.Kind() == reflect.Ptr && value.Type() == dencodingMapType\n}\n\nfunc unpackReflectValue(value reflect.Value, kinds ...reflect.Kind) reflect.Value {\n\tif len(kinds) == 0 {\n\t\tkinds = append(kinds, reflect.Ptr, reflect.Interface)\n\t}\n\tres := value\n\tfor {\n\t\tif isDencodingMap(res) {\n\t\t\treturn res\n\t\t}\n\t\tif !containsKind(kinds, res.Kind()) {\n\t\t\treturn res\n\t\t}\n\t\tif res.IsNil() {\n\t\t\treturn res\n\t\t}\n\t\tres = res.Elem()\n\t}\n}\n\nfunc (v Value) FirstAddressable() reflect.Value {\n\tres := v.Value\n\tfor !res.CanAddr() {\n\t\tres = res.Elem()\n\t}\n\treturn res\n}\n\n// Unpack returns the underlying reflect.Value after resolving any pointers or interface types.\nfunc (v Value) Unpack(kinds ...reflect.Kind) reflect.Value {\n\tif !v.Value.IsValid() {\n\t\treturn reflect.ValueOf(new(any)).Elem()\n\t}\n\treturn unpackReflectValue(v.Value, kinds...)\n}\n\nfunc (v Value) Type() reflect.Type {\n\treturn v.Unpack().Type()\n}\n\n// Set sets underlying value of v.\n// Depends on setFn since the implementation can differ depending on how the Value was initialised.\nfunc (v Value) Set(value Value) {\n\tif v.setFn != nil {\n\t\tv.setFn(value)\n\t\treturn\n\t}\n\tpanic(\"unable to set value with missing setFn\")\n}\n\n// Delete deletes the current element.\n// Depends on deleteFn since the implementation can differ depending on how the Value was initialised.\nfunc (v Value) Delete() {\n\tif v.deleteFn != nil {\n\t\tv.deleteFn()\n\t\treturn\n\t}\n\tpanic(\"unable to delete value with missing deleteFn\")\n}\n\nfunc (v Value) IsDencodingMap() bool {\n\tif v.Kind() != reflect.Ptr {\n\t\treturn false\n\t}\n\t_, ok := v.Interface().(*dencoding.Map)\n\treturn ok\n}\n\nfunc (v Value) dencodingMapIndex(key Value) Value {\n\tgetValueByKey := func() reflect.Value {\n\t\tif !v.IsDencodingMap() {\n\t\t\treturn reflect.Value{}\n\t\t}\n\t\tom := v.Interface().(*dencoding.Map)\n\t\tif v, ok := om.Get(key.Value.String()); !ok {\n\t\t\treturn reflect.Value{}\n\t\t} else {\n\t\t\tif v == nil {\n\t\t\t\treturn reflect.ValueOf(new(any)).Elem()\n\t\t\t}\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t}\n\tindex := Value{\n\t\tValue: getValueByKey(),\n\t\tsetFn: func(value Value) {\n\t\t\t// Note that we do not use Interface() here as it will dereference the received value.\n\t\t\t// Instead, we only dereference the interface type to receive the pointer.\n\t\t\tv.Interface().(*dencoding.Map).Set(key.Value.String(), value.Unpack(reflect.Interface).Interface())\n\t\t},\n\t\tdeleteFn: func() {\n\t\t\tv.Interface().(*dencoding.Map).Delete(key.Value.String())\n\t\t},\n\t}\n\treturn index.\n\t\tWithMetadata(\"key\", key.Interface()).\n\t\tWithMetadata(\"parent\", v)\n}\n\n// MapIndex returns the value associated with key in the map v.\n// It returns the zero Value if no field was found.\nfunc (v Value) MapIndex(key Value) Value {\n\tindex := Value{\n\t\tValue: v.Unpack().MapIndex(key.Value),\n\t\tsetFn: func(value Value) {\n\t\t\tv.Unpack().SetMapIndex(key.Value, value.Value)\n\t\t},\n\t\tdeleteFn: func() {\n\t\t\tv.Unpack().SetMapIndex(key.Value, reflect.Value{})\n\t\t},\n\t}\n\treturn index.\n\t\tWithMetadata(\"key\", key.Interface()).\n\t\tWithMetadata(\"parent\", v)\n}\n\nfunc (v Value) MapKeys() []Value {\n\tres := make([]Value, 0)\n\tfor _, k := range v.Unpack().MapKeys() {\n\t\tres = append(res, Value{Value: k})\n\t}\n\treturn res\n}\n\n// FieldByName returns the struct field with the given name.\n// It returns the zero Value if no field was found.\nfunc (v Value) FieldByName(name string) Value {\n\treturn Value{\n\t\tValue: v.Unpack().FieldByName(name),\n\t\tsetFn: func(value Value) {\n\t\t\tv.Unpack().FieldByName(name).Set(value.Value)\n\t\t},\n\t\tdeleteFn: func() {\n\t\t\tfield := v.Unpack().FieldByName(name)\n\t\t\tfield.Set(reflect.New(field.Type()))\n\t\t},\n\t}.\n\t\tWithMetadata(\"key\", name).\n\t\tWithMetadata(\"parent\", v)\n}\n\n// NumField returns the number of fields in the struct v.\nfunc (v Value) NumField() int {\n\treturn v.Unpack().NumField()\n}\n\n// Index returns v's i'th element.\n// It panics if v's Kind is not Array, Slice, or String or i is out of range.\nfunc (v Value) Index(i int) Value {\n\treturn Value{\n\t\tValue: v.Unpack().Index(i),\n\t\tsetFn: func(value Value) {\n\t\t\tv.Unpack().Index(i).Set(value.Value)\n\t\t},\n\t\tdeleteFn: func() {\n\t\t\tcurrentLen := v.Len()\n\t\t\tupdatedSlice := reflect.MakeSlice(sliceInterfaceType, currentLen-1, v.Len()-1)\n\t\t\t// Rebuild the slice excluding the deleted element\n\t\t\tfor indexToRead := 0; indexToRead < currentLen; indexToRead++ {\n\t\t\t\tindexToWrite := indexToRead\n\t\t\t\tif indexToRead == i {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif indexToRead > i {\n\t\t\t\t\tindexToWrite--\n\t\t\t\t}\n\t\t\t\tupdatedSlice.Index(indexToWrite).Set(\n\t\t\t\t\tv.Index(indexToRead).Value,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tv.Unpack().Set(updatedSlice)\n\t\t},\n\t}.\n\t\tWithMetadata(\"key\", i).\n\t\tWithMetadata(\"parent\", v)\n}\n\n// Append appends an empty value to the end of the slice.\nfunc (v Value) Append() Value {\n\tcurrentLen := v.Len()\n\tnewLen := currentLen + 1\n\n\tupdatedSlice := reflect.MakeSlice(reflect.TypeOf(v.Interface()), newLen, newLen)\n\t// copy all existing elements into updatedSlice.\n\t// this leaves the last element empty.\n\tfor i := 0; i < currentLen; i++ {\n\t\tupdatedSlice.Index(i).Set(\n\t\t\tv.Index(i).Value,\n\t\t)\n\t}\n\n\tfirstAddressable := v.FirstAddressable()\n\tfirstAddressable.Set(updatedSlice)\n\n\t// This code was causing a panic...\n\t// It doesn't seem necessary. Leaving here for reference in-case it was needed.\n\t// See https://github.com/TomWright/dasel/issues/392\n\t// Set the last element to uninitialised.\n\t//updatedSlice.Index(currentLen).Set(\n\t//\tv.Index(currentLen).asUninitialised().Value,\n\t//)\n\n\treturn v\n}\n\nvar sliceInterfaceType = reflect.TypeFor[[]any]()\nvar mapStringInterfaceType = reflect.TypeFor[map[string]interface{}]()\n\nvar UninitialisedPlaceholder interface{} = \"__dasel_not_found__\"\n\nfunc (v Value) asUninitialised() Value {\n\tv.Value = reflect.ValueOf(UninitialisedPlaceholder)\n\treturn v\n}\n\nfunc (v Value) initEmptyMap() Value {\n\temptyMap := reflect.MakeMap(mapStringInterfaceType)\n\tv.Set(Value{Value: emptyMap})\n\tv.Value = emptyMap\n\treturn v\n}\n\nfunc (v Value) initEmptydencodingMap() Value {\n\tom := dencoding.NewMap()\n\trom := reflect.ValueOf(om)\n\tv.Set(Value{Value: rom})\n\tv.Value = rom\n\treturn v\n}\n\nfunc (v Value) initEmptySlice() Value {\n\temptySlice := reflect.MakeSlice(sliceInterfaceType, 0, 0)\n\n\taddressableSlice := reflect.New(emptySlice.Type())\n\taddressableSlice.Elem().Set(emptySlice)\n\n\tv.Set(Value{Value: addressableSlice})\n\tv.Value = addressableSlice\n\treturn v\n}\n\nfunc makeAddressableSlice(value reflect.Value) reflect.Value {\n\tif !unpackReflectValue(value, reflect.Ptr).CanAddr() {\n\t\tunpacked := unpackReflectValue(value)\n\n\t\temptySlice := reflect.MakeSlice(unpacked.Type(), unpacked.Len(), unpacked.Len())\n\n\t\tfor i := 0; i < unpacked.Len(); i++ {\n\t\t\temptySlice.Index(i).Set(makeAddressable(unpacked.Index(i)))\n\t\t}\n\n\t\taddressableSlice := reflect.New(emptySlice.Type())\n\t\taddressableSlice.Elem().Set(emptySlice)\n\n\t\treturn addressableSlice\n\t} else {\n\t\t// Make contained values addressable\n\t\tunpacked := unpackReflectValue(value)\n\t\tfor i := 0; i < unpacked.Len(); i++ {\n\t\t\tunpacked.Index(i).Set(makeAddressable(unpacked.Index(i)))\n\t\t}\n\n\t\treturn value\n\t}\n}\n\nfunc makeAddressableMap(value reflect.Value) reflect.Value {\n\tif !unpackReflectValue(value, reflect.Ptr).CanAddr() {\n\t\tunpacked := unpackReflectValue(value)\n\n\t\temptyMap := reflect.MakeMap(unpacked.Type())\n\n\t\tfor _, key := range unpacked.MapKeys() {\n\t\t\temptyMap.SetMapIndex(key, makeAddressable(unpacked.MapIndex(key)))\n\t\t}\n\n\t\taddressableMap := reflect.New(emptyMap.Type())\n\t\taddressableMap.Elem().Set(emptyMap)\n\n\t\treturn addressableMap\n\t} else {\n\t\t// Make contained values addressable\n\t\tunpacked := unpackReflectValue(value)\n\n\t\tfor _, key := range unpacked.MapKeys() {\n\t\t\tunpacked.SetMapIndex(key, makeAddressable(unpacked.MapIndex(key)))\n\t\t}\n\n\t\treturn value\n\t}\n}\n\nfunc makeAddressable(value reflect.Value) reflect.Value {\n\tunpacked := unpackReflectValue(value)\n\n\tif isDencodingMap(unpacked) {\n\t\tom := value.Interface().(*dencoding.Map)\n\t\tfor _, kv := range om.KeyValues() {\n\t\t\tvar val any\n\t\t\tif v := deref(reflect.ValueOf(kv.Value)); v.IsValid() {\n\t\t\t\tval = makeAddressable(v).Interface()\n\t\t\t} else {\n\t\t\t\tval = nil\n\t\t\t}\n\t\t\tom.Set(kv.Key, val)\n\t\t}\n\t\treturn value\n\t}\n\n\tswitch unpacked.Kind() {\n\tcase reflect.Slice:\n\t\treturn makeAddressableSlice(value)\n\tcase reflect.Map:\n\t\treturn makeAddressableMap(value)\n\tdefault:\n\t\treturn value\n\t}\n}\n\nfunc derefSlice(value reflect.Value) reflect.Value {\n\tunpacked := unpackReflectValue(value)\n\n\tres := reflect.MakeSlice(unpacked.Type(), unpacked.Len(), unpacked.Len())\n\n\tfor i := 0; i < unpacked.Len(); i++ {\n\t\tif v := deref(unpacked.Index(i)); v.IsValid() {\n\t\t\tres.Index(i).Set(v)\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc derefMap(value reflect.Value) reflect.Value {\n\tunpacked := unpackReflectValue(value)\n\n\tres := reflect.MakeMap(unpacked.Type())\n\n\tfor _, key := range unpacked.MapKeys() {\n\t\tif v := deref(unpacked.MapIndex(key)); v.IsValid() {\n\t\t\tres.SetMapIndex(key, v)\n\t\t} else {\n\t\t\tres.SetMapIndex(key, reflect.ValueOf(new(any)))\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc deref(value reflect.Value) reflect.Value {\n\tunpacked := unpackReflectValue(value)\n\n\tif isDencodingMap(unpacked) {\n\t\tom := value.Interface().(*dencoding.Map)\n\t\tfor _, kv := range om.KeyValues() {\n\t\t\tif v := deref(reflect.ValueOf(kv.Value)); v.IsValid() {\n\t\t\t\tom.Set(kv.Key, v.Interface())\n\t\t\t} else {\n\t\t\t\tom.Set(kv.Key, nil)\n\t\t\t}\n\t\t}\n\t\treturn value\n\t}\n\n\tswitch unpacked.Kind() {\n\tcase reflect.Slice:\n\t\treturn derefSlice(value)\n\tcase reflect.Map:\n\t\treturn derefMap(value)\n\tdefault:\n\t\treturn unpackReflectValue(value)\n\t}\n}\n\n// Values represents a list of Value's.\ntype Values []Value\n\n// Interfaces returns the interface values for the underlying values stored in v.\nfunc (v Values) Interfaces() []interface{} {\n\tres := make([]interface{}, 0)\n\tfor _, val := range v {\n\t\tres = append(res, val.Interface())\n\t}\n\treturn res\n}\n\n//func (v Values) initEmptyMaps() Values {\n//\tres := make(Values, len(v))\n//\tfor k, value := range v {\n//\t\tif value.IsEmpty() {\n//\t\t\tres[k] = value.initEmptyMap()\n//\t\t} else {\n//\t\t\tres[k] = value\n//\t\t}\n//\t}\n//\treturn res\n//}\n\nfunc (v Values) initEmptydencodingMaps() Values {\n\tres := make(Values, len(v))\n\tfor k, value := range v {\n\t\tif value.IsEmpty() || value.IsNil() {\n\t\t\tres[k] = value.initEmptydencodingMap()\n\t\t} else {\n\t\t\tres[k] = value\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (v Values) initEmptySlices() Values {\n\tres := make(Values, len(v))\n\tfor k, value := range v {\n\t\tif value.IsEmpty() || value.IsNil() {\n\t\t\tres[k] = value.initEmptySlice()\n\t\t} else {\n\t\t\tres[k] = value\n\t\t}\n\t}\n\treturn res\n}\n"
        }
      ]
    }
  ]
}