{
  "metadata": {
    "timestamp": 1736567821927,
    "page": 407,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eatmoreapple/openwechat",
      "stars": 5098,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2841796875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n.idea\nbuild\n.DS_Store\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 1.0048828125,
          "content": "# Read the Docs configuration file for Sphinx projects\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\n# Set the OS, Python version and other tools you might need\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: \"3.12\"\n    # You can also specify other tool versions:\n    # nodejs: \"20\"\n    # rust: \"1.70\"\n    # golang: \"1.20\"\n\n# Build documentation in the \"docs/\" directory with Sphinx\nsphinx:\n  configuration: docs/conf.py\n  # You can configure Sphinx to use a different builder, for instance use the dirhtml builder for simpler URLs\n  # builder: \"dirhtml\"\n  # Fail on all warnings to avoid broken references\n  # fail_on_warning: true\n\n# Optionally build your docs in additional formats such as PDF and ePub\n# formats:\n#   - pdf\n#   - epub\n\n# Optional but recommended, declare the Python requirements required\n# to build your documentation\n# See https://docs.readthedocs.io/en/stable/guides/reproducible-builds.html\npython:\n   install:\n     - requirements: docs/requirements.txt"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0986328125,
          "content": "# openwechat\n\n[![Go Doc](https://pkg.go.dev/badge/github.com/eatMoreApple/openwechat)](https://godoc.org/github.com/eatMoreApple/openwechat)\n[![Release](https://img.shields.io/github/v/release/eatmoreapple/openwechat.svg?style=flat-square)](https://github.com/eatmoreapple/openwechat/releases)\n[![Go Report Card](https://goreportcard.com/badge/github.com/eatmoreapple/openwechat)](https://goreportcard.com/badge/github.com/eatmoreapple/openwechat)\n[![Stars](https://img.shields.io/github/stars/eatmoreapple/openwechat.svg?style=flat-square)](https://img.shields.io/github/stars/eatmoreapple/openwechat.svg?style=flat-square)\n[![Forks](https://img.shields.io/github/forks/eatmoreapple/openwechat.svg?style=flat-square)](https://img.shields.io/github/forks/eatmoreapple/openwechat.svg?style=flat-square)\n[![Sourcegraph](https://sourcegraph.com/github.com/eatmoreapple/openwechat/-/badge.svg)](https://sourcegraph.com/github.com/eatmoreapple/openwechat?badge)\n\n> golang版个人微信号API, 突破登录限制，类似开发公众号一样，开发个人微信号\n\n\n微信机器人，利用微信号完成一些功能的定制化开发⭐\n\n* 模块简单易用，易于扩展\n* 支持定制化开发，如日志记录，自动回复\n* 突破登录限制&#x1F4E3;\n* 无需重复扫码登录\n* 支持多个微信号同时登陆\n\n### 安装\n\n```shell\ngo get -u github.com/eatmoreapple/openwechat\n```\n\n### 快速开始\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/eatmoreapple/openwechat\"\n)\n\nfunc main() {\n\tbot := openwechat.DefaultBot(openwechat.Desktop) // 桌面模式\n\n\t// 注册消息处理函数\n\tbot.MessageHandler = func(msg *openwechat.Message) {\n\t\tif msg.IsText() && msg.Content == \"ping\" {\n\t\t\tmsg.ReplyText(\"pong\")\n\t\t}\n\t}\n\t// 注册登陆二维码回调\n\tbot.UUIDCallback = openwechat.PrintlnQrcodeUrl\n\n\t// 登陆\n\tif err := bot.Login(); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// 获取登陆的用户\n\tself, err := bot.GetCurrentUser()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// 获取所有的好友\n\tfriends, err := self.Friends()\n\tfmt.Println(friends, err)\n\n\t// 获取所有的群组\n\tgroups, err := self.Groups()\n\tfmt.Println(groups, err)\n\n\t// 阻塞主goroutine, 直到发生异常或者用户主动退出\n\tbot.Block()\n}\n```\n\n### 支持功能\n\n* 消息回复、给指定对象（好友、群组）发送文本、图片、文件、emoji表情等消息\n* 热登陆（无需重复扫码登录）、自定义消息处理、文件下载、消息防撤回\n* 获取对象信息、设置好友备注、拉好友进群等\n* 更多功能请查看文档\n\n### 文档\n\n[点击查看](https://openwechat.readthedocs.io/zh/latest/)\n\n### 项目主页\n\n[https://github.com/eatmoreapple/openwechat](https://github.com/eatmoreapple/openwechat)\n\n## Thanks\n\n<a href=\"https://www.jetbrains.com/?from=openwechat\"><img src=\"https://account.jetbrains.com/static/images/jetbrains-logo-inv.svg\" height=\"200\" alt=\"JetBrains\"/></a>\n\n** 如果喜欢的话，可以请作者吃包辣条。谢谢支持 :smile: **\n\n<img width=\"210px\" height=\"210px\" src=\"https://github.com/eatmoreapple/eatmoreapple/blob/main/img/wechat_pay.jpg\" align=\"left\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
          "name": "base_response.go",
          "type": "blob",
          "size": 0.7412109375,
          "content": "package openwechat\n\ntype Ret int\n\nconst (\n\tticketError         Ret = -14  // ticket error\n\tlogicError          Ret = -2   // logic error\n\tsysError            Ret = -1   // sys error\n\tparamError          Ret = 1    // param error\n\tfailedLoginWarn     Ret = 1100 // failed login warn\n\tfailedLoginCheck    Ret = 1101 // failed login check\n\tcookieInvalid       Ret = 1102 // cookie invalid\n\tloginEnvAbnormality Ret = 1203 // login environmental abnormality\n\toptTooOften         Ret = 1205 // operate too often\n)\n\n// BaseResponse 大部分返回对象都携带该信息\ntype BaseResponse struct {\n\tRet    Ret\n\tErrMsg string\n}\n\nfunc (b BaseResponse) Ok() bool {\n\treturn b.Ret == 0\n}\n\nfunc (b BaseResponse) Err() error {\n\tif b.Ok() {\n\t\treturn nil\n\t}\n\treturn b.Ret\n}\n"
        },
        {
          "name": "bot.go",
          "type": "blob",
          "size": 11.291015625,
          "content": "package openwechat\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/url\"\n\t\"os/exec\"\n\t\"runtime\"\n)\n\ntype Bot struct {\n\tScanCallBack        func(body CheckLoginResponse) // 扫码回调,可获取扫码用户的头像\n\tLoginCallBack       func(body CheckLoginResponse) // 登陆回调\n\tLogoutCallBack      func(bot *Bot)                // 退出回调\n\tUUIDCallback        func(uuid string)             // 获取UUID的回调函数\n\tSyncCheckCallback   func(resp SyncCheckResponse)  // 心跳回调\n\tMessageHandler      MessageHandler                // 获取消息成功的handle\n\tMessageErrorHandler MessageErrorHandler           // 获取消息发生错误的handle, 返回err == nil 则尝试继续监听\n\tCaller              *Caller\n\tStorage             *Session\n\terr                 error\n\tcontext             context.Context\n\tcancel              func()\n\tself                *Self\n\thotReloadStorage    HotReloadStorage\n\tuuid                string\n\tloginUUID           string\n\tdeviceId            string // 设备Id\n\tloginOptionGroup    BotOptionGroup\n}\n\n// Alive 判断当前用户是否正常在线\nfunc (b *Bot) Alive() bool {\n\tselect {\n\tcase <-b.context.Done():\n\t\treturn false\n\tdefault:\n\t\treturn b.self != nil\n\t}\n}\n\n// GetCurrentUser 获取当前的用户\n//\n//\tself, err := bot.GetCurrentUser()\n//\tif err != nil {\n//\t\treturn\n//\t}\n//\tfmt.Println(self.NickName)\nfunc (b *Bot) GetCurrentUser() (*Self, error) {\n\tif b.self == nil {\n\t\treturn nil, ErrUserNotLogin\n\t}\n\treturn b.self, nil\n}\n\n// login 这里对进行一些对登录前后的hook\nfunc (b *Bot) login(login BotLogin) (err error) {\n\topt := b.loginOptionGroup\n\topt.Prepare(b)\n\tif err = login.Login(b); err != nil {\n\t\terr = opt.OnError(b, err)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn opt.OnSuccess(b)\n}\n\n// Login 用户登录\nfunc (b *Bot) Login() error {\n\tscanLogin := &ScanLogin{UUID: b.loginUUID}\n\treturn b.login(scanLogin)\n}\n\n// HotLogin 热登录,可实现在单位时间内免重复扫码登录\n// 热登录需要先扫码登录一次才可以进行热登录\nfunc (b *Bot) HotLogin(storage HotReloadStorage, opts ...BotLoginOption) error {\n\thotLogin := &HotLogin{storage: storage}\n\t// 进行相关设置。\n\t// 如果相对默认的行为进行修改，在opts里面进行追加即可。\n\tb.loginOptionGroup = opts\n\treturn b.login(hotLogin)\n}\n\n// PushLogin 免扫码登录\n// 免扫码登录需要先扫码登录一次才可以进行扫码登录\nfunc (b *Bot) PushLogin(storage HotReloadStorage, opts ...BotLoginOption) error {\n\tpushLogin := &PushLogin{storage: storage}\n\t// 进行相关设置。\n\t// 如果相对默认的行为进行修改，在opts里面进行追加即可。\n\tb.loginOptionGroup = opts\n\treturn b.login(pushLogin)\n}\n\n// Logout 用户退出\nfunc (b *Bot) Logout() error {\n\tif !b.Alive() {\n\t\treturn ErrUserNotLogin\n\t}\n\tif err := b.Caller.Logout(b.Context(), b.Storage.LoginInfo); err != nil {\n\t\treturn err\n\t}\n\tb.ExitWith(ErrUserLogout)\n\treturn nil\n}\n\n// loginFromURL 登录逻辑\nfunc (b *Bot) loginFromURL(path *url.URL) error {\n\t// 获取登录的一些基本的信息\n\tinfo, err := b.Caller.GetLoginInfo(b.Context(), path)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 将LoginInfo存到storage里面\n\tb.Storage.LoginInfo = info\n\n\t// 处理设备Id\n\tif b.deviceId == \"\" {\n\t\tb.deviceId = GetRandomDeviceId()\n\t}\n\n\t// 构建BaseRequest\n\trequest := &BaseRequest{\n\t\tUin:      info.WxUin,\n\t\tSid:      info.WxSid,\n\t\tSkey:     info.SKey,\n\t\tDeviceID: b.deviceId,\n\t}\n\n\t// 将BaseRequest存到storage里面方便后续调用\n\tb.Storage.Request = request\n\n\treturn b.webInit()\n}\n\nfunc (b *Bot) initContacts(resp *WebInitResponse) {\n\tif resp.ContactList != nil {\n\t\tresp.ContactList.init(b.self)\n\t}\n}\n\nfunc (b *Bot) updateSyncKey(resp *WebInitResponse) {\n\tif b.Storage.Response != nil {\n\t\tresp.SyncKey = b.Storage.Response.SyncKey\n\t}\n\tb.Storage.Response = resp\n}\n\n// 拆分为小函数\nfunc (b *Bot) initUserInfo() error {\n\tresp, err := b.Caller.WebInit(b.Context(), b.Storage.Request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb.initSelf(resp)\n\tb.initContacts(resp)\n\tb.updateSyncKey(resp)\n\n\treturn nil\n}\n\nfunc (b *Bot) initSelf(resp *WebInitResponse) {\n\tb.self = &Self{\n\t\tbot:  b,\n\t\tUser: resp.User,\n\t}\n\tb.self.formatEmoji()\n\tb.self.self = b.self\n}\n\nfunc (b *Bot) saveHotReloadData() error {\n\tif b.hotReloadStorage == nil {\n\t\treturn nil\n\t}\n\treturn b.DumpHotReloadStorage()\n}\n\nfunc (b *Bot) notifyMobileClient() error {\n\tnotifyOption := &CallerWebWxStatusNotifyOptions{\n\t\tBaseRequest:     b.Storage.Request,\n\t\tWebInitResponse: b.Storage.Response,\n\t\tLoginInfo:       b.Storage.LoginInfo,\n\t}\n\treturn b.Caller.WebWxStatusNotify(b.Context(), notifyOption)\n}\n\nfunc (b *Bot) startMessageSync() {\n\tgo b.runMessageLoop()\n}\n\nfunc (b *Bot) runMessageLoop() {\n\tb.initMessageErrorHandler()\n\n\tfor b.Alive() {\n\t\tif err := b.syncCheck(); err != nil {\n\t\t\tif err = b.handleSyncError(err); err != nil {\n\t\t\t\tb.ExitWith(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (b *Bot) initMessageErrorHandler() {\n\tif b.MessageErrorHandler == nil {\n\t\tb.MessageErrorHandler = defaultMessageErrorHandler\n\t}\n}\n\nfunc (b *Bot) handleSyncError(err error) error {\n\treturn b.MessageErrorHandler(err)\n}\n\nfunc (b *Bot) webInit() error {\n\t// 1. 初始化用户信息\n\tif err := b.initUserInfo(); err != nil {\n\t\treturn fmt.Errorf(\"init user info: %w\", err)\n\t}\n\n\t// 2. 保存热重载数据\n\tif err := b.saveHotReloadData(); err != nil {\n\t\treturn fmt.Errorf(\"save hot reload data: %w\", err)\n\t}\n\n\t// 3. 通知移动端\n\tif err := b.notifyMobileClient(); err != nil {\n\t\treturn fmt.Errorf(\"notify mobile client: %w\", err)\n\t}\n\n\t// 4. 启动消息同步\n\tb.startMessageSync()\n\n\treturn nil\n}\n\nfunc (b *Bot) executeSyncCallback(resp *SyncCheckResponse) {\n\tif b.SyncCheckCallback != nil {\n\t\tb.SyncCheckCallback(*resp)\n\t}\n}\n\nfunc (b *Bot) handleMessages(messages []*Message) {\n\tif b.MessageHandler == nil {\n\t\treturn\n\t}\n\n\tfor _, msg := range messages {\n\t\tmsg.init(b)\n\t\tb.MessageHandler(msg)\n\t}\n}\n\nfunc (b *Bot) processNewMessages() error {\n\t// 获取新消息\n\tmessages, err := b.syncMessage()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sync message failed: %w\", err)\n\t}\n\n\t// 保存热重载数据\n\t_ = b.DumpHotReloadStorage()\n\n\t// 处理消息\n\tb.handleMessages(messages)\n\n\treturn nil\n}\n\nfunc (b *Bot) handleSyncSelector(selector Selector) error {\n\tswitch selector {\n\tcase SelectorNormal:\n\t\treturn nil\n\tdefault:\n\t\treturn b.processNewMessages()\n\t}\n}\n\nfunc (b *Bot) doSyncCheck(option *CallerSyncCheckOptions) error {\n\t// 更新同步检查参数\n\tb.updateSyncCheckOptions(option)\n\n\t// 执行同步检查\n\tresp, err := b.Caller.SyncCheck(b.Context(), option)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sync check failed: %w\", err)\n\t}\n\n\t// 执行心跳回调\n\tb.executeSyncCallback(resp)\n\n\t// 检查响应状态\n\tif err := resp.Err(); err != nil {\n\t\treturn resp.Err()\n\t}\n\n\t// 处理消息\n\treturn b.handleSyncSelector(resp.Selector)\n}\n\nfunc (b *Bot) updateSyncCheckOptions(option *CallerSyncCheckOptions) {\n\toption.BaseRequest = b.Storage.Request\n\toption.WebInitResponse = b.Storage.Response\n\toption.LoginInfo = b.Storage.LoginInfo\n}\n\n// 轮询请求\n// 根据状态码判断是否有新的请求\nfunc (b *Bot) syncCheck() error {\n\toption := &CallerSyncCheckOptions{}\n\n\tfor b.Alive() {\n\t\tif err := b.doSyncCheck(option); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// 获取新的消息\nfunc (b *Bot) syncMessage() ([]*Message, error) {\n\topt := CallerWebWxSyncOptions{\n\t\tBaseRequest:     b.Storage.Request,\n\t\tWebInitResponse: b.Storage.Response,\n\t\tLoginInfo:       b.Storage.LoginInfo,\n\t}\n\tresp, err := b.Caller.WebWxSync(b.Context(), &opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 更新SyncKey并且重新存入storage 如获取到的SyncKey为空则不更新\n\tif resp.SyncKey.Count > 0 {\n\t\tb.Storage.Response.SyncKey = resp.SyncKey\n\t}\n\treturn resp.AddMsgList, nil\n}\n\n// Block 当消息同步发生了错误或者用户主动在手机上退出，该方法会立即返回，否则会一直阻塞\nfunc (b *Bot) Block() error {\n\tif b.self == nil {\n\t\treturn errors.New(\"`Block` must be called after user login\")\n\t}\n\t<-b.Context().Done()\n\treturn b.CrashReason()\n}\n\n// Exit 主动退出，让 Block 不在阻塞\nfunc (b *Bot) Exit() {\n\tb.self = nil\n\tb.cancel()\n\tif b.LogoutCallBack != nil {\n\t\tb.LogoutCallBack(b)\n\t}\n}\n\n// ExitWith 主动退出并且设置退出原因, 可以通过 `CrashReason` 获取退出原因\nfunc (b *Bot) ExitWith(err error) {\n\tb.err = err\n\tb.Exit()\n}\n\n// CrashReason 获取当前Bot崩溃的原因\nfunc (b *Bot) CrashReason() error {\n\treturn b.err\n}\n\n// DumpHotReloadStorage 写入HotReloadStorage\nfunc (b *Bot) DumpHotReloadStorage() error {\n\tif b.hotReloadStorage == nil {\n\t\treturn errors.New(\"HotReloadStorage can not be nil\")\n\t}\n\treturn b.DumpTo(b.hotReloadStorage)\n}\n\n// DumpTo 将热登录需要的数据写入到指定的 io.Writer 中\n// 注: 写之前最好先清空之前的数据\nfunc (b *Bot) DumpTo(writer io.Writer) error {\n\tjar := b.Caller.Client.Jar()\n\titem := HotReloadStorageItem{\n\t\tBaseRequest:  b.Storage.Request,\n\t\tJar:          jar,\n\t\tLoginInfo:    b.Storage.LoginInfo,\n\t\tWechatDomain: b.Caller.Client.Domain,\n\t\tSyncKey:      b.Storage.Response.SyncKey,\n\t\tUUID:         b.uuid,\n\t}\n\treturn json.NewEncoder(writer).Encode(item)\n}\n\n// IsHot returns true if is hot login otherwise false\nfunc (b *Bot) IsHot() bool {\n\treturn b.hotReloadStorage != nil\n}\n\n// UUID returns current UUID of bot\nfunc (b *Bot) UUID() string {\n\treturn b.uuid\n}\n\n// Context returns current context of bot\nfunc (b *Bot) Context() context.Context {\n\treturn b.context\n}\n\n// NewBot Bot的构造方法\n// 接收外部的 context.Context，用于控制Bot的存活\nfunc NewBot(c context.Context) *Bot {\n\tcaller := DefaultCaller()\n\t// 默认行为为网页版微信模式\n\tcaller.Client.SetMode(normal)\n\tctx, cancel := context.WithCancel(c)\n\treturn &Bot{\n\t\tCaller:  caller,\n\t\tStorage: &Session{},\n\t\tcontext: ctx,\n\t\tcancel:  cancel,\n\t}\n}\n\nfunc New(ctx context.Context) *Bot {\n\treturn NewBot(ctx)\n}\n\n// DefaultBot 默认的Bot的构造方法,\n// mode不传入默认为 openwechat.Normal,详情见mode\n//\n//\tbot := openwechat.DefaultBot(openwechat.Desktop)\nfunc DefaultBot(prepares ...BotPreparer) *Bot {\n\tbot := NewBot(context.Background())\n\t// 获取二维码回调\n\tbot.UUIDCallback = PrintlnQrcodeUrl\n\t// 扫码回调\n\tbot.ScanCallBack = func(_ CheckLoginResponse) {\n\t\tlog.Println(\"扫码成功,请在手机上确认登录\")\n\t}\n\t// 登录回调\n\tbot.LoginCallBack = func(_ CheckLoginResponse) {\n\t\tlog.Println(\"登录成功\")\n\t}\n\t// 心跳回调函数\n\t// 默认的行为打印SyncCheckResponse\n\tbot.SyncCheckCallback = func(resp SyncCheckResponse) {\n\t\tlog.Printf(\"RetCode:%s  Selector:%s\", resp.RetCode, resp.Selector)\n\t}\n\tfor _, prepare := range prepares {\n\t\tprepare.Prepare(bot)\n\t}\n\treturn bot\n}\n\nfunc Default(prepares ...BotPreparer) *Bot {\n\treturn DefaultBot(prepares...)\n}\n\n// GetQrcodeUrl 通过uuid获取登录二维码的url\nfunc GetQrcodeUrl(uuid string) string {\n\treturn qrcode + uuid\n}\n\n// PrintlnQrcodeUrl 打印登录二维码\nfunc PrintlnQrcodeUrl(uuid string) {\n\tprintln(\"访问下面网址扫描二维码登录\")\n\tqrcodeUrl := GetQrcodeUrl(uuid)\n\tprintln(qrcodeUrl)\n\n\t// browser open the login url\n\t_ = open(qrcodeUrl)\n}\n\n// open opens the specified URL in the default browser of the user.\nfunc open(url string) error {\n\tvar (\n\t\tcmd  string\n\t\targs []string\n\t)\n\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tcmd, args = \"cmd\", []string{\"/c\", \"start\"}\n\tcase \"darwin\":\n\t\tcmd = \"open\"\n\tdefault:\n\t\t// \"linux\", \"freebsd\", \"openbsd\", \"netbsd\"\n\t\tcmd = \"xdg-open\"\n\t}\n\targs = append(args, url)\n\treturn exec.Command(cmd, args...).Start()\n}\n"
        },
        {
          "name": "bot_login.go",
          "type": "blob",
          "size": 8.111328125,
          "content": "package openwechat\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n)\n\n// LoginCode 定义登录状态码\ntype LoginCode string\n\nconst (\n\t// LoginCodeSuccess 登录成功\n\tLoginCodeSuccess LoginCode = \"200\"\n\t// LoginCodeScanned 已扫码\n\tLoginCodeScanned LoginCode = \"201\"\n\t// LoginCodeTimeout 登录超时\n\tLoginCodeTimeout LoginCode = \"400\"\n\t// LoginCodeWait 等待扫码\n\tLoginCodeWait LoginCode = \"408\"\n)\n\nfunc (l LoginCode) String() string {\n\tswitch l {\n\tcase LoginCodeSuccess:\n\t\treturn \"登录成功\"\n\tcase LoginCodeScanned:\n\t\treturn \"已扫码\"\n\tcase LoginCodeTimeout:\n\t\treturn \"登录超时\"\n\tcase LoginCodeWait:\n\t\treturn \"等待扫码\"\n\tdefault:\n\t\treturn \"未知状态\"\n\t}\n}\n\ntype BotPreparer interface {\n\tPrepare(*Bot)\n}\n\ntype BotLoginOption interface {\n\tBotPreparer\n\tOnError(*Bot, error) error\n\tOnSuccess(*Bot) error\n}\n\n// BotOptionGroup 是一个 BotLoginOption 的集合\n// 用于将多个 BotLoginOption 组合成一个 BotLoginOption\ntype BotOptionGroup []BotLoginOption\n\n// Prepare 实现了 BotLoginOption 接口\nfunc (g BotOptionGroup) Prepare(bot *Bot) {\n\tfor _, option := range g {\n\t\toption.Prepare(bot)\n\t}\n}\n\n// OnError 实现了 BotLoginOption 接口\nfunc (g BotOptionGroup) OnError(b *Bot, err error) error {\n\t// 当有一个 BotLoginOption 的 OnError 返回的 error 等于 nil 时，就会停止执行后续的 BotLoginOption\n\tfor _, option := range g {\n\t\tcurrentErr := option.OnError(b, err)\n\t\tif currentErr == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif currentErr != err {\n\t\t\treturn currentErr\n\t\t}\n\t}\n\treturn err\n}\n\n// OnSuccess 实现了 BotLoginOption 接口\nfunc (g BotOptionGroup) OnSuccess(b *Bot) error {\n\tfor _, option := range g {\n\t\tif err := option.OnSuccess(b); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype BaseBotLoginOption struct{}\n\nfunc (BaseBotLoginOption) Prepare(_ *Bot) {}\n\nfunc (BaseBotLoginOption) OnError(_ *Bot, err error) error { return err }\n\nfunc (BaseBotLoginOption) OnSuccess(_ *Bot) error { return nil }\n\n// DoNothingBotLoginOption 是一个空的 BotLoginOption，表示不做任何操作\nvar DoNothingBotLoginOption = &BaseBotLoginOption{}\n\n// RetryLoginOption 在登录失败后进行扫码登录\ntype RetryLoginOption struct {\n\tBaseBotLoginOption\n\tMaxRetryCount    int\n\tcurrentRetryTime int\n}\n\n// OnError 实现了 BotLoginOption 接口\n// 当登录失败后，会调用此方法进行扫码登录\nfunc (r *RetryLoginOption) OnError(bot *Bot, err error) error {\n\tif r.currentRetryTime >= r.MaxRetryCount {\n\t\treturn err\n\t}\n\tr.currentRetryTime++\n\treturn bot.Login()\n}\n\nfunc NewRetryLoginOption() BotLoginOption {\n\treturn &RetryLoginOption{MaxRetryCount: 1}\n}\n\ntype BotPreparerFunc func(*Bot)\n\nfunc (f BotPreparerFunc) Prepare(b *Bot) {\n\tf(b)\n}\n\n// withMode 是一个 BotPreparerFunc，用于设置 Bot 的模式\nfunc withMode(mode Mode) BotPreparer {\n\treturn BotPreparerFunc(func(b *Bot) { b.Caller.Client.SetMode(mode) })\n}\n\n// btw, 这两个变量已经变了4回了, 但是为了兼容以前的代码, 还是得想着法儿让用户无感知的更新\nvar (\n\t// Normal 网页版微信模式\n\tNormal = withMode(normal)\n\n\t// Desktop 桌面微信模式\n\tDesktop = withMode(desktop)\n)\n\n// WithContextOption 是一个 BotPreparerFunc，用于设置 Bot 的 context\nfunc WithContextOption(ctx context.Context) BotPreparer {\n\tif ctx == nil {\n\t\tpanic(\"context is nil\")\n\t}\n\treturn BotPreparerFunc(func(b *Bot) { b.context, b.cancel = context.WithCancel(ctx) })\n}\n\n// WithUUIDOption 是一个 BotPreparerFunc，用于设置 Bot 的 登录 uuid\nfunc WithUUIDOption(uuid string) BotPreparer {\n\treturn BotPreparerFunc(func(b *Bot) { b.loginUUID = uuid })\n}\n\n// WithDeviceID 是一个 BotPreparerFunc，用于设置 Bot 的 设备 id\nfunc WithDeviceID(deviceId string) BotPreparer {\n\treturn BotPreparerFunc(func(b *Bot) { b.deviceId = deviceId })\n}\n\n// BotLogin 定义了一个Login的接口\ntype BotLogin interface {\n\tLogin(bot *Bot) error\n}\n\n// ScanLogin 扫码登录\ntype ScanLogin struct {\n\tUUID string\n}\n\n// Login 实现了 BotLogin 接口\nfunc (s *ScanLogin) Login(bot *Bot) error {\n\tvar uuid = s.UUID\n\tif uuid == \"\" {\n\t\tvar err error\n\t\tuuid, err = bot.Caller.GetLoginUUID(bot.Context())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.checkLogin(bot, uuid)\n}\n\n// checkLogin 该方法会一直阻塞，直到用户扫码登录，或者二维码过期\nfunc (s *ScanLogin) checkLogin(bot *Bot, uuid string) error {\n\tbot.uuid = uuid\n\tloginChecker := &LoginChecker{\n\t\tBot:           bot,\n\t\tTip:           \"0\",\n\t\tUUIDCallback:  bot.UUIDCallback,\n\t\tLoginCallBack: bot.LoginCallBack,\n\t\tScanCallBack:  bot.ScanCallBack,\n\t}\n\treturn loginChecker.CheckLogin()\n}\n\nfunc botReload(bot *Bot, storage HotReloadStorage) error {\n\tif storage == nil {\n\t\treturn errors.New(\"storage is nil\")\n\t}\n\tbot.hotReloadStorage = storage\n\tvar item HotReloadStorageItem\n\tif err := json.NewDecoder(storage).Decode(&item); err != nil {\n\t\treturn err\n\t}\n\tbot.Caller.Client.SetCookieJar(item.Jar)\n\tbot.Storage.LoginInfo = item.LoginInfo\n\tbot.Storage.Request = item.BaseRequest\n\tbot.Caller.Client.Domain = item.WechatDomain\n\tbot.uuid = item.UUID\n\tif item.SyncKey != nil {\n\t\tif bot.Storage.Response == nil {\n\t\t\tbot.Storage.Response = &WebInitResponse{}\n\t\t}\n\t\tbot.Storage.Response.SyncKey = item.SyncKey\n\t}\n\treturn nil\n}\n\n// HotLogin 热登录模式\ntype HotLogin struct {\n\tstorage HotReloadStorage\n}\n\n// Login 实现了 BotLogin 接口\nfunc (h *HotLogin) Login(bot *Bot) error {\n\tif err := botReload(bot, h.storage); err != nil {\n\t\treturn err\n\t}\n\treturn bot.webInit()\n}\n\n// PushLogin 免扫码登录模式\ntype PushLogin struct {\n\tstorage HotReloadStorage\n}\n\n// Login 实现了 BotLogin 接口\nfunc (p *PushLogin) Login(bot *Bot) error {\n\tif err := botReload(bot, p.storage); err != nil {\n\t\treturn err\n\t}\n\tresp, err := bot.Caller.WebWxPushLogin(bot.Context(), bot.Storage.LoginInfo.WxUin)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = resp.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn p.checkLogin(bot, resp.UUID)\n}\n\n// checkLogin 登录检查\nfunc (p *PushLogin) checkLogin(bot *Bot, uuid string) error {\n\tbot.uuid = uuid\n\t// 为什么把 UUIDCallback 和 ScanCallBack 置为nil呢?\n\t// 因为这两个对用户是无感知的。\n\tloginChecker := &LoginChecker{\n\t\tBot:           bot,\n\t\tTip:           \"1\",\n\t\tLoginCallBack: bot.LoginCallBack,\n\t}\n\treturn loginChecker.CheckLogin()\n}\n\ntype LoginChecker struct {\n\tBot           *Bot\n\tTip           string\n\tUUIDCallback  func(uuid string)\n\tLoginCallBack func(body CheckLoginResponse)\n\tScanCallBack  func(body CheckLoginResponse)\n}\n\nfunc (l *LoginChecker) CheckLogin() error {\n\tuuid := l.Bot.UUID()\n\t// 二维码获取回调\n\tif cb := l.UUIDCallback; cb != nil {\n\t\tcb(uuid)\n\t}\n\tvar tip = l.Tip\n\tfor {\n\t\t// 长轮询检查是否扫码登录\n\t\tresp, err := l.Bot.Caller.CheckLogin(l.Bot.Context(), uuid, tip)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcode, err := resp.Code()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif tip == \"1\" {\n\t\t\ttip = \"0\"\n\t\t}\n\t\tswitch code {\n\t\tcase LoginCodeSuccess:\n\t\t\t// 判断是否有登录回调，如果有执行它\n\t\t\tredirectURL, err := resp.RedirectURL()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err = l.Bot.loginFromURL(redirectURL); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif cb := l.LoginCallBack; cb != nil {\n\t\t\t\tcb(resp)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase LoginCodeScanned:\n\t\t\t// 执行扫码回调\n\t\t\tif cb := l.ScanCallBack; cb != nil {\n\t\t\t\tcb(resp)\n\t\t\t}\n\t\tcase LoginCodeTimeout:\n\t\t\treturn ErrLoginTimeout\n\t\tcase LoginCodeWait:\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// # 下面都是即将废弃的函数。\n// # 为了兼容老版本暂时留了下来, 但是它的函数签名已经发生了改变。\n// # 如果你是使用的是openwechat提供的api来调用这些函数，那么你是感知不到变动的。\n// # openwechat内部对这些函数的调用做了兼容处理, 如果你的代码中调用了这些函数, 请尽快修改。\n\n// Deprecated: 请使用 NewRetryLoginOption 代替\n// HotLoginWithRetry 热登录模式，如果登录失败会重试\nfunc HotLoginWithRetry(flag bool) BotLoginOption {\n\tif flag {\n\t\treturn NewRetryLoginOption()\n\t}\n\treturn DoNothingBotLoginOption\n}\n\n// Deprecated: 请使用 NewRetryLoginOption 代替\n// PushLoginWithRetry 免扫码登录模式，如果登录失败会重试\nfunc PushLoginWithRetry(flag bool) BotLoginOption {\n\tif !flag {\n\t\treturn DoNothingBotLoginOption\n\t}\n\treturn NewRetryLoginOption()\n}\n"
        },
        {
          "name": "bot_test.go",
          "type": "blob",
          "size": 2.841796875,
          "content": "package openwechat\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLogin(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tbot.LoginCallBack = func(body CheckLoginResponse) {\n\t\tt.Log(\"login\")\n\t}\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestLogout(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tbot.LoginCallBack = func(body CheckLoginResponse) {\n\t\tt.Log(\"login\")\n\t}\n\tbot.LogoutCallBack = func(bot *Bot) {\n\t\tt.Log(\"logout\")\n\t}\n\tbot.MessageHandler = func(msg *Message) {\n\t\tif msg.IsText() && msg.Content == \"logout\" {\n\t\t\tif err := bot.Logout(); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t}\n\t}\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t_ = bot.Block()\n}\n\nfunc TestMessageHandle(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tbot.MessageHandler = func(msg *Message) {\n\t\tif msg.IsText() && msg.Content == \"ping\" {\n\t\t\tif _, err := msg.ReplyText(\"pong\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t}\n\t}\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t_ = bot.Block()\n}\n\nfunc TestFriends(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tuser, err := bot.GetCurrentUser()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tfriends, err := user.Friends()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(friends)\n}\n\nfunc TestGroups(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tuser, err := bot.GetCurrentUser()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tgroups, err := user.Groups()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(groups)\n}\n\nfunc TestPinUser(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tuser, err := bot.GetCurrentUser()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tfriends, err := user.Friends()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif friends.Count() > 0 {\n\t\tf := friends.First()\n\t\tif err = f.Pin(); err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(time.Second * 5)\n\t\tif err = f.UnPin(); err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestSender(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\tbot.MessageHandler = func(msg *Message) {\n\t\tif msg.IsSendByGroup() {\n\t\t\tfmt.Println(msg.SenderInGroup())\n\t\t} else {\n\t\t\tfmt.Println(msg.Sender())\n\t\t}\n\t}\n\tif err := bot.Login(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t_ = bot.Block()\n}\n\n// TestGetUUID\n// @description: 获取登录二维码(UUID)\n// @param t\nfunc TestGetUUID(t *testing.T) {\n\tbot := DefaultBot(Desktop)\n\n\tuuid, err := bot.Caller.GetLoginUUID(bot.Context())\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(uuid)\n}\n\n// TestLoginWithUUID\n// @description: 使用UUID登录\n// @param t\nfunc TestLoginWithUUID(t *testing.T) {\n\tuuid := \"oZZsO0Qv8Q==\"\n\tbot := DefaultBot(Desktop, WithUUIDOption(uuid))\n\terr := bot.Login()\n\tif err != nil {\n\t\tt.Errorf(\"登录失败: %v\", err.Error())\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "caller.go",
          "type": "blob",
          "size": 22.5947265625,
          "content": "package openwechat\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n)\n\n// Caller 调用请求和解析请求\n// 上层模块可以直接获取封装后的请求结果\ntype Caller struct {\n\tClient *Client\n}\n\n// NewCaller Constructor for Caller\nfunc NewCaller(client *Client) *Caller {\n\treturn &Caller{Client: client}\n}\n\n// DefaultCaller Default Constructor for Caller\nfunc DefaultCaller() *Caller {\n\treturn NewCaller(DefaultClient())\n}\n\n// GetLoginUUID 获取登录的uuid\nfunc (c *Caller) GetLoginUUID(ctx context.Context) (string, error) {\n\tresp, err := c.Client.GetLoginUUID(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\tvar buffer bytes.Buffer\n\tif _, err = buffer.ReadFrom(resp.Body); err != nil {\n\t\treturn \"\", err\n\t}\n\t// 正则匹配uuid字符串\n\tresults := uuidRegexp.FindSubmatch(buffer.Bytes())\n\tif len(results) != 2 {\n\t\t// 如果没有匹配到,可能微信的接口做了修改，或者当前机器的ip被加入了黑名单\n\t\treturn \"\", errors.New(\"uuid does not match\")\n\t}\n\treturn string(results[1]), nil\n}\n\n// CheckLogin 检查是否登录成功\nfunc (c *Caller) CheckLogin(ctx context.Context, uuid, tip string) (CheckLoginResponse, error) {\n\tresp, err := c.Client.CheckLogin(ctx, uuid, tip)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\tvar buffer bytes.Buffer\n\tif _, err := buffer.ReadFrom(resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer.Bytes(), nil\n}\n\n// GetLoginInfo 获取登录信息\nfunc (c *Caller) GetLoginInfo(ctx context.Context, path *url.URL) (*LoginInfo, error) {\n\t// 从响应体里面获取需要跳转的url\n\tquery := path.Query()\n\tquery.Set(\"version\", \"v2\")\n\tpath.RawQuery = query.Encode()\n\tresp, err := c.Client.GetLoginInfo(ctx, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// 微信 v2 版本修复了301 response missing Location header 的问题\n\tdefer func() { _ = resp.Body.Close() }()\n\n\tbs, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar loginInfo LoginInfo\n\n\t// xml结构体序列化储存\n\t// 为什么这里不直接使用resp.Body?\n\t// 因为要确保传入的reader实现了 io.ByteReader 接口\n\t// https://github.com/eatmoreapple/openwechat/pull/345\n\tif err = xml.NewDecoder(bytes.NewBuffer(bs)).Decode(&loginInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = loginInfo.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\t// set domain\n\tc.Client.Domain = WechatDomain(path.Host)\n\treturn &loginInfo, nil\n}\n\n// WebInit 获取初始化信息\nfunc (c *Caller) WebInit(ctx context.Context, request *BaseRequest) (*WebInitResponse, error) {\n\tresp, err := c.Client.WebInit(ctx, request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar webInitResponse WebInitResponse\n\tdefer func() { _ = resp.Body.Close() }()\n\tif err = json.NewDecoder(resp.Body).Decode(&webInitResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = webInitResponse.BaseResponse.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &webInitResponse, nil\n}\n\ntype CallerCommonOptions struct {\n\tBaseRequest     *BaseRequest\n\tWebInitResponse *WebInitResponse\n\tLoginInfo       *LoginInfo\n}\n\ntype CallerWebWxStatusNotifyOptions CallerCommonOptions\n\n// WebWxStatusNotify 通知手机已登录\nfunc (c *Caller) WebWxStatusNotify(ctx context.Context, opt *CallerWebWxStatusNotifyOptions) error {\n\tnotifyOpt := &ClientWebWxStatusNotifyOptions{\n\t\tBaseRequest:     opt.BaseRequest,\n\t\tWebInitResponse: opt.WebInitResponse,\n\t\tLoginInfo:       opt.LoginInfo,\n\t}\n\tresp, err := c.Client.WebWxStatusNotify(ctx, notifyOpt)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerSyncCheckOptions CallerCommonOptions\n\n// SyncCheck 异步获取是否有新的消息\nfunc (c *Caller) SyncCheck(ctx context.Context, opt *CallerSyncCheckOptions) (*SyncCheckResponse, error) {\n\tsyncCheckOption := &ClientSyncCheckOptions{\n\t\tBaseRequest:     opt.BaseRequest,\n\t\tWebInitResponse: opt.WebInitResponse,\n\t\tLoginInfo:       opt.LoginInfo,\n\t}\n\tresp, err := c.Client.SyncCheck(ctx, syncCheckOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar buffer bytes.Buffer\n\tif _, err = buffer.ReadFrom(resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewSyncCheckResponse(buffer.Bytes())\n}\n\n// WebWxGetContact 获取所有的联系人\nfunc (c *Caller) WebWxGetContact(ctx context.Context, info *LoginInfo) (Members, error) {\n\tvar members Members\n\tvar reqs int64\n\tfor {\n\t\tresp, err := c.Client.WebWxGetContact(ctx, info.SKey, reqs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar item WebWxContactResponse\n\t\tif err = json.NewDecoder(resp.Body).Decode(&item); err != nil {\n\t\t\t_ = resp.Body.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = resp.Body.Close(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = item.BaseResponse.Err(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmembers = append(members, item.MemberList...)\n\n\t\tif item.Seq == 0 || item.Seq == reqs {\n\t\t\tbreak\n\t\t}\n\t\treqs = item.Seq\n\t}\n\treturn members, nil\n}\n\n// WebWxBatchGetContact 获取联系人的详情\n// 注: Members参数的长度不要大于50\nfunc (c *Caller) WebWxBatchGetContact(ctx context.Context, members Members, request *BaseRequest) (Members, error) {\n\tresp, err := c.Client.WebWxBatchGetContact(ctx, members, request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar item WebWxBatchContactResponse\n\tif err = json.NewDecoder(resp.Body).Decode(&item); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = item.BaseResponse.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn item.ContactList, nil\n}\n\ntype CallerWebWxSyncOptions CallerCommonOptions\n\n// WebWxSync 获取新的消息接口\nfunc (c *Caller) WebWxSync(ctx context.Context, opt *CallerWebWxSyncOptions) (*WebWxSyncResponse, error) {\n\twxSyncOption := &ClientWebWxSyncOptions{\n\t\tBaseRequest:     opt.BaseRequest,\n\t\tWebInitResponse: opt.WebInitResponse,\n\t\tLoginInfo:       opt.LoginInfo,\n\t}\n\tresp, err := c.Client.WebWxSync(ctx, wxSyncOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar webWxSyncResponse WebWxSyncResponse\n\tif err = json.NewDecoder(resp.Body).Decode(&webWxSyncResponse); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &webWxSyncResponse, nil\n}\n\ntype CallerWebWxSendMsgOptions struct {\n\tLoginInfo   *LoginInfo\n\tBaseRequest *BaseRequest\n\tMessage     *SendMessage\n}\n\n// WebWxSendMsg 发送消息接口\nfunc (c *Caller) WebWxSendMsg(ctx context.Context, opt *CallerWebWxSendMsgOptions) (*SentMessage, error) {\n\twxSendMsgOption := &ClientWebWxSendMsgOptions{\n\t\tBaseRequest: opt.BaseRequest,\n\t\tLoginInfo:   opt.LoginInfo,\n\t\tMessage:     opt.Message,\n\t}\n\tresp, err := c.Client.WebWxSendMsg(ctx, wxSendMsgOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.SentMessage(opt.Message)\n}\n\n// WebWxSendEmoticon 发送表情接口\nfunc (c *Caller) WebWxSendEmoticon(ctx context.Context, md5 string, reader io.Reader, opt *CallerWebWxSendAppMsgOptions) (*SentMessage, error) {\n\tmd5OrMediaid := md5\n\tif reader != nil {\n\t\tfile, cb, err := readerToFile(reader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer cb()\n\t\t// 首先尝试上传图片\n\t\tvar mediaId string\n\t\t{\n\t\t\tuploadMediaOption := &CallerUploadMediaOptions{\n\t\t\t\tFromUserName: opt.FromUserName,\n\t\t\t\tToUserName:   opt.ToUserName,\n\t\t\t\tBaseRequest:  opt.BaseRequest,\n\t\t\t\tLoginInfo:    opt.LoginInfo,\n\t\t\t}\n\t\t\tresp, err := c.UploadMedia(ctx, file, uploadMediaOption)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmediaId = resp.MediaId\n\t\t}\n\n\t\tmd5OrMediaid = mediaId\n\t}\n\n\tmsg := NewEmoticonSendMessage(opt.FromUserName, opt.ToUserName, md5OrMediaid)\n\n\twxSendMsgOption := &ClientWebWxSendMsgOptions{\n\t\tBaseRequest: opt.BaseRequest,\n\t\tLoginInfo:   opt.LoginInfo,\n\t\tMessage:     msg,\n\t}\n\tresp, err := c.Client.WebWxSendEmoticon(ctx, wxSendMsgOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.SentMessage(msg)\n}\n\ntype CallerWebWxOplogOptions struct {\n\tRemarkName  string\n\tToUserName  string\n\tBaseRequest *BaseRequest\n}\n\n// WebWxOplog 修改用户备注接口\nfunc (c *Caller) WebWxOplog(ctx context.Context, opt *CallerWebWxOplogOptions) error {\n\twxOpLogOption := &ClientWebWxOplogOption{\n\t\tRemarkName:  opt.RemarkName,\n\t\tUserName:    opt.ToUserName,\n\t\tBaseRequest: opt.BaseRequest,\n\t}\n\tresp, err := c.Client.WebWxOplog(ctx, wxOpLogOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerUploadMediaOptions struct {\n\tFromUserName string\n\tToUserName   string\n\tBaseRequest  *BaseRequest\n\tLoginInfo    *LoginInfo\n}\n\nfunc (c *Caller) UploadMedia(ctx context.Context, file *os.File, opt *CallerUploadMediaOptions) (*UploadResponse, error) {\n\t// 首先尝试上传图片\n\th := md5.New()\n\tif _, err := io.Copy(h, file); err != nil {\n\t\treturn nil, err\n\t}\n\tfileMd5 := hex.EncodeToString(h.Sum(nil))\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfilename := file.Name()\n\tfilesize := stat.Size()\n\n\tclientWebWxUploadMediaByChunkOpt := &ClientWebWxUploadMediaByChunkOptions{\n\t\tFromUserName:     opt.FromUserName,\n\t\tToUserName:       opt.ToUserName,\n\t\tBaseRequest:      opt.BaseRequest,\n\t\tLoginInfo:        opt.LoginInfo,\n\t\tFilename:         filename,\n\t\tFileMD5:          fileMd5,\n\t\tFileSize:         filesize,\n\t\tLastModifiedDate: stat.ModTime(),\n\t}\n\n\tif filesize > needCheckSize {\n\t\tcheckUploadRequest := webWxCheckUploadRequest{\n\t\t\tBaseRequest:  opt.BaseRequest,\n\t\t\tFileMd5:      fileMd5,\n\t\t\tFileName:     filename,\n\t\t\tFileSize:     filesize,\n\t\t\tFileType:     7,\n\t\t\tFromUserName: opt.FromUserName,\n\t\t\tToUserName:   opt.ToUserName,\n\t\t}\n\t\tresp, err := c.Client.webWxCheckUploadRequest(ctx, checkUploadRequest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer func() { _ = resp.Body.Close() }()\n\t\tvar checkUploadResponse webWxCheckUploadResponse\n\t\tif err = json.NewDecoder(resp.Body).Decode(&checkUploadResponse); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = checkUploadResponse.BaseResponse.Err(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// 如果已经上传过了，直接返回\n\t\tif checkUploadResponse.MediaId != \"\" {\n\t\t\tvar item UploadResponse\n\t\t\titem.MediaId = checkUploadResponse.MediaId\n\t\t\titem.Signature = checkUploadResponse.Signature\n\t\t\titem.BaseResponse = checkUploadResponse.BaseResponse\n\t\t\treturn &item, nil\n\t\t}\n\t\tclientWebWxUploadMediaByChunkOpt.AESKey = checkUploadResponse.AESKey\n\t\tclientWebWxUploadMediaByChunkOpt.Signature = checkUploadResponse.Signature\n\t}\n\n\tresp, err := c.Client.WebWxUploadMediaByChunk(ctx, file, clientWebWxUploadMediaByChunkOpt)\n\t// 无错误上传成功之后获取请求结果，判断结果是否正常\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar item UploadResponse\n\tif err = json.NewDecoder(resp.Body).Decode(&item); err != nil {\n\t\treturn &item, err\n\t}\n\tif err = item.BaseResponse.Err(); err != nil {\n\t\treturn &item, err\n\t}\n\tif len(item.MediaId) == 0 {\n\t\treturn &item, errors.New(\"upload failed\")\n\t}\n\titem.Signature = clientWebWxUploadMediaByChunkOpt.Signature\n\treturn &item, nil\n}\n\ntype CallerUploadMediaCommonOptions struct {\n\tFromUserName string\n\tToUserName   string\n\tBaseRequest  *BaseRequest\n\tLoginInfo    *LoginInfo\n}\n\ntype CallerWebWxSendImageMsgOptions CallerUploadMediaCommonOptions\n\n// WebWxSendImageMsg 发送图片消息接口\nfunc (c *Caller) WebWxSendImageMsg(ctx context.Context, reader io.Reader, opt *CallerWebWxSendImageMsgOptions) (*SentMessage, error) {\n\tfile, cb, err := readerToFile(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cb()\n\t// 首先尝试上传图片\n\tvar mediaId string\n\t{\n\t\tuploadMediaOption := &CallerUploadMediaOptions{\n\t\t\tFromUserName: opt.FromUserName,\n\t\t\tToUserName:   opt.ToUserName,\n\t\t\tBaseRequest:  opt.BaseRequest,\n\t\t\tLoginInfo:    opt.LoginInfo,\n\t\t}\n\t\tresp, err := c.UploadMedia(ctx, file, uploadMediaOption)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmediaId = resp.MediaId\n\t}\n\t// 构造新的图片类型的信息\n\tmsg := NewMediaSendMessage(MsgTypeImage, opt.FromUserName, opt.ToUserName, mediaId)\n\t// 发送图片信息\n\tsendImageOption := &ClientWebWxSendMsgOptions{\n\t\tBaseRequest: opt.BaseRequest,\n\t\tLoginInfo:   opt.LoginInfo,\n\t\tMessage:     msg,\n\t}\n\tresp, err := c.Client.WebWxSendMsgImg(ctx, sendImageOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.SentMessage(msg)\n}\n\ntype CallerWebWxSendFileOptions CallerUploadMediaCommonOptions\n\nfunc (c *Caller) WebWxSendFile(ctx context.Context, reader io.Reader, opt *CallerWebWxSendFileOptions) (*SentMessage, error) {\n\tfile, cb, err := readerToFile(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cb()\n\n\tuploadMediaOption := &CallerUploadMediaOptions{\n\t\tFromUserName: opt.FromUserName,\n\t\tToUserName:   opt.ToUserName,\n\t\tBaseRequest:  opt.BaseRequest,\n\t\tLoginInfo:    opt.LoginInfo,\n\t}\n\tresp, err := c.UploadMedia(ctx, file, uploadMediaOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// 构造新的文件类型的信息\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tappMsg := newFileAppMessage(stat, resp.MediaId)\n\tcontent, err := appMsg.XmlByte()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := NewSendMessage(AppMessage, string(content), opt.FromUserName, opt.ToUserName, \"\")\n\tmsg.Signature = resp.Signature\n\treturn c.WebWxSendAppMsg(ctx, msg, opt.BaseRequest)\n}\n\ntype CallerWebWxSendAppMsgOptions CallerUploadMediaCommonOptions\n\nfunc (c *Caller) WebWxSendVideoMsg(ctx context.Context, reader io.Reader, opt *CallerWebWxSendAppMsgOptions) (*SentMessage, error) {\n\tfile, cb, err := readerToFile(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cb()\n\tvar mediaId string\n\t{\n\t\tuploadMediaOption := &CallerUploadMediaOptions{\n\t\t\tFromUserName: opt.FromUserName,\n\t\t\tToUserName:   opt.ToUserName,\n\t\t\tBaseRequest:  opt.BaseRequest,\n\t\t\tLoginInfo:    opt.LoginInfo,\n\t\t}\n\t\tresp, err := c.UploadMedia(ctx, file, uploadMediaOption)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmediaId = resp.MediaId\n\t}\n\t// 构造新的图片类型的信息\n\tmsg := NewMediaSendMessage(MsgTypeVideo, opt.FromUserName, opt.ToUserName, mediaId)\n\tresp, err := c.Client.WebWxSendVideoMsg(ctx, opt.BaseRequest, msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.SentMessage(msg)\n}\n\n// WebWxSendAppMsg 发送媒体消息\nfunc (c *Caller) WebWxSendAppMsg(ctx context.Context, msg *SendMessage, req *BaseRequest) (*SentMessage, error) {\n\tresp, err := c.Client.WebWxSendAppMsg(ctx, msg, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.SentMessage(msg)\n}\n\n// Logout 用户退出\nfunc (c *Caller) Logout(ctx context.Context, info *LoginInfo) error {\n\tresp, err := c.Client.Logout(ctx, info)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerAddFriendIntoChatRoomOptions struct {\n\tBaseRequest *BaseRequest\n\tLoginInfo   *LoginInfo\n\tGroup       *Group\n\tGroupLength int\n\tFriends     []*Friend\n}\n\n// AddFriendIntoChatRoom 拉好友入群\nfunc (c *Caller) AddFriendIntoChatRoom(ctx context.Context, opt *CallerAddFriendIntoChatRoomOptions) error {\n\tif len(opt.Friends) == 0 {\n\t\treturn errors.New(\"no friends found\")\n\t}\n\tinviteMemberList := make([]string, len(opt.Friends))\n\tfor i, friend := range opt.Friends {\n\t\tinviteMemberList[i] = friend.UserName\n\t}\n\tclientAddMemberIntoChatRoomOption := &ClientAddMemberIntoChatRoomOption{\n\t\tBaseRequest:      opt.BaseRequest,\n\t\tLoginInfo:        opt.LoginInfo,\n\t\tGroup:            opt.Group.UserName,\n\t\tGroupLength:      opt.GroupLength,\n\t\tInviteMemberList: inviteMemberList,\n\t}\n\tresp, err := c.Client.AddMemberIntoChatRoom(ctx, clientAddMemberIntoChatRoomOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerRemoveFriendFromChatRoomOptions struct {\n\tBaseRequest *BaseRequest\n\tLoginInfo   *LoginInfo\n\tGroup       *Group\n\tMembers     []*User\n}\n\n// RemoveFriendFromChatRoom 从群聊中移除用户\nfunc (c *Caller) RemoveFriendFromChatRoom(ctx context.Context, opt *CallerRemoveFriendFromChatRoomOptions) error {\n\tif len(opt.Members) == 0 {\n\t\treturn errors.New(\"no users found\")\n\t}\n\tusers := make([]string, len(opt.Members))\n\tfor i, member := range opt.Members {\n\t\tusers[i] = member.UserName\n\t}\n\treq := &ClientRemoveMemberFromChatRoomOption{\n\t\tBaseRequest:   opt.BaseRequest,\n\t\tLoginInfo:     opt.LoginInfo,\n\t\tGroup:         opt.Group.UserName,\n\t\tDelMemberList: users,\n\t}\n\tresp, err := c.Client.RemoveMemberFromChatRoom(ctx, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerWebWxVerifyUserOptions struct {\n\tVerifyContent string\n\tRecommendInfo RecommendInfo\n\tBaseRequest   *BaseRequest\n\tLoginInfo     *LoginInfo\n}\n\n// WebWxVerifyUser 同意加好友请求\nfunc (c *Caller) WebWxVerifyUser(ctx context.Context, opt *CallerWebWxVerifyUserOptions) error {\n\twebWxVerifyUserOption := &ClientWebWxVerifyUserOption{\n\t\tBaseRequest:   opt.BaseRequest,\n\t\tLoginInfo:     opt.LoginInfo,\n\t\tVerifyContent: opt.VerifyContent,\n\t\tRecommendInfo: opt.RecommendInfo,\n\t}\n\tresp, err := c.Client.WebWxVerifyUser(ctx, webWxVerifyUserOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\n// WebWxRevokeMsg 撤回消息操作\nfunc (c *Caller) WebWxRevokeMsg(ctx context.Context, msg *SentMessage, request *BaseRequest) error {\n\tresp, err := c.Client.WebWxRevokeMsg(ctx, msg, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerWebWxStatusAsReadOptions struct {\n\tBaseRequest *BaseRequest\n\tLoginInfo   *LoginInfo\n\tMessage     *Message\n}\n\n// WebWxStatusAsRead 将消息设置为已读\nfunc (c *Caller) WebWxStatusAsRead(ctx context.Context, opt *CallerWebWxStatusAsReadOptions) error {\n\tstatusAsReadOption := &ClientWebWxStatusAsReadOption{\n\t\tRequest:   opt.BaseRequest,\n\t\tLoginInfo: opt.LoginInfo,\n\t\tMessage:   opt.Message,\n\t}\n\tresp, err := c.Client.WebWxStatusAsRead(ctx, statusAsReadOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\ntype CallerWebWxRelationPinOptions struct {\n\tBaseRequest *BaseRequest\n\tUser        *User\n\tOp          uint8\n}\n\n// WebWxRelationPin 将联系人是否置顶\nfunc (c *Caller) WebWxRelationPin(ctx context.Context, opt *CallerWebWxRelationPinOptions) error {\n\twebWxRelationPinOption := &ClientWebWxRelationPinOption{\n\t\tRequest:    opt.BaseRequest,\n\t\tOp:         opt.Op,\n\t\tRemarkName: opt.User.RemarkName,\n\t\tUserName:   opt.User.UserName,\n\t}\n\tresp, err := c.Client.WebWxRelationPin(ctx, webWxRelationPinOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\n// WebWxPushLogin 免扫码登陆接口\nfunc (c *Caller) WebWxPushLogin(ctx context.Context, uin int64) (*PushLoginResponse, error) {\n\tresp, err := c.Client.WebWxPushLogin(ctx, uin)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar item PushLoginResponse\n\tif err = json.NewDecoder(resp.Body).Decode(&item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}\n\ntype CallerWebWxCreateChatRoomOptions struct {\n\tBaseRequest *BaseRequest\n\tLoginInfo   *LoginInfo\n\tTopic       string\n\tFriends     Friends\n}\n\n// WebWxCreateChatRoom 创建群聊\nfunc (c *Caller) WebWxCreateChatRoom(ctx context.Context, opt *CallerWebWxCreateChatRoomOptions) (*Group, error) {\n\tif len(opt.Friends) == 0 {\n\t\treturn nil, errors.New(\"create group with no friends\")\n\t}\n\tfriends := make([]string, len(opt.Friends))\n\tfor i, friend := range opt.Friends {\n\t\tfriends[i] = friend.UserName\n\t}\n\twebWxCreateChatRoomOption := &ClientWebWxCreateChatRoomOption{\n\t\tRequest:   opt.BaseRequest,\n\t\tTopic:     opt.Topic,\n\t\tFriends:   friends,\n\t\tLoginInfo: opt.LoginInfo,\n\t}\n\tresp, err := c.Client.WebWxCreateChatRoom(ctx, webWxCreateChatRoomOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tvar item struct {\n\t\tBaseResponse BaseResponse\n\t\tChatRoomName string\n\t}\n\tif err = json.NewDecoder(resp.Body).Decode(&item); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = item.BaseResponse.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\tgroup := Group{User: &User{UserName: item.ChatRoomName}}\n\treturn &group, nil\n}\n\ntype CallerWebWxRenameChatRoomOptions struct {\n\tNewTopic    string\n\tBaseRequest *BaseRequest\n\tLoginInfo   *LoginInfo\n\tGroup       *Group\n}\n\n// WebWxRenameChatRoom 群组重命名\nfunc (c *Caller) WebWxRenameChatRoom(ctx context.Context, opt *CallerWebWxRenameChatRoomOptions) error {\n\twebWxRenameChatRoomOption := &ClientWebWxRenameChatRoomOption{\n\t\tRequest:   opt.BaseRequest,\n\t\tNewTopic:  opt.NewTopic,\n\t\tGroup:     opt.Group.UserName,\n\t\tLoginInfo: opt.LoginInfo,\n\t}\n\tresp, err := c.Client.WebWxRenameChatRoom(ctx, webWxRenameChatRoomOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\tparser := MessageResponseParser{resp.Body}\n\treturn parser.Err()\n}\n\n// SetMode 设置Client的模式\nfunc (c *Client) SetMode(mode Mode) {\n\tc.mode = mode\n}\n\n// MessageResponseParser 消息响应解析器\ntype MessageResponseParser struct {\n\tReader io.Reader\n}\n\n// Err 解析错误\nfunc (p *MessageResponseParser) Err() error {\n\tvar item struct{ BaseResponse BaseResponse }\n\tif err := json.NewDecoder(p.Reader).Decode(&item); err != nil {\n\t\treturn err\n\t}\n\tif err := item.BaseResponse.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// MsgID 解析消息ID\nfunc (p *MessageResponseParser) MsgID() (string, error) {\n\tvar messageResp MessageResponse\n\tif err := json.NewDecoder(p.Reader).Decode(&messageResp); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := messageResp.BaseResponse.Err(); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn messageResp.MsgID, nil\n}\n\n// SentMessage 返回 SentMessage\nfunc (p *MessageResponseParser) SentMessage(msg *SendMessage) (*SentMessage, error) {\n\tmsgID, err := p.MsgID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SentMessage{MsgId: msgID, SendMessage: msg}, nil\n}\n\nfunc readerToFile(reader io.Reader) (file *os.File, cb func(), err error) {\n\tvar ok bool\n\tif file, ok = reader.(*os.File); ok {\n\t\treturn file, func() {}, nil\n\t}\n\tfile, err = os.CreateTemp(\"\", \"*\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcb = func() {\n\t\t_ = file.Close()\n\t\t_ = os.Remove(file.Name())\n\t}\n\t_, err = io.Copy(file, reader)\n\tif err != nil {\n\t\tcb()\n\t\treturn nil, nil, err\n\t}\n\t_, err = file.Seek(0, io.SeekStart)\n\tif err != nil {\n\t\tcb()\n\t\treturn nil, nil, err\n\t}\n\treturn file, cb, nil\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 34.1630859375,
          "content": "package openwechat\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// HttpHook 请求上下文钩子\ntype HttpHook interface {\n\t// BeforeRequest 将在请求之前调用\n\tBeforeRequest(req *http.Request)\n\n\t// AfterRequest 将在请求之后调用，无论请求成功与否\n\tAfterRequest(response *http.Response, err error)\n}\n\n// HttpHooks 请求上下文钩子列表\ntype HttpHooks []HttpHook\n\n// BeforeRequest 将在请求之前调用\nfunc (h HttpHooks) BeforeRequest(req *http.Request) {\n\tif len(h) == 0 {\n\t\treturn\n\t}\n\tfor _, hook := range h {\n\t\thook.BeforeRequest(req)\n\t}\n}\n\n// AfterRequest 将在请求之后调用，无论请求成功与否\nfunc (h HttpHooks) AfterRequest(response *http.Response, err error) {\n\tif len(h) == 0 {\n\t\treturn\n\t}\n\tfor _, hook := range h {\n\t\thook.AfterRequest(response, err)\n\t}\n}\n\ntype UserAgentHook struct {\n\tUserAgent string\n}\n\nfunc (u UserAgentHook) BeforeRequest(req *http.Request) {\n\treq.Header.Set(\"User-Agent\", u.UserAgent)\n}\n\nfunc (u UserAgentHook) AfterRequest(_ *http.Response, _ error) {}\n\n// defaultUserAgentHook 默认的User-Agent钩子\nvar defaultUserAgentHook = UserAgentHook{\"Mozilla/5.0 (Linux; U; UOS x86_64; zh-cn) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 UOSBrowser/6.0.1.1001\"}\n\n// Client http请求客户端\n// 客户端需要维持Session会话\ntype Client struct {\n\t// 设置一些client的请求行为\n\t// see normalMode desktopMode\n\tmode Mode\n\n\t// client http客户端\n\tclient *http.Client\n\n\t// Domain 微信服务器请求域名\n\t// 这个参数会在登录成功后被赋值\n\t// 之后所有的请求都会使用这个域名\n\t// 在登录热登录和扫码登录时会被重新赋值\n\tDomain WechatDomain\n\n\t// HttpHooks 请求上下文钩子\n\tHttpHooks HttpHooks\n\n\t// MaxRetryTimes 最大重试次数\n\tMaxRetryTimes int\n}\n\n// NewClient 创建一个新的客户端\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\tpanic(\"http client is nil\")\n\t}\n\tclient := &Client{client: httpClient}\n\tclient.MaxRetryTimes = 1\n\tclient.SetCookieJar(NewJar())\n\treturn client\n}\n\n// DefaultClient 自动存储cookie\n// 设置客户端不自动跳转\nfunc DefaultClient() *Client {\n\thttpClient := &http.Client{\n\t\t// 设置客户端不自动跳转\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t\t// 设置30秒超时\n\t\t// 因为微信同步消息时是一个时间长达25秒的长轮训\n\t\tTimeout: 30 * time.Second,\n\t}\n\tclient := NewClient(httpClient)\n\tclient.AddHttpHook(defaultUserAgentHook)\n\tclient.MaxRetryTimes = 5\n\treturn client\n}\n\n// AddHttpHook 添加一个请求上下文钩子\nfunc (c *Client) AddHttpHook(hooks ...HttpHook) {\n\tc.HttpHooks = append(c.HttpHooks, hooks...)\n}\n\nfunc (c *Client) do(req *http.Request) (*http.Response, error) {\n\t// 确保请求能够被执行\n\tif c.MaxRetryTimes <= 0 {\n\t\tc.MaxRetryTimes = 1\n\t}\n\tvar (\n\t\tresp        *http.Response\n\t\terr         error\n\t\trequestBody *bytes.Reader\n\t)\n\n\tc.HttpHooks.BeforeRequest(req)\n\tdefer func() { c.HttpHooks.AfterRequest(resp, err) }()\n\tif req.Body != nil {\n\t\trawBody, err := io.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"io.ReadAll: %w\", err)\n\t\t}\n\t\trequestBody = bytes.NewReader(rawBody)\n\t}\n\tfor i := 0; i < c.MaxRetryTimes; i++ {\n\t\tif requestBody != nil {\n\t\t\t_, err := requestBody.Seek(0, io.SeekStart)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"requestBody.Seek: %w\", err)\n\t\t\t}\n\t\t\treq.Body = io.NopCloser(requestBody)\n\t\t}\n\t\tresp, err = c.client.Do(req)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\terr = errors.Join(NetworkErr, err)\n\t}\n\treturn resp, err\n}\n\nfunc (c *Client) Do(req *http.Request) (*http.Response, error) {\n\treturn c.do(req)\n}\n\n// Jar 返回当前client的 http.CookieJar\n// this http.CookieJar must be *Jar type\nfunc (c *Client) Jar() *Jar {\n\treturn c.client.Jar.(*Jar)\n}\n\n// SetCookieJar 设置cookieJar\n// 这里限制了cookieJar必须是Jar类型\n// 否则进行cookie序列化的时候因为字段的私有性无法进行所有字段的导出\nfunc (c *Client) SetCookieJar(jar *Jar) {\n\tc.client.Jar = jar\n}\n\n// HTTPClient 返回http.Client\n// 用于自定义http.Client的行为，如设置超时时间、设置代理、设置TLS配置等\nfunc (c *Client) HTTPClient() *http.Client {\n\treturn c.client\n}\n\n// GetLoginUUID 获取登录的uuid\nfunc (c *Client) GetLoginUUID(ctx context.Context) (*http.Response, error) {\n\treq, err := c.mode.BuildGetLoginUUIDRequest(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// GetLoginQrcode 获取登录的二维吗\nfunc (c *Client) GetLoginQrcode(ctx context.Context, uuid string) (*http.Response, error) {\n\tpath := qrcode + uuid\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.client.Do(req)\n}\n\n// CheckLogin 检查是否登录\nfunc (c *Client) CheckLogin(ctx context.Context, uuid, tip string) (*http.Response, error) {\n\tpath, err := url.Parse(login)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnow := time.Now().Unix()\n\tparams := url.Values{}\n\tparams.Add(\"r\", strconv.FormatInt(now/1579, 10))\n\tparams.Add(\"_\", strconv.FormatInt(now, 10))\n\tparams.Add(\"loginicon\", \"true\")\n\tparams.Add(\"uuid\", uuid)\n\tparams.Add(\"tip\", tip)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// GetLoginInfo 请求获取LoginInfo\nfunc (c *Client) GetLoginInfo(ctx context.Context, path *url.URL) (*http.Response, error) {\n\treq, err := c.mode.BuildGetLoginInfoRequest(ctx, path.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// WebInit 请求获取初始化信息\nfunc (c *Client) WebInit(ctx context.Context, request *BaseRequest) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxinit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"_\", fmt.Sprintf(\"%d\", time.Now().Unix()))\n\tpath.RawQuery = params.Encode()\n\tcontent := struct{ BaseRequest *BaseRequest }{BaseRequest: request}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientCommonOptions struct {\n\tBaseRequest     *BaseRequest\n\tWebInitResponse *WebInitResponse\n\tLoginInfo       *LoginInfo\n}\n\ntype ClientWebWxStatusNotifyOptions ClientCommonOptions\n\n// WebWxStatusNotify 通知手机已登录\nfunc (c *Client) WebWxStatusNotify(ctx context.Context, opt *ClientWebWxStatusNotifyOptions) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxstatusnotify)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tusername := opt.WebInitResponse.User.UserName\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\":  opt.BaseRequest,\n\t\t\"ClientMsgId\":  time.Now().Unix(),\n\t\t\"Code\":         3,\n\t\t\"FromUserName\": username,\n\t\t\"ToUserName\":   username,\n\t}\n\tpath.RawQuery = params.Encode()\n\tbuffer, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientSyncCheckOptions ClientCommonOptions\n\n// SyncCheck 异步检查是否有新的消息返回\nfunc (c *Client) SyncCheck(ctx context.Context, opt *ClientSyncCheckOptions) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.SyncHost() + synccheck)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"r\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tparams.Add(\"skey\", opt.LoginInfo.SKey)\n\tparams.Add(\"sid\", opt.LoginInfo.WxSid)\n\tparams.Add(\"uin\", strconv.FormatInt(opt.LoginInfo.WxUin, 10))\n\tparams.Add(\"deviceid\", opt.BaseRequest.DeviceID)\n\tparams.Add(\"_\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tvar syncKeyStringSlice = make([]string, opt.WebInitResponse.SyncKey.Count)\n\t// 将SyncKey里面的元素按照特定的格式拼接起来\n\tfor index, item := range opt.WebInitResponse.SyncKey.List {\n\t\ti := fmt.Sprintf(\"%d_%d\", item.Key, item.Val)\n\t\tsyncKeyStringSlice[index] = i\n\t}\n\tsyncKey := strings.Join(syncKeyStringSlice, \"|\")\n\tparams.Add(\"synckey\", syncKey)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// WebWxGetContact 获取联系人信息\nfunc (c *Client) WebWxGetContact(ctx context.Context, sKey string, reqs int64) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxgetcontact)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"r\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tparams.Add(\"skey\", sKey)\n\tparams.Add(\"seq\", strconv.FormatInt(reqs, 10))\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// WebWxBatchGetContact 获取联系人详情\nfunc (c *Client) WebWxBatchGetContact(ctx context.Context, members Members, request *BaseRequest) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxbatchgetcontact)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"type\", \"ex\")\n\tparams.Add(\"r\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tpath.RawQuery = params.Encode()\n\tlist := NewUserDetailItemList(members)\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": request,\n\t\t\"Count\":       members.Count(),\n\t\t\"List\":        list,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxSyncOptions ClientCommonOptions\n\n// WebWxSync 获取消息接口\nfunc (c *Client) WebWxSync(ctx context.Context, opt *ClientWebWxSyncOptions) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsync)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"sid\", opt.LoginInfo.WxSid)\n\tparams.Add(\"skey\", opt.LoginInfo.SKey)\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": opt.BaseRequest,\n\t\t\"SyncKey\":     opt.WebInitResponse.SyncKey,\n\t\t\"rr\":          strconv.FormatInt(time.Now().Unix(), 10),\n\t}\n\treader, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\n// 发送消息\nfunc (c *Client) sendMessage(ctx context.Context, request *BaseRequest, url string, msg *SendMessage) (*http.Response, error) {\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": request,\n\t\t\"Msg\":         msg,\n\t\t\"Scene\":       0,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxSendMsgOptions struct {\n\tLoginInfo   *LoginInfo\n\tBaseRequest *BaseRequest\n\tMessage     *SendMessage\n}\n\n// WebWxSendMsg 发送文本消息\nfunc (c *Client) WebWxSendMsg(ctx context.Context, opt *ClientWebWxSendMsgOptions) (*http.Response, error) {\n\topt.Message.Type = MsgTypeText\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsendmsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\treturn c.sendMessage(ctx, opt.BaseRequest, path.String(), opt.Message)\n}\n\n// WebWxSendMsg 发送表情消息\nfunc (c *Client) WebWxSendEmoticon(ctx context.Context, opt *ClientWebWxSendMsgOptions) (*http.Response, error) {\n\topt.Message.Type = MsgTypeText\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsendemoticon)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"sys\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\treturn c.sendMessage(ctx, opt.BaseRequest, path.String(), opt.Message)\n}\n\n// WebWxGetHeadImg 获取用户的头像\nfunc (c *Client) WebWxGetHeadImg(ctx context.Context, user *User) (*http.Response, error) {\n\tvar path string\n\tif user.HeadImgUrl != \"\" {\n\t\tpath = c.Domain.BaseHost() + user.HeadImgUrl\n\t} else {\n\t\tparams := url.Values{}\n\t\tparams.Add(\"username\", user.UserName)\n\t\tparams.Add(\"skey\", user.self.bot.Storage.Request.Skey)\n\t\tparams.Add(\"type\", \"big\")\n\t\tparams.Add(\"chatroomid\", user.EncryChatRoomId)\n\t\tparams.Add(\"seq\", \"0\")\n\t\tURL, err := url.Parse(c.Domain.BaseHost() + webwxgeticon)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tURL.RawQuery = params.Encode()\n\t\tpath = URL.String()\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\ntype webWxCheckUploadRequest struct {\n\tBaseRequest  *BaseRequest `json:\"BaseRequest\"`\n\tFileMd5      string       `json:\"FileMd5\"`\n\tFileName     string       `json:\"FileName\"`\n\tFileSize     int64        `json:\"FileSize\"`\n\tFileType     uint8        `json:\"FileType\"`\n\tFromUserName string       `json:\"FromUserName\"`\n\tToUserName   string       `json:\"ToUserName\"`\n}\n\ntype webWxCheckUploadResponse struct {\n\tBaseResponse  BaseResponse `json:\"BaseResponse\"`\n\tMediaId       string       `json:\"MediaId\"`\n\tAESKey        string       `json:\"AESKey\"`\n\tSignature     string       `json:\"Signature\"`\n\tEntryFileName string       `json:\"EncryFileName\"`\n}\n\nfunc (c *Client) webWxCheckUploadRequest(ctx context.Context, req webWxCheckUploadRequest) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxcheckupload)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := jsonEncode(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treqs, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treqs.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(reqs)\n}\n\ntype uploadMediaRequest struct {\n\tUploadType    uint8        `json:\"UploadType\"`\n\tBaseRequest   *BaseRequest `json:\"BaseRequest\"`\n\tClientMediaId int64        `json:\"ClientMediaId\"`\n\tTotalLen      int64        `json:\"TotalLen\"`\n\tStartPos      int          `json:\"StartPos\"`\n\tDataLen       int64        `json:\"DataLen\"`\n\tMediaType     uint8        `json:\"MediaType\"`\n\tFromUserName  string       `json:\"FromUserName\"`\n\tToUserName    string       `json:\"ToUserName\"`\n\tFileMd5       string       `json:\"FileMd5\"`\n\tAESKey        string       `json:\"AESKey,omitempty\"`\n\tSignature     string       `json:\"Signature,omitempty\"`\n}\n\ntype ClientWebWxUploadMediaByChunkOptions struct {\n\tFromUserName     string\n\tToUserName       string\n\tBaseRequest      *BaseRequest\n\tLoginInfo        *LoginInfo\n\tFilename         string\n\tFileMD5          string\n\tFileSize         int64\n\tLastModifiedDate time.Time\n\tAESKey           string\n\tSignature        string\n}\n\ntype UploadFile interface {\n\tio.ReaderAt\n\tio.ReadSeeker\n}\n\n// WebWxUploadMediaByChunk 分块上传文件\n// TODO 优化掉这个函数\nfunc (c *Client) WebWxUploadMediaByChunk(ctx context.Context, file UploadFile, opt *ClientWebWxUploadMediaByChunkOptions) (*http.Response, error) {\n\t// 获取文件上传的类型\n\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n\t\treturn nil, err\n\t}\n\tcontentType, err := GetFileContentType(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilename := opt.Filename\n\n\tif ext := filepath.Ext(filename); ext == \"\" {\n\t\tnames := strings.Split(contentType, \"/\")\n\t\tfilename = filename + \".\" + names[len(names)-1]\n\t}\n\n\t// 获取文件的类型\n\tmediaType := messageType(filename)\n\n\tpath, err := url.Parse(c.Domain.FileHost() + webwxuploadmedia)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"f\", \"json\")\n\n\tpath.RawQuery = params.Encode()\n\n\tcookies := c.Jar().Cookies(path)\n\n\twebWxDataTicket, err := wxDataTicket(cookies)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuploadMediaRequest := &uploadMediaRequest{\n\t\tUploadType:    2,\n\t\tBaseRequest:   opt.BaseRequest,\n\t\tClientMediaId: time.Now().Unix() * 1e4,\n\t\tTotalLen:      opt.FileSize,\n\t\tStartPos:      0,\n\t\tDataLen:       opt.FileSize,\n\t\tMediaType:     4,\n\t\tFromUserName:  opt.FromUserName,\n\t\tToUserName:    opt.ToUserName,\n\t\tFileMd5:       opt.FileMD5,\n\t\tAESKey:        opt.AESKey,\n\t\tSignature:     opt.Signature,\n\t}\n\n\tuploadMediaRequestByte, err := json.Marshal(uploadMediaRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 计算上传文件的次数\n\tchunks := int((opt.FileSize + chunkSize - 1) / chunkSize)\n\n\tcontent := map[string]string{\n\t\t\"id\":                \"WU_FILE_0\",\n\t\t\"name\":              filename,\n\t\t\"type\":              contentType,\n\t\t\"lastModifiedDate\":  opt.LastModifiedDate.Format(TimeFormat),\n\t\t\"size\":              strconv.FormatInt(opt.FileSize, 10),\n\t\t\"mediatype\":         mediaType,\n\t\t\"webwx_data_ticket\": webWxDataTicket,\n\t\t\"pass_ticket\":       opt.LoginInfo.PassTicket,\n\t}\n\n\tif chunks > 1 {\n\t\tcontent[\"chunks\"] = strconv.Itoa(chunks)\n\t}\n\n\tvar (\n\t\tresp       *http.Response\n\t\tformBuffer = bytes.NewBuffer(nil)\n\t)\n\n\tupload := func(chunk int, fileReader io.Reader) error {\n\t\tif chunks > 1 {\n\t\t\tcontent[\"chunk\"] = strconv.Itoa(chunk)\n\t\t}\n\t\tformBuffer.Reset()\n\n\t\twriter := multipart.NewWriter(formBuffer)\n\n\t\t// write form data\n\t\t{\n\t\t\tif err = writer.WriteField(\"uploadmediarequest\", string(uploadMediaRequestByte)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor k, v := range content {\n\t\t\t\tif err := writer.WriteField(k, v); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create form file\n\t\t\tfileWriter, err := writer.CreateFormFile(\"filename\", filename)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err = io.Copy(fileWriter, fileReader); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), formBuffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\n\t\tresp, err = c.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// parse response error\n\t\t{\n\t\t\tisLastTime := chunk+1 == chunks\n\t\t\tif !isLastTime {\n\t\t\t\tdefer func() { _ = resp.Body.Close() }()\n\t\t\t\tparser := MessageResponseParser{Reader: resp.Body}\n\t\t\t\terr = parser.Err()\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\t// 分块上传\n\tfor chunk := 0; chunk < chunks; chunk++ {\n\t\t// chunk reader\n\t\tselectionReader := io.NewSectionReader(file, int64(chunk)*chunkSize, chunkSize)\n\t\t// try to upload\n\t\tif err = upload(chunk, selectionReader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// 将最后一次携带文件信息的response返回\n\treturn resp, err\n}\n\n// WebWxSendMsgImg 发送图片\n// 这个接口依赖上传文件的接口\n// 发送的图片必须是已经成功上传的图片\nfunc (c *Client) WebWxSendMsgImg(ctx context.Context, opt *ClientWebWxSendMsgOptions) (*http.Response, error) {\n\topt.Message.Type = MsgTypeImage\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsendmsgimg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"async\")\n\tparams.Add(\"f\", \"json\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\treturn c.sendMessage(ctx, opt.BaseRequest, path.String(), opt.Message)\n}\n\n// WebWxSendAppMsg 发送文件信息\nfunc (c *Client) WebWxSendAppMsg(ctx context.Context, msg *SendMessage, request *BaseRequest) (*http.Response, error) {\n\tmsg.Type = AppMessage\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsendappmsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"async\")\n\tparams.Add(\"f\", \"json\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tpath.RawQuery = params.Encode()\n\treturn c.sendMessage(ctx, request, path.String(), msg)\n}\n\ntype ClientWebWxOplogOption struct {\n\tRemarkName  string\n\tUserName    string\n\tBaseRequest *BaseRequest\n}\n\n// WebWxOplog 用户重命名接口\nfunc (c *Client) WebWxOplog(ctx context.Context, opt *ClientWebWxOplogOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxoplog)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"lang\", \"zh_CN\")\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": opt.BaseRequest,\n\t\t\"CmdId\":       2,\n\t\t\"RemarkName\":  opt.RemarkName,\n\t\t\"UserName\":    opt.UserName,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxVerifyUserOption struct {\n\tRecommendInfo RecommendInfo\n\tVerifyContent string\n\tBaseRequest   *BaseRequest\n\tLoginInfo     *LoginInfo\n}\n\n// WebWxVerifyUser 添加用户为好友接口\nfunc (c *Client) WebWxVerifyUser(ctx context.Context, opt *ClientWebWxVerifyUserOption) (*http.Response, error) {\n\tloginInfo := opt.LoginInfo\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxverifyuser)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"r\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", loginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\":    opt.BaseRequest,\n\t\t\"Opcode\":         3,\n\t\t\"SceneList\":      [1]int{33},\n\t\t\"SceneListCount\": 1,\n\t\t\"VerifyContent\":  opt.VerifyContent,\n\t\t\"VerifyUserList\": []interface{}{map[string]string{\n\t\t\t\"Value\":            opt.RecommendInfo.UserName,\n\t\t\t\"VerifyUserTicket\": opt.RecommendInfo.Ticket,\n\t\t}},\n\t\t\"VerifyUserListSize\": 1,\n\t\t\"skey\":               opt.BaseRequest.Skey,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\n// WebWxGetMsgImg 获取图片消息的图片响应\nfunc (c *Client) WebWxGetMsgImg(ctx context.Context, msg *Message, info *LoginInfo) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxgetmsgimg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"MsgID\", msg.MsgId)\n\tparams.Add(\"skey\", info.SKey)\n\t// params.Add(\"type\", \"slave\")\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// WebWxGetVoice 获取语音消息的语音响应\nfunc (c *Client) WebWxGetVoice(ctx context.Context, msg *Message, info *LoginInfo) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxgetvoice)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"msgid\", msg.MsgId)\n\tparams.Add(\"skey\", info.SKey)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Referer\", path.String())\n\treq.Header.Add(\"Range\", \"bytes=0-\")\n\treturn c.Do(req)\n}\n\n// WebWxGetVideo 获取视频消息的视频响应\nfunc (c *Client) WebWxGetVideo(ctx context.Context, msg *Message, info *LoginInfo) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxgetvideo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"msgid\", msg.MsgId)\n\tparams.Add(\"skey\", info.SKey)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Referer\", path.String())\n\treq.Header.Add(\"Range\", \"bytes=0-\")\n\treturn c.Do(req)\n}\n\n// WebWxGetMedia 获取文件消息的文件响应\nfunc (c *Client) WebWxGetMedia(ctx context.Context, msg *Message, info *LoginInfo) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.FileHost() + webwxgetmedia)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcookies := c.Jar().Cookies(path)\n\twebWxDataTicket, err := wxDataTicket(cookies)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"sender\", msg.FromUserName)\n\tparams.Add(\"mediaid\", msg.MediaId)\n\tparams.Add(\"encryfilename\", msg.EncryFileName)\n\tparams.Add(\"fromuser\", strconv.FormatInt(info.WxUin, 10))\n\tparams.Add(\"pass_ticket\", info.PassTicket)\n\tparams.Add(\"webwx_data_ticket\", webWxDataTicket)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Referer\", c.Domain.BaseHost()+\"/\")\n\treturn c.Do(req)\n}\n\n// Logout 用户退出\nfunc (c *Client) Logout(ctx context.Context, info *LoginInfo) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxlogout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"redirect\", \"1\")\n\tparams.Add(\"type\", \"1\")\n\tparams.Add(\"skey\", info.SKey)\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\ntype ClientAddMemberIntoChatRoomOption struct {\n\tGroup            string\n\tGroupLength      int\n\tInviteMemberList []string\n\tBaseRequest      *BaseRequest\n\tLoginInfo        *LoginInfo\n}\n\n// AddMemberIntoChatRoom 添加用户进群聊\nfunc (c *Client) AddMemberIntoChatRoom(ctx context.Context, opt *ClientAddMemberIntoChatRoomOption) (*http.Response, error) {\n\tif opt.GroupLength >= 40 {\n\t\treturn c.InviteMemberIntoChatRoom(ctx, opt)\n\t}\n\treturn c.addMemberIntoChatRoom(ctx, opt)\n}\n\n// addMemberIntoChatRoom 添加用户进群聊\nfunc (c *Client) addMemberIntoChatRoom(ctx context.Context, opt *ClientAddMemberIntoChatRoomOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxupdatechatroom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"addmember\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tparams.Add(\"lang\", \"zh_CN\")\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"ChatRoomName\":  opt.Group,\n\t\t\"BaseRequest\":   opt.BaseRequest,\n\t\t\"AddMemberList\": strings.Join(opt.InviteMemberList, \",\"),\n\t}\n\tbuffer, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq.Header.Set(\"Content-Type\", jsonContentType)\n\treturn c.Do(httpReq)\n}\n\n// InviteMemberIntoChatRoom 邀请用户进群聊\nfunc (c *Client) InviteMemberIntoChatRoom(ctx context.Context, opt *ClientAddMemberIntoChatRoomOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxupdatechatroom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"invitemember\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tparams.Add(\"lang\", \"zh_CN\")\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"ChatRoomName\":     opt.Group,\n\t\t\"BaseRequest\":      opt.BaseRequest,\n\t\t\"InviteMemberList\": strings.Join(opt.InviteMemberList, \",\"),\n\t}\n\tbuffer, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq.Header.Set(\"Content-Type\", jsonContentType)\n\treturn c.Do(httpReq)\n}\n\ntype ClientRemoveMemberFromChatRoomOption struct {\n\tGroup         string\n\tDelMemberList []string\n\tBaseRequest   *BaseRequest\n\tLoginInfo     *LoginInfo\n}\n\n// RemoveMemberFromChatRoom 从群聊中移除用户\nfunc (c *Client) RemoveMemberFromChatRoom(ctx context.Context, opt *ClientRemoveMemberFromChatRoomOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxupdatechatroom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"delmember\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tcontent := map[string]interface{}{\n\t\t\"ChatRoomName\":  opt.Group,\n\t\t\"BaseRequest\":   opt.BaseRequest,\n\t\t\"DelMemberList\": strings.Join(opt.DelMemberList, \",\"),\n\t}\n\tbuffer, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpReq.Header.Set(\"Content-Type\", jsonContentType)\n\treturn c.Do(httpReq)\n}\n\n// WebWxRevokeMsg 撤回消息\nfunc (c *Client) WebWxRevokeMsg(ctx context.Context, msg *SentMessage, request *BaseRequest) (*http.Response, error) {\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": request,\n\t\t\"ClientMsgId\": msg.ClientMsgId,\n\t\t\"SvrMsgId\":    msg.MsgId,\n\t\t\"ToUserName\":  msg.ToUserName,\n\t}\n\tbuffer, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.Domain.BaseHost()+webwxrevokemsg, buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\n// 校验上传文件\n// nolint:unused\nfunc (c *Client) webWxCheckUpload(stat os.FileInfo, request *BaseRequest, fileMd5, fromUserName, toUserName string) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxcheckupload)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\":  request,\n\t\t\"FileMd5\":      fileMd5,\n\t\t\"FileName\":     stat.Name(),\n\t\t\"FileSize\":     stat.Size(),\n\t\t\"FileType\":     7,\n\t\t\"FromUserName\": fromUserName,\n\t\t\"ToUserName\":   toUserName,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequest(http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxStatusAsReadOption struct {\n\tLoginInfo *LoginInfo\n\tRequest   *BaseRequest\n\tMessage   *Message\n}\n\nfunc (c *Client) WebWxStatusAsRead(ctx context.Context, opt *ClientWebWxStatusAsReadOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxstatusnotify)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\":  opt.Request,\n\t\t\"DeviceID\":     opt.Request.DeviceID,\n\t\t\"Sid\":          opt.Request.Sid,\n\t\t\"Skey\":         opt.Request.Skey,\n\t\t\"Uin\":          opt.LoginInfo.WxUin,\n\t\t\"ClientMsgId\":  time.Now().Unix(),\n\t\t\"Code\":         1,\n\t\t\"FromUserName\": opt.Message.ToUserName,\n\t\t\"ToUserName\":   opt.Message.FromUserName,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxRelationPinOption struct {\n\tRequest    *BaseRequest\n\tOp         uint8\n\tRemarkName string\n\tUserName   string\n}\n\n// WebWxRelationPin 联系人置顶接口\nfunc (c *Client) WebWxRelationPin(ctx context.Context, opt *ClientWebWxRelationPinOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxoplog)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": opt.Request,\n\t\t\"CmdId\":       3,\n\t\t\"OP\":          opt.Op,\n\t\t\"RemarkName\":  opt.RemarkName,\n\t\t\"UserName\":    opt.UserName,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\n// WebWxPushLogin 免扫码登陆接口\nfunc (c *Client) WebWxPushLogin(ctx context.Context, uin int64) (*http.Response, error) {\n\treq, err := c.mode.BuildPushLoginRequest(ctx, c.Domain.BaseHost(), uin)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n// WebWxSendVideoMsg 发送视频消息接口\nfunc (c *Client) WebWxSendVideoMsg(ctx context.Context, request *BaseRequest, msg *SendMessage) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxsendvideomsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"async\")\n\tparams.Add(\"f\", \"json\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"pass_ticket\", \"pass_ticket\")\n\tpath.RawQuery = params.Encode()\n\treturn c.sendMessage(ctx, request, path.String(), msg)\n}\n\ntype ClientWebWxCreateChatRoomOption struct {\n\tRequest   *BaseRequest\n\tLoginInfo *LoginInfo\n\tTopic     string\n\tFriends   []string\n}\n\n// WebWxCreateChatRoom 创建群聊\nfunc (c *Client) WebWxCreateChatRoom(ctx context.Context, opt *ClientWebWxCreateChatRoomOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxcreatechatroom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tparams.Add(\"r\", fmt.Sprintf(\"%d\", time.Now().Unix()))\n\tpath.RawQuery = params.Encode()\n\tcount := len(opt.Friends)\n\tmemberList := make([]struct{ UserName string }, count)\n\tfor index, member := range opt.Friends {\n\t\tmemberList[index] = struct{ UserName string }{member}\n\t}\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\": opt.Request,\n\t\t\"MemberCount\": count,\n\t\t\"MemberList\":  memberList,\n\t\t\"Topic\":       opt.Topic,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n\ntype ClientWebWxRenameChatRoomOption struct {\n\tRequest   *BaseRequest\n\tLoginInfo *LoginInfo\n\tNewTopic  string\n\tGroup     string\n}\n\n// WebWxRenameChatRoom 群组重命名接口\nfunc (c *Client) WebWxRenameChatRoom(ctx context.Context, opt *ClientWebWxRenameChatRoomOption) (*http.Response, error) {\n\tpath, err := url.Parse(c.Domain.BaseHost() + webwxupdatechatroom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"fun\", \"modtopic\")\n\tparams.Add(\"pass_ticket\", opt.LoginInfo.PassTicket)\n\tpath.RawQuery = params.Encode()\n\tcontent := map[string]interface{}{\n\t\t\"BaseRequest\":  opt.Request,\n\t\t\"ChatRoomName\": opt.Group,\n\t\t\"NewTopic\":     opt.NewTopic,\n\t}\n\tbody, err := jsonEncode(content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", jsonContentType)\n\treturn c.Do(req)\n}\n"
        },
        {
          "name": "cookiejar.go",
          "type": "blob",
          "size": 1.8916015625,
          "content": "package openwechat\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/url\"\n)\n\n// Jar is a struct which as same as cookiejar.Jar\n// cookiejar.Jar's fields are private, so we can't use it directly\ntype Jar struct {\n\tjar   *cookiejar.Jar\n\thosts map[string]*url.URL\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface\nfunc (j *Jar) UnmarshalJSON(bytes []byte) error {\n\tvar cookies map[string][]*http.Cookie\n\tif err := json.Unmarshal(bytes, &cookies); err != nil {\n\t\treturn err\n\t}\n\tif j.jar == nil {\n\t\tj.jar, _ = cookiejar.New(nil)\n\t}\n\tfor u, cs := range cookies {\n\t\tu, err := url.Parse(u)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tj.jar.SetCookies(u, cs)\n\t}\n\treturn nil\n}\n\n// MarshalJSON implements the json.Marshaler interface\nfunc (j *Jar) MarshalJSON() ([]byte, error) {\n\tvar cookies = make(map[string][]*http.Cookie)\n\tfor path, u := range j.hosts {\n\t\tcookies[path] = append(cookies[path], j.jar.Cookies(u)...)\n\t}\n\treturn json.Marshal(cookies)\n}\n\nfunc (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie) {\n\tif j.hosts == nil {\n\t\tj.hosts = make(map[string]*url.URL)\n\t}\n\tpath := u.Scheme + \"://\" + u.Host\n\tif _, exists := j.hosts[path]; !exists {\n\t\tj.hosts[path] = u\n\t}\n\tj.jar.SetCookies(u, cookies)\n}\n\nfunc (j *Jar) Cookies(u *url.URL) []*http.Cookie {\n\treturn j.jar.Cookies(u)\n}\n\nfunc NewJar() *Jar {\n\tjar, _ := cookiejar.New(nil)\n\treturn &Jar{\n\t\tjar:   jar,\n\t\thosts: make(map[string]*url.URL),\n\t}\n}\n\n// CookieGroup is a group of cookies\ntype CookieGroup []*http.Cookie\n\nfunc (c CookieGroup) GetByName(cookieName string) (cookie *http.Cookie, exist bool) {\n\tfor _, cookie := range c {\n\t\tif cookie.Name == cookieName {\n\t\t\treturn cookie, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc wxDataTicket(cookies []*http.Cookie) (string, error) {\n\tcookieGroup := CookieGroup(cookies)\n\tcookie, exist := cookieGroup.GetByName(\"webwx_data_ticket\")\n\tif !exist {\n\t\treturn \"\", ErrWebWxDataTicketNotFound\n\t}\n\treturn cookie.Value, nil\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "emoji.go",
          "type": "blob",
          "size": 6.8837890625,
          "content": "package openwechat\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\temojiRegexp = regexp.MustCompile(`<span class=\"emoji emoji(.*?)\"></span>`)\n)\n\n// Emoji 表情\n// 字段太多了,污染命名空间,封装成struct返回\nvar Emoji = struct {\n\tSmile        string\n\tGrimace      string\n\tDrool        string\n\tScowl        string\n\tCoolGuy      string\n\tSob          string\n\tShy          string\n\tSilent       string\n\tSleep        string\n\tCry          string\n\tAwkward      string\n\tAngry        string\n\tTongue       string\n\tGrin         string\n\tSurprise     string\n\tFrown        string\n\tRuthless     string\n\tBlush        string\n\tScream       string\n\tPuke         string\n\tChuckle      string\n\tJoyful       string\n\tSlight       string\n\tSmug         string\n\tHungry       string\n\tDrowsy       string\n\tPanic        string\n\tSweat        string\n\tLaugh        string\n\tCommando     string\n\tDetermined   string\n\tScold        string\n\tShocked      string\n\tShhh         string\n\tDizzy        string\n\tTormented    string\n\tToasted      string\n\tSkull        string\n\tHammer       string\n\tWave         string\n\tSpeechless   string\n\tNosePick     string\n\tClap         string\n\tShame        string\n\tTrick        string\n\tBahL         string\n\tBahR         string\n\tYawn         string\n\tPoohPooh     string\n\tShrunken     string\n\tTearingUp    string\n\tSly          string\n\tKiss         string\n\tWrath        string\n\tWhimper      string\n\tCleaver      string\n\tWatermelon   string\n\tBeer         string\n\tBasketball   string\n\tPingPong     string\n\tCoffee       string\n\tRice         string\n\tPig          string\n\tRose         string\n\tWilt         string\n\tLips         string\n\tHeart        string\n\tBrokenHeart  string\n\tCake         string\n\tLightning    string\n\tBomb         string\n\tDagger       string\n\tSoccer       string\n\tLadybug      string\n\tPoop         string\n\tMoon         string\n\tSun          string\n\tGift         string\n\tHug          string\n\tThumbsUp     string\n\tThumbsDown   string\n\tShake        string\n\tPeace        string\n\tFight        string\n\tBeckon       string\n\tFist         string\n\tPinky        string\n\tRockOn       string\n\tNuhuh        string\n\tOK           string\n\tInLove       string\n\tBlowkiss     string\n\tWaddle       string\n\tTremble      string\n\tAaagh        string\n\tTwirl        string\n\tKotow        string\n\tDramatic     string\n\tJumpRope     string\n\tSurrender    string\n\tHooray       string\n\tMeditate     string\n\tSmooch       string\n\tTaiChiL      string\n\tTaiChiR      string\n\tHey          string\n\tFacepalm     string\n\tSmirk        string\n\tSmart        string\n\tMoue         string\n\tYeah         string\n\tTea          string\n\tPacket       string\n\tCandle       string\n\tBlessing     string\n\tChick        string\n\tOnlooker     string\n\tGoForIt      string\n\tSweats       string\n\tOMG          string\n\tEmm          string\n\tRespect      string\n\tDoge         string\n\tNoProb       string\n\tMyBad        string\n\tKeepFighting string\n\tWow          string\n\tRich         string\n\tBroken       string\n\tHurt         string\n\tSigh         string\n\tLetMeSee     string\n\tAwesome      string\n\tBoring       string\n}{\n\tSmile:        \"[微笑]\",\n\tGrimace:      \"[撇嘴]\",\n\tDrool:        \"[色]\",\n\tScowl:        \"[发呆]\",\n\tCoolGuy:      \"[得意]\",\n\tSob:          \"[流泪]\",\n\tShy:          \"[害羞]\",\n\tSilent:       \"[闭嘴]\",\n\tSleep:        \"[睡]\",\n\tCry:          \"[大哭]\",\n\tAwkward:      \"[尴尬]\",\n\tAngry:        \"[发怒]\",\n\tTongue:       \"[调皮]\",\n\tGrin:         \"[呲牙]\",\n\tSurprise:     \"[惊讶]\",\n\tFrown:        \"[难过]\",\n\tRuthless:     \"[酷]\",\n\tBlush:        \"[冷汗]\",\n\tScream:       \"[抓狂]\",\n\tPuke:         \"[吐]\",\n\tChuckle:      \"[偷笑]\",\n\tJoyful:       \"[愉快]\",\n\tSlight:       \"[白眼]\",\n\tSmug:         \"[傲慢]\",\n\tHungry:       \"[饥饿]\",\n\tDrowsy:       \"[困]\",\n\tPanic:        \"[惊恐]\",\n\tSweat:        \"[流汗]\",\n\tLaugh:        \"[憨笑]\",\n\tCommando:     \"[悠闲]\",\n\tDetermined:   \"[奋斗]\",\n\tScold:        \"[咒骂]\",\n\tShocked:      \"[疑问]\",\n\tShhh:         \"[嘘]\",\n\tDizzy:        \"[晕]\",\n\tTormented:    \"[疯了]\",\n\tToasted:      \"[衰]\",\n\tSkull:        \"[骷髅]\",\n\tHammer:       \"[敲打]\",\n\tWave:         \"[再见]\",\n\tSpeechless:   \"[擦汗]\",\n\tNosePick:     \"[抠鼻]\",\n\tClap:         \"[鼓掌]\",\n\tShame:        \"[糗大了]\",\n\tTrick:        \"[坏笑]\",\n\tBahL:         \"[左哼哼]\",\n\tBahR:         \"[右哼哼]\",\n\tYawn:         \"[哈欠]\",\n\tPoohPooh:     \"[鄙视]\",\n\tShrunken:     \"[委屈]\",\n\tTearingUp:    \"[快哭了]\",\n\tSly:          \"[阴险]\",\n\tKiss:         \"[亲亲]\",\n\tWrath:        \"[吓]\",\n\tWhimper:      \"[可怜]\",\n\tCleaver:      \"[菜刀]\",\n\tWatermelon:   \"[西瓜]\",\n\tBeer:         \"[啤酒]\",\n\tBasketball:   \"[篮球]\",\n\tPingPong:     \"[乒乓]\",\n\tCoffee:       \"[咖啡]\",\n\tRice:         \"[饭]\",\n\tPig:          \"[猪头]\",\n\tRose:         \"[玫瑰]\",\n\tWilt:         \"[凋谢]\",\n\tLips:         \"[嘴唇]\",\n\tHeart:        \"[爱心]\",\n\tBrokenHeart:  \"[心碎]\",\n\tCake:         \"[蛋糕]\",\n\tLightning:    \"[闪电]\",\n\tBomb:         \"[炸弹]\",\n\tDagger:       \"[刀]\",\n\tSoccer:       \"[足球]\",\n\tLadybug:      \"[瓢虫]\",\n\tPoop:         \"[便便]\",\n\tMoon:         \"[月亮]\",\n\tSun:          \"[太阳]\",\n\tGift:         \"[礼物]\",\n\tHug:          \"[拥抱]\",\n\tThumbsUp:     \"[强]\",\n\tThumbsDown:   \"[弱]\",\n\tShake:        \"[握手]\",\n\tPeace:        \"[胜利]\",\n\tFight:        \"[抱拳]\",\n\tBeckon:       \"[勾引]\",\n\tFist:         \"[拳头]\",\n\tPinky:        \"[差劲]\",\n\tRockOn:       \"[爱你]\",\n\tNuhuh:        \"[NO]\",\n\tOK:           \"[OK]\",\n\tInLove:       \"[爱情]\",\n\tBlowkiss:     \"[飞吻]\",\n\tWaddle:       \"[跳跳]\",\n\tTremble:      \"[发抖]\",\n\tAaagh:        \"[怄火]\",\n\tTwirl:        \"[转圈]\",\n\tKotow:        \"[磕头]\",\n\tDramatic:     \"[回头]\",\n\tJumpRope:     \"[跳绳]\",\n\tSurrender:    \"[投降]\",\n\tHooray:       \"[激动]\",\n\tMeditate:     \"[乱舞]\",\n\tSmooch:       \"[献吻]\",\n\tTaiChiL:      \"[左太极]\",\n\tTaiChiR:      \"[右太极]\",\n\tHey:          \"[嘿哈]\",\n\tFacepalm:     \"[捂脸]\",\n\tSmirk:        \"[奸笑]\",\n\tSmart:        \"[机智]\",\n\tMoue:         \"[皱眉]\",\n\tYeah:         \"[耶]\",\n\tTea:          \"[茶]\",\n\tPacket:       \"[红包]\",\n\tCandle:       \"[蜡烛]\",\n\tBlessing:     \"[福]\",\n\tChick:        \"[鸡]\",\n\tOnlooker:     \"[吃瓜]\",\n\tGoForIt:      \"[加油]\",\n\tSweats:       \"[汗]\",\n\tOMG:          \"[天啊]\",\n\tEmm:          \"[Emm]\",\n\tRespect:      \"[社会社会]\",\n\tDoge:         \"[旺柴]\",\n\tNoProb:       \"[好的]\",\n\tMyBad:        \"[打脸]\",\n\tKeepFighting: \"[加油加油]\",\n\tWow:          \"[哇]\",\n\tRich:         \"[發]\",\n\tBroken:       \"[裂开]\",\n\tHurt:         \"[苦涩]\",\n\tSigh:         \"[叹气]\",\n\tLetMeSee:     \"[让我看看]\",\n\tAwesome:      \"[666]\",\n\tBoring:       \"[翻白眼]\",\n}\n\nfunc FormatEmoji(text string) string {\n\tresult := emojiRegexp.FindAllStringSubmatch(text, -1)\n\n\tfor _, item := range result {\n\t\tif len(item) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tvalue := item[0]\n\t\temojiCodeStr := item[1]\n\t\temojiCode, err := strconv.ParseInt(emojiCodeStr, 16, 64)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\ttext = strings.Replace(text, value, fmt.Sprintf(\"%c\", emojiCode), -1)\n\t}\n\n\treturn text\n}\n"
        },
        {
          "name": "emoji_test.go",
          "type": "blob",
          "size": 1.080078125,
          "content": "package openwechat\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestFormatEmoji(t *testing.T) {\n\tt.Log(FormatEmoji(`多吃点苹果<span class=\"emoji emoji1f34f\"></span>高兴<span class=\"emoji emoji1f604\"></span><span class=\"emoji emoji1f604\"></span><span class=\"emoji emoji1f604\"></span> 生气<span class=\"emoji emoji1f64e\"></span> 点赞<span class=\"emoji emoji1f44d\"></span>`))\n}\n\nfunc BenchmarkFormatEmojiString(b *testing.B) {\n\tstr := `多吃点苹果<span class=\"emoji emoji1f34f\"></span>高兴<span class=\"emoji emoji1f604\"></span><span class=\"emoji emoji1f604\"></span><span class=\"emoji emoji1f604\"></span> 生气<span class=\"emoji emoji1f64e\"></span> 点赞<span class=\"emoji emoji1f44d\"></span>`\n\tb.SetBytes(int64(len(str)))\n\t// b.N会根据函数的运行时间取一个合适的值\n\tfor i := 0; i < b.N; i++ {\n\t\tFormatEmoji(str)\n\t}\n}\n\nfunc BenchmarkFormatEmojiBlock(b *testing.B) {\n\tstr := \"\"\n\tfor ii := 0x1F301; ii <= 0x1F53D; ii++ {\n\t\tstr += fmt.Sprintf(`<span class=\"emoji emoji%x\"></span> `, ii)\n\t}\n\tb.SetBytes(int64(len(str)))\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tFormatEmoji(str)\n\t}\n}\n"
        },
        {
          "name": "entity.go",
          "type": "blob",
          "size": 4.2109375,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n)\n\n/*\n一些网络返回信息的封装\n*/\n\n// LoginInfo 登录信息\ntype LoginInfo struct {\n\tRet         int    `xml:\"ret\"`\n\tWxUin       int64  `xml:\"wxuin\"`\n\tIsGrayScale int    `xml:\"isgrayscale\"`\n\tMessage     string `xml:\"message\"`\n\tSKey        string `xml:\"skey\"`\n\tWxSid       string `xml:\"wxsid\"`\n\tPassTicket  string `xml:\"pass_ticket\"`\n}\n\nfunc (l LoginInfo) Ok() bool {\n\treturn l.Ret == 0\n}\n\nfunc (l LoginInfo) Err() error {\n\tif l.Ok() {\n\t\treturn nil\n\t}\n\treturn errors.New(l.Message)\n}\n\n// BaseRequest 初始的请求信息\n// 几乎所有的请求都要携带该参数\ntype BaseRequest struct {\n\tUin                 int64\n\tSid, Skey, DeviceID string\n}\n\ntype SyncKey struct {\n\tCount int\n\tList  []struct{ Key, Val int64 }\n}\n\n// WebInitResponse 初始化的相应信息\ntype WebInitResponse struct {\n\tCount               int\n\tClientVersion       int\n\tGrayScale           int\n\tInviteStartCount    int\n\tMPSubscribeMsgCount int\n\tClickReportInterval int\n\tSystemTime          int64\n\tChatSet             string\n\tSKey                string\n\tBaseResponse        BaseResponse\n\tSyncKey             *SyncKey\n\tUser                *User\n\tMPSubscribeMsgList  []*MPSubscribeMsg\n\tContactList         Members\n}\n\n// MPSubscribeMsg 公众号的订阅信息\ntype MPSubscribeMsg struct {\n\tMPArticleCount int\n\tTime           int64\n\tUserName       string\n\tNickName       string\n\tMPArticleList  []*MPArticle\n}\n\ntype MPArticle struct {\n\tTitle  string\n\tCover  string\n\tDigest string\n\tUrl    string\n}\n\ntype UserDetailItem struct {\n\tUserName        string\n\tEncryChatRoomId string\n}\n\ntype UserDetailItemList []UserDetailItem\n\nfunc NewUserDetailItemList(members Members) UserDetailItemList {\n\tvar list = make(UserDetailItemList, len(members))\n\tfor index, member := range members {\n\t\titem := UserDetailItem{UserName: member.UserName, EncryChatRoomId: member.EncryChatRoomId}\n\t\tlist[index] = item\n\t}\n\treturn list\n}\n\ntype WebWxSyncResponse struct {\n\tAddMsgCount            int\n\tContinueFlag           int\n\tDelContactCount        int\n\tModChatRoomMemberCount int\n\tModContactCount        int\n\tSkey                   string\n\tSyncCheckKey           SyncKey\n\tSyncKey                *SyncKey\n\tBaseResponse           BaseResponse\n\tModChatRoomMemberList  Members\n\tAddMsgList             []*Message\n}\n\ntype WebWxContactResponse struct {\n\tMemberCount  int\n\tSeq          int64\n\tBaseResponse BaseResponse\n\tMemberList   []*User\n}\n\ntype WebWxBatchContactResponse struct {\n\tCount        int\n\tBaseResponse BaseResponse\n\tContactList  []*User\n}\n\n// CheckLoginResponse 检查登录状态的响应body\ntype CheckLoginResponse []byte\n\n// RedirectURL 重定向的URL\nfunc (c CheckLoginResponse) RedirectURL() (*url.URL, error) {\n\tcode, err := c.Code()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif code != LoginCodeSuccess {\n\t\treturn nil, fmt.Errorf(\"expect status code %s, but got %s\", LoginCodeSuccess, code)\n\t}\n\tresults := redirectUriRegexp.FindSubmatch(c)\n\tif len(results) != 2 {\n\t\treturn nil, errors.New(\"redirect url does not match\")\n\t}\n\treturn url.Parse(string(results[1]))\n}\n\n// Code 获取当前的登录检查状态的代码\nfunc (c CheckLoginResponse) Code() (LoginCode, error) {\n\tresults := statusCodeRegexp.FindSubmatch(c)\n\tif len(results) != 2 {\n\t\treturn \"\", errors.New(\"error status code match\")\n\t}\n\tcode := string(results[1])\n\treturn LoginCode(code), nil\n}\n\n// Avatar 获取扫码后的用户头像, base64编码\nfunc (c CheckLoginResponse) Avatar() (string, error) {\n\tcode, err := c.Code()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif code != LoginCodeScanned {\n\t\treturn \"\", nil\n\t}\n\tresults := avatarRegexp.FindSubmatch(c)\n\tif len(results) != 2 {\n\t\treturn \"\", errors.New(\"avatar does not match\")\n\t}\n\treturn string(results[1]), nil\n}\n\ntype MessageResponse struct {\n\tBaseResponse BaseResponse\n\tLocalID      string\n\tMsgID        string\n}\n\ntype UploadResponse struct {\n\tBaseResponse BaseResponse `json:\"BaseResponse\"`\n\tMediaId      string       `json:\"MediaId\"`\n\tSignature    string       `json:\"Signature\"`\n}\n\ntype PushLoginResponse struct {\n\tRet  string `json:\"ret\"`\n\tMsg  string `json:\"msg\"`\n\tUUID string `json:\"uuid\"`\n}\n\nfunc (p PushLoginResponse) Ok() bool {\n\treturn p.Ret == \"0\" && p.UUID != \"\"\n}\n\nfunc (p PushLoginResponse) Err() error {\n\tif p.Ok() {\n\t\treturn nil\n\t}\n\treturn errors.New(p.Msg)\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.19140625,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n)\n\nfunc IsNetworkError(err error) bool {\n\treturn errors.Is(err, NetworkErr)\n}\n\n// IgnoreNetworkError 忽略网络请求的错误\nfunc IgnoreNetworkError(errHandler func(err error)) func(error) {\n\treturn func(err error) {\n\t\tif !IsNetworkError(err) {\n\t\t\terrHandler(err)\n\t\t}\n\t}\n}\n\nvar (\n\t// ErrForbidden 禁止当前账号登录\n\tErrForbidden = errors.New(\"login forbidden\")\n\n\t// ErrInvalidStorage define invalid storage error\n\tErrInvalidStorage = errors.New(\"invalid storage\")\n\n\t// NetworkErr define wechat network error\n\tNetworkErr = errors.New(\"wechat network error\")\n\n\t// ErrNoSuchUserFound define no such user found error\n\tErrNoSuchUserFound = errors.New(\"no such user found\")\n\n\t// ErrLoginTimeout define login timeout error\n\tErrLoginTimeout = errors.New(\"login timeout\")\n\n\t// ErrWebWxDataTicketNotFound define webwx_data_ticket not found error\n\tErrWebWxDataTicketNotFound = errors.New(\"webwx_data_ticket not found\")\n\n\t// ErrUserLogout define user logout error\n\tErrUserLogout = errors.New(\"user logout\")\n\n\t// ErrUserNotLogin define user not login\n\tErrUserNotLogin = errors.New(\"user not login\")\n)\n\n// Error impl error interface\nfunc (r Ret) Error() string {\n\treturn r.String()\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 0.2294921875,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestIsNetworkError(t *testing.T) {\n\tvar err = errors.New(\"test error\")\n\terr = errors.Join(err, NetworkErr)\n\tif !IsNetworkError(err) {\n\t\tt.Error(\"err is not network error\")\n\t}\n}\n"
        },
        {
          "name": "generate.go",
          "type": "blob",
          "size": 0.1162109375,
          "content": "package openwechat\n\n\n//go:generate stringer -type=MessageType,Ret,AppMessageType -linecomment=true -output=stringer.go\n"
        },
        {
          "name": "global.go",
          "type": "blob",
          "size": 5.12890625,
          "content": "package openwechat\n\nimport (\n\t\"regexp\"\n)\n\nvar (\n\tuuidRegexp        = regexp.MustCompile(`uuid = \"(.*?)\";`)\n\tstatusCodeRegexp  = regexp.MustCompile(`window.code=(\\d+);`)\n\tavatarRegexp      = regexp.MustCompile(`window.userAvatar = '(.*)';`)\n\tsyncCheckRegexp   = regexp.MustCompile(`window.synccheck=\\{retcode:\"(\\d+)\",selector:\"(\\d+)\"\\}`)\n\tredirectUriRegexp = regexp.MustCompile(`window.redirect_uri=\"(.*?)\"`)\n)\n\nconst (\n\tappId           = \"wx782c26e4c19acffb\"\n\tappMessageAppId = \"wxeb7ec651dd0aefa9\"\n\n\tjsonContentType       = \"application/json; charset=utf-8\"\n\tuosPatchClientVersion = \"2.0.0\"\n\tuosPatchExtspam       = \"Go8FCIkFEokFCggwMDAwMDAwMRAGGvAESySibk50w5Wb3uTl2c2h64jVVrV7gNs06GFlWplHQbY/5FfiO++1yH4ykC\" +\n\t\t\"yNPWKXmco+wfQzK5R98D3so7rJ5LmGFvBLjGceleySrc3SOf2Pc1gVehzJgODeS0lDL3/I/0S2SSE98YgKleq6Uqx6ndTy9yaL9qFxJL7eiA/R\" +\n\t\t\"3SEfTaW1SBoSITIu+EEkXff+Pv8NHOk7N57rcGk1w0ZzRrQDkXTOXFN2iHYIzAAZPIOY45Lsh+A4slpgnDiaOvRtlQYCt97nmPLuTipOJ8Qc5p\" +\n\t\t\"M7ZsOsAPPrCQL7nK0I7aPrFDF0q4ziUUKettzW8MrAaiVfmbD1/VkmLNVqqZVvBCtRblXb5FHmtS8FxnqCzYP4WFvz3T0TcrOqwLX1M/DQvcHa\" +\n\t\t\"GGw0B0y4bZMs7lVScGBFxMj3vbFi2SRKbKhaitxHfYHAOAa0X7/MSS0RNAjdwoyGHeOepXOKY+h3iHeqCvgOH6LOifdHf/1aaZNwSkGotYnYSc\" +\n\t\t\"W8Yx63LnSwba7+hESrtPa/huRmB9KWvMCKbDThL/nne14hnL277EDCSocPu3rOSYjuB9gKSOdVmWsj9Dxb/iZIe+S6AiG29Esm+/eUacSba0k8\" +\n\t\t\"wn5HhHg9d4tIcixrxveflc8vi2/wNQGVFNsGO6tB5WF0xf/plngOvQ1/ivGV/C1Qpdhzznh0ExAVJ6dwzNg7qIEBaw+BzTJTUuRcPk92Sn6QDn\" +\n\t\t\"2Pu3mpONaEumacjW4w6ipPnPw+g2TfywJjeEcpSZaP4Q3YV5HG8D6UjWA4GSkBKculWpdCMadx0usMomsSS/74QgpYqcPkmamB4nVv1JxczYIT\" +\n\t\t\"IqItIKjD35IGKAUwAA==\"\n)\n\n// 消息类型\nconst (\n\tAppMessage = 6\n)\n\n// MessageType 以Go惯用形式定义了PC微信所有的官方消息类型。\n// 详见 message_test.go\ntype MessageType int\n\n// AppMessageType 以Go惯用形式定义了PC微信所有的官方App消息类型。\ntype AppMessageType int\n\n// https://res.wx.qq.com/a/wx_fed/webwx/res/static/js/index_c7d281c.js\n// MSGTYPE_TEXT\n// MSGTYPE_IMAGE\n// MSGTYPE_VOICE\n// MSGTYPE_VERIFYMSG\n// MSGTYPE_POSSIBLEFRIEND_MSG\n// MSGTYPE_SHARECARD\n// MSGTYPE_VIDEO\n// MSGTYPE_EMOTICON\n// MSGTYPE_LOCATION\n// MSGTYPE_APP\n// MSGTYPE_VOIPMSG\n// MSGTYPE_VOIPNOTIFY\n// MSGTYPE_VOIPINVITE\n// MSGTYPE_MICROVIDEO\n// MSGTYPE_SYS\n// MSGTYPE_RECALLED\n\nconst (\n\tMsgTypeText           MessageType = 1     // 文本消息\n\tMsgTypeImage          MessageType = 3     // 图片消息\n\tMsgTypeVoice          MessageType = 34    // 语音消息\n\tMsgTypeVerify         MessageType = 37    // 认证消息\n\tMsgTypePossibleFriend MessageType = 40    // 好友推荐消息\n\tMsgTypeShareCard      MessageType = 42    // 名片消息\n\tMsgTypeVideo          MessageType = 43    // 视频消息\n\tMsgTypeEmoticon       MessageType = 47    // 表情消息\n\tMsgTypeLocation       MessageType = 48    // 地理位置消息\n\tMsgTypeApp            MessageType = 49    // APP消息\n\tMsgTypeVoip           MessageType = 50    // VOIP消息\n\tMsgTypeVoipNotify     MessageType = 52    // VOIP结束消息\n\tMsgTypeVoipInvite     MessageType = 53    // VOIP邀请\n\tMsgTypeMicroVideo     MessageType = 62    // 小视频消息\n\tMsgTypeSys            MessageType = 10000 // 系统消息\n\tMsgTypeRecalled       MessageType = 10002 // 消息撤回\n)\n\nconst (\n\tAppMsgTypeText                  AppMessageType = 1      // 文本消息\n\tAppMsgTypeImg                   AppMessageType = 2      // 图片消息\n\tAppMsgTypeAudio                 AppMessageType = 3      // 语音消息\n\tAppMsgTypeVideo                 AppMessageType = 4      // 视频消息\n\tAppMsgTypeUrl                   AppMessageType = 5      // 文章消息\n\tAppMsgTypeAttach                AppMessageType = 6      // 附件消息\n\tAppMsgTypeOpen                  AppMessageType = 7      // Open\n\tAppMsgTypeEmoji                 AppMessageType = 8      // 表情消息\n\tAppMsgTypeVoiceRemind           AppMessageType = 9      // VoiceRemind\n\tAppMsgTypeScanGood              AppMessageType = 10     // ScanGood\n\tAppMsgTypeGood                  AppMessageType = 13     // Good\n\tAppMsgTypeEmotion               AppMessageType = 15     // Emotion\n\tAppMsgTypeCardTicket            AppMessageType = 16     // 名片消息\n\tAppMsgTypeRealtimeShareLocation AppMessageType = 17     // 地理位置消息\n\tAppMsgTypeTransfers             AppMessageType = 2000   // 转账消息\n\tAppMsgTypeRedEnvelopes          AppMessageType = 2001   // 红包消息\n\tAppMsgTypeReaderType            AppMessageType = 100001 //自定义的消息\n)\n\n// ALL 跟search函数搭配\n//\n//\tfriends.Search(openwechat.ALL, )\nconst ALL = 0\n\n// 性别\nconst (\n\tMALE   = 1\n\tFEMALE = 2\n)\n\nconst (\n\t// 文件大小单位\n\t_  = 1 << (10 * iota) // 1 << 0  = 1B\n\tKB                    // 1 << 10 = 1KB\n\tMB                    // 1 << 20 = 1MB\n)\n\nconst (\n\t// ChunkSize 分块上传时每次上传的文件大小 (512KB)\n\tchunkSize = 512 * KB\n\n\t// needCheckSize 需要检测的文件大小 (25MB)\n\tneedCheckSize = 25 * MB // nolint:unused\n\n\t// maxFileUploadSize 最大文件上传大小 (50MB)\n\tmaxFileUploadSize = 50 * MB // nolint:unused\n\n\t// maxImageUploadSize 最大图片上传大小 (20MB)\n\tmaxImageUploadSize = 20 * MB // nolint:unused\n)\n\nconst TimeFormat = \"Mon Jan 02 2006 15:04:05 GMT+0800 (中国标准时间)\"\n\n// FileHelper 文件传输助手\nconst FileHelper = \"filehelper\"\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0517578125,
          "content": "module github.com/eatmoreapple/openwechat\n\ngo 1.20\n\n\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 25.275390625,
          "content": "package openwechat\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Message struct {\n\tisAt    bool\n\tAppInfo struct {\n\t\tType  int\n\t\tAppID string\n\t}\n\tAppMsgType            AppMessageType\n\tHasProductId          int\n\tImgHeight             int\n\tImgStatus             int\n\tImgWidth              int\n\tForwardFlag           int\n\tMsgType               MessageType\n\tStatus                int\n\tStatusNotifyCode      int\n\tSubMsgType            int\n\tVoiceLength           int\n\tCreateTime            int64\n\tNewMsgId              int64\n\tPlayLength            int64\n\tMediaId               string\n\tMsgId                 string\n\tEncryFileName         string\n\tFileName              string\n\tFileSize              string\n\tContent               string\n\tFromUserName          string\n\tOriContent            string\n\tStatusNotifyUserName  string\n\tTicket                string\n\tToUserName            string\n\tUrl                   string\n\tsenderUserNameInGroup string\n\tRecommendInfo         RecommendInfo\n\tbot                   *Bot\n\tmu                    sync.RWMutex\n\tcontext               context.Context\n\titem                  map[string]interface{}\n\tRaw                   []byte `json:\"-\"`\n\tRawContent            string `json:\"-\"` // 消息原始内容\n}\n\n// Sender 获取消息的发送者\nfunc (m *Message) Sender() (*User, error) {\n\tif m.IsSendBySelf() {\n\t\treturn m.Owner().User, nil\n\t}\n\t// 首先尝试从缓存里面查找, 如果没有找到则从服务器获取\n\tmembers, err := m.bot.self.Members()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuser, exist := members.GetByUserName(m.FromUserName)\n\tif !exist {\n\t\t// 找不到, 从服务器获取\n\t\tuser = newFriend(m.FromUserName, m.Owner()).User\n\t\terr = user.Detail()\n\t}\n\tif m.IsSendByGroup() && len(user.MemberList) == 0 {\n\t\terr = user.Detail()\n\t}\n\treturn user, err\n}\n\n// SenderInGroup 获取消息在群里面的发送者\nfunc (m *Message) SenderInGroup() (*User, error) {\n\tif !m.IsComeFromGroup() {\n\t\treturn nil, errors.New(\"message is not from group\")\n\t}\n\t// 拍一拍系列的系统消息\n\t// https://github.com/eatmoreapple/openwechat/issues/66\n\tif m.IsSystem() {\n\t\t// 判断是否有自己发送\n\t\tif m.IsSendBySelf() {\n\t\t\treturn m.Owner().User, nil\n\t\t}\n\t\treturn nil, errors.New(\"can not found sender from system message\")\n\t}\n\tuser, err := m.Sender()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user.IsFriend() {\n\t\treturn user, nil\n\t}\n\tgroup := &Group{user}\n\treturn group.SearchMemberByUsername(m.senderUserNameInGroup)\n}\n\n// Receiver 获取消息的接收者\n// 如果消息是群组消息，则返回群组\n// 如果消息是好友消息，则返回好友\n// 如果消息是系统消息，则返回当前用户\nfunc (m *Message) Receiver() (*User, error) {\n\tif m.IsSystem() || m.ToUserName == m.bot.self.UserName {\n\t\treturn m.bot.self.User, nil\n\t}\n\t// https://github.com/eatmoreapple/openwechat/issues/113\n\tif m.ToUserName == FileHelper {\n\t\treturn m.Owner().FileHelper().User, nil\n\t}\n\n\tif m.IsSendByGroup() {\n\t\tgroups, err := m.Owner().Groups()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tusername := m.FromUserName\n\t\tif m.IsSendBySelf() {\n\t\t\tusername = m.ToUserName\n\t\t}\n\t\tusers := groups.SearchByUserName(1, username)\n\t\tif users.Count() == 0 {\n\t\t\tgroup := newUser(m.Owner(), username)\n\t\t\tif err := group.Detail(); err == nil {\n\t\t\t\treturn group, nil\n\t\t\t}\n\t\t\treturn nil, ErrNoSuchUserFound\n\t\t}\n\t\treturn users.First().User, nil\n\t} else {\n\t\tmembers, err := m.Owner().Members()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser, exist := members.GetByUserName(m.ToUserName)\n\t\tif !exist {\n\t\t\treturn nil, ErrNoSuchUserFound\n\t\t}\n\t\treturn user, nil\n\t}\n}\n\n// IsSendBySelf 判断消息是否由自己发送\nfunc (m *Message) IsSendBySelf() bool {\n\treturn m.FromUserName == m.Owner().UserName\n}\n\n// IsSendByFriend 判断消息是否由好友发送\nfunc (m *Message) IsSendByFriend() bool {\n\treturn !m.IsSendByGroup() && strings.HasPrefix(m.FromUserName, \"@\") && !m.IsSendBySelf()\n}\n\n// IsSendByGroup 判断消息是否由群组发送\nfunc (m *Message) IsSendByGroup() bool {\n\treturn strings.HasPrefix(m.FromUserName, \"@@\") || (m.IsSendBySelf() && strings.HasPrefix(m.ToUserName, \"@@\"))\n}\n\n// IsSelfSendToGroup 判断消息是否由自己发送到群组\nfunc (m *Message) IsSelfSendToGroup() bool {\n\treturn m.IsSendBySelf() && strings.HasPrefix(m.ToUserName, \"@@\")\n}\n\n// ReplyText 回复文本消息\nfunc (m *Message) ReplyText(content string) (*SentMessage, error) {\n\t// 判断是否由自己发送\n\tusername := m.FromUserName\n\tif m.IsSendBySelf() {\n\t\tusername = m.ToUserName\n\t}\n\treturn m.Owner().sendTextToUser(username, content)\n}\n\n// ReplyEmoticon 回复表情\nfunc (m *Message) ReplyEmoticon(md5 string, file io.Reader) (*SentMessage, error) {\n\t// 判断是否由自己发送\n\tusername := m.FromUserName\n\tif m.IsSendBySelf() {\n\t\tusername = m.ToUserName\n\t}\n\treturn m.Owner().sendEmoticonToUser(username, md5, file)\n}\n\n// ReplyImage 回复图片消息\nfunc (m *Message) ReplyImage(file io.Reader) (*SentMessage, error) {\n\t// 判断是否由自己发送\n\tusername := m.FromUserName\n\tif m.IsSendBySelf() {\n\t\tusername = m.ToUserName\n\t}\n\treturn m.Owner().sendImageToUser(username, file)\n}\n\n// ReplyVideo 回复视频消息\nfunc (m *Message) ReplyVideo(file io.Reader) (*SentMessage, error) {\n\t// 判断是否由自己发送\n\tusername := m.FromUserName\n\tif m.IsSendBySelf() {\n\t\tusername = m.ToUserName\n\t}\n\treturn m.Owner().sendVideoToUser(username, file)\n}\n\n// ReplyFile 回复文件消息\nfunc (m *Message) ReplyFile(file io.Reader) (*SentMessage, error) {\n\t// 判断是否由自己发送\n\tusername := m.FromUserName\n\tif m.IsSendBySelf() {\n\t\tusername = m.ToUserName\n\t}\n\treturn m.Owner().sendFileToUser(username, file)\n}\n\nfunc (m *Message) IsText() bool {\n\treturn m.MsgType == MsgTypeText && m.Url == \"\"\n}\n\nfunc (m *Message) IsLocation() bool {\n\treturn m.MsgType == MsgTypeText && strings.Contains(m.Url, \"apis.map.qq.com\") && strings.Contains(m.Content, \"pictype=location\")\n}\n\nfunc (m *Message) IsRealtimeLocation() bool {\n\treturn m.IsRealtimeLocationStart() || m.IsRealtimeLocationStop()\n}\n\nfunc (m *Message) IsRealtimeLocationStart() bool {\n\treturn m.MsgType == MsgTypeApp && m.AppMsgType == AppMsgTypeRealtimeShareLocation\n}\n\nfunc (m *Message) IsRealtimeLocationStop() bool {\n\treturn m.MsgType == MsgTypeSys && m.Content == \"位置共享已经结束\"\n}\n\nfunc (m *Message) IsPicture() bool {\n\treturn m.MsgType == MsgTypeImage\n}\n\n// IsEmoticon 是否为表情包消息\nfunc (m *Message) IsEmoticon() bool {\n\treturn m.MsgType == MsgTypeEmoticon\n}\n\nfunc (m *Message) IsVoice() bool {\n\treturn m.MsgType == MsgTypeVoice\n}\n\nfunc (m *Message) IsFriendAdd() bool {\n\treturn m.MsgType == MsgTypeVerify && m.FromUserName == \"fmessage\"\n}\n\nfunc (m *Message) IsCard() bool {\n\treturn m.MsgType == MsgTypeShareCard\n}\n\nfunc (m *Message) IsVideo() bool {\n\treturn m.MsgType == MsgTypeVideo || m.MsgType == MsgTypeMicroVideo\n}\n\nfunc (m *Message) IsMedia() bool {\n\treturn m.MsgType == MsgTypeApp\n}\n\n// IsRecalled 判断是否撤回\nfunc (m *Message) IsRecalled() bool {\n\treturn m.MsgType == MsgTypeRecalled\n}\n\nfunc (m *Message) IsSystem() bool {\n\treturn m.MsgType == MsgTypeSys\n}\n\nfunc (m *Message) IsNotify() bool {\n\treturn m.MsgType == 51 && m.StatusNotifyCode != 0\n}\n\n// IsTransferAccounts 判断当前的消息是不是微信转账\nfunc (m *Message) IsTransferAccounts() bool {\n\treturn m.IsMedia() && m.FileName == \"微信转账\"\n}\n\n// IsSendRedPacket 判断当前是否发出红包\nfunc (m *Message) IsSendRedPacket() bool {\n\treturn m.IsSystem() && m.Content == \"发出红包，请在手机上查看\"\n}\n\n// IsReceiveRedPacket 判断当前是否收到红包\nfunc (m *Message) IsReceiveRedPacket() bool {\n\treturn m.IsSystem() && m.Content == \"收到红包，请在手机上查看\"\n}\n\n// IsRenameGroup 判断当前是否是群组重命名\nfunc (m *Message) IsRenameGroup() bool {\n\treturn m.IsSystem() && strings.Contains(m.Content, \"修改群名为\")\n}\n\nfunc (m *Message) IsSysNotice() bool {\n\treturn m.MsgType == 9999\n}\n\n// StatusNotify 判断是否为操作通知消息\nfunc (m *Message) StatusNotify() bool {\n\treturn m.MsgType == 51\n}\n\n// HasFile 判断消息是否为文件类型的消息\nfunc (m *Message) HasFile() bool {\n\treturn m.IsPicture() || m.IsVoice() || m.IsVideo() || m.HasAttachment() || m.IsEmoticon()\n}\n\n// HasAttachment 是否有附件\nfunc (m *Message) HasAttachment() bool {\n\treturn m.IsMedia() && m.AppMsgType == AppMsgTypeAttach\n}\n\n// GetFile 获取文件消息的文件\nfunc (m *Message) GetFile() (*http.Response, error) {\n\tif !m.HasFile() {\n\t\treturn nil, errors.New(\"invalid message type\")\n\t}\n\tswitch {\n\tcase m.IsPicture() || m.IsEmoticon():\n\t\treturn m.bot.Caller.Client.WebWxGetMsgImg(m.Context(), m, m.bot.Storage.LoginInfo)\n\tcase m.IsVoice():\n\t\treturn m.bot.Caller.Client.WebWxGetVoice(m.Context(), m, m.bot.Storage.LoginInfo)\n\tcase m.IsVideo():\n\t\treturn m.bot.Caller.Client.WebWxGetVideo(m.Context(), m, m.bot.Storage.LoginInfo)\n\tcase m.IsMedia() && m.AppMsgType == AppMsgTypeAttach:\n\t\treturn m.bot.Caller.Client.WebWxGetMedia(m.Context(), m, m.bot.Storage.LoginInfo)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported type\")\n\t}\n}\n\n// GetPicture 获取图片消息的响应\nfunc (m *Message) GetPicture() (*http.Response, error) {\n\tif !(m.IsPicture() || m.IsEmoticon()) {\n\t\treturn nil, errors.New(\"picture message required\")\n\t}\n\treturn m.bot.Caller.Client.WebWxGetMsgImg(m.Context(), m, m.bot.Storage.LoginInfo)\n}\n\n// GetVoice 获取录音消息的响应\nfunc (m *Message) GetVoice() (*http.Response, error) {\n\tif !m.IsVoice() {\n\t\treturn nil, errors.New(\"voice message required\")\n\t}\n\treturn m.bot.Caller.Client.WebWxGetVoice(m.Context(), m, m.bot.Storage.LoginInfo)\n}\n\n// GetVideo 获取视频消息的响应\nfunc (m *Message) GetVideo() (*http.Response, error) {\n\tif !m.IsVideo() {\n\t\treturn nil, errors.New(\"video message required\")\n\t}\n\treturn m.bot.Caller.Client.WebWxGetVideo(m.Context(), m, m.bot.Storage.LoginInfo)\n}\n\n// GetMedia 获取媒体消息的响应\nfunc (m *Message) GetMedia() (*http.Response, error) {\n\tif !m.IsMedia() {\n\t\treturn nil, errors.New(\"media message required\")\n\t}\n\treturn m.bot.Caller.Client.WebWxGetMedia(m.Context(), m, m.bot.Storage.LoginInfo)\n}\n\n// SaveFile 保存文件到指定的 io.Writer\nfunc (m *Message) SaveFile(writer io.Writer) error {\n\tresp, err := m.GetFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\t_, err = io.Copy(writer, resp.Body)\n\treturn err\n}\n\n// SaveFileToLocal 保存文件到本地\nfunc (m *Message) SaveFileToLocal(filename string) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = file.Close() }()\n\treturn m.SaveFile(file)\n}\n\n// Card 获取card类型\nfunc (m *Message) Card() (*Card, error) {\n\tif !m.IsCard() {\n\t\treturn nil, errors.New(\"card message required\")\n\t}\n\tvar card Card\n\terr := xml.Unmarshal([]byte(m.Content), &card)\n\treturn &card, err\n}\n\n// FriendAddMessageContent 获取FriendAddMessageContent内容\nfunc (m *Message) FriendAddMessageContent() (*FriendAddMessage, error) {\n\tif !m.IsFriendAdd() {\n\t\treturn nil, errors.New(\"friend add message required\")\n\t}\n\tvar f FriendAddMessage\n\terr := xml.Unmarshal([]byte(m.Content), &f)\n\treturn &f, err\n}\n\n// RevokeMsg 获取撤回消息的内容\nfunc (m *Message) RevokeMsg() (*RevokeMsg, error) {\n\tif !m.IsRecalled() {\n\t\treturn nil, errors.New(\"recalled message required\")\n\t}\n\tvar r RevokeMsg\n\terr := xml.Unmarshal([]byte(m.Content), &r)\n\treturn &r, err\n}\n\n// Agree 同意好友的请求\nfunc (m *Message) Agree(verifyContents ...string) (*Friend, error) {\n\tif !m.IsFriendAdd() {\n\t\treturn nil, errors.New(\"friend add message required\")\n\t}\n\topt := &CallerWebWxVerifyUserOptions{\n\t\tVerifyContent: strings.Join(verifyContents, \"\"),\n\t\tRecommendInfo: m.RecommendInfo,\n\t\tBaseRequest:   m.bot.Storage.Request,\n\t\tLoginInfo:     m.bot.Storage.LoginInfo,\n\t}\n\terr := m.bot.Caller.WebWxVerifyUser(m.Context(), opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfriend := newFriend(m.RecommendInfo.UserName, m.Owner())\n\tif err = friend.Detail(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn friend, nil\n}\n\n// AsRead 将消息设置为已读\nfunc (m *Message) AsRead() error {\n\topt := &CallerWebWxStatusAsReadOptions{\n\t\tBaseRequest: m.bot.Storage.Request,\n\t\tLoginInfo:   m.bot.Storage.LoginInfo,\n\t\tMessage:     m,\n\t}\n\treturn m.bot.Caller.WebWxStatusAsRead(m.Context(), opt)\n}\n\n// IsArticle 判断当前的消息类型是否为文章\nfunc (m *Message) IsArticle() bool {\n\treturn m.AppMsgType == AppMsgTypeUrl\n}\n\n// MediaData 获取当前App Message的具体内容\nfunc (m *Message) MediaData() (*AppMessageData, error) {\n\tif !m.IsMedia() {\n\t\treturn nil, errors.New(\"media message required\")\n\t}\n\tvar data AppMessageData\n\tif err := xml.Unmarshal([]byte(m.Content), &data); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &data, nil\n}\n\n// Set 往消息上下文中设置值\n// goroutine safe\nfunc (m *Message) Set(key string, value interface{}) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tif m.item == nil {\n\t\tm.item = make(map[string]interface{})\n\t}\n\tm.item[key] = value\n}\n\n// Get 从消息上下文中获取值\n// goroutine safe\nfunc (m *Message) Get(key string) (value interface{}, exist bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tvalue, exist = m.item[key]\n\treturn\n}\n\n// 消息初始化,根据不同的消息作出不同的处理\nfunc (m *Message) init(bot *Bot) {\n\tm.bot = bot\n\tdefaultMessageProcessor.ProcessMessage(m)\n}\n\n// SendMessage 发送消息的结构体\ntype SendMessage struct {\n\tType         MessageType\n\tContent      string\n\tFromUserName string\n\tToUserName   string\n\tLocalID      string\n\tClientMsgId  string\n\tMediaId      string `json:\"MediaId,omitempty\"`\n\tEmojiFlag    int    `json:\"EmojiFlag,omitempty\"`\n\tEMoticonMd5  string `json:\"EMoticonMd5,omitempty\"`\n\tSignature    string `json:\"Signature,omitempty\"`\n}\n\n// NewSendMessage SendMessage的构造方法\nfunc NewSendMessage(msgType MessageType, content, fromUserName, toUserName, mediaId string) *SendMessage {\n\tid := strconv.FormatInt(time.Now().UnixNano()/1e2, 10)\n\treturn &SendMessage{\n\t\tType:         msgType,\n\t\tContent:      content,\n\t\tFromUserName: fromUserName,\n\t\tToUserName:   toUserName,\n\t\tLocalID:      id,\n\t\tClientMsgId:  id,\n\t\tMediaId:      mediaId,\n\t}\n}\n\n// NewTextSendMessage 文本消息的构造方法\nfunc NewTextSendMessage(content, fromUserName, toUserName string) *SendMessage {\n\treturn NewSendMessage(MsgTypeText, content, fromUserName, toUserName, \"\")\n}\n\n// NewMediaSendMessage 媒体消息的构造方法\nfunc NewMediaSendMessage(msgType MessageType, fromUserName, toUserName, mediaId string) *SendMessage {\n\treturn NewSendMessage(msgType, \"\", fromUserName, toUserName, mediaId)\n}\n\n// NewEmoticonSendMessage 表情消息的构造方法\nfunc NewEmoticonSendMessage(fromUserName, toUserName, md5OrMediaId string) *SendMessage {\n\tmsg := NewSendMessage(MsgTypeEmoticon, \"\", fromUserName, toUserName, \"\")\n\tmsg.EmojiFlag = 2\n\tif strings.HasPrefix(md5OrMediaId, \"@\") {\n\t\tmsg.MediaId = md5OrMediaId\n\t} else {\n\t\tmsg.EMoticonMd5 = md5OrMediaId\n\t}\n\treturn msg\n}\n\n// RecommendInfo 一些特殊类型的消息会携带该结构体信息\ntype RecommendInfo struct {\n\tOpCode     int\n\tScene      int\n\tSex        int\n\tVerifyFlag int\n\tAttrStatus int64\n\tQQNum      int64\n\tAlias      string\n\tCity       string\n\tContent    string\n\tNickName   string\n\tProvince   string\n\tSignature  string\n\tTicket     string\n\tUserName   string\n}\n\n// Card 名片消息内容\ntype Card struct {\n\tXMLName                 xml.Name `xml:\"msg\"`\n\tImageStatus             int      `xml:\"imagestatus,attr\"`\n\tScene                   int      `xml:\"scene,attr\"`\n\tSex                     int      `xml:\"sex,attr\"`\n\tCertflag                int      `xml:\"certflag,attr\"`\n\tBigHeadImgUrl           string   `xml:\"bigheadimgurl,attr\"`\n\tSmallHeadImgUrl         string   `xml:\"smallheadimgurl,attr\"`\n\tUserName                string   `xml:\"username,attr\"`\n\tNickName                string   `xml:\"nickname,attr\"`\n\tShortPy                 string   `xml:\"shortpy,attr\"`\n\tAlias                   string   `xml:\"alias,attr\"` // Note: 这个是名片用户的微信号\n\tProvince                string   `xml:\"province,attr\"`\n\tCity                    string   `xml:\"city,attr\"`\n\tSign                    string   `xml:\"sign,attr\"`\n\tCertinfo                string   `xml:\"certinfo,attr\"`\n\tBrandIconUrl            string   `xml:\"brandIconUrl,attr\"`\n\tBrandHomeUr             string   `xml:\"brandHomeUr,attr\"`\n\tBrandSubscriptConfigUrl string   `xml:\"brandSubscriptConfigUrl,attr\"`\n\tBrandFlags              string   `xml:\"brandFlags,attr\"`\n\tRegionCode              string   `xml:\"regionCode,attr\"`\n}\n\n// FriendAddMessage 好友添加消息信息内容\ntype FriendAddMessage struct {\n\tXMLName           xml.Name `xml:\"msg\"`\n\tShortpy           string   `xml:\"shortpy,attr\"`\n\tImageStatus       int      `xml:\"imagestatus,attr\"`\n\tScene             int      `xml:\"scene,attr\"`\n\tPerCard           int      `xml:\"percard,attr\"`\n\tSex               int      `xml:\"sex,attr\"`\n\tAlbumFlag         int      `xml:\"albumflag,attr\"`\n\tAlbumStyle        int      `xml:\"albumstyle,attr\"`\n\tSnsFlag           int      `xml:\"snsflag,attr\"`\n\tOpcode            int      `xml:\"opcode,attr\"`\n\tFromUserName      string   `xml:\"fromusername,attr\"`\n\tEncryptUserName   string   `xml:\"encryptusername,attr\"`\n\tFromNickName      string   `xml:\"fromnickname,attr\"`\n\tContent           string   `xml:\"content,attr\"`\n\tCountry           string   `xml:\"country,attr\"`\n\tProvince          string   `xml:\"province,attr\"`\n\tCity              string   `xml:\"city,attr\"`\n\tSign              string   `xml:\"sign,attr\"`\n\tAlias             string   `xml:\"alias,attr\"`\n\tWeiBo             string   `xml:\"weibo,attr\"`\n\tAlbumBgImgId      string   `xml:\"albumbgimgid,attr\"`\n\tSnsBgImgId        string   `xml:\"snsbgimgid,attr\"`\n\tSnsBgObjectId     string   `xml:\"snsbgobjectid,attr\"`\n\tMHash             string   `xml:\"mhash,attr\"`\n\tMFullHash         string   `xml:\"mfullhash,attr\"`\n\tBigHeadImgUrl     string   `xml:\"bigheadimgurl,attr\"`\n\tSmallHeadImgUrl   string   `xml:\"smallheadimgurl,attr\"`\n\tTicket            string   `xml:\"ticket,attr\"`\n\tGoogleContact     string   `xml:\"googlecontact,attr\"`\n\tQrTicket          string   `xml:\"qrticket,attr\"`\n\tChatRoomUserName  string   `xml:\"chatroomusername,attr\"`\n\tSourceUserName    string   `xml:\"sourceusername,attr\"`\n\tShareCardUserName string   `xml:\"sharecardusername,attr\"`\n\tShareCardNickName string   `xml:\"sharecardnickname,attr\"`\n\tCardVersion       string   `xml:\"cardversion,attr\"`\n\tBrandList         struct {\n\t\tCount int   `xml:\"count,attr\"`\n\t\tVer   int64 `xml:\"ver,attr\"`\n\t} `xml:\"brandlist\"`\n}\n\n// RevokeMsg 撤回消息Content\ntype RevokeMsg struct {\n\tSysMsg    xml.Name `xml:\"sysmsg\"`\n\tType      string   `xml:\"type,attr\"`\n\tRevokeMsg struct {\n\t\tOldMsgId   int64  `xml:\"oldmsgid\"`\n\t\tMsgId      int64  `xml:\"msgid\"`\n\t\tSession    string `xml:\"session\"`\n\t\tReplaceMsg string `xml:\"replacemsg\"`\n\t} `xml:\"revokemsg\"`\n}\n\n// SentMessage 已发送的信息\ntype SentMessage struct {\n\t*SendMessage\n\tself  *Self\n\tMsgId string\n}\n\n// Revoke 撤回该消息\nfunc (s *SentMessage) Revoke() error {\n\treturn s.self.RevokeMessage(s)\n}\n\n// CanRevoke 是否可以撤回该消息\nfunc (s *SentMessage) CanRevoke() bool {\n\ti, err := strconv.ParseInt(s.ClientMsgId, 10, 64)\n\tif err != nil {\n\t\treturn false\n\t}\n\tstart := time.Unix(i/10000000, 0)\n\treturn time.Since(start) < 2*time.Minute\n}\n\n// ForwardToFriends 转发该消息给好友\n// 该方法会阻塞直到所有好友都接收到消息\n// 这里为了兼容以前的版本，默认休眠0.5秒，如果需要更快的速度，可以使用 SentMessage.ForwardToFriendsWithDelay\nfunc (s *SentMessage) ForwardToFriends(friends ...*Friend) error {\n\treturn s.ForwardToFriendsWithDelay(time.Second/2, friends...)\n}\n\n// ForwardToFriendsWithDelay 转发该消息给好友，延迟指定时间\nfunc (s *SentMessage) ForwardToFriendsWithDelay(delay time.Duration, friends ...*Friend) error {\n\treturn s.self.ForwardMessageToFriends(s, delay, friends...)\n}\n\n// ForwardToGroups 转发该消息给群组\n// 该方法会阻塞直到所有群组都接收到消息\n// 这里为了兼容以前的版本，默认休眠0.5秒，如果需要更快的速度，可以使用 SentMessage.ForwardToGroupsDelay\nfunc (s *SentMessage) ForwardToGroups(groups ...*Group) error {\n\treturn s.ForwardToGroupsWithDelay(time.Second/2, groups...)\n}\n\n// ForwardToGroupsWithDelay 转发该消息给群组， 延迟指定时间\nfunc (s *SentMessage) ForwardToGroupsWithDelay(delay time.Duration, groups ...*Group) error {\n\treturn s.self.ForwardMessageToGroups(s, delay, groups...)\n}\n\ntype appmsg struct {\n\tType      int    `xml:\"type\"`\n\tAppId     string `xml:\"appid,attr\"` // wxeb7ec651dd0aefa9\n\tSdkVer    string `xml:\"sdkver,attr\"`\n\tTitle     string `xml:\"title\"`\n\tDes       string `xml:\"des\"`\n\tAction    string `xml:\"action\"`\n\tContent   string `xml:\"content\"`\n\tUrl       string `xml:\"url\"`\n\tLowUrl    string `xml:\"lowurl\"`\n\tExtInfo   string `xml:\"extinfo\"`\n\tAppAttach struct {\n\t\tTotalLen int64  `xml:\"totallen\"`\n\t\tAttachId string `xml:\"attachid\"`\n\t\tFileExt  string `xml:\"fileext\"`\n\t} `xml:\"appattach\"`\n}\n\nfunc (f appmsg) XmlByte() ([]byte, error) {\n\treturn xml.Marshal(f)\n}\n\nfunc newFileAppMessage(stat os.FileInfo, attachId string) *appmsg {\n\tm := &appmsg{AppId: appMessageAppId, Title: stat.Name()}\n\tm.AppAttach.AttachId = attachId\n\tm.AppAttach.TotalLen = stat.Size()\n\tm.Type = 6\n\tm.AppAttach.FileExt = fileExtension(stat.Name())\n\treturn m\n}\n\n// AppMessageData 获取APP消息的正文\n// See https://github.com/eatmoreapple/openwechat/issues/62\ntype AppMessageData struct {\n\tXMLName xml.Name `xml:\"msg\"`\n\tAppMsg  struct {\n\t\tAppid             string         `xml:\"appid,attr\"`\n\t\tSdkVer            string         `xml:\"sdkver,attr\"`\n\t\tTitle             string         `xml:\"title\"`\n\t\tDes               string         `xml:\"des\"`\n\t\tAction            string         `xml:\"action\"`\n\t\tType              AppMessageType `xml:\"type\"`\n\t\tShowType          string         `xml:\"showtype\"`\n\t\tContent           string         `xml:\"content\"`\n\t\tURL               string         `xml:\"url\"`\n\t\tDataUrl           string         `xml:\"dataurl\"`\n\t\tLowUrl            string         `xml:\"lowurl\"`\n\t\tLowDataUrl        string         `xml:\"lowdataurl\"`\n\t\tRecordItem        string         `xml:\"recorditem\"`\n\t\tThumbUrl          string         `xml:\"thumburl\"`\n\t\tMessageAction     string         `xml:\"messageaction\"`\n\t\tMd5               string         `xml:\"md5\"`\n\t\tExtInfo           string         `xml:\"extinfo\"`\n\t\tSourceUsername    string         `xml:\"sourceusername\"`\n\t\tSourceDisplayName string         `xml:\"sourcedisplayname\"`\n\t\tCommentUrl        string         `xml:\"commenturl\"`\n\t\tAppAttach         struct {\n\t\t\tTotalLen          string `xml:\"totallen\"`\n\t\t\tAttachId          string `xml:\"attachid\"`\n\t\t\tEmoticonMd5       string `xml:\"emoticonmd5\"`\n\t\t\tFileExt           string `xml:\"fileext\"`\n\t\t\tFileUploadToken   string `xml:\"fileuploadtoken\"`\n\t\t\tOverwriteNewMsgId string `xml:\"overwrite_newmsgid\"`\n\t\t\tFileKey           string `xml:\"filekey\"`\n\t\t\tCdnAttachUrl      string `xml:\"cdnattachurl\"`\n\t\t\tAesKey            string `xml:\"aeskey\"`\n\t\t\tEncryVer          string `xml:\"encryver\"`\n\t\t} `xml:\"appattach\"`\n\t\tWeAppInfo struct {\n\t\t\tPagePath       string `xml:\"pagepath\"`\n\t\t\tUsername       string `xml:\"username\"`\n\t\t\tAppid          string `xml:\"appid\"`\n\t\t\tAppServiceType string `xml:\"appservicetype\"`\n\t\t} `xml:\"weappinfo\"`\n\t\tWebSearch string `xml:\"websearch\"`\n\t} `xml:\"appmsg\"`\n\tFromUsername string `xml:\"fromusername\"`\n\tScene        string `xml:\"scene\"`\n\tAppInfo      struct {\n\t\tVersion string `xml:\"version\"`\n\t\tAppName string `xml:\"appname\"`\n\t} `xml:\"appinfo\"`\n\tCommentUrl string `xml:\"commenturl\"`\n}\n\n// IsFromApplet 判断当前的消息类型是否来自小程序\nfunc (a *AppMessageData) IsFromApplet() bool {\n\treturn a.AppMsg.Appid != \"\"\n}\n\n// IsArticle 判断当前的消息类型是否为文章\nfunc (a *AppMessageData) IsArticle() bool {\n\treturn a.AppMsg.Type == AppMsgTypeUrl\n}\n\n// IsFile 判断当前的消息类型是否为文件\nfunc (a AppMessageData) IsFile() bool {\n\treturn a.AppMsg.Type == AppMsgTypeAttach\n}\n\n// IsComeFromGroup 判断消息是否来自群组\n// 可能是自己或者别的群员发送\nfunc (m *Message) IsComeFromGroup() bool {\n\treturn m.IsSendByGroup() || (strings.HasPrefix(m.ToUserName, \"@@\") && m.IsSendBySelf())\n}\n\nfunc (m *Message) String() string {\n\treturn fmt.Sprintf(\"<%s:%s>\", m.MsgType, m.MsgId)\n}\n\n// IsAt 判断消息是否为@消息\nfunc (m *Message) IsAt() bool {\n\treturn m.isAt\n}\n\n// IsPaiYiPai 判断消息是否为拍一拍\n// 不要问我为什么取名为PaiYiPai，因为我也不知道取啥名字好\nfunc (m *Message) IsPaiYiPai() bool {\n\treturn m.IsTickled()\n}\n\n// IsJoinGroup 判断是否有人加入了群聊\nfunc (m *Message) IsJoinGroup() bool {\n\treturn m.IsSystem() && (strings.Contains(m.Content, \"加入了群聊\") || strings.Contains(m.Content, \"分享的二维码加入群聊\")) && m.IsSendByGroup()\n}\n\n// IsTickled 判断消息是否为拍一拍\nfunc (m *Message) IsTickled() bool {\n\treturn m.IsSystem() && (strings.Contains(m.Content, \"拍了拍\") || strings.Contains(m.Content, \"拍拍\"))\n}\n\n// IsTickledMe 判断消息是否拍了拍自己\nfunc (m *Message) IsTickledMe() bool {\n\treturn m.IsSystem() && (strings.Count(m.Content, \"拍了拍我\") == 1 || strings.Count(m.Content, \"拍拍我\") == 1)\n}\n\n// IsVoipInvite 判断消息是否为语音或视频通话邀请\nfunc (m *Message) IsVoipInvite() bool {\n\treturn m.MsgType == MsgTypeVoipInvite\n}\n\n// Bot 返回当前消息所属的Bot\nfunc (m *Message) Bot() *Bot {\n\treturn m.bot\n}\n\n// Owner 返回当前消息的拥有者\nfunc (m *Message) Owner() *Self {\n\treturn m.Bot().self\n}\n\nfunc (m *Message) Context() context.Context {\n\tif m.context == nil {\n\t\treturn m.Bot().Context()\n\t}\n\treturn m.context\n}\n\nfunc (m *Message) WithContext(ctx context.Context) {\n\tif ctx == nil {\n\t\tpanic(\"nil context\")\n\t}\n\tm.context = ctx\n}\n"
        },
        {
          "name": "message_handle.go",
          "type": "blob",
          "size": 10.08984375,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// MessageHandler 消息处理函数\ntype MessageHandler func(msg *Message)\n\n// MessageDispatcher 消息分发处理接口\n// 跟 DispatchMessage 结合封装成 MessageHandler\ntype MessageDispatcher interface {\n\tDispatch(msg *Message)\n}\n\n// MessageContextHandler 消息处理函数\ntype MessageContextHandler func(ctx *MessageContext)\n\ntype MessageContextHandlerGroup []MessageContextHandler\n\n// MessageContext 消息处理上下文对象\ntype MessageContext struct {\n\tindex           int\n\tabortIndex      int\n\tmessageHandlers MessageContextHandlerGroup\n\t*Message\n}\n\n// Next 主动调用下一个消息处理函数(或开始调用)\nfunc (c *MessageContext) Next() {\n\tc.index++\n\tfor c.index <= len(c.messageHandlers) {\n\t\tif c.IsAbort() {\n\t\t\treturn\n\t\t}\n\t\thandle := c.messageHandlers[c.index-1]\n\t\thandle(c)\n\t\tc.index++\n\t}\n}\n\n// IsAbort 判断是否被中断\nfunc (c *MessageContext) IsAbort() bool {\n\treturn c.abortIndex > 0\n}\n\n// Abort 中断当前消息处理, 不会调用下一个消息处理函数, 但是不会中断当前的处理函数\nfunc (c *MessageContext) Abort() {\n\tc.abortIndex = c.index\n}\n\n// AbortHandler 获取当前中断的消息处理函数\nfunc (c *MessageContext) AbortHandler() MessageContextHandler {\n\tif c.abortIndex > 0 {\n\t\treturn c.messageHandlers[c.abortIndex-1]\n\t}\n\treturn nil\n}\n\n// MatchFunc 消息匹配函数,返回为true则表示匹配\ntype MatchFunc func(*Message) bool\n\n// MatchFuncList 将多个MatchFunc封装成一个MatchFunc\nfunc MatchFuncList(matchFuncs ...MatchFunc) MatchFunc {\n\treturn func(message *Message) bool {\n\t\tfor _, matchFunc := range matchFuncs {\n\t\t\tif !matchFunc(message) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n\ntype matchNode struct {\n\tmatchFunc MatchFunc\n\tgroup     MessageContextHandlerGroup\n}\n\ntype matchNodes []*matchNode\n\n// MessageMatchDispatcher impl MessageDispatcher interface\n//\n//\tdispatcher := NewMessageMatchDispatcher()\n//\tdispatcher.OnText(func(msg *Message){\n//\t\t\tmsg.ReplyText(\"hello\")\n//\t})\n//\tbot := DefaultBot()\n//\tbot.MessageHandler = DispatchMessage(dispatcher)\ntype MessageMatchDispatcher struct {\n\tasync      bool\n\tmatchNodes matchNodes\n}\n\n// NewMessageMatchDispatcher Constructor\nfunc NewMessageMatchDispatcher() *MessageMatchDispatcher {\n\treturn &MessageMatchDispatcher{}\n}\n\n// SetAsync 设置是否异步处理\nfunc (m *MessageMatchDispatcher) SetAsync(async bool) {\n\tm.async = async\n}\n\n// Dispatch impl MessageDispatcher\n// 遍历 MessageMatchDispatcher 所有的消息处理函数\n// 获取所有匹配上的函数\n// 执行处理的消息处理方法\nfunc (m *MessageMatchDispatcher) Dispatch(msg *Message) {\n\tvar group MessageContextHandlerGroup\n\tfor _, node := range m.matchNodes {\n\t\tif node.matchFunc(msg) {\n\t\t\tgroup = append(group, node.group...)\n\t\t}\n\t}\n\tctx := &MessageContext{Message: msg, messageHandlers: group}\n\tif m.async {\n\t\tgo m.do(ctx)\n\t} else {\n\t\tm.do(ctx)\n\t}\n}\n\nfunc (m *MessageMatchDispatcher) do(ctx *MessageContext) {\n\tctx.Next()\n}\n\n// RegisterHandler 注册消息处理函数, 根据自己的需求自定义\n// matchFunc返回true则表示处理对应的handlers\nfunc (m *MessageMatchDispatcher) RegisterHandler(matchFunc MatchFunc, handlers ...MessageContextHandler) {\n\tif matchFunc == nil {\n\t\tpanic(\"MatchFunc can not be nil\")\n\t}\n\tnode := &matchNode{matchFunc: matchFunc, group: handlers}\n\tm.matchNodes = append(m.matchNodes, node)\n}\n\n// OnText 注册处理消息类型为Text的处理函数\nfunc (m *MessageMatchDispatcher) OnText(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsText() }, handlers...)\n}\n\n// OnImage 注册处理消息类型为Image的处理函数\nfunc (m *MessageMatchDispatcher) OnImage(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsPicture() }, handlers...)\n}\n\n// OnEmoticon 注册处理消息类型为Emoticon的处理函数(表情包)\nfunc (m *MessageMatchDispatcher) OnEmoticon(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsEmoticon() }, handlers...)\n}\n\n// OnVoice 注册处理消息类型为Voice的处理函数\nfunc (m *MessageMatchDispatcher) OnVoice(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsVoice() }, handlers...)\n}\n\n// OnFriendAdd 注册处理消息类型为FriendAdd的处理函数\nfunc (m *MessageMatchDispatcher) OnFriendAdd(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsFriendAdd() }, handlers...)\n}\n\n// OnCard 注册处理消息类型为Card的处理函数\nfunc (m *MessageMatchDispatcher) OnCard(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsCard() }, handlers...)\n}\n\n// OnMedia 注册处理消息类型为Media(多媒体消息，包括但不限于APP分享、文件分享)的处理函数\nfunc (m *MessageMatchDispatcher) OnMedia(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsMedia() }, handlers...)\n}\n\n// OnFriendByNickName 注册根据好友昵称是否匹配的消息处理函数\nfunc (m *MessageMatchDispatcher) OnFriendByNickName(nickName string, handlers ...MessageContextHandler) {\n\tmatchFunc := func(message *Message) bool {\n\t\tif message.IsSendByFriend() {\n\t\t\tsender, err := message.Sender()\n\t\t\treturn err == nil && sender.NickName == nickName\n\t\t}\n\t\treturn false\n\t}\n\tm.RegisterHandler(matchFunc, handlers...)\n}\n\n// OnFriend 注册发送者为好友的处理函数\nfunc (m *MessageMatchDispatcher) OnFriend(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsSendByFriend() }, handlers...)\n}\n\n// OnGroup 注册发送者为群组的处理函数\nfunc (m *MessageMatchDispatcher) OnGroup(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsSendByGroup() }, handlers...)\n}\n\n// OnUser 注册根据消息发送者的行为是否匹配的消息处理函数\nfunc (m *MessageMatchDispatcher) OnUser(f func(user *User) bool, handlers ...MessageContextHandler) {\n\tmf := func(message *Message) bool {\n\t\tsender, err := message.Sender()\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn f(sender)\n\t}\n\tm.RegisterHandler(mf, handlers...)\n}\n\n// OnFriendByRemarkName 注册根据好友备注是否匹配的消息处理函数\nfunc (m *MessageMatchDispatcher) OnFriendByRemarkName(remarkName string, handlers ...MessageContextHandler) {\n\tf := func(user *User) bool {\n\t\treturn user.IsFriend() && user.RemarkName == remarkName\n\t}\n\tm.OnUser(f, handlers...)\n}\n\n// OnGroupByGroupName 注册根据群名是否匹配的消息处理函数\nfunc (m *MessageMatchDispatcher) OnGroupByGroupName(groupName string, handlers ...MessageContextHandler) {\n\tf := func(user *User) bool {\n\t\treturn user.IsGroup() && user.NickName == groupName\n\t}\n\tm.OnUser(f, handlers...)\n}\n\n// OnTrickled 注册处理消息类型为拍一拍的处理函数\nfunc (m *MessageMatchDispatcher) OnTrickled(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsTickled() }, handlers...)\n}\n\n// OnRecalled 注册撤回消息类型的处理函数\nfunc (m *MessageMatchDispatcher) OnRecalled(handlers ...MessageContextHandler) {\n\tm.RegisterHandler(func(message *Message) bool { return message.IsRecalled() }, handlers...)\n}\n\n// AsMessageHandler 将MessageMatchDispatcher转换为MessageHandler\nfunc (m *MessageMatchDispatcher) AsMessageHandler() MessageHandler {\n\treturn func(msg *Message) {\n\t\tm.Dispatch(msg)\n\t}\n}\n\ntype MessageSenderMatchFunc func(user *User) bool\n\n// SenderMatchFunc 抽象的匹配发送者特征的处理函数\n//\n//\t    dispatcher := NewMessageMatchDispatcher()\n//\t\t   matchFuncList := MatchFuncList(SenderFriendRequired(), SenderNickNameContainsMatchFunc(\"多吃点苹果\"))\n//\t\t   dispatcher.RegisterHandler(matchFuncList, func(ctx *MessageContext) {\n//\t\t\t     do your own business\n//\t\t   })\nfunc SenderMatchFunc(matchFuncs ...MessageSenderMatchFunc) MatchFunc {\n\treturn func(message *Message) bool {\n\t\tsender, err := message.Sender()\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tfor _, matchFunc := range matchFuncs {\n\t\t\tif !matchFunc(sender) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n\n// SenderFriendRequired 只匹配好友\nfunc SenderFriendRequired() MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return user.IsFriend() })\n}\n\n// SenderGroupRequired 只匹配群组\nfunc SenderGroupRequired() MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return user.IsGroup() })\n}\n\n// SenderMpRequired 只匹配公众号\nfunc SenderMpRequired() MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return user.IsMP() })\n}\n\n// SenderNickNameEqualMatchFunc 根据用户昵称是否等于指定字符串的匹配函数\nfunc SenderNickNameEqualMatchFunc(nickname string) MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return user.NickName == nickname })\n}\n\n// SenderRemarkNameEqualMatchFunc 根据用户备注是否等于指定字符串的匹配函数\nfunc SenderRemarkNameEqualMatchFunc(remarkName string) MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return user.RemarkName == remarkName })\n}\n\n// SenderNickNameContainsMatchFunc 根据用户昵称是否包含指定字符串的匹配函数\nfunc SenderNickNameContainsMatchFunc(nickname string) MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return strings.Contains(user.NickName, nickname) })\n}\n\n// SenderRemakeNameContainsFunc  根据用户备注名是否包含指定字符串的匹配函数\nfunc SenderRemakeNameContainsFunc(remakeName string) MatchFunc {\n\treturn SenderMatchFunc(func(user *User) bool { return strings.Contains(user.RemarkName, remakeName) })\n}\n\n// MessageErrorHandler 获取消息时发生了错误的处理函数\n// 参数err为获取消息时发生的错误，返回值为处理后的错误\n// 如果返回nil，则表示忽略该错误，否则将继续传递该错误\ntype MessageErrorHandler func(err error) error\n\n// defaultMessageErrorHandler 默认的SyncCheck错误处理函数\nfunc defaultMessageErrorHandler(err error) error {\n\tvar ret Ret\n\tif errors.As(err, &ret) {\n\t\tswitch ret {\n\t\tcase failedLoginCheck, cookieInvalid, failedLoginWarn:\n\t\t\treturn ret\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "message_processor.go",
          "type": "blob",
          "size": 3.4619140625,
          "content": "package openwechat\n\nimport (\n\t\"encoding/json\"\n\t\"html\"\n\t\"strings\"\n)\n\ntype MessageProcessor interface {\n\tProcessMessage(msg *Message)\n}\n\ntype MessageProcessorGroup []MessageProcessor\n\nfunc (g MessageProcessorGroup) ProcessMessage(msg *Message) {\n\tfor _, processor := range g {\n\t\tprocessor.ProcessMessage(msg)\n\t}\n}\n\n// 保存消息原始内容\ntype messageRowContentProcessor struct{}\n\nfunc (m *messageRowContentProcessor) ProcessMessage(msg *Message) {\n\traw, _ := json.Marshal(msg)\n\tmsg.Raw = raw\n\tmsg.RawContent = msg.Content\n}\n\n// 保存发送者在群里的用户名\ntype senderInGroupMessageProcessor struct{}\n\nfunc (s *senderInGroupMessageProcessor) ProcessMessage(msg *Message) {\n\tif !msg.IsSendByGroup() || msg.IsSystem() || msg.IsSendBySelf() {\n\t\treturn\n\t}\n\tdata := strings.Split(msg.Content, \":<br/>\")\n\tif len(data) < 2 {\n\t\treturn\n\t}\n\tmsg.Content = strings.Join(data[1:], \"\")\n\tmsg.senderUserNameInGroup = data[0]\n}\n\n// 检查消息是否被@了, 不是特别严谨\ntype atMessageProcessor struct{}\n\nfunc (g *atMessageProcessor) ProcessMessage(msg *Message) {\n\tif !msg.IsSendByGroup() {\n\t\treturn\n\t}\n\tif msg.IsSystem() {\n\t\treturn\n\t}\n\tif msg.IsSendBySelf() {\n\t\t// 这块不严谨，但是只能这么干了\n\t\tmsg.isAt = strings.Contains(msg.Content, \"@\") || strings.Contains(msg.Content, \"\\u2005\")\n\t\treturn\n\t}\n\tif strings.Contains(msg.Content, \"@\") {\n\t\tsender, err := msg.Sender()\n\t\tif err == nil {\n\t\t\treceiver := sender.MemberList.SearchByUserName(1, msg.ToUserName)\n\t\t\tif receiver != nil {\n\t\t\t\tdisplayName := receiver.First().DisplayName\n\t\t\t\tif displayName == \"\" {\n\t\t\t\t\tdisplayName = receiver.First().NickName\n\t\t\t\t}\n\t\t\t\tvar atFlag string\n\t\t\t\tmsgContent := FormatEmoji(msg.Content)\n\t\t\t\tatName := FormatEmoji(displayName)\n\t\t\t\tif strings.Contains(msgContent, \"\\u2005\") {\n\t\t\t\t\tatFlag = \"@\" + atName + \"\\u2005\"\n\t\t\t\t} else {\n\t\t\t\t\tatFlag = \"@\" + atName\n\t\t\t\t}\n\t\t\t\tmsg.isAt = strings.Contains(msgContent, atFlag) || strings.HasSuffix(msgContent, atFlag)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 处理消息中的换行符\ntype wrapLineMessageProcessor struct{}\n\nfunc (w *wrapLineMessageProcessor) ProcessMessage(msg *Message) {\n\tmsg.Content = strings.Replace(msg.Content, `<br/>`, \"\\n\", -1)\n}\n\n// 处理消息中的html转义字符\ntype unescapeHTMLMessageProcessor struct{}\n\nfunc (u *unescapeHTMLMessageProcessor) ProcessMessage(msg *Message) {\n\tmsg.Content = html.UnescapeString(msg.Content)\n}\n\n// 处理消息中的emoji表情\ntype emojiMessageProcessor struct{}\n\nfunc (e *emojiMessageProcessor) ProcessMessage(msg *Message) {\n\tmsg.Content = FormatEmoji(msg.Content)\n}\n\n// 尝试获取群聊中的消息的发送者\ntype tryToFindGroupMessageProcessor struct{}\n\nfunc (t *tryToFindGroupMessageProcessor) ProcessMessage(msg *Message) {\n\tif msg.IsSendByGroup() {\n\t\tif msg.FromUserName == msg.Owner().UserName {\n\t\t\treturn\n\t\t}\n\t\t// 首先尝试从缓存里面查找, 如果没有找到则从服务器获取\n\t\tmembers, err := msg.Owner().Members()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\t_, exist := members.GetByUserName(msg.FromUserName)\n\t\tif !exist {\n\t\t\towner := msg.Owner()\n\t\t\t// 找不到, 从服务器获取\n\t\t\tuser := newUser(owner, msg.FromUserName)\n\t\t\t_ = user.Detail()\n\t\t\towner.members = owner.members.Append(user)\n\t\t\towner.groups = owner.members.Groups()\n\t\t}\n\t}\n}\n\nvar (\n\tdefaultMessageProcessor MessageProcessor = MessageProcessorGroup{\n\t\t&messageRowContentProcessor{},\n\t\t&senderInGroupMessageProcessor{},\n\t\t&atMessageProcessor{},\n\t\t&wrapLineMessageProcessor{},\n\t\t&unescapeHTMLMessageProcessor{},\n\t\t&emojiMessageProcessor{},\n\t\t&tryToFindGroupMessageProcessor{},\n\t}\n)\n"
        },
        {
          "name": "message_test.go",
          "type": "blob",
          "size": 2.6435546875,
          "content": "package openwechat\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc ExampleMessageType_output() {\n\tfor _, wxt := range []MessageType{\n\t\tMsgTypeText, MsgTypeImage, MsgTypeVoice, MsgTypeVerify,\n\t\tMsgTypePossibleFriend, MsgTypeShareCard, MsgTypeVideo, MsgTypeEmoticon,\n\t\tMsgTypeLocation, MsgTypeApp, MsgTypeVoip, MsgTypeVoipNotify,\n\t\tMsgTypeVoipInvite, MsgTypeMicroVideo, MsgTypeSys, MsgTypeRecalled} {\n\t\tfmt.Printf(\"收到一条%s(type %d)\\n\", wxt, wxt)\n\t}\n\tfmt.Println(\"=======\")\n\tfor _, wxt := range []MessageType{10000, 6, 51} {\n\t\twxtstr := wxt.String()\n\t\tif regexp.MustCompile(`^M`).MatchString(wxtstr) {\n\t\t\twxtstr = \"未知消息\"\n\t\t}\n\t\tfmt.Printf(\"收到一条%s(type %d): %s\\n\", wxtstr, wxt, wxt)\n\t}\n\t// Output:\n\t// 收到一条文本消息(type 1)\n\t// 收到一条图片消息(type 3)\n\t// 收到一条语音消息(type 34)\n\t// 收到一条认证消息(type 37)\n\t// 收到一条好友推荐消息(type 40)\n\t// 收到一条名片消息(type 42)\n\t// 收到一条视频消息(type 43)\n\t// 收到一条表情消息(type 47)\n\t// 收到一条地理位置消息(type 48)\n\t// 收到一条APP消息(type 49)\n\t// 收到一条VOIP消息(type 50)\n\t// 收到一条VOIP结束消息(type 52)\n\t// 收到一条VOIP邀请(type 53)\n\t// 收到一条小视频消息(type 62)\n\t// 收到一条系统消息(type 10000)\n\t// 收到一条消息撤回(type 10002)\n\t// =======\n\t// 收到一条系统消息(type 10000): 系统消息\n\t// 收到一条未知消息(type 6): MessageType(6)\n\t// 收到一条未知消息(type 51): MessageType(51)\n}\n\nfunc TestMessage_FriendAddMessageContent(t *testing.T) {\n\tm := &Message{\n\t\tMsgType:      37,\n\t\tFromUserName: \"fmessage\",\n\t\tContent:      \"<msg fromusername=\\\"user1\\\" encryptusername=\\\"123123131@stranger\\\" fromnickname=\\\"nickname1\\\" content=\\\"test11111\\\"  shortpy=\\\"MMHDNLXX\\\" imagestatus=\\\"3\\\" scene=\\\"3\\\" country=\\\"CN\\\" province=\\\"Zhejiang\\\" city=\\\"Hangzhou\\\" sign=\\\"Life is a struggle.\\\" percard=\\\"1\\\" sex=\\\"1\\\" alias=\\\"1111\\\" weibo=\\\"\\\" albumflag=\\\"0\\\" albumstyle=\\\"0\\\" albumbgimgid=\\\"\\\" snsflag=\\\"273\\\" snsbgimgid=\\\"http://shmmsns.qpic.cn/mbsFs/0\\\" snsbgobjectid=\\\"123123131\\\" mhash=\\\"1231231\\\" mfullhash=\\\"1231231\\\" bigheadimgurl=\\\"http://wx.qlogo.cn/mmhead/ver_1/1231231/0\\\" smallheadimgurl=\\\"http://wx.qlogo.cn/mmhead/ver_1/1231231/132\\\" ticket=\\\"1231231@stranger\\\" opcode=\\\"2\\\" googlecontact=\\\"\\\" qrticket=\\\"\\\" chatroomusername=\\\"123@chatroom\\\" sourceusername=\\\"\\\" sourcenickname=\\\"\\\" sharecardusername=\\\"\\\" sharecardnickname=\\\"\\\" cardversion=\\\"\\\" extflag=\\\"0\\\"><brandlist count=\\\"0\\\" ver=\\\"759291380\\\"></brandlist></msg>\",\n\t}\n\tfm, err := m.FriendAddMessageContent()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif fm.Shortpy != \"MMHDNLXX\" {\n\t\tt.Error(\"unexpected shorty:\", fm.Shortpy)\n\t}\n}\n"
        },
        {
          "name": "mode.go",
          "type": "blob",
          "size": 3.4765625,
          "content": "package openwechat\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Mode interface {\n\tBuildGetLoginUUIDRequest(ctx context.Context) (*http.Request, error)\n\tBuildGetLoginInfoRequest(ctx context.Context, path string) (*http.Request, error)\n\tBuildPushLoginRequest(ctx context.Context, host string, uin int64) (*http.Request, error)\n}\n\nvar (\n\t// normal 网页版模式\n\tnormal Mode = normalMode{}\n\n\t// desktop 桌面模式，uos electron套壳\n\tdesktop Mode = desktopMode{}\n)\n\ntype normalMode struct{}\n\nfunc (n normalMode) BuildGetLoginUUIDRequest(ctx context.Context) (*http.Request, error) {\n\tpath, err := url.Parse(jslogin)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tredirectUrl, err := url.Parse(webwxnewloginpage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams.Add(\"redirect_uri\", redirectUrl.String())\n\tparams.Add(\"appid\", appId)\n\tparams.Add(\"fun\", \"new\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"_\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tpath.RawQuery = params.Encode()\n\treturn http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n}\n\nfunc (n normalMode) BuildGetLoginInfoRequest(ctx context.Context, path string) (*http.Request, error) {\n\treturn http.NewRequestWithContext(ctx, http.MethodGet, path, nil)\n}\n\nfunc (n normalMode) PushLogin(ctx context.Context, client *Client, uin int64) (*http.Response, error) {\n\tpath, err := url.Parse(client.Domain.BaseHost() + webwxpushloginurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"uin\", strconv.FormatInt(uin, 10))\n\tpath.RawQuery = params.Encode()\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn client.Do(req)\n}\n\nfunc (n normalMode) BuildPushLoginRequest(ctx context.Context, host string, uin int64) (*http.Request, error) {\n\tpath, err := url.Parse(host + webwxpushloginurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"uin\", strconv.FormatInt(uin, 10))\n\tpath.RawQuery = params.Encode()\n\treturn http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n}\n\ntype desktopMode struct{}\n\nfunc (n desktopMode) BuildGetLoginUUIDRequest(ctx context.Context) (*http.Request, error) {\n\tpath, err := url.Parse(jslogin)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tredirectUrl, err := url.Parse(webwxnewloginpage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := url.Values{\"mod\": {\"desktop\"}}\n\tredirectUrl.RawQuery = p.Encode()\n\tparams.Add(\"redirect_uri\", redirectUrl.String())\n\tparams.Add(\"appid\", appId)\n\tparams.Add(\"fun\", \"new\")\n\tparams.Add(\"lang\", \"zh_CN\")\n\tparams.Add(\"_\", strconv.FormatInt(time.Now().UnixNano()/1e6, 10))\n\tpath.RawQuery = params.Encode()\n\treturn http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n}\n\nfunc (n desktopMode) BuildGetLoginInfoRequest(ctx context.Context, path string) (*http.Request, error) {\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"client-version\", uosPatchClientVersion)\n\treq.Header.Add(\"extspam\", uosPatchExtspam)\n\treturn req, nil\n}\n\nfunc (n desktopMode) BuildPushLoginRequest(ctx context.Context, host string, uin int64) (*http.Request, error) {\n\tpath, err := url.Parse(host + webwxpushloginurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparams := url.Values{}\n\tparams.Add(\"uin\", strconv.FormatInt(uin, 10))\n\tparams.Add(\"mod\", \"desktop\")\n\tpath.RawQuery = params.Encode()\n\treturn http.NewRequestWithContext(ctx, http.MethodGet, path.String(), nil)\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 1.501953125,
          "content": "package openwechat\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc jsonEncode(v interface{}) (io.Reader, error) {\n\tvar buffer = bytes.NewBuffer(nil)\n\tencoder := json.NewEncoder(buffer)\n\t// 这里要设置禁止html转义\n\tencoder.SetEscapeHTML(false)\n\tif err := encoder.Encode(v); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer, nil\n}\n\n// GetRandomDeviceId 获取随机设备id\nfunc GetRandomDeviceId() string {\n\trng := rand.New(rand.NewSource(time.Now().Unix()))\n\tvar builder strings.Builder\n\tbuilder.Grow(16)\n\tbuilder.WriteString(\"e\")\n\tfor i := 0; i < 15; i++ {\n\t\tr := rng.Intn(9)\n\t\tbuilder.WriteString(strconv.Itoa(r))\n\t}\n\treturn builder.String()\n}\n\n// GetFileContentType 获取文件上传的类型\nfunc GetFileContentType(file io.Reader) (string, error) {\n\tdata := make([]byte, 512)\n\tif _, err := file.Read(data); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn http.DetectContentType(data), nil\n}\n\n// fileExtension\nfunc fileExtension(name string) string {\n\text := strings.ToLower(filepath.Ext(name))\n\tif len(ext) == 0 {\n\t\treturn \"undefined\"\n\t}\n\treturn strings.TrimPrefix(ext, \".\")\n}\n\n// 判断是否是图片\nfunc isImageType(imageType string) bool {\n\tswitch imageType {\n\tcase \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// 微信匹配文件类型策略\nfunc messageType(filename string) string {\n\text := fileExtension(filename)\n\tif isImageType(ext) {\n\t\treturn \"pic\"\n\t}\n\tif ext == \"mp4\" {\n\t\treturn \"video\"\n\t}\n\treturn \"doc\"\n}\n"
        },
        {
          "name": "relations.go",
          "type": "blob",
          "size": 12.5625,
          "content": "package openwechat\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Friend struct{ *User }\n\n// implement fmt.Stringer\nfunc (f *Friend) String() string {\n\tdisplay := f.NickName\n\tif f.RemarkName != \"\" {\n\t\tdisplay = f.RemarkName\n\t}\n\treturn fmt.Sprintf(\"<Friend:%s>\", display)\n}\n\n// SetRemarkName 重命名当前好友\n// Deprecated\nfunc (f *Friend) SetRemarkName(name string) error {\n\treturn f.Self().SetRemarkNameToFriend(f, name)\n}\n\n// SendText  发送文本消息\nfunc (f *Friend) SendText(content string) (*SentMessage, error) {\n\treturn f.Self().SendTextToFriend(f, content)\n}\n\n// SendImage 发送图片消息\nfunc (f *Friend) SendImage(file io.Reader) (*SentMessage, error) {\n\treturn f.Self().SendImageToFriend(f, file)\n}\n\n// SendVideo 发送视频消息\nfunc (f *Friend) SendVideo(file io.Reader) (*SentMessage, error) {\n\treturn f.Self().SendVideoToFriend(f, file)\n}\n\n// SendFile 发送文件消息\nfunc (f *Friend) SendFile(file io.Reader) (*SentMessage, error) {\n\treturn f.Self().SendFileToFriend(f, file)\n}\n\n// AddIntoGroup 拉该好友入群\nfunc (f *Friend) AddIntoGroup(groups ...*Group) error {\n\treturn f.Self().AddFriendIntoManyGroups(f, groups...)\n}\n\ntype Friends []*Friend\n\n// Count 获取好友的数量\nfunc (f Friends) Count() int {\n\treturn len(f)\n}\n\n// First 获取第一个好友\nfunc (f Friends) First() *Friend {\n\tif f.Count() > 0 {\n\t\treturn f.Sort()[0]\n\t}\n\treturn nil\n}\n\n// Last 获取最后一个好友\nfunc (f Friends) Last() *Friend {\n\tif f.Count() > 0 {\n\t\treturn f.Sort()[f.Count()-1]\n\t}\n\treturn nil\n}\n\n// SearchByUserName 根据用户名查找好友\nfunc (f Friends) SearchByUserName(limit int, username string) (results Friends) {\n\treturn f.Search(limit, func(friend *Friend) bool { return friend.User.UserName == username })\n}\n\n// SearchByNickName 根据昵称查找好友\nfunc (f Friends) SearchByNickName(limit int, nickName string) (results Friends) {\n\treturn f.Search(limit, func(friend *Friend) bool { return friend.User.NickName == nickName })\n}\n\n// SearchByRemarkName 根据备注查找好友\nfunc (f Friends) SearchByRemarkName(limit int, remarkName string) (results Friends) {\n\treturn f.Search(limit, func(friend *Friend) bool { return friend.User.RemarkName == remarkName })\n}\n\n// SearchByID 根据ID查找好友\nfunc (f Friends) SearchByID(id string) Friends {\n\treturn f.Search(1, func(friend *Friend) bool { return friend.User.ID() == id })\n}\n\n// Search 根据自定义条件查找好友\nfunc (f Friends) Search(limit int, searchFuncList ...func(friend *Friend) bool) (results Friends) {\n\treturn f.AsMembers().Search(limit, func(user *User) bool {\n\t\tvar friend = &Friend{user}\n\t\tfor _, searchFunc := range searchFuncList {\n\t\t\tif !searchFunc(friend) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}).Friends()\n}\n\n// AsMembers 将群组转换为用户列表\nfunc (f Friends) AsMembers() Members {\n\tvar members = make(Members, 0, f.Count())\n\tfor _, friend := range f {\n\t\tmembers = append(members, friend.User)\n\t}\n\treturn members\n}\n\n// Sort 对好友进行排序\nfunc (f Friends) Sort() Friends {\n\treturn f.AsMembers().Sort().Friends()\n}\n\n// Uniq 对好友进行去重\nfunc (f Friends) Uniq() Friends {\n\treturn f.AsMembers().Uniq().Friends()\n}\n\n// SendText 向slice的好友依次发送文本消息\nfunc (f Friends) SendText(text string, delays ...time.Duration) error {\n\tif f.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar delay time.Duration\n\tif len(delays) > 0 {\n\t\tdelay = delays[0]\n\t}\n\tself := f.First().Self()\n\treturn self.SendTextToFriends(text, delay, f...)\n}\n\n// BroadcastTextToFriendsByRandomTime 向所有好友随机时间间隔发送消息。\nfunc (f Friends) BroadcastTextToFriendsByRandomTime(msg string) error {\n\tfor _, friend := range f {\n\t\ttime.Sleep(time.Duration(rand.Intn(10)) * time.Second) //随机休眠0-10秒\n\t\tif _, err := friend.SendText(msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SendImage 向slice的好友依次发送图片消息\nfunc (f Friends) SendImage(file io.Reader, delays ...time.Duration) error {\n\tif f.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar delay time.Duration\n\tif len(delays) > 0 {\n\t\tdelay = delays[0]\n\t}\n\tself := f.First().Self()\n\treturn self.SendImageToFriends(file, delay, f...)\n}\n\n// SendFile 群发文件\nfunc (f Friends) SendFile(file io.Reader, delay ...time.Duration) error {\n\tif f.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar d time.Duration\n\tif len(delay) > 0 {\n\t\td = delay[0]\n\t}\n\tself := f.First().Self()\n\treturn self.SendFileToFriends(file, d, f...)\n}\n\ntype Group struct{ *User }\n\n// implement fmt.Stringer\nfunc (g *Group) String() string {\n\treturn fmt.Sprintf(\"<Group:%s>\", g.NickName)\n}\n\n// SendText 发送文本消息给当前的群组\nfunc (g *Group) SendText(content string) (*SentMessage, error) {\n\treturn g.Self().SendTextToGroup(g, content)\n}\n\n// SendImage 发送图片消息给当前的群组\nfunc (g *Group) SendImage(file io.Reader) (*SentMessage, error) {\n\treturn g.Self().SendImageToGroup(g, file)\n}\n\n// SendEmoticon 发送表情消息给当前的群组\nfunc (g *Group) SendEmoticon(md5 string, file io.Reader) (*SentMessage, error) {\n\treturn g.Self().SendEmoticonToGroup(g, md5, file)\n}\n\n// SendVideo 发送视频消息给当前的群组\nfunc (g *Group) SendVideo(file io.Reader) (*SentMessage, error) {\n\treturn g.Self().SendVideoToGroup(g, file)\n}\n\n// SendFile 发送文件给当前的群组\nfunc (g *Group) SendFile(file io.Reader) (*SentMessage, error) {\n\treturn g.Self().SendFileToGroup(g, file)\n}\n\n// Members 获取所有的群成员\nfunc (g *Group) Members() (Members, error) {\n\tif err := g.Detail(); err != nil {\n\t\treturn nil, err\n\t}\n\tg.MemberList.init(g.Self())\n\treturn g.MemberList, nil\n}\n\n// AddFriendsIn 拉好友入群\nfunc (g *Group) AddFriendsIn(friends ...*Friend) error {\n\tfriends = Friends(friends).Uniq()\n\treturn g.self.AddFriendsIntoGroup(g, friends...)\n}\n\n// RemoveMembers 从群聊中移除用户\n// Deprecated\n// 无论是网页版，还是程序上都不起作用\nfunc (g *Group) RemoveMembers(members Members) error {\n\treturn g.Self().RemoveMemberFromGroup(g, members)\n}\n\n// Rename 群组重命名\n// Deprecated\nfunc (g *Group) Rename(name string) error {\n\treturn g.Self().RenameGroup(g, name)\n}\n\n// SearchMemberByUsername 根据用户名查找群成员\nfunc (g *Group) SearchMemberByUsername(username string) (*User, error) {\n\tif g.MemberList.Count() == 0 {\n\t\tif _, err := g.Members(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tmembers := g.MemberList.SearchByUserName(1, username)\n\t// 如果此时本地查不到, 那么该成员可能是新加入的\n\tif members.Count() == 0 {\n\t\tif _, err := g.Members(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// 再次尝试获取\n\tmembers = g.MemberList.SearchByUserName(1, username)\n\tif members.Count() == 0 {\n\t\treturn nil, ErrNoSuchUserFound\n\t}\n\treturn members.First(), nil\n}\n\ntype Groups []*Group\n\n// Count 获取群组数量\nfunc (g Groups) Count() int {\n\treturn len(g)\n}\n\n// First 获取第一个群组\nfunc (g Groups) First() *Group {\n\tif g.Count() > 0 {\n\t\treturn g.Sort()[0]\n\t}\n\treturn nil\n}\n\n// Last 获取最后一个群组\nfunc (g Groups) Last() *Group {\n\tif g.Count() > 0 {\n\t\treturn g.Sort()[g.Count()-1]\n\t}\n\treturn nil\n}\n\n// SendText 向群组依次发送文本消息, 支持发送延迟\nfunc (g Groups) SendText(text string, delay ...time.Duration) error {\n\tif g.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar d time.Duration\n\tif len(delay) > 0 {\n\t\td = delay[0]\n\t}\n\tself := g.First().Self()\n\treturn self.SendTextToGroups(text, d, g...)\n}\n\n// SendImage 向群组依次发送图片消息, 支持发送延迟\nfunc (g Groups) SendImage(file io.Reader, delay ...time.Duration) error {\n\tif g.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar d time.Duration\n\tif len(delay) > 0 {\n\t\td = delay[0]\n\t}\n\tself := g.First().Self()\n\treturn self.SendImageToGroups(file, d, g...)\n}\n\n// SendFile 向群组依次发送文件消息, 支持发送延迟\nfunc (g Groups) SendFile(file io.Reader, delay ...time.Duration) error {\n\tif g.Count() == 0 {\n\t\treturn nil\n\t}\n\tvar d time.Duration\n\tif len(delay) > 0 {\n\t\td = delay[0]\n\t}\n\tself := g.First().Self()\n\treturn self.SendFileToGroups(file, d, g...)\n}\n\n// SearchByUserName 根据用户名查找群组\nfunc (g Groups) SearchByUserName(limit int, username string) (results Groups) {\n\treturn g.Search(limit, func(group *Group) bool { return group.UserName == username })\n}\n\n// SearchByNickName 根据昵称查找群组\nfunc (g Groups) SearchByNickName(limit int, nickName string) (results Groups) {\n\treturn g.Search(limit, func(group *Group) bool { return group.NickName == nickName })\n}\n\n// SearchByID 根据ID查找群组\nfunc (g Groups) SearchByID(id string) Groups {\n\treturn g.Search(1, func(group *Group) bool { return group.ID() == id })\n}\n\n// Search 根据自定义条件查找群组\nfunc (g Groups) Search(limit int, searchFuncList ...func(group *Group) bool) (results Groups) {\n\treturn g.AsMembers().Search(limit, func(user *User) bool {\n\t\tvar group = &Group{user}\n\t\tfor _, searchFunc := range searchFuncList {\n\t\t\tif !searchFunc(group) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}).Groups()\n}\n\n// AsMembers 将群组列表转换为用户列表\nfunc (g Groups) AsMembers() Members {\n\tvar members = make(Members, 0, g.Count())\n\tfor _, group := range g {\n\t\tmembers = append(members, group.User)\n\t}\n\treturn members\n}\n\n// Sort 对群组进行排序\nfunc (g Groups) Sort() Groups {\n\treturn g.AsMembers().Sort().Groups()\n}\n\n// Uniq 对群组进行去重\nfunc (g Groups) Uniq() Groups {\n\treturn g.AsMembers().Uniq().Groups()\n}\n\n// Mp 公众号对象\ntype Mp struct{ *User }\n\nfunc (m *Mp) String() string {\n\treturn fmt.Sprintf(\"<Mp:%s>\", m.NickName)\n}\n\n// Mps 公众号组对象\ntype Mps []*Mp\n\n// Count 数量统计\nfunc (m Mps) Count() int {\n\treturn len(m)\n}\n\n// First 获取第一个\nfunc (m Mps) First() *Mp {\n\tif m.Count() > 0 {\n\t\treturn m.Sort()[0]\n\t}\n\treturn nil\n}\n\n// Last 获取最后一个\nfunc (m Mps) Last() *Mp {\n\tif m.Count() > 0 {\n\t\treturn m.Sort()[m.Count()-1]\n\t}\n\treturn nil\n}\n\n// Search 根据自定义条件查找\nfunc (m Mps) Search(limit int, searchFuncList ...func(*Mp) bool) (results Mps) {\n\treturn m.AsMembers().Search(limit, func(user *User) bool {\n\t\tvar mp = &Mp{user}\n\t\tfor _, searchFunc := range searchFuncList {\n\t\t\tif !searchFunc(mp) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}).MPs()\n}\n\n// AsMembers 将公众号列表转换为用户列表\nfunc (m Mps) AsMembers() Members {\n\tvar members = make(Members, 0, m.Count())\n\tfor _, mp := range m {\n\t\tmembers = append(members, mp.User)\n\t}\n\treturn members\n}\n\n// Sort 对公众号进行排序\nfunc (m Mps) Sort() Mps {\n\treturn m.AsMembers().Sort().MPs()\n}\n\n// Uniq 对公众号进行去重\nfunc (m Mps) Uniq() Mps {\n\treturn m.AsMembers().Uniq().MPs()\n}\n\n// SearchByUserName 根据用户名查找\nfunc (m Mps) SearchByUserName(limit int, userName string) (results Mps) {\n\treturn m.Search(limit, func(mp *Mp) bool { return mp.UserName == userName })\n}\n\n// SearchByNickName 根据昵称查找\nfunc (m Mps) SearchByNickName(limit int, nickName string) (results Mps) {\n\treturn m.Search(limit, func(mp *Mp) bool { return mp.NickName == nickName })\n}\n\n// SendText 发送文本消息给公众号\nfunc (m *Mp) SendText(content string) (*SentMessage, error) {\n\treturn m.Self().SendTextToMp(m, content)\n}\n\n// SendImage 发送图片消息给公众号\nfunc (m *Mp) SendImage(file io.Reader) (*SentMessage, error) {\n\treturn m.Self().SendImageToMp(m, file)\n}\n\n// SendFile 发送文件消息给公众号\nfunc (m *Mp) SendFile(file io.Reader) (*SentMessage, error) {\n\treturn m.Self().SendFileToMp(m, file)\n}\n\n// GetByUsername 根据username查询一个Friend\nfunc (f Friends) GetByUsername(username string) *Friend {\n\treturn f.SearchByUserName(1, username).First()\n}\n\n// GetByRemarkName 根据remarkName查询一个Friend\nfunc (f Friends) GetByRemarkName(remarkName string) *Friend {\n\treturn f.SearchByRemarkName(1, remarkName).First()\n}\n\n// GetByNickName 根据nickname查询一个Friend\nfunc (f Friends) GetByNickName(nickname string) *Friend {\n\treturn f.SearchByNickName(1, nickname).First()\n}\n\n// GetByUsername 根据username查询一个Group\nfunc (g Groups) GetByUsername(username string) *Group {\n\treturn g.SearchByUserName(1, username).First()\n}\n\n// GetByNickName 根据nickname查询一个Group\nfunc (g Groups) GetByNickName(nickname string) *Group {\n\treturn g.SearchByNickName(1, nickname).First()\n}\n\n// GetByNickName 根据nickname查询一个Mp\nfunc (m Mps) GetByNickName(nickname string) *Mp {\n\treturn m.SearchByNickName(1, nickname).First()\n}\n\n// GetByUserName 根据username查询一个Mp\nfunc (m Mps) GetByUserName(username string) *Mp {\n\treturn m.SearchByUserName(1, username).First()\n}\n\n// search 根据自定义条件查找\nfunc search(searchList Members, limit int, searchFunc func(*User) bool) (results Members) {\n\tif limit <= 0 {\n\t\tlimit = searchList.Count()\n\t}\n\tfor _, member := range searchList {\n\t\tif results.Count() == limit {\n\t\t\tbreak\n\t\t}\n\t\tif searchFunc(member) {\n\t\t\tresults = append(results, member)\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 0.1884765625,
          "content": "package openwechat\n\n// Session 会话信息，包含登录信息、请求信息、响应信息\ntype Session struct {\n\tLoginInfo *LoginInfo\n\tRequest   *BaseRequest\n\tResponse  *WebInitResponse\n}\n"
        },
        {
          "name": "storage.go",
          "type": "blob",
          "size": 1.7470703125,
          "content": "package openwechat\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n)\n\ntype HotReloadStorageItem struct {\n\tJar          *Jar\n\tBaseRequest  *BaseRequest\n\tLoginInfo    *LoginInfo\n\tWechatDomain WechatDomain\n\tSyncKey      *SyncKey\n\tUUID         string\n}\n\n// HotReloadStorage 热登陆存储接口\ntype HotReloadStorage io.ReadWriter\n\n// fileHotReloadStorage 实现HotReloadStorage接口\n// 以文件的形式存储\ntype fileHotReloadStorage struct {\n\tfilename string\n\tfile     *os.File\n\tlock     sync.Mutex\n}\n\nfunc (j *fileHotReloadStorage) Read(p []byte) (n int, err error) {\n\tj.lock.Lock()\n\tdefer j.lock.Unlock()\n\tif j.file == nil {\n\t\tj.file, err = os.OpenFile(j.filename, os.O_RDWR, 0600)\n\t\tif os.IsNotExist(err) {\n\t\t\treturn 0, ErrInvalidStorage\n\t\t}\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn j.file.Read(p)\n}\n\nfunc (j *fileHotReloadStorage) Write(p []byte) (n int, err error) {\n\tj.lock.Lock()\n\tdefer j.lock.Unlock()\n\tif j.file == nil {\n\t\tj.file, err = os.Create(j.filename)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// reset offset and truncate file\n\tif _, err = j.file.Seek(0, io.SeekStart); err != nil {\n\t\treturn\n\t}\n\tif err = j.file.Truncate(0); err != nil {\n\t\treturn\n\t}\n\t// json decode only write once\n\treturn j.file.Write(p)\n}\n\nfunc (j *fileHotReloadStorage) Close() error {\n\tj.lock.Lock()\n\tdefer j.lock.Unlock()\n\tif j.file == nil {\n\t\treturn nil\n\t}\n\treturn j.file.Close()\n}\n\n// Deprecated: use NewFileHotReloadStorage instead\n// 不再单纯以json的格式存储，支持了用户自定义序列化方式\nfunc NewJsonFileHotReloadStorage(filename string) io.ReadWriteCloser {\n\treturn NewFileHotReloadStorage(filename)\n}\n\n// NewFileHotReloadStorage implements HotReloadStorage\nfunc NewFileHotReloadStorage(filename string) io.ReadWriteCloser {\n\treturn &fileHotReloadStorage{filename: filename}\n}\n"
        },
        {
          "name": "stringer.go",
          "type": "blob",
          "size": 4.7021484375,
          "content": "// Code generated by \"stringer -type=MessageType,Ret,AppMessageType -linecomment=true -output=stringer.go\"; DO NOT EDIT.\n\npackage openwechat\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[MsgTypeText-1]\n\t_ = x[MsgTypeImage-3]\n\t_ = x[MsgTypeVoice-34]\n\t_ = x[MsgTypeVerify-37]\n\t_ = x[MsgTypePossibleFriend-40]\n\t_ = x[MsgTypeShareCard-42]\n\t_ = x[MsgTypeVideo-43]\n\t_ = x[MsgTypeEmoticon-47]\n\t_ = x[MsgTypeLocation-48]\n\t_ = x[MsgTypeApp-49]\n\t_ = x[MsgTypeVoip-50]\n\t_ = x[MsgTypeVoipNotify-52]\n\t_ = x[MsgTypeVoipInvite-53]\n\t_ = x[MsgTypeMicroVideo-62]\n\t_ = x[MsgTypeSys-10000]\n\t_ = x[MsgTypeRecalled-10002]\n}\n\nconst _MessageType_name = \"文本消息图片消息语音消息认证消息好友推荐消息名片消息视频消息表情消息地理位置消息APP消息VOIP消息VOIP结束消息VOIP邀请小视频消息系统消息消息撤回\"\n\nvar _MessageType_map = map[MessageType]string{\n\t1:     _MessageType_name[0:12],\n\t3:     _MessageType_name[12:24],\n\t34:    _MessageType_name[24:36],\n\t37:    _MessageType_name[36:48],\n\t40:    _MessageType_name[48:66],\n\t42:    _MessageType_name[66:78],\n\t43:    _MessageType_name[78:90],\n\t47:    _MessageType_name[90:102],\n\t48:    _MessageType_name[102:120],\n\t49:    _MessageType_name[120:129],\n\t50:    _MessageType_name[129:139],\n\t52:    _MessageType_name[139:155],\n\t53:    _MessageType_name[155:165],\n\t62:    _MessageType_name[165:180],\n\t10000: _MessageType_name[180:192],\n\t10002: _MessageType_name[192:204],\n}\n\nfunc (i MessageType) String() string {\n\tif str, ok := _MessageType_map[i]; ok {\n\t\treturn str\n\t}\n\treturn \"MessageType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[ticketError - -14]\n\t_ = x[logicError - -2]\n\t_ = x[sysError - -1]\n\t_ = x[paramError-1]\n\t_ = x[failedLoginWarn-1100]\n\t_ = x[failedLoginCheck-1101]\n\t_ = x[cookieInvalid-1102]\n\t_ = x[loginEnvAbnormality-1203]\n\t_ = x[optTooOften-1205]\n}\n\nconst (\n\t_Ret_name_0 = \"ticket error\"\n\t_Ret_name_1 = \"logic errorsys error\"\n\t_Ret_name_2 = \"param error\"\n\t_Ret_name_3 = \"failed login warnfailed login checkcookie invalid\"\n\t_Ret_name_4 = \"login environmental abnormality\"\n\t_Ret_name_5 = \"operate too often\"\n)\n\nvar (\n\t_Ret_index_1 = [...]uint8{0, 11, 20}\n\t_Ret_index_3 = [...]uint8{0, 17, 35, 49}\n)\n\nfunc (i Ret) String() string {\n\tswitch {\n\tcase i == -14:\n\t\treturn _Ret_name_0\n\tcase -2 <= i && i <= -1:\n\t\ti -= -2\n\t\treturn _Ret_name_1[_Ret_index_1[i]:_Ret_index_1[i+1]]\n\tcase i == 1:\n\t\treturn _Ret_name_2\n\tcase 1100 <= i && i <= 1102:\n\t\ti -= 1100\n\t\treturn _Ret_name_3[_Ret_index_3[i]:_Ret_index_3[i+1]]\n\tcase i == 1203:\n\t\treturn _Ret_name_4\n\tcase i == 1205:\n\t\treturn _Ret_name_5\n\tdefault:\n\t\treturn \"Ret(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[AppMsgTypeText-1]\n\t_ = x[AppMsgTypeImg-2]\n\t_ = x[AppMsgTypeAudio-3]\n\t_ = x[AppMsgTypeVideo-4]\n\t_ = x[AppMsgTypeUrl-5]\n\t_ = x[AppMsgTypeAttach-6]\n\t_ = x[AppMsgTypeOpen-7]\n\t_ = x[AppMsgTypeEmoji-8]\n\t_ = x[AppMsgTypeVoiceRemind-9]\n\t_ = x[AppMsgTypeScanGood-10]\n\t_ = x[AppMsgTypeGood-13]\n\t_ = x[AppMsgTypeEmotion-15]\n\t_ = x[AppMsgTypeCardTicket-16]\n\t_ = x[AppMsgTypeRealtimeShareLocation-17]\n\t_ = x[AppMsgTypeTransfers-2000]\n\t_ = x[AppMsgTypeRedEnvelopes-2001]\n\t_ = x[AppMsgTypeReaderType-100001]\n}\n\nconst (\n\t_AppMessageType_name_0 = \"文本消息图片消息语音消息视频消息文章消息附件消息Open表情消息VoiceRemindScanGood\"\n\t_AppMessageType_name_1 = \"Good\"\n\t_AppMessageType_name_2 = \"Emotion名片消息地理位置消息\"\n\t_AppMessageType_name_3 = \"转账消息红包消息\"\n\t_AppMessageType_name_4 = \"自定义的消息\"\n)\n\nvar (\n\t_AppMessageType_index_0 = [...]uint8{0, 12, 24, 36, 48, 60, 72, 76, 88, 99, 107}\n\t_AppMessageType_index_2 = [...]uint8{0, 7, 19, 37}\n\t_AppMessageType_index_3 = [...]uint8{0, 12, 24}\n)\n\nfunc (i AppMessageType) String() string {\n\tswitch {\n\tcase 1 <= i && i <= 10:\n\t\ti -= 1\n\t\treturn _AppMessageType_name_0[_AppMessageType_index_0[i]:_AppMessageType_index_0[i+1]]\n\tcase i == 13:\n\t\treturn _AppMessageType_name_1\n\tcase 15 <= i && i <= 17:\n\t\ti -= 15\n\t\treturn _AppMessageType_name_2[_AppMessageType_index_2[i]:_AppMessageType_index_2[i+1]]\n\tcase 2000 <= i && i <= 2001:\n\t\ti -= 2000\n\t\treturn _AppMessageType_name_3[_AppMessageType_index_3[i]:_AppMessageType_index_3[i+1]]\n\tcase i == 100001:\n\t\treturn _AppMessageType_name_4\n\tdefault:\n\t\treturn \"AppMessageType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\n"
        },
        {
          "name": "sync_check.go",
          "type": "blob",
          "size": 1.2666015625,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n)\n\ntype Selector string\n\nconst (\n\tSelectorNormal          Selector = \"0\" // 正常\n\tSelectorNewMsg          Selector = \"2\" // 有新消息\n\tSelectorModContact      Selector = \"4\" // 联系人信息变更\n\tSelectorAddOrDelContact Selector = \"6\" // 添加或删除联系人\n\tSelectorModChatRoom     Selector = \"7\" // 进入或退出聊天室\n)\n\ntype SyncCheckResponse struct {\n\tRetCode  string\n\tSelector Selector\n}\n\nfunc (s SyncCheckResponse) Success() bool {\n\treturn s.RetCode == \"0\"\n}\n\nfunc (s SyncCheckResponse) NorMal() bool {\n\treturn s.Success() && s.Selector == SelectorNormal\n}\n\nfunc (s SyncCheckResponse) HasNewMessage() bool {\n\treturn s.Success() && s.Selector == SelectorNewMsg\n}\n\nfunc (s SyncCheckResponse) Err() error {\n\tif s.Success() {\n\t\treturn nil\n\t}\n\ti, err := strconv.Atoi(s.RetCode)\n\tif err != nil {\n\t\treturn errors.New(\"sync check unknown error\")\n\t}\n\treturn Ret(i)\n}\n\nfunc NewSyncCheckResponse(b []byte) (*SyncCheckResponse, error) {\n\tresults := syncCheckRegexp.FindSubmatch(b)\n\tif len(results) != 3 {\n\t\treturn nil, errors.New(\"parse sync key failed\")\n\t}\n\tretCode, selector := string(results[1]), Selector(results[2])\n\tsyncCheckResponse := &SyncCheckResponse{RetCode: retCode, Selector: selector}\n\treturn syncCheckResponse, nil\n}\n"
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 2.2412109375,
          "content": "package openwechat\n\n//// mode 类型限制\n//type mode string\n//\n//// 向外暴露2种模式\n//const (\n//\tNormal  mode = \"normal\"\n//\tDesktop mode = \"desktop\" // 突破网页版登录限制\n//)\n\nconst (\n\twebwxinit            = \"/cgi-bin/mmwebwx-bin/webwxinit\"\n\twebwxstatusnotify    = \"/cgi-bin/mmwebwx-bin/webwxstatusnotify\"\n\twebwxsync            = \"/cgi-bin/mmwebwx-bin/webwxsync\"\n\twebwxsendmsg         = \"/cgi-bin/mmwebwx-bin/webwxsendmsg\"\n\twebwxsendemoticon    = \"/cgi-bin/mmwebwx-bin/webwxsendemoticon\"\n\twebwxgetcontact      = \"/cgi-bin/mmwebwx-bin/webwxgetcontact\"\n\twebwxsendmsgimg      = \"/cgi-bin/mmwebwx-bin/webwxsendmsgimg\"\n\twebwxsendappmsg      = \"/cgi-bin/mmwebwx-bin/webwxsendappmsg\"\n\twebwxsendvideomsg    = \"/cgi-bin/mmwebwx-bin/webwxsendvideomsg\"\n\twebwxbatchgetcontact = \"/cgi-bin/mmwebwx-bin/webwxbatchgetcontact\"\n\twebwxoplog           = \"/cgi-bin/mmwebwx-bin/webwxoplog\"\n\twebwxverifyuser      = \"/cgi-bin/mmwebwx-bin/webwxverifyuser\"\n\tsynccheck            = \"/cgi-bin/mmwebwx-bin/synccheck\"\n\twebwxuploadmedia     = \"/cgi-bin/mmwebwx-bin/webwxuploadmedia\"\n\twebwxgetmsgimg       = \"/cgi-bin/mmwebwx-bin/webwxgetmsgimg\"\n\twebwxgetvoice        = \"/cgi-bin/mmwebwx-bin/webwxgetvoice\"\n\twebwxgetvideo        = \"/cgi-bin/mmwebwx-bin/webwxgetvideo\"\n\twebwxlogout          = \"/cgi-bin/mmwebwx-bin/webwxlogout\"\n\twebwxgetmedia        = \"/cgi-bin/mmwebwx-bin/webwxgetmedia\"\n\twebwxupdatechatroom  = \"/cgi-bin/mmwebwx-bin/webwxupdatechatroom\"\n\twebwxrevokemsg       = \"/cgi-bin/mmwebwx-bin/webwxrevokemsg\"\n\twebwxcheckupload     = \"/cgi-bin/mmwebwx-bin/webwxcheckupload\"\n\twebwxpushloginurl    = \"/cgi-bin/mmwebwx-bin/webwxpushloginurl\"\n\twebwxgeticon         = \"/cgi-bin/mmwebwx-bin/webwxgeticon\"\n\twebwxcreatechatroom  = \"/cgi-bin/mmwebwx-bin/webwxcreatechatroom\"\n\n\twebwxnewloginpage = \"https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage\"\n\tjslogin           = \"https://login.wx.qq.com/jslogin\"\n\tlogin             = \"https://login.wx.qq.com/cgi-bin/mmwebwx-bin/login\"\n\tqrcode            = \"https://login.weixin.qq.com/qrcode/\"\n)\n\ntype WechatDomain string\n\nfunc (w WechatDomain) BaseHost() string {\n\treturn \"https://\" + string(w)\n}\n\nfunc (w WechatDomain) FileHost() string {\n\treturn \"https://file.\" + string(w)\n}\n\nfunc (w WechatDomain) SyncHost() string {\n\treturn \"https://webpush.\" + string(w)\n}\n"
        },
        {
          "name": "user.go",
          "type": "blob",
          "size": 29.033203125,
          "content": "package openwechat\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// User 抽象的用户结构: 好友 群组 公众号\ntype User struct {\n\tHideInputBarFlag  int\n\tStarFriend        int\n\tSex               int\n\tAppAccountFlag    int\n\tVerifyFlag        int\n\tContactFlag       int\n\tWebWxPluginSwitch int\n\tHeadImgFlag       int\n\tSnsFlag           int\n\tIsOwner           int\n\tMemberCount       int\n\tChatRoomId        int\n\tUniFriend         int\n\tOwnerUin          int\n\tStatues           int\n\tAttrStatus        int64\n\tUin               int64\n\tProvince          string\n\tCity              string\n\tAlias             string\n\tDisplayName       string\n\tKeyWord           string\n\tEncryChatRoomId   string\n\tUserName          string\n\tNickName          string\n\tHeadImgUrl        string\n\tRemarkName        string\n\tPYInitial         string\n\tPYQuanPin         string\n\tRemarkPYInitial   string\n\tRemarkPYQuanPin   string\n\tSignature         string\n\n\tMemberList Members\n\n\tself *Self\n}\n\n// implement fmt.Stringer\nfunc (u *User) String() string {\n\tformat := \"User\"\n\tif u.IsSelf() {\n\t\tformat = \"Self\"\n\t} else if u.IsFriend() {\n\t\tformat = \"Friend\"\n\t} else if u.IsGroup() {\n\t\tformat = \"Group\"\n\t} else if u.IsMP() {\n\t\tformat = \"MP\"\n\t}\n\treturn fmt.Sprintf(\"<%s:%s>\", format, u.NickName)\n}\n\n// GetAvatarResponse 获取用户头像\nfunc (u *User) GetAvatarResponse() (resp *http.Response, err error) {\n\tfor i := 0; i < 3; i++ {\n\t\tresp, err = u.self.bot.Caller.Client.WebWxGetHeadImg(u.Self().Bot().Context(), u)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// 这里存在 ContentLength 为0的情况，需要重试\n\t\tif resp.ContentLength > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn resp, err\n}\n\n// SaveAvatar 下载用户头像\nfunc (u *User) SaveAvatar(filename string) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() { _ = file.Close() }()\n\treturn u.SaveAvatarWithWriter(file)\n}\n\nfunc (u *User) SaveAvatarWithWriter(writer io.Writer) error {\n\tresp, err := u.GetAvatarResponse()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 写文件前判断下 content length 是否是 0，不然保存的头像会出现\n\t// image not loaded  try to open it externally to fix format problem 问题\n\tif resp.ContentLength == 0 {\n\t\treturn errors.New(\"get avatar response content length is 0\")\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\t_, err = io.Copy(writer, resp.Body)\n\treturn err\n}\n\n// Detail 获取用户的详情\nfunc (u *User) Detail() error {\n\tif u.UserName == u.self.UserName {\n\t\treturn nil\n\t}\n\tmembers := Members{u}\n\tif err := members.Detail(); err != nil {\n\t\treturn err\n\t}\n\t*u = *members.First()\n\tu.MemberList.init(u.self)\n\treturn nil\n}\n\n// IsFriend 判断是否为好友\nfunc (u *User) IsFriend() bool {\n\treturn !u.IsGroup() && strings.HasPrefix(u.UserName, \"@\") && u.VerifyFlag == 0\n}\n\n// AsFriend 将当前用户转换为好友类型\nfunc (u *User) AsFriend() (*Friend, bool) {\n\tif u.IsFriend() {\n\t\treturn &Friend{User: u}, true\n\t}\n\treturn nil, false\n}\n\n// IsGroup 判断是否为群组\nfunc (u *User) IsGroup() bool {\n\treturn strings.HasPrefix(u.UserName, \"@@\") && u.VerifyFlag == 0\n}\n\n// AsGroup 将当前用户转换为群组类型\nfunc (u *User) AsGroup() (*Group, bool) {\n\tif u.IsGroup() {\n\t\treturn &Group{User: u}, true\n\t}\n\treturn nil, false\n}\n\n// IsMP  判断是否为公众号\nfunc (u *User) IsMP() bool {\n\treturn u.VerifyFlag == 8 || u.VerifyFlag == 24 || u.VerifyFlag == 136\n}\n\n// AsMP 将当前用户转换为公众号类型\nfunc (u *User) AsMP() (*Mp, bool) {\n\tif u.IsMP() {\n\t\treturn &Mp{User: u}, true\n\t}\n\treturn nil, false\n}\n\n// Pin 将联系人置顶\nfunc (u *User) Pin() error {\n\topt := &CallerWebWxRelationPinOptions{\n\t\tBaseRequest: u.self.bot.Storage.Request,\n\t\tUser:        u,\n\t\tOp:          1,\n\t}\n\treturn u.self.bot.Caller.WebWxRelationPin(u.Self().Bot().Context(), opt)\n}\n\n// UnPin 将联系人取消置顶\nfunc (u *User) UnPin() error {\n\topt := &CallerWebWxRelationPinOptions{\n\t\tBaseRequest: u.self.bot.Storage.Request,\n\t\tUser:        u,\n\t\tOp:          0,\n\t}\n\treturn u.self.bot.Caller.WebWxRelationPin(u.Self().Bot().Context(), opt)\n}\n\n// IsPin 判断当前联系人(好友、群组、公众号)是否为置顶状态\nfunc (u *User) IsPin() bool {\n\treturn u.ContactFlag == 2051\n}\n\n// ID 获取用户头像id\n// Deprecated: 请使用 AvatarID\nfunc (u *User) ID() string {\n\treturn u.AvatarID()\n}\n\n// AvatarID 获取用户头像id\n// 这个值会随着用户更换头像而变化\nfunc (u *User) AvatarID() string {\n\t// 首先尝试获取uid\n\tif u.Uin != 0 {\n\t\treturn strconv.FormatInt(u.Uin, 10)\n\t}\n\t// 如果uid不存在，尝试从头像url中获取\n\tif u.HeadImgUrl != \"\" {\n\t\tindex := strings.Index(u.HeadImgUrl, \"?\") + 1\n\t\tif len(u.HeadImgUrl) > index {\n\t\t\tquery := u.HeadImgUrl[index:]\n\t\t\tparams, err := url.ParseQuery(query)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn params.Get(\"seq\")\n\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// Equal 判断两个用户是否相等\nfunc (u *User) Equal(user *User) bool {\n\t// invalid user is not equal to any user\n\tif u == nil || user == nil {\n\t\treturn false\n\t}\n\t// not came from same bot\n\tif u.Self() != user.Self() {\n\t\treturn false\n\t}\n\treturn u.UserName == user.UserName\n}\n\n// Self 返回当前用户\nfunc (u *User) Self() *Self {\n\treturn u.self\n}\n\n// IsSelf 判断是否为当前用户\nfunc (u *User) IsSelf() bool {\n\treturn u.UserName == u.Self().UserName\n}\n\n// OrderSymbol 获取用户的排序标识\nfunc (u *User) OrderSymbol() string {\n\tvar symbol string\n\tif u.RemarkPYQuanPin != \"\" {\n\t\tsymbol = u.RemarkPYQuanPin\n\t} else if u.PYQuanPin != \"\" {\n\t\tsymbol = u.PYQuanPin\n\t} else {\n\t\tsymbol = u.NickName\n\t}\n\tsymbol = html.UnescapeString(symbol)\n\tsymbol = strings.ToUpper(symbol)\n\tsymbol = regexp.MustCompile(`/\\W/ig`).ReplaceAllString(symbol, \"\")\n\tif len(symbol) > 0 && symbol[0] < 'A' {\n\t\treturn \"~\"\n\t}\n\treturn symbol\n}\n\n// 格式化emoji表情\nfunc (u *User) formatEmoji() {\n\tu.NickName = FormatEmoji(u.NickName)\n\tu.RemarkName = FormatEmoji(u.RemarkName)\n\tu.DisplayName = FormatEmoji(u.DisplayName)\n}\n\nfunc newUser(self *Self, username string) *User {\n\treturn &User{\n\t\tUserName: username,\n\t\tself:     self,\n\t}\n}\n\n// Self 自己,当前登录用户对象\ntype Self struct {\n\t*User\n\tbot        *Bot\n\tfileHelper *Friend\n\tmembers    Members\n\tfriends    Friends\n\tgroups     Groups\n\tmps        Mps\n}\n\n// Members 获取所有的好友、群组、公众号信息\nfunc (s *Self) Members(update ...bool) (Members, error) {\n\t// 首先判断缓存里有没有,如果没有则去更新缓存\n\t// 判断是否需要更新,如果传入的参数不为nil,则取第一个\n\tif s.members == nil || (len(update) > 0 && update[0]) {\n\t\tif err := s.updateMembers(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\ts.members.Sort()\n\treturn s.members, nil\n}\n\n// 更新联系人处理\nfunc (s *Self) updateMembers() error {\n\tinfo := s.bot.Storage.LoginInfo\n\tmembers, err := s.bot.Caller.WebWxGetContact(s.Bot().Context(), info)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmembers.init(s)\n\ts.members = members\n\treturn nil\n}\n\n// FileHelper 获取文件传输助手对象，封装成Friend返回\n//\n//\tfh := self.FileHelper() // or fh := openwechat.NewFriendHelper(self)\nfunc (s *Self) FileHelper() *Friend {\n\tif s.fileHelper == nil {\n\t\ts.fileHelper = NewFriendHelper(s)\n\t}\n\treturn s.fileHelper\n}\nfunc (s *Self) ChkFrdGrpMpNil() bool {\n\treturn s.friends == nil && s.groups == nil && s.mps == nil\n}\n\n// Friends 获取所有的好友\nfunc (s *Self) Friends(update ...bool) (Friends, error) {\n\tif (len(update) > 0 && update[0]) || s.ChkFrdGrpMpNil() {\n\t\tif _, err := s.Members(true); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif s.friends == nil || (len(update) > 0 && update[0]) {\n\t\ts.friends = s.members.Friends()\n\t}\n\treturn s.friends, nil\n}\n\n// Groups 获取所有的群组\nfunc (s *Self) Groups(update ...bool) (Groups, error) {\n\n\tif (len(update) > 0 && update[0]) || s.ChkFrdGrpMpNil() {\n\t\tif _, err := s.Members(true); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t}\n\tif s.groups == nil || (len(update) > 0 && update[0]) {\n\t\ts.groups = s.members.Groups()\n\t}\n\treturn s.groups, nil\n}\n\n// Mps 获取所有的公众号\nfunc (s *Self) Mps(update ...bool) (Mps, error) {\n\tif (len(update) > 0 && update[0]) || s.ChkFrdGrpMpNil() {\n\t\tif _, err := s.Members(true); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif s.mps == nil || (len(update) > 0 && update[0]) {\n\t\ts.mps = s.members.MPs()\n\t}\n\treturn s.mps, nil\n}\n\n// UpdateMembersDetail 更新所有的联系人信息\nfunc (s *Self) UpdateMembersDetail() error {\n\t// 先获取所有的联系人\n\tmembers, err := s.Members()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn members.Detail()\n}\n\nfunc (s *Self) sendTextToUser(username, text string) (*SentMessage, error) {\n\tmsg := NewTextSendMessage(text, s.UserName, username)\n\topt := &CallerWebWxSendMsgOptions{\n\t\tLoginInfo:   s.bot.Storage.LoginInfo,\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tMessage:     msg,\n\t}\n\tsentMessage, err := s.bot.Caller.WebWxSendMsg(s.Bot().Context(), opt)\n\treturn s.sendMessageWrapper(sentMessage, err)\n}\n\nfunc (s *Self) sendEmoticonToUser(username, md5 string, file io.Reader) (*SentMessage, error) {\n\topt := &CallerWebWxSendAppMsgOptions{\n\t\tLoginInfo:    s.bot.Storage.LoginInfo,\n\t\tBaseRequest:  s.bot.Storage.Request,\n\t\tFromUserName: s.UserName,\n\t\tToUserName:   username,\n\t}\n\tsentMessage, err := s.bot.Caller.WebWxSendEmoticon(s.Bot().Context(), md5, file, opt)\n\treturn s.sendMessageWrapper(sentMessage, err)\n}\n\nfunc (s *Self) sendImageToUser(username string, file io.Reader) (*SentMessage, error) {\n\topt := &CallerWebWxSendImageMsgOptions{\n\t\tFromUserName: s.UserName,\n\t\tToUserName:   username,\n\t\tBaseRequest:  s.bot.Storage.Request,\n\t\tLoginInfo:    s.bot.Storage.LoginInfo,\n\t}\n\tsentMessage, err := s.bot.Caller.WebWxSendImageMsg(s.Bot().Context(), file, opt)\n\treturn s.sendMessageWrapper(sentMessage, err)\n}\n\nfunc (s *Self) sendVideoToUser(username string, file io.Reader) (*SentMessage, error) {\n\topt := &CallerWebWxSendAppMsgOptions{\n\t\tFromUserName: s.UserName,\n\t\tToUserName:   username,\n\t\tBaseRequest:  s.bot.Storage.Request,\n\t\tLoginInfo:    s.bot.Storage.LoginInfo,\n\t}\n\tsentMessage, err := s.bot.Caller.WebWxSendVideoMsg(s.Bot().Context(), file, opt)\n\treturn s.sendMessageWrapper(sentMessage, err)\n}\n\nfunc (s *Self) sendFileToUser(username string, file io.Reader) (*SentMessage, error) {\n\topt := &CallerWebWxSendFileOptions{\n\t\tFromUserName: s.UserName,\n\t\tToUserName:   username,\n\t\tBaseRequest:  s.bot.Storage.Request,\n\t\tLoginInfo:    s.bot.Storage.LoginInfo,\n\t}\n\tsentMessage, err := s.bot.Caller.WebWxSendFile(s.Bot().Context(), file, opt)\n\treturn s.sendMessageWrapper(sentMessage, err)\n}\n\n// SendTextToFriend 发送文本消息给好友\nfunc (s *Self) SendTextToFriend(friend *Friend, text string) (*SentMessage, error) {\n\treturn s.sendTextToUser(friend.User.UserName, text)\n}\n\n// SendEmoticonToFriend 发送表情给好友\nfunc (s *Self) SendEmoticonToFriend(friend *Friend, md5 string, file io.Reader) (*SentMessage, error) {\n\treturn s.sendEmoticonToUser(friend.User.UserName, md5, file)\n}\n\n// SendImageToFriend 发送图片消息给好友\nfunc (s *Self) SendImageToFriend(friend *Friend, file io.Reader) (*SentMessage, error) {\n\treturn s.sendImageToUser(friend.User.UserName, file)\n}\n\n// SendVideoToFriend 发送视频给好友\nfunc (s *Self) SendVideoToFriend(friend *Friend, file io.Reader) (*SentMessage, error) {\n\treturn s.sendVideoToUser(friend.User.UserName, file)\n}\n\n// SendFileToFriend 发送文件给好友\nfunc (s *Self) SendFileToFriend(friend *Friend, file io.Reader) (*SentMessage, error) {\n\treturn s.sendFileToUser(friend.User.UserName, file)\n}\n\n// SetRemarkNameToFriend 设置好友备注\n// Deprecated\n// 已经失效了\n//\n//\tself.SetRemarkNameToFriend(friend, \"remark\") // or friend.SetRemarkName(\"remark\")\nfunc (s *Self) SetRemarkNameToFriend(friend *Friend, remarkName string) error {\n\topt := &CallerWebWxOplogOptions{\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tToUserName:  friend.UserName,\n\t\tRemarkName:  remarkName,\n\t}\n\terr := s.bot.Caller.WebWxOplog(s.Bot().Context(), opt)\n\tif err == nil {\n\t\tfriend.RemarkName = remarkName\n\t}\n\treturn err\n}\n\n// CreateGroup 创建群聊\n// topic 群昵称,可以传递字符串\n// friends 群员,最少为2个，加上自己3个,三人才能成群\nfunc (s *Self) CreateGroup(topic string, friends ...*Friend) (*Group, error) {\n\tfriends = Friends(friends).Uniq()\n\tif len(friends) < 2 {\n\t\treturn nil, errors.New(\"a group must be at least 2 members\")\n\t}\n\topt := &CallerWebWxCreateChatRoomOptions{\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tLoginInfo:   s.bot.Storage.LoginInfo,\n\t\tTopic:       topic,\n\t\tFriends:     friends,\n\t}\n\tgroup, err := s.bot.Caller.WebWxCreateChatRoom(s.Bot().Context(), opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroup.self = s\n\tif err = group.Detail(); err != nil {\n\t\treturn nil, err\n\t}\n\t// 添加到群组列表\n\ts.groups = append(s.groups, group)\n\treturn group, nil\n}\n\n// AddFriendsIntoGroup 拉多名好友进群\n// 最好自己是群主,成功率高一点,因为有的群允许非群组拉人,而有的群不允许\nfunc (s *Self) AddFriendsIntoGroup(group *Group, friends ...*Friend) error {\n\tif len(friends) == 0 {\n\t\treturn nil\n\t}\n\tfriends = Friends(friends).Uniq()\n\t// 获取群的所有的群员\n\tgroupMembers, err := group.Members()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 判断当前的成员在不在群里面\n\tfor _, friend := range friends {\n\t\tfor _, member := range groupMembers {\n\t\t\tif member.UserName == friend.UserName {\n\t\t\t\treturn fmt.Errorf(\"user %s has alreay in this group\", friend.String())\n\t\t\t}\n\t\t}\n\t}\n\topt := &CallerAddFriendIntoChatRoomOptions{\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tLoginInfo:   s.bot.Storage.LoginInfo,\n\t\tGroup:       group,\n\t\tGroupLength: groupMembers.Count(),\n\t\tFriends:     friends,\n\t}\n\treturn s.bot.Caller.AddFriendIntoChatRoom(s.Bot().Context(), opt)\n}\n\n// RemoveMemberFromGroup 从群聊中移除用户\n// Deprecated\n// 无论是网页版，还是程序上都不起作用\nfunc (s *Self) RemoveMemberFromGroup(group *Group, members Members) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tif group.IsOwner == 0 {\n\t\treturn errors.New(\"group owner required\")\n\t}\n\tgroupMembers, err := group.Members()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 判断用户是否在群聊中\n\tvar count int\n\tfor _, member := range members {\n\t\tfor _, gm := range groupMembers {\n\t\t\tif gm.UserName == member.UserName {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\tif count != len(members) {\n\t\treturn errors.New(\"invalid members\")\n\t}\n\topt := &CallerRemoveFriendFromChatRoomOptions{\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tLoginInfo:   s.bot.Storage.LoginInfo,\n\t\tGroup:       group,\n\t\tMembers:     members,\n\t}\n\treturn s.bot.Caller.RemoveFriendFromChatRoom(s.Bot().Context(), opt)\n}\n\n// AddFriendIntoManyGroups 拉好友进多个群聊\n// AddFriendIntoGroups, 名字和上面的有点像\nfunc (s *Self) AddFriendIntoManyGroups(friend *Friend, groups ...*Group) error {\n\tgroups = Groups(groups).Uniq()\n\tfor _, group := range groups {\n\t\tif err := s.AddFriendsIntoGroup(group, friend); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// RenameGroup 群组重命名\n// Deprecated\nfunc (s *Self) RenameGroup(group *Group, newName string) error {\n\twebWxRenameChatRoomOptions := &CallerWebWxRenameChatRoomOptions{\n\t\tBaseRequest: s.bot.Storage.Request,\n\t\tLoginInfo:   s.bot.Storage.LoginInfo,\n\t\tGroup:       group,\n\t\tNewTopic:    newName,\n\t}\n\terr := s.bot.Caller.WebWxRenameChatRoom(s.Bot().Context(), webWxRenameChatRoomOptions)\n\tif err == nil {\n\t\tgroup.NickName = newName\n\t}\n\treturn err\n}\n\n// SendTextToGroup 发送文本消息给群组\nfunc (s *Self) SendTextToGroup(group *Group, text string) (*SentMessage, error) {\n\treturn s.sendTextToUser(group.User.UserName, text)\n}\n\n// SendImageToGroup 发送图片消息给群组\nfunc (s *Self) SendImageToGroup(group *Group, file io.Reader) (*SentMessage, error) {\n\treturn s.sendImageToUser(group.User.UserName, file)\n}\n\n// SendEmoticonToGroup 发送图片消息给群组\nfunc (s *Self) SendEmoticonToGroup(group *Group, md5 string, file io.Reader) (*SentMessage, error) {\n\treturn s.sendEmoticonToUser(group.User.UserName, md5, file)\n}\n\n// SendVideoToGroup 发送视频给群组\nfunc (s *Self) SendVideoToGroup(group *Group, file io.Reader) (*SentMessage, error) {\n\treturn s.sendVideoToUser(group.User.UserName, file)\n}\n\n// SendFileToGroup 发送文件给群组\nfunc (s *Self) SendFileToGroup(group *Group, file io.Reader) (*SentMessage, error) {\n\treturn s.sendFileToUser(group.User.UserName, file)\n}\n\n// RevokeMessage 撤回消息\n//\n//\tsentMessage, err := friend.SendText(\"message\")\n//\tif err == nil {\n//\t    self.RevokeMessage(sentMessage) // or sentMessage.Revoke()\n//\t}\nfunc (s *Self) RevokeMessage(msg *SentMessage) error {\n\treturn s.bot.Caller.WebWxRevokeMsg(s.Bot().Context(), msg, s.bot.Storage.Request)\n}\n\n// 转发消息接口\nfunc (s *Self) forwardMessage(msg *SentMessage, delay time.Duration, users ...*User) error {\n\tinfo := s.bot.Storage.LoginInfo\n\treq := s.bot.Storage.Request\n\n\tctx := s.Bot().Context()\n\n\tvar forwardFunc func() error\n\tswitch msg.Type {\n\tcase MsgTypeText:\n\t\tforwardFunc = func() error {\n\t\t\topt := &CallerWebWxSendMsgOptions{\n\t\t\t\tLoginInfo:   info,\n\t\t\t\tBaseRequest: req,\n\t\t\t\tMessage:     msg.SendMessage,\n\t\t\t}\n\t\t\t_, err := s.bot.Caller.WebWxSendMsg(ctx, opt)\n\t\t\treturn err\n\t\t}\n\tcase MsgTypeImage:\n\t\tforwardFunc = func() error {\n\t\t\topt := &ClientWebWxSendMsgOptions{\n\t\t\t\tLoginInfo:   info,\n\t\t\t\tBaseRequest: req,\n\t\t\t\tMessage:     msg.SendMessage,\n\t\t\t}\n\t\t\t_, err := s.bot.Caller.Client.WebWxSendMsgImg(ctx, opt)\n\t\t\treturn err\n\t\t}\n\tcase AppMessage:\n\t\tforwardFunc = func() error {\n\t\t\t_, err := s.bot.Caller.Client.WebWxSendAppMsg(ctx, msg.SendMessage, req)\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported message type: %s\", msg.Type)\n\t}\n\tvar errGroup []error\n\tfor _, user := range users {\n\t\tmsg.FromUserName = s.UserName\n\t\tmsg.ToUserName = user.UserName\n\t\tif err := forwardFunc(); err != nil {\n\t\t\terrGroup = append(errGroup, err)\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\tif len(errGroup) > 0 {\n\t\treturn errors.Join(errGroup...)\n\t}\n\treturn nil\n}\n\n// ForwardMessageToFriends 转发给好友\nfunc (s *Self) ForwardMessageToFriends(msg *SentMessage, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.forwardMessage(msg, delay, members...)\n}\n\n// ForwardMessageToGroups 转发给群组\nfunc (s *Self) ForwardMessageToGroups(msg *SentMessage, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.forwardMessage(msg, delay, members...)\n}\n\ntype SendMessageFunc func() (*SentMessage, error)\n\nfunc (s *Self) sendMessageToMember(sendMessageFunc SendMessageFunc, delay time.Duration, members ...*User) error {\n\tmsg, err := sendMessageFunc()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\treturn s.forwardMessage(msg, delay, members...)\n}\n\n// sendTextToMembers 发送文本消息给群组或者好友\nfunc (s *Self) sendTextToMembers(text string, delay time.Duration, members ...*User) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tvar sendMessageFunc SendMessageFunc = func() (*SentMessage, error) {\n\t\tuser := members[0]\n\t\treturn s.sendTextToUser(user.UserName, text)\n\t}\n\treturn s.sendMessageToMember(sendMessageFunc, delay, members[1:]...)\n}\n\n// sendEmoticonToMembers 发送表情消息给群组或者好友\nfunc (s *Self) sendEmoticonToMembers(md5 string, file io.Reader, delay time.Duration, members ...*User) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tvar sendMessageFunc SendMessageFunc = func() (*SentMessage, error) {\n\t\tuser := members[0]\n\t\treturn s.sendEmoticonToUser(user.UserName, md5, file)\n\t}\n\treturn s.sendMessageToMember(sendMessageFunc, delay, members[1:]...)\n}\n\n// sendImageToMembers 发送图片消息给群组或者好友\nfunc (s *Self) sendImageToMembers(img io.Reader, delay time.Duration, members ...*User) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tvar sendMessageFunc SendMessageFunc = func() (*SentMessage, error) {\n\t\tuser := members[0]\n\t\treturn s.sendImageToUser(user.UserName, img)\n\t}\n\treturn s.sendMessageToMember(sendMessageFunc, delay, members[1:]...)\n}\n\n// sendVideoToMembers 发送视频消息给群组或者好友\nfunc (s *Self) sendVideoToMembers(video io.Reader, delay time.Duration, members ...*User) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tvar sendMessageFunc SendMessageFunc = func() (*SentMessage, error) {\n\t\tuser := members[0]\n\t\treturn s.sendVideoToUser(user.UserName, video)\n\t}\n\treturn s.sendMessageToMember(sendMessageFunc, delay, members[1:]...)\n}\n\n// sendFileToMembers 发送文件消息给群组或者好友\nfunc (s *Self) sendFileToMembers(file io.Reader, delay time.Duration, members ...*User) error {\n\tif len(members) == 0 {\n\t\treturn nil\n\t}\n\tvar sendMessageFunc SendMessageFunc = func() (*SentMessage, error) {\n\t\tuser := members[0]\n\t\treturn s.sendFileToUser(user.UserName, file)\n\t}\n\treturn s.sendMessageToMember(sendMessageFunc, delay, members[1:]...)\n}\n\n// SendTextToFriends 发送文本消息给好友\nfunc (s *Self) SendTextToFriends(text string, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.sendTextToMembers(text, delay, members...)\n}\n\n// SendEmoticonToFriends 发送表情给好友\nfunc (s *Self) SendEmoticonToFriends(md5 string, file io.Reader, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.sendEmoticonToMembers(md5, file, delay, members...)\n}\n\n// SendImageToFriends 发送图片消息给好友\nfunc (s *Self) SendImageToFriends(img io.Reader, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.sendImageToMembers(img, delay, members...)\n}\n\n// SendFileToFriends 发送文件给好友\nfunc (s *Self) SendFileToFriends(file io.Reader, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.sendFileToMembers(file, delay, members...)\n}\n\n// SendVideoToFriends 发送视频给好友\nfunc (s *Self) SendVideoToFriends(video io.Reader, delay time.Duration, friends ...*Friend) error {\n\tmembers := Friends(friends).AsMembers()\n\treturn s.sendVideoToMembers(video, delay, members...)\n}\n\n// SendTextToGroups 发送文本消息给群组\nfunc (s *Self) SendTextToGroups(text string, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.sendTextToMembers(text, delay, members...)\n}\n\n// SendEmoticonToGroups 发送表情给群组\nfunc (s *Self) SendEmoticonToGroups(md5 string, file io.Reader, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.sendEmoticonToMembers(md5, file, delay, members...)\n}\n\n// SendImageToGroups 发送图片消息给群组\nfunc (s *Self) SendImageToGroups(img io.Reader, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.sendImageToMembers(img, delay, members...)\n}\n\n// SendFileToGroups 发送文件给群组\nfunc (s *Self) SendFileToGroups(file io.Reader, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.sendFileToMembers(file, delay, members...)\n}\n\n// SendVideoToGroups 发送视频给群组\nfunc (s *Self) SendVideoToGroups(video io.Reader, delay time.Duration, groups ...*Group) error {\n\tmembers := Groups(groups).AsMembers()\n\treturn s.sendVideoToMembers(video, delay, members...)\n}\n\n// ContactList 获取最近的联系人列表\nfunc (s *Self) ContactList() Members {\n\treturn s.Bot().Storage.Response.ContactList\n}\n\n// MPSubscribeList 获取部分公众号文章列表\nfunc (s *Self) MPSubscribeList() []*MPSubscribeMsg {\n\treturn s.Bot().Storage.Response.MPSubscribeMsgList\n}\n\n// ID 当前登录用户的ID\nfunc (s *Self) ID() int64 {\n\treturn s.Uin\n}\n\n// Members 抽象的用户组\ntype Members []*User\n\n// Uniq Members 去重\nfunc (m Members) Uniq() Members {\n\tvar uniqMembers = make(map[string]*User)\n\tfor _, member := range m {\n\t\tuniqMembers[member.UserName] = member\n\t}\n\tvar members = make(Members, 0, len(uniqMembers))\n\tfor _, member := range uniqMembers {\n\t\tmembers = append(members, member)\n\t}\n\treturn members\n}\n\n// Sort 对联系人进行排序\nfunc (m Members) Sort() Members {\n\tsort.Slice(m, func(i, j int) bool { return m[i].OrderSymbol() < m[j].OrderSymbol() })\n\treturn m\n}\n\n// Count 统计数量\nfunc (m Members) Count() int {\n\treturn len(m)\n}\n\n// First 获取第一个\nfunc (m Members) First() *User {\n\tif m.Count() > 0 {\n\t\tu := m[0]\n\t\treturn u\n\t}\n\treturn nil\n}\n\n// Last 获取最后一个\nfunc (m Members) Last() *User {\n\tif m.Count() > 0 {\n\t\tu := m[m.Count()-1]\n\t\treturn u\n\t}\n\treturn nil\n}\n\n// Append 追加联系人\nfunc (m Members) Append(user *User) (results Members) {\n\treturn append(m, user)\n}\n\n// SearchByUserName 根据用户名查找\nfunc (m Members) SearchByUserName(limit int, username string) (results Members) {\n\treturn m.Search(limit, func(user *User) bool { return user.UserName == username })\n}\n\n// SearchByNickName 根据昵称查找\nfunc (m Members) SearchByNickName(limit int, nickName string) (results Members) {\n\treturn m.Search(limit, func(user *User) bool { return user.NickName == nickName })\n}\n\n// SearchByRemarkName 根据备注查找\nfunc (m Members) SearchByRemarkName(limit int, remarkName string) (results Members) {\n\treturn m.Search(limit, func(user *User) bool { return user.RemarkName == remarkName })\n}\n\n// Search 根据自定义条件查找\nfunc (m Members) Search(limit int, searchFuncList ...func(user *User) bool) (results Members) {\n\treturn search(m, limit, func(group *User) bool {\n\t\tfor _, searchFunc := range searchFuncList {\n\t\t\tif !searchFunc(group) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// GetByUserName 根据username查找用户\nfunc (m Members) GetByUserName(username string) (*User, bool) {\n\tusers := m.SearchByUserName(1, username)\n\tuser := users.First()\n\treturn user, user != nil\n}\n\n// GetByRemarkName 根据remarkName查找用户\nfunc (m Members) GetByRemarkName(remarkName string) (*User, bool) {\n\tusers := m.SearchByRemarkName(1, remarkName)\n\tuser := users.First()\n\treturn user, user != nil\n}\n\n// GetByNickName 根据nickname查找用户\nfunc (m Members) GetByNickName(nickname string) (*User, bool) {\n\tusers := m.SearchByNickName(1, nickname)\n\tuser := users.First()\n\treturn user, user != nil\n}\n\nfunc (m Members) Friends() Friends {\n\tfriends := make(Friends, 0)\n\tfor _, mb := range m {\n\t\tfriend, ok := mb.AsFriend()\n\t\tif ok {\n\t\t\tfriends = append(friends, friend)\n\t\t}\n\t}\n\treturn friends\n}\n\nfunc (m Members) Groups() Groups {\n\tgroups := make(Groups, 0)\n\tfor _, mb := range m {\n\t\tgroup, ok := mb.AsGroup()\n\t\tif ok {\n\t\t\tgroups = append(groups, group)\n\t\t}\n\t}\n\treturn groups\n}\n\nfunc (m Members) MPs() Mps {\n\tmps := make(Mps, 0)\n\tfor _, mb := range m {\n\t\tmp, ok := mb.AsMP()\n\t\tif ok {\n\t\t\tmps = append(mps, mp)\n\t\t}\n\t}\n\treturn mps\n}\n\ntype membersUpdater struct {\n\tself       *Self\n\tmembers    Members\n\tmax        int\n\tindex      int\n\tupdateTime int\n\tcurrent    Members\n}\n\nfunc (m *membersUpdater) init() {\n\tif m.members.Count() > 0 {\n\t\tm.self = m.members.First().Self()\n\t}\n\tif m.members.Count() <= m.max {\n\t\tm.updateTime = 1\n\t} else {\n\t\tm.updateTime = m.members.Count() / m.max\n\t\tif m.members.Count()%m.max != 0 {\n\t\t\tm.updateTime++\n\t\t}\n\t}\n}\n\nfunc (m *membersUpdater) Next() bool {\n\tif m.index >= m.updateTime {\n\t\treturn false\n\t}\n\tm.index++\n\treturn true\n}\n\nfunc (m *membersUpdater) Update() error {\n\tstart := m.max * (m.index - 1)\n\n\tend := m.max * m.index\n\n\tif m.index == m.updateTime {\n\t\tend = m.members.Count()\n\t}\n\n\t// 获取需要更新的联系人\n\tm.current = m.members[start:end]\n\tctx := m.self.Bot().Context()\n\treq := m.self.Bot().Storage.Request\n\tmembers, err := m.self.Bot().Caller.WebWxBatchGetContact(ctx, m.current, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 更新联系人\n\tfor i, member := range members {\n\t\tmember.self = m.self\n\t\tmember.formatEmoji()\n\t\tm.members[start+i] = member\n\t}\n\treturn nil\n}\n\nfunc newMembersUpdater(members Members) *membersUpdater {\n\treturn &membersUpdater{\n\t\tmembers: members,\n\t\tmax:     50,\n\t}\n}\n\n// Detail 获取当前 Members 的详情\nfunc (m Members) Detail() error {\n\tif m.Count() == 0 {\n\t\treturn nil\n\t}\n\tupdater := newMembersUpdater(m)\n\tupdater.init()\n\tfor updater.Next() {\n\t\tif err := updater.Update(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m Members) init(self *Self) {\n\tfor _, member := range m {\n\t\tmember.self = self\n\t\tmember.formatEmoji()\n\t}\n}\n\nfunc newFriend(username string, self *Self) *Friend {\n\treturn &Friend{User: newUser(self, username)}\n}\n\n// NewFriendHelper 创建一个文件传输助手\n// 文件传输助手的微信身份标识符永远是filehelper\nfunc NewFriendHelper(self *Self) *Friend {\n\treturn newFriend(FileHelper, self)\n}\n\n// SendTextToMp 发送文本消息给公众号\nfunc (s *Self) SendTextToMp(mp *Mp, text string) (*SentMessage, error) {\n\treturn s.sendTextToUser(mp.User.UserName, text)\n}\n\n// SendEmoticonToMp 发送表情给公众号\nfunc (s *Self) SendEmoticonToMp(mp *Mp, md5 string, file io.Reader) (*SentMessage, error) {\n\treturn s.sendEmoticonToUser(mp.User.UserName, md5, file)\n}\n\n// SendImageToMp 发送图片消息给公众号\nfunc (s *Self) SendImageToMp(mp *Mp, file io.Reader) (*SentMessage, error) {\n\treturn s.sendImageToUser(mp.User.UserName, file)\n}\n\n// SendFileToMp 发送文件给公众号\nfunc (s *Self) SendFileToMp(mp *Mp, file io.Reader) (*SentMessage, error) {\n\treturn s.sendFileToUser(mp.User.UserName, file)\n}\n\n// SendVideoToMp 发送视频消息给公众号\nfunc (s *Self) SendVideoToMp(mp *Mp, file io.Reader) (*SentMessage, error) {\n\treturn s.sendVideoToUser(mp.User.UserName, file)\n}\n\nfunc (s *Self) sendMessageWrapper(message *SentMessage, err error) (*SentMessage, error) {\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmessage.self = s\n\treturn message, nil\n}\n\n// Bot 获取当前用户的机器人\nfunc (s *Self) Bot() *Bot {\n\treturn s.bot\n}\n"
        }
      ]
    }
  ]
}