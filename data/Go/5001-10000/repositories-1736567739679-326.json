{
  "metadata": {
    "timestamp": 1736567739679,
    "page": 326,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "h2non/imaginary",
      "stars": 5723,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0615234375,
          "content": "**/*~\n.devcontainer\n.github\n.git\nDockerfile\ndocker-compose.yml\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.310546875,
          "content": "root = true\n\n[*.go]\ncharset = utf-8\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[Makefile]\ncharset = utf-8\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3427734375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n.DS_Store\nThumbs.db\n\n# Folders\n_obj\n_test\n.idea\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n/dist\n*.exe\n*.test\nbin/\n.vagrant/\n\n*.old\n*.attr\n*.swp\n\nimaginary\nbin/imaginary\n"
        },
        {
          "name": ".godir",
          "type": "blob",
          "size": 0.009765625,
          "content": "imaginary\n"
        },
        {
          "name": ".golangci.toml",
          "type": "blob",
          "size": 0.9169921875,
          "content": "[run]\n    concurrency = 4\n    tests = false\n\n[linters-settings]\n    [linters-settings.gocyclo]\n        min-complexity = 20\n\n    [linters-settings.goconst]\n        min-len = 2\n        min-occurrences = 2\n\n    [linters-settings.misspell]\n        locale = \"US\"\n\n[linters]\n    # White-listing, to be more CI safe.\n    disable-all = true\n\n    # @see https://github.com/golangci/golangci-lint#enabled-by-default-linters\n    enable = [\n        \"staticcheck\",\n        \"gosimple\",\n        \"ineffassign\",\n        \"typecheck\",\n        \"govet\",\n#        \"errcheck\",\n        \"unused\",\n        \"structcheck\",\n        \"varcheck\",\n        \"deadcode\",\n\n        \"stylecheck\",\n        \"gosec\",\n        \"interfacer\",\n        \"unconvert\",\n#        \"goconst\",\n        \"gocyclo\",\n#        \"maligned\",\n        \"depguard\",\n        \"misspell\",\n        \"unparam\",\n        \"scopelint\", # Would like to ignore *_test.go files, but can't atm.\n        \"gocritic\",\n    ]\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.0009765625,
          "content": "language: go\n\nstages:\n  - test\n  - deploy\n\nservices:\n  - docker\n\ndist: focal\n\ngo:\n  - \"1.13\"\n  - \"1.14\"\n\nenv:\n  global:\n    - GOLANG_VERSION=\"${TRAVIS_GO_VERSION}\"\n    - IMAGINARY_VERSION=\"${TRAVIS_TAG:-dev}\"\n  matrix:\n    - LIBVIPS=8.8.4\n    - LIBVIPS=8.9.2\n    - LIBVIPS=8.10.0\n\nbefore_install:\n  - docker pull h2non/imaginary:latest || true\n\ninstall:\n  - \"true\"\n\nscript:\n  - docker build --pull --cache-from h2non/imaginary:latest --build-arg GOLANG_VERSION=\"${GOLANG_VERSION%.x}\" --build-arg LIBVIPS_VERSION=\"${LIBVIPS}\" --build-arg IMAGINARY_VERSION=\"${IMAGINARY_VERSION#v}\" --tag h2non/imaginary:${IMAGINARY_VERSION#v} .\n\n# jobs:\n#   include:\n#     # Deploy stage\n#     - stage: deploy\n#       script:\n#         - docker login -u \"$DOCKER_LOGIN\" -p \"$DOCKER_PWD\"\n#         - docker tag h2non/imaginary:${IMAGINARY_VERSION#v} h2non/imaginary:latest\n#         - docker push h2non/imaginary:${IMAGINARY_VERSION#v}\n#         - docker push h2non/imaginary:latest\n#       if: \"${TRAVIS_TAG} =~ ^v([0-9]+).([0-9]+).([0-9]+)$\"\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 3.41015625,
          "content": "ARG GOLANG_VERSION=1.17\nFROM golang:${GOLANG_VERSION}-bullseye as builder\n\nARG IMAGINARY_VERSION=dev\nARG LIBVIPS_VERSION=8.12.2\nARG GOLANGCILINT_VERSION=1.29.0\n\n# Installs libvips + required libraries\nRUN DEBIAN_FRONTEND=noninteractive \\\n  apt-get update && \\\n  apt-get install --no-install-recommends -y \\\n  ca-certificates \\\n  automake build-essential curl \\\n  gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg62-turbo-dev libpng-dev \\\n  libwebp-dev libtiff5-dev libgif-dev libexif-dev libxml2-dev libpoppler-glib-dev \\\n  swig libmagickwand-dev libpango1.0-dev libmatio-dev libopenslide-dev libcfitsio-dev \\\n  libgsf-1-dev fftw3-dev liborc-0.4-dev librsvg2-dev libimagequant-dev libheif-dev && \\\n  cd /tmp && \\\n  curl -fsSLO https://github.com/libvips/libvips/releases/download/v${LIBVIPS_VERSION}/vips-${LIBVIPS_VERSION}.tar.gz && \\\n  tar zvxf vips-${LIBVIPS_VERSION}.tar.gz && \\\n  cd /tmp/vips-${LIBVIPS_VERSION} && \\\n\tCFLAGS=\"-g -O3\" CXXFLAGS=\"-D_GLIBCXX_USE_CXX11_ABI=0 -g -O3\" \\\n    ./configure \\\n    --disable-debug \\\n    --disable-dependency-tracking \\\n    --disable-introspection \\\n    --disable-static \\\n    --enable-gtk-doc-html=no \\\n    --enable-gtk-doc=no \\\n    --enable-pyvips8=no && \\\n  make && \\\n  make install && \\\n  ldconfig\n\n# Installing golangci-lint\nWORKDIR /tmp\nRUN curl -fsSL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b \"${GOPATH}/bin\" v${GOLANGCILINT_VERSION}\n\nWORKDIR ${GOPATH}/src/github.com/h2non/imaginary\n\n# Cache go modules\nENV GO111MODULE=on\n\nCOPY go.mod .\nCOPY go.sum .\n\nRUN go mod download\n\n# Copy imaginary sources\nCOPY . .\n\n# Run quality control\nRUN go test ./... -test.v -race -test.coverprofile=atomic .\nRUN golangci-lint run .\n\n# Compile imaginary\nRUN go build -a \\\n    -o ${GOPATH}/bin/imaginary \\\n    -ldflags=\"-s -w -h -X main.Version=${IMAGINARY_VERSION}\" \\\n    github.com/h2non/imaginary\n\nFROM debian:bullseye-slim\n\nARG IMAGINARY_VERSION\n\nLABEL maintainer=\"tomas@aparicio.me\" \\\n      org.label-schema.description=\"Fast, simple, scalable HTTP microservice for high-level image processing with first-class Docker support\" \\\n      org.label-schema.schema-version=\"1.0\" \\\n      org.label-schema.url=\"https://github.com/h2non/imaginary\" \\\n      org.label-schema.vcs-url=\"https://github.com/h2non/imaginary\" \\\n      org.label-schema.version=\"${IMAGINARY_VERSION}\"\n\nCOPY --from=builder /usr/local/lib /usr/local/lib\nCOPY --from=builder /go/bin/imaginary /usr/local/bin/imaginary\nCOPY --from=builder /etc/ssl/certs /etc/ssl/certs\n\n# Install runtime dependencies\nRUN DEBIAN_FRONTEND=noninteractive \\\n  apt-get update && \\\n  apt-get install --no-install-recommends -y \\\n  procps libglib2.0-0 libjpeg62-turbo libpng16-16 libopenexr25 \\\n  libwebp6 libwebpmux3 libwebpdemux2 libtiff5 libgif7 libexif12 libxml2 libpoppler-glib8 \\\n  libmagickwand-6.q16-6 libpango1.0-0 libmatio11 libopenslide0 libjemalloc2 \\\n  libgsf-1-114 fftw3 liborc-0.4-0 librsvg2-2 libcfitsio9 libimagequant0 libheif1 && \\\n  ln -s /usr/lib/$(uname -m)-linux-gnu/libjemalloc.so.2 /usr/local/lib/libjemalloc.so && \\\n  apt-get autoremove -y && \\\n  apt-get autoclean && \\\n  apt-get clean && \\\n  rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\nENV LD_PRELOAD=/usr/local/lib/libjemalloc.so\n\n# Server port to listen\nENV PORT 9000\n\n# Drop privileges for non-UID mapped environments\nUSER nobody\n\n# Run the entrypoint command by default when the container starts.\nENTRYPOINT [\"/usr/local/bin/imaginary\"]\n\n# Expose the server TCP port\nEXPOSE ${PORT}\n"
        },
        {
          "name": "History.md",
          "type": "blob",
          "size": 23.23828125,
          "content": "\n1.2.4 / 2020-08-12\n==================\n\n  * upgrade: libvips to v8.10.0\n  * fix(pipeline): add missing autorate (#326)\n\nv1.2.3 / 2020-08-04\n===================\n\n  * feat(#315, #309): autorotate / gracefully fallback failed image type encoding\n\nv1.2.2 / 2020-06-11\n===================\n\n  * fix(docs): define mirror as default extend param\n  * refactor(params): use mirror as default extend behavior\n  * refactor(params): use mirror as default extend behavior\n\nv1.2.1 / 2020-06-08\n===================\n\n  * fix(history): release changes\n  * Merge branch 'master' of https://github.com/h2non/imaginary\n  * feat(version): release v1.1.1\n  * [improvement/server-graceful-shutdown] Add support of graceful shutdown (#312)\n  * fix\n\nv1.2.0 / 2020-06-07\n===================\n\n  * feat(ci): use job stages\n  * feat(ci): use job stages\n  * feat(ci): use job stages\n  * fix(ci): deploy filter\n  * feat(ci): only deploy for libvips 8.9.2\n  * fix(ci): strip v in semver version value\n  * feat(History): add changes\n  * New release, minor features, bimg upgrade and several fixes (#311)\n  * watermarkImage must be in lowerCamelCase (#255)\n  * Pre-release HEIF / HEIC support (#297)\n  * [improvement/log-levels] Add support set log levels (#301)\n  * chore(license): update year\n  * chore(docs): delete not valid contributor\n  * Added PlaceholderStatus option (#304)\n  * Create FUNDING.yml\n  * Delete README.md~\n  * Add fly.io (#300)\n\nv1.1.3 / 2020-02-28\n===================\n\n  * feat: add history changes\n  * Merge branch 'master' of https://github.com/h2non/imaginary\n  * refactor\n  * add fluentd config example to ingest imaginary logs (#260)\n\nv1.1.2 / 2020-02-08\n===================\n\n  * feature: implement interlace parameter (#273)\n  * Implement wildcard for paths for the allowed-origins option (#290)\n  * Go Modules, Code Refactoring, VIPS 8.8.1, etc. (#269)\n  * feature: implement aspect ratio (#275)\n  * Fix and add test for 2 buckets example (#281)\n  * Fix \"--allowed-origins\" type (#282)\n  * fix(docs): watermarkimage -> watermarkImage\n  * refactor(docs): removen image layers badge\n  * refactor: version set dev\n\nv1.1.1 / 2019-07-07\n===================\n\n  * feat(version): bump patch\n  * add validation to allowed-origins to include path (#265)\n  * Width and height are required in thumbnail request (#262)\n  * Merge pull request #258 from r-antonio/master\n  * Cleaned code to check for existence of headers\n  * Modified check for empty or undefined headers\n  * Merge pull request #259 from h2non/release/next\n  * Code Style changes\n  * Removing gometalinter in favor of golangci-lint\n  * Bumping libvips versions for building\n  * Merge branch 'master' into release/next\n  * Changed custom headers naming to forward headers\n  * Fixed spacing typo and headers checking\n  * Changed forwarded headers order, added tests and some fixes\n  * Added custom headers forwarding support\n  * Merge pull request #254 from nicolasmure/fix/readme\n  * apply @Dynom patch to fix cli help\n  * Update README.md\n  * fix enable-url-source param description in README\n  * Merge branch 'NextWithCIBase' into release/next\n  * Reverting and reordering\n  * ups\n  * Moving back to a single file, worst case we need to maintain two again.\n  * fixing a var\n  * Updating travis config, adding docker build and preparing for automated image building\n  * Megacheck has been removed in favor of staticcheck\n  * timing the pull separately, by putting it in a before_install\n  * Trying with a dev base image\n  * Adding .dockerignore and consistently guarding the variables\n  * Merging in changes by jbergstroem with some extra changes\n  * Merge pull request #229 from Dynom/uniformBuildRefactoring\n  * Improving gometalinter config\n  * First travis-ci config attempt\n  * Making sure vendor is not stale and that our deps are correctly configured\n  * gometalinter config\n  * Fixing Gopkg.toml\n  * Adding a newish Dockerfile\n\nv1.1.0 / 2019-02-21\n===================\n\n  * bumping to 1.1.0\n  * Merge pull request #243 from Dynom/CheckingIfDefaultValueWasSpecified\n  * Updating the documentation\n  * Testing if an ImageOption false value, was in fact requested\n\nv1.0.18 / 2019-01-28\n====================\n\n  * Bumping version to 1.0.18\n  * Isolated the calculation added a test and added Rounding (#242)\n\nv1.0.17 / 2019-01-20\n====================\n\n  * Bumping version to 1.0.17\n  * Merge pull request #239 from Dynom/RefactoringParameterParsingToImproveFeedback\n  * cleanup\n  * Bumping Go's version requirement\n  * Allow Go 1.9 to fail\n  * Refactoring, making things simpler\n  * Merge pull request #230 from Dynom/NonFunctionalImprovements\n  * minor styling\n  * Simplifying some if statements, removing unnecessary parenthesis and added an explicit error ignore\n  * Correct casing for multiple words\n  * explicitly ignoring errors\n  * ErrorReply's return value was never used.\n  * Changing the if's to a single map lookup.\n  * More literal to constant replacements\n  * Correcting comments, casing and constant use\n  * Removed unused variable and explicitly ignoring errors\n  * Correcting the use of abbreviations\n  * Comment fix\n  * Removing literals in favor of http constants\n  * Unavailable is not actually used, replaced it with _ to better convey intent.\n  * Removing unused function\n  * Style fixes\n  * Merge pull request #227 from Dynom/moarHealthEndpointDetails\n  * Merge pull request #228 from Dynom/addingExtraOriginTest\n  * Exposing several extra details\n  * Including a test case with multiple subdomains\n  * docs(watermarkimage): Add docs for the /watermarkimage endpoint (#226)\n  * refactor(README): remove header image\n\nv1.0.16 / 2018-12-11\n====================\n\n  * Adding LIBVIPS 8.7 and updating libvips URL (#225)\n\nv1.0.15 / 2018-12-10\n====================\n\n  * Updating bimg, libvips and Go\n  * Updated dockerfile vips repo (#222)\n  * fix: correct fit operation with autorotated images by switching width/height in certain cases (#208)\n  * Watermark image api (#221)\n  * Adding remote url wildcard support (#219)\n  * Bump Go versions and use '.x' to always get latest patch versions (#220)\n  * Update README.md (#207)\n  * Fix typo in documentation (#202)\n  * Drop salt as suggested in #194 (#200)\n  * Add URL signature feature (#194)\n  * fix(docker): remove race detector (#197)\n  * feat(version): bump to v1.0.15\n  * Changing build steps (#189)\n\nv1.0.14 / 2018-03-05\n====================\n\n  * feat(version): bump to v1.0.14\n  * Add Docker Compose note to README (#174)\n  * Fixes https by installing root CA certificates (#186)\n\nv1.0.13 / 2018-03-01\n====================\n\n  * fix(Dockerfile): update version sha2 hash\n  * feat(history): update changelog\n  * feat(version): bump to v1.0.13\n  * feat(Docker): upgrade libvips to v8.6.2 (#184)\n  * feat(vendor): upgrade bimg to v1.0.18\n  * fix(debug): implement custom debug function\n  * feat: add docker-compose.yml\n  * Merge branch 'master' of https://github.com/h2non/imaginary\n  * refactor(vendor): remove go-debug package from vendor\n  * refactor(docs): remove codesponsor :(\n  * fix testdata image links (#173)\n  * Log hours in 24 hour clock (#165)\n  * refactor(docs): update CLI usage and minimum requirements\n\nv1.0.11 / 2017-11-14\n====================\n\n  * fix(type_test): use string for proper formatting\n  * feat(version): bump to v1.0.11\n  * feat(bimg): update to v1.0.17\n  * Merge branch 'realla-add-fit'\n  * merge(add-fit): fix conflicts in server_test.go\n  * refactor(image): remove else statement\n  * fix(test): remove unused variable body\n  * Add type=auto using client Accept header to auto negotiate type. (#162)\n  * Add /fit action\n\nv1.0.10 / 2017-10-30\n====================\n\n  * feat(docs): update CLI usage help\n  * feat(#156): support disable endpoints (#160)\n\nv1.0.9 / 2017-10-29\n===================\n\n  * feat(version): bump to v1.0.9\n  * fix(#157): disable gzip compression support\n  * debug(travis)\n  * debug(travis)\n  * debug(travis)\n  * debug(travis)\n  * debug(travis)\n  * refactor(Dockerfile): use local source copy\n  * refactor(requirements): add Go 1.6+ as minimum requirement\n  * feat(vendor): support dependencies vendoring\n  * refactor(Gopkg): define version\n  * feat(vendor): add vendor dependencies\n  * feat(travis): add Go 1.9 support\n  * refactor(docs): specify POST payloads in description\n  * feat(docs): add imagelayer badge\n  * feat(docs): add imagelayer badge\n  * feat(docs): add imagelayer badge\n  * feat(docs): add imagelayer badge\n\nv1.0.8 / 2017-10-06\n===================\n\n  * feat(#101): add pipeline endpoint implementation + smart crop (#154)\n  * refactor(docs): move sponsor banner\n  * feat(docs): add sponsor ad\n  * refactor(license): update copyright\n\nv1.0.7 / 2017-09-11\n===================\n\n  * feat(version): bump to v1.0.7\n  * feat(version): bump to v1.0.6\n\nv1.0.5 / 2017-09-10\n===================\n\n  * feat(version): bump to v1.0.5\n  * feat(History): update version changes\n  * feat(params): add stripmeta params\n\nv1.0.4 / 2017-08-21\n===================\n\n  * feat(version): bump to 1.0.4\n  * Mapping Blur URL params to the ImageOptions struct fields (#152)\n\nv1.0.3 / 2017-08-20\n===================\n\n  * feat(version): bump to v1.0.3\n  * Merge branch 'master' of https://github.com/h2non/imaginary\n  * fix(docs): CLI spec typo\n  * Adding the Gaussian Blur feature plus a few minor formatting with gofmt. (#150)\n  * feat(docs): update maintainer note\n\nv1.0.2 / 2017-07-28\n===================\n\n  * feat(version): bump to v1.0.2\n  * fix(#146): handle proper response code range for max allowed size\n  * Typos and minor language in help text (#144)\n  * Update README.md (#143)\n  * feat(History): add missing Docker changes\n  * fix(server_test): assert content type header is present\n  * fix(Docker): use proper SHA256 hash\n  * feat(Docker): upgrade Go to v1.8.3 and libvips to v8.5.6\n  * feat(changelog): update v1.0.1 changes\n  * feat(version): bump to v1.0.1\n  * feat(#140): expose Content-Length header\n\nv1.0.0 / 2017-05-27\n===================\n\n  * refactor(controller): add height for smart crop form\n  * feat(controllers): add smart crop form\n  * feat(version): bump to v1.0.0\n  * feat(History): update changes\n  * Supporting smart crop (#136)\n\nv0.1.31 / 2017-05-18\n====================\n\n  * feat(History): update latest changes\n  * feat(version): bump to 0.1.31\n  * feat(Dockerfile): use libvips v8.5.5, Go v1.8.1 and bimg v1.0.8\n  * Correcting the documentation, caching headers are always sent, regardless of being fetched from mount or by URL. (#133)\n  * fix(docs): move toc top level sections\n  * feat(docs): add new maintainer notice (thanks to @kirillDanshin)\n  * feat(travis): use Go 1.8\n  * refactor(docs): update support badges\n  * feat(docs): add maintainers section\n  * fix(.godir): add project name\n  * fix(#124): fast workaround to unblock Heroku deployment until the buildpack can be updated\n  * Deploy on Cloud Foundry PaaS (#122)\n  * Add backers & sponsors from open collective (#119)\n  * 1. remove the .godir as Heroku and Cloud Foundry remove the support. (#117)\n\nv0.1.30 / 2017-01-18\n====================\n\n  * refacgor(version): add comments\n  * feat(version): bump to v0.1.30\n  * feat(History): update changes\n  * fix(travis): remove libvips 8.5\n  * feat(travis): add multi libvips testing environments\n  * fix(travis): use proper preinstall.sh URL\n  * Update .travis.yml\n  * fix(tests): integration with bimg v1.0.7\n  * fix(type): bimg v1.0.7 integration\n  * fix(type): bimg v1.0.7 integration\n  * Update History.md\n\nv0.1.29 / 2016-12-18\n====================\n\n  * feat(version): bump to 0.1.29\n  * feat(max-allowed-size): add new option max-allowed-size in bytes (#111)\n  * Merge pull request #112 from touhonoob/fix-help-allowed-origins\n  * fix(usage): correct help message of 'allowed-origins'\n  * refactor(docs): remove deprecated sharp benchmark results\n  * refactor(docs): update preinstall.sh install URL\n  * refactor(docs): use preinstall.sh script from bimg repository\n  * fix(docs): Docker image link\n  * fix(history)\n  * fix(history)\n\nv0.1.28 / 2016-10-02\n====================\n\n  * feat(docs): add placeholder docs and several refactors\n  * feat(docs): add placeholder docs and several refactors\n  * feat(#94): support placeholder image\n  * feat(version): bump to v0.1.28\n  * feat(version): release v0.1.28\n  * feat(core): support bimg@1.0.5, support extend background param\n  * chore(history): add Docker Go 1.7.1 support\n  * feat(docker): use Go 1.7.1\n\nv0.1.27 / 2016-09-28\n====================\n\n  * fix(server): mount route\n  * refactor(server): DRYer path prefix\n  * Merge pull request #93 from h2non/develop\n  * fix(tests): type tests based on libvips runtime support\n  * feat(version): bump\n  * feat(travis): add Go 1.7\n  * feat(docs): add new formats support\n  * fix(history): update to bimg@1.0.3\n  * fix(controllers): fix binary image processing\n  * refactor(controllers)\n  * Merge branch 'develop' of github.com:h2non/imaginary into develop\n  * feat(core): add additional image formats\n  * feat(core): add support for bimg@1.0.2 and new image formats\n  * Merge pull request #90 from iosphere/feature/path-prefix\n  * Add `path-prefix` flag to bind to an url path\n  * Merge pull request #89 from h2non/develop\n  * refactor(cli): update flag description\n  * feat(docs): improve CLI docs\n  * refactor(cli): improve description for -authorization flag\n\nv0.1.26 / 2016-09-06\n====================\n\n  * fix(merge): master\n  * chore(history): update history changelog\n  * feat(docs): update CLI usage and help\n  * feat: forward authorization headers support\n  * Fix description for URL source, and allowed origins server options (#83)\n  * fix(version): ups, editing from iPad\n  * fix(version): unresolved conflict\n  * merge: fix History conflicts\n  * Merge branch 'develop'\n  * Fix Expires and Cache-Control headers to be valid (#77)\n  * Update README.md (#74)\n  * Promote version 0.1.24 (#73)\n\n0.1.25 / 2016-05-27\n===================\n\n  * Sync develop (#82)\n  * feat(version): bump\n  * fix(#79): infer buffer type via magic numbers signature\n  * Sync develop (#80)\n\nv0.1.24 / 2016-04-21\n====================\n\n  * feat(version): bump\n  * Merge branch 'develop' of github.com:h2non/imaginary into develop\n  * Sync develop (#72)\n  * merge(upstream)\n  * refactor(travis)\n  * feat(bimg): bump version to v1\n  * Sync develop (#71)\n  * add background param (#69)\n  * Merge pull request #70 from h2non/develop\n  * fix(docs): typo\n  * fix(docs): minor typos\n  * Merge pull request #64 from h2non/develop\n  * Merge pull request #63 from h2non/develop\n\n0.1.23 / 2016-04-06\n===================\n\n  * feat(docs): add flip flop params\n  * feat(version): bump\n  * feat(#66): flip/flop support as param\n  * feat(timeout): increase read/write timeout to 60 seconds\n\n0.1.22 / 2016-02-20\n===================\n\n  * feat(docker): use SHA256 checksum\n  * feat: update history\n  * feat(version): bump\n  * feat(docs)\n  * feat(#62): support allowed origins\n  * feat(#62): support allowed origins\n  * Merge pull request #61 from h2non/master\n  * feat(travis): use go 1.6\n  * Merge pull request #60 from h2non/develop\n  * feat(history): add change log\n  * Merge pull request #59 from h2non/develop\n  * Merge pull request #58 from h2non/develop\n\n0.1.21 / 2016-02-09\n===================\n\n  * feat(version): bump\n\n0.1.20 / 2016-02-06\n===================\n\n  * feat(version): bump\n  * feat(docs): add PKGCONFIg variable\n  * merge(master)\n  * Merge pull request #57 from h2non/develop\n  * Merge pull request #56 from h2non/develop\n  * Merge pull request #55 from h2non/develop\n  * Merge pull request #54 from pra85/patch-1\n  * Typo fixes\n  * fix(docs): typo in scalability\n  * Merge pull request #53 from h2non/develop\n  * feat(docs): add imaginary badge\n  * refactor(docs): improve scalability notes\n  * feat(docs): add docker pulls badge\n  * feat(docs): add form data spec\n\n0.1.19 / 2016-01-30\n===================\n\n  * refactor(form): use previous params\n  * feat(docs): add rotate param in endpoints\n  * feat(version): bump\n  * feat(#49): support custom form field\n  * fix(docs): minor typo\n  * feat: add more tests, partially document code\n  * refactor(controllers): use external struct\n  * refactor: follow go idioms\n  * refactor(middleware): rename function\n  * refactor(middleware): only cache certain requests\n  * fix(docs): use proper flag\n  * fix(docs): add supported method\n  * fix(cli): bad flag description\n  * fix\n  * refactor(health)\n  * refactor\n  * feat: ignore imaginary root binary\n  * refactor(middleware)\n  * feat(docs): add examples\n  * feat(docs): update CLI help\n\n0.1.18 / 2015-11-04\n===================\n\n  * feat(version): bump\n  * fix(badge)\n  * fix(badge)\n  * merge(upstream)\n  * feat(docs): add remote URL support, update badges\n  * refactor(cli): change flag\n  * feat(#43, #35): support gravity param and health\n  * feat(#32): add test coverage\n  * feat(#32): initial support for URL processing\n  * fix(tests)\n  * feat(#32): support flags\n  * feat(#32): initial seed implementation\n  * Merge pull request #44 from freeformz/master\n  * Add Heroku Button Support\n  * fix(docs): content typo\n  * feat: add glide.yaml for vendording packages\n  * feat: add glide.yaml for vendording packages\n  * refactor(docs): add performance note\n  * refactor(docs)\n  * refactor(benchmark): uncomment kill sentence\n  * feat(docs): add benchmark notes\n  * refactor(image): add default error on panic\n  * feat: add panic handler. feat(docs): add error docs\n\n0.1.17 / 2015-10-31\n===================\n\n  * feat(version): bump\n  * Merge pull request #39 from Dynom/addingHttpCaching\n  * Added documentation.\n  * More style fixes.\n  * Removing redundant construct\n  * Fixing coding-style\n  * Merge pull request #41 from Dynom/enablingSecureDownloadOfGo\n  * Added the CA certs so that the --insecure flag can be removed from the GO installer.\n  * Added a sanity check for the value of the -http-cache-ttl flag.\n  * Added -http-cache-ttl flag\n  * feat(log): add comments\n  * refactor(body)\n  * refactor(benchmark)\n  * refactor(benchmark)\n  * refactor: rename function\n  * refactor: normalize statements, add minor docs\n  * refactor(docs): add link\n  * feat(docs): add toc\n\n0.1.16 / 2015-10-06\n===================\n\n  * fix(docker): restore to default\n  * refactor(docker): uses latest version\n  * feat(version): bump\n  * fix(#31): use libvips 7.42 docker tag\n  * refactor(docs): update descriptiong\n  * feat(docs): add libvips version compatibility note\n  * merge(upstream)\n  * refactor(docs): add root endpoint, fix minor typos\n  * refactor(docs): description\n  * feat(docs): add sourcegraph badge\n  * refactor(docs): minor changes, reorder\n\n0.1.15 / 2015-09-29\n===================\n\n  * feat(version): bump\n  * merge: upstream\n  * feat: expose libvips and bimg version in index route\n  * refactor(docs): add docker debug command\n\n0.1.14 / 2015-08-30\n===================\n\n  * fix: build\n  * refactor(docker): bump Go version\n  * feat(version): bump\n  * feat: use throttle v2\n  * refactor(make): push specific tag\n\n0.1.13 / 2015-08-10\n===================\n\n  * feat(version): bump\n  * feat(#30)\n\n0.1.12 / 2015-07-29\n===================\n\n  * feat(version): bump\n  * fix(dependency)\n  * refactor: add errors as constants. middleware\n  * refactor: add errors as constants. middleware\n  *  fix(docs): typo\n  * fix(travis): remove go tip build due to install.sh error\n  * refactor: server router\n  * refactor:\n  * fix(docs): add missing params per specific method\n  * feat(docs): add image\n  * feat(docs): add link\n\n0.1.11 / 2015-07-11\n===================\n\n  * feat(version): bump\n  * feat(#26): add TLS support\n  * feat(#27)\n  * feat(#27)\n  * refactor(docs)\n  * fix(docs): description\n  * fix\n  * feat: merge\n  * refactor(form): dry\n  * refactor(docs): http api\n  * refactor(main)\n\n0.1.10 / 2015-06-30\n===================\n\n  * feat(version): bump\n  * refactor(docs)\n  * feat(#25): several refactors and test coverage\n  * feat(#25): experimental support for local files processing\n  * feat: support no profile param\n  * feat(http): add bimg version header\n  * feat(http): add bimg header\n  * refactor(docs): node graph\n\n0.1.9 / 2015-06-12\n==================\n\n  * refactor: disable interlace by default (due to performance issues)\n  * feat(version): bump\n  * feat: add interlace support by default\n  * refactor(image): remove debug statement\n  * refactor(docs): description\n  * fix(form): add proper param for watermark\n  * fix(form): add proper param for watermark\n  * refactor(docs): description\n  * refactor(params): use math function\n\n0.1.8 / 2015-05-24\n==================\n\n  * feat(version): bump\n  * feat(version): bump\n  * fix(form): bad param\n  * refactor(docs): scalability\n  * refactor(docs): benchmark\n  * refactor(docs): description\n  * refactor(docs): usage\n  * refactor(docs): update sections\n  * refactor(bench). feat(docs): add resources and scalability notes\n  * refactor(docs)\n  * refact(bench)\n  * feat(docs): add production note\n  * merge\n  * refactor(server): isolate throttle to middleware\n  * fix(docs): duplicated param\n\n0.1.7 / 2015-04-27\n==================\n\n  * fix(extract): bad query param\n  * feat(version): bump\n  * fix(enlarge): bad params assignment\n  * feat(#24): crop by default\n\n0.1.6 / 2015-04-26\n==================\n\n  * feat(version): bump (maintenance release)\n\n0.1.5 / 2015-04-25\n==================\n\n  * feat(version): bump\n  * feat(params): add params for no auto rotate\n  * feat(params): add params for no auto rotate\n  * refactor(docs): description\n  * fix(docs): description\n  * refactor(docs): description\n  * refactor(docs): add new Heroku steps\n  * refactor(buildpack)\n  * refactor(buildpack)\n  * refactor(buildpack)\n  * refactor(buildpack)\n  * fix(heroku)\n  * refactor: update buildpack\n\n0.1.4 / 2015-04-19\n==================\n\n  * feat(version): bump\n  * feat: handle HTTP 404\n  * feat(heroku): update docs\n  * feat: update buildpack\n  * feat\n  * refactor(heroku)\n  * fix(heroku): buildpack order\n  * feat(#23)\n\n0.1.3 / 2015-04-19\n==================\n\n  * feat(version): bumo\n  * fix(port)\n  * refactor(docker): remove help flag\n  * refactor: heroku\n  * refactor\n  * refactor\n  * refactor\n  * refactor\n  * feat: add dependencies\n  * feat: add dependencies\n  * feat: add heroku files\n  * feat: add Heroku files\n  * refactor(docs): update description\n  * refactor(image)\n  * fix(docs)\n\n0.1.2 / 2015-04-18\n==================\n\n  * refactor(bench)\n  * feat(docs): better Heroku docs\n  * refactor: split parse params and body read\n  * feat(docs): add server clients\n  * refactor(docs)\n  * fix(form): add query param\n  * fix(docs): usage\n  * fix(cli): memory release\n  * fix(travis)\n\n0.1.1 / 2015-04-15\n==================\n\n  * feat(version): bump\n  * feat(#20) fix(#2)\n  * feat: refactor\n  * refactor(bench)\n  * refactor(docs)\n  * feat(docs): add benchmarks\n  * feat(docs): add benchmarks\n  * feat(docs): add benchmarks\n  * feat(#16): add benchmark\n  * refactor(docs)\n  * refactor(docs)\n\n0.1.0 / 2015-04-13\n==================\n\n  * feat(#18): http docs\n  * fix(travis): another attempt\n  * fix(travis)\n  * fix(docs)\n  * fix(travis)\n  * fix(travis)\n  * refactor(docs): docker\n  * refactor(cli): priorize CLI flag\n  * refactor(server)\n  * fix(travis): pending issue from Coveralls\n  * feat: add Makefile\n  * fix(package): name\n  * feat(docs): add docker badge\n\n0.1.0-rc.0 / 2015-04-12\n=======================\n\n  * feat(test): add test coverage\n  * refactor\n  * feat(#15): docker file settings\n  * feat(#19, #10, #13)\n  * feat(docs): add image\n  * feat(docs): add image\n  * feat(docs): add image\n  * feat(image): add image\n  * feat(#15, #11, #7, #5, #13)\n  * feat(#17, #7, #2)\n  * refactor: rename\n  * refactor: remove file\n  * refactor: rename\n  * refactor: use bimg\n  * refactor(image): options\n  * feat: add upload test\n  * refactor\n  * refactor\n  * feat: add Dockerfile\n  * refactor: server\n  * feat: add test\n  * feat: add test\n  * feat: add test\n  * feat: add sources\n  * feat: add files\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0712890625,
          "content": "The MIT License\n\nCopyright (c) 2015-2020 Tomas Aparicio and contributors\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5859375,
          "content": "OK_COLOR=\\033[32;01m\nNO_COLOR=\\033[0m\n\nbuild:\n\t@echo \"$(OK_COLOR)==> Compiling binary$(NO_COLOR)\"\n\tgo test && go build -o bin/imaginary\n\ntest:\n\tgo test\n\ninstall:\n\tgo get -u .\n\nbenchmark: build\n\tbash benchmark.sh\n\ndocker-build:\n\t@echo \"$(OK_COLOR)==> Building Docker image$(NO_COLOR)\"\n\tdocker build --no-cache=true --build-arg IMAGINARY_VERSION=$(VERSION) -t h2non/imaginary:$(VERSION) .\n\ndocker-push:\n\t@echo \"$(OK_COLOR)==> Pushing Docker image v$(VERSION) $(NO_COLOR)\"\n\tdocker push h2non/imaginary:$(VERSION)\n\ndocker: docker-build docker-push\n\n.PHONY: test benchmark docker-build docker-push docker\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.0146484375,
          "content": "web: imaginary\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 56.3837890625,
          "content": "# imaginary [![Docker](https://img.shields.io/badge/docker-h2non/imaginary-blue.svg)](https://hub.docker.com/r/h2non/imaginary/) [![Docker Registry](https://img.shields.io/docker/pulls/h2non/imaginary.svg)](https://hub.docker.com/r/h2non/imaginary/) [![Fly.io](https://img.shields.io/badge/deploy-fly.io-blue.svg)](https://fly.io/launch/github/h2non/imaginary)\n\n**[Fast](#benchmarks) HTTP [microservice](http://microservices.io/patterns/microservices.html)** written in Go **for high-level image processing** backed by [bimg](https://github.com/h2non/bimg) and [libvips](https://github.com/jcupitt/libvips). `imaginary` can be used as private or public HTTP service for massive image processing with first-class support for [Docker](#docker) & [Fly.io](#flyio).\nIt's almost dependency-free and only uses [`net/http`](http://golang.org/pkg/net/http/) native package without additional abstractions for better [performance](#performance).\n\nSupports multiple [image operations](#supported-image-operations) exposed as a simple [HTTP API](#http-api),\nwith additional optional features such as **API token authorization**, **URL signature protection**, **HTTP traffic throttle** strategy and **CORS support** for web clients.\n\n`imaginary` **can read** images **from HTTP POST payloads**, **server local path** or **remote HTTP servers**, supporting **JPEG**, **PNG**, **WEBP**, **HEIF**, and optionally **TIFF**, **PDF**, **GIF** and **SVG** formats if `libvips@8.3+` is compiled with proper library bindings.\n\n`imaginary` is able to output images as JPEG, PNG and WEBP formats, including transparent conversion across them.\n\n`imaginary` optionally **supports image placeholder fallback mechanism** in case of image processing error or server error of any nature, hence an image will be always returned by imaginary even in case of error, trying to match the requested image size and format type transparently. The error details will be provided in the response HTTP header `Error` field serialized as JSON.\n\n`imaginary` uses internally `libvips`, a powerful and efficient library written in C for fast image processing\nwhich requires a [low memory footprint](https://github.com/libvips/libvips/wiki/Benchmarks)\nand it's typically 4x faster than using the quickest ImageMagick and GraphicsMagick\nsettings or Go native `image` package, and in some cases it's even 8x faster processing JPEG images.\n\nTo get started, take a look the [installation](#installation) steps, [usage](#command-line-usage) cases and [API](#http-api) docs.\n\n## Contents\n\n- [Supported image operations](#supported-image-operations)\n- [Prerequisites](#prerequisites)\n- [Installation](#installation)\n  - [Docker](#docker)\n  - [Fly.io](#flyio)\n  - [Cloud Foundry](#cloudfoundry)\n  - [Google Cloud Run](#google-cloud-run)\n- [Recommended resources](#recommended-resources)\n- [Production notes](#production-notes)\n- [Scalability](#scalability)\n- [Clients](#clients)\n- [Performance](#performance)\n- [Benchmark](#benchmark)\n- [Command-line usage](#command-line-usage)\n- [HTTP API](#http-api)\n  - [Authorization](#authorization)\n  - [URL signature](#url-signature)\n  - [Errors](#errors)\n  - [Form data](#form-data)\n  - [Params](#params)\n  - [Endpoints](#get-)\n- [Logging](#logging)\n  - [Fluentd log ingestion](#fluentd-log-ingestion)\n- [Authors](#authors)\n- [License](#license)\n\n## Supported image operations\n\n- Resize\n- Enlarge\n- Crop\n- SmartCrop (based on [libvips built-in algorithm](https://github.com/jcupitt/libvips/blob/master/libvips/conversion/smartcrop.c))\n- Rotate (with auto-rotate based on EXIF orientation)\n- AutoRotate with further image transformations (based on EXIF metadata orientation)\n- Flip (with auto-flip based on EXIF metadata)\n- Flop\n- Zoom\n- Thumbnail\n- Fit\n- [Pipeline](#get--post-pipeline) of multiple independent image transformations in a single HTTP request.\n- Configurable image area extraction\n- Embed/Extend image, supporting multiple modes (white, black, mirror, copy or custom background color)\n- Watermark (customizable by text)\n- Watermark image\n- Custom output color space (RGB, black/white...)\n- Format conversion (with additional quality/compression settings)\n- Info (image size, format, orientation, alpha...)\n- Reply with default or custom placeholder image in case of error.\n- Blur\n\n## Prerequisites\n\n- [libvips](https://github.com/jcupitt/libvips) 8.8+ (8.9+ recommended)\n- C compatible compiler such as gcc 4.6+ or clang 3.0+\n- Go 1.12+\n\n## Installation\n\n```bash\ngo get -u github.com/h2non/imaginary\n```\n\nAlso, be sure you have the latest version of `bimg`:\n```bash\ngo get -u github.com/h2non/bimg\n```\n\n### libvips\n\nRun the following script as `sudo` (supports OSX, Debian/Ubuntu, Redhat, Fedora, Amazon Linux):\n```bash\ncurl -s https://raw.githubusercontent.com/h2non/bimg/master/preinstall.sh | sudo bash -\n```\n\nThe [install script](https://github.com/h2non/bimg/blob/master/preinstall.sh) requires `curl` and `pkg-config`\n\n### Docker\n\nSee [Dockerfile](https://github.com/h2non/imaginary/blob/master/Dockerfile) for image details.\n\nFetch the image (comes with latest stable Go and `libvips` versions)\n```\ndocker pull h2non/imaginary\n```\n\nStart the container with optional flags (default listening on port 9000)\n```\ndocker run -p 9000:9000 h2non/imaginary -cors -gzip\n```\n\nStart the container enabling remote URL source image processing via GET requests and `url` query param.\n```\ndocker run -p 9000:9000 h2non/imaginary -p 9000 -enable-url-source\n```\n\nStart the container enabling local directory image process via GET requests and `file` query param.\n```\ndocker run -p 9000:9000 h2non/imaginary -p 900 -mount /volume/images\n```\n\nStart the container in debug mode:\n```\ndocker run -p 9000:9000 -e \"DEBUG=*\" h2non/imaginary\n```\n\nEnter to the interactive shell in a running container\n```\nsudo docker exec -it <containerIdOrName> bash\n```\n\nStop the container\n```\ndocker stop h2non/imaginary\n```\n\nFor more usage examples, see the [command line usage](#command-line-usage).\n\nAll Docker images tags are available [here](https://hub.docker.com/r/h2non/imaginary/tags/).\n\n#### Docker Compose\n\nYou can add `imaginary` to your `docker-compose.yml` file:\n\n```yaml\nversion: \"3\"\nservices:\n  imaginary:\n    image: h2non/imaginary:latest\n    # optionally mount a volume as local image source\n    volumes:\n      - images:/mnt/data\n    environment:\n       PORT: 9000\n    command: -enable-url-source -mount /mnt/data\n    ports:\n      - \"9000:9000\"\n```\n\n### Fly.io\n\nDeploy imaginary in seconds close to your users in [Fly.io](https://fly.io) cloud by clicking on the button below:\n\n<a href=\"https://fly.io/docs/app-guides/run-a-global-image-service/\">\n  <img src=\"testdata/flyio-button.svg?raw=true\" width=\"200\">\n</a>\n\n#### About Fly.io\n\nFly is a platform for applications that need to run globally. It runs your code close to users and scales compute in cities where your app is busiest. Write your code, package it into a Docker image, deploy it to Fly's platform and let that do all the work to keep your app snappy.\n\nYou can [learn more](https://fly.io/docs/) about how Fly.io can reduce latency and provide a better experience by serving traffic close to your users location.\n\n#### Global image service tutorial\n\n[Learn more](https://fly.io/docs/app-guides/run-a-global-image-service/) about how to run a custom deployment of imaginary on the Fly.io cloud.\n\n### CloudFoundry\n\nAssuming you have cloudfoundry account, [bluemix](https://console.ng.bluemix.net/) or [pivotal](https://console.run.pivotal.io/) and [command line utility installed](https://github.com/cloudfoundry/cli).\n\nClone this repository:\n```\ngit clone https://github.com/h2non/imaginary.git\n```\n\nPush the application\n```\ncf push -b https://github.com/yacloud-io/go-buildpack-imaginary.git imaginary-inst01 --no-start\n```\n\nDefine the library path\n```\ncf set-env imaginary-inst01 LD_LIBRARY_PATH /home/vcap/app/vendor/vips/lib\n```\n\nStart the application\n```\ncf start imaginary-inst01\n```\n\n### Google Cloud Run\n\nClick to deploy on Google Cloud Run:\n\n[![Run on Google Cloud](https://deploy.cloud.run/button.svg)](https://deploy.cloud.run)\n\n### Recommended resources\n\nGiven the multithreaded native nature of Go, in terms of CPUs, most cores means more concurrency and therefore, a better performance can be achieved.\nFrom the other hand, in terms of memory, 512MB of RAM is usually enough for small services with low concurrency (<5 requests/second).\nUp to 2GB for high-load HTTP service processing potentially large images or exposed to an eventual high concurrency.\n\nIf you need to expose `imaginary` as public HTTP server, it's highly recommended to protect the service against DDoS-like attacks.\n`imaginary` has built-in support for HTTP concurrency throttle strategy to deal with this in a more convenient way and mitigate possible issues limiting the number of concurrent requests per second and caching the awaiting requests, if necessary.\n\n### Production notes\n\nIn production focused environments it's highly recommended to enable the HTTP concurrency throttle strategy in your `imaginary` servers.\n\nThe recommended concurrency limit per server to guarantee a good performance is up to `20` requests per second.\n\nYou can enable it simply passing a flag to the binary:\n```\n$ imaginary -concurrency 20\n```\n\n### Memory issues\n\nIn case you are experiencing any persistent unreleased memory issues in your deployment, you can try passing this environment variables to `imaginary`:\n\n```\nMALLOC_ARENA_MAX=2 imaginary -p 9000 -enable-url-source\n```\n\n### Graceful shutdown\n\nWhen you use a cluster, it is necessary to control how the deployment is executed, and it is very useful to finish the containers in a controlled manner.\n\nYou can use the next command:\n\n```\n$ ps auxw | grep 'bin/imaginary' | awk 'NR>1{print buf}{buf = $2}' | xargs kill -TERM > /dev/null 2>&1\n```\n\n### Scalability\n\nIf you're looking for a large scale solution for massive image processing, you should scale `imaginary` horizontally, distributing the HTTP load across a pool of imaginary servers.\n\nAssuming that you want to provide a high availability to deal efficiently with, let's say, 100 concurrent req/sec, a good approach would be using a front end balancer (e.g: HAProxy) to delegate the traffic control flow, ensure the quality of service and distribution the HTTP across a pool of servers:\n\n```\n        |==============|\n        |  Dark World  |\n        |==============|\n              ||||\n        |==============|\n        |   Balancer   |\n        |==============|\n           |       |\n          /         \\\n         /           \\\n        /             \\\n /-----------\\   /-----------\\\n | imaginary |   | imaginary | (*n)\n \\-----------/   \\-----------/\n```\n\n## Clients\n\n- [node.js](https://github.com/h2non/node-imaginary)\n\nFeel free to send a PR if you created a client for other language.\n\n## Performance\n\nlibvips is probably the faster open source solution for image processing.\nHere you can see some performance test comparisons for multiple scenarios:\n\n- [libvips speed and memory usage](https://github.com/libvips/libvips/wiki/Benchmarks)\n- [bimg](https://github.com/h2non/bimg#Performance) (Go library with C bindings to libvips)\n\n## Benchmark\n\nSee [benchmark.sh](https://github.com/h2non/imaginary/blob/master/benchmark.sh) for more details\n\nEnvironment: Go 1.4.2. libvips-7.42.3. OSX i7 2.7Ghz\n\n```\nRequests  [total]       200\nDuration  [total, attack, wait]   10.030639787s, 9.949499515s, 81.140272ms\nLatencies [mean, 50, 95, 99, max]   83.124471ms, 82.899435ms, 88.948008ms, 95.547765ms, 104.384977ms\nBytes In  [total, mean]     23443800, 117219.00\nBytes Out [total, mean]     175517000, 877585.00\nSuccess   [ratio]       100.00%\nStatus Codes  [code:count]      200:200\n```\n\n### Conclusions\n\n`imaginary` can deal efficiently with up to 20 request per second running in a multicore machine,\nwhere it crops a JPEG image of 5MB and spending per each request less than 100 ms\n\nThe most expensive image operation under high concurrency scenarios (> 20 req/sec) is the image enlargement, which requires a considerable amount of math operations to scale the original image. In this kind of operation the required processing time usually grows over the time if you're stressing the server continuously. The advice here is as simple as taking care about the number of concurrent enlarge operations to avoid server performance bottlenecks.\n\n## Command-line usage\n\n```\nUsage:\n  imaginary -p 80\n  imaginary -cors\n  imaginary -concurrency 10\n  imaginary -path-prefix /api/v1\n  imaginary -enable-url-source\n  imaginary -disable-endpoints form,health,crop,rotate\n  imaginary -enable-url-source -allowed-origins http://localhost,http://server.com,http://*.example.org\n  imaginary -enable-url-source -enable-auth-forwarding\n  imaginary -enable-url-source -authorization \"Basic AwDJdL2DbwrD==\"\n  imaginary -enable-placeholder\n  imaginary -enable-url-source -placeholder ./placeholder.jpg\n  imaginary -enable-url-signature -url-signature-key 4f46feebafc4b5e988f131c4ff8b5997\n  imaginary -enable-url-source -forward-headers X-Custom,X-Token\n  imaginary -h | -help\n  imaginary -v | -version\n\nOptions:\n  -a <addr>                 Bind address [default: *]\n  -p <port>                 Bind port [default: 8088]\n  -h, -help                 Show help\n  -v, -version              Show version\n  -path-prefix <value>      Url path prefix to listen to [default: \"/\"]\n  -cors                     Enable CORS support [default: false]\n  -gzip                     Enable gzip compression (deprecated) [default: false]\n  -disable-endpoints        Comma separated endpoints to disable. E.g: form,crop,rotate,health [default: \"\"]\n  -key <key>                Define API key for authorization\n  -mount <path>             Mount server local directory\n  -http-cache-ttl <num>     The TTL in seconds. Adds caching headers to locally served files.\n  -http-read-timeout <num>  HTTP read timeout in seconds [default: 60]\n  -http-write-timeout <num> HTTP write timeout in seconds [default: 60]\n  -enable-url-source        Enable remote HTTP URL image source processing (?url=http://..)\n  -enable-placeholder       Enable image response placeholder to be used in case of error [default: false]\n  -enable-auth-forwarding   Forwards X-Forward-Authorization or Authorization header to the image source server. -enable-url-source flag must be defined. Tip: secure your server from public access to prevent attack vectors\n  -forward-headers          Forwards custom headers to the image source server. -enable-url-source flag must be defined.\n  -enable-url-signature     Enable URL signature (URL-safe Base64-encoded HMAC digest) [default: false]\n  -url-signature-key        The URL signature key (32 characters minimum)\n  -allowed-origins <urls>   Restrict remote image source processing to certain origins (separated by commas). Note: Origins are validated against host *AND* path.\n  -max-allowed-size <bytes> Restrict maximum size of http image source (in bytes)\n  -max-allowed-resolution <megapixels> Restrict maximum resolution of the image [default: 18.0]\n  -certfile <path>          TLS certificate file path\n  -keyfile <path>           TLS private key file path\n  -authorization <value>    Defines a constant Authorization header value passed to all the image source servers. -enable-url-source flag must be defined. This overwrites authorization headers forwarding behavior via X-Forward-Authorization\n  -placeholder <path>       Image path to image custom placeholder to be used in case of error. Recommended minimum image size is: 1200x1200\n  -concurrency <num>        Throttle concurrency limit per second [default: disabled]\n  -burst <num>              Throttle burst max cache size [default: 100]\n  -mrelease <num>           OS memory release interval in seconds [default: 30]\n  -cpus <num>               Number of used cpu cores.\n                            (default for current machine is 8 cores)\n  -log-level                Set log level for http-server. E.g: info,warning,error [default: info].\n                            Or can use the environment variable GOLANG_LOG=info.\n```\n\nStart the server in a custom port:\n```bash\nimaginary -p 8080\n```\n\nAlso, you can pass the port as environment variable:\n```bash\nPORT=8080 imaginary\n```\n\nEnable HTTP server throttle strategy (max 10 requests/second):\n```\nimaginary -p 8080 -concurrency 10\n```\n\nEnable remote URL image fetching (then you can do GET request passing the `url=http://server.com/image.jpg` query param):\n```\nimaginary -p 8080 -enable-url-source\n```\n\nMount local directory (then you can do GET request passing the `file=image.jpg` query param):\n```\nimaginary -p 8080 -mount ~/images\n```\n\nEnable authorization header forwarding to image origin server. `X-Forward-Authorization` or `Authorization` (by priority) header value will be forwarded as `Authorization` header to the target origin server, if one of those headers are present in the incoming HTTP request.\nSecurity tip: secure your server from public access to prevent attack vectors when enabling this option:\n```\nimaginary -p 8080 -enable-url-source -enable-auth-forwarding\n```\n\nOr alternatively you can manually define an constant Authorization header value that will be always sent when fetching images from remote image origins. If defined, `X-Forward-Authorization` or `Authorization` headers won't be forwarded, and therefore ignored, if present.\n**Note**:\n```\nimaginary -p 8080 -enable-url-source -authorization \"Bearer s3cr3t\"\n```\n\nSend fixed caching headers in the response. The headers can be set in either \"cache nothing\" or \"cache for N seconds\". By specifying `0` imaginary will send the \"don't cache\" headers, otherwise it sends headers with a TTL. The following example informs the client to cache the result for 1 year:\n```\nimaginary -p 8080 -enable-url-source -http-cache-ttl 31556926\n```\n\nEnable placeholder image HTTP responses in case of server error/bad request.\nThe placeholder image will be dynamically and transparently resized matching the expected image `width`x`height` define in the HTTP request params.\nAlso, the placeholder image will be also transparently converted to the desired image type defined in the HTTP request params, so the API contract should be maintained as much better as possible.\n\nThis feature is particularly useful when using `imaginary` as public HTTP service consumed by Web clients.\nIn case of error, the appropriate HTTP status code will be used to reflect the error, and the error details will be exposed serialized as JSON in the `Error` response HTTP header, for further inspection and convenience for API clients.\n```\nimaginary -p 8080 -enable-placeholder -enable-url-source\n```\n\nYou can optionally use a custom placeholder image.\nSince the placeholder image should fit a variety of different sizes, it's recommended to use a large image, such as `1200`x`1200`.\nSupported custom placeholder image types are: `JPEG`, `PNG` and `WEBP`.\n```\nimaginary -p 8080 -placeholder=placeholder.jpg -enable-url-source\n```\n\nEnable URL signature (URL-safe Base64-encoded HMAC digest).\n\nThis feature is particularly useful to protect against multiple image operations attacks and to verify the requester identity.\n```\nimaginary -p 8080 -enable-url-signature -url-signature-key 4f46feebafc4b5e988f131c4ff8b5997\n```\n\nIt is recommended to pass key as environment variables:\n```\nURL_SIGNATURE_KEY=4f46feebafc4b5e988f131c4ff8b5997 imaginary -p 8080 -enable-url-signature\n```\n\nIncrease libvips threads concurrency (experimental):\n```\nVIPS_CONCURRENCY=10 imaginary -p 8080 -concurrency 10\n```\n\nEnable debug mode:\n```\nDEBUG=* imaginary -p 8080\n```\n\nOr filter debug output by package:\n```\nDEBUG=imaginary imaginary -p 8080\n```\n\nDisable info logs:\n```\nGOLANG_LOG=error imaginary -p 8080\n```\n\n#### Examples\n\nReading a local image (you must pass the `-mount=<directory>` flag):\n```\ncurl -O \"http://localhost:8088/crop?width=500&height=400&file=foo/bar/image.jpg\"\n```\n\nFetching the image from a remote server (you must pass the `-enable-url-source` flag):\n```\ncurl -O \"http://localhost:8088/crop?width=500&height=400&url=https://raw.githubusercontent.com/h2non/imaginary/master/testdata/large.jpg\"\n```\n\nCrop behaviour can be influenced with the `gravity` parameter. You can specify a preference for a certain region (north, south, etc.). To enable Smart Crop you can specify the value \"smart\" to autodetect the most interesting section to consider as center point for the crop operation:\n```\ncurl -O \"http://localhost:8088/crop?width=500&height=200&gravity=smart&url=https://raw.githubusercontent.com/h2non/imaginary/master/testdata/smart-crop.jpg\"\n```\n\n\n#### Playground\n\n`imaginary` exposes an ugly HTML form for playground purposes in: [`http://localhost:8088/form`](http://localhost:8088/form)\n\n## HTTP API\n\n### Allowed Origins\n\nimaginary can be configured to block all requests for images with a src URL this is not specified in the `allowed-origins` list. Imaginary will validate that the remote url matches the hostname and path of at least one origin in allowed list. Perhaps the easiest way to show how this works is to show some examples.\n\n| `allowed-origins` setting | image url | is valid |\n| ------------------------- | --------- | -------- |\n| `-allowed-origins https://s3.amazonaws.com/some-bucket/` | `s3.amazonaws.com/some-bucket/images/image.png` | VALID |\n| `-allowed-origins https://s3.amazonaws.com/some-bucket/` | `s3.amazonaws.com/images/image.png` | NOT VALID (no matching basepath) |\n| `-allowed-origins https://s3.amazonaws.com/some-*` | `s3.amazonaws.com/some-bucket/images/image.png` | VALID |\n| `-allowed-origins https://*.amazonaws.com/some-bucket/` | `anysubdomain.amazonaws.com/some-bucket/images/image.png` | VALID |\n| `-allowed-origins https://*.amazonaws.com` | `anysubdomain.amazonaws.comimages/image.png` | VALID |\n| `-allowed-origins https://*.amazonaws.com` | `www.notaws.comimages/image.png` | NOT VALID (no matching host) |\n| `-allowed-origins https://*.amazonaws.com, foo.amazonaws.com/some-bucket/` | `bar.amazonaws.com/some-other-bucket/image.png` | VALID (matches first condition but not second) |\n\n### Authorization\n\nimaginary supports a simple token-based API authorization.\nTo enable it, you should pass the `-key` flag to the binary.\n\nAPI token can be defined as HTTP header (`API-Key`) or query param (`key`).\n\nExample request with API key:\n```\nPOST /crop HTTP/1.1\nHost: localhost:8088\nAPI-Key: secret\n```\n\n### URL signature\n\nThe URL signature is provided by the `sign` request parameter.\n\nThe HMAC-SHA256 hash is created by taking the URL path (including the leading /), the request parameters (alphabetically-sorted and concatenated with & into a string). The hash is then base64url-encoded.\n\nHere an example in Go:\n```\nsignKey  := \"4f46feebafc4b5e988f131c4ff8b5997\"\nurlPath  := \"/resize\"\nurlQuery := \"file=image.jpg&height=200&type=jpeg&width=300\"\n\nh := hmac.New(sha256.New, []byte(signKey))\nh.Write([]byte(urlPath))\nh.Write([]byte(urlQuery))\nbuf := h.Sum(nil)\n\nfmt.Println(\"sign=\" + base64.RawURLEncoding.EncodeToString(buf))\n```\n\n### Errors\n\n`imaginary` will always reply with the proper HTTP status code and JSON body with error details.\n\nHere an example response error when the payload is empty:\n```json\n{\n  \"message\": \"Cannot read payload: no such file\",\n  \"code\": 1\n}\n```\n\nSee all the predefined supported errors [here](https://github.com/h2non/imaginary/blob/master/error.go#L19-L28).\n\n#### Placeholder\n\nIf `-enable-placeholder` or `-placeholder <image path>` flags are passed to `imaginary`, a placeholder image will be used in case of error or invalid request input.\n\nIf `-enable-placeholder` is passed, the default `imaginary` placeholder image will be used, however you can customized it via `-placeholder` flag, loading a custom compatible image from the file system.\n\nSince `imaginary` has been partially designed to be used as public HTTP service, including web pages, in certain scenarios the response MIME type must be respected,\nso the server will always reply with a placeholder image in case of error, such as image processing error, read error, payload error, request invalid request or any other.\n\nYou can customize the placeholder image passing the `-placeholder <image path>` flag when starting `imaginary`.\n\nIn this scenarios, the error message details will be exposed in the `Error` response header field as JSON for further inspection from API clients.\n\nIn some edge cases the placeholder image resizing might fail, so a 400 Bad Request will be used as response status and the `Content-Type` will be `application/json` with the proper message info. Note that this scenario won't be common.\n\n### Form data\n\nIf you're pushing images to `imaginary` as `multipart/form-data` (you can do it as well as `image/*`), you must define at least one input field called `file` with the raw image data in order to be processed properly by imaginary.\n\n### Params\n\nComplete list of available params. Take a look to each specific endpoint to see which params are supported.\nImage measures are always in pixels, unless otherwise indicated.\n\n- **width**       `int`   - Width of image area to extract/resize\n- **height**      `int`   - Height of image area to extract/resize\n- **top**         `int`   - Top edge of area to extract. Example: `100`\n- **left**        `int`   - Left edge of area to extract. Example: `100`\n- **areawidth**   `int`   - Height area to extract. Example: `300`\n- **areaheight**  `int`   - Width area to extract. Example: `300`\n- **quality**     `int`   - JPEG image quality between 1-100. Defaults to `80`\n- **compression** `int`   - PNG compression level. Default: `6`\n- **palette**     `bool`  - Enable 8-bit quantisation. Works with only PNG images. Default: `false`\n- **rotate**      `int`   - Image rotation angle. Must be multiple of `90`. Example: `180`\n- **factor**      `int`   - Zoom factor level. Example: `2`\n- **margin**      `int`   - Text area margin for watermark. Example: `50`\n- **dpi**         `int`   - DPI value for watermark. Example: `150`\n- **textwidth**   `int`   - Text area width for watermark. Example: `200`\n- **opacity**     `float` - Opacity level for watermark text or watermark image. Default: `0.2`\n- **flip**        `bool`  - Transform the resultant image with flip operation. Default: `false`\n- **flop**        `bool`  - Transform the resultant image with flop operation. Default: `false`\n- **force**       `bool`  - Force image transformation size. Default: `false`\n- **nocrop**      `bool`  - Disable crop transformation. Defaults depend on the operation\n- **noreplicate** `bool`  - Disable text replication in watermark. Defaults to `false`\n- **norotation**  `bool`  - Disable auto rotation based on EXIF orientation. Defaults to `false`\n- **noprofile**   `bool`  - Disable adding ICC profile metadata. Defaults to `false`\n- **stripmeta**   `bool`  - Remove original image metadata, such as EXIF metadata. Defaults to `false`\n- **text**        `string` - Watermark text content. Example: `copyright (c) 2189`\n- **font**        `string` - Watermark text font type and format. Example: `sans bold 12`\n- **color**       `string` - Watermark text RGB decimal base color. Example: `255,200,150`\n- **image**       `string` - Watermark image URL pointing to the remote HTTP server.\n- **type**        `string` - Specify the image format to output. Possible values are: `jpeg`, `png`, `webp` and `auto`. `auto` will use the preferred format requested by the client in the HTTP Accept header. A client can provide multiple comma-separated choices in `Accept` with the best being the one picked.\n- **gravity**     `string` - Define the crop operation gravity. Supported values are: `north`, `south`, `centre`, `west`, `east` and `smart`. Defaults to `centre`.\n- **file**        `string` - Use image from server local file path. In order to use this you must pass the `-mount=<dir>` flag.\n- **url**         `string` - Fetch the image from a remote HTTP server. In order to use this you must pass the `-enable-url-source` flag.\n- **colorspace**  `string` - Use a custom color space for the output image. Allowed values are: `srgb` or `bw` (black&white)\n- **field**       `string` - Custom image form field name if using `multipart/form`. Defaults to: `file`\n- **extend**      `string` - Extend represents the image extend mode used when the edges of an image are extended. Defaults to `mirror`. Allowed values are: `black`, `copy`, `mirror`, `white`, `lastpixel` and `background`. If `background` value is specified, you can define the desired extend RGB color via `background` param, such as `?extend=background&background=250,20,10`. For more info, see [libvips docs](https://libvips.github.io/libvips/API/current/libvips-conversion.html#VIPS-EXTEND-BACKGROUND:CAPS).\n- **background**  `string` - Background RGB decimal base color to use when flattening transparent PNGs. Example: `255,200,150`\n- **sigma**       `float`  - Size of the gaussian mask to use when blurring an image. Example: `15.0`\n- **minampl**     `float`  - Minimum amplitude of the gaussian filter to use when blurring an image. Default: Example: `0.5`\n- **operations**  `json`   - Pipeline of image operation transformations defined as URL safe encoded JSON array. See [pipeline](#get--post-pipeline) endpoints for more details.\n- **sign**        `string` - URL signature (URL-safe Base64-encoded HMAC digest)\n- **interlace**   `bool`   - Use progressive / interlaced format of the image output. Defaults to `false`\n- **aspectratio** `string` - Apply aspect ratio by giving either image's height or width. Exampe: `16:9`\n\n#### GET /\nContent-Type: `application/json`\n\nServes as JSON the current `imaginary`, `bimg` and `libvips` versions.\n\nExample response:\n```json\n{\n  \"imaginary\": \"0.1.28\",\n  \"bimg\": \"1.0.5\",\n  \"libvips\": \"8.4.1\"\n}\n```\n\n#### GET /health\nContent-Type: `application/json`\n\nProvides some useful statistics about the server stats with the following structure:\n\n- **uptime** `number` - Server process uptime in seconds.\n- **allocatedMemory** `number` - Currently allocated memory in megabytes.\n- **totalAllocatedMemory** `number` - Total allocated memory over the time in megabytes.\n- **goroutines** `number` - Number of running goroutines.\n- **cpus** `number` - Number of used CPU cores.\n\nExample response:\n```json\n{\n  \"uptime\": 1293,\n  \"allocatedMemory\": 5.31,\n  \"totalAllocatedMemory\": 34.3,\n  \"goroutines\": 19,\n  \"cpus\": 8\n}\n```\n\n#### GET /form\nContent Type: `text/html`\n\nServes an ugly HTML form, just for testing/playground purposes\n\n#### GET | POST /info\nAccepts: `image/*, multipart/form-data`. Content-Type: `application/json`\n\nReturns the image metadata as JSON:\n```json\n{\n  \"width\": 550,\n  \"height\": 740,\n  \"type\": \"jpeg\",\n  \"space\": \"srgb\",\n  \"hasAlpha\": false,\n  \"hasProfile\": true,\n  \"channels\": 3,\n  \"orientation\": 1\n}\n```\n\n#### GET | POST /crop\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nCrop the image by a given width or height. Image ratio is maintained\n\n##### Allowed params\n\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- force `bool`\n- rotate `int`\n- embed `bool`\n- norotation `bool`\n- noprofile `bool`\n- flip `bool`\n- flop `bool`\n- stripmeta `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- gravity `string`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n\n#### GET | POST /smartcrop\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nCrop the image by a given width or height using the [libvips](https://github.com/jcupitt/libvips/blob/master/libvips/conversion/smartcrop.c) built-in smart crop algorithm.\n\n##### Allowed params\n\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- force `bool`\n- rotate `int`\n- embed `bool`\n- norotation `bool`\n- noprofile `bool`\n- flip `bool`\n- flop `bool`\n- stripmeta `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- gravity `string`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n\n#### GET | POST /resize\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nResize an image by width or height. Image aspect ratio is maintained\n\n##### Allowed params\n\n- width `int` `required`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- nocrop `bool` - Defaults to `true`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /enlarge\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- width `int` `required`\n- height `int` `required`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- nocrop `bool` - Defaults to `false`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- palette `bool`\n\n#### GET | POST /extract\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- top `int` `required`\n- left `int`\n- areawidth `int` `required`\n- areaheight `int`\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /zoom\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- factor `number` `required`\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- nocrop `bool` - Defaults to `true`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /thumbnail\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- width `int` `required`\n- height `int` `required`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /fit\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nResize an image to fit within width and height, without cropping. Image aspect ratio is maintained\nThe width and height specify a maximum bounding box for the image.\n\n##### Allowed params\n\n- width `int` `required`\n- height `int` `required`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /rotate\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n\n#### GET | POST /autorotate\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nAutomatically rotate the image with no further image transformations based on EXIF orientation metadata.\n\nReturns a new image with the same size and format as the input image.\n\n##### Allowed params\n\n- rotate `int` `required`\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /flip\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /flop\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /convert\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- type `string` `required`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n#### GET | POST /pipeline\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\nThis endpoint allow the user to declare a pipeline of multiple independent image transformation operations all in a single HTTP request.\n\n**Note**: a maximum of 10 independent operations are current allowed within the same HTTP request.\n\nInternally, it operates pretty much as a sequential reducer pattern chain, where given an input image and a set of operations, for each independent image operation iteration, the output result image will be passed to the next one, as the accumulated result, until finishing all the operations.\n\nIn imperative programming, this would be pretty much analog to the following code:\n```js\nvar image\nfor operation in operations {\n  image = operation.Run(image, operation.Options)\n}\n```\n\n##### Allowed params\n\n- operations `json` `required` - URL safe encoded JSON with a list of operations. See below for interface details.\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n\n##### Operations JSON specification\n\nSelf-documented JSON operation schema:\n```js\n[\n  {\n    \"operation\": string, // Operation name identifier. Required.\n    \"ignore_failure\": boolean, // Ignore error in case of failure and continue with the next operation. Optional.\n    \"params\": map[string]mixed, // Object defining operation specific image transformation params, same as supported URL query params per each endpoint.\n  }\n]\n```\n\n###### Supported operations names\n\n- **crop** - Same as [`/crop`](#get--post-crop) endpoint.\n- **smartcrop** - Same as [`/smartcrop`](#get--post-smartcrop) endpoint.\n- **resize** - Same as [`/resize`](#get--post-resize) endpoint.\n- **enlarge** - Same as [`/enlarge`](#get--post-enlarge) endpoint.\n- **extract** - Same as [`/extract`](#get--post-extract) endpoint.\n- **rotate** - Same as [`/rotate`](#get--post-rotate) endpoint.\n- **autorotate** - Same as [`/autorotate`](#get--post-autorotate) endpoint.\n- **flip** - Same as [`/flip`](#get--post-flip) endpoint.\n- **flop** - Same as [`/flop`](#get--post-flop) endpoint.\n- **thumbnail** - Same as [`/thumbnail`](#get--post-thumbnail) endpoint.\n- **zoom** - Same as [`/zoom`](#get--post-zoom) endpoint.\n- **convert** - Same as [`/convert`](#get--post-convert) endpoint.\n- **watermark** - Same as [`/watermark`](#get--post-watermark) endpoint.\n- **watermarkImage** - Same as [`/watermarkimage`](#get--post-watermarkimage) endpoint.\n- **blur** - Same as [`/blur`](#get--post-blur) endpoint.\n\n###### Example\n\n```json\n[\n  {\n    \"operation\": \"crop\",\n    \"params\": {\n      \"width\": 500,\n      \"height\": 300\n    }\n  },\n  {\n    \"operation\": \"watermark\",\n    \"params\": {\n      \"text\": \"I need some covfete\",\n      \"font\": \"Verdana\",\n      \"textwidth\": 100,\n      \"opacity\": 0.8\n    }\n  },\n  {\n    \"operation\": \"rotate\",\n    \"params\": {\n      \"rotate\": 180\n    }\n  },\n  {\n    \"operation\": \"convert\",\n    \"params\": {\n      \"type\": \"webp\"\n    }\n  }\n]\n```\n\n#### GET | POST /watermark\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- text `string` `required`\n- margin `int`\n- dpi `int`\n- textwidth `int`\n- opacity `float`\n- noreplicate `bool`\n- font `string`\n- color `string`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- palette `bool`\n\n#### GET | POST /watermarkimage\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- image `string` `required` - URL to watermark image, example: `?image=https://logo-server.com/logo.jpg`\n- top `int` - Top position of the watermark image\n- left `int` - Left position of the watermark image\n- opacity `float` - Opacity value of the watermark image\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- rotate `int`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- sigma `float`\n- minampl `float`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- palette `bool`\n\n#### GET | POST /blur\nAccepts: `image/*, multipart/form-data`. Content-Type: `image/*`\n\n##### Allowed params\n\n- sigma `float` `required`\n- minampl `float`\n- width `int`\n- height `int`\n- quality `int` (JPEG-only)\n- compression `int` (PNG-only)\n- type `string`\n- file `string` - Only GET method and if the `-mount` flag is present\n- url `string` - Only GET method and if the `-enable-url-source` flag is present\n- embed `bool`\n- force `bool`\n- norotation `bool`\n- noprofile `bool`\n- stripmeta `bool`\n- flip `bool`\n- flop `bool`\n- extend `string`\n- background `string` - Example: `?background=250,20,10`\n- colorspace `string`\n- field `string` - Only POST and `multipart/form` payloads\n- interlace `bool`\n- aspectratio `string`\n- palette `bool`\n\n## Logging\n\nImaginary uses an [apache compatible log format](/log.go).\n\n### Fluentd log ingestion\n\nYou can ingest Imaginary logs with fluentd using the following fluentd config :\n\n```\n# use your own tag name (*.imaginary for this example)\n<filter *.imaginary>\n    @type parser\n    key_name log\n    reserve_data true\n\n    <parse>\n        @type multi_format\n        # access logs parser\n        <pattern>\n            format regexp\n            expression /^[^ ]* [^ ]* [^ ]* \\[(?<time>[^\\]]*)\\] \"(?<method>\\S+)(?: +(?<path>[^ ]*) +\\S*)?\" (?<code>[^ ]*) (?<size>[^ ]*) (?<response_time>[^ ]*)$/\n            types code:integer,size:integer,response_time:float\n            time_key time\n            time_format %d/%b/%Y %H:%M:%S\n        </pattern>\n        # warnings / error logs parser\n        <pattern>\n            format none\n            message_key message\n        </pattern>\n    </parse>\n</filter>\n\n<match *.imaginary>\n    @type rewrite_tag_filter\n\n    # Logs with code field are access logs, and logs without are error logs\n    <rule>\n        key code\n        pattern ^.+$\n        tag ${tag}.access\n    </rule>\n    <rule>\n        key code\n        pattern ^.+$\n        invert true\n        tag ${tag}.error\n    </rule>\n</match>\n```\n\nIn the end, access records are tagged with `*.imaginary.access`, and warning /\nerror records are tagged with `*.imaginary.error`.\n\n## Support\n\n### Backers\n\nSupport us with a monthly donation and help us continue our activities. [[Become a backer](https://opencollective.com/imaginary#backer)]\n\n<a href=\"https://opencollective.com/imaginary/backer/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/9/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/10/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/10/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/11/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/11/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/12/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/12/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/13/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/13/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/14/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/14/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/15/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/15/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/16/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/16/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/17/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/17/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/18/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/18/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/19/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/19/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/20/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/20/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/21/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/21/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/22/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/22/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/23/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/23/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/24/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/24/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/25/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/25/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/26/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/26/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/27/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/27/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/28/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/28/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/backer/29/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/backer/29/avatar.svg\"></a>\n\n### Support this project\n\n[![OpenCollective](https://opencollective.com/imaginary/backers/badge.svg)](#backers)\n\n### Sponsors\n\nBecome a sponsor and get your logo on our README on Github with a link to your site. [[Become a sponsor](https://opencollective.com/imaginary#sponsor)]\n\n<a href=\"https://opencollective.com/imaginary/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/9/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/10/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/10/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/11/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/11/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/12/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/12/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/13/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/13/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/14/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/14/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/15/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/15/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/16/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/16/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/17/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/17/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/18/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/18/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/19/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/19/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/20/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/20/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/21/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/21/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/22/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/22/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/23/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/23/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/24/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/24/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/25/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/25/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/26/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/26/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/27/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/27/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/28/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/28/avatar.svg\"></a>\n<a href=\"https://opencollective.com/imaginary/sponsor/29/website\" target=\"_blank\"><img src=\"https://opencollective.com/imaginary/sponsor/29/avatar.svg\"></a>\n\n## Authors\n\n- [Tomás Aparicio](https://github.com/h2non) - Original author and maintainer.\n\n## License\n\nMIT - Tomas Aparicio\n\n[![views](https://sourcegraph.com/api/repos/github.com/h2non/imaginary/.counters/views.svg)](https://sourcegraph.com/github.com/h2non/imaginary)\n"
        },
        {
          "name": "benchmark.sh",
          "type": "blob",
          "size": 0.697265625,
          "content": "#!/bin/bash\n#\n# Simple benchmark test suite\n#\n# You must have installed vegeta:\n# go get github.com/tsenart/vegeta\n#\n\n# Default port to listen\nport=8088\n\n# Start the server\n./bin/imaginary -p $port & > /dev/null\npid=$!\n\nsuite() {\n  echo \"$1 --------------------------------------\"\n  echo \"POST http://localhost:$port/$2\" | vegeta attack \\\n    -duration=30s \\\n    -rate=50 \\\n    -body=\"./testdata/large.jpg\" \\ | vegeta report\n  sleep 1\n}\n\n# Run suites\nsuite \"Crop\" \"crop?width=800&height=600\"\nsuite \"Resize\" \"resize?width=200\"\n#suite \"Rotate\" \"rotate?rotate=180\"\n#suite \"Enlarge\" \"enlarge?width=1600&height=1200\"\nsuite \"Extract\" \"extract?top=50&left=50&areawidth=200&areaheight=200\"\n\n# Kill the server\nkill -9 $pid\n"
        },
        {
          "name": "controllers.go",
          "type": "blob",
          "size": 5.9130859375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"mime\"\n\t\"net/http\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n\t\"github.com/h2non/filetype\"\n)\n\nfunc indexController(o ServerOptions) func(w http.ResponseWriter, r *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path != path.Join(o.PathPrefix, \"/\") {\n\t\t\tErrorReply(r, w, ErrNotFound, ServerOptions{})\n\t\t\treturn\n\t\t}\n\n\t\tbody, _ := json.Marshal(Versions{\n\t\t\tVersion,\n\t\t\tbimg.Version,\n\t\t\tbimg.VipsVersion,\n\t\t})\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t_, _ = w.Write(body)\n\t}\n}\n\nfunc healthController(w http.ResponseWriter, r *http.Request) {\n\thealth := GetHealthStats()\n\tbody, _ := json.Marshal(health)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_, _ = w.Write(body)\n}\n\nfunc imageController(o ServerOptions, operation Operation) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, req *http.Request) {\n\t\tvar imageSource = MatchSource(req)\n\t\tif imageSource == nil {\n\t\t\tErrorReply(req, w, ErrMissingImageSource, o)\n\t\t\treturn\n\t\t}\n\n\t\tbuf, err := imageSource.GetImage(req)\n\t\tif err != nil {\n\t\t\tif xerr, ok := err.(Error); ok {\n\t\t\t\tErrorReply(req, w, xerr, o)\n\t\t\t} else {\n\t\t\t\tErrorReply(req, w, NewError(err.Error(), http.StatusBadRequest), o)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif len(buf) == 0 {\n\t\t\tErrorReply(req, w, ErrEmptyBody, o)\n\t\t\treturn\n\t\t}\n\n\t\timageHandler(w, req, buf, operation, o)\n\t}\n}\n\nfunc determineAcceptMimeType(accept string) string {\n\tfor _, v := range strings.Split(accept, \",\") {\n\t\tmediaType, _, _ := mime.ParseMediaType(v)\n\t\tswitch mediaType {\n\t\tcase \"image/webp\":\n\t\t\treturn \"webp\"\n\t\tcase \"image/png\":\n\t\t\treturn \"png\"\n\t\tcase \"image/jpeg\":\n\t\t\treturn \"jpeg\"\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc imageHandler(w http.ResponseWriter, r *http.Request, buf []byte, operation Operation, o ServerOptions) {\n\t// Infer the body MIME type via mime sniff algorithm\n\tmimeType := http.DetectContentType(buf)\n\n\t// If cannot infer the type, infer it via magic numbers\n\tif mimeType == \"application/octet-stream\" {\n\t\tkind, err := filetype.Get(buf)\n\t\tif err == nil && kind.MIME.Value != \"\" {\n\t\t\tmimeType = kind.MIME.Value\n\t\t}\n\t}\n\n\t// Infer text/plain responses as potential SVG image\n\tif strings.Contains(mimeType, \"text/plain\") && len(buf) > 8 {\n\t\tif bimg.IsSVGImage(buf) {\n\t\t\tmimeType = \"image/svg+xml\"\n\t\t}\n\t}\n\n\t// Finally check if image MIME type is supported\n\tif !IsImageMimeTypeSupported(mimeType) {\n\t\tErrorReply(r, w, ErrUnsupportedMedia, o)\n\t\treturn\n\t}\n\n\topts, err := buildParamsFromQuery(r.URL.Query())\n\tif err != nil {\n\t\tErrorReply(r, w, NewError(\"Error while processing parameters, \"+err.Error(), http.StatusBadRequest), o)\n\t\treturn\n\t}\n\n\tvary := \"\"\n\tif opts.Type == \"auto\" {\n\t\topts.Type = determineAcceptMimeType(r.Header.Get(\"Accept\"))\n\t\tvary = \"Accept\" // Ensure caches behave correctly for negotiated content\n\t} else if opts.Type != \"\" && ImageType(opts.Type) == 0 {\n\t\tErrorReply(r, w, ErrOutputFormat, o)\n\t\treturn\n\t}\n\n\tsizeInfo, err := bimg.Size(buf)\n\n\tif err != nil {\n\t\tErrorReply(r, w, NewError(\"Error while processing the image: \"+err.Error(), http.StatusBadRequest), o)\n\t\treturn\n\t}\n\n\t// https://en.wikipedia.org/wiki/Image_resolution#Pixel_count\n\timgResolution := float64(sizeInfo.Width) * float64(sizeInfo.Height)\n\n\tif (imgResolution / 1000000) > o.MaxAllowedPixels {\n\t\tErrorReply(r, w, ErrResolutionTooBig, o)\n\t\treturn\n\t}\n\n\timage, err := operation.Run(buf, opts)\n\tif err != nil {\n\t\t// Ensure the Vary header is set when an error occurs\n\t\tif vary != \"\" {\n\t\t\tw.Header().Set(\"Vary\", vary)\n\t\t}\n\t\tErrorReply(r, w, NewError(\"Error while processing the image: \"+err.Error(), http.StatusBadRequest), o)\n\t\treturn\n\t}\n\n\t// Expose Content-Length response header\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(image.Body)))\n\tw.Header().Set(\"Content-Type\", image.Mime)\n\tif image.Mime != \"application/json\" && o.ReturnSize {\n\t\tmeta, err := bimg.Metadata(image.Body)\n\t\tif err == nil {\n\t\t\tw.Header().Set(\"Image-Width\", strconv.Itoa(meta.Size.Width))\n\t\t\tw.Header().Set(\"Image-Height\", strconv.Itoa(meta.Size.Height))\n\t\t}\n\t}\n\tif vary != \"\" {\n\t\tw.Header().Set(\"Vary\", vary)\n\t}\n\t_, _ = w.Write(image.Body)\n}\n\nfunc formController(o ServerOptions) func(w http.ResponseWriter, r *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\toperations := []struct {\n\t\t\tname   string\n\t\t\tmethod string\n\t\t\targs   string\n\t\t}{\n\t\t\t{\"Resize\", \"resize\", \"width=300&height=200&type=jpeg\"},\n\t\t\t{\"Force resize\", \"resize\", \"width=300&height=200&force=true\"},\n\t\t\t{\"Crop\", \"crop\", \"width=300&quality=95\"},\n\t\t\t{\"SmartCrop\", \"crop\", \"width=300&height=260&quality=95&gravity=smart\"},\n\t\t\t{\"Extract\", \"extract\", \"top=100&left=100&areawidth=300&areaheight=150\"},\n\t\t\t{\"Enlarge\", \"enlarge\", \"width=1440&height=900&quality=95\"},\n\t\t\t{\"Rotate\", \"rotate\", \"rotate=180\"},\n\t\t\t{\"AutoRotate\", \"autorotate\", \"quality=90\"},\n\t\t\t{\"Flip\", \"flip\", \"\"},\n\t\t\t{\"Flop\", \"flop\", \"\"},\n\t\t\t{\"Thumbnail\", \"thumbnail\", \"width=100\"},\n\t\t\t{\"Zoom\", \"zoom\", \"factor=2&areawidth=300&top=80&left=80\"},\n\t\t\t{\"Color space (black&white)\", \"resize\", \"width=400&height=300&colorspace=bw\"},\n\t\t\t{\"Add watermark\", \"watermark\", \"textwidth=100&text=Hello&font=sans%2012&opacity=0.5&color=255,200,50\"},\n\t\t\t{\"Convert format\", \"convert\", \"type=png\"},\n\t\t\t{\"Image metadata\", \"info\", \"\"},\n\t\t\t{\"Gaussian blur\", \"blur\", \"sigma=15.0&minampl=0.2\"},\n\t\t\t{\"Pipeline (image reduction via multiple transformations)\", \"pipeline\", \"operations=%5B%7B%22operation%22:%20%22crop%22,%20%22params%22:%20%7B%22width%22:%20300,%20%22height%22:%20260%7D%7D,%20%7B%22operation%22:%20%22convert%22,%20%22params%22:%20%7B%22type%22:%20%22webp%22%7D%7D%5D\"},\n\t\t}\n\n\t\thtml := \"<html><body>\"\n\n\t\tfor _, form := range operations {\n\t\t\thtml += fmt.Sprintf(`\n\t\t<h1>%s</h1>\n\t\t<form method=\"POST\" action=\"%s?%s\" enctype=\"multipart/form-data\">\n\t\t<input type=\"file\" name=\"file\" />\n\t\t<input type=\"submit\" value=\"Upload\" />\n\t\t</form>`, path.Join(o.PathPrefix, form.name), path.Join(o.PathPrefix, form.method), form.args)\n\t\t}\n\n\t\thtml += \"</body></html>\"\n\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t_, _ = w.Write([]byte(html))\n\t}\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.1748046875,
          "content": "version: \"3\"\n\nservices:\n  imaginary:\n    image: h2non/imaginary\n    ports:\n      - \"8088:8088\"\n    environment:\n      - PORT=8088\n    command: -concurrency 50 -enable-url-source\n\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 3.7333984375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nvar (\n\tErrNotFound             = NewError(\"Not found\", http.StatusNotFound)\n\tErrInvalidAPIKey        = NewError(\"Invalid or missing API key\", http.StatusUnauthorized)\n\tErrMethodNotAllowed     = NewError(\"HTTP method not allowed. Try with a POST or GET method (-enable-url-source flag must be defined)\", http.StatusMethodNotAllowed)\n\tErrGetMethodNotAllowed  = NewError(\"GET method not allowed. Make sure remote URL source is enabled by using the flag: -enable-url-source\", http.StatusMethodNotAllowed)\n\tErrUnsupportedMedia     = NewError(\"Unsupported media type\", http.StatusNotAcceptable)\n\tErrOutputFormat         = NewError(\"Unsupported output image format\", http.StatusBadRequest)\n\tErrEmptyBody            = NewError(\"Empty or unreadable image\", http.StatusBadRequest)\n\tErrMissingParamFile     = NewError(\"Missing required param: file\", http.StatusBadRequest)\n\tErrInvalidFilePath      = NewError(\"Invalid file path\", http.StatusBadRequest)\n\tErrInvalidImageURL      = NewError(\"Invalid image URL\", http.StatusBadRequest)\n\tErrMissingImageSource   = NewError(\"Cannot process the image due to missing or invalid params\", http.StatusBadRequest)\n\tErrNotImplemented       = NewError(\"Not implemented endpoint\", http.StatusNotImplemented)\n\tErrInvalidURLSignature  = NewError(\"Invalid URL signature\", http.StatusBadRequest)\n\tErrURLSignatureMismatch = NewError(\"URL signature mismatch\", http.StatusForbidden)\n\tErrResolutionTooBig     = NewError(\"Image resolution is too big\", http.StatusUnprocessableEntity)\n)\n\ntype Error struct {\n\tMessage string `json:\"message,omitempty\"`\n\tCode    int    `json:\"status\"`\n}\n\nfunc (e Error) JSON() []byte {\n\tbuf, _ := json.Marshal(e)\n\treturn buf\n}\n\nfunc (e Error) Error() string {\n\treturn e.Message\n}\n\nfunc (e Error) HTTPCode() int {\n\tif e.Code >= 400 && e.Code <= 511 {\n\t\treturn e.Code\n\t}\n\treturn http.StatusServiceUnavailable\n}\n\nfunc NewError(err string, code int) Error {\n\terr = strings.Replace(err, \"\\n\", \"\", -1)\n\treturn Error{Message: err, Code: code}\n}\n\nfunc sendErrorResponse(w http.ResponseWriter, httpStatusCode int, err error) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(httpStatusCode)\n\t_, _ = w.Write([]byte(fmt.Sprintf(\"{\\\"error\\\":\\\"%s\\\", \\\"status\\\": %d}\", err.Error(), httpStatusCode)))\n}\n\nfunc replyWithPlaceholder(req *http.Request, w http.ResponseWriter, errCaller Error, o ServerOptions) error {\n\tvar err error\n\tbimgOptions := bimg.Options{\n\t\tForce:   true,\n\t\tCrop:    true,\n\t\tEnlarge: true,\n\t\tType:    ImageType(req.URL.Query().Get(\"type\")),\n\t}\n\n\tbimgOptions.Width, err = parseInt(req.URL.Query().Get(\"width\"))\n\tif err != nil {\n\t\tsendErrorResponse(w, http.StatusBadRequest, err)\n\t\treturn err\n\t}\n\n\tbimgOptions.Height, err = parseInt(req.URL.Query().Get(\"height\"))\n\tif err != nil {\n\t\tsendErrorResponse(w, http.StatusBadRequest, err)\n\t\treturn err\n\t}\n\n\t// Resize placeholder to expected output\n\tbuf, err := bimg.Resize(o.PlaceholderImage, bimgOptions)\n\tif err != nil {\n\t\tsendErrorResponse(w, http.StatusBadRequest, err)\n\t\treturn err\n\t}\n\n\t// Use final response body image\n\timage := buf\n\n\t// Placeholder image response\n\tw.Header().Set(\"Content-Type\", GetImageMimeType(bimg.DetermineImageType(image)))\n\tw.Header().Set(\"Error\", string(errCaller.JSON()))\n\tif o.PlaceholderStatus != 0 {\n\t\tw.WriteHeader(o.PlaceholderStatus)\n\t} else {\n\t\tw.WriteHeader(errCaller.HTTPCode())\n\t}\n\t_, _ = w.Write(image)\n\n\treturn errCaller\n}\n\nfunc ErrorReply(req *http.Request, w http.ResponseWriter, err Error, o ServerOptions) {\n\t// Reply with placeholder if required\n\tif o.EnablePlaceholder || o.Placeholder != \"\" {\n\t\t_ = replyWithPlaceholder(req, w, err, o)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(err.HTTPCode())\n\t_, _ = w.Write(err.JSON())\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 0.4482421875,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestDefaultError(t *testing.T) {\n\terr := NewError(\"oops!\\n\\n\", 503)\n\n\tif err.Error() != \"oops!\" {\n\t\tt.Fatal(\"Invalid error message\")\n\t}\n\tif err.Code != 503 {\n\t\tt.Fatal(\"Invalid error code\")\n\t}\n\n\tcode := err.HTTPCode()\n\tif code != 503 {\n\t\tt.Fatalf(\"Invalid HTTP error status: %d\", code)\n\t}\n\n\tjson := string(err.JSON())\n\tif json != \"{\\\"message\\\":\\\"oops!\\\",\\\"status\\\":503}\" {\n\t\tt.Fatalf(\"Invalid JSON output: %s\", json)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.333984375,
          "content": "module github.com/h2non/imaginary\n\ngo 1.12\n\nrequire (\n\tgithub.com/garyburd/redigo v1.6.0 // indirect\n\tgithub.com/h2non/bimg v1.1.7\n\tgithub.com/h2non/filetype v1.1.0\n\tgithub.com/hashicorp/golang-lru v0.0.0-20160813221303-0a025b7e63ad // indirect\n\tgithub.com/rs/cors v0.0.0-20170727213201-7af7a1e09ba3\n\tgopkg.in/throttled/throttled.v2 v2.0.3\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.103515625,
          "content": "github.com/garyburd/redigo v1.6.0 h1:0VruCpn7yAIIu7pWVClQC8wxCJEcG3nyzpMSHKi1PQc=\ngithub.com/garyburd/redigo v1.6.0/go.mod h1:NR3MbYisc3/PwhQ00EMzDiPmrwpPxAn5GI05/YaO1SY=\ngithub.com/h2non/bimg v1.1.7 h1:JKJe70nDNMWp2wFnTLMGB8qJWQQMaKRn56uHmC/4+34=\ngithub.com/h2non/bimg v1.1.7/go.mod h1:R3+UiYwkK4rQl6KVFTOFJHitgLbZXBZNFh2cv3AEbp8=\ngithub.com/h2non/filetype v1.1.0 h1:Or/gjocJrJRNK/Cri/TDEKFjAR+cfG6eK65NGYB6gBA=\ngithub.com/h2non/filetype v1.1.0/go.mod h1:319b3zT68BvV+WRj7cwy856M2ehB3HqNOt6sy1HndBY=\ngithub.com/hashicorp/golang-lru v0.0.0-20160813221303-0a025b7e63ad h1:eMxs9EL0PvIGS9TTtxg4R+JxuPGav82J8rA+GFnY7po=\ngithub.com/hashicorp/golang-lru v0.0.0-20160813221303-0a025b7e63ad/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/rs/cors v0.0.0-20170727213201-7af7a1e09ba3 h1:86ukAHRTa2CXdBnWJHcjjPPGTyLGEF488OFRsbBAuFs=\ngithub.com/rs/cors v0.0.0-20170727213201-7af7a1e09ba3/go.mod h1:gFx+x8UowdsKA9AchylcLynDq+nNFfI8FkUZdN/jGCU=\ngopkg.in/throttled/throttled.v2 v2.0.3 h1:PGm7nfjjexecEyI2knw1akeLcrjzqxuYSU9a04R8rfU=\ngopkg.in/throttled/throttled.v2 v2.0.3/go.mod h1:L4cTNZO77XKEXtn8HNFRCMNGZPtRRKAhyuJBSvK/T90=\n"
        },
        {
          "name": "health.go",
          "type": "blob",
          "size": 1.576171875,
          "content": "package main\n\nimport (\n\t\"math\"\n\t\"runtime\"\n\t\"time\"\n)\n\nvar start = time.Now()\n\nconst MB float64 = 1.0 * 1024 * 1024\n\ntype HealthStats struct {\n\tUptime               int64   `json:\"uptime\"`\n\tAllocatedMemory      float64 `json:\"allocatedMemory\"`\n\tTotalAllocatedMemory float64 `json:\"totalAllocatedMemory\"`\n\tGoroutines           int     `json:\"goroutines\"`\n\tGCCycles             uint32  `json:\"completedGCCycles\"`\n\tNumberOfCPUs         int     `json:\"cpus\"`\n\tHeapSys              float64 `json:\"maxHeapUsage\"`\n\tHeapAllocated        float64 `json:\"heapInUse\"`\n\tObjectsInUse         uint64  `json:\"objectsInUse\"`\n\tOSMemoryObtained     float64 `json:\"OSMemoryObtained\"`\n}\n\nfunc GetHealthStats() *HealthStats {\n\tmem := &runtime.MemStats{}\n\truntime.ReadMemStats(mem)\n\n\treturn &HealthStats{\n\t\tUptime:               GetUptime(),\n\t\tAllocatedMemory:      toMegaBytes(mem.Alloc),\n\t\tTotalAllocatedMemory: toMegaBytes(mem.TotalAlloc),\n\t\tGoroutines:           runtime.NumGoroutine(),\n\t\tNumberOfCPUs:         runtime.NumCPU(),\n\t\tGCCycles:             mem.NumGC,\n\t\tHeapSys:              toMegaBytes(mem.HeapSys),\n\t\tHeapAllocated:        toMegaBytes(mem.HeapAlloc),\n\t\tObjectsInUse:         mem.Mallocs - mem.Frees,\n\t\tOSMemoryObtained:     toMegaBytes(mem.Sys),\n\t}\n}\n\nfunc GetUptime() int64 {\n\treturn time.Now().Unix() - start.Unix()\n}\n\nfunc toMegaBytes(bytes uint64) float64 {\n\treturn toFixed(float64(bytes)/MB, 2)\n}\n\nfunc round(num float64) int {\n\treturn int(num + math.Copysign(0.5, num))\n}\n\nfunc toFixed(num float64, precision int) float64 {\n\toutput := math.Pow(10, float64(precision))\n\treturn float64(round(num*output)) / output\n}\n"
        },
        {
          "name": "health_test.go",
          "type": "blob",
          "size": 1.0625,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestToMegaBytes(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    uint64\n\t\texpected float64\n\t}{\n\t\t{1024, 0},\n\t\t{1024 * 1024, 1},\n\t\t{1024 * 1024 * 10, 10},\n\t\t{1024 * 1024 * 100, 100},\n\t\t{1024 * 1024 * 250, 250},\n\t}\n\n\tfor _, test := range tests {\n\t\tval := toMegaBytes(test.value)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %#v != %#v\", val, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestRound(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{0, 0},\n\t\t{1, 1},\n\t\t{1.56, 2},\n\t\t{1.38, 1},\n\t\t{30.12, 30},\n\t}\n\n\tfor _, test := range tests {\n\t\tval := round(test.value)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %#v != %#v\", val, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestToFixed(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    float64\n\t\texpected float64\n\t}{\n\t\t{0, 0},\n\t\t{1, 1},\n\t\t{123, 123},\n\t\t{0.99, 1},\n\t\t{1.02, 1},\n\t\t{1.82, 1.8},\n\t\t{1.56, 1.6},\n\t\t{1.38, 1.4},\n\t}\n\n\tfor _, test := range tests {\n\t\tval := toFixed(test.value, 1)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %#v != %#v\", val, test.expected)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 11.3193359375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n)\n\n// OperationsMap defines the allowed image transformation operations listed by name.\n// Used for pipeline image processing.\nvar OperationsMap = map[string]Operation{\n\t\"crop\":           Crop,\n\t\"resize\":         Resize,\n\t\"enlarge\":        Enlarge,\n\t\"extract\":        Extract,\n\t\"rotate\":         Rotate,\n\t\"autorotate\":     AutoRotate,\n\t\"flip\":           Flip,\n\t\"flop\":           Flop,\n\t\"thumbnail\":      Thumbnail,\n\t\"zoom\":           Zoom,\n\t\"convert\":        Convert,\n\t\"watermark\":      Watermark,\n\t\"watermarkImage\": WatermarkImage,\n\t\"blur\":           GaussianBlur,\n\t\"smartcrop\":      SmartCrop,\n\t\"fit\":            Fit,\n}\n\n// Image stores an image binary buffer and its MIME type\ntype Image struct {\n\tBody []byte\n\tMime string\n}\n\n// Operation implements an image transformation runnable interface\ntype Operation func([]byte, ImageOptions) (Image, error)\n\n// Run performs the image transformation\nfunc (o Operation) Run(buf []byte, opts ImageOptions) (Image, error) {\n\treturn o(buf, opts)\n}\n\n// ImageInfo represents an image details and additional metadata\ntype ImageInfo struct {\n\tWidth       int    `json:\"width\"`\n\tHeight      int    `json:\"height\"`\n\tType        string `json:\"type\"`\n\tSpace       string `json:\"space\"`\n\tAlpha       bool   `json:\"hasAlpha\"`\n\tProfile     bool   `json:\"hasProfile\"`\n\tChannels    int    `json:\"channels\"`\n\tOrientation int    `json:\"orientation\"`\n}\n\nfunc Info(buf []byte, o ImageOptions) (Image, error) {\n\t// We're not handling an image here, but we reused the struct.\n\t// An interface will be definitively better here.\n\timage := Image{Mime: \"application/json\"}\n\n\tmeta, err := bimg.Metadata(buf)\n\tif err != nil {\n\t\treturn image, NewError(\"Cannot retrieve image metadata: %s\"+err.Error(), http.StatusBadRequest)\n\t}\n\n\tinfo := ImageInfo{\n\t\tWidth:       meta.Size.Width,\n\t\tHeight:      meta.Size.Height,\n\t\tType:        meta.Type,\n\t\tSpace:       meta.Space,\n\t\tAlpha:       meta.Alpha,\n\t\tProfile:     meta.Profile,\n\t\tChannels:    meta.Channels,\n\t\tOrientation: meta.Orientation,\n\t}\n\n\tbody, _ := json.Marshal(info)\n\timage.Body = body\n\n\treturn image, nil\n}\n\nfunc Resize(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 && o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: height or width\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Embed = true\n\n\tif o.IsDefinedField.NoCrop {\n\t\topts.Crop = !o.NoCrop\n\t}\n\n\treturn Process(buf, opts)\n}\n\nfunc Fit(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 || o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required params: height, width\", http.StatusBadRequest)\n\t}\n\n\tmetadata, err := bimg.Metadata(buf)\n\tif err != nil {\n\t\treturn Image{}, err\n\t}\n\n\tdims := metadata.Size\n\n\tif dims.Width == 0 || dims.Height == 0 {\n\t\treturn Image{}, NewError(\"Width or height of requested image is zero\", http.StatusNotAcceptable)\n\t}\n\n\t// metadata.Orientation\n\t// 0: no EXIF orientation\n\t// 1: CW 0\n\t// 2: CW 0, flip horizontal\n\t// 3: CW 180\n\t// 4: CW 180, flip horizontal\n\t// 5: CW 90, flip horizontal\n\t// 6: CW 270\n\t// 7: CW 270, flip horizontal\n\t// 8: CW 90\n\n\tvar originHeight, originWidth int\n\tvar fitHeight, fitWidth *int\n\tif o.NoRotation || (metadata.Orientation <= 4) {\n\t\toriginHeight = dims.Height\n\t\toriginWidth = dims.Width\n\t\tfitHeight = &o.Height\n\t\tfitWidth = &o.Width\n\t} else {\n\t\t// width/height will be switched with auto rotation\n\t\toriginWidth = dims.Height\n\t\toriginHeight = dims.Width\n\t\tfitWidth = &o.Height\n\t\tfitHeight = &o.Width\n\t}\n\n\t*fitWidth, *fitHeight = calculateDestinationFitDimension(originWidth, originHeight, *fitWidth, *fitHeight)\n\n\topts := BimgOptions(o)\n\topts.Embed = true\n\n\treturn Process(buf, opts)\n}\n\n// calculateDestinationFitDimension calculates the fit area based on the image and desired fit dimensions\nfunc calculateDestinationFitDimension(imageWidth, imageHeight, fitWidth, fitHeight int) (int, int) {\n\tif imageWidth*fitHeight > fitWidth*imageHeight {\n\t\t// constrained by width\n\t\tfitHeight = int(math.Round(float64(fitWidth) * float64(imageHeight) / float64(imageWidth)))\n\t} else {\n\t\t// constrained by height\n\t\tfitWidth = int(math.Round(float64(fitHeight) * float64(imageWidth) / float64(imageHeight)))\n\t}\n\n\treturn fitWidth, fitHeight\n}\n\nfunc Enlarge(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 || o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required params: height, width\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Enlarge = true\n\n\t// Since both width & height is required, we allow cropping by default.\n\topts.Crop = !o.NoCrop\n\n\treturn Process(buf, opts)\n}\n\nfunc Extract(buf []byte, o ImageOptions) (Image, error) {\n\tif o.AreaWidth == 0 || o.AreaHeight == 0 {\n\t\treturn Image{}, NewError(\"Missing required params: areawidth or areaheight\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Top = o.Top\n\topts.Left = o.Left\n\topts.AreaWidth = o.AreaWidth\n\topts.AreaHeight = o.AreaHeight\n\n\treturn Process(buf, opts)\n}\n\nfunc Crop(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 && o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: height or width\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Crop = true\n\treturn Process(buf, opts)\n}\n\nfunc SmartCrop(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 && o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: height or width\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Crop = true\n\topts.Gravity = bimg.GravitySmart\n\treturn Process(buf, opts)\n}\n\nfunc Rotate(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Rotate == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: rotate\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\treturn Process(buf, opts)\n}\n\nfunc AutoRotate(buf []byte, o ImageOptions) (out Image, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch value := r.(type) {\n\t\t\tcase error:\n\t\t\t\terr = value\n\t\t\tcase string:\n\t\t\t\terr = errors.New(value)\n\t\t\tdefault:\n\t\t\t\terr = errors.New(\"libvips internal error\")\n\t\t\t}\n\t\t\tout = Image{}\n\t\t}\n\t}()\n\n\t// Resize image via bimg\n\tibuf, err := bimg.NewImage(buf).AutoRotate()\n\tif err != nil {\n\t\treturn Image{}, err\n\t}\n\n\tmime := GetImageMimeType(bimg.DetermineImageType(ibuf))\n\treturn Image{Body: ibuf, Mime: mime}, nil\n}\n\nfunc Flip(buf []byte, o ImageOptions) (Image, error) {\n\topts := BimgOptions(o)\n\topts.Flip = true\n\treturn Process(buf, opts)\n}\n\nfunc Flop(buf []byte, o ImageOptions) (Image, error) {\n\topts := BimgOptions(o)\n\topts.Flop = true\n\treturn Process(buf, opts)\n}\n\nfunc Thumbnail(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Width == 0 && o.Height == 0 {\n\t\treturn Image{}, NewError(\"Missing required params: width or height\", http.StatusBadRequest)\n\t}\n\n\treturn Process(buf, BimgOptions(o))\n}\n\nfunc Zoom(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Factor == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: factor\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\n\tif o.Top > 0 || o.Left > 0 {\n\t\tif o.AreaWidth == 0 && o.AreaHeight == 0 {\n\t\t\treturn Image{}, NewError(\"Missing required params: areawidth, areaheight\", http.StatusBadRequest)\n\t\t}\n\n\t\topts.Top = o.Top\n\t\topts.Left = o.Left\n\t\topts.AreaWidth = o.AreaWidth\n\t\topts.AreaHeight = o.AreaHeight\n\n\t\tif o.IsDefinedField.NoCrop {\n\t\t\topts.Crop = !o.NoCrop\n\t\t}\n\t}\n\n\topts.Zoom = o.Factor\n\treturn Process(buf, opts)\n}\n\nfunc Convert(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Type == \"\" {\n\t\treturn Image{}, NewError(\"Missing required param: type\", http.StatusBadRequest)\n\t}\n\tif ImageType(o.Type) == bimg.UNKNOWN {\n\t\treturn Image{}, NewError(\"Invalid image type: \"+o.Type, http.StatusBadRequest)\n\t}\n\topts := BimgOptions(o)\n\n\treturn Process(buf, opts)\n}\n\nfunc Watermark(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Text == \"\" {\n\t\treturn Image{}, NewError(\"Missing required param: text\", http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.Watermark.DPI = o.DPI\n\topts.Watermark.Text = o.Text\n\topts.Watermark.Font = o.Font\n\topts.Watermark.Margin = o.Margin\n\topts.Watermark.Width = o.TextWidth\n\topts.Watermark.Opacity = o.Opacity\n\topts.Watermark.NoReplicate = o.NoReplicate\n\n\tif len(o.Color) > 2 {\n\t\topts.Watermark.Background = bimg.Color{R: o.Color[0], G: o.Color[1], B: o.Color[2]}\n\t}\n\n\treturn Process(buf, opts)\n}\n\nfunc WatermarkImage(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Image == \"\" {\n\t\treturn Image{}, NewError(\"Missing required param: image\", http.StatusBadRequest)\n\t}\n\tresponse, err := http.Get(o.Image)\n\tif err != nil {\n\t\treturn Image{}, NewError(fmt.Sprintf(\"Unable to retrieve watermark image. %s\", o.Image), http.StatusBadRequest)\n\t}\n\tdefer func() {\n\t\t_ = response.Body.Close()\n\t}()\n\n\tbodyReader := io.LimitReader(response.Body, 1e6)\n\n\timageBuf, err := ioutil.ReadAll(bodyReader)\n\tif len(imageBuf) == 0 {\n\t\terrMessage := \"Unable to read watermark image\"\n\n\t\tif err != nil {\n\t\t\terrMessage = fmt.Sprintf(\"%s. %s\", errMessage, err.Error())\n\t\t}\n\n\t\treturn Image{}, NewError(errMessage, http.StatusBadRequest)\n\t}\n\n\topts := BimgOptions(o)\n\topts.WatermarkImage.Left = o.Left\n\topts.WatermarkImage.Top = o.Top\n\topts.WatermarkImage.Buf = imageBuf\n\topts.WatermarkImage.Opacity = o.Opacity\n\n\treturn Process(buf, opts)\n}\n\nfunc GaussianBlur(buf []byte, o ImageOptions) (Image, error) {\n\tif o.Sigma == 0 && o.MinAmpl == 0 {\n\t\treturn Image{}, NewError(\"Missing required param: sigma or minampl\", http.StatusBadRequest)\n\t}\n\topts := BimgOptions(o)\n\treturn Process(buf, opts)\n}\n\nfunc Pipeline(buf []byte, o ImageOptions) (Image, error) {\n\tif len(o.Operations) == 0 {\n\t\treturn Image{}, NewError(\"Missing or invalid pipeline operations JSON\", http.StatusBadRequest)\n\t}\n\tif len(o.Operations) > 10 {\n\t\treturn Image{}, NewError(\"Maximum allowed pipeline operations exceeded\", http.StatusBadRequest)\n\t}\n\n\t// Validate and built operations\n\tfor i, operation := range o.Operations {\n\t\t// Validate supported operation name\n\t\tvar exists bool\n\t\tif operation.Operation, exists = OperationsMap[operation.Name]; !exists {\n\t\t\treturn Image{}, NewError(fmt.Sprintf(\"Unsupported operation name: %s\", operation.Name), http.StatusBadRequest)\n\t\t}\n\n\t\t// Parse and construct operation options\n\t\tvar err error\n\t\toperation.ImageOptions, err = buildParamsFromOperation(operation)\n\t\tif err != nil {\n\t\t\treturn Image{}, err\n\t\t}\n\n\t\t// Mutate list by value\n\t\to.Operations[i] = operation\n\t}\n\n\tvar image Image\n\tvar err error\n\n\t// Reduce image by running multiple operations\n\timage = Image{Body: buf}\n\tfor _, operation := range o.Operations {\n\t\tvar curImage Image\n\t\tcurImage, err = operation.Operation(image.Body, operation.ImageOptions)\n\t\tif err != nil && !operation.IgnoreFailure {\n\t\t\treturn Image{}, err\n\t\t}\n\t\tif operation.IgnoreFailure {\n\t\t\terr = nil\n\t\t}\n\t\tif err == nil {\n\t\t\timage = curImage\n\t\t}\n\t}\n\n\treturn image, err\n}\n\nfunc Process(buf []byte, opts bimg.Options) (out Image, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch value := r.(type) {\n\t\t\tcase error:\n\t\t\t\terr = value\n\t\t\tcase string:\n\t\t\t\terr = errors.New(value)\n\t\t\tdefault:\n\t\t\t\terr = errors.New(\"libvips internal error\")\n\t\t\t}\n\t\t\tout = Image{}\n\t\t}\n\t}()\n\n\t// Resize image via bimg\n\tibuf, err := bimg.Resize(buf, opts)\n\n\t// Handle specific type encode errors gracefully\n\tif err != nil && strings.Contains(err.Error(), \"encode\") && (opts.Type == bimg.WEBP || opts.Type == bimg.HEIF) {\n\t\t// Always fallback to JPEG\n\t\topts.Type = bimg.JPEG\n\t\tibuf, err = bimg.Resize(buf, opts)\n\t}\n\n\tif err != nil {\n\t\treturn Image{}, err\n\t}\n\n\tmime := GetImageMimeType(bimg.DetermineImageType(ibuf))\n\treturn Image{Body: ibuf, Mime: mime}, nil\n}\n"
        },
        {
          "name": "image_test.go",
          "type": "blob",
          "size": 4.3623046875,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"testing\"\n)\n\nfunc TestImageResize(t *testing.T) {\n\tt.Run(\"Width and Height defined\", func(t *testing.T) {\n\t\topts := ImageOptions{Width: 300, Height: 300}\n\t\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\t\timg, err := Resize(buf, opts)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t\t}\n\t\tif img.Mime != \"image/jpeg\" {\n\t\t\tt.Error(\"Invalid image MIME type\")\n\t\t}\n\t\tif assertSize(img.Body, opts.Width, opts.Height) != nil {\n\t\t\tt.Errorf(\"Invalid image size, expected: %dx%d\", opts.Width, opts.Height)\n\t\t}\n\t})\n\n\tt.Run(\"Width defined\", func(t *testing.T) {\n\t\topts := ImageOptions{Width: 300}\n\t\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\t\timg, err := Resize(buf, opts)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t\t}\n\t\tif img.Mime != \"image/jpeg\" {\n\t\t\tt.Error(\"Invalid image MIME type\")\n\t\t}\n\t\tif err := assertSize(img.Body, 300, 404); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\tt.Run(\"Width defined with NoCrop=false\", func(t *testing.T) {\n\t\topts := ImageOptions{Width: 300, NoCrop: false, IsDefinedField: IsDefinedField{NoCrop: true}}\n\t\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\t\timg, err := Resize(buf, opts)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t\t}\n\t\tif img.Mime != \"image/jpeg\" {\n\t\t\tt.Error(\"Invalid image MIME type\")\n\t\t}\n\n\t\t// The original image is 550x740\n\t\tif err := assertSize(img.Body, 300, 740); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\tt.Run(\"Width defined with NoCrop=true\", func(t *testing.T) {\n\t\topts := ImageOptions{Width: 300, NoCrop: true, IsDefinedField: IsDefinedField{NoCrop: true}}\n\t\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\t\timg, err := Resize(buf, opts)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t\t}\n\t\tif img.Mime != \"image/jpeg\" {\n\t\t\tt.Error(\"Invalid image MIME type\")\n\t\t}\n\n\t\t// The original image is 550x740\n\t\tif err := assertSize(img.Body, 300, 404); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n}\n\nfunc TestImageFit(t *testing.T) {\n\topts := ImageOptions{Width: 300, Height: 300}\n\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\timg, err := Fit(buf, opts)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t}\n\tif img.Mime != \"image/jpeg\" {\n\t\tt.Error(\"Invalid image MIME type\")\n\t}\n\t// 550x740 -> 222.9x300\n\tif assertSize(img.Body, 223, 300) != nil {\n\t\tt.Errorf(\"Invalid image size, expected: %dx%d\", opts.Width, opts.Height)\n\t}\n}\n\nfunc TestImageAutoRotate(t *testing.T) {\n\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\timg, err := AutoRotate(buf, ImageOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t}\n\tif img.Mime != \"image/jpeg\" {\n\t\tt.Error(\"Invalid image MIME type\")\n\t}\n\tif assertSize(img.Body, 550, 740) != nil {\n\t\tt.Errorf(\"Invalid image size, expected: %dx%d\", 550, 740)\n\t}\n}\n\nfunc TestImagePipelineOperations(t *testing.T) {\n\twidth, height := 300, 260\n\n\toperations := PipelineOperations{\n\t\tPipelineOperation{\n\t\t\tName: \"crop\",\n\t\t\tParams: map[string]interface{}{\n\t\t\t\t\"width\":  width,\n\t\t\t\t\"height\": height,\n\t\t\t},\n\t\t},\n\t\tPipelineOperation{\n\t\t\tName: \"convert\",\n\t\t\tParams: map[string]interface{}{\n\t\t\t\t\"type\": \"webp\",\n\t\t\t},\n\t\t},\n\t}\n\n\topts := ImageOptions{Operations: operations}\n\tbuf, _ := ioutil.ReadAll(readFile(\"imaginary.jpg\"))\n\n\timg, err := Pipeline(buf, opts)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process image: %s\", err)\n\t}\n\tif img.Mime != \"image/webp\" {\n\t\tt.Error(\"Invalid image MIME type\")\n\t}\n\tif assertSize(img.Body, width, height) != nil {\n\t\tt.Errorf(\"Invalid image size, expected: %dx%d\", width, height)\n\t}\n}\n\nfunc TestCalculateDestinationFitDimension(t *testing.T) {\n\tcases := []struct {\n\t\t// Image\n\t\timageWidth  int\n\t\timageHeight int\n\n\t\t// User parameter\n\t\toptionWidth  int\n\t\toptionHeight int\n\n\t\t// Expect\n\t\tfitWidth  int\n\t\tfitHeight int\n\t}{\n\n\t\t// Leading Width\n\t\t{1280, 1000, 710, 9999, 710, 555},\n\t\t{1279, 1000, 710, 9999, 710, 555},\n\t\t{900, 500, 312, 312, 312, 173}, // rounding down\n\t\t{900, 500, 313, 313, 313, 174}, // rounding up\n\n\t\t// Leading height\n\t\t{1299, 2000, 710, 999, 649, 999},\n\t\t{1500, 2000, 710, 999, 710, 947},\n\t}\n\n\tfor _, tc := range cases {\n\t\tfitWidth, fitHeight := calculateDestinationFitDimension(tc.imageWidth, tc.imageHeight, tc.optionWidth, tc.optionHeight)\n\t\tif fitWidth != tc.fitWidth || fitHeight != tc.fitHeight {\n\t\t\tt.Errorf(\n\t\t\t\t\"Fit dimensions calculation failure\\nExpected : %d/%d (width/height)\\nActual   : %d/%d (width/height)\\n%+v\",\n\t\t\t\ttc.fitWidth, tc.fitHeight, fitWidth, fitHeight, tc,\n\t\t\t)\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "imaginary.go",
          "type": "blob",
          "size": 13.1611328125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"runtime\"\n\td \"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nvar (\n\taAddr               = flag.String(\"a\", \"\", \"Bind address\")\n\taPort               = flag.Int(\"p\", 8088, \"Port to listen\")\n\taVers               = flag.Bool(\"v\", false, \"Show version\")\n\taVersl              = flag.Bool(\"version\", false, \"Show version\")\n\taHelp               = flag.Bool(\"h\", false, \"Show help\")\n\taHelpl              = flag.Bool(\"help\", false, \"Show help\")\n\taPathPrefix         = flag.String(\"path-prefix\", \"/\", \"Url path prefix to listen to\")\n\taCors               = flag.Bool(\"cors\", false, \"Enable CORS support\")\n\taGzip               = flag.Bool(\"gzip\", false, \"Enable gzip compression (deprecated)\")\n\taAuthForwarding     = flag.Bool(\"enable-auth-forwarding\", false, \"Forwards X-Forward-Authorization or Authorization header to the image source server. -enable-url-source flag must be defined. Tip: secure your server from public access to prevent attack vectors\")\n\taEnableURLSource    = flag.Bool(\"enable-url-source\", false, \"Enable remote HTTP URL image source processing\")\n\taEnablePlaceholder  = flag.Bool(\"enable-placeholder\", false, \"Enable image response placeholder to be used in case of error\")\n\taEnableURLSignature = flag.Bool(\"enable-url-signature\", false, \"Enable URL signature (URL-safe Base64-encoded HMAC digest)\")\n\taURLSignatureKey    = flag.String(\"url-signature-key\", \"\", \"The URL signature key (32 characters minimum)\")\n\taAllowedOrigins     = flag.String(\"allowed-origins\", \"\", \"Restrict remote image source processing to certain origins (separated by commas). Note: Origins are validated against host *AND* path.\")\n\taMaxAllowedSize     = flag.Int(\"max-allowed-size\", 0, \"Restrict maximum size of http image source (in bytes)\")\n\taMaxAllowedPixels   = flag.Float64(\"max-allowed-resolution\", 18.0, \"Restrict maximum resolution of the image (in megapixels)\")\n\taKey                = flag.String(\"key\", \"\", \"Define API key for authorization\")\n\taMount              = flag.String(\"mount\", \"\", \"Mount server local directory\")\n\taCertFile           = flag.String(\"certfile\", \"\", \"TLS certificate file path\")\n\taKeyFile            = flag.String(\"keyfile\", \"\", \"TLS private key file path\")\n\taAuthorization      = flag.String(\"authorization\", \"\", \"Defines a constant Authorization header value passed to all the image source servers. -enable-url-source flag must be defined. This overwrites authorization headers forwarding behavior via X-Forward-Authorization\")\n\taForwardHeaders     = flag.String(\"forward-headers\", \"\", \"Forwards custom headers to the image source server. -enable-url-source flag must be defined.\")\n\taPlaceholder        = flag.String(\"placeholder\", \"\", \"Image path to image custom placeholder to be used in case of error. Recommended minimum image size is: 1200x1200\")\n\taPlaceholderStatus  = flag.Int(\"placeholder-status\", 0, \"HTTP status returned when use -placeholder flag\")\n\taDisableEndpoints   = flag.String(\"disable-endpoints\", \"\", \"Comma separated endpoints to disable. E.g: form,crop,rotate,health\")\n\taHTTPCacheTTL       = flag.Int(\"http-cache-ttl\", -1, \"The TTL in seconds\")\n\taReadTimeout        = flag.Int(\"http-read-timeout\", 60, \"HTTP read timeout in seconds\")\n\taWriteTimeout       = flag.Int(\"http-write-timeout\", 60, \"HTTP write timeout in seconds\")\n\taConcurrency        = flag.Int(\"concurrency\", 0, \"Throttle concurrency limit per second\")\n\taBurst              = flag.Int(\"burst\", 100, \"Throttle burst max cache size\")\n\taMRelease           = flag.Int(\"mrelease\", 30, \"OS memory release interval in seconds\")\n\taCpus               = flag.Int(\"cpus\", runtime.GOMAXPROCS(-1), \"Number of cpu cores to use\")\n\taLogLevel           = flag.String(\"log-level\", \"info\", \"Define log level for http-server. E.g: info,warning,error\")\n\taReturnSize         = flag.Bool(\"return-size\", false, \"Return the image size in the HTTP headers\")\n)\n\nconst usage = `imaginary %s\n\nUsage:\n  imaginary -p 80\n  imaginary -cors\n  imaginary -concurrency 10\n  imaginary -path-prefix /api/v1\n  imaginary -enable-url-source\n  imaginary -disable-endpoints form,health,crop,rotate\n  imaginary -enable-url-source -allowed-origins http://localhost,http://server.com\n  imaginary -enable-url-source -enable-auth-forwarding\n  imaginary -enable-url-source -authorization \"Basic AwDJdL2DbwrD==\"\n  imaginary -enable-placeholder\n  imaginary -enable-url-source -placeholder ./placeholder.jpg\n  imaginary -enable-url-signature -url-signature-key 4f46feebafc4b5e988f131c4ff8b5997\n  imaginary -enable-url-source -forward-headers X-Custom,X-Token\n  imaginary -h | -help\n  imaginary -v | -version\n\nOptions:\n\n  -a <addr>                  Bind address [default: *]\n  -p <port>                  Bind port [default: 8088]\n  -h, -help                  Show help\n  -v, -version               Show version\n  -path-prefix <value>       Url path prefix to listen to [default: \"/\"]\n  -cors                      Enable CORS support [default: false]\n  -gzip                      Enable gzip compression (deprecated) [default: false]\n  -disable-endpoints         Comma separated endpoints to disable. E.g: form,crop,rotate,health [default: \"\"]\n  -key <key>                 Define API key for authorization\n  -mount <path>              Mount server local directory\n  -http-cache-ttl <num>      The TTL in seconds. Adds caching headers to locally served files.\n  -http-read-timeout <num>   HTTP read timeout in seconds [default: 30]\n  -http-write-timeout <num>  HTTP write timeout in seconds [default: 30]\n  -enable-url-source         Enable remote HTTP URL image source processing\n  -enable-placeholder        Enable image response placeholder to be used in case of error [default: false]\n  -enable-auth-forwarding    Forwards X-Forward-Authorization or Authorization header to the image source server. -enable-url-source flag must be defined. Tip: secure your server from public access to prevent attack vectors\n  -forward-headers           Forwards custom headers to the image source server. -enable-url-source flag must be defined.\n  -enable-url-signature      Enable URL signature (URL-safe Base64-encoded HMAC digest) [default: false]\n  -url-signature-key         The URL signature key (32 characters minimum)\n  -allowed-origins <urls>    Restrict remote image source processing to certain origins (separated by commas)\n  -max-allowed-size <bytes>  Restrict maximum size of http image source (in bytes)\n  -max-allowed-resolution <megapixels> Restrict maximum resolution of the image [default: 18.0]\n  -certfile <path>           TLS certificate file path\n  -keyfile <path>            TLS private key file path\n  -authorization <value>     Defines a constant Authorization header value passed to all the image source servers. -enable-url-source flag must be defined. This overwrites authorization headers forwarding behavior via X-Forward-Authorization\n  -placeholder <path>        Image path to image custom placeholder to be used in case of error. Recommended minimum image size is: 1200x1200\n  -placeholder-status <code> HTTP status returned when use -placeholder flag\n  -concurrency <num>         Throttle concurrency limit per second [default: disabled]\n  -burst <num>               Throttle burst max cache size [default: 100]\n  -mrelease <num>            OS memory release interval in seconds [default: 30]\n  -cpus <num>                Number of used cpu cores.\n                             (default for current machine is %d cores)\n  -log-level                 Set log level for http-server. E.g: info,warning,error [default: info].\n                             Or can use the environment variable GOLANG_LOG=info.\n  -return-size               Return the image size with X-Width and X-Height HTTP header. [default: disabled].\n`\n\ntype URLSignature struct {\n\tKey string\n}\n\nfunc main() {\n\tflag.Usage = func() {\n\t\t_, _ = fmt.Fprintf(os.Stderr, usage, Version, runtime.NumCPU())\n\t}\n\tflag.Parse()\n\n\tif *aHelp || *aHelpl {\n\t\tshowUsage()\n\t}\n\tif *aVers || *aVersl {\n\t\tshowVersion()\n\t}\n\n\t// Only required in Go < 1.5\n\truntime.GOMAXPROCS(*aCpus)\n\n\tport := getPort(*aPort)\n\turlSignature := getURLSignature(*aURLSignatureKey)\n\n\topts := ServerOptions{\n\t\tPort:               port,\n\t\tAddress:            *aAddr,\n\t\tCORS:               *aCors,\n\t\tAuthForwarding:     *aAuthForwarding,\n\t\tEnableURLSource:    *aEnableURLSource,\n\t\tEnablePlaceholder:  *aEnablePlaceholder,\n\t\tEnableURLSignature: *aEnableURLSignature,\n\t\tURLSignatureKey:    urlSignature.Key,\n\t\tPathPrefix:         *aPathPrefix,\n\t\tAPIKey:             *aKey,\n\t\tConcurrency:        *aConcurrency,\n\t\tBurst:              *aBurst,\n\t\tMount:              *aMount,\n\t\tCertFile:           *aCertFile,\n\t\tKeyFile:            *aKeyFile,\n\t\tPlaceholder:        *aPlaceholder,\n\t\tPlaceholderStatus:  *aPlaceholderStatus,\n\t\tHTTPCacheTTL:       *aHTTPCacheTTL,\n\t\tHTTPReadTimeout:    *aReadTimeout,\n\t\tHTTPWriteTimeout:   *aWriteTimeout,\n\t\tAuthorization:      *aAuthorization,\n\t\tForwardHeaders:     parseForwardHeaders(*aForwardHeaders),\n\t\tAllowedOrigins:     parseOrigins(*aAllowedOrigins),\n\t\tMaxAllowedSize:     *aMaxAllowedSize,\n\t\tMaxAllowedPixels:   *aMaxAllowedPixels,\n\t\tLogLevel:           getLogLevel(*aLogLevel),\n\t\tReturnSize:         *aReturnSize,\n\t}\n\n\t// Show warning if gzip flag is passed\n\tif *aGzip {\n\t\tfmt.Println(\"warning: -gzip flag is deprecated and will not have effect\")\n\t}\n\n\t// Create a memory release goroutine\n\tif *aMRelease > 0 {\n\t\tmemoryRelease(*aMRelease)\n\t}\n\n\t// Check if the mount directory exists, if present\n\tif *aMount != \"\" {\n\t\tcheckMountDirectory(*aMount)\n\t}\n\n\t// Validate HTTP cache param, if present\n\tif *aHTTPCacheTTL != -1 {\n\t\tcheckHTTPCacheTTL(*aHTTPCacheTTL)\n\t}\n\n\t// Parse endpoint names to disabled, if present\n\tif *aDisableEndpoints != \"\" {\n\t\topts.Endpoints = parseEndpoints(*aDisableEndpoints)\n\t}\n\n\t// Read placeholder image, if required\n\tif *aPlaceholder != \"\" {\n\t\tbuf, err := ioutil.ReadFile(*aPlaceholder)\n\t\tif err != nil {\n\t\t\texitWithError(\"cannot start the server: %s\", err)\n\t\t}\n\n\t\timageType := bimg.DetermineImageType(buf)\n\t\tif !bimg.IsImageTypeSupportedByVips(imageType).Load {\n\t\t\texitWithError(\"Placeholder image type is not supported. Only JPEG, PNG or WEBP are supported\")\n\t\t}\n\n\t\topts.PlaceholderImage = buf\n\t} else if *aEnablePlaceholder {\n\t\t// Expose default placeholder\n\t\topts.PlaceholderImage = placeholder\n\t}\n\n\t// Check URL signature key, if required\n\tif *aEnableURLSignature {\n\t\tif urlSignature.Key == \"\" {\n\t\t\texitWithError(\"URL signature key is required\")\n\t\t}\n\n\t\tif len(urlSignature.Key) < 32 {\n\t\t\texitWithError(\"URL signature key must be a minimum of 32 characters\")\n\t\t}\n\t}\n\n\tdebug(\"imaginary server listening on port :%d/%s\", opts.Port, strings.TrimPrefix(opts.PathPrefix, \"/\"))\n\n\t// Load image source providers\n\tLoadSources(opts)\n\n\t// Start the server\n\tServer(opts)\n}\n\nfunc getPort(port int) int {\n\tif portEnv := os.Getenv(\"PORT\"); portEnv != \"\" {\n\t\tnewPort, _ := strconv.Atoi(portEnv)\n\t\tif newPort > 0 {\n\t\t\tport = newPort\n\t\t}\n\t}\n\treturn port\n}\n\nfunc getURLSignature(key string) URLSignature {\n\tif keyEnv := os.Getenv(\"URL_SIGNATURE_KEY\"); keyEnv != \"\" {\n\t\tkey = keyEnv\n\t}\n\n\treturn URLSignature{key}\n}\n\nfunc getLogLevel(logLevel string) string {\n\tif logLevelEnv := os.Getenv(\"GOLANG_LOG\"); logLevelEnv != \"\" {\n\t\tlogLevel = logLevelEnv\n\t}\n\treturn logLevel\n}\n\nfunc showUsage() {\n\tflag.Usage()\n\tos.Exit(1)\n}\n\nfunc showVersion() {\n\tfmt.Println(Version)\n\tos.Exit(1)\n}\n\nfunc checkMountDirectory(path string) {\n\tsrc, err := os.Stat(path)\n\tif err != nil {\n\t\texitWithError(\"error while mounting directory: %s\", err)\n\t}\n\tif !src.IsDir() {\n\t\texitWithError(\"mount path is not a directory: %s\", path)\n\t}\n\tif path == \"/\" {\n\t\texitWithError(\"cannot mount root directory for security reasons\")\n\t}\n}\n\nfunc checkHTTPCacheTTL(ttl int) {\n\tif ttl < 0 || ttl > 31556926 {\n\t\texitWithError(\"The -http-cache-ttl flag only accepts a value from 0 to 31556926\")\n\t}\n\n\tif ttl == 0 {\n\t\tdebug(\"Adding HTTP cache control headers set to prevent caching.\")\n\t}\n}\n\nfunc parseForwardHeaders(forwardHeaders string) []string {\n\tvar headers []string\n\tif forwardHeaders == \"\" {\n\t\treturn headers\n\t}\n\n\tfor _, header := range strings.Split(forwardHeaders, \",\") {\n\t\tif norm := strings.TrimSpace(header); norm != \"\" {\n\t\t\theaders = append(headers, norm)\n\t\t}\n\t}\n\treturn headers\n}\n\nfunc parseOrigins(origins string) []*url.URL {\n\tvar urls []*url.URL\n\tif origins == \"\" {\n\t\treturn urls\n\t}\n\tfor _, origin := range strings.Split(origins, \",\") {\n\t\tu, err := url.Parse(origin)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif u.Path != \"\" {\n\t\t\tvar lastChar = u.Path[len(u.Path)-1:]\n\t\t\tif lastChar == \"*\" {\n\t\t\t\tu.Path = strings.TrimSuffix(u.Path, \"*\")\n\t\t\t} else if lastChar != \"/\" {\n\t\t\t\tu.Path += \"/\"\n\t\t\t}\n\t\t}\n\n\t\turls = append(urls, u)\n\t}\n\treturn urls\n}\n\nfunc parseEndpoints(input string) Endpoints {\n\tvar endpoints Endpoints\n\tfor _, endpoint := range strings.Split(input, \",\") {\n\t\tendpoint = strings.ToLower(strings.TrimSpace(endpoint))\n\t\tif endpoint != \"\" {\n\t\t\tendpoints = append(endpoints, endpoint)\n\t\t}\n\t}\n\treturn endpoints\n}\n\nfunc memoryRelease(interval int) {\n\tticker := time.NewTicker(time.Duration(interval) * time.Second)\n\tgo func() {\n\t\tfor range ticker.C {\n\t\t\tdebug(\"FreeOSMemory()\")\n\t\t\td.FreeOSMemory()\n\t\t}\n\t}()\n}\n\nfunc exitWithError(format string, args ...interface{}) {\n\t_, _ = fmt.Fprintf(os.Stderr, format+\"\\n\", args)\n\tos.Exit(1)\n}\n\nfunc debug(msg string, values ...interface{}) {\n\tdebug := os.Getenv(\"DEBUG\")\n\tif debug == \"imaginary\" || debug == \"*\" {\n\t\tlog.Printf(msg, values...)\n\t}\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 2.4541015625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst formatPattern = \"%s - - [%s] \\\"%s\\\" %d %d %.4f\\n\"\n\n// LogRecord implements an Apache-compatible HTTP logging\ntype LogRecord struct {\n\thttp.ResponseWriter\n\tstatus                int\n\tresponseBytes         int64\n\tip                    string\n\tmethod, uri, protocol string\n\ttime                  time.Time\n\telapsedTime           time.Duration\n}\n\n// Log writes a log entry in the passed io.Writer stream\nfunc (r *LogRecord) Log(out io.Writer) {\n\ttimeFormat := r.time.Format(\"02/Jan/2006 15:04:05\")\n\trequest := fmt.Sprintf(\"%s %s %s\", r.method, r.uri, r.protocol)\n\t_, _ = fmt.Fprintf(out, formatPattern, r.ip, timeFormat, request, r.status, r.responseBytes, r.elapsedTime.Seconds())\n}\n\n// Write acts like a proxy passing the given bytes buffer to the ResponseWritter\n// and additionally counting the passed amount of bytes for logging usage.\nfunc (r *LogRecord) Write(p []byte) (int, error) {\n\twritten, err := r.ResponseWriter.Write(p)\n\tr.responseBytes += int64(written)\n\treturn written, err\n}\n\n// WriteHeader calls ResponseWriter.WriteHeader() and sets the status code\nfunc (r *LogRecord) WriteHeader(status int) {\n\tr.status = status\n\tr.ResponseWriter.WriteHeader(status)\n}\n\n// LogHandler maps the HTTP handler with a custom io.Writer compatible stream\ntype LogHandler struct {\n\thandler  http.Handler\n\tio       io.Writer\n\tlogLevel string\n}\n\n// NewLog creates a new logger\nfunc NewLog(handler http.Handler, io io.Writer, logLevel string) http.Handler {\n\treturn &LogHandler{handler, io, logLevel}\n}\n\n// Implements the required method as standard HTTP handler, serving the request.\nfunc (h *LogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tclientIP := r.RemoteAddr\n\tif colon := strings.LastIndex(clientIP, \":\"); colon != -1 {\n\t\tclientIP = clientIP[:colon]\n\t}\n\n\trecord := &LogRecord{\n\t\tResponseWriter: w,\n\t\tip:             clientIP,\n\t\ttime:           time.Time{},\n\t\tmethod:         r.Method,\n\t\turi:            r.RequestURI,\n\t\tprotocol:       r.Proto,\n\t\tstatus:         http.StatusOK,\n\t\telapsedTime:    time.Duration(0),\n\t}\n\n\tstartTime := time.Now()\n\th.handler.ServeHTTP(record, r)\n\tfinishTime := time.Now()\n\n\trecord.time = finishTime.UTC()\n\trecord.elapsedTime = finishTime.Sub(startTime)\n\n\tswitch h.logLevel {\n\tcase \"error\":\n\t\tif record.status >= http.StatusInternalServerError {\n\t\t\trecord.Log(h.io)\n\t\t}\n\tcase \"warning\":\n\t\tif record.status >= http.StatusBadRequest {\n\t\t\trecord.Log(h.io)\n\t\t}\n\tcase \"info\":\n\t\trecord.Log(h.io)\n\t}\n}\n"
        },
        {
          "name": "log_test.go",
          "type": "blob",
          "size": 1.224609375,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype fakeWriter func([]byte) (int, error)\n\nfunc (fake fakeWriter) Write(buf []byte) (int, error) {\n\treturn fake(buf)\n}\n\nfunc TestLogInfo(t *testing.T) {\n\tvar buf []byte\n\twriter := fakeWriter(func(b []byte) (int, error) {\n\t\tbuf = b\n\t\treturn 0, nil\n\t})\n\n\tnoopHandler := func(w http.ResponseWriter, r *http.Request) {}\n\tlog := NewLog(http.HandlerFunc(noopHandler), writer, \"info\")\n\n\tts := httptest.NewServer(log)\n\tdefer ts.Close()\n\n\t_, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdata := string(buf)\n\tif strings.Contains(data, http.MethodGet) == false ||\n\t\tstrings.Contains(data, \"HTTP/1.1\") == false ||\n\t\tstrings.Contains(data, \" 200 \") == false {\n\t\tt.Fatalf(\"Invalid log output: %s\", data)\n\t}\n}\n\nfunc TestLogError(t *testing.T) {\n\tvar buf []byte\n\twriter := fakeWriter(func(b []byte) (int, error) {\n\t\tbuf = b\n\t\treturn 0, nil\n\t})\n\n\tnoopHandler := func(w http.ResponseWriter, r *http.Request) {}\n\tlog := NewLog(http.HandlerFunc(noopHandler), writer, \"error\")\n\n\tts := httptest.NewServer(log)\n\tdefer ts.Close()\n\n\t_, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdata := string(buf)\n\tif data != \"\" {\n\t\tt.Fatalf(\"Invalid log output: %s\", data)\n\t}\n}\n"
        },
        {
          "name": "middleware.go",
          "type": "blob",
          "size": 4.7314453125,
          "content": "package main\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/h2non/bimg\"\n\t\"github.com/rs/cors\"\n\t\"github.com/throttled/throttled/v2\"\n\t\"github.com/throttled/throttled/v2/store/memstore\"\n)\n\nfunc Middleware(fn func(http.ResponseWriter, *http.Request), o ServerOptions) http.Handler {\n\tnext := http.Handler(http.HandlerFunc(fn))\n\n\tif len(o.Endpoints) > 0 {\n\t\tnext = filterEndpoint(next, o)\n\t}\n\tif o.Concurrency > 0 {\n\t\tnext = throttle(next, o)\n\t}\n\tif o.CORS {\n\t\tnext = cors.Default().Handler(next)\n\t}\n\tif o.APIKey != \"\" {\n\t\tnext = authorizeClient(next, o)\n\t}\n\tif o.HTTPCacheTTL >= 0 {\n\t\tnext = setCacheHeaders(next, o.HTTPCacheTTL)\n\t}\n\n\treturn validate(defaultHeaders(next), o)\n}\n\nfunc ImageMiddleware(o ServerOptions) func(Operation) http.Handler {\n\treturn func(fn Operation) http.Handler {\n\t\thandler := validateImage(Middleware(imageController(o, fn), o), o)\n\n\t\tif o.EnableURLSignature {\n\t\t\treturn validateURLSignature(handler, o)\n\t\t}\n\n\t\treturn handler\n\t}\n}\n\nfunc filterEndpoint(next http.Handler, o ServerOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif o.Endpoints.IsValid(r) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tErrorReply(r, w, ErrNotImplemented, o)\n\t})\n}\n\nfunc throttleError(err error) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Error(w, \"throttle error: \"+err.Error(), http.StatusInternalServerError)\n\t})\n}\n\nfunc throttle(next http.Handler, o ServerOptions) http.Handler {\n\tstore, err := memstore.New(65536)\n\tif err != nil {\n\t\treturn throttleError(err)\n\t}\n\n\tquota := throttled.RateQuota{MaxRate: throttled.PerSec(o.Concurrency), MaxBurst: o.Burst}\n\trateLimiter, err := throttled.NewGCRARateLimiter(store, quota)\n\tif err != nil {\n\t\treturn throttleError(err)\n\t}\n\n\thttpRateLimiter := throttled.HTTPRateLimiter{\n\t\tRateLimiter: rateLimiter,\n\t\tVaryBy:      &throttled.VaryBy{Method: true},\n\t}\n\n\treturn httpRateLimiter.RateLimit(next)\n}\n\nfunc validate(next http.Handler, o ServerOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet && r.Method != http.MethodPost {\n\t\t\tErrorReply(r, w, ErrMethodNotAllowed, o)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc validateImage(next http.Handler, o ServerOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := r.URL.Path\n\t\tif r.Method == http.MethodGet && isPublicPath(path) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == http.MethodGet && o.Mount == \"\" && !o.EnableURLSource {\n\t\t\tErrorReply(r, w, ErrGetMethodNotAllowed, o)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc authorizeClient(next http.Handler, o ServerOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tkey := r.Header.Get(\"API-Key\")\n\t\tif key == \"\" {\n\t\t\tkey = r.URL.Query().Get(\"key\")\n\t\t}\n\n\t\tif key != o.APIKey {\n\t\t\tErrorReply(r, w, ErrInvalidAPIKey, o)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc defaultHeaders(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Server\", fmt.Sprintf(\"imaginary %s (bimg %s)\", Version, bimg.Version))\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc setCacheHeaders(next http.Handler, ttl int) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer next.ServeHTTP(w, r)\n\n\t\tif r.Method != http.MethodGet || isPublicPath(r.URL.Path) {\n\t\t\treturn\n\t\t}\n\n\t\tttlDiff := time.Duration(ttl) * time.Second\n\t\texpires := time.Now().Add(ttlDiff)\n\n\t\tw.Header().Add(\"Expires\", strings.Replace(expires.Format(time.RFC1123), \"UTC\", \"GMT\", -1))\n\t\tw.Header().Add(\"Cache-Control\", getCacheControl(ttl))\n\t})\n}\n\nfunc getCacheControl(ttl int) string {\n\tif ttl == 0 {\n\t\treturn \"private, no-cache, no-store, must-revalidate\"\n\t}\n\treturn fmt.Sprintf(\"public, s-maxage=%d, max-age=%d, no-transform\", ttl, ttl)\n}\n\nfunc isPublicPath(path string) bool {\n\treturn path == \"/\" || path == \"/health\" || path == \"/form\"\n}\n\nfunc validateURLSignature(next http.Handler, o ServerOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Retrieve and remove URL signature from request parameters\n\t\tquery := r.URL.Query()\n\t\tsign := query.Get(\"sign\")\n\t\tquery.Del(\"sign\")\n\n\t\t// Compute expected URL signature\n\t\th := hmac.New(sha256.New, []byte(o.URLSignatureKey))\n\t\t_, _ = h.Write([]byte(r.URL.Path))\n\t\t_, _ = h.Write([]byte(query.Encode()))\n\t\texpectedSign := h.Sum(nil)\n\n\t\turlSign, err := base64.RawURLEncoding.DecodeString(sign)\n\t\tif err != nil {\n\t\t\tErrorReply(r, w, ErrInvalidURLSignature, o)\n\t\t\treturn\n\t\t}\n\n\t\tif !hmac.Equal(urlSign, expectedSign) {\n\t\t\tErrorReply(r, w, ErrURLSignatureMismatch, o)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 4.171875,
          "content": "package main\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n)\n\n// ImageOptions represent all the supported image transformation params as first level members\ntype ImageOptions struct {\n\tIsDefinedField\n\n\tWidth         int\n\tHeight        int\n\tAreaWidth     int\n\tAreaHeight    int\n\tQuality       int\n\tCompression   int\n\tRotate        int\n\tTop           int\n\tLeft          int\n\tMargin        int\n\tFactor        int\n\tDPI           int\n\tTextWidth     int\n\tFlip          bool\n\tFlop          bool\n\tForce         bool\n\tEmbed         bool\n\tNoCrop        bool\n\tNoReplicate   bool\n\tNoRotation    bool\n\tNoProfile     bool\n\tStripMetadata bool\n\tOpacity       float32\n\tSigma         float64\n\tMinAmpl       float64\n\tText          string\n\tImage         string\n\tFont          string\n\tType          string\n\tAspectRatio   string\n\tColor         []uint8\n\tBackground    []uint8\n\tInterlace     bool\n\tSpeed         int\n\tExtend        bimg.Extend\n\tGravity       bimg.Gravity\n\tColorspace    bimg.Interpretation\n\tOperations    PipelineOperations\n}\n\n// IsDefinedField holds boolean ImageOptions fields. If true it means the field was specified in the request. This\n// metadata allows for sane usage of default (false) values.\ntype IsDefinedField struct {\n\tFlip          bool\n\tFlop          bool\n\tForce         bool\n\tEmbed         bool\n\tNoCrop        bool\n\tNoReplicate   bool\n\tNoRotation    bool\n\tNoProfile     bool\n\tStripMetadata bool\n\tInterlace     bool\n\tPalette       bool\n}\n\n// PipelineOperation represents the structure for an operation field.\ntype PipelineOperation struct {\n\tName          string                 `json:\"operation\"`\n\tIgnoreFailure bool                   `json:\"ignore_failure\"`\n\tParams        map[string]interface{} `json:\"params\"`\n\tImageOptions  ImageOptions           `json:\"-\"`\n\tOperation     Operation              `json:\"-\"`\n}\n\n// PipelineOperations defines the expected interface for a list of operations.\ntype PipelineOperations []PipelineOperation\n\nfunc transformByAspectRatio(params map[string]interface{}) (width, height int) {\n\twidth, _ = coerceTypeInt(params[\"width\"])\n\theight, _ = coerceTypeInt(params[\"height\"])\n\n\taspectRatio, ok := params[\"aspectratio\"].(map[string]int)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif width != 0 {\n\t\theight = width / aspectRatio[\"width\"] * aspectRatio[\"height\"]\n\t} else {\n\t\twidth = height / aspectRatio[\"height\"] * aspectRatio[\"width\"]\n\t}\n\n\treturn\n}\n\nfunc parseAspectRatio(val string) map[string]int {\n\tval = strings.TrimSpace(strings.ToLower(val))\n\tslicedVal := strings.Split(val, \":\")\n\n\tif len(slicedVal) < 2 {\n\t\treturn nil\n\t}\n\n\twidth, _ := strconv.Atoi(slicedVal[0])\n\theight, _ := strconv.Atoi(slicedVal[1])\n\n\treturn map[string]int{\n\t\t\"width\":  width,\n\t\t\"height\": height,\n\t}\n}\n\nfunc shouldTransformByAspectRatio(height, width int) bool {\n\n\t// override aspect ratio parameters if width and height is given or not given at all\n\tif (width != 0 && height != 0) || (width == 0 && height == 0) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// BimgOptions creates a new bimg compatible options struct mapping the fields properly\nfunc BimgOptions(o ImageOptions) bimg.Options {\n\topts := bimg.Options{\n\t\tWidth:          o.Width,\n\t\tHeight:         o.Height,\n\t\tFlip:           o.Flip,\n\t\tFlop:           o.Flop,\n\t\tQuality:        o.Quality,\n\t\tCompression:    o.Compression,\n\t\tNoAutoRotate:   o.NoRotation,\n\t\tNoProfile:      o.NoProfile,\n\t\tForce:          o.Force,\n\t\tGravity:        o.Gravity,\n\t\tEmbed:          o.Embed,\n\t\tExtend:         o.Extend,\n\t\tInterpretation: o.Colorspace,\n\t\tStripMetadata:  o.StripMetadata,\n\t\tType:           ImageType(o.Type),\n\t\tRotate:         bimg.Angle(o.Rotate),\n\t\tInterlace:      o.Interlace,\n\t\tPalette:        o.Palette,\n\t\tSpeed:          o.Speed,\n\t}\n\n\tif len(o.Background) != 0 {\n\t\topts.Background = bimg.Color{R: o.Background[0], G: o.Background[1], B: o.Background[2]}\n\t}\n\n\tif shouldTransformByAspectRatio(opts.Height, opts.Width) && o.AspectRatio != \"\" {\n\t\tparams := make(map[string]interface{})\n\t\tparams[\"height\"] = opts.Height\n\t\tparams[\"width\"] = opts.Width\n\t\tparams[\"aspectratio\"] = parseAspectRatio(o.AspectRatio)\n\n\t\topts.Width, opts.Height = transformByAspectRatio(params)\n\t}\n\n\tif o.Sigma > 0 || o.MinAmpl > 0 {\n\t\topts.GaussianBlur = bimg.GaussianBlur{\n\t\t\tSigma:   o.Sigma,\n\t\t\tMinAmpl: o.MinAmpl,\n\t\t}\n\t}\n\n\treturn opts\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 0.2626953125,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestBimgOptions(t *testing.T) {\n\timgOpts := ImageOptions{\n\t\tWidth:  500,\n\t\tHeight: 600,\n\t}\n\topts := BimgOptions(imgOpts)\n\n\tif opts.Width != imgOpts.Width || opts.Height != imgOpts.Height {\n\t\tt.Error(\"Invalid width and height\")\n\t}\n}\n"
        },
        {
          "name": "params.go",
          "type": "blob",
          "size": 11.029296875,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nvar ErrUnsupportedValue = errors.New(\"unsupported value\")\n\n// Coercion is the type that type coerces a parameter and defines the appropriate field on ImageOptions\ntype Coercion func(*ImageOptions, interface{}) error\n\nvar paramTypeCoercions = map[string]Coercion{\n\t\"width\":       coerceWidth,\n\t\"height\":      coerceHeight,\n\t\"quality\":     coerceQuality,\n\t\"top\":         coerceTop,\n\t\"left\":        coerceLeft,\n\t\"areawidth\":   coerceAreaWidth,\n\t\"areaheight\":  coerceAreaHeight,\n\t\"compression\": coerceCompression,\n\t\"rotate\":      coerceRotate,\n\t\"margin\":      coerceMargin,\n\t\"factor\":      coerceFactor,\n\t\"dpi\":         coerceDPI,\n\t\"textwidth\":   coerceTextWidth,\n\t\"opacity\":     coerceOpacity,\n\t\"flip\":        coerceFlip,\n\t\"flop\":        coerceFlop,\n\t\"nocrop\":      coerceNoCrop,\n\t\"noprofile\":   coerceNoProfile,\n\t\"norotation\":  coerceNoRotation,\n\t\"noreplicate\": coerceNoReplicate,\n\t\"force\":       coerceForce,\n\t\"embed\":       coerceEmbed,\n\t\"stripmeta\":   coerceStripMeta,\n\t\"text\":        coerceText,\n\t\"image\":       coerceImage,\n\t\"font\":        coerceFont,\n\t\"type\":        coerceImageType,\n\t\"color\":       coerceColor,\n\t\"colorspace\":  coerceColorSpace,\n\t\"gravity\":     coerceGravity,\n\t\"background\":  coerceBackground,\n\t\"extend\":      coerceExtend,\n\t\"sigma\":       coerceSigma,\n\t\"minampl\":     coerceMinAmpl,\n\t\"operations\":  coerceOperations,\n\t\"interlace\":   coerceInterlace,\n\t\"aspectratio\": coerceAspectRatio,\n\t\"palette\":     coercePalette,\n\t\"speed\":       coerceSpeed,\n}\n\nfunc coerceTypeInt(param interface{}) (int, error) {\n\tif v, ok := param.(int); ok {\n\t\treturn v, nil\n\t}\n\n\tif v, ok := param.(float64); ok {\n\t\treturn int(v), nil\n\t}\n\n\tif v, ok := param.(string); ok {\n\t\treturn parseInt(v)\n\t}\n\n\treturn 0, ErrUnsupportedValue\n}\n\nfunc coerceTypeFloat(param interface{}) (float64, error) {\n\tif v, ok := param.(float64); ok {\n\t\treturn v, nil\n\t}\n\n\tif v, ok := param.(int); ok {\n\t\treturn float64(v), nil\n\t}\n\n\tif v, ok := param.(string); ok {\n\t\tresult, err := parseFloat(v)\n\t\tif err != nil {\n\t\t\treturn 0, ErrUnsupportedValue\n\t\t}\n\n\t\treturn result, nil\n\t}\n\n\treturn 0, ErrUnsupportedValue\n}\n\nfunc coerceTypeBool(param interface{}) (bool, error) {\n\tif v, ok := param.(bool); ok {\n\t\treturn v, nil\n\t}\n\n\tif v, ok := param.(string); ok {\n\t\tresult, err := parseBool(v)\n\t\tif err != nil {\n\t\t\treturn false, ErrUnsupportedValue\n\t\t}\n\n\t\treturn result, nil\n\t}\n\n\treturn false, ErrUnsupportedValue\n}\n\nfunc coerceTypeString(param interface{}) (string, error) {\n\tif v, ok := param.(string); ok {\n\t\treturn v, nil\n\t}\n\n\treturn \"\", ErrUnsupportedValue\n}\n\nfunc coerceHeight(io *ImageOptions, param interface{}) (err error) {\n\tio.Height, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceWidth(io *ImageOptions, param interface{}) (err error) {\n\tio.Width, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceQuality(io *ImageOptions, param interface{}) (err error) {\n\tio.Quality, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceTop(io *ImageOptions, param interface{}) (err error) {\n\tio.Top, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceLeft(io *ImageOptions, param interface{}) (err error) {\n\tio.Left, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceAreaWidth(io *ImageOptions, param interface{}) (err error) {\n\tio.AreaWidth, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceAreaHeight(io *ImageOptions, param interface{}) (err error) {\n\tio.AreaHeight, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceCompression(io *ImageOptions, param interface{}) (err error) {\n\tio.Compression, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceRotate(io *ImageOptions, param interface{}) (err error) {\n\tio.Rotate, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceMargin(io *ImageOptions, param interface{}) (err error) {\n\tio.Margin, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceFactor(io *ImageOptions, param interface{}) (err error) {\n\tio.Factor, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceDPI(io *ImageOptions, param interface{}) (err error) {\n\tio.DPI, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceTextWidth(io *ImageOptions, param interface{}) (err error) {\n\tio.TextWidth, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc coerceOpacity(io *ImageOptions, param interface{}) (err error) {\n\tv, err := coerceTypeFloat(param)\n\tio.Opacity = float32(v)\n\treturn err\n}\n\nfunc coerceFlip(io *ImageOptions, param interface{}) (err error) {\n\tio.Flip, err = coerceTypeBool(param)\n\tio.IsDefinedField.Flip = true\n\treturn err\n}\n\nfunc coerceFlop(io *ImageOptions, param interface{}) (err error) {\n\tio.Flop, err = coerceTypeBool(param)\n\tio.IsDefinedField.Flop = true\n\treturn err\n}\n\nfunc coerceNoCrop(io *ImageOptions, param interface{}) (err error) {\n\tio.NoCrop, err = coerceTypeBool(param)\n\tio.IsDefinedField.NoCrop = true\n\treturn err\n}\n\nfunc coerceNoProfile(io *ImageOptions, param interface{}) (err error) {\n\tio.NoProfile, err = coerceTypeBool(param)\n\tio.IsDefinedField.NoProfile = true\n\treturn err\n}\n\nfunc coerceNoRotation(io *ImageOptions, param interface{}) (err error) {\n\tio.NoRotation, err = coerceTypeBool(param)\n\tio.IsDefinedField.NoRotation = true\n\treturn err\n}\n\nfunc coerceNoReplicate(io *ImageOptions, param interface{}) (err error) {\n\tio.NoReplicate, err = coerceTypeBool(param)\n\tio.IsDefinedField.NoReplicate = true\n\treturn err\n}\n\nfunc coerceForce(io *ImageOptions, param interface{}) (err error) {\n\tio.Force, err = coerceTypeBool(param)\n\tio.IsDefinedField.Force = true\n\treturn err\n}\n\nfunc coerceEmbed(io *ImageOptions, param interface{}) (err error) {\n\tio.Embed, err = coerceTypeBool(param)\n\tio.IsDefinedField.Embed = true\n\treturn err\n}\n\nfunc coerceStripMeta(io *ImageOptions, param interface{}) (err error) {\n\tio.StripMetadata, err = coerceTypeBool(param)\n\tio.IsDefinedField.StripMetadata = true\n\treturn err\n}\n\nfunc coerceText(io *ImageOptions, param interface{}) (err error) {\n\tio.Text, err = coerceTypeString(param)\n\treturn err\n}\n\nfunc coerceImage(io *ImageOptions, param interface{}) (err error) {\n\tio.Image, err = coerceTypeString(param)\n\treturn err\n}\n\nfunc coerceFont(io *ImageOptions, param interface{}) (err error) {\n\tio.Font, err = coerceTypeString(param)\n\treturn err\n}\n\nfunc coerceImageType(io *ImageOptions, param interface{}) (err error) {\n\tio.Type, err = coerceTypeString(param)\n\treturn err\n}\n\nfunc coerceColor(io *ImageOptions, param interface{}) error {\n\tif v, ok := param.(string); ok {\n\t\tio.Color = parseColor(v)\n\t\treturn nil\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceColorSpace(io *ImageOptions, param interface{}) error {\n\tif v, ok := param.(string); ok {\n\t\tio.Colorspace = parseColorspace(v)\n\t\treturn nil\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceGravity(io *ImageOptions, param interface{}) error {\n\tif v, ok := param.(string); ok {\n\t\tio.Gravity = parseGravity(v)\n\t\treturn nil\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceBackground(io *ImageOptions, param interface{}) error {\n\tif v, ok := param.(string); ok {\n\t\tio.Background = parseColor(v)\n\t\treturn nil\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceAspectRatio(io *ImageOptions, param interface{}) (err error) {\n\tio.AspectRatio, err = coerceTypeString(param)\n\treturn err\n}\n\nfunc coerceExtend(io *ImageOptions, param interface{}) error {\n\tif v, ok := param.(string); ok {\n\t\tio.Extend = parseExtendMode(v)\n\t\treturn nil\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceSigma(io *ImageOptions, param interface{}) (err error) {\n\tio.Sigma, err = coerceTypeFloat(param)\n\treturn err\n}\n\nfunc coerceMinAmpl(io *ImageOptions, param interface{}) (err error) {\n\tio.MinAmpl, err = coerceTypeFloat(param)\n\treturn err\n}\n\nfunc coerceOperations(io *ImageOptions, param interface{}) (err error) {\n\tif v, ok := param.(string); ok {\n\t\tops, err := parseJSONOperations(v)\n\t\tif err == nil {\n\t\t\tio.Operations = ops\n\t\t}\n\n\t\treturn err\n\t}\n\n\treturn ErrUnsupportedValue\n}\n\nfunc coerceInterlace(io *ImageOptions, param interface{}) (err error) {\n\tio.Interlace, err = coerceTypeBool(param)\n\tio.IsDefinedField.Interlace = true\n\treturn err\n}\n\nfunc coercePalette(io *ImageOptions, param interface{}) (err error) {\n\tio.Palette, err = coerceTypeBool(param)\n\tio.IsDefinedField.Palette = true\n\treturn err\n}\n\nfunc coerceSpeed(io *ImageOptions, param interface{}) (err error) {\n\tio.Speed, err = coerceTypeInt(param)\n\treturn err\n}\n\nfunc buildParamsFromOperation(op PipelineOperation) (ImageOptions, error) {\n\tvar options ImageOptions\n\n\t// Apply defaults\n\toptions.Extend = bimg.ExtendCopy\n\n\tfor key, value := range op.Params {\n\t\tfn, ok := paramTypeCoercions[key]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := fn(&options, value)\n\t\tif err != nil {\n\t\t\treturn ImageOptions{}, fmt.Errorf(`error while processing parameter \"%s\" with value %q, error: %s`, key, value, err)\n\t\t}\n\t}\n\n\treturn options, nil\n}\n\n// buildParamsFromQuery builds the ImageOptions type from untyped parameters\nfunc buildParamsFromQuery(query url.Values) (ImageOptions, error) {\n\tvar options ImageOptions\n\n\t// Apply defaults\n\toptions.Extend = bimg.ExtendCopy\n\n\t// Extract only known parameters\n\tfor key := range query {\n\t\tfn, ok := paramTypeCoercions[key]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tvalue := query.Get(key)\n\t\terr := fn(&options, value)\n\t\tif err != nil {\n\t\t\treturn ImageOptions{}, fmt.Errorf(`error while processing parameter \"%s\" with value %q, error: %s`, key, value, err)\n\t\t}\n\t}\n\n\treturn options, nil\n}\n\nfunc parseBool(val string) (bool, error) {\n\tif val == \"\" {\n\t\treturn false, nil\n\t}\n\n\treturn strconv.ParseBool(val)\n}\n\nfunc parseInt(param string) (int, error) {\n\tif param == \"\" {\n\t\treturn 0, nil\n\t}\n\n\tf, err := parseFloat(param)\n\treturn int(math.Floor(f + 0.5)), err\n}\n\nfunc parseFloat(param string) (float64, error) {\n\tif param == \"\" {\n\t\treturn 0.0, nil\n\t}\n\n\tval, err := strconv.ParseFloat(param, 64)\n\treturn math.Abs(val), err\n}\n\nfunc parseColorspace(val string) bimg.Interpretation {\n\tif val == \"bw\" {\n\t\treturn bimg.InterpretationBW\n\t}\n\treturn bimg.InterpretationSRGB\n}\n\nfunc parseColor(val string) []uint8 {\n\tconst max float64 = 255\n\tvar buf []uint8\n\tif val != \"\" {\n\t\tfor _, num := range strings.Split(val, \",\") {\n\t\t\tn, _ := strconv.ParseUint(strings.Trim(num, \" \"), 10, 8)\n\t\t\tbuf = append(buf, uint8(math.Min(float64(n), max)))\n\t\t}\n\t}\n\treturn buf\n}\n\nfunc parseJSONOperations(data string) (PipelineOperations, error) {\n\tvar operations PipelineOperations\n\n\t// Fewer than 2 characters cannot be valid JSON. We assume empty operation.\n\tif len(data) < 2 {\n\t\treturn operations, nil\n\t}\n\n\td := json.NewDecoder(strings.NewReader(data))\n\td.DisallowUnknownFields()\n\n\terr := d.Decode(&operations)\n\treturn operations, err\n}\n\nfunc parseExtendMode(val string) bimg.Extend {\n\tval = strings.TrimSpace(strings.ToLower(val))\n\tif val == \"white\" {\n\t\treturn bimg.ExtendWhite\n\t}\n\tif val == \"black\" {\n\t\treturn bimg.ExtendBlack\n\t}\n\tif val == \"copy\" {\n\t\treturn bimg.ExtendCopy\n\t}\n\tif val == \"background\" {\n\t\treturn bimg.ExtendBackground\n\t}\n\tif val == \"lastpixel\" {\n\t\treturn bimg.ExtendLast\n\t}\n\treturn bimg.ExtendMirror\n}\n\nfunc parseGravity(val string) bimg.Gravity {\n\tvar m = map[string]bimg.Gravity{\n\t\t\"south\": bimg.GravitySouth,\n\t\t\"north\": bimg.GravityNorth,\n\t\t\"east\":  bimg.GravityEast,\n\t\t\"west\":  bimg.GravityWest,\n\t\t\"smart\": bimg.GravitySmart,\n\t}\n\n\tval = strings.TrimSpace(strings.ToLower(val))\n\tif g, ok := m[val]; ok {\n\t\treturn g\n\t}\n\n\treturn bimg.GravityCentre\n}\n"
        },
        {
          "name": "params_test.go",
          "type": "blob",
          "size": 9.6259765625,
          "content": "package main\n\nimport (\n\t\"math\"\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nconst epsilon = 0.0001\n\nfunc TestReadParams(t *testing.T) {\n\tq := url.Values{}\n\tq.Set(\"width\", \"100\")\n\tq.Add(\"height\", \"80\")\n\tq.Add(\"noreplicate\", \"1\")\n\tq.Add(\"opacity\", \"0.2\")\n\tq.Add(\"text\", \"hello\")\n\tq.Add(\"background\", \"255,10,20\")\n\tq.Add(\"interlace\", \"true\")\n\n\tparams, err := buildParamsFromQuery(q)\n\tif err != nil {\n\t\tt.Errorf(\"Failed reading params, %s\", err)\n\t}\n\n\tassert := params.Width == 100 &&\n\t\tparams.Height == 80 &&\n\t\tparams.NoReplicate == true &&\n\t\tparams.Opacity == 0.2 &&\n\t\tparams.Text == \"hello\" &&\n\t\tparams.Background[0] == 255 &&\n\t\tparams.Background[1] == 10 &&\n\t\tparams.Background[2] == 20 &&\n\t\tparams.Interlace == true\n\n\tif assert == false {\n\t\tt.Error(\"Invalid params\")\n\t}\n}\n\nfunc TestParseParam(t *testing.T) {\n\tintCases := []struct {\n\t\tvalue    string\n\t\texpected int\n\t}{\n\t\t{\"1\", 1},\n\t\t{\"0100\", 100},\n\t\t{\"-100\", 100},\n\t\t{\"99.02\", 99},\n\t\t{\"99.9\", 100},\n\t}\n\n\tfor _, test := range intCases {\n\t\tval, _ := parseInt(test.value)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %s != %d\", test.value, test.expected)\n\t\t}\n\t}\n\n\tfloatCases := []struct {\n\t\tvalue    string\n\t\texpected float64\n\t}{\n\t\t{\"1.1\", 1.1},\n\t\t{\"01.1\", 1.1},\n\t\t{\"-1.10\", 1.10},\n\t\t{\"99.999999\", 99.999999},\n\t}\n\n\tfor _, test := range floatCases {\n\t\tval, _ := parseFloat(test.value)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %#v != %#v\", val, test.expected)\n\t\t}\n\t}\n\n\tboolCases := []struct {\n\t\tvalue    string\n\t\texpected bool\n\t}{\n\t\t{\"true\", true},\n\t\t{\"false\", false},\n\t\t{\"1\", true},\n\t\t{\"1.1\", false},\n\t\t{\"-1\", false},\n\t\t{\"0\", false},\n\t\t{\"0.0\", false},\n\t\t{\"no\", false},\n\t\t{\"yes\", false},\n\t}\n\n\tfor _, test := range boolCases {\n\t\tval, _ := parseBool(test.value)\n\t\tif val != test.expected {\n\t\t\tt.Errorf(\"Invalid param: %#v != %#v\", val, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestParseColor(t *testing.T) {\n\tcases := []struct {\n\t\tvalue    string\n\t\texpected []uint8\n\t}{\n\t\t{\"200,100,20\", []uint8{200, 100, 20}},\n\t\t{\"0,280,200\", []uint8{0, 255, 200}},\n\t\t{\" -1, 256 , 50\", []uint8{0, 255, 50}},\n\t\t{\" a, 20 , &hel0\", []uint8{0, 20, 0}},\n\t\t{\"\", []uint8{}},\n\t}\n\n\tfor _, color := range cases {\n\t\tc := parseColor(color.value)\n\t\tl := len(color.expected)\n\n\t\tif len(c) != l {\n\t\t\tt.Errorf(\"Invalid color length: %#v\", c)\n\t\t}\n\t\tif l == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tassert := c[0] == color.expected[0] &&\n\t\t\tc[1] == color.expected[1] &&\n\t\t\tc[2] == color.expected[2]\n\n\t\tif assert == false {\n\t\t\tt.Errorf(\"Invalid color schema: %#v <> %#v\", color.expected, c)\n\t\t}\n\t}\n}\n\nfunc TestParseExtend(t *testing.T) {\n\tcases := []struct {\n\t\tvalue    string\n\t\texpected bimg.Extend\n\t}{\n\t\t{\"white\", bimg.ExtendWhite},\n\t\t{\"black\", bimg.ExtendBlack},\n\t\t{\"copy\", bimg.ExtendCopy},\n\t\t{\"mirror\", bimg.ExtendMirror},\n\t\t{\"lastpixel\", bimg.ExtendLast},\n\t\t{\"background\", bimg.ExtendBackground},\n\t\t{\" BACKGROUND  \", bimg.ExtendBackground},\n\t\t{\"invalid\", bimg.ExtendMirror},\n\t\t{\"\", bimg.ExtendMirror},\n\t}\n\n\tfor _, extend := range cases {\n\t\tc := parseExtendMode(extend.value)\n\t\tif c != extend.expected {\n\t\t\tt.Errorf(\"Invalid extend value : %d != %d\", c, extend.expected)\n\t\t}\n\t}\n}\n\nfunc TestGravity(t *testing.T) {\n\tcases := []struct {\n\t\tgravityValue   string\n\t\tsmartCropValue bool\n\t}{\n\t\t{gravityValue: \"foo\", smartCropValue: false},\n\t\t{gravityValue: \"smart\", smartCropValue: true},\n\t}\n\n\tfor _, td := range cases {\n\t\tio, _ := buildParamsFromQuery(url.Values{\"gravity\": []string{td.gravityValue}})\n\t\tif (io.Gravity == bimg.GravitySmart) != td.smartCropValue {\n\t\t\tt.Errorf(\"Expected %t to be %t, test data: %+v\", io.Gravity == bimg.GravitySmart, td.smartCropValue, td)\n\t\t}\n\t}\n}\n\nfunc TestReadMapParams(t *testing.T) {\n\tcases := []struct {\n\t\tparams   map[string]interface{}\n\t\texpected ImageOptions\n\t}{\n\t\t{\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"width\":   100,\n\t\t\t\t\"opacity\": 0.1,\n\t\t\t\t\"type\":    \"webp\",\n\t\t\t\t\"embed\":   true,\n\t\t\t\t\"gravity\": \"west\",\n\t\t\t\t\"color\":   \"255,200,150\",\n\t\t\t},\n\t\t\tImageOptions{\n\t\t\t\tWidth:   100,\n\t\t\t\tOpacity: 0.1,\n\t\t\t\tType:    \"webp\",\n\t\t\t\tEmbed:   true,\n\t\t\t\tGravity: bimg.GravityWest,\n\t\t\t\tColor:   []uint8{255, 200, 150},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range cases {\n\t\topts, err := buildParamsFromOperation(PipelineOperation{Params: test.params})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error reading parameters %s\", err)\n\t\t\tt.FailNow()\n\t\t}\n\t\tif opts.Width != test.expected.Width {\n\t\t\tt.Errorf(\"Invalid width: %d != %d\", opts.Width, test.expected.Width)\n\t\t}\n\t\tif opts.Opacity != test.expected.Opacity {\n\t\t\tt.Errorf(\"Invalid opacity: %#v != %#v\", opts.Opacity, test.expected.Opacity)\n\t\t}\n\t\tif opts.Type != test.expected.Type {\n\t\t\tt.Errorf(\"Invalid type: %s != %s\", opts.Type, test.expected.Type)\n\t\t}\n\t\tif opts.Embed != test.expected.Embed {\n\t\t\tt.Errorf(\"Invalid embed: %#v != %#v\", opts.Embed, test.expected.Embed)\n\t\t}\n\t\tif opts.Gravity != test.expected.Gravity {\n\t\t\tt.Errorf(\"Invalid gravity: %#v != %#v\", opts.Gravity, test.expected.Gravity)\n\t\t}\n\t\tif opts.Color[0] != test.expected.Color[0] || opts.Color[1] != test.expected.Color[1] || opts.Color[2] != test.expected.Color[2] {\n\t\t\tt.Errorf(\"Invalid color: %#v != %#v\", opts.Color, test.expected.Color)\n\t\t}\n\t}\n}\n\nfunc TestParseFunctions(t *testing.T) {\n\tt.Run(\"parseBool\", func(t *testing.T) {\n\t\tif r, err := parseBool(\"true\"); r != true {\n\t\t\tt.Errorf(\"Expected string true to result a native type true %s\", err)\n\t\t}\n\n\t\tif r, err := parseBool(\"false\"); r != false {\n\t\t\tt.Errorf(\"Expected string false to result a native type false %s\", err)\n\t\t}\n\n\t\t// A special case that we support\n\t\tif _, err := parseBool(\"\"); err != nil {\n\t\t\tt.Errorf(\"Expected blank values to default to false, it didn't! %s\", err)\n\t\t}\n\n\t\tif r, err := parseBool(\"foo\"); err == nil {\n\t\t\tt.Errorf(\"Expected malformed values to result in an error, it didn't! %+v\", r)\n\t\t}\n\t})\n}\n\nfunc TestBuildParamsFromOperation(t *testing.T) {\n\top := PipelineOperation{\n\t\tParams: map[string]interface{}{\n\t\t\t\"width\":      200,\n\t\t\t\"opacity\":    2.2,\n\t\t\t\"force\":      true,\n\t\t\t\"stripmeta\":  false,\n\t\t\t\"type\":       \"jpeg\",\n\t\t\t\"background\": \"255,12,3\",\n\t\t},\n\t}\n\n\toptions, err := buildParamsFromOperation(op)\n\tif err != nil {\n\t\tt.Errorf(\"Expected this to work! %s\", err)\n\t}\n\n\tif input := op.Params[\"width\"].(int); options.Width != 200 {\n\t\tt.Errorf(\"Expected the Width to be coerced with the correct value of %d\", input)\n\t}\n\n\tif input := op.Params[\"opacity\"].(float64); math.Abs(input-float64(options.Opacity)) > epsilon {\n\t\tt.Errorf(\"Expected the Opacity to be coerced with the correct value of %f\", input)\n\t}\n\n\tif options.Force != true || options.StripMetadata != false {\n\t\tt.Errorf(\"Expected boolean parameters to result in their respective value's\\n%+v\", options)\n\t}\n\n\tif input := op.Params[\"background\"].(string); options.Background[0] != 255 {\n\t\tt.Errorf(\"Expected color parameter to be coerced with the correct value of %s\", input)\n\t}\n}\n\nfunc TestCoerceTypeFns(t *testing.T) {\n\tt.Run(\"coerceTypeInt\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tInput  interface{}\n\t\t\tExpect int\n\t\t\tErr    error\n\t\t}{\n\t\t\t{Input: \"200\", Expect: 200},\n\t\t\t{Input: int(200), Expect: 200},\n\t\t\t{Input: float64(200), Expect: 200},\n\t\t\t{Input: false, Expect: 0, Err: ErrUnsupportedValue},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\n\t\t\tresult, err := coerceTypeInt(tc.Input)\n\t\t\tif err != nil && tc.Err == nil {\n\t\t\t\tt.Errorf(\"Did not expect error %s\\n%+v\", err, tc)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err != nil && tc.Err != err {\n\t\t\t\tt.Errorf(\"Expected an error to be thrown\\nExpected: %s\\nReceived: %s\", tc.Err, err)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err == nil && result != tc.Expect {\n\t\t\t\tt.Errorf(\"Expected proper coercion %s\\n%+v\\n%+v\", err, result, tc)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"coerceTypeFloat\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tInput  interface{}\n\t\t\tExpect float64\n\t\t\tErr    error\n\t\t}{\n\t\t\t{Input: \"200\", Expect: 200},\n\t\t\t{Input: int(200), Expect: 200},\n\t\t\t{Input: float64(200), Expect: 200},\n\t\t\t{Input: false, Expect: 0, Err: ErrUnsupportedValue},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\n\t\t\tresult, err := coerceTypeFloat(tc.Input)\n\t\t\tif err != nil && tc.Err == nil {\n\t\t\t\tt.Errorf(\"Did not expect error %s\\n%+v\", err, tc)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err != nil && tc.Err != err {\n\t\t\t\tt.Errorf(\"Expected an error to be thrown\\nExpected: %s\\nReceived: %s\", tc.Err, err)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err == nil && math.Abs(result-tc.Expect) > epsilon {\n\t\t\t\tt.Errorf(\"Expected proper coercion %s\\n%+v\\n%+v\", err, result, tc)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"coerceTypeBool\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tInput  interface{}\n\t\t\tExpect bool\n\t\t\tErr    error\n\t\t}{\n\t\t\t{Input: \"true\", Expect: true},\n\t\t\t{Input: true, Expect: true},\n\t\t\t{Input: \"1\", Expect: true},\n\t\t\t{Input: \"bubblegum\", Expect: false, Err: ErrUnsupportedValue},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\n\t\t\tresult, err := coerceTypeBool(tc.Input)\n\t\t\tif err != nil && tc.Err == nil {\n\t\t\t\tt.Errorf(\"Did not expect error %s\\n%+v\", err, tc)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err != nil && tc.Err != err {\n\t\t\t\tt.Errorf(\"Expected an error to be thrown\\nExpected: %s\\nReceived: %s\", tc.Err, err)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err == nil && result != tc.Expect {\n\t\t\t\tt.Errorf(\"Expected proper coercion %s\\n%+v\\n%+v\", err, result, tc)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"coerceTypeString\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tInput  interface{}\n\t\t\tExpect string\n\t\t\tErr    error\n\t\t}{\n\t\t\t{Input: \"true\", Expect: \"true\"},\n\t\t\t{Input: false, Err: ErrUnsupportedValue},\n\t\t\t{Input: 0.0, Err: ErrUnsupportedValue},\n\t\t\t{Input: 0, Err: ErrUnsupportedValue},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\n\t\t\tresult, err := coerceTypeString(tc.Input)\n\t\t\tif err != nil && tc.Err == nil {\n\t\t\t\tt.Errorf(\"Did not expect error %s\\n%+v\", err, tc)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err != nil && tc.Err != err {\n\t\t\t\tt.Errorf(\"Expected an error to be thrown\\nExpected: %s\\nReceived: %s\", tc.Err, err)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\tif tc.Err == nil && result != tc.Expect {\n\t\t\t\tt.Errorf(\"Expected proper coercion %s\\n%+v\\n%+v\", err, result, tc)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "placeholder.go",
          "type": "blob",
          "size": 2.71875,
          "content": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\nconst placeholderData = `/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAGQAZADASIAAhEBAxEB/8QAGwABAAMBAQEBAAAAAAAAAAAAAAQFBgMCAQf/xAA5EAEAAQQBAQUFBAcJAAAAAAAAAQIDBBEFEgYUITFRE0FzobEVNWHBFjZTcZGS0SIjNIGCg8Lh8f/EABQBAQAAAAAAAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwD9lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL92mzZru176aKZqnXpD2i8r925XwqvoCD+kWF6Xf5f+0vj+TsZ9VdNjr3RG56o0oezGJYyu894tU3Onp1v3b20eLhY+LNU49qmiavCde8EgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABF5X7tyvhVfRKReV+7cr4VX0BmuzvIWMHvHeJqjr6dajflv+rTYOdZzqKqseapimdTuNM52ZwsfM7z3m3FfR09PjMa3v0/c0uJiWMSmqnHtxRFU7mNzP1BRc5yOTicpTRbuVRaiKappjXj6pvD18jeybl7Npqos1U/2KfCIjxj3ef8VXz0RVz9mJ8p6In+LVgy+dyuXj8xdoorqrt01apt68/Dw+a14WM6YvVch1RNUx0RMx+PujyU8xFXazU/tN/JqwZ7meTyas6MLAmYqiYiZjzmfT8HHH5HOwM+ixyNU1UVa3vU6iffEuPF/wB52mrqq8+u5P1de18R3jHq980zHzBf8ncrs8fkXLdXTXTRMxPozeJyPKZdqqzjzVcub3Neo8I9PSF9yNU1cJeqnzmzv5IHZCI7rfn3zXEfIF1jRXGPai7v2kUR1bnfjrxdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAReV+7cr4VX0SnjItU37Fy1XMxTXTNMzHn4gzHZbKsY3evb3aLfV066p1vzaTHyrGRMxYu0XJjz6Z3pVfo3h/tMj+aP6JnG8XZ4+uuqzVcqmuNT1zE/kCk5z9YLH+j6tUgZfFWMrMoybld2LlOtRTMa8P8AJPBlY/W3/c/4tUgfZVj7R7713fa76tbjXlr0TwZGmqMDtNVVenpo9pVO/wAKonX1fe0V+jNz7FrGqi5qOndM7iZmf/F/yXGY+fqbsVU10+EV0+evRy4/hsbCu+1p6rlyPKavd+4HXlaYo4jIpjyi3pA7I/4O/wDE/KFzk2acjHuWa5mKa41Mx5uHHYFrj7VVFmquqKp6p65ifyBLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB//2Q==`\n\nvar placeholder, _ = ioutil.ReadAll(base64.NewDecoder(base64.StdEncoding, strings.NewReader(placeholderData)))\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 3.6689453125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype ServerOptions struct {\n\tPort               int\n\tBurst              int\n\tConcurrency        int\n\tHTTPCacheTTL       int\n\tHTTPReadTimeout    int\n\tHTTPWriteTimeout   int\n\tMaxAllowedSize     int\n\tMaxAllowedPixels   float64\n\tCORS               bool\n\tGzip               bool // deprecated\n\tAuthForwarding     bool\n\tEnableURLSource    bool\n\tEnablePlaceholder  bool\n\tEnableURLSignature bool\n\tURLSignatureKey    string\n\tAddress            string\n\tPathPrefix         string\n\tAPIKey             string\n\tMount              string\n\tCertFile           string\n\tKeyFile            string\n\tAuthorization      string\n\tPlaceholder        string\n\tPlaceholderStatus  int\n\tForwardHeaders     []string\n\tPlaceholderImage   []byte\n\tEndpoints          Endpoints\n\tAllowedOrigins     []*url.URL\n\tLogLevel           string\n\tReturnSize         bool\n}\n\n// Endpoints represents a list of endpoint names to disable.\ntype Endpoints []string\n\n// IsValid validates if a given HTTP request endpoint is valid or not.\nfunc (e Endpoints) IsValid(r *http.Request) bool {\n\tparts := strings.Split(r.URL.Path, \"/\")\n\tendpoint := parts[len(parts)-1]\n\tfor _, name := range e {\n\t\tif endpoint == name {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc Server(o ServerOptions) {\n\taddr := o.Address + \":\" + strconv.Itoa(o.Port)\n\thandler := NewLog(NewServerMux(o), os.Stdout, o.LogLevel)\n\n\tserver := &http.Server{\n\t\tAddr:           addr,\n\t\tHandler:        handler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t\tReadTimeout:    time.Duration(o.HTTPReadTimeout) * time.Second,\n\t\tWriteTimeout:   time.Duration(o.HTTPWriteTimeout) * time.Second,\n\t}\n\n\tdone := make(chan os.Signal, 1)\n\tsignal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tif err := listenAndServe(server, o); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t<-done\n\tlog.Print(\"Graceful shutdown\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer func() {\n\t\t// extra handling here\n\t\tcancel()\n\t}()\n\n\tif err := server.Shutdown(ctx); err != nil {\n\t\tlog.Fatalf(\"Server Shutdown Failed:%+v\", err)\n\t}\n}\n\nfunc listenAndServe(s *http.Server, o ServerOptions) error {\n\tif o.CertFile != \"\" && o.KeyFile != \"\" {\n\t\treturn s.ListenAndServeTLS(o.CertFile, o.KeyFile)\n\t}\n\treturn s.ListenAndServe()\n}\n\nfunc join(o ServerOptions, route string) string {\n\treturn path.Join(o.PathPrefix, route)\n}\n\n// NewServerMux creates a new HTTP server route multiplexer.\nfunc NewServerMux(o ServerOptions) http.Handler {\n\tmux := http.NewServeMux()\n\n\tmux.Handle(join(o, \"/\"), Middleware(indexController(o), o))\n\tmux.Handle(join(o, \"/form\"), Middleware(formController(o), o))\n\tmux.Handle(join(o, \"/health\"), Middleware(healthController, o))\n\n\timage := ImageMiddleware(o)\n\tmux.Handle(join(o, \"/resize\"), image(Resize))\n\tmux.Handle(join(o, \"/fit\"), image(Fit))\n\tmux.Handle(join(o, \"/enlarge\"), image(Enlarge))\n\tmux.Handle(join(o, \"/extract\"), image(Extract))\n\tmux.Handle(join(o, \"/crop\"), image(Crop))\n\tmux.Handle(join(o, \"/smartcrop\"), image(SmartCrop))\n\tmux.Handle(join(o, \"/rotate\"), image(Rotate))\n\tmux.Handle(join(o, \"/autorotate\"), image(AutoRotate))\n\tmux.Handle(join(o, \"/flip\"), image(Flip))\n\tmux.Handle(join(o, \"/flop\"), image(Flop))\n\tmux.Handle(join(o, \"/thumbnail\"), image(Thumbnail))\n\tmux.Handle(join(o, \"/zoom\"), image(Zoom))\n\tmux.Handle(join(o, \"/convert\"), image(Convert))\n\tmux.Handle(join(o, \"/watermark\"), image(Watermark))\n\tmux.Handle(join(o, \"/watermarkimage\"), image(WatermarkImage))\n\tmux.Handle(join(o, \"/info\"), image(Info))\n\tmux.Handle(join(o, \"/blur\"), image(GaussianBlur))\n\tmux.Handle(join(o, \"/pipeline\"), image(Pipeline))\n\n\treturn mux\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 9.32421875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nfunc TestIndex(t *testing.T) {\n\topts := ServerOptions{PathPrefix: \"/\", MaxAllowedPixels: 18.0}\n\tts := testServer(indexController(opts))\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif strings.Contains(string(body), \"imaginary\") == false {\n\t\tt.Fatalf(\"Invalid body response: %s\", body)\n\t}\n}\n\nfunc TestCrop(t *testing.T) {\n\tts := testServer(controller(Crop))\n\tbuf := readFile(\"large.jpg\")\n\turl := ts.URL + \"?width=300\"\n\tdefer ts.Close()\n\n\tres, err := http.Post(url, \"image/jpeg\", buf)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\tif res.Header.Get(\"Content-Length\") == \"\" {\n\t\tt.Fatal(\"Empty content length response\")\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 300, 1080)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestResize(t *testing.T) {\n\tts := testServer(controller(Resize))\n\tbuf := readFile(\"large.jpg\")\n\turl := ts.URL + \"?width=300&nocrop=false\"\n\tdefer ts.Close()\n\n\tres, err := http.Post(url, \"image/jpeg\", buf)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 300, 1080)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestEnlarge(t *testing.T) {\n\tts := testServer(controller(Enlarge))\n\tbuf := readFile(\"large.jpg\")\n\turl := ts.URL + \"?width=300&height=200\"\n\tdefer ts.Close()\n\n\tres, err := http.Post(url, \"image/jpeg\", buf)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 300, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestExtract(t *testing.T) {\n\tts := testServer(controller(Extract))\n\tbuf := readFile(\"large.jpg\")\n\turl := ts.URL + \"?top=100&left=100&areawidth=200&areaheight=120\"\n\tdefer ts.Close()\n\n\tres, err := http.Post(url, \"image/jpeg\", buf)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 200, 120)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestTypeAuto(t *testing.T) {\n\tcases := []struct {\n\t\tacceptHeader string\n\t\texpected     string\n\t}{\n\t\t{\"\", \"jpeg\"},\n\t\t{\"image/webp,*/*\", \"webp\"},\n\t\t{\"image/png,*/*\", \"png\"},\n\t\t{\"image/webp;q=0.8,image/jpeg\", \"webp\"},\n\t\t{\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\", \"webp\"}, // Chrome\n\t}\n\n\tfor _, test := range cases {\n\t\tts := testServer(controller(Crop))\n\t\tbuf := readFile(\"large.jpg\")\n\t\turl := ts.URL + \"?width=300&type=auto\"\n\t\tdefer ts.Close()\n\n\t\treq, _ := http.NewRequest(http.MethodPost, url, buf)\n\t\treq.Header.Add(\"Content-Type\", \"image/jpeg\")\n\t\treq.Header.Add(\"Accept\", test.acceptHeader)\n\t\tres, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Cannot perform the request\")\n\t\t}\n\n\t\tif res.StatusCode != 200 {\n\t\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t\t}\n\n\t\tif res.Header.Get(\"Content-Length\") == \"\" {\n\t\t\tt.Fatal(\"Empty content length response\")\n\t\t}\n\n\t\timage, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(image) == 0 {\n\t\t\tt.Fatalf(\"Empty response body\")\n\t\t}\n\n\t\terr = assertSize(image, 300, 1080)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tif bimg.DetermineImageTypeName(image) != test.expected {\n\t\t\tt.Fatalf(\"Invalid image type\")\n\t\t}\n\n\t\tif res.Header.Get(\"Vary\") != \"Accept\" {\n\t\t\tt.Fatal(\"Vary header not set correctly\")\n\t\t}\n\t}\n}\n\nfunc TestFit(t *testing.T) {\n\tvar err error\n\n\tbuf := readFile(\"large.jpg\")\n\toriginal, _ := ioutil.ReadAll(buf)\n\terr = assertSize(original, 1920, 1080)\n\tif err != nil {\n\t\tt.Errorf(\"Reference image expecations weren't met\")\n\t}\n\n\tts := testServer(controller(Fit))\n\turl := ts.URL + \"?width=300&height=300\"\n\tdefer ts.Close()\n\n\tres, err := http.Post(url, \"image/jpeg\", bytes.NewReader(original))\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\t// The reference image has a ratio of 1.778, this should produce a height of 168.75\n\terr = assertSize(image, 300, 169)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestRemoteHTTPSource(t *testing.T) {\n\topts := ServerOptions{EnableURLSource: true, MaxAllowedPixels: 18.0}\n\tfn := ImageMiddleware(opts)(Crop)\n\tLoadSources(opts)\n\n\ttsImage := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tbuf, _ := ioutil.ReadFile(\"testdata/large.jpg\")\n\t\t_, _ = w.Write(buf)\n\t}))\n\tdefer tsImage.Close()\n\n\tts := httptest.NewServer(fn)\n\turl := ts.URL + \"?width=200&height=200&url=\" + tsImage.URL\n\tdefer ts.Close()\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %d\", res.StatusCode)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 200, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestInvalidRemoteHTTPSource(t *testing.T) {\n\topts := ServerOptions{EnableURLSource: true, MaxAllowedPixels: 18.0}\n\tfn := ImageMiddleware(opts)(Crop)\n\tLoadSources(opts)\n\n\ttsImage := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tw.WriteHeader(400)\n\t}))\n\tdefer tsImage.Close()\n\n\tts := httptest.NewServer(fn)\n\turl := ts.URL + \"?width=200&height=200&url=\" + tsImage.URL\n\tdefer ts.Close()\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tt.Fatal(\"Request failed\")\n\t}\n\tif res.StatusCode != 400 {\n\t\tt.Fatalf(\"Invalid response status: %d\", res.StatusCode)\n\t}\n}\n\nfunc TestMountDirectory(t *testing.T) {\n\topts := ServerOptions{Mount: \"testdata\", MaxAllowedPixels: 18.0}\n\tfn := ImageMiddleware(opts)(Crop)\n\tLoadSources(opts)\n\n\tts := httptest.NewServer(fn)\n\turl := ts.URL + \"?width=200&height=200&file=large.jpg\"\n\tdefer ts.Close()\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\tif res.StatusCode != 200 {\n\t\tt.Fatalf(\"Invalid response status: %d\", res.StatusCode)\n\t}\n\n\timage, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(image) == 0 {\n\t\tt.Fatalf(\"Empty response body\")\n\t}\n\n\terr = assertSize(image, 200, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif bimg.DetermineImageTypeName(image) != \"jpeg\" {\n\t\tt.Fatalf(\"Invalid image type\")\n\t}\n}\n\nfunc TestMountInvalidDirectory(t *testing.T) {\n\tfn := ImageMiddleware(ServerOptions{Mount: \"_invalid_\", MaxAllowedPixels: 18.0})(Crop)\n\tts := httptest.NewServer(fn)\n\turl := ts.URL + \"?top=100&left=100&areawidth=200&areaheight=120&file=large.jpg\"\n\tdefer ts.Close()\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 400 {\n\t\tt.Fatalf(\"Invalid response status: %d\", res.StatusCode)\n\t}\n}\n\nfunc TestMountInvalidPath(t *testing.T) {\n\tfn := ImageMiddleware(ServerOptions{Mount: \"_invalid_\"})(Crop)\n\tts := httptest.NewServer(fn)\n\turl := ts.URL + \"?top=100&left=100&areawidth=200&areaheight=120&file=../../large.jpg\"\n\tdefer ts.Close()\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot perform the request\")\n\t}\n\n\tif res.StatusCode != 400 {\n\t\tt.Fatalf(\"Invalid response status: %s\", res.Status)\n\t}\n}\n\nfunc controller(op Operation) func(w http.ResponseWriter, r *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tbuf, _ := ioutil.ReadAll(r.Body)\n\t\timageHandler(w, r, buf, op, ServerOptions{MaxAllowedPixels: 18.0})\n\t}\n}\n\nfunc testServer(fn func(w http.ResponseWriter, r *http.Request)) *httptest.Server {\n\treturn httptest.NewServer(http.HandlerFunc(fn))\n}\n\nfunc readFile(file string) io.Reader {\n\tbuf, _ := os.Open(path.Join(\"testdata\", file))\n\treturn buf\n}\n\nfunc assertSize(buf []byte, width, height int) error {\n\tsize, err := bimg.NewImage(buf).Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size.Width != width || size.Height != height {\n\t\treturn fmt.Errorf(\"invalid image size: %dx%d, expected: %dx%d\", size.Width, size.Height, width, height)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "source.go",
          "type": "blob",
          "size": 1.23046875,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype ImageSourceType string\ntype ImageSourceFactoryFunction func(*SourceConfig) ImageSource\n\ntype SourceConfig struct {\n\tAuthForwarding bool\n\tAuthorization  string\n\tMountPath      string\n\tType           ImageSourceType\n\tForwardHeaders []string\n\tAllowedOrigins []*url.URL\n\tMaxAllowedSize int\n}\n\nvar imageSourceMap = make(map[ImageSourceType]ImageSource)\nvar imageSourceFactoryMap = make(map[ImageSourceType]ImageSourceFactoryFunction)\n\ntype ImageSource interface {\n\tMatches(*http.Request) bool\n\tGetImage(*http.Request) ([]byte, error)\n}\n\nfunc RegisterSource(sourceType ImageSourceType, factory ImageSourceFactoryFunction) {\n\timageSourceFactoryMap[sourceType] = factory\n}\n\nfunc LoadSources(o ServerOptions) {\n\tfor name, factory := range imageSourceFactoryMap {\n\t\timageSourceMap[name] = factory(&SourceConfig{\n\t\t\tType:           name,\n\t\t\tMountPath:      o.Mount,\n\t\t\tAuthForwarding: o.AuthForwarding,\n\t\t\tAuthorization:  o.Authorization,\n\t\t\tAllowedOrigins: o.AllowedOrigins,\n\t\t\tMaxAllowedSize: o.MaxAllowedSize,\n\t\t\tForwardHeaders: o.ForwardHeaders,\n\t\t})\n\t}\n}\n\nfunc MatchSource(req *http.Request) ImageSource {\n\tfor _, source := range imageSourceMap {\n\t\tif source.Matches(req) {\n\t\t\treturn source\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "source_body.go",
          "type": "blob",
          "size": 1.1865234375,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nconst formFieldName = \"file\"\nconst maxMemory int64 = 1024 * 1024 * 64\n\nconst ImageSourceTypeBody ImageSourceType = \"payload\"\n\ntype BodyImageSource struct {\n\tConfig *SourceConfig\n}\n\nfunc NewBodyImageSource(config *SourceConfig) ImageSource {\n\treturn &BodyImageSource{config}\n}\n\nfunc (s *BodyImageSource) Matches(r *http.Request) bool {\n\treturn r.Method == http.MethodPost || r.Method == http.MethodPut\n}\n\nfunc (s *BodyImageSource) GetImage(r *http.Request) ([]byte, error) {\n\tif isFormBody(r) {\n\t\treturn readFormBody(r)\n\t}\n\treturn readRawBody(r)\n}\n\nfunc isFormBody(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(\"Content-Type\"), \"multipart/\")\n}\n\nfunc readFormBody(r *http.Request) ([]byte, error) {\n\terr := r.ParseMultipartForm(maxMemory)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfile, _, err := r.FormFile(formFieldName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tbuf, err := ioutil.ReadAll(file)\n\tif len(buf) == 0 {\n\t\terr = ErrEmptyBody\n\t}\n\n\treturn buf, err\n}\n\nfunc readRawBody(r *http.Request) ([]byte, error) {\n\treturn ioutil.ReadAll(r.Body)\n}\n\nfunc init() {\n\tRegisterSource(ImageSourceTypeBody, NewBodyImageSource)\n}\n"
        },
        {
          "name": "source_body_test.go",
          "type": "blob",
          "size": 1.634765625,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n)\n\nconst fixtureFile = \"testdata/large.jpg\"\n\nfunc TestSourceBodyMatch(t *testing.T) {\n\tu, _ := url.Parse(\"http://foo\")\n\treq := &http.Request{Method: http.MethodPost, URL: u}\n\tsource := NewBodyImageSource(&SourceConfig{})\n\n\tif !source.Matches(req) {\n\t\tt.Error(\"Cannot match the request\")\n\t}\n}\n\nfunc TestBodyImageSource(t *testing.T) {\n\tvar body []byte\n\tvar err error\n\n\tsource := NewBodyImageSource(&SourceConfig{})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err = source.GetImage(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error while reading the body: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\t}\n\n\tfile, _ := os.Open(fixtureFile)\n\tr, _ := http.NewRequest(http.MethodPost, \"http://foo/bar\", file)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n\n\tbuf, _ := ioutil.ReadFile(fixtureFile)\n\tif len(body) != len(buf) {\n\t\tt.Error(\"Invalid response body\")\n\t}\n}\n\nfunc testReadBody(t *testing.T) {\n\tvar body []byte\n\tvar err error\n\n\tsource := NewBodyImageSource(&SourceConfig{})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err = source.GetImage(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error while reading the body: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\t}\n\n\tfile, _ := os.Open(fixtureFile)\n\tr, _ := http.NewRequest(http.MethodPost, \"http://foo/bar\", file)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n\n\tbuf, _ := ioutil.ReadFile(fixtureFile)\n\tif len(body) != len(buf) {\n\t\tt.Error(\"Invalid response body\")\n\t}\n}\n"
        },
        {
          "name": "source_fs.go",
          "type": "blob",
          "size": 1.5087890625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strings\"\n)\n\nconst ImageSourceTypeFileSystem ImageSourceType = \"fs\"\n\ntype FileSystemImageSource struct {\n\tConfig *SourceConfig\n}\n\nfunc NewFileSystemImageSource(config *SourceConfig) ImageSource {\n\treturn &FileSystemImageSource{config}\n}\n\nfunc (s *FileSystemImageSource) Matches(r *http.Request) bool {\n\tfile, err := s.getFileParam(r)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn r.Method == http.MethodGet && file != \"\"\n}\n\nfunc (s *FileSystemImageSource) GetImage(r *http.Request) ([]byte, error) {\n\tfile, err := s.getFileParam(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif file == \"\" {\n\t\treturn nil, ErrMissingParamFile\n\t}\n\n\tfile, err = s.buildPath(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.read(file)\n}\n\nfunc (s *FileSystemImageSource) buildPath(file string) (string, error) {\n\tfile = path.Clean(path.Join(s.Config.MountPath, file))\n\tif !strings.HasPrefix(file, s.Config.MountPath) {\n\t\treturn \"\", ErrInvalidFilePath\n\t}\n\treturn file, nil\n}\n\nfunc (s *FileSystemImageSource) read(file string) ([]byte, error) {\n\tbuf, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, ErrInvalidFilePath\n\t}\n\treturn buf, nil\n}\n\nfunc (s *FileSystemImageSource) getFileParam(r *http.Request) (string, error) {\n\tunescaped, err := url.QueryUnescape(r.URL.Query().Get(\"file\"))\n\tif err != nil{\n\t\treturn \"\", fmt.Errorf(\"failed to unescape file param: %w\", err)\n\t}\n\n\treturn unescaped, nil\n}\n\nfunc init() {\n\tRegisterSource(ImageSourceTypeFileSystem, NewFileSystemImageSource)\n}\n"
        },
        {
          "name": "source_fs_test.go",
          "type": "blob",
          "size": 0.8173828125,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestFileSystemImageSource(t *testing.T) {\n\tvar body []byte\n\tvar err error\n\tconst fixtureFile = \"testdata/large image.jpg\"\n\n\tsource := NewFileSystemImageSource(&SourceConfig{MountPath: \"testdata\"})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err = source.GetImage(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error while reading the body: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\t}\n\n\tfile, _ := os.Open(fixtureFile)\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?file=large%20image.jpg\", file)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n\n\tbuf, _ := ioutil.ReadFile(fixtureFile)\n\tif len(body) != len(buf) {\n\t\tt.Error(\"Invalid response body\")\n\t}\n}\n"
        },
        {
          "name": "source_http.go",
          "type": "blob",
          "size": 4.0771484375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst ImageSourceTypeHTTP ImageSourceType = \"http\"\nconst URLQueryKey = \"url\"\n\ntype HTTPImageSource struct {\n\tConfig *SourceConfig\n}\n\nfunc NewHTTPImageSource(config *SourceConfig) ImageSource {\n\treturn &HTTPImageSource{config}\n}\n\nfunc (s *HTTPImageSource) Matches(r *http.Request) bool {\n\treturn r.Method == http.MethodGet && r.URL.Query().Get(URLQueryKey) != \"\"\n}\n\nfunc (s *HTTPImageSource) GetImage(req *http.Request) ([]byte, error) {\n\tu, err := parseURL(req)\n\tif err != nil {\n\t\treturn nil, ErrInvalidImageURL\n\t}\n\tif shouldRestrictOrigin(u, s.Config.AllowedOrigins) {\n\t\treturn nil, fmt.Errorf(\"not allowed remote URL origin: %s%s\", u.Host, u.Path)\n\t}\n\treturn s.fetchImage(u, req)\n}\n\nfunc (s *HTTPImageSource) fetchImage(url *url.URL, ireq *http.Request) ([]byte, error) {\n\t// Check remote image size by fetching HTTP Headers\n\tif s.Config.MaxAllowedSize > 0 {\n\t\treq := newHTTPRequest(s, ireq, http.MethodHead, url)\n\t\tres, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error fetching remote http image headers: %v\", err)\n\t\t}\n\t\t_ = res.Body.Close()\n\t\tif res.StatusCode < 200 && res.StatusCode > 206 {\n\t\t\treturn nil, NewError(fmt.Sprintf(\"error fetching remote http image headers: (status=%d) (url=%s)\", res.StatusCode, req.URL.String()), res.StatusCode)\n\t\t}\n\n\t\tcontentLength, _ := strconv.Atoi(res.Header.Get(\"Content-Length\"))\n\t\tif contentLength > s.Config.MaxAllowedSize {\n\t\t\treturn nil, fmt.Errorf(\"Content-Length %d exceeds maximum allowed %d bytes\", contentLength, s.Config.MaxAllowedSize)\n\t\t}\n\t}\n\n\t// Perform the request using the default client\n\treq := newHTTPRequest(s, ireq, http.MethodGet, url)\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error fetching remote http image: %v\", err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != 200 {\n\t\treturn nil, NewError(fmt.Sprintf(\"error fetching remote http image: (status=%d) (url=%s)\", res.StatusCode, req.URL.String()), res.StatusCode)\n\t}\n\n\t// Read the body\n\tbuf, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create image from response body: %s (url=%s)\", req.URL.String(), err)\n\t}\n\treturn buf, nil\n}\n\nfunc (s *HTTPImageSource) setAuthorizationHeader(req *http.Request, ireq *http.Request) {\n\tauth := s.Config.Authorization\n\tif auth == \"\" {\n\t\tauth = ireq.Header.Get(\"X-Forward-Authorization\")\n\t}\n\tif auth == \"\" {\n\t\tauth = ireq.Header.Get(\"Authorization\")\n\t}\n\tif auth != \"\" {\n\t\treq.Header.Set(\"Authorization\", auth)\n\t}\n}\n\nfunc (s *HTTPImageSource) setForwardHeaders(req *http.Request, ireq *http.Request) {\n\theaders := s.Config.ForwardHeaders\n\tfor _, header := range headers {\n\t\tif _, ok := ireq.Header[header]; ok {\n\t\t\treq.Header.Set(header, ireq.Header.Get(header))\n\t\t}\n\t}\n}\n\nfunc parseURL(request *http.Request) (*url.URL, error) {\n\treturn url.Parse(request.URL.Query().Get(URLQueryKey))\n}\n\nfunc newHTTPRequest(s *HTTPImageSource, ireq *http.Request, method string, url *url.URL) *http.Request {\n\treq, _ := http.NewRequest(method, url.String(), nil)\n\treq.Header.Set(\"User-Agent\", \"imaginary/\"+Version)\n\treq.URL = url\n\n\tif len(s.Config.ForwardHeaders) != 0 {\n\t\ts.setForwardHeaders(req, ireq)\n\t}\n\n\t// Forward auth header to the target server, if necessary\n\tif s.Config.AuthForwarding || s.Config.Authorization != \"\" {\n\t\ts.setAuthorizationHeader(req, ireq)\n\t}\n\n\treturn req\n}\n\nfunc shouldRestrictOrigin(url *url.URL, origins []*url.URL) bool {\n\tif len(origins) == 0 {\n\t\treturn false\n\t}\n\n\tfor _, origin := range origins {\n\t\tif origin.Host == url.Host {\n\t\t\tif strings.HasPrefix(url.Path, origin.Path) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif origin.Host[0:2] == \"*.\" {\n\t\t\t// Testing if \"*.example.org\" matches \"example.org\"\n\t\t\tif url.Host == origin.Host[2:] {\n\t\t\t\tif strings.HasPrefix(url.Path, origin.Path) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Testing if \"*.example.org\" matches \"foo.example.org\"\n\t\t\tif strings.HasSuffix(url.Host, origin.Host[1:]) {\n\t\t\t\tif strings.HasPrefix(url.Path, origin.Path) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc init() {\n\tRegisterSource(ImageSourceTypeHTTP, NewHTTPImageSource)\n}\n"
        },
        {
          "name": "source_http_test.go",
          "type": "blob",
          "size": 13.6435546875,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nconst fixtureImage = \"testdata/large.jpg\"\nconst fixture1024Bytes = \"testdata/1024bytes\"\n\nfunc TestHttpImageSource(t *testing.T) {\n\tvar body []byte\n\tvar err error\n\n\tbuf, _ := ioutil.ReadFile(fixtureImage)\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, _ = w.Write(buf)\n\t}))\n\tdefer ts.Close()\n\n\tsource := NewHTTPImageSource(&SourceConfig{})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err = source.GetImage(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error while reading the body: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\t}\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+ts.URL, nil)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n\n\tif len(body) != len(buf) {\n\t\tt.Error(\"Invalid response body\")\n\t}\n}\n\nfunc TestHttpImageSourceAllowedOrigin(t *testing.T) {\n\tbuf, _ := ioutil.ReadFile(fixtureImage)\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, _ = w.Write(buf)\n\t}))\n\tdefer ts.Close()\n\n\torigin, _ := url.Parse(ts.URL)\n\torigins := []*url.URL{origin}\n\tsource := NewHTTPImageSource(&SourceConfig{AllowedOrigins: origins})\n\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err := source.GetImage(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error while reading the body: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\n\t\tif len(body) != len(buf) {\n\t\t\tt.Error(\"Invalid response body length\")\n\t\t}\n\t}\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+ts.URL, nil)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n}\n\nfunc TestHttpImageSourceNotAllowedOrigin(t *testing.T) {\n\torigin, _ := url.Parse(\"http://foo\")\n\torigins := []*url.URL{origin}\n\tsource := NewHTTPImageSource(&SourceConfig{AllowedOrigins: origins})\n\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\t_, err := source.GetImage(r)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Error cannot be empty\")\n\t\t}\n\n\t\tif err.Error() != \"not allowed remote URL origin: bar.com\" {\n\t\t\tt.Fatalf(\"Invalid error message: %s\", err)\n\t\t}\n\t}\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=http://bar.com\", nil)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n}\n\nfunc TestHttpImageSourceForwardAuthHeader(t *testing.T) {\n\tcases := []string{\n\t\t\"X-Forward-Authorization\",\n\t\t\"Authorization\",\n\t}\n\n\tfor _, header := range cases {\n\t\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=http://bar.com\", nil)\n\t\tr.Header.Set(header, \"foobar\")\n\n\t\tsource := &HTTPImageSource{&SourceConfig{AuthForwarding: true}}\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\toreq := &http.Request{Header: make(http.Header)}\n\t\tsource.setAuthorizationHeader(oreq, r)\n\n\t\tif oreq.Header.Get(\"Authorization\") != \"foobar\" {\n\t\t\tt.Fatal(\"Mismatch Authorization header\")\n\t\t}\n\t}\n}\n\nfunc TestHttpImageSourceForwardHeaders(t *testing.T) {\n\tcases := []string{\n\t\t\"X-Custom\",\n\t\t\"X-Token\",\n\t}\n\n\tfor _, header := range cases {\n\t\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=http://bar.com\", nil)\n\t\tr.Header.Set(header, \"foobar\")\n\n\t\tsource := &HTTPImageSource{&SourceConfig{ForwardHeaders: cases}}\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\toreq := &http.Request{Header: make(http.Header)}\n\t\tsource.setForwardHeaders(oreq, r)\n\n\t\tif oreq.Header.Get(header) != \"foobar\" {\n\t\t\tt.Fatal(\"Mismatch custom header\")\n\t\t}\n\t}\n}\n\nfunc TestHttpImageSourceNotForwardHeaders(t *testing.T) {\n\tcases := []string{\n\t\t\"X-Custom\",\n\t\t\"X-Token\",\n\t}\n\n\ttestURL := createURL(\"http://bar.com\", t)\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+testURL.String(), nil)\n\tr.Header.Set(\"Not-Forward\", \"foobar\")\n\n\tsource := &HTTPImageSource{&SourceConfig{ForwardHeaders: cases}}\n\tif !source.Matches(r) {\n\t\tt.Fatal(\"Cannot match the request\")\n\t}\n\n\toreq := newHTTPRequest(source, r, http.MethodGet, testURL)\n\n\tif oreq.Header.Get(\"Not-Forward\") != \"\" {\n\t\tt.Fatal(\"Forwarded unspecified header\")\n\t}\n}\n\nfunc TestHttpImageSourceForwardedHeadersNotOverride(t *testing.T) {\n\tcases := []string{\n\t\t\"Authorization\",\n\t\t\"X-Custom\",\n\t}\n\n\ttestURL := createURL(\"http://bar.com\", t)\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+testURL.String(), nil)\n\tr.Header.Set(\"Authorization\", \"foobar\")\n\n\tsource := &HTTPImageSource{&SourceConfig{Authorization: \"ValidAPIKey\", ForwardHeaders: cases}}\n\tif !source.Matches(r) {\n\t\tt.Fatal(\"Cannot match the request\")\n\t}\n\n\toreq := newHTTPRequest(source, r, http.MethodGet, testURL)\n\n\tif oreq.Header.Get(\"Authorization\") != \"ValidAPIKey\" {\n\t\tt.Fatal(\"Authorization header override\")\n\t}\n}\n\nfunc TestHttpImageSourceCaseSensitivityInForwardedHeaders(t *testing.T) {\n\tcases := []string{\n\t\t\"X-Custom\",\n\t\t\"X-Token\",\n\t}\n\n\ttestURL := createURL(\"http://bar.com\", t)\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+testURL.String(), nil)\n\tr.Header.Set(\"x-custom\", \"foobar\")\n\n\tsource := &HTTPImageSource{&SourceConfig{ForwardHeaders: cases}}\n\tif !source.Matches(r) {\n\t\tt.Fatal(\"Cannot match the request\")\n\t}\n\n\toreq := newHTTPRequest(source, r, http.MethodGet, testURL)\n\n\tif oreq.Header.Get(\"X-Custom\") == \"\" {\n\t\tt.Fatal(\"Case sensitive not working on forwarded headers\")\n\t}\n}\n\nfunc TestHttpImageSourceEmptyForwardedHeaders(t *testing.T) {\n\tvar cases []string\n\n\ttestURL := createURL(\"http://bar.com\", t)\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+testURL.String(), nil)\n\n\tsource := &HTTPImageSource{&SourceConfig{ForwardHeaders: cases}}\n\tif !source.Matches(r) {\n\t\tt.Fatal(\"Cannot match the request\")\n\t}\n\n\tif len(source.Config.ForwardHeaders) != 0 {\n\t\tt.Log(source.Config.ForwardHeaders)\n\t\tt.Fatal(\"Set empty custom header\")\n\t}\n\n\toreq := newHTTPRequest(source, r, http.MethodGet, testURL)\n\n\tif oreq == nil {\n\t\tt.Fatal(\"Error creating request using empty custom headers\")\n\t}\n}\n\nfunc TestHttpImageSourceError(t *testing.T) {\n\tvar err error\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(404)\n\t\t_, _ = w.Write([]byte(\"Not found\"))\n\t}))\n\tdefer ts.Close()\n\n\tsource := NewHTTPImageSource(&SourceConfig{})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\t_, err = source.GetImage(r)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Server response should not be valid: %s\", err)\n\t\t}\n\t}\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+ts.URL, nil)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n}\n\nfunc TestHttpImageSourceExceedsMaximumAllowedLength(t *testing.T) {\n\tvar body []byte\n\tvar err error\n\n\tbuf, _ := ioutil.ReadFile(fixture1024Bytes)\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, _ = w.Write(buf)\n\t}))\n\tdefer ts.Close()\n\n\tsource := NewHTTPImageSource(&SourceConfig{\n\t\tMaxAllowedSize: 1023,\n\t})\n\tfakeHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif !source.Matches(r) {\n\t\t\tt.Fatal(\"Cannot match the request\")\n\t\t}\n\n\t\tbody, err = source.GetImage(r)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"It should not allow a request to image exceeding maximum allowed size: %s\", err)\n\t\t}\n\t\t_, _ = w.Write(body)\n\t}\n\n\tr, _ := http.NewRequest(http.MethodGet, \"http://foo/bar?url=\"+ts.URL, nil)\n\tw := httptest.NewRecorder()\n\tfakeHandler(w, r)\n}\n\nfunc TestShouldRestrictOrigin(t *testing.T) {\n\tplainOrigins := parseOrigins(\n\t\t\"https://example.org\",\n\t)\n\n\twildCardOrigins := parseOrigins(\n\t\t\"https://localhost,https://*.example.org,https://some.s3.bucket.on.aws.org,https://*.s3.bucket.on.aws.org\",\n\t)\n\n\twithPathOrigins := parseOrigins(\n\t\t\"https://localhost/foo/bar/,https://*.example.org/foo/,https://some.s3.bucket.on.aws.org/my/bucket/,\" +\n\t\t\t\"https://*.s3.bucket.on.aws.org/my/bucket/,https://no-leading-path-slash.example.org/assets\",\n\t)\n\n\twith2Buckets := parseOrigins(\n\t\t\"https://some.s3.bucket.on.aws.org/my/bucket1/,https://some.s3.bucket.on.aws.org/my/bucket2/\",\n\t)\n\n\tpathWildCard := parseOrigins(\n\t\t\"https://some.s3.bucket.on.aws.org/my-bucket-name*\",\n\t)\n\n\tt.Run(\"Plain origin\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://example.org/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, plainOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, plainOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin, plain URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://example.org/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, wildCardOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, wildCardOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin, sub domain URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://node-42.example.org/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, wildCardOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, wildCardOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin, sub-sub domain URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://n.s3.bucket.on.aws.org/our/bucket/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, wildCardOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, wildCardOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin, incorrect domain URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://myexample.org/logo.jpg\", t)\n\n\t\tif !shouldRestrictOrigin(testURL, plainOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to not be allowed with plain origins: %+v\", testURL, plainOrigins)\n\t\t}\n\n\t\tif !shouldRestrictOrigin(testURL, wildCardOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to not be allowed with wildcard origins: %+v\", testURL, wildCardOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Loopback origin with path, correct URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://localhost/foo/bar/logo.png\", t)\n\n\t\tif shouldRestrictOrigin(testURL, withPathOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin with path, correct URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://our.company.s3.bucket.on.aws.org/my/bucket/logo.gif\", t)\n\n\t\tif shouldRestrictOrigin(testURL, withPathOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin with partial path, correct URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://our.company.s3.bucket.on.aws.org/my/bucket/a/b/c/d/e/logo.gif\", t)\n\n\t\tif shouldRestrictOrigin(testURL, withPathOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin with partial path, correct URL double slashes\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://static.example.org/foo//a//b//c/d/e/logo.webp\", t)\n\n\t\tif shouldRestrictOrigin(testURL, withPathOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Wildcard origin with path missing trailing slash, correct URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://no-leading-path-slash.example.org/assets/logo.webp\", t)\n\n\t\tif shouldRestrictOrigin(testURL, parseOrigins(\"https://*.example.org/assets\")) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"Loopback origin with path, incorrect URL\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://localhost/wrong/logo.png\", t)\n\n\t\tif !shouldRestrictOrigin(testURL, withPathOrigins) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, withPathOrigins)\n\t\t}\n\t})\n\n\tt.Run(\"2 buckets, bucket1\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://some.s3.bucket.on.aws.org/my/bucket1/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, with2Buckets) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, with2Buckets)\n\t\t}\n\t})\n\n\tt.Run(\"2 buckets, bucket2\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://some.s3.bucket.on.aws.org/my/bucket2/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, with2Buckets) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, with2Buckets)\n\t\t}\n\t})\n\n\tt.Run(\"Path wildcard\", func(t *testing.T) {\n\t\ttestURL := createURL(\"https://some.s3.bucket.on.aws.org/my-bucket-name/logo.jpg\", t)\n\t\ttestURLFail := createURL(\"https://some.s3.bucket.on.aws.org/my-other-bucket-name/logo.jpg\", t)\n\n\t\tif shouldRestrictOrigin(testURL, pathWildCard) {\n\t\t\tt.Errorf(\"Expected '%s' to be allowed with origins: %+v\", testURL, pathWildCard)\n\t\t}\n\n\t\tif !shouldRestrictOrigin(testURLFail, pathWildCard) {\n\t\t\tt.Errorf(\"Expected '%s' to be restricted with origins: %+v\", testURLFail, pathWildCard)\n\t\t}\n\t})\n\n}\n\nfunc TestParseOrigins(t *testing.T) {\n\tt.Run(\"Appending a trailing slash on paths\", func(t *testing.T) {\n\t\torigins := parseOrigins(\"http://foo.example.org/assets\")\n\t\tif origins[0].Path != \"/assets/\" {\n\t\t\tt.Errorf(\"Expected the path to have a trailing /, instead it was: %q\", origins[0].Path)\n\t\t}\n\t})\n\n\tt.Run(\"Paths should not receive multiple trailing slashes\", func(t *testing.T) {\n\t\torigins := parseOrigins(\"http://foo.example.org/assets/\")\n\t\tif origins[0].Path != \"/assets/\" {\n\t\t\tt.Errorf(\"Expected the path to have a single trailing /, instead it was: %q\", origins[0].Path)\n\t\t}\n\t})\n\n\tt.Run(\"Empty paths are fine\", func(t *testing.T) {\n\t\torigins := parseOrigins(\"http://foo.example.org\")\n\t\tif origins[0].Path != \"\" {\n\t\t\tt.Errorf(\"Expected the path to remain empty, instead it was: %q\", origins[0].Path)\n\t\t}\n\t})\n\n\tt.Run(\"Root paths are fine\", func(t *testing.T) {\n\t\torigins := parseOrigins(\"http://foo.example.org/\")\n\t\tif origins[0].Path != \"/\" {\n\t\t\tt.Errorf(\"Expected the path to remain a slash, instead it was: %q\", origins[0].Path)\n\t\t}\n\t})\n}\n\nfunc createURL(urlStr string, t *testing.T) *url.URL {\n\tt.Helper()\n\n\tresult, err := url.Parse(urlStr)\n\n\tif err != nil {\n\t\tt.Error(\"Test setup failed, unable to parse test URL\")\n\t}\n\n\treturn result\n}\n"
        },
        {
          "name": "source_test.go",
          "type": "blob",
          "size": 0.294921875,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestMatchSource(t *testing.T) {\n\tu, _ := url.Parse(\"http://foo?url=http://bar/image.jpg\")\n\treq := &http.Request{Method: http.MethodGet, URL: u}\n\n\tsource := MatchSource(req)\n\tif source == nil {\n\t\tt.Error(\"Cannot match image source\")\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "type.go",
          "type": "blob",
          "size": 1.478515625,
          "content": "package main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/h2non/bimg\"\n)\n\n// ExtractImageTypeFromMime returns the MIME image type.\nfunc ExtractImageTypeFromMime(mime string) string {\n\tmime = strings.Split(mime, \";\")[0]\n\tparts := strings.Split(mime, \"/\")\n\tif len(parts) < 2 {\n\t\treturn \"\"\n\t}\n\tname := strings.Split(parts[1], \"+\")[0]\n\treturn strings.ToLower(name)\n}\n\n// IsImageMimeTypeSupported returns true if the image MIME\n// type is supported by bimg.\nfunc IsImageMimeTypeSupported(mime string) bool {\n\tformat := ExtractImageTypeFromMime(mime)\n\n\t// Some payloads may expose the MIME type for SVG as text/xml\n\tif format == \"xml\" {\n\t\tformat = \"svg\"\n\t}\n\n\treturn bimg.IsTypeNameSupported(format)\n}\n\n// ImageType returns the image type based on the given image type alias.\nfunc ImageType(name string) bimg.ImageType {\n\tswitch strings.ToLower(name) {\n\tcase \"jpeg\":\n\t\treturn bimg.JPEG\n\tcase \"png\":\n\t\treturn bimg.PNG\n\tcase \"webp\":\n\t\treturn bimg.WEBP\n\tcase \"tiff\":\n\t\treturn bimg.TIFF\n\tcase \"gif\":\n\t\treturn bimg.GIF\n\tcase \"svg\":\n\t\treturn bimg.SVG\n\tcase \"pdf\":\n\t\treturn bimg.PDF\n\tdefault:\n\t\treturn bimg.UNKNOWN\n\t}\n}\n\n// GetImageMimeType returns the MIME type based on the given image type code.\nfunc GetImageMimeType(code bimg.ImageType) string {\n\tswitch code {\n\tcase bimg.PNG:\n\t\treturn \"image/png\"\n\tcase bimg.WEBP:\n\t\treturn \"image/webp\"\n\tcase bimg.TIFF:\n\t\treturn \"image/tiff\"\n\tcase bimg.GIF:\n\t\treturn \"image/gif\"\n\tcase bimg.SVG:\n\t\treturn \"image/svg+xml\"\n\tcase bimg.PDF:\n\t\treturn \"application/pdf\"\n\tdefault:\n\t\treturn \"image/jpeg\"\n\t}\n}\n"
        },
        {
          "name": "type_test.go",
          "type": "blob",
          "size": 2.3984375,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/h2non/bimg\"\n)\n\nfunc TestExtractImageTypeFromMime(t *testing.T) {\n\tfiles := []struct {\n\t\tmime     string\n\t\texpected string\n\t}{\n\t\t{\"image/jpeg\", \"jpeg\"},\n\t\t{\"/png\", \"png\"},\n\t\t{\"png\", \"\"},\n\t\t{\"multipart/form-data; encoding=utf-8\", \"form-data\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, file := range files {\n\t\tif ExtractImageTypeFromMime(file.mime) != file.expected {\n\t\t\tt.Fatalf(\"Invalid mime type: %s != %s\", file.mime, file.expected)\n\t\t}\n\t}\n}\n\nfunc TestIsImageTypeSupported(t *testing.T) {\n\tfiles := []struct {\n\t\tname     string\n\t\texpected bool\n\t}{\n\t\t{\"image/jpeg\", true},\n\t\t{\"image/png\", true},\n\t\t{\"image/webp\", true},\n\t\t{\"IMAGE/JPEG\", true},\n\t\t{\"png\", false},\n\t\t{\"multipart/form-data; encoding=utf-8\", false},\n\t\t{\"application/json\", false},\n\t\t{\"image/gif\", bimg.IsImageTypeSupportedByVips(bimg.GIF).Load},\n\t\t{\"image/svg+xml\", bimg.IsImageTypeSupportedByVips(bimg.SVG).Load},\n\t\t{\"image/svg\", bimg.IsImageTypeSupportedByVips(bimg.SVG).Load},\n\t\t{\"image/tiff\", bimg.IsImageTypeSupportedByVips(bimg.TIFF).Load},\n\t\t{\"application/pdf\", bimg.IsImageTypeSupportedByVips(bimg.PDF).Load},\n\t\t{\"text/plain\", false},\n\t\t{\"blablabla\", false},\n\t\t{\"\", false},\n\t}\n\n\tfor _, file := range files {\n\t\tif IsImageMimeTypeSupported(file.name) != file.expected {\n\t\t\tt.Fatalf(\"Invalid type: %s != %t\", file.name, file.expected)\n\t\t}\n\t}\n}\n\nfunc TestImageType(t *testing.T) {\n\tfiles := []struct {\n\t\tname     string\n\t\texpected bimg.ImageType\n\t}{\n\t\t{\"jpeg\", bimg.JPEG},\n\t\t{\"png\", bimg.PNG},\n\t\t{\"webp\", bimg.WEBP},\n\t\t{\"tiff\", bimg.TIFF},\n\t\t{\"gif\", bimg.GIF},\n\t\t{\"svg\", bimg.SVG},\n\t\t{\"pdf\", bimg.PDF},\n\t\t{\"multipart/form-data; encoding=utf-8\", bimg.UNKNOWN},\n\t\t{\"json\", bimg.UNKNOWN},\n\t\t{\"text\", bimg.UNKNOWN},\n\t\t{\"blablabla\", bimg.UNKNOWN},\n\t\t{\"\", bimg.UNKNOWN},\n\t}\n\n\tfor _, file := range files {\n\t\tif ImageType(file.name) != file.expected {\n\t\t\tt.Fatalf(\"Invalid type: %s != %s\", file.name, bimg.ImageTypes[file.expected])\n\t\t}\n\t}\n}\n\nfunc TestGetImageMimeType(t *testing.T) {\n\tfiles := []struct {\n\t\tname     bimg.ImageType\n\t\texpected string\n\t}{\n\t\t{bimg.JPEG, \"image/jpeg\"},\n\t\t{bimg.PNG, \"image/png\"},\n\t\t{bimg.WEBP, \"image/webp\"},\n\t\t{bimg.TIFF, \"image/tiff\"},\n\t\t{bimg.GIF, \"image/gif\"},\n\t\t{bimg.PDF, \"application/pdf\"},\n\t\t{bimg.SVG, \"image/svg+xml\"},\n\t\t{bimg.UNKNOWN, \"image/jpeg\"},\n\t}\n\n\tfor _, file := range files {\n\t\tif GetImageMimeType(file.name) != file.expected {\n\t\t\tt.Fatalf(\"Invalid type: %s != %s\", bimg.ImageTypes[file.name], file.expected)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.310546875,
          "content": "package main\n\n// Version stores the current package semantic version\nvar Version = \"dev\"\n\n// Versions represents the used versions for several significant dependencies\ntype Versions struct {\n\tImaginaryVersion string `json:\"imaginary\"`\n\tBimgVersion      string `json:\"bimg\"`\n\tVipsVersion      string `json:\"libvips\"`\n}\n"
        }
      ]
    }
  ]
}