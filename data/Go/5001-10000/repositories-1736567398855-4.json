{
  "metadata": {
    "timestamp": 1736567398855,
    "page": 4,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "panjf2000/gnet",
      "stars": 9905,
      "defaultBranch": "dev",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.263671875,
          "content": "# IDEs\n.idea/\n.vscode/\n\n# dependencies\n/node_modules\n\n# production\n/build\n\n# generated files\n.docusaurus\n.docusaurus/\n.cache-loader\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2724609375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at panjf2000@gmail.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.796875,
          "content": "# Contributing \n\n## With issues:\n  - Use the search tool before opening a new issue.\n  - Please provide source code and commit sha if you found a bug.\n  - Review existing issues and provide feedback or react to them.\n\n## With pull requests:\n  - Open your pull request against `dev`.\n  - Open one pull request for only one feature/proposal, if you have several those, please put them into different PRs, whereas you are allowed to open one pull request with several bug-fixes.\n  - Your pull request should have no more than two commits, if not, you should squash them.\n  - It should pass all tests in the available continuous integrations systems such as TravisCI.\n  - You should add/modify tests to cover your proposed code changes.\n  - If your pull request contains a new feature, please document it on the README.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.1201171875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright (c) 2019-present Andy Pan\n   Copyright (c) 2017 Joshua J Baker\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.1220703125,
          "content": "<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/panjf2000/logos/master/gnet/logo.png\" alt=\"gnet\" />\n<br />\n<a title=\"Build Status\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/actions?query=workflow%3ATests\"><img src=\"https://img.shields.io/github/actions/workflow/status/panjf2000/gnet/test.yml?branch=dev&style=flat-square&logo=github-actions\" /></a>\n<a title=\"Codecov\" target=\"_blank\" href=\"https://codecov.io/gh/panjf2000/gnet\"><img src=\"https://img.shields.io/codecov/c/github/panjf2000/gnet?style=flat-square&logo=codecov\" /></a>\n<a title=\"Supported Platforms\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet\"><img src=\"https://img.shields.io/badge/platform-Linux%20%7C%20macOS%20%7C%20*BSD%20%7C%20Windows-549688?style=flat-square&logo=launchpad\" /></a>\n<a title=\"Minimum Go Version\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet\"><img src=\"https://img.shields.io/badge/go-%3E%3D1.20-30dff3?style=flat-square&logo=go\" /></a>\n<br />\n<a title=\"Go Report Card\" target=\"_blank\" href=\"https://goreportcard.com/report/github.com/panjf2000/gnet\"><img src=\"https://goreportcard.com/badge/github.com/panjf2000/gnet?style=flat-square\" /></a>\n<a title=\"Doc for gnet\" target=\"_blank\" href=\"https://pkg.go.dev/github.com/panjf2000/gnet/v2#section-documentation\"><img src=\"https://img.shields.io/badge/go.dev-doc-007d9c?style=flat-square&logo=read-the-docs\" /></a>\n<a title=\"Mentioned in Awesome Go\" target=\"_blank\" href=\"https://github.com/avelino/awesome-go#networking\"><img src=\"https://awesome.re/mentioned-badge-flat.svg\" /></a>\n<a title=\"Release\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/releases\"><img src=\"https://img.shields.io/github/v/release/panjf2000/gnet.svg?color=161823&style=flat-square&logo=smartthings\" /></a>\n<a title=\"Tag\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/tags\"><img src=\"https://img.shields.io/github/v/tag/panjf2000/gnet?color=%23ff8936&logo=fitbit&style=flat-square\" /></a>\n</p>\n\nEnglish | [中文](README_ZH.md)\n\n### 🎉🎉🎉 Feel free to join [the channels about `gnet` on the Discord Server](https://discord.gg/UyKD7NZcfH).\n\n# 📖 Introduction\n\n`gnet` is an event-driven networking framework that is ultra-fast and lightweight. It is built from scratch by exploiting [epoll](https://man7.org/linux/man-pages/man7/epoll.7.html) and [kqueue](https://en.wikipedia.org/wiki/Kqueue) and it can achieve much higher performance with lower memory consumption than Go [net](https://golang.org/pkg/net/) in many specific scenarios.\n\n`gnet` and [net](https://golang.org/pkg/net/) don't share the same philosophy in network programming. Thus, building network applications with `gnet` can be significantly different from building them with [net](https://golang.org/pkg/net/), and the philosophies can't be reconciled. There are other similar products written in other programming languages in the community, such as [libuv](https://github.com/libuv/libuv), [netty](https://github.com/netty/netty), [twisted](https://github.com/twisted/twisted), [tornado](https://github.com/tornadoweb/tornado), etc. which work in a similar pattern as `gnet` under the hood.\n\n`gnet` is not designed to displace the Go [net](https://golang.org/pkg/net/), but to create an alternative in the Go ecosystem for building performance-critical network services. As a result of which, `gnet` is not as comprehensive as Go [net](https://golang.org/pkg/net/), it provides only the core functionality (via a concise set of APIs) required by a network application and it doesn't plan on becoming a coverall networking framework, as I think Go [net](https://golang.org/pkg/net/) has done a good enough job in that area.\n\n`gnet` sells itself as a high-performance, lightweight, non-blocking, event-driven networking framework written in pure Go which works on the transport layer with TCP/UDP protocols and Unix Domain Socket. It enables developers to implement their own protocols(HTTP, RPC, WebSocket, Redis, etc.) of application layer upon `gnet` for building diversified network services. For instance, you get an HTTP Server if you implement HTTP protocol upon `gnet` while you have a Redis Server done with the implementation of Redis protocol upon `gnet` and so on.\n\n**`gnet` derives from the project: `evio` with much higher performance and more features.**\n\n# 🚀 Features\n\n## 🦖 Milestone\n\n- [x] [High-performance](#-performance) event-driven looping based on a networking model of multiple threads/goroutines\n- [x] Built-in goroutine pool powered by the library [ants](https://github.com/panjf2000/ants)\n- [x] Lock-free during the entire runtime\n- [x] Concise and easy-to-use APIs\n- [x] Efficient, reusable, and elastic memory buffer: (Elastic-)Ring-Buffer, Linked-List-Buffer and Elastic-Mixed-Buffer\n- [x] Multiple protocols/IPC mechanisms: `TCP`, `UDP`, and `Unix Domain Socket`\n- [x] Multiple load-balancing algorithms: `Round-Robin`, `Source-Addr-Hash`, and `Least-Connections`\n- [x] Flexible ticker event\n- [x] `gnet` client\n- [x] Running on `Linux`, `macOS`, `Windows`, and *BSD: `Darwin`/`DragonFlyBSD`/`FreeBSD`/`NetBSD`/`OpenBSD`\n- [x] **Edge-triggered** I/O support\n- [x] Multiple network addresses binding\n\n## 🕊 Roadmap\n\n- [ ] **TLS** support\n- [ ] [io_uring](https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023) support\n- [ ] **KCP** support\n\n***Windows version of `gnet` should only be used in development for developing and testing, it shouldn't be used in production.***\n\n# 🎬 Getting started\n\n`gnet` is available as a Go module and we highly recommend that you use `gnet` via [Go Modules](https://go.dev/blog/using-go-modules), with Go 1.11 Modules enabled (Go 1.11+), you can just simply add `import \"github.com/panjf2000/gnet/v2\"` to the codebase and run `go mod download/go mod tidy` or `go [build|run|test]` to download the necessary dependencies automatically.\n\n## With v2\n\n```bash\ngo get -u github.com/panjf2000/gnet/v2\n```\n\n## With v1\n\n```bash\ngo get -u github.com/panjf2000/gnet\n```\n\n# 🎡 Use cases\n\nThe following corporations/organizations use `gnet` as the underlying network service in production.\n\n<table>\n  <tbody>\n    <tr>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.tencent.com/\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/tencent_logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.tencentgames.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/tencent-games-logo.jpeg\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.iqiyi.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/iqiyi-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.mi.com/global/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/mi-logo.png\" width=\"200\" />\n        </a>\n      </td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.360.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/360-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://tieba.baidu.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/baidu-tieba-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.jd.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/jd-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.zuoyebang.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/zuoyebang-logo.jpeg\" width=\"200\" />\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\nIf you're also using `gnet` in production, please help us enrich this list by opening a pull request.\n\n# 📊 Performance\n\n## Benchmarks on TechEmpower\n\n```bash\n# Hardware Environment\n* 28 HT Cores Intel(R) Xeon(R) Gold 5120 CPU @ 3.20GHz\n* 32GB RAM\n* Dedicated Cisco 10-gigabit Ethernet switch\n* Debian 12 \"bookworm\"\n* Go1.19.x linux/amd64\n```\n\n![](https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-plaintext-top50-light.jpg)\n\nThis is a leaderboard of the top ***50*** out of ***486*** frameworks that encompass various programming languages worldwide, in which `gnet` is ranked ***first***.\n\n![](https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-plaintext-topN-go-light.png)\n\nThis is the full framework ranking of Go and `gnet` tops all the other frameworks, which makes `gnet` the ***fastest*** networking framework in Go.\n\nTo see the full ranking list, visit [TechEmpower Benchmark **Round 22**](https://www.techempower.com/benchmarks/#hw=ph&test=plaintext&section=data-r22).\n\n***Note that the HTTP implementation of gnet on TechEmpower is half-baked and fine-tuned for benchmark purposes only and far from production-ready.***\n\n## Contrasts to the similar networking libraries\n\n## On Linux (epoll)\n\n### Test Environment\n\n```bash\n# Machine information\n        OS : Ubuntu 20.04/x86_64\n       CPU : 8 CPU cores, AMD EPYC 7K62 48-Core Processor\n    Memory : 16.0 GiB\n\n# Go version and settings\nGo Version : go1.17.2 linux/amd64\nGOMAXPROCS : 8\n\n# Benchmark parameters\nTCP connections : 1000/2000/5000/10000\nPacket size     : 512/1024/2048/4096/8192/16384/32768/65536 bytes\nTest duration   : 15s\n```\n\n#### [Echo benchmark](https://github.com/gnet-io/gnet-benchmarks)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_conn_linux.png)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_packet_linux.png)\n\n## On MacOS (kqueue)\n\n### Test Environment\n\n```bash\n# Machine information\n        OS : MacOS Big Sur/x86_64\n       CPU : 6 CPU cores, Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\n    Memory : 16.0 GiB\n\n# Go version and settings\nGo Version : go1.16.5 darwin/amd64\nGOMAXPROCS : 12\n\n# Benchmark parameters\nTCP connections : 300/400/500/600/700\nPacket size     : 512/1024/2048/4096/8192 bytes\nTest duration   : 15s\n```\n\n#### [Echo benchmark](https://github.com/gnet-io/gnet-benchmarks)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_conn_macos.png)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_packet_macos.png)\n\n# ⚠️ License\n\nThe source code of `gnet` should be distributed under the Apache-2.0 license.\n\n# 👏 Contributors\n\nPlease read the [Contributing Guidelines](CONTRIBUTING.md) before opening a PR and thank you to all the developers who already made contributions to `gnet`!\n\n<a href=\"https://github.com/panjf2000/gnet/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=panjf2000/gnet\" />\n</a>\n\n# ⚓ Relevant Articles\n\n- [A Million WebSockets and Go](https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/)\n- [Going Infinite, handling 1M websockets connections in Go](https://speakerdeck.com/eranyanay/going-infinite-handling-1m-websockets-connections-in-go)\n- [Go netpoller 原生网络模型之源码全面揭秘](https://strikefreedom.top/go-netpoll-io-multiplexing-reactor)\n- [gnet: 一个轻量级且高性能的 Golang 网络库](https://strikefreedom.top/go-event-loop-networking-library-gnet)\n- [最快的 Go 网络框架 gnet 来啦！](https://strikefreedom.top/releasing-gnet-v1-with-techempower)\n\n# 💰 Backers\n\nSupport us with a monthly donation and help us continue our activities.\n\n<a href=\"https://opencollective.com/gnet#backers\" target=\"_blank\"><img src=\"https://opencollective.com/gnet/backers.svg\"></a>\n\n# 💎 Sponsors\n\nBecome a bronze sponsor with a monthly donation of $10 and get your logo on our README on GitHub.\n\n<a href=\"https://opencollective.com/gnet#sponsors\" target=\"_blank\"><img src=\"https://opencollective.com/gnet/sponsors.svg\"></a>\n\n# ☕️ Buy me a coffee\n\n> Please be sure to leave your name, GitHub account, or other social media accounts when you donate by the following means so that I can add it to the list of donors as a token of my appreciation.\n\n<img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/WeChatPay.JPG\" width=\"250\" align=\"middle\"/>&nbsp;&nbsp;\n<img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/AliPay.JPG\" width=\"250\" align=\"middle\"/>&nbsp;&nbsp;\n<a href=\"https://www.paypal.me/R136a1X\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/PayPal.JPG\" width=\"250\" align=\"middle\"/></a>&nbsp;&nbsp;\n\n# 🔑 JetBrains OS licenses\n\n`gnet` has been being developed with `GoLand` IDE under the ***free JetBrains Open Source license(s)*** granted by JetBrains s.r.o., hence I would like to express my thanks here.\n\n<a href=\"https://www.jetbrains.com/?from=gnet\" target=\"_blank\"><img src=\"https://resources.jetbrains.com/storage/products/company/brand/logos/jetbrains.svg\" alt=\"JetBrains logo.\"></a>\n\n# 🔋 Sponsorship\n\n<p>\n  <h3>This project is supported by:</h3>\n  <a href=\"https://www.digitalocean.com/\"><img src=\"https://opensource.nyc3.cdn.digitaloceanspaces.com/attribution/assets/SVG/DO_Logo_horizontal_blue.svg\" width=\"201px\" />\n  </a>\n</p>"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 12.7841796875,
          "content": "<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/panjf2000/logos/master/gnet/logo.png\" alt=\"gnet\" />\n<br />\n<a title=\"Build Status\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/actions?query=workflow%3ATests\"><img src=\"https://img.shields.io/github/actions/workflow/status/panjf2000/gnet/test.yml?branch=dev&style=flat-square&logo=github-actions\" /></a>\n<a title=\"Codecov\" target=\"_blank\" href=\"https://codecov.io/gh/panjf2000/gnet\"><img src=\"https://img.shields.io/codecov/c/github/panjf2000/gnet?style=flat-square&logo=codecov\" /></a>\n<a title=\"Supported Platforms\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet\"><img src=\"https://img.shields.io/badge/platform-Linux%20%7C%20macOS%20%7C%20*BSD%20%7C%20Windows-549688?style=flat-square&logo=launchpad\" /></a>\n<a title=\"Minimum Go Version\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet\"><img src=\"https://img.shields.io/badge/go-%3E%3D1.20-30dff3?style=flat-square&logo=go\" /></a>\n<br />\n<a title=\"Go Report Card\" target=\"_blank\" href=\"https://goreportcard.com/report/github.com/panjf2000/gnet\"><img src=\"https://goreportcard.com/badge/github.com/panjf2000/gnet?style=flat-square\" /></a>\n<a title=\"Doc for gnet\" target=\"_blank\" href=\"https://pkg.go.dev/github.com/panjf2000/gnet/v2#section-documentation\"><img src=\"https://img.shields.io/badge/go.dev-doc-007d9c?style=flat-square&logo=read-the-docs\" /></a>\n<a title=\"Mentioned in Awesome Go\" target=\"_blank\" href=\"https://github.com/avelino/awesome-go#networking\"><img src=\"https://awesome.re/mentioned-badge-flat.svg\" /></a>\n<a title=\"Release\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/releases\"><img src=\"https://img.shields.io/github/v/release/panjf2000/gnet.svg?color=161823&style=flat-square&logo=smartthings\" /></a>\n<a title=\"Tag\" target=\"_blank\" href=\"https://github.com/panjf2000/gnet/tags\"><img src=\"https://img.shields.io/github/v/tag/panjf2000/gnet?color=%23ff8936&logo=fitbit&style=flat-square\" /></a>\n</p>\n\n[英文](README.md) | 中文\n\n### 🎉🎉🎉 欢迎加入 `gnet` 在 [Discord 服务器上的频道](https://discord.gg/UyKD7NZcfH).\n\n# 📖 简介\n\n`gnet` 是一个基于事件驱动的高性能和轻量级网络框架。这个框架是基于 [epoll](https://en.wikipedia.org/wiki/Epoll) 和 [kqueue](https://en.wikipedia.org/wiki/Kqueue) 从零开发的，而且相比 Go [net](https://golang.org/pkg/net/)，它能以更低的内存占用实现更高的性能。\n\n`gnet` 和 [net](https://golang.org/pkg/net/) 有着不一样的网络编程范式。因此，用 `gnet` 开发网络应用和用 [net](https://golang.org/pkg/net/) 开发区别很大，而且两者之间不可调和。社区里有其他同类的产品像是 [libuv](https://github.com/libuv/libuv), [netty](https://github.com/netty/netty), [twisted](https://github.com/twisted/twisted), [tornado](https://github.com/tornadoweb/tornado)，`gnet` 的底层工作原理和这些框架非常类似。\n\n`gnet` 不是为了取代 [net](https://golang.org/pkg/net/) 而生的，而是在 Go 生态中为开发者提供一个开发性能敏感的网络服务的替代品。也正因如此，`gnet` 在功能全面性上比不了 Go [net](https://golang.org/pkg/net/)，它只会提供网络应用所需的最核心的功能和最精简的 APIs，而且 `gnet` 也并没有打算变成一个无所不包的网络框架，因为我觉得 Go [net](https://golang.org/pkg/net/) 在这方面已经做得足够好了。\n\n`gnet` 的卖点在于它是一个高性能、轻量级、非阻塞的纯 Go 语言实现的传输层（TCP/UDP/Unix Domain Socket）网络框架。开发者可以使用 `gnet` 来实现自己的应用层网络协议(HTTP、RPC、Redis、WebSocket 等等)，从而构建出自己的应用层网络服务。比如在 `gnet` 上实现 HTTP 协议就可以创建出一个 HTTP 服务器 或者 Web 开发框架，实现 Redis 协议就可以创建出自己的 Redis 服务器等等。\n\n**`gnet` 衍生自另一个项目：`evio`，但拥有更丰富的功能特性，且性能远胜之。**\n\n# 🚀 功能\n\n## 🦖 当前支持\n\n- [x] 基于多线程/协程网络模型的[高性能](#-性能测试)事件驱动循环\n- [x] 内置 goroutine 池，由开源库 [ants](https://github.com/panjf2000/ants) 提供支持\n- [x] 整个生命周期是无锁的\n- [x] 简单易用的 APIs\n- [x] 高效、可重用而且自动伸缩的内存 buffer：(Elastic-)Ring-Buffer, Linked-List-Buffer and Elastic-Mixed-Buffer\n- [x] 多种网络协议/IPC 机制：`TCP`、`UDP` 和 `Unix Domain Socket`\n- [x] 多种负载均衡算法：`Round-Robin(轮询)`、`Source-Addr-Hash(源地址哈希)` 和 `Least-Connections(最少连接数)`\n- [x] 灵活的事件定时器\n- [x] `gnet` 客户端支持\n- [x] 支持 `Linux`, `macOS`, `Windows` 和 *BSD 操作系统: `Darwin`/`DragonFlyBSD`/`FreeBSD`/`NetBSD`/`OpenBSD`\n- [x] **Edge-triggered** I/O 支持\n- [x] 多网络地址绑定\n\n## 🕊 未来计划\n\n- [ ] 支持 **TLS**\n- [ ] 支持 [io_uring](https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023)\n- [ ] 支持 **KCP**\n\n***`gnet` 的 Windows 版本应该仅用于开发阶段的开发和测试，切勿用于生产环境***。\n\n# 🎬 开始\n\n`gnet` 是一个 Go module，而且我们也强烈推荐通过 [Go Modules](https://go.dev/blog/using-go-modules) 来使用 `gnet`，在开启 Go Modules 支持（Go 1.11+）之后可以通过简单地在代码中写 `import \"github.com/panjf2000/gnet/v2\"` 来引入 `gnet`，然后执行 `go mod download/go mod tidy` 或者 `go [build|run|test]` 这些命令来自动下载所依赖的包。\n\n## 使用 v2\n\n```bash\ngo get -u github.com/panjf2000/gnet/v2\n```\n\n## 使用 v1\n\n```bash\ngo get -u github.com/panjf2000/gnet\n```\n\n# 🎡 用户案例\n\n以下公司/组织在生产环境上使用了 `gnet` 作为底层网络服务。\n\n<table>\n  <tbody>\n    <tr>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.tencent.com/\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/tencent_logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.tencentgames.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/tencent-games-logo.jpeg\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.iqiyi.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/iqiyi-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.mi.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/mi-logo.png\" width=\"200\" />\n        </a>\n      </td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.360.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/360-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://tieba.baidu.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/baidu-tieba-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.jd.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/jd-logo.png\" width=\"200\" />\n        </a>\n      </td>\n      <td align=\"center\" valign=\"middle\">\n        <a href=\"https://www.zuoyebang.com/\" target=\"_blank\">\n          <img src=\"https://res.strikefreedom.top/static_res/logos/zuoyebang-logo.jpeg\" width=\"200\" />\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n如果你也正在生产环境上使用 `gnet`，欢迎提 Pull Request 来丰富这份列表。\n\n# 📊 性能测试\n\n## TechEmpower 性能测试\n\n```bash\n# 硬件环境\n* 28 HT Cores Intel(R) Xeon(R) Gold 5120 CPU @ 3.20GHz\n* 32GB RAM\n* Dedicated Cisco 10-gigabit Ethernet switch\n* Debian 12 \"bookworm\"\n* Go1.19.x linux/amd64\n```\n\n![](https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-plaintext-top50-light.jpg)\n\n这是包含全部编程语言框架的性能排名***前 50*** 的结果，总榜单包含了全世界共计 ***486*** 个框架，其中 `gnet` 排名***第一***。\n\n![](https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-plaintext-topN-go-light.png)\n\n这是 Go 语言分类下的全部排名，`gnet` 超越了其他所有框架，位列第一，是***最快***的 Go 网络框架。\n\n完整的排行可以通过 [TechEmpower Benchmark **Round 22**](https://www.techempower.com/benchmarks/#hw=ph&test=plaintext&section=data-r22) 查看。\n\n***请注意，TechEmpower 上的 gnet 的 HTTP 实现是不完备且针对性调优的，仅仅是用于压测目的，不是生产可用的***。\n\n## 同类型的网络库性能对比\n\n## On Linux (epoll)\n\n### Test Environment\n\n```bash\n# Machine information\n        OS : Ubuntu 20.04/x86_64\n       CPU : 8 CPU cores, AMD EPYC 7K62 48-Core Processor\n    Memory : 16.0 GiB\n\n# Go version and settings\nGo Version : go1.17.2 linux/amd64\nGOMAXPROCS : 8\n\n# Benchmark parameters\nTCP connections : 1000/2000/5000/10000\nPacket size     : 512/1024/2048/4096/8192/16384/32768/65536 bytes\nTest duration   : 15s\n```\n\n#### [Echo benchmark](https://github.com/gnet-io/gnet-benchmarks)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_conn_linux.png)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_packet_linux.png)\n\n## On MacOS (kqueue)\n\n### Test Environment\n\n```bash\n# Machine information\n        OS : MacOS Big Sur/x86_64\n       CPU : 6 CPU cores, Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\n    Memory : 16.0 GiB\n\n# Go version and settings\nGo Version : go1.16.5 darwin/amd64\nGOMAXPROCS : 12\n\n# Benchmark parameters\nTCP connections : 300/400/500/600/700\nPacket size     : 512/1024/2048/4096/8192 bytes\nTest duration   : 15s\n```\n\n#### [Echo benchmark](https://github.com/gnet-io/gnet-benchmarks)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_conn_macos.png)\n\n![](https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_packet_macos.png)\n\n# ⚠️ 证书\n\n`gnet` 的源码需在遵循 Apache-2.0 开源证书的前提下使用。\n\n# 👏 贡献者\n\n请在提 PR 之前仔细阅读 [Contributing Guidelines](CONTRIBUTING.md)，感谢那些为 `gnet` 贡献过代码的开发者！\n\n<a href=\"https://github.com/panjf2000/gnet/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=panjf2000/gnet\" />\n</a>\n\n# ⚓ 相关文章\n\n- [A Million WebSockets and Go](https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/)\n- [Going Infinite, handling 1M websockets connections in Go](https://speakerdeck.com/eranyanay/going-infinite-handling-1m-websockets-connections-in-go)\n- [Go netpoller 原生网络模型之源码全面揭秘](https://strikefreedom.top/go-netpoll-io-multiplexing-reactor)\n- [gnet: 一个轻量级且高性能的 Golang 网络库](https://strikefreedom.top/go-event-loop-networking-library-gnet)\n- [最快的 Go 网络框架 gnet 来啦！](https://strikefreedom.top/releasing-gnet-v1-with-techempower)\n\n# 💰 支持\n\n如果有意向，可以通过每个月定量的少许捐赠来支持这个项目。\n\n<a href=\"https://opencollective.com/gnet#backers\" target=\"_blank\"><img src=\"https://opencollective.com/gnet/backers.svg\"></a>\n\n# 💎 赞助\n\n每月定量捐赠 10 刀即可成为本项目的赞助者，届时您的 logo 或者 link 可以展示在本项目的 README 上。\n\n<a href=\"https://opencollective.com/gnet#sponsors\" target=\"_blank\"><img src=\"https://opencollective.com/gnet/sponsors.svg\"></a>\n\n# ☕️ 打赏\n\n> 当您通过以下方式进行捐赠时，请务必留下姓名、GitHub 账号或其他社交媒体账号，以便我将其添加到捐赠者名单中，以表谢意。\n\n<img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/WeChatPay.JPG\" width=\"250\" align=\"middle\"/>&nbsp;&nbsp;\n<img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/AliPay.JPG\" width=\"250\" align=\"middle\"/>&nbsp;&nbsp;\n<a href=\"https://www.paypal.me/R136a1X\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/PayPal.JPG\" width=\"250\" align=\"middle\"/></a>&nbsp;&nbsp;\n\n# 🔑 JetBrains 开源证书支持\n\n`gnet` 项目一直以来都是在 JetBrains 公司旗下的 GoLand 集成开发环境中进行开发，基于 ***free JetBrains Open Source license(s)*** 正版免费授权，在此表达我的谢意。\n\n<a href=\"https://www.jetbrains.com/?from=gnet\" target=\"_blank\"><img src=\"https://resources.jetbrains.com/storage/products/company/brand/logos/jetbrains.svg\" alt=\"JetBrains logo.\"></a>\n\n# 🔋 赞助商\n\n<p>\n  <h3>本项目由以下机构赞助：</h3>\n  <a href=\"https://www.digitalocean.com/\"><img src=\"https://opensource.nyc3.cdn.digitaloceanspaces.com/attribution/assets/SVG/DO_Logo_horizontal_blue.svg\" width=\"201px\" />\n  </a>\n</p>"
        },
        {
          "name": "acceptor_unix.go",
          "type": "blob",
          "size": 3.087890625,
          "content": "// Copyright (c) 2021 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\t\"github.com/panjf2000/gnet/v2/pkg/queue\"\n\t\"github.com/panjf2000/gnet/v2/pkg/socket\"\n)\n\nfunc (el *eventloop) accept0(fd int, _ netpoll.IOEvent, _ netpoll.IOFlags) error {\n\tfor {\n\t\tnfd, sa, err := socket.Accept(fd)\n\t\tswitch err {\n\t\tcase nil:\n\t\tcase unix.EAGAIN: // the Accept queue has been drained out, we can return now\n\t\t\treturn nil\n\t\tcase unix.EINTR, unix.ECONNRESET, unix.ECONNABORTED:\n\t\t\t// ECONNRESET or ECONNABORTED could indicate that a socket\n\t\t\t// in the Accept queue was closed before we Accept()ed it.\n\t\t\t// It's a silly error, let's retry it.\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tel.getLogger().Errorf(\"Accept() failed due to error: %v\", err)\n\t\t\treturn errors.ErrAcceptSocket\n\t\t}\n\n\t\tremoteAddr := socket.SockaddrToTCPOrUnixAddr(sa)\n\t\tif el.engine.opts.TCPKeepAlive > 0 && el.listeners[fd].network == \"tcp\" {\n\t\t\terr = socket.SetKeepAlivePeriod(nfd, int(el.engine.opts.TCPKeepAlive.Seconds()))\n\t\t\tif err != nil {\n\t\t\t\tel.getLogger().Errorf(\"failed to set TCP keepalive on fd=%d: %v\", fd, err)\n\t\t\t}\n\t\t}\n\n\t\tel := el.engine.eventLoops.next(remoteAddr)\n\t\tc := newTCPConn(nfd, el, sa, el.listeners[fd].addr, remoteAddr)\n\t\terr = el.poller.Trigger(queue.HighPriority, el.register, c)\n\t\tif err != nil {\n\t\t\tel.getLogger().Errorf(\"failed to enqueue the accepted socket fd=%d to poller: %v\", c.fd, err)\n\t\t\t_ = unix.Close(nfd)\n\t\t\tc.release()\n\t\t}\n\t}\n}\n\nfunc (el *eventloop) accept(fd int, ev netpoll.IOEvent, flags netpoll.IOFlags) error {\n\tif el.listeners[fd].network == \"udp\" {\n\t\treturn el.readUDP(fd, ev, flags)\n\t}\n\n\tnfd, sa, err := socket.Accept(fd)\n\tswitch err {\n\tcase nil:\n\tcase unix.EINTR, unix.EAGAIN, unix.ECONNRESET, unix.ECONNABORTED:\n\t\t// ECONNRESET or ECONNABORTED could indicate that a socket\n\t\t// in the Accept queue was closed before we Accept()ed it.\n\t\t// It's a silly error, let's retry it.\n\t\treturn nil\n\tdefault:\n\t\tel.getLogger().Errorf(\"Accept() failed due to error: %v\", err)\n\t\treturn errors.ErrAcceptSocket\n\t}\n\n\tremoteAddr := socket.SockaddrToTCPOrUnixAddr(sa)\n\tif el.engine.opts.TCPKeepAlive > 0 && el.listeners[fd].network == \"tcp\" {\n\t\terr = socket.SetKeepAlivePeriod(nfd, int(el.engine.opts.TCPKeepAlive/time.Second))\n\t\tif err != nil {\n\t\t\tel.getLogger().Errorf(\"failed to set TCP keepalive on fd=%d: %v\", fd, err)\n\t\t}\n\t}\n\n\tc := newTCPConn(nfd, el, sa, el.listeners[fd].addr, remoteAddr)\n\treturn el.register0(c)\n}\n"
        },
        {
          "name": "acceptor_windows.go",
          "type": "blob",
          "size": 2.1982421875,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"runtime\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n)\n\nfunc (eng *engine) listenStream(ln net.Listener) (err error) {\n\tif eng.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tdefer func() { eng.shutdown(err) }()\n\n\tfor {\n\t\t// Accept TCP socket.\n\t\ttc, e := ln.Accept()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tif !eng.beingShutdown.Load() {\n\t\t\t\teng.opts.Logger.Errorf(\"Accept() fails due to error: %v\", err)\n\t\t\t} else if errors.Is(err, net.ErrClosed) {\n\t\t\t\terr = errors.Join(err, errorx.ErrEngineShutdown)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tel := eng.eventLoops.next(tc.RemoteAddr())\n\t\tc := newTCPConn(tc, el)\n\t\tel.ch <- &openConn{c: c}\n\t\tgo func(c *conn, tc net.Conn, el *eventloop) {\n\t\t\tvar buffer [0x10000]byte\n\t\t\tfor {\n\t\t\t\tn, err := tc.Read(buffer[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tel.ch <- &netErr{c, err}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tel.ch <- packTCPConn(c, buffer[:n])\n\t\t\t}\n\t\t}(c, tc, el)\n\t}\n}\n\nfunc (eng *engine) ListenUDP(pc net.PacketConn) (err error) {\n\tif eng.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tdefer func() { eng.shutdown(err) }()\n\n\tvar buffer [0x10000]byte\n\tfor {\n\t\t// Read data from UDP socket.\n\t\tn, addr, e := pc.ReadFrom(buffer[:])\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tif !eng.beingShutdown.Load() {\n\t\t\t\teng.opts.Logger.Errorf(\"failed to receive data from UDP fd due to error:%v\", err)\n\t\t\t} else if errors.Is(err, net.ErrClosed) {\n\t\t\t\terr = errors.Join(err, errorx.ErrEngineShutdown)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tel := eng.eventLoops.next(addr)\n\t\tc := newUDPConn(el, pc, pc.LocalAddr(), addr)\n\t\tel.ch <- packUDPConn(c, buffer[:n])\n\t}\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 23.4638671875,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd || windows\n\npackage gnet\n\nimport (\n\t\"bytes\"\n\tcrand \"crypto/rand\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\tbbPool \"github.com/panjf2000/gnet/v2/pkg/pool/bytebuffer\"\n\tgoPool \"github.com/panjf2000/gnet/v2/pkg/pool/goroutine\"\n)\n\ntype connHandler struct {\n\tnetwork string\n\trspCh   chan []byte\n\tdata    []byte\n}\n\ntype clientEvents struct {\n\t*BuiltinEventEngine\n\ttester    *testing.T\n\tsvr       *testClient\n\tpacketLen int\n}\n\nfunc (ev *clientEvents) OnBoot(e Engine) Action {\n\tfd, err := e.Dup()\n\trequire.ErrorIsf(ev.tester, err, errorx.ErrEmptyEngine, \"expected error: %v, but got: %v\",\n\t\terrorx.ErrUnsupportedOp, err)\n\tassert.EqualValuesf(ev.tester, fd, -1, \"expected -1, but got: %d\", fd)\n\treturn None\n}\n\nvar pingMsg = []byte(\"PING\\r\\n\")\n\nfunc (ev *clientEvents) OnOpen(Conn) (out []byte, action Action) {\n\tout = pingMsg\n\treturn\n}\n\nfunc (ev *clientEvents) OnClose(Conn, error) Action {\n\tif ev.svr != nil {\n\t\tif atomic.AddInt32(&ev.svr.clientActive, -1) == 0 {\n\t\t\treturn Shutdown\n\t\t}\n\t}\n\treturn None\n}\n\nfunc (ev *clientEvents) OnTraffic(c Conn) (action Action) {\n\thandler := c.Context().(*connHandler)\n\tif handler.network == \"udp\" {\n\t\tev.packetLen = datagramLen\n\t}\n\tbuf, err := c.Next(-1)\n\tassert.NoError(ev.tester, err)\n\thandler.data = append(handler.data, buf...)\n\tif len(handler.data) < ev.packetLen {\n\t\treturn\n\t}\n\thandler.rspCh <- handler.data\n\thandler.data = nil\n\treturn\n}\n\nfunc (ev *clientEvents) OnTick() (delay time.Duration, action Action) {\n\tdelay = 200 * time.Millisecond\n\treturn\n}\n\nfunc (ev *clientEvents) OnShutdown(e Engine) {\n\tfd, err := e.Dup()\n\trequire.ErrorIsf(ev.tester, err, errorx.ErrEmptyEngine, \"expected error: %v, but got: %v\",\n\t\terrorx.ErrUnsupportedOp, err)\n\tassert.EqualValuesf(ev.tester, fd, -1, \"expected -1, but got: %d\", fd)\n}\n\nfunc TestClient(t *testing.T) {\n\t// start an engine\n\t// connect 10 clients\n\t// each client will pipe random data for 1-3 seconds.\n\t// the writes to the engine will be random sizes. 0KB - 1MB.\n\t// the engine will echo back the data.\n\t// waits for graceful connection closing.\n\tt.Run(\"poll-LT\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{false, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{false, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{false, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{false, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{false, 0, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{false, 0, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-ET\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 0, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 0, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-ET-chunk\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 1 << 19, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 1 << 19, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 1 << 19, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 1 << 19, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 1 << 19, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 1 << 19, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-reuseport-LT\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-reuseport-ET\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9991\", &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"tcp\", \":9992\", &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9991\", &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"udp\", \":9992\", &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet1.sock\", &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunClient(t, \"unix\", \"gnet2.sock\", &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n}\n\ntype testClient struct {\n\t*BuiltinEventEngine\n\tclient        *Client\n\ttester        *testing.T\n\teng           Engine\n\tnetwork       string\n\taddr          string\n\tmulticore     bool\n\tasync         bool\n\tnclients      int\n\tstarted       int32\n\tconnected     int32\n\tclientActive  int32\n\tdisconnected  int32\n\tworkerPool    *goPool.Pool\n\tudpReadHeader int32\n}\n\nfunc (s *testClient) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\treturn\n}\n\nfunc (s *testClient) OnOpen(c Conn) (out []byte, action Action) {\n\tc.SetContext(&sync.Once{})\n\tatomic.AddInt32(&s.connected, 1)\n\trequire.NotNil(s.tester, c.LocalAddr(), \"nil local addr\")\n\trequire.NotNil(s.tester, c.RemoteAddr(), \"nil remote addr\")\n\treturn\n}\n\nfunc (s *testClient) OnClose(c Conn, err error) (action Action) {\n\tif err != nil {\n\t\tlogging.Debugf(\"error occurred on closed, %v\\n\", err)\n\t}\n\tif s.network != \"udp\" {\n\t\trequire.IsType(s.tester, c.Context(), new(sync.Once), \"invalid context\")\n\t}\n\n\tatomic.AddInt32(&s.disconnected, 1)\n\tif atomic.LoadInt32(&s.connected) == atomic.LoadInt32(&s.disconnected) &&\n\t\tatomic.LoadInt32(&s.disconnected) == int32(s.nclients) {\n\t\taction = Shutdown\n\t\ts.workerPool.Release()\n\t}\n\n\treturn\n}\n\nfunc (s *testClient) OnShutdown(Engine) {\n\tif s.network == \"udp\" {\n\t\trequire.EqualValues(s.tester, int32(s.nclients), atomic.LoadInt32(&s.udpReadHeader))\n\t}\n}\n\nfunc (s *testClient) OnTraffic(c Conn) (action Action) {\n\treadHeader := func() {\n\t\tping := make([]byte, len(pingMsg))\n\t\tn, err := io.ReadFull(c, ping)\n\t\trequire.NoError(s.tester, err)\n\t\trequire.EqualValues(s.tester, len(pingMsg), n)\n\t\trequire.Equal(s.tester, string(pingMsg), string(ping), \"bad header\")\n\t}\n\tv := c.Context()\n\tif v != nil {\n\t\tv.(*sync.Once).Do(readHeader)\n\t}\n\n\tif s.async {\n\t\tbuf := bbPool.Get()\n\t\t_, _ = c.WriteTo(buf)\n\n\t\tif s.network == \"tcp\" || s.network == \"unix\" {\n\t\t\t// just for test\n\t\t\t_ = c.InboundBuffered()\n\t\t\t_ = c.OutboundBuffered()\n\t\t\t_, _ = c.Discard(1)\n\t\t}\n\t\tif v == nil && bytes.Equal(buf.Bytes(), pingMsg) {\n\t\t\tatomic.AddInt32(&s.udpReadHeader, 1)\n\t\t\tbuf.Reset()\n\t\t}\n\t\t_ = s.workerPool.Submit(\n\t\t\tfunc() {\n\t\t\t\tif buf.Len() > 0 {\n\t\t\t\t\terr := c.AsyncWrite(buf.Bytes(), nil)\n\t\t\t\t\trequire.NoError(s.tester, err)\n\t\t\t\t}\n\t\t\t})\n\t\treturn\n\t}\n\n\tbuf, _ := c.Next(-1)\n\tif v == nil && bytes.Equal(buf, pingMsg) {\n\t\tatomic.AddInt32(&s.udpReadHeader, 1)\n\t\tbuf = nil\n\t}\n\tif len(buf) > 0 {\n\t\tn, err := c.Write(buf)\n\t\trequire.NoError(s.tester, err)\n\t\trequire.EqualValues(s.tester, len(buf), n)\n\t}\n\treturn\n}\n\nfunc (s *testClient) OnTick() (delay time.Duration, action Action) {\n\tdelay = 100 * time.Millisecond\n\tif atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tfor i := 0; i < s.nclients; i++ {\n\t\t\tatomic.AddInt32(&s.clientActive, 1)\n\t\t\tvar netConn bool\n\t\t\tif i%2 == 0 {\n\t\t\t\tnetConn = true\n\t\t\t}\n\t\t\tgo startGnetClient(s.tester, s.client, s.network, s.addr, s.multicore, s.async, netConn)\n\t\t}\n\t}\n\tif s.network == \"udp\" && atomic.LoadInt32(&s.clientActive) == 0 {\n\t\taction = Shutdown\n\t\treturn\n\t}\n\treturn\n}\n\nfunc runClient(t *testing.T, network, addr string, conf *testConf) {\n\tts := &testClient{\n\t\ttester:     t,\n\t\tnetwork:    network,\n\t\taddr:       addr,\n\t\tmulticore:  conf.multicore,\n\t\tasync:      conf.async,\n\t\tnclients:   conf.clients,\n\t\tworkerPool: goPool.Default(),\n\t}\n\tvar err error\n\tclientEV := &clientEvents{tester: t, packetLen: streamLen, svr: ts}\n\tts.client, err = NewClient(\n\t\tclientEV,\n\t\tWithEdgeTriggeredIO(conf.et),\n\t\tWithEdgeTriggeredIOChunk(conf.etChunk),\n\t\tWithTCPNoDelay(TCPNoDelay),\n\t\tWithLockOSThread(true),\n\t\tWithTicker(true),\n\t)\n\tassert.NoError(t, err)\n\n\terr = ts.client.Start()\n\tassert.NoError(t, err)\n\tdefer ts.client.Stop() //nolint:errcheck\n\n\terr = Run(ts,\n\t\tnetwork+\"://\"+addr,\n\t\tWithEdgeTriggeredIO(conf.et),\n\t\tWithEdgeTriggeredIOChunk(conf.etChunk),\n\t\tWithLockOSThread(conf.async),\n\t\tWithMulticore(conf.multicore),\n\t\tWithReusePort(conf.reuseport),\n\t\tWithTicker(true),\n\t\tWithTCPKeepAlive(time.Minute*1),\n\t\tWithLoadBalancing(conf.lb))\n\tassert.NoError(t, err)\n}\n\nfunc startGnetClient(t *testing.T, cli *Client, network, addr string, multicore, async, netDial bool) {\n\tvar (\n\t\tc   Conn\n\t\terr error\n\t)\n\thandler := &connHandler{\n\t\tnetwork: network,\n\t\trspCh:   make(chan []byte, 1),\n\t}\n\tif netDial {\n\t\tvar netConn net.Conn\n\t\tnetConn, err = stdDial(network, addr)\n\t\trequire.NoError(t, err)\n\t\tc, err = cli.EnrollContext(netConn, handler)\n\t} else {\n\t\tc, err = cli.DialContext(network, addr, handler)\n\t}\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\terr = c.Wake(nil)\n\trequire.NoError(t, err)\n\trspCh := handler.rspCh\n\tduration := time.Duration((rand.Float64()*2+1)*float64(time.Second)) / 2\n\tlogging.Debugf(\"test duration: %v\", duration)\n\tstart := time.Now()\n\tfor time.Since(start) < duration {\n\t\treqData := make([]byte, streamLen)\n\t\tif network == \"udp\" {\n\t\t\treqData = reqData[:datagramLen]\n\t\t}\n\t\t_, err = crand.Read(reqData)\n\t\trequire.NoError(t, err)\n\t\terr = c.AsyncWrite(reqData, nil)\n\t\trequire.NoError(t, err)\n\t\trespData := <-rspCh\n\t\trequire.NoError(t, err)\n\t\tif !async {\n\t\t\t// require.Equalf(t, reqData, respData, \"response mismatch with protocol:%s, multi-core:%t, content of bytes: %d vs %d\", network, multicore, string(reqData), string(respData))\n\t\t\trequire.Equalf(\n\t\t\t\tt,\n\t\t\t\treqData,\n\t\t\t\trespData,\n\t\t\t\t\"response mismatch with protocol:%s, multi-core:%t, length of bytes: %d vs %d\",\n\t\t\t\tnetwork,\n\t\t\t\tmulticore,\n\t\t\t\tlen(reqData),\n\t\t\t\tlen(respData),\n\t\t\t)\n\t\t}\n\t}\n}\n\ntype clientEventsForWake struct {\n\tBuiltinEventEngine\n\ttester *testing.T\n\tch     chan struct{}\n}\n\nfunc (ev *clientEventsForWake) OnBoot(_ Engine) Action {\n\tev.ch = make(chan struct{})\n\treturn None\n}\n\nfunc (ev *clientEventsForWake) OnTraffic(c Conn) (action Action) {\n\tn, err := c.Read(nil)\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, n)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tbuf := make([]byte, 10)\n\tn, err = c.Read(buf)\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, n)\n\tassert.ErrorIsf(ev.tester, err, io.ErrShortBuffer, \"expected error: %v, but got: %v\", io.ErrShortBuffer, err)\n\tbuf, err = c.Next(10)\n\tassert.Nilf(ev.tester, buf, \"expected: %v, but got: %v\", nil, buf)\n\tassert.ErrorIsf(ev.tester, err, io.ErrShortBuffer, \"expected error: %v, but got: %v\", io.ErrShortBuffer, err)\n\tbuf, err = c.Next(-1)\n\tassert.Emptyf(ev.tester, buf, \"expected an empty slice, but got: %v\", buf)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tbuf, err = c.Peek(10)\n\tassert.Nilf(ev.tester, buf, \"expected: %v, but got: %v\", nil, buf)\n\tassert.ErrorIsf(ev.tester, err, io.ErrShortBuffer, \"expected error: %v, but got: %v\", io.ErrShortBuffer, err)\n\tbuf, err = c.Peek(-1)\n\tassert.Emptyf(ev.tester, buf, \"expected an empty slice, but got: %v\", buf)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tn, err = c.Discard(10)\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, n)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tn, err = c.Discard(-1)\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, n)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tm, err := c.WriteTo(io.Discard)\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, m)\n\tassert.NoErrorf(ev.tester, err, \"expected: %v, but got: %v\", nil, err)\n\tn = c.InboundBuffered()\n\tassert.Zerof(ev.tester, n, \"expected: %v, but got: %v\", 0, m)\n\t<-ev.ch\n\treturn None\n}\n\ntype serverEventsForWake struct {\n\tBuiltinEventEngine\n\tnetwork, addr string\n\tclient        *Client\n\tclientEV      *clientEventsForWake\n\ttester        *testing.T\n\tclients       int32\n\tstarted       int32\n}\n\nfunc (ev *serverEventsForWake) OnOpen(_ Conn) ([]byte, Action) {\n\tatomic.AddInt32(&ev.clients, 1)\n\treturn nil, None\n}\n\nfunc (ev *serverEventsForWake) OnClose(_ Conn, _ error) Action {\n\tif atomic.AddInt32(&ev.clients, -1) == 0 {\n\t\treturn Shutdown\n\t}\n\treturn None\n}\n\nfunc (ev *serverEventsForWake) OnTick() (time.Duration, Action) {\n\tif atomic.CompareAndSwapInt32(&ev.started, 0, 1) {\n\t\tgo testConnWakeImmediately(ev.tester, ev.client, ev.clientEV, ev.network, ev.addr)\n\t}\n\treturn 100 * time.Millisecond, None\n}\n\nfunc testConnWakeImmediately(t *testing.T, client *Client, clientEV *clientEventsForWake, network, addr string) {\n\tc, err := client.Dial(network, addr)\n\tassert.NoErrorf(t, err, \"failed to dial: %v\", err)\n\terr = c.Wake(nil)\n\tassert.NoError(t, err)\n\terr = c.Close()\n\tassert.NoError(t, err)\n\tclientEV.ch <- struct{}{}\n}\n\nfunc TestWakeConnImmediately(t *testing.T) {\n\tcurrentLogger, currentFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tt.Cleanup(func() {\n\t\tlogging.SetDefaultLoggerAndFlusher(currentLogger, currentFlusher) // restore\n\t})\n\n\tclientEV := &clientEventsForWake{tester: t}\n\tlogPath := filepath.Join(t.TempDir(), \"gnet-test-wake-conn-immediately.log\")\n\tclient, err := NewClient(clientEV,\n\t\tWithSocketRecvBuffer(4*1024),\n\t\tWithSocketSendBuffer(4*1024),\n\t\tWithLogPath(logPath),\n\t\tWithLogLevel(logging.WarnLevel),\n\t\tWithReadBufferCap(512),\n\t\tWithWriteBufferCap(512))\n\tassert.NoError(t, err)\n\tlogging.Cleanup()\n\n\terr = client.Start()\n\tassert.NoError(t, err)\n\tdefer client.Stop() //nolint:errcheck\n\n\tserverEV := &serverEventsForWake{tester: t, network: \"tcp\", addr: \":18888\", client: client, clientEV: clientEV}\n\n\terr = Run(serverEV, serverEV.network+\"://\"+serverEV.addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestClientReadOnEOF(t *testing.T) {\n\tcurrentLogger, currentFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tt.Cleanup(func() {\n\t\tlogging.SetDefaultLoggerAndFlusher(currentLogger, currentFlusher) // restore\n\t})\n\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:9999\")\n\tassert.NoError(t, err)\n\tdefer ln.Close()\n\n\tgo func() {\n\t\tfor {\n\t\t\tconn, err := ln.Accept()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tgo process(conn)\n\t\t}\n\t}()\n\n\tev := &clientReadOnEOF{\n\t\tresult: make(chan struct {\n\t\t\tdata []byte\n\t\t\terr  error\n\t\t}, 1),\n\t\tdata: []byte(\"test\"),\n\t}\n\tcli, err := NewClient(ev,\n\t\tWithSocketRecvBuffer(4*1024),\n\t\tWithSocketSendBuffer(4*1024),\n\t\tWithTCPKeepAlive(time.Minute),\n\t\tWithLogger(zap.NewExample().Sugar()),\n\t\tWithReadBufferCap(32*1024),\n\t\tWithWriteBufferCap(32*1024))\n\tassert.NoError(t, err)\n\tdefer cli.Stop() //nolint:errcheck\n\n\terr = cli.Start()\n\tassert.NoError(t, err)\n\n\t_, err = cli.Dial(\"tcp\", \"127.0.0.1:9999\")\n\tassert.NoError(t, err)\n\n\tselect {\n\tcase res := <-ev.result:\n\t\tassert.NoError(t, res.err)\n\t\tassert.EqualValuesf(t, ev.data, res.data, \"expected: %v, but got: %v\", ev.data, res.data)\n\tcase <-time.After(5 * time.Second):\n\t\tt.Errorf(\"timeout waiting for the result\")\n\t}\n}\n\nfunc process(conn net.Conn) {\n\tdefer conn.Close() //noliint:errcheck\n\tbuf := make([]byte, 8)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn\n\t}\n\t_, _ = conn.Write(buf[:n])\n\t_ = conn.Close()\n}\n\ntype clientReadOnEOF struct {\n\tBuiltinEventEngine\n\tdata   []byte\n\tresult chan struct {\n\t\tdata []byte\n\t\terr  error\n\t}\n}\n\nfunc (clientReadOnEOF) OnBoot(Engine) (action Action) {\n\treturn None\n}\n\nfunc (cli clientReadOnEOF) OnOpen(Conn) (out []byte, action Action) {\n\treturn cli.data, None\n}\n\nfunc (clientReadOnEOF) OnClose(Conn, error) (action Action) {\n\treturn Close\n}\n\nfunc (cli clientReadOnEOF) OnTraffic(c Conn) (action Action) {\n\tdata, err := c.Next(-1)\n\tcli.result <- struct {\n\t\tdata []byte\n\t\terr  error\n\t}{data: data, err: err}\n\treturn None\n}\n"
        },
        {
          "name": "client_unix.go",
          "type": "blob",
          "size": 6.814453125,
          "content": "// Copyright (c) 2021 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"strconv\"\n\t\"syscall\"\n\n\t\"golang.org/x/sync/errgroup\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/buffer/ring\"\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/math\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\t\"github.com/panjf2000/gnet/v2/pkg/queue\"\n\t\"github.com/panjf2000/gnet/v2/pkg/socket\"\n)\n\n// Client of gnet.\ntype Client struct {\n\topts *Options\n\tel   *eventloop\n}\n\n// NewClient creates an instance of Client.\nfunc NewClient(eh EventHandler, opts ...Option) (cli *Client, err error) {\n\toptions := loadOptions(opts...)\n\tcli = new(Client)\n\tcli.opts = options\n\n\tlogger, logFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tif options.Logger == nil {\n\t\tif options.LogPath != \"\" {\n\t\t\tlogger, logFlusher, _ = logging.CreateLoggerAsLocalFile(options.LogPath, options.LogLevel)\n\t\t}\n\t\toptions.Logger = logger\n\t} else {\n\t\tlogger = options.Logger\n\t\tlogFlusher = nil\n\t}\n\tlogging.SetDefaultLoggerAndFlusher(logger, logFlusher)\n\n\tvar p *netpoll.Poller\n\tif p, err = netpoll.OpenPoller(); err != nil {\n\t\treturn\n\t}\n\n\trootCtx, shutdown := context.WithCancel(context.Background())\n\teg, ctx := errgroup.WithContext(rootCtx)\n\teng := engine{\n\t\tlisteners:    make(map[int]*listener),\n\t\topts:         options,\n\t\tturnOff:      shutdown,\n\t\teventHandler: eh,\n\t\tconcurrency: struct {\n\t\t\t*errgroup.Group\n\t\t\tctx context.Context\n\t\t}{eg, ctx},\n\t}\n\tel := eventloop{\n\t\tlisteners: eng.listeners,\n\t\tengine:    &eng,\n\t\tpoller:    p,\n\t}\n\n\tif options.EdgeTriggeredIOChunk > 0 {\n\t\toptions.EdgeTriggeredIO = true\n\t\toptions.EdgeTriggeredIOChunk = math.CeilToPowerOfTwo(options.EdgeTriggeredIOChunk)\n\t} else if options.EdgeTriggeredIO {\n\t\toptions.EdgeTriggeredIOChunk = 1 << 20 // 1MB\n\t}\n\n\trbc := options.ReadBufferCap\n\tswitch {\n\tcase rbc <= 0:\n\t\toptions.ReadBufferCap = MaxStreamBufferCap\n\tcase rbc <= ring.DefaultBufferSize:\n\t\toptions.ReadBufferCap = ring.DefaultBufferSize\n\tdefault:\n\t\toptions.ReadBufferCap = math.CeilToPowerOfTwo(rbc)\n\t}\n\twbc := options.WriteBufferCap\n\tswitch {\n\tcase wbc <= 0:\n\t\toptions.WriteBufferCap = MaxStreamBufferCap\n\tcase wbc <= ring.DefaultBufferSize:\n\t\toptions.WriteBufferCap = ring.DefaultBufferSize\n\tdefault:\n\t\toptions.WriteBufferCap = math.CeilToPowerOfTwo(wbc)\n\t}\n\n\tel.buffer = make([]byte, options.ReadBufferCap)\n\tel.connections.init()\n\tel.eventHandler = eh\n\tcli.el = &el\n\treturn\n}\n\n// Start starts the client event-loop, handing IO events.\nfunc (cli *Client) Start() error {\n\tlogging.Infof(\"Starting gnet client with 1 event-loop\")\n\tcli.el.eventHandler.OnBoot(Engine{cli.el.engine})\n\tcli.el.engine.concurrency.Go(cli.el.run)\n\t// Start the ticker.\n\tif cli.opts.Ticker {\n\t\tctx := cli.el.engine.concurrency.ctx\n\t\tcli.el.engine.concurrency.Go(func() error {\n\t\t\tcli.el.ticker(ctx)\n\t\t\treturn nil\n\t\t})\n\t}\n\tlogging.Debugf(\"default logging level is %s\", logging.LogLevel())\n\treturn nil\n}\n\n// Stop stops the client event-loop.\nfunc (cli *Client) Stop() (err error) {\n\tlogging.Error(cli.el.poller.Trigger(queue.HighPriority, func(_ any) error { return errorx.ErrEngineShutdown }, nil))\n\terr = cli.el.engine.concurrency.Wait()\n\tlogging.Error(cli.el.poller.Close())\n\tcli.el.eventHandler.OnShutdown(Engine{cli.el.engine})\n\tlogging.Cleanup()\n\treturn\n}\n\n// Dial is like net.Dial().\nfunc (cli *Client) Dial(network, address string) (Conn, error) {\n\treturn cli.DialContext(network, address, nil)\n}\n\n// DialContext is like Dial but also accepts an empty interface ctx that can be obtained later via Conn.Context.\nfunc (cli *Client) DialContext(network, address string, ctx any) (Conn, error) {\n\tc, err := net.Dial(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cli.EnrollContext(c, ctx)\n}\n\n// Enroll converts a net.Conn to gnet.Conn and then adds it into Client.\nfunc (cli *Client) Enroll(c net.Conn) (Conn, error) {\n\treturn cli.EnrollContext(c, nil)\n}\n\n// EnrollContext is like Enroll but also accepts an empty interface ctx that can be obtained later via Conn.Context.\nfunc (cli *Client) EnrollContext(c net.Conn, ctx any) (Conn, error) {\n\tdefer c.Close()\n\n\tsc, ok := c.(syscall.Conn)\n\tif !ok {\n\t\treturn nil, errors.New(\"failed to convert net.Conn to syscall.Conn\")\n\t}\n\trc, err := sc.SyscallConn()\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to get syscall.RawConn from net.Conn\")\n\t}\n\n\tvar dupFD int\n\te := rc.Control(func(fd uintptr) {\n\t\tdupFD, err = unix.Dup(int(fd))\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\n\tif cli.opts.SocketSendBuffer > 0 {\n\t\tif err = socket.SetSendBuffer(dupFD, cli.opts.SocketSendBuffer); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif cli.opts.SocketRecvBuffer > 0 {\n\t\tif err = socket.SetRecvBuffer(dupFD, cli.opts.SocketRecvBuffer); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar (\n\t\tsockAddr unix.Sockaddr\n\t\tgc       *conn\n\t)\n\tswitch c.(type) {\n\tcase *net.UnixConn:\n\t\tsockAddr, _, _, err = socket.GetUnixSockAddr(c.RemoteAddr().Network(), c.RemoteAddr().String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tua := c.LocalAddr().(*net.UnixAddr)\n\t\tua.Name = c.RemoteAddr().String() + \".\" + strconv.Itoa(dupFD)\n\t\tgc = newTCPConn(dupFD, cli.el, sockAddr, c.LocalAddr(), c.RemoteAddr())\n\tcase *net.TCPConn:\n\t\tif cli.opts.TCPNoDelay == TCPNoDelay {\n\t\t\tif err = socket.SetNoDelay(dupFD, 1); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tif cli.opts.TCPKeepAlive > 0 {\n\t\t\tif err = socket.SetKeepAlivePeriod(dupFD, int(cli.opts.TCPKeepAlive.Seconds())); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tsockAddr, _, _, _, err = socket.GetTCPSockAddr(c.RemoteAddr().Network(), c.RemoteAddr().String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgc = newTCPConn(dupFD, cli.el, sockAddr, c.LocalAddr(), c.RemoteAddr())\n\tcase *net.UDPConn:\n\t\tsockAddr, _, _, _, err = socket.GetUDPSockAddr(c.RemoteAddr().Network(), c.RemoteAddr().String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgc = newUDPConn(dupFD, cli.el, c.LocalAddr(), sockAddr, true)\n\tdefault:\n\t\treturn nil, errorx.ErrUnsupportedProtocol\n\t}\n\tgc.ctx = ctx\n\n\tconnOpened := make(chan struct{})\n\tccb := &connWithCallback{c: gc, cb: func() {\n\t\tclose(connOpened)\n\t}}\n\terr = cli.el.poller.Trigger(queue.HighPriority, cli.el.register, ccb)\n\tif err != nil {\n\t\tgc.Close()\n\t\treturn nil, err\n\t}\n\n\t<-connOpened\n\treturn gc, nil\n}\n"
        },
        {
          "name": "client_windows.go",
          "type": "blob",
          "size": 5.5625,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"golang.org/x/sync/errgroup\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\ntype Client struct {\n\topts *Options\n\tel   *eventloop\n}\n\nfunc NewClient(eh EventHandler, opts ...Option) (cli *Client, err error) {\n\toptions := loadOptions(opts...)\n\tcli = &Client{opts: options}\n\n\tlogger, logFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tif options.Logger == nil {\n\t\tif options.LogPath != \"\" {\n\t\t\tlogger, logFlusher, _ = logging.CreateLoggerAsLocalFile(options.LogPath, options.LogLevel)\n\t\t}\n\t\toptions.Logger = logger\n\t} else {\n\t\tlogger = options.Logger\n\t\tlogFlusher = nil\n\t}\n\tlogging.SetDefaultLoggerAndFlusher(logger, logFlusher)\n\n\trootCtx, shutdown := context.WithCancel(context.Background())\n\teg, ctx := errgroup.WithContext(rootCtx)\n\teng := &engine{\n\t\tlisteners:    []*listener{},\n\t\topts:         options,\n\t\tturnOff:      shutdown,\n\t\teventHandler: eh,\n\t\tconcurrency: struct {\n\t\t\t*errgroup.Group\n\t\t\tctx context.Context\n\t\t}{eg, ctx},\n\t}\n\tcli.el = &eventloop{\n\t\tch:           make(chan any, 1024),\n\t\teng:          eng,\n\t\tconnections:  make(map[*conn]struct{}),\n\t\teventHandler: eh,\n\t}\n\treturn\n}\n\nfunc (cli *Client) Start() error {\n\tcli.el.eventHandler.OnBoot(Engine{cli.el.eng})\n\tcli.el.eng.concurrency.Go(cli.el.run)\n\tif cli.opts.Ticker {\n\t\tctx := cli.el.eng.concurrency.ctx\n\t\tcli.el.eng.concurrency.Go(func() error {\n\t\t\tcli.el.ticker(ctx)\n\t\t\treturn nil\n\t\t})\n\t}\n\tlogging.Debugf(\"default logging level is %s\", logging.LogLevel())\n\treturn nil\n}\n\nfunc (cli *Client) Stop() (err error) {\n\tcli.el.ch <- errorx.ErrEngineShutdown\n\terr = cli.el.eng.concurrency.Wait()\n\tcli.el.eventHandler.OnShutdown(Engine{cli.el.eng})\n\tlogging.Cleanup()\n\treturn\n}\n\nvar (\n\tmu           sync.RWMutex\n\tunixAddrDirs = make(map[string]string)\n)\n\n// unixAddr uses os.MkdirTemp to get a name that is unique.\nfunc unixAddr(addr string) string {\n\t// Pass an empty pattern to get a directory name that is as short as possible.\n\t// If we end up with a name longer than the sun_path field in the sockaddr_un\n\t// struct, we won't be able to make the syscall to open the socket.\n\td, err := os.MkdirTemp(\"\", \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttmpAddr := filepath.Join(d, addr)\n\tmu.Lock()\n\tunixAddrDirs[tmpAddr] = d\n\tmu.Unlock()\n\n\treturn tmpAddr\n}\n\nfunc (cli *Client) Dial(network, addr string) (Conn, error) {\n\treturn cli.DialContext(network, addr, nil)\n}\n\nfunc (cli *Client) DialContext(network, addr string, ctx any) (Conn, error) {\n\tvar (\n\t\tc   net.Conn\n\t\terr error\n\t)\n\tif network == \"unix\" {\n\t\tladdr, _ := net.ResolveUnixAddr(network, unixAddr(addr))\n\t\traddr, _ := net.ResolveUnixAddr(network, addr)\n\t\tc, err = net.DialUnix(network, laddr, raddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tc, err = net.Dial(network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn cli.EnrollContext(c, ctx)\n}\n\nfunc (cli *Client) Enroll(nc net.Conn) (gc Conn, err error) {\n\treturn cli.EnrollContext(nc, nil)\n}\n\nfunc (cli *Client) EnrollContext(nc net.Conn, ctx any) (gc Conn, err error) {\n\tconnOpened := make(chan struct{})\n\tswitch v := nc.(type) {\n\tcase *net.TCPConn:\n\t\tif cli.opts.TCPNoDelay == TCPNoDelay {\n\t\t\tif err = v.SetNoDelay(true); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif cli.opts.TCPKeepAlive > 0 {\n\t\t\tif err = v.SetKeepAlive(true); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = v.SetKeepAlivePeriod(cli.opts.TCPKeepAlive); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc := newTCPConn(nc, cli.el)\n\t\tc.SetContext(ctx)\n\t\tcli.el.ch <- &openConn{c: c, cb: func() { close(connOpened) }}\n\t\tgo func(c *conn, tc net.Conn, el *eventloop) {\n\t\t\tvar buffer [0x10000]byte\n\t\t\tfor {\n\t\t\t\tn, err := tc.Read(buffer[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tel.ch <- &netErr{c, err}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tel.ch <- packTCPConn(c, buffer[:n])\n\t\t\t}\n\t\t}(c, nc, cli.el)\n\t\tgc = c\n\tcase *net.UnixConn:\n\t\tc := newTCPConn(nc, cli.el)\n\t\tc.SetContext(ctx)\n\t\tcli.el.ch <- &openConn{c: c, cb: func() { close(connOpened) }}\n\t\tgo func(c *conn, uc net.Conn, el *eventloop) {\n\t\t\tvar buffer [0x10000]byte\n\t\t\tfor {\n\t\t\t\tn, err := uc.Read(buffer[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tel.ch <- &netErr{c, err}\n\t\t\t\t\tmu.RLock()\n\t\t\t\t\ttmpDir := unixAddrDirs[uc.LocalAddr().String()]\n\t\t\t\t\tmu.RUnlock()\n\t\t\t\t\tif err := os.RemoveAll(tmpDir); err != nil {\n\t\t\t\t\t\tlogging.Errorf(\"failed to remove temporary directory for unix local address: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tel.ch <- packTCPConn(c, buffer[:n])\n\t\t\t}\n\t\t}(c, nc, cli.el)\n\t\tgc = c\n\tcase *net.UDPConn:\n\t\tc := newUDPConn(cli.el, nil, nc.LocalAddr(), nc.RemoteAddr())\n\t\tc.SetContext(ctx)\n\t\tc.rawConn = nc\n\t\tcli.el.ch <- &openConn{c: c, cb: func() { close(connOpened) }}\n\t\tgo func(uc net.Conn, el *eventloop) {\n\t\t\tvar buffer [0x10000]byte\n\t\t\tfor {\n\t\t\t\tn, err := uc.Read(buffer[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tc := newUDPConn(cli.el, nil, uc.LocalAddr(), uc.RemoteAddr())\n\t\t\t\tc.SetContext(ctx)\n\t\t\t\tc.rawConn = uc\n\t\t\t\tel.ch <- packUDPConn(c, buffer[:n])\n\t\t\t}\n\t\t}(nc, cli.el)\n\t\tgc = c\n\tdefault:\n\t\treturn nil, errorx.ErrUnsupportedProtocol\n\t}\n\n\t<-connOpened\n\treturn\n}\n"
        },
        {
          "name": "conn_map.go",
          "type": "blob",
          "size": 1.60546875,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build (darwin || dragonfly || freebsd || linux || netbsd || openbsd) && !gc_opt\n\npackage gnet\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/panjf2000/gnet/v2/internal/gfd\"\n)\n\ntype connMatrix struct {\n\tconnCount int32\n\tconnMap   map[int]*conn\n}\n\nfunc (cm *connMatrix) init() {\n\tcm.connMap = make(map[int]*conn)\n}\n\nfunc (cm *connMatrix) iterate(f func(*conn) bool) {\n\tfor _, c := range cm.connMap {\n\t\tif c != nil {\n\t\t\tif !f(c) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (cm *connMatrix) incCount(_ int, delta int32) {\n\tatomic.AddInt32(&cm.connCount, delta)\n}\n\nfunc (cm *connMatrix) loadCount() (n int32) {\n\treturn atomic.LoadInt32(&cm.connCount)\n}\n\nfunc (cm *connMatrix) addConn(c *conn, index int) {\n\tc.gfd = gfd.NewGFD(c.fd, index, 0, 0)\n\tcm.connMap[c.fd] = c\n\tcm.incCount(0, 1)\n}\n\nfunc (cm *connMatrix) delConn(c *conn) {\n\tdelete(cm.connMap, c.fd)\n\tcm.incCount(0, -1)\n}\n\nfunc (cm *connMatrix) getConn(fd int) *conn {\n\treturn cm.connMap[fd]\n}\n\n/*\nfunc (cm *connMatrix) getConnByGFD(fd gfd.GFD) *conn {\n\treturn cm.connMap[fd.Fd()]\n}\n*/\n"
        },
        {
          "name": "conn_matrix.go",
          "type": "blob",
          "size": 4.1787109375,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build (darwin || dragonfly || freebsd || linux || netbsd || openbsd) && gc_opt\n\npackage gnet\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/panjf2000/gnet/v2/internal/gfd\"\n)\n\ntype connMatrix struct {\n\tdisableCompact bool                          // disable compaction when it is true\n\tconnCounts     [gfd.ConnMatrixRowMax]int32   // number of active connections in event-loop\n\trow            int                           // next available row index\n\tcolumn         int                           // next available column index\n\ttable          [gfd.ConnMatrixRowMax][]*conn // connection matrix of *conn, multiple slices\n\tfd2gfd         map[int]gfd.GFD               // fd -> gfd.GFD\n}\n\nfunc (cm *connMatrix) init() {\n\tcm.fd2gfd = make(map[int]gfd.GFD)\n}\n\nfunc (cm *connMatrix) iterate(f func(*conn) bool) {\n\tcm.disableCompact = true\n\tdefer func() { cm.disableCompact = false }()\n\tfor _, conns := range cm.table {\n\t\tfor _, c := range conns {\n\t\t\tif c != nil {\n\t\t\t\tif !f(c) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (cm *connMatrix) incCount(row int, delta int32) {\n\tatomic.AddInt32(&cm.connCounts[row], delta)\n}\n\nfunc (cm *connMatrix) loadCount() (n int32) {\n\tfor i := 0; i < len(cm.connCounts); i++ {\n\t\tn += atomic.LoadInt32(&cm.connCounts[i])\n\t}\n\treturn\n}\n\nfunc (cm *connMatrix) addConn(c *conn, index int) {\n\tif cm.row >= gfd.ConnMatrixRowMax {\n\t\treturn\n\t}\n\n\tif cm.table[cm.row] == nil {\n\t\tcm.table[cm.row] = make([]*conn, gfd.ConnMatrixColumnMax)\n\t}\n\n\tc.gfd = gfd.NewGFD(c.fd, index, cm.row, cm.column)\n\tcm.fd2gfd[c.fd] = c.gfd\n\tcm.table[cm.row][cm.column] = c\n\tcm.incCount(cm.row, 1)\n\n\tif cm.column++; cm.column == gfd.ConnMatrixColumnMax {\n\t\tcm.row++\n\t\tcm.column = 0\n\t}\n}\n\nfunc (cm *connMatrix) delConn(c *conn) {\n\tcfd, cgfd := c.fd, c.gfd\n\n\tdelete(cm.fd2gfd, cfd)\n\tcm.incCount(cgfd.ConnMatrixRow(), -1)\n\tif cm.connCounts[cgfd.ConnMatrixRow()] == 0 {\n\t\tcm.table[cgfd.ConnMatrixRow()] = nil\n\t} else {\n\t\tcm.table[cgfd.ConnMatrixRow()][cgfd.ConnMatrixColumn()] = nil\n\t}\n\tif cm.row > cgfd.ConnMatrixRow() || cm.column > cgfd.ConnMatrixColumn() {\n\t\tcm.row, cm.column = cgfd.ConnMatrixRow(), cgfd.ConnMatrixColumn()\n\t}\n\n\t// Locate the last *conn in table and move it to the deleted location.\n\n\tif cm.disableCompact || cm.table[cgfd.ConnMatrixRow()] == nil { // the deleted *conn is the last one, do nothing here.\n\t\treturn\n\t}\n\n\t// Traverse backward to find the first non-empty point in the matrix until we reach the deleted position.\n\tfor row := gfd.ConnMatrixRowMax - 1; row >= cgfd.ConnMatrixRow(); row-- {\n\t\tif cm.connCounts[row] == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tcolumnMin := -1\n\t\tif row == cgfd.ConnMatrixRow() {\n\t\t\tcolumnMin = cgfd.ConnMatrixColumn()\n\t\t}\n\t\tfor column := gfd.ConnMatrixColumnMax - 1; column > columnMin; column-- {\n\t\t\tif cm.table[row][column] == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tgFd := cm.table[row][column].gfd\n\t\t\tgFd.UpdateIndexes(cgfd.ConnMatrixRow(), cgfd.ConnMatrixColumn())\n\t\t\tcm.table[row][column].gfd = gFd\n\t\t\tcm.fd2gfd[gFd.Fd()] = gFd\n\t\t\tcm.table[cgfd.ConnMatrixRow()][cgfd.ConnMatrixColumn()] = cm.table[row][column]\n\t\t\tcm.incCount(row, -1)\n\t\t\tcm.incCount(cgfd.ConnMatrixRow(), 1)\n\n\t\t\tif cm.connCounts[row] == 0 {\n\t\t\t\tcm.table[row] = nil\n\t\t\t} else {\n\t\t\t\tcm.table[row][column] = nil\n\t\t\t}\n\n\t\t\tcm.row, cm.column = row, column\n\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (cm *connMatrix) getConn(fd int) *conn {\n\tgFD, ok := cm.fd2gfd[fd]\n\tif !ok {\n\t\treturn nil\n\t}\n\tif cm.table[gFD.ConnMatrixRow()] == nil {\n\t\treturn nil\n\t}\n\treturn cm.table[gFD.ConnMatrixRow()][gFD.ConnMatrixColumn()]\n}\n\n/*\nfunc (cm *connMatrix) getConnByGFD(fd gfd.GFD) *conn {\n\tif cm.table[fd.ConnMatrixRow()] == nil {\n\t\treturn nil\n\t}\n\treturn cm.table[fd.ConnMatrixRow()][fd.ConnMatrixColumn()]\n}\n*/\n"
        },
        {
          "name": "conn_matrix_test.go",
          "type": "blob",
          "size": 2.54296875,
          "content": "//go:build (darwin || dragonfly || freebsd || linux || netbsd || openbsd) && gc_opt\n\npackage gnet\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n\n\tgoPool \"github.com/panjf2000/gnet/v2/pkg/pool/goroutine\"\n)\n\nvar testVastConns = false\n\nfunc TestConnMatrix(t *testing.T) {\n\tt.Run(\"1k-connections\", func(t *testing.T) {\n\t\ttestConnMatrix(t, 1000)\n\t})\n\tt.Run(\"10k-connections\", func(t *testing.T) {\n\t\ttestConnMatrix(t, 10000)\n\t})\n\tt.Run(\"100k-connections\", func(t *testing.T) {\n\t\tif !testVastConns {\n\t\t\tt.Skip(\"skipped because testVastConns is set to false\")\n\t\t}\n\t\ttestConnMatrix(t, 100000)\n\t})\n\tt.Run(\"1m-connections\", func(t *testing.T) {\n\t\tif !testVastConns {\n\t\t\tt.Skip(\"skipped because testVastConns is set to false\")\n\t\t}\n\t\ttestConnMatrix(t, 1000000)\n\t})\n}\n\nconst (\n\tactionAdd = iota + 1\n\tactionDel\n)\n\ntype handleConn struct {\n\tc      *conn\n\taction int\n}\n\nfunc testConnMatrix(t *testing.T, n int) {\n\thandleConns := make(chan *handleConn, 1024)\n\tconnections := connMatrix{}\n\tconnections.init()\n\tel := eventloop{engine: &engine{opts: &Options{}}}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tfor i := 0; i < n+n/2; i++ {\n\t\t\tv := <-handleConns\n\t\t\tswitch v.action {\n\t\t\tcase actionAdd:\n\t\t\t\tconnections.addConn(v.c, 0)\n\t\t\tcase actionDel:\n\t\t\t\tconnections.delConn(v.c)\n\t\t\t}\n\t\t}\n\t\tclose(done)\n\t}()\n\n\tpool := goPool.Default()\n\tfor i := 0; i < n; i++ {\n\t\tc := newTCPConn(i, &el, &unix.SockaddrInet4{}, &net.TCPAddr{}, &net.TCPAddr{})\n\t\thandleConns <- &handleConn{c, actionAdd}\n\t\tif i%2 == 0 {\n\t\t\tpool.Submit(func() {\n\t\t\t\thandleConns <- &handleConn{c, actionDel}\n\t\t\t})\n\t\t}\n\t}\n\tm := n / 2\n\n\t<-done\n\tif count := connections.loadCount(); count != int32(n)/2 {\n\t\tt.Fatalf(\"unexpected conn count %d, expected %d\", count, int32(n)/2)\n\t}\n\n\tfor i := 0; i < len(connections.table); i++ {\n\t\tif connections.connCounts[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor j := 0; j < len(connections.table[i]) && m > 0; j++ {\n\t\t\tm--\n\t\t\tc := connections.table[i][j]\n\t\t\tif c == nil {\n\t\t\t\tt.Fatalf(\"unexpected nil connection at row %d, column %d\", i, j)\n\t\t\t}\n\t\t\tif c.fd != c.gfd.Fd() {\n\t\t\t\tt.Fatalf(\"unexpected fd %d, expected fd %d\", c.gfd.Fd(), c.fd)\n\t\t\t}\n\t\t\tif i != c.gfd.ConnMatrixRow() || j != c.gfd.ConnMatrixColumn() {\n\t\t\t\tt.Fatalf(\"unexpected row %d, column %d, expected row %d, column %d\",\n\t\t\t\t\tc.gfd.ConnMatrixRow(), c.gfd.ConnMatrixColumn(), i, j)\n\t\t\t}\n\t\t\tgfd, ok := connections.fd2gfd[c.fd]\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"missing gfd for fd %d\", c.fd)\n\t\t\t}\n\t\t\tif gfd != c.gfd {\n\t\t\t\tt.Fatalf(\"expected gfd: %v, but got gfd: %v\", c.gfd, gfd)\n\t\t\t}\n\t\t}\n\t}\n\n\tt.Log(\"connMatrix remains compact after many additions and deletions, test done!\")\n}\n"
        },
        {
          "name": "connection_bsd.go",
          "type": "blob",
          "size": 1.984375,
          "content": "// Copyright (c) 2021 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"io\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n)\n\nfunc (c *conn) processIO(_ int, filter netpoll.IOEvent, flags netpoll.IOFlags) (err error) {\n\tel := c.loop\n\tswitch filter {\n\tcase unix.EVFILT_READ:\n\t\terr = el.read(c)\n\tcase unix.EVFILT_WRITE:\n\t\terr = el.write(c)\n\t}\n\t// EV_EOF indicates that the remote has closed the connection.\n\t// We check for EV_EOF after processing the read/write event\n\t// to ensure that nothing is left out on this event filter.\n\tif flags&unix.EV_EOF != 0 && c.opened && err == nil {\n\t\tswitch filter {\n\t\tcase unix.EVFILT_READ:\n\t\t\t// Received the event of EVFILT_READ|EV_EOF, but the previous eventloop.read\n\t\t\t// failed to drain the socket buffer, so we make sure we get it done this time.\n\t\t\tc.isEOF = true\n\t\t\terr = el.read(c)\n\t\tcase unix.EVFILT_WRITE:\n\t\t\t// On macOS, the kqueue in either LT or ET mode will notify with one event for the\n\t\t\t// EOF of the TCP remote: EVFILT_READ|EV_ADD|EV_CLEAR|EV_EOF. But for some reason,\n\t\t\t// two events will be issued in ET mode for the EOF of the Unix remote in this order:\n\t\t\t// 1) EVFILT_WRITE|EV_ADD|EV_CLEAR|EV_EOF, 2) EVFILT_READ|EV_ADD|EV_CLEAR|EV_EOF.\n\t\t\terr = el.write(c)\n\t\tdefault:\n\t\t\tc.outboundBuffer.Release() // don't bother to write to a connection that is already broken\n\t\t\terr = el.close(c, io.EOF)\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "connection_linux.go",
          "type": "blob",
          "size": 2.541015625,
          "content": "/*\n * Copyright (c) 2021 The Gnet Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage gnet\n\nimport (\n\t\"io\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n)\n\nfunc (c *conn) processIO(_ int, ev netpoll.IOEvent, _ netpoll.IOFlags) error {\n\tel := c.loop\n\t// First check for any unexpected non-IO events.\n\t// For these events we just close the connection directly.\n\tif ev&(netpoll.ErrEvents|unix.EPOLLRDHUP) != 0 && ev&netpoll.ReadWriteEvents == 0 {\n\t\tc.outboundBuffer.Release() // don't bother to write to a connection that is already broken\n\t\treturn el.close(c, io.EOF)\n\t}\n\t// Secondly, check for EPOLLOUT before EPOLLIN, the former has a higher priority\n\t// than the latter regardless of the aliveness of the current connection:\n\t//\n\t// 1. When the connection is alive and the system is overloaded, we want to\n\t// offload the incoming traffic by writing all pending data back to the remotes\n\t// before continuing to read and handle requests.\n\t// 2. When the connection is dead, we need to try writing any pending data back\n\t// to the remote first and then close the connection.\n\t//\n\t// We perform eventloop.write for EPOLLOUT because it can take good care of either case.\n\tif ev&(netpoll.WriteEvents|netpoll.ErrEvents) != 0 {\n\t\tif err := el.write(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Check for EPOLLIN before EPOLLRDHUP in case that there are pending data in\n\t// the socket buffer.\n\tif ev&(netpoll.ReadEvents|netpoll.ErrEvents) != 0 {\n\t\tif err := el.read(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Ultimately, check for EPOLLRDHUP, this event indicates that the remote has\n\t// either closed connection or shut down the writing half of the connection.\n\tif ev&unix.EPOLLRDHUP != 0 && c.opened {\n\t\tif ev&unix.EPOLLIN == 0 { // unreadable EPOLLRDHUP, close the connection directly\n\t\t\treturn el.close(c, io.EOF)\n\t\t}\n\t\t// Received the event of EPOLLIN|EPOLLRDHUP, but the previous eventloop.read\n\t\t// failed to drain the socket buffer, so we ensure to get it done this time.\n\t\tc.isEOF = true\n\t\treturn el.read(c)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "connection_unix.go",
          "type": "blob",
          "size": 12.9658203125,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/internal/gfd\"\n\t\"github.com/panjf2000/gnet/v2/pkg/bs\"\n\t\"github.com/panjf2000/gnet/v2/pkg/buffer/elastic\"\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\tgio \"github.com/panjf2000/gnet/v2/pkg/io\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\tbsPool \"github.com/panjf2000/gnet/v2/pkg/pool/byteslice\"\n\t\"github.com/panjf2000/gnet/v2/pkg/queue\"\n\t\"github.com/panjf2000/gnet/v2/pkg/socket\"\n)\n\ntype conn struct {\n\tfd             int                    // file descriptor\n\tgfd            gfd.GFD                // gnet file descriptor\n\tctx            any                    // user-defined context\n\tremote         unix.Sockaddr          // remote socket address\n\tlocalAddr      net.Addr               // local addr\n\tremoteAddr     net.Addr               // remote addr\n\tloop           *eventloop             // connected event-loop\n\toutboundBuffer elastic.Buffer         // buffer for data that is eligible to be sent to the remote\n\tpollAttachment netpoll.PollAttachment // connection attachment for poller\n\tinboundBuffer  elastic.RingBuffer     // buffer for leftover data from the remote\n\tbuffer         []byte                 // buffer for the latest bytes\n\tcache          []byte                 // temporary cache for the inbound data\n\tisDatagram     bool                   // UDP protocol\n\topened         bool                   // connection opened event fired\n\tisEOF          bool                   // whether the connection has reached EOF\n}\n\nfunc newTCPConn(fd int, el *eventloop, sa unix.Sockaddr, localAddr, remoteAddr net.Addr) (c *conn) {\n\tc = &conn{\n\t\tfd:             fd,\n\t\tremote:         sa,\n\t\tloop:           el,\n\t\tlocalAddr:      localAddr,\n\t\tremoteAddr:     remoteAddr,\n\t\tpollAttachment: netpoll.PollAttachment{FD: fd},\n\t}\n\tc.pollAttachment.Callback = c.processIO\n\tc.outboundBuffer.Reset(el.engine.opts.WriteBufferCap)\n\treturn\n}\n\nfunc newUDPConn(fd int, el *eventloop, localAddr net.Addr, sa unix.Sockaddr, connected bool) (c *conn) {\n\tc = &conn{\n\t\tfd:             fd,\n\t\tgfd:            gfd.NewGFD(fd, el.idx, 0, 0),\n\t\tremote:         sa,\n\t\tloop:           el,\n\t\tlocalAddr:      localAddr,\n\t\tremoteAddr:     socket.SockaddrToUDPAddr(sa),\n\t\tisDatagram:     true,\n\t\tpollAttachment: netpoll.PollAttachment{FD: fd, Callback: el.readUDP},\n\t}\n\tif connected {\n\t\tc.remote = nil\n\t}\n\treturn\n}\n\nfunc (c *conn) release() {\n\tc.opened = false\n\tc.isEOF = false\n\tc.ctx = nil\n\tc.buffer = nil\n\tif addr, ok := c.localAddr.(*net.TCPAddr); ok && len(c.loop.listeners) == 0 && len(addr.Zone) > 0 {\n\t\tbsPool.Put(bs.StringToBytes(addr.Zone))\n\t}\n\tif addr, ok := c.remoteAddr.(*net.TCPAddr); ok && len(addr.Zone) > 0 {\n\t\tbsPool.Put(bs.StringToBytes(addr.Zone))\n\t}\n\tif addr, ok := c.localAddr.(*net.UDPAddr); ok && len(c.loop.listeners) == 0 && len(addr.Zone) > 0 {\n\t\tbsPool.Put(bs.StringToBytes(addr.Zone))\n\t}\n\tif addr, ok := c.remoteAddr.(*net.UDPAddr); ok && len(addr.Zone) > 0 {\n\t\tbsPool.Put(bs.StringToBytes(addr.Zone))\n\t}\n\tc.localAddr = nil\n\tc.remoteAddr = nil\n\tif !c.isDatagram {\n\t\tc.remote = nil\n\t\tc.inboundBuffer.Done()\n\t\tc.outboundBuffer.Release()\n\t}\n}\n\nfunc (c *conn) open(buf []byte) error {\n\tif c.isDatagram && c.remote == nil {\n\t\treturn unix.Send(c.fd, buf, 0)\n\t}\n\n\tfor {\n\t\tn, err := unix.Write(c.fd, buf)\n\t\tif err != nil {\n\t\t\tif err == unix.EAGAIN {\n\t\t\t\t_, _ = c.outboundBuffer.Write(buf)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tbuf = buf[n:]\n\t\tif len(buf) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *conn) write(data []byte) (n int, err error) {\n\tisET := c.loop.engine.opts.EdgeTriggeredIO\n\tn = len(data)\n\t// If there is pending data in outbound buffer,\n\t// the current data ought to be appended to the\n\t// outbound buffer for maintaining the sequence\n\t// of network packets.\n\tif !c.outboundBuffer.IsEmpty() {\n\t\t_, _ = c.outboundBuffer.Write(data)\n\t\treturn\n\t}\n\n\tvar sent int\nloop:\n\tif sent, err = unix.Write(c.fd, data); err != nil {\n\t\t// A temporary error occurs, append the data to outbound buffer,\n\t\t// writing it back to the remote in the next round for LT mode.\n\t\tif err == unix.EAGAIN {\n\t\t\t_, err = c.outboundBuffer.Write(data)\n\t\t\tif !isET {\n\t\t\t\terr = c.loop.poller.ModReadWrite(&c.pollAttachment, false)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif err := c.loop.close(c, os.NewSyscallError(\"write\", err)); err != nil {\n\t\t\tlogging.Errorf(\"failed to close connection(fd=%d,remote=%+v) on conn.write: %v\",\n\t\t\t\tc.fd, c.remoteAddr, err)\n\t\t}\n\t\treturn 0, os.NewSyscallError(\"write\", err)\n\t}\n\tdata = data[sent:]\n\tif isET && len(data) > 0 {\n\t\tgoto loop\n\t}\n\t// Failed to send all data back to the remote, buffer the leftover data for the next round.\n\tif len(data) > 0 {\n\t\t_, _ = c.outboundBuffer.Write(data)\n\t\terr = c.loop.poller.ModReadWrite(&c.pollAttachment, false)\n\t}\n\n\treturn\n}\n\nfunc (c *conn) writev(bs [][]byte) (n int, err error) {\n\tisET := c.loop.engine.opts.EdgeTriggeredIO\n\n\tfor _, b := range bs {\n\t\tn += len(b)\n\t}\n\n\t// If there is pending data in outbound buffer,\n\t// the current data ought to be appended to the\n\t// outbound buffer for maintaining the sequence\n\t// of network packets.\n\tif !c.outboundBuffer.IsEmpty() {\n\t\t_, _ = c.outboundBuffer.Writev(bs)\n\t\treturn\n\t}\n\n\tremaining := n\n\tvar sent int\nloop:\n\tif sent, err = gio.Writev(c.fd, bs); err != nil {\n\t\t// A temporary error occurs, append the data to outbound buffer,\n\t\t// writing it back to the remote in the next round for LT mode.\n\t\tif err == unix.EAGAIN {\n\t\t\t_, err = c.outboundBuffer.Writev(bs)\n\t\t\tif !isET {\n\t\t\t\terr = c.loop.poller.ModReadWrite(&c.pollAttachment, false)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif err := c.loop.close(c, os.NewSyscallError(\"writev\", err)); err != nil {\n\t\t\tlogging.Errorf(\"failed to close connection(fd=%d,remote=%+v) on conn.writev: %v\",\n\t\t\t\tc.fd, c.remoteAddr, err)\n\t\t}\n\t\treturn 0, os.NewSyscallError(\"writev\", err)\n\t}\n\tpos := len(bs)\n\tif remaining -= sent; remaining > 0 {\n\t\tfor i := range bs {\n\t\t\tbn := len(bs[i])\n\t\t\tif sent < bn {\n\t\t\t\tbs[i] = bs[i][sent:]\n\t\t\t\tpos = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsent -= bn\n\t\t}\n\t}\n\tbs = bs[pos:]\n\tif isET && remaining > 0 {\n\t\tgoto loop\n\t}\n\n\t// Failed to send all data back to the remote, buffer the leftover data for the next round.\n\tif remaining > 0 {\n\t\t_, _ = c.outboundBuffer.Writev(bs)\n\t\terr = c.loop.poller.ModReadWrite(&c.pollAttachment, false)\n\t}\n\n\treturn\n}\n\ntype asyncWriteHook struct {\n\tcallback AsyncCallback\n\tdata     []byte\n}\n\nfunc (c *conn) asyncWrite(a any) (err error) {\n\thook := a.(*asyncWriteHook)\n\tdefer func() {\n\t\tif hook.callback != nil {\n\t\t\t_ = hook.callback(c, err)\n\t\t}\n\t}()\n\n\tif !c.opened {\n\t\treturn net.ErrClosed\n\t}\n\n\t_, err = c.write(hook.data)\n\treturn\n}\n\ntype asyncWritevHook struct {\n\tcallback AsyncCallback\n\tdata     [][]byte\n}\n\nfunc (c *conn) asyncWritev(a any) (err error) {\n\thook := a.(*asyncWritevHook)\n\tdefer func() {\n\t\tif hook.callback != nil {\n\t\t\t_ = hook.callback(c, err)\n\t\t}\n\t}()\n\n\tif !c.opened {\n\t\treturn net.ErrClosed\n\t}\n\n\t_, err = c.writev(hook.data)\n\treturn\n}\n\nfunc (c *conn) sendTo(buf []byte) error {\n\tif c.remote == nil {\n\t\treturn unix.Send(c.fd, buf, 0)\n\t}\n\treturn unix.Sendto(c.fd, buf, 0, c.remote)\n}\n\nfunc (c *conn) resetBuffer() {\n\tc.buffer = c.buffer[:0]\n\tc.inboundBuffer.Reset()\n\tc.inboundBuffer.Done()\n}\n\nfunc (c *conn) Read(p []byte) (n int, err error) {\n\tif c.inboundBuffer.IsEmpty() {\n\t\tn = copy(p, c.buffer)\n\t\tc.buffer = c.buffer[n:]\n\t\tif n == 0 && len(p) > 0 {\n\t\t\terr = io.ErrShortBuffer\n\t\t}\n\t\treturn\n\t}\n\tn, _ = c.inboundBuffer.Read(p)\n\tif n == len(p) {\n\t\treturn\n\t}\n\tm := copy(p[n:], c.buffer)\n\tn += m\n\tc.buffer = c.buffer[m:]\n\treturn\n}\n\nfunc (c *conn) Next(n int) (buf []byte, err error) {\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + len(c.buffer); n > totalLen {\n\t\treturn nil, io.ErrShortBuffer\n\t} else if n <= 0 {\n\t\tn = totalLen\n\t}\n\n\tif c.inboundBuffer.IsEmpty() {\n\t\tbuf = c.buffer[:n]\n\t\tc.buffer = c.buffer[n:]\n\t\treturn\n\t}\n\n\tbuf = bsPool.Get(n)\n\t_, err = c.Read(buf)\n\treturn\n}\n\nfunc (c *conn) Peek(n int) (buf []byte, err error) {\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + len(c.buffer); n > totalLen {\n\t\treturn nil, io.ErrShortBuffer\n\t} else if n <= 0 {\n\t\tn = totalLen\n\t}\n\n\tif c.inboundBuffer.IsEmpty() {\n\t\treturn c.buffer[:n], err\n\t}\n\n\thead, tail := c.inboundBuffer.Peek(n)\n\tif len(head) == n {\n\t\treturn head, err\n\t}\n\tbuf = bsPool.Get(n)[:0]\n\tbuf = append(buf, head...)\n\tbuf = append(buf, tail...)\n\tif inBufferLen >= n {\n\t\treturn\n\t}\n\n\tremaining := n - inBufferLen\n\tbuf = append(buf, c.buffer[:remaining]...)\n\tc.cache = buf\n\treturn\n}\n\nfunc (c *conn) Discard(n int) (int, error) {\n\tif len(c.cache) > 0 {\n\t\tbsPool.Put(c.cache)\n\t\tc.cache = nil\n\t}\n\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + len(c.buffer); n >= totalLen || n <= 0 {\n\t\tc.resetBuffer()\n\t\treturn totalLen, nil\n\t}\n\n\tif c.inboundBuffer.IsEmpty() {\n\t\tc.buffer = c.buffer[n:]\n\t\treturn n, nil\n\t}\n\n\tdiscarded, _ := c.inboundBuffer.Discard(n)\n\tif discarded < inBufferLen {\n\t\treturn discarded, nil\n\t}\n\n\tremaining := n - inBufferLen\n\tc.buffer = c.buffer[remaining:]\n\treturn n, nil\n}\n\nfunc (c *conn) Write(p []byte) (int, error) {\n\tif c.isDatagram {\n\t\tif err := c.sendTo(p); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn len(p), nil\n\t}\n\treturn c.write(p)\n}\n\nfunc (c *conn) Writev(bs [][]byte) (int, error) {\n\tif c.isDatagram {\n\t\treturn 0, errorx.ErrUnsupportedOp\n\t}\n\treturn c.writev(bs)\n}\n\nfunc (c *conn) ReadFrom(r io.Reader) (int64, error) {\n\treturn c.outboundBuffer.ReadFrom(r)\n}\n\nfunc (c *conn) WriteTo(w io.Writer) (n int64, err error) {\n\tif !c.inboundBuffer.IsEmpty() {\n\t\tif n, err = c.inboundBuffer.WriteTo(w); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tvar m int\n\tm, err = w.Write(c.buffer)\n\tn += int64(m)\n\tc.buffer = c.buffer[m:]\n\treturn\n}\n\nfunc (c *conn) Flush() error {\n\treturn c.loop.write(c)\n}\n\nfunc (c *conn) InboundBuffered() int {\n\treturn c.inboundBuffer.Buffered() + len(c.buffer)\n}\n\nfunc (c *conn) OutboundBuffered() int {\n\treturn c.outboundBuffer.Buffered()\n}\n\nfunc (c *conn) Context() any         { return c.ctx }\nfunc (c *conn) SetContext(ctx any)   { c.ctx = ctx }\nfunc (c *conn) LocalAddr() net.Addr  { return c.localAddr }\nfunc (c *conn) RemoteAddr() net.Addr { return c.remoteAddr }\n\n// Implementation of Socket interface\n\n// func (c *conn) Gfd() gfd.GFD             { return c.gfd }\n\nfunc (c *conn) Fd() int                        { return c.fd }\nfunc (c *conn) Dup() (fd int, err error)       { return socket.Dup(c.fd) }\nfunc (c *conn) SetReadBuffer(bytes int) error  { return socket.SetRecvBuffer(c.fd, bytes) }\nfunc (c *conn) SetWriteBuffer(bytes int) error { return socket.SetSendBuffer(c.fd, bytes) }\nfunc (c *conn) SetLinger(sec int) error        { return socket.SetLinger(c.fd, sec) }\nfunc (c *conn) SetNoDelay(noDelay bool) error {\n\treturn socket.SetNoDelay(c.fd, func(b bool) int {\n\t\tif b {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t}(noDelay))\n}\n\nfunc (c *conn) SetKeepAlivePeriod(d time.Duration) error {\n\treturn socket.SetKeepAlivePeriod(c.fd, int(d.Seconds()))\n}\n\nfunc (c *conn) AsyncWrite(buf []byte, callback AsyncCallback) error {\n\tif c.isDatagram {\n\t\terr := c.sendTo(buf)\n\t\t// TODO: it will not go asynchronously with UDP, so calling a callback is needless,\n\t\t//  we may remove this branch in the future, please don't rely on the callback\n\t\t// \tto do something important under UDP, if you're working with UDP, just call Conn.Write\n\t\t// \tto send back your data.\n\t\tif callback != nil {\n\t\t\t_ = callback(nil, nil)\n\t\t}\n\t\treturn err\n\t}\n\treturn c.loop.poller.Trigger(queue.HighPriority, c.asyncWrite, &asyncWriteHook{callback, buf})\n}\n\nfunc (c *conn) AsyncWritev(bs [][]byte, callback AsyncCallback) error {\n\tif c.isDatagram {\n\t\treturn errorx.ErrUnsupportedOp\n\t}\n\treturn c.loop.poller.Trigger(queue.HighPriority, c.asyncWritev, &asyncWritevHook{callback, bs})\n}\n\nfunc (c *conn) Wake(callback AsyncCallback) error {\n\treturn c.loop.poller.Trigger(queue.LowPriority, func(_ any) (err error) {\n\t\terr = c.loop.wake(c)\n\t\tif callback != nil {\n\t\t\t_ = callback(c, err)\n\t\t}\n\t\treturn\n\t}, nil)\n}\n\nfunc (c *conn) CloseWithCallback(callback AsyncCallback) error {\n\treturn c.loop.poller.Trigger(queue.LowPriority, func(_ any) (err error) {\n\t\terr = c.loop.close(c, nil)\n\t\tif callback != nil {\n\t\t\t_ = callback(c, err)\n\t\t}\n\t\treturn\n\t}, nil)\n}\n\nfunc (c *conn) Close() error {\n\treturn c.loop.poller.Trigger(queue.LowPriority, func(_ any) (err error) {\n\t\terr = c.loop.close(c, nil)\n\t\treturn\n\t}, nil)\n}\n\nfunc (*conn) SetDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n\nfunc (*conn) SetReadDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n\nfunc (*conn) SetWriteDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n"
        },
        {
          "name": "connection_windows.go",
          "type": "blob",
          "size": 10.7392578125,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/panjf2000/ants/v2\"\n\t\"golang.org/x/sys/windows\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/buffer/elastic\"\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\tbbPool \"github.com/panjf2000/gnet/v2/pkg/pool/bytebuffer\"\n\tbsPool \"github.com/panjf2000/gnet/v2/pkg/pool/byteslice\"\n\tgoPool \"github.com/panjf2000/gnet/v2/pkg/pool/goroutine\"\n)\n\ntype netErr struct {\n\tc   *conn\n\terr error\n}\n\ntype tcpConn struct {\n\tc *conn\n\tb *bbPool.ByteBuffer\n}\n\ntype udpConn struct {\n\tc *conn\n}\n\ntype openConn struct {\n\tc  *conn\n\tcb func()\n}\n\ntype conn struct {\n\tpc            net.PacketConn\n\tctx           any                // user-defined context\n\tloop          *eventloop         // owner event-loop\n\tbuffer        *bbPool.ByteBuffer // reuse memory of inbound data as a temporary buffer\n\tcache         []byte             // temporary cache for the inbound data\n\trawConn       net.Conn           // original connection\n\tlocalAddr     net.Addr           // local server addr\n\tremoteAddr    net.Addr           // remote addr\n\tinboundBuffer elastic.RingBuffer // buffer for data from the remote\n}\n\nfunc packTCPConn(c *conn, buf []byte) *tcpConn {\n\tb := bbPool.Get()\n\t_, _ = b.Write(buf)\n\treturn &tcpConn{c: c, b: b}\n}\n\nfunc unpackTCPConn(tc *tcpConn) *conn {\n\tif tc.c.buffer == nil { // the connection has been closed\n\t\treturn nil\n\t}\n\t_, _ = tc.c.buffer.Write(tc.b.B)\n\tbbPool.Put(tc.b)\n\ttc.b = nil\n\treturn tc.c\n}\n\nfunc packUDPConn(c *conn, buf []byte) *udpConn {\n\t_, _ = c.buffer.Write(buf)\n\treturn &udpConn{c}\n}\n\nfunc newTCPConn(nc net.Conn, el *eventloop) (c *conn) {\n\treturn &conn{\n\t\tloop:       el,\n\t\tbuffer:     bbPool.Get(),\n\t\trawConn:    nc,\n\t\tlocalAddr:  nc.LocalAddr(),\n\t\tremoteAddr: nc.RemoteAddr(),\n\t}\n}\n\nfunc (c *conn) release() {\n\tc.ctx = nil\n\tc.localAddr = nil\n\tif c.rawConn != nil {\n\t\tc.rawConn = nil\n\t\tc.remoteAddr = nil\n\t}\n\tc.inboundBuffer.Done()\n\tbbPool.Put(c.buffer)\n\tc.buffer = nil\n}\n\nfunc newUDPConn(el *eventloop, pc net.PacketConn, localAddr, remoteAddr net.Addr) *conn {\n\treturn &conn{\n\t\tpc:         pc,\n\t\tloop:       el,\n\t\tbuffer:     bbPool.Get(),\n\t\tlocalAddr:  localAddr,\n\t\tremoteAddr: remoteAddr,\n\t}\n}\n\nfunc (c *conn) resetBuffer() {\n\tc.buffer.Reset()\n\tc.inboundBuffer.Reset()\n\tc.inboundBuffer.Done()\n}\n\nfunc (c *conn) Read(p []byte) (n int, err error) {\n\tif c.inboundBuffer.IsEmpty() {\n\t\tn = copy(p, c.buffer.B)\n\t\tc.buffer.B = c.buffer.B[n:]\n\t\tif n == 0 && len(p) > 0 {\n\t\t\terr = io.ErrShortBuffer\n\t\t}\n\t\treturn\n\t}\n\tn, _ = c.inboundBuffer.Read(p)\n\tif n == len(p) {\n\t\treturn\n\t}\n\tm := copy(p[n:], c.buffer.B)\n\tn += m\n\tc.buffer.B = c.buffer.B[m:]\n\treturn\n}\n\nfunc (c *conn) Next(n int) (buf []byte, err error) {\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + c.buffer.Len(); n > totalLen {\n\t\treturn nil, io.ErrShortBuffer\n\t} else if n <= 0 {\n\t\tn = totalLen\n\t}\n\tif c.inboundBuffer.IsEmpty() {\n\t\tbuf = c.buffer.B[:n]\n\t\tc.buffer.B = c.buffer.B[n:]\n\t\treturn\n\t}\n\n\tbuf = bsPool.Get(n)\n\t_, err = c.Read(buf)\n\treturn\n}\n\nfunc (c *conn) Peek(n int) (buf []byte, err error) {\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + c.buffer.Len(); n > totalLen {\n\t\treturn nil, io.ErrShortBuffer\n\t} else if n <= 0 {\n\t\tn = totalLen\n\t}\n\tif c.inboundBuffer.IsEmpty() {\n\t\treturn c.buffer.B[:n], err\n\t}\n\thead, tail := c.inboundBuffer.Peek(n)\n\tif len(head) == n {\n\t\treturn head, err\n\t}\n\tbuf = bsPool.Get(n)[:0]\n\tbuf = append(buf, head...)\n\tbuf = append(buf, tail...)\n\tif inBufferLen >= n {\n\t\treturn\n\t}\n\n\tremaining := n - inBufferLen\n\tbuf = append(buf, c.buffer.B[:remaining]...)\n\tc.cache = buf\n\treturn\n}\n\nfunc (c *conn) Discard(n int) (int, error) {\n\tif len(c.cache) > 0 {\n\t\tbsPool.Put(c.cache)\n\t\tc.cache = nil\n\t}\n\n\tinBufferLen := c.inboundBuffer.Buffered()\n\tif totalLen := inBufferLen + c.buffer.Len(); n >= totalLen || n <= 0 {\n\t\tc.resetBuffer()\n\t\treturn totalLen, nil\n\t}\n\n\tif c.inboundBuffer.IsEmpty() {\n\t\tc.buffer.B = c.buffer.B[n:]\n\t\treturn n, nil\n\t}\n\n\tdiscarded, _ := c.inboundBuffer.Discard(n)\n\tif discarded < inBufferLen {\n\t\treturn discarded, nil\n\t}\n\n\tremaining := n - inBufferLen\n\tc.buffer.B = c.buffer.B[remaining:]\n\treturn n, nil\n}\n\nfunc (c *conn) Write(p []byte) (int, error) {\n\tif c.rawConn == nil && c.pc == nil {\n\t\treturn 0, net.ErrClosed\n\t}\n\tif c.rawConn != nil {\n\t\treturn c.rawConn.Write(p)\n\t}\n\treturn c.pc.WriteTo(p, c.remoteAddr)\n}\n\nfunc (c *conn) Writev(bs [][]byte) (int, error) {\n\tif c.rawConn != nil {\n\t\tbb := bbPool.Get()\n\t\tdefer bbPool.Put(bb)\n\t\tfor i := range bs {\n\t\t\t_, _ = bb.Write(bs[i])\n\t\t}\n\t\treturn c.rawConn.Write(bb.Bytes())\n\t}\n\treturn 0, net.ErrClosed\n}\n\nfunc (c *conn) ReadFrom(r io.Reader) (int64, error) {\n\tif c.rawConn != nil {\n\t\treturn io.Copy(c.rawConn, r)\n\t}\n\treturn 0, net.ErrClosed\n}\n\nfunc (c *conn) WriteTo(w io.Writer) (n int64, err error) {\n\tif !c.inboundBuffer.IsEmpty() {\n\t\tif n, err = c.inboundBuffer.WriteTo(w); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif c.buffer == nil {\n\t\treturn 0, nil\n\t}\n\tdefer c.buffer.Reset()\n\treturn c.buffer.WriteTo(w)\n}\n\nfunc (c *conn) Flush() error {\n\treturn nil\n}\n\nfunc (c *conn) InboundBuffered() int {\n\tif c.buffer == nil {\n\t\treturn 0\n\t}\n\treturn c.inboundBuffer.Buffered() + c.buffer.Len()\n}\n\nfunc (c *conn) OutboundBuffered() int {\n\treturn 0\n}\n\nfunc (c *conn) Context() any         { return c.ctx }\nfunc (c *conn) SetContext(ctx any)   { c.ctx = ctx }\nfunc (c *conn) LocalAddr() net.Addr  { return c.localAddr }\nfunc (c *conn) RemoteAddr() net.Addr { return c.remoteAddr }\n\nfunc (c *conn) Fd() (fd int) {\n\tif c.rawConn == nil {\n\t\treturn -1\n\t}\n\n\trc, err := c.rawConn.(syscall.Conn).SyscallConn()\n\tif err != nil {\n\t\treturn -1\n\t}\n\tif err := rc.Control(func(i uintptr) {\n\t\tfd = int(i)\n\t}); err != nil {\n\t\treturn -1\n\t}\n\treturn\n}\n\nfunc (c *conn) Dup() (fd int, err error) {\n\tif c.rawConn == nil && c.pc == nil {\n\t\treturn -1, net.ErrClosed\n\t}\n\n\tvar (\n\t\tsc syscall.Conn\n\t\tok bool\n\t)\n\tif c.rawConn != nil {\n\t\tsc, ok = c.rawConn.(syscall.Conn)\n\t} else {\n\t\tsc, ok = c.pc.(syscall.Conn)\n\t}\n\n\tif !ok {\n\t\treturn -1, errors.New(\"failed to convert net.Conn to syscall.Conn\")\n\t}\n\trc, err := sc.SyscallConn()\n\tif err != nil {\n\t\treturn -1, errors.New(\"failed to get syscall.RawConn from net.Conn\")\n\t}\n\n\tvar dupHandle windows.Handle\n\te := rc.Control(func(fd uintptr) {\n\t\tprocess := windows.CurrentProcess()\n\t\terr = windows.DuplicateHandle(\n\t\t\tprocess,\n\t\t\twindows.Handle(fd),\n\t\t\tprocess,\n\t\t\t&dupHandle,\n\t\t\t0,\n\t\t\ttrue,\n\t\t\twindows.DUPLICATE_SAME_ACCESS,\n\t\t)\n\t})\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif e != nil {\n\t\treturn -1, e\n\t}\n\n\treturn int(dupHandle), nil\n}\n\nfunc (c *conn) SetReadBuffer(bytes int) error {\n\tif c.rawConn == nil && c.pc == nil {\n\t\treturn net.ErrClosed\n\t}\n\n\tif c.rawConn != nil {\n\t\treturn c.rawConn.(interface{ SetReadBuffer(int) error }).SetReadBuffer(bytes)\n\t}\n\treturn c.pc.(interface{ SetReadBuffer(int) error }).SetReadBuffer(bytes)\n}\n\nfunc (c *conn) SetWriteBuffer(bytes int) error {\n\tif c.rawConn == nil && c.pc == nil {\n\t\treturn net.ErrClosed\n\t}\n\tif c.rawConn != nil {\n\t\treturn c.rawConn.(interface{ SetWriteBuffer(int) error }).SetWriteBuffer(bytes)\n\t}\n\treturn c.pc.(interface{ SetWriteBuffer(int) error }).SetWriteBuffer(bytes)\n}\n\nfunc (c *conn) SetLinger(sec int) error {\n\tif c.rawConn == nil {\n\t\treturn net.ErrClosed\n\t}\n\n\ttc, ok := c.rawConn.(*net.TCPConn)\n\tif !ok {\n\t\treturn errorx.ErrUnsupportedOp\n\t}\n\treturn tc.SetLinger(sec)\n}\n\nfunc (c *conn) SetNoDelay(noDelay bool) error {\n\tif c.rawConn == nil {\n\t\treturn net.ErrClosed\n\t}\n\n\ttc, ok := c.rawConn.(*net.TCPConn)\n\tif !ok {\n\t\treturn errorx.ErrUnsupportedOp\n\t}\n\treturn tc.SetNoDelay(noDelay)\n}\n\nfunc (c *conn) SetKeepAlivePeriod(d time.Duration) error {\n\tif c.rawConn == nil {\n\t\treturn net.ErrClosed\n\t}\n\n\ttc, ok := c.rawConn.(*net.TCPConn)\n\tif !ok || d < 0 {\n\t\treturn errorx.ErrUnsupportedOp\n\t}\n\tif err := tc.SetKeepAlive(true); err != nil {\n\t\treturn err\n\t}\n\tif err := tc.SetKeepAlivePeriod(d); err != nil {\n\t\t_ = tc.SetKeepAlive(false)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype nonBlockingPool struct {\n\t*goPool.Pool\n}\n\nfunc (np *nonBlockingPool) Go(task func()) (err error) {\n\tif err = np.Submit(task); err == ants.ErrPoolOverload {\n\t\tgo task()\n\t}\n\treturn\n}\n\nvar workerPool = nonBlockingPool{Pool: goPool.Default()}\n\n// Gfd return an uninitialized GFD which is not valid,\n// this method is only implemented for compatibility, don't use it on Windows.\n// func (c *conn) Gfd() gfd.GFD { return gfd.GFD{} }\n\nfunc (c *conn) AsyncWrite(buf []byte, cb AsyncCallback) error {\n\t_, err := c.Write(buf)\n\n\tcallback := func() error {\n\t\tif cb != nil {\n\t\t\t_ = cb(c, err)\n\t\t}\n\t\treturn err\n\t}\n\n\tselect {\n\tcase c.loop.ch <- callback:\n\tdefault:\n\t\t// If the event-loop channel is full, asynchronize this operation to avoid blocking the eventloop.\n\t\terr = workerPool.Go(func() {\n\t\t\tc.loop.ch <- callback\n\t\t})\n\t}\n\n\treturn err\n}\n\nfunc (c *conn) AsyncWritev(bs [][]byte, cb AsyncCallback) error {\n\tbuf := bbPool.Get()\n\tfor _, b := range bs {\n\t\t_, _ = buf.Write(b)\n\t}\n\treturn c.AsyncWrite(buf.Bytes(), func(c Conn, err error) error {\n\t\tdefer bbPool.Put(buf)\n\t\tif cb == nil {\n\t\t\treturn err\n\t\t}\n\t\treturn cb(c, err)\n\t})\n}\n\nfunc (c *conn) Wake(cb AsyncCallback) (err error) {\n\twakeFn := func() (err error) {\n\t\terr = c.loop.wake(c)\n\t\tif cb != nil {\n\t\t\t_ = cb(c, err)\n\t\t}\n\t\treturn\n\t}\n\n\tselect {\n\tcase c.loop.ch <- wakeFn:\n\tdefault:\n\t\t// If the event-loop channel is full, asynchronize this operation to avoid blocking the eventloop.\n\t\terr = workerPool.Go(func() {\n\t\t\tc.loop.ch <- wakeFn\n\t\t})\n\t}\n\n\treturn\n}\n\nfunc (c *conn) Close() (err error) {\n\tcloseFn := func() error {\n\t\treturn c.loop.close(c, nil)\n\t}\n\n\tselect {\n\tcase c.loop.ch <- closeFn:\n\tdefault:\n\t\t// If the event-loop channel is full, asynchronize this operation to avoid blocking the eventloop.\n\t\terr = workerPool.Go(func() {\n\t\t\tc.loop.ch <- closeFn\n\t\t})\n\t}\n\n\treturn\n}\n\nfunc (c *conn) CloseWithCallback(cb AsyncCallback) (err error) {\n\tcloseFn := func() (err error) {\n\t\terr = c.loop.close(c, nil)\n\t\tif cb != nil {\n\t\t\t_ = cb(c, err)\n\t\t}\n\t\treturn\n\t}\n\n\tselect {\n\tcase c.loop.ch <- closeFn:\n\tdefault:\n\t\t// If the event-loop channel is full, asynchronize this operation to avoid blocking the eventloop.\n\t\terr = workerPool.Go(func() {\n\t\t\tc.loop.ch <- closeFn\n\t\t})\n\t}\n\n\treturn\n}\n\nfunc (*conn) SetDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n\nfunc (*conn) SetReadDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n\nfunc (*conn) SetWriteDeadline(_ time.Time) error {\n\treturn errorx.ErrUnsupportedOp\n}\n"
        },
        {
          "name": "engine_unix.go",
          "type": "blob",
          "size": 7.5771484375,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\t\"golang.org/x/sync/errgroup\"\n\n\t\"github.com/panjf2000/gnet/v2/internal/gfd\"\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\t\"github.com/panjf2000/gnet/v2/pkg/queue\"\n)\n\ntype engine struct {\n\tlisteners    map[int]*listener // listeners for accepting incoming connections\n\topts         *Options          // options with engine\n\tingress      *eventloop        // main event-loop that monitors all listeners\n\teventLoops   loadBalancer      // event-loops for handling events\n\tinShutdown   atomic.Bool       // whether the engine is in shutdown\n\tturnOff      context.CancelFunc\n\teventHandler EventHandler // user eventHandler\n\tconcurrency  struct {\n\t\t*errgroup.Group\n\n\t\tctx context.Context\n\t}\n}\n\nfunc (eng *engine) isShutdown() bool {\n\treturn eng.inShutdown.Load()\n}\n\n// shutdown signals the engine to shut down.\nfunc (eng *engine) shutdown(err error) {\n\tif err != nil && !errors.Is(err, errorx.ErrEngineShutdown) {\n\t\teng.opts.Logger.Errorf(\"engine is being shutdown with error: %v\", err)\n\t}\n\n\teng.turnOff()\n}\n\nfunc (eng *engine) closeEventLoops() {\n\teng.eventLoops.iterate(func(_ int, el *eventloop) bool {\n\t\tfor _, ln := range el.listeners {\n\t\t\tln.close()\n\t\t}\n\t\t_ = el.poller.Close()\n\t\treturn true\n\t})\n\tif eng.ingress != nil {\n\t\tfor _, ln := range eng.listeners {\n\t\t\tln.close()\n\t\t}\n\t\terr := eng.ingress.poller.Close()\n\t\tif err != nil {\n\t\t\teng.opts.Logger.Errorf(\"failed to close poller when stopping engine: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (eng *engine) runEventLoops(ctx context.Context, numEventLoop int) error {\n\tvar el0 *eventloop\n\tlns := eng.listeners\n\t// Create loops locally and bind the listeners.\n\tfor i := 0; i < numEventLoop; i++ {\n\t\tif i > 0 {\n\t\t\tlns = make(map[int]*listener, len(eng.listeners))\n\t\t\tfor _, l := range eng.listeners {\n\t\t\t\tln, err := initListener(l.network, l.address, eng.opts)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tlns[ln.fd] = ln\n\t\t\t}\n\t\t}\n\t\tp, err := netpoll.OpenPoller()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tel := new(eventloop)\n\t\tel.listeners = lns\n\t\tel.engine = eng\n\t\tel.poller = p\n\t\tel.buffer = make([]byte, eng.opts.ReadBufferCap)\n\t\tel.connections.init()\n\t\tel.eventHandler = eng.eventHandler\n\t\tfor _, ln := range lns {\n\t\t\tif err = el.poller.AddRead(ln.packPollAttachment(el.accept), false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\teng.eventLoops.register(el)\n\n\t\t// Start the ticker.\n\t\tif eng.opts.Ticker && el.idx == 0 {\n\t\t\tel0 = el\n\t\t}\n\t}\n\n\t// Start event-loops in background.\n\teng.eventLoops.iterate(func(_ int, el *eventloop) bool {\n\t\teng.concurrency.Go(el.run)\n\t\treturn true\n\t})\n\n\tif el0 != nil {\n\t\teng.concurrency.Go(func() error {\n\t\t\tel0.ticker(ctx)\n\t\t\treturn nil\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc (eng *engine) activateReactors(ctx context.Context, numEventLoop int) error {\n\tfor i := 0; i < numEventLoop; i++ {\n\t\tp, err := netpoll.OpenPoller()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tel := new(eventloop)\n\t\tel.listeners = eng.listeners\n\t\tel.engine = eng\n\t\tel.poller = p\n\t\tel.buffer = make([]byte, eng.opts.ReadBufferCap)\n\t\tel.connections.init()\n\t\tel.eventHandler = eng.eventHandler\n\t\teng.eventLoops.register(el)\n\t}\n\n\t// Start sub reactors in background.\n\teng.eventLoops.iterate(func(_ int, el *eventloop) bool {\n\t\teng.concurrency.Go(el.orbit)\n\t\treturn true\n\t})\n\n\tp, err := netpoll.OpenPoller()\n\tif err != nil {\n\t\treturn err\n\t}\n\tel := new(eventloop)\n\tel.listeners = eng.listeners\n\tel.idx = -1\n\tel.engine = eng\n\tel.poller = p\n\tel.eventHandler = eng.eventHandler\n\tfor _, ln := range eng.listeners {\n\t\tif err = el.poller.AddRead(ln.packPollAttachment(el.accept0), true); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\teng.ingress = el\n\n\t// Start main reactor in background.\n\teng.concurrency.Go(el.rotate)\n\n\t// Start the ticker.\n\tif eng.opts.Ticker {\n\t\teng.concurrency.Go(func() error {\n\t\t\teng.ingress.ticker(ctx)\n\t\t\treturn nil\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc (eng *engine) start(ctx context.Context, numEventLoop int) error {\n\tif eng.opts.ReusePort {\n\t\treturn eng.runEventLoops(ctx, numEventLoop)\n\t}\n\n\treturn eng.activateReactors(ctx, numEventLoop)\n}\n\nfunc (eng *engine) stop(ctx context.Context, s Engine) {\n\t// Wait on a signal for shutdown\n\t<-ctx.Done()\n\n\teng.eventHandler.OnShutdown(s)\n\n\t// Notify all event-loops to exit.\n\teng.eventLoops.iterate(func(i int, el *eventloop) bool {\n\t\terr := el.poller.Trigger(queue.HighPriority, func(_ any) error { return errorx.ErrEngineShutdown }, nil)\n\t\tif err != nil {\n\t\t\teng.opts.Logger.Errorf(\"failed to enqueue shutdown signal of high-priority for event-loop(%d): %v\", i, err)\n\t\t}\n\t\treturn true\n\t})\n\tif eng.ingress != nil {\n\t\terr := eng.ingress.poller.Trigger(queue.HighPriority, func(_ any) error { return errorx.ErrEngineShutdown }, nil)\n\t\tif err != nil {\n\t\t\teng.opts.Logger.Errorf(\"failed to enqueue shutdown signal of high-priority for main event-loop: %v\", err)\n\t\t}\n\t}\n\n\tif err := eng.concurrency.Wait(); err != nil {\n\t\teng.opts.Logger.Errorf(\"engine shutdown error: %v\", err)\n\t}\n\n\t// Close all listeners and pollers of event-loops.\n\teng.closeEventLoops()\n\n\t// Put the engine into the shutdown state.\n\teng.inShutdown.Store(true)\n}\n\nfunc run(eventHandler EventHandler, listeners []*listener, options *Options, addrs []string) error {\n\t// Figure out the proper number of event-loop to run.\n\tnumEventLoop := 1\n\tif options.Multicore {\n\t\tnumEventLoop = runtime.NumCPU()\n\t}\n\tif options.NumEventLoop > 0 {\n\t\tnumEventLoop = options.NumEventLoop\n\t}\n\tif numEventLoop > gfd.EventLoopIndexMax {\n\t\tnumEventLoop = gfd.EventLoopIndexMax\n\t}\n\n\tlogging.Infof(\"Launching gnet with %d event-loops, listening on: %s\",\n\t\tnumEventLoop, strings.Join(addrs, \" | \"))\n\n\tlns := make(map[int]*listener, len(listeners))\n\tfor _, ln := range listeners {\n\t\tlns[ln.fd] = ln\n\t}\n\trootCtx, shutdown := context.WithCancel(context.Background())\n\teg, ctx := errgroup.WithContext(rootCtx)\n\teng := engine{\n\t\tlisteners:    lns,\n\t\topts:         options,\n\t\tturnOff:      shutdown,\n\t\teventHandler: eventHandler,\n\t\tconcurrency: struct {\n\t\t\t*errgroup.Group\n\t\t\tctx context.Context\n\t\t}{eg, ctx},\n\t}\n\tswitch options.LB {\n\tcase RoundRobin:\n\t\teng.eventLoops = new(roundRobinLoadBalancer)\n\tcase LeastConnections:\n\t\teng.eventLoops = new(leastConnectionsLoadBalancer)\n\tcase SourceAddrHash:\n\t\teng.eventLoops = new(sourceAddrHashLoadBalancer)\n\t}\n\n\te := Engine{&eng}\n\tswitch eng.eventHandler.OnBoot(e) {\n\tcase None, Close:\n\tcase Shutdown:\n\t\treturn nil\n\t}\n\n\tif err := eng.start(ctx, numEventLoop); err != nil {\n\t\teng.closeEventLoops()\n\t\teng.opts.Logger.Errorf(\"gnet engine is stopping with error: %v\", err)\n\t\treturn err\n\t}\n\tdefer eng.stop(rootCtx, e)\n\n\tfor _, addr := range addrs {\n\t\tallEngines.Store(addr, &eng)\n\t}\n\n\treturn nil\n}\n\n/*\nfunc (eng *engine) sendCmd(cmd *asyncCmd, urgent bool) error {\n\tif !gfd.Validate(cmd.fd) {\n\t\treturn errors.ErrInvalidConn\n\t}\n\tel := eng.eventLoops.index(cmd.fd.EventLoopIndex())\n\tif el == nil {\n\t\treturn errors.ErrInvalidConn\n\t}\n\tif urgent {\n\t\treturn el.poller.Trigger(queue.LowPriority, el.execCmd, cmd)\n\t}\n\treturn el.poller.Trigger(el.execCmd, cmd)\n}\n*/\n"
        },
        {
          "name": "engine_windows.go",
          "type": "blob",
          "size": 4.4765625,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\t\"golang.org/x/sync/errgroup\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\ntype engine struct {\n\tlisteners     []*listener\n\topts          *Options     // options with engine\n\teventLoops    loadBalancer // event-loops for handling events\n\tinShutdown    atomic.Bool  // whether the engine is in shutdown\n\tbeingShutdown atomic.Bool  // whether the engine is being shutdown\n\tturnOff       context.CancelFunc\n\teventHandler  EventHandler // user eventHandler\n\tconcurrency   struct {\n\t\t*errgroup.Group\n\n\t\tctx context.Context\n\t}\n}\n\nfunc (eng *engine) isShutdown() bool {\n\treturn eng.inShutdown.Load()\n}\n\n// shutdown signals the engine to shut down.\nfunc (eng *engine) shutdown(err error) {\n\tif err != nil && !errors.Is(err, errorx.ErrEngineShutdown) {\n\t\teng.opts.Logger.Errorf(\"engine is being shutdown with error: %v\", err)\n\t}\n\teng.turnOff()\n\teng.beingShutdown.Store(true)\n}\n\nfunc (eng *engine) closeEventLoops() {\n\teng.eventLoops.iterate(func(i int, el *eventloop) bool {\n\t\tel.ch <- errorx.ErrEngineShutdown\n\t\treturn true\n\t})\n\tfor _, ln := range eng.listeners {\n\t\tln.close()\n\t}\n}\n\nfunc (eng *engine) start(ctx context.Context, numEventLoop int) error {\n\tfor i := 0; i < numEventLoop; i++ {\n\t\tel := eventloop{\n\t\t\tch:           make(chan any, 1024),\n\t\t\tidx:          i,\n\t\t\teng:          eng,\n\t\t\tconnections:  make(map[*conn]struct{}),\n\t\t\teventHandler: eng.eventHandler,\n\t\t}\n\t\teng.eventLoops.register(&el)\n\t\teng.concurrency.Go(el.run)\n\t\tif i == 0 && eng.opts.Ticker {\n\t\t\teng.concurrency.Go(func() error {\n\t\t\t\tel.ticker(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\t}\n\n\tfor _, ln := range eng.listeners {\n\t\tl := ln\n\t\tif l.pc != nil {\n\t\t\teng.concurrency.Go(func() error {\n\t\t\t\treturn eng.ListenUDP(l.pc)\n\t\t\t})\n\t\t} else {\n\t\t\teng.concurrency.Go(func() error {\n\t\t\t\treturn eng.listenStream(l.ln)\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (eng *engine) stop(ctx context.Context, engine Engine) {\n\t<-ctx.Done()\n\n\teng.eventHandler.OnShutdown(engine)\n\n\teng.closeEventLoops()\n\n\tif err := eng.concurrency.Wait(); err != nil && !errors.Is(err, errorx.ErrEngineShutdown) {\n\t\teng.opts.Logger.Errorf(\"engine shutdown error: %v\", err)\n\t}\n\n\teng.inShutdown.Store(true)\n}\n\nfunc run(eventHandler EventHandler, listeners []*listener, options *Options, addrs []string) error {\n\t// Figure out the proper number of event-loops/goroutines to run.\n\tnumEventLoop := 1\n\tif options.Multicore {\n\t\tnumEventLoop = runtime.NumCPU()\n\t}\n\tif options.NumEventLoop > 0 {\n\t\tnumEventLoop = options.NumEventLoop\n\t}\n\n\tlogging.Infof(\"Launching gnet with %d event-loops, listening on: %s\",\n\t\tnumEventLoop, strings.Join(addrs, \" | \"))\n\n\trootCtx, shutdown := context.WithCancel(context.Background())\n\teg, ctx := errgroup.WithContext(rootCtx)\n\teng := engine{\n\t\topts:         options,\n\t\tlisteners:    listeners,\n\t\tturnOff:      shutdown,\n\t\teventHandler: eventHandler,\n\t\tconcurrency: struct {\n\t\t\t*errgroup.Group\n\t\t\tctx context.Context\n\t\t}{eg, ctx},\n\t}\n\n\tswitch options.LB {\n\tcase RoundRobin:\n\t\teng.eventLoops = new(roundRobinLoadBalancer)\n\t\t// If there are more than one listener, we can't use roundRobinLoadBalancer because\n\t\t// it's not concurrency-safe, replace it with leastConnectionsLoadBalancer.\n\t\tif len(listeners) > 1 {\n\t\t\teng.eventLoops = new(leastConnectionsLoadBalancer)\n\t\t}\n\tcase LeastConnections:\n\t\teng.eventLoops = new(leastConnectionsLoadBalancer)\n\tcase SourceAddrHash:\n\t\teng.eventLoops = new(sourceAddrHashLoadBalancer)\n\t}\n\n\tengine := Engine{eng: &eng}\n\tswitch eventHandler.OnBoot(engine) {\n\tcase None, Close:\n\tcase Shutdown:\n\t\treturn nil\n\t}\n\n\tif err := eng.start(ctx, numEventLoop); err != nil {\n\t\teng.opts.Logger.Errorf(\"gnet engine is stopping with error: %v\", err)\n\t\treturn err\n\t}\n\tdefer eng.stop(rootCtx, engine)\n\n\tfor _, addr := range addrs {\n\t\tallEngines.Store(addr, &eng)\n\t}\n\n\treturn nil\n}\n\n/*\nfunc (eng *engine) sendCmd(_ *asyncCmd, _ bool) error {\n\treturn errorx.ErrUnsupportedOp\n}\n*/\n"
        },
        {
          "name": "eventloop_unix.go",
          "type": "blob",
          "size": 9.0712890625,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\tgio \"github.com/panjf2000/gnet/v2/pkg/io\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\t\"github.com/panjf2000/gnet/v2/pkg/queue\"\n)\n\ntype eventloop struct {\n\tlisteners    map[int]*listener // listeners\n\tidx          int               // loop index in the engine loops list\n\tengine       *engine           // engine in loop\n\tpoller       *netpoll.Poller   // epoll or kqueue\n\tbuffer       []byte            // read packet buffer whose capacity is set by user, default value is 64KB\n\tconnections  connMatrix        // loop connections storage\n\teventHandler EventHandler      // user eventHandler\n}\n\nfunc (el *eventloop) getLogger() logging.Logger {\n\treturn el.engine.opts.Logger\n}\n\nfunc (el *eventloop) countConn() int32 {\n\treturn el.connections.loadCount()\n}\n\nfunc (el *eventloop) closeConns() {\n\t// Close loops and all outstanding connections\n\tel.connections.iterate(func(c *conn) bool {\n\t\t_ = el.close(c, nil)\n\t\treturn true\n\t})\n}\n\ntype connWithCallback struct {\n\tc  *conn\n\tcb func()\n}\n\nfunc (el *eventloop) register(a any) error {\n\tc, ok := a.(*conn)\n\tif !ok {\n\t\tccb := a.(*connWithCallback)\n\t\tc = ccb.c\n\t\tdefer ccb.cb()\n\t}\n\treturn el.register0(c)\n}\n\nfunc (el *eventloop) register0(c *conn) error {\n\taddEvents := el.poller.AddRead\n\tif el.engine.opts.EdgeTriggeredIO {\n\t\taddEvents = el.poller.AddReadWrite\n\t}\n\tif err := addEvents(&c.pollAttachment, el.engine.opts.EdgeTriggeredIO); err != nil {\n\t\t_ = unix.Close(c.fd)\n\t\tc.release()\n\t\treturn err\n\t}\n\tel.connections.addConn(c, el.idx)\n\tif c.isDatagram && c.remote != nil {\n\t\treturn nil\n\t}\n\treturn el.open(c)\n}\n\nfunc (el *eventloop) open(c *conn) error {\n\tc.opened = true\n\n\tout, action := el.eventHandler.OnOpen(c)\n\tif out != nil {\n\t\tif err := c.open(out); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !c.outboundBuffer.IsEmpty() && !el.engine.opts.EdgeTriggeredIO {\n\t\tif err := el.poller.ModReadWrite(&c.pollAttachment, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) read0(a any) error {\n\treturn el.read(a.(*conn))\n}\n\nfunc (el *eventloop) read(c *conn) error {\n\tif !c.opened {\n\t\treturn nil\n\t}\n\n\tvar recv int\n\tisET := el.engine.opts.EdgeTriggeredIO\n\tchunk := el.engine.opts.EdgeTriggeredIOChunk\nloop:\n\tn, err := unix.Read(c.fd, el.buffer)\n\tif err != nil || n == 0 {\n\t\tif err == unix.EAGAIN {\n\t\t\treturn nil\n\t\t}\n\t\tif n == 0 {\n\t\t\terr = io.EOF\n\t\t}\n\t\treturn el.close(c, os.NewSyscallError(\"read\", err))\n\t}\n\trecv += n\n\n\tc.buffer = el.buffer[:n]\n\taction := el.eventHandler.OnTraffic(c)\n\tswitch action {\n\tcase None:\n\tcase Close:\n\t\treturn el.close(c, nil)\n\tcase Shutdown:\n\t\treturn errorx.ErrEngineShutdown\n\t}\n\t_, _ = c.inboundBuffer.Write(c.buffer)\n\tc.buffer = c.buffer[:0]\n\n\tif c.isEOF || (isET && recv < chunk) {\n\t\tgoto loop\n\t}\n\n\t// To prevent infinite reading in ET mode and starving other events,\n\t// we need to set up threshold for the maximum read bytes per connection\n\t// on each event-loop. If the threshold is reached and there are still\n\t// unread data in the socket buffer, we must issue another read event manually.\n\tif isET && n == len(el.buffer) {\n\t\treturn el.poller.Trigger(queue.LowPriority, el.read0, c)\n\t}\n\n\treturn nil\n}\n\nfunc (el *eventloop) write0(a any) error {\n\treturn el.write(a.(*conn))\n}\n\n// The default value of UIO_MAXIOV/IOV_MAX is 1024 on Linux and most BSD-like OSs.\nconst iovMax = 1024\n\nfunc (el *eventloop) write(c *conn) error {\n\tif c.outboundBuffer.IsEmpty() {\n\t\treturn nil\n\t}\n\n\tisET := el.engine.opts.EdgeTriggeredIO\n\tchunk := el.engine.opts.EdgeTriggeredIOChunk\n\tvar (\n\t\tn    int\n\t\tsent int\n\t\terr  error\n\t)\nloop:\n\tiov, _ := c.outboundBuffer.Peek(-1)\n\tif len(iov) > 1 {\n\t\tif len(iov) > iovMax {\n\t\t\tiov = iov[:iovMax]\n\t\t}\n\t\tn, err = gio.Writev(c.fd, iov)\n\t} else {\n\t\tn, err = unix.Write(c.fd, iov[0])\n\t}\n\t_, _ = c.outboundBuffer.Discard(n)\n\tswitch err {\n\tcase nil:\n\tcase unix.EAGAIN:\n\t\treturn nil\n\tdefault:\n\t\treturn el.close(c, os.NewSyscallError(\"write\", err))\n\t}\n\tsent += n\n\n\tif isET && !c.outboundBuffer.IsEmpty() && sent < chunk {\n\t\tgoto loop\n\t}\n\n\t// All data have been sent, it's no need to monitor the writable events for LT mode,\n\t// remove the writable event from poller to help the future event-loops if necessary.\n\tif !isET && c.outboundBuffer.IsEmpty() {\n\t\treturn el.poller.ModRead(&c.pollAttachment, false)\n\t}\n\n\t// To prevent infinite writing in ET mode and starving other events,\n\t// we need to set up threshold for the maximum write bytes per connection\n\t// on each event-loop. If the threshold is reached and there are still\n\t// pending data to write, we must issue another write event manually.\n\tif isET && !c.outboundBuffer.IsEmpty() {\n\t\treturn el.poller.Trigger(queue.HighPriority, el.write0, c)\n\t}\n\n\treturn nil\n}\n\nfunc (el *eventloop) close(c *conn, err error) error {\n\tif !c.opened || el.connections.getConn(c.fd) == nil {\n\t\treturn nil // ignore stale connections\n\t}\n\n\tel.connections.delConn(c)\n\taction := el.eventHandler.OnClose(c, err)\n\n\t// Send residual data in buffer back to the remote before actually closing the connection.\n\tfor !c.outboundBuffer.IsEmpty() {\n\t\tiov, _ := c.outboundBuffer.Peek(0)\n\t\tif len(iov) > iovMax {\n\t\t\tiov = iov[:iovMax]\n\t\t}\n\t\tn, err := gio.Writev(c.fd, iov)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t_, _ = c.outboundBuffer.Discard(n)\n\t}\n\n\tc.release()\n\n\tvar errStr strings.Builder\n\terr0, err1 := el.poller.Delete(c.fd), unix.Close(c.fd)\n\tif err0 != nil {\n\t\terr0 = fmt.Errorf(\"failed to delete fd=%d from poller in event-loop(%d): %v\",\n\t\t\tc.fd, el.idx, os.NewSyscallError(\"delete\", err0))\n\t\terrStr.WriteString(err0.Error())\n\t\terrStr.WriteString(\" | \")\n\t}\n\tif err1 != nil {\n\t\terr1 = fmt.Errorf(\"failed to close fd=%d in event-loop(%d): %v\",\n\t\t\tc.fd, el.idx, os.NewSyscallError(\"close\", err1))\n\t\terrStr.WriteString(err1.Error())\n\t}\n\tif errStr.Len() > 0 {\n\t\treturn errors.New(strings.TrimSuffix(errStr.String(), \" | \"))\n\t}\n\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) wake(c *conn) error {\n\tif !c.opened || el.connections.getConn(c.fd) == nil {\n\t\treturn nil // ignore stale connections\n\t}\n\n\taction := el.eventHandler.OnTraffic(c)\n\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) ticker(ctx context.Context) {\n\tvar (\n\t\taction Action\n\t\tdelay  time.Duration\n\t\ttimer  *time.Timer\n\t)\n\tdefer func() {\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t}\n\t}()\n\tfor {\n\t\tdelay, action = el.eventHandler.OnTick()\n\t\tswitch action {\n\t\tcase None, Close:\n\t\tcase Shutdown:\n\t\t\t// It seems reasonable to mark this as low-priority, waiting for some tasks like asynchronous writes\n\t\t\t// to finish up before shutting down the service.\n\t\t\terr := el.poller.Trigger(queue.LowPriority, func(_ any) error { return errorx.ErrEngineShutdown }, nil)\n\t\t\tel.getLogger().Debugf(\"failed to enqueue shutdown signal of high-priority for event-loop(%d): %v\", el.idx, err)\n\t\t}\n\t\tif timer == nil {\n\t\t\ttimer = time.NewTimer(delay)\n\t\t} else {\n\t\t\ttimer.Reset(delay)\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tel.getLogger().Debugf(\"stopping ticker in event-loop(%d) from Engine, error:%v\", el.idx, ctx.Err())\n\t\t\treturn\n\t\tcase <-timer.C:\n\t\t}\n\t}\n}\n\nfunc (el *eventloop) readUDP(fd int, _ netpoll.IOEvent, _ netpoll.IOFlags) error {\n\tn, sa, err := unix.Recvfrom(fd, el.buffer, 0)\n\tif err != nil {\n\t\tif err == unix.EAGAIN {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"failed to read UDP packet from fd=%d in event-loop(%d), %v\",\n\t\t\tfd, el.idx, os.NewSyscallError(\"recvfrom\", err))\n\t}\n\tvar c *conn\n\tif ln, ok := el.listeners[fd]; ok {\n\t\tc = newUDPConn(fd, el, ln.addr, sa, false)\n\t} else {\n\t\tc = el.connections.getConn(fd)\n\t}\n\tc.buffer = el.buffer[:n]\n\taction := el.eventHandler.OnTraffic(c)\n\tif c.remote != nil {\n\t\tc.release()\n\t}\n\tif action == Shutdown {\n\t\treturn errorx.ErrEngineShutdown\n\t}\n\treturn nil\n}\n\nfunc (el *eventloop) handleAction(c *conn, action Action) error {\n\tswitch action {\n\tcase None:\n\t\treturn nil\n\tcase Close:\n\t\treturn el.close(c, nil)\n\tcase Shutdown:\n\t\treturn errorx.ErrEngineShutdown\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n/*\nfunc (el *eventloop) execCmd(a any) (err error) {\n\tcmd := a.(*asyncCmd)\n\tc := el.connections.getConnByGFD(cmd.fd)\n\tif c == nil || c.gfd != cmd.fd {\n\t\treturn errorx.ErrInvalidConn\n\t}\n\n\tdefer func() {\n\t\tif cmd.cb != nil {\n\t\t\t_ = cmd.cb(c, err)\n\t\t}\n\t}()\n\n\tswitch cmd.typ {\n\tcase asyncCmdClose:\n\t\treturn el.close(c, nil)\n\tcase asyncCmdWake:\n\t\treturn el.wake(c)\n\tcase asyncCmdWrite:\n\t\t_, err = c.Write(cmd.param.([]byte))\n\tcase asyncCmdWritev:\n\t\t_, err = c.Writev(cmd.param.([][]byte))\n\tdefault:\n\t\treturn errorx.ErrUnsupportedOp\n\t}\n\treturn\n}\n*/\n"
        },
        {
          "name": "eventloop_unix_test.go",
          "type": "blob",
          "size": 6.5908203125,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc (lb *roundRobinLoadBalancer) register(el *eventloop) {\n\tlb.baseLoadBalancer.register(el)\n\tregisterInitConn(el)\n}\n\nfunc (lb *leastConnectionsLoadBalancer) register(el *eventloop) {\n\tlb.baseLoadBalancer.register(el)\n\tregisterInitConn(el)\n}\n\nfunc (lb *sourceAddrHashLoadBalancer) register(el *eventloop) {\n\tlb.baseLoadBalancer.register(el)\n\tregisterInitConn(el)\n}\n\nfunc registerInitConn(el *eventloop) {\n\tfor i := 0; i < int(atomic.LoadInt32(&nowEventLoopInitConn)); i++ {\n\t\tc := newTCPConn(i, el, &unix.SockaddrInet4{}, &net.TCPAddr{}, &net.TCPAddr{})\n\t\tel.connections.addConn(c, el.idx)\n\t}\n}\n\n// nowEventLoopInitConn initializes the number of conn fake data, must be set to 0 after use.\nvar (\n\tnowEventLoopInitConn int32\n\ttestBigGC            = false\n)\n\nfunc BenchmarkGC4El100k(b *testing.B) {\n\toldGc := debug.SetGCPercent(-1)\n\n\tts1 := benchServeGC(b, \"tcp\", \":0\", true, 4, 100000)\n\tb.Run(\"Run-4-eventloop-100000\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\truntime.GC()\n\t\t}\n\t})\n\t_ = ts1.eng.Stop(context.Background())\n\n\tdebug.SetGCPercent(oldGc)\n}\n\nfunc BenchmarkGC4El200k(b *testing.B) {\n\toldGc := debug.SetGCPercent(-1)\n\n\tts1 := benchServeGC(b, \"tcp\", \":0\", true, 4, 200000)\n\tb.Run(\"Run-4-eventloop-200000\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\truntime.GC()\n\t\t}\n\t})\n\t_ = ts1.eng.Stop(context.Background())\n\n\tdebug.SetGCPercent(oldGc)\n}\n\nfunc BenchmarkGC4El500k(b *testing.B) {\n\toldGc := debug.SetGCPercent(-1)\n\n\tts1 := benchServeGC(b, \"tcp\", \":0\", true, 4, 500000)\n\tb.Run(\"Run-4-eventloop-500000\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\truntime.GC()\n\t\t}\n\t})\n\t_ = ts1.eng.Stop(context.Background())\n\n\tdebug.SetGCPercent(oldGc)\n}\n\nfunc benchServeGC(b *testing.B, network, addr string, async bool, elNum int, initConnCount int32) *benchmarkServerGC {\n\tts := &benchmarkServerGC{\n\t\ttester:        b,\n\t\tnetwork:       network,\n\t\taddr:          addr,\n\t\tasync:         async,\n\t\telNum:         elNum,\n\t\tinitOk:        make(chan struct{}),\n\t\tinitConnCount: initConnCount,\n\t}\n\n\tnowEventLoopInitConn = initConnCount\n\tgo func() {\n\t\terr := Run(ts,\n\t\t\tnetwork+\"://\"+addr,\n\t\t\tWithLockOSThread(async),\n\t\t\tWithNumEventLoop(elNum),\n\t\t\tWithTCPKeepAlive(time.Minute*1),\n\t\t\tWithTCPNoDelay(TCPDelay))\n\t\tassert.NoError(b, err)\n\t\tnowEventLoopInitConn = 0\n\t}()\n\t<-ts.initOk\n\treturn ts\n}\n\ntype benchmarkServerGC struct {\n\t*BuiltinEventEngine\n\ttester        *testing.B\n\teng           Engine\n\tnetwork       string\n\taddr          string\n\tasync         bool\n\telNum         int\n\tinitConnCount int32\n\tinitOk        chan struct{}\n}\n\nfunc (s *benchmarkServerGC) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\tgo func() {\n\t\tfor {\n\t\t\tif s.eng.eng.eventLoops.len() == s.elNum && s.eng.CountConnections() == s.elNum*int(s.initConnCount) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t\tclose(s.initOk)\n\t}()\n\treturn\n}\n\n// TestServeGC generate fake data asynchronously, if you need to test, manually open the comment.\nfunc TestServeGC(t *testing.T) {\n\tt.Run(\"gc-loop\", func(t *testing.T) {\n\t\tt.Run(\"1-loop-10000\", func(t *testing.T) {\n\t\t\tif testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 1, 10000)\n\t\t})\n\t\tt.Run(\"1-loop-100000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 1, 100000)\n\t\t})\n\t\tt.Run(\"1-loop-1000000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 1, 1000000)\n\t\t})\n\t\tt.Run(\"2-loop-10000\", func(t *testing.T) {\n\t\t\tif testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 2, 10000)\n\t\t})\n\t\tt.Run(\"2-loop-100000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 2, 100000)\n\t\t})\n\t\tt.Run(\"2-loop-1000000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 2, 1000000)\n\t\t})\n\t\tt.Run(\"4-loop-10000\", func(t *testing.T) {\n\t\t\tif testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 4, 10000)\n\t\t})\n\t\tt.Run(\"4-loop-100000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 4, 100000)\n\t\t})\n\t\tt.Run(\"4-loop-1000000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 4, 1000000)\n\t\t})\n\t\tt.Run(\"16-loop-10000\", func(t *testing.T) {\n\t\t\tif testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 16, 10000)\n\t\t})\n\t\tt.Run(\"16-loop-100000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 16, 100000)\n\t\t})\n\t\tt.Run(\"16-loop-1000000\", func(t *testing.T) {\n\t\t\tif !testBigGC {\n\t\t\t\tt.Skipf(\"Skip when testBigGC=%t\", testBigGC)\n\t\t\t}\n\t\t\ttestServeGC(t, \"tcp\", \":0\", true, true, 16, 1000000)\n\t\t})\n\t})\n}\n\nfunc testServeGC(t *testing.T, network, addr string, multicore, async bool, elNum int, initConnCount int32) {\n\tts := &testServerGC{\n\t\ttester:    t,\n\t\tnetwork:   network,\n\t\taddr:      addr,\n\t\tmulticore: multicore,\n\t\tasync:     async,\n\t\telNum:     elNum,\n\t}\n\n\tnowEventLoopInitConn = initConnCount\n\n\terr := Run(ts,\n\t\tnetwork+\"://\"+addr,\n\t\tWithLockOSThread(async),\n\t\tWithMulticore(multicore),\n\t\tWithNumEventLoop(elNum),\n\t\tWithTCPKeepAlive(time.Minute*1),\n\t\tWithTCPNoDelay(TCPDelay))\n\tassert.NoError(t, err)\n\tnowEventLoopInitConn = 0\n}\n\ntype testServerGC struct {\n\t*BuiltinEventEngine\n\ttester    *testing.T\n\teng       Engine\n\tnetwork   string\n\taddr      string\n\tmulticore bool\n\tasync     bool\n\telNum     int\n}\n\nfunc (s *testServerGC) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\tgcSecs := 5\n\tif testBigGC {\n\t\tgcSecs = 10\n\t}\n\tgo s.GC(gcSecs)\n\n\treturn\n}\n\nfunc (s *testServerGC) GC(secs int) {\n\tdefer func() {\n\t\t_ = s.eng.Stop(context.Background())\n\t\truntime.GC()\n\t}()\n\tvar gcAllTime, gcAllCount time.Duration\n\tgcStart := time.Now()\n\tfor range time.Tick(time.Second) {\n\t\tgcAllCount++\n\t\tnow := time.Now()\n\t\truntime.GC()\n\t\tgcTime := time.Since(now)\n\t\tgcAllTime += gcTime\n\t\ts.tester.Log(s.tester.Name(), s.network, \"server gc:\", gcTime, \"average gc time:\", gcAllTime/gcAllCount)\n\t\tif time.Since(gcStart) >= time.Second*time.Duration(secs) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "eventloop_windows.go",
          "type": "blob",
          "size": 4.6455078125,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\ntype eventloop struct {\n\tch           chan any           // channel for event-loop\n\tidx          int                // index of event-loop in event-loops\n\teng          *engine            // engine in loop\n\tconnCount    int32              // number of active connections in event-loop\n\tconnections  map[*conn]struct{} // TCP connection map: fd -> conn\n\teventHandler EventHandler       // user eventHandler\n}\n\nfunc (el *eventloop) getLogger() logging.Logger {\n\treturn el.eng.opts.Logger\n}\n\nfunc (el *eventloop) incConn(delta int32) {\n\tatomic.AddInt32(&el.connCount, delta)\n}\n\nfunc (el *eventloop) countConn() int32 {\n\treturn atomic.LoadInt32(&el.connCount)\n}\n\nfunc (el *eventloop) run() (err error) {\n\tdefer func() {\n\t\tel.eng.shutdown(err)\n\t\tfor c := range el.connections {\n\t\t\t_ = el.close(c, nil)\n\t\t}\n\t}()\n\n\tif el.eng.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tfor i := range el.ch {\n\t\tswitch v := i.(type) {\n\t\tcase error:\n\t\t\terr = v\n\t\tcase *netErr:\n\t\t\terr = el.close(v.c, v.err)\n\t\tcase *openConn:\n\t\t\terr = el.open(v)\n\t\tcase *tcpConn:\n\t\t\terr = el.read(unpackTCPConn(v))\n\t\tcase *udpConn:\n\t\t\terr = el.readUDP(v.c)\n\t\tcase func() error:\n\t\t\terr = v()\n\t\t}\n\n\t\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\t\tel.getLogger().Debugf(\"event-loop(%d) is exiting in terms of the demand from user, %v\", el.idx, err)\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tel.getLogger().Debugf(\"event-loop(%d) got a nonlethal error: %v\", el.idx, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (el *eventloop) open(oc *openConn) error {\n\tif oc.cb != nil {\n\t\tdefer oc.cb()\n\t}\n\n\tc := oc.c\n\tel.connections[c] = struct{}{}\n\tel.incConn(1)\n\n\tout, action := el.eventHandler.OnOpen(c)\n\tif out != nil {\n\t\tif _, err := c.rawConn.Write(out); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) read(c *conn) error {\n\tif _, ok := el.connections[c]; !ok {\n\t\treturn nil // ignore stale wakes.\n\t}\n\taction := el.eventHandler.OnTraffic(c)\n\tswitch action {\n\tcase None:\n\tcase Close:\n\t\treturn el.close(c, nil)\n\tcase Shutdown:\n\t\treturn errorx.ErrEngineShutdown\n\t}\n\t_, _ = c.inboundBuffer.Write(c.buffer.B)\n\tc.buffer.Reset()\n\n\treturn nil\n}\n\nfunc (el *eventloop) readUDP(c *conn) error {\n\taction := el.eventHandler.OnTraffic(c)\n\tif action == Shutdown {\n\t\treturn errorx.ErrEngineShutdown\n\t}\n\tc.release()\n\treturn nil\n}\n\nfunc (el *eventloop) ticker(ctx context.Context) {\n\tif el == nil {\n\t\treturn\n\t}\n\tvar (\n\t\taction Action\n\t\tdelay  time.Duration\n\t\ttimer  *time.Timer\n\t)\n\tdefer func() {\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t}\n\t}()\n\tvar shutdown bool\n\tfor {\n\t\tdelay, action = el.eventHandler.OnTick()\n\t\tswitch action {\n\t\tcase None, Close:\n\t\tcase Shutdown:\n\t\t\tif !shutdown {\n\t\t\t\tshutdown = true\n\t\t\t\tel.ch <- errorx.ErrEngineShutdown\n\t\t\t\tel.getLogger().Debugf(\"stopping ticker in event-loop(%d) from Tick()\", el.idx)\n\t\t\t}\n\t\t}\n\t\tif timer == nil {\n\t\t\ttimer = time.NewTimer(delay)\n\t\t} else {\n\t\t\ttimer.Reset(delay)\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tel.getLogger().Debugf(\"stopping ticker in event-loop(%d) from Server, error:%v\", el.idx, ctx.Err())\n\t\t\treturn\n\t\tcase <-timer.C:\n\t\t}\n\t}\n}\n\nfunc (el *eventloop) wake(c *conn) error {\n\tif _, ok := el.connections[c]; !ok {\n\t\treturn nil // ignore stale wakes.\n\t}\n\taction := el.eventHandler.OnTraffic(c)\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) close(c *conn, err error) error {\n\tif _, ok := el.connections[c]; c.rawConn == nil || !ok {\n\t\treturn nil // ignore stale wakes.\n\t}\n\n\tdelete(el.connections, c)\n\tel.incConn(-1)\n\taction := el.eventHandler.OnClose(c, err)\n\terr = c.rawConn.Close()\n\tc.release()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close connection=%s in event-loop(%d): %v\", c.remoteAddr, el.idx, err)\n\t}\n\n\treturn el.handleAction(c, action)\n}\n\nfunc (el *eventloop) handleAction(c *conn, action Action) error {\n\tswitch action {\n\tcase None:\n\t\treturn nil\n\tcase Close:\n\t\treturn el.close(c, nil)\n\tcase Shutdown:\n\t\treturn errorx.ErrEngineShutdown\n\tdefault:\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "gnet.go",
          "type": "blob",
          "size": 21.580078125,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package gnet implements a high-performance, lightweight, non-blocking,\n// event-driven networking framework written in pure Go.\n//\n// Visit https://gnet.host/ for more details about gnet.\npackage gnet\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/buffer/ring\"\n\t\"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/math\"\n)\n\n// Action is an action that occurs after the completion of an event.\ntype Action int\n\nconst (\n\t// None indicates that no action should occur following an event.\n\tNone Action = iota\n\n\t// Close closes the connection.\n\tClose\n\n\t// Shutdown shutdowns the engine.\n\tShutdown\n)\n\n// Engine represents an engine context which provides some functions.\ntype Engine struct {\n\t// eng is the internal engine struct.\n\teng *engine\n}\n\n// Validate checks whether the engine is available.\nfunc (e Engine) Validate() error {\n\tif e.eng == nil || len(e.eng.listeners) == 0 {\n\t\treturn errors.ErrEmptyEngine\n\t}\n\tif e.eng.isShutdown() {\n\t\treturn errors.ErrEngineInShutdown\n\t}\n\treturn nil\n}\n\n// CountConnections counts the number of currently active connections and returns it.\nfunc (e Engine) CountConnections() (count int) {\n\tif e.Validate() != nil {\n\t\treturn -1\n\t}\n\n\te.eng.eventLoops.iterate(func(_ int, el *eventloop) bool {\n\t\tcount += int(el.countConn())\n\t\treturn true\n\t})\n\treturn\n}\n\n// Dup returns a copy of the underlying file descriptor of listener.\n// It is the caller's responsibility to close dupFD when finished.\n// Closing listener does not affect dupFD, and closing dupFD does not affect listener.\nfunc (e Engine) Dup() (fd int, err error) {\n\tif err := e.Validate(); err != nil {\n\t\treturn -1, err\n\t}\n\tif len(e.eng.listeners) > 1 {\n\t\treturn -1, errors.ErrUnsupportedOp\n\t}\n\tfor _, ln := range e.eng.listeners {\n\t\tfd, err = ln.dup()\n\t}\n\treturn\n}\n\n// Stop gracefully shuts down this Engine without interrupting any active event-loops,\n// it waits indefinitely for connections and event-loops to be closed and then shuts down.\nfunc (e Engine) Stop(ctx context.Context) error {\n\tif err := e.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\te.eng.shutdown(nil)\n\n\tticker := time.NewTicker(shutdownPollInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tif e.eng.isShutdown() {\n\t\t\treturn nil\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-ticker.C:\n\t\t}\n\t}\n}\n\n/*\ntype asyncCmdType uint8\n\nconst (\n\tasyncCmdClose = iota + 1\n\tasyncCmdWake\n\tasyncCmdWrite\n\tasyncCmdWritev\n)\n\ntype asyncCmd struct {\n\tfd  gfd.GFD\n\ttyp asyncCmdType\n\tcb  AsyncCallback\n\tparam any\n}\n\n// AsyncWrite writes data to the given connection asynchronously.\nfunc (e Engine) AsyncWrite(fd gfd.GFD, p []byte, cb AsyncCallback) error {\n\tif err := e.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn e.eng.sendCmd(&asyncCmd{fd: fd, typ: asyncCmdWrite, cb: cb, param: p}, false)\n}\n\n// AsyncWritev is like AsyncWrite, but it accepts a slice of byte slices.\nfunc (e Engine) AsyncWritev(fd gfd.GFD, batch [][]byte, cb AsyncCallback) error {\n\tif err := e.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn e.eng.sendCmd(&asyncCmd{fd: fd, typ: asyncCmdWritev, cb: cb, param: batch}, false)\n}\n\n// Close closes the given connection.\nfunc (e Engine) Close(fd gfd.GFD, cb AsyncCallback) error {\n\tif err := e.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn e.eng.sendCmd(&asyncCmd{fd: fd, typ: asyncCmdClose, cb: cb}, false)\n}\n\n// Wake wakes up the given connection.\nfunc (e Engine) Wake(fd gfd.GFD, cb AsyncCallback) error {\n\tif err := e.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn e.eng.sendCmd(&asyncCmd{fd: fd, typ: asyncCmdWake, cb: cb}, true)\n}\n*/\n\n// Reader is an interface that consists of a number of methods for reading that Conn must implement.\n//\n// Note that the methods in this interface are not concurrency-safe for concurrent use,\n// you must invoke them within any method in EventHandler.\ntype Reader interface {\n\tio.Reader\n\tio.WriterTo\n\n\t// Next returns a slice containing the next n bytes from the buffer,\n\t// advancing the buffer as if the bytes had been returned by Read.\n\t// Calling this method has the same effect as calling Peek and Discard.\n\t// If the amount of the available bytes is less than requested, a pair of (0, io.ErrShortBuffer)\n\t// is returned.\n\t//\n\t// Note that the []byte buf returned by Next() is not allowed to be passed to a new goroutine,\n\t// as this []byte will be reused within event-loop.\n\t// If you have to use buf in a new goroutine, then you need to make a copy of buf and pass this copy\n\t// to that new goroutine.\n\tNext(n int) (buf []byte, err error)\n\n\t// Peek returns the next n bytes without advancing the inbound buffer, the returned bytes\n\t// remain valid until a Discard is called. If the amount of the available bytes is\n\t// less than requested, a pair of (0, io.ErrShortBuffer) is returned.\n\t//\n\t// Note that the []byte buf returned by Peek() is not allowed to be passed to a new goroutine,\n\t// as this []byte will be reused within event-loop.\n\t// If you have to use buf in a new goroutine, then you need to make a copy of buf and pass this copy\n\t// to that new goroutine.\n\tPeek(n int) (buf []byte, err error)\n\n\t// Discard advances the inbound buffer with next n bytes, returning the number of bytes discarded.\n\tDiscard(n int) (discarded int, err error)\n\n\t// InboundBuffered returns the number of bytes that can be read from the current buffer.\n\tInboundBuffered() (n int)\n}\n\n// Writer is an interface that consists of a number of methods for writing that Conn must implement.\ntype Writer interface {\n\tio.Writer     // not concurrency-safe\n\tio.ReaderFrom // not concurrency-safe\n\n\t// Writev writes multiple byte slices to remote synchronously, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tWritev(bs [][]byte) (n int, err error)\n\n\t// Flush writes any buffered data to the underlying connection, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tFlush() (err error)\n\n\t// OutboundBuffered returns the number of bytes that can be read from the current buffer.\n\t// it's not concurrency-safe, you must invoke it within any method in EventHandler.\n\tOutboundBuffered() (n int)\n\n\t// AsyncWrite writes bytes to remote asynchronously, it's concurrency-safe,\n\t// you don't have to invoke it within any method in EventHandler,\n\t// usually you would call it in an individual goroutine.\n\t//\n\t// Note that it will go synchronously with UDP, so it is needless to call\n\t// this asynchronous method, we may disable this method for UDP and just\n\t// return ErrUnsupportedOp in the future, therefore, please don't rely on\n\t// this method to do something important under UDP, if you're working with UDP,\n\t// just call Conn.Write to send back your data.\n\tAsyncWrite(buf []byte, callback AsyncCallback) (err error)\n\n\t// AsyncWritev writes multiple byte slices to remote asynchronously,\n\t// you don't have to invoke it within any method in EventHandler,\n\t// usually you would call it in an individual goroutine.\n\tAsyncWritev(bs [][]byte, callback AsyncCallback) (err error)\n}\n\n// AsyncCallback is a callback that will be invoked after the asynchronous function finishes.\n//\n// Note that the parameter gnet.Conn might have been already released when it's UDP protocol,\n// thus it shouldn't be accessed.\n// This callback will be executed in event-loop, thus it must not block, otherwise,\n// it blocks the event-loop.\ntype AsyncCallback func(c Conn, err error) error\n\n// Socket is a set of functions which manipulate the underlying file descriptor of a connection.\n//\n// Note that the methods in this interface are concurrency-safe for concurrent use,\n// you don't have to invoke them within any method in EventHandler.\ntype Socket interface {\n\t// Gfd returns the gfd of socket.\n\t// Gfd() gfd.GFD\n\n\t// Fd returns the underlying file descriptor.\n\tFd() int\n\n\t// Dup returns a copy of the underlying file descriptor.\n\t// It is the caller's responsibility to close fd when finished.\n\t// Closing c does not affect fd, and closing fd does not affect c.\n\t//\n\t// The returned file descriptor is different from the\n\t// connection's. Attempting to change properties of the original\n\t// using this duplicate may or may not have the desired effect.\n\tDup() (int, error)\n\n\t// SetReadBuffer sets the size of the operating system's\n\t// receive buffer associated with the connection.\n\tSetReadBuffer(bytes int) error\n\n\t// SetWriteBuffer sets the size of the operating system's\n\t// transmit buffer associated with the connection.\n\tSetWriteBuffer(bytes int) error\n\n\t// SetLinger sets the behavior of Close on a connection which still\n\t// has data waiting to be sent or to be acknowledged.\n\t//\n\t// If sec < 0 (the default), the operating system finishes sending the\n\t// data in the background.\n\t//\n\t// If sec == 0, the operating system discards any unsent or\n\t// unacknowledged data.\n\t//\n\t// If sec > 0, the data is sent in the background as with sec < 0. On\n\t// some operating systems after sec seconds have elapsed any remaining\n\t// unsent data may be discarded.\n\tSetLinger(sec int) error\n\n\t// SetKeepAlivePeriod tells operating system to send keep-alive messages on the connection\n\t// and sets period between TCP keep-alive probes.\n\tSetKeepAlivePeriod(d time.Duration) error\n\n\t// SetNoDelay controls whether the operating system should delay\n\t// packet transmission in hopes of sending fewer packets (Nagle's\n\t// algorithm).\n\t// The default is true (no delay), meaning that data is sent as soon as possible after a Write.\n\tSetNoDelay(noDelay bool) error\n}\n\n// Conn is an interface of underlying connection.\ntype Conn interface {\n\tReader // all methods in Reader are not concurrency-safe.\n\tWriter // some methods in Writer are concurrency-safe, some are not.\n\tSocket // all methods in Socket are concurrency-safe.\n\n\t// Context returns a user-defined context, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tContext() (ctx any)\n\n\t// SetContext sets a user-defined context, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tSetContext(ctx any)\n\n\t// LocalAddr is the connection's local socket address, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tLocalAddr() (addr net.Addr)\n\n\t// RemoteAddr is the connection's remote address, it's not concurrency-safe,\n\t// you must invoke it within any method in EventHandler.\n\tRemoteAddr() (addr net.Addr)\n\n\t// Wake triggers a OnTraffic event for the current connection, it's concurrency-safe.\n\tWake(callback AsyncCallback) (err error)\n\n\t// CloseWithCallback closes the current connection, it's concurrency-safe.\n\t// Usually you should provide a non-nil callback for this method,\n\t// otherwise your better choice is Close().\n\tCloseWithCallback(callback AsyncCallback) (err error)\n\n\t// Close closes the current connection, implements net.Conn, it's concurrency-safe.\n\tClose() (err error)\n\n\t// SetDeadline implements net.Conn.\n\tSetDeadline(t time.Time) (err error)\n\n\t// SetReadDeadline implements net.Conn.\n\tSetReadDeadline(t time.Time) (err error)\n\n\t// SetWriteDeadline implements net.Conn.\n\tSetWriteDeadline(t time.Time) (err error)\n}\n\ntype (\n\t// EventHandler represents the engine events' callbacks for the Run call.\n\t// Each event has an Action return value that is used manage the state\n\t// of the connection and engine.\n\tEventHandler interface {\n\t\t// OnBoot fires when the engine is ready for accepting connections.\n\t\t// The parameter engine has information and various utilities.\n\t\tOnBoot(eng Engine) (action Action)\n\n\t\t// OnShutdown fires when the engine is being shut down, it is called right after\n\t\t// all event-loops and connections are closed.\n\t\tOnShutdown(eng Engine)\n\n\t\t// OnOpen fires when a new connection has been opened.\n\t\t//\n\t\t// The Conn c has information about the connection such as its local and remote addresses.\n\t\t// The parameter out is the return value which is going to be sent back to the remote.\n\t\t// Sending large amounts of data back to the remote in OnOpen is usually not recommended.\n\t\tOnOpen(c Conn) (out []byte, action Action)\n\n\t\t// OnClose fires when a connection has been closed.\n\t\t// The parameter err is the last known connection error.\n\t\tOnClose(c Conn, err error) (action Action)\n\n\t\t// OnTraffic fires when a socket receives data from the remote.\n\t\t//\n\t\t// Note that the []byte returned from Conn.Peek(int)/Conn.Next(int) is not allowed to be passed to a new goroutine,\n\t\t// as this []byte will be reused within event-loop after OnTraffic() returns.\n\t\t// If you have to use this []byte in a new goroutine, you should either make a copy of it or call Conn.Read([]byte)\n\t\t// to read data into your own []byte, then pass the new []byte to the new goroutine.\n\t\tOnTraffic(c Conn) (action Action)\n\n\t\t// OnTick fires immediately after the engine starts and will fire again\n\t\t// following the duration specified by the delay return value.\n\t\tOnTick() (delay time.Duration, action Action)\n\t}\n\n\t// BuiltinEventEngine is a built-in implementation of EventHandler which sets up each method with a default implementation,\n\t// you can compose it with your own implementation of EventHandler when you don't want to implement all methods\n\t// in EventHandler.\n\tBuiltinEventEngine struct{}\n)\n\n// OnBoot fires when the engine is ready for accepting connections.\n// The parameter engine has information and various utilities.\nfunc (*BuiltinEventEngine) OnBoot(_ Engine) (action Action) {\n\treturn\n}\n\n// OnShutdown fires when the engine is being shut down, it is called right after\n// all event-loops and connections are closed.\nfunc (*BuiltinEventEngine) OnShutdown(_ Engine) {\n}\n\n// OnOpen fires when a new connection has been opened.\n// The parameter out is the return value which is going to be sent back to the remote.\nfunc (*BuiltinEventEngine) OnOpen(_ Conn) (out []byte, action Action) {\n\treturn\n}\n\n// OnClose fires when a connection has been closed.\n// The parameter err is the last known connection error.\nfunc (*BuiltinEventEngine) OnClose(_ Conn, _ error) (action Action) {\n\treturn\n}\n\n// OnTraffic fires when a local socket receives data from the remote.\nfunc (*BuiltinEventEngine) OnTraffic(_ Conn) (action Action) {\n\treturn\n}\n\n// OnTick fires immediately after the engine starts and will fire again\n// following the duration specified by the delay return value.\nfunc (*BuiltinEventEngine) OnTick() (delay time.Duration, action Action) {\n\treturn\n}\n\n// MaxStreamBufferCap is the default buffer size for each stream-oriented connection(TCP/Unix).\nvar MaxStreamBufferCap = 64 * 1024 // 64KB\n\nfunc createListeners(addrs []string, opts ...Option) ([]*listener, *Options, error) {\n\toptions := loadOptions(opts...)\n\n\tlogger, logFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tif options.Logger == nil {\n\t\tif options.LogPath != \"\" {\n\t\t\tlogger, logFlusher, _ = logging.CreateLoggerAsLocalFile(options.LogPath, options.LogLevel)\n\t\t}\n\t\toptions.Logger = logger\n\t} else {\n\t\tlogger = options.Logger\n\t\tlogFlusher = nil\n\t}\n\tlogging.SetDefaultLoggerAndFlusher(logger, logFlusher)\n\n\tlogging.Debugf(\"default logging level is %s\", logging.LogLevel())\n\n\t// The maximum number of operating system threads that the Go program can use is initially set to 10000,\n\t// which should also be the maximum amount of I/O event-loops locked to OS threads that users can start up.\n\tif options.LockOSThread && options.NumEventLoop > 10000 {\n\t\tlogging.Errorf(\"too many event-loops under LockOSThread mode, should be less than 10,000 \"+\n\t\t\t\"while you are trying to set up %d\\n\", options.NumEventLoop)\n\t\treturn nil, nil, errors.ErrTooManyEventLoopThreads\n\t}\n\n\tif options.EdgeTriggeredIOChunk > 0 {\n\t\toptions.EdgeTriggeredIO = true\n\t\toptions.EdgeTriggeredIOChunk = math.CeilToPowerOfTwo(options.EdgeTriggeredIOChunk)\n\t} else if options.EdgeTriggeredIO {\n\t\toptions.EdgeTriggeredIOChunk = 1 << 20 // 1MB\n\t}\n\n\trbc := options.ReadBufferCap\n\tswitch {\n\tcase rbc <= 0:\n\t\toptions.ReadBufferCap = MaxStreamBufferCap\n\tcase rbc <= ring.DefaultBufferSize:\n\t\toptions.ReadBufferCap = ring.DefaultBufferSize\n\tdefault:\n\t\toptions.ReadBufferCap = math.CeilToPowerOfTwo(rbc)\n\t}\n\twbc := options.WriteBufferCap\n\tswitch {\n\tcase wbc <= 0:\n\t\toptions.WriteBufferCap = MaxStreamBufferCap\n\tcase wbc <= ring.DefaultBufferSize:\n\t\toptions.WriteBufferCap = ring.DefaultBufferSize\n\tdefault:\n\t\toptions.WriteBufferCap = math.CeilToPowerOfTwo(wbc)\n\t}\n\n\tvar hasUDP, hasUnix bool\n\tfor _, addr := range addrs {\n\t\tproto, _, err := parseProtoAddr(addr)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thasUDP = hasUDP || strings.HasPrefix(proto, \"udp\")\n\t\thasUnix = hasUnix || proto == \"unix\"\n\t}\n\n\t// SO_REUSEPORT enables duplicate address and port bindings across various\n\t// Unix-like OSs, whereas there is platform-specific inconsistency:\n\t// Linux implemented SO_REUSEPORT with load balancing for incoming connections\n\t// while *BSD implemented it for only binding to the same address and port, which\n\t// makes it pointless to enable SO_REUSEPORT on *BSD and Darwin for gnet with\n\t// multiple event-loops because only the first or last event-loop will be constantly\n\t// woken up to accept incoming connections and handle I/O events while the rest of\n\t// event-loops remain idle.\n\t// Thus, we disable SO_REUSEPORT on *BSD and Darwin by default.\n\t//\n\t// Note that FreeBSD 12 introduced a new socket option named SO_REUSEPORT_LB\n\t// with the capability of load balancing, it's the equivalent of Linux's SO_REUSEPORT.\n\t// Also note that DragonFlyBSD 3.6.0 extended SO_REUSEPORT to distribute workload to\n\t// available sockets, which make it the same as Linux's SO_REUSEPORT.\n\t//\n\t// Despite the fact that SO_REUSEPORT can be set on a Unix domain socket\n\t// via setsockopt() without reporting an error, SO_REUSEPORT is actually\n\t// not supported for sockets of AF_UNIX. Thus, we avoid setting it on the\n\t// Unix domain sockets.\n\tgoos := runtime.GOOS\n\tif (options.Multicore || options.NumEventLoop > 1) && options.ReusePort &&\n\t\t((goos != \"linux\" && goos != \"dragonfly\" && goos != \"freebsd\") || hasUnix) {\n\t\toptions.ReusePort = false\n\t}\n\n\t// If there is UDP address in the list, we have no choice but to enable SO_REUSEPORT anyway,\n\t// also disable edge-triggered I/O for UDP by default.\n\tif hasUDP {\n\t\toptions.ReusePort = true\n\t\toptions.EdgeTriggeredIO = false\n\t}\n\n\tlisteners := make([]*listener, len(addrs))\n\tfor i, a := range addrs {\n\t\tproto, addr, err := parseProtoAddr(a)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tln, err := initListener(proto, addr, options)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tlisteners[i] = ln\n\t}\n\n\treturn listeners, options, nil\n}\n\n// Run starts handling events on the specified address.\n//\n// Address should use a scheme prefix and be formatted\n// like `tcp://192.168.0.10:9851` or `unix://socket`.\n// Valid network schemes:\n//\n//\ttcp   - bind to both IPv4 and IPv6\n//\ttcp4  - IPv4\n//\ttcp6  - IPv6\n//\tudp   - bind to both IPv4 and IPv6\n//\tudp4  - IPv4\n//\tudp6  - IPv6\n//\tunix  - Unix Domain Socket\n//\n// The \"tcp\" network scheme is assumed when one is not specified.\nfunc Run(eventHandler EventHandler, protoAddr string, opts ...Option) error {\n\tlisteners, options, err := createListeners([]string{protoAddr}, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tfor _, ln := range listeners {\n\t\t\tln.close()\n\t\t}\n\t\tlogging.Cleanup()\n\t}()\n\treturn run(eventHandler, listeners, options, []string{protoAddr})\n}\n\n// Rotate is like Run but accepts multiple network addresses.\nfunc Rotate(eventHandler EventHandler, addrs []string, opts ...Option) error {\n\tlisteners, options, err := createListeners(addrs, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tfor _, ln := range listeners {\n\t\t\tln.close()\n\t\t}\n\t\tlogging.Cleanup()\n\t}()\n\treturn run(eventHandler, listeners, options, addrs)\n}\n\nvar (\n\tallEngines sync.Map\n\n\t// shutdownPollInterval is how often we poll to check whether engine has been shut down during gnet.Stop().\n\tshutdownPollInterval = 500 * time.Millisecond\n)\n\n// Stop gracefully shuts down the engine without interrupting any active event-loops,\n// it waits indefinitely for connections and event-loops to be closed and then shuts down.\n//\n// Deprecated: The global Stop only shuts down the last registered Engine with the same\n// protocol and IP:Port as the previous Engine's, which can lead to leaks of Engine if\n// you invoke gnet.Run multiple times using the same protocol and IP:Port under the\n// condition that WithReuseAddr(true) and WithReusePort(true) are enabled.\n// Use Engine.Stop instead.\nfunc Stop(ctx context.Context, protoAddr string) error {\n\tvar eng *engine\n\tif s, ok := allEngines.Load(protoAddr); ok {\n\t\teng = s.(*engine)\n\t\teng.shutdown(nil)\n\t\tdefer allEngines.Delete(protoAddr)\n\t} else {\n\t\treturn errors.ErrEngineInShutdown\n\t}\n\n\tif eng.isShutdown() {\n\t\treturn errors.ErrEngineInShutdown\n\t}\n\n\tticker := time.NewTicker(shutdownPollInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tif eng.isShutdown() {\n\t\t\treturn nil\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-ticker.C:\n\t\t}\n\t}\n}\n\nfunc parseProtoAddr(protoAddr string) (string, string, error) {\n\tprotoAddr = strings.ToLower(protoAddr)\n\tif strings.Count(protoAddr, \"://\") != 1 {\n\t\treturn \"\", \"\", errors.ErrInvalidNetworkAddress\n\t}\n\tpair := strings.SplitN(protoAddr, \"://\", 2)\n\tproto, addr := pair[0], pair[1]\n\tswitch proto {\n\tcase \"tcp\", \"tcp4\", \"tcp6\", \"udp\", \"udp4\", \"udp6\", \"unix\":\n\tdefault:\n\t\treturn \"\", \"\", errors.ErrUnsupportedProtocol\n\t}\n\tif addr == \"\" {\n\t\treturn \"\", \"\", errors.ErrInvalidNetworkAddress\n\t}\n\treturn proto, addr, nil\n}\n"
        },
        {
          "name": "gnet_test.go",
          "type": "blob",
          "size": 56.326171875,
          "content": "package gnet\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\tcrand \"crypto/rand\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/errgroup\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\tbbPool \"github.com/panjf2000/gnet/v2/pkg/pool/bytebuffer\"\n\tgoPool \"github.com/panjf2000/gnet/v2/pkg/pool/goroutine\"\n)\n\nvar (\n\tdatagramLen = 1024\n\tstreamLen   = 1024 * 1024\n)\n\ntype testConf struct {\n\tet        bool\n\tetChunk   int\n\treuseport bool\n\tmulticore bool\n\tasync     bool\n\twritev    bool\n\tclients   int\n\tlb        LoadBalancing\n}\n\nfunc TestServer(t *testing.T) {\n\t// start an engine\n\t// connect 10 clients\n\t// each client will pipe random data for 1-3 seconds.\n\t// the writes to the engine will be random sizes. 0KB - 1MB.\n\t// the engine will echo back the data.\n\t// waits for graceful connection closing.\n\tt.Run(\"poll-LT\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, false, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{false, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{false, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, false, true, true, true, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-ET\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, false, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, false, true, true, true, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-ET-chunk\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 1 << 19, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 1 << 19, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 1 << 18, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 1 << 19, false, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 1 << 19, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 1 << 19, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 1 << 18, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 1 << 19, false, true, false, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 1 << 18, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 1 << 19, false, true, true, false, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 1 << 18, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 1 << 19, false, true, true, true, 10, SourceAddrHash})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-reuseport-LT\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{false, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{false, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{false, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{false, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-reuseport-ET\", func(t *testing.T) {\n\t\tt.Run(\"tcp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"tcp-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\"}, &testConf{true, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9992\"}, &testConf{true, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"udp-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9991\"}, &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"udp://:9992\"}, &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"unix-async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet1.sock\"}, &testConf{true, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"unix://gnet2.sock\"}, &testConf{true, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-multi-addrs-LT\", func(t *testing.T) {\n\t\tt.Run(\"sync\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"sync-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, false, false, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, true, false, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, false, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-multi-addrs-reuseport-LT\", func(t *testing.T) {\n\t\tt.Run(\"sync\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"sync-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, false, false, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, true, false, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{false, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-multi-addrs-ET\", func(t *testing.T) {\n\t\tt.Run(\"sync\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"sync-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, false, false, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, true, false, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, false, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"poll-multi-addrs-reuseport-ET\", func(t *testing.T) {\n\t\tt.Run(\"sync\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, false, false, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, true, false, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"sync-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, false, false, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, true, false, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"udp://:9993\", \"udp://:9994\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, false, true, false, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"udp://:9997\", \"udp://:9998\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, true, true, false, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"async-writev\", func(t *testing.T) {\n\t\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9991\", \"tcp://:9992\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, false, true, true, 10, RoundRobin})\n\t\t\t})\n\t\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\t\trunServer(t, []string{\"tcp://:9995\", \"tcp://:9996\", \"unix://gnet1.sock\", \"unix://gnet2.sock\"}, &testConf{true, 0, true, true, true, true, 10, LeastConnections})\n\t\t\t})\n\t\t})\n\t})\n}\n\ntype testServer struct {\n\t*BuiltinEventEngine\n\ttester       *testing.T\n\teng          Engine\n\taddrs        []string\n\tmulticore    bool\n\tasync        bool\n\twritev       bool\n\tnclients     int\n\tstarted      int32\n\tconnected    int32\n\tdisconnected int32\n\tclientActive int32\n\tworkerPool   *goPool.Pool\n}\n\nfunc (s *testServer) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\tfd, err := s.eng.Dup()\n\tif len(s.addrs) > 1 {\n\t\tassert.ErrorIsf(s.tester, err, errorx.ErrUnsupportedOp, \"dup error\")\n\t} else {\n\t\trequire.NoErrorf(s.tester, err, \"dup error\")\n\t\tassert.Greaterf(s.tester, fd, 2, \"expected fd: > 2, but got: %d\", fd)\n\t\tassert.NoErrorf(s.tester, SysClose(fd), \"close fd error\")\n\t}\n\treturn\n}\n\nfunc (s *testServer) OnOpen(c Conn) (out []byte, action Action) {\n\tc.SetContext(c)\n\tatomic.AddInt32(&s.connected, 1)\n\tout = []byte(\"sweetness\\r\\n\")\n\trequire.NotNil(s.tester, c.LocalAddr(), \"nil local addr\")\n\trequire.NotNil(s.tester, c.RemoteAddr(), \"nil remote addr\")\n\treturn\n}\n\nfunc (s *testServer) OnShutdown(_ Engine) {\n\tfd, err := s.eng.Dup()\n\tif len(s.addrs) > 1 {\n\t\tassert.ErrorIsf(s.tester, err, errorx.ErrUnsupportedOp, \"dup error\")\n\t} else {\n\t\trequire.NoErrorf(s.tester, err, \"dup error\")\n\t\tassert.Greaterf(s.tester, fd, 2, \"expected fd: > 2, but got: %d\", fd)\n\t\tassert.NoErrorf(s.tester, SysClose(fd), \"close fd error\")\n\t}\n}\n\nfunc (s *testServer) OnClose(c Conn, err error) (action Action) {\n\tif err != nil {\n\t\tlogging.Debugf(\"error occurred on closed, %v\\n\", err)\n\t}\n\n\trequire.Equal(s.tester, c.Context(), c, \"invalid context\")\n\n\tatomic.AddInt32(&s.disconnected, 1)\n\treturn\n}\n\nfunc (s *testServer) OnTraffic(c Conn) (action Action) {\n\tif s.async {\n\t\tbuf := bbPool.Get()\n\t\t_, _ = c.WriteTo(buf)\n\t\tif c.LocalAddr().Network() == \"tcp\" || c.LocalAddr().Network() == \"unix\" {\n\t\t\t// just for test\n\t\t\t_ = c.InboundBuffered()\n\t\t\t_ = c.OutboundBuffered()\n\t\t\t_, _ = c.Discard(1)\n\n\t\t\t_ = s.workerPool.Submit(\n\t\t\t\tfunc() {\n\t\t\t\t\tif s.writev {\n\t\t\t\t\t\tmid := buf.Len() / 2\n\t\t\t\t\t\tbs := make([][]byte, 2)\n\t\t\t\t\t\tbs[0] = buf.B[:mid]\n\t\t\t\t\t\tbs[1] = buf.B[mid:]\n\t\t\t\t\t\t_ = c.AsyncWritev(bs, func(c Conn, err error) error {\n\t\t\t\t\t\t\tif c.RemoteAddr() != nil {\n\t\t\t\t\t\t\t\tlogging.Debugf(\"conn=%s done writev: %v\", c.RemoteAddr().String(), err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbbPool.Put(buf)\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_ = c.AsyncWrite(buf.Bytes(), func(c Conn, err error) error {\n\t\t\t\t\t\t\tif c.RemoteAddr() != nil {\n\t\t\t\t\t\t\t\tlogging.Debugf(\"conn=%s done write: %v\", c.RemoteAddr().String(), err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbbPool.Put(buf)\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\treturn\n\t\t} else if c.LocalAddr().Network() == \"udp\" {\n\t\t\t_ = s.workerPool.Submit(\n\t\t\t\tfunc() {\n\t\t\t\t\t_ = c.AsyncWrite(buf.Bytes(), nil)\n\t\t\t\t})\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\tbuf, _ := c.Next(-1)\n\tif s.writev {\n\t\tmid := len(buf) / 2\n\t\t_, _ = c.Writev([][]byte{buf[:mid], buf[mid:]})\n\t} else {\n\t\t_, _ = c.Write(buf)\n\t}\n\n\t// Only for code coverage of testing.\n\tif !s.multicore {\n\t\tassert.NoErrorf(s.tester, c.Flush(), \"flush error\")\n\t\t_ = c.Fd()\n\t\tfd, err := c.Dup()\n\t\trequire.NoErrorf(s.tester, err, \"dup error\")\n\t\tassert.Greaterf(s.tester, fd, 2, \"expected fd: > 2, but got: %d\", fd)\n\t\tassert.NoErrorf(s.tester, SysClose(fd), \"close error\")\n\t\t// TODO(panjf2000): somehow these two system calls will fail with Unix Domain Socket,\n\t\t//  returning \"invalid argument\" error on macOS in Github actions intermittently,\n\t\t//  try to figure it out.\n\t\tif c.LocalAddr().Network() == \"unix\" && runtime.GOOS == \"darwin\" {\n\t\t\t_ = c.SetReadBuffer(streamLen)\n\t\t\t_ = c.SetWriteBuffer(streamLen)\n\t\t} else {\n\t\t\tassert.NoErrorf(s.tester, c.SetReadBuffer(streamLen), \"set read buffer error\")\n\t\t\tassert.NoErrorf(s.tester, c.SetWriteBuffer(streamLen), \"set write buffer error\")\n\t\t}\n\t\tif c.LocalAddr().Network() == \"tcp\" {\n\t\t\tassert.NoErrorf(s.tester, c.SetLinger(1), \"set linger error\")\n\t\t\tassert.NoErrorf(s.tester, c.SetNoDelay(false), \"set no delay error\")\n\t\t\tassert.NoErrorf(s.tester, c.SetKeepAlivePeriod(time.Minute), \"set keep alive period error\")\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (s *testServer) OnTick() (delay time.Duration, action Action) {\n\tdelay = 100 * time.Millisecond\n\tif atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tfor _, protoAddr := range s.addrs {\n\t\t\tproto, addr, err := parseProtoAddr(protoAddr)\n\t\t\tassert.NoError(s.tester, err)\n\t\t\tfor i := 0; i < s.nclients; i++ {\n\t\t\t\tatomic.AddInt32(&s.clientActive, 1)\n\t\t\t\tgo func() {\n\t\t\t\t\tstartClient(s.tester, proto, addr, s.multicore, s.async)\n\t\t\t\t\tatomic.AddInt32(&s.clientActive, -1)\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}\n\tif atomic.LoadInt32(&s.clientActive) == 0 {\n\t\tvar streamAddrs int\n\t\tfor _, addr := range s.addrs {\n\t\t\tif !strings.HasPrefix(addr, \"udp\") {\n\t\t\t\tstreamAddrs++\n\t\t\t}\n\t\t}\n\t\tstreamConns := s.nclients * streamAddrs\n\t\tdisconnected := atomic.LoadInt32(&s.disconnected)\n\t\tif int(disconnected) == streamConns && disconnected == atomic.LoadInt32(&s.connected) {\n\t\t\taction = Shutdown\n\t\t\ts.workerPool.Release()\n\t\t\trequire.EqualValues(s.tester, 0, s.eng.CountConnections())\n\t\t}\n\t}\n\treturn\n}\n\nfunc runServer(t *testing.T, addrs []string, conf *testConf) {\n\tts := &testServer{\n\t\ttester:     t,\n\t\taddrs:      addrs,\n\t\tmulticore:  conf.multicore,\n\t\tasync:      conf.async,\n\t\twritev:     conf.writev,\n\t\tnclients:   conf.clients,\n\t\tworkerPool: goPool.Default(),\n\t}\n\tvar err error\n\tif len(addrs) > 1 {\n\t\terr = Rotate(ts,\n\t\t\taddrs,\n\t\t\tWithEdgeTriggeredIO(conf.et),\n\t\t\tWithEdgeTriggeredIOChunk(conf.etChunk),\n\t\t\tWithLockOSThread(conf.async),\n\t\t\tWithMulticore(conf.multicore),\n\t\t\tWithReusePort(conf.reuseport),\n\t\t\tWithTicker(true),\n\t\t\tWithTCPKeepAlive(time.Minute),\n\t\t\tWithTCPNoDelay(TCPNoDelay),\n\t\t\tWithLoadBalancing(conf.lb))\n\t} else {\n\t\terr = Run(ts,\n\t\t\taddrs[0],\n\t\t\tWithEdgeTriggeredIO(conf.et),\n\t\t\tWithEdgeTriggeredIOChunk(conf.etChunk),\n\t\t\tWithLockOSThread(conf.async),\n\t\t\tWithMulticore(conf.multicore),\n\t\t\tWithReusePort(conf.reuseport),\n\t\t\tWithTicker(true),\n\t\t\tWithTCPKeepAlive(time.Minute),\n\t\t\tWithTCPNoDelay(TCPDelay),\n\t\t\tWithLoadBalancing(conf.lb))\n\t}\n\tassert.NoError(t, err)\n}\n\nfunc startClient(t *testing.T, network, addr string, multicore, async bool) {\n\tc, err := net.Dial(network, addr)\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\trd := bufio.NewReader(c)\n\tif network != \"udp\" {\n\t\tmsg, err := rd.ReadBytes('\\n')\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, string(msg), \"sweetness\\r\\n\", \"bad header\")\n\t}\n\tduration := time.Duration((rand.Float64()*2+1)*float64(time.Second)) / 2\n\tlogging.Debugf(\"test duration: %v\", duration)\n\tstart := time.Now()\n\tfor time.Since(start) < duration {\n\t\treqData := make([]byte, streamLen)\n\t\tif network == \"udp\" {\n\t\t\treqData = reqData[:datagramLen]\n\t\t}\n\t\t_, err = crand.Read(reqData)\n\t\trequire.NoError(t, err)\n\t\t_, err = c.Write(reqData)\n\t\trequire.NoError(t, err)\n\t\trespData := make([]byte, len(reqData))\n\t\t_, err = io.ReadFull(rd, respData)\n\t\trequire.NoError(t, err)\n\t\tif !async {\n\t\t\t// require.Equalf(t, reqData, respData, \"response mismatch with protocol:%s, multi-core:%t, content of bytes: %d vs %d\", network, multicore, string(reqData), string(respData))\n\t\t\trequire.Equalf(\n\t\t\t\tt,\n\t\t\t\treqData,\n\t\t\t\trespData,\n\t\t\t\t\"response mismatch with protocol:%s, multi-core:%t, length of bytes: %d vs %d\",\n\t\t\t\tnetwork,\n\t\t\t\tmulticore,\n\t\t\t\tlen(reqData),\n\t\t\t\tlen(respData),\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestDefaultGnetServer(*testing.T) {\n\tsvr := BuiltinEventEngine{}\n\tsvr.OnBoot(Engine{})\n\tsvr.OnOpen(nil)\n\tsvr.OnClose(nil, nil)\n\tsvr.OnTraffic(nil)\n\tsvr.OnTick()\n}\n\ntype testBadAddrServer struct {\n\t*BuiltinEventEngine\n}\n\nfunc (t *testBadAddrServer) OnBoot(_ Engine) (action Action) {\n\treturn Shutdown\n}\n\nfunc TestBadAddresses(t *testing.T) {\n\tevents := new(testBadAddrServer)\n\terr := Run(events, \"tulip://howdy\")\n\tassert.ErrorIs(t, err, errorx.ErrUnsupportedProtocol)\n\terr = Run(events, \"howdy\")\n\tassert.ErrorIs(t, err, errorx.ErrInvalidNetworkAddress)\n\terr = Run(events, \"tcp://\")\n\tassert.ErrorIs(t, err, errorx.ErrInvalidNetworkAddress)\n}\n\nfunc TestTick(t *testing.T) {\n\ttestTick(\"tcp\", \":9989\", t)\n}\n\ntype testTickServer struct {\n\t*BuiltinEventEngine\n\tcount int\n}\n\nfunc (t *testTickServer) OnTick() (delay time.Duration, action Action) {\n\tdelay = time.Millisecond * 10\n\tif t.count == 25 {\n\t\taction = Shutdown\n\t\treturn\n\t}\n\tt.count++\n\treturn\n}\n\nfunc testTick(network, addr string, t *testing.T) {\n\tevents := &testTickServer{}\n\tstart := time.Now()\n\topts := Options{Ticker: true}\n\terr := Run(events, network+\"://\"+addr, WithOptions(opts))\n\tassert.NoError(t, err)\n\tdur := time.Since(start)\n\tif dur < 250&time.Millisecond || dur > time.Second {\n\t\tt.Logf(\"bad ticker timing: %d\", dur)\n\t}\n}\n\nfunc TestWakeConn(t *testing.T) {\n\ttestWakeConn(t, \"tcp\", \":9990\")\n}\n\ntype testWakeConnServer struct {\n\t*BuiltinEventEngine\n\ttester  *testing.T\n\tnetwork string\n\taddr    string\n\tconn    chan Conn\n\tc       Conn\n\twake    bool\n}\n\nfunc (t *testWakeConnServer) OnOpen(c Conn) (out []byte, action Action) {\n\tt.conn <- c\n\treturn\n}\n\nfunc (t *testWakeConnServer) OnClose(Conn, error) (action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testWakeConnServer) OnTraffic(c Conn) (action Action) {\n\t_, _ = c.Write([]byte(\"Waking up.\"))\n\taction = -1\n\treturn\n}\n\nfunc (t *testWakeConnServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.wake {\n\t\tt.wake = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tr := make([]byte, 10)\n\t\t\t_, err = conn.Read(r)\n\t\t\trequire.NoError(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\tt.c = <-t.conn\n\t_ = t.c.Wake(func(c Conn, err error) error {\n\t\tlogging.Debugf(\"conn=%s done wake: %v\", c.RemoteAddr().String(), err)\n\t\treturn nil\n\t})\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testWakeConn(t *testing.T, network, addr string) {\n\tcurrentLogger, currentFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tt.Cleanup(func() {\n\t\tlogging.SetDefaultLoggerAndFlusher(currentLogger, currentFlusher) // restore\n\t})\n\n\tsvr := &testWakeConnServer{tester: t, network: network, addr: addr, conn: make(chan Conn, 1)}\n\tlogger := zap.NewExample()\n\terr := Run(svr, network+\"://\"+addr,\n\t\tWithTicker(true),\n\t\tWithNumEventLoop(2*runtime.NumCPU()),\n\t\tWithLogger(logger.Sugar()),\n\t\tWithSocketRecvBuffer(4*1024),\n\t\tWithSocketSendBuffer(4*1024),\n\t\tWithReadBufferCap(2000),\n\t\tWithWriteBufferCap(2000))\n\tassert.NoError(t, err)\n\t_ = logger.Sync()\n}\n\nfunc TestShutdown(t *testing.T) {\n\ttestShutdown(t, \"tcp\", \":9991\")\n}\n\ntype testShutdownServer struct {\n\t*BuiltinEventEngine\n\ttester  *testing.T\n\teng     Engine\n\tnetwork string\n\taddr    string\n\tcount   int\n\tclients int32\n\tN       int\n}\n\nfunc (t *testShutdownServer) OnBoot(eng Engine) (action Action) {\n\tt.eng = eng\n\treturn\n}\n\nfunc (t *testShutdownServer) OnOpen(Conn) (out []byte, action Action) {\n\trequire.EqualValues(t.tester, atomic.AddInt32(&t.clients, 1), t.eng.CountConnections())\n\treturn\n}\n\nfunc (t *testShutdownServer) OnClose(Conn, error) (action Action) {\n\tatomic.AddInt32(&t.clients, -1)\n\treturn\n}\n\nfunc (t *testShutdownServer) OnTick() (delay time.Duration, action Action) {\n\tif t.count == 0 {\n\t\t// start clients\n\t\tfor i := 0; i < t.N; i++ {\n\t\t\tgo func() {\n\t\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\t\trequire.NoError(t.tester, err)\n\t\t\t\tdefer conn.Close()\n\t\t\t\t_, err = conn.Read([]byte{0})\n\t\t\t\trequire.Error(t.tester, err)\n\t\t\t}()\n\t\t}\n\t} else if int(atomic.LoadInt32(&t.clients)) == t.N {\n\t\taction = Shutdown\n\t}\n\tt.count++\n\tdelay = time.Second / 20\n\treturn\n}\n\nfunc testShutdown(t *testing.T, network, addr string) {\n\tcurrentLogger, currentFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tt.Cleanup(func() {\n\t\tlogging.SetDefaultLoggerAndFlusher(currentLogger, currentFlusher) // restore\n\t})\n\n\tevents := &testShutdownServer{tester: t, network: network, addr: addr, N: 100}\n\tlogPath := filepath.Join(t.TempDir(), \"gnet-test-shutdown.log\")\n\terr := Run(events, network+\"://\"+addr,\n\t\tWithLogPath(logPath),\n\t\tWithLogLevel(logging.WarnLevel),\n\t\tWithTicker(true),\n\t\tWithReadBufferCap(512),\n\t\tWithWriteBufferCap(512))\n\tassert.NoError(t, err)\n\trequire.Equal(t, 0, int(events.clients), \"did not close all clients\")\n}\n\nfunc TestCloseActionError(t *testing.T) {\n\ttestCloseActionError(t, \"tcp\", \":9992\")\n}\n\ntype testCloseActionErrorServer struct {\n\t*BuiltinEventEngine\n\ttester        *testing.T\n\tnetwork, addr string\n\taction        bool\n}\n\nfunc (t *testCloseActionErrorServer) OnClose(Conn, error) (action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testCloseActionErrorServer) OnTraffic(c Conn) (action Action) {\n\tn := c.InboundBuffered()\n\tbuf := make([]byte, n)\n\tm, err := c.Read(buf)\n\tassert.NoError(t.tester, err)\n\tassert.EqualValuesf(t.tester, n, m, \"read %d bytes, expected %d\", m, n)\n\tn, err = c.Write(buf)\n\tassert.NoError(t.tester, err)\n\tassert.EqualValuesf(t.tester, m, n, \"wrote %d bytes, expected %d\", n, m)\n\taction = Close\n\treturn\n}\n\nfunc (t *testCloseActionErrorServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.action {\n\t\tt.action = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tdata := []byte(\"Hello World!\")\n\t\t\t_, _ = conn.Write(data)\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.NoError(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testCloseActionError(t *testing.T, network, addr string) {\n\tevents := &testCloseActionErrorServer{tester: t, network: network, addr: addr}\n\terr := Run(events, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestShutdownActionError(t *testing.T) {\n\ttestShutdownActionError(t, \"tcp\", \":9993\")\n}\n\ntype testShutdownActionErrorServer struct {\n\t*BuiltinEventEngine\n\ttester        *testing.T\n\tnetwork, addr string\n\taction        bool\n}\n\nfunc (t *testShutdownActionErrorServer) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Peek(-1)\n\t_, _ = c.Write(buf)\n\t_, _ = c.Discard(-1)\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testShutdownActionErrorServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.action {\n\t\tt.action = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tdata := []byte(\"Hello World!\")\n\t\t\t_, _ = conn.Write(data)\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.NoError(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testShutdownActionError(t *testing.T, network, addr string) {\n\tevents := &testShutdownActionErrorServer{tester: t, network: network, addr: addr}\n\terr := Run(events, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestCloseActionOnOpen(t *testing.T) {\n\ttestCloseActionOnOpen(t, \"tcp\", \":9994\")\n}\n\ntype testCloseActionOnOpenServer struct {\n\t*BuiltinEventEngine\n\ttester        *testing.T\n\tnetwork, addr string\n\taction        bool\n}\n\nfunc (t *testCloseActionOnOpenServer) OnOpen(Conn) (out []byte, action Action) {\n\taction = Close\n\treturn\n}\n\nfunc (t *testCloseActionOnOpenServer) OnClose(Conn, error) (action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testCloseActionOnOpenServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.action {\n\t\tt.action = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t}()\n\t\treturn\n\t}\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testCloseActionOnOpen(t *testing.T, network, addr string) {\n\tevents := &testCloseActionOnOpenServer{tester: t, network: network, addr: addr}\n\terr := Run(events, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestShutdownActionOnOpen(t *testing.T) {\n\ttestShutdownActionOnOpen(t, \"tcp\", \":9995\")\n}\n\ntype testShutdownActionOnOpenServer struct {\n\t*BuiltinEventEngine\n\ttester        *testing.T\n\tnetwork, addr string\n\taction        bool\n\teng           Engine\n}\n\nfunc (t *testShutdownActionOnOpenServer) OnOpen(Conn) (out []byte, action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testShutdownActionOnOpenServer) OnShutdown(e Engine) {\n\tt.eng = e\n\tfd, err := t.eng.Dup()\n\tassert.Greaterf(t.tester, fd, 2, \"expected fd: > 2, but got: %d\", fd)\n\trequire.NoErrorf(t.tester, err, \"dup error\")\n\tassert.NoErrorf(t.tester, SysClose(fd), \"close error\")\n\tlogging.Debugf(\"dup fd: %d with error: %v\\n\", fd, err)\n}\n\nfunc (t *testShutdownActionOnOpenServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.action {\n\t\tt.action = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t}()\n\t\treturn\n\t}\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testShutdownActionOnOpen(t *testing.T, network, addr string) {\n\tevents := &testShutdownActionOnOpenServer{tester: t, network: network, addr: addr}\n\terr := Run(events, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n\t_, err = events.eng.Dup()\n\tassert.ErrorIsf(t, err, errorx.ErrEngineInShutdown, \"expected error: %v, but got: %v\",\n\t\terrorx.ErrEngineInShutdown, err)\n}\n\nfunc TestUDPShutdown(t *testing.T) {\n\ttestUDPShutdown(t, \"udp4\", \":9000\")\n}\n\ntype testUDPShutdownServer struct {\n\t*BuiltinEventEngine\n\ttester  *testing.T\n\tnetwork string\n\taddr    string\n\ttick    bool\n}\n\nfunc (t *testUDPShutdownServer) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Peek(-1)\n\t_, _ = c.Write(buf)\n\t_, _ = c.Discard(-1)\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testUDPShutdownServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.tick {\n\t\tt.tick = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tdata := []byte(\"Hello World!\")\n\t\t\t_, err = conn.Write(data)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.NoError(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testUDPShutdown(t *testing.T, network, addr string) {\n\tsvr := &testUDPShutdownServer{tester: t, network: network, addr: addr}\n\terr := Run(svr, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestCloseConnection(t *testing.T) {\n\ttestCloseConnection(t, \"tcp\", \":9996\")\n}\n\ntype testCloseConnectionServer struct {\n\t*BuiltinEventEngine\n\ttester        *testing.T\n\tnetwork, addr string\n\taction        bool\n}\n\nfunc (t *testCloseConnectionServer) OnClose(Conn, error) (action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testCloseConnectionServer) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Peek(-1)\n\t_, _ = c.Write(buf)\n\t_, _ = c.Discard(-1)\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\t_ = c.CloseWithCallback(func(_ Conn, err error) error {\n\t\t\tassert.ErrorIsf(t.tester, err, errorx.ErrEngineShutdown, \"should be engine shutdown error\")\n\t\t\treturn nil\n\t\t})\n\t}()\n\treturn\n}\n\nfunc (t *testCloseConnectionServer) OnTick() (delay time.Duration, action Action) {\n\tdelay = time.Millisecond * 100\n\tif !t.action {\n\t\tt.action = true\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tdata := []byte(\"Hello World!\")\n\t\t\t_, _ = conn.Write(data)\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\t// waiting the engine shutdown.\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.Error(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\treturn\n}\n\nfunc testCloseConnection(t *testing.T, network, addr string) {\n\tevents := &testCloseConnectionServer{tester: t, network: network, addr: addr}\n\terr := Run(events, network+\"://\"+addr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestServerOptionsCheck(t *testing.T) {\n\terr := Run(&BuiltinEventEngine{}, \"tcp://:3500\", WithNumEventLoop(10001), WithLockOSThread(true))\n\tassert.EqualError(t, err, errorx.ErrTooManyEventLoopThreads.Error(), \"error returned with LockOSThread option\")\n}\n\nfunc TestStopServer(t *testing.T) {\n\ttestStop(t, \"tcp\", \":9997\")\n}\n\ntype testStopServer struct {\n\t*BuiltinEventEngine\n\ttester                   *testing.T\n\tnetwork, addr, protoAddr string\n\teng                      Engine\n\taction                   bool\n}\n\nfunc (t *testStopServer) OnBoot(eng Engine) (action Action) {\n\tt.eng = eng\n\treturn\n}\n\nfunc (t *testStopServer) OnClose(Conn, error) (action Action) {\n\tlogging.Debugf(\"closing connection...\")\n\treturn\n}\n\nfunc (t *testStopServer) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Peek(-1)\n\t_, _ = c.Write(buf)\n\t_, _ = c.Discard(-1)\n\treturn\n}\n\nfunc (t *testStopServer) OnTick() (delay time.Duration, action Action) {\n\tdelay = time.Millisecond * 100\n\tif !t.action {\n\t\tt.action = true\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tdata := []byte(\"Hello World!\")\n\t\t\t_, _ = conn.Write(data)\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.NoError(t.tester, err)\n\n\t\t\tgo func() {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\t\t\t\tdefer cancel()\n\t\t\t\tlogging.Debugf(\"stop engine...\", t.eng.Stop(ctx))\n\t\t\t}()\n\n\t\t\t// waiting the engine shutdown.\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.Error(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\treturn\n}\n\nfunc testStop(t *testing.T, network, addr string) {\n\tevents := &testStopServer{tester: t, network: network, addr: addr, protoAddr: network + \"://\" + addr}\n\terr := Run(events, events.protoAddr, WithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestEngineStop(t *testing.T) {\n\ttestEngineStop(t, \"tcp\", \":9998\")\n}\n\ntype testStopEngine struct {\n\t*BuiltinEventEngine\n\ttester                   *testing.T\n\tnetwork, addr, protoAddr string\n\teng                      Engine\n\tstopIter                 int64\n\tname                     string\n\texchngCount              int64\n}\n\nfunc (t *testStopEngine) OnBoot(eng Engine) (action Action) {\n\tt.eng = eng\n\treturn\n}\n\nfunc (t *testStopEngine) OnClose(Conn, error) (action Action) {\n\tlogging.Debugf(\"closing connection...\")\n\treturn\n}\n\nfunc (t *testStopEngine) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Peek(-1)\n\t_, _ = c.Write(buf)\n\t_, _ = c.Discard(-1)\n\tatomic.AddInt64(&t.exchngCount, 1)\n\treturn\n}\n\nfunc (t *testStopEngine) OnTick() (delay time.Duration, action Action) {\n\tdelay = time.Millisecond * 100\n\tgo func() {\n\t\tconn, err := net.Dial(t.network, t.addr)\n\t\trequire.NoError(t.tester, err)\n\t\tdefer conn.Close()\n\t\tdata := []byte(\"Hello World! \" + t.name)\n\t\t_, _ = conn.Write(data)\n\t\t_, err = conn.Read(data)\n\t\trequire.NoError(t.tester, err)\n\n\t\titer := atomic.LoadInt64(&t.stopIter)\n\t\tif iter <= 0 {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\t\t\tdefer cancel()\n\t\t\tlogging.Debugf(\"stop engine...\", t.eng.Stop(ctx))\n\t\t\t// waiting the engine shutdown.\n\t\t\t_, err = conn.Read(data)\n\t\t\trequire.Error(t.tester, err)\n\t\t}\n\t\tatomic.AddInt64(&t.stopIter, -1)\n\t}()\n\treturn\n}\n\nfunc testEngineStop(t *testing.T, network, addr string) {\n\tevents1 := &testStopEngine{tester: t, network: network, addr: addr, protoAddr: network + \"://\" + addr, name: \"1\", stopIter: 2}\n\tevents2 := &testStopEngine{tester: t, network: network, addr: addr, protoAddr: network + \"://\" + addr, name: \"2\", stopIter: 5}\n\n\tresult1 := make(chan error, 1)\n\tgo func() {\n\t\terr := Run(events1, events1.protoAddr, WithTicker(true), WithReuseAddr(true), WithReusePort(true))\n\t\tresult1 <- err\n\t}()\n\t// ensure the first handler processes before starting the next since the delay per tick is 100ms\n\ttime.Sleep(150 * time.Millisecond)\n\tresult2 := make(chan error, 1)\n\tgo func() {\n\t\terr := Run(events2, events2.protoAddr, WithTicker(true), WithReuseAddr(true), WithReusePort(true))\n\t\tresult2 <- err\n\t}()\n\n\terr := <-result1\n\tassert.NoError(t, err)\n\terr = <-result2\n\tassert.NoError(t, err)\n\t// make sure that each handler processed at least 1\n\trequire.Greater(t, events1.exchngCount, int64(0))\n\trequire.Greater(t, events2.exchngCount, int64(0))\n\trequire.Equal(t, int64(2+1+5+1), events1.exchngCount+events2.exchngCount)\n\t// stop an already stopped engine\n\trequire.Equal(t, errorx.ErrEngineInShutdown, events1.eng.Stop(context.Background()))\n}\n\n// Test should not panic when we wake-up server_closed conn.\nfunc TestClosedWakeUp(t *testing.T) {\n\tevents := &testClosedWakeUpServer{\n\t\ttester:             t,\n\t\tBuiltinEventEngine: &BuiltinEventEngine{}, network: \"tcp\", addr: \":9999\", protoAddr: \"tcp://:9999\",\n\t\tclientClosed: make(chan struct{}),\n\t\tserverClosed: make(chan struct{}),\n\t\twakeup:       make(chan struct{}),\n\t}\n\n\terr := Run(events, events.protoAddr)\n\tassert.NoError(t, err)\n}\n\ntype testClosedWakeUpServer struct {\n\t*BuiltinEventEngine\n\ttester                   *testing.T\n\tnetwork, addr, protoAddr string\n\n\twakeup       chan struct{}\n\tserverClosed chan struct{}\n\tclientClosed chan struct{}\n}\n\nfunc (s *testClosedWakeUpServer) OnBoot(eng Engine) (action Action) {\n\tgo func() {\n\t\tc, err := net.Dial(s.network, s.addr)\n\t\trequire.NoError(s.tester, err)\n\n\t\t_, err = c.Write([]byte(\"hello\"))\n\t\trequire.NoError(s.tester, err)\n\n\t\t<-s.wakeup\n\t\t_, err = c.Write([]byte(\"hello again\"))\n\t\trequire.NoError(s.tester, err)\n\n\t\tclose(s.clientClosed)\n\t\t<-s.serverClosed\n\n\t\tlogging.Debugf(\"stop engine...\", eng.Stop(context.TODO()))\n\t}()\n\n\treturn None\n}\n\nfunc (s *testClosedWakeUpServer) OnTraffic(c Conn) Action {\n\tassert.NotNil(s.tester, c.RemoteAddr())\n\n\tselect {\n\tcase <-s.wakeup:\n\tdefault:\n\t\tclose(s.wakeup)\n\t}\n\n\tgo func() { require.NoError(s.tester, c.Wake(nil)) }()\n\tgo func() { require.NoError(s.tester, c.Close()) }()\n\n\t<-s.clientClosed\n\n\t_, _ = c.Write([]byte(\"answer\"))\n\treturn None\n}\n\nfunc (s *testClosedWakeUpServer) OnClose(Conn, error) (action Action) {\n\tselect {\n\tcase <-s.serverClosed:\n\tdefault:\n\t\tclose(s.serverClosed)\n\t}\n\treturn\n}\n\ntype testMultiInstLoggerRaceServer struct {\n\t*BuiltinEventEngine\n}\n\nfunc (t *testMultiInstLoggerRaceServer) OnBoot(_ Engine) (action Action) {\n\treturn Shutdown\n}\n\nfunc TestMultiInstLoggerRace(t *testing.T) {\n\tcurrentLogger, currentFlusher := logging.GetDefaultLogger(), logging.GetDefaultFlusher()\n\tt.Cleanup(func() {\n\t\tlogging.SetDefaultLoggerAndFlusher(currentLogger, currentFlusher) // restore\n\t})\n\n\tlogger1, _ := zap.NewDevelopment()\n\tevents1 := new(testMultiInstLoggerRaceServer)\n\tg := errgroup.Group{}\n\tg.Go(func() error {\n\t\terr := Run(events1, \"tulip://howdy\", WithLogger(logger1.Sugar()))\n\t\treturn err\n\t})\n\n\tlogger2, _ := zap.NewDevelopment()\n\tevents2 := new(testMultiInstLoggerRaceServer)\n\tg.Go(func() error {\n\t\terr := Run(events2, \"tulip://howdy\", WithLogger(logger2.Sugar()))\n\t\treturn err\n\t})\n\n\tassert.ErrorIs(t, g.Wait(), errorx.ErrUnsupportedProtocol)\n}\n\nvar errIncompletePacket = errors.New(\"incomplete packet\")\n\ntype simServer struct {\n\tBuiltinEventEngine\n\ttester       *testing.T\n\teng          Engine\n\tnetwork      string\n\taddr         string\n\tmulticore    bool\n\tnclients     int\n\tpacketSize   int\n\tbatchWrite   int\n\tbatchRead    int\n\tstarted      int32\n\tconnected    int32\n\tdisconnected int32\n}\n\nfunc (s *simServer) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\treturn\n}\n\nfunc (s *simServer) OnOpen(c Conn) (out []byte, action Action) {\n\tc.SetContext(&testCodec{})\n\tatomic.AddInt32(&s.connected, 1)\n\tout = []byte(\"sweetness\\r\\n\")\n\trequire.NotNil(s.tester, c.LocalAddr(), \"nil local addr\")\n\trequire.NotNil(s.tester, c.RemoteAddr(), \"nil remote addr\")\n\treturn\n}\n\nfunc (s *simServer) OnClose(_ Conn, err error) (action Action) {\n\tif err != nil {\n\t\tlogging.Debugf(\"error occurred on closed, %v\\n\", err)\n\t}\n\n\tatomic.AddInt32(&s.disconnected, 1)\n\tif atomic.LoadInt32(&s.connected) == atomic.LoadInt32(&s.disconnected) &&\n\t\tatomic.LoadInt32(&s.disconnected) == int32(s.nclients) {\n\t\taction = Shutdown\n\t}\n\n\treturn\n}\n\nfunc (s *simServer) OnTraffic(c Conn) (action Action) {\n\tcodec := c.Context().(*testCodec)\n\tvar packets [][]byte\n\tfor i := 0; i < s.batchRead; i++ {\n\t\tdata, err := codec.Decode(c)\n\t\tif errors.Is(err, errIncompletePacket) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlogging.Errorf(\"invalid packet: %v\", err)\n\t\t\treturn Close\n\t\t}\n\t\tpacket, _ := codec.Encode(data)\n\t\tpackets = append(packets, packet)\n\t}\n\tif n := len(packets); n > 1 {\n\t\t_, _ = c.Writev(packets)\n\t} else if n == 1 {\n\t\t_, _ = c.Write(packets[0])\n\t}\n\tif len(packets) == s.batchRead && c.InboundBuffered() > 0 {\n\t\terr := c.Wake(nil) // wake up the connection manually to avoid missing the leftover data\n\t\tassert.NoError(s.tester, err)\n\t}\n\treturn\n}\n\nfunc (s *simServer) OnTick() (delay time.Duration, action Action) {\n\tif atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tfor i := 0; i < s.nclients; i++ {\n\t\t\tgo func() {\n\t\t\t\trunSimClient(s.tester, s.network, s.addr, s.packetSize, s.batchWrite)\n\t\t\t}()\n\t\t}\n\t}\n\tdelay = 100 * time.Millisecond\n\treturn\n}\n\n// All current protocols.\nconst (\n\tmagicNumber     = 1314\n\tmagicNumberSize = 2\n\tbodySize        = 4\n)\n\nvar magicNumberBytes []byte\n\nfunc init() {\n\tmagicNumberBytes = make([]byte, magicNumberSize)\n\tbinary.BigEndian.PutUint16(magicNumberBytes, uint16(magicNumber))\n}\n\n// Protocol format:\n//\n// * 0           2                       6\n// * +-----------+-----------------------+\n// * |   magic   |       body len        |\n// * +-----------+-----------+-----------+\n// * |                                   |\n// * +                                   +\n// * |           body bytes              |\n// * +                                   +\n// * |            ... ...                |\n// * +-----------------------------------+.\ntype testCodec struct{}\n\nfunc (codec testCodec) Encode(buf []byte) ([]byte, error) {\n\tbodyOffset := magicNumberSize + bodySize\n\tmsgLen := bodyOffset + len(buf)\n\n\tdata := make([]byte, msgLen)\n\tcopy(data, magicNumberBytes)\n\n\tbinary.BigEndian.PutUint32(data[magicNumberSize:bodyOffset], uint32(len(buf)))\n\tcopy(data[bodyOffset:msgLen], buf)\n\treturn data, nil\n}\n\nfunc (codec testCodec) Decode(c Conn) ([]byte, error) {\n\tbodyOffset := magicNumberSize + bodySize\n\tbuf, err := c.Peek(bodyOffset)\n\tif err != nil {\n\t\tif errors.Is(err, io.ErrShortBuffer) {\n\t\t\terr = errIncompletePacket\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif !bytes.Equal(magicNumberBytes, buf[:magicNumberSize]) {\n\t\treturn nil, errors.New(\"invalid magic number\")\n\t}\n\n\tbodyLen := binary.BigEndian.Uint32(buf[magicNumberSize:bodyOffset])\n\tmsgLen := bodyOffset + int(bodyLen)\n\tbuf, err = c.Peek(msgLen)\n\tif err != nil {\n\t\tif errors.Is(err, io.ErrShortBuffer) {\n\t\t\terr = errIncompletePacket\n\t\t}\n\t\treturn nil, err\n\t}\n\tbody := make([]byte, bodyLen)\n\tcopy(body, buf[bodyOffset:msgLen])\n\t_, _ = c.Discard(msgLen)\n\n\treturn body, nil\n}\n\nfunc (codec testCodec) Unpack(buf []byte) ([]byte, error) {\n\tbodyOffset := magicNumberSize + bodySize\n\tif len(buf) < bodyOffset {\n\t\treturn nil, errIncompletePacket\n\t}\n\n\tif !bytes.Equal(magicNumberBytes, buf[:magicNumberSize]) {\n\t\treturn nil, errors.New(\"invalid magic number\")\n\t}\n\n\tbodyLen := binary.BigEndian.Uint32(buf[magicNumberSize:bodyOffset])\n\tmsgLen := bodyOffset + int(bodyLen)\n\tif len(buf) < msgLen {\n\t\treturn nil, errIncompletePacket\n\t}\n\n\treturn buf[bodyOffset:msgLen], nil\n}\n\nfunc TestSimServer(t *testing.T) {\n\tt.Run(\"packet-size=64,batch=200\", func(t *testing.T) {\n\t\trunSimServer(t, \":7200\", true, 10, 64, 200, -1)\n\t})\n\tt.Run(\"packet-size=128,batch=100\", func(t *testing.T) {\n\t\trunSimServer(t, \":7201\", false, 10, 128, 100, 10)\n\t})\n\tt.Run(\"packet-size=256,batch=50\", func(t *testing.T) {\n\t\trunSimServer(t, \":7202\", true, 10, 256, 50, -1)\n\t})\n\tt.Run(\"packet-size=512,batch=30\", func(t *testing.T) {\n\t\trunSimServer(t, \":7203\", false, 10, 512, 30, 3)\n\t})\n\tt.Run(\"packet-size=1024,batch=20\", func(t *testing.T) {\n\t\trunSimServer(t, \":7204\", true, 10, 1024, 20, -1)\n\t})\n\tt.Run(\"packet-size=64*1024,batch=10\", func(t *testing.T) {\n\t\trunSimServer(t, \":7205\", false, 10, 64*1024, 10, 1)\n\t})\n\tt.Run(\"packet-size=128*1024,batch=5\", func(t *testing.T) {\n\t\trunSimServer(t, \":7206\", true, 10, 128*1024, 5, -1)\n\t})\n\tt.Run(\"packet-size=512*1024,batch=3\", func(t *testing.T) {\n\t\trunSimServer(t, \":7207\", false, 10, 512*1024, 3, 1)\n\t})\n\tt.Run(\"packet-size=1024*1024,batch=2\", func(t *testing.T) {\n\t\trunSimServer(t, \":7208\", true, 10, 1024*1024, 2, -1)\n\t})\n}\n\nfunc runSimServer(t *testing.T, addr string, et bool, nclients, packetSize, batchWrite, batchRead int) {\n\tts := &simServer{\n\t\ttester:     t,\n\t\tnetwork:    \"tcp\",\n\t\taddr:       addr,\n\t\tmulticore:  true,\n\t\tnclients:   nclients,\n\t\tpacketSize: packetSize,\n\t\tbatchWrite: batchWrite,\n\t\tbatchRead:  batchRead,\n\t}\n\tif batchRead < 0 {\n\t\tts.batchRead = math.MaxInt32 // unlimited read batch\n\t}\n\terr := Run(ts,\n\t\tts.network+\"://\"+ts.addr,\n\t\tWithEdgeTriggeredIO(et),\n\t\tWithMulticore(ts.multicore),\n\t\tWithTicker(true),\n\t\tWithTCPKeepAlive(time.Minute*1))\n\tassert.NoError(t, err)\n}\n\nfunc runSimClient(t *testing.T, network, addr string, packetSize, batch int) {\n\tc, err := net.Dial(network, addr)\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\trd := bufio.NewReader(c)\n\tmsg, err := rd.ReadBytes('\\n')\n\trequire.NoError(t, err)\n\trequire.Equal(t, string(msg), \"sweetness\\r\\n\", \"bad header\")\n\tvar duration time.Duration\n\tpacketBytes := packetSize * batch\n\tswitch {\n\tcase packetBytes < 16*1024:\n\t\tduration = 2 * time.Second\n\tcase packetBytes < 32*1024:\n\t\tduration = 3 * time.Second\n\tcase packetBytes < 480*1024:\n\t\tduration = 4 * time.Second\n\tdefault:\n\t\tduration = 5 * time.Second\n\t}\n\tlogging.Debugf(\"test duration: %v\", duration)\n\tstart := time.Now()\n\tfor time.Since(start) < duration {\n\t\tbatchSendAndRecv(t, c, rd, packetSize, batch)\n\t}\n}\n\nfunc batchSendAndRecv(t *testing.T, c net.Conn, rd *bufio.Reader, packetSize, batch int) {\n\tcodec := testCodec{}\n\tvar (\n\t\trequests  [][]byte\n\t\tbuf       []byte\n\t\tpacketLen int\n\t)\n\tfor i := 0; i < batch; i++ {\n\t\treq := make([]byte, packetSize)\n\t\t_, err := crand.Read(req)\n\t\trequire.NoError(t, err)\n\t\trequests = append(requests, req)\n\t\tpacket, _ := codec.Encode(req)\n\t\tpacketLen = len(packet)\n\t\tbuf = append(buf, packet...)\n\t}\n\t_, err := c.Write(buf)\n\trequire.NoError(t, err)\n\trespPacket := make([]byte, batch*packetLen)\n\t_, err = io.ReadFull(rd, respPacket)\n\trequire.NoError(t, err)\n\tfor i, req := range requests {\n\t\trsp, err := codec.Unpack(respPacket[i*packetLen:])\n\t\trequire.NoError(t, err)\n\t\trequire.Equalf(t, req, rsp, \"request and response mismatch, packet size: %d, batch: %d, round: %d\",\n\t\t\tpacketSize, batch, i)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5322265625,
          "content": "module github.com/panjf2000/gnet/v2\n\nrequire (\n\tgithub.com/panjf2000/ants/v2 v2.10.0\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/valyala/bytebufferpool v1.0.0\n\tgo.uber.org/zap v1.21.0 // don't upgrade this one\n\tgolang.org/x/sync v0.8.0\n\tgolang.org/x/sys v0.25.0\n\tgopkg.in/natefinch/lumberjack.v2 v2.2.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgo.uber.org/atomic v1.7.0 // indirect\n\tgo.uber.org/multierr v1.6.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\ngo 1.20\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 6.9521484375,
          "content": "github.com/benbjohnson/clock v1.1.0 h1:Q92kusRqC1XV2MjkWETPvjJVqKetz1OzxZB7mHJLju8=\ngithub.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/panjf2000/ants/v2 v2.10.0 h1:zhRg1pQUtkyRiOFo2Sbqwjp0GfBNo9cUY2/Grpx1p+8=\ngithub.com/panjf2000/ants/v2 v2.10.0/go.mod h1:7ZxyxsqE4vvW0M7LSD8aI3cKwgFhBHbxnlN8mDqHa1I=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngo.uber.org/atomic v1.7.0 h1:ADUqmZGgLDDfbSL9ZmPxKTybcoEYHgpYfELNoN+7hsw=\ngo.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngo.uber.org/goleak v1.1.11 h1:wy28qYRKZgnJTxGxvye5/wgWr1EKjmUDGYox5mGlRlI=\ngo.uber.org/goleak v1.1.11/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngo.uber.org/multierr v1.6.0 h1:y6IPFStTAIT5Ytl7/XYmHvzXQ7S3g/IeZW9hyZ5thw4=\ngo.uber.org/multierr v1.6.0/go.mod h1:cdWPpRnG4AhwMwsgIHip0KRBQjJy5kYEpYjJxpXp9iU=\ngo.uber.org/zap v1.21.0 h1:WefMeulhovoZ2sYXz7st6K0sLj7bBhpiFaud4r4zST8=\ngo.uber.org/zap v1.21.0/go.mod h1:wjWOCqI0f2ZZrJF/UufIOkiC8ii6tm1iqIsLo76RfJw=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=\ngolang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=\ngolang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1 h1:bBRl1b0OH9s/DuPhuXpNl+VtCaJXFZ5/uEFST95x9zc=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1/go.mod h1:YD8tP3GAjkrDg1eZH7EGmyESg/lsYskCTPBJVb9jqSc=\ngopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "listener_unix.go",
          "type": "blob",
          "size": 3.9677734375,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n\t\"github.com/panjf2000/gnet/v2/pkg/socket\"\n)\n\ntype listener struct {\n\tonce             sync.Once\n\tfd               int\n\taddr             net.Addr\n\taddress, network string\n\tsockOptInts      []socket.Option[int]\n\tsockOptStrs      []socket.Option[string]\n\tpollAttachment   *netpoll.PollAttachment // listener attachment for poller\n}\n\nfunc (ln *listener) packPollAttachment(handler netpoll.PollEventHandler) *netpoll.PollAttachment {\n\tln.pollAttachment = &netpoll.PollAttachment{FD: ln.fd, Callback: handler}\n\treturn ln.pollAttachment\n}\n\nfunc (ln *listener) dup() (int, error) {\n\treturn socket.Dup(ln.fd)\n}\n\nfunc (ln *listener) normalize() (err error) {\n\tswitch ln.network {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tln.fd, ln.addr, err = socket.TCPSocket(ln.network, ln.address, true, ln.sockOptInts, ln.sockOptStrs)\n\t\tln.network = \"tcp\"\n\tcase \"udp\", \"udp4\", \"udp6\":\n\t\tln.fd, ln.addr, err = socket.UDPSocket(ln.network, ln.address, false, ln.sockOptInts, ln.sockOptStrs)\n\t\tln.network = \"udp\"\n\tcase \"unix\":\n\t\t_ = os.RemoveAll(ln.address)\n\t\tln.fd, ln.addr, err = socket.UnixSocket(ln.network, ln.address, true, ln.sockOptInts, ln.sockOptStrs)\n\tdefault:\n\t\terr = errors.ErrUnsupportedProtocol\n\t}\n\treturn\n}\n\nfunc (ln *listener) close() {\n\tln.once.Do(\n\t\tfunc() {\n\t\t\tif ln.fd > 0 {\n\t\t\t\tlogging.Error(os.NewSyscallError(\"close\", unix.Close(ln.fd)))\n\t\t\t}\n\t\t\tif ln.network == \"unix\" {\n\t\t\t\tlogging.Error(os.RemoveAll(ln.address))\n\t\t\t}\n\t\t})\n}\n\nfunc initListener(network, addr string, options *Options) (l *listener, err error) {\n\tvar (\n\t\tsockOptInts []socket.Option[int]\n\t\tsockOptStrs []socket.Option[string]\n\t)\n\tif options.ReusePort || strings.HasPrefix(network, \"udp\") {\n\t\tsockOpt := socket.Option[int]{SetSockOpt: socket.SetReuseport, Opt: 1}\n\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t}\n\tif options.ReuseAddr {\n\t\tsockOpt := socket.Option[int]{SetSockOpt: socket.SetReuseAddr, Opt: 1}\n\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t}\n\tif options.TCPNoDelay == TCPNoDelay && strings.HasPrefix(network, \"tcp\") {\n\t\tsockOpt := socket.Option[int]{SetSockOpt: socket.SetNoDelay, Opt: 1}\n\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t}\n\tif options.SocketRecvBuffer > 0 {\n\t\tsockOpt := socket.Option[int]{SetSockOpt: socket.SetRecvBuffer, Opt: options.SocketRecvBuffer}\n\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t}\n\tif options.SocketSendBuffer > 0 {\n\t\tsockOpt := socket.Option[int]{SetSockOpt: socket.SetSendBuffer, Opt: options.SocketSendBuffer}\n\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t}\n\tif strings.HasPrefix(network, \"udp\") {\n\t\tudpAddr, err := net.ResolveUDPAddr(network, addr)\n\t\tif err == nil && udpAddr.IP.IsMulticast() {\n\t\t\tif sockoptFn := socket.SetMulticastMembership(network, udpAddr); sockoptFn != nil {\n\t\t\t\tsockOpt := socket.Option[int]{SetSockOpt: sockoptFn, Opt: options.MulticastInterfaceIndex}\n\t\t\t\tsockOptInts = append(sockOptInts, sockOpt)\n\t\t\t}\n\t\t}\n\t}\n\tif options.BindToDevice != \"\" {\n\t\tsockOpt := socket.Option[string]{SetSockOpt: socket.SetBindToDevice, Opt: options.BindToDevice}\n\t\tsockOptStrs = append(sockOptStrs, sockOpt)\n\t}\n\tl = &listener{network: network, address: addr, sockOptInts: sockOptInts, sockOptStrs: sockOptStrs}\n\terr = l.normalize()\n\treturn\n}\n"
        },
        {
          "name": "listener_windows.go",
          "type": "blob",
          "size": 3.2978515625,
          "content": "// Copyright (c) 2023 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\ntype listener struct {\n\tnetwork string\n\taddress string\n\tonce    sync.Once\n\tln      net.Listener\n\tpc      net.PacketConn\n\taddr    net.Addr\n}\n\nfunc (l *listener) dup() (int, error) {\n\tif l.ln == nil && l.pc == nil {\n\t\treturn -1, errorx.ErrUnsupportedOp\n\t}\n\n\tvar (\n\t\tsc syscall.Conn\n\t\tok bool\n\t)\n\tif l.ln != nil {\n\t\tsc, ok = l.ln.(syscall.Conn)\n\t} else {\n\t\tsc, ok = l.pc.(syscall.Conn)\n\t}\n\n\tif !ok {\n\t\treturn -1, errors.New(\"failed to convert net.Conn to syscall.Conn\")\n\t}\n\trc, err := sc.SyscallConn()\n\tif err != nil {\n\t\treturn -1, errors.New(\"failed to get syscall.RawConn from net.Conn\")\n\t}\n\n\tvar dupHandle windows.Handle\n\te := rc.Control(func(fd uintptr) {\n\t\tprocess := windows.CurrentProcess()\n\t\terr = windows.DuplicateHandle(\n\t\t\tprocess,\n\t\t\twindows.Handle(fd),\n\t\t\tprocess,\n\t\t\t&dupHandle,\n\t\t\t0,\n\t\t\ttrue,\n\t\t\twindows.DUPLICATE_SAME_ACCESS,\n\t\t)\n\t})\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif e != nil {\n\t\treturn -1, e\n\t}\n\n\treturn int(dupHandle), nil\n}\n\nfunc (l *listener) close() {\n\tl.once.Do(func() {\n\t\tif l.pc != nil {\n\t\t\tlogging.Error(os.NewSyscallError(\"close\", l.pc.Close()))\n\t\t\treturn\n\t\t}\n\t\tlogging.Error(os.NewSyscallError(\"close\", l.ln.Close()))\n\t})\n}\n\nfunc initListener(network, addr string, options *Options) (l *listener, err error) {\n\tlc := net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t\treturn c.Control(func(fd uintptr) {\n\t\t\t\tif network != \"unix\" && (options.ReuseAddr || options.ReusePort) {\n\t\t\t\t\t_ = windows.SetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_REUSEADDR, 1)\n\t\t\t\t}\n\t\t\t\tif options.TCPNoDelay == TCPNoDelay {\n\t\t\t\t\t_ = windows.SetsockoptInt(windows.Handle(fd), windows.IPPROTO_TCP, windows.TCP_NODELAY, 1)\n\t\t\t\t}\n\t\t\t\tif options.SocketRecvBuffer > 0 {\n\t\t\t\t\t_ = windows.SetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_RCVBUF, options.SocketRecvBuffer)\n\t\t\t\t}\n\t\t\t\tif options.SocketSendBuffer > 0 {\n\t\t\t\t\t_ = windows.SetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_SNDBUF, options.SocketSendBuffer)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\tKeepAlive: options.TCPKeepAlive,\n\t}\n\tl = &listener{network: network, address: addr}\n\tswitch network {\n\tcase \"udp\", \"udp4\", \"udp6\":\n\t\tif l.pc, err = lc.ListenPacket(context.Background(), network, addr); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tl.addr = l.pc.LocalAddr()\n\tcase \"unix\":\n\t\t_ = os.Remove(addr)\n\t\tfallthrough\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tif l.ln, err = lc.Listen(context.Background(), network, addr); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tl.addr = l.ln.Addr()\n\tdefault:\n\t\terr = errorx.ErrUnsupportedProtocol\n\t}\n\treturn\n}\n"
        },
        {
          "name": "load_balancer.go",
          "type": "blob",
          "size": 3.8916015625,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"hash/crc32\"\n\t\"net\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/bs\"\n)\n\n// LoadBalancing represents the type of load-balancing algorithm.\ntype LoadBalancing int\n\nconst (\n\t// RoundRobin assigns the next accepted connection to the event-loop by polling event-loop list.\n\tRoundRobin LoadBalancing = iota\n\n\t// LeastConnections assigns the next accepted connection to the event-loop that is\n\t// serving the least number of active connections at the current time.\n\tLeastConnections\n\n\t// SourceAddrHash assigns the next accepted connection to the event-loop by hashing the remote address.\n\tSourceAddrHash\n)\n\ntype (\n\t// loadBalancer is an interface which manipulates the event-loop set.\n\tloadBalancer interface {\n\t\tregister(*eventloop)\n\t\tnext(net.Addr) *eventloop\n\t\tindex(int) *eventloop\n\t\titerate(func(int, *eventloop) bool)\n\t\tlen() int\n\t}\n\n\t// baseLoadBalancer with base lb.\n\tbaseLoadBalancer struct {\n\t\teventLoops []*eventloop\n\t\tsize       int\n\t}\n\n\t// roundRobinLoadBalancer with Round-Robin algorithm.\n\troundRobinLoadBalancer struct {\n\t\tbaseLoadBalancer\n\t\tnextIndex uint64\n\t}\n\n\t// leastConnectionsLoadBalancer with Least-Connections algorithm.\n\tleastConnectionsLoadBalancer struct {\n\t\tbaseLoadBalancer\n\t}\n\n\t// sourceAddrHashLoadBalancer with Hash algorithm.\n\tsourceAddrHashLoadBalancer struct {\n\t\tbaseLoadBalancer\n\t}\n)\n\n// ==================================== Implementation of base load-balancer ====================================\n\n// register adds a new eventloop into load-balancer.\nfunc (lb *baseLoadBalancer) register(el *eventloop) {\n\tel.idx = lb.size\n\tlb.eventLoops = append(lb.eventLoops, el)\n\tlb.size++\n}\n\n// index returns the eligible eventloop by index.\nfunc (lb *baseLoadBalancer) index(i int) *eventloop {\n\tif i >= lb.size {\n\t\treturn nil\n\t}\n\treturn lb.eventLoops[i]\n}\n\n// iterate iterates all the eventloops.\nfunc (lb *baseLoadBalancer) iterate(f func(int, *eventloop) bool) {\n\tfor i, el := range lb.eventLoops {\n\t\tif !f(i, el) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// len returns the length of event-loop list.\nfunc (lb *baseLoadBalancer) len() int {\n\treturn lb.size\n}\n\n// ==================================== Implementation of Round-Robin load-balancer ====================================\n\n// next returns the eligible event-loop based on Round-Robin algorithm.\nfunc (lb *roundRobinLoadBalancer) next(_ net.Addr) (el *eventloop) {\n\tel = lb.eventLoops[lb.nextIndex%uint64(lb.size)]\n\tlb.nextIndex++\n\treturn\n}\n\n// ================================= Implementation of Least-Connections load-balancer =================================\n\nfunc (lb *leastConnectionsLoadBalancer) next(_ net.Addr) (el *eventloop) {\n\tel = lb.eventLoops[0]\n\tminN := el.countConn()\n\tfor _, v := range lb.eventLoops[1:] {\n\t\tif n := v.countConn(); n < minN {\n\t\t\tminN = n\n\t\t\tel = v\n\t\t}\n\t}\n\treturn\n}\n\n// ======================================= Implementation of Hash load-balancer ========================================\n\n// hash converts a string to a unique hash code.\nfunc (*sourceAddrHashLoadBalancer) hash(s string) int {\n\tv := int(crc32.ChecksumIEEE(bs.StringToBytes(s)))\n\tif v >= 0 {\n\t\treturn v\n\t}\n\treturn -v\n}\n\n// next returns the eligible event-loop by taking the remainder of a hash code as the index of event-loop list.\nfunc (lb *sourceAddrHashLoadBalancer) next(netAddr net.Addr) *eventloop {\n\thashCode := lb.hash(netAddr.String())\n\treturn lb.eventLoops[hashCode%lb.size]\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 9.9853515625,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gnet\n\nimport (\n\t\"time\"\n\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\n// Option is a function that will set up option.\ntype Option func(opts *Options)\n\nfunc loadOptions(options ...Option) *Options {\n\topts := new(Options)\n\tfor _, option := range options {\n\t\toption(opts)\n\t}\n\treturn opts\n}\n\n// TCPSocketOpt is the type of TCP socket options.\ntype TCPSocketOpt int\n\n// Available TCP socket options.\nconst (\n\tTCPNoDelay TCPSocketOpt = iota\n\tTCPDelay\n)\n\n// Options are configurations for the gnet application.\ntype Options struct {\n\t// ================================== Options for only server-side ==================================\n\n\t// Multicore indicates whether the engine will be effectively created with multi-cores, if so,\n\t// then you must take care with synchronizing memory between all event callbacks, otherwise,\n\t// it will run the engine with single thread. The number of threads in the engine will be\n\t// automatically assigned to the number of usable logical CPUs that can be leveraged by the\n\t// current process.\n\tMulticore bool\n\n\t// NumEventLoop is set up to start the given number of event-loop goroutines.\n\t// Note that a non-negative NumEventLoop will override Multicore.\n\tNumEventLoop int\n\n\t// LB represents the load-balancing algorithm used when assigning new connections\n\t// to event loops.\n\tLB LoadBalancing\n\n\t// ReuseAddr indicates whether to set the SO_REUSEADDR socket option.\n\tReuseAddr bool\n\n\t// ReusePort indicates whether to set the SO_REUSEPORT socket option.\n\tReusePort bool\n\n\t// MulticastInterfaceIndex is the index of the interface name where the multicast UDP addresses will be bound to.\n\tMulticastInterfaceIndex int\n\n\t// BindToDevice is the name of the interface to which the listening socket will be bound.\n\t//\n\t// It is only available on Linux at the moment, an error will therefore be returned when\n\t// setting this option on non-linux platforms.\n\tBindToDevice string\n\n\t// ============================= Options for both server-side and client-side =============================\n\n\t// ReadBufferCap is the maximum number of bytes that can be read from the remote when the readable event comes.\n\t// The default value is 64KB, it can either be reduced to avoid starving the subsequent connections or increased\n\t// to read more data from a socket.\n\t//\n\t// Note that ReadBufferCap will always be converted to the least power of two integer value greater than\n\t// or equal to its real amount.\n\tReadBufferCap int\n\n\t// WriteBufferCap is the maximum number of bytes that a static outbound buffer can hold,\n\t// if the data exceeds this value, the overflow bytes will be stored in the elastic linked list buffer.\n\t// The default value is 64KB.\n\t//\n\t// Note that WriteBufferCap will always be converted to the least power of two integer value greater than\n\t// or equal to its real amount.\n\tWriteBufferCap int\n\n\t// LockOSThread is used to determine whether each I/O event-loop should be associated to an OS thread,\n\t// it is useful when you need some kind of mechanisms like thread local storage, or invoke certain C\n\t// libraries (such as graphics lib: GLib) that require thread-level manipulation via cgo, or want all I/O\n\t// event-loops to actually run in parallel for a potential higher performance.\n\tLockOSThread bool\n\n\t// Ticker indicates whether the ticker has been set up.\n\tTicker bool\n\n\t// TCPKeepAlive enables the TCP keep-alive mechanism (SO_KEEPALIVE) and set its value\n\t// on TCP_KEEPIDLE, 1/5 of its value on TCP_KEEPINTVL, and 5 on TCP_KEEPCNT.\n\tTCPKeepAlive time.Duration\n\n\t// TCPNoDelay controls whether the operating system should delay\n\t// packet transmission in hopes of sending fewer packets (Nagle's algorithm).\n\t// When this option is assigned to TCPNoDelay, TCP_NODELAY socket option will\n\t// be turned on, on the contrary, if it is assigned to TCPDelay, the socket\n\t// option will be turned off.\n\t//\n\t// The default is TCPNoDelay, meaning that TCP_NODELAY is turned on and data\n\t// will not be buffered but sent as soon as possible after a write operation.\n\tTCPNoDelay TCPSocketOpt\n\n\t// SocketRecvBuffer sets the maximum socket receive buffer of kernel in bytes.\n\tSocketRecvBuffer int\n\n\t// SocketSendBuffer sets the maximum socket send buffer of kernel in bytes.\n\tSocketSendBuffer int\n\n\t// LogPath specifies a local path where logs will be written, this is the easiest\n\t// way to set up logging, gnet instantiates a default uber-go/zap logger with this\n\t// given log path, you are also allowed to employ your own logger during the lifetime\n\t// by implementing the following logging.Logger interface.\n\t//\n\t// Note that this option can be overridden by a non-nil option Logger.\n\tLogPath string\n\n\t// LogLevel specifies the logging level, it should be used along with LogPath.\n\tLogLevel logging.Level\n\n\t// Logger is the customized logger for logging info, if it is not set,\n\t// then gnet will use the default logger powered by go.uber.org/zap.\n\tLogger logging.Logger\n\n\t// EdgeTriggeredIO enables the edge-triggered I/O for the underlying epoll/kqueue event-loop.\n\t// Don't enable it unless you are 100% sure what you are doing.\n\t// Note that this option is only available for stream-oriented protocol.\n\tEdgeTriggeredIO bool\n\n\t// EdgeTriggeredIOChunk specifies the number of bytes that `gnet` can\n\t// read/write up to in one event loop of ET. This option implies\n\t// EdgeTriggeredIO when it is set to a value greater than 0.\n\t// If EdgeTriggeredIO is set to true and EdgeTriggeredIOChunk is not set,\n\t// 1MB is used. The value of EdgeTriggeredIOChunk must be a power of 2,\n\t// otherwise, it will be rounded up to the nearest power of 2.\n\tEdgeTriggeredIOChunk int\n}\n\n// WithOptions sets up all options.\nfunc WithOptions(options Options) Option {\n\treturn func(opts *Options) {\n\t\t*opts = options\n\t}\n}\n\n// WithMulticore enables multi-cores mode for gnet engine.\nfunc WithMulticore(multicore bool) Option {\n\treturn func(opts *Options) {\n\t\topts.Multicore = multicore\n\t}\n}\n\n// WithLockOSThread enables LockOSThread mode for I/O event-loops.\nfunc WithLockOSThread(lockOSThread bool) Option {\n\treturn func(opts *Options) {\n\t\topts.LockOSThread = lockOSThread\n\t}\n}\n\n// WithReadBufferCap sets ReadBufferCap for reading bytes.\nfunc WithReadBufferCap(readBufferCap int) Option {\n\treturn func(opts *Options) {\n\t\topts.ReadBufferCap = readBufferCap\n\t}\n}\n\n// WithWriteBufferCap sets WriteBufferCap for pending bytes.\nfunc WithWriteBufferCap(writeBufferCap int) Option {\n\treturn func(opts *Options) {\n\t\topts.WriteBufferCap = writeBufferCap\n\t}\n}\n\n// WithLoadBalancing picks the load-balancing algorithm for gnet engine.\nfunc WithLoadBalancing(lb LoadBalancing) Option {\n\treturn func(opts *Options) {\n\t\topts.LB = lb\n\t}\n}\n\n// WithNumEventLoop sets the number of event loops for gnet engine.\nfunc WithNumEventLoop(numEventLoop int) Option {\n\treturn func(opts *Options) {\n\t\topts.NumEventLoop = numEventLoop\n\t}\n}\n\n// WithReusePort sets SO_REUSEPORT socket option.\nfunc WithReusePort(reusePort bool) Option {\n\treturn func(opts *Options) {\n\t\topts.ReusePort = reusePort\n\t}\n}\n\n// WithReuseAddr sets SO_REUSEADDR socket option.\nfunc WithReuseAddr(reuseAddr bool) Option {\n\treturn func(opts *Options) {\n\t\topts.ReuseAddr = reuseAddr\n\t}\n}\n\n// WithTCPKeepAlive enables the TCP keep-alive mechanism and sets its values.\nfunc WithTCPKeepAlive(tcpKeepAlive time.Duration) Option {\n\treturn func(opts *Options) {\n\t\topts.TCPKeepAlive = tcpKeepAlive\n\t}\n}\n\n// WithTCPNoDelay enable/disable the TCP_NODELAY socket option.\nfunc WithTCPNoDelay(tcpNoDelay TCPSocketOpt) Option {\n\treturn func(opts *Options) {\n\t\topts.TCPNoDelay = tcpNoDelay\n\t}\n}\n\n// WithSocketRecvBuffer sets the maximum socket receive buffer of kernel in bytes.\nfunc WithSocketRecvBuffer(recvBuf int) Option {\n\treturn func(opts *Options) {\n\t\topts.SocketRecvBuffer = recvBuf\n\t}\n}\n\n// WithSocketSendBuffer sets the maximum socket send buffer of kernel in bytes.\nfunc WithSocketSendBuffer(sendBuf int) Option {\n\treturn func(opts *Options) {\n\t\topts.SocketSendBuffer = sendBuf\n\t}\n}\n\n// WithTicker indicates whether a ticker is currently set.\nfunc WithTicker(ticker bool) Option {\n\treturn func(opts *Options) {\n\t\topts.Ticker = ticker\n\t}\n}\n\n// WithLogPath specifies a local path for logging file.\nfunc WithLogPath(fileName string) Option {\n\treturn func(opts *Options) {\n\t\topts.LogPath = fileName\n\t}\n}\n\n// WithLogLevel specifies the logging level for the local logging file.\nfunc WithLogLevel(lvl logging.Level) Option {\n\treturn func(opts *Options) {\n\t\topts.LogLevel = lvl\n\t}\n}\n\n// WithLogger specifies a customized logger.\nfunc WithLogger(logger logging.Logger) Option {\n\treturn func(opts *Options) {\n\t\topts.Logger = logger\n\t}\n}\n\n// WithMulticastInterfaceIndex sets the interface name where UDP multicast sockets will be bound to.\nfunc WithMulticastInterfaceIndex(idx int) Option {\n\treturn func(opts *Options) {\n\t\topts.MulticastInterfaceIndex = idx\n\t}\n}\n\n// WithBindToDevice sets the name of the interface to which the listening socket will be bound.\n//\n// It is only available on Linux at the moment, an error will therefore be returned when\n// setting this option on non-linux platforms.\nfunc WithBindToDevice(iface string) Option {\n\treturn func(opts *Options) {\n\t\topts.BindToDevice = iface\n\t}\n}\n\n// WithEdgeTriggeredIO enables the edge-triggered I/O for the underlying epoll/kqueue event-loop.\nfunc WithEdgeTriggeredIO(et bool) Option {\n\treturn func(opts *Options) {\n\t\topts.EdgeTriggeredIO = et\n\t}\n}\n\n// WithEdgeTriggeredIOChunk sets the number of bytes that `gnet` can\n// read/write up to in one event loop of ET.\nfunc WithEdgeTriggeredIOChunk(chunk int) Option {\n\treturn func(opts *Options) {\n\t\topts.EdgeTriggeredIOChunk = chunk\n\t}\n}\n"
        },
        {
          "name": "os_unix_test.go",
          "type": "blob",
          "size": 19.60546875,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd\n\npackage gnet\n\nimport (\n\t\"context\"\n\tcrand \"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/sys/unix\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/logging\"\n)\n\nvar (\n\tSysClose = unix.Close\n\tstdDial  = net.Dial\n)\n\n// NOTE: TestServeMulticast can fail with \"write: no buffer space available\" on Wi-Fi interface.\nfunc TestServeMulticast(t *testing.T) {\n\tt.Run(\"IPv4\", func(t *testing.T) {\n\t\t// 224.0.0.169 is an unassigned address from the Local Network Control Block\n\t\t// https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml#multicast-addresses-1\n\t\tt.Run(\"udp-multicast\", func(t *testing.T) {\n\t\t\ttestMulticast(t, \"224.0.0.169:9991\", false, false, -1, 10)\n\t\t})\n\t\tt.Run(\"udp-multicast-reuseport\", func(t *testing.T) {\n\t\t\ttestMulticast(t, \"224.0.0.169:9991\", true, false, -1, 10)\n\t\t})\n\t\tt.Run(\"udp-multicast-reuseaddr\", func(t *testing.T) {\n\t\t\ttestMulticast(t, \"224.0.0.169:9991\", false, true, -1, 10)\n\t\t})\n\t})\n\tt.Run(\"IPv6\", func(t *testing.T) {\n\t\tiface, err := findLoopbackInterface()\n\t\trequire.NoError(t, err)\n\t\tif iface.Flags&net.FlagMulticast != net.FlagMulticast {\n\t\t\tt.Skip(\"multicast is not supported on loopback interface\")\n\t\t}\n\t\t// ff02::3 is an unassigned address from Link-Local Scope Multicast Addresses\n\t\t// https://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml#link-local\n\t\tt.Run(\"udp-multicast\", func(t *testing.T) {\n\t\t\ttestMulticast(t, fmt.Sprintf(\"[ff02::3%%%s]:9991\", iface.Name), false, false, iface.Index, 10)\n\t\t})\n\t\tt.Run(\"udp-multicast-reuseport\", func(t *testing.T) {\n\t\t\ttestMulticast(t, fmt.Sprintf(\"[ff02::3%%%s]:9991\", iface.Name), true, false, iface.Index, 10)\n\t\t})\n\t\tt.Run(\"udp-multicast-reuseaddr\", func(t *testing.T) {\n\t\t\ttestMulticast(t, fmt.Sprintf(\"[ff02::3%%%s]:9991\", iface.Name), false, true, iface.Index, 10)\n\t\t})\n\t})\n}\n\nfunc findLoopbackInterface() (*net.Interface, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagLoopback == net.FlagLoopback {\n\t\t\treturn &iface, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"no loopback interface\")\n}\n\nfunc testMulticast(t *testing.T, addr string, reuseport, reuseaddr bool, index, nclients int) {\n\tts := &testMcastServer{\n\t\tt:        t,\n\t\taddr:     addr,\n\t\tnclients: nclients,\n\t}\n\toptions := []Option{\n\t\tWithReuseAddr(reuseaddr),\n\t\tWithReusePort(reuseport),\n\t\tWithSocketRecvBuffer(2 * nclients * 1024), // enough space to receive messages from nclients to eliminate dropped packets\n\t\tWithTicker(true),\n\t}\n\tif index != -1 {\n\t\toptions = append(options, WithMulticastInterfaceIndex(index))\n\t}\n\terr := Run(ts, \"udp://\"+addr, options...)\n\tassert.NoError(t, err)\n}\n\ntype testMcastServer struct {\n\t*BuiltinEventEngine\n\tt        *testing.T\n\tmcast    sync.Map\n\taddr     string\n\tnclients int\n\tstarted  int32\n\tactive   int32\n}\n\nfunc (s *testMcastServer) startMcastClient() {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tc, err := net.Dial(\"udp\", s.addr)\n\trequire.NoError(s.t, err)\n\tdefer c.Close()\n\tch := make(chan []byte, 10000)\n\ts.mcast.Store(c.LocalAddr().String(), ch)\n\tduration := time.Duration((rand.Float64()*2+1)*float64(time.Second)) / 2\n\tlogging.Debugf(\"test duration: %v\", duration)\n\tstart := time.Now()\n\tfor time.Since(start) < duration {\n\t\treqData := make([]byte, 1024)\n\t\t_, err = crand.Read(reqData)\n\t\trequire.NoError(s.t, err)\n\t\t_, err = c.Write(reqData)\n\t\trequire.NoError(s.t, err)\n\t\t// Workaround for MacOS \"write: no buffer space available\" error messages\n\t\t// https://developer.apple.com/forums/thread/42334\n\t\ttime.Sleep(time.Millisecond)\n\t\tselect {\n\t\tcase respData := <-ch:\n\t\t\trequire.Equalf(s.t, reqData, respData, \"response mismatch, length of bytes: %d vs %d\", len(reqData), len(respData))\n\t\tcase <-ctx.Done():\n\t\t\trequire.Fail(s.t, \"timeout receiving message\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *testMcastServer) OnTraffic(c Conn) (action Action) {\n\tbuf, _ := c.Next(-1)\n\tb := make([]byte, len(buf))\n\tcopy(b, buf)\n\tch, ok := s.mcast.Load(c.RemoteAddr().String())\n\trequire.True(s.t, ok)\n\tch.(chan []byte) <- b\n\treturn\n}\n\nfunc (s *testMcastServer) OnTick() (delay time.Duration, action Action) {\n\tif atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tfor i := 0; i < s.nclients; i++ {\n\t\t\tatomic.AddInt32(&s.active, 1)\n\t\t\tgo func() {\n\t\t\t\tdefer atomic.AddInt32(&s.active, -1)\n\t\t\t\ts.startMcastClient()\n\t\t\t}()\n\t\t}\n\t}\n\tif atomic.LoadInt32(&s.active) == 0 {\n\t\taction = Shutdown\n\t\treturn\n\t}\n\tdelay = time.Second / 5\n\treturn\n}\n\ntype testMulticastBindServer struct {\n\t*BuiltinEventEngine\n}\n\nfunc (t *testMulticastBindServer) OnTick() (delay time.Duration, action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc TestMulticastBindIPv4(t *testing.T) {\n\tts := &testMulticastBindServer{}\n\tiface, err := findLoopbackInterface()\n\trequire.NoError(t, err)\n\terr = Run(ts, \"udp://224.0.0.169:9991\",\n\t\tWithMulticastInterfaceIndex(iface.Index),\n\t\tWithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc TestMulticastBindIPv6(t *testing.T) {\n\tts := &testMulticastBindServer{}\n\tiface, err := findLoopbackInterface()\n\trequire.NoError(t, err)\n\terr = Run(ts, fmt.Sprintf(\"udp://[ff02::3%%%s]:9991\", iface.Name),\n\t\tWithMulticastInterfaceIndex(iface.Index),\n\t\tWithTicker(true))\n\tassert.NoError(t, err)\n}\n\nfunc detectLinuxEthernetInterfaceName() (string, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Traditionally, network interfaces were named as eth0, eth1, etc., for Ethernet interfaces.\n\t// However, with the introduction of predictable network interface names. Meanwhile, modern\n\t// convention commonly uses patterns like eno[1-N], ens[1-N], enp<PCI slot>s<card index no>, etc.,\n\t// for Ethernet interfaces.\n\t// Check out https://www.thomas-krenn.com/en/wiki/Predictable_Network_Interface_Names and\n\t// https://en.wikipedia.org/wiki/Consistent_Network_Device_Naming for more details.\n\tregex := regexp.MustCompile(`e(no|ns|np|th)\\d+s*\\d*$`)\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagLoopback != 0 || iface.Flags&net.FlagUp == 0 || iface.Flags&net.FlagRunning == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif regex.MatchString(iface.Name) {\n\t\t\treturn iface.Name, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no Ethernet interface found\")\n}\n\nfunc getInterfaceIP(ifname string, ipv4 bool) (net.IP, error) {\n\tiface, err := net.InterfaceByName(ifname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Get all unicast addresses for this interface\n\taddrs, err := iface.Addrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Loop through the addresses and find the first IPv4 address\n\tfor _, addr := range addrs {\n\t\tvar ip net.IP\n\t\tswitch v := addr.(type) {\n\t\tcase *net.IPNet:\n\t\t\tip = v.IP\n\t\tcase *net.IPAddr:\n\t\t\tip = v.IP\n\t\t}\n\t\t// Check if the IP is IPv4.\n\t\tif ip != nil && (ip.To4() != nil) == ipv4 {\n\t\t\treturn ip, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"no valid IP address found\")\n}\n\ntype testBindToDeviceServer[T interface{ *net.TCPAddr | *net.UDPAddr }] struct {\n\tBuiltinEventEngine\n\ttester          *testing.T\n\tdata            []byte\n\tpackets         atomic.Int32\n\texpectedPackets int32\n\tnetwork         string\n\tloopBackAddr    T\n\teth0Addr        T\n\tbroadcastAddr   T\n}\n\nfunc netDial[T *net.TCPAddr | *net.UDPAddr](network string, a T) (net.Conn, error) {\n\taddr := any(a)\n\tswitch v := addr.(type) {\n\tcase *net.TCPAddr:\n\t\treturn net.DialTCP(network, nil, v)\n\tcase *net.UDPAddr:\n\t\treturn net.DialUDP(network, nil, v)\n\tdefault:\n\t\treturn nil, errors.New(\"unsupported address type\")\n\t}\n}\n\nfunc (s *testBindToDeviceServer[T]) OnTraffic(c Conn) (action Action) {\n\tb, err := c.Next(-1)\n\tassert.NoError(s.tester, err)\n\tassert.EqualValues(s.tester, s.data, b)\n\t_, err = c.Write(b)\n\tassert.NoError(s.tester, err)\n\ts.packets.Add(1)\n\treturn\n}\n\nfunc (s *testBindToDeviceServer[T]) OnShutdown(_ Engine) {\n\tassert.EqualValues(s.tester, s.expectedPackets, s.packets.Load())\n}\n\nfunc (s *testBindToDeviceServer[T]) OnTick() (delay time.Duration, action Action) {\n\t// Send a packet to the loopback interface, it should never make its way to the server\n\t// because we've bound the server to eth0.\n\tc, err := netDial(s.network, s.loopBackAddr)\n\tif strings.HasPrefix(s.network, \"tcp\") {\n\t\tassert.ErrorContains(s.tester, err, \"connection refused\")\n\t} else {\n\t\tassert.NoError(s.tester, err)\n\t\tdefer c.Close()\n\t\t_, err = c.Write(s.data)\n\t\tassert.NoError(s.tester, err)\n\t}\n\n\tif s.broadcastAddr != nil {\n\t\t// Send a packet to the broadcast address, it should reach the server.\n\t\tc6, err := netDial(s.network, s.broadcastAddr)\n\t\tassert.NoError(s.tester, err)\n\t\tdefer c6.Close()\n\t\t_, err = c6.Write(s.data)\n\t\tassert.NoError(s.tester, err)\n\t}\n\n\t// Send a packet to the eth0 interface, it should reach the server.\n\tc4, err := netDial(s.network, s.eth0Addr)\n\tassert.NoError(s.tester, err)\n\tdefer c4.Close()\n\t_, err = c4.Write(s.data)\n\tassert.NoError(s.tester, err)\n\tbuf := make([]byte, len(s.data))\n\t_, err = c4.Read(buf)\n\tassert.NoError(s.tester, err)\n\tassert.EqualValues(s.tester, s.data, buf, len(s.data), len(buf))\n\n\treturn time.Second, Shutdown\n}\n\nfunc TestBindToDevice(t *testing.T) {\n\tif runtime.GOOS != \"linux\" {\n\t\terr := Run(&testBindToDeviceServer[*net.UDPAddr]{}, \"tcp://:9999\", WithBindToDevice(\"eth0\"))\n\t\tassert.ErrorIs(t, err, errorx.ErrUnsupportedOp)\n\t\treturn\n\t}\n\n\tlp, err := findLoopbackInterface()\n\tassert.NoError(t, err)\n\tdev, err := detectLinuxEthernetInterfaceName()\n\tassert.NoErrorf(t, err, \"no testable Ethernet interface found\")\n\tt.Logf(\"detected Ethernet interface: %s\", dev)\n\tdata := []byte(\"hello\")\n\tt.Run(\"IPv4\", func(t *testing.T) {\n\t\tip, err := getInterfaceIP(dev, true)\n\t\tassert.NoError(t, err)\n\t\tt.Run(\"TCP\", func(t *testing.T) {\n\t\t\tts := &testBindToDeviceServer[*net.TCPAddr]{\n\t\t\t\ttester:          t,\n\t\t\t\tdata:            data,\n\t\t\t\texpectedPackets: 1,\n\t\t\t\tnetwork:         \"tcp\",\n\t\t\t\tloopBackAddr:    &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 9999, Zone: \"\"},\n\t\t\t\teth0Addr:        &net.TCPAddr{IP: ip, Port: 9999, Zone: \"\"},\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\terr = Run(ts, \"tcp://0.0.0.0:9999\",\n\t\t\t\tWithTicker(true),\n\t\t\t\tWithBindToDevice(dev))\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tt.Run(\"UDP\", func(t *testing.T) {\n\t\t\tts := &testBindToDeviceServer[*net.UDPAddr]{\n\t\t\t\ttester:          t,\n\t\t\t\tdata:            data,\n\t\t\t\texpectedPackets: 2,\n\t\t\t\tnetwork:         \"udp\",\n\t\t\t\tloopBackAddr:    &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 9999, Zone: \"\"},\n\t\t\t\teth0Addr:        &net.UDPAddr{IP: ip, Port: 9999, Zone: \"\"},\n\t\t\t\tbroadcastAddr:   &net.UDPAddr{IP: net.IPv4bcast, Port: 9999, Zone: \"\"},\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\terr = Run(ts, \"udp://0.0.0.0:9999\",\n\t\t\t\tWithTicker(true),\n\t\t\t\tWithBindToDevice(dev))\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t})\n\tt.Run(\"IPv6\", func(t *testing.T) {\n\t\tt.Run(\"TCP\", func(t *testing.T) {\n\t\t\tip, err := getInterfaceIP(dev, false)\n\t\t\tassert.NoError(t, err)\n\t\t\tts := &testBindToDeviceServer[*net.TCPAddr]{\n\t\t\t\ttester:          t,\n\t\t\t\tdata:            data,\n\t\t\t\texpectedPackets: 1,\n\t\t\t\tnetwork:         \"tcp6\",\n\t\t\t\tloopBackAddr:    &net.TCPAddr{IP: net.IPv6loopback, Port: 9999, Zone: lp.Name},\n\t\t\t\teth0Addr:        &net.TCPAddr{IP: ip, Port: 9999, Zone: dev},\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\terr = Run(ts, \"tcp6://[::]:9999\",\n\t\t\t\tWithTicker(true),\n\t\t\t\tWithBindToDevice(dev))\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tt.Run(\"UDP\", func(t *testing.T) {\n\t\t\tip, err := getInterfaceIP(dev, false)\n\t\t\tassert.NoError(t, err)\n\t\t\tts := &testBindToDeviceServer[*net.UDPAddr]{\n\t\t\t\ttester:          t,\n\t\t\t\tdata:            data,\n\t\t\t\texpectedPackets: 2,\n\t\t\t\tnetwork:         \"udp6\",\n\t\t\t\tloopBackAddr:    &net.UDPAddr{IP: net.IPv6loopback, Port: 9999, Zone: lp.Name},\n\t\t\t\teth0Addr:        &net.UDPAddr{IP: ip, Port: 9999, Zone: dev},\n\t\t\t\tbroadcastAddr:   &net.UDPAddr{IP: net.IPv6linklocalallnodes, Port: 9999, Zone: dev},\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\terr = Run(ts, \"udp6://[::]:9999\",\n\t\t\t\tWithTicker(true),\n\t\t\t\tWithBindToDevice(dev))\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t})\n}\n\n/*\nfunc TestEngineAsyncWrite(t *testing.T) {\n\tt.Run(\"tcp\", func(t *testing.T) {\n\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\ttestEngineAsyncWrite(t, \"tcp\", \":18888\", false, false, 10, LeastConnections)\n\t\t})\n\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\ttestEngineAsyncWrite(t, \"tcp\", \":28888\", true, true, 10, RoundRobin)\n\t\t})\n\t})\n\tt.Run(\"unix\", func(t *testing.T) {\n\t\tt.Run(\"1-loop\", func(t *testing.T) {\n\t\t\ttestEngineAsyncWrite(t, \"unix\", \":18888\", false, false, 10, LeastConnections)\n\t\t})\n\t\tt.Run(\"N-loop\", func(t *testing.T) {\n\t\t\ttestEngineAsyncWrite(t, \"unix\", \":28888\", true, true, 10, RoundRobin)\n\t\t})\n\t})\n}\n\ntype testEngineAsyncWriteServer struct {\n\t*BuiltinEventEngine\n\ttester       *testing.T\n\teng          Engine\n\tnetwork      string\n\taddr         string\n\tmulticore    bool\n\twritev       bool\n\tnclients     int\n\tstarted      int32\n\tconnected    int32\n\tclientActive int32\n\tdisconnected int32\n\tworkerPool   *goPool.Pool\n}\n\nfunc (s *testEngineAsyncWriteServer) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\treturn\n}\n\nfunc (s *testEngineAsyncWriteServer) OnOpen(c Conn) (out []byte, action Action) {\n\tc.SetContext(c)\n\tatomic.AddInt32(&s.connected, 1)\n\tout = []byte(\"sweetness\\r\\n\")\n\trequire.NotNil(s.tester, c.LocalAddr(), \"nil local addr\")\n\trequire.NotNil(s.tester, c.RemoteAddr(), \"nil remote addr\")\n\treturn\n}\n\nfunc (s *testEngineAsyncWriteServer) OnClose(c Conn, err error) (action Action) {\n\tif err != nil {\n\t\tlogging.Debugf(\"error occurred on closed, %v\\n\", err)\n\t}\n\tif s.network != \"udp\" {\n\t\trequire.Equal(s.tester, c.Context(), c, \"invalid context\")\n\t}\n\n\tatomic.AddInt32(&s.disconnected, 1)\n\tif atomic.LoadInt32(&s.connected) == atomic.LoadInt32(&s.disconnected) &&\n\t\tatomic.LoadInt32(&s.disconnected) == int32(s.nclients) {\n\t\taction = Shutdown\n\t\ts.workerPool.Release()\n\t}\n\n\treturn\n}\n\nfunc (s *testEngineAsyncWriteServer) OnTraffic(c Conn) (action Action) {\n\tgFD := c.Gfd()\n\n\tbuf := bbPool.Get()\n\t_, _ = c.WriteTo(buf)\n\n\t// just for test\n\t_ = c.InboundBuffered()\n\t_ = c.OutboundBuffered()\n\t_, _ = c.Discard(1)\n\n\t_ = s.workerPool.Submit(\n\t\tfunc() {\n\t\t\tif s.writev {\n\t\t\t\tmid := buf.Len() / 2\n\t\t\t\tbs := make([][]byte, 2)\n\t\t\t\tbs[0] = buf.B[:mid]\n\t\t\t\tbs[1] = buf.B[mid:]\n\t\t\t\t_ = s.eng.AsyncWritev(gFD, bs, func(c Conn, err error) error {\n\t\t\t\t\tif c.RemoteAddr() != nil {\n\t\t\t\t\t\tlogging.Debugf(\"conn=%s done writev: %v\", c.RemoteAddr().String(), err)\n\t\t\t\t\t}\n\t\t\t\t\tbbPool.Put(buf)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t_ = s.eng.AsyncWrite(gFD, buf.Bytes(), func(c Conn, err error) error {\n\t\t\t\t\tif c.RemoteAddr() != nil {\n\t\t\t\t\t\tlogging.Debugf(\"conn=%s done write: %v\", c.RemoteAddr().String(), err)\n\t\t\t\t\t}\n\t\t\t\t\tbbPool.Put(buf)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\treturn\n}\n\nfunc (s *testEngineAsyncWriteServer) OnTick() (delay time.Duration, action Action) {\n\tdelay = time.Second / 5\n\tif atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tfor i := 0; i < s.nclients; i++ {\n\t\t\tatomic.AddInt32(&s.clientActive, 1)\n\t\t\tgo func() {\n\t\t\t\tinitClient(s.tester, s.network, s.addr, s.multicore)\n\t\t\t\tatomic.AddInt32(&s.clientActive, -1)\n\t\t\t}()\n\t\t}\n\t}\n\tif s.network == \"udp\" && atomic.LoadInt32(&s.clientActive) == 0 {\n\t\taction = Shutdown\n\t\treturn\n\t}\n\treturn\n}\n\nfunc testEngineAsyncWrite(t *testing.T, network, addr string, multicore, writev bool, nclients int, lb LoadBalancing) {\n\tts := &testEngineAsyncWriteServer{\n\t\ttester:     t,\n\t\tnetwork:    network,\n\t\taddr:       addr,\n\t\tmulticore:  multicore,\n\t\twritev:     writev,\n\t\tnclients:   nclients,\n\t\tworkerPool: goPool.Default(),\n\t}\n\terr := Run(ts,\n\t\tnetwork+\"://\"+addr,\n\t\tWithMulticore(multicore),\n\t\tWithTicker(true),\n\t\tWithLoadBalancing(lb))\n\tassert.NoError(t, err)\n}\n\nfunc initClient(t *testing.T, network, addr string, multicore bool) {\n\trand.Seed(time.Now().UnixNano())\n\tc, err := net.Dial(network, addr)\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\trd := bufio.NewReader(c)\n\tmsg, err := rd.ReadBytes('\\n')\n\trequire.NoError(t, err)\n\trequire.Equal(t, string(msg), \"sweetness\\r\\n\", \"bad header\")\n\tduration := time.Duration((rand.Float64()*2+1)*float64(time.Second)) / 2\n\tt.Logf(\"test duration: %dms\", duration/time.Millisecond)\n\tstart := time.Now()\n\tfor time.Since(start) < duration {\n\t\treqData := make([]byte, streamLen)\n\t\t_, err = rand.Read(reqData)\n\t\trequire.NoError(t, err)\n\t\t_, err = c.Write(reqData)\n\t\trequire.NoError(t, err)\n\t\trespData := make([]byte, len(reqData))\n\t\t_, err = io.ReadFull(rd, respData)\n\t\trequire.NoError(t, err)\n\t\trequire.Equalf(\n\t\t\tt,\n\t\t\tlen(reqData),\n\t\t\tlen(respData),\n\t\t\t\"response mismatch with protocol:%s, multi-core:%t, length of bytes: %d vs %d\",\n\t\t\tnetwork,\n\t\t\tmulticore,\n\t\t\tlen(reqData),\n\t\t\tlen(respData),\n\t\t)\n\t}\n}\n\nfunc TestEngineWakeConn(t *testing.T) {\n\ttestEngineWakeConn(t, \"tcp\", \":9990\")\n}\n\ntype testEngineWakeConnServer struct {\n\t*BuiltinEventEngine\n\ttester  *testing.T\n\teng     Engine\n\tnetwork string\n\taddr    string\n\tgFD     chan gfd.GFD\n\twake    bool\n}\n\nfunc (t *testEngineWakeConnServer) OnBoot(eng Engine) (action Action) {\n\tt.eng = eng\n\treturn\n}\n\nfunc (t *testEngineWakeConnServer) OnOpen(c Conn) (out []byte, action Action) {\n\tt.gFD <- c.Gfd()\n\treturn\n}\n\nfunc (t *testEngineWakeConnServer) OnClose(Conn, error) (action Action) {\n\taction = Shutdown\n\treturn\n}\n\nfunc (t *testEngineWakeConnServer) OnTraffic(c Conn) (action Action) {\n\t_, _ = c.Write([]byte(\"Waking up.\"))\n\taction = -1\n\treturn\n}\n\nfunc (t *testEngineWakeConnServer) OnTick() (delay time.Duration, action Action) {\n\tif !t.wake {\n\t\tt.wake = true\n\t\tdelay = time.Millisecond * 100\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(t.network, t.addr)\n\t\t\trequire.NoError(t.tester, err)\n\t\t\tdefer conn.Close()\n\t\t\tr := make([]byte, 10)\n\t\t\t_, err = conn.Read(r)\n\t\t\trequire.NoError(t.tester, err)\n\t\t}()\n\t\treturn\n\t}\n\tgFD := <-t.gFD\n\t_ = t.eng.Wake(gFD, func(c Conn, err error) error {\n\t\tlogging.Debugf(\"conn=%s done wake: %v\", c.RemoteAddr().String(), err)\n\t\treturn nil\n\t})\n\tdelay = time.Millisecond * 100\n\treturn\n}\n\nfunc testEngineWakeConn(t *testing.T, network, addr string) {\n\tsvr := &testEngineWakeConnServer{tester: t, network: network, addr: addr, gFD: make(chan gfd.GFD, 1)}\n\tlogger := zap.NewExample()\n\terr := Run(svr, network+\"://\"+addr,\n\t\tWithTicker(true),\n\t\tWithNumEventLoop(2*runtime.NumCPU()),\n\t\tWithLogger(logger.Sugar()),\n\t\tWithSocketRecvBuffer(4*1024),\n\t\tWithSocketSendBuffer(4*1024),\n\t\tWithReadBufferCap(2000),\n\t\tWithWriteBufferCap(2000))\n\tassert.NoError(t, err)\n\t_ = logger.Sync()\n}\n\n// Test should not panic when we wake-up server_closed conn.\nfunc TestEngineClosedWakeUp(t *testing.T) {\n\tevents := &testEngineClosedWakeUpServer{\n\t\ttester:             t,\n\t\tBuiltinEventEngine: &BuiltinEventEngine{}, network: \"tcp\", addr: \":9999\", protoAddr: \"tcp://:9999\",\n\t\tclientClosed: make(chan struct{}),\n\t\tserverClosed: make(chan struct{}),\n\t\twakeup:       make(chan struct{}),\n\t}\n\n\terr := Run(events, events.protoAddr)\n\tassert.NoError(t, err)\n}\n\ntype testEngineClosedWakeUpServer struct {\n\t*BuiltinEventEngine\n\ttester                   *testing.T\n\tnetwork, addr, protoAddr string\n\n\teng Engine\n\n\twakeup       chan struct{}\n\tserverClosed chan struct{}\n\tclientClosed chan struct{}\n}\n\nfunc (s *testEngineClosedWakeUpServer) OnBoot(eng Engine) (action Action) {\n\ts.eng = eng\n\tgo func() {\n\t\tc, err := net.Dial(s.network, s.addr)\n\t\trequire.NoError(s.tester, err)\n\n\t\t_, err = c.Write([]byte(\"hello\"))\n\t\trequire.NoError(s.tester, err)\n\n\t\t<-s.wakeup\n\t\t_, err = c.Write([]byte(\"hello again\"))\n\t\trequire.NoError(s.tester, err)\n\n\t\tclose(s.clientClosed)\n\t\t<-s.serverClosed\n\n\t\tlogging.Debugf(\"stop engine...\", Stop(context.TODO(), s.protoAddr))\n\t}()\n\n\treturn None\n}\n\nfunc (s *testEngineClosedWakeUpServer) OnTraffic(c Conn) Action {\n\tassert.NotNil(s.tester, c.RemoteAddr())\n\n\tselect {\n\tcase <-s.wakeup:\n\tdefault:\n\t\tclose(s.wakeup)\n\t}\n\n\tfd := c.Gfd()\n\n\tgo func() { require.NoError(s.tester, c.Wake(nil)) }()\n\tgo s.eng.Close(fd, nil)\n\n\t<-s.clientClosed\n\n\t_, _ = c.Write([]byte(\"answer\"))\n\treturn None\n}\n\nfunc (s *testEngineClosedWakeUpServer) OnClose(Conn, error) (action Action) {\n\tselect {\n\tcase <-s.serverClosed:\n\tdefault:\n\t\tclose(s.serverClosed)\n\t}\n\treturn\n}\n*/\n"
        },
        {
          "name": "os_windows_test.go",
          "type": "blob",
          "size": 0.404296875,
          "content": "//go:build windows\n\npackage gnet\n\nimport (\n\t\"net\"\n\t\"syscall\"\n)\n\nfunc SysClose(fd int) error {\n\treturn syscall.CloseHandle(syscall.Handle(fd))\n}\n\nfunc stdDial(network, addr string) (net.Conn, error) {\n\tif network == \"unix\" {\n\t\tladdr, _ := net.ResolveUnixAddr(network, unixAddr(addr))\n\t\traddr, _ := net.ResolveUnixAddr(network, addr)\n\t\treturn net.DialUnix(network, laddr, raddr)\n\t}\n\treturn net.Dial(network, addr)\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "reactor_default.go",
          "type": "blob",
          "size": 3.740234375,
          "content": "// Copyright (c) 2019 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build (darwin || dragonfly || freebsd || linux || netbsd || openbsd) && !poll_opt\n\npackage gnet\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n\t\"github.com/panjf2000/gnet/v2/pkg/netpoll\"\n)\n\nfunc (el *eventloop) rotate() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling(el.accept0)\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"main reactor is exiting in terms of the demand from user, %v\", err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"main reactor is exiting due to error: %v\", err)\n\t}\n\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n\nfunc (el *eventloop) orbit() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling(func(fd int, ev netpoll.IOEvent, flags netpoll.IOFlags) error {\n\t\tc := el.connections.getConn(fd)\n\t\tif c == nil {\n\t\t\t// For kqueue, this might happen when the connection has already been closed,\n\t\t\t// the file descriptor will be deleted from kqueue automatically as documented\n\t\t\t// in the manual pages.\n\t\t\t// For epoll, it somehow notified with an event for a stale fd that is not in\n\t\t\t// our connection set. We need to explicitly delete it from the epoll set.\n\t\t\t// Also print a warning log for this kind of irregularity.\n\t\t\tel.getLogger().Warnf(\"received event[fd=%d|ev=%d|flags=%d] of a stale connection from event-loop(%d)\", fd, ev, flags, el.idx)\n\t\t\treturn el.poller.Delete(fd)\n\t\t}\n\t\treturn c.processIO(fd, ev, flags)\n\t})\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"event-loop(%d) is exiting in terms of the demand from user, %v\", el.idx, err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"event-loop(%d) is exiting due to error: %v\", el.idx, err)\n\t}\n\n\tel.closeConns()\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n\nfunc (el *eventloop) run() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling(func(fd int, ev netpoll.IOEvent, flags netpoll.IOFlags) error {\n\t\tc := el.connections.getConn(fd)\n\t\tif c == nil {\n\t\t\tif _, ok := el.listeners[fd]; ok {\n\t\t\t\treturn el.accept(fd, ev, flags)\n\t\t\t}\n\t\t\t// For kqueue, this might happen when the connection has already been closed,\n\t\t\t// the file descriptor will be deleted from kqueue automatically as documented\n\t\t\t// in the manual pages.\n\t\t\t// For epoll, it somehow notified with an event for a stale fd that is not in\n\t\t\t// our connection set. We need to explicitly delete it from the epoll set.\n\t\t\t// Also print a warning log for this kind of irregularity.\n\t\t\tel.getLogger().Warnf(\"received event[fd=%d|ev=%d|flags=%d] of a stale connection from event-loop(%d)\", fd, ev, flags, el.idx)\n\t\t\treturn el.poller.Delete(fd)\n\t\t}\n\t\treturn c.processIO(fd, ev, flags)\n\t})\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"event-loop(%d) is exiting in terms of the demand from user, %v\", el.idx, err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"event-loop(%d) is exiting due to error: %v\", el.idx, err)\n\t}\n\n\tel.closeConns()\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n"
        },
        {
          "name": "reactor_ultimate.go",
          "type": "blob",
          "size": 2.189453125,
          "content": "// Copyright (c) 2021 The Gnet Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build (darwin || dragonfly || freebsd || linux || netbsd || openbsd) && poll_opt\n\npackage gnet\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\n\terrorx \"github.com/panjf2000/gnet/v2/pkg/errors\"\n)\n\nfunc (el *eventloop) rotate() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling()\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"main reactor is exiting in terms of the demand from user, %v\", err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"main reactor is exiting due to error: %v\", err)\n\t}\n\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n\nfunc (el *eventloop) orbit() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling()\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"event-loop(%d) is exiting in terms of the demand from user, %v\", el.idx, err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"event-loop(%d) is exiting due to error: %v\", el.idx, err)\n\t}\n\n\tel.closeConns()\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n\nfunc (el *eventloop) run() error {\n\tif el.engine.opts.LockOSThread {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\terr := el.poller.Polling()\n\tif errors.Is(err, errorx.ErrEngineShutdown) {\n\t\tel.getLogger().Debugf(\"event-loop(%d) is exiting in terms of the demand from user, %v\", el.idx, err)\n\t\terr = nil\n\t} else if err != nil {\n\t\tel.getLogger().Errorf(\"event-loop(%d) is exiting due to error: %v\", el.idx, err)\n\t}\n\n\tel.closeConns()\n\tel.engine.shutdown(err)\n\n\treturn err\n}\n"
        }
      ]
    }
  ]
}