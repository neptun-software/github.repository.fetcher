{
  "metadata": {
    "timestamp": 1736567736371,
    "page": 322,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "elastic/go-elasticsearch",
      "stars": 5733,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".buildkite",
          "type": "tree",
          "content": null
        },
        {
          "name": ".ci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.0771484375,
          "content": "comment: off\n\ncoverage:\n  status:\n    patch: off\n\nignore:\n  - \"esapi/api.*.go\"\n"
        },
        {
          "name": ".doc",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": ".git/\ntmp/\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "tmp/\n*.test\n\n#jetBrains editors\n.idea\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 21.82421875,
          "content": "# 8.17.0\n\n* Expose BulkIndexer total flushed bytes metric [#914](https://github.com/elastic/go-elasticsearch/pull/914) thanks to @aureleoules\n\n# API\n\nUpdated APIs to 8.17.0\n\n# Typed API\n\nUpdate APIs to latest [elasticsearch-specification 8.17](https://github.com/elastic/elasticsearch-specification/tree/2f823ff6fcaa7f3f0f9b990dc90512d8901e5d64)\n\n# 8.16.0\n\n# API\n\n* `InferenceStreamInference` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/stream-inference-api.html)\n* `QueryRulesTest` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/test-query-ruleset.html)\n* `Ingest.DeleteIPLocationDatabase` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-ip-location-database-api.html)\n* `Ingest.GetIPLocationDatabase` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/get-ip-location-database-api.html)\n* `Ingest.PutIPLocationDatabase` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/put-ip-location-database-api.html)\n\n# Typed API\n\nUpdate APIs to latest [elasticsearch-specification 8.16](https://github.com/elastic/elasticsearch-specification/tree/4fcf747dfafc951e1dcf3077327e3dcee9107db3)\n\n# 8.15.0\n\n# API\n\n* API is generated from the Elasticsearch 8.15.0 specification. \n\n# Typed API\n\nUpdate APIs to latest [elasticsearch-specification 8.15](https://github.com/elastic/elasticsearch-specification/tree/19027dbdd366978ccae41842a040a636730e7c10)\n\n# 8.14.0\n\n# API\n\nNew APIs:\n\n * ConnectorUpdateActiveFiltering [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/update-connector-filtering-api.html)\n * ConnectorUpdateFilteringValidation [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/update-connector-filtering-api.html)\n * TextStructureFindFieldStructure [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/find-field-structure.html)\n * TextStructureFindMessageStructure [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/find-message-structure.html)\n\n# Typed API\n\nNew APIs:\n\n * UpdateTrainedModelDeployment [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/update-trained-model-deployment.html)\n\n# Transport\n * Fixed a deadlock in the connection pool https://github.com/elastic/elastic-transport-go/issues/20\n\n# 8.13.1\n\n# Typed API\n\nUpdate APIs to latest [elasticsearch-specification 8.13](https://github.com/elastic/elasticsearch-specification/tree/5fb8f1ce9c4605abcaa44aa0f17dbfc60497a757)\n\n## Fixes\n\nThis patch release brings a fix to the initialisation of the `Request` in endpoints which would prevent using the shortcuts for fields. \nCanonical`.Request()` method was unaffected.\n\n* `Autoscaling.PutAutoscalingPolicy`\n* `Indices.Downsample`\n* `Indices.PutSettings`\n* `Indices.SimulateTemplate`\n* `Inference.PutModel`\n* `Logstash.PutPipeline`\n* `Ml.ValidateDetector`\n* `SearchApplication.Put`\n\n# 8.13.0\n\n# API \n\nNew APIS:\n\n* `ConnectorSecretGet`\n* `ConnectorSecretPost`\n* `ConnectorSecretPut`\n* `ConnectorSecretDelete`\n* `ConnectorUpdateIndexName`\n* `ConnectorUpdateNative`\n* `ConnectorUpdateStatus`\n* `ConnectorUpdateAPIKeyDocumentID`\n* `ConnectorUpdateServiceDocumentType`\n\n\n* `EsqlAsyncQuery` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/esql-async-query-api.html)\n* `EsqlAsyncQueryGet` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/esql-async-query-get-api.html)\n* `ProfilingFlamegraph` [Documentation](https://www.elastic.co/guide/en/observability/current/universal-profiling.html)\n* `ProfilingStacktraces` [Documentation](https://www.elastic.co/guide/en/observability/current/universal-profiling.html)\n* `TextStructureTestGrokPattern` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/test-grok-pattern.html)\n* `Indices.ResolveCluster` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-resolve-cluster-api.html)\n* `Security.QueryUser` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-query-user.html)\n\n# Typed API\n\n* `indices.ResolveCluster` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-resolve-cluster-api.html)\n* `textstructure.TestGrokPattern` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/test-grok-pattern.html)\n\nThanks to @pakio, transport now has an optional pool based compression option. [link](https://github.com/elastic/elastic-transport-go/pull/19)\n\nAnd to @tblyler for fixing a very subtle memory leak in the `BulkIndexer`. #797\n\n# 8.12.1\n\n* Fix: ticker memory leak in bulk indexer due to internal flush call resetting the ticker. #797\n* Fix: Scroll now uses the body to pass the scroll_id. #785\n* Add: generated UnmarshalJSON for Requests to allow injecting payloads using aliases.\n* Fix: `put_synonym_rule` was not working due to a type issue in the [Elasticsearch API Specification](https://github.com/elastic/elasticsearch-specification/pull/2407).\n\n# 8.12.0\n\n## Client\n\n### Golang version\n\nThe client now requires Golang version 1.20\n\n### OpenTelemetry\n\nThe client now provides OpenTelemetry integration. This integration can be enabled in the config using the `elasticsearch.NewOpenTelemetryInstrumentation`.\nOnce set up, the provided `context` will be used to record spans with useful information about the request being made to the server.\n\nMore about what you can expect in the [Semantic Conventions for Elasticsearch](https://opentelemetry.io/docs/specs/semconv/database/elasticsearch/).\n\n### BulkIndexer\n\n`if_seq_no` & `if_primary_term` are now supported thanks to @benjyiw [#783](https://github.com/elastic/go-elasticsearch/pull/783)\n\n## API\n\n* `SimulateIngest`\n* `ConnectorCheckIn`\n* `ConnectorDelete`\n* `ConnectorGet`\n* `ConnectorLastSync`\n* `ConnectorList`\n* `ConnectorPost`\n* `ConnectorPut`\n* `ConnectorSyncJobCancel`\n* `ConnectorSyncJobCheckIn`\n* `ConnectorSyncJobDelete`\n* `ConnectorSyncJobError`\n* `ConnectorSyncJobGet`\n* `ConnectorSyncJobList`\n* `ConnectorSyncJobPost`\n* `ConnectorSyncJobUpdateStats`\n* `ConnectorUpdateConfiguration`\n* `ConnectorUpdateError`\n* `ConnectorUpdateFiltering`\n* `ConnectorUpdateName`\n* `ConnectorUpdatePipeline`\n* `ConnectorUpdateScheduling`\n\n## Typed API\n\n* `Esql.Query` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql-rest.html)\n* `Fleet.PostSecret`\n* `Inference` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/inference-apis.html)\n  * `DeleteModel` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-inference-api.html)\n  * `GetModel` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/get-inference-api.html)\n  * `Inference` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/post-inference-api.html)\n  * `PutModel` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/put-inference-api.html)\n* `SearchApplication`\n  * `GetSettings` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-settings.html)\n  * `UpdateSettings` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-settings.html)\n\n# 8.11.1\n\n## Typed API\n\n* Fix https://github.com/elastic/go-elasticsearch/issues/756 preventing from settings indices in `indices.PutSettings`\n\n# 8.11.0\n\n## API\n\n**Experimental APIs**\n\n* `EsqlQuery`            [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql-query-api.html)\n* `InferenceDeleteModel` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-inference-api.html)\n* `InferenceGetModel`    [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/get-inference-api.html)\n* `InferenceInference`   [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/post-inference-api.html)\n* `InferencePutModel`    [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/put-inference-api.html)\n\n## Typed API\n\n* Mandatory URL parameters are not exposed as functions anymore as they already exist in the constructor.\n\n# New Compatibility Policy\n\nStarting from version `8.12.0`, this library follow the Go language [policy](https://go.dev/doc/devel/release#policy). Each major Go release is supported until there are two newer major releases. For example, Go 1.5 was supported until the Go 1.7 release, and Go 1.6 was supported until the Go 1.8 release.\n\nIf you have any questions or concerns, please do not hesitate to reach out to us.\n\n# 8.10.1\n\n## Typed API\n\nUpdate APIs to latest [elasticsearch-specification 8.10](https://github.com/elastic/elasticsearch-specification/commit/3b09f9d8e90178243f8a340a7bc324aab152c602)\n\n# 8.10.0\n\n## API\n**Experimental APIs for internal use**\n* `FleetDeleteSecret`\n* `FleetGetSecret`\n* `FleetPostSecret`\n\n**Exprimental APIs**\n\n`QueryRulesetList`\n\n**Stable APIs**\n\n`Security.GetSettings`\n`Security.UpdateSettings`\n\n## Typed API\n**Exprimental APIs**\n\n`QueryRuleset.List`\n\n**Technical Preview**\n* [QueryRuleSet](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-rules-apis.html)\n\n**Beta**\n* [Synonyms](https://www.elastic.co/guide/en/elasticsearch/reference/current/synonyms-apis.html)\n\n# 8.9.0\n\n## API\n**New API**\n\n* `Cluster.Info` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-info.html)\n\n**Experimental APIs**\n\n* `QueryRulesetGet` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/get-query-ruleset.html)\n* `QueryRulesetDelete` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-query-ruleset.html)\n* `QueryRulesetPut` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/put-query-ruleset.html)\n* `SearchApplicationRenderQuery` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/search-application-render-query.html)\n* `Security.CreateCrossClusterAPIKey` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-cross-cluster-api-key.html)\n* `Security.UpdateCrossClusterAPIKey` [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-cross-cluster-api-key.html)\n\n## Typed API\n\n* Propagated request fields towards the endpoint for ease of access, taking priority over same-name query string fields.\n* Added a stub for Do methods on endpoints that only support a boolean response such as `core.exists`. \n* NDJSON endpoints support with custom serialization like `core.bulk`.\n* Link to endpoints documentation in API index to better display and ease of use.\n\n**fixes**\n\n* Fixed a deserialization issue for `Property` & `Analyzer` #696\n\n# 8.8.2\n\n## Typed API\n\n* Fixed deserialization for `Suggest` in search responses.\n* Fixed double-quoted strings in deserialization for unions normalized as string. #684\n* Fixed handling of `core.Get` response when the index did not exist. #678\n\n# 8.7.0\n\n## API\n\n* `ML.DeleteJob`: Added `WithDeleteUserAnnotations`. Should annotations added by the user be deleted.\n* `ML.ResetJob`: Added `WithDeleteUserAnnotations`. Should annotations added by the user be deleted.\n* `ML.StartTrainedModelDeployment`: Added `WithPriority`. The deployment priority.\n* `TransformGetTransformStats`: Added `WithTimeout`. Controls the time to wait for the stats.\n* `TransformStartTransform`: Added `WithFrom`. Restricts the set of transformed entities to those changed after this time.\n\n**New APIs**\n\n`TransformScheduleNowTransform` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/8.7/schedule-now-transform.html).\n`HealthReport` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/8.7/health-api.html).\n\n## Typed API\n\n* Inclusion of responses structures.\n\n**Changes**\n\n* `Do` method on endpoints now return a typed response, one per endpoint.\n* `Perform` method added on endpoints, returns `http.Response` as did `Do`.\n* Elasticsearch exceptions are now handled as `types.ElasticsearchError` with `.As` and `.Is` methods.\n* `.Raw` now takes a reader as input.\n* User defined values such as `_source` in `Hits` are now `json.RawMessage` to highlight they later deserializable nature.  \n\n# 8.6.0\n\n## API\n\n* `ML.StartTrainedModelDeployment`: Added `WithPriority`\n\n**New APIs**\n* `ML.UpdateTrainedModelDeployment`: Updates certain properties of trained model deployment.\n\n\n## Client\n**BulkIndexer**\n\nImprovements were made to the BulkIndexer memory usage to allow better handling under burst use cases. Thanks to @christos68k and @rockdaboot !\n\n# 8.5.0\n\n## API\n\n* `ML.StartTrainedModelDeployment`: Description of `NumberOfAllocations` has been changed in \"The total number of allocations this model is assigned across machine learning nodes\".\n* `Security.GetAPIKey`: Added `WithLimitedBy` boolean parameter. Flag to show the limited-by role descriptors of API Keys.\n* `Security.GetUser`: Added `WithProfileUID` boolean parameter. Flag to retrieve profile uid (if exists) associated to the user.\n* `Security.GetUserProfile`: Changed the description of uid parameter, a comma-separated list of unique identifier for user profiles.\n* `Security.QueryAPIKeys`: Added `WithLimitedBy` boolean parameter. Flag to show the limited-by role descriptors of API Keys.\n* `TextStructureFindStructure`: Added `EcsCompatibility` string parameter. Optional parameter to specify the compatibility mode with ECS Grok patterns - may be either 'v1' or 'disabled'.\n\n**Promoted to stable**\n\n* `ML.InferTrainedModel`\n* `ML.PutTrainedModelDefinitionPart`\n* `ML.PutTrainedModelVocabulary`\n* `ML.StartTrainedModelDeployment`\n* `ML.StopTrainedModelDeployment`\n* `Security.activateUserProfile`\n* `Security.DisableUserProfile`\n* `Security.EnableUserProfile`\n* `Security.GetUserProfile`\n* `Security.HasPrivilegesUserProfile`\n* `Security.SuggestUserProfiles`\n* `Security.UpdateUserProfileData`\n\n**New APIs**\n\n* `ML.ClearTrainedModelDeploymentCache` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-trained-model-deployment-cache.html).\n* `Security.BulkUpdateAPIKeys` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-bulk-update-api-keys.html).\n* `Indices.Downsample` (Experimental API) [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-rollup.html)\n\n## Typed API\n\nFollowing multiple feedbacks we decided to remove the builder API for the type tree.\n\nIn its place, work has started to further simplify the type tree by removing redundant type aliases. The API also now comes with a helper package named `some` that allows to call for inline pointers on primitive types.\n\nIn addition, a bug was fixed preventing the use of wildcards in index names, and enums are now extensible by default.\n\nThe Typed API remains in `alpha` stage while its development continues.\n\n# 8.4.0\n\n## API\n\n* `get`, `mget` and `search` added `force_synthetic_source`: Should this request force synthetic _source? Use this to test if the mapping supports synthetic _source and to get a sense of the worst case performance. Fetches with this enabled will be slower the enabling synthetic source natively in the index.\n* `ML.StartTrainedModelDeployment` added `cache_size`: A byte-size value for configuring the inference cache size. For example, 20mb.\n* `Snapshot.Get` added `sort`, `size`, `order`, `from_sort_value`, `after`, `offset` and `slm_policy_filter`. More on these in the [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/8.4/get-snapshot-api.html).\n\n**New API**\n\n* `Security.UpdateAPIKey` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/8.4/security-api-update-api-key.html).\n\n## Typed API\n\nAs highlighted in the release not for the 8.4.0-alpha.1, this release marks the beginning of the newly arrived `TypedClient`.\n\nThis new API is still in `alpha` stage and will be release alongside the existing `esapi`.\n\nA few examples of standard use-cases can be found in the [TypedAPI section of the documentation](https://www.elastic.co/guide/en/elasticsearch/client/go-api/master/typedapi.html).\n\n# 8.4.0-alpha.2\n\nThis second prerelease of the 8.4.0 updates the API for the client and fixes the serialization for types using [additional properties](https://github.com/elastic/elasticsearch-specification/blob/main/docs/behaviors.md#additionalproperties--additionalproperty).\n\n# 8.4.0-alpha.1\n\nThis prerelease introduces a new typed API generated from the [elasticsearch-specification](https://github.com/elastic/elasticsearch-specification). This generation from the common specification allows us to provide a complete API which uses an exhaustive hierarchy of types  reflecting the possibilities given by Elasticsearch.\n\nThis new API is the next iteration of the Go client for Elasticsearch, it now lives alongside the existing API, it is in `alpha` state and will gain features over time and releases.\n\n## What's new\n\nThe `TypedClient` is built around a fluent builder for easier request creation and a collection of structures and helpers that mimics as closely as possible the Elasticsearch JSON API.\n\nAs a first example, here is a search request:\n```go\ncfg := elasticsearch.Config{\n// Define your configuration\n}\nes, _ := elasticsearch.NewTypedClient(cfg)\nres, err := es.Search().\nIndex(\"index_name\").\nRequest(&search.Request{\nQuery: &types.QueryContainer{\nMatch: map[types.Field]types.MatchQuery{\n\"name\": {Query: \"Foo\"},\n},\n},\n},\n).Do(context.Background())\n```\n\nThe `Request` uses the structures found in the `typedapi/types` package which will lead you along the possibilities. A builder for each structure that allows easier access and declaration is also provided.\n\nMore on the specifics and a few examples of standard use-cases can be found in the [TypedAPI section of the documentation](https://www.elastic.co/guide/en/elasticsearch/client/go-api/master/typedapi.html).\n\n## Limitations\n\nWhile most of the endpoints are covered, a few points are still being worked on and will be part of future releases:\n\n* NDJSON endpoints: `bulk`, `msearch`, `msearch_template`, `ML.post_data`, `find_structure`, to name a few.\n* Response and Errors structures with deserialization.\n\n## Transport & config\n\nWhile being different, the new API uses all the existing layers that were built so far, `elastic-transport-go` remains the preferred transport and all your configuration and credentials applies, same as before.\n\n## Feedback\n\nFeedback is very welcome, play with it, use it, let us know what you think!\n\n# 8.3.0\n\n## API\n\n* `ML.InferTrainedModelDeployment` renamed to `InferTrainedModel`\n* `ML.PreviewDatafeed` has two new parameters, `start` and `end`. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/8.3/ml-preview-datafeed.html)\n* `ML.StartTrainedModelDeployment` has three new parameters, `number_of_allocations`, `threads_per_allocation` and `queue_capacity`. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/start-trained-model-deployment.html)\n* `Cluster.DeleteVotingConfigExclusions` has a new `master_timeout` parameter.\n* `Cluster.PostVotingConfigExclusions` has a new `master_timeout` parameter.\n* `Snapshot.Get` has a new `index_names` parameters (boolean). Whether to include the name of each index in the snapshot. Defaults to true.\n\n**New APIs**\n\n* `Security.HasPrivilegesUserProfile` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges-user-profile.html)\n\n# 8.2.0\n## Client\n\n* Fixed a serialisation error for `retry_on_conflict` in the BulkIndexer. Thanks to @lpflpf for the help!\n* Fixed a concurrent map error in the BulkIndexer when custom headers are applied. Thanks to @chzhuo for the contribution!\n\n## API\n\n**New APIs**\n\n* `Cat.ComponentTemplates`\n* `ML.GetMemoryStats` [documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/get-ml-memory.html)\n\n* `Security.activateUserProfile` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-activate-user-profile.html)\n* `Security.disableUserProfile` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-disable-user-profile.html)\n* `Security.enableUserProfile` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-enable-user-profile.html)\n* `Security.getUserProfile` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-profile.html)\n* `Security.suggestUserProfiles` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-suggest-user-profile.html)\n* `Security.updateUserProfileData` (Experimental API) [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-user-profile-data.html)\n\n# 8.1.0\n## API\n\n* API is generated from the Elasticsearch 8.1.0 specification.\n\n**New parameters**\n\n* `WithWaitForCompletion` for `Indices.Forcemerge`\n* `WithFeatures` for `Indices.Get`\n* `WithForce` for `ML.DeleteTrainedModel`\n\n**New APIs**\n\n* `OidcAuthenticate`, `OidcLogout` and `OidcPrepareAuthentication` [see documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api.html#security-openid-apis)\n* `TransformResetTransform`\n\n# 8.0.0\n## Client\n\n* The client now uses `elastic-transport-go` dependency which lives in its [own repository](https://github.com/elastic/elastic-transport-go/).\n* With the knewly extracted transport, the `retryOnTimeout` has been replaced with a `retryOnError` callback. This allows to select more finely which error should be retried by the client.\n* `BulkIndexerItem` `Body` field is now an `io.ReadSeeker` allowing reread without increasing memory consumption.\n* `BulkIndexerItem` know correctly uses the `routing` property instead of the deprecated `_routing`.\n\n## API\n\n* API is generated from the Elasticsearch 8.0.0 specification.\n\n\n\n\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.0693359375,
          "content": "303 See Other\n\nLocation: https://www.elastic.co/community/codeofconduct"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.21484375,
          "content": "# Contributing\n\nThe Elasticsearch Go client is open source and we love to receive contributions from our community.\n\nThere are many ways to contribute, from writing tutorials or blog posts, improving the documentation, submitting bug reports and feature requests or writing code.\n\n## Sign the Contributor License Agreement\n\nWe do ask that you sign the [Contiributor License Agreement](https://www.elastic.co/contributor-agreement)\nbefore we can accept pull requests from you.\n\n## Development\n\n### Prerequisites\n\nYou need at least Go 1.21 to build the project.\n\nDocker is used for some tests to spawn an Elasticsearch server.\n\n### Project structure\n\nThe code for each API lives in individual files in the `esapi` subfolder, this code is entirely generated by the subproject located in the `internal/build` folder.\n\n\n\n### Before you open a PR\n\nPlease run the tests locally with `make test` and make sure everything is in order.\n\nIf your changes address the generator, you can run the integration with the following command:\n\n`TEST_SUITE=free STACK_VERSION=8.0.0-SNAPSHOT WORKSPACE=/tmp/workspace/$STACK_VERSION .ci/run-tests`\n\nTEST_SUITE can either be `free` or `platinum`, STACK_VERSION reflects the targeted Elasticsearch version of the client."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.080078125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2018 Elasticsearch BV\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 21.3193359375,
          "content": "SHELL := /bin/bash\n\nELASTICSEARCH_DEFAULT_BUILD_VERSION = \"8.16.0-SNAPSHOT\"\n\n##@ Test\ntest-unit:  ## Run unit tests\n\t@printf \"\\033[2m→ Running unit tests...\\033[0m\\n\"\nifdef race\n\t$(eval testunitargs += \"-race\")\nendif\nifeq ($(OS),Windows_NT)\n\t$(eval testunitargs += \"./...\")\nelse\n\t$(eval testunitargs += \"-cover\" \"-coverprofile=tmp/unit.cov\" \"./...\")\nendif\n\t@mkdir -p tmp\n\t@if which gotestsum > /dev/null 2>&1 ; then \\\n\t\techo \"gotestsum --format=short-verbose --junitfile=tmp/unit-report.xml --\" $(testunitargs); \\\n\t\tgotestsum --format=short-verbose --junitfile=tmp/unit-report.xml -- $(testunitargs); \\\n\telse \\\n\t\techo \"go test -v\" $(testunitargs); \\\n\t\tgo test -v $(testunitargs); \\\n\tfi;\ntest: test-unit\n\ntest-integ:  ## Run integration tests\n\t@mkdir -p tmp\n\t@printf \"\\033[2m→ Running integration tests...\\033[0m\\n\"\n\t$(eval testintegtags += \"integration\")\nifdef multinode\n\t$(eval testintegtags += \"multinode\")\nendif\nifdef race\n\t$(eval testintegargs += \"-race\")\nendif\n\t$(eval testintegargs += \"-cover\" \"-coverpkg=github.com/elastic/go-elasticsearch/v8,github.com/elastic/go-elasticsearch/v8/esutil,github.com/elastic/go-elasticsearch/v8/typedapi\" \"-coverprofile=$(PWD)/tmp/integration-client.cov\" \"-tags='$(testintegtags)'\" \"-timeout=1h\")\n\t@if which gotestsum > /dev/null 2>&1 ; then \\\n  \t\tcd internal/testing/e2e; \\\n\t\techo \"gotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-report.xml --\" $(testintegargs); \\\n\t\tgotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-report.xml -- $(testintegargs); \\\n\telse \\\n\t  \tcd internal/testing/e2e; \\\n\t\techo \"go test -v -count=1\" $(testintegargs); \\\n\t\tgo test -v -count=1 $(testintegargs); \\\n\tfi;\n\ntest-api:  ## Run generated API integration tests\n\t@mkdir -p tmp\nifdef race\n\t$(eval testapiargs += \"-race\")\nendif\n\t$(eval testapiargs += \"-cover\" \"-coverpkg=github.com/elastic/go-elasticsearch/v8/esapi\" \"-coverprofile=$(PWD)/tmp/integration-api.cov\" \"-tags='integration'\" \"-timeout=1h\")\nifdef flavor\nelse\n\t$(eval flavor='free')\nendif\n\t@printf \"\\033[2m→ Running API integration tests for [$(flavor)]...\\033[0m\\n\"\nifeq ($(flavor), platinum)\n\t@{ \\\n\t\tset -e ; \\\n\t\ttrap \"test -d .git && git checkout --quiet $(PWD)/esapi/test/go.mod\" INT TERM EXIT; \\\n\t\texport ELASTICSEARCH_URL='https://elastic:elastic@localhost:9200' && \\\n\t\tif which gotestsum > /dev/null 2>&1 ; then \\\n\t\t\tcd esapi/test && \\\n\t\t\tgo mod download && \\\n\t\t\t\tgotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-api-report.xml -- $(testapiargs) $(PWD)/esapi/test/xpack/*_test.go && \\\n\t\t\t\tgotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-api-report.xml -- $(testapiargs) $(PWD)/esapi/test/xpack/ml/*_test.go && \\\n\t\t\t\tgotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-api-report.xml -- $(testapiargs) $(PWD)/esapi/test/xpack/ml-crud/*_test.go; \\\n\t\telse \\\n\t\t\techo \"go test -v\" $(testapiargs); \\\n\t\t\tcd esapi/test && \\\n\t\t\tgo mod download && \\\n\t\t\t\tgo test -v $(testapiargs) $(PWD)/esapi/test/xpack/*_test.go && \\\n\t\t\t\tgo test -v $(testapiargs) $(PWD)/esapi/test/xpack/ml/*_test.go && \\\n\t\t\t\tgo test -v $(testapiargs) $(PWD)/esapi/test/xpack/ml-crud/*_test.go;  \\\n\t\tfi; \\\n\t}\nelse\n\t$(eval testapiargs += $(PWD)/esapi/test/*_test.go)\n\t{ \\\n\t\tset -e ; \\\n\t\ttrap \"test -d .git && git checkout --quiet $(PWD)/esapi/test/go.mod\" INT TERM EXIT; \\\n\t\tif which gotestsum > /dev/null 2>&1 ; then \\\n\t\t\tcd esapi/test && \\\n\t\t\tgo mod download && \\\n\t\t\tgotestsum --format=short-verbose --junitfile=$(PWD)/tmp/integration-api-report.xml -- $(testapiargs); \\\n\t\telse \\\n\t\t\techo \"go test -v\" $(testapiargs); \\\n\t\t\tcd esapi/test && \\\n\t\t\tgo mod download && \\\n\t\t\tgo test -v $(testapiargs); \\\n\t\tfi; \\\n\t}\nendif\n\ntest-bench:  ## Run benchmarks\n\t@printf \"\\033[2m→ Running benchmarks...\\033[0m\\n\"\n\tgo test -run=none -bench=. -benchmem ./...\n\ntest-examples: ## Execute the _examples\n\t@printf \"\\033[2m→ Testing the examples...\\033[0m\\n\"\n\t@{ \\\n\t\tset -e ; \\\n\t\ttrap \"test -d .git && git checkout --quiet _examples/**/go.mod\" INT TERM EXIT; \\\n\t\tfor d in _examples/*/; do \\\n\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\n\"; \\\n\t\t\tprintf \"\\033[1mUpdating dependencies for $$d\\033[0m\\n\"; \\\n\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n\t\t\t(cd $$d && go mod download all && make setup test) || \\\n\t\t\t( \\\n\t\t\t\tprintf \"\\033[31m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n\t\t\t\tprintf \"\\033[31;1m⨯ ERROR\\033[0m\\n\"; \\\n\t\t\t\tfalse; \\\n\t\t\t); \\\n\t    done; \\\n\t    \\\n\t    ( \\\n\t    cd _examples; \\\n\t\tfor f in *.go; do \\\n\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\n\"; \\\n\t\t\tprintf \"\\033[1m$$f\\033[0m\\n\"; \\\n\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n\t\t\t(export ELASTICSEARCH_URL=http://elastic:elastic@localhost:9200 && go run $$f && true) || \\\n\t\t\t( \\\n\t\t\t\tprintf \"\\033[31m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n\t\t\t\tprintf \"\\033[31;1m⨯ ERROR\\033[0m\\n\"; \\\n\t\t\t\tfalse; \\\n\t\t\t); \\\n\t\tdone; \\\n\t\t);\\\n#\t\t\\\n#\t\tfor f in _examples/*/; do \\\n#\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n#\t\t\tprintf \"\\033[1m$$f\\033[0m\\n\"; \\\n#\t\t\tprintf \"\\033[2m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n#\t\t\t(cd $$f && make test && true) || \\\n#\t\t\t( \\\n#\t\t\t\tprintf \"\\033[31m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n#\t\t\t\tprintf \"\\033[31;1m⨯ ERROR\\033[0m\\n\"; \\\n#\t\t\t\tfalse; \\\n#\t\t\t); \\\n#\t\tdone; \\\n\t\tprintf \"\\033[32m────────────────────────────────────────────────────────────────────────────────\\033[0m\\n\"; \\\n\t\t\\\n\t\tprintf \"\\033[32;1mSUCCESS\\033[0m\\n\"; \\\n\t}\n\ntest-coverage:  ## Generate test coverage report\n\t@printf \"\\033[2m→ Generating test coverage report...\\033[0m\\n\"\n\t@go tool cover -html=tmp/unit.cov -o tmp/coverage.html\n\t@go tool cover -func=tmp/unit.cov | 'grep' -v 'esapi/api\\.' | sed 's/github.com\\/elastic\\/go-elasticsearch\\///g'\n\t@printf \"\\033[0m--------------------------------------------------------------------------------\\nopen tmp/coverage.html\\n\\n\\033[0m\"\n\n##@ Development\nlint:  ## Run lint on the package\n\t@printf \"\\033[2m→ Running lint...\\033[0m\\n\"\n\tgo vet github.com/elastic/go-elasticsearch/...\n\t@{ \\\n\t\tset -e ; \\\n\t\ttrap \"test -d ../../../.git && git checkout --quiet go.mod\" INT TERM EXIT; \\\n\t\techo \"cd internal/build/ && go vet ./...\"; \\\n\t\tcd \"internal/build/\" && go mod tidy && go mod download && go vet ./...; \\\n\t}\n\n\napidiff: ## Display API incompabilities\n\t@if ! command -v apidiff > /dev/null; then \\\n\t\tprintf \"\\033[31;1mERROR: apidiff not installed\\033[0m\\n\"; \\\n\t\tprintf \"go get -u github.com/go-modules-by-example/apidiff\\n\"; \\\n\t\tprintf \"\\033[2m→ https://github.com/go-modules-by-example/index/blob/master/019_apidiff/README.md\\033[0m\\n\\n\"; \\\n\t\tfalse; \\\n\tfi;\n\t@rm -rf tmp/apidiff-OLD tmp/apidiff-NEW\n\t@git clone --quiet --local .git/ tmp/apidiff-OLD\n\t@mkdir -p tmp/apidiff-NEW\n\t@tar -c --exclude .git --exclude tmp --exclude cmd . | tar -x -C tmp/apidiff-NEW\n\t@printf \"\\033[2m→ Running apidiff...\\033[0m\\n\"\n\t@pritnf \"tmp/apidiff-OLD/esapi tmp/apidiff-NEW/esapi\\n\"\n\t@{ \\\n\t\tset -e ; \\\n\t\toutput=$$(apidiff tmp/apidiff-OLD/esapi tmp/apidiff-NEW/esapi); \\\n\t\tprintf \"\\n$$output\\n\\n\"; \\\n\t\tif echo $$output | grep -i -e 'incompatible' - > /dev/null 2>&1; then \\\n\t\t\tprintf \"\\n\\033[31;1mFAILURE\\033[0m\\n\\n\"; \\\n\t\t\tfalse; \\\n\t\telse \\\n\t\t\tprintf \"\\033[32;1mSUCCESS\\033[0m\\n\"; \\\n\t\tfi; \\\n\t}\n\nbackport: ## Backport one or more commits from main into version branches\nifeq ($(origin commits), undefined)\n\t@echo \"Missing commit(s), exiting...\"\n\t@exit 2\nendif\nifndef branches\n\t$(eval branches_list = '7.16' '6.x' '5.x')\nelse\n\t$(eval branches_list = $(shell echo $(branches) | tr ',' ' ') )\nendif\n\t$(eval commits_list = $(shell echo $(commits) | tr ',' ' '))\n\t@printf \"\\033[2m→ Backporting commits [$(commits)]\\033[0m\\n\"\n\t@{ \\\n\t\tset -e -o pipefail; \\\n\t\tfor commit in $(commits_list); do \\\n\t\t\tgit show --pretty='%h | %s' --no-patch $$commit; \\\n\t\tdone; \\\n\t\techo \"\"; \\\n\t\tfor branch in $(branches_list); do \\\n\t\t\tprintf \"\\033[2m→ $$branch\\033[0m\\n\"; \\\n\t\t\tgit checkout $$branch; \\\n\t\t\tfor commit in $(commits_list); do \\\n\t\t\t\tgit cherry-pick -x $$commit; \\\n\t\t\tdone; \\\n\t\t\tgit status --short --branch; \\\n\t\t\techo \"\"; \\\n\t\tdone; \\\n\t\tprintf \"\\033[2m→ Push updates to Github:\\033[0m\\n\"; \\\n\t\tfor branch in $(branches_list); do \\\n\t\t\techo \"git push --verbose origin $$branch\"; \\\n\t\tdone; \\\n\t}\n\nrelease: ## Release a new version to Github\n\t$(eval branch = $(shell git rev-parse --abbrev-ref HEAD))\n\t$(eval current_version = $(shell cat internal/version/version.go | sed -Ee 's/const Client = \"(.*)\"/\\1/' | tail -1))\n\t@printf \"\\033[2m→ [$(branch)] Current version: $(current_version)...\\033[0m\\n\"\nifndef version\n\t@printf \"\\033[31m[!] Missing version argument, exiting...\\033[0m\\n\"\n\t@exit 2\nendif\nifeq ($(version), \"\")\n\t@printf \"\\033[31m[!] Empty version argument, exiting...\\033[0m\\n\"\n\t@exit 2\nendif\n\t@printf \"\\033[2m→ [$(branch)] Creating version $(version)...\\033[0m\\n\"\n\t@{ \\\n\t\tset -e -o pipefail; \\\n\t\tcp internal/version/version.go internal/version/version.go.OLD && \\\n\t\tcat internal/version/version.go.OLD | sed -e 's/Client = \".*\"/Client = \"$(version)\"/' > internal/version/version.go && \\\n\t\tgo vet internal/version/version.go && \\\n\t\tgo fmt internal/version/version.go && \\\n\t\tgit diff --color-words internal/version/version.go | tail -n 1; \\\n\t}\n\t@{ \\\n\t\tset -e -o pipefail; \\\n\t\tprintf \"\\033[2m→ Commit and create Git tag? (y/n): \\033[0m\\c\"; \\\n\t\tread continue; \\\n\t\tif [[ $$continue == \"y\" ]]; then \\\n\t\t\tgit add internal/version/version.go && \\\n\t\t\tgit commit --no-status --quiet --message \"Release $(version)\" && \\\n\t\t\tgit tag --annotate v$(version) --message 'Release $(version)'; \\\n\t\t\tprintf \"\\033[2m→ Push `git show --pretty='%h (%s)' --no-patch HEAD` to Github:\\033[0m\\n\\n\"; \\\n\t\t\tprintf \"\\033[1m  git push origin HEAD && git push origin v$(version)\\033[0m\\n\\n\"; \\\n\t\t\tmv internal/version/version.go.OLD internal/version/version.go && \\\n\t\t\tgit add internal/version/version.go && \\\n\t\t\toriginal_version=`cat internal/version/version.go | sed -ne 's;^const Client = \"\\(.*\\)\"$$;\\1;p'` && \\\n\t\t\tgit commit --no-status --quiet --message \"Update version to $$original_version\"; \\\n\t\t\tprintf \"\\033[2m→ Version updated to [$$original_version].\\033[0m\\n\\n\"; \\\n\t\telse \\\n\t\t\techo \"Aborting...\"; \\\n\t\t\trm internal/version/version.go.OLD; \\\n\t\t\texit 1; \\\n\t\tfi; \\\n\t}\n\ngodoc: ## Display documentation for the package\n\t@printf \"\\033[2m→ Generating documentation...\\033[0m\\n\"\n\t@echo \"* http://localhost:6060/pkg/github.com/elastic/go-elasticsearch/v8\"\n\t@echo \"* http://localhost:6060/pkg/github.com/elastic/go-elasticsearch/v8/esapi\"\n\t@echo \"* http://localhost:6060/pkg/github.com/elastic/go-elasticsearch/v8/esutil\"\n\t@printf \"\\n\"\n\tgodoc --http=localhost:6060 --play\n\ncluster: ## Launch an Elasticsearch cluster with Docker\n\t$(eval flavor ?= \"core\")\n\t$(eval elasticsearch_url = \"http://es1:9200\")\n\nifdef ELASTICSEARCH_BUILD_VERSION\n\t$(eval version ?= \"elasticsearch:\"${ELASTICSEARCH_BUILD_VERSION})\nelse\n\t$(eval version ?= \"elasticsearch:\"${ELASTICSEARCH_DEFAULT_BUILD_VERSION})\nendif\n\nifeq ($(origin nodes), undefined)\n\t$(eval nodes = 1)\nendif\n\t@printf \"\\033[2m→ Launching %d node(s) of %s...\\033[0m\\n\" $(nodes) $(version)\nifeq ($(shell test $(nodes) && test $(nodes) -gt 1; echo $$?),0)\n\t$(eval detach ?= \"true\")\nelse\n\t$(eval detach ?= \"false\")\nendif\n\n\t$(eval elasticsearch_url = \"http://elastic:elastic@es1:9200\")\nifeq ($(flavor), platinum)\n\t$(eval elasticsearch_url = \"https://elastic:elastic@es1:9200\")\n\t$(eval xpack_env += --env \"ELASTIC_PASSWORD=elastic\")\n\t$(eval xpack_env += --env \"xpack.license.self_generated.type=trial\")\n\t$(eval xpack_env += --env \"xpack.security.enabled=true\")\n\t$(eval xpack_env += --env \"xpack.security.http.ssl.enabled=true\")\n\t$(eval xpack_env += --env \"xpack.security.http.ssl.key=certs/testnode.key\")\n\t$(eval xpack_env += --env \"xpack.security.http.ssl.certificate=certs/testnode.crt\")\n\t$(eval xpack_env += --env \"xpack.security.http.ssl.certificate_authorities=certs/ca.crt\")\n\t$(eval xpack_env += --env \"xpack.security.transport.ssl.enabled=true\")\n\t$(eval xpack_env += --env \"xpack.security.transport.ssl.verification_mode=certificate\")\n\t$(eval xpack_env += --env \"xpack.security.transport.ssl.key=certs/testnode.key\")\n\t$(eval xpack_env += --env \"xpack.security.transport.ssl.certificate=certs/testnode.crt\")\n\t$(eval xpack_env += --env \"xpack.security.transport.ssl.certificate_authorities=certs/ca.crt\")\n\t$(eval xpack_volumes += --volume \"$(PWD)/.ci/certs/testnode.crt:/usr/share/elasticsearch/config/certs/testnode.crt\")\n\t$(eval xpack_volumes += --volume \"$(PWD)/.ci/certs/testnode.key:/usr/share/elasticsearch/config/certs/testnode.key\")\n\t$(eval xpack_volumes += --volume \"$(PWD)/.ci/certs/ca.crt:/usr/share/elasticsearch/config/certs/ca.crt\")\nendif\n\t@docker network inspect elasticsearch > /dev/null 2>&1 || docker network create elasticsearch;\n\t@{ \\\n\t\tfor n in `seq 1 $(nodes)`; do \\\n\t\t\tif [[ -z \"$$port\" ]]; then \\\n\t\t\t\thostport=$$((9199+$$n)); \\\n\t\t\telse \\\n\t\t\t\thostport=$$port; \\\n\t\t\tfi; \\\n\t\t\tdocker run \\\n\t\t\t\t--name \"es$$n\" \\\n\t\t\t\t--network elasticsearch \\\n\t\t\t\t--env \"ELASTIC_PASSWORD=elastic\" \\\n\t\t\t\t--env \"node.name=es$$n\" \\\n\t\t\t\t--env \"cluster.name=go-elasticsearch\" \\\n\t\t\t\t--env \"cluster.initial_master_nodes=es1\" \\\n\t\t\t\t--env \"discovery.seed_hosts=es1\" \\\n\t\t\t\t--env \"cluster.routing.allocation.disk.threshold_enabled=false\" \\\n\t\t\t\t--env \"bootstrap.memory_lock=true\" \\\n\t\t\t\t--env \"node.attr.testattr=test\" \\\n\t\t\t\t--env \"path.repo=/tmp\" \\\n\t\t\t\t--env \"repositories.url.allowed_urls=http://snapshot.test*\" \\\n\t\t\t\t--env \"xpack.security.enabled=false\" \\\n\t\t\t\t--env ES_JAVA_OPTS=\"-Xms1g -Xmx1g\" \\\n\t\t\t\t$(xpack_env) \\\n\t\t\t\t--volume `echo $(version) | tr -C \"[:alnum:]\" '-'`-node-$$n-data:/usr/share/elasticsearch/data \\\n\t\t\t\t$(xpack_volumes) \\\n\t\t\t\t--publish $$hostport:9200 \\\n\t\t\t\t--ulimit nofile=65536:65536 \\\n\t\t\t\t--ulimit memlock=-1:-1 \\\n\t\t\t\t--detach=$(detach) \\\n\t\t\t\t--rm \\\n\t\t\t\tdocker.elastic.co/elasticsearch/$(version); \\\n\t\tdone \\\n\t}\nifdef detach\n\t@{ \\\n\t\tprintf \"\\033[2m→ Waiting for the cluster on $(elasticsearch_url)...\\033[0m\\n\"; \\\n\t\tdocker run --network elasticsearch --rm appropriate/curl --max-time 120 --retry 120 --retry-delay 1 --retry-connrefused --show-error --silent --insecure $(elasticsearch_url); \\\n\t\toutput=\"\\033[2m→ Cluster ready; to remove containers:\"; \\\n\t\toutput=\"$$output docker rm -f\"; \\\n\t\tfor n in `seq 1 $(nodes)`; do \\\n\t\t\toutput=\"$$output es$$n\"; \\\n\t\tdone; \\\n\t\tprintf \"$$output\\033[0m\\n\"; \\\n\t}\nendif\n\ncluster-update: ## Update the Docker image\nifdef ELASTICSEARCH_BUILD_VERSION\n\t$(eval version ?= \"elasticsearch:\"${ELASTICSEARCH_BUILD_VERSION})\nelse\n\t$(eval version ?= \"elasticsearch:\"${ELASTICSEARCH_DEFAULT_BUILD_VERSION})\nendif\n\t@printf \"\\033[2m→ Updating the Docker image...\\033[0m\\n\"\n\t@docker pull docker.elastic.co/elasticsearch/$(version);\n\ncluster-clean: ## Remove unused Docker volumes and networks\n\t@printf \"\\033[2m→ Cleaning up Docker assets...\\033[0m\\n\"\n\tdocker volume prune --force\n\tdocker network prune --force\n\ndocker: ## Build the Docker image and run it\n\tdocker build --file .ci/Dockerfile --tag elastic/go-elasticsearch .\n\tdocker run -it --network elasticsearch --volume $(PWD)/tmp:/tmp:rw,delegated --rm elastic/go-elasticsearch\n\n##@ Generator\ngen-api:  ## Generate the API package from the JSON specification\n\t$(eval input  ?= tmp/rest-api-spec)\n\t$(eval output ?= esapi)\nifdef debug\n\t$(eval args += --debug)\nendif\nifdef ELASTICSEARCH_BUILD_VERSION\n\t$(eval version = $(ELASTICSEARCH_BUILD_VERSION))\nelse\n\t$(eval version = $(ELASTICSEARCH_DEFAULT_BUILD_VERSION))\nendif\nifdef ELASTICSEARCH_BUILD_HASH\n\t$(eval build_hash = $(ELASTICSEARCH_BUILD_HASH))\nelse\n\t$(eval build_hash = $(shell cat tmp/elasticsearch.json | jq \".projects.elasticsearch.commit_hash\"))\nendif\n\t@printf \"\\033[2m→ Generating API package from specification ($(version):$(build_hash))...\\033[0m\\n\"\n\t@{ \\\n\t\tset -e; \\\n\t\ttrap \"test -d .git && git checkout --quiet $(PWD)/internal/build/go.mod\" INT TERM EXIT; \\\n\t\texport ELASTICSEARCH_BUILD_VERSION=$(version) && \\\n\t\texport ELASTICSEARCH_BUILD_HASH=$(build_hash) && \\\n\t\tcd internal/build && \\\n\t\tgo run main.go apisource --input '$(PWD)/$(input)/api/*.json' --output '$(PWD)/$(output)' $(args) && \\\n\t\tgo run main.go apistruct --output '$(PWD)/$(output)'; \\\n\t}\n\ngen-tests:  ## Generate the API tests from the YAML specification\n\t$(eval input  ?= tmp/rest-api-spec)\n\t$(eval output ?= esapi/test)\nifdef debug\n\t$(eval args += --debug)\nendif\nifdef ELASTICSEARCH_BUILD_VERSION\n\t$(eval version = $(ELASTICSEARCH_BUILD_VERSION))\nelse\n\t$(eval version = $(ELASTICSEARCH_DEFAULT_BUILD_VERSION))\nendif\nifdef ELASTICSEARCH_BUILD_HASH\n\t$(eval build_hash = $(ELASTICSEARCH_BUILD_HASH))\nelse\n\t$(eval build_hash = $(shell cat tmp/elasticsearch.json | jq \".projects.elasticsearch.commit_hash\"))\nendif\n\t@printf \"\\033[2m→ Generating API tests from specification ($(version):$(build_hash))...\\033[0m\\n\"\n\t@{ \\\n\t\tset -e; \\\n\t\ttrap \"test -d .git && git checkout --quiet $(PWD)/internal/cmd/generate/go.mod\" INT TERM EXIT; \\\n\t\texport ELASTICSEARCH_BUILD_VERSION=$(version) && \\\n\t\texport ELASTICSEARCH_BUILD_HASH=$(build_hash) && \\\n\t\trm -rf $(output)/*_test.go && \\\n\t\trm -rf $(output)/xpack && \\\n\t\tcd internal/build && \\\n\t\tgo get golang.org/x/tools/cmd/goimports && \\\n\t\tgo generate ./... && \\\n\t\tgo run main.go apitests --input '$(PWD)/$(input)/test/free/**/*.y*ml' --output '$(PWD)/$(output)' $(args) && \\\n\t\tgo run main.go apitests --input '$(PWD)/$(input)/test/platinum/**/*.yml' --output '$(PWD)/$(output)/xpack' $(args) && \\\n\t\tmkdir -p '$(PWD)/esapi/test/xpack/ml' && \\\n\t\tmkdir -p '$(PWD)/esapi/test/xpack/ml-crud' && \\\n\t\tmv $(PWD)/esapi/test/xpack/xpack_ml* $(PWD)/esapi/test/xpack/ml/ && \\\n\t\tmv $(PWD)/esapi/test/xpack/ml/xpack_ml__jobs_crud_test.go $(PWD)/esapi/test/xpack/ml-crud/; \\\n\t}\n\ngen-docs:  ## Generate the skeleton of documentation examples\n\t$(eval input  ?= tmp/alternatives_report.json)\n\t$(eval update ?= no)\n\t@{ \\\n\t\tset -e; \\\n\t\ttrap \"test -d .git && git checkout --quiet $(PWD)/internal/cmd/generate/go.mod\" INT TERM EXIT; \\\n\t\tif [[ $(update) == 'yes' ]]; then \\\n\t\t\tprintf \"\\033[2m→ Updating the alternatives_report.json file\\033[0m\\n\" && \\\n\t\t\tcurl -s https://raw.githubusercontent.com/elastic/built-docs/master/raw/en/elasticsearch/reference/master/alternatives_report.json > tmp/alternatives_report.json; \\\n\t\tfi; \\\n\t\tprintf \"\\033[2m→ Generating Go source files from Console input in [$(input)]\\033[0m\\n\" && \\\n\t\t( cd '$(PWD)/internal/cmd/generate' && \\\n\t\t\tgo run main.go examples src --debug --input='$(PWD)/$(input)' --output='$(PWD)/.doc/examples/' \\\n\t\t) && \\\n\t\t( cd '$(PWD)/.doc/examples/src' && \\\n\t\t\tif which gotestsum > /dev/null 2>&1 ; then \\\n\t\t\t\tgotestsum --format=short-verbose; \\\n\t\t\telse \\\n\t\t\t\tgo test -v $(testunitargs); \\\n\t\t\tfi; \\\n\t\t) && \\\n\t\tprintf \"\\n\\033[2m→ Generating ASCIIDoc files from Go source\\033[0m\\n\" && \\\n\t\t( cd '$(PWD)/internal/build' && \\\n\t\t\tgo run main.go examples doc --debug --input='$(PWD)/.doc/examples/src/' --output='$(PWD)/.doc/examples/' \\\n\t\t) \\\n\t}\n\ndownload-specs: ## Download the latest specs for the specified Elasticsearch version\n\t$(eval output ?= tmp)\n\t@mkdir -p tmp\n\t@{ \\\n\t\tset -e; \\\n\t\tprintf \"\\n\\033[2m→ Downloading latest Elasticsearch specs for version [$(ELASTICSEARCH_DEFAULT_BUILD_VERSION)]\\033[0m\\n\" && \\\n\t\trm -rf $(output)/rest-api-spec && \\\n\t\trm -rf $(output)/elasticsearch.json && \\\n\t\tcd internal/build && \\\n\t\tgo run main.go download-spec --output '$(PWD)/$(output)'; \\\n\t}\n\n##@ Other\n#------------------------------------------------------------------------------\nhelp:  ## Display help\n\t@awk 'BEGIN {FS = \":.*##\"; printf \"Usage:\\n  make \\033[36m<target>\\033[0m\\n\"} /^[a-zA-Z_-]+:.*?##/ { printf \"  \\033[36m%-15s\\033[0m %s\\n\", $$1, $$2 } /^##@/ { printf \"\\n\\033[1m%s\\033[0m\\n\", substr($$0, 5) } ' $(MAKEFILE_LIST)\n#------------- <https://suva.sh/posts/well-documented-makefiles> --------------\n\n.DEFAULT_GOAL := help\n.PHONY: help apidiff backport cluster cluster-clean cluster-update coverage docker examples gen-api gen-tests godoc lint release test test-api test-bench test-integ test-unit\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.0556640625,
          "content": "Elasticsearch Go Client\nCopyright 2021 Elasticsearch B.V."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.291015625,
          "content": "# go-elasticsearch\n\nThe official Go client for [Elasticsearch](https://www.elastic.co/products/elasticsearch).\n\n**[Download the latest version of Elasticsearch](https://www.elastic.co/downloads/elasticsearch)**\nor\n**[sign-up](https://cloud.elastic.co/registration?elektra=en-ess-sign-up-page)**\n**for a free trial of Elastic Cloud**.\n\n[![Go Reference](https://pkg.go.dev/github.com/elastic/go-elasticsearch?status.svg)](https://pkg.go.dev/github.com/elastic/go-elasticsearch/v8)\n[![Go Report Card](https://goreportcard.com/badge/github.com/elastic/go-elasticsearch)](https://goreportcard.com/report/github.com/elastic/go-elasticsearch)\n[![codecov.io](https://codecov.io/github/elastic/go-elasticsearch/coverage.svg?branch=main)](https://codecov.io/gh/elastic/go-elasticsearch?branch=main)\n[![Build](https://github.com/elastic/go-elasticsearch/workflows/Build/badge.svg)](https://github.com/elastic/go-elasticsearch/actions?query=branch%3Amain)\n[![Unit](https://github.com/elastic/go-elasticsearch/workflows/Unit/badge.svg)](https://github.com/elastic/go-elasticsearch/actions?query=branch%3Amain)\n[![Integration](https://github.com/elastic/go-elasticsearch/workflows/Integration/badge.svg)](https://github.com/elastic/go-elasticsearch/actions?query=branch%3Amain)\n[![API](https://github.com/elastic/go-elasticsearch/workflows/API/badge.svg)](https://github.com/elastic/go-elasticsearch/actions?query=branch%3Amain)\n\n## Compatibility\n\n### Go\n\nStarting from version `8.12.0`, this library follow the Go language [policy](https://go.dev/doc/devel/release#policy). Each major Go release is supported until there are two newer major releases. For example, Go 1.5 was supported until the Go 1.7 release, and Go 1.6 was supported until the Go 1.8 release.\n\n### Elasticsearch\n\nLanguage clients are forward compatible; meaning that clients support communicating with greater or equal minor versions of Elasticsearch.\nElasticsearch language clients are only backwards compatible with default distributions and without guarantees made.\n\nWhen using Go modules, include the version in the import path, and specify either an explicit version or a branch:\n\n    require github.com/elastic/go-elasticsearch/v8 v8.0.0\n    require github.com/elastic/go-elasticsearch/v7 7.17\n\nIt's possible to use multiple versions of the client in a single project:\n\n    // go.mod\n    github.com/elastic/go-elasticsearch/v7 v7.17.0\n    github.com/elastic/go-elasticsearch/v8 v8.0.0\n\n    // main.go\n    import (\n      elasticsearch7 \"github.com/elastic/go-elasticsearch/v7\"\n      elasticsearch8 \"github.com/elastic/go-elasticsearch/v8\"\n    )\n    // ...\n    es7, _ := elasticsearch7.NewDefaultClient()\n    es8, _ := elasticsearch8.NewDefaultClient()\n\nThe `main` branch of the client is compatible with the current `master` branch of Elasticsearch.\n\n<!-- ----------------------------------------------------------------------------------------------- -->\n\n## Installation\n\nRefer to the [Installation section](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_installation)\nof the getting started documentation.\n\n<!-- ----------------------------------------------------------------------------------------------- -->\n\n## Connecting\n\nRefer to the [Connecting section](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_connecting)\nof the getting started documentation.\n\n## Operations\n\n* [Creating an index](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_creating_an_index)\n* [Indexing documents](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_indexing_documents)\n* [Getting documents](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_getting_documents)\n* [Searching documents](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_searching_documents)\n* [Updating documents](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_updating_documents)\n* [Deleting documents](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_deleting_documents)\n* [Deleting an index](https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html#_deleting_an_index)\n<!-- ----------------------------------------------------------------------------------------------- -->\n\n## Helpers\n\nThe `esutil` package provides convenience helpers for working with the client. At the moment, it provides the `esutil.JSONReader()` and the `esutil.BulkIndexer` helpers.\n\n<!-- ----------------------------------------------------------------------------------------------- -->\n\n## Examples\n\nThe **[`_examples`](./_examples)** folder contains a number of recipes and comprehensive examples to get you started with the client, including configuration and customization of the client, using a custom certificate authority (CA) for security (TLS), mocking the transport for unit tests, embedding the client in a custom type, building queries, performing requests individually and in bulk, and parsing the responses.\n\n<!-- ----------------------------------------------------------------------------------------------- -->\n\n## License\n\nThis software is licensed under the [Apache 2 license](./LICENSE). See [NOTICE](./NOTICE).\n"
        },
        {
          "name": "_benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "catalog-info.yaml",
          "type": "blob",
          "size": 0.4619140625,
          "content": "apiVersion: backstage.io/v1alpha1\nkind: Resource\nmetadata:\n  name: buildkite-pipeline-go-elasticsearch\nspec:\n  implementation:\n    apiVersion: buildkite.elastic.dev/v1\n    kind: Pipeline\n    metadata:\n      description: Elasticsearch Go Client\n      name: go-elasticsearch\n    spec:\n      repository: elastic/go-elasticsearch\n      teams:\n        devtools-team: {}\n        everyone:\n          access_level: READ_ONLY\n  owner: group:devtools-team\n  type: buildkite-pipeline\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 2.3125,
          "content": "// Licensed to Elasticsearch B.V. under one or more contributor\n// license agreements. See the NOTICE file distributed with\n// this work for additional information regarding copyright\n// ownership. Elasticsearch B.V. licenses this file to you under\n// the Apache License, Version 2.0 (the \"License\"); you may\n// not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/*\nPackage elasticsearch provides a Go client for Elasticsearch.\n\nCreate the client with the NewDefaultClient function:\n\n\t\telasticsearch.NewDefaultClient()\n\nThe ELASTICSEARCH_URL environment variable is used instead of the default URL, when set.\nUse a comma to separate multiple URLs.\n\nTo configure the client, pass a Config object to the NewClient function:\n\n\t\tcfg := elasticsearch.Config{\n\t\t  Addresses: []string{\n\t\t    \"http://localhost:9200\",\n\t\t    \"http://localhost:9201\",\n\t\t  },\n\t\t  Username: \"foo\",\n\t\t  Password: \"bar\",\n\t\t  Transport: &http.Transport{\n\t\t    MaxIdleConnsPerHost:   10,\n\t\t    ResponseHeaderTimeout: time.Second,\n\t\t    DialContext:           (&net.Dialer{Timeout: time.Second}).DialContext,\n\t\t    TLSClientConfig: &tls.Config{\n\t\t      MinVersion:         tls.VersionTLS12,\n\t\t    },\n\t\t  },\n\t\t}\n\n\t\telasticsearch.NewClient(cfg)\n\nWhen using the Elastic Service (https://elastic.co/cloud), you can use CloudID instead of Addresses.\nWhen either Addresses or CloudID is set, the ELASTICSEARCH_URL environment variable is ignored.\n\nSee the elasticsearch_integration_test.go file and the _examples folder for more information.\n\nCall the Elasticsearch APIs by invoking the corresponding methods on the client:\n\n\t\tres, err := es.Info()\n\t\tif err != nil {\n\t\t  log.Fatalf(\"Error getting response: %s\", err)\n\t\t}\n\n\t\tlog.Println(res)\n\nSee the github.com/elastic/go-elasticsearch/esapi package for more information about using the API.\n\nSee the github.com/elastic/elastic-transport-go package for more information about configuring the transport.\n*/\npackage elasticsearch\n"
        },
        {
          "name": "elasticsearch.go",
          "type": "blob",
          "size": 15.50390625,
          "content": "// Licensed to Elasticsearch B.V. under one or more contributor\n// license agreements. See the NOTICE file distributed with\n// this work for additional information regarding copyright\n// ownership. Elasticsearch B.V. licenses this file to you under\n// the Apache License, Version 2.0 (the \"License\"); you may\n// not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage elasticsearch\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/elastic/go-elasticsearch/v8/typedapi\"\n\n\t\"github.com/elastic/go-elasticsearch/v8/esapi\"\n\t\"github.com/elastic/go-elasticsearch/v8/internal/version\"\n\n\t\"github.com/elastic/elastic-transport-go/v8/elastictransport\"\n\ttpversion \"github.com/elastic/elastic-transport-go/v8/elastictransport/version\"\n)\n\nconst (\n\tdefaultURL = \"http://localhost:9200\"\n\n\t// Version returns the package version as a string.\n\tVersion        = version.Client\n\tunknownProduct = \"the client noticed that the server is not Elasticsearch and we do not support this unknown product\"\n\n\t// HeaderClientMeta Key for the HTTP Header related to telemetry data sent with\n\t// each request to Elasticsearch.\n\tHeaderClientMeta = \"x-elastic-client-meta\"\n\n\tcompatibilityHeader = \"application/vnd.elasticsearch+json;compatible-with=8\"\n)\n\nvar (\n\tesCompatHeader = \"ELASTIC_CLIENT_APIVERSIONING\"\n\tuserAgent      string\n\treGoVersion    = regexp.MustCompile(`go(\\d+\\.\\d+\\..+)`)\n\treMetaVersion  = regexp.MustCompile(\"([0-9.]+)(.*)\")\n)\n\nfunc init() {\n\tuserAgent = initUserAgent()\n}\n\n// Config represents the client configuration.\ntype Config struct {\n\tAddresses []string // A list of Elasticsearch nodes to use.\n\tUsername  string   // Username for HTTP Basic Authentication.\n\tPassword  string   // Password for HTTP Basic Authentication.\n\n\tCloudID                string // Endpoint for the Elastic Service (https://elastic.co/cloud).\n\tAPIKey                 string // Base64-encoded token for authorization; if set, overrides username/password and service token.\n\tServiceToken           string // Service token for authorization; if set, overrides username/password.\n\tCertificateFingerprint string // SHA256 hex fingerprint given by Elasticsearch on first launch.\n\n\tHeader http.Header // Global HTTP request header.\n\n\t// PEM-encoded certificate authorities.\n\t// When set, an empty certificate pool will be created, and the certificates will be appended to it.\n\t// The option is only valid when the transport is not specified, or when it's http.Transport.\n\tCACert []byte\n\n\tRetryOnStatus []int                           // List of status codes for retry. Default: 502, 503, 504.\n\tDisableRetry  bool                            // Default: false.\n\tMaxRetries    int                             // Default: 3.\n\tRetryOnError  func(*http.Request, error) bool // Optional function allowing to indicate which error should be retried. Default: nil.\n\n\tCompressRequestBody      bool // Default: false.\n\tCompressRequestBodyLevel int  // Default: gzip.DefaultCompression.\n\tPoolCompressor           bool // If true, a sync.Pool based gzip writer is used. Default: false.\n\n\tDiscoverNodesOnStart  bool          // Discover nodes when initializing the client. Default: false.\n\tDiscoverNodesInterval time.Duration // Discover nodes periodically. Default: disabled.\n\n\tEnableMetrics           bool // Enable the metrics collection.\n\tEnableDebugLogger       bool // Enable the debug logging.\n\tEnableCompatibilityMode bool // Enable sends compatibility header\n\n\tDisableMetaHeader bool // Disable the additional \"X-Elastic-Client-Meta\" HTTP header.\n\n\tRetryBackoff func(attempt int) time.Duration // Optional backoff duration. Default: nil.\n\n\tTransport http.RoundTripper         // The HTTP transport object.\n\tLogger    elastictransport.Logger   // The logger object.\n\tSelector  elastictransport.Selector // The selector object.\n\n\t// Optional constructor function for a custom ConnectionPool. Default: nil.\n\tConnectionPoolFunc func([]*elastictransport.Connection, elastictransport.Selector) elastictransport.ConnectionPool\n\n\tInstrumentation elastictransport.Instrumentation // Enable instrumentation throughout the client.\n}\n\n// NewOpenTelemetryInstrumentation provides the OpenTelemetry integration for both low-level and TypedAPI.\n// provider is optional, if nil is passed the integration will retrieve the provider set globally by otel.\n// captureSearchBody allows to define if the search queries body should be included in the span.\n// Search endpoints are:\n//\n//\tsearch\n//\tasync_search.submit\n//\tmsearch\n//\teql.search\n//\tterms_enum\n//\tsearch_template\n//\tmsearch_template\n//\trender_search_template\nfunc NewOpenTelemetryInstrumentation(provider trace.TracerProvider, captureSearchBody bool) elastictransport.Instrumentation {\n\treturn elastictransport.NewOtelInstrumentation(provider, captureSearchBody, Version)\n}\n\n// BaseClient represents the Elasticsearch client.\ntype BaseClient struct {\n\tTransport           elastictransport.Interface\n\tmetaHeader          string\n\tcompatibilityHeader bool\n\n\tdisableMetaHeader   bool\n\tproductCheckMu      sync.RWMutex\n\tproductCheckSuccess bool\n}\n\n// Client represents the Functional Options API.\ntype Client struct {\n\tBaseClient\n\t*esapi.API\n}\n\n// TypedClient represents the Typed API.\ntype TypedClient struct {\n\tBaseClient\n\t*typedapi.API\n}\n\n// NewDefaultClient creates a new client with default options.\n//\n// It will use http://localhost:9200 as the default address.\n//\n// It will use the ELASTICSEARCH_URL environment variable, if set,\n// to configure the addresses; use a comma to separate multiple URLs.\nfunc NewDefaultClient() (*Client, error) {\n\treturn NewClient(Config{})\n}\n\n// NewClient creates a new client with configuration from cfg.\n//\n// It will use http://localhost:9200 as the default address.\n//\n// It will use the ELASTICSEARCH_URL environment variable, if set,\n// to configure the addresses; use a comma to separate multiple URLs.\n//\n// If either cfg.Addresses or cfg.CloudID is set, the ELASTICSEARCH_URL\n// environment variable is ignored.\n//\n// It's an error to set both cfg.Addresses and cfg.CloudID.\nfunc NewClient(cfg Config) (*Client, error) {\n\ttp, err := newTransport(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcompatHeaderEnv := os.Getenv(esCompatHeader)\n\tcompatibilityHeader, _ := strconv.ParseBool(compatHeaderEnv)\n\n\tclient := &Client{\n\t\tBaseClient: BaseClient{\n\t\t\tTransport:           tp,\n\t\t\tdisableMetaHeader:   cfg.DisableMetaHeader,\n\t\t\tmetaHeader:          initMetaHeader(tp),\n\t\t\tcompatibilityHeader: cfg.EnableCompatibilityMode || compatibilityHeader,\n\t\t},\n\t}\n\tclient.API = esapi.New(client)\n\n\tif cfg.DiscoverNodesOnStart {\n\t\tgo client.DiscoverNodes()\n\t}\n\n\treturn client, nil\n}\n\n// NewTypedClient create a new client with the configuration from cfg.\n//\n// This version uses the same configuration as NewClient.\n//\n// It will return the client with the TypedAPI.\nfunc NewTypedClient(cfg Config) (*TypedClient, error) {\n\ttp, err := newTransport(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcompatHeaderEnv := os.Getenv(esCompatHeader)\n\tcompatibilityHeader, _ := strconv.ParseBool(compatHeaderEnv)\n\n\tmetaHeader := strings.Join([]string{initMetaHeader(tp), \"hl=1\"}, \",\")\n\n\tclient := &TypedClient{\n\t\tBaseClient: BaseClient{\n\t\t\tTransport:           tp,\n\t\t\tdisableMetaHeader:   cfg.DisableMetaHeader,\n\t\t\tmetaHeader:          metaHeader,\n\t\t\tcompatibilityHeader: cfg.EnableCompatibilityMode || compatibilityHeader,\n\t\t},\n\t}\n\tclient.API = typedapi.New(client)\n\n\tif cfg.DiscoverNodesOnStart {\n\t\tgo client.DiscoverNodes()\n\t}\n\n\treturn client, nil\n}\n\nfunc newTransport(cfg Config) (*elastictransport.Client, error) {\n\tvar addrs []string\n\n\tif len(cfg.Addresses) == 0 && cfg.CloudID == \"\" {\n\t\taddrs = addrsFromEnvironment()\n\t} else {\n\t\tif len(cfg.Addresses) > 0 && cfg.CloudID != \"\" {\n\t\t\treturn nil, errors.New(\"cannot create client: both Addresses and CloudID are set\")\n\t\t}\n\n\t\tif cfg.CloudID != \"\" {\n\t\t\tcloudAddr, err := addrFromCloudID(cfg.CloudID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"cannot create client: cannot parse CloudID: %s\", err)\n\t\t\t}\n\t\t\taddrs = append(addrs, cloudAddr)\n\t\t}\n\n\t\tif len(cfg.Addresses) > 0 {\n\t\t\taddrs = append(addrs, cfg.Addresses...)\n\t\t}\n\t}\n\n\turls, err := addrsToURLs(addrs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot create client: %s\", err)\n\t}\n\n\tif len(urls) == 0 {\n\t\tu, _ := url.Parse(defaultURL) // errcheck exclude\n\t\turls = append(urls, u)\n\t}\n\n\t// TODO(karmi): Refactor\n\tif urls[0].User != nil {\n\t\tcfg.Username = urls[0].User.Username()\n\t\tpw, _ := urls[0].User.Password()\n\t\tcfg.Password = pw\n\t}\n\n\ttpConfig := elastictransport.Config{\n\t\tUserAgent: userAgent,\n\n\t\tURLs:                   urls,\n\t\tUsername:               cfg.Username,\n\t\tPassword:               cfg.Password,\n\t\tAPIKey:                 cfg.APIKey,\n\t\tServiceToken:           cfg.ServiceToken,\n\t\tCertificateFingerprint: cfg.CertificateFingerprint,\n\n\t\tHeader: cfg.Header,\n\t\tCACert: cfg.CACert,\n\n\t\tRetryOnStatus: cfg.RetryOnStatus,\n\t\tDisableRetry:  cfg.DisableRetry,\n\t\tRetryOnError:  cfg.RetryOnError,\n\t\tMaxRetries:    cfg.MaxRetries,\n\t\tRetryBackoff:  cfg.RetryBackoff,\n\n\t\tCompressRequestBody:      cfg.CompressRequestBody,\n\t\tCompressRequestBodyLevel: cfg.CompressRequestBodyLevel,\n\t\tPoolCompressor:           cfg.PoolCompressor,\n\n\t\tEnableMetrics:     cfg.EnableMetrics,\n\t\tEnableDebugLogger: cfg.EnableDebugLogger,\n\n\t\tDiscoverNodesInterval: cfg.DiscoverNodesInterval,\n\n\t\tTransport:          cfg.Transport,\n\t\tLogger:             cfg.Logger,\n\t\tSelector:           cfg.Selector,\n\t\tConnectionPoolFunc: cfg.ConnectionPoolFunc,\n\n\t\tInstrumentation: cfg.Instrumentation,\n\t}\n\n\ttp, err := elastictransport.New(tpConfig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating transport: %s\", err)\n\t}\n\n\treturn tp, nil\n}\n\n// Perform delegates to Transport to execute a request and return a response.\nfunc (c *BaseClient) Perform(req *http.Request) (*http.Response, error) {\n\t// Compatibility Header\n\tif c.compatibilityHeader {\n\t\tif req.Body != nil {\n\t\t\treq.Header.Set(\"Content-Type\", compatibilityHeader)\n\t\t}\n\t\treq.Header.Set(\"Accept\", compatibilityHeader)\n\t}\n\n\tif !c.disableMetaHeader {\n\t\texistingMetaHeader := req.Header.Get(HeaderClientMeta)\n\t\tif existingMetaHeader != \"\" {\n\t\t\treq.Header.Set(HeaderClientMeta, strings.Join([]string{c.metaHeader, existingMetaHeader}, \",\"))\n\t\t} else {\n\t\t\treq.Header.Add(HeaderClientMeta, c.metaHeader)\n\t\t}\n\t} else {\n\t\treq.Header.Del(HeaderClientMeta)\n\t}\n\n\t// Retrieve the original request.\n\tres, err := c.Transport.Perform(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// ResponseCheck, we run the header check on the first answer from ES.\n\tif res.StatusCode >= 200 && res.StatusCode < 300 {\n\t\tcheckHeader := func() error { return genuineCheckHeader(res.Header) }\n\t\tif err := c.doProductCheck(checkHeader); err != nil {\n\t\t\tres.Body.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// InstrumentationEnabled propagates back to the client the Instrumentation provided by the transport.\nfunc (c *BaseClient) InstrumentationEnabled() elastictransport.Instrumentation {\n\tif tp, ok := c.Transport.(elastictransport.Instrumented); ok {\n\t\treturn tp.InstrumentationEnabled()\n\t}\n\treturn nil\n}\n\n// doProductCheck calls f if there as not been a prior successful call to doProductCheck,\n// returning nil otherwise.\nfunc (c *BaseClient) doProductCheck(f func() error) error {\n\tc.productCheckMu.RLock()\n\tproductCheckSuccess := c.productCheckSuccess\n\tc.productCheckMu.RUnlock()\n\n\tif productCheckSuccess {\n\t\treturn nil\n\t}\n\n\tc.productCheckMu.Lock()\n\tdefer c.productCheckMu.Unlock()\n\n\tif c.productCheckSuccess {\n\t\treturn nil\n\t}\n\n\tif err := f(); err != nil {\n\t\treturn err\n\t}\n\n\tc.productCheckSuccess = true\n\n\treturn nil\n}\n\n// genuineCheckHeader validates the presence of the X-Elastic-Product header\nfunc genuineCheckHeader(header http.Header) error {\n\tif header.Get(\"X-Elastic-Product\") != \"Elasticsearch\" {\n\t\treturn errors.New(unknownProduct)\n\t}\n\treturn nil\n}\n\n// Metrics returns the client metrics.\nfunc (c *BaseClient) Metrics() (elastictransport.Metrics, error) {\n\tif mt, ok := c.Transport.(elastictransport.Measurable); ok {\n\t\treturn mt.Metrics()\n\t}\n\treturn elastictransport.Metrics{}, errors.New(\"transport is missing method Metrics()\")\n}\n\n// DiscoverNodes reloads the client connections by fetching information from the cluster.\nfunc (c *BaseClient) DiscoverNodes() error {\n\tif dt, ok := c.Transport.(elastictransport.Discoverable); ok {\n\t\treturn dt.DiscoverNodes()\n\t}\n\treturn errors.New(\"transport is missing method DiscoverNodes()\")\n}\n\n// addrsFromEnvironment returns a list of addresses by splitting\n// the ELASTICSEARCH_URL environment variable with comma, or an empty list.\nfunc addrsFromEnvironment() []string {\n\tvar addrs []string\n\n\tif envURLs, ok := os.LookupEnv(\"ELASTICSEARCH_URL\"); ok && envURLs != \"\" {\n\t\tlist := strings.Split(envURLs, \",\")\n\t\tfor _, u := range list {\n\t\t\taddrs = append(addrs, strings.TrimSpace(u))\n\t\t}\n\t}\n\n\treturn addrs\n}\n\n// addrsToURLs creates a list of url.URL structures from url list.\nfunc addrsToURLs(addrs []string) ([]*url.URL, error) {\n\tvar urls []*url.URL\n\tfor _, addr := range addrs {\n\t\tu, err := url.Parse(strings.TrimRight(addr, \"/\"))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot parse url: %v\", err)\n\t\t}\n\n\t\turls = append(urls, u)\n\t}\n\treturn urls, nil\n}\n\n// addrFromCloudID extracts the Elasticsearch URL from CloudID.\n// See: https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html\nfunc addrFromCloudID(input string) (string, error) {\n\tvar scheme = \"https://\"\n\n\tvalues := strings.Split(input, \":\")\n\tif len(values) != 2 {\n\t\treturn \"\", fmt.Errorf(\"unexpected format: %q\", input)\n\t}\n\tdata, err := base64.StdEncoding.DecodeString(values[1])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tparts := strings.Split(string(data), \"$\")\n\n\tif len(parts) < 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid encoded value: %s\", parts)\n\t}\n\n\treturn fmt.Sprintf(\"%s%s.%s\", scheme, parts[1], parts[0]), nil\n}\n\nfunc initUserAgent() string {\n\tvar b strings.Builder\n\n\tb.WriteString(\"go-elasticsearch\")\n\tb.WriteRune('/')\n\tb.WriteString(Version)\n\tb.WriteRune(' ')\n\tb.WriteRune('(')\n\tb.WriteString(runtime.GOOS)\n\tb.WriteRune(' ')\n\tb.WriteString(runtime.GOARCH)\n\tb.WriteString(\"; \")\n\tb.WriteString(\"Go \")\n\tif v := reGoVersion.ReplaceAllString(runtime.Version(), \"$1\"); v != \"\" {\n\t\tb.WriteString(v)\n\t} else {\n\t\tb.WriteString(runtime.Version())\n\t}\n\tb.WriteRune(')')\n\n\treturn b.String()\n}\n\nfunc initMetaHeader(transport interface{}) string {\n\tvar b strings.Builder\n\tvar strippedGoVersion string\n\tvar strippedEsVersion string\n\tvar strippedTransportVersion string\n\n\tstrippedEsVersion = buildStrippedVersion(Version)\n\tstrippedGoVersion = buildStrippedVersion(runtime.Version())\n\n\tif _, ok := transport.(*elastictransport.Client); ok {\n\t\tstrippedTransportVersion = buildStrippedVersion(tpversion.Transport)\n\t} else {\n\t\tstrippedTransportVersion = strippedEsVersion\n\t}\n\n\tvar duos = [][]string{\n\t\t{\n\t\t\t\"es\",\n\t\t\tstrippedEsVersion,\n\t\t},\n\t\t{\n\t\t\t\"go\",\n\t\t\tstrippedGoVersion,\n\t\t},\n\t\t{\n\t\t\t\"t\",\n\t\t\tstrippedTransportVersion,\n\t\t},\n\t\t{\n\t\t\t\"hc\",\n\t\t\tstrippedGoVersion,\n\t\t},\n\t}\n\n\tvar arr []string\n\tfor _, duo := range duos {\n\t\tarr = append(arr, strings.Join(duo, \"=\"))\n\t}\n\tb.WriteString(strings.Join(arr, \",\"))\n\n\treturn b.String()\n}\n\nfunc buildStrippedVersion(version string) string {\n\tv := reMetaVersion.FindStringSubmatch(version)\n\n\tif len(v) == 3 && !strings.Contains(version, \"devel\") {\n\t\tswitch {\n\t\tcase v[2] != \"\":\n\t\t\treturn v[1] + \"p\"\n\t\tdefault:\n\t\t\treturn v[1]\n\t\t}\n\t}\n\n\treturn \"0.0p\"\n}\n"
        },
        {
          "name": "elasticsearch_benchmark_test.go",
          "type": "blob",
          "size": 5.81640625,
          "content": "// Licensed to Elasticsearch B.V. under one or more contributor\n// license agreements. See the NOTICE file distributed with\n// this work for additional information regarding copyright\n// ownership. Elasticsearch B.V. licenses this file to you under\n// the Apache License, Version 2.0 (the \"License\"); you may\n// not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//go:build !integration\n// +build !integration\n\npackage elasticsearch_test\n\nimport (\n\t\"context\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/elastic/go-elasticsearch/v8\"\n\t\"github.com/elastic/go-elasticsearch/v8/esapi\"\n)\n\nvar defaultResponse = http.Response{\n\tStatus:        \"200 OK\",\n\tStatusCode:    200,\n\tContentLength: 2,\n\tHeader: http.Header(map[string][]string{\n\t\t\"Content-Type\":      {\"application/json\"},\n\t\t\"X-Elastic-Product\": {\"Elasticsearch\"},\n\t}),\n\tBody: ioutil.NopCloser(strings.NewReader(`{}`)),\n}\n\ntype FakeTransport struct {\n\tFakeResponse *http.Response\n}\n\nfunc (t *FakeTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\treturn t.FakeResponse, nil\n}\n\nfunc newFakeTransport(b *testing.B) *FakeTransport {\n\treturn &FakeTransport{FakeResponse: &defaultResponse}\n}\n\nfunc BenchmarkClient(b *testing.B) {\n\tb.ReportAllocs()\n\n\tb.Run(\"Create client with defaults\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_, err := elasticsearch.NewDefaultClient()\n\n\t\t\tif err != nil {\n\t\t\t\tb.Fatalf(\"Unexpected error when creating a client: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkClientAPI(b *testing.B) {\n\tb.ReportAllocs()\n\n\tctx := context.Background()\n\n\tclient, err := elasticsearch.NewClient(elasticsearch.Config{\n\t\tAddresses: []string{\"http://localhost:9200\"},\n\t\tTransport: newFakeTransport(b),\n\t})\n\tif err != nil {\n\t\tb.Fatalf(\"ERROR: %s\", err)\n\t}\n\n\tb.Run(\"InfoRequest{}.Do()\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\n\t\treq := esapi.InfoRequest{}\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tif _, err := req.Do(ctx, client); err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"IndexRequest{...}.Do()\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tvar body strings.Builder\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdocID := strconv.FormatInt(int64(i), 10)\n\n\t\t\tbody.Reset()\n\t\t\tbody.WriteString(`{\"foo\" : \"bar `)\n\t\t\tbody.WriteString(docID)\n\t\t\tbody.WriteString(`\t\" }`)\n\n\t\t\treq := esapi.IndexRequest{\n\t\t\t\tIndex:      \"test\",\n\t\t\t\tDocumentID: docID,\n\t\t\t\tBody:       strings.NewReader(body.String()),\n\t\t\t\tRefresh:    \"true\",\n\t\t\t\tPretty:     true,\n\t\t\t\tTimeout:    100,\n\t\t\t}\n\t\t\tif _, err := req.Do(ctx, client); err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"Index(...)\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tvar body strings.Builder\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdocID := strconv.FormatInt(int64(i), 10)\n\n\t\t\tbody.Reset()\n\t\t\tbody.WriteString(`{\"foo\" : \"bar `)\n\t\t\tbody.WriteString(docID)\n\t\t\tbody.WriteString(`\t\" }`)\n\n\t\t\t_, err := client.Index(\n\t\t\t\t\"test\",\n\t\t\t\tstrings.NewReader(body.String()),\n\t\t\t\tclient.Index.WithDocumentID(docID),\n\t\t\t\tclient.Index.WithRefresh(\"true\"),\n\t\t\t\tclient.Index.WithPretty(),\n\t\t\t\tclient.Index.WithTimeout(100),\n\t\t\t\tclient.Index.WithContext(ctx),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"SearchRequest{...}.Do()\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\n\t\tbody := `{\"foo\" : \"bar\"}`\n\t\tindx := []string{\"test\"}\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\treq := esapi.SearchRequest{\n\t\t\t\tIndex:   indx,\n\t\t\t\tBody:    strings.NewReader(body),\n\t\t\t\tSize:    esapi.IntPtr(25),\n\t\t\t\tPretty:  true,\n\t\t\t\tTimeout: 100,\n\t\t\t}\n\t\t\tif _, err := req.Do(ctx, client); err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"Search(...)\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\n\t\tbody := `{\"foo\" : \"bar\"}`\n\t\tindx := \"test\"\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_, err := client.Search(\n\t\t\t\tclient.Search.WithIndex(indx),\n\t\t\t\tclient.Search.WithBody(strings.NewReader(body)),\n\t\t\t\tclient.Search.WithSize(25),\n\t\t\t\tclient.Search.WithPretty(),\n\t\t\t\tclient.Search.WithTimeout(100),\n\t\t\t\tclient.Search.WithContext(ctx),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"BulkRequest{...}.Do()\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tvar body strings.Builder\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdocID := strconv.FormatInt(int64(i), 10)\n\n\t\t\tbody.Reset()\n\t\t\tbody.WriteString(`{\"index\" : { \"_index\" : \"test\", \"_type\" : \"_doc\", \"_id\" : \"` + docID + `\" }}`)\n\t\t\tbody.WriteString(`{\"foo\" : \"bar `)\n\t\t\tbody.WriteString(docID)\n\t\t\tbody.WriteString(`\t\" }`)\n\n\t\t\treq := esapi.BulkRequest{\n\t\t\t\tBody:    strings.NewReader(body.String()),\n\t\t\t\tRefresh: \"true\",\n\t\t\t\tPretty:  true,\n\t\t\t\tTimeout: 100,\n\t\t\t}\n\t\t\tif _, err := req.Do(ctx, client); err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"Bulk(...)\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tvar body strings.Builder\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdocID := strconv.FormatInt(int64(i), 10)\n\n\t\t\tbody.Reset()\n\t\t\tbody.WriteString(`{\"index\" : { \"_index\" : \"test\", \"_type\" : \"_doc\", \"_id\" : \"` + docID + `\" }}`)\n\t\t\tbody.WriteString(`{\"foo\" : \"bar `)\n\t\t\tbody.WriteString(docID)\n\t\t\tbody.WriteString(`\t\" }`)\n\n\t\t\t_, err := client.Bulk(\n\t\t\t\tstrings.NewReader(body.String()),\n\t\t\t\tclient.Bulk.WithRefresh(\"true\"),\n\t\t\t\tclient.Bulk.WithPretty(),\n\t\t\t\tclient.Bulk.WithTimeout(100),\n\t\t\t\tclient.Bulk.WithContext(ctx),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tb.Errorf(\"Unexpected error when getting a response: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "elasticsearch_example_test.go",
          "type": "blob",
          "size": 2.2705078125,
          "content": "// Licensed to Elasticsearch B.V. under one or more contributor\n// license agreements. See the NOTICE file distributed with\n// this work for additional information regarding copyright\n// ownership. Elasticsearch B.V. licenses this file to you under\n// the Apache License, Version 2.0 (the \"License\"); you may\n// not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//go:build !integration\n// +build !integration\n\npackage elasticsearch_test\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/elastic/elastic-transport-go/v8/elastictransport\"\n\t\"github.com/elastic/go-elasticsearch/v8\"\n)\n\nfunc init() {\n\tlog.SetFlags(0)\n}\n\nfunc ExampleNewDefaultClient() {\n\tes, err := elasticsearch.NewDefaultClient()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating the client: %s\\n\", err)\n\t}\n\n\tres, err := es.Info()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error getting the response: %s\\n\", err)\n\t}\n\tdefer res.Body.Close()\n\n\tlog.Print(es.Transport.(*elastictransport.Client).URLs())\n}\n\nfunc ExampleNewClient() {\n\tcfg := elasticsearch.Config{\n\t\tAddresses: []string{\n\t\t\t\"http://localhost:9200\",\n\t\t},\n\t\tUsername: \"foo\",\n\t\tPassword: \"bar\",\n\t\tTransport: &http.Transport{\n\t\t\tMaxIdleConnsPerHost:   10,\n\t\t\tResponseHeaderTimeout: time.Second,\n\t\t\tDialContext:           (&net.Dialer{Timeout: time.Second}).DialContext,\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\t},\n\t\t},\n\t}\n\n\tes, _ := elasticsearch.NewClient(cfg)\n\tlog.Print(es.Transport.(*elastictransport.Client).URLs())\n}\n\nfunc ExampleNewClient_logger() {\n\t// import \"github.com/elastic/go-elasticsearch/v8/elastictransport\"\n\n\t// Use one of the bundled loggers:\n\t//\n\t// * elastictransport.TextLogger\n\t// * elastictransport.ColorLogger\n\t// * elastictransport.CurlLogger\n\t// * elastictransport.JSONLogger\n\n\tcfg := elasticsearch.Config{\n\t\tLogger: &elastictransport.ColorLogger{Output: os.Stdout},\n\t}\n\n\telasticsearch.NewClient(cfg)\n}\n"
        },
        {
          "name": "elasticsearch_internal_test.go",
          "type": "blob",
          "size": 36.392578125,
          "content": "// Licensed to Elasticsearch B.V. under one or more contributor\n// license agreements. See the NOTICE file distributed with\n// this work for additional information regarding copyright\n// ownership. Elasticsearch B.V. licenses this file to you under\n// the Apache License, Version 2.0 (the \"License\"); you may\n// not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//go:build !integration\n// +build !integration\n\npackage elasticsearch\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"github.com/elastic/go-elasticsearch/v8/esapi\"\n\t\"github.com/elastic/go-elasticsearch/v8/typedapi/types\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/elastic/elastic-transport-go/v8/elastictransport\"\n)\n\nvar metaHeaderReValidation = regexp.MustCompile(`^[a-z]{1,}=[a-z0-9\\.\\-]{1,}(?:,[a-z]{1,}=[a-z0-9\\.\\-]+)*$`)\nvar called bool\n\ntype mockTransp struct {\n\tRoundTripFunc func(*http.Request) (*http.Response, error)\n}\n\nvar defaultRoundTripFunc = func(req *http.Request) (*http.Response, error) {\n\tresponse := &http.Response{Header: http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}}}\n\n\tif req.URL.Path == \"/\" {\n\t\tresponse.Body = ioutil.NopCloser(strings.NewReader(`{\n\t\t  \"version\" : {\n\t\t\t\"number\" : \"8.0.0-SNAPSHOT\",\n\t\t\t\"build_flavor\" : \"default\"\n\t\t  },\n\t\t  \"tagline\" : \"You Know, for Search\"\n\t\t}`))\n\t\tresponse.Header.Add(\"Content-Type\", \"application/json\")\n\t} else {\n\t\tcalled = true\n\t}\n\n\treturn response, nil\n}\n\nfunc (t *mockTransp) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif t.RoundTripFunc == nil {\n\t\treturn defaultRoundTripFunc(req)\n\t}\n\treturn t.RoundTripFunc(req)\n}\n\nfunc TestClientConfiguration(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"With empty\", func(t *testing.T) {\n\t\tc, err := NewDefaultClient()\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != defaultURL {\n\t\t\tt.Errorf(\"Unexpected URL, want=%s, got=%s\", defaultURL, u)\n\t\t}\n\t})\n\n\tt.Run(\"With URL from Addresses\", func(t *testing.T) {\n\t\tc, err := NewClient(Config{Addresses: []string{\"http://localhost:8080//\"}})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != \"http://localhost:8080\" {\n\t\t\tt.Errorf(\"Unexpected URL, want=http://localhost:8080, got=%s\", u)\n\t\t}\n\t})\n\n\tt.Run(\"With URL from environment\", func(t *testing.T) {\n\t\tos.Setenv(\"ELASTICSEARCH_URL\", \"http://example.com\")\n\t\tdefer func() { os.Setenv(\"ELASTICSEARCH_URL\", \"\") }()\n\n\t\tc, err := NewDefaultClient()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != \"http://example.com\" {\n\t\t\tt.Errorf(\"Unexpected URL, want=http://example.com, got=%s\", u)\n\t\t}\n\t})\n\n\tt.Run(\"With URL from environment and cfg.Addresses\", func(t *testing.T) {\n\t\tos.Setenv(\"ELASTICSEARCH_URL\", \"http://example.com\")\n\t\tdefer func() { os.Setenv(\"ELASTICSEARCH_URL\", \"\") }()\n\n\t\tc, err := NewClient(Config{Addresses: []string{\"http://localhost:8080//\"}})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != \"http://localhost:8080\" {\n\t\t\tt.Errorf(\"Unexpected URL, want=http://localhost:8080, got=%s\", u)\n\t\t}\n\t})\n\n\tt.Run(\"With URL from environment and cfg.CloudID\", func(t *testing.T) {\n\t\tos.Setenv(\"ELASTICSEARCH_URL\", \"http://example.com\")\n\t\tdefer func() { os.Setenv(\"ELASTICSEARCH_URL\", \"\") }()\n\n\t\tc, err := NewClient(Config{CloudID: \"foo:YmFyLmNsb3VkLmVzLmlvJGFiYzEyMyRkZWY0NTY=\"})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != \"https://abc123.bar.cloud.es.io\" {\n\t\t\tt.Errorf(\"Unexpected URL, want=https://abc123.bar.cloud.es.io, got=%s\", u)\n\t\t}\n\t})\n\n\tt.Run(\"With cfg.Addresses and cfg.CloudID\", func(t *testing.T) {\n\t\t_, err := NewClient(Config{Addresses: []string{\"http://localhost:8080//\"}, CloudID: \"foo:ABC=\"})\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error, got: %v\", err)\n\t\t}\n\t\tmatch, _ := regexp.MatchString(\"both .* are set\", err.Error())\n\t\tif !match {\n\t\t\tt.Errorf(\"Expected error when addresses from environment and configuration are used together, got: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"With CloudID\", func(t *testing.T) {\n\t\t// bar.cloud.es.io$abc123$def456\n\t\tc, err := NewClient(Config{CloudID: \"foo:YmFyLmNsb3VkLmVzLmlvJGFiYzEyMyRkZWY0NTY=\"})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tu := c.Transport.(*elastictransport.Client).URLs()[0].String()\n\n\t\tif u != \"https://abc123.bar.cloud.es.io\" {\n\t\t\tt.Errorf(\"Unexpected URL, want=https://abc123.bar.cloud.es.io, got=%s\", u)\n\t\t}\n\t})\n\n\tt.Run(\"With invalid CloudID\", func(t *testing.T) {\n\t\tvar err error\n\n\t\t_, err = NewClient(Config{CloudID: \"foo:ZZZ===\"})\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for CloudID, got: %v\", err)\n\t\t}\n\n\t\t_, err = NewClient(Config{CloudID: \"foo:Zm9v\"})\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for CloudID, got: %v\", err)\n\t\t}\n\n\t\t_, err = NewClient(Config{CloudID: \"foo:\"})\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for CloudID, got: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"With invalid URL\", func(t *testing.T) {\n\t\tu := \":foo\"\n\t\t_, err := NewClient(Config{Addresses: []string{u}})\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for URL %q, got %v\", u, err)\n\t\t}\n\t})\n\n\tt.Run(\"With invalid URL from environment\", func(t *testing.T) {\n\t\tos.Setenv(\"ELASTICSEARCH_URL\", \":foobar\")\n\t\tdefer func() { os.Setenv(\"ELASTICSEARCH_URL\", \"\") }()\n\n\t\tc, err := NewDefaultClient()\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error, got: %+v\", c)\n\t\t}\n\t})\n}\n\nfunc TestClientInterface(t *testing.T) {\n\tt.Run(\"Transport\", func(t *testing.T) {\n\t\tc, err := NewClient(Config{Transport: &mockTransp{}})\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tif called != false { // megacheck ignore\n\t\t\tt.Errorf(\"Unexpected call to transport by client\")\n\t\t}\n\n\t\tc.Perform(&http.Request{URL: &url.URL{}, Header: make(http.Header)}) // errcheck ignore\n\n\t\tif called != true { // megacheck ignore\n\t\t\tt.Errorf(\"Expected client to call transport\")\n\t\t}\n\t})\n}\n\nfunc TestAddrsToURLs(t *testing.T) {\n\ttt := []struct {\n\t\tname  string\n\t\taddrs []string\n\t\turls  []*url.URL\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"valid\",\n\t\t\taddrs: []string{\n\t\t\t\t\"http://example.com\",\n\t\t\t\t\"https://example.com\",\n\t\t\t\t\"http://192.168.255.255\",\n\t\t\t\t\"http://example.com:8080\",\n\t\t\t},\n\t\t\turls: []*url.URL{\n\t\t\t\t{Scheme: \"http\", Host: \"example.com\"},\n\t\t\t\t{Scheme: \"https\", Host: \"example.com\"},\n\t\t\t\t{Scheme: \"http\", Host: \"192.168.255.255\"},\n\t\t\t\t{Scheme: \"http\", Host: \"example.com:8080\"},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"trim trailing slash\",\n\t\t\taddrs: []string{\"http://example.com/\", \"http://example.com//\"},\n\t\t\turls: []*url.URL{\n\t\t\t\t{Scheme: \"http\", Host: \"example.com\", Path: \"\"},\n\t\t\t\t{Scheme: \"http\", Host: \"example.com\", Path: \"\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"keep suffix\",\n\t\t\taddrs: []string{\"http://example.com/foo\"},\n\t\t\turls:  []*url.URL{{Scheme: \"http\", Host: \"example.com\", Path: \"/foo\"}},\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid url\",\n\t\t\taddrs: []string{\"://invalid.com\"},\n\t\t\turls:  nil,\n\t\t\terr:   errors.New(\"missing protocol scheme\"),\n\t\t},\n\t}\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tres, err := addrsToURLs(tc.addrs)\n\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got: %v\", err)\n\t\t\t\t}\n\t\t\t\tmatch, _ := regexp.MatchString(tc.err.Error(), err.Error())\n\t\t\t\tif !match {\n\t\t\t\t\tt.Errorf(\"Expected err [%s] to match: %s\", err.Error(), tc.err.Error())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor i := range tc.urls {\n\t\t\t\tif res[i].Scheme != tc.urls[i].Scheme {\n\t\t\t\t\tt.Errorf(\"%s: Unexpected scheme, want=%s, got=%s\", tc.name, tc.urls[i].Scheme, res[i].Scheme)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := range tc.urls {\n\t\t\t\tif res[i].Host != tc.urls[i].Host {\n\t\t\t\t\tt.Errorf(\"%s: Unexpected host, want=%s, got=%s\", tc.name, tc.urls[i].Host, res[i].Host)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := range tc.urls {\n\t\t\t\tif res[i].Path != tc.urls[i].Path {\n\t\t\t\t\tt.Errorf(\"%s: Unexpected path, want=%s, got=%s\", tc.name, tc.urls[i].Path, res[i].Path)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCloudID(t *testing.T) {\n\tt.Run(\"Parse\", func(t *testing.T) {\n\t\tvar testdata = []struct {\n\t\t\tin  string\n\t\t\tout string\n\t\t}{\n\t\t\t{\n\t\t\t\tin:  \"name:\" + base64.StdEncoding.EncodeToString([]byte(\"host$es_uuid$kibana_uuid\")),\n\t\t\t\tout: \"https://es_uuid.host\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tin:  \"name:\" + base64.StdEncoding.EncodeToString([]byte(\"host:9243$es_uuid$kibana_uuid\")),\n\t\t\t\tout: \"https://es_uuid.host:9243\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tin:  \"name:\" + base64.StdEncoding.EncodeToString([]byte(\"host$es_uuid$\")),\n\t\t\t\tout: \"https://es_uuid.host\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tin:  \"name:\" + base64.StdEncoding.EncodeToString([]byte(\"host$es_uuid\")),\n\t\t\t\tout: \"https://es_uuid.host\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range testdata {\n\t\t\tactual, err := addrFromCloudID(tt.in)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif actual != tt.out {\n\t\t\t\tt.Errorf(\"Unexpected output, want=%q, got=%q\", tt.out, actual)\n\t\t\t}\n\t\t}\n\n\t})\n\n\tt.Run(\"Invalid format\", func(t *testing.T) {\n\t\tinput := \"foobar\"\n\t\t_, err := addrFromCloudID(input)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for input %q, got %v\", input, err)\n\t\t}\n\t\tmatch, _ := regexp.MatchString(\"unexpected format\", err.Error())\n\t\tif !match {\n\t\t\tt.Errorf(\"Unexpected error string: %s\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Invalid base64 value\", func(t *testing.T) {\n\t\tinput := \"foobar:xxxxx\"\n\t\t_, err := addrFromCloudID(input)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for input %q, got %v\", input, err)\n\t\t}\n\t\tmatch, _ := regexp.MatchString(\"illegal base64 data\", err.Error())\n\t\tif !match {\n\t\t\tt.Errorf(\"Unexpected error string: %s\", err)\n\t\t}\n\t})\n}\n\nfunc TestVersion(t *testing.T) {\n\tif Version == \"\" {\n\t\tt.Error(\"Version is empty\")\n\t}\n}\n\nfunc TestClientMetrics(t *testing.T) {\n\tc, _ := NewClient(Config{EnableMetrics: true})\n\n\tm, err := c.Metrics()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tif m.Requests != 0 {\n\t\tt.Errorf(\"Unexpected output: %s\", m)\n\t}\n}\n\nfunc TestResponseCheckOnly(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tresponse   *http.Response\n\t\trequestErr error\n\t\twantErr    bool\n\t}{\n\t\t{\n\t\t\tname: \"Valid answer with header\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tHeader: http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\tBody:   ioutil.NopCloser(strings.NewReader(\"{}\")),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid answer without header\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"{}\")),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid answer with header and response check\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tHeader: http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\tBody:   ioutil.NopCloser(strings.NewReader(\"{}\")),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid answer without header and response check\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"{}\")),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Request failed\",\n\t\t\tresponse:   nil,\n\t\t\trequestErr: errors.New(\"request failed\"),\n\t\t\twantErr:    true,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid request, 500 response\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t},\n\t\t\trequestErr: nil,\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid request, 404 response\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusNotFound,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t},\n\t\t\trequestErr: nil,\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid request, 403 response\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusForbidden,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t},\n\t\t\trequestErr: nil,\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid request, 401 response\",\n\t\t\tresponse: &http.Response{\n\t\t\t\tStatusCode: http.StatusUnauthorized,\n\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t},\n\t\t\trequestErr: nil,\n\t\t\twantErr:    false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc, _ := NewClient(Config{\n\t\t\t\tTransport: &mockTransp{RoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\treturn tt.response, tt.requestErr\n\t\t\t\t}},\n\t\t\t})\n\t\t\t_, err := c.Cat.Indices()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Unexpected error, got %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProductCheckError(t *testing.T) {\n\tvar requestPaths []string\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestPaths = append(requestPaths, r.URL.Path)\n\t\tif len(requestPaths) == 1 {\n\t\t\t// Simulate transient error from a proxy on the first request.\n\t\t\t// This must not be cached by the client.\n\t\t\tw.WriteHeader(http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"X-Elastic-Product\", \"Elasticsearch\")\n\t\tw.Write([]byte(\"{}\"))\n\t}))\n\tdefer server.Close()\n\n\tc, _ := NewClient(Config{Addresses: []string{server.URL}, DisableRetry: true})\n\tif _, err := c.Cat.Indices(); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif c.productCheckSuccess {\n\t\tt.Fatalf(\"product check should be invalid, got %v\", c.productCheckSuccess)\n\t}\n\tif _, err := c.Cat.Indices(); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif n := len(requestPaths); n != 2 {\n\t\tt.Fatalf(\"expected 2 requests, got %d\", n)\n\t}\n\tif !reflect.DeepEqual(requestPaths, []string{\"/_cat/indices\", \"/_cat/indices\"}) {\n\t\tt.Fatalf(\"unexpected request paths: %s\", requestPaths)\n\t}\n\tif !c.productCheckSuccess {\n\t\tt.Fatalf(\"product check should be valid, got : %v\", c.productCheckSuccess)\n\t}\n}\n\nfunc TestFingerprint(t *testing.T) {\n\tbody := []byte(`{\"body\": true\"}\"`)\n\tcert, err := tls.X509KeyPair([]byte(`-----BEGIN CERTIFICATE-----\nMIIDYjCCAkqgAwIBAgIVAIClHav09e9XGWJrnshywAjUHTnXMA0GCSqGSIb3DQEB\nCwUAMDQxMjAwBgNVBAMTKUVsYXN0aWMgQ2VydGlmaWNhdGUgVG9vbCBBdXRvZ2Vu\nZXJhdGVkIENBMB4XDTIzMDMyODE3MDIzOVoXDTI2MDMyNzE3MDIzOVowEzERMA8G\nA1UEAxMIaW5zdGFuY2UwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCV\n+t5/g6u2r3awCtzqp17KG0hRxzkVoJoF8DYzVh+Rv9ymxQW0C/U8dQihAjkZHaIA\nn49lSyNLkwWtmqQgPcimV4d6XuTYx2ahDixXYtjmoOSwH5dRtovKPCNKDPkUj9Vq\nNwMW0uB1VxniMKI4DnYFqBgHL9kQKhQqvas6Gx0X6ptGRCLYCtVxeFcau6nnkZJt\nurb+HNV5waOh0uTmsqnnslK3NjCQ/f030vPKxM5fOqOU5ajUHpZFJ6ZFmS32074H\nl+mZoRT/GtbnVtIg+CJXsWThF3/L4iBImv+rkY9MKX5fyMLJgmIJG68S90IQGR8c\nZ2lZYzC0J7zjMsYlODbDAgMBAAGjgYswgYgwHQYDVR0OBBYEFIDIcECn3AVHc3jk\nMpQ4r7Kc3WCsMB8GA1UdIwQYMBaAFJYCWKn16g+acbing4Vl45QGUBs0MDsGA1Ud\nEQQ0MDKCCWxvY2FsaG9zdIIIaW5zdGFuY2WHBH8AAAGHEAAAAAAAAAAAAAAAAAAA\nAAGCA2VzMTAJBgNVHRMEAjAAMA0GCSqGSIb3DQEBCwUAA4IBAQBtX3RQ5ATpfORM\nlrnhaUPGOWkjnb3p3BrdAWUaWoh136QhaXqxKiALQQhTtTerkXOcuquy9MmAyYvS\n9fDdGvLCAO8pPCXjnzonCHerCLGdS7f/eqvSFWCdy7LPHzTAFYfVWVvbZed+83TL\nbDY63AMwIexj34vJEStMapuFwWx05fstE8qZWIbYCL87sF5H/MRhzlz3ScAhQ1N7\ntODH7zvLzSxFGGEzCIKZ0iPFKbd3Y0wE6SptDSKhOqlnC8kkNeI2GjWsqVfHKsoF\npDFmri7IfOucuvalXJ6xiHPr9RDbuxEXs0u8mteT5nFQo7EaEGdHpg1pNGbfBOzP\nlmj/dRS9\n-----END CERTIFICATE-----`), []byte(`-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAlfref4Ortq92sArc6qdeyhtIUcc5FaCaBfA2M1Yfkb/cpsUF\ntAv1PHUIoQI5GR2iAJ+PZUsjS5MFrZqkID3IpleHel7k2MdmoQ4sV2LY5qDksB+X\nUbaLyjwjSgz5FI/VajcDFtLgdVcZ4jCiOA52BagYBy/ZECoUKr2rOhsdF+qbRkQi\n2ArVcXhXGrup55GSbbq2/hzVecGjodLk5rKp57JStzYwkP39N9LzysTOXzqjlOWo\n1B6WRSemRZkt9tO+B5fpmaEU/xrW51bSIPgiV7Fk4Rd/y+IgSJr/q5GPTCl+X8jC\nyYJiCRuvEvdCEBkfHGdpWWMwtCe84zLGJTg2wwIDAQABAoIBAAEP7HYNNnDWdYMD\n+WAtYM12X/W5s/wUP94juaBI4u4iZH2EZodlixEdZUCTXgq43WsDUhxX05s7cE+p\nH5DuSCHtoo2WHvGKAposwRDm2f3YVWQ2Xyb2ahNt69LYHHWrO+XQ60YYTa3r8Gn3\n7dFR3I016/jyn5DeEVaglvS1dfj2UG4ybR4KkMfcKd94X0rKvz3wzAhHIh+hwMtv\nsVk7V4vSnKf2mJXwIVECTolnEJEkCjWjjymgUJYKT8yN7JnAsHRcvMa6kWwIGrLp\noQCEaJwYM6ynCRS989pLt3vA2iu5VkYhiHXJ9Ds/5b5yzhzmj+ymzKbFKrrUUrmn\n+2Jp1K0CgYEAw8BchALsD/+JuoXjinA14MH7PZjIsXyhtPk+c4pk42iMNyg1J8XF\nY/ITepLYsl2bZqQI1jOJdDqsTwIsva9r749lsmkYI3VOxhi7+qBK0sThR66C87lX\niU2QpnZ9NloC6ort4a3MEvZ/gRQcXdBrNlNoza2p7PHAVDTnsdSrNKUCgYEAxCQV\nuo85oZyfnMufn/gcI9IeYOgiB0tO3a8cAFX2wQW1y935t6Z13ApUQc4EnCOH7ZBc\ntd5kT+xGdRWnfPZ38FM1dd5MBdGE69s3q8pJDUExSgNLqaF6/5bD32qui66L3ugu\neMjxrzqJsc2uQTPCs18SGsyRmf54DpY8HglOmUcCgYAGRDgx+a347SNJl1OrcOAo\nq80RMbzrAaRjmL8JD9se9I/YjC73cPtasbsx51WMkDaTWJj30nqJ//7YIKeyAtWf\nu6Vzyq19JRo6eTw7T7pVePwFQW7rwnks6hDBY3WqscL6IyxuVxP7X2zBgxVNY4ir\nGox2WSLhdPPFPlRUewxoCQKBgAJvqE1u5fpZ5ame5dao0ECppXLyrymEB/C88g4X\nAz+WgJGNqkJbsO8QuccvdeMylcefmWcw4fIULzPZFwF4VjkH74wNPMh9t7buPBzI\nIGwnuSMAM3ph5RMzni8yNgTKIDaej6U0abwRcBBjS5zHtc1giusGS3CsNnWH7Cs7\nVlyVAoGBAK+prq9t9x3tC3NfCZH8/Wfs/X0T1qm11RiL5+tOhmbguWAqSSBy8OjX\nYh8AOXrFuMGldcaTXxMeiKvI2cyybnls1MFsPoeV/fSMJbex7whdeJeTi66NOSKr\noftUHvkHS0Vv/LicMEOufFGslb4T9aPJ7oyhoSlz9CfAutDWk/q/\n-----END RSA PRIVATE KEY-----`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Elastic-Product\", \"Elasticsearch\")\n\t\tw.Write(body)\n\t}))\n\tserver.TLS = new(tls.Config)\n\tserver.TLS.Certificates = []tls.Certificate{cert}\n\tserver.StartTLS()\n\n\tdefer server.Close()\n\n\tconfig := Config{\n\t\tAddresses:    []string{server.URL},\n\t\tDisableRetry: true,\n\t}\n\n\t// Without certificate and authority, client should fail on TLS\n\tclient, _ := NewClient(config)\n\t_, err = client.Info()\n\n\tif errors.Unwrap(err).Error() != `x509: “instance” certificate is not standards compliant` {\n\t\tif ok := errors.As(err, &x509.UnknownAuthorityError{}); !ok {\n\t\t\tt.Fatalf(\"Uknown error, expected UnknownAuthorityError, got: %s\", err)\n\t\t}\n\t}\n\n\t// We add the fingerprint corresponding to testcert.LocalhostCert\n\t//\n\tconfig.CertificateFingerprint = \"1DBF91CA60E9B94E89582396C2C825466F4C449FAFB7BCA29157EE5D61D5C171\"\n\tclient, _ = NewClient(config)\n\tres, err := client.Info()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer res.Body.Close()\n\n\tdata, _ := ioutil.ReadAll(res.Body)\n\tif !bytes.Equal(data, body) {\n\t\tt.Fatalf(\"unexpected payload returned: expected: %s, got: %s\", body, data)\n\t}\n}\n\nfunc TestCompatibilityHeader(t *testing.T) {\n\ttests := []struct {\n\t\tname                string\n\t\tenvVar              bool\n\t\tconfigVar           bool\n\t\tcompatibilityHeader bool\n\t\tbodyPresent         bool\n\t\texpectsHeader       []string\n\t}{\n\t\t{\n\t\t\tname:                \"Compatibility header disabled\",\n\t\t\tcompatibilityHeader: false,\n\t\t\tbodyPresent:         false,\n\t\t\tenvVar:              false,\n\t\t\tconfigVar:           false,\n\t\t\texpectsHeader:       []string{\"application/json\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"Compatibility header enabled with env var\",\n\t\t\tcompatibilityHeader: true,\n\t\t\tbodyPresent:         false,\n\t\t\tenvVar:              true,\n\t\t\tconfigVar:           false,\n\t\t\texpectsHeader:       []string{\"application/vnd.elasticsearch+json;compatible-with=8\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"Compatibility header enabled with body with env var\",\n\t\t\tcompatibilityHeader: true,\n\t\t\tbodyPresent:         true,\n\t\t\tenvVar:              true,\n\t\t\tconfigVar:           false,\n\t\t\texpectsHeader:       []string{\"application/vnd.elasticsearch+json;compatible-with=8\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"Compatibility header enabled in conf\",\n\t\t\tcompatibilityHeader: true,\n\t\t\tbodyPresent:         false,\n\t\t\tenvVar:              false,\n\t\t\tconfigVar:           true,\n\t\t\texpectsHeader:       []string{\"application/vnd.elasticsearch+json;compatible-with=8\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"Compatibility header enabled with body in conf\",\n\t\t\tcompatibilityHeader: true,\n\t\t\tbodyPresent:         true,\n\t\t\tenvVar:              false,\n\t\t\tconfigVar:           true,\n\t\t\texpectsHeader:       []string{\"application/vnd.elasticsearch+json;compatible-with=8\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Setenv(esCompatHeader, strconv.FormatBool(test.compatibilityHeader))\n\n\t\t\tc, _ := NewClient(Config{\n\t\t\t\tEnableCompatibilityMode: test.configVar,\n\t\t\t\tAddresses:               []string{},\n\t\t\t\tTransport: &mockTransp{\n\t\t\t\t\tRoundTripFunc: func(req *http.Request) (*http.Response, error) {\n\t\t\t\t\t\tif test.compatibilityHeader {\n\t\t\t\t\t\t\tif !reflect.DeepEqual(req.Header[\"Accept\"], test.expectsHeader) {\n\t\t\t\t\t\t\t\tt.Errorf(\"Compatibility header enabled but header is, not in request headers, got: %s, want: %s\", req.Header[\"Accept\"], test.expectsHeader)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif test.bodyPresent {\n\t\t\t\t\t\t\t\tif !reflect.DeepEqual(req.Header[\"Content-Type\"], test.expectsHeader) {\n\t\t\t\t\t\t\t\t\tt.Errorf(\"Compatibility header with Body enabled, not in request headers, got: %s, want: %s\", req.Header[\"Content-Type\"], test.expectsHeader)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif reflect.DeepEqual(req.Header[\"Content-Type\"], test.expectsHeader) {\n\t\t\t\t\t\t\t\t\tt.Errorf(\"Compatibility header if Content-Type shouldn't be set with an empty body\")\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\t\tStatus:     \"MOCK\",\n\t\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"{}\")),\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treq := &http.Request{URL: &url.URL{}, Header: make(http.Header)}\n\t\t\tif test.bodyPresent {\n\t\t\t\treq.Body = ioutil.NopCloser(strings.NewReader(\"{}\"))\n\t\t\t}\n\n\t\t\t_, _ = c.Perform(req)\n\t\t})\n\t}\n}\n\nfunc TestBuildStrippedVersion(t *testing.T) {\n\ttype args struct {\n\t\tversion string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"Standard Go version\",\n\t\t\targs: args{version: \"go1.16\"},\n\t\t\twant: \"1.16\",\n\t\t},\n\t\t{\n\t\t\tname: \"Rc Go version\",\n\t\t\targs: args{\n\t\t\t\tversion: \"go1.16rc1\",\n\t\t\t},\n\t\t\twant: \"1.16p\",\n\t\t},\n\t\t{\n\t\t\tname: \"Beta Go version (go1.16beta1 example)\",\n\t\t\targs: args{\n\t\t\t\tversion: \"devel +2ff33f5e44 Thu Dec 17 16:03:19 2020 +0000\",\n\t\t\t},\n\t\t\twant: \"0.0p\",\n\t\t},\n\t\t{\n\t\t\tname: \"Random mostly good Go version\",\n\t\t\targs: args{\n\t\t\t\tversion: \"1.16\",\n\t\t\t},\n\t\t\twant: \"1.16\",\n\t\t},\n\t\t{\n\t\t\tname: \"Client package version\",\n\t\t\targs: args{\n\t\t\t\tversion: \"8.0.0\",\n\t\t\t},\n\t\t\twant: \"8.0.0\",\n\t\t},\n\t\t{\n\t\t\tname: \"Client pre release version\",\n\t\t\targs: args{\n\t\t\t\tversion: \"8.0.0-SNAPSHOT\",\n\t\t\t},\n\t\t\twant: \"8.0.0p\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := buildStrippedVersion(tt.args.version); got != tt.want {\n\t\t\t\tt.Errorf(\"buildStrippedVersion() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMetaHeader(t *testing.T) {\n\tt.Run(\"MetaHeader with elastictransport\", func(t *testing.T) {\n\t\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\t\tTransport: &mockTransp{\n\t\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\th := request.Header.Get(HeaderClientMeta)\n\t\t\t\t\tif !metaHeaderReValidation.MatchString(h) {\n\t\t\t\t\t\tt.Errorf(\"expected client metaheader to validate regexp, got: %s\", h)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tc, _ := NewDefaultClient()\n\t\tc.Transport = tp\n\n\t\t_, _ = c.Info()\n\t})\n\n\tt.Run(\"Metaheader with typedclient\", func(t *testing.T) {\n\t\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\t\tTransport: &mockTransp{\n\t\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\th := request.Header.Get(HeaderClientMeta)\n\t\t\t\t\tif !metaHeaderReValidation.MatchString(h) {\n\t\t\t\t\t\tt.Errorf(\"expected client metaheader to validate regexp, got: %s\", h)\n\t\t\t\t\t}\n\t\t\t\t\tif !strings.Contains(h, \"hl=1\") {\n\t\t\t\t\t\tt.Errorf(\"invalid metaheader, should contain hl=1, got: %s\", h)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tc, _ := NewTypedClient(Config{})\n\t\tc.Transport = tp\n\n\t\t_, _ = c.Info().Do(nil)\n\t})\n}\n\nfunc TestNewTypedClient(t *testing.T) {\n\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\tTransport: &mockTransp{\n\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\th := request.Header.Get(HeaderClientMeta)\n\t\t\t\tif !metaHeaderReValidation.MatchString(h) {\n\t\t\t\t\tt.Errorf(\"expected client metaheader to validate regexp, got: %s\", h)\n\t\t\t\t}\n\n\t\t\t\treturn &http.Response{\n\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\tBody: ioutil.NopCloser(strings.NewReader(`{\n\t\t\t\t\t  \"version\" : {\n\t\t\t\t\t\t\"number\" : \"8.0.0-SNAPSHOT\",\n\t\t\t\t\t\t\"build_flavor\" : \"default\"\n\t\t\t\t\t  },\n\t\t\t\t\t  \"tagline\" : \"You Know, for Search\"\n\t\t\t\t\t}`)),\n\t\t\t\t}, nil\n\t\t\t},\n\t\t},\n\t})\n\n\tc, _ := NewTypedClient(Config{})\n\tc.Transport = tp\n\n\tres, err := c.Info().Do(context.Background())\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif res.Tagline != \"You Know, for Search\" {\n\t\tt.Fatal(\"unexpected tagline\")\n\t}\n\n\t_, err = NewClient(Config{})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\nfunc TestContentTypeOverride(t *testing.T) {\n\tt.Run(\"default JSON Content-Type\", func(t *testing.T) {\n\t\tcontentType := \"application/json\"\n\n\t\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\t\tTransport: &mockTransp{\n\t\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\th := request.Header.Get(\"Content-Type\")\n\t\t\t\t\tif h != contentType {\n\t\t\t\t\t\tt.Fatalf(\"unexpected content-type, wanted %s, got: %s\", contentType, h)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tc, _ := NewDefaultClient()\n\t\tc.Transport = tp\n\n\t\t_, _ = c.Search(c.Search.WithBody(strings.NewReader(\"\")))\n\t})\n\tt.Run(\"overriden CBOR Content-Type functional options style\", func(t *testing.T) {\n\t\tcontentType := \"application/cbor\"\n\n\t\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\t\tTransport: &mockTransp{\n\t\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\th := request.Header.Get(\"Content-Type\")\n\t\t\t\t\tif h != contentType {\n\t\t\t\t\t\tt.Fatalf(\"unexpected content-type, wanted %s, got: %s\", contentType, h)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tc, _ := NewDefaultClient()\n\t\tc.Transport = tp\n\n\t\t_, _ = c.Search(\n\t\t\tc.Search.WithHeader(map[string]string{\n\t\t\t\t\"Content-Type\": contentType,\n\t\t\t}),\n\t\t\tc.Search.WithBody(strings.NewReader(\"\")),\n\t\t)\n\t})\n\tt.Run(\"overriden CBOR Content-Type direct call style\", func(t *testing.T) {\n\t\tcontentType := \"application/cbor\"\n\n\t\ttp, _ := elastictransport.New(elastictransport.Config{\n\t\t\tURLs: []*url.URL{{Scheme: \"http\", Host: \"foo\"}},\n\t\t\tTransport: &mockTransp{\n\t\t\t\tRoundTripFunc: func(request *http.Request) (*http.Response, error) {\n\t\t\t\t\th := request.Header.Get(\"Content-Type\")\n\t\t\t\t\tif h != contentType {\n\t\t\t\t\t\tt.Fatalf(\"unexpected content-type, wanted %s, got: %s\", contentType, h)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\tHeader:     http.Header{\"X-Elastic-Product\": []string{\"Elasticsearch\"}},\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tStatus:     \"OK\",\n\t\t\t\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tc, _ := NewDefaultClient()\n\t\tc.Transport = tp\n\n\t\tsearch := esapi.SearchRequest{}\n\t\tsearch.Body = strings.NewReader(\"\")\n\t\tsearch.Header = make(map[string][]string)\n\t\tsearch.Header.Set(\"Content-Type\", contentType)\n\t\tsearch.Do(context.Background(), tp)\n\t})\n}\n\ntype FakeInstrumentation struct {\n\tError error\n\n\tName                string\n\tClosed              bool\n\tClusterID           string\n\tNodeName            string\n\tPathParts           map[string]string\n\tPersistQuery        bool\n\tQueryEndpoint       string\n\tQuery               string\n\tBeforeRequestFunc   func(r *http.Request, endpoint string) bool\n\tBeforeRequestResult bool\n\tAfterRequestFunc    func(r *http.Request, system, endpoint string) bool\n\tAfterRequestResult  bool\n}\n\nfunc NewFakeInstrumentation(recordQuery bool) *FakeInstrumentation {\n\treturn &FakeInstrumentation{\n\t\tPersistQuery: recordQuery,\n\t\tPathParts:    make(map[string]string),\n\t}\n}\n\nfunc (c *FakeInstrumentation) Start(ctx context.Context, name string) context.Context {\n\tc.Name = name\n\treturn ctx\n}\n\nfunc (c *FakeInstrumentation) Close(ctx context.Context) {\n\tc.Closed = true\n}\n\nfunc (c *FakeInstrumentation) RecordError(ctx context.Context, err error) {\n\tc.Error = err\n}\n\nfunc (c *FakeInstrumentation) AfterResponse(ctx context.Context, res *http.Response) {\n\tif id := res.Header.Get(\"X-Found-Handling-Cluster\"); id != \"\" {\n\t\tc.ClusterID = id\n\t}\n\tif name := res.Header.Get(\"X-Found-Handling-Instance\"); name != \"\" {\n\t\tc.NodeName = name\n\t}\n}\n\nfunc (c *FakeInstrumentation) RecordPathPart(ctx context.Context, pathPart, value string) {\n\tc.PathParts[pathPart] = value\n}\n\nfunc (c *FakeInstrumentation) RecordRequestBody(ctx context.Context, endpoint string, query io.Reader) io.ReadCloser {\n\tc.QueryEndpoint = endpoint\n\tif !c.PersistQuery {\n\t\treturn nil\n\t}\n\n\tbuf := bytes.Buffer{}\n\tbuf.ReadFrom(query)\n\tc.Query = buf.String()\n\treturn io.NopCloser(&buf)\n}\n\nfunc (c *FakeInstrumentation) BeforeRequest(req *http.Request, endpoint string) {\n\tif c.BeforeRequestFunc != nil {\n\t\tc.BeforeRequestResult = c.BeforeRequestFunc(req, endpoint)\n\t}\n}\n\nfunc (c *FakeInstrumentation) AfterRequest(req *http.Request, system, endpoint string) {\n\tif c.AfterRequestFunc != nil {\n\t\tc.AfterRequestResult = c.AfterRequestFunc(req, system, endpoint)\n\t}\n}\n\nfunc TestInstrumentation(t *testing.T) {\n\tsuccessTp := func(request *http.Request) (*http.Response, error) {\n\t\th := http.Header{}\n\t\th.Add(\"X-Elastic-Product\", \"Elasticsearch\")\n\t\th.Add(\"X-Found-Handling-Cluster\", \"foo-bar-cluster-id\")\n\t\th.Add(\"X-Found-Handling-Instance\", \"0123456789\")\n\t\treturn &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     h,\n\t\t\tBody:       io.NopCloser(strings.NewReader(`{}`)),\n\t\t}, nil\n\t}\n\n\terrorTp := func(request *http.Request) (*http.Response, error) {\n\t\th := http.Header{}\n\t\th.Add(\"X-Elastic-Product\", \"Elasticsearch\")\n\t\th.Add(\"X-Found-Handling-Cluster\", \"foo-bar-cluster-id\")\n\t\th.Add(\"X-Found-Handling-Instance\", \"0123456789\")\n\t\treturn &http.Response{\n\t\t\tStatusCode: http.StatusNotFound,\n\t\t\tHeader:     h,\n\t\t\tBody: io.NopCloser(strings.NewReader(`{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"index_not_found_exception\",\n        \"reason\": \"no such index [foo]\",\n        \"resource.type\": \"index_or_alias\",\n        \"resource.id\": \"foo\",\n        \"index_uuid\": \"_na_\",\n        \"index\": \"foo\"\n      }\n    ],\n    \"type\": \"index_not_found_exception\",\n    \"reason\": \"no such index [foo]\",\n    \"resource.type\": \"index_or_alias\",\n    \"resource.id\": \"foo\",\n    \"index_uuid\": \"_na_\",\n    \"index\": \"foo\"\n  },\n  \"status\": 404\n}`)),\n\t\t}, nil\n\t}\n\n\treason := \"index_not_found_exception\"\n\n\ttype args struct {\n\t\troundTripFunc   func(request *http.Request) (*http.Response, error)\n\t\tinstrumentation *FakeInstrumentation\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *FakeInstrumentation\n\t}{\n\t\t{\n\t\t\tname: \"with query\",\n\t\t\targs: args{\n\t\t\t\tsuccessTp,\n\t\t\t\tNewFakeInstrumentation(true),\n\t\t\t},\n\t\t\twant: &FakeInstrumentation{\n\t\t\t\tName:                \"search\",\n\t\t\t\tClosed:              true,\n\t\t\t\tClusterID:           \"foo-bar-cluster-id\",\n\t\t\t\tNodeName:            \"0123456789\",\n\t\t\t\tPathParts:           map[string]string{\"index\": \"foo\"},\n\t\t\t\tPersistQuery:        true,\n\t\t\t\tQueryEndpoint:       \"search\",\n\t\t\t\tQuery:               \"{\\\"query\\\":{\\\"match_all\\\":{}}}\",\n\t\t\t\tBeforeRequestResult: true,\n\t\t\t\tAfterRequestResult:  true,\n\t\t\t\tBeforeRequestFunc: func(r *http.Request, endpoint string) bool {\n\t\t\t\t\tif r != nil {\n\t\t\t\t\t\tif r.URL.Path != \"/foo/_search\" {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif r.Method != http.MethodPost {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\tAfterRequestFunc: func(r *http.Request, system, endpoint string) bool {\n\t\t\t\t\tif r != nil {\n\t\t\t\t\t\tif r.URL.Path != \"/foo/_search\" {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif r.Method != http.MethodPost {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"without query\",\n\t\t\targs: args{\n\t\t\t\tsuccessTp,\n\t\t\t\tNewFakeInstrumentation(false),\n\t\t\t},\n\t\t\twant: &FakeInstrumentation{\n\t\t\t\tName:                \"search\",\n\t\t\t\tClosed:              true,\n\t\t\t\tClusterID:           \"foo-bar-cluster-id\",\n\t\t\t\tNodeName:            \"0123456789\",\n\t\t\t\tPathParts:           map[string]string{\"index\": \"foo\"},\n\t\t\t\tPersistQuery:        true,\n\t\t\t\tQueryEndpoint:       \"search\",\n\t\t\t\tQuery:               \"\",\n\t\t\t\tBeforeRequestResult: true,\n\t\t\t\tAfterRequestResult:  true,\n\t\t\t\tBeforeRequestFunc:   func(r *http.Request, endpoint string) bool { return true },\n\t\t\t\tAfterRequestFunc:    func(r *http.Request, system, endpoint string) bool { return true },\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with error\",\n\t\t\targs: args{\n\t\t\t\terrorTp,\n\t\t\t\tNewFakeInstrumentation(false),\n\t\t\t},\n\t\t\twant: &FakeInstrumentation{\n\t\t\t\tName:                \"search\",\n\t\t\t\tClosed:              true,\n\t\t\t\tClusterID:           \"foo-bar-cluster-id\",\n\t\t\t\tNodeName:            \"0123456789\",\n\t\t\t\tPathParts:           map[string]string{\"index\": \"foo\"},\n\t\t\t\tPersistQuery:        true,\n\t\t\t\tQueryEndpoint:       \"search\",\n\t\t\t\tQuery:               \"\",\n\t\t\t\tBeforeRequestResult: true,\n\t\t\t\tAfterRequestResult:  true,\n\t\t\t\tBeforeRequestFunc:   func(r *http.Request, endpoint string) bool { return true },\n\t\t\t\tAfterRequestFunc:    func(r *http.Request, system, endpoint string) bool { return true },\n\t\t\t\tError:               &types.ElasticsearchError{Status: http.StatusNotFound, ErrorCause: types.ErrorCause{Type: reason}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Run(\"typed client\", func(t *testing.T) {\n\t\t\t\tinstrument := test.args.instrumentation\n\t\t\t\tinstrument.BeforeRequestFunc = test.want.BeforeRequestFunc\n\t\t\t\tinstrument.AfterRequestFunc = test.want.AfterRequestFunc\n\n\t\t\t\tes, _ := NewTypedClient(Config{\n\t\t\t\t\tTransport:       &mockTransp{RoundTripFunc: test.args.roundTripFunc},\n\t\t\t\t\tInstrumentation: instrument,\n\t\t\t\t})\n\t\t\t\tes.Search().\n\t\t\t\t\tIndex(\"foo\").\n\t\t\t\t\tQuery(&types.Query{\n\t\t\t\t\t\tMatchAll: types.NewMatchAllQuery(),\n\t\t\t\t\t}).\n\t\t\t\t\tDo(context.Background())\n\n\t\t\t\tif test.want.Error != nil {\n\t\t\t\t\tif !errors.Is(instrument.Error, test.want.Error) {\n\t\t\t\t\t\tt.Error(\"ploup\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif instrument.BeforeRequestResult != test.want.BeforeRequestResult ||\n\t\t\t\t\tinstrument.AfterRequestResult != test.want.AfterRequestResult ||\n\t\t\t\t\tinstrument.Name != test.want.Name ||\n\t\t\t\t\tinstrument.Query != test.want.Query ||\n\t\t\t\t\tinstrument.QueryEndpoint != test.want.QueryEndpoint ||\n\t\t\t\t\tinstrument.NodeName != test.want.NodeName ||\n\t\t\t\t\tinstrument.ClusterID != test.want.ClusterID ||\n\t\t\t\t\tinstrument.Closed == false {\n\t\t\t\t\tt.Errorf(\"instrument didn't record the expected values:\\ngot:  %#v\\nwant: %#v\", instrument, test.want)\n\t\t\t\t}\n\n\t\t\t\tif !reflect.DeepEqual(instrument.PathParts, test.want.PathParts) {\n\t\t\t\t\tt.Errorf(\"path parts not within expected values, got: %#v, want: %#v\", instrument.PathParts, test.want.PathParts)\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"low-level client\", func(t *testing.T) {\n\t\t\t\tinstrument := test.args.instrumentation\n\t\t\t\tinstrument.BeforeRequestFunc = test.want.BeforeRequestFunc\n\t\t\t\tinstrument.AfterRequestFunc = test.want.AfterRequestFunc\n\n\t\t\t\tes, _ := NewClient(Config{\n\t\t\t\t\tTransport:       &mockTransp{RoundTripFunc: test.args.roundTripFunc},\n\t\t\t\t\tInstrumentation: instrument,\n\t\t\t\t})\n\t\t\t\tes.Search(\n\t\t\t\t\tes.Search.WithIndex(\"foo\"),\n\t\t\t\t\tes.Search.WithBody(strings.NewReader(\"{\\\"query\\\":{\\\"match_all\\\":{}}}\")),\n\t\t\t\t\tes.Search.WithContext(context.Background()),\n\t\t\t\t)\n\n\t\t\t\tif test.want.Error != nil {\n\t\t\t\t\tif !errors.Is(instrument.Error, test.want.Error) {\n\t\t\t\t\t\tt.Error(\"ploup\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif instrument.BeforeRequestResult != test.want.BeforeRequestResult ||\n\t\t\t\t\tinstrument.AfterRequestResult != test.want.AfterRequestResult ||\n\t\t\t\t\tinstrument.Name != test.want.Name ||\n\t\t\t\t\tinstrument.Query != test.want.Query ||\n\t\t\t\t\tinstrument.QueryEndpoint != test.want.QueryEndpoint ||\n\t\t\t\t\tinstrument.NodeName != test.want.NodeName ||\n\t\t\t\t\tinstrument.ClusterID != test.want.ClusterID ||\n\t\t\t\t\tinstrument.Closed == false {\n\t\t\t\t\tt.Errorf(\"instrument didn't record the expected values:\\ngot:  %#v\\nwant: %#v\", instrument, test.want)\n\t\t\t\t}\n\n\t\t\t\tif !reflect.DeepEqual(instrument.PathParts, test.want.PathParts) {\n\t\t\t\t\tt.Errorf(\"path parts not within expected values, got: %#v, want: %#v\", instrument.PathParts, test.want.PathParts)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n}\n"
        },
        {
          "name": "esapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "esutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4072265625,
          "content": "module github.com/elastic/go-elasticsearch/v8\n\ngo 1.22\n\ntoolchain go1.22.0\n\nrequire (\n\tgithub.com/elastic/elastic-transport-go/v8 v8.6.0\n\tgo.opentelemetry.io/otel/trace v1.28.0\n)\n\nrequire (\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgo.opentelemetry.io/otel v1.28.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.28.0 // indirect\n\tgolang.org/x/sys v0.19.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.2666015625,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/elastic/elastic-transport-go/v8 v8.6.0 h1:Y2S/FBjx1LlCv5m6pWAF2kDJAHoSjSRSJCApolgfthA=\ngithub.com/elastic/elastic-transport-go/v8 v8.6.0/go.mod h1:YLHer5cj0csTzNFXoNQ8qhtGY1GTvSqPnKWKaqQE3Hk=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngo.opentelemetry.io/otel v1.28.0 h1:/SqNcYk+idO0CxKEUOtKQClMK/MimZihKYMruSMViUo=\ngo.opentelemetry.io/otel v1.28.0/go.mod h1:q68ijF8Fc8CnMHKyzqL6akLO46ePnjkgfIMIjUIX9z4=\ngo.opentelemetry.io/otel/metric v1.28.0 h1:f0HGvSl1KRAU1DLgLGFjrwVyismPlnuU6JD6bOeuA5Q=\ngo.opentelemetry.io/otel/metric v1.28.0/go.mod h1:Fb1eVBFZmLVTMb6PPohq3TO9IIhUisDsbJoL/+uQW4s=\ngo.opentelemetry.io/otel/sdk v1.21.0 h1:FTt8qirL1EysG6sTQRZ5TokkU8d0ugCj8htOgThZXQ8=\ngo.opentelemetry.io/otel/sdk v1.21.0/go.mod h1:Nna6Yv7PWTdgJHVRD9hIYywQBRx7pbox6nwBnZIxl/E=\ngo.opentelemetry.io/otel/trace v1.28.0 h1:GhQ9cUuQGmNDd5BTCP2dAvv75RdMxEfTmYejp+lkx9g=\ngo.opentelemetry.io/otel/trace v1.28.0/go.mod h1:jPyXzNPg6da9+38HEwElrQiHlVMTnVfM3/yv2OlIHaI=\ngolang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=\ngolang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "typedapi",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}