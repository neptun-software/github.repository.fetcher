{
  "metadata": {
    "timestamp": 1736567809636,
    "page": 395,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "x-motemen/gore",
      "stars": 5148,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": "/gore\n/goxz\n/CREDITS\n*.exe\n*.test\n*.out\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2216796875,
          "content": "FROM golang:1.19.4-alpine3.17\n\nRUN apk add --no-cache git make\nWORKDIR /go/src/github.com/x-motemen/gore/\nCOPY . .\nRUN make install\n\nRUN go install github.com/mdempsky/gocode@latest   # for code completion\n\nENTRYPOINT [\"gore\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 motemen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5,
          "content": "BIN := gore\nVERSION := $$(make -s show-version)\nVERSION_PATH := .\nCURRENT_REVISION = $(shell git rev-parse --short HEAD)\nBUILD_LDFLAGS = \"-s -w -X github.com/x-motemen/$(BIN)/cli.revision=$(CURRENT_REVISION)\"\nGOBIN ?= $(shell go env GOPATH)/bin\n\n.PHONY: all\nall: build\n\n.PHONY: build\nbuild:\n\tgo build -ldflags=$(BUILD_LDFLAGS) -o $(BIN) ./cmd/$(BIN)\n\n.PHONY: install\ninstall:\n\tgo install -ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n.PHONY: show-version\nshow-version: $(GOBIN)/gobump\n\t@gobump show -r \"$(VERSION_PATH)\"\n\n$(GOBIN)/gobump:\n\t@go install github.com/x-motemen/gobump/cmd/gobump@latest\n\n.PHONY: cross\ncross: $(GOBIN)/goxz CREDITS\n\tgoxz -n $(BIN) -pv=v$(VERSION) -build-ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n$(GOBIN)/goxz:\n\tgo install github.com/Songmu/goxz/cmd/goxz@latest\n\nCREDITS: $(GOBIN)/gocredits go.sum\n\tgo mod tidy\n\tgocredits -w .\n\n$(GOBIN)/gocredits:\n\tgo install github.com/Songmu/gocredits/cmd/gocredits@latest\n\n.PHONY: test\ntest: build\n\tgo test -v ./... # we don't use -race which increases much duration\n\n.PHONY: lint\nlint: $(GOBIN)/staticcheck\n\tgo vet ./...\n\tstaticcheck -checks all,-ST1000 ./...\n\n$(GOBIN)/staticcheck:\n\tgo install honnef.co/go/tools/cmd/staticcheck@latest\n\n.PHONY: clean\nclean:\n\trm -rf $(BIN) goxz CREDITS\n\tgo clean\n\n.PHONY: bump\nbump: $(GOBIN)/gobump\n\ttest -z \"$$(git status --porcelain || echo .)\"\n\ttest \"$$(git branch --show-current)\" = \"main\"\n\t@gobump up -w \"$(VERSION_PATH)\"\n\tgit commit -am \"bump up version to $(VERSION)\"\n\tgit tag \"v$(VERSION)\"\n\tgit push --atomic origin main tag \"v$(VERSION)\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.5244140625,
          "content": "# gore [![CI Status](https://github.com/x-motemen/gore/workflows/CI/badge.svg)](https://github.com/x-motemen/gore/actions)\n### Yet another Go REPL that works nicely. Featured with line editing, code completion, and more.\n\n![Screencast](doc/screencast.gif)\n\n(Screencast taken with [cho45/KeyCast](https://github.com/cho45/KeyCast))\n\n## Usage\n\n```sh\ngore\n```\nAfter a prompt is shown, enter any Go expressions/statements/functions or commands described below.\n\nTo quit the session, type `Ctrl-D` or use `:q` command.\n\n## Features\n\n- Line editing with history\n- Multi-line input\n- Package importing with completion\n- Evaluates any expressions, statements and function declarations\n- No \"evaluated but not used\" errors\n- Code completion (requires [gocode](https://github.com/mdempsky/gocode))\n- Showing documents\n- Auto-importing (`gore -autoimport`)\n\n## REPL Commands\n\nSome functionalities are provided as commands in the REPL:\n\n```\n:import <package path>  Import package\n:type <expr>            Print the type of expression\n:print                  Show current source\n:write [<filename>]     Write out current source to file\n:clear                  Clear the codes\n:doc <expr or pkg>      Show document\n:help                   List commands\n:quit                   Quit the session\n```\n\n## Installation\nThe gore command requires Go tool-chains on runtime, so standalone binary is not distributed.\n\n```sh\ngo install github.com/x-motemen/gore/cmd/gore@latest\n```\n\nMake sure `$GOPATH/bin` is in your `$PATH`.\n\nAlso recommended:\n\n```sh\ngo install github.com/mdempsky/gocode@latest   # for code completion\n```\n\nOr you can use Docker:\n\n```sh\ngit clone https://github.com/x-motemen/gore.git\ncd gore\ndocker build -t gore .\ndocker run -it --rm gore\n```\n\n## FAQ/Caveats\n\n- gore runs code using `go run` for each input. All the inputted lines are\n  evaluated again and again so you can't bind the evaluated time by\n  `time.Now()`, for example. If you don't like this behavior, you may want to use\n  [yaegi](https://github.com/containous/yaegi).\n- gore support Go modules. You can load local modules when you start gore at\n  the project directory. You don't need to `go get` to check the usage of a\n  remote repository, `:import github.com/...` will automatically download that\n  module. Also, you don't need to `go get` the pretty print module anymore. If\n  you want to load a local code from `$GOPATH`, you need to create the modules\n  file (`go mod init ...`) and then start gore at the project directory.\n\n## License\n\n[The MIT License](./LICENSE).\n\n## Author\n\nmotemen &lt;<motemen@gmail.com>&gt;\n"
        },
        {
          "name": "cli",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "command_name.go",
          "type": "blob",
          "size": 0.8076171875,
          "content": "package gore\n\nimport \"strings\"\n\ntype commandName string\n\nfunc (s commandName) String() string {\n\tvar b strings.Builder\n\tfor _, c := range s {\n\t\tif c != '[' && c != ']' {\n\t\t\tb.WriteRune(c)\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc (s commandName) matches(t string) bool {\n\tvar grouping bool\n\tfor i, j := 0, 0; j <= len(t); i, j = i+1, j+1 {\n\t\tif i >= len(s) {\n\t\t\treturn j == len(t)\n\t\t}\n\t\tif s[i] == '[' {\n\t\t\tgrouping = true\n\t\t\ti++\n\t\t}\n\t\tif j == len(t) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i] == ']' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] != t[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn grouping\n}\n\nfunc (s commandName) matchesPrefix(t string) bool {\n\tfor i, j := 0, 0; j < len(t); i, j = i+1, j+1 {\n\t\tif i >= len(s) {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == '[' {\n\t\t\ti++\n\t\t}\n\t\tif s[i] == ']' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] != t[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "command_name_test.go",
          "type": "blob",
          "size": 1.380859375,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCommandName(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tstr     string\n\t\ttarget  string\n\t\tmatches bool\n\t\tprefix  bool\n\t}{\n\t\t{\"foobar\", \"foobar\", \"foobarr\", false, false},\n\t\t{\"foobar\", \"foobar\", \"foobar\", true, true},\n\t\t{\"foobar\", \"foobar\", \"foo\", false, true},\n\t\t{\"foobar\", \"foobar\", \"\", false, true},\n\t\t{\"foo[bar]\", \"foobar\", \"foobarr\", false, false},\n\t\t{\"foo[bar]\", \"foobar\", \"foobar\", true, true},\n\t\t{\"foo[bar]\", \"foobar\", \"foob\", true, true},\n\t\t{\"foo[bar]\", \"foobar\", \"foo\", true, true},\n\t\t{\"foo[bar]\", \"foobar\", \"fo\", false, true},\n\t\t{\"foo[bar]\", \"foobar\", \"\", false, true},\n\t\t{\"foo[bar]\", \"foobar\", \"foo[bar]\", false, false},\n\t\t{\"foo[bar]\", \"foobar\", \"foobar]\", false, false},\n\t\t{\"foo[bar]\", \"foobar\", \"foo[]\", false, false},\n\t\t{\"foo[bar]\", \"foobar\", \"foo[\", false, false},\n\t\t{\"foo[bar]\", \"foobar\", \"[\", false, false},\n\t\t{\"[bar]\", \"bar\", \"foobar\", false, false},\n\t\t{\"[bar]\", \"bar\", \"bar\", true, true},\n\t\t{\"[bar]\", \"bar\", \"bra\", false, false},\n\t\t{\"[bar]\", \"bar\", \"ba\", true, true},\n\t\t{\"[bar]\", \"bar\", \"\", true, true},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name+\"/\"+tc.target, func(t *testing.T) {\n\t\t\tcn := commandName(tc.name)\n\t\t\tassert.Equal(t, tc.str, fmt.Sprint(cn))\n\t\t\tassert.Equal(t, tc.matches, cn.matches(tc.target))\n\t\t\tassert.Equal(t, tc.prefix, cn.matchesPrefix(tc.target))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "commands.go",
          "type": "blob",
          "size": 9.912109375,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/build\"\n\t\"go/types\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"golang.org/x/tools/go/ast/astutil\"\n\t\"golang.org/x/tools/go/packages\"\n)\n\ntype command struct {\n\tname     commandName\n\taction   func(*Session, string) error\n\tcomplete func(*Session, string) []string\n\targ      string\n\tdocument string\n}\n\nvar commands []command\n\nfunc init() {\n\tcommands = []command{\n\t\t{\n\t\t\tname:     commandName(\"i[mport]\"),\n\t\t\taction:   actionImport,\n\t\t\tcomplete: completeImport,\n\t\t\targ:      \"<package>\",\n\t\t\tdocument: \"import a package\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"t[ype]\"),\n\t\t\taction:   actionType,\n\t\t\targ:      \"<expr>\",\n\t\t\tcomplete: completeDoc,\n\t\t\tdocument: \"print the type of expression\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"print\"),\n\t\t\taction:   actionPrint,\n\t\t\tdocument: \"print current source\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"w[rite]\"),\n\t\t\taction:   actionWrite,\n\t\t\tcomplete: nil, // TODO implement\n\t\t\targ:      \"[<file>]\",\n\t\t\tdocument: \"write out current source\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"clear\"),\n\t\t\taction:   actionClear,\n\t\t\tdocument: \"clear the codes\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"d[oc]\"),\n\t\t\taction:   actionDoc,\n\t\t\tcomplete: completeDoc,\n\t\t\targ:      \"<expr or pkg>\",\n\t\t\tdocument: \"show documentation\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"h[elp]\"),\n\t\t\taction:   actionHelp,\n\t\t\tdocument: \"show this help\",\n\t\t},\n\t\t{\n\t\t\tname:     commandName(\"q[uit]\"),\n\t\t\taction:   actionQuit,\n\t\t\tdocument: \"quit the session\",\n\t\t},\n\t}\n}\n\nfunc actionImport(s *Session, arg string) error {\n\tif arg == \"\" {\n\t\treturn fmt.Errorf(\"argument is required\")\n\t}\n\n\tif strings.Contains(arg, \" \") {\n\t\tfor _, v := range strings.Fields(arg) {\n\t\t\tif v == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := actionImport(s, v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\targ = strings.Trim(arg, `\"`)\n\n\t// check if the package specified by path is importable\n\t_, err := packages.Load(\n\t\t&packages.Config{\n\t\t\tDir:        s.tempDir,\n\t\t\tBuildFlags: []string{\"-mod=mod\"},\n\t\t},\n\t\targ,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar found bool\n\tfor _, i := range s.file.Imports {\n\t\tif strings.Trim(i.Path.Value, `\"`) == arg {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tastutil.AddNamedImport(s.fset, s.file, \"_\", arg)\n\t\t_, err = s.types.Check(\"_tmp\", s.fset, append(s.extraFiles, s.file), nil)\n\t\tif err != nil && strings.Contains(err.Error(), \"could not import \"+arg) {\n\t\t\tastutil.DeleteNamedImport(s.fset, s.file, \"_\", arg)\n\t\t\treturn fmt.Errorf(\"could not import %q\", arg)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nvar gorootSrc = filepath.Join(filepath.Clean(runtime.GOROOT()), \"src\")\n\nfunc completeImport(_ *Session, prefix string) []string {\n\tresult := []string{}\n\tseen := map[string]bool{}\n\n\tp := strings.LastIndexFunc(prefix, unicode.IsSpace) + 1\n\n\td, fn := path.Split(prefix[p:])\n\n\t// complete candidates from the current module\n\tif modules, err := goListAll(); err == nil {\n\t\tfor _, m := range modules {\n\n\t\t\tmatchPath := func(fn string) bool {\n\t\t\t\tif len(fn) < 2 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor _, s := range strings.Split(m.Path, \"/\") {\n\t\t\t\t\tif strings.HasPrefix(s, fn) || strings.HasPrefix(strings.TrimPrefix(s, \"go-\"), fn) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif strings.HasPrefix(m.Path, prefix[p:]) || d == \"\" && matchPath(fn) {\n\t\t\t\tresult = append(result, prefix[:p]+m.Path)\n\t\t\t\tseen[m.Path] = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(d, m.Path) {\n\t\t\t\tdir := filepath.Join(m.Dir, strings.Replace(d, m.Path, \"\", 1))\n\t\t\t\tif fi, err := os.Stat(dir); err != nil || !fi.IsDir() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tentries, err := os.ReadDir(dir)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfor _, fi := range entries {\n\t\t\t\t\tif !fi.IsDir() {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tname := fi.Name()\n\t\t\t\t\tif skipCompleteDir(name) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif strings.HasPrefix(name, fn) {\n\t\t\t\t\t\tr := path.Join(d, name)\n\t\t\t\t\t\tif !seen[r] {\n\t\t\t\t\t\t\tresult = append(result, prefix[:p]+r)\n\t\t\t\t\t\t\tseen[r] = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// complete candidates from GOPATH/src/\n\tfor _, srcDir := range build.Default.SrcDirs() {\n\t\tdir := filepath.Join(srcDir, d)\n\n\t\tif fi, err := os.Stat(dir); err != nil || !fi.IsDir() {\n\t\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\t\terrorf(\"Stat %s: %s\", dir, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tentries, err := os.ReadDir(dir)\n\t\tif err != nil {\n\t\t\terrorf(\"ReadDir %s: %s\", dir, err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, fi := range entries {\n\t\t\tif !fi.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tname := fi.Name()\n\t\t\tif skipCompleteDir(name) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(name, fn) {\n\t\t\t\tr := path.Join(d, name)\n\t\t\t\tif srcDir != gorootSrc {\n\t\t\t\t\t// append \"/\" if this directory is not a repository\n\t\t\t\t\t// e.g. does not have VCS directory such as .git or .hg\n\t\t\t\t\t// TODO: do not append \"/\" to subdirectories of repos\n\t\t\t\t\tvar isRepo bool\n\t\t\t\t\tfor _, vcsDir := range []string{\".git\", \".hg\", \".svn\", \".bzr\"} {\n\t\t\t\t\t\t_, err := os.Stat(filepath.Join(srcDir, filepath.FromSlash(r), vcsDir))\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tisRepo = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !isRepo {\n\t\t\t\t\t\tr += \"/\"\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif !seen[r] {\n\t\t\t\t\tresult = append(result, prefix[:p]+r)\n\t\t\t\t\tseen[r] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc skipCompleteDir(dir string) bool {\n\treturn strings.HasPrefix(dir, \".\") || strings.HasPrefix(dir, \"_\") || dir == \"testdata\"\n}\n\nfunc completeDoc(s *Session, prefix string) []string {\n\tpos, cands, err := s.completeCode(prefix, len(prefix), false)\n\tif err != nil {\n\t\terrorf(\"completeCode: %s\", err)\n\t\treturn nil\n\t}\n\n\tresult := make([]string, 0, len(cands))\n\tfor _, c := range cands {\n\t\tresult = append(result, prefix[0:pos]+c)\n\t}\n\n\treturn result\n}\n\nfunc actionPrint(s *Session, _ string) error {\n\tsource, err := s.source(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(source)\n\n\treturn nil\n}\n\nfunc actionType(s *Session, in string) error {\n\tif in == \"\" {\n\t\treturn fmt.Errorf(\"argument is required\")\n\t}\n\n\ts.clearQuickFix()\n\n\ts.storeCode()\n\tdefer s.restoreCode()\n\n\texpr, err := s.evalExpr(in)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.typeInfo = types.Info{\n\t\tTypes:  make(map[ast.Expr]types.TypeAndValue),\n\t\tUses:   make(map[*ast.Ident]types.Object),\n\t\tDefs:   make(map[*ast.Ident]types.Object),\n\t\tScopes: make(map[ast.Node]*types.Scope),\n\t}\n\t_, err = s.types.Check(\"_tmp\", s.fset, append(s.extraFiles, s.file), &s.typeInfo)\n\tif err != nil {\n\t\tdebugf(\"typecheck error (ignored): %s\", err)\n\t}\n\n\ttyp := s.typeInfo.TypeOf(expr)\n\tif typ == nil {\n\t\treturn fmt.Errorf(\"cannot get type: %v\", expr)\n\t}\n\tif typ, ok := typ.(*types.Basic); ok && typ.Kind() == types.Invalid {\n\t\treturn fmt.Errorf(\"cannot get type: %v\", expr)\n\t}\n\tfmt.Fprintf(s.stdout, \"%v\\n\", typ)\n\treturn nil\n}\n\nfunc actionWrite(s *Session, filename string) error {\n\tsource, err := s.source(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif filename == \"\" {\n\t\tfilename = fmt.Sprintf(\"gore_session_%s.go\", time.Now().Format(\"20060102_150405\"))\n\t}\n\n\terr = os.WriteFile(filename, []byte(source), 0o644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinfof(\"Source wrote to %s\", filename)\n\n\treturn nil\n}\n\nfunc actionClear(s *Session, _ string) error {\n\treturn s.init()\n}\n\nfunc actionDoc(s *Session, in string) error {\n\tif in == \"\" {\n\t\treturn fmt.Errorf(\"argument is required\")\n\t}\n\n\ts.clearQuickFix()\n\n\ts.storeCode()\n\tdefer s.restoreCode()\n\n\texpr, err := s.evalExpr(in)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.typeInfo = types.Info{\n\t\tTypes:  make(map[ast.Expr]types.TypeAndValue),\n\t\tUses:   make(map[*ast.Ident]types.Object),\n\t\tDefs:   make(map[*ast.Ident]types.Object),\n\t\tScopes: make(map[ast.Node]*types.Scope),\n\t}\n\t_, err = s.types.Check(\"_tmp\", s.fset, append(s.extraFiles, s.file), &s.typeInfo)\n\tif err != nil {\n\t\tdebugf(\"typecheck error (ignored): %s\", err)\n\t}\n\n\t// :doc patterns:\n\t// - \"json\" -> \"encoding/json\" (package name)\n\t// - \"json.Encoder\" -> \"encoding/json\", \"Encoder\" (package member)\n\t// - \"json.NewEncoder(nil).Encode\" -> \"encoding/json\", \"Decode\" (package type member)\n\tvar docObj types.Object\n\tif sel, ok := expr.(*ast.SelectorExpr); ok {\n\t\t// package member, package type member\n\t\tdocObj = s.typeInfo.ObjectOf(sel.Sel)\n\t} else if t := s.typeInfo.TypeOf(expr); t != nil && t != types.Typ[types.Invalid] {\n\t\tfor {\n\t\t\tif pt, ok := t.(*types.Pointer); ok {\n\t\t\t\tt = pt.Elem()\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tswitch t := t.(type) {\n\t\tcase *types.Named:\n\t\t\tdocObj = t.Obj()\n\t\tcase *types.Basic:\n\t\t\t// builtin types\n\t\t\tdocObj = types.Universe.Lookup(t.Name())\n\t\t}\n\t} else if ident, ok := expr.(*ast.Ident); ok {\n\t\t// package name\n\t\tmainScope := s.typeInfo.Scopes[s.mainFunc().Type]\n\t\t_, docObj = mainScope.LookupParent(ident.Name, ident.NamePos)\n\t}\n\n\tif docObj == nil {\n\t\treturn fmt.Errorf(\"cannot determine the document location\")\n\t}\n\n\tdebugf(\"doc :: obj=%#v\", docObj)\n\n\tvar pkgPath, objName string\n\tif pkgName, ok := docObj.(*types.PkgName); ok {\n\t\tpkgPath = pkgName.Imported().Path()\n\t} else {\n\t\tif pkg := docObj.Pkg(); pkg != nil {\n\t\t\tpkgPath = pkg.Path()\n\t\t} else {\n\t\t\tpkgPath = \"builtin\"\n\t\t}\n\t\tobjName = docObj.Name()\n\t}\n\n\tdebugf(\"doc :: %q %q\", pkgPath, objName)\n\n\targs := []string{\"doc\", pkgPath}\n\tif objName != \"\" {\n\t\targs = append(args, objName)\n\t}\n\n\tgodoc := exec.Command(\"go\", args...)\n\tgodoc.Dir = s.tempDir\n\tgodoc.Env = append(os.Environ(), \"GO111MODULE=on\")\n\tef := newErrFilter(s.stderr)\n\tgodoc.Stderr = ef\n\tdefer ef.Close()\n\n\t// TODO just use PAGER?\n\tif pagerCmd := os.Getenv(\"GORE_PAGER\"); pagerCmd != \"\" {\n\t\tr, err := godoc.StdoutPipe()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpager := exec.Command(pagerCmd)\n\t\tpager.Stdin = r\n\t\tpager.Stdout = s.stdout\n\t\tpager.Stderr = s.stderr\n\n\t\terr = pager.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = godoc.Run()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn pager.Wait()\n\t}\n\tgodoc.Stdout = s.stdout\n\treturn godoc.Run()\n}\n\nfunc actionHelp(s *Session, _ string) error {\n\tw := tabwriter.NewWriter(s.stdout, 0, 8, 4, ' ', 0)\n\tfor _, command := range commands {\n\t\tcmd := fmt.Sprintf(\":%s\", command.name)\n\t\tif command.arg != \"\" {\n\t\t\tcmd = cmd + \" \" + command.arg\n\t\t}\n\t\tw.Write([]byte(\"    \" + cmd + \"\\t\" + command.document + \"\\n\"))\n\t}\n\tw.Flush()\n\n\treturn nil\n}\n\nfunc actionQuit(_ *Session, _ string) error {\n\treturn ErrQuit\n}\n"
        },
        {
          "name": "commands_test.go",
          "type": "blob",
          "size": 4.7373046875,
          "content": "package gore\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAction_Type(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`:type \"hello\"`,\n\t\t\":type 128\",\n\t\t\":type 3.14\",\n\t\t\"func f() []int { return nil }\",\n\t\t\":t f\",\n\t\t\":t f()\",\n\t\t\":i fmt encoding/json\",\n\t\t\":t fmt.Sprint\",\n\t\t\":t fmt.Println\",\n\t\t\":t json.NewEncoder\",\n\t\t\":t x\",\n\t\t\":t fmt\",\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Regexp(t, `string\nint\nfloat64\nfunc\\(\\) \\[\\]int\n\\[\\]int\nfunc\\(a \\.\\.\\.(?:interface\\{\\}|any)\\) string\nfunc\\(a \\.\\.\\.(?:interface\\{\\}|any)\\) \\(n int, err error\\)\nfunc\\(w io\\.Writer\\) \\*encoding/json\\.Encoder\n`, stdout.String())\n\tassert.Equal(t, `type: cannot get type: x\ntype: cannot get type: fmt\n`, stderr.String())\n}\n\nfunc TestAction_Doc(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\":import encoding/json\")\n\trequire.NoError(t, err)\n\terr = s.Eval(\":i fmt\")\n\trequire.NoError(t, err)\n\n\ttest := func() {\n\t\terr = s.Eval(\":doc fmt\")\n\t\trequire.NoError(t, err)\n\n\t\terr = s.Eval(\":doc fmt.Print\")\n\t\trequire.NoError(t, err)\n\n\t\terr = s.Eval(\":d json.NewEncoder(nil).Encode\")\n\t\trequire.NoError(t, err)\n\t}\n\n\ttest()\n\n\t// test :doc works after some code\n\n\terr = s.Eval(\"a := 1\")\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\"fmt.Print()\")\n\trequire.NoError(t, err)\n\n\ttest()\n\n\tassert.Contains(t, stdout.String(), \"package fmt\")\n\tassert.Contains(t, stdout.String(), \"func Printf\")\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestAction_Import(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\":import encoding/json fmt\")\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\"fmt.Print\")\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\"json.Encoder{}\")\n\trequire.NoError(t, err)\n\n\tassert.Contains(t, stdout.String(), \"(func(...interface {}) (int, error))\")\n\tassert.Contains(t, stdout.String(), \"json.Encoder\")\n\tassert.Equal(t, \"\", stderr.String())\n\n\terr = s.Eval(\":import invalid\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\"fmt.Sprint\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"import: could not import \\\"invalid\\\"\\n\", stderr.String())\n}\n\nfunc TestAction_Clear(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`x := 10`,\n\t\t`x`,\n\t\t`:clear`,\n\t\t`x := \"foo\"`,\n\t\t`x`,\n\t\t`:clear`,\n\t\t`x`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, `10\n10\n\"foo\"\n\"foo\"\n`, stdout.String())\n\tassert.Equal(t, \"undefined: x\\n\", stderr.String())\n}\n\nfunc TestAction_Help(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\": :  :   help  \")\n\trequire.NoError(t, err)\n\n\tassert.Contains(t, stdout.String(), \":import <package>\")\n\tassert.Contains(t, stdout.String(), \":write [<file>]\")\n\tassert.Contains(t, stdout.String(), \"show this help\")\n\tassert.Contains(t, stdout.String(), \"quit the session\")\n\tassert.Equal(t, \"\", stderr.String())\n\n\terr = s.Eval(\":h\")\n\trequire.NoError(t, err)\n}\n\nfunc TestAction_Quit(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\" :\\t: quit\")\n\trequire.Equal(t, ErrQuit, err)\n\n\tassert.Equal(t, \"\", stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n\n\terr = s.Eval(\":q\")\n\trequire.Equal(t, ErrQuit, err)\n}\n\nfunc TestAction_CommandNotFound(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\":::\")\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\":foo\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\":ii\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\":docc\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\":help]\")\n\trequire.Error(t, err)\n\n\tassert.Equal(t, \"\", stdout.String())\n\tassert.Equal(t, `command not found: foo\ncommand not found: ii\ncommand not found: docc\ncommand not found: help]\n`, stderr.String())\n}\n\nfunc TestAction_ArgumentRequired(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\":import\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\":type\")\n\trequire.Error(t, err)\n\n\terr = s.Eval(\":doc\")\n\trequire.Error(t, err)\n\n\tassert.Equal(t, \"\", stdout.String())\n\tassert.Equal(t, `import: argument is required\ntype: argument is required\ndoc: argument is required\n`, stderr.String())\n}\n"
        },
        {
          "name": "complete.go",
          "type": "blob",
          "size": 2.6005859375,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/x-motemen/gore/gocode\"\n)\n\nfunc (s *Session) completeWord(line string, pos int) (string, []string, string) {\n\tif strings.HasPrefix(strings.TrimSpace(line), \":\") {\n\t\t// complete commands\n\t\tvar idx int\n\t\tin := strings.TrimLeftFunc(line[:pos], func(c rune) bool {\n\t\t\tif c == ':' || unicode.IsSpace(c) {\n\t\t\t\tidx++\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t\tvar cmd string\n\t\tif tokens := strings.Fields(in); len(tokens) > 0 {\n\t\t\tcmd = tokens[0]\n\t\t}\n\n\t\tif !strings.Contains(in, \" \") {\n\t\t\tpre, post := line[:idx], line[pos:]\n\t\t\tvar result []string\n\t\t\tfor _, command := range commands {\n\t\t\t\tname := pre + fmt.Sprint(command.name)\n\t\t\t\tif cmd == \"\" || command.name.matchesPrefix(cmd) {\n\t\t\t\t\tif !strings.HasPrefix(post, \" \") && command.arg != \"\" {\n\t\t\t\t\t\tname += \" \"\n\t\t\t\t\t}\n\t\t\t\t\tresult = append(result, name)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\", result, post\n\t\t}\n\n\t\t// complete command arguments\n\t\tfor _, command := range commands {\n\t\t\tif command.complete == nil || !command.name.matches(cmd) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcmdPrefix := line[:idx] + cmd + \" \"\n\t\t\treturn cmdPrefix, command.complete(s, line[len(cmdPrefix):pos]), \"\"\n\t\t}\n\n\t\treturn \"\", nil, \"\"\n\t}\n\n\tif !gocode.Available() {\n\t\treturn \"\", nil, \"\"\n\t}\n\n\tif strings.TrimSpace(line[:pos]) == \"\" {\n\t\treturn \"\", []string{line[:pos] + indent}, line[pos:]\n\t}\n\n\t// code completion\n\tpos, cands, err := s.completeCode(line, pos, true)\n\tif err != nil {\n\t\terrorf(\"completeCode: %s\", err)\n\t\treturn \"\", nil, \"\"\n\t}\n\n\treturn line[0:pos], cands, \"\"\n}\n\n// completeCode does code completion within the session using gocode.\n// in and pos specifies the current input and the cursor position (0 <= pos <= len(in)) respectively.\n// If exprMode is set to true, the completion is done as an expression (e.g. appends \"(\" to functions).\n// Return value keep specifies how many characters of in should be kept and candidates are what follow in[0:keep].\nfunc (s *Session) completeCode(in string, pos int, exprMode bool) (keep int, candidates []string, err error) {\n\ts.clearQuickFix()\n\n\tsource, err := s.source(false)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Kind of dirty hack :/\n\tp := strings.LastIndex(source, \"}\")\n\teditingSource := source[0:p] + in + source[p:]\n\tcursor := len(source[0:p]) + pos\n\n\tresult, err := gocode.Query([]byte(editingSource), cursor)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tkeep = pos - result.Cursor\n\tcandidates = make([]string, 0, len(result.Candidates))\n\tfor _, e := range result.Candidates {\n\t\tcand := e.Name\n\t\tif cand == printerName && e.Class == \"func\" {\n\t\t\tcontinue\n\t\t}\n\t\tif exprMode && e.Class == \"func\" {\n\t\t\tcand += \"(\"\n\t\t}\n\t\tcandidates = append(candidates, cand)\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "complete_test.go",
          "type": "blob",
          "size": 3.134765625,
          "content": "package gore\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/x-motemen/gore/gocode\"\n)\n\nfunc TestSession_completeWord(t *testing.T) {\n\tif !gocode.Available() {\n\t\tt.Skipf(\"gocode unavailable\")\n\t}\n\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tpre, cands, post := s.completeWord(\"\", 0)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\"    \"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\"    x\", 4)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\"        \"}, cands)\n\tassert.Equal(t, post, \"x\")\n\n\tpre, cands, post = s.completeWord(\" : :\", 4)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\n\t\t\" : :import \",\n\t\t\" : :type \",\n\t\t\" : :print\",\n\t\t\" : :write \",\n\t\t\" : :clear\",\n\t\t\" : :doc \",\n\t\t\" : :help\",\n\t\t\" : :quit\",\n\t}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\" : : i\", 6)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\" : : import \"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\"::i t\", 5)\n\tassert.Equal(t, \"::i \", pre)\n\tassert.Equal(t, []string{\"testing\", \"text\", \"time\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\"::i gor\", 7)\n\tassert.Equal(t, \"::i \", pre)\n\tassert.Equal(t, []string{\"github.com/x-motemen/gore\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i gore\", 7)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\"github.com/x-motemen/gore\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i to\", 5)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\"golang.org/x/tools\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i qu\", 5)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\"github.com/motemen/go-quickfix\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i go-qu\", 8)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\"github.com/motemen/go-quickfix\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i go-\", 6)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\n\t\t\"github.com/davecgh/go-spew\", \"github.com/mattn/go-runewidth\",\n\t\t\"github.com/motemen/go-quickfix\", \"github.com/pmezard/go-difflib\",\n\t}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i x-\", 5)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Equal(t, []string{\"github.com/x-motemen/gore\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":c\", 2)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\":clear\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\" : : q\", 6)\n\tassert.Equal(t, \"\", pre)\n\tassert.Equal(t, []string{\" : : quit\"}, cands)\n\tassert.Equal(t, post, \"\")\n\n\terr = actionImport(s, \"fmt\")\n\trequire.NoError(t, err)\n\n\tpre, cands, post = s.completeWord(\"fmt.p\", 5)\n\tassert.Equal(t, \"fmt.\", pre)\n\tassert.Contains(t, cands, \"Println(\")\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\" ::: doc  f\", 11)\n\tassert.Equal(t, \" ::: doc \", pre)\n\tassert.Equal(t, []string{\" fmt\"}, cands)\n\tassert.Equal(t, post, \"\")\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 0.3076171875,
          "content": "//go:build debug\n// +build debug\n\npackage gore\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n)\n\nfunc debugf(format string, args ...any) {\n\t_, file, line, ok := runtime.Caller(1)\n\n\tif ok {\n\t\tformat = fmt.Sprintf(\"%s:%d %s\", filepath.Base(file), line, format)\n\t}\n\n\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "errfilter.go",
          "type": "blob",
          "size": 1.193359375,
          "content": "package gore\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\t\"golang.org/x/text/transform\"\n)\n\nfunc newErrFilter(w io.Writer) io.WriteCloser {\n\treturn transform.NewWriter(w, &errTransformer{})\n}\n\ntype errTransformer struct{}\n\nfunc (*errTransformer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {\n\tvar i int\n\tfor {\n\t\tif atEOF {\n\t\t\tif i = len(src) - 1; i < 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tif i = bytes.IndexByte(src, '\\n'); i < 0 {\n\t\t\t\terr = transform.ErrShortSrc\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tres := replaceErrMsg(src[:i+1])\n\t\tif nDst+len(res) > len(dst) {\n\t\t\terr = transform.ErrShortDst\n\t\t\tbreak\n\t\t}\n\t\tsrc = src[i+1:]\n\t\tnSrc += i + 1\n\t\tnDst += copy(dst[nDst:], res)\n\t\tif len(src) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (*errTransformer) Reset() {}\n\nfunc replaceErrMsg(p []byte) []byte {\n\tif bytes.HasPrefix(p, []byte(\"# command-line-arguments\")) {\n\t\treturn nil\n\t}\n\tif cs := \"build command-line-arguments: \"; bytes.HasPrefix(p, []byte(cs)) {\n\t\treturn p[len(cs):]\n\t}\n\tif bytes.HasPrefix(p, []byte(`warning: pattern \"all\" matched no module dependencies`)) {\n\t\treturn nil\n\t}\n\tif i := bytes.Index(p, []byte(\"gore_session.go\")); i >= 0 {\n\t\tif j := bytes.IndexRune(p[i:], ' '); j >= 0 {\n\t\t\treturn p[i+j+1:]\n\t\t}\n\t\treturn p\n\t}\n\treturn p\n}\n"
        },
        {
          "name": "errfilter_test.go",
          "type": "blob",
          "size": 1.1767578125,
          "content": "package gore\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestErrFilter(t *testing.T) {\n\ttestCases := []struct {\n\t\tid, src, expected string\n\t}{\n\t\t{\n\t\t\t\"simple\",\n\t\t\t\"foobar\",\n\t\t\t\"foobar\",\n\t\t},\n\t\t{\n\t\t\t\"new line\",\n\t\t\t\"foobar\\nbaz\\nqux\\n\",\n\t\t\t\"foobar\\nbaz\\nqux\\n\",\n\t\t},\n\t\t{\n\t\t\t\"command-line-arguments\",\n\t\t\t\"# command-line-arguments foo\\nbar\\nbuild command-line-arguments: baz\\nqux\",\n\t\t\t\"bar\\nbaz\\nqux\",\n\t\t},\n\t\t{\n\t\t\t\"gore_session.go\",\n\t\t\t\"/tmp/gore_session.go:10:24: undefined: foo\",\n\t\t\t\"undefined: foo\",\n\t\t},\n\t\t{\n\t\t\t\"command-line-arguments and gore_session.go\",\n\t\t\t\"# command-line-arguments foo\\n/tmp/gore_session.go:10:24: undefined: foo\",\n\t\t\t\"undefined: foo\",\n\t\t},\n\t\t{\n\t\t\t\"no module dependencies warning\",\n\t\t\t\"warning: pattern \\\"all\\\" matched no module dependencies\\nwarning: pattern \\\"all\\\" matched no module depend\",\n\t\t\t\"warning: pattern \\\"all\\\" matched no module depend\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.id, func(t *testing.T) {\n\t\t\tvar out strings.Builder\n\t\t\tw := newErrFilter(&out)\n\t\t\t_, err := w.Write([]byte(tc.src))\n\t\t\trequire.NoError(t, err)\n\t\t\terr = w.Close()\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.expected, out.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5126953125,
          "content": "module github.com/x-motemen/gore\n\ngo 1.19\n\nrequire (\n\tgithub.com/motemen/go-quickfix v0.0.0-20230925231438-5cf0001766ff\n\tgithub.com/peterh/liner v1.2.2\n\tgithub.com/stretchr/testify v1.3.0\n\tgolang.org/x/text v0.13.0\n\tgolang.org/x/tools v0.13.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.0 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgolang.org/x/mod v0.12.0 // indirect\n\tgolang.org/x/sys v0.12.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.2705078125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/motemen/go-quickfix v0.0.0-20230925231438-5cf0001766ff h1:GxE6FXAMf6277RwdspqECes+okYHGnv8H5XMz2SK9/s=\ngithub.com/motemen/go-quickfix v0.0.0-20230925231438-5cf0001766ff/go.mod h1:bqir/ik5G0acBrQTQMnv5mvIq6GC5q66tyNY2yI4lJM=\ngithub.com/peterh/liner v1.2.2 h1:aJ4AOodmL+JxOZZEL2u9iJf8omNRpqHc/EbrK+3mAXw=\ngithub.com/peterh/liner v1.2.2/go.mod h1:xFwJyiKIXJZUKItq5dGHZSTBRAuG/CpeNpWLyiNRNwI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngolang.org/x/mod v0.12.0 h1:rmsUpXtvNzj340zd98LZ4KntptpfRHwpFOHG188oHXc=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=\ngolang.org/x/sys v0.0.0-20211117180635-dee7805ff2e1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0 h1:CM0HF96J0hcLAwsHPJZjfdNzs0gftsLfgKt57wWHJ0o=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/text v0.13.0 h1:ablQoSUd0tRdKxZewP80B+BaqeKJuVhuRxj/dkrun3k=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/tools v0.13.0 h1:Iey4qkscZuv0VvIt8E0neZjtPVQFSc870HQ448QgEmQ=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\n"
        },
        {
          "name": "gocode",
          "type": "tree",
          "content": null
        },
        {
          "name": "gomod.go",
          "type": "blob",
          "size": 2.826171875,
          "content": "package gore\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"go/build\"\n\t\"io\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc (s *Session) initGoMod() error {\n\ttempModule := filepath.Base(s.tempDir)\n\tgoModPath := filepath.Join(s.tempDir, \"go.mod\")\n\tdirectives := s.listModuleDirectives()\n\tmod := \"module \" + tempModule + \"\\n\" + strings.Join(directives, \"\\n\")\n\treturn os.WriteFile(goModPath, []byte(mod), 0o644)\n}\n\nfunc (s *Session) listModuleDirectives() []string {\n\tvar directives []string\n\tfor i, pp := range printerPkgs {\n\t\tif pp.path == \"fmt\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Check local module caches.\n\t\tfound := lookupGoModule(pp.path, pp.version)\n\t\tif found {\n\t\t\tfor _, r := range pp.requires {\n\t\t\t\tif !lookupGoModule(r.path, r.version) {\n\t\t\t\t\tfound = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif found || canAccessGoproxy() {\n\t\t\t// Specifying the version of the printer package improves startup\n\t\t\t// performance by skipping module version fetching. Also allows to\n\t\t\t// use gore in offline environment.\n\t\t\tdirectives = append(directives, \"require \"+pp.path+\" \"+pp.version)\n\t\t\tfor _, r := range pp.requires {\n\t\t\t\tdirectives = append(directives, \"require \"+r.path+\" \"+r.version)\n\t\t\t}\n\t\t} else {\n\t\t\t// If there is no module cache and no network connection, use fmt package.\n\t\t\tprinterPkgs = printerPkgs[i+1:]\n\t\t}\n\t\t// only the first printer is checked (assuming printerPkgs[1] is fmt)\n\t\tbreak\n\t}\n\tmodules, err := goListAll()\n\tif err != nil {\n\t\treturn directives\n\t}\n\tfor _, m := range modules {\n\t\tif m.Main || m.Replace != nil {\n\t\t\tdirectives = append(directives, \"replace \"+m.Path+\" => \"+strconv.Quote(m.Dir))\n\t\t\ts.requiredModules = append(s.requiredModules, m.Path)\n\t\t}\n\t}\n\treturn directives\n}\n\ntype goModule struct {\n\tPath, Dir, Version string\n\tMain               bool\n\tReplace            *goModule\n}\n\nfunc goListAll() ([]*goModule, error) {\n\tcmd := exec.Command(\"go\", \"list\", \"-json\", \"-m\", \"all\")\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\td := json.NewDecoder(bytes.NewReader(out))\n\tvar ms []*goModule\n\tfor {\n\t\tm := new(goModule)\n\t\tif err := d.Decode(m); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn ms, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tms = append(ms, m)\n\t}\n}\n\nfunc lookupGoModule(pkg, version string) bool {\n\tmodDir := filepath.Join(build.Default.GOPATH, \"pkg/mod\", pkg+\"@\"+version)\n\tfi, err := os.Stat(modDir)\n\treturn err == nil && fi.IsDir()\n}\n\nfunc canAccessGoproxy() bool {\n\tvar host string\n\tif u, err := url.Parse(getGoproxy()); err != nil {\n\t\thost = \"proxy.golang.org\"\n\t} else {\n\t\thost = u.Hostname()\n\t}\n\taddr := net.JoinHostPort(host, \"80\")\n\tdialer := net.Dialer{Timeout: 5 * time.Second}\n\tconn, err := dialer.Dial(\"tcp\", addr)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer conn.Close()\n\treturn true\n}\n\nfunc getGoproxy() string {\n\tif goproxy := os.Getenv(\"GOPROXY\"); goproxy != \"\" {\n\t\treturn goproxy\n\t}\n\treturn \"https://proxy.golang.org/\"\n}\n"
        },
        {
          "name": "gore.go",
          "type": "blob",
          "size": 2.3173828125,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Version of gore.\nconst Version = \"0.5.7\"\n\n// Gore ...\ntype Gore struct {\n\tautoImport           bool\n\textFiles             string\n\tpackageName          string\n\toutWriter, errWriter io.Writer\n}\n\n// New Gore\nfunc New(opts ...Option) *Gore {\n\tg := &Gore{outWriter: os.Stdout, errWriter: os.Stderr}\n\tfor _, opt := range opts {\n\t\topt(g)\n\t}\n\treturn g\n}\n\n// Run ...\nfunc (g *Gore) Run() error {\n\ts, err := NewSession(g.outWriter, g.errWriter)\n\tdefer s.Clear()\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.autoImport = g.autoImport\n\n\tfmt.Fprintf(g.errWriter, \"gore version %s  :help for help\\n\", Version)\n\n\tif g.extFiles != \"\" {\n\t\textFiles := strings.Split(g.extFiles, \",\")\n\t\ts.includeFiles(extFiles)\n\t}\n\n\tif g.packageName != \"\" {\n\t\tif err := s.includePackage(g.packageName); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\trl := newContLiner()\n\tdefer rl.Close()\n\n\tvar historyFile string\n\thome, err := homeDir()\n\tif err != nil {\n\t\terrorf(\"home: %s\", err)\n\t} else {\n\t\thistoryFile = filepath.Join(home, \"history\")\n\n\t\tf, err := os.Open(historyFile)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\terrorf(\"%s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t_, err := rl.ReadHistory(f)\n\t\t\tif err != nil {\n\t\t\t\terrorf(\"while reading history: %s\", err)\n\t\t\t}\n\t\t\tf.Close()\n\t\t}\n\t}\n\n\trl.SetWordCompleter(s.completeWord)\n\n\tfor {\n\t\tin, err := rl.Prompt()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif in == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := rl.Reindent(); err != nil {\n\t\t\tfmt.Fprintf(g.errWriter, \"error: %s\\n\", err)\n\t\t\trl.Clear()\n\t\t\tcontinue\n\t\t}\n\n\t\terr = s.Eval(in)\n\t\tif err != nil {\n\t\t\tif err == ErrContinue {\n\t\t\t\tcontinue\n\t\t\t} else if err == ErrQuit {\n\t\t\t\tbreak\n\t\t\t} else if err != ErrCmdRun {\n\t\t\t\trl.Clear()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\trl.Accepted()\n\t}\n\n\tif historyFile != \"\" {\n\t\terr := os.MkdirAll(filepath.Dir(historyFile), 0o755)\n\t\tif err != nil {\n\t\t\terrorf(\"%s\", err)\n\t\t} else {\n\t\t\tf, err := os.Create(historyFile)\n\t\t\tif err != nil {\n\t\t\t\terrorf(\"%s\", err)\n\t\t\t} else {\n\t\t\t\t_, err := rl.WriteHistory(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrorf(\"while saving history: %s\", err)\n\t\t\t\t}\n\t\t\t\tf.Close()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc homeDir() (home string, err error) {\n\thome = os.Getenv(\"GORE_HOME\")\n\tif home != \"\" {\n\t\treturn\n\t}\n\n\thome, err = os.UserHomeDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\thome = filepath.Join(home, \".gore\")\n\treturn\n}\n"
        },
        {
          "name": "liner.go",
          "type": "blob",
          "size": 1.955078125,
          "content": "package gore\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"text/scanner\"\n\n\t\"github.com/peterh/liner\"\n)\n\nconst (\n\tpromptDefault  = \"gore> \"\n\tpromptContinue = \"..... \"\n\tindent         = \"    \"\n)\n\ntype contLiner struct {\n\t*liner.State\n\tbuffer string\n\tdepth  int\n}\n\nfunc newContLiner() *contLiner {\n\trl := liner.NewLiner()\n\trl.SetCtrlCAborts(true)\n\treturn &contLiner{State: rl}\n}\n\nfunc (cl *contLiner) promptString() string {\n\tif cl.buffer != \"\" {\n\t\treturn promptContinue + strings.Repeat(indent, cl.depth)\n\t}\n\n\treturn promptDefault\n}\n\nfunc (cl *contLiner) Prompt() (string, error) {\n\tline, err := cl.State.Prompt(cl.promptString())\n\tif err == io.EOF {\n\t\tif cl.buffer != \"\" {\n\t\t\t// cancel line continuation\n\t\t\tcl.Accepted()\n\t\t\tfmt.Println()\n\t\t\terr = nil\n\t\t}\n\t} else if err == liner.ErrPromptAborted {\n\t\terr = nil\n\t\tif cl.buffer != \"\" {\n\t\t\tcl.Accepted()\n\t\t} else {\n\t\t\tfmt.Println(\"(^D to quit)\")\n\t\t}\n\t} else if err == nil {\n\t\tif cl.buffer != \"\" {\n\t\t\tcl.buffer = cl.buffer + \"\\n\" + line\n\t\t} else {\n\t\t\tcl.buffer = line\n\t\t}\n\t}\n\n\treturn cl.buffer, err\n}\n\nfunc (cl *contLiner) Accepted() {\n\tcl.State.AppendHistory(cl.buffer)\n\tcl.buffer = \"\"\n}\n\nfunc (cl *contLiner) Clear() {\n\tcl.buffer = \"\"\n\tcl.depth = 0\n}\n\nvar errUnmatchedBraces = fmt.Errorf(\"unmatched braces\")\n\nfunc (cl *contLiner) Reindent() error {\n\toldDepth := cl.depth\n\tcl.depth = cl.countDepth()\n\n\tif cl.depth < 0 {\n\t\treturn errUnmatchedBraces\n\t}\n\n\tif cl.depth < oldDepth {\n\t\tlines := strings.Split(cl.buffer, \"\\n\")\n\t\tif len(lines) > 1 {\n\t\t\tlastLine := lines[len(lines)-1]\n\n\t\t\tcursorUp()\n\t\t\tfmt.Printf(\"\\r%s%s\", cl.promptString(), lastLine)\n\t\t\teraseInLine()\n\t\t\tfmt.Print(\"\\n\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cl *contLiner) countDepth() int {\n\treader := bytes.NewBufferString(cl.buffer)\n\tsc := new(scanner.Scanner)\n\tsc.Init(reader)\n\tsc.Error = func(_ *scanner.Scanner, msg string) {\n\t\tdebugf(\"scanner: %s\", msg)\n\t}\n\n\tdepth := 0\n\tfor {\n\t\tswitch sc.Scan() {\n\t\tcase '{', '(':\n\t\t\tdepth++\n\t\tcase '}', ')':\n\t\t\tdepth--\n\t\tcase scanner.EOF:\n\t\t\treturn depth\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 0.2236328125,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc errorf(format string, args ...any) {\n\tfmt.Fprintf(os.Stderr, \"error: \"+format+\"\\n\", args...)\n}\n\nfunc infof(format string, args ...any) {\n\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n}\n"
        },
        {
          "name": "node.go",
          "type": "blob",
          "size": 0.6904296875,
          "content": "package gore\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"reflect\"\n)\n\n// normalizeNodePos resets all position information of node and its descendants.\nfunc normalizeNodePos(node ast.Node) {\n\tast.Inspect(node, func(node ast.Node) bool {\n\t\tif node == nil {\n\t\t\treturn true\n\t\t}\n\n\t\tif node.Pos() == token.NoPos && node.End() == token.NoPos {\n\t\t\treturn true\n\t\t}\n\n\t\tpv := reflect.ValueOf(node)\n\t\tif pv.Kind() != reflect.Ptr {\n\t\t\treturn true\n\t\t}\n\n\t\tv := pv.Elem()\n\t\tif v.Kind() != reflect.Struct {\n\t\t\treturn true\n\t\t}\n\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tf := v.Field(i)\n\t\t\tft := f.Type()\n\t\t\tif f.CanSet() && ft.PkgPath() == \"go/token\" && ft.Name() == \"Pos\" && f.Int() != 0 {\n\t\t\t\tf.SetInt(1)\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t})\n}\n"
        },
        {
          "name": "node_test.go",
          "type": "blob",
          "size": 0.484375,
          "content": "package gore\n\nimport (\n\t\"go/parser\"\n\t\"go/token\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNormalizeNodePos(t *testing.T) {\n\tsrc := `package P\n\nimport \"fmt\"\n\nfunc F() {\n\tfmt.\n\t\tPrintln(\n\t\t1,\n\t)\n}\n`\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, \"t.go\", src, 0)\n\trequire.NoError(t, err)\n\n\tnormalizeNodePos(f)\n\n\tformatted := showNode(fset, f)\n\tif formatted == src {\n\t\tt.Fatalf(\"formatted source must differ from original after normalizeNode: %s\", formatted)\n\t}\n}\n"
        },
        {
          "name": "nodebug.go",
          "type": "blob",
          "size": 0.0791015625,
          "content": "//go:build !debug\n// +build !debug\n\npackage gore\n\nfunc debugf(string, ...any) {}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 0.658203125,
          "content": "package gore\n\nimport \"io\"\n\n// Option for Gore\ntype Option func(*Gore)\n\n// AutoImport option\nfunc AutoImport(autoImport bool) Option {\n\treturn func(g *Gore) {\n\t\tg.autoImport = autoImport\n\t}\n}\n\n// ExtFiles option\nfunc ExtFiles(extFiles string) Option {\n\treturn func(g *Gore) {\n\t\tg.extFiles = extFiles\n\t}\n}\n\n// PackageName option\nfunc PackageName(packageName string) Option {\n\treturn func(g *Gore) {\n\t\tg.packageName = packageName\n\t}\n}\n\n// OutWriter option\nfunc OutWriter(outWriter io.Writer) Option {\n\treturn func(g *Gore) {\n\t\tg.outWriter = outWriter\n\t}\n}\n\n// ErrWriter option\nfunc ErrWriter(errWriter io.Writer) Option {\n\treturn func(g *Gore) {\n\t\tg.errWriter = errWriter\n\t}\n}\n"
        },
        {
          "name": "quickfix.go",
          "type": "blob",
          "size": 5.9130859375,
          "content": "package gore\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"strings\"\n\n\t\"golang.org/x/tools/go/ast/astutil\"\n\n\t\"github.com/motemen/go-quickfix\"\n)\n\n// doQuickFix tries to fix the source AST so that it compiles well.\nfunc (s *Session) doQuickFix() {\n\tconst maxAttempts = 10\n\n\tif err := s.reset(); err != nil {\n\t\tdebugf(\"reset :: err = %s\", err)\n\t}\n\nL:\n\tfor i := 0; i < maxAttempts; i++ {\n\t\ts.typeInfo = types.Info{\n\t\t\tTypes: make(map[ast.Expr]types.TypeAndValue),\n\t\t}\n\n\t\tconfig := quickfix.Config{\n\t\t\tFset:     s.fset,\n\t\t\tFiles:    append(s.extraFiles, s.file),\n\t\t\tTypeInfo: &s.typeInfo,\n\t\t\tDir:      s.tempDir,\n\t\t}\n\t\t_, err := config.QuickFixOnce()\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tdebugf(\"quickFix :: err = %s\", err)\n\n\t\terrList, ok := err.(quickfix.ErrorList)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// (try to) fix gore-specific remaining errors\n\t\tfor _, err := range errList {\n\t\t\terr, ok := err.(types.Error)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// \"... used as value\":\n\t\t\t//\n\t\t\t// convert\n\t\t\t//   __gore_pp(funcWithSideEffectReturningNoValue())\n\t\t\t// to\n\t\t\t//   funcWithSideEffectReturningNoValue()\n\t\t\tif strings.HasSuffix(err.Msg, \" used as value\") {\n\t\t\t\tnodepath, _ := astutil.PathEnclosingInterval(s.file, err.Pos, err.Pos)\n\n\t\t\t\tfor _, node := range nodepath {\n\t\t\t\t\tstmt, ok := node.(ast.Stmt)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tfor i := range s.mainBody.List {\n\t\t\t\t\t\tif s.mainBody.List[i] != stmt {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texprs := printedExprs(stmt)\n\n\t\t\t\t\t\tstmts := s.mainBody.List[0:i]\n\t\t\t\t\t\tfor _, expr := range exprs {\n\t\t\t\t\t\t\tstmts = append(stmts, &ast.ExprStmt{X: expr})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.mainBody.List = append(stmts, s.mainBody.List[i+1:]...)\n\t\t\t\t\t\tcontinue L\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdebugf(\"quickFix :: give up: %s\", err)\n\t\tbreak\n\t}\n}\n\nfunc (s *Session) clearQuickFix() {\n\t// make all import specs explicit (i.e. no \"_\").\n\tfor _, imp := range s.file.Imports {\n\t\timp.Name = nil\n\t}\n\n\tfor i := 0; i < len(s.mainBody.List); {\n\t\tstmt := s.mainBody.List[i]\n\n\t\t// remove assignment statement if it is omittable.\n\t\tif assign, ok := stmt.(*ast.AssignStmt); ok && s.isPureAssignStmt(assign) {\n\t\t\ts.mainBody.List = append(s.mainBody.List[0:i], s.mainBody.List[i+1:]...)\n\t\t\tcontinue\n\t\t}\n\n\t\t// remove expressions just for printing out\n\t\t// i.e. what causes \"evaluated but not used.\"\n\t\tif exprs := printedExprs(stmt); exprs != nil {\n\t\t\tallPure := true\n\t\t\tfor _, expr := range exprs {\n\t\t\t\tif !s.isPureExpr(expr) {\n\t\t\t\t\tallPure = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif allPure {\n\t\t\t\ts.mainBody.List = append(s.mainBody.List[0:i], s.mainBody.List[i+1:]...)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// convert possibly impure expressions to blank assignment\n\t\t\tvar trailing []ast.Stmt\n\t\t\ts.mainBody.List, trailing = s.mainBody.List[0:i], s.mainBody.List[i+1:]\n\t\t\tfor _, expr := range exprs {\n\t\t\t\tif !s.isPureExpr(expr) {\n\t\t\t\t\tt := s.typeInfo.TypeOf(expr)\n\t\t\t\t\tvar lhs []ast.Expr\n\t\t\t\t\tif t, ok := t.(*types.Tuple); ok {\n\t\t\t\t\t\tlhs = make([]ast.Expr, t.Len())\n\t\t\t\t\t\tfor i := 0; i < t.Len(); i++ {\n\t\t\t\t\t\t\tlhs[i] = ast.NewIdent(\"_\")\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlhs = []ast.Expr{ast.NewIdent(\"_\")}\n\t\t\t\t\t}\n\t\t\t\t\ts.mainBody.List = append(s.mainBody.List, &ast.AssignStmt{\n\t\t\t\t\t\tLhs: lhs, Tok: token.ASSIGN, Rhs: []ast.Expr{expr},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.mainBody.List = append(s.mainBody.List, trailing...)\n\t\t\tcontinue\n\t\t}\n\n\t\ti++\n\t}\n\n\tdebugf(\"clearQuickFix :: %s\", showNode(s.fset, s.mainBody))\n}\n\n// isPureAssignStmt returns assignment is pure and omittable.\nfunc (s *Session) isPureAssignStmt(stmt *ast.AssignStmt) bool {\n\tfor _, lhs := range stmt.Lhs {\n\t\tif !isNamedIdent(lhs, \"_\") {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor _, expr := range stmt.Rhs {\n\t\tif !s.isPureExpr(expr) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// printedExprs returns arguments of statement stmt of form \"p(x...)\"\nfunc printedExprs(stmt ast.Stmt) []ast.Expr {\n\tst, ok := stmt.(*ast.ExprStmt)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t// first check whether the expr is p(_) form\n\tcall, ok := st.X.(*ast.CallExpr)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif !isNamedIdent(call.Fun, printerName) {\n\t\treturn nil\n\t}\n\n\treturn call.Args\n}\n\nvar pureBuiltinFuncNames = map[string]bool{\n\t\"append\":  true,\n\t\"cap\":     true,\n\t\"complex\": true,\n\t\"imag\":    true,\n\t\"len\":     true,\n\t\"make\":    true,\n\t\"new\":     true,\n\t\"real\":    true,\n}\n\n// isPureExpr checks if an expression expr is \"pure\", which means\n// removing this expression will no affect the entire program.\n// - identifiers (\"x\")\n// - types\n// - selectors (\"x.y\")\n// - slices (\"a[n:m]\")\n// - literals (\"1\")\n// - type conversion (\"int(1)\")\n// - type assertion (\"x.(int)\")\n// - call of some built-in functions as listed in pureBuiltinFuncNames\nfunc (s *Session) isPureExpr(expr ast.Expr) bool {\n\tif expr == nil {\n\t\treturn true\n\t}\n\n\tswitch expr := expr.(type) {\n\tcase *ast.Ident:\n\t\treturn true\n\tcase *ast.BasicLit:\n\t\treturn true\n\tcase *ast.BinaryExpr:\n\t\treturn s.isPureExpr(expr.X) && s.isPureExpr(expr.Y)\n\tcase *ast.CallExpr:\n\t\ttv := s.typeInfo.Types[expr.Fun]\n\t\tfor _, arg := range expr.Args {\n\t\t\tif !s.isPureExpr(arg) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif tv.IsType() {\n\t\t\treturn true\n\t\t}\n\n\t\tif tv.IsBuiltin() {\n\t\t\tif ident, ok := expr.Fun.(*ast.Ident); ok {\n\t\t\t\tif pureBuiltinFuncNames[ident.Name] {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\tcase *ast.CompositeLit:\n\t\treturn true\n\tcase *ast.FuncLit:\n\t\treturn true\n\tcase *ast.IndexExpr:\n\t\treturn s.isPureExpr(expr.X) && s.isPureExpr(expr.Index)\n\tcase *ast.SelectorExpr:\n\t\treturn s.isPureExpr(expr.X)\n\tcase *ast.SliceExpr:\n\t\treturn s.isPureExpr(expr.Low) && s.isPureExpr(expr.High) && s.isPureExpr(expr.Max)\n\tcase *ast.StarExpr:\n\t\treturn s.isPureExpr(expr.X)\n\tcase *ast.TypeAssertExpr:\n\t\treturn true\n\tcase *ast.UnaryExpr:\n\t\treturn s.isPureExpr(expr.X)\n\tcase *ast.ParenExpr:\n\t\treturn s.isPureExpr(expr.X)\n\n\tcase *ast.InterfaceType:\n\t\treturn true\n\tcase *ast.ArrayType:\n\t\treturn true\n\tcase *ast.ChanType:\n\t\treturn true\n\tcase *ast.KeyValueExpr:\n\t\treturn true\n\tcase *ast.MapType:\n\t\treturn true\n\tcase *ast.StructType:\n\t\treturn true\n\tcase *ast.FuncType:\n\t\treturn true\n\n\tcase *ast.Ellipsis:\n\t\treturn true\n\n\tcase *ast.BadExpr:\n\t\treturn false\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 13.2841796875,
          "content": "package gore\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/build\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/scanner\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"golang.org/x/tools/go/packages\"\n\t\"golang.org/x/tools/imports\"\n\n\t\"github.com/motemen/go-quickfix\"\n)\n\n// Session ...\ntype Session struct {\n\ttempDir         string\n\ttempFilePath    string\n\tfile            *ast.File\n\tfset            *token.FileSet\n\ttypes           *types.Config\n\ttypeInfo        types.Info\n\textraFilePaths  []string\n\textraFiles      []*ast.File\n\tautoImport      bool\n\trequiredModules []string\n\tmainBody        *ast.BlockStmt\n\tlastStmts       []ast.Stmt\n\tlastDecls       []ast.Decl\n\tstdout          io.Writer\n\tstderr          io.Writer\n}\n\nconst printerName = \"__gore_p\"\n\nconst initialSourceTemplate = `\npackage main\n\nimport %q\n\nfunc ` + printerName + `(xs ...any) {\n\tfor _, x := range xs {\n\t\t%s\n\t}\n}\n\nfunc main() {\n}\n`\n\n// printerPkgs is a list of packages that provides pretty printing function\n// when changing this, read listModuleDirectives carefully\nvar printerPkgs = []struct {\n\tpath, version string\n\trequires      []pathVersion\n\tcode          string\n}{\n\t{\n\t\tpath: \"github.com/k0kubun/pp/v3\", version: \"v3.1.0\", code: `pp.Println(x)`,\n\t\trequires: []pathVersion{{\"github.com/mattn/go-colorable\", \"v0.1.12\"}},\n\t},\n\t{path: \"fmt\", code: `fmt.Printf(\"%#v\\n\", x)`},\n}\n\ntype pathVersion struct {\n\tpath, version string\n}\n\n// NewSession creates a new Session.\nfunc NewSession(stdout, stderr io.Writer) (*Session, error) {\n\tvar err error\n\n\ts := &Session{stdout: stdout, stderr: stderr}\n\n\ts.tempDir, err = os.MkdirTemp(\"\", \"gore-\")\n\tif err != nil {\n\t\treturn s, err\n\t}\n\ts.tempFilePath = filepath.Join(s.tempDir, \"gore_session.go\")\n\n\tif err = s.init(); err != nil {\n\t\treturn s, err\n\t}\n\n\treturn s, nil\n}\n\ntype pkgsImporter struct {\n\tdir string\n}\n\nfunc (i *pkgsImporter) Import(path string) (*types.Package, error) {\n\tpkgs, err := packages.Load(&packages.Config{\n\t\tMode:       packages.NeedTypes | packages.NeedDeps,\n\t\tDir:        i.dir,\n\t\tBuildFlags: []string{\"-mod=mod\"},\n\t}, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(pkgs) == 0 {\n\t\treturn nil, fmt.Errorf(\"path %s not found\", path)\n\t}\n\n\treturn pkgs[0].Types, nil\n}\n\nfunc (s *Session) init() (err error) {\n\ts.fset = token.NewFileSet()\n\ts.types = &types.Config{Importer: &pkgsImporter{dir: s.tempDir}}\n\ts.typeInfo = types.Info{}\n\ts.extraFilePaths = nil\n\ts.extraFiles = nil\n\n\tif err = s.initGoMod(); err != nil { // this should be before printer load for printer package requirements\n\t\treturn err\n\t}\n\n\tvar initialSource string\n\tfor _, pp := range printerPkgs {\n\t\t_, err = packages.Load(\n\t\t\t&packages.Config{\n\t\t\t\tDir:        s.tempDir,\n\t\t\t\tBuildFlags: []string{\"-mod=mod\"},\n\t\t\t},\n\t\t\tpp.path,\n\t\t)\n\t\tif err == nil {\n\t\t\tinitialSource = fmt.Sprintf(initialSourceTemplate, pp.path, pp.code)\n\t\t\tbreak\n\t\t}\n\t\tdebugf(\"could not import %q: %s\", pp.path, err)\n\t}\n\n\tif initialSource == \"\" {\n\t\treturn fmt.Errorf(\"could not load 'fmt' package: %w\", err)\n\t}\n\n\ts.file, err = parser.ParseFile(s.fset, \"gore_session.go\", initialSource, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.mainBody = s.mainFunc().Body\n\n\ts.lastStmts = nil\n\ts.lastDecls = nil\n\treturn nil\n}\n\nfunc (s *Session) mainFunc() *ast.FuncDecl {\n\treturn s.file.Scope.Lookup(\"main\").Decl.(*ast.FuncDecl)\n}\n\n// Run the session.\nfunc (s *Session) Run() error {\n\tf, err := os.Create(s.tempFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\terr = printer.Fprint(f, s.fset, s.file)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn s.goRun(append(s.extraFilePaths, s.tempFilePath))\n}\n\nfunc (s *Session) goRun(files []string) error {\n\targs := append([]string{\"run\", \"-mod=mod\"}, files...)\n\tdebugf(\"go %s\", strings.Join(args, \" \"))\n\tcmd := exec.Command(\"go\", args...)\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = s.stdout\n\tcmd.Dir = s.tempDir\n\tef := newErrFilter(s.stderr)\n\tcmd.Stderr = ef\n\tdefer ef.Close()\n\treturn cmd.Run()\n}\n\nfunc (s *Session) evalExpr(in string) (ast.Expr, error) {\n\texpr, err := parser.ParseExpr(in)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstmt := &ast.ExprStmt{\n\t\tX: &ast.CallExpr{\n\t\t\tFun:  ast.NewIdent(printerName),\n\t\t\tArgs: []ast.Expr{expr},\n\t\t},\n\t}\n\n\ts.appendStatements(stmt)\n\n\treturn expr, nil\n}\n\nfunc isNamedIdent(expr ast.Expr, name string) bool {\n\tident, ok := expr.(*ast.Ident)\n\treturn ok && ident.Name == name\n}\n\nfunc (s *Session) evalStmt(in string) error {\n\tsrc := fmt.Sprintf(\"package P; func F() { %s }\", in)\n\tf, err := parser.ParseFile(s.fset, \"stmt.go\", src, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenclosingFunc := f.Scope.Lookup(\"F\").Decl.(*ast.FuncDecl)\n\n\tdebugf(\"evalStmt :: %s\", showNode(s.fset, enclosingFunc.Body.List))\n\tvar stmts []ast.Stmt\n\n\tfor _, stmt := range enclosingFunc.Body.List {\n\t\tswitch stmt := stmt.(type) {\n\t\tcase *ast.AssignStmt:\n\t\t\tif stmt := buildPrintStmt(stmt.Lhs); stmt != nil {\n\t\t\t\tstmts = append(stmts, stmt)\n\t\t\t}\n\t\tcase *ast.DeclStmt:\n\t\t\tif decl, ok := stmt.Decl.(*ast.GenDecl); ok {\n\t\t\t\tif decl.Tok == token.TYPE {\n\t\t\t\t\ts.file.Decls = append(s.file.Decls, decl)\n\t\t\t\t\tcontinue\n\t\t\t\t} else if stmt := buildPrintStmtOfDecl(decl); stmt != nil {\n\t\t\t\t\tstmts = append(stmts, stmt)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts.appendStatements(stmt)\n\t}\n\ts.appendStatements(stmts...)\n\n\treturn nil\n}\n\nfunc buildPrintStmt(exprs []ast.Expr) ast.Stmt {\n\tvs := make([]ast.Expr, 0, len(exprs))\n\tfor _, v := range exprs {\n\t\tif !isNamedIdent(v, \"_\") {\n\t\t\tvs = append(vs, v)\n\t\t}\n\t}\n\tif len(vs) == 0 {\n\t\treturn nil\n\t}\n\treturn &ast.ExprStmt{\n\t\tX: &ast.CallExpr{\n\t\t\tFun:  ast.NewIdent(printerName),\n\t\t\tArgs: vs,\n\t\t},\n\t}\n}\n\nfunc buildPrintStmtOfDecl(decl *ast.GenDecl) ast.Stmt {\n\tvar cnt int\n\tfor _, s := range decl.Specs {\n\t\tif vs, ok := s.(*ast.ValueSpec); ok {\n\t\t\tcnt += len(vs.Values)\n\t\t}\n\t}\n\tif cnt == 0 {\n\t\treturn nil\n\t}\n\texprs := make([]ast.Expr, 0, cnt)\n\tfor _, s := range decl.Specs {\n\t\tif vs, ok := s.(*ast.ValueSpec); ok {\n\t\t\tfor _, name := range vs.Names {\n\t\t\t\texprs = append(exprs, ast.Expr(name))\n\t\t\t}\n\t\t}\n\t}\n\treturn buildPrintStmt(exprs)\n}\n\nfunc (s *Session) evalFunc(in string) error {\n\tsrc := fmt.Sprintf(\"package P; %s\", in)\n\tf, err := parser.ParseFile(s.fset, \"func.go\", src, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(f.Decls) != 1 {\n\t\treturn errors.New(\"eval func error\")\n\t}\n\tnewDecl, ok := f.Decls[0].(*ast.FuncDecl)\n\tif !ok {\n\t\treturn errors.New(\"eval func error\")\n\t}\n\tfor i, d := range s.file.Decls {\n\t\tif d, ok := d.(*ast.FuncDecl); ok && d.Name.String() == newDecl.Name.String() {\n\t\t\ts.file.Decls = append(s.file.Decls[:i], s.file.Decls[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\ts.file.Decls = append(s.file.Decls, newDecl)\n\treturn nil\n}\n\nfunc (*Session) parseTokens(in string) error {\n\tvar sc scanner.Scanner\n\tfset := token.NewFileSet()\n\tfile := fset.AddFile(\"\", fset.Base(), len(in))\n\tsc.Init(file, []byte(in), nil, 0)\n\tfor {\n\t\t_, tok, lit := sc.Scan()\n\t\tif tok == token.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif tok == token.ILLEGAL {\n\t\t\treturn fmt.Errorf(\"invalid token: %q\", string(lit))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Session) appendStatements(stmts ...ast.Stmt) {\n\ts.mainBody.List = append(s.mainBody.List, stmts...)\n}\n\n// Error ...\ntype Error string\n\n// Errors\nconst (\n\tErrContinue Error = \"<continue input>\"\n\tErrQuit     Error = \"<quit session>\"\n\tErrCmdRun   Error = \"<command failed>\"\n)\n\nfunc (e Error) Error() string {\n\treturn string(e)\n}\n\nfunc (s *Session) source(space bool) (string, error) {\n\tnormalizeNodePos(s.mainFunc())\n\n\tvar config *printer.Config\n\tif space {\n\t\tconfig = &printer.Config{\n\t\t\tMode:     printer.UseSpaces,\n\t\t\tTabwidth: 4,\n\t\t}\n\t} else {\n\t\tconfig = &printer.Config{\n\t\t\tTabwidth: 8,\n\t\t}\n\t}\n\n\tvar sb strings.Builder\n\terr := config.Fprint(&sb, s.fset, s.file)\n\treturn sb.String(), err\n}\n\nfunc (s *Session) reset() error {\n\tsource, err := s.source(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfile, err := parser.ParseFile(s.fset, \"gore_session.go\", source, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.file = file\n\ts.mainBody = s.mainFunc().Body\n\n\treturn nil\n}\n\n// Eval the input.\nfunc (s *Session) Eval(in string) error {\n\tdebugf(\"eval >>> %q\", in)\n\n\ts.clearQuickFix()\n\ts.storeCode()\n\n\tif strings.HasPrefix(strings.TrimSpace(in), \":\") {\n\t\terr := s.invokeCommand(in)\n\t\tif err != nil && err != ErrQuit {\n\t\t\tfmt.Fprintf(s.stderr, \"%s\\n\", err)\n\t\t}\n\t\treturn err\n\t}\n\n\tif _, err := s.evalExpr(in); err != nil {\n\t\tdebugf(\"expr :: err = %s\", err)\n\n\t\terr := s.evalStmt(in)\n\t\tif err != nil {\n\t\t\tdebugf(\"stmt :: err = %s\", err)\n\n\t\t\terr := s.evalFunc(in)\n\t\t\tif err != nil {\n\t\t\t\tdebugf(\"func :: err = %s\", err)\n\n\t\t\t\tif err := s.parseTokens(in); err != nil {\n\t\t\t\t\tfmt.Fprintf(s.stderr, \"%s\\n\", err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn ErrContinue\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.autoImport {\n\t\tif err := s.fixImports(); err != nil {\n\t\t\tdebugf(\"fixImports :: err = %s\", err)\n\t\t}\n\t}\n\ts.doQuickFix()\n\n\terr := s.Run()\n\tif err != nil {\n\t\tif _, ok := err.(*exec.ExitError); ok {\n\t\t\tdebugf(\"got exit error, popping out last input\")\n\t\t\ts.restoreCode()\n\t\t}\n\t\tdebugf(\"%s\", err)\n\t\terr = ErrCmdRun\n\t}\n\n\treturn err\n}\n\nfunc (s *Session) invokeCommand(in string) (err error) {\n\tin = strings.TrimLeftFunc(in, func(c rune) bool {\n\t\treturn c == ':' || unicode.IsSpace(c)\n\t})\n\ttokens := strings.Fields(in)\n\tif len(tokens) == 0 {\n\t\treturn\n\t}\n\tcmd := tokens[0]\n\targ := strings.TrimSpace(strings.TrimPrefix(in, cmd))\n\tfor _, command := range commands {\n\t\tif !command.name.matches(cmd) {\n\t\t\tcontinue\n\t\t}\n\t\terr = command.action(s, arg)\n\t\tif err != nil {\n\t\t\tif err == ErrQuit {\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = fmt.Errorf(\"%s: %s\", command.name, err)\n\t\t}\n\t\treturn\n\t}\n\treturn fmt.Errorf(\"command not found: %s\", cmd)\n}\n\n// storeCode stores current state of code so that it can be restored\nfunc (s *Session) storeCode() {\n\ts.lastStmts = s.mainBody.List\n\tif len(s.lastDecls) != len(s.file.Decls) {\n\t\ts.lastDecls = make([]ast.Decl, len(s.file.Decls))\n\t}\n\tcopy(s.lastDecls, s.file.Decls)\n}\n\n// restoreCode restores the previous code\nfunc (s *Session) restoreCode() {\n\ts.mainBody.List = s.lastStmts\n\tdecls := make([]ast.Decl, 0, len(s.file.Decls))\n\tfor _, d := range s.file.Decls {\n\t\tif d, ok := d.(*ast.FuncDecl); ok && d.Name.String() != \"main\" {\n\t\t\tfor _, ld := range s.lastDecls {\n\t\t\t\tif ld, ok := ld.(*ast.FuncDecl); ok && ld.Name.String() == d.Name.String() {\n\t\t\t\t\tdecls = append(decls, ld)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdecls = append(decls, d)\n\t}\n\ts.file.Decls = decls\n}\n\n// includeFiles imports packages and funcsions from multiple golang source\nfunc (s *Session) includeFiles(files []string) {\n\tfor _, file := range files {\n\t\ts.includeFile(file)\n\t}\n}\n\nfunc (s *Session) includeFile(file string) {\n\tcontent, err := os.ReadFile(file)\n\tif err != nil {\n\t\terrorf(\"%s\", err)\n\t\treturn\n\t}\n\n\tif err = s.importPackages(content); err != nil {\n\t\terrorf(\"%s\", err)\n\t\treturn\n\t}\n\n\tif err = s.importFile(content); err != nil {\n\t\terrorf(\"%s\", err)\n\t}\n\n\tinfof(\"added file %s\", file)\n}\n\n// importPackages includes packages defined on external file into main file\nfunc (s *Session) importPackages(src []byte) error {\n\tastf, err := parser.ParseFile(s.fset, \"\", src, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, imt := range astf.Imports {\n\t\tdebugf(\"import package: %s\", imt.Path.Value)\n\t\tif err = actionImport(s, imt.Path.Value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// importFile adds external golang file to goRun target to use its function\nfunc (s *Session) importFile(src []byte) error {\n\ttmp, err := os.CreateTemp(s.tempDir, \"gore_external_*.go\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := parser.ParseFile(s.fset, tmp.Name(), src, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// rewrite to package main\n\tf.Name.Name = \"main\"\n\n\t// remove func main()\n\tfor i, decl := range f.Decls {\n\t\tif funcDecl, ok := decl.(*ast.FuncDecl); ok {\n\t\t\tif isNamedIdent(funcDecl.Name, \"main\") {\n\t\t\t\tf.Decls = append(f.Decls[0:i], f.Decls[i+1:]...)\n\t\t\t\t// main() removed from this file, we may have to\n\t\t\t\t// remove some unused import's\n\t\t\t\tquickfix.QuickFix(s.fset, []*ast.File{f})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tout, err := os.Create(tmp.Name())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\terr = printer.Fprint(out, s.fset, f)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdebugf(\"import file: %s\", tmp.Name())\n\ts.extraFilePaths = append(s.extraFilePaths, tmp.Name())\n\ts.extraFiles = append(s.extraFiles, f)\n\n\treturn nil\n}\n\n// fixImports formats and adjusts imports for the current AST.\nfunc (s *Session) fixImports() error {\n\t// Fix against error: no required module provides package ...; try 'go get -d ...'\n\tfor _, path := range s.requiredModules {\n\t\tcmd := exec.Command(\"go\", \"get\", \"-d\", path)\n\t\tcmd.Dir = s.tempDir\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tdebugf(\"failed to go get -d %q: %s\", path, err)\n\t\t}\n\t}\n\ts.requiredModules = nil\n\n\tvar buf bytes.Buffer\n\terr := printer.Fprint(&buf, s.fset, s.file)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tformatted, err := imports.Process(\"\", buf.Bytes(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.file, err = parser.ParseFile(s.fset, \"\", formatted, parser.Mode(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.mainBody = s.mainFunc().Body\n\n\treturn nil\n}\n\nfunc (s *Session) includePackage(path string) error {\n\tpkg, err := build.Import(path, \".\", 0)\n\tif err != nil {\n\t\tvar err2 error\n\t\tpkg, err2 = build.ImportDir(path, 0)\n\t\tif err2 != nil {\n\t\t\treturn err // return package path import error, not directory import error as build.Import can also import directories if \"./foo\" is specified\n\t\t}\n\t}\n\n\tfiles := make([]string, len(pkg.GoFiles))\n\tfor i, f := range pkg.GoFiles {\n\t\tfiles[i] = filepath.Join(pkg.Dir, f)\n\t}\n\ts.includeFiles(files)\n\n\treturn nil\n}\n\n// Clear the temporary directory.\nfunc (s *Session) Clear() error {\n\treturn os.RemoveAll(s.tempDir)\n}\n"
        },
        {
          "name": "session_gomod_test.go",
          "type": "blob",
          "size": 3.9599609375,
          "content": "package gore\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc chdir(dir string) func() {\n\td, _ := os.Getwd()\n\tos.Chdir(dir)\n\treturn func() { os.Chdir(d) }\n}\n\nfunc gomodSetup(t *testing.T) {\n\ttempDir := newTempDir(t)\n\tmod1Dir := filepath.Join(tempDir, \"mod1\")\n\trequire.NoError(t, os.Mkdir(mod1Dir, 0o700))\n\trequire.NoError(t, os.WriteFile(filepath.Join(mod1Dir, \"go.mod\"), []byte(`module mod1\n`), 0o600))\n\trequire.NoError(t, os.WriteFile(filepath.Join(mod1Dir, \"mod1.go\"), []byte(`package mod1\n\nconst Value = 10\n`), 0o600))\n\n\tmod2Dir := filepath.Join(tempDir, \"mod2\")\n\trequire.NoError(t, os.Mkdir(mod2Dir, 0o700))\n\trequire.NoError(t, os.WriteFile(filepath.Join(mod2Dir, \"go.mod\"), []byte(fmt.Sprintf(`module mod2\n\nreplace mod1 => %s\n\nrequire mod1 v0.0.0-00010101000000-000000000000\n`, strconv.Quote(mod1Dir))), 0o600))\n\trequire.NoError(t, os.WriteFile(filepath.Join(mod2Dir, \"mod2.go\"), []byte(`package mod2\n\nimport \"mod1\"\n\nfunc Foo() int {\n\treturn mod1.Value\n}\n`), 0o600))\n\n\tmod3Dir := filepath.Join(mod2Dir, \"mod3\")\n\trequire.NoError(t, os.Mkdir(mod3Dir, 0o700))\n\trequire.NoError(t, os.WriteFile(filepath.Join(mod3Dir, \"mod3.go\"), []byte(`package mod3\n\nfunc Bar() string {\n\treturn \"mod3\"\n}\n`), 0o600))\n\n\tmod4Dir := filepath.Join(mod2Dir, \"mod4\")\n\trequire.NoError(t, os.Mkdir(mod4Dir, 0o700))\n\n\tt.Cleanup(chdir(mod2Dir))\n}\n\nfunc TestSessionEval_Gomod(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\tgomodSetup(t)\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`:i mod2`,\n\t\t`mod2.Foo()`,\n\t\t`mod2.Foo() + mod2.Foo()`,\n\t\t`:clear`,\n\t\t`:i mod2`,\n\t\t`mod2.Foo()`,\n\t\t`:i mod1`,\n\t\t`3 * mod1.Value`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, \"10\\n20\\n10\\n30\\n\", stdout.String())\n\tassert.Equal(t, ``, stderr.String())\n}\n\nfunc TestSessionEval_Gomod_AutoImport(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\tgomodSetup(t)\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\ts.autoImport = true\n\n\tcodes := []string{\n\t\t`mod2.Foo()`,\n\t\t`mod2.Foo() + mod2.Foo()`,\n\t\t`:clear`,\n\t\t`mod2.Foo()`,\n\t\t`3 * mod1.Value`,\n\t\t`:t mod2.Foo`,\n\t\t`:d mod2.Foo`,\n\t\t`mod3.Bar()`,\n\t\t`:t mod3.Bar`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, `10\n20\n10\n30\nfunc() int\npackage mod2 // import \"mod2\"\n\nfunc Foo() int\n\"mod3\"\nfunc() string\n`, stdout.String())\n\tassert.Equal(t, ``, stderr.String())\n}\n\nfunc TestSessionEval_Gomod_DeepDir(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\tgomodSetup(t)\n\trequire.NoError(t, os.Mkdir(\"tmp\", 0o700))\n\trequire.NoError(t, os.Chdir(\"tmp\"))\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`:i mod2`,\n\t\t`mod2.Foo()`,\n\t\t`mod2.Foo() + mod2.Foo()`,\n\t\t`:clear`,\n\t\t`:i mod2`,\n\t\t`mod2.Foo()`,\n\t\t`:i mod1`,\n\t\t`3 * mod1.Value`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, \"10\\n20\\n10\\n30\\n\", stdout.String())\n\tassert.Equal(t, ``, stderr.String())\n}\n\nfunc TestSessionEval_Gomod_Outside(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\t_ = newTempDir(t)\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`:i github.com/x-motemen/gore`,\n\t\t`gore.Session{}`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, ``, stderr.String())\n}\n\nfunc TestSessionEval_Gomod_CompleteImport(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\tgomodSetup(t)\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tpre, cands, post := s.completeWord(\":i \", 3)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Subset(t, cands, []string{\"mod2\", \"mod1\"})\n\tassert.Equal(t, post, \"\")\n\n\tpre, cands, post = s.completeWord(\":i mod2/\", 8)\n\tassert.Equal(t, \":i \", pre)\n\tassert.Subset(t, cands, []string{\"mod2/mod3\", \"mod2/mod4\"})\n\tassert.Equal(t, post, \"\")\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 9.1259765625,
          "content": "package gore\n\nimport (\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc init() {\n\tprinterPkgs = printerPkgs[1:]\n}\n\nfunc newTempDir(t *testing.T) string {\n\tdir, err := os.MkdirTemp(\"\", \"gore-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() { os.RemoveAll(dir) })\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() { os.Chdir(wd) })\n\n\terr = os.Chdir(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dir\n}\n\nfunc TestSessionEval_import(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t\":import encoding/json\",\n\t\t\"b, err := json.Marshal(nil)\",\n\t\t\"string(b)\",\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, `[]byte{0x6e, 0x75, 0x6c, 0x6c}\n<nil>\n\"null\"\n`, stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_QuickFix_evaluated_but_not_used(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`[]byte(\"\")`,\n\t\t`make([]int, 0)`,\n\t\t`1+1`,\n\t\t`func() {}`,\n\t\t`(4 & (1 << 1))`,\n\t\t`1`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tr := regexp.MustCompile(`0x[0-9a-f]+`)\n\tassert.Equal(t, `[]byte{}\n[]int{}\n2\n(func())(...)\n0\n1\n`, r.ReplaceAllString(stdout.String(), \"...\"))\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_QuickFix_used_as_value(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`:import log`,\n\t\t`a := 1`,\n\t\t`log.SetPrefix(\"\")`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, \"1\\n\", stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_QuickFix_no_new_variables(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`var a, b int`,\n\t\t`a := 2`,\n\t\t`b := a * 2`,\n\t\t`a := 3`,\n\t\t`c := a * b`,\n\t\t`c := b * c`,\n\t\t`b := c * a`,\n\t\t`a * b * c`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, `2\n4\n3\n12\n48\n144\n20736\n`, stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_AutoImport(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\ts.autoImport = true\n\n\tcodes := []string{\n\t\t`filepath.Join(\"a\", \"b\")`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, \"\\\"a/b\\\"\\n\", stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSession_IncludePackage(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\terr = s.includePackage(\"github.com/x-motemen/gore/gocode\")\n\trequire.NoError(t, err)\n\n\terr = s.Eval(\"Completer{}\")\n\trequire.NoError(t, err)\n}\n\nfunc TestSessionEval_Copy(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`a := []string{\"hello\", \"world\"}`,\n\t\t`b := []string{\"goodbye\", \"world\"}`,\n\t\t`copy(a, b)`,\n\t\t`a[0]`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, `[]string{\"hello\", \"world\"}\n[]string{\"goodbye\", \"world\"}\n2\n\"goodbye\"\n`, stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_Const(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`const ( a = iota; b )`,\n\t\t`a`,\n\t\t`b`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, \"0\\n1\\n0\\n1\\n\", stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_Declarations(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`var a, b int = 10, 20`,\n\t\t`var (x int = 10; y string = \"hello\"; z uint64; w error; v func(string)int)`,\n\t}\n\n\tfor _, code := range codes {\n\t\terr := s.Eval(code)\n\t\trequire.NoError(t, err)\n\t}\n\n\tassert.Equal(t, `10\n20\n10\n\"hello\"\n0x0\n<nil>\n(func(string) int)(nil)\n`, stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_NotUsed(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`f := func() []int { return []int{1, 2, 3} }`,\n\t\t`len(f())`,\n\t\t`3`,\n\t\t`len(f()) + len(f())`,\n\t\t`var x int`,\n\t\t`g := func() int { x++; return 128 }`,\n\t\t`g() + g()`,\n\t\t`g() * g()`,\n\t\t`x`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tr := regexp.MustCompile(`0x[0-9a-f]+`)\n\tassert.Equal(t, `(func() []int)(...)\n3\n3\n6\n(func() int)(...)\n256\n16384\n4\n`, r.ReplaceAllString(stdout.String(), \"...\"))\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_MultipleValues(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`var err error`,\n\t\t`:import fmt`,\n\t\t`fmt.Print()`,\n\t\t`fmt.Print()`,\n\t\t`:import io`,\n\t\t`_, err = func() (int, error) { return 0, io.EOF }()`,\n\t\t`err.Error()`,\n\t\t`var x int`,\n\t\t`x, err = 10, fmt.Errorf(\"test\")`,\n\t\t`x`,\n\t\t`err.Error()`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, `0\n<nil>\n0\n<nil>\n&errors.errorString{s:\"EOF\"}\n\"EOF\"\n10\n&errors.errorString{s:\"test\"}\n10\n\"test\"\n`, stdout.String())\n\tassert.Equal(t, \"\", stderr.String())\n}\n\nfunc TestSessionEval_Struct(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`type X struct { v int }`,\n\t\t`func (x *X) add(v int) { x.v += v }`,\n\t\t`var x X`,\n\t\t`x`,\n\t\t`x.add(1)`,\n\t\t`x`,\n\t\t`x.add(2)`,\n\t\t`x`,\n\t\t`type Y X; type Z Y;`,\n\t\t`func (z *Z) sub(v int) { z.v -= v }`,\n\t\t`var z Z`,\n\t\t`z.sub(3)`,\n\t\t`z`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Contains(t, stdout.String(), `main.X{v:0}\nmain.X{v:1}\nmain.X{v:3}\nmain.Z{v:-3}`)\n\tassert.Equal(t, ``, stderr.String())\n}\n\nfunc TestSessionEval_Func(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`func f() int { return 100 }`,\n\t\t`func g() string { return \"hello, world\" }`,\n\t\t`func h() int { s := \"\"; return s }`,\n\t\t`f() + len(g())`,\n\t\t`func f() int { return 200 }`,\n\t\t`f() * len(g())`,\n\t\t`func f() string { i := 100; return i }`,\n\t\t`f() | len(g())`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, \"112\\n2400\\n204\\n\", stdout.String())\n\tassert.Regexp(t, `cannot use s \\((?:variable of )?type string\\) as (?:type int|int value) in return (?:argument|statement)\ninvalid operation: f\\(\\) \\+ len\\(g\\(\\)\\) \\(mismatched types string and int\\)\ninvalid operation: f\\(\\) \\* len\\(g\\(\\)\\) \\(mismatched types string and int\\)\ncannot use i \\((?:variable of )?type int\\) as (?:type string|string value) in return (?:argument|statement)\n`, stderr.String())\n}\n\nfunc TestSessionEval_TokenError(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`foo\\`,\n\t\t`ba # r`,\n\t\t`$ + 3`,\n\t\t\"`foo\",\n\t\t\"`foo\\nbar`\",\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, \"\\\"foo\\\\nbar\\\"\\n\", stdout.String())\n\tassert.Equal(t, `invalid token: \"\\\\\"\ninvalid token: \"#\"\ninvalid token: \"$\"\n`, stderr.String())\n}\n\nfunc TestSessionEval_CompileError(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\tcodes := []string{\n\t\t`foo`,\n\t\t`func f() int { return 100 }`,\n\t\t`func g() string { return \"hello\" }`,\n\t\t`len(f())`,\n\t\t`len(g())`,\n\t\t`f() + g()`,\n\t\t`f() + len(g())`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Equal(t, \"5\\n105\\n\", stdout.String())\n\tassert.Regexp(t, `undefined: foo\ninvalid argument:? f\\(\\) \\((?:value of )?type int\\) for len\ninvalid operation: f\\(\\) \\+ g\\(\\) \\(mismatched types int and string\\)\n`, stderr.String())\n}\n\nfunc TestSession_ExtraFiles(t *testing.T) {\n\tvar stdout, stderr strings.Builder\n\t_ = newTempDir(t)\n\trequire.NoError(t, os.WriteFile(\"test.go\", []byte(`package test\n\n// V is a value\nvar V = 42\n`), 0o644))\n\ts, err := NewSession(&stdout, &stderr)\n\tt.Cleanup(func() { s.Clear() })\n\trequire.NoError(t, err)\n\n\ts.includeFiles([]string{\"test.go\"})\n\tcodes := []string{\n\t\t`V`,\n\t\t`:type V`,\n\t\t`:doc V`,\n\t}\n\n\tfor _, code := range codes {\n\t\t_ = s.Eval(code)\n\t}\n\n\tassert.Contains(t, stdout.String(), `42\nint\npackage builtin`)\n\tassert.Equal(t, ``, stderr.String())\n}\n"
        },
        {
          "name": "terminal_unix.go",
          "type": "blob",
          "size": 0.1572265625,
          "content": "//go:build !windows\n// +build !windows\n\npackage gore\n\nimport (\n\t\"fmt\"\n)\n\nfunc cursorUp() {\n\tfmt.Print(\"\\x1b[1A\")\n}\n\nfunc eraseInLine() {\n\tfmt.Print(\"\\x1b[0K\")\n}\n"
        },
        {
          "name": "terminal_windows.go",
          "type": "blob",
          "size": 1.5966796875,
          "content": "package gore\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\ntype (\n\tshort int16\n\tword  uint16\n)\n\ntype coord struct {\n\tx short\n\ty short\n}\n\ntype smallRect struct {\n\tleft   short\n\ttop    short\n\tright  short\n\tbottom short\n}\n\ntype consoleScreenBufferInfo struct {\n\tsize              coord\n\tcursorPosition    coord\n\tattributes        word\n\twindow            smallRect\n\tmaximumWindowSize coord\n}\n\nvar (\n\tkernel32                       = syscall.NewLazyDLL(\"kernel32.dll\")\n\tprocGetStdHandle               = kernel32.NewProc(\"GetStdHandle\")\n\tprocGetConsoleScreenBufferInfo = kernel32.NewProc(\"GetConsoleScreenBufferInfo\")\n\tprocSetConsoleCursorPosition   = kernel32.NewProc(\"SetConsoleCursorPosition\")\n\tprocFillConsoleOutputCharacter = kernel32.NewProc(\"FillConsoleOutputCharacterW\")\n\n\tstdoutHandle uintptr\n)\n\nfunc init() {\n\tstdoutHandle = getStdHandle(syscall.STD_OUTPUT_HANDLE)\n}\n\nfunc getStdHandle(stdhandle int32) uintptr {\n\thandle, _, _ := procGetStdHandle.Call(uintptr(stdhandle))\n\treturn handle\n}\n\nfunc cursorUp() {\n\tvar csbi consoleScreenBufferInfo\n\tprocGetConsoleScreenBufferInfo.Call(stdoutHandle, uintptr(unsafe.Pointer(&csbi)))\n\n\tvar cursor coord\n\tcursor.x = csbi.cursorPosition.x\n\tcursor.y = csbi.cursorPosition.y - 1\n\n\tprocSetConsoleCursorPosition.Call(stdoutHandle, uintptr(*(*int32)(unsafe.Pointer(&cursor))))\n}\n\nfunc eraseInLine() {\n\tvar csbi consoleScreenBufferInfo\n\tprocGetConsoleScreenBufferInfo.Call(stdoutHandle, uintptr(unsafe.Pointer(&csbi)))\n\n\tvar w uint32\n\tprocFillConsoleOutputCharacter.Call(stdoutHandle, uintptr(' '), uintptr(csbi.size.x), uintptr(*(*int32)(unsafe.Pointer(&csbi.cursorPosition))), uintptr(unsafe.Pointer(&w)))\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.19140625,
          "content": "package gore\n\nimport (\n\t\"go/printer\"\n\t\"go/token\"\n\t\"strings\"\n)\n\nfunc showNode(fset *token.FileSet, node any) string {\n\tvar sb strings.Builder\n\tprinter.Fprint(&sb, fset, node)\n\treturn sb.String()\n}\n"
        }
      ]
    }
  ]
}