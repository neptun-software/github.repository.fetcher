{
  "metadata": {
    "timestamp": 1736567728872,
    "page": 315,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dop251/goja",
      "stars": 5754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": ".idea\n*.iml\ntestdata/test262\n"
        },
        {
          "name": ".tc39_test262_checkout.sh",
          "type": "blob",
          "size": 0.2822265625,
          "content": "#!/bin/sh -e\n# this is just the commit it was last tested with\nsha=cb4a6c8074671c00df8cbc17a620c0f9462b312a\n\nmkdir -p testdata/test262\ncd testdata/test262\ngit init\ngit remote add origin https://github.com/tc39/test262.git\ngit fetch origin --depth=1 \"${sha}\"\ngit reset --hard \"${sha}\"\ncd -\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "Copyright (c) 2016 Dmitry Panov\n\nCopyright (c) 2012 Robert Krimen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.8818359375,
          "content": "goja\n====\n\nECMAScript 5.1(+) implementation in Go.\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/dop251/goja.svg)](https://pkg.go.dev/github.com/dop251/goja)\n\nGoja is an implementation of ECMAScript 5.1 in pure Go with emphasis on standard compliance and\nperformance.\n\nThis project was largely inspired by [otto](https://github.com/robertkrimen/otto).\n\nThe minimum required Go version is 1.20.\n\nFeatures\n--------\n\n * Full ECMAScript 5.1 support (including regex and strict mode).\n * Passes nearly all [tc39 tests](https://github.com/tc39/test262) for the features implemented so far. The goal is to\n   pass all of them. See .tc39_test262_checkout.sh for the latest working commit id.\n * Capable of running Babel, Typescript compiler and pretty much anything written in ES5.\n * Sourcemaps.\n * Most of ES6 functionality, still work in progress, see https://github.com/dop251/goja/milestone/1?closed=1\n\nKnown incompatibilities and caveats\n-----------------------------------\n\n### WeakMap\nWeakMap is implemented by embedding references to the values into the keys. This means that as long\nas the key is reachable all values associated with it in any weak maps also remain reachable and therefore\ncannot be garbage collected even if they are not otherwise referenced, even after the WeakMap is gone.\nThe reference to the value is dropped either when the key is explicitly removed from the WeakMap or when the\nkey becomes unreachable.\n\nTo illustrate this:\n\n```javascript\nvar m = new WeakMap();\nvar key = {};\nvar value = {/* a very large object */};\nm.set(key, value);\nvalue = undefined;\nm = undefined; // The value does NOT become garbage-collectable at this point\nkey = undefined; // Now it does\n// m.delete(key); // This would work too\n```\n\nThe reason for it is the limitation of the Go runtime. At the time of writing (version 1.15) having a finalizer\nset on an object which is part of a reference cycle makes the whole cycle non-garbage-collectable. The solution\nabove is the only reasonable way I can think of without involving finalizers. This is the third attempt\n(see https://github.com/dop251/goja/issues/250 and https://github.com/dop251/goja/issues/199 for more details).\n\nNote, this does not have any effect on the application logic, but may cause a higher-than-expected memory usage.\n\n### WeakRef and FinalizationRegistry\nFor the reason mentioned above implementing WeakRef and FinalizationRegistry does not seem to be possible at this stage.\n\n### JSON\n`JSON.parse()` uses the standard Go library which operates in UTF-8. Therefore, it cannot correctly parse broken UTF-16\nsurrogate pairs, for example:\n\n```javascript\nJSON.parse(`\"\\\\uD800\"`).charCodeAt(0).toString(16) // returns \"fffd\" instead of \"d800\"\n```\n\n### Date\nConversion from calendar date to epoch timestamp uses the standard Go library which uses `int`, rather than `float` as per\nECMAScript specification. This means if you pass arguments that overflow int to the `Date()` constructor or  if there is\nan integer overflow, the result will be incorrect, for example:\n\n```javascript\nDate.UTC(1970, 0, 1, 80063993375, 29, 1, -288230376151711740) // returns 29256 instead of 29312\n```\n\nFAQ\n---\n\n### How fast is it?\n\nAlthough it's faster than many scripting language implementations in Go I have seen\n(for example it's 6-7 times faster than otto on average) it is not a\nreplacement for V8 or SpiderMonkey or any other general-purpose JavaScript engine.\nYou can find some benchmarks [here](https://github.com/dop251/goja/issues/2).\n\n### Why would I want to use it over a V8 wrapper?\n\nIt greatly depends on your usage scenario. If most of the work is done in javascript\n(for example crypto or any other heavy calculations) you are definitely better off with V8.\n\nIf you need a scripting language that drives an engine written in Go so that\nyou need to make frequent calls between Go and javascript passing complex data structures\nthen the cgo overhead may outweigh the benefits of having a faster javascript engine.\n\nBecause it's written in pure Go there are no cgo dependencies, it's very easy to build and it\nshould run on any platform supported by Go.\n\nIt gives you a much better control over execution environment so can be useful for research.\n\n### Is it goroutine-safe?\n\nNo. An instance of goja.Runtime can only be used by a single goroutine\nat a time. You can create as many instances of Runtime as you like but\nit's not possible to pass object values between runtimes.\n\n### Where is setTimeout()?\n\nsetTimeout() assumes concurrent execution of code which requires an execution\nenvironment, for example an event loop similar to nodejs or a browser.\nThere is a [separate project](https://github.com/dop251/goja_nodejs) aimed at providing some NodeJS functionality,\nand it includes an event loop.\n\n### Can you implement (feature X from ES6 or higher)?\n\nI will be adding features in their dependency order and as quickly as time permits. Please do not ask\nfor ETAs. Features that are open in the [milestone](https://github.com/dop251/goja/milestone/1) are either in progress\nor will be worked on next.\n\nThe ongoing work is done in separate feature branches which are merged into master when appropriate.\nEvery commit in these branches represents a relatively stable state (i.e. it compiles and passes all enabled tc39 tests),\nhowever because the version of tc39 tests I use is quite old, it may be not as well tested as the ES5.1 functionality. Because there are (usually) no major breaking changes between ECMAScript revisions\nit should not break your existing code. You are encouraged to give it a try and report any bugs found. Please do not submit fixes though without discussing it first, as the code could be changed in the meantime.\n\n### How do I contribute?\n\nBefore submitting a pull request please make sure that:\n\n- You followed ECMA standard as close as possible. If adding a new feature make sure you've read the specification,\ndo not just base it on a couple of examples that work fine.\n- Your change does not have a significant negative impact on performance (unless it's a bugfix and it's unavoidable)\n- It passes all relevant tc39 tests.\n\nCurrent Status\n--------------\n\n * There should be no breaking changes in the API, however it may be extended.\n * Some of the AnnexB functionality is missing.\n\nBasic Example\n-------------\n\nRun JavaScript and get the result value.\n\n```go\nvm := goja.New()\nv, err := vm.RunString(\"2 + 2\")\nif err != nil {\n    panic(err)\n}\nif num := v.Export().(int64); num != 4 {\n    panic(num)\n}\n```\n\nPassing Values to JS\n--------------------\nAny Go value can be passed to JS using Runtime.ToValue() method. See the method's [documentation](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) for more details.\n\nExporting Values from JS\n------------------------\nA JS value can be exported into its default Go representation using Value.Export() method.\n\nAlternatively it can be exported into a specific Go variable using [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo) method.\n\nWithin a single export operation the same Object will be represented by the same Go value (either the same map, slice or\na pointer to the same struct). This includes circular objects and makes it possible to export them.\n\nCalling JS functions from Go\n----------------------------\nThere are 2 approaches:\n\n- Using [AssertFunction()](https://pkg.go.dev/github.com/dop251/goja#AssertFunction):\n```go\nconst SCRIPT = `\nfunction sum(a, b) {\n    return +a + b;\n}\n`\n\nvm := goja.New()\n_, err := vm.RunString(SCRIPT)\nif err != nil {\n    panic(err)\n}\nsum, ok := goja.AssertFunction(vm.Get(\"sum\"))\nif !ok {\n    panic(\"Not a function\")\n}\n\nres, err := sum(goja.Undefined(), vm.ToValue(40), vm.ToValue(2))\nif err != nil {\n    panic(err)\n}\nfmt.Println(res)\n// Output: 42\n```\n- Using [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo):\n```go\nconst SCRIPT = `\nfunction sum(a, b) {\n    return +a + b;\n}\n`\n\nvm := goja.New()\n_, err := vm.RunString(SCRIPT)\nif err != nil {\n    panic(err)\n}\n\nvar sum func(int, int) int\nerr = vm.ExportTo(vm.Get(\"sum\"), &sum)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(sum(40, 2)) // note, _this_ value in the function will be undefined.\n// Output: 42\n```\n\nThe first one is more low level and allows specifying _this_ value, whereas the second one makes the function look like\na normal Go function.\n\nMapping struct field and method names\n-------------------------------------\nBy default, the names are passed through as is which means they are capitalised. This does not match\nthe standard JavaScript naming convention, so if you need to make your JS code look more natural or if you are\ndealing with a 3rd party library, you can use a [FieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#FieldNameMapper):\n\n```go\nvm := goja.New()\nvm.SetFieldNameMapper(TagFieldNameMapper(\"json\", true))\ntype S struct {\n    Field int `json:\"field\"`\n}\nvm.Set(\"s\", S{Field: 42})\nres, _ := vm.RunString(`s.field`) // without the mapper it would have been s.Field\nfmt.Println(res.Export())\n// Output: 42\n```\n\nThere are two standard mappers: [TagFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#TagFieldNameMapper) and\n[UncapFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#UncapFieldNameMapper), or you can use your own implementation.\n\nNative Constructors\n-------------------\n\nIn order to implement a constructor function in Go use `func (goja.ConstructorCall) *goja.Object`.\nSee [Runtime.ToValue()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) documentation for more details.\n\nRegular Expressions\n-------------------\n\nGoja uses the embedded Go regexp library where possible, otherwise it falls back to [regexp2](https://github.com/dlclark/regexp2).\n\nExceptions\n----------\n\nAny exception thrown in JavaScript is returned as an error of type *Exception. It is possible to extract the value thrown\nby using the Value() method:\n\n```go\nvm := goja.New()\n_, err := vm.RunString(`\n\nthrow(\"Test\");\n\n`)\n\nif jserr, ok := err.(*Exception); ok {\n    if jserr.Value().Export() != \"Test\" {\n        panic(\"wrong value\")\n    }\n} else {\n    panic(\"wrong type\")\n}\n```\n\nIf a native Go function panics with a Value, it is thrown as a Javascript exception (and therefore can be caught):\n\n```go\nvar vm *Runtime\n\nfunc Test() {\n    panic(vm.ToValue(\"Error\"))\n}\n\nvm = goja.New()\nvm.Set(\"Test\", Test)\n_, err := vm.RunString(`\n\ntry {\n    Test();\n} catch(e) {\n    if (e !== \"Error\") {\n        throw e;\n    }\n}\n\n`)\n\nif err != nil {\n    panic(err)\n}\n```\n\nInterrupting\n------------\n\n```go\nfunc TestInterrupt(t *testing.T) {\n    const SCRIPT = `\n    var i = 0;\n    for (;;) {\n        i++;\n    }\n    `\n\n    vm := goja.New()\n    time.AfterFunc(200 * time.Millisecond, func() {\n        vm.Interrupt(\"halt\")\n    })\n\n    _, err := vm.RunString(SCRIPT)\n    if err == nil {\n        t.Fatal(\"Err is nil\")\n    }\n    // err is of type *InterruptError and its Value() method returns whatever has been passed to vm.Interrupt()\n}\n```\n\nNodeJS Compatibility\n--------------------\n\nThere is a [separate project](https://github.com/dop251/goja_nodejs) aimed at providing some of the NodeJS functionality.\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 13.3759765625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/bits\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype arrayIterObject struct {\n\tbaseObject\n\tobj     *Object\n\tnextIdx int64\n\tkind    iterationKind\n}\n\nfunc (ai *arrayIterObject) next() Value {\n\tif ai.obj == nil {\n\t\treturn ai.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\tif ta, ok := ai.obj.self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t}\n\tl := toLength(ai.obj.self.getStr(\"length\", nil))\n\tindex := ai.nextIdx\n\tif index >= l {\n\t\tai.obj = nil\n\t\treturn ai.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\tai.nextIdx++\n\tidxVal := valueInt(index)\n\tif ai.kind == iterationKindKey {\n\t\treturn ai.val.runtime.createIterResultObject(idxVal, false)\n\t}\n\telementValue := nilSafe(ai.obj.self.getIdx(idxVal, nil))\n\tvar result Value\n\tif ai.kind == iterationKindValue {\n\t\tresult = elementValue\n\t} else {\n\t\tresult = ai.val.runtime.newArrayValues([]Value{idxVal, elementValue})\n\t}\n\treturn ai.val.runtime.createIterResultObject(result, false)\n}\n\nfunc (r *Runtime) createArrayIterator(iterObj *Object, kind iterationKind) Value {\n\to := &Object{runtime: r}\n\n\tai := &arrayIterObject{\n\t\tobj:  iterObj,\n\t\tkind: kind,\n\t}\n\tai.class = classObject\n\tai.val = o\n\tai.extensible = true\n\to.self = ai\n\tai.prototype = r.getArrayIteratorPrototype()\n\tai.init()\n\n\treturn o\n}\n\ntype arrayObject struct {\n\tbaseObject\n\tvalues         []Value\n\tlength         uint32\n\tobjCount       int\n\tpropValueCount int\n\tlengthProp     valueProperty\n}\n\nfunc (a *arrayObject) init() {\n\ta.baseObject.init()\n\ta.lengthProp.writable = true\n\n\ta._put(\"length\", &a.lengthProp)\n}\n\nfunc (a *arrayObject) _setLengthInt(l uint32, throw bool) bool {\n\tret := true\n\tif l <= a.length {\n\t\tif a.propValueCount > 0 {\n\t\t\t// Slow path\n\t\t\tfor i := len(a.values) - 1; i >= int(l); i-- {\n\t\t\t\tif prop, ok := a.values[i].(*valueProperty); ok {\n\t\t\t\t\tif !prop.configurable {\n\t\t\t\t\t\tl = uint32(i) + 1\n\t\t\t\t\t\tret = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ta.propValueCount--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif l <= uint32(len(a.values)) {\n\t\tif l >= 16 && l < uint32(cap(a.values))>>2 {\n\t\t\tar := make([]Value, l)\n\t\t\tcopy(ar, a.values)\n\t\t\ta.values = ar\n\t\t} else {\n\t\t\tar := a.values[l:len(a.values)]\n\t\t\tfor i := range ar {\n\t\t\t\tar[i] = nil\n\t\t\t}\n\t\t\ta.values = a.values[:l]\n\t\t}\n\t}\n\ta.length = l\n\tif !ret {\n\t\ta.val.runtime.typeErrorResult(throw, \"Cannot redefine property: length\")\n\t}\n\treturn ret\n}\n\nfunc (a *arrayObject) setLengthInt(l uint32, throw bool) bool {\n\tif l == a.length {\n\t\treturn true\n\t}\n\tif !a.lengthProp.writable {\n\t\ta.val.runtime.typeErrorResult(throw, \"length is not writable\")\n\t\treturn false\n\t}\n\treturn a._setLengthInt(l, throw)\n}\n\nfunc (a *arrayObject) setLength(v uint32, throw bool) bool {\n\tif !a.lengthProp.writable {\n\t\ta.val.runtime.typeErrorResult(throw, \"length is not writable\")\n\t\treturn false\n\t}\n\treturn a._setLengthInt(v, throw)\n}\n\nfunc (a *arrayObject) getIdx(idx valueInt, receiver Value) Value {\n\tprop := a.getOwnPropIdx(idx)\n\tif prop == nil {\n\t\tif a.prototype != nil {\n\t\t\tif receiver == nil {\n\t\t\t\treturn a.prototype.self.getIdx(idx, a.val)\n\t\t\t}\n\t\t\treturn a.prototype.self.getIdx(idx, receiver)\n\t\t}\n\t}\n\tif prop, ok := prop.(*valueProperty); ok {\n\t\tif receiver == nil {\n\t\t\treturn prop.get(a.val)\n\t\t}\n\t\treturn prop.get(receiver)\n\t}\n\treturn prop\n}\n\nfunc (a *arrayObject) getOwnPropStr(name unistring.String) Value {\n\tif len(a.values) > 0 {\n\t\tif i := strToArrayIdx(name); i != math.MaxUint32 {\n\t\t\tif i < uint32(len(a.values)) {\n\t\t\t\treturn a.values[i]\n\t\t\t}\n\t\t}\n\t}\n\tif name == \"length\" {\n\t\treturn a.getLengthProp()\n\t}\n\treturn a.baseObject.getOwnPropStr(name)\n}\n\nfunc (a *arrayObject) getOwnPropIdx(idx valueInt) Value {\n\tif i := toIdx(idx); i != math.MaxUint32 {\n\t\tif i < uint32(len(a.values)) {\n\t\t\treturn a.values[i]\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn a.baseObject.getOwnPropStr(idx.string())\n}\n\nfunc (a *arrayObject) sortLen() int {\n\treturn len(a.values)\n}\n\nfunc (a *arrayObject) sortGet(i int) Value {\n\tv := a.values[i]\n\tif p, ok := v.(*valueProperty); ok {\n\t\tv = p.get(a.val)\n\t}\n\treturn v\n}\n\nfunc (a *arrayObject) swap(i int, j int) {\n\ta.values[i], a.values[j] = a.values[j], a.values[i]\n}\n\nfunc (a *arrayObject) getStr(name unistring.String, receiver Value) Value {\n\treturn a.getStrWithOwnProp(a.getOwnPropStr(name), name, receiver)\n}\n\nfunc (a *arrayObject) getLengthProp() *valueProperty {\n\ta.lengthProp.value = intToValue(int64(a.length))\n\treturn &a.lengthProp\n}\n\nfunc (a *arrayObject) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\tif i := toIdx(idx); i != math.MaxUint32 {\n\t\treturn a._setOwnIdx(i, val, throw)\n\t} else {\n\t\treturn a.baseObject.setOwnStr(idx.string(), val, throw)\n\t}\n}\n\nfunc (a *arrayObject) _setOwnIdx(idx uint32, val Value, throw bool) bool {\n\tvar prop Value\n\tif idx < uint32(len(a.values)) {\n\t\tprop = a.values[idx]\n\t}\n\n\tif prop == nil {\n\t\tif proto := a.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, ok := proto.self.setForeignIdx(valueInt(idx), val, a.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\t// new property\n\t\tif !a.extensible {\n\t\t\ta.val.runtime.typeErrorResult(throw, \"Cannot add property %d, object is not extensible\", idx)\n\t\t\treturn false\n\t\t} else {\n\t\t\tif idx >= a.length {\n\t\t\t\tif !a.setLengthInt(idx+1, throw) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif idx >= uint32(len(a.values)) {\n\t\t\t\tif !a.expand(idx) {\n\t\t\t\t\ta.val.self.(*sparseArrayObject).add(idx, val)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.objCount++\n\t\t}\n\t} else {\n\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\tif !prop.isWritable() {\n\t\t\t\ta.val.runtime.typeErrorResult(throw)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tprop.set(a.val, val)\n\t\t\treturn true\n\t\t}\n\t}\n\ta.values[idx] = val\n\treturn true\n}\n\nfunc (a *arrayObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._setOwnIdx(idx, val, throw)\n\t} else {\n\t\tif name == \"length\" {\n\t\t\treturn a.setLength(a.val.runtime.toLengthUint32(val), throw)\n\t\t} else {\n\t\t\treturn a.baseObject.setOwnStr(name, val, throw)\n\t\t}\n\t}\n}\n\nfunc (a *arrayObject) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn a._setForeignIdx(idx, a.getOwnPropIdx(idx), val, receiver, throw)\n}\n\nfunc (a *arrayObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn a._setForeignStr(name, a.getOwnPropStr(name), val, receiver, throw)\n}\n\ntype arrayPropIter struct {\n\ta     *arrayObject\n\tlimit int\n\tidx   int\n}\n\nfunc (i *arrayPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.a.values) && i.idx < i.limit {\n\t\tname := asciiString(strconv.Itoa(i.idx))\n\t\tprop := i.a.values[i.idx]\n\t\ti.idx++\n\t\tif prop != nil {\n\t\t\treturn propIterItem{name: name, value: prop}, i.next\n\t\t}\n\t}\n\n\treturn i.a.baseObject.iterateStringKeys()()\n}\n\nfunc (a *arrayObject) iterateStringKeys() iterNextFunc {\n\treturn (&arrayPropIter{\n\t\ta:     a,\n\t\tlimit: len(a.values),\n\t}).next\n}\n\nfunc (a *arrayObject) stringKeys(all bool, accum []Value) []Value {\n\tfor i, prop := range a.values {\n\t\tname := strconv.Itoa(i)\n\t\tif prop != nil {\n\t\t\tif !all {\n\t\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.enumerable {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\taccum = append(accum, asciiString(name))\n\t\t}\n\t}\n\treturn a.baseObject.stringKeys(all, accum)\n}\n\nfunc (a *arrayObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn idx < uint32(len(a.values)) && a.values[idx] != nil\n\t} else {\n\t\treturn a.baseObject.hasOwnPropertyStr(name)\n\t}\n}\n\nfunc (a *arrayObject) hasOwnPropertyIdx(idx valueInt) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn idx < uint32(len(a.values)) && a.values[idx] != nil\n\t}\n\treturn a.baseObject.hasOwnPropertyStr(idx.string())\n}\n\nfunc (a *arrayObject) hasPropertyIdx(idx valueInt) bool {\n\tif a.hasOwnPropertyIdx(idx) {\n\t\treturn true\n\t}\n\n\tif a.prototype != nil {\n\t\treturn a.prototype.self.hasPropertyIdx(idx)\n\t}\n\n\treturn false\n}\n\nfunc (a *arrayObject) expand(idx uint32) bool {\n\ttargetLen := idx + 1\n\tif targetLen > uint32(len(a.values)) {\n\t\tif targetLen < uint32(cap(a.values)) {\n\t\t\ta.values = a.values[:targetLen]\n\t\t} else {\n\t\t\tif idx > 4096 && (a.objCount == 0 || idx/uint32(a.objCount) > 10) {\n\t\t\t\t//log.Println(\"Switching standard->sparse\")\n\t\t\t\tsa := &sparseArrayObject{\n\t\t\t\t\tbaseObject:     a.baseObject,\n\t\t\t\t\tlength:         a.length,\n\t\t\t\t\tpropValueCount: a.propValueCount,\n\t\t\t\t}\n\t\t\t\tsa.setValues(a.values, a.objCount+1)\n\t\t\t\tsa.val.self = sa\n\t\t\t\tsa.lengthProp.writable = a.lengthProp.writable\n\t\t\t\tsa._put(\"length\", &sa.lengthProp)\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tif bits.UintSize == 32 {\n\t\t\t\t\tif targetLen >= math.MaxInt32 {\n\t\t\t\t\t\tpanic(a.val.runtime.NewTypeError(\"Array index overflows int\"))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttl := int(targetLen)\n\t\t\t\tnewValues := make([]Value, tl, growCap(tl, len(a.values), cap(a.values)))\n\t\t\t\tcopy(newValues, a.values)\n\t\t\t\ta.values = newValues\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (r *Runtime) defineArrayLength(prop *valueProperty, descr PropertyDescriptor, setter func(uint32, bool) bool, throw bool) bool {\n\tvar newLen uint32\n\tret := true\n\tif descr.Value != nil {\n\t\tnewLen = r.toLengthUint32(descr.Value)\n\t}\n\n\tif descr.Configurable == FLAG_TRUE || descr.Enumerable == FLAG_TRUE || descr.Getter != nil || descr.Setter != nil {\n\t\tret = false\n\t\tgoto Reject\n\t}\n\n\tif descr.Value != nil {\n\t\toldLen := uint32(prop.value.ToInteger())\n\t\tif oldLen != newLen {\n\t\t\tret = setter(newLen, false)\n\t\t}\n\t} else {\n\t\tret = true\n\t}\n\n\tif descr.Writable != FLAG_NOT_SET {\n\t\tw := descr.Writable.Bool()\n\t\tif prop.writable {\n\t\t\tprop.writable = w\n\t\t} else {\n\t\t\tif w {\n\t\t\t\tret = false\n\t\t\t\tgoto Reject\n\t\t\t}\n\t\t}\n\t}\n\nReject:\n\tif !ret {\n\t\tr.typeErrorResult(throw, \"Cannot redefine property: length\")\n\t}\n\n\treturn ret\n}\n\nfunc (a *arrayObject) _defineIdxProperty(idx uint32, desc PropertyDescriptor, throw bool) bool {\n\tvar existing Value\n\tif idx < uint32(len(a.values)) {\n\t\texisting = a.values[idx]\n\t}\n\tprop, ok := a.baseObject._defineOwnProperty(unistring.String(strconv.FormatUint(uint64(idx), 10)), existing, desc, throw)\n\tif ok {\n\t\tif idx >= a.length {\n\t\t\tif !a.setLengthInt(idx+1, throw) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tif a.expand(idx) {\n\t\t\ta.values[idx] = prop\n\t\t\ta.objCount++\n\t\t\tif _, ok := prop.(*valueProperty); ok {\n\t\t\t\ta.propValueCount++\n\t\t\t}\n\t\t} else {\n\t\t\ta.val.self.(*sparseArrayObject).add(idx, prop)\n\t\t}\n\t}\n\treturn ok\n}\n\nfunc (a *arrayObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._defineIdxProperty(idx, descr, throw)\n\t}\n\tif name == \"length\" {\n\t\treturn a.val.runtime.defineArrayLength(a.getLengthProp(), descr, a.setLength, throw)\n\t}\n\treturn a.baseObject.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (a *arrayObject) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._defineIdxProperty(idx, descr, throw)\n\t}\n\treturn a.baseObject.defineOwnPropertyStr(idx.string(), descr, throw)\n}\n\nfunc (a *arrayObject) _deleteIdxProp(idx uint32, throw bool) bool {\n\tif idx < uint32(len(a.values)) {\n\t\tif v := a.values[idx]; v != nil {\n\t\t\tif p, ok := v.(*valueProperty); ok {\n\t\t\t\tif !p.configurable {\n\t\t\t\t\ta.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of %s\", idx, a.val.toString())\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\ta.propValueCount--\n\t\t\t}\n\t\t\ta.values[idx] = nil\n\t\t\ta.objCount--\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (a *arrayObject) deleteStr(name unistring.String, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._deleteIdxProp(idx, throw)\n\t}\n\treturn a.baseObject.deleteStr(name, throw)\n}\n\nfunc (a *arrayObject) deleteIdx(idx valueInt, throw bool) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._deleteIdxProp(idx, throw)\n\t}\n\treturn a.baseObject.deleteStr(idx.string(), throw)\n}\n\nfunc (a *arrayObject) export(ctx *objectExportCtx) interface{} {\n\tif v, exists := ctx.get(a.val); exists {\n\t\treturn v\n\t}\n\tarr := make([]interface{}, a.length)\n\tctx.put(a.val, arr)\n\tif a.propValueCount == 0 && a.length == uint32(len(a.values)) && uint32(a.objCount) == a.length {\n\t\tfor i, v := range a.values {\n\t\t\tif v != nil {\n\t\t\t\tarr[i] = exportValue(v, ctx)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor i := uint32(0); i < a.length; i++ {\n\t\t\tv := a.getIdx(valueInt(i), nil)\n\t\t\tif v != nil {\n\t\t\t\tarr[i] = exportValue(v, ctx)\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc (a *arrayObject) exportType() reflect.Type {\n\treturn reflectTypeArray\n}\n\nfunc (a *arrayObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tr := a.val.runtime\n\tif iter := a.getSym(SymIterator, nil); iter == r.getArrayValues() || iter == nil {\n\t\tl := toIntStrict(int64(a.length))\n\t\tif typ.Kind() == reflect.Array {\n\t\t\tif dst.Len() != l {\n\t\t\t\treturn fmt.Errorf(\"cannot convert an Array into an array, lengths mismatch (have %d, need %d)\", l, dst.Len())\n\t\t\t}\n\t\t} else {\n\t\t\tdst.Set(reflect.MakeSlice(typ, l, l))\n\t\t}\n\t\tctx.putTyped(a.val, typ, dst.Interface())\n\t\tfor i := 0; i < l; i++ {\n\t\t\tif i >= len(a.values) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tval := a.values[i]\n\t\t\tif p, ok := val.(*valueProperty); ok {\n\t\t\t\tval = p.get(a.val)\n\t\t\t}\n\t\t\terr := r.toReflectValue(val, dst.Index(i), ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not convert array element %v to %v at %d: %w\", val, typ, i, err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn a.baseObject.exportToArrayOrSlice(dst, typ, ctx)\n}\n\nfunc (a *arrayObject) setValuesFromSparse(items []sparseArrayItem, newMaxIdx int) {\n\ta.values = make([]Value, newMaxIdx+1)\n\tfor _, item := range items {\n\t\ta.values[item.idx] = item.value\n\t}\n\ta.objCount = len(items)\n}\n\nfunc toIdx(v valueInt) uint32 {\n\tif v >= 0 && v < math.MaxUint32 {\n\t\treturn uint32(v)\n\t}\n\treturn math.MaxUint32\n}\n"
        },
        {
          "name": "array_sparse.go",
          "type": "blob",
          "size": 12.1337890625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/bits\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype sparseArrayItem struct {\n\tidx   uint32\n\tvalue Value\n}\n\ntype sparseArrayObject struct {\n\tbaseObject\n\titems          []sparseArrayItem\n\tlength         uint32\n\tpropValueCount int\n\tlengthProp     valueProperty\n}\n\nfunc (a *sparseArrayObject) findIdx(idx uint32) int {\n\treturn sort.Search(len(a.items), func(i int) bool {\n\t\treturn a.items[i].idx >= idx\n\t})\n}\n\nfunc (a *sparseArrayObject) _setLengthInt(l uint32, throw bool) bool {\n\tret := true\n\tif l <= a.length {\n\t\tif a.propValueCount > 0 {\n\t\t\t// Slow path\n\t\t\tfor i := len(a.items) - 1; i >= 0; i-- {\n\t\t\t\titem := a.items[i]\n\t\t\t\tif item.idx <= l {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif prop, ok := item.value.(*valueProperty); ok {\n\t\t\t\t\tif !prop.configurable {\n\t\t\t\t\t\tl = item.idx + 1\n\t\t\t\t\t\tret = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ta.propValueCount--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tidx := a.findIdx(l)\n\n\taa := a.items[idx:]\n\tfor i := range aa {\n\t\taa[i].value = nil\n\t}\n\ta.items = a.items[:idx]\n\ta.length = l\n\tif !ret {\n\t\ta.val.runtime.typeErrorResult(throw, \"Cannot redefine property: length\")\n\t}\n\treturn ret\n}\n\nfunc (a *sparseArrayObject) setLengthInt(l uint32, throw bool) bool {\n\tif l == a.length {\n\t\treturn true\n\t}\n\tif !a.lengthProp.writable {\n\t\ta.val.runtime.typeErrorResult(throw, \"length is not writable\")\n\t\treturn false\n\t}\n\treturn a._setLengthInt(l, throw)\n}\n\nfunc (a *sparseArrayObject) setLength(v uint32, throw bool) bool {\n\tif !a.lengthProp.writable {\n\t\ta.val.runtime.typeErrorResult(throw, \"length is not writable\")\n\t\treturn false\n\t}\n\treturn a._setLengthInt(v, throw)\n}\n\nfunc (a *sparseArrayObject) _getIdx(idx uint32) Value {\n\ti := a.findIdx(idx)\n\tif i < len(a.items) && a.items[i].idx == idx {\n\t\treturn a.items[i].value\n\t}\n\n\treturn nil\n}\n\nfunc (a *sparseArrayObject) getStr(name unistring.String, receiver Value) Value {\n\treturn a.getStrWithOwnProp(a.getOwnPropStr(name), name, receiver)\n}\n\nfunc (a *sparseArrayObject) getIdx(idx valueInt, receiver Value) Value {\n\tprop := a.getOwnPropIdx(idx)\n\tif prop == nil {\n\t\tif a.prototype != nil {\n\t\t\tif receiver == nil {\n\t\t\t\treturn a.prototype.self.getIdx(idx, a.val)\n\t\t\t}\n\t\t\treturn a.prototype.self.getIdx(idx, receiver)\n\t\t}\n\t}\n\tif prop, ok := prop.(*valueProperty); ok {\n\t\tif receiver == nil {\n\t\t\treturn prop.get(a.val)\n\t\t}\n\t\treturn prop.get(receiver)\n\t}\n\treturn prop\n}\n\nfunc (a *sparseArrayObject) getLengthProp() *valueProperty {\n\ta.lengthProp.value = intToValue(int64(a.length))\n\treturn &a.lengthProp\n}\n\nfunc (a *sparseArrayObject) getOwnPropStr(name unistring.String) Value {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._getIdx(idx)\n\t}\n\tif name == \"length\" {\n\t\treturn a.getLengthProp()\n\t}\n\treturn a.baseObject.getOwnPropStr(name)\n}\n\nfunc (a *sparseArrayObject) getOwnPropIdx(idx valueInt) Value {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._getIdx(idx)\n\t}\n\treturn a.baseObject.getOwnPropStr(idx.string())\n}\n\nfunc (a *sparseArrayObject) add(idx uint32, val Value) {\n\ti := a.findIdx(idx)\n\ta.items = append(a.items, sparseArrayItem{})\n\tcopy(a.items[i+1:], a.items[i:])\n\ta.items[i] = sparseArrayItem{\n\t\tidx:   idx,\n\t\tvalue: val,\n\t}\n}\n\nfunc (a *sparseArrayObject) _setOwnIdx(idx uint32, val Value, throw bool) bool {\n\tvar prop Value\n\ti := a.findIdx(idx)\n\tif i < len(a.items) && a.items[i].idx == idx {\n\t\tprop = a.items[i].value\n\t}\n\n\tif prop == nil {\n\t\tif proto := a.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, ok := proto.self.setForeignIdx(valueInt(idx), val, a.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\n\t\t// new property\n\t\tif !a.extensible {\n\t\t\ta.val.runtime.typeErrorResult(throw, \"Cannot add property %d, object is not extensible\", idx)\n\t\t\treturn false\n\t\t}\n\n\t\tif idx >= a.length {\n\t\t\tif !a.setLengthInt(idx+1, throw) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif a.expand(idx) {\n\t\t\ta.items = append(a.items, sparseArrayItem{})\n\t\t\tcopy(a.items[i+1:], a.items[i:])\n\t\t\ta.items[i] = sparseArrayItem{\n\t\t\t\tidx:   idx,\n\t\t\t\tvalue: val,\n\t\t\t}\n\t\t} else {\n\t\t\tar := a.val.self.(*arrayObject)\n\t\t\tar.values[idx] = val\n\t\t\tar.objCount++\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\tif !prop.isWritable() {\n\t\t\t\ta.val.runtime.typeErrorResult(throw)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tprop.set(a.val, val)\n\t\t} else {\n\t\t\ta.items[i].value = val\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (a *sparseArrayObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._setOwnIdx(idx, val, throw)\n\t} else {\n\t\tif name == \"length\" {\n\t\t\treturn a.setLength(a.val.runtime.toLengthUint32(val), throw)\n\t\t} else {\n\t\t\treturn a.baseObject.setOwnStr(name, val, throw)\n\t\t}\n\t}\n}\n\nfunc (a *sparseArrayObject) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._setOwnIdx(idx, val, throw)\n\t}\n\n\treturn a.baseObject.setOwnStr(idx.string(), val, throw)\n}\n\nfunc (a *sparseArrayObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn a._setForeignStr(name, a.getOwnPropStr(name), val, receiver, throw)\n}\n\nfunc (a *sparseArrayObject) setForeignIdx(name valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn a._setForeignIdx(name, a.getOwnPropIdx(name), val, receiver, throw)\n}\n\ntype sparseArrayPropIter struct {\n\ta   *sparseArrayObject\n\tidx int\n}\n\nfunc (i *sparseArrayPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.a.items) {\n\t\tname := asciiString(strconv.Itoa(int(i.a.items[i.idx].idx)))\n\t\tprop := i.a.items[i.idx].value\n\t\ti.idx++\n\t\tif prop != nil {\n\t\t\treturn propIterItem{name: name, value: prop}, i.next\n\t\t}\n\t}\n\n\treturn i.a.baseObject.iterateStringKeys()()\n}\n\nfunc (a *sparseArrayObject) iterateStringKeys() iterNextFunc {\n\treturn (&sparseArrayPropIter{\n\t\ta: a,\n\t}).next\n}\n\nfunc (a *sparseArrayObject) stringKeys(all bool, accum []Value) []Value {\n\tif all {\n\t\tfor _, item := range a.items {\n\t\t\taccum = append(accum, asciiString(strconv.FormatUint(uint64(item.idx), 10)))\n\t\t}\n\t} else {\n\t\tfor _, item := range a.items {\n\t\t\tif prop, ok := item.value.(*valueProperty); ok && !prop.enumerable {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taccum = append(accum, asciiString(strconv.FormatUint(uint64(item.idx), 10)))\n\t\t}\n\t}\n\n\treturn a.baseObject.stringKeys(all, accum)\n}\n\nfunc (a *sparseArrayObject) setValues(values []Value, objCount int) {\n\ta.items = make([]sparseArrayItem, 0, objCount)\n\tfor i, val := range values {\n\t\tif val != nil {\n\t\t\ta.items = append(a.items, sparseArrayItem{\n\t\t\t\tidx:   uint32(i),\n\t\t\t\tvalue: val,\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc (a *sparseArrayObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\ti := a.findIdx(idx)\n\t\treturn i < len(a.items) && a.items[i].idx == idx\n\t} else {\n\t\treturn a.baseObject.hasOwnPropertyStr(name)\n\t}\n}\n\nfunc (a *sparseArrayObject) hasOwnPropertyIdx(idx valueInt) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\ti := a.findIdx(idx)\n\t\treturn i < len(a.items) && a.items[i].idx == idx\n\t}\n\n\treturn a.baseObject.hasOwnPropertyStr(idx.string())\n}\n\nfunc (a *sparseArrayObject) hasPropertyIdx(idx valueInt) bool {\n\tif a.hasOwnPropertyIdx(idx) {\n\t\treturn true\n\t}\n\n\tif a.prototype != nil {\n\t\treturn a.prototype.self.hasPropertyIdx(idx)\n\t}\n\n\treturn false\n}\n\nfunc (a *sparseArrayObject) expand(idx uint32) bool {\n\tif l := len(a.items); l >= 1024 {\n\t\tif ii := a.items[l-1].idx; ii > idx {\n\t\t\tidx = ii\n\t\t}\n\t\tif (bits.UintSize == 64 || idx < math.MaxInt32) && int(idx)>>3 < l {\n\t\t\t//log.Println(\"Switching sparse->standard\")\n\t\t\tar := &arrayObject{\n\t\t\t\tbaseObject:     a.baseObject,\n\t\t\t\tlength:         a.length,\n\t\t\t\tpropValueCount: a.propValueCount,\n\t\t\t}\n\t\t\tar.setValuesFromSparse(a.items, int(idx))\n\t\t\tar.val.self = ar\n\t\t\tar.lengthProp.writable = a.lengthProp.writable\n\t\t\ta._put(\"length\", &ar.lengthProp)\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (a *sparseArrayObject) _defineIdxProperty(idx uint32, desc PropertyDescriptor, throw bool) bool {\n\tvar existing Value\n\ti := a.findIdx(idx)\n\tif i < len(a.items) && a.items[i].idx == idx {\n\t\texisting = a.items[i].value\n\t}\n\tprop, ok := a.baseObject._defineOwnProperty(unistring.String(strconv.FormatUint(uint64(idx), 10)), existing, desc, throw)\n\tif ok {\n\t\tif idx >= a.length {\n\t\t\tif !a.setLengthInt(idx+1, throw) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tif i >= len(a.items) || a.items[i].idx != idx {\n\t\t\tif a.expand(idx) {\n\t\t\t\ta.items = append(a.items, sparseArrayItem{})\n\t\t\t\tcopy(a.items[i+1:], a.items[i:])\n\t\t\t\ta.items[i] = sparseArrayItem{\n\t\t\t\t\tidx:   idx,\n\t\t\t\t\tvalue: prop,\n\t\t\t\t}\n\t\t\t\tif idx >= a.length {\n\t\t\t\t\ta.length = idx + 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ta.val.self.(*arrayObject).values[idx] = prop\n\t\t\t}\n\t\t} else {\n\t\t\ta.items[i].value = prop\n\t\t}\n\t\tif _, ok := prop.(*valueProperty); ok {\n\t\t\ta.propValueCount++\n\t\t}\n\t}\n\treturn ok\n}\n\nfunc (a *sparseArrayObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._defineIdxProperty(idx, descr, throw)\n\t}\n\tif name == \"length\" {\n\t\treturn a.val.runtime.defineArrayLength(a.getLengthProp(), descr, a.setLength, throw)\n\t}\n\treturn a.baseObject.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (a *sparseArrayObject) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._defineIdxProperty(idx, descr, throw)\n\t}\n\treturn a.baseObject.defineOwnPropertyStr(idx.string(), descr, throw)\n}\n\nfunc (a *sparseArrayObject) _deleteIdxProp(idx uint32, throw bool) bool {\n\ti := a.findIdx(idx)\n\tif i < len(a.items) && a.items[i].idx == idx {\n\t\tif p, ok := a.items[i].value.(*valueProperty); ok {\n\t\t\tif !p.configurable {\n\t\t\t\ta.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of %s\", idx, a.val.toString())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\ta.propValueCount--\n\t\t}\n\t\tcopy(a.items[i:], a.items[i+1:])\n\t\ta.items[len(a.items)-1].value = nil\n\t\ta.items = a.items[:len(a.items)-1]\n\t}\n\treturn true\n}\n\nfunc (a *sparseArrayObject) deleteStr(name unistring.String, throw bool) bool {\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\treturn a._deleteIdxProp(idx, throw)\n\t}\n\treturn a.baseObject.deleteStr(name, throw)\n}\n\nfunc (a *sparseArrayObject) deleteIdx(idx valueInt, throw bool) bool {\n\tif idx := toIdx(idx); idx != math.MaxUint32 {\n\t\treturn a._deleteIdxProp(idx, throw)\n\t}\n\treturn a.baseObject.deleteStr(idx.string(), throw)\n}\n\nfunc (a *sparseArrayObject) sortLen() int {\n\tif len(a.items) > 0 {\n\t\treturn toIntStrict(int64(a.items[len(a.items)-1].idx) + 1)\n\t}\n\n\treturn 0\n}\n\nfunc (a *sparseArrayObject) export(ctx *objectExportCtx) interface{} {\n\tif v, exists := ctx.get(a.val); exists {\n\t\treturn v\n\t}\n\tarr := make([]interface{}, a.length)\n\tctx.put(a.val, arr)\n\tvar prevIdx uint32\n\tfor _, item := range a.items {\n\t\tidx := item.idx\n\t\tfor i := prevIdx; i < idx; i++ {\n\t\t\tif a.prototype != nil {\n\t\t\t\tif v := a.prototype.self.getIdx(valueInt(i), nil); v != nil {\n\t\t\t\t\tarr[i] = exportValue(v, ctx)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv := item.value\n\t\tif v != nil {\n\t\t\tif prop, ok := v.(*valueProperty); ok {\n\t\t\t\tv = prop.get(a.val)\n\t\t\t}\n\t\t\tarr[idx] = exportValue(v, ctx)\n\t\t}\n\t\tprevIdx = idx + 1\n\t}\n\tfor i := prevIdx; i < a.length; i++ {\n\t\tif a.prototype != nil {\n\t\t\tif v := a.prototype.self.getIdx(valueInt(i), nil); v != nil {\n\t\t\t\tarr[i] = exportValue(v, ctx)\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc (a *sparseArrayObject) exportType() reflect.Type {\n\treturn reflectTypeArray\n}\n\nfunc (a *sparseArrayObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tr := a.val.runtime\n\tif iter := a.getSym(SymIterator, nil); iter == r.getArrayValues() || iter == nil {\n\t\tl := toIntStrict(int64(a.length))\n\t\tif typ.Kind() == reflect.Array {\n\t\t\tif dst.Len() != l {\n\t\t\t\treturn fmt.Errorf(\"cannot convert an Array into an array, lengths mismatch (have %d, need %d)\", l, dst.Len())\n\t\t\t}\n\t\t} else {\n\t\t\tdst.Set(reflect.MakeSlice(typ, l, l))\n\t\t}\n\t\tctx.putTyped(a.val, typ, dst.Interface())\n\t\tfor _, item := range a.items {\n\t\t\tval := item.value\n\t\t\tif p, ok := val.(*valueProperty); ok {\n\t\t\t\tval = p.get(a.val)\n\t\t\t}\n\t\t\tidx := toIntStrict(int64(item.idx))\n\t\t\tif idx >= l {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr := r.toReflectValue(val, dst.Index(idx), ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not convert array element %v to %v at %d: %w\", item.value, typ, idx, err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn a.baseObject.exportToArrayOrSlice(dst, typ, ctx)\n}\n"
        },
        {
          "name": "array_sparse_test.go",
          "type": "blob",
          "size": 5.45703125,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSparseArraySetLengthWithPropItems(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [1,2,3,4];\n\ta[100000] = 5;\n\tvar thrown = false;\n\n\tObject.defineProperty(a, \"2\", {value: 42, configurable: false, writable: false});\n\ttry {\n\t\tObject.defineProperty(a, \"length\", {value: 0, writable: false});\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\tthrown && a.length === 3;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSparseArraySwitch(t *testing.T) {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tvar a = [];\n\ta[20470] = 5; // switch to sparse`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ta := vm.Get(\"a\").(*Object)\n\tif _, ok := a.self.(*sparseArrayObject); !ok {\n\t\tt.Fatal(\"1: array is not sparse\")\n\t}\n\t_, err = vm.RunString(`\n\tvar cutoffIdx = Math.round(20470 - 20470/8);\n\tfor (var i = a.length - 1; i >= cutoffIdx; i--) {\n\t\ta[i] = i;\n\t}\n\n\t// At this point it will have switched to a normal array\n\tif (a.length != 20471) {\n\t\tthrow new Error(\"Invalid length: \" + a.length);\n\t}\n\n\tfor (var i = 0; i < cutoffIdx; i++) {\n\t\tif (a[i] !== undefined) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}\n\n\tfor (var i = cutoffIdx; i < a.length; i++) {\n\t\tif (a[i] !== i) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := a.self.(*arrayObject); !ok {\n\t\tt.Fatal(\"2: array is not normal\")\n\t}\n\t_, err = vm.RunString(`\n\t// Now try to expand. Should stay a normal array\n\ta[20471] = 20471;\n\tif (a.length != 20472) {\n\t\tthrow new Error(\"Invalid length: \" + a.length);\n\t}\n\n\tfor (var i = 0; i < cutoffIdx; i++) {\n\t\tif (a[i] !== undefined) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}\n\n\tfor (var i = cutoffIdx; i < a.length; i++) {\n\t\tif (a[i] !== i) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := a.self.(*arrayObject); !ok {\n\t\tt.Fatal(\"3: array is not normal\")\n\t}\n\t_, err = vm.RunString(`\n\t// Delete enough elements for it to become sparse again.\n\tvar cutoffIdx1 = Math.round(20472 - 20472/10);\n\tfor (var i = cutoffIdx; i < cutoffIdx1; i++) {\n\t\tdelete a[i];\n\t}\n\n\t// This should switch it back to sparse.\n\ta[25590] = 25590;\n\tif (a.length != 25591) {\n\t\tthrow new Error(\"Invalid length: \" + a.length);\n\t}\n\n\tfor (var i = 0; i < cutoffIdx1; i++) {\n\t\tif (a[i] !== undefined) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}\n\n\tfor (var i = cutoffIdx1; i < 20472; i++) {\n\t\tif (a[i] !== i) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}\n\n\tfor (var i = 20472; i < 25590; i++) {\n\t\tif (a[i] !== undefined) {\n\t\t\tthrow new Error(\"Invalid value at \" + i + \": \" + a[i]);\n\t\t}\n\t}\n\n\tif (a[25590] !== 25590) {\n\t\tthrow new Error(\"Invalid value at 25590: \" + a[25590]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := a.self.(*sparseArrayObject); !ok {\n\t\tt.Fatal(\"4: array is not sparse\")\n\t}\n}\n\nfunc TestSparseArrayOwnKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a1 = [];\n\ta1[500000] = 1;\n\tvar seen = false;\n\tvar count = 0;\n\tvar keys = Object.keys(a1);\n\tkeys.length === 1 && keys[0] === \"500000\"; \n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSparseArrayEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a1 = [];\n\ta1[500000] = 1;\n\tvar seen = false;\n\tvar count = 0;\n\tfor (var i in a1) {\n\t\tif (i === \"500000\") {\n\t\t\tif (seen) {\n\t\t\t\tthrow new Error(\"seen twice\");\n\t\t\t}\n\t\t\tseen = true;\n\t\t}\n\t\tcount++;\n\t}\n\tseen && count === 1;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArraySparseMaxLength(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [];\n\ta[4294967294]=1;\n\ta.length === 4294967295 && a[4294967294] === 1;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArraySparseExportProps(t *testing.T) {\n\tvm := New()\n\tproto := vm.NewArray()\n\tfor _, idx := range []string{\"0\", \"500\", \"9999\", \"10001\", \"20471\"} {\n\t\terr := proto.Set(idx, true)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tarr := vm.NewArray()\n\terr := arr.SetPrototype(proto)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = arr.DefineDataProperty(\"20470\", vm.ToValue(true), FLAG_TRUE, FLAG_FALSE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = arr.DefineDataProperty(\"10000\", vm.ToValue(true), FLAG_TRUE, FLAG_FALSE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = arr.Set(\"length\", 20472)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tactual := arr.Export()\n\tif actualArr, ok := actual.([]interface{}); ok {\n\t\tif len(actualArr) == 20472 {\n\t\t\texpectedIdx := map[int]struct{}{\n\t\t\t\t0:     {},\n\t\t\t\t500:   {},\n\t\t\t\t9999:  {},\n\t\t\t\t10000: {},\n\t\t\t\t10001: {},\n\t\t\t\t20470: {},\n\t\t\t\t20471: {},\n\t\t\t}\n\t\t\tfor i, v := range actualArr {\n\t\t\t\tif _, exists := expectedIdx[i]; exists {\n\t\t\t\t\tif v != true {\n\t\t\t\t\t\tt.Fatalf(\"Expected true at %d, got %v\", i, v)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif v != nil {\n\t\t\t\t\t\tt.Fatalf(\"Expected nil at %d, got %v\", i, v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"Expected len 20471, actual: %d\", len(actualArr))\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Invalid export type: %T\", actual)\n\t}\n}\n\nfunc TestSparseArrayExportToSlice(t *testing.T) {\n\tvm := New()\n\tarr := vm.NewArray()\n\terr := arr.Set(\"20470\", 120470)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = arr.DefineDataProperty(\"20471\", vm.ToValue(220471), FLAG_TRUE, FLAG_FALSE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar exp []int\n\terr = vm.ExportTo(arr, &exp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(exp) != 20472 {\n\t\tt.Fatalf(\"len: %d\", len(exp))\n\t}\n\tif e := exp[20470]; e != 120470 {\n\t\tt.Fatalf(\"20470: %d\", e)\n\t}\n\tif e := exp[20471]; e != 220471 {\n\t\tt.Fatalf(\"20471: %d\", e)\n\t}\n\tfor i := 0; i < 20470; i++ {\n\t\tif exp[i] != 0 {\n\t\t\tt.Fatalf(\"at %d: %d\", i, exp[i])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 2.150390625,
          "content": "package goja\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArray1(t *testing.T) {\n\tr := &Runtime{}\n\ta := r.newArray(nil)\n\ta.setOwnIdx(valueInt(0), asciiString(\"test\"), true)\n\tif l := a.getStr(\"length\", nil).ToInteger(); l != 1 {\n\t\tt.Fatalf(\"Unexpected length: %d\", l)\n\t}\n}\n\nfunc TestArrayExportProps(t *testing.T) {\n\tvm := New()\n\tarr := vm.NewArray()\n\terr := arr.DefineDataProperty(\"0\", vm.ToValue(true), FLAG_TRUE, FLAG_FALSE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tactual := arr.Export()\n\texpected := []interface{}{true}\n\tif !reflect.DeepEqual(actual, expected) {\n\t\tt.Fatalf(\"Expected: %#v, actual: %#v\", expected, actual)\n\t}\n}\n\nfunc TestArrayCanonicalIndex(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [];\n\ta[\"00\"] = 1;\n\ta[\"01\"] = 2;\n\tif (a[0] !== undefined) {\n\t\tthrow new Error(\"a[0]\");\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc BenchmarkArrayGetStr(b *testing.B) {\n\tb.StopTimer()\n\tr := New()\n\tv := &Object{runtime: r}\n\n\ta := &arrayObject{\n\t\tbaseObject: baseObject{\n\t\t\tval:        v,\n\t\t\textensible: true,\n\t\t},\n\t}\n\tv.self = a\n\n\ta.init()\n\n\tv.setOwn(valueInt(0), asciiString(\"test\"), false)\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.getStr(\"0\", nil)\n\t}\n\n}\n\nfunc BenchmarkArrayGet(b *testing.B) {\n\tb.StopTimer()\n\tr := New()\n\tv := &Object{runtime: r}\n\n\ta := &arrayObject{\n\t\tbaseObject: baseObject{\n\t\t\tval:        v,\n\t\t\textensible: true,\n\t\t},\n\t}\n\tv.self = a\n\n\ta.init()\n\n\tvar idx Value = valueInt(0)\n\n\tv.setOwn(idx, asciiString(\"test\"), false)\n\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv.get(idx, nil)\n\t}\n\n}\n\nfunc BenchmarkArrayPut(b *testing.B) {\n\tb.StopTimer()\n\tr := New()\n\n\tv := &Object{runtime: r}\n\n\ta := &arrayObject{\n\t\tbaseObject: baseObject{\n\t\t\tval:        v,\n\t\t\textensible: true,\n\t\t},\n\t}\n\n\tv.self = a\n\n\ta.init()\n\n\tvar idx Value = valueInt(0)\n\tvar val Value = asciiString(\"test\")\n\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv.setOwn(idx, val, false)\n\t}\n\n}\n\nfunc BenchmarkArraySetEmpty(b *testing.B) {\n\tr := New()\n\t_ = r.Get(\"Array\").(*Object).Get(\"prototype\").String() // materialise Array.prototype\n\ta := r.NewArray(0, 0)\n\tvalues := a.self.(*arrayObject).values\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvalues[0] = nil\n\t\ta.self.setOwnIdx(0, valueTrue, true)\n\t}\n}\n"
        },
        {
          "name": "ast",
          "type": "tree",
          "content": null
        },
        {
          "name": "builtin_array.go",
          "type": "blob",
          "size": 46.560546875,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"sync\"\n)\n\nfunc (r *Runtime) newArray(prototype *Object) (a *arrayObject) {\n\tv := &Object{runtime: r}\n\n\ta = &arrayObject{}\n\ta.class = classArray\n\ta.val = v\n\ta.extensible = true\n\tv.self = a\n\ta.prototype = prototype\n\ta.init()\n\treturn\n}\n\nfunc (r *Runtime) newArrayObject() *arrayObject {\n\treturn r.newArray(r.getArrayPrototype())\n}\n\nfunc setArrayValues(a *arrayObject, values []Value) *arrayObject {\n\ta.values = values\n\ta.length = uint32(len(values))\n\ta.objCount = len(values)\n\treturn a\n}\n\nfunc setArrayLength(a *arrayObject, l int64) *arrayObject {\n\ta.setOwnStr(\"length\", intToValue(l), true)\n\treturn a\n}\n\nfunc arraySpeciesCreate(obj *Object, size int64) *Object {\n\tif isArray(obj) {\n\t\tv := obj.self.getStr(\"constructor\", nil)\n\t\tif constructObj, ok := v.(*Object); ok {\n\t\t\tv = constructObj.self.getSym(SymSpecies, nil)\n\t\t\tif v == _null {\n\t\t\t\tv = nil\n\t\t\t}\n\t\t}\n\n\t\tif v != nil && v != _undefined {\n\t\t\tconstructObj, _ := v.(*Object)\n\t\t\tif constructObj != nil {\n\t\t\t\tif constructor := constructObj.self.assertConstructor(); constructor != nil {\n\t\t\t\t\treturn constructor([]Value{intToValue(size)}, constructObj)\n\t\t\t\t}\n\t\t\t}\n\t\t\tpanic(obj.runtime.NewTypeError(\"Species is not a constructor\"))\n\t\t}\n\t}\n\treturn obj.runtime.newArrayLength(size)\n}\n\nfunc max(a, b int64) int64 {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc relToIdx(rel, l int64) int64 {\n\tif rel >= 0 {\n\t\treturn min(rel, l)\n\t}\n\treturn max(l+rel, 0)\n}\n\nfunc (r *Runtime) newArrayValues(values []Value) *Object {\n\treturn setArrayValues(r.newArrayObject(), values).val\n}\n\nfunc (r *Runtime) newArrayLength(l int64) *Object {\n\treturn setArrayLength(r.newArrayObject(), l).val\n}\n\nfunc (r *Runtime) builtin_newArray(args []Value, proto *Object) *Object {\n\tl := len(args)\n\tif l == 1 {\n\t\tif al, ok := args[0].(valueInt); ok {\n\t\t\treturn setArrayLength(r.newArray(proto), int64(al)).val\n\t\t} else if f, ok := args[0].(valueFloat); ok {\n\t\t\tal := int64(f)\n\t\t\tif float64(al) == float64(f) {\n\t\t\t\treturn r.newArrayLength(al)\n\t\t\t} else {\n\t\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid array length\"))\n\t\t\t}\n\t\t}\n\t\treturn setArrayValues(r.newArray(proto), []Value{args[0]}).val\n\t} else {\n\t\targsCopy := make([]Value, l)\n\t\tcopy(argsCopy, args)\n\t\treturn setArrayValues(r.newArray(proto), argsCopy).val\n\t}\n}\n\nfunc (r *Runtime) generic_push(obj *Object, call FunctionCall) Value {\n\tl := toLength(obj.self.getStr(\"length\", nil))\n\tnl := l + int64(len(call.Arguments))\n\tif nl >= maxInt {\n\t\tr.typeErrorResult(true, \"Invalid array length\")\n\t\tpanic(\"unreachable\")\n\t}\n\tfor i, arg := range call.Arguments {\n\t\tobj.self.setOwnIdx(valueInt(l+int64(i)), arg, true)\n\t}\n\tn := valueInt(nl)\n\tobj.self.setOwnStr(\"length\", n, true)\n\treturn n\n}\n\nfunc (r *Runtime) arrayproto_push(call FunctionCall) Value {\n\tobj := call.This.ToObject(r)\n\treturn r.generic_push(obj, call)\n}\n\nfunc (r *Runtime) arrayproto_pop_generic(obj *Object) Value {\n\tl := toLength(obj.self.getStr(\"length\", nil))\n\tif l == 0 {\n\t\tobj.self.setOwnStr(\"length\", intToValue(0), true)\n\t\treturn _undefined\n\t}\n\tidx := valueInt(l - 1)\n\tval := obj.self.getIdx(idx, nil)\n\tobj.self.deleteIdx(idx, true)\n\tobj.self.setOwnStr(\"length\", idx, true)\n\treturn val\n}\n\nfunc (r *Runtime) arrayproto_pop(call FunctionCall) Value {\n\tobj := call.This.ToObject(r)\n\tif a, ok := obj.self.(*arrayObject); ok {\n\t\tl := a.length\n\t\tvar val Value\n\t\tif l > 0 {\n\t\t\tl--\n\t\t\tif l < uint32(len(a.values)) {\n\t\t\t\tval = a.values[l]\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\t// optimisation bail-out\n\t\t\t\treturn r.arrayproto_pop_generic(obj)\n\t\t\t}\n\t\t\tif _, ok := val.(*valueProperty); ok {\n\t\t\t\t// optimisation bail-out\n\t\t\t\treturn r.arrayproto_pop_generic(obj)\n\t\t\t}\n\t\t\t//a._setLengthInt(l, false)\n\t\t\ta.values[l] = nil\n\t\t\ta.values = a.values[:l]\n\t\t} else {\n\t\t\tval = _undefined\n\t\t}\n\t\tif a.lengthProp.writable {\n\t\t\ta.length = l\n\t\t} else {\n\t\t\ta.setLength(0, true) // will throw\n\t\t}\n\t\treturn val\n\t} else {\n\t\treturn r.arrayproto_pop_generic(obj)\n\t}\n}\n\nfunc (r *Runtime) arrayproto_join(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := int(toLength(o.self.getStr(\"length\", nil)))\n\tvar sep String\n\tif s := call.Argument(0); s != _undefined {\n\t\tsep = s.toString()\n\t} else {\n\t\tsep = asciiString(\",\")\n\t}\n\tif l == 0 {\n\t\treturn stringEmpty\n\t}\n\n\tvar buf StringBuilder\n\n\telement0 := o.self.getIdx(valueInt(0), nil)\n\tif element0 != nil && element0 != _undefined && element0 != _null {\n\t\tbuf.WriteString(element0.toString())\n\t}\n\n\tfor i := 1; i < l; i++ {\n\t\tbuf.WriteString(sep)\n\t\telement := o.self.getIdx(valueInt(int64(i)), nil)\n\t\tif element != nil && element != _undefined && element != _null {\n\t\t\tbuf.WriteString(element.toString())\n\t\t}\n\t}\n\n\treturn buf.String()\n}\n\nfunc (r *Runtime) arrayproto_toString(call FunctionCall) Value {\n\tarray := call.This.ToObject(r)\n\tvar toString func() Value\n\tswitch a := array.self.(type) {\n\tcase *objectGoSliceReflect:\n\t\ttoString = a.toString\n\tcase *objectGoArrayReflect:\n\t\ttoString = a.toString\n\t}\n\tif toString != nil {\n\t\treturn toString()\n\t}\n\tf := array.self.getStr(\"join\", nil)\n\tif fObj, ok := f.(*Object); ok {\n\t\tif fcall, ok := fObj.self.assertCallable(); ok {\n\t\t\treturn fcall(FunctionCall{\n\t\t\t\tThis: array,\n\t\t\t})\n\t\t}\n\t}\n\treturn r.objectproto_toString(FunctionCall{\n\t\tThis: array,\n\t})\n}\n\nfunc (r *Runtime) writeItemLocaleString(item Value, buf *StringBuilder) {\n\tif item != nil && item != _undefined && item != _null {\n\t\tif f, ok := r.getVStr(item, \"toLocaleString\").(*Object); ok {\n\t\t\tif c, ok := f.self.assertCallable(); ok {\n\t\t\t\tstrVal := c(FunctionCall{\n\t\t\t\t\tThis: item,\n\t\t\t\t})\n\t\t\t\tbuf.WriteString(strVal.toString())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tr.typeErrorResult(true, \"Property 'toLocaleString' of object %s is not a function\", item)\n\t}\n}\n\nfunc (r *Runtime) arrayproto_toLocaleString(call FunctionCall) Value {\n\tarray := call.This.ToObject(r)\n\tvar buf StringBuilder\n\tif a := r.checkStdArrayObj(array); a != nil {\n\t\tfor i, item := range a.values {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\tr.writeItemLocaleString(item, &buf)\n\t\t}\n\t} else {\n\t\tlength := toLength(array.self.getStr(\"length\", nil))\n\t\tfor i := int64(0); i < length; i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\titem := array.self.getIdx(valueInt(i), nil)\n\t\t\tr.writeItemLocaleString(item, &buf)\n\t\t}\n\t}\n\n\treturn buf.String()\n}\n\nfunc isConcatSpreadable(obj *Object) bool {\n\tspreadable := obj.self.getSym(SymIsConcatSpreadable, nil)\n\tif spreadable != nil && spreadable != _undefined {\n\t\treturn spreadable.ToBoolean()\n\t}\n\treturn isArray(obj)\n}\n\nfunc (r *Runtime) arrayproto_concat_append(a *Object, item Value) {\n\taLength := toLength(a.self.getStr(\"length\", nil))\n\tif obj, ok := item.(*Object); ok && isConcatSpreadable(obj) {\n\t\tlength := toLength(obj.self.getStr(\"length\", nil))\n\t\tif aLength+length >= maxInt {\n\t\t\tpanic(r.NewTypeError(\"Invalid array length\"))\n\t\t}\n\t\tfor i := int64(0); i < length; i++ {\n\t\t\tv := obj.self.getIdx(valueInt(i), nil)\n\t\t\tif v != nil {\n\t\t\t\tcreateDataPropertyOrThrow(a, intToValue(aLength), v)\n\t\t\t}\n\t\t\taLength++\n\t\t}\n\t} else {\n\t\tcreateDataPropertyOrThrow(a, intToValue(aLength), item)\n\t\taLength++\n\t}\n\ta.self.setOwnStr(\"length\", intToValue(aLength), true)\n}\n\nfunc (r *Runtime) arrayproto_concat(call FunctionCall) Value {\n\tobj := call.This.ToObject(r)\n\ta := arraySpeciesCreate(obj, 0)\n\tr.arrayproto_concat_append(a, call.This.ToObject(r))\n\tfor _, item := range call.Arguments {\n\t\tr.arrayproto_concat_append(a, item)\n\t}\n\treturn a\n}\n\nfunc (r *Runtime) arrayproto_slice(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tstart := relToIdx(call.Argument(0).ToInteger(), length)\n\tvar end int64\n\tif endArg := call.Argument(1); endArg != _undefined {\n\t\tend = endArg.ToInteger()\n\t} else {\n\t\tend = length\n\t}\n\tend = relToIdx(end, length)\n\n\tcount := end - start\n\tif count < 0 {\n\t\tcount = 0\n\t}\n\n\ta := arraySpeciesCreate(o, count)\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\tif dst := r.checkStdArrayObjWithProto(a); dst != nil {\n\t\t\tvalues := make([]Value, count)\n\t\t\tcopy(values, src.values[start:])\n\t\t\tsetArrayValues(dst, values)\n\t\t\treturn a\n\t\t}\n\t}\n\n\tn := int64(0)\n\tfor start < end {\n\t\tp := o.self.getIdx(valueInt(start), nil)\n\t\tif p != nil {\n\t\t\tcreateDataPropertyOrThrow(a, valueInt(n), p)\n\t\t}\n\t\tstart++\n\t\tn++\n\t}\n\treturn a\n}\n\nfunc (r *Runtime) arrayproto_sort(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\n\tvar compareFn func(FunctionCall) Value\n\targ := call.Argument(0)\n\tif arg != _undefined {\n\t\tif arg, ok := call.Argument(0).(*Object); ok {\n\t\t\tcompareFn, _ = arg.self.assertCallable()\n\t\t}\n\t\tif compareFn == nil {\n\t\t\tpanic(r.NewTypeError(\"The comparison function must be either a function or undefined\"))\n\t\t}\n\t}\n\n\tvar s sortable\n\tif r.checkStdArrayObj(o) != nil {\n\t\ts = o.self\n\t} else if _, ok := o.self.(reflectValueWrapper); ok {\n\t\ts = o.self\n\t}\n\n\tif s != nil {\n\t\tctx := arraySortCtx{\n\t\t\tobj:     s,\n\t\t\tcompare: compareFn,\n\t\t}\n\n\t\tsort.Stable(&ctx)\n\t} else {\n\t\tlength := toLength(o.self.getStr(\"length\", nil))\n\t\ta := make([]Value, 0, length)\n\t\tfor i := int64(0); i < length; i++ {\n\t\t\tidx := valueInt(i)\n\t\t\tif o.self.hasPropertyIdx(idx) {\n\t\t\t\ta = append(a, nilSafe(o.self.getIdx(idx, nil)))\n\t\t\t}\n\t\t}\n\t\tar := r.newArrayValues(a)\n\t\tctx := arraySortCtx{\n\t\t\tobj:     ar.self,\n\t\t\tcompare: compareFn,\n\t\t}\n\n\t\tsort.Stable(&ctx)\n\t\tfor i := 0; i < len(a); i++ {\n\t\t\to.self.setOwnIdx(valueInt(i), a[i], true)\n\t\t}\n\t\tfor i := int64(len(a)); i < length; i++ {\n\t\t\to.self.deleteIdx(valueInt(i), true)\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) arrayproto_splice(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tactualStart := relToIdx(call.Argument(0).ToInteger(), length)\n\tvar actualDeleteCount int64\n\tswitch len(call.Arguments) {\n\tcase 0:\n\tcase 1:\n\t\tactualDeleteCount = length - actualStart\n\tdefault:\n\t\tactualDeleteCount = min(max(call.Argument(1).ToInteger(), 0), length-actualStart)\n\t}\n\titemCount := max(int64(len(call.Arguments)-2), 0)\n\tnewLength := length - actualDeleteCount + itemCount\n\tif newLength >= maxInt {\n\t\tpanic(r.NewTypeError(\"Invalid array length\"))\n\t}\n\ta := arraySpeciesCreate(o, actualDeleteCount)\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\tif dst := r.checkStdArrayObjWithProto(a); dst != nil {\n\t\t\tvalues := make([]Value, actualDeleteCount)\n\t\t\tcopy(values, src.values[actualStart:])\n\t\t\tsetArrayValues(dst, values)\n\t\t} else {\n\t\t\tfor k := int64(0); k < actualDeleteCount; k++ {\n\t\t\t\tcreateDataPropertyOrThrow(a, intToValue(k), src.values[k+actualStart])\n\t\t\t}\n\t\t\ta.self.setOwnStr(\"length\", intToValue(actualDeleteCount), true)\n\t\t}\n\t\tvar values []Value\n\t\tif itemCount < actualDeleteCount {\n\t\t\tvalues = src.values\n\t\t\tcopy(values[actualStart+itemCount:], values[actualStart+actualDeleteCount:])\n\t\t\ttail := values[newLength:]\n\t\t\tfor k := range tail {\n\t\t\t\ttail[k] = nil\n\t\t\t}\n\t\t\tvalues = values[:newLength]\n\t\t} else if itemCount > actualDeleteCount {\n\t\t\tif int64(cap(src.values)) >= newLength {\n\t\t\t\tvalues = src.values[:newLength]\n\t\t\t\tcopy(values[actualStart+itemCount:], values[actualStart+actualDeleteCount:length])\n\t\t\t} else {\n\t\t\t\tvalues = make([]Value, newLength)\n\t\t\t\tcopy(values, src.values[:actualStart])\n\t\t\t\tcopy(values[actualStart+itemCount:], src.values[actualStart+actualDeleteCount:])\n\t\t\t}\n\t\t} else {\n\t\t\tvalues = src.values\n\t\t}\n\t\tif itemCount > 0 {\n\t\t\tcopy(values[actualStart:], call.Arguments[2:])\n\t\t}\n\t\tsrc.values = values\n\t\tsrc.objCount = len(values)\n\t} else {\n\t\tfor k := int64(0); k < actualDeleteCount; k++ {\n\t\t\tfrom := valueInt(k + actualStart)\n\t\t\tif o.self.hasPropertyIdx(from) {\n\t\t\t\tcreateDataPropertyOrThrow(a, valueInt(k), nilSafe(o.self.getIdx(from, nil)))\n\t\t\t}\n\t\t}\n\n\t\tif itemCount < actualDeleteCount {\n\t\t\tfor k := actualStart; k < length-actualDeleteCount; k++ {\n\t\t\t\tfrom := valueInt(k + actualDeleteCount)\n\t\t\t\tto := valueInt(k + itemCount)\n\t\t\t\tif o.self.hasPropertyIdx(from) {\n\t\t\t\t\to.self.setOwnIdx(to, nilSafe(o.self.getIdx(from, nil)), true)\n\t\t\t\t} else {\n\t\t\t\t\to.self.deleteIdx(to, true)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor k := length; k > length-actualDeleteCount+itemCount; k-- {\n\t\t\t\to.self.deleteIdx(valueInt(k-1), true)\n\t\t\t}\n\t\t} else if itemCount > actualDeleteCount {\n\t\t\tfor k := length - actualDeleteCount; k > actualStart; k-- {\n\t\t\t\tfrom := valueInt(k + actualDeleteCount - 1)\n\t\t\t\tto := valueInt(k + itemCount - 1)\n\t\t\t\tif o.self.hasPropertyIdx(from) {\n\t\t\t\t\to.self.setOwnIdx(to, nilSafe(o.self.getIdx(from, nil)), true)\n\t\t\t\t} else {\n\t\t\t\t\to.self.deleteIdx(to, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif itemCount > 0 {\n\t\t\tfor i, item := range call.Arguments[2:] {\n\t\t\t\to.self.setOwnIdx(valueInt(actualStart+int64(i)), item, true)\n\t\t\t}\n\t\t}\n\t}\n\n\to.self.setOwnStr(\"length\", intToValue(newLength), true)\n\n\treturn a\n}\n\nfunc (r *Runtime) arrayproto_unshift(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\targCount := int64(len(call.Arguments))\n\tnewLen := intToValue(length + argCount)\n\tif argCount > 0 {\n\t\tnewSize := length + argCount\n\t\tif newSize >= maxInt {\n\t\t\tpanic(r.NewTypeError(\"Invalid array length\"))\n\t\t}\n\t\tif arr := r.checkStdArrayObjWithProto(o); arr != nil && newSize < math.MaxUint32 {\n\t\t\tif int64(cap(arr.values)) >= newSize {\n\t\t\t\tarr.values = arr.values[:newSize]\n\t\t\t\tcopy(arr.values[argCount:], arr.values[:length])\n\t\t\t} else {\n\t\t\t\tvalues := make([]Value, newSize)\n\t\t\t\tcopy(values[argCount:], arr.values)\n\t\t\t\tarr.values = values\n\t\t\t}\n\t\t\tcopy(arr.values, call.Arguments)\n\t\t\tarr.objCount = int(arr.length)\n\t\t} else {\n\t\t\tfor k := length - 1; k >= 0; k-- {\n\t\t\t\tfrom := valueInt(k)\n\t\t\t\tto := valueInt(k + argCount)\n\t\t\t\tif o.self.hasPropertyIdx(from) {\n\t\t\t\t\to.self.setOwnIdx(to, nilSafe(o.self.getIdx(from, nil)), true)\n\t\t\t\t} else {\n\t\t\t\t\to.self.deleteIdx(to, true)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor k, arg := range call.Arguments {\n\t\t\t\to.self.setOwnIdx(valueInt(int64(k)), arg, true)\n\t\t\t}\n\t\t}\n\t}\n\n\to.self.setOwnStr(\"length\", newLen, true)\n\treturn newLen\n}\n\nfunc (r *Runtime) arrayproto_at(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tidx := call.Argument(0).ToInteger()\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif idx < 0 {\n\t\tidx = length + idx\n\t}\n\tif idx >= length || idx < 0 {\n\t\treturn _undefined\n\t}\n\ti := valueInt(idx)\n\tif o.self.hasPropertyIdx(i) {\n\t\treturn o.self.getIdx(i, nil)\n\t}\n\treturn _undefined\n}\n\nfunc (r *Runtime) arrayproto_indexOf(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif length == 0 {\n\t\treturn intToValue(-1)\n\t}\n\n\tn := call.Argument(1).ToInteger()\n\tif n >= length {\n\t\treturn intToValue(-1)\n\t}\n\n\tif n < 0 {\n\t\tn = max(length+n, 0)\n\t}\n\n\tsearchElement := call.Argument(0)\n\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\tfor i, val := range arr.values[n:] {\n\t\t\tif searchElement.StrictEquals(val) {\n\t\t\t\treturn intToValue(n + int64(i))\n\t\t\t}\n\t\t}\n\t\treturn intToValue(-1)\n\t}\n\n\tfor ; n < length; n++ {\n\t\tidx := valueInt(n)\n\t\tif o.self.hasPropertyIdx(idx) {\n\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\tif searchElement.StrictEquals(val) {\n\t\t\t\t\treturn idx\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intToValue(-1)\n}\n\nfunc (r *Runtime) arrayproto_includes(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif length == 0 {\n\t\treturn valueFalse\n\t}\n\n\tn := call.Argument(1).ToInteger()\n\tif n >= length {\n\t\treturn valueFalse\n\t}\n\n\tif n < 0 {\n\t\tn = max(length+n, 0)\n\t}\n\n\tsearchElement := call.Argument(0)\n\tif searchElement == _negativeZero {\n\t\tsearchElement = _positiveZero\n\t}\n\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\tfor _, val := range arr.values[n:] {\n\t\t\tif searchElement.SameAs(val) {\n\t\t\t\treturn valueTrue\n\t\t\t}\n\t\t}\n\t\treturn valueFalse\n\t}\n\n\tfor ; n < length; n++ {\n\t\tidx := valueInt(n)\n\t\tval := nilSafe(o.self.getIdx(idx, nil))\n\t\tif searchElement.SameAs(val) {\n\t\t\treturn valueTrue\n\t\t}\n\t}\n\n\treturn valueFalse\n}\n\nfunc (r *Runtime) arrayproto_lastIndexOf(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif length == 0 {\n\t\treturn intToValue(-1)\n\t}\n\n\tvar fromIndex int64\n\n\tif len(call.Arguments) < 2 {\n\t\tfromIndex = length - 1\n\t} else {\n\t\tfromIndex = call.Argument(1).ToInteger()\n\t\tif fromIndex >= 0 {\n\t\t\tfromIndex = min(fromIndex, length-1)\n\t\t} else {\n\t\t\tfromIndex += length\n\t\t}\n\t}\n\n\tsearchElement := call.Argument(0)\n\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\tvals := arr.values\n\t\tfor k := fromIndex; k >= 0; k-- {\n\t\t\tif v := vals[k]; v != nil && searchElement.StrictEquals(v) {\n\t\t\t\treturn intToValue(k)\n\t\t\t}\n\t\t}\n\t\treturn intToValue(-1)\n\t}\n\n\tfor k := fromIndex; k >= 0; k-- {\n\t\tidx := valueInt(k)\n\t\tif o.self.hasPropertyIdx(idx) {\n\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\tif searchElement.StrictEquals(val) {\n\t\t\t\t\treturn idx\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intToValue(-1)\n}\n\nfunc (r *Runtime) arrayproto_every(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(0); k < length; k++ {\n\t\tidx := valueInt(k)\n\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = idx\n\t\t\tif !callbackFn(fc).ToBoolean() {\n\t\t\t\treturn valueFalse\n\t\t\t}\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) arrayproto_some(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(0); k < length; k++ {\n\t\tidx := valueInt(k)\n\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = idx\n\t\t\tif callbackFn(fc).ToBoolean() {\n\t\t\t\treturn valueTrue\n\t\t\t}\n\t\t}\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) arrayproto_forEach(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(0); k < length; k++ {\n\t\tidx := valueInt(k)\n\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = idx\n\t\t\tcallbackFn(fc)\n\t\t}\n\t}\n\treturn _undefined\n}\n\nfunc (r *Runtime) arrayproto_map(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\ta := arraySpeciesCreate(o, length)\n\tif _, stdSrc := o.self.(*arrayObject); stdSrc {\n\t\tif arr, ok := a.self.(*arrayObject); ok {\n\t\t\tvalues := make([]Value, length)\n\t\t\tfor k := int64(0); k < length; k++ {\n\t\t\t\tidx := valueInt(k)\n\t\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\t\tfc.Arguments[0] = val\n\t\t\t\t\tfc.Arguments[1] = idx\n\t\t\t\t\tvalues[k] = callbackFn(fc)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetArrayValues(arr, values)\n\t\t\treturn a\n\t\t}\n\t}\n\tfor k := int64(0); k < length; k++ {\n\t\tidx := valueInt(k)\n\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = idx\n\t\t\tcreateDataPropertyOrThrow(a, idx, callbackFn(fc))\n\t\t}\n\t}\n\treturn a\n}\n\nfunc (r *Runtime) arrayproto_filter(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := call.Argument(0).ToObject(r)\n\tif callbackFn, ok := callbackFn.self.assertCallable(); ok {\n\t\ta := arraySpeciesCreate(o, 0)\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, o},\n\t\t}\n\t\tif _, stdSrc := o.self.(*arrayObject); stdSrc {\n\t\t\tif arr := r.checkStdArrayObj(a); arr != nil {\n\t\t\t\tvar values []Value\n\t\t\t\tfor k := int64(0); k < length; k++ {\n\t\t\t\t\tidx := valueInt(k)\n\t\t\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\t\t\tfc.Arguments[0] = val\n\t\t\t\t\t\tfc.Arguments[1] = idx\n\t\t\t\t\t\tif callbackFn(fc).ToBoolean() {\n\t\t\t\t\t\t\tvalues = append(values, val)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetArrayValues(arr, values)\n\t\t\t\treturn a\n\t\t\t}\n\t\t}\n\n\t\tto := int64(0)\n\t\tfor k := int64(0); k < length; k++ {\n\t\t\tidx := valueInt(k)\n\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\tfc.Arguments[0] = val\n\t\t\t\tfc.Arguments[1] = idx\n\t\t\t\tif callbackFn(fc).ToBoolean() {\n\t\t\t\t\tcreateDataPropertyOrThrow(a, intToValue(to), val)\n\t\t\t\t\tto++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn a\n\t} else {\n\t\tr.typeErrorResult(true, \"%s is not a function\", call.Argument(0))\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc (r *Runtime) arrayproto_reduce(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := call.Argument(0).ToObject(r)\n\tif callbackFn, ok := callbackFn.self.assertCallable(); ok {\n\t\tfc := FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{nil, nil, nil, o},\n\t\t}\n\n\t\tvar k int64\n\n\t\tif len(call.Arguments) >= 2 {\n\t\t\tfc.Arguments[0] = call.Argument(1)\n\t\t} else {\n\t\t\tfor ; k < length; k++ {\n\t\t\t\tidx := valueInt(k)\n\t\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\t\tfc.Arguments[0] = val\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif fc.Arguments[0] == nil {\n\t\t\t\tr.typeErrorResult(true, \"No initial value\")\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t\tk++\n\t\t}\n\n\t\tfor ; k < length; k++ {\n\t\t\tidx := valueInt(k)\n\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\tfc.Arguments[1] = val\n\t\t\t\tfc.Arguments[2] = idx\n\t\t\t\tfc.Arguments[0] = callbackFn(fc)\n\t\t\t}\n\t\t}\n\t\treturn fc.Arguments[0]\n\t} else {\n\t\tr.typeErrorResult(true, \"%s is not a function\", call.Argument(0))\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc (r *Runtime) arrayproto_reduceRight(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := call.Argument(0).ToObject(r)\n\tif callbackFn, ok := callbackFn.self.assertCallable(); ok {\n\t\tfc := FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{nil, nil, nil, o},\n\t\t}\n\n\t\tk := length - 1\n\n\t\tif len(call.Arguments) >= 2 {\n\t\t\tfc.Arguments[0] = call.Argument(1)\n\t\t} else {\n\t\t\tfor ; k >= 0; k-- {\n\t\t\t\tidx := valueInt(k)\n\t\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\t\tfc.Arguments[0] = val\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif fc.Arguments[0] == nil {\n\t\t\t\tr.typeErrorResult(true, \"No initial value\")\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t\tk--\n\t\t}\n\n\t\tfor ; k >= 0; k-- {\n\t\t\tidx := valueInt(k)\n\t\t\tif val := o.self.getIdx(idx, nil); val != nil {\n\t\t\t\tfc.Arguments[1] = val\n\t\t\t\tfc.Arguments[2] = idx\n\t\t\t\tfc.Arguments[0] = callbackFn(fc)\n\t\t\t}\n\t\t}\n\t\treturn fc.Arguments[0]\n\t} else {\n\t\tr.typeErrorResult(true, \"%s is not a function\", call.Argument(0))\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc arrayproto_reverse_generic_step(o *Object, lower, upper int64) {\n\tlowerP := valueInt(lower)\n\tupperP := valueInt(upper)\n\tvar lowerValue, upperValue Value\n\tlowerExists := o.self.hasPropertyIdx(lowerP)\n\tif lowerExists {\n\t\tlowerValue = nilSafe(o.self.getIdx(lowerP, nil))\n\t}\n\tupperExists := o.self.hasPropertyIdx(upperP)\n\tif upperExists {\n\t\tupperValue = nilSafe(o.self.getIdx(upperP, nil))\n\t}\n\tif lowerExists && upperExists {\n\t\to.self.setOwnIdx(lowerP, upperValue, true)\n\t\to.self.setOwnIdx(upperP, lowerValue, true)\n\t} else if !lowerExists && upperExists {\n\t\to.self.setOwnIdx(lowerP, upperValue, true)\n\t\to.self.deleteIdx(upperP, true)\n\t} else if lowerExists && !upperExists {\n\t\to.self.deleteIdx(lowerP, true)\n\t\to.self.setOwnIdx(upperP, lowerValue, true)\n\t}\n}\n\nfunc (r *Runtime) arrayproto_reverse_generic(o *Object, start int64) {\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tmiddle := l / 2\n\tfor lower := start; lower != middle; lower++ {\n\t\tarrayproto_reverse_generic_step(o, lower, l-lower-1)\n\t}\n}\n\nfunc (r *Runtime) arrayproto_reverse(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tif a := r.checkStdArrayObj(o); a != nil {\n\t\tl := len(a.values)\n\t\tmiddle := l / 2\n\t\tfor lower := 0; lower != middle; lower++ {\n\t\t\tupper := l - lower - 1\n\t\t\ta.values[lower], a.values[upper] = a.values[upper], a.values[lower]\n\t\t}\n\t\t//TODO: go arrays\n\t} else {\n\t\tr.arrayproto_reverse_generic(o, 0)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) arrayproto_shift(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tif a := r.checkStdArrayObjWithProto(o); a != nil {\n\t\tif len(a.values) == 0 {\n\t\t\tif !a.lengthProp.writable {\n\t\t\t\ta.setLength(0, true) // will throw\n\t\t\t}\n\t\t\treturn _undefined\n\t\t}\n\t\tfirst := a.values[0]\n\t\tcopy(a.values, a.values[1:])\n\t\ta.values[len(a.values)-1] = nil\n\t\ta.values = a.values[:len(a.values)-1]\n\t\ta.length--\n\t\treturn first\n\t}\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif length == 0 {\n\t\to.self.setOwnStr(\"length\", intToValue(0), true)\n\t\treturn _undefined\n\t}\n\tfirst := o.self.getIdx(valueInt(0), nil)\n\tfor i := int64(1); i < length; i++ {\n\t\tidxFrom := valueInt(i)\n\t\tidxTo := valueInt(i - 1)\n\t\tif o.self.hasPropertyIdx(idxFrom) {\n\t\t\to.self.setOwnIdx(idxTo, nilSafe(o.self.getIdx(idxFrom, nil)), true)\n\t\t} else {\n\t\t\to.self.deleteIdx(idxTo, true)\n\t\t}\n\t}\n\n\tlv := valueInt(length - 1)\n\to.self.deleteIdx(lv, true)\n\to.self.setOwnStr(\"length\", lv, true)\n\n\treturn first\n}\n\nfunc (r *Runtime) arrayproto_values(call FunctionCall) Value {\n\treturn r.createArrayIterator(call.This.ToObject(r), iterationKindValue)\n}\n\nfunc (r *Runtime) arrayproto_keys(call FunctionCall) Value {\n\treturn r.createArrayIterator(call.This.ToObject(r), iterationKindKey)\n}\n\nfunc (r *Runtime) arrayproto_copyWithin(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tvar relEnd, dir int64\n\tto := relToIdx(call.Argument(0).ToInteger(), l)\n\tfrom := relToIdx(call.Argument(1).ToInteger(), l)\n\tif end := call.Argument(2); end != _undefined {\n\t\trelEnd = end.ToInteger()\n\t} else {\n\t\trelEnd = l\n\t}\n\tfinal := relToIdx(relEnd, l)\n\tcount := min(final-from, l-to)\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\tif count > 0 {\n\t\t\tcopy(arr.values[to:to+count], arr.values[from:from+count])\n\t\t}\n\t\treturn o\n\t}\n\tif from < to && to < from+count {\n\t\tdir = -1\n\t\tfrom = from + count - 1\n\t\tto = to + count - 1\n\t} else {\n\t\tdir = 1\n\t}\n\tfor count > 0 {\n\t\tif o.self.hasPropertyIdx(valueInt(from)) {\n\t\t\to.self.setOwnIdx(valueInt(to), nilSafe(o.self.getIdx(valueInt(from), nil)), true)\n\t\t} else {\n\t\t\to.self.deleteIdx(valueInt(to), true)\n\t\t}\n\t\tfrom += dir\n\t\tto += dir\n\t\tcount--\n\t}\n\n\treturn o\n}\n\nfunc (r *Runtime) arrayproto_entries(call FunctionCall) Value {\n\treturn r.createArrayIterator(call.This.ToObject(r), iterationKindKeyValue)\n}\n\nfunc (r *Runtime) arrayproto_fill(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tk := relToIdx(call.Argument(1).ToInteger(), l)\n\tvar relEnd int64\n\tif endArg := call.Argument(2); endArg != _undefined {\n\t\trelEnd = endArg.ToInteger()\n\t} else {\n\t\trelEnd = l\n\t}\n\tfinal := relToIdx(relEnd, l)\n\tvalue := call.Argument(0)\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\tfor ; k < final; k++ {\n\t\t\tarr.values[k] = value\n\t\t}\n\t} else {\n\t\tfor ; k < final; k++ {\n\t\t\to.self.setOwnIdx(valueInt(k), value, true)\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) arrayproto_find(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tpredicate := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(0); k < l; k++ {\n\t\tidx := valueInt(k)\n\t\tkValue := o.self.getIdx(idx, nil)\n\t\tfc.Arguments[0], fc.Arguments[1] = kValue, idx\n\t\tif predicate(fc).ToBoolean() {\n\t\t\treturn kValue\n\t\t}\n\t}\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) arrayproto_findIndex(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tpredicate := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(0); k < l; k++ {\n\t\tidx := valueInt(k)\n\t\tkValue := o.self.getIdx(idx, nil)\n\t\tfc.Arguments[0], fc.Arguments[1] = kValue, idx\n\t\tif predicate(fc).ToBoolean() {\n\t\t\treturn idx\n\t\t}\n\t}\n\n\treturn intToValue(-1)\n}\n\nfunc (r *Runtime) arrayproto_findLast(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tpredicate := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(l - 1); k >= 0; k-- {\n\t\tidx := valueInt(k)\n\t\tkValue := o.self.getIdx(idx, nil)\n\t\tfc.Arguments[0], fc.Arguments[1] = kValue, idx\n\t\tif predicate(fc).ToBoolean() {\n\t\t\treturn kValue\n\t\t}\n\t}\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) arrayproto_findLastIndex(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tpredicate := r.toCallable(call.Argument(0))\n\tfc := FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: []Value{nil, nil, o},\n\t}\n\tfor k := int64(l - 1); k >= 0; k-- {\n\t\tidx := valueInt(k)\n\t\tkValue := o.self.getIdx(idx, nil)\n\t\tfc.Arguments[0], fc.Arguments[1] = kValue, idx\n\t\tif predicate(fc).ToBoolean() {\n\t\t\treturn idx\n\t\t}\n\t}\n\n\treturn intToValue(-1)\n}\n\nfunc (r *Runtime) arrayproto_flat(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tdepthNum := int64(1)\n\tif len(call.Arguments) > 0 {\n\t\tdepthNum = call.Argument(0).ToInteger()\n\t}\n\ta := arraySpeciesCreate(o, 0)\n\tr.flattenIntoArray(a, o, l, 0, depthNum, nil, nil)\n\treturn a\n}\n\nfunc (r *Runtime) flattenIntoArray(target, source *Object, sourceLen, start, depth int64, mapperFunction func(FunctionCall) Value, thisArg Value) int64 {\n\ttargetIndex, sourceIndex := start, int64(0)\n\tfor sourceIndex < sourceLen {\n\t\tp := intToValue(sourceIndex)\n\t\tif source.hasProperty(p.toString()) {\n\t\t\telement := nilSafe(source.get(p, source))\n\t\t\tif mapperFunction != nil {\n\t\t\t\telement = mapperFunction(FunctionCall{\n\t\t\t\t\tThis:      thisArg,\n\t\t\t\t\tArguments: []Value{element, p, source},\n\t\t\t\t})\n\t\t\t}\n\t\t\tvar elementArray *Object\n\t\t\tif depth > 0 {\n\t\t\t\tif elementObj, ok := element.(*Object); ok && isArray(elementObj) {\n\t\t\t\t\telementArray = elementObj\n\t\t\t\t}\n\t\t\t}\n\t\t\tif elementArray != nil {\n\t\t\t\telementLen := toLength(elementArray.self.getStr(\"length\", nil))\n\t\t\t\ttargetIndex = r.flattenIntoArray(target, elementArray, elementLen, targetIndex, depth-1, nil, nil)\n\t\t\t} else {\n\t\t\t\tif targetIndex >= maxInt-1 {\n\t\t\t\t\tpanic(r.NewTypeError(\"Invalid array length\"))\n\t\t\t\t}\n\t\t\t\tcreateDataPropertyOrThrow(target, intToValue(targetIndex), element)\n\t\t\t\ttargetIndex++\n\t\t\t}\n\t\t}\n\t\tsourceIndex++\n\t}\n\treturn targetIndex\n}\n\nfunc (r *Runtime) arrayproto_flatMap(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tcallbackFn := r.toCallable(call.Argument(0))\n\tthisArg := Undefined()\n\tif len(call.Arguments) > 1 {\n\t\tthisArg = call.Argument(1)\n\t}\n\ta := arraySpeciesCreate(o, 0)\n\tr.flattenIntoArray(a, o, l, 0, 1, callbackFn, thisArg)\n\treturn a\n}\n\nfunc (r *Runtime) arrayproto_with(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\trelativeIndex := call.Argument(0).ToInteger()\n\tvalue := call.Argument(1)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\n\tactualIndex := int64(0)\n\tif relativeIndex >= 0 {\n\t\tactualIndex = relativeIndex\n\t} else {\n\t\tactualIndex = length + relativeIndex\n\t}\n\tif actualIndex >= length || actualIndex < 0 {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid index %s\", call.Argument(0).String()))\n\t}\n\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\ta := make([]Value, 0, length)\n\t\tfor k := int64(0); k < length; k++ {\n\t\t\tpk := valueInt(k)\n\t\t\tvar fromValue Value\n\t\t\tif k == actualIndex {\n\t\t\t\tfromValue = value\n\t\t\t} else {\n\t\t\t\tfromValue = src.values[pk]\n\t\t\t}\n\t\t\ta = append(a, fromValue)\n\t\t}\n\t\treturn r.newArrayValues(a)\n\t} else {\n\t\ta := r.newArrayLength(length)\n\t\tfor k := int64(0); k < length; k++ {\n\t\t\tpk := valueInt(k)\n\t\t\tvar fromValue Value\n\t\t\tif k == actualIndex {\n\t\t\t\tfromValue = value\n\t\t\t} else {\n\t\t\t\tfromValue = o.self.getIdx(pk, nil)\n\t\t\t}\n\t\t\tcreateDataPropertyOrThrow(a, pk, fromValue)\n\t\t}\n\t\treturn a\n\t}\n}\n\nfunc (r *Runtime) arrayproto_toReversed(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\ta := make([]Value, 0, length)\n\t\tfor k := int64(0); k < length; k++ {\n\t\t\tfrom := valueInt(length - k - 1)\n\t\t\tfromValue := src.values[from]\n\t\t\ta = append(a, fromValue)\n\t\t}\n\t\treturn r.newArrayValues(a)\n\t} else {\n\t\ta := r.newArrayLength(length)\n\t\tfor k := int64(0); k < length; k++ {\n\t\t\tpk := valueInt(k)\n\t\t\tfrom := valueInt(length - k - 1)\n\t\t\tfromValue := o.self.getIdx(from, nil)\n\t\t\tcreateDataPropertyOrThrow(a, pk, fromValue)\n\t\t}\n\t\treturn a\n\t}\n}\n\nfunc (r *Runtime) arrayproto_toSorted(call FunctionCall) Value {\n\tvar compareFn func(FunctionCall) Value\n\targ := call.Argument(0)\n\tif arg != _undefined {\n\t\tif arg, ok := arg.(*Object); ok {\n\t\t\tcompareFn, _ = arg.self.assertCallable()\n\t\t}\n\t\tif compareFn == nil {\n\t\t\tpanic(r.NewTypeError(\"The comparison function must be either a function or undefined\"))\n\t\t}\n\t}\n\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tif length >= math.MaxUint32 {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid array length\"))\n\t}\n\tvar a []Value\n\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\ta = make([]Value, length)\n\t\tcopy(a, src.values)\n\t} else {\n\t\ta = make([]Value, 0, length)\n\t\tfor i := int64(0); i < length; i++ {\n\t\t\tidx := valueInt(i)\n\t\t\ta = append(a, nilSafe(o.self.getIdx(idx, nil)))\n\t\t}\n\t}\n\n\tar := r.newArrayValues(a)\n\tctx := arraySortCtx{\n\t\tobj:     ar.self,\n\t\tcompare: compareFn,\n\t}\n\n\tsort.Stable(&ctx)\n\treturn ar\n}\n\nfunc (r *Runtime) arrayproto_toSpliced(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tlength := toLength(o.self.getStr(\"length\", nil))\n\tactualStart := relToIdx(call.Argument(0).ToInteger(), length)\n\tvar actualSkipCount int64\n\tif len(call.Arguments) == 1 {\n\t\tactualSkipCount = length - actualStart\n\t} else if len(call.Arguments) > 1 {\n\t\tactualSkipCount = min(max(call.Argument(1).ToInteger(), 0), length-actualStart)\n\t}\n\titemCount := max(int64(len(call.Arguments)-2), 0)\n\tnewLength := length - actualSkipCount + itemCount\n\tif newLength >= maxInt {\n\t\tpanic(r.NewTypeError(\"Invalid array length\"))\n\t}\n\n\tif src := r.checkStdArrayObj(o); src != nil {\n\t\tvar values []Value\n\t\tif itemCount == actualSkipCount {\n\t\t\tvalues = make([]Value, len(src.values))\n\t\t\tcopy(values, src.values)\n\t\t} else {\n\t\t\tvalues = make([]Value, newLength)\n\t\t\tcopy(values, src.values[:actualStart])\n\t\t\tcopy(values[actualStart+itemCount:], src.values[actualStart+actualSkipCount:])\n\t\t}\n\t\tif itemCount > 0 {\n\t\t\tcopy(values[actualStart:], call.Arguments[2:])\n\t\t}\n\t\treturn r.newArrayValues(values)\n\t} else {\n\t\ta := r.newArrayLength(newLength)\n\t\tvar i int64\n\t\trl := actualStart + actualSkipCount\n\n\t\tfor i < actualStart {\n\t\t\tpi := valueInt(i)\n\t\t\tiValue := nilSafe(o.self.getIdx(pi, nil))\n\t\t\tcreateDataPropertyOrThrow(a, pi, iValue)\n\t\t\ti++\n\t\t}\n\n\t\tif itemCount > 0 {\n\t\t\tfor _, item := range call.Arguments[2:] {\n\t\t\t\tcreateDataPropertyOrThrow(a, valueInt(i), nilSafe(item))\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tfor i < newLength {\n\t\t\tpi := valueInt(i)\n\t\t\tfrom := valueInt(rl)\n\t\t\tfromValue := nilSafe(o.self.getIdx(from, nil))\n\t\t\tcreateDataPropertyOrThrow(a, pi, fromValue)\n\t\t\ti++\n\t\t\trl++\n\t\t}\n\n\t\treturn a\n\t}\n}\n\nfunc (r *Runtime) checkStdArrayObj(obj *Object) *arrayObject {\n\tif arr, ok := obj.self.(*arrayObject); ok &&\n\t\tarr.propValueCount == 0 &&\n\t\tarr.length == uint32(len(arr.values)) &&\n\t\tuint32(arr.objCount) == arr.length {\n\n\t\treturn arr\n\t}\n\n\treturn nil\n}\n\nfunc (r *Runtime) checkStdArrayObjWithProto(obj *Object) *arrayObject {\n\tif arr := r.checkStdArrayObj(obj); arr != nil {\n\t\tif p1, ok := arr.prototype.self.(*arrayObject); ok && p1.propValueCount == 0 {\n\t\t\tif p2, ok := p1.prototype.self.(*baseObject); ok && p2.prototype == nil {\n\t\t\t\tp2.ensurePropOrder()\n\t\t\t\tif p2.idxPropCount == 0 {\n\t\t\t\t\treturn arr\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (r *Runtime) checkStdArray(v Value) *arrayObject {\n\tif obj, ok := v.(*Object); ok {\n\t\treturn r.checkStdArrayObj(obj)\n\t}\n\n\treturn nil\n}\n\nfunc (r *Runtime) checkStdArrayIter(v Value) *arrayObject {\n\tif arr := r.checkStdArray(v); arr != nil &&\n\t\tarr.getSym(SymIterator, nil) == r.getArrayValues() {\n\n\t\treturn arr\n\t}\n\n\treturn nil\n}\n\nfunc (r *Runtime) array_from(call FunctionCall) Value {\n\tvar mapFn func(FunctionCall) Value\n\tif mapFnArg := call.Argument(1); mapFnArg != _undefined {\n\t\tif mapFnObj, ok := mapFnArg.(*Object); ok {\n\t\t\tif fn, ok := mapFnObj.self.assertCallable(); ok {\n\t\t\t\tmapFn = fn\n\t\t\t}\n\t\t}\n\t\tif mapFn == nil {\n\t\t\tpanic(r.NewTypeError(\"%s is not a function\", mapFnArg))\n\t\t}\n\t}\n\tt := call.Argument(2)\n\titems := call.Argument(0)\n\tif mapFn == nil && call.This == r.global.Array { // mapFn may mutate the array\n\t\tif arr := r.checkStdArrayIter(items); arr != nil {\n\t\t\titems := make([]Value, len(arr.values))\n\t\t\tcopy(items, arr.values)\n\t\t\treturn r.newArrayValues(items)\n\t\t}\n\t}\n\n\tvar ctor func(args []Value, newTarget *Object) *Object\n\tif call.This != r.global.Array {\n\t\tif o, ok := call.This.(*Object); ok {\n\t\t\tif c := o.self.assertConstructor(); c != nil {\n\t\t\t\tctor = c\n\t\t\t}\n\t\t}\n\t}\n\tvar arr *Object\n\tif usingIterator := toMethod(r.getV(items, SymIterator)); usingIterator != nil {\n\t\tif ctor != nil {\n\t\t\tarr = ctor([]Value{}, nil)\n\t\t} else {\n\t\t\tarr = r.newArrayValues(nil)\n\t\t}\n\t\titer := r.getIterator(items, usingIterator)\n\t\tif mapFn == nil {\n\t\t\tif a := r.checkStdArrayObjWithProto(arr); a != nil {\n\t\t\t\tvar values []Value\n\t\t\t\titer.iterate(func(val Value) {\n\t\t\t\t\tvalues = append(values, val)\n\t\t\t\t})\n\t\t\t\tsetArrayValues(a, values)\n\t\t\t\treturn arr\n\t\t\t}\n\t\t}\n\t\tk := int64(0)\n\t\titer.iterate(func(val Value) {\n\t\t\tif mapFn != nil {\n\t\t\t\tval = mapFn(FunctionCall{This: t, Arguments: []Value{val, intToValue(k)}})\n\t\t\t}\n\t\t\tcreateDataPropertyOrThrow(arr, intToValue(k), val)\n\t\t\tk++\n\t\t})\n\t\tarr.self.setOwnStr(\"length\", intToValue(k), true)\n\t} else {\n\t\tarrayLike := items.ToObject(r)\n\t\tl := toLength(arrayLike.self.getStr(\"length\", nil))\n\t\tif ctor != nil {\n\t\t\tarr = ctor([]Value{intToValue(l)}, nil)\n\t\t} else {\n\t\t\tarr = r.newArrayValues(nil)\n\t\t}\n\t\tif mapFn == nil {\n\t\t\tif a := r.checkStdArrayObjWithProto(arr); a != nil {\n\t\t\t\tvalues := make([]Value, l)\n\t\t\t\tfor k := int64(0); k < l; k++ {\n\t\t\t\t\tvalues[k] = nilSafe(arrayLike.self.getIdx(valueInt(k), nil))\n\t\t\t\t}\n\t\t\t\tsetArrayValues(a, values)\n\t\t\t\treturn arr\n\t\t\t}\n\t\t}\n\t\tfor k := int64(0); k < l; k++ {\n\t\t\tidx := valueInt(k)\n\t\t\titem := arrayLike.self.getIdx(idx, nil)\n\t\t\tif mapFn != nil {\n\t\t\t\titem = mapFn(FunctionCall{This: t, Arguments: []Value{item, idx}})\n\t\t\t} else {\n\t\t\t\titem = nilSafe(item)\n\t\t\t}\n\t\t\tcreateDataPropertyOrThrow(arr, idx, item)\n\t\t}\n\t\tarr.self.setOwnStr(\"length\", intToValue(l), true)\n\t}\n\n\treturn arr\n}\n\nfunc (r *Runtime) array_isArray(call FunctionCall) Value {\n\tif o, ok := call.Argument(0).(*Object); ok {\n\t\tif isArray(o) {\n\t\t\treturn valueTrue\n\t\t}\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) array_of(call FunctionCall) Value {\n\tvar ctor func(args []Value, newTarget *Object) *Object\n\tif call.This != r.global.Array {\n\t\tif o, ok := call.This.(*Object); ok {\n\t\t\tif c := o.self.assertConstructor(); c != nil {\n\t\t\t\tctor = c\n\t\t\t}\n\t\t}\n\t}\n\tif ctor == nil {\n\t\tvalues := make([]Value, len(call.Arguments))\n\t\tcopy(values, call.Arguments)\n\t\treturn r.newArrayValues(values)\n\t}\n\tl := intToValue(int64(len(call.Arguments)))\n\tarr := ctor([]Value{l}, nil)\n\tfor i, val := range call.Arguments {\n\t\tcreateDataPropertyOrThrow(arr, intToValue(int64(i)), val)\n\t}\n\tarr.self.setOwnStr(\"length\", l, true)\n\treturn arr\n}\n\nfunc (r *Runtime) arrayIterProto_next(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif iter, ok := thisObj.self.(*arrayIterObject); ok {\n\t\treturn iter.next()\n\t}\n\tpanic(r.NewTypeError(\"Method Array Iterator.prototype.next called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc createArrayProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(_positiveZero, true, false, false) })\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getArray(), true, false, true) })\n\n\tt.putStr(\"at\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_at, \"at\", 1) })\n\tt.putStr(\"concat\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_concat, \"concat\", 1) })\n\tt.putStr(\"copyWithin\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_copyWithin, \"copyWithin\", 2) })\n\tt.putStr(\"entries\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_entries, \"entries\", 0) })\n\tt.putStr(\"every\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_every, \"every\", 1) })\n\tt.putStr(\"fill\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_fill, \"fill\", 1) })\n\tt.putStr(\"filter\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_filter, \"filter\", 1) })\n\tt.putStr(\"find\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_find, \"find\", 1) })\n\tt.putStr(\"findIndex\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_findIndex, \"findIndex\", 1) })\n\tt.putStr(\"findLast\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_findLast, \"findLast\", 1) })\n\tt.putStr(\"findLastIndex\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_findLastIndex, \"findLastIndex\", 1) })\n\tt.putStr(\"flat\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_flat, \"flat\", 0) })\n\tt.putStr(\"flatMap\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_flatMap, \"flatMap\", 1) })\n\tt.putStr(\"forEach\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_forEach, \"forEach\", 1) })\n\tt.putStr(\"includes\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_includes, \"includes\", 1) })\n\tt.putStr(\"indexOf\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_indexOf, \"indexOf\", 1) })\n\tt.putStr(\"join\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_join, \"join\", 1) })\n\tt.putStr(\"keys\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_keys, \"keys\", 0) })\n\tt.putStr(\"lastIndexOf\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_lastIndexOf, \"lastIndexOf\", 1) })\n\tt.putStr(\"map\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_map, \"map\", 1) })\n\tt.putStr(\"pop\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_pop, \"pop\", 0) })\n\tt.putStr(\"push\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_push, \"push\", 1) })\n\tt.putStr(\"reduce\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_reduce, \"reduce\", 1) })\n\tt.putStr(\"reduceRight\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_reduceRight, \"reduceRight\", 1) })\n\tt.putStr(\"reverse\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_reverse, \"reverse\", 0) })\n\tt.putStr(\"shift\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_shift, \"shift\", 0) })\n\tt.putStr(\"slice\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_slice, \"slice\", 2) })\n\tt.putStr(\"some\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_some, \"some\", 1) })\n\tt.putStr(\"sort\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_sort, \"sort\", 1) })\n\tt.putStr(\"splice\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_splice, \"splice\", 2) })\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_toLocaleString, \"toLocaleString\", 0) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return valueProp(r.getArrayToString(), true, false, true) })\n\tt.putStr(\"unshift\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_unshift, \"unshift\", 1) })\n\tt.putStr(\"with\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_with, \"with\", 2) })\n\tt.putStr(\"toReversed\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_toReversed, \"toReversed\", 0) })\n\tt.putStr(\"toSorted\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_toSorted, \"toSorted\", 1) })\n\tt.putStr(\"toSpliced\", func(r *Runtime) Value { return r.methodProp(r.arrayproto_toSpliced, \"toSpliced\", 2) })\n\tt.putStr(\"values\", func(r *Runtime) Value { return valueProp(r.getArrayValues(), true, false, true) })\n\n\tt.putSym(SymIterator, func(r *Runtime) Value { return valueProp(r.getArrayValues(), true, false, true) })\n\tt.putSym(SymUnscopables, func(r *Runtime) Value {\n\t\tbl := r.newBaseObject(nil, classObject)\n\t\tbl.setOwnStr(\"copyWithin\", valueTrue, true)\n\t\tbl.setOwnStr(\"entries\", valueTrue, true)\n\t\tbl.setOwnStr(\"fill\", valueTrue, true)\n\t\tbl.setOwnStr(\"find\", valueTrue, true)\n\t\tbl.setOwnStr(\"findIndex\", valueTrue, true)\n\t\tbl.setOwnStr(\"findLast\", valueTrue, true)\n\t\tbl.setOwnStr(\"findLastIndex\", valueTrue, true)\n\t\tbl.setOwnStr(\"flat\", valueTrue, true)\n\t\tbl.setOwnStr(\"flatMap\", valueTrue, true)\n\t\tbl.setOwnStr(\"includes\", valueTrue, true)\n\t\tbl.setOwnStr(\"keys\", valueTrue, true)\n\t\tbl.setOwnStr(\"values\", valueTrue, true)\n\t\tbl.setOwnStr(\"groupBy\", valueTrue, true)\n\t\tbl.setOwnStr(\"groupByToMap\", valueTrue, true)\n\t\tbl.setOwnStr(\"toReversed\", valueTrue, true)\n\t\tbl.setOwnStr(\"toSorted\", valueTrue, true)\n\t\tbl.setOwnStr(\"toSpliced\", valueTrue, true)\n\n\t\treturn valueProp(bl.val, false, false, true)\n\t})\n\n\treturn t\n}\n\nvar arrayProtoTemplate *objectTemplate\nvar arrayProtoTemplateOnce sync.Once\n\nfunc getArrayProtoTemplate() *objectTemplate {\n\tarrayProtoTemplateOnce.Do(func() {\n\t\tarrayProtoTemplate = createArrayProtoTemplate()\n\t})\n\treturn arrayProtoTemplate\n}\n\nfunc (r *Runtime) getArrayPrototype() *Object {\n\tret := r.global.ArrayPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.ArrayPrototype = ret\n\t\tr.newTemplatedArrayObject(getArrayProtoTemplate(), ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getArray() *Object {\n\tret := r.global.Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tret.self = r.createArray(ret)\n\t\tr.global.Array = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) createArray(val *Object) objectImpl {\n\to := r.newNativeFuncConstructObj(val, r.builtin_newArray, \"Array\", r.getArrayPrototype(), 1)\n\to._putProp(\"from\", r.newNativeFunc(r.array_from, \"from\", 1), true, false, true)\n\to._putProp(\"isArray\", r.newNativeFunc(r.array_isArray, \"isArray\", 1), true, false, true)\n\to._putProp(\"of\", r.newNativeFunc(r.array_of, \"of\", 0), true, false, true)\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) createArrayIterProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"next\", r.newNativeFunc(r.arrayIterProto_next, \"next\", 0), true, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classArrayIterator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getArrayValues() *Object {\n\tret := r.global.arrayValues\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.arrayproto_values, \"values\", 0)\n\t\tr.global.arrayValues = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getArrayToString() *Object {\n\tret := r.global.arrayToString\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.arrayproto_toString, \"toString\", 0)\n\t\tr.global.arrayToString = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getArrayIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.ArrayIteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.ArrayIteratorPrototype = o\n\t\to.self = r.createArrayIterProto(o)\n\t}\n\treturn o\n\n}\n\ntype sortable interface {\n\tsortLen() int\n\tsortGet(int) Value\n\tswap(int, int)\n}\n\ntype arraySortCtx struct {\n\tobj     sortable\n\tcompare func(FunctionCall) Value\n}\n\nfunc (a *arraySortCtx) sortCompare(x, y Value) int {\n\tif x == nil && y == nil {\n\t\treturn 0\n\t}\n\n\tif x == nil {\n\t\treturn 1\n\t}\n\n\tif y == nil {\n\t\treturn -1\n\t}\n\n\tif x == _undefined && y == _undefined {\n\t\treturn 0\n\t}\n\n\tif x == _undefined {\n\t\treturn 1\n\t}\n\n\tif y == _undefined {\n\t\treturn -1\n\t}\n\n\tif a.compare != nil {\n\t\tf := a.compare(FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{x, y},\n\t\t}).ToFloat()\n\t\tif f > 0 {\n\t\t\treturn 1\n\t\t}\n\t\tif f < 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif math.Signbit(f) {\n\t\t\treturn -1\n\t\t}\n\t\treturn 0\n\t}\n\treturn x.toString().CompareTo(y.toString())\n}\n\n// sort.Interface\n\nfunc (a *arraySortCtx) Len() int {\n\treturn a.obj.sortLen()\n}\n\nfunc (a *arraySortCtx) Less(j, k int) bool {\n\treturn a.sortCompare(a.obj.sortGet(j), a.obj.sortGet(k)) < 0\n}\n\nfunc (a *arraySortCtx) Swap(j, k int) {\n\ta.obj.swap(j, k)\n}\n"
        },
        {
          "name": "builtin_arrray_test.go",
          "type": "blob",
          "size": 9.0625,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArrayProtoProp(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(Array.prototype, '0', {value: 42, configurable: true, writable: false})\n\tvar a = []\n\ta[0] = 1\n\ta[0]\n\t`\n\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestArrayDelete(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [1, 2];\n\tvar deleted = delete a[0];\n\tvar undef = a[0] === undefined;\n\tvar len = a.length;\n\n\tdeleted && undef && len === 2;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayDeleteNonexisting(t *testing.T) {\n\tconst SCRIPT = `\n\tArray.prototype[0] = 42;\n\tvar a = [];\n\tdelete a[0] && a[0] === 42;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArraySetLength(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [1, 2];\n\tvar assert0 = a.length == 2;\n\ta.length = \"1\";\n\ta.length = 1.0;\n\ta.length = 1;\n\tvar assert1 = a.length == 1;\n\ta.length = 2;\n\tvar assert2 = a.length == 2;\n\tassert0 && assert1 && assert2 && a[1] === undefined;\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayReverseNonOptimisable(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [];\n\tObject.defineProperty(a, \"0\", {get: function() {return 42}, set: function(v) {Object.defineProperty(a, \"0\", {value: v + 1, writable: true, configurable: true})}, configurable: true})\n\ta[1] = 43;\n\ta.reverse();\n\n\ta.length === 2 && a[0] === 44 && a[1] === 42;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayPushNonOptimisable(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(Object.prototype, \"0\", {value: 42});\n\tvar a = [];\n\tvar thrown = false;\n\ttry {\n\t\ta.push(1);\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArraySetLengthWithPropItems(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [1,2,3,4];\n\tvar thrown = false;\n\n\tObject.defineProperty(a, \"2\", {value: 42, configurable: false, writable: false});\n\ttry {\n\t\tObject.defineProperty(a, \"length\", {value: 0, writable: false});\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\tthrown && a.length === 3;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayFrom(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction checkDestHoles(dest, prefix) {\n\t\tassert(dest !== source, prefix + \": dest !== source\");\n\t\tassert.sameValue(dest.length, 3, prefix + \": dest.length\");\n\t\tassert.sameValue(dest[0], 1, prefix + \": [0]\");\n\t\tassert.sameValue(dest[1], undefined, prefix + \": [1]\");\n\t\tassert(dest.hasOwnProperty(\"1\"), prefix + ': hasOwnProperty(\"1\")');\n\t\tassert.sameValue(dest[2], 3, prefix + \": [2]\");\n\t}\n\n\tfunction checkDest(dest, prefix) {\n\t\tassert(dest !== source, prefix + \": dest !== source\");\n\t\tassert.sameValue(dest.length, 3, prefix + \": dest.length\");\n\t\tassert.sameValue(dest[0], 1, prefix + \": [0]\");\n\t\tassert.sameValue(dest[1], 2, prefix + \": [1]\");\n\t\tassert.sameValue(dest[2], 3, prefix + \": [2]\");\n\t}\n\n\tvar source = [1,2,3];\n\tvar srcHoles = [1,,3];\n\n\tcheckDest(Array.from(source), \"std source/std dest\");\n\tcheckDestHoles(Array.from(srcHoles), \"std source (holes)/std dest\");\n\n\tfunction Iter() {\n\t\tthis.idx = 0;\n\t}\n\tIter.prototype.next = function() {\n\t\tif (this.idx < source.length) {\n\t\t\treturn {value: source[this.idx++]};\n\t\t} else {\n\t\t\treturn {done: true};\n\t\t}\n\t}\n\n\tvar src = {};\n\tsrc[Symbol.iterator] = function() {\n\t\treturn new Iter();\n\t}\n\tcheckDest(Array.from(src), \"iter src/std dest\");\n\n\tsrc = {0: 1, 2: 3, length: 3};\n\tcheckDestHoles(Array.from(src), \"arrayLike src/std dest\");\n\n\tfunction A() {}\n\tA.from = Array.from;\n\n\tcheckDest(A.from(source), \"std src/cust dest\");\n\tcheckDestHoles(A.from(srcHoles), \"std src (holes)/cust dest\");\n\tcheckDestHoles(A.from(src), \"arrayLike src/cust dest\");\n\n\tfunction T2() {\n\t  Object.defineProperty(this, 0, {\n\t\tconfigurable: false,\n\t\twritable: true,\n\t\tenumerable: true\n\t  });\n\t}\n\n\tassert.throws(TypeError, function() {\n\t\tArray.from.call(T2, source);\n\t});\n\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayOf(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction T1() {\n\t  Object.preventExtensions(this);\n\t}\n\t\n\tassert.throws(TypeError, function() {\n\t  Array.of.call(T1, 'Bob');\n\t});\n\n\tfunction T2() {\n\t  Object.defineProperty(this, 0, {\n\t\tconfigurable: false,\n\t\twritable: true,\n\t\tenumerable: true\n\t  });\n\t}\n\t\n\tassert.throws(TypeError, function() {\n\t  Array.of.call(T2, 'Bob');\n\t})\n\n\tresult = Array.of.call(undefined);\n\tassert(\n\t  result instanceof Array,\n\t  'this is not a constructor'\n\t);\n\n\tresult = Array.of.call(Math.cos);\n\tassert(\n\t  result instanceof Array,\n\t  'this is a builtin function with no [[Construct]] slot'\n\t);\n\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestUnscopables(t *testing.T) {\n\tconst SCRIPT = `\n\tvar keys = [];\n\tvar _length;\n\twith (Array.prototype) {\n\t\t_length = length;\n\t\tkeys.push('something');\n\t}\n\t_length === 0 && keys.length === 1 && keys[0] === \"something\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArraySort(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(TypeError, function() {\n\t\t[1,2].sort(null);\n\t}, \"null compare function\");\n\tassert.throws(TypeError, function() {\n\t\t[1,2].sort({});\n\t}, \"non-callable compare function\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestArraySortNonStdArray(t *testing.T) {\n\tconst SCRIPT = `\n\tconst array = [undefined, 'c', /*hole*/, 'b', undefined, /*hole*/, 'a', 'd'];\n\n\tObject.defineProperty(array, '2', {\n\t  get() {\n\t\tarray.pop();\n\t\tarray.pop();\n\t\treturn this.foo;\n\t  },\n\t  set(v) {\n\t\tthis.foo = v;\n\t  }\n\t});\n\n\tarray.sort();\n\n\tassert.sameValue(array[0], 'b');\n\tassert.sameValue(array[1], 'c');\n\tassert.sameValue(array[3], undefined);\n\tassert.sameValue(array[4], undefined);\n\tassert.sameValue('5' in array, false);\n\tassert.sameValue(array.hasOwnProperty('5'), false);\n\tassert.sameValue(array.length, 6);\n\tassert.sameValue(array.foo, undefined);\n\n\tassert.sameValue(array[2], undefined);\n\tassert.sameValue(array.length, 4);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayConcat(t *testing.T) {\n\tconst SCRIPT = `\n\tvar concat = Array.prototype.concat;\n\tvar array = [1, 2];\n\tvar sparseArray = [1, , 2];\n\tvar nonSpreadableArray = [1, 2];\n\tnonSpreadableArray[Symbol.isConcatSpreadable] = false;\n\tvar arrayLike = { 0: 1, 1: 2, length: 2 };\n\tvar spreadableArrayLike = { 0: 1, 1: 2, length: 2 };\n\tspreadableArrayLike[Symbol.isConcatSpreadable] = true;\n\tassert(looksNative(concat));\n\tassert(deepEqual(array.concat(), [1, 2]), '#1');\n\tassert(deepEqual(sparseArray.concat(), [1, , 2]), '#2');\n\tassert(deepEqual(nonSpreadableArray.concat(), [[1, 2]]), '#3');\n\tassert(deepEqual(concat.call(arrayLike), [{ 0: 1, 1: 2, length: 2 }]), '#4');\n\tassert(deepEqual(concat.call(spreadableArrayLike), [1, 2]), '#5');\n\tassert(deepEqual([].concat(array), [1, 2]), '#6');\n\tassert(deepEqual([].concat(sparseArray), [1, , 2]), '#7');\n\tassert(deepEqual([].concat(nonSpreadableArray), [[1, 2]]), '#8');\n\tassert(deepEqual([].concat(arrayLike), [{ 0: 1, 1: 2, length: 2 }]), '#9');\n\tassert(deepEqual([].concat(spreadableArrayLike), [1, 2]), '#10');\n\tassert(deepEqual(array.concat(sparseArray, nonSpreadableArray, arrayLike, spreadableArrayLike), [\n\t1, 2, 1, , 2, [1, 2], { 0: 1, 1: 2, length: 2 }, 1, 2,\n\t]), '#11');\n\tarray = [];\n\tarray.constructor = {};\n\tarray.constructor[Symbol.species] = function () {\n\t\treturn { foo: 1 };\n\t}\n\tassert.sameValue(array.concat().foo, 1, '@@species');\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayFlat(t *testing.T) {\n\tconst SCRIPT = `\n\tvar array = [1, [2,3,[4,5,6]], [[[[7,8,9]]]]];\n\tassert(deepEqual(array.flat(), [1,2,3,[4,5,6],[[[7,8,9]]]]), '#1');\n\tassert(deepEqual(array.flat(1), [1,2,3,[4,5,6],[[[7,8,9]]]]), '#2');\n\tassert(deepEqual(array.flat(3), [1,2,3,4,5,6,[7,8,9]]), '#3');\n\tassert(deepEqual(array.flat(4), [1,2,3,4,5,6,7,8,9]), '#4');\n\tassert(deepEqual(array.flat(10), [1,2,3,4,5,6,7,8,9]), '#5');\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayFlatMap(t *testing.T) {\n\tconst SCRIPT = `\n\tvar double = function(x) {\n\t\tif (isNaN(x)) {\n\t\t\treturn x\n\t\t}\n\t\treturn x * 2\n\t}\n\tvar array = [1, [2,3,[4,5,6]], [[[[7,8,9]]]]];\n\tassert(deepEqual(array.flatMap(double), [2,2,3,[4,5,6],[[[7,8,9]]]]), '#1');\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayProto(t *testing.T) {\n\tconst SCRIPT = `\n\tconst a = Array.prototype;\n\ta.push(1, 2, 3, 4, 5);\n\tassert.sameValue(a.length, 5);\n\tassert.sameValue(a[0], 1);\n\ta.length = 3;\n\tassert.sameValue(a.length, 3);\n\tassert(compareArray(a, [1, 2, 3]));\n\ta.shift();\n\tassert.sameValue(a.length, 2);\n\tassert(compareArray(a, [2, 3]));\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayToSpliced(t *testing.T) {\n\tconst SCRIPT = `\n\tconst a = [1, 2, 3];\n\ta.push(4)\n\tassert(compareArray(a, [1, 2, 3, 4]));\n\tconst b = a.toSpliced(2)\n\tassert(compareArray(a, [1, 2, 3, 4]));\n\tassert(compareArray(b, [1, 2]));\n\ta.push(5)\n\tconst c = a.toSpliced(1, 2);\n\tassert(compareArray(a, [1, 2, 3, 4, 5]));\n\tassert(compareArray(c, [1, 4, 5]));\n\tassert(compareArray(a.toSpliced(4, 2, 'a', 'b'), [1, 2, 3, 4, 'a', 'b']));\n\tassert(compareArray(a, [1, 2, 3, 4, 5]));\n\tassert(compareArray(a.toSpliced(-2, 2), [1, 2, 3]));\n\tassert(compareArray(a, [1, 2, 3, 4, 5]));\n\tassert(compareArray(a.toSpliced(2, 10), [1, 2]));\n\tassert(compareArray(a, [1, 2, 3, 4, 5]));\n\tassert(compareArray(a.toSpliced(1, 0, 'a'), [1, 'a', 2, 3, 4, 5]));\n\tassert(compareArray(a, [1, 2, 3, 4, 5]));\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "builtin_bigint.go",
          "type": "blob",
          "size": 9.5361328125,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"hash/maphash\"\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype valueBigInt big.Int\n\nfunc (v *valueBigInt) ToInteger() int64 {\n\tv.ToNumber()\n\treturn 0\n}\n\nfunc (v *valueBigInt) toString() String {\n\treturn asciiString((*big.Int)(v).String())\n}\n\nfunc (v *valueBigInt) string() unistring.String {\n\treturn unistring.String(v.String())\n}\n\nfunc (v *valueBigInt) ToString() Value {\n\treturn v\n}\n\nfunc (v *valueBigInt) String() string {\n\treturn (*big.Int)(v).String()\n}\n\nfunc (v *valueBigInt) ToFloat() float64 {\n\tv.ToNumber()\n\treturn 0\n}\n\nfunc (v *valueBigInt) ToNumber() Value {\n\tpanic(typeError(\"Cannot convert a BigInt value to a number\"))\n}\n\nfunc (v *valueBigInt) ToBoolean() bool {\n\treturn (*big.Int)(v).Sign() != 0\n}\n\nfunc (v *valueBigInt) ToObject(r *Runtime) *Object {\n\treturn r.newPrimitiveObject(v, r.getBigIntPrototype(), classObject)\n}\n\nfunc (v *valueBigInt) SameAs(other Value) bool {\n\tif o, ok := other.(*valueBigInt); ok {\n\t\treturn (*big.Int)(v).Cmp((*big.Int)(o)) == 0\n\t}\n\treturn false\n}\n\nfunc (v *valueBigInt) Equals(other Value) bool {\n\tswitch o := other.(type) {\n\tcase *valueBigInt:\n\t\treturn (*big.Int)(v).Cmp((*big.Int)(o)) == 0\n\tcase valueInt:\n\t\treturn (*big.Int)(v).Cmp(big.NewInt(int64(o))) == 0\n\tcase valueFloat:\n\t\tif IsInfinity(o) || math.IsNaN(float64(o)) {\n\t\t\treturn false\n\t\t}\n\t\tif f := big.NewFloat(float64(o)); f.IsInt() {\n\t\t\ti, _ := f.Int(nil)\n\t\t\treturn (*big.Int)(v).Cmp(i) == 0\n\t\t}\n\t\treturn false\n\tcase String:\n\t\tbigInt, err := stringToBigInt(o.toTrimmedUTF8())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn bigInt.Cmp((*big.Int)(v)) == 0\n\tcase valueBool:\n\t\treturn (*big.Int)(v).Int64() == o.ToInteger()\n\tcase *Object:\n\t\treturn v.Equals(o.toPrimitiveNumber())\n\t}\n\treturn false\n}\n\nfunc (v *valueBigInt) StrictEquals(other Value) bool {\n\to, ok := other.(*valueBigInt)\n\tif ok {\n\t\treturn (*big.Int)(v).Cmp((*big.Int)(o)) == 0\n\t}\n\treturn false\n}\n\nfunc (v *valueBigInt) Export() interface{} {\n\treturn new(big.Int).Set((*big.Int)(v))\n}\n\nfunc (v *valueBigInt) ExportType() reflect.Type {\n\treturn typeBigInt\n}\n\nfunc (v *valueBigInt) baseObject(rt *Runtime) *Object {\n\treturn rt.getBigIntPrototype()\n}\n\nfunc (v *valueBigInt) hash(hash *maphash.Hash) uint64 {\n\tvar sign byte\n\tif (*big.Int)(v).Sign() < 0 {\n\t\tsign = 0x01\n\t} else {\n\t\tsign = 0x00\n\t}\n\t_ = hash.WriteByte(sign)\n\t_, _ = hash.Write((*big.Int)(v).Bytes())\n\th := hash.Sum64()\n\thash.Reset()\n\treturn h\n}\n\nfunc toBigInt(value Value) *valueBigInt {\n\t// Undefined\tThrow a TypeError exception.\n\t// Null\t\t\tThrow a TypeError exception.\n\t// Boolean\t\tReturn 1n if prim is true and 0n if prim is false.\n\t// BigInt\t\tReturn prim.\n\t// Number\t\tThrow a TypeError exception.\n\t// String\t\t1. Let n be StringToBigInt(prim).\n\t//\t\t\t\t2. If n is undefined, throw a SyntaxError exception.\n\t//\t\t\t\t3. Return n.\n\t// Symbol\t\tThrow a TypeError exception.\n\tswitch prim := value.(type) {\n\tcase *valueBigInt:\n\t\treturn prim\n\tcase String:\n\t\tbigInt, err := stringToBigInt(prim.toTrimmedUTF8())\n\t\tif err != nil {\n\t\t\tpanic(syntaxError(fmt.Sprintf(\"Cannot convert %s to a BigInt\", prim)))\n\t\t}\n\t\treturn (*valueBigInt)(bigInt)\n\tcase valueBool:\n\t\treturn (*valueBigInt)(big.NewInt(prim.ToInteger()))\n\tcase *Symbol:\n\t\tpanic(typeError(\"Cannot convert Symbol to a BigInt\"))\n\tcase *Object:\n\t\treturn toBigInt(prim.toPrimitiveNumber())\n\tdefault:\n\t\tpanic(typeError(fmt.Sprintf(\"Cannot convert %s to a BigInt\", prim)))\n\t}\n}\n\nfunc numberToBigInt(v Value) *valueBigInt {\n\tswitch v := toNumeric(v).(type) {\n\tcase *valueBigInt:\n\t\treturn v\n\tcase valueInt:\n\t\treturn (*valueBigInt)(big.NewInt(v.ToInteger()))\n\tcase valueFloat:\n\t\tif IsInfinity(v) || math.IsNaN(float64(v)) {\n\t\t\tpanic(rangeError(fmt.Sprintf(\"Cannot convert %s to a BigInt\", v)))\n\t\t}\n\t\tif f := big.NewFloat(float64(v)); f.IsInt() {\n\t\t\tn, _ := f.Int(nil)\n\t\t\treturn (*valueBigInt)(n)\n\t\t}\n\t\tpanic(rangeError(fmt.Sprintf(\"Cannot convert %s to a BigInt\", v)))\n\tcase *Object:\n\t\tprim := v.toPrimitiveNumber()\n\t\tswitch prim.(type) {\n\t\tcase valueInt, valueFloat:\n\t\t\treturn numberToBigInt(prim)\n\t\tdefault:\n\t\t\treturn toBigInt(prim)\n\t\t}\n\tdefault:\n\t\tpanic(newTypeError(\"Cannot convert %s to a BigInt\", v))\n\t}\n}\n\nfunc stringToBigInt(str string) (*big.Int, error) {\n\tvar bigint big.Int\n\tn, err := stringToInt(str)\n\tif err != nil {\n\t\tswitch {\n\t\tcase isRangeErr(err):\n\t\t\tbigint.SetString(str, 0)\n\t\tcase err == strconv.ErrSyntax:\n\t\tdefault:\n\t\t\treturn nil, strconv.ErrSyntax\n\t\t}\n\t} else {\n\t\tbigint.SetInt64(n)\n\t}\n\treturn &bigint, nil\n}\n\nfunc (r *Runtime) thisBigIntValue(value Value) Value {\n\tswitch t := value.(type) {\n\tcase *valueBigInt:\n\t\treturn t\n\tcase *Object:\n\t\tswitch t := t.self.(type) {\n\t\tcase *primitiveValueObject:\n\t\t\treturn r.thisBigIntValue(t.pValue)\n\t\tcase *objectGoReflect:\n\t\t\tif t.exportType() == typeBigInt && t.valueOf != nil {\n\t\t\t\treturn t.valueOf()\n\t\t\t}\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"requires that 'this' be a BigInt\"))\n}\n\nfunc (r *Runtime) bigintproto_valueOf(call FunctionCall) Value {\n\treturn r.thisBigIntValue(call.This)\n}\n\nfunc (r *Runtime) bigintproto_toString(call FunctionCall) Value {\n\tx := (*big.Int)(r.thisBigIntValue(call.This).(*valueBigInt))\n\tradix := call.Argument(0)\n\tvar radixMV int\n\n\tif radix == _undefined {\n\t\tradixMV = 10\n\t} else {\n\t\tradixMV = int(radix.ToInteger())\n\t\tif radixMV < 2 || radixMV > 36 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"radix must be an integer between 2 and 36\"))\n\t\t}\n\t}\n\n\treturn asciiString(x.Text(radixMV))\n}\n\nfunc (r *Runtime) bigint_asIntN(call FunctionCall) Value {\n\tif len(call.Arguments) < 2 {\n\t\tpanic(r.NewTypeError(\"Cannot convert undefined to a BigInt\"))\n\t}\n\tbits := r.toIndex(call.Argument(0).ToNumber())\n\tif bits < 0 {\n\t\tpanic(r.NewTypeError(\"Invalid value: not (convertible to) a safe integer\"))\n\t}\n\tbigint := toBigInt(call.Argument(1))\n\n\ttwoToBits := new(big.Int).Lsh(big.NewInt(1), uint(bits))\n\tmod := new(big.Int).Mod((*big.Int)(bigint), twoToBits)\n\tif bits > 0 && mod.Cmp(new(big.Int).Lsh(big.NewInt(1), uint(bits-1))) >= 0 {\n\t\treturn (*valueBigInt)(mod.Sub(mod, twoToBits))\n\t} else {\n\t\treturn (*valueBigInt)(mod)\n\t}\n}\n\nfunc (r *Runtime) bigint_asUintN(call FunctionCall) Value {\n\tif len(call.Arguments) < 2 {\n\t\tpanic(r.NewTypeError(\"Cannot convert undefined to a BigInt\"))\n\t}\n\tbits := r.toIndex(call.Argument(0).ToNumber())\n\tif bits < 0 {\n\t\tpanic(r.NewTypeError(\"Invalid value: not (convertible to) a safe integer\"))\n\t}\n\tbigint := (*big.Int)(toBigInt(call.Argument(1)))\n\tret := new(big.Int).Mod(bigint, new(big.Int).Lsh(big.NewInt(1), uint(bits)))\n\treturn (*valueBigInt)(ret)\n}\n\nvar bigintTemplate *objectTemplate\nvar bigintTemplateOnce sync.Once\n\nfunc getBigIntTemplate() *objectTemplate {\n\tbigintTemplateOnce.Do(func() {\n\t\tbigintTemplate = createBigIntTemplate()\n\t})\n\treturn bigintTemplate\n}\n\nfunc createBigIntTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.getFunctionPrototype()\n\t}\n\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(asciiString(\"BigInt\"), false, false, true) })\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(1), false, false, true) })\n\tt.putStr(\"prototype\", func(r *Runtime) Value { return valueProp(r.getBigIntPrototype(), false, false, false) })\n\n\tt.putStr(\"asIntN\", func(r *Runtime) Value { return r.methodProp(r.bigint_asIntN, \"asIntN\", 2) })\n\tt.putStr(\"asUintN\", func(r *Runtime) Value { return r.methodProp(r.bigint_asUintN, \"asUintN\", 2) })\n\n\treturn t\n}\n\nfunc (r *Runtime) builtin_BigInt(call FunctionCall) Value {\n\tif len(call.Arguments) > 0 {\n\t\tswitch v := call.Argument(0).(type) {\n\t\tcase *valueBigInt, valueInt, valueFloat, *Object:\n\t\t\treturn numberToBigInt(v)\n\t\tdefault:\n\t\t\treturn toBigInt(v)\n\t\t}\n\t}\n\treturn (*valueBigInt)(big.NewInt(0))\n}\n\nfunc (r *Runtime) builtin_newBigInt(args []Value, newTarget *Object) *Object {\n\tif newTarget != nil {\n\t\tpanic(r.NewTypeError(\"BigInt is not a constructor\"))\n\t}\n\tvar v Value\n\tif len(args) > 0 {\n\t\tv = numberToBigInt(args[0])\n\t} else {\n\t\tv = (*valueBigInt)(big.NewInt(0))\n\t}\n\treturn r.newPrimitiveObject(v, newTarget, classObject)\n}\n\nfunc (r *Runtime) getBigInt() *Object {\n\tret := r.global.BigInt\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.BigInt = ret\n\t\tr.newTemplatedFuncObject(getBigIntTemplate(), ret, r.builtin_BigInt,\n\t\t\tr.wrapNativeConstruct(r.builtin_newBigInt, ret, r.getBigIntPrototype()))\n\t}\n\treturn ret\n}\n\nfunc createBigIntProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(0), false, false, true) })\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(asciiString(\"BigInt\"), false, false, true) })\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getBigInt(), true, false, true) })\n\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.bigintproto_toString, \"toLocaleString\", 0) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.bigintproto_toString, \"toString\", 0) })\n\tt.putStr(\"valueOf\", func(r *Runtime) Value { return r.methodProp(r.bigintproto_valueOf, \"valueOf\", 0) })\n\tt.putSym(SymToStringTag, func(r *Runtime) Value { return valueProp(asciiString(\"BigInt\"), false, false, true) })\n\n\treturn t\n}\n\nvar bigintProtoTemplate *objectTemplate\nvar bigintProtoTemplateOnce sync.Once\n\nfunc getBigIntProtoTemplate() *objectTemplate {\n\tbigintProtoTemplateOnce.Do(func() {\n\t\tbigintProtoTemplate = createBigIntProtoTemplate()\n\t})\n\treturn bigintProtoTemplate\n}\n\nfunc (r *Runtime) getBigIntPrototype() *Object {\n\tret := r.global.BigIntPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.BigIntPrototype = ret\n\t\to := r.newTemplatedObject(getBigIntProtoTemplate(), ret)\n\t\to.class = classObject\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_bigint_test.go",
          "type": "blob",
          "size": 4.0166015625,
          "content": "package goja\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc TestBigInt(t *testing.T) {\n\tconst SCRIPT = `0xabcdef0123456789abcdef0123n`\n\tb := new(big.Int)\n\tb.SetString(\"0xabcdef0123456789abcdef0123\", 0)\n\ttestScript(SCRIPT, (*valueBigInt)(b), t)\n}\n\nfunc TestBigIntExportTo(t *testing.T) {\n\tvm := New()\n\n\tt.Run(\"bigint exportType\", func(t *testing.T) {\n\t\tv, err := vm.RunString(`BigInt(Number.MAX_SAFE_INTEGER + 10);`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif typ := v.ExportType(); typ != typeBigInt {\n\t\t\tt.Fatal(typ)\n\t\t}\n\t})\n\n\tt.Run(\"bigint\", func(t *testing.T) {\n\t\tvar b big.Int\n\t\terr := vm.ExportTo(vm.ToValue(big.NewInt(10)), &b)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b.Cmp(big.NewInt(10)) != 0 {\n\t\t\tt.Fatalf(\"bigint: %s\", b.String())\n\t\t}\n\t})\n}\n\nfunc TestBigIntFormat(t *testing.T) {\n\tconst SCRIPT = `\nassert.sameValue((1n).toString(undefined), \"1\", \"radius undefined\");\nassert.throws(RangeError, () => { (1n).toString(-1); }, \"radius -1\");\nassert.throws(RangeError, () => { (1n).toString(37); }, \"radius 37\");\nassert.sameValue((1n).toString(2), \"1\", \"radius 2\");\nassert.sameValue((10n).toString(3), \"101\", \"radius 3\");\n`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestBigIntOperator(t *testing.T) {\n\tconst SCRIPT = `\nassert.throws(TypeError, () => { 1 - 1n; }, \"mix type add\");\nassert.throws(TypeError, () => { 1n - 1; }, \"mix type add\");\nassert.throws(TypeError, () => { 1n + 1; }, \"mix type sub\");\nassert.throws(TypeError, () => { 1 + 1n; }, \"mix type sub\");\nassert.throws(TypeError, () => { 1 * 1n; }, \"mix type mul\");\nassert.throws(TypeError, () => { 1n * 1; }, \"mix type mul\");\nassert.throws(TypeError, () => { 1 / 1n; }, \"mix type div\");\nassert.throws(TypeError, () => { 1n / 1; }, \"mix type div\");\nassert.throws(TypeError, () => { 1 % 1n; }, \"mix type mod\");\nassert.throws(TypeError, () => { 1n % 1; }, \"mix type mod\");\nassert.throws(TypeError, () => { 1n ** 1; }, \"mix type exp\");\nassert.throws(TypeError, () => { 1 ** 1n; }, \"mix type exp\");\nassert.throws(TypeError, () => { 1 & 1n; }, \"mix type and\");\nassert.throws(TypeError, () => { 1n & 1; }, \"mix type and\");\nassert.throws(TypeError, () => { 1 | 1n; }, \"mix type or\");\nassert.throws(TypeError, () => { 1n | 1; }, \"mix type or\");\nassert.throws(TypeError, () => { 1 ^ 1n; }, \"mix type xor\");\nassert.throws(TypeError, () => { 1n ^ 1; }, \"mix type xor\");\nassert.throws(TypeError, () => { 1 << 1n; }, \"mix type lsh\");\nassert.throws(TypeError, () => { 1n << 1; }, \"mix type lsh\");\nassert.throws(TypeError, () => { 1 >> 1n; }, \"mix type rsh\");\nassert.throws(TypeError, () => { 1n >> 1; }, \"mix type rsh\");\nassert.throws(TypeError, () => { 1 >>> 1n; }, \"mix type ursh\");\nassert.throws(TypeError, () => { 1n >>> 1; }, \"mix type ursh\");\n\nassert.sameValue(1n + 1n, 2n, \"add\");\nassert.sameValue(1n - 1n, 0n, \"sub\");\nassert.sameValue(1n * 2n, 2n, \"mul\");\nassert.sameValue(1n / 2n, 0n, \"div\");\nassert.sameValue(1n % 2n, 1n, \"mod\");\nassert.sameValue(1n ** 2n, 1n, \"exp\");\nassert.sameValue(1n & 1n, 1n, \"and\");\nassert.sameValue(1n | 1n, 1n, \"or\");\nassert.sameValue(2n ^ 1n, 3n, \"xor\");\nassert.sameValue(1n << 1n, 2n, \"lsh\");\nassert.sameValue(4n << -1n, 2n, \"neg lsh\");\nassert.sameValue(4n >> 1n, 2n, \"rsh\");\nassert.sameValue(2n >> -2n, 8n, \"neg rsh\");\n\nlet a = 1n;\nassert.sameValue(++a, 2n, \"inc\");\nassert.sameValue(--a, 1n, \"dec\");\n\nassert.sameValue(Object(1n) - 1n, 0n, \"primitive sub\");\nassert.sameValue(Object(Object(1n)) - 1n, 0n, \"primitive sub\");\nassert.sameValue({ [Symbol.toPrimitive]: () => 1n } - 1n, 0n, \"primitive sub\");\nassert.sameValue({ valueOf: () => 1n } - 1n, 0n, \"valueOf sub\");\n\nassert.sameValue(1n > 0, true, \"gt\");\nassert.sameValue(0 > 1n, false, \"gt\");\nassert.sameValue(Object(1n) > 0, true, \"gt\");\nassert.sameValue(0 > Object(1n), false, \"gt\");\n\nassert.sameValue(1n < 0, false, \"lt\");\nassert.sameValue(0 < 1n, true, \"lt\");\nassert.sameValue(Object(1n) < 0, false, \"lt\");\nassert.sameValue(0 < Object(1n), true, \"lt\");\n\nassert.sameValue(1n >= 0, true, \"ge\");\nassert.sameValue(0 >= 1n, false, \"ge\");\nassert.sameValue(1n <= 0, false, \"le\");\nassert.sameValue(0 <= 1n, true, \"le\");\n`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "builtin_boolean.go",
          "type": "blob",
          "size": 1.9208984375,
          "content": "package goja\n\nfunc (r *Runtime) booleanproto_toString(call FunctionCall) Value {\n\tvar b bool\n\tswitch o := call.This.(type) {\n\tcase valueBool:\n\t\tb = bool(o)\n\t\tgoto success\n\tcase *Object:\n\t\tif p, ok := o.self.(*primitiveValueObject); ok {\n\t\t\tif b1, ok := p.pValue.(valueBool); ok {\n\t\t\t\tb = bool(b1)\n\t\t\t\tgoto success\n\t\t\t}\n\t\t}\n\t\tif o, ok := o.self.(*objectGoReflect); ok {\n\t\t\tif o.class == classBoolean && o.toString != nil {\n\t\t\t\treturn o.toString()\n\t\t\t}\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Method Boolean.prototype.toString is called on incompatible receiver\")\n\nsuccess:\n\tif b {\n\t\treturn stringTrue\n\t}\n\treturn stringFalse\n}\n\nfunc (r *Runtime) booleanproto_valueOf(call FunctionCall) Value {\n\tswitch o := call.This.(type) {\n\tcase valueBool:\n\t\treturn o\n\tcase *Object:\n\t\tif p, ok := o.self.(*primitiveValueObject); ok {\n\t\t\tif b, ok := p.pValue.(valueBool); ok {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif o, ok := o.self.(*objectGoReflect); ok {\n\t\t\tif o.class == classBoolean && o.valueOf != nil {\n\t\t\t\treturn o.valueOf()\n\t\t\t}\n\t\t}\n\t}\n\n\tr.typeErrorResult(true, \"Method Boolean.prototype.valueOf is called on incompatible receiver\")\n\treturn nil\n}\n\nfunc (r *Runtime) getBooleanPrototype() *Object {\n\tret := r.global.BooleanPrototype\n\tif ret == nil {\n\t\tret = r.newPrimitiveObject(valueFalse, r.global.ObjectPrototype, classBoolean)\n\t\tr.global.BooleanPrototype = ret\n\t\to := ret.self\n\t\to._putProp(\"toString\", r.newNativeFunc(r.booleanproto_toString, \"toString\", 0), true, false, true)\n\t\to._putProp(\"valueOf\", r.newNativeFunc(r.booleanproto_valueOf, \"valueOf\", 0), true, false, true)\n\t\to._putProp(\"constructor\", r.getBoolean(), true, false, true)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getBoolean() *Object {\n\tret := r.global.Boolean\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Boolean = ret\n\t\tproto := r.getBooleanPrototype()\n\t\tr.newNativeFuncAndConstruct(ret, r.builtin_Boolean,\n\t\t\tr.wrapNativeConstruct(r.builtin_newBoolean, ret, proto), proto, \"Boolean\", intToValue(1))\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_date.go",
          "type": "blob",
          "size": 30.49609375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc (r *Runtime) makeDate(args []Value, utc bool) (t time.Time, valid bool) {\n\tswitch {\n\tcase len(args) >= 2:\n\t\tt = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.Local)\n\t\tt, valid = _dateSetYear(t, FunctionCall{Arguments: args}, 0, utc)\n\tcase len(args) == 0:\n\t\tt = r.now()\n\t\tvalid = true\n\tdefault: // one argument\n\t\tif o, ok := args[0].(*Object); ok {\n\t\t\tif d, ok := o.self.(*dateObject); ok {\n\t\t\t\tt = d.time()\n\t\t\t\tvalid = true\n\t\t\t}\n\t\t}\n\t\tif !valid {\n\t\t\tpv := toPrimitive(args[0])\n\t\t\tif val, ok := pv.(String); ok {\n\t\t\t\treturn dateParse(val.String())\n\t\t\t}\n\t\t\tpv = pv.ToNumber()\n\t\t\tvar n int64\n\t\t\tif i, ok := pv.(valueInt); ok {\n\t\t\t\tn = int64(i)\n\t\t\t} else if f, ok := pv.(valueFloat); ok {\n\t\t\t\tf := float64(f)\n\t\t\t\tif math.IsNaN(f) || math.IsInf(f, 0) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif math.Abs(f) > maxTime {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tn = int64(f)\n\t\t\t} else {\n\t\t\t\tn = pv.ToInteger()\n\t\t\t}\n\t\t\tt = timeFromMsec(n)\n\t\t\tvalid = true\n\t\t}\n\t}\n\tif valid {\n\t\tmsec := t.Unix()*1000 + int64(t.Nanosecond()/1e6)\n\t\tif msec < 0 {\n\t\t\tmsec = -msec\n\t\t}\n\t\tif msec > maxTime {\n\t\t\tvalid = false\n\t\t}\n\t}\n\treturn\n}\n\nfunc (r *Runtime) newDateTime(args []Value, proto *Object) *Object {\n\tt, isSet := r.makeDate(args, false)\n\treturn r.newDateObject(t, isSet, proto)\n}\n\nfunc (r *Runtime) builtin_newDate(args []Value, proto *Object) *Object {\n\treturn r.newDateTime(args, proto)\n}\n\nfunc (r *Runtime) builtin_date(FunctionCall) Value {\n\treturn asciiString(dateFormat(r.now()))\n}\n\nfunc (r *Runtime) date_parse(call FunctionCall) Value {\n\tt, set := dateParse(call.Argument(0).toString().String())\n\tif set {\n\t\treturn intToValue(timeToMsec(t))\n\t}\n\treturn _NaN\n}\n\nfunc (r *Runtime) date_UTC(call FunctionCall) Value {\n\tvar args []Value\n\tif len(call.Arguments) < 2 {\n\t\targs = []Value{call.Argument(0), _positiveZero}\n\t} else {\n\t\targs = call.Arguments\n\t}\n\tt, valid := r.makeDate(args, true)\n\tif !valid {\n\t\treturn _NaN\n\t}\n\treturn intToValue(timeToMsec(t))\n}\n\nfunc (r *Runtime) date_now(FunctionCall) Value {\n\treturn intToValue(timeToMsec(r.now()))\n}\n\nfunc (r *Runtime) dateproto_toString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(dateTimeLayout))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toUTCString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.timeUTC().Format(utcDateTimeLayout))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toUTCString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toISOString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\tutc := d.timeUTC()\n\t\t\tyear := utc.Year()\n\t\t\tif year >= -9999 && year <= 9999 {\n\t\t\t\treturn asciiString(utc.Format(isoDateTimeLayout))\n\t\t\t}\n\t\t\t// extended year\n\t\t\treturn asciiString(fmt.Sprintf(\"%+06d-\", year) + utc.Format(isoDateTimeLayout[5:]))\n\t\t} else {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid time value\"))\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toISOString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toJSON(call FunctionCall) Value {\n\tobj := call.This.ToObject(r)\n\ttv := obj.toPrimitiveNumber()\n\tif f, ok := tv.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif math.IsNaN(f) || math.IsInf(f, 0) {\n\t\t\treturn _null\n\t\t}\n\t}\n\n\tif toISO, ok := obj.self.getStr(\"toISOString\", nil).(*Object); ok {\n\t\tif toISO, ok := toISO.self.assertCallable(); ok {\n\t\t\treturn toISO(FunctionCall{\n\t\t\t\tThis: obj,\n\t\t\t})\n\t\t}\n\t}\n\n\tpanic(r.NewTypeError(\"toISOString is not a function\"))\n}\n\nfunc (r *Runtime) dateproto_toPrimitive(call FunctionCall) Value {\n\to := r.toObject(call.This)\n\targ := call.Argument(0)\n\n\tif asciiString(\"string\").StrictEquals(arg) || asciiString(\"default\").StrictEquals(arg) {\n\t\treturn o.ordinaryToPrimitiveString()\n\t}\n\tif asciiString(\"number\").StrictEquals(arg) {\n\t\treturn o.ordinaryToPrimitiveNumber()\n\t}\n\tpanic(r.NewTypeError(\"Invalid hint: %s\", arg))\n}\n\nfunc (r *Runtime) dateproto_toDateString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(dateLayout))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toDateString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toTimeString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(timeLayout))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toTimeString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toLocaleString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(datetimeLayout_en_GB))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toLocaleString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toLocaleDateString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(dateLayout_en_GB))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toLocaleDateString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_toLocaleTimeString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn asciiString(d.time().Format(timeLayout_en_GB))\n\t\t} else {\n\t\t\treturn stringInvalidDate\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.toLocaleTimeString is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_valueOf(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(d.msec)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.valueOf is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getTime(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(d.msec)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getTime is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getFullYear(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Year()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getFullYear is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCFullYear(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Year()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCFullYear is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getMonth(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Month()) - 1)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getMonth is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCMonth(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Month()) - 1)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCMonth is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getHours(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Hour()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getHours is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCHours(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Hour()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCHours is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getDate(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Day()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getDate is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCDate(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Day()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCDate is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getDay(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Weekday()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getDay is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCDay(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Weekday()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCDay is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getMinutes(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Minute()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getMinutes is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCMinutes(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Minute()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCMinutes is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getSeconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Second()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getSeconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCSeconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Second()))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCSeconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.time().Nanosecond() / 1e6))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getMilliseconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getUTCMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\treturn intToValue(int64(d.timeUTC().Nanosecond() / 1e6))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getUTCMilliseconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_getTimezoneOffset(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet() {\n\t\t\t_, offset := d.time().Zone()\n\t\t\treturn floatToValue(float64(-offset) / 60)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.getTimezoneOffset is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setTime(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tn := call.Argument(0).ToNumber()\n\t\tif IsNaN(n) {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\treturn d.setTimeMs(n.ToInteger())\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setTime is called on incompatible receiver\"))\n}\n\n// _norm returns nhi, nlo such that\n//\n//\thi * base + lo == nhi * base + nlo\n//\t0 <= nlo < base\nfunc _norm(hi, lo, base int64) (nhi, nlo int64, ok bool) {\n\tif lo < 0 {\n\t\tif hi == math.MinInt64 && lo <= -base {\n\t\t\t// underflow\n\t\t\tok = false\n\t\t\treturn\n\t\t}\n\t\tn := (-lo-1)/base + 1\n\t\thi -= n\n\t\tlo += n * base\n\t}\n\tif lo >= base {\n\t\tif hi == math.MaxInt64 {\n\t\t\t// overflow\n\t\t\tok = false\n\t\t\treturn\n\t\t}\n\t\tn := lo / base\n\t\thi += n\n\t\tlo -= n * base\n\t}\n\treturn hi, lo, true\n}\n\nfunc mkTime(year, m, day, hour, min, sec, nsec int64, loc *time.Location) (t time.Time, ok bool) {\n\tyear, m, ok = _norm(year, m, 12)\n\tif !ok {\n\t\treturn\n\t}\n\n\t// Normalise nsec, sec, min, hour, overflowing into day.\n\tsec, nsec, ok = _norm(sec, nsec, 1e9)\n\tif !ok {\n\t\treturn\n\t}\n\tmin, sec, ok = _norm(min, sec, 60)\n\tif !ok {\n\t\treturn\n\t}\n\thour, min, ok = _norm(hour, min, 60)\n\tif !ok {\n\t\treturn\n\t}\n\tday, hour, ok = _norm(day, hour, 24)\n\tif !ok {\n\t\treturn\n\t}\n\tif year > math.MaxInt32 || year < math.MinInt32 ||\n\t\tday > math.MaxInt32 || day < math.MinInt32 ||\n\t\tm >= math.MaxInt32 || m < math.MinInt32-1 {\n\t\treturn time.Time{}, false\n\t}\n\tmonth := time.Month(m) + 1\n\treturn time.Date(int(year), month, int(day), int(hour), int(min), int(sec), int(nsec), loc), true\n}\n\nfunc _intArg(call FunctionCall, argNum int) (int64, bool) {\n\tn := call.Argument(argNum).ToNumber()\n\tif IsNaN(n) {\n\t\treturn 0, false\n\t}\n\treturn n.ToInteger(), true\n}\n\nfunc _dateSetYear(t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar year int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tyear, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t\tif year >= 0 && year <= 99 {\n\t\t\tyear += 1900\n\t\t}\n\t} else {\n\t\tyear = int64(t.Year())\n\t}\n\n\treturn _dateSetMonth(year, t, call, argNum+1, utc)\n}\n\nfunc _dateSetFullYear(t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar year int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tyear, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tyear = int64(t.Year())\n\t}\n\treturn _dateSetMonth(year, t, call, argNum+1, utc)\n}\n\nfunc _dateSetMonth(year int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar mon int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tmon, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tmon = int64(t.Month()) - 1\n\t}\n\n\treturn _dateSetDay(year, mon, t, call, argNum+1, utc)\n}\n\nfunc _dateSetDay(year, mon int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar day int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tday, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tday = int64(t.Day())\n\t}\n\n\treturn _dateSetHours(year, mon, day, t, call, argNum+1, utc)\n}\n\nfunc _dateSetHours(year, mon, day int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar hours int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\thours, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\thours = int64(t.Hour())\n\t}\n\treturn _dateSetMinutes(year, mon, day, hours, t, call, argNum+1, utc)\n}\n\nfunc _dateSetMinutes(year, mon, day, hours int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar min int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tmin, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tmin = int64(t.Minute())\n\t}\n\treturn _dateSetSeconds(year, mon, day, hours, min, t, call, argNum+1, utc)\n}\n\nfunc _dateSetSeconds(year, mon, day, hours, min int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar sec int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tsec, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tsec = int64(t.Second())\n\t}\n\treturn _dateSetMilliseconds(year, mon, day, hours, min, sec, t, call, argNum+1, utc)\n}\n\nfunc _dateSetMilliseconds(year, mon, day, hours, min, sec int64, t time.Time, call FunctionCall, argNum int, utc bool) (time.Time, bool) {\n\tvar msec int64\n\tif argNum == 0 || argNum > 0 && argNum < len(call.Arguments) {\n\t\tvar ok bool\n\t\tmsec, ok = _intArg(call, argNum)\n\t\tif !ok {\n\t\t\treturn time.Time{}, false\n\t\t}\n\t} else {\n\t\tmsec = int64(t.Nanosecond() / 1e6)\n\t}\n\tvar ok bool\n\tsec, msec, ok = _norm(sec, msec, 1e3)\n\tif !ok {\n\t\treturn time.Time{}, false\n\t}\n\n\tvar loc *time.Location\n\tif utc {\n\t\tloc = time.UTC\n\t} else {\n\t\tloc = time.Local\n\t}\n\tr, ok := mkTime(year, mon, day, hours, min, sec, msec*1e6, loc)\n\tif !ok {\n\t\treturn time.Time{}, false\n\t}\n\tif utc {\n\t\treturn r.In(time.Local), true\n\t}\n\treturn r, true\n}\n\nfunc (r *Runtime) dateproto_setMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tn := call.Argument(0).ToNumber()\n\t\tif IsNaN(n) {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tmsec := n.ToInteger()\n\t\tsec := d.msec / 1e3\n\t\tvar ok bool\n\t\tsec, msec, ok = _norm(sec, msec, 1e3)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(sec*1e3 + msec)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setMilliseconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tn := call.Argument(0).ToNumber()\n\t\tif IsNaN(n) {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tmsec := n.ToInteger()\n\t\tsec := d.msec / 1e3\n\t\tvar ok bool\n\t\tsec, msec, ok = _norm(sec, msec, 1e3)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(sec*1e3 + msec)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCMilliseconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setSeconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.time(), call, -5, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setSeconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCSeconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.timeUTC(), call, -5, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCSeconds is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setMinutes(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.time(), call, -4, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setMinutes is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCMinutes(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.timeUTC(), call, -4, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCMinutes is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setHours(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.time(), call, -3, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setHours is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCHours(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.timeUTC(), call, -3, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCHours is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setDate(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.time(), limitCallArgs(call, 1), -2, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setDate is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCDate(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.timeUTC(), limitCallArgs(call, 1), -2, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCDate is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setMonth(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.time(), limitCallArgs(call, 2), -1, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setMonth is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCMonth(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tt, ok := _dateSetFullYear(d.timeUTC(), limitCallArgs(call, 2), -1, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\tif d.isSet() {\n\t\t\treturn d.setTimeMs(timeToMsec(t))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCMonth is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setFullYear(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tvar t time.Time\n\t\tif d.isSet() {\n\t\t\tt = d.time()\n\t\t} else {\n\t\t\tt = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.Local)\n\t\t}\n\t\tt, ok := _dateSetFullYear(t, limitCallArgs(call, 3), 0, false)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\treturn d.setTimeMs(timeToMsec(t))\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setFullYear is called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) dateproto_setUTCFullYear(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tvar t time.Time\n\t\tif d.isSet() {\n\t\t\tt = d.timeUTC()\n\t\t} else {\n\t\t\tt = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.UTC)\n\t\t}\n\t\tt, ok := _dateSetFullYear(t, limitCallArgs(call, 3), 0, true)\n\t\tif !ok {\n\t\t\td.unset()\n\t\t\treturn _NaN\n\t\t}\n\t\treturn d.setTimeMs(timeToMsec(t))\n\t}\n\tpanic(r.NewTypeError(\"Method Date.prototype.setUTCFullYear is called on incompatible receiver\"))\n}\n\nvar dateTemplate *objectTemplate\nvar dateTemplateOnce sync.Once\n\nfunc getDateTemplate() *objectTemplate {\n\tdateTemplateOnce.Do(func() {\n\t\tdateTemplate = createDateTemplate()\n\t})\n\treturn dateTemplate\n}\n\nfunc createDateTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.getFunctionPrototype()\n\t}\n\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(asciiString(\"Date\"), false, false, true) })\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(7), false, false, true) })\n\n\tt.putStr(\"prototype\", func(r *Runtime) Value { return valueProp(r.getDatePrototype(), false, false, false) })\n\n\tt.putStr(\"parse\", func(r *Runtime) Value { return r.methodProp(r.date_parse, \"parse\", 1) })\n\tt.putStr(\"UTC\", func(r *Runtime) Value { return r.methodProp(r.date_UTC, \"UTC\", 7) })\n\tt.putStr(\"now\", func(r *Runtime) Value { return r.methodProp(r.date_now, \"now\", 0) })\n\n\treturn t\n}\n\nfunc (r *Runtime) getDate() *Object {\n\tret := r.global.Date\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Date = ret\n\t\tr.newTemplatedFuncObject(getDateTemplate(), ret, r.builtin_date,\n\t\t\tr.wrapNativeConstruct(r.builtin_newDate, ret, r.getDatePrototype()))\n\t}\n\treturn ret\n}\n\nfunc createDateProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getDate(), true, false, true) })\n\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toString, \"toString\", 0) })\n\tt.putStr(\"toDateString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toDateString, \"toDateString\", 0) })\n\tt.putStr(\"toTimeString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toTimeString, \"toTimeString\", 0) })\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toLocaleString, \"toLocaleString\", 0) })\n\tt.putStr(\"toLocaleDateString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toLocaleDateString, \"toLocaleDateString\", 0) })\n\tt.putStr(\"toLocaleTimeString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toLocaleTimeString, \"toLocaleTimeString\", 0) })\n\tt.putStr(\"valueOf\", func(r *Runtime) Value { return r.methodProp(r.dateproto_valueOf, \"valueOf\", 0) })\n\tt.putStr(\"getTime\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getTime, \"getTime\", 0) })\n\tt.putStr(\"getFullYear\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getFullYear, \"getFullYear\", 0) })\n\tt.putStr(\"getUTCFullYear\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCFullYear, \"getUTCFullYear\", 0) })\n\tt.putStr(\"getMonth\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getMonth, \"getMonth\", 0) })\n\tt.putStr(\"getUTCMonth\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCMonth, \"getUTCMonth\", 0) })\n\tt.putStr(\"getDate\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getDate, \"getDate\", 0) })\n\tt.putStr(\"getUTCDate\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCDate, \"getUTCDate\", 0) })\n\tt.putStr(\"getDay\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getDay, \"getDay\", 0) })\n\tt.putStr(\"getUTCDay\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCDay, \"getUTCDay\", 0) })\n\tt.putStr(\"getHours\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getHours, \"getHours\", 0) })\n\tt.putStr(\"getUTCHours\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCHours, \"getUTCHours\", 0) })\n\tt.putStr(\"getMinutes\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getMinutes, \"getMinutes\", 0) })\n\tt.putStr(\"getUTCMinutes\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCMinutes, \"getUTCMinutes\", 0) })\n\tt.putStr(\"getSeconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getSeconds, \"getSeconds\", 0) })\n\tt.putStr(\"getUTCSeconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCSeconds, \"getUTCSeconds\", 0) })\n\tt.putStr(\"getMilliseconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getMilliseconds, \"getMilliseconds\", 0) })\n\tt.putStr(\"getUTCMilliseconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getUTCMilliseconds, \"getUTCMilliseconds\", 0) })\n\tt.putStr(\"getTimezoneOffset\", func(r *Runtime) Value { return r.methodProp(r.dateproto_getTimezoneOffset, \"getTimezoneOffset\", 0) })\n\tt.putStr(\"setTime\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setTime, \"setTime\", 1) })\n\tt.putStr(\"setMilliseconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setMilliseconds, \"setMilliseconds\", 1) })\n\tt.putStr(\"setUTCMilliseconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCMilliseconds, \"setUTCMilliseconds\", 1) })\n\tt.putStr(\"setSeconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setSeconds, \"setSeconds\", 2) })\n\tt.putStr(\"setUTCSeconds\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCSeconds, \"setUTCSeconds\", 2) })\n\tt.putStr(\"setMinutes\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setMinutes, \"setMinutes\", 3) })\n\tt.putStr(\"setUTCMinutes\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCMinutes, \"setUTCMinutes\", 3) })\n\tt.putStr(\"setHours\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setHours, \"setHours\", 4) })\n\tt.putStr(\"setUTCHours\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCHours, \"setUTCHours\", 4) })\n\tt.putStr(\"setDate\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setDate, \"setDate\", 1) })\n\tt.putStr(\"setUTCDate\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCDate, \"setUTCDate\", 1) })\n\tt.putStr(\"setMonth\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setMonth, \"setMonth\", 2) })\n\tt.putStr(\"setUTCMonth\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCMonth, \"setUTCMonth\", 2) })\n\tt.putStr(\"setFullYear\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setFullYear, \"setFullYear\", 3) })\n\tt.putStr(\"setUTCFullYear\", func(r *Runtime) Value { return r.methodProp(r.dateproto_setUTCFullYear, \"setUTCFullYear\", 3) })\n\tt.putStr(\"toUTCString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toUTCString, \"toUTCString\", 0) })\n\tt.putStr(\"toISOString\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toISOString, \"toISOString\", 0) })\n\tt.putStr(\"toJSON\", func(r *Runtime) Value { return r.methodProp(r.dateproto_toJSON, \"toJSON\", 1) })\n\n\tt.putSym(SymToPrimitive, func(r *Runtime) Value {\n\t\treturn valueProp(r.newNativeFunc(r.dateproto_toPrimitive, \"[Symbol.toPrimitive]\", 1), false, false, true)\n\t})\n\n\treturn t\n}\n\nvar dateProtoTemplate *objectTemplate\nvar dateProtoTemplateOnce sync.Once\n\nfunc getDateProtoTemplate() *objectTemplate {\n\tdateProtoTemplateOnce.Do(func() {\n\t\tdateProtoTemplate = createDateProtoTemplate()\n\t})\n\treturn dateProtoTemplate\n}\n\nfunc (r *Runtime) getDatePrototype() *Object {\n\tret := r.global.DatePrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.DatePrototype = ret\n\t\tr.newTemplatedObject(getDateProtoTemplate(), ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_error.go",
          "type": "blob",
          "size": 8.197265625,
          "content": "package goja\n\nimport \"github.com/dop251/goja/unistring\"\n\nconst propNameStack = \"stack\"\n\ntype errorObject struct {\n\tbaseObject\n\tstack          []StackFrame\n\tstackPropAdded bool\n}\n\nfunc (e *errorObject) formatStack() String {\n\tvar b StringBuilder\n\tval := writeErrorString(&b, e.val)\n\tif val != nil {\n\t\tb.WriteString(val)\n\t}\n\tb.WriteRune('\\n')\n\n\tfor _, frame := range e.stack {\n\t\tb.writeASCII(\"\\tat \")\n\t\tframe.WriteToValueBuilder(&b)\n\t\tb.WriteRune('\\n')\n\t}\n\treturn b.String()\n}\n\nfunc (e *errorObject) addStackProp() Value {\n\tif !e.stackPropAdded {\n\t\tres := e._putProp(propNameStack, e.formatStack(), true, false, true)\n\t\tif len(e.propNames) > 1 {\n\t\t\t// reorder property names to ensure 'stack' is the first one\n\t\t\tcopy(e.propNames[1:], e.propNames)\n\t\t\te.propNames[0] = propNameStack\n\t\t}\n\t\te.stackPropAdded = true\n\t\treturn res\n\t}\n\treturn nil\n}\n\nfunc (e *errorObject) getStr(p unistring.String, receiver Value) Value {\n\treturn e.getStrWithOwnProp(e.getOwnPropStr(p), p, receiver)\n}\n\nfunc (e *errorObject) getOwnPropStr(name unistring.String) Value {\n\tres := e.baseObject.getOwnPropStr(name)\n\tif res == nil && name == propNameStack {\n\t\treturn e.addStackProp()\n\t}\n\n\treturn res\n}\n\nfunc (e *errorObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif name == propNameStack {\n\t\te.addStackProp()\n\t}\n\treturn e.baseObject.setOwnStr(name, val, throw)\n}\n\nfunc (e *errorObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn e._setForeignStr(name, e.getOwnPropStr(name), val, receiver, throw)\n}\n\nfunc (e *errorObject) deleteStr(name unistring.String, throw bool) bool {\n\tif name == propNameStack {\n\t\te.addStackProp()\n\t}\n\treturn e.baseObject.deleteStr(name, throw)\n}\n\nfunc (e *errorObject) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tif name == propNameStack {\n\t\te.addStackProp()\n\t}\n\treturn e.baseObject.defineOwnPropertyStr(name, desc, throw)\n}\n\nfunc (e *errorObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif e.baseObject.hasOwnPropertyStr(name) {\n\t\treturn true\n\t}\n\n\treturn name == propNameStack && !e.stackPropAdded\n}\n\nfunc (e *errorObject) stringKeys(all bool, accum []Value) []Value {\n\tif all && !e.stackPropAdded {\n\t\taccum = append(accum, asciiString(propNameStack))\n\t}\n\treturn e.baseObject.stringKeys(all, accum)\n}\n\nfunc (e *errorObject) iterateStringKeys() iterNextFunc {\n\te.addStackProp()\n\treturn e.baseObject.iterateStringKeys()\n}\n\nfunc (e *errorObject) init() {\n\te.baseObject.init()\n\tvm := e.val.runtime.vm\n\te.stack = vm.captureStack(make([]StackFrame, 0, len(vm.callStack)+1), 0)\n}\n\nfunc (r *Runtime) newErrorObject(proto *Object, class string) *errorObject {\n\tobj := &Object{runtime: r}\n\to := &errorObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      class,\n\t\t\tval:        obj,\n\t\t\textensible: true,\n\t\t\tprototype:  proto,\n\t\t},\n\t}\n\tobj.self = o\n\to.init()\n\treturn o\n}\n\nfunc (r *Runtime) builtin_Error(args []Value, proto *Object) *Object {\n\tobj := r.newErrorObject(proto, classError)\n\tif len(args) > 0 && args[0] != _undefined {\n\t\tobj._putProp(\"message\", args[0].ToString(), true, false, true)\n\t}\n\tif len(args) > 1 && args[1] != _undefined {\n\t\tif options, ok := args[1].(*Object); ok {\n\t\t\tif options.hasProperty(asciiString(\"cause\")) {\n\t\t\t\tobj.defineOwnPropertyStr(\"cause\", PropertyDescriptor{\n\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\tEnumerable:   FLAG_FALSE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t\tValue:        options.Get(\"cause\"),\n\t\t\t\t}, true)\n\t\t\t}\n\t\t}\n\t}\n\treturn obj.val\n}\n\nfunc (r *Runtime) builtin_AggregateError(args []Value, proto *Object) *Object {\n\tobj := r.newErrorObject(proto, classError)\n\tif len(args) > 1 && args[1] != nil && args[1] != _undefined {\n\t\tobj._putProp(\"message\", args[1].toString(), true, false, true)\n\t}\n\tvar errors []Value\n\tif len(args) > 0 {\n\t\terrors = r.iterableToList(args[0], nil)\n\t}\n\tobj._putProp(\"errors\", r.newArrayValues(errors), true, false, true)\n\n\tif len(args) > 2 && args[2] != _undefined {\n\t\tif options, ok := args[2].(*Object); ok {\n\t\t\tif options.hasProperty(asciiString(\"cause\")) {\n\t\t\t\tobj.defineOwnPropertyStr(\"cause\", PropertyDescriptor{\n\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\tEnumerable:   FLAG_FALSE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t\tValue:        options.Get(\"cause\"),\n\t\t\t\t}, true)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj.val\n}\n\nfunc writeErrorString(sb *StringBuilder, obj *Object) String {\n\tvar nameStr, msgStr String\n\tname := obj.self.getStr(\"name\", nil)\n\tif name == nil || name == _undefined {\n\t\tnameStr = asciiString(\"Error\")\n\t} else {\n\t\tnameStr = name.toString()\n\t}\n\tmsg := obj.self.getStr(\"message\", nil)\n\tif msg == nil || msg == _undefined {\n\t\tmsgStr = stringEmpty\n\t} else {\n\t\tmsgStr = msg.toString()\n\t}\n\tif nameStr.Length() == 0 {\n\t\treturn msgStr\n\t}\n\tif msgStr.Length() == 0 {\n\t\treturn nameStr\n\t}\n\tsb.WriteString(nameStr)\n\tsb.WriteString(asciiString(\": \"))\n\tsb.WriteString(msgStr)\n\treturn nil\n}\n\nfunc (r *Runtime) error_toString(call FunctionCall) Value {\n\tvar sb StringBuilder\n\tval := writeErrorString(&sb, r.toObject(call.This))\n\tif val != nil {\n\t\treturn val\n\t}\n\treturn sb.String()\n}\n\nfunc (r *Runtime) createErrorPrototype(name String, ctor *Object) *Object {\n\to := r.newBaseObject(r.getErrorPrototype(), classObject)\n\to._putProp(\"message\", stringEmpty, true, false, true)\n\to._putProp(\"name\", name, true, false, true)\n\to._putProp(\"constructor\", ctor, true, false, true)\n\treturn o.val\n}\n\nfunc (r *Runtime) getErrorPrototype() *Object {\n\tret := r.global.ErrorPrototype\n\tif ret == nil {\n\t\tret = r.NewObject()\n\t\tr.global.ErrorPrototype = ret\n\t\to := ret.self\n\t\to._putProp(\"message\", stringEmpty, true, false, true)\n\t\to._putProp(\"name\", stringError, true, false, true)\n\t\to._putProp(\"toString\", r.newNativeFunc(r.error_toString, \"toString\", 0), true, false, true)\n\t\to._putProp(\"constructor\", r.getError(), true, false, true)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getError() *Object {\n\tret := r.global.Error\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Error = ret\n\t\tr.newNativeFuncConstruct(ret, r.builtin_Error, \"Error\", r.getErrorPrototype(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getAggregateError() *Object {\n\tret := r.global.AggregateError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.AggregateError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_AggregateError, \"AggregateError\", r.createErrorPrototype(stringAggregateError, ret), r.getError(), 2)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getTypeError() *Object {\n\tret := r.global.TypeError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.TypeError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"TypeError\", r.createErrorPrototype(stringTypeError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getReferenceError() *Object {\n\tret := r.global.ReferenceError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.ReferenceError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"ReferenceError\", r.createErrorPrototype(stringReferenceError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getSyntaxError() *Object {\n\tret := r.global.SyntaxError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.SyntaxError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"SyntaxError\", r.createErrorPrototype(stringSyntaxError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getRangeError() *Object {\n\tret := r.global.RangeError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.RangeError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"RangeError\", r.createErrorPrototype(stringRangeError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getEvalError() *Object {\n\tret := r.global.EvalError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.EvalError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"EvalError\", r.createErrorPrototype(stringEvalError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getURIError() *Object {\n\tret := r.global.URIError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.URIError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"URIError\", r.createErrorPrototype(stringURIError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getGoError() *Object {\n\tret := r.global.GoError\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.GoError = ret\n\t\tr.newNativeFuncConstructProto(ret, r.builtin_Error, \"GoError\", r.createErrorPrototype(stringGoError, ret), r.getError(), 1)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_function.go",
          "type": "blob",
          "size": 11.140625,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"sync\"\n)\n\nfunc (r *Runtime) functionCtor(args []Value, proto *Object, async, generator bool) *Object {\n\tvar sb StringBuilder\n\tif async {\n\t\tif generator {\n\t\t\tsb.WriteString(asciiString(\"(async function* anonymous(\"))\n\t\t} else {\n\t\t\tsb.WriteString(asciiString(\"(async function anonymous(\"))\n\t\t}\n\t} else {\n\t\tif generator {\n\t\t\tsb.WriteString(asciiString(\"(function* anonymous(\"))\n\t\t} else {\n\t\t\tsb.WriteString(asciiString(\"(function anonymous(\"))\n\t\t}\n\t}\n\tif len(args) > 1 {\n\t\tar := args[:len(args)-1]\n\t\tfor i, arg := range ar {\n\t\t\tsb.WriteString(arg.toString())\n\t\t\tif i < len(ar)-1 {\n\t\t\t\tsb.WriteRune(',')\n\t\t\t}\n\t\t}\n\t}\n\tsb.WriteString(asciiString(\"\\n) {\\n\"))\n\tif len(args) > 0 {\n\t\tsb.WriteString(args[len(args)-1].toString())\n\t}\n\tsb.WriteString(asciiString(\"\\n})\"))\n\n\tret := r.toObject(r.eval(sb.String(), false, false))\n\tret.self.setProto(proto, true)\n\treturn ret\n}\n\nfunc (r *Runtime) builtin_Function(args []Value, proto *Object) *Object {\n\treturn r.functionCtor(args, proto, false, false)\n}\n\nfunc (r *Runtime) builtin_asyncFunction(args []Value, proto *Object) *Object {\n\treturn r.functionCtor(args, proto, true, false)\n}\n\nfunc (r *Runtime) builtin_generatorFunction(args []Value, proto *Object) *Object {\n\treturn r.functionCtor(args, proto, false, true)\n}\n\nfunc (r *Runtime) functionproto_toString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tswitch f := obj.self.(type) {\n\tcase funcObjectImpl:\n\t\treturn f.source()\n\tcase *proxyObject:\n\t\tif _, ok := f.target.self.(funcObjectImpl); ok {\n\t\t\treturn asciiString(\"function () { [native code] }\")\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Function.prototype.toString requires that 'this' be a Function\"))\n}\n\nfunc (r *Runtime) functionproto_hasInstance(call FunctionCall) Value {\n\tif o, ok := call.This.(*Object); ok {\n\t\tif _, ok = o.self.assertCallable(); ok {\n\t\t\treturn r.toBoolean(o.self.hasInstance(call.Argument(0)))\n\t\t}\n\t}\n\n\treturn valueFalse\n}\n\nfunc (r *Runtime) createListFromArrayLike(a Value) []Value {\n\to := r.toObject(a)\n\tif arr := r.checkStdArrayObj(o); arr != nil {\n\t\treturn arr.values\n\t}\n\tl := toLength(o.self.getStr(\"length\", nil))\n\tres := make([]Value, 0, l)\n\tfor k := int64(0); k < l; k++ {\n\t\tres = append(res, nilSafe(o.self.getIdx(valueInt(k), nil)))\n\t}\n\treturn res\n}\n\nfunc (r *Runtime) functionproto_apply(call FunctionCall) Value {\n\tvar args []Value\n\tif len(call.Arguments) >= 2 {\n\t\targs = r.createListFromArrayLike(call.Arguments[1])\n\t}\n\n\tf := r.toCallable(call.This)\n\treturn f(FunctionCall{\n\t\tThis:      call.Argument(0),\n\t\tArguments: args,\n\t})\n}\n\nfunc (r *Runtime) functionproto_call(call FunctionCall) Value {\n\tvar args []Value\n\tif len(call.Arguments) > 0 {\n\t\targs = call.Arguments[1:]\n\t}\n\n\tf := r.toCallable(call.This)\n\treturn f(FunctionCall{\n\t\tThis:      call.Argument(0),\n\t\tArguments: args,\n\t})\n}\n\nfunc (r *Runtime) boundCallable(target func(FunctionCall) Value, boundArgs []Value) func(FunctionCall) Value {\n\tvar this Value\n\tvar args []Value\n\tif len(boundArgs) > 0 {\n\t\tthis = boundArgs[0]\n\t\targs = make([]Value, len(boundArgs)-1)\n\t\tcopy(args, boundArgs[1:])\n\t} else {\n\t\tthis = _undefined\n\t}\n\treturn func(call FunctionCall) Value {\n\t\ta := append(args, call.Arguments...)\n\t\treturn target(FunctionCall{\n\t\t\tThis:      this,\n\t\t\tArguments: a,\n\t\t})\n\t}\n}\n\nfunc (r *Runtime) boundConstruct(f *Object, target func([]Value, *Object) *Object, boundArgs []Value) func([]Value, *Object) *Object {\n\tif target == nil {\n\t\treturn nil\n\t}\n\tvar args []Value\n\tif len(boundArgs) > 1 {\n\t\targs = make([]Value, len(boundArgs)-1)\n\t\tcopy(args, boundArgs[1:])\n\t}\n\treturn func(fargs []Value, newTarget *Object) *Object {\n\t\ta := append(args, fargs...)\n\t\tif newTarget == f {\n\t\t\tnewTarget = nil\n\t\t}\n\t\treturn target(a, newTarget)\n\t}\n}\n\nfunc (r *Runtime) functionproto_bind(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\n\tfcall := r.toCallable(call.This)\n\tconstruct := obj.self.assertConstructor()\n\n\tvar l = _positiveZero\n\tif obj.self.hasOwnPropertyStr(\"length\") {\n\t\tvar li int64\n\t\tswitch lenProp := nilSafe(obj.self.getStr(\"length\", nil)).(type) {\n\t\tcase valueInt:\n\t\t\tli = lenProp.ToInteger()\n\t\tcase valueFloat:\n\t\t\tswitch lenProp {\n\t\t\tcase _positiveInf:\n\t\t\t\tl = lenProp\n\t\t\t\tgoto lenNotInt\n\t\t\tcase _negativeInf:\n\t\t\t\tgoto lenNotInt\n\t\t\tcase _negativeZero:\n\t\t\t\t// no-op, li == 0\n\t\t\tdefault:\n\t\t\t\tif !math.IsNaN(float64(lenProp)) {\n\t\t\t\t\tli = int64(math.Abs(float64(lenProp)))\n\t\t\t\t} // else li = 0\n\t\t\t}\n\t\t}\n\t\tif len(call.Arguments) > 1 {\n\t\t\tli -= int64(len(call.Arguments)) - 1\n\t\t}\n\t\tif li < 0 {\n\t\t\tli = 0\n\t\t}\n\t\tl = intToValue(li)\n\t}\nlenNotInt:\n\tname := obj.self.getStr(\"name\", nil)\n\tnameStr := stringBound_\n\tif s, ok := name.(String); ok {\n\t\tnameStr = nameStr.Concat(s)\n\t}\n\n\tv := &Object{runtime: r}\n\tff := r.newNativeFuncAndConstruct(v, r.boundCallable(fcall, call.Arguments), r.boundConstruct(v, construct, call.Arguments), nil, nameStr.string(), l)\n\tbf := &boundFuncObject{\n\t\tnativeFuncObject: *ff,\n\t\twrapped:          obj,\n\t}\n\tbf.prototype = obj.self.proto()\n\tv.self = bf\n\n\treturn v\n}\n\nfunc (r *Runtime) getThrower() *Object {\n\tret := r.global.thrower\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.builtin_thrower, \"\", 0)\n\t\tr.global.thrower = ret\n\t\tr.object_freeze(FunctionCall{Arguments: []Value{ret}})\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) newThrowerProperty(configurable bool) Value {\n\tthrower := r.getThrower()\n\treturn &valueProperty{\n\t\tgetterFunc:   thrower,\n\t\tsetterFunc:   thrower,\n\t\taccessor:     true,\n\t\tconfigurable: configurable,\n\t}\n}\n\nfunc createFunctionProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getFunction(), true, false, true) })\n\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(_positiveZero, false, false, true) })\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(stringEmpty, false, false, true) })\n\n\tt.putStr(\"apply\", func(r *Runtime) Value { return r.methodProp(r.functionproto_apply, \"apply\", 2) })\n\tt.putStr(\"bind\", func(r *Runtime) Value { return r.methodProp(r.functionproto_bind, \"bind\", 1) })\n\tt.putStr(\"call\", func(r *Runtime) Value { return r.methodProp(r.functionproto_call, \"call\", 1) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.functionproto_toString, \"toString\", 0) })\n\n\tt.putStr(\"caller\", func(r *Runtime) Value { return r.newThrowerProperty(true) })\n\tt.putStr(\"arguments\", func(r *Runtime) Value { return r.newThrowerProperty(true) })\n\n\tt.putSym(SymHasInstance, func(r *Runtime) Value {\n\t\treturn valueProp(r.newNativeFunc(r.functionproto_hasInstance, \"[Symbol.hasInstance]\", 1), false, false, false)\n\t})\n\n\treturn t\n}\n\nvar functionProtoTemplate *objectTemplate\nvar functionProtoTemplateOnce sync.Once\n\nfunc getFunctionProtoTemplate() *objectTemplate {\n\tfunctionProtoTemplateOnce.Do(func() {\n\t\tfunctionProtoTemplate = createFunctionProtoTemplate()\n\t})\n\treturn functionProtoTemplate\n}\n\nfunc (r *Runtime) getFunctionPrototype() *Object {\n\tret := r.global.FunctionPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.FunctionPrototype = ret\n\t\tr.newTemplatedFuncObject(getFunctionProtoTemplate(), ret, func(FunctionCall) Value {\n\t\t\treturn _undefined\n\t\t}, nil)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) createFunction(v *Object) objectImpl {\n\treturn r.newNativeFuncConstructObj(v, r.builtin_Function, \"Function\", r.getFunctionPrototype(), 1)\n}\n\nfunc (r *Runtime) createAsyncFunctionProto(val *Object) objectImpl {\n\to := &baseObject{\n\t\tclass:      classObject,\n\t\tval:        val,\n\t\textensible: true,\n\t\tprototype:  r.getFunctionPrototype(),\n\t}\n\to.init()\n\n\to._putProp(\"constructor\", r.getAsyncFunction(), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(classAsyncFunction), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getAsyncFunctionPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.AsyncFunctionPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.AsyncFunctionPrototype = o\n\t\to.self = r.createAsyncFunctionProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createAsyncFunction(val *Object) objectImpl {\n\to := r.newNativeFuncConstructObj(val, r.builtin_asyncFunction, \"AsyncFunction\", r.getAsyncFunctionPrototype(), 1)\n\n\treturn o\n}\n\nfunc (r *Runtime) getAsyncFunction() *Object {\n\tvar o *Object\n\tif o = r.global.AsyncFunction; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.AsyncFunction = o\n\t\to.self = r.createAsyncFunction(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) builtin_genproto_next(call FunctionCall) Value {\n\tif o, ok := call.This.(*Object); ok {\n\t\tif gen, ok := o.self.(*generatorObject); ok {\n\t\t\treturn gen.next(call.Argument(0))\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method [Generator].prototype.next called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) builtin_genproto_return(call FunctionCall) Value {\n\tif o, ok := call.This.(*Object); ok {\n\t\tif gen, ok := o.self.(*generatorObject); ok {\n\t\t\treturn gen._return(call.Argument(0))\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method [Generator].prototype.return called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) builtin_genproto_throw(call FunctionCall) Value {\n\tif o, ok := call.This.(*Object); ok {\n\t\tif gen, ok := o.self.(*generatorObject); ok {\n\t\t\treturn gen.throw(call.Argument(0))\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method [Generator].prototype.throw called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) createGeneratorFunctionProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getFunctionPrototype(), classObject)\n\n\to._putProp(\"constructor\", r.getGeneratorFunction(), false, false, true)\n\to._putProp(\"prototype\", r.getGeneratorPrototype(), false, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classGeneratorFunction), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getGeneratorFunctionPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.GeneratorFunctionPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.GeneratorFunctionPrototype = o\n\t\to.self = r.createGeneratorFunctionProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createGeneratorFunction(val *Object) objectImpl {\n\to := r.newNativeFuncConstructObj(val, r.builtin_generatorFunction, \"GeneratorFunction\", r.getGeneratorFunctionPrototype(), 1)\n\treturn o\n}\n\nfunc (r *Runtime) getGeneratorFunction() *Object {\n\tvar o *Object\n\tif o = r.global.GeneratorFunction; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.GeneratorFunction = o\n\t\to.self = r.createGeneratorFunction(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createGeneratorProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"constructor\", r.getGeneratorFunctionPrototype(), false, false, true)\n\to._putProp(\"next\", r.newNativeFunc(r.builtin_genproto_next, \"next\", 1), true, false, true)\n\to._putProp(\"return\", r.newNativeFunc(r.builtin_genproto_return, \"return\", 1), true, false, true)\n\to._putProp(\"throw\", r.newNativeFunc(r.builtin_genproto_throw, \"throw\", 1), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(classGenerator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getGeneratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.GeneratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.GeneratorPrototype = o\n\t\to.self = r.createGeneratorProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) getFunction() *Object {\n\tret := r.global.Function\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Function = ret\n\t\tret.self = r.createFunction(ret)\n\t}\n\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_function_test.go",
          "type": "blob",
          "size": 0.22265625,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHashbangInFunctionConstructor(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(SyntaxError, function() {\n\t\tnew Function(\"#!\")\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "builtin_global.go",
          "type": "blob",
          "size": 14.6875,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst hexUpper = \"0123456789ABCDEF\"\n\nvar (\n\tparseFloatRegexp = regexp.MustCompile(`^([+-]?(?:Infinity|[0-9]*\\.?[0-9]*(?:[eE][+-]?[0-9]+)?))`)\n)\n\nfunc (r *Runtime) builtin_isNaN(call FunctionCall) Value {\n\tif math.IsNaN(call.Argument(0).ToFloat()) {\n\t\treturn valueTrue\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) builtin_parseInt(call FunctionCall) Value {\n\tstr := call.Argument(0).toString().toTrimmedUTF8()\n\tradix := int(toInt32(call.Argument(1)))\n\tv, _ := parseInt(str, radix)\n\treturn v\n}\n\nfunc (r *Runtime) builtin_parseFloat(call FunctionCall) Value {\n\tm := parseFloatRegexp.FindStringSubmatch(call.Argument(0).toString().toTrimmedUTF8())\n\tif len(m) == 2 {\n\t\tif s := m[1]; s != \"\" && s != \"+\" && s != \"-\" {\n\t\t\tswitch s {\n\t\t\tcase \"+\", \"-\":\n\t\t\tcase \"Infinity\", \"+Infinity\":\n\t\t\t\treturn _positiveInf\n\t\t\tcase \"-Infinity\":\n\t\t\t\treturn _negativeInf\n\t\t\tdefault:\n\t\t\t\tf, err := strconv.ParseFloat(s, 64)\n\t\t\t\tif err == nil || isRangeErr(err) {\n\t\t\t\t\treturn floatToValue(f)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn _NaN\n}\n\nfunc (r *Runtime) builtin_isFinite(call FunctionCall) Value {\n\tf := call.Argument(0).ToFloat()\n\tif math.IsNaN(f) || math.IsInf(f, 0) {\n\t\treturn valueFalse\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) _encode(uriString String, unescaped *[256]bool) String {\n\treader := uriString.Reader()\n\tutf8Buf := make([]byte, utf8.UTFMax)\n\tneeded := false\n\tl := 0\n\tfor {\n\t\trn, _, err := reader.ReadRune()\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\tpanic(r.newError(r.getURIError(), \"Malformed URI\"))\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif rn >= utf8.RuneSelf {\n\t\t\tneeded = true\n\t\t\tl += utf8.EncodeRune(utf8Buf, rn) * 3\n\t\t} else if !unescaped[rn] {\n\t\t\tneeded = true\n\t\t\tl += 3\n\t\t} else {\n\t\t\tl++\n\t\t}\n\t}\n\n\tif !needed {\n\t\treturn uriString\n\t}\n\n\tbuf := make([]byte, l)\n\ti := 0\n\treader = uriString.Reader()\n\tfor {\n\t\trn, _, err := reader.ReadRune()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\tif rn >= utf8.RuneSelf {\n\t\t\tn := utf8.EncodeRune(utf8Buf, rn)\n\t\t\tfor _, b := range utf8Buf[:n] {\n\t\t\t\tbuf[i] = '%'\n\t\t\t\tbuf[i+1] = hexUpper[b>>4]\n\t\t\t\tbuf[i+2] = hexUpper[b&15]\n\t\t\t\ti += 3\n\t\t\t}\n\t\t} else if !unescaped[rn] {\n\t\t\tbuf[i] = '%'\n\t\t\tbuf[i+1] = hexUpper[rn>>4]\n\t\t\tbuf[i+2] = hexUpper[rn&15]\n\t\t\ti += 3\n\t\t} else {\n\t\t\tbuf[i] = byte(rn)\n\t\t\ti++\n\t\t}\n\t}\n\treturn asciiString(buf)\n}\n\nfunc (r *Runtime) _decode(sv String, reservedSet *[256]bool) String {\n\ts := sv.String()\n\thexCount := 0\n\tfor i := 0; i < len(s); {\n\t\tswitch s[i] {\n\t\tcase '%':\n\t\t\tif i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {\n\t\t\t\tpanic(r.newError(r.getURIError(), \"Malformed URI\"))\n\t\t\t}\n\t\t\tc := unhex(s[i+1])<<4 | unhex(s[i+2])\n\t\t\tif !reservedSet[c] {\n\t\t\t\thexCount++\n\t\t\t}\n\t\t\ti += 3\n\t\tdefault:\n\t\t\ti++\n\t\t}\n\t}\n\n\tif hexCount == 0 {\n\t\treturn sv\n\t}\n\n\tt := make([]byte, len(s)-hexCount*2)\n\tj := 0\n\tisUnicode := false\n\tfor i := 0; i < len(s); {\n\t\tch := s[i]\n\t\tswitch ch {\n\t\tcase '%':\n\t\t\tc := unhex(s[i+1])<<4 | unhex(s[i+2])\n\t\t\tif reservedSet[c] {\n\t\t\t\tt[j] = s[i]\n\t\t\t\tt[j+1] = s[i+1]\n\t\t\t\tt[j+2] = s[i+2]\n\t\t\t\tj += 3\n\t\t\t} else {\n\t\t\t\tt[j] = c\n\t\t\t\tif c >= utf8.RuneSelf {\n\t\t\t\t\tisUnicode = true\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\t\t\ti += 3\n\t\tdefault:\n\t\t\tif ch >= utf8.RuneSelf {\n\t\t\t\tisUnicode = true\n\t\t\t}\n\t\t\tt[j] = ch\n\t\t\tj++\n\t\t\ti++\n\t\t}\n\t}\n\n\tif !isUnicode {\n\t\treturn asciiString(t)\n\t}\n\n\tus := make([]rune, 0, len(s))\n\tfor len(t) > 0 {\n\t\trn, size := utf8.DecodeRune(t)\n\t\tif rn == utf8.RuneError {\n\t\t\tif size != 3 || t[0] != 0xef || t[1] != 0xbf || t[2] != 0xbd {\n\t\t\t\tpanic(r.newError(r.getURIError(), \"Malformed URI\"))\n\t\t\t}\n\t\t}\n\t\tus = append(us, rn)\n\t\tt = t[size:]\n\t}\n\treturn unicodeStringFromRunes(us)\n}\n\nfunc ishex(c byte) bool {\n\tswitch {\n\tcase '0' <= c && c <= '9':\n\t\treturn true\n\tcase 'a' <= c && c <= 'f':\n\t\treturn true\n\tcase 'A' <= c && c <= 'F':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc unhex(c byte) byte {\n\tswitch {\n\tcase '0' <= c && c <= '9':\n\t\treturn c - '0'\n\tcase 'a' <= c && c <= 'f':\n\t\treturn c - 'a' + 10\n\tcase 'A' <= c && c <= 'F':\n\t\treturn c - 'A' + 10\n\t}\n\treturn 0\n}\n\nfunc (r *Runtime) builtin_decodeURI(call FunctionCall) Value {\n\turiString := call.Argument(0).toString()\n\treturn r._decode(uriString, &uriReservedHash)\n}\n\nfunc (r *Runtime) builtin_decodeURIComponent(call FunctionCall) Value {\n\turiString := call.Argument(0).toString()\n\treturn r._decode(uriString, &emptyEscapeSet)\n}\n\nfunc (r *Runtime) builtin_encodeURI(call FunctionCall) Value {\n\turiString := call.Argument(0).toString()\n\treturn r._encode(uriString, &uriReservedUnescapedHash)\n}\n\nfunc (r *Runtime) builtin_encodeURIComponent(call FunctionCall) Value {\n\turiString := call.Argument(0).toString()\n\treturn r._encode(uriString, &uriUnescaped)\n}\n\nfunc (r *Runtime) builtin_escape(call FunctionCall) Value {\n\ts := call.Argument(0).toString()\n\tvar sb strings.Builder\n\tl := s.Length()\n\tfor i := 0; i < l; i++ {\n\t\tr := s.CharAt(i)\n\t\tif r >= 'A' && r <= 'Z' || r >= 'a' && r <= 'z' || r >= '0' && r <= '9' ||\n\t\t\tr == '@' || r == '*' || r == '_' || r == '+' || r == '-' || r == '.' || r == '/' {\n\t\t\tsb.WriteByte(byte(r))\n\t\t} else if r <= 0xff {\n\t\t\tsb.WriteByte('%')\n\t\t\tsb.WriteByte(hexUpper[r>>4])\n\t\t\tsb.WriteByte(hexUpper[r&0xf])\n\t\t} else {\n\t\t\tsb.WriteString(\"%u\")\n\t\t\tsb.WriteByte(hexUpper[r>>12])\n\t\t\tsb.WriteByte(hexUpper[(r>>8)&0xf])\n\t\t\tsb.WriteByte(hexUpper[(r>>4)&0xf])\n\t\t\tsb.WriteByte(hexUpper[r&0xf])\n\t\t}\n\t}\n\treturn asciiString(sb.String())\n}\n\nfunc (r *Runtime) builtin_unescape(call FunctionCall) Value {\n\ts := call.Argument(0).toString()\n\tl := s.Length()\n\tvar asciiBuf []byte\n\tvar unicodeBuf []uint16\n\t_, u := devirtualizeString(s)\n\tunicode := u != nil\n\tif unicode {\n\t\tunicodeBuf = make([]uint16, 1, l+1)\n\t\tunicodeBuf[0] = unistring.BOM\n\t} else {\n\t\tasciiBuf = make([]byte, 0, l)\n\t}\n\tfor i := 0; i < l; {\n\t\tr := s.CharAt(i)\n\t\tif r == '%' {\n\t\t\tif i <= l-6 && s.CharAt(i+1) == 'u' {\n\t\t\t\tc0 := s.CharAt(i + 2)\n\t\t\t\tc1 := s.CharAt(i + 3)\n\t\t\t\tc2 := s.CharAt(i + 4)\n\t\t\t\tc3 := s.CharAt(i + 5)\n\t\t\t\tif c0 <= 0xff && ishex(byte(c0)) &&\n\t\t\t\t\tc1 <= 0xff && ishex(byte(c1)) &&\n\t\t\t\t\tc2 <= 0xff && ishex(byte(c2)) &&\n\t\t\t\t\tc3 <= 0xff && ishex(byte(c3)) {\n\t\t\t\t\tr = uint16(unhex(byte(c0)))<<12 |\n\t\t\t\t\t\tuint16(unhex(byte(c1)))<<8 |\n\t\t\t\t\t\tuint16(unhex(byte(c2)))<<4 |\n\t\t\t\t\t\tuint16(unhex(byte(c3)))\n\t\t\t\t\ti += 5\n\t\t\t\t\tgoto out\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i <= l-3 {\n\t\t\t\tc0 := s.CharAt(i + 1)\n\t\t\t\tc1 := s.CharAt(i + 2)\n\t\t\t\tif c0 <= 0xff && ishex(byte(c0)) &&\n\t\t\t\t\tc1 <= 0xff && ishex(byte(c1)) {\n\t\t\t\t\tr = uint16(unhex(byte(c0))<<4 | unhex(byte(c1)))\n\t\t\t\t\ti += 2\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tout:\n\t\tif r >= utf8.RuneSelf && !unicode {\n\t\t\tunicodeBuf = make([]uint16, 1, l+1)\n\t\t\tunicodeBuf[0] = unistring.BOM\n\t\t\tfor _, b := range asciiBuf {\n\t\t\t\tunicodeBuf = append(unicodeBuf, uint16(b))\n\t\t\t}\n\t\t\tasciiBuf = nil\n\t\t\tunicode = true\n\t\t}\n\t\tif unicode {\n\t\t\tunicodeBuf = append(unicodeBuf, r)\n\t\t} else {\n\t\t\tasciiBuf = append(asciiBuf, byte(r))\n\t\t}\n\t\ti++\n\t}\n\tif unicode {\n\t\treturn unicodeString(unicodeBuf)\n\t}\n\n\treturn asciiString(asciiBuf)\n}\n\nfunc createGlobalObjectTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"Object\", func(r *Runtime) Value { return valueProp(r.getObject(), true, false, true) })\n\tt.putStr(\"Function\", func(r *Runtime) Value { return valueProp(r.getFunction(), true, false, true) })\n\tt.putStr(\"Array\", func(r *Runtime) Value { return valueProp(r.getArray(), true, false, true) })\n\tt.putStr(\"String\", func(r *Runtime) Value { return valueProp(r.getString(), true, false, true) })\n\tt.putStr(\"Number\", func(r *Runtime) Value { return valueProp(r.getNumber(), true, false, true) })\n\tt.putStr(\"BigInt\", func(r *Runtime) Value { return valueProp(r.getBigInt(), true, false, true) })\n\tt.putStr(\"RegExp\", func(r *Runtime) Value { return valueProp(r.getRegExp(), true, false, true) })\n\tt.putStr(\"Date\", func(r *Runtime) Value { return valueProp(r.getDate(), true, false, true) })\n\tt.putStr(\"Boolean\", func(r *Runtime) Value { return valueProp(r.getBoolean(), true, false, true) })\n\tt.putStr(\"Proxy\", func(r *Runtime) Value { return valueProp(r.getProxy(), true, false, true) })\n\tt.putStr(\"Reflect\", func(r *Runtime) Value { return valueProp(r.getReflect(), true, false, true) })\n\tt.putStr(\"Error\", func(r *Runtime) Value { return valueProp(r.getError(), true, false, true) })\n\tt.putStr(\"AggregateError\", func(r *Runtime) Value { return valueProp(r.getAggregateError(), true, false, true) })\n\tt.putStr(\"TypeError\", func(r *Runtime) Value { return valueProp(r.getTypeError(), true, false, true) })\n\tt.putStr(\"ReferenceError\", func(r *Runtime) Value { return valueProp(r.getReferenceError(), true, false, true) })\n\tt.putStr(\"SyntaxError\", func(r *Runtime) Value { return valueProp(r.getSyntaxError(), true, false, true) })\n\tt.putStr(\"RangeError\", func(r *Runtime) Value { return valueProp(r.getRangeError(), true, false, true) })\n\tt.putStr(\"EvalError\", func(r *Runtime) Value { return valueProp(r.getEvalError(), true, false, true) })\n\tt.putStr(\"URIError\", func(r *Runtime) Value { return valueProp(r.getURIError(), true, false, true) })\n\tt.putStr(\"GoError\", func(r *Runtime) Value { return valueProp(r.getGoError(), true, false, true) })\n\n\tt.putStr(\"eval\", func(r *Runtime) Value { return valueProp(r.getEval(), true, false, true) })\n\n\tt.putStr(\"Math\", func(r *Runtime) Value { return valueProp(r.getMath(), true, false, true) })\n\tt.putStr(\"JSON\", func(r *Runtime) Value { return valueProp(r.getJSON(), true, false, true) })\n\taddTypedArrays(t)\n\tt.putStr(\"Symbol\", func(r *Runtime) Value { return valueProp(r.getSymbol(), true, false, true) })\n\tt.putStr(\"WeakSet\", func(r *Runtime) Value { return valueProp(r.getWeakSet(), true, false, true) })\n\tt.putStr(\"WeakMap\", func(r *Runtime) Value { return valueProp(r.getWeakMap(), true, false, true) })\n\tt.putStr(\"Map\", func(r *Runtime) Value { return valueProp(r.getMap(), true, false, true) })\n\tt.putStr(\"Set\", func(r *Runtime) Value { return valueProp(r.getSet(), true, false, true) })\n\tt.putStr(\"Promise\", func(r *Runtime) Value { return valueProp(r.getPromise(), true, false, true) })\n\n\tt.putStr(\"globalThis\", func(r *Runtime) Value { return valueProp(r.globalObject, true, false, true) })\n\tt.putStr(\"NaN\", func(r *Runtime) Value { return valueProp(_NaN, false, false, false) })\n\tt.putStr(\"undefined\", func(r *Runtime) Value { return valueProp(_undefined, false, false, false) })\n\tt.putStr(\"Infinity\", func(r *Runtime) Value { return valueProp(_positiveInf, false, false, false) })\n\n\tt.putStr(\"isNaN\", func(r *Runtime) Value { return r.methodProp(r.builtin_isNaN, \"isNaN\", 1) })\n\tt.putStr(\"parseInt\", func(r *Runtime) Value { return valueProp(r.getParseInt(), true, false, true) })\n\tt.putStr(\"parseFloat\", func(r *Runtime) Value { return valueProp(r.getParseFloat(), true, false, true) })\n\tt.putStr(\"isFinite\", func(r *Runtime) Value { return r.methodProp(r.builtin_isFinite, \"isFinite\", 1) })\n\tt.putStr(\"decodeURI\", func(r *Runtime) Value { return r.methodProp(r.builtin_decodeURI, \"decodeURI\", 1) })\n\tt.putStr(\"decodeURIComponent\", func(r *Runtime) Value { return r.methodProp(r.builtin_decodeURIComponent, \"decodeURIComponent\", 1) })\n\tt.putStr(\"encodeURI\", func(r *Runtime) Value { return r.methodProp(r.builtin_encodeURI, \"encodeURI\", 1) })\n\tt.putStr(\"encodeURIComponent\", func(r *Runtime) Value { return r.methodProp(r.builtin_encodeURIComponent, \"encodeURIComponent\", 1) })\n\tt.putStr(\"escape\", func(r *Runtime) Value { return r.methodProp(r.builtin_escape, \"escape\", 1) })\n\tt.putStr(\"unescape\", func(r *Runtime) Value { return r.methodProp(r.builtin_unescape, \"unescape\", 1) })\n\n\t// TODO: Annex B\n\n\tt.putSym(SymToStringTag, func(r *Runtime) Value { return valueProp(asciiString(classGlobal), false, false, true) })\n\n\treturn t\n}\n\nvar globalObjectTemplate *objectTemplate\nvar globalObjectTemplateOnce sync.Once\n\nfunc getGlobalObjectTemplate() *objectTemplate {\n\tglobalObjectTemplateOnce.Do(func() {\n\t\tglobalObjectTemplate = createGlobalObjectTemplate()\n\t})\n\treturn globalObjectTemplate\n}\n\nfunc (r *Runtime) getEval() *Object {\n\tret := r.global.Eval\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.builtin_eval, \"eval\", 1)\n\t\tr.global.Eval = ret\n\t}\n\treturn ret\n}\n\nfunc digitVal(d byte) int {\n\tvar v byte\n\tswitch {\n\tcase '0' <= d && d <= '9':\n\t\tv = d - '0'\n\tcase 'a' <= d && d <= 'z':\n\t\tv = d - 'a' + 10\n\tcase 'A' <= d && d <= 'Z':\n\t\tv = d - 'A' + 10\n\tdefault:\n\t\treturn 36\n\t}\n\treturn int(v)\n}\n\n// ECMAScript compatible version of strconv.ParseInt\nfunc parseInt(s string, base int) (Value, error) {\n\tvar n int64\n\tvar err error\n\tvar cutoff, maxVal int64\n\tvar sign bool\n\ti := 0\n\n\tif len(s) < 1 {\n\t\terr = strconv.ErrSyntax\n\t\tgoto Error\n\t}\n\n\tswitch s[0] {\n\tcase '-':\n\t\tsign = true\n\t\ts = s[1:]\n\tcase '+':\n\t\ts = s[1:]\n\t}\n\n\tif len(s) < 1 {\n\t\terr = strconv.ErrSyntax\n\t\tgoto Error\n\t}\n\n\t// Look for hex prefix.\n\tif s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X') {\n\t\tif base == 0 || base == 16 {\n\t\t\tbase = 16\n\t\t\ts = s[2:]\n\t\t}\n\t}\n\n\tswitch {\n\tcase len(s) < 1:\n\t\terr = strconv.ErrSyntax\n\t\tgoto Error\n\n\tcase 2 <= base && base <= 36:\n\t// valid base; nothing to do\n\n\tcase base == 0:\n\t\t// Look for hex prefix.\n\t\tswitch {\n\t\tcase s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):\n\t\t\tif len(s) < 3 {\n\t\t\t\terr = strconv.ErrSyntax\n\t\t\t\tgoto Error\n\t\t\t}\n\t\t\tbase = 16\n\t\t\ts = s[2:]\n\t\tdefault:\n\t\t\tbase = 10\n\t\t}\n\n\tdefault:\n\t\terr = errors.New(\"invalid base \" + strconv.Itoa(base))\n\t\tgoto Error\n\t}\n\n\t// Cutoff is the smallest number such that cutoff*base > maxInt64.\n\t// Use compile-time constants for common cases.\n\tswitch base {\n\tcase 10:\n\t\tcutoff = math.MaxInt64/10 + 1\n\tcase 16:\n\t\tcutoff = math.MaxInt64/16 + 1\n\tdefault:\n\t\tcutoff = math.MaxInt64/int64(base) + 1\n\t}\n\n\tmaxVal = math.MaxInt64\n\tfor ; i < len(s); i++ {\n\t\tif n >= cutoff {\n\t\t\t// n*base overflows\n\t\t\treturn parseLargeInt(float64(n), s[i:], base, sign)\n\t\t}\n\t\tv := digitVal(s[i])\n\t\tif v >= base {\n\t\t\tbreak\n\t\t}\n\t\tn *= int64(base)\n\n\t\tn1 := n + int64(v)\n\t\tif n1 < n || n1 > maxVal {\n\t\t\t// n+v overflows\n\t\t\treturn parseLargeInt(float64(n)+float64(v), s[i+1:], base, sign)\n\t\t}\n\t\tn = n1\n\t}\n\n\tif i == 0 {\n\t\terr = strconv.ErrSyntax\n\t\tgoto Error\n\t}\n\n\tif sign {\n\t\tn = -n\n\t}\n\treturn intToValue(n), nil\n\nError:\n\treturn _NaN, err\n}\n\nfunc parseLargeInt(n float64, s string, base int, sign bool) (Value, error) {\n\ti := 0\n\tb := float64(base)\n\tfor ; i < len(s); i++ {\n\t\tv := digitVal(s[i])\n\t\tif v >= base {\n\t\t\tbreak\n\t\t}\n\t\tn = n*b + float64(v)\n\t}\n\tif sign {\n\t\tn = -n\n\t}\n\t// We know it can't be represented as int, so use valueFloat instead of floatToValue\n\treturn valueFloat(n), nil\n}\n\nvar (\n\turiUnescaped             [256]bool\n\turiReserved              [256]bool\n\turiReservedHash          [256]bool\n\turiReservedUnescapedHash [256]bool\n\temptyEscapeSet           [256]bool\n)\n\nfunc init() {\n\tfor _, c := range \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.!~*'()\" {\n\t\turiUnescaped[c] = true\n\t}\n\n\tfor _, c := range \";/?:@&=+$,\" {\n\t\turiReserved[c] = true\n\t}\n\n\tfor i := 0; i < 256; i++ {\n\t\tif uriUnescaped[i] || uriReserved[i] {\n\t\t\turiReservedUnescapedHash[i] = true\n\t\t}\n\t\turiReservedHash[i] = uriReserved[i]\n\t}\n\turiReservedUnescapedHash['#'] = true\n\turiReservedHash['#'] = true\n}\n"
        },
        {
          "name": "builtin_global_test.go",
          "type": "blob",
          "size": 0.3974609375,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEncodeURI(t *testing.T) {\n\tconst SCRIPT = `\n\tencodeURI('')\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"%D1%82%D0%B5%D1%81%D1%82\"), t)\n}\n\nfunc TestDecodeURI(t *testing.T) {\n\tconst SCRIPT = `\n\tdecodeURI(\"http://ru.wikipedia.org/wiki/%d0%ae%D0%bd%D0%B8%D0%BA%D0%BE%D0%B4\")\n\t`\n\n\ttestScript(SCRIPT, newStringValue(\"http://ru.wikipedia.org/wiki/\"), t)\n}\n"
        },
        {
          "name": "builtin_json.go",
          "type": "blob",
          "size": 12.009765625,
          "content": "package goja\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst hex = \"0123456789abcdef\"\n\nfunc (r *Runtime) builtinJSON_parse(call FunctionCall) Value {\n\td := json.NewDecoder(strings.NewReader(call.Argument(0).toString().String()))\n\n\tvalue, err := r.builtinJSON_decodeValue(d)\n\tif errors.Is(err, io.EOF) {\n\t\tpanic(r.newError(r.getSyntaxError(), \"Unexpected end of JSON input (%v)\", err.Error()))\n\t}\n\tif err != nil {\n\t\tpanic(r.newError(r.getSyntaxError(), err.Error()))\n\t}\n\n\tif tok, err := d.Token(); err != io.EOF {\n\t\tpanic(r.newError(r.getSyntaxError(), \"Unexpected token at the end: %v\", tok))\n\t}\n\n\tvar reviver func(FunctionCall) Value\n\n\tif arg1 := call.Argument(1); arg1 != _undefined {\n\t\treviver, _ = arg1.ToObject(r).self.assertCallable()\n\t}\n\n\tif reviver != nil {\n\t\troot := r.NewObject()\n\t\tcreateDataPropertyOrThrow(root, stringEmpty, value)\n\t\treturn r.builtinJSON_reviveWalk(reviver, root, stringEmpty)\n\t}\n\n\treturn value\n}\n\nfunc (r *Runtime) builtinJSON_decodeToken(d *json.Decoder, tok json.Token) (Value, error) {\n\tswitch tok := tok.(type) {\n\tcase json.Delim:\n\t\tswitch tok {\n\t\tcase '{':\n\t\t\treturn r.builtinJSON_decodeObject(d)\n\t\tcase '[':\n\t\t\treturn r.builtinJSON_decodeArray(d)\n\t\t}\n\tcase nil:\n\t\treturn _null, nil\n\tcase string:\n\t\treturn newStringValue(tok), nil\n\tcase float64:\n\t\treturn floatToValue(tok), nil\n\tcase bool:\n\t\tif tok {\n\t\t\treturn valueTrue, nil\n\t\t}\n\t\treturn valueFalse, nil\n\t}\n\treturn nil, fmt.Errorf(\"Unexpected token (%T): %v\", tok, tok)\n}\n\nfunc (r *Runtime) builtinJSON_decodeValue(d *json.Decoder) (Value, error) {\n\ttok, err := d.Token()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn r.builtinJSON_decodeToken(d, tok)\n}\n\nfunc (r *Runtime) builtinJSON_decodeObject(d *json.Decoder) (*Object, error) {\n\tobject := r.NewObject()\n\tfor {\n\t\tkey, end, err := r.builtinJSON_decodeObjectKey(d)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif end {\n\t\t\tbreak\n\t\t}\n\t\tvalue, err := r.builtinJSON_decodeValue(d)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tobject.self._putProp(unistring.NewFromString(key), value, true, true, true)\n\t}\n\treturn object, nil\n}\n\nfunc (r *Runtime) builtinJSON_decodeObjectKey(d *json.Decoder) (string, bool, error) {\n\ttok, err := d.Token()\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\tswitch tok := tok.(type) {\n\tcase json.Delim:\n\t\tif tok == '}' {\n\t\t\treturn \"\", true, nil\n\t\t}\n\tcase string:\n\t\treturn tok, false, nil\n\t}\n\n\treturn \"\", false, fmt.Errorf(\"Unexpected token (%T): %v\", tok, tok)\n}\n\nfunc (r *Runtime) builtinJSON_decodeArray(d *json.Decoder) (*Object, error) {\n\tvar arrayValue []Value\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif delim, ok := tok.(json.Delim); ok {\n\t\t\tif delim == ']' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tvalue, err := r.builtinJSON_decodeToken(d, tok)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tarrayValue = append(arrayValue, value)\n\t}\n\treturn r.newArrayValues(arrayValue), nil\n}\n\nfunc (r *Runtime) builtinJSON_reviveWalk(reviver func(FunctionCall) Value, holder *Object, name Value) Value {\n\tvalue := nilSafe(holder.get(name, nil))\n\n\tif object, ok := value.(*Object); ok {\n\t\tif isArray(object) {\n\t\t\tlength := toLength(object.self.getStr(\"length\", nil))\n\t\t\tfor index := int64(0); index < length; index++ {\n\t\t\t\tname := asciiString(strconv.FormatInt(index, 10))\n\t\t\t\tvalue := r.builtinJSON_reviveWalk(reviver, object, name)\n\t\t\t\tif value == _undefined {\n\t\t\t\t\tobject.delete(name, false)\n\t\t\t\t} else {\n\t\t\t\t\tcreateDataProperty(object, name, value)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, name := range object.self.stringKeys(false, nil) {\n\t\t\t\tvalue := r.builtinJSON_reviveWalk(reviver, object, name)\n\t\t\t\tif value == _undefined {\n\t\t\t\t\tobject.self.deleteStr(name.string(), false)\n\t\t\t\t} else {\n\t\t\t\t\tcreateDataProperty(object, name, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn reviver(FunctionCall{\n\t\tThis:      holder,\n\t\tArguments: []Value{name, value},\n\t})\n}\n\ntype _builtinJSON_stringifyContext struct {\n\tr                *Runtime\n\tstack            []*Object\n\tpropertyList     []Value\n\treplacerFunction func(FunctionCall) Value\n\tgap, indent      string\n\tbuf              bytes.Buffer\n\tallAscii         bool\n}\n\nfunc (r *Runtime) builtinJSON_stringify(call FunctionCall) Value {\n\tctx := _builtinJSON_stringifyContext{\n\t\tr:        r,\n\t\tallAscii: true,\n\t}\n\n\treplacer, _ := call.Argument(1).(*Object)\n\tif replacer != nil {\n\t\tif isArray(replacer) {\n\t\t\tlength := toLength(replacer.self.getStr(\"length\", nil))\n\t\t\tseen := map[string]bool{}\n\t\t\tpropertyList := make([]Value, length)\n\t\t\tlength = 0\n\t\t\tfor index := range propertyList {\n\t\t\t\tvar name string\n\t\t\t\tvalue := replacer.self.getIdx(valueInt(int64(index)), nil)\n\t\t\t\tswitch v := value.(type) {\n\t\t\t\tcase valueFloat, valueInt, String:\n\t\t\t\t\tname = value.String()\n\t\t\t\tcase *Object:\n\t\t\t\t\tswitch v.self.className() {\n\t\t\t\t\tcase classNumber, classString:\n\t\t\t\t\t\tname = value.String()\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif seen[name] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tseen[name] = true\n\t\t\t\tpropertyList[length] = newStringValue(name)\n\t\t\t\tlength += 1\n\t\t\t}\n\t\t\tctx.propertyList = propertyList[0:length]\n\t\t} else if c, ok := replacer.self.assertCallable(); ok {\n\t\t\tctx.replacerFunction = c\n\t\t}\n\t}\n\tif spaceValue := call.Argument(2); spaceValue != _undefined {\n\t\tif o, ok := spaceValue.(*Object); ok {\n\t\t\tswitch oImpl := o.self.(type) {\n\t\t\tcase *primitiveValueObject:\n\t\t\t\tswitch oImpl.pValue.(type) {\n\t\t\t\tcase valueInt, valueFloat:\n\t\t\t\t\tspaceValue = o.ToNumber()\n\t\t\t\t}\n\t\t\tcase *stringObject:\n\t\t\t\tspaceValue = o.ToString()\n\t\t\t}\n\t\t}\n\t\tisNum := false\n\t\tvar num int64\n\t\tif i, ok := spaceValue.(valueInt); ok {\n\t\t\tnum = int64(i)\n\t\t\tisNum = true\n\t\t} else if f, ok := spaceValue.(valueFloat); ok {\n\t\t\tnum = int64(f)\n\t\t\tisNum = true\n\t\t}\n\t\tif isNum {\n\t\t\tif num > 0 {\n\t\t\t\tif num > 10 {\n\t\t\t\t\tnum = 10\n\t\t\t\t}\n\t\t\t\tctx.gap = strings.Repeat(\" \", int(num))\n\t\t\t}\n\t\t} else {\n\t\t\tif s, ok := spaceValue.(String); ok {\n\t\t\t\tstr := s.String()\n\t\t\t\tif len(str) > 10 {\n\t\t\t\t\tctx.gap = str[:10]\n\t\t\t\t} else {\n\t\t\t\t\tctx.gap = str\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ctx.do(call.Argument(0)) {\n\t\tif ctx.allAscii {\n\t\t\treturn asciiString(ctx.buf.String())\n\t\t} else {\n\t\t\treturn &importedString{\n\t\t\t\ts: ctx.buf.String(),\n\t\t\t}\n\t\t}\n\t}\n\treturn _undefined\n}\n\nfunc (ctx *_builtinJSON_stringifyContext) do(v Value) bool {\n\tholder := ctx.r.NewObject()\n\tcreateDataPropertyOrThrow(holder, stringEmpty, v)\n\treturn ctx.str(stringEmpty, holder)\n}\n\nfunc (ctx *_builtinJSON_stringifyContext) str(key Value, holder *Object) bool {\n\tvalue := nilSafe(holder.get(key, nil))\n\n\tswitch value.(type) {\n\tcase *Object, *valueBigInt:\n\t\tif toJSON, ok := ctx.r.getVStr(value, \"toJSON\").(*Object); ok {\n\t\t\tif c, ok := toJSON.self.assertCallable(); ok {\n\t\t\t\tvalue = c(FunctionCall{\n\t\t\t\t\tThis:      value,\n\t\t\t\t\tArguments: []Value{key},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif ctx.replacerFunction != nil {\n\t\tvalue = ctx.replacerFunction(FunctionCall{\n\t\t\tThis:      holder,\n\t\t\tArguments: []Value{key, value},\n\t\t})\n\t}\n\n\tif o, ok := value.(*Object); ok {\n\t\tswitch o1 := o.self.(type) {\n\t\tcase *primitiveValueObject:\n\t\t\tswitch pValue := o1.pValue.(type) {\n\t\t\tcase valueInt, valueFloat:\n\t\t\t\tvalue = o.ToNumber()\n\t\t\tdefault:\n\t\t\t\tvalue = pValue\n\t\t\t}\n\t\tcase *stringObject:\n\t\t\tvalue = o.toString()\n\t\tcase *objectGoReflect:\n\t\t\tif o1.toJson != nil {\n\t\t\t\tvalue = ctx.r.ToValue(o1.toJson())\n\t\t\t} else if v, ok := o1.origValue.Interface().(json.Marshaler); ok {\n\t\t\t\tb, err := v.MarshalJSON()\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(ctx.r.NewGoError(err))\n\t\t\t\t}\n\t\t\t\tctx.buf.Write(b)\n\t\t\t\tctx.allAscii = false\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\tswitch o1.className() {\n\t\t\t\tcase classNumber:\n\t\t\t\t\tvalue = o1.val.ordinaryToPrimitiveNumber()\n\t\t\t\tcase classString:\n\t\t\t\t\tvalue = o1.val.ordinaryToPrimitiveString()\n\t\t\t\tcase classBoolean:\n\t\t\t\t\tif o.ToInteger() != 0 {\n\t\t\t\t\t\tvalue = valueTrue\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = valueFalse\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif o1.exportType() == typeBigInt {\n\t\t\t\t\tvalue = o1.val.ordinaryToPrimitiveNumber()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch value1 := value.(type) {\n\tcase valueBool:\n\t\tif value1 {\n\t\t\tctx.buf.WriteString(\"true\")\n\t\t} else {\n\t\t\tctx.buf.WriteString(\"false\")\n\t\t}\n\tcase String:\n\t\tctx.quote(value1)\n\tcase valueInt:\n\t\tctx.buf.WriteString(value.String())\n\tcase valueFloat:\n\t\tif !math.IsNaN(float64(value1)) && !math.IsInf(float64(value1), 0) {\n\t\t\tctx.buf.WriteString(value.String())\n\t\t} else {\n\t\t\tctx.buf.WriteString(\"null\")\n\t\t}\n\tcase valueNull:\n\t\tctx.buf.WriteString(\"null\")\n\tcase *valueBigInt:\n\t\tctx.r.typeErrorResult(true, \"Do not know how to serialize a BigInt\")\n\tcase *Object:\n\t\tfor _, object := range ctx.stack {\n\t\t\tif value1.SameAs(object) {\n\t\t\t\tctx.r.typeErrorResult(true, \"Converting circular structure to JSON\")\n\t\t\t}\n\t\t}\n\t\tctx.stack = append(ctx.stack, value1)\n\t\tdefer func() { ctx.stack = ctx.stack[:len(ctx.stack)-1] }()\n\t\tif _, ok := value1.self.assertCallable(); !ok {\n\t\t\tif isArray(value1) {\n\t\t\t\tctx.ja(value1)\n\t\t\t} else {\n\t\t\t\tctx.jo(value1)\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (ctx *_builtinJSON_stringifyContext) ja(array *Object) {\n\tvar stepback string\n\tif ctx.gap != \"\" {\n\t\tstepback = ctx.indent\n\t\tctx.indent += ctx.gap\n\t}\n\tlength := toLength(array.self.getStr(\"length\", nil))\n\tif length == 0 {\n\t\tctx.buf.WriteString(\"[]\")\n\t\treturn\n\t}\n\n\tctx.buf.WriteByte('[')\n\tvar separator string\n\tif ctx.gap != \"\" {\n\t\tctx.buf.WriteByte('\\n')\n\t\tctx.buf.WriteString(ctx.indent)\n\t\tseparator = \",\\n\" + ctx.indent\n\t} else {\n\t\tseparator = \",\"\n\t}\n\n\tfor i := int64(0); i < length; i++ {\n\t\tif !ctx.str(asciiString(strconv.FormatInt(i, 10)), array) {\n\t\t\tctx.buf.WriteString(\"null\")\n\t\t}\n\t\tif i < length-1 {\n\t\t\tctx.buf.WriteString(separator)\n\t\t}\n\t}\n\tif ctx.gap != \"\" {\n\t\tctx.buf.WriteByte('\\n')\n\t\tctx.buf.WriteString(stepback)\n\t\tctx.indent = stepback\n\t}\n\tctx.buf.WriteByte(']')\n}\n\nfunc (ctx *_builtinJSON_stringifyContext) jo(object *Object) {\n\tvar stepback string\n\tif ctx.gap != \"\" {\n\t\tstepback = ctx.indent\n\t\tctx.indent += ctx.gap\n\t}\n\n\tctx.buf.WriteByte('{')\n\tmark := ctx.buf.Len()\n\tvar separator string\n\tif ctx.gap != \"\" {\n\t\tctx.buf.WriteByte('\\n')\n\t\tctx.buf.WriteString(ctx.indent)\n\t\tseparator = \",\\n\" + ctx.indent\n\t} else {\n\t\tseparator = \",\"\n\t}\n\n\tvar props []Value\n\tif ctx.propertyList == nil {\n\t\tprops = object.self.stringKeys(false, nil)\n\t} else {\n\t\tprops = ctx.propertyList\n\t}\n\n\tempty := true\n\tfor _, name := range props {\n\t\toff := ctx.buf.Len()\n\t\tif !empty {\n\t\t\tctx.buf.WriteString(separator)\n\t\t}\n\t\tctx.quote(name.toString())\n\t\tif ctx.gap != \"\" {\n\t\t\tctx.buf.WriteString(\": \")\n\t\t} else {\n\t\t\tctx.buf.WriteByte(':')\n\t\t}\n\t\tif ctx.str(name, object) {\n\t\t\tif empty {\n\t\t\t\tempty = false\n\t\t\t}\n\t\t} else {\n\t\t\tctx.buf.Truncate(off)\n\t\t}\n\t}\n\n\tif empty {\n\t\tctx.buf.Truncate(mark)\n\t} else {\n\t\tif ctx.gap != \"\" {\n\t\t\tctx.buf.WriteByte('\\n')\n\t\t\tctx.buf.WriteString(stepback)\n\t\t\tctx.indent = stepback\n\t\t}\n\t}\n\tctx.buf.WriteByte('}')\n}\n\nfunc (ctx *_builtinJSON_stringifyContext) quote(str String) {\n\tctx.buf.WriteByte('\"')\n\treader := &lenientUtf16Decoder{utf16Reader: str.utf16Reader()}\n\tfor {\n\t\tr, _, err := reader.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tswitch r {\n\t\tcase '\"', '\\\\':\n\t\t\tctx.buf.WriteByte('\\\\')\n\t\t\tctx.buf.WriteByte(byte(r))\n\t\tcase 0x08:\n\t\t\tctx.buf.WriteString(`\\b`)\n\t\tcase 0x09:\n\t\t\tctx.buf.WriteString(`\\t`)\n\t\tcase 0x0A:\n\t\t\tctx.buf.WriteString(`\\n`)\n\t\tcase 0x0C:\n\t\t\tctx.buf.WriteString(`\\f`)\n\t\tcase 0x0D:\n\t\t\tctx.buf.WriteString(`\\r`)\n\t\tdefault:\n\t\t\tif r < 0x20 {\n\t\t\t\tctx.buf.WriteString(`\\u00`)\n\t\t\t\tctx.buf.WriteByte(hex[r>>4])\n\t\t\t\tctx.buf.WriteByte(hex[r&0xF])\n\t\t\t} else {\n\t\t\t\tif utf16.IsSurrogate(r) {\n\t\t\t\t\tctx.buf.WriteString(`\\u`)\n\t\t\t\t\tctx.buf.WriteByte(hex[r>>12])\n\t\t\t\t\tctx.buf.WriteByte(hex[(r>>8)&0xF])\n\t\t\t\t\tctx.buf.WriteByte(hex[(r>>4)&0xF])\n\t\t\t\t\tctx.buf.WriteByte(hex[r&0xF])\n\t\t\t\t} else {\n\t\t\t\t\tctx.buf.WriteRune(r)\n\t\t\t\t\tif ctx.allAscii && r >= utf8.RuneSelf {\n\t\t\t\t\t\tctx.allAscii = false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tctx.buf.WriteByte('\"')\n}\n\nfunc (r *Runtime) getJSON() *Object {\n\tret := r.global.JSON\n\tif ret == nil {\n\t\tJSON := r.newBaseObject(r.global.ObjectPrototype, classObject)\n\t\tret = JSON.val\n\t\tr.global.JSON = ret\n\t\tJSON._putProp(\"parse\", r.newNativeFunc(r.builtinJSON_parse, \"parse\", 2), true, false, true)\n\t\tJSON._putProp(\"stringify\", r.newNativeFunc(r.builtinJSON_stringify, \"stringify\", 3), true, false, true)\n\t\tJSON._putSym(SymToStringTag, valueProp(asciiString(classJSON), false, false, true))\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_json_test.go",
          "type": "blob",
          "size": 2.99609375,
          "content": "package goja\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestJSONMarshalObject(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\to.Set(\"test\", 42)\n\to.Set(\"testfunc\", vm.Get(\"Error\"))\n\tb, err := json.Marshal(o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != `{\"test\":42}` {\n\t\tt.Fatalf(\"Unexpected value: %s\", b)\n\t}\n}\n\nfunc TestJSONMarshalGoDate(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\to.Set(\"test\", time.Unix(86400, 0).UTC())\n\tb, err := json.Marshal(o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != `{\"test\":\"1970-01-02T00:00:00Z\"}` {\n\t\tt.Fatalf(\"Unexpected value: %s\", b)\n\t}\n}\n\nfunc TestJSONMarshalObjectCircular(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\to.Set(\"o\", o)\n\t_, err := json.Marshal(o)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tif !strings.HasSuffix(err.Error(), \"Converting circular structure to JSON\") {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc TestJSONStringifyCircularWrappedGo(t *testing.T) {\n\ttype CircularType struct {\n\t\tSelf *CircularType\n\t}\n\tvm := New()\n\tv := CircularType{}\n\tv.Self = &v\n\tvm.Set(\"v\", &v)\n\t_, err := vm.RunString(\"JSON.stringify(v)\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tif !strings.HasPrefix(err.Error(), \"TypeError: Converting circular structure to JSON\") {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc TestJSONParseReviver(t *testing.T) {\n\t// example from\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n\tconst SCRIPT = `\n\tJSON.parse('{\"p\": 5}', function(key, value) {\n\t  return typeof value === 'number'\n        ? value * 2 // return value * 2 for numbers\n\t    : value     // return everything else unchanged\n\t })[\"p\"]\n\t`\n\n\ttestScript(SCRIPT, intToValue(10), t)\n}\n\nfunc TestQuoteMalformedSurrogatePair(t *testing.T) {\n\ttestScript(`JSON.stringify(\"\\uD800\")`, asciiString(`\"\\ud800\"`), t)\n}\n\nfunc TestEOFWrapping(t *testing.T) {\n\tvm := New()\n\n\t_, err := vm.RunString(\"JSON.parse('{')\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"Unexpected end of JSON input\") {\n\t\tt.Fatalf(\"Error doesn't contain human-friendly wrapper: %v\", err)\n\t}\n}\n\ntype testMarshalJSONErrorStruct struct {\n\te error\n}\n\nfunc (s *testMarshalJSONErrorStruct) MarshalJSON() ([]byte, error) {\n\treturn nil, s.e\n}\n\nfunc TestMarshalJSONError(t *testing.T) {\n\tvm := New()\n\tv := testMarshalJSONErrorStruct{e: errors.New(\"test error\")}\n\tvm.Set(\"v\", &v)\n\t_, err := vm.RunString(\"JSON.stringify(v)\")\n\tif !errors.Is(err, v.e) {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc BenchmarkJSONStringify(b *testing.B) {\n\tb.StopTimer()\n\tvm := New()\n\tvar createObj func(level int) *Object\n\tcreateObj = func(level int) *Object {\n\t\to := vm.NewObject()\n\t\to.Set(\"field1\", \"test\")\n\t\to.Set(\"field2\", 42)\n\t\tif level > 0 {\n\t\t\tlevel--\n\t\t\to.Set(\"obj1\", createObj(level))\n\t\t\to.Set(\"obj2\", createObj(level))\n\t\t}\n\t\treturn o\n\t}\n\n\to := createObj(3)\n\tjson := vm.Get(\"JSON\").(*Object)\n\tstringify, _ := AssertFunction(json.Get(\"stringify\"))\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tstringify(nil, o)\n\t}\n}\n"
        },
        {
          "name": "builtin_map.go",
          "type": "blob",
          "size": 9.1484375,
          "content": "package goja\n\nimport (\n\t\"reflect\"\n)\n\nvar mapExportType = reflect.TypeOf([][2]interface{}{})\n\ntype mapObject struct {\n\tbaseObject\n\tm *orderedMap\n}\n\ntype mapIterObject struct {\n\tbaseObject\n\titer *orderedMapIter\n\tkind iterationKind\n}\n\nfunc (o *mapIterObject) next() Value {\n\tif o.iter == nil {\n\t\treturn o.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\n\tentry := o.iter.next()\n\tif entry == nil {\n\t\to.iter = nil\n\t\treturn o.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\n\tvar result Value\n\tswitch o.kind {\n\tcase iterationKindKey:\n\t\tresult = entry.key\n\tcase iterationKindValue:\n\t\tresult = entry.value\n\tdefault:\n\t\tresult = o.val.runtime.newArrayValues([]Value{entry.key, entry.value})\n\t}\n\n\treturn o.val.runtime.createIterResultObject(result, false)\n}\n\nfunc (mo *mapObject) init() {\n\tmo.baseObject.init()\n\tmo.m = newOrderedMap(mo.val.runtime.getHash())\n}\n\nfunc (mo *mapObject) exportType() reflect.Type {\n\treturn mapExportType\n}\n\nfunc (mo *mapObject) export(ctx *objectExportCtx) interface{} {\n\tm := make([][2]interface{}, mo.m.size)\n\tctx.put(mo.val, m)\n\n\titer := mo.m.newIter()\n\tfor i := 0; i < len(m); i++ {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tm[i][0] = exportValue(entry.key, ctx)\n\t\tm[i][1] = exportValue(entry.value, ctx)\n\t}\n\n\treturn m\n}\n\nfunc (mo *mapObject) exportToMap(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tdst.Set(reflect.MakeMap(typ))\n\tctx.putTyped(mo.val, typ, dst.Interface())\n\tkeyTyp := typ.Key()\n\telemTyp := typ.Elem()\n\titer := mo.m.newIter()\n\tr := mo.val.runtime\n\tfor {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tkeyVal := reflect.New(keyTyp).Elem()\n\t\terr := r.toReflectValue(entry.key, keyVal, ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\telemVal := reflect.New(elemTyp).Elem()\n\t\terr = r.toReflectValue(entry.value, elemVal, ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdst.SetMapIndex(keyVal, elemVal)\n\t}\n\treturn nil\n}\n\nfunc (r *Runtime) mapProto_clear(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.clear called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\tmo.m.clear()\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) mapProto_delete(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.delete called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\treturn r.toBoolean(mo.m.remove(call.Argument(0)))\n}\n\nfunc (r *Runtime) mapProto_get(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.get called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\treturn nilSafe(mo.m.get(call.Argument(0)))\n}\n\nfunc (r *Runtime) mapProto_has(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.has called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tif mo.m.has(call.Argument(0)) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) mapProto_set(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.set called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tmo.m.set(call.Argument(0), call.Argument(1))\n\treturn call.This\n}\n\nfunc (r *Runtime) mapProto_entries(call FunctionCall) Value {\n\treturn r.createMapIterator(call.This, iterationKindKeyValue)\n}\n\nfunc (r *Runtime) mapProto_forEach(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Map.prototype.forEach called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tcallbackFn, ok := r.toObject(call.Argument(0)).self.assertCallable()\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"object is not a function %s\"))\n\t}\n\tt := call.Argument(1)\n\titer := mo.m.newIter()\n\tfor {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tcallbackFn(FunctionCall{This: t, Arguments: []Value{entry.value, entry.key, thisObj}})\n\t}\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) mapProto_keys(call FunctionCall) Value {\n\treturn r.createMapIterator(call.This, iterationKindKey)\n}\n\nfunc (r *Runtime) mapProto_values(call FunctionCall) Value {\n\treturn r.createMapIterator(call.This, iterationKindValue)\n}\n\nfunc (r *Runtime) mapProto_getSize(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tmo, ok := thisObj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method get Map.prototype.size called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\treturn intToValue(int64(mo.m.size))\n}\n\nfunc (r *Runtime) builtin_newMap(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"Map\"))\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, r.global.Map, r.global.MapPrototype)\n\to := &Object{runtime: r}\n\n\tmo := &mapObject{}\n\tmo.class = classObject\n\tmo.val = o\n\tmo.extensible = true\n\to.self = mo\n\tmo.prototype = proto\n\tmo.init()\n\tif len(args) > 0 {\n\t\tif arg := args[0]; arg != nil && arg != _undefined && arg != _null {\n\t\t\tadder := mo.getStr(\"set\", nil)\n\t\t\tadderFn := toMethod(adder)\n\t\t\tif adderFn == nil {\n\t\t\t\tpanic(r.NewTypeError(\"Map.set in missing\"))\n\t\t\t}\n\t\t\titer := r.getIterator(arg, nil)\n\t\t\ti0 := valueInt(0)\n\t\t\ti1 := valueInt(1)\n\t\t\tif adder == r.global.mapAdder {\n\t\t\t\titer.iterate(func(item Value) {\n\t\t\t\t\titemObj := r.toObject(item)\n\t\t\t\t\tk := nilSafe(itemObj.self.getIdx(i0, nil))\n\t\t\t\t\tv := nilSafe(itemObj.self.getIdx(i1, nil))\n\t\t\t\t\tmo.m.set(k, v)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\titer.iterate(func(item Value) {\n\t\t\t\t\titemObj := r.toObject(item)\n\t\t\t\t\tk := itemObj.self.getIdx(i0, nil)\n\t\t\t\t\tv := itemObj.self.getIdx(i1, nil)\n\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{k, v}})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createMapIterator(mapValue Value, kind iterationKind) Value {\n\tobj := r.toObject(mapValue)\n\tmapObj, ok := obj.self.(*mapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Object is not a Map\"))\n\t}\n\n\to := &Object{runtime: r}\n\n\tmi := &mapIterObject{\n\t\titer: mapObj.m.newIter(),\n\t\tkind: kind,\n\t}\n\tmi.class = classObject\n\tmi.val = o\n\tmi.extensible = true\n\to.self = mi\n\tmi.prototype = r.getMapIteratorPrototype()\n\tmi.init()\n\n\treturn o\n}\n\nfunc (r *Runtime) mapIterProto_next(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif iter, ok := thisObj.self.(*mapIterObject); ok {\n\t\treturn iter.next()\n\t}\n\tpanic(r.NewTypeError(\"Method Map Iterator.prototype.next called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc (r *Runtime) createMapProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putProp(\"constructor\", r.getMap(), true, false, true)\n\to._putProp(\"clear\", r.newNativeFunc(r.mapProto_clear, \"clear\", 0), true, false, true)\n\tr.global.mapAdder = r.newNativeFunc(r.mapProto_set, \"set\", 2)\n\to._putProp(\"set\", r.global.mapAdder, true, false, true)\n\to._putProp(\"delete\", r.newNativeFunc(r.mapProto_delete, \"delete\", 1), true, false, true)\n\to._putProp(\"forEach\", r.newNativeFunc(r.mapProto_forEach, \"forEach\", 1), true, false, true)\n\to._putProp(\"has\", r.newNativeFunc(r.mapProto_has, \"has\", 1), true, false, true)\n\to._putProp(\"get\", r.newNativeFunc(r.mapProto_get, \"get\", 1), true, false, true)\n\to.setOwnStr(\"size\", &valueProperty{\n\t\tgetterFunc:   r.newNativeFunc(r.mapProto_getSize, \"get size\", 0),\n\t\taccessor:     true,\n\t\twritable:     true,\n\t\tconfigurable: true,\n\t}, true)\n\to._putProp(\"keys\", r.newNativeFunc(r.mapProto_keys, \"keys\", 0), true, false, true)\n\to._putProp(\"values\", r.newNativeFunc(r.mapProto_values, \"values\", 0), true, false, true)\n\n\tentriesFunc := r.newNativeFunc(r.mapProto_entries, \"entries\", 0)\n\to._putProp(\"entries\", entriesFunc, true, false, true)\n\to._putSym(SymIterator, valueProp(entriesFunc, true, false, true))\n\to._putSym(SymToStringTag, valueProp(asciiString(classMap), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createMap(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newMap, r.getMapPrototype(), \"Map\", 0)\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) createMapIterProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"next\", r.newNativeFunc(r.mapIterProto_next, \"next\", 0), true, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classMapIterator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getMapIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.MapIteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.MapIteratorPrototype = o\n\t\to.self = r.createMapIterProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) getMapPrototype() *Object {\n\tret := r.global.MapPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.MapPrototype = ret\n\t\tret.self = r.createMapProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getMap() *Object {\n\tret := r.global.Map\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Map = ret\n\t\tret.self = r.createMap(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_map_test.go",
          "type": "blob",
          "size": 4.123046875,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"hash/maphash\"\n\t\"testing\"\n)\n\nfunc TestMapEvilIterator(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar o = {};\n\n\tfunction Iter(value) {\n\t\tthis.value = value;\n\t\tthis.idx = 0;\n\t}\n\n\tIter.prototype.next = function() {\n\t\tvar idx = this.idx;\n\t\tif (idx === 0) {\n\t\t\tthis.idx++;\n\t\t\treturn this.value;\n\t\t}\n\t\treturn {done: true};\n\t}\n\n\to[Symbol.iterator] = function() {\n\t\treturn new Iter({});\n\t}\n\n\tassert.throws(TypeError, function() {\n\t\tnew Map(o);\n\t});\n\n\to[Symbol.iterator] = function() {\n\t\treturn new Iter({value: []});\n\t}\n\n\tfunction t(prefix) {\n\t\tvar m = new Map(o);\n\t\tassert.sameValue(1, m.size, prefix+\": m.size\");\n\t\tassert.sameValue(true, m.has(undefined), prefix+\": m.has(undefined)\");\n\t\tassert.sameValue(undefined, m.get(undefined), prefix+\": m.get(undefined)\");\n\t}\n\n\tt(\"standard adder\");\n\n\tvar count = 0;\n\tvar origSet = Map.prototype.set;\n\n\tMap.prototype.set = function() {\n\t\tcount++;\n\t\torigSet.apply(this, arguments);\n\t}\n\n\tt(\"custom adder\");\n\tassert.sameValue(1, count, \"count\");\n\n\tundefined;\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestMapExportToNilMap(t *testing.T) {\n\tvm := New()\n\tvar m map[int]interface{}\n\tres, err := vm.RunString(\"new Map([[1, true]])\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = vm.ExportTo(res, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(m) != 1 {\n\t\tt.Fatal(m)\n\t}\n\tif _, exists := m[1]; !exists {\n\t\tt.Fatal(m)\n\t}\n}\n\nfunc TestMapExportToNonNilMap(t *testing.T) {\n\tvm := New()\n\tm := map[int]interface{}{\n\t\t2: true,\n\t}\n\tres, err := vm.RunString(\"new Map([[1, true]])\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = vm.ExportTo(res, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(m) != 1 {\n\t\tt.Fatal(m)\n\t}\n\tif _, exists := m[1]; !exists {\n\t\tt.Fatal(m)\n\t}\n}\n\nfunc TestMapGetAdderGetIteratorOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet getterCalled = 0;\n\n\tclass M extends Map {\n\t    get set() {\n\t        getterCalled++;\n\t        return null;\n\t    }\n\t}\n\n\tlet getIteratorCalled = 0;\n\n\tlet iterable = {};\n\titerable[Symbol.iterator] = () => {\n\t    getIteratorCalled++\n\t    return {\n\t        next: 1\n\t    };\n\t}\n\n\tlet thrown = false;\n\n\ttry {\n\t    new M(iterable);\n\t} catch (e) {\n\t    if (e instanceof TypeError) {\n\t        thrown = true;\n\t    } else {\n\t        throw e;\n\t    }\n\t}\n\n\tthrown && getterCalled === 1 && getIteratorCalled === 0;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc ExampleObject_Export_map() {\n\tvm := New()\n\tm, err := vm.RunString(`\n\tnew Map([[1, true], [2, false]]);\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\texp := m.Export()\n\tfmt.Printf(\"%T, %v\\n\", exp, exp)\n\t// Output: [][2]interface {}, [[1 true] [2 false]]\n}\n\nfunc ExampleRuntime_ExportTo_mapToMap() {\n\tvm := New()\n\tm, err := vm.RunString(`\n\tnew Map([[1, true], [2, false]]);\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\texp := make(map[int]bool)\n\terr = vm.ExportTo(m, &exp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(exp)\n\t// Output: map[1:true 2:false]\n}\n\nfunc ExampleRuntime_ExportTo_mapToSlice() {\n\tvm := New()\n\tm, err := vm.RunString(`\n\tnew Map([[1, true], [2, false]]);\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\texp := make([][]interface{}, 0)\n\terr = vm.ExportTo(m, &exp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(exp)\n\t// Output: [[1 true] [2 false]]\n}\n\nfunc ExampleRuntime_ExportTo_mapToTypedSlice() {\n\tvm := New()\n\tm, err := vm.RunString(`\n\tnew Map([[1, true], [2, false]]);\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\texp := make([][2]interface{}, 0)\n\terr = vm.ExportTo(m, &exp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(exp)\n\t// Output: [[1 true] [2 false]]\n}\n\nfunc BenchmarkMapDelete(b *testing.B) {\n\tvar key1 Value = asciiString(\"a\")\n\tvar key2 Value = asciiString(\"b\")\n\tone := intToValue(1)\n\ttwo := intToValue(2)\n\tfor i := 0; i < b.N; i++ {\n\t\tm := newOrderedMap(&maphash.Hash{})\n\t\tm.set(key1, one)\n\t\tm.set(key2, two)\n\t\tif !m.remove(key1) {\n\t\t\tb.Fatal(\"remove() returned false\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkMapDeleteJS(b *testing.B) {\n\tprg, err := Compile(\"test.js\", `\n\tvar m = new Map([['a',1], ['b', 2]]);\n\t\n\tvar result = m.delete('a');\n\n\tif (!result || m.size !== 1) {\n\t\tthrow new Error(\"Fail!\");\n\t}\n\t`,\n\t\tfalse)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm := New()\n\t\t_, err := vm.RunProgram(prg)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "builtin_math.go",
          "type": "blob",
          "size": 10.9951171875,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n\t\"sync\"\n)\n\nfunc (r *Runtime) math_abs(call FunctionCall) Value {\n\treturn floatToValue(math.Abs(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_acos(call FunctionCall) Value {\n\treturn floatToValue(math.Acos(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_acosh(call FunctionCall) Value {\n\treturn floatToValue(math.Acosh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_asin(call FunctionCall) Value {\n\treturn floatToValue(math.Asin(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_asinh(call FunctionCall) Value {\n\treturn floatToValue(math.Asinh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_atan(call FunctionCall) Value {\n\treturn floatToValue(math.Atan(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_atanh(call FunctionCall) Value {\n\treturn floatToValue(math.Atanh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_atan2(call FunctionCall) Value {\n\ty := call.Argument(0).ToFloat()\n\tx := call.Argument(1).ToFloat()\n\n\treturn floatToValue(math.Atan2(y, x))\n}\n\nfunc (r *Runtime) math_cbrt(call FunctionCall) Value {\n\treturn floatToValue(math.Cbrt(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_ceil(call FunctionCall) Value {\n\treturn floatToValue(math.Ceil(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_clz32(call FunctionCall) Value {\n\treturn intToValue(int64(bits.LeadingZeros32(toUint32(call.Argument(0)))))\n}\n\nfunc (r *Runtime) math_cos(call FunctionCall) Value {\n\treturn floatToValue(math.Cos(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_cosh(call FunctionCall) Value {\n\treturn floatToValue(math.Cosh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_exp(call FunctionCall) Value {\n\treturn floatToValue(math.Exp(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_expm1(call FunctionCall) Value {\n\treturn floatToValue(math.Expm1(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_floor(call FunctionCall) Value {\n\treturn floatToValue(math.Floor(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_fround(call FunctionCall) Value {\n\treturn floatToValue(float64(float32(call.Argument(0).ToFloat())))\n}\n\nfunc (r *Runtime) math_hypot(call FunctionCall) Value {\n\tvar max float64\n\tvar hasNaN bool\n\tabsValues := make([]float64, 0, len(call.Arguments))\n\tfor _, v := range call.Arguments {\n\t\targ := nilSafe(v).ToFloat()\n\t\tif math.IsNaN(arg) {\n\t\t\thasNaN = true\n\t\t} else {\n\t\t\tabs := math.Abs(arg)\n\t\t\tif abs > max {\n\t\t\t\tmax = abs\n\t\t\t}\n\t\t\tabsValues = append(absValues, abs)\n\t\t}\n\t}\n\tif math.IsInf(max, 1) {\n\t\treturn _positiveInf\n\t}\n\tif hasNaN {\n\t\treturn _NaN\n\t}\n\tif max == 0 {\n\t\treturn _positiveZero\n\t}\n\n\t// Kahan summation to avoid rounding errors.\n\t// Normalize the numbers to the largest one to avoid overflow.\n\tvar sum, compensation float64\n\tfor _, n := range absValues {\n\t\tn /= max\n\t\tsummand := n*n - compensation\n\t\tpreliminary := sum + summand\n\t\tcompensation = (preliminary - sum) - summand\n\t\tsum = preliminary\n\t}\n\treturn floatToValue(math.Sqrt(sum) * max)\n}\n\nfunc (r *Runtime) math_imul(call FunctionCall) Value {\n\tx := toUint32(call.Argument(0))\n\ty := toUint32(call.Argument(1))\n\treturn intToValue(int64(int32(x * y)))\n}\n\nfunc (r *Runtime) math_log(call FunctionCall) Value {\n\treturn floatToValue(math.Log(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_log1p(call FunctionCall) Value {\n\treturn floatToValue(math.Log1p(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_log10(call FunctionCall) Value {\n\treturn floatToValue(math.Log10(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_log2(call FunctionCall) Value {\n\treturn floatToValue(math.Log2(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_max(call FunctionCall) Value {\n\tresult := math.Inf(-1)\n\targs := call.Arguments\n\tfor i, arg := range args {\n\t\tn := nilSafe(arg).ToFloat()\n\t\tif math.IsNaN(n) {\n\t\t\targs = args[i+1:]\n\t\t\tgoto NaNLoop\n\t\t}\n\t\tresult = math.Max(result, n)\n\t}\n\n\treturn floatToValue(result)\n\nNaNLoop:\n\t// All arguments still need to be coerced to number according to the specs.\n\tfor _, arg := range args {\n\t\tnilSafe(arg).ToFloat()\n\t}\n\treturn _NaN\n}\n\nfunc (r *Runtime) math_min(call FunctionCall) Value {\n\tresult := math.Inf(1)\n\targs := call.Arguments\n\tfor i, arg := range args {\n\t\tn := nilSafe(arg).ToFloat()\n\t\tif math.IsNaN(n) {\n\t\t\targs = args[i+1:]\n\t\t\tgoto NaNLoop\n\t\t}\n\t\tresult = math.Min(result, n)\n\t}\n\n\treturn floatToValue(result)\n\nNaNLoop:\n\t// All arguments still need to be coerced to number according to the specs.\n\tfor _, arg := range args {\n\t\tnilSafe(arg).ToFloat()\n\t}\n\treturn _NaN\n}\n\nfunc pow(x, y Value) Value {\n\tif x, ok := x.(valueInt); ok {\n\t\tif y, ok := y.(valueInt); ok && y >= 0 {\n\t\t\tif y == 0 {\n\t\t\t\treturn intToValue(1)\n\t\t\t}\n\t\t\tif x == 0 {\n\t\t\t\treturn intToValue(0)\n\t\t\t}\n\t\t\tip := ipow(int64(x), int64(y))\n\t\t\tif ip != 0 {\n\t\t\t\treturn intToValue(ip)\n\t\t\t}\n\t\t}\n\t}\n\txf := x.ToFloat()\n\tyf := y.ToFloat()\n\tif math.Abs(xf) == 1 && math.IsInf(yf, 0) {\n\t\treturn _NaN\n\t}\n\tif xf == 1 && math.IsNaN(yf) {\n\t\treturn _NaN\n\t}\n\treturn floatToValue(math.Pow(xf, yf))\n}\n\nfunc (r *Runtime) math_pow(call FunctionCall) Value {\n\treturn pow(call.Argument(0), call.Argument(1))\n}\n\nfunc (r *Runtime) math_random(call FunctionCall) Value {\n\treturn floatToValue(r.rand())\n}\n\nfunc (r *Runtime) math_round(call FunctionCall) Value {\n\tf := call.Argument(0).ToFloat()\n\tif math.IsNaN(f) {\n\t\treturn _NaN\n\t}\n\n\tif f == 0 && math.Signbit(f) {\n\t\treturn _negativeZero\n\t}\n\n\tt := math.Trunc(f)\n\n\tif f >= 0 {\n\t\tif f-t >= 0.5 {\n\t\t\treturn floatToValue(t + 1)\n\t\t}\n\t} else {\n\t\tif t-f > 0.5 {\n\t\t\treturn floatToValue(t - 1)\n\t\t}\n\t}\n\n\treturn floatToValue(t)\n}\n\nfunc (r *Runtime) math_sign(call FunctionCall) Value {\n\targ := call.Argument(0)\n\tnum := arg.ToFloat()\n\tif math.IsNaN(num) || num == 0 { // this will match -0 too\n\t\treturn arg\n\t}\n\tif num > 0 {\n\t\treturn intToValue(1)\n\t}\n\treturn intToValue(-1)\n}\n\nfunc (r *Runtime) math_sin(call FunctionCall) Value {\n\treturn floatToValue(math.Sin(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_sinh(call FunctionCall) Value {\n\treturn floatToValue(math.Sinh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_sqrt(call FunctionCall) Value {\n\treturn floatToValue(math.Sqrt(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_tan(call FunctionCall) Value {\n\treturn floatToValue(math.Tan(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_tanh(call FunctionCall) Value {\n\treturn floatToValue(math.Tanh(call.Argument(0).ToFloat()))\n}\n\nfunc (r *Runtime) math_trunc(call FunctionCall) Value {\n\targ := call.Argument(0)\n\tif i, ok := arg.(valueInt); ok {\n\t\treturn i\n\t}\n\treturn floatToValue(math.Trunc(arg.ToFloat()))\n}\n\nfunc createMathTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"E\", func(r *Runtime) Value { return valueProp(valueFloat(math.E), false, false, false) })\n\tt.putStr(\"LN10\", func(r *Runtime) Value { return valueProp(valueFloat(math.Ln10), false, false, false) })\n\tt.putStr(\"LN2\", func(r *Runtime) Value { return valueProp(valueFloat(math.Ln2), false, false, false) })\n\tt.putStr(\"LOG10E\", func(r *Runtime) Value { return valueProp(valueFloat(math.Log10E), false, false, false) })\n\tt.putStr(\"LOG2E\", func(r *Runtime) Value { return valueProp(valueFloat(math.Log2E), false, false, false) })\n\tt.putStr(\"PI\", func(r *Runtime) Value { return valueProp(valueFloat(math.Pi), false, false, false) })\n\tt.putStr(\"SQRT1_2\", func(r *Runtime) Value { return valueProp(valueFloat(sqrt1_2), false, false, false) })\n\tt.putStr(\"SQRT2\", func(r *Runtime) Value { return valueProp(valueFloat(math.Sqrt2), false, false, false) })\n\n\tt.putSym(SymToStringTag, func(r *Runtime) Value { return valueProp(asciiString(classMath), false, false, true) })\n\n\tt.putStr(\"abs\", func(r *Runtime) Value { return r.methodProp(r.math_abs, \"abs\", 1) })\n\tt.putStr(\"acos\", func(r *Runtime) Value { return r.methodProp(r.math_acos, \"acos\", 1) })\n\tt.putStr(\"acosh\", func(r *Runtime) Value { return r.methodProp(r.math_acosh, \"acosh\", 1) })\n\tt.putStr(\"asin\", func(r *Runtime) Value { return r.methodProp(r.math_asin, \"asin\", 1) })\n\tt.putStr(\"asinh\", func(r *Runtime) Value { return r.methodProp(r.math_asinh, \"asinh\", 1) })\n\tt.putStr(\"atan\", func(r *Runtime) Value { return r.methodProp(r.math_atan, \"atan\", 1) })\n\tt.putStr(\"atanh\", func(r *Runtime) Value { return r.methodProp(r.math_atanh, \"atanh\", 1) })\n\tt.putStr(\"atan2\", func(r *Runtime) Value { return r.methodProp(r.math_atan2, \"atan2\", 2) })\n\tt.putStr(\"cbrt\", func(r *Runtime) Value { return r.methodProp(r.math_cbrt, \"cbrt\", 1) })\n\tt.putStr(\"ceil\", func(r *Runtime) Value { return r.methodProp(r.math_ceil, \"ceil\", 1) })\n\tt.putStr(\"clz32\", func(r *Runtime) Value { return r.methodProp(r.math_clz32, \"clz32\", 1) })\n\tt.putStr(\"cos\", func(r *Runtime) Value { return r.methodProp(r.math_cos, \"cos\", 1) })\n\tt.putStr(\"cosh\", func(r *Runtime) Value { return r.methodProp(r.math_cosh, \"cosh\", 1) })\n\tt.putStr(\"exp\", func(r *Runtime) Value { return r.methodProp(r.math_exp, \"exp\", 1) })\n\tt.putStr(\"expm1\", func(r *Runtime) Value { return r.methodProp(r.math_expm1, \"expm1\", 1) })\n\tt.putStr(\"floor\", func(r *Runtime) Value { return r.methodProp(r.math_floor, \"floor\", 1) })\n\tt.putStr(\"fround\", func(r *Runtime) Value { return r.methodProp(r.math_fround, \"fround\", 1) })\n\tt.putStr(\"hypot\", func(r *Runtime) Value { return r.methodProp(r.math_hypot, \"hypot\", 2) })\n\tt.putStr(\"imul\", func(r *Runtime) Value { return r.methodProp(r.math_imul, \"imul\", 2) })\n\tt.putStr(\"log\", func(r *Runtime) Value { return r.methodProp(r.math_log, \"log\", 1) })\n\tt.putStr(\"log1p\", func(r *Runtime) Value { return r.methodProp(r.math_log1p, \"log1p\", 1) })\n\tt.putStr(\"log10\", func(r *Runtime) Value { return r.methodProp(r.math_log10, \"log10\", 1) })\n\tt.putStr(\"log2\", func(r *Runtime) Value { return r.methodProp(r.math_log2, \"log2\", 1) })\n\tt.putStr(\"max\", func(r *Runtime) Value { return r.methodProp(r.math_max, \"max\", 2) })\n\tt.putStr(\"min\", func(r *Runtime) Value { return r.methodProp(r.math_min, \"min\", 2) })\n\tt.putStr(\"pow\", func(r *Runtime) Value { return r.methodProp(r.math_pow, \"pow\", 2) })\n\tt.putStr(\"random\", func(r *Runtime) Value { return r.methodProp(r.math_random, \"random\", 0) })\n\tt.putStr(\"round\", func(r *Runtime) Value { return r.methodProp(r.math_round, \"round\", 1) })\n\tt.putStr(\"sign\", func(r *Runtime) Value { return r.methodProp(r.math_sign, \"sign\", 1) })\n\tt.putStr(\"sin\", func(r *Runtime) Value { return r.methodProp(r.math_sin, \"sin\", 1) })\n\tt.putStr(\"sinh\", func(r *Runtime) Value { return r.methodProp(r.math_sinh, \"sinh\", 1) })\n\tt.putStr(\"sqrt\", func(r *Runtime) Value { return r.methodProp(r.math_sqrt, \"sqrt\", 1) })\n\tt.putStr(\"tan\", func(r *Runtime) Value { return r.methodProp(r.math_tan, \"tan\", 1) })\n\tt.putStr(\"tanh\", func(r *Runtime) Value { return r.methodProp(r.math_tanh, \"tanh\", 1) })\n\tt.putStr(\"trunc\", func(r *Runtime) Value { return r.methodProp(r.math_trunc, \"trunc\", 1) })\n\n\treturn t\n}\n\nvar mathTemplate *objectTemplate\nvar mathTemplateOnce sync.Once\n\nfunc getMathTemplate() *objectTemplate {\n\tmathTemplateOnce.Do(func() {\n\t\tmathTemplate = createMathTemplate()\n\t})\n\treturn mathTemplate\n}\n\nfunc (r *Runtime) getMath() *Object {\n\tret := r.global.Math\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Math = ret\n\t\tr.newTemplatedObject(getMathTemplate(), ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_number.go",
          "type": "blob",
          "size": 8.55078125,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"sync\"\n\n\t\"github.com/dop251/goja/ftoa\"\n)\n\nfunc (r *Runtime) toNumber(v Value) Value {\n\tswitch t := v.(type) {\n\tcase valueFloat, valueInt:\n\t\treturn v\n\tcase *Object:\n\t\tswitch t := t.self.(type) {\n\t\tcase *primitiveValueObject:\n\t\t\treturn r.toNumber(t.pValue)\n\t\tcase *objectGoReflect:\n\t\t\tif t.class == classNumber && t.valueOf != nil {\n\t\t\t\treturn t.valueOf()\n\t\t\t}\n\t\t}\n\t\tif t == r.global.NumberPrototype {\n\t\t\treturn _positiveZero\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Value is not a number: %s\", v))\n}\n\nfunc (r *Runtime) numberproto_valueOf(call FunctionCall) Value {\n\treturn r.toNumber(call.This)\n}\n\nfunc (r *Runtime) numberproto_toString(call FunctionCall) Value {\n\tvar numVal Value\n\tswitch t := call.This.(type) {\n\tcase valueFloat, valueInt:\n\t\tnumVal = t\n\tcase *Object:\n\t\tswitch t := t.self.(type) {\n\t\tcase *primitiveValueObject:\n\t\t\tnumVal = r.toNumber(t.pValue)\n\t\tcase *objectGoReflect:\n\t\t\tif t.class == classNumber {\n\t\t\t\tif t.toString != nil {\n\t\t\t\t\treturn t.toString()\n\t\t\t\t}\n\t\t\t\tif t.valueOf != nil {\n\t\t\t\t\tnumVal = t.valueOf()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif t == r.global.NumberPrototype {\n\t\t\treturn asciiString(\"0\")\n\t\t}\n\t}\n\tif numVal == nil {\n\t\tpanic(r.NewTypeError(\"Value is not a number\"))\n\t}\n\tvar radix int\n\tif arg := call.Argument(0); arg != _undefined {\n\t\tradix = int(arg.ToInteger())\n\t} else {\n\t\tradix = 10\n\t}\n\n\tif radix < 2 || radix > 36 {\n\t\tpanic(r.newError(r.getRangeError(), \"toString() radix argument must be between 2 and 36\"))\n\t}\n\n\tnum := numVal.ToFloat()\n\n\tif math.IsNaN(num) {\n\t\treturn stringNaN\n\t}\n\n\tif math.IsInf(num, 1) {\n\t\treturn stringInfinity\n\t}\n\n\tif math.IsInf(num, -1) {\n\t\treturn stringNegInfinity\n\t}\n\n\tif radix == 10 {\n\t\treturn asciiString(fToStr(num, ftoa.ModeStandard, 0))\n\t}\n\n\treturn asciiString(ftoa.FToBaseStr(num, radix))\n}\n\nfunc (r *Runtime) numberproto_toFixed(call FunctionCall) Value {\n\tnum := r.toNumber(call.This).ToFloat()\n\tprec := call.Argument(0).ToInteger()\n\n\tif prec < 0 || prec > 100 {\n\t\tpanic(r.newError(r.getRangeError(), \"toFixed() precision must be between 0 and 100\"))\n\t}\n\tif math.IsNaN(num) {\n\t\treturn stringNaN\n\t}\n\treturn asciiString(fToStr(num, ftoa.ModeFixed, int(prec)))\n}\n\nfunc (r *Runtime) numberproto_toExponential(call FunctionCall) Value {\n\tnum := r.toNumber(call.This).ToFloat()\n\tprecVal := call.Argument(0)\n\tvar prec int64\n\tif precVal == _undefined {\n\t\treturn asciiString(fToStr(num, ftoa.ModeStandardExponential, 0))\n\t} else {\n\t\tprec = precVal.ToInteger()\n\t}\n\n\tif math.IsNaN(num) {\n\t\treturn stringNaN\n\t}\n\tif math.IsInf(num, 1) {\n\t\treturn stringInfinity\n\t}\n\tif math.IsInf(num, -1) {\n\t\treturn stringNegInfinity\n\t}\n\n\tif prec < 0 || prec > 100 {\n\t\tpanic(r.newError(r.getRangeError(), \"toExponential() precision must be between 0 and 100\"))\n\t}\n\n\treturn asciiString(fToStr(num, ftoa.ModeExponential, int(prec+1)))\n}\n\nfunc (r *Runtime) numberproto_toPrecision(call FunctionCall) Value {\n\tnumVal := r.toNumber(call.This)\n\tprecVal := call.Argument(0)\n\tif precVal == _undefined {\n\t\treturn numVal.toString()\n\t}\n\tnum := numVal.ToFloat()\n\tprec := precVal.ToInteger()\n\n\tif math.IsNaN(num) {\n\t\treturn stringNaN\n\t}\n\tif math.IsInf(num, 1) {\n\t\treturn stringInfinity\n\t}\n\tif math.IsInf(num, -1) {\n\t\treturn stringNegInfinity\n\t}\n\tif prec < 1 || prec > 100 {\n\t\tpanic(r.newError(r.getRangeError(), \"toPrecision() precision must be between 1 and 100\"))\n\t}\n\n\treturn asciiString(fToStr(num, ftoa.ModePrecision, int(prec)))\n}\n\nfunc (r *Runtime) number_isFinite(call FunctionCall) Value {\n\tswitch arg := call.Argument(0).(type) {\n\tcase valueInt:\n\t\treturn valueTrue\n\tcase valueFloat:\n\t\tf := float64(arg)\n\t\treturn r.toBoolean(!math.IsInf(f, 0) && !math.IsNaN(f))\n\tdefault:\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) number_isInteger(call FunctionCall) Value {\n\tswitch arg := call.Argument(0).(type) {\n\tcase valueInt:\n\t\treturn valueTrue\n\tcase valueFloat:\n\t\tf := float64(arg)\n\t\treturn r.toBoolean(!math.IsNaN(f) && !math.IsInf(f, 0) && math.Floor(f) == f)\n\tdefault:\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) number_isNaN(call FunctionCall) Value {\n\tif f, ok := call.Argument(0).(valueFloat); ok && math.IsNaN(float64(f)) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) number_isSafeInteger(call FunctionCall) Value {\n\targ := call.Argument(0)\n\tif i, ok := arg.(valueInt); ok && i >= -(maxInt-1) && i <= maxInt-1 {\n\t\treturn valueTrue\n\t}\n\tif arg == _negativeZero {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc createNumberProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getNumber(), true, false, true) })\n\n\tt.putStr(\"toExponential\", func(r *Runtime) Value { return r.methodProp(r.numberproto_toExponential, \"toExponential\", 1) })\n\tt.putStr(\"toFixed\", func(r *Runtime) Value { return r.methodProp(r.numberproto_toFixed, \"toFixed\", 1) })\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.numberproto_toString, \"toLocaleString\", 0) })\n\tt.putStr(\"toPrecision\", func(r *Runtime) Value { return r.methodProp(r.numberproto_toPrecision, \"toPrecision\", 1) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.numberproto_toString, \"toString\", 1) })\n\tt.putStr(\"valueOf\", func(r *Runtime) Value { return r.methodProp(r.numberproto_valueOf, \"valueOf\", 0) })\n\n\treturn t\n}\n\nvar numberProtoTemplate *objectTemplate\nvar numberProtoTemplateOnce sync.Once\n\nfunc getNumberProtoTemplate() *objectTemplate {\n\tnumberProtoTemplateOnce.Do(func() {\n\t\tnumberProtoTemplate = createNumberProtoTemplate()\n\t})\n\treturn numberProtoTemplate\n}\n\nfunc (r *Runtime) getNumberPrototype() *Object {\n\tret := r.global.NumberPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.NumberPrototype = ret\n\t\to := r.newTemplatedObject(getNumberProtoTemplate(), ret)\n\t\to.class = classNumber\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getParseFloat() *Object {\n\tret := r.global.parseFloat\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.builtin_parseFloat, \"parseFloat\", 1)\n\t\tr.global.parseFloat = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getParseInt() *Object {\n\tret := r.global.parseInt\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.builtin_parseInt, \"parseInt\", 2)\n\t\tr.global.parseInt = ret\n\t}\n\treturn ret\n}\n\nfunc createNumberTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.getFunctionPrototype()\n\t}\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(1), false, false, true) })\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(asciiString(\"Number\"), false, false, true) })\n\n\tt.putStr(\"prototype\", func(r *Runtime) Value { return valueProp(r.getNumberPrototype(), false, false, false) })\n\n\tt.putStr(\"EPSILON\", func(r *Runtime) Value { return valueProp(_epsilon, false, false, false) })\n\tt.putStr(\"isFinite\", func(r *Runtime) Value { return r.methodProp(r.number_isFinite, \"isFinite\", 1) })\n\tt.putStr(\"isInteger\", func(r *Runtime) Value { return r.methodProp(r.number_isInteger, \"isInteger\", 1) })\n\tt.putStr(\"isNaN\", func(r *Runtime) Value { return r.methodProp(r.number_isNaN, \"isNaN\", 1) })\n\tt.putStr(\"isSafeInteger\", func(r *Runtime) Value { return r.methodProp(r.number_isSafeInteger, \"isSafeInteger\", 1) })\n\tt.putStr(\"MAX_SAFE_INTEGER\", func(r *Runtime) Value { return valueProp(valueInt(maxInt-1), false, false, false) })\n\tt.putStr(\"MIN_SAFE_INTEGER\", func(r *Runtime) Value { return valueProp(valueInt(-(maxInt - 1)), false, false, false) })\n\tt.putStr(\"MIN_VALUE\", func(r *Runtime) Value { return valueProp(valueFloat(math.SmallestNonzeroFloat64), false, false, false) })\n\tt.putStr(\"MAX_VALUE\", func(r *Runtime) Value { return valueProp(valueFloat(math.MaxFloat64), false, false, false) })\n\tt.putStr(\"NaN\", func(r *Runtime) Value { return valueProp(_NaN, false, false, false) })\n\tt.putStr(\"NEGATIVE_INFINITY\", func(r *Runtime) Value { return valueProp(_negativeInf, false, false, false) })\n\tt.putStr(\"parseFloat\", func(r *Runtime) Value { return valueProp(r.getParseFloat(), true, false, true) })\n\tt.putStr(\"parseInt\", func(r *Runtime) Value { return valueProp(r.getParseInt(), true, false, true) })\n\tt.putStr(\"POSITIVE_INFINITY\", func(r *Runtime) Value { return valueProp(_positiveInf, false, false, false) })\n\n\treturn t\n}\n\nvar numberTemplate *objectTemplate\nvar numberTemplateOnce sync.Once\n\nfunc getNumberTemplate() *objectTemplate {\n\tnumberTemplateOnce.Do(func() {\n\t\tnumberTemplate = createNumberTemplate()\n\t})\n\treturn numberTemplate\n}\n\nfunc (r *Runtime) getNumber() *Object {\n\tret := r.global.Number\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Number = ret\n\t\tr.newTemplatedFuncObject(getNumberTemplate(), ret, r.builtin_Number,\n\t\t\tr.wrapNativeConstruct(r.builtin_newNumber, ret, r.getNumberPrototype()))\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_object.go",
          "type": "blob",
          "size": 19.3798828125,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc (r *Runtime) builtin_Object(args []Value, newTarget *Object) *Object {\n\tif newTarget != nil && newTarget != r.getObject() {\n\t\tproto := r.getPrototypeFromCtor(newTarget, nil, r.global.ObjectPrototype)\n\t\treturn r.newBaseObject(proto, classObject).val\n\t}\n\tif len(args) > 0 {\n\t\targ := args[0]\n\t\tif arg != _undefined && arg != _null {\n\t\t\treturn arg.ToObject(r)\n\t\t}\n\t}\n\treturn r.NewObject()\n}\n\nfunc (r *Runtime) object_getPrototypeOf(call FunctionCall) Value {\n\to := call.Argument(0).ToObject(r)\n\tp := o.self.proto()\n\tif p == nil {\n\t\treturn _null\n\t}\n\treturn p\n}\n\nfunc (r *Runtime) valuePropToDescriptorObject(desc Value) Value {\n\tif desc == nil {\n\t\treturn _undefined\n\t}\n\tvar writable, configurable, enumerable, accessor bool\n\tvar get, set *Object\n\tvar value Value\n\tif v, ok := desc.(*valueProperty); ok {\n\t\twritable = v.writable\n\t\tconfigurable = v.configurable\n\t\tenumerable = v.enumerable\n\t\taccessor = v.accessor\n\t\tvalue = v.value\n\t\tget = v.getterFunc\n\t\tset = v.setterFunc\n\t} else {\n\t\twritable = true\n\t\tconfigurable = true\n\t\tenumerable = true\n\t\tvalue = desc\n\t}\n\n\tret := r.NewObject()\n\tobj := ret.self\n\tif !accessor {\n\t\tobj.setOwnStr(\"value\", value, false)\n\t\tobj.setOwnStr(\"writable\", r.toBoolean(writable), false)\n\t} else {\n\t\tif get != nil {\n\t\t\tobj.setOwnStr(\"get\", get, false)\n\t\t} else {\n\t\t\tobj.setOwnStr(\"get\", _undefined, false)\n\t\t}\n\t\tif set != nil {\n\t\t\tobj.setOwnStr(\"set\", set, false)\n\t\t} else {\n\t\t\tobj.setOwnStr(\"set\", _undefined, false)\n\t\t}\n\t}\n\tobj.setOwnStr(\"enumerable\", r.toBoolean(enumerable), false)\n\tobj.setOwnStr(\"configurable\", r.toBoolean(configurable), false)\n\n\treturn ret\n}\n\nfunc (r *Runtime) object_getOwnPropertyDescriptor(call FunctionCall) Value {\n\to := call.Argument(0).ToObject(r)\n\tpropName := toPropertyKey(call.Argument(1))\n\treturn r.valuePropToDescriptorObject(o.getOwnProp(propName))\n}\n\nfunc (r *Runtime) object_getOwnPropertyDescriptors(call FunctionCall) Value {\n\to := call.Argument(0).ToObject(r)\n\tresult := r.newBaseObject(r.global.ObjectPrototype, classObject).val\n\tfor item, next := o.self.iterateKeys()(); next != nil; item, next = next() {\n\t\tvar prop Value\n\t\tif item.value == nil {\n\t\t\tprop = o.getOwnProp(item.name)\n\t\t\tif prop == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\tprop = item.value\n\t\t}\n\t\tdescriptor := r.valuePropToDescriptorObject(prop)\n\t\tif descriptor != _undefined {\n\t\t\tcreateDataPropertyOrThrow(result, item.name, descriptor)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (r *Runtime) object_getOwnPropertyNames(call FunctionCall) Value {\n\tobj := call.Argument(0).ToObject(r)\n\n\treturn r.newArrayValues(obj.self.stringKeys(true, nil))\n}\n\nfunc (r *Runtime) object_getOwnPropertySymbols(call FunctionCall) Value {\n\tobj := call.Argument(0).ToObject(r)\n\treturn r.newArrayValues(obj.self.symbols(true, nil))\n}\n\nfunc (r *Runtime) toValueProp(v Value) *valueProperty {\n\tif v == nil || v == _undefined {\n\t\treturn nil\n\t}\n\tobj := r.toObject(v)\n\tgetter := obj.self.getStr(\"get\", nil)\n\tsetter := obj.self.getStr(\"set\", nil)\n\twritable := obj.self.getStr(\"writable\", nil)\n\tvalue := obj.self.getStr(\"value\", nil)\n\tif (getter != nil || setter != nil) && (value != nil || writable != nil) {\n\t\tr.typeErrorResult(true, \"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\")\n\t}\n\n\tret := &valueProperty{}\n\tif writable != nil && writable.ToBoolean() {\n\t\tret.writable = true\n\t}\n\tif e := obj.self.getStr(\"enumerable\", nil); e != nil && e.ToBoolean() {\n\t\tret.enumerable = true\n\t}\n\tif c := obj.self.getStr(\"configurable\", nil); c != nil && c.ToBoolean() {\n\t\tret.configurable = true\n\t}\n\tret.value = value\n\n\tif getter != nil && getter != _undefined {\n\t\to := r.toObject(getter)\n\t\tif _, ok := o.self.assertCallable(); !ok {\n\t\t\tr.typeErrorResult(true, \"getter must be a function\")\n\t\t}\n\t\tret.getterFunc = o\n\t}\n\n\tif setter != nil && setter != _undefined {\n\t\to := r.toObject(setter)\n\t\tif _, ok := o.self.assertCallable(); !ok {\n\t\t\tr.typeErrorResult(true, \"setter must be a function\")\n\t\t}\n\t\tret.setterFunc = o\n\t}\n\n\tif ret.getterFunc != nil || ret.setterFunc != nil {\n\t\tret.accessor = true\n\t}\n\n\treturn ret\n}\n\nfunc (r *Runtime) toPropertyDescriptor(v Value) (ret PropertyDescriptor) {\n\tif o, ok := v.(*Object); ok {\n\t\tdescr := o.self\n\n\t\t// Save the original descriptor for reference\n\t\tret.jsDescriptor = o\n\n\t\tret.Value = descr.getStr(\"value\", nil)\n\n\t\tif p := descr.getStr(\"writable\", nil); p != nil {\n\t\t\tret.Writable = ToFlag(p.ToBoolean())\n\t\t}\n\t\tif p := descr.getStr(\"enumerable\", nil); p != nil {\n\t\t\tret.Enumerable = ToFlag(p.ToBoolean())\n\t\t}\n\t\tif p := descr.getStr(\"configurable\", nil); p != nil {\n\t\t\tret.Configurable = ToFlag(p.ToBoolean())\n\t\t}\n\n\t\tret.Getter = descr.getStr(\"get\", nil)\n\t\tret.Setter = descr.getStr(\"set\", nil)\n\n\t\tif ret.Getter != nil && ret.Getter != _undefined {\n\t\t\tif _, ok := r.toObject(ret.Getter).self.assertCallable(); !ok {\n\t\t\t\tr.typeErrorResult(true, \"getter must be a function\")\n\t\t\t}\n\t\t}\n\n\t\tif ret.Setter != nil && ret.Setter != _undefined {\n\t\t\tif _, ok := r.toObject(ret.Setter).self.assertCallable(); !ok {\n\t\t\t\tr.typeErrorResult(true, \"setter must be a function\")\n\t\t\t}\n\t\t}\n\n\t\tif (ret.Getter != nil || ret.Setter != nil) && (ret.Value != nil || ret.Writable != FLAG_NOT_SET) {\n\t\t\tr.typeErrorResult(true, \"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\")\n\t\t}\n\t} else {\n\t\tr.typeErrorResult(true, \"Property description must be an object: %s\", v.String())\n\t}\n\n\treturn\n}\n\nfunc (r *Runtime) _defineProperties(o *Object, p Value) {\n\ttype propItem struct {\n\t\tname Value\n\t\tprop PropertyDescriptor\n\t}\n\tprops := p.ToObject(r)\n\tvar list []propItem\n\tfor item, next := iterateEnumerableProperties(props)(); next != nil; item, next = next() {\n\t\tlist = append(list, propItem{\n\t\t\tname: item.name,\n\t\t\tprop: r.toPropertyDescriptor(item.value),\n\t\t})\n\t}\n\tfor _, prop := range list {\n\t\to.defineOwnProperty(prop.name, prop.prop, true)\n\t}\n}\n\nfunc (r *Runtime) object_create(call FunctionCall) Value {\n\tvar proto *Object\n\tif arg := call.Argument(0); arg != _null {\n\t\tif o, ok := arg.(*Object); ok {\n\t\t\tproto = o\n\t\t} else {\n\t\t\tr.typeErrorResult(true, \"Object prototype may only be an Object or null: %s\", arg.String())\n\t\t}\n\t}\n\to := r.newBaseObject(proto, classObject).val\n\n\tif props := call.Argument(1); props != _undefined {\n\t\tr._defineProperties(o, props)\n\t}\n\n\treturn o\n}\n\nfunc (r *Runtime) object_defineProperty(call FunctionCall) (ret Value) {\n\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\tdescr := r.toPropertyDescriptor(call.Argument(2))\n\t\tobj.defineOwnProperty(toPropertyKey(call.Argument(1)), descr, true)\n\t\tret = call.Argument(0)\n\t} else {\n\t\tr.typeErrorResult(true, \"Object.defineProperty called on non-object\")\n\t}\n\treturn\n}\n\nfunc (r *Runtime) object_defineProperties(call FunctionCall) Value {\n\tobj := r.toObject(call.Argument(0))\n\tr._defineProperties(obj, call.Argument(1))\n\treturn obj\n}\n\nfunc (r *Runtime) object_seal(call FunctionCall) Value {\n\t// ES6\n\targ := call.Argument(0)\n\tif obj, ok := arg.(*Object); ok {\n\t\tobj.self.preventExtensions(true)\n\t\tdescr := PropertyDescriptor{\n\t\t\tConfigurable: FLAG_FALSE,\n\t\t}\n\n\t\tfor item, next := obj.self.iterateKeys()(); next != nil; item, next = next() {\n\t\t\tif prop, ok := item.value.(*valueProperty); ok {\n\t\t\t\tprop.configurable = false\n\t\t\t} else {\n\t\t\t\tobj.defineOwnProperty(item.name, descr, true)\n\t\t\t}\n\t\t}\n\n\t\treturn obj\n\t}\n\treturn arg\n}\n\nfunc (r *Runtime) object_freeze(call FunctionCall) Value {\n\targ := call.Argument(0)\n\tif obj, ok := arg.(*Object); ok {\n\t\tobj.self.preventExtensions(true)\n\n\t\tfor item, next := obj.self.iterateKeys()(); next != nil; item, next = next() {\n\t\t\tif prop, ok := item.value.(*valueProperty); ok {\n\t\t\t\tprop.configurable = false\n\t\t\t\tif !prop.accessor {\n\t\t\t\t\tprop.writable = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprop := obj.getOwnProp(item.name)\n\t\t\t\tdescr := PropertyDescriptor{\n\t\t\t\t\tConfigurable: FLAG_FALSE,\n\t\t\t\t}\n\t\t\t\tif prop, ok := prop.(*valueProperty); ok && prop.accessor {\n\t\t\t\t\t// no-op\n\t\t\t\t} else {\n\t\t\t\t\tdescr.Writable = FLAG_FALSE\n\t\t\t\t}\n\t\t\t\tobj.defineOwnProperty(item.name, descr, true)\n\t\t\t}\n\t\t}\n\t\treturn obj\n\t} else {\n\t\t// ES6 behavior\n\t\treturn arg\n\t}\n}\n\nfunc (r *Runtime) object_preventExtensions(call FunctionCall) (ret Value) {\n\targ := call.Argument(0)\n\tif obj, ok := arg.(*Object); ok {\n\t\tobj.self.preventExtensions(true)\n\t}\n\treturn arg\n}\n\nfunc (r *Runtime) object_isSealed(call FunctionCall) Value {\n\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\tif obj.self.isExtensible() {\n\t\t\treturn valueFalse\n\t\t}\n\t\tfor item, next := obj.self.iterateKeys()(); next != nil; item, next = next() {\n\t\t\tvar prop Value\n\t\t\tif item.value == nil {\n\t\t\t\tprop = obj.getOwnProp(item.name)\n\t\t\t\tif prop == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprop = item.value\n\t\t\t}\n\t\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\t\tif prop.configurable {\n\t\t\t\t\treturn valueFalse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn valueFalse\n\t\t\t}\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) object_isFrozen(call FunctionCall) Value {\n\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\tif obj.self.isExtensible() {\n\t\t\treturn valueFalse\n\t\t}\n\t\tfor item, next := obj.self.iterateKeys()(); next != nil; item, next = next() {\n\t\t\tvar prop Value\n\t\t\tif item.value == nil {\n\t\t\t\tprop = obj.getOwnProp(item.name)\n\t\t\t\tif prop == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprop = item.value\n\t\t\t}\n\t\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\t\tif prop.configurable || prop.value != nil && prop.writable {\n\t\t\t\t\treturn valueFalse\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn valueFalse\n\t\t\t}\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) object_isExtensible(call FunctionCall) Value {\n\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\tif obj.self.isExtensible() {\n\t\t\treturn valueTrue\n\t\t}\n\t\treturn valueFalse\n\t} else {\n\t\t// ES6\n\t\t//r.typeErrorResult(true, \"Object.isExtensible called on non-object\")\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) object_keys(call FunctionCall) Value {\n\tobj := call.Argument(0).ToObject(r)\n\n\treturn r.newArrayValues(obj.self.stringKeys(false, nil))\n}\n\nfunc (r *Runtime) object_entries(call FunctionCall) Value {\n\tobj := call.Argument(0).ToObject(r)\n\n\tvar values []Value\n\n\tfor item, next := iterateEnumerableStringProperties(obj)(); next != nil; item, next = next() {\n\t\tvalues = append(values, r.newArrayValues([]Value{item.name, item.value}))\n\t}\n\n\treturn r.newArrayValues(values)\n}\n\nfunc (r *Runtime) object_values(call FunctionCall) Value {\n\tobj := call.Argument(0).ToObject(r)\n\n\tvar values []Value\n\n\tfor item, next := iterateEnumerableStringProperties(obj)(); next != nil; item, next = next() {\n\t\tvalues = append(values, item.value)\n\t}\n\n\treturn r.newArrayValues(values)\n}\n\nfunc (r *Runtime) objectproto_hasOwnProperty(call FunctionCall) Value {\n\tp := toPropertyKey(call.Argument(0))\n\to := call.This.ToObject(r)\n\tif o.hasOwnProperty(p) {\n\t\treturn valueTrue\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) objectproto_isPrototypeOf(call FunctionCall) Value {\n\tif v, ok := call.Argument(0).(*Object); ok {\n\t\to := call.This.ToObject(r)\n\t\tfor {\n\t\t\tv = v.self.proto()\n\t\t\tif v == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif v == o {\n\t\t\t\treturn valueTrue\n\t\t\t}\n\t\t}\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) objectproto_propertyIsEnumerable(call FunctionCall) Value {\n\tp := toPropertyKey(call.Argument(0))\n\to := call.This.ToObject(r)\n\tpv := o.getOwnProp(p)\n\tif pv == nil {\n\t\treturn valueFalse\n\t}\n\tif prop, ok := pv.(*valueProperty); ok {\n\t\tif !prop.enumerable {\n\t\t\treturn valueFalse\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) objectproto_toString(call FunctionCall) Value {\n\tswitch o := call.This.(type) {\n\tcase valueNull:\n\t\treturn stringObjectNull\n\tcase valueUndefined:\n\t\treturn stringObjectUndefined\n\tdefault:\n\t\tobj := o.ToObject(r)\n\t\tif o, ok := obj.self.(*objectGoReflect); ok {\n\t\t\tif toString := o.toString; toString != nil {\n\t\t\t\treturn toString()\n\t\t\t}\n\t\t}\n\t\tvar clsName string\n\t\tif isArray(obj) {\n\t\t\tclsName = classArray\n\t\t} else {\n\t\t\tclsName = obj.self.className()\n\t\t}\n\t\tif tag := obj.self.getSym(SymToStringTag, nil); tag != nil {\n\t\t\tif str, ok := tag.(String); ok {\n\t\t\t\tclsName = str.String()\n\t\t\t}\n\t\t}\n\t\treturn newStringValue(fmt.Sprintf(\"[object %s]\", clsName))\n\t}\n}\n\nfunc (r *Runtime) objectproto_toLocaleString(call FunctionCall) Value {\n\ttoString := toMethod(r.getVStr(call.This, \"toString\"))\n\treturn toString(FunctionCall{This: call.This})\n}\n\nfunc (r *Runtime) objectproto_getProto(call FunctionCall) Value {\n\tproto := call.This.ToObject(r).self.proto()\n\tif proto != nil {\n\t\treturn proto\n\t}\n\treturn _null\n}\n\nfunc (r *Runtime) setObjectProto(o, arg Value) {\n\tr.checkObjectCoercible(o)\n\tvar proto *Object\n\tif arg != _null {\n\t\tif obj, ok := arg.(*Object); ok {\n\t\t\tproto = obj\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n\tif o, ok := o.(*Object); ok {\n\t\to.self.setProto(proto, true)\n\t}\n}\n\nfunc (r *Runtime) objectproto_setProto(call FunctionCall) Value {\n\tr.setObjectProto(call.This, call.Argument(0))\n\treturn _undefined\n}\n\nfunc (r *Runtime) objectproto_valueOf(call FunctionCall) Value {\n\treturn call.This.ToObject(r)\n}\n\nfunc (r *Runtime) object_assign(call FunctionCall) Value {\n\tto := call.Argument(0).ToObject(r)\n\tif len(call.Arguments) > 1 {\n\t\tfor _, arg := range call.Arguments[1:] {\n\t\t\tif arg != _undefined && arg != _null {\n\t\t\t\tsource := arg.ToObject(r)\n\t\t\t\tfor item, next := iterateEnumerableProperties(source)(); next != nil; item, next = next() {\n\t\t\t\t\tto.setOwn(item.name, item.value, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to\n}\n\nfunc (r *Runtime) object_is(call FunctionCall) Value {\n\treturn r.toBoolean(call.Argument(0).SameAs(call.Argument(1)))\n}\n\nfunc (r *Runtime) toProto(proto Value) *Object {\n\tif proto != _null {\n\t\tif obj, ok := proto.(*Object); ok {\n\t\t\treturn obj\n\t\t} else {\n\t\t\tpanic(r.NewTypeError(\"Object prototype may only be an Object or null: %s\", proto))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (r *Runtime) object_setPrototypeOf(call FunctionCall) Value {\n\to := call.Argument(0)\n\tr.checkObjectCoercible(o)\n\tproto := r.toProto(call.Argument(1))\n\tif o, ok := o.(*Object); ok {\n\t\to.self.setProto(proto, true)\n\t}\n\n\treturn o\n}\n\nfunc (r *Runtime) object_fromEntries(call FunctionCall) Value {\n\to := call.Argument(0)\n\tr.checkObjectCoercible(o)\n\n\tresult := r.newBaseObject(r.global.ObjectPrototype, classObject).val\n\n\titer := r.getIterator(o, nil)\n\titer.iterate(func(nextValue Value) {\n\t\ti0 := valueInt(0)\n\t\ti1 := valueInt(1)\n\n\t\titemObj := r.toObject(nextValue)\n\t\tk := itemObj.self.getIdx(i0, nil)\n\t\tv := itemObj.self.getIdx(i1, nil)\n\t\tkey := toPropertyKey(k)\n\n\t\tcreateDataPropertyOrThrow(result, key, v)\n\t})\n\n\treturn result\n}\n\nfunc (r *Runtime) object_hasOwn(call FunctionCall) Value {\n\to := call.Argument(0)\n\tobj := o.ToObject(r)\n\tp := toPropertyKey(call.Argument(1))\n\n\tif obj.hasOwnProperty(p) {\n\t\treturn valueTrue\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\nfunc createObjectTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.getFunctionPrototype()\n\t}\n\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(1), false, false, true) })\n\tt.putStr(\"name\", func(r *Runtime) Value { return valueProp(asciiString(\"Object\"), false, false, true) })\n\n\tt.putStr(\"prototype\", func(r *Runtime) Value { return valueProp(r.global.ObjectPrototype, false, false, false) })\n\n\tt.putStr(\"assign\", func(r *Runtime) Value { return r.methodProp(r.object_assign, \"assign\", 2) })\n\tt.putStr(\"defineProperty\", func(r *Runtime) Value { return r.methodProp(r.object_defineProperty, \"defineProperty\", 3) })\n\tt.putStr(\"defineProperties\", func(r *Runtime) Value { return r.methodProp(r.object_defineProperties, \"defineProperties\", 2) })\n\tt.putStr(\"entries\", func(r *Runtime) Value { return r.methodProp(r.object_entries, \"entries\", 1) })\n\tt.putStr(\"getOwnPropertyDescriptor\", func(r *Runtime) Value {\n\t\treturn r.methodProp(r.object_getOwnPropertyDescriptor, \"getOwnPropertyDescriptor\", 2)\n\t})\n\tt.putStr(\"getOwnPropertyDescriptors\", func(r *Runtime) Value {\n\t\treturn r.methodProp(r.object_getOwnPropertyDescriptors, \"getOwnPropertyDescriptors\", 1)\n\t})\n\tt.putStr(\"getPrototypeOf\", func(r *Runtime) Value { return r.methodProp(r.object_getPrototypeOf, \"getPrototypeOf\", 1) })\n\tt.putStr(\"is\", func(r *Runtime) Value { return r.methodProp(r.object_is, \"is\", 2) })\n\tt.putStr(\"getOwnPropertyNames\", func(r *Runtime) Value { return r.methodProp(r.object_getOwnPropertyNames, \"getOwnPropertyNames\", 1) })\n\tt.putStr(\"getOwnPropertySymbols\", func(r *Runtime) Value {\n\t\treturn r.methodProp(r.object_getOwnPropertySymbols, \"getOwnPropertySymbols\", 1)\n\t})\n\tt.putStr(\"create\", func(r *Runtime) Value { return r.methodProp(r.object_create, \"create\", 2) })\n\tt.putStr(\"seal\", func(r *Runtime) Value { return r.methodProp(r.object_seal, \"seal\", 1) })\n\tt.putStr(\"freeze\", func(r *Runtime) Value { return r.methodProp(r.object_freeze, \"freeze\", 1) })\n\tt.putStr(\"preventExtensions\", func(r *Runtime) Value { return r.methodProp(r.object_preventExtensions, \"preventExtensions\", 1) })\n\tt.putStr(\"isSealed\", func(r *Runtime) Value { return r.methodProp(r.object_isSealed, \"isSealed\", 1) })\n\tt.putStr(\"isFrozen\", func(r *Runtime) Value { return r.methodProp(r.object_isFrozen, \"isFrozen\", 1) })\n\tt.putStr(\"isExtensible\", func(r *Runtime) Value { return r.methodProp(r.object_isExtensible, \"isExtensible\", 1) })\n\tt.putStr(\"keys\", func(r *Runtime) Value { return r.methodProp(r.object_keys, \"keys\", 1) })\n\tt.putStr(\"setPrototypeOf\", func(r *Runtime) Value { return r.methodProp(r.object_setPrototypeOf, \"setPrototypeOf\", 2) })\n\tt.putStr(\"values\", func(r *Runtime) Value { return r.methodProp(r.object_values, \"values\", 1) })\n\tt.putStr(\"fromEntries\", func(r *Runtime) Value { return r.methodProp(r.object_fromEntries, \"fromEntries\", 1) })\n\tt.putStr(\"hasOwn\", func(r *Runtime) Value { return r.methodProp(r.object_hasOwn, \"hasOwn\", 2) })\n\n\treturn t\n}\n\nvar _objectTemplate *objectTemplate\nvar objectTemplateOnce sync.Once\n\nfunc getObjectTemplate() *objectTemplate {\n\tobjectTemplateOnce.Do(func() {\n\t\t_objectTemplate = createObjectTemplate()\n\t})\n\treturn _objectTemplate\n}\n\nfunc (r *Runtime) getObject() *Object {\n\tret := r.global.Object\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Object = ret\n\t\tr.newTemplatedFuncObject(getObjectTemplate(), ret, func(call FunctionCall) Value {\n\t\t\treturn r.builtin_Object(call.Arguments, nil)\n\t\t}, r.builtin_Object)\n\t}\n\treturn ret\n}\n\n/*\nfunc (r *Runtime) getObjectPrototype() *Object {\n\tret := r.global.ObjectPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.ObjectPrototype = ret\n\t\tr.newTemplatedObject(getObjectProtoTemplate(), ret)\n\t}\n\treturn ret\n}\n*/\n\nvar objectProtoTemplate *objectTemplate\nvar objectProtoTemplateOnce sync.Once\n\nfunc getObjectProtoTemplate() *objectTemplate {\n\tobjectProtoTemplateOnce.Do(func() {\n\t\tobjectProtoTemplate = createObjectProtoTemplate()\n\t})\n\treturn objectProtoTemplate\n}\n\nfunc createObjectProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\n\t// null prototype\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getObject(), true, false, true) })\n\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.objectproto_toString, \"toString\", 0) })\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.objectproto_toLocaleString, \"toLocaleString\", 0) })\n\tt.putStr(\"valueOf\", func(r *Runtime) Value { return r.methodProp(r.objectproto_valueOf, \"valueOf\", 0) })\n\tt.putStr(\"hasOwnProperty\", func(r *Runtime) Value { return r.methodProp(r.objectproto_hasOwnProperty, \"hasOwnProperty\", 1) })\n\tt.putStr(\"isPrototypeOf\", func(r *Runtime) Value { return r.methodProp(r.objectproto_isPrototypeOf, \"isPrototypeOf\", 1) })\n\tt.putStr(\"propertyIsEnumerable\", func(r *Runtime) Value {\n\t\treturn r.methodProp(r.objectproto_propertyIsEnumerable, \"propertyIsEnumerable\", 1)\n\t})\n\tt.putStr(__proto__, func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.objectproto_getProto, \"get __proto__\", 0),\n\t\t\tsetterFunc:   r.newNativeFunc(r.objectproto_setProto, \"set __proto__\", 1),\n\t\t\tconfigurable: true,\n\t\t}\n\t})\n\n\treturn t\n}\n"
        },
        {
          "name": "builtin_promise.go",
          "type": "blob",
          "size": 19.333984375,
          "content": "package goja\n\nimport (\n\t\"github.com/dop251/goja/unistring\"\n\t\"reflect\"\n)\n\ntype PromiseState int\ntype PromiseRejectionOperation int\n\ntype promiseReactionType int\n\nconst (\n\tPromiseStatePending PromiseState = iota\n\tPromiseStateFulfilled\n\tPromiseStateRejected\n)\n\nconst (\n\tPromiseRejectionReject PromiseRejectionOperation = iota\n\tPromiseRejectionHandle\n)\n\nconst (\n\tpromiseReactionFulfill promiseReactionType = iota\n\tpromiseReactionReject\n)\n\ntype PromiseRejectionTracker func(p *Promise, operation PromiseRejectionOperation)\n\ntype jobCallback struct {\n\tcallback func(FunctionCall) Value\n}\n\ntype promiseCapability struct {\n\tpromise               *Object\n\tresolveObj, rejectObj *Object\n}\n\ntype promiseReaction struct {\n\tcapability  *promiseCapability\n\ttyp         promiseReactionType\n\thandler     *jobCallback\n\tasyncRunner *asyncRunner\n\tasyncCtx    interface{}\n}\n\nvar typePromise = reflect.TypeOf((*Promise)(nil))\n\n// Promise is a Go wrapper around ECMAScript Promise. Calling Runtime.ToValue() on it\n// returns the underlying Object. Calling Export() on a Promise Object returns a Promise.\n//\n// Use Runtime.NewPromise() to create one. Calling Runtime.ToValue() on a zero object or nil returns null Value.\n//\n// WARNING: Instances of Promise are not goroutine-safe. See Runtime.NewPromise() for more details.\ntype Promise struct {\n\tbaseObject\n\tstate            PromiseState\n\tresult           Value\n\tfulfillReactions []*promiseReaction\n\trejectReactions  []*promiseReaction\n\thandled          bool\n}\n\nfunc (p *Promise) State() PromiseState {\n\treturn p.state\n}\n\nfunc (p *Promise) Result() Value {\n\treturn p.result\n}\n\nfunc (p *Promise) toValue(r *Runtime) Value {\n\tif p == nil || p.val == nil {\n\t\treturn _null\n\t}\n\tpromise := p.val\n\tif promise.runtime != r {\n\t\tpanic(r.NewTypeError(\"Illegal runtime transition of a Promise\"))\n\t}\n\treturn promise\n}\n\nfunc (p *Promise) createResolvingFunctions() (resolve, reject *Object) {\n\tr := p.val.runtime\n\talreadyResolved := false\n\treturn p.val.runtime.newNativeFunc(func(call FunctionCall) Value {\n\t\t\tif alreadyResolved {\n\t\t\t\treturn _undefined\n\t\t\t}\n\t\t\talreadyResolved = true\n\t\t\tresolution := call.Argument(0)\n\t\t\tif resolution.SameAs(p.val) {\n\t\t\t\treturn p.reject(r.NewTypeError(\"Promise self-resolution\"))\n\t\t\t}\n\t\t\tif obj, ok := resolution.(*Object); ok {\n\t\t\t\tvar thenAction Value\n\t\t\t\tex := r.vm.try(func() {\n\t\t\t\t\tthenAction = obj.self.getStr(\"then\", nil)\n\t\t\t\t})\n\t\t\t\tif ex != nil {\n\t\t\t\t\treturn p.reject(ex.val)\n\t\t\t\t}\n\t\t\t\tif call, ok := assertCallable(thenAction); ok {\n\t\t\t\t\tjob := r.newPromiseResolveThenableJob(p, resolution, &jobCallback{callback: call})\n\t\t\t\t\tr.enqueuePromiseJob(job)\n\t\t\t\t\treturn _undefined\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn p.fulfill(resolution)\n\t\t}, \"\", 1),\n\t\tp.val.runtime.newNativeFunc(func(call FunctionCall) Value {\n\t\t\tif alreadyResolved {\n\t\t\t\treturn _undefined\n\t\t\t}\n\t\t\talreadyResolved = true\n\t\t\treason := call.Argument(0)\n\t\t\treturn p.reject(reason)\n\t\t}, \"\", 1)\n}\n\nfunc (p *Promise) reject(reason Value) Value {\n\treactions := p.rejectReactions\n\tp.result = reason\n\tp.fulfillReactions, p.rejectReactions = nil, nil\n\tp.state = PromiseStateRejected\n\tr := p.val.runtime\n\tif !p.handled {\n\t\tr.trackPromiseRejection(p, PromiseRejectionReject)\n\t}\n\tr.triggerPromiseReactions(reactions, reason)\n\treturn _undefined\n}\n\nfunc (p *Promise) fulfill(value Value) Value {\n\treactions := p.fulfillReactions\n\tp.result = value\n\tp.fulfillReactions, p.rejectReactions = nil, nil\n\tp.state = PromiseStateFulfilled\n\tp.val.runtime.triggerPromiseReactions(reactions, value)\n\treturn _undefined\n}\n\nfunc (p *Promise) exportType() reflect.Type {\n\treturn typePromise\n}\n\nfunc (p *Promise) export(*objectExportCtx) interface{} {\n\treturn p\n}\n\nfunc (p *Promise) addReactions(fulfillReaction *promiseReaction, rejectReaction *promiseReaction) {\n\tr := p.val.runtime\n\tif tracker := r.asyncContextTracker; tracker != nil {\n\t\tctx := tracker.Grab()\n\t\tfulfillReaction.asyncCtx = ctx\n\t\trejectReaction.asyncCtx = ctx\n\t}\n\tswitch p.state {\n\tcase PromiseStatePending:\n\t\tp.fulfillReactions = append(p.fulfillReactions, fulfillReaction)\n\t\tp.rejectReactions = append(p.rejectReactions, rejectReaction)\n\tcase PromiseStateFulfilled:\n\t\tr.enqueuePromiseJob(r.newPromiseReactionJob(fulfillReaction, p.result))\n\tdefault:\n\t\treason := p.result\n\t\tif !p.handled {\n\t\t\tr.trackPromiseRejection(p, PromiseRejectionHandle)\n\t\t}\n\t\tr.enqueuePromiseJob(r.newPromiseReactionJob(rejectReaction, reason))\n\t}\n\tp.handled = true\n}\n\nfunc (r *Runtime) newPromiseResolveThenableJob(p *Promise, thenable Value, then *jobCallback) func() {\n\treturn func() {\n\t\tresolve, reject := p.createResolvingFunctions()\n\t\tex := r.vm.try(func() {\n\t\t\tr.callJobCallback(then, thenable, resolve, reject)\n\t\t})\n\t\tif ex != nil {\n\t\t\tif fn, ok := reject.self.assertCallable(); ok {\n\t\t\t\tfn(FunctionCall{Arguments: []Value{ex.val}})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) enqueuePromiseJob(job func()) {\n\tr.jobQueue = append(r.jobQueue, job)\n}\n\nfunc (r *Runtime) triggerPromiseReactions(reactions []*promiseReaction, argument Value) {\n\tfor _, reaction := range reactions {\n\t\tr.enqueuePromiseJob(r.newPromiseReactionJob(reaction, argument))\n\t}\n}\n\nfunc (r *Runtime) newPromiseReactionJob(reaction *promiseReaction, argument Value) func() {\n\treturn func() {\n\t\tvar handlerResult Value\n\t\tfulfill := false\n\t\tif reaction.handler == nil {\n\t\t\thandlerResult = argument\n\t\t\tif reaction.typ == promiseReactionFulfill {\n\t\t\t\tfulfill = true\n\t\t\t}\n\t\t} else {\n\t\t\tif tracker := r.asyncContextTracker; tracker != nil {\n\t\t\t\ttracker.Resumed(reaction.asyncCtx)\n\t\t\t}\n\t\t\tex := r.vm.try(func() {\n\t\t\t\thandlerResult = r.callJobCallback(reaction.handler, _undefined, argument)\n\t\t\t\tfulfill = true\n\t\t\t})\n\t\t\tif ex != nil {\n\t\t\t\thandlerResult = ex.val\n\t\t\t}\n\t\t\tif tracker := r.asyncContextTracker; tracker != nil {\n\t\t\t\ttracker.Exited()\n\t\t\t}\n\t\t}\n\t\tif reaction.capability != nil {\n\t\t\tif fulfill {\n\t\t\t\treaction.capability.resolve(handlerResult)\n\t\t\t} else {\n\t\t\t\treaction.capability.reject(handlerResult)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) newPromise(proto *Object) *Promise {\n\to := &Object{runtime: r}\n\n\tpo := &Promise{}\n\tpo.class = classObject\n\tpo.val = o\n\tpo.extensible = true\n\to.self = po\n\tpo.prototype = proto\n\tpo.init()\n\treturn po\n}\n\nfunc (r *Runtime) builtin_newPromise(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"Promise\"))\n\t}\n\tvar arg0 Value\n\tif len(args) > 0 {\n\t\targ0 = args[0]\n\t}\n\texecutor := r.toCallable(arg0)\n\n\tproto := r.getPrototypeFromCtor(newTarget, r.global.Promise, r.getPromisePrototype())\n\tpo := r.newPromise(proto)\n\n\tresolve, reject := po.createResolvingFunctions()\n\tex := r.vm.try(func() {\n\t\texecutor(FunctionCall{Arguments: []Value{resolve, reject}})\n\t})\n\tif ex != nil {\n\t\tif fn, ok := reject.self.assertCallable(); ok {\n\t\t\tfn(FunctionCall{Arguments: []Value{ex.val}})\n\t\t}\n\t}\n\treturn po.val\n}\n\nfunc (r *Runtime) promiseProto_then(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif p, ok := thisObj.self.(*Promise); ok {\n\t\tc := r.speciesConstructorObj(thisObj, r.getPromise())\n\t\tresultCapability := r.newPromiseCapability(c)\n\t\treturn r.performPromiseThen(p, call.Argument(0), call.Argument(1), resultCapability)\n\t}\n\tpanic(r.NewTypeError(\"Method Promise.prototype.then called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc (r *Runtime) newPromiseCapability(c *Object) *promiseCapability {\n\tpcap := new(promiseCapability)\n\tif c == r.getPromise() {\n\t\tp := r.newPromise(r.getPromisePrototype())\n\t\tpcap.resolveObj, pcap.rejectObj = p.createResolvingFunctions()\n\t\tpcap.promise = p.val\n\t} else {\n\t\tvar resolve, reject Value\n\t\texecutor := r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\tif resolve != nil {\n\t\t\t\tpanic(r.NewTypeError(\"resolve is already set\"))\n\t\t\t}\n\t\t\tif reject != nil {\n\t\t\t\tpanic(r.NewTypeError(\"reject is already set\"))\n\t\t\t}\n\t\t\tif arg := call.Argument(0); arg != _undefined {\n\t\t\t\tresolve = arg\n\t\t\t}\n\t\t\tif arg := call.Argument(1); arg != _undefined {\n\t\t\t\treject = arg\n\t\t\t}\n\t\t\treturn nil\n\t\t}, \"\", 2)\n\t\tpcap.promise = r.toConstructor(c)([]Value{executor}, c)\n\t\tpcap.resolveObj = r.toObject(resolve)\n\t\tr.toCallable(pcap.resolveObj) // make sure it's callable\n\t\tpcap.rejectObj = r.toObject(reject)\n\t\tr.toCallable(pcap.rejectObj)\n\t}\n\treturn pcap\n}\n\nfunc (r *Runtime) performPromiseThen(p *Promise, onFulfilled, onRejected Value, resultCapability *promiseCapability) Value {\n\tvar onFulfilledJobCallback, onRejectedJobCallback *jobCallback\n\tif f, ok := assertCallable(onFulfilled); ok {\n\t\tonFulfilledJobCallback = &jobCallback{callback: f}\n\t}\n\tif f, ok := assertCallable(onRejected); ok {\n\t\tonRejectedJobCallback = &jobCallback{callback: f}\n\t}\n\tfulfillReaction := &promiseReaction{\n\t\tcapability: resultCapability,\n\t\ttyp:        promiseReactionFulfill,\n\t\thandler:    onFulfilledJobCallback,\n\t}\n\trejectReaction := &promiseReaction{\n\t\tcapability: resultCapability,\n\t\ttyp:        promiseReactionReject,\n\t\thandler:    onRejectedJobCallback,\n\t}\n\tp.addReactions(fulfillReaction, rejectReaction)\n\tif resultCapability == nil {\n\t\treturn _undefined\n\t}\n\treturn resultCapability.promise\n}\n\nfunc (r *Runtime) promiseProto_catch(call FunctionCall) Value {\n\treturn r.invoke(call.This, \"then\", _undefined, call.Argument(0))\n}\n\nfunc (r *Runtime) promiseResolve(c *Object, x Value) *Object {\n\tif obj, ok := x.(*Object); ok {\n\t\txConstructor := nilSafe(obj.self.getStr(\"constructor\", nil))\n\t\tif xConstructor.SameAs(c) {\n\t\t\treturn obj\n\t\t}\n\t}\n\tpcap := r.newPromiseCapability(c)\n\tpcap.resolve(x)\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promiseProto_finally(call FunctionCall) Value {\n\tpromise := r.toObject(call.This)\n\tc := r.speciesConstructorObj(promise, r.getPromise())\n\tonFinally := call.Argument(0)\n\tvar thenFinally, catchFinally Value\n\tif onFinallyFn, ok := assertCallable(onFinally); !ok {\n\t\tthenFinally, catchFinally = onFinally, onFinally\n\t} else {\n\t\tthenFinally = r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\tvalue := call.Argument(0)\n\t\t\tresult := onFinallyFn(FunctionCall{})\n\t\t\tpromise := r.promiseResolve(c, result)\n\t\t\tvalueThunk := r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\t\treturn value\n\t\t\t}, \"\", 0)\n\t\t\treturn r.invoke(promise, \"then\", valueThunk)\n\t\t}, \"\", 1)\n\n\t\tcatchFinally = r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\treason := call.Argument(0)\n\t\t\tresult := onFinallyFn(FunctionCall{})\n\t\t\tpromise := r.promiseResolve(c, result)\n\t\t\tthrower := r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\t\tpanic(reason)\n\t\t\t}, \"\", 0)\n\t\t\treturn r.invoke(promise, \"then\", thrower)\n\t\t}, \"\", 1)\n\t}\n\treturn r.invoke(promise, \"then\", thenFinally, catchFinally)\n}\n\nfunc (pcap *promiseCapability) resolve(result Value) {\n\tpcap.promise.runtime.toCallable(pcap.resolveObj)(FunctionCall{Arguments: []Value{result}})\n}\n\nfunc (pcap *promiseCapability) reject(reason Value) {\n\tpcap.promise.runtime.toCallable(pcap.rejectObj)(FunctionCall{Arguments: []Value{reason}})\n}\n\nfunc (pcap *promiseCapability) try(f func()) bool {\n\tex := pcap.promise.runtime.vm.try(f)\n\tif ex != nil {\n\t\tpcap.reject(ex.val)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (r *Runtime) promise_all(call FunctionCall) Value {\n\tc := r.toObject(call.This)\n\tpcap := r.newPromiseCapability(c)\n\n\tpcap.try(func() {\n\t\tpromiseResolve := r.toCallable(c.self.getStr(\"resolve\", nil))\n\t\titer := r.getIterator(call.Argument(0), nil)\n\t\tvar values []Value\n\t\tremainingElementsCount := 1\n\t\titer.iterate(func(nextValue Value) {\n\t\t\tindex := len(values)\n\t\t\tvalues = append(values, _undefined)\n\t\t\tnextPromise := promiseResolve(FunctionCall{This: c, Arguments: []Value{nextValue}})\n\t\t\talreadyCalled := false\n\t\t\tonFulfilled := r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\t\tif alreadyCalled {\n\t\t\t\t\treturn _undefined\n\t\t\t\t}\n\t\t\t\talreadyCalled = true\n\t\t\t\tvalues[index] = call.Argument(0)\n\t\t\t\tremainingElementsCount--\n\t\t\t\tif remainingElementsCount == 0 {\n\t\t\t\t\tpcap.resolve(r.newArrayValues(values))\n\t\t\t\t}\n\t\t\t\treturn _undefined\n\t\t\t}, \"\", 1)\n\t\t\tremainingElementsCount++\n\t\t\tr.invoke(nextPromise, \"then\", onFulfilled, pcap.rejectObj)\n\t\t})\n\t\tremainingElementsCount--\n\t\tif remainingElementsCount == 0 {\n\t\t\tpcap.resolve(r.newArrayValues(values))\n\t\t}\n\t})\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promise_allSettled(call FunctionCall) Value {\n\tc := r.toObject(call.This)\n\tpcap := r.newPromiseCapability(c)\n\n\tpcap.try(func() {\n\t\tpromiseResolve := r.toCallable(c.self.getStr(\"resolve\", nil))\n\t\titer := r.getIterator(call.Argument(0), nil)\n\t\tvar values []Value\n\t\tremainingElementsCount := 1\n\t\titer.iterate(func(nextValue Value) {\n\t\t\tindex := len(values)\n\t\t\tvalues = append(values, _undefined)\n\t\t\tnextPromise := promiseResolve(FunctionCall{This: c, Arguments: []Value{nextValue}})\n\t\t\talreadyCalled := false\n\t\t\treaction := func(status Value, valueKey unistring.String) *Object {\n\t\t\t\treturn r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\t\t\tif alreadyCalled {\n\t\t\t\t\t\treturn _undefined\n\t\t\t\t\t}\n\t\t\t\t\talreadyCalled = true\n\t\t\t\t\tobj := r.NewObject()\n\t\t\t\t\tobj.self._putProp(\"status\", status, true, true, true)\n\t\t\t\t\tobj.self._putProp(valueKey, call.Argument(0), true, true, true)\n\t\t\t\t\tvalues[index] = obj\n\t\t\t\t\tremainingElementsCount--\n\t\t\t\t\tif remainingElementsCount == 0 {\n\t\t\t\t\t\tpcap.resolve(r.newArrayValues(values))\n\t\t\t\t\t}\n\t\t\t\t\treturn _undefined\n\t\t\t\t}, \"\", 1)\n\t\t\t}\n\t\t\tonFulfilled := reaction(asciiString(\"fulfilled\"), \"value\")\n\t\t\tonRejected := reaction(asciiString(\"rejected\"), \"reason\")\n\t\t\tremainingElementsCount++\n\t\t\tr.invoke(nextPromise, \"then\", onFulfilled, onRejected)\n\t\t})\n\t\tremainingElementsCount--\n\t\tif remainingElementsCount == 0 {\n\t\t\tpcap.resolve(r.newArrayValues(values))\n\t\t}\n\t})\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promise_any(call FunctionCall) Value {\n\tc := r.toObject(call.This)\n\tpcap := r.newPromiseCapability(c)\n\n\tpcap.try(func() {\n\t\tpromiseResolve := r.toCallable(c.self.getStr(\"resolve\", nil))\n\t\titer := r.getIterator(call.Argument(0), nil)\n\t\tvar errors []Value\n\t\tremainingElementsCount := 1\n\t\titer.iterate(func(nextValue Value) {\n\t\t\tindex := len(errors)\n\t\t\terrors = append(errors, _undefined)\n\t\t\tnextPromise := promiseResolve(FunctionCall{This: c, Arguments: []Value{nextValue}})\n\t\t\talreadyCalled := false\n\t\t\tonRejected := r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\t\tif alreadyCalled {\n\t\t\t\t\treturn _undefined\n\t\t\t\t}\n\t\t\t\talreadyCalled = true\n\t\t\t\terrors[index] = call.Argument(0)\n\t\t\t\tremainingElementsCount--\n\t\t\t\tif remainingElementsCount == 0 {\n\t\t\t\t\t_error := r.builtin_new(r.getAggregateError(), nil)\n\t\t\t\t\t_error.self._putProp(\"errors\", r.newArrayValues(errors), true, false, true)\n\t\t\t\t\tpcap.reject(_error)\n\t\t\t\t}\n\t\t\t\treturn _undefined\n\t\t\t}, \"\", 1)\n\n\t\t\tremainingElementsCount++\n\t\t\tr.invoke(nextPromise, \"then\", pcap.resolveObj, onRejected)\n\t\t})\n\t\tremainingElementsCount--\n\t\tif remainingElementsCount == 0 {\n\t\t\t_error := r.builtin_new(r.getAggregateError(), nil)\n\t\t\t_error.self._putProp(\"errors\", r.newArrayValues(errors), true, false, true)\n\t\t\tpcap.reject(_error)\n\t\t}\n\t})\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promise_race(call FunctionCall) Value {\n\tc := r.toObject(call.This)\n\tpcap := r.newPromiseCapability(c)\n\n\tpcap.try(func() {\n\t\tpromiseResolve := r.toCallable(c.self.getStr(\"resolve\", nil))\n\t\titer := r.getIterator(call.Argument(0), nil)\n\t\titer.iterate(func(nextValue Value) {\n\t\t\tnextPromise := promiseResolve(FunctionCall{This: c, Arguments: []Value{nextValue}})\n\t\t\tr.invoke(nextPromise, \"then\", pcap.resolveObj, pcap.rejectObj)\n\t\t})\n\t})\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promise_reject(call FunctionCall) Value {\n\tpcap := r.newPromiseCapability(r.toObject(call.This))\n\tpcap.reject(call.Argument(0))\n\treturn pcap.promise\n}\n\nfunc (r *Runtime) promise_resolve(call FunctionCall) Value {\n\treturn r.promiseResolve(r.toObject(call.This), call.Argument(0))\n}\n\nfunc (r *Runtime) createPromiseProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\to._putProp(\"constructor\", r.getPromise(), true, false, true)\n\n\to._putProp(\"catch\", r.newNativeFunc(r.promiseProto_catch, \"catch\", 1), true, false, true)\n\to._putProp(\"finally\", r.newNativeFunc(r.promiseProto_finally, \"finally\", 1), true, false, true)\n\to._putProp(\"then\", r.newNativeFunc(r.promiseProto_then, \"then\", 2), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(classPromise), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createPromise(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newPromise, r.getPromisePrototype(), \"Promise\", 1)\n\n\to._putProp(\"all\", r.newNativeFunc(r.promise_all, \"all\", 1), true, false, true)\n\to._putProp(\"allSettled\", r.newNativeFunc(r.promise_allSettled, \"allSettled\", 1), true, false, true)\n\to._putProp(\"any\", r.newNativeFunc(r.promise_any, \"any\", 1), true, false, true)\n\to._putProp(\"race\", r.newNativeFunc(r.promise_race, \"race\", 1), true, false, true)\n\to._putProp(\"reject\", r.newNativeFunc(r.promise_reject, \"reject\", 1), true, false, true)\n\to._putProp(\"resolve\", r.newNativeFunc(r.promise_resolve, \"resolve\", 1), true, false, true)\n\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) getPromisePrototype() *Object {\n\tret := r.global.PromisePrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.PromisePrototype = ret\n\t\tret.self = r.createPromiseProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getPromise() *Object {\n\tret := r.global.Promise\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Promise = ret\n\t\tret.self = r.createPromise(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) wrapPromiseReaction(fObj *Object) func(interface{}) error {\n\tf, _ := AssertFunction(fObj)\n\treturn func(x interface{}) error {\n\t\t_, err := f(nil, r.ToValue(x))\n\t\treturn err\n\t}\n}\n\n// NewPromise creates and returns a Promise and resolving functions for it.\n// The returned errors will be uncatchable errors, such as InterruptedError or StackOverflowError, which should be propagated upwards.\n// Exceptions are handled through [PromiseRejectionTracker].\n//\n// WARNING: The returned values are not goroutine-safe and must not be called in parallel with VM running.\n// In order to make use of this method you need an event loop such as the one in goja_nodejs (https://github.com/dop251/goja_nodejs)\n// where it can be used like this:\n//\n//\tloop := NewEventLoop()\n//\tloop.Start()\n//\tdefer loop.Stop()\n//\tloop.RunOnLoop(func(vm *goja.Runtime) {\n//\t    p, resolve, _ := vm.NewPromise()\n//\t    vm.Set(\"p\", p)\n//\t    go func() {\n//\t        time.Sleep(500 * time.Millisecond)   // or perform any other blocking operation\n//\t        loop.RunOnLoop(func(*goja.Runtime) { // resolve() must be called on the loop, cannot call it here\n//\t            err := resolve(result)\n//\t            // Handle uncatchable errors (e.g. by stopping the loop, panicking or setting a flag)\n//\t        })\n//\t    }()\n//\t}\nfunc (r *Runtime) NewPromise() (promise *Promise, resolve, reject func(reason interface{}) error) {\n\tp := r.newPromise(r.getPromisePrototype())\n\tresolveF, rejectF := p.createResolvingFunctions()\n\treturn p, r.wrapPromiseReaction(resolveF), r.wrapPromiseReaction(rejectF)\n}\n\n// SetPromiseRejectionTracker registers a function that will be called in two scenarios: when a promise is rejected\n// without any handlers (with operation argument set to PromiseRejectionReject), and when a handler is added to a\n// rejected promise for the first time (with operation argument set to PromiseRejectionHandle).\n//\n// Setting a tracker replaces any existing one. Setting it to nil disables the functionality.\n//\n// See https://tc39.es/ecma262/#sec-host-promise-rejection-tracker for more details.\nfunc (r *Runtime) SetPromiseRejectionTracker(tracker PromiseRejectionTracker) {\n\tr.promiseRejectionTracker = tracker\n}\n\n// SetAsyncContextTracker registers a handler that allows to track async execution contexts. See AsyncContextTracker\n// documentation for more details. Setting it to nil disables the functionality.\n// This method (as Runtime in general) is not goroutine-safe.\nfunc (r *Runtime) SetAsyncContextTracker(tracker AsyncContextTracker) {\n\tr.asyncContextTracker = tracker\n}\n"
        },
        {
          "name": "builtin_proxy.go",
          "type": "blob",
          "size": 13.90625,
          "content": "package goja\n\nimport (\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype nativeProxyHandler struct {\n\thandler *ProxyTrapConfig\n}\n\nfunc (h *nativeProxyHandler) getPrototypeOf(target *Object) (Value, bool) {\n\tif trap := h.handler.GetPrototypeOf; trap != nil {\n\t\treturn trap(target), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) setPrototypeOf(target *Object, proto *Object) (bool, bool) {\n\tif trap := h.handler.SetPrototypeOf; trap != nil {\n\t\treturn trap(target, proto), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) isExtensible(target *Object) (bool, bool) {\n\tif trap := h.handler.IsExtensible; trap != nil {\n\t\treturn trap(target), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) preventExtensions(target *Object) (bool, bool) {\n\tif trap := h.handler.PreventExtensions; trap != nil {\n\t\treturn trap(target), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) getOwnPropertyDescriptorStr(target *Object, prop unistring.String) (Value, bool) {\n\tif trap := h.handler.GetOwnPropertyDescriptorIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\tdesc := trap(target, idx)\n\t\t\treturn desc.toValue(target.runtime), true\n\t\t}\n\t}\n\tif trap := h.handler.GetOwnPropertyDescriptor; trap != nil {\n\t\tdesc := trap(target, prop.String())\n\t\treturn desc.toValue(target.runtime), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) getOwnPropertyDescriptorIdx(target *Object, prop valueInt) (Value, bool) {\n\tif trap := h.handler.GetOwnPropertyDescriptorIdx; trap != nil {\n\t\tdesc := trap(target, toIntStrict(int64(prop)))\n\t\treturn desc.toValue(target.runtime), true\n\t}\n\tif trap := h.handler.GetOwnPropertyDescriptor; trap != nil {\n\t\tdesc := trap(target, prop.String())\n\t\treturn desc.toValue(target.runtime), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) getOwnPropertyDescriptorSym(target *Object, prop *Symbol) (Value, bool) {\n\tif trap := h.handler.GetOwnPropertyDescriptorSym; trap != nil {\n\t\tdesc := trap(target, prop)\n\t\treturn desc.toValue(target.runtime), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) definePropertyStr(target *Object, prop unistring.String, desc PropertyDescriptor) (bool, bool) {\n\tif trap := h.handler.DefinePropertyIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\treturn trap(target, idx, desc), true\n\t\t}\n\t}\n\tif trap := h.handler.DefineProperty; trap != nil {\n\t\treturn trap(target, prop.String(), desc), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) definePropertyIdx(target *Object, prop valueInt, desc PropertyDescriptor) (bool, bool) {\n\tif trap := h.handler.DefinePropertyIdx; trap != nil {\n\t\treturn trap(target, toIntStrict(int64(prop)), desc), true\n\t}\n\tif trap := h.handler.DefineProperty; trap != nil {\n\t\treturn trap(target, prop.String(), desc), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) definePropertySym(target *Object, prop *Symbol, desc PropertyDescriptor) (bool, bool) {\n\tif trap := h.handler.DefinePropertySym; trap != nil {\n\t\treturn trap(target, prop, desc), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) hasStr(target *Object, prop unistring.String) (bool, bool) {\n\tif trap := h.handler.HasIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\treturn trap(target, idx), true\n\t\t}\n\t}\n\tif trap := h.handler.Has; trap != nil {\n\t\treturn trap(target, prop.String()), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) hasIdx(target *Object, prop valueInt) (bool, bool) {\n\tif trap := h.handler.HasIdx; trap != nil {\n\t\treturn trap(target, toIntStrict(int64(prop))), true\n\t}\n\tif trap := h.handler.Has; trap != nil {\n\t\treturn trap(target, prop.String()), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) hasSym(target *Object, prop *Symbol) (bool, bool) {\n\tif trap := h.handler.HasSym; trap != nil {\n\t\treturn trap(target, prop), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) getStr(target *Object, prop unistring.String, receiver Value) (Value, bool) {\n\tif trap := h.handler.GetIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\treturn trap(target, idx, receiver), true\n\t\t}\n\t}\n\tif trap := h.handler.Get; trap != nil {\n\t\treturn trap(target, prop.String(), receiver), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) getIdx(target *Object, prop valueInt, receiver Value) (Value, bool) {\n\tif trap := h.handler.GetIdx; trap != nil {\n\t\treturn trap(target, toIntStrict(int64(prop)), receiver), true\n\t}\n\tif trap := h.handler.Get; trap != nil {\n\t\treturn trap(target, prop.String(), receiver), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) getSym(target *Object, prop *Symbol, receiver Value) (Value, bool) {\n\tif trap := h.handler.GetSym; trap != nil {\n\t\treturn trap(target, prop, receiver), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) setStr(target *Object, prop unistring.String, value Value, receiver Value) (bool, bool) {\n\tif trap := h.handler.SetIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\treturn trap(target, idx, value, receiver), true\n\t\t}\n\t}\n\tif trap := h.handler.Set; trap != nil {\n\t\treturn trap(target, prop.String(), value, receiver), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) setIdx(target *Object, prop valueInt, value Value, receiver Value) (bool, bool) {\n\tif trap := h.handler.SetIdx; trap != nil {\n\t\treturn trap(target, toIntStrict(int64(prop)), value, receiver), true\n\t}\n\tif trap := h.handler.Set; trap != nil {\n\t\treturn trap(target, prop.String(), value, receiver), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) setSym(target *Object, prop *Symbol, value Value, receiver Value) (bool, bool) {\n\tif trap := h.handler.SetSym; trap != nil {\n\t\treturn trap(target, prop, value, receiver), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) deleteStr(target *Object, prop unistring.String) (bool, bool) {\n\tif trap := h.handler.DeletePropertyIdx; trap != nil {\n\t\tif idx, ok := strToInt(prop); ok {\n\t\t\treturn trap(target, idx), true\n\t\t}\n\t}\n\tif trap := h.handler.DeleteProperty; trap != nil {\n\t\treturn trap(target, prop.String()), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) deleteIdx(target *Object, prop valueInt) (bool, bool) {\n\tif trap := h.handler.DeletePropertyIdx; trap != nil {\n\t\treturn trap(target, toIntStrict(int64(prop))), true\n\t}\n\tif trap := h.handler.DeleteProperty; trap != nil {\n\t\treturn trap(target, prop.String()), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) deleteSym(target *Object, prop *Symbol) (bool, bool) {\n\tif trap := h.handler.DeletePropertySym; trap != nil {\n\t\treturn trap(target, prop), true\n\t}\n\treturn false, false\n}\n\nfunc (h *nativeProxyHandler) ownKeys(target *Object) (*Object, bool) {\n\tif trap := h.handler.OwnKeys; trap != nil {\n\t\treturn trap(target), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) apply(target *Object, this Value, args []Value) (Value, bool) {\n\tif trap := h.handler.Apply; trap != nil {\n\t\treturn trap(target, this, args), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) construct(target *Object, args []Value, newTarget *Object) (Value, bool) {\n\tif trap := h.handler.Construct; trap != nil {\n\t\treturn trap(target, args, newTarget), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *nativeProxyHandler) toObject(runtime *Runtime) *Object {\n\treturn runtime.ToValue(h.handler).ToObject(runtime)\n}\n\nfunc (r *Runtime) newNativeProxyHandler(nativeHandler *ProxyTrapConfig) proxyHandler {\n\treturn &nativeProxyHandler{handler: nativeHandler}\n}\n\n// ProxyTrapConfig provides a simplified Go-friendly API for implementing Proxy traps.\n// If an *Idx trap is defined it gets called for integer property keys, including negative ones. Note that\n// this only includes string property keys that represent a canonical integer\n// (i.e. \"0\", \"123\", but not \"00\", \"01\", \" 1\" or \"-0\").\n// For efficiency strings representing integers exceeding 2^53 are not checked to see if they are canonical,\n// i.e. the *Idx traps will receive \"9007199254740993\" as well as \"9007199254740994\", even though the former is not\n// a canonical representation in ECMAScript (Number(\"9007199254740993\") === 9007199254740992).\n// See https://262.ecma-international.org/#sec-canonicalnumericindexstring\n// If an *Idx trap is not set, the corresponding string one is used.\ntype ProxyTrapConfig struct {\n\t// A trap for Object.getPrototypeOf, Reflect.getPrototypeOf, __proto__, Object.prototype.isPrototypeOf, instanceof\n\tGetPrototypeOf func(target *Object) (prototype *Object)\n\n\t// A trap for Object.setPrototypeOf, Reflect.setPrototypeOf\n\tSetPrototypeOf func(target *Object, prototype *Object) (success bool)\n\n\t// A trap for Object.isExtensible, Reflect.isExtensible\n\tIsExtensible func(target *Object) (success bool)\n\n\t// A trap for Object.preventExtensions, Reflect.preventExtensions\n\tPreventExtensions func(target *Object) (success bool)\n\n\t// A trap for Object.getOwnPropertyDescriptor, Reflect.getOwnPropertyDescriptor (string properties)\n\tGetOwnPropertyDescriptor func(target *Object, prop string) (propertyDescriptor PropertyDescriptor)\n\n\t// A trap for Object.getOwnPropertyDescriptor, Reflect.getOwnPropertyDescriptor (integer properties)\n\tGetOwnPropertyDescriptorIdx func(target *Object, prop int) (propertyDescriptor PropertyDescriptor)\n\n\t// A trap for Object.getOwnPropertyDescriptor, Reflect.getOwnPropertyDescriptor (Symbol properties)\n\tGetOwnPropertyDescriptorSym func(target *Object, prop *Symbol) (propertyDescriptor PropertyDescriptor)\n\n\t// A trap for Object.defineProperty, Reflect.defineProperty (string properties)\n\tDefineProperty func(target *Object, key string, propertyDescriptor PropertyDescriptor) (success bool)\n\n\t// A trap for Object.defineProperty, Reflect.defineProperty (integer properties)\n\tDefinePropertyIdx func(target *Object, key int, propertyDescriptor PropertyDescriptor) (success bool)\n\n\t// A trap for Object.defineProperty, Reflect.defineProperty (Symbol properties)\n\tDefinePropertySym func(target *Object, key *Symbol, propertyDescriptor PropertyDescriptor) (success bool)\n\n\t// A trap for the in operator, with operator, Reflect.has (string properties)\n\tHas func(target *Object, property string) (available bool)\n\n\t// A trap for the in operator, with operator, Reflect.has (integer properties)\n\tHasIdx func(target *Object, property int) (available bool)\n\n\t// A trap for the in operator, with operator, Reflect.has (Symbol properties)\n\tHasSym func(target *Object, property *Symbol) (available bool)\n\n\t// A trap for getting property values, Reflect.get (string properties)\n\tGet func(target *Object, property string, receiver Value) (value Value)\n\n\t// A trap for getting property values, Reflect.get (integer properties)\n\tGetIdx func(target *Object, property int, receiver Value) (value Value)\n\n\t// A trap for getting property values, Reflect.get (Symbol properties)\n\tGetSym func(target *Object, property *Symbol, receiver Value) (value Value)\n\n\t// A trap for setting property values, Reflect.set (string properties)\n\tSet func(target *Object, property string, value Value, receiver Value) (success bool)\n\n\t// A trap for setting property values, Reflect.set (integer properties)\n\tSetIdx func(target *Object, property int, value Value, receiver Value) (success bool)\n\n\t// A trap for setting property values, Reflect.set (Symbol properties)\n\tSetSym func(target *Object, property *Symbol, value Value, receiver Value) (success bool)\n\n\t// A trap for the delete operator, Reflect.deleteProperty (string properties)\n\tDeleteProperty func(target *Object, property string) (success bool)\n\n\t// A trap for the delete operator, Reflect.deleteProperty (integer properties)\n\tDeletePropertyIdx func(target *Object, property int) (success bool)\n\n\t// A trap for the delete operator, Reflect.deleteProperty (Symbol properties)\n\tDeletePropertySym func(target *Object, property *Symbol) (success bool)\n\n\t// A trap for Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.keys, Reflect.ownKeys\n\tOwnKeys func(target *Object) (object *Object)\n\n\t// A trap for a function call, Function.prototype.apply, Function.prototype.call, Reflect.apply\n\tApply func(target *Object, this Value, argumentsList []Value) (value Value)\n\n\t// A trap for the new operator, Reflect.construct\n\tConstruct func(target *Object, argumentsList []Value, newTarget *Object) (value *Object)\n}\n\nfunc (r *Runtime) newProxy(args []Value, proto *Object) *Object {\n\tif len(args) >= 2 {\n\t\tif target, ok := args[0].(*Object); ok {\n\t\t\tif proxyHandler, ok := args[1].(*Object); ok {\n\t\t\t\treturn r.newProxyObject(target, proxyHandler, proto).val\n\t\t\t}\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Cannot create proxy with a non-object as target or handler\"))\n}\n\nfunc (r *Runtime) builtin_newProxy(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"Proxy\"))\n\t}\n\treturn r.newProxy(args, r.getPrototypeFromCtor(newTarget, r.getProxy(), r.global.ObjectPrototype))\n}\n\nfunc (r *Runtime) NewProxy(target *Object, nativeHandler *ProxyTrapConfig) Proxy {\n\tif p, ok := target.self.(*proxyObject); ok {\n\t\tif p.handler == nil {\n\t\t\tpanic(r.NewTypeError(\"Cannot create proxy with a revoked proxy as target\"))\n\t\t}\n\t}\n\thandler := r.newNativeProxyHandler(nativeHandler)\n\tproxy := r._newProxyObject(target, handler, nil)\n\treturn Proxy{proxy: proxy}\n}\n\nfunc (r *Runtime) builtin_proxy_revocable(call FunctionCall) Value {\n\tif len(call.Arguments) >= 2 {\n\t\tif target, ok := call.Argument(0).(*Object); ok {\n\t\t\tif proxyHandler, ok := call.Argument(1).(*Object); ok {\n\t\t\t\tproxy := r.newProxyObject(target, proxyHandler, nil)\n\t\t\t\trevoke := r.newNativeFunc(func(FunctionCall) Value {\n\t\t\t\t\tproxy.revoke()\n\t\t\t\t\treturn _undefined\n\t\t\t\t}, \"\", 0)\n\t\t\t\tret := r.NewObject()\n\t\t\t\tret.self._putProp(\"proxy\", proxy.val, true, true, true)\n\t\t\t\tret.self._putProp(\"revoke\", revoke, true, true, true)\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Cannot create proxy with a non-object as target or handler\"))\n}\n\nfunc (r *Runtime) createProxy(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newProxy, nil, \"Proxy\", 2)\n\n\to._putProp(\"revocable\", r.newNativeFunc(r.builtin_proxy_revocable, \"revocable\", 2), true, false, true)\n\treturn o\n}\n\nfunc (r *Runtime) getProxy() *Object {\n\tret := r.global.Proxy\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Proxy = ret\n\t\tr.createProxy(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_proxy_test.go",
          "type": "blob",
          "size": 26.7353515625,
          "content": "package goja\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestProxy_Object_target_getPrototypeOf(t *testing.T) {\n\tconst SCRIPT = `\n    var proto = {};\n\tvar obj = Object.create(proto);\n\tvar proxy = new Proxy(obj, {});\n\tvar p = Object.getPrototypeOf(proxy);\n\tassert.sameValue(proto, p);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_Object_proxy_getPrototypeOf(t *testing.T) {\n\tconst SCRIPT = `\n    var proto = {};\n\tvar proto2 = {};\n\tvar obj = Object.create(proto);\n\tvar proxy = new Proxy(obj, {\n\t\tgetPrototypeOf: function(target) {\n\t\t\treturn proto2;\n\t\t}\n\t});\n\tvar p = Object.getPrototypeOf(proxy);\n\tassert.sameValue(proto2, p);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_Object_native_proxy_getPrototypeOf(t *testing.T) {\n\tconst SCRIPT = `\n\tvar p = Object.getPrototypeOf(proxy);\n\tassert.sameValue(proto, p);\n\t`\n\n\truntime := New()\n\n\tprototype := runtime.NewObject()\n\truntime.Set(\"proto\", prototype)\n\n\ttarget := runtime.NewObject()\n\tproxy := runtime.NewProxy(target, &ProxyTrapConfig{\n\t\tGetPrototypeOf: func(target *Object) *Object {\n\t\t\treturn prototype\n\t\t},\n\t})\n\truntime.Set(\"proxy\", proxy)\n\n\truntime.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_Object_target_setPrototypeOf(t *testing.T) {\n\tconst SCRIPT = `\n    var proto = {};\n\tvar obj = {};\n\tObject.setPrototypeOf(obj, proto);\n\tvar proxy = new Proxy(obj, {});\n\tvar p = Object.getPrototypeOf(proxy);\n\tassert.sameValue(proto, p);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_Object_proxy_setPrototypeOf(t *testing.T) {\n\tconst SCRIPT = `\n    var proto = {};\n\tvar proto2 = {};\n\tvar obj = {};\n\tObject.setPrototypeOf(obj, proto);\n\tvar proxy = new Proxy(obj, {\n\t\tsetPrototypeOf: function(target, prototype) {\n\t\t\treturn Object.setPrototypeOf(target, proto2);\n\t\t}\n\t});\n\tObject.setPrototypeOf(proxy, null);\n\tvar p = Object.getPrototypeOf(proxy);\n\tassert.sameValue(proto2, p);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_Object_target_isExtensible(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tObject.seal(obj);\n\tvar proxy = new Proxy(obj, {});\n\tObject.isExtensible(proxy);\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestProxy_proxy_isExtensible(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tObject.seal(obj);\n\tvar proxy = new Proxy(obj, {\n\t\tisExtensible: function(target) {\n\t\t\treturn false;\n\t\t}\n\t});\n\tObject.isExtensible(proxy);\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestProxy_native_proxy_isExtensible(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tObject.preventExtensions(target);\n\t\treturn Object.isExtensible(proxy);\n\t})();\n\t`\n\n\truntime := New()\n\n\ttarget := runtime.NewObject()\n\truntime.Set(\"target\", target)\n\n\tproxy := runtime.NewProxy(target, &ProxyTrapConfig{\n\t\tIsExtensible: func(target *Object) (success bool) {\n\t\t\treturn false\n\t\t},\n\t})\n\truntime.Set(\"proxy\", proxy)\n\n\tval, err := runtime.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif val.ToBoolean() {\n\t\tt.Fatal()\n\t}\n}\n\nfunc TestProxy_Object_target_preventExtensions(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tcanEvolve: true\n\t};\n\tvar proxy = new Proxy(obj, {});\n\tObject.preventExtensions(proxy);\n\tproxy.canEvolve\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProxy_proxy_preventExtensions(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tcanEvolve: true\n\t};\n\tvar proxy = new Proxy(obj, {\n\t\tpreventExtensions: function(target) {\n\t\t\ttarget.canEvolve = false;\n\t\t\tObject.preventExtensions(obj);\n\t\t\treturn true;\n\t\t}\n\t});\n\tObject.preventExtensions(proxy);\n\tproxy.canEvolve;\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestProxy_native_proxy_preventExtensions(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tObject.preventExtensions(proxy);\n\t\treturn proxy.canEvolve;\n\t})();\n\t`\n\n\truntime := New()\n\n\ttarget := runtime.NewObject()\n\ttarget.Set(\"canEvolve\", true)\n\truntime.Set(\"target\", target)\n\n\tproxy := runtime.NewProxy(target, &ProxyTrapConfig{\n\t\tPreventExtensions: func(target *Object) (success bool) {\n\t\t\ttarget.Set(\"canEvolve\", false)\n\t\t\t_, err := runtime.RunString(\"Object.preventExtensions(target)\")\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn true\n\t\t},\n\t})\n\truntime.Set(\"proxy\", proxy)\n\n\tval, err := runtime.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif val.ToBoolean() {\n\t\tt.Fatal()\n\t}\n}\n\nfunc TestProxy_Object_target_getOwnPropertyDescriptor(t *testing.T) {\n\tconst SCRIPT = `\n\tvar desc = {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tvalue: 42,\n\t\twritable: false \n\t};\n\n\tvar obj = {};\n\tObject.defineProperty(obj, \"foo\", desc);\n\n\tvar proxy = new Proxy(obj, {});\n\n\tvar desc2 = Object.getOwnPropertyDescriptor(proxy, \"foo\");\n\tdesc2.value\n\t`\n\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestProxy_proxy_getOwnPropertyDescriptor(t *testing.T) {\n\tconst SCRIPT = `\n\tvar desc = {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tvalue: 42,\n\t\twritable: false \n\t};\n\tvar proxy_desc = {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tvalue: 24,\n\t\twritable: false \n\t};\n\n\tvar obj = {};\n\tObject.defineProperty(obj, \"foo\", desc);\n\n\tvar proxy = new Proxy(obj, {\n\t\tgetOwnPropertyDescriptor: function(target, property) {\n\t\t\treturn proxy_desc;\n\t\t}\n\t});\n\n\tassert.throws(TypeError, function() {\n\t\tObject.getOwnPropertyDescriptor(proxy, \"foo\");\n\t});\n\tundefined;\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_native_proxy_getOwnPropertyDescriptor(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tvar desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: 42,\n\t\t\twritable: false \n\t\t};\n\t\tvar proxy_desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: 24,\n\t\t\twritable: false \n\t\t};\n\t\t\n\t\tvar obj = {};\n\t\tObject.defineProperty(obj, \"foo\", desc);\n\n\t\treturn function(constructor) {\n\t\t\tvar proxy = constructor(obj, proxy_desc);\n\n\t\t\tvar desc2 = Object.getOwnPropertyDescriptor(proxy, \"foo\");\n\t\t\treturn desc2.value\n\t\t}\n\t})();\n\t`\n\n\truntime := New()\n\n\tconstructor := func(call FunctionCall) Value {\n\t\ttarget := call.Argument(0).(*Object)\n\t\tproxyDesc := call.Argument(1).(*Object)\n\n\t\treturn runtime.NewProxy(target, &ProxyTrapConfig{\n\t\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) PropertyDescriptor {\n\t\t\t\treturn runtime.toPropertyDescriptor(proxyDesc)\n\t\t\t},\n\t\t}).proxy.val\n\t}\n\n\tval, err := runtime.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif c, ok := val.(*Object).self.assertCallable(); ok {\n\t\tval := c(FunctionCall{\n\t\t\tThis:      val,\n\t\t\tArguments: []Value{runtime.ToValue(constructor)},\n\t\t})\n\t\tif i := val.ToInteger(); i != 24 {\n\t\t\tt.Fatalf(\"val: %d\", i)\n\t\t}\n\t} else {\n\t\tt.Fatal(\"not a function\")\n\t}\n}\n\nfunc TestProxy_native_proxy_getOwnPropertyDescriptorIdx(t *testing.T) {\n\tvm := New()\n\ta := vm.NewArray()\n\tproxy1 := vm.NewProxy(a, &ProxyTrapConfig{\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) PropertyDescriptor {\n\t\t\tpanic(vm.NewTypeError(\"GetOwnPropertyDescriptor was called for %q\", prop))\n\t\t},\n\t\tGetOwnPropertyDescriptorIdx: func(target *Object, prop int) PropertyDescriptor {\n\t\t\tif prop >= -1 && prop <= 1 {\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        vm.ToValue(prop),\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PropertyDescriptor{}\n\t\t},\n\t})\n\n\tproxy2 := vm.NewProxy(a, &ProxyTrapConfig{\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) PropertyDescriptor {\n\t\t\tswitch prop {\n\t\t\tcase \"-1\", \"0\", \"1\":\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        vm.ToValue(prop),\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PropertyDescriptor{}\n\t\t},\n\t})\n\n\tproxy3 := vm.NewProxy(a, &ProxyTrapConfig{\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) PropertyDescriptor {\n\t\t\treturn PropertyDescriptor{\n\t\t\t\tValue:        vm.ToValue(prop),\n\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t}\n\t\t},\n\t\tGetOwnPropertyDescriptorIdx: func(target *Object, prop int) PropertyDescriptor {\n\t\t\tpanic(vm.NewTypeError(\"GetOwnPropertyDescriptorIdx was called for %d\", prop))\n\t\t},\n\t})\n\n\tvm.Set(\"proxy1\", proxy1)\n\tvm.Set(\"proxy2\", proxy2)\n\tvm.Set(\"proxy3\", proxy3)\n\tvm.testScriptWithTestLibX(`\n\tvar desc;\n\tfor (var i = -1; i <= 1; i++) {\n\t\tdesc = Object.getOwnPropertyDescriptor(proxy1, i);\n\t\tassert(deepEqual(desc, {value: i, writable: false, enumerable: false, configurable: true}), \"1. int \"+i);\n\n\t\tdesc = Object.getOwnPropertyDescriptor(proxy1, \"\"+i);\n\t\tassert(deepEqual(desc, {value: i, writable: false, enumerable: false, configurable: true}), \"1. str \"+i);\n\n\t\tdesc = Object.getOwnPropertyDescriptor(proxy2, i);\n\t\tassert(deepEqual(desc, {value: \"\"+i, writable: false, enumerable: false, configurable: true}), \"2. int \"+i);\n\n\t\tdesc = Object.getOwnPropertyDescriptor(proxy2, \"\"+i);\n\t\tassert(deepEqual(desc, {value: \"\"+i, writable: false, enumerable: false, configurable: true}), \"2. str \"+i);\n\t}\n\n\tfor (const prop of [\"00\", \" 0\", \"-0\", \"01\"]) {\n\t\tdesc = Object.getOwnPropertyDescriptor(proxy3, prop);\n\t\tassert(deepEqual(desc, {value: prop, writable: false, enumerable: false, configurable: true}), \"3. \"+prop);\n\t}\n\t`, _undefined, t)\n}\n\nfunc TestProxy_native_proxy_getOwnPropertyDescriptorSym(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\tsym := NewSymbol(\"42\")\n\tvm.Set(\"sym\", sym)\n\tproxy := vm.NewProxy(o, &ProxyTrapConfig{\n\t\tGetOwnPropertyDescriptorSym: func(target *Object, s *Symbol) PropertyDescriptor {\n\t\t\tif target != o {\n\t\t\t\tpanic(vm.NewTypeError(\"Invalid target\"))\n\t\t\t}\n\t\t\tif s == sym {\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        vm.ToValue(\"passed\"),\n\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PropertyDescriptor{}\n\t\t},\n\t})\n\n\tvm.Set(\"proxy\", proxy)\n\tvm.testScriptWithTestLibX(`\n\tvar desc = Object.getOwnPropertyDescriptor(proxy, sym);\n\tassert(deepEqual(desc, {value: \"passed\", writable: true, enumerable: false, configurable: true}));\n\tassert.sameValue(Object.getOwnPropertyDescriptor(proxy, Symbol.iterator), undefined);\n\t`, _undefined, t)\n}\n\nfunc TestProxy_native_proxy_getOwnPropertyDescriptor_non_existing(t *testing.T) {\n\tvm := New()\n\tproxy := vm.NewProxy(vm.NewObject(), &ProxyTrapConfig{\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) (propertyDescriptor PropertyDescriptor) {\n\t\t\treturn // empty PropertyDescriptor\n\t\t},\n\t})\n\tvm.Set(\"proxy\", proxy)\n\tres, err := vm.RunString(`Object.getOwnPropertyDescriptor(proxy, \"foo\") === undefined`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res != valueTrue {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestProxy_Object_target_defineProperty(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {});\n\tObject.defineProperty(proxy, \"foo\", {\n\t\tvalue: \"test123\"\n\t});\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test123\"), t)\n}\n\nfunc TestProxy_proxy_defineProperty(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {\n\t\tdefineProperty: function(target, prop, descriptor) {\n\t\t\ttarget.foo = \"321tset\";\n\t\t\treturn true;\n\t\t}\n\t});\n\tObject.defineProperty(proxy, \"foo\", {\n\t\tvalue: \"test123\"\n\t});\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"321tset\"), t)\n}\n\nfunc TestProxy_native_proxy_defineProperty(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(proxy, \"foo\", {\n\t\tvalue: \"teststr\"\n\t});\n\tObject.defineProperty(proxy, \"0\", {\n\t\tvalue: \"testidx\"\n\t});\n\tObject.defineProperty(proxy, Symbol.toStringTag, {\n\t\tvalue: \"testsym\"\n\t});\n\tassert.sameValue(proxy.foo, \"teststr-passed-str\");\n\tassert.sameValue(proxy[0], \"testidx-passed-idx\");\n\tassert.sameValue(proxy[Symbol.toStringTag], \"testsym-passed-sym\");\n\t`\n\n\truntime := New()\n\n\ttarget := runtime.NewObject()\n\n\tproxy := runtime.NewProxy(target, &ProxyTrapConfig{\n\t\tDefineProperty: func(target *Object, key string, propertyDescriptor PropertyDescriptor) (success bool) {\n\t\t\ttarget.Set(key, propertyDescriptor.Value.String()+\"-passed-str\")\n\t\t\treturn true\n\t\t},\n\t\tDefinePropertyIdx: func(target *Object, key int, propertyDescriptor PropertyDescriptor) (success bool) {\n\t\t\ttarget.Set(strconv.Itoa(key), propertyDescriptor.Value.String()+\"-passed-idx\")\n\t\t\treturn true\n\t\t},\n\t\tDefinePropertySym: func(target *Object, key *Symbol, propertyDescriptor PropertyDescriptor) (success bool) {\n\t\t\ttarget.SetSymbol(key, propertyDescriptor.Value.String()+\"-passed-sym\")\n\t\t\treturn true\n\t\t},\n\t})\n\truntime.Set(\"proxy\", proxy)\n\n\truntime.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_target_has_in(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tsecret: true\n\t};\n\tvar proxy = new Proxy(obj, {});\n\t\n\t\"secret\" in proxy\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProxy_proxy_has_in(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tsecret: true\n\t};\n\tvar proxy = new Proxy(obj, {\n\t\thas: function(target, key) {\n\t\t\treturn key !== \"secret\";\n\t\t}\n\t});\n\t\n\t\"secret\" in proxy\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestProxy_target_has_with(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tsecret: true\n\t};\n\tvar proxy = new Proxy(obj, {});\n\t\n\twith(proxy) {\n\t\t(secret);\n\t}\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProxy_proxy_has_with(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tsecret: true\n\t};\n\tvar proxy = new Proxy(obj, {\n\t\thas: function(target, key) {\n\t\t\treturn key !== \"secret\";\n\t\t}\n\t});\n\t\n\tvar thrown = false;\n\ttry {\n\t\twith(proxy) {\n\t\t\t(secret);\n\t\t}\n\t} catch (e) {\n\t\tif (e instanceof ReferenceError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProxy_target_get(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {});\n\tObject.defineProperty(proxy, \"foo\", {\n\t\tvalue: \"test123\"\n\t});\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test123\"), t)\n}\n\nfunc TestProxy_proxy_get(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {\n\t\tget: function(target, prop, receiver) {\n\t\t\treturn \"321tset\"\n\t\t}\n\t});\n\tObject.defineProperty(proxy, \"foo\", {\n\t\tvalue: \"test123\",\n\t\tconfigurable: true,\n\t});\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"321tset\"), t)\n}\n\nfunc TestProxy_proxy_get_json_stringify(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar propValue = \"321tset\";\n\tvar _handler, _target, _prop, _receiver;\n\tvar proxy = new Proxy(obj, {\n\t\townKeys: function() {\n\t\t\treturn [\"foo\"];\n\t\t},\n\t\tgetOwnPropertyDescriptor: function(target, prop) {\n\t\t\tif (prop === \"foo\") {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: propValue,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tget: function(target, prop, receiver) {\n\t\t\tif (prop === \"foo\") {\n\t\t\t\t_prop = prop;\n\t\t\t\t_receiver = receiver;\n\t\t\t\treturn propValue;\n\t\t\t}\n\t\t\treturn obj[prop];\n\t\t}\n\t});\n\tvar res = JSON.stringify(proxy);\n\tassert.sameValue(res, '{\"foo\":\"321tset\"}');\n\tassert.sameValue(_prop, \"foo\");\n\tassert.sameValue(_receiver, proxy);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_native_proxy_get(t *testing.T) {\n\tvm := New()\n\tpropValueStr := vm.ToValue(\"321tset\")\n\tpropValueIdx := vm.ToValue(\"idx\")\n\tpropValueSym := vm.ToValue(\"sym\")\n\tsym := NewSymbol(\"test\")\n\tobj := vm.NewObject()\n\tproxy := vm.NewProxy(obj, &ProxyTrapConfig{\n\t\tOwnKeys: func(*Object) *Object {\n\t\t\treturn vm.NewArray(\"0\", \"foo\")\n\t\t},\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) (propertyDescriptor PropertyDescriptor) {\n\t\t\tif prop == \"foo\" {\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        propValueStr,\n\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif prop == \"0\" {\n\t\t\t\tpanic(vm.NewTypeError(\"GetOwnPropertyDescriptor(0) was called\"))\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tGetOwnPropertyDescriptorIdx: func(target *Object, prop int) (propertyDescriptor PropertyDescriptor) {\n\t\t\tif prop == 0 {\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        propValueIdx,\n\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tGet: func(target *Object, property string, receiver Value) (value Value) {\n\t\t\tif property == \"foo\" {\n\t\t\t\treturn propValueStr\n\t\t\t}\n\t\t\tif property == \"0\" {\n\t\t\t\tpanic(vm.NewTypeError(\"Get(0) was called\"))\n\t\t\t}\n\t\t\treturn obj.Get(property)\n\t\t},\n\t\tGetIdx: func(target *Object, property int, receiver Value) (value Value) {\n\t\t\tif property == 0 {\n\t\t\t\treturn propValueIdx\n\t\t\t}\n\t\t\treturn obj.Get(strconv.Itoa(property))\n\t\t},\n\t\tGetSym: func(target *Object, property *Symbol, receiver Value) (value Value) {\n\t\t\tif property == sym {\n\t\t\t\treturn propValueSym\n\t\t\t}\n\t\t\treturn obj.GetSymbol(property)\n\t\t},\n\t})\n\tvm.Set(\"proxy\", proxy)\n\tres, err := vm.RunString(`JSON.stringify(proxy)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.SameAs(asciiString(`{\"0\":\"idx\",\"foo\":\"321tset\"}`)) {\n\t\tt.Fatalf(\"res: %v\", res)\n\t}\n\tres, err = vm.RunString(`proxy[Symbol.toPrimitive]`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !IsUndefined(res) {\n\t\tt.Fatalf(\"res: %v\", res)\n\t}\n\n\tres, err = vm.RunString(`proxy.hasOwnProperty(Symbol.toPrimitive)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.SameAs(valueFalse) {\n\t\tt.Fatalf(\"res: %v\", res)\n\t}\n\n\tif val := vm.ToValue(proxy).(*Object).GetSymbol(sym); val == nil || !val.SameAs(propValueSym) {\n\t\tt.Fatalf(\"Get(symbol): %v\", val)\n\t}\n\n\tres, err = vm.RunString(`proxy.toString()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.SameAs(asciiString(`[object Object]`)) {\n\t\tt.Fatalf(\"res: %v\", res)\n\t}\n}\n\nfunc TestProxy_native_proxy_set(t *testing.T) {\n\tvm := New()\n\tpropValueStr := vm.ToValue(\"321tset\")\n\tpropValueIdx := vm.ToValue(\"idx\")\n\tpropValueSym := vm.ToValue(\"sym\")\n\tsym := NewSymbol(\"test\")\n\tobj := vm.NewObject()\n\tproxy := vm.NewProxy(obj, &ProxyTrapConfig{\n\t\tSet: func(target *Object, property string, value Value, receiver Value) (success bool) {\n\t\t\tif property == \"str\" {\n\t\t\t\tobj.Set(property, propValueStr)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"Setter for unexpected property: %q\", property))\n\t\t},\n\t\tSetIdx: func(target *Object, property int, value Value, receiver Value) (success bool) {\n\t\t\tif property == 0 {\n\t\t\t\tobj.Set(strconv.Itoa(property), propValueIdx)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"Setter for unexpected idx property: %d\", property))\n\t\t},\n\t\tSetSym: func(target *Object, property *Symbol, value Value, receiver Value) (success bool) {\n\t\t\tif property == sym {\n\t\t\t\tobj.SetSymbol(property, propValueSym)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"Setter for unexpected sym property: %q\", property.String()))\n\t\t},\n\t})\n\tproxyObj := vm.ToValue(proxy).ToObject(vm)\n\terr := proxyObj.Set(\"str\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = proxyObj.Set(\"0\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = proxyObj.SetSymbol(sym, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v := obj.Get(\"str\"); !propValueStr.SameAs(v) {\n\t\tt.Fatal(v)\n\t}\n\tif v := obj.Get(\"0\"); !propValueIdx.SameAs(v) {\n\t\tt.Fatal(v)\n\t}\n\tif v := obj.GetSymbol(sym); !propValueSym.SameAs(v) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestProxy_target_set_prop(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {});\n\tproxy.foo = \"test123\";\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test123\"), t)\n}\n\nfunc TestProxy_proxy_set_prop(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {\n\t\tset: function(target, prop, receiver) {\n\t\t\ttarget.foo = \"321tset\";\n\t\t\treturn true;\n\t\t}\n\t});\n\tproxy.foo = \"test123\";\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"321tset\"), t)\n}\nfunc TestProxy_target_set_associative(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {});\n\tproxy[\"foo\"] = \"test123\";\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test123\"), t)\n}\n\nfunc TestProxy_proxy_set_associative(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {};\n\tvar proxy = new Proxy(obj, {\n\t\tset: function(target, property, value, receiver) {\n\t\t\ttarget[\"foo\"] = \"321tset\";\n\t\t\treturn true;\n\t\t}\n\t});\n\tproxy[\"foo\"] = \"test123\";\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"321tset\"), t)\n}\n\nfunc TestProxy_target_delete(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tfoo: \"test\"\n\t};\n\tvar proxy = new Proxy(obj, {});\n\tdelete proxy.foo;\n\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_proxy_delete(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tfoo: \"test\"\n\t};\n\tvar proxy = new Proxy(obj, {\n\t\tdeleteProperty: function(target, prop) {\n\t\t\treturn true;\n\t\t}\n\t});\n\tdelete proxy.foo;\n\n\tproxy.foo;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test\"), t)\n}\n\nfunc TestProxy_native_delete(t *testing.T) {\n\tvm := New()\n\tsym := NewSymbol(\"test\")\n\tobj := vm.NewObject()\n\tvar strCalled, idxCalled, symCalled, strNegCalled, idxNegCalled, symNegCalled bool\n\tproxy := vm.NewProxy(obj, &ProxyTrapConfig{\n\t\tDeleteProperty: func(target *Object, property string) (success bool) {\n\t\t\tif property == \"str\" {\n\t\t\t\tstrCalled = true\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif property == \"strNeg\" {\n\t\t\t\tstrNegCalled = true\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"DeleteProperty for unexpected property: %q\", property))\n\t\t},\n\t\tDeletePropertyIdx: func(target *Object, property int) (success bool) {\n\t\t\tif property == 0 {\n\t\t\t\tidxCalled = true\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif property == 1 {\n\t\t\t\tidxNegCalled = true\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"DeletePropertyIdx for unexpected idx property: %d\", property))\n\t\t},\n\t\tDeletePropertySym: func(target *Object, property *Symbol) (success bool) {\n\t\t\tif property == sym {\n\t\t\t\tsymCalled = true\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif property == SymIterator {\n\t\t\t\tsymNegCalled = true\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tpanic(vm.NewTypeError(\"DeletePropertySym for unexpected sym property: %q\", property.String()))\n\t\t},\n\t})\n\tproxyObj := vm.ToValue(proxy).ToObject(vm)\n\terr := proxyObj.Delete(\"str\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = proxyObj.Delete(\"0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = proxyObj.DeleteSymbol(sym)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strCalled {\n\t\tt.Fatal(\"str\")\n\t}\n\tif !idxCalled {\n\t\tt.Fatal(\"idx\")\n\t}\n\tif !symCalled {\n\t\tt.Fatal(\"sym\")\n\t}\n\tvm.Set(\"proxy\", proxy)\n\t_, err = vm.RunString(`\n\tif (delete proxy.strNeg) {\n\t\tthrow new Error(\"strNeg\");\n\t}\n\tif (delete proxy[1]) {\n\t\tthrow new Error(\"idxNeg\");\n\t}\n\tif (delete proxy[Symbol.iterator]) {\n\t\tthrow new Error(\"symNeg\");\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strNegCalled {\n\t\tt.Fatal(\"strNeg\")\n\t}\n\tif !idxNegCalled {\n\t\tt.Fatal(\"idxNeg\")\n\t}\n\tif !symNegCalled {\n\t\tt.Fatal(\"symNeg\")\n\t}\n}\n\nfunc TestProxy_target_keys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tfoo: \"test\"\n\t};\n\tvar proxy = new Proxy(obj, {});\n\n\tvar keys = Object.keys(proxy);\n\tif (keys.length != 1) {\n\t\tthrow new Error(\"assertion error\");\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_proxy_keys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tfoo: \"test\"\n\t};\n\tvar proxy = new Proxy(obj, {\n\t\townKeys: function(target) {\n\t\t\treturn [\"foo\", \"bar\"];\n\t\t}\n\t});\n\n\tvar keys = Object.keys(proxy);\n\tif (keys.length !== 1) {\n\t\tthrow new Error(\"length is \"+keys.length);\n\t}\n\tif (keys[0] !== \"foo\") {\n\t\tthrow new Error(\"keys[0] is \"+keys[0]);\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestProxy_target_call(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {});\n\n\tproxy();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test\"), t)\n}\n\nfunc TestProxy_proxy_call(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {\n\t\tapply: function(target, thisArg, args) {\n\t\t\treturn \"tset\"\n\t\t}\n\t});\n\n\tproxy();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"tset\"), t)\n}\n\nfunc TestProxy_target_func_apply(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {});\n\n\tproxy.apply();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test\"), t)\n}\n\nfunc TestProxy_proxy_func_apply(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {\n\t\tapply: function(target, thisArg, args) {\n\t\t\treturn \"tset\"\n\t\t}\n\t});\n\n\tproxy.apply();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"tset\"), t)\n}\n\nfunc TestProxy_target_func_call(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {});\n\n\tproxy.call();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test\"), t)\n}\n\nfunc TestProxy_proxy_func_call(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function() {\n\t\treturn \"test\"\n\t}\n\t\n\tvar proxy = new Proxy(obj, {\n\t\tapply: function(target, thisArg, args) {\n\t\t\treturn \"tset\"\n\t\t}\n\t});\n\n\tproxy.call();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"tset\"), t)\n}\n\nfunc TestProxy_target_new(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function(word) {\n\t\tthis.foo = function() {\n\t\t\treturn word;\n\t\t}\n\t}\n\t\n\tvar proxy = new Proxy(obj, {});\n\n\tvar instance = new proxy(\"test\");\n\tinstance.foo();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"test\"), t)\n}\n\nfunc TestProxy_proxy_new(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = function(word) {\n\t\tthis.foo = function() {\n\t\t\treturn word;\n\t\t}\n\t}\n\t\n\tvar proxy = new Proxy(obj, {\n\t\tconstruct: function(target, args, newTarget) {\n\t\t\tvar word = args[0]; \n\t\t\treturn {\n\t\t\t\tfoo: function() {\n\t\t\t\t\treturn \"caught-\" + word\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tvar instance = new proxy(\"test\");\n\tinstance.foo();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"caught-test\"), t)\n}\n\nfunc TestProxy_Object_native_proxy_ownKeys(t *testing.T) {\n\theaders := map[string][]string{\n\t\t\"k0\": {},\n\t}\n\tvm := New()\n\tproxy := vm.NewProxy(vm.NewObject(), &ProxyTrapConfig{\n\t\tOwnKeys: func(target *Object) (object *Object) {\n\t\t\tkeys := make([]interface{}, 0, len(headers))\n\t\t\tfor k := range headers {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\treturn vm.ToValue(keys).ToObject(vm)\n\t\t},\n\t\tGetOwnPropertyDescriptor: func(target *Object, prop string) PropertyDescriptor {\n\t\t\tv, exists := headers[prop]\n\t\t\tif exists {\n\t\t\t\treturn PropertyDescriptor{\n\t\t\t\t\tValue:        vm.ToValue(v),\n\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PropertyDescriptor{}\n\t\t},\n\t})\n\tvm.Set(\"headers\", proxy)\n\tv, err := vm.RunString(`\n\t\tvar keys = Object.keys(headers);\n\t\tkeys.length === 1 && keys[0] === \"k0\";\n\t\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != valueTrue {\n\t\tt.Fatal(\"not true\", v)\n\t}\n}\n\nfunc TestProxy_proxy_forIn(t *testing.T) {\n\tconst SCRIPT = `\n\tvar proto = {\n\t\ta: 2,\n\t\tprotoProp: 1\n\t}\n\tObject.defineProperty(proto, \"protoNonEnum\", {\n\t\tvalue: 2,\n\t\twritable: true,\n\t\tconfigurable: true\n\t});\n\tvar target = Object.create(proto);\n\tvar proxy = new Proxy(target, {\n\t\townKeys: function() {\n\t\t\treturn [\"a\", \"b\"];\n\t\t},\n\t\tgetOwnPropertyDescriptor: function(target, p) {\n\t\t\tswitch (p) {\n\t\t\tcase \"a\":\n\t\t\tcase \"b\":\n\t\t\t\treturn {\n\t\t\t\t\tvalue: 42,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tvar forInResult = [];\n\tfor (var key in proxy) {\n\t\tif (forInResult.indexOf(key) !== -1) {\n\t\t\tthrow new Error(\"Duplicate property \"+key);\n\t\t}\n\t\tforInResult.push(key);\n\t}\n\tforInResult.length === 3 && forInResult[0] === \"a\" && forInResult[1] === \"b\" && forInResult[2] === \"protoProp\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProxyExport(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`\n\tnew Proxy({}, {});\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tv1 := v.Export()\n\tif _, ok := v1.(Proxy); !ok {\n\t\tt.Fatalf(\"Export returned unexpected type: %T\", v1)\n\t}\n}\n\nfunc TestProxy_proxy_createTargetNotCallable(t *testing.T) {\n\t// from https://github.com/tc39/test262/blob/main/test/built-ins/Proxy/create-target-is-not-callable.js\n\tconst SCRIPT = `\n\tvar p = new Proxy({}, {});\n\n\tassert.throws(TypeError, function() {\n\t\t  p();\n\t});\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestProxyEnumerableSymbols(t *testing.T) {\n\tconst SCRIPT = `\n\tvar getOwnKeys = [];\n\tvar ownKeysResult = [Symbol(), \"foo\", \"0\"];\n\tvar proxy = new Proxy({}, {\n\t  getOwnPropertyDescriptor: function(_target, key) {\n\t\tgetOwnKeys.push(key);\n\t  },\n\t  ownKeys: function() {\n\t\treturn ownKeysResult;\n\t  },\n\t});\n\n\tlet {...$} = proxy;\n\tcompareArray(getOwnKeys, ownKeysResult);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, valueTrue, t)\n}\n"
        },
        {
          "name": "builtin_reflect.go",
          "type": "blob",
          "size": 5.0068359375,
          "content": "package goja\n\nfunc (r *Runtime) builtin_reflect_apply(call FunctionCall) Value {\n\treturn r.toCallable(call.Argument(0))(FunctionCall{\n\t\tThis:      call.Argument(1),\n\t\tArguments: r.createListFromArrayLike(call.Argument(2))})\n}\n\nfunc (r *Runtime) toConstructor(v Value) func(args []Value, newTarget *Object) *Object {\n\tif ctor := r.toObject(v).self.assertConstructor(); ctor != nil {\n\t\treturn ctor\n\t}\n\tpanic(r.NewTypeError(\"Value is not a constructor\"))\n}\n\nfunc (r *Runtime) builtin_reflect_construct(call FunctionCall) Value {\n\ttarget := call.Argument(0)\n\tctor := r.toConstructor(target)\n\tvar newTarget Value\n\tif len(call.Arguments) > 2 {\n\t\tnewTarget = call.Argument(2)\n\t\tr.toConstructor(newTarget)\n\t} else {\n\t\tnewTarget = target\n\t}\n\treturn ctor(r.createListFromArrayLike(call.Argument(1)), r.toObject(newTarget))\n}\n\nfunc (r *Runtime) builtin_reflect_defineProperty(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tkey := toPropertyKey(call.Argument(1))\n\tdesc := r.toPropertyDescriptor(call.Argument(2))\n\n\treturn r.toBoolean(target.defineOwnProperty(key, desc, false))\n}\n\nfunc (r *Runtime) builtin_reflect_deleteProperty(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tkey := toPropertyKey(call.Argument(1))\n\n\treturn r.toBoolean(target.delete(key, false))\n}\n\nfunc (r *Runtime) builtin_reflect_get(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tkey := toPropertyKey(call.Argument(1))\n\tvar receiver Value\n\tif len(call.Arguments) > 2 {\n\t\treceiver = call.Arguments[2]\n\t}\n\treturn target.get(key, receiver)\n}\n\nfunc (r *Runtime) builtin_reflect_getOwnPropertyDescriptor(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tkey := toPropertyKey(call.Argument(1))\n\treturn r.valuePropToDescriptorObject(target.getOwnProp(key))\n}\n\nfunc (r *Runtime) builtin_reflect_getPrototypeOf(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tif proto := target.self.proto(); proto != nil {\n\t\treturn proto\n\t}\n\n\treturn _null\n}\n\nfunc (r *Runtime) builtin_reflect_has(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tkey := toPropertyKey(call.Argument(1))\n\treturn r.toBoolean(target.hasProperty(key))\n}\n\nfunc (r *Runtime) builtin_reflect_isExtensible(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\treturn r.toBoolean(target.self.isExtensible())\n}\n\nfunc (r *Runtime) builtin_reflect_ownKeys(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\treturn r.newArrayValues(target.self.keys(true, nil))\n}\n\nfunc (r *Runtime) builtin_reflect_preventExtensions(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\treturn r.toBoolean(target.self.preventExtensions(false))\n}\n\nfunc (r *Runtime) builtin_reflect_set(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tvar receiver Value\n\tif len(call.Arguments) >= 4 {\n\t\treceiver = call.Argument(3)\n\t} else {\n\t\treceiver = target\n\t}\n\treturn r.toBoolean(target.set(call.Argument(1), call.Argument(2), receiver, false))\n}\n\nfunc (r *Runtime) builtin_reflect_setPrototypeOf(call FunctionCall) Value {\n\ttarget := r.toObject(call.Argument(0))\n\tvar proto *Object\n\tif arg := call.Argument(1); arg != _null {\n\t\tproto = r.toObject(arg)\n\t}\n\treturn r.toBoolean(target.self.setProto(proto, false))\n}\n\nfunc (r *Runtime) createReflect(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putProp(\"apply\", r.newNativeFunc(r.builtin_reflect_apply, \"apply\", 3), true, false, true)\n\to._putProp(\"construct\", r.newNativeFunc(r.builtin_reflect_construct, \"construct\", 2), true, false, true)\n\to._putProp(\"defineProperty\", r.newNativeFunc(r.builtin_reflect_defineProperty, \"defineProperty\", 3), true, false, true)\n\to._putProp(\"deleteProperty\", r.newNativeFunc(r.builtin_reflect_deleteProperty, \"deleteProperty\", 2), true, false, true)\n\to._putProp(\"get\", r.newNativeFunc(r.builtin_reflect_get, \"get\", 2), true, false, true)\n\to._putProp(\"getOwnPropertyDescriptor\", r.newNativeFunc(r.builtin_reflect_getOwnPropertyDescriptor, \"getOwnPropertyDescriptor\", 2), true, false, true)\n\to._putProp(\"getPrototypeOf\", r.newNativeFunc(r.builtin_reflect_getPrototypeOf, \"getPrototypeOf\", 1), true, false, true)\n\to._putProp(\"has\", r.newNativeFunc(r.builtin_reflect_has, \"has\", 2), true, false, true)\n\to._putProp(\"isExtensible\", r.newNativeFunc(r.builtin_reflect_isExtensible, \"isExtensible\", 1), true, false, true)\n\to._putProp(\"ownKeys\", r.newNativeFunc(r.builtin_reflect_ownKeys, \"ownKeys\", 1), true, false, true)\n\to._putProp(\"preventExtensions\", r.newNativeFunc(r.builtin_reflect_preventExtensions, \"preventExtensions\", 1), true, false, true)\n\to._putProp(\"set\", r.newNativeFunc(r.builtin_reflect_set, \"set\", 3), true, false, true)\n\to._putProp(\"setPrototypeOf\", r.newNativeFunc(r.builtin_reflect_setPrototypeOf, \"setPrototypeOf\", 2), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(\"Reflect\"), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getReflect() *Object {\n\tret := r.global.Reflect\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Reflect = ret\n\t\tret.self = r.createReflect(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_regexp.go",
          "type": "blob",
          "size": 34.5224609375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"github.com/dop251/goja/parser\"\n\t\"regexp\"\n\t\"strings\"\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n)\n\nfunc (r *Runtime) newRegexpObject(proto *Object) *regexpObject {\n\tv := &Object{runtime: r}\n\n\to := &regexpObject{}\n\to.class = classRegExp\n\to.val = v\n\to.extensible = true\n\tv.self = o\n\to.prototype = proto\n\to.init()\n\treturn o\n}\n\nfunc (r *Runtime) newRegExpp(pattern *regexpPattern, patternStr String, proto *Object) *regexpObject {\n\to := r.newRegexpObject(proto)\n\n\to.pattern = pattern\n\to.source = patternStr\n\n\treturn o\n}\n\nfunc decodeHex(s string) (int, bool) {\n\tvar hex int\n\tfor i := 0; i < len(s); i++ {\n\t\tvar n byte\n\t\tchr := s[i]\n\t\tswitch {\n\t\tcase '0' <= chr && chr <= '9':\n\t\t\tn = chr - '0'\n\t\tcase 'a' <= chr && chr <= 'f':\n\t\t\tn = chr - 'a' + 10\n\t\tcase 'A' <= chr && chr <= 'F':\n\t\t\tn = chr - 'A' + 10\n\t\tdefault:\n\t\t\treturn 0, false\n\t\t}\n\t\thex = hex*16 + int(n)\n\t}\n\treturn hex, true\n}\n\nfunc writeHex4(b *strings.Builder, i int) {\n\tb.WriteByte(hex[i>>12])\n\tb.WriteByte(hex[(i>>8)&0xF])\n\tb.WriteByte(hex[(i>>4)&0xF])\n\tb.WriteByte(hex[i&0xF])\n}\n\n// Convert any valid surrogate pairs in the form of \\uXXXX\\uXXXX to unicode characters\nfunc convertRegexpToUnicode(patternStr string) string {\n\tvar sb strings.Builder\n\tpos := 0\n\tfor i := 0; i < len(patternStr)-11; {\n\t\tr, size := utf8.DecodeRuneInString(patternStr[i:])\n\t\tif r == '\\\\' {\n\t\t\ti++\n\t\t\tif patternStr[i] == 'u' && patternStr[i+5] == '\\\\' && patternStr[i+6] == 'u' {\n\t\t\t\tif first, ok := decodeHex(patternStr[i+1 : i+5]); ok {\n\t\t\t\t\tif isUTF16FirstSurrogate(uint16(first)) {\n\t\t\t\t\t\tif second, ok := decodeHex(patternStr[i+7 : i+11]); ok {\n\t\t\t\t\t\t\tif isUTF16SecondSurrogate(uint16(second)) {\n\t\t\t\t\t\t\t\tr = utf16.DecodeRune(rune(first), rune(second))\n\t\t\t\t\t\t\t\tsb.WriteString(patternStr[pos : i-1])\n\t\t\t\t\t\t\t\tsb.WriteRune(r)\n\t\t\t\t\t\t\t\ti += 11\n\t\t\t\t\t\t\t\tpos = i\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t} else {\n\t\t\ti += size\n\t\t}\n\t}\n\tif pos > 0 {\n\t\tsb.WriteString(patternStr[pos:])\n\t\treturn sb.String()\n\t}\n\treturn patternStr\n}\n\n// Convert any extended unicode characters to UTF-16 in the form of \\uXXXX\\uXXXX\nfunc convertRegexpToUtf16(patternStr string) string {\n\tvar sb strings.Builder\n\tpos := 0\n\tvar prevRune rune\n\tfor i := 0; i < len(patternStr); {\n\t\tr, size := utf8.DecodeRuneInString(patternStr[i:])\n\t\tif r > 0xFFFF {\n\t\t\tsb.WriteString(patternStr[pos:i])\n\t\t\tif prevRune == '\\\\' {\n\t\t\t\tsb.WriteRune('\\\\')\n\t\t\t}\n\t\t\tfirst, second := utf16.EncodeRune(r)\n\t\t\tsb.WriteString(`\\u`)\n\t\t\twriteHex4(&sb, int(first))\n\t\t\tsb.WriteString(`\\u`)\n\t\t\twriteHex4(&sb, int(second))\n\t\t\tpos = i + size\n\t\t}\n\t\ti += size\n\t\tprevRune = r\n\t}\n\tif pos > 0 {\n\t\tsb.WriteString(patternStr[pos:])\n\t\treturn sb.String()\n\t}\n\treturn patternStr\n}\n\n// convert any broken UTF-16 surrogate pairs to \\uXXXX\nfunc escapeInvalidUtf16(s String) string {\n\tif imported, ok := s.(*importedString); ok {\n\t\treturn imported.s\n\t}\n\tif ascii, ok := s.(asciiString); ok {\n\t\treturn ascii.String()\n\t}\n\tvar sb strings.Builder\n\trd := &lenientUtf16Decoder{utf16Reader: s.utf16Reader()}\n\tpos := 0\n\tutf8Size := 0\n\tvar utf8Buf [utf8.UTFMax]byte\n\tfor {\n\t\tc, size, err := rd.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif utf16.IsSurrogate(c) {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.Grow(utf8Size + 7)\n\t\t\t\thrd := s.Reader()\n\t\t\t\tvar c rune\n\t\t\t\tfor p := 0; p < pos; {\n\t\t\t\t\tvar size int\n\t\t\t\t\tvar err error\n\t\t\t\t\tc, size, err = hrd.ReadRune()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// will not happen\n\t\t\t\t\t\tpanic(fmt.Errorf(\"error while reading string head %q, pos: %d: %w\", s.String(), pos, err))\n\t\t\t\t\t}\n\t\t\t\t\tsb.WriteRune(c)\n\t\t\t\t\tp += size\n\t\t\t\t}\n\t\t\t\tif c == '\\\\' {\n\t\t\t\t\tsb.WriteRune(c)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.WriteString(`\\u`)\n\t\t\twriteHex4(&sb, int(c))\n\t\t} else {\n\t\t\tif sb.Len() > 0 {\n\t\t\t\tsb.WriteRune(c)\n\t\t\t} else {\n\t\t\t\tutf8Size += utf8.EncodeRune(utf8Buf[:], c)\n\t\t\t\tpos += size\n\t\t\t}\n\t\t}\n\t}\n\tif sb.Len() > 0 {\n\t\treturn sb.String()\n\t}\n\treturn s.String()\n}\n\nfunc compileRegexpFromValueString(patternStr String, flags string) (*regexpPattern, error) {\n\treturn compileRegexp(escapeInvalidUtf16(patternStr), flags)\n}\n\nfunc compileRegexp(patternStr, flags string) (p *regexpPattern, err error) {\n\tvar global, ignoreCase, multiline, dotAll, sticky, unicode bool\n\tvar wrapper *regexpWrapper\n\tvar wrapper2 *regexp2Wrapper\n\n\tif flags != \"\" {\n\t\tinvalidFlags := func() {\n\t\t\terr = fmt.Errorf(\"Invalid flags supplied to RegExp constructor '%s'\", flags)\n\t\t}\n\t\tfor _, chr := range flags {\n\t\t\tswitch chr {\n\t\t\tcase 'g':\n\t\t\t\tif global {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tglobal = true\n\t\t\tcase 'm':\n\t\t\t\tif multiline {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmultiline = true\n\t\t\tcase 's':\n\t\t\t\tif dotAll {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdotAll = true\n\t\t\tcase 'i':\n\t\t\t\tif ignoreCase {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tignoreCase = true\n\t\t\tcase 'y':\n\t\t\t\tif sticky {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tsticky = true\n\t\t\tcase 'u':\n\t\t\t\tif unicode {\n\t\t\t\t\tinvalidFlags()\n\t\t\t\t}\n\t\t\t\tunicode = true\n\t\t\tdefault:\n\t\t\t\tinvalidFlags()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif unicode {\n\t\tpatternStr = convertRegexpToUnicode(patternStr)\n\t} else {\n\t\tpatternStr = convertRegexpToUtf16(patternStr)\n\t}\n\n\tre2Str, err1 := parser.TransformRegExp(patternStr, dotAll, unicode)\n\tif err1 == nil {\n\t\tre2flags := \"\"\n\t\tif multiline {\n\t\t\tre2flags += \"m\"\n\t\t}\n\t\tif dotAll {\n\t\t\tre2flags += \"s\"\n\t\t}\n\t\tif ignoreCase {\n\t\t\tre2flags += \"i\"\n\t\t}\n\t\tif len(re2flags) > 0 {\n\t\t\tre2Str = fmt.Sprintf(\"(?%s:%s)\", re2flags, re2Str)\n\t\t}\n\n\t\tpattern, err1 := regexp.Compile(re2Str)\n\t\tif err1 != nil {\n\t\t\terr = fmt.Errorf(\"Invalid regular expression (re2): %s (%v)\", re2Str, err1)\n\t\t\treturn\n\t\t}\n\t\twrapper = (*regexpWrapper)(pattern)\n\t} else {\n\t\tif _, incompat := err1.(parser.RegexpErrorIncompatible); !incompat {\n\t\t\terr = err1\n\t\t\treturn\n\t\t}\n\t\twrapper2, err = compileRegexp2(patternStr, multiline, dotAll, ignoreCase, unicode)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"Invalid regular expression (regexp2): %s (%v)\", patternStr, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tp = &regexpPattern{\n\t\tsrc:            patternStr,\n\t\tregexpWrapper:  wrapper,\n\t\tregexp2Wrapper: wrapper2,\n\t\tglobal:         global,\n\t\tignoreCase:     ignoreCase,\n\t\tmultiline:      multiline,\n\t\tdotAll:         dotAll,\n\t\tsticky:         sticky,\n\t\tunicode:        unicode,\n\t}\n\treturn\n}\n\nfunc (r *Runtime) _newRegExp(patternStr String, flags string, proto *Object) *regexpObject {\n\tpattern, err := compileRegexpFromValueString(patternStr, flags)\n\tif err != nil {\n\t\tpanic(r.newSyntaxError(err.Error(), -1))\n\t}\n\treturn r.newRegExpp(pattern, patternStr, proto)\n}\n\nfunc (r *Runtime) builtin_newRegExp(args []Value, proto *Object) *Object {\n\tvar patternVal, flagsVal Value\n\tif len(args) > 0 {\n\t\tpatternVal = args[0]\n\t}\n\tif len(args) > 1 {\n\t\tflagsVal = args[1]\n\t}\n\treturn r.newRegExp(patternVal, flagsVal, proto).val\n}\n\nfunc (r *Runtime) newRegExp(patternVal, flagsVal Value, proto *Object) *regexpObject {\n\tvar pattern String\n\tvar flags string\n\tif isRegexp(patternVal) { // this may have side effects so need to call it anyway\n\t\tif obj, ok := patternVal.(*Object); ok {\n\t\t\tif rx, ok := obj.self.(*regexpObject); ok {\n\t\t\t\tif flagsVal == nil || flagsVal == _undefined {\n\t\t\t\t\treturn rx.clone()\n\t\t\t\t} else {\n\t\t\t\t\treturn r._newRegExp(rx.source, flagsVal.toString().String(), proto)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpattern = nilSafe(obj.self.getStr(\"source\", nil)).toString()\n\t\t\t\tif flagsVal == nil || flagsVal == _undefined {\n\t\t\t\t\tflags = nilSafe(obj.self.getStr(\"flags\", nil)).toString().String()\n\t\t\t\t} else {\n\t\t\t\t\tflags = flagsVal.toString().String()\n\t\t\t\t}\n\t\t\t\tgoto exit\n\t\t\t}\n\t\t}\n\t}\n\n\tif patternVal != nil && patternVal != _undefined {\n\t\tpattern = patternVal.toString()\n\t}\n\tif flagsVal != nil && flagsVal != _undefined {\n\t\tflags = flagsVal.toString().String()\n\t}\n\n\tif pattern == nil {\n\t\tpattern = stringEmpty\n\t}\nexit:\n\treturn r._newRegExp(pattern, flags, proto)\n}\n\nfunc (r *Runtime) builtin_RegExp(call FunctionCall) Value {\n\tpattern := call.Argument(0)\n\tpatternIsRegExp := isRegexp(pattern)\n\tflags := call.Argument(1)\n\tif patternIsRegExp && flags == _undefined {\n\t\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\t\tpatternConstructor := obj.self.getStr(\"constructor\", nil)\n\t\t\tif patternConstructor == r.global.RegExp {\n\t\t\t\treturn pattern\n\t\t\t}\n\t\t}\n\t}\n\treturn r.newRegExp(pattern, flags, r.getRegExpPrototype()).val\n}\n\nfunc (r *Runtime) regexpproto_compile(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tvar (\n\t\t\tpattern *regexpPattern\n\t\t\tsource  String\n\t\t\tflags   string\n\t\t\terr     error\n\t\t)\n\t\tpatternVal := call.Argument(0)\n\t\tflagsVal := call.Argument(1)\n\t\tif o, ok := patternVal.(*Object); ok {\n\t\t\tif p, ok := o.self.(*regexpObject); ok {\n\t\t\t\tif flagsVal != _undefined {\n\t\t\t\t\tpanic(r.NewTypeError(\"Cannot supply flags when constructing one RegExp from another\"))\n\t\t\t\t}\n\t\t\t\tthis.pattern = p.pattern\n\t\t\t\tthis.source = p.source\n\t\t\t\tgoto exit\n\t\t\t}\n\t\t}\n\t\tif patternVal != _undefined {\n\t\t\tsource = patternVal.toString()\n\t\t} else {\n\t\t\tsource = stringEmpty\n\t\t}\n\t\tif flagsVal != _undefined {\n\t\t\tflags = flagsVal.toString().String()\n\t\t}\n\t\tpattern, err = compileRegexpFromValueString(source, flags)\n\t\tif err != nil {\n\t\t\tpanic(r.newSyntaxError(err.Error(), -1))\n\t\t}\n\t\tthis.pattern = pattern\n\t\tthis.source = source\n\texit:\n\t\tthis.setOwnStr(\"lastIndex\", intToValue(0), true)\n\t\treturn call.This\n\t}\n\n\tpanic(r.NewTypeError(\"Method RegExp.prototype.compile called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) regexpproto_exec(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\treturn this.exec(call.Argument(0).toString())\n\t} else {\n\t\tr.typeErrorResult(true, \"Method RegExp.prototype.exec called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This}))\n\t\treturn nil\n\t}\n}\n\nfunc (r *Runtime) regexpproto_test(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.test(call.Argument(0).toString()) {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.test called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_toString(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif this := r.checkStdRegexp(obj); this != nil {\n\t\tvar sb StringBuilder\n\t\tsb.WriteRune('/')\n\t\tif !this.writeEscapedSource(&sb) {\n\t\t\tsb.WriteString(this.source)\n\t\t}\n\t\tsb.WriteRune('/')\n\t\tif this.pattern.global {\n\t\t\tsb.WriteRune('g')\n\t\t}\n\t\tif this.pattern.ignoreCase {\n\t\t\tsb.WriteRune('i')\n\t\t}\n\t\tif this.pattern.multiline {\n\t\t\tsb.WriteRune('m')\n\t\t}\n\t\tif this.pattern.dotAll {\n\t\t\tsb.WriteRune('s')\n\t\t}\n\t\tif this.pattern.unicode {\n\t\t\tsb.WriteRune('u')\n\t\t}\n\t\tif this.pattern.sticky {\n\t\t\tsb.WriteRune('y')\n\t\t}\n\t\treturn sb.String()\n\t}\n\tpattern := nilSafe(obj.self.getStr(\"source\", nil)).toString()\n\tflags := nilSafe(obj.self.getStr(\"flags\", nil)).toString()\n\tvar sb StringBuilder\n\tsb.WriteRune('/')\n\tsb.WriteString(pattern)\n\tsb.WriteRune('/')\n\tsb.WriteString(flags)\n\treturn sb.String()\n}\n\nfunc (r *regexpObject) writeEscapedSource(sb *StringBuilder) bool {\n\tif r.source.Length() == 0 {\n\t\tsb.WriteString(asciiString(\"(?:)\"))\n\t\treturn true\n\t}\n\tpos := 0\n\tlastPos := 0\n\trd := &lenientUtf16Decoder{utf16Reader: r.source.utf16Reader()}\nL:\n\tfor {\n\t\tc, size, err := rd.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tswitch c {\n\t\tcase '\\\\':\n\t\t\tpos++\n\t\t\t_, size, err = rd.ReadRune()\n\t\t\tif err != nil {\n\t\t\t\tbreak L\n\t\t\t}\n\t\tcase '/', '\\u000a', '\\u000d', '\\u2028', '\\u2029':\n\t\t\tsb.WriteSubstring(r.source, lastPos, pos)\n\t\t\tsb.WriteRune('\\\\')\n\t\t\tswitch c {\n\t\t\tcase '\\u000a':\n\t\t\t\tsb.WriteRune('n')\n\t\t\tcase '\\u000d':\n\t\t\t\tsb.WriteRune('r')\n\t\t\tdefault:\n\t\t\t\tsb.WriteRune('u')\n\t\t\t\tsb.WriteRune(rune(hex[c>>12]))\n\t\t\t\tsb.WriteRune(rune(hex[(c>>8)&0xF]))\n\t\t\t\tsb.WriteRune(rune(hex[(c>>4)&0xF]))\n\t\t\t\tsb.WriteRune(rune(hex[c&0xF]))\n\t\t\t}\n\t\t\tlastPos = pos + size\n\t\t}\n\t\tpos += size\n\t}\n\tif lastPos > 0 {\n\t\tsb.WriteSubstring(r.source, lastPos, r.source.Length())\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (r *Runtime) regexpproto_getSource(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tvar sb StringBuilder\n\t\tif this.writeEscapedSource(&sb) {\n\t\t\treturn sb.String()\n\t\t}\n\t\treturn this.source\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn asciiString(\"(?:)\")\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.source getter called on incompatible receiver\"))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getGlobal(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.global {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.global getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getMultiline(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.multiline {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.multiline getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getDotAll(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.dotAll {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.dotAll getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getIgnoreCase(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.ignoreCase {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.ignoreCase getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getUnicode(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.unicode {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.unicode getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getSticky(call FunctionCall) Value {\n\tif this, ok := r.toObject(call.This).self.(*regexpObject); ok {\n\t\tif this.pattern.sticky {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else if call.This == r.global.RegExpPrototype {\n\t\treturn _undefined\n\t} else {\n\t\tpanic(r.NewTypeError(\"Method RegExp.prototype.sticky getter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n}\n\nfunc (r *Runtime) regexpproto_getFlags(call FunctionCall) Value {\n\tvar global, ignoreCase, multiline, dotAll, sticky, unicode bool\n\n\tthisObj := r.toObject(call.This)\n\tsize := 0\n\tif v := thisObj.self.getStr(\"global\", nil); v != nil {\n\t\tglobal = v.ToBoolean()\n\t\tif global {\n\t\t\tsize++\n\t\t}\n\t}\n\tif v := thisObj.self.getStr(\"ignoreCase\", nil); v != nil {\n\t\tignoreCase = v.ToBoolean()\n\t\tif ignoreCase {\n\t\t\tsize++\n\t\t}\n\t}\n\tif v := thisObj.self.getStr(\"multiline\", nil); v != nil {\n\t\tmultiline = v.ToBoolean()\n\t\tif multiline {\n\t\t\tsize++\n\t\t}\n\t}\n\tif v := thisObj.self.getStr(\"dotAll\", nil); v != nil {\n\t\tdotAll = v.ToBoolean()\n\t\tif dotAll {\n\t\t\tsize++\n\t\t}\n\t}\n\tif v := thisObj.self.getStr(\"sticky\", nil); v != nil {\n\t\tsticky = v.ToBoolean()\n\t\tif sticky {\n\t\t\tsize++\n\t\t}\n\t}\n\tif v := thisObj.self.getStr(\"unicode\", nil); v != nil {\n\t\tunicode = v.ToBoolean()\n\t\tif unicode {\n\t\t\tsize++\n\t\t}\n\t}\n\n\tvar sb strings.Builder\n\tsb.Grow(size)\n\tif global {\n\t\tsb.WriteByte('g')\n\t}\n\tif ignoreCase {\n\t\tsb.WriteByte('i')\n\t}\n\tif multiline {\n\t\tsb.WriteByte('m')\n\t}\n\tif dotAll {\n\t\tsb.WriteByte('s')\n\t}\n\tif unicode {\n\t\tsb.WriteByte('u')\n\t}\n\tif sticky {\n\t\tsb.WriteByte('y')\n\t}\n\n\treturn asciiString(sb.String())\n}\n\nfunc (r *Runtime) regExpExec(execFn func(FunctionCall) Value, rxObj *Object, arg Value) Value {\n\tres := execFn(FunctionCall{\n\t\tThis:      rxObj,\n\t\tArguments: []Value{arg},\n\t})\n\n\tif res != _null {\n\t\tif _, ok := res.(*Object); !ok {\n\t\t\tpanic(r.NewTypeError(\"RegExp exec method returned something other than an Object or null\"))\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc (r *Runtime) getGlobalRegexpMatches(rxObj *Object, s String, fullUnicode bool) []Value {\n\trxObj.self.setOwnStr(\"lastIndex\", intToValue(0), true)\n\texecFn, ok := r.toObject(rxObj.self.getStr(\"exec\", nil)).self.assertCallable()\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"exec is not a function\"))\n\t}\n\tvar a []Value\n\tfor {\n\t\tres := r.regExpExec(execFn, rxObj, s)\n\t\tif res == _null {\n\t\t\tbreak\n\t\t}\n\t\ta = append(a, res)\n\t\tmatchStr := nilSafe(r.toObject(res).self.getIdx(valueInt(0), nil)).toString()\n\t\tif matchStr.Length() == 0 {\n\t\t\tthisIndex := toLength(rxObj.self.getStr(\"lastIndex\", nil))\n\t\t\trxObj.self.setOwnStr(\"lastIndex\", valueInt(advanceStringIndex64(s, thisIndex, fullUnicode)), true)\n\t\t}\n\t}\n\n\treturn a\n}\n\nfunc (r *Runtime) regexpproto_stdMatcherGeneric(rxObj *Object, s String) Value {\n\trx := rxObj.self\n\tflags := nilSafe(rx.getStr(\"flags\", nil)).String()\n\tglobal := strings.ContainsRune(flags, 'g')\n\tif global {\n\t\ta := r.getGlobalRegexpMatches(rxObj, s, strings.ContainsRune(flags, 'u'))\n\t\tif len(a) == 0 {\n\t\t\treturn _null\n\t\t}\n\t\tar := make([]Value, 0, len(a))\n\t\tfor _, result := range a {\n\t\t\tobj := r.toObject(result)\n\t\t\tmatchStr := nilSafe(obj.self.getIdx(valueInt(0), nil)).ToString()\n\t\t\tar = append(ar, matchStr)\n\t\t}\n\t\treturn r.newArrayValues(ar)\n\t}\n\n\texecFn, ok := r.toObject(rx.getStr(\"exec\", nil)).self.assertCallable()\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"exec is not a function\"))\n\t}\n\n\treturn r.regExpExec(execFn, rxObj, s)\n}\n\nfunc (r *Runtime) checkStdRegexp(rxObj *Object) *regexpObject {\n\tif deoptimiseRegexp {\n\t\treturn nil\n\t}\n\n\trx, ok := rxObj.self.(*regexpObject)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif !rx.standard || rx.prototype == nil || rx.prototype.self != r.global.stdRegexpProto {\n\t\treturn nil\n\t}\n\n\treturn rx\n}\n\nfunc (r *Runtime) regexpproto_stdMatcher(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\ts := call.Argument(0).toString()\n\trx := r.checkStdRegexp(thisObj)\n\tif rx == nil {\n\t\treturn r.regexpproto_stdMatcherGeneric(thisObj, s)\n\t}\n\tif rx.pattern.global {\n\t\tres := rx.pattern.findAllSubmatchIndex(s, 0, -1, rx.pattern.sticky)\n\t\tif len(res) == 0 {\n\t\t\trx.setOwnStr(\"lastIndex\", intToValue(0), true)\n\t\t\treturn _null\n\t\t}\n\t\ta := make([]Value, 0, len(res))\n\t\tfor _, result := range res {\n\t\t\ta = append(a, s.Substring(result[0], result[1]))\n\t\t}\n\t\trx.setOwnStr(\"lastIndex\", intToValue(int64(res[len(res)-1][1])), true)\n\t\treturn r.newArrayValues(a)\n\t} else {\n\t\treturn rx.exec(s)\n\t}\n}\n\nfunc (r *Runtime) regexpproto_stdSearchGeneric(rxObj *Object, arg String) Value {\n\trx := rxObj.self\n\tpreviousLastIndex := nilSafe(rx.getStr(\"lastIndex\", nil))\n\tzero := intToValue(0)\n\tif !previousLastIndex.SameAs(zero) {\n\t\trx.setOwnStr(\"lastIndex\", zero, true)\n\t}\n\texecFn, ok := r.toObject(rx.getStr(\"exec\", nil)).self.assertCallable()\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"exec is not a function\"))\n\t}\n\n\tresult := r.regExpExec(execFn, rxObj, arg)\n\tcurrentLastIndex := nilSafe(rx.getStr(\"lastIndex\", nil))\n\tif !currentLastIndex.SameAs(previousLastIndex) {\n\t\trx.setOwnStr(\"lastIndex\", previousLastIndex, true)\n\t}\n\n\tif result == _null {\n\t\treturn intToValue(-1)\n\t}\n\n\treturn r.toObject(result).self.getStr(\"index\", nil)\n}\n\nfunc (r *Runtime) regexpproto_stdMatcherAll(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\ts := call.Argument(0).toString()\n\tflags := nilSafe(thisObj.self.getStr(\"flags\", nil)).toString()\n\tc := r.speciesConstructorObj(call.This.(*Object), r.getRegExp())\n\tmatcher := r.toConstructor(c)([]Value{call.This, flags}, nil)\n\tmatcher.self.setOwnStr(\"lastIndex\", valueInt(toLength(thisObj.self.getStr(\"lastIndex\", nil))), true)\n\tflagsStr := flags.String()\n\tglobal := strings.Contains(flagsStr, \"g\")\n\tfullUnicode := strings.Contains(flagsStr, \"u\")\n\treturn r.createRegExpStringIterator(matcher, s, global, fullUnicode)\n}\n\nfunc (r *Runtime) createRegExpStringIterator(matcher *Object, s String, global, fullUnicode bool) Value {\n\to := &Object{runtime: r}\n\n\tri := &regExpStringIterObject{\n\t\tmatcher:     matcher,\n\t\ts:           s,\n\t\tglobal:      global,\n\t\tfullUnicode: fullUnicode,\n\t}\n\tri.class = classObject\n\tri.val = o\n\tri.extensible = true\n\to.self = ri\n\tri.prototype = r.getRegExpStringIteratorPrototype()\n\tri.init()\n\n\treturn o\n}\n\ntype regExpStringIterObject struct {\n\tbaseObject\n\tmatcher                   *Object\n\ts                         String\n\tglobal, fullUnicode, done bool\n}\n\n// RegExpExec as defined in 21.2.5.2.1\nfunc regExpExec(r *Object, s String) Value {\n\texec := r.self.getStr(\"exec\", nil)\n\tif execObject, ok := exec.(*Object); ok {\n\t\tif execFn, ok := execObject.self.assertCallable(); ok {\n\t\t\treturn r.runtime.regExpExec(execFn, r, s)\n\t\t}\n\t}\n\tif rx, ok := r.self.(*regexpObject); ok {\n\t\treturn rx.exec(s)\n\t}\n\tpanic(r.runtime.NewTypeError(\"no RegExpMatcher internal slot\"))\n}\n\nfunc (ri *regExpStringIterObject) next() (v Value) {\n\tif ri.done {\n\t\treturn ri.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\n\tmatch := regExpExec(ri.matcher, ri.s)\n\tif IsNull(match) {\n\t\tri.done = true\n\t\treturn ri.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\tif !ri.global {\n\t\tri.done = true\n\t\treturn ri.val.runtime.createIterResultObject(match, false)\n\t}\n\n\tmatchStr := nilSafe(ri.val.runtime.toObject(match).self.getIdx(valueInt(0), nil)).toString()\n\tif matchStr.Length() == 0 {\n\t\tthisIndex := toLength(ri.matcher.self.getStr(\"lastIndex\", nil))\n\t\tri.matcher.self.setOwnStr(\"lastIndex\", valueInt(advanceStringIndex64(ri.s, thisIndex, ri.fullUnicode)), true)\n\t}\n\treturn ri.val.runtime.createIterResultObject(match, false)\n}\n\nfunc (r *Runtime) regexpproto_stdSearch(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\ts := call.Argument(0).toString()\n\trx := r.checkStdRegexp(thisObj)\n\tif rx == nil {\n\t\treturn r.regexpproto_stdSearchGeneric(thisObj, s)\n\t}\n\n\tpreviousLastIndex := rx.getStr(\"lastIndex\", nil)\n\trx.setOwnStr(\"lastIndex\", intToValue(0), true)\n\n\tmatch, result := rx.execRegexp(s)\n\trx.setOwnStr(\"lastIndex\", previousLastIndex, true)\n\n\tif !match {\n\t\treturn intToValue(-1)\n\t}\n\treturn intToValue(int64(result[0]))\n}\n\nfunc (r *Runtime) regexpproto_stdSplitterGeneric(splitter *Object, s String, limit Value, unicodeMatching bool) Value {\n\tvar a []Value\n\tvar lim int64\n\tif limit == nil || limit == _undefined {\n\t\tlim = maxInt - 1\n\t} else {\n\t\tlim = toLength(limit)\n\t}\n\tif lim == 0 {\n\t\treturn r.newArrayValues(a)\n\t}\n\tsize := s.Length()\n\tp := 0\n\texecFn := toMethod(splitter.ToObject(r).self.getStr(\"exec\", nil)) // must be non-nil\n\n\tif size == 0 {\n\t\tif r.regExpExec(execFn, splitter, s) == _null {\n\t\t\ta = append(a, s)\n\t\t}\n\t\treturn r.newArrayValues(a)\n\t}\n\n\tq := p\n\tfor q < size {\n\t\tsplitter.self.setOwnStr(\"lastIndex\", intToValue(int64(q)), true)\n\t\tz := r.regExpExec(execFn, splitter, s)\n\t\tif z == _null {\n\t\t\tq = advanceStringIndex(s, q, unicodeMatching)\n\t\t} else {\n\t\t\tz := r.toObject(z)\n\t\t\te := toLength(splitter.self.getStr(\"lastIndex\", nil))\n\t\t\tif e == int64(p) {\n\t\t\t\tq = advanceStringIndex(s, q, unicodeMatching)\n\t\t\t} else {\n\t\t\t\ta = append(a, s.Substring(p, q))\n\t\t\t\tif int64(len(a)) == lim {\n\t\t\t\t\treturn r.newArrayValues(a)\n\t\t\t\t}\n\t\t\t\tif e > int64(size) {\n\t\t\t\t\tp = size\n\t\t\t\t} else {\n\t\t\t\t\tp = int(e)\n\t\t\t\t}\n\t\t\t\tnumberOfCaptures := max(toLength(z.self.getStr(\"length\", nil))-1, 0)\n\t\t\t\tfor i := int64(1); i <= numberOfCaptures; i++ {\n\t\t\t\t\ta = append(a, nilSafe(z.self.getIdx(valueInt(i), nil)))\n\t\t\t\t\tif int64(len(a)) == lim {\n\t\t\t\t\t\treturn r.newArrayValues(a)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p\n\t\t\t}\n\t\t}\n\t}\n\ta = append(a, s.Substring(p, size))\n\treturn r.newArrayValues(a)\n}\n\nfunc advanceStringIndex(s String, pos int, unicode bool) int {\n\tnext := pos + 1\n\tif !unicode {\n\t\treturn next\n\t}\n\tl := s.Length()\n\tif next >= l {\n\t\treturn next\n\t}\n\tif !isUTF16FirstSurrogate(s.CharAt(pos)) {\n\t\treturn next\n\t}\n\tif !isUTF16SecondSurrogate(s.CharAt(next)) {\n\t\treturn next\n\t}\n\treturn next + 1\n}\n\nfunc advanceStringIndex64(s String, pos int64, unicode bool) int64 {\n\tnext := pos + 1\n\tif !unicode {\n\t\treturn next\n\t}\n\tl := int64(s.Length())\n\tif next >= l {\n\t\treturn next\n\t}\n\tif !isUTF16FirstSurrogate(s.CharAt(int(pos))) {\n\t\treturn next\n\t}\n\tif !isUTF16SecondSurrogate(s.CharAt(int(next))) {\n\t\treturn next\n\t}\n\treturn next + 1\n}\n\nfunc (r *Runtime) regexpproto_stdSplitter(call FunctionCall) Value {\n\trxObj := r.toObject(call.This)\n\ts := call.Argument(0).toString()\n\tlimitValue := call.Argument(1)\n\tvar splitter *Object\n\tsearch := r.checkStdRegexp(rxObj)\n\tc := r.speciesConstructorObj(rxObj, r.getRegExp())\n\tif search == nil || c != r.global.RegExp {\n\t\tflags := nilSafe(rxObj.self.getStr(\"flags\", nil)).toString()\n\t\tflagsStr := flags.String()\n\n\t\t// Add 'y' flag if missing\n\t\tif !strings.Contains(flagsStr, \"y\") {\n\t\t\tflags = flags.Concat(asciiString(\"y\"))\n\t\t}\n\t\tsplitter = r.toConstructor(c)([]Value{rxObj, flags}, nil)\n\t\tsearch = r.checkStdRegexp(splitter)\n\t\tif search == nil {\n\t\t\treturn r.regexpproto_stdSplitterGeneric(splitter, s, limitValue, strings.Contains(flagsStr, \"u\"))\n\t\t}\n\t}\n\n\tpattern := search.pattern // toUint32() may recompile the pattern, but we still need to use the original\n\tlimit := -1\n\tif limitValue != _undefined {\n\t\tlimit = int(toUint32(limitValue))\n\t}\n\n\tif limit == 0 {\n\t\treturn r.newArrayValues(nil)\n\t}\n\n\ttargetLength := s.Length()\n\tvar valueArray []Value\n\tlastIndex := 0\n\tfound := 0\n\n\tresult := pattern.findAllSubmatchIndex(s, 0, -1, false)\n\tif targetLength == 0 {\n\t\tif result == nil {\n\t\t\tvalueArray = append(valueArray, s)\n\t\t}\n\t\tgoto RETURN\n\t}\n\n\tfor _, match := range result {\n\t\tif match[0] == match[1] {\n\t\t\t// FIXME Ugh, this is a hack\n\t\t\tif match[0] == 0 || match[0] == targetLength {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif lastIndex != match[0] {\n\t\t\tvalueArray = append(valueArray, s.Substring(lastIndex, match[0]))\n\t\t\tfound++\n\t\t} else if lastIndex == match[0] {\n\t\t\tif lastIndex != -1 {\n\t\t\t\tvalueArray = append(valueArray, stringEmpty)\n\t\t\t\tfound++\n\t\t\t}\n\t\t}\n\n\t\tlastIndex = match[1]\n\t\tif found == limit {\n\t\t\tgoto RETURN\n\t\t}\n\n\t\tcaptureCount := len(match) / 2\n\t\tfor index := 1; index < captureCount; index++ {\n\t\t\toffset := index * 2\n\t\t\tvar value Value\n\t\t\tif match[offset] != -1 {\n\t\t\t\tvalue = s.Substring(match[offset], match[offset+1])\n\t\t\t} else {\n\t\t\t\tvalue = _undefined\n\t\t\t}\n\t\t\tvalueArray = append(valueArray, value)\n\t\t\tfound++\n\t\t\tif found == limit {\n\t\t\t\tgoto RETURN\n\t\t\t}\n\t\t}\n\t}\n\n\tif found != limit {\n\t\tif lastIndex != targetLength {\n\t\t\tvalueArray = append(valueArray, s.Substring(lastIndex, targetLength))\n\t\t} else {\n\t\t\tvalueArray = append(valueArray, stringEmpty)\n\t\t}\n\t}\n\nRETURN:\n\treturn r.newArrayValues(valueArray)\n}\n\nfunc (r *Runtime) regexpproto_stdReplacerGeneric(rxObj *Object, s, replaceStr String, rcall func(FunctionCall) Value) Value {\n\tvar results []Value\n\tflags := nilSafe(rxObj.self.getStr(\"flags\", nil)).String()\n\tisGlobal := strings.ContainsRune(flags, 'g')\n\tisUnicode := strings.ContainsRune(flags, 'u')\n\tif isGlobal {\n\t\tresults = r.getGlobalRegexpMatches(rxObj, s, isUnicode)\n\t} else {\n\t\texecFn := toMethod(rxObj.self.getStr(\"exec\", nil)) // must be non-nil\n\t\tresult := r.regExpExec(execFn, rxObj, s)\n\t\tif result != _null {\n\t\t\tresults = append(results, result)\n\t\t}\n\t}\n\tlengthS := s.Length()\n\tnextSourcePosition := 0\n\tvar resultBuf StringBuilder\n\tfor _, result := range results {\n\t\tobj := r.toObject(result)\n\t\tnCaptures := max(toLength(obj.self.getStr(\"length\", nil))-1, 0)\n\t\tmatched := nilSafe(obj.self.getIdx(valueInt(0), nil)).toString()\n\t\tmatchLength := matched.Length()\n\t\tposition := toIntStrict(max(min(nilSafe(obj.self.getStr(\"index\", nil)).ToInteger(), int64(lengthS)), 0))\n\t\tvar captures []Value\n\t\tif rcall != nil {\n\t\t\tcaptures = make([]Value, 0, nCaptures+3)\n\t\t} else {\n\t\t\tcaptures = make([]Value, 0, nCaptures+1)\n\t\t}\n\t\tcaptures = append(captures, matched)\n\t\tfor n := int64(1); n <= nCaptures; n++ {\n\t\t\tcapN := nilSafe(obj.self.getIdx(valueInt(n), nil))\n\t\t\tif capN != _undefined {\n\t\t\t\tcapN = capN.ToString()\n\t\t\t}\n\t\t\tcaptures = append(captures, capN)\n\t\t}\n\t\tvar replacement String\n\t\tif rcall != nil {\n\t\t\tcaptures = append(captures, intToValue(int64(position)), s)\n\t\t\treplacement = rcall(FunctionCall{\n\t\t\t\tThis:      _undefined,\n\t\t\t\tArguments: captures,\n\t\t\t}).toString()\n\t\t\tif position >= nextSourcePosition {\n\t\t\t\tresultBuf.WriteString(s.Substring(nextSourcePosition, position))\n\t\t\t\tresultBuf.WriteString(replacement)\n\t\t\t\tnextSourcePosition = position + matchLength\n\t\t\t}\n\t\t} else {\n\t\t\tif position >= nextSourcePosition {\n\t\t\t\tresultBuf.WriteString(s.Substring(nextSourcePosition, position))\n\t\t\t\twriteSubstitution(s, position, len(captures), func(idx int) String {\n\t\t\t\t\tcapture := captures[idx]\n\t\t\t\t\tif capture != _undefined {\n\t\t\t\t\t\treturn capture.toString()\n\t\t\t\t\t}\n\t\t\t\t\treturn stringEmpty\n\t\t\t\t}, replaceStr, &resultBuf)\n\t\t\t\tnextSourcePosition = position + matchLength\n\t\t\t}\n\t\t}\n\t}\n\tif nextSourcePosition < lengthS {\n\t\tresultBuf.WriteString(s.Substring(nextSourcePosition, lengthS))\n\t}\n\treturn resultBuf.String()\n}\n\nfunc writeSubstitution(s String, position int, numCaptures int, getCapture func(int) String, replaceStr String, buf *StringBuilder) {\n\tl := s.Length()\n\trl := replaceStr.Length()\n\tmatched := getCapture(0)\n\ttailPos := position + matched.Length()\n\n\tfor i := 0; i < rl; i++ {\n\t\tc := replaceStr.CharAt(i)\n\t\tif c == '$' && i < rl-1 {\n\t\t\tch := replaceStr.CharAt(i + 1)\n\t\t\tswitch ch {\n\t\t\tcase '$':\n\t\t\t\tbuf.WriteRune('$')\n\t\t\tcase '`':\n\t\t\t\tbuf.WriteString(s.Substring(0, position))\n\t\t\tcase '\\'':\n\t\t\t\tif tailPos < l {\n\t\t\t\t\tbuf.WriteString(s.Substring(tailPos, l))\n\t\t\t\t}\n\t\t\tcase '&':\n\t\t\t\tbuf.WriteString(matched)\n\t\t\tdefault:\n\t\t\t\tmatchNumber := 0\n\t\t\t\tj := i + 1\n\t\t\t\tfor j < rl {\n\t\t\t\t\tch := replaceStr.CharAt(j)\n\t\t\t\t\tif ch >= '0' && ch <= '9' {\n\t\t\t\t\t\tm := matchNumber*10 + int(ch-'0')\n\t\t\t\t\t\tif m >= numCaptures {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatchNumber = m\n\t\t\t\t\t\tj++\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif matchNumber > 0 {\n\t\t\t\t\tbuf.WriteString(getCapture(matchNumber))\n\t\t\t\t\ti = j - 1\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tbuf.WriteRune('$')\n\t\t\t\t\tbuf.WriteRune(rune(ch))\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t} else {\n\t\t\tbuf.WriteRune(rune(c))\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) regexpproto_stdReplacer(call FunctionCall) Value {\n\trxObj := r.toObject(call.This)\n\ts := call.Argument(0).toString()\n\treplaceStr, rcall := getReplaceValue(call.Argument(1))\n\n\trx := r.checkStdRegexp(rxObj)\n\tif rx == nil {\n\t\treturn r.regexpproto_stdReplacerGeneric(rxObj, s, replaceStr, rcall)\n\t}\n\n\tvar index int64\n\tfind := 1\n\tif rx.pattern.global {\n\t\tfind = -1\n\t\trx.setOwnStr(\"lastIndex\", intToValue(0), true)\n\t} else {\n\t\tindex = rx.getLastIndex()\n\t}\n\tfound := rx.pattern.findAllSubmatchIndex(s, toIntStrict(index), find, rx.pattern.sticky)\n\tif len(found) > 0 {\n\t\tif !rx.updateLastIndex(index, found[0], found[len(found)-1]) {\n\t\t\tfound = nil\n\t\t}\n\t} else {\n\t\trx.updateLastIndex(index, nil, nil)\n\t}\n\n\treturn stringReplace(s, found, replaceStr, rcall)\n}\n\nfunc (r *Runtime) regExpStringIteratorProto_next(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif iter, ok := thisObj.self.(*regExpStringIterObject); ok {\n\t\treturn iter.next()\n\t}\n\tpanic(r.NewTypeError(\"Method RegExp String Iterator.prototype.next called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc (r *Runtime) createRegExpStringIteratorPrototype(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"next\", r.newNativeFunc(r.regExpStringIteratorProto_next, \"next\", 0), true, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classRegExpStringIterator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getRegExpStringIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.RegExpStringIteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.RegExpStringIteratorPrototype = o\n\t\to.self = r.createRegExpStringIteratorPrototype(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) getRegExp() *Object {\n\tret := r.global.RegExp\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.RegExp = ret\n\t\tproto := r.getRegExpPrototype()\n\t\tr.newNativeFuncAndConstruct(ret, r.builtin_RegExp,\n\t\t\tr.wrapNativeConstruct(r.builtin_newRegExp, ret, proto), proto, \"RegExp\", intToValue(2))\n\t\trx := ret.self\n\t\tr.putSpeciesReturnThis(rx)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getRegExpPrototype() *Object {\n\tret := r.global.RegExpPrototype\n\tif ret == nil {\n\t\to := r.newGuardedObject(r.global.ObjectPrototype, classObject)\n\t\tret = o.val\n\t\tr.global.RegExpPrototype = ret\n\t\tr.global.stdRegexpProto = o\n\n\t\to._putProp(\"constructor\", r.getRegExp(), true, false, true)\n\t\to._putProp(\"compile\", r.newNativeFunc(r.regexpproto_compile, \"compile\", 2), true, false, true)\n\t\to._putProp(\"exec\", r.newNativeFunc(r.regexpproto_exec, \"exec\", 1), true, false, true)\n\t\to._putProp(\"test\", r.newNativeFunc(r.regexpproto_test, \"test\", 1), true, false, true)\n\t\to._putProp(\"toString\", r.newNativeFunc(r.regexpproto_toString, \"toString\", 0), true, false, true)\n\t\to.setOwnStr(\"source\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getSource, \"get source\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"global\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getGlobal, \"get global\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"multiline\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getMultiline, \"get multiline\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"dotAll\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getDotAll, \"get dotAll\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"ignoreCase\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getIgnoreCase, \"get ignoreCase\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"unicode\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getUnicode, \"get unicode\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"sticky\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getSticky, \"get sticky\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\t\to.setOwnStr(\"flags\", &valueProperty{\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.regexpproto_getFlags, \"get flags\", 0),\n\t\t\taccessor:     true,\n\t\t}, false)\n\n\t\to._putSym(SymMatch, valueProp(r.newNativeFunc(r.regexpproto_stdMatcher, \"[Symbol.match]\", 1), true, false, true))\n\t\to._putSym(SymMatchAll, valueProp(r.newNativeFunc(r.regexpproto_stdMatcherAll, \"[Symbol.matchAll]\", 1), true, false, true))\n\t\to._putSym(SymSearch, valueProp(r.newNativeFunc(r.regexpproto_stdSearch, \"[Symbol.search]\", 1), true, false, true))\n\t\to._putSym(SymSplit, valueProp(r.newNativeFunc(r.regexpproto_stdSplitter, \"[Symbol.split]\", 2), true, false, true))\n\t\to._putSym(SymReplace, valueProp(r.newNativeFunc(r.regexpproto_stdReplacer, \"[Symbol.replace]\", 2), true, false, true))\n\t\to.guard(\"exec\", \"global\", \"multiline\", \"ignoreCase\", \"unicode\", \"sticky\")\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_set.go",
          "type": "blob",
          "size": 8.9482421875,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar setExportType = reflectTypeArray\n\ntype setObject struct {\n\tbaseObject\n\tm *orderedMap\n}\n\ntype setIterObject struct {\n\tbaseObject\n\titer *orderedMapIter\n\tkind iterationKind\n}\n\nfunc (o *setIterObject) next() Value {\n\tif o.iter == nil {\n\t\treturn o.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\n\tentry := o.iter.next()\n\tif entry == nil {\n\t\to.iter = nil\n\t\treturn o.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\n\tvar result Value\n\tswitch o.kind {\n\tcase iterationKindValue:\n\t\tresult = entry.key\n\tdefault:\n\t\tresult = o.val.runtime.newArrayValues([]Value{entry.key, entry.key})\n\t}\n\n\treturn o.val.runtime.createIterResultObject(result, false)\n}\n\nfunc (so *setObject) init() {\n\tso.baseObject.init()\n\tso.m = newOrderedMap(so.val.runtime.getHash())\n}\n\nfunc (so *setObject) exportType() reflect.Type {\n\treturn setExportType\n}\n\nfunc (so *setObject) export(ctx *objectExportCtx) interface{} {\n\ta := make([]interface{}, so.m.size)\n\tctx.put(so.val, a)\n\titer := so.m.newIter()\n\tfor i := 0; i < len(a); i++ {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\ta[i] = exportValue(entry.key, ctx)\n\t}\n\treturn a\n}\n\nfunc (so *setObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tl := so.m.size\n\tif typ.Kind() == reflect.Array {\n\t\tif dst.Len() != l {\n\t\t\treturn fmt.Errorf(\"cannot convert a Set into an array, lengths mismatch: have %d, need %d)\", l, dst.Len())\n\t\t}\n\t} else {\n\t\tdst.Set(reflect.MakeSlice(typ, l, l))\n\t}\n\tctx.putTyped(so.val, typ, dst.Interface())\n\titer := so.m.newIter()\n\tr := so.val.runtime\n\tfor i := 0; i < l; i++ {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\terr := r.toReflectValue(entry.key, dst.Index(i), ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (so *setObject) exportToMap(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tdst.Set(reflect.MakeMap(typ))\n\tkeyTyp := typ.Key()\n\telemTyp := typ.Elem()\n\titer := so.m.newIter()\n\tr := so.val.runtime\n\tfor {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tkeyVal := reflect.New(keyTyp).Elem()\n\t\terr := r.toReflectValue(entry.key, keyVal, ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdst.SetMapIndex(keyVal, reflect.Zero(elemTyp))\n\t}\n\treturn nil\n}\n\nfunc (r *Runtime) setProto_add(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Set.prototype.add called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\tso.m.set(call.Argument(0), nil)\n\treturn call.This\n}\n\nfunc (r *Runtime) setProto_clear(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Set.prototype.clear called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\tso.m.clear()\n\treturn _undefined\n}\n\nfunc (r *Runtime) setProto_delete(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Set.prototype.delete called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\treturn r.toBoolean(so.m.remove(call.Argument(0)))\n}\n\nfunc (r *Runtime) setProto_entries(call FunctionCall) Value {\n\treturn r.createSetIterator(call.This, iterationKindKeyValue)\n}\n\nfunc (r *Runtime) setProto_forEach(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Set.prototype.forEach called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tcallbackFn, ok := r.toObject(call.Argument(0)).self.assertCallable()\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"object is not a function %s\"))\n\t}\n\tt := call.Argument(1)\n\titer := so.m.newIter()\n\tfor {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tcallbackFn(FunctionCall{This: t, Arguments: []Value{entry.key, entry.key, thisObj}})\n\t}\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) setProto_has(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method Set.prototype.has called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\treturn r.toBoolean(so.m.has(call.Argument(0)))\n}\n\nfunc (r *Runtime) setProto_getSize(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tso, ok := thisObj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method get Set.prototype.size called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\n\treturn intToValue(int64(so.m.size))\n}\n\nfunc (r *Runtime) setProto_values(call FunctionCall) Value {\n\treturn r.createSetIterator(call.This, iterationKindValue)\n}\n\nfunc (r *Runtime) builtin_newSet(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"Set\"))\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, r.global.Set, r.global.SetPrototype)\n\to := &Object{runtime: r}\n\n\tso := &setObject{}\n\tso.class = classObject\n\tso.val = o\n\tso.extensible = true\n\to.self = so\n\tso.prototype = proto\n\tso.init()\n\tif len(args) > 0 {\n\t\tif arg := args[0]; arg != nil && arg != _undefined && arg != _null {\n\t\t\tadder := so.getStr(\"add\", nil)\n\t\t\tstdArr := r.checkStdArrayIter(arg)\n\t\t\tif adder == r.global.setAdder {\n\t\t\t\tif stdArr != nil {\n\t\t\t\t\tfor _, v := range stdArr.values {\n\t\t\t\t\t\tso.m.set(v, nil)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr.getIterator(arg, nil).iterate(func(item Value) {\n\t\t\t\t\t\tso.m.set(item, nil)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadderFn := toMethod(adder)\n\t\t\t\tif adderFn == nil {\n\t\t\t\t\tpanic(r.NewTypeError(\"Set.add in missing\"))\n\t\t\t\t}\n\t\t\t\tif stdArr != nil {\n\t\t\t\t\tfor _, item := range stdArr.values {\n\t\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{item}})\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr.getIterator(arg, nil).iterate(func(item Value) {\n\t\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{item}})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createSetIterator(setValue Value, kind iterationKind) Value {\n\tobj := r.toObject(setValue)\n\tsetObj, ok := obj.self.(*setObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Object is not a Set\"))\n\t}\n\n\to := &Object{runtime: r}\n\n\tsi := &setIterObject{\n\t\titer: setObj.m.newIter(),\n\t\tkind: kind,\n\t}\n\tsi.class = classObject\n\tsi.val = o\n\tsi.extensible = true\n\to.self = si\n\tsi.prototype = r.getSetIteratorPrototype()\n\tsi.init()\n\n\treturn o\n}\n\nfunc (r *Runtime) setIterProto_next(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif iter, ok := thisObj.self.(*setIterObject); ok {\n\t\treturn iter.next()\n\t}\n\tpanic(r.NewTypeError(\"Method Set Iterator.prototype.next called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc (r *Runtime) createSetProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putProp(\"constructor\", r.getSet(), true, false, true)\n\tr.global.setAdder = r.newNativeFunc(r.setProto_add, \"add\", 1)\n\to._putProp(\"add\", r.global.setAdder, true, false, true)\n\n\to._putProp(\"clear\", r.newNativeFunc(r.setProto_clear, \"clear\", 0), true, false, true)\n\to._putProp(\"delete\", r.newNativeFunc(r.setProto_delete, \"delete\", 1), true, false, true)\n\to._putProp(\"forEach\", r.newNativeFunc(r.setProto_forEach, \"forEach\", 1), true, false, true)\n\to._putProp(\"has\", r.newNativeFunc(r.setProto_has, \"has\", 1), true, false, true)\n\to.setOwnStr(\"size\", &valueProperty{\n\t\tgetterFunc:   r.newNativeFunc(r.setProto_getSize, \"get size\", 0),\n\t\taccessor:     true,\n\t\twritable:     true,\n\t\tconfigurable: true,\n\t}, true)\n\n\tvaluesFunc := r.newNativeFunc(r.setProto_values, \"values\", 0)\n\to._putProp(\"values\", valuesFunc, true, false, true)\n\to._putProp(\"keys\", valuesFunc, true, false, true)\n\to._putProp(\"entries\", r.newNativeFunc(r.setProto_entries, \"entries\", 0), true, false, true)\n\to._putSym(SymIterator, valueProp(valuesFunc, true, false, true))\n\to._putSym(SymToStringTag, valueProp(asciiString(classSet), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createSet(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newSet, r.getSetPrototype(), \"Set\", 0)\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) createSetIterProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"next\", r.newNativeFunc(r.setIterProto_next, \"next\", 0), true, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classSetIterator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getSetIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.SetIteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.SetIteratorPrototype = o\n\t\to.self = r.createSetIterProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) getSetPrototype() *Object {\n\tret := r.global.SetPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.SetPrototype = ret\n\t\tret.self = r.createSetProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getSet() *Object {\n\tret := r.global.Set\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Set = ret\n\t\tret.self = r.createSet(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_set_test.go",
          "type": "blob",
          "size": 2.765625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSetEvilIterator(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {};\n\to[Symbol.iterator] = function() {\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\tif (!this.flag) {\n\t\t\t\t\tthis.flag = true;\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t\treturn {done: true};\n\t\t\t}\n\t\t}\n\t}\n\tnew Set(o);\n\tundefined;\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc ExampleRuntime_ExportTo_setToMap() {\n\tvm := New()\n\ts, err := vm.RunString(`\n\tnew Set([1, 2, 3])\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tm := make(map[int]struct{})\n\terr = vm.ExportTo(s, &m)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(m)\n\t// Output: map[1:{} 2:{} 3:{}]\n}\n\nfunc ExampleRuntime_ExportTo_setToSlice() {\n\tvm := New()\n\ts, err := vm.RunString(`\n\tnew Set([1, 2, 3])\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar a []int\n\terr = vm.ExportTo(s, &a)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(a)\n\t// Output: [1 2 3]\n}\n\nfunc TestSetExportToSliceCircular(t *testing.T) {\n\tvm := New()\n\ts, err := vm.RunString(`\n\tlet s = new Set();\n\ts.add(s);\n\ts;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar a []Value\n\terr = vm.ExportTo(s, &a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(a) != 1 {\n\t\tt.Fatalf(\"len: %d\", len(a))\n\t}\n\tif a[0] != s {\n\t\tt.Fatalf(\"a: %v\", a)\n\t}\n}\n\nfunc TestSetExportToArrayMismatchedLengths(t *testing.T) {\n\tvm := New()\n\ts, err := vm.RunString(`\n\tnew Set([1, 2])\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar s1 [3]int\n\terr = vm.ExportTo(s, &s1)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif msg := err.Error(); !strings.Contains(msg, \"lengths mismatch\") {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc TestSetExportToNilMap(t *testing.T) {\n\tvm := New()\n\tvar m map[int]interface{}\n\tres, err := vm.RunString(\"new Set([1])\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = vm.ExportTo(res, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(m) != 1 {\n\t\tt.Fatal(m)\n\t}\n\tif _, exists := m[1]; !exists {\n\t\tt.Fatal(m)\n\t}\n}\n\nfunc TestSetExportToNonNilMap(t *testing.T) {\n\tvm := New()\n\tm := map[int]interface{}{\n\t\t2: true,\n\t}\n\tres, err := vm.RunString(\"new Set([1])\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = vm.ExportTo(res, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(m) != 1 {\n\t\tt.Fatal(m)\n\t}\n\tif _, exists := m[1]; !exists {\n\t\tt.Fatal(m)\n\t}\n}\n\nfunc TestSetGetAdderGetIteratorOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet getterCalled = 0;\n\n\tclass S extends Set {\n\t    get add() {\n\t        getterCalled++;\n\t        return null;\n\t    }\n\t}\n\n\tlet getIteratorCalled = 0;\n\n\tlet iterable = {};\n\titerable[Symbol.iterator] = () => {\n\t    getIteratorCalled++\n\t    return {\n\t        next: 1\n\t    };\n\t}\n\n\tlet thrown = false;\n\n\ttry {\n\t    new S(iterable);\n\t} catch (e) {\n\t    if (e instanceof TypeError) {\n\t        thrown = true;\n\t    } else {\n\t        throw e;\n\t    }\n\t}\n\n\tthrown && getterCalled === 1 && getIteratorCalled === 0;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n"
        },
        {
          "name": "builtin_string.go",
          "type": "blob",
          "size": 29.7080078125,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"sync\"\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/unistring\"\n\n\t\"github.com/dop251/goja/parser\"\n\t\"golang.org/x/text/collate\"\n\t\"golang.org/x/text/language\"\n\t\"golang.org/x/text/unicode/norm\"\n)\n\nfunc (r *Runtime) collator() *collate.Collator {\n\tcollator := r._collator\n\tif collator == nil {\n\t\tcollator = collate.New(language.Und)\n\t\tr._collator = collator\n\t}\n\treturn collator\n}\n\nfunc toString(arg Value) String {\n\tif s, ok := arg.(String); ok {\n\t\treturn s\n\t}\n\tif s, ok := arg.(*Symbol); ok {\n\t\treturn s.descriptiveString()\n\t}\n\treturn arg.toString()\n}\n\nfunc (r *Runtime) builtin_String(call FunctionCall) Value {\n\tif len(call.Arguments) > 0 {\n\t\treturn toString(call.Arguments[0])\n\t} else {\n\t\treturn stringEmpty\n\t}\n}\n\nfunc (r *Runtime) _newString(s String, proto *Object) *Object {\n\tv := &Object{runtime: r}\n\n\to := &stringObject{}\n\to.class = classString\n\to.val = v\n\to.extensible = true\n\tv.self = o\n\to.prototype = proto\n\tif s != nil {\n\t\to.value = s\n\t}\n\to.init()\n\treturn v\n}\n\nfunc (r *Runtime) builtin_newString(args []Value, proto *Object) *Object {\n\tvar s String\n\tif len(args) > 0 {\n\t\ts = args[0].toString()\n\t} else {\n\t\ts = stringEmpty\n\t}\n\treturn r._newString(s, proto)\n}\n\nfunc (r *Runtime) stringproto_toStringValueOf(this Value, funcName string) Value {\n\tif str, ok := this.(String); ok {\n\t\treturn str\n\t}\n\tif obj, ok := this.(*Object); ok {\n\t\tif strObj, ok := obj.self.(*stringObject); ok {\n\t\t\treturn strObj.value\n\t\t}\n\t\tif reflectObj, ok := obj.self.(*objectGoReflect); ok && reflectObj.class == classString {\n\t\t\tif toString := reflectObj.toString; toString != nil {\n\t\t\t\treturn toString()\n\t\t\t}\n\t\t\tif valueOf := reflectObj.valueOf; valueOf != nil {\n\t\t\t\treturn valueOf()\n\t\t\t}\n\t\t}\n\t\tif obj == r.global.StringPrototype {\n\t\t\treturn stringEmpty\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"String.prototype.%s is called on incompatible receiver\", funcName)\n\treturn nil\n}\n\nfunc (r *Runtime) stringproto_toString(call FunctionCall) Value {\n\treturn r.stringproto_toStringValueOf(call.This, \"toString\")\n}\n\nfunc (r *Runtime) stringproto_valueOf(call FunctionCall) Value {\n\treturn r.stringproto_toStringValueOf(call.This, \"valueOf\")\n}\n\nfunc (r *Runtime) stringproto_iterator(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\treturn r.createStringIterator(call.This.toString())\n}\n\nfunc (r *Runtime) string_fromcharcode(call FunctionCall) Value {\n\tb := make([]byte, len(call.Arguments))\n\tfor i, arg := range call.Arguments {\n\t\tchr := toUint16(arg)\n\t\tif chr >= utf8.RuneSelf {\n\t\t\tbb := make([]uint16, len(call.Arguments)+1)\n\t\t\tbb[0] = unistring.BOM\n\t\t\tbb1 := bb[1:]\n\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\tbb1[j] = uint16(b[j])\n\t\t\t}\n\t\t\tbb1[i] = chr\n\t\t\ti++\n\t\t\tfor j, arg := range call.Arguments[i:] {\n\t\t\t\tbb1[i+j] = toUint16(arg)\n\t\t\t}\n\t\t\treturn unicodeString(bb)\n\t\t}\n\t\tb[i] = byte(chr)\n\t}\n\n\treturn asciiString(b)\n}\n\nfunc (r *Runtime) string_fromcodepoint(call FunctionCall) Value {\n\tvar sb StringBuilder\n\tfor _, arg := range call.Arguments {\n\t\tnum := arg.ToNumber()\n\t\tvar c rune\n\t\tif numInt, ok := num.(valueInt); ok {\n\t\t\tif numInt < 0 || numInt > utf8.MaxRune {\n\t\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid code point %d\", numInt))\n\t\t\t}\n\t\t\tc = rune(numInt)\n\t\t} else {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid code point %s\", num))\n\t\t}\n\t\tsb.WriteRune(c)\n\t}\n\treturn sb.String()\n}\n\nfunc (r *Runtime) string_raw(call FunctionCall) Value {\n\tcooked := call.Argument(0).ToObject(r)\n\traw := nilSafe(cooked.self.getStr(\"raw\", nil)).ToObject(r)\n\tliteralSegments := toLength(raw.self.getStr(\"length\", nil))\n\tif literalSegments <= 0 {\n\t\treturn stringEmpty\n\t}\n\tvar stringElements StringBuilder\n\tnextIndex := int64(0)\n\tnumberOfSubstitutions := int64(len(call.Arguments) - 1)\n\tfor {\n\t\tnextSeg := nilSafe(raw.self.getIdx(valueInt(nextIndex), nil)).toString()\n\t\tstringElements.WriteString(nextSeg)\n\t\tif nextIndex+1 == literalSegments {\n\t\t\treturn stringElements.String()\n\t\t}\n\t\tif nextIndex < numberOfSubstitutions {\n\t\t\tstringElements.WriteString(nilSafe(call.Arguments[nextIndex+1]).toString())\n\t\t}\n\t\tnextIndex++\n\t}\n}\n\nfunc (r *Runtime) stringproto_at(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tpos := call.Argument(0).ToInteger()\n\tlength := int64(s.Length())\n\tif pos < 0 {\n\t\tpos = length + pos\n\t}\n\tif pos >= length || pos < 0 {\n\t\treturn _undefined\n\t}\n\treturn s.Substring(int(pos), int(pos+1))\n}\n\nfunc (r *Runtime) stringproto_charAt(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tpos := call.Argument(0).ToInteger()\n\tif pos < 0 || pos >= int64(s.Length()) {\n\t\treturn stringEmpty\n\t}\n\treturn s.Substring(int(pos), int(pos+1))\n}\n\nfunc (r *Runtime) stringproto_charCodeAt(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tpos := call.Argument(0).ToInteger()\n\tif pos < 0 || pos >= int64(s.Length()) {\n\t\treturn _NaN\n\t}\n\treturn intToValue(int64(s.CharAt(toIntStrict(pos)) & 0xFFFF))\n}\n\nfunc (r *Runtime) stringproto_codePointAt(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tp := call.Argument(0).ToInteger()\n\tsize := s.Length()\n\tif p < 0 || p >= int64(size) {\n\t\treturn _undefined\n\t}\n\tpos := toIntStrict(p)\n\tfirst := s.CharAt(pos)\n\tif isUTF16FirstSurrogate(first) {\n\t\tpos++\n\t\tif pos < size {\n\t\t\tsecond := s.CharAt(pos)\n\t\t\tif isUTF16SecondSurrogate(second) {\n\t\t\t\treturn intToValue(int64(utf16.DecodeRune(rune(first), rune(second))))\n\t\t\t}\n\t\t}\n\t}\n\treturn intToValue(int64(first & 0xFFFF))\n}\n\nfunc (r *Runtime) stringproto_concat(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tstrs := make([]String, len(call.Arguments)+1)\n\ta, u := devirtualizeString(call.This.toString())\n\tallAscii := true\n\ttotalLen := 0\n\tif u == nil {\n\t\tstrs[0] = a\n\t\ttotalLen = len(a)\n\t} else {\n\t\tstrs[0] = u\n\t\ttotalLen = u.Length()\n\t\tallAscii = false\n\t}\n\tfor i, arg := range call.Arguments {\n\t\ta, u := devirtualizeString(arg.toString())\n\t\tif u != nil {\n\t\t\tallAscii = false\n\t\t\ttotalLen += u.Length()\n\t\t\tstrs[i+1] = u\n\t\t} else {\n\t\t\ttotalLen += a.Length()\n\t\t\tstrs[i+1] = a\n\t\t}\n\t}\n\n\tif allAscii {\n\t\tvar buf strings.Builder\n\t\tbuf.Grow(totalLen)\n\t\tfor _, s := range strs {\n\t\t\tbuf.WriteString(s.String())\n\t\t}\n\t\treturn asciiString(buf.String())\n\t} else {\n\t\tbuf := make([]uint16, totalLen+1)\n\t\tbuf[0] = unistring.BOM\n\t\tpos := 1\n\t\tfor _, s := range strs {\n\t\t\tswitch s := s.(type) {\n\t\t\tcase asciiString:\n\t\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\t\tbuf[pos] = uint16(s[i])\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\tcase unicodeString:\n\t\t\t\tcopy(buf[pos:], s[1:])\n\t\t\t\tpos += s.Length()\n\t\t\t}\n\t\t}\n\t\treturn unicodeString(buf)\n\t}\n}\n\nfunc (r *Runtime) stringproto_endsWith(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tsearchString := call.Argument(0)\n\tif isRegexp(searchString) {\n\t\tpanic(r.NewTypeError(\"First argument to String.prototype.endsWith must not be a regular expression\"))\n\t}\n\tsearchStr := searchString.toString()\n\tl := int64(s.Length())\n\tvar pos int64\n\tif posArg := call.Argument(1); posArg != _undefined {\n\t\tpos = posArg.ToInteger()\n\t} else {\n\t\tpos = l\n\t}\n\tend := toIntStrict(min(max(pos, 0), l))\n\tsearchLength := searchStr.Length()\n\tstart := end - searchLength\n\tif start < 0 {\n\t\treturn valueFalse\n\t}\n\tfor i := 0; i < searchLength; i++ {\n\t\tif s.CharAt(start+i) != searchStr.CharAt(i) {\n\t\t\treturn valueFalse\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) stringproto_includes(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tsearchString := call.Argument(0)\n\tif isRegexp(searchString) {\n\t\tpanic(r.NewTypeError(\"First argument to String.prototype.includes must not be a regular expression\"))\n\t}\n\tsearchStr := searchString.toString()\n\tvar pos int64\n\tif posArg := call.Argument(1); posArg != _undefined {\n\t\tpos = posArg.ToInteger()\n\t} else {\n\t\tpos = 0\n\t}\n\tstart := toIntStrict(min(max(pos, 0), int64(s.Length())))\n\tif s.index(searchStr, start) != -1 {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) stringproto_indexOf(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tvalue := call.This.toString()\n\ttarget := call.Argument(0).toString()\n\tpos := call.Argument(1).ToNumber().ToInteger()\n\n\tif pos < 0 {\n\t\tpos = 0\n\t} else {\n\t\tl := int64(value.Length())\n\t\tif pos > l {\n\t\t\tpos = l\n\t\t}\n\t}\n\n\treturn intToValue(int64(value.index(target, toIntStrict(pos))))\n}\n\nfunc (r *Runtime) stringproto_lastIndexOf(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tvalue := call.This.toString()\n\ttarget := call.Argument(0).toString()\n\tnumPos := call.Argument(1).ToNumber()\n\n\tvar pos int64\n\tif f, ok := numPos.(valueFloat); ok && math.IsNaN(float64(f)) {\n\t\tpos = int64(value.Length())\n\t} else {\n\t\tpos = numPos.ToInteger()\n\t\tif pos < 0 {\n\t\t\tpos = 0\n\t\t} else {\n\t\t\tl := int64(value.Length())\n\t\t\tif pos > l {\n\t\t\t\tpos = l\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intToValue(int64(value.lastIndex(target, toIntStrict(pos))))\n}\n\nfunc (r *Runtime) stringproto_localeCompare(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tthis := norm.NFD.String(call.This.toString().String())\n\tthat := norm.NFD.String(call.Argument(0).toString().String())\n\treturn intToValue(int64(r.collator().CompareString(this, that)))\n}\n\nfunc (r *Runtime) stringproto_match(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tregexp := call.Argument(0)\n\tif regexp != _undefined && regexp != _null {\n\t\tif matcher := toMethod(r.getV(regexp, SymMatch)); matcher != nil {\n\t\t\treturn matcher(FunctionCall{\n\t\t\t\tThis:      regexp,\n\t\t\t\tArguments: []Value{call.This},\n\t\t\t})\n\t\t}\n\t}\n\n\tvar rx *regexpObject\n\tif regexp, ok := regexp.(*Object); ok {\n\t\trx, _ = regexp.self.(*regexpObject)\n\t}\n\n\tif rx == nil {\n\t\trx = r.newRegExp(regexp, nil, r.getRegExpPrototype())\n\t}\n\n\tif matcher, ok := r.toObject(rx.getSym(SymMatch, nil)).self.assertCallable(); ok {\n\t\treturn matcher(FunctionCall{\n\t\t\tThis:      rx.val,\n\t\t\tArguments: []Value{call.This.toString()},\n\t\t})\n\t}\n\n\tpanic(r.NewTypeError(\"RegExp matcher is not a function\"))\n}\n\nfunc (r *Runtime) stringproto_matchAll(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tregexp := call.Argument(0)\n\tif regexp != _undefined && regexp != _null {\n\t\tif isRegexp(regexp) {\n\t\t\tif o, ok := regexp.(*Object); ok {\n\t\t\t\tflags := nilSafe(o.self.getStr(\"flags\", nil))\n\t\t\t\tr.checkObjectCoercible(flags)\n\t\t\t\tif !strings.Contains(flags.toString().String(), \"g\") {\n\t\t\t\t\tpanic(r.NewTypeError(\"RegExp doesn't have global flag set\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif matcher := toMethod(r.getV(regexp, SymMatchAll)); matcher != nil {\n\t\t\treturn matcher(FunctionCall{\n\t\t\t\tThis:      regexp,\n\t\t\t\tArguments: []Value{call.This},\n\t\t\t})\n\t\t}\n\t}\n\n\trx := r.newRegExp(regexp, asciiString(\"g\"), r.getRegExpPrototype())\n\n\tif matcher, ok := r.toObject(rx.getSym(SymMatchAll, nil)).self.assertCallable(); ok {\n\t\treturn matcher(FunctionCall{\n\t\t\tThis:      rx.val,\n\t\t\tArguments: []Value{call.This.toString()},\n\t\t})\n\t}\n\n\tpanic(r.NewTypeError(\"RegExp matcher is not a function\"))\n}\n\nfunc (r *Runtime) stringproto_normalize(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tvar form string\n\tif formArg := call.Argument(0); formArg != _undefined {\n\t\tform = formArg.toString().toString().String()\n\t} else {\n\t\tform = \"NFC\"\n\t}\n\tvar f norm.Form\n\tswitch form {\n\tcase \"NFC\":\n\t\tf = norm.NFC\n\tcase \"NFD\":\n\t\tf = norm.NFD\n\tcase \"NFKC\":\n\t\tf = norm.NFKC\n\tcase \"NFKD\":\n\t\tf = norm.NFKD\n\tdefault:\n\t\tpanic(r.newError(r.getRangeError(), \"The normalization form should be one of NFC, NFD, NFKC, NFKD\"))\n\t}\n\n\tswitch s := s.(type) {\n\tcase asciiString:\n\t\treturn s\n\tcase unicodeString:\n\t\tss := s.String()\n\t\treturn newStringValue(f.String(ss))\n\tcase *importedString:\n\t\tif s.scanned && s.u == nil {\n\t\t\treturn asciiString(s.s)\n\t\t}\n\t\treturn newStringValue(f.String(s.s))\n\tdefault:\n\t\tpanic(unknownStringTypeErr(s))\n\t}\n}\n\nfunc (r *Runtime) _stringPad(call FunctionCall, start bool) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tmaxLength := toLength(call.Argument(0))\n\tstringLength := int64(s.Length())\n\tif maxLength <= stringLength {\n\t\treturn s\n\t}\n\tstrAscii, strUnicode := devirtualizeString(s)\n\tvar filler String\n\tvar fillerAscii asciiString\n\tvar fillerUnicode unicodeString\n\tif fillString := call.Argument(1); fillString != _undefined {\n\t\tfiller = fillString.toString()\n\t\tif filler.Length() == 0 {\n\t\t\treturn s\n\t\t}\n\t\tfillerAscii, fillerUnicode = devirtualizeString(filler)\n\t} else {\n\t\tfillerAscii = \" \"\n\t\tfiller = fillerAscii\n\t}\n\tremaining := toIntStrict(maxLength - stringLength)\n\tif fillerUnicode == nil && strUnicode == nil {\n\t\tfl := fillerAscii.Length()\n\t\tvar sb strings.Builder\n\t\tsb.Grow(toIntStrict(maxLength))\n\t\tif !start {\n\t\t\tsb.WriteString(string(strAscii))\n\t\t}\n\t\tfor remaining >= fl {\n\t\t\tsb.WriteString(string(fillerAscii))\n\t\t\tremaining -= fl\n\t\t}\n\t\tif remaining > 0 {\n\t\t\tsb.WriteString(string(fillerAscii[:remaining]))\n\t\t}\n\t\tif start {\n\t\t\tsb.WriteString(string(strAscii))\n\t\t}\n\t\treturn asciiString(sb.String())\n\t}\n\tvar sb unicodeStringBuilder\n\tsb.ensureStarted(toIntStrict(maxLength))\n\tif !start {\n\t\tsb.writeString(s)\n\t}\n\tfl := filler.Length()\n\tfor remaining >= fl {\n\t\tsb.writeString(filler)\n\t\tremaining -= fl\n\t}\n\tif remaining > 0 {\n\t\tsb.writeString(filler.Substring(0, remaining))\n\t}\n\tif start {\n\t\tsb.writeString(s)\n\t}\n\n\treturn sb.String()\n}\n\nfunc (r *Runtime) stringproto_padEnd(call FunctionCall) Value {\n\treturn r._stringPad(call, false)\n}\n\nfunc (r *Runtime) stringproto_padStart(call FunctionCall) Value {\n\treturn r._stringPad(call, true)\n}\n\nfunc (r *Runtime) stringproto_repeat(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tn := call.Argument(0).ToNumber()\n\tif n == _positiveInf {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid count value\"))\n\t}\n\tnumInt := n.ToInteger()\n\tif numInt < 0 {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid count value\"))\n\t}\n\tif numInt == 0 || s.Length() == 0 {\n\t\treturn stringEmpty\n\t}\n\tnum := toIntStrict(numInt)\n\ta, u := devirtualizeString(s)\n\tif u == nil {\n\t\tvar sb strings.Builder\n\t\tsb.Grow(len(a) * num)\n\t\tfor i := 0; i < num; i++ {\n\t\t\tsb.WriteString(string(a))\n\t\t}\n\t\treturn asciiString(sb.String())\n\t}\n\n\tvar sb unicodeStringBuilder\n\tsb.Grow(u.Length() * num)\n\tfor i := 0; i < num; i++ {\n\t\tsb.writeUnicodeString(u)\n\t}\n\treturn sb.String()\n}\n\nfunc getReplaceValue(replaceValue Value) (str String, rcall func(FunctionCall) Value) {\n\tif replaceValue, ok := replaceValue.(*Object); ok {\n\t\tif c, ok := replaceValue.self.assertCallable(); ok {\n\t\t\trcall = c\n\t\t\treturn\n\t\t}\n\t}\n\tstr = replaceValue.toString()\n\treturn\n}\n\nfunc stringReplace(s String, found [][]int, newstring String, rcall func(FunctionCall) Value) Value {\n\tif len(found) == 0 {\n\t\treturn s\n\t}\n\n\ta, u := devirtualizeString(s)\n\n\tvar buf StringBuilder\n\n\tlastIndex := 0\n\tlengthS := s.Length()\n\tif rcall != nil {\n\t\tfor _, item := range found {\n\t\t\tif item[0] != lastIndex {\n\t\t\t\tbuf.WriteSubstring(s, lastIndex, item[0])\n\t\t\t}\n\t\t\tmatchCount := len(item) / 2\n\t\t\targumentList := make([]Value, matchCount+2)\n\t\t\tfor index := 0; index < matchCount; index++ {\n\t\t\t\toffset := 2 * index\n\t\t\t\tif item[offset] != -1 {\n\t\t\t\t\tif u == nil {\n\t\t\t\t\t\targumentList[index] = a[item[offset]:item[offset+1]]\n\t\t\t\t\t} else {\n\t\t\t\t\t\targumentList[index] = u.Substring(item[offset], item[offset+1])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\targumentList[index] = _undefined\n\t\t\t\t}\n\t\t\t}\n\t\t\targumentList[matchCount] = valueInt(item[0])\n\t\t\targumentList[matchCount+1] = s\n\t\t\treplacement := rcall(FunctionCall{\n\t\t\t\tThis:      _undefined,\n\t\t\t\tArguments: argumentList,\n\t\t\t}).toString()\n\t\t\tbuf.WriteString(replacement)\n\t\t\tlastIndex = item[1]\n\t\t}\n\t} else {\n\t\tfor _, item := range found {\n\t\t\tif item[0] != lastIndex {\n\t\t\t\tbuf.WriteString(s.Substring(lastIndex, item[0]))\n\t\t\t}\n\t\t\tmatchCount := len(item) / 2\n\t\t\twriteSubstitution(s, item[0], matchCount, func(idx int) String {\n\t\t\t\tif item[idx*2] != -1 {\n\t\t\t\t\tif u == nil {\n\t\t\t\t\t\treturn a[item[idx*2]:item[idx*2+1]]\n\t\t\t\t\t}\n\t\t\t\t\treturn u.Substring(item[idx*2], item[idx*2+1])\n\t\t\t\t}\n\t\t\t\treturn stringEmpty\n\t\t\t}, newstring, &buf)\n\t\t\tlastIndex = item[1]\n\t\t}\n\t}\n\n\tif lastIndex != lengthS {\n\t\tbuf.WriteString(s.Substring(lastIndex, lengthS))\n\t}\n\n\treturn buf.String()\n}\n\nfunc (r *Runtime) stringproto_replace(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tsearchValue := call.Argument(0)\n\treplaceValue := call.Argument(1)\n\tif searchValue != _undefined && searchValue != _null {\n\t\tif replacer := toMethod(r.getV(searchValue, SymReplace)); replacer != nil {\n\t\t\treturn replacer(FunctionCall{\n\t\t\t\tThis:      searchValue,\n\t\t\t\tArguments: []Value{call.This, replaceValue},\n\t\t\t})\n\t\t}\n\t}\n\n\ts := call.This.toString()\n\tvar found [][]int\n\tsearchStr := searchValue.toString()\n\tpos := s.index(searchStr, 0)\n\tif pos != -1 {\n\t\tfound = append(found, []int{pos, pos + searchStr.Length()})\n\t}\n\n\tstr, rcall := getReplaceValue(replaceValue)\n\treturn stringReplace(s, found, str, rcall)\n}\n\nfunc (r *Runtime) stringproto_replaceAll(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tsearchValue := call.Argument(0)\n\treplaceValue := call.Argument(1)\n\tif searchValue != _undefined && searchValue != _null {\n\t\tif isRegexp(searchValue) {\n\t\t\tif o, ok := searchValue.(*Object); ok {\n\t\t\t\tflags := nilSafe(o.self.getStr(\"flags\", nil))\n\t\t\t\tr.checkObjectCoercible(flags)\n\t\t\t\tif !strings.Contains(flags.toString().String(), \"g\") {\n\t\t\t\t\tpanic(r.NewTypeError(\"String.prototype.replaceAll called with a non-global RegExp argument\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif replacer := toMethod(r.getV(searchValue, SymReplace)); replacer != nil {\n\t\t\treturn replacer(FunctionCall{\n\t\t\t\tThis:      searchValue,\n\t\t\t\tArguments: []Value{call.This, replaceValue},\n\t\t\t})\n\t\t}\n\t}\n\n\ts := call.This.toString()\n\tvar found [][]int\n\tsearchStr := searchValue.toString()\n\tsearchLength := searchStr.Length()\n\tadvanceBy := toIntStrict(max(1, int64(searchLength)))\n\n\tpos := s.index(searchStr, 0)\n\tfor pos != -1 {\n\t\tfound = append(found, []int{pos, pos + searchLength})\n\t\tpos = s.index(searchStr, pos+advanceBy)\n\t}\n\n\tstr, rcall := getReplaceValue(replaceValue)\n\treturn stringReplace(s, found, str, rcall)\n}\n\nfunc (r *Runtime) stringproto_search(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tregexp := call.Argument(0)\n\tif regexp != _undefined && regexp != _null {\n\t\tif searcher := toMethod(r.getV(regexp, SymSearch)); searcher != nil {\n\t\t\treturn searcher(FunctionCall{\n\t\t\t\tThis:      regexp,\n\t\t\t\tArguments: []Value{call.This},\n\t\t\t})\n\t\t}\n\t}\n\n\tvar rx *regexpObject\n\tif regexp, ok := regexp.(*Object); ok {\n\t\trx, _ = regexp.self.(*regexpObject)\n\t}\n\n\tif rx == nil {\n\t\trx = r.newRegExp(regexp, nil, r.getRegExpPrototype())\n\t}\n\n\tif searcher, ok := r.toObject(rx.getSym(SymSearch, nil)).self.assertCallable(); ok {\n\t\treturn searcher(FunctionCall{\n\t\t\tThis:      rx.val,\n\t\t\tArguments: []Value{call.This.toString()},\n\t\t})\n\t}\n\n\tpanic(r.NewTypeError(\"RegExp searcher is not a function\"))\n}\n\nfunc (r *Runtime) stringproto_slice(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\tl := int64(s.Length())\n\tstart := call.Argument(0).ToInteger()\n\tvar end int64\n\tif arg1 := call.Argument(1); arg1 != _undefined {\n\t\tend = arg1.ToInteger()\n\t} else {\n\t\tend = l\n\t}\n\n\tif start < 0 {\n\t\tstart += l\n\t\tif start < 0 {\n\t\t\tstart = 0\n\t\t}\n\t} else {\n\t\tif start > l {\n\t\t\tstart = l\n\t\t}\n\t}\n\n\tif end < 0 {\n\t\tend += l\n\t\tif end < 0 {\n\t\t\tend = 0\n\t\t}\n\t} else {\n\t\tif end > l {\n\t\t\tend = l\n\t\t}\n\t}\n\n\tif end > start {\n\t\treturn s.Substring(int(start), int(end))\n\t}\n\treturn stringEmpty\n}\n\nfunc (r *Runtime) stringproto_split(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\tseparatorValue := call.Argument(0)\n\tlimitValue := call.Argument(1)\n\tif separatorValue != _undefined && separatorValue != _null {\n\t\tif splitter := toMethod(r.getV(separatorValue, SymSplit)); splitter != nil {\n\t\t\treturn splitter(FunctionCall{\n\t\t\t\tThis:      separatorValue,\n\t\t\t\tArguments: []Value{call.This, limitValue},\n\t\t\t})\n\t\t}\n\t}\n\ts := call.This.toString()\n\n\tlimit := -1\n\tif limitValue != _undefined {\n\t\tlimit = int(toUint32(limitValue))\n\t}\n\n\tseparatorValue = separatorValue.ToString()\n\n\tif limit == 0 {\n\t\treturn r.newArrayValues(nil)\n\t}\n\n\tif separatorValue == _undefined {\n\t\treturn r.newArrayValues([]Value{s})\n\t}\n\n\tseparator := separatorValue.String()\n\n\tstr := s.String()\n\tsplitLimit := limit\n\tif limit > 0 {\n\t\tsplitLimit = limit + 1\n\t}\n\n\t// TODO handle invalid UTF-16\n\tsplit := strings.SplitN(str, separator, splitLimit)\n\n\tif limit > 0 && len(split) > limit {\n\t\tsplit = split[:limit]\n\t}\n\n\tvalueArray := make([]Value, len(split))\n\tfor index, value := range split {\n\t\tvalueArray[index] = newStringValue(value)\n\t}\n\n\treturn r.newArrayValues(valueArray)\n}\n\nfunc (r *Runtime) stringproto_startsWith(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tsearchString := call.Argument(0)\n\tif isRegexp(searchString) {\n\t\tpanic(r.NewTypeError(\"First argument to String.prototype.startsWith must not be a regular expression\"))\n\t}\n\tsearchStr := searchString.toString()\n\tl := int64(s.Length())\n\tvar pos int64\n\tif posArg := call.Argument(1); posArg != _undefined {\n\t\tpos = posArg.ToInteger()\n\t}\n\tstart := toIntStrict(min(max(pos, 0), l))\n\tsearchLength := searchStr.Length()\n\tif int64(searchLength+start) > l {\n\t\treturn valueFalse\n\t}\n\tfor i := 0; i < searchLength; i++ {\n\t\tif s.CharAt(start+i) != searchStr.CharAt(i) {\n\t\t\treturn valueFalse\n\t\t}\n\t}\n\treturn valueTrue\n}\n\nfunc (r *Runtime) stringproto_substring(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\tl := int64(s.Length())\n\tintStart := call.Argument(0).ToInteger()\n\tvar intEnd int64\n\tif end := call.Argument(1); end != _undefined {\n\t\tintEnd = end.ToInteger()\n\t} else {\n\t\tintEnd = l\n\t}\n\tif intStart < 0 {\n\t\tintStart = 0\n\t} else if intStart > l {\n\t\tintStart = l\n\t}\n\n\tif intEnd < 0 {\n\t\tintEnd = 0\n\t} else if intEnd > l {\n\t\tintEnd = l\n\t}\n\n\tif intStart > intEnd {\n\t\tintStart, intEnd = intEnd, intStart\n\t}\n\n\treturn s.Substring(int(intStart), int(intEnd))\n}\n\nfunc (r *Runtime) stringproto_toLowerCase(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\treturn s.toLower()\n}\n\nfunc (r *Runtime) stringproto_toUpperCase(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\treturn s.toUpper()\n}\n\nfunc (r *Runtime) stringproto_trim(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\t// TODO handle invalid UTF-16\n\treturn newStringValue(strings.Trim(s.String(), parser.WhitespaceChars))\n}\n\nfunc (r *Runtime) stringproto_trimEnd(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\t// TODO handle invalid UTF-16\n\treturn newStringValue(strings.TrimRight(s.String(), parser.WhitespaceChars))\n}\n\nfunc (r *Runtime) stringproto_trimStart(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\n\t// TODO handle invalid UTF-16\n\treturn newStringValue(strings.TrimLeft(s.String(), parser.WhitespaceChars))\n}\n\nfunc (r *Runtime) stringproto_substr(call FunctionCall) Value {\n\tr.checkObjectCoercible(call.This)\n\ts := call.This.toString()\n\tstart := call.Argument(0).ToInteger()\n\tvar length int64\n\tsl := int64(s.Length())\n\tif arg := call.Argument(1); arg != _undefined {\n\t\tlength = arg.ToInteger()\n\t} else {\n\t\tlength = sl\n\t}\n\n\tif start < 0 {\n\t\tstart = max(sl+start, 0)\n\t}\n\n\tlength = min(max(length, 0), sl-start)\n\tif length <= 0 {\n\t\treturn stringEmpty\n\t}\n\n\treturn s.Substring(int(start), int(start+length))\n}\n\nfunc (r *Runtime) stringIterProto_next(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\tif iter, ok := thisObj.self.(*stringIterObject); ok {\n\t\treturn iter.next()\n\t}\n\tpanic(r.NewTypeError(\"Method String Iterator.prototype.next called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n}\n\nfunc (r *Runtime) createStringIterProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.getIteratorPrototype(), classObject)\n\n\to._putProp(\"next\", r.newNativeFunc(r.stringIterProto_next, \"next\", 0), true, false, true)\n\to._putSym(SymToStringTag, valueProp(asciiString(classStringIterator), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) getStringIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.StringIteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.StringIteratorPrototype = o\n\t\to.self = r.createStringIterProto(o)\n\t}\n\treturn o\n}\n\nfunc createStringProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"length\", func(r *Runtime) Value { return valueProp(intToValue(0), false, false, false) })\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getString(), true, false, true) })\n\n\tt.putStr(\"at\", func(r *Runtime) Value { return r.methodProp(r.stringproto_at, \"at\", 1) })\n\tt.putStr(\"charAt\", func(r *Runtime) Value { return r.methodProp(r.stringproto_charAt, \"charAt\", 1) })\n\tt.putStr(\"charCodeAt\", func(r *Runtime) Value { return r.methodProp(r.stringproto_charCodeAt, \"charCodeAt\", 1) })\n\tt.putStr(\"codePointAt\", func(r *Runtime) Value { return r.methodProp(r.stringproto_codePointAt, \"codePointAt\", 1) })\n\tt.putStr(\"concat\", func(r *Runtime) Value { return r.methodProp(r.stringproto_concat, \"concat\", 1) })\n\tt.putStr(\"endsWith\", func(r *Runtime) Value { return r.methodProp(r.stringproto_endsWith, \"endsWith\", 1) })\n\tt.putStr(\"includes\", func(r *Runtime) Value { return r.methodProp(r.stringproto_includes, \"includes\", 1) })\n\tt.putStr(\"indexOf\", func(r *Runtime) Value { return r.methodProp(r.stringproto_indexOf, \"indexOf\", 1) })\n\tt.putStr(\"lastIndexOf\", func(r *Runtime) Value { return r.methodProp(r.stringproto_lastIndexOf, \"lastIndexOf\", 1) })\n\tt.putStr(\"localeCompare\", func(r *Runtime) Value { return r.methodProp(r.stringproto_localeCompare, \"localeCompare\", 1) })\n\tt.putStr(\"match\", func(r *Runtime) Value { return r.methodProp(r.stringproto_match, \"match\", 1) })\n\tt.putStr(\"matchAll\", func(r *Runtime) Value { return r.methodProp(r.stringproto_matchAll, \"matchAll\", 1) })\n\tt.putStr(\"normalize\", func(r *Runtime) Value { return r.methodProp(r.stringproto_normalize, \"normalize\", 0) })\n\tt.putStr(\"padEnd\", func(r *Runtime) Value { return r.methodProp(r.stringproto_padEnd, \"padEnd\", 1) })\n\tt.putStr(\"padStart\", func(r *Runtime) Value { return r.methodProp(r.stringproto_padStart, \"padStart\", 1) })\n\tt.putStr(\"repeat\", func(r *Runtime) Value { return r.methodProp(r.stringproto_repeat, \"repeat\", 1) })\n\tt.putStr(\"replace\", func(r *Runtime) Value { return r.methodProp(r.stringproto_replace, \"replace\", 2) })\n\tt.putStr(\"replaceAll\", func(r *Runtime) Value { return r.methodProp(r.stringproto_replaceAll, \"replaceAll\", 2) })\n\tt.putStr(\"search\", func(r *Runtime) Value { return r.methodProp(r.stringproto_search, \"search\", 1) })\n\tt.putStr(\"slice\", func(r *Runtime) Value { return r.methodProp(r.stringproto_slice, \"slice\", 2) })\n\tt.putStr(\"split\", func(r *Runtime) Value { return r.methodProp(r.stringproto_split, \"split\", 2) })\n\tt.putStr(\"startsWith\", func(r *Runtime) Value { return r.methodProp(r.stringproto_startsWith, \"startsWith\", 1) })\n\tt.putStr(\"substring\", func(r *Runtime) Value { return r.methodProp(r.stringproto_substring, \"substring\", 2) })\n\tt.putStr(\"toLocaleLowerCase\", func(r *Runtime) Value { return r.methodProp(r.stringproto_toLowerCase, \"toLocaleLowerCase\", 0) })\n\tt.putStr(\"toLocaleUpperCase\", func(r *Runtime) Value { return r.methodProp(r.stringproto_toUpperCase, \"toLocaleUpperCase\", 0) })\n\tt.putStr(\"toLowerCase\", func(r *Runtime) Value { return r.methodProp(r.stringproto_toLowerCase, \"toLowerCase\", 0) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return r.methodProp(r.stringproto_toString, \"toString\", 0) })\n\tt.putStr(\"toUpperCase\", func(r *Runtime) Value { return r.methodProp(r.stringproto_toUpperCase, \"toUpperCase\", 0) })\n\tt.putStr(\"trim\", func(r *Runtime) Value { return r.methodProp(r.stringproto_trim, \"trim\", 0) })\n\tt.putStr(\"trimEnd\", func(r *Runtime) Value { return valueProp(r.getStringproto_trimEnd(), true, false, true) })\n\tt.putStr(\"trimStart\", func(r *Runtime) Value { return valueProp(r.getStringproto_trimStart(), true, false, true) })\n\tt.putStr(\"trimRight\", func(r *Runtime) Value { return valueProp(r.getStringproto_trimEnd(), true, false, true) })\n\tt.putStr(\"trimLeft\", func(r *Runtime) Value { return valueProp(r.getStringproto_trimStart(), true, false, true) })\n\tt.putStr(\"valueOf\", func(r *Runtime) Value { return r.methodProp(r.stringproto_valueOf, \"valueOf\", 0) })\n\n\t// Annex B\n\tt.putStr(\"substr\", func(r *Runtime) Value { return r.methodProp(r.stringproto_substr, \"substr\", 2) })\n\n\tt.putSym(SymIterator, func(r *Runtime) Value {\n\t\treturn valueProp(r.newNativeFunc(r.stringproto_iterator, \"[Symbol.iterator]\", 0), true, false, true)\n\t})\n\n\treturn t\n}\n\nfunc (r *Runtime) getStringproto_trimEnd() *Object {\n\tret := r.global.stringproto_trimEnd\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.stringproto_trimEnd, \"trimEnd\", 0)\n\t\tr.global.stringproto_trimEnd = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getStringproto_trimStart() *Object {\n\tret := r.global.stringproto_trimStart\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.stringproto_trimStart, \"trimStart\", 0)\n\t\tr.global.stringproto_trimStart = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getStringSingleton() *stringObject {\n\tret := r.stringSingleton\n\tif ret == nil {\n\t\tret = r.builtin_new(r.getString(), nil).self.(*stringObject)\n\t\tr.stringSingleton = ret\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getString() *Object {\n\tret := r.global.String\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.String = ret\n\t\tproto := r.getStringPrototype()\n\t\to := r.newNativeFuncAndConstruct(ret, r.builtin_String, r.wrapNativeConstruct(r.builtin_newString, ret, proto), proto, \"String\", intToValue(1))\n\t\tret.self = o\n\t\to._putProp(\"fromCharCode\", r.newNativeFunc(r.string_fromcharcode, \"fromCharCode\", 1), true, false, true)\n\t\to._putProp(\"fromCodePoint\", r.newNativeFunc(r.string_fromcodepoint, \"fromCodePoint\", 1), true, false, true)\n\t\to._putProp(\"raw\", r.newNativeFunc(r.string_raw, \"raw\", 1), true, false, true)\n\t}\n\treturn ret\n}\n\nvar stringProtoTemplate *objectTemplate\nvar stringProtoTemplateOnce sync.Once\n\nfunc getStringProtoTemplate() *objectTemplate {\n\tstringProtoTemplateOnce.Do(func() {\n\t\tstringProtoTemplate = createStringProtoTemplate()\n\t})\n\treturn stringProtoTemplate\n}\n\nfunc (r *Runtime) getStringPrototype() *Object {\n\tret := r.global.StringPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.StringPrototype = ret\n\t\to := r.newTemplatedObject(getStringProtoTemplate(), ret)\n\t\to.class = classString\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_string_test.go",
          "type": "blob",
          "size": 8.21875,
          "content": "package goja\n\nimport \"testing\"\n\nfunc TestSubstr(t *testing.T) {\n\tconst SCRIPT = `\nassert.sameValue('abc'.substr(0, false), '', 'start: 0, length: false');\nassert.sameValue('abc'.substr(1, false), '', 'start: 1, length: false');\nassert.sameValue('abc'.substr(2, false), '', 'start: 2, length: false');\nassert.sameValue('abc'.substr(3, false), '', 'start: 3, length: false');\n\nassert.sameValue('abc'.substr(0, NaN), '', 'start: 0, length: NaN');\nassert.sameValue('abc'.substr(1, NaN), '', 'start: 1, length: NaN');\nassert.sameValue('abc'.substr(2, NaN), '', 'start: 2, length: NaN');\nassert.sameValue('abc'.substr(3, NaN), '', 'start: 3, length: NaN');\n\nassert.sameValue('abc'.substr(0, ''), '', 'start: 0, length: \"\"');\nassert.sameValue('abc'.substr(1, ''), '', 'start: 1, length: \"\"');\nassert.sameValue('abc'.substr(2, ''), '', 'start: 2, length: \"\"');\nassert.sameValue('abc'.substr(3, ''), '', 'start: 3, length: \"\"');\n\nassert.sameValue('abc'.substr(0, null), '', 'start: 0, length: null');\nassert.sameValue('abc'.substr(1, null), '', 'start: 1, length: null');\nassert.sameValue('abc'.substr(2, null), '', 'start: 2, length: null');\nassert.sameValue('abc'.substr(3, null), '', 'start: 3, length: null');\n\nassert.sameValue('abc'.substr(0, -1), '', '0, -1');\nassert.sameValue('abc'.substr(0, -2), '', '0, -2');\nassert.sameValue('abc'.substr(0, -3), '', '0, -3');\nassert.sameValue('abc'.substr(0, -4), '', '0, -4');\n\nassert.sameValue('abc'.substr(1, -1), '', '1, -1');\nassert.sameValue('abc'.substr(1, -2), '', '1, -2');\nassert.sameValue('abc'.substr(1, -3), '', '1, -3');\nassert.sameValue('abc'.substr(1, -4), '', '1, -4');\n\nassert.sameValue('abc'.substr(2, -1), '', '2, -1');\nassert.sameValue('abc'.substr(2, -2), '', '2, -2');\nassert.sameValue('abc'.substr(2, -3), '', '2, -3');\nassert.sameValue('abc'.substr(2, -4), '', '2, -4');\n\nassert.sameValue('abc'.substr(3, -1), '', '3, -1');\nassert.sameValue('abc'.substr(3, -2), '', '3, -2');\nassert.sameValue('abc'.substr(3, -3), '', '3, -3');\nassert.sameValue('abc'.substr(3, -4), '', '3, -4');\n\nassert.sameValue('abc'.substr(0, 1), 'a', '0, 1');\nassert.sameValue('abc'.substr(0, 2), 'ab', '0, 1');\nassert.sameValue('abc'.substr(0, 3), 'abc', '0, 1');\nassert.sameValue('abc'.substr(0, 4), 'abc', '0, 1');\n\nassert.sameValue('abc'.substr(1, 1), 'b', '1, 1');\nassert.sameValue('abc'.substr(1, 2), 'bc', '1, 1');\nassert.sameValue('abc'.substr(1, 3), 'bc', '1, 1');\nassert.sameValue('abc'.substr(1, 4), 'bc', '1, 1');\n\nassert.sameValue('abc'.substr(2, 1), 'c', '2, 1');\nassert.sameValue('abc'.substr(2, 2), 'c', '2, 1');\nassert.sameValue('abc'.substr(2, 3), 'c', '2, 1');\nassert.sameValue('abc'.substr(2, 4), 'c', '2, 1');\n\nassert.sameValue('abc'.substr(3, 1), '', '3, 1');\nassert.sameValue('abc'.substr(3, 2), '', '3, 1');\nassert.sameValue('abc'.substr(3, 3), '', '3, 1');\nassert.sameValue('abc'.substr(3, 4), '', '3, 1');\n\nassert.sameValue('abc'.substr(0), 'abc', 'start: 0, length: unspecified');\nassert.sameValue('abc'.substr(1), 'bc', 'start: 1, length: unspecified');\nassert.sameValue('abc'.substr(2), 'c', 'start: 2, length: unspecified');\nassert.sameValue('abc'.substr(3), '', 'start: 3, length: unspecified');\n\nassert.sameValue(\n  'abc'.substr(0, undefined), 'abc', 'start: 0, length: undefined'\n);\nassert.sameValue(\n  'abc'.substr(1, undefined), 'bc', 'start: 1, length: undefined'\n);\nassert.sameValue(\n  'abc'.substr(2, undefined), 'c', 'start: 2, length: undefined'\n);\nassert.sameValue(\n  'abc'.substr(3, undefined), '', 'start: 3, length: undefined'\n);\n\nassert.sameValue('A', String.fromCharCode(65, 0x2014));\n\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestStringMatchSym(t *testing.T) {\n\tconst SCRIPT = `\nfunction Prefix(p) {\n\tthis.p = p;\n}\n\nPrefix.prototype[Symbol.match] = function(s) {\n\treturn s.substring(0, this.p.length) === this.p;\n}\n\nvar prefix1 = new Prefix(\"abc\");\nvar prefix2 = new Prefix(\"def\");\n\n\"abc123\".match(prefix1) === true && \"abc123\".match(prefix2) === false &&\n\"def123\".match(prefix1) === false && \"def123\".match(prefix2) === true;\n`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestStringMatchAllSym(t *testing.T) {\n\tconst SCRIPT = `\nfunction Prefix(p) {\n\tthis.p = p;\n}\n\nPrefix.prototype[Symbol.matchAll] = function(s) {\n\treturn s.substring(0, this.p.length) === this.p;\n}\n\nvar prefix1 = new Prefix(\"abc\");\nvar prefix2 = new Prefix(\"def\");\n\n\"abc123\".matchAll(prefix1) === true && \"abc123\".matchAll(prefix2) === false &&\n\"def123\".matchAll(prefix1) === false && \"def123\".matchAll(prefix2) === true;\n`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestGenericSplitter(t *testing.T) {\n\tconst SCRIPT = `\nfunction MyRegexp(pattern, flags) {\n\tif (pattern instanceof MyRegexp) {\n\t\tpattern = pattern.wrapped;\n\t}\n\tthis.wrapped = new RegExp(pattern, flags);\n}\n\nMyRegexp.prototype.exec = function() {\n\treturn this.wrapped.exec.apply(this.wrapped, arguments);\n}\n\nObject.defineProperty(MyRegexp.prototype, \"lastIndex\", {\n\tget: function() {\n\t\treturn this.wrapped.lastIndex;\n\t},\n\tset: function(v) {\n\t\tthis.wrapped.lastIndex = v;\n\t}\n});\n\nObject.defineProperty(MyRegexp.prototype, \"flags\", {\n\tget: function() {\n\t\treturn this.wrapped.flags;\n\t}\n});\n\nMyRegexp[Symbol.species] = MyRegexp;\nMyRegexp.prototype[Symbol.split] = RegExp.prototype[Symbol.split];\n\nvar r = new MyRegexp(/ /);\nvar res = \"a b c\".split(r);\nres.length === 3 && res[0] === \"a\" && res[1] === \"b\" && res[2] === \"c\";\n`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestStringIterSurrPair(t *testing.T) {\n\tconst SCRIPT = `\nvar lo = '\\uD834';\nvar hi = '\\uDF06';\nvar pair = lo + hi;\nvar string = 'a' + pair + 'b' + lo + pair + hi + lo;\nvar iterator = string[Symbol.iterator]();\nvar result;\n\nresult = iterator.next();\nif (result.value !== 'a') {\n\tthrow new Error(\"at 0: \" + result.value);\n}\nresult = iterator.next();\nif (result.value !== pair) {\n\tthrow new Error(\"at 1: \" + result.value);\n}\n\n`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestValueStringBuilder(t *testing.T) {\n\tt.Run(\"substringASCII\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tstr := newStringValue(\"a\\U00010000b\")\n\t\tsb.WriteSubstring(str, 0, 1)\n\t\tres := sb.String()\n\t\tif res != asciiString(\"a\") {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"substringASCIIPure\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tstr := newStringValue(\"ab\")\n\t\tsb.WriteSubstring(str, 0, 1)\n\t\tres := sb.String()\n\t\tif res != asciiString(\"a\") {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"substringUnicode\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tstr := newStringValue(\"a\\U00010000b\")\n\t\tsb.WriteSubstring(str, 1, 3)\n\t\tres := sb.String()\n\t\tif !res.SameAs(unicodeStringFromRunes([]rune{0x10000})) {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"substringASCIIUnicode\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tstr := newStringValue(\"a\\U00010000b\")\n\t\tsb.WriteSubstring(str, 0, 2)\n\t\tres := sb.String()\n\t\tif !res.SameAs(unicodeStringFromRunes([]rune{'a', 0xD800})) {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"substringUnicodeASCII\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tstr := newStringValue(\"a\\U00010000b\")\n\t\tsb.WriteSubstring(str, 2, 4)\n\t\tres := sb.String()\n\t\tif !res.SameAs(unicodeStringFromRunes([]rune{0xDC00, 'b'})) {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"concatSubstringUnicodeASCII\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tsb.WriteString(newStringValue(\"\"))\n\t\tsb.WriteSubstring(asciiString(\" ascii\"), 0, 6)\n\t\tif res := sb.String(); !res.SameAs(newStringValue(\" ascii\")) {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"concat_ASCII_importedASCII\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tsb.WriteString(asciiString(\"ascii\"))\n\t\tsb.WriteString(&importedString{s: \" imported_ascii1234567890\"})\n\t\ts := sb.String()\n\t\tif res, ok := s.(asciiString); !ok || res != \"ascii imported_ascii1234567890\" {\n\t\t\tt.Fatal(s)\n\t\t}\n\t})\n\n\tt.Run(\"concat_ASCII_importedUnicode\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar sb StringBuilder\n\t\tsb.WriteString(asciiString(\"ascii\"))\n\t\tsb.WriteString(&importedString{s: \" imported_\"})\n\t\ts := sb.String()\n\t\tif res, ok := s.(unicodeString); !ok || !res.SameAs(newStringValue(\"ascii imported_\")) {\n\t\t\tt.Fatal(s)\n\t\t}\n\t})\n\n}\n\nfunc TestStringSplit(t *testing.T) {\n\tconst SCRIPT = `\n\tassert(compareArray(\"\".split(\"#\",2), [\"\"]));\n\tassert(compareArray(\"\".split(\"#\"), [\"\"]));\n\tassert(compareArray(\"\".split(\"\",2), []));\n\tassert(compareArray(\"\".split(\"\"), []));\n`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "builtin_symbol.go",
          "type": "blob",
          "size": 4.8037109375,
          "content": "package goja\n\nimport \"github.com/dop251/goja/unistring\"\n\nvar (\n\tSymHasInstance        = newSymbol(asciiString(\"Symbol.hasInstance\"))\n\tSymIsConcatSpreadable = newSymbol(asciiString(\"Symbol.isConcatSpreadable\"))\n\tSymIterator           = newSymbol(asciiString(\"Symbol.iterator\"))\n\tSymMatch              = newSymbol(asciiString(\"Symbol.match\"))\n\tSymMatchAll           = newSymbol(asciiString(\"Symbol.matchAll\"))\n\tSymReplace            = newSymbol(asciiString(\"Symbol.replace\"))\n\tSymSearch             = newSymbol(asciiString(\"Symbol.search\"))\n\tSymSpecies            = newSymbol(asciiString(\"Symbol.species\"))\n\tSymSplit              = newSymbol(asciiString(\"Symbol.split\"))\n\tSymToPrimitive        = newSymbol(asciiString(\"Symbol.toPrimitive\"))\n\tSymToStringTag        = newSymbol(asciiString(\"Symbol.toStringTag\"))\n\tSymUnscopables        = newSymbol(asciiString(\"Symbol.unscopables\"))\n)\n\nfunc (r *Runtime) builtin_symbol(call FunctionCall) Value {\n\tvar desc String\n\tif arg := call.Argument(0); !IsUndefined(arg) {\n\t\tdesc = arg.toString()\n\t}\n\treturn newSymbol(desc)\n}\n\nfunc (r *Runtime) symbolproto_tostring(call FunctionCall) Value {\n\tsym, ok := call.This.(*Symbol)\n\tif !ok {\n\t\tif obj, ok := call.This.(*Object); ok {\n\t\t\tif v, ok := obj.self.(*primitiveValueObject); ok {\n\t\t\t\tif sym1, ok := v.pValue.(*Symbol); ok {\n\t\t\t\t\tsym = sym1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif sym == nil {\n\t\tpanic(r.NewTypeError(\"Method Symbol.prototype.toString is called on incompatible receiver\"))\n\t}\n\treturn sym.descriptiveString()\n}\n\nfunc (r *Runtime) symbolproto_valueOf(call FunctionCall) Value {\n\t_, ok := call.This.(*Symbol)\n\tif ok {\n\t\treturn call.This\n\t}\n\n\tif obj, ok := call.This.(*Object); ok {\n\t\tif v, ok := obj.self.(*primitiveValueObject); ok {\n\t\t\tif sym, ok := v.pValue.(*Symbol); ok {\n\t\t\t\treturn sym\n\t\t\t}\n\t\t}\n\t}\n\n\tpanic(r.NewTypeError(\"Symbol.prototype.valueOf requires that 'this' be a Symbol\"))\n}\n\nfunc (r *Runtime) symbol_for(call FunctionCall) Value {\n\tkey := call.Argument(0).toString()\n\tkeyStr := key.string()\n\tif v := r.symbolRegistry[keyStr]; v != nil {\n\t\treturn v\n\t}\n\tif r.symbolRegistry == nil {\n\t\tr.symbolRegistry = make(map[unistring.String]*Symbol)\n\t}\n\tv := newSymbol(key)\n\tr.symbolRegistry[keyStr] = v\n\treturn v\n}\n\nfunc (r *Runtime) symbol_keyfor(call FunctionCall) Value {\n\targ := call.Argument(0)\n\tsym, ok := arg.(*Symbol)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"%s is not a symbol\", arg.String()))\n\t}\n\tfor key, s := range r.symbolRegistry {\n\t\tif s == sym {\n\t\t\treturn stringValueFromRaw(key)\n\t\t}\n\t}\n\treturn _undefined\n}\n\nfunc (r *Runtime) thisSymbolValue(v Value) *Symbol {\n\tif sym, ok := v.(*Symbol); ok {\n\t\treturn sym\n\t}\n\tif obj, ok := v.(*Object); ok {\n\t\tif pVal, ok := obj.self.(*primitiveValueObject); ok {\n\t\t\tif sym, ok := pVal.pValue.(*Symbol); ok {\n\t\t\t\treturn sym\n\t\t\t}\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Value is not a Symbol\"))\n}\n\nfunc (r *Runtime) createSymbolProto(val *Object) objectImpl {\n\to := &baseObject{\n\t\tclass:      classObject,\n\t\tval:        val,\n\t\textensible: true,\n\t\tprototype:  r.global.ObjectPrototype,\n\t}\n\to.init()\n\n\to._putProp(\"constructor\", r.getSymbol(), true, false, true)\n\to.setOwnStr(\"description\", &valueProperty{\n\t\tconfigurable: true,\n\t\tgetterFunc: r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\treturn r.thisSymbolValue(call.This).desc\n\t\t}, \"get description\", 0),\n\t\taccessor: true,\n\t}, false)\n\to._putProp(\"toString\", r.newNativeFunc(r.symbolproto_tostring, \"toString\", 0), true, false, true)\n\to._putProp(\"valueOf\", r.newNativeFunc(r.symbolproto_valueOf, \"valueOf\", 0), true, false, true)\n\to._putSym(SymToPrimitive, valueProp(r.newNativeFunc(r.symbolproto_valueOf, \"[Symbol.toPrimitive]\", 1), false, false, true))\n\to._putSym(SymToStringTag, valueProp(newStringValue(\"Symbol\"), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createSymbol(val *Object) objectImpl {\n\to := r.newNativeFuncAndConstruct(val, r.builtin_symbol, func(args []Value, newTarget *Object) *Object {\n\t\tpanic(r.NewTypeError(\"Symbol is not a constructor\"))\n\t}, r.getSymbolPrototype(), \"Symbol\", _positiveZero)\n\n\to._putProp(\"for\", r.newNativeFunc(r.symbol_for, \"for\", 1), true, false, true)\n\to._putProp(\"keyFor\", r.newNativeFunc(r.symbol_keyfor, \"keyFor\", 1), true, false, true)\n\n\tfor _, s := range []*Symbol{\n\t\tSymHasInstance,\n\t\tSymIsConcatSpreadable,\n\t\tSymIterator,\n\t\tSymMatch,\n\t\tSymMatchAll,\n\t\tSymReplace,\n\t\tSymSearch,\n\t\tSymSpecies,\n\t\tSymSplit,\n\t\tSymToPrimitive,\n\t\tSymToStringTag,\n\t\tSymUnscopables,\n\t} {\n\t\tn := s.desc.(asciiString)\n\t\tn = n[len(\"Symbol.\"):]\n\t\to._putProp(unistring.String(n), s, false, false, false)\n\t}\n\n\treturn o\n}\n\nfunc (r *Runtime) getSymbolPrototype() *Object {\n\tret := r.global.SymbolPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.SymbolPrototype = ret\n\t\tret.self = r.createSymbolProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getSymbol() *Object {\n\tret := r.global.Symbol\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Symbol = ret\n\t\tret.self = r.createSymbol(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_typedarrays.go",
          "type": "blob",
          "size": 67.90234375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype typedArraySortCtx struct {\n\tta           *typedArrayObject\n\tcompare      func(FunctionCall) Value\n\tneedValidate bool\n\tdetached     bool\n}\n\nfunc (ctx *typedArraySortCtx) Len() int {\n\treturn ctx.ta.length\n}\n\nfunc (ctx *typedArraySortCtx) checkDetached() {\n\tif !ctx.detached && ctx.needValidate {\n\t\tctx.detached = !ctx.ta.viewedArrayBuf.ensureNotDetached(false)\n\t\tctx.needValidate = false\n\t}\n}\n\nfunc (ctx *typedArraySortCtx) Less(i, j int) bool {\n\tctx.checkDetached()\n\tif ctx.detached {\n\t\treturn false\n\t}\n\toffset := ctx.ta.offset\n\tif ctx.compare != nil {\n\t\tx := ctx.ta.typedArray.get(offset + i)\n\t\ty := ctx.ta.typedArray.get(offset + j)\n\t\tres := ctx.compare(FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{x, y},\n\t\t}).ToNumber()\n\t\tctx.needValidate = true\n\t\tif i, ok := res.(valueInt); ok {\n\t\t\treturn i < 0\n\t\t}\n\t\tf := res.ToFloat()\n\t\tif f < 0 {\n\t\t\treturn true\n\t\t}\n\t\tif f > 0 {\n\t\t\treturn false\n\t\t}\n\t\tif math.Signbit(f) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\treturn ctx.ta.typedArray.less(offset+i, offset+j)\n}\n\nfunc (ctx *typedArraySortCtx) Swap(i, j int) {\n\tctx.checkDetached()\n\tif ctx.detached {\n\t\treturn\n\t}\n\toffset := ctx.ta.offset\n\tctx.ta.typedArray.swap(offset+i, offset+j)\n}\n\nfunc allocByteSlice(size int) (b []byte) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tpanic(rangeError(fmt.Sprintf(\"Buffer size is too large: %d\", size)))\n\t\t}\n\t}()\n\tif size < 0 {\n\t\tpanic(rangeError(fmt.Sprintf(\"Invalid buffer size: %d\", size)))\n\t}\n\tb = make([]byte, size)\n\treturn\n}\n\nfunc (r *Runtime) builtin_newArrayBuffer(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"ArrayBuffer\"))\n\t}\n\tb := r._newArrayBuffer(r.getPrototypeFromCtor(newTarget, r.getArrayBuffer(), r.getArrayBufferPrototype()), nil)\n\tif len(args) > 0 {\n\t\tb.data = allocByteSlice(r.toIndex(args[0]))\n\t}\n\treturn b.val\n}\n\nfunc (r *Runtime) arrayBufferProto_getByteLength(call FunctionCall) Value {\n\to := r.toObject(call.This)\n\tif b, ok := o.self.(*arrayBufferObject); ok {\n\t\tif b.ensureNotDetached(false) {\n\t\t\treturn intToValue(int64(len(b.data)))\n\t\t}\n\t\treturn intToValue(0)\n\t}\n\tpanic(r.NewTypeError(\"Object is not ArrayBuffer: %s\", o))\n}\n\nfunc (r *Runtime) arrayBufferProto_slice(call FunctionCall) Value {\n\to := r.toObject(call.This)\n\tif b, ok := o.self.(*arrayBufferObject); ok {\n\t\tl := int64(len(b.data))\n\t\tstart := relToIdx(call.Argument(0).ToInteger(), l)\n\t\tvar stop int64\n\t\tif arg := call.Argument(1); arg != _undefined {\n\t\t\tstop = arg.ToInteger()\n\t\t} else {\n\t\t\tstop = l\n\t\t}\n\t\tstop = relToIdx(stop, l)\n\t\tnewLen := max(stop-start, 0)\n\t\tret := r.speciesConstructor(o, r.getArrayBuffer())([]Value{intToValue(newLen)}, nil)\n\t\tif ab, ok := ret.self.(*arrayBufferObject); ok {\n\t\t\tif newLen > 0 {\n\t\t\t\tb.ensureNotDetached(true)\n\t\t\t\tif ret == o {\n\t\t\t\t\tpanic(r.NewTypeError(\"Species constructor returned the same ArrayBuffer\"))\n\t\t\t\t}\n\t\t\t\tif int64(len(ab.data)) < newLen {\n\t\t\t\t\tpanic(r.NewTypeError(\"Species constructor returned an ArrayBuffer that is too small: %d\", len(ab.data)))\n\t\t\t\t}\n\t\t\t\tab.ensureNotDetached(true)\n\t\t\t\tcopy(ab.data, b.data[start:stop])\n\t\t\t}\n\t\t\treturn ret\n\t\t}\n\t\tpanic(r.NewTypeError(\"Species constructor did not return an ArrayBuffer: %s\", ret.String()))\n\t}\n\tpanic(r.NewTypeError(\"Object is not ArrayBuffer: %s\", o))\n}\n\nfunc (r *Runtime) arrayBuffer_isView(call FunctionCall) Value {\n\tif o, ok := call.Argument(0).(*Object); ok {\n\t\tif _, ok := o.self.(*dataViewObject); ok {\n\t\t\treturn valueTrue\n\t\t}\n\t\tif _, ok := o.self.(*typedArrayObject); ok {\n\t\t\treturn valueTrue\n\t\t}\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) newDataView(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"DataView\"))\n\t}\n\tvar bufArg Value\n\tif len(args) > 0 {\n\t\tbufArg = args[0]\n\t}\n\tvar buffer *arrayBufferObject\n\tif o, ok := bufArg.(*Object); ok {\n\t\tif b, ok := o.self.(*arrayBufferObject); ok {\n\t\t\tbuffer = b\n\t\t}\n\t}\n\tif buffer == nil {\n\t\tpanic(r.NewTypeError(\"First argument to DataView constructor must be an ArrayBuffer\"))\n\t}\n\tvar byteOffset, byteLen int\n\tif len(args) > 1 {\n\t\toffsetArg := nilSafe(args[1])\n\t\tbyteOffset = r.toIndex(offsetArg)\n\t\tbuffer.ensureNotDetached(true)\n\t\tif byteOffset > len(buffer.data) {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Start offset %s is outside the bounds of the buffer\", offsetArg.String()))\n\t\t}\n\t}\n\tif len(args) > 2 && args[2] != nil && args[2] != _undefined {\n\t\tbyteLen = r.toIndex(args[2])\n\t\tif byteOffset+byteLen > len(buffer.data) {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid DataView length %d\", byteLen))\n\t\t}\n\t} else {\n\t\tbyteLen = len(buffer.data) - byteOffset\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, r.getDataView(), r.getDataViewPrototype())\n\tbuffer.ensureNotDetached(true)\n\tif byteOffset > len(buffer.data) {\n\t\tpanic(r.newError(r.getRangeError(), \"Start offset %d is outside the bounds of the buffer\", byteOffset))\n\t}\n\tif byteOffset+byteLen > len(buffer.data) {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid DataView length %d\", byteLen))\n\t}\n\to := &Object{runtime: r}\n\tb := &dataViewObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      classObject,\n\t\t\tval:        o,\n\t\t\tprototype:  proto,\n\t\t\textensible: true,\n\t\t},\n\t\tviewedArrayBuf: buffer,\n\t\tbyteOffset:     byteOffset,\n\t\tbyteLen:        byteLen,\n\t}\n\to.self = b\n\tb.init()\n\treturn o\n}\n\nfunc (r *Runtime) dataViewProto_getBuffer(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn dv.viewedArrayBuf.val\n\t}\n\tpanic(r.NewTypeError(\"Method get DataView.prototype.buffer called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getByteLen(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tdv.viewedArrayBuf.ensureNotDetached(true)\n\t\treturn intToValue(int64(dv.byteLen))\n\t}\n\tpanic(r.NewTypeError(\"Method get DataView.prototype.byteLength called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getByteOffset(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tdv.viewedArrayBuf.ensureNotDetached(true)\n\t\treturn intToValue(int64(dv.byteOffset))\n\t}\n\tpanic(r.NewTypeError(\"Method get DataView.prototype.byteOffset called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getFloat32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn floatToValue(float64(dv.viewedArrayBuf.getFloat32(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 4))))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getFloat32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getFloat64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn floatToValue(dv.viewedArrayBuf.getFloat64(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 8)))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getFloat64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getInt8(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidx, _ := dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 1)\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getInt8(idx)))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getInt8 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getInt16(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getInt16(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 2))))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getInt16 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getInt32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getInt32(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 4))))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getInt32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getUint8(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidx, _ := dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 1)\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getUint8(idx)))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getUint8 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getUint16(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getUint16(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 2))))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getUint16 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getUint32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn intToValue(int64(dv.viewedArrayBuf.getUint32(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0)), call.Argument(1), 4))))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getUint32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getBigInt64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn (*valueBigInt)(dv.viewedArrayBuf.getBigInt64(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0).ToNumber()), call.Argument(1), 8)))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getBigInt64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_getBigUint64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\treturn (*valueBigInt)(dv.viewedArrayBuf.getBigUint64(dv.getIdxAndByteOrder(r.toIndex(call.Argument(0).ToNumber()), call.Argument(1), 8)))\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.getBigUint64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setFloat32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toFloat32(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 4)\n\t\tdv.viewedArrayBuf.setFloat32(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setFloat32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setFloat64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := call.Argument(1).ToFloat()\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 8)\n\t\tdv.viewedArrayBuf.setFloat64(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setFloat64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setInt8(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toInt8(call.Argument(1))\n\t\tidx, _ := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 1)\n\t\tdv.viewedArrayBuf.setInt8(idx, val)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setInt8 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setInt16(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toInt16(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 2)\n\t\tdv.viewedArrayBuf.setInt16(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setInt16 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setInt32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toInt32(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 4)\n\t\tdv.viewedArrayBuf.setInt32(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setInt32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setUint8(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toUint8(call.Argument(1))\n\t\tidx, _ := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 1)\n\t\tdv.viewedArrayBuf.setUint8(idx, val)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setUint8 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setUint16(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toUint16(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 2)\n\t\tdv.viewedArrayBuf.setUint16(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setUint16 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setUint32(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toUint32(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 4)\n\t\tdv.viewedArrayBuf.setUint32(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setUint32 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setBigInt64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toBigInt64(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 8)\n\t\tdv.viewedArrayBuf.setBigInt64(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setBigInt64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) dataViewProto_setBigUint64(call FunctionCall) Value {\n\tif dv, ok := r.toObject(call.This).self.(*dataViewObject); ok {\n\t\tidxVal := r.toIndex(call.Argument(0))\n\t\tval := toBigUint64(call.Argument(1))\n\t\tidx, bo := dv.getIdxAndByteOrder(idxVal, call.Argument(2), 8)\n\t\tdv.viewedArrayBuf.setBigUint64(idx, val, bo)\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method DataView.prototype.setBigUint64 called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_getBuffer(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\treturn ta.viewedArrayBuf.val\n\t}\n\tpanic(r.NewTypeError(\"Method get TypedArray.prototype.buffer called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_getByteLen(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tif ta.viewedArrayBuf.data == nil {\n\t\t\treturn _positiveZero\n\t\t}\n\t\treturn intToValue(int64(ta.length) * int64(ta.elemSize))\n\t}\n\tpanic(r.NewTypeError(\"Method get TypedArray.prototype.byteLength called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_getLength(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tif ta.viewedArrayBuf.data == nil {\n\t\t\treturn _positiveZero\n\t\t}\n\t\treturn intToValue(int64(ta.length))\n\t}\n\tpanic(r.NewTypeError(\"Method get TypedArray.prototype.length called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_getByteOffset(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tif ta.viewedArrayBuf.data == nil {\n\t\t\treturn _positiveZero\n\t\t}\n\t\treturn intToValue(int64(ta.offset) * int64(ta.elemSize))\n\t}\n\tpanic(r.NewTypeError(\"Method get TypedArray.prototype.byteOffset called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_copyWithin(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tl := int64(ta.length)\n\t\tvar relEnd int64\n\t\tto := toIntStrict(relToIdx(call.Argument(0).ToInteger(), l))\n\t\tfrom := toIntStrict(relToIdx(call.Argument(1).ToInteger(), l))\n\t\tif end := call.Argument(2); end != _undefined {\n\t\t\trelEnd = end.ToInteger()\n\t\t} else {\n\t\t\trelEnd = l\n\t\t}\n\t\tfinal := toIntStrict(relToIdx(relEnd, l))\n\t\tdata := ta.viewedArrayBuf.data\n\t\toffset := ta.offset\n\t\telemSize := ta.elemSize\n\t\tif final > from {\n\t\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\t\tcopy(data[(offset+to)*elemSize:], data[(offset+from)*elemSize:(offset+final)*elemSize])\n\t\t}\n\t\treturn call.This\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.copyWithin called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_entries(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\treturn r.createArrayIterator(ta.val, iterationKindKeyValue)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.entries called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_every(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif !callbackFn(fc).ToBoolean() {\n\t\t\t\treturn valueFalse\n\t\t\t}\n\t\t}\n\t\treturn valueTrue\n\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.every called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_fill(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tl := int64(ta.length)\n\t\tk := toIntStrict(relToIdx(call.Argument(1).ToInteger(), l))\n\t\tvar relEnd int64\n\t\tif endArg := call.Argument(2); endArg != _undefined {\n\t\t\trelEnd = endArg.ToInteger()\n\t\t} else {\n\t\t\trelEnd = l\n\t\t}\n\t\tfinal := toIntStrict(relToIdx(relEnd, l))\n\t\tvalue := ta.typedArray.toRaw(call.Argument(0))\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tfor ; k < final; k++ {\n\t\t\tta.typedArray.setRaw(ta.offset+k, value)\n\t\t}\n\t\treturn call.This\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.fill called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_filter(call FunctionCall) Value {\n\to := r.toObject(call.This)\n\tif ta, ok := o.self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tbuf := make([]byte, 0, ta.length*ta.elemSize)\n\t\tcaptured := 0\n\t\trawVal := make([]byte, ta.elemSize)\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t\ti := (ta.offset + k) * ta.elemSize\n\t\t\t\tcopy(rawVal, ta.viewedArrayBuf.data[i:])\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t\tfor i := range rawVal {\n\t\t\t\t\trawVal[i] = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif callbackFn(fc).ToBoolean() {\n\t\t\t\tbuf = append(buf, rawVal...)\n\t\t\t\tcaptured++\n\t\t\t}\n\t\t}\n\t\tc := r.speciesConstructorObj(o, ta.defaultCtor)\n\t\tab := r._newArrayBuffer(r.getArrayBufferPrototype(), nil)\n\t\tab.data = buf\n\t\tkept := r.toConstructor(ta.defaultCtor)([]Value{ab.val}, ta.defaultCtor)\n\t\tif c == ta.defaultCtor {\n\t\t\treturn kept\n\t\t} else {\n\t\t\tret := r.typedArrayCreate(c, intToValue(int64(captured)))\n\t\t\tkeptTa := kept.self.(*typedArrayObject)\n\t\t\tfor i := 0; i < captured; i++ {\n\t\t\t\tret.typedArray.set(i, keptTa.typedArray.get(keptTa.offset+i))\n\t\t\t}\n\t\t\treturn ret.val\n\t\t}\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.filter called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_find(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tpredicate := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tvar val Value\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tval = ta.typedArray.get(ta.offset + k)\n\t\t\t}\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif predicate(fc).ToBoolean() {\n\t\t\t\treturn val\n\t\t\t}\n\t\t}\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.find called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_findIndex(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tpredicate := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif predicate(fc).ToBoolean() {\n\t\t\t\treturn fc.Arguments[1]\n\t\t\t}\n\t\t}\n\t\treturn intToValue(-1)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.findIndex called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_findLast(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tpredicate := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := ta.length - 1; k >= 0; k-- {\n\t\t\tvar val Value\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tval = ta.typedArray.get(ta.offset + k)\n\t\t\t}\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif predicate(fc).ToBoolean() {\n\t\t\t\treturn val\n\t\t\t}\n\t\t}\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.findLast called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_findLastIndex(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tpredicate := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := ta.length - 1; k >= 0; k-- {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif predicate(fc).ToBoolean() {\n\t\t\t\treturn fc.Arguments[1]\n\t\t\t}\n\t\t}\n\t\treturn intToValue(-1)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.findLastIndex called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_forEach(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tvar val Value\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tval = ta.typedArray.get(ta.offset + k)\n\t\t\t}\n\t\t\tfc.Arguments[0] = val\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tcallbackFn(fc)\n\t\t}\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.forEach called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_includes(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tlength := int64(ta.length)\n\t\tif length == 0 {\n\t\t\treturn valueFalse\n\t\t}\n\n\t\tn := call.Argument(1).ToInteger()\n\t\tif n >= length {\n\t\t\treturn valueFalse\n\t\t}\n\n\t\tif n < 0 {\n\t\t\tn = max(length+n, 0)\n\t\t}\n\n\t\tsearchElement := call.Argument(0)\n\t\tif searchElement == _negativeZero {\n\t\t\tsearchElement = _positiveZero\n\t\t}\n\t\tstartIdx := toIntStrict(n)\n\t\tif !ta.viewedArrayBuf.ensureNotDetached(false) {\n\t\t\tif searchElement == _undefined && startIdx < ta.length {\n\t\t\t\treturn valueTrue\n\t\t\t}\n\t\t\treturn valueFalse\n\t\t}\n\t\tif ta.typedArray.typeMatch(searchElement) {\n\t\t\tse := ta.typedArray.toRaw(searchElement)\n\t\t\tfor k := startIdx; k < ta.length; k++ {\n\t\t\t\tif ta.typedArray.getRaw(ta.offset+k) == se {\n\t\t\t\t\treturn valueTrue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn valueFalse\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.includes called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_at(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tidx := call.Argument(0).ToInteger()\n\t\tlength := int64(ta.length)\n\t\tif idx < 0 {\n\t\t\tidx = length + idx\n\t\t}\n\t\tif idx >= length || idx < 0 {\n\t\t\treturn _undefined\n\t\t}\n\t\tif ta.viewedArrayBuf.ensureNotDetached(false) {\n\t\t\treturn ta.typedArray.get(ta.offset + int(idx))\n\t\t}\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.at called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_indexOf(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tlength := int64(ta.length)\n\t\tif length == 0 {\n\t\t\treturn intToValue(-1)\n\t\t}\n\n\t\tn := call.Argument(1).ToInteger()\n\t\tif n >= length {\n\t\t\treturn intToValue(-1)\n\t\t}\n\n\t\tif n < 0 {\n\t\t\tn = max(length+n, 0)\n\t\t}\n\n\t\tif ta.viewedArrayBuf.ensureNotDetached(false) {\n\t\t\tsearchElement := call.Argument(0)\n\t\t\tif searchElement == _negativeZero {\n\t\t\t\tsearchElement = _positiveZero\n\t\t\t}\n\t\t\tif !IsNaN(searchElement) && ta.typedArray.typeMatch(searchElement) {\n\t\t\t\tse := ta.typedArray.toRaw(searchElement)\n\t\t\t\tfor k := toIntStrict(n); k < ta.length; k++ {\n\t\t\t\t\tif ta.typedArray.getRaw(ta.offset+k) == se {\n\t\t\t\t\t\treturn intToValue(int64(k))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn intToValue(-1)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.indexOf called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_join(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\ts := call.Argument(0)\n\t\tvar sep String\n\t\tif s != _undefined {\n\t\t\tsep = s.toString()\n\t\t} else {\n\t\t\tsep = asciiString(\",\")\n\t\t}\n\t\tl := ta.length\n\t\tif l == 0 {\n\t\t\treturn stringEmpty\n\t\t}\n\n\t\tvar buf StringBuilder\n\n\t\tvar element0 Value\n\t\tif ta.isValidIntegerIndex(0) {\n\t\t\telement0 = ta.typedArray.get(ta.offset + 0)\n\t\t}\n\t\tif element0 != nil && element0 != _undefined && element0 != _null {\n\t\t\tbuf.WriteString(element0.toString())\n\t\t}\n\n\t\tfor i := 1; i < l; i++ {\n\t\t\tbuf.WriteString(sep)\n\t\t\tif ta.isValidIntegerIndex(i) {\n\t\t\t\telement := ta.typedArray.get(ta.offset + i)\n\t\t\t\tif element != nil && element != _undefined && element != _null {\n\t\t\t\t\tbuf.WriteString(element.toString())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf.String()\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.join called on incompatible receiver\"))\n}\n\nfunc (r *Runtime) typedArrayProto_keys(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\treturn r.createArrayIterator(ta.val, iterationKindKey)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.keys called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_lastIndexOf(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tlength := int64(ta.length)\n\t\tif length == 0 {\n\t\t\treturn intToValue(-1)\n\t\t}\n\n\t\tvar fromIndex int64\n\n\t\tif len(call.Arguments) < 2 {\n\t\t\tfromIndex = length - 1\n\t\t} else {\n\t\t\tfromIndex = call.Argument(1).ToInteger()\n\t\t\tif fromIndex >= 0 {\n\t\t\t\tfromIndex = min(fromIndex, length-1)\n\t\t\t} else {\n\t\t\t\tfromIndex += length\n\t\t\t\tif fromIndex < 0 {\n\t\t\t\t\tfromIndex = -1 // prevent underflow in toIntStrict() on 32-bit platforms\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ta.viewedArrayBuf.ensureNotDetached(false) {\n\t\t\tsearchElement := call.Argument(0)\n\t\t\tif searchElement == _negativeZero {\n\t\t\t\tsearchElement = _positiveZero\n\t\t\t}\n\t\t\tif !IsNaN(searchElement) && ta.typedArray.typeMatch(searchElement) {\n\t\t\t\tse := ta.typedArray.toRaw(searchElement)\n\t\t\t\tfor k := toIntStrict(fromIndex); k >= 0; k-- {\n\t\t\t\t\tif ta.typedArray.getRaw(ta.offset+k) == se {\n\t\t\t\t\t\treturn intToValue(int64(k))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn intToValue(-1)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.lastIndexOf called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_map(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tdst := r.typedArraySpeciesCreate(ta, []Value{intToValue(int64(ta.length))})\n\t\tfor i := 0; i < ta.length; i++ {\n\t\t\tif ta.isValidIntegerIndex(i) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + i)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(i))\n\t\t\tdst.typedArray.set(i, callbackFn(fc))\n\t\t}\n\t\treturn dst.val\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.map called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_reduce(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{nil, nil, nil, call.This},\n\t\t}\n\t\tk := 0\n\t\tif len(call.Arguments) >= 2 {\n\t\t\tfc.Arguments[0] = call.Argument(1)\n\t\t} else {\n\t\t\tif ta.length > 0 {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + 0)\n\t\t\t\tk = 1\n\t\t\t}\n\t\t}\n\t\tif fc.Arguments[0] == nil {\n\t\t\tpanic(r.NewTypeError(\"Reduce of empty array with no initial value\"))\n\t\t}\n\t\tfor ; k < ta.length; k++ {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[1] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[1] = _undefined\n\t\t\t}\n\t\t\tidx := valueInt(k)\n\t\t\tfc.Arguments[2] = idx\n\t\t\tfc.Arguments[0] = callbackFn(fc)\n\t\t}\n\t\treturn fc.Arguments[0]\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.reduce called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_reduceRight(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      _undefined,\n\t\t\tArguments: []Value{nil, nil, nil, call.This},\n\t\t}\n\t\tk := ta.length - 1\n\t\tif len(call.Arguments) >= 2 {\n\t\t\tfc.Arguments[0] = call.Argument(1)\n\t\t} else {\n\t\t\tif k >= 0 {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t\tk--\n\t\t\t}\n\t\t}\n\t\tif fc.Arguments[0] == nil {\n\t\t\tpanic(r.NewTypeError(\"Reduce of empty array with no initial value\"))\n\t\t}\n\t\tfor ; k >= 0; k-- {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[1] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[1] = _undefined\n\t\t\t}\n\t\t\tidx := valueInt(k)\n\t\t\tfc.Arguments[2] = idx\n\t\t\tfc.Arguments[0] = callbackFn(fc)\n\t\t}\n\t\treturn fc.Arguments[0]\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.reduceRight called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_reverse(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tl := ta.length\n\t\tmiddle := l / 2\n\t\tfor lower := 0; lower != middle; lower++ {\n\t\t\tupper := l - lower - 1\n\t\t\tta.typedArray.swap(ta.offset+lower, ta.offset+upper)\n\t\t}\n\n\t\treturn call.This\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.reverse called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_set(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tsrcObj := call.Argument(0).ToObject(r)\n\t\ttargetOffset := toIntStrict(call.Argument(1).ToInteger())\n\t\tif targetOffset < 0 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"offset should be >= 0\"))\n\t\t}\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\ttargetLen := ta.length\n\t\tif src, ok := srcObj.self.(*typedArrayObject); ok {\n\t\t\tsrc.viewedArrayBuf.ensureNotDetached(true)\n\t\t\tsrcLen := src.length\n\t\t\tif x := srcLen + targetOffset; x < 0 || x > targetLen {\n\t\t\t\tpanic(r.newError(r.getRangeError(), \"Source is too large\"))\n\t\t\t}\n\t\t\tif src.defaultCtor == ta.defaultCtor {\n\t\t\t\tcopy(ta.viewedArrayBuf.data[(ta.offset+targetOffset)*ta.elemSize:],\n\t\t\t\t\tsrc.viewedArrayBuf.data[src.offset*src.elemSize:(src.offset+srcLen)*src.elemSize])\n\t\t\t} else {\n\t\t\t\tcheckTypedArrayMixBigInt(src.defaultCtor, ta.defaultCtor)\n\t\t\t\tcurSrc := uintptr(unsafe.Pointer(&src.viewedArrayBuf.data[src.offset*src.elemSize]))\n\t\t\t\tendSrc := curSrc + uintptr(srcLen*src.elemSize)\n\t\t\t\tcurDst := uintptr(unsafe.Pointer(&ta.viewedArrayBuf.data[(ta.offset+targetOffset)*ta.elemSize]))\n\t\t\t\tdstOffset := ta.offset + targetOffset\n\t\t\t\tsrcOffset := src.offset\n\t\t\t\tif ta.elemSize == src.elemSize {\n\t\t\t\t\tif curDst <= curSrc || curDst >= endSrc {\n\t\t\t\t\t\tfor i := 0; i < srcLen; i++ {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor i := srcLen - 1; i >= 0; i-- {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx := int(curDst-curSrc) / (src.elemSize - ta.elemSize)\n\t\t\t\t\tif x < 0 {\n\t\t\t\t\t\tx = 0\n\t\t\t\t\t} else if x > srcLen {\n\t\t\t\t\t\tx = srcLen\n\t\t\t\t\t}\n\t\t\t\t\tif ta.elemSize < src.elemSize {\n\t\t\t\t\t\tfor i := x; i < srcLen; i++ {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := x - 1; i >= 0; i-- {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor i := 0; i < x; i++ {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := srcLen - 1; i >= x; i-- {\n\t\t\t\t\t\t\tta.typedArray.set(dstOffset+i, src.typedArray.get(srcOffset+i))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttargetLen := ta.length\n\t\t\tsrcLen := toIntStrict(toLength(srcObj.self.getStr(\"length\", nil)))\n\t\t\tif x := srcLen + targetOffset; x < 0 || x > targetLen {\n\t\t\t\tpanic(r.newError(r.getRangeError(), \"Source is too large\"))\n\t\t\t}\n\t\t\tfor i := 0; i < srcLen; i++ {\n\t\t\t\tval := nilSafe(srcObj.self.getIdx(valueInt(i), nil))\n\t\t\t\tif ta.isValidIntegerIndex(i) {\n\t\t\t\t\tta.typedArray.set(targetOffset+i, val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _undefined\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.set called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_slice(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tlength := int64(ta.length)\n\t\tstart := toIntStrict(relToIdx(call.Argument(0).ToInteger(), length))\n\t\tvar e int64\n\t\tif endArg := call.Argument(1); endArg != _undefined {\n\t\t\te = endArg.ToInteger()\n\t\t} else {\n\t\t\te = length\n\t\t}\n\t\tend := toIntStrict(relToIdx(e, length))\n\n\t\tcount := end - start\n\t\tif count < 0 {\n\t\t\tcount = 0\n\t\t}\n\t\tdst := r.typedArraySpeciesCreate(ta, []Value{intToValue(int64(count))})\n\t\tif dst.defaultCtor == ta.defaultCtor {\n\t\t\tif count > 0 {\n\t\t\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\t\t\toffset := ta.offset\n\t\t\t\telemSize := ta.elemSize\n\t\t\t\tcopy(dst.viewedArrayBuf.data, ta.viewedArrayBuf.data[(offset+start)*elemSize:(offset+start+count)*elemSize])\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\t\t\tdst.typedArray.set(i, ta.typedArray.get(ta.offset+start+i))\n\t\t\t}\n\t\t}\n\t\treturn dst.val\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.slice called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_some(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tcallbackFn := r.toCallable(call.Argument(0))\n\t\tfc := FunctionCall{\n\t\t\tThis:      call.Argument(1),\n\t\t\tArguments: []Value{nil, nil, call.This},\n\t\t}\n\t\tfor k := 0; k < ta.length; k++ {\n\t\t\tif ta.isValidIntegerIndex(k) {\n\t\t\t\tfc.Arguments[0] = ta.typedArray.get(ta.offset + k)\n\t\t\t} else {\n\t\t\t\tfc.Arguments[0] = _undefined\n\t\t\t}\n\t\t\tfc.Arguments[1] = intToValue(int64(k))\n\t\t\tif callbackFn(fc).ToBoolean() {\n\t\t\t\treturn valueTrue\n\t\t\t}\n\t\t}\n\t\treturn valueFalse\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.some called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_sort(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tvar compareFn func(FunctionCall) Value\n\n\t\tif arg := call.Argument(0); arg != _undefined {\n\t\t\tcompareFn = r.toCallable(arg)\n\t\t}\n\n\t\tctx := typedArraySortCtx{\n\t\t\tta:      ta,\n\t\t\tcompare: compareFn,\n\t\t}\n\n\t\tsort.Stable(&ctx)\n\t\treturn call.This\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.sort called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_subarray(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tl := int64(ta.length)\n\t\tbeginIdx := relToIdx(call.Argument(0).ToInteger(), l)\n\t\tvar relEnd int64\n\t\tif endArg := call.Argument(1); endArg != _undefined {\n\t\t\trelEnd = endArg.ToInteger()\n\t\t} else {\n\t\t\trelEnd = l\n\t\t}\n\t\tendIdx := relToIdx(relEnd, l)\n\t\tnewLen := max(endIdx-beginIdx, 0)\n\t\treturn r.typedArraySpeciesCreate(ta, []Value{ta.viewedArrayBuf.val,\n\t\t\tintToValue((int64(ta.offset) + beginIdx) * int64(ta.elemSize)),\n\t\t\tintToValue(newLen),\n\t\t}).val\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.subarray called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_toLocaleString(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tlength := ta.length\n\t\tvar buf StringBuilder\n\t\tfor i := 0; i < length; i++ {\n\t\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteRune(',')\n\t\t\t}\n\t\t\titem := ta.typedArray.get(ta.offset + i)\n\t\t\tr.writeItemLocaleString(item, &buf)\n\t\t}\n\t\treturn buf.String()\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.toLocaleString called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_values(call FunctionCall) Value {\n\tif ta, ok := r.toObject(call.This).self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\treturn r.createArrayIterator(ta.val, iterationKindValue)\n\t}\n\tpanic(r.NewTypeError(\"Method TypedArray.prototype.values called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: call.This})))\n}\n\nfunc (r *Runtime) typedArrayProto_toStringTag(call FunctionCall) Value {\n\tif obj, ok := call.This.(*Object); ok {\n\t\tif ta, ok := obj.self.(*typedArrayObject); ok {\n\t\t\treturn nilSafe(ta.defaultCtor.self.getStr(\"name\", nil))\n\t\t}\n\t}\n\n\treturn _undefined\n}\n\nfunc (r *Runtime) typedArrayProto_with(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tta, ok := o.self.(*typedArrayObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"%s is not a valid TypedArray\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n\tta.viewedArrayBuf.ensureNotDetached(true)\n\tlength := ta.length\n\trelativeIndex := call.Argument(0).ToInteger()\n\tvar actualIndex int\n\n\tif relativeIndex >= 0 {\n\t\tactualIndex = toIntStrict(relativeIndex)\n\t} else {\n\t\tactualIndex = toIntStrict(int64(length) + relativeIndex)\n\t}\n\tif !ta.isValidIntegerIndex(actualIndex) {\n\t\tpanic(r.newError(r.getRangeError(), \"Invalid typed array index\"))\n\t}\n\n\tvar numericValue Value\n\tswitch ta.typedArray.(type) {\n\tcase *bigInt64Array, *bigUint64Array:\n\t\tnumericValue = toBigInt(call.Argument(1))\n\tdefault:\n\t\tnumericValue = call.Argument(1).ToNumber()\n\t}\n\n\ta := r.typedArrayCreate(ta.defaultCtor, intToValue(int64(length)))\n\tfor k := 0; k < length; k++ {\n\t\tvar fromValue Value\n\t\tif k == actualIndex {\n\t\t\tfromValue = numericValue\n\t\t} else {\n\t\t\tfromValue = ta.typedArray.get(ta.offset + k)\n\t\t}\n\t\ta.typedArray.set(ta.offset+k, fromValue)\n\t}\n\treturn a.val\n}\n\nfunc (r *Runtime) typedArrayProto_toReversed(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tta, ok := o.self.(*typedArrayObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"%s is not a valid TypedArray\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n\tta.viewedArrayBuf.ensureNotDetached(true)\n\tlength := ta.length\n\n\ta := r.typedArrayCreate(ta.defaultCtor, intToValue(int64(length)))\n\n\tfor k := 0; k < length; k++ {\n\t\tfrom := length - k - 1\n\t\tfromValue := ta.typedArray.get(ta.offset + from)\n\t\ta.typedArray.set(ta.offset+k, fromValue)\n\t}\n\n\treturn a.val\n}\n\nfunc (r *Runtime) typedArrayProto_toSorted(call FunctionCall) Value {\n\to := call.This.ToObject(r)\n\tta, ok := o.self.(*typedArrayObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"%s is not a valid TypedArray\", r.objectproto_toString(FunctionCall{This: call.This})))\n\t}\n\tta.viewedArrayBuf.ensureNotDetached(true)\n\n\tvar compareFn func(FunctionCall) Value\n\targ := call.Argument(0)\n\tif arg != _undefined {\n\t\tif arg, ok := arg.(*Object); ok {\n\t\t\tcompareFn, _ = arg.self.assertCallable()\n\t\t}\n\t\tif compareFn == nil {\n\t\t\tpanic(r.NewTypeError(\"The comparison function must be either a function or undefined\"))\n\t\t}\n\t}\n\n\tlength := ta.length\n\n\ta := r.typedArrayCreate(ta.defaultCtor, intToValue(int64(length)))\n\tcopy(a.viewedArrayBuf.data, ta.viewedArrayBuf.data)\n\n\tctx := typedArraySortCtx{\n\t\tta:      a,\n\t\tcompare: compareFn,\n\t}\n\n\tsort.Stable(&ctx)\n\n\treturn a.val\n}\n\nfunc (r *Runtime) newTypedArray([]Value, *Object) *Object {\n\tpanic(r.NewTypeError(\"Abstract class TypedArray not directly constructable\"))\n}\n\nfunc (r *Runtime) typedArray_from(call FunctionCall) Value {\n\tc := r.toObject(call.This)\n\tvar mapFc func(call FunctionCall) Value\n\tthisValue := call.Argument(2)\n\tif mapFn := call.Argument(1); mapFn != _undefined {\n\t\tmapFc = r.toCallable(mapFn)\n\t}\n\tsource := r.toObject(call.Argument(0))\n\tusingIter := toMethod(source.self.getSym(SymIterator, nil))\n\tif usingIter != nil {\n\t\tvalues := r.iterableToList(source, usingIter)\n\t\tta := r.typedArrayCreate(c, intToValue(int64(len(values))))\n\t\tif mapFc == nil {\n\t\t\tfor idx, val := range values {\n\t\t\t\tta.typedArray.set(idx, val)\n\t\t\t}\n\t\t} else {\n\t\t\tfc := FunctionCall{\n\t\t\t\tThis:      thisValue,\n\t\t\t\tArguments: []Value{nil, nil},\n\t\t\t}\n\t\t\tfor idx, val := range values {\n\t\t\t\tfc.Arguments[0], fc.Arguments[1] = val, intToValue(int64(idx))\n\t\t\t\tval = mapFc(fc)\n\t\t\t\tta._putIdx(idx, val)\n\t\t\t}\n\t\t}\n\t\treturn ta.val\n\t}\n\tlength := toIntStrict(toLength(source.self.getStr(\"length\", nil)))\n\tta := r.typedArrayCreate(c, intToValue(int64(length)))\n\tif mapFc == nil {\n\t\tfor i := 0; i < length; i++ {\n\t\t\tta.typedArray.set(i, nilSafe(source.self.getIdx(valueInt(i), nil)))\n\t\t}\n\t} else {\n\t\tfc := FunctionCall{\n\t\t\tThis:      thisValue,\n\t\t\tArguments: []Value{nil, nil},\n\t\t}\n\t\tfor i := 0; i < length; i++ {\n\t\t\tidx := valueInt(i)\n\t\t\tfc.Arguments[0], fc.Arguments[1] = source.self.getIdx(idx, nil), idx\n\t\t\tta.typedArray.set(i, mapFc(fc))\n\t\t}\n\t}\n\treturn ta.val\n}\n\nfunc (r *Runtime) typedArray_of(call FunctionCall) Value {\n\tta := r.typedArrayCreate(r.toObject(call.This), intToValue(int64(len(call.Arguments))))\n\tfor i, val := range call.Arguments {\n\t\tta.typedArray.set(i, val)\n\t}\n\treturn ta.val\n}\n\nfunc (r *Runtime) allocateTypedArray(newTarget *Object, length int, taCtor typedArrayObjectCtor, proto *Object) *typedArrayObject {\n\tbuf := r._newArrayBuffer(r.getArrayBufferPrototype(), nil)\n\tta := taCtor(buf, 0, length, r.getPrototypeFromCtor(newTarget, nil, proto))\n\tif length > 0 {\n\t\tbuf.data = allocByteSlice(length * ta.elemSize)\n\t}\n\treturn ta\n}\n\nfunc (r *Runtime) typedArraySpeciesCreate(ta *typedArrayObject, args []Value) *typedArrayObject {\n\treturn r.typedArrayCreate(r.speciesConstructorObj(ta.val, ta.defaultCtor), args...)\n}\n\nfunc (r *Runtime) typedArrayCreate(ctor *Object, args ...Value) *typedArrayObject {\n\to := r.toConstructor(ctor)(args, ctor)\n\tif ta, ok := o.self.(*typedArrayObject); ok {\n\t\tta.viewedArrayBuf.ensureNotDetached(true)\n\t\tif len(args) == 1 {\n\t\t\tif l, ok := args[0].(valueInt); ok {\n\t\t\t\tif ta.length < int(l) {\n\t\t\t\t\tpanic(r.NewTypeError(\"Derived TypedArray constructor created an array which was too small\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ta\n\t}\n\tpanic(r.NewTypeError(\"Invalid TypedArray: %s\", o))\n}\n\nfunc (r *Runtime) typedArrayFrom(ctor, items *Object, mapFn, thisValue Value, taCtor typedArrayObjectCtor, proto *Object) *Object {\n\tvar mapFc func(call FunctionCall) Value\n\tif mapFn != nil {\n\t\tmapFc = r.toCallable(mapFn)\n\t\tif thisValue == nil {\n\t\t\tthisValue = _undefined\n\t\t}\n\t}\n\tusingIter := toMethod(items.self.getSym(SymIterator, nil))\n\tif usingIter != nil {\n\t\tvalues := r.iterableToList(items, usingIter)\n\t\tta := r.allocateTypedArray(ctor, len(values), taCtor, proto)\n\t\tif mapFc == nil {\n\t\t\tfor idx, val := range values {\n\t\t\t\tta.typedArray.set(idx, val)\n\t\t\t}\n\t\t} else {\n\t\t\tfc := FunctionCall{\n\t\t\t\tThis:      thisValue,\n\t\t\t\tArguments: []Value{nil, nil},\n\t\t\t}\n\t\t\tfor idx, val := range values {\n\t\t\t\tfc.Arguments[0], fc.Arguments[1] = val, intToValue(int64(idx))\n\t\t\t\tval = mapFc(fc)\n\t\t\t\tta.typedArray.set(idx, val)\n\t\t\t}\n\t\t}\n\t\treturn ta.val\n\t}\n\tlength := toIntStrict(toLength(items.self.getStr(\"length\", nil)))\n\tta := r.allocateTypedArray(ctor, length, taCtor, proto)\n\tif mapFc == nil {\n\t\tfor i := 0; i < length; i++ {\n\t\t\tta.typedArray.set(i, nilSafe(items.self.getIdx(valueInt(i), nil)))\n\t\t}\n\t} else {\n\t\tfc := FunctionCall{\n\t\t\tThis:      thisValue,\n\t\t\tArguments: []Value{nil, nil},\n\t\t}\n\t\tfor i := 0; i < length; i++ {\n\t\t\tidx := valueInt(i)\n\t\t\tfc.Arguments[0], fc.Arguments[1] = items.self.getIdx(idx, nil), idx\n\t\t\tta.typedArray.set(i, mapFc(fc))\n\t\t}\n\t}\n\treturn ta.val\n}\n\nfunc (r *Runtime) _newTypedArrayFromArrayBuffer(ab *arrayBufferObject, args []Value, newTarget *Object, taCtor typedArrayObjectCtor, proto *Object) *Object {\n\tta := taCtor(ab, 0, 0, r.getPrototypeFromCtor(newTarget, nil, proto))\n\tvar byteOffset int\n\tif len(args) > 1 && args[1] != nil && args[1] != _undefined {\n\t\tbyteOffset = r.toIndex(args[1])\n\t\tif byteOffset%ta.elemSize != 0 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Start offset of %s should be a multiple of %d\", newTarget.self.getStr(\"name\", nil), ta.elemSize))\n\t\t}\n\t}\n\tvar length int\n\tif len(args) > 2 && args[2] != nil && args[2] != _undefined {\n\t\tlength = r.toIndex(args[2])\n\t\tab.ensureNotDetached(true)\n\t\tif byteOffset+length*ta.elemSize > len(ab.data) {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Invalid typed array length: %d\", length))\n\t\t}\n\t} else {\n\t\tab.ensureNotDetached(true)\n\t\tif len(ab.data)%ta.elemSize != 0 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Byte length of %s should be a multiple of %d\", newTarget.self.getStr(\"name\", nil), ta.elemSize))\n\t\t}\n\t\tlength = (len(ab.data) - byteOffset) / ta.elemSize\n\t\tif length < 0 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Start offset %d is outside the bounds of the buffer\", byteOffset))\n\t\t}\n\t}\n\tta.offset = byteOffset / ta.elemSize\n\tta.length = length\n\treturn ta.val\n}\n\nfunc checkTypedArrayMixBigInt(src, dst *Object) {\n\tsrcType := src.self.getStr(\"name\", nil).String()\n\tif strings.HasPrefix(srcType, \"Big\") {\n\t\tif !strings.HasPrefix(dst.self.getStr(\"name\", nil).String(), \"Big\") {\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) _newTypedArrayFromTypedArray(src *typedArrayObject, newTarget *Object, taCtor typedArrayObjectCtor, proto *Object) *Object {\n\tdst := r.allocateTypedArray(newTarget, 0, taCtor, proto)\n\tsrc.viewedArrayBuf.ensureNotDetached(true)\n\tl := src.length\n\n\tdst.viewedArrayBuf.data = allocByteSlice(toIntStrict(int64(l) * int64(dst.elemSize)))\n\tsrc.viewedArrayBuf.ensureNotDetached(true)\n\tif src.defaultCtor == dst.defaultCtor {\n\t\tcopy(dst.viewedArrayBuf.data, src.viewedArrayBuf.data[src.offset*src.elemSize:])\n\t\tdst.length = src.length\n\t\treturn dst.val\n\t} else {\n\t\tcheckTypedArrayMixBigInt(src.defaultCtor, newTarget)\n\t}\n\tdst.length = l\n\tfor i := 0; i < l; i++ {\n\t\tdst.typedArray.set(i, src.typedArray.get(src.offset+i))\n\t}\n\treturn dst.val\n}\n\nfunc (r *Runtime) _newTypedArray(args []Value, newTarget *Object, taCtor typedArrayObjectCtor, proto *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"TypedArray\"))\n\t}\n\tif len(args) > 0 {\n\t\tif obj, ok := args[0].(*Object); ok {\n\t\t\tswitch o := obj.self.(type) {\n\t\t\tcase *arrayBufferObject:\n\t\t\t\treturn r._newTypedArrayFromArrayBuffer(o, args, newTarget, taCtor, proto)\n\t\t\tcase *typedArrayObject:\n\t\t\t\treturn r._newTypedArrayFromTypedArray(o, newTarget, taCtor, proto)\n\t\t\tdefault:\n\t\t\t\treturn r.typedArrayFrom(newTarget, obj, nil, nil, taCtor, proto)\n\t\t\t}\n\t\t}\n\t}\n\tvar l int\n\tif len(args) > 0 {\n\t\tif arg0 := args[0]; arg0 != nil {\n\t\t\tl = r.toIndex(arg0)\n\t\t}\n\t}\n\treturn r.allocateTypedArray(newTarget, l, taCtor, proto).val\n}\n\nfunc (r *Runtime) newUint8Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newUint8ArrayObject, proto)\n}\n\nfunc (r *Runtime) newUint8ClampedArray(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newUint8ClampedArrayObject, proto)\n}\n\nfunc (r *Runtime) newInt8Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newInt8ArrayObject, proto)\n}\n\nfunc (r *Runtime) newUint16Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newUint16ArrayObject, proto)\n}\n\nfunc (r *Runtime) newInt16Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newInt16ArrayObject, proto)\n}\n\nfunc (r *Runtime) newUint32Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newUint32ArrayObject, proto)\n}\n\nfunc (r *Runtime) newInt32Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newInt32ArrayObject, proto)\n}\n\nfunc (r *Runtime) newFloat32Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newFloat32ArrayObject, proto)\n}\n\nfunc (r *Runtime) newFloat64Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newFloat64ArrayObject, proto)\n}\n\nfunc (r *Runtime) newBigInt64Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newBigInt64ArrayObject, proto)\n}\n\nfunc (r *Runtime) newBigUint64Array(args []Value, newTarget, proto *Object) *Object {\n\treturn r._newTypedArray(args, newTarget, r.newBigUint64ArrayObject, proto)\n}\n\nfunc (r *Runtime) createArrayBufferProto(val *Object) objectImpl {\n\tb := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\tbyteLengthProp := &valueProperty{\n\t\taccessor:     true,\n\t\tconfigurable: true,\n\t\tgetterFunc:   r.newNativeFunc(r.arrayBufferProto_getByteLength, \"get byteLength\", 0),\n\t}\n\tb._put(\"byteLength\", byteLengthProp)\n\tb._putProp(\"constructor\", r.getArrayBuffer(), true, false, true)\n\tb._putProp(\"slice\", r.newNativeFunc(r.arrayBufferProto_slice, \"slice\", 2), true, false, true)\n\tb._putSym(SymToStringTag, valueProp(asciiString(\"ArrayBuffer\"), false, false, true))\n\treturn b\n}\n\nfunc (r *Runtime) createArrayBuffer(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newArrayBuffer, r.getArrayBufferPrototype(), \"ArrayBuffer\", 1)\n\to._putProp(\"isView\", r.newNativeFunc(r.arrayBuffer_isView, \"isView\", 1), true, false, true)\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) createDataView(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.newDataView, r.getDataViewPrototype(), \"DataView\", 1)\n\treturn o\n}\n\nfunc (r *Runtime) createTypedArray(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.newTypedArray, r.getTypedArrayPrototype(), \"TypedArray\", 0)\n\to._putProp(\"from\", r.newNativeFunc(r.typedArray_from, \"from\", 1), true, false, true)\n\to._putProp(\"of\", r.newNativeFunc(r.typedArray_of, \"of\", 0), true, false, true)\n\tr.putSpeciesReturnThis(o)\n\n\treturn o\n}\n\nfunc (r *Runtime) getTypedArray() *Object {\n\tret := r.global.TypedArray\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.TypedArray = ret\n\t\tr.createTypedArray(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) createTypedArrayCtor(val *Object, ctor func(args []Value, newTarget, proto *Object) *Object, name unistring.String, bytesPerElement int) {\n\tp := r.newBaseObject(r.getTypedArrayPrototype(), classObject)\n\to := r.newNativeConstructOnly(val, func(args []Value, newTarget *Object) *Object {\n\t\treturn ctor(args, newTarget, p.val)\n\t}, p.val, name, 3)\n\n\tp._putProp(\"constructor\", o.val, true, false, true)\n\n\to.prototype = r.getTypedArray()\n\tbpe := intToValue(int64(bytesPerElement))\n\to._putProp(\"BYTES_PER_ELEMENT\", bpe, false, false, false)\n\tp._putProp(\"BYTES_PER_ELEMENT\", bpe, false, false, false)\n}\n\nfunc addTypedArrays(t *objectTemplate) {\n\tt.putStr(\"ArrayBuffer\", func(r *Runtime) Value { return valueProp(r.getArrayBuffer(), true, false, true) })\n\tt.putStr(\"DataView\", func(r *Runtime) Value { return valueProp(r.getDataView(), true, false, true) })\n\tt.putStr(\"Uint8Array\", func(r *Runtime) Value { return valueProp(r.getUint8Array(), true, false, true) })\n\tt.putStr(\"Uint8ClampedArray\", func(r *Runtime) Value { return valueProp(r.getUint8ClampedArray(), true, false, true) })\n\tt.putStr(\"Int8Array\", func(r *Runtime) Value { return valueProp(r.getInt8Array(), true, false, true) })\n\tt.putStr(\"Uint16Array\", func(r *Runtime) Value { return valueProp(r.getUint16Array(), true, false, true) })\n\tt.putStr(\"Int16Array\", func(r *Runtime) Value { return valueProp(r.getInt16Array(), true, false, true) })\n\tt.putStr(\"Uint32Array\", func(r *Runtime) Value { return valueProp(r.getUint32Array(), true, false, true) })\n\tt.putStr(\"Int32Array\", func(r *Runtime) Value { return valueProp(r.getInt32Array(), true, false, true) })\n\tt.putStr(\"Float32Array\", func(r *Runtime) Value { return valueProp(r.getFloat32Array(), true, false, true) })\n\tt.putStr(\"Float64Array\", func(r *Runtime) Value { return valueProp(r.getFloat64Array(), true, false, true) })\n\tt.putStr(\"BigInt64Array\", func(r *Runtime) Value { return valueProp(r.getBigInt64Array(), true, false, true) })\n\tt.putStr(\"BigUint64Array\", func(r *Runtime) Value { return valueProp(r.getBigUint64Array(), true, false, true) })\n}\n\nfunc createTypedArrayProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"buffer\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.typedArrayProto_getBuffer, \"get buffer\", 0),\n\t\t}\n\t})\n\n\tt.putStr(\"byteLength\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.typedArrayProto_getByteLen, \"get byteLength\", 0),\n\t\t}\n\t})\n\n\tt.putStr(\"byteOffset\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.typedArrayProto_getByteOffset, \"get byteOffset\", 0),\n\t\t}\n\t})\n\n\tt.putStr(\"at\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_at, \"at\", 1) })\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getTypedArray(), true, false, true) })\n\tt.putStr(\"copyWithin\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_copyWithin, \"copyWithin\", 2) })\n\tt.putStr(\"entries\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_entries, \"entries\", 0) })\n\tt.putStr(\"every\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_every, \"every\", 1) })\n\tt.putStr(\"fill\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_fill, \"fill\", 1) })\n\tt.putStr(\"filter\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_filter, \"filter\", 1) })\n\tt.putStr(\"find\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_find, \"find\", 1) })\n\tt.putStr(\"findIndex\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_findIndex, \"findIndex\", 1) })\n\tt.putStr(\"findLast\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_findLast, \"findLast\", 1) })\n\tt.putStr(\"findLastIndex\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_findLastIndex, \"findLastIndex\", 1) })\n\tt.putStr(\"forEach\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_forEach, \"forEach\", 1) })\n\tt.putStr(\"includes\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_includes, \"includes\", 1) })\n\tt.putStr(\"indexOf\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_indexOf, \"indexOf\", 1) })\n\tt.putStr(\"join\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_join, \"join\", 1) })\n\tt.putStr(\"keys\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_keys, \"keys\", 0) })\n\tt.putStr(\"lastIndexOf\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_lastIndexOf, \"lastIndexOf\", 1) })\n\tt.putStr(\"length\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.typedArrayProto_getLength, \"get length\", 0),\n\t\t}\n\t})\n\tt.putStr(\"map\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_map, \"map\", 1) })\n\tt.putStr(\"reduce\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_reduce, \"reduce\", 1) })\n\tt.putStr(\"reduceRight\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_reduceRight, \"reduceRight\", 1) })\n\tt.putStr(\"reverse\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_reverse, \"reverse\", 0) })\n\tt.putStr(\"set\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_set, \"set\", 1) })\n\tt.putStr(\"slice\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_slice, \"slice\", 2) })\n\tt.putStr(\"some\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_some, \"some\", 1) })\n\tt.putStr(\"sort\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_sort, \"sort\", 1) })\n\tt.putStr(\"subarray\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_subarray, \"subarray\", 2) })\n\tt.putStr(\"toLocaleString\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_toLocaleString, \"toLocaleString\", 0) })\n\tt.putStr(\"with\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_with, \"with\", 2) })\n\tt.putStr(\"toReversed\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_toReversed, \"toReversed\", 0) })\n\tt.putStr(\"toSorted\", func(r *Runtime) Value { return r.methodProp(r.typedArrayProto_toSorted, \"toSorted\", 1) })\n\tt.putStr(\"toString\", func(r *Runtime) Value { return valueProp(r.getArrayToString(), true, false, true) })\n\tt.putStr(\"values\", func(r *Runtime) Value { return valueProp(r.getTypedArrayValues(), true, false, true) })\n\n\tt.putSym(SymIterator, func(r *Runtime) Value { return valueProp(r.getTypedArrayValues(), true, false, true) })\n\tt.putSym(SymToStringTag, func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\tgetterFunc:   r.newNativeFunc(r.typedArrayProto_toStringTag, \"get [Symbol.toStringTag]\", 0),\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t}\n\t})\n\n\treturn t\n}\n\nfunc (r *Runtime) getTypedArrayValues() *Object {\n\tret := r.global.typedArrayValues\n\tif ret == nil {\n\t\tret = r.newNativeFunc(r.typedArrayProto_values, \"values\", 0)\n\t\tr.global.typedArrayValues = ret\n\t}\n\treturn ret\n}\n\nvar typedArrayProtoTemplate *objectTemplate\nvar typedArrayProtoTemplateOnce sync.Once\n\nfunc getTypedArrayProtoTemplate() *objectTemplate {\n\ttypedArrayProtoTemplateOnce.Do(func() {\n\t\ttypedArrayProtoTemplate = createTypedArrayProtoTemplate()\n\t})\n\treturn typedArrayProtoTemplate\n}\n\nfunc (r *Runtime) getTypedArrayPrototype() *Object {\n\tret := r.global.TypedArrayPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.TypedArrayPrototype = ret\n\t\tr.newTemplatedObject(getTypedArrayProtoTemplate(), ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getUint8Array() *Object {\n\tret := r.global.Uint8Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Uint8Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newUint8Array, \"Uint8Array\", 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getUint8ClampedArray() *Object {\n\tret := r.global.Uint8ClampedArray\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Uint8ClampedArray = ret\n\t\tr.createTypedArrayCtor(ret, r.newUint8ClampedArray, \"Uint8ClampedArray\", 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getInt8Array() *Object {\n\tret := r.global.Int8Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Int8Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newInt8Array, \"Int8Array\", 1)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getUint16Array() *Object {\n\tret := r.global.Uint16Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Uint16Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newUint16Array, \"Uint16Array\", 2)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getInt16Array() *Object {\n\tret := r.global.Int16Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Int16Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newInt16Array, \"Int16Array\", 2)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getUint32Array() *Object {\n\tret := r.global.Uint32Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Uint32Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newUint32Array, \"Uint32Array\", 4)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getInt32Array() *Object {\n\tret := r.global.Int32Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Int32Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newInt32Array, \"Int32Array\", 4)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getFloat32Array() *Object {\n\tret := r.global.Float32Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Float32Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newFloat32Array, \"Float32Array\", 4)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getFloat64Array() *Object {\n\tret := r.global.Float64Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.Float64Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newFloat64Array, \"Float64Array\", 8)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getBigInt64Array() *Object {\n\tret := r.global.BigInt64Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.BigInt64Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newBigInt64Array, \"BigInt64Array\", 8)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getBigUint64Array() *Object {\n\tret := r.global.BigUint64Array\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.BigUint64Array = ret\n\t\tr.createTypedArrayCtor(ret, r.newBigUint64Array, \"BigUint64Array\", 8)\n\t}\n\treturn ret\n}\n\nfunc createDataViewProtoTemplate() *objectTemplate {\n\tt := newObjectTemplate()\n\tt.protoFactory = func(r *Runtime) *Object {\n\t\treturn r.global.ObjectPrototype\n\t}\n\n\tt.putStr(\"buffer\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.dataViewProto_getBuffer, \"get buffer\", 0),\n\t\t}\n\t})\n\tt.putStr(\"byteLength\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.dataViewProto_getByteLen, \"get byteLength\", 0),\n\t\t}\n\t})\n\tt.putStr(\"byteOffset\", func(r *Runtime) Value {\n\t\treturn &valueProperty{\n\t\t\taccessor:     true,\n\t\t\tconfigurable: true,\n\t\t\tgetterFunc:   r.newNativeFunc(r.dataViewProto_getByteOffset, \"get byteOffset\", 0),\n\t\t}\n\t})\n\n\tt.putStr(\"constructor\", func(r *Runtime) Value { return valueProp(r.getDataView(), true, false, true) })\n\n\tt.putStr(\"getFloat32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getFloat32, \"getFloat32\", 1) })\n\tt.putStr(\"getFloat64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getFloat64, \"getFloat64\", 1) })\n\tt.putStr(\"getInt8\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getInt8, \"getInt8\", 1) })\n\tt.putStr(\"getInt16\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getInt16, \"getInt16\", 1) })\n\tt.putStr(\"getInt32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getInt32, \"getInt32\", 1) })\n\tt.putStr(\"getUint8\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getUint8, \"getUint8\", 1) })\n\tt.putStr(\"getUint16\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getUint16, \"getUint16\", 1) })\n\tt.putStr(\"getUint32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getUint32, \"getUint32\", 1) })\n\tt.putStr(\"getBigInt64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getBigInt64, \"getBigInt64\", 1) })\n\tt.putStr(\"getBigUint64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_getBigUint64, \"getBigUint64\", 1) })\n\tt.putStr(\"setFloat32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setFloat32, \"setFloat32\", 2) })\n\tt.putStr(\"setFloat64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setFloat64, \"setFloat64\", 2) })\n\tt.putStr(\"setInt8\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setInt8, \"setInt8\", 2) })\n\tt.putStr(\"setInt16\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setInt16, \"setInt16\", 2) })\n\tt.putStr(\"setInt32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setInt32, \"setInt32\", 2) })\n\tt.putStr(\"setUint8\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setUint8, \"setUint8\", 2) })\n\tt.putStr(\"setUint16\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setUint16, \"setUint16\", 2) })\n\tt.putStr(\"setUint32\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setUint32, \"setUint32\", 2) })\n\tt.putStr(\"setBigInt64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setBigInt64, \"setBigInt64\", 2) })\n\tt.putStr(\"setBigUint64\", func(r *Runtime) Value { return r.methodProp(r.dataViewProto_setBigUint64, \"setBigUint64\", 2) })\n\n\tt.putSym(SymToStringTag, func(r *Runtime) Value { return valueProp(asciiString(\"DataView\"), false, false, true) })\n\n\treturn t\n}\n\nvar dataViewProtoTemplate *objectTemplate\nvar dataViewProtoTemplateOnce sync.Once\n\nfunc getDataViewProtoTemplate() *objectTemplate {\n\tdataViewProtoTemplateOnce.Do(func() {\n\t\tdataViewProtoTemplate = createDataViewProtoTemplate()\n\t})\n\treturn dataViewProtoTemplate\n}\n\nfunc (r *Runtime) getDataViewPrototype() *Object {\n\tret := r.global.DataViewPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.DataViewPrototype = ret\n\t\tr.newTemplatedObject(getDataViewProtoTemplate(), ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getDataView() *Object {\n\tret := r.global.DataView\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.DataView = ret\n\t\tret.self = r.createDataView(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getArrayBufferPrototype() *Object {\n\tret := r.global.ArrayBufferPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.ArrayBufferPrototype = ret\n\t\tret.self = r.createArrayBufferProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getArrayBuffer() *Object {\n\tret := r.global.ArrayBuffer\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.ArrayBuffer = ret\n\t\tret.self = r.createArrayBuffer(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_typedarrays_test.go",
          "type": "blob",
          "size": 7.1904296875,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\n/*\nfunc TestArrayBufferNew(t *testing.T) {\n\tconst SCRIPT = `\n\tvar b = new ArrayBuffer(16);\n\tb.byteLength;\n\t`\n\n\ttestScript(SCRIPT, intToValue(16), t)\n}\n*/\n\nfunc TestArrayBufferSetUint32(t *testing.T) {\n\tvm := New()\n\tb := vm._newArrayBuffer(vm.global.ArrayBufferPrototype, nil)\n\tb.data = make([]byte, 4)\n\tb.setUint32(0, 0xCAFEBABE, bigEndian)\n\n\ti := b.getUint32(0, bigEndian)\n\tif i != 0xCAFEBABE {\n\t\tt.Fatal(i)\n\t}\n\ti = b.getUint32(0, littleEndian)\n\tif i != 0xBEBAFECA {\n\t\tt.Fatal(i)\n\t}\n\n\tb.setUint32(0, 0xBEBAFECA, littleEndian)\n\ti = b.getUint32(0, bigEndian)\n\tif i != 0xCAFEBABE {\n\t\tt.Fatal(i)\n\t}\n}\n\nfunc TestArrayBufferSetInt32(t *testing.T) {\n\tvm := New()\n\tb := vm._newArrayBuffer(vm.global.ArrayBufferPrototype, nil)\n\tb.data = make([]byte, 4)\n\tb.setInt32(0, -42, littleEndian)\n\tif v := b.getInt32(0, littleEndian); v != -42 {\n\t\tt.Fatal(v)\n\t}\n\n\tb.setInt32(0, -42, bigEndian)\n\tif v := b.getInt32(0, bigEndian); v != -42 {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestNewUint8Array(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = new Uint8Array(1);\n\ta[0] = 42;\n\ta.byteLength === 1 && a.length === 1 && a[0] === 42;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestNewUint16Array(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = new Uint16Array(1);\n\ta[0] = 42;\n\ta.byteLength === 2 && a.length === 1 && a[0] === 42;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTypedArraysSpeciesConstructor(t *testing.T) {\n\tconst SCRIPT = `\n    'use strict';\n    function MyArray() {\n        var NewTarget = this.__proto__.constructor;\n        return Reflect.construct(Uint16Array, arguments, NewTarget);\n    }\n    MyArray.prototype = Object.create(Uint16Array.prototype, {\n        constructor: {\n            value: MyArray,\n            writable: true,\n            configurable: true\n        }\n    });\n    var a = new MyArray(1);\n    Object.defineProperty(MyArray, Symbol.species, {value: Uint8Array, configurable: true});\n    a[0] = 32767;\n    var b = a.filter(function() {\n        return true;\n    });\n\tif (a[0] !== 32767) {\n\t\tthrow new Error(\"a[0]=\" + a[0]); \n\t}\n\tif (!(b instanceof Uint8Array)) {\n\t\tthrow new Error(\"b instanceof Uint8Array\");\n\t}\n\tif (b[0] != 255) {\n\t\tthrow new Error(\"b[0]=\" + b[0]);\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArrayFromArrayBuffer(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(2);\n\tvar a16 = new Uint16Array(buf);\n\tif (!(a16 instanceof Uint16Array)) {\n\t\tthrow new Error(\"a16 is not an instance\");\n\t}\n\tif (a16.buffer !== buf) {\n\t\tthrow new Error(\"a16.buffer !== buf\");\n\t}\n\tif (a16.length !== 1) {\n\t\tthrow new Error(\"a16.length=\" + a16.length);\n\t}\n\tvar a8 = new Uint8Array(buf);\n\ta8.fill(0xAA);\n\tif (a16[0] !== 0xAAAA) {\n\t\tthrow new Error(\"a16[0]=\" + a16[0]);\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetOverlapDifSize(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(4);\n\tvar src = new Uint8Array(buf, 1, 2);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tvar dst = new Uint16Array(buf);\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetOverlapDifSize2(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(4);\n\tvar src = new Uint8Array(buf, 0, 2);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tvar dst = new Uint16Array(buf);\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetOverlapDifSize3(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(8);\n\tvar src = new Uint8Array(buf, 2, 4);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tsrc[2] = 3;\n\tsrc[3] = 4;\n\tvar dst = new Uint16Array(buf);\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2 || dst[2] !== 3 || dst[3] !== 4) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetOverlapDifSize4(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(10);\n\tvar dst = new Uint8Array(buf, 2, 5);\n\tvar src = new Uint16Array(buf);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tsrc[2] = 3;\n\tsrc[3] = 4;\n\tsrc[4] = 5;\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2 || dst[2] !== 3 || dst[3] !== 4 || dst[4] !== 5) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetNoOverlapDifSizeForward(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(10);\n\tvar dst = new Uint8Array(buf, 7, 2);\n\tvar src = new Uint16Array(buf, 0, 2);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2 || src[0] !== 1 || src[1] !== 2) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetNoOverlapDifSizeBackward(t *testing.T) {\n\tconst SCRIPT = `\n\tvar buf = new ArrayBuffer(10);\n\tvar dst = new Uint8Array(buf, 0, 2);\n\tvar src = new Uint16Array(buf, 6, 2);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2 || src[0] !== 1 || src[1] !== 2) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetNoOverlapDifSizeDifBuffers(t *testing.T) {\n\tconst SCRIPT = `\n\tvar dstBuf = new ArrayBuffer(1024);\n\tvar dst = new Uint8Array(dstBuf, 0, 2);\n\tvar src = new Uint16Array(2);\n\tsrc[0] = 1;\n\tsrc[1] = 2;\n\tdst.set(src);\n\tif (dst[0] !== 1 || dst[1] !== 2 || src[0] !== 1 || src[1] !== 2) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySliceSameType(t *testing.T) {\n\tconst SCRIPT = `\n\tvar src = Uint8Array.of(1,2,3,4);\n\tvar dst = src.slice(1, 3);\n\tif (dst.length !== 2 || dst[0] !== 2 || dst[1] !== 3) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySliceDifType(t *testing.T) {\n\tconst SCRIPT = `\n\tvar src = Uint8Array.of(1,2,3,4);\n\tObject.defineProperty(Uint8Array, Symbol.species, {value: Uint16Array, configurable: true});\n\tvar dst = src.slice(1, 3);\n\tif (!(dst instanceof Uint16Array)) {\n\t\tthrow new Error(\"wrong dst type: \" + dst);\n\t}\n\tif (dst.length !== 2 || dst[0] !== 2 || dst[1] !== 3) {\n\t\tthrow new Error(\"dst: \" + dst.join(\",\"));\n\t}\t\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySortComparatorReturnValueFloats(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = Float64Array.of(\n\t\t5.97,\n\t\t9.91,\n\t\t4.13,\n\t\t9.28,\n\t\t3.29\n\t);\n\ta.sort( function(a, b) { return a - b; } );\n\tfor (var i = 1; i < a.length; i++) {\n\t\tif (a[i] < a[i-1]) {\n\t\t\tthrow new Error(\"Array is not sorted: \" + a);\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySortComparatorReturnValueNegZero(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = new Uint8Array([2, 1]);\n\ta.sort( function(a, b) { return a > b ? 0 : -0; } );\n\tfor (var i = 1; i < a.length; i++) {\n\t\tif (a[i] < a[i-1]) {\n\t\t\tthrow new Error(\"Array is not sorted: \" + a);\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestInt32ArrayNegativeIndex(t *testing.T) {\n\tconst SCRIPT = `\n\tnew Int32Array()[-1] === undefined;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTypedArrayDeleteUnconfigurable(t *testing.T) {\n\tconst SCRIPT = `\n\ttry {\n\t\t(function() {\n\t\t\t'use strict';\n\t\t\tdelete Uint8Array.prototype.BYTES_PER_ELEMENT;\n\t\t})();\n\t} catch(e) {\n\t\tif (!(e instanceof TypeError)) {\n\t\t\tthrow e;\n\t\t}\n\t\tif (!e.message.startsWith(\"Cannot delete property\")) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "builtin_weakmap.go",
          "type": "blob",
          "size": 4.6875,
          "content": "package goja\n\ntype weakMap uint64\n\ntype weakMapObject struct {\n\tbaseObject\n\tm weakMap\n}\n\nfunc (wmo *weakMapObject) init() {\n\twmo.baseObject.init()\n\twmo.m = weakMap(wmo.val.runtime.genId())\n}\n\nfunc (wm weakMap) set(key *Object, value Value) {\n\tkey.getWeakRefs()[wm] = value\n}\n\nfunc (wm weakMap) get(key *Object) Value {\n\treturn key.weakRefs[wm]\n}\n\nfunc (wm weakMap) remove(key *Object) bool {\n\tif _, exists := key.weakRefs[wm]; exists {\n\t\tdelete(key.weakRefs, wm)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wm weakMap) has(key *Object) bool {\n\t_, exists := key.weakRefs[wm]\n\treturn exists\n}\n\nfunc (r *Runtime) weakMapProto_delete(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twmo, ok := thisObj.self.(*weakMapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakMap.prototype.delete called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tkey, ok := call.Argument(0).(*Object)\n\tif ok && wmo.m.remove(key) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) weakMapProto_get(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twmo, ok := thisObj.self.(*weakMapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakMap.prototype.get called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tvar res Value\n\tif key, ok := call.Argument(0).(*Object); ok {\n\t\tres = wmo.m.get(key)\n\t}\n\tif res == nil {\n\t\treturn _undefined\n\t}\n\treturn res\n}\n\nfunc (r *Runtime) weakMapProto_has(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twmo, ok := thisObj.self.(*weakMapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakMap.prototype.has called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tkey, ok := call.Argument(0).(*Object)\n\tif ok && wmo.m.has(key) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) weakMapProto_set(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twmo, ok := thisObj.self.(*weakMapObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakMap.prototype.set called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tkey := r.toObject(call.Argument(0))\n\twmo.m.set(key, call.Argument(1))\n\treturn call.This\n}\n\nfunc (r *Runtime) needNew(name string) *Object {\n\treturn r.NewTypeError(\"Constructor %s requires 'new'\", name)\n}\n\nfunc (r *Runtime) builtin_newWeakMap(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"WeakMap\"))\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, r.global.WeakMap, r.global.WeakMapPrototype)\n\to := &Object{runtime: r}\n\n\twmo := &weakMapObject{}\n\twmo.class = classObject\n\twmo.val = o\n\twmo.extensible = true\n\to.self = wmo\n\twmo.prototype = proto\n\twmo.init()\n\tif len(args) > 0 {\n\t\tif arg := args[0]; arg != nil && arg != _undefined && arg != _null {\n\t\t\tadder := wmo.getStr(\"set\", nil)\n\t\t\tadderFn := toMethod(adder)\n\t\t\tif adderFn == nil {\n\t\t\t\tpanic(r.NewTypeError(\"WeakMap.set in missing\"))\n\t\t\t}\n\t\t\titer := r.getIterator(arg, nil)\n\t\t\ti0 := valueInt(0)\n\t\t\ti1 := valueInt(1)\n\t\t\tif adder == r.global.weakMapAdder {\n\t\t\t\titer.iterate(func(item Value) {\n\t\t\t\t\titemObj := r.toObject(item)\n\t\t\t\t\tk := itemObj.self.getIdx(i0, nil)\n\t\t\t\t\tv := nilSafe(itemObj.self.getIdx(i1, nil))\n\t\t\t\t\twmo.m.set(r.toObject(k), v)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\titer.iterate(func(item Value) {\n\t\t\t\t\titemObj := r.toObject(item)\n\t\t\t\t\tk := itemObj.self.getIdx(i0, nil)\n\t\t\t\t\tv := itemObj.self.getIdx(i1, nil)\n\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{k, v}})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createWeakMapProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putProp(\"constructor\", r.getWeakMap(), true, false, true)\n\tr.global.weakMapAdder = r.newNativeFunc(r.weakMapProto_set, \"set\", 2)\n\to._putProp(\"set\", r.global.weakMapAdder, true, false, true)\n\to._putProp(\"delete\", r.newNativeFunc(r.weakMapProto_delete, \"delete\", 1), true, false, true)\n\to._putProp(\"has\", r.newNativeFunc(r.weakMapProto_has, \"has\", 1), true, false, true)\n\to._putProp(\"get\", r.newNativeFunc(r.weakMapProto_get, \"get\", 1), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(classWeakMap), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createWeakMap(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newWeakMap, r.getWeakMapPrototype(), \"WeakMap\", 0)\n\n\treturn o\n}\n\nfunc (r *Runtime) getWeakMapPrototype() *Object {\n\tret := r.global.WeakMapPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.WeakMapPrototype = ret\n\t\tret.self = r.createWeakMapProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getWeakMap() *Object {\n\tret := r.global.WeakMap\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.WeakMap = ret\n\t\tret.self = r.createWeakMap(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_weakmap_test.go",
          "type": "blob",
          "size": 1.26953125,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWeakMap(t *testing.T) {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tvar m = new WeakMap();\n\tvar m1 = new WeakMap();\n\tvar key = {};\n\tm.set(key, true);\n\tm1.set(key, false);\n\tif (!m.has(key)) {\n\t\tthrow new Error(\"has\");\n\t}\n\tif (m.get(key) !== true) {\n\t\tthrow new Error(\"value does not match\");\n\t}\n\tif (!m1.has(key)) {\n\t\tthrow new Error(\"has (m1)\");\n\t}\n\tif (m1.get(key) !== false) {\n\t\tthrow new Error(\"m1 value does not match\");\n\t}\n\tm.delete(key);\n\tif (m.has(key)) {\n\t\tthrow new Error(\"m still has after delete\");\n\t}\n\tif (!m1.has(key)) {\n\t\tthrow new Error(\"m1 does not have after delete from m\");\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestWeakMapGetAdderGetIteratorOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet getterCalled = 0;\n\n\tclass M extends WeakMap {\n\t    get set() {\n\t        getterCalled++;\n\t        return null;\n\t    }\n\t}\n\n\tlet getIteratorCalled = 0;\n\n\tlet iterable = {};\n\titerable[Symbol.iterator] = () => {\n\t    getIteratorCalled++\n\t    return {\n\t        next: 1\n\t    };\n\t}\n\n\tlet thrown = false;\n\n\ttry {\n\t    new M(iterable);\n\t} catch (e) {\n\t    if (e instanceof TypeError) {\n\t        thrown = true;\n\t    } else {\n\t        throw e;\n\t    }\n\t}\n\n\tthrown && getterCalled === 1 && getIteratorCalled === 0;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n"
        },
        {
          "name": "builtin_weakset.go",
          "type": "blob",
          "size": 3.6904296875,
          "content": "package goja\n\ntype weakSetObject struct {\n\tbaseObject\n\ts weakMap\n}\n\nfunc (ws *weakSetObject) init() {\n\tws.baseObject.init()\n\tws.s = weakMap(ws.val.runtime.genId())\n}\n\nfunc (r *Runtime) weakSetProto_add(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twso, ok := thisObj.self.(*weakSetObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakSet.prototype.add called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\twso.s.set(r.toObject(call.Argument(0)), nil)\n\treturn call.This\n}\n\nfunc (r *Runtime) weakSetProto_delete(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twso, ok := thisObj.self.(*weakSetObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakSet.prototype.delete called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tobj, ok := call.Argument(0).(*Object)\n\tif ok && wso.s.remove(obj) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) weakSetProto_has(call FunctionCall) Value {\n\tthisObj := r.toObject(call.This)\n\twso, ok := thisObj.self.(*weakSetObject)\n\tif !ok {\n\t\tpanic(r.NewTypeError(\"Method WeakSet.prototype.has called on incompatible receiver %s\", r.objectproto_toString(FunctionCall{This: thisObj})))\n\t}\n\tobj, ok := call.Argument(0).(*Object)\n\tif ok && wso.s.has(obj) {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n}\n\nfunc (r *Runtime) builtin_newWeakSet(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tpanic(r.needNew(\"WeakSet\"))\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, r.global.WeakSet, r.global.WeakSetPrototype)\n\to := &Object{runtime: r}\n\n\twso := &weakSetObject{}\n\twso.class = classObject\n\twso.val = o\n\twso.extensible = true\n\to.self = wso\n\twso.prototype = proto\n\twso.init()\n\tif len(args) > 0 {\n\t\tif arg := args[0]; arg != nil && arg != _undefined && arg != _null {\n\t\t\tadder := wso.getStr(\"add\", nil)\n\t\t\tstdArr := r.checkStdArrayIter(arg)\n\t\t\tif adder == r.global.weakSetAdder {\n\t\t\t\tif stdArr != nil {\n\t\t\t\t\tfor _, v := range stdArr.values {\n\t\t\t\t\t\twso.s.set(r.toObject(v), nil)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr.getIterator(arg, nil).iterate(func(item Value) {\n\t\t\t\t\t\twso.s.set(r.toObject(item), nil)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadderFn := toMethod(adder)\n\t\t\t\tif adderFn == nil {\n\t\t\t\t\tpanic(r.NewTypeError(\"WeakSet.add in missing\"))\n\t\t\t\t}\n\t\t\t\tif stdArr != nil {\n\t\t\t\t\tfor _, item := range stdArr.values {\n\t\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{item}})\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr.getIterator(arg, nil).iterate(func(item Value) {\n\t\t\t\t\t\tadderFn(FunctionCall{This: o, Arguments: []Value{item}})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) createWeakSetProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putProp(\"constructor\", r.global.WeakSet, true, false, true)\n\tr.global.weakSetAdder = r.newNativeFunc(r.weakSetProto_add, \"add\", 1)\n\to._putProp(\"add\", r.global.weakSetAdder, true, false, true)\n\to._putProp(\"delete\", r.newNativeFunc(r.weakSetProto_delete, \"delete\", 1), true, false, true)\n\to._putProp(\"has\", r.newNativeFunc(r.weakSetProto_has, \"has\", 1), true, false, true)\n\n\to._putSym(SymToStringTag, valueProp(asciiString(classWeakSet), false, false, true))\n\n\treturn o\n}\n\nfunc (r *Runtime) createWeakSet(val *Object) objectImpl {\n\to := r.newNativeConstructOnly(val, r.builtin_newWeakSet, r.getWeakSetPrototype(), \"WeakSet\", 0)\n\n\treturn o\n}\n\nfunc (r *Runtime) getWeakSetPrototype() *Object {\n\tret := r.global.WeakSetPrototype\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.WeakSetPrototype = ret\n\t\tret.self = r.createWeakSetProto(ret)\n\t}\n\treturn ret\n}\n\nfunc (r *Runtime) getWeakSet() *Object {\n\tret := r.global.WeakSet\n\tif ret == nil {\n\t\tret = &Object{runtime: r}\n\t\tr.global.WeakSet = ret\n\t\tret.self = r.createWeakSet(ret)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "builtin_weakset_test.go",
          "type": "blob",
          "size": 1.791015625,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWeakSetBasic(t *testing.T) {\n\tconst SCRIPT = `\n\tvar s = new WeakSet();\n\tvar o = {};\n\ts.add(o);\n\tif (!s.has(o)) {\n\t\tthrow new Error(\"has\");\n\t}\n\ts.delete(o);\n\tif (s.has(o)) {\n\t\tthrow new Error(\"still has\");\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestWeakSetArraySimple(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o1 = {}, o2 = {}, o3 = {};\n\t\n\tvar s = new WeakSet([o1, o2, o3]);\n\ts.has(o1) && s.has(o2) && s.has(o3);\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestWeakSetArrayGeneric(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o1 = {}, o2 = {}, o3 = {};\n\tvar a = new Array();\n\tvar s;\n\tvar thrown = false;\n\ta[1] = o2;\n\t\n\ttry {\n\t\ts = new WeakSet(a);\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tthrown = true;\n\t\t}\n\t}\n\tif (!thrown) {\n\t\tthrow new Error(\"Case 1 does not throw\");\n\t}\n \n\tObject.defineProperty(a.__proto__, \"0\", {value: o1, writable: true, enumerable: true, configurable: true});\n\ts = new WeakSet(a);\n\tif (!(s.has(o1) && s.has(o2) && !s.has(o3))) {\n\t\tthrow new Error(\"Case 2 failed\");\n\t}\n\n\tObject.defineProperty(a, \"2\", {value: o3, configurable: true});\t\n\ts = new WeakSet(a);\n\ts.has(o1) && s.has(o2) && s.has(o3);\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestWeakSetGetAdderGetIteratorOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet getterCalled = 0;\n\n\tclass S extends WeakSet {\n\t    get add() {\n\t        getterCalled++;\n\t        return null;\n\t    }\n\t}\n\n\tlet getIteratorCalled = 0;\n\n\tlet iterable = {};\n\titerable[Symbol.iterator] = () => {\n\t    getIteratorCalled++\n\t    return {\n\t        next: 1\n\t    };\n\t}\n\n\tlet thrown = false;\n\n\ttry {\n\t    new S(iterable);\n\t} catch (e) {\n\t    if (e instanceof TypeError) {\n\t        thrown = true;\n\t    } else {\n\t        throw e;\n\t    }\n\t}\n\n\tthrown && getterCalled === 1 && getIteratorCalled === 0;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n"
        },
        {
          "name": "compiler.go",
          "type": "blob",
          "size": 35.255859375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"github.com/dop251/goja/token\"\n\t\"sort\"\n\n\t\"github.com/dop251/goja/ast\"\n\t\"github.com/dop251/goja/file\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype blockType int\n\nconst (\n\tblockLoop blockType = iota\n\tblockLoopEnum\n\tblockTry\n\tblockLabel\n\tblockSwitch\n\tblockWith\n\tblockScope\n\tblockIterScope\n\tblockOptChain\n)\n\nconst (\n\tmaskConst     = 1 << 31\n\tmaskVar       = 1 << 30\n\tmaskDeletable = 1 << 29\n\tmaskStrict    = maskDeletable\n\n\tmaskTyp = maskConst | maskVar | maskDeletable\n)\n\ntype varType byte\n\nconst (\n\tvarTypeVar varType = iota\n\tvarTypeLet\n\tvarTypeStrictConst\n\tvarTypeConst\n)\n\nconst thisBindingName = \" this\" // must not be a valid identifier\n\ntype CompilerError struct {\n\tMessage string\n\tFile    *file.File\n\tOffset  int\n}\n\ntype CompilerSyntaxError struct {\n\tCompilerError\n}\n\ntype CompilerReferenceError struct {\n\tCompilerError\n}\n\ntype srcMapItem struct {\n\tpc     int\n\tsrcPos int\n}\n\n// Program is an internal, compiled representation of code which is produced by the Compile function.\n// This representation is not linked to a runtime in any way and can be used concurrently.\n// It is always preferable to use a Program over a string when running code as it skips the compilation step.\ntype Program struct {\n\tcode []instruction\n\n\tfuncName unistring.String\n\tsrc      *file.File\n\tsrcMap   []srcMapItem\n}\n\ntype compiler struct {\n\tp     *Program\n\tscope *scope\n\tblock *block\n\n\tclassScope *classScope\n\n\tenumGetExpr compiledEnumGetExpr\n\n\tevalVM *vm // VM used to evaluate constant expressions\n\tctxVM  *vm // VM in which an eval() code is compiled\n\n\tcodeScratchpad []instruction\n\n\tstringCache map[unistring.String]Value\n}\n\ntype binding struct {\n\tscope        *scope\n\tname         unistring.String\n\taccessPoints map[*scope]*[]int\n\tisConst      bool\n\tisStrict     bool\n\tisArg        bool\n\tisVar        bool\n\tinStash      bool\n}\n\nfunc (b *binding) getAccessPointsForScope(s *scope) *[]int {\n\tm := b.accessPoints[s]\n\tif m == nil {\n\t\ta := make([]int, 0, 1)\n\t\tm = &a\n\t\tif b.accessPoints == nil {\n\t\t\tb.accessPoints = make(map[*scope]*[]int)\n\t\t}\n\t\tb.accessPoints[s] = m\n\t}\n\treturn m\n}\n\nfunc (b *binding) markAccessPointAt(pos int) {\n\tscope := b.scope.c.scope\n\tm := b.getAccessPointsForScope(scope)\n\t*m = append(*m, pos-scope.base)\n}\n\nfunc (b *binding) markAccessPointAtScope(scope *scope, pos int) {\n\tm := b.getAccessPointsForScope(scope)\n\t*m = append(*m, pos-scope.base)\n}\n\nfunc (b *binding) markAccessPoint() {\n\tscope := b.scope.c.scope\n\tm := b.getAccessPointsForScope(scope)\n\t*m = append(*m, len(scope.prg.code)-scope.base)\n}\n\nfunc (b *binding) emitGet() {\n\tb.markAccessPoint()\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.emit(loadStack(0))\n\t} else {\n\t\tb.scope.c.emit(loadStackLex(0))\n\t}\n}\n\nfunc (b *binding) emitGetAt(pos int) {\n\tb.markAccessPointAt(pos)\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.p.code[pos] = loadStack(0)\n\t} else {\n\t\tb.scope.c.p.code[pos] = loadStackLex(0)\n\t}\n}\n\nfunc (b *binding) emitGetP() {\n\tif b.isVar && !b.isArg {\n\t\t// no-op\n\t} else {\n\t\t// make sure TDZ is checked\n\t\tb.markAccessPoint()\n\t\tb.scope.c.emit(loadStackLex(0), pop)\n\t}\n}\n\nfunc (b *binding) emitSet() {\n\tif b.isConst {\n\t\tif b.isStrict || b.scope.c.scope.strict {\n\t\t\tb.scope.c.emit(throwAssignToConst)\n\t\t}\n\t\treturn\n\t}\n\tb.markAccessPoint()\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.emit(storeStack(0))\n\t} else {\n\t\tb.scope.c.emit(storeStackLex(0))\n\t}\n}\n\nfunc (b *binding) emitSetP() {\n\tif b.isConst {\n\t\tif b.isStrict || b.scope.c.scope.strict {\n\t\t\tb.scope.c.emit(throwAssignToConst)\n\t\t}\n\t\treturn\n\t}\n\tb.markAccessPoint()\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.emit(storeStackP(0))\n\t} else {\n\t\tb.scope.c.emit(storeStackLexP(0))\n\t}\n}\n\nfunc (b *binding) emitInitP() {\n\tif !b.isVar && b.scope.outer == nil {\n\t\tb.scope.c.emit(initGlobalP(b.name))\n\t} else {\n\t\tb.markAccessPoint()\n\t\tb.scope.c.emit(initStackP(0))\n\t}\n}\n\nfunc (b *binding) emitInit() {\n\tif !b.isVar && b.scope.outer == nil {\n\t\tb.scope.c.emit(initGlobal(b.name))\n\t} else {\n\t\tb.markAccessPoint()\n\t\tb.scope.c.emit(initStack(0))\n\t}\n}\n\nfunc (b *binding) emitInitAt(pos int) {\n\tif !b.isVar && b.scope.outer == nil {\n\t\tb.scope.c.p.code[pos] = initGlobal(b.name)\n\t} else {\n\t\tb.markAccessPointAt(pos)\n\t\tb.scope.c.p.code[pos] = initStack(0)\n\t}\n}\n\nfunc (b *binding) emitInitAtScope(scope *scope, pos int) {\n\tif !b.isVar && scope.outer == nil {\n\t\tscope.c.p.code[pos] = initGlobal(b.name)\n\t} else {\n\t\tb.markAccessPointAtScope(scope, pos)\n\t\tscope.c.p.code[pos] = initStack(0)\n\t}\n}\n\nfunc (b *binding) emitInitPAtScope(scope *scope, pos int) {\n\tif !b.isVar && scope.outer == nil {\n\t\tscope.c.p.code[pos] = initGlobalP(b.name)\n\t} else {\n\t\tb.markAccessPointAtScope(scope, pos)\n\t\tscope.c.p.code[pos] = initStackP(0)\n\t}\n}\n\nfunc (b *binding) emitGetVar(callee bool) {\n\tb.markAccessPoint()\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.emit(&loadMixed{name: b.name, callee: callee})\n\t} else {\n\t\tb.scope.c.emit(&loadMixedLex{name: b.name, callee: callee})\n\t}\n}\n\nfunc (b *binding) emitResolveVar(strict bool) {\n\tb.markAccessPoint()\n\tif b.isVar && !b.isArg {\n\t\tb.scope.c.emit(&resolveMixed{name: b.name, strict: strict, typ: varTypeVar})\n\t} else {\n\t\tvar typ varType\n\t\tif b.isConst {\n\t\t\tif b.isStrict {\n\t\t\t\ttyp = varTypeStrictConst\n\t\t\t} else {\n\t\t\t\ttyp = varTypeConst\n\t\t\t}\n\t\t} else {\n\t\t\ttyp = varTypeLet\n\t\t}\n\t\tb.scope.c.emit(&resolveMixed{name: b.name, strict: strict, typ: typ})\n\t}\n}\n\nfunc (b *binding) moveToStash() {\n\tif b.isArg && !b.scope.argsInStash {\n\t\tb.scope.moveArgsToStash()\n\t} else {\n\t\tb.inStash = true\n\t\tb.scope.needStash = true\n\t}\n}\n\nfunc (b *binding) useCount() (count int) {\n\tfor _, a := range b.accessPoints {\n\t\tcount += len(*a)\n\t}\n\treturn\n}\n\ntype scope struct {\n\tc          *compiler\n\tprg        *Program\n\touter      *scope\n\tnested     []*scope\n\tboundNames map[unistring.String]*binding\n\tbindings   []*binding\n\tbase       int\n\tnumArgs    int\n\n\t// function type. If not funcNone, this is a function or a top-level lexical environment\n\tfuncType funcType\n\n\t// in strict mode\n\tstrict bool\n\t// eval top-level scope\n\teval bool\n\t// at least one inner scope has direct eval() which can lookup names dynamically (by name)\n\tdynLookup bool\n\t// at least one binding has been marked for placement in stash\n\tneedStash bool\n\n\t// is a variable environment, i.e. the target for dynamically created var bindings\n\tvariable bool\n\t// a function scope that has at least one direct eval() and non-strict, so the variables can be added dynamically\n\tdynamic bool\n\t// arguments have been marked for placement in stash (functions only)\n\targsInStash bool\n\t// need 'arguments' object (functions only)\n\targsNeeded bool\n}\n\ntype block struct {\n\ttyp        blockType\n\tlabel      unistring.String\n\tcont       int\n\tbreaks     []int\n\tconts      []int\n\touter      *block\n\tbreaking   *block // set when the 'finally' block is an empty break statement sequence\n\tneedResult bool\n}\n\nfunc (c *compiler) leaveScopeBlock(enter *enterBlock) {\n\tc.updateEnterBlock(enter)\n\tleave := &leaveBlock{\n\t\tstackSize: enter.stackSize,\n\t\tpopStash:  enter.stashSize > 0,\n\t}\n\tc.emit(leave)\n\tfor _, pc := range c.block.breaks {\n\t\tc.p.code[pc] = leave\n\t}\n\tc.block.breaks = nil\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) leaveBlock() {\n\tlbl := len(c.p.code)\n\tfor _, item := range c.block.breaks {\n\t\tc.p.code[item] = jump(lbl - item)\n\t}\n\tif t := c.block.typ; t == blockLoop || t == blockLoopEnum {\n\t\tfor _, item := range c.block.conts {\n\t\t\tc.p.code[item] = jump(c.block.cont - item)\n\t\t}\n\t}\n\tc.block = c.block.outer\n}\n\nfunc (e *CompilerSyntaxError) Error() string {\n\tif e.File != nil {\n\t\treturn fmt.Sprintf(\"SyntaxError: %s at %s\", e.Message, e.File.Position(e.Offset))\n\t}\n\treturn fmt.Sprintf(\"SyntaxError: %s\", e.Message)\n}\n\nfunc (e *CompilerReferenceError) Error() string {\n\treturn fmt.Sprintf(\"ReferenceError: %s\", e.Message)\n}\n\nfunc (c *compiler) newScope() {\n\tstrict := false\n\tif c.scope != nil {\n\t\tstrict = c.scope.strict\n\t}\n\tc.scope = &scope{\n\t\tc:      c,\n\t\tprg:    c.p,\n\t\touter:  c.scope,\n\t\tstrict: strict,\n\t}\n}\n\nfunc (c *compiler) newBlockScope() {\n\tc.newScope()\n\tif outer := c.scope.outer; outer != nil {\n\t\touter.nested = append(outer.nested, c.scope)\n\t}\n\tc.scope.base = len(c.p.code)\n}\n\nfunc (c *compiler) popScope() {\n\tc.scope = c.scope.outer\n}\n\nfunc (c *compiler) emitLiteralString(s String) {\n\tkey := s.string()\n\tif c.stringCache == nil {\n\t\tc.stringCache = make(map[unistring.String]Value)\n\t}\n\tinternVal := c.stringCache[key]\n\tif internVal == nil {\n\t\tc.stringCache[key] = s\n\t\tinternVal = s\n\t}\n\n\tc.emit(loadVal{internVal})\n}\n\nfunc (c *compiler) emitLiteralValue(v Value) {\n\tif s, ok := v.(String); ok {\n\t\tc.emitLiteralString(s)\n\t\treturn\n\t}\n\n\tc.emit(loadVal{v})\n}\n\nfunc newCompiler() *compiler {\n\tc := &compiler{\n\t\tp: &Program{},\n\t}\n\n\tc.enumGetExpr.init(c, file.Idx(0))\n\n\treturn c\n}\n\nfunc (p *Program) dumpCode(logger func(format string, args ...interface{})) {\n\tp._dumpCode(\"\", logger)\n}\n\nfunc (p *Program) _dumpCode(indent string, logger func(format string, args ...interface{})) {\n\tdumpInitFields := func(initFields *Program) {\n\t\ti := indent + \">\"\n\t\tlogger(\"%s ---- init_fields:\", i)\n\t\tinitFields._dumpCode(i, logger)\n\t\tlogger(\"%s ----\", i)\n\t}\n\tfor pc, ins := range p.code {\n\t\tlogger(\"%s %d: %T(%v)\", indent, pc, ins, ins)\n\t\tvar prg *Program\n\t\tswitch f := ins.(type) {\n\t\tcase newFuncInstruction:\n\t\t\tprg = f.getPrg()\n\t\tcase *newDerivedClass:\n\t\t\tif f.initFields != nil {\n\t\t\t\tdumpInitFields(f.initFields)\n\t\t\t}\n\t\t\tprg = f.ctor\n\t\tcase *newClass:\n\t\t\tif f.initFields != nil {\n\t\t\t\tdumpInitFields(f.initFields)\n\t\t\t}\n\t\t\tprg = f.ctor\n\t\tcase *newStaticFieldInit:\n\t\t\tif f.initFields != nil {\n\t\t\t\tdumpInitFields(f.initFields)\n\t\t\t}\n\t\t}\n\t\tif prg != nil {\n\t\t\tprg._dumpCode(indent+\">\", logger)\n\t\t}\n\t}\n}\n\nfunc (p *Program) sourceOffset(pc int) int {\n\ti := sort.Search(len(p.srcMap), func(idx int) bool {\n\t\treturn p.srcMap[idx].pc > pc\n\t}) - 1\n\tif i >= 0 {\n\t\treturn p.srcMap[i].srcPos\n\t}\n\n\treturn 0\n}\n\nfunc (p *Program) addSrcMap(srcPos int) {\n\tif len(p.srcMap) > 0 && p.srcMap[len(p.srcMap)-1].srcPos == srcPos {\n\t\treturn\n\t}\n\tp.srcMap = append(p.srcMap, srcMapItem{pc: len(p.code), srcPos: srcPos})\n}\n\nfunc (s *scope) lookupName(name unistring.String) (binding *binding, noDynamics bool) {\n\tnoDynamics = true\n\ttoStash := false\n\tfor curScope := s; ; curScope = curScope.outer {\n\t\tif curScope.outer != nil {\n\t\t\tif b, exists := curScope.boundNames[name]; exists {\n\t\t\t\tif toStash && !b.inStash {\n\t\t\t\t\tb.moveToStash()\n\t\t\t\t}\n\t\t\t\tbinding = b\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tnoDynamics = false\n\t\t\treturn\n\t\t}\n\t\tif curScope.dynamic {\n\t\t\tnoDynamics = false\n\t\t}\n\t\tif name == \"arguments\" && curScope.funcType != funcNone && curScope.funcType != funcArrow {\n\t\t\tif curScope.funcType == funcClsInit {\n\t\t\t\ts.c.throwSyntaxError(0, \"'arguments' is not allowed in class field initializer or static initialization block\")\n\t\t\t}\n\t\t\tcurScope.argsNeeded = true\n\t\t\tbinding, _ = curScope.bindName(name)\n\t\t\treturn\n\t\t}\n\t\tif curScope.isFunction() {\n\t\t\ttoStash = true\n\t\t}\n\t}\n}\n\nfunc (s *scope) lookupThis() (*binding, bool) {\n\ttoStash := false\n\tfor curScope := s; curScope != nil; curScope = curScope.outer {\n\t\tif curScope.outer == nil {\n\t\t\tif curScope.eval {\n\t\t\t\treturn nil, true\n\t\t\t}\n\t\t}\n\t\tif b, exists := curScope.boundNames[thisBindingName]; exists {\n\t\t\tif toStash && !b.inStash {\n\t\t\t\tb.moveToStash()\n\t\t\t}\n\t\t\treturn b, false\n\t\t}\n\t\tif curScope.isFunction() {\n\t\t\ttoStash = true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (s *scope) ensureBoundNamesCreated() {\n\tif s.boundNames == nil {\n\t\ts.boundNames = make(map[unistring.String]*binding)\n\t}\n}\n\nfunc (s *scope) addBinding(offset int) *binding {\n\tif len(s.bindings) >= (1<<24)-1 {\n\t\ts.c.throwSyntaxError(offset, \"Too many variables\")\n\t}\n\tb := &binding{\n\t\tscope: s,\n\t}\n\ts.bindings = append(s.bindings, b)\n\treturn b\n}\n\nfunc (s *scope) bindNameLexical(name unistring.String, unique bool, offset int) (*binding, bool) {\n\tif b := s.boundNames[name]; b != nil {\n\t\tif unique {\n\t\t\ts.c.throwSyntaxError(offset, \"Identifier '%s' has already been declared\", name)\n\t\t}\n\t\treturn b, false\n\t}\n\tb := s.addBinding(offset)\n\tb.name = name\n\ts.ensureBoundNamesCreated()\n\ts.boundNames[name] = b\n\treturn b, true\n}\n\nfunc (s *scope) createThisBinding() *binding {\n\tthisBinding, _ := s.bindNameLexical(thisBindingName, false, 0)\n\tthisBinding.isVar = true // don't check on load\n\treturn thisBinding\n}\n\nfunc (s *scope) bindName(name unistring.String) (*binding, bool) {\n\tif !s.isFunction() && !s.variable && s.outer != nil {\n\t\treturn s.outer.bindName(name)\n\t}\n\tb, created := s.bindNameLexical(name, false, 0)\n\tif created {\n\t\tb.isVar = true\n\t}\n\treturn b, created\n}\n\nfunc (s *scope) bindNameShadow(name unistring.String) (*binding, bool) {\n\tif !s.isFunction() && s.outer != nil {\n\t\treturn s.outer.bindNameShadow(name)\n\t}\n\n\t_, exists := s.boundNames[name]\n\tb := &binding{\n\t\tscope: s,\n\t\tname:  name,\n\t}\n\ts.bindings = append(s.bindings, b)\n\ts.ensureBoundNamesCreated()\n\ts.boundNames[name] = b\n\treturn b, !exists\n}\n\nfunc (s *scope) nearestFunction() *scope {\n\tfor sc := s; sc != nil; sc = sc.outer {\n\t\tif sc.isFunction() {\n\t\t\treturn sc\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *scope) nearestThis() *scope {\n\tfor sc := s; sc != nil; sc = sc.outer {\n\t\tif sc.eval || sc.isFunction() && sc.funcType != funcArrow {\n\t\t\treturn sc\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *scope) finaliseVarAlloc(stackOffset int) (stashSize, stackSize int) {\n\targsInStash := false\n\tif f := s.nearestFunction(); f != nil {\n\t\targsInStash = f.argsInStash\n\t}\n\tstackIdx, stashIdx := 0, 0\n\tallInStash := s.isDynamic()\n\tvar derivedCtor bool\n\tif fs := s.nearestThis(); fs != nil && fs.funcType == funcDerivedCtor {\n\t\tderivedCtor = true\n\t}\n\tfor i, b := range s.bindings {\n\t\tvar this bool\n\t\tif b.name == thisBindingName {\n\t\t\tthis = true\n\t\t}\n\t\tif allInStash || b.inStash {\n\t\t\tfor scope, aps := range b.accessPoints {\n\t\t\t\tvar level uint32\n\t\t\t\tfor sc := scope; sc != nil && sc != s; sc = sc.outer {\n\t\t\t\t\tif sc.needStash || sc.isDynamic() {\n\t\t\t\t\t\tlevel++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif level > 255 {\n\t\t\t\t\ts.c.throwSyntaxError(0, \"Maximum nesting level (256) exceeded\")\n\t\t\t\t}\n\t\t\t\tidx := (level << 24) | uint32(stashIdx)\n\t\t\t\tbase := scope.base\n\t\t\t\tcode := scope.prg.code\n\t\t\t\tif this {\n\t\t\t\t\tif derivedCtor {\n\t\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\t\tswitch (*ap).(type) {\n\t\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t\t*ap = loadThisStash(idx)\n\t\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t\t*ap = initStash(idx)\n\t\t\t\t\t\t\tcase resolveThisStack:\n\t\t\t\t\t\t\t\t*ap = resolveThisStash(idx)\n\t\t\t\t\t\t\tcase _ret:\n\t\t\t\t\t\t\t\t*ap = cret(idx)\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for 'this'\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\t\tswitch (*ap).(type) {\n\t\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t\t*ap = loadStash(idx)\n\t\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t\t*ap = initStash(idx)\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for 'this'\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\tswitch i := (*ap).(type) {\n\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t*ap = loadStash(idx)\n\t\t\t\t\t\tcase storeStack:\n\t\t\t\t\t\t\t*ap = storeStash(idx)\n\t\t\t\t\t\tcase storeStackP:\n\t\t\t\t\t\t\t*ap = storeStashP(idx)\n\t\t\t\t\t\tcase loadStackLex:\n\t\t\t\t\t\t\t*ap = loadStashLex(idx)\n\t\t\t\t\t\tcase storeStackLex:\n\t\t\t\t\t\t\t*ap = storeStashLex(idx)\n\t\t\t\t\t\tcase storeStackLexP:\n\t\t\t\t\t\t\t*ap = storeStashLexP(idx)\n\t\t\t\t\t\tcase initStackP:\n\t\t\t\t\t\t\t*ap = initStashP(idx)\n\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t*ap = initStash(idx)\n\t\t\t\t\t\tcase *loadMixed:\n\t\t\t\t\t\t\ti.idx = idx\n\t\t\t\t\t\tcase *loadMixedLex:\n\t\t\t\t\t\t\ti.idx = idx\n\t\t\t\t\t\tcase *resolveMixed:\n\t\t\t\t\t\t\ti.idx = idx\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for binding: %T\", i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstashIdx++\n\t\t} else {\n\t\t\tvar idx int\n\t\t\tif !this {\n\t\t\t\tif i < s.numArgs {\n\t\t\t\t\tidx = -(i + 1)\n\t\t\t\t} else {\n\t\t\t\t\tstackIdx++\n\t\t\t\t\tidx = stackIdx + stackOffset\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor scope, aps := range b.accessPoints {\n\t\t\t\tvar level int\n\t\t\t\tfor sc := scope; sc != nil && sc != s; sc = sc.outer {\n\t\t\t\t\tif sc.needStash || sc.isDynamic() {\n\t\t\t\t\t\tlevel++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif level > 255 {\n\t\t\t\t\ts.c.throwSyntaxError(0, \"Maximum nesting level (256) exceeded\")\n\t\t\t\t}\n\t\t\t\tcode := scope.prg.code\n\t\t\t\tbase := scope.base\n\t\t\t\tif this {\n\t\t\t\t\tif derivedCtor {\n\t\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\t\tswitch (*ap).(type) {\n\t\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t\t*ap = loadThisStack{}\n\t\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t\t// no-op\n\t\t\t\t\t\t\tcase resolveThisStack:\n\t\t\t\t\t\t\t\t// no-op\n\t\t\t\t\t\t\tcase _ret:\n\t\t\t\t\t\t\t\t// no-op, already in the right place\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for 'this'\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} /*else {\n\t\t\t\t\t\tno-op\n\t\t\t\t\t}*/\n\t\t\t\t} else if argsInStash {\n\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\tswitch i := (*ap).(type) {\n\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t*ap = loadStack1(idx)\n\t\t\t\t\t\tcase storeStack:\n\t\t\t\t\t\t\t*ap = storeStack1(idx)\n\t\t\t\t\t\tcase storeStackP:\n\t\t\t\t\t\t\t*ap = storeStack1P(idx)\n\t\t\t\t\t\tcase loadStackLex:\n\t\t\t\t\t\t\t*ap = loadStack1Lex(idx)\n\t\t\t\t\t\tcase storeStackLex:\n\t\t\t\t\t\t\t*ap = storeStack1Lex(idx)\n\t\t\t\t\t\tcase storeStackLexP:\n\t\t\t\t\t\t\t*ap = storeStack1LexP(idx)\n\t\t\t\t\t\tcase initStackP:\n\t\t\t\t\t\t\t*ap = initStack1P(idx)\n\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t*ap = initStack1(idx)\n\t\t\t\t\t\tcase *loadMixed:\n\t\t\t\t\t\t\t*ap = &loadMixedStack1{name: i.name, idx: idx, level: uint8(level), callee: i.callee}\n\t\t\t\t\t\tcase *loadMixedLex:\n\t\t\t\t\t\t\t*ap = &loadMixedStack1Lex{name: i.name, idx: idx, level: uint8(level), callee: i.callee}\n\t\t\t\t\t\tcase *resolveMixed:\n\t\t\t\t\t\t\t*ap = &resolveMixedStack1{typ: i.typ, name: i.name, idx: idx, level: uint8(level), strict: i.strict}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for binding: %T\", i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor _, pc := range *aps {\n\t\t\t\t\t\tap := &code[base+pc]\n\t\t\t\t\t\tswitch i := (*ap).(type) {\n\t\t\t\t\t\tcase loadStack:\n\t\t\t\t\t\t\t*ap = loadStack(idx)\n\t\t\t\t\t\tcase storeStack:\n\t\t\t\t\t\t\t*ap = storeStack(idx)\n\t\t\t\t\t\tcase storeStackP:\n\t\t\t\t\t\t\t*ap = storeStackP(idx)\n\t\t\t\t\t\tcase loadStackLex:\n\t\t\t\t\t\t\t*ap = loadStackLex(idx)\n\t\t\t\t\t\tcase storeStackLex:\n\t\t\t\t\t\t\t*ap = storeStackLex(idx)\n\t\t\t\t\t\tcase storeStackLexP:\n\t\t\t\t\t\t\t*ap = storeStackLexP(idx)\n\t\t\t\t\t\tcase initStack:\n\t\t\t\t\t\t\t*ap = initStack(idx)\n\t\t\t\t\t\tcase initStackP:\n\t\t\t\t\t\t\t*ap = initStackP(idx)\n\t\t\t\t\t\tcase *loadMixed:\n\t\t\t\t\t\t\t*ap = &loadMixedStack{name: i.name, idx: idx, level: uint8(level), callee: i.callee}\n\t\t\t\t\t\tcase *loadMixedLex:\n\t\t\t\t\t\t\t*ap = &loadMixedStackLex{name: i.name, idx: idx, level: uint8(level), callee: i.callee}\n\t\t\t\t\t\tcase *resolveMixed:\n\t\t\t\t\t\t\t*ap = &resolveMixedStack{typ: i.typ, name: i.name, idx: idx, level: uint8(level), strict: i.strict}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ts.c.assert(false, s.c.p.sourceOffset(pc), \"Unsupported instruction for binding: %T\", i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor _, nested := range s.nested {\n\t\tnested.finaliseVarAlloc(stackIdx + stackOffset)\n\t}\n\treturn stashIdx, stackIdx\n}\n\nfunc (s *scope) moveArgsToStash() {\n\tfor _, b := range s.bindings {\n\t\tif !b.isArg {\n\t\t\tbreak\n\t\t}\n\t\tb.inStash = true\n\t}\n\ts.argsInStash = true\n\ts.needStash = true\n}\n\nfunc (c *compiler) trimCode(delta int) {\n\tsrc := c.p.code[delta:]\n\tnewCode := make([]instruction, len(src))\n\tcopy(newCode, src)\n\tif cap(c.codeScratchpad) < cap(c.p.code) {\n\t\tc.codeScratchpad = c.p.code[:0]\n\t}\n\tc.p.code = newCode\n}\n\nfunc (s *scope) trimCode(delta int) {\n\ts.c.trimCode(delta)\n\tif delta != 0 {\n\t\tsrcMap := s.c.p.srcMap\n\t\tfor i := range srcMap {\n\t\t\tsrcMap[i].pc -= delta\n\t\t}\n\t\ts.adjustBase(-delta)\n\t}\n}\n\nfunc (s *scope) adjustBase(delta int) {\n\ts.base += delta\n\tfor _, nested := range s.nested {\n\t\tnested.adjustBase(delta)\n\t}\n}\n\nfunc (s *scope) makeNamesMap() map[unistring.String]uint32 {\n\tl := len(s.bindings)\n\tif l == 0 {\n\t\treturn nil\n\t}\n\tnames := make(map[unistring.String]uint32, l)\n\tfor i, b := range s.bindings {\n\t\tidx := uint32(i)\n\t\tif b.isConst {\n\t\t\tidx |= maskConst\n\t\t\tif b.isStrict {\n\t\t\t\tidx |= maskStrict\n\t\t\t}\n\t\t}\n\t\tif b.isVar {\n\t\t\tidx |= maskVar\n\t\t}\n\t\tnames[b.name] = idx\n\t}\n\treturn names\n}\n\nfunc (s *scope) isDynamic() bool {\n\treturn s.dynLookup || s.dynamic\n}\n\nfunc (s *scope) isFunction() bool {\n\treturn s.funcType != funcNone && !s.eval\n}\n\nfunc (s *scope) deleteBinding(b *binding) {\n\tidx := 0\n\tfor i, bb := range s.bindings {\n\t\tif bb == b {\n\t\t\tidx = i\n\t\t\tgoto found\n\t\t}\n\t}\n\treturn\nfound:\n\tdelete(s.boundNames, b.name)\n\tcopy(s.bindings[idx:], s.bindings[idx+1:])\n\tl := len(s.bindings) - 1\n\ts.bindings[l] = nil\n\ts.bindings = s.bindings[:l]\n}\n\nfunc (c *compiler) compile(in *ast.Program, strict, inGlobal bool, evalVm *vm) {\n\tc.ctxVM = evalVm\n\n\teval := evalVm != nil\n\tc.p.src = in.File\n\tc.newScope()\n\tscope := c.scope\n\tscope.dynamic = true\n\tscope.eval = eval\n\tif !strict && len(in.Body) > 0 {\n\t\tstrict = c.isStrict(in.Body) != nil\n\t}\n\tscope.strict = strict\n\townVarScope := eval && strict\n\townLexScope := !inGlobal || eval\n\tif ownVarScope {\n\t\tc.newBlockScope()\n\t\tscope = c.scope\n\t\tscope.variable = true\n\t}\n\tif eval && !inGlobal {\n\t\tfor s := evalVm.stash; s != nil; s = s.outer {\n\t\t\tif ft := s.funcType; ft != funcNone && ft != funcArrow {\n\t\t\t\tscope.funcType = ft\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tfuncs := c.extractFunctions(in.Body)\n\tc.createFunctionBindings(funcs)\n\tnumFuncs := len(scope.bindings)\n\tif inGlobal && !ownVarScope {\n\t\tif numFuncs == len(funcs) {\n\t\t\tc.compileFunctionsGlobalAllUnique(funcs)\n\t\t} else {\n\t\t\tc.compileFunctionsGlobal(funcs)\n\t\t}\n\t}\n\tc.compileDeclList(in.DeclarationList, false)\n\tnumVars := len(scope.bindings) - numFuncs\n\tvars := make([]unistring.String, len(scope.bindings))\n\tfor i, b := range scope.bindings {\n\t\tvars[i] = b.name\n\t}\n\tif len(vars) > 0 && !ownVarScope && ownLexScope {\n\t\tif inGlobal {\n\t\t\tc.emit(&bindGlobal{\n\t\t\t\tvars:      vars[numFuncs:],\n\t\t\t\tfuncs:     vars[:numFuncs],\n\t\t\t\tdeletable: eval,\n\t\t\t})\n\t\t} else {\n\t\t\tc.emit(&bindVars{names: vars, deletable: eval})\n\t\t}\n\t}\n\tvar enter *enterBlock\n\tif c.compileLexicalDeclarations(in.Body, ownVarScope || !ownLexScope) {\n\t\tif ownLexScope {\n\t\t\tc.block = &block{\n\t\t\t\touter:      c.block,\n\t\t\t\ttyp:        blockScope,\n\t\t\t\tneedResult: true,\n\t\t\t}\n\t\t\tenter = &enterBlock{}\n\t\t\tc.emit(enter)\n\t\t}\n\t}\n\tif len(scope.bindings) > 0 && !ownLexScope {\n\t\tvar lets, consts []unistring.String\n\t\tfor _, b := range c.scope.bindings[numFuncs+numVars:] {\n\t\t\tif b.isConst {\n\t\t\t\tconsts = append(consts, b.name)\n\t\t\t} else {\n\t\t\t\tlets = append(lets, b.name)\n\t\t\t}\n\t\t}\n\t\tc.emit(&bindGlobal{\n\t\t\tvars:   vars[numFuncs:],\n\t\t\tfuncs:  vars[:numFuncs],\n\t\t\tlets:   lets,\n\t\t\tconsts: consts,\n\t\t})\n\t}\n\tif !inGlobal || ownVarScope {\n\t\tc.compileFunctions(funcs)\n\t}\n\tc.compileStatements(in.Body, true)\n\tif enter != nil {\n\t\tc.leaveScopeBlock(enter)\n\t\tc.popScope()\n\t}\n\n\tscope.finaliseVarAlloc(0)\n\tc.stringCache = nil\n}\n\nfunc (c *compiler) compileDeclList(v []*ast.VariableDeclaration, inFunc bool) {\n\tfor _, value := range v {\n\t\tc.createVarBindings(value, inFunc)\n\t}\n}\n\nfunc (c *compiler) extractLabelled(st ast.Statement) ast.Statement {\n\tif st, ok := st.(*ast.LabelledStatement); ok {\n\t\treturn c.extractLabelled(st.Statement)\n\t}\n\treturn st\n}\n\nfunc (c *compiler) extractFunctions(list []ast.Statement) (funcs []*ast.FunctionDeclaration) {\n\tfor _, st := range list {\n\t\tvar decl *ast.FunctionDeclaration\n\t\tswitch st := c.extractLabelled(st).(type) {\n\t\tcase *ast.FunctionDeclaration:\n\t\t\tdecl = st\n\t\tcase *ast.LabelledStatement:\n\t\t\tif st1, ok := st.Statement.(*ast.FunctionDeclaration); ok {\n\t\t\t\tdecl = st1\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tfuncs = append(funcs, decl)\n\t}\n\treturn\n}\n\nfunc (c *compiler) createFunctionBindings(funcs []*ast.FunctionDeclaration) {\n\ts := c.scope\n\tif s.outer != nil {\n\t\tunique := !s.isFunction() && !s.variable && s.strict\n\t\tif !unique {\n\t\t\thasNonStandard := false\n\t\t\tfor _, decl := range funcs {\n\t\t\t\tif !decl.Function.Async && !decl.Function.Generator {\n\t\t\t\t\ts.bindNameLexical(decl.Function.Name.Name, false, int(decl.Function.Name.Idx1())-1)\n\t\t\t\t} else {\n\t\t\t\t\thasNonStandard = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif hasNonStandard {\n\t\t\t\tfor _, decl := range funcs {\n\t\t\t\t\tif decl.Function.Async || decl.Function.Generator {\n\t\t\t\t\t\ts.bindNameLexical(decl.Function.Name.Name, true, int(decl.Function.Name.Idx1())-1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, decl := range funcs {\n\t\t\t\ts.bindNameLexical(decl.Function.Name.Name, true, int(decl.Function.Name.Idx1())-1)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, decl := range funcs {\n\t\t\ts.bindName(decl.Function.Name.Name)\n\t\t}\n\t}\n}\n\nfunc (c *compiler) compileFunctions(list []*ast.FunctionDeclaration) {\n\tfor _, decl := range list {\n\t\tc.compileFunction(decl)\n\t}\n}\n\nfunc (c *compiler) compileFunctionsGlobalAllUnique(list []*ast.FunctionDeclaration) {\n\tfor _, decl := range list {\n\t\tc.compileFunctionLiteral(decl.Function, false).emitGetter(true)\n\t}\n}\n\nfunc (c *compiler) compileFunctionsGlobal(list []*ast.FunctionDeclaration) {\n\tm := make(map[unistring.String]int, len(list))\n\tfor i := len(list) - 1; i >= 0; i-- {\n\t\tname := list[i].Function.Name.Name\n\t\tif _, exists := m[name]; !exists {\n\t\t\tm[name] = i\n\t\t}\n\t}\n\tidx := 0\n\tfor i, decl := range list {\n\t\tname := decl.Function.Name.Name\n\t\tif m[name] == i {\n\t\t\tc.compileFunctionLiteral(decl.Function, false).emitGetter(true)\n\t\t\tc.scope.bindings[idx] = c.scope.boundNames[name]\n\t\t\tidx++\n\t\t} else {\n\t\t\tleave := c.enterDummyMode()\n\t\t\tc.compileFunctionLiteral(decl.Function, false).emitGetter(false)\n\t\t\tleave()\n\t\t}\n\t}\n}\n\nfunc (c *compiler) createVarIdBinding(name unistring.String, offset int, inFunc bool) {\n\tif c.scope.strict {\n\t\tc.checkIdentifierLName(name, offset)\n\t\tc.checkIdentifierName(name, offset)\n\t}\n\tif !inFunc || name != \"arguments\" {\n\t\tc.scope.bindName(name)\n\t}\n}\n\nfunc (c *compiler) createBindings(target ast.Expression, createIdBinding func(name unistring.String, offset int)) {\n\tswitch target := target.(type) {\n\tcase *ast.Identifier:\n\t\tcreateIdBinding(target.Name, int(target.Idx)-1)\n\tcase *ast.ObjectPattern:\n\t\tfor _, prop := range target.Properties {\n\t\t\tswitch prop := prop.(type) {\n\t\t\tcase *ast.PropertyShort:\n\t\t\t\tcreateIdBinding(prop.Name.Name, int(prop.Name.Idx)-1)\n\t\t\tcase *ast.PropertyKeyed:\n\t\t\t\tc.createBindings(prop.Value, createIdBinding)\n\t\t\tdefault:\n\t\t\t\tc.throwSyntaxError(int(target.Idx0()-1), \"unsupported property type in ObjectPattern: %T\", prop)\n\t\t\t}\n\t\t}\n\t\tif target.Rest != nil {\n\t\t\tc.createBindings(target.Rest, createIdBinding)\n\t\t}\n\tcase *ast.ArrayPattern:\n\t\tfor _, elt := range target.Elements {\n\t\t\tif elt != nil {\n\t\t\t\tc.createBindings(elt, createIdBinding)\n\t\t\t}\n\t\t}\n\t\tif target.Rest != nil {\n\t\t\tc.createBindings(target.Rest, createIdBinding)\n\t\t}\n\tcase *ast.AssignExpression:\n\t\tc.createBindings(target.Left, createIdBinding)\n\tdefault:\n\t\tc.throwSyntaxError(int(target.Idx0()-1), \"unsupported binding target: %T\", target)\n\t}\n}\n\nfunc (c *compiler) createVarBinding(target ast.Expression, inFunc bool) {\n\tc.createBindings(target, func(name unistring.String, offset int) {\n\t\tc.createVarIdBinding(name, offset, inFunc)\n\t})\n}\n\nfunc (c *compiler) createVarBindings(v *ast.VariableDeclaration, inFunc bool) {\n\tfor _, item := range v.List {\n\t\tc.createVarBinding(item.Target, inFunc)\n\t}\n}\n\nfunc (c *compiler) createLexicalIdBinding(name unistring.String, isConst bool, offset int) *binding {\n\tif name == \"let\" {\n\t\tc.throwSyntaxError(offset, \"let is disallowed as a lexically bound name\")\n\t}\n\tif c.scope.strict {\n\t\tc.checkIdentifierLName(name, offset)\n\t\tc.checkIdentifierName(name, offset)\n\t}\n\tb, _ := c.scope.bindNameLexical(name, true, offset)\n\tif isConst {\n\t\tb.isConst, b.isStrict = true, true\n\t}\n\treturn b\n}\n\nfunc (c *compiler) createLexicalIdBindingFuncBody(name unistring.String, isConst bool, offset int, calleeBinding *binding) *binding {\n\tif name == \"let\" {\n\t\tc.throwSyntaxError(offset, \"let is disallowed as a lexically bound name\")\n\t}\n\tif c.scope.strict {\n\t\tc.checkIdentifierLName(name, offset)\n\t\tc.checkIdentifierName(name, offset)\n\t}\n\tparamScope := c.scope.outer\n\tparentBinding := paramScope.boundNames[name]\n\tif parentBinding != nil {\n\t\tif parentBinding != calleeBinding && (name != \"arguments\" || !paramScope.argsNeeded) {\n\t\t\tc.throwSyntaxError(offset, \"Identifier '%s' has already been declared\", name)\n\t\t}\n\t}\n\tb, _ := c.scope.bindNameLexical(name, true, offset)\n\tif isConst {\n\t\tb.isConst, b.isStrict = true, true\n\t}\n\treturn b\n}\n\nfunc (c *compiler) createLexicalBinding(target ast.Expression, isConst bool) {\n\tc.createBindings(target, func(name unistring.String, offset int) {\n\t\tc.createLexicalIdBinding(name, isConst, offset)\n\t})\n}\n\nfunc (c *compiler) createLexicalBindings(lex *ast.LexicalDeclaration) {\n\tfor _, d := range lex.List {\n\t\tc.createLexicalBinding(d.Target, lex.Token == token.CONST)\n\t}\n}\n\nfunc (c *compiler) compileLexicalDeclarations(list []ast.Statement, scopeDeclared bool) bool {\n\tfor _, st := range list {\n\t\tif lex, ok := st.(*ast.LexicalDeclaration); ok {\n\t\t\tif !scopeDeclared {\n\t\t\t\tc.newBlockScope()\n\t\t\t\tscopeDeclared = true\n\t\t\t}\n\t\t\tc.createLexicalBindings(lex)\n\t\t} else if cls, ok := st.(*ast.ClassDeclaration); ok {\n\t\t\tif !scopeDeclared {\n\t\t\t\tc.newBlockScope()\n\t\t\t\tscopeDeclared = true\n\t\t\t}\n\t\t\tc.createLexicalIdBinding(cls.Class.Name.Name, false, int(cls.Class.Name.Idx)-1)\n\t\t}\n\t}\n\treturn scopeDeclared\n}\n\nfunc (c *compiler) compileLexicalDeclarationsFuncBody(list []ast.Statement, calleeBinding *binding) {\n\tfor _, st := range list {\n\t\tif lex, ok := st.(*ast.LexicalDeclaration); ok {\n\t\t\tisConst := lex.Token == token.CONST\n\t\t\tfor _, d := range lex.List {\n\t\t\t\tc.createBindings(d.Target, func(name unistring.String, offset int) {\n\t\t\t\t\tc.createLexicalIdBindingFuncBody(name, isConst, offset, calleeBinding)\n\t\t\t\t})\n\t\t\t}\n\t\t} else if cls, ok := st.(*ast.ClassDeclaration); ok {\n\t\t\tc.createLexicalIdBindingFuncBody(cls.Class.Name.Name, false, int(cls.Class.Name.Idx)-1, calleeBinding)\n\t\t}\n\t}\n}\n\nfunc (c *compiler) compileFunction(v *ast.FunctionDeclaration) {\n\tname := v.Function.Name.Name\n\tb := c.scope.boundNames[name]\n\tif b == nil || b.isVar {\n\t\te := &compiledIdentifierExpr{\n\t\t\tname: v.Function.Name.Name,\n\t\t}\n\t\te.init(c, v.Function.Idx0())\n\t\te.emitSetter(c.compileFunctionLiteral(v.Function, false), false)\n\t} else {\n\t\tc.compileFunctionLiteral(v.Function, false).emitGetter(true)\n\t\tb.emitInitP()\n\t}\n}\n\nfunc (c *compiler) compileStandaloneFunctionDecl(v *ast.FunctionDeclaration) {\n\tif v.Function.Async {\n\t\tc.throwSyntaxError(int(v.Idx0())-1, \"Async functions can only be declared at top level or inside a block.\")\n\t}\n\tif v.Function.Generator {\n\t\tc.throwSyntaxError(int(v.Idx0())-1, \"Generators can only be declared at top level or inside a block.\")\n\t}\n\tif c.scope.strict {\n\t\tc.throwSyntaxError(int(v.Idx0())-1, \"In strict mode code, functions can only be declared at top level or inside a block.\")\n\t}\n\tc.throwSyntaxError(int(v.Idx0())-1, \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\")\n}\n\nfunc (c *compiler) emit(instructions ...instruction) {\n\tc.p.code = append(c.p.code, instructions...)\n}\n\nfunc (c *compiler) throwSyntaxError(offset int, format string, args ...interface{}) {\n\tpanic(&CompilerSyntaxError{\n\t\tCompilerError: CompilerError{\n\t\t\tFile:    c.p.src,\n\t\t\tOffset:  offset,\n\t\t\tMessage: fmt.Sprintf(format, args...),\n\t\t},\n\t})\n}\n\nfunc (c *compiler) isStrict(list []ast.Statement) *ast.StringLiteral {\n\tfor _, st := range list {\n\t\tif st, ok := st.(*ast.ExpressionStatement); ok {\n\t\t\tif e, ok := st.Expression.(*ast.StringLiteral); ok {\n\t\t\t\tif e.Literal == `\"use strict\"` || e.Literal == `'use strict'` {\n\t\t\t\t\treturn e\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) isStrictStatement(s ast.Statement) *ast.StringLiteral {\n\tif s, ok := s.(*ast.BlockStatement); ok {\n\t\treturn c.isStrict(s.List)\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) checkIdentifierName(name unistring.String, offset int) {\n\tswitch name {\n\tcase \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\":\n\t\tc.throwSyntaxError(offset, \"Unexpected strict mode reserved word\")\n\t}\n}\n\nfunc (c *compiler) checkIdentifierLName(name unistring.String, offset int) {\n\tswitch name {\n\tcase \"eval\", \"arguments\":\n\t\tc.throwSyntaxError(offset, \"Assignment to eval or arguments is not allowed in strict mode\")\n\t}\n}\n\n// Enter a 'dummy' compilation mode. Any code produced after this method is called will be discarded after\n// leaveFunc is called with no additional side effects. This is useful for compiling code inside a\n// constant falsy condition 'if' branch or a loop (i.e 'if (false) { ... } or while (false) { ... }).\n// Such code should not be included in the final compilation result as it's never called, but it must\n// still produce compilation errors if there are any.\n// TODO: make sure variable lookups do not de-optimise parent scopes\nfunc (c *compiler) enterDummyMode() (leaveFunc func()) {\n\tsavedBlock, savedProgram := c.block, c.p\n\tif savedBlock != nil {\n\t\tc.block = &block{\n\t\t\ttyp:      savedBlock.typ,\n\t\t\tlabel:    savedBlock.label,\n\t\t\touter:    savedBlock.outer,\n\t\t\tbreaking: savedBlock.breaking,\n\t\t}\n\t}\n\tc.p = &Program{\n\t\tsrc: c.p.src,\n\t}\n\tc.newScope()\n\treturn func() {\n\t\tc.block, c.p = savedBlock, savedProgram\n\t\tc.popScope()\n\t}\n}\n\nfunc (c *compiler) compileStatementDummy(statement ast.Statement) {\n\tleave := c.enterDummyMode()\n\tc.compileStatement(statement, false)\n\tleave()\n}\n\nfunc (c *compiler) assert(cond bool, offset int, msg string, args ...interface{}) {\n\tif !cond {\n\t\tc.throwSyntaxError(offset, \"Compiler bug: \"+msg, args...)\n\t}\n}\n\nfunc privateIdString(desc unistring.String) unistring.String {\n\treturn asciiString(\"#\").Concat(stringValueFromRaw(desc)).string()\n}\n\ntype privateName struct {\n\tidx                  int\n\tisStatic             bool\n\tisMethod             bool\n\thasGetter, hasSetter bool\n}\n\ntype resolvedPrivateName struct {\n\tname     unistring.String\n\tidx      uint32\n\tlevel    uint8\n\tisStatic bool\n\tisMethod bool\n}\n\nfunc (r *resolvedPrivateName) string() unistring.String {\n\treturn privateIdString(r.name)\n}\n\ntype privateEnvRegistry struct {\n\tfields, methods []unistring.String\n}\n\ntype classScope struct {\n\tc            *compiler\n\tprivateNames map[unistring.String]*privateName\n\n\tinstanceEnv, staticEnv privateEnvRegistry\n\n\touter *classScope\n}\n\nfunc (r *privateEnvRegistry) createPrivateMethodId(name unistring.String) int {\n\tr.methods = append(r.methods, name)\n\treturn len(r.methods) - 1\n}\n\nfunc (r *privateEnvRegistry) createPrivateFieldId(name unistring.String) int {\n\tr.fields = append(r.fields, name)\n\treturn len(r.fields) - 1\n}\n\nfunc (s *classScope) declarePrivateId(name unistring.String, kind ast.PropertyKind, isStatic bool, offset int) {\n\tpn := s.privateNames[name]\n\tif pn != nil {\n\t\tif pn.isStatic == isStatic {\n\t\t\tswitch kind {\n\t\t\tcase ast.PropertyKindGet:\n\t\t\t\tif pn.hasSetter && !pn.hasGetter {\n\t\t\t\t\tpn.hasGetter = true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase ast.PropertyKindSet:\n\t\t\t\tif pn.hasGetter && !pn.hasSetter {\n\t\t\t\t\tpn.hasSetter = true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts.c.throwSyntaxError(offset, \"Identifier '#%s' has already been declared\", name)\n\t\tpanic(\"unreachable\")\n\t}\n\tvar env *privateEnvRegistry\n\tif isStatic {\n\t\tenv = &s.staticEnv\n\t} else {\n\t\tenv = &s.instanceEnv\n\t}\n\n\tpn = &privateName{\n\t\tisStatic:  isStatic,\n\t\thasGetter: kind == ast.PropertyKindGet,\n\t\thasSetter: kind == ast.PropertyKindSet,\n\t}\n\tif kind != ast.PropertyKindValue {\n\t\tpn.idx = env.createPrivateMethodId(name)\n\t\tpn.isMethod = true\n\t} else {\n\t\tpn.idx = env.createPrivateFieldId(name)\n\t}\n\n\tif s.privateNames == nil {\n\t\ts.privateNames = make(map[unistring.String]*privateName)\n\t}\n\ts.privateNames[name] = pn\n}\n\nfunc (s *classScope) getDeclaredPrivateId(name unistring.String) *privateName {\n\tif n := s.privateNames[name]; n != nil {\n\t\treturn n\n\t}\n\ts.c.assert(false, 0, \"getDeclaredPrivateId() for undeclared id\")\n\tpanic(\"unreachable\")\n}\n\nfunc (c *compiler) resolvePrivateName(name unistring.String, offset int) (*resolvedPrivateName, *privateId) {\n\tlevel := 0\n\tfor s := c.classScope; s != nil; s = s.outer {\n\t\tif len(s.privateNames) > 0 {\n\t\t\tif pn := s.privateNames[name]; pn != nil {\n\t\t\t\treturn &resolvedPrivateName{\n\t\t\t\t\tname:     name,\n\t\t\t\t\tidx:      uint32(pn.idx),\n\t\t\t\t\tlevel:    uint8(level),\n\t\t\t\t\tisStatic: pn.isStatic,\n\t\t\t\t\tisMethod: pn.isMethod,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\tlevel++\n\t\t}\n\t}\n\tif c.ctxVM != nil {\n\t\tfor s := c.ctxVM.privEnv; s != nil; s = s.outer {\n\t\t\tif id := s.names[name]; id != nil {\n\t\t\t\treturn nil, id\n\t\t\t}\n\t\t}\n\t}\n\tc.throwSyntaxError(offset, \"Private field '#%s' must be declared in an enclosing class\", name)\n\tpanic(\"unreachable\")\n}\n"
        },
        {
          "name": "compiler_expr.go",
          "type": "blob",
          "size": 80.3984375,
          "content": "package goja\n\nimport (\n\t\"math/big\"\n\n\t\"github.com/dop251/goja/ast\"\n\t\"github.com/dop251/goja/file\"\n\t\"github.com/dop251/goja/token\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype compiledExpr interface {\n\temitGetter(putOnStack bool)\n\temitSetter(valueExpr compiledExpr, putOnStack bool)\n\temitRef()\n\temitUnary(prepare, body func(), postfix, putOnStack bool)\n\tdeleteExpr() compiledExpr\n\tconstant() bool\n\taddSrcMap()\n}\n\ntype compiledExprOrRef interface {\n\tcompiledExpr\n\temitGetterOrRef()\n}\n\ntype compiledCallExpr struct {\n\tbaseCompiledExpr\n\targs   []compiledExpr\n\tcallee compiledExpr\n\n\tisVariadic bool\n}\n\ntype compiledNewExpr struct {\n\tcompiledCallExpr\n}\n\ntype compiledObjectLiteral struct {\n\tbaseCompiledExpr\n\texpr *ast.ObjectLiteral\n}\n\ntype compiledArrayLiteral struct {\n\tbaseCompiledExpr\n\texpr *ast.ArrayLiteral\n}\n\ntype compiledRegexpLiteral struct {\n\tbaseCompiledExpr\n\texpr *ast.RegExpLiteral\n}\n\ntype compiledLiteral struct {\n\tbaseCompiledExpr\n\tval Value\n}\n\ntype compiledTemplateLiteral struct {\n\tbaseCompiledExpr\n\ttag         compiledExpr\n\telements    []*ast.TemplateElement\n\texpressions []compiledExpr\n}\n\ntype compiledAssignExpr struct {\n\tbaseCompiledExpr\n\tleft, right compiledExpr\n\toperator    token.Token\n}\n\ntype compiledObjectAssignmentPattern struct {\n\tbaseCompiledExpr\n\texpr *ast.ObjectPattern\n}\n\ntype compiledArrayAssignmentPattern struct {\n\tbaseCompiledExpr\n\texpr *ast.ArrayPattern\n}\n\ntype deleteGlobalExpr struct {\n\tbaseCompiledExpr\n\tname unistring.String\n}\n\ntype deleteVarExpr struct {\n\tbaseCompiledExpr\n\tname unistring.String\n}\n\ntype deletePropExpr struct {\n\tbaseCompiledExpr\n\tleft compiledExpr\n\tname unistring.String\n}\n\ntype deleteElemExpr struct {\n\tbaseCompiledExpr\n\tleft, member compiledExpr\n}\n\ntype constantExpr struct {\n\tbaseCompiledExpr\n\tval Value\n}\n\ntype baseCompiledExpr struct {\n\tc      *compiler\n\toffset int\n}\n\ntype compiledIdentifierExpr struct {\n\tbaseCompiledExpr\n\tname unistring.String\n}\n\ntype compiledAwaitExpression struct {\n\tbaseCompiledExpr\n\targ compiledExpr\n}\n\ntype compiledYieldExpression struct {\n\tbaseCompiledExpr\n\targ      compiledExpr\n\tdelegate bool\n}\n\ntype funcType uint8\n\nconst (\n\tfuncNone funcType = iota\n\tfuncRegular\n\tfuncArrow\n\tfuncMethod\n\tfuncClsInit\n\tfuncCtor\n\tfuncDerivedCtor\n)\n\ntype compiledFunctionLiteral struct {\n\tbaseCompiledExpr\n\tname            *ast.Identifier\n\tparameterList   *ast.ParameterList\n\tbody            []ast.Statement\n\tsource          string\n\tdeclarationList []*ast.VariableDeclaration\n\tlhsName         unistring.String\n\tstrict          *ast.StringLiteral\n\thomeObjOffset   uint32\n\ttyp             funcType\n\tisExpr          bool\n\n\tisAsync, isGenerator bool\n}\n\ntype compiledBracketExpr struct {\n\tbaseCompiledExpr\n\tleft, member compiledExpr\n}\n\ntype compiledThisExpr struct {\n\tbaseCompiledExpr\n}\n\ntype compiledSuperExpr struct {\n\tbaseCompiledExpr\n}\n\ntype compiledNewTarget struct {\n\tbaseCompiledExpr\n}\n\ntype compiledSequenceExpr struct {\n\tbaseCompiledExpr\n\tsequence []compiledExpr\n}\n\ntype compiledUnaryExpr struct {\n\tbaseCompiledExpr\n\toperand  compiledExpr\n\toperator token.Token\n\tpostfix  bool\n}\n\ntype compiledConditionalExpr struct {\n\tbaseCompiledExpr\n\ttest, consequent, alternate compiledExpr\n}\n\ntype compiledLogicalOr struct {\n\tbaseCompiledExpr\n\tleft, right compiledExpr\n}\n\ntype compiledCoalesce struct {\n\tbaseCompiledExpr\n\tleft, right compiledExpr\n}\n\ntype compiledLogicalAnd struct {\n\tbaseCompiledExpr\n\tleft, right compiledExpr\n}\n\ntype compiledBinaryExpr struct {\n\tbaseCompiledExpr\n\tleft, right compiledExpr\n\toperator    token.Token\n}\n\ntype compiledEnumGetExpr struct {\n\tbaseCompiledExpr\n}\n\ntype defaultDeleteExpr struct {\n\tbaseCompiledExpr\n\texpr compiledExpr\n}\n\ntype compiledSpreadCallArgument struct {\n\tbaseCompiledExpr\n\texpr compiledExpr\n}\n\ntype compiledOptionalChain struct {\n\tbaseCompiledExpr\n\texpr compiledExpr\n}\n\ntype compiledOptional struct {\n\tbaseCompiledExpr\n\texpr compiledExpr\n}\n\nfunc (e *defaultDeleteExpr) emitGetter(putOnStack bool) {\n\te.expr.emitGetter(false)\n\tif putOnStack {\n\t\te.c.emitLiteralValue(valueTrue)\n\t}\n}\n\nfunc (c *compiler) compileExpression(v ast.Expression) compiledExpr {\n\t// log.Printf(\"compileExpression: %T\", v)\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase *ast.AssignExpression:\n\t\treturn c.compileAssignExpression(v)\n\tcase *ast.NumberLiteral:\n\t\treturn c.compileNumberLiteral(v)\n\tcase *ast.StringLiteral:\n\t\treturn c.compileStringLiteral(v)\n\tcase *ast.TemplateLiteral:\n\t\treturn c.compileTemplateLiteral(v)\n\tcase *ast.BooleanLiteral:\n\t\treturn c.compileBooleanLiteral(v)\n\tcase *ast.NullLiteral:\n\t\tr := &compiledLiteral{\n\t\t\tval: _null,\n\t\t}\n\t\tr.init(c, v.Idx0())\n\t\treturn r\n\tcase *ast.Identifier:\n\t\treturn c.compileIdentifierExpression(v)\n\tcase *ast.CallExpression:\n\t\treturn c.compileCallExpression(v)\n\tcase *ast.ObjectLiteral:\n\t\treturn c.compileObjectLiteral(v)\n\tcase *ast.ArrayLiteral:\n\t\treturn c.compileArrayLiteral(v)\n\tcase *ast.RegExpLiteral:\n\t\treturn c.compileRegexpLiteral(v)\n\tcase *ast.BinaryExpression:\n\t\treturn c.compileBinaryExpression(v)\n\tcase *ast.UnaryExpression:\n\t\treturn c.compileUnaryExpression(v)\n\tcase *ast.ConditionalExpression:\n\t\treturn c.compileConditionalExpression(v)\n\tcase *ast.FunctionLiteral:\n\t\treturn c.compileFunctionLiteral(v, true)\n\tcase *ast.ArrowFunctionLiteral:\n\t\treturn c.compileArrowFunctionLiteral(v)\n\tcase *ast.ClassLiteral:\n\t\treturn c.compileClassLiteral(v, true)\n\tcase *ast.DotExpression:\n\t\treturn c.compileDotExpression(v)\n\tcase *ast.PrivateDotExpression:\n\t\treturn c.compilePrivateDotExpression(v)\n\tcase *ast.BracketExpression:\n\t\treturn c.compileBracketExpression(v)\n\tcase *ast.ThisExpression:\n\t\tr := &compiledThisExpr{}\n\t\tr.init(c, v.Idx0())\n\t\treturn r\n\tcase *ast.SuperExpression:\n\t\tc.throwSyntaxError(int(v.Idx0())-1, \"'super' keyword unexpected here\")\n\t\tpanic(\"unreachable\")\n\tcase *ast.SequenceExpression:\n\t\treturn c.compileSequenceExpression(v)\n\tcase *ast.NewExpression:\n\t\treturn c.compileNewExpression(v)\n\tcase *ast.MetaProperty:\n\t\treturn c.compileMetaProperty(v)\n\tcase *ast.ObjectPattern:\n\t\treturn c.compileObjectAssignmentPattern(v)\n\tcase *ast.ArrayPattern:\n\t\treturn c.compileArrayAssignmentPattern(v)\n\tcase *ast.OptionalChain:\n\t\tr := &compiledOptionalChain{\n\t\t\texpr: c.compileExpression(v.Expression),\n\t\t}\n\t\tr.init(c, v.Idx0())\n\t\treturn r\n\tcase *ast.Optional:\n\t\tr := &compiledOptional{\n\t\t\texpr: c.compileExpression(v.Expression),\n\t\t}\n\t\tr.init(c, v.Idx0())\n\t\treturn r\n\tcase *ast.AwaitExpression:\n\t\tr := &compiledAwaitExpression{\n\t\t\targ: c.compileExpression(v.Argument),\n\t\t}\n\t\tr.init(c, v.Await)\n\t\treturn r\n\tcase *ast.YieldExpression:\n\t\tr := &compiledYieldExpression{\n\t\t\targ:      c.compileExpression(v.Argument),\n\t\t\tdelegate: v.Delegate,\n\t\t}\n\t\tr.init(c, v.Yield)\n\t\treturn r\n\tdefault:\n\t\tc.assert(false, int(v.Idx0())-1, \"Unknown expression type: %T\", v)\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (e *baseCompiledExpr) constant() bool {\n\treturn false\n}\n\nfunc (e *baseCompiledExpr) init(c *compiler, idx file.Idx) {\n\te.c = c\n\te.offset = int(idx) - 1\n}\n\nfunc (e *baseCompiledExpr) emitSetter(compiledExpr, bool) {\n\te.c.throwSyntaxError(e.offset, \"Not a valid left-value expression\")\n}\n\nfunc (e *baseCompiledExpr) emitRef() {\n\te.c.assert(false, e.offset, \"Cannot emit reference for this type of expression\")\n}\n\nfunc (e *baseCompiledExpr) deleteExpr() compiledExpr {\n\tr := &constantExpr{\n\t\tval: valueTrue,\n\t}\n\tr.init(e.c, file.Idx(e.offset+1))\n\treturn r\n}\n\nfunc (e *baseCompiledExpr) emitUnary(func(), func(), bool, bool) {\n\te.c.throwSyntaxError(e.offset, \"Not a valid left-value expression\")\n}\n\nfunc (e *baseCompiledExpr) addSrcMap() {\n\tif e.offset >= 0 {\n\t\te.c.p.addSrcMap(e.offset)\n\t}\n}\n\nfunc (e *constantExpr) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\te.addSrcMap()\n\t\te.c.emitLiteralValue(e.val)\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitGetter(putOnStack bool) {\n\te.addSrcMap()\n\tif b, noDynamics := e.c.scope.lookupName(e.name); noDynamics {\n\t\te.c.assert(b != nil, e.offset, \"No dynamics and not found\")\n\t\tif putOnStack {\n\t\t\tb.emitGet()\n\t\t} else {\n\t\t\tb.emitGetP()\n\t\t}\n\t} else {\n\t\tif b != nil {\n\t\t\tb.emitGetVar(false)\n\t\t} else {\n\t\t\te.c.emit(loadDynamic(e.name))\n\t\t}\n\t\tif !putOnStack {\n\t\t\te.c.emit(pop)\n\t\t}\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitGetterOrRef() {\n\te.addSrcMap()\n\tif b, noDynamics := e.c.scope.lookupName(e.name); noDynamics {\n\t\te.c.assert(b != nil, e.offset, \"No dynamics and not found\")\n\t\tb.emitGet()\n\t} else {\n\t\tif b != nil {\n\t\t\tb.emitGetVar(false)\n\t\t} else {\n\t\t\te.c.emit(loadDynamicRef(e.name))\n\t\t}\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitGetterAndCallee() {\n\te.addSrcMap()\n\tif b, noDynamics := e.c.scope.lookupName(e.name); noDynamics {\n\t\te.c.assert(b != nil, e.offset, \"No dynamics and not found\")\n\t\te.c.emit(loadUndef)\n\t\tb.emitGet()\n\t} else {\n\t\tif b != nil {\n\t\t\tb.emitGetVar(true)\n\t\t} else {\n\t\t\te.c.emit(loadDynamicCallee(e.name))\n\t\t}\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitVarSetter1(putOnStack bool, emitRight func(isRef bool)) {\n\te.addSrcMap()\n\tc := e.c\n\n\tif b, noDynamics := c.scope.lookupName(e.name); noDynamics {\n\t\tif c.scope.strict {\n\t\t\tc.checkIdentifierLName(e.name, e.offset)\n\t\t}\n\t\temitRight(false)\n\t\tif b != nil {\n\t\t\tif putOnStack {\n\t\t\t\tb.emitSet()\n\t\t\t} else {\n\t\t\t\tb.emitSetP()\n\t\t\t}\n\t\t} else {\n\t\t\tif c.scope.strict {\n\t\t\t\tc.emit(setGlobalStrict(e.name))\n\t\t\t} else {\n\t\t\t\tc.emit(setGlobal(e.name))\n\t\t\t}\n\t\t\tif !putOnStack {\n\t\t\t\tc.emit(pop)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tc.emitVarRef(e.name, e.offset, b)\n\t\temitRight(true)\n\t\tif putOnStack {\n\t\t\tc.emit(putValue)\n\t\t} else {\n\t\t\tc.emit(putValueP)\n\t\t}\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitVarSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.emitVarSetter1(putOnStack, func(bool) {\n\t\te.c.emitNamedOrConst(valueExpr, e.name)\n\t})\n}\n\nfunc (c *compiler) emitVarRef(name unistring.String, offset int, b *binding) {\n\tif c.scope.strict {\n\t\tc.checkIdentifierLName(name, offset)\n\t}\n\n\tif b != nil {\n\t\tb.emitResolveVar(c.scope.strict)\n\t} else {\n\t\tif c.scope.strict {\n\t\t\tc.emit(resolveVar1Strict(name))\n\t\t} else {\n\t\t\tc.emit(resolveVar1(name))\n\t\t}\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) emitRef() {\n\tb, _ := e.c.scope.lookupName(e.name)\n\te.c.emitVarRef(e.name, e.offset, b)\n}\n\nfunc (e *compiledIdentifierExpr) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.emitVarSetter(valueExpr, putOnStack)\n}\n\nfunc (e *compiledIdentifierExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\tif putOnStack {\n\t\te.emitVarSetter1(true, func(isRef bool) {\n\t\t\te.c.emit(loadUndef)\n\t\t\tif isRef {\n\t\t\t\te.c.emit(getValue)\n\t\t\t} else {\n\t\t\t\te.emitGetter(true)\n\t\t\t}\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tif !postfix {\n\t\t\t\tbody()\n\t\t\t}\n\t\t\te.c.emit(rdupN(1))\n\t\t\tif postfix {\n\t\t\t\tbody()\n\t\t\t}\n\t\t})\n\t\te.c.emit(pop)\n\t} else {\n\t\te.emitVarSetter1(false, func(isRef bool) {\n\t\t\tif isRef {\n\t\t\t\te.c.emit(getValue)\n\t\t\t} else {\n\t\t\t\te.emitGetter(true)\n\t\t\t}\n\t\t\tbody()\n\t\t})\n\t}\n}\n\nfunc (e *compiledIdentifierExpr) deleteExpr() compiledExpr {\n\tif e.c.scope.strict {\n\t\te.c.throwSyntaxError(e.offset, \"Delete of an unqualified identifier in strict mode\")\n\t\tpanic(\"Unreachable\")\n\t}\n\tif b, noDynamics := e.c.scope.lookupName(e.name); noDynamics {\n\t\tif b == nil {\n\t\t\tr := &deleteGlobalExpr{\n\t\t\t\tname: e.name,\n\t\t\t}\n\t\t\tr.init(e.c, file.Idx(0))\n\t\t\treturn r\n\t\t}\n\t} else {\n\t\tif b == nil {\n\t\t\tr := &deleteVarExpr{\n\t\t\t\tname: e.name,\n\t\t\t}\n\t\t\tr.init(e.c, file.Idx(e.offset+1))\n\t\t\treturn r\n\t\t}\n\t}\n\tr := &compiledLiteral{\n\t\tval: valueFalse,\n\t}\n\tr.init(e.c, file.Idx(e.offset+1))\n\treturn r\n}\n\ntype compiledSuperDotExpr struct {\n\tbaseCompiledExpr\n\tname unistring.String\n}\n\nfunc (e *compiledSuperDotExpr) emitGetter(putOnStack bool) {\n\te.c.emitLoadThis()\n\te.c.emit(loadSuper)\n\te.addSrcMap()\n\te.c.emit(getPropRecv(e.name))\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledSuperDotExpr) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.c.emitLoadThis()\n\te.c.emit(loadSuper)\n\tvalueExpr.emitGetter(true)\n\te.addSrcMap()\n\tif putOnStack {\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setPropRecvStrict(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropRecv(e.name))\n\t\t}\n\t} else {\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setPropRecvStrictP(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropRecvP(e.name))\n\t\t}\n\t}\n}\n\nfunc (e *compiledSuperDotExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\tif !putOnStack {\n\t\te.c.emitLoadThis()\n\t\te.c.emit(loadSuper, dupLast(2), getPropRecv(e.name))\n\t\tbody()\n\t\te.addSrcMap()\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setPropRecvStrictP(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropRecvP(e.name))\n\t\t}\n\t} else {\n\t\tif !postfix {\n\t\t\te.c.emitLoadThis()\n\t\t\te.c.emit(loadSuper, dupLast(2), getPropRecv(e.name))\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setPropRecvStrict(e.name))\n\t\t\t} else {\n\t\t\t\te.c.emit(setPropRecv(e.name))\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emit(loadUndef)\n\t\t\te.c.emitLoadThis()\n\t\t\te.c.emit(loadSuper, dupLast(2), getPropRecv(e.name))\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\te.c.emit(rdupN(3))\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setPropRecvStrictP(e.name))\n\t\t\t} else {\n\t\t\t\te.c.emit(setPropRecvP(e.name))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *compiledSuperDotExpr) emitRef() {\n\te.c.emitLoadThis()\n\te.c.emit(loadSuper)\n\tif e.c.scope.strict {\n\t\te.c.emit(getPropRefRecvStrict(e.name))\n\t} else {\n\t\te.c.emit(getPropRefRecv(e.name))\n\t}\n}\n\nfunc (e *compiledSuperDotExpr) deleteExpr() compiledExpr {\n\treturn e.c.superDeleteError(e.offset)\n}\n\ntype compiledDotExpr struct {\n\tbaseCompiledExpr\n\tleft compiledExpr\n\tname unistring.String\n}\n\ntype compiledPrivateDotExpr struct {\n\tbaseCompiledExpr\n\tleft compiledExpr\n\tname unistring.String\n}\n\nfunc (c *compiler) checkSuperBase(idx file.Idx) {\n\tif s := c.scope.nearestThis(); s != nil {\n\t\tswitch s.funcType {\n\t\tcase funcMethod, funcClsInit, funcCtor, funcDerivedCtor:\n\t\t\treturn\n\t\t}\n\t}\n\tc.throwSyntaxError(int(idx)-1, \"'super' keyword unexpected here\")\n\tpanic(\"unreachable\")\n}\n\nfunc (c *compiler) compileDotExpression(v *ast.DotExpression) compiledExpr {\n\tif sup, ok := v.Left.(*ast.SuperExpression); ok {\n\t\tc.checkSuperBase(sup.Idx)\n\t\tr := &compiledSuperDotExpr{\n\t\t\tname: v.Identifier.Name,\n\t\t}\n\t\tr.init(c, v.Identifier.Idx)\n\t\treturn r\n\t}\n\n\tr := &compiledDotExpr{\n\t\tleft: c.compileExpression(v.Left),\n\t\tname: v.Identifier.Name,\n\t}\n\tr.init(c, v.Identifier.Idx)\n\treturn r\n}\n\nfunc (c *compiler) compilePrivateDotExpression(v *ast.PrivateDotExpression) compiledExpr {\n\tr := &compiledPrivateDotExpr{\n\t\tleft: c.compileExpression(v.Left),\n\t\tname: v.Identifier.Name,\n\t}\n\tr.init(c, v.Identifier.Idx)\n\treturn r\n}\n\nfunc (e *compiledPrivateDotExpr) _emitGetter(rn *resolvedPrivateName, id *privateId) {\n\tif rn != nil {\n\t\te.c.emit((*getPrivatePropRes)(rn))\n\t} else {\n\t\te.c.emit((*getPrivatePropId)(id))\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) _emitSetter(rn *resolvedPrivateName, id *privateId) {\n\tif rn != nil {\n\t\te.c.emit((*setPrivatePropRes)(rn))\n\t} else {\n\t\te.c.emit((*setPrivatePropId)(id))\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) _emitSetterP(rn *resolvedPrivateName, id *privateId) {\n\tif rn != nil {\n\t\te.c.emit((*setPrivatePropResP)(rn))\n\t} else {\n\t\te.c.emit((*setPrivatePropIdP)(id))\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) emitGetter(putOnStack bool) {\n\te.left.emitGetter(true)\n\te.addSrcMap()\n\trn, id := e.c.resolvePrivateName(e.name, e.offset)\n\te._emitGetter(rn, id)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) emitSetter(v compiledExpr, putOnStack bool) {\n\trn, id := e.c.resolvePrivateName(e.name, e.offset)\n\te.left.emitGetter(true)\n\tv.emitGetter(true)\n\te.addSrcMap()\n\tif putOnStack {\n\t\te._emitSetter(rn, id)\n\t} else {\n\t\te._emitSetterP(rn, id)\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\trn, id := e.c.resolvePrivateName(e.name, e.offset)\n\tif !putOnStack {\n\t\te.left.emitGetter(true)\n\t\te.c.emit(dup)\n\t\te._emitGetter(rn, id)\n\t\tbody()\n\t\te.addSrcMap()\n\t\te._emitSetterP(rn, id)\n\t} else {\n\t\tif !postfix {\n\t\t\te.left.emitGetter(true)\n\t\t\te.c.emit(dup)\n\t\t\te._emitGetter(rn, id)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\te._emitSetter(rn, id)\n\t\t} else {\n\t\t\te.c.emit(loadUndef)\n\t\t\te.left.emitGetter(true)\n\t\t\te.c.emit(dup)\n\t\t\te._emitGetter(rn, id)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\te.c.emit(rdupN(2))\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\te._emitSetterP(rn, id)\n\t\t}\n\t}\n}\n\nfunc (e *compiledPrivateDotExpr) deleteExpr() compiledExpr {\n\te.c.throwSyntaxError(e.offset, \"Private fields can not be deleted\")\n\tpanic(\"unreachable\")\n}\n\nfunc (e *compiledPrivateDotExpr) emitRef() {\n\te.left.emitGetter(true)\n\trn, id := e.c.resolvePrivateName(e.name, e.offset)\n\tif rn != nil {\n\t\te.c.emit((*getPrivateRefRes)(rn))\n\t} else {\n\t\te.c.emit((*getPrivateRefId)(id))\n\t}\n}\n\ntype compiledSuperBracketExpr struct {\n\tbaseCompiledExpr\n\tmember compiledExpr\n}\n\nfunc (e *compiledSuperBracketExpr) emitGetter(putOnStack bool) {\n\te.c.emitLoadThis()\n\te.member.emitGetter(true)\n\te.c.emit(loadSuper)\n\te.addSrcMap()\n\te.c.emit(getElemRecv)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledSuperBracketExpr) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.c.emitLoadThis()\n\te.member.emitGetter(true)\n\te.c.emit(loadSuper)\n\tvalueExpr.emitGetter(true)\n\te.addSrcMap()\n\tif putOnStack {\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setElemRecvStrict)\n\t\t} else {\n\t\t\te.c.emit(setElemRecv)\n\t\t}\n\t} else {\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setElemRecvStrictP)\n\t\t} else {\n\t\t\te.c.emit(setElemRecvP)\n\t\t}\n\t}\n}\n\nfunc (e *compiledSuperBracketExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\tif !putOnStack {\n\t\te.c.emitLoadThis()\n\t\te.member.emitGetter(true)\n\t\te.c.emit(loadSuper, dupLast(3), getElemRecv)\n\t\tbody()\n\t\te.addSrcMap()\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setElemRecvStrictP)\n\t\t} else {\n\t\t\te.c.emit(setElemRecvP)\n\t\t}\n\t} else {\n\t\tif !postfix {\n\t\t\te.c.emitLoadThis()\n\t\t\te.member.emitGetter(true)\n\t\t\te.c.emit(loadSuper, dupLast(3), getElemRecv)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setElemRecvStrict)\n\t\t\t} else {\n\t\t\t\te.c.emit(setElemRecv)\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emit(loadUndef)\n\t\t\te.c.emitLoadThis()\n\t\t\te.member.emitGetter(true)\n\t\t\te.c.emit(loadSuper, dupLast(3), getElemRecv)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\te.c.emit(rdupN(4))\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setElemRecvStrictP)\n\t\t\t} else {\n\t\t\t\te.c.emit(setElemRecvP)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *compiledSuperBracketExpr) emitRef() {\n\te.c.emitLoadThis()\n\te.member.emitGetter(true)\n\te.c.emit(loadSuper)\n\tif e.c.scope.strict {\n\t\te.c.emit(getElemRefRecvStrict)\n\t} else {\n\t\te.c.emit(getElemRefRecv)\n\t}\n}\n\nfunc (c *compiler) superDeleteError(offset int) compiledExpr {\n\treturn c.compileEmitterExpr(func() {\n\t\tc.emit(throwConst{referenceError(\"Unsupported reference to 'super'\")})\n\t}, file.Idx(offset+1))\n}\n\nfunc (e *compiledSuperBracketExpr) deleteExpr() compiledExpr {\n\treturn e.c.superDeleteError(e.offset)\n}\n\nfunc (c *compiler) checkConstantString(expr compiledExpr) (unistring.String, bool) {\n\tif expr.constant() {\n\t\tif val, ex := c.evalConst(expr); ex == nil {\n\t\t\tif s, ok := val.(String); ok {\n\t\t\t\treturn s.string(), true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", false\n}\n\nfunc (c *compiler) compileBracketExpression(v *ast.BracketExpression) compiledExpr {\n\tif sup, ok := v.Left.(*ast.SuperExpression); ok {\n\t\tc.checkSuperBase(sup.Idx)\n\t\tmember := c.compileExpression(v.Member)\n\t\tif name, ok := c.checkConstantString(member); ok {\n\t\t\tr := &compiledSuperDotExpr{\n\t\t\t\tname: name,\n\t\t\t}\n\t\t\tr.init(c, v.LeftBracket)\n\t\t\treturn r\n\t\t}\n\n\t\tr := &compiledSuperBracketExpr{\n\t\t\tmember: member,\n\t\t}\n\t\tr.init(c, v.LeftBracket)\n\t\treturn r\n\t}\n\n\tleft := c.compileExpression(v.Left)\n\tmember := c.compileExpression(v.Member)\n\tif name, ok := c.checkConstantString(member); ok {\n\t\tr := &compiledDotExpr{\n\t\t\tleft: left,\n\t\t\tname: name,\n\t\t}\n\t\tr.init(c, v.LeftBracket)\n\t\treturn r\n\t}\n\n\tr := &compiledBracketExpr{\n\t\tleft:   left,\n\t\tmember: member,\n\t}\n\tr.init(c, v.LeftBracket)\n\treturn r\n}\n\nfunc (e *compiledDotExpr) emitGetter(putOnStack bool) {\n\te.left.emitGetter(true)\n\te.addSrcMap()\n\te.c.emit(getProp(e.name))\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledDotExpr) emitRef() {\n\te.left.emitGetter(true)\n\tif e.c.scope.strict {\n\t\te.c.emit(getPropRefStrict(e.name))\n\t} else {\n\t\te.c.emit(getPropRef(e.name))\n\t}\n}\n\nfunc (e *compiledDotExpr) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.left.emitGetter(true)\n\tvalueExpr.emitGetter(true)\n\te.addSrcMap()\n\tif e.c.scope.strict {\n\t\tif putOnStack {\n\t\t\te.c.emit(setPropStrict(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropStrictP(e.name))\n\t\t}\n\t} else {\n\t\tif putOnStack {\n\t\t\te.c.emit(setProp(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropP(e.name))\n\t\t}\n\t}\n}\n\nfunc (e *compiledDotExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\tif !putOnStack {\n\t\te.left.emitGetter(true)\n\t\te.c.emit(dup)\n\t\te.c.emit(getProp(e.name))\n\t\tbody()\n\t\te.addSrcMap()\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setPropStrictP(e.name))\n\t\t} else {\n\t\t\te.c.emit(setPropP(e.name))\n\t\t}\n\t} else {\n\t\tif !postfix {\n\t\t\te.left.emitGetter(true)\n\t\t\te.c.emit(dup)\n\t\t\te.c.emit(getProp(e.name))\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setPropStrict(e.name))\n\t\t\t} else {\n\t\t\t\te.c.emit(setProp(e.name))\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emit(loadUndef)\n\t\t\te.left.emitGetter(true)\n\t\t\te.c.emit(dup)\n\t\t\te.c.emit(getProp(e.name))\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\te.c.emit(rdupN(2))\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setPropStrictP(e.name))\n\t\t\t} else {\n\t\t\t\te.c.emit(setPropP(e.name))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *compiledDotExpr) deleteExpr() compiledExpr {\n\tr := &deletePropExpr{\n\t\tleft: e.left,\n\t\tname: e.name,\n\t}\n\tr.init(e.c, file.Idx(e.offset)+1)\n\treturn r\n}\n\nfunc (e *compiledBracketExpr) emitGetter(putOnStack bool) {\n\te.left.emitGetter(true)\n\te.member.emitGetter(true)\n\te.addSrcMap()\n\te.c.emit(getElem)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledBracketExpr) emitRef() {\n\te.left.emitGetter(true)\n\te.member.emitGetter(true)\n\tif e.c.scope.strict {\n\t\te.c.emit(getElemRefStrict)\n\t} else {\n\t\te.c.emit(getElemRef)\n\t}\n}\n\nfunc (e *compiledBracketExpr) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\te.left.emitGetter(true)\n\te.member.emitGetter(true)\n\tvalueExpr.emitGetter(true)\n\te.addSrcMap()\n\tif e.c.scope.strict {\n\t\tif putOnStack {\n\t\t\te.c.emit(setElemStrict)\n\t\t} else {\n\t\t\te.c.emit(setElemStrictP)\n\t\t}\n\t} else {\n\t\tif putOnStack {\n\t\t\te.c.emit(setElem)\n\t\t} else {\n\t\t\te.c.emit(setElemP)\n\t\t}\n\t}\n}\n\nfunc (e *compiledBracketExpr) emitUnary(prepare, body func(), postfix, putOnStack bool) {\n\tif !putOnStack {\n\t\te.left.emitGetter(true)\n\t\te.member.emitGetter(true)\n\t\te.c.emit(dupLast(2), getElem)\n\t\tbody()\n\t\te.addSrcMap()\n\t\tif e.c.scope.strict {\n\t\t\te.c.emit(setElemStrict, pop)\n\t\t} else {\n\t\t\te.c.emit(setElem, pop)\n\t\t}\n\t} else {\n\t\tif !postfix {\n\t\t\te.left.emitGetter(true)\n\t\t\te.member.emitGetter(true)\n\t\t\te.c.emit(dupLast(2), getElem)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setElemStrict)\n\t\t\t} else {\n\t\t\t\te.c.emit(setElem)\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emit(loadUndef)\n\t\t\te.left.emitGetter(true)\n\t\t\te.member.emitGetter(true)\n\t\t\te.c.emit(dupLast(2), getElem)\n\t\t\tif prepare != nil {\n\t\t\t\tprepare()\n\t\t\t}\n\t\t\te.c.emit(rdupN(3))\n\t\t\tbody()\n\t\t\te.addSrcMap()\n\t\t\tif e.c.scope.strict {\n\t\t\t\te.c.emit(setElemStrict, pop)\n\t\t\t} else {\n\t\t\t\te.c.emit(setElem, pop)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *compiledBracketExpr) deleteExpr() compiledExpr {\n\tr := &deleteElemExpr{\n\t\tleft:   e.left,\n\t\tmember: e.member,\n\t}\n\tr.init(e.c, file.Idx(e.offset)+1)\n\treturn r\n}\n\nfunc (e *deleteElemExpr) emitGetter(putOnStack bool) {\n\te.left.emitGetter(true)\n\te.member.emitGetter(true)\n\te.addSrcMap()\n\tif e.c.scope.strict {\n\t\te.c.emit(deleteElemStrict)\n\t} else {\n\t\te.c.emit(deleteElem)\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *deletePropExpr) emitGetter(putOnStack bool) {\n\te.left.emitGetter(true)\n\te.addSrcMap()\n\tif e.c.scope.strict {\n\t\te.c.emit(deletePropStrict(e.name))\n\t} else {\n\t\te.c.emit(deleteProp(e.name))\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *deleteVarExpr) emitGetter(putOnStack bool) {\n\t/*if e.c.scope.strict {\n\t\te.c.throwSyntaxError(e.offset, \"Delete of an unqualified identifier in strict mode\")\n\t\treturn\n\t}*/\n\te.c.emit(deleteVar(e.name))\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *deleteGlobalExpr) emitGetter(putOnStack bool) {\n\t/*if e.c.scope.strict {\n\t\te.c.throwSyntaxError(e.offset, \"Delete of an unqualified identifier in strict mode\")\n\t\treturn\n\t}*/\n\n\te.c.emit(deleteGlobal(e.name))\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledAssignExpr) emitGetter(putOnStack bool) {\n\tswitch e.operator {\n\tcase token.ASSIGN:\n\t\te.left.emitSetter(e.right, putOnStack)\n\tcase token.PLUS:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(add)\n\t\t}, false, putOnStack)\n\tcase token.MINUS:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(sub)\n\t\t}, false, putOnStack)\n\tcase token.MULTIPLY:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(mul)\n\t\t}, false, putOnStack)\n\tcase token.EXPONENT:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(exp)\n\t\t}, false, putOnStack)\n\tcase token.SLASH:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(div)\n\t\t}, false, putOnStack)\n\tcase token.REMAINDER:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(mod)\n\t\t}, false, putOnStack)\n\tcase token.OR:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(or)\n\t\t}, false, putOnStack)\n\tcase token.AND:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(and)\n\t\t}, false, putOnStack)\n\tcase token.EXCLUSIVE_OR:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(xor)\n\t\t}, false, putOnStack)\n\tcase token.SHIFT_LEFT:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(sal)\n\t\t}, false, putOnStack)\n\tcase token.SHIFT_RIGHT:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(sar)\n\t\t}, false, putOnStack)\n\tcase token.UNSIGNED_SHIFT_RIGHT:\n\t\te.left.emitUnary(nil, func() {\n\t\t\te.right.emitGetter(true)\n\t\t\te.c.emit(shr)\n\t\t}, false, putOnStack)\n\tdefault:\n\t\te.c.assert(false, e.offset, \"Unknown assign operator: %s\", e.operator.String())\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (e *compiledLiteral) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\te.c.emitLiteralValue(e.val)\n\t}\n}\n\nfunc (e *compiledLiteral) constant() bool {\n\treturn true\n}\n\nfunc (e *compiledTemplateLiteral) emitGetter(putOnStack bool) {\n\tif e.tag == nil {\n\t\tif len(e.elements) == 0 {\n\t\t\te.c.emitLiteralString(stringEmpty)\n\t\t} else {\n\t\t\ttail := e.elements[len(e.elements)-1].Parsed\n\t\t\tif len(e.elements) == 1 {\n\t\t\t\te.c.emitLiteralString(stringValueFromRaw(tail))\n\t\t\t} else {\n\t\t\t\tstringCount := 0\n\t\t\t\tif head := e.elements[0].Parsed; head != \"\" {\n\t\t\t\t\te.c.emitLiteralString(stringValueFromRaw(head))\n\t\t\t\t\tstringCount++\n\t\t\t\t}\n\t\t\t\te.expressions[0].emitGetter(true)\n\t\t\t\te.c.emit(_toString{})\n\t\t\t\tstringCount++\n\t\t\t\tfor i := 1; i < len(e.elements)-1; i++ {\n\t\t\t\t\tif elt := e.elements[i].Parsed; elt != \"\" {\n\t\t\t\t\t\te.c.emitLiteralString(stringValueFromRaw(elt))\n\t\t\t\t\t\tstringCount++\n\t\t\t\t\t}\n\t\t\t\t\te.expressions[i].emitGetter(true)\n\t\t\t\t\te.c.emit(_toString{})\n\t\t\t\t\tstringCount++\n\t\t\t\t}\n\t\t\t\tif tail != \"\" {\n\t\t\t\t\te.c.emitLiteralString(stringValueFromRaw(tail))\n\t\t\t\t\tstringCount++\n\t\t\t\t}\n\t\t\t\te.c.emit(concatStrings(stringCount))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcooked := make([]Value, len(e.elements))\n\t\traw := make([]Value, len(e.elements))\n\t\tfor i, elt := range e.elements {\n\t\t\traw[i] = &valueProperty{\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue:      newStringValue(elt.Literal),\n\t\t\t}\n\t\t\tvar cookedVal Value\n\t\t\tif elt.Valid {\n\t\t\t\tcookedVal = stringValueFromRaw(elt.Parsed)\n\t\t\t} else {\n\t\t\t\tcookedVal = _undefined\n\t\t\t}\n\t\t\tcooked[i] = &valueProperty{\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue:      cookedVal,\n\t\t\t}\n\t\t}\n\t\te.c.emitCallee(e.tag)\n\t\te.c.emit(&getTaggedTmplObject{\n\t\t\traw:    raw,\n\t\t\tcooked: cooked,\n\t\t})\n\t\tfor _, expr := range e.expressions {\n\t\t\texpr.emitGetter(true)\n\t\t}\n\t\te.c.emit(call(len(e.expressions) + 1))\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileParameterBindingIdentifier(name unistring.String, offset int) (*binding, bool) {\n\tif c.scope.strict {\n\t\tc.checkIdentifierName(name, offset)\n\t\tc.checkIdentifierLName(name, offset)\n\t}\n\treturn c.scope.bindNameShadow(name)\n}\n\nfunc (c *compiler) compileParameterPatternIdBinding(name unistring.String, offset int) {\n\tif _, unique := c.compileParameterBindingIdentifier(name, offset); !unique {\n\t\tc.throwSyntaxError(offset, \"Duplicate parameter name not allowed in this context\")\n\t}\n}\n\nfunc (c *compiler) compileParameterPatternBinding(item ast.Expression) {\n\tc.createBindings(item, c.compileParameterPatternIdBinding)\n}\n\nfunc (c *compiler) newCode(length, minCap int) (buf []instruction) {\n\tif c.codeScratchpad != nil {\n\t\tbuf = c.codeScratchpad\n\t\tc.codeScratchpad = nil\n\t}\n\tif cap(buf) < minCap {\n\t\tbuf = make([]instruction, length, minCap)\n\t} else {\n\t\tbuf = buf[:length]\n\t}\n\treturn\n}\n\nfunc (e *compiledFunctionLiteral) compile() (prg *Program, name unistring.String, length int, strict bool) {\n\te.c.assert(e.typ != funcNone, e.offset, \"compiledFunctionLiteral.typ is not set\")\n\n\tsavedPrg := e.c.p\n\tpreambleLen := 8 // enter, boxThis, loadStack(0), initThis, createArgs, set, loadCallee, init\n\te.c.p = &Program{\n\t\tsrc:    e.c.p.src,\n\t\tcode:   e.c.newCode(preambleLen, 16),\n\t\tsrcMap: []srcMapItem{{srcPos: e.offset}},\n\t}\n\te.c.newScope()\n\ts := e.c.scope\n\ts.funcType = e.typ\n\n\tif e.name != nil {\n\t\tname = e.name.Name\n\t} else {\n\t\tname = e.lhsName\n\t}\n\n\tif name != \"\" {\n\t\te.c.p.funcName = name\n\t}\n\tsavedBlock := e.c.block\n\tdefer func() {\n\t\te.c.block = savedBlock\n\t}()\n\n\te.c.block = &block{\n\t\ttyp: blockScope,\n\t}\n\n\tif !s.strict {\n\t\ts.strict = e.strict != nil\n\t}\n\n\thasPatterns := false\n\thasInits := false\n\tfirstDupIdx := -1\n\n\tif e.parameterList.Rest != nil {\n\t\thasPatterns = true // strictly speaking not, but we need to activate all the checks\n\t}\n\n\t// First, make sure that the first bindings correspond to the formal parameters\n\tfor _, item := range e.parameterList.List {\n\t\tswitch tgt := item.Target.(type) {\n\t\tcase *ast.Identifier:\n\t\t\toffset := int(tgt.Idx) - 1\n\t\t\tb, unique := e.c.compileParameterBindingIdentifier(tgt.Name, offset)\n\t\t\tif !unique {\n\t\t\t\tfirstDupIdx = offset\n\t\t\t}\n\t\t\tb.isArg = true\n\t\tcase ast.Pattern:\n\t\t\tb := s.addBinding(int(item.Idx0()) - 1)\n\t\t\tb.isArg = true\n\t\t\thasPatterns = true\n\t\tdefault:\n\t\t\te.c.throwSyntaxError(int(item.Idx0())-1, \"Unsupported BindingElement type: %T\", item)\n\t\t\treturn\n\t\t}\n\t\tif item.Initializer != nil {\n\t\t\thasInits = true\n\t\t}\n\n\t\tif firstDupIdx >= 0 && (hasPatterns || hasInits || s.strict || e.typ == funcArrow || e.typ == funcMethod) {\n\t\t\te.c.throwSyntaxError(firstDupIdx, \"Duplicate parameter name not allowed in this context\")\n\t\t\treturn\n\t\t}\n\n\t\tif (hasPatterns || hasInits) && e.strict != nil {\n\t\t\te.c.throwSyntaxError(int(e.strict.Idx)-1, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n\t\t\treturn\n\t\t}\n\n\t\tif !hasInits {\n\t\t\tlength++\n\t\t}\n\t}\n\n\tvar thisBinding *binding\n\tif e.typ != funcArrow {\n\t\tthisBinding = s.createThisBinding()\n\t}\n\n\t// create pattern bindings\n\tif hasPatterns {\n\t\tfor _, item := range e.parameterList.List {\n\t\t\tswitch tgt := item.Target.(type) {\n\t\t\tcase *ast.Identifier:\n\t\t\t\t// we already created those in the previous loop, skipping\n\t\t\tdefault:\n\t\t\t\te.c.compileParameterPatternBinding(tgt)\n\t\t\t}\n\t\t}\n\t\tif rest := e.parameterList.Rest; rest != nil {\n\t\t\te.c.compileParameterPatternBinding(rest)\n\t\t}\n\t}\n\n\tparamsCount := len(e.parameterList.List)\n\n\ts.numArgs = paramsCount\n\tbody := e.body\n\tfuncs := e.c.extractFunctions(body)\n\tvar calleeBinding *binding\n\n\temitArgsRestMark := -1\n\tfirstForwardRef := -1\n\tenterFunc2Mark := -1\n\n\tif hasPatterns || hasInits {\n\t\tif e.isExpr && e.name != nil {\n\t\t\tif b, created := s.bindNameLexical(e.name.Name, false, 0); created {\n\t\t\t\tb.isConst = true\n\t\t\t\tcalleeBinding = b\n\t\t\t}\n\t\t}\n\t\tfor i, item := range e.parameterList.List {\n\t\t\tif pattern, ok := item.Target.(ast.Pattern); ok {\n\t\t\t\ti := i\n\t\t\t\te.c.compilePatternInitExpr(func() {\n\t\t\t\t\tif firstForwardRef == -1 {\n\t\t\t\t\t\ts.bindings[i].emitGet()\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.c.emit(loadStackLex(-i - 1))\n\t\t\t\t\t}\n\t\t\t\t}, item.Initializer, item.Target.Idx0()).emitGetter(true)\n\t\t\t\te.c.emitPattern(pattern, func(target, init compiledExpr) {\n\t\t\t\t\te.c.emitPatternLexicalAssign(target, init)\n\t\t\t\t}, false)\n\t\t\t} else if item.Initializer != nil {\n\t\t\t\tmarkGet := len(e.c.p.code)\n\t\t\t\te.c.emit(nil)\n\t\t\t\tmark := len(e.c.p.code)\n\t\t\t\te.c.emit(nil)\n\t\t\t\te.c.emitExpr(e.c.compileExpression(item.Initializer), true)\n\t\t\t\tif firstForwardRef == -1 && (s.isDynamic() || s.bindings[i].useCount() > 0) {\n\t\t\t\t\tfirstForwardRef = i\n\t\t\t\t}\n\t\t\t\tif firstForwardRef == -1 {\n\t\t\t\t\ts.bindings[i].emitGetAt(markGet)\n\t\t\t\t} else {\n\t\t\t\t\te.c.p.code[markGet] = loadStackLex(-i - 1)\n\t\t\t\t}\n\t\t\t\ts.bindings[i].emitInitP()\n\t\t\t\te.c.p.code[mark] = jdefP(len(e.c.p.code) - mark)\n\t\t\t} else {\n\t\t\t\tif firstForwardRef == -1 && s.bindings[i].useCount() > 0 {\n\t\t\t\t\tfirstForwardRef = i\n\t\t\t\t}\n\t\t\t\tif firstForwardRef != -1 {\n\t\t\t\t\te.c.emit(loadStackLex(-i - 1))\n\t\t\t\t\ts.bindings[i].emitInitP()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif rest := e.parameterList.Rest; rest != nil {\n\t\t\te.c.emitAssign(rest, e.c.compileEmitterExpr(\n\t\t\t\tfunc() {\n\t\t\t\t\temitArgsRestMark = len(e.c.p.code)\n\t\t\t\t\te.c.emit(createArgsRestStack(paramsCount))\n\t\t\t\t}, rest.Idx0()),\n\t\t\t\tfunc(target, init compiledExpr) {\n\t\t\t\t\te.c.emitPatternLexicalAssign(target, init)\n\t\t\t\t})\n\t\t}\n\t\tif firstForwardRef != -1 {\n\t\t\tfor _, b := range s.bindings {\n\t\t\t\tb.inStash = true\n\t\t\t}\n\t\t\ts.argsInStash = true\n\t\t\ts.needStash = true\n\t\t}\n\n\t\te.c.newBlockScope()\n\t\tvarScope := e.c.scope\n\t\tvarScope.variable = true\n\t\tenterFunc2Mark = len(e.c.p.code)\n\t\te.c.emit(nil)\n\t\te.c.compileDeclList(e.declarationList, false)\n\t\te.c.createFunctionBindings(funcs)\n\t\te.c.compileLexicalDeclarationsFuncBody(body, calleeBinding)\n\t\tfor _, b := range varScope.bindings {\n\t\t\tif b.isVar {\n\t\t\t\tif parentBinding := s.boundNames[b.name]; parentBinding != nil && parentBinding != calleeBinding {\n\t\t\t\t\tparentBinding.emitGet()\n\t\t\t\t\tb.emitSetP()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// To avoid triggering variable conflict when binding from non-strict direct eval().\n\t\t// Parameters are supposed to be in a parent scope, hence no conflict.\n\t\tfor _, b := range s.bindings[:paramsCount] {\n\t\t\tb.isVar = true\n\t\t}\n\t\te.c.compileDeclList(e.declarationList, true)\n\t\te.c.createFunctionBindings(funcs)\n\t\te.c.compileLexicalDeclarations(body, true)\n\t\tif e.isExpr && e.name != nil {\n\t\t\tif b, created := s.bindNameLexical(e.name.Name, false, 0); created {\n\t\t\t\tb.isConst = true\n\t\t\t\tcalleeBinding = b\n\t\t\t}\n\t\t}\n\t\tif calleeBinding != nil {\n\t\t\te.c.emit(loadCallee)\n\t\t\tcalleeBinding.emitInitP()\n\t\t}\n\t}\n\n\te.c.compileFunctions(funcs)\n\tif e.isGenerator {\n\t\te.c.emit(yieldEmpty)\n\t}\n\te.c.compileStatements(body, false)\n\n\tvar last ast.Statement\n\tif l := len(body); l > 0 {\n\t\tlast = body[l-1]\n\t}\n\tif _, ok := last.(*ast.ReturnStatement); !ok {\n\t\tif e.typ == funcDerivedCtor {\n\t\t\te.c.emit(loadUndef)\n\t\t\tthisBinding.markAccessPoint()\n\t\t\te.c.emit(ret)\n\t\t} else {\n\t\t\te.c.emit(loadUndef, ret)\n\t\t}\n\t}\n\n\tdelta := 0\n\tcode := e.c.p.code\n\n\tif s.isDynamic() && !s.argsInStash {\n\t\ts.moveArgsToStash()\n\t}\n\n\tif s.argsNeeded || s.isDynamic() && e.typ != funcArrow && e.typ != funcClsInit {\n\t\tif e.typ == funcClsInit {\n\t\t\te.c.throwSyntaxError(e.offset, \"'arguments' is not allowed in class field initializer or static initialization block\")\n\t\t}\n\t\tb, created := s.bindNameLexical(\"arguments\", false, 0)\n\t\tif created || b.isVar {\n\t\t\tif !s.argsInStash {\n\t\t\t\ts.moveArgsToStash()\n\t\t\t}\n\t\t\tif s.strict {\n\t\t\t\tb.isConst = true\n\t\t\t} else {\n\t\t\t\tb.isVar = e.c.scope.isFunction()\n\t\t\t}\n\t\t\tpos := preambleLen - 2\n\t\t\tdelta += 2\n\t\t\tif s.strict || hasPatterns || hasInits {\n\t\t\t\tcode[pos] = createArgsUnmapped(paramsCount)\n\t\t\t} else {\n\t\t\t\tcode[pos] = createArgsMapped(paramsCount)\n\t\t\t}\n\t\t\tpos++\n\t\t\tb.emitInitPAtScope(s, pos)\n\t\t}\n\t}\n\n\tif calleeBinding != nil {\n\t\tif !s.isDynamic() && calleeBinding.useCount() == 0 {\n\t\t\ts.deleteBinding(calleeBinding)\n\t\t\tcalleeBinding = nil\n\t\t} else {\n\t\t\tdelta++\n\t\t\tcalleeBinding.emitInitPAtScope(s, preambleLen-delta)\n\t\t\tdelta++\n\t\t\tcode[preambleLen-delta] = loadCallee\n\t\t}\n\t}\n\n\tif thisBinding != nil {\n\t\tif !s.isDynamic() && thisBinding.useCount() == 0 {\n\t\t\ts.deleteBinding(thisBinding)\n\t\t\tthisBinding = nil\n\t\t} else {\n\t\t\tif thisBinding.inStash || s.isDynamic() {\n\t\t\t\tdelta++\n\t\t\t\tthisBinding.emitInitAtScope(s, preambleLen-delta)\n\t\t\t}\n\t\t}\n\t}\n\n\tstashSize, stackSize := s.finaliseVarAlloc(0)\n\n\tif thisBinding != nil && thisBinding.inStash && (!s.argsInStash || stackSize > 0) {\n\t\tdelta++\n\t\tcode[preambleLen-delta] = loadStack(0)\n\t} // otherwise, 'this' will be at stack[sp-1], no need to load\n\n\tif !s.strict && thisBinding != nil {\n\t\tdelta++\n\t\tcode[preambleLen-delta] = boxThis\n\t}\n\tdelta++\n\tdelta = preambleLen - delta\n\tvar enter instruction\n\tif stashSize > 0 || s.argsInStash {\n\t\tif firstForwardRef == -1 {\n\t\t\tenter1 := enterFunc{\n\t\t\t\tnumArgs:     uint32(paramsCount),\n\t\t\t\targsToStash: s.argsInStash,\n\t\t\t\tstashSize:   uint32(stashSize),\n\t\t\t\tstackSize:   uint32(stackSize),\n\t\t\t\textensible:  s.dynamic,\n\t\t\t\tfuncType:    e.typ,\n\t\t\t}\n\t\t\tif s.isDynamic() {\n\t\t\t\tenter1.names = s.makeNamesMap()\n\t\t\t}\n\t\t\tenter = &enter1\n\t\t\tif enterFunc2Mark != -1 {\n\t\t\t\tef2 := &enterFuncBody{\n\t\t\t\t\textensible: e.c.scope.dynamic,\n\t\t\t\t\tfuncType:   e.typ,\n\t\t\t\t}\n\t\t\t\te.c.updateEnterBlock(&ef2.enterBlock)\n\t\t\t\te.c.p.code[enterFunc2Mark] = ef2\n\t\t\t}\n\t\t} else {\n\t\t\tenter1 := enterFunc1{\n\t\t\t\tstashSize:  uint32(stashSize),\n\t\t\t\tnumArgs:    uint32(paramsCount),\n\t\t\t\targsToCopy: uint32(firstForwardRef),\n\t\t\t\textensible: s.dynamic,\n\t\t\t\tfuncType:   e.typ,\n\t\t\t}\n\t\t\tif s.isDynamic() {\n\t\t\t\tenter1.names = s.makeNamesMap()\n\t\t\t}\n\t\t\tenter = &enter1\n\t\t\tif enterFunc2Mark != -1 {\n\t\t\t\tef2 := &enterFuncBody{\n\t\t\t\t\tadjustStack: true,\n\t\t\t\t\textensible:  e.c.scope.dynamic,\n\t\t\t\t\tfuncType:    e.typ,\n\t\t\t\t}\n\t\t\t\te.c.updateEnterBlock(&ef2.enterBlock)\n\t\t\t\te.c.p.code[enterFunc2Mark] = ef2\n\t\t\t}\n\t\t}\n\t\tif emitArgsRestMark != -1 && s.argsInStash {\n\t\t\te.c.p.code[emitArgsRestMark] = createArgsRestStash\n\t\t}\n\t} else {\n\t\tenter = &enterFuncStashless{\n\t\t\tstackSize: uint32(stackSize),\n\t\t\targs:      uint32(paramsCount),\n\t\t}\n\t\tif enterFunc2Mark != -1 {\n\t\t\tef2 := &enterFuncBody{\n\t\t\t\textensible: e.c.scope.dynamic,\n\t\t\t\tfuncType:   e.typ,\n\t\t\t}\n\t\t\te.c.updateEnterBlock(&ef2.enterBlock)\n\t\t\te.c.p.code[enterFunc2Mark] = ef2\n\t\t}\n\t}\n\tcode[delta] = enter\n\te.c.p.srcMap[0].pc = delta\n\ts.trimCode(delta)\n\n\tstrict = s.strict\n\tprg = e.c.p\n\t// e.c.p.dumpCode()\n\tif enterFunc2Mark != -1 {\n\t\te.c.popScope()\n\t}\n\te.c.popScope()\n\te.c.p = savedPrg\n\n\treturn\n}\n\nfunc (e *compiledFunctionLiteral) emitGetter(putOnStack bool) {\n\tp, name, length, strict := e.compile()\n\tswitch e.typ {\n\tcase funcArrow:\n\t\tif e.isAsync {\n\t\t\te.c.emit(&newAsyncArrowFunc{newArrowFunc: newArrowFunc{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}}})\n\t\t} else {\n\t\t\te.c.emit(&newArrowFunc{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}})\n\t\t}\n\tcase funcMethod, funcClsInit:\n\t\tif e.isAsync {\n\t\t\te.c.emit(&newAsyncMethod{newMethod: newMethod{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}, homeObjOffset: e.homeObjOffset}})\n\t\t} else {\n\t\t\tif e.isGenerator {\n\t\t\t\te.c.emit(&newGeneratorMethod{newMethod: newMethod{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}, homeObjOffset: e.homeObjOffset}})\n\t\t\t} else {\n\t\t\t\te.c.emit(&newMethod{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}, homeObjOffset: e.homeObjOffset})\n\t\t\t}\n\t\t}\n\tcase funcRegular:\n\t\tif e.isAsync {\n\t\t\te.c.emit(&newAsyncFunc{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}})\n\t\t} else {\n\t\t\tif e.isGenerator {\n\t\t\t\te.c.emit(&newGeneratorFunc{newFunc: newFunc{prg: p, length: length, name: name, source: e.source, strict: strict}})\n\t\t\t} else {\n\t\t\t\te.c.emit(&newFunc{prg: p, length: length, name: name, source: e.source, strict: strict})\n\t\t\t}\n\t\t}\n\tdefault:\n\t\te.c.throwSyntaxError(e.offset, \"Unsupported func type: %v\", e.typ)\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileFunctionLiteral(v *ast.FunctionLiteral, isExpr bool) *compiledFunctionLiteral {\n\tstrictBody := c.isStrictStatement(v.Body)\n\tif v.Name != nil && (c.scope.strict || strictBody != nil) {\n\t\tc.checkIdentifierName(v.Name.Name, int(v.Name.Idx)-1)\n\t\tc.checkIdentifierLName(v.Name.Name, int(v.Name.Idx)-1)\n\t}\n\tif v.Async && v.Generator {\n\t\tc.throwSyntaxError(int(v.Function)-1, \"Async generators are not supported yet\")\n\t}\n\tr := &compiledFunctionLiteral{\n\t\tname:            v.Name,\n\t\tparameterList:   v.ParameterList,\n\t\tbody:            v.Body.List,\n\t\tsource:          v.Source,\n\t\tdeclarationList: v.DeclarationList,\n\t\tisExpr:          isExpr,\n\t\ttyp:             funcRegular,\n\t\tstrict:          strictBody,\n\t\tisAsync:         v.Async,\n\t\tisGenerator:     v.Generator,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\ntype compiledClassLiteral struct {\n\tbaseCompiledExpr\n\tname       *ast.Identifier\n\tsuperClass compiledExpr\n\tbody       []ast.ClassElement\n\tlhsName    unistring.String\n\tsource     string\n\tisExpr     bool\n}\n\nfunc (c *compiler) processKey(expr ast.Expression) (val unistring.String, computed bool) {\n\tkeyExpr := c.compileExpression(expr)\n\tif keyExpr.constant() {\n\t\tv, ex := c.evalConst(keyExpr)\n\t\tif ex == nil {\n\t\t\treturn v.string(), false\n\t\t}\n\t}\n\tkeyExpr.emitGetter(true)\n\tcomputed = true\n\treturn\n}\n\nfunc (e *compiledClassLiteral) processClassKey(expr ast.Expression) (privateName *privateName, key unistring.String, computed bool) {\n\tif p, ok := expr.(*ast.PrivateIdentifier); ok {\n\t\tprivateName = e.c.classScope.getDeclaredPrivateId(p.Name)\n\t\tkey = privateIdString(p.Name)\n\t\treturn\n\t}\n\tkey, computed = e.c.processKey(expr)\n\treturn\n}\n\ntype clsElement struct {\n\tkey         unistring.String\n\tprivateName *privateName\n\tinitializer compiledExpr\n\tbody        *compiledFunctionLiteral\n\tcomputed    bool\n}\n\nfunc (e *compiledClassLiteral) emitGetter(putOnStack bool) {\n\te.c.newBlockScope()\n\ts := e.c.scope\n\ts.strict = true\n\n\tenter := &enterBlock{}\n\tmark0 := len(e.c.p.code)\n\te.c.emit(enter)\n\te.c.block = &block{\n\t\ttyp:   blockScope,\n\t\touter: e.c.block,\n\t}\n\tvar clsBinding *binding\n\tvar clsName unistring.String\n\tif name := e.name; name != nil {\n\t\tclsName = name.Name\n\t\tclsBinding = e.c.createLexicalIdBinding(clsName, true, int(name.Idx)-1)\n\t} else {\n\t\tclsName = e.lhsName\n\t}\n\n\tvar ctorMethod *ast.MethodDefinition\n\tctorMethodIdx := -1\n\tstaticsCount := 0\n\tinstanceFieldsCount := 0\n\thasStaticPrivateMethods := false\n\tcs := &classScope{\n\t\tc:     e.c,\n\t\touter: e.c.classScope,\n\t}\n\n\tfor idx, elt := range e.body {\n\t\tswitch elt := elt.(type) {\n\t\tcase *ast.ClassStaticBlock:\n\t\t\tif len(elt.Block.List) > 0 {\n\t\t\t\tstaticsCount++\n\t\t\t}\n\t\tcase *ast.FieldDefinition:\n\t\t\tif id, ok := elt.Key.(*ast.PrivateIdentifier); ok {\n\t\t\t\tcs.declarePrivateId(id.Name, ast.PropertyKindValue, elt.Static, int(elt.Idx)-1)\n\t\t\t}\n\t\t\tif elt.Static {\n\t\t\t\tstaticsCount++\n\t\t\t} else {\n\t\t\t\tinstanceFieldsCount++\n\t\t\t}\n\t\tcase *ast.MethodDefinition:\n\t\t\tif !elt.Static {\n\t\t\t\tif id, ok := elt.Key.(*ast.StringLiteral); ok {\n\t\t\t\t\tif !elt.Computed && id.Value == \"constructor\" {\n\t\t\t\t\t\tif ctorMethod != nil {\n\t\t\t\t\t\t\te.c.throwSyntaxError(int(id.Idx)-1, \"A class may only have one constructor\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctorMethod = elt\n\t\t\t\t\t\tctorMethodIdx = idx\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif id, ok := elt.Key.(*ast.PrivateIdentifier); ok {\n\t\t\t\tcs.declarePrivateId(id.Name, elt.Kind, elt.Static, int(elt.Idx)-1)\n\t\t\t\tif elt.Static {\n\t\t\t\t\thasStaticPrivateMethods = true\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\te.c.assert(false, int(elt.Idx0())-1, \"Unsupported static element: %T\", elt)\n\t\t}\n\t}\n\n\tvar staticInit *newStaticFieldInit\n\tif staticsCount > 0 || hasStaticPrivateMethods {\n\t\tstaticInit = &newStaticFieldInit{}\n\t\te.c.emit(staticInit)\n\t}\n\n\tvar derived bool\n\tvar newClassIns *newClass\n\tif superClass := e.superClass; superClass != nil {\n\t\tderived = true\n\t\tsuperClass.emitGetter(true)\n\t\tndc := &newDerivedClass{\n\t\t\tnewClass: newClass{\n\t\t\t\tname:   clsName,\n\t\t\t\tsource: e.source,\n\t\t\t},\n\t\t}\n\t\te.addSrcMap()\n\t\te.c.emit(ndc)\n\t\tnewClassIns = &ndc.newClass\n\t} else {\n\t\tnewClassIns = &newClass{\n\t\t\tname:   clsName,\n\t\t\tsource: e.source,\n\t\t}\n\t\te.addSrcMap()\n\t\te.c.emit(newClassIns)\n\t}\n\n\te.c.classScope = cs\n\n\tif ctorMethod != nil {\n\t\tnewClassIns.ctor, newClassIns.length = e.c.compileCtor(ctorMethod.Body, derived)\n\t}\n\n\tcurIsPrototype := false\n\n\tinstanceFields := make([]clsElement, 0, instanceFieldsCount)\n\tstaticElements := make([]clsElement, 0, staticsCount)\n\n\t// stack at this point:\n\t//\n\t// staticFieldInit (if staticsCount > 0 || hasStaticPrivateMethods)\n\t// prototype\n\t// class function\n\t// <- sp\n\n\tfor idx, elt := range e.body {\n\t\tif idx == ctorMethodIdx {\n\t\t\tcontinue\n\t\t}\n\t\tswitch elt := elt.(type) {\n\t\tcase *ast.ClassStaticBlock:\n\t\t\tif len(elt.Block.List) > 0 {\n\t\t\t\tf := e.c.compileFunctionLiteral(&ast.FunctionLiteral{\n\t\t\t\t\tFunction:        elt.Idx0(),\n\t\t\t\t\tParameterList:   &ast.ParameterList{},\n\t\t\t\t\tBody:            elt.Block,\n\t\t\t\t\tSource:          elt.Source,\n\t\t\t\t\tDeclarationList: elt.DeclarationList,\n\t\t\t\t}, true)\n\t\t\t\tf.typ = funcClsInit\n\t\t\t\t//f.lhsName = \"<static_initializer>\"\n\t\t\t\tf.homeObjOffset = 1\n\t\t\t\tstaticElements = append(staticElements, clsElement{\n\t\t\t\t\tbody: f,\n\t\t\t\t})\n\t\t\t}\n\t\tcase *ast.FieldDefinition:\n\t\t\tprivateName, key, computed := e.processClassKey(elt.Key)\n\t\t\tvar el clsElement\n\t\t\tif elt.Initializer != nil {\n\t\t\t\tel.initializer = e.c.compileExpression(elt.Initializer)\n\t\t\t}\n\t\t\tel.computed = computed\n\t\t\tif computed {\n\t\t\t\tif elt.Static {\n\t\t\t\t\tif curIsPrototype {\n\t\t\t\t\t\te.c.emit(defineComputedKey(5))\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.c.emit(defineComputedKey(4))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif curIsPrototype {\n\t\t\t\t\t\te.c.emit(defineComputedKey(3))\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.c.emit(defineComputedKey(2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.privateName = privateName\n\t\t\t\tel.key = key\n\t\t\t}\n\t\t\tif elt.Static {\n\t\t\t\tstaticElements = append(staticElements, el)\n\t\t\t} else {\n\t\t\t\tinstanceFields = append(instanceFields, el)\n\t\t\t}\n\t\tcase *ast.MethodDefinition:\n\t\t\tif elt.Static {\n\t\t\t\tif curIsPrototype {\n\t\t\t\t\te.c.emit(pop)\n\t\t\t\t\tcurIsPrototype = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !curIsPrototype {\n\t\t\t\t\te.c.emit(dupN(1))\n\t\t\t\t\tcurIsPrototype = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivateName, key, computed := e.processClassKey(elt.Key)\n\t\t\tlit := e.c.compileFunctionLiteral(elt.Body, true)\n\t\t\tlit.typ = funcMethod\n\t\t\tif computed {\n\t\t\t\te.c.emit(_toPropertyKey{})\n\t\t\t\tlit.homeObjOffset = 2\n\t\t\t} else {\n\t\t\t\tlit.homeObjOffset = 1\n\t\t\t\tlit.lhsName = key\n\t\t\t}\n\t\t\tlit.emitGetter(true)\n\t\t\tif privateName != nil {\n\t\t\t\tvar offset int\n\t\t\t\tif elt.Static {\n\t\t\t\t\tif curIsPrototype {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tstaticInit\n\t\t\t\t\t\t\tproto\n\t\t\t\t\t\t\tcls\n\t\t\t\t\t\t\tproto\n\t\t\t\t\t\t\tmethod\n\t\t\t\t\t\t\t<- sp\n\t\t\t\t\t\t*/\n\t\t\t\t\t\toffset = 5\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tstaticInit\n\t\t\t\t\t\t\tproto\n\t\t\t\t\t\t\tcls\n\t\t\t\t\t\t\tmethod\n\t\t\t\t\t\t\t<- sp\n\t\t\t\t\t\t*/\n\t\t\t\t\t\toffset = 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif curIsPrototype {\n\t\t\t\t\t\toffset = 3\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitch elt.Kind {\n\t\t\t\tcase ast.PropertyKindGet:\n\t\t\t\t\te.c.emit(&definePrivateGetter{\n\t\t\t\t\t\tdefinePrivateMethod: definePrivateMethod{\n\t\t\t\t\t\t\tidx:          privateName.idx,\n\t\t\t\t\t\t\ttargetOffset: offset,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\tcase ast.PropertyKindSet:\n\t\t\t\t\te.c.emit(&definePrivateSetter{\n\t\t\t\t\t\tdefinePrivateMethod: definePrivateMethod{\n\t\t\t\t\t\t\tidx:          privateName.idx,\n\t\t\t\t\t\t\ttargetOffset: offset,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\tdefault:\n\t\t\t\t\te.c.emit(&definePrivateMethod{\n\t\t\t\t\t\tidx:          privateName.idx,\n\t\t\t\t\t\ttargetOffset: offset,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if computed {\n\t\t\t\tswitch elt.Kind {\n\t\t\t\tcase ast.PropertyKindGet:\n\t\t\t\t\te.c.emit(&defineGetter{})\n\t\t\t\tcase ast.PropertyKindSet:\n\t\t\t\t\te.c.emit(&defineSetter{})\n\t\t\t\tdefault:\n\t\t\t\t\te.c.emit(&defineMethod{})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch elt.Kind {\n\t\t\t\tcase ast.PropertyKindGet:\n\t\t\t\t\te.c.emit(&defineGetterKeyed{key: key})\n\t\t\t\tcase ast.PropertyKindSet:\n\t\t\t\t\te.c.emit(&defineSetterKeyed{key: key})\n\t\t\t\tdefault:\n\t\t\t\t\te.c.emit(&defineMethodKeyed{key: key})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif curIsPrototype {\n\t\te.c.emit(pop)\n\t}\n\n\tif len(instanceFields) > 0 {\n\t\tnewClassIns.initFields = e.compileFieldsAndStaticBlocks(instanceFields, \"<instance_members_initializer>\")\n\t}\n\tif staticInit != nil {\n\t\tif len(staticElements) > 0 {\n\t\t\tstaticInit.initFields = e.compileFieldsAndStaticBlocks(staticElements, \"<static_initializer>\")\n\t\t}\n\t}\n\n\tenv := e.c.classScope.instanceEnv\n\tif s.dynLookup {\n\t\tnewClassIns.privateMethods, newClassIns.privateFields = env.methods, env.fields\n\t}\n\tnewClassIns.numPrivateMethods = uint32(len(env.methods))\n\tnewClassIns.numPrivateFields = uint32(len(env.fields))\n\tnewClassIns.hasPrivateEnv = len(e.c.classScope.privateNames) > 0\n\n\tif (clsBinding != nil && clsBinding.useCount() > 0) || s.dynLookup {\n\t\tif clsBinding != nil {\n\t\t\t// Because this block may be in the middle of an expression, its initial stack position\n\t\t\t// cannot be known, and therefore it may not have any stack variables.\n\t\t\t// Note, because clsBinding would be accessed through a function, it should already be in stash,\n\t\t\t// this is just to make sure.\n\t\t\tclsBinding.moveToStash()\n\t\t\tclsBinding.emitInit()\n\t\t}\n\t} else {\n\t\tif clsBinding != nil {\n\t\t\ts.deleteBinding(clsBinding)\n\t\t\tclsBinding = nil\n\t\t}\n\t\te.c.p.code[mark0] = jump(1)\n\t}\n\n\tif staticsCount > 0 || hasStaticPrivateMethods {\n\t\tise := &initStaticElements{}\n\t\te.c.emit(ise)\n\t\tenv := e.c.classScope.staticEnv\n\t\tstaticInit.numPrivateFields = uint32(len(env.fields))\n\t\tstaticInit.numPrivateMethods = uint32(len(env.methods))\n\t\tif s.dynLookup {\n\t\t\t// These cannot be set on staticInit, because it is executed before ClassHeritage, and therefore\n\t\t\t// the VM's PrivateEnvironment is still not set.\n\t\t\tise.privateFields = env.fields\n\t\t\tise.privateMethods = env.methods\n\t\t}\n\t} else {\n\t\te.c.emit(endVariadic) // re-using as semantics match\n\t}\n\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n\n\tif clsBinding != nil || s.dynLookup {\n\t\te.c.leaveScopeBlock(enter)\n\t\te.c.assert(enter.stackSize == 0, e.offset, \"enter.StackSize != 0 in compiledClassLiteral\")\n\t} else {\n\t\te.c.block = e.c.block.outer\n\t}\n\tif len(e.c.classScope.privateNames) > 0 {\n\t\te.c.emit(popPrivateEnv{})\n\t}\n\te.c.classScope = e.c.classScope.outer\n\te.c.popScope()\n}\n\nfunc (e *compiledClassLiteral) compileFieldsAndStaticBlocks(elements []clsElement, funcName unistring.String) *Program {\n\tsavedPrg := e.c.p\n\tsavedBlock := e.c.block\n\tdefer func() {\n\t\te.c.p = savedPrg\n\t\te.c.block = savedBlock\n\t}()\n\n\te.c.block = &block{\n\t\ttyp: blockScope,\n\t}\n\n\te.c.p = &Program{\n\t\tsrc:      savedPrg.src,\n\t\tfuncName: funcName,\n\t\tcode:     e.c.newCode(2, 16),\n\t}\n\n\te.c.newScope()\n\ts := e.c.scope\n\ts.funcType = funcClsInit\n\tthisBinding := s.createThisBinding()\n\n\tvalIdx := 0\n\tfor _, elt := range elements {\n\t\tif elt.body != nil {\n\t\t\te.c.emit(dup) // this\n\t\t\telt.body.emitGetter(true)\n\t\t\telt.body.addSrcMap()\n\t\t\te.c.emit(call(0), pop)\n\t\t} else {\n\t\t\tif elt.computed {\n\t\t\t\te.c.emit(loadComputedKey(valIdx))\n\t\t\t\tvalIdx++\n\t\t\t}\n\t\t\tif init := elt.initializer; init != nil {\n\t\t\t\tif !elt.computed {\n\t\t\t\t\te.c.emitNamedOrConst(init, elt.key)\n\t\t\t\t} else {\n\t\t\t\t\te.c.emitExpr(init, true)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\te.c.emit(loadUndef)\n\t\t\t}\n\t\t\tif elt.privateName != nil {\n\t\t\t\te.c.emit(&definePrivateProp{\n\t\t\t\t\tidx: elt.privateName.idx,\n\t\t\t\t})\n\t\t\t} else if elt.computed {\n\t\t\t\te.c.emit(defineProp{})\n\t\t\t} else {\n\t\t\t\te.c.emit(definePropKeyed(elt.key))\n\t\t\t}\n\t\t}\n\t}\n\t//e.c.emit(halt)\n\tif s.isDynamic() || thisBinding.useCount() > 0 {\n\t\tif s.isDynamic() || thisBinding.inStash {\n\t\t\tthisBinding.emitInitAt(1)\n\t\t}\n\t} else {\n\t\ts.deleteBinding(thisBinding)\n\t}\n\tstashSize, stackSize := s.finaliseVarAlloc(0)\n\te.c.assert(stackSize == 0, e.offset, \"stackSize != 0 in initFields\")\n\tif stashSize > 0 {\n\t\te.c.assert(stashSize == 1, e.offset, \"stashSize != 1 in initFields\")\n\t\tenter := &enterFunc{\n\t\t\tstashSize: 1,\n\t\t\tfuncType:  funcClsInit,\n\t\t}\n\t\tif s.dynLookup {\n\t\t\tenter.names = s.makeNamesMap()\n\t\t}\n\t\te.c.p.code[0] = enter\n\t\ts.trimCode(0)\n\t} else {\n\t\ts.trimCode(2)\n\t}\n\tres := e.c.p\n\te.c.popScope()\n\treturn res\n}\n\nfunc (c *compiler) compileClassLiteral(v *ast.ClassLiteral, isExpr bool) *compiledClassLiteral {\n\tif v.Name != nil {\n\t\tc.checkIdentifierLName(v.Name.Name, int(v.Name.Idx)-1)\n\t}\n\tr := &compiledClassLiteral{\n\t\tname:       v.Name,\n\t\tsuperClass: c.compileExpression(v.SuperClass),\n\t\tbody:       v.Body,\n\t\tsource:     v.Source,\n\t\tisExpr:     isExpr,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileCtor(ctor *ast.FunctionLiteral, derived bool) (p *Program, length int) {\n\tf := c.compileFunctionLiteral(ctor, true)\n\tif derived {\n\t\tf.typ = funcDerivedCtor\n\t} else {\n\t\tf.typ = funcCtor\n\t}\n\tp, _, length, _ = f.compile()\n\treturn\n}\n\nfunc (c *compiler) compileArrowFunctionLiteral(v *ast.ArrowFunctionLiteral) *compiledFunctionLiteral {\n\tvar strictBody *ast.StringLiteral\n\tvar body []ast.Statement\n\tswitch b := v.Body.(type) {\n\tcase *ast.BlockStatement:\n\t\tstrictBody = c.isStrictStatement(b)\n\t\tbody = b.List\n\tcase *ast.ExpressionBody:\n\t\tbody = []ast.Statement{\n\t\t\t&ast.ReturnStatement{\n\t\t\t\tArgument: b.Expression,\n\t\t\t},\n\t\t}\n\tdefault:\n\t\tc.throwSyntaxError(int(b.Idx0())-1, \"Unsupported ConciseBody type: %T\", b)\n\t}\n\tr := &compiledFunctionLiteral{\n\t\tparameterList:   v.ParameterList,\n\t\tbody:            body,\n\t\tsource:          v.Source,\n\t\tdeclarationList: v.DeclarationList,\n\t\tisExpr:          true,\n\t\ttyp:             funcArrow,\n\t\tstrict:          strictBody,\n\t\tisAsync:         v.Async,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) emitLoadThis() {\n\tb, eval := c.scope.lookupThis()\n\tif b != nil {\n\t\tb.emitGet()\n\t} else {\n\t\tif eval {\n\t\t\tc.emit(getThisDynamic{})\n\t\t} else {\n\t\t\tc.emit(loadGlobalObject)\n\t\t}\n\t}\n}\n\nfunc (e *compiledThisExpr) emitGetter(putOnStack bool) {\n\te.addSrcMap()\n\te.c.emitLoadThis()\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledSuperExpr) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\te.c.emit(loadSuper)\n\t}\n}\n\nfunc (e *compiledNewExpr) emitGetter(putOnStack bool) {\n\tif e.isVariadic {\n\t\te.c.emit(startVariadic)\n\t}\n\te.callee.emitGetter(true)\n\tfor _, expr := range e.args {\n\t\texpr.emitGetter(true)\n\t}\n\te.addSrcMap()\n\tif e.isVariadic {\n\t\te.c.emit(newVariadic, endVariadic)\n\t} else {\n\t\te.c.emit(_new(len(e.args)))\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileCallArgs(list []ast.Expression) (args []compiledExpr, isVariadic bool) {\n\targs = make([]compiledExpr, len(list))\n\tfor i, argExpr := range list {\n\t\tif spread, ok := argExpr.(*ast.SpreadElement); ok {\n\t\t\targs[i] = c.compileSpreadCallArgument(spread)\n\t\t\tisVariadic = true\n\t\t} else {\n\t\t\targs[i] = c.compileExpression(argExpr)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (c *compiler) compileNewExpression(v *ast.NewExpression) compiledExpr {\n\targs, isVariadic := c.compileCallArgs(v.ArgumentList)\n\tr := &compiledNewExpr{\n\t\tcompiledCallExpr: compiledCallExpr{\n\t\t\tcallee:     c.compileExpression(v.Callee),\n\t\t\targs:       args,\n\t\t\tisVariadic: isVariadic,\n\t\t},\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledNewTarget) emitGetter(putOnStack bool) {\n\tif s := e.c.scope.nearestThis(); s == nil || s.funcType == funcNone {\n\t\te.c.throwSyntaxError(e.offset, \"new.target expression is not allowed here\")\n\t}\n\tif putOnStack {\n\t\te.addSrcMap()\n\t\te.c.emit(loadNewTarget)\n\t}\n}\n\nfunc (c *compiler) compileMetaProperty(v *ast.MetaProperty) compiledExpr {\n\tif v.Meta.Name == \"new\" || v.Property.Name != \"target\" {\n\t\tr := &compiledNewTarget{}\n\t\tr.init(c, v.Idx0())\n\t\treturn r\n\t}\n\tc.throwSyntaxError(int(v.Idx)-1, \"Unsupported meta property: %s.%s\", v.Meta.Name, v.Property.Name)\n\treturn nil\n}\n\nfunc (e *compiledSequenceExpr) emitGetter(putOnStack bool) {\n\tif len(e.sequence) > 0 {\n\t\tfor i := 0; i < len(e.sequence)-1; i++ {\n\t\t\te.sequence[i].emitGetter(false)\n\t\t}\n\t\te.sequence[len(e.sequence)-1].emitGetter(putOnStack)\n\t}\n}\n\nfunc (c *compiler) compileSequenceExpression(v *ast.SequenceExpression) compiledExpr {\n\ts := make([]compiledExpr, len(v.Sequence))\n\tfor i, expr := range v.Sequence {\n\t\ts[i] = c.compileExpression(expr)\n\t}\n\tr := &compiledSequenceExpr{\n\t\tsequence: s,\n\t}\n\tvar idx file.Idx\n\tif len(v.Sequence) > 0 {\n\t\tidx = v.Idx0()\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (c *compiler) emitThrow(v Value) {\n\tif o, ok := v.(*Object); ok {\n\t\tt := nilSafe(o.self.getStr(\"name\", nil)).toString().String()\n\t\tswitch t {\n\t\tcase \"TypeError\", \"RangeError\":\n\t\t\tc.emit(loadDynamic(t))\n\t\t\tmsg := o.self.getStr(\"message\", nil)\n\t\t\tif msg != nil {\n\t\t\t\tc.emitLiteralValue(msg)\n\t\t\t\tc.emit(_new(1))\n\t\t\t} else {\n\t\t\t\tc.emit(_new(0))\n\t\t\t}\n\t\t\tc.emit(throw)\n\t\t\treturn\n\t\t}\n\t}\n\tc.assert(false, 0, \"unknown exception type thrown while evaluating constant expression: %s\", v.String())\n\tpanic(\"unreachable\")\n}\n\nfunc (c *compiler) emitConst(expr compiledExpr, putOnStack bool) {\n\tv, ex := c.evalConst(expr)\n\tif ex == nil {\n\t\tif putOnStack {\n\t\t\tc.emitLiteralValue(v)\n\t\t}\n\t} else {\n\t\tc.emitThrow(ex.val)\n\t}\n}\n\nfunc (c *compiler) evalConst(expr compiledExpr) (Value, *Exception) {\n\tif expr, ok := expr.(*compiledLiteral); ok {\n\t\treturn expr.val, nil\n\t}\n\tif c.evalVM == nil {\n\t\tc.evalVM = New().vm\n\t}\n\tvar savedPrg *Program\n\tcreatedPrg := false\n\tif c.evalVM.prg == nil {\n\t\tc.evalVM.prg = &Program{\n\t\t\tsrc: c.p.src,\n\t\t}\n\t\tsavedPrg = c.p\n\t\tc.p = c.evalVM.prg\n\t\tcreatedPrg = true\n\t}\n\tsavedPc := len(c.p.code)\n\texpr.emitGetter(true)\n\tc.evalVM.pc = savedPc\n\tex := c.evalVM.runTry()\n\tif createdPrg {\n\t\tc.evalVM.prg = nil\n\t\tc.evalVM.pc = 0\n\t\tc.p = savedPrg\n\t} else {\n\t\tc.evalVM.prg.code = c.evalVM.prg.code[:savedPc]\n\t\tc.p.code = c.evalVM.prg.code\n\t}\n\tif ex == nil {\n\t\treturn c.evalVM.pop(), nil\n\t}\n\treturn nil, ex\n}\n\nfunc (e *compiledUnaryExpr) constant() bool {\n\treturn e.operand.constant()\n}\n\nfunc (e *compiledUnaryExpr) emitGetter(putOnStack bool) {\n\tvar prepare, body func()\n\n\ttoNumber := func() {\n\t\te.addSrcMap()\n\t\te.c.emit(toNumber)\n\t}\n\n\tswitch e.operator {\n\tcase token.NOT:\n\t\te.operand.emitGetter(true)\n\t\te.c.emit(not)\n\t\tgoto end\n\tcase token.BITWISE_NOT:\n\t\te.operand.emitGetter(true)\n\t\te.c.emit(bnot)\n\t\tgoto end\n\tcase token.TYPEOF:\n\t\tif o, ok := e.operand.(compiledExprOrRef); ok {\n\t\t\to.emitGetterOrRef()\n\t\t} else {\n\t\t\te.operand.emitGetter(true)\n\t\t}\n\t\te.c.emit(typeof)\n\t\tgoto end\n\tcase token.DELETE:\n\t\te.operand.deleteExpr().emitGetter(putOnStack)\n\t\treturn\n\tcase token.MINUS:\n\t\te.c.emitExpr(e.operand, true)\n\t\te.c.emit(neg)\n\t\tgoto end\n\tcase token.PLUS:\n\t\te.c.emitExpr(e.operand, true)\n\t\te.c.emit(plus)\n\t\tgoto end\n\tcase token.INCREMENT:\n\t\tprepare = toNumber\n\t\tbody = func() {\n\t\t\te.c.emit(inc)\n\t\t}\n\tcase token.DECREMENT:\n\t\tprepare = toNumber\n\t\tbody = func() {\n\t\t\te.c.emit(dec)\n\t\t}\n\tcase token.VOID:\n\t\te.c.emitExpr(e.operand, false)\n\t\tif putOnStack {\n\t\t\te.c.emit(loadUndef)\n\t\t}\n\t\treturn\n\tdefault:\n\t\te.c.assert(false, e.offset, \"Unknown unary operator: %s\", e.operator.String())\n\t\tpanic(\"unreachable\")\n\t}\n\n\te.operand.emitUnary(prepare, body, e.postfix, putOnStack)\n\treturn\n\nend:\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileUnaryExpression(v *ast.UnaryExpression) compiledExpr {\n\tr := &compiledUnaryExpr{\n\t\toperand:  c.compileExpression(v.Operand),\n\t\toperator: v.Operator,\n\t\tpostfix:  v.Postfix,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledConditionalExpr) emitGetter(putOnStack bool) {\n\te.test.emitGetter(true)\n\tj := len(e.c.p.code)\n\te.c.emit(nil)\n\te.consequent.emitGetter(putOnStack)\n\tj1 := len(e.c.p.code)\n\te.c.emit(nil)\n\te.c.p.code[j] = jne(len(e.c.p.code) - j)\n\te.alternate.emitGetter(putOnStack)\n\te.c.p.code[j1] = jump(len(e.c.p.code) - j1)\n}\n\nfunc (c *compiler) compileConditionalExpression(v *ast.ConditionalExpression) compiledExpr {\n\tr := &compiledConditionalExpr{\n\t\ttest:       c.compileExpression(v.Test),\n\t\tconsequent: c.compileExpression(v.Consequent),\n\t\talternate:  c.compileExpression(v.Alternate),\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledLogicalOr) constant() bool {\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif v.ToBoolean() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn e.right.constant()\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (e *compiledLogicalOr) emitGetter(putOnStack bool) {\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif !v.ToBoolean() {\n\t\t\t\te.c.emitExpr(e.right, putOnStack)\n\t\t\t} else {\n\t\t\t\tif putOnStack {\n\t\t\t\t\te.c.emitLiteralValue(v)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emitThrow(ex.val)\n\t\t}\n\t\treturn\n\t}\n\te.c.emitExpr(e.left, true)\n\tj := len(e.c.p.code)\n\te.addSrcMap()\n\te.c.emit(nil)\n\te.c.emitExpr(e.right, true)\n\te.c.p.code[j] = jeq1(len(e.c.p.code) - j)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledCoalesce) constant() bool {\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif v != _null && v != _undefined {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn e.right.constant()\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (e *compiledCoalesce) emitGetter(putOnStack bool) {\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif v == _undefined || v == _null {\n\t\t\t\te.c.emitExpr(e.right, putOnStack)\n\t\t\t} else {\n\t\t\t\tif putOnStack {\n\t\t\t\t\te.c.emitLiteralValue(v)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emitThrow(ex.val)\n\t\t}\n\t\treturn\n\t}\n\te.c.emitExpr(e.left, true)\n\tj := len(e.c.p.code)\n\te.addSrcMap()\n\te.c.emit(nil)\n\te.c.emitExpr(e.right, true)\n\te.c.p.code[j] = jcoalesc(len(e.c.p.code) - j)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledLogicalAnd) constant() bool {\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif !v.ToBoolean() {\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\treturn e.right.constant()\n\t\t\t}\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (e *compiledLogicalAnd) emitGetter(putOnStack bool) {\n\tvar j int\n\tif e.left.constant() {\n\t\tif v, ex := e.c.evalConst(e.left); ex == nil {\n\t\t\tif !v.ToBoolean() {\n\t\t\t\te.c.emitLiteralValue(v)\n\t\t\t} else {\n\t\t\t\te.c.emitExpr(e.right, putOnStack)\n\t\t\t}\n\t\t} else {\n\t\t\te.c.emitThrow(ex.val)\n\t\t}\n\t\treturn\n\t}\n\te.left.emitGetter(true)\n\tj = len(e.c.p.code)\n\te.addSrcMap()\n\te.c.emit(nil)\n\te.c.emitExpr(e.right, true)\n\te.c.p.code[j] = jneq1(len(e.c.p.code) - j)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledBinaryExpr) constant() bool {\n\treturn e.left.constant() && e.right.constant()\n}\n\nfunc (e *compiledBinaryExpr) emitGetter(putOnStack bool) {\n\te.c.emitExpr(e.left, true)\n\te.c.emitExpr(e.right, true)\n\te.addSrcMap()\n\n\tswitch e.operator {\n\tcase token.LESS:\n\t\te.c.emit(op_lt)\n\tcase token.GREATER:\n\t\te.c.emit(op_gt)\n\tcase token.LESS_OR_EQUAL:\n\t\te.c.emit(op_lte)\n\tcase token.GREATER_OR_EQUAL:\n\t\te.c.emit(op_gte)\n\tcase token.EQUAL:\n\t\te.c.emit(op_eq)\n\tcase token.NOT_EQUAL:\n\t\te.c.emit(op_neq)\n\tcase token.STRICT_EQUAL:\n\t\te.c.emit(op_strict_eq)\n\tcase token.STRICT_NOT_EQUAL:\n\t\te.c.emit(op_strict_neq)\n\tcase token.PLUS:\n\t\te.c.emit(add)\n\tcase token.MINUS:\n\t\te.c.emit(sub)\n\tcase token.MULTIPLY:\n\t\te.c.emit(mul)\n\tcase token.EXPONENT:\n\t\te.c.emit(exp)\n\tcase token.SLASH:\n\t\te.c.emit(div)\n\tcase token.REMAINDER:\n\t\te.c.emit(mod)\n\tcase token.AND:\n\t\te.c.emit(and)\n\tcase token.OR:\n\t\te.c.emit(or)\n\tcase token.EXCLUSIVE_OR:\n\t\te.c.emit(xor)\n\tcase token.INSTANCEOF:\n\t\te.c.emit(op_instanceof)\n\tcase token.IN:\n\t\te.c.emit(op_in)\n\tcase token.SHIFT_LEFT:\n\t\te.c.emit(sal)\n\tcase token.SHIFT_RIGHT:\n\t\te.c.emit(sar)\n\tcase token.UNSIGNED_SHIFT_RIGHT:\n\t\te.c.emit(shr)\n\tdefault:\n\t\te.c.assert(false, e.offset, \"Unknown operator: %s\", e.operator.String())\n\t\tpanic(\"unreachable\")\n\t}\n\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileBinaryExpression(v *ast.BinaryExpression) compiledExpr {\n\n\tswitch v.Operator {\n\tcase token.LOGICAL_OR:\n\t\treturn c.compileLogicalOr(v.Left, v.Right, v.Idx0())\n\tcase token.COALESCE:\n\t\treturn c.compileCoalesce(v.Left, v.Right, v.Idx0())\n\tcase token.LOGICAL_AND:\n\t\treturn c.compileLogicalAnd(v.Left, v.Right, v.Idx0())\n\t}\n\n\tif id, ok := v.Left.(*ast.PrivateIdentifier); ok {\n\t\treturn c.compilePrivateIn(id, v.Right, id.Idx)\n\t}\n\n\tr := &compiledBinaryExpr{\n\t\tleft:     c.compileExpression(v.Left),\n\t\tright:    c.compileExpression(v.Right),\n\t\toperator: v.Operator,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\ntype compiledPrivateIn struct {\n\tbaseCompiledExpr\n\tid    unistring.String\n\tright compiledExpr\n}\n\nfunc (e *compiledPrivateIn) emitGetter(putOnStack bool) {\n\te.right.emitGetter(true)\n\trn, id := e.c.resolvePrivateName(e.id, e.offset)\n\tif rn != nil {\n\t\te.c.emit((*privateInRes)(rn))\n\t} else {\n\t\te.c.emit((*privateInId)(id))\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compilePrivateIn(id *ast.PrivateIdentifier, right ast.Expression, idx file.Idx) compiledExpr {\n\tr := &compiledPrivateIn{\n\t\tid:    id.Name,\n\t\tright: c.compileExpression(right),\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (c *compiler) compileLogicalOr(left, right ast.Expression, idx file.Idx) compiledExpr {\n\tr := &compiledLogicalOr{\n\t\tleft:  c.compileExpression(left),\n\t\tright: c.compileExpression(right),\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (c *compiler) compileCoalesce(left, right ast.Expression, idx file.Idx) compiledExpr {\n\tr := &compiledCoalesce{\n\t\tleft:  c.compileExpression(left),\n\t\tright: c.compileExpression(right),\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (c *compiler) compileLogicalAnd(left, right ast.Expression, idx file.Idx) compiledExpr {\n\tr := &compiledLogicalAnd{\n\t\tleft:  c.compileExpression(left),\n\t\tright: c.compileExpression(right),\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (e *compiledObjectLiteral) emitGetter(putOnStack bool) {\n\te.addSrcMap()\n\te.c.emit(newObject)\n\thasProto := false\n\tfor _, prop := range e.expr.Value {\n\t\tswitch prop := prop.(type) {\n\t\tcase *ast.PropertyKeyed:\n\t\t\tkey, computed := e.c.processKey(prop.Key)\n\t\t\tvalueExpr := e.c.compileExpression(prop.Value)\n\t\t\tvar ne namedEmitter\n\t\t\tif fn, ok := valueExpr.(*compiledFunctionLiteral); ok {\n\t\t\t\tif fn.name == nil {\n\t\t\t\t\tne = fn\n\t\t\t\t}\n\t\t\t\tswitch prop.Kind {\n\t\t\t\tcase ast.PropertyKindMethod, ast.PropertyKindGet, ast.PropertyKindSet:\n\t\t\t\t\tfn.typ = funcMethod\n\t\t\t\t\tif computed {\n\t\t\t\t\t\tfn.homeObjOffset = 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfn.homeObjOffset = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if v, ok := valueExpr.(namedEmitter); ok {\n\t\t\t\tne = v\n\t\t\t}\n\t\t\tif computed {\n\t\t\t\te.c.emit(_toPropertyKey{})\n\t\t\t\te.c.emitExpr(valueExpr, true)\n\t\t\t\tswitch prop.Kind {\n\t\t\t\tcase ast.PropertyKindValue:\n\t\t\t\t\tif ne != nil {\n\t\t\t\t\t\te.c.emit(setElem1Named)\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.c.emit(setElem1)\n\t\t\t\t\t}\n\t\t\t\tcase ast.PropertyKindMethod:\n\t\t\t\t\te.c.emit(&defineMethod{enumerable: true})\n\t\t\t\tcase ast.PropertyKindGet:\n\t\t\t\t\te.c.emit(&defineGetter{enumerable: true})\n\t\t\t\tcase ast.PropertyKindSet:\n\t\t\t\t\te.c.emit(&defineSetter{enumerable: true})\n\t\t\t\tdefault:\n\t\t\t\t\te.c.assert(false, e.offset, \"unknown property kind: %s\", prop.Kind)\n\t\t\t\t\tpanic(\"unreachable\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisProto := key == __proto__ && !prop.Computed\n\t\t\t\tif isProto {\n\t\t\t\t\tif hasProto {\n\t\t\t\t\t\te.c.throwSyntaxError(int(prop.Idx0())-1, \"Duplicate __proto__ fields are not allowed in object literals\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\thasProto = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ne != nil && !isProto {\n\t\t\t\t\tne.emitNamed(key)\n\t\t\t\t} else {\n\t\t\t\t\te.c.emitExpr(valueExpr, true)\n\t\t\t\t}\n\t\t\t\tswitch prop.Kind {\n\t\t\t\tcase ast.PropertyKindValue:\n\t\t\t\t\tif isProto {\n\t\t\t\t\t\te.c.emit(setProto)\n\t\t\t\t\t} else {\n\t\t\t\t\t\te.c.emit(putProp(key))\n\t\t\t\t\t}\n\t\t\t\tcase ast.PropertyKindMethod:\n\t\t\t\t\te.c.emit(&defineMethodKeyed{key: key, enumerable: true})\n\t\t\t\tcase ast.PropertyKindGet:\n\t\t\t\t\te.c.emit(&defineGetterKeyed{key: key, enumerable: true})\n\t\t\t\tcase ast.PropertyKindSet:\n\t\t\t\t\te.c.emit(&defineSetterKeyed{key: key, enumerable: true})\n\t\t\t\tdefault:\n\t\t\t\t\te.c.assert(false, e.offset, \"unknown property kind: %s\", prop.Kind)\n\t\t\t\t\tpanic(\"unreachable\")\n\t\t\t\t}\n\t\t\t}\n\t\tcase *ast.PropertyShort:\n\t\t\tkey := prop.Name.Name\n\t\t\tif prop.Initializer != nil {\n\t\t\t\te.c.throwSyntaxError(int(prop.Initializer.Idx0())-1, \"Invalid shorthand property initializer\")\n\t\t\t}\n\t\t\tif e.c.scope.strict && key == \"let\" {\n\t\t\t\te.c.throwSyntaxError(e.offset, \"'let' cannot be used as a shorthand property in strict mode\")\n\t\t\t}\n\t\t\te.c.compileIdentifierExpression(&prop.Name).emitGetter(true)\n\t\t\te.c.emit(putProp(key))\n\t\tcase *ast.SpreadElement:\n\t\t\te.c.compileExpression(prop.Expression).emitGetter(true)\n\t\t\te.c.emit(copySpread)\n\t\tdefault:\n\t\t\te.c.assert(false, e.offset, \"unknown Property type: %T\", prop)\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileObjectLiteral(v *ast.ObjectLiteral) compiledExpr {\n\tr := &compiledObjectLiteral{\n\t\texpr: v,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledArrayLiteral) emitGetter(putOnStack bool) {\n\te.addSrcMap()\n\thasSpread := false\n\tmark := len(e.c.p.code)\n\te.c.emit(nil)\n\tfor _, v := range e.expr.Value {\n\t\tif spread, ok := v.(*ast.SpreadElement); ok {\n\t\t\thasSpread = true\n\t\t\te.c.compileExpression(spread.Expression).emitGetter(true)\n\t\t\te.c.emit(pushArraySpread)\n\t\t} else {\n\t\t\tif v != nil {\n\t\t\t\te.c.emitExpr(e.c.compileExpression(v), true)\n\t\t\t} else {\n\t\t\t\te.c.emit(loadNil)\n\t\t\t}\n\t\t\te.c.emit(pushArrayItem)\n\t\t}\n\t}\n\tvar objCount uint32\n\tif !hasSpread {\n\t\tobjCount = uint32(len(e.expr.Value))\n\t}\n\te.c.p.code[mark] = newArray(objCount)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileArrayLiteral(v *ast.ArrayLiteral) compiledExpr {\n\tr := &compiledArrayLiteral{\n\t\texpr: v,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledRegexpLiteral) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\tpattern, err := compileRegexp(e.expr.Pattern, e.expr.Flags)\n\t\tif err != nil {\n\t\t\te.c.throwSyntaxError(e.offset, err.Error())\n\t\t}\n\n\t\te.c.emit(&newRegexp{pattern: pattern, src: newStringValue(e.expr.Pattern)})\n\t}\n}\n\nfunc (c *compiler) compileRegexpLiteral(v *ast.RegExpLiteral) compiledExpr {\n\tr := &compiledRegexpLiteral{\n\t\texpr: v,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) emitCallee(callee compiledExpr) (calleeName unistring.String) {\n\tswitch callee := callee.(type) {\n\tcase *compiledDotExpr:\n\t\tcallee.left.emitGetter(true)\n\t\tc.emit(getPropCallee(callee.name))\n\tcase *compiledPrivateDotExpr:\n\t\tcallee.left.emitGetter(true)\n\t\trn, id := c.resolvePrivateName(callee.name, callee.offset)\n\t\tif rn != nil {\n\t\t\tc.emit((*getPrivatePropResCallee)(rn))\n\t\t} else {\n\t\t\tc.emit((*getPrivatePropIdCallee)(id))\n\t\t}\n\tcase *compiledSuperDotExpr:\n\t\tc.emitLoadThis()\n\t\tc.emit(loadSuper)\n\t\tc.emit(getPropRecvCallee(callee.name))\n\tcase *compiledBracketExpr:\n\t\tcallee.left.emitGetter(true)\n\t\tcallee.member.emitGetter(true)\n\t\tc.emit(getElemCallee)\n\tcase *compiledSuperBracketExpr:\n\t\tc.emitLoadThis()\n\t\tc.emit(loadSuper)\n\t\tcallee.member.emitGetter(true)\n\t\tc.emit(getElemRecvCallee)\n\tcase *compiledIdentifierExpr:\n\t\tcalleeName = callee.name\n\t\tcallee.emitGetterAndCallee()\n\tcase *compiledOptionalChain:\n\t\tc.startOptChain()\n\t\tc.emitCallee(callee.expr)\n\t\tc.endOptChain()\n\tcase *compiledOptional:\n\t\tc.emitCallee(callee.expr)\n\t\tc.block.conts = append(c.block.conts, len(c.p.code))\n\t\tc.emit(nil)\n\tcase *compiledSuperExpr:\n\t\t// no-op\n\tdefault:\n\t\tc.emit(loadUndef)\n\t\tcallee.emitGetter(true)\n\t}\n\treturn\n}\n\nfunc (e *compiledCallExpr) emitGetter(putOnStack bool) {\n\tif e.isVariadic {\n\t\te.c.emit(startVariadic)\n\t}\n\tcalleeName := e.c.emitCallee(e.callee)\n\n\tfor _, expr := range e.args {\n\t\texpr.emitGetter(true)\n\t}\n\n\te.addSrcMap()\n\tif _, ok := e.callee.(*compiledSuperExpr); ok {\n\t\tb, eval := e.c.scope.lookupThis()\n\t\te.c.assert(eval || b != nil, e.offset, \"super call, but no 'this' binding\")\n\t\tif eval {\n\t\t\te.c.emit(resolveThisDynamic{})\n\t\t} else {\n\t\t\tb.markAccessPoint()\n\t\t\te.c.emit(resolveThisStack{})\n\t\t}\n\t\tif e.isVariadic {\n\t\t\te.c.emit(superCallVariadic)\n\t\t} else {\n\t\t\te.c.emit(superCall(len(e.args)))\n\t\t}\n\t} else if calleeName == \"eval\" {\n\t\tfoundVar := false\n\t\tfor sc := e.c.scope; sc != nil; sc = sc.outer {\n\t\t\tif !foundVar && (sc.variable || sc.isFunction()) {\n\t\t\t\tfoundVar = true\n\t\t\t\tif !sc.strict {\n\t\t\t\t\tsc.dynamic = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.dynLookup = true\n\t\t}\n\n\t\tif e.c.scope.strict {\n\t\t\tif e.isVariadic {\n\t\t\t\te.c.emit(callEvalVariadicStrict)\n\t\t\t} else {\n\t\t\t\te.c.emit(callEvalStrict(len(e.args)))\n\t\t\t}\n\t\t} else {\n\t\t\tif e.isVariadic {\n\t\t\t\te.c.emit(callEvalVariadic)\n\t\t\t} else {\n\t\t\t\te.c.emit(callEval(len(e.args)))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif e.isVariadic {\n\t\t\te.c.emit(callVariadic)\n\t\t} else {\n\t\t\te.c.emit(call(len(e.args)))\n\t\t}\n\t}\n\tif e.isVariadic {\n\t\te.c.emit(endVariadic)\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledCallExpr) deleteExpr() compiledExpr {\n\tr := &defaultDeleteExpr{\n\t\texpr: e,\n\t}\n\tr.init(e.c, file.Idx(e.offset+1))\n\treturn r\n}\n\nfunc (c *compiler) compileSpreadCallArgument(spread *ast.SpreadElement) compiledExpr {\n\tr := &compiledSpreadCallArgument{\n\t\texpr: c.compileExpression(spread.Expression),\n\t}\n\tr.init(c, spread.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileCallee(v ast.Expression) compiledExpr {\n\tif sup, ok := v.(*ast.SuperExpression); ok {\n\t\tif s := c.scope.nearestThis(); s != nil && s.funcType == funcDerivedCtor {\n\t\t\te := &compiledSuperExpr{}\n\t\t\te.init(c, sup.Idx)\n\t\t\treturn e\n\t\t}\n\t\tc.throwSyntaxError(int(v.Idx0())-1, \"'super' keyword unexpected here\")\n\t\tpanic(\"unreachable\")\n\t}\n\treturn c.compileExpression(v)\n}\n\nfunc (c *compiler) compileCallExpression(v *ast.CallExpression) compiledExpr {\n\n\targs := make([]compiledExpr, len(v.ArgumentList))\n\tisVariadic := false\n\tfor i, argExpr := range v.ArgumentList {\n\t\tif spread, ok := argExpr.(*ast.SpreadElement); ok {\n\t\t\targs[i] = c.compileSpreadCallArgument(spread)\n\t\t\tisVariadic = true\n\t\t} else {\n\t\t\targs[i] = c.compileExpression(argExpr)\n\t\t}\n\t}\n\n\tr := &compiledCallExpr{\n\t\targs:       args,\n\t\tcallee:     c.compileCallee(v.Callee),\n\t\tisVariadic: isVariadic,\n\t}\n\tr.init(c, v.LeftParenthesis)\n\treturn r\n}\n\nfunc (c *compiler) compileIdentifierExpression(v *ast.Identifier) compiledExpr {\n\tif c.scope.strict {\n\t\tc.checkIdentifierName(v.Name, int(v.Idx)-1)\n\t}\n\n\tr := &compiledIdentifierExpr{\n\t\tname: v.Name,\n\t}\n\tr.offset = int(v.Idx) - 1\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileNumberLiteral(v *ast.NumberLiteral) compiledExpr {\n\tif c.scope.strict && len(v.Literal) > 1 && v.Literal[0] == '0' && v.Literal[1] <= '7' && v.Literal[1] >= '0' {\n\t\tc.throwSyntaxError(int(v.Idx)-1, \"Octal literals are not allowed in strict mode\")\n\t\tpanic(\"Unreachable\")\n\t}\n\tvar val Value\n\tswitch num := v.Value.(type) {\n\tcase int64:\n\t\tval = intToValue(num)\n\tcase float64:\n\t\tval = floatToValue(num)\n\tcase *big.Int:\n\t\tval = (*valueBigInt)(num)\n\tdefault:\n\t\tc.assert(false, int(v.Idx)-1, \"Unsupported number literal type: %T\", v.Value)\n\t\tpanic(\"unreachable\")\n\t}\n\tr := &compiledLiteral{\n\t\tval: val,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileStringLiteral(v *ast.StringLiteral) compiledExpr {\n\tr := &compiledLiteral{\n\t\tval: stringValueFromRaw(v.Value),\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileTemplateLiteral(v *ast.TemplateLiteral) compiledExpr {\n\tr := &compiledTemplateLiteral{}\n\tif v.Tag != nil {\n\t\tr.tag = c.compileExpression(v.Tag)\n\t}\n\tce := make([]compiledExpr, len(v.Expressions))\n\tfor i, expr := range v.Expressions {\n\t\tce[i] = c.compileExpression(expr)\n\t}\n\tr.expressions = ce\n\tr.elements = v.Elements\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileBooleanLiteral(v *ast.BooleanLiteral) compiledExpr {\n\tvar val Value\n\tif v.Value {\n\t\tval = valueTrue\n\t} else {\n\t\tval = valueFalse\n\t}\n\n\tr := &compiledLiteral{\n\t\tval: val,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (c *compiler) compileAssignExpression(v *ast.AssignExpression) compiledExpr {\n\t// log.Printf(\"compileAssignExpression(): %+v\", v)\n\n\tr := &compiledAssignExpr{\n\t\tleft:     c.compileExpression(v.Left),\n\t\tright:    c.compileExpression(v.Right),\n\t\toperator: v.Operator,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledEnumGetExpr) emitGetter(putOnStack bool) {\n\te.c.emit(enumGet)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (c *compiler) compileObjectAssignmentPattern(v *ast.ObjectPattern) compiledExpr {\n\tr := &compiledObjectAssignmentPattern{\n\t\texpr: v,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledObjectAssignmentPattern) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\te.c.emit(loadUndef)\n\t}\n}\n\nfunc (c *compiler) compileArrayAssignmentPattern(v *ast.ArrayPattern) compiledExpr {\n\tr := &compiledArrayAssignmentPattern{\n\t\texpr: v,\n\t}\n\tr.init(c, v.Idx0())\n\treturn r\n}\n\nfunc (e *compiledArrayAssignmentPattern) emitGetter(putOnStack bool) {\n\tif putOnStack {\n\t\te.c.emit(loadUndef)\n\t}\n}\n\nfunc (c *compiler) emitExpr(expr compiledExpr, putOnStack bool) {\n\tif expr.constant() {\n\t\tc.emitConst(expr, putOnStack)\n\t} else {\n\t\texpr.emitGetter(putOnStack)\n\t}\n}\n\ntype namedEmitter interface {\n\temitNamed(name unistring.String)\n}\n\nfunc (c *compiler) emitNamed(expr compiledExpr, name unistring.String) {\n\tif en, ok := expr.(namedEmitter); ok {\n\t\ten.emitNamed(name)\n\t} else {\n\t\texpr.emitGetter(true)\n\t}\n}\n\nfunc (c *compiler) emitNamedOrConst(expr compiledExpr, name unistring.String) {\n\tif expr.constant() {\n\t\tc.emitConst(expr, true)\n\t} else {\n\t\tc.emitNamed(expr, name)\n\t}\n}\n\nfunc (e *compiledFunctionLiteral) emitNamed(name unistring.String) {\n\te.lhsName = name\n\te.emitGetter(true)\n}\n\nfunc (e *compiledClassLiteral) emitNamed(name unistring.String) {\n\te.lhsName = name\n\te.emitGetter(true)\n}\n\nfunc (c *compiler) emitPattern(pattern ast.Pattern, emitter func(target, init compiledExpr), putOnStack bool) {\n\tswitch pattern := pattern.(type) {\n\tcase *ast.ObjectPattern:\n\t\tc.emitObjectPattern(pattern, emitter, putOnStack)\n\tcase *ast.ArrayPattern:\n\t\tc.emitArrayPattern(pattern, emitter, putOnStack)\n\tdefault:\n\t\tc.assert(false, int(pattern.Idx0())-1, \"unsupported Pattern: %T\", pattern)\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *compiler) emitAssign(target ast.Expression, init compiledExpr, emitAssignSimple func(target, init compiledExpr)) {\n\tpattern, isPattern := target.(ast.Pattern)\n\tif isPattern {\n\t\tinit.emitGetter(true)\n\t\tc.emitPattern(pattern, emitAssignSimple, false)\n\t} else {\n\t\temitAssignSimple(c.compileExpression(target), init)\n\t}\n}\n\nfunc (c *compiler) emitObjectPattern(pattern *ast.ObjectPattern, emitAssign func(target, init compiledExpr), putOnStack bool) {\n\tif pattern.Rest != nil {\n\t\tc.emit(createDestructSrc)\n\t} else {\n\t\tc.emit(checkObjectCoercible)\n\t}\n\tfor _, prop := range pattern.Properties {\n\t\tswitch prop := prop.(type) {\n\t\tcase *ast.PropertyShort:\n\t\t\tc.emit(dup)\n\t\t\temitAssign(c.compileIdentifierExpression(&prop.Name), c.compilePatternInitExpr(func() {\n\t\t\t\tc.emit(getProp(prop.Name.Name))\n\t\t\t}, prop.Initializer, prop.Idx0()))\n\t\tcase *ast.PropertyKeyed:\n\t\t\tc.emit(dup)\n\t\t\tc.compileExpression(prop.Key).emitGetter(true)\n\t\t\tc.emit(_toPropertyKey{})\n\t\t\tvar target ast.Expression\n\t\t\tvar initializer ast.Expression\n\t\t\tif e, ok := prop.Value.(*ast.AssignExpression); ok {\n\t\t\t\ttarget = e.Left\n\t\t\t\tinitializer = e.Right\n\t\t\t} else {\n\t\t\t\ttarget = prop.Value\n\t\t\t}\n\t\t\tc.emitAssign(target, c.compilePatternInitExpr(func() {\n\t\t\t\tc.emit(getKey)\n\t\t\t}, initializer, prop.Idx0()), emitAssign)\n\t\tdefault:\n\t\t\tc.throwSyntaxError(int(prop.Idx0()-1), \"Unsupported AssignmentProperty type: %T\", prop)\n\t\t}\n\t}\n\tif pattern.Rest != nil {\n\t\temitAssign(c.compileExpression(pattern.Rest), c.compileEmitterExpr(func() {\n\t\t\tc.emit(copyRest)\n\t\t}, pattern.Rest.Idx0()))\n\t\tc.emit(pop)\n\t}\n\tif !putOnStack {\n\t\tc.emit(pop)\n\t}\n}\n\nfunc (c *compiler) emitArrayPattern(pattern *ast.ArrayPattern, emitAssign func(target, init compiledExpr), putOnStack bool) {\n\tc.emit(iterate)\n\tfor _, elt := range pattern.Elements {\n\t\tswitch elt := elt.(type) {\n\t\tcase nil:\n\t\t\tc.emit(iterGetNextOrUndef{}, pop)\n\t\tcase *ast.AssignExpression:\n\t\t\tc.emitAssign(elt.Left, c.compilePatternInitExpr(func() {\n\t\t\t\tc.emit(iterGetNextOrUndef{})\n\t\t\t}, elt.Right, elt.Idx0()), emitAssign)\n\t\tdefault:\n\t\t\tc.emitAssign(elt, c.compileEmitterExpr(func() {\n\t\t\t\tc.emit(iterGetNextOrUndef{})\n\t\t\t}, elt.Idx0()), emitAssign)\n\t\t}\n\t}\n\tif pattern.Rest != nil {\n\t\tc.emitAssign(pattern.Rest, c.compileEmitterExpr(func() {\n\t\t\tc.emit(newArrayFromIter)\n\t\t}, pattern.Rest.Idx0()), emitAssign)\n\t} else {\n\t\tc.emit(enumPopClose)\n\t}\n\n\tif !putOnStack {\n\t\tc.emit(pop)\n\t}\n}\n\nfunc (e *compiledObjectAssignmentPattern) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\tvalueExpr.emitGetter(true)\n\te.c.emitObjectPattern(e.expr, e.c.emitPatternAssign, putOnStack)\n}\n\nfunc (e *compiledArrayAssignmentPattern) emitSetter(valueExpr compiledExpr, putOnStack bool) {\n\tvalueExpr.emitGetter(true)\n\te.c.emitArrayPattern(e.expr, e.c.emitPatternAssign, putOnStack)\n}\n\ntype compiledPatternInitExpr struct {\n\tbaseCompiledExpr\n\temitSrc func()\n\tdef     compiledExpr\n}\n\nfunc (e *compiledPatternInitExpr) emitGetter(putOnStack bool) {\n\tif !putOnStack {\n\t\treturn\n\t}\n\te.emitSrc()\n\tif e.def != nil {\n\t\tmark := len(e.c.p.code)\n\t\te.c.emit(nil)\n\t\te.c.emitExpr(e.def, true)\n\t\te.c.p.code[mark] = jdef(len(e.c.p.code) - mark)\n\t}\n}\n\nfunc (e *compiledPatternInitExpr) emitNamed(name unistring.String) {\n\te.emitSrc()\n\tif e.def != nil {\n\t\tmark := len(e.c.p.code)\n\t\te.c.emit(nil)\n\t\te.c.emitNamedOrConst(e.def, name)\n\t\te.c.p.code[mark] = jdef(len(e.c.p.code) - mark)\n\t}\n}\n\nfunc (c *compiler) compilePatternInitExpr(emitSrc func(), def ast.Expression, idx file.Idx) compiledExpr {\n\tr := &compiledPatternInitExpr{\n\t\temitSrc: emitSrc,\n\t\tdef:     c.compileExpression(def),\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\ntype compiledEmitterExpr struct {\n\tbaseCompiledExpr\n\temitter      func()\n\tnamedEmitter func(name unistring.String)\n}\n\nfunc (e *compiledEmitterExpr) emitGetter(putOnStack bool) {\n\tif e.emitter != nil {\n\t\te.emitter()\n\t} else {\n\t\te.namedEmitter(\"\")\n\t}\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledEmitterExpr) emitNamed(name unistring.String) {\n\tif e.namedEmitter != nil {\n\t\te.namedEmitter(name)\n\t} else {\n\t\te.emitter()\n\t}\n}\n\nfunc (c *compiler) compileEmitterExpr(emitter func(), idx file.Idx) *compiledEmitterExpr {\n\tr := &compiledEmitterExpr{\n\t\temitter: emitter,\n\t}\n\tr.init(c, idx)\n\treturn r\n}\n\nfunc (e *compiledSpreadCallArgument) emitGetter(putOnStack bool) {\n\te.expr.emitGetter(putOnStack)\n\tif putOnStack {\n\t\te.c.emit(pushSpread)\n\t}\n}\n\nfunc (c *compiler) startOptChain() {\n\tc.block = &block{\n\t\ttyp:   blockOptChain,\n\t\touter: c.block,\n\t}\n}\n\nfunc (c *compiler) endOptChain() {\n\tlbl := len(c.p.code)\n\tfor _, item := range c.block.breaks {\n\t\tc.p.code[item] = jopt(lbl - item)\n\t}\n\tfor _, item := range c.block.conts {\n\t\tc.p.code[item] = joptc(lbl - item)\n\t}\n\tc.block = c.block.outer\n}\n\nfunc (e *compiledOptionalChain) emitGetter(putOnStack bool) {\n\te.c.startOptChain()\n\te.expr.emitGetter(true)\n\te.c.endOptChain()\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledOptional) emitGetter(putOnStack bool) {\n\te.expr.emitGetter(putOnStack)\n\tif putOnStack {\n\t\te.c.block.breaks = append(e.c.block.breaks, len(e.c.p.code))\n\t\te.c.emit(nil)\n\t}\n}\n\nfunc (e *compiledAwaitExpression) emitGetter(putOnStack bool) {\n\te.arg.emitGetter(true)\n\te.c.emit(await)\n\tif !putOnStack {\n\t\te.c.emit(pop)\n\t}\n}\n\nfunc (e *compiledYieldExpression) emitGetter(putOnStack bool) {\n\tif e.arg != nil {\n\t\te.arg.emitGetter(true)\n\t} else {\n\t\te.c.emit(loadUndef)\n\t}\n\tif putOnStack {\n\t\tif e.delegate {\n\t\t\te.c.emit(yieldDelegateRes)\n\t\t} else {\n\t\t\te.c.emit(yieldRes)\n\t\t}\n\t} else {\n\t\tif e.delegate {\n\t\t\te.c.emit(yieldDelegate)\n\t\t} else {\n\t\t\te.c.emit(yield)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "compiler_stmt.go",
          "type": "blob",
          "size": 27.96484375,
          "content": "package goja\n\nimport (\n\t\"github.com/dop251/goja/ast\"\n\t\"github.com/dop251/goja/file\"\n\t\"github.com/dop251/goja/token\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\nfunc (c *compiler) compileStatement(v ast.Statement, needResult bool) {\n\n\tswitch v := v.(type) {\n\tcase *ast.BlockStatement:\n\t\tc.compileBlockStatement(v, needResult)\n\tcase *ast.ExpressionStatement:\n\t\tc.compileExpressionStatement(v, needResult)\n\tcase *ast.VariableStatement:\n\t\tc.compileVariableStatement(v)\n\tcase *ast.LexicalDeclaration:\n\t\tc.compileLexicalDeclaration(v)\n\tcase *ast.ReturnStatement:\n\t\tc.compileReturnStatement(v)\n\tcase *ast.IfStatement:\n\t\tc.compileIfStatement(v, needResult)\n\tcase *ast.DoWhileStatement:\n\t\tc.compileDoWhileStatement(v, needResult)\n\tcase *ast.ForStatement:\n\t\tc.compileForStatement(v, needResult)\n\tcase *ast.ForInStatement:\n\t\tc.compileForInStatement(v, needResult)\n\tcase *ast.ForOfStatement:\n\t\tc.compileForOfStatement(v, needResult)\n\tcase *ast.WhileStatement:\n\t\tc.compileWhileStatement(v, needResult)\n\tcase *ast.BranchStatement:\n\t\tc.compileBranchStatement(v)\n\tcase *ast.TryStatement:\n\t\tc.compileTryStatement(v, needResult)\n\tcase *ast.ThrowStatement:\n\t\tc.compileThrowStatement(v)\n\tcase *ast.SwitchStatement:\n\t\tc.compileSwitchStatement(v, needResult)\n\tcase *ast.LabelledStatement:\n\t\tc.compileLabeledStatement(v, needResult)\n\tcase *ast.EmptyStatement:\n\t\tc.compileEmptyStatement(needResult)\n\tcase *ast.FunctionDeclaration:\n\t\tc.compileStandaloneFunctionDecl(v)\n\t\t// note functions inside blocks are hoisted to the top of the block and are compiled using compileFunctions()\n\tcase *ast.ClassDeclaration:\n\t\tc.compileClassDeclaration(v)\n\tcase *ast.WithStatement:\n\t\tc.compileWithStatement(v, needResult)\n\tcase *ast.DebuggerStatement:\n\tdefault:\n\t\tc.assert(false, int(v.Idx0())-1, \"Unknown statement type: %T\", v)\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *compiler) compileLabeledStatement(v *ast.LabelledStatement, needResult bool) {\n\tlabel := v.Label.Name\n\tif c.scope.strict {\n\t\tc.checkIdentifierName(label, int(v.Label.Idx)-1)\n\t}\n\tfor b := c.block; b != nil; b = b.outer {\n\t\tif b.label == label {\n\t\t\tc.throwSyntaxError(int(v.Label.Idx-1), \"Label '%s' has already been declared\", label)\n\t\t}\n\t}\n\tswitch s := v.Statement.(type) {\n\tcase *ast.ForInStatement:\n\t\tc.compileLabeledForInStatement(s, needResult, label)\n\tcase *ast.ForOfStatement:\n\t\tc.compileLabeledForOfStatement(s, needResult, label)\n\tcase *ast.ForStatement:\n\t\tc.compileLabeledForStatement(s, needResult, label)\n\tcase *ast.WhileStatement:\n\t\tc.compileLabeledWhileStatement(s, needResult, label)\n\tcase *ast.DoWhileStatement:\n\t\tc.compileLabeledDoWhileStatement(s, needResult, label)\n\tdefault:\n\t\tc.compileGenericLabeledStatement(s, needResult, label)\n\t}\n}\n\nfunc (c *compiler) updateEnterBlock(enter *enterBlock) {\n\tscope := c.scope\n\tstashSize, stackSize := 0, 0\n\tif scope.dynLookup {\n\t\tstashSize = len(scope.bindings)\n\t\tenter.names = scope.makeNamesMap()\n\t} else {\n\t\tfor _, b := range scope.bindings {\n\t\t\tif b.inStash {\n\t\t\t\tstashSize++\n\t\t\t} else {\n\t\t\t\tstackSize++\n\t\t\t}\n\t\t}\n\t}\n\tenter.stashSize, enter.stackSize = uint32(stashSize), uint32(stackSize)\n}\n\nfunc (c *compiler) compileTryStatement(v *ast.TryStatement, needResult bool) {\n\tc.block = &block{\n\t\ttyp:   blockTry,\n\t\touter: c.block,\n\t}\n\tvar lp int\n\tvar bodyNeedResult bool\n\tvar finallyBreaking *block\n\tif v.Finally != nil {\n\t\tlp, finallyBreaking = c.scanStatements(v.Finally.List)\n\t}\n\tif finallyBreaking != nil {\n\t\tc.block.breaking = finallyBreaking\n\t\tif lp == -1 {\n\t\t\tbodyNeedResult = finallyBreaking.needResult\n\t\t}\n\t} else {\n\t\tbodyNeedResult = needResult\n\t}\n\tlbl := len(c.p.code)\n\tc.emit(nil)\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tc.compileBlockStatement(v.Body, bodyNeedResult)\n\tvar catchOffset int\n\tif v.Catch != nil {\n\t\tlbl2 := len(c.p.code) // jump over the catch block\n\t\tc.emit(nil)\n\t\tcatchOffset = len(c.p.code) - lbl\n\t\tif v.Catch.Parameter != nil {\n\t\t\tc.block = &block{\n\t\t\t\ttyp:   blockScope,\n\t\t\t\touter: c.block,\n\t\t\t}\n\t\t\tc.newBlockScope()\n\t\t\tlist := v.Catch.Body.List\n\t\t\tfuncs := c.extractFunctions(list)\n\t\t\tif _, ok := v.Catch.Parameter.(ast.Pattern); ok {\n\t\t\t\t// add anonymous binding for the catch parameter, note it must be first\n\t\t\t\tc.scope.addBinding(int(v.Catch.Idx0()) - 1)\n\t\t\t}\n\t\t\tc.createBindings(v.Catch.Parameter, func(name unistring.String, offset int) {\n\t\t\t\tif c.scope.strict {\n\t\t\t\t\tswitch name {\n\t\t\t\t\tcase \"arguments\", \"eval\":\n\t\t\t\t\t\tc.throwSyntaxError(offset, \"Catch variable may not be eval or arguments in strict mode\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.scope.bindNameLexical(name, true, offset)\n\t\t\t})\n\t\t\tenter := &enterBlock{}\n\t\t\tc.emit(enter)\n\t\t\tif pattern, ok := v.Catch.Parameter.(ast.Pattern); ok {\n\t\t\t\tc.scope.bindings[0].emitGet()\n\t\t\t\tc.emitPattern(pattern, func(target, init compiledExpr) {\n\t\t\t\t\tc.emitPatternLexicalAssign(target, init)\n\t\t\t\t}, false)\n\t\t\t}\n\t\t\tfor _, decl := range funcs {\n\t\t\t\tc.scope.bindNameLexical(decl.Function.Name.Name, true, int(decl.Function.Name.Idx1())-1)\n\t\t\t}\n\t\t\tc.compileLexicalDeclarations(list, true)\n\t\t\tc.compileFunctions(funcs)\n\t\t\tc.compileStatements(list, bodyNeedResult)\n\t\t\tc.leaveScopeBlock(enter)\n\t\t\tif c.scope.dynLookup || c.scope.bindings[0].inStash {\n\t\t\t\tc.p.code[lbl+catchOffset] = &enterCatchBlock{\n\t\t\t\t\tnames:     enter.names,\n\t\t\t\t\tstashSize: enter.stashSize,\n\t\t\t\t\tstackSize: enter.stackSize,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenter.stackSize--\n\t\t\t}\n\t\t\tc.popScope()\n\t\t} else {\n\t\t\tc.emit(pop)\n\t\t\tc.compileBlockStatement(v.Catch.Body, bodyNeedResult)\n\t\t}\n\t\tc.p.code[lbl2] = jump(len(c.p.code) - lbl2)\n\t}\n\tvar finallyOffset int\n\tif v.Finally != nil {\n\t\tc.emit(enterFinally{})\n\t\tfinallyOffset = len(c.p.code) - lbl // finallyOffset should not include enterFinally\n\t\tif bodyNeedResult && finallyBreaking != nil && lp == -1 {\n\t\t\tc.emit(clearResult)\n\t\t}\n\t\tc.compileBlockStatement(v.Finally, false)\n\t\tc.emit(leaveFinally{})\n\t} else {\n\t\tc.emit(leaveTry{})\n\t}\n\tc.p.code[lbl] = try{catchOffset: int32(catchOffset), finallyOffset: int32(finallyOffset)}\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) addSrcMap(node ast.Node) {\n\tc.p.addSrcMap(int(node.Idx0()) - 1)\n}\n\nfunc (c *compiler) compileThrowStatement(v *ast.ThrowStatement) {\n\tc.compileExpression(v.Argument).emitGetter(true)\n\tc.addSrcMap(v)\n\tc.emit(throw)\n}\n\nfunc (c *compiler) compileDoWhileStatement(v *ast.DoWhileStatement, needResult bool) {\n\tc.compileLabeledDoWhileStatement(v, needResult, \"\")\n}\n\nfunc (c *compiler) compileLabeledDoWhileStatement(v *ast.DoWhileStatement, needResult bool, label unistring.String) {\n\tc.block = &block{\n\t\ttyp:        blockLoop,\n\t\touter:      c.block,\n\t\tlabel:      label,\n\t\tneedResult: needResult,\n\t}\n\n\tstart := len(c.p.code)\n\tc.compileStatement(v.Body, needResult)\n\tc.block.cont = len(c.p.code)\n\tc.emitExpr(c.compileExpression(v.Test), true)\n\tc.emit(jeq(start - len(c.p.code)))\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) compileForStatement(v *ast.ForStatement, needResult bool) {\n\tc.compileLabeledForStatement(v, needResult, \"\")\n}\n\nfunc (c *compiler) compileForHeadLexDecl(decl *ast.LexicalDeclaration, needResult bool) *enterBlock {\n\tc.block = &block{\n\t\ttyp:        blockIterScope,\n\t\touter:      c.block,\n\t\tneedResult: needResult,\n\t}\n\n\tc.newBlockScope()\n\tenterIterBlock := &enterBlock{}\n\tc.emit(enterIterBlock)\n\tc.createLexicalBindings(decl)\n\tc.compileLexicalDeclaration(decl)\n\treturn enterIterBlock\n}\n\nfunc (c *compiler) compileLabeledForStatement(v *ast.ForStatement, needResult bool, label unistring.String) {\n\tloopBlock := &block{\n\t\ttyp:        blockLoop,\n\t\touter:      c.block,\n\t\tlabel:      label,\n\t\tneedResult: needResult,\n\t}\n\tc.block = loopBlock\n\n\tvar enterIterBlock *enterBlock\n\tswitch init := v.Initializer.(type) {\n\tcase nil:\n\t\t// no-op\n\tcase *ast.ForLoopInitializerLexicalDecl:\n\t\tenterIterBlock = c.compileForHeadLexDecl(&init.LexicalDeclaration, needResult)\n\tcase *ast.ForLoopInitializerVarDeclList:\n\t\tfor _, expr := range init.List {\n\t\t\tc.compileVarBinding(expr)\n\t\t}\n\tcase *ast.ForLoopInitializerExpression:\n\t\tc.compileExpression(init.Expression).emitGetter(false)\n\tdefault:\n\t\tc.assert(false, int(v.For)-1, \"Unsupported for loop initializer: %T\", init)\n\t\tpanic(\"unreachable\")\n\t}\n\n\tif needResult {\n\t\tc.emit(clearResult) // initial result\n\t}\n\n\tif enterIterBlock != nil {\n\t\tc.emit(jump(1))\n\t}\n\n\tstart := len(c.p.code)\n\tvar j int\n\ttestConst := false\n\tif v.Test != nil {\n\t\texpr := c.compileExpression(v.Test)\n\t\tif expr.constant() {\n\t\t\tr, ex := c.evalConst(expr)\n\t\t\tif ex == nil {\n\t\t\t\tif r.ToBoolean() {\n\t\t\t\t\ttestConst = true\n\t\t\t\t} else {\n\t\t\t\t\tleave := c.enterDummyMode()\n\t\t\t\t\tc.compileStatement(v.Body, false)\n\t\t\t\t\tif v.Update != nil {\n\t\t\t\t\t\tc.compileExpression(v.Update).emitGetter(false)\n\t\t\t\t\t}\n\t\t\t\t\tleave()\n\t\t\t\t\tgoto end\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texpr.addSrcMap()\n\t\t\t\tc.emitThrow(ex.val)\n\t\t\t\tgoto end\n\t\t\t}\n\t\t} else {\n\t\t\texpr.emitGetter(true)\n\t\t\tj = len(c.p.code)\n\t\t\tc.emit(nil)\n\t\t}\n\t}\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tc.compileStatement(v.Body, needResult)\n\tloopBlock.cont = len(c.p.code)\n\tif enterIterBlock != nil {\n\t\tc.emit(jump(1))\n\t}\n\tif v.Update != nil {\n\t\tc.compileExpression(v.Update).emitGetter(false)\n\t}\n\tif enterIterBlock != nil {\n\t\tif c.scope.needStash || c.scope.isDynamic() {\n\t\t\tc.p.code[start-1] = copyStash{}\n\t\t\tc.p.code[loopBlock.cont] = copyStash{}\n\t\t} else {\n\t\t\tif l := len(c.p.code); l > loopBlock.cont {\n\t\t\t\tloopBlock.cont++\n\t\t\t} else {\n\t\t\t\tc.p.code = c.p.code[:l-1]\n\t\t\t}\n\t\t}\n\t}\n\tc.emit(jump(start - len(c.p.code)))\n\tif v.Test != nil {\n\t\tif !testConst {\n\t\t\tc.p.code[j] = jne(len(c.p.code) - j)\n\t\t}\n\t}\nend:\n\tif enterIterBlock != nil {\n\t\tc.leaveScopeBlock(enterIterBlock)\n\t\tc.popScope()\n\t}\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) compileForInStatement(v *ast.ForInStatement, needResult bool) {\n\tc.compileLabeledForInStatement(v, needResult, \"\")\n}\n\nfunc (c *compiler) compileForInto(into ast.ForInto, needResult bool) (enter *enterBlock) {\n\tswitch into := into.(type) {\n\tcase *ast.ForIntoExpression:\n\t\tc.compileExpression(into.Expression).emitSetter(&c.enumGetExpr, false)\n\tcase *ast.ForIntoVar:\n\t\tif c.scope.strict && into.Binding.Initializer != nil {\n\t\t\tc.throwSyntaxError(int(into.Binding.Initializer.Idx0())-1, \"for-in loop variable declaration may not have an initializer.\")\n\t\t}\n\t\tswitch target := into.Binding.Target.(type) {\n\t\tcase *ast.Identifier:\n\t\t\tc.compileIdentifierExpression(target).emitSetter(&c.enumGetExpr, false)\n\t\tcase ast.Pattern:\n\t\t\tc.emit(enumGet)\n\t\t\tc.emitPattern(target, c.emitPatternVarAssign, false)\n\t\tdefault:\n\t\t\tc.throwSyntaxError(int(target.Idx0()-1), \"unsupported for-in var target: %T\", target)\n\t\t}\n\tcase *ast.ForDeclaration:\n\n\t\tc.block = &block{\n\t\t\ttyp:        blockIterScope,\n\t\t\touter:      c.block,\n\t\t\tneedResult: needResult,\n\t\t}\n\n\t\tc.newBlockScope()\n\t\tenter = &enterBlock{}\n\t\tc.emit(enter)\n\t\tswitch target := into.Target.(type) {\n\t\tcase *ast.Identifier:\n\t\t\tb := c.createLexicalIdBinding(target.Name, into.IsConst, int(into.Idx)-1)\n\t\t\tc.emit(enumGet)\n\t\t\tb.emitInitP()\n\t\tcase ast.Pattern:\n\t\t\tc.createLexicalBinding(target, into.IsConst)\n\t\t\tc.emit(enumGet)\n\t\t\tc.emitPattern(target, func(target, init compiledExpr) {\n\t\t\t\tc.emitPatternLexicalAssign(target, init)\n\t\t\t}, false)\n\t\tdefault:\n\t\t\tc.assert(false, int(into.Idx)-1, \"Unsupported ForBinding: %T\", into.Target)\n\t\t}\n\tdefault:\n\t\tc.assert(false, int(into.Idx0())-1, \"Unsupported for-into: %T\", into)\n\t\tpanic(\"unreachable\")\n\t}\n\n\treturn\n}\n\nfunc (c *compiler) compileLabeledForInOfStatement(into ast.ForInto, source ast.Expression, body ast.Statement, iter, needResult bool, label unistring.String) {\n\tc.block = &block{\n\t\ttyp:        blockLoopEnum,\n\t\touter:      c.block,\n\t\tlabel:      label,\n\t\tneedResult: needResult,\n\t}\n\tenterPos := -1\n\tif forDecl, ok := into.(*ast.ForDeclaration); ok {\n\t\tc.block = &block{\n\t\t\ttyp:        blockScope,\n\t\t\touter:      c.block,\n\t\t\tneedResult: false,\n\t\t}\n\t\tc.newBlockScope()\n\t\tenterPos = len(c.p.code)\n\t\tc.emit(jump(1))\n\t\tc.createLexicalBinding(forDecl.Target, forDecl.IsConst)\n\t}\n\tc.compileExpression(source).emitGetter(true)\n\tif enterPos != -1 {\n\t\ts := c.scope\n\t\tused := len(c.block.breaks) > 0 || s.isDynamic()\n\t\tif !used {\n\t\t\tfor _, b := range s.bindings {\n\t\t\t\tif b.useCount() > 0 {\n\t\t\t\t\tused = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif used {\n\t\t\t// We need the stack untouched because it contains the source.\n\t\t\t// This is not the most optimal way, but it's an edge case, hopefully quite rare.\n\t\t\tfor _, b := range s.bindings {\n\t\t\t\tb.moveToStash()\n\t\t\t}\n\t\t\tenter := &enterBlock{}\n\t\t\tc.p.code[enterPos] = enter\n\t\t\tc.leaveScopeBlock(enter)\n\t\t} else {\n\t\t\tc.block = c.block.outer\n\t\t}\n\t\tc.popScope()\n\t}\n\tif iter {\n\t\tc.emit(iterateP)\n\t} else {\n\t\tc.emit(enumerate)\n\t}\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tstart := len(c.p.code)\n\tc.block.cont = start\n\tc.emit(nil)\n\tenterIterBlock := c.compileForInto(into, needResult)\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tc.compileStatement(body, needResult)\n\tif enterIterBlock != nil {\n\t\tc.leaveScopeBlock(enterIterBlock)\n\t\tc.popScope()\n\t}\n\tc.emit(jump(start - len(c.p.code)))\n\tif iter {\n\t\tc.p.code[start] = iterNext(len(c.p.code) - start)\n\t} else {\n\t\tc.p.code[start] = enumNext(len(c.p.code) - start)\n\t}\n\tc.emit(enumPop, jump(2))\n\tc.leaveBlock()\n\tc.emit(enumPopClose)\n}\n\nfunc (c *compiler) compileLabeledForInStatement(v *ast.ForInStatement, needResult bool, label unistring.String) {\n\tc.compileLabeledForInOfStatement(v.Into, v.Source, v.Body, false, needResult, label)\n}\n\nfunc (c *compiler) compileForOfStatement(v *ast.ForOfStatement, needResult bool) {\n\tc.compileLabeledForOfStatement(v, needResult, \"\")\n}\n\nfunc (c *compiler) compileLabeledForOfStatement(v *ast.ForOfStatement, needResult bool, label unistring.String) {\n\tc.compileLabeledForInOfStatement(v.Into, v.Source, v.Body, true, needResult, label)\n}\n\nfunc (c *compiler) compileWhileStatement(v *ast.WhileStatement, needResult bool) {\n\tc.compileLabeledWhileStatement(v, needResult, \"\")\n}\n\nfunc (c *compiler) compileLabeledWhileStatement(v *ast.WhileStatement, needResult bool, label unistring.String) {\n\tc.block = &block{\n\t\ttyp:        blockLoop,\n\t\touter:      c.block,\n\t\tlabel:      label,\n\t\tneedResult: needResult,\n\t}\n\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tstart := len(c.p.code)\n\tc.block.cont = start\n\texpr := c.compileExpression(v.Test)\n\ttestTrue := false\n\tvar j int\n\tif expr.constant() {\n\t\tif t, ex := c.evalConst(expr); ex == nil {\n\t\t\tif t.ToBoolean() {\n\t\t\t\ttestTrue = true\n\t\t\t} else {\n\t\t\t\tc.compileStatementDummy(v.Body)\n\t\t\t\tgoto end\n\t\t\t}\n\t\t} else {\n\t\t\tc.emitThrow(ex.val)\n\t\t\tgoto end\n\t\t}\n\t} else {\n\t\texpr.emitGetter(true)\n\t\tj = len(c.p.code)\n\t\tc.emit(nil)\n\t}\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tc.compileStatement(v.Body, needResult)\n\tc.emit(jump(start - len(c.p.code)))\n\tif !testTrue {\n\t\tc.p.code[j] = jne(len(c.p.code) - j)\n\t}\nend:\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) compileEmptyStatement(needResult bool) {\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n}\n\nfunc (c *compiler) compileBranchStatement(v *ast.BranchStatement) {\n\tswitch v.Token {\n\tcase token.BREAK:\n\t\tc.compileBreak(v.Label, v.Idx)\n\tcase token.CONTINUE:\n\t\tc.compileContinue(v.Label, v.Idx)\n\tdefault:\n\t\tc.assert(false, int(v.Idx0())-1, \"Unknown branch statement token: %s\", v.Token.String())\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *compiler) findBranchBlock(st *ast.BranchStatement) *block {\n\tswitch st.Token {\n\tcase token.BREAK:\n\t\treturn c.findBreakBlock(st.Label, true)\n\tcase token.CONTINUE:\n\t\treturn c.findBreakBlock(st.Label, false)\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) findBreakBlock(label *ast.Identifier, isBreak bool) (res *block) {\n\tif label != nil {\n\t\tvar found *block\n\t\tfor b := c.block; b != nil; b = b.outer {\n\t\t\tif res == nil {\n\t\t\t\tif bb := b.breaking; bb != nil {\n\t\t\t\t\tres = bb\n\t\t\t\t\tif isBreak {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif b.label == label.Name {\n\t\t\t\tfound = b\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isBreak && found != nil && found.typ != blockLoop && found.typ != blockLoopEnum {\n\t\t\tc.throwSyntaxError(int(label.Idx)-1, \"Illegal continue statement: '%s' does not denote an iteration statement\", label.Name)\n\t\t}\n\t\tif res == nil {\n\t\t\tres = found\n\t\t}\n\t} else {\n\t\t// find the nearest loop or switch (if break)\n\tL:\n\t\tfor b := c.block; b != nil; b = b.outer {\n\t\t\tif bb := b.breaking; bb != nil {\n\t\t\t\treturn bb\n\t\t\t}\n\t\t\tswitch b.typ {\n\t\t\tcase blockLoop, blockLoopEnum:\n\t\t\t\tres = b\n\t\t\t\tbreak L\n\t\t\tcase blockSwitch:\n\t\t\t\tif isBreak {\n\t\t\t\t\tres = b\n\t\t\t\t\tbreak L\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (c *compiler) emitBlockExitCode(label *ast.Identifier, idx file.Idx, isBreak bool) *block {\n\tblock := c.findBreakBlock(label, isBreak)\n\tif block == nil {\n\t\tc.throwSyntaxError(int(idx)-1, \"Could not find block\")\n\t\tpanic(\"unreachable\")\n\t}\n\tcontForLoop := !isBreak && block.typ == blockLoop\nL:\n\tfor b := c.block; b != block; b = b.outer {\n\t\tswitch b.typ {\n\t\tcase blockIterScope:\n\t\t\t// blockIterScope in 'for' loops is shared across iterations, so\n\t\t\t// continue should not pop it.\n\t\t\tif contForLoop && b.outer == block {\n\t\t\t\tbreak L\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase blockScope:\n\t\t\tb.breaks = append(b.breaks, len(c.p.code))\n\t\t\tc.emit(nil)\n\t\tcase blockTry:\n\t\t\tc.emit(leaveTry{})\n\t\tcase blockWith:\n\t\t\tc.emit(leaveWith)\n\t\tcase blockLoopEnum:\n\t\t\tc.emit(enumPopClose)\n\t\t}\n\t}\n\treturn block\n}\n\nfunc (c *compiler) compileBreak(label *ast.Identifier, idx file.Idx) {\n\tblock := c.emitBlockExitCode(label, idx, true)\n\tblock.breaks = append(block.breaks, len(c.p.code))\n\tc.emit(nil)\n}\n\nfunc (c *compiler) compileContinue(label *ast.Identifier, idx file.Idx) {\n\tblock := c.emitBlockExitCode(label, idx, false)\n\tblock.conts = append(block.conts, len(c.p.code))\n\tc.emit(nil)\n}\n\nfunc (c *compiler) compileIfBody(s ast.Statement, needResult bool) {\n\tif !c.scope.strict {\n\t\tif s, ok := s.(*ast.FunctionDeclaration); ok && !s.Function.Async && !s.Function.Generator {\n\t\t\tc.compileFunction(s)\n\t\t\tif needResult {\n\t\t\t\tc.emit(clearResult)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tc.compileStatement(s, needResult)\n}\n\nfunc (c *compiler) compileIfBodyDummy(s ast.Statement) {\n\tleave := c.enterDummyMode()\n\tdefer leave()\n\tc.compileIfBody(s, false)\n}\n\nfunc (c *compiler) compileIfStatement(v *ast.IfStatement, needResult bool) {\n\ttest := c.compileExpression(v.Test)\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\tif test.constant() {\n\t\tr, ex := c.evalConst(test)\n\t\tif ex != nil {\n\t\t\ttest.addSrcMap()\n\t\t\tc.emitThrow(ex.val)\n\t\t\treturn\n\t\t}\n\t\tif r.ToBoolean() {\n\t\t\tc.compileIfBody(v.Consequent, needResult)\n\t\t\tif v.Alternate != nil {\n\t\t\t\tc.compileIfBodyDummy(v.Alternate)\n\t\t\t}\n\t\t} else {\n\t\t\tc.compileIfBodyDummy(v.Consequent)\n\t\t\tif v.Alternate != nil {\n\t\t\t\tc.compileIfBody(v.Alternate, needResult)\n\t\t\t} else {\n\t\t\t\tif needResult {\n\t\t\t\t\tc.emit(clearResult)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\ttest.emitGetter(true)\n\tjmp := len(c.p.code)\n\tc.emit(nil)\n\tc.compileIfBody(v.Consequent, needResult)\n\tif v.Alternate != nil {\n\t\tjmp1 := len(c.p.code)\n\t\tc.emit(nil)\n\t\tc.p.code[jmp] = jne(len(c.p.code) - jmp)\n\t\tc.compileIfBody(v.Alternate, needResult)\n\t\tc.p.code[jmp1] = jump(len(c.p.code) - jmp1)\n\t} else {\n\t\tif needResult {\n\t\t\tc.emit(jump(2))\n\t\t\tc.p.code[jmp] = jne(len(c.p.code) - jmp)\n\t\t\tc.emit(clearResult)\n\t\t} else {\n\t\t\tc.p.code[jmp] = jne(len(c.p.code) - jmp)\n\t\t}\n\t}\n}\n\nfunc (c *compiler) compileReturnStatement(v *ast.ReturnStatement) {\n\tif s := c.scope.nearestFunction(); s != nil && s.funcType == funcClsInit {\n\t\tc.throwSyntaxError(int(v.Return)-1, \"Illegal return statement\")\n\t}\n\tif v.Argument != nil {\n\t\tc.emitExpr(c.compileExpression(v.Argument), true)\n\t} else {\n\t\tc.emit(loadUndef)\n\t}\n\tfor b := c.block; b != nil; b = b.outer {\n\t\tswitch b.typ {\n\t\tcase blockTry:\n\t\t\tc.emit(saveResult, leaveTry{}, loadResult)\n\t\tcase blockLoopEnum:\n\t\t\tc.emit(enumPopClose)\n\t\t}\n\t}\n\tif s := c.scope.nearestFunction(); s != nil && s.funcType == funcDerivedCtor {\n\t\tb := s.boundNames[thisBindingName]\n\t\tc.assert(b != nil, int(v.Return)-1, \"Derived constructor, but no 'this' binding\")\n\t\tb.markAccessPoint()\n\t}\n\tc.emit(ret)\n}\n\nfunc (c *compiler) checkVarConflict(name unistring.String, offset int) {\n\tfor sc := c.scope; sc != nil; sc = sc.outer {\n\t\tif b, exists := sc.boundNames[name]; exists && !b.isVar && !(b.isArg && sc != c.scope) {\n\t\t\tc.throwSyntaxError(offset, \"Identifier '%s' has already been declared\", name)\n\t\t}\n\t\tif sc.isFunction() {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (c *compiler) emitVarAssign(name unistring.String, offset int, init compiledExpr) {\n\tc.checkVarConflict(name, offset)\n\tif init != nil {\n\t\tb, noDyn := c.scope.lookupName(name)\n\t\tif noDyn {\n\t\t\tc.emitNamedOrConst(init, name)\n\t\t\tc.p.addSrcMap(offset)\n\t\t\tb.emitInitP()\n\t\t} else {\n\t\t\tc.emitVarRef(name, offset, b)\n\t\t\tc.emitNamedOrConst(init, name)\n\t\t\tc.p.addSrcMap(offset)\n\t\t\tc.emit(initValueP)\n\t\t}\n\t}\n}\n\nfunc (c *compiler) compileVarBinding(expr *ast.Binding) {\n\tswitch target := expr.Target.(type) {\n\tcase *ast.Identifier:\n\t\tc.emitVarAssign(target.Name, int(target.Idx)-1, c.compileExpression(expr.Initializer))\n\tcase ast.Pattern:\n\t\tc.compileExpression(expr.Initializer).emitGetter(true)\n\t\tc.emitPattern(target, c.emitPatternVarAssign, false)\n\tdefault:\n\t\tc.throwSyntaxError(int(target.Idx0()-1), \"unsupported variable binding target: %T\", target)\n\t}\n}\n\nfunc (c *compiler) emitLexicalAssign(name unistring.String, offset int, init compiledExpr) {\n\tb := c.scope.boundNames[name]\n\tc.assert(b != nil, offset, \"Lexical declaration for an unbound name\")\n\tif init != nil {\n\t\tc.emitNamedOrConst(init, name)\n\t\tc.p.addSrcMap(offset)\n\t} else {\n\t\tif b.isConst {\n\t\t\tc.throwSyntaxError(offset, \"Missing initializer in const declaration\")\n\t\t}\n\t\tc.emit(loadUndef)\n\t}\n\tb.emitInitP()\n}\n\nfunc (c *compiler) emitPatternVarAssign(target, init compiledExpr) {\n\tid := target.(*compiledIdentifierExpr)\n\tc.emitVarAssign(id.name, id.offset, init)\n}\n\nfunc (c *compiler) emitPatternLexicalAssign(target, init compiledExpr) {\n\tid := target.(*compiledIdentifierExpr)\n\tc.emitLexicalAssign(id.name, id.offset, init)\n}\n\nfunc (c *compiler) emitPatternAssign(target, init compiledExpr) {\n\tif id, ok := target.(*compiledIdentifierExpr); ok {\n\t\tb, noDyn := c.scope.lookupName(id.name)\n\t\tif noDyn {\n\t\t\tc.emitNamedOrConst(init, id.name)\n\t\t\tb.emitSetP()\n\t\t} else {\n\t\t\tc.emitVarRef(id.name, id.offset, b)\n\t\t\tc.emitNamedOrConst(init, id.name)\n\t\t\tc.emit(putValueP)\n\t\t}\n\t} else {\n\t\ttarget.emitRef()\n\t\tc.emitExpr(init, true)\n\t\tc.emit(putValueP)\n\t}\n}\n\nfunc (c *compiler) compileLexicalBinding(expr *ast.Binding) {\n\tswitch target := expr.Target.(type) {\n\tcase *ast.Identifier:\n\t\tc.emitLexicalAssign(target.Name, int(target.Idx)-1, c.compileExpression(expr.Initializer))\n\tcase ast.Pattern:\n\t\tc.compileExpression(expr.Initializer).emitGetter(true)\n\t\tc.emitPattern(target, func(target, init compiledExpr) {\n\t\t\tc.emitPatternLexicalAssign(target, init)\n\t\t}, false)\n\tdefault:\n\t\tc.throwSyntaxError(int(target.Idx0()-1), \"unsupported lexical binding target: %T\", target)\n\t}\n}\n\nfunc (c *compiler) compileVariableStatement(v *ast.VariableStatement) {\n\tfor _, expr := range v.List {\n\t\tc.compileVarBinding(expr)\n\t}\n}\n\nfunc (c *compiler) compileLexicalDeclaration(v *ast.LexicalDeclaration) {\n\tfor _, e := range v.List {\n\t\tc.compileLexicalBinding(e)\n\t}\n}\n\nfunc (c *compiler) isEmptyResult(st ast.Statement) bool {\n\tswitch st := st.(type) {\n\tcase *ast.EmptyStatement, *ast.VariableStatement, *ast.LexicalDeclaration, *ast.FunctionDeclaration,\n\t\t*ast.ClassDeclaration, *ast.BranchStatement, *ast.DebuggerStatement:\n\t\treturn true\n\tcase *ast.LabelledStatement:\n\t\treturn c.isEmptyResult(st.Statement)\n\tcase *ast.BlockStatement:\n\t\tfor _, s := range st.List {\n\t\t\tif _, ok := s.(*ast.BranchStatement); ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif !c.isEmptyResult(s) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *compiler) scanStatements(list []ast.Statement) (lastProducingIdx int, breakingBlock *block) {\n\tlastProducingIdx = -1\n\tfor i, st := range list {\n\t\tif bs, ok := st.(*ast.BranchStatement); ok {\n\t\t\tif blk := c.findBranchBlock(bs); blk != nil {\n\t\t\t\tbreakingBlock = blk\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif !c.isEmptyResult(st) {\n\t\t\tlastProducingIdx = i\n\t\t}\n\t}\n\treturn\n}\n\nfunc (c *compiler) compileStatementsNeedResult(list []ast.Statement, lastProducingIdx int) {\n\tif lastProducingIdx >= 0 {\n\t\tfor _, st := range list[:lastProducingIdx] {\n\t\t\tif _, ok := st.(*ast.FunctionDeclaration); ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.compileStatement(st, false)\n\t\t}\n\t\tc.compileStatement(list[lastProducingIdx], true)\n\t}\n\tvar leave func()\n\tdefer func() {\n\t\tif leave != nil {\n\t\t\tleave()\n\t\t}\n\t}()\n\tfor _, st := range list[lastProducingIdx+1:] {\n\t\tif _, ok := st.(*ast.FunctionDeclaration); ok {\n\t\t\tcontinue\n\t\t}\n\t\tc.compileStatement(st, false)\n\t\tif leave == nil {\n\t\t\tif _, ok := st.(*ast.BranchStatement); ok {\n\t\t\t\tleave = c.enterDummyMode()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *compiler) compileStatements(list []ast.Statement, needResult bool) {\n\tlastProducingIdx, blk := c.scanStatements(list)\n\tif blk != nil {\n\t\tneedResult = blk.needResult\n\t}\n\tif needResult {\n\t\tc.compileStatementsNeedResult(list, lastProducingIdx)\n\t\treturn\n\t}\n\tfor _, st := range list {\n\t\tif _, ok := st.(*ast.FunctionDeclaration); ok {\n\t\t\tcontinue\n\t\t}\n\t\tc.compileStatement(st, false)\n\t}\n}\n\nfunc (c *compiler) compileGenericLabeledStatement(v ast.Statement, needResult bool, label unistring.String) {\n\tc.block = &block{\n\t\ttyp:        blockLabel,\n\t\touter:      c.block,\n\t\tlabel:      label,\n\t\tneedResult: needResult,\n\t}\n\tc.compileStatement(v, needResult)\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) compileBlockStatement(v *ast.BlockStatement, needResult bool) {\n\tvar scopeDeclared bool\n\tfuncs := c.extractFunctions(v.List)\n\tif len(funcs) > 0 {\n\t\tc.newBlockScope()\n\t\tscopeDeclared = true\n\t}\n\tc.createFunctionBindings(funcs)\n\tscopeDeclared = c.compileLexicalDeclarations(v.List, scopeDeclared)\n\n\tvar enter *enterBlock\n\tif scopeDeclared {\n\t\tc.block = &block{\n\t\t\touter:      c.block,\n\t\t\ttyp:        blockScope,\n\t\t\tneedResult: needResult,\n\t\t}\n\t\tenter = &enterBlock{}\n\t\tc.emit(enter)\n\t}\n\tc.compileFunctions(funcs)\n\tc.compileStatements(v.List, needResult)\n\tif scopeDeclared {\n\t\tc.leaveScopeBlock(enter)\n\t\tc.popScope()\n\t}\n}\n\nfunc (c *compiler) compileExpressionStatement(v *ast.ExpressionStatement, needResult bool) {\n\tc.emitExpr(c.compileExpression(v.Expression), needResult)\n\tif needResult {\n\t\tc.emit(saveResult)\n\t}\n}\n\nfunc (c *compiler) compileWithStatement(v *ast.WithStatement, needResult bool) {\n\tif c.scope.strict {\n\t\tc.throwSyntaxError(int(v.With)-1, \"Strict mode code may not include a with statement\")\n\t\treturn\n\t}\n\tc.compileExpression(v.Object).emitGetter(true)\n\tc.emit(enterWith)\n\tc.block = &block{\n\t\touter:      c.block,\n\t\ttyp:        blockWith,\n\t\tneedResult: needResult,\n\t}\n\tc.newBlockScope()\n\tc.scope.dynamic = true\n\tc.compileStatement(v.Body, needResult)\n\tc.emit(leaveWith)\n\tc.leaveBlock()\n\tc.popScope()\n}\n\nfunc (c *compiler) compileSwitchStatement(v *ast.SwitchStatement, needResult bool) {\n\tc.block = &block{\n\t\ttyp:        blockSwitch,\n\t\touter:      c.block,\n\t\tneedResult: needResult,\n\t}\n\n\tc.compileExpression(v.Discriminant).emitGetter(true)\n\n\tvar funcs []*ast.FunctionDeclaration\n\tfor _, s := range v.Body {\n\t\tf := c.extractFunctions(s.Consequent)\n\t\tfuncs = append(funcs, f...)\n\t}\n\tvar scopeDeclared bool\n\tif len(funcs) > 0 {\n\t\tc.newBlockScope()\n\t\tscopeDeclared = true\n\t\tc.createFunctionBindings(funcs)\n\t}\n\n\tfor _, s := range v.Body {\n\t\tscopeDeclared = c.compileLexicalDeclarations(s.Consequent, scopeDeclared)\n\t}\n\n\tvar enter *enterBlock\n\tvar db *binding\n\tif scopeDeclared {\n\t\tc.block = &block{\n\t\t\ttyp:        blockScope,\n\t\t\touter:      c.block,\n\t\t\tneedResult: needResult,\n\t\t}\n\t\tenter = &enterBlock{}\n\t\tc.emit(enter)\n\t\t// create anonymous variable for the discriminant\n\t\tbindings := c.scope.bindings\n\t\tvar bb []*binding\n\t\tif cap(bindings) == len(bindings) {\n\t\t\tbb = make([]*binding, len(bindings)+1)\n\t\t} else {\n\t\t\tbb = bindings[:len(bindings)+1]\n\t\t}\n\t\tcopy(bb[1:], bindings)\n\t\tdb = &binding{\n\t\t\tscope:    c.scope,\n\t\t\tisConst:  true,\n\t\t\tisStrict: true,\n\t\t}\n\t\tbb[0] = db\n\t\tc.scope.bindings = bb\n\t}\n\n\tc.compileFunctions(funcs)\n\n\tif needResult {\n\t\tc.emit(clearResult)\n\t}\n\n\tjumps := make([]int, len(v.Body))\n\n\tfor i, s := range v.Body {\n\t\tif s.Test != nil {\n\t\t\tif db != nil {\n\t\t\t\tdb.emitGet()\n\t\t\t} else {\n\t\t\t\tc.emit(dup)\n\t\t\t}\n\t\t\tc.compileExpression(s.Test).emitGetter(true)\n\t\t\tc.emit(op_strict_eq)\n\t\t\tif db != nil {\n\t\t\t\tc.emit(jne(2))\n\t\t\t} else {\n\t\t\t\tc.emit(jne(3), pop)\n\t\t\t}\n\t\t\tjumps[i] = len(c.p.code)\n\t\t\tc.emit(nil)\n\t\t}\n\t}\n\n\tif db == nil {\n\t\tc.emit(pop)\n\t}\n\tjumpNoMatch := -1\n\tif v.Default != -1 {\n\t\tif v.Default != 0 {\n\t\t\tjumps[v.Default] = len(c.p.code)\n\t\t\tc.emit(nil)\n\t\t}\n\t} else {\n\t\tjumpNoMatch = len(c.p.code)\n\t\tc.emit(nil)\n\t}\n\n\tfor i, s := range v.Body {\n\t\tif s.Test != nil || i != 0 {\n\t\t\tc.p.code[jumps[i]] = jump(len(c.p.code) - jumps[i])\n\t\t}\n\t\tc.compileStatements(s.Consequent, needResult)\n\t}\n\n\tif jumpNoMatch != -1 {\n\t\tc.p.code[jumpNoMatch] = jump(len(c.p.code) - jumpNoMatch)\n\t}\n\tif enter != nil {\n\t\tc.leaveScopeBlock(enter)\n\t\tenter.stackSize--\n\t\tc.popScope()\n\t}\n\tc.leaveBlock()\n}\n\nfunc (c *compiler) compileClassDeclaration(v *ast.ClassDeclaration) {\n\tc.emitLexicalAssign(v.Class.Name.Name, int(v.Class.Class)-1, c.compileClassLiteral(v.Class, false))\n}\n"
        },
        {
          "name": "compiler_test.go",
          "type": "blob",
          "size": 98.12109375,
          "content": "package goja\n\nimport (\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst TESTLIB = `\nfunction $ERROR(message) {\n\tthrow new Error(message);\n}\n\nfunction Test262Error(message) {\n  this.message = message || \"\";\n}\n\nTest262Error.prototype.toString = function () {\n  return \"Test262Error: \" + this.message;\n};\n\nTest262Error.thrower = (message) => {\n  throw new Test262Error(message);\n};\n\nfunction assert(mustBeTrue, message) {\n    if (mustBeTrue === true) {\n        return;\n    }\n\n    if (message === undefined) {\n        message = 'Expected true but got ' + String(mustBeTrue);\n    }\n    $ERROR(message);\n}\n\nassert._isSameValue = function (a, b) {\n    if (a === b) {\n        // Handle +/-0 vs. -/+0\n        return a !== 0 || 1 / a === 1 / b;\n    }\n\n    // Handle NaN vs. NaN\n    return a !== a && b !== b;\n};\n\nassert.sameValue = function (actual, expected, message) {\n    if (assert._isSameValue(actual, expected)) {\n        return;\n    }\n\n    if (message === undefined) {\n        message = '';\n    } else {\n        message += ' ';\n    }\n\n    message += 'Expected SameValue(' + String(actual) + ', ' + String(expected) + ') to be true';\n\n    $ERROR(message);\n};\n\nassert.throws = function (expectedErrorConstructor, func, message) {\n  if (typeof func !== \"function\") {\n    $ERROR('assert.throws requires two arguments: the error constructor ' +\n      'and a function to run');\n    return;\n  }\n  if (message === undefined) {\n    message = '';\n  } else {\n    message += ' ';\n  }\n\n  try {\n    func();\n  } catch (thrown) {\n    if (typeof thrown !== 'object' || thrown === null) {\n      message += 'Thrown value was not an object!';\n      $ERROR(message);\n    } else if (thrown.constructor !== expectedErrorConstructor) {\n      message += 'Expected a ' + expectedErrorConstructor.name + ' but got a ' + thrown.constructor.name;\n      $ERROR(message);\n    }\n    return;\n  }\n\n  message += 'Expected a ' + expectedErrorConstructor.name + ' to be thrown but no exception was thrown at all';\n  $ERROR(message);\n};\n\nfunction compareArray(a, b) {\n  if (b.length !== a.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (b[i] !== a[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n`\n\nconst TESTLIBX = `\n\tfunction looksNative(fn) {\n\t\treturn /native code/.test(Function.prototype.toString.call(fn));\n\t}\n\n\tfunction deepEqual(a, b) {\n\t\tif (typeof a === \"object\") {\n\t\t\tif (typeof b === \"object\") {\n\t\t\t\tif (a === b) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (Reflect.getPrototypeOf(a) !== Reflect.getPrototypeOf(b)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar keysA = Object.keys(a);\n\t\t\t\tvar keysB = Object.keys(b);\n\t\t\t\tif (keysA.length !== keysB.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!compareArray(keysA.sort(), keysB.sort())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < keysA.length; i++) {\n\t\t\t\t\tvar key = keysA[i];\n\t\t\t\t\tif (!deepEqual(a[key], b[key])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn assert._isSameValue(a, b);\n\t}\n\n\tfunction assertStack(e, expected) {\n\t\tconst lines = e.stack.split('\\n');\n\t\tassert.sameValue(lines.length, expected.length + 2, \"Stack lengths mismatch\");\n\t\tlet lnum = 1;\n\t\tfor (const [file, func, line, col] of expected) {\n\t\t\tconst expLine = func === \"\" ?\n\t\t\t\t\"\\tat \" + file + \":\" + line + \":\" + col + \"(\" :\n\t\t\t\t\"\\tat \" + func + \" (\" + file + \":\" + line + \":\" + col + \"(\";\n\t\t\tassert.sameValue(lines[lnum].substring(0, expLine.length), expLine, \"line \" + lnum);\n\t\t\tlnum++;\n\t\t}\n\t}\n`\n\nvar (\n\t// The reason it's implemented this way rather than just as _testLib = MustCompile(...)\n\t// is because when you try to debug the compiler and set a breakpoint it gets triggered during the\n\t// initialisation which is annoying.\n\t_testLib, _testLibX       *Program\n\ttestLibOnce, testLibXOnce sync.Once\n)\n\nfunc testLib() *Program {\n\ttestLibOnce.Do(func() {\n\t\t_testLib = MustCompile(\"testlib.js\", TESTLIB, false)\n\t})\n\treturn _testLib\n}\n\nfunc testLibX() *Program {\n\ttestLibXOnce.Do(func() {\n\t\t_testLibX = MustCompile(\"testlibx.js\", TESTLIBX, false)\n\t})\n\treturn _testLibX\n}\n\nfunc (r *Runtime) testPrg(p *Program, expectedResult Value, t *testing.T) {\n\tp.dumpCode(t.Logf)\n\tv, err := r.RunProgram(p)\n\tif err != nil {\n\t\tif ex, ok := err.(*Exception); ok {\n\t\t\tt.Fatalf(\"Exception: %v\", ex.String())\n\t\t}\n\t}\n\tvm := r.vm\n\tt.Logf(\"stack size: %d\", len(vm.stack))\n\tt.Logf(\"stashAllocs: %d\", vm.stashAllocs)\n\n\tif v == nil && expectedResult != nil || !v.SameAs(expectedResult) {\n\t\tt.Fatalf(\"Result: %+v, expected: %+v\", v, expectedResult)\n\t}\n\n\tif vm.sp != 0 {\n\t\tt.Fatalf(\"sp: %d\", vm.sp)\n\t}\n\n\tif l := len(vm.iterStack); l > 0 {\n\t\tt.Fatalf(\"iter stack is not empty: %d\", l)\n\t}\n}\n\nfunc (r *Runtime) testScriptWithTestLib(script string, expectedResult Value, t *testing.T) {\n\t_, err := r.RunProgram(testLib())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr.testScript(script, expectedResult, t)\n}\n\nfunc (r *Runtime) testScriptWithTestLibX(script string, expectedResult Value, t *testing.T) {\n\t_, err := r.RunProgram(testLib())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = r.RunProgram(testLibX())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr.testScript(script, expectedResult, t)\n}\n\nfunc (r *Runtime) testScript(script string, expectedResult Value, t *testing.T) {\n\tr.testPrg(MustCompile(\"test.js\", script, false), expectedResult, t)\n}\n\nfunc testScript(script string, expectedResult Value, t *testing.T) {\n\tNew().testScript(script, expectedResult, t)\n}\n\nfunc testScriptWithTestLib(script string, expectedResult Value, t *testing.T) {\n\tNew().testScriptWithTestLib(script, expectedResult, t)\n}\n\nfunc testScriptWithTestLibX(script string, expectedResult Value, t *testing.T) {\n\tNew().testScriptWithTestLibX(script, expectedResult, t)\n}\n\nfunc (r *Runtime) testAsyncFunc(src string, expectedResult Value, t *testing.T) {\n\tv, err := r.RunScript(\"test.js\", \"(async function test() {\"+src+\"\\n})()\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpromise := v.Export().(*Promise)\n\tswitch s := promise.State(); s {\n\tcase PromiseStateFulfilled:\n\t\tif res := promise.Result(); res == nil && expectedResult != nil || !res.SameAs(expectedResult) {\n\t\t\tt.Fatalf(\"Result: %+v, expected: %+v\", res, expectedResult)\n\t\t}\n\tcase PromiseStateRejected:\n\t\tres := promise.Result()\n\t\tif resObj, ok := res.(*Object); ok {\n\t\t\tif stack := resObj.Get(\"stack\"); stack != nil {\n\t\t\t\tt.Fatal(stack.String())\n\t\t\t}\n\t\t}\n\t\tt.Fatal(res.String())\n\tdefault:\n\t\tt.Fatalf(\"Unexpected promise state: %v\", s)\n\t}\n}\n\nfunc (r *Runtime) testAsyncFuncWithTestLib(src string, expectedResult Value, t *testing.T) {\n\t_, err := r.RunProgram(testLib())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr.testAsyncFunc(src, expectedResult, t)\n}\n\nfunc (r *Runtime) testAsyncFuncWithTestLibX(src string, expectedResult Value, t *testing.T) {\n\t_, err := r.RunProgram(testLib())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = r.RunProgram(testLibX())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr.testAsyncFunc(src, expectedResult, t)\n}\n\nfunc testAsyncFunc(src string, expectedResult Value, t *testing.T) {\n\tNew().testAsyncFunc(src, expectedResult, t)\n}\n\nfunc testAsyncFuncWithTestLib(src string, expectedResult Value, t *testing.T) {\n\tNew().testAsyncFuncWithTestLib(src, expectedResult, t)\n}\n\nfunc testAsyncFuncWithTestLibX(src string, expectedResult Value, t *testing.T) {\n\tNew().testAsyncFuncWithTestLibX(src, expectedResult, t)\n}\n\nfunc TestEmptyProgram(t *testing.T) {\n\tconst SCRIPT = `\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestResultEmptyBlock(t *testing.T) {\n\tconst SCRIPT = `\n\tundefined;\n\t{}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestResultVarDecl(t *testing.T) {\n\tconst SCRIPT = `\n\t7; var x = 1;\n\t`\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestResultLexDecl(t *testing.T) {\n\tconst SCRIPT = `\n\t7; {let x = 1};\n\t`\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestResultLexDeclBreak(t *testing.T) {\n\tconst SCRIPT = `\n\tL:{ 7; {let x = 1; break L;}};\n\t`\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestResultLexDeclNested(t *testing.T) {\n\tconst SCRIPT = `\n\t7; {let x = (function() { return eval(\"8; {let y = 9}\")})()};\n\t`\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestErrorProto(t *testing.T) {\n\tconst SCRIPT = `\n\tvar e = new TypeError();\n\te.name;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"TypeError\"), t)\n}\n\nfunc TestThis1(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction independent() {\n\t\treturn this.prop;\n\t}\n\tvar o = {};\n\to.b = {g: independent, prop: 42};\n\n\to.b.g();\n\t`\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestThis2(t *testing.T) {\n\tconst SCRIPT = `\nvar o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\n\no.f();\n`\n\n\ttestScript(SCRIPT, intToValue(37), t)\n}\n\nfunc TestThisStrict(t *testing.T) {\n\tconst SCRIPT = `\n\t\"use strict\";\n\n\tObject.defineProperty(Object.prototype, \"x\", { get: function () { return this; } });\n\n\t(5).x === 5;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestThisNoStrict(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(Object.prototype, \"x\", { get: function () { return this; } });\n\n\t(5).x == 5;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestNestedFuncVarResolution(t *testing.T) {\n\tconst SCRIPT = `\n\t(function outer() {\n\t\tvar v = 42;\n\t\tfunction inner() {\n\t\t\treturn v;\n\t\t}\n\t\treturn inner();\n\t})();\n`\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestNestedFuncVarResolution1(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction outer(argOuter) {\n\t\tvar called = 0;\n\t  var inner = function(argInner) {\n\t\tif (arguments.length !== 1) {\n\t\t\tthrow new Error();\n\t\t}\n\t\tcalled++;\n\t\tif (argOuter !== 1) {\n\t\t\tthrow new Error(\"argOuter\");\n\t\t}\n\t\tif (argInner !== 2) {\n\t\t\tthrow new Error(\"argInner\");\n\t\t}\n\t  };\n\t\tinner(2);\n\t}\n\touter(1);\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestCallFewerArgs(t *testing.T) {\n\tconst SCRIPT = `\nfunction A(a, b, c) {\n\treturn String(a) + \" \" + String(b) + \" \" + String(c);\n}\n\nA(1, 2);\n`\n\ttestScript(SCRIPT, asciiString(\"1 2 undefined\"), t)\n}\n\nfunc TestCallFewerArgsClosureNoArgs(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x;\n\tfunction A(a, b, c) {\n\t\tvar y = a;\n\t\tx = function() { return \" \" + y };\n\t\treturn String(a) + \" \" + String(b) + \" \" + String(c);\n\t}\n\n\tA(1, 2) + x();\n`\n\ttestScript(SCRIPT, asciiString(\"1 2 undefined 1\"), t)\n}\n\nfunc TestCallFewerArgsClosureArgs(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x;\n\tfunction A(a, b, c) {\n\t\tvar y = b;\n\t\tx = function() { return \" \" + a + \" \" + y };\n\t\treturn String(a) + \" \" + String(b) + \" \" + String(c);\n\t}\n\n\tA(1, 2) + x();\n`\n\ttestScript(SCRIPT, asciiString(\"1 2 undefined 1 2\"), t)\n}\n\nfunc TestCallMoreArgs(t *testing.T) {\n\tconst SCRIPT = `\nfunction A(a, b) {\n\tvar c = 4;\n\treturn a - b + c;\n}\n\nA(1, 2, 3);\n`\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestCallMoreArgsDynamic(t *testing.T) {\n\tconst SCRIPT = `\nfunction A(a, b) {\n\tvar c = 4;\n\tif (false) {\n\t\teval(\"\");\n\t}\n\treturn a - b + c;\n}\n\nA(1, 2, 3);\n`\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestCallLessArgsDynamic(t *testing.T) {\n\tconst SCRIPT = `\nfunction A(a, b, c) {\n\t// Make it stashful\n\tfunction B() {\n\t\treturn a;\n\t}\n\treturn String(a) + \" \" + String(b) + \" \" + String(c);\n}\n\nA(1, 2);\n`\n\ttestScript(SCRIPT, asciiString(\"1 2 undefined\"), t)\n}\n\nfunc TestCallLessArgsDynamicLocalVar(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(param) {\n\t\tvar a = 42;\n\t\tif (false) {\n\t\t\teval(\"\");\n\t\t}\n\t\treturn a;\n\t}\n\tf();\n`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\n/*\nfunc TestFib(t *testing.T) {\n\ttestScript(TEST_FIB, valueInt(9227465), t)\n}\n*/\n\nfunc TestNativeCall(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = Object(1);\n\tObject.defineProperty(o, \"test\", {value: 42});\n\to.test;\n\t`\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestJSCall(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction getter() {\n\t\treturn this.x;\n\t}\n\tvar o = Object(1);\n\to.x = 42;\n\tObject.defineProperty(o, \"test\", {get: getter});\n\to.test;\n\t`\n\ttestScript(SCRIPT, intToValue(42), t)\n\n}\n\nfunc TestLoop1(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n    \t\tvar x = 1;\n    \t\tfor (var i = 0; i < 1; i++) {\n        \t\tvar x = 2;\n    \t\t}\n    \t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestLoopBreak(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n    \t\tvar x = 1;\n    \t\tfor (var i = 0; i < 1; i++) {\n        \t\tbreak;\n        \t\tvar x = 2;\n    \t\t}\n    \t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestForLoopOptionalExpr(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n    \t\tvar x = 1;\n    \t\tfor (;;) {\n        \t\tbreak;\n        \t\tvar x = 2;\n    \t\t}\n    \t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestBlockBreak(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv = 0;\n\tB1: {\n\t\trv = 1;\n\t\tB2: {\n\t\t\trv = 2;\n\t\t\tbreak B1;\n\t\t}\n\t\trv = 3;\n\t}\n\trv;\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n\n}\n\nfunc TestTry(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar x = 1;\n\t\ttry {\n\t\t\tx = 2;\n\t\t} catch(e) {\n\t\t\tx = 3;\n\t\t} finally {\n\t\t\tx = 4;\n\t\t}\n\t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(4), t)\n}\n\nfunc TestTryOptionalCatchBinding(t *testing.T) {\n\tconst SCRIPT = `\n\ttry {\n\t\tthrow null;\n\t} catch {\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar x;\n\t\ttry {\n\t\t\tthrow 4;\n\t\t} catch(e) {\n\t\t\tx = e;\n\t\t}\n\t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(4), t)\n}\n\nfunc TestTryCatchDirectEval(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar x;\n\t\ttry {\n\t\t\tthrow 4;\n\t\t} catch(e) {\n\t\t\teval(\"x = e\");\n\t\t}\n\t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(4), t)\n}\n\nfunc TestTryExceptionInCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar x;\n\t\ttry {\n\t\t\tthrow 4;\n\t\t} catch(e) {\n\t\t\tthrow 5;\n\t\t}\n\t\treturn x;\n\t}\n\n\tvar rv;\n\ttry {\n\t\tA();\n\t} catch (e) {\n\t\trv = e;\n\t}\n\trv;\n\t`\n\ttestScript(SCRIPT, intToValue(5), t)\n}\n\nfunc TestTryContinueInCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tvar c3 = 0, fin3 = 0;\n\twhile (c3 < 2) {\n\t\ttry {\n\t\t\tthrow \"ex1\";\n\t\t} catch(er1) {\n\t\t\tc3 += 1;\n\t\t\tcontinue;\n\t\t} finally {\n\t\t\tfin3 = 1;\n\t\t}\n\t\tfin3 = 0;\n\t}\n\n\tfin3;\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestContinueInWith(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x;\n\tvar o = {x: 0};\n\tfor (var i = 0; i < 2; i++) {\n\t\twith(o) {\n\t\t\tx = i;\n\t\t\tif (i === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tx;\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryContinueInFinally(t *testing.T) {\n\tconst SCRIPT = `\n\tvar c3 = 0, fin3 = 0;\n\twhile (c3 < 2) {\n  \t\ttry {\n    \t\t\tthrow \"ex1\";\n  \t\t} catch(er1) {\n    \t\t\tc3 += 1;\n  \t\t} finally {\n    \t\t\tfin3 = 1;\n    \t\t\tcontinue;\n  \t\t}\n  \t\tfin3 = 0;\n\t}\n\n\tfin3;\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestTryBreakFinallyContinue(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 3; i++) {\n\t  try {\n\t\tbreak;\n\t  } finally {\n\t\tcontinue;\n\t  }\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryBreakFinallyContinueWithResult(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 3; i++) {\n\t  try {\n\t\ttrue;\n\t\tbreak;\n\t  } finally {\n\t\tcontinue;\n\t  }\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryBreakFinallyContinueWithResult1(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 3; i++) {\n\t  try {\n\t\ttrue;\n\t\tbreak;\n\t  } finally {\n\t\tvar x = 1;\n\t\tcontinue;\n\t  }\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryBreakFinallyContinueWithResultNested(t *testing.T) {\n\tconst SCRIPT = `\nLOOP:\n\tfor (var i = 0; i < 3; i++) {\n\t  try {\n\t\tif (true) {\n\t\t\tfalse; break;\n\t\t}\n\t  } finally {\n\t\tif (true) {\n\t\t\ttrue; continue;\n\t\t}\n\t  }\n\t}\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTryBreakOuterFinallyContinue(t *testing.T) {\n\tconst SCRIPT = `\n\tlet iCount = 0, jCount = 0;\n\tOUTER: for (let i = 0; i < 1; i++) {\n\t\tiCount++;\n\t\tfor (let j = 0; j < 2; j++) {\n\t\t\tjCount++;\n\t\t\ttry {\n\t\t\t\tbreak OUTER;\n\t\t\t} finally {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\t\"\"+iCount+jCount;\n\t`\n\ttestScript(SCRIPT, asciiString(\"12\"), t)\n}\n\nfunc TestTryIllegalContinueWithFinallyOverride(t *testing.T) {\n\tconst SCRIPT = `\n\tL: {\n\t\twhile (Math.random() > 0.5) {\n\t\t\ttry {\n\t\t\t\tcontinue L;\n\t\t\t} finally {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestTryIllegalContinueWithFinallyOverrideNoLabel(t *testing.T) {\n\tconst SCRIPT = `\n\tL: {\n\t\ttry {\n\t\t\tcontinue;\n\t\t} finally {\n\t\t\tbreak L;\n\t\t}\n\t}\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestTryIllegalContinueWithFinallyOverrideDummy(t *testing.T) {\n\tconst SCRIPT = `\n\tL: {\n\t\twhile (false) {\n\t\t\ttry {\n\t\t\t\tcontinue L;\n\t\t\t} finally {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestTryNoResult(t *testing.T) {\n\tconst SCRIPT = `\n\ttrue;\n    L:\n    try {\n        break L;\n    } finally {\n    }\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestCatchLexicalEnv(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\ttry {\n\t\t\tthrow 1;\n\t\t} catch (e) {\n\t\t\tvar x = e;\n\t\t}\n\t\treturn x;\n\t}\n\n\tF();\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestThrowType(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction Exception(message) {\n\t\tthis.message = message;\n\t}\n\n\n\tfunction A() {\n\t\ttry {\n\t\t\tthrow new Exception(\"boo!\");\n\t\t} catch(e) {\n\t\t\treturn e;\n\t\t}\n\t}\n\tvar thrown = A();\n\tthrown !== null && typeof thrown === \"object\" && thrown.constructor === Exception;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestThrowConstructorName(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction Exception(message) {\n\t\tthis.message = message;\n\t}\n\n\n\tfunction A() {\n\t\ttry {\n\t\t\tthrow new Exception(\"boo!\");\n\t\t} catch(e) {\n\t\t\treturn e;\n\t\t}\n\t}\n\tA().constructor.name;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"Exception\"), t)\n}\n\nfunc TestThrowNativeConstructorName(t *testing.T) {\n\tconst SCRIPT = `\n\n\n\tfunction A() {\n\t\ttry {\n\t\t\tthrow new TypeError();\n\t\t} catch(e) {\n\t\t\treturn e;\n\t\t}\n\t}\n\tA().constructor.name;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"TypeError\"), t)\n}\n\nfunc TestEmptyTryNoCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tvar called = false;\n\ttry {\n\t} finally {\n\t\tcalled = true;\n\t}\n\tcalled;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTryReturnFromCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(o) {\n\t\tvar x = 42;\n\n\t\tfunction innerf(o) {\n\t\t\ttry {\n\t\t\t\tthrow o;\n\t\t\t} catch (e) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\treturn innerf(o);\n\t}\n\tf({});\n\t`\n\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestTryCompletionResult(t *testing.T) {\n\tconst SCRIPT = `\n\t99; do { -99; try { 39 } catch (e) { -1 } finally { break; -2 }; } while (false);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestIfElse(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv;\n\tif (rv === undefined) {\n\t\trv = \"passed\";\n\t} else {\n\t\trv = \"failed\";\n\t}\n\trv;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"passed\"), t)\n}\n\nfunc TestIfElseRetVal(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x;\n\tif (x === undefined) {\n\t\t\"passed\";\n\t} else {\n\t\t\"failed\";\n\t}\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"passed\"), t)\n}\n\nfunc TestWhileReturnValue(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0;\n\twhile(true) {\n\t\tx = 1;\n\t\tbreak;\n\t}\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestIfElseLabel(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0;\n\tabc: if (true) {\n\t\tx = 1;\n\t\tbreak abc;\n\t}\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestIfMultipleLabels(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0;\n\txyz:abc: if (true) {\n\t\tbreak xyz;\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestBreakOutOfTry(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar x = 1;\n\t\tB: {\n\t\t\ttry {\n\t\t\t\tx = 2;\n\t\t\t} catch(e) {\n\t\t\t\tx = 3;\n\t\t\t} finally {\n\t\t\t\tbreak B;\n\t\t\t\tx = 4;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestReturnOutOfTryNested(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tfunction nested() {\n\t\t\ttry {\n\t\t\t\treturn 1;\n\t\t\t} catch(e) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\treturn nested();\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestReturnOutOfTryWithFinally(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction test() {\n\t\ttry {\n\t\t\treturn 'Hello, world!';\n\t\t} finally {\n\t\t\tconst dummy = 'unexpected';\n\t\t}\n\t}\n\ttest();\n\t`\n\ttestScript(SCRIPT, asciiString(\"Hello, world!\"), t)\n}\n\nfunc TestContinueLoop(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar r = 0;\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tif (i > 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\treturn r;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestContinueOutOfTry(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {\n\t\tvar r = 0;\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\ttry {\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\treturn 99;\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\treturn r;\n\t}\n\n\tA();\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestThisInCatch(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction O() {\n\t\ttry {\n\t\t\tf();\n\t\t} catch (e) {\n\t\t\tthis.value = e.toString();\n\t\t}\n\t}\n\n\tfunction f() {\n\t\tthrow \"ex\";\n\t}\n\n\tvar o = new O();\n\to.value;\n\t`\n\ttestScript(SCRIPT, asciiString(\"ex\"), t)\n}\n\nfunc TestNestedTry(t *testing.T) {\n\tconst SCRIPT = `\n\tvar ex;\n\ttry {\n  \t\tthrow \"ex1\";\n\t} catch (er1) {\n  \t\ttry {\n    \t\t\tthrow \"ex2\";\n  \t\t} catch (er1) {\n\t\t\tex = er1;\n\t\t}\n\t}\n\tex;\n\t`\n\ttestScript(SCRIPT, asciiString(\"ex2\"), t)\n}\n\nfunc TestNestedTryInStashlessFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar ex1, ex2;\n\t\ttry {\n\t\t\tthrow \"ex1\";\n\t\t} catch (er1) {\n\t\t\ttry {\n\t\t\t\tthrow \"ex2\";\n\t\t\t} catch (er1) {\n\t\t\t\tex2 = er1;\n\t\t\t}\n\t\t\tex1 = er1;\n\t\t}\n\t\treturn ex1 == \"ex1\" && ex2 == \"ex2\";\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalLexicalDecl(t *testing.T) {\n\tconst SCRIPT = `\n\teval(\"let x = true; x;\");\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalInCatchInStashlessFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar ex;\n\t\ttry {\n\t\t\tthrow \"ex1\";\n\t\t} catch (er1) {\n\t\t\teval(\"ex = er1\");\n\t\t}\n\t\treturn ex;\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, asciiString(\"ex1\"), t)\n}\n\nfunc TestCatchClosureInStashlessFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar ex;\n\t\ttry {\n\t\t\tthrow \"ex1\";\n\t\t} catch (er1) {\n\t\t\treturn function() {\n\t\t\t\treturn er1;\n\t\t\t}\n\t\t}\n\t}\n\tf()();\n\t`\n\ttestScript(SCRIPT, asciiString(\"ex1\"), t)\n}\n\nfunc TestCatchVarNotUsedInStashlessFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar ex;\n\t\ttry {\n\t\t\tthrow \"ex1\";\n\t\t} catch (er1) {\n\t\t\tex = \"ok\";\n\t\t}\n\t\treturn ex;\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, asciiString(\"ok\"), t)\n}\n\nfunc TestNew(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction O() {\n\t\tthis.x = 42;\n\t}\n\n\tnew O().x;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestStringConstructor(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\treturn String(33) + \" \" + String(\"cows\");\n\t}\n\n\tF();\n\t`\n\ttestScript(SCRIPT, asciiString(\"33 cows\"), t)\n}\n\nfunc TestError(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\treturn new Error(\"test\");\n\t}\n\n\tvar e = F();\n\te.message == \"test\" && e.name == \"Error\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTypeError(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\treturn new TypeError(\"test\");\n\t}\n\n\tvar e = F();\n\te.message == \"test\" && e.name == \"TypeError\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestToString(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 42};\n\to.toString = function() {\n\t\treturn String(this.x);\n\t}\n\n\tvar o1 = {};\n\to.toString() + \" ### \" + o1.toString();\n\t`\n\ttestScript(SCRIPT, asciiString(\"42 ### [object Object]\"), t)\n}\n\nfunc TestEvalOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {f: function() {return 42}, x: 0};\n\tvar trace = \"\";\n\n\tfunction F1() {\n\t    trace += \"First!\";\n\t    return o;\n\t}\n\n\tfunction F2() {\n\t    trace += \"Second!\";\n\t    return \"f\";\n\t}\n\n\tfunction F3() {\n\t    trace += \"Third!\";\n\t}\n\n\tvar rv = F1()[F2()](F3());\n\trv += trace;\n\trv;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"42First!Second!Third!\"), t)\n}\n\nfunc TestPostfixIncBracket(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 42};\n\tvar trace = \"\";\n\n\tfunction F1() {\n\t    trace += \"First!\";\n\t    return o;\n\t}\n\n\tfunction F2() {\n\t    trace += \"Second!\";\n\t    return \"x\";\n\t}\n\n\n\tvar rv = F1()[F2()]++;\n\trv + trace + o.x;\n\t`\n\ttestScript(SCRIPT, asciiString(\"42First!Second!43\"), t)\n}\n\nfunc TestPostfixIncDot(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 42};\n\tvar trace = \"\";\n\n\tfunction F1() {\n\t    trace += \"First!\";\n\t    return o;\n\t}\n\n\tvar rv = F1().x++;\n\trv + trace + o.x;\n\t`\n\ttestScript(SCRIPT, asciiString(\"42First!43\"), t)\n}\n\nfunc TestPrefixIncBracket(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 42};\n\tvar trace = \"\";\n\n\tfunction F1() {\n\t    trace += \"First!\";\n\t    return o;\n\t}\n\n\tfunction F2() {\n\t    trace += \"Second!\";\n\t    return \"x\";\n\t}\n\n\n\tvar rv = ++F1()[F2()];\n\trv + trace + o.x;\n\t`\n\ttestScript(SCRIPT, asciiString(\"43First!Second!43\"), t)\n}\n\nfunc TestPrefixIncDot(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 42};\n\tvar trace = \"\";\n\n\tfunction F1() {\n\t    trace += \"First!\";\n\t    return o;\n\t}\n\n\tvar rv = ++F1().x;\n\trv + trace + o.x;\n\t`\n\ttestScript(SCRIPT, asciiString(\"43First!43\"), t)\n}\n\nfunc TestPostDecObj(t *testing.T) {\n\tconst SCRIPT = `\n\tvar object = {valueOf: function() {return 1}};\n\tvar y = object--;\n\tvar ok = false;\n\tif (y === 1) {\n\t\tok = true;\n\t}\n\tok;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestPropAcc1(t *testing.T) {\n\tconst SCRIPT = `\n\t1..toString()\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"1\"), t)\n}\n\nfunc TestEvalDirect(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv = false;\n    function foo(){ rv = true; }\n\n    var o = { };\n    function f() {\n        try {\n\t        eval(\"o.bar( foo() );\");\n\t\t} catch (e) {\n\t\t}\n    }\n    f();\n\trv;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalRet(t *testing.T) {\n\tconst SCRIPT = `\n\teval(\"for (var i = 0; i < 3; i++) {i}\")\n\t`\n\n\ttestScript(SCRIPT, valueInt(2), t)\n}\n\nfunc TestEvalFunctionDecl(t *testing.T) {\n\tconst SCRIPT = `\n\teval(\"function F() {}\")\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalFunctionExpr(t *testing.T) {\n\tconst SCRIPT = `\n\teval(\"(function F() {return 42;})\")()\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestEvalDirectScope(t *testing.T) {\n\tconst SCRIPT = `\n\tvar __10_4_2_1_3 = \"str\";\n\tfunction testcase() {\n\t\tvar __10_4_2_1_3 = \"str1\";\n\t\ttry {\n\t\t\tthrow \"error\";\n\t\t} catch (e) {\n\t\t\tvar __10_4_2_1_3 = \"str2\";\n\t\t\treturn eval(\"__10_4_2_1_3\");\n\t\t}\n\t}\n\ttestcase();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"str2\"), t)\n}\n\nfunc TestEvalDirectScope1(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar __10_4_2_1_5 = \"str\";\n\tfunction testcase() {\n\t\t\t\tvar __10_4_2_1_5 = \"str1\";\n\t\t\t\tvar r = eval(\"\\\n\t\t\t\t\t\t\t  var __10_4_2_1_5 = \\'str2\\'; \\\n\t\t\t\t\t\t\t  eval(\\\"\\'str2\\' === __10_4_2_1_5\\\")\\\n\t\t\t\t\t\t\t\");\n\t\t\t\treturn r;\n\t\t}\n\ttestcase();\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalDirectCreateBinding(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\teval(\"var x = true\");\n\t\treturn x;\n\t}\n\tvar res = f();\n\tvar thrown = false;\n\ttry {\n\t\tx;\n\t} catch(e) {\n\t\tif (e instanceof ReferenceError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tres && thrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalDirectCreateBinding1(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\teval(\"let x = 1; var y = 2; function f1() {return x};\");\n\t\tassert.throws(ReferenceError, function() { x });\n\t\treturn \"\"+y+f1();\n\t}\n\tf();\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, asciiString(\"21\"), t)\n}\n\nfunc TestEvalDirectCreateBinding3(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet x;\n\t\ttry {\n\t\t\teval(\"var y=1, x=2\");\n\t\t} catch(e) {}\n\t\treturn y;\n\t}\n\tassert.throws(ReferenceError, f);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalGlobalStrict(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar evalStr =\n\t'for (var x in this) {\\n'+\n\t'  if ( x === \\'Math\\' ) {\\n'+\n\t'  }\\n'+\n\t'}\\n';\n\n\teval(evalStr);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalEmptyStrict(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\teval(\"\");\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalFuncDecl(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar funcA = eval(\"function __funcA(__arg){return __arg;}; __funcA\");\n\ttypeof funcA;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"function\"), t)\n}\n\nfunc TestGetAfterSet(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar x = 1;\n\t\treturn x;\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestForLoopRet(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 20; i++) { if (i > 2) {break;} else { i }}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestForLoopRet1(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 20; i++) { if (i > 2) {42;; {L:{break;}}} else { i }}\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestForInLoopRet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = [1, 2, 3, 4];\n\tfor (var i in o) { if (i > 2) {break;} else { i }}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestForInLoopRet1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {};\n\to.x = 1;\n\to.y = 2;\n\tfor (var i in o) {\n\t\ttrue;\n\t}\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDoWhileLoopRet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar i = 0;\n\tdo {\n\t\tif (i > 2) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\ti;\n\t\t}\n\t} while (i++ < 20);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestDoWhileContinueRet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar i = 0;\n\tdo {\n\t\tif (i > 2) {\n\t\t\ttrue;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\ti;\n\t\t}\n\t} while (i++ < 20);\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestWhileLoopRet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar i; while (i < 20) { if (i > 2) {break;} else { i++ }}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestLoopRet1(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 20; i++) { }\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestInstanceof(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv;\n\ttry {\n\t\ttrue();\n\t} catch (e) {\n\t\trv = e instanceof TypeError;\n\t}\n\trv;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestStrictAssign(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar rv;\n\tvar called = false;\n\tfunction F() {\n\t\tcalled = true;\n\t\treturn 1;\n\t}\n\ttry {\n\t\tx = F();\n\t} catch (e) {\n\t\trv = e instanceof ReferenceError;\n\t}\n\trv + \" \" + called;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"true true\"), t)\n}\n\nfunc TestStrictScope(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv;\n\tvar called = false;\n\tfunction F() {\n\t\t'use strict';\n\t\tx = 1;\n\t}\n\ttry {\n\t\tF();\n\t} catch (e) {\n\t\trv = e instanceof ReferenceError;\n\t}\n\tx = 1;\n\trv + \" \" + x;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"true 1\"), t)\n}\n\nfunc TestStringObj(t *testing.T) {\n\tconst SCRIPT = `\n\tvar s = new String(\"test\");\n\ts[0] + s[2] + s[1];\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"tse\"), t)\n}\n\nfunc TestStringPrimitive(t *testing.T) {\n\tconst SCRIPT = `\n\tvar s = \"test\";\n\ts[0] + s[2] + s[1];\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"tse\"), t)\n}\n\nfunc TestCallGlobalObject(t *testing.T) {\n\tconst SCRIPT = `\n\tvar rv;\n\ttry {\n\t\tthis();\n\t} catch (e) {\n\t\trv = e instanceof TypeError\n\t}\n\trv;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFuncLength(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, y) {\n\n\t}\n\tF.length\n\t`\n\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestNativeFuncLength(t *testing.T) {\n\tconst SCRIPT = `\n\teval.length + Object.defineProperty.length + String.length\n\t`\n\n\ttestScript(SCRIPT, intToValue(5), t)\n}\n\nfunc TestArguments(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\treturn arguments.length + \" \" + arguments[1];\n\t}\n\n\tF(1,2,3)\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"3 2\"), t)\n}\n\nfunc TestArgumentsPut(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, y) {\n\t\targuments[0] -= arguments[1];\n\t\treturn x;\n\t}\n\n\tF(5, 2)\n\t`\n\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestArgumentsPutStrict(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, y) {\n\t\t'use strict';\n\t\targuments[0] -= arguments[1];\n\t\treturn x;\n\t}\n\n\tF(5, 2)\n\t`\n\n\ttestScript(SCRIPT, intToValue(5), t)\n}\n\nfunc TestArgumentsExtra(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, y) {\n\t\treturn arguments[2];\n\t}\n\n\tF(1, 2, 42)\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestArgumentsExist(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, arguments) {\n\t\treturn arguments;\n\t}\n\n\tF(1, 42)\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestArgumentsDelete(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(x) {\n\t\tdelete arguments[0];\n\t\targuments[0] = 42;\n\t\treturn x;\n\t}\n\tf(1)\n\t`\n\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestArgumentsInEval(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\treturn eval(\"arguments\");\n\t}\n\tf(1)[0];\n\t`\n\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestArgumentsRedeclareInEval(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(\"arguments\" in this, false, \"No global 'arguments' binding\");\n\n\tfunction f(p = eval(\"var arguments = 'param'\"), arguments) {}\n\tassert.throws(SyntaxError, f);\n\n\tassert.sameValue(\"arguments\" in this, false, \"No global 'arguments' binding\");\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestArgumentsRedeclareArrow(t *testing.T) {\n\tconst SCRIPT = `\n\tconst oldArguments = globalThis.arguments;\n\tlet count = 0;\n\tconst f = (p = eval(\"var arguments = 'param'\"), q = () => arguments) => {\n\t  var arguments = \"local\";\n\t  assert.sameValue(arguments, \"local\", \"arguments\");\n\t  assert.sameValue(q(), \"param\", \"q\");\n\t  count++;\n\t}\n\tf();\n\tassert.sameValue(count, 1);\n\tassert.sameValue(globalThis.arguments, oldArguments, \"globalThis.arguments unchanged\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalParamWithDef(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(param = 0) {\n\t\teval(\"var param = 1\");\n\t\treturn param;\n\t}\n\tf();\n\t`\n\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestArgumentsRedefinedAsLetDyn(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet arguments;\n\t\teval(\"\"); // force dynamic scope\n\t\treturn arguments;\n\t}\n\t\n\tf(1,2);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestWith(t *testing.T) {\n\tconst SCRIPT = `\n\tvar b = 1;\n\tvar o = {a: 41};\n\twith(o) {\n\t\ta += b;\n\t}\n\to.a;\n\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestWithInFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F() {\n\t\tvar b = 1;\n\t\tvar c = 0;\n\t\tvar o = {a: 40, c: 1};\n\t\twith(o) {\n\t\t\ta += b + c;\n\t\t}\n\t\treturn o.a;\n\t}\n\n\tF();\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestAssignNonExtendable(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tfunction F() {\n    \t\tthis.x = 1;\n\t}\n\n\tvar o = new F();\n\tObject.preventExtensions(o);\n\to.x = 42;\n\to.x;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestAssignNonExtendable1(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tfunction F() {\n\t}\n\n\tvar o = new F();\n\tvar rv;\n\n\tObject.preventExtensions(o);\n\ttry {\n\t\to.x = 42;\n\t} catch (e) {\n\t\trv = e.constructor === TypeError;\n\t}\n\n\trv += \" \" + o.x;\n\trv;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"true undefined\"), t)\n}\n\nfunc TestAssignStrict(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\ttry {\n\t\teval(\"eval = 42\");\n\t} catch(e) {\n\t\tvar rv = e instanceof SyntaxError\n\t}\n\trv;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestIllegalArgmentName(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\ttry {\n\t\teval(\"function F(eval) {}\");\n\t} catch (e) {\n\t\tvar rv = e instanceof SyntaxError\n\t}\n\trv;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFunction(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar f0 = Function(\"\");\n\tvar f1 = Function(\"return ' one'\");\n\tvar f2 = Function(\"arg\", \"return ' ' + arg\");\n\tf0() + f1() + f2(\"two\");\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"undefined one two\"), t)\n}\n\nfunc TestFunction1(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar f = function f1(count) {\n\t\tif (count == 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn f1(count-1);\n\t}\n\n\tf(1);\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFunction2(t *testing.T) {\n\tconst SCRIPT = `\n\tvar trace = \"\";\n\tfunction f(count) {\n    \t\ttrace += \"f(\"+count+\")\";\n    \t\tif (count == 0) {\n        \t\treturn;\n    \t\t}\n    \t\treturn f(count-1);\n\t}\n\n\tfunction f1() {\n    \t\ttrace += \"f1\";\n\t}\n\n\tvar f2 = f;\n\tf = f1;\n\tf2(1);\n\ttrace;\n\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"f(1)f1\"), t)\n}\n\nfunc TestFunctionToString(t *testing.T) {\n\tconst SCRIPT = `\n\n\tFunction(\"arg1\", \"arg2\", \"return 42\").toString();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"function anonymous(arg1,arg2\\n) {\\nreturn 42\\n}\"), t)\n}\n\nfunc TestObjectLiteral(t *testing.T) {\n\tconst SCRIPT = `\n\tvar getterCalled = false;\n\tvar setterCalled = false;\n\n\tvar o = {get x() {getterCalled = true}, set x(_) {setterCalled = true}};\n\n\to.x;\n\to.x = 42;\n\n\tgetterCalled && setterCalled;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestConst(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar v1 = true && true;\n\tvar v2 = 1/(-1 * 0);\n\tvar v3 = 1 == 2 || v1;\n\tvar v4 = true && false\n\tv1 === true && v2 === -Infinity && v3 === v1 && v4 === false;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestConstWhile(t *testing.T) {\n\tconst SCRIPT = `\n\tvar c = 0;\n\twhile (2 + 2 === 4) {\n\t\tif (++c > 9) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tc === 10;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestConstWhileThrow(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown = false;\n\ttry {\n\t\twhile ('s' in true) {\n\t\t\tbreak;\n\t\t}\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError\n\t}\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDupParams(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x, y, x) {\n\t\treturn x;\n\t}\n\n\tF(1, 2);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestUseUnsuppliedParam(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction getMessage(message) {\n\t\tif (message === undefined) {\n\t\t\tmessage = '';\n\t\t}\n\t\tmessage += \" 123 456\";\n\t\treturn message;\n\t}\n\n\tgetMessage();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\" 123 456\"), t)\n}\n\nfunc TestForInLetWithInitializer(t *testing.T) {\n\tconst SCRIPT = `for (let x = 3 in {}) { }`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestForInLoop(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction Proto() {}\n\tProto.prototype.x = 42;\n\tvar o = new Proto();\n\to.y = 44;\n\to.x = 45;\n\tvar hasX = false;\n\tvar hasY = false;\n\n\tfor (var i in o) {\n    \t\tswitch(i) {\n    \t\tcase \"x\":\n        \t\tif (hasX) {\n            \t\t\tthrow new Error(\"Already has X\");\n        \t\t}\n        \t\thasX = true;\n        \t\tbreak;\n    \t\tcase \"y\":\n        \t\tif (hasY) {\n            \t\t\tthrow new Error(\"Already has Y\");\n        \t\t}\n        \t\thasY = true;\n        \t\tbreak;\n    \t\t}\n\t}\n\n\thasX && hasY;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestWhileLoopResult(t *testing.T) {\n\tconst SCRIPT = `\n\twhile(false);\n\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEmptySwitch(t *testing.T) {\n\tconst SCRIPT = `\n\tswitch(1){}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEmptyDoWhile(t *testing.T) {\n\tconst SCRIPT = `\n\tdo {} while(false)\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSwitch(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x) {\n\t\tvar i = 0;\n\t\tswitch (x) {\n\t\tcase 0:\n\t\t\ti++;\n\t\tcase 1:\n\t\t\ti++;\n\t\tdefault:\n\t\t\ti++;\n\t\tcase 2:\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tF(0) + F(1) + F(2) + F(4);\n\n\t`\n\n\ttestScript(SCRIPT, intToValue(10), t)\n}\n\nfunc TestSwitchDefFirst(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction F(x) {\n\t\tvar i = 0;\n\t\tswitch (x) {\n\t\tdefault:\n\t\t\ti++;\n\t\tcase 0:\n\t\t\ti++;\n\t\tcase 1:\n\t\t\ti++;\n\t\tcase 2:\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tF(0) + F(1) + F(2) + F(4);\n\n\t`\n\n\ttestScript(SCRIPT, intToValue(10), t)\n}\n\nfunc TestSwitchResult(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 2;\n\n\tswitch (x) {\n\tcase 0:\n\t\t\"zero\";\n\tcase 1:\n\t\t\"one\";\n\tcase 2:\n\t\t\"two\";\n\t\tbreak;\n\tcase 3:\n\t\t\"three\";\n\tdefault:\n\t\t\"default\";\n\t}\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"two\"), t)\n}\n\nfunc TestSwitchResult1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0;\n\tswitch (x) { case 0: \"two\"; case 1: break}\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"two\"), t)\n}\n\nfunc TestSwitchResult2(t *testing.T) {\n\tconst SCRIPT = `\n\t6; switch (\"a\") { case \"a\": 7; case \"b\": }\n\t`\n\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestSwitchResultJumpIntoEmptyEval(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction t(x) {\n\t\treturn eval(\"switch(x) { case 1: 2; break; case 2: let x = 1; case 3: x+2; break; case 4: default: 9}\");\n\t}\n\t\"\"+t(2)+t();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"39\"), t)\n}\n\nfunc TestSwitchResultJumpIntoEmpty(t *testing.T) {\n\tconst SCRIPT = `\n\tswitch(2) { case 1: 2; break; case 2: let x = 1; case 3: x+2; case 4: {let y = 2}; break; default: 9};\n\t`\n\n\ttestScript(SCRIPT, valueInt(3), t)\n}\n\nfunc TestSwitchLexical(t *testing.T) {\n\tconst SCRIPT = `\n\tswitch (true) { case true: let x = 1; }\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSwitchBreakOuter(t *testing.T) {\n\tconst SCRIPT = `\n\tLOOP:\n\tfor (let i = 0; i < 10; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tlet x = 1;\n\t\t\tcontinue;\n\t\tcase 2:\n\t\t\ttry {\n\t\t\t\tx++;\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof ReferenceError) {\n\t\t\t\t\tbreak LOOP;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new Error(\"Exception was not thrown\");\n\t\t}\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestIfBreakResult(t *testing.T) {\n\tconst SCRIPT = `\n\tL: {if (true) {42;} break L;}\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestSwitchNoMatch(t *testing.T) {\n\tconst SCRIPT = `\n\tvar result;\n\tvar x;\n\tswitch (x) {\n\tcase 0:\n\t\tresult = \"2\";\n\t\tbreak;\n\t}\n\n\tresult;\n\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSwitchNoMatchNoDefault(t *testing.T) {\n\tconst SCRIPT = `\n\t\tswitch (1) {\n\t\tcase 0:\n\t\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSwitchNoMatchNoDefaultNoResult(t *testing.T) {\n\tconst SCRIPT = `\n\t\tswitch (1) {\n\t\tcase 0:\n\t\t}\n\t\t42;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestSwitchNoMatchNoDefaultNoResultMatch(t *testing.T) {\n\tconst SCRIPT = `\n\t\tswitch (1) {\n\t\tcase 1:\n\t\t}\n\t\t42;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestEmptySwitchNoResult(t *testing.T) {\n\tconst SCRIPT = `\n\t\tswitch (1) {}\n\t\t42;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestGetOwnPropertyNames(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {\n\t\tprop1: 42,\n\t\tprop2: \"test\"\n\t}\n\n\tvar hasProp1 = false;\n\tvar hasProp2 = false;\n\n\tvar names = Object.getOwnPropertyNames(o);\n\tfor (var i in names) {\n\t\tvar p = names[i];\n\t\tswitch(p) {\n\t\tcase \"prop1\":\n\t\t\thasProp1 = true;\n\t\t\tbreak;\n\t\tcase \"prop2\":\n\t\t\thasProp2 = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thasProp1 && hasProp2;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayLiteral(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar f1Called = false;\n\tvar f2Called = false;\n\tvar f3Called = false;\n\tvar errorThrown = false;\n\n\tfunction F1() {\n\t\tf1Called = true;\n\t}\n\n\tfunction F2() {\n\t\tf2Called = true;\n\t}\n\n\tfunction F3() {\n\t\tf3Called = true;\n\t}\n\n\n\ttry {\n\t\tvar a = [F1(), x(F3()), F2()];\n\t} catch(e) {\n\t\tif (e instanceof ReferenceError) {\n\t\t\terrorThrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tf1Called && !f2Called && f3Called && errorThrown && a === undefined;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestJumpOutOfReturn(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar a;\n\t\tif (a == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tf();\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSwitchJumpOutOfReturn(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(x) {\n\t\tswitch(x) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn x;\n\t\t}\n\t}\n\n\tf(0);\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSetToReadOnlyPropertyStrictBracket(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tvar o = {};\n\tvar thrown = false;\n\tObject.defineProperty(o, \"test\", {value: 42, configurable: true});\n\ttry {\n\t\to[\"test\"] = 43;\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSetToReadOnlyPropertyStrictDot(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tvar o = {};\n\tvar thrown = false;\n\tObject.defineProperty(o, \"test\", {value: 42, configurable: true});\n\ttry {\n\t\to.test = 43;\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDeleteNonConfigurablePropertyStrictBracket(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tvar o = {};\n\tvar thrown = false;\n\tObject.defineProperty(o, \"test\", {value: 42});\n\ttry {\n\t\tdelete o[\"test\"];\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDeleteNonConfigurablePropertyStrictDot(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\n\tvar o = {};\n\tvar thrown = false;\n\tObject.defineProperty(o, \"test\", {value: 42});\n\ttry {\n\t\tdelete o.test;\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestCompound1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0;\n  \tvar scope = {x: 1};\n    \tvar f;\n  \twith (scope) {\n    \t\tf = function() {\n        \t\tx *= (delete scope.x, 2);\n    \t\t}\n  \t}\n\tf();\n\n\tscope.x === 2 && x === 0;\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestCompound2(t *testing.T) {\n\tconst SCRIPT = `\n\nvar x;\nx = \"x\";\nx ^= \"1\";\n\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestDeleteArguments(t *testing.T) {\n\tdefer func() {\n\t\tif _, ok := recover().(*CompilerSyntaxError); !ok {\n\t\t\tt.Fatal(\"Expected syntax error\")\n\t\t}\n\t}()\n\tconst SCRIPT = `\n\t'use strict';\n\n\tfunction f() {\n\t\tdelete arguments;\n\t}\n\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestReturnUndefined(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n    \t\treturn x;\n\t}\n\n\tvar thrown = false;\n\ttry {\n\t\tf();\n\t} catch (e) {\n\t\tthrown = e instanceof ReferenceError;\n\t}\n\n\tthrown;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestForBreak(t *testing.T) {\n\tconst SCRIPT = `\n\tvar supreme, count;\n\tsupreme = 5;\n\tvar __evaluated =  eval(\"for(count=0;;) {if (count===supreme)break;else count++; }\");\n    \tif (__evaluated !== void 0) {\n        \tthrow new Error('#1: __evaluated === 4. Actual:  __evaluated ==='+ __evaluated  );\n    \t}\n\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestLargeNumberLiteral(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 0x800000000000000000000;\n\tx.toString();\n\t`\n\ttestScript(SCRIPT, asciiString(\"9.671406556917033e+24\"), t)\n}\n\nfunc TestIncDelete(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {x: 1};\n\to.x += (delete o.x, 1);\n\to.x;\n\t`\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestCompoundAssignRefError(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown = false;\n\ttry {\n\t\ta *= 1;\n\t} catch (e) {\n\t\tif (e instanceof ReferenceError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestObjectLiteral__Proto__(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {\n\t\t__proto__: null,\n\t\ttest: 42\n\t}\n\n\tObject.getPrototypeOf(o);\n\t`\n\n\ttestScript(SCRIPT, _null, t)\n}\n\nfunc TestEmptyCodeError(t *testing.T) {\n\tif _, err := New().RunString(`i`); err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t} else {\n\t\tif e := err.Error(); e != \"ReferenceError: i is not defined at <eval>:1:1(0)\" {\n\t\t\tt.Fatalf(\"Unexpected error: '%s'\", e)\n\t\t}\n\t}\n}\n\nfunc TestForOfArray(t *testing.T) {\n\tconst SCRIPT = `\n\tvar array = [0, 'a', true, false, null, /* hole */, undefined, NaN];\n\tvar i = 0;\n\t\n\tfor (var value of array) {\n\t  assert.sameValue(value, array[i], 'element at index ' + i);\n\t  i++;\n\t}\n\t\n\tassert.sameValue(i, 8, 'Visits all elements');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestForOfReturn(t *testing.T) {\n\tconst SCRIPT = `\n\tvar callCount = 0;\n\tvar iterationCount = 0;\n\tvar iterable = {};\n\tvar x = {\n\t  set attr(_) {\n\t\tthrow new Test262Error();\n\t  }\n\t};\n\t\n\titerable[Symbol.iterator] = function() {\n\t  return {\n\t\tnext: function() {\n\t\t  return { done: false, value: 0 };\n\t\t},\n\t\treturn: function() {\n\t\t  callCount += 1;\n\t\t}\n\t  }\n\t};\n\t\n\tassert.throws(Test262Error, function() {\n\t  for (x.attr of iterable) {\n\t\titerationCount += 1;\n\t  }\n\t});\n\t\n\tassert.sameValue(iterationCount, 0, 'The loop body is not evaluated');\n\tassert.sameValue(callCount, 1, 'Iterator is closed');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestForOfReturn1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar iterable = {};\n\tvar iterationCount = 0;\n\n\titerable[Symbol.iterator] = function() {\n\t  return {\n\t\tnext: function() {\n\t\t  return { done: false, value: null };\n\t\t},\n\t\tget return() {\n\t\t  throw new Test262Error();\n\t\t}\n\t  };\n\t};\n\n\tassert.throws(Test262Error, function() {\n\t  for (var x of iterable) {\n\t\titerationCount += 1;\n\t\tbreak;\n\t  }\n\t});\n\n\tassert.sameValue(iterationCount, 1, 'The loop body is evaluated');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestForOfLet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar iterCount = 0;\n\tfunction f() {}\n\tfor (var let of [23]) {\n\t\tf(let);\n\t\tif (let != 23) {\n\t\t\tthrow new Error(\"\");\n\t\t}\n\t\titerCount += 1;\n\t}\n\n\titerCount;\n`\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestForOfLetLet(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (let let of [23]) {\n\t}\n`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestForHeadLet(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (let = 0; let < 2; let++);\n`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestLhsLet(t *testing.T) {\n\tconst SCRIPT = `\n\tlet = 1;\n\tlet;\n\t`\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestLetPostfixASI(t *testing.T) {\n\tconst SCRIPT = `\n\tlet\n\t++\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestIteratorReturnNormal(t *testing.T) {\n\tconst SCRIPT = `\n\tvar iterable = {};\n\tvar iterationCount = 0;\n\n\titerable[Symbol.iterator] = function() {\n\t  return {\n\t\tnext: function() {\n\t\t  return { done: ++iterationCount > 2, value: null };\n\t\t},\n\t\tget return() {\n\t\t  throw new Test262Error();\n\t\t}\n\t  };\n\t};\n\n\tfor (var x of iterable) {\n\t}\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestIteratorReturnErrorNested(t *testing.T) {\n\tconst SCRIPT = `\n\tvar returnCalled = {};\n\tfunction iter(id) {\n\t\treturn function() {\n\t\t\tvar count = 0;\n\t\t\treturn {\n\t\t\t\tnext: function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: null,\n\t\t\t\t\t\tdone: ++count > 2\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\treturn: function () {\n\t\t\t\t\treturnCalled[id] = true;\n\t\t\t\t\tthrow new Error(id);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tvar iterable1 = {};\n\titerable1[Symbol.iterator] = iter(\"1\");\n\tvar iterable2 = {};\n\titerable2[Symbol.iterator] = iter(\"2\");\n\n\ttry {\n\t\tfor (var i of iterable1) {\n\t\t\tfor (var j of iterable2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"no exception was thrown\");\n\t} catch (e) {\n\t\tif (e.message !== \"2\") {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tif (!returnCalled[\"1\"]) {\n\t\tthrow new Error(\"no return 1\");\n\t}\n\tif (!returnCalled[\"2\"]) {\n\t\tthrow new Error(\"no return 2\");\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestReturnFromForInLoop(t *testing.T) {\n\tconst SCRIPT = `\n\t(function f() {\n\t\tfor (var i in {a: 1}) {\n\t\t\treturn true;\n\t\t}\n\t})();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestReturnFromForOfLoop(t *testing.T) {\n\tconst SCRIPT = `\n\t(function f() {\n\t\tfor (var i of [1]) {\n\t\t\treturn true;\n\t\t}\n\t})();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestIfStackLeaks(t *testing.T) {\n\tconst SCRIPT = `\n\tvar t = 0;\n\tif (t === 0) {\n\t\tt;\n\t}\n\t`\n\ttestScript(SCRIPT, _positiveZero, t)\n}\n\nfunc TestWithCallee(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction O() {\n\t\tvar that = this;\n\t\tthis.m = function() {\n\t\t\treturn this === that;\n\t\t}\n\t}\n\twith(new O()) {\n\t\tm();\n\t}\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestWithScope(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(o) {\n\t\tvar x = 42;\n\n\t\tfunction innerf(o) {\n\t\t\twith (o) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\treturn innerf(o);\n\t}\n\tf({});\n\t`\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestEvalCallee(t *testing.T) {\n\tconst SCRIPT = `\n\t(function () {\n\t\t'use strict';\n\t\tvar v = function() {\n\t\t\treturn this === undefined;\n\t\t};\n\t\treturn eval('v()');\n\t})();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalBindingDeleteVar(t *testing.T) {\n\tconst SCRIPT = `\n\t(function () {\n\t\teval(\"var x = 1\");\n\t\treturn x === 1 && delete x;\n\t})();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEvalBindingDeleteFunc(t *testing.T) {\n\tconst SCRIPT = `\n\t(function () {\n\t\teval(\"function x(){}\");\n\t\treturn typeof x === \"function\" && delete x;\n\t})();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDeleteGlobalLexical(t *testing.T) {\n\tconst SCRIPT = `\n\tlet x;\n\tdelete x;\n\t`\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestDeleteGlobalEval(t *testing.T) {\n\tconst SCRIPT = `\n\teval(\"var x\");\n\tdelete x;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestTryResultEmpty(t *testing.T) {\n\tconst SCRIPT = `\n\t1; try { } finally { }\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryResultEmptyCatch(t *testing.T) {\n\tconst SCRIPT = `\n\t1; try { throw null } catch(e) { }\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryResultEmptyContinueLoop(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (var i = 0; i < 2; i++) { try {throw null;} catch(e) {continue;} 'bad'}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryEmptyCatchStackLeak(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tvar f;\n\t\t// Make sure the outer function is not stashless.\n\t\t(function() {\n\t\t\tf++;\n\t\t})();\n\t\ttry {\n\t\t\tthrow new Error();\n\t\t} catch(e) {}\n\t})();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTryThrowEmptyCatch(t *testing.T) {\n\tconst SCRIPT = `\n\ttry {\n\t\tthrow new Error();\n\t}\n\tcatch (e) {}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestFalsyLoopBreak(t *testing.T) {\n\tconst SCRIPT = `\n\twhile(false) {\n\t  \tbreak;\n\t}\n\tfor(;false;) {\n\t\tbreak;\n\t}\n\tundefined;\n\t`\n\tMustCompile(\"\", SCRIPT, false)\n}\n\nfunc TestFalsyLoopBreakWithResult(t *testing.T) {\n\tconst SCRIPT = `\n\twhile(false) {\n\t  break;\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestDummyCompile(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\t\n\tfor (;false;) {\n\t\teval = 1;\n\t}\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestDummyCompileForUpdate(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\t\n\tfor (;false;eval=1) {\n\t}\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestObjectLiteralWithNumericKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {1e3: true};\n\tvar keys = Object.keys(o);\n\tvar o1 = {get 1e3() {return true;}};\n\tvar keys1 = Object.keys(o1);\n\tvar o2 = {1e21: true};\n\tvar keys2 = Object.keys(o2);\n\tlet o3 = {0(){return true}};\n\tkeys.length === 1 && keys[0] === \"1000\" && \n\tkeys1.length === 1 && keys1[0] === \"1000\" && o1[1e3] === true &&\n\tkeys2.length === 1 && keys2[0] === \"1e+21\" && o3[0]();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEscapedObjectPropertyKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar obj = {\n\t\tw\\u0069th: 42\n\t};\n\tvar obj = {\n\t\twith() {42}\n\t};\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestEscapedKeywords(t *testing.T) {\n\tconst SCRIPT = `r\\u0065turn;`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestEscapedLet(t *testing.T) {\n\tconst SCRIPT = `\nthis.let = 0;\n\nl\\u0065t // ASI\na;\n\n// If the parser treated the previous escaped \"let\" as a lexical declaration,\n// this variable declaration will result an early syntax error.\nvar a;\n`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestObjectLiteralFuncProps(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\t'use strict';\n\t\tvar o = {\n\t\t\teval: function() {return 1;},\n\t\t\targuments() {return 2;},\n\t\t\ttest: function test1() {}\n\t\t}\n\t\tassert.sameValue(o.eval.name, \"eval\");\n\t\tassert.sameValue(o.arguments.name, \"arguments\");\n\t\tassert.sameValue(o.eval(), 1);\n\t\tassert.sameValue(o.arguments(), 2);\n\t\tassert.sameValue(o.test.name, \"test1\");\n\t})();\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestFuncName(t *testing.T) {\n\tconst SCRIPT = `\n\tvar method = 1;\n\tvar o = {\n\t\tmethod: function() {\n\t\t\treturn method;\n\t\t},\n\t\tmethod1: function method() {\n\t\t\treturn method;\n\t\t}\n\t}\n\to.method() === 1 && o.method1() === o.method1;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFuncNameAssign(t *testing.T) {\n\tconst SCRIPT = `\n\tvar f = function() {};\n\tvar f1;\n\tf1 = function() {};\n\tlet f2 = function() {};\n\n\tf.name === \"f\" && f1.name === \"f1\" && f2.name === \"f2\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalDeclGlobal(t *testing.T) {\n\tconst SCRIPT = `\n\tif (true) {\n\t\tlet it = \"be\";\n\t\tif (it !== \"be\") {\n\t\t\tthrow new Error(it);\n\t\t}\n\t}\n\tlet thrown = false;\n\ttry {\n\t\tit;\n\t} catch(e) {\n\t\tif (e instanceof ReferenceError) {\n\t\t\tthrown = true;\n\t\t}\n\t}\n\tthrown;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalDeclFunction(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tif (true) {\n\t\t\tlet it = \"be\";\n\t\t\tif (it !== \"be\") {\n\t\t\t\tthrow new Error(it);\n\t\t\t}\n\t\t}\n\t\tlet thrown = false;\n\t\ttry {\n\t\t\tit;\n\t\t} catch(e) {\n\t\t\tif (e instanceof ReferenceError) {\n\t\t\t\tthrown = true;\n\t\t\t}\n\t\t}\n\t\treturn thrown;\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalDynamicScope(t *testing.T) {\n\tconst SCRIPT = `\n\tconst global = 1;\n\tfunction f() {\n\t\tconst func = global + 1;\n\t\tfunction inner() {\n\t\t\tfunction assertThrows(fn) {\n\t\t\t\tlet thrown = false;\n\t\t\t\ttry {\n\t\t\t\t\tfn();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof TypeError) {\n\t\t\t\t\t\tthrown = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!thrown) {\n\t\t\t\t\tthrow new Error(\"Did not throw\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassertThrows(function() {\n\t\t\t\tfunc++;\n\t\t\t});\n\t\t\tassertThrows(function() {\n\t\t\t\tglobal++;\n\t\t\t});\n\n\t\t\tassertThrows(function() {\n\t\t\t\teval(\"func++\");\n\t\t\t});\n\t\t\tassertThrows(function() {\n\t\t\t\teval(\"global++\");\n\t\t\t});\n\n\t\t\treturn eval(\"func + 1\");\n\t\t}\n\t\treturn inner();\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, valueInt(3), t)\n}\n\nfunc TestLexicalDynamicScope1(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tconst x = 1 * 4;\n\t\treturn (function() {\n\t\t\teval(\"\");\n\t\t\treturn x;\n\t\t})();\n\t})();\n\t`\n\ttestScript(SCRIPT, intToValue(4), t)\n}\n\nfunc TestLexicalDynamicScope2(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tconst x = 1 + 3;\n\t\tvar y = 2 * 2;\n\t\teval(\"\");\n\t\treturn x;\n\t})();\n\t`\n\ttestScript(SCRIPT, intToValue(4), t)\n}\n\nfunc TestNonStrictLet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar let = 1;\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestStrictLet(t *testing.T) {\n\tconst SCRIPT = `\n\tvar let = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, true)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestLetLet(t *testing.T) {\n\tconst SCRIPT = `\n\tlet let = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestLetASI(t *testing.T) {\n\tconst SCRIPT = `\n\twhile (false) let // ASI\n\tx = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLetASI1(t *testing.T) {\n\tconst SCRIPT = `\n\tlet\n\tx = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLetNoASI(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {}let\nx = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLetNoASI1(t *testing.T) {\n\tconst SCRIPT = `\nlet\nlet = 1;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestLetArrayWithNewline(t *testing.T) {\n\tconst SCRIPT = `\n    with ({}) let\n    [a] = 0;\n\t`\n\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestDynamicUninitedVarAccess(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tvar x;\n\t\treturn eval(\"x\");\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestLexicalForLoopNoClosure(t *testing.T) {\n\tconst SCRIPT = `\n\tlet sum = 0;\n\tfor (let i = 0; i < 3; i++) {\n\t\tsum += i;\n\t}\n\tsum;\n\t`\n\ttestScript(SCRIPT, valueInt(3), t)\n}\n\nfunc TestLexicalForLoopClosure(t *testing.T) {\n\tconst SCRIPT = `\n\tvar f = [];\n\tfor (let i = 0; i < 3; i++) {\n\t\tf.push(function() {\n\t\t\treturn i;\n\t\t});\n\t}\n\tf.length === 3 && f[0]() === 0 && f[1]() === 1 && f[2]() === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalForLoopClosureInNext(t *testing.T) {\n\tconst SCRIPT = `\n\tconst a = [];\n\tfor (let i = 0; i < 5; a.push(function () { return i; }), ++i) { }\n\tlet res = \"\";\n\tfor (let k = 0; k < 5; ++k) {\n\t\tres += \"\"+a[k]();\n\t}\n\tres;\n\t`\n\ttestScript(SCRIPT, asciiString(\"12345\"), t)\n}\n\nfunc TestVarForLoop(t *testing.T) {\n\tconst SCRIPT = `\n\tvar f = [];\n\tfor (var i = 0, j = 0; i < 3; i++) {\n\t\tf.push(function() {\n\t\t\treturn i;\n\t\t});\n\t}\n\tf.length === 3 && f[0]() === 3 && f[1]() === 3 && f[2]() === 3;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalForOfLoop(t *testing.T) {\n\tconst SCRIPT = `\n\tvar f = [];\n\tfor (let i of [0, 1, 2]) {\n\t\tf.push(function() {\n\t\t\treturn i;\n\t\t});\n\t}\n\tf.length === 3 && f[0]() === 0 && f[1]() === 1 && f[2]() === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLexicalForOfLoopContBreak(t *testing.T) {\n\tconst SCRIPT = `\n\tconst f = [];\n\tfor (let i of [0, 1, 2, 3, 4, 5]) {\n\t\tif (i % 2) continue;\n\t\tf.push(function() {\n\t\t\treturn i;\n\t\t});\n\t\tif (i > 2) break;\n\t}\n\tlet res = \"\";\n\tf.forEach(function(item) {res += item()});\n\tf.length === 3 && res === \"024\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestVarBlockConflict(t *testing.T) {\n\tconst SCRIPT = `\n\tlet x;\n\t{\n\t\tif (false) {\n\t\t\tvar x;\n\t\t}\n\t}\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestVarBlockConflictEval(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(SyntaxError, function() {\n\t\tlet x;\n\t\t{\n\t\t\tif (true) {\n\t\t\t\teval(\"var x\");\n\t\t\t}\n\t\t}\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestVarBlockNoConflict(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet x;\n\t\tfunction ff() {\n\t\t\t{\n\t\t\t\tvar x = 3;\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestVarBlockNoConflictEval(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet x;\n\t\tfunction ff() {\n\t\t\t{\n\t\t\t\teval(\"var x = 3\");\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestVarDeclCorrectScope(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\t{\n\t\t\tlet z;\n\t\t\teval(\"var x = 3\");\n\t\t}\n\t\treturn x;\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, valueInt(3), t)\n}\n\nfunc TestLexicalCatch(t *testing.T) {\n\tconst SCRIPT = `\n\ttry {\n\t\tthrow null;\n\t} catch (e) {\n\t\tlet x = 1;\n\t\tfunction f() {}\n\t\te;\n\t}\n\t`\n\ttestScript(SCRIPT, _null, t)\n}\n\nfunc TestArgumentsLexicalDecl(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f1() {\n\t\tlet arguments;\n\t\treturn arguments;\n\t}\n\tf1(42);\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestArgumentsLexicalDeclAssign(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f1() {\n\t\tlet arguments = arguments;\n\t\treturn a;\n\t}\n\tassert.throws(ReferenceError, function() {\n\t\tf1(42);\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestLexicalConstModifyFromEval(t *testing.T) {\n\tconst SCRIPT = `\n\tconst x = 1;\n\tfunction f() {\n\t\teval(\"x = 2\");\n\t}\n\tassert.throws(TypeError, function() {\n\t\tf();\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestLexicalStrictNames(t *testing.T) {\n\tconst SCRIPT = `let eval = 1;`\n\n\t_, err := Compile(\"\", SCRIPT, true)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestAssignAfterStackExpand(t *testing.T) {\n\t// make sure the reference to the variable x does not remain stale after the stack is copied\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tsum += arguments[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tfunction testAssignment() {\n\t  var x = 0;\n\t  var scope = {};\n\n\t  with (scope) {\n\t\tx = (scope.x = f(0, 0, 0, 0, 0, 0, 1, 1), 1);\n\t  }\n\n\t  if (scope.x !== 2) {\n\t\tthrow new Error('#1: scope.x === 2. Actual: ' + (scope.x));\n\t  }\n\t  if (x !== 1) {\n\t\tthrow new Error('#2: x === 1. Actual: ' + (x));\n\t  }\n\t}\n\ttestAssignment();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestArgAccessFromDynamicStash(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(arg) {\n\t\tfunction test() {\n\t\t\teval(\"\");\n\t\t\treturn a;\n\t\t}\n\t\treturn arg;\n\t}\n\tf(true);\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLoadMixedLex(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet a = 1;\n\t\t{\n\t\t\tfunction inner() {\n\t\t\t\teval(\"var a = true\");\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\treturn inner();\n\t\t}\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestObjectLiteralSpread(t *testing.T) {\n\tconst SCRIPT = `\n\tlet src = {prop1: 1};\n\tObject.defineProperty(src, \"prop2\", {value: 2, configurable: true});\n\tObject.defineProperty(src, \"prop3\", {value: 3, enumerable: true, configurable: true});\n\tlet target = {prop4: 4, ...src};\n\tassert(deepEqual(target, {prop1: 1, prop3: 3, prop4: 4}));\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestArrayLiteralSpread(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a1 = [1, 2];\n\tlet a2 = [3, 4];\n\tlet a = [...a1, 0, ...a2, 1];\n\tassert(compareArray(a, [1, 2, 0, 3, 4, 1]));\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectAssignmentPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b, c;\n\t({a, b, c=3} = {a: 1, b: 2});\n\tassert.sameValue(a, 1, \"a\");\n\tassert.sameValue(b, 2, \"b\");\n\tassert.sameValue(c, 3, \"c\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectAssignmentPatternNoDyn(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tlet a, b, c;\n\t\t({a, b, c=3} = {a: 1, b: 2});\n\t\tassert.sameValue(a, 1, \"a\");\n\t\tassert.sameValue(b, 2, \"b\");\n\t\tassert.sameValue(c, 3, \"c\");\n\t})();\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectAssignmentPatternNested(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b, c, d;\n\t({a, b, c: {d} = 3} = {a: 1, b: 2, c: {d: 4}});\n\tassert.sameValue(a, 1, \"a\");\n\tassert.sameValue(b, 2, \"b\");\n\tassert.sameValue(c, undefined, \"c\");\n\tassert.sameValue(d, 4, \"d\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectAssignmentPatternEvalOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet trace = \"\";\n\tlet target_obj = {};\n\n\tfunction src() {\n\t    trace += \"src(),\";\n\t\treturn {\n\t\t\tget a() {\n\t\t\t\ttrace += \"get a,\";\n\t\t\t\treturn \"a\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction prop1() {\n\t\ttrace += \"prop1(),\"\n\t\treturn {\n\t\t\ttoString: function() {\n\t\t\t\ttrace += \"prop1-to-string(),\";\n\t\t\t\treturn \"a\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction prop2() {\n\t\ttrace += \"prop2(),\";\n\t\treturn {\n\t\t\ttoString: function() {\n\t\t\t\ttrace += \"prop2-to-string(),\";\n\t\t\t\treturn \"b\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction target() {\n\t\ttrace += \"target(),\"\n\t\treturn target_obj;\n\t}\n\t\n\tlet a, b;\n\t\n\t({[prop1()]: target().a, [prop2()]: b} = src());\n\tif (target_obj.a !== \"a\") {\n\t\tthrow new Error(\"target_obj.a=\"+target_obj.a);\n\t}\n\ttrace;\n\t`\n\ttestScript(SCRIPT, asciiString(\"src(),prop1(),prop1-to-string(),target(),get a,prop2(),prop2-to-string(),\"), t)\n}\n\nfunc TestArrayAssignmentPatternEvalOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet trace = \"\";\n\n\tlet src_arr = {\n\t\t[Symbol.iterator]: function() {\n\t\t\tlet done = false;\n\t\t\treturn {\n\t\t\t\tnext: function() {\n\t\t\t\t\ttrace += \"next,\";\n\t\t\t\t\tif (!done) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\treturn {value: 0};\n\t\t\t\t\t}\n\t\t\t\t\treturn {done: true};\n\t\t\t\t},\n\t\t\t\treturn: function() {\n\t\t\t\t\ttrace += \"return,\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction src() {\n\t\ttrace += \"src(),\";\n\t\treturn src_arr;\n\t}\n\n\tlet tgt = {\n\t\tget a() {\n\t\t\ttrace += \"get a,\";\n\t\t\treturn \"a\";\n\t\t},\n\t\tget b() {\n\t\t\ttrace += \"get b,\";\n\t\t\treturn \"b\";\n\t\t}\n\t}\n\n\tfunction target() {\n\t\ttrace += \"target(),\";\n\t\treturn tgt;\n\t}\n\n\tfunction default_a() {\n\t\ttrace += \"default a,\";\n\t\treturn \"def_a\";\n\t}\n\n\tfunction default_b() {\n\t\ttrace += \"default b,\";\n\t\treturn \"def_b\";\n\t}\n\n\t([target().a = default_a(), target().b = default_b()] = src());\n\ttrace;\n\t`\n\ttestScript(SCRIPT, asciiString(\"src(),target(),next,target(),next,default b,\"), t)\n}\n\nfunc TestObjectAssignPatternRest(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b, c, d;\n\t({a, b, c, ...d} = {a: 1, b: 2, d: 4});\n\tassert.sameValue(a, 1, \"a\");\n\tassert.sameValue(b, 2, \"b\");\n\tassert.sameValue(c, undefined, \"c\");\n\tassert(deepEqual(d, {d: 4}), \"d\");\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectBindPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tlet {a, b, c, ...d} = {a: 1, b: 2, d: 4};\n\tassert.sameValue(a, 1, \"a\");\n\tassert.sameValue(b, 2, \"b\");\n\tassert.sameValue(c, undefined, \"c\");\n\tassert(deepEqual(d, {d: 4}), \"d\");\n\n\tvar { x: y, } = { x: 23 };\n\t\n\tassert.sameValue(y, 23);\n\t\n\tassert.throws(ReferenceError, function() {\n\t  x;\n\t});\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestObjLiteralShorthandWithInitializer(t *testing.T) {\n\tconst SCRIPT = `\n\to = {a=1};\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestObjLiteralShorthandLetStringLit(t *testing.T) {\n\tconst SCRIPT = `\n\to = {\"let\"};\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestObjLiteralComputedKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tlet o = {\n\t\tget [Symbol.toString]() {\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestObjLiteralComputedKeysEvalOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet trace = [];\n\tfunction key() {\n\t\ttrace.push(\"key\");\n\t\treturn {\n\t\t\ttoString: function() {\n\t\t\t\ttrace.push(\"key-toString\");\n\t\t\t\treturn \"key\";\n\t\t\t}\n\t\t}\n\t}\n\tfunction val() {\n\t\ttrace.push(\"val\");\n\t\treturn \"val\";\n\t}\n\t\n\tconst _ = {\n\t\t[key()]: val(),\n\t}\n\t\n\ttrace.join(\",\");\n\t`\n\ttestScript(SCRIPT, asciiString(\"key,key-toString,val\"), t)\n}\n\nfunc TestArrayAssignPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b;\n\t([a, b] = [1, 2]);\n\ta === 1 && b === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayAssignPattern1(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b;\n\t([a = 3, b = 2] = [1]);\n\ta === 1 && b === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayAssignPatternLHS(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a = {};\n\t[ a.b, a['c'] = 2 ] = [1];\n\ta.b === 1 && a.c === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayAssignPatternElision(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b;\n\t([a,, b] = [1, 4, 2]);\n\ta === 1 && b === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayAssignPatternRestPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tlet a, b, z;\n\t[ z, ...[a, b] ] = [0, 1, 2];\n\tz === 0 && a === 1 && b === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestArrayBindingPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tlet [a, b] = [1, 2];\n\ta === 1 && b === 2;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestObjectPatternShorthandInit(t *testing.T) {\n\tconst SCRIPT = `\n\t[...{ x = 1 }] = [];\n\tx;\n\t`\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestArrayBindingPatternRestPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tconst [a, b, ...[c, d]] = [1, 2, 3, 4];\n\ta === 1 && b === 2 && c === 3 && d === 4;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestForVarPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {a: 1};\n\tvar trace = \"\";\n\tfor (var [key, value] of Object.entries(o)) {\n\t\ttrace += key+\":\"+value;\n\t}\n\ttrace;\n\t`\n\ttestScript(SCRIPT, asciiString(\"a:1\"), t)\n}\n\nfunc TestForLexPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {a: 1};\n\tvar trace = \"\";\n\tfor (const [key, value] of Object.entries(o)) {\n\t\ttrace += key+\":\"+value;\n\t}\n\ttrace;\n\t`\n\ttestScript(SCRIPT, asciiString(\"a:1\"), t)\n}\n\nfunc TestBindingPatternRestTrailingComma(t *testing.T) {\n\tconst SCRIPT = `\n\tconst [a, b, ...rest,] = [];\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestAssignPatternRestTrailingComma(t *testing.T) {\n\tconst SCRIPT = `\n\t([a, b, ...rest,] = []);\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n}\n\nfunc TestFuncParamInitializerSimple(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = 1) {\n\t\treturn a;\n\t}\n\t\"\"+f()+f(2);\n\t`\n\ttestScript(SCRIPT, asciiString(\"12\"), t)\n}\n\nfunc TestFuncParamObjectPatternSimple(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f({a, b} = {a: 1, b: 2}) {\n\t\treturn \"\" + a + b;\n\t}\n\t\"\"+f()+\" \"+f({a: 3, b: 4});\n\t`\n\ttestScript(SCRIPT, asciiString(\"12 34\"), t)\n}\n\nfunc TestFuncParamRestStackSimple(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(arg1, ...rest) {\n\t\treturn rest;\n\t}\n\tlet ar = f(1, 2, 3);\n\tar.join(\",\");\n\t`\n\ttestScript(SCRIPT, asciiString(\"2,3\"), t)\n}\n\nfunc TestFuncParamRestStashSimple(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(arg1, ...rest) {\n\t\teval(\"true\");\n\t\treturn rest;\n\t}\n\tlet ar = f(1, 2, 3);\n\tar.join(\",\");\n\t`\n\ttestScript(SCRIPT, asciiString(\"2,3\"), t)\n}\n\nfunc TestRestArgsNotInStash(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(...rest) {\n\t\t() => rest;\n\t\treturn rest.length;\n\t}\n\tf(1,2);\n\t`\n\ttestScript(SCRIPT, valueInt(2), t)\n}\n\nfunc TestRestArgsInStash(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(first, ...rest) {\n\t\t() => first;\n\t\t() => rest;\n\t\treturn rest.length;\n\t}\n\tf(1,2);\n\t`\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestRestArgsInStashFwdRef(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(first = eval(), ...rest) {\n\t\t() => first;\n\t\t() => rest;\n\t\treturn rest.length === 1 && rest[0] === 2;\n\t}\n\tf(1,2);\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFuncParamRestPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(arg1, ...{0: rest1, 1: rest2}) {\n\t\treturn \"\"+arg1+\" \"+rest1+\" \"+rest2;\n\t}\n\tf(1, 2, 3);\n\t`\n\ttestScript(SCRIPT, asciiString(\"1 2 3\"), t)\n}\n\nfunc TestFuncParamForwardRef(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = b + 1, b) {\n\t\treturn \"\"+a+\" \"+b;\n\t}\n\tf(1, 2);\n\t`\n\ttestScript(SCRIPT, asciiString(\"1 2\"), t)\n}\n\nfunc TestFuncParamForwardRefMissing(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = b + 1, b) {\n\t\treturn \"\"+a+\" \"+b;\n\t}\n\tassert.throws(ReferenceError, function() {\n\t\tf();\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestFuncParamInnerRef(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = inner) {\n\t\tvar inner = 42;\n\t\treturn a;\n\t}\n\tassert.throws(ReferenceError, function() {\n\t\tf();\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestFuncParamInnerRefEval(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = eval(\"inner\")) {\n\t\tvar inner = 42;\n\t\treturn a;\n\t}\n\tassert.throws(ReferenceError, function() {\n\t\tf();\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestFuncParamCalleeName(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = f) {\n\t\tvar f;\n\t\treturn f;\n\t}\n\ttypeof f();\n\t`\n\ttestScript(SCRIPT, asciiString(\"undefined\"), t)\n}\n\nfunc TestFuncParamVarCopy(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(a = f) {\n\t\tvar a;\n\t\treturn a;\n\t}\n\ttypeof f();\n\t`\n\ttestScript(SCRIPT, asciiString(\"function\"), t)\n}\n\nfunc TestFuncParamScope(t *testing.T) {\n\tconst SCRIPT = `\n\tvar x = 'outside';\n\tvar probe1, probe2;\n\t\n\tfunction f(\n\t\t_ = probe1 = function() { return x; },\n\t\t__ = (eval('var x = \"inside\";'), probe2 = function() { return x; })\n\t) {\n\t}\n\tf();\n\tprobe1()+\" \"+probe2();\n\t`\n\ttestScript(SCRIPT, asciiString(\"inside inside\"), t)\n}\n\nfunc TestDefParamsStackPtr(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A() {};\n\tA.B = function () {};\n\tfunction D(message = '') {\n\t  var C = A.B;\n\t  C([1,2,3]);\n\t};\n\t\n\tD();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestNestedVariadicCalls(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\treturn Array.prototype.join.call(arguments, \",\");\n\t}\n\tf(...[1], \"a\", f(...[2]));\n\t`\n\ttestScript(SCRIPT, asciiString(\"1,a,2\"), t)\n}\n\nfunc TestVariadicNew(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction C() {\n\t\tthis.res = Array.prototype.join.call(arguments, \",\");\n\t}\n\tvar c = new C(...[1], \"a\", new C(...[2]).res);\n\tc.res;\n\t`\n\ttestScript(SCRIPT, asciiString(\"1,a,2\"), t)\n}\n\nfunc TestVariadicUseStackVars(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction A(message) { return message; }\n\tfunction B(...args){\n\t\t\treturn A(...args);\n\t}\n\tB(\"C\");\n\t`\n\ttestScript(SCRIPT, asciiString(\"C\"), t)\n}\n\nfunc TestCatchParamPattern(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tlet x = 3;\n\t\ttry {\n\t\t\tthrow {a: 1, b: 2};\n\t\t} catch ({a, b, c = x}) {\n\t\t\tlet x = 99;\n\t\t\treturn \"\"+a+\" \"+b+\" \"+c;\n\t\t}\n\t}\n\tf();\n\t`\n\ttestScript(SCRIPT, asciiString(\"1 2 3\"), t)\n}\n\nfunc TestArrowUseStrict(t *testing.T) {\n\t// simple parameter list -- ok\n\t_, err := Compile(\"\", \"(a) => {'use strict';}\", false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// non-simple parameter list -- syntax error\n\t_, err = Compile(\"\", \"(a=0) => {'use strict';}\", false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestArrowBoxedThis(t *testing.T) {\n\tconst SCRIPT = `\n\tvar context;\n\tfn = function() {\n\t\treturn (arg) => { var local; context = this; };\n\t};\n\t\n\tfn()();\n\tcontext === this;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestParameterOverride(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(arg) {\n\t\tvar arg = arg || \"default\"\n\t\treturn arg\n\t}\n\tf()\n\t`\n\ttestScript(SCRIPT, asciiString(\"default\"), t)\n}\n\nfunc TestEvalInIterScope(t *testing.T) {\n\tconst SCRIPT = `\n\tfor (let a = 0; a < 1; a++) {\n\t\teval(\"a\");\n\t}\n\t`\n\n\ttestScript(SCRIPT, valueInt(0), t)\n}\n\nfunc TestTemplateLiterals(t *testing.T) {\n\tvm := New()\n\t_, err := vm.RunString(\"const a = 1, b = 'b';\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf := func(t *testing.T, template, expected string) {\n\t\tres, err := vm.RunString(template)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif actual := res.Export(); actual != expected {\n\t\t\tt.Fatalf(\"Expected: %q, actual: %q\", expected, actual)\n\t\t}\n\t}\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\tf(t, \"``\", \"\")\n\t})\n\tt.Run(\"noSub\", func(t *testing.T) {\n\t\tf(t, \"`test`\", \"test\")\n\t})\n\tt.Run(\"emptyTail\", func(t *testing.T) {\n\t\tf(t, \"`a=${a},b=${b}`\", \"a=1,b=b\")\n\t})\n\tt.Run(\"emptyHead\", func(t *testing.T) {\n\t\tf(t, \"`${a},b=${b}$`\", \"1,b=b$\")\n\t})\n\tt.Run(\"headAndTail\", func(t *testing.T) {\n\t\tf(t, \"`a=${a},b=${b}$`\", \"a=1,b=b$\")\n\t})\n}\n\nfunc TestTaggedTemplate(t *testing.T) {\n\tconst SCRIPT = `\n\t\tlet res;\n\t\tconst o = {\n\t\t\ttmpl() {\n\t\t\t\tres = this;\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t}\n\t\t` +\n\t\t\"o.tmpl()`test`;\" + `\n\t\tres === o;\n\t\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDuplicateGlobalFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction a(){}\n\tfunction b(){ return \"b\" }\n\tfunction c(){ return \"c\" }\n\tfunction a(){}\n\tb();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"b\"), t)\n}\n\nfunc TestDuplicateFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tfunction a(){}\n\t\tfunction b(){ return \"b\" }\n\t\tfunction c(){ return \"c\" }\n\t\tfunction a(){}\n\t\treturn b();\n\t}\n\tf();\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"b\"), t)\n}\n\nfunc TestSrcLocations(t *testing.T) {\n\t// Do not reformat, assertions depend on the line and column numbers\n\tconst SCRIPT = `\n\tlet i = {\n\t\tvalueOf() {\n\t\t\tthrow new Error();\n\t\t}\n\t};\n\ttry {\n\t\ti++;\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"valueOf\", 4, 10],\n\t\t\t\t\t\t[\"test.js\", \"\", 8, 3]\n\t\t\t\t\t\t]);\n\t}\n\n\tObject.defineProperty(globalThis, \"x\", {\n\t\tget() {\n\t\t\tthrow new Error();\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error();\n\t\t}\n\t});\n\n\ttry {\n\t\tx;\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"get\", 17, 10],\n\t\t\t\t\t\t[\"test.js\", \"\", 25, 3]\n\t\t\t\t\t\t]);\n\t}\n\n\ttry {\n\t\tx++;\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"get\", 17, 10],\n\t\t\t\t\t\t[\"test.js\", \"\", 33, 3]\n\t\t\t\t\t\t]);\n\t}\n\n\ttry {\n\t\tx = 2;\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"set\", 20, 10],\n\t\t\t\t\t\t[\"test.js\", \"\", 41, 3]\n\t\t\t\t\t\t]);\n\t}\n\n\ttry {\n\t\t+i;\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"valueOf\", 4, 10],\n\t\t\t\t\t\t[\"test.js\", \"\", 49, 4]\n\t\t\t\t\t\t]);\n\t}\n\n\ttry {\n\t\tlet n;\n\t\tn.field = {\n\t        \"key1\": \"test\",\n\t        \"key2\": {},\n\t\t}\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"\", 58, 5]\n\t\t\t\t\t\t]);\n\t}\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestSrcLocationThrowLiteral(t *testing.T) {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tconst z = 1;\n\tthrow \"\";\n\t`)\n\tif ex, ok := err.(*Exception); ok {\n\t\tpos := ex.stack[0].Position()\n\t\tif pos.Line != 3 {\n\t\t\tt.Fatal(pos)\n\t\t}\n\t} else {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSrcLocation(t *testing.T) {\n\tprg := MustCompile(\"test.js\", `\nf();\nvar x = 1;\nlet y = 1;\nlet [z1, z2] = [0, 0];\n\nvar [z3, z4] = [0, 0];\n\t`, false)\n\tconst (\n\t\tvarLine     = 3\n\t\tletLine     = 4\n\t\tdstrLetLine = 5\n\t\tdstrVarLine = 7\n\t)\n\tlinesOfInterest := map[int]string{\n\t\tvarLine:     \"var\",\n\t\tletLine:     \"let\",\n\t\tdstrLetLine: \"destruct let\",\n\t\tdstrVarLine: \"destruct var\",\n\t}\n\tfor i := range prg.code {\n\t\tloc := prg.src.Position(prg.sourceOffset(i))\n\t\tdelete(linesOfInterest, loc.Line)\n\t\tif len(linesOfInterest) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, v := range linesOfInterest {\n\t\tt.Fatalf(\"no %s line\", v)\n\t}\n}\n\nfunc TestBadObjectKey(t *testing.T) {\n\t_, err := Compile(\"\", \"({!:0})\", false)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestConstantFolding(t *testing.T) {\n\ttestValues := func(prg *Program, result Value, t *testing.T) {\n\t\tvalues := make(map[unistring.String]struct{})\n\t\tfor _, ins := range prg.code {\n\t\t\tif lv, ok := ins.(loadVal); ok {\n\t\t\t\tvalues[lv.v.string()] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tif len(values) != 1 {\n\t\t\tprg.dumpCode(t.Logf)\n\t\t\tt.Fatalf(\"values: %v\", values)\n\t\t}\n\t}\n\tf := func(src string, result Value, t *testing.T) {\n\t\tprg := MustCompile(\"test.js\", src, false)\n\t\ttestValues(prg, result, t)\n\t\tNew().testPrg(prg, result, t)\n\t}\n\tff := func(src string, result Value, t *testing.T) {\n\t\tprg := MustCompile(\"test.js\", src, false)\n\t\tfl := prg.code[0].(*newFunc)\n\t\ttestValues(fl.prg, result, t)\n\t\tNew().testPrg(prg, result, t)\n\t}\n\n\tt.Run(\"lexical binding\", func(t *testing.T) {\n\t\tf(\"const x = 1 + 2; x\", valueInt(3), t)\n\t})\n\tt.Run(\"var binding\", func(t *testing.T) {\n\t\tf(\"var x = 1 + 2; x\", valueInt(3), t)\n\t})\n\tt.Run(\"assignment\", func(t *testing.T) {\n\t\tf(\"x = 1 + 2; x\", valueInt(3), t)\n\t})\n\tt.Run(\"object pattern\", func(t *testing.T) {\n\t\tf(\"const {x = 1 + 2} = {}; x\", valueInt(3), t)\n\t})\n\tt.Run(\"array pattern\", func(t *testing.T) {\n\t\tf(\"const [x = 1 + 2] = []; x\", valueInt(3), t)\n\t})\n\tt.Run(\"object literal\", func(t *testing.T) {\n\t\tf(\"var o = {x: 1 + 2}; o.x\", valueInt(3), t)\n\t})\n\tt.Run(\"array literal\", func(t *testing.T) {\n\t\tf(\"var a = [3, 3, 3, 1 + 2]; a[3]\", valueInt(3), t)\n\t})\n\tt.Run(\"default function parameter\", func(t *testing.T) {\n\t\tff(\"function f(arg = 1 + 2) {return arg}; f()\", valueInt(3), t)\n\t})\n\tt.Run(\"return\", func(t *testing.T) {\n\t\tff(\"function f() {return 1 + 2}; f()\", valueInt(3), t)\n\t})\n}\n\nfunc TestStringInterning(t *testing.T) {\n\tconst SCRIPT = `\n\tconst str1 = \"Test\";\n\tfunction f() {\n\t\treturn \"Test\";\n\t}\n\t[str1, f()];\n\t`\n\tvm := New()\n\tres, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstr1 := res.(*Object).Get(\"0\").String()\n\tstr2 := res.(*Object).Get(\"1\").String()\n\tif unsafe.StringData(str1) != unsafe.StringData(str2) {\n\t\tt.Fatal(\"not interned\")\n\t}\n}\n\nfunc TestAssignBeforeInit(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(ReferenceError, () => {\n\t\ta = 1;\n\t\tlet a;\n\t});\n\n\tassert.throws(ReferenceError, () => {\n\t    ({a, b} = {a: 1, b: 2});\n\t    let a, b;\n\t});\n\n\tassert.throws(ReferenceError, () => {\n\t\t(function() {\n\t\t\teval(\"\");\n\t\t\t({a} = {a: 1});\n\t\t})();\n\t\tlet a;\n\t});\n\n\tassert.throws(ReferenceError, () => {\n\t    const ctx = {x: 1};\n\t    function t() {\n\t        delete ctx.x;\n\t        return 42;\n\t    }\n\t    with(ctx) {\n\t        (function() {\n\t            'use strict';\n\t            ({x} = {x: t()});\n\t        })();\n\t    }\n\t    return ctx.x;\n\t});\n\n\tassert.throws(ReferenceError, () => {\n\t    const ctx = {x: 1};\n\t    function t() {\n\t        delete ctx.x;\n\t        return 42;\n\t    }\n\t    with(ctx) {\n\t        (function() {\n\t            'use strict';\n\t\t\t\tconst src = {};\n\t\t\t\tObject.defineProperty(src, \"x\", {\n\t\t\t\t\tget() {\n\t\t\t\t\t\treturn t();\n\t\t\t\t\t}\n\t\t\t\t});\n\t            ({x} = src);\n\t        })();\n\t    }\n\t    return ctx.x;\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestOptChainCallee(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a;\n\tassert.sameValue(a?.(true), undefined);\n\ta = null;\n\tassert.sameValue(a?.(), undefined);\n\tvar o = {n: null};\n\tassert.sameValue(o.m?.(true), undefined);\n\tassert.sameValue(o.n?.(true), undefined);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectLiteralSuper(t *testing.T) {\n\tconst SCRIPT = `\n\tconst proto = {\n\t\tm() {\n\t\t\treturn 40;\n\t\t}\n\t}\n\tconst o = {\n\t\tm() {\n\t\t\treturn super.m() + 2;\n\t\t}\n\t}\n\to.__proto__ = proto;\n\to.m();\n\t`\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestClassCaptureThisInFieldInit(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\n\tclass C {\n\t\ta = () => this\n\t}\n\n\tlet c = new C();\n\tc.a() === c;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassUseThisInFieldInit(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\n\tclass C {\n\t\ta = this\n\t}\n\n\tlet c = new C();\n\tc.a === c;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassCaptureThisInStaticFieldInit(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\n\tclass C {\n\t\tstatic a = (capture = () => this, 0)\n\t}\n\n\tlet c = new C();\n\tcapture() === C;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassDynCaptureThisInStaticFieldInit(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\tstatic a = eval(\"this\")\n\t}\n\n\tC.a === C;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestCompileClass(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C extends Error {\n\t\ta = true;\n\t\tb = 1;\n\t\t[\"b\".toUpperCase()] = 2\n\t\tstatic A = Math.random() < 1\n\t\tconstructor(message = \"My Error\") {\n\t\t\tsuper(message);\n\t\t}\n\t\tstatic M() {\n\t\t}\n\t\tstatic M1() {\n\t\t}\n\t\tm() {\n\t\t\t//return C.a;\n\t\t}\n\t\tm1() {\n\t\t\treturn true;\n\t\t}\n\t\tstatic {\n\t\t\tthis.supername = super.name;\n\t\t}\n\t}\n\tlet c = new C();\n\tc.a === true && c.b === 1 && c.B === 2 && c.m1() && C.A && C.supername === \"Error\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSuperInEval(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C extends Error {\n\t\tconstructor() {\n\t\t\teval(\"super()\");\n\t\t}\n\t\tm() {\n\t\t\treturn eval(\"super.name\");\n\t\t}\n\t}\n\tlet c = new C();\n\tc.m() === \"Error\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSuperRefDot(t *testing.T) {\n\tconst SCRIPT = `\n\tlet thisGet, thisSet;\n\tclass P {\n\t\t_p = 0\n\t    get p() {\n\t\t\tthisGet = this;\n\t        return this._p;\n\t    }\n\t\tset p(v) {\n\t\t\tthisSet = this;\n\t\t\tthis._p = v;\n\t\t}\n\t}\n\n\tclass C extends P {\n\t    g() {\n\t        return super.p;\n\t    }\n\t\ts(v) {\n\t\t\tsuper.p = v;\n\t\t}\n\n\t\tinc() {\n\t\t\tsuper.p++;\n\t\t}\n\t\tincR() {\n\t\t\treturn super.p++;\n\t\t}\n\n\t\tinc1() {\n\t\t\t++super.p;\n\t\t}\n\n\t\tinc1R() {\n\t\t\treturn ++super.p;\n\t\t}\n\t\tunary() {\n\t\t\treturn +super.p;\n\t\t}\n\t\tpattern() {\n\t\t\t[super.p] = [9];\n\t\t}\n\t}\n\n\tlet o = new C();\n\tassert.sameValue(o.g(), 0, \"get value\");\n\tassert.sameValue(thisGet, o, \"get this\");\n\to.s(1);\n\tassert.sameValue(o._p, 1, \"set value\");\n\tassert.sameValue(thisSet, o, \"set this\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\to.inc();\n\tassert.sameValue(o._p, 2, \"inc value\");\n\tassert.sameValue(thisGet, o, \"inc thisGet\");\n\tassert.sameValue(thisSet, o, \"inc thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\tassert.sameValue(o.incR(), 2, \"incR result\");\n\tassert.sameValue(o._p, 3, \"incR value\");\n\tassert.sameValue(thisGet, o, \"incR thisGet\");\n\tassert.sameValue(thisSet, o, \"incR thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\to.inc1();\n\tassert.sameValue(o._p, 4, \"inc1 value\");\n\tassert.sameValue(thisGet, o, \"inc1 thisGet\");\n\tassert.sameValue(thisSet, o, \"inc1 thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\tassert.sameValue(o.inc1R(), 5, \"inc1R result\");\n\tassert.sameValue(o._p, 5, \"inc1R value\");\n\tassert.sameValue(thisGet, o, \"inc1R thisGet\");\n\tassert.sameValue(thisSet, o, \"inc1R thisSet\");\n\n\tassert.sameValue(o.unary(), 5, \"unary\");\n\n\to.pattern();\n\tassert.sameValue(o._p, 9, \"pattern\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestPrivateRefDot(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t#p = 0;\n\t    g() {\n\t        return this.#p;\n\t    }\n\t\ts(v) {\n\t\t\tthis.#p = v;\n\t\t}\n\n\t\tinc() {\n\t\t\tthis.#p++;\n\t\t}\n\t\tincR() {\n\t\t\treturn this.#p++;\n\t\t}\n\n\t\tinc1() {\n\t\t\t++this.#p;\n\t\t}\n\n\t\tinc1R() {\n\t\t\treturn ++this.#p;\n\t\t}\n\t\tpattern() {\n\t\t\t[this.#p] = [9];\n\t\t}\n\t}\n\n\tlet o = new C();\n\tassert.sameValue(o.g(), 0, \"get value\");\n\to.s(1);\n\tassert.sameValue(o.g(), 1, \"set value\");\n\n\to.inc();\n\tassert.sameValue(o.g(), 2, \"inc value\");\n\n\tassert.sameValue(o.incR(), 2, \"incR result\");\n\tassert.sameValue(o.g(), 3, \"incR value\");\n\n\to.inc1();\n\tassert.sameValue(o.g(), 4, \"inc1 value\");\n\n\tassert.sameValue(o.inc1R(), 5, \"inc1R result\");\n\tassert.sameValue(o.g(), 5, \"inc1R value\");\n\n\to.pattern();\n\tassert.sameValue(o.g(), 9, \"pattern\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestPrivateRefDotEval(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t#p = 0;\n\t    g() {\n\t        return eval(\"this.#p\");\n\t    }\n\t\ts(v) {\n\t\t\teval(\"this.#p = v\");\n\t\t}\n\n\t\tincR() {\n\t\t\treturn eval(\"this.#p++\");\n\t\t}\n\n\t\tinc1R() {\n\t\t\treturn eval(\"++this.#p\");\n\t\t}\n\n\t\tpattern() {\n\t\t\teval(\"[this.#p] = [9]\");\n\t\t}\n\t}\n\n\tlet o = new C();\n\tassert.sameValue(o.g(), 0, \"get value\");\n\to.s(1);\n\tassert.sameValue(o.g(), 1, \"set value\");\n\n\tassert.sameValue(o.incR(), 1, \"incR result\");\n\tassert.sameValue(o.g(), 2, \"incR value\");\n\n\tassert.sameValue(o.inc1R(), 3, \"inc1R result\");\n\tassert.sameValue(o.g(), 3, \"inc1R value\");\n\n\to.pattern();\n\tassert.sameValue(o.g(), 9, \"pattern\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestSuperRefDotCallee(t *testing.T) {\n\tconst SCRIPT = `\n\tclass P {\n\t    get p() {\n\t        return function() {\n\t            return this;\n\t        };\n\t    }\n\t}\n\n\tclass C extends P {\n\t    m() {\n\t        return super.p();\n\t    }\n\t}\n\n\tlet o = new C();\n\to.m() === o;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSuperRefBracket(t *testing.T) {\n\tconst SCRIPT = `\n\tlet PROP = \"p\";\n\tlet thisGet, thisSet;\n\tclass P {\n\t\t_p = 0\n\t    get p() {\n\t\t\tthisGet = this;\n\t        return this._p;\n\t    }\n\t\tset p(v) {\n\t\t\tthisSet = this;\n\t\t\tthis._p = v;\n\t\t}\n\t}\n\n\tclass C extends P {\n\t    g() {\n\t        return super[PROP];\n\t    }\n\t\ts(v) {\n\t\t\tsuper[PROP] = v;\n\t\t}\n\n\t\tinc() {\n\t\t\tsuper[PROP]++;\n\t\t}\n\t\tincR() {\n\t\t\treturn super[PROP]++;\n\t\t}\n\n\t\tinc1() {\n\t\t\t++super[PROP];\n\t\t}\n\n\t\tinc1R() {\n\t\t\treturn ++super[PROP];\n\t\t}\n\t\tpattern() {\n\t\t\t[super[PROP]] = [9];\n\t\t}\n\t}\n\n\tlet o = new C();\n\tassert.sameValue(o.g(), 0, \"get value\");\n\tassert.sameValue(thisGet, o, \"get this\");\n\to.s(1);\n\tassert.sameValue(o._p, 1, \"set value\");\n\tassert.sameValue(thisSet, o, \"set this\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\to.inc();\n\tassert.sameValue(o._p, 2, \"inc value\");\n\tassert.sameValue(thisGet, o, \"inc thisGet\");\n\tassert.sameValue(thisSet, o, \"inc thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\tassert.sameValue(o.incR(), 2, \"incR result\");\n\tassert.sameValue(o._p, 3, \"incR value\");\n\tassert.sameValue(thisGet, o, \"incR thisGet\");\n\tassert.sameValue(thisSet, o, \"incR thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\to.inc1();\n\tassert.sameValue(o._p, 4, \"inc1 value\");\n\tassert.sameValue(thisGet, o, \"inc1 thisGet\");\n\tassert.sameValue(thisSet, o, \"inc1 thisSet\");\n\n\tthisGet = undefined;\n\tthisSet = undefined;\n\tassert.sameValue(o.inc1R(), 5, \"inc1R result\");\n\tassert.sameValue(o._p, 5, \"inc1R value\");\n\tassert.sameValue(thisGet, o, \"inc1R thisGet\");\n\tassert.sameValue(thisSet, o, \"inc1R thisSet\");\n\n\to.pattern();\n\tassert.sameValue(o._p, 9, \"pattern\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestSuperRefBracketEvalOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tlet keyCallCount = 0;\n\n\tfunction key() {\n\t\tkeyCallCount++;\n\t\tC.prototype.__proto__ = null;\n\t    return \"k\";\n\t}\n\n\tclass C {\n\t    constructor() {\n\t        super[key()]++;\n\t    }\n\t}\n\n\tassert.throws(TypeError, () => new C());\n\tassert.sameValue(keyCallCount, 1);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestSuperRefBracketCallee(t *testing.T) {\n\tconst SCRIPT = `\n\tlet PROP = \"p\";\n\tclass P {\n\t    get p() {\n\t        return function() {\n\t            return this;\n\t        };\n\t    }\n\t}\n\n\tclass C extends P {\n\t    m() {\n\t        return super[PROP]();\n\t    }\n\t}\n\n\tlet o = new C();\n\to.m() === o;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSuperBaseInCtor(t *testing.T) {\n\tconst SCRIPT = `\n\tlet result;\n\tclass Derived extends Object {\n\t    constructor() {\n\t        super();\n\t        result = super.constructor === Object;\n\t    }\n\t}\n\tnew Derived();\n\tresult;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassNamedEval(t *testing.T) {\n\tconst SCRIPT = `\n\tconst C = class {\n\t}\n\n\tC.name === \"C\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassNonDerived(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction initF() {\n\t}\n\tclass C {\n\t    f = initF()\n\t}\n\tlet c = new C();\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestClassExpr(t *testing.T) {\n\tconst SCRIPT = `\n\ttypeof Object.getOwnPropertyDescriptor(class {get f() {}}.prototype, \"f\").get === \"function\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassSuperInHeritage(t *testing.T) {\n\tconst SCRIPT = `\n\tclass P {\n\t    a() {\n\t        return Error;\n\t    }\n\t}\n\n\tclass C extends P {\n\t    m() {\n\t        class Inner extends super.a() {\n\t        }\n\t        return new Inner();\n\t    }\n\t}\n\n\tnew C().m() instanceof Error;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassSuperInHeritageExpr(t *testing.T) {\n\tconst SCRIPT = `\n\tclass P {\n\t    a() {\n\t        return Error;\n\t    }\n\t}\n\n\tclass C extends P {\n\t    m() {\n\t\t\tfunction f(cls) {\n\t\t\t\treturn new cls();\n\t\t\t}\n\t        return f(class Inner extends super.a() {\n\t        })\n\t    }\n\t}\n\n\tnew C().m() instanceof Error;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassReferToBinding(t *testing.T) {\n\tconst SCRIPT = `\n\tconst CC = class C {\n\t\tstatic T = 40\n\t    f = C.T + 2\n\t}\n\tlet c = new CC();\n\tc.f;\n\t`\n\n\ttestScript(SCRIPT, intToValue(42), t)\n}\n\nfunc TestClassReferToBindingInStaticDecl(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\tstatic T = C.name\n\t}\n\tC.T;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"C\"), t)\n}\n\nfunc TestClassReferToBindingInStaticEval(t *testing.T) {\n\tconst SCRIPT = `\n\tconst CC = class C {\n\t\tstatic T = eval(\"C.name\")\n\t}\n\tCC.T;\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"C\"), t)\n}\n\nfunc TestClassReferToBindingFromHeritage(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(ReferenceError, () => {\n\t\tclass C extends C {\n\t\t}\n\t});\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestClassCaptureSuperCallInArrowFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tlet f;\n\tclass C extends class {} {\n\t\tconstructor() {\n\t\t\tf = () => super();\n\t\t\tf();\n\t\t}\n\t}\n\tlet c = new C();\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestClassCaptureSuperCallInNestedArrowFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tlet f;\n\tclass P {\n\t}\n\tclass C extends P {\n\t\tconstructor() {\n\t\t\tf = () => () => super();\n\t\t\tf()();\n\t\t}\n\t}\n\tnew C() instanceof P;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestThisInEval(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(eval(\"this\"), this, \"global\");\n\n\tlet o = {\n\t\tf() {\n\t\t\treturn eval(\"this\");\n\t\t}\n\t}\n\tassert.sameValue(o.f(), o, \"obj literal\");\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestStaticAsBindingTarget(t *testing.T) {\n\tconst SCRIPT = `\n\tlet [static] = [];\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestEvalInStaticFieldInit(t *testing.T) {\n\tconst SCRIPT = `\n\tvar C = class {\n\t\tstatic f = 'test';\n\t\tstatic g = this.f + '262';\n\t\tstatic h = eval('this.g') + 'test';\n\t}\n\tC.f === \"test\" && C.g === \"test262\" && C.h === \"test262test\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestClassPrivateElemInEval(t *testing.T) {\n\tconst SCRIPT = `\n\tlet f1, f2;\n\n\tclass C extends (f1 = o => eval(\"o.#a\"), Object) {\n\t    static #a = 42;\n\t    static {\n\t        f2 = o => eval(\"o.#a\");\n\t\t\tassert.sameValue(C.#a, 42);\n\t\t\tassert.sameValue((() => C.#a)(), 42);\n\t    }\n\t}\n\n\tassert.throws(SyntaxError, () => f1(C));\n\tassert.sameValue(f2(C), 42);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestClassPrivateElemInIndirectEval(t *testing.T) {\n\tconst SCRIPT = `\n\tlet f1, f2;\n\n\tclass C extends (f1 = o => (0, eval)(\"o.#a\"), Object) {\n\t    static #a = 42;\n\t    static {\n\t        f2 = o => (0, eval)(\"o.#a\");\n\t\t\tassert.throws(SyntaxError, () => (0, eval)(\"C.#a\"));\n\t    }\n\t}\n\n\tassert.throws(SyntaxError, () => f1(C));\n\tassert.throws(SyntaxError, () => f2(C));\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestClassPrivateElemInFunction(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.throws(SyntaxError, () => {\n\t\tclass C {\n\t\t    static #a = 42;\n\t\t    static {\n\t\t        Function(\"o\", \"return o.#a\");\n\t\t    }\n\t\t}\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestClassPrivateElementsDecl(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t#a = 42;\n\t\tget #b() {}\n\t\tset #b(_) {}\n\t\tget c() {\n\t\t\treturn this.#a;\n\t\t}\n\t\t#m() {\n\t\t\treturn this.#a;\n\t\t}\n\t\tstatic getter(inst) {\n\t\t\treturn inst.#m();\n\t\t}\n\t}\n\tlet c = new C();\n\tc.c + C.getter(c);\n\t`\n\ttestScript(SCRIPT, intToValue(84), t)\n}\n\nfunc TestPrivateIn(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t#a = 42;\n\t\tstatic check(inst) {\n\t\t\treturn #a in inst;\n\t\t}\n\t}\n\tlet c = new C();\n\tC.check(c);\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDeletePropOfNonObject(t *testing.T) {\n\tconst SCRIPT = `\n\tdelete 'Test262'[100] && delete 'Test262'.a && delete 'Test262'['@'];\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestKeywordsAsLabels(t *testing.T) {\n\tconst SCRIPT = `\n\tlet: for (let i = 0; i < 2; i++) {\n\t\tif (i === 0) continue let;\n\t\tbreak let;\n\t}\n\n\t\\u006Cet: for (let i = 0; i < 2; i++) {\n\t\tif (i === 0) continue \\u006Cet;\n\t\tbreak \\u006Cet;\n\t}\n\n\tyield: for (let i = 0; i < 2; i++) {\n\t\tif (i === 0) continue yield;\n\t\tbreak yield;\n\t}\n\n\tyi\\u0065ld: for (let i = 0; i < 2; i++) {\n\t\tif (i === 0) continue yi\\u0065ld;\n\t\tbreak yi\\u0065ld;\n\t}\n`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestThisResolutionWithArg(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\tfunction f(arg) {\n\t\tcapture = () => this; // move 'this' to stash\n\t\treturn [this, arg];\n\t}\n\tconst _this = {};\n\tconst arg = {};\n\tconst [_this1, arg1] = f.call(_this, arg);\n\t_this1 === _this && arg1 === arg;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestThisResolutionArgInStash(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\tfunction f(arg) {\n\t\tcapture = () => this + arg; // move 'this' and arguments to stash\n\t\treturn [this, arg];\n\t}\n\tconst _this = {};\n\tconst arg = {};\n\tconst [_this1, arg1] = f.call(_this, arg);\n\t_this1 === _this && arg1 === arg;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestThisResolutionWithStackVar(t *testing.T) {\n\tconst SCRIPT = `\n\tlet capture;\n\tfunction f(arg) {\n\t\tconst _ = 1; // a stack variable\n\t\tcapture = () => this + arg; // move 'this' and arguments to stash\n\t\treturn [this, arg];\n\t}\n\tconst _this = {};\n\tconst arg = {};\n\tconst [_this1, arg1] = f.call(_this, arg);\n\t_this1 === _this && arg1 === arg;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestForInLoopContinue(t *testing.T) {\n\tconst SCRIPT = `\n\tvar globalSink;\n\t(function() {\n\t    const data = [{disabled: true}, {}];\n\t\tfunction dummy() {}\n\t    function f1() {}\n\n\t    function f() {\n\t\t\tdummy(); // move dummy to stash (so that f1 is at index 1)\n\t        for (const d of data) {\n\t            if (d.disabled) continue;\n\t            globalSink = () => d; // move d to stash\n\t            f1();\n\t        }\n\t    }\n\n\t    f();\n\t})();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestForInLoopContinueOuter(t *testing.T) {\n\tconst SCRIPT = `\n\tvar globalSink;\n\t(function() {\n\t    const data = [{disabled: true}, {}];\n\t\tfunction dummy1() {}\n\t    function f1() {}\n\n\t    function f() {\n\t\t\tdummy1();\n\t\t\tlet counter = 0;\n\t\t\tOUTER: for (let i = 0; i < 1; i++) {\n\t\t        for (const d of data) {\n\t\t            if (d.disabled) continue OUTER;\n\t\t            globalSink = () => d;\n\t\t        }\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tf1();\n\t\t\tif (counter !== 0) {\n\t\t\t\tthrow new Error(counter);\n\t\t\t}\n\t    }\n\n\t    f();\n\t})();\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestLexicalDeclInSwitch(t *testing.T) {\n\tconst SCRIPT = `\n\tswitch(0) {\n\t    case 1:\n\t        if (false) b = 3;\n\t    case 2:\n\t        const c = 1;\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestClassFieldSpecial(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\tget;\n\t\tset;\n\t\tasync;\n\t\tstatic;\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestClassMethodSpecial(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\tget() {}\n\t\tset() {}\n\t\tasync() {}\n\t\tstatic() {}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestClassMethodNumLiteral(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t0() {\n\t\t\treturn true;\n\t\t}\n\t}\n\tnew C()[0]();\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestAsyncFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tasync (x = true, y) => {};\n\tasync x => {};\n\tlet passed = false;\n\tasync function f() {\n\t\treturn true;\n\t}\n\tasync function f1(arg = true) {\n\t\tpassed = await f();\n\t}\n\tawait f1();\n\treturn passed;\n\t`\n\ttestAsyncFunc(SCRIPT, valueTrue, t)\n}\n\nfunc TestObjectLiteralComputedMethodKeys(t *testing.T) {\n\t_, err := Compile(\"\", `\n\t\t({\n\t\t    [\"__proto__\"]() {},\n\t\t    [\"__proto__\"]() {}\n\t\t})\n\t`, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = Compile(\"\", `\n\t\t({\n\t\t    get [\"__proto__\"]() {},\n\t\t    get [\"__proto__\"]() {}\n\t\t})\n\t`, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGeneratorFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tlet trace = \"\";\n\tfunction defParam() {\n\t\ttrace += \"1\";\n\t\treturn \"def\";\n\t}\n\tfunction* g(param = defParam()) {\n\t\tconst THREE = 3;\n\t\ttrace += \"2\";\n\t\tassert.sameValue(Math.floor(yield 1), THREE);\n\t\treturn 42;\n\t}\n\tlet iter = g();\n\tassert.sameValue(trace, \"1\");\n\n\tlet next = iter.next();\n\tassert.sameValue(next.value, 1);\n\tassert.sameValue(next.done, false);\n\n\tnext = iter.next(Math.PI);\n\tassert.sameValue(next.value, 42);\n\tassert.sameValue(next.done, true);\n\n\tassert.sameValue(trace, \"12\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestGeneratorMethods(t *testing.T) {\n\tconst SCRIPT = `\n\tclass C {\n\t\t*g(param) {\n\t\t\tyield 1;\n\t\t\tyield 2;\n\t\t}\n\t}\n\tlet c = new C();\n\tlet iter = c.g();\n\tlet res = iter.next();\n\tassert.sameValue(res.value, 1);\n\tassert.sameValue(res.done, false);\n\n\tres = iter.next();\n\tassert.sameValue(res.value, 2);\n\tassert.sameValue(res.done, false);\n\n\tres = iter.next();\n\tassert.sameValue(res.value, undefined);\n\tassert.sameValue(res.done, true);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestFunctionBodyClassDecl(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction as(requiredArgument = {}) {\n\t\tclass something { }\n\t};\n\t`\n\t_, err := Compile(\"\", SCRIPT, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNestedDestructArray(t *testing.T) {\n\tconst SCRIPT = `\n\tvar [\n\t\t[ h = 0 ] = [ 0 ]\n\t] = [];\n\tassert.sameValue(h, 0);\n\n\tvar [\n\t\t[ h1 = 1 ] = []\n\t] = [];\n\tassert.sameValue(h1, 1);\n\n\tvar [\n\t\t[ h2 = 1 ] = []\n\t] = [ [ 2 ] ];\n\tassert.sameValue(h2, 2);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\n/*\nfunc TestBabel(t *testing.T) {\n\tsrc, err := os.ReadFile(\"babel7.js\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvm := New()\n\t_, err = vm.RunString(string(src))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = vm.RunString(`var result = Babel.transform(\"\", {presets: [\"es2015\"]});`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}*/\n\nfunc BenchmarkCompile(b *testing.B) {\n\tdata, err := os.ReadFile(\"testdata/S15.10.2.12_A1_T1.js\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tsrc := string(data)\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := Compile(\"test.js\", src, false)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "date.go",
          "type": "blob",
          "size": 2.3984375,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"time\"\n)\n\nconst (\n\tdateTimeLayout       = \"Mon Jan 02 2006 15:04:05 GMT-0700 (MST)\"\n\tutcDateTimeLayout    = \"Mon, 02 Jan 2006 15:04:05 GMT\"\n\tisoDateTimeLayout    = \"2006-01-02T15:04:05.000Z\"\n\tdateLayout           = \"Mon Jan 02 2006\"\n\ttimeLayout           = \"15:04:05 GMT-0700 (MST)\"\n\tdatetimeLayout_en_GB = \"01/02/2006, 15:04:05\"\n\tdateLayout_en_GB     = \"01/02/2006\"\n\ttimeLayout_en_GB     = \"15:04:05\"\n\n\tmaxTime   = 8.64e15\n\ttimeUnset = math.MinInt64\n)\n\ntype dateObject struct {\n\tbaseObject\n\tmsec int64\n}\n\nfunc dateParse(date string) (t time.Time, ok bool) {\n\td, ok := parseDateISOString(date)\n\tif !ok {\n\t\td, ok = parseDateOtherString(date)\n\t}\n\tif !ok {\n\t\treturn\n\t}\n\tif d.month > 12 ||\n\t\td.day > 31 ||\n\t\td.hour > 24 ||\n\t\td.min > 59 ||\n\t\td.sec > 59 ||\n\t\t// special case 24:00:00.000\n\t\t(d.hour == 24 && (d.min != 0 || d.sec != 0 || d.msec != 0)) {\n\t\tok = false\n\t\treturn\n\t}\n\tvar loc *time.Location\n\tif d.isLocal {\n\t\tloc = time.Local\n\t} else {\n\t\tloc = time.FixedZone(\"\", d.timeZoneOffset*60)\n\t}\n\tt = time.Date(d.year, time.Month(d.month), d.day, d.hour, d.min, d.sec, d.msec*1e6, loc)\n\tunixMilli := t.UnixMilli()\n\tok = unixMilli >= -maxTime && unixMilli <= maxTime\n\treturn\n}\n\nfunc (r *Runtime) newDateObject(t time.Time, isSet bool, proto *Object) *Object {\n\tv := &Object{runtime: r}\n\td := &dateObject{}\n\tv.self = d\n\td.val = v\n\td.class = classDate\n\td.prototype = proto\n\td.extensible = true\n\td.init()\n\tif isSet {\n\t\td.msec = timeToMsec(t)\n\t} else {\n\t\td.msec = timeUnset\n\t}\n\treturn v\n}\n\nfunc dateFormat(t time.Time) string {\n\treturn t.Local().Format(dateTimeLayout)\n}\n\nfunc timeFromMsec(msec int64) time.Time {\n\tsec := msec / 1000\n\tnsec := (msec % 1000) * 1e6\n\treturn time.Unix(sec, nsec)\n}\n\nfunc timeToMsec(t time.Time) int64 {\n\treturn t.Unix()*1000 + int64(t.Nanosecond())/1e6\n}\n\nfunc (d *dateObject) exportType() reflect.Type {\n\treturn typeTime\n}\n\nfunc (d *dateObject) export(*objectExportCtx) interface{} {\n\tif d.isSet() {\n\t\treturn d.time()\n\t}\n\treturn nil\n}\n\nfunc (d *dateObject) setTimeMs(ms int64) Value {\n\tif ms >= 0 && ms <= maxTime || ms < 0 && ms >= -maxTime {\n\t\td.msec = ms\n\t\treturn intToValue(ms)\n\t}\n\n\td.unset()\n\treturn _NaN\n}\n\nfunc (d *dateObject) isSet() bool {\n\treturn d.msec != timeUnset\n}\n\nfunc (d *dateObject) unset() {\n\td.msec = timeUnset\n}\n\nfunc (d *dateObject) time() time.Time {\n\treturn timeFromMsec(d.msec)\n}\n\nfunc (d *dateObject) timeUTC() time.Time {\n\treturn timeFromMsec(d.msec).In(time.UTC)\n}\n"
        },
        {
          "name": "date_parser.go",
          "type": "blob",
          "size": 8.294921875,
          "content": "package goja\n\nimport (\n\t\"strings\"\n)\n\ntype date struct {\n\tyear, month, day     int\n\thour, min, sec, msec int\n\ttimeZoneOffset       int // time zone offset in minutes\n\tisLocal              bool\n}\n\nfunc skip(s string, c byte) (string, bool) {\n\tif len(s) > 0 && s[0] == c {\n\t\treturn s[1:], true\n\t}\n\treturn s, false\n}\n\nfunc skipSpaces(s string) string {\n\tfor len(s) > 0 && s[0] == ' ' {\n\t\ts = s[1:]\n\t}\n\treturn s\n}\n\nfunc skipUntil(s string, stopList string) string {\n\tfor len(s) > 0 && !strings.ContainsRune(stopList, rune(s[0])) {\n\t\ts = s[1:]\n\t}\n\treturn s\n}\n\nfunc match(s string, lower string) (string, bool) {\n\tif len(s) < len(lower) {\n\t\treturn s, false\n\t}\n\tfor i := 0; i < len(lower); i++ {\n\t\tc1 := s[i]\n\t\tc2 := lower[i]\n\t\tif c1 != c2 {\n\t\t\t// switch to lower-case; 'a'-'A' is known to be a single bit\n\t\t\tc1 |= 'a' - 'A'\n\t\t\tif c1 != c2 || c1 < 'a' || c1 > 'z' {\n\t\t\t\treturn s, false\n\t\t\t}\n\t\t}\n\t}\n\treturn s[len(lower):], true\n}\n\nfunc getDigits(s string, minDigits, maxDigits int) (int, string, bool) {\n\tvar i, v int\n\tfor i < len(s) && i < maxDigits && s[i] >= '0' && s[i] <= '9' {\n\t\tv = v*10 + int(s[i]-'0')\n\t\ti++\n\t}\n\tif i < minDigits {\n\t\treturn 0, s, false\n\t}\n\treturn v, s[i:], true\n}\n\nfunc getMilliseconds(s string) (int, string) {\n\tmul, v := 100, 0\n\tif len(s) > 0 && (s[0] == '.' || s[0] == ',') {\n\t\tconst I_START = 1\n\t\ti := I_START\n\t\tfor i < len(s) && i-I_START < 9 && s[i] >= '0' && s[i] <= '9' {\n\t\t\tv += int(s[i]-'0') * mul\n\t\t\tmul /= 10\n\t\t\ti++\n\t\t}\n\t\tif i > I_START {\n\t\t\t// only consume the separator if digits are present\n\t\t\treturn v, s[i:]\n\t\t}\n\t}\n\treturn 0, s\n}\n\n// [+-]HH:mm or [+-]HHmm or Z\nfunc getTimeZoneOffset(s string, strict bool) (int, string, bool) {\n\tif len(s) == 0 {\n\t\treturn 0, s, false\n\t}\n\tsign := s[0]\n\tif sign == '+' || sign == '-' {\n\t\tvar hh, mm, v int\n\t\tvar ok bool\n\t\tt := s[1:]\n\t\tn := len(t)\n\t\tif hh, t, ok = getDigits(t, 1, 9); !ok {\n\t\t\treturn 0, s, false\n\t\t}\n\t\tn -= len(t)\n\t\tif strict && n != 2 && n != 4 {\n\t\t\treturn 0, s, false\n\t\t}\n\t\tfor n > 4 {\n\t\t\tn -= 2\n\t\t\thh /= 100\n\t\t}\n\t\tif n > 2 {\n\t\t\tmm = hh % 100\n\t\t\thh = hh / 100\n\t\t} else if t, ok = skip(t, ':'); ok {\n\t\t\tif mm, t, ok = getDigits(t, 2, 2); !ok {\n\t\t\t\treturn 0, s, false\n\t\t\t}\n\t\t}\n\t\tif hh > 23 || mm > 59 {\n\t\t\treturn 0, s, false\n\t\t}\n\t\tv = hh*60 + mm\n\t\tif sign == '-' {\n\t\t\tv = -v\n\t\t}\n\t\treturn v, t, true\n\t} else if sign == 'Z' {\n\t\treturn 0, s[1:], true\n\t}\n\treturn 0, s, false\n}\n\nvar tzAbbrs = []struct {\n\tnameLower string\n\toffset    int\n}{\n\t{\"gmt\", 0},        // Greenwich Mean Time\n\t{\"utc\", 0},        // Coordinated Universal Time\n\t{\"ut\", 0},         // Universal Time\n\t{\"z\", 0},          // Zulu Time\n\t{\"edt\", -4 * 60},  // Eastern Daylight Time\n\t{\"est\", -5 * 60},  // Eastern Standard Time\n\t{\"cdt\", -5 * 60},  // Central Daylight Time\n\t{\"cst\", -6 * 60},  // Central Standard Time\n\t{\"mdt\", -6 * 60},  // Mountain Daylight Time\n\t{\"mst\", -7 * 60},  // Mountain Standard Time\n\t{\"pdt\", -7 * 60},  // Pacific Daylight Time\n\t{\"pst\", -8 * 60},  // Pacific Standard Time\n\t{\"wet\", +0 * 60},  // Western European Time\n\t{\"west\", +1 * 60}, // Western European Summer Time\n\t{\"cet\", +1 * 60},  // Central European Time\n\t{\"cest\", +2 * 60}, // Central European Summer Time\n\t{\"eet\", +2 * 60},  // Eastern European Time\n\t{\"eest\", +3 * 60}, // Eastern European Summer Time\n}\n\nfunc getTimeZoneAbbr(s string) (int, string, bool) {\n\tfor _, tzAbbr := range tzAbbrs {\n\t\tif s, ok := match(s, tzAbbr.nameLower); ok {\n\t\t\treturn tzAbbr.offset, s, true\n\t\t}\n\t}\n\treturn 0, s, false\n}\n\nvar monthNamesLower = []string{\n\t\"jan\",\n\t\"feb\",\n\t\"mar\",\n\t\"apr\",\n\t\"may\",\n\t\"jun\",\n\t\"jul\",\n\t\"aug\",\n\t\"sep\",\n\t\"oct\",\n\t\"nov\",\n\t\"dec\",\n}\n\nfunc getMonth(s string) (int, string, bool) {\n\tfor i, monthNameLower := range monthNamesLower {\n\t\tif s, ok := match(s, monthNameLower); ok {\n\t\t\treturn i + 1, s, true\n\t\t}\n\t}\n\treturn 0, s, false\n}\n\nfunc parseDateISOString(s string) (date, bool) {\n\tif len(s) == 0 {\n\t\treturn date{}, false\n\t}\n\tvar d = date{month: 1, day: 1}\n\tvar ok bool\n\n\t// year is either yyyy digits or [+-]yyyyyy\n\tsign := s[0]\n\tif sign == '-' || sign == '+' {\n\t\ts = s[1:]\n\t\tif d.year, s, ok = getDigits(s, 6, 6); !ok {\n\t\t\treturn date{}, false\n\t\t}\n\t\tif sign == '-' {\n\t\t\tif d.year == 0 {\n\t\t\t\t// reject -000000\n\t\t\t\treturn date{}, false\n\t\t\t}\n\t\t\td.year = -d.year\n\t\t}\n\t} else if d.year, s, ok = getDigits(s, 4, 4); !ok {\n\t\treturn date{}, false\n\t}\n\tif s, ok = skip(s, '-'); ok {\n\t\tif d.month, s, ok = getDigits(s, 2, 2); !ok || d.month < 1 {\n\t\t\treturn date{}, false\n\t\t}\n\t\tif s, ok = skip(s, '-'); ok {\n\t\t\tif d.day, s, ok = getDigits(s, 2, 2); !ok || d.day < 1 {\n\t\t\t\treturn date{}, false\n\t\t\t}\n\t\t}\n\t}\n\tif s, ok = skip(s, 'T'); ok {\n\t\tif d.hour, s, ok = getDigits(s, 2, 2); !ok {\n\t\t\treturn date{}, false\n\t\t}\n\t\tif s, ok = skip(s, ':'); !ok {\n\t\t\treturn date{}, false\n\t\t}\n\t\tif d.min, s, ok = getDigits(s, 2, 2); !ok {\n\t\t\treturn date{}, false\n\t\t}\n\t\tif s, ok = skip(s, ':'); ok {\n\t\t\tif d.sec, s, ok = getDigits(s, 2, 2); !ok {\n\t\t\t\treturn date{}, false\n\t\t\t}\n\t\t\td.msec, s = getMilliseconds(s)\n\t\t}\n\t\td.isLocal = true\n\t}\n\t// parse the time zone offset if present\n\tif len(s) > 0 {\n\t\tif d.timeZoneOffset, s, ok = getTimeZoneOffset(s, true); !ok {\n\t\t\treturn date{}, false\n\t\t}\n\t\td.isLocal = false\n\t}\n\t// error if extraneous characters\n\treturn d, len(s) == 0\n}\n\nfunc parseDateOtherString(s string) (date, bool) {\n\tvar d = date{\n\t\tyear:    2001,\n\t\tmonth:   1,\n\t\tday:     1,\n\t\tisLocal: true,\n\t}\n\tvar nums [3]int\n\tvar numIndex int\n\tvar hasYear, hasMon, hasTime, ok bool\n\tfor {\n\t\ts = skipSpaces(s)\n\t\tif len(s) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tc := s[0]\n\t\tn, val := len(s), 0\n\t\tif c == '+' || c == '-' {\n\t\t\tif hasTime {\n\t\t\t\tif val, s, ok = getTimeZoneOffset(s, false); ok {\n\t\t\t\t\td.timeZoneOffset = val\n\t\t\t\t\td.isLocal = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !hasTime || !ok {\n\t\t\t\ts = s[1:]\n\t\t\t\tif val, s, ok = getDigits(s, 1, 9); ok {\n\t\t\t\t\td.year = val\n\t\t\t\t\tif c == '-' {\n\t\t\t\t\t\tif d.year == 0 {\n\t\t\t\t\t\t\treturn date{}, false\n\t\t\t\t\t\t}\n\t\t\t\t\t\td.year = -d.year\n\t\t\t\t\t}\n\t\t\t\t\thasYear = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if val, s, ok = getDigits(s, 1, 9); ok {\n\t\t\tif s, ok = skip(s, ':'); ok {\n\t\t\t\t// time part\n\t\t\t\td.hour = val\n\t\t\t\tif d.min, s, ok = getDigits(s, 1, 2); !ok {\n\t\t\t\t\treturn date{}, false\n\t\t\t\t}\n\t\t\t\tif s, ok = skip(s, ':'); ok {\n\t\t\t\t\tif d.sec, s, ok = getDigits(s, 1, 2); !ok {\n\t\t\t\t\t\treturn date{}, false\n\t\t\t\t\t}\n\t\t\t\t\td.msec, s = getMilliseconds(s)\n\t\t\t\t}\n\t\t\t\thasTime = true\n\t\t\t\tif t := skipSpaces(s); len(t) > 0 {\n\t\t\t\t\tif t, ok = match(t, \"pm\"); ok {\n\t\t\t\t\t\tif d.hour < 12 {\n\t\t\t\t\t\t\td.hour += 12\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = t\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else if t, ok = match(t, \"am\"); ok {\n\t\t\t\t\t\tif d.hour == 12 {\n\t\t\t\t\t\t\td.hour = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = t\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if n-len(s) > 2 {\n\t\t\t\td.year = val\n\t\t\t\thasYear = true\n\t\t\t} else if val < 1 || val > 31 {\n\t\t\t\td.year = val\n\t\t\t\tif val < 100 {\n\t\t\t\t\td.year += 1900\n\t\t\t\t}\n\t\t\t\tif val < 50 {\n\t\t\t\t\td.year += 100\n\t\t\t\t}\n\t\t\t\thasYear = true\n\t\t\t} else {\n\t\t\t\tif numIndex == 3 {\n\t\t\t\t\treturn date{}, false\n\t\t\t\t}\n\t\t\t\tnums[numIndex] = val\n\t\t\t\tnumIndex++\n\t\t\t}\n\t\t} else if val, s, ok = getMonth(s); ok {\n\t\t\td.month = val\n\t\t\thasMon = true\n\t\t\ts = skipUntil(s, \"0123456789 -/(\")\n\t\t} else if val, s, ok = getTimeZoneAbbr(s); ok {\n\t\t\td.timeZoneOffset = val\n\t\t\tif len(s) > 0 {\n\t\t\t\tif c := s[0]; (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {\n\t\t\t\t\treturn date{}, false\n\t\t\t\t}\n\t\t\t}\n\t\t\td.isLocal = false\n\t\t\tcontinue\n\t\t} else if c == '(' {\n\t\t\t// skip parenthesized phrase\n\t\t\tlevel := 1\n\t\t\ts = s[1:]\n\t\t\tfor len(s) > 0 && level != 0 {\n\t\t\t\tif s[0] == '(' {\n\t\t\t\t\tlevel++\n\t\t\t\t} else if s[0] == ')' {\n\t\t\t\t\tlevel--\n\t\t\t\t}\n\t\t\t\ts = s[1:]\n\t\t\t}\n\t\t\tif level > 0 {\n\t\t\t\treturn date{}, false\n\t\t\t}\n\t\t} else if c == ')' {\n\t\t\treturn date{}, false\n\t\t} else {\n\t\t\tif hasYear || hasMon || hasTime || numIndex > 0 {\n\t\t\t\treturn date{}, false\n\t\t\t}\n\t\t\t// skip a word\n\t\t\ts = skipUntil(s, \" -/(\")\n\t\t}\n\t\tfor len(s) > 0 && strings.ContainsRune(\"-/.,\", rune(s[0])) {\n\t\t\ts = s[1:]\n\t\t}\n\t}\n\tn := numIndex\n\tif hasYear {\n\t\tn++\n\t}\n\tif hasMon {\n\t\tn++\n\t}\n\tif n > 3 {\n\t\treturn date{}, false\n\t}\n\n\tswitch numIndex {\n\tcase 0:\n\t\tif !hasYear {\n\t\t\treturn date{}, false\n\t\t}\n\tcase 1:\n\t\tif hasMon {\n\t\t\td.day = nums[0]\n\t\t} else {\n\t\t\td.month = nums[0]\n\t\t}\n\tcase 2:\n\t\tif hasYear {\n\t\t\td.month = nums[0]\n\t\t\td.day = nums[1]\n\t\t} else if hasMon {\n\t\t\td.year = nums[1]\n\t\t\tif nums[1] < 100 {\n\t\t\t\td.year += 1900\n\t\t\t}\n\t\t\tif nums[1] < 50 {\n\t\t\t\td.year += 100\n\t\t\t}\n\t\t\td.day = nums[0]\n\t\t} else {\n\t\t\td.month = nums[0]\n\t\t\td.day = nums[1]\n\t\t}\n\tcase 3:\n\t\td.year = nums[2]\n\t\tif nums[2] < 100 {\n\t\t\td.year += 1900\n\t\t}\n\t\tif nums[2] < 50 {\n\t\t\td.year += 100\n\t\t}\n\t\td.month = nums[0]\n\t\td.day = nums[1]\n\tdefault:\n\t\treturn date{}, false\n\t}\n\treturn d, d.month > 0 && d.day > 0\n}\n"
        },
        {
          "name": "date_test.go",
          "type": "blob",
          "size": 21.666015625,
          "content": "package goja\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestDateUTC(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(Date.UTC(1970, 0), 0, '1970, 0');\n\tassert.sameValue(Date.UTC(2016, 0), 1451606400000, '2016, 0');\n\tassert.sameValue(Date.UTC(2016, 6), 1467331200000, '2016, 6');\n\n\tassert.sameValue(Date.UTC(2016, 6, 1), 1467331200000, '2016, 6, 1');\n\tassert.sameValue(Date.UTC(2016, 6, 5), 1467676800000, '2016, 6, 5');\n\n\tassert.sameValue(Date.UTC(2016, 6, 5, 0), 1467676800000, '2016, 6, 5, 0');\n\tassert.sameValue(Date.UTC(2016, 6, 5, 15), 1467730800000, '2016, 6, 5, 15');\n\n\tassert.sameValue(\n  \t\tDate.UTC(2016, 6, 5, 15, 0), 1467730800000, '2016, 6, 5, 15, 0'\n\t);\n\tassert.sameValue(\n  \t\tDate.UTC(2016, 6, 5, 15, 34), 1467732840000, '2016, 6, 5, 15, 34'\n\t);\n\n\tassert.sameValue(\n  \t\tDate.UTC(2016, 6, 5, 15, 34, 0), 1467732840000, '2016, 6, 5, 15, 34, 0'\n\t);\n\tassert.sameValue(\n  \t\tDate.UTC(2016, 6, 5, 15, 34, 45), 1467732885000, '2016, 6, 5, 15, 34, 45'\n\t);\n\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestNewDate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar d1 = new Date(\"2016-09-01T12:34:56Z\");\n\td1.getUTCHours() === 12;\n\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestNewDate0(t *testing.T) {\n\tconst SCRIPT = `\n\t(new Date(0)).toUTCString();\n\n\t`\n\ttestScript(SCRIPT, asciiString(\"Thu, 01 Jan 1970 00:00:00 GMT\"), t)\n}\n\nfunc TestSetHour(t *testing.T) {\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst SCRIPT = `\n\tvar d = new Date(2016, 8, 1, 12, 23, 45)\n\tassert.sameValue(d.getHours(), 12);\n\tassert.sameValue(d.getUTCHours(), 16);\n\n\td.setHours(13);\n\tassert.sameValue(d.getHours(), 13);\n\tassert.sameValue(d.getMinutes(), 23);\n\tassert.sameValue(d.getSeconds(), 45);\n\n\td.setUTCHours(13);\n\tassert.sameValue(d.getHours(), 9);\n\tassert.sameValue(d.getMinutes(), 23);\n\tassert.sameValue(d.getSeconds(), 45);\n\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n\n}\n\nfunc TestSetMinute(t *testing.T) {\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\ttime.Local = time.FixedZone(\"Asia/Delhi\", 5*60*60+30*60)\n\n\tconst SCRIPT = `\n\tvar d = new Date(2016, 8, 1, 12, 23, 45)\n\tassert.sameValue(d.getHours(), 12);\n\tassert.sameValue(d.getUTCHours(), 6);\n\tassert.sameValue(d.getMinutes(), 23);\n\tassert.sameValue(d.getUTCMinutes(), 53);\n\n\td.setMinutes(55);\n\tassert.sameValue(d.getMinutes(), 55);\n\tassert.sameValue(d.getSeconds(), 45);\n\n\td.setUTCMinutes(52);\n\tassert.sameValue(d.getMinutes(), 22);\n\tassert.sameValue(d.getHours(), 13);\n\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n\n}\n\nfunc TestTimezoneOffset(t *testing.T) {\n\tconst SCRIPT = `\n\tvar d = new Date(0);\n\td.getTimezoneOffset();\n\t`\n\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"Europe/London\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestScript(SCRIPT, intToValue(-60), t)\n}\n\nfunc TestDateValueOf(t *testing.T) {\n\tconst SCRIPT = `\n\tvar d9 = new Date(1.23e15);\n\td9.valueOf();\n\t`\n\n\ttestScript(SCRIPT, intToValue(1.23e15), t)\n}\n\nfunc TestDateSetters(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue((new Date(0)).setMilliseconds(2345), 2345, \"setMilliseconds(2345)\");\n\tassert.sameValue(new Date(1000).setMilliseconds(23450000000000), 23450000001000, \"setMilliseconds(23450000000000)\");\n\tassert.sameValue((new Date(0)).setUTCMilliseconds(2345), 2345, \"setUTCMilliseconds()\");\n\tassert.sameValue((new Date(0)).setSeconds(12), 12000, \"setSeconds()\");\n\tassert.sameValue((new Date(0)).setUTCSeconds(12), 12000, \"setUTCSeconds()\");\n\tassert.sameValue((new Date(0)).setMinutes(12), 12 * 60 * 1000, \"setMinutes()\");\n\tassert.sameValue((new Date(0)).setUTCMinutes(12), 12 * 60 * 1000, \"setUTCMinutes()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setHours(1), 1464739200000, \"setHours()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setUTCHours(1), 1464742800000, \"setUTCHours()\");\n\tassert.sameValue((new Date(0)).setDate(2), 86400000, \"setDate()\");\n\tassert.sameValue((new Date(0)).setUTCDate(2), 86400000, \"setUTCDate()\");\n\tassert.sameValue((new Date(0)).setMonth(2), 5097600000, \"setMonth()\");\n\tassert.sameValue((new Date(0)).setUTCMonth(2), 5097600000, \"setUTCMonth()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971), 31536000000, \"setFullYear()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971, 2, 3), 36806400000, \"setFullYear(Y,M,D)\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971), 31536000000, \"setUTCFullYear()\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971, 2, 3), 36806400000, \"setUTCFullYear(Y,M,D)\");\n\n\tvar d = new Date();\n\td.setTime(1151877845000);\n\tassert.sameValue(d.getHours(), 23, \"d.getHours()\");\n\t`\n\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"Europe/London\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestDateParse(t *testing.T) {\n\tconst SCRIPT = `\n\tvar zero = new Date(0);\n\n\tassert.sameValue(zero.valueOf(), Date.parse(zero.toString()),\n\t\t\t\t\t \"Date.parse(zeroDate.toString())\");\n\tassert.sameValue(zero.valueOf(), Date.parse(zero.toUTCString()),\n\t\t\t\t\t \"Date.parse(zeroDate.toUTCString())\");\n\tassert.sameValue(zero.valueOf(), Date.parse(zero.toISOString()),\n\t\t\t\t\t \"Date.parse(zeroDate.toISOString())\");\n\n\tfunction testParse(str, expected) {\n\t\tassert.sameValue(Date.parse(str), expected, str);\n\t}\n\n\ttestParse(\"Mon, 02 Jan 2006 15:04:05 MST\",\t\t\t\t\t\t\t1136239445000);\n\ttestParse(\"Tue, 22 Jun 2021 13:54:40 GMT\",\t\t\t\t\t\t\t1624370080000);\n\ttestParse(\"Tuesday, 22 Jun 2021 13:54:40 GMT\",\t\t\t\t\t\t1624370080000);\n\ttestParse(\"Mon, 02 Jan 2006 15:04:05 GMT-07:00 (MST)\",\t\t\t\t1136239445000);\n\ttestParse(\"Mon, 02 Jan 2006 15:04:05 -07:00 (MST)\",\t\t\t\t\t1136239445000);\n\ttestParse(\"Monday, 02 Jan 2006 15:04:05 -0700 (MST)\",\t\t\t\t1136239445000);\n\ttestParse(\"Mon Jan 02 2006 15:04:05 GMT-0700 (GMT Standard Time)\",\t1136239445000);\n\ttestParse(\"Mon Jan 2 15:04:05 MST 2006\",\t\t\t\t\t\t\t1136239445000);\n\ttestParse(\"Mon Jan 02 15:04:05 MST 2006\",\t\t\t\t\t\t\t1136239445000);\n\ttestParse(\"Mon Jan  2 15:04:05 2006\",\t\t\t\t\t\t\t\t1136232245000);\n\ttestParse(\"Mon Jan 02 15:04:05 -0700 2006\",\t\t\t\t\t\t\t1136239445000);\n\ttestParse(\"Mon Jan 02 3:4 PM -0700 2006\",\t\t\t\t\t\t\t1136239440000);\n\n\ttestParse(\"December 04, 1986\",\t534056400000);\n\ttestParse(\"Dec 04, 1986\",\t\t534056400000);\n\ttestParse(\"Dec 4, 1986\",\t\t534056400000);\n\n\ttestParse(\"2006-01-02T15:04:05.000Z\",\t1136214245000);\n\ttestParse(\"2006-06-02T15:04:05.000\",\t1149275045000);\n\ttestParse(\"2006-01-02T15:04:05\",\t\t1136232245000);\n\ttestParse(\"2006-01-02 15:04:05.123\",\t1136232245123);\n\ttestParse(\"2006-01-02\",\t\t\t\t\t1136160000000);\n\ttestParse(\"2006T15:04-0700\",\t\t\t1136153040000);\n\ttestParse(\"2006T15:04+07:00\",\t\t\t1136102640000);\n\ttestParse(\"2006T15:04Z\",\t\t\t\t1136127840000);\n\ttestParse(\"2019-01-01T12:00:00.52Z\",\t1546344000520);\n\ttestParse(\"2019-01T12:00:00.52Z\",\t\t1546344000520);\n\ttestParse(\"+002019-01-01T12:00:00.52Z\",\t1546344000520);\n\n\tvar d = new Date(\"Mon, 02 Jan 2006 15:04:05 MST\");\n\n\tassert.sameValue(d.getUTCHours(), 22,\n\t\t\t\t\t\"new Date(\\\"Mon, 02 Jan 2006 15:04:05 MST\\\").getUTCHours()\");\n\n\tassert.sameValue(d.getHours(), 17,\n\t\t\t\t\t\"new Date(\\\"Mon, 02 Jan 2006 15:04:05 MST\\\").getHours()\");\n\n\tassert.sameValue(Date.parse(\"Mon, 02 Jan 2006 15:04:05 zzz\"), NaN,\n\t\t\t\t\t \"Date.parse(\\\"Mon, 02 Jan 2006 15:04:05 zzz\\\")\");\n\n\tassert.sameValue(Date.parse(\"Mon, 02 Jan 2006 15:04:05 ZZZ\"), NaN,\n\t\t\t\t\t \"Date.parse(\\\"Mon, 02 Jan 2006 15:04:05 ZZZ\\\")\");\n\n\tvar minDateStr = \"-271821-04-20T00:00:00.000Z\";\n\tvar minDate = new Date(-8640000000000000);\n\n\tassert.sameValue(minDate.toISOString(), minDateStr, \"minDateStr\");\n\tassert.sameValue(Date.parse(minDateStr), minDate.valueOf(), \"parse minDateStr\");\n\n\tvar maxDateStr = \"+275760-09-13T00:00:00.000Z\";\n\tvar maxDate = new Date(8640000000000000);\n\n\tassert.sameValue(maxDate.toISOString(), maxDateStr, \"maxDateStr\");\n\tassert.sameValue(Date.parse(maxDateStr), maxDate.valueOf(), \"parse maxDateStr\");\n\n\tvar belowRange = \"-271821-04-19T23:59:59.999Z\";\n\tvar aboveRange = \"+275760-09-13T00:00:00.001Z\";\n\n\tassert.sameValue(Date.parse(belowRange), NaN, \"parse below minimum time value\");\n\tassert.sameValue(Date.parse(aboveRange), NaN, \"parse above maximum time value\");\n\t`\n\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestDateMaxValues(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue((new Date(0)).setUTCMilliseconds(8.64e15), 8.64e15);\n\tassert.sameValue((new Date(0)).setUTCSeconds(8640000000000), 8.64e15);\n\tassert.sameValue((new Date(0)).setUTCMilliseconds(-8.64e15), -8.64e15);\n\tassert.sameValue((new Date(0)).setUTCSeconds(-8640000000000), -8.64e15);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestDateExport(t *testing.T) {\n\tvm := New()\n\tres, err := vm.RunString(`new Date(1000)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texp := res.Export()\n\tif d, ok := exp.(time.Time); ok {\n\t\tif d.UnixNano()/1e6 != 1000 {\n\t\t\tt.Fatalf(\"Invalid exported date: %v\", d)\n\t\t}\n\t\tif loc := d.Location(); loc != time.Local {\n\t\t\tt.Fatalf(\"Invalid timezone: %v\", loc)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Invalid export type: %T\", exp)\n\t}\n}\n\nfunc TestDateToJSON(t *testing.T) {\n\tconst SCRIPT = `\n\tDate.prototype.toJSON.call({ toISOString: function () { return 1; } })\n\t`\n\ttestScript(SCRIPT, intToValue(1), t)\n}\n\nfunc TestDateExportType(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`new Date()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif typ := v.ExportType(); typ != typeTime {\n\t\tt.Fatal(typ)\n\t}\n}\n\nfunc TestDateParseV8(t *testing.T) {\n\t// Taken from https://chromium.googlesource.com/v8/v8/+/refs/heads/main/test/mjsunit/date-parse.js\n\tconst SCRIPT = `\nconst assertEquals = assert.sameValue,\n\tassertTrue = assert;\n\n// Copyright 2008 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// Test that we can parse dates in all the different formats that we\n// have to support.\n//\n// These formats are all supported by KJS but a lot of them are not\n// supported by Spidermonkey.\nfunction testDateParse(string) {\n  var d = Date.parse(string);\n  assertEquals(946713600000, d, \"parse: \" + string);\n};\n// For local time we just test that parsing returns non-NaN positive\n// number of milliseconds to make it timezone independent.\nfunction testDateParseLocalTime(string) {\n  var d = Date.parse(\"parse-local-time:\" + string);\n  assertTrue(!isNaN(d), \"parse-local-time: \" + string + \" is NaN.\");\n  assertTrue(d > 0, \"parse-local-time: \" + string + \" <= 0.\");\n};\nfunction testDateParseMisc(array) {\n  assertEquals(2, array.length, \"array [\" + array + \"] length != 2.\");\n  var string = array[0];\n  var expected = array[1];\n  var d = Date.parse(string);\n  assertEquals(expected, d, \"parse-misc: \" + string);\n}\n//\n// Test all the formats in UT timezone.\n//\nvar testCasesUT = [\n    'Sat, 01-Jan-2000 08:00:00 UT',\n    'Sat, 01 Jan 2000 08:00:00 UT',\n    'Jan 01 2000 08:00:00 UT',\n    'Jan 01 08:00:00 UT 2000',\n    'Saturday, 01-Jan-00 08:00:00 UT',\n    '01 Jan 00 08:00 +0000',\n    // Ignore weekdays.\n    'Mon, 01 Jan 2000 08:00:00 UT',\n    'Tue, 01 Jan 2000 08:00:00 UT',\n    // Ignore prefix that is not part of a date.\n    '[Saturday] Jan 01 08:00:00 UT 2000',\n    'Ignore all of this stuff because it is annoying 01 Jan 2000 08:00:00 UT',\n    '[Saturday] Jan 01 2000 08:00:00 UT',\n    'All of this stuff is really annoying, so it will be ignored Jan 01 2000 08:00:00 UT',\n    // If the three first letters of the month is a\n    // month name we are happy - ignore the rest.\n    'Sat, 01-Janisamonth-2000 08:00:00 UT',\n    'Sat, 01 Janisamonth 2000 08:00:00 UT',\n    'Janisamonth 01 2000 08:00:00 UT',\n    'Janisamonth 01 08:00:00 UT 2000',\n    'Saturday, 01-Janisamonth-00 08:00:00 UT',\n    '01 Janisamonth 00 08:00 +0000',\n    // Allow missing space between month and day.\n    'Janisamonthandtherestisignored01 2000 08:00:00 UT',\n    'Jan01 2000 08:00:00 UT',\n    // Allow year/month/day format.\n    'Sat, 2000/01/01 08:00:00 UT',\n    // Allow month/day/year format.\n    'Sat, 01/01/2000 08:00:00 UT',\n    // Allow month/day year format.\n    'Sat, 01/01 2000 08:00:00 UT',\n    // Allow comma instead of space after day, month and year.\n    'Sat, 01,Jan,2000,08:00:00 UT',\n    // Seconds are optional.\n    'Sat, 01-Jan-2000 08:00 UT',\n    'Sat, 01 Jan 2000 08:00 UT',\n    'Jan 01 2000 08:00 UT',\n    'Jan 01 08:00 UT 2000',\n    'Saturday, 01-Jan-00 08:00 UT',\n    '01 Jan 00 08:00 +0000',\n    // Allow AM/PM after the time.\n    'Sat, 01-Jan-2000 08:00 AM UT',\n    'Sat, 01 Jan 2000 08:00 AM UT',\n    'Jan 01 2000 08:00 AM UT',\n    'Jan 01 08:00 AM UT 2000',\n    'Saturday, 01-Jan-00 08:00 AM UT',\n    '01 Jan 00 08:00 AM +0000',\n    // White space and stuff in parenthesis is\n    // apparently allowed in most places where white\n    // space is allowed.\n    '   Sat,   01-Jan-2000   08:00:00   UT  ',\n    '  Sat,   01   Jan   2000   08:00:00   UT  ',\n    '  Saturday,   01-Jan-00   08:00:00   UT  ',\n    '  01    Jan   00    08:00   +0000   ',\n    ' ()(Sat, 01-Jan-2000)  Sat,   01-Jan-2000   08:00:00   UT  ',\n    '  Sat()(Sat, 01-Jan-2000)01   Jan   2000   08:00:00   UT  ',\n    '  Sat,(02)01   Jan   2000   08:00:00   UT  ',\n    '  Sat,  01(02)Jan   2000   08:00:00   UT  ',\n    '  Sat,  01  Jan  2000 (2001)08:00:00   UT  ',\n    '  Sat,  01  Jan  2000 (01)08:00:00   UT  ',\n    '  Sat,  01  Jan  2000 (01:00:00)08:00:00   UT  ',\n    '  Sat,  01  Jan  2000  08:00:00 (CDT)UT  ',\n    '  Sat,  01  Jan  2000  08:00:00  UT((((CDT))))',\n    '  Saturday,   01-Jan-00 ()(((asfd)))(Sat, 01-Jan-2000)08:00:00   UT  ',\n    '  01    Jan   00    08:00 ()(((asdf)))(Sat, 01-Jan-2000)+0000   ',\n    '  01    Jan   00    08:00   +0000()((asfd)(Sat, 01-Jan-2000)) '];\n//\n// Test that we do the right correction for different time zones.\n// I'll assume that we can handle the same formats as for UT and only\n// test a few formats for each of the timezones.\n//\n// GMT = UT\nvar testCasesGMT = [\n    'Sat, 01-Jan-2000 08:00:00 GMT',\n    'Sat, 01-Jan-2000 08:00:00 GMT+0',\n    'Sat, 01-Jan-2000 08:00:00 GMT+00',\n    'Sat, 01-Jan-2000 08:00:00 GMT+000',\n    'Sat, 01-Jan-2000 08:00:00 GMT+0000',\n    'Sat, 01-Jan-2000 08:00:00 GMT+00:00', // Interestingly, KJS cannot handle this.\n    'Sat, 01 Jan 2000 08:00:00 GMT',\n    'Saturday, 01-Jan-00 08:00:00 GMT',\n    '01 Jan 00 08:00 -0000',\n    '01 Jan 00 08:00 +0000'];\n// EST = UT minus 5 hours.\nvar testCasesEST = [\n    'Sat, 01-Jan-2000 03:00:00 UTC-0500',\n    'Sat, 01-Jan-2000 03:00:00 UTC-05:00', // Interestingly, KJS cannot handle this.\n    'Sat, 01-Jan-2000 03:00:00 EST',\n    'Sat, 01 Jan 2000 03:00:00 EST',\n    'Saturday, 01-Jan-00 03:00:00 EST',\n    '01 Jan 00 03:00 -0500'];\n// EDT = UT minus 4 hours.\nvar testCasesEDT = [\n    'Sat, 01-Jan-2000 04:00:00 EDT',\n    'Sat, 01 Jan 2000 04:00:00 EDT',\n    'Saturday, 01-Jan-00 04:00:00 EDT',\n    '01 Jan 00 04:00 -0400'];\n// CST = UT minus 6 hours.\nvar testCasesCST = [\n    'Sat, 01-Jan-2000 02:00:00 CST',\n    'Sat, 01 Jan 2000 02:00:00 CST',\n    'Saturday, 01-Jan-00 02:00:00 CST',\n    '01 Jan 00 02:00 -0600'];\n// CDT = UT minus 5 hours.\nvar testCasesCDT = [\n    'Sat, 01-Jan-2000 03:00:00 CDT',\n    'Sat, 01 Jan 2000 03:00:00 CDT',\n    'Saturday, 01-Jan-00 03:00:00 CDT',\n    '01 Jan 00 03:00 -0500'];\n// MST = UT minus 7 hours.\nvar testCasesMST = [\n    'Sat, 01-Jan-2000 01:00:00 MST',\n    'Sat, 01 Jan 2000 01:00:00 MST',\n    'Saturday, 01-Jan-00 01:00:00 MST',\n    '01 Jan 00 01:00 -0700'];\n// MDT = UT minus 6 hours.\nvar testCasesMDT = [\n    'Sat, 01-Jan-2000 02:00:00 MDT',\n    'Sat, 01 Jan 2000 02:00:00 MDT',\n    'Saturday, 01-Jan-00 02:00:00 MDT',\n    '01 Jan 00 02:00 -0600'];\n// PST = UT minus 8 hours.\nvar testCasesPST = [\n    'Sat, 01-Jan-2000 00:00:00 PST',\n    'Sat, 01 Jan 2000 00:00:00 PST',\n    'Saturday, 01-Jan-00 00:00:00 PST',\n    '01 Jan 00 00:00 -0800',\n    // Allow missing time.\n    'Sat, 01-Jan-2000 PST'];\n// PDT = UT minus 7 hours.\nvar testCasesPDT = [\n    'Sat, 01-Jan-2000 01:00:00 PDT',\n    'Sat, 01 Jan 2000 01:00:00 PDT',\n    'Saturday, 01-Jan-00 01:00:00 PDT',\n    '01 Jan 00 01:00 -0700'];\n// Local time cases.\nvar testCasesLocalTime = [\n    // Allow timezone omission.\n    'Sat, 01-Jan-2000 08:00:00',\n    'Sat, 01 Jan 2000 08:00:00',\n    'Jan 01 2000 08:00:00',\n    'Jan 01 08:00:00 2000',\n    'Saturday, 01-Jan-00 08:00:00',\n    '01 Jan 00 08:00'];\n// Misc. test cases that result in a different time value.\nvar testCasesMisc = [\n    // Special handling for years in the [0, 100) range.\n    ['Sat, 01 Jan 0 08:00:00 UT', 946713600000], // year 2000\n    ['Sat, 01 Jan 49 08:00:00 UT', 2493100800000], // year 2049\n    ['Sat, 01 Jan 50 08:00:00 UT', -631123200000], // year 1950\n    ['Sat, 01 Jan 99 08:00:00 UT', 915177600000], // year 1999\n    ['Sat, 01 Jan 100 08:00:00 UT', -59011430400000], // year 100\n    // Test PM after time.\n    ['Sat, 01-Jan-2000 08:00 PM UT', 946756800000],\n    ['Sat, 01 Jan 2000 08:00 PM UT', 946756800000],\n    ['Jan 01 2000 08:00 PM UT', 946756800000],\n    ['Jan 01 08:00 PM UT 2000', 946756800000],\n    ['Saturday, 01-Jan-00 08:00 PM UT', 946756800000],\n    ['01 Jan 00 08:00 PM +0000', 946756800000]];\n// Test different version of the ES5 date time string format.\nvar testCasesES5Misc = [\n    ['2000-01-01T08:00:00.000Z', 946713600000],\n    ['2000-01-01T08:00:00Z', 946713600000],\n    ['2000-01-01T08:00Z', 946713600000],\n    ['2000-01T08:00:00.000Z', 946713600000],\n    ['2000T08:00:00.000Z', 946713600000],\n    ['2000T08:00Z', 946713600000],\n    ['2000-01T00:00:00.000-08:00', 946713600000],\n    ['2000-01T08:00:00.001Z', 946713600001],\n    ['2000-01T08:00:00.099Z', 946713600099],\n    ['2000-01T08:00:00.999Z', 946713600999],\n    ['2000-01T00:00:00.001-08:00', 946713600001],\n    ['2000-01-01T24:00Z', 946771200000],\n    ['2000-01-01T24:00:00Z', 946771200000],\n    ['2000-01-01T24:00:00.000Z', 946771200000],\n    ['2000-01-01T24:00:00.000Z', 946771200000]];\nvar testCasesES5MiscNegative = [\n    '2000-01-01TZ',\n    '2000-01-01T60Z',\n    '2000-01-01T60:60Z',\n    '2000-01-0108:00Z',\n    '2000-01-01T08Z',\n    '2000-01-01T24:01',\n    '2000-01-01T24:00:01',\n    '2000-01-01T24:00:00.001',\n    '2000-01-01T24:00:00.999Z'];\n// TODO(littledan): This is an hack that could break in historically\n// changing timezones that happened on this day, but allows us to\n// check the date value for local times.\nvar localOffset = new Date('2000-01-01').getTimezoneOffset()*1000*60;\n// Sanity check which is even more of a hack: in the timezones where\n// these tests are likely to be run, the offset is nonzero because\n// dates which don't include Z are in the local timezone.\nif (this.Intl &&\n    [\"America/Los_Angeles\", \"Europe/Berlin\", \"Europe/Madrid\"].indexOf(\n        Intl.DateTimeFormat().resolvedOptions().timeZone) != -1) {\n  assertTrue(localOffset != 0);\n}\nvar testCasesES2016TZ = [\n    // If the timezone is absent and time is present, use local time\n    ['2000-01-02T00:00', 946771200000 + localOffset],\n    ['2000-01-02T00:00:00', 946771200000 + localOffset],\n    ['2000-01-02T00:00:00.000', 946771200000 + localOffset],\n    // If timezone is absent and time is absent, use UTC\n    ['2000-01-02', 946771200000],\n    ['2000-01-02', 946771200000],\n    ['2000-01-02', 946771200000],\n];\n// Run all the tests.\ntestCasesUT.forEach(testDateParse);\ntestCasesGMT.forEach(testDateParse);\ntestCasesEST.forEach(testDateParse);\ntestCasesEDT.forEach(testDateParse);\ntestCasesCST.forEach(testDateParse);\ntestCasesCDT.forEach(testDateParse);\ntestCasesMST.forEach(testDateParse);\ntestCasesMDT.forEach(testDateParse);\ntestCasesPST.forEach(testDateParse);\ntestCasesPDT.forEach(testDateParse);\ntestCasesLocalTime.forEach(testDateParseLocalTime);\ntestCasesMisc.forEach(testDateParseMisc);\n// ES5 date time string format compliance.\ntestCasesES5Misc.forEach(testDateParseMisc);\ntestCasesES5MiscNegative.forEach(function (s) {\n    assertTrue(isNaN(Date.parse(s)), s + \" is not NaN.\");\n});\ntestCasesES2016TZ.forEach(testDateParseMisc);\n// Test that we can parse our own date format.\n// (Dates from 1970 to ~2070 with 150h steps.)\nfor (var i = 0; i < 24 * 365 * 100; i += 150) {\n  var ms = i * (3600 * 1000);\n  var s = (new Date(ms)).toString();\n  assertEquals(ms, Date.parse(s), \"parse own: \" + s);\n}\n// Negative tests.\nvar testCasesNegative = [\n    'May 25 2008 1:30 (PM)) UTC',  // Bad unmatched ')' after number.\n    'May 25 2008 1:30( )AM (PM)',  //\n    'a1',                          // Issue 126448, 53209.\n    'nasfdjklsfjoaifg1',\n    'x_2',\n    'May 25 2008 AAA (GMT)'];      // Unknown word after number.\ntestCasesNegative.forEach(function (s) {\n    assertTrue(isNaN(Date.parse(s)), s + \" is not NaN.\");\n});\n`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n"
        },
        {
          "name": "destruct.go",
          "type": "blob",
          "size": 7.59765625,
          "content": "package goja\n\nimport (\n\t\"github.com/dop251/goja/unistring\"\n\t\"reflect\"\n)\n\ntype destructKeyedSource struct {\n\tr        *Runtime\n\twrapped  Value\n\tusedKeys map[Value]struct{}\n}\n\nfunc newDestructKeyedSource(r *Runtime, wrapped Value) *destructKeyedSource {\n\treturn &destructKeyedSource{\n\t\tr:       r,\n\t\twrapped: wrapped,\n\t}\n}\n\nfunc (r *Runtime) newDestructKeyedSource(wrapped Value) *Object {\n\treturn &Object{\n\t\truntime: r,\n\t\tself:    newDestructKeyedSource(r, wrapped),\n\t}\n}\n\nfunc (d *destructKeyedSource) w() objectImpl {\n\treturn d.wrapped.ToObject(d.r).self\n}\n\nfunc (d *destructKeyedSource) recordKey(key Value) {\n\tif d.usedKeys == nil {\n\t\td.usedKeys = make(map[Value]struct{})\n\t}\n\td.usedKeys[key] = struct{}{}\n}\n\nfunc (d *destructKeyedSource) sortLen() int {\n\treturn d.w().sortLen()\n}\n\nfunc (d *destructKeyedSource) sortGet(i int) Value {\n\treturn d.w().sortGet(i)\n}\n\nfunc (d *destructKeyedSource) swap(i int, i2 int) {\n\td.w().swap(i, i2)\n}\n\nfunc (d *destructKeyedSource) className() string {\n\treturn d.w().className()\n}\n\nfunc (d *destructKeyedSource) typeOf() String {\n\treturn d.w().typeOf()\n}\n\nfunc (d *destructKeyedSource) getStr(p unistring.String, receiver Value) Value {\n\td.recordKey(stringValueFromRaw(p))\n\treturn d.w().getStr(p, receiver)\n}\n\nfunc (d *destructKeyedSource) getIdx(p valueInt, receiver Value) Value {\n\td.recordKey(p.toString())\n\treturn d.w().getIdx(p, receiver)\n}\n\nfunc (d *destructKeyedSource) getSym(p *Symbol, receiver Value) Value {\n\td.recordKey(p)\n\treturn d.w().getSym(p, receiver)\n}\n\nfunc (d *destructKeyedSource) getOwnPropStr(u unistring.String) Value {\n\td.recordKey(stringValueFromRaw(u))\n\treturn d.w().getOwnPropStr(u)\n}\n\nfunc (d *destructKeyedSource) getOwnPropIdx(v valueInt) Value {\n\td.recordKey(v.toString())\n\treturn d.w().getOwnPropIdx(v)\n}\n\nfunc (d *destructKeyedSource) getOwnPropSym(symbol *Symbol) Value {\n\td.recordKey(symbol)\n\treturn d.w().getOwnPropSym(symbol)\n}\n\nfunc (d *destructKeyedSource) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\treturn d.w().setOwnStr(p, v, throw)\n}\n\nfunc (d *destructKeyedSource) setOwnIdx(p valueInt, v Value, throw bool) bool {\n\treturn d.w().setOwnIdx(p, v, throw)\n}\n\nfunc (d *destructKeyedSource) setOwnSym(p *Symbol, v Value, throw bool) bool {\n\treturn d.w().setOwnSym(p, v, throw)\n}\n\nfunc (d *destructKeyedSource) setForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn d.w().setForeignStr(p, v, receiver, throw)\n}\n\nfunc (d *destructKeyedSource) setForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn d.w().setForeignIdx(p, v, receiver, throw)\n}\n\nfunc (d *destructKeyedSource) setForeignSym(p *Symbol, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn d.w().setForeignSym(p, v, receiver, throw)\n}\n\nfunc (d *destructKeyedSource) hasPropertyStr(u unistring.String) bool {\n\treturn d.w().hasPropertyStr(u)\n}\n\nfunc (d *destructKeyedSource) hasPropertyIdx(idx valueInt) bool {\n\treturn d.w().hasPropertyIdx(idx)\n}\n\nfunc (d *destructKeyedSource) hasPropertySym(s *Symbol) bool {\n\treturn d.w().hasPropertySym(s)\n}\n\nfunc (d *destructKeyedSource) hasOwnPropertyStr(u unistring.String) bool {\n\treturn d.w().hasOwnPropertyStr(u)\n}\n\nfunc (d *destructKeyedSource) hasOwnPropertyIdx(v valueInt) bool {\n\treturn d.w().hasOwnPropertyIdx(v)\n}\n\nfunc (d *destructKeyedSource) hasOwnPropertySym(s *Symbol) bool {\n\treturn d.w().hasOwnPropertySym(s)\n}\n\nfunc (d *destructKeyedSource) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\treturn d.w().defineOwnPropertyStr(name, desc, throw)\n}\n\nfunc (d *destructKeyedSource) defineOwnPropertyIdx(name valueInt, desc PropertyDescriptor, throw bool) bool {\n\treturn d.w().defineOwnPropertyIdx(name, desc, throw)\n}\n\nfunc (d *destructKeyedSource) defineOwnPropertySym(name *Symbol, desc PropertyDescriptor, throw bool) bool {\n\treturn d.w().defineOwnPropertySym(name, desc, throw)\n}\n\nfunc (d *destructKeyedSource) deleteStr(name unistring.String, throw bool) bool {\n\treturn d.w().deleteStr(name, throw)\n}\n\nfunc (d *destructKeyedSource) deleteIdx(idx valueInt, throw bool) bool {\n\treturn d.w().deleteIdx(idx, throw)\n}\n\nfunc (d *destructKeyedSource) deleteSym(s *Symbol, throw bool) bool {\n\treturn d.w().deleteSym(s, throw)\n}\n\nfunc (d *destructKeyedSource) assertCallable() (call func(FunctionCall) Value, ok bool) {\n\treturn d.w().assertCallable()\n}\n\nfunc (d *destructKeyedSource) vmCall(vm *vm, n int) {\n\td.w().vmCall(vm, n)\n}\n\nfunc (d *destructKeyedSource) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn d.w().assertConstructor()\n}\n\nfunc (d *destructKeyedSource) proto() *Object {\n\treturn d.w().proto()\n}\n\nfunc (d *destructKeyedSource) setProto(proto *Object, throw bool) bool {\n\treturn d.w().setProto(proto, throw)\n}\n\nfunc (d *destructKeyedSource) hasInstance(v Value) bool {\n\treturn d.w().hasInstance(v)\n}\n\nfunc (d *destructKeyedSource) isExtensible() bool {\n\treturn d.w().isExtensible()\n}\n\nfunc (d *destructKeyedSource) preventExtensions(throw bool) bool {\n\treturn d.w().preventExtensions(throw)\n}\n\ntype destructKeyedSourceIter struct {\n\td       *destructKeyedSource\n\twrapped iterNextFunc\n}\n\nfunc (i *destructKeyedSourceIter) next() (propIterItem, iterNextFunc) {\n\tfor {\n\t\titem, next := i.wrapped()\n\t\tif next == nil {\n\t\t\treturn item, nil\n\t\t}\n\t\ti.wrapped = next\n\t\tif _, exists := i.d.usedKeys[item.name]; !exists {\n\t\t\treturn item, i.next\n\t\t}\n\t}\n}\n\nfunc (d *destructKeyedSource) iterateStringKeys() iterNextFunc {\n\treturn (&destructKeyedSourceIter{\n\t\td:       d,\n\t\twrapped: d.w().iterateStringKeys(),\n\t}).next\n}\n\nfunc (d *destructKeyedSource) iterateSymbols() iterNextFunc {\n\treturn (&destructKeyedSourceIter{\n\t\td:       d,\n\t\twrapped: d.w().iterateSymbols(),\n\t}).next\n}\n\nfunc (d *destructKeyedSource) iterateKeys() iterNextFunc {\n\treturn (&destructKeyedSourceIter{\n\t\td:       d,\n\t\twrapped: d.w().iterateKeys(),\n\t}).next\n}\n\nfunc (d *destructKeyedSource) export(ctx *objectExportCtx) interface{} {\n\treturn d.w().export(ctx)\n}\n\nfunc (d *destructKeyedSource) exportType() reflect.Type {\n\treturn d.w().exportType()\n}\n\nfunc (d *destructKeyedSource) exportToMap(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn d.w().exportToMap(dst, typ, ctx)\n}\n\nfunc (d *destructKeyedSource) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn d.w().exportToArrayOrSlice(dst, typ, ctx)\n}\n\nfunc (d *destructKeyedSource) equal(impl objectImpl) bool {\n\treturn d.w().equal(impl)\n}\n\nfunc (d *destructKeyedSource) stringKeys(all bool, accum []Value) []Value {\n\tvar next iterNextFunc\n\tif all {\n\t\tnext = d.iterateStringKeys()\n\t} else {\n\t\tnext = (&enumerableIter{\n\t\t\to:       d.wrapped.ToObject(d.r),\n\t\t\twrapped: d.iterateStringKeys(),\n\t\t}).next\n\t}\n\tfor item, next := next(); next != nil; item, next = next() {\n\t\taccum = append(accum, item.name)\n\t}\n\treturn accum\n}\n\nfunc (d *destructKeyedSource) filterUsedKeys(keys []Value) []Value {\n\tk := 0\n\tfor i, key := range keys {\n\t\tif _, exists := d.usedKeys[key]; exists {\n\t\t\tcontinue\n\t\t}\n\t\tif k != i {\n\t\t\tkeys[k] = key\n\t\t}\n\t\tk++\n\t}\n\treturn keys[:k]\n}\n\nfunc (d *destructKeyedSource) symbols(all bool, accum []Value) []Value {\n\treturn d.filterUsedKeys(d.w().symbols(all, accum))\n}\n\nfunc (d *destructKeyedSource) keys(all bool, accum []Value) []Value {\n\treturn d.filterUsedKeys(d.w().keys(all, accum))\n}\n\nfunc (d *destructKeyedSource) _putProp(name unistring.String, value Value, writable, enumerable, configurable bool) Value {\n\treturn d.w()._putProp(name, value, writable, enumerable, configurable)\n}\n\nfunc (d *destructKeyedSource) _putSym(s *Symbol, prop Value) {\n\td.w()._putSym(s, prop)\n}\n\nfunc (d *destructKeyedSource) getPrivateEnv(typ *privateEnvType, create bool) *privateElements {\n\treturn d.w().getPrivateEnv(typ, create)\n}\n"
        },
        {
          "name": "extract_failed_tests.sh",
          "type": "blob",
          "size": 0.0771484375,
          "content": "#!/bin/sh\n\nsed -En 's/^.*FAIL: TestTC39\\/tc39\\/(test\\/.*.js).*$/\"\\1\": true,/p'\n"
        },
        {
          "name": "file",
          "type": "tree",
          "content": null
        },
        {
          "name": "ftoa",
          "type": "tree",
          "content": null
        },
        {
          "name": "func.go",
          "type": "blob",
          "size": 24.892578125,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype resultType uint8\n\nconst (\n\tresultNormal resultType = iota\n\tresultYield\n\tresultYieldRes      // a yield that expects a value in return\n\tresultYieldDelegate // yield*\n\tresultYieldDelegateRes\n\tresultAwait\n)\n\n// used both as an instruction and as a Value\ntype yieldMarker struct {\n\tvalueNull\n\tresultType resultType\n}\n\nvar (\n\tawait = &yieldMarker{resultType: resultAwait}\n\n\tyield            = &yieldMarker{resultType: resultYield}\n\tyieldRes         = &yieldMarker{resultType: resultYieldRes}\n\tyieldDelegate    = &yieldMarker{resultType: resultYieldDelegate}\n\tyieldDelegateRes = &yieldMarker{resultType: resultYieldDelegateRes}\n\tyieldEmpty       = &yieldMarker{resultType: resultYield}\n)\n\n// AsyncContextTracker is a handler that allows to track an async execution context to ensure it remains\n// consistent across all callback invocations.\n// Whenever a Promise reaction job is scheduled the Grab method is called. It is supposed to return the\n// current context. The same context will be supplied to the Resumed method before the reaction job is\n// executed. The Exited method is called after the reaction job is finished.\n// This means that for each invocation of the Grab method there will be exactly one subsequent invocation\n// of Resumed and then Exited methods (assuming the Promise is fulfilled or rejected). Also, the Resumed/Exited\n// calls cannot be nested, so Exited can simply clear the current context instead of popping from a stack.\n// Note, this works for both async functions and regular Promise.then()/Promise.catch() callbacks.\n// See TestAsyncContextTracker for more insight.\n//\n// To register it call Runtime.SetAsyncContextTracker().\ntype AsyncContextTracker interface {\n\tGrab() (trackingObject interface{})\n\tResumed(trackingObject interface{})\n\tExited()\n}\n\ntype funcObjectImpl interface {\n\tsource() String\n}\n\ntype baseFuncObject struct {\n\tbaseObject\n\n\tlenProp valueProperty\n}\n\ntype baseJsFuncObject struct {\n\tbaseFuncObject\n\n\tstash   *stash\n\tprivEnv *privateEnv\n\n\tprg    *Program\n\tsrc    string\n\tstrict bool\n}\n\ntype funcObject struct {\n\tbaseJsFuncObject\n}\n\ntype generatorFuncObject struct {\n\tbaseJsFuncObject\n}\n\ntype asyncFuncObject struct {\n\tbaseJsFuncObject\n}\n\ntype classFuncObject struct {\n\tbaseJsFuncObject\n\tinitFields   *Program\n\tcomputedKeys []Value\n\n\tprivateEnvType *privateEnvType\n\tprivateMethods []Value\n\n\tderived bool\n}\n\ntype methodFuncObject struct {\n\tbaseJsFuncObject\n\thomeObject *Object\n}\n\ntype generatorMethodFuncObject struct {\n\tmethodFuncObject\n}\n\ntype asyncMethodFuncObject struct {\n\tmethodFuncObject\n}\n\ntype arrowFuncObject struct {\n\tbaseJsFuncObject\n\tfuncObj   *Object\n\tnewTarget Value\n}\n\ntype asyncArrowFuncObject struct {\n\tarrowFuncObject\n}\n\ntype nativeFuncObject struct {\n\tbaseFuncObject\n\n\tf         func(FunctionCall) Value\n\tconstruct func(args []Value, newTarget *Object) *Object\n}\n\ntype wrappedFuncObject struct {\n\tnativeFuncObject\n\twrapped reflect.Value\n}\n\ntype boundFuncObject struct {\n\tnativeFuncObject\n\twrapped *Object\n}\n\ntype generatorState uint8\n\nconst (\n\tgenStateUndefined generatorState = iota\n\tgenStateSuspendedStart\n\tgenStateExecuting\n\tgenStateSuspendedYield\n\tgenStateSuspendedYieldRes\n\tgenStateCompleted\n)\n\ntype generatorObject struct {\n\tbaseObject\n\tgen       generator\n\tdelegated *iteratorRecord\n\tstate     generatorState\n}\n\nfunc (f *nativeFuncObject) source() String {\n\treturn newStringValue(fmt.Sprintf(\"function %s() { [native code] }\", nilSafe(f.getStr(\"name\", nil)).toString()))\n}\n\nfunc (f *nativeFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.f\n}\n\nfunc (f *wrappedFuncObject) exportType() reflect.Type {\n\treturn f.wrapped.Type()\n}\n\nfunc (f *wrappedFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.wrapped.Interface()\n}\n\nfunc (f *funcObject) _addProto(n unistring.String) Value {\n\tif n == \"prototype\" {\n\t\tif _, exists := f.values[n]; !exists {\n\t\t\treturn f.addPrototype()\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (f *funcObject) getStr(p unistring.String, receiver Value) Value {\n\treturn f.getStrWithOwnProp(f.getOwnPropStr(p), p, receiver)\n}\n\nfunc (f *funcObject) getOwnPropStr(name unistring.String) Value {\n\tif v := f._addProto(name); v != nil {\n\t\treturn v\n\t}\n\n\treturn f.baseObject.getOwnPropStr(name)\n}\n\nfunc (f *funcObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tf._addProto(name)\n\treturn f.baseObject.setOwnStr(name, val, throw)\n}\n\nfunc (f *funcObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn f._setForeignStr(name, f.getOwnPropStr(name), val, receiver, throw)\n}\n\nfunc (f *funcObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tf._addProto(name)\n\treturn f.baseObject.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (f *funcObject) deleteStr(name unistring.String, throw bool) bool {\n\tf._addProto(name)\n\treturn f.baseObject.deleteStr(name, throw)\n}\n\nfunc (f *funcObject) addPrototype() Value {\n\tproto := f.val.runtime.NewObject()\n\tproto.self._putProp(\"constructor\", f.val, true, false, true)\n\treturn f._putProp(\"prototype\", proto, true, false, false)\n}\n\nfunc (f *funcObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif f.baseObject.hasOwnPropertyStr(name) {\n\t\treturn true\n\t}\n\n\tif name == \"prototype\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (f *funcObject) stringKeys(all bool, accum []Value) []Value {\n\tif all {\n\t\tif _, exists := f.values[\"prototype\"]; !exists {\n\t\t\taccum = append(accum, asciiString(\"prototype\"))\n\t\t}\n\t}\n\treturn f.baseFuncObject.stringKeys(all, accum)\n}\n\nfunc (f *funcObject) iterateStringKeys() iterNextFunc {\n\tif _, exists := f.values[\"prototype\"]; !exists {\n\t\tf.addPrototype()\n\t}\n\treturn f.baseFuncObject.iterateStringKeys()\n}\n\nfunc (f *baseFuncObject) createInstance(newTarget *Object) *Object {\n\tr := f.val.runtime\n\tif newTarget == nil {\n\t\tnewTarget = f.val\n\t}\n\tproto := r.getPrototypeFromCtor(newTarget, nil, r.global.ObjectPrototype)\n\n\treturn f.val.runtime.newBaseObject(proto, classObject).val\n}\n\nfunc (f *baseJsFuncObject) source() String {\n\treturn newStringValue(f.src)\n}\n\nfunc (f *baseJsFuncObject) construct(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tnewTarget = f.val\n\t}\n\tproto := newTarget.self.getStr(\"prototype\", nil)\n\tvar protoObj *Object\n\tif p, ok := proto.(*Object); ok {\n\t\tprotoObj = p\n\t} else {\n\t\tprotoObj = f.val.runtime.global.ObjectPrototype\n\t}\n\n\tobj := f.val.runtime.newBaseObject(protoObj, classObject).val\n\tret := f.call(FunctionCall{\n\t\tThis:      obj,\n\t\tArguments: args,\n\t}, newTarget)\n\n\tif ret, ok := ret.(*Object); ok {\n\t\treturn ret\n\t}\n\treturn obj\n}\n\nfunc (f *classFuncObject) Call(FunctionCall) Value {\n\tpanic(f.val.runtime.NewTypeError(\"Class constructor cannot be invoked without 'new'\"))\n}\n\nfunc (f *classFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *classFuncObject) vmCall(vm *vm, n int) {\n\tf.Call(FunctionCall{})\n}\n\nfunc (f *classFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *classFuncObject) createInstance(args []Value, newTarget *Object) (instance *Object) {\n\tif f.derived {\n\t\tif ctor := f.prototype.self.assertConstructor(); ctor != nil {\n\t\t\tinstance = ctor(args, newTarget)\n\t\t} else {\n\t\t\tpanic(f.val.runtime.NewTypeError(\"Super constructor is not a constructor\"))\n\t\t}\n\t} else {\n\t\tinstance = f.baseFuncObject.createInstance(newTarget)\n\t}\n\treturn\n}\n\nfunc (f *classFuncObject) _initFields(instance *Object) {\n\tif f.privateEnvType != nil {\n\t\tpenv := instance.self.getPrivateEnv(f.privateEnvType, true)\n\t\tpenv.methods = f.privateMethods\n\t}\n\tif f.initFields != nil {\n\t\tvm := f.val.runtime.vm\n\t\tvm.pushCtx()\n\t\tvm.prg = f.initFields\n\t\tvm.stash = f.stash\n\t\tvm.privEnv = f.privEnv\n\t\tvm.newTarget = nil\n\n\t\t// so that 'super' base could be correctly resolved (including from direct eval())\n\t\tvm.push(f.val)\n\n\t\tvm.sb = vm.sp\n\t\tvm.push(instance)\n\t\tvm.pc = 0\n\t\tex := vm.runTry()\n\t\tvm.popCtx()\n\t\tif ex != nil {\n\t\t\tpanic(ex)\n\t\t}\n\t\tvm.sp -= 2\n\t}\n}\n\nfunc (f *classFuncObject) construct(args []Value, newTarget *Object) *Object {\n\tif newTarget == nil {\n\t\tnewTarget = f.val\n\t}\n\tif f.prg == nil {\n\t\tinstance := f.createInstance(args, newTarget)\n\t\tf._initFields(instance)\n\t\treturn instance\n\t} else {\n\t\tvar instance *Object\n\t\tvar thisVal Value\n\t\tif !f.derived {\n\t\t\tinstance = f.createInstance(args, newTarget)\n\t\t\tf._initFields(instance)\n\t\t\tthisVal = instance\n\t\t}\n\t\tret := f._call(args, newTarget, thisVal)\n\n\t\tif ret, ok := ret.(*Object); ok {\n\t\t\treturn ret\n\t\t}\n\t\tif f.derived {\n\t\t\tr := f.val.runtime\n\t\t\tif ret != _undefined {\n\t\t\t\tpanic(r.NewTypeError(\"Derived constructors may only return object or undefined\"))\n\t\t\t}\n\t\t\tif v := r.vm.stack[r.vm.sp+1]; v != nil { // using residual 'this' value (a bit hacky)\n\t\t\t\tinstance = r.toObject(v)\n\t\t\t} else {\n\t\t\t\tpanic(r.newError(r.getReferenceError(), \"Must call super constructor in derived class before returning from derived constructor\"))\n\t\t\t}\n\t\t}\n\t\treturn instance\n\t}\n}\n\nfunc (f *classFuncObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn f.construct\n}\n\nfunc (f *baseJsFuncObject) Call(call FunctionCall) Value {\n\treturn f.call(call, nil)\n}\n\nfunc (f *arrowFuncObject) Call(call FunctionCall) Value {\n\treturn f._call(call.Arguments, f.newTarget, nil)\n}\n\nfunc (f *baseJsFuncObject) __call(args []Value, newTarget, this Value) (Value, *Exception) {\n\tvm := f.val.runtime.vm\n\n\tvm.stack.expand(vm.sp + len(args) + 1)\n\tvm.stack[vm.sp] = f.val\n\tvm.sp++\n\tvm.stack[vm.sp] = this\n\tvm.sp++\n\tfor _, arg := range args {\n\t\tif arg != nil {\n\t\t\tvm.stack[vm.sp] = arg\n\t\t} else {\n\t\t\tvm.stack[vm.sp] = _undefined\n\t\t}\n\t\tvm.sp++\n\t}\n\n\tvm.pushTryFrame(tryPanicMarker, -1)\n\tdefer vm.popTryFrame()\n\n\tvar needPop bool\n\tif vm.prg != nil {\n\t\tvm.pushCtx()\n\t\tvm.callStack = append(vm.callStack, context{pc: -2}) // extra frame so that run() halts after ret\n\t\tneedPop = true\n\t} else {\n\t\tvm.pc = -2\n\t\tvm.pushCtx()\n\t}\n\n\tvm.args = len(args)\n\tvm.prg = f.prg\n\tvm.stash = f.stash\n\tvm.privEnv = f.privEnv\n\tvm.newTarget = newTarget\n\tvm.pc = 0\n\tfor {\n\t\tex := vm.runTryInner()\n\t\tif ex != nil {\n\t\t\treturn nil, ex\n\t\t}\n\t\tif vm.halted() {\n\t\t\tbreak\n\t\t}\n\t}\n\tif needPop {\n\t\tvm.popCtx()\n\t}\n\n\treturn vm.pop(), nil\n}\n\nfunc (f *baseJsFuncObject) _call(args []Value, newTarget, this Value) Value {\n\tres, ex := f.__call(args, newTarget, this)\n\tif ex != nil {\n\t\tpanic(ex)\n\t}\n\treturn res\n}\n\nfunc (f *baseJsFuncObject) call(call FunctionCall, newTarget Value) Value {\n\treturn f._call(call.Arguments, newTarget, nilSafe(call.This))\n}\n\nfunc (f *baseJsFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *baseFuncObject) exportType() reflect.Type {\n\treturn reflectTypeFunc\n}\n\nfunc (f *baseFuncObject) typeOf() String {\n\treturn stringFunction\n}\n\nfunc (f *baseJsFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *funcObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn f.construct\n}\n\nfunc (f *baseJsFuncObject) vmCall(vm *vm, n int) {\n\tvm.pushCtx()\n\tvm.args = n\n\tvm.prg = f.prg\n\tvm.stash = f.stash\n\tvm.privEnv = f.privEnv\n\tvm.pc = 0\n\tvm.stack[vm.sp-n-1], vm.stack[vm.sp-n-2] = vm.stack[vm.sp-n-2], vm.stack[vm.sp-n-1]\n}\n\nfunc (f *arrowFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *arrowFuncObject) vmCall(vm *vm, n int) {\n\tvm.pushCtx()\n\tvm.args = n\n\tvm.prg = f.prg\n\tvm.stash = f.stash\n\tvm.privEnv = f.privEnv\n\tvm.pc = 0\n\tvm.stack[vm.sp-n-1], vm.stack[vm.sp-n-2] = nil, vm.stack[vm.sp-n-1]\n\tvm.newTarget = f.newTarget\n}\n\nfunc (f *arrowFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *baseFuncObject) init(name unistring.String, length Value) {\n\tf.baseObject.init()\n\n\tf.lenProp.configurable = true\n\tf.lenProp.value = length\n\tf._put(\"length\", &f.lenProp)\n\n\tf._putProp(\"name\", stringValueFromRaw(name), false, false, true)\n}\n\nfunc hasInstance(val *Object, v Value) bool {\n\tif v, ok := v.(*Object); ok {\n\t\to := val.self.getStr(\"prototype\", nil)\n\t\tif o1, ok := o.(*Object); ok {\n\t\t\tfor {\n\t\t\t\tv = v.self.proto()\n\t\t\t\tif v == nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif o1 == v {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(val.runtime.NewTypeError(\"prototype is not an object\"))\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (f *baseFuncObject) hasInstance(v Value) bool {\n\treturn hasInstance(f.val, v)\n}\n\nfunc (f *nativeFuncObject) defaultConstruct(ccall func(ConstructorCall) *Object, args []Value, newTarget *Object) *Object {\n\tobj := f.createInstance(newTarget)\n\tret := ccall(ConstructorCall{\n\t\tThis:      obj,\n\t\tArguments: args,\n\t\tNewTarget: newTarget,\n\t})\n\n\tif ret != nil {\n\t\treturn ret\n\t}\n\treturn obj\n}\n\nfunc (f *nativeFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\tif f.f != nil {\n\t\treturn f.f, true\n\t}\n\treturn nil, false\n}\n\nfunc (f *nativeFuncObject) vmCall(vm *vm, n int) {\n\tif f.f != nil {\n\t\tvm.pushCtx()\n\t\tvm.prg = nil\n\t\tvm.sb = vm.sp - n // so that [sb-1] points to the callee\n\t\tret := f.f(FunctionCall{\n\t\t\tArguments: vm.stack[vm.sp-n : vm.sp],\n\t\t\tThis:      vm.stack[vm.sp-n-2],\n\t\t})\n\t\tif ret == nil {\n\t\t\tret = _undefined\n\t\t}\n\t\tvm.stack[vm.sp-n-2] = ret\n\t\tvm.popCtx()\n\t} else {\n\t\tvm.stack[vm.sp-n-2] = _undefined\n\t}\n\tvm.sp -= n + 1\n\tvm.pc++\n}\n\nfunc (f *nativeFuncObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn f.construct\n}\n\nfunc (f *boundFuncObject) hasInstance(v Value) bool {\n\treturn instanceOfOperator(v, f.wrapped)\n}\n\nfunc (f *baseJsFuncObject) prepareForVmCall(call FunctionCall) {\n\tvm := f.val.runtime.vm\n\targs := call.Arguments\n\tvm.stack.expand(vm.sp + len(args) + 1)\n\tvm.stack[vm.sp] = call.This\n\tvm.sp++\n\tvm.stack[vm.sp] = f.val\n\tvm.sp++\n\tfor _, arg := range args {\n\t\tif arg != nil {\n\t\t\tvm.stack[vm.sp] = arg\n\t\t} else {\n\t\t\tvm.stack[vm.sp] = _undefined\n\t\t}\n\t\tvm.sp++\n\t}\n}\n\nfunc (f *baseJsFuncObject) asyncCall(call FunctionCall, vmCall func(*vm, int)) Value {\n\tf.prepareForVmCall(call)\n\tar := &asyncRunner{\n\t\tf:      f.val,\n\t\tvmCall: vmCall,\n\t}\n\tar.start(len(call.Arguments))\n\treturn ar.promiseCap.promise\n}\n\nfunc (f *asyncFuncObject) Call(call FunctionCall) Value {\n\treturn f.asyncCall(call, f.baseJsFuncObject.vmCall)\n}\n\nfunc (f *asyncFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *asyncFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *asyncArrowFuncObject) Call(call FunctionCall) Value {\n\treturn f.asyncCall(call, f.arrowFuncObject.vmCall)\n}\n\nfunc (f *asyncArrowFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *asyncArrowFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *asyncArrowFuncObject) vmCall(vm *vm, n int) {\n\tf.asyncVmCall(vm, n, f.arrowFuncObject.vmCall)\n}\n\nfunc (f *asyncMethodFuncObject) Call(call FunctionCall) Value {\n\treturn f.asyncCall(call, f.methodFuncObject.vmCall)\n}\n\nfunc (f *asyncMethodFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *asyncMethodFuncObject) export(ctx *objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *asyncMethodFuncObject) vmCall(vm *vm, n int) {\n\tf.asyncVmCall(vm, n, f.methodFuncObject.vmCall)\n}\n\nfunc (f *baseJsFuncObject) asyncVmCall(vm *vm, n int, vmCall func(*vm, int)) {\n\tar := &asyncRunner{\n\t\tf:      f.val,\n\t\tvmCall: vmCall,\n\t}\n\tar.start(n)\n\tvm.push(ar.promiseCap.promise)\n\tvm.pc++\n}\n\nfunc (f *asyncFuncObject) vmCall(vm *vm, n int) {\n\tf.asyncVmCall(vm, n, f.baseJsFuncObject.vmCall)\n}\n\ntype asyncRunner struct {\n\tgen        generator\n\tpromiseCap *promiseCapability\n\tf          *Object\n\tvmCall     func(*vm, int)\n}\n\nfunc (ar *asyncRunner) onFulfilled(call FunctionCall) Value {\n\tar.gen.vm.curAsyncRunner = ar\n\tdefer func() {\n\t\tar.gen.vm.curAsyncRunner = nil\n\t}()\n\targ := call.Argument(0)\n\tres, resType, ex := ar.gen.next(arg)\n\tar.step(res, resType == resultNormal, ex)\n\treturn _undefined\n}\n\nfunc (ar *asyncRunner) onRejected(call FunctionCall) Value {\n\tar.gen.vm.curAsyncRunner = ar\n\tdefer func() {\n\t\tar.gen.vm.curAsyncRunner = nil\n\t}()\n\treason := call.Argument(0)\n\tres, resType, ex := ar.gen.nextThrow(reason)\n\tar.step(res, resType == resultNormal, ex)\n\treturn _undefined\n}\n\nfunc (ar *asyncRunner) step(res Value, done bool, ex *Exception) {\n\tr := ar.f.runtime\n\tif done || ex != nil {\n\t\tif ex == nil {\n\t\t\tar.promiseCap.resolve(res)\n\t\t} else {\n\t\t\tar.promiseCap.reject(ex.val)\n\t\t}\n\t\treturn\n\t}\n\n\t// await\n\tpromise := r.promiseResolve(r.getPromise(), res)\n\tpromise.self.(*Promise).addReactions(&promiseReaction{\n\t\ttyp:         promiseReactionFulfill,\n\t\thandler:     &jobCallback{callback: ar.onFulfilled},\n\t\tasyncRunner: ar,\n\t}, &promiseReaction{\n\t\ttyp:         promiseReactionReject,\n\t\thandler:     &jobCallback{callback: ar.onRejected},\n\t\tasyncRunner: ar,\n\t})\n}\n\nfunc (ar *asyncRunner) start(nArgs int) {\n\tr := ar.f.runtime\n\tar.gen.vm = r.vm\n\tar.promiseCap = r.newPromiseCapability(r.getPromise())\n\tsp := r.vm.sp\n\tar.gen.enter()\n\tar.vmCall(r.vm, nArgs)\n\tres, resType, ex := ar.gen.step()\n\tar.step(res, resType == resultNormal, ex)\n\tif ex != nil {\n\t\tr.vm.sp = sp - nArgs - 2\n\t}\n\tr.vm.popTryFrame()\n\tr.vm.popCtx()\n}\n\ntype generator struct {\n\tctx execCtx\n\tvm  *vm\n\n\ttryStackLen, iterStackLen, refStackLen uint32\n}\n\nfunc (g *generator) storeLengths() {\n\tg.tryStackLen, g.iterStackLen, g.refStackLen = uint32(len(g.vm.tryStack)), uint32(len(g.vm.iterStack)), uint32(len(g.vm.refStack))\n}\n\nfunc (g *generator) enter() {\n\tg.vm.pushCtx()\n\tg.vm.pushTryFrame(tryPanicMarker, -1)\n\tg.vm.prg, g.vm.sb, g.vm.pc = nil, -1, -2 // so that vm.run() halts after ret\n\tg.storeLengths()\n}\n\nfunc (g *generator) step() (res Value, resultType resultType, ex *Exception) {\n\tfor {\n\t\tex = g.vm.runTryInner()\n\t\tif ex != nil {\n\t\t\treturn\n\t\t}\n\t\tif g.vm.halted() {\n\t\t\tbreak\n\t\t}\n\t}\n\tres = g.vm.pop()\n\tif ym, ok := res.(*yieldMarker); ok {\n\t\tresultType = ym.resultType\n\t\tg.ctx = execCtx{}\n\t\tg.vm.pc = -g.vm.pc + 1\n\t\tif res != yieldEmpty {\n\t\t\tres = g.vm.pop()\n\t\t} else {\n\t\t\tres = nil\n\t\t}\n\t\tg.vm.suspend(&g.ctx, g.tryStackLen, g.iterStackLen, g.refStackLen)\n\t\tg.vm.sp = g.vm.sb - 1\n\t\tg.vm.callStack = g.vm.callStack[:len(g.vm.callStack)-1] // remove the frame with pc == -2, as ret would do\n\t}\n\treturn\n}\n\nfunc (g *generator) enterNext() {\n\tg.vm.pushCtx()\n\tg.vm.pushTryFrame(tryPanicMarker, -1)\n\tg.vm.callStack = append(g.vm.callStack, context{pc: -2}) // extra frame so that vm.run() halts after ret\n\tg.storeLengths()\n\tg.vm.resume(&g.ctx)\n}\n\nfunc (g *generator) next(v Value) (Value, resultType, *Exception) {\n\tg.enterNext()\n\tif v != nil {\n\t\tg.vm.push(v)\n\t}\n\tres, done, ex := g.step()\n\tg.vm.popTryFrame()\n\tg.vm.popCtx()\n\treturn res, done, ex\n}\n\nfunc (g *generator) nextThrow(v interface{}) (Value, resultType, *Exception) {\n\tg.enterNext()\n\tex := g.vm.handleThrow(v)\n\tif ex != nil {\n\t\tg.vm.popTryFrame()\n\t\tg.vm.popCtx()\n\t\treturn nil, resultNormal, ex\n\t}\n\n\tres, resType, ex := g.step()\n\tg.vm.popTryFrame()\n\tg.vm.popCtx()\n\treturn res, resType, ex\n}\n\nfunc (g *generatorObject) init(vmCall func(*vm, int), nArgs int) {\n\tg.baseObject.init()\n\tvm := g.val.runtime.vm\n\tg.gen.vm = vm\n\n\tg.gen.enter()\n\tvmCall(vm, nArgs)\n\n\t_, _, ex := g.gen.step()\n\n\tvm.popTryFrame()\n\tif ex != nil {\n\t\tpanic(ex)\n\t}\n\n\tg.state = genStateSuspendedStart\n\tvm.popCtx()\n}\n\nfunc (g *generatorObject) validate() {\n\tif g.state == genStateExecuting {\n\t\tpanic(g.val.runtime.NewTypeError(\"Illegal generator state\"))\n\t}\n}\n\nfunc (g *generatorObject) step(res Value, resType resultType, ex *Exception) Value {\n\tif ex != nil {\n\t\tg.delegated = nil\n\t\tg.state = genStateCompleted\n\t\tpanic(ex)\n\t}\n\tswitch resType {\n\tcase resultYield:\n\t\tg.state = genStateSuspendedYield\n\t\treturn g.val.runtime.createIterResultObject(res, false)\n\tcase resultYieldDelegate:\n\t\tg.state = genStateSuspendedYield\n\t\treturn g.delegate(res)\n\tcase resultYieldRes:\n\t\tg.state = genStateSuspendedYieldRes\n\t\treturn g.val.runtime.createIterResultObject(res, false)\n\tcase resultYieldDelegateRes:\n\t\tg.state = genStateSuspendedYieldRes\n\t\treturn g.delegate(res)\n\tcase resultNormal:\n\t\tg.state = genStateCompleted\n\t\treturn g.val.runtime.createIterResultObject(res, true)\n\tdefault:\n\t\tpanic(g.val.runtime.NewTypeError(\"Runtime bug: unexpected result type: %v\", resType))\n\t}\n}\n\nfunc (g *generatorObject) delegate(v Value) Value {\n\tex := g.val.runtime.try(func() {\n\t\tg.delegated = g.val.runtime.getIterator(v, nil)\n\t})\n\tif ex != nil {\n\t\tg.delegated = nil\n\t\tg.state = genStateCompleted\n\t\treturn g.step(g.gen.nextThrow(ex))\n\t}\n\treturn g.next(_undefined)\n}\n\nfunc (g *generatorObject) tryCallDelegated(fn func() (Value, bool)) (ret Value, done bool) {\n\tex := g.val.runtime.try(func() {\n\t\tret, done = fn()\n\t})\n\tif ex != nil {\n\t\tg.delegated = nil\n\t\tg.state = genStateExecuting\n\t\treturn g.step(g.gen.nextThrow(ex)), false\n\t}\n\treturn\n}\n\nfunc (g *generatorObject) callDelegated(method func(FunctionCall) Value, v Value) (Value, bool) {\n\tres := g.val.runtime.toObject(method(FunctionCall{This: g.delegated.iterator, Arguments: []Value{v}}))\n\tif iteratorComplete(res) {\n\t\tg.delegated = nil\n\t\treturn iteratorValue(res), true\n\t}\n\treturn res, false\n}\n\nfunc (g *generatorObject) next(v Value) Value {\n\tg.validate()\n\tif g.state == genStateCompleted {\n\t\treturn g.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\tif g.delegated != nil {\n\t\tres, done := g.tryCallDelegated(func() (Value, bool) {\n\t\t\treturn g.callDelegated(g.delegated.next, v)\n\t\t})\n\t\tif !done {\n\t\t\treturn res\n\t\t} else {\n\t\t\tv = res\n\t\t}\n\t}\n\tif g.state != genStateSuspendedYieldRes {\n\t\tv = nil\n\t}\n\tg.state = genStateExecuting\n\treturn g.step(g.gen.next(v))\n}\n\nfunc (g *generatorObject) throw(v Value) Value {\n\tg.validate()\n\tif g.state == genStateSuspendedStart {\n\t\tg.state = genStateCompleted\n\t}\n\tif g.state == genStateCompleted {\n\t\tpanic(v)\n\t}\n\tif d := g.delegated; d != nil {\n\t\tres, done := g.tryCallDelegated(func() (Value, bool) {\n\t\t\tmethod := toMethod(g.delegated.iterator.self.getStr(\"throw\", nil))\n\t\t\tif method != nil {\n\t\t\t\treturn g.callDelegated(method, v)\n\t\t\t}\n\t\t\tg.delegated = nil\n\t\t\td.returnIter()\n\t\t\tpanic(g.val.runtime.NewTypeError(\"The iterator does not provide a 'throw' method\"))\n\t\t})\n\t\tif !done {\n\t\t\treturn res\n\t\t}\n\t\tif g.state != genStateSuspendedYieldRes {\n\t\t\tres = nil\n\t\t}\n\t\tg.state = genStateExecuting\n\t\treturn g.step(g.gen.next(res))\n\t}\n\tg.state = genStateExecuting\n\treturn g.step(g.gen.nextThrow(v))\n}\n\nfunc (g *generatorObject) _return(v Value) Value {\n\tg.validate()\n\tif g.state == genStateSuspendedStart {\n\t\tg.state = genStateCompleted\n\t}\n\n\tif g.state == genStateCompleted {\n\t\treturn g.val.runtime.createIterResultObject(v, true)\n\t}\n\n\tif d := g.delegated; d != nil {\n\t\tres, done := g.tryCallDelegated(func() (Value, bool) {\n\t\t\tmethod := toMethod(g.delegated.iterator.self.getStr(\"return\", nil))\n\t\t\tif method != nil {\n\t\t\t\treturn g.callDelegated(method, v)\n\t\t\t}\n\t\t\tg.delegated = nil\n\t\t\treturn v, true\n\t\t})\n\t\tif !done {\n\t\t\treturn res\n\t\t} else {\n\t\t\tv = res\n\t\t}\n\t}\n\n\tg.state = genStateExecuting\n\n\tg.gen.enterNext()\n\n\tvm := g.gen.vm\n\tvar ex *Exception\n\tfor len(vm.tryStack) > 0 {\n\t\ttf := &vm.tryStack[len(vm.tryStack)-1]\n\t\tif int(tf.callStackLen) != len(vm.callStack) {\n\t\t\tbreak\n\t\t}\n\n\t\tif tf.finallyPos >= 0 {\n\t\t\tvm.sp = int(tf.sp)\n\t\t\tvm.stash = tf.stash\n\t\t\tvm.privEnv = tf.privEnv\n\t\t\tex1 := vm.restoreStacks(tf.iterLen, tf.refLen)\n\t\t\tif ex1 != nil {\n\t\t\t\tex = ex1\n\t\t\t\tvm.popTryFrame()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvm.pc = int(tf.finallyPos)\n\t\t\ttf.catchPos = tryPanicMarker\n\t\t\ttf.finallyPos = -1\n\t\t\ttf.finallyRet = -2 // -1 would cause it to continue after leaveFinally\n\t\t\tfor {\n\t\t\t\tex1 := vm.runTryInner()\n\t\t\t\tif ex1 != nil {\n\t\t\t\t\tex = ex1\n\t\t\t\t\tvm.popTryFrame()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif vm.halted() {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvm.popTryFrame()\n\t\t}\n\t}\n\n\tg.state = genStateCompleted\n\n\tvm.popTryFrame()\n\n\tif ex == nil {\n\t\tex = vm.restoreStacks(g.gen.iterStackLen, g.gen.refStackLen)\n\t}\n\n\tif ex != nil {\n\t\tpanic(ex)\n\t}\n\n\tvm.callStack = vm.callStack[:len(vm.callStack)-1]\n\tvm.sp = vm.sb - 1\n\tvm.popCtx()\n\n\treturn g.val.runtime.createIterResultObject(v, true)\n}\n\nfunc (f *baseJsFuncObject) generatorCall(vmCall func(*vm, int), nArgs int) Value {\n\to := &Object{runtime: f.val.runtime}\n\n\tgenObj := &generatorObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      classObject,\n\t\t\tval:        o,\n\t\t\textensible: true,\n\t\t},\n\t}\n\to.self = genObj\n\tgenObj.init(vmCall, nArgs)\n\tgenObj.prototype = o.runtime.getPrototypeFromCtor(f.val, nil, o.runtime.getGeneratorPrototype())\n\treturn o\n}\n\nfunc (f *baseJsFuncObject) generatorVmCall(vmCall func(*vm, int), nArgs int) {\n\tvm := f.val.runtime.vm\n\tvm.push(f.generatorCall(vmCall, nArgs))\n\tvm.pc++\n}\n\nfunc (f *generatorFuncObject) vmCall(_ *vm, nArgs int) {\n\tf.generatorVmCall(f.baseJsFuncObject.vmCall, nArgs)\n}\n\nfunc (f *generatorFuncObject) Call(call FunctionCall) Value {\n\tf.prepareForVmCall(call)\n\treturn f.generatorCall(f.baseJsFuncObject.vmCall, len(call.Arguments))\n}\n\nfunc (f *generatorFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *generatorFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n\nfunc (f *generatorFuncObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn nil\n}\n\nfunc (f *generatorMethodFuncObject) vmCall(_ *vm, nArgs int) {\n\tf.generatorVmCall(f.methodFuncObject.vmCall, nArgs)\n}\n\nfunc (f *generatorMethodFuncObject) Call(call FunctionCall) Value {\n\tf.prepareForVmCall(call)\n\treturn f.generatorCall(f.methodFuncObject.vmCall, len(call.Arguments))\n}\n\nfunc (f *generatorMethodFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn f.Call, true\n}\n\nfunc (f *generatorMethodFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.Call\n}\n"
        },
        {
          "name": "func_test.go",
          "type": "blob",
          "size": 5.576171875,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFuncProto(t *testing.T) {\n\tconst SCRIPT = `\n\t\"use strict\";\n\tfunction A() {}\n\tA.__proto__ = Object;\n\tA.prototype = {};\n\n\tfunction B() {}\n\tB.__proto__ = Object.create(null);\n\tvar thrown = false;\n\ttry {\n\t\tdelete B.prototype;\n\t} catch (e) {\n\t\tthrown = e instanceof TypeError;\n\t}\n\tthrown;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFuncPrototypeRedefine(t *testing.T) {\n\tconst SCRIPT = `\n\tlet thrown = false;\n\ttry {\n\t\tObject.defineProperty(function() {}, \"prototype\", {\n\t\t\tset: function(_value) {},\n\t\t});\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFuncExport(t *testing.T) {\n\tvm := New()\n\ttyp := reflect.TypeOf((func(FunctionCall) Value)(nil))\n\n\tf := func(expr string, t *testing.T) {\n\t\tv, err := vm.RunString(expr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif actualTyp := v.ExportType(); actualTyp != typ {\n\t\t\tt.Fatalf(\"Invalid export type: %v\", actualTyp)\n\t\t}\n\t\tev := v.Export()\n\t\tif actualTyp := reflect.TypeOf(ev); actualTyp != typ {\n\t\t\tt.Fatalf(\"Invalid export value: %v\", ev)\n\t\t}\n\t}\n\n\tt.Run(\"regular function\", func(t *testing.T) {\n\t\tf(\"(function() {})\", t)\n\t})\n\n\tt.Run(\"arrow function\", func(t *testing.T) {\n\t\tf(\"(()=>{})\", t)\n\t})\n\n\tt.Run(\"method\", func(t *testing.T) {\n\t\tf(\"({m() {}}).m\", t)\n\t})\n\n\tt.Run(\"class\", func(t *testing.T) {\n\t\tf(\"(class {})\", t)\n\t})\n}\n\nfunc TestFuncWrapUnwrap(t *testing.T) {\n\tvm := New()\n\tf := func(a int, b string) bool {\n\t\treturn a > 0 && b != \"\"\n\t}\n\tvar f1 func(int, string) bool\n\tv := vm.ToValue(f)\n\tif et := v.ExportType(); et != reflect.TypeOf(f1) {\n\t\tt.Fatal(et)\n\t}\n\terr := vm.ExportTo(v, &f1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !f1(1, \"a\") {\n\t\tt.Fatal(\"not true\")\n\t}\n}\n\nfunc TestWrappedFunc(t *testing.T) {\n\tvm := New()\n\tf := func(a int, b string) bool {\n\t\treturn a > 0 && b != \"\"\n\t}\n\tvm.Set(\"f\", f)\n\tconst SCRIPT = `\n\tassert.sameValue(typeof f, \"function\");\n\tconst s = f.toString()\n\tassert(s.endsWith(\"TestWrappedFunc.func1() { [native code] }\"), s);\n\tassert(f(1, \"a\"));\n\tassert(!f(0, \"\"));\n\t`\n\tvm.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestWrappedFuncErrorPassthrough(t *testing.T) {\n\tvm := New()\n\te := errors.New(\"test\")\n\tf := func(a int) error {\n\t\tif a > 0 {\n\t\t\treturn e\n\t\t}\n\t\treturn nil\n\t}\n\n\tvar f1 func(a int64) error\n\terr := vm.ExportTo(vm.ToValue(f), &f1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := f1(1); err != e {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc ExampleAssertConstructor() {\n\tvm := New()\n\tres, err := vm.RunString(`\n\t\t(class C {\n\t\t\tconstructor(x) {\n\t\t\t\tthis.x = x;\n\t\t\t}\n\t\t})\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif ctor, ok := AssertConstructor(res); ok {\n\t\tobj, err := ctor(nil, vm.ToValue(\"Test\"))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Print(obj.Get(\"x\"))\n\t} else {\n\t\tpanic(\"Not a constructor\")\n\t}\n\t// Output: Test\n}\n\ntype testAsyncCtx struct {\n\tgroup    string\n\trefCount int\n}\n\ntype testAsyncContextTracker struct {\n\tctx     *testAsyncCtx\n\tlogFunc func(...interface{})\n\tresumed bool\n}\n\nfunc (s *testAsyncContextTracker) Grab() interface{} {\n\tctx := s.ctx\n\tif ctx != nil {\n\t\ts.logFunc(\"Grab\", ctx.group)\n\t\tctx.refCount++\n\t}\n\treturn ctx\n}\n\nfunc (s *testAsyncContextTracker) Resumed(trackingObj interface{}) {\n\ts.logFunc(\"Resumed\", trackingObj)\n\tif s.resumed {\n\t\tpanic(\"Nested Resumed() calls\")\n\t}\n\ts.ctx = trackingObj.(*testAsyncCtx)\n\ts.resumed = true\n}\n\nfunc (s *testAsyncContextTracker) releaseCtx() {\n\ts.ctx.refCount--\n\tif s.ctx.refCount < 0 {\n\t\tpanic(\"refCount < 0\")\n\t}\n\tif s.ctx.refCount == 0 {\n\t\ts.logFunc(s.ctx.group, \"is finished\")\n\t}\n}\n\nfunc (s *testAsyncContextTracker) Exited() {\n\ts.logFunc(\"Exited\")\n\tif s.ctx != nil {\n\t\ts.releaseCtx()\n\t\ts.ctx = nil\n\t}\n\ts.resumed = false\n}\n\nfunc TestAsyncContextTracker(t *testing.T) {\n\tr := New()\n\tvar tracker testAsyncContextTracker\n\ttracker.logFunc = t.Log\n\n\tgroup := func(name string, asyncFunc func(FunctionCall) Value) Value {\n\t\tprevCtx := tracker.ctx\n\t\tdefer func() {\n\t\t\tt.Log(\"Returned\", name)\n\t\t\ttracker.releaseCtx()\n\t\t\ttracker.ctx = prevCtx\n\t\t}()\n\t\ttracker.ctx = &testAsyncCtx{\n\t\t\tgroup:    name,\n\t\t\trefCount: 1,\n\t\t}\n\t\tt.Log(\"Set\", name)\n\t\treturn asyncFunc(FunctionCall{})\n\t}\n\tr.SetAsyncContextTracker(&tracker)\n\tr.Set(\"group\", group)\n\tr.Set(\"check\", func(expectedGroup, msg string) {\n\t\tvar groupName string\n\t\tif tracker.ctx != nil {\n\t\t\tgroupName = tracker.ctx.group\n\t\t}\n\t\tif groupName != expectedGroup {\n\t\t\tt.Fatalf(\"Unexpected group (%q), expected %q in %s\", groupName, expectedGroup, msg)\n\t\t}\n\t\tt.Log(\"In\", msg)\n\t})\n\n\tt.Run(\"\", func(t *testing.T) {\n\t\t_, err := r.RunString(`\n\t\tgroup(\"1\", async () => {\n\t\t  check(\"1\", \"line A\");\n\t\t  await 3;\n\t\t  check(\"1\", \"line B\");\n\t\t  group(\"2\", async () => {\n\t\t     check(\"2\", \"line C\");\n\t\t     await 4;\n\t\t     check(\"2\", \"line D\");\n\t\t })\n\t\t}).then(() => {\n            check(\"\", \"line E\");\n\t\t})\n\t\t`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\n\tt.Run(\"\", func(t *testing.T) {\n\t\t_, err := r.RunString(`\n\t\tgroup(\"some\", async () => {\n\t\t\tcheck(\"some\", \"line A\");\n\t\t    (async () => {\n\t\t\t\tcheck(\"some\", \"line B\");\n\t\t        await 1;\n\t\t\t\tcheck(\"some\", \"line C\");\n\t\t        await 2;\n\t\t\t\tcheck(\"some\", \"line D\");\n\t\t    })();\n\t\t\tcheck(\"some\", \"line E\");\n\t\t});\n\t`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\n\tt.Run(\"\", func(t *testing.T) {\n\t\t_, err := r.RunString(`\n\tgroup(\"Main\", async () => {\n\t\tcheck(\"Main\", \"0.1\");\n\t\tawait Promise.all([\n\t\t\tgroup(\"A\", async () => {\n\t\t\t\tcheck(\"A\", \"1.1\");\n\t\t\t\tawait 1;\n\t\t\t\tcheck(\"A\", \"1.2\");\n\t\t\t}),\n\t\t\t(async () => {\n\t\t\t\tcheck(\"Main\", \"3.1\");\n\t\t\t})(),\n\t\t\tgroup(\"B\", async () => {\n\t\t\t\tcheck(\"B\", \"2.1\");\n\t\t\t\tawait 2;\n\t\t\t\tcheck(\"B\", \"2.2\");\n\t\t\t})\n\t\t]);\n\t\tcheck(\"Main\", \"0.2\");\n\t});\n\t`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.400390625,
          "content": "module github.com/dop251/goja\n\ngo 1.20\n\nrequire (\n\tgithub.com/Masterminds/semver/v3 v3.2.1\n\tgithub.com/dlclark/regexp2 v1.11.4\n\tgithub.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d\n\tgithub.com/go-sourcemap/sourcemap v2.1.3+incompatible\n\tgithub.com/google/pprof v0.0.0-20230207041349-798e818bf904\n\tgolang.org/x/text v0.3.8\n\tgopkg.in/yaml.v2 v2.4.0\n)\n\nrequire github.com/kr/pretty v0.3.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.2001953125,
          "content": "github.com/Masterminds/semver/v3 v3.2.1 h1:RN9w6+7QoMeJVGyfmbcgs28Br8cvmnucEXnY0rYXWg0=\ngithub.com/Masterminds/semver/v3 v3.2.1/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/dlclark/regexp2 v1.4.1-0.20201116162257-a2a8dda75c91/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=\ngithub.com/dlclark/regexp2 v1.11.4 h1:rPYF9/LECdNymJufQKmri9gV604RvvABwgOA8un7yAo=\ngithub.com/dlclark/regexp2 v1.11.4/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dop251/goja v0.0.0-20211022113120-dc8c55024d06/go.mod h1:R9ET47fwRVRPZnOGvHxxhuZcbrMCuiqOz3Rlrh4KSnk=\ngithub.com/dop251/goja_nodejs v0.0.0-20210225215109-d91c329300e7/go.mod h1:hn7BA7c8pLvoGndExHudxTDKZ84Pyvv+90pbBjbTz0Y=\ngithub.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d h1:W1n4DvpzZGOISgp7wWNtraLcHtnmnTwBlJidqtMIuwQ=\ngithub.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d/go.mod h1:DngW8aVqWbuLRMHItjPUyqdj+HWPvnQe8V8y1nDpIbM=\ngithub.com/go-sourcemap/sourcemap v2.1.3+incompatible h1:W1iEw64niKVGogNgBN3ePyLFfuisuzeidWPMPWmECqU=\ngithub.com/go-sourcemap/sourcemap v2.1.3+incompatible/go.mod h1:F8jJfvm2KbVjc5NqelyYJmf/v5J0dwNLS2mL4sNA1Jg=\ngithub.com/google/pprof v0.0.0-20230207041349-798e818bf904 h1:4/hN5RUoecvl+RmJRE2YxKWtnnQls6rQjjW5oV7qg2U=\ngithub.com/google/pprof v0.0.0-20230207041349-798e818bf904/go.mod h1:uglQLonpP8qtYCYyzA+8c/9qtqgA3qsXGYqCPKARAFg=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/rogpeppe/go-internal v1.6.1 h1:/FiVV8dS/e+YqF2JvO3yXRFbBLTIuSDkuC7aBOAvL+k=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\n"
        },
        {
          "name": "goja",
          "type": "tree",
          "content": null
        },
        {
          "name": "ipow.go",
          "type": "blob",
          "size": 1.39453125,
          "content": "package goja\n\n// inspired by https://gist.github.com/orlp/3551590\n\nvar overflows = [64]int64{\n\t9223372036854775807, 9223372036854775807, 3037000499, 2097151,\n\t55108, 6208, 1448, 511,\n\t234, 127, 78, 52,\n\t38, 28, 22, 18,\n\t15, 13, 11, 9,\n\t8, 7, 7, 6,\n\t6, 5, 5, 5,\n\t4, 4, 4, 4,\n\t3, 3, 3, 3,\n\t3, 3, 3, 3,\n\t2, 2, 2, 2,\n\t2, 2, 2, 2,\n\t2, 2, 2, 2,\n\t2, 2, 2, 2,\n\t2, 2, 2, 2,\n\t2, 2, 2, 2,\n}\n\nvar highestBitSet = [63]byte{\n\t0, 1, 2, 2, 3, 3, 3, 3,\n\t4, 4, 4, 4, 4, 4, 4, 4,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 6, 6, 6, 6, 6, 6,\n}\n\nfunc ipow(base, exp int64) (result int64) {\n\tif exp >= 63 {\n\t\tif base == 1 {\n\t\t\treturn 1\n\t\t}\n\n\t\tif base == -1 {\n\t\t\treturn 1 - 2*(exp&1)\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tif base > overflows[exp] || -base > overflows[exp] {\n\t\treturn 0\n\t}\n\n\tresult = 1\n\n\tswitch highestBitSet[byte(exp)] {\n\tcase 6:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\texp >>= 1\n\t\tbase *= base\n\t\tfallthrough\n\tcase 5:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\texp >>= 1\n\t\tbase *= base\n\t\tfallthrough\n\tcase 4:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\texp >>= 1\n\t\tbase *= base\n\t\tfallthrough\n\tcase 3:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\texp >>= 1\n\t\tbase *= base\n\t\tfallthrough\n\tcase 2:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\texp >>= 1\n\t\tbase *= base\n\t\tfallthrough\n\tcase 1:\n\t\tif exp&1 != 0 {\n\t\t\tresult *= base\n\t\t}\n\t\tfallthrough\n\tdefault:\n\t\treturn result\n\t}\n}\n"
        },
        {
          "name": "map.go",
          "type": "blob",
          "size": 2.953125,
          "content": "package goja\n\nimport (\n\t\"hash/maphash\"\n)\n\ntype mapEntry struct {\n\tkey, value Value\n\n\titerPrev, iterNext *mapEntry\n\thNext              *mapEntry\n}\n\ntype orderedMap struct {\n\thash                *maphash.Hash\n\thashTable           map[uint64]*mapEntry\n\titerFirst, iterLast *mapEntry\n\tsize                int\n}\n\ntype orderedMapIter struct {\n\tm   *orderedMap\n\tcur *mapEntry\n}\n\nfunc (m *orderedMap) lookup(key Value) (h uint64, entry, hPrev *mapEntry) {\n\tif key == _negativeZero {\n\t\tkey = intToValue(0)\n\t}\n\th = key.hash(m.hash)\n\tfor entry = m.hashTable[h]; entry != nil && !entry.key.SameAs(key); hPrev, entry = entry, entry.hNext {\n\t}\n\treturn\n}\n\nfunc (m *orderedMap) set(key, value Value) {\n\th, entry, hPrev := m.lookup(key)\n\tif entry != nil {\n\t\tentry.value = value\n\t} else {\n\t\tif key == _negativeZero {\n\t\t\tkey = intToValue(0)\n\t\t}\n\t\tentry = &mapEntry{key: key, value: value}\n\t\tif hPrev == nil {\n\t\t\tm.hashTable[h] = entry\n\t\t} else {\n\t\t\thPrev.hNext = entry\n\t\t}\n\t\tif m.iterLast != nil {\n\t\t\tentry.iterPrev = m.iterLast\n\t\t\tm.iterLast.iterNext = entry\n\t\t} else {\n\t\t\tm.iterFirst = entry\n\t\t}\n\t\tm.iterLast = entry\n\t\tm.size++\n\t}\n}\n\nfunc (m *orderedMap) get(key Value) Value {\n\t_, entry, _ := m.lookup(key)\n\tif entry != nil {\n\t\treturn entry.value\n\t}\n\n\treturn nil\n}\n\nfunc (m *orderedMap) remove(key Value) bool {\n\th, entry, hPrev := m.lookup(key)\n\tif entry != nil {\n\t\tentry.key = nil\n\t\tentry.value = nil\n\n\t\t// remove from the doubly-linked list\n\t\tif entry.iterPrev != nil {\n\t\t\tentry.iterPrev.iterNext = entry.iterNext\n\t\t} else {\n\t\t\tm.iterFirst = entry.iterNext\n\t\t}\n\t\tif entry.iterNext != nil {\n\t\t\tentry.iterNext.iterPrev = entry.iterPrev\n\t\t} else {\n\t\t\tm.iterLast = entry.iterPrev\n\t\t}\n\n\t\t// remove from the hashTable\n\t\tif hPrev == nil {\n\t\t\tif entry.hNext == nil {\n\t\t\t\tdelete(m.hashTable, h)\n\t\t\t} else {\n\t\t\t\tm.hashTable[h] = entry.hNext\n\t\t\t}\n\t\t} else {\n\t\t\thPrev.hNext = entry.hNext\n\t\t}\n\n\t\tm.size--\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (m *orderedMap) has(key Value) bool {\n\t_, entry, _ := m.lookup(key)\n\treturn entry != nil\n}\n\nfunc (iter *orderedMapIter) next() *mapEntry {\n\tif iter.m == nil {\n\t\t// closed iterator\n\t\treturn nil\n\t}\n\n\tcur := iter.cur\n\t// if the current item was deleted, track back to find the latest that wasn't\n\tfor cur != nil && cur.key == nil {\n\t\tcur = cur.iterPrev\n\t}\n\n\tif cur != nil {\n\t\tcur = cur.iterNext\n\t} else {\n\t\tcur = iter.m.iterFirst\n\t}\n\n\tif cur == nil {\n\t\titer.close()\n\t} else {\n\t\titer.cur = cur\n\t}\n\n\treturn cur\n}\n\nfunc (iter *orderedMapIter) close() {\n\titer.m = nil\n\titer.cur = nil\n}\n\nfunc newOrderedMap(h *maphash.Hash) *orderedMap {\n\treturn &orderedMap{\n\t\thash:      h,\n\t\thashTable: make(map[uint64]*mapEntry),\n\t}\n}\n\nfunc (m *orderedMap) newIter() *orderedMapIter {\n\titer := &orderedMapIter{\n\t\tm: m,\n\t}\n\treturn iter\n}\n\nfunc (m *orderedMap) clear() {\n\tfor item := m.iterFirst; item != nil; item = item.iterNext {\n\t\titem.key = nil\n\t\titem.value = nil\n\t\tif item.iterPrev != nil {\n\t\t\titem.iterPrev.iterNext = nil\n\t\t}\n\t}\n\tm.iterFirst = nil\n\tm.iterLast = nil\n\tm.hashTable = make(map[uint64]*mapEntry)\n\tm.size = 0\n}\n"
        },
        {
          "name": "map_test.go",
          "type": "blob",
          "size": 4.8076171875,
          "content": "package goja\n\nimport (\n\t\"hash/maphash\"\n\t\"math\"\n\t\"math/big\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc testMapHashVal(v1, v2 Value, expected bool, t *testing.T) {\n\tvar h maphash.Hash\n\tactual := v1.hash(&h) == v2.hash(&h)\n\tif actual != expected {\n\t\tt.Fatalf(\"testMapHashVal failed for %v, %v\", v1, v2)\n\t}\n}\n\nfunc TestMapHash(t *testing.T) {\n\ttestMapHashVal(_NaN, _NaN, true, t)\n\ttestMapHashVal(valueTrue, valueFalse, false, t)\n\ttestMapHashVal(valueTrue, valueTrue, true, t)\n\ttestMapHashVal(intToValue(0), _negativeZero, true, t)\n\ttestMapHashVal(asciiString(\"Test\"), asciiString(\"Test\"), true, t)\n\ttestMapHashVal(newStringValue(\"\"), newStringValue(\"\"), true, t)\n\ttestMapHashVal(floatToValue(1.2345), floatToValue(1.2345), true, t)\n\ttestMapHashVal(SymIterator, SymToStringTag, false, t)\n\ttestMapHashVal(SymIterator, SymIterator, true, t)\n\ttestMapHashVal((*valueBigInt)(big.NewInt(1)), (*valueBigInt)(big.NewInt(-1)), false, t)\n\ttestMapHashVal((*valueBigInt)(big.NewInt(1)), (*valueBigInt)(big.NewInt(1)), true, t)\n\n\t// The following tests introduce indeterministic behaviour\n\t//testMapHashVal(asciiString(\"Test\"), asciiString(\"Test1\"), false, t)\n\t//testMapHashVal(newStringValue(\"\"), asciiString(\"Test\"), false, t)\n\t//testMapHashVal(newStringValue(\"\"), newStringValue(\"1\"), false, t)\n}\n\nfunc TestOrderedMap(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\tfor i := int64(0); i < 50; i++ {\n\t\tm.set(intToValue(i), asciiString(strconv.FormatInt(i, 10)))\n\t}\n\tif m.size != 50 {\n\t\tt.Fatalf(\"Unexpected size: %d\", m.size)\n\t}\n\n\tfor i := int64(0); i < 50; i++ {\n\t\texpected := asciiString(strconv.FormatInt(i, 10))\n\t\tactual := m.get(intToValue(i))\n\t\tif !expected.SameAs(actual) {\n\t\t\tt.Fatalf(\"Wrong value for %d\", i)\n\t\t}\n\t}\n\n\tfor i := int64(0); i < 50; i += 2 {\n\t\tif !m.remove(intToValue(i)) {\n\t\t\tt.Fatalf(\"remove(%d) return false\", i)\n\t\t}\n\t}\n\tif m.size != 25 {\n\t\tt.Fatalf(\"Unexpected size: %d\", m.size)\n\t}\n\n\titer := m.newIter()\n\tcount := 0\n\tfor {\n\t\tentry := iter.next()\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\tm.remove(entry.key)\n\t\tcount++\n\t}\n\n\tif count != 25 {\n\t\tt.Fatalf(\"Unexpected iter count: %d\", count)\n\t}\n\n\tif m.size != 0 {\n\t\tt.Fatalf(\"Unexpected size: %d\", m.size)\n\t}\n}\n\nfunc TestOrderedMapCollision(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\tn1 := uint64(123456789)\n\tn2 := math.Float64frombits(n1)\n\tn1Key := intToValue(int64(n1))\n\tn2Key := floatToValue(n2)\n\tm.set(n1Key, asciiString(\"n1\"))\n\tm.set(n2Key, asciiString(\"n2\"))\n\tif m.size == len(m.hashTable) {\n\t\tt.Fatal(\"Expected a collision but there wasn't one\")\n\t}\n\tif n2Val := m.get(n2Key); !asciiString(\"n2\").SameAs(n2Val) {\n\t\tt.Fatalf(\"unexpected n2Val: %v\", n2Val)\n\t}\n\tif n1Val := m.get(n1Key); !asciiString(\"n1\").SameAs(n1Val) {\n\t\tt.Fatalf(\"unexpected nVal: %v\", n1Val)\n\t}\n\n\tif !m.remove(n1Key) {\n\t\tt.Fatal(\"removing n1Key returned false\")\n\t}\n\tif n2Val := m.get(n2Key); !asciiString(\"n2\").SameAs(n2Val) {\n\t\tt.Fatalf(\"2: unexpected n2Val: %v\", n2Val)\n\t}\n}\n\nfunc TestOrderedMapIter(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\titer := m.newIter()\n\tent := iter.next()\n\tif ent != nil {\n\t\tt.Fatal(\"entry should be nil\")\n\t}\n\titer1 := m.newIter()\n\tm.set(intToValue(1), valueTrue)\n\tent = iter.next()\n\tif ent != nil {\n\t\tt.Fatal(\"2: entry should be nil\")\n\t}\n\tent = iter1.next()\n\tif ent == nil {\n\t\tt.Fatal(\"entry is nil\")\n\t}\n\tif !intToValue(1).SameAs(ent.key) {\n\t\tt.Fatal(\"unexpected key\")\n\t}\n\tif !valueTrue.SameAs(ent.value) {\n\t\tt.Fatal(\"unexpected value\")\n\t}\n}\n\nfunc TestOrderedMapIterVisitAfterReAdd(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\tone := intToValue(1)\n\ttwo := intToValue(2)\n\n\tm.set(one, valueTrue)\n\tm.set(two, valueTrue)\n\titer := m.newIter()\n\tentry := iter.next()\n\tif !one.SameAs(entry.key) {\n\t\tt.Fatalf(\"1: unexpected key: %v\", entry.key)\n\t}\n\tif !m.remove(one) {\n\t\tt.Fatal(\"remove returned false\")\n\t}\n\tentry = iter.next()\n\tif !two.SameAs(entry.key) {\n\t\tt.Fatalf(\"2: unexpected key: %v\", entry.key)\n\t}\n\tm.set(one, valueTrue)\n\tentry = iter.next()\n\tif entry == nil {\n\t\tt.Fatal(\"entry is nil\")\n\t}\n\tif !one.SameAs(entry.key) {\n\t\tt.Fatalf(\"3: unexpected key: %v\", entry.key)\n\t}\n}\n\nfunc TestOrderedMapIterAddAfterClear(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\tone := intToValue(1)\n\tm.set(one, valueTrue)\n\titer := m.newIter()\n\titer.next()\n\tm.clear()\n\tm.set(one, valueTrue)\n\tentry := iter.next()\n\tif entry == nil {\n\t\tt.Fatal(\"entry is nil\")\n\t}\n\tif entry.key != one {\n\t\tt.Fatalf(\"unexpected key: %v\", entry.key)\n\t}\n\tentry = iter.next()\n\tif entry != nil {\n\t\tt.Fatalf(\"entry is not nil: %v\", entry)\n\t}\n}\n\nfunc TestOrderedMapIterDeleteCurrent(t *testing.T) {\n\tm := newOrderedMap(&maphash.Hash{})\n\tone := intToValue(1)\n\ttwo := intToValue(2)\n\titer := m.newIter()\n\tm.set(one, valueTrue)\n\tm.set(two, valueTrue)\n\tentry := iter.next()\n\tif entry.key != one {\n\t\tt.Fatalf(\"unexpected key: %v\", entry.key)\n\t}\n\tm.remove(one)\n\tentry = iter.next()\n\tif entry.key != two {\n\t\tt.Fatalf(\"2: unexpected key: %v\", entry.key)\n\t}\n}\n"
        },
        {
          "name": "object.go",
          "type": "blob",
          "size": 44.1865234375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst (\n\tclassObject        = \"Object\"\n\tclassArray         = \"Array\"\n\tclassWeakSet       = \"WeakSet\"\n\tclassWeakMap       = \"WeakMap\"\n\tclassMap           = \"Map\"\n\tclassMath          = \"Math\"\n\tclassSet           = \"Set\"\n\tclassFunction      = \"Function\"\n\tclassAsyncFunction = \"AsyncFunction\"\n\tclassNumber        = \"Number\"\n\tclassString        = \"String\"\n\tclassBoolean       = \"Boolean\"\n\tclassError         = \"Error\"\n\tclassRegExp        = \"RegExp\"\n\tclassDate          = \"Date\"\n\tclassJSON          = \"JSON\"\n\tclassGlobal        = \"global\"\n\tclassPromise       = \"Promise\"\n\n\tclassArrayIterator        = \"Array Iterator\"\n\tclassMapIterator          = \"Map Iterator\"\n\tclassSetIterator          = \"Set Iterator\"\n\tclassStringIterator       = \"String Iterator\"\n\tclassRegExpStringIterator = \"RegExp String Iterator\"\n\n\tclassGenerator         = \"Generator\"\n\tclassGeneratorFunction = \"GeneratorFunction\"\n)\n\nvar (\n\thintDefault Value = asciiString(\"default\")\n\thintNumber  Value = asciiString(\"number\")\n\thintString  Value = asciiString(\"string\")\n)\n\ntype Object struct {\n\tid      uint64\n\truntime *Runtime\n\tself    objectImpl\n\n\tweakRefs map[weakMap]Value\n}\n\ntype iterNextFunc func() (propIterItem, iterNextFunc)\n\ntype PropertyDescriptor struct {\n\tjsDescriptor *Object\n\n\tValue Value\n\n\tWritable, Configurable, Enumerable Flag\n\n\tGetter, Setter Value\n}\n\nfunc (p *PropertyDescriptor) Empty() bool {\n\tvar empty PropertyDescriptor\n\treturn *p == empty\n}\n\nfunc (p *PropertyDescriptor) IsAccessor() bool {\n\treturn p.Setter != nil || p.Getter != nil\n}\n\nfunc (p *PropertyDescriptor) IsData() bool {\n\treturn p.Value != nil || p.Writable != FLAG_NOT_SET\n}\n\nfunc (p *PropertyDescriptor) IsGeneric() bool {\n\treturn !p.IsAccessor() && !p.IsData()\n}\n\nfunc (p *PropertyDescriptor) toValue(r *Runtime) Value {\n\tif p.jsDescriptor != nil {\n\t\treturn p.jsDescriptor\n\t}\n\tif p.Empty() {\n\t\treturn _undefined\n\t}\n\to := r.NewObject()\n\ts := o.self\n\n\tif p.Value != nil {\n\t\ts._putProp(\"value\", p.Value, true, true, true)\n\t}\n\n\tif p.Writable != FLAG_NOT_SET {\n\t\ts._putProp(\"writable\", valueBool(p.Writable.Bool()), true, true, true)\n\t}\n\n\tif p.Enumerable != FLAG_NOT_SET {\n\t\ts._putProp(\"enumerable\", valueBool(p.Enumerable.Bool()), true, true, true)\n\t}\n\n\tif p.Configurable != FLAG_NOT_SET {\n\t\ts._putProp(\"configurable\", valueBool(p.Configurable.Bool()), true, true, true)\n\t}\n\n\tif p.Getter != nil {\n\t\ts._putProp(\"get\", p.Getter, true, true, true)\n\t}\n\tif p.Setter != nil {\n\t\ts._putProp(\"set\", p.Setter, true, true, true)\n\t}\n\n\treturn o\n}\n\nfunc (p *PropertyDescriptor) complete() {\n\tif p.Getter == nil && p.Setter == nil {\n\t\tif p.Value == nil {\n\t\t\tp.Value = _undefined\n\t\t}\n\t\tif p.Writable == FLAG_NOT_SET {\n\t\t\tp.Writable = FLAG_FALSE\n\t\t}\n\t} else {\n\t\tif p.Getter == nil {\n\t\t\tp.Getter = _undefined\n\t\t}\n\t\tif p.Setter == nil {\n\t\t\tp.Setter = _undefined\n\t\t}\n\t}\n\tif p.Enumerable == FLAG_NOT_SET {\n\t\tp.Enumerable = FLAG_FALSE\n\t}\n\tif p.Configurable == FLAG_NOT_SET {\n\t\tp.Configurable = FLAG_FALSE\n\t}\n}\n\ntype objectExportCacheItem map[reflect.Type]interface{}\n\ntype objectExportCtx struct {\n\tcache map[*Object]interface{}\n}\n\ntype objectImpl interface {\n\tsortable\n\tclassName() string\n\ttypeOf() String\n\tgetStr(p unistring.String, receiver Value) Value\n\tgetIdx(p valueInt, receiver Value) Value\n\tgetSym(p *Symbol, receiver Value) Value\n\n\tgetOwnPropStr(unistring.String) Value\n\tgetOwnPropIdx(valueInt) Value\n\tgetOwnPropSym(*Symbol) Value\n\n\tsetOwnStr(p unistring.String, v Value, throw bool) bool\n\tsetOwnIdx(p valueInt, v Value, throw bool) bool\n\tsetOwnSym(p *Symbol, v Value, throw bool) bool\n\n\tsetForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool)\n\tsetForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool)\n\tsetForeignSym(p *Symbol, v, receiver Value, throw bool) (res bool, handled bool)\n\n\thasPropertyStr(unistring.String) bool\n\thasPropertyIdx(idx valueInt) bool\n\thasPropertySym(s *Symbol) bool\n\n\thasOwnPropertyStr(unistring.String) bool\n\thasOwnPropertyIdx(valueInt) bool\n\thasOwnPropertySym(s *Symbol) bool\n\n\tdefineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool\n\tdefineOwnPropertyIdx(name valueInt, desc PropertyDescriptor, throw bool) bool\n\tdefineOwnPropertySym(name *Symbol, desc PropertyDescriptor, throw bool) bool\n\n\tdeleteStr(name unistring.String, throw bool) bool\n\tdeleteIdx(idx valueInt, throw bool) bool\n\tdeleteSym(s *Symbol, throw bool) bool\n\n\tassertCallable() (call func(FunctionCall) Value, ok bool)\n\tvmCall(vm *vm, n int)\n\tassertConstructor() func(args []Value, newTarget *Object) *Object\n\tproto() *Object\n\tsetProto(proto *Object, throw bool) bool\n\thasInstance(v Value) bool\n\tisExtensible() bool\n\tpreventExtensions(throw bool) bool\n\n\texport(ctx *objectExportCtx) interface{}\n\texportType() reflect.Type\n\texportToMap(m reflect.Value, typ reflect.Type, ctx *objectExportCtx) error\n\texportToArrayOrSlice(s reflect.Value, typ reflect.Type, ctx *objectExportCtx) error\n\tequal(objectImpl) bool\n\n\titerateStringKeys() iterNextFunc\n\titerateSymbols() iterNextFunc\n\titerateKeys() iterNextFunc\n\n\tstringKeys(all bool, accum []Value) []Value\n\tsymbols(all bool, accum []Value) []Value\n\tkeys(all bool, accum []Value) []Value\n\n\t_putProp(name unistring.String, value Value, writable, enumerable, configurable bool) Value\n\t_putSym(s *Symbol, prop Value)\n\tgetPrivateEnv(typ *privateEnvType, create bool) *privateElements\n}\n\ntype baseObject struct {\n\tclass      string\n\tval        *Object\n\tprototype  *Object\n\textensible bool\n\n\tvalues    map[unistring.String]Value\n\tpropNames []unistring.String\n\n\tlastSortedPropLen, idxPropCount int\n\n\tsymValues *orderedMap\n\n\tprivateElements map[*privateEnvType]*privateElements\n}\n\ntype guardedObject struct {\n\tbaseObject\n\tguardedProps map[unistring.String]struct{}\n}\n\ntype primitiveValueObject struct {\n\tbaseObject\n\tpValue Value\n}\n\nfunc (o *primitiveValueObject) export(*objectExportCtx) interface{} {\n\treturn o.pValue.Export()\n}\n\nfunc (o *primitiveValueObject) exportType() reflect.Type {\n\treturn o.pValue.ExportType()\n}\n\ntype FunctionCall struct {\n\tThis      Value\n\tArguments []Value\n}\n\ntype ConstructorCall struct {\n\tThis      *Object\n\tArguments []Value\n\tNewTarget *Object\n}\n\nfunc (f FunctionCall) Argument(idx int) Value {\n\tif idx < len(f.Arguments) {\n\t\treturn f.Arguments[idx]\n\t}\n\treturn _undefined\n}\n\nfunc (f ConstructorCall) Argument(idx int) Value {\n\tif idx < len(f.Arguments) {\n\t\treturn f.Arguments[idx]\n\t}\n\treturn _undefined\n}\n\nfunc (o *baseObject) init() {\n\to.values = make(map[unistring.String]Value)\n}\n\nfunc (o *baseObject) className() string {\n\treturn o.class\n}\n\nfunc (o *baseObject) typeOf() String {\n\treturn stringObjectC\n}\n\nfunc (o *baseObject) hasPropertyStr(name unistring.String) bool {\n\tif o.val.self.hasOwnPropertyStr(name) {\n\t\treturn true\n\t}\n\tif o.prototype != nil {\n\t\treturn o.prototype.self.hasPropertyStr(name)\n\t}\n\treturn false\n}\n\nfunc (o *baseObject) hasPropertyIdx(idx valueInt) bool {\n\treturn o.val.self.hasPropertyStr(idx.string())\n}\n\nfunc (o *baseObject) hasPropertySym(s *Symbol) bool {\n\tif o.hasOwnPropertySym(s) {\n\t\treturn true\n\t}\n\tif o.prototype != nil {\n\t\treturn o.prototype.self.hasPropertySym(s)\n\t}\n\treturn false\n}\n\nfunc (o *baseObject) getWithOwnProp(prop, p, receiver Value) Value {\n\tif prop == nil && o.prototype != nil {\n\t\tif receiver == nil {\n\t\t\treturn o.prototype.get(p, o.val)\n\t\t}\n\t\treturn o.prototype.get(p, receiver)\n\t}\n\tif prop, ok := prop.(*valueProperty); ok {\n\t\tif receiver == nil {\n\t\t\treturn prop.get(o.val)\n\t\t}\n\t\treturn prop.get(receiver)\n\t}\n\treturn prop\n}\n\nfunc (o *baseObject) getStrWithOwnProp(prop Value, name unistring.String, receiver Value) Value {\n\tif prop == nil && o.prototype != nil {\n\t\tif receiver == nil {\n\t\t\treturn o.prototype.self.getStr(name, o.val)\n\t\t}\n\t\treturn o.prototype.self.getStr(name, receiver)\n\t}\n\tif prop, ok := prop.(*valueProperty); ok {\n\t\tif receiver == nil {\n\t\t\treturn prop.get(o.val)\n\t\t}\n\t\treturn prop.get(receiver)\n\t}\n\treturn prop\n}\n\nfunc (o *baseObject) getIdx(idx valueInt, receiver Value) Value {\n\treturn o.val.self.getStr(idx.string(), receiver)\n}\n\nfunc (o *baseObject) getSym(s *Symbol, receiver Value) Value {\n\treturn o.getWithOwnProp(o.getOwnPropSym(s), s, receiver)\n}\n\nfunc (o *baseObject) getStr(name unistring.String, receiver Value) Value {\n\tprop := o.values[name]\n\tif prop == nil {\n\t\tif o.prototype != nil {\n\t\t\tif receiver == nil {\n\t\t\t\treturn o.prototype.self.getStr(name, o.val)\n\t\t\t}\n\t\t\treturn o.prototype.self.getStr(name, receiver)\n\t\t}\n\t}\n\tif prop, ok := prop.(*valueProperty); ok {\n\t\tif receiver == nil {\n\t\t\treturn prop.get(o.val)\n\t\t}\n\t\treturn prop.get(receiver)\n\t}\n\treturn prop\n}\n\nfunc (o *baseObject) getOwnPropIdx(idx valueInt) Value {\n\treturn o.val.self.getOwnPropStr(idx.string())\n}\n\nfunc (o *baseObject) getOwnPropSym(s *Symbol) Value {\n\tif o.symValues != nil {\n\t\treturn o.symValues.get(s)\n\t}\n\treturn nil\n}\n\nfunc (o *baseObject) getOwnPropStr(name unistring.String) Value {\n\treturn o.values[name]\n}\n\nfunc (o *baseObject) checkDeleteProp(name unistring.String, prop *valueProperty, throw bool) bool {\n\tif !prop.configurable {\n\t\tif throw {\n\t\t\tr := o.val.runtime\n\t\t\tpanic(r.NewTypeError(\"Cannot delete property '%s' of %s\", name, r.objectproto_toString(FunctionCall{This: o.val})))\n\t\t}\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) checkDelete(name unistring.String, val Value, throw bool) bool {\n\tif val, ok := val.(*valueProperty); ok {\n\t\treturn o.checkDeleteProp(name, val, throw)\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) _delete(name unistring.String) {\n\tdelete(o.values, name)\n\tfor i, n := range o.propNames {\n\t\tif n == name {\n\t\t\tnames := o.propNames\n\t\t\tif namesMarkedForCopy(names) {\n\t\t\t\tnewNames := make([]unistring.String, len(names)-1, shrinkCap(len(names), cap(names)))\n\t\t\t\tcopy(newNames, names[:i])\n\t\t\t\tcopy(newNames[i:], names[i+1:])\n\t\t\t\to.propNames = newNames\n\t\t\t} else {\n\t\t\t\tcopy(names[i:], names[i+1:])\n\t\t\t\tnames[len(names)-1] = \"\"\n\t\t\t\to.propNames = names[:len(names)-1]\n\t\t\t}\n\t\t\tif i < o.lastSortedPropLen {\n\t\t\t\to.lastSortedPropLen--\n\t\t\t\tif i < o.idxPropCount {\n\t\t\t\t\to.idxPropCount--\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (o *baseObject) deleteIdx(idx valueInt, throw bool) bool {\n\treturn o.val.self.deleteStr(idx.string(), throw)\n}\n\nfunc (o *baseObject) deleteSym(s *Symbol, throw bool) bool {\n\tif o.symValues != nil {\n\t\tif val := o.symValues.get(s); val != nil {\n\t\t\tif !o.checkDelete(s.descriptiveString().string(), val, throw) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\to.symValues.remove(s)\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) deleteStr(name unistring.String, throw bool) bool {\n\tif val, exists := o.values[name]; exists {\n\t\tif !o.checkDelete(name, val, throw) {\n\t\t\treturn false\n\t\t}\n\t\to._delete(name)\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) setProto(proto *Object, throw bool) bool {\n\tcurrent := o.prototype\n\tif current.SameAs(proto) {\n\t\treturn true\n\t}\n\tif !o.extensible {\n\t\to.val.runtime.typeErrorResult(throw, \"%s is not extensible\", o.val)\n\t\treturn false\n\t}\n\tfor p := proto; p != nil; p = p.self.proto() {\n\t\tif p.SameAs(o.val) {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cyclic __proto__ value\")\n\t\t\treturn false\n\t\t}\n\t\tif _, ok := p.self.(*proxyObject); ok {\n\t\t\tbreak\n\t\t}\n\t}\n\to.prototype = proto\n\treturn true\n}\n\nfunc (o *baseObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\townDesc := o.values[name]\n\tif ownDesc == nil {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, handled := proto.self.setForeignStr(name, val, o.val, throw); handled {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\t// new property\n\t\tif !o.extensible {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot add property %s, object is not extensible\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\to.values[name] = val\n\t\t\tnames := copyNamesIfNeeded(o.propNames, 1)\n\t\t\to.propNames = append(names, name)\n\t\t}\n\t\treturn true\n\t}\n\tif prop, ok := ownDesc.(*valueProperty); ok {\n\t\tif !prop.isWritable() {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\tprop.set(o.val, val)\n\t\t}\n\t} else {\n\t\to.values[name] = val\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\treturn o.val.self.setOwnStr(idx.string(), val, throw)\n}\n\nfunc (o *baseObject) setOwnSym(name *Symbol, val Value, throw bool) bool {\n\tvar ownDesc Value\n\tif o.symValues != nil {\n\t\townDesc = o.symValues.get(name)\n\t}\n\tif ownDesc == nil {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, handled := proto.self.setForeignSym(name, val, o.val, throw); handled {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\t// new property\n\t\tif !o.extensible {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot add property %s, object is not extensible\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\tif o.symValues == nil {\n\t\t\t\to.symValues = newOrderedMap(nil)\n\t\t\t}\n\t\t\to.symValues.set(name, val)\n\t\t}\n\t\treturn true\n\t}\n\tif prop, ok := ownDesc.(*valueProperty); ok {\n\t\tif !prop.isWritable() {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\tprop.set(o.val, val)\n\t\t}\n\t} else {\n\t\to.symValues.set(name, val)\n\t}\n\treturn true\n}\n\nfunc (o *baseObject) _setForeignStr(name unistring.String, prop, val, receiver Value, throw bool) (bool, bool) {\n\tif prop != nil {\n\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\tif !prop.isWritable() {\n\t\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\t\treturn false, true\n\t\t\t}\n\t\t\tif prop.setterFunc != nil {\n\t\t\t\tprop.set(receiver, val)\n\t\t\t\treturn true, true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\tif receiver != proto {\n\t\t\t\treturn proto.self.setForeignStr(name, val, receiver, throw)\n\t\t\t}\n\t\t\treturn proto.self.setOwnStr(name, val, throw), true\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc (o *baseObject) _setForeignIdx(idx valueInt, prop, val, receiver Value, throw bool) (bool, bool) {\n\tif prop != nil {\n\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\tif !prop.isWritable() {\n\t\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%d'\", idx)\n\t\t\t\treturn false, true\n\t\t\t}\n\t\t\tif prop.setterFunc != nil {\n\t\t\t\tprop.set(receiver, val)\n\t\t\t\treturn true, true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\tif receiver != proto {\n\t\t\t\treturn proto.self.setForeignIdx(idx, val, receiver, throw)\n\t\t\t}\n\t\t\treturn proto.self.setOwnIdx(idx, val, throw), true\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc (o *baseObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, o.values[name], val, receiver, throw)\n}\n\nfunc (o *baseObject) setForeignIdx(name valueInt, val, receiver Value, throw bool) (bool, bool) {\n\tif idx := toIdx(name); idx != math.MaxUint32 {\n\t\to.ensurePropOrder()\n\t\tif o.idxPropCount == 0 {\n\t\t\treturn o._setForeignIdx(name, name, nil, receiver, throw)\n\t\t}\n\t}\n\treturn o.setForeignStr(name.string(), val, receiver, throw)\n}\n\nfunc (o *baseObject) setForeignSym(name *Symbol, val, receiver Value, throw bool) (bool, bool) {\n\tvar prop Value\n\tif o.symValues != nil {\n\t\tprop = o.symValues.get(name)\n\t}\n\tif prop != nil {\n\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\tif !prop.isWritable() {\n\t\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\t\treturn false, true\n\t\t\t}\n\t\t\tif prop.setterFunc != nil {\n\t\t\t\tprop.set(receiver, val)\n\t\t\t\treturn true, true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\tif receiver != o.val {\n\t\t\t\treturn proto.self.setForeignSym(name, val, receiver, throw)\n\t\t\t}\n\t\t\treturn proto.self.setOwnSym(name, val, throw), true\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc (o *baseObject) hasOwnPropertySym(s *Symbol) bool {\n\tif o.symValues != nil {\n\t\treturn o.symValues.has(s)\n\t}\n\treturn false\n}\n\nfunc (o *baseObject) hasOwnPropertyStr(name unistring.String) bool {\n\t_, exists := o.values[name]\n\treturn exists\n}\n\nfunc (o *baseObject) hasOwnPropertyIdx(idx valueInt) bool {\n\treturn o.val.self.hasOwnPropertyStr(idx.string())\n}\n\nfunc (o *baseObject) _defineOwnProperty(name unistring.String, existingValue Value, descr PropertyDescriptor, throw bool) (val Value, ok bool) {\n\n\tgetterObj, _ := descr.Getter.(*Object)\n\tsetterObj, _ := descr.Setter.(*Object)\n\n\tvar existing *valueProperty\n\n\tif existingValue == nil {\n\t\tif !o.extensible {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot define property %s, object is not extensible\", name)\n\t\t\treturn nil, false\n\t\t}\n\t\texisting = &valueProperty{}\n\t} else {\n\t\tif existing, ok = existingValue.(*valueProperty); !ok {\n\t\t\texisting = &valueProperty{\n\t\t\t\twritable:     true,\n\t\t\t\tenumerable:   true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue:        existingValue,\n\t\t\t}\n\t\t}\n\n\t\tif !existing.configurable {\n\t\t\tif descr.Configurable == FLAG_TRUE {\n\t\t\t\tgoto Reject\n\t\t\t}\n\t\t\tif descr.Enumerable != FLAG_NOT_SET && descr.Enumerable.Bool() != existing.enumerable {\n\t\t\t\tgoto Reject\n\t\t\t}\n\t\t}\n\t\tif existing.accessor && descr.Value != nil || !existing.accessor && (getterObj != nil || setterObj != nil) {\n\t\t\tif !existing.configurable {\n\t\t\t\tgoto Reject\n\t\t\t}\n\t\t} else if !existing.accessor {\n\t\t\tif !existing.configurable {\n\t\t\t\tif !existing.writable {\n\t\t\t\t\tif descr.Writable == FLAG_TRUE {\n\t\t\t\t\t\tgoto Reject\n\t\t\t\t\t}\n\t\t\t\t\tif descr.Value != nil && !descr.Value.SameAs(existing.value) {\n\t\t\t\t\t\tgoto Reject\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif !existing.configurable {\n\t\t\t\tif descr.Getter != nil && existing.getterFunc != getterObj || descr.Setter != nil && existing.setterFunc != setterObj {\n\t\t\t\t\tgoto Reject\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif descr.Writable == FLAG_TRUE && descr.Enumerable == FLAG_TRUE && descr.Configurable == FLAG_TRUE && descr.Value != nil {\n\t\treturn descr.Value, true\n\t}\n\n\tif descr.Writable != FLAG_NOT_SET {\n\t\texisting.writable = descr.Writable.Bool()\n\t}\n\tif descr.Enumerable != FLAG_NOT_SET {\n\t\texisting.enumerable = descr.Enumerable.Bool()\n\t}\n\tif descr.Configurable != FLAG_NOT_SET {\n\t\texisting.configurable = descr.Configurable.Bool()\n\t}\n\n\tif descr.Value != nil {\n\t\texisting.value = descr.Value\n\t\texisting.getterFunc = nil\n\t\texisting.setterFunc = nil\n\t}\n\n\tif descr.Value != nil || descr.Writable != FLAG_NOT_SET {\n\t\texisting.accessor = false\n\t}\n\n\tif descr.Getter != nil {\n\t\texisting.getterFunc = propGetter(o.val, descr.Getter, o.val.runtime)\n\t\texisting.value = nil\n\t\texisting.accessor = true\n\t}\n\n\tif descr.Setter != nil {\n\t\texisting.setterFunc = propSetter(o.val, descr.Setter, o.val.runtime)\n\t\texisting.value = nil\n\t\texisting.accessor = true\n\t}\n\n\tif !existing.accessor && existing.value == nil {\n\t\texisting.value = _undefined\n\t}\n\n\treturn existing, true\n\nReject:\n\to.val.runtime.typeErrorResult(throw, \"Cannot redefine property: %s\", name)\n\treturn nil, false\n\n}\n\nfunc (o *baseObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\texistingVal := o.values[name]\n\tif v, ok := o._defineOwnProperty(name, existingVal, descr, throw); ok {\n\t\to.values[name] = v\n\t\tif existingVal == nil {\n\t\t\tnames := copyNamesIfNeeded(o.propNames, 1)\n\t\t\to.propNames = append(names, name)\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *baseObject) defineOwnPropertyIdx(idx valueInt, desc PropertyDescriptor, throw bool) bool {\n\treturn o.val.self.defineOwnPropertyStr(idx.string(), desc, throw)\n}\n\nfunc (o *baseObject) defineOwnPropertySym(s *Symbol, descr PropertyDescriptor, throw bool) bool {\n\tvar existingVal Value\n\tif o.symValues != nil {\n\t\texistingVal = o.symValues.get(s)\n\t}\n\tif v, ok := o._defineOwnProperty(s.descriptiveString().string(), existingVal, descr, throw); ok {\n\t\tif o.symValues == nil {\n\t\t\to.symValues = newOrderedMap(nil)\n\t\t}\n\t\to.symValues.set(s, v)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *baseObject) _put(name unistring.String, v Value) {\n\tif _, exists := o.values[name]; !exists {\n\t\tnames := copyNamesIfNeeded(o.propNames, 1)\n\t\to.propNames = append(names, name)\n\t}\n\n\to.values[name] = v\n}\n\nfunc valueProp(value Value, writable, enumerable, configurable bool) Value {\n\tif writable && enumerable && configurable {\n\t\treturn value\n\t}\n\treturn &valueProperty{\n\t\tvalue:        value,\n\t\twritable:     writable,\n\t\tenumerable:   enumerable,\n\t\tconfigurable: configurable,\n\t}\n}\n\nfunc (o *baseObject) _putProp(name unistring.String, value Value, writable, enumerable, configurable bool) Value {\n\tprop := valueProp(value, writable, enumerable, configurable)\n\to._put(name, prop)\n\treturn prop\n}\n\nfunc (o *baseObject) _putSym(s *Symbol, prop Value) {\n\tif o.symValues == nil {\n\t\to.symValues = newOrderedMap(nil)\n\t}\n\to.symValues.set(s, prop)\n}\n\nfunc (o *baseObject) getPrivateEnv(typ *privateEnvType, create bool) *privateElements {\n\tenv := o.privateElements[typ]\n\tif env != nil && create {\n\t\tpanic(o.val.runtime.NewTypeError(\"Private fields for the class have already been set\"))\n\t}\n\tif env == nil && create {\n\t\tenv = &privateElements{\n\t\t\tfields: make([]Value, typ.numFields),\n\t\t}\n\t\tif o.privateElements == nil {\n\t\t\to.privateElements = make(map[*privateEnvType]*privateElements)\n\t\t}\n\t\to.privateElements[typ] = env\n\t}\n\treturn env\n}\n\nfunc (o *Object) tryPrimitive(methodName unistring.String) Value {\n\tif method, ok := o.self.getStr(methodName, nil).(*Object); ok {\n\t\tif call, ok := method.self.assertCallable(); ok {\n\t\t\tv := call(FunctionCall{\n\t\t\t\tThis: o,\n\t\t\t})\n\t\t\tif _, fail := v.(*Object); !fail {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (o *Object) ordinaryToPrimitiveNumber() Value {\n\tif v := o.tryPrimitive(\"valueOf\"); v != nil {\n\t\treturn v\n\t}\n\n\tif v := o.tryPrimitive(\"toString\"); v != nil {\n\t\treturn v\n\t}\n\n\tpanic(o.runtime.NewTypeError(\"Could not convert %v to primitive\", o.self))\n}\n\nfunc (o *Object) ordinaryToPrimitiveString() Value {\n\tif v := o.tryPrimitive(\"toString\"); v != nil {\n\t\treturn v\n\t}\n\n\tif v := o.tryPrimitive(\"valueOf\"); v != nil {\n\t\treturn v\n\t}\n\n\tpanic(o.runtime.NewTypeError(\"Could not convert %v (%T) to primitive\", o.self, o.self))\n}\n\nfunc (o *Object) tryExoticToPrimitive(hint Value) Value {\n\texoticToPrimitive := toMethod(o.self.getSym(SymToPrimitive, nil))\n\tif exoticToPrimitive != nil {\n\t\tret := exoticToPrimitive(FunctionCall{\n\t\t\tThis:      o,\n\t\t\tArguments: []Value{hint},\n\t\t})\n\t\tif _, fail := ret.(*Object); !fail {\n\t\t\treturn ret\n\t\t}\n\t\tpanic(o.runtime.NewTypeError(\"Cannot convert object to primitive value\"))\n\t}\n\treturn nil\n}\n\nfunc (o *Object) toPrimitiveNumber() Value {\n\tif v := o.tryExoticToPrimitive(hintNumber); v != nil {\n\t\treturn v\n\t}\n\n\treturn o.ordinaryToPrimitiveNumber()\n}\n\nfunc (o *Object) toPrimitiveString() Value {\n\tif v := o.tryExoticToPrimitive(hintString); v != nil {\n\t\treturn v\n\t}\n\n\treturn o.ordinaryToPrimitiveString()\n}\n\nfunc (o *Object) toPrimitive() Value {\n\tif v := o.tryExoticToPrimitive(hintDefault); v != nil {\n\t\treturn v\n\t}\n\treturn o.ordinaryToPrimitiveNumber()\n}\n\nfunc (o *baseObject) assertCallable() (func(FunctionCall) Value, bool) {\n\treturn nil, false\n}\n\nfunc (o *baseObject) vmCall(vm *vm, _ int) {\n\tpanic(vm.r.NewTypeError(\"Not a function: %s\", o.val.toString()))\n}\n\nfunc (o *baseObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn nil\n}\n\nfunc (o *baseObject) proto() *Object {\n\treturn o.prototype\n}\n\nfunc (o *baseObject) isExtensible() bool {\n\treturn o.extensible\n}\n\nfunc (o *baseObject) preventExtensions(bool) bool {\n\to.extensible = false\n\treturn true\n}\n\nfunc (o *baseObject) sortLen() int {\n\treturn toIntStrict(toLength(o.val.self.getStr(\"length\", nil)))\n}\n\nfunc (o *baseObject) sortGet(i int) Value {\n\treturn o.val.self.getIdx(valueInt(i), nil)\n}\n\nfunc (o *baseObject) swap(i int, j int) {\n\tii := valueInt(i)\n\tjj := valueInt(j)\n\n\tx := o.val.self.getIdx(ii, nil)\n\ty := o.val.self.getIdx(jj, nil)\n\n\to.val.self.setOwnIdx(ii, y, false)\n\to.val.self.setOwnIdx(jj, x, false)\n}\n\nfunc (o *baseObject) export(ctx *objectExportCtx) interface{} {\n\tif v, exists := ctx.get(o.val); exists {\n\t\treturn v\n\t}\n\tkeys := o.stringKeys(false, nil)\n\tm := make(map[string]interface{}, len(keys))\n\tctx.put(o.val, m)\n\tfor _, itemName := range keys {\n\t\titemNameStr := itemName.String()\n\t\tv := o.val.self.getStr(itemName.string(), nil)\n\t\tif v != nil {\n\t\t\tm[itemNameStr] = exportValue(v, ctx)\n\t\t} else {\n\t\t\tm[itemNameStr] = nil\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc (o *baseObject) exportType() reflect.Type {\n\treturn reflectTypeMap\n}\n\nfunc genericExportToMap(o *Object, dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tdst.Set(reflect.MakeMap(typ))\n\tctx.putTyped(o, typ, dst.Interface())\n\tkeyTyp := typ.Key()\n\telemTyp := typ.Elem()\n\tneedConvertKeys := !reflectTypeString.AssignableTo(keyTyp)\n\titer := &enumerableIter{\n\t\to:       o,\n\t\twrapped: o.self.iterateStringKeys(),\n\t}\n\tr := o.runtime\n\tfor item, next := iter.next(); next != nil; item, next = next() {\n\t\tvar kv reflect.Value\n\t\tvar err error\n\t\tif needConvertKeys {\n\t\t\tkv = reflect.New(keyTyp).Elem()\n\t\t\terr = r.toReflectValue(item.name, kv, ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not convert map key %s to %v: %w\", item.name.String(), typ, err)\n\t\t\t}\n\t\t} else {\n\t\t\tkv = reflect.ValueOf(item.name.String())\n\t\t}\n\n\t\tival := o.self.getStr(item.name.string(), nil)\n\t\tif ival != nil {\n\t\t\tvv := reflect.New(elemTyp).Elem()\n\t\t\terr = r.toReflectValue(ival, vv, ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not convert map value %v to %v at key %s: %w\", ival, typ, item.name.String(), err)\n\t\t\t}\n\t\t\tdst.SetMapIndex(kv, vv)\n\t\t} else {\n\t\t\tdst.SetMapIndex(kv, reflect.Zero(elemTyp))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (o *baseObject) exportToMap(m reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn genericExportToMap(o.val, m, typ, ctx)\n}\n\nfunc genericExportToArrayOrSlice(o *Object, dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) (err error) {\n\tr := o.runtime\n\n\tif method := toMethod(r.getV(o, SymIterator)); method != nil {\n\t\t// iterable\n\n\t\tvar values []Value\n\t\t// cannot change (append to) the slice once it's been put into the cache, so we need to know its length beforehand\n\t\tex := r.try(func() {\n\t\t\tvalues = r.iterableToList(o, method)\n\t\t})\n\t\tif ex != nil {\n\t\t\treturn ex\n\t\t}\n\t\tif typ.Kind() == reflect.Array {\n\t\t\tif dst.Len() != len(values) {\n\t\t\t\treturn fmt.Errorf(\"cannot convert an iterable into an array, lengths mismatch (have %d, need %d)\", len(values), dst.Len())\n\t\t\t}\n\t\t} else {\n\t\t\tdst.Set(reflect.MakeSlice(typ, len(values), len(values)))\n\t\t}\n\t\tctx.putTyped(o, typ, dst.Interface())\n\t\tfor i, val := range values {\n\t\t\terr = r.toReflectValue(val, dst.Index(i), ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// array-like\n\t\tvar lp Value\n\t\tif _, ok := o.self.assertCallable(); !ok {\n\t\t\tlp = o.self.getStr(\"length\", nil)\n\t\t}\n\t\tif lp == nil {\n\t\t\treturn fmt.Errorf(\"cannot convert %v to %v: not an array or iterable\", o, typ)\n\t\t}\n\t\tl := toIntStrict(toLength(lp))\n\t\tif dst.Len() != l {\n\t\t\tif typ.Kind() == reflect.Array {\n\t\t\t\treturn fmt.Errorf(\"cannot convert an array-like object into an array, lengths mismatch (have %d, need %d)\", l, dst.Len())\n\t\t\t} else {\n\t\t\t\tdst.Set(reflect.MakeSlice(typ, l, l))\n\t\t\t}\n\t\t}\n\t\tctx.putTyped(o, typ, dst.Interface())\n\t\tfor i := 0; i < l; i++ {\n\t\t\tval := nilSafe(o.self.getIdx(valueInt(i), nil))\n\t\t\terr = r.toReflectValue(val, dst.Index(i), ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (o *baseObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn genericExportToArrayOrSlice(o.val, dst, typ, ctx)\n}\n\ntype enumerableFlag int\n\nconst (\n\t_ENUM_UNKNOWN enumerableFlag = iota\n\t_ENUM_FALSE\n\t_ENUM_TRUE\n)\n\ntype propIterItem struct {\n\tname       Value\n\tvalue      Value\n\tenumerable enumerableFlag\n}\n\ntype objectPropIter struct {\n\to         *baseObject\n\tpropNames []unistring.String\n\tidx       int\n}\n\ntype recursivePropIter struct {\n\to    objectImpl\n\tcur  iterNextFunc\n\tseen map[unistring.String]struct{}\n}\n\ntype enumerableIter struct {\n\to       *Object\n\twrapped iterNextFunc\n}\n\nfunc (i *enumerableIter) next() (propIterItem, iterNextFunc) {\n\tfor {\n\t\tvar item propIterItem\n\t\titem, i.wrapped = i.wrapped()\n\t\tif i.wrapped == nil {\n\t\t\treturn item, nil\n\t\t}\n\t\tif item.enumerable == _ENUM_FALSE {\n\t\t\tcontinue\n\t\t}\n\t\tif item.enumerable == _ENUM_UNKNOWN {\n\t\t\tvar prop Value\n\t\t\tif item.value == nil {\n\t\t\t\tprop = i.o.getOwnProp(item.name)\n\t\t\t} else {\n\t\t\t\tprop = item.value\n\t\t\t}\n\t\t\tif prop == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif prop, ok := prop.(*valueProperty); ok {\n\t\t\t\tif !prop.enumerable {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn item, i.next\n\t}\n}\n\nfunc (i *recursivePropIter) next() (propIterItem, iterNextFunc) {\n\tfor {\n\t\tvar item propIterItem\n\t\titem, i.cur = i.cur()\n\t\tif i.cur == nil {\n\t\t\tif proto := i.o.proto(); proto != nil {\n\t\t\t\ti.cur = proto.self.iterateStringKeys()\n\t\t\t\ti.o = proto.self\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn propIterItem{}, nil\n\t\t}\n\t\tname := item.name.string()\n\t\tif _, exists := i.seen[name]; !exists {\n\t\t\ti.seen[name] = struct{}{}\n\t\t\treturn item, i.next\n\t\t}\n\t}\n}\n\nfunc enumerateRecursive(o *Object) iterNextFunc {\n\treturn (&enumerableIter{\n\t\to: o,\n\t\twrapped: (&recursivePropIter{\n\t\t\to:    o.self,\n\t\t\tcur:  o.self.iterateStringKeys(),\n\t\t\tseen: make(map[unistring.String]struct{}),\n\t\t}).next,\n\t}).next\n}\n\nfunc (i *objectPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.propNames) {\n\t\tname := i.propNames[i.idx]\n\t\ti.idx++\n\t\tprop := i.o.values[name]\n\t\tif prop != nil {\n\t\t\treturn propIterItem{name: stringValueFromRaw(name), value: prop}, i.next\n\t\t}\n\t}\n\tclearNamesCopyMarker(i.propNames)\n\treturn propIterItem{}, nil\n}\n\nvar copyMarker = unistring.String(\" \")\n\n// Set a copy-on-write flag so that any subsequent modifications of anything below the current length\n// trigger a copy.\n// The marker is a special value put at the index position of cap-1. Capacity is set so that the marker is\n// beyond the current length (therefore invisible to normal slice operations).\n// This function is called before an iteration begins to avoid copying of the names array if\n// there are no modifications within the iteration.\n// Note that the copying also occurs in two cases: nested iterations (on the same object) and\n// iterations after a previously abandoned iteration (because there is currently no mechanism to close an\n// iterator). It is still better than copying every time.\nfunc prepareNamesForCopy(names []unistring.String) []unistring.String {\n\tif len(names) == 0 {\n\t\treturn names\n\t}\n\tif namesMarkedForCopy(names) || cap(names) == len(names) {\n\t\tvar newcap int\n\t\tif cap(names) == len(names) {\n\t\t\tnewcap = growCap(len(names)+1, len(names), cap(names))\n\t\t} else {\n\t\t\tnewcap = cap(names)\n\t\t}\n\t\tnewNames := make([]unistring.String, len(names), newcap)\n\t\tcopy(newNames, names)\n\t\tnames = newNames\n\t}\n\tnames[cap(names)-1 : cap(names)][0] = copyMarker\n\treturn names\n}\n\nfunc namesMarkedForCopy(names []unistring.String) bool {\n\treturn cap(names) > len(names) && names[cap(names)-1 : cap(names)][0] == copyMarker\n}\n\nfunc clearNamesCopyMarker(names []unistring.String) {\n\tif cap(names) > len(names) {\n\t\tnames[cap(names)-1 : cap(names)][0] = \"\"\n\t}\n}\n\nfunc copyNamesIfNeeded(names []unistring.String, extraCap int) []unistring.String {\n\tif namesMarkedForCopy(names) && len(names)+extraCap >= cap(names) {\n\t\tvar newcap int\n\t\tnewsize := len(names) + extraCap + 1\n\t\tif newsize > cap(names) {\n\t\t\tnewcap = growCap(newsize, len(names), cap(names))\n\t\t} else {\n\t\t\tnewcap = cap(names)\n\t\t}\n\t\tnewNames := make([]unistring.String, len(names), newcap)\n\t\tcopy(newNames, names)\n\t\treturn newNames\n\t}\n\treturn names\n}\n\nfunc (o *baseObject) iterateStringKeys() iterNextFunc {\n\to.ensurePropOrder()\n\tpropNames := prepareNamesForCopy(o.propNames)\n\to.propNames = propNames\n\treturn (&objectPropIter{\n\t\to:         o,\n\t\tpropNames: propNames,\n\t}).next\n}\n\ntype objectSymbolIter struct {\n\titer *orderedMapIter\n}\n\nfunc (i *objectSymbolIter) next() (propIterItem, iterNextFunc) {\n\tentry := i.iter.next()\n\tif entry != nil {\n\t\treturn propIterItem{\n\t\t\tname:  entry.key,\n\t\t\tvalue: entry.value,\n\t\t}, i.next\n\t}\n\treturn propIterItem{}, nil\n}\n\nfunc (o *baseObject) iterateSymbols() iterNextFunc {\n\tif o.symValues != nil {\n\t\treturn (&objectSymbolIter{\n\t\t\titer: o.symValues.newIter(),\n\t\t}).next\n\t}\n\treturn func() (propIterItem, iterNextFunc) {\n\t\treturn propIterItem{}, nil\n\t}\n}\n\ntype objectAllPropIter struct {\n\to      *Object\n\tcurStr iterNextFunc\n}\n\nfunc (i *objectAllPropIter) next() (propIterItem, iterNextFunc) {\n\titem, next := i.curStr()\n\tif next != nil {\n\t\ti.curStr = next\n\t\treturn item, i.next\n\t}\n\treturn i.o.self.iterateSymbols()()\n}\n\nfunc (o *baseObject) iterateKeys() iterNextFunc {\n\treturn (&objectAllPropIter{\n\t\to:      o.val,\n\t\tcurStr: o.val.self.iterateStringKeys(),\n\t}).next\n}\n\nfunc (o *baseObject) equal(objectImpl) bool {\n\t// Rely on parent reference comparison\n\treturn false\n}\n\n// hopefully this gets inlined\nfunc (o *baseObject) ensurePropOrder() {\n\tif o.lastSortedPropLen < len(o.propNames) {\n\t\to.fixPropOrder()\n\t}\n}\n\n// Reorder property names so that any integer properties are shifted to the beginning of the list\n// in ascending order. This is to conform to https://262.ecma-international.org/#sec-ordinaryownpropertykeys.\n// Personally I think this requirement is strange. I can sort of understand where they are coming from,\n// this way arrays can be specified just as objects with a 'magic' length property. However, I think\n// it's safe to assume most devs don't use Objects to store integer properties. Therefore, performing\n// property type checks when adding (and potentially looking up) properties would be unreasonable.\n// Instead, we keep insertion order and only change it when (if) the properties get enumerated.\nfunc (o *baseObject) fixPropOrder() {\n\tnames := o.propNames\n\tfor i := o.lastSortedPropLen; i < len(names); i++ {\n\t\tname := names[i]\n\t\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\t\tk := sort.Search(o.idxPropCount, func(j int) bool {\n\t\t\t\treturn strToArrayIdx(names[j]) >= idx\n\t\t\t})\n\t\t\tif k < i {\n\t\t\t\tif namesMarkedForCopy(names) {\n\t\t\t\t\tnewNames := make([]unistring.String, len(names), cap(names))\n\t\t\t\t\tcopy(newNames[:k], names)\n\t\t\t\t\tcopy(newNames[k+1:i+1], names[k:i])\n\t\t\t\t\tcopy(newNames[i+1:], names[i+1:])\n\t\t\t\t\tnames = newNames\n\t\t\t\t\to.propNames = names\n\t\t\t\t} else {\n\t\t\t\t\tcopy(names[k+1:i+1], names[k:i])\n\t\t\t\t}\n\t\t\t\tnames[k] = name\n\t\t\t}\n\t\t\to.idxPropCount++\n\t\t}\n\t}\n\to.lastSortedPropLen = len(names)\n}\n\nfunc (o *baseObject) stringKeys(all bool, keys []Value) []Value {\n\to.ensurePropOrder()\n\tif all {\n\t\tfor _, k := range o.propNames {\n\t\t\tkeys = append(keys, stringValueFromRaw(k))\n\t\t}\n\t} else {\n\t\tfor _, k := range o.propNames {\n\t\t\tprop := o.values[k]\n\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.enumerable {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tkeys = append(keys, stringValueFromRaw(k))\n\t\t}\n\t}\n\treturn keys\n}\n\nfunc (o *baseObject) symbols(all bool, accum []Value) []Value {\n\tif o.symValues != nil {\n\t\titer := o.symValues.newIter()\n\t\tif all {\n\t\t\tfor {\n\t\t\t\tentry := iter.next()\n\t\t\t\tif entry == nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\taccum = append(accum, entry.key)\n\t\t\t}\n\t\t} else {\n\t\t\tfor {\n\t\t\t\tentry := iter.next()\n\t\t\t\tif entry == nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif prop, ok := entry.value.(*valueProperty); ok {\n\t\t\t\t\tif !prop.enumerable {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccum = append(accum, entry.key)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn accum\n}\n\nfunc (o *baseObject) keys(all bool, accum []Value) []Value {\n\treturn o.symbols(all, o.val.self.stringKeys(all, accum))\n}\n\nfunc (o *baseObject) hasInstance(Value) bool {\n\tpanic(o.val.runtime.NewTypeError(\"Expecting a function in instanceof check, but got %s\", o.val.toString()))\n}\n\nfunc toMethod(v Value) func(FunctionCall) Value {\n\tif v == nil || IsUndefined(v) || IsNull(v) {\n\t\treturn nil\n\t}\n\tif obj, ok := v.(*Object); ok {\n\t\tif call, ok := obj.self.assertCallable(); ok {\n\t\t\treturn call\n\t\t}\n\t}\n\tpanic(newTypeError(\"%s is not a method\", v.String()))\n}\n\nfunc instanceOfOperator(o Value, c *Object) bool {\n\tif instOfHandler := toMethod(c.self.getSym(SymHasInstance, c)); instOfHandler != nil {\n\t\treturn instOfHandler(FunctionCall{\n\t\t\tThis:      c,\n\t\t\tArguments: []Value{o},\n\t\t}).ToBoolean()\n\t}\n\n\treturn c.self.hasInstance(o)\n}\n\nfunc (o *Object) get(p Value, receiver Value) Value {\n\tswitch p := p.(type) {\n\tcase valueInt:\n\t\treturn o.self.getIdx(p, receiver)\n\tcase *Symbol:\n\t\treturn o.self.getSym(p, receiver)\n\tdefault:\n\t\treturn o.self.getStr(p.string(), receiver)\n\t}\n}\n\nfunc (o *Object) getOwnProp(p Value) Value {\n\tswitch p := p.(type) {\n\tcase valueInt:\n\t\treturn o.self.getOwnPropIdx(p)\n\tcase *Symbol:\n\t\treturn o.self.getOwnPropSym(p)\n\tdefault:\n\t\treturn o.self.getOwnPropStr(p.string())\n\t}\n}\n\nfunc (o *Object) hasOwnProperty(p Value) bool {\n\tswitch p := p.(type) {\n\tcase valueInt:\n\t\treturn o.self.hasOwnPropertyIdx(p)\n\tcase *Symbol:\n\t\treturn o.self.hasOwnPropertySym(p)\n\tdefault:\n\t\treturn o.self.hasOwnPropertyStr(p.string())\n\t}\n}\n\nfunc (o *Object) hasProperty(p Value) bool {\n\tswitch p := p.(type) {\n\tcase valueInt:\n\t\treturn o.self.hasPropertyIdx(p)\n\tcase *Symbol:\n\t\treturn o.self.hasPropertySym(p)\n\tdefault:\n\t\treturn o.self.hasPropertyStr(p.string())\n\t}\n}\n\nfunc (o *Object) setStr(name unistring.String, val, receiver Value, throw bool) bool {\n\tif receiver == o {\n\t\treturn o.self.setOwnStr(name, val, throw)\n\t} else {\n\t\tif res, ok := o.self.setForeignStr(name, val, receiver, throw); !ok {\n\t\t\tif robj, ok := receiver.(*Object); ok {\n\t\t\t\tif prop := robj.self.getOwnPropStr(name); prop != nil {\n\t\t\t\t\tif desc, ok := prop.(*valueProperty); ok {\n\t\t\t\t\t\tif desc.accessor {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver property %s is an accessor\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !desc.writable {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn robj.self.defineOwnPropertyStr(name, PropertyDescriptor{Value: val}, throw)\n\t\t\t\t} else {\n\t\t\t\t\treturn robj.self.defineOwnPropertyStr(name, PropertyDescriptor{\n\t\t\t\t\t\tValue:        val,\n\t\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\t}, throw)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver is not an object: %v\", receiver)\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n}\n\nfunc (o *Object) set(name Value, val, receiver Value, throw bool) bool {\n\tswitch name := name.(type) {\n\tcase valueInt:\n\t\treturn o.setIdx(name, val, receiver, throw)\n\tcase *Symbol:\n\t\treturn o.setSym(name, val, receiver, throw)\n\tdefault:\n\t\treturn o.setStr(name.string(), val, receiver, throw)\n\t}\n}\n\nfunc (o *Object) setOwn(name Value, val Value, throw bool) bool {\n\tswitch name := name.(type) {\n\tcase valueInt:\n\t\treturn o.self.setOwnIdx(name, val, throw)\n\tcase *Symbol:\n\t\treturn o.self.setOwnSym(name, val, throw)\n\tdefault:\n\t\treturn o.self.setOwnStr(name.string(), val, throw)\n\t}\n}\n\nfunc (o *Object) setIdx(name valueInt, val, receiver Value, throw bool) bool {\n\tif receiver == o {\n\t\treturn o.self.setOwnIdx(name, val, throw)\n\t} else {\n\t\tif res, ok := o.self.setForeignIdx(name, val, receiver, throw); !ok {\n\t\t\tif robj, ok := receiver.(*Object); ok {\n\t\t\t\tif prop := robj.self.getOwnPropIdx(name); prop != nil {\n\t\t\t\t\tif desc, ok := prop.(*valueProperty); ok {\n\t\t\t\t\t\tif desc.accessor {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver property %s is an accessor\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !desc.writable {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trobj.self.defineOwnPropertyIdx(name, PropertyDescriptor{Value: val}, throw)\n\t\t\t\t} else {\n\t\t\t\t\trobj.self.defineOwnPropertyIdx(name, PropertyDescriptor{\n\t\t\t\t\t\tValue:        val,\n\t\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\t}, throw)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver is not an object: %v\", receiver)\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *Object) setSym(name *Symbol, val, receiver Value, throw bool) bool {\n\tif receiver == o {\n\t\treturn o.self.setOwnSym(name, val, throw)\n\t} else {\n\t\tif res, ok := o.self.setForeignSym(name, val, receiver, throw); !ok {\n\t\t\tif robj, ok := receiver.(*Object); ok {\n\t\t\t\tif prop := robj.self.getOwnPropSym(name); prop != nil {\n\t\t\t\t\tif desc, ok := prop.(*valueProperty); ok {\n\t\t\t\t\t\tif desc.accessor {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver property %s is an accessor\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !desc.writable {\n\t\t\t\t\t\t\to.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%s'\", name)\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trobj.self.defineOwnPropertySym(name, PropertyDescriptor{Value: val}, throw)\n\t\t\t\t} else {\n\t\t\t\t\trobj.self.defineOwnPropertySym(name, PropertyDescriptor{\n\t\t\t\t\t\tValue:        val,\n\t\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\t\tConfigurable: FLAG_TRUE,\n\t\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\t}, throw)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\to.runtime.typeErrorResult(throw, \"Receiver is not an object: %v\", receiver)\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *Object) delete(n Value, throw bool) bool {\n\tswitch n := n.(type) {\n\tcase valueInt:\n\t\treturn o.self.deleteIdx(n, throw)\n\tcase *Symbol:\n\t\treturn o.self.deleteSym(n, throw)\n\tdefault:\n\t\treturn o.self.deleteStr(n.string(), throw)\n\t}\n}\n\nfunc (o *Object) defineOwnProperty(n Value, desc PropertyDescriptor, throw bool) bool {\n\tswitch n := n.(type) {\n\tcase valueInt:\n\t\treturn o.self.defineOwnPropertyIdx(n, desc, throw)\n\tcase *Symbol:\n\t\treturn o.self.defineOwnPropertySym(n, desc, throw)\n\tdefault:\n\t\treturn o.self.defineOwnPropertyStr(n.string(), desc, throw)\n\t}\n}\n\nfunc (o *Object) getWeakRefs() map[weakMap]Value {\n\trefs := o.weakRefs\n\tif refs == nil {\n\t\trefs = make(map[weakMap]Value)\n\t\to.weakRefs = refs\n\t}\n\treturn refs\n}\n\nfunc (o *Object) getId() uint64 {\n\tid := o.id\n\tif id == 0 {\n\t\tid = o.runtime.genId()\n\t\to.id = id\n\t}\n\treturn id\n}\n\nfunc (o *guardedObject) guard(props ...unistring.String) {\n\tif o.guardedProps == nil {\n\t\to.guardedProps = make(map[unistring.String]struct{})\n\t}\n\tfor _, p := range props {\n\t\to.guardedProps[p] = struct{}{}\n\t}\n}\n\nfunc (o *guardedObject) check(p unistring.String) {\n\tif _, exists := o.guardedProps[p]; exists {\n\t\to.val.self = &o.baseObject\n\t}\n}\n\nfunc (o *guardedObject) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\tres := o.baseObject.setOwnStr(p, v, throw)\n\tif res {\n\t\to.check(p)\n\t}\n\treturn res\n}\n\nfunc (o *guardedObject) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tres := o.baseObject.defineOwnPropertyStr(name, desc, throw)\n\tif res {\n\t\to.check(name)\n\t}\n\treturn res\n}\n\nfunc (o *guardedObject) deleteStr(name unistring.String, throw bool) bool {\n\tres := o.baseObject.deleteStr(name, throw)\n\tif res {\n\t\to.check(name)\n\t}\n\treturn res\n}\n\nfunc (ctx *objectExportCtx) get(key *Object) (interface{}, bool) {\n\tif v, exists := ctx.cache[key]; exists {\n\t\tif item, ok := v.(objectExportCacheItem); ok {\n\t\t\tr, exists := item[key.self.exportType()]\n\t\t\treturn r, exists\n\t\t} else {\n\t\t\treturn v, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (ctx *objectExportCtx) getTyped(key *Object, typ reflect.Type) (interface{}, bool) {\n\tif v, exists := ctx.cache[key]; exists {\n\t\tif item, ok := v.(objectExportCacheItem); ok {\n\t\t\tr, exists := item[typ]\n\t\t\treturn r, exists\n\t\t} else {\n\t\t\tif reflect.TypeOf(v) == typ {\n\t\t\t\treturn v, true\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (ctx *objectExportCtx) put(key *Object, value interface{}) {\n\tif ctx.cache == nil {\n\t\tctx.cache = make(map[*Object]interface{})\n\t}\n\tif item, ok := ctx.cache[key].(objectExportCacheItem); ok {\n\t\titem[key.self.exportType()] = value\n\t} else {\n\t\tctx.cache[key] = value\n\t}\n}\n\nfunc (ctx *objectExportCtx) putTyped(key *Object, typ reflect.Type, value interface{}) {\n\tif ctx.cache == nil {\n\t\tctx.cache = make(map[*Object]interface{})\n\t}\n\tv, exists := ctx.cache[key]\n\tif exists {\n\t\tif item, ok := ctx.cache[key].(objectExportCacheItem); ok {\n\t\t\titem[typ] = value\n\t\t} else {\n\t\t\tm := make(objectExportCacheItem, 2)\n\t\t\tm[key.self.exportType()] = v\n\t\t\tm[typ] = value\n\t\t\tctx.cache[key] = m\n\t\t}\n\t} else {\n\t\tm := make(objectExportCacheItem)\n\t\tm[typ] = value\n\t\tctx.cache[key] = m\n\t}\n}\n\ntype enumPropertiesIter struct {\n\to       *Object\n\twrapped iterNextFunc\n}\n\nfunc (i *enumPropertiesIter) next() (propIterItem, iterNextFunc) {\n\tfor i.wrapped != nil {\n\t\titem, next := i.wrapped()\n\t\ti.wrapped = next\n\t\tif next == nil {\n\t\t\tbreak\n\t\t}\n\t\tif item.value == nil {\n\t\t\titem.value = i.o.get(item.name, nil)\n\t\t\tif item.value == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\tif prop, ok := item.value.(*valueProperty); ok {\n\t\t\t\titem.value = prop.get(i.o)\n\t\t\t}\n\t\t}\n\t\treturn item, i.next\n\t}\n\treturn propIterItem{}, nil\n}\n\nfunc iterateEnumerableProperties(o *Object) iterNextFunc {\n\treturn (&enumPropertiesIter{\n\t\to: o,\n\t\twrapped: (&enumerableIter{\n\t\t\to:       o,\n\t\t\twrapped: o.self.iterateKeys(),\n\t\t}).next,\n\t}).next\n}\n\nfunc iterateEnumerableStringProperties(o *Object) iterNextFunc {\n\treturn (&enumPropertiesIter{\n\t\to: o,\n\t\twrapped: (&enumerableIter{\n\t\t\to:       o,\n\t\t\twrapped: o.self.iterateStringKeys(),\n\t\t}).next,\n\t}).next\n}\n\ntype privateId struct {\n\ttyp      *privateEnvType\n\tname     unistring.String\n\tidx      uint32\n\tisMethod bool\n}\n\ntype privateEnvType struct {\n\tnumFields, numMethods uint32\n}\n\ntype privateNames map[unistring.String]*privateId\n\ntype privateEnv struct {\n\tinstanceType, staticType *privateEnvType\n\n\tnames privateNames\n\n\touter *privateEnv\n}\n\ntype privateElements struct {\n\tmethods []Value\n\tfields  []Value\n}\n\nfunc (i *privateId) String() string {\n\treturn \"#\" + i.name.String()\n}\n\nfunc (i *privateId) string() unistring.String {\n\treturn privateIdString(i.name)\n}\n"
        },
        {
          "name": "object_args.go",
          "type": "blob",
          "size": 3.3134765625,
          "content": "package goja\n\nimport \"github.com/dop251/goja/unistring\"\n\ntype argumentsObject struct {\n\tbaseObject\n\tlength int\n}\n\ntype mappedProperty struct {\n\tvalueProperty\n\tv *Value\n}\n\nfunc (a *argumentsObject) getStr(name unistring.String, receiver Value) Value {\n\treturn a.getStrWithOwnProp(a.getOwnPropStr(name), name, receiver)\n}\n\nfunc (a *argumentsObject) getOwnPropStr(name unistring.String) Value {\n\tif mapped, ok := a.values[name].(*mappedProperty); ok {\n\t\tif mapped.writable && mapped.enumerable && mapped.configurable {\n\t\t\treturn *mapped.v\n\t\t}\n\t\treturn &valueProperty{\n\t\t\tvalue:        *mapped.v,\n\t\t\twritable:     mapped.writable,\n\t\t\tconfigurable: mapped.configurable,\n\t\t\tenumerable:   mapped.enumerable,\n\t\t}\n\t}\n\n\treturn a.baseObject.getOwnPropStr(name)\n}\n\nfunc (a *argumentsObject) init() {\n\ta.baseObject.init()\n\ta._putProp(\"length\", intToValue(int64(a.length)), true, false, true)\n}\n\nfunc (a *argumentsObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif prop, ok := a.values[name].(*mappedProperty); ok {\n\t\tif !prop.writable {\n\t\t\ta.val.runtime.typeErrorResult(throw, \"Property is not writable: %s\", name)\n\t\t\treturn false\n\t\t}\n\t\t*prop.v = val\n\t\treturn true\n\t}\n\treturn a.baseObject.setOwnStr(name, val, throw)\n}\n\nfunc (a *argumentsObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn a._setForeignStr(name, a.getOwnPropStr(name), val, receiver, throw)\n}\n\nfunc (a *argumentsObject) deleteStr(name unistring.String, throw bool) bool {\n\tif prop, ok := a.values[name].(*mappedProperty); ok {\n\t\tif !a.checkDeleteProp(name, &prop.valueProperty, throw) {\n\t\t\treturn false\n\t\t}\n\t\ta._delete(name)\n\t\treturn true\n\t}\n\n\treturn a.baseObject.deleteStr(name, throw)\n}\n\ntype argumentsPropIter struct {\n\twrapped iterNextFunc\n}\n\nfunc (i *argumentsPropIter) next() (propIterItem, iterNextFunc) {\n\tvar item propIterItem\n\titem, i.wrapped = i.wrapped()\n\tif i.wrapped == nil {\n\t\treturn propIterItem{}, nil\n\t}\n\tif prop, ok := item.value.(*mappedProperty); ok {\n\t\titem.value = *prop.v\n\t}\n\treturn item, i.next\n}\n\nfunc (a *argumentsObject) iterateStringKeys() iterNextFunc {\n\treturn (&argumentsPropIter{\n\t\twrapped: a.baseObject.iterateStringKeys(),\n\t}).next\n}\n\nfunc (a *argumentsObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif mapped, ok := a.values[name].(*mappedProperty); ok {\n\t\texisting := &valueProperty{\n\t\t\tconfigurable: mapped.configurable,\n\t\t\twritable:     true,\n\t\t\tenumerable:   mapped.enumerable,\n\t\t\tvalue:        *mapped.v,\n\t\t}\n\n\t\tval, ok := a.baseObject._defineOwnProperty(name, existing, descr, throw)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tif prop, ok := val.(*valueProperty); ok {\n\t\t\tif !prop.accessor {\n\t\t\t\t*mapped.v = prop.value\n\t\t\t}\n\t\t\tif prop.accessor || !prop.writable {\n\t\t\t\ta._put(name, prop)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tmapped.configurable = prop.configurable\n\t\t\tmapped.enumerable = prop.enumerable\n\t\t} else {\n\t\t\t*mapped.v = val\n\t\t\tmapped.configurable = true\n\t\t\tmapped.enumerable = true\n\t\t}\n\n\t\treturn true\n\t}\n\n\treturn a.baseObject.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (a *argumentsObject) export(ctx *objectExportCtx) interface{} {\n\tif v, exists := ctx.get(a.val); exists {\n\t\treturn v\n\t}\n\tarr := make([]interface{}, a.length)\n\tctx.put(a.val, arr)\n\tfor i := range arr {\n\t\tv := a.getIdx(valueInt(int64(i)), nil)\n\t\tif v != nil {\n\t\t\tarr[i] = exportValue(v, ctx)\n\t\t}\n\t}\n\treturn arr\n}\n"
        },
        {
          "name": "object_dynamic.go",
          "type": "blob",
          "size": 21.267578125,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\n/*\nDynamicObject is an interface representing a handler for a dynamic Object. Such an object can be created\nusing the Runtime.NewDynamicObject() method.\n\nNote that Runtime.ToValue() does not have any special treatment for DynamicObject. The only way to create\na dynamic object is by using the Runtime.NewDynamicObject() method. This is done deliberately to avoid\nsilent code breaks when this interface changes.\n*/\ntype DynamicObject interface {\n\t// Get a property value for the key. May return nil if the property does not exist.\n\tGet(key string) Value\n\t// Set a property value for the key. Return true if success, false otherwise.\n\tSet(key string, val Value) bool\n\t// Has should return true if and only if the property exists.\n\tHas(key string) bool\n\t// Delete the property for the key. Returns true on success (note, that includes missing property).\n\tDelete(key string) bool\n\t// Keys returns a list of all existing property keys. There are no checks for duplicates or to make sure\n\t// that the order conforms to https://262.ecma-international.org/#sec-ordinaryownpropertykeys\n\tKeys() []string\n}\n\n/*\nDynamicArray is an interface representing a handler for a dynamic array Object. Such an object can be created\nusing the Runtime.NewDynamicArray() method.\n\nAny integer property key or a string property key that can be parsed into an int value (including negative\nones) is treated as an index and passed to the trap methods of the DynamicArray. Note this is different from\nthe regular ECMAScript arrays which only support positive indexes up to 2^32-1.\n\nDynamicArray cannot be sparse, i.e. hasOwnProperty(num) will return true for num >= 0 && num < Len(). Deleting\nsuch a property is equivalent to setting it to undefined. Note that this creates a slight peculiarity because\nhasOwnProperty() will still return true, even after deletion.\n\nNote that Runtime.ToValue() does not have any special treatment for DynamicArray. The only way to create\na dynamic array is by using the Runtime.NewDynamicArray() method. This is done deliberately to avoid\nsilent code breaks when this interface changes.\n*/\ntype DynamicArray interface {\n\t// Len returns the current array length.\n\tLen() int\n\t// Get an item at index idx. Note that idx may be any integer, negative or beyond the current length.\n\tGet(idx int) Value\n\t// Set an item at index idx. Note that idx may be any integer, negative or beyond the current length.\n\t// The expected behaviour when it's beyond length is that the array's length is increased to accommodate\n\t// the item. All elements in the 'new' section of the array should be zeroed.\n\tSet(idx int, val Value) bool\n\t// SetLen is called when the array's 'length' property is changed. If the length is increased all elements in the\n\t// 'new' section of the array should be zeroed.\n\tSetLen(int) bool\n}\n\ntype baseDynamicObject struct {\n\tval       *Object\n\tprototype *Object\n}\n\ntype dynamicObject struct {\n\tbaseDynamicObject\n\td DynamicObject\n}\n\ntype dynamicArray struct {\n\tbaseDynamicObject\n\ta DynamicArray\n}\n\n/*\nNewDynamicObject creates an Object backed by the provided DynamicObject handler.\n\nAll properties of this Object are Writable, Enumerable and Configurable data properties. Any attempt to define\na property that does not conform to this will fail.\n\nThe Object is always extensible and cannot be made non-extensible. Object.preventExtensions() will fail.\n\nThe Object's prototype is initially set to Object.prototype, but can be changed using regular mechanisms\n(Object.SetPrototype() in Go or Object.setPrototypeOf() in JS).\n\nThe Object cannot have own Symbol properties, however its prototype can. If you need an iterator support for\nexample, you could create a regular object, set Symbol.iterator on that object and then use it as a\nprototype. See TestDynamicObjectCustomProto for more details.\n\nExport() returns the original DynamicObject.\n\nThis mechanism is similar to ECMAScript Proxy, however because all properties are enumerable and the object\nis always extensible there is no need for invariant checks which removes the need to have a target object and\nmakes it a lot more efficient.\n*/\nfunc (r *Runtime) NewDynamicObject(d DynamicObject) *Object {\n\tv := &Object{runtime: r}\n\to := &dynamicObject{\n\t\td: d,\n\t\tbaseDynamicObject: baseDynamicObject{\n\t\t\tval:       v,\n\t\t\tprototype: r.global.ObjectPrototype,\n\t\t},\n\t}\n\tv.self = o\n\treturn v\n}\n\n/*\nNewSharedDynamicObject is similar to Runtime.NewDynamicObject but the resulting Object can be shared across multiple\nRuntimes. The Object's prototype will be null. The provided DynamicObject must be goroutine-safe.\n*/\nfunc NewSharedDynamicObject(d DynamicObject) *Object {\n\tv := &Object{}\n\to := &dynamicObject{\n\t\td: d,\n\t\tbaseDynamicObject: baseDynamicObject{\n\t\t\tval: v,\n\t\t},\n\t}\n\tv.self = o\n\treturn v\n}\n\n/*\nNewDynamicArray creates an array Object backed by the provided DynamicArray handler.\nIt is similar to NewDynamicObject, the differences are:\n\n- the Object is an array (i.e. Array.isArray() will return true and it will have the length property).\n\n- the prototype will be initially set to Array.prototype.\n\n- the Object cannot have any own string properties except for the 'length'.\n*/\nfunc (r *Runtime) NewDynamicArray(a DynamicArray) *Object {\n\tv := &Object{runtime: r}\n\to := &dynamicArray{\n\t\ta: a,\n\t\tbaseDynamicObject: baseDynamicObject{\n\t\t\tval:       v,\n\t\t\tprototype: r.getArrayPrototype(),\n\t\t},\n\t}\n\tv.self = o\n\treturn v\n}\n\n/*\nNewSharedDynamicArray is similar to Runtime.NewDynamicArray but the resulting Object can be shared across multiple\nRuntimes. The Object's prototype will be null. If you need to run Array's methods on it, use Array.prototype.[...].call(a, ...).\nThe provided DynamicArray must be goroutine-safe.\n*/\nfunc NewSharedDynamicArray(a DynamicArray) *Object {\n\tv := &Object{}\n\to := &dynamicArray{\n\t\ta: a,\n\t\tbaseDynamicObject: baseDynamicObject{\n\t\t\tval: v,\n\t\t},\n\t}\n\tv.self = o\n\treturn v\n}\n\nfunc (*dynamicObject) sortLen() int {\n\treturn 0\n}\n\nfunc (*dynamicObject) sortGet(i int) Value {\n\treturn nil\n}\n\nfunc (*dynamicObject) swap(i int, i2 int) {\n}\n\nfunc (*dynamicObject) className() string {\n\treturn classObject\n}\n\nfunc (o *baseDynamicObject) getParentStr(p unistring.String, receiver Value) Value {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver == nil {\n\t\t\treturn proto.self.getStr(p, o.val)\n\t\t}\n\t\treturn proto.self.getStr(p, receiver)\n\t}\n\treturn nil\n}\n\nfunc (o *dynamicObject) getStr(p unistring.String, receiver Value) Value {\n\tprop := o.d.Get(p.String())\n\tif prop == nil {\n\t\treturn o.getParentStr(p, receiver)\n\t}\n\treturn prop\n}\n\nfunc (o *baseDynamicObject) getParentIdx(p valueInt, receiver Value) Value {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver == nil {\n\t\t\treturn proto.self.getIdx(p, o.val)\n\t\t}\n\t\treturn proto.self.getIdx(p, receiver)\n\t}\n\treturn nil\n}\n\nfunc (o *dynamicObject) getIdx(p valueInt, receiver Value) Value {\n\tprop := o.d.Get(p.String())\n\tif prop == nil {\n\t\treturn o.getParentIdx(p, receiver)\n\t}\n\treturn prop\n}\n\nfunc (o *baseDynamicObject) getSym(p *Symbol, receiver Value) Value {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver == nil {\n\t\t\treturn proto.self.getSym(p, o.val)\n\t\t}\n\t\treturn proto.self.getSym(p, receiver)\n\t}\n\treturn nil\n}\n\nfunc (o *dynamicObject) getOwnPropStr(u unistring.String) Value {\n\treturn o.d.Get(u.String())\n}\n\nfunc (o *dynamicObject) getOwnPropIdx(v valueInt) Value {\n\treturn o.d.Get(v.String())\n}\n\nfunc (*baseDynamicObject) getOwnPropSym(*Symbol) Value {\n\treturn nil\n}\n\nfunc (o *dynamicObject) _set(prop string, v Value, throw bool) bool {\n\tif o.d.Set(prop, v) {\n\t\treturn true\n\t}\n\ttypeErrorResult(throw, \"'Set' on a dynamic object returned false\")\n\treturn false\n}\n\nfunc (o *baseDynamicObject) _setSym(throw bool) {\n\ttypeErrorResult(throw, \"Dynamic objects do not support Symbol properties\")\n}\n\nfunc (o *dynamicObject) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\tprop := p.String()\n\tif !o.d.Has(prop) {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, handled := proto.self.setForeignStr(p, v, o.val, throw); handled {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t}\n\treturn o._set(prop, v, throw)\n}\n\nfunc (o *dynamicObject) setOwnIdx(p valueInt, v Value, throw bool) bool {\n\tprop := p.String()\n\tif !o.d.Has(prop) {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, handled := proto.self.setForeignIdx(p, v, o.val, throw); handled {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t}\n\treturn o._set(prop, v, throw)\n}\n\nfunc (o *baseDynamicObject) setOwnSym(s *Symbol, v Value, throw bool) bool {\n\tif proto := o.prototype; proto != nil {\n\t\t// we know it's foreign because prototype loops are not allowed\n\t\tif res, handled := proto.self.setForeignSym(s, v, o.val, throw); handled {\n\t\t\treturn res\n\t\t}\n\t}\n\to._setSym(throw)\n\treturn false\n}\n\nfunc (o *baseDynamicObject) setParentForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool) {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver != proto {\n\t\t\treturn proto.self.setForeignStr(p, v, receiver, throw)\n\t\t}\n\t\treturn proto.self.setOwnStr(p, v, throw), true\n\t}\n\treturn false, false\n}\n\nfunc (o *dynamicObject) setForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool) {\n\tprop := p.String()\n\tif !o.d.Has(prop) {\n\t\treturn o.setParentForeignStr(p, v, receiver, throw)\n\t}\n\treturn false, false\n}\n\nfunc (o *baseDynamicObject) setParentForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool) {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver != proto {\n\t\t\treturn proto.self.setForeignIdx(p, v, receiver, throw)\n\t\t}\n\t\treturn proto.self.setOwnIdx(p, v, throw), true\n\t}\n\treturn false, false\n}\n\nfunc (o *dynamicObject) setForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool) {\n\tprop := p.String()\n\tif !o.d.Has(prop) {\n\t\treturn o.setParentForeignIdx(p, v, receiver, throw)\n\t}\n\treturn false, false\n}\n\nfunc (o *baseDynamicObject) setForeignSym(p *Symbol, v, receiver Value, throw bool) (res bool, handled bool) {\n\tif proto := o.prototype; proto != nil {\n\t\tif receiver != proto {\n\t\t\treturn proto.self.setForeignSym(p, v, receiver, throw)\n\t\t}\n\t\treturn proto.self.setOwnSym(p, v, throw), true\n\t}\n\treturn false, false\n}\n\nfunc (o *dynamicObject) hasPropertyStr(u unistring.String) bool {\n\tif o.hasOwnPropertyStr(u) {\n\t\treturn true\n\t}\n\tif proto := o.prototype; proto != nil {\n\t\treturn proto.self.hasPropertyStr(u)\n\t}\n\treturn false\n}\n\nfunc (o *dynamicObject) hasPropertyIdx(idx valueInt) bool {\n\tif o.hasOwnPropertyIdx(idx) {\n\t\treturn true\n\t}\n\tif proto := o.prototype; proto != nil {\n\t\treturn proto.self.hasPropertyIdx(idx)\n\t}\n\treturn false\n}\n\nfunc (o *baseDynamicObject) hasPropertySym(s *Symbol) bool {\n\tif proto := o.prototype; proto != nil {\n\t\treturn proto.self.hasPropertySym(s)\n\t}\n\treturn false\n}\n\nfunc (o *dynamicObject) hasOwnPropertyStr(u unistring.String) bool {\n\treturn o.d.Has(u.String())\n}\n\nfunc (o *dynamicObject) hasOwnPropertyIdx(v valueInt) bool {\n\treturn o.d.Has(v.String())\n}\n\nfunc (*baseDynamicObject) hasOwnPropertySym(_ *Symbol) bool {\n\treturn false\n}\n\nfunc (o *baseDynamicObject) checkDynamicObjectPropertyDescr(name fmt.Stringer, descr PropertyDescriptor, throw bool) bool {\n\tif descr.Getter != nil || descr.Setter != nil {\n\t\ttypeErrorResult(throw, \"Dynamic objects do not support accessor properties\")\n\t\treturn false\n\t}\n\tif descr.Writable == FLAG_FALSE {\n\t\ttypeErrorResult(throw, \"Dynamic object field %q cannot be made read-only\", name.String())\n\t\treturn false\n\t}\n\tif descr.Enumerable == FLAG_FALSE {\n\t\ttypeErrorResult(throw, \"Dynamic object field %q cannot be made non-enumerable\", name.String())\n\t\treturn false\n\t}\n\tif descr.Configurable == FLAG_FALSE {\n\t\ttypeErrorResult(throw, \"Dynamic object field %q cannot be made non-configurable\", name.String())\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (o *dynamicObject) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tif o.checkDynamicObjectPropertyDescr(name, desc, throw) {\n\t\treturn o._set(name.String(), desc.Value, throw)\n\t}\n\treturn false\n}\n\nfunc (o *dynamicObject) defineOwnPropertyIdx(name valueInt, desc PropertyDescriptor, throw bool) bool {\n\tif o.checkDynamicObjectPropertyDescr(name, desc, throw) {\n\t\treturn o._set(name.String(), desc.Value, throw)\n\t}\n\treturn false\n}\n\nfunc (o *baseDynamicObject) defineOwnPropertySym(name *Symbol, desc PropertyDescriptor, throw bool) bool {\n\to._setSym(throw)\n\treturn false\n}\n\nfunc (o *dynamicObject) _delete(prop string, throw bool) bool {\n\tif o.d.Delete(prop) {\n\t\treturn true\n\t}\n\ttypeErrorResult(throw, \"Could not delete property %q of a dynamic object\", prop)\n\treturn false\n}\n\nfunc (o *dynamicObject) deleteStr(name unistring.String, throw bool) bool {\n\treturn o._delete(name.String(), throw)\n}\n\nfunc (o *dynamicObject) deleteIdx(idx valueInt, throw bool) bool {\n\treturn o._delete(idx.String(), throw)\n}\n\nfunc (*baseDynamicObject) deleteSym(_ *Symbol, _ bool) bool {\n\treturn true\n}\n\nfunc (o *baseDynamicObject) assertCallable() (call func(FunctionCall) Value, ok bool) {\n\treturn nil, false\n}\n\nfunc (o *baseDynamicObject) vmCall(vm *vm, n int) {\n\tpanic(vm.r.NewTypeError(\"Dynamic object is not callable\"))\n}\n\nfunc (*baseDynamicObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn nil\n}\n\nfunc (o *baseDynamicObject) proto() *Object {\n\treturn o.prototype\n}\n\nfunc (o *baseDynamicObject) setProto(proto *Object, throw bool) bool {\n\to.prototype = proto\n\treturn true\n}\n\nfunc (o *baseDynamicObject) hasInstance(v Value) bool {\n\tpanic(newTypeError(\"Expecting a function in instanceof check, but got a dynamic object\"))\n}\n\nfunc (*baseDynamicObject) isExtensible() bool {\n\treturn true\n}\n\nfunc (o *baseDynamicObject) preventExtensions(throw bool) bool {\n\ttypeErrorResult(throw, \"Cannot make a dynamic object non-extensible\")\n\treturn false\n}\n\ntype dynamicObjectPropIter struct {\n\to         *dynamicObject\n\tpropNames []string\n\tidx       int\n}\n\nfunc (i *dynamicObjectPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.propNames) {\n\t\tname := i.propNames[i.idx]\n\t\ti.idx++\n\t\tif i.o.d.Has(name) {\n\t\t\treturn propIterItem{name: newStringValue(name), enumerable: _ENUM_TRUE}, i.next\n\t\t}\n\t}\n\treturn propIterItem{}, nil\n}\n\nfunc (o *dynamicObject) iterateStringKeys() iterNextFunc {\n\tkeys := o.d.Keys()\n\treturn (&dynamicObjectPropIter{\n\t\to:         o,\n\t\tpropNames: keys,\n\t}).next\n}\n\nfunc (o *baseDynamicObject) iterateSymbols() iterNextFunc {\n\treturn func() (propIterItem, iterNextFunc) {\n\t\treturn propIterItem{}, nil\n\t}\n}\n\nfunc (o *dynamicObject) iterateKeys() iterNextFunc {\n\treturn o.iterateStringKeys()\n}\n\nfunc (o *dynamicObject) export(ctx *objectExportCtx) interface{} {\n\treturn o.d\n}\n\nfunc (o *dynamicObject) exportType() reflect.Type {\n\treturn reflect.TypeOf(o.d)\n}\n\nfunc (o *baseDynamicObject) exportToMap(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn genericExportToMap(o.val, dst, typ, ctx)\n}\n\nfunc (o *baseDynamicObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\treturn genericExportToArrayOrSlice(o.val, dst, typ, ctx)\n}\n\nfunc (o *dynamicObject) equal(impl objectImpl) bool {\n\tif other, ok := impl.(*dynamicObject); ok {\n\t\treturn o.d == other.d\n\t}\n\treturn false\n}\n\nfunc (o *dynamicObject) stringKeys(all bool, accum []Value) []Value {\n\tkeys := o.d.Keys()\n\tif l := len(accum) + len(keys); l > cap(accum) {\n\t\toldAccum := accum\n\t\taccum = make([]Value, len(accum), l)\n\t\tcopy(accum, oldAccum)\n\t}\n\tfor _, key := range keys {\n\t\taccum = append(accum, newStringValue(key))\n\t}\n\treturn accum\n}\n\nfunc (*baseDynamicObject) symbols(all bool, accum []Value) []Value {\n\treturn accum\n}\n\nfunc (o *dynamicObject) keys(all bool, accum []Value) []Value {\n\treturn o.stringKeys(all, accum)\n}\n\nfunc (*baseDynamicObject) _putProp(name unistring.String, value Value, writable, enumerable, configurable bool) Value {\n\treturn nil\n}\n\nfunc (*baseDynamicObject) _putSym(s *Symbol, prop Value) {\n}\n\nfunc (o *baseDynamicObject) getPrivateEnv(*privateEnvType, bool) *privateElements {\n\tpanic(newTypeError(\"Dynamic objects cannot have private elements\"))\n}\n\nfunc (o *baseDynamicObject) typeOf() String {\n\treturn stringObjectC\n}\n\nfunc (a *dynamicArray) sortLen() int {\n\treturn a.a.Len()\n}\n\nfunc (a *dynamicArray) sortGet(i int) Value {\n\treturn a.a.Get(i)\n}\n\nfunc (a *dynamicArray) swap(i int, j int) {\n\tx := a.sortGet(i)\n\ty := a.sortGet(j)\n\ta.a.Set(int(i), y)\n\ta.a.Set(int(j), x)\n}\n\nfunc (a *dynamicArray) className() string {\n\treturn classArray\n}\n\nfunc (a *dynamicArray) getStr(p unistring.String, receiver Value) Value {\n\tif p == \"length\" {\n\t\treturn intToValue(int64(a.a.Len()))\n\t}\n\tif idx, ok := strToInt(p); ok {\n\t\treturn a.a.Get(idx)\n\t}\n\treturn a.getParentStr(p, receiver)\n}\n\nfunc (a *dynamicArray) getIdx(p valueInt, receiver Value) Value {\n\tif val := a.getOwnPropIdx(p); val != nil {\n\t\treturn val\n\t}\n\treturn a.getParentIdx(p, receiver)\n}\n\nfunc (a *dynamicArray) getOwnPropStr(u unistring.String) Value {\n\tif u == \"length\" {\n\t\treturn &valueProperty{\n\t\t\tvalue:    intToValue(int64(a.a.Len())),\n\t\t\twritable: true,\n\t\t}\n\t}\n\tif idx, ok := strToInt(u); ok {\n\t\treturn a.a.Get(idx)\n\t}\n\treturn nil\n}\n\nfunc (a *dynamicArray) getOwnPropIdx(v valueInt) Value {\n\treturn a.a.Get(toIntStrict(int64(v)))\n}\n\nfunc (a *dynamicArray) _setLen(v Value, throw bool) bool {\n\tif a.a.SetLen(toIntStrict(v.ToInteger())) {\n\t\treturn true\n\t}\n\ttypeErrorResult(throw, \"'SetLen' on a dynamic array returned false\")\n\treturn false\n}\n\nfunc (a *dynamicArray) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\tif p == \"length\" {\n\t\treturn a._setLen(v, throw)\n\t}\n\tif idx, ok := strToInt(p); ok {\n\t\treturn a._setIdx(idx, v, throw)\n\t}\n\ttypeErrorResult(throw, \"Cannot set property %q on a dynamic array\", p.String())\n\treturn false\n}\n\nfunc (a *dynamicArray) _setIdx(idx int, v Value, throw bool) bool {\n\tif a.a.Set(idx, v) {\n\t\treturn true\n\t}\n\ttypeErrorResult(throw, \"'Set' on a dynamic array returned false\")\n\treturn false\n}\n\nfunc (a *dynamicArray) setOwnIdx(p valueInt, v Value, throw bool) bool {\n\treturn a._setIdx(toIntStrict(int64(p)), v, throw)\n}\n\nfunc (a *dynamicArray) setForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn a.setParentForeignStr(p, v, receiver, throw)\n}\n\nfunc (a *dynamicArray) setForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn a.setParentForeignIdx(p, v, receiver, throw)\n}\n\nfunc (a *dynamicArray) hasPropertyStr(u unistring.String) bool {\n\tif a.hasOwnPropertyStr(u) {\n\t\treturn true\n\t}\n\tif proto := a.prototype; proto != nil {\n\t\treturn proto.self.hasPropertyStr(u)\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) hasPropertyIdx(idx valueInt) bool {\n\tif a.hasOwnPropertyIdx(idx) {\n\t\treturn true\n\t}\n\tif proto := a.prototype; proto != nil {\n\t\treturn proto.self.hasPropertyIdx(idx)\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) _has(idx int) bool {\n\treturn idx >= 0 && idx < a.a.Len()\n}\n\nfunc (a *dynamicArray) hasOwnPropertyStr(u unistring.String) bool {\n\tif u == \"length\" {\n\t\treturn true\n\t}\n\tif idx, ok := strToInt(u); ok {\n\t\treturn a._has(idx)\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) hasOwnPropertyIdx(v valueInt) bool {\n\treturn a._has(toIntStrict(int64(v)))\n}\n\nfunc (a *dynamicArray) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tif a.checkDynamicObjectPropertyDescr(name, desc, throw) {\n\t\tif idx, ok := strToInt(name); ok {\n\t\t\treturn a._setIdx(idx, desc.Value, throw)\n\t\t}\n\t\ttypeErrorResult(throw, \"Cannot define property %q on a dynamic array\", name.String())\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) defineOwnPropertyIdx(name valueInt, desc PropertyDescriptor, throw bool) bool {\n\tif a.checkDynamicObjectPropertyDescr(name, desc, throw) {\n\t\treturn a._setIdx(toIntStrict(int64(name)), desc.Value, throw)\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) _delete(idx int, throw bool) bool {\n\tif a._has(idx) {\n\t\ta._setIdx(idx, _undefined, throw)\n\t}\n\treturn true\n}\n\nfunc (a *dynamicArray) deleteStr(name unistring.String, throw bool) bool {\n\tif idx, ok := strToInt(name); ok {\n\t\treturn a._delete(idx, throw)\n\t}\n\tif a.hasOwnPropertyStr(name) {\n\t\ttypeErrorResult(throw, \"Cannot delete property %q on a dynamic array\", name.String())\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (a *dynamicArray) deleteIdx(idx valueInt, throw bool) bool {\n\treturn a._delete(toIntStrict(int64(idx)), throw)\n}\n\ntype dynArrayPropIter struct {\n\ta          DynamicArray\n\tidx, limit int\n}\n\nfunc (i *dynArrayPropIter) next() (propIterItem, iterNextFunc) {\n\tif i.idx < i.limit && i.idx < i.a.Len() {\n\t\tname := strconv.Itoa(i.idx)\n\t\ti.idx++\n\t\treturn propIterItem{name: asciiString(name), enumerable: _ENUM_TRUE}, i.next\n\t}\n\n\treturn propIterItem{}, nil\n}\n\nfunc (a *dynamicArray) iterateStringKeys() iterNextFunc {\n\treturn (&dynArrayPropIter{\n\t\ta:     a.a,\n\t\tlimit: a.a.Len(),\n\t}).next\n}\n\nfunc (a *dynamicArray) iterateKeys() iterNextFunc {\n\treturn a.iterateStringKeys()\n}\n\nfunc (a *dynamicArray) export(ctx *objectExportCtx) interface{} {\n\treturn a.a\n}\n\nfunc (a *dynamicArray) exportType() reflect.Type {\n\treturn reflect.TypeOf(a.a)\n}\n\nfunc (a *dynamicArray) equal(impl objectImpl) bool {\n\tif other, ok := impl.(*dynamicArray); ok {\n\t\treturn a == other\n\t}\n\treturn false\n}\n\nfunc (a *dynamicArray) stringKeys(all bool, accum []Value) []Value {\n\tal := a.a.Len()\n\tl := len(accum) + al\n\tif all {\n\t\tl++\n\t}\n\tif l > cap(accum) {\n\t\toldAccum := accum\n\t\taccum = make([]Value, len(oldAccum), l)\n\t\tcopy(accum, oldAccum)\n\t}\n\tfor i := 0; i < al; i++ {\n\t\taccum = append(accum, asciiString(strconv.Itoa(i)))\n\t}\n\tif all {\n\t\taccum = append(accum, asciiString(\"length\"))\n\t}\n\treturn accum\n}\n\nfunc (a *dynamicArray) keys(all bool, accum []Value) []Value {\n\treturn a.stringKeys(all, accum)\n}\n"
        },
        {
          "name": "object_dynamic_test.go",
          "type": "blob",
          "size": 8.09375,
          "content": "package goja\n\nimport (\n\t\"sync\"\n\t\"testing\"\n)\n\ntype testDynObject struct {\n\tr *Runtime\n\tm map[string]Value\n}\n\nfunc (t *testDynObject) Get(key string) Value {\n\treturn t.m[key]\n}\n\nfunc (t *testDynObject) Set(key string, val Value) bool {\n\tt.m[key] = val\n\treturn true\n}\n\nfunc (t *testDynObject) Has(key string) bool {\n\t_, exists := t.m[key]\n\treturn exists\n}\n\nfunc (t *testDynObject) Delete(key string) bool {\n\tdelete(t.m, key)\n\treturn true\n}\n\nfunc (t *testDynObject) Keys() []string {\n\tkeys := make([]string, 0, len(t.m))\n\tfor k := range t.m {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\ntype testDynArray struct {\n\tr *Runtime\n\ta []Value\n}\n\nfunc (t *testDynArray) Len() int {\n\treturn len(t.a)\n}\n\nfunc (t *testDynArray) Get(idx int) Value {\n\tif idx < 0 {\n\t\tidx += len(t.a)\n\t}\n\tif idx >= 0 && idx < len(t.a) {\n\t\treturn t.a[idx]\n\t}\n\treturn nil\n}\n\nfunc (t *testDynArray) expand(newLen int) {\n\tif newLen > cap(t.a) {\n\t\ta := make([]Value, newLen)\n\t\tcopy(a, t.a)\n\t\tt.a = a\n\t} else {\n\t\tt.a = t.a[:newLen]\n\t}\n}\n\nfunc (t *testDynArray) Set(idx int, val Value) bool {\n\tif idx < 0 {\n\t\tidx += len(t.a)\n\t}\n\tif idx < 0 {\n\t\treturn false\n\t}\n\tif idx >= len(t.a) {\n\t\tt.expand(idx + 1)\n\t}\n\tt.a[idx] = val\n\treturn true\n}\n\nfunc (t *testDynArray) SetLen(i int) bool {\n\tif i > len(t.a) {\n\t\tt.expand(i)\n\t\treturn true\n\t}\n\tif i < 0 {\n\t\treturn false\n\t}\n\tif i < len(t.a) {\n\t\ttail := t.a[i:len(t.a)]\n\t\tfor j := range tail {\n\t\t\ttail[j] = nil\n\t\t}\n\t\tt.a = t.a[:i]\n\t}\n\treturn true\n}\n\nfunc TestDynamicObject(t *testing.T) {\n\tvm := New()\n\tdynObj := &testDynObject{\n\t\tr: vm,\n\t\tm: make(map[string]Value),\n\t}\n\to := vm.NewDynamicObject(dynObj)\n\tvm.Set(\"o\", o)\n\tvm.testScriptWithTestLibX(`\n\tassert(o instanceof Object, \"instanceof Object\");\n\tassert(o === o, \"self equality\");\n\tassert(o !== {}, \"non-equality\");\n\n\to.test = 42;\n\tassert(\"test\" in o, \"'test' in o\");\n\tassert(deepEqual(Object.getOwnPropertyDescriptor(o, \"test\"), {value: 42, writable: true, enumerable: true, configurable: true}), \"prop desc\");\n\n\tassert.throws(TypeError, function() {\n\t\t\"use strict\";\n\t\tObject.defineProperty(o, \"test1\", {value: 0, writable: false, enumerable: false, configurable: true});\n\t}, \"define prop\");\n\n\tvar keys = [];\n\tfor (var key in o) {\n\t\tkeys.push(key);\n\t}\n\tassert(compareArray(keys, [\"test\"]), \"for-in\");\n\n\tassert(delete o.test, \"delete\");\n\tassert(!(\"test\" in o), \"'test' in o after delete\");\n\n\tassert(\"__proto__\" in o, \"__proto__ in o\");\n\tassert.sameValue(o.__proto__, Object.prototype, \"__proto__\");\n\to.__proto__ = null;\n\tassert(!(\"__proto__\" in o), \"__proto__ in o after setting to null\");\n\t`, _undefined, t)\n}\n\nfunc TestDynamicObjectCustomProto(t *testing.T) {\n\tvm := New()\n\tm := make(map[string]Value)\n\tdynObj := &testDynObject{\n\t\tr: vm,\n\t\tm: m,\n\t}\n\to := vm.NewDynamicObject(dynObj)\n\tvm.Set(\"o\", o)\n\tvm.testScriptWithTestLib(`\n\tvar proto = {\n\t\tvalueOf: function() {\n\t\t\treturn this.num;\n\t\t}\n\t};\n\tproto[Symbol.toStringTag] = \"GoObject\";\n\tObject.setPrototypeOf(o, proto);\n\to.num = 41;\n\tassert(o instanceof Object, \"instanceof\");\n\tassert.sameValue(o+1, 42);\n\tassert.sameValue(o.toString(), \"[object GoObject]\");\n\t`, _undefined, t)\n\n\tif v := m[\"num\"]; v.Export() != int64(41) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestDynamicArray(t *testing.T) {\n\tvm := New()\n\tdynObj := &testDynArray{\n\t\tr: vm,\n\t}\n\ta := vm.NewDynamicArray(dynObj)\n\tvm.Set(\"a\", a)\n\tvm.testScriptWithTestLibX(`\n\tassert(a instanceof Array, \"instanceof Array\");\n\tassert(a instanceof Object, \"instanceof Object\");\n\tassert(a === a, \"self equality\");\n\tassert(a !== [], \"non-equality\");\n\tassert(Array.isArray(a), \"isArray()\");\n\tassert(\"length\" in a, \"length in a\");\n\tassert.sameValue(a.length, 0, \"len == 0\");\n\tassert.sameValue(a[0], undefined, \"a[0] (1)\");\n\n\ta[0] = 0;\n\tassert.sameValue(a[0], 0, \"a[0] (2)\");\n\tassert.sameValue(a.length, 1, \"length\");\n\tassert(deepEqual(Object.getOwnPropertyDescriptor(a, 0), {value: 0, writable: true, enumerable: true, configurable: true}), \"prop desc\");\n\tassert(deepEqual(Object.getOwnPropertyDescriptor(a, \"length\"), {value: 1, writable: true, enumerable: false, configurable: false}), \"length prop desc\");\n\n\tassert(\"__proto__\" in a, \"__proto__ in a\");\n\tassert.sameValue(a.__proto__, Array.prototype, \"__proto__\");\n\n\tassert(compareArray(Object.keys(a), [\"0\"]), \"Object.keys()\");\n\tassert(compareArray(Reflect.ownKeys(a), [\"0\", \"length\"]), \"Reflect.ownKeys()\");\n\n\ta.length = 2;\n\tassert.sameValue(a.length, 2, \"length after grow\");\n\tassert.sameValue(a[1], undefined, \"a[1]\");\n\n\ta[1] = 1;\n\tassert.sameValue(a[1], 1, \"a[1] after set\");\n\ta.length = 1;\n\tassert.sameValue(a.length, 1, \"length after shrink\");\n\tassert.sameValue(a[1], undefined, \"a[1] after shrink\");\n\ta.length = 2;\n\tassert.sameValue(a.length, 2, \"length after shrink and grow\");\n\tassert.sameValue(a[1], undefined, \"a[1] after grow\");\n\n\ta[0] = 3; a[1] = 1; a[2] = 2;\n\tassert.sameValue(a.length, 3);\n\tvar keys = [];\n\tfor (var key in a) {\n\t\tkeys.push(key);\n\t}\n\tassert(compareArray(keys, [\"0\",\"1\",\"2\"]), \"for-in\");\n\n\tvar vals = [];\n\tfor (var val of a) {\n\t\tvals.push(val);\n\t}\n\tassert(compareArray(vals, [3,1,2]), \"for-of\");\n\n\ta.sort();\n\tassert(compareArray(a, [1,2,3]), \"sort: \"+a);\n\n\tassert.sameValue(a[-1], 3);\n\tassert.sameValue(a[-4], undefined);\n\n\tassert.throws(TypeError, function() {\n\t\t\"use strict\";\n\t\tdelete a.length;\n\t}, \"delete length\");\n\n\tassert.throws(TypeError, function() {\n\t\t\"use strict\";\n\t\ta.test = true;\n\t}, \"set string prop\");\n\n\tassert.throws(TypeError, function() {\n\t\t\"use strict\";\n\t\tObject.defineProperty(a, 0, {value: 0, writable: false, enumerable: false, configurable: true});\n\t}, \"define prop\");\n\n\t`, _undefined, t)\n}\n\ntype testSharedDynObject struct {\n\tsync.RWMutex\n\tm map[string]Value\n}\n\nfunc (t *testSharedDynObject) Get(key string) Value {\n\tt.RLock()\n\tval := t.m[key]\n\tt.RUnlock()\n\treturn val\n}\n\nfunc (t *testSharedDynObject) Set(key string, val Value) bool {\n\tt.Lock()\n\tt.m[key] = val\n\tt.Unlock()\n\treturn true\n}\n\nfunc (t *testSharedDynObject) Has(key string) bool {\n\tt.RLock()\n\t_, exists := t.m[key]\n\tt.RUnlock()\n\treturn exists\n}\n\nfunc (t *testSharedDynObject) Delete(key string) bool {\n\tt.Lock()\n\tdelete(t.m, key)\n\tt.Unlock()\n\treturn true\n}\n\nfunc (t *testSharedDynObject) Keys() []string {\n\tt.RLock()\n\tkeys := make([]string, 0, len(t.m))\n\tfor k := range t.m {\n\t\tkeys = append(keys, k)\n\t}\n\tt.RUnlock()\n\treturn keys\n}\n\nfunc TestSharedDynamicObject(t *testing.T) {\n\tdynObj := &testSharedDynObject{m: make(map[string]Value, 10000)}\n\to := NewSharedDynamicObject(dynObj)\n\tch := make(chan error, 1)\n\tgo func() {\n\t\tvm := New()\n\t\tvm.Set(\"o\", o)\n\t\t_, err := vm.RunString(`\n\t\t\tfor (let i = 0; i < 10000; i++) {\n\t\t\t\to[i] = i;\n\t\t\t}\n\t\t`)\n\t\tch <- err\n\t}()\n\tvm := New()\n\tvm.Set(\"o\", o)\n\t_, err := vm.RunString(`\n\t\t\tfor (let i = 0; i < 10000; i++) {\n\t\t\t\to[i] = i+1;\n\t\t\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = <-ch\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype testSharedDynArray struct {\n\tsync.RWMutex\n\ta []Value\n}\n\nfunc (t *testSharedDynArray) Len() int {\n\tt.RLock()\n\tl := len(t.a)\n\tt.RUnlock()\n\treturn l\n}\n\nfunc (t *testSharedDynArray) Get(idx int) Value {\n\tt.RLock()\n\tdefer t.RUnlock()\n\tif idx < 0 {\n\t\tidx += len(t.a)\n\t}\n\tif idx >= 0 && idx < len(t.a) {\n\t\treturn t.a[idx]\n\t}\n\treturn nil\n}\n\nfunc (t *testSharedDynArray) expand(newLen int) {\n\tif newLen > cap(t.a) {\n\t\ta := make([]Value, newLen)\n\t\tcopy(a, t.a)\n\t\tt.a = a\n\t} else {\n\t\tt.a = t.a[:newLen]\n\t}\n}\n\nfunc (t *testSharedDynArray) Set(idx int, val Value) bool {\n\tt.Lock()\n\tdefer t.Unlock()\n\tif idx < 0 {\n\t\tidx += len(t.a)\n\t}\n\tif idx < 0 {\n\t\treturn false\n\t}\n\tif idx >= len(t.a) {\n\t\tt.expand(idx + 1)\n\t}\n\tt.a[idx] = val\n\treturn true\n}\n\nfunc (t *testSharedDynArray) SetLen(i int) bool {\n\tt.Lock()\n\tdefer t.Unlock()\n\tif i > len(t.a) {\n\t\tt.expand(i)\n\t\treturn true\n\t}\n\tif i < 0 {\n\t\treturn false\n\t}\n\tif i < len(t.a) {\n\t\ttail := t.a[i:len(t.a)]\n\t\tfor j := range tail {\n\t\t\ttail[j] = nil\n\t\t}\n\t\tt.a = t.a[:i]\n\t}\n\treturn true\n}\n\nfunc TestSharedDynamicArray(t *testing.T) {\n\tdynObj := &testSharedDynArray{a: make([]Value, 10000)}\n\to := NewSharedDynamicArray(dynObj)\n\tch := make(chan error, 1)\n\tgo func() {\n\t\tvm := New()\n\t\tvm.Set(\"o\", o)\n\t\t_, err := vm.RunString(`\n\t\t\tfor (let i = 0; i < 10000; i++) {\n\t\t\t\to[i] = i;\n\t\t\t}\n\t\t`)\n\t\tch <- err\n\t}()\n\tvm := New()\n\tvm.Set(\"o\", o)\n\t_, err := vm.RunString(`\n\t\t\tfor (let i = 0; i < 10000; i++) {\n\t\t\t\to[i] = i+1;\n\t\t\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = <-ch\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "object_goarray_reflect.go",
          "type": "blob",
          "size": 8.455078125,
          "content": "package goja\n\nimport (\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype objectGoArrayReflect struct {\n\tobjectGoReflect\n\tlengthProp valueProperty\n\n\tvalueCache valueArrayCache\n\n\tputIdx func(idx int, v Value, throw bool) bool\n}\n\ntype valueArrayCache []reflectValueWrapper\n\nfunc (c *valueArrayCache) get(idx int) reflectValueWrapper {\n\tif idx < len(*c) {\n\t\treturn (*c)[idx]\n\t}\n\treturn nil\n}\n\nfunc (c *valueArrayCache) grow(newlen int) {\n\toldcap := cap(*c)\n\tif oldcap < newlen {\n\t\ta := make([]reflectValueWrapper, newlen, growCap(newlen, len(*c), oldcap))\n\t\tcopy(a, *c)\n\t\t*c = a\n\t} else {\n\t\t*c = (*c)[:newlen]\n\t}\n}\n\nfunc (c *valueArrayCache) put(idx int, w reflectValueWrapper) {\n\tif len(*c) <= idx {\n\t\tc.grow(idx + 1)\n\t}\n\t(*c)[idx] = w\n}\n\nfunc (c *valueArrayCache) shrink(newlen int) {\n\tif len(*c) > newlen {\n\t\ttail := (*c)[newlen:]\n\t\tfor i, item := range tail {\n\t\t\tif item != nil {\n\t\t\t\tcopyReflectValueWrapper(item)\n\t\t\t\ttail[i] = nil\n\t\t\t}\n\t\t}\n\t\t*c = (*c)[:newlen]\n\t}\n}\n\nfunc (o *objectGoArrayReflect) _init() {\n\to.objectGoReflect.init()\n\to.class = classArray\n\to.prototype = o.val.runtime.getArrayPrototype()\n\to.baseObject._put(\"length\", &o.lengthProp)\n}\n\nfunc (o *objectGoArrayReflect) init() {\n\to._init()\n\to.updateLen()\n\to.putIdx = o._putIdx\n}\n\nfunc (o *objectGoArrayReflect) updateLen() {\n\to.lengthProp.value = intToValue(int64(o.fieldsValue.Len()))\n}\n\nfunc (o *objectGoArrayReflect) _hasIdx(idx valueInt) bool {\n\tif idx := int64(idx); idx >= 0 && idx < int64(o.fieldsValue.Len()) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoArrayReflect) _hasStr(name unistring.String) bool {\n\tif idx := strToIdx64(name); idx >= 0 && idx < int64(o.fieldsValue.Len()) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoArrayReflect) _getIdx(idx int) Value {\n\tif v := o.valueCache.get(idx); v != nil {\n\t\treturn v.esValue()\n\t}\n\n\tv := o.fieldsValue.Index(idx)\n\n\tres, w := o.elemToValue(v)\n\tif w != nil {\n\t\to.valueCache.put(idx, w)\n\t}\n\n\treturn res\n}\n\nfunc (o *objectGoArrayReflect) getIdx(idx valueInt, receiver Value) Value {\n\tif idx := toIntStrict(int64(idx)); idx >= 0 && idx < o.fieldsValue.Len() {\n\t\treturn o._getIdx(idx)\n\t}\n\treturn o.objectGoReflect.getStr(idx.string(), receiver)\n}\n\nfunc (o *objectGoArrayReflect) getStr(name unistring.String, receiver Value) Value {\n\tvar ownProp Value\n\tif idx := strToGoIdx(name); idx >= 0 && idx < o.fieldsValue.Len() {\n\t\townProp = o._getIdx(idx)\n\t} else if name == \"length\" {\n\t\tif o.fieldsValue.Kind() == reflect.Slice {\n\t\t\to.updateLen()\n\t\t}\n\t\townProp = &o.lengthProp\n\t} else {\n\t\townProp = o.objectGoReflect.getOwnPropStr(name)\n\t}\n\treturn o.getStrWithOwnProp(ownProp, name, receiver)\n}\n\nfunc (o *objectGoArrayReflect) getOwnPropStr(name unistring.String) Value {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif idx < o.fieldsValue.Len() {\n\t\t\treturn &valueProperty{\n\t\t\t\tvalue:      o._getIdx(idx),\n\t\t\t\twritable:   true,\n\t\t\t\tenumerable: true,\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif name == \"length\" {\n\t\tif o.fieldsValue.Kind() == reflect.Slice {\n\t\t\to.updateLen()\n\t\t}\n\t\treturn &o.lengthProp\n\t}\n\treturn o.objectGoReflect.getOwnPropStr(name)\n}\n\nfunc (o *objectGoArrayReflect) getOwnPropIdx(idx valueInt) Value {\n\tif idx := toIntStrict(int64(idx)); idx >= 0 && idx < o.fieldsValue.Len() {\n\t\treturn &valueProperty{\n\t\t\tvalue:      o._getIdx(idx),\n\t\t\twritable:   true,\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoArrayReflect) _putIdx(idx int, v Value, throw bool) bool {\n\tcached := o.valueCache.get(idx)\n\tif cached != nil {\n\t\tcopyReflectValueWrapper(cached)\n\t}\n\n\trv := o.fieldsValue.Index(idx)\n\terr := o.val.runtime.toReflectValue(v, rv, &objectExportCtx{})\n\tif err != nil {\n\t\tif cached != nil {\n\t\t\tcached.setReflectValue(rv)\n\t\t}\n\t\to.val.runtime.typeErrorResult(throw, \"Go type conversion error: %v\", err)\n\t\treturn false\n\t}\n\tif cached != nil {\n\t\to.valueCache[idx] = nil\n\t}\n\treturn true\n}\n\nfunc (o *objectGoArrayReflect) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\tif i := toIntStrict(int64(idx)); i >= 0 {\n\t\tif i >= o.fieldsValue.Len() {\n\t\t\tif res, ok := o._setForeignIdx(idx, nil, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\treturn o.putIdx(i, val, throw)\n\t} else {\n\t\tname := idx.string()\n\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); !ok {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Can't set property '%s' on Go slice\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n}\n\nfunc (o *objectGoArrayReflect) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif idx >= o.fieldsValue.Len() {\n\t\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\treturn o.putIdx(idx, val, throw)\n\t} else {\n\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); !ok {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Can't set property '%s' on Go slice\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n}\n\nfunc (o *objectGoArrayReflect) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignIdx(idx, trueValIfPresent(o._hasIdx(idx)), val, receiver, throw)\n}\n\nfunc (o *objectGoArrayReflect) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, trueValIfPresent(o.hasOwnPropertyStr(name)), val, receiver, throw)\n}\n\nfunc (o *objectGoArrayReflect) hasOwnPropertyIdx(idx valueInt) bool {\n\treturn o._hasIdx(idx)\n}\n\nfunc (o *objectGoArrayReflect) hasOwnPropertyStr(name unistring.String) bool {\n\tif o._hasStr(name) || name == \"length\" {\n\t\treturn true\n\t}\n\treturn o.objectGoReflect.hasOwnPropertyStr(name)\n}\n\nfunc (o *objectGoArrayReflect) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\tif i := toIntStrict(int64(idx)); i >= 0 {\n\t\tif !o.val.runtime.checkHostObjectPropertyDescr(idx.string(), descr, throw) {\n\t\t\treturn false\n\t\t}\n\t\tval := descr.Value\n\t\tif val == nil {\n\t\t\tval = _undefined\n\t\t}\n\t\treturn o.putIdx(i, val, throw)\n\t}\n\to.val.runtime.typeErrorResult(throw, \"Cannot define property '%d' on a Go slice\", idx)\n\treturn false\n}\n\nfunc (o *objectGoArrayReflect) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif !o.val.runtime.checkHostObjectPropertyDescr(name, descr, throw) {\n\t\t\treturn false\n\t\t}\n\t\tval := descr.Value\n\t\tif val == nil {\n\t\t\tval = _undefined\n\t\t}\n\t\treturn o.putIdx(idx, val, throw)\n\t}\n\to.val.runtime.typeErrorResult(throw, \"Cannot define property '%s' on a Go slice\", name)\n\treturn false\n}\n\nfunc (o *objectGoArrayReflect) _deleteIdx(idx int) {\n\tif idx < o.fieldsValue.Len() {\n\t\tif cv := o.valueCache.get(idx); cv != nil {\n\t\t\tcopyReflectValueWrapper(cv)\n\t\t\to.valueCache[idx] = nil\n\t\t}\n\n\t\to.fieldsValue.Index(idx).Set(reflect.Zero(o.fieldsValue.Type().Elem()))\n\t}\n}\n\nfunc (o *objectGoArrayReflect) deleteStr(name unistring.String, throw bool) bool {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\to._deleteIdx(idx)\n\t\treturn true\n\t}\n\n\treturn o.objectGoReflect.deleteStr(name, throw)\n}\n\nfunc (o *objectGoArrayReflect) deleteIdx(i valueInt, throw bool) bool {\n\tidx := toIntStrict(int64(i))\n\tif idx >= 0 {\n\t\to._deleteIdx(idx)\n\t}\n\treturn true\n}\n\ntype goArrayReflectPropIter struct {\n\to          *objectGoArrayReflect\n\tidx, limit int\n}\n\nfunc (i *goArrayReflectPropIter) next() (propIterItem, iterNextFunc) {\n\tif i.idx < i.limit && i.idx < i.o.fieldsValue.Len() {\n\t\tname := strconv.Itoa(i.idx)\n\t\ti.idx++\n\t\treturn propIterItem{name: asciiString(name), enumerable: _ENUM_TRUE}, i.next\n\t}\n\n\treturn i.o.objectGoReflect.iterateStringKeys()()\n}\n\nfunc (o *objectGoArrayReflect) stringKeys(all bool, accum []Value) []Value {\n\tfor i := 0; i < o.fieldsValue.Len(); i++ {\n\t\taccum = append(accum, asciiString(strconv.Itoa(i)))\n\t}\n\n\treturn o.objectGoReflect.stringKeys(all, accum)\n}\n\nfunc (o *objectGoArrayReflect) iterateStringKeys() iterNextFunc {\n\treturn (&goArrayReflectPropIter{\n\t\to:     o,\n\t\tlimit: o.fieldsValue.Len(),\n\t}).next\n}\n\nfunc (o *objectGoArrayReflect) sortLen() int {\n\treturn o.fieldsValue.Len()\n}\n\nfunc (o *objectGoArrayReflect) sortGet(i int) Value {\n\treturn o.getIdx(valueInt(i), nil)\n}\n\nfunc (o *objectGoArrayReflect) swap(i int, j int) {\n\tvi := o.fieldsValue.Index(i)\n\tvj := o.fieldsValue.Index(j)\n\ttmp := reflect.New(o.fieldsValue.Type().Elem()).Elem()\n\ttmp.Set(vi)\n\tvi.Set(vj)\n\tvj.Set(tmp)\n\n\tcachedI := o.valueCache.get(i)\n\tcachedJ := o.valueCache.get(j)\n\tif cachedI != nil {\n\t\tcachedI.setReflectValue(vj)\n\t\to.valueCache.put(j, cachedI)\n\t} else {\n\t\tif j < len(o.valueCache) {\n\t\t\to.valueCache[j] = nil\n\t\t}\n\t}\n\n\tif cachedJ != nil {\n\t\tcachedJ.setReflectValue(vi)\n\t\to.valueCache.put(i, cachedJ)\n\t} else {\n\t\tif i < len(o.valueCache) {\n\t\t\to.valueCache[i] = nil\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "object_goarray_reflect_test.go",
          "type": "blob",
          "size": 5.619140625,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGoReflectArray(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"a\", [...]int{1, 2, 3})\n\t_, err := vm.RunString(`\n\tif (!Array.isArray(a)) {\n\t\tthrow new Error(\"isArray() returned false\");\n\t}\n\tif (a[0] !== 1 || a[1] !== 2 || a[2] !== 3) {\n\t\tthrow new Error(\"Array contents is incorrect\");\n\t}\n\tif (!a.hasOwnProperty(\"length\")) {\n\t\tthrow new Error(\"hasOwnProperty() returned false\");\n\t}\n\tlet desc = Object.getOwnPropertyDescriptor(a, \"length\");\n\tif (desc.value !== 3 || desc.writable || desc.enumerable || desc.configurable) {\n\t\tthrow new Error(\"incorrect property descriptor: \" + JSON.stringify(desc));\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectArraySort(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"a\", [...]int{3, 1, 2})\n\tv, err := vm.RunString(`\n\t\ta.sort();\n\t\tif (a[0] !== 1 || a[1] !== 2 || a[2] !== 3) {\n\t\t\tthrow new Error(a.toString());\n\t\t}\n\t\ta;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tres := v.Export()\n\tif a, ok := res.([3]int); ok {\n\t\tif a[0] != 1 || a[1] != 2 || a[2] != 3 {\n\t\t\tt.Fatal(a)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Wrong type: %T\", res)\n\t}\n}\n\nfunc TestGoReflectArrayCopyOnChange(t *testing.T) {\n\tvm := New()\n\n\tv, err := vm.RunString(`\n\ta => {\n\t\tlet tmp = a[0];\n\t\tif (tmp !== a[0]) {\n\t\t\tthrow new Error(\"tmp !== a[0]\");\n\t\t}\n\n\t\ta[0] = a[1];\n\t\tif (tmp === a[0]) {\n\t\t\tthrow new Error(\"tmp === a[0]\");\n\t\t}\n\t\tif (tmp.Test !== \"1\") {\n\t\t\tthrow new Error(\"tmp.Test: \" + tmp.Test + \" (\" + typeof tmp.Test + \")\");\n\t\t}\n\t\tif (a[0].Test !== \"2\") {\n\t\t\tthrow new Error(\"a[0].Test: \" + a[0].Test);\n\t\t}\n\n\t\ta[0].Test = \"3\";\n\t\tif (a[0].Test !== \"3\") {\n\t\t\tthrow new Error(\"a[0].Test (1): \" + a[0].Test);\n\t\t}\n\n\t\ttmp = a[0];\n\t\ttmp.Test = \"4\";\n\t\tif (a[0].Test !== \"4\") {\n\t\t\tthrow new Error(\"a[0].Test (2): \" + a[0].Test);\n\t\t}\n\n\t\tdelete a[0];\n\t\tif (a[0] && a[0].Test !== \"\") {\n\t\t\tthrow new Error(\"a[0].Test (3): \" + a[0].Test);\n\t\t}\n\t\tif (tmp.Test !== \"4\") {\n\t\t\tthrow new Error(\"tmp.Test (1): \" + tmp.Test);\n\t\t}\n\n\t\ta[1] = tmp;\n\t\tif (a[1].Test !== \"4\") {\n\t\t\tthrow new Error(\"a[1].Test: \" + a[1].Test);\n\t\t}\n\n        // grow\n\t\ttmp = a[1];\n\t\ta.push(null);\n\t\tif (a.length !== 3) {\n\t\t\tthrow new Error(\"a.length after push: \" + a.length);\n\t\t}\n\n\t\ttmp.Test = \"5\";\n\t\tif (a[1].Test !== \"5\") {\n\t\t\tthrow new Error(\"a[1].Test (1): \" + a[1].Test);\n\t\t}\n\n\t\t// shrink\n\t\ta.length = 1;\n\t\tif (a.length !== 1) {\n\t\t\tthrow new Error(\"a.length after shrink: \" + a.length);\n\t\t}\n\n\t\tif (tmp.Test !== \"5\") {\n\t\t\tthrow new Error(\"tmp.Test (shrink): \" + tmp.Test);\n\t\t}\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfn, ok := AssertFunction(v)\n\tif !ok {\n\t\tt.Fatal(\"Not a function\")\n\t}\n\n\tt.Run(\"[]struct\", func(t *testing.T) {\n\t\ta := []struct {\n\t\t\tTest string\n\t\t}{{\"1\"}, {\"2\"}}\n\t\t_, err := fn(nil, vm.ToValue(a))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a[0].Test != \"\" {\n\t\t\tt.Fatalf(\"a[0]: %#v\", a[0])\n\t\t}\n\n\t\tif a[1].Test != \"4\" {\n\t\t\tt.Fatalf(\"a0[1]: %#v\", a[1])\n\t\t}\n\t})\n\n\t// The copy-on-change mechanism doesn't apply to the types below because the contained values are references.\n\t// These tests are here for completeness and to prove that the behaviour is consistent.\n\n\tt.Run(\"[]I\", func(t *testing.T) {\n\t\ttype I interface {\n\t\t\tGet() string\n\t\t}\n\n\t\ta := []I{&testGoReflectMethod_O{Test: \"1\"}, &testGoReflectMethod_O{Test: \"2\"}}\n\n\t\t_, err = fn(nil, vm.ToValue(a))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\n\tt.Run(\"[]interface{}\", func(t *testing.T) {\n\t\ta := []interface{}{&testGoReflectMethod_O{Test: \"1\"}, &testGoReflectMethod_O{Test: \"2\"}}\n\n\t\t_, err = fn(nil, vm.ToValue(a))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n}\n\nfunc TestCopyOnChangeReflectSlice(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`\n\ts => {\n\t\ts.A.push(1);\n\t\tif (s.A.length !== 1) {\n\t\t\tthrow new Error(\"s.A.length: \" + s.A.length);\n\t\t}\n\t\tif (s.A[0] !== 1) {\n\t\t\tthrow new Error(\"s.A[0]: \" + s.A[0]);\n\t\t}\n\t\tlet tmp = s.A;\n\t\tif (tmp !== s.A) {\n\t\t\tthrow new Error(\"tmp !== s.A\");\n\t\t}\n\t\ts.A = [2];\n\t\tif (tmp === s.A) {\n\t\t\tthrow new Error(\"tmp === s.A\");\n\t\t}\n\t\tif (tmp[0] !== 1) {\n\t\t\tthrow new Error(\"tmp[0]: \" + tmp[0]);\n\t\t}\n\t\tif (s.A[0] !== 2) {\n\t\t\tthrow new Error(\"s.A[0] (1): \" + s.A[0]);\n\t\t}\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfn, ok := AssertFunction(v)\n\tif !ok {\n\t\tt.Fatal(\"Not a function\")\n\t}\n\n\tt.Run(\"[]int\", func(t *testing.T) {\n\t\ttype S struct {\n\t\t\tA []int\n\t\t}\n\t\tvar s S\n\t\t_, err := fn(nil, vm.ToValue(&s))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(s.A) != 1 {\n\t\t\tt.Fatal(s)\n\t\t}\n\t\tif s.A[0] != 2 {\n\t\t\tt.Fatal(s.A)\n\t\t}\n\t})\n\n\tt.Run(\"[]interface{}\", func(t *testing.T) {\n\t\ttype S struct {\n\t\t\tA []interface{}\n\t\t}\n\t\tvar s S\n\t\t_, err := fn(nil, vm.ToValue(&s))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(s.A) != 1 {\n\t\t\tt.Fatal(s)\n\t\t}\n\t\tif s.A[0] != int64(2) {\n\t\t\tt.Fatal(s.A)\n\t\t}\n\t})\n}\n\nfunc TestCopyOnChangeSort(t *testing.T) {\n\ta := []struct {\n\t\tTest string\n\t}{{\"2\"}, {\"1\"}}\n\n\tvm := New()\n\tvm.Set(\"a\", &a)\n\n\t_, err := vm.RunString(`\n\t\tlet a0 = a[0];\n\t\tlet a1 = a[1];\n\t\ta.sort((a, b) => a.Test.localeCompare(b.Test));\n\t\tif (a[0].Test !== \"1\") {\n\t\t\tthrow new Error(\"a[0]: \" + a[0]);\n\t\t}\n\t\tif (a[1].Test !== \"2\") {\n\t\t\tthrow new Error(\"a[1]: \" + a[1]);\n\t\t}\n\t\tif (a0 !== a[1]) {\n\t\t\tthrow new Error(\"a0 !== a[1]\");\n\t\t}\n\t\tif (a1 !== a[0]) {\n\t\t\tthrow new Error(\"a1 !== a[0]\");\n\t\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif a[0].Test != \"1\" || a[1].Test != \"2\" {\n\t\tt.Fatal(a)\n\t}\n}\n\ntype testStringerArray [8]byte\n\nfunc (a testStringerArray) String() string {\n\treturn \"X\"\n}\n\nfunc TestReflectArrayToString(t *testing.T) {\n\tvm := New()\n\tvar a testStringerArray\n\tvm.Set(\"a\", &a)\n\tres, err := vm.RunString(\"`${a}`\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exp := res.Export(); exp != \"X\" {\n\t\tt.Fatal(exp)\n\t}\n\n\tvar a1 [2]byte\n\tvm.Set(\"a\", &a1)\n\tres, err = vm.RunString(\"`${a}`\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exp := res.Export(); exp != \"0,0\" {\n\t\tt.Fatal(exp)\n\t}\n}\n"
        },
        {
          "name": "object_gomap.go",
          "type": "blob",
          "size": 3.5302734375,
          "content": "package goja\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype objectGoMapSimple struct {\n\tbaseObject\n\tdata map[string]interface{}\n}\n\nfunc (o *objectGoMapSimple) init() {\n\to.baseObject.init()\n\to.prototype = o.val.runtime.global.ObjectPrototype\n\to.class = classObject\n\to.extensible = true\n}\n\nfunc (o *objectGoMapSimple) _getStr(name string) Value {\n\tv, exists := o.data[name]\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn o.val.runtime.ToValue(v)\n}\n\nfunc (o *objectGoMapSimple) getStr(name unistring.String, receiver Value) Value {\n\tif v := o._getStr(name.String()); v != nil {\n\t\treturn v\n\t}\n\treturn o.baseObject.getStr(name, receiver)\n}\n\nfunc (o *objectGoMapSimple) getOwnPropStr(name unistring.String) Value {\n\tif v := o._getStr(name.String()); v != nil {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoMapSimple) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tn := name.String()\n\tif _, exists := o.data[n]; exists {\n\t\to.data[n] = val.Export()\n\t\treturn true\n\t}\n\tif proto := o.prototype; proto != nil {\n\t\t// we know it's foreign because prototype loops are not allowed\n\t\tif res, ok := proto.self.setForeignStr(name, val, o.val, throw); ok {\n\t\t\treturn res\n\t\t}\n\t}\n\t// new property\n\tif !o.extensible {\n\t\to.val.runtime.typeErrorResult(throw, \"Cannot add property %s, object is not extensible\", name)\n\t\treturn false\n\t} else {\n\t\to.data[n] = val.Export()\n\t}\n\treturn true\n}\n\nfunc trueValIfPresent(present bool) Value {\n\tif present {\n\t\treturn valueTrue\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoMapSimple) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, trueValIfPresent(o._hasStr(name.String())), val, receiver, throw)\n}\n\nfunc (o *objectGoMapSimple) _hasStr(name string) bool {\n\t_, exists := o.data[name]\n\treturn exists\n}\n\nfunc (o *objectGoMapSimple) hasOwnPropertyStr(name unistring.String) bool {\n\treturn o._hasStr(name.String())\n}\n\nfunc (o *objectGoMapSimple) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif !o.val.runtime.checkHostObjectPropertyDescr(name, descr, throw) {\n\t\treturn false\n\t}\n\n\tn := name.String()\n\tif o.extensible || o._hasStr(n) {\n\t\to.data[n] = descr.Value.Export()\n\t\treturn true\n\t}\n\n\to.val.runtime.typeErrorResult(throw, \"Cannot define property %s, object is not extensible\", n)\n\treturn false\n}\n\nfunc (o *objectGoMapSimple) deleteStr(name unistring.String, _ bool) bool {\n\tdelete(o.data, name.String())\n\treturn true\n}\n\ntype gomapPropIter struct {\n\to         *objectGoMapSimple\n\tpropNames []string\n\tidx       int\n}\n\nfunc (i *gomapPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.propNames) {\n\t\tname := i.propNames[i.idx]\n\t\ti.idx++\n\t\tif _, exists := i.o.data[name]; exists {\n\t\t\treturn propIterItem{name: newStringValue(name), enumerable: _ENUM_TRUE}, i.next\n\t\t}\n\t}\n\n\treturn propIterItem{}, nil\n}\n\nfunc (o *objectGoMapSimple) iterateStringKeys() iterNextFunc {\n\tpropNames := make([]string, len(o.data))\n\ti := 0\n\tfor key := range o.data {\n\t\tpropNames[i] = key\n\t\ti++\n\t}\n\n\treturn (&gomapPropIter{\n\t\to:         o,\n\t\tpropNames: propNames,\n\t}).next\n}\n\nfunc (o *objectGoMapSimple) stringKeys(_ bool, accum []Value) []Value {\n\t// all own keys are enumerable\n\tfor key := range o.data {\n\t\taccum = append(accum, newStringValue(key))\n\t}\n\treturn accum\n}\n\nfunc (o *objectGoMapSimple) export(*objectExportCtx) interface{} {\n\treturn o.data\n}\n\nfunc (o *objectGoMapSimple) exportType() reflect.Type {\n\treturn reflectTypeMap\n}\n\nfunc (o *objectGoMapSimple) equal(other objectImpl) bool {\n\tif other, ok := other.(*objectGoMapSimple); ok {\n\t\treturn o == other\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "object_gomap_reflect.go",
          "type": "blob",
          "size": 7.2265625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype objectGoMapReflect struct {\n\tobjectGoReflect\n\n\tkeyType, valueType reflect.Type\n}\n\nfunc (o *objectGoMapReflect) init() {\n\to.objectGoReflect.init()\n\to.keyType = o.fieldsValue.Type().Key()\n\to.valueType = o.fieldsValue.Type().Elem()\n}\n\nfunc (o *objectGoMapReflect) toKey(n Value, throw bool) reflect.Value {\n\tkey := reflect.New(o.keyType).Elem()\n\terr := o.val.runtime.toReflectValue(n, key, &objectExportCtx{})\n\tif err != nil {\n\t\to.val.runtime.typeErrorResult(throw, \"map key conversion error: %v\", err)\n\t\treturn reflect.Value{}\n\t}\n\treturn key\n}\n\nfunc (o *objectGoMapReflect) strToKey(name string, throw bool) reflect.Value {\n\tif o.keyType.Kind() == reflect.String {\n\t\treturn reflect.ValueOf(name).Convert(o.keyType)\n\t}\n\treturn o.toKey(newStringValue(name), throw)\n}\n\nfunc (o *objectGoMapReflect) _getKey(key reflect.Value) Value {\n\tif !key.IsValid() {\n\t\treturn nil\n\t}\n\tif v := o.fieldsValue.MapIndex(key); v.IsValid() {\n\t\trv := v\n\t\tif rv.Kind() == reflect.Interface {\n\t\t\trv = rv.Elem()\n\t\t}\n\t\treturn o.val.runtime.toValue(v.Interface(), rv)\n\t}\n\n\treturn nil\n}\n\nfunc (o *objectGoMapReflect) _get(n Value) Value {\n\treturn o._getKey(o.toKey(n, false))\n}\n\nfunc (o *objectGoMapReflect) _getStr(name string) Value {\n\treturn o._getKey(o.strToKey(name, false))\n}\n\nfunc (o *objectGoMapReflect) getStr(name unistring.String, receiver Value) Value {\n\tif v := o._getStr(name.String()); v != nil {\n\t\treturn v\n\t}\n\treturn o.objectGoReflect.getStr(name, receiver)\n}\n\nfunc (o *objectGoMapReflect) getIdx(idx valueInt, receiver Value) Value {\n\tif v := o._get(idx); v != nil {\n\t\treturn v\n\t}\n\treturn o.objectGoReflect.getIdx(idx, receiver)\n}\n\nfunc (o *objectGoMapReflect) getOwnPropStr(name unistring.String) Value {\n\tif v := o._getStr(name.String()); v != nil {\n\t\treturn &valueProperty{\n\t\t\tvalue:      v,\n\t\t\twritable:   true,\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\treturn o.objectGoReflect.getOwnPropStr(name)\n}\n\nfunc (o *objectGoMapReflect) getOwnPropIdx(idx valueInt) Value {\n\tif v := o._get(idx); v != nil {\n\t\treturn &valueProperty{\n\t\t\tvalue:      v,\n\t\t\twritable:   true,\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\treturn o.objectGoReflect.getOwnPropStr(idx.string())\n}\n\nfunc (o *objectGoMapReflect) toValue(val Value, throw bool) (reflect.Value, bool) {\n\tv := reflect.New(o.valueType).Elem()\n\terr := o.val.runtime.toReflectValue(val, v, &objectExportCtx{})\n\tif err != nil {\n\t\to.val.runtime.typeErrorResult(throw, \"map value conversion error: %v\", err)\n\t\treturn reflect.Value{}, false\n\t}\n\n\treturn v, true\n}\n\nfunc (o *objectGoMapReflect) _put(key reflect.Value, val Value, throw bool) bool {\n\tif key.IsValid() {\n\t\tif o.extensible || o.fieldsValue.MapIndex(key).IsValid() {\n\t\t\tv, ok := o.toValue(val, throw)\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\to.fieldsValue.SetMapIndex(key, v)\n\t\t} else {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot set property %v, object is not extensible\", key)\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoMapReflect) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tn := name.String()\n\tkey := o.strToKey(n, false)\n\tif !key.IsValid() || !o.fieldsValue.MapIndex(key).IsValid() {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, ok := proto.self.setForeignStr(name, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\t// new property\n\t\tif !o.extensible {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot add property %s, object is not extensible\", n)\n\t\t\treturn false\n\t\t} else {\n\t\t\tif throw && !key.IsValid() {\n\t\t\t\to.strToKey(n, true)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\to._put(key, val, throw)\n\treturn true\n}\n\nfunc (o *objectGoMapReflect) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\tkey := o.toKey(idx, false)\n\tif !key.IsValid() || !o.fieldsValue.MapIndex(key).IsValid() {\n\t\tif proto := o.prototype; proto != nil {\n\t\t\t// we know it's foreign because prototype loops are not allowed\n\t\t\tif res, ok := proto.self.setForeignIdx(idx, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\t// new property\n\t\tif !o.extensible {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot add property %d, object is not extensible\", idx)\n\t\t\treturn false\n\t\t} else {\n\t\t\tif throw && !key.IsValid() {\n\t\t\t\to.toKey(idx, true)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\to._put(key, val, throw)\n\treturn true\n}\n\nfunc (o *objectGoMapReflect) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, trueValIfPresent(o.hasOwnPropertyStr(name)), val, receiver, throw)\n}\n\nfunc (o *objectGoMapReflect) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignIdx(idx, trueValIfPresent(o.hasOwnPropertyIdx(idx)), val, receiver, throw)\n}\n\nfunc (o *objectGoMapReflect) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif !o.val.runtime.checkHostObjectPropertyDescr(name, descr, throw) {\n\t\treturn false\n\t}\n\n\treturn o._put(o.strToKey(name.String(), throw), descr.Value, throw)\n}\n\nfunc (o *objectGoMapReflect) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\tif !o.val.runtime.checkHostObjectPropertyDescr(idx.string(), descr, throw) {\n\t\treturn false\n\t}\n\n\treturn o._put(o.toKey(idx, throw), descr.Value, throw)\n}\n\nfunc (o *objectGoMapReflect) hasOwnPropertyStr(name unistring.String) bool {\n\tkey := o.strToKey(name.String(), false)\n\tif key.IsValid() && o.fieldsValue.MapIndex(key).IsValid() {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoMapReflect) hasOwnPropertyIdx(idx valueInt) bool {\n\tkey := o.toKey(idx, false)\n\tif key.IsValid() && o.fieldsValue.MapIndex(key).IsValid() {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoMapReflect) deleteStr(name unistring.String, throw bool) bool {\n\tkey := o.strToKey(name.String(), throw)\n\tif !key.IsValid() {\n\t\treturn false\n\t}\n\to.fieldsValue.SetMapIndex(key, reflect.Value{})\n\treturn true\n}\n\nfunc (o *objectGoMapReflect) deleteIdx(idx valueInt, throw bool) bool {\n\tkey := o.toKey(idx, throw)\n\tif !key.IsValid() {\n\t\treturn false\n\t}\n\to.fieldsValue.SetMapIndex(key, reflect.Value{})\n\treturn true\n}\n\ntype gomapReflectPropIter struct {\n\to    *objectGoMapReflect\n\tkeys []reflect.Value\n\tidx  int\n}\n\nfunc (i *gomapReflectPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.keys) {\n\t\tkey := i.keys[i.idx]\n\t\tv := i.o.fieldsValue.MapIndex(key)\n\t\ti.idx++\n\t\tif v.IsValid() {\n\t\t\treturn propIterItem{name: i.o.keyToString(key), enumerable: _ENUM_TRUE}, i.next\n\t\t}\n\t}\n\n\treturn propIterItem{}, nil\n}\n\nfunc (o *objectGoMapReflect) iterateStringKeys() iterNextFunc {\n\treturn (&gomapReflectPropIter{\n\t\to:    o,\n\t\tkeys: o.fieldsValue.MapKeys(),\n\t}).next\n}\n\nfunc (o *objectGoMapReflect) stringKeys(_ bool, accum []Value) []Value {\n\t// all own keys are enumerable\n\tfor _, key := range o.fieldsValue.MapKeys() {\n\t\taccum = append(accum, o.keyToString(key))\n\t}\n\n\treturn accum\n}\n\nfunc (*objectGoMapReflect) keyToString(key reflect.Value) String {\n\tkind := key.Kind()\n\n\tif kind == reflect.String {\n\t\treturn newStringValue(key.String())\n\t}\n\n\tstr := fmt.Sprintf(\"%v\", key)\n\n\tswitch kind {\n\tcase reflect.Int,\n\t\treflect.Int8,\n\t\treflect.Int16,\n\t\treflect.Int32,\n\t\treflect.Int64,\n\t\treflect.Uint,\n\t\treflect.Uint8,\n\t\treflect.Uint16,\n\t\treflect.Uint32,\n\t\treflect.Uint64,\n\t\treflect.Float32,\n\t\treflect.Float64:\n\t\treturn asciiString(str)\n\tdefault:\n\t\treturn newStringValue(str)\n\t}\n}\n"
        },
        {
          "name": "object_gomap_reflect_test.go",
          "type": "blob",
          "size": 6.1611328125,
          "content": "package goja\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestGoMapReflectGetSet(t *testing.T) {\n\tconst SCRIPT = `\n\tm.c = m.a + m.b;\n\t`\n\n\tvm := New()\n\tm := map[string]string{\n\t\t\"a\": \"4\",\n\t\t\"b\": \"2\",\n\t}\n\tvm.Set(\"m\", m)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif c := m[\"c\"]; c != \"42\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", c)\n\t}\n}\n\nfunc TestGoMapReflectIntKey(t *testing.T) {\n\tconst SCRIPT = `\n\tm[2] = m[0] + m[1];\n\t`\n\n\tvm := New()\n\tm := map[int]int{\n\t\t0: 40,\n\t\t1: 2,\n\t}\n\tvm.Set(\"m\", m)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif c := m[2]; c != 42 {\n\t\tt.Fatalf(\"Unexpected value: '%d'\", c)\n\t}\n}\n\nfunc TestGoMapReflectDelete(t *testing.T) {\n\tconst SCRIPT = `\n\tdelete m.a;\n\t`\n\n\tvm := New()\n\tm := map[string]string{\n\t\t\"a\": \"4\",\n\t\t\"b\": \"2\",\n\t}\n\tvm.Set(\"m\", m)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, exists := m[\"a\"]; exists {\n\t\tt.Fatal(\"a still exists\")\n\t}\n\n\tif b := m[\"b\"]; b != \"2\" {\n\t\tt.Fatalf(\"Unexpected b: '%s'\", b)\n\t}\n}\n\nfunc TestGoMapReflectJSON(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(m) {\n\t\treturn JSON.stringify(m);\n\t}\n\t`\n\n\tvm := New()\n\tm := map[string]string{\n\t\t\"t\": \"42\",\n\t}\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf := vm.Get(\"f\")\n\tif call, ok := AssertFunction(f); ok {\n\t\tv, err := call(nil, ([]Value{vm.ToValue(m)})...)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !v.StrictEquals(asciiString(`{\"t\":\"42\"}`)) {\n\t\t\tt.Fatalf(\"Unexpected value: %v\", v)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Not a function: %v\", f)\n\t}\n}\n\nfunc TestGoMapReflectProto(t *testing.T) {\n\tconst SCRIPT = `\n\tm.hasOwnProperty(\"t\");\n\t`\n\n\tvm := New()\n\tm := map[string]string{\n\t\t\"t\": \"42\",\n\t}\n\tvm.Set(\"m\", m)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\ntype gomapReflect_noMethods map[string]interface{}\ntype gomapReflect_withMethods map[string]interface{}\n\nfunc (m gomapReflect_withMethods) Method() bool {\n\treturn true\n}\n\nfunc TestGoMapReflectNoMethods(t *testing.T) {\n\tconst SCRIPT = `\n\ttypeof m === \"object\" && m.hasOwnProperty(\"t\") && m.t === 42;\n\t`\n\n\tvm := New()\n\tm := make(gomapReflect_noMethods)\n\tm[\"t\"] = 42\n\tvm.Set(\"m\", m)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n}\n\nfunc TestGoMapReflectWithMethods(t *testing.T) {\n\tconst SCRIPT = `\n\ttypeof m === \"object\" && !m.hasOwnProperty(\"t\") && m.hasOwnProperty(\"Method\") && m.Method();\n\t`\n\n\tvm := New()\n\tm := make(gomapReflect_withMethods)\n\tm[\"t\"] = 42\n\tvm.Set(\"m\", m)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n}\n\nfunc TestGoMapReflectWithProto(t *testing.T) {\n\tvm := New()\n\tm := map[string]string{\n\t\t\"t\": \"42\",\n\t}\n\tvm.Set(\"m\", m)\n\tvm.testScriptWithTestLib(`\n\t(function() {\n\t'use strict';\n\tvar proto = {};\n\tvar getterAllowed = false;\n\tvar setterAllowed = false;\n\tvar tHolder = \"proto t\";\n\tObject.defineProperty(proto, \"t\", {\n\t\tget: function() {\n\t\t\tif (!getterAllowed) throw new Error(\"getter is called\");\n\t\t\treturn tHolder;\n\t\t},\n\t\tset: function(v) {\n\t\t\tif (!setterAllowed) throw new Error(\"setter is called\");\n\t\t\ttHolder = v;\n\t\t}\n\t});\n\tvar t1Holder;\n\tObject.defineProperty(proto, \"t1\", {\n\t\tget: function() {\n\t\t\treturn t1Holder;\n\t\t},\n\t\tset: function(v) {\n\t\t\tt1Holder = v;\n\t\t}\n\t});\n\tObject.setPrototypeOf(m, proto);\n\tassert.sameValue(m.t, \"42\");\n\tm.t = 43;\n\tassert.sameValue(m.t, \"43\");\n\tt1Holder = \"test\";\n\tassert.sameValue(m.t1, \"test\");\n\tm.t1 = \"test1\";\n\tassert.sameValue(m.t1, \"test1\");\n\tdelete m.t;\n\tgetterAllowed = true;\n\tassert.sameValue(m.t, \"proto t\", \"after delete\");\n\tsetterAllowed = true;\n\tm.t = true;\n\tassert.sameValue(m.t, true, \"m.t === true\");\n\tassert.sameValue(tHolder, true, \"tHolder === true\");\n\tObject.preventExtensions(m);\n\tassert.throws(TypeError, function() {\n\t\tm.t2 = 1;\n\t});\n\tm.t1 = \"test2\";\n\tassert.sameValue(m.t1, \"test2\");\n\t})();\n\t`, _undefined, t)\n}\n\nfunc TestGoMapReflectProtoProp(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\"use strict\";\n\tvar proto = {};\n\tObject.defineProperty(proto, \"ro\", {value: 42});\n\tObject.setPrototypeOf(m, proto);\n\tassert.throws(TypeError, function() {\n\t\tm.ro = 43;\n\t});\n\tObject.defineProperty(m, \"ro\", {value: 43});\n\tassert.sameValue(m.ro, \"43\");\n\t})();\n\t`\n\n\tr := New()\n\tr.Set(\"m\", map[string]string{})\n\tr.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestGoMapReflectUnicode(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.setPrototypeOf(m, s);\n\tif (m. !== \"passed\") {\n\t\tthrow new Error(\"m.: \" + m.);\n\t}\n\tm[\"\"];\n\t`\n\ttype S struct {\n\t\t string\n\t}\n\tvm := New()\n\tm := map[string]int{\n\t\t\"\": 42,\n\t}\n\ts := S{\n\t\t: \"passed\",\n\t}\n\tvm.Set(\"m\", m)\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res == nil || !res.StrictEquals(valueInt(42)) {\n\t\tt.Fatalf(\"Unexpected value: %v\", res)\n\t}\n}\n\nfunc TestGoMapReflectStruct(t *testing.T) {\n\ttype S struct {\n\t\tTest int\n\t}\n\n\tm := map[string]S{\n\t\t\"1\": {Test: 1},\n\t}\n\n\tvm := New()\n\tvm.Set(\"m\", m)\n\tres, err := vm.RunString(\"m[1].Test = 2; m[1].Test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res.Export() != int64(1) {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestGoMapReflectElt(t *testing.T) {\n\ttype mapping map[string]interface{}\n\n\tconst SCRIPT = `a.s() && a.t === null && a.t1 === undefined;`\n\n\tr := New()\n\n\tr.Set(\"a\", mapping{\n\t\t\"s\": func() bool { return true },\n\t\t\"t\": nil,\n\t})\n\n\tr.testScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestGoMapReflectKeyToString(t *testing.T) {\n\tvm := New()\n\n\ttest := func(v any, t *testing.T) {\n\t\to1 := vm.ToValue(v).ToObject(vm)\n\t\tkeys := o1.Keys()\n\t\tsort.Strings(keys)\n\t\tif len(keys) != 2 || keys[0] != \"1\" || keys[1] != \"2\" {\n\t\t\tt.Fatal(keys)\n\t\t}\n\n\t\tkeys1 := o1.self.stringKeys(true, nil)\n\t\tsort.Slice(keys1, func(a, b int) bool {\n\t\t\treturn strings.Compare(keys1[a].String(), keys1[b].String()) < 0\n\t\t})\n\t\tif len(keys1) != 2 || keys1[0] != asciiString(\"1\") || keys1[1] != asciiString(\"2\") {\n\t\t\tt.Fatal(keys1)\n\t\t}\n\t}\n\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tm1 := map[int]any{\n\t\t\t1: 2,\n\t\t\t2: 3,\n\t\t}\n\t\ttest(m1, t)\n\t})\n\n\tt.Run(\"CustomString\", func(t *testing.T) {\n\t\ttype CustomString string\n\t\tm2 := map[CustomString]any{\n\t\t\t\"1\": 2,\n\t\t\t\"2\": 3,\n\t\t}\n\t\ttest(m2, t)\n\t})\n\n}\n"
        },
        {
          "name": "object_gomap_test.go",
          "type": "blob",
          "size": 5.6845703125,
          "content": "package goja\n\nimport \"testing\"\n\nfunc TestGomapProp(t *testing.T) {\n\tconst SCRIPT = `\n\to.a + o.b;\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{\n\t\t\"a\": 40,\n\t\t\"b\": 2,\n\t})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.ToInteger(); i != 42 {\n\t\tt.Fatalf(\"Expected 42, got: %d\", i)\n\t}\n}\n\nfunc TestGomapEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar hasX = false;\n\tvar hasY = false;\n\tfor (var key in o) {\n\t\tswitch (key) {\n\t\tcase \"x\":\n\t\t\tif (hasX) {\n\t\t\t\tthrow \"Already have x\";\n\t\t\t}\n\t\t\thasX = true;\n\t\t\tbreak;\n\t\tcase \"y\":\n\t\t\tif (hasY) {\n\t\t\t\tthrow \"Already have y\";\n\t\t\t}\n\t\t\thasY = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow \"Unexpected property: \" + key;\n\t\t}\n\t}\n\thasX && hasY;\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{\n\t\t\"x\": 40,\n\t\t\"y\": 2,\n\t})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGomapDeleteWhileEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar hasX = false;\n\tvar hasY = false;\n\tfor (var key in o) {\n\t\tswitch (key) {\n\t\tcase \"x\":\n\t\t\tif (hasX) {\n\t\t\t\tthrow \"Already have x\";\n\t\t\t}\n\t\t\thasX = true;\n\t\t\tdelete o.y;\n\t\t\tbreak;\n\t\tcase \"y\":\n\t\t\tif (hasY) {\n\t\t\t\tthrow \"Already have y\";\n\t\t\t}\n\t\t\thasY = true;\n\t\t\tdelete o.x;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow \"Unexpected property: \" + key;\n\t\t}\n\t}\n\thasX && !hasY || hasY && !hasX;\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{\n\t\t\"x\": 40,\n\t\t\"y\": 2,\n\t})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGomapInstanceOf(t *testing.T) {\n\tconst SCRIPT = `\n\t(o instanceof Object) && !(o instanceof Error);\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGomapTypeOf(t *testing.T) {\n\tconst SCRIPT = `\n\ttypeof o;\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(asciiString(\"object\")) {\n\t\tt.Fatalf(\"Expected object, got %v\", v)\n\t}\n}\n\nfunc TestGomapProto(t *testing.T) {\n\tconst SCRIPT = `\n\to.hasOwnProperty(\"test\");\n\t`\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{\n\t\t\"test\": 42,\n\t})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGoMapExtensibility(t *testing.T) {\n\tconst SCRIPT = `\n\t\"use strict\";\n\to.test = 42;\n\tObject.preventExtensions(o);\n\to.test = 43;\n\ttry {\n\t\to.test1 = 42;\n\t} catch (e) {\n\t\tif (!(e instanceof TypeError)) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\to.test === 43 && o.test1 === undefined;\n\t`\n\n\tr := New()\n\tr.Set(\"o\", map[string]interface{}{})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tif ex, ok := err.(*Exception); ok {\n\t\t\tt.Fatal(ex.String())\n\t\t} else {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n}\n\nfunc TestGoMapWithProto(t *testing.T) {\n\tvm := New()\n\tm := map[string]interface{}{\n\t\t\"t\": \"42\",\n\t}\n\tvm.Set(\"m\", m)\n\tvm.testScriptWithTestLib(`\n\t(function() {\n\t'use strict';\n\tvar proto = {};\n\tvar getterAllowed = false;\n\tvar setterAllowed = false;\n\tvar tHolder = \"proto t\";\n\tObject.defineProperty(proto, \"t\", {\n\t\tget: function() {\n\t\t\tif (!getterAllowed) throw new Error(\"getter is called\");\n\t\t\treturn tHolder;\n\t\t},\n\t\tset: function(v) {\n\t\t\tif (!setterAllowed) throw new Error(\"setter is called\");\n\t\t\ttHolder = v;\n\t\t}\n\t});\n\tvar t1Holder;\n\tObject.defineProperty(proto, \"t1\", {\n\t\tget: function() {\n\t\t\treturn t1Holder;\n\t\t},\n\t\tset: function(v) {\n\t\t\tt1Holder = v;\n\t\t}\n\t});\n\tObject.setPrototypeOf(m, proto);\n\tassert.sameValue(m.t, \"42\");\n\tm.t = 43;\n\tassert.sameValue(m.t, 43);\n\tt1Holder = \"test\";\n\tassert.sameValue(m.t1, \"test\");\n\tm.t1 = \"test1\";\n\tassert.sameValue(m.t1, \"test1\");\n\tdelete m.t;\n\tgetterAllowed = true;\n\tassert.sameValue(m.t, \"proto t\", \"after delete\");\n\tsetterAllowed = true;\n\tm.t = true;\n\tassert.sameValue(m.t, true);\n\tassert.sameValue(tHolder, true);\n\tObject.preventExtensions(m);\n\tassert.throws(TypeError, function() {\n\t\tm.t2 = 1;\n\t});\n\tm.t1 = \"test2\";\n\tassert.sameValue(m.t1, \"test2\");\n\t})();\n\t`, _undefined, t)\n}\n\nfunc TestGoMapProtoProp(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\"use strict\";\n\tvar proto = {};\n\tObject.defineProperty(proto, \"ro\", {value: 42});\n\tObject.setPrototypeOf(m, proto);\n\tassert.throws(TypeError, function() {\n\t\tm.ro = 43;\n\t});\n\tObject.defineProperty(m, \"ro\", {value: 43});\n\tassert.sameValue(m.ro, 43);\n\t})();\n\t`\n\n\tr := New()\n\tr.Set(\"m\", map[string]interface{}{})\n\tr.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestGoMapProtoPropChain(t *testing.T) {\n\tconst SCRIPT = `\n\t(function() {\n\t\"use strict\";\n\tvar p1 = Object.create(null);\n\tm.__proto__ = p1;\n\t\n\tObject.defineProperty(p1, \"test\", {\n\t\tvalue: 42\n\t});\n\t\n\tObject.defineProperty(m, \"test\", {\n\t\tvalue: 43,\n\t\twritable: true,\n\t});\n\tvar o = Object.create(m);\n\to.test = 44;\n\tassert.sameValue(o.test, 44);\n\n\tvar sym = Symbol(true);\n\tObject.defineProperty(p1, sym, {\n\t\tvalue: 42\n\t});\n\t\n\tObject.defineProperty(m, sym, {\n\t\tvalue: 43,\n\t\twritable: true,\n\t});\n\to[sym] = 44;\n\tassert.sameValue(o[sym], 44);\n\t})();\n\t`\n\n\tr := New()\n\tr.Set(\"m\", map[string]interface{}{})\n\tr.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestGoMapUnicode(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.setPrototypeOf(m, s);\n\tif (m. !== \"passed\") {\n\t\tthrow new Error(\"m.: \" + m.);\n\t}\n\tm[\"\"];\n\t`\n\ttype S struct {\n\t\t string\n\t}\n\tvm := New()\n\tm := map[string]interface{}{\n\t\t\"\": 42,\n\t}\n\ts := S{\n\t\t: \"passed\",\n\t}\n\tvm.Set(\"m\", m)\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res == nil || !res.StrictEquals(valueInt(42)) {\n\t\tt.Fatalf(\"Unexpected value: %v\", res)\n\t}\n}\n"
        },
        {
          "name": "object_goreflect.go",
          "type": "blob",
          "size": 16.716796875,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/dop251/goja/parser\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\n// JsonEncodable allows custom JSON encoding by JSON.stringify()\n// Note that if the returned value itself also implements JsonEncodable, it won't have any effect.\ntype JsonEncodable interface {\n\tJsonEncodable() interface{}\n}\n\n// FieldNameMapper provides custom mapping between Go and JavaScript property names.\ntype FieldNameMapper interface {\n\t// FieldName returns a JavaScript name for the given struct field in the given type.\n\t// If this method returns \"\" the field becomes hidden.\n\tFieldName(t reflect.Type, f reflect.StructField) string\n\n\t// MethodName returns a JavaScript name for the given method in the given type.\n\t// If this method returns \"\" the method becomes hidden.\n\tMethodName(t reflect.Type, m reflect.Method) string\n}\n\ntype tagFieldNameMapper struct {\n\ttagName      string\n\tuncapMethods bool\n}\n\nfunc (tfm tagFieldNameMapper) FieldName(_ reflect.Type, f reflect.StructField) string {\n\ttag := f.Tag.Get(tfm.tagName)\n\tif idx := strings.IndexByte(tag, ','); idx != -1 {\n\t\ttag = tag[:idx]\n\t}\n\tif parser.IsIdentifier(tag) {\n\t\treturn tag\n\t}\n\treturn \"\"\n}\n\nfunc uncapitalize(s string) string {\n\treturn strings.ToLower(s[0:1]) + s[1:]\n}\n\nfunc (tfm tagFieldNameMapper) MethodName(_ reflect.Type, m reflect.Method) string {\n\tif tfm.uncapMethods {\n\t\treturn uncapitalize(m.Name)\n\t}\n\treturn m.Name\n}\n\ntype uncapFieldNameMapper struct {\n}\n\nfunc (u uncapFieldNameMapper) FieldName(_ reflect.Type, f reflect.StructField) string {\n\treturn uncapitalize(f.Name)\n}\n\nfunc (u uncapFieldNameMapper) MethodName(_ reflect.Type, m reflect.Method) string {\n\treturn uncapitalize(m.Name)\n}\n\ntype reflectFieldInfo struct {\n\tIndex     []int\n\tAnonymous bool\n}\n\ntype reflectFieldsInfo struct {\n\tFields map[string]reflectFieldInfo\n\tNames  []string\n}\n\ntype reflectMethodsInfo struct {\n\tMethods map[string]int\n\tNames   []string\n}\n\ntype reflectValueWrapper interface {\n\tesValue() Value\n\treflectValue() reflect.Value\n\tsetReflectValue(reflect.Value)\n}\n\nfunc isContainer(k reflect.Kind) bool {\n\tswitch k {\n\tcase reflect.Struct, reflect.Slice, reflect.Array:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc copyReflectValueWrapper(w reflectValueWrapper) {\n\tv := w.reflectValue()\n\tc := reflect.New(v.Type()).Elem()\n\tc.Set(v)\n\tw.setReflectValue(c)\n}\n\ntype objectGoReflect struct {\n\tbaseObject\n\torigValue, fieldsValue reflect.Value\n\n\tfieldsInfo  *reflectFieldsInfo\n\tmethodsInfo *reflectMethodsInfo\n\n\tmethodsValue reflect.Value\n\n\tvalueCache map[string]reflectValueWrapper\n\n\ttoString, valueOf func() Value\n\n\ttoJson func() interface{}\n}\n\nfunc (o *objectGoReflect) init() {\n\to.baseObject.init()\n\tswitch o.fieldsValue.Kind() {\n\tcase reflect.Bool:\n\t\to.class = classBoolean\n\t\to.prototype = o.val.runtime.getBooleanPrototype()\n\t\to.toString = o._toStringBool\n\t\to.valueOf = o._valueOfBool\n\tcase reflect.String:\n\t\to.class = classString\n\t\to.prototype = o.val.runtime.getStringPrototype()\n\t\to.toString = o._toStringString\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\to.class = classNumber\n\t\to.prototype = o.val.runtime.getNumberPrototype()\n\t\to.valueOf = o._valueOfInt\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\to.class = classNumber\n\t\to.prototype = o.val.runtime.getNumberPrototype()\n\t\to.valueOf = o._valueOfUint\n\tcase reflect.Float32, reflect.Float64:\n\t\to.class = classNumber\n\t\to.prototype = o.val.runtime.getNumberPrototype()\n\t\to.valueOf = o._valueOfFloat\n\tdefault:\n\t\to.class = classObject\n\t\to.prototype = o.val.runtime.global.ObjectPrototype\n\t}\n\n\tif o.fieldsValue.Kind() == reflect.Struct {\n\t\to.fieldsInfo = o.val.runtime.fieldsInfo(o.fieldsValue.Type())\n\t}\n\n\tvar methodsType reflect.Type\n\t// Always use pointer type for non-interface values to be able to access both methods defined on\n\t// the literal type and on the pointer.\n\tif o.fieldsValue.Kind() != reflect.Interface {\n\t\tmethodsType = reflect.PtrTo(o.fieldsValue.Type())\n\t} else {\n\t\tmethodsType = o.fieldsValue.Type()\n\t}\n\n\to.methodsInfo = o.val.runtime.methodsInfo(methodsType)\n\n\t// Container values and values that have at least one method defined on the pointer type\n\t// need to be addressable.\n\tif !o.origValue.CanAddr() && (isContainer(o.origValue.Kind()) || len(o.methodsInfo.Names) > 0) {\n\t\tvalue := reflect.New(o.origValue.Type()).Elem()\n\t\tvalue.Set(o.origValue)\n\t\to.origValue = value\n\t\tif value.Kind() != reflect.Ptr {\n\t\t\to.fieldsValue = value\n\t\t}\n\t}\n\n\to.extensible = true\n\n\tswitch o.origValue.Interface().(type) {\n\tcase fmt.Stringer:\n\t\to.toString = o._toStringStringer\n\tcase error:\n\t\to.toString = o._toStringError\n\t}\n\n\tif len(o.methodsInfo.Names) > 0 && o.fieldsValue.Kind() != reflect.Interface {\n\t\to.methodsValue = o.fieldsValue.Addr()\n\t} else {\n\t\to.methodsValue = o.fieldsValue\n\t}\n\n\tif j, ok := o.origValue.Interface().(JsonEncodable); ok {\n\t\to.toJson = j.JsonEncodable\n\t}\n}\n\nfunc (o *objectGoReflect) getStr(name unistring.String, receiver Value) Value {\n\tif v := o._get(name.String()); v != nil {\n\t\treturn v\n\t}\n\treturn o.baseObject.getStr(name, receiver)\n}\n\nfunc (o *objectGoReflect) _getField(jsName string) reflect.Value {\n\tif o.fieldsInfo != nil {\n\t\tif info, exists := o.fieldsInfo.Fields[jsName]; exists {\n\t\t\treturn o.fieldsValue.FieldByIndex(info.Index)\n\t\t}\n\t}\n\n\treturn reflect.Value{}\n}\n\nfunc (o *objectGoReflect) _getMethod(jsName string) reflect.Value {\n\tif o.methodsInfo != nil {\n\t\tif idx, exists := o.methodsInfo.Methods[jsName]; exists {\n\t\t\treturn o.methodsValue.Method(idx)\n\t\t}\n\t}\n\n\treturn reflect.Value{}\n}\n\nfunc (o *objectGoReflect) elemToValue(ev reflect.Value) (Value, reflectValueWrapper) {\n\tif isContainer(ev.Kind()) {\n\t\tif ev.CanAddr() {\n\t\t\tev = ev.Addr()\n\t\t}\n\t\tret := o.val.runtime.toValue(ev.Interface(), ev)\n\t\tif obj, ok := ret.(*Object); ok {\n\t\t\tif w, ok := obj.self.(reflectValueWrapper); ok {\n\t\t\t\treturn ret, w\n\t\t\t}\n\t\t}\n\t\treturn ret, nil\n\t}\n\n\tif ev.Kind() == reflect.Interface {\n\t\tev = ev.Elem()\n\t}\n\n\tif ev.Kind() == reflect.Invalid {\n\t\treturn _null, nil\n\t}\n\n\treturn o.val.runtime.toValue(ev.Interface(), ev), nil\n}\n\nfunc (o *objectGoReflect) _getFieldValue(name string) Value {\n\tif v := o.valueCache[name]; v != nil {\n\t\treturn v.esValue()\n\t}\n\tif v := o._getField(name); v.IsValid() {\n\t\tres, w := o.elemToValue(v)\n\t\tif w != nil {\n\t\t\tif o.valueCache == nil {\n\t\t\t\to.valueCache = make(map[string]reflectValueWrapper)\n\t\t\t}\n\t\t\to.valueCache[name] = w\n\t\t}\n\t\treturn res\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoReflect) _get(name string) Value {\n\tif o.fieldsValue.Kind() == reflect.Struct {\n\t\tif ret := o._getFieldValue(name); ret != nil {\n\t\t\treturn ret\n\t\t}\n\t}\n\n\tif v := o._getMethod(name); v.IsValid() {\n\t\treturn o.val.runtime.toValue(v.Interface(), v)\n\t}\n\n\treturn nil\n}\n\nfunc (o *objectGoReflect) getOwnPropStr(name unistring.String) Value {\n\tn := name.String()\n\tif o.fieldsValue.Kind() == reflect.Struct {\n\t\tif v := o._getFieldValue(n); v != nil {\n\t\t\treturn &valueProperty{\n\t\t\t\tvalue:      v,\n\t\t\t\twritable:   true,\n\t\t\t\tenumerable: true,\n\t\t\t}\n\t\t}\n\t}\n\n\tif v := o._getMethod(n); v.IsValid() {\n\t\treturn &valueProperty{\n\t\t\tvalue:      o.val.runtime.toValue(v.Interface(), v),\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\n\treturn o.baseObject.getOwnPropStr(name)\n}\n\nfunc (o *objectGoReflect) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\thas, ok := o._put(name.String(), val, throw)\n\tif !has {\n\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); !ok {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot assign to property %s of a host object\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn ok\n}\n\nfunc (o *objectGoReflect) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, trueValIfPresent(o._has(name.String())), val, receiver, throw)\n}\n\nfunc (o *objectGoReflect) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignIdx(idx, nil, val, receiver, throw)\n}\n\nfunc (o *objectGoReflect) _put(name string, val Value, throw bool) (has, ok bool) {\n\tif o.fieldsValue.Kind() == reflect.Struct {\n\t\tif v := o._getField(name); v.IsValid() {\n\t\t\tcached := o.valueCache[name]\n\t\t\tif cached != nil {\n\t\t\t\tcopyReflectValueWrapper(cached)\n\t\t\t}\n\n\t\t\terr := o.val.runtime.toReflectValue(val, v, &objectExportCtx{})\n\t\t\tif err != nil {\n\t\t\t\tif cached != nil {\n\t\t\t\t\tcached.setReflectValue(v)\n\t\t\t\t}\n\t\t\t\to.val.runtime.typeErrorResult(throw, \"Go struct conversion error: %v\", err)\n\t\t\t\treturn true, false\n\t\t\t}\n\t\t\tif cached != nil {\n\t\t\t\tdelete(o.valueCache, name)\n\t\t\t}\n\t\t\treturn true, true\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc (o *objectGoReflect) _putProp(name unistring.String, value Value, writable, enumerable, configurable bool) Value {\n\tif _, ok := o._put(name.String(), value, false); ok {\n\t\treturn value\n\t}\n\treturn o.baseObject._putProp(name, value, writable, enumerable, configurable)\n}\n\nfunc (r *Runtime) checkHostObjectPropertyDescr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif descr.Getter != nil || descr.Setter != nil {\n\t\tr.typeErrorResult(throw, \"Host objects do not support accessor properties\")\n\t\treturn false\n\t}\n\tif descr.Writable == FLAG_FALSE {\n\t\tr.typeErrorResult(throw, \"Host object field %s cannot be made read-only\", name)\n\t\treturn false\n\t}\n\tif descr.Configurable == FLAG_TRUE {\n\t\tr.typeErrorResult(throw, \"Host object field %s cannot be made configurable\", name)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (o *objectGoReflect) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif o.val.runtime.checkHostObjectPropertyDescr(name, descr, throw) {\n\t\tn := name.String()\n\t\tif has, ok := o._put(n, descr.Value, throw); !has {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Cannot define property '%s' on a host object\", n)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn ok\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (o *objectGoReflect) _has(name string) bool {\n\tif o.fieldsValue.Kind() == reflect.Struct {\n\t\tif v := o._getField(name); v.IsValid() {\n\t\t\treturn true\n\t\t}\n\t}\n\tif v := o._getMethod(name); v.IsValid() {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *objectGoReflect) hasOwnPropertyStr(name unistring.String) bool {\n\treturn o._has(name.String()) || o.baseObject.hasOwnPropertyStr(name)\n}\n\nfunc (o *objectGoReflect) _valueOfInt() Value {\n\treturn intToValue(o.fieldsValue.Int())\n}\n\nfunc (o *objectGoReflect) _valueOfUint() Value {\n\treturn intToValue(int64(o.fieldsValue.Uint()))\n}\n\nfunc (o *objectGoReflect) _valueOfBool() Value {\n\tif o.fieldsValue.Bool() {\n\t\treturn valueTrue\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\nfunc (o *objectGoReflect) _valueOfFloat() Value {\n\treturn floatToValue(o.fieldsValue.Float())\n}\n\nfunc (o *objectGoReflect) _toStringStringer() Value {\n\treturn newStringValue(o.origValue.Interface().(fmt.Stringer).String())\n}\n\nfunc (o *objectGoReflect) _toStringString() Value {\n\treturn newStringValue(o.fieldsValue.String())\n}\n\nfunc (o *objectGoReflect) _toStringBool() Value {\n\tif o.fieldsValue.Bool() {\n\t\treturn stringTrue\n\t} else {\n\t\treturn stringFalse\n\t}\n}\n\nfunc (o *objectGoReflect) _toStringError() Value {\n\treturn newStringValue(o.origValue.Interface().(error).Error())\n}\n\nfunc (o *objectGoReflect) deleteStr(name unistring.String, throw bool) bool {\n\tn := name.String()\n\tif o._has(n) {\n\t\to.val.runtime.typeErrorResult(throw, \"Cannot delete property %s from a Go type\", n)\n\t\treturn false\n\t}\n\treturn o.baseObject.deleteStr(name, throw)\n}\n\ntype goreflectPropIter struct {\n\to   *objectGoReflect\n\tidx int\n}\n\nfunc (i *goreflectPropIter) nextField() (propIterItem, iterNextFunc) {\n\tnames := i.o.fieldsInfo.Names\n\tif i.idx < len(names) {\n\t\tname := names[i.idx]\n\t\ti.idx++\n\t\treturn propIterItem{name: newStringValue(name), enumerable: _ENUM_TRUE}, i.nextField\n\t}\n\n\ti.idx = 0\n\treturn i.nextMethod()\n}\n\nfunc (i *goreflectPropIter) nextMethod() (propIterItem, iterNextFunc) {\n\tnames := i.o.methodsInfo.Names\n\tif i.idx < len(names) {\n\t\tname := names[i.idx]\n\t\ti.idx++\n\t\treturn propIterItem{name: newStringValue(name), enumerable: _ENUM_TRUE}, i.nextMethod\n\t}\n\n\treturn propIterItem{}, nil\n}\n\nfunc (o *objectGoReflect) iterateStringKeys() iterNextFunc {\n\tr := &goreflectPropIter{\n\t\to: o,\n\t}\n\tif o.fieldsInfo != nil {\n\t\treturn r.nextField\n\t}\n\n\treturn r.nextMethod\n}\n\nfunc (o *objectGoReflect) stringKeys(_ bool, accum []Value) []Value {\n\t// all own keys are enumerable\n\tif o.fieldsInfo != nil {\n\t\tfor _, name := range o.fieldsInfo.Names {\n\t\t\taccum = append(accum, newStringValue(name))\n\t\t}\n\t}\n\n\tfor _, name := range o.methodsInfo.Names {\n\t\taccum = append(accum, newStringValue(name))\n\t}\n\n\treturn accum\n}\n\nfunc (o *objectGoReflect) export(*objectExportCtx) interface{} {\n\treturn o.origValue.Interface()\n}\n\nfunc (o *objectGoReflect) exportType() reflect.Type {\n\treturn o.origValue.Type()\n}\n\nfunc (o *objectGoReflect) equal(other objectImpl) bool {\n\tif other, ok := other.(*objectGoReflect); ok {\n\t\tk1, k2 := o.fieldsValue.Kind(), other.fieldsValue.Kind()\n\t\tif k1 == k2 {\n\t\t\tif isContainer(k1) {\n\t\t\t\treturn o.fieldsValue == other.fieldsValue\n\t\t\t}\n\t\t\treturn o.fieldsValue.Interface() == other.fieldsValue.Interface()\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (o *objectGoReflect) reflectValue() reflect.Value {\n\treturn o.fieldsValue\n}\n\nfunc (o *objectGoReflect) setReflectValue(v reflect.Value) {\n\to.fieldsValue = v\n\to.origValue = v\n\to.methodsValue = v.Addr()\n}\n\nfunc (o *objectGoReflect) esValue() Value {\n\treturn o.val\n}\n\nfunc (r *Runtime) buildFieldInfo(t reflect.Type, index []int, info *reflectFieldsInfo) {\n\tn := t.NumField()\n\tfor i := 0; i < n; i++ {\n\t\tfield := t.Field(i)\n\t\tname := field.Name\n\t\tisExported := ast.IsExported(name)\n\n\t\tif !isExported && !field.Anonymous {\n\t\t\tcontinue\n\t\t}\n\n\t\tif r.fieldNameMapper != nil {\n\t\t\tname = r.fieldNameMapper.FieldName(t, field)\n\t\t}\n\n\t\tif name != \"\" && isExported {\n\t\t\tif inf, exists := info.Fields[name]; !exists {\n\t\t\t\tinfo.Names = append(info.Names, name)\n\t\t\t} else {\n\t\t\t\tif len(inf.Index) <= len(index) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif name != \"\" || field.Anonymous {\n\t\t\tidx := make([]int, len(index)+1)\n\t\t\tcopy(idx, index)\n\t\t\tidx[len(idx)-1] = i\n\n\t\t\tif name != \"\" && isExported {\n\t\t\t\tinfo.Fields[name] = reflectFieldInfo{\n\t\t\t\t\tIndex:     idx,\n\t\t\t\t\tAnonymous: field.Anonymous,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif field.Anonymous {\n\t\t\t\ttyp := field.Type\n\t\t\t\tfor typ.Kind() == reflect.Ptr {\n\t\t\t\t\ttyp = typ.Elem()\n\t\t\t\t}\n\t\t\t\tif typ.Kind() == reflect.Struct {\n\t\t\t\t\tr.buildFieldInfo(typ, idx, info)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar emptyMethodsInfo = reflectMethodsInfo{}\n\nfunc (r *Runtime) buildMethodsInfo(t reflect.Type) (info *reflectMethodsInfo) {\n\tn := t.NumMethod()\n\tif n == 0 {\n\t\treturn &emptyMethodsInfo\n\t}\n\tinfo = new(reflectMethodsInfo)\n\tinfo.Methods = make(map[string]int, n)\n\tinfo.Names = make([]string, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tmethod := t.Method(i)\n\t\tname := method.Name\n\t\tif !ast.IsExported(name) {\n\t\t\tcontinue\n\t\t}\n\t\tif r.fieldNameMapper != nil {\n\t\t\tname = r.fieldNameMapper.MethodName(t, method)\n\t\t\tif name == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif _, exists := info.Methods[name]; !exists {\n\t\t\tinfo.Names = append(info.Names, name)\n\t\t}\n\n\t\tinfo.Methods[name] = i\n\t}\n\treturn\n}\n\nfunc (r *Runtime) buildFieldsInfo(t reflect.Type) (info *reflectFieldsInfo) {\n\tinfo = new(reflectFieldsInfo)\n\tn := t.NumField()\n\tinfo.Fields = make(map[string]reflectFieldInfo, n)\n\tinfo.Names = make([]string, 0, n)\n\tr.buildFieldInfo(t, nil, info)\n\treturn\n}\n\nfunc (r *Runtime) fieldsInfo(t reflect.Type) (info *reflectFieldsInfo) {\n\tvar exists bool\n\tif info, exists = r.fieldsInfoCache[t]; !exists {\n\t\tinfo = r.buildFieldsInfo(t)\n\t\tif r.fieldsInfoCache == nil {\n\t\t\tr.fieldsInfoCache = make(map[reflect.Type]*reflectFieldsInfo)\n\t\t}\n\t\tr.fieldsInfoCache[t] = info\n\t}\n\n\treturn\n}\n\nfunc (r *Runtime) methodsInfo(t reflect.Type) (info *reflectMethodsInfo) {\n\tvar exists bool\n\tif info, exists = r.methodsInfoCache[t]; !exists {\n\t\tinfo = r.buildMethodsInfo(t)\n\t\tif r.methodsInfoCache == nil {\n\t\t\tr.methodsInfoCache = make(map[reflect.Type]*reflectMethodsInfo)\n\t\t}\n\t\tr.methodsInfoCache[t] = info\n\t}\n\n\treturn\n}\n\n// SetFieldNameMapper sets a custom field name mapper for Go types. It can be called at any time, however\n// the mapping for any given value is fixed at the point of creation.\n// Setting this to nil restores the default behaviour which is all exported fields and methods are mapped to their\n// original unchanged names.\nfunc (r *Runtime) SetFieldNameMapper(mapper FieldNameMapper) {\n\tr.fieldNameMapper = mapper\n\tr.fieldsInfoCache = nil\n\tr.methodsInfoCache = nil\n}\n\n// TagFieldNameMapper returns a FieldNameMapper that uses the given tagName for struct fields and optionally\n// uncapitalises (making the first letter lower case) method names.\n// The common tag value syntax is supported (name[,options]), however options are ignored.\n// Setting name to anything other than a valid ECMAScript identifier makes the field hidden.\nfunc TagFieldNameMapper(tagName string, uncapMethods bool) FieldNameMapper {\n\treturn tagFieldNameMapper{\n\t\ttagName:      tagName,\n\t\tuncapMethods: uncapMethods,\n\t}\n}\n\n// UncapFieldNameMapper returns a FieldNameMapper that uncapitalises struct field and method names\n// making the first letter lower case.\nfunc UncapFieldNameMapper() FieldNameMapper {\n\treturn uncapFieldNameMapper{}\n}\n"
        },
        {
          "name": "object_goreflect_test.go",
          "type": "blob",
          "size": 31.1142578125,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGoReflectGet(t *testing.T) {\n\tconst SCRIPT = `\n\to.X + o.Y;\n\t`\n\ttype O struct {\n\t\tX int\n\t\tY string\n\t}\n\tr := New()\n\to := O{X: 4, Y: \"2\"}\n\tr.Set(\"o\", o)\n\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s, ok := v.(String); ok {\n\t\tif s.String() != \"42\" {\n\t\t\tt.Fatalf(\"Unexpected string: %s\", s)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Unexpected type: %s\", v)\n\t}\n}\n\nfunc TestGoReflectSet(t *testing.T) {\n\tconst SCRIPT = `\n\to.X++;\n\to.Y += \"P\";\n\t`\n\ttype O struct {\n\t\tX int\n\t\tY string\n\t}\n\tr := New()\n\to := O{X: 4, Y: \"2\"}\n\tr.Set(\"o\", &o)\n\n\t_, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o.X != 5 {\n\t\tt.Fatalf(\"Unexpected X: %d\", o.X)\n\t}\n\n\tif o.Y != \"2P\" {\n\t\tt.Fatalf(\"Unexpected Y: %s\", o.Y)\n\t}\n\n\tr.Set(\"o\", o)\n\t_, err = r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif res, ok := r.Get(\"o\").Export().(O); ok {\n\t\tif res.X != 6 {\n\t\t\tt.Fatalf(\"Unexpected res.X: %d\", res.X)\n\t\t}\n\n\t\tif res.Y != \"2PP\" {\n\t\t\tt.Fatalf(\"Unexpected res.Y: %s\", res.Y)\n\t\t}\n\t}\n}\n\nfunc TestGoReflectEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar hasX = false;\n\tvar hasY = false;\n\tfor (var key in o) {\n\t\tswitch (key) {\n\t\tcase \"X\":\n\t\t\tif (hasX) {\n\t\t\t\tthrow \"Already have X\";\n\t\t\t}\n\t\t\thasX = true;\n\t\t\tbreak;\n\t\tcase \"Y\":\n\t\t\tif (hasY) {\n\t\t\t\tthrow \"Already have Y\";\n\t\t\t}\n\t\t\thasY = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow \"Unexpected property: \" + key;\n\t\t}\n\t}\n\thasX && hasY;\n\t`\n\n\ttype S struct {\n\t\tX, Y int\n\t}\n\n\tr := New()\n\tr.Set(\"o\", S{X: 40, Y: 2})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n}\n\nfunc TestGoReflectCustomIntUnbox(t *testing.T) {\n\tconst SCRIPT = `\n\ti + 2;\n\t`\n\n\ttype CustomInt int\n\tvar i CustomInt = 40\n\n\tr := New()\n\tr.Set(\"i\", i)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(intToValue(42)) {\n\t\tt.Fatalf(\"Expected int 42, got %v\", v)\n\t}\n}\n\nfunc TestGoReflectPreserveCustomType(t *testing.T) {\n\tconst SCRIPT = `\n\ti;\n\t`\n\n\ttype CustomInt int\n\tvar i CustomInt = 42\n\n\tr := New()\n\tr.Set(\"i\", i)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tve := v.Export()\n\n\tif ii, ok := ve.(CustomInt); ok {\n\t\tif ii != i {\n\t\t\tt.Fatalf(\"Wrong value: %v\", ii)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Wrong type: %v\", ve)\n\t}\n}\n\nfunc TestGoReflectCustomIntValueOf(t *testing.T) {\n\tconst SCRIPT = `\n\tif (i instanceof Number) {\n\t\ti.valueOf();\n\t} else {\n\t\tthrow new Error(\"Value is not a number\");\n\t}\n\t`\n\n\ttype CustomInt int\n\tvar i CustomInt = 42\n\n\tr := New()\n\tr.Set(\"i\", i)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(intToValue(42)) {\n\t\tt.Fatalf(\"Expected int 42, got %v\", v)\n\t}\n}\n\nfunc TestGoReflectEqual(t *testing.T) {\n\tconst SCRIPT = `\n\tx === y;\n\t`\n\n\ttype CustomInt int\n\tvar x CustomInt = 42\n\tvar y CustomInt = 42\n\n\tr := New()\n\tr.Set(\"x\", x)\n\tr.Set(\"y\", y)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\ntype testGoReflectMethod_O struct {\n\tfield string\n\tTest  string\n}\n\nfunc (o testGoReflectMethod_O) Method(s string) string {\n\treturn o.field + s\n}\n\nfunc TestGoReflectMethod(t *testing.T) {\n\tconst SCRIPT = `\n\to.Method(\" 123\")\n\t`\n\n\to := testGoReflectMethod_O{\n\t\tfield: \"test\",\n\t}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(asciiString(\"test 123\")) {\n\t\tt.Fatalf(\"Expected 'test 123', got %v\", v)\n\t}\n}\n\nfunc (o *testGoReflectMethod_O) Set(s string) {\n\to.field = s\n}\n\nfunc (o *testGoReflectMethod_O) Get() string {\n\treturn o.field\n}\n\nfunc TestGoReflectMethodPtr(t *testing.T) {\n\tconst SCRIPT = `\n\to.Set(\"42\")\n\to.Get()\n\t`\n\n\to := testGoReflectMethod_O{\n\t\tfield: \"test\",\n\t}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(asciiString(\"42\")) {\n\t\tt.Fatalf(\"Expected '42', got %v\", v)\n\t}\n}\n\nfunc (b *testBoolS) Method() bool {\n\treturn bool(*b)\n}\n\nfunc TestGoReflectPtrMethodOnNonPtrValue(t *testing.T) {\n\tvar o testGoReflectMethod_O\n\to.Get()\n\tvm := New()\n\tvm.Set(\"o\", o)\n\t_, err := vm.RunString(`o.Get()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = vm.RunString(`o.Method()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar b testBoolS\n\tvm.Set(\"b\", b)\n\t_, err = vm.RunString(`b.Method()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectStructField(t *testing.T) {\n\ttype S struct {\n\t\tF testGoReflectMethod_O\n\t\tB testBoolS\n\t}\n\tvar s S\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\n\tconst SCRIPT = `\n\ts.F.Set(\"Test\");\n\tassert.sameValue(s.F.Method(\"\"), \"Test\", \"1\");\n\n\ts.B = true;\n\tassert.sameValue(s.B.Method(), true, \"2\");\n\n\tassert.sameValue(s.B.toString(), \"B\", \"3\");\n\t`\n\n\tvm.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestGoReflectProp(t *testing.T) {\n\tconst SCRIPT = `\n\tvar d1 = Object.getOwnPropertyDescriptor(o, \"Get\");\n\tvar d2 = Object.getOwnPropertyDescriptor(o, \"Test\");\n\t!d1.writable && !d1.configurable && d2.writable && !d2.configurable;\n\t`\n\n\to := testGoReflectMethod_O{\n\t\tfield: \"test\",\n\t}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGoReflectRedefineFieldSuccess(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(o, \"Test\", {value: \"AAA\"}) === o;\n\t`\n\n\to := testGoReflectMethod_O{}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n\tif o.Test != \"AAA\" {\n\t\tt.Fatalf(\"Expected 'AAA', got '%s'\", o.Test)\n\t}\n\n}\n\nfunc TestGoReflectRedefineFieldNonWritable(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown = false;\n\ttry {\n\t\tObject.defineProperty(o, \"Test\", {value: \"AAA\", writable: false});\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\n\to := testGoReflectMethod_O{Test: \"Test\"}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n\tif o.Test != \"Test\" {\n\t\tt.Fatalf(\"Expected 'Test', got: '%s'\", o.Test)\n\t}\n}\n\nfunc TestGoReflectRedefineFieldConfigurable(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown = false;\n\ttry {\n\t\tObject.defineProperty(o, \"Test\", {value: \"AAA\", configurable: true});\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\n\to := testGoReflectMethod_O{Test: \"Test\"}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n\tif o.Test != \"Test\" {\n\t\tt.Fatalf(\"Expected 'Test', got: '%s'\", o.Test)\n\t}\n}\n\nfunc TestGoReflectRedefineMethod(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown = false;\n\ttry {\n\t\tObject.defineProperty(o, \"Method\", {value: \"AAA\", configurable: true});\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tthrown = true;\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrown;\n\t`\n\n\to := testGoReflectMethod_O{Test: \"Test\"}\n\n\tr := New()\n\tr.Set(\"o\", &o)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n}\n\nfunc TestGoReflectEmbeddedStruct(t *testing.T) {\n\tconst SCRIPT = `\n\tif (o.ParentField2 !== \"ParentField2\") {\n\t\tthrow new Error(\"ParentField2 = \" + o.ParentField2);\n\t}\n\n\tif (o.Parent.ParentField2 !== 2) {\n\t\tthrow new Error(\"o.Parent.ParentField2 = \" + o.Parent.ParentField2);\n\t}\n\n\tif (o.ParentField1 !== 1) {\n\t\tthrow new Error(\"o.ParentField1 = \" + o.ParentField1);\n\n\t}\n\n\tif (o.ChildField !== 3) {\n\t\tthrow new Error(\"o.ChildField = \" + o.ChildField);\n\t}\n\n\tvar keys = {};\n\tfor (var k in o) {\n\t\tif (keys[k]) {\n\t\t\tthrow new Error(\"Duplicate key: \" + k);\n\t\t}\n\t\tkeys[k] = true;\n\t}\n\n\tvar expectedKeys = [\"ParentField2\", \"ParentField1\", \"Parent\", \"ChildField\"];\n\tfor (var i in expectedKeys) {\n\t\tif (!keys[expectedKeys[i]]) {\n\t\t\tthrow new Error(\"Missing key in enumeration: \" + expectedKeys[i]);\n\t\t}\n\t\tdelete keys[expectedKeys[i]];\n\t}\n\n\tvar remainingKeys = Object.keys(keys);\n\tif (remainingKeys.length > 0) {\n\t\tthrow new Error(\"Unexpected keys: \" + remainingKeys);\n\t}\n\n\to.ParentField2 = \"ParentField22\";\n\to.Parent.ParentField2 = 22;\n\to.ParentField1 = 11;\n\to.ChildField = 33;\n\t`\n\n\ttype Parent struct {\n\t\tParentField1 int\n\t\tParentField2 int\n\t}\n\n\ttype Child struct {\n\t\tParentField2 string\n\t\tParent\n\t\tChildField int\n\t}\n\n\tvm := New()\n\to := Child{\n\t\tParent: Parent{\n\t\t\tParentField1: 1,\n\t\t\tParentField2: 2,\n\t\t},\n\t\tParentField2: \"ParentField2\",\n\t\tChildField:   3,\n\t}\n\tvm.Set(\"o\", &o)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o.ParentField2 != \"ParentField22\" {\n\t\tt.Fatalf(\"ParentField2 = %q\", o.ParentField2)\n\t}\n\n\tif o.Parent.ParentField2 != 22 {\n\t\tt.Fatalf(\"Parent.ParentField2 = %d\", o.Parent.ParentField2)\n\t}\n\n\tif o.ParentField1 != 11 {\n\t\tt.Fatalf(\"ParentField1 = %d\", o.ParentField1)\n\t}\n\n\tif o.ChildField != 33 {\n\t\tt.Fatalf(\"ChildField = %d\", o.ChildField)\n\t}\n}\n\ntype jsonTagNamer struct{}\n\nfunc (jsonTagNamer) FieldName(_ reflect.Type, field reflect.StructField) string {\n\tif jsonTag := field.Tag.Get(\"json\"); jsonTag != \"\" {\n\t\treturn jsonTag\n\t}\n\treturn field.Name\n}\n\nfunc (jsonTagNamer) MethodName(_ reflect.Type, method reflect.Method) string {\n\treturn method.Name\n}\n\nfunc TestGoReflectCustomNaming(t *testing.T) {\n\n\ttype testStructWithJsonTags struct {\n\t\tA string `json:\"b\"` // <-- script sees field \"A\" as property \"b\"\n\t}\n\n\to := &testStructWithJsonTags{\"Hello world\"}\n\tr := New()\n\tr.SetFieldNameMapper(&jsonTagNamer{})\n\tr.Set(\"fn\", func() *testStructWithJsonTags { return o })\n\n\tt.Run(\"get property\", func(t *testing.T) {\n\t\tv, err := r.RunString(`fn().b`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !v.StrictEquals(newStringValue(o.A)) {\n\t\t\tt.Fatalf(\"Expected %q, got %v\", o.A, v)\n\t\t}\n\t})\n\n\tt.Run(\"set property\", func(t *testing.T) {\n\t\t_, err := r.RunString(`fn().b = \"Hello universe\"`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif o.A != \"Hello universe\" {\n\t\t\tt.Fatalf(\"Expected \\\"Hello universe\\\", got %q\", o.A)\n\t\t}\n\t})\n\n\tt.Run(\"enumerate properties\", func(t *testing.T) {\n\t\tv, err := r.RunString(`Object.keys(fn())`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(v.Export(), []interface{}{\"b\"}) {\n\t\t\tt.Fatalf(\"Expected [\\\"b\\\"], got %v\", v.Export())\n\t\t}\n\t})\n}\n\nfunc TestGoReflectCustomObjNaming(t *testing.T) {\n\n\ttype testStructWithJsonTags struct {\n\t\tA string `json:\"b\"` // <-- script sees field \"A\" as property \"b\"\n\t}\n\n\tr := New()\n\tr.SetFieldNameMapper(&jsonTagNamer{})\n\n\tt.Run(\"Set object in slice\", func(t *testing.T) {\n\t\ttestSlice := &[]testStructWithJsonTags{{\"Hello world\"}}\n\t\tr.Set(\"testslice\", testSlice)\n\t\t_, err := r.RunString(`testslice[0] = {b:\"setted\"}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif (*testSlice)[0].A != \"setted\" {\n\t\t\tt.Fatalf(\"Expected \\\"setted\\\", got %q\", (*testSlice)[0])\n\t\t}\n\t})\n\n\tt.Run(\"Set object in map\", func(t *testing.T) {\n\t\ttestMap := map[string]testStructWithJsonTags{\"key\": {\"Hello world\"}}\n\t\tr.Set(\"testmap\", testMap)\n\t\t_, err := r.RunString(`testmap[\"key\"] = {b:\"setted\"}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif testMap[\"key\"].A != \"setted\" {\n\t\t\tt.Fatalf(\"Expected \\\"setted\\\", got %q\", testMap[\"key\"])\n\t\t}\n\t})\n\n\tt.Run(\"Add object to map\", func(t *testing.T) {\n\t\ttestMap := map[string]testStructWithJsonTags{}\n\t\tr.Set(\"testmap\", testMap)\n\t\t_, err := r.RunString(`testmap[\"newkey\"] = {b:\"setted\"}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif testMap[\"newkey\"].A != \"setted\" {\n\t\t\tt.Fatalf(\"Expected \\\"setted\\\", got %q\", testMap[\"newkey\"])\n\t\t}\n\t})\n}\n\ntype fieldNameMapper1 struct{}\n\nfunc (fieldNameMapper1) FieldName(_ reflect.Type, f reflect.StructField) string {\n\treturn strings.ToLower(f.Name)\n}\n\nfunc (fieldNameMapper1) MethodName(_ reflect.Type, m reflect.Method) string {\n\treturn m.Name\n}\n\nfunc TestNonStructAnonFields(t *testing.T) {\n\ttype Test1 struct {\n\t\tM bool\n\t}\n\ttype test3 []int\n\ttype Test4 []int\n\ttype Test2 struct {\n\t\ttest3\n\t\tTest4\n\t\t*Test1\n\t}\n\n\tconst SCRIPT = `\n\tJSON.stringify(a);\n\ta.m && a.test3 === undefined && a.test4.length === 2\n\t`\n\tvm := New()\n\tvm.SetFieldNameMapper(fieldNameMapper1{})\n\tvm.Set(\"a\", &Test2{Test1: &Test1{M: true}, Test4: []int{1, 2}, test3: nil})\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Unexepected result: %v\", v)\n\t}\n}\n\nfunc TestStructNonAddressable(t *testing.T) {\n\ttype S struct {\n\t\tField int\n\t}\n\n\tconst SCRIPT = `\n\t\"use strict\";\n\t\n\tif (!Object.getOwnPropertyDescriptor(s, \"Field\").writable) {\n\t\tthrow new Error(\"s.Field is non-writable\");\n\t}\n\n\tif (!Object.getOwnPropertyDescriptor(s1, \"Field\").writable) {\n\t\tthrow new Error(\"s1.Field is non-writable\");\n\t}\n\n\ts1.Field = 42;\n\ts.Field = 43;\n\ts;\n`\n\n\tvar s S\n\tvm := New()\n\tvm.Set(\"s\", s)\n\tvm.Set(\"s1\", &s)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texp := v.Export()\n\tif s1, ok := exp.(S); ok {\n\t\tif s1.Field != 43 {\n\t\t\tt.Fatal(s1)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Wrong type: %T\", exp)\n\t}\n\tif s.Field != 42 {\n\t\tt.Fatalf(\"Unexpected s.Field value: %d\", s.Field)\n\t}\n}\n\ntype testFieldMapper struct {\n}\n\nfunc (testFieldMapper) FieldName(_ reflect.Type, f reflect.StructField) string {\n\tif tag := f.Tag.Get(\"js\"); tag != \"\" {\n\t\tif tag == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn tag\n\t}\n\n\treturn f.Name\n}\n\nfunc (testFieldMapper) MethodName(_ reflect.Type, m reflect.Method) string {\n\treturn m.Name\n}\n\nfunc TestHidingAnonField(t *testing.T) {\n\ttype InnerType struct {\n\t\tAnotherField string\n\t}\n\n\ttype OuterType struct {\n\t\tInnerType `js:\"-\"`\n\t\tSomeField string\n\t}\n\n\tconst SCRIPT = `\n\tvar a = Object.getOwnPropertyNames(o);\n\tif (a.length !== 2) {\n\t\tthrow new Error(\"unexpected length: \" + a.length);\n\t}\n\n\tif (a.indexOf(\"SomeField\") === -1) {\n\t\tthrow new Error(\"no SomeField\");\n\t}\n\n\tif (a.indexOf(\"AnotherField\") === -1) {\n\t\tthrow new Error(\"no SomeField\");\n\t}\n\t`\n\n\tvar o OuterType\n\n\tvm := New()\n\tvm.SetFieldNameMapper(testFieldMapper{})\n\tvm.Set(\"o\", &o)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestFieldOverriding(t *testing.T) {\n\ttype InnerType struct {\n\t\tAnotherField  string\n\t\tAnotherField1 string\n\t}\n\n\ttype OuterType struct {\n\t\tInnerType     `js:\"-\"`\n\t\tSomeField     string\n\t\tAnotherField  string `js:\"-\"`\n\t\tAnotherField1 string\n\t}\n\n\tconst SCRIPT = `\n\tif (o.SomeField !== \"SomeField\") {\n\t\tthrow new Error(\"SomeField\");\n\t}\n\n\tif (o.AnotherField !== \"AnotherField inner\") {\n\t\tthrow new Error(\"AnotherField\");\n\t}\n\n\tif (o.AnotherField1 !== \"AnotherField1 outer\") {\n\t\tthrow new Error(\"AnotherField1\");\n\t}\n\n\tif (o.InnerType) {\n\t\tthrow new Error(\"InnerType is present\");\n\t}\n\t`\n\n\to := OuterType{\n\t\tInnerType: InnerType{\n\t\t\tAnotherField:  \"AnotherField inner\",\n\t\t\tAnotherField1: \"AnotherField1 inner\",\n\t\t},\n\t\tSomeField:     \"SomeField\",\n\t\tAnotherField:  \"AnotherField outer\",\n\t\tAnotherField1: \"AnotherField1 outer\",\n\t}\n\n\tvm := New()\n\tvm.SetFieldNameMapper(testFieldMapper{})\n\tvm.Set(\"o\", &o)\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDefinePropertyUnexportedJsName(t *testing.T) {\n\ttype T struct {\n\t\tField      int\n\t\tunexported int\n\t}\n\n\tvm := New()\n\tvm.SetFieldNameMapper(fieldNameMapper1{})\n\tvm.Set(\"f\", &T{unexported: 0})\n\n\t_, err := vm.RunString(`\n\t\"use strict\";\n\tObject.defineProperty(f, \"field\", {value: 42});\n\tif (f.field !== 42) {\n\t\tthrow new Error(\"Unexpected value: \" + f.field);\n\t}\n\tif (f.hasOwnProperty(\"unexported\")) {\n\t\tthrow new Error(\"hasOwnProperty('unexported') is true\");\n\t}\n\tvar thrown;\n\ttry {\n\t\tObject.defineProperty(f, \"unexported\", {value: 1});\n\t} catch (e) {\n\t\tthrown = e;\n\t}\n\tif (!(thrown instanceof TypeError)) {\n\t\tthrow new Error(\"Unexpected error: \", thrown);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype fieldNameMapperToLower struct{}\n\nfunc (fieldNameMapperToLower) FieldName(_ reflect.Type, f reflect.StructField) string {\n\treturn strings.ToLower(f.Name)\n}\n\nfunc (fieldNameMapperToLower) MethodName(_ reflect.Type, m reflect.Method) string {\n\treturn strings.ToLower(m.Name)\n}\n\nfunc TestHasOwnPropertyUnexportedJsName(t *testing.T) {\n\tvm := New()\n\tvm.SetFieldNameMapper(fieldNameMapperToLower{})\n\tvm.Set(\"f\", &testGoReflectMethod_O{})\n\n\t_, err := vm.RunString(`\n\t\"use strict\";\n\tif (!f.hasOwnProperty(\"test\")) {\n\t\tthrow new Error(\"hasOwnProperty('test') returned false\");\n\t}\n\tif (!f.hasOwnProperty(\"method\")) {\n\t\tthrow new Error(\"hasOwnProperty('method') returned false\");\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc BenchmarkGoReflectGet(b *testing.B) {\n\ttype parent struct {\n\t\tfield, Test1, Test2, Test3, Test4, Test5, Test string\n\t}\n\n\ttype child struct {\n\t\tparent\n\t\tTest6 string\n\t}\n\n\tb.StopTimer()\n\tvm := New()\n\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tv := vm.ToValue(child{parent: parent{Test: \"Test\", field: \"\"}}).(*Object)\n\t\tv.Get(\"Test\")\n\t}\n}\n\nfunc TestNestedStructSet(t *testing.T) {\n\ttype B struct {\n\t\tField int\n\t}\n\ttype A struct {\n\t\tB B\n\t}\n\n\tconst SCRIPT = `\n\t'use strict';\n\ta.B.Field++;\n\tif (a1.B.Field != 1) {\n\t\tthrow new Error(\"a1.B.Field = \" + a1.B.Field);\n\t}\n\tvar d = Object.getOwnPropertyDescriptor(a1.B, \"Field\");\n\tif (!d.writable) {\n\t\tthrow new Error(\"a1.B is not writable\");\n\t}\n\ta1.B.Field = 42;\n\ta1;\n\t`\n\ta := A{\n\t\tB: B{\n\t\t\tField: 1,\n\t\t},\n\t}\n\tvm := New()\n\tvm.Set(\"a\", &a)\n\tvm.Set(\"a1\", a)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texp := v.Export()\n\tif v, ok := exp.(A); ok {\n\t\tif v.B.Field != 42 {\n\t\t\tt.Fatal(v)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Wrong type: %T\", exp)\n\t}\n\n\tif v := a.B.Field; v != 2 {\n\t\tt.Fatalf(\"Unexpected a.B.Field: %d\", v)\n\t}\n}\n\nfunc TestStructNonAddressableAnonStruct(t *testing.T) {\n\n\ttype C struct {\n\t\tZ int64\n\t\tX string\n\t}\n\n\ttype B struct {\n\t\tC\n\t\tY string\n\t}\n\n\ttype A struct {\n\t\tB B\n\t}\n\n\ta := A{\n\t\tB: B{\n\t\t\tC: C{\n\t\t\t\tZ: 1,\n\t\t\t\tX: \"X2\",\n\t\t\t},\n\t\t\tY: \"Y3\",\n\t\t},\n\t}\n\tconst SCRIPT = `\n\t\"use strict\";\n\tvar s = JSON.stringify(a);\n\ts;\n`\n\n\tvm := New()\n\tvm.Set(\"a\", &a)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := `{\"B\":{\"C\":{\"Z\":1,\"X\":\"X2\"},\"Z\":1,\"X\":\"X2\",\"Y\":\"Y3\"}}`\n\tif expected != v.String() {\n\t\tt.Fatalf(\"Expected '%s', got '%s'\", expected, v.String())\n\t}\n\n}\n\nfunc TestTagFieldNameMapperInvalidId(t *testing.T) {\n\tvm := New()\n\tvm.SetFieldNameMapper(TagFieldNameMapper(\"json\", true))\n\ttype S struct {\n\t\tField int `json:\"-\"`\n\t}\n\tvm.Set(\"s\", S{Field: 42})\n\tres, err := vm.RunString(`s.hasOwnProperty(\"field\") || s.hasOwnProperty(\"Field\")`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res != valueFalse {\n\t\tt.Fatalf(\"Unexpected result: %v\", res)\n\t}\n}\n\nfunc TestPrimitivePtr(t *testing.T) {\n\tvm := New()\n\ts := \"test\"\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(`s instanceof String && s == \"test\"`) // note non-strict equality\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v := res.ToBoolean(); !v {\n\t\tt.Fatalf(\"value: %#v\", res)\n\t}\n\ts = \"test1\"\n\tres, err = vm.RunString(`s == \"test1\"`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v := res.ToBoolean(); !v {\n\t\tt.Fatalf(\"value: %#v\", res)\n\t}\n}\n\nfunc TestStringer(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"e\", errors.New(\"test\"))\n\tres, err := vm.RunString(\"e.toString()\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v := res.Export(); v != \"test\" {\n\t\tt.Fatalf(\"v: %v\", v)\n\t}\n}\n\nfunc ExampleTagFieldNameMapper() {\n\tvm := New()\n\tvm.SetFieldNameMapper(TagFieldNameMapper(\"json\", true))\n\ttype S struct {\n\t\tField int `json:\"field\"`\n\t}\n\tvm.Set(\"s\", S{Field: 42})\n\tres, _ := vm.RunString(`s.field`)\n\tfmt.Println(res.Export())\n\t// Output: 42\n}\n\nfunc ExampleUncapFieldNameMapper() {\n\tvm := New()\n\ts := testGoReflectMethod_O{\n\t\tTest: \"passed\",\n\t}\n\tvm.SetFieldNameMapper(UncapFieldNameMapper())\n\tvm.Set(\"s\", s)\n\tres, _ := vm.RunString(`s.test + \" and \" + s.method(\"passed too\")`)\n\tfmt.Println(res.Export())\n\t// Output: passed and passed too\n}\n\nfunc TestGoReflectWithProto(t *testing.T) {\n\ttype S struct {\n\t\tField int\n\t}\n\tvar s S\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\tvm.testScriptWithTestLib(`\n\t(function() {\n\t'use strict';\n\tvar proto = {\n\t\tField: \"protoField\",\n\t\ttest: 42\n\t};\n\tvar test1Holder;\n\tObject.defineProperty(proto, \"test1\", {\n\t\tset: function(v) {\n\t\t\ttest1Holder = v;\n\t\t},\n\t\tget: function() {\n\t\t\treturn test1Holder;\n\t\t}\n\t});\n\tObject.setPrototypeOf(s, proto);\n\tassert.sameValue(s.Field, 0, \"s.Field\");\n\ts.Field = 2;\n\tassert.sameValue(s.Field, 2, \"s.Field\");\n\tassert.sameValue(s.test, 42, \"s.test\");\n\tassert.throws(TypeError, function() {\n\t\tObject.defineProperty(s, \"test\", {value: 43});\n\t});\n\ttest1Holder = 1;\n\tassert.sameValue(s.test1, 1, \"s.test1\");\n\ts.test1 = 2;\n\tassert.sameValue(test1Holder, 2, \"test1Holder\");\n\t})();\n\t`, _undefined, t)\n}\n\nfunc TestGoReflectSymbols(t *testing.T) {\n\ttype S struct {\n\t\tField int\n\t}\n\tvar s S\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`\n\t'use strict';\n\tvar sym = Symbol(66);\n\ts[sym] = \"Test\";\n\tif (s[sym] !== \"Test\") {\n\t\tthrow new Error(\"s[sym]=\" + s[sym]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectSymbolEqualityQuirk(t *testing.T) {\n\ttype Field struct {\n\t}\n\ttype S struct {\n\t\tField *Field\n\t}\n\tvar s = S{\n\t\tField: &Field{},\n\t}\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(`\n\tvar sym = Symbol(66);\n\tvar field1 = s.Field;\n\tfield1[sym] = true;\n\tvar field2 = s.Field;\n\t// Because a wrapper is created every time the property is accessed\n\t// field1 and field2 will be different instances of the wrapper.\n\t// Symbol properties only exist in the wrapper, they cannot be placed into the original Go value,\n\t// hence the following:\n\tfield1 === field2 && field1[sym] === true && field2[sym] === undefined;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res != valueTrue {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestGoObj__Proto__(t *testing.T) {\n\ttype S struct {\n\t\tField int\n\t}\n\tvm := New()\n\tvm.Set(\"s\", S{})\n\tvm.Set(\"m\", map[string]interface{}{})\n\tvm.Set(\"mr\", map[int]string{})\n\tvm.Set(\"a\", []interface{}{})\n\tvm.Set(\"ar\", []string{})\n\t_, err := vm.RunString(`\n\tfunction f(s, expectedCtor, prefix) {\n\t\tif (s.__proto__ !== expectedCtor.prototype) {\n\t\t\tthrow new Error(prefix + \": __proto__: \" + s.__proto__);\n\t\t}\n\t\ts.__proto__ = null;\n\t\tif (s.__proto__ !== undefined) { // as there is no longer a prototype, there is no longer the __proto__ property\n\t\t\tthrow new Error(prefix + \": __proto__ is not undefined: \" + s.__proto__);\n\t\t}\n\t\tvar proto = Object.getPrototypeOf(s);\n\t\tif (proto !== null) {\n\t\t\tthrow new Error(prefix + \": proto is not null: \" + proto);\n\t\t}\n\t}\n\tf(s, Object, \"struct\");\n\tf(m, Object, \"simple map\");\n\tf(mr, Object, \"reflect map\");\n\tf(a, Array, \"slice\");\n\tf(ar, Array, \"reflect slice\");\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectUnicodeProps(t *testing.T) {\n\ttype S struct {\n\t\t string\n\t}\n\tvm := New()\n\tvar s S\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`\n\tif (!s.hasOwnProperty(\"\")) {\n\t\tthrow new Error(\"hasOwnProperty\");\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectPreserveType(t *testing.T) {\n\tvm := New()\n\tvar expect = time.Duration(math.MaxInt64)\n\tvm.Set(`make`, func() time.Duration {\n\t\treturn expect\n\t})\n\tvm.Set(`handle`, func(d time.Duration) {\n\t\tif d.String() != expect.String() {\n\t\t\tt.Fatal(`expect`, expect, `, but get`, d)\n\t\t}\n\t})\n\t_, e := vm.RunString(`\n\tvar d=make()\n\thandle(d)\n\t`)\n\tif e != nil {\n\t\tt.Fatal(e)\n\t}\n}\n\nfunc TestGoReflectCopyOnWrite(t *testing.T) {\n\ttype Inner struct {\n\t\tField int\n\t}\n\ttype S struct {\n\t\tI Inner\n\t}\n\tvar s S\n\ts.I.Field = 1\n\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`\n\t\tif (s.I.Field !== 1) {\n\t\t\tthrow new Error(\"s.I.Field: \" + s.I.Field);\n\t\t}\n\n\t\tlet tmp = s.I; // tmp becomes a reference to s.I\n\t\tif (tmp.Field !== 1) {\n\t\t\tthrow new Error(\"tmp.Field: \" + tmp.Field);\n\t\t}\n\n\t\ts.I.Field = 2;\n\t\tif (s.I.Field !== 2) {\n\t\t\tthrow new Error(\"s.I.Field (1): \" + s.I.Field);\n\t\t}\n\t\tif (tmp.Field !== 2) {\n\t\t\tthrow new Error(\"tmp.Field (1): \" + tmp.Field);\n\t\t}\n\n\t\ts.I = {Field: 3}; // at this point tmp is changed to a copy\n\t\tif (s.I.Field !== 3) {\n\t\t\tthrow new Error(\"s.I.Field (2): \" + s.I.Field);\n\t\t}\n\t\tif (tmp.Field !== 2) {\n\t\t\tthrow new Error(\"tmp.Field (2): \" + tmp.Field);\n\t\t}\n\t`)\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReflectSetReflectValue(t *testing.T) {\n\to := []testGoReflectMethod_O{{}}\n\tvm := New()\n\tvm.Set(\"o\", o)\n\t_, err := vm.RunString(`\n\t\tconst t = o[0];\n\t\tt.Set(\"a\");\n\t\to[0] = {};\n\t\to[0].Set(\"b\");\n\t\tif (t.Get() !== \"a\") {\n\t\t\tthrow new Error();\n\t\t}\n\t`)\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReflectOverwriteReflectMap(t *testing.T) {\n\tvm := New()\n\ttype S struct {\n\t\tM map[int]interface{}\n\t}\n\tvar s S\n\ts.M = map[int]interface{}{\n\t\t0: true,\n\t}\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`\n\ts.M = {1: false};\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, exists := s.M[0]; exists {\n\t\tt.Fatal(s)\n\t}\n}\n\ntype testBoolS bool\n\nfunc (testBoolS) String() string {\n\treturn \"B\"\n}\n\ntype testIntS int\n\nfunc (testIntS) String() string {\n\treturn \"I\"\n}\n\ntype testStringS string\n\nfunc (testStringS) String() string {\n\treturn \"S\"\n}\n\nfunc TestGoReflectToPrimitive(t *testing.T) {\n\tvm := New()\n\n\tf := func(expr string, expected Value, t *testing.T) {\n\t\tv, err := vm.RunString(expr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif IsNaN(expected) {\n\t\t\tif IsNaN(v) {\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif v.StrictEquals(expected) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tt.Fatalf(\"%s: expected: %v, actual: %v\", expr, expected, v)\n\t}\n\n\tt.Run(\"Not Stringers\", func(t *testing.T) {\n\t\ttype Bool bool\n\t\tvar b Bool = true\n\n\t\tt.Run(\"Bool\", func(t *testing.T) {\n\t\t\tvm.Set(\"b\", b)\n\t\t\tf(\"+b\", intToValue(1), t)\n\t\t\tf(\"`${b}`\", asciiString(\"true\"), t)\n\t\t\tf(\"b.toString()\", asciiString(\"true\"), t)\n\t\t\tf(\"b.valueOf()\", valueTrue, t)\n\t\t})\n\n\t\tt.Run(\"*Bool\", func(t *testing.T) {\n\t\t\tvm.Set(\"b\", &b)\n\t\t\tf(\"+b\", intToValue(1), t)\n\t\t\tf(\"`${b}`\", asciiString(\"true\"), t)\n\t\t\tf(\"b.toString()\", asciiString(\"true\"), t)\n\t\t\tf(\"b.valueOf()\", valueTrue, t)\n\t\t})\n\n\t\ttype Int int\n\t\tvar i Int = 1\n\n\t\tt.Run(\"Int\", func(t *testing.T) {\n\t\t\tvm.Set(\"i\", i)\n\t\t\tf(\"+i\", intToValue(1), t)\n\t\t\tf(\"`${i}`\", asciiString(\"1\"), t)\n\t\t\tf(\"i.toString()\", asciiString(\"1\"), t)\n\t\t\tf(\"i.valueOf()\", intToValue(1), t)\n\t\t})\n\n\t\tt.Run(\"*Int\", func(t *testing.T) {\n\t\t\tvm.Set(\"i\", &i)\n\t\t\tf(\"+i\", intToValue(1), t)\n\t\t\tf(\"`${i}`\", asciiString(\"1\"), t)\n\t\t\tf(\"i.toString()\", asciiString(\"1\"), t)\n\t\t\tf(\"i.valueOf()\", intToValue(1), t)\n\t\t})\n\n\t\ttype Uint uint\n\t\tvar ui Uint = 1\n\n\t\tt.Run(\"Uint\", func(t *testing.T) {\n\t\t\tvm.Set(\"ui\", ui)\n\t\t\tf(\"+ui\", intToValue(1), t)\n\t\t\tf(\"`${ui}`\", asciiString(\"1\"), t)\n\t\t\tf(\"ui.toString()\", asciiString(\"1\"), t)\n\t\t\tf(\"ui.valueOf()\", intToValue(1), t)\n\t\t})\n\n\t\tt.Run(\"*Uint\", func(t *testing.T) {\n\t\t\tvm.Set(\"ui\", &i)\n\t\t\tf(\"+ui\", intToValue(1), t)\n\t\t\tf(\"`${ui}`\", asciiString(\"1\"), t)\n\t\t\tf(\"ui.toString()\", asciiString(\"1\"), t)\n\t\t\tf(\"ui.valueOf()\", intToValue(1), t)\n\t\t})\n\n\t\ttype Float float64\n\t\tvar fl Float = 1.1\n\n\t\tt.Run(\"Float\", func(t *testing.T) {\n\t\t\tvm.Set(\"fl\", fl)\n\t\t\tf(\"+fl\", floatToValue(1.1), t)\n\t\t\tf(\"`${fl}`\", asciiString(\"1.1\"), t)\n\t\t\tf(\"fl.toString()\", asciiString(\"1.1\"), t)\n\t\t\tf(\"fl.valueOf()\", floatToValue(1.1), t)\n\t\t})\n\n\t\tt.Run(\"*Float\", func(t *testing.T) {\n\t\t\tvm.Set(\"fl\", &fl)\n\t\t\tf(\"+fl\", floatToValue(1.1), t)\n\t\t\tf(\"`${fl}`\", asciiString(\"1.1\"), t)\n\t\t\tf(\"fl.toString()\", asciiString(\"1.1\"), t)\n\t\t\tf(\"fl.valueOf()\", floatToValue(1.1), t)\n\t\t})\n\n\t\tfl = Float(math.Inf(1))\n\t\tt.Run(\"FloatInf\", func(t *testing.T) {\n\t\t\tvm.Set(\"fl\", fl)\n\t\t\tf(\"+fl\", _positiveInf, t)\n\t\t\tf(\"fl.toString()\", asciiString(\"Infinity\"), t)\n\t\t})\n\n\t\ttype Empty struct{}\n\n\t\tvar e Empty\n\t\tt.Run(\"Empty\", func(t *testing.T) {\n\t\t\tvm.Set(\"e\", &e)\n\t\t\tf(\"+e\", _NaN, t)\n\t\t\tf(\"`${e}`\", asciiString(\"[object Object]\"), t)\n\t\t\tf(\"e.toString()\", asciiString(\"[object Object]\"), t)\n\t\t\tf(\"e.valueOf()\", vm.ToValue(&e), t)\n\t\t})\n\t})\n\n\tt.Run(\"Stringers\", func(t *testing.T) {\n\t\tvar b testBoolS = true\n\t\tt.Run(\"Bool\", func(t *testing.T) {\n\t\t\tvm.Set(\"b\", b)\n\t\t\tf(\"`${b}`\", asciiString(\"B\"), t)\n\t\t\tf(\"b.toString()\", asciiString(\"B\"), t)\n\t\t\tf(\"b.valueOf()\", valueTrue, t)\n\t\t\tf(\"+b\", intToValue(1), t)\n\t\t})\n\n\t\tt.Run(\"*Bool\", func(t *testing.T) {\n\t\t\tvm.Set(\"b\", &b)\n\t\t\tf(\"`${b}`\", asciiString(\"B\"), t)\n\t\t\tf(\"b.toString()\", asciiString(\"B\"), t)\n\t\t\tf(\"b.valueOf()\", valueTrue, t)\n\t\t\tf(\"+b\", intToValue(1), t)\n\t\t})\n\n\t\tvar i testIntS = 1\n\t\tt.Run(\"Int\", func(t *testing.T) {\n\t\t\tvm.Set(\"i\", i)\n\t\t\tf(\"`${i}`\", asciiString(\"I\"), t)\n\t\t\tf(\"i.toString()\", asciiString(\"I\"), t)\n\t\t\tf(\"i.valueOf()\", intToValue(1), t)\n\t\t\tf(\"+i\", intToValue(1), t)\n\t\t})\n\n\t\tt.Run(\"*Int\", func(t *testing.T) {\n\t\t\tvm.Set(\"i\", &i)\n\t\t\tf(\"`${i}`\", asciiString(\"I\"), t)\n\t\t\tf(\"i.toString()\", asciiString(\"I\"), t)\n\t\t\tf(\"i.valueOf()\", intToValue(1), t)\n\t\t\tf(\"+i\", intToValue(1), t)\n\t\t})\n\n\t\tvar s testStringS\n\t\tt.Run(\"String\", func(t *testing.T) {\n\t\t\tvm.Set(\"s\", s)\n\t\t\tf(\"`${s}`\", asciiString(\"S\"), t)\n\t\t\tf(\"s.toString()\", asciiString(\"S\"), t)\n\t\t\tf(\"s.valueOf()\", asciiString(\"S\"), t)\n\t\t\tf(\"+s\", _NaN, t)\n\t\t})\n\n\t\tt.Run(\"*String\", func(t *testing.T) {\n\t\t\tvm.Set(\"s\", &s)\n\t\t\tf(\"`${s}`\", asciiString(\"S\"), t)\n\t\t\tf(\"s.toString()\", asciiString(\"S\"), t)\n\t\t\tf(\"s.valueOf()\", asciiString(\"S\"), t)\n\t\t\tf(\"+s\", _NaN, t)\n\t\t})\n\t})\n}\n\ntype testGoReflectFuncRt struct {\n}\n\nfunc (*testGoReflectFuncRt) M(call FunctionCall, r *Runtime) Value {\n\tif r == nil {\n\t\tpanic(typeError(\"Runtime is nil\"))\n\t}\n\treturn call.Argument(0)\n}\n\nfunc (*testGoReflectFuncRt) C(call ConstructorCall, r *Runtime) *Object {\n\tif r == nil {\n\t\tpanic(typeError(\"Runtime is nil in constructor\"))\n\t}\n\tcall.This.Set(\"r\", call.Argument(0))\n\treturn nil\n}\n\nfunc TestGoReflectFuncWithRuntime(t *testing.T) {\n\tvm := New()\n\tvar s testGoReflectFuncRt\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(\"s.M(true)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res != valueTrue {\n\t\tt.Fatal(res)\n\t}\n\n\tres, err = vm.RunString(\"new s.C(true).r\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif res != valueTrue {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestGoReflectDefaultToString(t *testing.T) {\n\tvar s testStringS\n\tvm := New()\n\tv := vm.ToValue(s).(*Object)\n\tv.Delete(\"toString\")\n\tv.Delete(\"valueOf\")\n\tvm.Set(\"s\", v)\n\t_, err := vm.RunString(`\n\t\tclass S {\n\t\t\ttoString() {\n\t\t\t\treturn \"X\";\n\t\t\t}\n\t\t}\n\n\t\tif (s.toString() !== \"S\") {\n\t\t\tthrow new Error(s.toString());\n\t\t}\n\t\tif ((\"\" + s) !== \"S\") {\n\t\t\tthrow new Error(\"\" + s);\n\t\t}\n\n\t\tObject.setPrototypeOf(s, S.prototype);\n\t\tif (s.toString() !== \"X\") {\n\t\t\tthrow new Error(s.toString());\n\t\t}\n\t\tif ((\"\" + s) !== \"X\") {\n\t\t\tthrow new Error(\"\" + s);\n\t\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoReflectUnexportedEmbedStruct(t *testing.T) {\n\ttype privateEmbed struct {\n\t\tA string\n\t}\n\ttype PublicEmbed struct {\n\t\tB string\n\t}\n\ttype privateNested struct {\n\t\tC string\n\t}\n\ttype PublicNested struct {\n\t\tD string\n\t}\n\ttype Foo struct {\n\t\tprivateEmbed\n\t\tPublicEmbed\n\n\t\tprivateNested privateNested\n\t\tPublicNested  PublicNested\n\n\t\te string\n\t\tF string\n\t}\n\n\tvm := New()\n\tvm.Set(\"foo\", Foo{\n\t\tprivateEmbed:  privateEmbed{A: \"testA\"},\n\t\tPublicEmbed:   PublicEmbed{B: \"testB\"},\n\t\tprivateNested: privateNested{C: \"testC\"},\n\t\tPublicNested:  PublicNested{D: \"testD\"},\n\t\te:             \"testE\",\n\t\tF:             \"testF\",\n\t})\n\n\tscenarios := []struct {\n\t\texpr     string\n\t\texpected string\n\t}{\n\t\t{\"foo.privateEmbed\", \"undefined\"},\n\t\t{\"foo.A\", \"testA\"},\n\t\t// ---\n\t\t{\"foo.PublicEmbed\", \"[object Object]\"},\n\t\t{\"foo.B\", \"testB\"},\n\t\t{\"foo.PublicEmbed.B\", \"testB\"},\n\t\t// ---\n\t\t{\"foo.privateNested\", \"undefined\"},\n\t\t{\"foo.C\", \"undefined\"},\n\t\t// ---\n\t\t{\"foo.PublicNested\", \"[object Object]\"},\n\t\t{\"foo.D\", \"undefined\"},\n\t\t{\"foo.PublicNested.D\", \"testD\"},\n\t\t// ---\n\t\t{\"foo.e\", \"undefined\"},\n\t\t{\"foo.F\", \"testF\"},\n\t}\n\n\tfor _, s := range scenarios {\n\t\tt.Run(s.expr, func(t *testing.T) {\n\t\t\tv, err := vm.RunString(s.expr)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tvStr := v.String()\n\n\t\t\tif vStr != s.expected {\n\t\t\t\tt.Fatalf(\"Expected %q, got %q\", s.expected, vStr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNestedSliceAddr(t *testing.T) {\n\ttype document struct {\n\t\tItems []any\n\t}\n\n\tvar d document\n\truntime := New()\n\truntime.Set(\"d\", &d)\n\n\t_, err := runtime.RunString(`\n\td.Items.push(\"Hello\");\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(d.Items) != 1 || d.Items[0] != \"Hello\" {\n\t\tt.Fatal(d.Items)\n\t}\n}\n"
        },
        {
          "name": "object_goslice.go",
          "type": "blob",
          "size": 7.759765625,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype objectGoSlice struct {\n\tbaseObject\n\tdata       *[]interface{}\n\tlengthProp valueProperty\n\torigIsPtr  bool\n}\n\nfunc (r *Runtime) newObjectGoSlice(data *[]interface{}, isPtr bool) *objectGoSlice {\n\tobj := &Object{runtime: r}\n\ta := &objectGoSlice{\n\t\tbaseObject: baseObject{\n\t\t\tval: obj,\n\t\t},\n\t\tdata:      data,\n\t\torigIsPtr: isPtr,\n\t}\n\tobj.self = a\n\ta.init()\n\n\treturn a\n}\n\nfunc (o *objectGoSlice) init() {\n\to.baseObject.init()\n\to.class = classArray\n\to.prototype = o.val.runtime.getArrayPrototype()\n\to.lengthProp.writable = true\n\to.extensible = true\n\to.baseObject._put(\"length\", &o.lengthProp)\n}\n\nfunc (o *objectGoSlice) updateLen() {\n\to.lengthProp.value = intToValue(int64(len(*o.data)))\n}\n\nfunc (o *objectGoSlice) _getIdx(idx int) Value {\n\treturn o.val.runtime.ToValue((*o.data)[idx])\n}\n\nfunc (o *objectGoSlice) getStr(name unistring.String, receiver Value) Value {\n\tvar ownProp Value\n\tif idx := strToGoIdx(name); idx >= 0 && idx < len(*o.data) {\n\t\townProp = o._getIdx(idx)\n\t} else if name == \"length\" {\n\t\to.updateLen()\n\t\townProp = &o.lengthProp\n\t}\n\n\treturn o.getStrWithOwnProp(ownProp, name, receiver)\n}\n\nfunc (o *objectGoSlice) getIdx(idx valueInt, receiver Value) Value {\n\tif idx := int64(idx); idx >= 0 && idx < int64(len(*o.data)) {\n\t\treturn o._getIdx(int(idx))\n\t}\n\tif o.prototype != nil {\n\t\tif receiver == nil {\n\t\t\treturn o.prototype.self.getIdx(idx, o.val)\n\t\t}\n\t\treturn o.prototype.self.getIdx(idx, receiver)\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoSlice) getOwnPropStr(name unistring.String) Value {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif idx < len(*o.data) {\n\t\t\treturn &valueProperty{\n\t\t\t\tvalue:      o._getIdx(idx),\n\t\t\t\twritable:   true,\n\t\t\t\tenumerable: true,\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif name == \"length\" {\n\t\to.updateLen()\n\t\treturn &o.lengthProp\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoSlice) getOwnPropIdx(idx valueInt) Value {\n\tif idx := int64(idx); idx >= 0 && idx < int64(len(*o.data)) {\n\t\treturn &valueProperty{\n\t\t\tvalue:      o._getIdx(int(idx)),\n\t\t\twritable:   true,\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (o *objectGoSlice) grow(size int) {\n\toldcap := cap(*o.data)\n\tif oldcap < size {\n\t\tn := make([]interface{}, size, growCap(size, len(*o.data), oldcap))\n\t\tcopy(n, *o.data)\n\t\t*o.data = n\n\t} else {\n\t\ttail := (*o.data)[len(*o.data):size]\n\t\tfor k := range tail {\n\t\t\ttail[k] = nil\n\t\t}\n\t\t*o.data = (*o.data)[:size]\n\t}\n}\n\nfunc (o *objectGoSlice) shrink(size int) {\n\ttail := (*o.data)[size:]\n\tfor k := range tail {\n\t\ttail[k] = nil\n\t}\n\t*o.data = (*o.data)[:size]\n}\n\nfunc (o *objectGoSlice) putIdx(idx int, v Value, throw bool) {\n\tif idx >= len(*o.data) {\n\t\to.grow(idx + 1)\n\t}\n\t(*o.data)[idx] = v.Export()\n}\n\nfunc (o *objectGoSlice) putLength(v uint32, throw bool) bool {\n\tif bits.UintSize == 32 && v > math.MaxInt32 {\n\t\tpanic(rangeError(\"Integer value overflows 32-bit int\"))\n\t}\n\tnewLen := int(v)\n\tcurLen := len(*o.data)\n\tif newLen > curLen {\n\t\to.grow(newLen)\n\t} else if newLen < curLen {\n\t\to.shrink(newLen)\n\t}\n\treturn true\n}\n\nfunc (o *objectGoSlice) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\tif i := toIntStrict(int64(idx)); i >= 0 {\n\t\tif i >= len(*o.data) {\n\t\t\tif res, ok := o._setForeignIdx(idx, nil, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\to.putIdx(i, val, throw)\n\t} else {\n\t\tname := idx.string()\n\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); !ok {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Can't set property '%s' on Go slice\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *objectGoSlice) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif idx >= len(*o.data) {\n\t\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); ok {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t\to.putIdx(idx, val, throw)\n\t} else {\n\t\tif name == \"length\" {\n\t\t\treturn o.putLength(o.val.runtime.toLengthUint32(val), throw)\n\t\t}\n\t\tif res, ok := o._setForeignStr(name, nil, val, o.val, throw); !ok {\n\t\t\to.val.runtime.typeErrorResult(throw, \"Can't set property '%s' on Go slice\", name)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *objectGoSlice) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignIdx(idx, trueValIfPresent(o.hasOwnPropertyIdx(idx)), val, receiver, throw)\n}\n\nfunc (o *objectGoSlice) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn o._setForeignStr(name, trueValIfPresent(o.hasOwnPropertyStr(name)), val, receiver, throw)\n}\n\nfunc (o *objectGoSlice) hasOwnPropertyIdx(idx valueInt) bool {\n\tif idx := int64(idx); idx >= 0 {\n\t\treturn idx < int64(len(*o.data))\n\t}\n\treturn false\n}\n\nfunc (o *objectGoSlice) hasOwnPropertyStr(name unistring.String) bool {\n\tif idx := strToIdx64(name); idx >= 0 {\n\t\treturn idx < int64(len(*o.data))\n\t}\n\treturn name == \"length\"\n}\n\nfunc (o *objectGoSlice) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\tif i := toIntStrict(int64(idx)); i >= 0 {\n\t\tif !o.val.runtime.checkHostObjectPropertyDescr(idx.string(), descr, throw) {\n\t\t\treturn false\n\t\t}\n\t\tval := descr.Value\n\t\tif val == nil {\n\t\t\tval = _undefined\n\t\t}\n\t\to.putIdx(i, val, throw)\n\t\treturn true\n\t}\n\to.val.runtime.typeErrorResult(throw, \"Cannot define property '%d' on a Go slice\", idx)\n\treturn false\n}\n\nfunc (o *objectGoSlice) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif idx := strToGoIdx(name); idx >= 0 {\n\t\tif !o.val.runtime.checkHostObjectPropertyDescr(name, descr, throw) {\n\t\t\treturn false\n\t\t}\n\t\tval := descr.Value\n\t\tif val == nil {\n\t\t\tval = _undefined\n\t\t}\n\t\to.putIdx(idx, val, throw)\n\t\treturn true\n\t}\n\tif name == \"length\" {\n\t\treturn o.val.runtime.defineArrayLength(&o.lengthProp, descr, o.putLength, throw)\n\t}\n\to.val.runtime.typeErrorResult(throw, \"Cannot define property '%s' on a Go slice\", name)\n\treturn false\n}\n\nfunc (o *objectGoSlice) _deleteIdx(idx int64) {\n\tif idx < int64(len(*o.data)) {\n\t\t(*o.data)[idx] = nil\n\t}\n}\n\nfunc (o *objectGoSlice) deleteStr(name unistring.String, throw bool) bool {\n\tif idx := strToIdx64(name); idx >= 0 {\n\t\to._deleteIdx(idx)\n\t\treturn true\n\t}\n\treturn o.baseObject.deleteStr(name, throw)\n}\n\nfunc (o *objectGoSlice) deleteIdx(i valueInt, throw bool) bool {\n\tidx := int64(i)\n\tif idx >= 0 {\n\t\to._deleteIdx(idx)\n\t}\n\treturn true\n}\n\ntype goslicePropIter struct {\n\to          *objectGoSlice\n\tidx, limit int\n}\n\nfunc (i *goslicePropIter) next() (propIterItem, iterNextFunc) {\n\tif i.idx < i.limit && i.idx < len(*i.o.data) {\n\t\tname := strconv.Itoa(i.idx)\n\t\ti.idx++\n\t\treturn propIterItem{name: newStringValue(name), enumerable: _ENUM_TRUE}, i.next\n\t}\n\n\treturn propIterItem{}, nil\n}\n\nfunc (o *objectGoSlice) iterateStringKeys() iterNextFunc {\n\treturn (&goslicePropIter{\n\t\to:     o,\n\t\tlimit: len(*o.data),\n\t}).next\n}\n\nfunc (o *objectGoSlice) stringKeys(_ bool, accum []Value) []Value {\n\tfor i := range *o.data {\n\t\taccum = append(accum, asciiString(strconv.Itoa(i)))\n\t}\n\n\treturn accum\n}\n\nfunc (o *objectGoSlice) export(*objectExportCtx) interface{} {\n\tif o.origIsPtr {\n\t\treturn o.data\n\t}\n\treturn *o.data\n}\n\nfunc (o *objectGoSlice) exportType() reflect.Type {\n\tif o.origIsPtr {\n\t\treturn reflectTypeArrayPtr\n\t}\n\treturn reflectTypeArray\n}\n\nfunc (o *objectGoSlice) equal(other objectImpl) bool {\n\tif other, ok := other.(*objectGoSlice); ok {\n\t\treturn o.data == other.data\n\t}\n\treturn false\n}\n\nfunc (o *objectGoSlice) esValue() Value {\n\treturn o.val\n}\n\nfunc (o *objectGoSlice) reflectValue() reflect.Value {\n\treturn reflect.ValueOf(o.data).Elem()\n}\n\nfunc (o *objectGoSlice) setReflectValue(value reflect.Value) {\n\to.data = value.Addr().Interface().(*[]interface{})\n}\n\nfunc (o *objectGoSlice) sortLen() int {\n\treturn len(*o.data)\n}\n\nfunc (o *objectGoSlice) sortGet(i int) Value {\n\treturn o.getIdx(valueInt(i), nil)\n}\n\nfunc (o *objectGoSlice) swap(i int, j int) {\n\t(*o.data)[i], (*o.data)[j] = (*o.data)[j], (*o.data)[i]\n}\n"
        },
        {
          "name": "object_goslice_reflect.go",
          "type": "blob",
          "size": 2.216796875,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n\t\"reflect\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype objectGoSliceReflect struct {\n\tobjectGoArrayReflect\n}\n\nfunc (o *objectGoSliceReflect) init() {\n\to.objectGoArrayReflect._init()\n\to.lengthProp.writable = true\n\to.putIdx = o._putIdx\n}\n\nfunc (o *objectGoSliceReflect) _putIdx(idx int, v Value, throw bool) bool {\n\tif idx >= o.fieldsValue.Len() {\n\t\to.grow(idx + 1)\n\t}\n\treturn o.objectGoArrayReflect._putIdx(idx, v, throw)\n}\n\nfunc (o *objectGoSliceReflect) grow(size int) {\n\toldcap := o.fieldsValue.Cap()\n\tif oldcap < size {\n\t\tn := reflect.MakeSlice(o.fieldsValue.Type(), size, growCap(size, o.fieldsValue.Len(), oldcap))\n\t\treflect.Copy(n, o.fieldsValue)\n\t\to.fieldsValue.Set(n)\n\t\tl := len(o.valueCache)\n\t\tif l > size {\n\t\t\tl = size\n\t\t}\n\t\tfor i, w := range o.valueCache[:l] {\n\t\t\tif w != nil {\n\t\t\t\tw.setReflectValue(o.fieldsValue.Index(i))\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttail := o.fieldsValue.Slice(o.fieldsValue.Len(), size)\n\t\tzero := reflect.Zero(o.fieldsValue.Type().Elem())\n\t\tfor i := 0; i < tail.Len(); i++ {\n\t\t\ttail.Index(i).Set(zero)\n\t\t}\n\t\to.fieldsValue.SetLen(size)\n\t}\n}\n\nfunc (o *objectGoSliceReflect) shrink(size int) {\n\to.valueCache.shrink(size)\n\ttail := o.fieldsValue.Slice(size, o.fieldsValue.Len())\n\tzero := reflect.Zero(o.fieldsValue.Type().Elem())\n\tfor i := 0; i < tail.Len(); i++ {\n\t\ttail.Index(i).Set(zero)\n\t}\n\to.fieldsValue.SetLen(size)\n}\n\nfunc (o *objectGoSliceReflect) putLength(v uint32, throw bool) bool {\n\tif bits.UintSize == 32 && v > math.MaxInt32 {\n\t\tpanic(rangeError(\"Integer value overflows 32-bit int\"))\n\t}\n\tnewLen := int(v)\n\tcurLen := o.fieldsValue.Len()\n\tif newLen > curLen {\n\t\to.grow(newLen)\n\t} else if newLen < curLen {\n\t\to.shrink(newLen)\n\t}\n\treturn true\n}\n\nfunc (o *objectGoSliceReflect) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif name == \"length\" {\n\t\treturn o.putLength(o.val.runtime.toLengthUint32(val), throw)\n\t}\n\treturn o.objectGoArrayReflect.setOwnStr(name, val, throw)\n}\n\nfunc (o *objectGoSliceReflect) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif name == \"length\" {\n\t\treturn o.val.runtime.defineArrayLength(&o.lengthProp, descr, o.putLength, throw)\n\t}\n\treturn o.objectGoArrayReflect.defineOwnPropertyStr(name, descr, throw)\n}\n"
        },
        {
          "name": "object_goslice_reflect_test.go",
          "type": "blob",
          "size": 9.568359375,
          "content": "package goja\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGoSliceReflectBasic(t *testing.T) {\n\tconst SCRIPT = `\n\tvar sum = 0;\n\tfor (var i = 0; i < a.length; i++) {\n\t\tsum += a[i];\n\t}\n\tsum;\n\t`\n\tr := New()\n\tr.Set(\"a\", []int{1, 2, 3, 4})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.ToInteger(); i != 10 {\n\t\tt.Fatalf(\"Expected 10, got: %d\", i)\n\t}\n\n}\n\nfunc TestGoSliceReflectIn(t *testing.T) {\n\tconst SCRIPT = `\n\tvar idx = \"\";\n\tfor (var i in a) {\n\t\tidx += i;\n\t}\n\tidx;\n\t`\n\tr := New()\n\tr.Set(\"a\", []int{1, 2, 3, 4})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.String(); i != \"0123\" {\n\t\tt.Fatalf(\"Expected '0123', got: '%s'\", i)\n\t}\n}\n\nfunc TestGoSliceReflectSet(t *testing.T) {\n\tconst SCRIPT = `\n\ta[0] = 33;\n\ta[1] = 333;\n\ta[2] = \"42\";\n\ta[3] = {};\n\ta[4] = 0;\n\t`\n\tr := New()\n\ta := []int8{1, 2, 3, 4}\n\tr.Set(\"a\", a)\n\t_, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif a[0] != 33 {\n\t\tt.Fatalf(\"a[0] = %d, expected 33\", a[0])\n\t}\n\tif a[1] != 77 {\n\t\tt.Fatalf(\"a[1] = %d, expected 77\", a[1])\n\t}\n\tif a[2] != 42 {\n\t\tt.Fatalf(\"a[2] = %d, expected 42\", a[2])\n\t}\n\tif a[3] != 0 {\n\t\tt.Fatalf(\"a[3] = %d, expected 0\", a[3])\n\t}\n}\n\nfunc TestGoSliceReflectPush(t *testing.T) {\n\n\tr := New()\n\n\tt.Run(\"Can push to array by array ptr\", func(t *testing.T) {\n\t\ta := []int8{1}\n\t\tr.Set(\"a\", &a)\n\t\t_, err := r.RunString(`a.push (10)`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif a[1] != 10 {\n\t\t\tt.Fatalf(\"a[1] = %d, expected 10\", a[1])\n\t\t}\n\t})\n\n\tt.Run(\"Can push to array by struct ptr\", func(t *testing.T) {\n\t\ttype testStr struct {\n\t\t\tA []int\n\t\t}\n\t\ta := testStr{\n\t\t\tA: []int{2},\n\t\t}\n\n\t\tr.Set(\"a\", &a)\n\t\t_, err := r.RunString(`a.A.push (10)`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif a.A[1] != 10 {\n\t\t\tt.Fatalf(\"a[1] = %v, expected 10\", a)\n\t\t}\n\t})\n\n}\n\nfunc TestGoSliceReflectStructField(t *testing.T) {\n\tvm := New()\n\tvar s struct {\n\t\tA []int\n\t\tB *[]int\n\t}\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`\n\t\t'use strict';\n\t\ts.A.push(1);\n\t\tif (s.B !== null) {\n\t\t\tthrow new Error(\"s.B is not null: \" + s.B);\n\t\t}\n\t\ts.B = [2];\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(s.A) != 1 || s.A[0] != 1 {\n\t\tt.Fatalf(\"s.A: %v\", s.A)\n\t}\n\tif len(*s.B) != 1 || (*s.B)[0] != 2 {\n\t\tt.Fatalf(\"s.B: %v\", *s.B)\n\t}\n}\n\nfunc TestGoSliceReflectExportToStructField(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`({A: [1], B: [2]})`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar s struct {\n\t\tA []int\n\t\tB *[]int\n\t}\n\terr = vm.ExportTo(v, &s)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(s.A) != 1 || s.A[0] != 1 {\n\t\tt.Fatalf(\"s.A: %v\", s.A)\n\t}\n\tif len(*s.B) != 1 || (*s.B)[0] != 2 {\n\t\tt.Fatalf(\"s.B: %v\", *s.B)\n\t}\n}\n\nfunc TestGoSliceReflectProtoMethod(t *testing.T) {\n\tconst SCRIPT = `\n\ta.join(\",\")\n\t`\n\n\tr := New()\n\ta := []int8{1, 2, 3, 4}\n\tr.Set(\"a\", a)\n\tret, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif s := ret.String(); s != \"1,2,3,4\" {\n\t\tt.Fatalf(\"Unexpected result: '%s'\", s)\n\t}\n}\n\ntype gosliceReflect_withMethods []interface{}\n\nfunc (s gosliceReflect_withMethods) Method() bool {\n\treturn true\n}\n\nfunc TestGoSliceReflectMethod(t *testing.T) {\n\tconst SCRIPT = `\n\ttypeof a === \"object\" && a[0] === 42 && a.Method() === true;\n\t`\n\n\tvm := New()\n\ta := make(gosliceReflect_withMethods, 1)\n\ta[0] = 42\n\tvm.Set(\"a\", a)\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Expected true, got %v\", v)\n\t}\n\n}\n\nfunc TestGoSliceReflectGetStr(t *testing.T) {\n\tr := New()\n\tv := r.ToValue([]string{\"test\"})\n\tif o, ok := v.(*Object); ok {\n\t\tif e := o.Get(\"0\").Export(); e != \"test\" {\n\t\t\tt.Fatalf(\"Unexpected o.Get(\\\"0\\\"): %v\", e)\n\t\t}\n\t}\n}\n\nfunc TestGoSliceReflectNilObjectIfaceVal(t *testing.T) {\n\tr := New()\n\ta := []Value{(*Object)(nil)}\n\tr.Set(\"a\", a)\n\tret, err := r.RunString(`\n\t\"\"+a[0];\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !asciiString(\"null\").SameAs(ret) {\n\t\tt.Fatalf(\"ret: %v\", ret)\n\t}\n}\n\nfunc TestGoSliceReflectSetLength(t *testing.T) {\n\tr := New()\n\ta := []int{1, 2, 3, 4}\n\tb := []testing.TB{&testing.T{}, &testing.T{}, (*testing.T)(nil)}\n\tr.Set(\"a\", &a)\n\tr.Set(\"b\", &b)\n\t_, err := r.RunString(`\n\t'use strict';\n\ta.length = 3;\n\tif (a.length !== 3) {\n\t\tthrow new Error(\"length=\"+a.length);\n\t}\n\tif (a[3] !== undefined) {\n\t\tthrow new Error(\"a[3]=\"+a[3]);\n\t}\n\ta.length = 5;\n\tif (a.length !== 5) {\n\t\tthrow new Error(\"a.length=\"+a.length);\n\t}\n\tif (a[3] !== 0) {\n\t\tthrow new Error(\"a[3]=\"+a[3]);\n\t}\n\tif (a[4] !== 0) {\n\t\tthrow new Error(\"a[4]=\"+a[4]);\n\t}\n\n\tb.length = 3;\n\tif (b.length !== 3) {\n\t\tthrow new Error(\"b.length=\"+b.length);\n\t}\n\tif (b[3] !== undefined) {\n\t\tthrow new Error(\"b[3]=\"+b[3]);\n\t}\n\tb.length = 5;\n\tif (b.length !== 5) {\n\t\tthrow new Error(\"length=\"+b.length);\n\t}\n\tif (b[3] !== null) {\n\t\tthrow new Error(\"b[3]=\"+b[3]);\n\t}\n\tif (b[4] !== null) {\n\t\tthrow new Error(\"b[4]=\"+b[4]);\n\t}\n\tif (b[2] !== null) {\n\t\tthrow new Error(\"b[2]=\"+b[2]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoSliceReflectProto(t *testing.T) {\n\tr := New()\n\ta := []*Object{{}, nil, {}}\n\tr.Set(\"a\", &a)\n\tr.testScriptWithTestLib(`\n\tvar proto = [,2,,4];\n\tObject.setPrototypeOf(a, proto);\n\tassert.sameValue(a[1], null, \"a[1]\");\n\tassert.sameValue(a[3], 4, \"a[3]\");\n\tvar desc = Object.getOwnPropertyDescriptor(a, \"1\");\n\tassert.sameValue(desc.value, null, \"desc.value\");\n\tassert(desc.writable, \"writable\");\n\tassert(desc.enumerable, \"enumerable\");\n\tassert(!desc.configurable, \"configurable\");\n\tvar v5;\n\tObject.defineProperty(proto, \"5\", {\n\t\tset: function(v) {\n\t\t\tv5 = v;\n\t\t}\n\t});\n\ta[5] = \"test\";\n\tassert.sameValue(v5, \"test\", \"v5\");\n\t`, _undefined, t)\n}\n\nfunc TestGoSliceReflectProtoProto(t *testing.T) {\n\tr := New()\n\ta := []*Object{{}, nil, {}}\n\tproto := []*Object{{}, {}, {}, {}}\n\tr.Set(\"a\", &a)\n\tr.Set(\"proto\", proto)\n\t_, err := r.RunString(`\n\t\"use strict\";\n\tvar protoproto = {};\n\tObject.defineProperty(protoproto, \"3\", {\n\t\tvalue: 42\n\t});\n\tObject.setPrototypeOf(proto, protoproto);\n\tObject.setPrototypeOf(a, proto);\n\tif (a.hasOwnProperty(\"3\")) {\n\t\tthrow new Error(\"a.hasOwnProperty(\\\"3\\\")\");\n\t}\n\tif (a[3] !== null) {\n\t\tthrow new Error(\"a[3]=\"+a[3]);\n\t}\n\ta[3] = null;\n\tif (a[3] !== null) {\n\t\tthrow new Error(\"a[3]=\" + a[3]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n}\n\nfunc TestGoSliceReflectDelete(t *testing.T) {\n\tr := New()\n\ta := []*Object{{}, nil, {}}\n\tr.Set(\"a\", a)\n\tv, err := r.RunString(`\n\tdelete a[0] && delete a[1] && delete a[3];\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != valueTrue {\n\t\tt.Fatalf(\"not true: %v\", v)\n\t}\n}\n\nfunc TestGoSliceReflectPop(t *testing.T) {\n\tr := New()\n\ta := []string{\"1\", \"\", \"3\"}\n\tr.Set(\"a\", &a)\n\tv, err := r.RunString(`\n\ta.pop()\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.SameAs(asciiString(\"3\")) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestGoSliceReflectPopNoPtr(t *testing.T) {\n\tr := New()\n\ta := []string{\"1\", \"\", \"3\"}\n\tr.Set(\"a\", a)\n\tv, err := r.RunString(`\n\ta.pop()\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.SameAs(asciiString(\"3\")) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestGoSliceReflectLengthProperty(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"s\", []int{2, 3, 4})\n\t_, err := vm.RunString(`\n\tif (!s.hasOwnProperty(\"length\")) {\n\t\tthrow new Error(\"hasOwnProperty() returned false\");\n\t}\n\tlet desc = Object.getOwnPropertyDescriptor(s, \"length\");\n\tif (desc.value !== 3 || !desc.writable || desc.enumerable || desc.configurable) {\n\t\tthrow new Error(\"incorrect property descriptor: \" + JSON.stringify(desc));\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype testCustomSliceWithMethods []int\n\nfunc (a testCustomSliceWithMethods) Method() bool {\n\treturn true\n}\n\nfunc TestGoSliceReflectMethods(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"s\", testCustomSliceWithMethods{1, 2, 3})\n\t_, err := vm.RunString(`\n\tif (!s.hasOwnProperty(\"Method\")) {\n\t\tthrow new Error(\"hasOwnProperty() returned false\");\n\t}\n\tlet desc = Object.getOwnPropertyDescriptor(s, \"Method\");\n\tif (desc.value() !== true || desc.writable || !desc.enumerable || desc.configurable) {\n\t\tthrow new Error(\"incorrect property descriptor: \" + JSON.stringify(desc));\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoSliceReflectExportAfterGrow(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"a\", []int{1})\n\tv, err := vm.RunString(`\n\t\ta.push(2);\n\t\ta;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texp := v.Export()\n\tif a, ok := exp.([]int); ok {\n\t\tif len(a) != 2 || a[0] != 1 || a[1] != 2 {\n\t\t\tt.Fatal(a)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Wrong type: %T\", exp)\n\t}\n}\n\nfunc TestGoSliceReflectSort(t *testing.T) {\n\tvm := New()\n\ttype Thing struct{ Name string }\n\tvm.Set(\"v\", []*Thing{\n\t\t{Name: \"log\"},\n\t\t{Name: \"etc\"},\n\t\t{Name: \"test\"},\n\t\t{Name: \"bin\"},\n\t})\n\tret, err := vm.RunString(`\n//v.sort((a, b) => a.Name.localeCompare(b.Name)).map((x) => x.Name);\n\tconst tmp = v[0];\n\tv[0] = v[1];\n\tv[1] = tmp;\n\tv[0].Name + v[1].Name;\n`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tt.Log(ret.Export())\n}\n\nfunc TestGoSliceReflect111(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"v\", []int32{\n\t\t1, 2,\n\t})\n\tret, err := vm.RunString(`\n//v.sort((a, b) => a.Name.localeCompare(b.Name)).map((x) => x.Name);\n\tconst tmp = v[0];\n\tv[0] = v[1];\n\tv[1] = tmp;\n\t\"\" + v[0] + v[1];\n`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tt.Log(ret.Export())\n\ta := []int{1, 2}\n\ta0 := reflect.ValueOf(a).Index(0)\n\ta0.Set(reflect.ValueOf(0))\n\tt.Log(a[0])\n}\n\nfunc TestGoSliceReflectExternalLenUpdate(t *testing.T) {\n\tdata := &[]int{1}\n\n\tvm := New()\n\tvm.Set(\"data\", data)\n\tvm.Set(\"append\", func(a *[]int, v int) {\n\t\tif a != data {\n\t\t\tpanic(vm.NewTypeError(\"a != data\"))\n\t\t}\n\t\t*a = append(*a, v)\n\t})\n\n\tvm.testScriptWithTestLib(`\n\t\tassert.sameValue(data.length, 1);\n\n        // modify with js\n        data.push(1);\n\t\tassert.sameValue(data.length, 2);\n\n        // modify with go\n        append(data, 2);\n\t\tassert.sameValue(data.length, 3);\n    `, _undefined, t)\n}\n\nfunc BenchmarkGoSliceReflectSet(b *testing.B) {\n\tvm := New()\n\ta := vm.ToValue([]int{1}).(*Object)\n\tb.ResetTimer()\n\tv := intToValue(0)\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Set(\"0\", v)\n\t}\n}\n"
        },
        {
          "name": "object_goslice_test.go",
          "type": "blob",
          "size": 5.453125,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGoSliceBasic(t *testing.T) {\n\tconst SCRIPT = `\n\tvar sum = 0;\n\tfor (var i = 0; i < a.length; i++) {\n\t\tsum += a[i];\n\t}\n\tsum;\n\t`\n\tr := New()\n\tr.Set(\"a\", []interface{}{1, 2, 3, 4})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.ToInteger(); i != 10 {\n\t\tt.Fatalf(\"Expected 10, got: %d\", i)\n\t}\n}\n\nfunc TestGoSliceIn(t *testing.T) {\n\tconst SCRIPT = `\n\tvar idx = \"\";\n\tfor (var i in a) {\n\t\tidx += i;\n\t}\n\tidx;\n\t`\n\tr := New()\n\tr.Set(\"a\", []interface{}{1, 2, 3, 4})\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.String(); i != \"0123\" {\n\t\tt.Fatalf(\"Expected '0123', got: '%s'\", i)\n\t}\n}\n\nfunc TestGoSliceExpand(t *testing.T) {\n\tconst SCRIPT = `\n\tvar l = a.length;\n\tfor (var i = 0; i < l; i++) {\n\t\ta[l + i] = a[i] * 2;\n\t}\n\n\tvar sum = 0;\n\tfor (var i = 0; i < a.length; i++) {\n\t\tsum += a[i];\n\t}\n\tsum;\n\t`\n\tr := New()\n\ta := []interface{}{int64(1), int64(2), int64(3), int64(4)}\n\tr.Set(\"a\", &a)\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsum := int64(0)\n\tfor _, v := range a {\n\t\tsum += v.(int64)\n\t}\n\tif i := v.ToInteger(); i != sum {\n\t\tt.Fatalf(\"Expected %d, got: %d\", sum, i)\n\t}\n}\n\nfunc TestGoSliceProtoMethod(t *testing.T) {\n\tconst SCRIPT = `\n\ta.join(\",\")\n\t`\n\n\tr := New()\n\ta := []interface{}{1, 2, 3, 4}\n\tr.Set(\"a\", a)\n\tret, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif s := ret.String(); s != \"1,2,3,4\" {\n\t\tt.Fatalf(\"Unexpected result: '%s'\", s)\n\t}\n}\n\nfunc TestGoSliceSetLength(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, 2, 3, 4}\n\tr.Set(\"a\", &a)\n\t_, err := r.RunString(`\n\t'use strict';\n\ta.length = 3;\n\tif (a.length !== 3) {\n\t\tthrow new Error(\"length=\"+a.length);\n\t}\n\tif (a[3] !== undefined) {\n\t\tthrow new Error(\"a[3](1)=\"+a[3]);\n\t}\n\ta.length = 5;\n\tif (a.length !== 5) {\n\t\tthrow new Error(\"length=\"+a.length);\n\t}\n\tif (a[3] !== null) {\n\t\tthrow new Error(\"a[3](2)=\"+a[3]);\n\t}\n\tif (a[4] !== null) {\n\t\tthrow new Error(\"a[4]=\"+a[4]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoSliceProto(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tr.Set(\"a\", &a)\n\tr.testScriptWithTestLib(`\n\tvar proto = [,2,,4];\n\tObject.setPrototypeOf(a, proto);\n\tassert.sameValue(a[1], null, \"a[1]\");\n\tassert.sameValue(a[3], 4, \"a[3]\");\n\tvar desc = Object.getOwnPropertyDescriptor(a, \"1\");\n\tassert.sameValue(desc.value, null, \"desc.value\");\n\tassert(desc.writable, \"writable\");\n\tassert(desc.enumerable, \"enumerable\");\n\tassert(!desc.configurable, \"configurable\");\n\tvar v5;\n\tObject.defineProperty(proto, \"5\", {\n\t\tset: function(v) {\n\t\t\tv5 = v;\n\t\t}\n\t});\n\ta[5] = \"test\";\n\tassert.sameValue(v5, \"test\", \"v5\");\n\t`, _undefined, t)\n}\n\nfunc TestGoSliceProtoProto(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tproto := []interface{}{1, 2, 3, 4}\n\tr.Set(\"a\", &a)\n\tr.Set(\"proto\", proto)\n\t_, err := r.RunString(`\n\t\"use strict\";\n\tvar protoproto = Object.create(null);\n\tObject.defineProperty(protoproto, \"3\", {\n\t\tvalue: 42\n\t});\n\tObject.setPrototypeOf(proto, protoproto);\n\tObject.setPrototypeOf(a, proto);\n\ta[3] = 11;\n\tif (a[3] !== 11) {\n\t\tthrow new Error(\"a[3]=\" + a[3]);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoSliceDelete(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tr.Set(\"a\", a)\n\tv, err := r.RunString(`\n\tdelete a[0] && delete a[1] && delete a[3];\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != valueTrue {\n\t\tt.Fatalf(\"not true: %v\", v)\n\t}\n}\n\nfunc TestGoSlicePop(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tr.Set(\"a\", &a)\n\tv, err := r.RunString(`\n\ta.pop()\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.SameAs(intToValue(3)) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestGoSlicePopNoPtr(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tr.Set(\"a\", a)\n\tv, err := r.RunString(`\n\ta.pop()\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.SameAs(intToValue(3)) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestGoSliceShift(t *testing.T) {\n\tr := New()\n\ta := []interface{}{1, nil, 3}\n\tr.Set(\"a\", &a)\n\tv, err := r.RunString(`\n\ta.shift()\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !v.SameAs(intToValue(1)) {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc TestGoSliceLengthProperty(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"s\", []interface{}{2, 3, 4})\n\t_, err := vm.RunString(`\n\tif (!s.hasOwnProperty(\"length\")) {\n\t\tthrow new Error(\"hasOwnProperty() returned false\");\n\t}\n\tlet desc = Object.getOwnPropertyDescriptor(s, \"length\");\n\tif (desc.value !== 3 || !desc.writable || desc.enumerable || desc.configurable) {\n\t\tthrow new Error(\"incorrect property descriptor: \" + JSON.stringify(desc));\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoSliceSort(t *testing.T) {\n\tvm := New()\n\ts := []interface{}{4, 2, 3}\n\tvm.Set(\"s\", &s)\n\t_, err := vm.RunString(`s.sort()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(s) != 3 {\n\t\tt.Fatalf(\"len: %d\", len(s))\n\t}\n\tif s[0] != 2 || s[1] != 3 || s[2] != 4 {\n\t\tt.Fatalf(\"val: %v\", s)\n\t}\n}\n\nfunc TestGoSliceToString(t *testing.T) {\n\tvm := New()\n\ts := []interface{}{4, 2, 3}\n\tvm.Set(\"s\", &s)\n\tres, err := vm.RunString(\"`${s}`\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exp := res.Export(); exp != \"4,2,3\" {\n\t\tt.Fatal(exp)\n\t}\n}\n\nfunc TestGoSliceExternalLenUpdate(t *testing.T) {\n\tdata := &[]interface{}{1}\n\n\tvm := New()\n\tvm.Set(\"data\", data)\n\tvm.Set(\"append\", func(a *[]interface{}, v int) {\n\t\tif a != data {\n\t\t\tpanic(vm.NewTypeError(\"a != data\"))\n\t\t}\n\t\t*a = append(*a, v)\n\t})\n\n\tvm.testScriptWithTestLib(`\n\t\tassert.sameValue(data.length, 1);\n\n        // modify with js\n        data.push(1);\n\t\tassert.sameValue(data.length, 2);\n\n        // modify with go\n        append(data, 2);\n\t\tassert.sameValue(data.length, 3);\n    `, _undefined, t)\n}\n"
        },
        {
          "name": "object_template.go",
          "type": "blob",
          "size": 11.3623046875,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"github.com/dop251/goja/unistring\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n)\n\ntype templatePropFactory func(*Runtime) Value\n\ntype objectTemplate struct {\n\tpropNames []unistring.String\n\tprops     map[unistring.String]templatePropFactory\n\n\tsymProps     map[*Symbol]templatePropFactory\n\tsymPropNames []*Symbol\n\n\tprotoFactory func(*Runtime) *Object\n}\n\ntype templatedObject struct {\n\tbaseObject\n\ttmpl *objectTemplate\n\n\tprotoMaterialised bool\n}\n\ntype templatedFuncObject struct {\n\ttemplatedObject\n\n\tf         func(FunctionCall) Value\n\tconstruct func(args []Value, newTarget *Object) *Object\n}\n\n// This type exists because Array.prototype is supposed to be an array itself and I could not find\n// a different way of implementing it without either introducing another layer of interfaces or hoisting\n// the templates to baseObject both of which would have had a negative effect on the performance.\n// The implementation is as simple as possible and is not optimised in any way, but I very much doubt anybody\n// uses Array.prototype as an actual array.\ntype templatedArrayObject struct {\n\ttemplatedObject\n}\n\nfunc newObjectTemplate() *objectTemplate {\n\treturn &objectTemplate{\n\t\tprops: make(map[unistring.String]templatePropFactory),\n\t}\n}\n\nfunc (t *objectTemplate) putStr(name unistring.String, f templatePropFactory) {\n\tt.props[name] = f\n\tt.propNames = append(t.propNames, name)\n}\n\nfunc (t *objectTemplate) putSym(s *Symbol, f templatePropFactory) {\n\tif t.symProps == nil {\n\t\tt.symProps = make(map[*Symbol]templatePropFactory)\n\t}\n\tt.symProps[s] = f\n\tt.symPropNames = append(t.symPropNames, s)\n}\n\nfunc (r *Runtime) newTemplatedObject(tmpl *objectTemplate, obj *Object) *templatedObject {\n\tif obj == nil {\n\t\tobj = &Object{runtime: r}\n\t}\n\to := &templatedObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      classObject,\n\t\t\tval:        obj,\n\t\t\textensible: true,\n\t\t},\n\t\ttmpl: tmpl,\n\t}\n\tobj.self = o\n\to.init()\n\treturn o\n}\n\nfunc (o *templatedObject) materialiseProto() {\n\tif !o.protoMaterialised {\n\t\tif o.tmpl.protoFactory != nil {\n\t\t\to.prototype = o.tmpl.protoFactory(o.val.runtime)\n\t\t}\n\t\to.protoMaterialised = true\n\t}\n}\n\nfunc (o *templatedObject) getStr(name unistring.String, receiver Value) Value {\n\townProp := o.getOwnPropStr(name)\n\tif ownProp == nil {\n\t\to.materialiseProto()\n\t}\n\treturn o.getStrWithOwnProp(ownProp, name, receiver)\n}\n\nfunc (o *templatedObject) getSym(s *Symbol, receiver Value) Value {\n\townProp := o.getOwnPropSym(s)\n\tif ownProp == nil {\n\t\to.materialiseProto()\n\t}\n\treturn o.getWithOwnProp(ownProp, s, receiver)\n}\n\nfunc (o *templatedObject) getOwnPropStr(p unistring.String) Value {\n\tif v, exists := o.values[p]; exists {\n\t\treturn v\n\t}\n\tif f := o.tmpl.props[p]; f != nil {\n\t\tv := f(o.val.runtime)\n\t\to.values[p] = v\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (o *templatedObject) materialiseSymbols() {\n\tif o.symValues == nil {\n\t\to.symValues = newOrderedMap(nil)\n\t\tfor _, p := range o.tmpl.symPropNames {\n\t\t\to.symValues.set(p, o.tmpl.symProps[p](o.val.runtime))\n\t\t}\n\t}\n}\n\nfunc (o *templatedObject) getOwnPropSym(s *Symbol) Value {\n\tif o.symValues == nil && o.tmpl.symProps[s] == nil {\n\t\treturn nil\n\t}\n\to.materialiseSymbols()\n\treturn o.baseObject.getOwnPropSym(s)\n}\n\nfunc (o *templatedObject) materialisePropNames() {\n\tif o.propNames == nil {\n\t\to.propNames = append(([]unistring.String)(nil), o.tmpl.propNames...)\n\t}\n}\n\nfunc (o *templatedObject) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\texisting := o.getOwnPropStr(p) // materialise property (in case it's an accessor)\n\tif existing == nil {\n\t\to.materialiseProto()\n\t\to.materialisePropNames()\n\t}\n\treturn o.baseObject.setOwnStr(p, v, throw)\n}\n\nfunc (o *templatedObject) setOwnSym(name *Symbol, val Value, throw bool) bool {\n\to.materialiseSymbols()\n\to.materialiseProto()\n\treturn o.baseObject.setOwnSym(name, val, throw)\n}\n\nfunc (o *templatedObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\townProp := o.getOwnPropStr(name)\n\tif ownProp == nil {\n\t\to.materialiseProto()\n\t}\n\treturn o._setForeignStr(name, ownProp, val, receiver, throw)\n}\n\nfunc (o *templatedObject) proto() *Object {\n\to.materialiseProto()\n\treturn o.prototype\n}\n\nfunc (o *templatedObject) setProto(proto *Object, throw bool) bool {\n\to.protoMaterialised = true\n\tret := o.baseObject.setProto(proto, throw)\n\tif ret {\n\t\to.protoMaterialised = true\n\t}\n\treturn ret\n}\n\nfunc (o *templatedObject) setForeignIdx(name valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn o.setForeignStr(name.string(), val, receiver, throw)\n}\n\nfunc (o *templatedObject) setForeignSym(name *Symbol, val, receiver Value, throw bool) (bool, bool) {\n\to.materialiseProto()\n\to.materialiseSymbols()\n\treturn o.baseObject.setForeignSym(name, val, receiver, throw)\n}\n\nfunc (o *templatedObject) hasPropertyStr(name unistring.String) bool {\n\tif o.val.self.hasOwnPropertyStr(name) {\n\t\treturn true\n\t}\n\to.materialiseProto()\n\tif o.prototype != nil {\n\t\treturn o.prototype.self.hasPropertyStr(name)\n\t}\n\treturn false\n}\n\nfunc (o *templatedObject) hasPropertySym(s *Symbol) bool {\n\tif o.hasOwnPropertySym(s) {\n\t\treturn true\n\t}\n\to.materialiseProto()\n\tif o.prototype != nil {\n\t\treturn o.prototype.self.hasPropertySym(s)\n\t}\n\treturn false\n}\n\nfunc (o *templatedObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif v, exists := o.values[name]; exists {\n\t\treturn v != nil\n\t}\n\n\t_, exists := o.tmpl.props[name]\n\treturn exists\n}\n\nfunc (o *templatedObject) hasOwnPropertySym(s *Symbol) bool {\n\tif o.symValues != nil {\n\t\treturn o.symValues.has(s)\n\t}\n\t_, exists := o.tmpl.symProps[s]\n\treturn exists\n}\n\nfunc (o *templatedObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\texistingVal := o.getOwnPropStr(name)\n\tif v, ok := o._defineOwnProperty(name, existingVal, descr, throw); ok {\n\t\to.values[name] = v\n\t\tif existingVal == nil {\n\t\t\to.materialisePropNames()\n\t\t\tnames := copyNamesIfNeeded(o.propNames, 1)\n\t\t\to.propNames = append(names, name)\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (o *templatedObject) defineOwnPropertySym(s *Symbol, descr PropertyDescriptor, throw bool) bool {\n\to.materialiseSymbols()\n\treturn o.baseObject.defineOwnPropertySym(s, descr, throw)\n}\n\nfunc (o *templatedObject) deleteStr(name unistring.String, throw bool) bool {\n\tif val := o.getOwnPropStr(name); val != nil {\n\t\tif !o.checkDelete(name, val, throw) {\n\t\t\treturn false\n\t\t}\n\t\to.materialisePropNames()\n\t\to._delete(name)\n\t\tif _, exists := o.tmpl.props[name]; exists {\n\t\t\to.values[name] = nil // white hole\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (o *templatedObject) deleteSym(s *Symbol, throw bool) bool {\n\to.materialiseSymbols()\n\treturn o.baseObject.deleteSym(s, throw)\n}\n\nfunc (o *templatedObject) materialiseProps() {\n\tfor name, f := range o.tmpl.props {\n\t\tif _, exists := o.values[name]; !exists {\n\t\t\to.values[name] = f(o.val.runtime)\n\t\t}\n\t}\n\to.materialisePropNames()\n}\n\nfunc (o *templatedObject) iterateStringKeys() iterNextFunc {\n\to.materialiseProps()\n\treturn o.baseObject.iterateStringKeys()\n}\n\nfunc (o *templatedObject) iterateSymbols() iterNextFunc {\n\to.materialiseSymbols()\n\treturn o.baseObject.iterateSymbols()\n}\n\nfunc (o *templatedObject) stringKeys(all bool, keys []Value) []Value {\n\tif all {\n\t\to.materialisePropNames()\n\t} else {\n\t\to.materialiseProps()\n\t}\n\treturn o.baseObject.stringKeys(all, keys)\n}\n\nfunc (o *templatedObject) symbols(all bool, accum []Value) []Value {\n\to.materialiseSymbols()\n\treturn o.baseObject.symbols(all, accum)\n}\n\nfunc (o *templatedObject) keys(all bool, accum []Value) []Value {\n\treturn o.symbols(all, o.stringKeys(all, accum))\n}\n\nfunc (r *Runtime) newTemplatedFuncObject(tmpl *objectTemplate, obj *Object, f func(FunctionCall) Value, ctor func([]Value, *Object) *Object) *templatedFuncObject {\n\tif obj == nil {\n\t\tobj = &Object{runtime: r}\n\t}\n\to := &templatedFuncObject{\n\t\ttemplatedObject: templatedObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classFunction,\n\t\t\t\tval:        obj,\n\t\t\t\textensible: true,\n\t\t\t},\n\t\t\ttmpl: tmpl,\n\t\t},\n\t\tf:         f,\n\t\tconstruct: ctor,\n\t}\n\tobj.self = o\n\to.init()\n\treturn o\n}\n\nfunc (f *templatedFuncObject) source() String {\n\treturn newStringValue(fmt.Sprintf(\"function %s() { [native code] }\", nilSafe(f.getStr(\"name\", nil)).toString()))\n}\n\nfunc (f *templatedFuncObject) export(*objectExportCtx) interface{} {\n\treturn f.f\n}\n\nfunc (f *templatedFuncObject) assertCallable() (func(FunctionCall) Value, bool) {\n\tif f.f != nil {\n\t\treturn f.f, true\n\t}\n\treturn nil, false\n}\n\nfunc (f *templatedFuncObject) vmCall(vm *vm, n int) {\n\tvar nf nativeFuncObject\n\tnf.f = f.f\n\tnf.vmCall(vm, n)\n}\n\nfunc (f *templatedFuncObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\treturn f.construct\n}\n\nfunc (f *templatedFuncObject) exportType() reflect.Type {\n\treturn reflectTypeFunc\n}\n\nfunc (f *templatedFuncObject) typeOf() String {\n\treturn stringFunction\n}\n\nfunc (f *templatedFuncObject) hasInstance(v Value) bool {\n\treturn hasInstance(f.val, v)\n}\n\nfunc (r *Runtime) newTemplatedArrayObject(tmpl *objectTemplate, obj *Object) *templatedArrayObject {\n\tif obj == nil {\n\t\tobj = &Object{runtime: r}\n\t}\n\to := &templatedArrayObject{\n\t\ttemplatedObject: templatedObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classArray,\n\t\t\t\tval:        obj,\n\t\t\t\textensible: true,\n\t\t\t},\n\t\t\ttmpl: tmpl,\n\t\t},\n\t}\n\tobj.self = o\n\to.init()\n\treturn o\n}\n\nfunc (a *templatedArrayObject) getLenProp() *valueProperty {\n\tlenProp, _ := a.getOwnPropStr(\"length\").(*valueProperty)\n\tif lenProp == nil {\n\t\tpanic(a.val.runtime.NewTypeError(\"missing length property\"))\n\t}\n\treturn lenProp\n}\n\nfunc (a *templatedArrayObject) _setOwnIdx(idx uint32) {\n\tlenProp := a.getLenProp()\n\tl := uint32(lenProp.value.ToInteger())\n\tif idx >= l {\n\t\tlenProp.value = intToValue(int64(idx) + 1)\n\t}\n}\n\nfunc (a *templatedArrayObject) setLength(l uint32, throw bool) bool {\n\tlenProp := a.getLenProp()\n\toldLen := uint32(lenProp.value.ToInteger())\n\tif l == oldLen {\n\t\treturn true\n\t}\n\tif !lenProp.writable {\n\t\ta.val.runtime.typeErrorResult(throw, \"length is not writable\")\n\t\treturn false\n\t}\n\tret := true\n\tif l < oldLen {\n\t\ta.materialisePropNames()\n\t\ta.fixPropOrder()\n\t\ti := sort.Search(a.idxPropCount, func(idx int) bool {\n\t\t\treturn strToArrayIdx(a.propNames[idx]) >= l\n\t\t})\n\t\tfor j := a.idxPropCount - 1; j >= i; j-- {\n\t\t\tif !a.deleteStr(a.propNames[j], false) {\n\t\t\t\tl = strToArrayIdx(a.propNames[j]) + 1\n\t\t\t\tret = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tlenProp.value = intToValue(int64(l))\n\treturn ret\n}\n\nfunc (a *templatedArrayObject) setOwnStr(name unistring.String, value Value, throw bool) bool {\n\tif name == \"length\" {\n\t\treturn a.setLength(a.val.runtime.toLengthUint32(value), throw)\n\t}\n\tif !a.templatedObject.setOwnStr(name, value, throw) {\n\t\treturn false\n\t}\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\ta._setOwnIdx(idx)\n\t}\n\treturn true\n}\n\nfunc (a *templatedArrayObject) setOwnIdx(p valueInt, v Value, throw bool) bool {\n\tif !a.templatedObject.setOwnStr(p.string(), v, throw) {\n\t\treturn false\n\t}\n\tif idx := toIdx(p); idx != math.MaxUint32 {\n\t\ta._setOwnIdx(idx)\n\t}\n\treturn true\n}\n\nfunc (a *templatedArrayObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif name == \"length\" {\n\t\treturn a.val.runtime.defineArrayLength(a.getLenProp(), descr, a.setLength, throw)\n\t}\n\tif !a.templatedObject.defineOwnPropertyStr(name, descr, throw) {\n\t\treturn false\n\t}\n\tif idx := strToArrayIdx(name); idx != math.MaxUint32 {\n\t\ta._setOwnIdx(idx)\n\t}\n\treturn true\n}\n\nfunc (a *templatedArrayObject) defineOwnPropertyIdx(p valueInt, desc PropertyDescriptor, throw bool) bool {\n\tif !a.templatedObject.defineOwnPropertyStr(p.string(), desc, throw) {\n\t\treturn false\n\t}\n\tif idx := toIdx(p); idx != math.MaxUint32 {\n\t\ta._setOwnIdx(idx)\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "object_test.go",
          "type": "blob",
          "size": 12.2705078125,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestDefineProperty(t *testing.T) {\n\tr := New()\n\to := r.NewObject()\n\n\terr := o.DefineDataProperty(\"data\", r.ToValue(42), FLAG_TRUE, FLAG_TRUE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = o.DefineAccessorProperty(\"accessor_ro\", r.ToValue(func() int {\n\t\treturn 1\n\t}), nil, FLAG_TRUE, FLAG_TRUE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = o.DefineAccessorProperty(\"accessor_rw\",\n\t\tr.ToValue(func(call FunctionCall) Value {\n\t\t\treturn o.Get(\"__hidden\")\n\t\t}),\n\t\tr.ToValue(func(call FunctionCall) (ret Value) {\n\t\t\to.Set(\"__hidden\", call.Argument(0))\n\t\t\treturn\n\t\t}),\n\t\tFLAG_TRUE, FLAG_TRUE)\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif v := o.Get(\"accessor_ro\"); v.ToInteger() != 1 {\n\t\tt.Fatalf(\"Unexpected accessor value: %v\", v)\n\t}\n\n\terr = o.Set(\"accessor_ro\", r.ToValue(2))\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n\tif ex, ok := err.(*Exception); ok {\n\t\tif msg := ex.Error(); msg != \"TypeError: Cannot assign to read only property 'accessor_ro'\" {\n\t\t\tt.Fatalf(\"Unexpected error: '%s'\", msg)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Unexected error type: %T\", err)\n\t}\n\n\terr = o.Set(\"accessor_rw\", 42)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif v := o.Get(\"accessor_rw\"); v.ToInteger() != 42 {\n\t\tt.Fatalf(\"Unexpected value: %v\", v)\n\t}\n}\n\nfunc TestPropertyOrder(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {};\n\tvar sym1 = Symbol(1);\n\tvar sym2 = Symbol(2);\n\to[sym2] = 1;\n\to[4294967294] = 1;\n\to[2] = 1;\n\to[1] = 1;\n\to[0] = 1;\n\to[\"02\"] = 1;\n\to[4294967295] = 1;\n\to[\"01\"] = 1;\n\to[\"00\"] = 1;\n\to[sym1] = 1;\n\tvar expected = [\"0\", \"1\", \"2\", \"4294967294\", \"02\", \"4294967295\", \"01\", \"00\", sym2, sym1];\n\tvar actual = Reflect.ownKeys(o);\n\tif (actual.length !== expected.length) {\n\t\tthrow new Error(\"Unexpected length: \"+actual.length);\n\t}\n\tfor (var i = 0; i < actual.length; i++) {\n\t\tif (actual[i] !== expected[i]) {\n\t\t\tthrow new Error(\"Unexpected list: \" + actual);\n\t\t}\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestDefinePropertiesSymbol(t *testing.T) {\n\tconst SCRIPT = `\n\tvar desc = {};\n\tdesc[Symbol.toStringTag] = {value: \"Test\"};\n\tvar o = {};\n\tObject.defineProperties(o, desc);\n\to[Symbol.toStringTag] === \"Test\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestObjectShorthandProperties(t *testing.T) {\n\tconst SCRIPT = `\n\tvar b = 1;\n\tvar a = {b, get() {return \"c\"}};\n\n\tassert.sameValue(a.b, b, \"#1\");\n\tassert.sameValue(a.get(), \"c\", \"#2\");\n\n\tvar obj = {\n\t\tw\\u0069th() { return 42; }\n    };\n\n\tassert.sameValue(obj['with'](), 42, 'property exists');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjectAssign(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(Object.assign({ b: 1 }, { get a() {\n          Object.defineProperty(this, \"b\", {\n            value: 3,\n            enumerable: false\n          });\n        }, b: 2 }).b, 1, \"#1\");\n\n\tassert.sameValue(Object.assign({ b: 1 }, { get a() {\n          delete this.b;\n        }, b: 2 }).b, 1, \"#2\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestExportCircular(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\to.Set(\"o\", o)\n\tv := o.Export()\n\tif m, ok := v.(map[string]interface{}); ok {\n\t\tif reflect.ValueOf(m[\"o\"]).Pointer() != reflect.ValueOf(v).Pointer() {\n\t\t\tt.Fatal(\"Unexpected value\")\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Unexpected type\")\n\t}\n\n\tres, err := vm.RunString(`var a = []; a[0] = a;`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tv = res.Export()\n\tif a, ok := v.([]interface{}); ok {\n\t\tif reflect.ValueOf(a[0]).Pointer() != reflect.ValueOf(v).Pointer() {\n\t\t\tt.Fatal(\"Unexpected value\")\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Unexpected type\")\n\t}\n}\n\ntype test_s struct {\n\tS *test_s1\n}\ntype test_s1 struct {\n\tS *test_s\n}\n\nfunc TestExportToCircular(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\to.Set(\"o\", o)\n\tvar m map[string]interface{}\n\terr := vm.ExportTo(o, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttype K string\n\ttype T map[K]T\n\tvar m1 T\n\terr = vm.ExportTo(o, &m1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttype A []A\n\tvar a A\n\tres, err := vm.RunString(\"var a = []; a[0] = a;\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = vm.ExportTo(res, &a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif &a[0] != &a[0][0] {\n\t\tt.Fatal(\"values do not match\")\n\t}\n\n\to = vm.NewObject()\n\to.Set(\"S\", o)\n\tvar s test_s\n\terr = vm.ExportTo(o, &s)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif s.S.S != &s {\n\t\tt.Fatalf(\"values do not match: %v, %v\", s.S.S, &s)\n\t}\n\n\ttype test_s2 struct {\n\t\tS  interface{}\n\t\tS1 *test_s2\n\t}\n\n\tvar s2 test_s2\n\to.Set(\"S1\", o)\n\n\terr = vm.ExportTo(o, &s2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif m, ok := s2.S.(map[string]interface{}); ok {\n\t\tif reflect.ValueOf(m[\"S\"]).Pointer() != reflect.ValueOf(m).Pointer() {\n\t\t\tt.Fatal(\"Unexpected m.S\")\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Unexpected s2.S type: %T\", s2.S)\n\t}\n\tif s2.S1 != &s2 {\n\t\tt.Fatal(\"Unexpected s2.S1\")\n\t}\n\n\to1 := vm.NewObject()\n\to1.Set(\"S\", o)\n\to1.Set(\"S1\", o)\n\terr = vm.ExportTo(o1, &s2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif s2.S1.S1 != s2.S1 {\n\t\tt.Fatal(\"Unexpected s2.S1.S1\")\n\t}\n}\n\nfunc TestExportWrappedMap(t *testing.T) {\n\tvm := New()\n\tm := map[string]interface{}{\n\t\t\"test\": \"failed\",\n\t}\n\texported := vm.ToValue(m).Export()\n\tif exportedMap, ok := exported.(map[string]interface{}); ok {\n\t\texportedMap[\"test\"] = \"passed\"\n\t\tif v := m[\"test\"]; v != \"passed\" {\n\t\t\tt.Fatalf(\"Unexpected m[\\\"test\\\"]: %v\", v)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Unexpected export type: %T\", exported)\n\t}\n}\n\nfunc TestExportToWrappedMap(t *testing.T) {\n\tvm := New()\n\tm := map[string]interface{}{\n\t\t\"test\": \"failed\",\n\t}\n\tvar exported map[string]interface{}\n\terr := vm.ExportTo(vm.ToValue(m), &exported)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texported[\"test\"] = \"passed\"\n\tif v := m[\"test\"]; v != \"passed\" {\n\t\tt.Fatalf(\"Unexpected m[\\\"test\\\"]: %v\", v)\n\t}\n}\n\nfunc TestExportToWrappedMapCustom(t *testing.T) {\n\ttype CustomMap map[string]bool\n\tvm := New()\n\tm := CustomMap{}\n\tvar exported CustomMap\n\terr := vm.ExportTo(vm.ToValue(m), &exported)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texported[\"test\"] = true\n\tif v := m[\"test\"]; v != true {\n\t\tt.Fatalf(\"Unexpected m[\\\"test\\\"]: %v\", v)\n\t}\n}\n\nfunc TestExportToSliceNonIterable(t *testing.T) {\n\tvm := New()\n\to := vm.NewObject()\n\tvar a []interface{}\n\terr := vm.ExportTo(o, &a)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error\")\n\t}\n\tif len(a) != 0 {\n\t\tt.Fatalf(\"a: %v\", a)\n\t}\n\tif msg := err.Error(); msg != \"cannot convert [object Object] to []interface {}: not an array or iterable\" {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc ExampleRuntime_ExportTo_iterableToSlice() {\n\tvm := New()\n\tv, err := vm.RunString(`\n\tfunction reverseIterator() {\n\t    const arr = this;\n\t    let idx = arr.length;\n\t    return {\n\t\t\tnext: () => idx > 0 ? {value: arr[--idx]} : {done: true}\n\t    }\n\t}\n\tconst arr = [1,2,3];\n\tarr[Symbol.iterator] = reverseIterator;\n\tarr;\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar arr []int\n\terr = vm.ExportTo(v, &arr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(arr)\n\t// Output: [3 2 1]\n}\n\nfunc TestRuntime_ExportTo_proxiedIterableToSlice(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`\n\tfunction reverseIterator() {\n\t    const arr = this;\n\t    let idx = arr.length;\n\t    return {\n\t\t\tnext: () => idx > 0 ? {value: arr[--idx]} : {done: true}\n\t    }\n\t}\n\tconst arr = [1,2,3];\n\tarr[Symbol.iterator] = reverseIterator;\n\tnew Proxy(arr, {});\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar arr []int\n\terr = vm.ExportTo(v, &arr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif out := fmt.Sprint(arr); out != \"[3 2 1]\" {\n\t\tt.Fatal(out)\n\t}\n}\n\nfunc ExampleRuntime_ExportTo_arrayLikeToSlice() {\n\tvm := New()\n\tv, err := vm.RunString(`\n\t({\n\t\tlength: 3,\n\t\t0: 1,\n\t\t1: 2,\n\t\t2: 3\n\t});\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar arr []int\n\terr = vm.ExportTo(v, &arr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(arr)\n\t// Output: [1 2 3]\n}\n\nfunc TestExportArrayToArrayMismatchedLengths(t *testing.T) {\n\tvm := New()\n\ta := vm.NewArray(1, 2)\n\tvar a1 [3]int\n\terr := vm.ExportTo(a, &a1)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif msg := err.Error(); !strings.Contains(msg, \"lengths mismatch\") {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc TestExportIterableToArrayMismatchedLengths(t *testing.T) {\n\tvm := New()\n\ta, err := vm.RunString(`\n\t\tnew Map([[1, true], [2, true]]);\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar a1 [3]interface{}\n\terr = vm.ExportTo(a, &a1)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif msg := err.Error(); !strings.Contains(msg, \"lengths mismatch\") {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc TestExportArrayLikeToArrayMismatchedLengths(t *testing.T) {\n\tvm := New()\n\ta, err := vm.RunString(`\n\t\t({\n\t\t\tlength: 2,\n\t\t\t0: true,\n\t\t\t1: true\n\t\t});\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar a1 [3]interface{}\n\terr = vm.ExportTo(a, &a1)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif msg := err.Error(); !strings.Contains(msg, \"lengths mismatch\") {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc TestSetForeignReturnValue(t *testing.T) {\n\tconst SCRIPT = `\n\tvar array = [1, 2, 3];\n\tvar arrayTarget = new Proxy(array, {});\n\n\tObject.preventExtensions(array);\n\n\t!Reflect.set(arrayTarget, \"foo\", 2);\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestDefinePropertiesUndefinedVal(t *testing.T) {\n\tconst SCRIPT = `\nvar target = {};\nvar sym = Symbol();\ntarget[sym] = 1;\ntarget.foo = 2;\ntarget[0] = 3;\n\nvar getOwnKeys = [];\nvar proxy = new Proxy(target, {\n  getOwnPropertyDescriptor: function(_target, key) {\n    getOwnKeys.push(key);\n  },\n});\n\nObject.defineProperties({}, proxy);\n\ttrue;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc ExampleObject_Delete() {\n\tvm := New()\n\tobj := vm.NewObject()\n\t_ = obj.Set(\"test\", true)\n\tbefore := obj.Get(\"test\")\n\t_ = obj.Delete(\"test\")\n\tafter := obj.Get(\"test\")\n\tfmt.Printf(\"before: %v, after: %v\", before, after)\n\t// Output: before: true, after: <nil>\n}\n\nfunc ExampleObject_GetOwnPropertyNames() {\n\tvm := New()\n\tobj := vm.NewObject()\n\tobj.DefineDataProperty(\"test\", vm.ToValue(true), FLAG_TRUE, FLAG_TRUE, FLAG_FALSE) // define a non-enumerable property that Keys() would not return\n\tfmt.Print(obj.GetOwnPropertyNames())\n\t// Output: [test]\n}\n\nfunc TestObjectEquality(t *testing.T) {\n\ttype CustomInt int\n\ttype S struct {\n\t\tF CustomInt\n\t}\n\tvm := New()\n\tvm.Set(\"s\", S{})\n\t// indexOf() and includes() use different equality checks (StrictEquals and SameValueZero respectively),\n\t// but for objects they must behave the same. De-referencing s.F creates a new wrapper each time.\n\tvm.testScriptWithTestLib(`\n\tassert.sameValue([s.F].indexOf(s.F), 0, \"indexOf\");\n\tassert([s.F].includes(s.F));\n\t`, _undefined, t)\n}\n\nfunc BenchmarkPut(b *testing.B) {\n\tv := &Object{}\n\n\to := &baseObject{\n\t\tval:        v,\n\t\textensible: true,\n\t}\n\tv.self = o\n\n\to.init()\n\n\tvar key Value = asciiString(\"test\")\n\tvar val Value = valueInt(123)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv.setOwn(key, val, false)\n\t}\n}\n\nfunc BenchmarkPutStr(b *testing.B) {\n\tv := &Object{}\n\n\to := &baseObject{\n\t\tval:        v,\n\t\textensible: true,\n\t}\n\n\to.init()\n\n\tv.self = o\n\n\tvar val Value = valueInt(123)\n\n\tfor i := 0; i < b.N; i++ {\n\t\to.setOwnStr(\"test\", val, false)\n\t}\n}\n\nfunc BenchmarkGet(b *testing.B) {\n\tv := &Object{}\n\n\to := &baseObject{\n\t\tval:        v,\n\t\textensible: true,\n\t}\n\n\to.init()\n\n\tv.self = o\n\tvar n Value = asciiString(\"test\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv.get(n, nil)\n\t}\n\n}\n\nfunc BenchmarkGetStr(b *testing.B) {\n\tv := &Object{}\n\n\to := &baseObject{\n\t\tval:        v,\n\t\textensible: true,\n\t}\n\tv.self = o\n\n\to.init()\n\n\tfor i := 0; i < b.N; i++ {\n\t\to.getStr(\"test\", nil)\n\t}\n}\n\nfunc __toString(v Value) string {\n\tswitch v := v.(type) {\n\tcase asciiString:\n\t\treturn string(v)\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc BenchmarkToString1(b *testing.B) {\n\tv := asciiString(\"test\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv.toString()\n\t}\n}\n\nfunc BenchmarkToString2(b *testing.B) {\n\tv := asciiString(\"test\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\t__toString(v)\n\t}\n}\n\nfunc BenchmarkConv(b *testing.B) {\n\tcount := int64(0)\n\tfor i := 0; i < b.N; i++ {\n\t\tcount += valueInt(123).ToInteger()\n\t}\n\tif count == 0 {\n\t\tb.Fatal(\"zero\")\n\t}\n}\n\nfunc BenchmarkToUTF8String(b *testing.B) {\n\tvar s String = asciiString(\"test\")\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = s.String()\n\t}\n}\n\nfunc BenchmarkAdd(b *testing.B) {\n\tvar x, y Value\n\tx = valueInt(2)\n\ty = valueInt(2)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif xi, ok := x.(valueInt); ok {\n\t\t\tif yi, ok := y.(valueInt); ok {\n\t\t\t\tx = xi + yi\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkAddString(b *testing.B) {\n\tvar x, y Value\n\n\ttst := asciiString(\"22\")\n\tx = asciiString(\"2\")\n\ty = asciiString(\"2\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar z Value\n\t\tif xi, ok := x.(String); ok {\n\t\t\tif yi, ok := y.(String); ok {\n\t\t\t\tz = xi.Concat(yi)\n\t\t\t}\n\t\t}\n\t\tif !z.StrictEquals(tst) {\n\t\t\tb.Fatalf(\"Unexpected result %v\", x)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "profiler.go",
          "type": "blob",
          "size": 8.1328125,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/google/pprof/profile\"\n)\n\nconst profInterval = 10 * time.Millisecond\nconst profMaxStackDepth = 64\n\nconst (\n\tprofReqNone int32 = iota\n\tprofReqDoSample\n\tprofReqSampleReady\n\tprofReqStop\n)\n\ntype _globalProfiler struct {\n\tp profiler\n\tw io.Writer\n\n\tenabled int32\n}\n\nvar globalProfiler _globalProfiler\n\ntype profTracker struct {\n\treq, finished int32\n\tstart, stop   time.Time\n\tnumFrames     int\n\tframes        [profMaxStackDepth]StackFrame\n}\n\ntype profiler struct {\n\tmu       sync.Mutex\n\ttrackers []*profTracker\n\tbuf      *profBuffer\n\trunning  bool\n}\n\ntype profFunc struct {\n\tf    profile.Function\n\tlocs map[int32]*profile.Location\n}\n\ntype profSampleNode struct {\n\tloc      *profile.Location\n\tsample   *profile.Sample\n\tparent   *profSampleNode\n\tchildren map[*profile.Location]*profSampleNode\n}\n\ntype profBuffer struct {\n\tfuncs map[*Program]*profFunc\n\troot  profSampleNode\n}\n\nfunc (pb *profBuffer) addSample(pt *profTracker) {\n\tsampleFrames := pt.frames[:pt.numFrames]\n\tn := &pb.root\n\tfor j := len(sampleFrames) - 1; j >= 0; j-- {\n\t\tframe := sampleFrames[j]\n\t\tif frame.prg == nil {\n\t\t\tcontinue\n\t\t}\n\t\tvar f *profFunc\n\t\tif f = pb.funcs[frame.prg]; f == nil {\n\t\t\tf = &profFunc{\n\t\t\t\tlocs: make(map[int32]*profile.Location),\n\t\t\t}\n\t\t\tif pb.funcs == nil {\n\t\t\t\tpb.funcs = make(map[*Program]*profFunc)\n\t\t\t}\n\t\t\tpb.funcs[frame.prg] = f\n\t\t}\n\t\tvar loc *profile.Location\n\t\tif loc = f.locs[int32(frame.pc)]; loc == nil {\n\t\t\tloc = &profile.Location{}\n\t\t\tf.locs[int32(frame.pc)] = loc\n\t\t}\n\t\tif nn := n.children[loc]; nn == nil {\n\t\t\tif n.children == nil {\n\t\t\t\tn.children = make(map[*profile.Location]*profSampleNode, 1)\n\t\t\t}\n\t\t\tnn = &profSampleNode{\n\t\t\t\tparent: n,\n\t\t\t\tloc:    loc,\n\t\t\t}\n\t\t\tn.children[loc] = nn\n\t\t\tn = nn\n\t\t} else {\n\t\t\tn = nn\n\t\t}\n\t}\n\tsmpl := n.sample\n\tif smpl == nil {\n\t\tlocs := make([]*profile.Location, 0, len(sampleFrames))\n\t\tfor n1 := n; n1.loc != nil; n1 = n1.parent {\n\t\t\tlocs = append(locs, n1.loc)\n\t\t}\n\t\tsmpl = &profile.Sample{\n\t\t\tLocation: locs,\n\t\t\tValue:    make([]int64, 2),\n\t\t}\n\t\tn.sample = smpl\n\t}\n\tsmpl.Value[0]++\n\tsmpl.Value[1] += int64(pt.stop.Sub(pt.start))\n}\n\nfunc (pb *profBuffer) profile() *profile.Profile {\n\tpr := profile.Profile{}\n\tpr.SampleType = []*profile.ValueType{\n\t\t{Type: \"samples\", Unit: \"count\"},\n\t\t{Type: \"cpu\", Unit: \"nanoseconds\"},\n\t}\n\tpr.PeriodType = pr.SampleType[1]\n\tpr.Period = int64(profInterval)\n\tmapping := &profile.Mapping{\n\t\tID:   1,\n\t\tFile: \"[ECMAScript code]\",\n\t}\n\tpr.Mapping = make([]*profile.Mapping, 1, len(pb.funcs)+1)\n\tpr.Mapping[0] = mapping\n\n\tpr.Function = make([]*profile.Function, 0, len(pb.funcs))\n\tfuncNames := make(map[string]struct{})\n\tvar funcId, locId uint64\n\tfor prg, f := range pb.funcs {\n\t\tfileName := prg.src.Name()\n\t\tfuncId++\n\t\tf.f.ID = funcId\n\t\tf.f.Filename = fileName\n\t\tvar funcName string\n\t\tif prg.funcName != \"\" {\n\t\t\tfuncName = prg.funcName.String()\n\t\t} else {\n\t\t\tfuncName = \"<anonymous>\"\n\t\t}\n\t\t// Make sure the function name is unique, otherwise the graph display merges them into one node, even\n\t\t// if they are in different mappings.\n\t\tif _, exists := funcNames[funcName]; exists {\n\t\t\tfuncName += \".\" + strconv.FormatUint(f.f.ID, 10)\n\t\t} else {\n\t\t\tfuncNames[funcName] = struct{}{}\n\t\t}\n\t\tf.f.Name = funcName\n\t\tpr.Function = append(pr.Function, &f.f)\n\t\tfor pc, loc := range f.locs {\n\t\t\tlocId++\n\t\t\tloc.ID = locId\n\t\t\tpos := prg.src.Position(prg.sourceOffset(int(pc)))\n\t\t\tloc.Line = []profile.Line{\n\t\t\t\t{\n\t\t\t\t\tFunction: &f.f,\n\t\t\t\t\tLine:     int64(pos.Line),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tloc.Mapping = mapping\n\t\t\tpr.Location = append(pr.Location, loc)\n\t\t}\n\t}\n\tpb.addSamples(&pr, &pb.root)\n\treturn &pr\n}\n\nfunc (pb *profBuffer) addSamples(p *profile.Profile, n *profSampleNode) {\n\tif n.sample != nil {\n\t\tp.Sample = append(p.Sample, n.sample)\n\t}\n\tfor _, child := range n.children {\n\t\tpb.addSamples(p, child)\n\t}\n}\n\nfunc (p *profiler) run() {\n\tticker := time.NewTicker(profInterval)\n\tcounter := 0\n\n\tfor ts := range ticker.C {\n\t\tp.mu.Lock()\n\t\tleft := len(p.trackers)\n\t\tif left == 0 {\n\t\t\tbreak\n\t\t}\n\t\tfor {\n\t\t\t// This loop runs until either one of the VMs is signalled or all of the VMs are scanned and found\n\t\t\t// busy or deleted.\n\t\t\tif counter >= len(p.trackers) {\n\t\t\t\tcounter = 0\n\t\t\t}\n\t\t\ttracker := p.trackers[counter]\n\t\t\treq := atomic.LoadInt32(&tracker.req)\n\t\t\tif req == profReqSampleReady {\n\t\t\t\tp.buf.addSample(tracker)\n\t\t\t}\n\t\t\tif atomic.LoadInt32(&tracker.finished) != 0 {\n\t\t\t\tp.trackers[counter] = p.trackers[len(p.trackers)-1]\n\t\t\t\tp.trackers[len(p.trackers)-1] = nil\n\t\t\t\tp.trackers = p.trackers[:len(p.trackers)-1]\n\t\t\t} else {\n\t\t\t\tcounter++\n\t\t\t\tif req != profReqDoSample {\n\t\t\t\t\t// signal the VM to take a sample\n\t\t\t\t\ttracker.start = ts\n\t\t\t\t\tatomic.StoreInt32(&tracker.req, profReqDoSample)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft--\n\t\t\tif left <= 0 {\n\t\t\t\t// all VMs are busy\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tp.mu.Unlock()\n\t}\n\tticker.Stop()\n\tp.running = false\n\tp.mu.Unlock()\n}\n\nfunc (p *profiler) registerVm() *profTracker {\n\tpt := new(profTracker)\n\tp.mu.Lock()\n\tif p.buf != nil {\n\t\tp.trackers = append(p.trackers, pt)\n\t\tif !p.running {\n\t\t\tgo p.run()\n\t\t\tp.running = true\n\t\t}\n\t} else {\n\t\tpt.req = profReqStop\n\t}\n\tp.mu.Unlock()\n\treturn pt\n}\n\nfunc (p *profiler) start() error {\n\tp.mu.Lock()\n\tif p.buf != nil {\n\t\tp.mu.Unlock()\n\t\treturn errors.New(\"profiler is already active\")\n\t}\n\tp.buf = new(profBuffer)\n\tp.mu.Unlock()\n\treturn nil\n}\n\nfunc (p *profiler) stop() *profile.Profile {\n\tp.mu.Lock()\n\ttrackers, buf := p.trackers, p.buf\n\tp.trackers, p.buf = nil, nil\n\tp.mu.Unlock()\n\tif buf != nil {\n\t\tk := 0\n\t\tfor i, tracker := range trackers {\n\t\t\treq := atomic.LoadInt32(&tracker.req)\n\t\t\tif req == profReqSampleReady {\n\t\t\t\tbuf.addSample(tracker)\n\t\t\t} else if req == profReqDoSample {\n\t\t\t\t// In case the VM is requested to do a sample, there is a small chance of a race\n\t\t\t\t// where we set profReqStop in between the read and the write, so that the req\n\t\t\t\t// ends up being set to profReqSampleReady. It's no such a big deal if we do nothing,\n\t\t\t\t// it just means the VM remains in tracing mode until it finishes the current run,\n\t\t\t\t// but we do an extra cleanup step later just in case.\n\t\t\t\tif i != k {\n\t\t\t\t\ttrackers[k] = trackers[i]\n\t\t\t\t}\n\t\t\t\tk++\n\t\t\t}\n\t\t\tatomic.StoreInt32(&tracker.req, profReqStop)\n\t\t}\n\n\t\tif k > 0 {\n\t\t\ttrackers = trackers[:k]\n\t\t\tgo func() {\n\t\t\t\t// Make sure all VMs are requested to stop tracing.\n\t\t\t\tfor {\n\t\t\t\t\tk := 0\n\t\t\t\t\tfor i, tracker := range trackers {\n\t\t\t\t\t\treq := atomic.LoadInt32(&tracker.req)\n\t\t\t\t\t\tif req != profReqStop {\n\t\t\t\t\t\t\tatomic.StoreInt32(&tracker.req, profReqStop)\n\t\t\t\t\t\t\tif i != k {\n\t\t\t\t\t\t\t\ttrackers[k] = trackers[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif k == 0 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\ttrackers = trackers[:k]\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\treturn buf.profile()\n\t}\n\treturn nil\n}\n\n/*\nStartProfile enables execution time profiling for all Runtimes within the current process.\nThis works similar to pprof.StartCPUProfile and produces the same format which can be consumed by `go tool pprof`.\nThere are, however, a few notable differences. Firstly, it's not a CPU profile, rather \"execution time\" profile.\nIt measures the time the VM spends executing an instruction. If this instruction happens to be a call to a\nblocking Go function, the waiting time will be measured. Secondly, the 'cpu' sample isn't simply `count*period`,\nit's the time interval between when sampling was requested and when the instruction has finished. If a VM is still\nexecuting the same instruction when the time comes for the next sample, the sampling is skipped (i.e. `count` doesn't\ngrow).\n\nIf there are multiple functions with the same name, their names get a '.N' suffix, where N is a unique number,\nbecause otherwise the graph view merges them together (even if they are in different mappings). This includes\n\"<anonymous>\" functions.\n\nThe sampling period is set to 10ms.\n\nIt returns an error if profiling is already active.\n*/\nfunc StartProfile(w io.Writer) error {\n\terr := globalProfiler.p.start()\n\tif err != nil {\n\t\treturn err\n\t}\n\tglobalProfiler.w = w\n\tatomic.StoreInt32(&globalProfiler.enabled, 1)\n\treturn nil\n}\n\n/*\nStopProfile stops the current profile initiated by StartProfile, if any.\n*/\nfunc StopProfile() {\n\tatomic.StoreInt32(&globalProfiler.enabled, 0)\n\tpr := globalProfiler.p.stop()\n\tif pr != nil {\n\t\t_ = pr.Write(globalProfiler.w)\n\t}\n\tglobalProfiler.w = nil\n}\n"
        },
        {
          "name": "profiler_test.go",
          "type": "blob",
          "size": 1.9970703125,
          "content": "package goja\n\nimport (\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestProfiler(t *testing.T) {\n\n\terr := StartProfile(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvm := New()\n\tgo func() {\n\t\t_, err := vm.RunScript(\"test123.js\", `\n\t\t\tconst a = 2 + 2;\n\t\t\tfunction loop() {\n\t\t\t\tfor(;;) {}\n\t\t\t}\n\t\t\tloop();\n\t\t`)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(*InterruptedError); !ok {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t}()\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tatomic.StoreInt32(&globalProfiler.enabled, 0)\n\tpr := globalProfiler.p.stop()\n\n\tif len(pr.Sample) == 0 {\n\t\tt.Fatal(\"No samples were recorded\")\n\t}\n\n\tvar running bool\n\tfor i := 0; i < 10; i++ {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tglobalProfiler.p.mu.Lock()\n\t\trunning = globalProfiler.p.running\n\t\tglobalProfiler.p.mu.Unlock()\n\t\tif !running {\n\t\t\tbreak\n\t\t}\n\t}\n\tif running {\n\t\tt.Fatal(\"The profiler is still running\")\n\t}\n\tvm.Interrupt(nil)\n}\n\nfunc TestProfiler1(t *testing.T) {\n\tt.Skip(\"This test takes too long with race detector enabled and is non-deterministic. It's left here mostly for documentation purposes.\")\n\n\terr := StartProfile(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgo func() {\n\t\tsleep := func() {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\t// Spawn new vms faster than once every 10ms (the profiler interval) and make sure they don't finish too soon.\n\t\t// This means (*profiler).run() won't be fast enough to collect the samples, so they must be collected\n\t\t// after the profiler is stopped.\n\t\tfor i := 0; i < 500; i++ {\n\t\t\tgo func() {\n\t\t\t\tvm := New()\n\t\t\t\tvm.Set(\"sleep\", sleep)\n\t\t\t\t_, err := vm.RunScript(\"test123.js\", `\n\t\t\t\tfunction loop() {\n\t\t\t\t\tfor (let i = 0; i < 50000; i++) {\n\t\t\t\t\t\tconst a = Math.pow(Math.Pi, Math.Pi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tloop();\n\t\t\t\tsleep();\n\t\t\t\t`)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif _, ok := err.(*InterruptedError); !ok {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\ttime.Sleep(1 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond)\n\tatomic.StoreInt32(&globalProfiler.enabled, 0)\n\tpr := globalProfiler.p.stop()\n\n\tif len(pr.Sample) == 0 {\n\t\tt.Fatal(\"No samples were recorded\")\n\t}\n}\n"
        },
        {
          "name": "proxy.go",
          "type": "blob",
          "size": 31.802734375,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\n// Proxy is a Go wrapper around ECMAScript Proxy. Calling Runtime.ToValue() on it\n// returns the underlying Proxy. Calling Export() on an ECMAScript Proxy returns a wrapper.\n// Use Runtime.NewProxy() to create one.\ntype Proxy struct {\n\tproxy *proxyObject\n}\n\nvar (\n\tproxyType = reflect.TypeOf(Proxy{})\n)\n\ntype proxyPropIter struct {\n\tp     *proxyObject\n\tnames []Value\n\tidx   int\n}\n\nfunc (i *proxyPropIter) next() (propIterItem, iterNextFunc) {\n\tfor i.idx < len(i.names) {\n\t\tname := i.names[i.idx]\n\t\ti.idx++\n\t\treturn propIterItem{name: name}, i.next\n\t}\n\treturn propIterItem{}, nil\n}\n\nfunc (r *Runtime) newProxyObject(target, handler, proto *Object) *proxyObject {\n\treturn r._newProxyObject(target, &jsProxyHandler{handler: handler}, proto)\n}\n\nfunc (r *Runtime) _newProxyObject(target *Object, handler proxyHandler, proto *Object) *proxyObject {\n\tv := &Object{runtime: r}\n\tp := &proxyObject{}\n\tv.self = p\n\tp.val = v\n\tp.class = classObject\n\tif proto == nil {\n\t\tp.prototype = r.global.ObjectPrototype\n\t} else {\n\t\tp.prototype = proto\n\t}\n\tp.extensible = false\n\tp.init()\n\tp.target = target\n\tp.handler = handler\n\tif call, ok := target.self.assertCallable(); ok {\n\t\tp.call = call\n\t}\n\tif ctor := target.self.assertConstructor(); ctor != nil {\n\t\tp.ctor = ctor\n\t}\n\treturn p\n}\n\nfunc (p Proxy) Revoke() {\n\tp.proxy.revoke()\n}\n\nfunc (p Proxy) Handler() *Object {\n\tif handler := p.proxy.handler; handler != nil {\n\t\treturn handler.toObject(p.proxy.val.runtime)\n\t}\n\treturn nil\n}\n\nfunc (p Proxy) Target() *Object {\n\treturn p.proxy.target\n}\n\nfunc (p Proxy) toValue(r *Runtime) Value {\n\tif p.proxy == nil {\n\t\treturn _null\n\t}\n\tproxy := p.proxy.val\n\tif proxy.runtime != r {\n\t\tpanic(r.NewTypeError(\"Illegal runtime transition of a Proxy\"))\n\t}\n\treturn proxy\n}\n\ntype proxyTrap string\n\nconst (\n\tproxy_trap_getPrototypeOf           = \"getPrototypeOf\"\n\tproxy_trap_setPrototypeOf           = \"setPrototypeOf\"\n\tproxy_trap_isExtensible             = \"isExtensible\"\n\tproxy_trap_preventExtensions        = \"preventExtensions\"\n\tproxy_trap_getOwnPropertyDescriptor = \"getOwnPropertyDescriptor\"\n\tproxy_trap_defineProperty           = \"defineProperty\"\n\tproxy_trap_has                      = \"has\"\n\tproxy_trap_get                      = \"get\"\n\tproxy_trap_set                      = \"set\"\n\tproxy_trap_deleteProperty           = \"deleteProperty\"\n\tproxy_trap_ownKeys                  = \"ownKeys\"\n\tproxy_trap_apply                    = \"apply\"\n\tproxy_trap_construct                = \"construct\"\n)\n\nfunc (p proxyTrap) String() (name string) {\n\treturn string(p)\n}\n\ntype proxyHandler interface {\n\tgetPrototypeOf(target *Object) (Value, bool)\n\tsetPrototypeOf(target *Object, proto *Object) (bool, bool)\n\tisExtensible(target *Object) (bool, bool)\n\tpreventExtensions(target *Object) (bool, bool)\n\n\tgetOwnPropertyDescriptorStr(target *Object, prop unistring.String) (Value, bool)\n\tgetOwnPropertyDescriptorIdx(target *Object, prop valueInt) (Value, bool)\n\tgetOwnPropertyDescriptorSym(target *Object, prop *Symbol) (Value, bool)\n\n\tdefinePropertyStr(target *Object, prop unistring.String, desc PropertyDescriptor) (bool, bool)\n\tdefinePropertyIdx(target *Object, prop valueInt, desc PropertyDescriptor) (bool, bool)\n\tdefinePropertySym(target *Object, prop *Symbol, desc PropertyDescriptor) (bool, bool)\n\n\thasStr(target *Object, prop unistring.String) (bool, bool)\n\thasIdx(target *Object, prop valueInt) (bool, bool)\n\thasSym(target *Object, prop *Symbol) (bool, bool)\n\n\tgetStr(target *Object, prop unistring.String, receiver Value) (Value, bool)\n\tgetIdx(target *Object, prop valueInt, receiver Value) (Value, bool)\n\tgetSym(target *Object, prop *Symbol, receiver Value) (Value, bool)\n\n\tsetStr(target *Object, prop unistring.String, value Value, receiver Value) (bool, bool)\n\tsetIdx(target *Object, prop valueInt, value Value, receiver Value) (bool, bool)\n\tsetSym(target *Object, prop *Symbol, value Value, receiver Value) (bool, bool)\n\n\tdeleteStr(target *Object, prop unistring.String) (bool, bool)\n\tdeleteIdx(target *Object, prop valueInt) (bool, bool)\n\tdeleteSym(target *Object, prop *Symbol) (bool, bool)\n\n\townKeys(target *Object) (*Object, bool)\n\tapply(target *Object, this Value, args []Value) (Value, bool)\n\tconstruct(target *Object, args []Value, newTarget *Object) (Value, bool)\n\n\ttoObject(*Runtime) *Object\n}\n\ntype jsProxyHandler struct {\n\thandler *Object\n}\n\nfunc (h *jsProxyHandler) toObject(*Runtime) *Object {\n\treturn h.handler\n}\n\nfunc (h *jsProxyHandler) proxyCall(trap proxyTrap, args ...Value) (Value, bool) {\n\tr := h.handler.runtime\n\n\tif m := toMethod(r.getVStr(h.handler, unistring.String(trap.String()))); m != nil {\n\t\treturn m(FunctionCall{\n\t\t\tThis:      h.handler,\n\t\t\tArguments: args,\n\t\t}), true\n\t}\n\n\treturn nil, false\n}\n\nfunc (h *jsProxyHandler) boolProxyCall(trap proxyTrap, args ...Value) (bool, bool) {\n\tif v, ok := h.proxyCall(trap, args...); ok {\n\t\treturn v.ToBoolean(), true\n\t}\n\treturn false, false\n}\n\nfunc (h *jsProxyHandler) getPrototypeOf(target *Object) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_getPrototypeOf, target)\n}\n\nfunc (h *jsProxyHandler) setPrototypeOf(target *Object, proto *Object) (bool, bool) {\n\tvar protoVal Value\n\tif proto != nil {\n\t\tprotoVal = proto\n\t} else {\n\t\tprotoVal = _null\n\t}\n\treturn h.boolProxyCall(proxy_trap_setPrototypeOf, target, protoVal)\n}\n\nfunc (h *jsProxyHandler) isExtensible(target *Object) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_isExtensible, target)\n}\n\nfunc (h *jsProxyHandler) preventExtensions(target *Object) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_preventExtensions, target)\n}\n\nfunc (h *jsProxyHandler) getOwnPropertyDescriptorStr(target *Object, prop unistring.String) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_getOwnPropertyDescriptor, target, stringValueFromRaw(prop))\n}\n\nfunc (h *jsProxyHandler) getOwnPropertyDescriptorIdx(target *Object, prop valueInt) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_getOwnPropertyDescriptor, target, prop.toString())\n}\n\nfunc (h *jsProxyHandler) getOwnPropertyDescriptorSym(target *Object, prop *Symbol) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_getOwnPropertyDescriptor, target, prop)\n}\n\nfunc (h *jsProxyHandler) definePropertyStr(target *Object, prop unistring.String, desc PropertyDescriptor) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_defineProperty, target, stringValueFromRaw(prop), desc.toValue(h.handler.runtime))\n}\n\nfunc (h *jsProxyHandler) definePropertyIdx(target *Object, prop valueInt, desc PropertyDescriptor) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_defineProperty, target, prop.toString(), desc.toValue(h.handler.runtime))\n}\n\nfunc (h *jsProxyHandler) definePropertySym(target *Object, prop *Symbol, desc PropertyDescriptor) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_defineProperty, target, prop, desc.toValue(h.handler.runtime))\n}\n\nfunc (h *jsProxyHandler) hasStr(target *Object, prop unistring.String) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_has, target, stringValueFromRaw(prop))\n}\n\nfunc (h *jsProxyHandler) hasIdx(target *Object, prop valueInt) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_has, target, prop.toString())\n}\n\nfunc (h *jsProxyHandler) hasSym(target *Object, prop *Symbol) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_has, target, prop)\n}\n\nfunc (h *jsProxyHandler) getStr(target *Object, prop unistring.String, receiver Value) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_get, target, stringValueFromRaw(prop), receiver)\n}\n\nfunc (h *jsProxyHandler) getIdx(target *Object, prop valueInt, receiver Value) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_get, target, prop.toString(), receiver)\n}\n\nfunc (h *jsProxyHandler) getSym(target *Object, prop *Symbol, receiver Value) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_get, target, prop, receiver)\n}\n\nfunc (h *jsProxyHandler) setStr(target *Object, prop unistring.String, value Value, receiver Value) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_set, target, stringValueFromRaw(prop), value, receiver)\n}\n\nfunc (h *jsProxyHandler) setIdx(target *Object, prop valueInt, value Value, receiver Value) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_set, target, prop.toString(), value, receiver)\n}\n\nfunc (h *jsProxyHandler) setSym(target *Object, prop *Symbol, value Value, receiver Value) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_set, target, prop, value, receiver)\n}\n\nfunc (h *jsProxyHandler) deleteStr(target *Object, prop unistring.String) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_deleteProperty, target, stringValueFromRaw(prop))\n}\n\nfunc (h *jsProxyHandler) deleteIdx(target *Object, prop valueInt) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_deleteProperty, target, prop.toString())\n}\n\nfunc (h *jsProxyHandler) deleteSym(target *Object, prop *Symbol) (bool, bool) {\n\treturn h.boolProxyCall(proxy_trap_deleteProperty, target, prop)\n}\n\nfunc (h *jsProxyHandler) ownKeys(target *Object) (*Object, bool) {\n\tif v, ok := h.proxyCall(proxy_trap_ownKeys, target); ok {\n\t\treturn h.handler.runtime.toObject(v), true\n\t}\n\treturn nil, false\n}\n\nfunc (h *jsProxyHandler) apply(target *Object, this Value, args []Value) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_apply, target, this, h.handler.runtime.newArrayValues(args))\n}\n\nfunc (h *jsProxyHandler) construct(target *Object, args []Value, newTarget *Object) (Value, bool) {\n\treturn h.proxyCall(proxy_trap_construct, target, h.handler.runtime.newArrayValues(args), newTarget)\n}\n\ntype proxyObject struct {\n\tbaseObject\n\ttarget  *Object\n\thandler proxyHandler\n\tcall    func(FunctionCall) Value\n\tctor    func(args []Value, newTarget *Object) *Object\n}\n\nfunc (p *proxyObject) checkHandler() proxyHandler {\n\tr := p.val.runtime\n\tif handler := p.handler; handler != nil {\n\t\treturn handler\n\t}\n\tpanic(r.NewTypeError(\"Proxy already revoked\"))\n}\n\nfunc (p *proxyObject) proto() *Object {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().getPrototypeOf(target); ok {\n\t\tvar handlerProto *Object\n\t\tif v != _null {\n\t\t\thandlerProto = p.val.runtime.toObject(v)\n\t\t}\n\t\tif !target.self.isExtensible() && !p.__sameValue(handlerProto, target.self.proto()) {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'getPrototypeOf' on proxy: proxy target is non-extensible but the trap did not return its actual prototype\"))\n\t\t}\n\t\treturn handlerProto\n\t}\n\n\treturn target.self.proto()\n}\n\nfunc (p *proxyObject) setProto(proto *Object, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().setPrototypeOf(target, proto); ok {\n\t\tif v {\n\t\t\tif !target.self.isExtensible() && !p.__sameValue(proto, target.self.proto()) {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'setPrototypeOf' on proxy: trap returned truish for setting a new prototype on the non-extensible proxy target\"))\n\t\t\t}\n\t\t\treturn true\n\t\t} else {\n\t\t\tp.val.runtime.typeErrorResult(throw, \"'setPrototypeOf' on proxy: trap returned falsish\")\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn target.self.setProto(proto, throw)\n}\n\nfunc (p *proxyObject) isExtensible() bool {\n\ttarget := p.target\n\tif booleanTrapResult, ok := p.checkHandler().isExtensible(p.target); ok {\n\t\tif te := target.self.isExtensible(); booleanTrapResult != te {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is '%v')\", te))\n\t\t}\n\t\treturn booleanTrapResult\n\t}\n\n\treturn target.self.isExtensible()\n}\n\nfunc (p *proxyObject) preventExtensions(throw bool) bool {\n\ttarget := p.target\n\tif booleanTrapResult, ok := p.checkHandler().preventExtensions(target); ok {\n\t\tif !booleanTrapResult {\n\t\t\tp.val.runtime.typeErrorResult(throw, \"'preventExtensions' on proxy: trap returned falsish\")\n\t\t\treturn false\n\t\t}\n\t\tif te := target.self.isExtensible(); booleanTrapResult && te {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'preventExtensions' on proxy: trap returned truish but the proxy target is extensible\"))\n\t\t}\n\t}\n\n\treturn target.self.preventExtensions(throw)\n}\n\nfunc propToValueProp(v Value) *valueProperty {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tif v, ok := v.(*valueProperty); ok {\n\t\treturn v\n\t}\n\treturn &valueProperty{\n\t\tvalue:        v,\n\t\twritable:     true,\n\t\tconfigurable: true,\n\t\tenumerable:   true,\n\t}\n}\n\nfunc (p *proxyObject) proxyDefineOwnPropertyPreCheck(trapResult, throw bool) bool {\n\tif !trapResult {\n\t\tp.val.runtime.typeErrorResult(throw, \"'defineProperty' on proxy: trap returned falsish\")\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (p *proxyObject) proxyDefineOwnPropertyPostCheck(prop Value, target *Object, descr PropertyDescriptor) {\n\ttargetDesc := propToValueProp(prop)\n\textensibleTarget := target.self.isExtensible()\n\tsettingConfigFalse := descr.Configurable == FLAG_FALSE\n\tif targetDesc == nil {\n\t\tif !extensibleTarget {\n\t\t\tpanic(p.val.runtime.NewTypeError())\n\t\t}\n\t\tif settingConfigFalse {\n\t\t\tpanic(p.val.runtime.NewTypeError())\n\t\t}\n\t} else {\n\t\tif !p.__isCompatibleDescriptor(extensibleTarget, &descr, targetDesc) {\n\t\t\tpanic(p.val.runtime.NewTypeError())\n\t\t}\n\t\tif settingConfigFalse && targetDesc.configurable {\n\t\t\tpanic(p.val.runtime.NewTypeError())\n\t\t}\n\t\tif targetDesc.value != nil && !targetDesc.configurable && targetDesc.writable {\n\t\t\tif descr.Writable == FLAG_FALSE {\n\t\t\t\tpanic(p.val.runtime.NewTypeError())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *proxyObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\ttarget := p.target\n\tif booleanTrapResult, ok := p.checkHandler().definePropertyStr(target, name, descr); ok {\n\t\tif !p.proxyDefineOwnPropertyPreCheck(booleanTrapResult, throw) {\n\t\t\treturn false\n\t\t}\n\t\tp.proxyDefineOwnPropertyPostCheck(target.self.getOwnPropStr(name), target, descr)\n\t\treturn true\n\t}\n\treturn target.self.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (p *proxyObject) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\ttarget := p.target\n\tif booleanTrapResult, ok := p.checkHandler().definePropertyIdx(target, idx, descr); ok {\n\t\tif !p.proxyDefineOwnPropertyPreCheck(booleanTrapResult, throw) {\n\t\t\treturn false\n\t\t}\n\t\tp.proxyDefineOwnPropertyPostCheck(target.self.getOwnPropIdx(idx), target, descr)\n\t\treturn true\n\t}\n\n\treturn target.self.defineOwnPropertyIdx(idx, descr, throw)\n}\n\nfunc (p *proxyObject) defineOwnPropertySym(s *Symbol, descr PropertyDescriptor, throw bool) bool {\n\ttarget := p.target\n\tif booleanTrapResult, ok := p.checkHandler().definePropertySym(target, s, descr); ok {\n\t\tif !p.proxyDefineOwnPropertyPreCheck(booleanTrapResult, throw) {\n\t\t\treturn false\n\t\t}\n\t\tp.proxyDefineOwnPropertyPostCheck(target.self.getOwnPropSym(s), target, descr)\n\t\treturn true\n\t}\n\n\treturn target.self.defineOwnPropertySym(s, descr, throw)\n}\n\nfunc (p *proxyObject) proxyHasChecks(targetProp Value, target *Object, name fmt.Stringer) {\n\ttargetDesc := propToValueProp(targetProp)\n\tif targetDesc != nil {\n\t\tif !targetDesc.configurable {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'has' on proxy: trap returned falsish for property '%s' which exists in the proxy target as non-configurable\", name.String()))\n\t\t}\n\t\tif !target.self.isExtensible() {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'has' on proxy: trap returned falsish for property '%s' but the proxy target is not extensible\", name.String()))\n\t\t}\n\t}\n}\n\nfunc (p *proxyObject) hasPropertyStr(name unistring.String) bool {\n\ttarget := p.target\n\tif b, ok := p.checkHandler().hasStr(target, name); ok {\n\t\tif !b {\n\t\t\tp.proxyHasChecks(target.self.getOwnPropStr(name), target, name)\n\t\t}\n\t\treturn b\n\t}\n\n\treturn target.self.hasPropertyStr(name)\n}\n\nfunc (p *proxyObject) hasPropertyIdx(idx valueInt) bool {\n\ttarget := p.target\n\tif b, ok := p.checkHandler().hasIdx(target, idx); ok {\n\t\tif !b {\n\t\t\tp.proxyHasChecks(target.self.getOwnPropIdx(idx), target, idx)\n\t\t}\n\t\treturn b\n\t}\n\n\treturn target.self.hasPropertyIdx(idx)\n}\n\nfunc (p *proxyObject) hasPropertySym(s *Symbol) bool {\n\ttarget := p.target\n\tif b, ok := p.checkHandler().hasSym(target, s); ok {\n\t\tif !b {\n\t\t\tp.proxyHasChecks(target.self.getOwnPropSym(s), target, s)\n\t\t}\n\t\treturn b\n\t}\n\n\treturn target.self.hasPropertySym(s)\n}\n\nfunc (p *proxyObject) hasOwnPropertyStr(name unistring.String) bool {\n\treturn p.getOwnPropStr(name) != nil\n}\n\nfunc (p *proxyObject) hasOwnPropertyIdx(idx valueInt) bool {\n\treturn p.getOwnPropIdx(idx) != nil\n}\n\nfunc (p *proxyObject) hasOwnPropertySym(s *Symbol) bool {\n\treturn p.getOwnPropSym(s) != nil\n}\n\nfunc (p *proxyObject) proxyGetOwnPropertyDescriptor(targetProp Value, target *Object, trapResult Value, name fmt.Stringer) Value {\n\tr := p.val.runtime\n\ttargetDesc := propToValueProp(targetProp)\n\tvar trapResultObj *Object\n\tif trapResult != nil && trapResult != _undefined {\n\t\tif obj, ok := trapResult.(*Object); ok {\n\t\t\ttrapResultObj = obj\n\t\t} else {\n\t\t\tpanic(r.NewTypeError(\"'getOwnPropertyDescriptor' on proxy: trap returned neither object nor undefined for property '%s'\", name.String()))\n\t\t}\n\t}\n\tif trapResultObj == nil {\n\t\tif targetDesc == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif !targetDesc.configurable {\n\t\t\tpanic(r.NewTypeError())\n\t\t}\n\t\tif !target.self.isExtensible() {\n\t\t\tpanic(r.NewTypeError())\n\t\t}\n\t\treturn nil\n\t}\n\textensibleTarget := target.self.isExtensible()\n\tresultDesc := r.toPropertyDescriptor(trapResultObj)\n\tresultDesc.complete()\n\tif !p.__isCompatibleDescriptor(extensibleTarget, &resultDesc, targetDesc) {\n\t\tpanic(r.NewTypeError(\"'getOwnPropertyDescriptor' on proxy: trap returned descriptor for property '%s' that is incompatible with the existing property in the proxy target\", name.String()))\n\t}\n\n\tif resultDesc.Configurable == FLAG_FALSE {\n\t\tif targetDesc == nil {\n\t\t\tpanic(r.NewTypeError(\"'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '%s' which is non-existent in the proxy target\", name.String()))\n\t\t}\n\n\t\tif targetDesc.configurable {\n\t\t\tpanic(r.NewTypeError(\"'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '%s' which is configurable in the proxy target\", name.String()))\n\t\t}\n\n\t\tif resultDesc.Writable == FLAG_FALSE && targetDesc.writable {\n\t\t\tpanic(r.NewTypeError(\"'getOwnPropertyDescriptor' on proxy: trap reported non-configurable and writable for property '%s' which is non-configurable, non-writable in the proxy target\", name.String()))\n\t\t}\n\t}\n\n\tif resultDesc.Writable == FLAG_TRUE && resultDesc.Configurable == FLAG_TRUE &&\n\t\tresultDesc.Enumerable == FLAG_TRUE {\n\t\treturn resultDesc.Value\n\t}\n\treturn r.toValueProp(trapResultObj)\n}\n\nfunc (p *proxyObject) getOwnPropStr(name unistring.String) Value {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().getOwnPropertyDescriptorStr(target, name); ok {\n\t\treturn p.proxyGetOwnPropertyDescriptor(target.self.getOwnPropStr(name), target, v, name)\n\t}\n\n\treturn target.self.getOwnPropStr(name)\n}\n\nfunc (p *proxyObject) getOwnPropIdx(idx valueInt) Value {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().getOwnPropertyDescriptorIdx(target, idx); ok {\n\t\treturn p.proxyGetOwnPropertyDescriptor(target.self.getOwnPropIdx(idx), target, v, idx)\n\t}\n\n\treturn target.self.getOwnPropIdx(idx)\n}\n\nfunc (p *proxyObject) getOwnPropSym(s *Symbol) Value {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().getOwnPropertyDescriptorSym(target, s); ok {\n\t\treturn p.proxyGetOwnPropertyDescriptor(target.self.getOwnPropSym(s), target, v, s)\n\t}\n\n\treturn target.self.getOwnPropSym(s)\n}\n\nfunc (p *proxyObject) proxyGetChecks(targetProp, trapResult Value, name fmt.Stringer) {\n\tif targetDesc, ok := targetProp.(*valueProperty); ok {\n\t\tif !targetDesc.accessor {\n\t\t\tif !targetDesc.writable && !targetDesc.configurable && !trapResult.SameAs(targetDesc.value) {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'get' on proxy: property '%s' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '%s' but got '%s')\", name.String(), nilSafe(targetDesc.value), ret))\n\t\t\t}\n\t\t} else {\n\t\t\tif !targetDesc.configurable && targetDesc.getterFunc == nil && trapResult != _undefined {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'get' on proxy: property '%s' is a non-configurable accessor property on the proxy target and does not have a getter function, but the trap did not return 'undefined' (got '%s')\", name.String(), ret))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *proxyObject) getStr(name unistring.String, receiver Value) Value {\n\ttarget := p.target\n\tif receiver == nil {\n\t\treceiver = p.val\n\t}\n\tif v, ok := p.checkHandler().getStr(target, name, receiver); ok {\n\t\tp.proxyGetChecks(target.self.getOwnPropStr(name), v, name)\n\t\treturn v\n\t}\n\treturn target.self.getStr(name, receiver)\n}\n\nfunc (p *proxyObject) getIdx(idx valueInt, receiver Value) Value {\n\ttarget := p.target\n\tif receiver == nil {\n\t\treceiver = p.val\n\t}\n\tif v, ok := p.checkHandler().getIdx(target, idx, receiver); ok {\n\t\tp.proxyGetChecks(target.self.getOwnPropIdx(idx), v, idx)\n\t\treturn v\n\t}\n\treturn target.self.getIdx(idx, receiver)\n}\n\nfunc (p *proxyObject) getSym(s *Symbol, receiver Value) Value {\n\ttarget := p.target\n\tif receiver == nil {\n\t\treceiver = p.val\n\t}\n\tif v, ok := p.checkHandler().getSym(target, s, receiver); ok {\n\t\tp.proxyGetChecks(target.self.getOwnPropSym(s), v, s)\n\t\treturn v\n\t}\n\n\treturn target.self.getSym(s, receiver)\n}\n\nfunc (p *proxyObject) proxySetPreCheck(trapResult, throw bool, name fmt.Stringer) bool {\n\tif !trapResult {\n\t\tp.val.runtime.typeErrorResult(throw, \"'set' on proxy: trap returned falsish for property '%s'\", name.String())\n\t}\n\treturn trapResult\n}\n\nfunc (p *proxyObject) proxySetPostCheck(targetProp, value Value, name fmt.Stringer) {\n\tif prop, ok := targetProp.(*valueProperty); ok {\n\t\tif prop.accessor {\n\t\t\tif !prop.configurable && prop.setterFunc == nil {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'set' on proxy: trap returned truish for property '%s' which exists in the proxy target as a non-configurable and non-writable accessor property without a setter\", name.String()))\n\t\t\t}\n\t\t} else if !prop.configurable && !prop.writable && !p.__sameValue(prop.value, value) {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'set' on proxy: trap returned truish for property '%s' which exists in the proxy target as a non-configurable and non-writable data property with a different value\", name.String()))\n\t\t}\n\t}\n}\n\nfunc (p *proxyObject) proxySetStr(name unistring.String, value, receiver Value, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().setStr(target, name, value, receiver); ok {\n\t\tif p.proxySetPreCheck(v, throw, name) {\n\t\t\tp.proxySetPostCheck(target.self.getOwnPropStr(name), value, name)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn target.setStr(name, value, receiver, throw)\n}\n\nfunc (p *proxyObject) proxySetIdx(idx valueInt, value, receiver Value, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().setIdx(target, idx, value, receiver); ok {\n\t\tif p.proxySetPreCheck(v, throw, idx) {\n\t\t\tp.proxySetPostCheck(target.self.getOwnPropIdx(idx), value, idx)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn target.setIdx(idx, value, receiver, throw)\n}\n\nfunc (p *proxyObject) proxySetSym(s *Symbol, value, receiver Value, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().setSym(target, s, value, receiver); ok {\n\t\tif p.proxySetPreCheck(v, throw, s) {\n\t\t\tp.proxySetPostCheck(target.self.getOwnPropSym(s), value, s)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn target.setSym(s, value, receiver, throw)\n}\n\nfunc (p *proxyObject) setOwnStr(name unistring.String, v Value, throw bool) bool {\n\treturn p.proxySetStr(name, v, p.val, throw)\n}\n\nfunc (p *proxyObject) setOwnIdx(idx valueInt, v Value, throw bool) bool {\n\treturn p.proxySetIdx(idx, v, p.val, throw)\n}\n\nfunc (p *proxyObject) setOwnSym(s *Symbol, v Value, throw bool) bool {\n\treturn p.proxySetSym(s, v, p.val, throw)\n}\n\nfunc (p *proxyObject) setForeignStr(name unistring.String, v, receiver Value, throw bool) (bool, bool) {\n\treturn p.proxySetStr(name, v, receiver, throw), true\n}\n\nfunc (p *proxyObject) setForeignIdx(idx valueInt, v, receiver Value, throw bool) (bool, bool) {\n\treturn p.proxySetIdx(idx, v, receiver, throw), true\n}\n\nfunc (p *proxyObject) setForeignSym(s *Symbol, v, receiver Value, throw bool) (bool, bool) {\n\treturn p.proxySetSym(s, v, receiver, throw), true\n}\n\nfunc (p *proxyObject) proxyDeleteCheck(trapResult bool, targetProp Value, name fmt.Stringer, target *Object, throw bool) {\n\tif trapResult {\n\t\tif targetProp == nil {\n\t\t\treturn\n\t\t}\n\t\tif targetDesc, ok := targetProp.(*valueProperty); ok {\n\t\t\tif !targetDesc.configurable {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'deleteProperty' on proxy: property '%s' is a non-configurable property but the trap returned truish\", name.String()))\n\t\t\t}\n\t\t}\n\t\tif !target.self.isExtensible() {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'deleteProperty' on proxy: trap returned truish for property '%s' but the proxy target is non-extensible\", name.String()))\n\t\t}\n\t} else {\n\t\tp.val.runtime.typeErrorResult(throw, \"'deleteProperty' on proxy: trap returned falsish for property '%s'\", name.String())\n\t}\n}\n\nfunc (p *proxyObject) deleteStr(name unistring.String, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().deleteStr(target, name); ok {\n\t\tp.proxyDeleteCheck(v, target.self.getOwnPropStr(name), name, target, throw)\n\t\treturn v\n\t}\n\n\treturn target.self.deleteStr(name, throw)\n}\n\nfunc (p *proxyObject) deleteIdx(idx valueInt, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().deleteIdx(target, idx); ok {\n\t\tp.proxyDeleteCheck(v, target.self.getOwnPropIdx(idx), idx, target, throw)\n\t\treturn v\n\t}\n\n\treturn target.self.deleteIdx(idx, throw)\n}\n\nfunc (p *proxyObject) deleteSym(s *Symbol, throw bool) bool {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().deleteSym(target, s); ok {\n\t\tp.proxyDeleteCheck(v, target.self.getOwnPropSym(s), s, target, throw)\n\t\treturn v\n\t}\n\n\treturn target.self.deleteSym(s, throw)\n}\n\nfunc (p *proxyObject) keys(all bool, _ []Value) []Value {\n\tif v, ok := p.proxyOwnKeys(); ok {\n\t\tif !all {\n\t\t\tk := 0\n\t\t\tfor i, key := range v {\n\t\t\t\tprop := p.val.getOwnProp(key)\n\t\t\t\tif prop == nil || prop == _undefined {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.enumerable {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif k != i {\n\t\t\t\t\tv[k] = v[i]\n\t\t\t\t}\n\t\t\t\tk++\n\t\t\t}\n\t\t\tv = v[:k]\n\t\t}\n\t\treturn v\n\t}\n\treturn p.target.self.keys(all, nil)\n}\n\nfunc (p *proxyObject) proxyOwnKeys() ([]Value, bool) {\n\ttarget := p.target\n\tif v, ok := p.checkHandler().ownKeys(target); ok {\n\t\tkeys := p.val.runtime.toObject(v)\n\t\tvar keyList []Value\n\t\tkeySet := make(map[Value]struct{})\n\t\tl := toLength(keys.self.getStr(\"length\", nil))\n\t\tfor k := int64(0); k < l; k++ {\n\t\t\titem := keys.self.getIdx(valueInt(k), nil)\n\t\t\tif _, ok := item.(String); !ok {\n\t\t\t\tif _, ok := item.(*Symbol); !ok {\n\t\t\t\t\tpanic(p.val.runtime.NewTypeError(\"%s is not a valid property name\", item.String()))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, exists := keySet[item]; exists {\n\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'ownKeys' on proxy: trap returned duplicate entries\"))\n\t\t\t}\n\t\t\tkeyList = append(keyList, item)\n\t\t\tkeySet[item] = struct{}{}\n\t\t}\n\t\text := target.self.isExtensible()\n\t\tfor item, next := target.self.iterateKeys()(); next != nil; item, next = next() {\n\t\t\tif _, exists := keySet[item.name]; exists {\n\t\t\t\tdelete(keySet, item.name)\n\t\t\t} else {\n\t\t\t\tif !ext {\n\t\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'ownKeys' on proxy: trap result did not include '%s'\", item.name.String()))\n\t\t\t\t}\n\t\t\t\tvar prop Value\n\t\t\t\tif item.value == nil {\n\t\t\t\t\tprop = target.getOwnProp(item.name)\n\t\t\t\t} else {\n\t\t\t\t\tprop = item.value\n\t\t\t\t}\n\t\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.configurable {\n\t\t\t\t\tpanic(p.val.runtime.NewTypeError(\"'ownKeys' on proxy: trap result did not include non-configurable '%s'\", item.name.String()))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !ext && len(keyList) > 0 && len(keySet) > 0 {\n\t\t\tpanic(p.val.runtime.NewTypeError(\"'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible\"))\n\t\t}\n\n\t\treturn keyList, true\n\t}\n\n\treturn nil, false\n}\n\nfunc (p *proxyObject) iterateStringKeys() iterNextFunc {\n\treturn (&proxyPropIter{\n\t\tp:     p,\n\t\tnames: p.stringKeys(true, nil),\n\t}).next\n}\n\nfunc (p *proxyObject) iterateSymbols() iterNextFunc {\n\treturn (&proxyPropIter{\n\t\tp:     p,\n\t\tnames: p.symbols(true, nil),\n\t}).next\n}\n\nfunc (p *proxyObject) iterateKeys() iterNextFunc {\n\treturn (&proxyPropIter{\n\t\tp:     p,\n\t\tnames: p.keys(true, nil),\n\t}).next\n}\n\nfunc (p *proxyObject) assertCallable() (call func(FunctionCall) Value, ok bool) {\n\tif p.call != nil {\n\t\treturn func(call FunctionCall) Value {\n\t\t\treturn p.apply(call)\n\t\t}, true\n\t}\n\treturn nil, false\n}\n\nfunc (p *proxyObject) vmCall(vm *vm, n int) {\n\tvm.pushCtx()\n\tvm.prg = nil\n\tvm.sb = vm.sp - n // so that [sb-1] points to the callee\n\tret := p.apply(FunctionCall{This: vm.stack[vm.sp-n-2], Arguments: vm.stack[vm.sp-n : vm.sp]})\n\tif ret == nil {\n\t\tret = _undefined\n\t}\n\tvm.stack[vm.sp-n-2] = ret\n\tvm.popCtx()\n\tvm.sp -= n + 1\n\tvm.pc++\n}\n\nfunc (p *proxyObject) assertConstructor() func(args []Value, newTarget *Object) *Object {\n\tif p.ctor != nil {\n\t\treturn p.construct\n\t}\n\treturn nil\n}\n\nfunc (p *proxyObject) apply(call FunctionCall) Value {\n\tif p.call == nil {\n\t\tpanic(p.val.runtime.NewTypeError(\"proxy target is not a function\"))\n\t}\n\tif v, ok := p.checkHandler().apply(p.target, nilSafe(call.This), call.Arguments); ok {\n\t\treturn v\n\t}\n\treturn p.call(call)\n}\n\nfunc (p *proxyObject) construct(args []Value, newTarget *Object) *Object {\n\tif p.ctor == nil {\n\t\tpanic(p.val.runtime.NewTypeError(\"proxy target is not a constructor\"))\n\t}\n\tif newTarget == nil {\n\t\tnewTarget = p.val\n\t}\n\tif v, ok := p.checkHandler().construct(p.target, args, newTarget); ok {\n\t\treturn p.val.runtime.toObject(v)\n\t}\n\treturn p.ctor(args, newTarget)\n}\n\nfunc (p *proxyObject) __isCompatibleDescriptor(extensible bool, desc *PropertyDescriptor, current *valueProperty) bool {\n\tif current == nil {\n\t\treturn extensible\n\t}\n\n\tif !current.configurable {\n\t\tif desc.Configurable == FLAG_TRUE {\n\t\t\treturn false\n\t\t}\n\n\t\tif desc.Enumerable != FLAG_NOT_SET && desc.Enumerable.Bool() != current.enumerable {\n\t\t\treturn false\n\t\t}\n\n\t\tif desc.IsGeneric() {\n\t\t\treturn true\n\t\t}\n\n\t\tif desc.IsData() != !current.accessor {\n\t\t\treturn desc.Configurable != FLAG_FALSE\n\t\t}\n\n\t\tif desc.IsData() && !current.accessor {\n\t\t\tif !current.configurable {\n\t\t\t\tif desc.Writable == FLAG_TRUE && !current.writable {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif !current.writable {\n\t\t\t\t\tif desc.Value != nil && !desc.Value.SameAs(current.value) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tif desc.IsAccessor() && current.accessor {\n\t\t\tif !current.configurable {\n\t\t\t\tif desc.Setter != nil && desc.Setter.SameAs(current.setterFunc) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif desc.Getter != nil && desc.Getter.SameAs(current.getterFunc) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p *proxyObject) __sameValue(val1, val2 Value) bool {\n\tif val1 == nil && val2 == nil {\n\t\treturn true\n\t}\n\tif val1 != nil {\n\t\treturn val1.SameAs(val2)\n\t}\n\treturn false\n}\n\nfunc (p *proxyObject) filterKeys(vals []Value, all, symbols bool) []Value {\n\tif !all {\n\t\tk := 0\n\t\tfor i, val := range vals {\n\t\t\tvar prop Value\n\t\t\tif symbols {\n\t\t\t\tif s, ok := val.(*Symbol); ok {\n\t\t\t\t\tprop = p.getOwnPropSym(s)\n\t\t\t\t} else {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, ok := val.(*Symbol); !ok {\n\t\t\t\t\tprop = p.getOwnPropStr(val.string())\n\t\t\t\t} else {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif prop == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.enumerable {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif k != i {\n\t\t\t\tvals[k] = vals[i]\n\t\t\t}\n\t\t\tk++\n\t\t}\n\t\tvals = vals[:k]\n\t} else {\n\t\tk := 0\n\t\tfor i, val := range vals {\n\t\t\tif _, ok := val.(*Symbol); ok != symbols {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif k != i {\n\t\t\t\tvals[k] = vals[i]\n\t\t\t}\n\t\t\tk++\n\t\t}\n\t\tvals = vals[:k]\n\t}\n\treturn vals\n}\n\nfunc (p *proxyObject) stringKeys(all bool, _ []Value) []Value { // we can assume accum is empty\n\tvar keys []Value\n\tif vals, ok := p.proxyOwnKeys(); ok {\n\t\tkeys = vals\n\t} else {\n\t\tkeys = p.target.self.stringKeys(true, nil)\n\t}\n\n\treturn p.filterKeys(keys, all, false)\n}\n\nfunc (p *proxyObject) symbols(all bool, accum []Value) []Value {\n\tvar symbols []Value\n\tif vals, ok := p.proxyOwnKeys(); ok {\n\t\tsymbols = vals\n\t} else {\n\t\tsymbols = p.target.self.symbols(true, nil)\n\t}\n\tsymbols = p.filterKeys(symbols, all, true)\n\tif accum == nil {\n\t\treturn symbols\n\t}\n\taccum = append(accum, symbols...)\n\treturn accum\n}\n\nfunc (p *proxyObject) className() string {\n\tif p.target == nil {\n\t\tpanic(p.val.runtime.NewTypeError(\"proxy has been revoked\"))\n\t}\n\tif p.call != nil || p.ctor != nil {\n\t\treturn classFunction\n\t}\n\treturn classObject\n}\n\nfunc (p *proxyObject) typeOf() String {\n\tif p.call == nil {\n\t\treturn stringObjectC\n\t}\n\n\treturn stringFunction\n}\n\nfunc (p *proxyObject) exportType() reflect.Type {\n\treturn proxyType\n}\n\nfunc (p *proxyObject) export(*objectExportCtx) interface{} {\n\treturn Proxy{\n\t\tproxy: p,\n\t}\n}\n\nfunc (p *proxyObject) revoke() {\n\tp.handler = nil\n\tp.target = nil\n}\n"
        },
        {
          "name": "regexp.go",
          "type": "blob",
          "size": 15.494140625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"github.com/dlclark/regexp2\"\n\t\"github.com/dop251/goja/unistring\"\n\t\"io\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode/utf16\"\n)\n\ntype regexp2MatchCache struct {\n\ttarget String\n\trunes  []rune\n\tposMap []int\n}\n\n// Not goroutine-safe. Use regexp2Wrapper.clone()\ntype regexp2Wrapper struct {\n\trx    *regexp2.Regexp\n\tcache *regexp2MatchCache\n}\n\ntype regexpWrapper regexp.Regexp\n\ntype positionMapItem struct {\n\tsrc, dst int\n}\ntype positionMap []positionMapItem\n\nfunc (m positionMap) get(src int) int {\n\tif src <= 0 {\n\t\treturn src\n\t}\n\tres := sort.Search(len(m), func(n int) bool { return m[n].src >= src })\n\tif res >= len(m) || m[res].src != src {\n\t\tpanic(\"index not found\")\n\t}\n\treturn m[res].dst\n}\n\ntype arrayRuneReader struct {\n\trunes []rune\n\tpos   int\n}\n\nfunc (rd *arrayRuneReader) ReadRune() (r rune, size int, err error) {\n\tif rd.pos < len(rd.runes) {\n\t\tr = rd.runes[rd.pos]\n\t\tsize = 1\n\t\trd.pos++\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\n// Not goroutine-safe. Use regexpPattern.clone()\ntype regexpPattern struct {\n\tsrc string\n\n\tglobal, ignoreCase, multiline, dotAll, sticky, unicode bool\n\n\tregexpWrapper  *regexpWrapper\n\tregexp2Wrapper *regexp2Wrapper\n}\n\nfunc compileRegexp2(src string, multiline, dotAll, ignoreCase, unicode bool) (*regexp2Wrapper, error) {\n\tvar opts regexp2.RegexOptions = regexp2.ECMAScript\n\tif multiline {\n\t\topts |= regexp2.Multiline\n\t}\n\tif dotAll {\n\t\topts |= regexp2.Singleline\n\t}\n\tif ignoreCase {\n\t\topts |= regexp2.IgnoreCase\n\t}\n\tif unicode {\n\t\topts |= regexp2.Unicode\n\t}\n\tregexp2Pattern, err1 := regexp2.Compile(src, opts)\n\tif err1 != nil {\n\t\treturn nil, fmt.Errorf(\"Invalid regular expression (regexp2): %s (%v)\", src, err1)\n\t}\n\n\treturn &regexp2Wrapper{rx: regexp2Pattern}, nil\n}\n\nfunc (p *regexpPattern) createRegexp2() {\n\tif p.regexp2Wrapper != nil {\n\t\treturn\n\t}\n\trx, err := compileRegexp2(p.src, p.multiline, p.dotAll, p.ignoreCase, p.unicode)\n\tif err != nil {\n\t\t// At this point the regexp should have been successfully converted to re2, if it fails now, it's a bug.\n\t\tpanic(err)\n\t}\n\tp.regexp2Wrapper = rx\n}\n\nfunc buildUTF8PosMap(s unicodeString) (positionMap, string) {\n\tpm := make(positionMap, 0, s.Length())\n\trd := s.Reader()\n\tsPos, utf8Pos := 0, 0\n\tvar sb strings.Builder\n\tfor {\n\t\tr, size, err := rd.ReadRune()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\t// the string contains invalid UTF-16, bailing out\n\t\t\treturn nil, \"\"\n\t\t}\n\t\tutf8Size, _ := sb.WriteRune(r)\n\t\tsPos += size\n\t\tutf8Pos += utf8Size\n\t\tpm = append(pm, positionMapItem{src: utf8Pos, dst: sPos})\n\t}\n\treturn pm, sb.String()\n}\n\nfunc (p *regexpPattern) findSubmatchIndex(s String, start int) []int {\n\tif p.regexpWrapper == nil {\n\t\treturn p.regexp2Wrapper.findSubmatchIndex(s, start, p.unicode, p.global || p.sticky)\n\t}\n\tif start != 0 {\n\t\t// Unfortunately Go's regexp library does not allow starting from an arbitrary position.\n\t\t// If we just drop the first _start_ characters of the string the assertions (^, $, \\b and \\B) will not\n\t\t// work correctly.\n\t\tp.createRegexp2()\n\t\treturn p.regexp2Wrapper.findSubmatchIndex(s, start, p.unicode, p.global || p.sticky)\n\t}\n\treturn p.regexpWrapper.findSubmatchIndex(s, p.unicode)\n}\n\nfunc (p *regexpPattern) findAllSubmatchIndex(s String, start int, limit int, sticky bool) [][]int {\n\tif p.regexpWrapper == nil {\n\t\treturn p.regexp2Wrapper.findAllSubmatchIndex(s, start, limit, sticky, p.unicode)\n\t}\n\tif start == 0 {\n\t\ta, u := devirtualizeString(s)\n\t\tif u == nil {\n\t\t\treturn p.regexpWrapper.findAllSubmatchIndex(string(a), limit, sticky)\n\t\t}\n\t\tif limit == 1 {\n\t\t\tresult := p.regexpWrapper.findSubmatchIndexUnicode(u, p.unicode)\n\t\t\tif result == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn [][]int{result}\n\t\t}\n\t\t// Unfortunately Go's regexp library lacks FindAllReaderSubmatchIndex(), so we have to use a UTF-8 string as an\n\t\t// input.\n\t\tif p.unicode {\n\t\t\t// Try to convert s to UTF-8. If it does not contain any invalid UTF-16 we can do the matching in UTF-8.\n\t\t\tpm, str := buildUTF8PosMap(u)\n\t\t\tif pm != nil {\n\t\t\t\tres := p.regexpWrapper.findAllSubmatchIndex(str, limit, sticky)\n\t\t\t\tfor _, result := range res {\n\t\t\t\t\tfor i, idx := range result {\n\t\t\t\t\t\tresult[i] = pm.get(idx)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t}\n\n\tp.createRegexp2()\n\treturn p.regexp2Wrapper.findAllSubmatchIndex(s, start, limit, sticky, p.unicode)\n}\n\n// clone creates a copy of the regexpPattern which can be used concurrently.\nfunc (p *regexpPattern) clone() *regexpPattern {\n\tret := &regexpPattern{\n\t\tsrc:        p.src,\n\t\tglobal:     p.global,\n\t\tignoreCase: p.ignoreCase,\n\t\tmultiline:  p.multiline,\n\t\tdotAll:     p.dotAll,\n\t\tsticky:     p.sticky,\n\t\tunicode:    p.unicode,\n\t}\n\tif p.regexpWrapper != nil {\n\t\tret.regexpWrapper = p.regexpWrapper.clone()\n\t}\n\tif p.regexp2Wrapper != nil {\n\t\tret.regexp2Wrapper = p.regexp2Wrapper.clone()\n\t}\n\treturn ret\n}\n\ntype regexpObject struct {\n\tbaseObject\n\tpattern *regexpPattern\n\tsource  String\n\n\tstandard bool\n}\n\nfunc (r *regexp2Wrapper) findSubmatchIndex(s String, start int, fullUnicode, doCache bool) (result []int) {\n\tif fullUnicode {\n\t\treturn r.findSubmatchIndexUnicode(s, start, doCache)\n\t}\n\treturn r.findSubmatchIndexUTF16(s, start, doCache)\n}\n\nfunc (r *regexp2Wrapper) findUTF16Cached(s String, start int, doCache bool) (match *regexp2.Match, runes []rune, err error) {\n\twrapped := r.rx\n\tcache := r.cache\n\tif cache != nil && cache.posMap == nil && cache.target.SameAs(s) {\n\t\trunes = cache.runes\n\t} else {\n\t\trunes = s.utf16Runes()\n\t\tcache = nil\n\t}\n\tmatch, err = wrapped.FindRunesMatchStartingAt(runes, start)\n\tif doCache && match != nil && err == nil {\n\t\tif cache == nil {\n\t\t\tif r.cache == nil {\n\t\t\t\tr.cache = new(regexp2MatchCache)\n\t\t\t}\n\t\t\t*r.cache = regexp2MatchCache{\n\t\t\t\ttarget: s,\n\t\t\t\trunes:  runes,\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr.cache = nil\n\t}\n\treturn\n}\n\nfunc (r *regexp2Wrapper) findSubmatchIndexUTF16(s String, start int, doCache bool) (result []int) {\n\tmatch, _, err := r.findUTF16Cached(s, start, doCache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif match == nil {\n\t\treturn\n\t}\n\tgroups := match.Groups()\n\n\tresult = make([]int, 0, len(groups)<<1)\n\tfor _, group := range groups {\n\t\tif len(group.Captures) > 0 {\n\t\t\tresult = append(result, group.Index, group.Index+group.Length)\n\t\t} else {\n\t\t\tresult = append(result, -1, 0)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (r *regexp2Wrapper) findUnicodeCached(s String, start int, doCache bool) (match *regexp2.Match, posMap []int, err error) {\n\tvar (\n\t\trunes       []rune\n\t\tmappedStart int\n\t\tsplitPair   bool\n\t\tsavedRune   rune\n\t)\n\twrapped := r.rx\n\tcache := r.cache\n\tif cache != nil && cache.posMap != nil && cache.target.SameAs(s) {\n\t\trunes, posMap = cache.runes, cache.posMap\n\t\tmappedStart, splitPair = posMapReverseLookup(posMap, start)\n\t} else {\n\t\tposMap, runes, mappedStart, splitPair = buildPosMap(&lenientUtf16Decoder{utf16Reader: s.utf16Reader()}, s.Length(), start)\n\t\tcache = nil\n\t}\n\tif splitPair {\n\t\t// temporarily set the rune at mappedStart to the second code point of the pair\n\t\t_, second := utf16.EncodeRune(runes[mappedStart])\n\t\tsavedRune, runes[mappedStart] = runes[mappedStart], second\n\t}\n\tmatch, err = wrapped.FindRunesMatchStartingAt(runes, mappedStart)\n\tif doCache && match != nil && err == nil {\n\t\tif splitPair {\n\t\t\trunes[mappedStart] = savedRune\n\t\t}\n\t\tif cache == nil {\n\t\t\tif r.cache == nil {\n\t\t\t\tr.cache = new(regexp2MatchCache)\n\t\t\t}\n\t\t\t*r.cache = regexp2MatchCache{\n\t\t\t\ttarget: s,\n\t\t\t\trunes:  runes,\n\t\t\t\tposMap: posMap,\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr.cache = nil\n\t}\n\n\treturn\n}\n\nfunc (r *regexp2Wrapper) findSubmatchIndexUnicode(s String, start int, doCache bool) (result []int) {\n\tmatch, posMap, err := r.findUnicodeCached(s, start, doCache)\n\tif match == nil || err != nil {\n\t\treturn\n\t}\n\n\tgroups := match.Groups()\n\n\tresult = make([]int, 0, len(groups)<<1)\n\tfor _, group := range groups {\n\t\tif len(group.Captures) > 0 {\n\t\t\tresult = append(result, posMap[group.Index], posMap[group.Index+group.Length])\n\t\t} else {\n\t\t\tresult = append(result, -1, 0)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (r *regexp2Wrapper) findAllSubmatchIndexUTF16(s String, start, limit int, sticky bool) [][]int {\n\twrapped := r.rx\n\tmatch, runes, err := r.findUTF16Cached(s, start, false)\n\tif match == nil || err != nil {\n\t\treturn nil\n\t}\n\tif limit < 0 {\n\t\tlimit = len(runes) + 1\n\t}\n\tresults := make([][]int, 0, limit)\n\tfor match != nil {\n\t\tgroups := match.Groups()\n\n\t\tresult := make([]int, 0, len(groups)<<1)\n\n\t\tfor _, group := range groups {\n\t\t\tif len(group.Captures) > 0 {\n\t\t\t\tstartPos := group.Index\n\t\t\t\tendPos := group.Index + group.Length\n\t\t\t\tresult = append(result, startPos, endPos)\n\t\t\t} else {\n\t\t\t\tresult = append(result, -1, 0)\n\t\t\t}\n\t\t}\n\n\t\tif sticky && len(result) > 1 {\n\t\t\tif result[0] != start {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tstart = result[1]\n\t\t}\n\n\t\tresults = append(results, result)\n\t\tlimit--\n\t\tif limit <= 0 {\n\t\t\tbreak\n\t\t}\n\t\tmatch, err = wrapped.FindNextMatch(match)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn results\n}\n\nfunc buildPosMap(rd io.RuneReader, l, start int) (posMap []int, runes []rune, mappedStart int, splitPair bool) {\n\tposMap = make([]int, 0, l+1)\n\tcurPos := 0\n\trunes = make([]rune, 0, l)\n\tstartFound := false\n\tfor {\n\t\tif !startFound {\n\t\t\tif curPos == start {\n\t\t\t\tmappedStart = len(runes)\n\t\t\t\tstartFound = true\n\t\t\t}\n\t\t\tif curPos > start {\n\t\t\t\t// start position splits a surrogate pair\n\t\t\t\tmappedStart = len(runes) - 1\n\t\t\t\tsplitPair = true\n\t\t\t\tstartFound = true\n\t\t\t}\n\t\t}\n\t\trn, size, err := rd.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trunes = append(runes, rn)\n\t\tposMap = append(posMap, curPos)\n\t\tcurPos += size\n\t}\n\tposMap = append(posMap, curPos)\n\treturn\n}\n\nfunc posMapReverseLookup(posMap []int, pos int) (int, bool) {\n\tmapped := sort.SearchInts(posMap, pos)\n\tif mapped < len(posMap) && posMap[mapped] != pos {\n\t\treturn mapped - 1, true\n\t}\n\treturn mapped, false\n}\n\nfunc (r *regexp2Wrapper) findAllSubmatchIndexUnicode(s unicodeString, start, limit int, sticky bool) [][]int {\n\twrapped := r.rx\n\tif limit < 0 {\n\t\tlimit = len(s) + 1\n\t}\n\tresults := make([][]int, 0, limit)\n\tmatch, posMap, err := r.findUnicodeCached(s, start, false)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tfor match != nil {\n\t\tgroups := match.Groups()\n\n\t\tresult := make([]int, 0, len(groups)<<1)\n\n\t\tfor _, group := range groups {\n\t\t\tif len(group.Captures) > 0 {\n\t\t\t\tstart := posMap[group.Index]\n\t\t\t\tend := posMap[group.Index+group.Length]\n\t\t\t\tresult = append(result, start, end)\n\t\t\t} else {\n\t\t\t\tresult = append(result, -1, 0)\n\t\t\t}\n\t\t}\n\n\t\tif sticky && len(result) > 1 {\n\t\t\tif result[0] != start {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tstart = result[1]\n\t\t}\n\n\t\tresults = append(results, result)\n\t\tmatch, err = wrapped.FindNextMatch(match)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn results\n}\n\nfunc (r *regexp2Wrapper) findAllSubmatchIndex(s String, start, limit int, sticky, fullUnicode bool) [][]int {\n\ta, u := devirtualizeString(s)\n\tif u != nil {\n\t\tif fullUnicode {\n\t\t\treturn r.findAllSubmatchIndexUnicode(u, start, limit, sticky)\n\t\t}\n\t\treturn r.findAllSubmatchIndexUTF16(u, start, limit, sticky)\n\t}\n\treturn r.findAllSubmatchIndexUTF16(a, start, limit, sticky)\n}\n\nfunc (r *regexp2Wrapper) clone() *regexp2Wrapper {\n\treturn &regexp2Wrapper{\n\t\trx: r.rx,\n\t}\n}\n\nfunc (r *regexpWrapper) findAllSubmatchIndex(s string, limit int, sticky bool) (results [][]int) {\n\twrapped := (*regexp.Regexp)(r)\n\tresults = wrapped.FindAllStringSubmatchIndex(s, limit)\n\tpos := 0\n\tif sticky {\n\t\tfor i, result := range results {\n\t\t\tif len(result) > 1 {\n\t\t\t\tif result[0] != pos {\n\t\t\t\t\treturn results[:i]\n\t\t\t\t}\n\t\t\t\tpos = result[1]\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (r *regexpWrapper) findSubmatchIndex(s String, fullUnicode bool) []int {\n\ta, u := devirtualizeString(s)\n\tif u != nil {\n\t\treturn r.findSubmatchIndexUnicode(u, fullUnicode)\n\t}\n\treturn r.findSubmatchIndexASCII(string(a))\n}\n\nfunc (r *regexpWrapper) findSubmatchIndexASCII(s string) []int {\n\twrapped := (*regexp.Regexp)(r)\n\treturn wrapped.FindStringSubmatchIndex(s)\n}\n\nfunc (r *regexpWrapper) findSubmatchIndexUnicode(s unicodeString, fullUnicode bool) (result []int) {\n\twrapped := (*regexp.Regexp)(r)\n\tif fullUnicode {\n\t\tposMap, runes, _, _ := buildPosMap(&lenientUtf16Decoder{utf16Reader: s.utf16Reader()}, s.Length(), 0)\n\t\tres := wrapped.FindReaderSubmatchIndex(&arrayRuneReader{runes: runes})\n\t\tfor i, item := range res {\n\t\t\tif item >= 0 {\n\t\t\t\tres[i] = posMap[item]\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\treturn wrapped.FindReaderSubmatchIndex(s.utf16RuneReader())\n}\n\nfunc (r *regexpWrapper) clone() *regexpWrapper {\n\treturn r\n}\n\nfunc (r *regexpObject) execResultToArray(target String, result []int) Value {\n\tcaptureCount := len(result) >> 1\n\tvalueArray := make([]Value, captureCount)\n\tmatchIndex := result[0]\n\tvalueArray[0] = target.Substring(result[0], result[1])\n\tlowerBound := 0\n\tfor index := 1; index < captureCount; index++ {\n\t\toffset := index << 1\n\t\tif result[offset] >= 0 && result[offset+1] >= lowerBound {\n\t\t\tvalueArray[index] = target.Substring(result[offset], result[offset+1])\n\t\t\tlowerBound = result[offset]\n\t\t} else {\n\t\t\tvalueArray[index] = _undefined\n\t\t}\n\t}\n\tmatch := r.val.runtime.newArrayValues(valueArray)\n\tmatch.self.setOwnStr(\"input\", target, false)\n\tmatch.self.setOwnStr(\"index\", intToValue(int64(matchIndex)), false)\n\treturn match\n}\n\nfunc (r *regexpObject) getLastIndex() int64 {\n\tlastIndex := toLength(r.getStr(\"lastIndex\", nil))\n\tif !r.pattern.global && !r.pattern.sticky {\n\t\treturn 0\n\t}\n\treturn lastIndex\n}\n\nfunc (r *regexpObject) updateLastIndex(index int64, firstResult, lastResult []int) bool {\n\tif r.pattern.sticky {\n\t\tif firstResult == nil || int64(firstResult[0]) != index {\n\t\t\tr.setOwnStr(\"lastIndex\", intToValue(0), true)\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\tif firstResult == nil {\n\t\t\tif r.pattern.global {\n\t\t\t\tr.setOwnStr(\"lastIndex\", intToValue(0), true)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif r.pattern.global || r.pattern.sticky {\n\t\tr.setOwnStr(\"lastIndex\", intToValue(int64(lastResult[1])), true)\n\t}\n\treturn true\n}\n\nfunc (r *regexpObject) execRegexp(target String) (match bool, result []int) {\n\tindex := r.getLastIndex()\n\tif index >= 0 && index <= int64(target.Length()) {\n\t\tresult = r.pattern.findSubmatchIndex(target, int(index))\n\t}\n\tmatch = r.updateLastIndex(index, result, result)\n\treturn\n}\n\nfunc (r *regexpObject) exec(target String) Value {\n\tmatch, result := r.execRegexp(target)\n\tif match {\n\t\treturn r.execResultToArray(target, result)\n\t}\n\treturn _null\n}\n\nfunc (r *regexpObject) test(target String) bool {\n\tmatch, _ := r.execRegexp(target)\n\treturn match\n}\n\nfunc (r *regexpObject) clone() *regexpObject {\n\tr1 := r.val.runtime.newRegexpObject(r.prototype)\n\tr1.source = r.source\n\tr1.pattern = r.pattern\n\n\treturn r1\n}\n\nfunc (r *regexpObject) init() {\n\tr.baseObject.init()\n\tr.standard = true\n\tr._putProp(\"lastIndex\", intToValue(0), true, false, false)\n}\n\nfunc (r *regexpObject) setProto(proto *Object, throw bool) bool {\n\tres := r.baseObject.setProto(proto, throw)\n\tif res {\n\t\tr.standard = false\n\t}\n\treturn res\n}\n\nfunc (r *regexpObject) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tres := r.baseObject.defineOwnPropertyStr(name, desc, throw)\n\tif res {\n\t\tr.standard = false\n\t}\n\treturn res\n}\n\nfunc (r *regexpObject) defineOwnPropertySym(name *Symbol, desc PropertyDescriptor, throw bool) bool {\n\tres := r.baseObject.defineOwnPropertySym(name, desc, throw)\n\tif res && r.standard {\n\t\tswitch name {\n\t\tcase SymMatch, SymMatchAll, SymSearch, SymSplit, SymReplace:\n\t\t\tr.standard = false\n\t\t}\n\t}\n\treturn res\n}\n\nfunc (r *regexpObject) deleteStr(name unistring.String, throw bool) bool {\n\tres := r.baseObject.deleteStr(name, throw)\n\tif res {\n\t\tr.standard = false\n\t}\n\treturn res\n}\n\nfunc (r *regexpObject) setOwnStr(name unistring.String, value Value, throw bool) bool {\n\tres := r.baseObject.setOwnStr(name, value, throw)\n\tif res && r.standard && name == \"exec\" {\n\t\tr.standard = false\n\t}\n\treturn res\n}\n\nfunc (r *regexpObject) setOwnSym(name *Symbol, value Value, throw bool) bool {\n\tres := r.baseObject.setOwnSym(name, value, throw)\n\tif res && r.standard {\n\t\tswitch name {\n\t\tcase SymMatch, SymMatchAll, SymSearch, SymSplit, SymReplace:\n\t\t\tr.standard = false\n\t\t}\n\t}\n\treturn res\n}\n"
        },
        {
          "name": "regexp_test.go",
          "type": "blob",
          "size": 28.85546875,
          "content": "package goja\n\nimport (\n\t\"testing\"\n)\n\nfunc TestRegexp1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = new RegExp(\"(['\\\"])(.*?)\\\\1\");\n\tvar m = r.exec(\"'test'\");\n\tm !== null && m.length == 3 && m[2] === \"test\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexp2(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = new RegExp(\"(['\\\"])(.*?)['\\\"]\");\n\tvar m = r.exec(\"'test'\");\n\tm !== null && m.length == 3 && m[2] === \"test\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpLiteral(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = /(['\\\"])(.*?)\\1/;\n\tvar m = r.exec(\"'test'\");\n\tm !== null && m.length == 3 && m[2] === \"test\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRe2Unicode(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = /()/i;\n\tvar m = r.exec(\"''\");\n\tm !== null && m.length == 2 && m[1] === \"\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRe2UnicodeTarget(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = /(['\\\"])(.*?)['\\\"]/i;\n\tvar m = r.exec(\"''\");\n\tm !== null && m.length == 3 && m[2] === \"\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRegexp2Unicode(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = /(['\\\"])()\\1/i;\n\tvar m = r.exec(\"''\");\n\tm !== null && m.length == 3 && m[2] === \"\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRegexp2UnicodeTarget(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = /(['\\\"])(.*?)\\1/;\n\tvar m = r.exec(\"''\");\n\tm !== null && m.length == 3 && m[2] === \"\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRe2Whitespace(t *testing.T) {\n\tconst SCRIPT = `\n\t\"\\u2000\\u2001\\u2002\\u200b\".replace(/\\s+/g, \"\") === \"\\u200b\";\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpRegexp2Whitespace(t *testing.T) {\n\tconst SCRIPT = `\n\t\"A\\u2000\\u2001\\u2002A\\u200b\".replace(/(A)\\s+\\1/g, \"\") === \"\\u200b\"\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEmptyCharClassRe2(t *testing.T) {\n\tconst SCRIPT = `\n\t/[]/.test(\"\\u0000\");\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestNegatedEmptyCharClassRe2(t *testing.T) {\n\tconst SCRIPT = `\n\t/[^]/.test(\"\\u0000\");\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestEmptyCharClassRegexp2(t *testing.T) {\n\tconst SCRIPT = `\n\t/([])\\1/.test(\"\\u0000\\u0000\");\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestRegexp2Negate(t *testing.T) {\n\tconst SCRIPT = `\n\t/([\\D1])\\1/.test(\"aa\");\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestAlternativeRe2(t *testing.T) {\n\tconst SCRIPT = `\n\t/()|/.exec(\"\") !== null;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpReplaceGlobal(t *testing.T) {\n\tconst SCRIPT = `\n\t\"QBZPbage\\ny_cynprubyqre\".replace(/^\\s*|\\s*$/g, '')\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"QBZPbage\\ny_cynprubyqre\"), t)\n}\n\nfunc TestRegexpNumCaptures(t *testing.T) {\n\tconst SCRIPT = `\n\t\"Fubpxjnir Synfu 9.0  e115\".replace(/([a-zA-Z]|\\s)+/, '')\n\t`\n\ttestScript(SCRIPT, asciiString(\"9.0  e115\"), t)\n}\n\nfunc TestRegexpNumCaptures1(t *testing.T) {\n\tconst SCRIPT = `\n\t\"Fubpxjnir Sy\\tfu 9.0  e115\".replace(/^.*\\s+(\\S+\\s+\\S+$)/, '')\n\t`\n\ttestScript(SCRIPT, asciiString(\"\"), t)\n}\n\nfunc TestRegexpSInClass(t *testing.T) {\n\tconst SCRIPT = `\n\t/[\\S]/.test(\"\\u2028\");\n\t`\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestRegexpDotMatchCR(t *testing.T) {\n\tconst SCRIPT = `\n\t/./.test(\"\\r\");\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestRegexpDotMatchCRInGroup(t *testing.T) {\n\tconst SCRIPT = `\n\t/(.)/.test(\"\\r\");\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestRegexpDotMatchLF(t *testing.T) {\n\tconst SCRIPT = `\n\t/./.test(\"\\n\");\n\t`\n\n\ttestScript(SCRIPT, valueFalse, t)\n}\n\nfunc TestRegexpSplitWithBackRef(t *testing.T) {\n\tconst SCRIPT = `\n\t\"a++b+-c\".split(/([+-])\\1/).join(\" $$ \")\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"a $$ + $$ b+-c\"), t)\n}\n\nfunc TestEscapeNonASCII(t *testing.T) {\n\tconst SCRIPT = `\n\t/\\/.test(\"\")\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpUTF16(t *testing.T) {\n\tconst SCRIPT = `\n\tvar str = \"\\uD800\\uDC00\";\n\n\tassert(/\\uD800/g.test(str), \"#1\");\n\tassert(/\\uD800/.test(str), \"#2\");\n\tassert(//.test(str), \"#3\");\n\n\tvar re = /\\uD800/;\n\n\tassert(compareArray(str.replace(re, \"X\"), [\"X\", \"\\uDC00\"]), \"#4\");\n\tassert(compareArray(str.split(re), [\"\", \"\\uDC00\"]), \"#5\");\n\tassert(compareArray(\"a\\uD800\\uDC00b\".split(/\\uD800/g), [\"a\", \"\\uDC00b\"]), \"#6\");\n\tassert(compareArray(\"a\\uD800\\uDC00b\".split(/(?:)/g), [\"a\", \"\\uD800\", \"\\uDC00\", \"b\"]), \"#7\");\n\tassert(compareArray(\"0\\x80\".split(/(0){0}/g), [\"0\", undefined, \"\\x80\"]), \"#7+\");\n\n\tre = /(?=)a/; // a hack to use regexp2\n\tassert.sameValue(re.exec('\\ud83d\\ude02a').index, 2, \"#8\");\n\n\tassert.sameValue(/./.exec('\\ud83d\\ude02')[0], '\\ud83d', \"#9\");\n\n\tassert(RegExp(\"\\uD800\").test(\"\\uD800\"), \"#10\");\n\n\tvar cu = 0xD800;\n\tvar xx = \"a\\\\\" + String.fromCharCode(cu);\n\tvar pattern = eval(\"/\" + xx + \"/\");\n\tassert.sameValue(pattern.source, \"a\\\\\\\\\\\\ud800\", \"Code unit: \" + cu.toString(16), \"#11\");\n\tassert(pattern.test(\"a\\\\\\uD800\"), \"#12\");\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpUnicode(t *testing.T) {\n\tconst SCRIPT = `\n\n\tassert(!/\\uD800/u.test(\"\\uD800\\uDC00\"), \"#1\");\n\tassert(!/\\uFFFD/u.test(\"\\uD800\\uDC00\"), \"#2\");\n\n\tassert(/\\uD800\\uDC00/u.test(\"\\uD800\\uDC00\"), \"#3\");\n\n\tassert(/\\uD800/u.test(\"\\uD800\"), \"#4\");\n\n\tassert(compareArray(\"a\\uD800\\uDC00b\".split(/\\uD800/gu), [\"a\\uD800\\uDC00b\"]), \"#5\");\n\n\tassert(compareArray(\"a\\uD800\\uDC00b\".split(/(?:)/gu), [\"a\", \"\", \"b\"]), \"#6\");\n\n\tassert(compareArray(\"0\\x80\".split(/(0){0}/gu), [\"0\", undefined, \"\\x80\"]), \"#7\");\n\n\tvar re = eval('/' + /\\ud834\\udf06/u.source + '/u');\n\tassert(re.test('\\ud834\\udf06'), \"#9\");\n\n\t/*re = RegExp(\"\\\\p{L}\", \"u\");\n\tif (!re.test(\"A\")) {\n\t\tthrow new Error(\"Test 9 failed\");\n\t}*/\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestConvertRegexpToUnicode(t *testing.T) {\n\tif s := convertRegexpToUnicode(`test\\uD800\\u0C00passed`); s != `test\\uD800\\u0C00passed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\uD800\\uDC00passed`); s != `testpassed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\u0023passed`); s != `test\\u0023passed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\u0passed`); s != `test\\u0passed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\uD800passed`); s != `test\\uD800passed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\uD800`); s != `test\\uD800` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`test\\uD80`); s != `test\\uD80` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`\\\\uD800\\uDC00passed`); s != `\\\\uD800\\uDC00passed` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUnicode(`testpassed`); s != `testpassed` {\n\t\tt.Fatal(s)\n\t}\n}\n\nfunc TestConvertRegexpToUtf16(t *testing.T) {\n\tif s := convertRegexpToUtf16(``); s != `\\ud800\\udc00` {\n\t\tt.Fatal(s)\n\t}\n\tif s := convertRegexpToUtf16(`\\`); s != `\\\\\\ud800\\udc00` {\n\t\tt.Fatal(s)\n\t}\n}\n\nfunc TestEscapeInvalidUtf16(t *testing.T) {\n\tif s := escapeInvalidUtf16(asciiString(\"test\")); s != \"test\" {\n\t\tt.Fatal(s)\n\t}\n\tif s := escapeInvalidUtf16(newStringValue(\"test\\U00010000\")); s != \"test\\U00010000\" {\n\t\tt.Fatal(s)\n\t}\n\tif s := escapeInvalidUtf16(unicodeStringFromRunes([]rune{'t', 0xD800})); s != \"t\\\\ud800\" {\n\t\tt.Fatal(s)\n\t}\n\tif s := escapeInvalidUtf16(unicodeStringFromRunes([]rune{'t', 0xD800, 'p'})); s != \"t\\\\ud800p\" {\n\t\tt.Fatal(s)\n\t}\n\tif s := escapeInvalidUtf16(unicodeStringFromRunes([]rune{0xD800, 'p'})); s != \"\\\\ud800p\" {\n\t\tt.Fatal(s)\n\t}\n\tif s := escapeInvalidUtf16(unicodeStringFromRunes([]rune{'t', '\\\\', 0xD800, 'p'})); s != `t\\\\\\ud800p` {\n\t\tt.Fatal(s)\n\t}\n}\n\nfunc TestRegexpAssertion(t *testing.T) {\n\tconst SCRIPT = `\n\tvar res = 'aaa'.match(/^a/g);\n\tres.length === 1 || res[0] === 'a';\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpUnicodeAdvanceStringIndex(t *testing.T) {\n\tconst SCRIPT = `\n\t// deoptimise RegExp\n\tvar origExec = RegExp.prototype.exec;\n\tRegExp.prototype.exec = function(s) {\n\t\treturn origExec.call(this, s);\n\t};\n\n\tvar re = /(?:)/gu;\n\tvar str = \"a\\uD800\\uDC00b\";\n\tassert(compareArray(str.split(re), [\"a\", \"\", \"b\"]), \"#1\");\n\n\tre.lastIndex = 3;\n\tassert.sameValue(re.exec(str).index, 3, \"#2\");\n\n\tre.lastIndex = 2;\n\tassert.sameValue(re.exec(str).index, 1, \"#3\");\n\n\tre.lastIndex = 4;\n\tassert.sameValue(re.exec(str).index, 4, \"#4\");\n\n\tre.lastIndex = 5;\n\tassert.sameValue(re.exec(str), null, \"#5\");\n\n\tvar iterator = str.matchAll(re); // regexp is copied by matchAll, but resets lastIndex\n\tvar matches = [];\n\tfor (var v of iterator) {matches.push(v);}\n\tassert.sameValue(matches.length, 4, \"#6\");\n\tassert.sameValue(matches[0].index, 0, \"#7 index\");\n\tassert.sameValue(matches[0][0], \"\", \"#7 value\");\n\tassert.sameValue(matches[1].index, 1, \"#8 index\");\n\tassert.sameValue(matches[1][0], \"\", \"#8 value\");\n\tassert.sameValue(matches[2].index, 3, \"#9 index\");\n\tassert.sameValue(matches[2][0], \"\", \"#9 value\");\n\tassert.sameValue(matches[3].index, 4, \"#10 index\");\n\tassert.sameValue(matches[3][0], \"\", \"#10 value\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpInit(t *testing.T) {\n\tconst SCRIPT = `\n\tRegExp(\".\").lastIndex;\n\t`\n\ttestScript(SCRIPT, intToValue(0), t)\n}\n\nfunc TestRegexpToString(t *testing.T) {\n\tconst SCRIPT = `\n\tRegExp.prototype.toString.call({\n\tsource: 'foo',\n    flags: 'bar'});\n\t`\n\ttestScript(SCRIPT, asciiString(\"/foo/bar\"), t)\n}\n\nfunc TestRegexpEscapeSource(t *testing.T) {\n\tconst SCRIPT = `\n\t/href=\"(.+?)(\\/.*\\/\\S+?)\\/\"/.source;\n\t`\n\ttestScript(SCRIPT, asciiString(`href=\"(.+?)(\\/.*\\/\\S+?)\\/\"`), t)\n}\n\nfunc TestRegexpConsecutiveMatchCache(t *testing.T) {\n\tconst SCRIPT = `\n\t(function test(unicode) {\n\t\tvar regex = new RegExp('t(e)(st(\\\\d?))', unicode?'gu':'g');\n\t\tvar string = 'test1test2';\n\t\tvar match;\n\t\tvar matches = [];\n\t\twhile (match = regex.exec(string)) {\n\t\t\tmatches.push(match);\n\t\t}\n\t\tvar expectedMatches = [\n\t\t  [\n\t\t\t'test1',\n\t\t\t'e',\n\t\t\t'st1',\n\t\t\t'1'\n\t\t  ],\n\t\t  [\n\t\t\t'test2',\n\t\t\t'e',\n\t\t\t'st2',\n\t\t\t'2'\n\t\t  ]\n\t\t];\n\t\texpectedMatches[0].index = 0;\n\t\texpectedMatches[0].input = 'test1test2';\n\t\texpectedMatches[1].index = 5;\n\t\texpectedMatches[1].input = 'test1test2';\n\n\t\tassert(deepEqual(matches, expectedMatches), \"#1\");\n\n\t\t// try the same regexp with a different string\n\t\tregex.lastIndex = 0;\n\t\tmatch = regex.exec(' test5');\n\t\tvar expectedMatch = [\n\t\t  'test5',\n\t\t  'e',\n\t\t  'st5',\n\t\t  '5'\n\t\t];\n\t\texpectedMatch.index = 1;\n\t\texpectedMatch.input = ' test5';\n\t\tassert(deepEqual(match, expectedMatch), \"#2\");\n\t\tassert.sameValue(regex.lastIndex, 6, \"#3\");\n\n\t\t// continue matching with a different string\n\t\tmatch = regex.exec(' test5test6');\n\t\texpectedMatch = [\n\t\t  'test6',\n\t\t  'e',\n\t\t  'st6',\n\t\t  '6'\n\t\t];\n\t\texpectedMatch.index = 6;\n\t\texpectedMatch.input = ' test5test6';\n\t\tassert(deepEqual(match, expectedMatch), \"#4\");\n\t\tassert.sameValue(regex.lastIndex, 11, \"#5\");\n\n\t\tmatch = regex.exec(' test5test6');\n\t\tassert.sameValue(match, null, \"#6\");\n\t\treturn regex;\n\t});\n\t`\n\tvm := New()\n\t_, _ = vm.RunProgram(testLib())\n\t_, _ = vm.RunProgram(testLibX())\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar f func(bool) (*Object, error)\n\terr = vm.ExportTo(v, &f)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregex, err := f(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif regex.self.(*regexpObject).pattern.regexp2Wrapper.cache != nil {\n\t\tt.Fatal(\"Cache is not nil (non-unicode)\")\n\t}\n\n\tregex, err = f(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif regex.self.(*regexpObject).pattern.regexp2Wrapper.cache != nil {\n\t\tt.Fatal(\"Cache is not nil (unicode)\")\n\t}\n}\n\nfunc TestRegexpMatchAll(t *testing.T) {\n\tconst SCRIPT = `\n\t(function test(unicode) {\n\t\tvar regex = new RegExp('t(e)(st(\\\\d?))', unicode?'gu':'g');\n\t\tvar string = 'test1test2';\n\t\tvar matches = [];\n\t\tfor (var match of string.matchAll(regex)) {\n\t\t\tmatches.push(match);\n\t\t}\n\t\tvar expectedMatches = [\n\t\t  [\n\t\t\t'test1',\n\t\t\t'e',\n\t\t\t'st1',\n\t\t\t'1'\n\t\t  ],\n\t\t  [\n\t\t\t'test2',\n\t\t\t'e',\n\t\t\t'st2',\n\t\t\t'2'\n\t\t  ]\n\t\t];\n\t\texpectedMatches[0].index = 0;\n\t\texpectedMatches[0].input = 'test1test2';\n\t\texpectedMatches[1].index = 5;\n\t\texpectedMatches[1].input = 'test1test2';\n\n\t\tassert(deepEqual(matches, expectedMatches), \"#1\");\n\t\tassert.sameValue(regex.lastIndex, 0, \"#1 lastIndex\");\n\n\t\t// try the same regexp with a different string\n\t\tstring = ' test5';\n\t\tmatches = [];\n\t\tfor (var match of string.matchAll(regex)) {\n\t\t\tmatches.push(match);\n\t\t}\n\t\texpectedMatches = [\n\t\t\t[\n\t\t\t  'test5',\n\t\t\t  'e',\n\t\t\t  'st5',\n\t\t\t  '5'\n\t\t\t]\n\t\t];\n\t\texpectedMatches[0].index = 1;\n\t\texpectedMatches[0].input = ' test5';\n\t\tassert(deepEqual(matches, expectedMatches), \"#2\");\n\t\tassert.sameValue(regex.lastIndex, 0, \"#2 lastIndex\");\n\n\t\t// continue matching with a different string\n\t\tstring = ' test5test6';\n\t\tmatches = [];\n\t\tfor (var match of string.matchAll(regex)) {\n\t\t\tmatches.push(match);\n\t\t}\n\t\tvar expectedMatches = [\n\t\t  [\n\t\t\t'test5',\n\t\t\t'e',\n\t\t\t'st5',\n\t\t\t'5'\n\t\t  ],\n\t\t  [\n\t\t\t'test6',\n\t\t\t'e',\n\t\t\t'st6',\n\t\t\t'6'\n\t\t  ]\n\t\t];\n\t\texpectedMatches[0].index = 1;\n\t\texpectedMatches[0].input = ' test5test6';\n\t\texpectedMatches[1].index = 6;\n\t\texpectedMatches[1].input = ' test5test6';\n\t\tassert(deepEqual(matches, expectedMatches), \"#3\");\n\t\tassert.sameValue(regex.lastIndex, 0, \"#3 lastindex\");\n\t});\n\t`\n\tvm := New()\n\t_, _ = vm.RunProgram(testLib())\n\t_, _ = vm.RunProgram(testLibX())\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar f func(bool) (*Object, error)\n\terr = vm.ExportTo(v, &f)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = f(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = f(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRegexpOverrideSpecies(t *testing.T) {\n\tconst SCRIPT = `\n\tObject.defineProperty(RegExp, Symbol.species, {\n\t\tconfigurable: true,\n\t\tvalue: function() {\n\t\t\tthrow \"passed\";\n\t\t}\n\t});\n\ttry {\n\t\t\"ab\".split(/a/);\n\t\tthrow new Error(\"Expected error\");\n\t} catch(e) {\n\t\tif (e !== \"passed\") {\n\t\t\tthrow e;\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpSymbolMatchAllCallsIsRegexp(t *testing.T) {\n\t// This is tc39's test/built-ins/RegExp/prototype/Symbol.matchAll/isregexp-this-throws.js\n\tconst SCRIPT = `\n\tvar a = new Object();\n\tObject.defineProperty(a, Symbol.match, {\n\t\tget: function() {\n\t\t\tthrow \"passed\";\n\t\t}\n\t});\n\ttry {\n\t\tRegExp.prototype[Symbol.matchAll].call(a, '');\n\t\tthrow new Error(\"Expected error\");\n\t} catch(e) {\n\t\tif (e !== \"passed\") {\n\t\t\tthrow e;\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpMatchAllConstructor(t *testing.T) {\n\t// This is tc39's test/built-ins/RegExp/prototype/Symbol.matchAll/species-constuctor.js\n\tconst SCRIPT = `\n\tvar callCount = 0;\n\tvar callArgs;\n\tvar regexp = /\\d/u;\n\tvar obj = {}\n\tObject.defineProperty(obj, Symbol.species, {\n\t\tvalue: function() {\n\t\t  callCount++;\n\t\t  callArgs = arguments;\n\t\t  return /\\w/g;\n\t\t}\n\t});\n\tregexp.constructor = obj;\n\tvar str = 'a*b';\n\tvar iter = regexp[Symbol.matchAll](str);\n\n\tassert.sameValue(callCount, 1);\n\tassert.sameValue(callArgs.length, 2);\n\tassert.sameValue(callArgs[0], regexp);\n\tassert.sameValue(callArgs[1], 'u');\n\n\tvar first = iter.next()\n\tassert.sameValue(first.done, false);\n\tassert.sameValue(first.value.length, 1);\n\tassert.sameValue(first.value[0], \"a\");\n\tvar second = iter.next()\n\tassert.sameValue(second.done, true);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexp2InvalidEscape(t *testing.T) {\n\ttestScript(`/(?=)\\x0/.test(\"x0\")`, valueTrue, t)\n}\n\nfunc TestRegexpUnicodeEmptyMatch(t *testing.T) {\n\ttestScript(`/(0)0|/gu.exec(\"0\\xef\").length === 2`, valueTrue, t)\n}\n\nfunc TestRegexpInvalidGroup(t *testing.T) {\n\tconst SCRIPT = `\n\t[\"?\", \"(?)\"].forEach(function(s) {\n\t\tassert.throws(SyntaxError, function() {new RegExp(s)}, s);\n\t});\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpLookbehindAssertion(t *testing.T) {\n\tconst SCRIPT = `\n\tvar re = /(?<=Jack|Tom)Sprat/;\n\tassert(re.test(\"JackSprat\"), \"#1\");\n\tassert(!re.test(\"JohnSprat\"), \"#2\");\n\n\tre = /(?<!-)\\d+/;\n\tassert(re.test(\"3\"), \"#3\");\n\tassert(!re.test(\"-3\"), \"#4\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpInvalidUTF8(t *testing.T) {\n\tvm := New()\n\t// Note that normally vm.ToValue() would replace invalid UTF-8 sequences with RuneError\n\t_, err := vm.New(vm.Get(\"RegExp\"), asciiString([]byte{0xAD}))\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\n// this should not cause data races when run with -race\nfunc TestRegexpConcurrentLiterals(t *testing.T) {\n\tprg := MustCompile(\"test.js\", `var r = /(?<!-)\\d+/; r.test(\"\");`, false)\n\tgo func() {\n\t\tvm := New()\n\t\t_, err := vm.RunProgram(prg)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\tvm := New()\n\t_, _ = vm.RunProgram(prg)\n}\n\nfunc TestRegexpDotAll(t *testing.T) {\n\tconst SCRIPT = `\n\tvar re = /./s;\n\tre.test(\"\\r\") && re.test(\"\\n\")\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpDotAllInGroup(t *testing.T) {\n\tconst SCRIPT = `\n\tvar re = /(.)/s;\n\tre.test(\"\\r\") && re.test(\"\\n\")\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestRegexpNumSeparators(t *testing.T) {\n\tconst SCRIPT = `\n\tconst re = /(?<=a)\\u{65}_/u;\n\tassert(re.test(\"ae_\") && !re.test(\"e_\"));\n\n\tassert.throws(SyntaxError, () => {\n\t\tnew RegExp(\"(?<=a)\\\\u{6_5}\", \"u\");\n\t});\n\n\tassert.throws(SyntaxError, () => {\n\t\tnew RegExp(\"a\\\\u{6_5}\", \"u\");\n\t});\n\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestRegexpUnicodeEscape(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(\"u{0_2}\".match(/\\u{0_2}/)[0], \"u{0_2}\");\n\tassert.sameValue(\"uu\\x02\".match(/\\u{2}/u)[0], '\\x02');\n\tassert.sameValue(\"uu\\x02\".match(/\\u{2}/)[0], \"uu\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc BenchmarkRegexpSplitWithBackRef(b *testing.B) {\n\tconst SCRIPT = `\n\t\"aaaaaaaaaaaaaaaaaaaaaaaaa++bbbbbbbbbbbbbbbbbbbbbb+-ccccccccccccccccccccccc\".split(/([+-])\\1/)\n\t`\n\tb.StopTimer()\n\tprg, err := Compile(\"test.js\", SCRIPT, false)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tvm := New()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkRegexpMatch(b *testing.B) {\n\tconst SCRIPT = `\n        \"a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n        \".match(/[^\\r\\n]+/g)\n        `\n\tb.StopTimer()\n\tprg, err := Compile(\"test.js\", SCRIPT, false)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tvm := New()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkRegexpMatchCache(b *testing.B) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tvar s = \"a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n        \"\n\t\tvar r = /[^\\r\\n]+/g\n\t\twhile(r.exec(s)) {};\n\t});\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tif fn, ok := AssertFunction(v); ok {\n\t\tb.ResetTimer()\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfn(_undefined)\n\t\t}\n\t} else {\n\t\tb.Fatal(\"not a function\")\n\t}\n}\n\nfunc BenchmarkRegexpMatchAll(b *testing.B) {\n\tconst SCRIPT = `\n\t(function() {\n\t\tvar s = \"a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n         a\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\ra\\nb\\r\\c\\nd\\r\\e\\n\\f\\rg\\nh\\r\\\n        \"\n\t\tvar r = /[^\\r\\n]+/g\n\t\tfor (var v of s.matchAll(r)) {}\n\t});\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tif fn, ok := AssertFunction(v); ok {\n\t\tb.ResetTimer()\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfn(_undefined)\n\t\t}\n\t} else {\n\t\tb.Fatal(\"not a function\")\n\t}\n}\n\nfunc BenchmarkRegexpSingleExec(b *testing.B) {\n\tvm := New()\n\tregexp := vm.Get(\"RegExp\")\n\tf := func(reStr, str string, b *testing.B) {\n\t\tr, err := vm.New(regexp, vm.ToValue(reStr))\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\texec, ok := AssertFunction(r.Get(\"exec\"))\n\t\tif !ok {\n\t\t\tb.Fatal(\"RegExp.exec is not a function\")\n\t\t}\n\t\targ := vm.ToValue(str)\n\t\tb.ResetTimer()\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_, err := exec(r, arg)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tb.Run(\"Re-ASCII\", func(b *testing.B) {\n\t\tf(\"test\", \"aaaaaaaaaaaaaaaaaaaaaaaaa testing\", b)\n\t})\n\n\tb.Run(\"Re2-ASCII\", func(b *testing.B) {\n\t\tf(\"(?=)test\", \"aaaaaaaaaaaaaaaaaaaaaaaaa testing\", b)\n\t})\n\n\tb.Run(\"Re-Unicode\", func(b *testing.B) {\n\t\tf(\"test\", \"aaaaaaaaaaaaaaaaaaaaaaaaa testing \", b)\n\t})\n\n\tb.Run(\"Re2-Unicode\", func(b *testing.B) {\n\t\tf(\"(?=)test\", \"aaaaaaaaaaaaaaaaaaaaaaaaa testing \", b)\n\t})\n\n}\n"
        },
        {
          "name": "runtime.go",
          "type": "blob",
          "size": 79.2392578125,
          "content": "package goja\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"hash/maphash\"\n\t\"math\"\n\t\"math/big\"\n\t\"math/bits\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"golang.org/x/text/collate\"\n\n\tjs_ast \"github.com/dop251/goja/ast\"\n\t\"github.com/dop251/goja/file\"\n\t\"github.com/dop251/goja/parser\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst (\n\tsqrt1_2 float64 = math.Sqrt2 / 2\n\n\tdeoptimiseRegexp = false\n)\n\nvar (\n\ttypeCallable = reflect.TypeOf(Callable(nil))\n\ttypeValue    = reflect.TypeOf((*Value)(nil)).Elem()\n\ttypeObject   = reflect.TypeOf((*Object)(nil))\n\ttypeTime     = reflect.TypeOf(time.Time{})\n\ttypeBigInt   = reflect.TypeOf((*big.Int)(nil))\n\ttypeBytes    = reflect.TypeOf(([]byte)(nil))\n)\n\ntype iterationKind int\n\nconst (\n\titerationKindKey iterationKind = iota\n\titerationKindValue\n\titerationKindKeyValue\n)\n\ntype global struct {\n\tstash stash\n\n\tObject   *Object\n\tArray    *Object\n\tFunction *Object\n\tString   *Object\n\tNumber   *Object\n\tBigInt   *Object\n\tBoolean  *Object\n\tRegExp   *Object\n\tDate     *Object\n\tSymbol   *Object\n\tProxy    *Object\n\tReflect  *Object\n\tPromise  *Object\n\tMath     *Object\n\tJSON     *Object\n\n\tAsyncFunction *Object\n\n\tArrayBuffer       *Object\n\tDataView          *Object\n\tTypedArray        *Object\n\tUint8Array        *Object\n\tUint8ClampedArray *Object\n\tInt8Array         *Object\n\tUint16Array       *Object\n\tInt16Array        *Object\n\tUint32Array       *Object\n\tInt32Array        *Object\n\tFloat32Array      *Object\n\tFloat64Array      *Object\n\tBigInt64Array     *Object\n\tBigUint64Array    *Object\n\n\tWeakSet *Object\n\tWeakMap *Object\n\tMap     *Object\n\tSet     *Object\n\n\tError          *Object\n\tAggregateError *Object\n\tTypeError      *Object\n\tReferenceError *Object\n\tSyntaxError    *Object\n\tRangeError     *Object\n\tEvalError      *Object\n\tURIError       *Object\n\n\tGoError *Object\n\n\tObjectPrototype   *Object\n\tArrayPrototype    *Object\n\tNumberPrototype   *Object\n\tBigIntPrototype   *Object\n\tStringPrototype   *Object\n\tBooleanPrototype  *Object\n\tFunctionPrototype *Object\n\tRegExpPrototype   *Object\n\tDatePrototype     *Object\n\tSymbolPrototype   *Object\n\n\tArrayBufferPrototype *Object\n\tDataViewPrototype    *Object\n\tTypedArrayPrototype  *Object\n\tWeakSetPrototype     *Object\n\tWeakMapPrototype     *Object\n\tMapPrototype         *Object\n\tSetPrototype         *Object\n\tPromisePrototype     *Object\n\n\tGeneratorFunctionPrototype *Object\n\tGeneratorFunction          *Object\n\tGeneratorPrototype         *Object\n\n\tAsyncFunctionPrototype *Object\n\n\tIteratorPrototype             *Object\n\tArrayIteratorPrototype        *Object\n\tMapIteratorPrototype          *Object\n\tSetIteratorPrototype          *Object\n\tStringIteratorPrototype       *Object\n\tRegExpStringIteratorPrototype *Object\n\n\tErrorPrototype *Object\n\n\tEval *Object\n\n\tthrower *Object\n\n\tstdRegexpProto *guardedObject\n\n\tweakSetAdder  *Object\n\tweakMapAdder  *Object\n\tmapAdder      *Object\n\tsetAdder      *Object\n\tarrayValues   *Object\n\tarrayToString *Object\n\n\tstringproto_trimEnd   *Object\n\tstringproto_trimStart *Object\n\n\tparseFloat, parseInt *Object\n\n\ttypedArrayValues *Object\n}\n\ntype Flag int\n\nconst (\n\tFLAG_NOT_SET Flag = iota\n\tFLAG_FALSE\n\tFLAG_TRUE\n)\n\nfunc (f Flag) Bool() bool {\n\treturn f == FLAG_TRUE\n}\n\nfunc ToFlag(b bool) Flag {\n\tif b {\n\t\treturn FLAG_TRUE\n\t}\n\treturn FLAG_FALSE\n}\n\ntype RandSource func() float64\n\ntype Now func() time.Time\n\ntype Runtime struct {\n\tglobal          global\n\tglobalObject    *Object\n\tstringSingleton *stringObject\n\trand            RandSource\n\tnow             Now\n\t_collator       *collate.Collator\n\tparserOptions   []parser.Option\n\n\tsymbolRegistry map[unistring.String]*Symbol\n\n\tfieldsInfoCache  map[reflect.Type]*reflectFieldsInfo\n\tmethodsInfoCache map[reflect.Type]*reflectMethodsInfo\n\n\tfieldNameMapper FieldNameMapper\n\n\tvm    *vm\n\thash  *maphash.Hash\n\tidSeq uint64\n\n\tjobQueue []func()\n\n\tpromiseRejectionTracker PromiseRejectionTracker\n\tasyncContextTracker     AsyncContextTracker\n}\n\ntype StackFrame struct {\n\tprg      *Program\n\tfuncName unistring.String\n\tpc       int\n}\n\nfunc (f *StackFrame) SrcName() string {\n\tif f.prg == nil {\n\t\treturn \"<native>\"\n\t}\n\treturn f.prg.src.Name()\n}\n\nfunc (f *StackFrame) FuncName() string {\n\tif f.funcName == \"\" && f.prg == nil {\n\t\treturn \"<native>\"\n\t}\n\tif f.funcName == \"\" {\n\t\treturn \"<anonymous>\"\n\t}\n\treturn f.funcName.String()\n}\n\nfunc (f *StackFrame) Position() file.Position {\n\tif f.prg == nil || f.prg.src == nil {\n\t\treturn file.Position{}\n\t}\n\treturn f.prg.src.Position(f.prg.sourceOffset(f.pc))\n}\n\nfunc (f *StackFrame) WriteToValueBuilder(b *StringBuilder) {\n\tif f.prg != nil {\n\t\tif n := f.prg.funcName; n != \"\" {\n\t\t\tb.WriteString(stringValueFromRaw(n))\n\t\t\tb.writeASCII(\" (\")\n\t\t}\n\t\tp := f.Position()\n\t\tif p.Filename != \"\" {\n\t\t\tb.WriteUTF8String(p.Filename)\n\t\t} else {\n\t\t\tb.writeASCII(\"<eval>\")\n\t\t}\n\t\tb.WriteRune(':')\n\t\tb.writeASCII(strconv.Itoa(p.Line))\n\t\tb.WriteRune(':')\n\t\tb.writeASCII(strconv.Itoa(p.Column))\n\t\tb.WriteRune('(')\n\t\tb.writeASCII(strconv.Itoa(f.pc))\n\t\tb.WriteRune(')')\n\t\tif f.prg.funcName != \"\" {\n\t\t\tb.WriteRune(')')\n\t\t}\n\t} else {\n\t\tif f.funcName != \"\" {\n\t\t\tb.WriteString(stringValueFromRaw(f.funcName))\n\t\t\tb.writeASCII(\" (\")\n\t\t}\n\t\tb.writeASCII(\"native\")\n\t\tif f.funcName != \"\" {\n\t\t\tb.WriteRune(')')\n\t\t}\n\t}\n}\n\nfunc (f *StackFrame) Write(b *bytes.Buffer) {\n\tif f.prg != nil {\n\t\tif n := f.prg.funcName; n != \"\" {\n\t\t\tb.WriteString(n.String())\n\t\t\tb.WriteString(\" (\")\n\t\t}\n\t\tp := f.Position()\n\t\tif p.Filename != \"\" {\n\t\t\tb.WriteString(p.Filename)\n\t\t} else {\n\t\t\tb.WriteString(\"<eval>\")\n\t\t}\n\t\tb.WriteByte(':')\n\t\tb.WriteString(strconv.Itoa(p.Line))\n\t\tb.WriteByte(':')\n\t\tb.WriteString(strconv.Itoa(p.Column))\n\t\tb.WriteByte('(')\n\t\tb.WriteString(strconv.Itoa(f.pc))\n\t\tb.WriteByte(')')\n\t\tif f.prg.funcName != \"\" {\n\t\t\tb.WriteByte(')')\n\t\t}\n\t} else {\n\t\tif f.funcName != \"\" {\n\t\t\tb.WriteString(f.funcName.String())\n\t\t\tb.WriteString(\" (\")\n\t\t}\n\t\tb.WriteString(\"native\")\n\t\tif f.funcName != \"\" {\n\t\t\tb.WriteByte(')')\n\t\t}\n\t}\n}\n\n// An un-catchable exception is not catchable by try/catch statements (finally is not executed either),\n// but it is returned as an error to a Go caller rather than causing a panic.\ntype uncatchableException interface {\n\terror\n\t_uncatchableException()\n}\n\ntype Exception struct {\n\tval   Value\n\tstack []StackFrame\n}\n\ntype baseUncatchableException struct {\n\tException\n}\n\nfunc (e *baseUncatchableException) _uncatchableException() {}\n\ntype InterruptedError struct {\n\tbaseUncatchableException\n\tiface interface{}\n}\n\nfunc (e *InterruptedError) Unwrap() error {\n\tif err, ok := e.iface.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype StackOverflowError struct {\n\tbaseUncatchableException\n}\n\nfunc (e *InterruptedError) Value() interface{} {\n\treturn e.iface\n}\n\nfunc (e *InterruptedError) String() string {\n\tif e == nil {\n\t\treturn \"<nil>\"\n\t}\n\tvar b bytes.Buffer\n\tif e.iface != nil {\n\t\tb.WriteString(fmt.Sprint(e.iface))\n\t\tb.WriteByte('\\n')\n\t}\n\te.writeFullStack(&b)\n\treturn b.String()\n}\n\nfunc (e *InterruptedError) Error() string {\n\tif e == nil || e.iface == nil {\n\t\treturn \"<nil>\"\n\t}\n\tvar b bytes.Buffer\n\tb.WriteString(fmt.Sprint(e.iface))\n\te.writeShortStack(&b)\n\treturn b.String()\n}\n\nfunc (e *Exception) writeFullStack(b *bytes.Buffer) {\n\tfor _, frame := range e.stack {\n\t\tb.WriteString(\"\\tat \")\n\t\tframe.Write(b)\n\t\tb.WriteByte('\\n')\n\t}\n}\n\nfunc (e *Exception) writeShortStack(b *bytes.Buffer) {\n\tif len(e.stack) > 0 && (e.stack[0].prg != nil || e.stack[0].funcName != \"\") {\n\t\tb.WriteString(\" at \")\n\t\te.stack[0].Write(b)\n\t}\n}\n\nfunc (e *Exception) String() string {\n\tif e == nil {\n\t\treturn \"<nil>\"\n\t}\n\tvar b bytes.Buffer\n\tif e.val != nil {\n\t\tb.WriteString(e.val.String())\n\t\tb.WriteByte('\\n')\n\t}\n\te.writeFullStack(&b)\n\treturn b.String()\n}\n\nfunc (e *Exception) Error() string {\n\tif e == nil {\n\t\treturn \"<nil>\"\n\t}\n\tvar b bytes.Buffer\n\tif e.val != nil {\n\t\tb.WriteString(e.val.String())\n\t}\n\te.writeShortStack(&b)\n\treturn b.String()\n}\n\nfunc (e *Exception) Value() Value {\n\treturn e.val\n}\n\nfunc (e *Exception) Unwrap() error {\n\tif obj, ok := e.val.(*Object); ok {\n\t\tif obj.runtime.getGoError().self.hasInstance(obj) {\n\t\t\tif val := obj.Get(\"value\"); val != nil {\n\t\t\t\te1, _ := val.Export().(error)\n\t\t\t\treturn e1\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Exception) Stack() []StackFrame {\n\treturn e.stack\n}\n\nfunc (r *Runtime) createIterProto(val *Object) objectImpl {\n\to := newBaseObjectObj(val, r.global.ObjectPrototype, classObject)\n\n\to._putSym(SymIterator, valueProp(r.newNativeFunc(r.returnThis, \"[Symbol.iterator]\", 0), true, false, true))\n\treturn o\n}\n\nfunc (r *Runtime) getIteratorPrototype() *Object {\n\tvar o *Object\n\tif o = r.global.IteratorPrototype; o == nil {\n\t\to = &Object{runtime: r}\n\t\tr.global.IteratorPrototype = o\n\t\to.self = r.createIterProto(o)\n\t}\n\treturn o\n}\n\nfunc (r *Runtime) init() {\n\tr.rand = rand.Float64\n\tr.now = time.Now\n\n\tr.global.ObjectPrototype = &Object{runtime: r}\n\tr.newTemplatedObject(getObjectProtoTemplate(), r.global.ObjectPrototype)\n\n\tr.globalObject = &Object{runtime: r}\n\tr.newTemplatedObject(getGlobalObjectTemplate(), r.globalObject)\n\n\tr.vm = &vm{\n\t\tr: r,\n\t}\n\tr.vm.init()\n}\n\nfunc (r *Runtime) typeErrorResult(throw bool, args ...interface{}) {\n\tif throw {\n\t\tpanic(r.NewTypeError(args...))\n\t}\n}\n\nfunc (r *Runtime) newError(typ *Object, format string, args ...interface{}) Value {\n\tvar msg string\n\tif len(args) > 0 {\n\t\tmsg = fmt.Sprintf(format, args...)\n\t} else {\n\t\tmsg = format\n\t}\n\treturn r.builtin_new(typ, []Value{newStringValue(msg)})\n}\n\nfunc (r *Runtime) throwReferenceError(name unistring.String) {\n\tpanic(r.newReferenceError(name))\n}\n\nfunc (r *Runtime) newReferenceError(name unistring.String) Value {\n\treturn r.newError(r.getReferenceError(), \"%s is not defined\", name)\n}\n\nfunc (r *Runtime) newSyntaxError(msg string, offset int) Value {\n\treturn r.builtin_new(r.getSyntaxError(), []Value{newStringValue(msg)})\n}\n\nfunc newBaseObjectObj(obj, proto *Object, class string) *baseObject {\n\to := &baseObject{\n\t\tclass:      class,\n\t\tval:        obj,\n\t\textensible: true,\n\t\tprototype:  proto,\n\t}\n\tobj.self = o\n\to.init()\n\treturn o\n}\n\nfunc newGuardedObj(proto *Object, class string) *guardedObject {\n\treturn &guardedObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      class,\n\t\t\textensible: true,\n\t\t\tprototype:  proto,\n\t\t},\n\t}\n}\n\nfunc (r *Runtime) newBaseObject(proto *Object, class string) (o *baseObject) {\n\tv := &Object{runtime: r}\n\treturn newBaseObjectObj(v, proto, class)\n}\n\nfunc (r *Runtime) newGuardedObject(proto *Object, class string) (o *guardedObject) {\n\tv := &Object{runtime: r}\n\to = newGuardedObj(proto, class)\n\tv.self = o\n\to.val = v\n\to.init()\n\treturn\n}\n\nfunc (r *Runtime) NewObject() (v *Object) {\n\treturn r.newBaseObject(r.global.ObjectPrototype, classObject).val\n}\n\n// CreateObject creates an object with given prototype. Equivalent of Object.create(proto).\nfunc (r *Runtime) CreateObject(proto *Object) *Object {\n\treturn r.newBaseObject(proto, classObject).val\n}\n\nfunc (r *Runtime) NewArray(items ...interface{}) *Object {\n\tvalues := make([]Value, len(items))\n\tfor i, item := range items {\n\t\tvalues[i] = r.ToValue(item)\n\t}\n\treturn r.newArrayValues(values)\n}\n\nfunc (r *Runtime) NewTypeError(args ...interface{}) *Object {\n\tmsg := \"\"\n\tif len(args) > 0 {\n\t\tf, _ := args[0].(string)\n\t\tmsg = fmt.Sprintf(f, args[1:]...)\n\t}\n\treturn r.builtin_new(r.getTypeError(), []Value{newStringValue(msg)})\n}\n\nfunc (r *Runtime) NewGoError(err error) *Object {\n\te := r.newError(r.getGoError(), err.Error()).(*Object)\n\te.Set(\"value\", err)\n\treturn e\n}\n\nfunc (r *Runtime) newFunc(name unistring.String, length int, strict bool) (f *funcObject) {\n\tf = &funcObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) newAsyncFunc(name unistring.String, length int, strict bool) (f *asyncFuncObject) {\n\tf = &asyncFuncObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.class = classFunction\n\tf.prototype = r.getAsyncFunctionPrototype()\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) newGeneratorFunc(name unistring.String, length int, strict bool) (f *generatorFuncObject) {\n\tf = &generatorFuncObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.class = classFunction\n\tf.prototype = r.getGeneratorFunctionPrototype()\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\tf._putProp(\"prototype\", r.newBaseObject(r.getGeneratorPrototype(), classObject).val, true, false, false)\n\treturn\n}\n\nfunc (r *Runtime) newClassFunc(name unistring.String, length int, proto *Object, derived bool) (f *classFuncObject) {\n\tv := &Object{runtime: r}\n\n\tf = &classFuncObject{}\n\tf.class = classFunction\n\tf.val = v\n\tf.extensible = true\n\tf.strict = true\n\tf.derived = derived\n\tv.self = f\n\tf.prototype = proto\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) initBaseJsFunction(f *baseJsFuncObject, strict bool) {\n\tv := &Object{runtime: r}\n\n\tf.class = classFunction\n\tf.val = v\n\tf.extensible = true\n\tf.strict = strict\n\tf.prototype = r.getFunctionPrototype()\n}\n\nfunc (r *Runtime) newMethod(name unistring.String, length int, strict bool) (f *methodFuncObject) {\n\tf = &methodFuncObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) newGeneratorMethod(name unistring.String, length int, strict bool) (f *generatorMethodFuncObject) {\n\tf = &generatorMethodFuncObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.prototype = r.getGeneratorFunctionPrototype()\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\tf._putProp(\"prototype\", r.newBaseObject(r.getGeneratorPrototype(), classObject).val, true, false, false)\n\treturn\n}\n\nfunc (r *Runtime) newAsyncMethod(name unistring.String, length int, strict bool) (f *asyncMethodFuncObject) {\n\tf = &asyncMethodFuncObject{}\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) initArrowFunc(f *arrowFuncObject, strict bool) {\n\tr.initBaseJsFunction(&f.baseJsFuncObject, strict)\n\tf.newTarget = r.vm.newTarget\n}\n\nfunc (r *Runtime) newArrowFunc(name unistring.String, length int, strict bool) (f *arrowFuncObject) {\n\tf = &arrowFuncObject{}\n\tr.initArrowFunc(f, strict)\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) newAsyncArrowFunc(name unistring.String, length int, strict bool) (f *asyncArrowFuncObject) {\n\tf = &asyncArrowFuncObject{}\n\tr.initArrowFunc(&f.arrowFuncObject, strict)\n\tf.class = classObject\n\tf.prototype = r.getAsyncFunctionPrototype()\n\tf.val.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn\n}\n\nfunc (r *Runtime) newNativeConstructor(call func(ConstructorCall) *Object, name unistring.String, length int64) *Object {\n\tv := &Object{runtime: r}\n\n\tf := &nativeFuncObject{\n\t\tbaseFuncObject: baseFuncObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classFunction,\n\t\t\t\tval:        v,\n\t\t\t\textensible: true,\n\t\t\t\tprototype:  r.getFunctionPrototype(),\n\t\t\t},\n\t\t},\n\t}\n\n\tf.f = func(c FunctionCall) Value {\n\t\tthisObj, _ := c.This.(*Object)\n\t\tif thisObj != nil {\n\t\t\tres := call(ConstructorCall{\n\t\t\t\tThis:      thisObj,\n\t\t\t\tArguments: c.Arguments,\n\t\t\t})\n\t\t\tif res == nil {\n\t\t\t\treturn _undefined\n\t\t\t}\n\t\t\treturn res\n\t\t}\n\t\treturn f.defaultConstruct(call, c.Arguments, nil)\n\t}\n\n\tf.construct = func(args []Value, newTarget *Object) *Object {\n\t\treturn f.defaultConstruct(call, args, newTarget)\n\t}\n\n\tv.self = f\n\tf.init(name, intToValue(length))\n\n\tproto := r.NewObject()\n\tproto.self._putProp(\"constructor\", v, true, false, true)\n\tf._putProp(\"prototype\", proto, true, false, false)\n\n\treturn v\n}\n\nfunc (r *Runtime) newNativeConstructOnly(v *Object, ctor func(args []Value, newTarget *Object) *Object, defaultProto *Object, name unistring.String, length int64) *nativeFuncObject {\n\treturn r.newNativeFuncAndConstruct(v, func(call FunctionCall) Value {\n\t\treturn ctor(call.Arguments, nil)\n\t},\n\t\tfunc(args []Value, newTarget *Object) *Object {\n\t\t\tif newTarget == nil {\n\t\t\t\tnewTarget = v\n\t\t\t}\n\t\t\treturn ctor(args, newTarget)\n\t\t}, defaultProto, name, intToValue(length))\n}\n\nfunc (r *Runtime) newNativeFuncAndConstruct(v *Object, call func(call FunctionCall) Value, ctor func(args []Value, newTarget *Object) *Object, defaultProto *Object, name unistring.String, l Value) *nativeFuncObject {\n\tif v == nil {\n\t\tv = &Object{runtime: r}\n\t}\n\n\tf := &nativeFuncObject{\n\t\tbaseFuncObject: baseFuncObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classFunction,\n\t\t\t\tval:        v,\n\t\t\t\textensible: true,\n\t\t\t\tprototype:  r.getFunctionPrototype(),\n\t\t\t},\n\t\t},\n\t\tf:         call,\n\t\tconstruct: ctor,\n\t}\n\tv.self = f\n\tf.init(name, l)\n\tif defaultProto != nil {\n\t\tf._putProp(\"prototype\", defaultProto, false, false, false)\n\t}\n\n\treturn f\n}\n\nfunc (r *Runtime) newNativeFunc(call func(FunctionCall) Value, name unistring.String, length int) *Object {\n\tv := &Object{runtime: r}\n\n\tf := &nativeFuncObject{\n\t\tbaseFuncObject: baseFuncObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classFunction,\n\t\t\t\tval:        v,\n\t\t\t\textensible: true,\n\t\t\t\tprototype:  r.getFunctionPrototype(),\n\t\t\t},\n\t\t},\n\t\tf: call,\n\t}\n\tv.self = f\n\tf.init(name, intToValue(int64(length)))\n\treturn v\n}\n\nfunc (r *Runtime) newWrappedFunc(value reflect.Value) *Object {\n\n\tv := &Object{runtime: r}\n\n\tf := &wrappedFuncObject{\n\t\tnativeFuncObject: nativeFuncObject{\n\t\t\tbaseFuncObject: baseFuncObject{\n\t\t\t\tbaseObject: baseObject{\n\t\t\t\t\tclass:      classFunction,\n\t\t\t\t\tval:        v,\n\t\t\t\t\textensible: true,\n\t\t\t\t\tprototype:  r.getFunctionPrototype(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tf: r.wrapReflectFunc(value),\n\t\t},\n\t\twrapped: value,\n\t}\n\tv.self = f\n\tname := unistring.NewFromString(runtime.FuncForPC(value.Pointer()).Name())\n\tf.init(name, intToValue(int64(value.Type().NumIn())))\n\treturn v\n}\n\nfunc (r *Runtime) newNativeFuncConstructObj(v *Object, construct func(args []Value, proto *Object) *Object, name unistring.String, proto *Object, length int) *nativeFuncObject {\n\tf := &nativeFuncObject{\n\t\tbaseFuncObject: baseFuncObject{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tclass:      classFunction,\n\t\t\t\tval:        v,\n\t\t\t\textensible: true,\n\t\t\t\tprototype:  r.getFunctionPrototype(),\n\t\t\t},\n\t\t},\n\t\tf:         r.constructToCall(construct, proto),\n\t\tconstruct: r.wrapNativeConstruct(construct, v, proto),\n\t}\n\n\tf.init(name, intToValue(int64(length)))\n\tif proto != nil {\n\t\tf._putProp(\"prototype\", proto, false, false, false)\n\t}\n\treturn f\n}\n\nfunc (r *Runtime) newNativeFuncConstruct(v *Object, construct func(args []Value, proto *Object) *Object, name unistring.String, prototype *Object, length int64) *Object {\n\treturn r.newNativeFuncConstructProto(v, construct, name, prototype, r.getFunctionPrototype(), length)\n}\n\nfunc (r *Runtime) newNativeFuncConstructProto(v *Object, construct func(args []Value, proto *Object) *Object, name unistring.String, prototype, proto *Object, length int64) *Object {\n\tf := &nativeFuncObject{}\n\tf.class = classFunction\n\tf.val = v\n\tf.extensible = true\n\tv.self = f\n\tf.prototype = proto\n\tf.f = r.constructToCall(construct, prototype)\n\tf.construct = r.wrapNativeConstruct(construct, v, prototype)\n\tf.init(name, intToValue(length))\n\tif prototype != nil {\n\t\tf._putProp(\"prototype\", prototype, false, false, false)\n\t}\n\treturn v\n}\n\nfunc (r *Runtime) newPrimitiveObject(value Value, proto *Object, class string) *Object {\n\tv := &Object{runtime: r}\n\n\to := &primitiveValueObject{}\n\to.class = class\n\to.val = v\n\to.extensible = true\n\tv.self = o\n\to.prototype = proto\n\to.pValue = value\n\to.init()\n\treturn v\n}\n\nfunc (r *Runtime) builtin_Number(call FunctionCall) Value {\n\tif len(call.Arguments) > 0 {\n\t\tswitch t := call.Arguments[0].(type) {\n\t\tcase *Object:\n\t\t\tprimValue := t.toPrimitiveNumber()\n\t\t\tif bigint, ok := primValue.(*valueBigInt); ok {\n\t\t\t\treturn intToValue((*big.Int)(bigint).Int64())\n\t\t\t}\n\t\t\treturn primValue.ToNumber()\n\t\tcase *valueBigInt:\n\t\t\treturn intToValue((*big.Int)(t).Int64())\n\t\tdefault:\n\t\t\treturn t.ToNumber()\n\t\t}\n\t} else {\n\t\treturn valueInt(0)\n\t}\n}\n\nfunc (r *Runtime) builtin_newNumber(args []Value, proto *Object) *Object {\n\tvar v Value\n\tif len(args) > 0 {\n\t\tswitch t := args[0].(type) {\n\t\tcase *Object:\n\t\t\tprimValue := t.toPrimitiveNumber()\n\t\t\tif bigint, ok := primValue.(*valueBigInt); ok {\n\t\t\t\tv = intToValue((*big.Int)(bigint).Int64())\n\t\t\t} else {\n\t\t\t\tv = primValue.ToNumber()\n\t\t\t}\n\t\tcase *valueBigInt:\n\t\t\tv = intToValue((*big.Int)(t).Int64())\n\t\tdefault:\n\t\t\tv = t.ToNumber()\n\t\t}\n\t} else {\n\t\tv = intToValue(0)\n\t}\n\treturn r.newPrimitiveObject(v, proto, classNumber)\n}\n\nfunc (r *Runtime) builtin_Boolean(call FunctionCall) Value {\n\tif len(call.Arguments) > 0 {\n\t\tif call.Arguments[0].ToBoolean() {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\nfunc (r *Runtime) builtin_newBoolean(args []Value, proto *Object) *Object {\n\tvar v Value\n\tif len(args) > 0 {\n\t\tif args[0].ToBoolean() {\n\t\t\tv = valueTrue\n\t\t} else {\n\t\t\tv = valueFalse\n\t\t}\n\t} else {\n\t\tv = valueFalse\n\t}\n\treturn r.newPrimitiveObject(v, proto, classBoolean)\n}\n\nfunc (r *Runtime) builtin_new(construct *Object, args []Value) *Object {\n\treturn r.toConstructor(construct)(args, construct)\n}\n\nfunc (r *Runtime) builtin_thrower(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tstrict := true\n\tswitch fn := obj.self.(type) {\n\tcase *funcObject:\n\t\tstrict = fn.strict\n\t}\n\tr.typeErrorResult(strict, \"'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\")\n\treturn nil\n}\n\nfunc (r *Runtime) eval(srcVal String, direct, strict bool) Value {\n\tsrc := escapeInvalidUtf16(srcVal)\n\tvm := r.vm\n\tinGlobal := true\n\tif direct {\n\t\tfor s := vm.stash; s != nil; s = s.outer {\n\t\t\tif s.isVariable() {\n\t\t\t\tinGlobal = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tvm.pushCtx()\n\tfuncObj := _undefined\n\tif !direct {\n\t\tvm.stash = &r.global.stash\n\t\tvm.privEnv = nil\n\t} else {\n\t\tif sb := vm.sb; sb > 0 {\n\t\t\tfuncObj = vm.stack[sb-1]\n\t\t}\n\t}\n\tp, err := r.compile(\"<eval>\", src, strict, inGlobal, r.vm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvm.prg = p\n\tvm.pc = 0\n\tvm.args = 0\n\tvm.result = _undefined\n\tvm.push(funcObj)\n\tvm.sb = vm.sp\n\tvm.push(nil) // this\n\tex := vm.runTry()\n\tretval := vm.result\n\tvm.popCtx()\n\tif ex != nil {\n\t\tpanic(ex)\n\t}\n\tvm.sp -= 2\n\treturn retval\n}\n\nfunc (r *Runtime) builtin_eval(call FunctionCall) Value {\n\tif len(call.Arguments) == 0 {\n\t\treturn _undefined\n\t}\n\tif str, ok := call.Arguments[0].(String); ok {\n\t\treturn r.eval(str, false, false)\n\t}\n\treturn call.Arguments[0]\n}\n\nfunc (r *Runtime) constructToCall(construct func(args []Value, proto *Object) *Object, proto *Object) func(call FunctionCall) Value {\n\treturn func(call FunctionCall) Value {\n\t\treturn construct(call.Arguments, proto)\n\t}\n}\n\nfunc (r *Runtime) wrapNativeConstruct(c func(args []Value, proto *Object) *Object, ctorObj, defProto *Object) func(args []Value, newTarget *Object) *Object {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn func(args []Value, newTarget *Object) *Object {\n\t\tvar proto *Object\n\t\tif newTarget != nil {\n\t\t\tproto = r.getPrototypeFromCtor(newTarget, ctorObj, defProto)\n\t\t} else {\n\t\t\tproto = defProto\n\t\t}\n\t\treturn c(args, proto)\n\t}\n}\n\nfunc (r *Runtime) toCallable(v Value) func(FunctionCall) Value {\n\tif call, ok := r.toObject(v).self.assertCallable(); ok {\n\t\treturn call\n\t}\n\tr.typeErrorResult(true, \"Value is not callable: %s\", v.toString())\n\treturn nil\n}\n\nfunc (r *Runtime) checkObjectCoercible(v Value) {\n\tswitch v.(type) {\n\tcase valueUndefined, valueNull:\n\t\tr.typeErrorResult(true, \"Value is not object coercible\")\n\t}\n}\n\nfunc toInt8(v Value) int8 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn int8(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn int8(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint8(v Value) uint8 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn uint8(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn uint8(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint8Clamp(v Value) uint8 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\tif i < 0 {\n\t\t\treturn 0\n\t\t}\n\t\tif i <= 255 {\n\t\t\treturn uint8(i)\n\t\t}\n\t\treturn 255\n\t}\n\n\tif num, ok := v.(valueFloat); ok {\n\t\tnum := float64(num)\n\t\tif !math.IsNaN(num) {\n\t\t\tif num < 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif num > 255 {\n\t\t\t\treturn 255\n\t\t\t}\n\t\t\tf := math.Floor(num)\n\t\t\tf1 := f + 0.5\n\t\t\tif f1 < num {\n\t\t\t\treturn uint8(f + 1)\n\t\t\t}\n\t\t\tif f1 > num {\n\t\t\t\treturn uint8(f)\n\t\t\t}\n\t\t\tr := uint8(f)\n\t\t\tif r&1 != 0 {\n\t\t\t\treturn r + 1\n\t\t\t}\n\t\t\treturn r\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toInt16(v Value) int16 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn int16(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn int16(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint16(v Value) uint16 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn uint16(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn uint16(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toInt32(v Value) int32 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn int32(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn int32(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint32(v Value) uint32 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn uint32(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn uint32(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toInt64(v Value) int64 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn int64(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn int64(f)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint64(v Value) uint64 {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn uint64(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn uint64(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toInt(v Value) int {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn int(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn int(f)\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toUint(v Value) uint {\n\tv = v.ToNumber()\n\tif i, ok := v.(valueInt); ok {\n\t\treturn uint(i)\n\t}\n\n\tif f, ok := v.(valueFloat); ok {\n\t\tf := float64(f)\n\t\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\t\treturn uint(int64(f))\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc toFloat32(v Value) float32 {\n\treturn float32(v.ToFloat())\n}\n\nfunc toLength(v Value) int64 {\n\tif v == nil {\n\t\treturn 0\n\t}\n\ti := v.ToInteger()\n\tif i < 0 {\n\t\treturn 0\n\t}\n\tif i >= maxInt {\n\t\treturn maxInt - 1\n\t}\n\treturn i\n}\n\nfunc (r *Runtime) toLengthUint32(v Value) uint32 {\n\tvar intVal int64\nrepeat:\n\tswitch num := v.(type) {\n\tcase valueInt:\n\t\tintVal = int64(num)\n\tcase valueFloat:\n\t\tif v != _negativeZero {\n\t\t\tif i, ok := floatToInt(float64(num)); ok {\n\t\t\t\tintVal = i\n\t\t\t} else {\n\t\t\t\tgoto fail\n\t\t\t}\n\t\t}\n\tcase String:\n\t\tv = num.ToNumber()\n\t\tgoto repeat\n\tdefault:\n\t\t// Legacy behaviour as specified in https://tc39.es/ecma262/#sec-arraysetlength (see the note)\n\t\tn2 := toUint32(v)\n\t\tn1 := v.ToNumber()\n\t\tif f, ok := n1.(valueFloat); ok {\n\t\t\tf := float64(f)\n\t\t\tif f != 0 || !math.Signbit(f) {\n\t\t\t\tgoto fail\n\t\t\t}\n\t\t}\n\t\tif n1.ToInteger() != int64(n2) {\n\t\t\tgoto fail\n\t\t}\n\t\treturn n2\n\t}\n\tif intVal >= 0 && intVal <= math.MaxUint32 {\n\t\treturn uint32(intVal)\n\t}\nfail:\n\tpanic(r.newError(r.getRangeError(), \"Invalid array length\"))\n}\n\nfunc toIntStrict(i int64) int {\n\tif bits.UintSize == 32 {\n\t\tif i > math.MaxInt32 || i < math.MinInt32 {\n\t\t\tpanic(rangeError(\"Integer value overflows 32-bit int\"))\n\t\t}\n\t}\n\treturn int(i)\n}\n\nfunc toIntClamp(i int64) int {\n\tif bits.UintSize == 32 {\n\t\tif i > math.MaxInt32 {\n\t\t\treturn math.MaxInt32\n\t\t}\n\t\tif i < math.MinInt32 {\n\t\t\treturn math.MinInt32\n\t\t}\n\t}\n\treturn int(i)\n}\n\nfunc (r *Runtime) toIndex(v Value) int {\n\tnum := v.ToInteger()\n\tif num >= 0 && num < maxInt {\n\t\tif bits.UintSize == 32 && num >= math.MaxInt32 {\n\t\t\tpanic(r.newError(r.getRangeError(), \"Index %s overflows int\", v.String()))\n\t\t}\n\t\treturn int(num)\n\t}\n\tpanic(r.newError(r.getRangeError(), \"Invalid index %s\", v.String()))\n}\n\nfunc (r *Runtime) toBoolean(b bool) Value {\n\tif b {\n\t\treturn valueTrue\n\t} else {\n\t\treturn valueFalse\n\t}\n}\n\n// New creates an instance of a Javascript runtime that can be used to run code. Multiple instances may be created and\n// used simultaneously, however it is not possible to pass JS values across runtimes.\nfunc New() *Runtime {\n\tr := &Runtime{}\n\tr.init()\n\treturn r\n}\n\n// Compile creates an internal representation of the JavaScript code that can be later run using the Runtime.RunProgram()\n// method. This representation is not linked to a runtime in any way and can be run in multiple runtimes (possibly\n// at the same time).\nfunc Compile(name, src string, strict bool) (*Program, error) {\n\treturn compile(name, src, strict, true, nil)\n}\n\n// CompileAST creates an internal representation of the JavaScript code that can be later run using the Runtime.RunProgram()\n// method. This representation is not linked to a runtime in any way and can be run in multiple runtimes (possibly\n// at the same time).\nfunc CompileAST(prg *js_ast.Program, strict bool) (*Program, error) {\n\treturn compileAST(prg, strict, true, nil)\n}\n\n// MustCompile is like Compile but panics if the code cannot be compiled.\n// It simplifies safe initialization of global variables holding compiled JavaScript code.\nfunc MustCompile(name, src string, strict bool) *Program {\n\tprg, err := Compile(name, src, strict)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn prg\n}\n\n// Parse takes a source string and produces a parsed AST. Use this function if you want to pass options\n// to the parser, e.g.:\n//\n//\tp, err := Parse(\"test.js\", \"var a = true\", parser.WithDisableSourceMaps)\n//\tif err != nil { /* ... */ }\n//\tprg, err := CompileAST(p, true)\n//\t// ...\n//\n// Otherwise use Compile which combines both steps.\nfunc Parse(name, src string, options ...parser.Option) (prg *js_ast.Program, err error) {\n\tprg, err1 := parser.ParseFile(nil, name, src, 0, options...)\n\tif err1 != nil {\n\t\t// FIXME offset\n\t\terr = &CompilerSyntaxError{\n\t\t\tCompilerError: CompilerError{\n\t\t\t\tMessage: err1.Error(),\n\t\t\t},\n\t\t}\n\t}\n\treturn\n}\n\nfunc compile(name, src string, strict, inGlobal bool, evalVm *vm, parserOptions ...parser.Option) (p *Program, err error) {\n\tprg, err := Parse(name, src, parserOptions...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn compileAST(prg, strict, inGlobal, evalVm)\n}\n\nfunc compileAST(prg *js_ast.Program, strict, inGlobal bool, evalVm *vm) (p *Program, err error) {\n\tc := newCompiler()\n\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tp = nil\n\t\t\tswitch x1 := x.(type) {\n\t\t\tcase *CompilerSyntaxError:\n\t\t\t\terr = x1\n\t\t\tdefault:\n\t\t\t\tpanic(x)\n\t\t\t}\n\t\t}\n\t}()\n\n\tc.compile(prg, strict, inGlobal, evalVm)\n\tp = c.p\n\treturn\n}\n\nfunc (r *Runtime) compile(name, src string, strict, inGlobal bool, evalVm *vm) (p *Program, err error) {\n\tp, err = compile(name, src, strict, inGlobal, evalVm, r.parserOptions...)\n\tif err != nil {\n\t\tswitch x1 := err.(type) {\n\t\tcase *CompilerSyntaxError:\n\t\t\terr = &Exception{\n\t\t\t\tval: r.builtin_new(r.getSyntaxError(), []Value{newStringValue(x1.Error())}),\n\t\t\t}\n\t\tcase *CompilerReferenceError:\n\t\t\terr = &Exception{\n\t\t\t\tval: r.newError(r.getReferenceError(), x1.Message),\n\t\t\t} // TODO proper message\n\t\t}\n\t}\n\treturn\n}\n\n// RunString executes the given string in the global context.\nfunc (r *Runtime) RunString(str string) (Value, error) {\n\treturn r.RunScript(\"\", str)\n}\n\n// RunScript executes the given string in the global context.\nfunc (r *Runtime) RunScript(name, src string) (Value, error) {\n\tp, err := r.compile(name, src, false, true, nil)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r.RunProgram(p)\n}\n\nfunc isUncatchableException(e error) bool {\n\tfor ; e != nil; e = errors.Unwrap(e) {\n\t\tif _, ok := e.(uncatchableException); ok {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc asUncatchableException(v interface{}) error {\n\tswitch v := v.(type) {\n\tcase uncatchableException:\n\t\treturn v\n\tcase error:\n\t\tif isUncatchableException(v) {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn nil\n}\n\n// RunProgram executes a pre-compiled (see Compile()) code in the global context.\nfunc (r *Runtime) RunProgram(p *Program) (result Value, err error) {\n\tvm := r.vm\n\trecursive := len(vm.callStack) > 0\n\tdefer func() {\n\t\tif recursive {\n\t\t\tvm.sp -= 2\n\t\t\tvm.popCtx()\n\t\t} else {\n\t\t\tvm.callStack = vm.callStack[:len(vm.callStack)-1]\n\t\t}\n\t\tif x := recover(); x != nil {\n\t\t\tif ex := asUncatchableException(x); ex != nil {\n\t\t\t\terr = ex\n\t\t\t\tif len(vm.callStack) == 0 {\n\t\t\t\t\tr.leaveAbrupt()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(x)\n\t\t\t}\n\t\t}\n\t}()\n\tif recursive {\n\t\tvm.pushCtx()\n\t\tvm.stash = &r.global.stash\n\t\tvm.privEnv = nil\n\t\tvm.newTarget = nil\n\t\tvm.args = 0\n\t\tsp := vm.sp\n\t\tvm.stack.expand(sp + 1)\n\t\tvm.stack[sp] = _undefined // 'callee'\n\t\tvm.stack[sp+1] = nil      // 'this'\n\t\tvm.sb = sp + 1\n\t\tvm.sp = sp + 2\n\t} else {\n\t\tvm.callStack = append(vm.callStack, context{})\n\t}\n\tvm.prg = p\n\tvm.pc = 0\n\tvm.result = _undefined\n\tex := vm.runTry()\n\tif ex == nil {\n\t\tresult = r.vm.result\n\t} else {\n\t\terr = ex\n\t}\n\tif recursive {\n\t\tvm.clearStack()\n\t} else {\n\t\tvm.prg = nil\n\t\tvm.sb = -1\n\t\tr.leave()\n\t}\n\treturn\n}\n\n// CaptureCallStack appends the current call stack frames to the stack slice (which may be nil) up to the specified depth.\n// The most recent frame will be the first one.\n// If depth <= 0 or more than the number of available frames, returns the entire stack.\n// This method is not safe for concurrent use and should only be called by a Go function that is\n// called from a running script.\nfunc (r *Runtime) CaptureCallStack(depth int, stack []StackFrame) []StackFrame {\n\tl := len(r.vm.callStack)\n\tvar offset int\n\tif depth > 0 {\n\t\toffset = l - depth + 1\n\t\tif offset < 0 {\n\t\t\toffset = 0\n\t\t}\n\t}\n\tif stack == nil {\n\t\tstack = make([]StackFrame, 0, l-offset+1)\n\t}\n\treturn r.vm.captureStack(stack, offset)\n}\n\n// Interrupt a running JavaScript. The corresponding Go call will return an *InterruptedError containing v.\n// If the interrupt propagates until the stack is empty the currently queued promise resolve/reject jobs will be cleared\n// without being executed. This is the same time they would be executed otherwise.\n// Note, it only works while in JavaScript code, it does not interrupt native Go functions (which includes all built-ins).\n// If the runtime is currently not running, it will be immediately interrupted on the next Run*() call.\n// To avoid that use ClearInterrupt()\nfunc (r *Runtime) Interrupt(v interface{}) {\n\tr.vm.Interrupt(v)\n}\n\n// ClearInterrupt resets the interrupt flag. Typically this needs to be called before the runtime\n// is made available for re-use if there is a chance it could have been interrupted with Interrupt().\n// Otherwise if Interrupt() was called when runtime was not running (e.g. if it had already finished)\n// so that Interrupt() didn't actually trigger, an attempt to use the runtime will immediately cause\n// an interruption. It is up to the user to ensure proper synchronisation so that ClearInterrupt() is\n// only called when the runtime has finished and there is no chance of a concurrent Interrupt() call.\nfunc (r *Runtime) ClearInterrupt() {\n\tr.vm.ClearInterrupt()\n}\n\n/*\nToValue converts a Go value into a JavaScript value of a most appropriate type. Structural types (such as structs, maps\nand slices) are wrapped so that changes are reflected on the original value which can be retrieved using Value.Export().\n\nWARNING! These wrapped Go values do not behave in the same way as native ECMAScript values. If you plan to modify\nthem in ECMAScript, bear in mind the following caveats:\n\n1. If a regular JavaScript Object is assigned as an element of a wrapped Go struct, map or array, it is\nExport()'ed and therefore copied. This may result in an unexpected behaviour in JavaScript:\n\n\tm := map[string]interface{}{}\n\tvm.Set(\"m\", m)\n\tvm.RunString(`\n\tvar obj = {test: false};\n\tm.obj = obj; // obj gets Export()'ed, i.e. copied to a new map[string]interface{} and then this map is set as m[\"obj\"]\n\tobj.test = true; // note, m.obj.test is still false\n\t`)\n\tfmt.Println(m[\"obj\"].(map[string]interface{})[\"test\"]) // prints \"false\"\n\n2. Be careful with nested non-pointer compound types (structs, slices and arrays) if you modify them in\nECMAScript. Better avoid it at all if possible. One of the fundamental differences between ECMAScript and Go is in\nthe former all Objects are references whereas in Go you can have a literal struct or array. Consider the following\nexample:\n\n\ttype S struct {\n\t    Field int\n\t}\n\n\ta := []S{{1}, {2}} // slice of literal structs\n\tvm.Set(\"a\", &a)\n\tvm.RunString(`\n\t    let tmp = {Field: 1};\n\t    a[0] = tmp;\n\t    a[1] = tmp;\n\t    tmp.Field = 2;\n\t`)\n\nIn ECMAScript one would expect a[0].Field and a[1].Field to be equal to 2, but this is really not possible\n(or at least non-trivial without some complex reference tracking).\n\nTo cover the most common use cases and to avoid excessive memory allocation, the following 'copy-on-change' mechanism\nis implemented (for both arrays and structs):\n\n* When a nested compound value is accessed, the returned ES value becomes a reference to the literal value.\nThis ensures that things like 'a[0].Field = 1' work as expected and simple access to 'a[0].Field' does not result\nin copying of a[0].\n\n* The original container ('a' in our case) keeps track of the returned reference value and if a[0] is reassigned\n(e.g. by direct assignment, deletion or shrinking the array) the old a[0] is copied and the earlier returned value\nbecomes a reference to the copy:\n\n\tlet tmp = a[0];                      // no copy, tmp is a reference to a[0]\n\ttmp.Field = 1;                       // a[0].Field === 1 after this\n\ta[0] = {Field: 2};                   // tmp is now a reference to a copy of the old value (with Field === 1)\n\ta[0].Field === 2 && tmp.Field === 1; // true\n\n* Array value swaps caused by in-place sort (using Array.prototype.sort()) do not count as re-assignments, instead\nthe references are adjusted to point to the new indices.\n\n* Assignment to an inner compound value always does a copy (and sometimes type conversion):\n\n\ta[1] = tmp;    // a[1] is now a copy of tmp\n\ttmp.Field = 3; // does not affect a[1].Field\n\n3. Non-addressable structs, slices and arrays get copied. This sometimes may lead to a confusion as assigning to\ninner fields does not appear to work:\n\n\ta1 := []interface{}{S{1}, S{2}}\n\tvm.Set(\"a1\", &a1)\n\tvm.RunString(`\n\t   a1[0].Field === 1; // true\n\t   a1[0].Field = 2;\n\t   a1[0].Field === 2; // FALSE, because what it really did was copy a1[0] set its Field to 2 and immediately drop it\n\t`)\n\nAn alternative would be making a1[0].Field a non-writable property which would probably be more in line with\nECMAScript, however it would require to manually copy the value if it does need to be modified which may be\nimpractical.\n\nNote, the same applies to slices. If a slice is passed by value (not as a pointer), resizing the slice does not reflect on the original\nvalue. Moreover, extending the slice may result in the underlying array being re-allocated and copied.\nFor example:\n\n\ta := []interface{}{1}\n\tvm.Set(\"a\", a)\n\tvm.RunString(`a.push(2); a[0] = 0;`)\n\tfmt.Println(a[0]) // prints \"1\"\n\nNotes on individual types:\n\n# Primitive types\n\nPrimitive types (numbers, string, bool) are converted to the corresponding JavaScript primitives. These values\nare goroutine-safe and can be transferred between runtimes.\n\n# Strings\n\nBecause of the difference in internal string representation between ECMAScript (which uses UTF-16) and Go (which uses\nUTF-8) conversion from JS to Go may be lossy. In particular, code points that can be part of UTF-16 surrogate pairs\n(0xD800-0xDFFF) cannot be represented in UTF-8 unless they form a valid surrogate pair and are replaced with\nutf8.RuneError.\n\nThe string value must be a valid UTF-8. If it is not, invalid characters are replaced with utf8.RuneError, but\nthe behaviour of a subsequent Export() is unspecified (it may return the original value, or a value with replaced\ninvalid characters).\n\n# Nil\n\nNil is converted to null.\n\n# Functions\n\nfunc(FunctionCall) Value is treated as a native JavaScript function. This increases performance because there are no\nautomatic argument and return value type conversions (which involves reflect). Attempting to use\nthe function as a constructor will result in a TypeError. Note: implementations must not retain and use references\nto FunctionCall.Arguments after the function returns.\n\nfunc(FunctionCall, *Runtime) Value is treated as above, except the *Runtime is also passed as a parameter.\n\nfunc(ConstructorCall) *Object is treated as a native constructor, allowing to use it with the new\noperator:\n\n\tfunc MyObject(call goja.ConstructorCall) *goja.Object {\n\t   // call.This contains the newly created object as per http://www.ecma-international.org/ecma-262/5.1/index.html#sec-13.2.2\n\t   // call.Arguments contain arguments passed to the function\n\n\t   call.This.Set(\"method\", method)\n\n\t   //...\n\n\t   // If return value is a non-nil *Object, it will be used instead of call.This\n\t   // This way it is possible to return a Go struct or a map converted\n\t   // into goja.Value using ToValue(), however in this case\n\t   // instanceof will not work as expected, unless you set the prototype:\n\t   //\n\t   // instance := &myCustomStruct{}\n\t   // instanceValue := vm.ToValue(instance).(*Object)\n\t   // instanceValue.SetPrototype(call.This.Prototype())\n\t   // return instanceValue\n\t   return nil\n\t}\n\n\truntime.Set(\"MyObject\", MyObject)\n\nThen it can be used in JS as follows:\n\n\tvar o = new MyObject(arg);\n\tvar o1 = MyObject(arg); // same thing\n\to instanceof MyObject && o1 instanceof MyObject; // true\n\nWhen a native constructor is called directly (without the new operator) its behavior depends on\nthis value: if it's an Object, it is passed through, otherwise a new one is created exactly as\nif it was called with the new operator. In either case call.NewTarget will be nil.\n\nfunc(ConstructorCall, *Runtime) *Object is treated as above, except the *Runtime is also passed as a parameter.\n\nAny other Go function is wrapped so that the arguments are automatically converted into the required Go types and the\nreturn value is converted to a JavaScript value (using this method).  If conversion is not possible, a TypeError is\nthrown.\n\nFunctions with multiple return values return an Array. If the last return value is an `error` it is not returned but\nconverted into a JS exception. If the error is *Exception, it is thrown as is, otherwise it's wrapped in a GoEerror.\nNote that if there are exactly two return values and the last is an `error`, the function returns the first value as is,\nnot an Array.\n\n# Structs\n\nStructs are converted to Object-like values. Fields and methods are available as properties, their values are\nresults of this method (ToValue()) applied to the corresponding Go value.\n\nField properties are writable and non-configurable. Method properties are non-writable and non-configurable.\n\nAttempt to define a new property or delete an existing property will fail (throw in strict mode) unless it's a Symbol\nproperty. Symbol properties only exist in the wrapper and do not affect the underlying Go value.\nNote that because a wrapper is created every time a property is accessed it may lead to unexpected results such as this:\n\n\t type Field struct{\n\t }\n\t type S struct {\n\t\tField *Field\n\t }\n\t var s = S{\n\t\tField: &Field{},\n\t }\n\t vm := New()\n\t vm.Set(\"s\", &s)\n\t res, err := vm.RunString(`\n\t var sym = Symbol(66);\n\t var field1 = s.Field;\n\t field1[sym] = true;\n\t var field2 = s.Field;\n\t field1 === field2; // true, because the equality operation compares the wrapped values, not the wrappers\n\t field1[sym] === true; // true\n\t field2[sym] === undefined; // also true\n\t `)\n\nThe same applies to values from maps and slices as well.\n\n# Handling of time.Time\n\ntime.Time does not get special treatment and therefore is converted just like any other `struct` providing access to\nall its methods. This is done deliberately instead of converting it to a `Date` because these two types are not fully\ncompatible: `time.Time` includes zone, whereas JS `Date` doesn't. Doing the conversion implicitly therefore would\nresult in a loss of information.\n\nIf you need to convert it to a `Date`, it can be done either in JS:\n\n\tvar d = new Date(goval.UnixNano()/1e6);\n\n... or in Go:\n\n\t now := time.Now()\n\t vm := New()\n\t val, err := vm.New(vm.Get(\"Date\").ToObject(vm), vm.ToValue(now.UnixNano()/1e6))\n\t if err != nil {\n\t\t...\n\t }\n\t vm.Set(\"d\", val)\n\nNote that Value.Export() for a `Date` value returns time.Time in local timezone.\n\n# Maps\n\nMaps with string, integer, or float key types are converted into host objects that largely behave like a JavaScript Object.\nOne noticeable difference is that the key order is not stable, as with maps in Go.\nKeys are converted to strings following the fmt.Sprintf(\"%v\") convention.\n\n# Maps with methods\n\nIf a map type has at least one method defined, the properties of the resulting Object represent methods, not map keys.\nThis is because in JavaScript there is no distinction between 'object.key` and `object[key]`, unlike Go.\nIf access to the map values is required, it can be achieved by defining another method or, if it's not possible, by\ndefining an external getter function.\n\n# Slices\n\nSlices are converted into host objects that behave largely like JavaScript Array. It has the appropriate\nprototype and all the usual methods should work. There is, however, a caveat: converted Arrays may not contain holes\n(because Go slices cannot). This means that hasOwnProperty(n) always returns `true` if n < length. Deleting an item with\nan index < length will set it to a zero value (but the property will remain). Nil slice elements are be converted to\n`null`. Accessing an element beyond `length` returns `undefined`. Also see the warning above about passing slices as\nvalues (as opposed to pointers).\n\n# Arrays\n\nArrays are converted similarly to slices, except the resulting Arrays are not resizable (and therefore the 'length'\nproperty is non-writable).\n\nAny other type is converted to a generic reflect based host object. Depending on the underlying type it behaves similar\nto a Number, String, Boolean or Object.\n\nNote that the underlying type is not lost, calling Export() returns the original Go value. This applies to all\nreflect based types.\n*/\nfunc (r *Runtime) ToValue(i interface{}) Value {\n\treturn r.toValue(i, reflect.Value{})\n}\n\nfunc (r *Runtime) toValue(i interface{}, origValue reflect.Value) Value {\n\tswitch i := i.(type) {\n\tcase nil:\n\t\treturn _null\n\tcase *Object:\n\t\tif i == nil || i.self == nil {\n\t\t\treturn _null\n\t\t}\n\t\tif i.runtime != nil && i.runtime != r {\n\t\t\tpanic(r.NewTypeError(\"Illegal runtime transition of an Object\"))\n\t\t}\n\t\treturn i\n\tcase valueContainer:\n\t\treturn i.toValue(r)\n\tcase Value:\n\t\treturn i\n\tcase string:\n\t\tif len(i) <= 16 {\n\t\t\tif u := unistring.Scan(i); u != nil {\n\t\t\t\treturn &importedString{s: i, u: u, scanned: true}\n\t\t\t}\n\t\t\treturn asciiString(i)\n\t\t}\n\t\treturn &importedString{s: i}\n\tcase bool:\n\t\tif i {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\tcase func(FunctionCall) Value:\n\t\tname := unistring.NewFromString(runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name())\n\t\treturn r.newNativeFunc(i, name, 0)\n\tcase func(FunctionCall, *Runtime) Value:\n\t\tname := unistring.NewFromString(runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name())\n\t\treturn r.newNativeFunc(func(call FunctionCall) Value {\n\t\t\treturn i(call, r)\n\t\t}, name, 0)\n\tcase func(ConstructorCall) *Object:\n\t\tname := unistring.NewFromString(runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name())\n\t\treturn r.newNativeConstructor(i, name, 0)\n\tcase func(ConstructorCall, *Runtime) *Object:\n\t\tname := unistring.NewFromString(runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name())\n\t\treturn r.newNativeConstructor(func(call ConstructorCall) *Object {\n\t\t\treturn i(call, r)\n\t\t}, name, 0)\n\tcase int:\n\t\treturn intToValue(int64(i))\n\tcase int8:\n\t\treturn intToValue(int64(i))\n\tcase int16:\n\t\treturn intToValue(int64(i))\n\tcase int32:\n\t\treturn intToValue(int64(i))\n\tcase int64:\n\t\treturn intToValue(i)\n\tcase uint:\n\t\tif uint64(i) <= math.MaxInt64 {\n\t\t\treturn intToValue(int64(i))\n\t\t} else {\n\t\t\treturn floatToValue(float64(i))\n\t\t}\n\tcase uint8:\n\t\treturn intToValue(int64(i))\n\tcase uint16:\n\t\treturn intToValue(int64(i))\n\tcase uint32:\n\t\treturn intToValue(int64(i))\n\tcase uint64:\n\t\tif i <= math.MaxInt64 {\n\t\t\treturn intToValue(int64(i))\n\t\t}\n\t\treturn floatToValue(float64(i))\n\tcase float32:\n\t\treturn floatToValue(float64(i))\n\tcase float64:\n\t\treturn floatToValue(i)\n\tcase *big.Int:\n\t\treturn (*valueBigInt)(new(big.Int).Set(i))\n\tcase map[string]interface{}:\n\t\tif i == nil {\n\t\t\treturn _null\n\t\t}\n\t\tobj := &Object{runtime: r}\n\t\tm := &objectGoMapSimple{\n\t\t\tbaseObject: baseObject{\n\t\t\t\tval:        obj,\n\t\t\t\textensible: true,\n\t\t\t},\n\t\t\tdata: i,\n\t\t}\n\t\tobj.self = m\n\t\tm.init()\n\t\treturn obj\n\tcase []interface{}:\n\t\treturn r.newObjectGoSlice(&i, false).val\n\tcase *[]interface{}:\n\t\tif i == nil {\n\t\t\treturn _null\n\t\t}\n\t\treturn r.newObjectGoSlice(i, true).val\n\t}\n\n\tif !origValue.IsValid() {\n\t\torigValue = reflect.ValueOf(i)\n\t}\n\n\tvalue := origValue\n\tfor value.Kind() == reflect.Ptr {\n\t\tvalue = value.Elem()\n\t}\n\n\tif !value.IsValid() {\n\t\treturn _null\n\t}\n\n\tswitch value.Kind() {\n\tcase reflect.Map:\n\t\tif value.Type().NumMethod() == 0 {\n\t\t\tswitch value.Type().Key().Kind() {\n\t\t\tcase reflect.String, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\treflect.Float64, reflect.Float32:\n\n\t\t\t\tobj := &Object{runtime: r}\n\t\t\t\tm := &objectGoMapReflect{\n\t\t\t\t\tobjectGoReflect: objectGoReflect{\n\t\t\t\t\t\tbaseObject: baseObject{\n\t\t\t\t\t\t\tval:        obj,\n\t\t\t\t\t\t\textensible: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\torigValue:   origValue,\n\t\t\t\t\t\tfieldsValue: value,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tm.init()\n\t\t\t\tobj.self = m\n\t\t\t\treturn obj\n\t\t\t}\n\t\t}\n\tcase reflect.Array:\n\t\tobj := &Object{runtime: r}\n\t\ta := &objectGoArrayReflect{\n\t\t\tobjectGoReflect: objectGoReflect{\n\t\t\t\tbaseObject: baseObject{\n\t\t\t\t\tval: obj,\n\t\t\t\t},\n\t\t\t\torigValue:   origValue,\n\t\t\t\tfieldsValue: value,\n\t\t\t},\n\t\t}\n\t\ta.init()\n\t\tobj.self = a\n\t\treturn obj\n\tcase reflect.Slice:\n\t\tobj := &Object{runtime: r}\n\t\ta := &objectGoSliceReflect{\n\t\t\tobjectGoArrayReflect: objectGoArrayReflect{\n\t\t\t\tobjectGoReflect: objectGoReflect{\n\t\t\t\t\tbaseObject: baseObject{\n\t\t\t\t\t\tval: obj,\n\t\t\t\t\t},\n\t\t\t\t\torigValue:   origValue,\n\t\t\t\t\tfieldsValue: value,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\ta.init()\n\t\tobj.self = a\n\t\treturn obj\n\tcase reflect.Func:\n\t\treturn r.newWrappedFunc(value)\n\t}\n\n\tobj := &Object{runtime: r}\n\to := &objectGoReflect{\n\t\tbaseObject: baseObject{\n\t\t\tval: obj,\n\t\t},\n\t\torigValue:   origValue,\n\t\tfieldsValue: value,\n\t}\n\tobj.self = o\n\to.init()\n\treturn obj\n}\n\nfunc (r *Runtime) wrapReflectFunc(value reflect.Value) func(FunctionCall) Value {\n\treturn func(call FunctionCall) Value {\n\t\ttyp := value.Type()\n\t\tnargs := typ.NumIn()\n\t\tvar in []reflect.Value\n\n\t\tif l := len(call.Arguments); l < nargs {\n\t\t\t// fill missing arguments with zero values\n\t\t\tn := nargs\n\t\t\tif typ.IsVariadic() {\n\t\t\t\tn--\n\t\t\t}\n\t\t\tin = make([]reflect.Value, n)\n\t\t\tfor i := l; i < n; i++ {\n\t\t\t\tin[i] = reflect.Zero(typ.In(i))\n\t\t\t}\n\t\t} else {\n\t\t\tif l > nargs && !typ.IsVariadic() {\n\t\t\t\tl = nargs\n\t\t\t}\n\t\t\tin = make([]reflect.Value, l)\n\t\t}\n\n\t\tfor i, a := range call.Arguments {\n\t\t\tvar t reflect.Type\n\n\t\t\tn := i\n\t\t\tif n >= nargs-1 && typ.IsVariadic() {\n\t\t\t\tif n > nargs-1 {\n\t\t\t\t\tn = nargs - 1\n\t\t\t\t}\n\n\t\t\t\tt = typ.In(n).Elem()\n\t\t\t} else if n > nargs-1 { // ignore extra arguments\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tt = typ.In(n)\n\t\t\t}\n\n\t\t\tv := reflect.New(t).Elem()\n\t\t\terr := r.toReflectValue(a, v, &objectExportCtx{})\n\t\t\tif err != nil {\n\t\t\t\tpanic(r.NewTypeError(\"could not convert function call parameter %d: %v\", i, err))\n\t\t\t}\n\t\t\tin[i] = v\n\t\t}\n\n\t\tout := value.Call(in)\n\t\tif len(out) == 0 {\n\t\t\treturn _undefined\n\t\t}\n\n\t\tif last := out[len(out)-1]; last.Type() == reflectTypeError {\n\t\t\tif !last.IsNil() {\n\t\t\t\terr := last.Interface().(error)\n\t\t\t\tif _, ok := err.(*Exception); ok {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tif isUncatchableException(err) {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tpanic(r.NewGoError(err))\n\t\t\t}\n\t\t\tout = out[:len(out)-1]\n\t\t}\n\n\t\tswitch len(out) {\n\t\tcase 0:\n\t\t\treturn _undefined\n\t\tcase 1:\n\t\t\treturn r.ToValue(out[0].Interface())\n\t\tdefault:\n\t\t\ts := make([]interface{}, len(out))\n\t\t\tfor i, v := range out {\n\t\t\t\ts[i] = v.Interface()\n\t\t\t}\n\n\t\t\treturn r.ToValue(s)\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) toReflectValue(v Value, dst reflect.Value, ctx *objectExportCtx) error {\n\ttyp := dst.Type()\n\n\tif typ == typeValue {\n\t\tdst.Set(reflect.ValueOf(v))\n\t\treturn nil\n\t}\n\n\tif typ == typeObject {\n\t\tif obj, ok := v.(*Object); ok {\n\t\t\tdst.Set(reflect.ValueOf(obj))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif typ == typeCallable {\n\t\tif fn, ok := AssertFunction(v); ok {\n\t\t\tdst.Set(reflect.ValueOf(fn))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tet := v.ExportType()\n\tif et == nil || et == reflectTypeNil {\n\t\tdst.Set(reflect.Zero(typ))\n\t\treturn nil\n\t}\n\n\tkind := typ.Kind()\n\tfor i := 0; ; i++ {\n\t\tif et.AssignableTo(typ) {\n\t\t\tev := reflect.ValueOf(exportValue(v, ctx))\n\t\t\tfor ; i > 0; i-- {\n\t\t\t\tev = ev.Elem()\n\t\t\t}\n\t\t\tdst.Set(ev)\n\t\t\treturn nil\n\t\t}\n\t\texpKind := et.Kind()\n\t\tif expKind == kind && et.ConvertibleTo(typ) || expKind == reflect.String && typ == typeBytes {\n\t\t\tev := reflect.ValueOf(exportValue(v, ctx))\n\t\t\tfor ; i > 0; i-- {\n\t\t\t\tev = ev.Elem()\n\t\t\t}\n\t\t\tdst.Set(ev.Convert(typ))\n\t\t\treturn nil\n\t\t}\n\t\tif expKind == reflect.Ptr {\n\t\t\tet = et.Elem()\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif typ == typeTime {\n\t\tif obj, ok := v.(*Object); ok {\n\t\t\tif d, ok := obj.self.(*dateObject); ok {\n\t\t\t\tdst.Set(reflect.ValueOf(d.time()))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif et.Kind() == reflect.String {\n\t\t\ttme, ok := dateParse(v.String())\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"could not convert string %v to %v\", v, typ)\n\t\t\t}\n\t\t\tdst.Set(reflect.ValueOf(tme))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tswitch kind {\n\tcase reflect.String:\n\t\tdst.Set(reflect.ValueOf(v.String()).Convert(typ))\n\t\treturn nil\n\tcase reflect.Bool:\n\t\tdst.Set(reflect.ValueOf(v.ToBoolean()).Convert(typ))\n\t\treturn nil\n\tcase reflect.Int:\n\t\tdst.Set(reflect.ValueOf(toInt(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Int64:\n\t\tdst.Set(reflect.ValueOf(toInt64(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Int32:\n\t\tdst.Set(reflect.ValueOf(toInt32(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Int16:\n\t\tdst.Set(reflect.ValueOf(toInt16(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Int8:\n\t\tdst.Set(reflect.ValueOf(toInt8(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Uint:\n\t\tdst.Set(reflect.ValueOf(toUint(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Uint64:\n\t\tdst.Set(reflect.ValueOf(toUint64(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Uint32:\n\t\tdst.Set(reflect.ValueOf(toUint32(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Uint16:\n\t\tdst.Set(reflect.ValueOf(toUint16(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Uint8:\n\t\tdst.Set(reflect.ValueOf(toUint8(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Float64:\n\t\tdst.Set(reflect.ValueOf(v.ToFloat()).Convert(typ))\n\t\treturn nil\n\tcase reflect.Float32:\n\t\tdst.Set(reflect.ValueOf(toFloat32(v)).Convert(typ))\n\t\treturn nil\n\tcase reflect.Slice, reflect.Array:\n\t\tif o, ok := v.(*Object); ok {\n\t\t\tif v, exists := ctx.getTyped(o, typ); exists {\n\t\t\t\tdst.Set(reflect.ValueOf(v))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn o.self.exportToArrayOrSlice(dst, typ, ctx)\n\t\t}\n\tcase reflect.Map:\n\t\tif o, ok := v.(*Object); ok {\n\t\t\tif v, exists := ctx.getTyped(o, typ); exists {\n\t\t\t\tdst.Set(reflect.ValueOf(v))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn o.self.exportToMap(dst, typ, ctx)\n\t\t}\n\tcase reflect.Struct:\n\t\tif o, ok := v.(*Object); ok {\n\t\t\tt := reflect.PtrTo(typ)\n\t\t\tif v, exists := ctx.getTyped(o, t); exists {\n\t\t\t\tdst.Set(reflect.ValueOf(v).Elem())\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts := dst\n\t\t\tctx.putTyped(o, t, s.Addr().Interface())\n\t\t\tfor i := 0; i < typ.NumField(); i++ {\n\t\t\t\tfield := typ.Field(i)\n\t\t\t\tif ast.IsExported(field.Name) {\n\t\t\t\t\tname := field.Name\n\t\t\t\t\tif r.fieldNameMapper != nil {\n\t\t\t\t\t\tname = r.fieldNameMapper.FieldName(typ, field)\n\t\t\t\t\t}\n\t\t\t\t\tvar v Value\n\t\t\t\t\tif field.Anonymous {\n\t\t\t\t\t\tv = o\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = o.self.getStr(unistring.NewFromString(name), nil)\n\t\t\t\t\t}\n\n\t\t\t\t\tif v != nil {\n\t\t\t\t\t\terr := r.toReflectValue(v, s.Field(i), ctx)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"could not convert struct value %v to %v for field %s: %w\", v, field.Type, field.Name, err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\tcase reflect.Func:\n\t\tif fn, ok := AssertFunction(v); ok {\n\t\t\tdst.Set(reflect.MakeFunc(typ, r.wrapJSFunc(fn, typ)))\n\t\t\treturn nil\n\t\t}\n\tcase reflect.Ptr:\n\t\tif o, ok := v.(*Object); ok {\n\t\t\tif v, exists := ctx.getTyped(o, typ); exists {\n\t\t\t\tdst.Set(reflect.ValueOf(v))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif dst.IsNil() {\n\t\t\tdst.Set(reflect.New(typ.Elem()))\n\t\t}\n\t\treturn r.toReflectValue(v, dst.Elem(), ctx)\n\t}\n\n\treturn fmt.Errorf(\"could not convert %v to %v\", v, typ)\n}\n\nfunc (r *Runtime) wrapJSFunc(fn Callable, typ reflect.Type) func(args []reflect.Value) (results []reflect.Value) {\n\treturn func(args []reflect.Value) (results []reflect.Value) {\n\t\tvar jsArgs []Value\n\t\tif len(args) > 0 {\n\t\t\tif typ.IsVariadic() {\n\t\t\t\tvarArg := args[len(args)-1]\n\t\t\t\targs = args[:len(args)-1]\n\t\t\t\tjsArgs = make([]Value, 0, len(args)+varArg.Len())\n\t\t\t\tfor _, arg := range args {\n\t\t\t\t\tjsArgs = append(jsArgs, r.ToValue(arg.Interface()))\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < varArg.Len(); i++ {\n\t\t\t\t\tjsArgs = append(jsArgs, r.ToValue(varArg.Index(i).Interface()))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjsArgs = make([]Value, len(args))\n\t\t\t\tfor i, arg := range args {\n\t\t\t\t\tjsArgs[i] = r.ToValue(arg.Interface())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumOut := typ.NumOut()\n\t\tresults = make([]reflect.Value, numOut)\n\t\tres, err := fn(_undefined, jsArgs...)\n\t\tif err == nil {\n\t\t\tif numOut > 0 {\n\t\t\t\tv := reflect.New(typ.Out(0)).Elem()\n\t\t\t\terr = r.toReflectValue(res, v, &objectExportCtx{})\n\t\t\t\tif err == nil {\n\t\t\t\t\tresults[0] = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err != nil {\n\t\t\tif numOut > 0 && typ.Out(numOut-1) == reflectTypeError {\n\t\t\t\tif ex, ok := err.(*Exception); ok {\n\t\t\t\t\tif exo, ok := ex.val.(*Object); ok {\n\t\t\t\t\t\tif v := exo.self.getStr(\"value\", nil); v != nil {\n\t\t\t\t\t\t\tif v.ExportType().AssignableTo(reflectTypeError) {\n\t\t\t\t\t\t\t\terr = v.Export().(error)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults[numOut-1] = reflect.ValueOf(err).Convert(typ.Out(numOut - 1))\n\t\t\t} else {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\n\t\tfor i, v := range results {\n\t\t\tif !v.IsValid() {\n\t\t\t\tresults[i] = reflect.Zero(typ.Out(i))\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n}\n\n// ExportTo converts a JavaScript value into the specified Go value. The second parameter must be a non-nil pointer.\n// Returns error if conversion is not possible.\n//\n// Notes on specific cases:\n//\n// # Empty interface\n//\n// Exporting to an interface{} results in a value of the same type as Value.Export() would produce.\n//\n// # Numeric types\n//\n// Exporting to numeric types uses the standard ECMAScript conversion operations, same as used when assigning\n// values to non-clamped typed array items, e.g. https://262.ecma-international.org/#sec-toint32.\n//\n// # Functions\n//\n// Exporting to a 'func' creates a strictly typed 'gateway' into an ES function which can be called from Go.\n// The arguments are converted into ES values using Runtime.ToValue(). If the func has no return values,\n// the return value is ignored. If the func has exactly one return value, it is converted to the appropriate\n// type using ExportTo(). If the last return value is 'error', exceptions are caught and returned as *Exception\n// (instances of GoError are unwrapped, i.e. their 'value' is returned instead). In all other cases exceptions\n// result in a panic. Any extra return values are zeroed.\n//\n// 'this' value will always be set to 'undefined'.\n//\n// For a more low-level mechanism see AssertFunction().\n//\n// # Map types\n//\n// An ES Map can be exported into a Go map type. If any exported key value is non-hashable, the operation panics\n// (as reflect.Value.SetMapIndex() would). Symbol.iterator is ignored.\n//\n// Exporting an ES Set into a map type results in the map being populated with (element) -> (zero value) key/value\n// pairs. If any value is non-hashable, the operation panics (as reflect.Value.SetMapIndex() would).\n// Symbol.iterator is ignored.\n//\n// Any other Object populates the map with own enumerable non-symbol properties.\n//\n// # Slice types\n//\n// Exporting an ES Set into a slice type results in its elements being exported.\n//\n// Exporting any Object that implements the iterable protocol (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol)\n// into a slice type results in the slice being populated with the results of the iteration.\n//\n// Array is treated as iterable (i.e. overwriting Symbol.iterator affects the result).\n//\n// If an object has a 'length' property and is not a function it is treated as array-like. The resulting slice\n// will contain obj[0], ... obj[length-1].\n//\n// ArrayBuffer and ArrayBuffer-backed types (i.e. typed arrays and DataView) can be exported into []byte. The result\n// is backed by the original data, no copy is performed.\n//\n// For any other Object an error is returned.\n//\n// # Array types\n//\n// Anything that can be exported to a slice type can also be exported to an array type, as long as the lengths\n// match. If they do not, an error is returned.\n//\n// # Proxy\n//\n// Proxy objects are treated the same way as if they were accessed from ES code in regard to their properties\n// (such as 'length' or [Symbol.iterator]). This means exporting them to slice types works, however\n// exporting a proxied Map into a map type does not produce its contents, because the Proxy is not recognised\n// as a Map. Same applies to a proxied Set.\nfunc (r *Runtime) ExportTo(v Value, target interface{}) error {\n\ttval := reflect.ValueOf(target)\n\tif tval.Kind() != reflect.Ptr || tval.IsNil() {\n\t\treturn errors.New(\"target must be a non-nil pointer\")\n\t}\n\treturn r.toReflectValue(v, tval.Elem(), &objectExportCtx{})\n}\n\n// GlobalObject returns the global object.\nfunc (r *Runtime) GlobalObject() *Object {\n\treturn r.globalObject\n}\n\n// Set the specified variable in the global context.\n// Equivalent to running \"name = value\" in non-strict mode.\n// The value is first converted using ToValue().\n// Note, this is not the same as GlobalObject().Set(name, value),\n// because if a global lexical binding (let or const) exists, it is set instead.\nfunc (r *Runtime) Set(name string, value interface{}) error {\n\treturn r.try(func() {\n\t\tname := unistring.NewFromString(name)\n\t\tv := r.ToValue(value)\n\t\tif ref := r.global.stash.getRefByName(name, false); ref != nil {\n\t\t\tref.set(v)\n\t\t} else {\n\t\t\tr.globalObject.self.setOwnStr(name, v, true)\n\t\t}\n\t})\n}\n\n// Get the specified variable in the global context.\n// Equivalent to dereferencing a variable by name in non-strict mode. If variable is not defined returns nil.\n// Note, this is not the same as GlobalObject().Get(name),\n// because if a global lexical binding (let or const) exists, it is used instead.\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (r *Runtime) Get(name string) Value {\n\tn := unistring.NewFromString(name)\n\tif v, exists := r.global.stash.getByName(n); exists {\n\t\treturn v\n\t} else {\n\t\treturn r.globalObject.self.getStr(n, nil)\n\t}\n}\n\n// SetRandSource sets random source for this Runtime. If not called, the default math/rand is used.\nfunc (r *Runtime) SetRandSource(source RandSource) {\n\tr.rand = source\n}\n\n// SetTimeSource sets the current time source for this Runtime.\n// If not called, the default time.Now() is used.\nfunc (r *Runtime) SetTimeSource(now Now) {\n\tr.now = now\n}\n\n// SetParserOptions sets parser options to be used by RunString, RunScript and eval() within the code.\nfunc (r *Runtime) SetParserOptions(opts ...parser.Option) {\n\tr.parserOptions = opts\n}\n\n// SetMaxCallStackSize sets the maximum function call depth. When exceeded, a *StackOverflowError is thrown and\n// returned by RunProgram or by a Callable call. This is useful to prevent memory exhaustion caused by an\n// infinite recursion. The default value is math.MaxInt32.\n// This method (as the rest of the Set* methods) is not safe for concurrent use and may only be called\n// from the vm goroutine or when the vm is not running.\nfunc (r *Runtime) SetMaxCallStackSize(size int) {\n\tr.vm.maxCallStackSize = size\n}\n\n// New is an equivalent of the 'new' operator allowing to call it directly from Go.\nfunc (r *Runtime) New(construct Value, args ...Value) (o *Object, err error) {\n\terr = r.try(func() {\n\t\to = r.builtin_new(r.toObject(construct), args)\n\t})\n\treturn\n}\n\n// Callable represents a JavaScript function that can be called from Go.\ntype Callable func(this Value, args ...Value) (Value, error)\n\n// AssertFunction checks if the Value is a function and returns a Callable.\n// Note, for classes this returns a callable and a 'true', however calling it will always result in a TypeError.\n// For classes use AssertConstructor().\nfunc AssertFunction(v Value) (Callable, bool) {\n\tif obj, ok := v.(*Object); ok {\n\t\tif f, ok := obj.self.assertCallable(); ok {\n\t\t\treturn func(this Value, args ...Value) (ret Value, err error) {\n\t\t\t\terr = obj.runtime.runWrapped(func() {\n\t\t\t\t\tret = f(FunctionCall{\n\t\t\t\t\t\tThis:      this,\n\t\t\t\t\t\tArguments: args,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Constructor is a type that can be used to call constructors. The first argument (newTarget) can be nil\n// which sets it to the constructor function itself.\ntype Constructor func(newTarget *Object, args ...Value) (*Object, error)\n\n// AssertConstructor checks if the Value is a constructor and returns a Constructor.\nfunc AssertConstructor(v Value) (Constructor, bool) {\n\tif obj, ok := v.(*Object); ok {\n\t\tif ctor := obj.self.assertConstructor(); ctor != nil {\n\t\t\treturn func(newTarget *Object, args ...Value) (ret *Object, err error) {\n\t\t\t\terr = obj.runtime.runWrapped(func() {\n\t\t\t\t\tret = ctor(args, newTarget)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (r *Runtime) runWrapped(f func()) (err error) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tif ex := asUncatchableException(x); ex != nil {\n\t\t\t\terr = ex\n\t\t\t\tif len(r.vm.callStack) == 0 {\n\t\t\t\t\tr.leaveAbrupt()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(x)\n\t\t\t}\n\t\t}\n\t}()\n\tex := r.vm.try(f)\n\tif ex != nil {\n\t\terr = ex\n\t}\n\tif len(r.vm.callStack) == 0 {\n\t\tr.leave()\n\t} else {\n\t\tr.vm.clearStack()\n\t}\n\treturn\n}\n\n// IsUndefined returns true if the supplied Value is undefined. Note, it checks against the real undefined, not\n// against the global object's 'undefined' property.\nfunc IsUndefined(v Value) bool {\n\treturn v == _undefined\n}\n\n// IsNull returns true if the supplied Value is null.\nfunc IsNull(v Value) bool {\n\treturn v == _null\n}\n\n// IsNaN returns true if the supplied value is NaN.\nfunc IsNaN(v Value) bool {\n\tf, ok := v.(valueFloat)\n\treturn ok && math.IsNaN(float64(f))\n}\n\n// IsInfinity returns true if the supplied is (+/-)Infinity\nfunc IsInfinity(v Value) bool {\n\treturn v == _positiveInf || v == _negativeInf\n}\n\n// Undefined returns JS undefined value. Note if global 'undefined' property is changed this still returns the original value.\nfunc Undefined() Value {\n\treturn _undefined\n}\n\n// Null returns JS null value.\nfunc Null() Value {\n\treturn _null\n}\n\n// NaN returns a JS NaN value.\nfunc NaN() Value {\n\treturn _NaN\n}\n\n// PositiveInf returns a JS +Inf value.\nfunc PositiveInf() Value {\n\treturn _positiveInf\n}\n\n// NegativeInf returns a JS -Inf value.\nfunc NegativeInf() Value {\n\treturn _negativeInf\n}\n\nfunc tryFunc(f func()) (ret interface{}) {\n\tdefer func() {\n\t\tret = recover()\n\t}()\n\n\tf()\n\treturn\n}\n\n// Try runs a given function catching and returning any JS exception. Use this method to run any code\n// that may throw exceptions (such as Object.Get, Object.String, Object.ToInteger, Object.Export, Runtime.Get, Runtime.InstanceOf, etc.)\n// outside the Runtime execution context (i.e. when calling directly from Go, not from a JS function implemented in Go).\nfunc (r *Runtime) Try(f func()) *Exception {\n\treturn r.vm.try(f)\n}\n\nfunc (r *Runtime) try(f func()) error {\n\tif ex := r.vm.try(f); ex != nil {\n\t\treturn ex\n\t}\n\treturn nil\n}\n\nfunc (r *Runtime) toObject(v Value, args ...interface{}) *Object {\n\tif obj, ok := v.(*Object); ok {\n\t\treturn obj\n\t}\n\tif len(args) > 0 {\n\t\tpanic(r.NewTypeError(args...))\n\t} else {\n\t\tvar s string\n\t\tif v == nil {\n\t\t\ts = \"undefined\"\n\t\t} else {\n\t\t\ts = v.String()\n\t\t}\n\t\tpanic(r.NewTypeError(\"Value is not an object: %s\", s))\n\t}\n}\n\nfunc (r *Runtime) speciesConstructor(o, defaultConstructor *Object) func(args []Value, newTarget *Object) *Object {\n\tc := o.self.getStr(\"constructor\", nil)\n\tif c != nil && c != _undefined {\n\t\tc = r.toObject(c).self.getSym(SymSpecies, nil)\n\t}\n\tif c == nil || c == _undefined || c == _null {\n\t\tc = defaultConstructor\n\t}\n\treturn r.toConstructor(c)\n}\n\nfunc (r *Runtime) speciesConstructorObj(o, defaultConstructor *Object) *Object {\n\tc := o.self.getStr(\"constructor\", nil)\n\tif c != nil && c != _undefined {\n\t\tc = r.toObject(c).self.getSym(SymSpecies, nil)\n\t}\n\tif c == nil || c == _undefined || c == _null {\n\t\treturn defaultConstructor\n\t}\n\tobj := r.toObject(c)\n\tif obj.self.assertConstructor() == nil {\n\t\tpanic(r.NewTypeError(\"Value is not a constructor\"))\n\t}\n\treturn obj\n}\n\nfunc (r *Runtime) returnThis(call FunctionCall) Value {\n\treturn call.This\n}\n\nfunc createDataProperty(o *Object, p Value, v Value) {\n\to.defineOwnProperty(p, PropertyDescriptor{\n\t\tWritable:     FLAG_TRUE,\n\t\tEnumerable:   FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tValue:        v,\n\t}, false)\n}\n\nfunc createDataPropertyOrThrow(o *Object, p Value, v Value) {\n\to.defineOwnProperty(p, PropertyDescriptor{\n\t\tWritable:     FLAG_TRUE,\n\t\tEnumerable:   FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tValue:        v,\n\t}, true)\n}\n\nfunc toPropertyKey(key Value) Value {\n\treturn key.ToString()\n}\n\nfunc (r *Runtime) getVStr(v Value, p unistring.String) Value {\n\to := v.ToObject(r)\n\treturn o.self.getStr(p, v)\n}\n\nfunc (r *Runtime) getV(v Value, p Value) Value {\n\to := v.ToObject(r)\n\treturn o.get(p, v)\n}\n\ntype iteratorRecord struct {\n\titerator *Object\n\tnext     func(FunctionCall) Value\n}\n\nfunc (r *Runtime) getIterator(obj Value, method func(FunctionCall) Value) *iteratorRecord {\n\tif method == nil {\n\t\tmethod = toMethod(r.getV(obj, SymIterator))\n\t\tif method == nil {\n\t\t\tpanic(r.NewTypeError(\"object is not iterable\"))\n\t\t}\n\t}\n\n\titer := r.toObject(method(FunctionCall{\n\t\tThis: obj,\n\t}))\n\n\tvar next func(FunctionCall) Value\n\n\tif obj, ok := iter.self.getStr(\"next\", nil).(*Object); ok {\n\t\tif call, ok := obj.self.assertCallable(); ok {\n\t\t\tnext = call\n\t\t}\n\t}\n\n\treturn &iteratorRecord{\n\t\titerator: iter,\n\t\tnext:     next,\n\t}\n}\n\nfunc iteratorComplete(iterResult *Object) bool {\n\treturn nilSafe(iterResult.self.getStr(\"done\", nil)).ToBoolean()\n}\n\nfunc iteratorValue(iterResult *Object) Value {\n\treturn nilSafe(iterResult.self.getStr(\"value\", nil))\n}\n\nfunc (ir *iteratorRecord) iterate(step func(Value)) {\n\tr := ir.iterator.runtime\n\tfor {\n\t\tif ir.next == nil {\n\t\t\tpanic(r.NewTypeError(\"iterator.next is missing or not a function\"))\n\t\t}\n\t\tres := r.toObject(ir.next(FunctionCall{This: ir.iterator}))\n\t\tif iteratorComplete(res) {\n\t\t\tbreak\n\t\t}\n\t\tvalue := iteratorValue(res)\n\t\tret := tryFunc(func() {\n\t\t\tstep(value)\n\t\t})\n\t\tif ret != nil {\n\t\t\t_ = tryFunc(func() {\n\t\t\t\tir.returnIter()\n\t\t\t})\n\t\t\tpanic(ret)\n\t\t}\n\t}\n}\n\nfunc (ir *iteratorRecord) step() (value Value, ex *Exception) {\n\tr := ir.iterator.runtime\n\tex = r.vm.try(func() {\n\t\tres := r.toObject(ir.next(FunctionCall{This: ir.iterator}))\n\t\tdone := iteratorComplete(res)\n\t\tif !done {\n\t\t\tvalue = iteratorValue(res)\n\t\t} else {\n\t\t\tir.close()\n\t\t}\n\t})\n\treturn\n}\n\nfunc (ir *iteratorRecord) returnIter() {\n\tif ir.iterator == nil {\n\t\treturn\n\t}\n\tretMethod := toMethod(ir.iterator.self.getStr(\"return\", nil))\n\tif retMethod != nil {\n\t\tir.iterator.runtime.toObject(retMethod(FunctionCall{This: ir.iterator}))\n\t}\n\tir.iterator = nil\n\tir.next = nil\n}\n\nfunc (ir *iteratorRecord) close() {\n\tir.iterator = nil\n\tir.next = nil\n}\n\n// ForOf is a Go equivalent of for-of loop. The function panics if an exception is thrown at any point\n// while iterating, including if the supplied value is not iterable\n// (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol).\n// When using outside of Runtime.Run (i.e. when calling directly from Go code, not from a JS function implemented\n// in Go) it must be enclosed in Try. See the example.\nfunc (r *Runtime) ForOf(iterable Value, step func(curValue Value) (continueIteration bool)) {\n\titer := r.getIterator(iterable, nil)\n\tfor {\n\t\tvalue, ex := iter.step()\n\t\tif ex != nil {\n\t\t\tpanic(ex)\n\t\t}\n\t\tif value != nil {\n\t\t\tvar continueIteration bool\n\t\t\tex := r.vm.try(func() {\n\t\t\t\tcontinueIteration = step(value)\n\t\t\t})\n\t\t\tif ex != nil {\n\t\t\t\titer.returnIter()\n\t\t\t\tpanic(ex)\n\t\t\t}\n\t\t\tif !continueIteration {\n\t\t\t\titer.returnIter()\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) createIterResultObject(value Value, done bool) Value {\n\to := r.NewObject()\n\to.self.setOwnStr(\"value\", value, false)\n\to.self.setOwnStr(\"done\", r.toBoolean(done), false)\n\treturn o\n}\n\nfunc (r *Runtime) getHash() *maphash.Hash {\n\tif r.hash == nil {\n\t\tr.hash = &maphash.Hash{}\n\t}\n\treturn r.hash\n}\n\n// called when the top level function returns normally (i.e. control is passed outside the Runtime).\nfunc (r *Runtime) leave() {\n\tvar jobs []func()\n\tfor len(r.jobQueue) > 0 {\n\t\tjobs, r.jobQueue = r.jobQueue, jobs[:0]\n\t\tfor _, job := range jobs {\n\t\t\tjob()\n\t\t}\n\t}\n\tr.jobQueue = nil\n\tr.vm.stack = nil\n}\n\n// called when the top level function returns (i.e. control is passed outside the Runtime) but it was due to an interrupt\nfunc (r *Runtime) leaveAbrupt() {\n\tr.jobQueue = nil\n\tr.ClearInterrupt()\n}\n\nfunc nilSafe(v Value) Value {\n\tif v != nil {\n\t\treturn v\n\t}\n\treturn _undefined\n}\n\nfunc isArray(object *Object) bool {\n\tself := object.self\n\tif proxy, ok := self.(*proxyObject); ok {\n\t\tif proxy.target == nil {\n\t\t\tpanic(typeError(\"Cannot perform 'IsArray' on a proxy that has been revoked\"))\n\t\t}\n\t\treturn isArray(proxy.target)\n\t}\n\tswitch self.className() {\n\tcase classArray:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isRegexp(v Value) bool {\n\tif o, ok := v.(*Object); ok {\n\t\tmatcher := o.self.getSym(SymMatch, nil)\n\t\tif matcher != nil && matcher != _undefined {\n\t\t\treturn matcher.ToBoolean()\n\t\t}\n\t\t_, reg := o.self.(*regexpObject)\n\t\treturn reg\n\t}\n\treturn false\n}\n\nfunc limitCallArgs(call FunctionCall, n int) FunctionCall {\n\tif len(call.Arguments) > n {\n\t\treturn FunctionCall{This: call.This, Arguments: call.Arguments[:n]}\n\t} else {\n\t\treturn call\n\t}\n}\n\nfunc shrinkCap(newSize, oldCap int) int {\n\tif oldCap > 8 {\n\t\tif cap := oldCap / 2; cap >= newSize {\n\t\t\treturn cap\n\t\t}\n\t}\n\treturn oldCap\n}\n\nfunc growCap(newSize, oldSize, oldCap int) int {\n\t// Use the same algorithm as in runtime.growSlice\n\tdoublecap := oldCap + oldCap\n\tif newSize > doublecap {\n\t\treturn newSize\n\t} else {\n\t\tif oldSize < 1024 {\n\t\t\treturn doublecap\n\t\t} else {\n\t\t\tcap := oldCap\n\t\t\t// Check 0 < cap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < cap && cap < newSize {\n\t\t\t\tcap += cap / 4\n\t\t\t}\n\t\t\t// Return the requested cap when\n\t\t\t// the calculation overflowed.\n\t\t\tif cap <= 0 {\n\t\t\t\treturn newSize\n\t\t\t}\n\t\t\treturn cap\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) genId() (ret uint64) {\n\tif r.hash == nil {\n\t\th := r.getHash()\n\t\tr.idSeq = h.Sum64()\n\t}\n\tif r.idSeq == 0 {\n\t\tr.idSeq = 1\n\t}\n\tret = r.idSeq\n\tr.idSeq++\n\treturn\n}\n\nfunc (r *Runtime) setGlobal(name unistring.String, v Value, strict bool) {\n\tif ref := r.global.stash.getRefByName(name, strict); ref != nil {\n\t\tref.set(v)\n\t} else {\n\t\to := r.globalObject.self\n\t\tif strict {\n\t\t\tif o.hasOwnPropertyStr(name) {\n\t\t\t\to.setOwnStr(name, v, true)\n\t\t\t} else {\n\t\t\t\tr.throwReferenceError(name)\n\t\t\t}\n\t\t} else {\n\t\t\to.setOwnStr(name, v, false)\n\t\t}\n\t}\n}\n\nfunc (r *Runtime) trackPromiseRejection(p *Promise, operation PromiseRejectionOperation) {\n\tif r.promiseRejectionTracker != nil {\n\t\tr.promiseRejectionTracker(p, operation)\n\t}\n}\n\nfunc (r *Runtime) callJobCallback(job *jobCallback, this Value, args ...Value) Value {\n\treturn job.callback(FunctionCall{This: this, Arguments: args})\n}\n\nfunc (r *Runtime) invoke(v Value, p unistring.String, args ...Value) Value {\n\to := v.ToObject(r)\n\treturn r.toCallable(o.self.getStr(p, nil))(FunctionCall{This: v, Arguments: args})\n}\n\nfunc (r *Runtime) iterableToList(iterable Value, method func(FunctionCall) Value) []Value {\n\titer := r.getIterator(iterable, method)\n\tvar values []Value\n\titer.iterate(func(item Value) {\n\t\tvalues = append(values, item)\n\t})\n\treturn values\n}\n\nfunc (r *Runtime) putSpeciesReturnThis(o objectImpl) {\n\to._putSym(SymSpecies, &valueProperty{\n\t\tgetterFunc:   r.newNativeFunc(r.returnThis, \"get [Symbol.species]\", 0),\n\t\taccessor:     true,\n\t\tconfigurable: true,\n\t})\n}\n\nfunc strToArrayIdx(s unistring.String) uint32 {\n\tif s == \"\" {\n\t\treturn math.MaxUint32\n\t}\n\tl := len(s)\n\tif s[0] == '0' {\n\t\tif l == 1 {\n\t\t\treturn 0\n\t\t}\n\t\treturn math.MaxUint32\n\t}\n\tvar n uint32\n\tif l < 10 {\n\t\t// guaranteed not to overflow\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif c < '0' || c > '9' {\n\t\t\t\treturn math.MaxUint32\n\t\t\t}\n\t\t\tn = n*10 + uint32(c-'0')\n\t\t}\n\t\treturn n\n\t}\n\tif l > 10 {\n\t\t// guaranteed to overflow\n\t\treturn math.MaxUint32\n\t}\n\tc9 := s[9]\n\tif c9 < '0' || c9 > '9' {\n\t\treturn math.MaxUint32\n\t}\n\tfor i := 0; i < 9; i++ {\n\t\tc := s[i]\n\t\tif c < '0' || c > '9' {\n\t\t\treturn math.MaxUint32\n\t\t}\n\t\tn = n*10 + uint32(c-'0')\n\t}\n\tif n >= math.MaxUint32/10+1 {\n\t\treturn math.MaxUint32\n\t}\n\tn *= 10\n\tn1 := n + uint32(c9-'0')\n\tif n1 < n {\n\t\treturn math.MaxUint32\n\t}\n\n\treturn n1\n}\n\nfunc strToInt32(s unistring.String) (int32, bool) {\n\tif s == \"\" {\n\t\treturn -1, false\n\t}\n\tneg := s[0] == '-'\n\tif neg {\n\t\ts = s[1:]\n\t}\n\tl := len(s)\n\tif s[0] == '0' {\n\t\tif l == 1 {\n\t\t\treturn 0, !neg\n\t\t}\n\t\treturn -1, false\n\t}\n\tvar n uint32\n\tif l < 10 {\n\t\t// guaranteed not to overflow\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif c < '0' || c > '9' {\n\t\t\t\treturn -1, false\n\t\t\t}\n\t\t\tn = n*10 + uint32(c-'0')\n\t\t}\n\t} else if l > 10 {\n\t\t// guaranteed to overflow\n\t\treturn -1, false\n\t} else {\n\t\tc9 := s[9]\n\t\tif c9 >= '0' {\n\t\t\tif !neg && c9 > '7' || c9 > '8' {\n\t\t\t\t// guaranteed to overflow\n\t\t\t\treturn -1, false\n\t\t\t}\n\t\t\tfor i := 0; i < 9; i++ {\n\t\t\t\tc := s[i]\n\t\t\t\tif c < '0' || c > '9' {\n\t\t\t\t\treturn -1, false\n\t\t\t\t}\n\t\t\t\tn = n*10 + uint32(c-'0')\n\t\t\t}\n\t\t\tif n >= math.MaxInt32/10+1 {\n\t\t\t\t// valid number, but it overflows integer\n\t\t\t\treturn 0, false\n\t\t\t}\n\t\t\tn = n*10 + uint32(c9-'0')\n\t\t} else {\n\t\t\treturn -1, false\n\t\t}\n\t}\n\tif neg {\n\t\treturn int32(-n), true\n\t}\n\treturn int32(n), true\n}\n\nfunc strToInt64(s unistring.String) (int64, bool) {\n\tif s == \"\" {\n\t\treturn -1, false\n\t}\n\tneg := s[0] == '-'\n\tif neg {\n\t\ts = s[1:]\n\t}\n\tl := len(s)\n\tif s[0] == '0' {\n\t\tif l == 1 {\n\t\t\treturn 0, !neg\n\t\t}\n\t\treturn -1, false\n\t}\n\tvar n uint64\n\tif l < 19 {\n\t\t// guaranteed not to overflow\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif c < '0' || c > '9' {\n\t\t\t\treturn -1, false\n\t\t\t}\n\t\t\tn = n*10 + uint64(c-'0')\n\t\t}\n\t} else if l > 19 {\n\t\t// guaranteed to overflow\n\t\treturn -1, false\n\t} else {\n\t\tc18 := s[18]\n\t\tif c18 >= '0' {\n\t\t\tif !neg && c18 > '7' || c18 > '8' {\n\t\t\t\t// guaranteed to overflow\n\t\t\t\treturn -1, false\n\t\t\t}\n\t\t\tfor i := 0; i < 18; i++ {\n\t\t\t\tc := s[i]\n\t\t\t\tif c < '0' || c > '9' {\n\t\t\t\t\treturn -1, false\n\t\t\t\t}\n\t\t\t\tn = n*10 + uint64(c-'0')\n\t\t\t}\n\t\t\tif n >= math.MaxInt64/10+1 {\n\t\t\t\t// valid number, but it overflows integer\n\t\t\t\treturn 0, false\n\t\t\t}\n\t\t\tn = n*10 + uint64(c18-'0')\n\t\t} else {\n\t\t\treturn -1, false\n\t\t}\n\t}\n\tif neg {\n\t\treturn int64(-n), true\n\t}\n\treturn int64(n), true\n}\n\nfunc strToInt(s unistring.String) (int, bool) {\n\tif bits.UintSize == 32 {\n\t\tn, ok := strToInt32(s)\n\t\treturn int(n), ok\n\t}\n\tn, ok := strToInt64(s)\n\treturn int(n), ok\n}\n\n// Attempts to convert a string into a canonical integer.\n// On success returns (number, true).\n// If it was a canonical number, but not an integer returns (0, false). This includes -0 and overflows.\n// In all other cases returns (-1, false).\n// See https://262.ecma-international.org/#sec-canonicalnumericindexstring\nfunc strToIntNum(s unistring.String) (int, bool) {\n\tn, ok := strToInt64(s)\n\tif n == 0 {\n\t\treturn 0, ok\n\t}\n\tif ok && n >= -maxInt && n <= maxInt {\n\t\tif bits.UintSize == 32 {\n\t\t\tif n > math.MaxInt32 || n < math.MinInt32 {\n\t\t\t\treturn 0, false\n\t\t\t}\n\t\t}\n\t\treturn int(n), true\n\t}\n\tstr := stringValueFromRaw(s)\n\tif str.ToNumber().toString().SameAs(str) {\n\t\treturn 0, false\n\t}\n\treturn -1, false\n}\n\nfunc strToGoIdx(s unistring.String) int {\n\tif n, ok := strToInt(s); ok {\n\t\treturn n\n\t}\n\treturn -1\n}\n\nfunc strToIdx64(s unistring.String) int64 {\n\tif n, ok := strToInt64(s); ok {\n\t\treturn n\n\t}\n\treturn -1\n}\n\nfunc assertCallable(v Value) (func(FunctionCall) Value, bool) {\n\tif obj, ok := v.(*Object); ok {\n\t\treturn obj.self.assertCallable()\n\t}\n\treturn nil, false\n}\n\n// InstanceOf is an equivalent of \"left instanceof right\".\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (r *Runtime) InstanceOf(left Value, right *Object) (res bool) {\n\treturn instanceOfOperator(left, right)\n}\n\nfunc (r *Runtime) methodProp(f func(FunctionCall) Value, name unistring.String, nArgs int) Value {\n\treturn valueProp(r.newNativeFunc(f, name, nArgs), true, false, true)\n}\n\nfunc (r *Runtime) getPrototypeFromCtor(newTarget, defCtor, defProto *Object) *Object {\n\tif newTarget == defCtor {\n\t\treturn defProto\n\t}\n\tproto := newTarget.self.getStr(\"prototype\", nil)\n\tif obj, ok := proto.(*Object); ok {\n\t\treturn obj\n\t}\n\treturn defProto\n}\n"
        },
        {
          "name": "runtime_test.go",
          "type": "blob",
          "size": 59.9833984375,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/dop251/goja/parser\"\n)\n\nfunc TestGlobalObjectProto(t *testing.T) {\n\tconst SCRIPT = `\n\tthis instanceof Object\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestUnicodeString(t *testing.T) {\n\tconst SCRIPT = `\n\tvar s = \"\";\n\ts.length === 4 && s[1] === \"\";\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc Test2TierHierarchyProp(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = {};\n\tObject.defineProperty(a, \"test\", {\n\t\tvalue: 42,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: true\n\t});\n\tvar b = Object.create(a);\n\tvar c = Object.create(b);\n\tc.test = 43;\n\tc.test === 42 && !b.hasOwnProperty(\"test\");\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestConstStringIter(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar count = 0;\n\n\tfor (var i in \"1234\") {\n    \t\tfor (var j in \"1234567\") {\n        \t\tcount++\n    \t\t}\n\t}\n\n\tcount;\n\t`\n\n\ttestScript(SCRIPT, intToValue(28), t)\n}\n\nfunc TestUnicodeConcat(t *testing.T) {\n\tconst SCRIPT = `\n\n\tvar s = \"\";\n\tvar s1 = \"test\";\n\tvar s2 = \"\";\n\n\ts.concat(s1) === \"test\" && s.concat(s1, s2) === \"test\" && s1.concat(s, s2) === \"test\"\n\t\t&& s.concat(s2) === \"\";\n\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestIndexOf(t *testing.T) {\n\tconst SCRIPT = `\n\n\t\"abc\".indexOf(\"\", 4)\n\t`\n\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestUnicodeIndexOf(t *testing.T) {\n\tconst SCRIPT = `\n\t\"\".indexOf(\"\", 1) === 2 && ''.indexOf('') === 1\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestLastIndexOf(t *testing.T) {\n\tconst SCRIPT = `\n\n\t\"abcabab\".lastIndexOf(\"ab\", 3)\n\t`\n\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestUnicodeLastIndexOf(t *testing.T) {\n\tconst SCRIPT = `\n\t\"\".lastIndexOf(\"\", 3)\n\t`\n\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestUnicodeLastIndexOf1(t *testing.T) {\n\tconst SCRIPT = `\n\t\"abcde\".lastIndexOf(\"cd\");\n\t`\n\n\ttestScript(SCRIPT, intToValue(3), t)\n}\n\nfunc TestNumber(t *testing.T) {\n\tconst SCRIPT = `\n\t(new Number(100111122133144155)).toString()\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"100111122133144160\"), t)\n}\n\nfunc TestFractionalNumberToStringRadix(t *testing.T) {\n\tconst SCRIPT = `\n\t(new Number(123.456)).toString(36)\n\t`\n\n\ttestScript(SCRIPT, asciiString(\"3f.gez4w97ry\"), t)\n}\n\nfunc TestNumberFormatRounding(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue((123.456).toExponential(undefined), \"1.23456e+2\", \"undefined\");\n\tassert.sameValue((0.000001).toPrecision(2), \"0.0000010\")\n\tassert.sameValue((-7).toPrecision(1), \"-7\");\n\tassert.sameValue((-42).toPrecision(1), \"-4e+1\");\n\tassert.sameValue((0.000001).toPrecision(1), \"0.000001\");\n\tassert.sameValue((123.456).toPrecision(1), \"1e+2\", \"1\");\n\tassert.sameValue((123.456).toPrecision(2), \"1.2e+2\", \"2\");\n\n\tvar n = new Number(\"0.000000000000000000001\"); // 1e-21\n\tassert.sameValue((n).toPrecision(1), \"1e-21\");\n\tassert.sameValue((25).toExponential(0), \"3e+1\");\n\tassert.sameValue((-25).toExponential(0), \"-3e+1\");\n\tassert.sameValue((12345).toExponential(3), \"1.235e+4\");\n\tassert.sameValue((25.5).toFixed(0), \"26\");\n\tassert.sameValue((-25.5).toFixed(0), \"-26\");\n\tassert.sameValue((99.9).toFixed(0), \"100\");\n\tassert.sameValue((99.99).toFixed(1), \"100.0\");\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestBinOctalNumbers(t *testing.T) {\n\tconst SCRIPT = `\n\t0b111;\n\t`\n\n\ttestScript(SCRIPT, valueInt(7), t)\n}\n\nfunc TestSetFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tsum(40, 2);\n\t`\n\tr := New()\n\terr := r.Set(\"sum\", func(call FunctionCall) Value {\n\t\treturn r.ToValue(call.Argument(0).ToInteger() + call.Argument(1).ToInteger())\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i := v.ToInteger(); i != 42 {\n\t\tt.Fatalf(\"Expected 42, got: %d\", i)\n\t}\n}\n\nfunc ExampleRuntime_Set_lexical() {\n\tr := New()\n\t_, err := r.RunString(\"let x\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = r.Set(\"x\", 1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Print(r.Get(\"x\"), r.GlobalObject().Get(\"x\"))\n\t// Output: 1 <nil>\n}\n\nfunc TestRecursiveRun(t *testing.T) {\n\t// Make sure that a recursive call to Run*() correctly sets the environment and no stash or stack\n\t// corruptions occur.\n\tvm := New()\n\tvm.Set(\"f\", func() (Value, error) {\n\t\treturn vm.RunString(\"let x = 1; { let z = 100, z1 = 200, z2 = 300, z3 = 400; x = x + z3} x;\")\n\t})\n\tres, err := vm.RunString(`\n\tfunction f1() {\n\t\tlet x = 2;\n\t\teval('');\n\t\t{\n\t\t\tlet y = 3;\n\t\t\tlet res = f();\n\t\t\tif (x !== 2) { // check for stash corruption\n\t\t\t\tthrow new Error(\"x=\"+x);\n\t\t\t}\n\t\t\tif (y !== 3) { // check for stack corruption\n\t\t\t\tthrow new Error(\"y=\"+y);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tf1();\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.SameAs(valueInt(401)) {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestRecursiveRunWithNArgs(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f\", func() (Value, error) {\n\t\treturn vm.RunString(`\n\t\t{\n\t\t\tlet a = 0;\n\t\t\tlet b = 1;\n\t\t\ta = 2; // this used to to corrupt b, because its location on the stack was off by vm.args (1 in our case)\n\t\t\tb;\n\t\t}\n\t`)\n\t})\n\t_, err := vm.RunString(`\n\t\t(function(arg) { // need an ES function call with an argument to set vm.args\n\t\t\tlet res = f();\n\t\t\tif (res !== 1) {\n\t\t\t\tthrow new Error(res);\n\t\t\t}\n\t\t})(123);\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRecursiveRunCallee(t *testing.T) {\n\t// Make sure that a recursive call to Run*() correctly sets the callee (i.e. stack[sb-1])\n\tvm := New()\n\tvm.Set(\"f\", func() (Value, error) {\n\t\treturn vm.RunString(\"this; (() => 1)()\")\n\t})\n\tres, err := vm.RunString(`\n\t\tf(123, 123);\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.SameAs(valueInt(1)) {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestObjectGetSet(t *testing.T) {\n\tconst SCRIPT = `\n\t\tinput.test++;\n\t\tinput;\n\t`\n\tr := New()\n\to := r.NewObject()\n\to.Set(\"test\", 42)\n\tr.Set(\"input\", o)\n\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif o1, ok := v.(*Object); ok {\n\t\tif v1 := o1.Get(\"test\"); v1.Export() != int64(43) {\n\t\t\tt.Fatalf(\"Unexpected test value: %v (%T)\", v1, v1.Export())\n\t\t}\n\t}\n}\n\nfunc TestThrowFromNativeFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tvar thrown;\n\ttry {\n\t\tf();\n\t} catch (e) {\n\t\tthrown = e;\n\t}\n\tthrown;\n\t`\n\tr := New()\n\tr.Set(\"f\", func(call FunctionCall) Value {\n\t\tpanic(r.ToValue(\"testError\"))\n\t})\n\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.Equals(asciiString(\"testError\")) {\n\t\tt.Fatalf(\"Unexpected result: %v\", v)\n\t}\n}\n\nfunc TestSetGoFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tf(40, 2)\n\t`\n\tr := New()\n\tr.Set(\"f\", func(a, b int) int {\n\t\treturn a + b\n\t})\n\n\tv, err := r.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif v.ToInteger() != 42 {\n\t\tt.Fatalf(\"Unexpected result: %v\", v)\n\t}\n}\n\nfunc TestSetFuncVariadic(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f\", func(s string, g ...Value) {\n\t\tsomething := g[0].ToObject(vm).Get(s).ToInteger()\n\t\tif something != 5 {\n\t\t\tt.Fatal()\n\t\t}\n\t})\n\t_, err := vm.RunString(`\n           f(\"something\", {something: 5})\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSetFuncVariadicFuncArg(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f\", func(s string, g ...Value) {\n\t\tif f, ok := AssertFunction(g[0]); ok {\n\t\t\tv, err := f(nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif v != valueTrue {\n\t\t\t\tt.Fatal(v)\n\t\t\t}\n\t\t}\n\t})\n\t_, err := vm.RunString(`\n           f(\"something\", () => true)\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestArgsKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction testArgs2(x, y, z) {\n    \t\t// Properties of the arguments object are enumerable.\n    \t\treturn Object.keys(arguments);\n\t}\n\n\ttestArgs2(1,2).length\n\t`\n\n\ttestScript(SCRIPT, intToValue(2), t)\n}\n\nfunc TestIPowOverflow(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue(Math.pow(65536, 6), 7.922816251426434e+28);\n\tassert.sameValue(Math.pow(10, 19), 1e19);\n\tassert.sameValue(Math.pow(2097151, 3), 9223358842721534000);\n\tassert.sameValue(Math.pow(2097152, 3), 9223372036854776000);\n\tassert.sameValue(Math.pow(-2097151, 3), -9223358842721534000);\n\tassert.sameValue(Math.pow(-2097152, 3), -9223372036854776000);\n\tassert.sameValue(Math.pow(9007199254740992, 0), 1);\n\tassert.sameValue(Math.pow(-9007199254740992, 0), 1);\n\tassert.sameValue(Math.pow(0, 0), 1);\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestIPow(t *testing.T) {\n\tif res := ipow(-9223372036854775808, 1); res != -9223372036854775808 {\n\t\tt.Fatal(res)\n\t}\n\n\tif res := ipow(9223372036854775807, 1); res != 9223372036854775807 {\n\t\tt.Fatal(res)\n\t}\n\n\tif res := ipow(-9223372036854775807, 1); res != -9223372036854775807 {\n\t\tt.Fatal(res)\n\t}\n\n\tif res := ipow(9223372036854775807, 0); res != 1 {\n\t\tt.Fatal(res)\n\t}\n\n\tif res := ipow(-9223372036854775807, 0); res != 1 {\n\t\tt.Fatal(res)\n\t}\n\n\tif res := ipow(-9223372036854775808, 0); res != 1 {\n\t\tt.Fatal(res)\n\t}\n}\n\nfunc TestInterrupt(t *testing.T) {\n\tconst SCRIPT = `\n\tvar i = 0;\n\tfor (;;) {\n\t\ti++;\n\t}\n\t`\n\n\tvm := New()\n\ttime.AfterFunc(200*time.Millisecond, func() {\n\t\tvm.Interrupt(\"halt\")\n\t})\n\n\t_, err := vm.RunString(SCRIPT)\n\tif err == nil {\n\t\tt.Fatal(\"Err is nil\")\n\t}\n}\n\nfunc TestRuntime_ExportToNumbers(t *testing.T) {\n\tvm := New()\n\tt.Run(\"int8/no overflow\", func(t *testing.T) {\n\t\tvar i8 int8\n\t\terr := vm.ExportTo(vm.ToValue(-123), &i8)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i8 != -123 {\n\t\t\tt.Fatalf(\"i8: %d\", i8)\n\t\t}\n\t})\n\n\tt.Run(\"int8/overflow\", func(t *testing.T) {\n\t\tvar i8 int8\n\t\terr := vm.ExportTo(vm.ToValue(333), &i8)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i8 != 77 {\n\t\t\tt.Fatalf(\"i8: %d\", i8)\n\t\t}\n\t})\n\n\tt.Run(\"int64/uint64\", func(t *testing.T) {\n\t\tvar ui64 uint64\n\t\terr := vm.ExportTo(vm.ToValue(-1), &ui64)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif ui64 != math.MaxUint64 {\n\t\t\tt.Fatalf(\"ui64: %d\", ui64)\n\t\t}\n\t})\n\n\tt.Run(\"int8/float\", func(t *testing.T) {\n\t\tvar i8 int8\n\t\terr := vm.ExportTo(vm.ToValue(333.9234), &i8)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i8 != 77 {\n\t\t\tt.Fatalf(\"i8: %d\", i8)\n\t\t}\n\t})\n\n\tt.Run(\"int8/object\", func(t *testing.T) {\n\t\tvar i8 int8\n\t\terr := vm.ExportTo(vm.NewObject(), &i8)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i8 != 0 {\n\t\t\tt.Fatalf(\"i8: %d\", i8)\n\t\t}\n\t})\n\n\tt.Run(\"int/object_cust_valueOf\", func(t *testing.T) {\n\t\tvar i int\n\t\tobj, err := vm.RunString(`\n\t\t({\n\t\t\tvalueOf: function() { return 42; }\n\t\t})\n\t\t`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = vm.ExportTo(obj, &i)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 42 {\n\t\t\tt.Fatalf(\"i: %d\", i)\n\t\t}\n\t})\n\n\tt.Run(\"float32/no_trunc\", func(t *testing.T) {\n\t\tvar f float32\n\t\terr := vm.ExportTo(vm.ToValue(1.234567), &f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif f != 1.234567 {\n\t\t\tt.Fatalf(\"f: %f\", f)\n\t\t}\n\t})\n\n\tt.Run(\"float32/trunc\", func(t *testing.T) {\n\t\tvar f float32\n\t\terr := vm.ExportTo(vm.ToValue(1.234567890), &f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif f != float32(1.234567890) {\n\t\t\tt.Fatalf(\"f: %f\", f)\n\t\t}\n\t})\n\n\tt.Run(\"float64\", func(t *testing.T) {\n\t\tvar f float64\n\t\terr := vm.ExportTo(vm.ToValue(1.234567), &f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif f != 1.234567 {\n\t\t\tt.Fatalf(\"f: %f\", f)\n\t\t}\n\t})\n\n\tt.Run(\"float32/object\", func(t *testing.T) {\n\t\tvar f float32\n\t\terr := vm.ExportTo(vm.NewObject(), &f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif f == f { // expecting NaN\n\t\t\tt.Fatalf(\"f: %f\", f)\n\t\t}\n\t})\n\n\tt.Run(\"float64/object\", func(t *testing.T) {\n\t\tvar f float64\n\t\terr := vm.ExportTo(vm.NewObject(), &f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif f == f { // expecting NaN\n\t\t\tt.Fatalf(\"f: %f\", f)\n\t\t}\n\t})\n\n}\n\nfunc TestRuntime_ExportToSlice(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [1, 2, 3];\n\ta;\n\t`\n\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar a []string\n\terr = vm.ExportTo(v, &a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif l := len(a); l != 3 {\n\t\tt.Fatalf(\"Unexpected len: %d\", l)\n\t}\n\tif a[0] != \"1\" || a[1] != \"2\" || a[2] != \"3\" {\n\t\tt.Fatalf(\"Unexpected value: %+v\", a)\n\t}\n}\n\nfunc TestRuntime_ExportToMap(t *testing.T) {\n\tconst SCRIPT = `\n\tvar m = {\n\t\t\"0\": 1,\n\t\t\"1\": 2,\n\t\t\"2\": 3,\n\t}\n\tm;\n\t`\n\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar m map[int]string\n\terr = vm.ExportTo(v, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif l := len(m); l != 3 {\n\t\tt.Fatalf(\"Unexpected len: %d\", l)\n\t}\n\tif m[0] != \"1\" || m[1] != \"2\" || m[2] != \"3\" {\n\t\tt.Fatalf(\"Unexpected value: %+v\", m)\n\t}\n}\n\nfunc TestRuntime_ExportToMap1(t *testing.T) {\n\tconst SCRIPT = `\n\tvar m = {\n\t\t\"0\": 1,\n\t\t\"1\": 2,\n\t\t\"2\": 3,\n\t}\n\tm;\n\t`\n\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar m map[string]string\n\terr = vm.ExportTo(v, &m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif l := len(m); l != 3 {\n\t\tt.Fatalf(\"Unexpected len: %d\", l)\n\t}\n\tif m[\"0\"] != \"1\" || m[\"1\"] != \"2\" || m[\"2\"] != \"3\" {\n\t\tt.Fatalf(\"Unexpected value: %+v\", m)\n\t}\n}\n\nfunc TestRuntime_ExportToStruct(t *testing.T) {\n\tconst SCRIPT = `\n\tvar m = {\n\t\tTest: 1,\n\t}\n\tm;\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar o testGoReflectMethod_O\n\terr = vm.ExportTo(v, &o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o.Test != \"1\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", o.Test)\n\t}\n\n}\n\nfunc TestRuntime_ExportToStructPtr(t *testing.T) {\n\tconst SCRIPT = `\n\tvar m = {\n\t\tTest: 1,\n\t}\n\tm;\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar o *testGoReflectMethod_O\n\terr = vm.ExportTo(v, &o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o.Test != \"1\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", o.Test)\n\t}\n\n}\n\nfunc TestRuntime_ExportToStructAnonymous(t *testing.T) {\n\ttype BaseTestStruct struct {\n\t\tA int64\n\t\tB int64\n\t}\n\n\ttype TestStruct struct {\n\t\tBaseTestStruct\n\t\tC string\n\t}\n\n\tconst SCRIPT = `\n\tvar m = {\n\t\tA: 1,\n\t\tB: 2,\n\t\tC: \"testC\"\n\t}\n\tm;\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest := &TestStruct{}\n\terr = vm.ExportTo(v, test)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif test.A != 1 {\n\t\tt.Fatalf(\"Unexpected value: '%d'\", test.A)\n\t}\n\tif test.B != 2 {\n\t\tt.Fatalf(\"Unexpected value: '%d'\", test.B)\n\t}\n\tif test.C != \"testC\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", test.C)\n\t}\n\n}\n\nfunc TestRuntime_ExportToStructFromPtr(t *testing.T) {\n\tvm := New()\n\tv := vm.ToValue(&testGoReflectMethod_O{\n\t\tfield: \"5\",\n\t\tTest:  \"12\",\n\t})\n\n\tvar o testGoReflectMethod_O\n\terr := vm.ExportTo(v, &o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o.Test != \"12\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", o.Test)\n\t}\n\tif o.field != \"5\" {\n\t\tt.Fatalf(\"Unexpected value for field: '%s'\", o.field)\n\t}\n}\n\nfunc TestRuntime_ExportToStructWithPtrValues(t *testing.T) {\n\ttype BaseTestStruct struct {\n\t\tA int64\n\t\tB *int64\n\t}\n\n\ttype TestStruct2 struct {\n\t\tE string\n\t}\n\n\ttype TestStruct struct {\n\t\tBaseTestStruct\n\t\tC *string\n\t\tD *TestStruct2\n\t}\n\n\tconst SCRIPT = `\n\tvar m = {\n\t\tA: 1,\n\t\tB: 2,\n\t\tC: \"testC\",\n\t\tD: {\n\t\t\tE: \"testE\",\n\t\t}\n\t}\n\tm;\n\t`\n\tvm := New()\n\tv, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest := &TestStruct{}\n\terr = vm.ExportTo(v, test)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif test.A != 1 {\n\t\tt.Fatalf(\"Unexpected value: '%d'\", test.A)\n\t}\n\tif test.B == nil || *test.B != 2 {\n\t\tt.Fatalf(\"Unexpected value: '%v'\", test.B)\n\t}\n\tif test.C == nil || *test.C != \"testC\" {\n\t\tt.Fatalf(\"Unexpected value: '%v'\", test.C)\n\t}\n\tif test.D == nil || test.D.E != \"testE\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", test.D.E)\n\t}\n\n}\n\nfunc TestRuntime_ExportToTime(t *testing.T) {\n\tconst SCRIPT = `\n\tvar dateStr = \"2018-08-13T15:02:13+02:00\";\n\tvar str = \"test123\";\n\t`\n\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar ti time.Time\n\terr = vm.ExportTo(vm.Get(\"dateStr\"), &ti)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif ti.Format(time.RFC3339) != \"2018-08-13T15:02:13+02:00\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", ti.Format(time.RFC3339))\n\t}\n\n\terr = vm.ExportTo(vm.Get(\"str\"), &ti)\n\tif err == nil {\n\t\tt.Fatal(\"Expected err to not be nil\")\n\t}\n\n\tvar str string\n\terr = vm.ExportTo(vm.Get(\"dateStr\"), &str)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif str != \"2018-08-13T15:02:13+02:00\" {\n\t\tt.Fatalf(\"Unexpected value: '%s'\", str)\n\t}\n\n\td, err := vm.RunString(`new Date(1000)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tti = time.Time{}\n\terr = vm.ExportTo(d, &ti)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif ti.UnixNano() != 1000*1e6 {\n\t\tt.Fatal(ti)\n\t}\n\tif ti.Location() != time.Local {\n\t\tt.Fatalf(\"Wrong location: %v\", ti)\n\t}\n}\n\nfunc ExampleRuntime_ExportTo_func() {\n\tconst SCRIPT = `\n\tfunction f(param) {\n\t\treturn +param + 2;\n\t}\n\t`\n\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar fn func(string) string\n\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(fn(\"40\")) // note, _this_ value in the function will be undefined.\n\t// Output: 42\n}\n\nfunc ExampleRuntime_ExportTo_funcThrow() {\n\tconst SCRIPT = `\n\tfunction f(param) {\n\t\tthrow new Error(\"testing\");\n\t}\n\t`\n\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar fn func(string) (string, error)\n\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t_, err = fn(\"\")\n\n\tfmt.Println(err)\n\t// Output: Error: testing at f (<eval>:3:9(3))\n}\n\nfunc ExampleRuntime_ExportTo_funcVariadic() {\n\tconst SCRIPT = `\n\tfunction f(...args) {\n\t\treturn args.join(\"#\");\n\t}\n\t`\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar fn func(args ...interface{}) string\n\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(fn(\"a\", \"b\", 42))\n\t// Output: a#b#42\n}\n\nfunc TestRuntime_ExportTo_funcVariadic(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(...args) {\n\t\treturn args.join(\"#\");\n\t}\n\t`\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tt.Run(\"no args\", func(t *testing.T) {\n\t\tvar fn func(args ...any) string\n\t\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tres := fn()\n\t\tif res != \"\" {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"non-variadic args\", func(t *testing.T) {\n\t\tvar fn func(firstArg any, args ...any) string\n\t\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tres := fn(\"first\")\n\t\tif res != \"first\" {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n\tt.Run(\"non-variadic and variadic args\", func(t *testing.T) {\n\t\tvar fn func(firstArg any, args ...any) string\n\t\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tres := fn(\"first\", \"second\")\n\t\tif res != \"first#second\" {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n\n}\n\nfunc TestRuntime_ExportToFuncFail(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(param) {\n\t\treturn +param + 2;\n\t}\n\t`\n\n\ttype T struct {\n\t\tField1 int\n\t}\n\n\tvar fn func(string) (T, error)\n\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = vm.ExportTo(vm.Get(\"f\"), &fn)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := fn(\"40\"); err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc TestRuntime_ExportToCallable(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(param) {\n\t\treturn +param + 2;\n\t}\n\t`\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar c Callable\n\terr = vm.ExportTo(vm.Get(\"f\"), &c)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tres, err := c(Undefined(), vm.ToValue(\"40\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t} else if !res.StrictEquals(vm.ToValue(42)) {\n\t\tt.Fatalf(\"Unexpected value: %v\", res)\n\t}\n}\n\nfunc TestRuntime_ExportToObject(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {\"test\": 42};\n\to;\n\t`\n\tvm := New()\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar o *Object\n\terr = vm.ExportTo(vm.Get(\"o\"), &o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif v := o.Get(\"test\"); !v.StrictEquals(vm.ToValue(42)) {\n\t\tt.Fatalf(\"Unexpected value: %v\", v)\n\t}\n}\n\nfunc ExampleAssertFunction() {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tfunction sum(a, b) {\n\t\treturn a+b;\n\t}\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsum, ok := AssertFunction(vm.Get(\"sum\"))\n\tif !ok {\n\t\tpanic(\"Not a function\")\n\t}\n\n\tres, err := sum(Undefined(), vm.ToValue(40), vm.ToValue(2))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res)\n\t// Output: 42\n}\n\nfunc TestGoFuncError(t *testing.T) {\n\tconst SCRIPT = `\n\ttry {\n\t\tf();\n\t} catch (e) {\n\t\tif (!(e instanceof GoError)) {\n\t\t\tthrow(e);\n\t\t}\n\t\tif (e.value.Error() !== \"Test\") {\n\t\t\tthrow(\"Unexpected value: \" + e.value.Error());\n\t\t}\n\t}\n\t`\n\n\tf := func() error {\n\t\treturn errors.New(\"Test\")\n\t}\n\n\tvm := New()\n\tvm.Set(\"f\", f)\n\t_, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestToValueNil(t *testing.T) {\n\ttype T struct{}\n\tvar a *T\n\tvm := New()\n\n\tif v := vm.ToValue(nil); !IsNull(v) {\n\t\tt.Fatalf(\"nil: %v\", v)\n\t}\n\n\tif v := vm.ToValue(a); !IsNull(v) {\n\t\tt.Fatalf(\"struct ptr: %v\", v)\n\t}\n\n\tvar m map[string]interface{}\n\tif v := vm.ToValue(m); !IsNull(v) {\n\t\tt.Fatalf(\"map[string]interface{}: %v\", v)\n\t}\n\n\tvar ar []interface{}\n\tif v := vm.ToValue(ar); IsNull(v) {\n\t\tt.Fatalf(\"[]interface{}: %v\", v)\n\t}\n\n\tvar arptr *[]interface{}\n\tif v := vm.ToValue(arptr); !IsNull(v) {\n\t\tt.Fatalf(\"*[]interface{}: %v\", v)\n\t}\n}\n\nfunc TestToValueFloat(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f64\", float64(123))\n\tvm.Set(\"f32\", float32(321))\n\n\tv, err := vm.RunString(\"f64 === 123 && f32 === 321\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v.Export().(bool) != true {\n\t\tt.Fatalf(\"StrictEquals for golang float failed\")\n\t}\n}\n\nfunc TestToValueInterface(t *testing.T) {\n\n\tf := func(i interface{}) bool {\n\t\treturn i == t\n\t}\n\tvm := New()\n\tvm.Set(\"f\", f)\n\tvm.Set(\"t\", t)\n\tv, err := vm.RunString(`f(t)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != valueTrue {\n\t\tt.Fatalf(\"v: %v\", v)\n\t}\n}\n\nfunc TestJSONEscape(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = \"\\\\+1\";\n\tJSON.stringify(a);\n\t`\n\n\ttestScript(SCRIPT, asciiString(`\"\\\\+1\"`), t)\n}\n\nfunc TestJSONObjectInArray(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = \"[{\\\"a\\\":1},{\\\"a\\\":2}]\";\n\tJSON.stringify(JSON.parse(a)) == a;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestJSONQuirkyNumbers(t *testing.T) {\n\tconst SCRIPT = `\n\tvar s;\n\ts = JSON.stringify(NaN);\n\tif (s != \"null\") {\n\t\tthrow new Error(\"NaN: \" + s);\n\t}\n\n\ts = JSON.stringify(Infinity);\n\tif (s != \"null\") {\n\t\tthrow new Error(\"Infinity: \" + s);\n\t}\n\n\ts = JSON.stringify(-Infinity);\n\tif (s != \"null\") {\n\t\tthrow new Error(\"-Infinity: \" + s);\n\t}\n\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestJSONNil(t *testing.T) {\n\tconst SCRIPT = `\n\tJSON.stringify(i);\n\t`\n\n\tvm := New()\n\tvar i interface{}\n\tvm.Set(\"i\", i)\n\tret, err := vm.RunString(SCRIPT)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif ret.String() != \"null\" {\n\t\tt.Fatalf(\"Expected 'null', got: %v\", ret)\n\t}\n}\n\ntype customJsonEncodable struct{}\n\nfunc (*customJsonEncodable) JsonEncodable() interface{} {\n\treturn \"Test\"\n}\n\nfunc TestJsonEncodable(t *testing.T) {\n\tvar s customJsonEncodable\n\n\tvm := New()\n\tvm.Set(\"s\", &s)\n\n\tret, err := vm.RunString(\"JSON.stringify(s)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !ret.StrictEquals(vm.ToValue(\"\\\"Test\\\"\")) {\n\t\tt.Fatalf(\"Expected \\\"Test\\\", got: %v\", ret)\n\t}\n}\n\nfunc TestSortComparatorReturnValues(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [];\n\tfor (var i = 0; i < 12; i++) {\n\t    a[i] = i;\n\t}\n\n\ta.sort(function(x, y) { return y - x });\n\n\tfor (var i = 0; i < 12; i++) {\n\t    if (a[i] !== 11-i) {\n\t\tthrow new Error(\"Value at index \" + i + \" is incorrect: \" + a[i]);\n\t    }\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSortComparatorReturnValueFloats(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [\n\t\t5.97,\n\t\t9.91,\n\t\t4.13,\n\t\t9.28,\n\t\t3.29,\n\t];\n\ta.sort( function(a, b) { return a - b; } );\n\tfor (var i = 1; i < a.length; i++) {\n\t\tif (a[i] < a[i-1]) {\n\t\t\tthrow new Error(\"Array is not sorted: \" + a);\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestSortComparatorReturnValueNegZero(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = [2, 1];\n\ta.sort( function(a, b) { return a > b ? 0 : -0; } );\n\tfor (var i = 1; i < a.length; i++) {\n\t\tif (a[i] < a[i-1]) {\n\t\t\tthrow new Error(\"Array is not sorted: \" + a);\n\t\t}\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestNilApplyArg(t *testing.T) {\n\tconst SCRIPT = `\n\t(function x(a, b) {\n\t\treturn a === undefined && b === 1;\n        }).apply(this, [,1])\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestNilCallArg(t *testing.T) {\n\tconst SCRIPT = `\n\t\"use strict\";\n\tfunction f(a) {\n\t\treturn this === undefined && a === undefined;\n\t}\n\t`\n\tvm := New()\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\tvm.RunProgram(prg)\n\tif f, ok := AssertFunction(vm.Get(\"f\")); ok {\n\t\tv, err := f(nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !v.StrictEquals(valueTrue) {\n\t\t\tt.Fatalf(\"Unexpected result: %v\", v)\n\t\t}\n\t}\n}\n\nfunc TestNullCallArg(t *testing.T) {\n\tconst SCRIPT = `\n\tf(null);\n\t`\n\tvm := New()\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\tvm.Set(\"f\", func(x *int) bool {\n\t\treturn x == nil\n\t})\n\n\tv, err := vm.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !v.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Unexpected result: %v\", v)\n\t}\n}\n\nfunc TestObjectKeys(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = { a: 1, b: 2, c: 3, d: 4 };\n\to;\n\t`\n\n\tvm := New()\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tres, err := vm.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif o, ok := res.(*Object); ok {\n\t\tkeys := o.Keys()\n\t\tif !reflect.DeepEqual(keys, []string{\"a\", \"b\", \"c\", \"d\"}) {\n\t\t\tt.Fatalf(\"Unexpected keys: %v\", keys)\n\t\t}\n\t}\n}\n\nfunc TestReflectCallExtraArgs(t *testing.T) {\n\tconst SCRIPT = `\n\tf(41, \"extra\")\n\t`\n\tf := func(x int) int {\n\t\treturn x + 1\n\t}\n\n\tvm := New()\n\tvm.Set(\"f\", f)\n\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tres, err := vm.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.StrictEquals(intToValue(42)) {\n\t\tt.Fatalf(\"Unexpected result: %v\", res)\n\t}\n}\n\nfunc TestReflectCallNotEnoughArgs(t *testing.T) {\n\tconst SCRIPT = `\n\tf(42)\n\t`\n\tvm := New()\n\n\tf := func(x, y int, z *int, s string) (int, error) {\n\t\tif z != nil {\n\t\t\treturn 0, fmt.Errorf(\"z is not nil\")\n\t\t}\n\t\tif s != \"\" {\n\t\t\treturn 0, fmt.Errorf(\"s is not \\\"\\\"\")\n\t\t}\n\t\treturn x + y, nil\n\t}\n\n\tvm.Set(\"f\", f)\n\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tres, err := vm.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !res.StrictEquals(intToValue(42)) {\n\t\tt.Fatalf(\"Unexpected result: %v\", res)\n\t}\n}\n\nfunc TestReflectCallVariadic(t *testing.T) {\n\tconst SCRIPT = `\n\tvar r = f(\"Hello %s, %d\", \"test\", 42);\n\tif (r !== \"Hello test, 42\") {\n\t\tthrow new Error(\"test 1 has failed: \" + r);\n\t}\n\n\tr = f(\"Hello %s, %s\", \"test\");\n\tif (r !== \"Hello test, %!s(MISSING)\") {\n\t\tthrow new Error(\"test 2 has failed: \" + r);\n\t}\n\n\tr = f();\n\tif (r !== \"\") {\n\t\tthrow new Error(\"test 3 has failed: \" + r);\n\t}\n\n\t`\n\n\tvm := New()\n\tvm.Set(\"f\", fmt.Sprintf)\n\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\t_, err := vm.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReflectNullValueArgument(t *testing.T) {\n\trt := New()\n\trt.Set(\"fn\", func(v Value) {\n\t\tif v == nil {\n\t\t\tt.Error(\"null becomes nil\")\n\t\t}\n\t\tif !IsNull(v) {\n\t\t\tt.Error(\"null is not null\")\n\t\t}\n\t})\n\trt.RunString(`fn(null);`)\n}\n\ntype testNativeConstructHelper struct {\n\trt   *Runtime\n\tbase int64\n\t// any other state\n}\n\nfunc (t *testNativeConstructHelper) calc(call FunctionCall) Value {\n\treturn t.rt.ToValue(t.base + call.Argument(0).ToInteger())\n}\n\nfunc TestNativeConstruct(t *testing.T) {\n\tconst SCRIPT = `\n\tvar f = new F(40);\n\tf instanceof F && f.method() === 42 && f.calc(2) === 42;\n\t`\n\n\trt := New()\n\n\tmethod := func(call FunctionCall) Value {\n\t\treturn rt.ToValue(42)\n\t}\n\n\trt.Set(\"F\", func(call ConstructorCall) *Object { // constructor signature (as opposed to 'func(FunctionCall) Value')\n\t\th := &testNativeConstructHelper{\n\t\t\trt:   rt,\n\t\t\tbase: call.Argument(0).ToInteger(),\n\t\t}\n\t\tcall.This.Set(\"method\", method)\n\t\tcall.This.Set(\"calc\", h.calc)\n\t\treturn nil // or any other *Object which will be used instead of call.This\n\t})\n\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tres, err := rt.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !res.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Unexpected result: %v\", res)\n\t}\n\n\tif fn, ok := AssertFunction(rt.Get(\"F\")); ok {\n\t\tv, err := fn(nil, rt.ToValue(42))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif o, ok := v.(*Object); ok {\n\t\t\tif o.Get(\"method\") == nil {\n\t\t\t\tt.Fatal(\"No method\")\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Not an object\")\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Not a function\")\n\t}\n\n\tresp := &testNativeConstructHelper{}\n\tvalue := rt.ToValue(resp)\n\tif value.Export() != resp {\n\t\tt.Fatal(\"no\")\n\t}\n}\n\nfunc TestCreateObject(t *testing.T) {\n\tconst SCRIPT = `\n\tinst instanceof C;\n\t`\n\n\tr := New()\n\tc := r.ToValue(func(call ConstructorCall) *Object {\n\t\treturn nil\n\t})\n\n\tproto := c.(*Object).Get(\"prototype\").(*Object)\n\n\tinst := r.CreateObject(proto)\n\n\tr.Set(\"C\", c)\n\tr.Set(\"inst\", inst)\n\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tres, err := r.RunProgram(prg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !res.StrictEquals(valueTrue) {\n\t\tt.Fatalf(\"Unexpected result: %v\", res)\n\t}\n}\n\nfunc TestInterruptInWrappedFunction(t *testing.T) {\n\trt := New()\n\tv, err := rt.RunString(`\n\t\tvar fn = function() {\n\t\t\twhile (true) {}\n\t\t};\n\t\tfn;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfn, ok := AssertFunction(v)\n\tif !ok {\n\t\tt.Fatal(\"Not a function\")\n\t}\n\tgo func() {\n\t\t<-time.After(10 * time.Millisecond)\n\t\trt.Interrupt(errors.New(\"hi\"))\n\t}()\n\n\t_, err = fn(nil)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif _, ok := err.(*InterruptedError); !ok {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n}\n\nfunc TestInterruptInWrappedFunction2(t *testing.T) {\n\trt := New()\n\t// this test panics as otherwise goja will recover and possibly loop\n\tvar called bool\n\trt.Set(\"v\", rt.ToValue(func() {\n\t\tif called {\n\t\t\tgo func() {\n\t\t\t\tpanic(\"this should never get called twice\")\n\t\t\t}()\n\t\t}\n\t\tcalled = true\n\t\trt.Interrupt(\"here is the error\")\n\t}))\n\n\trt.Set(\"s\", rt.ToValue(func(a Callable) (Value, error) {\n\t\treturn a(nil)\n\t}))\n\n\trt.Set(\"k\", rt.ToValue(func(e Value) {\n\t\tgo func() {\n\t\t\tpanic(\"this should never get called actually\")\n\t\t}()\n\t}))\n\t_, err := rt.RunString(`\n        Promise.resolve().then(()=>k()); // this should never resolve\n        while(true) {\n            try{\n                s(() =>{\n                    v();\n                })\n                break;\n            } catch (e) {\n                k(e);\n            }\n        }\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"expected error but got no error\")\n\t}\n\tintErr := new(InterruptedError)\n\tif !errors.As(err, &intErr) {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n\tif !strings.Contains(intErr.Error(), \"here is the error\") {\n\t\tt.Fatalf(\"Wrong error message: %q\", intErr.Error())\n\t}\n\t_, err = rt.RunString(`Promise.resolve().then(()=>globalThis.S=5)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts := rt.Get(\"S\")\n\tif s == nil || s.ToInteger() != 5 {\n\t\tt.Fatalf(\"Wrong value for S %v\", s)\n\t}\n}\n\nfunc TestInterruptInWrappedFunction2Recover(t *testing.T) {\n\trt := New()\n\t// this test panics as otherwise goja will recover and possibly loop\n\tvar vCalled int\n\trt.Set(\"v\", rt.ToValue(func() {\n\t\tif vCalled == 0 {\n\t\t\trt.Interrupt(\"here is the error\")\n\t\t}\n\t\tvCalled++\n\t}))\n\n\trt.Set(\"s\", rt.ToValue(func(a Callable) (Value, error) {\n\t\tv, err := a(nil)\n\t\tif err != nil {\n\t\t\tintErr := new(InterruptedError)\n\t\t\tif errors.As(err, &intErr) {\n\t\t\t\trt.ClearInterrupt()\n\t\t\t\treturn nil, errors.New(\"oops we got interrupted let's not that\")\n\t\t\t}\n\t\t}\n\t\treturn v, err\n\t}))\n\tvar kCalled int\n\n\trt.Set(\"k\", rt.ToValue(func(e Value) {\n\t\tkCalled++\n\t}))\n\t_, err := rt.RunString(`\n        Promise.resolve().then(()=>k());\n        while(true) {\n            try{\n                s(() => {\n                    v();\n                })\n                break;\n            } catch (e) {\n                k(e);\n            }\n        }\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif vCalled != 2 {\n\t\tt.Fatalf(\"v was not called exactly twice but %d times\", vCalled)\n\t}\n\tif kCalled != 2 {\n\t\tt.Fatalf(\"k was not called exactly twice but %d times\", kCalled)\n\t}\n\t_, err = rt.RunString(`Promise.resolve().then(()=>globalThis.S=5)`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts := rt.Get(\"S\")\n\tif s == nil || s.ToInteger() != 5 {\n\t\tt.Fatalf(\"Wrong value for S %v\", s)\n\t}\n}\n\nfunc TestInterruptInWrappedFunctionExpectInteruptError(t *testing.T) {\n\trt := New()\n\t// this test panics as otherwise goja will recover and possibly loop\n\trt.Set(\"v\", rt.ToValue(func() {\n\t\trt.Interrupt(\"here is the error\")\n\t}))\n\n\trt.Set(\"s\", rt.ToValue(func(a Callable) (Value, error) {\n\t\treturn a(nil)\n\t}))\n\n\t_, err := rt.RunString(`\n        s(() =>{\n            v();\n        })\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"expected error but got no error\")\n\t}\n\tvar intErr *InterruptedError\n\tif !errors.As(err, &intErr) {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n\tif !strings.Contains(intErr.Error(), \"here is the error\") {\n\t\tt.Fatalf(\"Wrong error message: %q\", intErr.Error())\n\t}\n}\n\nfunc TestInterruptInWrappedFunctionExpectStackOverflowError(t *testing.T) {\n\trt := New()\n\trt.SetMaxCallStackSize(5)\n\t// this test panics as otherwise goja will recover and possibly loop\n\trt.Set(\"v\", rt.ToValue(func() {\n\t\t_, err := rt.RunString(`\n\t\t(function loop() { loop() })();\n\t\t`)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}))\n\n\trt.Set(\"s\", rt.ToValue(func(a Callable) (Value, error) {\n\t\treturn a(nil)\n\t}))\n\n\t_, err := rt.RunString(`\n        s(() =>{\n            v();\n        })\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"expected error but got no error\")\n\t}\n\tvar soErr *StackOverflowError\n\tif !errors.As(err, &soErr) {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n}\n\nfunc TestInterruptWithPromises(t *testing.T) {\n\trt := New()\n\trt.SetMaxCallStackSize(5)\n\t// this test panics as otherwise goja will recover and possibly loop\n\trt.Set(\"abort\", rt.ToValue(func() {\n\t\t// panic(\"waty\")\n\t\trt.Interrupt(\"abort this\")\n\t}))\n\tvar queue = make(chan func() error, 10)\n\trt.Set(\"myPromise\", func() Value {\n\t\tp, resolve, _ := rt.NewPromise()\n\t\tqueue <- func() error {\n\t\t\treturn resolve(\"some value\")\n\t\t}\n\n\t\treturn rt.ToValue(p)\n\t})\n\n\t_, err := rt.RunString(`\n\t\tlet p = myPromise()\n\t\tp.then(() => { abort() });\n\t`)\n\tif err != nil {\n\t\tt.Fatal(\"expected noerror but got error\")\n\t}\n\tf := <-queue\n\terr = f()\n\tif err == nil {\n\t\tt.Fatal(\"expected error but got no error\")\n\t}\n\tt.Log(err)\n\tvar soErr *InterruptedError\n\tif !errors.As(err, &soErr) {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n}\n\nfunc TestRunLoopPreempt(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(\"(function() {for (;;) {}})\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfn, ok := AssertFunction(v)\n\tif !ok {\n\t\tt.Fatal(\"Not a function\")\n\t}\n\n\tgo func() {\n\t\t<-time.After(100 * time.Millisecond)\n\t\truntime.GC() // this hangs if the vm loop does not have any preemption points\n\t\tvm.Interrupt(errors.New(\"hi\"))\n\t}()\n\n\t_, err = fn(nil)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif _, ok := err.(*InterruptedError); !ok {\n\t\tt.Fatalf(\"Wrong error type: %T\", err)\n\t}\n}\n\nfunc TestNaN(t *testing.T) {\n\tif !IsNaN(_NaN) {\n\t\tt.Fatal(\"IsNaN() doesn't detect NaN\")\n\t}\n\tif IsNaN(Undefined()) {\n\t\tt.Fatal(\"IsNaN() says undefined is a NaN\")\n\t}\n\tif !IsNaN(NaN()) {\n\t\tt.Fatal(\"NaN() doesn't return NaN\")\n\t}\n}\n\nfunc TestInf(t *testing.T) {\n\tif !IsInfinity(_positiveInf) {\n\t\tt.Fatal(\"IsInfinity() doesn't detect +Inf\")\n\t}\n\tif !IsInfinity(_negativeInf) {\n\t\tt.Fatal(\"IsInfinity() doesn't detect -Inf\")\n\t}\n\tif IsInfinity(Undefined()) {\n\t\tt.Fatal(\"IsInfinity() says undefined is a Infinity\")\n\t}\n\tif !IsInfinity(PositiveInf()) {\n\t\tt.Fatal(\"PositiveInfinity() doesn't return Inf\")\n\t}\n\tif !IsInfinity(NegativeInf()) {\n\t\tt.Fatal(\"NegativeInfinity() doesn't return Inf\")\n\t}\n}\n\nfunc TestRuntimeNew(t *testing.T) {\n\tvm := New()\n\tv, err := vm.New(vm.Get(\"Number\"), vm.ToValue(\"12345\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif n, ok := v.Export().(int64); ok {\n\t\tif n != 12345 {\n\t\t\tt.Fatalf(\"n: %v\", n)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"v: %T\", v)\n\t}\n}\n\nfunc TestAutoBoxing(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\t'use strict';\n\t\tvar a = 1;\n\t\tvar thrown1 = false;\n\t\tvar thrown2 = false;\n\t\ttry {\n\t\t\ta.test = 42;\n\t\t} catch (e) {\n\t\t\tthrown1 = e instanceof TypeError;\n\t\t}\n\t\ttry {\n\t\t\ta[\"test1\"] = 42;\n\t\t} catch (e) {\n\t\t\tthrown2 = e instanceof TypeError;\n\t\t}\n\t\treturn thrown1 && thrown2;\n\t}\n\tvar a = 1;\n\ta.test = 42; // should not throw\n\ta[\"test1\"] = 42; // should not throw\n\ta.test === undefined && a.test1 === undefined && f();\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestProtoGetter(t *testing.T) {\n\tconst SCRIPT = `\n\t({}).__proto__ === Object.prototype && [].__proto__ === Array.prototype;\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestSymbol1(t *testing.T) {\n\tconst SCRIPT = `\n\t\tSymbol.toPrimitive[Symbol.toPrimitive]() === Symbol.toPrimitive;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestFreezeSymbol(t *testing.T) {\n\tconst SCRIPT = `\n\t\tvar s = Symbol(1);\n\t\tvar o = {};\n\t\to[s] = 42;\n\t\tObject.freeze(o);\n\t\to[s] = 43;\n\t\to[s] === 42 && Object.isFrozen(o);\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestToPropertyKey(t *testing.T) {\n\tconst SCRIPT = `\n\tvar sym = Symbol(42);\n\tvar callCount = 0;\n\n\tvar wrapper = {\n\t  toString: function() {\n\t\tcallCount += 1;\n\t\treturn sym;\n\t  },\n\t  valueOf: function() {\n\t\t$ERROR(\"valueOf() called\");\n\t  }\n\t};\n\n\tvar o = {};\n\to[wrapper] = function() { return \"test\" };\n\tassert.sameValue(o[wrapper], o[sym], \"o[wrapper] === o[sym]\");\n\tassert.sameValue(o[wrapper](), \"test\", \"o[wrapper]()\");\n\tassert.sameValue(o[sym](), \"test\", \"o[sym]()\");\n\n\tvar wrapper1 = {};\n\twrapper1[Symbol.toPrimitive] = function(hint) {\n\t\tif (hint === \"string\" || hint === \"default\") {\n\t\t\treturn \"1\";\n\t\t}\n\t\tif (hint === \"number\") {\n\t\t\treturn 2;\n\t\t}\n\t\t$ERROR(\"Unknown hint value \"+hint);\n\t};\n\tvar a = [];\n\ta[wrapper1] = 42;\n\tassert.sameValue(a[1], 42, \"a[1]\");\n\tassert.sameValue(a[1], a[wrapper1], \"a[1] === a[wrapper1]\");\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestPrimThisValue(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction t() {\n\t\t'use strict';\n\n\t\tBoolean.prototype.toString = function() {\n\t\t  return typeof this;\n\t\t};\n\n\t\tassert.sameValue(true.toLocaleString(), \"boolean\");\n\n\t\tBoolean.prototype[Symbol.iterator] = function() {\n\t\t\treturn [typeof this][Symbol.iterator]();\n\t\t}\n\t\tvar s = new Set(true);\n\t\tassert.sameValue(s.size, 1, \"size\");\n\t\tassert.sameValue(s.has(\"boolean\"), true, \"s.has('boolean')\");\n\t}\n\tt();\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestPrimThisValueGetter(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction t() {\n\t\t'use strict';\n\t\tObject.defineProperty(Boolean.prototype, \"toString\", {\n\t\t  get: function() {\n\t\t\tvar v = typeof this;\n\t\t\treturn function() {\n\t\t\t  return v;\n\t\t\t};\n\t\t  }\n\t\t});\n\n\t\tassert.sameValue(true.toLocaleString(), \"boolean\");\n\t}\n\tt();\n\t`\n\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestObjSetSym(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar sym = Symbol(true);\n\tvar p1 = Object.create(null);\n\tvar p2 = Object.create(p1);\n\t\n\tObject.defineProperty(p1, sym, {\n\tvalue: 42\n\t});\n\t\n\tObject.defineProperty(p2, sym, {\n\tvalue: 43,\n\twritable: true,\n\t});\n\tvar o = Object.create(p2);\n\to[sym] = 44;\n\to[sym];\n\t`\n\ttestScript(SCRIPT, intToValue(44), t)\n}\n\nfunc TestObjSet(t *testing.T) {\n\tconst SCRIPT = `\n\t'use strict';\n\tvar p1 = Object.create(null);\n\tvar p2 = Object.create(p1);\n\t\n\tObject.defineProperty(p1, \"test\", {\n\tvalue: 42\n\t});\n\t\n\tObject.defineProperty(p2, \"test\", {\n\tvalue: 43,\n\twritable: true,\n\t});\n\tvar o = Object.create(p2);\n\to.test = 44;\n\to.test;\n\t`\n\ttestScript(SCRIPT, intToValue(44), t)\n}\n\nfunc TestToValueNilValue(t *testing.T) {\n\tr := New()\n\tvar a Value\n\tr.Set(\"a\", a)\n\tret, err := r.RunString(`\n\t\"\"+a;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !asciiString(\"null\").SameAs(ret) {\n\t\tt.Fatalf(\"ret: %v\", ret)\n\t}\n}\n\nfunc TestDateConversion(t *testing.T) {\n\tnow := time.Now()\n\tvm := New()\n\tval, err := vm.New(vm.Get(\"Date\").ToObject(vm), vm.ToValue(now.UnixNano()/1e6))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvm.Set(\"d\", val)\n\tres, err := vm.RunString(`+d`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exp := res.Export(); exp != now.UnixNano()/1e6 {\n\t\tt.Fatalf(\"Value does not match: %v\", exp)\n\t}\n\tvm.Set(\"goval\", now)\n\tres, err = vm.RunString(`+(new Date(goval.UnixNano()/1e6))`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exp := res.Export(); exp != now.UnixNano()/1e6 {\n\t\tt.Fatalf(\"Value does not match: %v\", exp)\n\t}\n}\n\nfunc TestNativeCtorNewTarget(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction NewTarget() {\n\t}\n\n\tvar o = Reflect.construct(Number, [1], NewTarget);\n\to.__proto__ === NewTarget.prototype && o.toString() === \"[object Number]\";\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestNativeCtorNonNewCall(t *testing.T) {\n\tvm := New()\n\tvm.Set(`Animal`, func(call ConstructorCall) *Object {\n\t\tobj := call.This\n\t\tobj.Set(`name`, call.Argument(0).String())\n\t\tobj.Set(`eat`, func(call FunctionCall) Value {\n\t\t\tself := call.This.(*Object)\n\t\t\treturn vm.ToValue(fmt.Sprintf(\"%s eat\", self.Get(`name`)))\n\t\t})\n\t\treturn nil\n\t})\n\tv, err := vm.RunString(`\n\n\tfunction __extends(d, b){\n\t\tfunction __() {\n\t\t\tthis.constructor = d;\n\t\t}\n\t\td.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t}\n\n\tvar Cat = (function (_super) {\n\t\t__extends(Cat, _super);\n\t\tfunction Cat() {\n\t\t\treturn _super.call(this, \"cat\") || this;\n\t\t}\n\t\treturn Cat;\n\t}(Animal));\n\n\tvar cat = new Cat();\n\tcat instanceof Cat && cat.eat() === \"cat eat\";\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != valueTrue {\n\t\tt.Fatal(v)\n\t}\n}\n\nfunc ExampleNewSymbol() {\n\tsym1 := NewSymbol(\"66\")\n\tsym2 := NewSymbol(\"66\")\n\tfmt.Printf(\"%s %s %v\", sym1, sym2, sym1.Equals(sym2))\n\t// Output: 66 66 false\n}\n\nfunc ExampleObject_SetSymbol() {\n\ttype IterResult struct {\n\t\tDone  bool\n\t\tValue Value\n\t}\n\n\tvm := New()\n\tvm.SetFieldNameMapper(UncapFieldNameMapper()) // to use IterResult\n\n\to := vm.NewObject()\n\to.SetSymbol(SymIterator, func() *Object {\n\t\tcount := 0\n\t\titer := vm.NewObject()\n\t\titer.Set(\"next\", func() IterResult {\n\t\t\tif count < 10 {\n\t\t\t\tcount++\n\t\t\t\treturn IterResult{\n\t\t\t\t\tValue: vm.ToValue(count),\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn IterResult{\n\t\t\t\tDone: true,\n\t\t\t}\n\t\t})\n\t\treturn iter\n\t})\n\tvm.Set(\"o\", o)\n\n\tres, err := vm.RunString(`\n\tvar acc = \"\";\n\tfor (var v of o) {\n\t\tacc += v + \" \";\n\t}\n\tacc;\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res)\n\t// Output: 1 2 3 4 5 6 7 8 9 10\n}\n\nfunc ExampleRuntime_NewArray() {\n\tvm := New()\n\tarray := vm.NewArray(1, 2, true)\n\tvm.Set(\"array\", array)\n\tres, err := vm.RunString(`\n\tvar acc = \"\";\n\tfor (var v of array) {\n\t\tacc += v + \" \";\n\t}\n\tacc;\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res)\n\t// Output: 1 2 true\n}\n\nfunc ExampleRuntime_SetParserOptions() {\n\tvm := New()\n\tvm.SetParserOptions(parser.WithDisableSourceMaps)\n\n\tres, err := vm.RunString(`\n\t\"I did not hang!\";\n//# sourceMappingURL=/dev/zero`)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res.String())\n\t// Output: I did not hang!\n}\n\nfunc TestRuntime_SetParserOptions_Eval(t *testing.T) {\n\tvm := New()\n\tvm.SetParserOptions(parser.WithDisableSourceMaps)\n\n\t_, err := vm.RunString(`\n\teval(\"//# sourceMappingURL=/dev/zero\");\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNativeCallWithRuntimeParameter(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f\", func(_ FunctionCall, r *Runtime) Value {\n\t\tif r == vm {\n\t\t\treturn valueTrue\n\t\t}\n\t\treturn valueFalse\n\t})\n\tret, err := vm.RunString(`f()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif ret != valueTrue {\n\t\tt.Fatal(ret)\n\t}\n}\n\nfunc TestNestedEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {baz: true, foo: true, bar: true};\n\tvar res = \"\";\n\tfor (var i in o) {\n\t\tdelete o.baz;\n\t\tObject.defineProperty(o, \"hidden\", {value: true, configurable: true});\n\t\tfor (var j in o) {\n\t\t\tObject.defineProperty(o, \"0\", {value: true, configurable: true});\n\t\t\tObject.defineProperty(o, \"1\", {value: true, configurable: true});\n\t\t\tfor (var k in o) {}\n\t\t\tres += i + \"-\" + j + \" \";\n\t\t}\n\t}\n\tassert(compareArray(Reflect.ownKeys(o), [\"0\",\"1\",\"foo\",\"bar\",\"hidden\"]), \"keys\");\n\tres;\n\t`\n\ttestScriptWithTestLib(SCRIPT, asciiString(\"baz-foo baz-bar foo-foo foo-bar bar-foo bar-bar \"), t)\n}\n\nfunc TestAbandonedEnumerate(t *testing.T) {\n\tconst SCRIPT = `\n\tvar o = {baz: true, foo: true, bar: true};\n\tvar res = \"\";\n\tfor (var i in o) {\n\t\tdelete o.baz;\n\t\tfor (var j in o) {\n\t\t\tres += i + \"-\" + j + \" \";\n\t\t\tbreak;\n\t\t}\n\t}\n\tres;\n\t`\n\ttestScript(SCRIPT, asciiString(\"baz-foo foo-foo bar-foo \"), t)\n}\n\nfunc TestIterCloseThrows(t *testing.T) {\n\tconst SCRIPT = `\n\tvar returnCount = 0;\n\tvar iterable = {};\n\tvar iterator = {\n\t  next: function() {\n\t\treturn { value: true };\n\t  },\n\t  return: function() {\n\t\treturnCount += 1;\n\t\tthrow new Error();\n\t  }\n\t};\n\titerable[Symbol.iterator] = function() {\n\t  return iterator;\n\t};\n\n\ttry {\n\t\tfor (var i of iterable) {\n\t\t\t\tbreak;\n\t\t}\n\t} catch (e) {};\n\treturnCount;\n\t`\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestDeclareGlobalFunc(t *testing.T) {\n\tconst SCRIPT = `\n\tvar initial;\n\n\tObject.defineProperty(this, 'f', {\n\t  enumerable: true,\n\t  writable: true,\n\t  configurable: false\n\t});\n\n\t(0,eval)('initial = f; function f() { return 2222; }');\n\tvar desc = Object.getOwnPropertyDescriptor(this, \"f\");\n\tassert(desc.enumerable, \"enumerable\");\n\tassert(desc.writable, \"writable\");\n\tassert(!desc.configurable, \"configurable\");\n\tassert.sameValue(initial(), 2222);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestStackOverflowError(t *testing.T) {\n\tvm := New()\n\tvm.SetMaxCallStackSize(3)\n\t_, err := vm.RunString(`\n\tfunction f() {\n\t\tf();\n\t}\n\tf();\n\t`)\n\tif _, ok := err.(*StackOverflowError); !ok {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestStacktraceLocationThrowFromCatch(t *testing.T) {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tfunction main(arg) {\n\t\ttry {\n\t\t\tif (arg === 1) {\n\t\t\t\treturn f1();\n\t\t\t}\n\t\t\tif (arg === 2) {\n\t\t\t\treturn f2();\n\t\t\t}\n\t\t\tif (arg === 3) {\n\t\t\t\treturn f3();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tfunction f1() {}\n\tfunction f2() {\n\t\tthrow new Error();\n\t}\n\tfunction f3() {}\n\tmain(2);\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tstack := err.(*Exception).stack\n\tif len(stack) != 3 {\n\t\tt.Fatalf(\"Unexpected stack len: %v\", stack)\n\t}\n\tif frame := stack[0]; frame.funcName != \"f2\" || frame.pc != 2 {\n\t\tt.Fatalf(\"Unexpected stack frame 0: %#v\", frame)\n\t}\n\tif frame := stack[1]; frame.funcName != \"main\" || frame.pc != 17 {\n\t\tt.Fatalf(\"Unexpected stack frame 1: %#v\", frame)\n\t}\n\tif frame := stack[2]; frame.funcName != \"\" || frame.pc != 7 {\n\t\tt.Fatalf(\"Unexpected stack frame 2: %#v\", frame)\n\t}\n}\n\nfunc TestErrorStackRethrow(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction f(e) {\n\t\tthrow e;\n\t}\n\ttry {\n\t\tf(new Error());\n\t} catch(e) {\n\t\tassertStack(e, [[\"test.js\", \"\", 6, 5]]);\n\t}\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestStacktraceLocationThrowFromGo(t *testing.T) {\n\tvm := New()\n\tf := func() {\n\t\tpanic(vm.ToValue(\"Test\"))\n\t}\n\tvm.Set(\"f\", f)\n\t_, err := vm.RunString(`\n\tfunction main() {\n\t\t(function noop() {})();\n\t\treturn callee();\n\t}\n\tfunction callee() {\n\t\treturn f();\n\t}\n\tmain();\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tstack := err.(*Exception).stack\n\tif len(stack) != 4 {\n\t\tt.Fatalf(\"Unexpected stack len: %v\", stack)\n\t}\n\tif frame := stack[0]; !strings.HasSuffix(frame.funcName.String(), \"TestStacktraceLocationThrowFromGo.func1\") {\n\t\tt.Fatalf(\"Unexpected stack frame 0: %#v\", frame)\n\t}\n\tif frame := stack[1]; frame.funcName != \"callee\" || frame.pc != 2 {\n\t\tt.Fatalf(\"Unexpected stack frame 1: %#v\", frame)\n\t}\n\tif frame := stack[2]; frame.funcName != \"main\" || frame.pc != 6 {\n\t\tt.Fatalf(\"Unexpected stack frame 2: %#v\", frame)\n\t}\n\tif frame := stack[3]; frame.funcName != \"\" || frame.pc != 4 {\n\t\tt.Fatalf(\"Unexpected stack frame 3: %#v\", frame)\n\t}\n}\n\nfunc TestStacktraceLocationThrowNativeInTheMiddle(t *testing.T) {\n\tvm := New()\n\tv, err := vm.RunString(`(function f1() {\n\t\tthrow new Error(\"test\")\n\t})`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar f1 func()\n\terr = vm.ExportTo(v, &f1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tf := func() {\n\t\tf1()\n\t}\n\tvm.Set(\"f\", f)\n\t_, err = vm.RunString(`\n\tfunction main() {\n\t\t(function noop() {})();\n\t\treturn callee();\n\t}\n\tfunction callee() {\n\t\treturn f();\n\t}\n\tmain();\n\t`)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tstack := err.(*Exception).stack\n\tif len(stack) != 5 {\n\t\tt.Fatalf(\"Unexpected stack len: %v\", stack)\n\t}\n\tif frame := stack[0]; frame.funcName != \"f1\" || frame.pc != 7 {\n\t\tt.Fatalf(\"Unexpected stack frame 0: %#v\", frame)\n\t}\n\tif frame := stack[1]; !strings.HasSuffix(frame.funcName.String(), \"TestStacktraceLocationThrowNativeInTheMiddle.func1\") {\n\t\tt.Fatalf(\"Unexpected stack frame 1: %#v\", frame)\n\t}\n\tif frame := stack[2]; frame.funcName != \"callee\" || frame.pc != 2 {\n\t\tt.Fatalf(\"Unexpected stack frame 2: %#v\", frame)\n\t}\n\tif frame := stack[3]; frame.funcName != \"main\" || frame.pc != 6 {\n\t\tt.Fatalf(\"Unexpected stack frame 3: %#v\", frame)\n\t}\n\tif frame := stack[4]; frame.funcName != \"\" || frame.pc != 4 {\n\t\tt.Fatalf(\"Unexpected stack frame 4: %#v\", frame)\n\t}\n}\n\nfunc TestStrToInt64(t *testing.T) {\n\tif _, ok := strToInt64(\"\"); ok {\n\t\tt.Fatal(\"<empty>\")\n\t}\n\tif n, ok := strToInt64(\"0\"); !ok || n != 0 {\n\t\tt.Fatal(\"0\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-0\"); ok {\n\t\tt.Fatal(\"-0\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-1\"); !ok || n != -1 {\n\t\tt.Fatal(\"-1\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"9223372036854775808\"); ok {\n\t\tt.Fatal(\"max+1\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"9223372036854775817\"); ok {\n\t\tt.Fatal(\"9223372036854775817\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-9223372036854775818\"); ok {\n\t\tt.Fatal(\"-9223372036854775818\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"9223372036854775807\"); !ok || n != 9223372036854775807 {\n\t\tt.Fatal(\"max\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-9223372036854775809\"); ok {\n\t\tt.Fatal(\"min-1\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-9223372036854775808\"); !ok || n != -9223372036854775808 {\n\t\tt.Fatal(\"min\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-00\"); ok {\n\t\tt.Fatal(\"-00\", n, ok)\n\t}\n\tif n, ok := strToInt64(\"-01\"); ok {\n\t\tt.Fatal(\"-01\", n, ok)\n\t}\n}\n\nfunc TestStrToInt32(t *testing.T) {\n\tif _, ok := strToInt32(\"\"); ok {\n\t\tt.Fatal(\"<empty>\")\n\t}\n\tif n, ok := strToInt32(\"0\"); !ok || n != 0 {\n\t\tt.Fatal(\"0\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-0\"); ok {\n\t\tt.Fatal(\"-0\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-1\"); !ok || n != -1 {\n\t\tt.Fatal(\"-1\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"2147483648\"); ok {\n\t\tt.Fatal(\"max+1\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"2147483657\"); ok {\n\t\tt.Fatal(\"2147483657\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-2147483658\"); ok {\n\t\tt.Fatal(\"-2147483658\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"2147483647\"); !ok || n != 2147483647 {\n\t\tt.Fatal(\"max\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-2147483649\"); ok {\n\t\tt.Fatal(\"min-1\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-2147483648\"); !ok || n != -2147483648 {\n\t\tt.Fatal(\"min\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-00\"); ok {\n\t\tt.Fatal(\"-00\", n, ok)\n\t}\n\tif n, ok := strToInt32(\"-01\"); ok {\n\t\tt.Fatal(\"-01\", n, ok)\n\t}\n}\n\nfunc TestDestructSymbol(t *testing.T) {\n\tconst SCRIPT = `\n\tvar S = Symbol(\"S\");\n\tvar s, rest;\n\n\t({[S]: s, ...rest} = {[S]: true, test: 1});\n\tassert.sameValue(s, true, \"S\");\n\tassert(deepEqual(rest, {test: 1}), \"rest\");\n\t`\n\ttestScriptWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestAccessorFuncName(t *testing.T) {\n\tconst SCRIPT = `\n\tconst namedSym = Symbol('test262');\n\tconst emptyStrSym = Symbol(\"\");\n\tconst anonSym = Symbol();\n\n\tconst o = {\n\t  get id() {},\n\t  get [anonSym]() {},\n\t  get [namedSym]() {},\n      get [emptyStrSym]() {},\n\t  set id(v) {},\n\t  set [anonSym](v) {},\n\t  set [namedSym](v) {},\n      set [emptyStrSym](v) {}\n\t};\n\n\tlet prop;\n\tprop = Object.getOwnPropertyDescriptor(o, 'id');\n\tassert.sameValue(prop.get.name, 'get id');\n\tassert.sameValue(prop.set.name, 'set id');\n\n\tprop = Object.getOwnPropertyDescriptor(o, anonSym);\n\tassert.sameValue(prop.get.name, 'get ');\n\tassert.sameValue(prop.set.name, 'set ');\n\n\tprop = Object.getOwnPropertyDescriptor(o, emptyStrSym);\n\tassert.sameValue(prop.get.name, 'get []');\n\tassert.sameValue(prop.set.name, 'set []');\n\n\tprop = Object.getOwnPropertyDescriptor(o, namedSym);\n\tassert.sameValue(prop.get.name, 'get [test262]');\n\tassert.sameValue(prop.set.name, 'set [test262]');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestCoverFuncName(t *testing.T) {\n\tconst SCRIPT = `\n\tvar namedSym = Symbol('');\n\tvar anonSym = Symbol();\n\tvar o;\n\n\to = {\n\t  xId: (0, function() {}),\n\t  id: (function() {}),\n      id1: function x() {},\n\t  [anonSym]: (function() {}),\n\t  [namedSym]: (function() {})\n\t};\n\n\tassert(o.xId.name !== 'xId');\n\tassert.sameValue(o.id1.name, 'x'); \n\tassert.sameValue(o.id.name, 'id', 'via IdentifierName');\n\tassert.sameValue(o[anonSym].name, '', 'via anonymous Symbol');\n\tassert.sameValue(o[namedSym].name, '[]', 'via Symbol');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestAnonFuncName(t *testing.T) {\n\tconst SCRIPT = `\n\tconst d = Object.getOwnPropertyDescriptor((function() {}), 'name');\n\td !== undefined && d.value === '';\n\t`\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestStringToBytesConversion(t *testing.T) {\n\tvm := New()\n\tv := vm.ToValue(\"Test\")\n\tvar b []byte\n\terr := vm.ExportTo(v, &b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != \"Test\" {\n\t\tt.Fatal(b)\n\t}\n}\n\nfunc TestPromiseAll(t *testing.T) {\n\tconst SCRIPT = `\nvar p1 = new Promise(function() {});\nvar p2 = new Promise(function() {});\nvar p3 = new Promise(function() {});\nvar callCount = 0;\nvar currentThis = p1;\nvar nextThis = p2;\nvar afterNextThis = p3;\n\np1.then = p2.then = p3.then = function(a, b) {\n  assert.sameValue(typeof a, 'function', 'type of first argument');\n  assert.sameValue(\n    a.length,\n    1,\n    'ES6 25.4.1.3.2: The length property of a promise resolve function is 1.'\n  );\n  assert.sameValue(typeof b, 'function', 'type of second argument');\n  assert.sameValue(\n    b.length,\n    1,\n    'ES6 25.4.1.3.1: The length property of a promise reject function is 1.'\n  );\n  assert.sameValue(arguments.length, 2, '\"then\"\" invoked with two arguments');\n  assert.sameValue(this, currentThis, '\"this\" value');\n\n  currentThis = nextThis;\n  nextThis = afterNextThis;\n  afterNextThis = null;\n\n  callCount += 1;\n};\n\nPromise.all([p1, p2, p3]);\n\nassert.sameValue(callCount, 3, '\"then\"\" invoked once for every iterated value');\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestPromiseExport(t *testing.T) {\n\tvm := New()\n\tp, _, _ := vm.NewPromise()\n\tpv := vm.ToValue(p)\n\tif actual := pv.ExportType(); actual != reflect.TypeOf((*Promise)(nil)) {\n\t\tt.Fatalf(\"Export type: %v\", actual)\n\t}\n\n\tif ev := pv.Export(); ev != p {\n\t\tt.Fatalf(\"Export value: %v\", ev)\n\t}\n}\n\nfunc TestErrorStack(t *testing.T) {\n\tconst SCRIPT = `\n\tconst err = new Error(\"test\");\n\tif (!(\"stack\" in err)) {\n\t\tthrow new Error(\"in\");\n\t}\n\tif (Reflect.ownKeys(err)[0] !== \"stack\") {\n\t\tthrow new Error(\"property order\");\n\t}\n\tconst stack = err.stack;\n\tif (stack !== \"Error: test\\n\\tat test.js:2:14(3)\\n\") {\n\t\tthrow new Error(stack);\n\t}\n\tdelete err.stack;\n\tif (\"stack\" in err) {\n\t\tthrow new Error(\"stack still in err after delete\");\n\t}\n\t`\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestErrorFormatSymbols(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"a\", func() (Value, error) { return nil, errors.New(\"something %s %f\") })\n\t_, err := vm.RunString(\"a()\")\n\tif !strings.Contains(err.Error(), \"something %s %f\") {\n\t\tt.Fatalf(\"Wrong value %q\", err.Error())\n\t}\n}\n\nfunc TestPanicPassthrough(t *testing.T) {\n\tconst panicString = \"Test panic\"\n\tr := New()\n\tr.Set(\"f\", func() {\n\t\tpanic(panicString)\n\t})\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tif x != panicString {\n\t\t\t\tt.Fatalf(\"Wrong panic value: %v\", x)\n\t\t\t}\n\t\t\tif len(r.vm.callStack) > 0 {\n\t\t\t\tt.Fatal(\"vm.callStack is not empty\")\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"No panic\")\n\t\t}\n\t}()\n\t_, _ = r.RunString(\"f()\")\n\tt.Fatal(\"Should not reach here\")\n}\n\nfunc TestSuspendResumeRelStackLen(t *testing.T) {\n\tconst SCRIPT = `\n\tasync function f2() {\n\t\tthrow new Error(\"test\");\n\t}\n\n\tasync function f1() {\n\t\tlet a = [1];\n\t\tfor (let i of a) {\n\t\t\ttry {\n\t\t\t\tawait f2();\n\t\t\t} catch {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync function f() {\n\t\tlet a = [1];\n\t\tfor (let i of a) {\n\t\t\treturn await f1();\n\t\t}\n\t}\n\treturn f();\n\t`\n\ttestAsyncFunc(SCRIPT, valueTrue, t)\n}\n\nfunc TestSuspendResumeStacks(t *testing.T) {\n\tconst SCRIPT = `\nasync function f1() {\n\tthrow new Error();\n}\nasync function f() {\n  try {\n\tawait f1();\n  } catch {}\n}\n\nresult = await f();\n\t`\n\ttestAsyncFunc(SCRIPT, _undefined, t)\n}\n\nfunc TestNestedTopLevelConstructorCall(t *testing.T) {\n\tr := New()\n\tc := func(call ConstructorCall, rt *Runtime) *Object {\n\t\tif _, err := rt.RunString(\"(5)\"); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn nil\n\t}\n\tif err := r.Set(\"C\", c); err != nil {\n\t\tpanic(err)\n\t}\n\tif _, err := r.RunString(\"new C()\"); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestNestedTopLevelConstructorPanicAsync(t *testing.T) {\n\tr := New()\n\tc := func(call ConstructorCall, rt *Runtime) *Object {\n\t\tc, ok := AssertFunction(rt.ToValue(func() {}))\n\t\tif !ok {\n\t\t\tpanic(\"wat\")\n\t\t}\n\t\tif _, err := c(Undefined()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn nil\n\t}\n\tif err := r.Set(\"C\", c); err != nil {\n\t\tpanic(err)\n\t}\n\tif _, err := r.RunString(\"new C()\"); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestAsyncFuncThrow(t *testing.T) {\n\tconst SCRIPT = `\n\tclass TestError extends Error {\n\t}\n\n\tasync function f() {\n\t\tthrow new TestError();\n\t}\n\n\tasync function f1() {\n\t\ttry {\n\t\t\tawait f();\n\t\t} catch (e) {\n\t\t\tassert.sameValue(e.constructor.name, TestError.name);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\"No exception was thrown\");\n\t}\n\tawait f1();\n\treturn undefined;\n\t`\n\ttestAsyncFuncWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestAsyncStacktrace(t *testing.T) {\n\t// Do not reformat, assertions depend on the line and column numbers\n\tconst SCRIPT = `\n\tlet ex;\n\tasync function foo(x) {\n\t  await bar(x);\n\t}\n\n\tasync function bar(x) {\n\t  await x;\n\t  throw new Error(\"Let's have a look...\");\n\t}\n\n\ttry {\n\t\tawait foo(1);\n\t} catch (e) {\n\t\tassertStack(e, [\n\t\t\t[\"test.js\", \"bar\", 9, 10],\n\t\t\t[\"test.js\", \"foo\", 4, 13],\n\t\t\t[\"test.js\", \"test\", 13, 12],\n\t\t]);\n\t}\n\t`\n\ttestAsyncFuncWithTestLibX(SCRIPT, _undefined, t)\n}\n\nfunc TestPanicPropagation(t *testing.T) {\n\tr := New()\n\tr.Set(\"doPanic\", func() {\n\t\tpanic(true)\n\t})\n\tv, err := r.RunString(`(function() {\n\t\tdoPanic();\n\t})`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf, ok := AssertFunction(v)\n\tif !ok {\n\t\tt.Fatal(\"not a function\")\n\t}\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tif x != true {\n\t\t\t\tt.Fatal(\"Invalid panic value\")\n\t\t\t}\n\t\t}\n\t}()\n\t_, _ = f(nil)\n\tt.Fatal(\"Expected panic\")\n}\n\nfunc TestAwaitInParameters(t *testing.T) {\n\t_, err := Compile(\"\", `\n\tasync function g() {\n\t    async function inner(a = 1 + await 1) {\n\t    }\n\t}\n\t`, false)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n}\n\nfunc ExampleRuntime_ForOf() {\n\tr := New()\n\tv, err := r.RunString(`\n\t\tnew Map().set(\"a\", 1).set(\"b\", 2);\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar sb strings.Builder\n\tex := r.Try(func() {\n\t\tr.ForOf(v, func(v Value) bool {\n\t\t\to := v.ToObject(r)\n\t\t\tkey := o.Get(\"0\")\n\t\t\tvalue := o.Get(\"1\")\n\n\t\t\tsb.WriteString(key.String())\n\t\t\tsb.WriteString(\"=\")\n\t\t\tsb.WriteString(value.String())\n\t\t\tsb.WriteString(\",\")\n\n\t\t\treturn true\n\t\t})\n\t})\n\tif ex != nil {\n\t\tpanic(ex)\n\t}\n\tfmt.Println(sb.String())\n\t// Output: a=1,b=2,\n}\n\nfunc TestDestructAssignToSymbol(t *testing.T) {\n\tconst SCRIPT = `\n\tconst s = Symbol('s');\n\tconst target = {};\n\n\t({a: target[s]} = {a: 42});\n\tassert.sameValue(target[s], 42);\n`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestToNumber(t *testing.T) {\n\tconst SCRIPT = `\n\tassert(isNaN(Number(\"+\")));\n\tassert(isNaN(Number(\"++\")));\n\tassert(isNaN(Number(\"-\")));\n\tassert(isNaN(Number(\"0xfp1\")));\n\tassert(isNaN(Number(\"0Xfp1\")));\n\tassert(isNaN(Number(\"+0xfp1\")));\n\tassert(isNaN(Number(\" +0xfp1\")));\n\tassert(isNaN(Number(\" + 0xfp1\")));\n\tassert(isNaN(Number(\" 0xfp1\")));\n\tassert(isNaN(Number(\"-0xfp1\")));\n\tassert(isNaN(Number(\"- 0xfp1\")));\n\tassert(isNaN(Number(\" - 0xfp1\")));\n\tassert.sameValue(Number(\"0.\"), 0);\n\tassert.sameValue(Number(\" \"), 0);\n\tassert.sameValue(Number(\" Infinity\"), Infinity);\n\n\tlet a = [1];\n\tassert.sameValue(1, a.at(\"0xfp1\"));\n\tassert.sameValue(1, a.at(\" 0xfp1\"));\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\n/*\nfunc TestArrayConcatSparse(t *testing.T) {\nfunction foo(a,b,c)\n  {\n    arguments[0] = 1; arguments[1] = 'str'; arguments[2] = 2.1;\n    if(1 === a && 'str' === b && 2.1 === c)\n      return true;\n  }\n\n\n\tconst SCRIPT = `\n\tvar a1 = [];\n\tvar a2 = [];\n\ta1[500000] = 1;\n\ta2[1000000] = 2;\n\tvar a3 = a1.concat(a2);\n\ta3.length === 1500002 && a3[500000] === 1 && a3[1500001] == 2;\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n*/\n\nfunc BenchmarkCallReflect(b *testing.B) {\n\tvm := New()\n\tvm.Set(\"f\", func(v Value) {\n\n\t})\n\n\tprg := MustCompile(\"test.js\", \"f(null)\", true)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkCallNative(b *testing.B) {\n\tvm := New()\n\tvm.Set(\"f\", func(call FunctionCall) (ret Value) {\n\t\treturn\n\t})\n\n\tprg := MustCompile(\"test.js\", \"f(null)\", true)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkCallJS(b *testing.B) {\n\tvm := New()\n\t_, err := vm.RunString(`\n\tfunction f() {\n\t\treturn 42;\n\t}\n\t`)\n\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tprg := MustCompile(\"test.js\", \"f(null)\", true)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkMainLoop(b *testing.B) {\n\tvm := New()\n\n\tconst SCRIPT = `\n\t\tfor (var i=0; i<100000; i++) {\n\t\t}\n\t`\n\n\tprg := MustCompile(\"test.js\", SCRIPT, true)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkStringMapGet(b *testing.B) {\n\tm := make(map[string]Value)\n\tfor i := 0; i < 100; i++ {\n\t\tm[strconv.Itoa(i)] = intToValue(int64(i))\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif m[\"50\"] == nil {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}\n\nfunc BenchmarkValueStringMapGet(b *testing.B) {\n\tm := make(map[String]Value)\n\tfor i := 0; i < 100; i++ {\n\t\tm[asciiString(strconv.Itoa(i))] = intToValue(int64(i))\n\t}\n\tb.ResetTimer()\n\tvar key String = asciiString(\"50\")\n\tfor i := 0; i < b.N; i++ {\n\t\tif m[key] == nil {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}\n\nfunc BenchmarkAsciiStringMapGet(b *testing.B) {\n\tm := make(map[asciiString]Value)\n\tfor i := 0; i < 100; i++ {\n\t\tm[asciiString(strconv.Itoa(i))] = intToValue(int64(i))\n\t}\n\tb.ResetTimer()\n\tvar key = asciiString(\"50\")\n\tfor i := 0; i < b.N; i++ {\n\t\tif m[key] == nil {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tNew()\n\t}\n}\n"
        },
        {
          "name": "staticcheck.conf",
          "type": "blob",
          "size": 0.1025390625,
          "content": "checks = [\"all\", \"-ST1000\", \"-ST1003\", \"-ST1005\", \"-ST1006\", \"-ST1012\", \"-ST1021\", \"-ST1020\", \"-ST1008\"]\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 9.4755859375,
          "content": "package goja\n\nimport (\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst (\n\t__proto__ = \"__proto__\"\n)\n\nvar (\n\tstringTrue        String = asciiString(\"true\")\n\tstringFalse       String = asciiString(\"false\")\n\tstringNull        String = asciiString(\"null\")\n\tstringUndefined   String = asciiString(\"undefined\")\n\tstringObjectC     String = asciiString(\"object\")\n\tstringFunction    String = asciiString(\"function\")\n\tstringBoolean     String = asciiString(\"boolean\")\n\tstringString      String = asciiString(\"string\")\n\tstringSymbol      String = asciiString(\"symbol\")\n\tstringNumber      String = asciiString(\"number\")\n\tstringBigInt      String = asciiString(\"bigint\")\n\tstringNaN         String = asciiString(\"NaN\")\n\tstringInfinity           = asciiString(\"Infinity\")\n\tstringNegInfinity        = asciiString(\"-Infinity\")\n\tstringBound_      String = asciiString(\"bound \")\n\tstringEmpty       String = asciiString(\"\")\n\n\tstringError          String = asciiString(\"Error\")\n\tstringAggregateError String = asciiString(\"AggregateError\")\n\tstringTypeError      String = asciiString(\"TypeError\")\n\tstringReferenceError String = asciiString(\"ReferenceError\")\n\tstringSyntaxError    String = asciiString(\"SyntaxError\")\n\tstringRangeError     String = asciiString(\"RangeError\")\n\tstringEvalError      String = asciiString(\"EvalError\")\n\tstringURIError       String = asciiString(\"URIError\")\n\tstringGoError        String = asciiString(\"GoError\")\n\n\tstringObjectNull      String = asciiString(\"[object Null]\")\n\tstringObjectUndefined String = asciiString(\"[object Undefined]\")\n\tstringInvalidDate     String = asciiString(\"Invalid Date\")\n)\n\ntype utf16Reader interface {\n\treadChar() (c uint16, err error)\n}\n\n// String represents an ECMAScript string Value. Its internal representation depends on the contents of the\n// string, but in any case it is capable of holding any UTF-16 string, either valid or invalid.\n// Instances of this type, as any other primitive values, are goroutine-safe and can be passed between runtimes.\n// Strings can be created using Runtime.ToValue(goString) or StringFromUTF16.\ntype String interface {\n\tValue\n\tCharAt(int) uint16\n\tLength() int\n\tConcat(String) String\n\tSubstring(start, end int) String\n\tCompareTo(String) int\n\tReader() io.RuneReader\n\tutf16Reader() utf16Reader\n\tutf16RuneReader() io.RuneReader\n\tutf16Runes() []rune\n\tindex(String, int) int\n\tlastIndex(String, int) int\n\ttoLower() String\n\ttoUpper() String\n\ttoTrimmedUTF8() string\n}\n\ntype stringIterObject struct {\n\tbaseObject\n\treader io.RuneReader\n}\n\nfunc isUTF16FirstSurrogate(c uint16) bool {\n\treturn c >= 0xD800 && c <= 0xDBFF\n}\n\nfunc isUTF16SecondSurrogate(c uint16) bool {\n\treturn c >= 0xDC00 && c <= 0xDFFF\n}\n\nfunc (si *stringIterObject) next() Value {\n\tif si.reader == nil {\n\t\treturn si.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\tr, _, err := si.reader.ReadRune()\n\tif err == io.EOF {\n\t\tsi.reader = nil\n\t\treturn si.val.runtime.createIterResultObject(_undefined, true)\n\t}\n\treturn si.val.runtime.createIterResultObject(stringFromRune(r), false)\n}\n\nfunc stringFromRune(r rune) String {\n\tif r < utf8.RuneSelf {\n\t\tvar sb strings.Builder\n\t\tsb.WriteByte(byte(r))\n\t\treturn asciiString(sb.String())\n\t}\n\tvar sb unicodeStringBuilder\n\tsb.WriteRune(r)\n\treturn sb.String()\n}\n\nfunc (r *Runtime) createStringIterator(s String) Value {\n\to := &Object{runtime: r}\n\n\tsi := &stringIterObject{\n\t\treader: &lenientUtf16Decoder{utf16Reader: s.utf16Reader()},\n\t}\n\tsi.class = classObject\n\tsi.val = o\n\tsi.extensible = true\n\to.self = si\n\tsi.prototype = r.getStringIteratorPrototype()\n\tsi.init()\n\n\treturn o\n}\n\ntype stringObject struct {\n\tbaseObject\n\tvalue      String\n\tlength     int\n\tlengthProp valueProperty\n}\n\nfunc newStringValue(s string) String {\n\tif u := unistring.Scan(s); u != nil {\n\t\treturn unicodeString(u)\n\t}\n\treturn asciiString(s)\n}\n\nfunc stringValueFromRaw(raw unistring.String) String {\n\tif b := raw.AsUtf16(); b != nil {\n\t\treturn unicodeString(b)\n\t}\n\treturn asciiString(raw)\n}\n\nfunc (s *stringObject) init() {\n\ts.baseObject.init()\n\ts.setLength()\n}\n\nfunc (s *stringObject) setLength() {\n\tif s.value != nil {\n\t\ts.length = s.value.Length()\n\t}\n\ts.lengthProp.value = intToValue(int64(s.length))\n\ts._put(\"length\", &s.lengthProp)\n}\n\nfunc (s *stringObject) getStr(name unistring.String, receiver Value) Value {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\treturn s._getIdx(i)\n\t}\n\treturn s.baseObject.getStr(name, receiver)\n}\n\nfunc (s *stringObject) getIdx(idx valueInt, receiver Value) Value {\n\ti := int(idx)\n\tif i >= 0 && i < s.length {\n\t\treturn s._getIdx(i)\n\t}\n\treturn s.baseObject.getStr(idx.string(), receiver)\n}\n\nfunc (s *stringObject) getOwnPropStr(name unistring.String) Value {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\tval := s._getIdx(i)\n\t\treturn &valueProperty{\n\t\t\tvalue:      val,\n\t\t\tenumerable: true,\n\t\t}\n\t}\n\n\treturn s.baseObject.getOwnPropStr(name)\n}\n\nfunc (s *stringObject) getOwnPropIdx(idx valueInt) Value {\n\ti := int64(idx)\n\tif i >= 0 {\n\t\tif i < int64(s.length) {\n\t\t\tval := s._getIdx(int(i))\n\t\t\treturn &valueProperty{\n\t\t\t\tvalue:      val,\n\t\t\t\tenumerable: true,\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn s.baseObject.getOwnPropStr(idx.string())\n}\n\nfunc (s *stringObject) _getIdx(idx int) Value {\n\treturn s.value.Substring(idx, idx+1)\n}\n\nfunc (s *stringObject) setOwnStr(name unistring.String, val Value, throw bool) bool {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\ts.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%d' of a String\", i)\n\t\treturn false\n\t}\n\n\treturn s.baseObject.setOwnStr(name, val, throw)\n}\n\nfunc (s *stringObject) setOwnIdx(idx valueInt, val Value, throw bool) bool {\n\ti := int64(idx)\n\tif i >= 0 && i < int64(s.length) {\n\t\ts.val.runtime.typeErrorResult(throw, \"Cannot assign to read only property '%d' of a String\", i)\n\t\treturn false\n\t}\n\n\treturn s.baseObject.setOwnStr(idx.string(), val, throw)\n}\n\nfunc (s *stringObject) setForeignStr(name unistring.String, val, receiver Value, throw bool) (bool, bool) {\n\treturn s._setForeignStr(name, s.getOwnPropStr(name), val, receiver, throw)\n}\n\nfunc (s *stringObject) setForeignIdx(idx valueInt, val, receiver Value, throw bool) (bool, bool) {\n\treturn s._setForeignIdx(idx, s.getOwnPropIdx(idx), val, receiver, throw)\n}\n\nfunc (s *stringObject) defineOwnPropertyStr(name unistring.String, descr PropertyDescriptor, throw bool) bool {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\t_, ok := s._defineOwnProperty(name, &valueProperty{enumerable: true}, descr, throw)\n\t\treturn ok\n\t}\n\n\treturn s.baseObject.defineOwnPropertyStr(name, descr, throw)\n}\n\nfunc (s *stringObject) defineOwnPropertyIdx(idx valueInt, descr PropertyDescriptor, throw bool) bool {\n\ti := int64(idx)\n\tif i >= 0 && i < int64(s.length) {\n\t\ts.val.runtime.typeErrorResult(throw, \"Cannot redefine property: %d\", i)\n\t\treturn false\n\t}\n\n\treturn s.baseObject.defineOwnPropertyStr(idx.string(), descr, throw)\n}\n\ntype stringPropIter struct {\n\tstr         String // separate, because obj can be the singleton\n\tobj         *stringObject\n\tidx, length int\n}\n\nfunc (i *stringPropIter) next() (propIterItem, iterNextFunc) {\n\tif i.idx < i.length {\n\t\tname := strconv.Itoa(i.idx)\n\t\ti.idx++\n\t\treturn propIterItem{name: asciiString(name), enumerable: _ENUM_TRUE}, i.next\n\t}\n\n\treturn i.obj.baseObject.iterateStringKeys()()\n}\n\nfunc (s *stringObject) iterateStringKeys() iterNextFunc {\n\treturn (&stringPropIter{\n\t\tstr:    s.value,\n\t\tobj:    s,\n\t\tlength: s.length,\n\t}).next\n}\n\nfunc (s *stringObject) stringKeys(all bool, accum []Value) []Value {\n\tfor i := 0; i < s.length; i++ {\n\t\taccum = append(accum, asciiString(strconv.Itoa(i)))\n\t}\n\n\treturn s.baseObject.stringKeys(all, accum)\n}\n\nfunc (s *stringObject) deleteStr(name unistring.String, throw bool) bool {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\ts.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of a String\", i)\n\t\treturn false\n\t}\n\n\treturn s.baseObject.deleteStr(name, throw)\n}\n\nfunc (s *stringObject) deleteIdx(idx valueInt, throw bool) bool {\n\ti := int64(idx)\n\tif i >= 0 && i < int64(s.length) {\n\t\ts.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of a String\", i)\n\t\treturn false\n\t}\n\n\treturn s.baseObject.deleteStr(idx.string(), throw)\n}\n\nfunc (s *stringObject) hasOwnPropertyStr(name unistring.String) bool {\n\tif i := strToGoIdx(name); i >= 0 && i < s.length {\n\t\treturn true\n\t}\n\treturn s.baseObject.hasOwnPropertyStr(name)\n}\n\nfunc (s *stringObject) hasOwnPropertyIdx(idx valueInt) bool {\n\ti := int64(idx)\n\tif i >= 0 && i < int64(s.length) {\n\t\treturn true\n\t}\n\treturn s.baseObject.hasOwnPropertyStr(idx.string())\n}\n\nfunc devirtualizeString(s String) (asciiString, unicodeString) {\n\tswitch s := s.(type) {\n\tcase asciiString:\n\t\treturn s, nil\n\tcase unicodeString:\n\t\treturn \"\", s\n\tcase *importedString:\n\t\ts.ensureScanned()\n\t\tif s.u != nil {\n\t\t\treturn \"\", s.u\n\t\t}\n\t\treturn asciiString(s.s), nil\n\tdefault:\n\t\tpanic(unknownStringTypeErr(s))\n\t}\n}\n\nfunc unknownStringTypeErr(v Value) interface{} {\n\treturn newTypeError(\"Internal bug: unknown string type: %T\", v)\n}\n\n// StringFromUTF16 creates a string value from an array of UTF-16 code units. The result is a copy, so the initial\n// slice can be modified after calling this function (but it must not be modified while the function is running).\n// No validation of any kind is performed.\nfunc StringFromUTF16(chars []uint16) String {\n\tisAscii := true\n\tfor _, c := range chars {\n\t\tif c >= utf8.RuneSelf {\n\t\t\tisAscii = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif isAscii {\n\t\tvar sb strings.Builder\n\t\tsb.Grow(len(chars))\n\t\tfor _, c := range chars {\n\t\t\tsb.WriteByte(byte(c))\n\t\t}\n\t\treturn asciiString(sb.String())\n\t}\n\tbuf := make([]uint16, len(chars)+1)\n\tbuf[0] = unistring.BOM\n\tcopy(buf[1:], chars)\n\treturn unicodeString(buf)\n}\n"
        },
        {
          "name": "string_ascii.go",
          "type": "blob",
          "size": 7.509765625,
          "content": "package goja\n\nimport (\n\t\"hash/maphash\"\n\t\"io\"\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype asciiString string\n\ntype asciiRuneReader struct {\n\ts   asciiString\n\tpos int\n}\n\nfunc (rr *asciiRuneReader) ReadRune() (r rune, size int, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tr = rune(rr.s[rr.pos])\n\t\tsize = 1\n\t\trr.pos++\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\ntype asciiUtf16Reader struct {\n\ts   asciiString\n\tpos int\n}\n\nfunc (rr *asciiUtf16Reader) readChar() (c uint16, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tc = uint16(rr.s[rr.pos])\n\t\trr.pos++\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nfunc (rr *asciiUtf16Reader) ReadRune() (r rune, size int, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tr = rune(rr.s[rr.pos])\n\t\trr.pos++\n\t\tsize = 1\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nfunc (s asciiString) Reader() io.RuneReader {\n\treturn &asciiRuneReader{\n\t\ts: s,\n\t}\n}\n\nfunc (s asciiString) utf16Reader() utf16Reader {\n\treturn &asciiUtf16Reader{\n\t\ts: s,\n\t}\n}\n\nfunc (s asciiString) utf16RuneReader() io.RuneReader {\n\treturn &asciiUtf16Reader{\n\t\ts: s,\n\t}\n}\n\nfunc (s asciiString) utf16Runes() []rune {\n\trunes := make([]rune, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\trunes[i] = rune(s[i])\n\t}\n\treturn runes\n}\n\n// ss must be trimmed\nfunc stringToInt(ss string) (int64, error) {\n\tif ss == \"\" {\n\t\treturn 0, nil\n\t}\n\tif ss == \"-0\" {\n\t\treturn 0, strconv.ErrSyntax\n\t}\n\tif len(ss) > 2 {\n\t\tswitch ss[:2] {\n\t\tcase \"0x\", \"0X\":\n\t\t\treturn strconv.ParseInt(ss[2:], 16, 64)\n\t\tcase \"0b\", \"0B\":\n\t\t\treturn strconv.ParseInt(ss[2:], 2, 64)\n\t\tcase \"0o\", \"0O\":\n\t\t\treturn strconv.ParseInt(ss[2:], 8, 64)\n\t\t}\n\t}\n\treturn strconv.ParseInt(ss, 10, 64)\n}\n\nfunc (s asciiString) _toInt(trimmed string) (int64, error) {\n\treturn stringToInt(trimmed)\n}\n\nfunc isRangeErr(err error) bool {\n\tif err, ok := err.(*strconv.NumError); ok {\n\t\treturn err.Err == strconv.ErrRange\n\t}\n\treturn false\n}\n\nfunc (s asciiString) _toFloat(trimmed string) (float64, error) {\n\tif trimmed == \"\" {\n\t\treturn 0, nil\n\t}\n\tif trimmed == \"-0\" {\n\t\tvar f float64\n\t\treturn -f, nil\n\t}\n\n\t// Go allows underscores in numbers, when parsed as floats, but ECMAScript expect them to be interpreted as NaN.\n\tif strings.ContainsRune(trimmed, '_') {\n\t\treturn 0, strconv.ErrSyntax\n\t}\n\n\t// Hexadecimal floats are not supported by ECMAScript.\n\tif len(trimmed) >= 2 {\n\t\tvar prefix string\n\t\tif trimmed[0] == '-' || trimmed[0] == '+' {\n\t\t\tprefix = trimmed[1:]\n\t\t} else {\n\t\t\tprefix = trimmed\n\t\t}\n\t\tif len(prefix) >= 2 && prefix[0] == '0' && (prefix[1] == 'x' || prefix[1] == 'X') {\n\t\t\treturn 0, strconv.ErrSyntax\n\t\t}\n\t}\n\n\tf, err := strconv.ParseFloat(trimmed, 64)\n\tif err == nil && math.IsInf(f, 0) {\n\t\tss := strings.ToLower(trimmed)\n\t\tif strings.HasPrefix(ss, \"inf\") || strings.HasPrefix(ss, \"-inf\") || strings.HasPrefix(ss, \"+inf\") {\n\t\t\t// We handle \"Infinity\" separately, prevent from being parsed as Infinity due to strconv.ParseFloat() permissive syntax\n\t\t\treturn 0, strconv.ErrSyntax\n\t\t}\n\t}\n\tif isRangeErr(err) {\n\t\terr = nil\n\t}\n\treturn f, err\n}\n\nfunc (s asciiString) ToInteger() int64 {\n\tss := strings.TrimSpace(string(s))\n\tif ss == \"\" {\n\t\treturn 0\n\t}\n\tif ss == \"Infinity\" || ss == \"+Infinity\" {\n\t\treturn math.MaxInt64\n\t}\n\tif ss == \"-Infinity\" {\n\t\treturn math.MinInt64\n\t}\n\ti, err := s._toInt(ss)\n\tif err != nil {\n\t\tf, err := s._toFloat(ss)\n\t\tif err == nil {\n\t\t\treturn int64(f)\n\t\t}\n\t}\n\treturn i\n}\n\nfunc (s asciiString) toString() String {\n\treturn s\n}\n\nfunc (s asciiString) ToString() Value {\n\treturn s\n}\n\nfunc (s asciiString) String() string {\n\treturn string(s)\n}\n\nfunc (s asciiString) ToFloat() float64 {\n\tss := strings.TrimSpace(string(s))\n\tif ss == \"\" {\n\t\treturn 0\n\t}\n\tif ss == \"Infinity\" || ss == \"+Infinity\" {\n\t\treturn math.Inf(1)\n\t}\n\tif ss == \"-Infinity\" {\n\t\treturn math.Inf(-1)\n\t}\n\tf, err := s._toFloat(ss)\n\tif err != nil {\n\t\ti, err := s._toInt(ss)\n\t\tif err == nil {\n\t\t\treturn float64(i)\n\t\t}\n\t\tf = math.NaN()\n\t}\n\treturn f\n}\n\nfunc (s asciiString) ToBoolean() bool {\n\treturn s != \"\"\n}\n\nfunc (s asciiString) ToNumber() Value {\n\tss := strings.TrimSpace(string(s))\n\tif ss == \"\" {\n\t\treturn intToValue(0)\n\t}\n\tif ss == \"Infinity\" || ss == \"+Infinity\" {\n\t\treturn _positiveInf\n\t}\n\tif ss == \"-Infinity\" {\n\t\treturn _negativeInf\n\t}\n\n\tif i, err := s._toInt(ss); err == nil {\n\t\treturn intToValue(i)\n\t}\n\n\tif f, err := s._toFloat(ss); err == nil {\n\t\treturn floatToValue(f)\n\t}\n\n\treturn _NaN\n}\n\nfunc (s asciiString) ToObject(r *Runtime) *Object {\n\treturn r._newString(s, r.getStringPrototype())\n}\n\nfunc (s asciiString) SameAs(other Value) bool {\n\treturn s.StrictEquals(other)\n}\n\nfunc (s asciiString) Equals(other Value) bool {\n\tif s.StrictEquals(other) {\n\t\treturn true\n\t}\n\n\tif o, ok := other.(valueInt); ok {\n\t\tif o1, e := s._toInt(strings.TrimSpace(string(s))); e == nil {\n\t\t\treturn o1 == int64(o)\n\t\t}\n\t\treturn false\n\t}\n\n\tif o, ok := other.(valueFloat); ok {\n\t\treturn s.ToFloat() == float64(o)\n\t}\n\n\tif o, ok := other.(valueBool); ok {\n\t\tif o1, e := s._toFloat(strings.TrimSpace(string(s))); e == nil {\n\t\t\treturn o1 == o.ToFloat()\n\t\t}\n\t\treturn false\n\t}\n\n\tif o, ok := other.(*valueBigInt); ok {\n\t\tbigInt, err := stringToBigInt(s.toTrimmedUTF8())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn bigInt.Cmp((*big.Int)(o)) == 0\n\t}\n\n\tif o, ok := other.(*Object); ok {\n\t\treturn s.Equals(o.toPrimitive())\n\t}\n\treturn false\n}\n\nfunc (s asciiString) StrictEquals(other Value) bool {\n\tif otherStr, ok := other.(asciiString); ok {\n\t\treturn s == otherStr\n\t}\n\tif otherStr, ok := other.(*importedString); ok {\n\t\tif otherStr.u == nil {\n\t\t\treturn string(s) == otherStr.s\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s asciiString) baseObject(r *Runtime) *Object {\n\tss := r.getStringSingleton()\n\tss.value = s\n\tss.setLength()\n\treturn ss.val\n}\n\nfunc (s asciiString) hash(hash *maphash.Hash) uint64 {\n\t_, _ = hash.WriteString(string(s))\n\th := hash.Sum64()\n\thash.Reset()\n\treturn h\n}\n\nfunc (s asciiString) CharAt(idx int) uint16 {\n\treturn uint16(s[idx])\n}\n\nfunc (s asciiString) Length() int {\n\treturn len(s)\n}\n\nfunc (s asciiString) Concat(other String) String {\n\ta, u := devirtualizeString(other)\n\tif u != nil {\n\t\tb := make([]uint16, len(s)+len(u))\n\t\tb[0] = unistring.BOM\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tb[i+1] = uint16(s[i])\n\t\t}\n\t\tcopy(b[len(s)+1:], u[1:])\n\t\treturn unicodeString(b)\n\t}\n\treturn s + a\n}\n\nfunc (s asciiString) Substring(start, end int) String {\n\treturn s[start:end]\n}\n\nfunc (s asciiString) CompareTo(other String) int {\n\tswitch other := other.(type) {\n\tcase asciiString:\n\t\treturn strings.Compare(string(s), string(other))\n\tcase unicodeString:\n\t\treturn strings.Compare(string(s), other.String())\n\tcase *importedString:\n\t\treturn strings.Compare(string(s), other.s)\n\tdefault:\n\t\tpanic(newTypeError(\"Internal bug: unknown string type: %T\", other))\n\t}\n}\n\nfunc (s asciiString) index(substr String, start int) int {\n\ta, u := devirtualizeString(substr)\n\tif u == nil {\n\t\tif start > len(s) {\n\t\t\treturn -1\n\t\t}\n\t\tp := strings.Index(string(s[start:]), string(a))\n\t\tif p >= 0 {\n\t\t\treturn p + start\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc (s asciiString) lastIndex(substr String, pos int) int {\n\ta, u := devirtualizeString(substr)\n\tif u == nil {\n\t\tend := pos + len(a)\n\t\tvar ss string\n\t\tif end > len(s) {\n\t\t\tss = string(s)\n\t\t} else {\n\t\t\tss = string(s[:end])\n\t\t}\n\t\treturn strings.LastIndex(ss, string(a))\n\t}\n\treturn -1\n}\n\nfunc (s asciiString) toLower() String {\n\treturn asciiString(strings.ToLower(string(s)))\n}\n\nfunc (s asciiString) toUpper() String {\n\treturn asciiString(strings.ToUpper(string(s)))\n}\n\nfunc (s asciiString) toTrimmedUTF8() string {\n\treturn strings.TrimSpace(string(s))\n}\n\nfunc (s asciiString) string() unistring.String {\n\treturn unistring.String(s)\n}\n\nfunc (s asciiString) Export() interface{} {\n\treturn string(s)\n}\n\nfunc (s asciiString) ExportType() reflect.Type {\n\treturn reflectTypeString\n}\n"
        },
        {
          "name": "string_imported.go",
          "type": "blob",
          "size": 5.888671875,
          "content": "package goja\n\nimport (\n\t\"hash/maphash\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/parser\"\n\t\"github.com/dop251/goja/unistring\"\n\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n)\n\n// Represents a string imported from Go. The idea is to delay the scanning for unicode characters and converting\n// to unicodeString until necessary. This way strings that are merely passed through never get scanned which\n// saves CPU and memory.\n// Currently, importedString is created in 2 cases: Runtime.ToValue() for strings longer than 16 bytes and as a result\n// of JSON.stringify() if it may contain unicode characters. More cases could be added in the future.\ntype importedString struct {\n\ts string\n\tu unicodeString\n\n\tscanned bool\n}\n\nfunc (i *importedString) scan() {\n\ti.u = unistring.Scan(i.s)\n\ti.scanned = true\n}\n\nfunc (i *importedString) ensureScanned() {\n\tif !i.scanned {\n\t\ti.scan()\n\t}\n}\n\nfunc (i *importedString) ToInteger() int64 {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn 0\n\t}\n\treturn asciiString(i.s).ToInteger()\n}\n\nfunc (i *importedString) toString() String {\n\treturn i\n}\n\nfunc (i *importedString) string() unistring.String {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn unistring.FromUtf16(i.u)\n\t}\n\treturn unistring.String(i.s)\n}\n\nfunc (i *importedString) ToString() Value {\n\treturn i\n}\n\nfunc (i *importedString) String() string {\n\treturn i.s\n}\n\nfunc (i *importedString) ToFloat() float64 {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn math.NaN()\n\t}\n\treturn asciiString(i.s).ToFloat()\n}\n\nfunc (i *importedString) ToNumber() Value {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.ToNumber()\n\t}\n\treturn asciiString(i.s).ToNumber()\n}\n\nfunc (i *importedString) ToBoolean() bool {\n\treturn len(i.s) != 0\n}\n\nfunc (i *importedString) ToObject(r *Runtime) *Object {\n\treturn r._newString(i, r.getStringPrototype())\n}\n\nfunc (i *importedString) SameAs(other Value) bool {\n\treturn i.StrictEquals(other)\n}\n\nfunc (i *importedString) Equals(other Value) bool {\n\tif i.StrictEquals(other) {\n\t\treturn true\n\t}\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.Equals(other)\n\t}\n\treturn asciiString(i.s).Equals(other)\n}\n\nfunc (i *importedString) StrictEquals(other Value) bool {\n\tswitch otherStr := other.(type) {\n\tcase asciiString:\n\t\tif i.u != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn i.s == string(otherStr)\n\tcase unicodeString:\n\t\ti.ensureScanned()\n\t\tif i.u != nil && i.u.equals(otherStr) {\n\t\t\treturn true\n\t\t}\n\tcase *importedString:\n\t\treturn i.s == otherStr.s\n\t}\n\treturn false\n}\n\nfunc (i *importedString) Export() interface{} {\n\treturn i.s\n}\n\nfunc (i *importedString) ExportType() reflect.Type {\n\treturn reflectTypeString\n}\n\nfunc (i *importedString) baseObject(r *Runtime) *Object {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.baseObject(r)\n\t}\n\treturn asciiString(i.s).baseObject(r)\n}\n\nfunc (i *importedString) hash(hasher *maphash.Hash) uint64 {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.hash(hasher)\n\t}\n\treturn asciiString(i.s).hash(hasher)\n}\n\nfunc (i *importedString) CharAt(idx int) uint16 {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.CharAt(idx)\n\t}\n\treturn asciiString(i.s).CharAt(idx)\n}\n\nfunc (i *importedString) Length() int {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.Length()\n\t}\n\treturn asciiString(i.s).Length()\n}\n\nfunc (i *importedString) Concat(v String) String {\n\tif !i.scanned {\n\t\tif v, ok := v.(*importedString); ok {\n\t\t\tif !v.scanned {\n\t\t\t\treturn &importedString{s: i.s + v.s}\n\t\t\t}\n\t\t}\n\t\ti.ensureScanned()\n\t}\n\tif i.u != nil {\n\t\treturn i.u.Concat(v)\n\t}\n\treturn asciiString(i.s).Concat(v)\n}\n\nfunc (i *importedString) Substring(start, end int) String {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.Substring(start, end)\n\t}\n\treturn asciiString(i.s).Substring(start, end)\n}\n\nfunc (i *importedString) CompareTo(v String) int {\n\treturn strings.Compare(i.s, v.String())\n}\n\nfunc (i *importedString) Reader() io.RuneReader {\n\tif i.scanned {\n\t\tif i.u != nil {\n\t\t\treturn i.u.Reader()\n\t\t}\n\t\treturn asciiString(i.s).Reader()\n\t}\n\treturn strings.NewReader(i.s)\n}\n\ntype stringUtf16Reader struct {\n\ts      string\n\tpos    int\n\tsecond uint16\n}\n\nfunc (s *stringUtf16Reader) readChar() (c uint16, err error) {\n\tif s.second != 0 {\n\t\tc, s.second = s.second, 0\n\t\treturn\n\t}\n\tif s.pos < len(s.s) {\n\t\tr1, size1 := utf8.DecodeRuneInString(s.s[s.pos:])\n\t\ts.pos += size1\n\t\tif r1 <= 0xFFFF {\n\t\t\tc = uint16(r1)\n\t\t} else {\n\t\t\tfirst, second := utf16.EncodeRune(r1)\n\t\t\tc, s.second = uint16(first), uint16(second)\n\t\t}\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nfunc (s *stringUtf16Reader) ReadRune() (r rune, size int, err error) {\n\tc, err := s.readChar()\n\tif err != nil {\n\t\treturn\n\t}\n\tr = rune(c)\n\tsize = 1\n\treturn\n}\n\nfunc (i *importedString) utf16Reader() utf16Reader {\n\tif i.scanned {\n\t\tif i.u != nil {\n\t\t\treturn i.u.utf16Reader()\n\t\t}\n\t\treturn asciiString(i.s).utf16Reader()\n\t}\n\treturn &stringUtf16Reader{\n\t\ts: i.s,\n\t}\n}\n\nfunc (i *importedString) utf16RuneReader() io.RuneReader {\n\tif i.scanned {\n\t\tif i.u != nil {\n\t\t\treturn i.u.utf16RuneReader()\n\t\t}\n\t\treturn asciiString(i.s).utf16RuneReader()\n\t}\n\treturn &stringUtf16Reader{\n\t\ts: i.s,\n\t}\n}\n\nfunc (i *importedString) utf16Runes() []rune {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.utf16Runes()\n\t}\n\treturn asciiString(i.s).utf16Runes()\n}\n\nfunc (i *importedString) index(v String, start int) int {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.index(v, start)\n\t}\n\treturn asciiString(i.s).index(v, start)\n}\n\nfunc (i *importedString) lastIndex(v String, pos int) int {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn i.u.lastIndex(v, pos)\n\t}\n\treturn asciiString(i.s).lastIndex(v, pos)\n}\n\nfunc (i *importedString) toLower() String {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\treturn toLower(i.s)\n\t}\n\treturn asciiString(i.s).toLower()\n}\n\nfunc (i *importedString) toUpper() String {\n\ti.ensureScanned()\n\tif i.u != nil {\n\t\tcaser := cases.Upper(language.Und)\n\t\treturn newStringValue(caser.String(i.s))\n\t}\n\treturn asciiString(i.s).toUpper()\n}\n\nfunc (i *importedString) toTrimmedUTF8() string {\n\treturn strings.Trim(i.s, parser.WhitespaceChars)\n}\n"
        },
        {
          "name": "string_test.go",
          "type": "blob",
          "size": 4.7109375,
          "content": "package goja\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestStringOOBProperties(t *testing.T) {\n\tconst SCRIPT = `\n\tvar string = new String(\"str\");\n\t\n\tstring[4] = 1;\n\tstring[4];\n\t`\n\n\ttestScript(SCRIPT, valueInt(1), t)\n}\n\nfunc TestImportedString(t *testing.T) {\n\tvm := New()\n\n\ttestUnaryOp := func(a, expr string, result interface{}, t *testing.T) {\n\t\tv, err := vm.RunString(\"a => \" + expr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar fn func(a Value) (Value, error)\n\t\terr = vm.ExportTo(v, &fn)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, aa := range []Value{newStringValue(a), vm.ToValue(a)} {\n\t\t\tres, err := fn(aa)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif res.Export() != result {\n\t\t\t\tt.Fatalf(\"%s, a:%v(%T). expected: %v, actual: %v\", expr, aa, aa, result, res)\n\t\t\t}\n\t\t}\n\t}\n\n\ttestBinaryOp := func(a, b, expr string, result interface{}, t *testing.T) {\n\t\tv, err := vm.RunString(\"(a, b) => \" + expr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar fn func(a, b Value) (Value, error)\n\t\terr = vm.ExportTo(v, &fn)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, aa := range []Value{newStringValue(a), vm.ToValue(a)} {\n\t\t\tfor _, bb := range []Value{newStringValue(b), vm.ToValue(b)} {\n\t\t\t\tres, err := fn(aa, bb)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif res.Export() != result {\n\t\t\t\t\tt.Fatalf(\"%s, a:%v(%T), b:%v(%T). expected: %v, actual: %v\", expr, aa, aa, bb, bb, result, res)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstrs := []string{\"shortAscii\", \"longlongAscii1234567890123456789\", \"short \", \"long  1234567890  \\U0001F600\", \"\", \"Ascii\", \"long\", \"\"}\n\tindexOfResults := [][]int{\n\t\t/*\n\t\t\tconst strs = [\"shortAscii\", \"longlongAscii1234567890123456789\", \"short \", \"long  1234567890  \\u{1F600}\", \"\", \"Ascii\", \"long\", \"\"];\n\n\t\t\tstrs.forEach(a => {\n\t\t\t    console.log(\"{\", strs.map(b => a.indexOf(b)).join(\", \"), \"},\");\n\t\t\t});\n\t\t*/\n\t\t{0, -1, -1, -1, -1, 5, -1, -1},\n\t\t{-1, 0, -1, -1, -1, 8, 0, -1},\n\t\t{-1, -1, 0, -1, 6, -1, -1, 9},\n\t\t{-1, -1, -1, 0, 5, -1, 0, 8},\n\t\t{-1, -1, -1, -1, 0, -1, -1, 3},\n\t\t{-1, -1, -1, -1, -1, 0, -1, -1},\n\t\t{-1, -1, -1, -1, -1, -1, 0, -1},\n\t\t{-1, -1, -1, -1, -1, -1, -1, 0},\n\t}\n\n\tlastIndexOfResults := [][]int{\n\t\t/*\n\t\t\tstrs.forEach(a => {\n\t\t\t    console.log(\"{\", strs.map(b => a.lastIndexOf(b)).join(\", \"), \"},\");\n\t\t\t});\n\t\t*/\n\t\t{0, -1, -1, -1, -1, 5, -1, -1},\n\t\t{-1, 0, -1, -1, -1, 8, 4, -1},\n\t\t{-1, -1, 0, -1, 6, -1, -1, 9},\n\t\t{-1, -1, -1, 0, 23, -1, 0, 26},\n\t\t{-1, -1, -1, -1, 0, -1, -1, 3},\n\t\t{-1, -1, -1, -1, -1, 0, -1, -1},\n\t\t{-1, -1, -1, -1, -1, -1, 0, -1},\n\t\t{-1, -1, -1, -1, -1, -1, -1, 0},\n\t}\n\n\tpad := func(s, p string, n int, start bool) string {\n\t\tif n == 0 {\n\t\t\treturn s\n\t\t}\n\t\tif p == \"\" {\n\t\t\tp = \" \"\n\t\t}\n\t\tvar b strings.Builder\n\t\tss := utf16.Encode([]rune(s))\n\t\tb.Grow(n)\n\t\tn -= len(ss)\n\t\tif !start {\n\t\t\tb.WriteString(s)\n\t\t}\n\t\tif n > 0 {\n\t\t\tpp := utf16.Encode([]rune(p))\n\t\t\tfor n > 0 {\n\t\t\t\tif n > len(pp) {\n\t\t\t\t\tb.WriteString(p)\n\t\t\t\t\tn -= len(pp)\n\t\t\t\t} else {\n\t\t\t\t\tb.WriteString(string(utf16.Decode(pp[:n])))\n\t\t\t\t\tn = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif start {\n\t\t\tb.WriteString(s)\n\t\t}\n\t\treturn b.String()\n\t}\n\n\tfor i, a := range strs {\n\t\ttestUnaryOp(a, \"JSON.parse(JSON.stringify(a))\", a, t)\n\t\ttestUnaryOp(a, \"a.length\", int64(len(utf16.Encode([]rune(a)))), t)\n\t\tfor j, b := range strs {\n\t\t\ttestBinaryOp(a, b, \"a === b\", a == b, t)\n\t\t\ttestBinaryOp(a, b, \"a == b\", a == b, t)\n\t\t\ttestBinaryOp(a, b, \"a + b\", a+b, t)\n\t\t\ttestBinaryOp(a, b, \"a > b\", strings.Compare(a, b) > 0, t)\n\t\t\ttestBinaryOp(a, b, \"`A${a}B${b}C`\", \"A\"+a+\"B\"+b+\"C\", t)\n\t\t\ttestBinaryOp(a, b, \"a.indexOf(b)\", int64(indexOfResults[i][j]), t)\n\t\t\ttestBinaryOp(a, b, \"a.lastIndexOf(b)\", int64(lastIndexOfResults[i][j]), t)\n\t\t\ttestBinaryOp(a, b, \"a.padStart(32, b)\", pad(a, b, 32, true), t)\n\t\t\ttestBinaryOp(a, b, \"a.padEnd(32, b)\", pad(a, b, 32, false), t)\n\t\t\ttestBinaryOp(a, b, \"a.replace(b, '')\", strings.Replace(a, b, \"\", 1), t)\n\t\t}\n\t}\n}\n\nfunc TestStringFromUTF16(t *testing.T) {\n\ts := StringFromUTF16([]uint16{})\n\tif s.Length() != 0 || !s.SameAs(asciiString(\"\")) {\n\t\tt.Fatal(s)\n\t}\n\n\ts = StringFromUTF16([]uint16{0xD800})\n\tif s.Length() != 1 || s.CharAt(0) != 0xD800 {\n\t\tt.Fatal(s)\n\t}\n\n\ts = StringFromUTF16([]uint16{'A', 'B'})\n\tif !s.SameAs(asciiString(\"AB\")) {\n\t\tt.Fatal(s)\n\t}\n}\n\nfunc TestStringBuilder(t *testing.T) {\n\tt.Run(\"writeUTF8String-switch\", func(t *testing.T) {\n\t\tvar sb StringBuilder\n\t\tsb.WriteUTF8String(\"Head\")\n\t\tsb.WriteUTF8String(\"1bc\")\n\t\tif res := sb.String().String(); res != \"Head1bc\" {\n\t\t\tt.Fatal(res)\n\t\t}\n\t})\n}\n\nfunc BenchmarkASCIIConcat(b *testing.B) {\n\tvm := New()\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := vm.RunString(`{let result = \"ab\";\n\t\tfor (let i = 0 ; i < 10;i++) {\n\t\t\tresult += result;\n\t\t}}`)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"Unexpected errors %s\", err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "string_unicode.go",
          "type": "blob",
          "size": 12.0263671875,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"hash/maphash\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n\n\t\"github.com/dop251/goja/parser\"\n\t\"github.com/dop251/goja/unistring\"\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n)\n\ntype unicodeString []uint16\n\ntype unicodeRuneReader struct {\n\ts   unicodeString\n\tpos int\n}\n\ntype utf16RuneReader struct {\n\ts   unicodeString\n\tpos int\n}\n\n// passes through invalid surrogate pairs\ntype lenientUtf16Decoder struct {\n\tutf16Reader utf16Reader\n\tprev        uint16\n\tprevSet     bool\n}\n\n// StringBuilder serves similar purpose to strings.Builder, except it works with ECMAScript String.\n// Use it to efficiently build 'native' ECMAScript values that either contain invalid UTF-16 surrogate pairs\n// (and therefore cannot be represented as UTF-8) or never expected to be exported to Go. See also\n// StringFromUTF16.\ntype StringBuilder struct {\n\tasciiBuilder   strings.Builder\n\tunicodeBuilder unicodeStringBuilder\n}\n\ntype unicodeStringBuilder struct {\n\tbuf     []uint16\n\tunicode bool\n}\n\nvar (\n\tInvalidRuneError = errors.New(\"invalid rune\")\n)\n\nfunc (rr *utf16RuneReader) readChar() (c uint16, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tc = rr.s[rr.pos]\n\t\trr.pos++\n\t\treturn\n\t}\n\terr = io.EOF\n\treturn\n}\n\nfunc (rr *utf16RuneReader) ReadRune() (r rune, size int, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tr = rune(rr.s[rr.pos])\n\t\trr.pos++\n\t\tsize = 1\n\t\treturn\n\t}\n\terr = io.EOF\n\treturn\n}\n\nfunc (rr *lenientUtf16Decoder) ReadRune() (r rune, size int, err error) {\n\tvar c uint16\n\tif rr.prevSet {\n\t\tc = rr.prev\n\t\trr.prevSet = false\n\t} else {\n\t\tc, err = rr.utf16Reader.readChar()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tsize = 1\n\tif isUTF16FirstSurrogate(c) {\n\t\tsecond, err1 := rr.utf16Reader.readChar()\n\t\tif err1 != nil {\n\t\t\tif err1 != io.EOF {\n\t\t\t\terr = err1\n\t\t\t} else {\n\t\t\t\tr = rune(c)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif isUTF16SecondSurrogate(second) {\n\t\t\tr = utf16.DecodeRune(rune(c), rune(second))\n\t\t\tsize++\n\t\t\treturn\n\t\t} else {\n\t\t\trr.prev = second\n\t\t\trr.prevSet = true\n\t\t}\n\t}\n\tr = rune(c)\n\treturn\n}\n\nfunc (rr *unicodeRuneReader) ReadRune() (r rune, size int, err error) {\n\tif rr.pos < len(rr.s) {\n\t\tc := rr.s[rr.pos]\n\t\tsize++\n\t\trr.pos++\n\t\tif isUTF16FirstSurrogate(c) {\n\t\t\tif rr.pos < len(rr.s) {\n\t\t\t\tsecond := rr.s[rr.pos]\n\t\t\t\tif isUTF16SecondSurrogate(second) {\n\t\t\t\t\tr = utf16.DecodeRune(rune(c), rune(second))\n\t\t\t\t\tsize++\n\t\t\t\t\trr.pos++\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = InvalidRuneError\n\t\t} else if isUTF16SecondSurrogate(c) {\n\t\t\terr = InvalidRuneError\n\t\t}\n\t\tr = rune(c)\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nfunc (b *unicodeStringBuilder) Grow(n int) {\n\tif len(b.buf) == 0 {\n\t\tn++\n\t}\n\tif cap(b.buf)-len(b.buf) < n {\n\t\tbuf := make([]uint16, len(b.buf), 2*cap(b.buf)+n)\n\t\tcopy(buf, b.buf)\n\t\tb.buf = buf\n\t}\n}\n\nfunc (b *unicodeStringBuilder) ensureStarted(initialSize int) {\n\tb.Grow(initialSize)\n\tif len(b.buf) == 0 {\n\t\tb.buf = append(b.buf, unistring.BOM)\n\t}\n}\n\n// assumes already started\nfunc (b *unicodeStringBuilder) writeString(s String) {\n\ta, u := devirtualizeString(s)\n\tif u != nil {\n\t\tb.buf = append(b.buf, u[1:]...)\n\t\tb.unicode = true\n\t} else {\n\t\tfor i := 0; i < len(a); i++ {\n\t\t\tb.buf = append(b.buf, uint16(a[i]))\n\t\t}\n\t}\n}\n\nfunc (b *unicodeStringBuilder) String() String {\n\tif b.unicode {\n\t\treturn unicodeString(b.buf)\n\t}\n\tif len(b.buf) < 2 {\n\t\treturn stringEmpty\n\t}\n\tbuf := make([]byte, 0, len(b.buf)-1)\n\tfor _, c := range b.buf[1:] {\n\t\tbuf = append(buf, byte(c))\n\t}\n\treturn asciiString(buf)\n}\n\nfunc (b *unicodeStringBuilder) WriteRune(r rune) {\n\tb.ensureStarted(2)\n\tb.writeRuneFast(r)\n}\n\n// assumes already started\nfunc (b *unicodeStringBuilder) writeRuneFast(r rune) {\n\tif r <= 0xFFFF {\n\t\tb.buf = append(b.buf, uint16(r))\n\t\tif !b.unicode && r >= utf8.RuneSelf {\n\t\t\tb.unicode = true\n\t\t}\n\t} else {\n\t\tfirst, second := utf16.EncodeRune(r)\n\t\tb.buf = append(b.buf, uint16(first), uint16(second))\n\t\tb.unicode = true\n\t}\n}\n\nfunc (b *unicodeStringBuilder) writeASCIIString(bytes string) {\n\tfor _, c := range bytes {\n\t\tb.buf = append(b.buf, uint16(c))\n\t}\n}\n\nfunc (b *unicodeStringBuilder) writeUnicodeString(str unicodeString) {\n\tb.buf = append(b.buf, str[1:]...)\n\tb.unicode = true\n}\n\nfunc (b *StringBuilder) ascii() bool {\n\treturn len(b.unicodeBuilder.buf) == 0\n}\n\nfunc (b *StringBuilder) WriteString(s String) {\n\ta, u := devirtualizeString(s)\n\tif u != nil {\n\t\tb.switchToUnicode(u.Length())\n\t\tb.unicodeBuilder.writeUnicodeString(u)\n\t} else {\n\t\tif b.ascii() {\n\t\t\tb.asciiBuilder.WriteString(string(a))\n\t\t} else {\n\t\t\tb.unicodeBuilder.writeASCIIString(string(a))\n\t\t}\n\t}\n}\n\nfunc (b *StringBuilder) WriteUTF8String(s string) {\n\tfirstUnicodeIdx := 0\n\tif b.ascii() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] >= utf8.RuneSelf {\n\t\t\t\tb.switchToUnicode(len(s))\n\t\t\t\tb.unicodeBuilder.writeASCIIString(s[:i])\n\t\t\t\tfirstUnicodeIdx = i\n\t\t\t\tgoto unicode\n\t\t\t}\n\t\t}\n\t\tb.asciiBuilder.WriteString(s)\n\t\treturn\n\t}\nunicode:\n\tfor _, r := range s[firstUnicodeIdx:] {\n\t\tb.unicodeBuilder.writeRuneFast(r)\n\t}\n}\n\nfunc (b *StringBuilder) writeASCII(s string) {\n\tif b.ascii() {\n\t\tb.asciiBuilder.WriteString(s)\n\t} else {\n\t\tb.unicodeBuilder.writeASCIIString(s)\n\t}\n}\n\nfunc (b *StringBuilder) WriteRune(r rune) {\n\tif r < utf8.RuneSelf {\n\t\tif b.ascii() {\n\t\t\tb.asciiBuilder.WriteByte(byte(r))\n\t\t} else {\n\t\t\tb.unicodeBuilder.writeRuneFast(r)\n\t\t}\n\t} else {\n\t\tvar extraLen int\n\t\tif r <= 0xFFFF {\n\t\t\textraLen = 1\n\t\t} else {\n\t\t\textraLen = 2\n\t\t}\n\t\tb.switchToUnicode(extraLen)\n\t\tb.unicodeBuilder.writeRuneFast(r)\n\t}\n}\n\nfunc (b *StringBuilder) String() String {\n\tif b.ascii() {\n\t\treturn asciiString(b.asciiBuilder.String())\n\t}\n\treturn b.unicodeBuilder.String()\n}\n\nfunc (b *StringBuilder) Grow(n int) {\n\tif b.ascii() {\n\t\tb.asciiBuilder.Grow(n)\n\t} else {\n\t\tb.unicodeBuilder.Grow(n)\n\t}\n}\n\n// LikelyUnicode hints to the builder that the resulting string is likely to contain Unicode (non-ASCII) characters.\n// The argument is an extra capacity (in characters) to reserve on top of the current length (it's like calling\n// Grow() afterwards).\n// This method may be called at any point (not just when the buffer is empty), although for efficiency it should\n// be called as early as possible.\nfunc (b *StringBuilder) LikelyUnicode(extraLen int) {\n\tb.switchToUnicode(extraLen)\n}\n\nfunc (b *StringBuilder) switchToUnicode(extraLen int) {\n\tif b.ascii() {\n\t\tc := b.asciiBuilder.Cap()\n\t\tnewCap := b.asciiBuilder.Len() + extraLen\n\t\tif newCap < c {\n\t\t\tnewCap = c\n\t\t}\n\t\tb.unicodeBuilder.ensureStarted(newCap)\n\t\tb.unicodeBuilder.writeASCIIString(b.asciiBuilder.String())\n\t\tb.asciiBuilder.Reset()\n\t}\n}\n\nfunc (b *StringBuilder) WriteSubstring(source String, start int, end int) {\n\ta, us := devirtualizeString(source)\n\tif us == nil {\n\t\tif b.ascii() {\n\t\t\tb.asciiBuilder.WriteString(string(a[start:end]))\n\t\t} else {\n\t\t\tb.unicodeBuilder.writeASCIIString(string(a[start:end]))\n\t\t}\n\t\treturn\n\t}\n\tif b.ascii() {\n\t\tuc := false\n\t\tfor i := start; i < end; i++ {\n\t\t\tif us.CharAt(i) >= utf8.RuneSelf {\n\t\t\t\tuc = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif uc {\n\t\t\tb.switchToUnicode(end - start + 1)\n\t\t} else {\n\t\t\tb.asciiBuilder.Grow(end - start + 1)\n\t\t\tfor i := start; i < end; i++ {\n\t\t\t\tb.asciiBuilder.WriteByte(byte(us.CharAt(i)))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tb.unicodeBuilder.buf = append(b.unicodeBuilder.buf, us[start+1:end+1]...)\n\tb.unicodeBuilder.unicode = true\n}\n\nfunc (s unicodeString) Reader() io.RuneReader {\n\treturn &unicodeRuneReader{\n\t\ts: s[1:],\n\t}\n}\n\nfunc (s unicodeString) utf16Reader() utf16Reader {\n\treturn &utf16RuneReader{\n\t\ts: s[1:],\n\t}\n}\n\nfunc (s unicodeString) utf16RuneReader() io.RuneReader {\n\treturn &utf16RuneReader{\n\t\ts: s[1:],\n\t}\n}\n\nfunc (s unicodeString) utf16Runes() []rune {\n\trunes := make([]rune, len(s)-1)\n\tfor i, ch := range s[1:] {\n\t\trunes[i] = rune(ch)\n\t}\n\treturn runes\n}\n\nfunc (s unicodeString) ToInteger() int64 {\n\treturn 0\n}\n\nfunc (s unicodeString) toString() String {\n\treturn s\n}\n\nfunc (s unicodeString) ToString() Value {\n\treturn s\n}\n\nfunc (s unicodeString) ToFloat() float64 {\n\treturn math.NaN()\n}\n\nfunc (s unicodeString) ToBoolean() bool {\n\treturn len(s) > 0\n}\n\nfunc (s unicodeString) toTrimmedUTF8() string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings.Trim(s.String(), parser.WhitespaceChars)\n}\n\nfunc (s unicodeString) ToNumber() Value {\n\treturn asciiString(s.toTrimmedUTF8()).ToNumber()\n}\n\nfunc (s unicodeString) ToObject(r *Runtime) *Object {\n\treturn r._newString(s, r.getStringPrototype())\n}\n\nfunc (s unicodeString) equals(other unicodeString) bool {\n\tif len(s) != len(other) {\n\t\treturn false\n\t}\n\tfor i, r := range s {\n\t\tif r != other[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s unicodeString) SameAs(other Value) bool {\n\treturn s.StrictEquals(other)\n}\n\nfunc (s unicodeString) Equals(other Value) bool {\n\tif s.StrictEquals(other) {\n\t\treturn true\n\t}\n\n\tif o, ok := other.(*Object); ok {\n\t\treturn s.Equals(o.toPrimitive())\n\t}\n\treturn false\n}\n\nfunc (s unicodeString) StrictEquals(other Value) bool {\n\tif otherStr, ok := other.(unicodeString); ok {\n\t\treturn s.equals(otherStr)\n\t}\n\tif otherStr, ok := other.(*importedString); ok {\n\t\totherStr.ensureScanned()\n\t\tif otherStr.u != nil {\n\t\t\treturn s.equals(otherStr.u)\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (s unicodeString) baseObject(r *Runtime) *Object {\n\tss := r.getStringSingleton()\n\tss.value = s\n\tss.setLength()\n\treturn ss.val\n}\n\nfunc (s unicodeString) CharAt(idx int) uint16 {\n\treturn s[idx+1]\n}\n\nfunc (s unicodeString) Length() int {\n\treturn len(s) - 1\n}\n\nfunc (s unicodeString) Concat(other String) String {\n\ta, u := devirtualizeString(other)\n\tif u != nil {\n\t\tb := make(unicodeString, len(s)+len(u)-1)\n\t\tcopy(b, s)\n\t\tcopy(b[len(s):], u[1:])\n\t\treturn b\n\t}\n\tb := make([]uint16, len(s)+len(a))\n\tcopy(b, s)\n\tb1 := b[len(s):]\n\tfor i := 0; i < len(a); i++ {\n\t\tb1[i] = uint16(a[i])\n\t}\n\treturn unicodeString(b)\n}\n\nfunc (s unicodeString) Substring(start, end int) String {\n\tss := s[start+1 : end+1]\n\tfor _, c := range ss {\n\t\tif c >= utf8.RuneSelf {\n\t\t\tb := make(unicodeString, end-start+1)\n\t\t\tb[0] = unistring.BOM\n\t\t\tcopy(b[1:], ss)\n\t\t\treturn b\n\t\t}\n\t}\n\tas := make([]byte, end-start)\n\tfor i, c := range ss {\n\t\tas[i] = byte(c)\n\t}\n\treturn asciiString(as)\n}\n\nfunc (s unicodeString) String() string {\n\treturn string(utf16.Decode(s[1:]))\n}\n\nfunc (s unicodeString) CompareTo(other String) int {\n\t// TODO handle invalid UTF-16\n\treturn strings.Compare(s.String(), other.String())\n}\n\nfunc (s unicodeString) index(substr String, start int) int {\n\tvar ss []uint16\n\ta, u := devirtualizeString(substr)\n\tif u != nil {\n\t\tss = u[1:]\n\t} else {\n\t\tss = make([]uint16, len(a))\n\t\tfor i := 0; i < len(a); i++ {\n\t\t\tss[i] = uint16(a[i])\n\t\t}\n\t}\n\ts1 := s[1:]\n\t// TODO: optimise\n\tend := len(s1) - len(ss)\n\tfor start <= end {\n\t\tfor i := 0; i < len(ss); i++ {\n\t\t\tif s1[start+i] != ss[i] {\n\t\t\t\tgoto nomatch\n\t\t\t}\n\t\t}\n\n\t\treturn start\n\tnomatch:\n\t\tstart++\n\t}\n\treturn -1\n}\n\nfunc (s unicodeString) lastIndex(substr String, start int) int {\n\tvar ss []uint16\n\ta, u := devirtualizeString(substr)\n\tif u != nil {\n\t\tss = u[1:]\n\t} else {\n\t\tss = make([]uint16, len(a))\n\t\tfor i := 0; i < len(a); i++ {\n\t\t\tss[i] = uint16(a[i])\n\t\t}\n\t}\n\n\ts1 := s[1:]\n\tif maxStart := len(s1) - len(ss); start > maxStart {\n\t\tstart = maxStart\n\t}\n\t// TODO: optimise\n\tfor start >= 0 {\n\t\tfor i := 0; i < len(ss); i++ {\n\t\t\tif s1[start+i] != ss[i] {\n\t\t\t\tgoto nomatch\n\t\t\t}\n\t\t}\n\n\t\treturn start\n\tnomatch:\n\t\tstart--\n\t}\n\treturn -1\n}\n\nfunc unicodeStringFromRunes(r []rune) unicodeString {\n\treturn unistring.NewFromRunes(r).AsUtf16()\n}\n\nfunc toLower(s string) String {\n\tcaser := cases.Lower(language.Und)\n\tr := []rune(caser.String(s))\n\t// Workaround\n\tascii := true\n\tfor i := 0; i < len(r)-1; i++ {\n\t\tif (i == 0 || r[i-1] != 0x3b1) && r[i] == 0x345 && r[i+1] == 0x3c2 {\n\t\t\ti++\n\t\t\tr[i] = 0x3c3\n\t\t}\n\t\tif r[i] >= utf8.RuneSelf {\n\t\t\tascii = false\n\t\t}\n\t}\n\tif ascii {\n\t\tascii = r[len(r)-1] < utf8.RuneSelf\n\t}\n\tif ascii {\n\t\treturn asciiString(r)\n\t}\n\treturn unicodeStringFromRunes(r)\n}\n\nfunc (s unicodeString) toLower() String {\n\treturn toLower(s.String())\n}\n\nfunc (s unicodeString) toUpper() String {\n\tcaser := cases.Upper(language.Und)\n\treturn newStringValue(caser.String(s.String()))\n}\n\nfunc (s unicodeString) Export() interface{} {\n\treturn s.String()\n}\n\nfunc (s unicodeString) ExportType() reflect.Type {\n\treturn reflectTypeString\n}\n\nfunc (s unicodeString) hash(hash *maphash.Hash) uint64 {\n\t_, _ = hash.WriteString(string(unistring.FromUtf16(s)))\n\th := hash.Sum64()\n\thash.Reset()\n\treturn h\n}\n\nfunc (s unicodeString) string() unistring.String {\n\treturn unistring.FromUtf16(s)\n}\n"
        },
        {
          "name": "tc39_norace_test.go",
          "type": "blob",
          "size": 0.3115234375,
          "content": "//go:build !race\n// +build !race\n\npackage goja\n\nimport \"testing\"\n\n// Prevent linter warnings about unused type\nvar _ = tc39Test{name: \"\", f: nil}\n\nfunc (ctx *tc39TestCtx) runTest(name string, f func(t *testing.T)) {\n\tctx.t.Run(name, func(t *testing.T) {\n\t\tt.Parallel()\n\t\tf(t)\n\t})\n}\n\nfunc (ctx *tc39TestCtx) flush() {\n}\n"
        },
        {
          "name": "tc39_race_test.go",
          "type": "blob",
          "size": 0.607421875,
          "content": "//go:build race\n// +build race\n\npackage goja\n\nimport (\n\t\"testing\"\n)\n\nconst (\n\ttc39MaxTestGroupSize = 8000 // to prevent race detector complaining about too many goroutines\n)\n\nfunc (ctx *tc39TestCtx) runTest(name string, f func(t *testing.T)) {\n\tctx.testQueue = append(ctx.testQueue, tc39Test{name: name, f: f})\n\tif len(ctx.testQueue) >= tc39MaxTestGroupSize {\n\t\tctx.flush()\n\t}\n}\n\nfunc (ctx *tc39TestCtx) flush() {\n\tctx.t.Run(\"tc39\", func(t *testing.T) {\n\t\tfor _, tc := range ctx.testQueue {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\ttc.f(t)\n\t\t\t})\n\t\t}\n\t})\n\tctx.testQueue = ctx.testQueue[:0]\n}\n"
        },
        {
          "name": "tc39_test.go",
          "type": "blob",
          "size": 27.099609375,
          "content": "package goja\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"runtime/debug\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"gopkg.in/yaml.v2\"\n)\n\nconst (\n\ttc39BASE = \"testdata/test262\"\n)\n\nvar (\n\tinvalidFormatError = errors.New(\"Invalid file format\")\n\n\tignorableTestError = newSymbol(stringEmpty)\n)\n\nvar (\n\tskipPrefixes prefixList\n\n\tskipList = map[string]bool{\n\n\t\t// out-of-date (https://github.com/tc39/test262/issues/3407)\n\t\t\"test/language/expressions/prefix-increment/S11.4.4_A6_T3.js\":        true,\n\t\t\"test/language/expressions/prefix-increment/S11.4.4_A6_T2.js\":        true,\n\t\t\"test/language/expressions/prefix-increment/S11.4.4_A6_T1.js\":        true,\n\t\t\"test/language/expressions/prefix-decrement/S11.4.5_A6_T3.js\":        true,\n\t\t\"test/language/expressions/prefix-decrement/S11.4.5_A6_T2.js\":        true,\n\t\t\"test/language/expressions/prefix-decrement/S11.4.5_A6_T1.js\":        true,\n\t\t\"test/language/expressions/postfix-increment/S11.3.1_A6_T3.js\":       true,\n\t\t\"test/language/expressions/postfix-increment/S11.3.1_A6_T2.js\":       true,\n\t\t\"test/language/expressions/postfix-increment/S11.3.1_A6_T1.js\":       true,\n\t\t\"test/language/expressions/postfix-decrement/S11.3.2_A6_T3.js\":       true,\n\t\t\"test/language/expressions/postfix-decrement/S11.3.2_A6_T2.js\":       true,\n\t\t\"test/language/expressions/postfix-decrement/S11.3.2_A6_T1.js\":       true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.1_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.1_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.1_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.11_T4.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.11_T2.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.11_T1.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.10_T4.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.10_T2.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.10_T1.js\": true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.9_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.9_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.9_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.8_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.8_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.8_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.7_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.7_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.7_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.6_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.6_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.6_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.5_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.5_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.5_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.4_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.4_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.4_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.3_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.3_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.3_T1.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.2_T4.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.2_T2.js\":  true,\n\t\t\"test/language/expressions/compound-assignment/S11.13.2_A7.2_T1.js\":  true,\n\t\t\"test/language/expressions/assignment/S11.13.1_A7_T3.js\":             true,\n\n\t\t// timezone\n\t\t\"test/built-ins/Date/prototype/toISOString/15.9.5.43-0-8.js\":  true,\n\t\t\"test/built-ins/Date/prototype/toISOString/15.9.5.43-0-9.js\":  true,\n\t\t\"test/built-ins/Date/prototype/toISOString/15.9.5.43-0-10.js\": true,\n\n\t\t// floating point date calculations\n\t\t\"test/built-ins/Date/UTC/fp-evaluation-order.js\": true,\n\n\t\t// quantifier integer limit in regexp\n\t\t\"test/built-ins/RegExp/quantifier-integer-limit.js\": true,\n\n\t\t// GetFunctionRealm\n\t\t\"test/built-ins/Function/internals/Construct/base-ctor-revoked-proxy.js\": true,\n\n\t\t// Uses deprecated __lookupGetter__/__lookupSetter__\n\t\t\"test/language/expressions/class/elements/private-getter-is-not-a-own-property.js\": true,\n\t\t\"test/language/expressions/class/elements/private-setter-is-not-a-own-property.js\": true,\n\t\t\"test/language/statements/class/elements/private-setter-is-not-a-own-property.js\":  true,\n\t\t\"test/language/statements/class/elements/private-getter-is-not-a-own-property.js\":  true,\n\n\t\t// restricted unicode regexp syntax\n\t\t\"test/built-ins/RegExp/unicode_restricted_quantifiable_assertion.js\":         true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_octal_escape.js\":                   true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_incomple_quantifier.js\":            true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_incomplete_quantifier.js\":          true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_identity_escape_x.js\":              true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_identity_escape_u.js\":              true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_identity_escape_c.js\":              true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_identity_escape_alpha.js\":          true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_identity_escape.js\":                true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_brackets.js\":                       true,\n\t\t\"test/built-ins/RegExp/unicode_restricted_character_class_escape.js\":         true,\n\t\t\"test/annexB/built-ins/RegExp/prototype/compile/pattern-string-invalid-u.js\": true,\n\n\t\t// Because goja parser works in UTF-8 it is not possible to pass strings containing invalid UTF-16 code points.\n\t\t// This is mitigated by escaping them as \\uXXXX, however because of this the RegExp source becomes\n\t\t// `\\uXXXX` instead of `<the actual UTF-16 code point of XXXX>`.\n\t\t// The resulting RegExp will work exactly the same, but it causes these two tests to fail.\n\t\t\"test/annexB/built-ins/RegExp/RegExp-leading-escape-BMP.js\":  true,\n\t\t\"test/annexB/built-ins/RegExp/RegExp-trailing-escape-BMP.js\": true,\n\t\t\"test/language/literals/regexp/S7.8.5_A1.4_T2.js\":            true,\n\t\t\"test/language/literals/regexp/S7.8.5_A1.1_T2.js\":            true,\n\t\t\"test/language/literals/regexp/S7.8.5_A2.1_T2.js\":            true,\n\t\t\"test/language/literals/regexp/S7.8.5_A2.4_T2.js\":            true,\n\n\t\t// async generator\n\t\t\"test/language/expressions/optional-chaining/member-expression.js\":                                                                            true,\n\t\t\"test/language/expressions/class/elements/same-line-async-method-rs-static-async-generator-method-privatename-identifier-alt.js\":              true,\n\t\t\"test/language/expressions/class/elements/same-line-async-method-rs-static-async-generator-method-privatename-identifier.js\":                  true,\n\t\t\"test/language/destructuring/binding/syntax/destructuring-object-parameters-function-arguments-length.js\":                                     true,\n\t\t\"test/language/destructuring/binding/syntax/destructuring-array-parameters-function-arguments-length.js\":                                      true,\n\t\t\"test/language/comments/hashbang/function-constructor.js\":                                                                                     true,\n\t\t\"test/language/statements/class/elements/after-same-line-static-async-method-rs-static-async-generator-method-privatename-identifier.js\":      true,\n\t\t\"test/language/statements/class/elements/after-same-line-static-async-method-rs-static-async-generator-method-privatename-identifier-alt.js\":  true,\n\t\t\"test/language/statements/class/elements/same-line-async-method-rs-static-async-generator-method-privatename-identifier.js\":                   true,\n\t\t\"test/language/statements/class/elements/same-line-async-method-rs-static-async-generator-method-privatename-identifier-alt.js\":               true,\n\t\t\"test/language/expressions/class/elements/after-same-line-static-async-method-rs-static-async-generator-method-privatename-identifier-alt.js\": true,\n\t\t\"test/language/expressions/class/elements/after-same-line-static-async-method-rs-static-async-generator-method-privatename-identifier.js\":     true,\n\t\t\"test/built-ins/Object/seal/seal-asyncgeneratorfunction.js\":                                                                                   true,\n\t\t\"test/language/statements/switch/scope-lex-async-generator.js\":                                                                                true,\n\t\t\"test/language/statements/class/elements/private-async-generator-method-name.js\":                                                              true,\n\t\t\"test/language/expressions/class/elements/private-async-generator-method-name.js\":                                                             true,\n\t\t\"test/language/expressions/async-generator/name.js\":                                                                                           true,\n\t\t\"test/language/statements/class/elements/same-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                            true,\n\t\t\"test/language/statements/class/elements/same-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                        true,\n\t\t\"test/language/statements/class/elements/new-sc-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                          true,\n\t\t\"test/language/statements/class/elements/new-sc-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                      true,\n\t\t\"test/language/statements/class/elements/after-same-line-static-gen-rs-static-async-generator-method-privatename-identifier.js\":               true,\n\t\t\"test/language/statements/class/elements/after-same-line-static-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":           true,\n\t\t\"test/language/statements/class/elements/after-same-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                      true,\n\t\t\"test/language/statements/class/elements/after-same-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                  true,\n\t\t\"test/language/expressions/class/elements/same-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                           true,\n\t\t\"test/language/expressions/class/elements/same-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                       true,\n\t\t\"test/language/expressions/class/elements/new-sc-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                         true,\n\t\t\"test/language/expressions/class/elements/new-sc-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                     true,\n\t\t\"test/language/expressions/class/elements/after-same-line-static-gen-rs-static-async-generator-method-privatename-identifier.js\":              true,\n\t\t\"test/language/expressions/class/elements/after-same-line-static-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":          true,\n\t\t\"test/language/expressions/class/elements/after-same-line-gen-rs-static-async-generator-method-privatename-identifier.js\":                     true,\n\t\t\"test/language/expressions/class/elements/after-same-line-gen-rs-static-async-generator-method-privatename-identifier-alt.js\":                 true,\n\t\t\"test/built-ins/GeneratorFunction/is-a-constructor.js\":                                                                                        true,\n\n\t\t// async iterator\n\t\t\"test/language/expressions/optional-chaining/iteration-statement-for-await-of.js\": true,\n\n\t\t// legacy number literals\n\t\t\"test/language/literals/numeric/non-octal-decimal-integer.js\": true,\n\t\t\"test/language/literals/string/S7.8.4_A4.3_T2.js\":             true,\n\t\t\"test/language/literals/string/S7.8.4_A4.3_T1.js\":             true,\n\n\t\t// Regexp\n\t\t\"test/language/literals/regexp/invalid-range-negative-lookbehind.js\":    true,\n\t\t\"test/language/literals/regexp/invalid-range-lookbehind.js\":             true,\n\t\t\"test/language/literals/regexp/invalid-optional-negative-lookbehind.js\": true,\n\t\t\"test/language/literals/regexp/invalid-optional-lookbehind.js\":          true,\n\n\t\t// unicode full case folding\n\t\t\"test/built-ins/RegExp/unicode_full_case_folding.js\": true,\n\n\t\t// FIXME bugs\n\n\t\t// Left-hand side as a CoverParenthesizedExpression\n\t\t\"test/language/expressions/assignment/fn-name-lhs-cover.js\": true,\n\n\t\t// Character \\ missing from character class [\\c]\n\t\t\"test/annexB/built-ins/RegExp/RegExp-invalid-control-escape-character-class.js\": true,\n\t\t\"test/annexB/built-ins/RegExp/RegExp-control-escape-russian-letter.js\":          true,\n\n\t\t// Skip due to regexp named groups\n\t\t\"test/built-ins/String/prototype/replaceAll/searchValue-replacer-RegExp-call.js\": true,\n\n\t\t\"test/built-ins/RegExp/nullable-quantifier.js\":               true,\n\t\t\"test/built-ins/RegExp/lookahead-quantifier-match-groups.js\": true,\n\t}\n\n\tfeaturesBlackList = []string{\n\t\t\"async-iteration\",\n\t\t\"Symbol.asyncIterator\",\n\t\t\"resizable-arraybuffer\",\n\t\t\"regexp-named-groups\",\n\t\t\"regexp-duplicate-named-groups\",\n\t\t\"regexp-unicode-property-escapes\",\n\t\t\"regexp-match-indices\",\n\t\t\"regexp-modifiers\",\n\t\t\"RegExp.escape\",\n\t\t\"legacy-regexp\",\n\t\t\"tail-call-optimization\",\n\t\t\"Temporal\",\n\t\t\"import-assertions\",\n\t\t\"dynamic-import\",\n\t\t\"logical-assignment-operators\",\n\t\t\"import.meta\",\n\t\t\"Atomics\",\n\t\t\"Atomics.waitAsync\",\n\t\t\"Atomics.pause\",\n\t\t\"FinalizationRegistry\",\n\t\t\"WeakRef\",\n\t\t\"__getter__\",\n\t\t\"__setter__\",\n\t\t\"ShadowRealm\",\n\t\t\"SharedArrayBuffer\",\n\t\t\"decorators\",\n\t\t\"regexp-v-flag\",\n\t\t\"iterator-helpers\",\n\t\t\"symbols-as-weakmap-keys\",\n\t\t\"uint8array-base64\",\n\t\t\"String.prototype.toWellFormed\",\n\t\t\"explicit-resource-management\",\n\t\t\"set-methods\",\n\t\t\"promise-try\",\n\t\t\"promise-with-resolvers\",\n\t\t\"array-grouping\",\n\t\t\"Math.sumPrecise\",\n\t\t\"Float16Array\",\n\t\t\"arraybuffer-transfer\",\n\t\t\"Array.fromAsync\",\n\t\t\"String.prototype.isWellFormed\",\n\t}\n)\n\nvar goVersion *semver.Version\n\nfunc init() {\n\tif info, ok := debug.ReadBuildInfo(); ok {\n\t\tgoVersion = semver.MustParse(strings.TrimPrefix(info.GoVersion, \"go\"))\n\t} else {\n\t\tpanic(\"Could not read build info\")\n\t}\n\n\tskip := func(prefixes ...string) {\n\t\tfor _, prefix := range prefixes {\n\t\t\tskipPrefixes.Add(prefix)\n\t\t}\n\t}\n\n\tif goVersion.LessThan(semver.MustParse(\"1.21\")) {\n\t\tskip(\n\t\t\t// Go <1.21 only supports Unicode 13\n\t\t\t\"test/language/identifiers/start-unicode-14.\",\n\t\t\t\"test/language/identifiers/part-unicode-14.\",\n\t\t\t\"test/language/identifiers/start-unicode-15.\",\n\t\t\t\"test/language/identifiers/part-unicode-15.\",\n\t\t)\n\t}\n\n\tskip(\n\t\t// generators and async generators (harness/hidden-constructors.js)\n\t\t\"test/built-ins/Async\",\n\n\t\t// async generators\n\t\t\"test/language/statements/class/elements/wrapped-in-sc-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/same-line-method-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/regular-definitions-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/private-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/new-sc-line-method-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/multiple-stacked-definitions-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/new-no-sc-line-method-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/multiple-definitions-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/after-same-line-static-method-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/after-same-line-method-rs-static-async-generator-\",\n\t\t\"test/language/statements/class/elements/after-same-line-static-method-rs-static-async-generator-\",\n\n\t\t\"test/language/expressions/class/elements/wrapped-in-sc-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/same-line-method-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/regular-definitions-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/private-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/new-sc-line-method-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/multiple-stacked-definitions-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/new-no-sc-line-method-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/multiple-definitions-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/after-same-line-static-method-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/after-same-line-method-rs-static-async-generator-\",\n\t\t\"test/language/expressions/class/elements/after-same-line-static-method-rs-static-async-generator-\",\n\n\t\t\"test/language/eval-code/direct/async-gen-\",\n\n\t\t// restricted unicode regexp syntax\n\t\t\"test/language/literals/regexp/u-\",\n\n\t\t// legacy octal escape in strings in strict mode\n\t\t\"test/language/literals/string/legacy-octal-\",\n\t\t\"test/language/literals/string/legacy-non-octal-\",\n\n\t\t// modules\n\t\t\"test/language/export/\",\n\t\t\"test/language/import/\",\n\t\t\"test/language/module-code/\",\n\t)\n\n}\n\ntype tc39Test struct {\n\tname string\n\tf    func(t *testing.T)\n}\n\ntype tc39BenchmarkItem struct {\n\tname     string\n\tduration time.Duration\n}\n\ntype tc39BenchmarkData []tc39BenchmarkItem\n\ntype tc39TestCtx struct {\n\tbase         string\n\tt            *testing.T\n\tprgCache     map[string]*Program\n\tprgCacheLock sync.Mutex\n\tenableBench  bool\n\tbenchmark    tc39BenchmarkData\n\tbenchLock    sync.Mutex\n\tsabStub      *Program\n\t//lint:ignore U1000 Only used with race\n\ttestQueue []tc39Test\n}\n\ntype TC39MetaNegative struct {\n\tPhase, Type string\n}\n\ntype tc39Meta struct {\n\tNegative TC39MetaNegative\n\tIncludes []string\n\tFlags    []string\n\tFeatures []string\n\tEs5id    string\n\tEs6id    string\n\tEsid     string\n}\n\ntype prefixList struct {\n\tprefixes map[int]map[string]struct{}\n}\n\nfunc (pl *prefixList) Add(prefix string) {\n\tl := pl.prefixes[len(prefix)]\n\tif l == nil {\n\t\tl = make(map[string]struct{})\n\t\tif pl.prefixes == nil {\n\t\t\tpl.prefixes = make(map[int]map[string]struct{})\n\t\t}\n\t\tpl.prefixes[len(prefix)] = l\n\t}\n\tl[prefix] = struct{}{}\n}\n\nfunc (pl *prefixList) Match(s string) bool {\n\tfor l, prefixes := range pl.prefixes {\n\t\tif len(s) >= l {\n\t\t\tif _, exists := prefixes[s[:l]]; exists {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (m *tc39Meta) hasFlag(flag string) bool {\n\tfor _, f := range m.Flags {\n\t\tif f == flag {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc parseTC39File(name string) (*tc39Meta, string, error) {\n\tf, err := os.Open(name)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer f.Close()\n\n\tb, err := io.ReadAll(f)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tstr := string(b)\n\tmetaStart := strings.Index(str, \"/*---\")\n\tif metaStart == -1 {\n\t\treturn nil, \"\", invalidFormatError\n\t} else {\n\t\tmetaStart += 5\n\t}\n\tmetaEnd := strings.Index(str, \"---*/\")\n\tif metaEnd == -1 || metaEnd <= metaStart {\n\t\treturn nil, \"\", invalidFormatError\n\t}\n\n\tvar meta tc39Meta\n\terr = yaml.Unmarshal([]byte(str[metaStart:metaEnd]), &meta)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif meta.Negative.Type != \"\" && meta.Negative.Phase == \"\" {\n\t\treturn nil, \"\", errors.New(\"negative type is set, but phase isn't\")\n\t}\n\n\treturn &meta, str, nil\n}\n\nfunc (*tc39TestCtx) detachArrayBuffer(call FunctionCall) Value {\n\tif obj, ok := call.Argument(0).(*Object); ok {\n\t\tif buf, ok := obj.self.(*arrayBufferObject); ok {\n\t\t\tbuf.detach()\n\t\t\treturn _undefined\n\t\t}\n\t}\n\tpanic(typeError(\"detachArrayBuffer() is called with incompatible argument\"))\n}\n\nfunc (*tc39TestCtx) throwIgnorableTestError(FunctionCall) Value {\n\tpanic(ignorableTestError)\n}\n\nfunc (ctx *tc39TestCtx) runTC39Test(name, src string, meta *tc39Meta, t testing.TB) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tpanic(fmt.Sprintf(\"panic while running %s: %v\", name, x))\n\t\t}\n\t}()\n\tvm := New()\n\t_262 := vm.NewObject()\n\t_262.Set(\"detachArrayBuffer\", ctx.detachArrayBuffer)\n\t_262.Set(\"createRealm\", ctx.throwIgnorableTestError)\n\t_262.Set(\"evalScript\", func(call FunctionCall) Value {\n\t\tscript := call.Argument(0).String()\n\t\tresult, err := vm.RunString(script)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn result\n\t})\n\tvm.Set(\"$262\", _262)\n\tvm.Set(\"IgnorableTestError\", ignorableTestError)\n\tvm.RunProgram(ctx.sabStub)\n\tvar out []string\n\tasync := meta.hasFlag(\"async\")\n\tif async {\n\t\terr := ctx.runFile(ctx.base, path.Join(\"harness\", \"doneprintHandle.js\"), vm)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvm.Set(\"print\", func(msg string) {\n\t\t\tout = append(out, msg)\n\t\t})\n\t} else {\n\t\tvm.Set(\"print\", t.Log)\n\t}\n\n\terr, early := ctx.runTC39Script(name, src, meta.Includes, vm)\n\n\tif err != nil {\n\t\tif meta.Negative.Type == \"\" {\n\t\t\tif err, ok := err.(*Exception); ok {\n\t\t\t\tif err.Value() == ignorableTestError {\n\t\t\t\t\tt.Skip(\"Test threw IgnorableTestError\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Fatalf(\"%s: %v\", name, err)\n\t\t} else {\n\t\t\tif (meta.Negative.Phase == \"early\" || meta.Negative.Phase == \"parse\") && !early || meta.Negative.Phase == \"runtime\" && early {\n\t\t\t\tt.Fatalf(\"%s: error %v happened at the wrong phase (expected %s)\", name, err, meta.Negative.Phase)\n\t\t\t}\n\t\t\tvar errType string\n\n\t\t\tswitch err := err.(type) {\n\t\t\tcase *Exception:\n\t\t\t\tif o, ok := err.Value().(*Object); ok {\n\t\t\t\t\tif c := o.Get(\"constructor\"); c != nil {\n\t\t\t\t\t\tif c, ok := c.(*Object); ok {\n\t\t\t\t\t\t\terrType = c.Get(\"name\").String()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.Fatalf(\"%s: error constructor is not an object (%v)\", name, o)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Fatalf(\"%s: error does not have a constructor (%v)\", name, o)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"%s: error is not an object (%v)\", name, err.Value())\n\t\t\t\t}\n\t\t\tcase *CompilerSyntaxError:\n\t\t\t\terrType = \"SyntaxError\"\n\t\t\tcase *CompilerReferenceError:\n\t\t\t\terrType = \"ReferenceError\"\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"%s: error is not a JS error: %v\", name, err)\n\t\t\t}\n\n\t\t\tif errType != meta.Negative.Type {\n\t\t\t\tvm.vm.prg.dumpCode(t.Logf)\n\t\t\t\tt.Fatalf(\"%s: unexpected error type (%s), expected (%s)\", name, errType, meta.Negative.Type)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif meta.Negative.Type != \"\" {\n\t\t\tvm.vm.prg.dumpCode(t.Logf)\n\t\t\tt.Fatalf(\"%s: Expected error: %v\", name, err)\n\t\t}\n\t}\n\n\tif vm.vm.sp != 0 {\n\t\tt.Fatalf(\"sp: %d\", vm.vm.sp)\n\t}\n\n\tif l := len(vm.vm.iterStack); l > 0 {\n\t\tt.Fatalf(\"iter stack is not empty: %d\", l)\n\t}\n\tif async {\n\t\tcomplete := false\n\t\tfor _, line := range out {\n\t\t\tif strings.HasPrefix(line, \"Test262:AsyncTestFailure:\") {\n\t\t\t\tt.Fatal(line)\n\t\t\t} else if line == \"Test262:AsyncTestComplete\" {\n\t\t\t\tcomplete = true\n\t\t\t}\n\t\t}\n\t\tif !complete {\n\t\t\tfor _, line := range out {\n\t\t\t\tt.Log(line)\n\t\t\t}\n\t\t\tt.Fatal(\"Test262:AsyncTestComplete was not printed\")\n\t\t}\n\t}\n}\n\nfunc (ctx *tc39TestCtx) runTC39File(name string, t testing.TB) {\n\tif skipList[name] {\n\t\tt.Skip(\"Excluded\")\n\t}\n\tif skipPrefixes.Match(name) {\n\t\tt.Skip(\"Excluded\")\n\t}\n\tp := path.Join(ctx.base, name)\n\tmeta, src, err := parseTC39File(p)\n\tif err != nil {\n\t\t//t.Fatalf(\"Could not parse %s: %v\", name, err)\n\t\tt.Errorf(\"Could not parse %s: %v\", name, err)\n\t\treturn\n\t}\n\tif meta.hasFlag(\"module\") {\n\t\tt.Skip(\"module\")\n\t}\n\tif meta.Es5id == \"\" {\n\t\tfor _, feature := range meta.Features {\n\t\t\tfor _, bl := range featuresBlackList {\n\t\t\t\tif feature == bl {\n\t\t\t\t\tt.Skip(\"Blacklisted feature\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar startTime time.Time\n\tif ctx.enableBench {\n\t\tstartTime = time.Now()\n\t}\n\n\thasRaw := meta.hasFlag(\"raw\")\n\n\tif hasRaw || !meta.hasFlag(\"onlyStrict\") {\n\t\t//log.Printf(\"Running normal test: %s\", name)\n\t\tt.Logf(\"Running normal test: %s\", name)\n\t\tctx.runTC39Test(name, src, meta, t)\n\t}\n\n\tif !hasRaw && !meta.hasFlag(\"noStrict\") {\n\t\t//log.Printf(\"Running strict test: %s\", name)\n\t\tt.Logf(\"Running strict test: %s\", name)\n\t\tctx.runTC39Test(name, \"'use strict';\\n\"+src, meta, t)\n\t}\n\n\tif ctx.enableBench {\n\t\tctx.benchLock.Lock()\n\t\tctx.benchmark = append(ctx.benchmark, tc39BenchmarkItem{\n\t\t\tname:     name,\n\t\t\tduration: time.Since(startTime),\n\t\t})\n\t\tctx.benchLock.Unlock()\n\t}\n\n}\n\nfunc (ctx *tc39TestCtx) init() {\n\tctx.prgCache = make(map[string]*Program)\n\tctx.sabStub = MustCompile(\"sabStub.js\", `\n\t\tObject.defineProperty(this, \"SharedArrayBuffer\", {\n\t\t\tget: function() {\n\t\t\t\tthrow IgnorableTestError;\n\t\t\t}\n\t\t});`,\n\t\tfalse)\n}\n\nfunc (ctx *tc39TestCtx) compile(base, name string) (*Program, error) {\n\tctx.prgCacheLock.Lock()\n\tdefer ctx.prgCacheLock.Unlock()\n\n\tprg := ctx.prgCache[name]\n\tif prg == nil {\n\t\tfname := path.Join(base, name)\n\t\tf, err := os.Open(fname)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tb, err := io.ReadAll(f)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstr := string(b)\n\t\tprg, err = Compile(name, str, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tctx.prgCache[name] = prg\n\t}\n\n\treturn prg, nil\n}\n\nfunc (ctx *tc39TestCtx) runFile(base, name string, vm *Runtime) error {\n\tprg, err := ctx.compile(base, name)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = vm.RunProgram(prg)\n\treturn err\n}\n\nfunc (ctx *tc39TestCtx) runTC39Script(name, src string, includes []string, vm *Runtime) (err error, early bool) {\n\tearly = true\n\terr = ctx.runFile(ctx.base, path.Join(\"harness\", \"assert.js\"), vm)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = ctx.runFile(ctx.base, path.Join(\"harness\", \"sta.js\"), vm)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor _, include := range includes {\n\t\terr = ctx.runFile(ctx.base, path.Join(\"harness\", include), vm)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar p *Program\n\tp, err = Compile(name, src, false)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tearly = false\n\t_, err = vm.RunProgram(p)\n\n\treturn\n}\n\nfunc (ctx *tc39TestCtx) runTC39Tests(name string) {\n\tfiles, err := os.ReadDir(path.Join(ctx.base, name))\n\tif err != nil {\n\t\tctx.t.Fatal(err)\n\t}\n\n\tfor _, file := range files {\n\t\tif file.Name()[0] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif file.IsDir() {\n\t\t\tctx.runTC39Tests(path.Join(name, file.Name()))\n\t\t} else {\n\t\t\tfileName := file.Name()\n\t\t\tif strings.HasSuffix(fileName, \".js\") && !strings.HasSuffix(fileName, \"_FIXTURE.js\") {\n\t\t\t\tname := path.Join(name, fileName)\n\t\t\t\tctx.runTest(name, func(t *testing.T) {\n\t\t\t\t\tctx.runTC39File(name, t)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc TestTC39(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\n\tif _, err := os.Stat(tc39BASE); err != nil {\n\t\tt.Skipf(\"If you want to run tc39 tests, download them from https://github.com/tc39/test262 and put into %s. See .tc39_test262_checkout.sh for the latest working commit id. (%v)\", tc39BASE, err)\n\t}\n\n\tctx := &tc39TestCtx{\n\t\tbase: tc39BASE,\n\t}\n\tctx.init()\n\t//ctx.enableBench = true\n\n\tt.Run(\"tc39\", func(t *testing.T) {\n\t\tctx.t = t\n\t\t//ctx.runTC39File(\"test/language/types/number/8.5.1.js\", t)\n\t\tctx.runTC39Tests(\"test/language\")\n\t\tctx.runTC39Tests(\"test/built-ins\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/String/prototype/substr\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/String/prototype/trimLeft\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/String/prototype/trimRight\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/escape\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/unescape\")\n\t\tctx.runTC39Tests(\"test/annexB/built-ins/RegExp\")\n\n\t\tctx.flush()\n\t})\n\n\tif ctx.enableBench {\n\t\tsort.Slice(ctx.benchmark, func(i, j int) bool {\n\t\t\treturn ctx.benchmark[i].duration > ctx.benchmark[j].duration\n\t\t})\n\t\tbench := ctx.benchmark\n\t\tif len(bench) > 50 {\n\t\t\tbench = bench[:50]\n\t\t}\n\t\tfor _, item := range bench {\n\t\t\tfmt.Printf(\"%s\\t%d\\n\", item.name, item.duration/time.Millisecond)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "token",
          "type": "tree",
          "content": null
        },
        {
          "name": "typedarrays.go",
          "type": "blob",
          "size": 33.8046875,
          "content": "package goja\n\nimport (\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\ntype byteOrder bool\n\nconst (\n\tbigEndian    byteOrder = false\n\tlittleEndian byteOrder = true\n)\n\nvar (\n\tnativeEndian byteOrder\n\n\tarrayBufferType = reflect.TypeOf(ArrayBuffer{})\n)\n\ntype typedArrayObjectCtor func(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject\n\ntype arrayBufferObject struct {\n\tbaseObject\n\tdetached bool\n\tdata     []byte\n}\n\n// ArrayBuffer is a Go wrapper around ECMAScript ArrayBuffer. Calling Runtime.ToValue() on it\n// returns the underlying ArrayBuffer. Calling Export() on an ECMAScript ArrayBuffer returns a wrapper.\n// Use Runtime.NewArrayBuffer([]byte) to create one.\ntype ArrayBuffer struct {\n\tbuf *arrayBufferObject\n}\n\ntype dataViewObject struct {\n\tbaseObject\n\tviewedArrayBuf      *arrayBufferObject\n\tbyteLen, byteOffset int\n}\n\ntype typedArray interface {\n\ttoRaw(Value) uint64\n\tget(idx int) Value\n\tset(idx int, value Value)\n\tgetRaw(idx int) uint64\n\tsetRaw(idx int, raw uint64)\n\tless(i, j int) bool\n\tswap(i, j int)\n\ttypeMatch(v Value) bool\n\texport(offset int, length int) interface{}\n\texportType() reflect.Type\n}\n\ntype uint8Array []byte\ntype uint8ClampedArray []byte\ntype int8Array []byte\ntype uint16Array []byte\ntype int16Array []byte\ntype uint32Array []byte\ntype int32Array []byte\ntype float32Array []byte\ntype float64Array []byte\ntype bigInt64Array []byte\ntype bigUint64Array []byte\n\ntype typedArrayObject struct {\n\tbaseObject\n\tviewedArrayBuf *arrayBufferObject\n\tdefaultCtor    *Object\n\tlength, offset int\n\telemSize       int\n\ttypedArray     typedArray\n}\n\nfunc (a ArrayBuffer) toValue(r *Runtime) Value {\n\tif a.buf == nil {\n\t\treturn _null\n\t}\n\tv := a.buf.val\n\tif v.runtime != r {\n\t\tpanic(r.NewTypeError(\"Illegal runtime transition of an ArrayBuffer\"))\n\t}\n\treturn v\n}\n\n// Bytes returns the underlying []byte for this ArrayBuffer.\n// For detached ArrayBuffers returns nil.\nfunc (a ArrayBuffer) Bytes() []byte {\n\treturn a.buf.data\n}\n\n// Detach the ArrayBuffer. After this, the underlying []byte becomes unreferenced and any attempt\n// to use this ArrayBuffer results in a TypeError.\n// Returns false if it was already detached, true otherwise.\n// Note, this method may only be called from the goroutine that 'owns' the Runtime, it may not\n// be called concurrently.\nfunc (a ArrayBuffer) Detach() bool {\n\tif a.buf.detached {\n\t\treturn false\n\t}\n\ta.buf.detach()\n\treturn true\n}\n\n// Detached returns true if the ArrayBuffer is detached.\nfunc (a ArrayBuffer) Detached() bool {\n\treturn a.buf.detached\n}\n\n// NewArrayBuffer creates a new instance of ArrayBuffer backed by the provided byte slice.\n//\n// Warning: be careful when using unaligned slices (sub-slices that do not start at word boundaries). If later a\n// typed array of a multibyte type (uint16, uint32, etc.) is created from a buffer backed by an unaligned slice,\n// using this typed array will result in unaligned access which may cause performance degradation or runtime panics\n// on some architectures or configurations.\nfunc (r *Runtime) NewArrayBuffer(data []byte) ArrayBuffer {\n\tbuf := r._newArrayBuffer(r.getArrayBufferPrototype(), nil)\n\tbuf.data = data\n\treturn ArrayBuffer{\n\t\tbuf: buf,\n\t}\n}\n\nfunc (a *uint8Array) toRaw(v Value) uint64 {\n\treturn uint64(toUint8(v))\n}\n\nfunc (a *uint8Array) ptr(idx int) *uint8 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*uint8)(unsafe.Pointer(uintptr(p) + uintptr(idx)))\n}\n\nfunc (a *uint8Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *uint8Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toUint8(value)\n}\n\nfunc (a *uint8Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *uint8Array) setRaw(idx int, raw uint64) {\n\t*(a.ptr(idx)) = uint8(raw)\n}\n\nfunc (a *uint8Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *uint8Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *uint8Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= 0 && i <= 255\n\t}\n\treturn false\n}\n\nfunc (a *uint8Array) export(offset int, length int) interface{} {\n\treturn ([]uint8)(*a)[offset : offset+length : offset+length]\n}\n\nfunc (a *uint8Array) exportType() reflect.Type {\n\treturn typeBytes\n}\n\nfunc (a *uint8ClampedArray) toRaw(v Value) uint64 {\n\treturn uint64(toUint8Clamp(v))\n}\n\nfunc (a *uint8ClampedArray) ptr(idx int) *uint8 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*uint8)(unsafe.Pointer(uintptr(p) + uintptr(idx)))\n}\n\nfunc (a *uint8ClampedArray) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *uint8ClampedArray) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toUint8Clamp(value)\n}\n\nfunc (a *uint8ClampedArray) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *uint8ClampedArray) setRaw(idx int, raw uint64) {\n\t*(a.ptr(idx)) = uint8(raw)\n}\n\nfunc (a *uint8ClampedArray) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *uint8ClampedArray) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *uint8ClampedArray) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= 0 && i <= 255\n\t}\n\treturn false\n}\n\nfunc (a *uint8ClampedArray) export(offset int, length int) interface{} {\n\treturn ([]uint8)(*a)[offset : offset+length : offset+length]\n}\n\nfunc (a *uint8ClampedArray) exportType() reflect.Type {\n\treturn typeBytes\n}\n\nfunc (a *int8Array) ptr(idx int) *int8 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*int8)(unsafe.Pointer(uintptr(p) + uintptr(idx)))\n}\n\nfunc (a *int8Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *int8Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *int8Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toInt8(value)\n}\n\nfunc (a *int8Array) toRaw(v Value) uint64 {\n\treturn uint64(toInt8(v))\n}\n\nfunc (a *int8Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = int8(v)\n}\n\nfunc (a *int8Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *int8Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *int8Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= math.MinInt8 && i <= math.MaxInt8\n\t}\n\treturn false\n}\n\nfunc (a *int8Array) export(offset int, length int) interface{} {\n\tvar res []int8\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeInt8Array = reflect.TypeOf(([]int8)(nil))\n\nfunc (a *int8Array) exportType() reflect.Type {\n\treturn typeInt8Array\n}\n\nfunc (a *uint16Array) toRaw(v Value) uint64 {\n\treturn uint64(toUint16(v))\n}\n\nfunc (a *uint16Array) ptr(idx int) *uint16 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*uint16)(unsafe.Pointer(uintptr(p) + uintptr(idx)*2))\n}\n\nfunc (a *uint16Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *uint16Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toUint16(value)\n}\n\nfunc (a *uint16Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *uint16Array) setRaw(idx int, raw uint64) {\n\t*(a.ptr(idx)) = uint16(raw)\n}\n\nfunc (a *uint16Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *uint16Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *uint16Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= 0 && i <= math.MaxUint16\n\t}\n\treturn false\n}\n\nvar typeUint16Array = reflect.TypeOf(([]uint16)(nil))\n\nfunc (a *uint16Array) export(offset int, length int) interface{} {\n\tvar res []uint16\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*2\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nfunc (a *uint16Array) exportType() reflect.Type {\n\treturn typeUint16Array\n}\n\nfunc (a *int16Array) ptr(idx int) *int16 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*int16)(unsafe.Pointer(uintptr(p) + uintptr(idx)*2))\n}\n\nfunc (a *int16Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *int16Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *int16Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toInt16(value)\n}\n\nfunc (a *int16Array) toRaw(v Value) uint64 {\n\treturn uint64(toInt16(v))\n}\n\nfunc (a *int16Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = int16(v)\n}\n\nfunc (a *int16Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *int16Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *int16Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= math.MinInt16 && i <= math.MaxInt16\n\t}\n\treturn false\n}\n\nfunc (a *int16Array) export(offset int, length int) interface{} {\n\tvar res []int16\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*2\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeInt16Array = reflect.TypeOf(([]int16)(nil))\n\nfunc (a *int16Array) exportType() reflect.Type {\n\treturn typeInt16Array\n}\n\nfunc (a *uint32Array) ptr(idx int) *uint32 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*uint32)(unsafe.Pointer(uintptr(p) + uintptr(idx)*4))\n}\n\nfunc (a *uint32Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *uint32Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *uint32Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toUint32(value)\n}\n\nfunc (a *uint32Array) toRaw(v Value) uint64 {\n\treturn uint64(toUint32(v))\n}\n\nfunc (a *uint32Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = uint32(v)\n}\n\nfunc (a *uint32Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *uint32Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *uint32Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= 0 && i <= math.MaxUint32\n\t}\n\treturn false\n}\n\nfunc (a *uint32Array) export(offset int, length int) interface{} {\n\tvar res []uint32\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*4\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeUint32Array = reflect.TypeOf(([]uint32)(nil))\n\nfunc (a *uint32Array) exportType() reflect.Type {\n\treturn typeUint32Array\n}\n\nfunc (a *int32Array) ptr(idx int) *int32 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*int32)(unsafe.Pointer(uintptr(p) + uintptr(idx)*4))\n}\n\nfunc (a *int32Array) get(idx int) Value {\n\treturn intToValue(int64(*(a.ptr(idx))))\n}\n\nfunc (a *int32Array) getRaw(idx int) uint64 {\n\treturn uint64(*(a.ptr(idx)))\n}\n\nfunc (a *int32Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toInt32(value)\n}\n\nfunc (a *int32Array) toRaw(v Value) uint64 {\n\treturn uint64(toInt32(v))\n}\n\nfunc (a *int32Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = int32(v)\n}\n\nfunc (a *int32Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *int32Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *int32Array) typeMatch(v Value) bool {\n\tif i, ok := v.(valueInt); ok {\n\t\treturn i >= math.MinInt32 && i <= math.MaxInt32\n\t}\n\treturn false\n}\n\nfunc (a *int32Array) export(offset int, length int) interface{} {\n\tvar res []int32\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*4\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeInt32Array = reflect.TypeOf(([]int32)(nil))\n\nfunc (a *int32Array) exportType() reflect.Type {\n\treturn typeInt32Array\n}\n\nfunc (a *float32Array) ptr(idx int) *float32 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*float32)(unsafe.Pointer(uintptr(p) + uintptr(idx)*4))\n}\n\nfunc (a *float32Array) get(idx int) Value {\n\treturn floatToValue(float64(*(a.ptr(idx))))\n}\n\nfunc (a *float32Array) getRaw(idx int) uint64 {\n\treturn uint64(math.Float32bits(*(a.ptr(idx))))\n}\n\nfunc (a *float32Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toFloat32(value)\n}\n\nfunc (a *float32Array) toRaw(v Value) uint64 {\n\treturn uint64(math.Float32bits(toFloat32(v)))\n}\n\nfunc (a *float32Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = math.Float32frombits(uint32(v))\n}\n\nfunc typedFloatLess(x, y float64) bool {\n\txNan := math.IsNaN(x)\n\tyNan := math.IsNaN(y)\n\tif yNan {\n\t\treturn !xNan\n\t} else if xNan {\n\t\treturn false\n\t}\n\tif x == 0 && y == 0 { // handle neg zero\n\t\treturn math.Signbit(x)\n\t}\n\treturn x < y\n}\n\nfunc (a *float32Array) less(i, j int) bool {\n\treturn typedFloatLess(float64(*(a.ptr(i))), float64(*(a.ptr(j))))\n}\n\nfunc (a *float32Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *float32Array) typeMatch(v Value) bool {\n\tswitch v.(type) {\n\tcase valueInt, valueFloat:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (a *float32Array) export(offset int, length int) interface{} {\n\tvar res []float32\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*4\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeFloat32Array = reflect.TypeOf(([]float32)(nil))\n\nfunc (a *float32Array) exportType() reflect.Type {\n\treturn typeFloat32Array\n}\n\nfunc (a *float64Array) ptr(idx int) *float64 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*float64)(unsafe.Pointer(uintptr(p) + uintptr(idx)*8))\n}\n\nfunc (a *float64Array) get(idx int) Value {\n\treturn floatToValue(*(a.ptr(idx)))\n}\n\nfunc (a *float64Array) getRaw(idx int) uint64 {\n\treturn math.Float64bits(*(a.ptr(idx)))\n}\n\nfunc (a *float64Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = value.ToFloat()\n}\n\nfunc (a *float64Array) toRaw(v Value) uint64 {\n\treturn math.Float64bits(v.ToFloat())\n}\n\nfunc (a *float64Array) setRaw(idx int, v uint64) {\n\t*(a.ptr(idx)) = math.Float64frombits(v)\n}\n\nfunc (a *float64Array) less(i, j int) bool {\n\treturn typedFloatLess(*(a.ptr(i)), *(a.ptr(j)))\n}\n\nfunc (a *float64Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *float64Array) typeMatch(v Value) bool {\n\tswitch v.(type) {\n\tcase valueInt, valueFloat:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (a *float64Array) export(offset int, length int) interface{} {\n\tvar res []float64\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*8\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeFloat64Array = reflect.TypeOf(([]float64)(nil))\n\nfunc (a *float64Array) exportType() reflect.Type {\n\treturn typeFloat64Array\n}\n\nfunc (a *bigInt64Array) toRaw(value Value) uint64 {\n\treturn toBigInt64(value).Uint64()\n}\n\nfunc (a *bigInt64Array) ptr(idx int) *int64 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*int64)(unsafe.Pointer(uintptr(p) + uintptr(idx)*8))\n}\n\nfunc (a *bigInt64Array) get(idx int) Value {\n\treturn (*valueBigInt)(big.NewInt(*a.ptr(idx)))\n}\n\nfunc toBigInt64(v Value) *big.Int {\n\tn := (*big.Int)(toBigInt(v))\n\n\ttwoTo64 := new(big.Int).Lsh(big.NewInt(1), 64)\n\ttwoTo63 := new(big.Int).Lsh(big.NewInt(1), 63)\n\n\tint64bit := new(big.Int).Mod(n, twoTo64)\n\tif int64bit.Cmp(twoTo63) >= 0 {\n\t\treturn int64bit.Sub(int64bit, twoTo64)\n\t}\n\treturn int64bit\n}\n\nfunc (a *bigInt64Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toBigInt64(value).Int64()\n}\n\nfunc (a *bigInt64Array) getRaw(idx int) uint64 {\n\treturn uint64(*a.ptr(idx))\n}\n\nfunc (a *bigInt64Array) setRaw(idx int, raw uint64) {\n\t*(a.ptr(idx)) = int64(raw)\n}\n\nfunc (a *bigInt64Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *bigInt64Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *bigInt64Array) typeMatch(v Value) bool {\n\tif _, ok := v.(*valueBigInt); ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (a *bigInt64Array) export(offset int, length int) interface{} {\n\tvar res []int64\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*8\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeBigInt64Array = reflect.TypeOf(([]int64)(nil))\n\nfunc (a *bigInt64Array) exportType() reflect.Type {\n\treturn typeBigInt64Array\n}\n\nfunc (a *bigUint64Array) toRaw(value Value) uint64 {\n\treturn toBigUint64(value).Uint64()\n}\n\nfunc (a *bigUint64Array) ptr(idx int) *uint64 {\n\tp := unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(a)).Data)\n\treturn (*uint64)(unsafe.Pointer(uintptr(p) + uintptr(idx)*8))\n}\n\nfunc (a *bigUint64Array) get(idx int) Value {\n\treturn (*valueBigInt)(new(big.Int).SetUint64(*a.ptr(idx)))\n}\n\nfunc toBigUint64(v Value) *big.Int {\n\tn := (*big.Int)(toBigInt(v))\n\treturn new(big.Int).Mod(n, new(big.Int).Lsh(big.NewInt(1), 64))\n}\n\nfunc (a *bigUint64Array) set(idx int, value Value) {\n\t*(a.ptr(idx)) = toBigUint64(value).Uint64()\n}\n\nfunc (a *bigUint64Array) getRaw(idx int) uint64 {\n\treturn *a.ptr(idx)\n}\n\nfunc (a *bigUint64Array) setRaw(idx int, raw uint64) {\n\t*(a.ptr(idx)) = raw\n}\n\nfunc (a *bigUint64Array) less(i, j int) bool {\n\treturn *(a.ptr(i)) < *(a.ptr(j))\n}\n\nfunc (a *bigUint64Array) swap(i, j int) {\n\tpi, pj := a.ptr(i), a.ptr(j)\n\t*pi, *pj = *pj, *pi\n}\n\nfunc (a *bigUint64Array) typeMatch(v Value) bool {\n\tif _, ok := v.(*valueBigInt); ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (a *bigUint64Array) export(offset int, length int) interface{} {\n\tvar res []uint64\n\tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n\tsliceHeader.Data = (*reflect.SliceHeader)(unsafe.Pointer(a)).Data + uintptr(offset)*8\n\tsliceHeader.Len = length\n\tsliceHeader.Cap = length\n\treturn res\n}\n\nvar typeBigUint64Array = reflect.TypeOf(([]uint64)(nil))\n\nfunc (a *bigUint64Array) exportType() reflect.Type {\n\treturn typeBigUint64Array\n}\n\nfunc (a *typedArrayObject) _getIdx(idx int) Value {\n\tif 0 <= idx && idx < a.length {\n\t\tif !a.viewedArrayBuf.ensureNotDetached(false) {\n\t\t\treturn nil\n\t\t}\n\t\treturn a.typedArray.get(idx + a.offset)\n\t}\n\treturn nil\n}\n\nfunc (a *typedArrayObject) getOwnPropStr(name unistring.String) Value {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\tv := a._getIdx(idx)\n\t\tif v != nil {\n\t\t\treturn &valueProperty{\n\t\t\t\tvalue:        v,\n\t\t\t\twritable:     true,\n\t\t\t\tenumerable:   true,\n\t\t\t\tconfigurable: true,\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif idx == 0 {\n\t\treturn nil\n\t}\n\treturn a.baseObject.getOwnPropStr(name)\n}\n\nfunc (a *typedArrayObject) getOwnPropIdx(idx valueInt) Value {\n\tv := a._getIdx(toIntClamp(int64(idx)))\n\tif v != nil {\n\t\treturn &valueProperty{\n\t\t\tvalue:        v,\n\t\t\twritable:     true,\n\t\t\tenumerable:   true,\n\t\t\tconfigurable: true,\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (a *typedArrayObject) getStr(name unistring.String, receiver Value) Value {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\treturn a._getIdx(idx)\n\t}\n\tif idx == 0 {\n\t\treturn nil\n\t}\n\treturn a.baseObject.getStr(name, receiver)\n}\n\nfunc (a *typedArrayObject) getIdx(idx valueInt, receiver Value) Value {\n\treturn a._getIdx(toIntClamp(int64(idx)))\n}\n\nfunc (a *typedArrayObject) isValidIntegerIndex(idx int) bool {\n\tif a.viewedArrayBuf.ensureNotDetached(false) {\n\t\tif idx >= 0 && idx < a.length {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (a *typedArrayObject) _putIdx(idx int, v Value) {\n\tswitch a.typedArray.(type) {\n\tcase *bigInt64Array, *bigUint64Array:\n\t\tv = toBigInt(v)\n\tdefault:\n\t\tv = v.ToNumber()\n\t}\n\tif a.isValidIntegerIndex(idx) {\n\t\ta.typedArray.set(idx+a.offset, v)\n\t}\n}\n\nfunc (a *typedArrayObject) _hasIdx(idx int) bool {\n\treturn a.isValidIntegerIndex(idx)\n}\n\nfunc (a *typedArrayObject) setOwnStr(p unistring.String, v Value, throw bool) bool {\n\tidx, ok := strToIntNum(p)\n\tif ok {\n\t\ta._putIdx(idx, v)\n\t\treturn true\n\t}\n\tif idx == 0 {\n\t\ttoNumeric(v) // make sure it throws\n\t\treturn true\n\t}\n\treturn a.baseObject.setOwnStr(p, v, throw)\n}\n\nfunc (a *typedArrayObject) setOwnIdx(p valueInt, v Value, throw bool) bool {\n\ta._putIdx(toIntClamp(int64(p)), v)\n\treturn true\n}\n\nfunc (a *typedArrayObject) setForeignStr(p unistring.String, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn a._setForeignStr(p, a.getOwnPropStr(p), v, receiver, throw)\n}\n\nfunc (a *typedArrayObject) setForeignIdx(p valueInt, v, receiver Value, throw bool) (res bool, handled bool) {\n\treturn a._setForeignIdx(p, trueValIfPresent(a.hasOwnPropertyIdx(p)), v, receiver, throw)\n}\n\nfunc (a *typedArrayObject) hasOwnPropertyStr(name unistring.String) bool {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\treturn a._hasIdx(idx)\n\t}\n\tif idx == 0 {\n\t\treturn false\n\t}\n\treturn a.baseObject.hasOwnPropertyStr(name)\n}\n\nfunc (a *typedArrayObject) hasOwnPropertyIdx(idx valueInt) bool {\n\treturn a._hasIdx(toIntClamp(int64(idx)))\n}\n\nfunc (a *typedArrayObject) hasPropertyStr(name unistring.String) bool {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\treturn a._hasIdx(idx)\n\t}\n\tif idx == 0 {\n\t\treturn false\n\t}\n\treturn a.baseObject.hasPropertyStr(name)\n}\n\nfunc (a *typedArrayObject) hasPropertyIdx(idx valueInt) bool {\n\treturn a.hasOwnPropertyIdx(idx)\n}\n\nfunc (a *typedArrayObject) _defineIdxProperty(idx int, desc PropertyDescriptor, throw bool) bool {\n\tif desc.Configurable == FLAG_FALSE || desc.Enumerable == FLAG_FALSE || desc.IsAccessor() || desc.Writable == FLAG_FALSE {\n\t\ta.val.runtime.typeErrorResult(throw, \"Cannot redefine property: %d\", idx)\n\t\treturn false\n\t}\n\t_, ok := a._defineOwnProperty(unistring.String(strconv.Itoa(idx)), a.getOwnPropIdx(valueInt(idx)), desc, throw)\n\tif ok {\n\t\tif !a.isValidIntegerIndex(idx) {\n\t\t\ta.val.runtime.typeErrorResult(throw, \"Invalid typed array index\")\n\t\t\treturn false\n\t\t}\n\t\ta._putIdx(idx, desc.Value)\n\t\treturn true\n\t}\n\treturn ok\n}\n\nfunc (a *typedArrayObject) defineOwnPropertyStr(name unistring.String, desc PropertyDescriptor, throw bool) bool {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\treturn a._defineIdxProperty(idx, desc, throw)\n\t}\n\tif idx == 0 {\n\t\ta.viewedArrayBuf.ensureNotDetached(throw)\n\t\ta.val.runtime.typeErrorResult(throw, \"Invalid typed array index\")\n\t\treturn false\n\t}\n\treturn a.baseObject.defineOwnPropertyStr(name, desc, throw)\n}\n\nfunc (a *typedArrayObject) defineOwnPropertyIdx(name valueInt, desc PropertyDescriptor, throw bool) bool {\n\treturn a._defineIdxProperty(toIntClamp(int64(name)), desc, throw)\n}\n\nfunc (a *typedArrayObject) deleteStr(name unistring.String, throw bool) bool {\n\tidx, ok := strToIntNum(name)\n\tif ok {\n\t\tif a.isValidIntegerIndex(idx) {\n\t\t\ta.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of %s\", idx, a.val.String())\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\tif idx == 0 {\n\t\treturn true\n\t}\n\treturn a.baseObject.deleteStr(name, throw)\n}\n\nfunc (a *typedArrayObject) deleteIdx(idx valueInt, throw bool) bool {\n\tif a.viewedArrayBuf.ensureNotDetached(false) && idx >= 0 && int64(idx) < int64(a.length) {\n\t\ta.val.runtime.typeErrorResult(throw, \"Cannot delete property '%d' of %s\", idx, a.val.String())\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (a *typedArrayObject) stringKeys(all bool, accum []Value) []Value {\n\tif accum == nil {\n\t\taccum = make([]Value, 0, a.length)\n\t}\n\tfor i := 0; i < a.length; i++ {\n\t\taccum = append(accum, asciiString(strconv.Itoa(i)))\n\t}\n\treturn a.baseObject.stringKeys(all, accum)\n}\n\ntype typedArrayPropIter struct {\n\ta   *typedArrayObject\n\tidx int\n}\n\nfunc (i *typedArrayPropIter) next() (propIterItem, iterNextFunc) {\n\tif i.idx < i.a.length {\n\t\tname := strconv.Itoa(i.idx)\n\t\tprop := i.a._getIdx(i.idx)\n\t\ti.idx++\n\t\treturn propIterItem{name: asciiString(name), value: prop}, i.next\n\t}\n\n\treturn i.a.baseObject.iterateStringKeys()()\n}\n\nfunc (a *typedArrayObject) iterateStringKeys() iterNextFunc {\n\treturn (&typedArrayPropIter{\n\t\ta: a,\n\t}).next\n}\n\nfunc (a *typedArrayObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tif typ == typeBytes {\n\t\tdst.Set(reflect.ValueOf(a.viewedArrayBuf.data))\n\t\treturn nil\n\t}\n\treturn a.baseObject.exportToArrayOrSlice(dst, typ, ctx)\n}\n\nfunc (a *typedArrayObject) export(_ *objectExportCtx) interface{} {\n\treturn a.typedArray.export(a.offset, a.length)\n}\n\nfunc (a *typedArrayObject) exportType() reflect.Type {\n\treturn a.typedArray.exportType()\n}\n\nfunc (o *dataViewObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tif typ == typeBytes {\n\t\tdst.Set(reflect.ValueOf(o.viewedArrayBuf.data))\n\t\treturn nil\n\t}\n\treturn o.baseObject.exportToArrayOrSlice(dst, typ, ctx)\n}\n\nfunc (r *Runtime) _newTypedArrayObject(buf *arrayBufferObject, offset, length, elemSize int, defCtor *Object, arr typedArray, proto *Object) *typedArrayObject {\n\to := &Object{runtime: r}\n\ta := &typedArrayObject{\n\t\tbaseObject: baseObject{\n\t\t\tval:        o,\n\t\t\tclass:      classObject,\n\t\t\tprototype:  proto,\n\t\t\textensible: true,\n\t\t},\n\t\tviewedArrayBuf: buf,\n\t\toffset:         offset,\n\t\tlength:         length,\n\t\telemSize:       elemSize,\n\t\tdefaultCtor:    defCtor,\n\t\ttypedArray:     arr,\n\t}\n\to.self = a\n\ta.init()\n\treturn a\n\n}\n\nfunc (r *Runtime) newUint8ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\t// Note, no need to use r.getUint8Array() here or in the similar methods below, because the value is already set\n\t// by the time they are called.\n\treturn r._newTypedArrayObject(buf, offset, length, 1, r.global.Uint8Array, (*uint8Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newUint8ClampedArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 1, r.global.Uint8ClampedArray, (*uint8ClampedArray)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newInt8ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 1, r.global.Int8Array, (*int8Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newUint16ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 2, r.global.Uint16Array, (*uint16Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newInt16ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 2, r.global.Int16Array, (*int16Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newUint32ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 4, r.global.Uint32Array, (*uint32Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newInt32ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 4, r.global.Int32Array, (*int32Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newFloat32ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 4, r.global.Float32Array, (*float32Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newFloat64ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 8, r.global.Float64Array, (*float64Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newBigInt64ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 8, r.global.BigInt64Array, (*bigInt64Array)(&buf.data), proto)\n}\n\nfunc (r *Runtime) newBigUint64ArrayObject(buf *arrayBufferObject, offset, length int, proto *Object) *typedArrayObject {\n\treturn r._newTypedArrayObject(buf, offset, length, 8, r.global.BigUint64Array, (*bigUint64Array)(&buf.data), proto)\n}\n\nfunc (o *dataViewObject) getIdxAndByteOrder(getIdx int, littleEndianVal Value, size int) (int, byteOrder) {\n\to.viewedArrayBuf.ensureNotDetached(true)\n\tif getIdx+size > o.byteLen {\n\t\tpanic(o.val.runtime.newError(o.val.runtime.getRangeError(), \"Index %d is out of bounds\", getIdx))\n\t}\n\tgetIdx += o.byteOffset\n\tvar bo byteOrder\n\tif littleEndianVal != nil {\n\t\tif littleEndianVal.ToBoolean() {\n\t\t\tbo = littleEndian\n\t\t} else {\n\t\t\tbo = bigEndian\n\t\t}\n\t} else {\n\t\tbo = nativeEndian\n\t}\n\treturn getIdx, bo\n}\n\nfunc (o *arrayBufferObject) ensureNotDetached(throw bool) bool {\n\tif o.detached {\n\t\to.val.runtime.typeErrorResult(throw, \"ArrayBuffer is detached\")\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (o *arrayBufferObject) getFloat32(idx int, byteOrder byteOrder) float32 {\n\treturn math.Float32frombits(o.getUint32(idx, byteOrder))\n}\n\nfunc (o *arrayBufferObject) setFloat32(idx int, val float32, byteOrder byteOrder) {\n\to.setUint32(idx, math.Float32bits(val), byteOrder)\n}\n\nfunc (o *arrayBufferObject) getFloat64(idx int, byteOrder byteOrder) float64 {\n\treturn math.Float64frombits(o.getUint64(idx, byteOrder))\n}\n\nfunc (o *arrayBufferObject) setFloat64(idx int, val float64, byteOrder byteOrder) {\n\to.setUint64(idx, math.Float64bits(val), byteOrder)\n}\n\nfunc (o *arrayBufferObject) getUint64(idx int, byteOrder byteOrder) uint64 {\n\tvar b []byte\n\tif byteOrder == nativeEndian {\n\t\tb = o.data[idx : idx+8]\n\t} else {\n\t\tb = make([]byte, 8)\n\t\td := o.data[idx : idx+8]\n\t\tb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7] = d[7], d[6], d[5], d[4], d[3], d[2], d[1], d[0]\n\t}\n\treturn *((*uint64)(unsafe.Pointer(&b[0])))\n}\n\nfunc (o *arrayBufferObject) setUint64(idx int, val uint64, byteOrder byteOrder) {\n\tif byteOrder == nativeEndian {\n\t\t*(*uint64)(unsafe.Pointer(&o.data[idx])) = val\n\t} else {\n\t\tb := (*[8]byte)(unsafe.Pointer(&val))\n\t\td := o.data[idx : idx+8]\n\t\td[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7] = b[7], b[6], b[5], b[4], b[3], b[2], b[1], b[0]\n\t}\n}\n\nfunc (o *arrayBufferObject) getUint32(idx int, byteOrder byteOrder) uint32 {\n\tvar b []byte\n\tif byteOrder == nativeEndian {\n\t\tb = o.data[idx : idx+4]\n\t} else {\n\t\tb = make([]byte, 4)\n\t\td := o.data[idx : idx+4]\n\t\tb[0], b[1], b[2], b[3] = d[3], d[2], d[1], d[0]\n\t}\n\treturn *((*uint32)(unsafe.Pointer(&b[0])))\n}\n\nfunc (o *arrayBufferObject) setUint32(idx int, val uint32, byteOrder byteOrder) {\n\to.ensureNotDetached(true)\n\tif byteOrder == nativeEndian {\n\t\t*(*uint32)(unsafe.Pointer(&o.data[idx])) = val\n\t} else {\n\t\tb := (*[4]byte)(unsafe.Pointer(&val))\n\t\td := o.data[idx : idx+4]\n\t\td[0], d[1], d[2], d[3] = b[3], b[2], b[1], b[0]\n\t}\n}\n\nfunc (o *arrayBufferObject) getBigInt64(idx int, byteOrder byteOrder) *big.Int {\n\tvar b []byte\n\tif byteOrder == nativeEndian {\n\t\tb = o.data[idx : idx+8]\n\t} else {\n\t\tb = make([]byte, 8)\n\t\td := o.data[idx : idx+8]\n\t\tb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7] = d[7], d[6], d[5], d[4], d[3], d[2], d[1], d[0]\n\t}\n\treturn big.NewInt(*((*int64)(unsafe.Pointer(&b[0]))))\n}\n\nfunc (o *arrayBufferObject) getBigUint64(idx int, byteOrder byteOrder) *big.Int {\n\tvar b []byte\n\tif byteOrder == nativeEndian {\n\t\tb = o.data[idx : idx+8]\n\t} else {\n\t\tb = make([]byte, 8)\n\t\td := o.data[idx : idx+8]\n\t\tb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7] = d[7], d[6], d[5], d[4], d[3], d[2], d[1], d[0]\n\t}\n\treturn new(big.Int).SetUint64(*((*uint64)(unsafe.Pointer(&b[0]))))\n}\n\nfunc (o *arrayBufferObject) setBigInt64(idx int, val *big.Int, byteOrder byteOrder) {\n\tif byteOrder == nativeEndian {\n\t\t*(*int64)(unsafe.Pointer(&o.data[idx])) = val.Int64()\n\t} else {\n\t\tn := val.Int64()\n\t\tb := (*[8]byte)(unsafe.Pointer(&n))\n\t\td := o.data[idx : idx+8]\n\t\td[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7] = b[7], b[6], b[5], b[4], b[3], b[2], b[1], b[0]\n\t}\n}\n\nfunc (o *arrayBufferObject) setBigUint64(idx int, val *big.Int, byteOrder byteOrder) {\n\tif byteOrder == nativeEndian {\n\t\t*(*uint64)(unsafe.Pointer(&o.data[idx])) = val.Uint64()\n\t} else {\n\t\tn := val.Uint64()\n\t\tb := (*[8]byte)(unsafe.Pointer(&n))\n\t\td := o.data[idx : idx+8]\n\t\td[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7] = b[7], b[6], b[5], b[4], b[3], b[2], b[1], b[0]\n\t}\n}\n\nfunc (o *arrayBufferObject) getUint16(idx int, byteOrder byteOrder) uint16 {\n\tvar b []byte\n\tif byteOrder == nativeEndian {\n\t\tb = o.data[idx : idx+2]\n\t} else {\n\t\tb = make([]byte, 2)\n\t\td := o.data[idx : idx+2]\n\t\tb[0], b[1] = d[1], d[0]\n\t}\n\treturn *((*uint16)(unsafe.Pointer(&b[0])))\n}\n\nfunc (o *arrayBufferObject) setUint16(idx int, val uint16, byteOrder byteOrder) {\n\tif byteOrder == nativeEndian {\n\t\t*(*uint16)(unsafe.Pointer(&o.data[idx])) = val\n\t} else {\n\t\tb := (*[2]byte)(unsafe.Pointer(&val))\n\t\td := o.data[idx : idx+2]\n\t\td[0], d[1] = b[1], b[0]\n\t}\n}\n\nfunc (o *arrayBufferObject) getUint8(idx int) uint8 {\n\treturn o.data[idx]\n}\n\nfunc (o *arrayBufferObject) setUint8(idx int, val uint8) {\n\to.data[idx] = val\n}\n\nfunc (o *arrayBufferObject) getInt32(idx int, byteOrder byteOrder) int32 {\n\treturn int32(o.getUint32(idx, byteOrder))\n}\n\nfunc (o *arrayBufferObject) setInt32(idx int, val int32, byteOrder byteOrder) {\n\to.setUint32(idx, uint32(val), byteOrder)\n}\n\nfunc (o *arrayBufferObject) getInt16(idx int, byteOrder byteOrder) int16 {\n\treturn int16(o.getUint16(idx, byteOrder))\n}\n\nfunc (o *arrayBufferObject) setInt16(idx int, val int16, byteOrder byteOrder) {\n\to.setUint16(idx, uint16(val), byteOrder)\n}\n\nfunc (o *arrayBufferObject) getInt8(idx int) int8 {\n\treturn int8(o.data[idx])\n}\n\nfunc (o *arrayBufferObject) setInt8(idx int, val int8) {\n\to.setUint8(idx, uint8(val))\n}\n\nfunc (o *arrayBufferObject) detach() {\n\to.data = nil\n\to.detached = true\n}\n\nfunc (o *arrayBufferObject) exportType() reflect.Type {\n\treturn arrayBufferType\n}\n\nfunc (o *arrayBufferObject) export(*objectExportCtx) interface{} {\n\treturn ArrayBuffer{\n\t\tbuf: o,\n\t}\n}\n\nfunc (o *arrayBufferObject) exportToArrayOrSlice(dst reflect.Value, typ reflect.Type, ctx *objectExportCtx) error {\n\tif typ == typeBytes {\n\t\tdst.Set(reflect.ValueOf(o.data))\n\t\treturn nil\n\t}\n\treturn o.baseObject.exportToArrayOrSlice(dst, typ, ctx)\n}\n\nfunc (r *Runtime) _newArrayBuffer(proto *Object, o *Object) *arrayBufferObject {\n\tif o == nil {\n\t\to = &Object{runtime: r}\n\t}\n\tb := &arrayBufferObject{\n\t\tbaseObject: baseObject{\n\t\t\tclass:      classObject,\n\t\t\tval:        o,\n\t\t\tprototype:  proto,\n\t\t\textensible: true,\n\t\t},\n\t}\n\to.self = b\n\tb.init()\n\treturn b\n}\n\nfunc init() {\n\tbuf := [2]byte{}\n\t*(*uint16)(unsafe.Pointer(&buf[0])) = uint16(0xCAFE)\n\n\tswitch buf {\n\tcase [2]byte{0xFE, 0xCA}:\n\t\tnativeEndian = littleEndian\n\tcase [2]byte{0xCA, 0xFE}:\n\t\tnativeEndian = bigEndian\n\tdefault:\n\t\tpanic(\"Could not determine native endianness.\")\n\t}\n}\n"
        },
        {
          "name": "typedarrays_test.go",
          "type": "blob",
          "size": 12.501953125,
          "content": "package goja\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestUint16ArrayObject(t *testing.T) {\n\tvm := New()\n\tbuf := vm._newArrayBuffer(vm.global.ArrayBufferPrototype, nil)\n\tbuf.data = make([]byte, 16)\n\tif nativeEndian == littleEndian {\n\t\tbuf.data[2] = 0xFE\n\t\tbuf.data[3] = 0xCA\n\t} else {\n\t\tbuf.data[2] = 0xCA\n\t\tbuf.data[3] = 0xFE\n\t}\n\ta := vm.newUint16ArrayObject(buf, 1, 1, nil)\n\tv := a.getIdx(valueInt(0), nil)\n\tif v != valueInt(0xCAFE) {\n\t\tt.Fatalf(\"v: %v\", v)\n\t}\n}\n\nfunc TestArrayBufferGoWrapper(t *testing.T) {\n\tvm := New()\n\tdata := []byte{0xAA, 0xBB}\n\tbuf := vm.NewArrayBuffer(data)\n\tvm.Set(\"buf\", buf)\n\t_, err := vm.RunString(`\n\tvar a = new Uint8Array(buf);\n\tif (a.length !== 2 || a[0] !== 0xAA || a[1] !== 0xBB) {\n\t\tthrow new Error(a);\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tret, err := vm.RunString(`\n\tvar b = Uint8Array.of(0xCC, 0xDD);\n\tb.buffer;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbuf1 := ret.Export().(ArrayBuffer)\n\tdata1 := buf1.Bytes()\n\tif len(data1) != 2 || data1[0] != 0xCC || data1[1] != 0xDD {\n\t\tt.Fatal(data1)\n\t}\n\tif buf1.Detached() {\n\t\tt.Fatal(\"buf1.Detached() returned true\")\n\t}\n\tif !buf1.Detach() {\n\t\tt.Fatal(\"buf1.Detach() returned false\")\n\t}\n\tif !buf1.Detached() {\n\t\tt.Fatal(\"buf1.Detached() returned false\")\n\t}\n\t_, err = vm.RunString(`\n\tif (b[0] !== undefined) {\n\t\tthrow new Error(\"b[0] !== undefined\");\n\t}\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestTypedArrayIdx(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = new Uint8Array(1);\n\n\t// 32-bit integer overflow, should not panic on 32-bit architectures\n\tif (a[4294967297] !== undefined) {\n\t\tthrow new Error(\"4294967297\");\n\t}\n\n\t// Canonical non-integer\n\ta[\"Infinity\"] = 8;\n\tif (a[\"Infinity\"] !== undefined) {\n\t\tthrow new Error(\"Infinity\");\n\t}\n\ta[\"NaN\"] = 1;\n\tif (a[\"NaN\"] !== undefined) {\n\t\tthrow new Error(\"NaN\");\n\t}\n\n\t// Non-canonical integer\n\ta[\"00\"] = \"00\";\n\tif (a[\"00\"] !== \"00\") {\n\t\tthrow new Error(\"00\");\n\t}\n\n\t// Non-canonical non-integer\n\ta[\"1e-3\"] = \"1e-3\";\n\tif (a[\"1e-3\"] !== \"1e-3\") {\n\t\tthrow new Error(\"1e-3\");\n\t}\n\tif (a[\"0.001\"] !== undefined) {\n\t\tthrow new Error(\"0.001\");\n\t}\n\n\t// Negative zero\n\ta[\"-0\"] = 88;\n\tif (a[\"-0\"] !== undefined) {\n\t\tthrow new Error(\"-0\");\n\t}\n\n\tif (a[0] !== 0) {\n\t\tthrow new Error(\"0\");\n\t}\n\n\ta[\"9007199254740992\"] = 1;\n\tif (a[\"9007199254740992\"] !== undefined) {\n\t\tthrow new Error(\"9007199254740992\");\n\t}\n\ta[\"-9007199254740992\"] = 1;\n\tif (a[\"-9007199254740992\"] !== undefined) {\n\t\tthrow new Error(\"-9007199254740992\");\n\t}\n\n\t// Safe integer overflow, not canonical (Number(\"9007199254740993\") === 9007199254740992)\n\ta[\"9007199254740993\"] = 1;\n\tif (a[\"9007199254740993\"] !== 1) {\n\t\tthrow new Error(\"9007199254740993\");\n\t}\n\ta[\"-9007199254740993\"] = 1;\n\tif (a[\"-9007199254740993\"] !== 1) {\n\t\tthrow new Error(\"-9007199254740993\");\n\t}\n\n\t// Safe integer overflow, canonical Number(\"9007199254740994\") == 9007199254740994\n\ta[\"9007199254740994\"] = 1;\n\tif (a[\"9007199254740994\"] !== undefined) {\n\t\tthrow new Error(\"9007199254740994\");\n\t}\n\ta[\"-9007199254740994\"] = 1;\n\tif (a[\"-9007199254740994\"] !== undefined) {\n\t\tthrow new Error(\"-9007199254740994\");\n\t}\n\t`\n\n\ttestScript(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArraySetDetachedBuffer(t *testing.T) {\n\tconst SCRIPT = `\n\tlet sample = new Uint8Array([42]);\n\t$DETACHBUFFER(sample.buffer);\n\tsample[0] = 1;\n\n\tassert.sameValue(sample[0], undefined, 'sample[0] = 1 is undefined');\n\tsample['1.1'] = 1;\n\tassert.sameValue(sample['1.1'], undefined, 'sample[\\'1.1\\'] = 1 is undefined');\n\tsample['-0'] = 1;\n\tassert.sameValue(sample['-0'], undefined, 'sample[\\'-0\\'] = 1 is undefined');\n\tsample['-1'] = 1;\n\tassert.sameValue(sample['-1'], undefined, 'sample[\\'-1\\'] = 1 is undefined');\n\tsample['1'] = 1;\n\tassert.sameValue(sample['1'], undefined, 'sample[\\'1\\'] = 1 is undefined');\n\tsample['2'] = 1;\n\tassert.sameValue(sample['2'], undefined, 'sample[\\'2\\'] = 1 is undefined');\t\n\t`\n\tvm := New()\n\tvm.Set(\"$DETACHBUFFER\", func(buf *ArrayBuffer) {\n\t\tbuf.Detach()\n\t})\n\tvm.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArrayDefinePropDetachedBuffer(t *testing.T) {\n\tconst SCRIPT = `\n\tvar desc = {\n\t  value: 0,\n\t  configurable: false,\n\t  enumerable: true,\n\t  writable: true\n\t};\n\t\n\tvar obj = {\n\t  valueOf: function() {\n\t\tthrow new Error(\"valueOf() was called\");\n\t  }\n\t};\n\tlet sample = new Uint8Array(42);\n\t$DETACHBUFFER(sample.buffer);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"0\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"0\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"-1\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"-1\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"1.1\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"1.1\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"-0\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"-0\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"2\", {\n\t  configurable: true,\n\t  enumerable: true,\n\t  writable: true,\n\t  value: obj\n\t}),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"2\", {configurable: true, enumerable: true, writable: true, value: obj}) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"3\", {\n\t  configurable: false,\n\t  enumerable: false,\n\t  writable: true,\n\t  value: obj\n\t}),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"3\", {configurable: false, enumerable: false, writable: true, value: obj}) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"4\", {\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: true,\n\t  value: obj\n\t}),\n\tfalse,\n\t'Reflect.defineProperty(\"new TA(42)\", \"4\", {writable: false, configurable: false, enumerable: true, value: obj}) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"42\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"42\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"43\", desc),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"43\", {value: 0, configurable: false, enumerable: true, writable: true} ) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"5\", {\n\t  get: function() {}\n\t}),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"5\", {get: function() {}}) must return false'\n\t);\n\t\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"6\", {\n\t  configurable: false,\n\t  enumerable: true,\n\t  writable: true\n\t}),\n\tfalse,\n\t'Reflect.defineProperty(sample, \"6\", {configurable: false, enumerable: true, writable: true}) must return false'\n\t);\n\t`\n\tvm := New()\n\tvm.Set(\"$DETACHBUFFER\", func(buf *ArrayBuffer) {\n\t\tbuf.Detach()\n\t})\n\tvm.testScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArrayDefineProperty(t *testing.T) {\n\tconst SCRIPT = `\n\tvar a = new Uint8Array(1);\n\n\tassert.throws(TypeError, function() {\n\t\tObject.defineProperty(a, \"1\", {value: 1});\n\t});\n\tassert.sameValue(Reflect.defineProperty(a, \"1\", {value: 1}), false, \"1\");\n\n\tassert.throws(TypeError, function() {\n\t\tObject.defineProperty(a, \"Infinity\", {value: 8});\n\t});\n\tassert.sameValue(Reflect.defineProperty(a, \"Infinity\", {value: 8}), false, \"Infinity\");\n\n\tObject.defineProperty(a, \"test\", {value: \"passed\"});\n\tassert.sameValue(a.test, \"passed\", \"string property\");\n\n\tassert.throws(TypeError, function() {\n\t\tObject.defineProperty(a, \"0\", {value: 1, writable: false});\n\t}, \"define non-writable\");\n\n\tassert.throws(TypeError, function() {\n\t\tObject.defineProperty(a, \"0\", {get() { return 1; }});\n\t}, \"define accessor\");\n\n\tvar sample = new Uint8Array([42, 42]);\n\n\tassert.sameValue(\n\tReflect.defineProperty(sample, \"0\", {\n\t  value: 8,\n\t  configurable: true,\n\t  enumerable: true,\n\t  writable: true\n\t}),\n\ttrue\n\t);\n\n\tassert.sameValue(sample[0], 8, \"property value was set\");\n\tlet descriptor0 = Object.getOwnPropertyDescriptor(sample, \"0\");\n\tassert.sameValue(descriptor0.value, 8);\n\tassert.sameValue(descriptor0.configurable, true, \"configurable\");\n\tassert.sameValue(descriptor0.enumerable, true);\n\tassert.sameValue(descriptor0.writable, true);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestTypedArrayGetInvalidIndex(t *testing.T) {\n\tconst SCRIPT = `\n\tvar TypedArray = Object.getPrototypeOf(Int8Array);\n\tvar proto = TypedArray.prototype;\n\tObject.defineProperty(proto, \"1\", {\n\t\tget: function() {\n\t\t\tthrow new Error(\"OrdinaryGet was called!\");\n\t\t}\n\t});\n\tvar a = new Uint8Array(1);\n\tassert.sameValue(a[1], undefined);\n\tassert.sameValue(a[\"1\"], undefined);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc TestExportArrayBufferToBytes(t *testing.T) {\n\tvm := New()\n\tbb := []byte(\"test\")\n\tab := vm.NewArrayBuffer(bb)\n\tvar b []byte\n\terr := vm.ExportTo(vm.ToValue(ab), &b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(b, bb) {\n\t\tt.Fatal(\"Not equal\")\n\t}\n\n\terr = vm.ExportTo(vm.ToValue(123), &b)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestTypedArrayExport(t *testing.T) {\n\tvm := New()\n\n\tt.Run(\"uint8\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Uint8Array([1, 2])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]uint8); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != 2 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t\t_, err = vm.RunString(`{\n\t\tlet a = new Uint8Array([1, 2]);\n\t\tif (a[0] !== 1 || a[1] !== 2) {\n\t\t\tthrow new Error(a);\n\t\t}\n\t\t}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\n\tt.Run(\"uint8-slice\", func(t *testing.T) {\n\t\tv, err := vm.RunString(`{\n\t\t\tconst buf = new Uint8Array([1, 2]).buffer;\n\t\t\tnew Uint8Array(buf, 1, 1);\n\t\t}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]uint8); ok {\n\t\t\tif len(a) != 1 || a[0] != 2 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t\t_, err = vm.RunString(`{\n\t\tlet a = new Uint8Array([1, 2]);\n\t\tif (a[0] !== 1 || a[1] !== 2) {\n\t\t\tthrow new Error(a);\n\t\t}\n\t\t}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\n\tt.Run(\"int8\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Int8Array([1, -2])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]int8); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != -2 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"uint16\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Uint16Array([1, 63000])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]uint16); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != 63000 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"int16\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Int16Array([1, -31000])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]int16); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != -31000 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"uint32\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Uint32Array([1, 123456])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]uint32); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != 123456 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"int32\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Int32Array([1, -123456])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]int32); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != -123456 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"float32\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Float32Array([1, -1.23456])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]float32); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != -1.23456 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"float64\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new Float64Array([1, -1.23456789])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]float64); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != -1.23456789 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"bigint64\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new BigInt64Array([18446744073709551617n, 2n])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]int64); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != 2 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n\tt.Run(\"biguint64\", func(t *testing.T) {\n\t\tv, err := vm.RunString(\"new BigUint64Array([18446744073709551617n, 2n])\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif a, ok := v.Export().([]uint64); ok {\n\t\t\tif len(a) != 2 || a[0] != 1 || a[1] != 2 {\n\t\t\t\tt.Fatal(a)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Wrong export type\")\n\t\t}\n\t})\n\n}\n"
        },
        {
          "name": "unistring",
          "type": "tree",
          "content": null
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 26.103515625,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"hash/maphash\"\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/dop251/goja/ftoa\"\n\t\"github.com/dop251/goja/unistring\"\n)\n\nvar (\n\t// Not goroutine-safe, do not use for anything other than package level init\n\tpkgHasher maphash.Hash\n\n\thashFalse = randomHash()\n\thashTrue  = randomHash()\n\thashNull  = randomHash()\n\thashUndef = randomHash()\n)\n\n// Not goroutine-safe, do not use for anything other than package level init\nfunc randomHash() uint64 {\n\tpkgHasher.WriteByte(0)\n\treturn pkgHasher.Sum64()\n}\n\nvar (\n\tvalueFalse    Value = valueBool(false)\n\tvalueTrue     Value = valueBool(true)\n\t_null         Value = valueNull{}\n\t_NaN          Value = valueFloat(math.NaN())\n\t_positiveInf  Value = valueFloat(math.Inf(+1))\n\t_negativeInf  Value = valueFloat(math.Inf(-1))\n\t_positiveZero Value = valueInt(0)\n\tnegativeZero        = math.Float64frombits(0 | (1 << 63))\n\t_negativeZero Value = valueFloat(negativeZero)\n\t_epsilon            = valueFloat(2.2204460492503130808472633361816e-16)\n\t_undefined    Value = valueUndefined{}\n)\n\nvar (\n\treflectTypeInt      = reflect.TypeOf(int64(0))\n\treflectTypeBool     = reflect.TypeOf(false)\n\treflectTypeNil      = reflect.TypeOf(nil)\n\treflectTypeFloat    = reflect.TypeOf(float64(0))\n\treflectTypeMap      = reflect.TypeOf(map[string]interface{}{})\n\treflectTypeArray    = reflect.TypeOf([]interface{}{})\n\treflectTypeArrayPtr = reflect.TypeOf((*[]interface{})(nil))\n\treflectTypeString   = reflect.TypeOf(\"\")\n\treflectTypeFunc     = reflect.TypeOf((func(FunctionCall) Value)(nil))\n\treflectTypeError    = reflect.TypeOf((*error)(nil)).Elem()\n)\n\nvar intCache [256]Value\n\n// Value represents an ECMAScript value.\n//\n// Export returns a \"plain\" Go value which type depends on the type of the Value.\n//\n// For integer numbers it's int64.\n//\n// For any other numbers (including Infinities, NaN and negative zero) it's float64.\n//\n// For string it's a string. Note that unicode strings are converted into UTF-8 with invalid code points replaced with utf8.RuneError.\n//\n// For boolean it's bool.\n//\n// For null and undefined it's nil.\n//\n// For Object it depends on the Object type, see Object.Export() for more details.\ntype Value interface {\n\tToInteger() int64\n\ttoString() String\n\tstring() unistring.String\n\tToString() Value\n\tString() string\n\tToFloat() float64\n\tToNumber() Value\n\tToBoolean() bool\n\tToObject(*Runtime) *Object\n\tSameAs(Value) bool\n\tEquals(Value) bool\n\tStrictEquals(Value) bool\n\tExport() interface{}\n\tExportType() reflect.Type\n\n\tbaseObject(r *Runtime) *Object\n\n\thash(hasher *maphash.Hash) uint64\n}\n\ntype valueContainer interface {\n\ttoValue(*Runtime) Value\n}\n\ntype typeError string\ntype rangeError string\ntype referenceError string\ntype syntaxError string\n\ntype valueInt int64\ntype valueFloat float64\ntype valueBool bool\ntype valueNull struct{}\ntype valueUndefined struct {\n\tvalueNull\n}\n\n// *Symbol is a Value containing ECMAScript Symbol primitive. Symbols must only be created\n// using NewSymbol(). Zero values and copying of values (i.e. *s1 = *s2) are not permitted.\n// Well-known Symbols can be accessed using Sym* package variables (SymIterator, etc...)\n// Symbols can be shared by multiple Runtimes.\ntype Symbol struct {\n\th    uintptr\n\tdesc String\n}\n\ntype valueUnresolved struct {\n\tr   *Runtime\n\tref unistring.String\n}\n\ntype memberUnresolved struct {\n\tvalueUnresolved\n}\n\ntype valueProperty struct {\n\tvalue        Value\n\twritable     bool\n\tconfigurable bool\n\tenumerable   bool\n\taccessor     bool\n\tgetterFunc   *Object\n\tsetterFunc   *Object\n}\n\nvar (\n\terrAccessBeforeInit = referenceError(\"Cannot access a variable before initialization\")\n\terrAssignToConst    = typeError(\"Assignment to constant variable.\")\n\terrMixBigIntType    = typeError(\"Cannot mix BigInt and other types, use explicit conversions\")\n)\n\nfunc propGetter(o Value, v Value, r *Runtime) *Object {\n\tif v == _undefined {\n\t\treturn nil\n\t}\n\tif obj, ok := v.(*Object); ok {\n\t\tif _, ok := obj.self.assertCallable(); ok {\n\t\t\treturn obj\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Getter must be a function: %s\", v.toString())\n\treturn nil\n}\n\nfunc propSetter(o Value, v Value, r *Runtime) *Object {\n\tif v == _undefined {\n\t\treturn nil\n\t}\n\tif obj, ok := v.(*Object); ok {\n\t\tif _, ok := obj.self.assertCallable(); ok {\n\t\t\treturn obj\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Setter must be a function: %s\", v.toString())\n\treturn nil\n}\n\nfunc fToStr(num float64, mode ftoa.FToStrMode, prec int) string {\n\tvar buf1 [128]byte\n\treturn string(ftoa.FToStr(num, mode, prec, buf1[:0]))\n}\n\nfunc (i valueInt) ToInteger() int64 {\n\treturn int64(i)\n}\n\nfunc (i valueInt) toString() String {\n\treturn asciiString(i.String())\n}\n\nfunc (i valueInt) string() unistring.String {\n\treturn unistring.String(i.String())\n}\n\nfunc (i valueInt) ToString() Value {\n\treturn i\n}\n\nfunc (i valueInt) String() string {\n\treturn strconv.FormatInt(int64(i), 10)\n}\n\nfunc (i valueInt) ToFloat() float64 {\n\treturn float64(i)\n}\n\nfunc (i valueInt) ToBoolean() bool {\n\treturn i != 0\n}\n\nfunc (i valueInt) ToObject(r *Runtime) *Object {\n\treturn r.newPrimitiveObject(i, r.getNumberPrototype(), classNumber)\n}\n\nfunc (i valueInt) ToNumber() Value {\n\treturn i\n}\n\nfunc (i valueInt) SameAs(other Value) bool {\n\treturn i == other\n}\n\nfunc (i valueInt) Equals(other Value) bool {\n\tswitch o := other.(type) {\n\tcase valueInt:\n\t\treturn i == o\n\tcase *valueBigInt:\n\t\treturn (*big.Int)(o).Cmp(big.NewInt(int64(i))) == 0\n\tcase valueFloat:\n\t\treturn float64(i) == float64(o)\n\tcase String:\n\t\treturn o.ToNumber().Equals(i)\n\tcase valueBool:\n\t\treturn int64(i) == o.ToInteger()\n\tcase *Object:\n\t\treturn i.Equals(o.toPrimitive())\n\t}\n\n\treturn false\n}\n\nfunc (i valueInt) StrictEquals(other Value) bool {\n\tswitch o := other.(type) {\n\tcase valueInt:\n\t\treturn i == o\n\tcase valueFloat:\n\t\treturn float64(i) == float64(o)\n\t}\n\n\treturn false\n}\n\nfunc (i valueInt) baseObject(r *Runtime) *Object {\n\treturn r.getNumberPrototype()\n}\n\nfunc (i valueInt) Export() interface{} {\n\treturn int64(i)\n}\n\nfunc (i valueInt) ExportType() reflect.Type {\n\treturn reflectTypeInt\n}\n\nfunc (i valueInt) hash(*maphash.Hash) uint64 {\n\treturn uint64(i)\n}\n\nfunc (b valueBool) ToInteger() int64 {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc (b valueBool) toString() String {\n\tif b {\n\t\treturn stringTrue\n\t}\n\treturn stringFalse\n}\n\nfunc (b valueBool) ToString() Value {\n\treturn b\n}\n\nfunc (b valueBool) String() string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\n\nfunc (b valueBool) string() unistring.String {\n\treturn unistring.String(b.String())\n}\n\nfunc (b valueBool) ToFloat() float64 {\n\tif b {\n\t\treturn 1.0\n\t}\n\treturn 0\n}\n\nfunc (b valueBool) ToBoolean() bool {\n\treturn bool(b)\n}\n\nfunc (b valueBool) ToObject(r *Runtime) *Object {\n\treturn r.newPrimitiveObject(b, r.getBooleanPrototype(), \"Boolean\")\n}\n\nfunc (b valueBool) ToNumber() Value {\n\tif b {\n\t\treturn valueInt(1)\n\t}\n\treturn valueInt(0)\n}\n\nfunc (b valueBool) SameAs(other Value) bool {\n\tif other, ok := other.(valueBool); ok {\n\t\treturn b == other\n\t}\n\treturn false\n}\n\nfunc (b valueBool) Equals(other Value) bool {\n\tif o, ok := other.(valueBool); ok {\n\t\treturn b == o\n\t}\n\n\tif b {\n\t\treturn other.Equals(intToValue(1))\n\t} else {\n\t\treturn other.Equals(intToValue(0))\n\t}\n\n}\n\nfunc (b valueBool) StrictEquals(other Value) bool {\n\tif other, ok := other.(valueBool); ok {\n\t\treturn b == other\n\t}\n\treturn false\n}\n\nfunc (b valueBool) baseObject(r *Runtime) *Object {\n\treturn r.getBooleanPrototype()\n}\n\nfunc (b valueBool) Export() interface{} {\n\treturn bool(b)\n}\n\nfunc (b valueBool) ExportType() reflect.Type {\n\treturn reflectTypeBool\n}\n\nfunc (b valueBool) hash(*maphash.Hash) uint64 {\n\tif b {\n\t\treturn hashTrue\n\t}\n\n\treturn hashFalse\n}\n\nfunc (n valueNull) ToInteger() int64 {\n\treturn 0\n}\n\nfunc (n valueNull) toString() String {\n\treturn stringNull\n}\n\nfunc (n valueNull) string() unistring.String {\n\treturn stringNull.string()\n}\n\nfunc (n valueNull) ToString() Value {\n\treturn n\n}\n\nfunc (n valueNull) String() string {\n\treturn \"null\"\n}\n\nfunc (u valueUndefined) toString() String {\n\treturn stringUndefined\n}\n\nfunc (u valueUndefined) ToString() Value {\n\treturn u\n}\n\nfunc (u valueUndefined) String() string {\n\treturn \"undefined\"\n}\n\nfunc (u valueUndefined) string() unistring.String {\n\treturn \"undefined\"\n}\n\nfunc (u valueUndefined) ToNumber() Value {\n\treturn _NaN\n}\n\nfunc (u valueUndefined) SameAs(other Value) bool {\n\t_, same := other.(valueUndefined)\n\treturn same\n}\n\nfunc (u valueUndefined) StrictEquals(other Value) bool {\n\t_, same := other.(valueUndefined)\n\treturn same\n}\n\nfunc (u valueUndefined) ToFloat() float64 {\n\treturn math.NaN()\n}\n\nfunc (u valueUndefined) hash(*maphash.Hash) uint64 {\n\treturn hashUndef\n}\n\nfunc (n valueNull) ToFloat() float64 {\n\treturn 0\n}\n\nfunc (n valueNull) ToBoolean() bool {\n\treturn false\n}\n\nfunc (n valueNull) ToObject(r *Runtime) *Object {\n\tr.typeErrorResult(true, \"Cannot convert undefined or null to object\")\n\treturn nil\n\t//return r.newObject()\n}\n\nfunc (n valueNull) ToNumber() Value {\n\treturn intToValue(0)\n}\n\nfunc (n valueNull) SameAs(other Value) bool {\n\t_, same := other.(valueNull)\n\treturn same\n}\n\nfunc (n valueNull) Equals(other Value) bool {\n\tswitch other.(type) {\n\tcase valueUndefined, valueNull:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (n valueNull) StrictEquals(other Value) bool {\n\t_, same := other.(valueNull)\n\treturn same\n}\n\nfunc (n valueNull) baseObject(*Runtime) *Object {\n\treturn nil\n}\n\nfunc (n valueNull) Export() interface{} {\n\treturn nil\n}\n\nfunc (n valueNull) ExportType() reflect.Type {\n\treturn reflectTypeNil\n}\n\nfunc (n valueNull) hash(*maphash.Hash) uint64 {\n\treturn hashNull\n}\n\nfunc (p *valueProperty) ToInteger() int64 {\n\treturn 0\n}\n\nfunc (p *valueProperty) toString() String {\n\treturn stringEmpty\n}\n\nfunc (p *valueProperty) string() unistring.String {\n\treturn \"\"\n}\n\nfunc (p *valueProperty) ToString() Value {\n\treturn _undefined\n}\n\nfunc (p *valueProperty) String() string {\n\treturn \"\"\n}\n\nfunc (p *valueProperty) ToFloat() float64 {\n\treturn math.NaN()\n}\n\nfunc (p *valueProperty) ToBoolean() bool {\n\treturn false\n}\n\nfunc (p *valueProperty) ToObject(*Runtime) *Object {\n\treturn nil\n}\n\nfunc (p *valueProperty) ToNumber() Value {\n\treturn nil\n}\n\nfunc (p *valueProperty) isWritable() bool {\n\treturn p.writable || p.setterFunc != nil\n}\n\nfunc (p *valueProperty) get(this Value) Value {\n\tif p.getterFunc == nil {\n\t\tif p.value != nil {\n\t\t\treturn p.value\n\t\t}\n\t\treturn _undefined\n\t}\n\tcall, _ := p.getterFunc.self.assertCallable()\n\treturn call(FunctionCall{\n\t\tThis: this,\n\t})\n}\n\nfunc (p *valueProperty) set(this, v Value) {\n\tif p.setterFunc == nil {\n\t\tp.value = v\n\t\treturn\n\t}\n\tcall, _ := p.setterFunc.self.assertCallable()\n\tcall(FunctionCall{\n\t\tThis:      this,\n\t\tArguments: []Value{v},\n\t})\n}\n\nfunc (p *valueProperty) SameAs(other Value) bool {\n\tif otherProp, ok := other.(*valueProperty); ok {\n\t\treturn p == otherProp\n\t}\n\treturn false\n}\n\nfunc (p *valueProperty) Equals(Value) bool {\n\treturn false\n}\n\nfunc (p *valueProperty) StrictEquals(Value) bool {\n\treturn false\n}\n\nfunc (p *valueProperty) baseObject(r *Runtime) *Object {\n\tr.typeErrorResult(true, \"BUG: baseObject() is called on valueProperty\") // TODO error message\n\treturn nil\n}\n\nfunc (p *valueProperty) Export() interface{} {\n\tpanic(\"Cannot export valueProperty\")\n}\n\nfunc (p *valueProperty) ExportType() reflect.Type {\n\tpanic(\"Cannot export valueProperty\")\n}\n\nfunc (p *valueProperty) hash(*maphash.Hash) uint64 {\n\tpanic(\"valueProperty should never be used in maps or sets\")\n}\n\nfunc floatToIntClip(n float64) int64 {\n\tswitch {\n\tcase math.IsNaN(n):\n\t\treturn 0\n\tcase n >= math.MaxInt64:\n\t\treturn math.MaxInt64\n\tcase n <= math.MinInt64:\n\t\treturn math.MinInt64\n\t}\n\treturn int64(n)\n}\n\nfunc (f valueFloat) ToInteger() int64 {\n\treturn floatToIntClip(float64(f))\n}\n\nfunc (f valueFloat) toString() String {\n\treturn asciiString(f.String())\n}\n\nfunc (f valueFloat) string() unistring.String {\n\treturn unistring.String(f.String())\n}\n\nfunc (f valueFloat) ToString() Value {\n\treturn f\n}\n\nfunc (f valueFloat) String() string {\n\treturn fToStr(float64(f), ftoa.ModeStandard, 0)\n}\n\nfunc (f valueFloat) ToFloat() float64 {\n\treturn float64(f)\n}\n\nfunc (f valueFloat) ToBoolean() bool {\n\treturn float64(f) != 0.0 && !math.IsNaN(float64(f))\n}\n\nfunc (f valueFloat) ToObject(r *Runtime) *Object {\n\treturn r.newPrimitiveObject(f, r.getNumberPrototype(), \"Number\")\n}\n\nfunc (f valueFloat) ToNumber() Value {\n\treturn f\n}\n\nfunc (f valueFloat) SameAs(other Value) bool {\n\tswitch o := other.(type) {\n\tcase valueFloat:\n\t\tthis := float64(f)\n\t\to1 := float64(o)\n\t\tif math.IsNaN(this) && math.IsNaN(o1) {\n\t\t\treturn true\n\t\t} else {\n\t\t\tret := this == o1\n\t\t\tif ret && this == 0 {\n\t\t\t\tret = math.Signbit(this) == math.Signbit(o1)\n\t\t\t}\n\t\t\treturn ret\n\t\t}\n\tcase valueInt:\n\t\tthis := float64(f)\n\t\tret := this == float64(o)\n\t\tif ret && this == 0 {\n\t\t\tret = !math.Signbit(this)\n\t\t}\n\t\treturn ret\n\t}\n\n\treturn false\n}\n\nfunc (f valueFloat) Equals(other Value) bool {\n\tswitch o := other.(type) {\n\tcase valueFloat:\n\t\treturn f == o\n\tcase valueInt:\n\t\treturn float64(f) == float64(o)\n\tcase *valueBigInt:\n\t\tif IsInfinity(f) || math.IsNaN(float64(f)) {\n\t\t\treturn false\n\t\t}\n\t\tif f := big.NewFloat(float64(f)); f.IsInt() {\n\t\t\ti, _ := f.Int(nil)\n\t\t\treturn (*big.Int)(o).Cmp(i) == 0\n\t\t}\n\t\treturn false\n\tcase String, valueBool:\n\t\treturn float64(f) == o.ToFloat()\n\tcase *Object:\n\t\treturn f.Equals(o.toPrimitive())\n\t}\n\n\treturn false\n}\n\nfunc (f valueFloat) StrictEquals(other Value) bool {\n\tswitch o := other.(type) {\n\tcase valueFloat:\n\t\treturn f == o\n\tcase valueInt:\n\t\treturn float64(f) == float64(o)\n\t}\n\n\treturn false\n}\n\nfunc (f valueFloat) baseObject(r *Runtime) *Object {\n\treturn r.getNumberPrototype()\n}\n\nfunc (f valueFloat) Export() interface{} {\n\treturn float64(f)\n}\n\nfunc (f valueFloat) ExportType() reflect.Type {\n\treturn reflectTypeFloat\n}\n\nfunc (f valueFloat) hash(*maphash.Hash) uint64 {\n\tif f == _negativeZero {\n\t\treturn 0\n\t}\n\treturn math.Float64bits(float64(f))\n}\n\nfunc (o *Object) ToInteger() int64 {\n\treturn o.toPrimitiveNumber().ToNumber().ToInteger()\n}\n\nfunc (o *Object) toString() String {\n\treturn o.toPrimitiveString().toString()\n}\n\nfunc (o *Object) string() unistring.String {\n\treturn o.toPrimitiveString().string()\n}\n\nfunc (o *Object) ToString() Value {\n\treturn o.toPrimitiveString().ToString()\n}\n\nfunc (o *Object) String() string {\n\treturn o.toPrimitiveString().String()\n}\n\nfunc (o *Object) ToFloat() float64 {\n\treturn o.toPrimitiveNumber().ToFloat()\n}\n\nfunc (o *Object) ToBoolean() bool {\n\treturn true\n}\n\nfunc (o *Object) ToObject(*Runtime) *Object {\n\treturn o\n}\n\nfunc (o *Object) ToNumber() Value {\n\treturn o.toPrimitiveNumber().ToNumber()\n}\n\nfunc (o *Object) SameAs(other Value) bool {\n\treturn o.StrictEquals(other)\n}\n\nfunc (o *Object) Equals(other Value) bool {\n\tif other, ok := other.(*Object); ok {\n\t\treturn o == other || o.self.equal(other.self)\n\t}\n\n\tswitch o1 := other.(type) {\n\tcase valueInt, valueFloat, *valueBigInt, String, *Symbol:\n\t\treturn o.toPrimitive().Equals(other)\n\tcase valueBool:\n\t\treturn o.Equals(o1.ToNumber())\n\t}\n\n\treturn false\n}\n\nfunc (o *Object) StrictEquals(other Value) bool {\n\tif other, ok := other.(*Object); ok {\n\t\treturn o == other || o != nil && other != nil && o.self.equal(other.self)\n\t}\n\treturn false\n}\n\nfunc (o *Object) baseObject(*Runtime) *Object {\n\treturn o\n}\n\n// Export the Object to a plain Go type.\n// If the Object is a wrapped Go value (created using ToValue()) returns the original value.\n//\n// If the Object is a function, returns func(FunctionCall) Value. Note that exceptions thrown inside the function\n// result in panics, which can also leave the Runtime in an unusable state. Therefore, these values should only\n// be used inside another ES function implemented in Go. For calling a function from Go, use AssertFunction() or\n// Runtime.ExportTo() as described in the README.\n//\n// For a Map, returns the list of entries as [][2]interface{}.\n//\n// For a Set, returns the list of elements as []interface{}.\n//\n// For a Proxy, returns Proxy.\n//\n// For a Promise, returns Promise.\n//\n// For a DynamicObject or a DynamicArray, returns the underlying handler.\n//\n// For typed arrays it returns a slice of the corresponding type backed by the original data (i.e. it does not copy).\n//\n// For an untyped array, returns its items exported into a newly created []interface{}.\n//\n// In all other cases returns own enumerable non-symbol properties as map[string]interface{}.\n//\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) Export() interface{} {\n\treturn o.self.export(&objectExportCtx{})\n}\n\n// ExportType returns the type of the value that is returned by Export().\nfunc (o *Object) ExportType() reflect.Type {\n\treturn o.self.exportType()\n}\n\nfunc (o *Object) hash(*maphash.Hash) uint64 {\n\treturn o.getId()\n}\n\n// Get an object's property by name.\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) Get(name string) Value {\n\treturn o.self.getStr(unistring.NewFromString(name), nil)\n}\n\n// GetSymbol returns the value of a symbol property. Use one of the Sym* values for well-known\n// symbols (such as SymIterator, SymToStringTag, etc...).\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) GetSymbol(sym *Symbol) Value {\n\treturn o.self.getSym(sym, nil)\n}\n\n// Keys returns a list of Object's enumerable keys.\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) Keys() (keys []string) {\n\titer := &enumerableIter{\n\t\to:       o,\n\t\twrapped: o.self.iterateStringKeys(),\n\t}\n\tfor item, next := iter.next(); next != nil; item, next = next() {\n\t\tkeys = append(keys, item.name.String())\n\t}\n\n\treturn\n}\n\n// GetOwnPropertyNames returns a list of all own string properties of the Object, similar to Object.getOwnPropertyNames()\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) GetOwnPropertyNames() (keys []string) {\n\tfor item, next := o.self.iterateStringKeys()(); next != nil; item, next = next() {\n\t\tkeys = append(keys, item.name.String())\n\t}\n\n\treturn\n}\n\n// Symbols returns a list of Object's enumerable symbol properties.\n// This method will panic with an *Exception if a JavaScript exception is thrown in the process. Use Runtime.Try to catch these.\nfunc (o *Object) Symbols() []*Symbol {\n\tsymbols := o.self.symbols(false, nil)\n\tret := make([]*Symbol, len(symbols))\n\tfor i, sym := range symbols {\n\t\tret[i], _ = sym.(*Symbol)\n\t}\n\treturn ret\n}\n\n// DefineDataProperty is a Go equivalent of Object.defineProperty(o, name, {value: value, writable: writable,\n// configurable: configurable, enumerable: enumerable})\nfunc (o *Object) DefineDataProperty(name string, value Value, writable, configurable, enumerable Flag) error {\n\treturn o.runtime.try(func() {\n\t\to.self.defineOwnPropertyStr(unistring.NewFromString(name), PropertyDescriptor{\n\t\t\tValue:        value,\n\t\t\tWritable:     writable,\n\t\t\tConfigurable: configurable,\n\t\t\tEnumerable:   enumerable,\n\t\t}, true)\n\t})\n}\n\n// DefineAccessorProperty is a Go equivalent of Object.defineProperty(o, name, {get: getter, set: setter,\n// configurable: configurable, enumerable: enumerable})\nfunc (o *Object) DefineAccessorProperty(name string, getter, setter Value, configurable, enumerable Flag) error {\n\treturn o.runtime.try(func() {\n\t\to.self.defineOwnPropertyStr(unistring.NewFromString(name), PropertyDescriptor{\n\t\t\tGetter:       getter,\n\t\t\tSetter:       setter,\n\t\t\tConfigurable: configurable,\n\t\t\tEnumerable:   enumerable,\n\t\t}, true)\n\t})\n}\n\n// DefineDataPropertySymbol is a Go equivalent of Object.defineProperty(o, name, {value: value, writable: writable,\n// configurable: configurable, enumerable: enumerable})\nfunc (o *Object) DefineDataPropertySymbol(name *Symbol, value Value, writable, configurable, enumerable Flag) error {\n\treturn o.runtime.try(func() {\n\t\to.self.defineOwnPropertySym(name, PropertyDescriptor{\n\t\t\tValue:        value,\n\t\t\tWritable:     writable,\n\t\t\tConfigurable: configurable,\n\t\t\tEnumerable:   enumerable,\n\t\t}, true)\n\t})\n}\n\n// DefineAccessorPropertySymbol is a Go equivalent of Object.defineProperty(o, name, {get: getter, set: setter,\n// configurable: configurable, enumerable: enumerable})\nfunc (o *Object) DefineAccessorPropertySymbol(name *Symbol, getter, setter Value, configurable, enumerable Flag) error {\n\treturn o.runtime.try(func() {\n\t\to.self.defineOwnPropertySym(name, PropertyDescriptor{\n\t\t\tGetter:       getter,\n\t\t\tSetter:       setter,\n\t\t\tConfigurable: configurable,\n\t\t\tEnumerable:   enumerable,\n\t\t}, true)\n\t})\n}\n\nfunc (o *Object) Set(name string, value interface{}) error {\n\treturn o.runtime.try(func() {\n\t\to.self.setOwnStr(unistring.NewFromString(name), o.runtime.ToValue(value), true)\n\t})\n}\n\nfunc (o *Object) SetSymbol(name *Symbol, value interface{}) error {\n\treturn o.runtime.try(func() {\n\t\to.self.setOwnSym(name, o.runtime.ToValue(value), true)\n\t})\n}\n\nfunc (o *Object) Delete(name string) error {\n\treturn o.runtime.try(func() {\n\t\to.self.deleteStr(unistring.NewFromString(name), true)\n\t})\n}\n\nfunc (o *Object) DeleteSymbol(name *Symbol) error {\n\treturn o.runtime.try(func() {\n\t\to.self.deleteSym(name, true)\n\t})\n}\n\n// Prototype returns the Object's prototype, same as Object.getPrototypeOf(). If the prototype is null\n// returns nil.\nfunc (o *Object) Prototype() *Object {\n\treturn o.self.proto()\n}\n\n// SetPrototype sets the Object's prototype, same as Object.setPrototypeOf(). Setting proto to nil\n// is an equivalent of Object.setPrototypeOf(null).\nfunc (o *Object) SetPrototype(proto *Object) error {\n\treturn o.runtime.try(func() {\n\t\to.self.setProto(proto, true)\n\t})\n}\n\n// MarshalJSON returns JSON representation of the Object. It is equivalent to JSON.stringify(o).\n// Note, this implements json.Marshaler so that json.Marshal() can be used without the need to Export().\nfunc (o *Object) MarshalJSON() ([]byte, error) {\n\tctx := _builtinJSON_stringifyContext{\n\t\tr: o.runtime,\n\t}\n\tex := o.runtime.vm.try(func() {\n\t\tif !ctx.do(o) {\n\t\t\tctx.buf.WriteString(\"null\")\n\t\t}\n\t})\n\tif ex != nil {\n\t\treturn nil, ex\n\t}\n\treturn ctx.buf.Bytes(), nil\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface. It is added to compliment MarshalJSON, because\n// some alternative JSON encoders refuse to use MarshalJSON unless UnmarshalJSON is also present.\n// It is a no-op and always returns nil.\nfunc (o *Object) UnmarshalJSON([]byte) error {\n\treturn nil\n}\n\n// ClassName returns the class name\nfunc (o *Object) ClassName() string {\n\treturn o.self.className()\n}\n\nfunc (o valueUnresolved) throw() {\n\to.r.throwReferenceError(o.ref)\n}\n\nfunc (o valueUnresolved) ToInteger() int64 {\n\to.throw()\n\treturn 0\n}\n\nfunc (o valueUnresolved) toString() String {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) string() unistring.String {\n\to.throw()\n\treturn \"\"\n}\n\nfunc (o valueUnresolved) ToString() Value {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) String() string {\n\to.throw()\n\treturn \"\"\n}\n\nfunc (o valueUnresolved) ToFloat() float64 {\n\to.throw()\n\treturn 0\n}\n\nfunc (o valueUnresolved) ToBoolean() bool {\n\to.throw()\n\treturn false\n}\n\nfunc (o valueUnresolved) ToObject(*Runtime) *Object {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) ToNumber() Value {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) SameAs(Value) bool {\n\to.throw()\n\treturn false\n}\n\nfunc (o valueUnresolved) Equals(Value) bool {\n\to.throw()\n\treturn false\n}\n\nfunc (o valueUnresolved) StrictEquals(Value) bool {\n\to.throw()\n\treturn false\n}\n\nfunc (o valueUnresolved) baseObject(*Runtime) *Object {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) Export() interface{} {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) ExportType() reflect.Type {\n\to.throw()\n\treturn nil\n}\n\nfunc (o valueUnresolved) hash(*maphash.Hash) uint64 {\n\to.throw()\n\treturn 0\n}\n\nfunc (s *Symbol) ToInteger() int64 {\n\tpanic(typeError(\"Cannot convert a Symbol value to a number\"))\n}\n\nfunc (s *Symbol) toString() String {\n\tpanic(typeError(\"Cannot convert a Symbol value to a string\"))\n}\n\nfunc (s *Symbol) ToString() Value {\n\treturn s\n}\n\nfunc (s *Symbol) String() string {\n\tif s.desc != nil {\n\t\treturn s.desc.String()\n\t}\n\treturn \"\"\n}\n\nfunc (s *Symbol) string() unistring.String {\n\tif s.desc != nil {\n\t\treturn s.desc.string()\n\t}\n\treturn \"\"\n}\n\nfunc (s *Symbol) ToFloat() float64 {\n\tpanic(typeError(\"Cannot convert a Symbol value to a number\"))\n}\n\nfunc (s *Symbol) ToNumber() Value {\n\tpanic(typeError(\"Cannot convert a Symbol value to a number\"))\n}\n\nfunc (s *Symbol) ToBoolean() bool {\n\treturn true\n}\n\nfunc (s *Symbol) ToObject(r *Runtime) *Object {\n\treturn s.baseObject(r)\n}\n\nfunc (s *Symbol) SameAs(other Value) bool {\n\tif s1, ok := other.(*Symbol); ok {\n\t\treturn s == s1\n\t}\n\treturn false\n}\n\nfunc (s *Symbol) Equals(o Value) bool {\n\tswitch o := o.(type) {\n\tcase *Object:\n\t\treturn s.Equals(o.toPrimitive())\n\t}\n\treturn s.SameAs(o)\n}\n\nfunc (s *Symbol) StrictEquals(o Value) bool {\n\treturn s.SameAs(o)\n}\n\nfunc (s *Symbol) Export() interface{} {\n\treturn s.String()\n}\n\nfunc (s *Symbol) ExportType() reflect.Type {\n\treturn reflectTypeString\n}\n\nfunc (s *Symbol) baseObject(r *Runtime) *Object {\n\treturn r.newPrimitiveObject(s, r.getSymbolPrototype(), classObject)\n}\n\nfunc (s *Symbol) hash(*maphash.Hash) uint64 {\n\treturn uint64(s.h)\n}\n\nfunc exportValue(v Value, ctx *objectExportCtx) interface{} {\n\tif obj, ok := v.(*Object); ok {\n\t\treturn obj.self.export(ctx)\n\t}\n\treturn v.Export()\n}\n\nfunc newSymbol(s String) *Symbol {\n\tr := &Symbol{\n\t\tdesc: s,\n\t}\n\t// This may need to be reconsidered in the future.\n\t// Depending on changes in Go's allocation policy and/or introduction of a compacting GC\n\t// this may no longer provide sufficient dispersion. The alternative, however, is a globally\n\t// synchronised random generator/hasher/sequencer and I don't want to go down that route just yet.\n\tr.h = uintptr(unsafe.Pointer(r))\n\treturn r\n}\n\nfunc NewSymbol(s string) *Symbol {\n\treturn newSymbol(newStringValue(s))\n}\n\nfunc (s *Symbol) descriptiveString() String {\n\tdesc := s.desc\n\tif desc == nil {\n\t\tdesc = stringEmpty\n\t}\n\treturn asciiString(\"Symbol(\").Concat(desc).Concat(asciiString(\")\"))\n}\n\nfunc funcName(prefix string, n Value) String {\n\tvar b StringBuilder\n\tb.WriteString(asciiString(prefix))\n\tif sym, ok := n.(*Symbol); ok {\n\t\tif sym.desc != nil {\n\t\t\tb.WriteRune('[')\n\t\t\tb.WriteString(sym.desc)\n\t\t\tb.WriteRune(']')\n\t\t}\n\t} else {\n\t\tb.WriteString(n.toString())\n\t}\n\treturn b.String()\n}\n\nfunc newTypeError(args ...interface{}) typeError {\n\tmsg := \"\"\n\tif len(args) > 0 {\n\t\tf, _ := args[0].(string)\n\t\tmsg = fmt.Sprintf(f, args[1:]...)\n\t}\n\treturn typeError(msg)\n}\n\nfunc typeErrorResult(throw bool, args ...interface{}) {\n\tif throw {\n\t\tpanic(newTypeError(args...))\n\t}\n\n}\n\nfunc init() {\n\tfor i := 0; i < 256; i++ {\n\t\tintCache[i] = valueInt(i - 256)\n\t}\n}\n"
        },
        {
          "name": "vm.go",
          "type": "blob",
          "size": 115.6513671875,
          "content": "package goja\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/dop251/goja/unistring\"\n)\n\nconst (\n\tmaxInt = 1 << 53\n\n\ttryPanicMarker = -2\n)\n\ntype valueStack []Value\n\ntype stash struct {\n\tvalues    []Value\n\textraArgs []Value\n\tnames     map[unistring.String]uint32\n\tobj       *Object\n\n\touter *stash\n\n\t// If this is a top-level function stash, sets the type of the function. If set, dynamic var declarations\n\t// created by direct eval go here.\n\tfuncType funcType\n}\n\ntype context struct {\n\tprg       *Program\n\tstash     *stash\n\tprivEnv   *privateEnv\n\tnewTarget Value\n\tresult    Value\n\tpc, sb    int\n\targs      int\n}\n\ntype tryFrame struct {\n\t// holds an uncaught exception for the 'finally' block\n\texception *Exception\n\n\tcallStackLen, iterLen, refLen uint32\n\n\tsp      int32\n\tstash   *stash\n\tprivEnv *privateEnv\n\n\tcatchPos, finallyPos, finallyRet int32\n}\n\ntype execCtx struct {\n\tcontext\n\tstack     []Value\n\ttryStack  []tryFrame\n\titerStack []iterStackItem\n\trefStack  []ref\n}\n\nfunc (vm *vm) suspend(ectx *execCtx, tryStackLen, iterStackLen, refStackLen uint32) {\n\tvm.saveCtx(&ectx.context)\n\tectx.stack = append(ectx.stack[:0], vm.stack[vm.sb-1:vm.sp]...)\n\tif len(vm.tryStack) > int(tryStackLen) {\n\t\tectx.tryStack = append(ectx.tryStack[:0], vm.tryStack[tryStackLen:]...)\n\t\tvm.tryStack = vm.tryStack[:tryStackLen]\n\t\tsp := int32(vm.sb - 1)\n\t\tfor i := range ectx.tryStack {\n\t\t\ttf := &ectx.tryStack[i]\n\t\t\ttf.iterLen -= iterStackLen\n\t\t\ttf.refLen -= refStackLen\n\t\t\ttf.sp -= sp\n\t\t}\n\t}\n\tif len(vm.iterStack) > int(iterStackLen) {\n\t\tectx.iterStack = append(ectx.iterStack[:0], vm.iterStack[iterStackLen:]...)\n\t\tvm.iterStack = vm.iterStack[:iterStackLen]\n\t}\n\tif len(vm.refStack) > int(refStackLen) {\n\t\tectx.refStack = append(ectx.refStack[:0], vm.refStack[refStackLen:]...)\n\t\tvm.refStack = vm.refStack[:refStackLen]\n\t}\n}\n\nfunc (vm *vm) resume(ctx *execCtx) {\n\tvm.restoreCtx(&ctx.context)\n\tsp := vm.sp\n\tvm.sb = sp + 1\n\tvm.stack.expand(sp + len(ctx.stack))\n\tcopy(vm.stack[sp:], ctx.stack)\n\tvm.sp += len(ctx.stack)\n\tfor i := range ctx.tryStack {\n\t\ttf := &ctx.tryStack[i]\n\t\ttf.callStackLen = uint32(len(vm.callStack))\n\t\ttf.iterLen += uint32(len(vm.iterStack))\n\t\ttf.refLen += uint32(len(vm.refStack))\n\t\ttf.sp += int32(sp)\n\t}\n\tvm.tryStack = append(vm.tryStack, ctx.tryStack...)\n\tvm.iterStack = append(vm.iterStack, ctx.iterStack...)\n\tvm.refStack = append(vm.refStack, ctx.refStack...)\n}\n\ntype iterStackItem struct {\n\tval  Value\n\tf    iterNextFunc\n\titer *iteratorRecord\n}\n\ntype ref interface {\n\tget() Value\n\tset(Value)\n\tinit(Value)\n\trefname() unistring.String\n}\n\ntype stashRef struct {\n\tn   unistring.String\n\tv   *[]Value\n\tidx int\n}\n\nfunc (r *stashRef) get() Value {\n\treturn nilSafe((*r.v)[r.idx])\n}\n\nfunc (r *stashRef) set(v Value) {\n\t(*r.v)[r.idx] = v\n}\n\nfunc (r *stashRef) init(v Value) {\n\tr.set(v)\n}\n\nfunc (r *stashRef) refname() unistring.String {\n\treturn r.n\n}\n\ntype thisRef struct {\n\tv   *[]Value\n\tidx int\n}\n\nfunc (r *thisRef) get() Value {\n\tv := (*r.v)[r.idx]\n\tif v == nil {\n\t\tpanic(referenceError(\"Must call super constructor in derived class before accessing 'this'\"))\n\t}\n\n\treturn v\n}\n\nfunc (r *thisRef) set(v Value) {\n\tptr := &(*r.v)[r.idx]\n\tif *ptr != nil {\n\t\tpanic(referenceError(\"Super constructor may only be called once\"))\n\t}\n\t*ptr = v\n}\n\nfunc (r *thisRef) init(v Value) {\n\tr.set(v)\n}\n\nfunc (r *thisRef) refname() unistring.String {\n\treturn thisBindingName\n}\n\ntype stashRefLex struct {\n\tstashRef\n}\n\nfunc (r *stashRefLex) get() Value {\n\tv := (*r.v)[r.idx]\n\tif v == nil {\n\t\tpanic(errAccessBeforeInit)\n\t}\n\treturn v\n}\n\nfunc (r *stashRefLex) set(v Value) {\n\tp := &(*r.v)[r.idx]\n\tif *p == nil {\n\t\tpanic(errAccessBeforeInit)\n\t}\n\t*p = v\n}\n\nfunc (r *stashRefLex) init(v Value) {\n\t(*r.v)[r.idx] = v\n}\n\ntype stashRefConst struct {\n\tstashRefLex\n\tstrictConst bool\n}\n\nfunc (r *stashRefConst) set(v Value) {\n\tif r.strictConst {\n\t\tpanic(errAssignToConst)\n\t}\n}\n\ntype objRef struct {\n\tbase   *Object\n\tname   Value\n\tthis   Value\n\tstrict bool\n\n\tnameConverted bool\n}\n\nfunc (r *objRef) getKey() Value {\n\tif !r.nameConverted {\n\t\tr.name = toPropertyKey(r.name)\n\t\tr.nameConverted = true\n\t}\n\treturn r.name\n}\n\nfunc (r *objRef) get() Value {\n\treturn r.base.get(r.getKey(), r.this)\n}\n\nfunc (r *objRef) set(v Value) {\n\tkey := r.getKey()\n\tif r.this != nil {\n\t\tr.base.set(key, v, r.this, r.strict)\n\t} else {\n\t\tr.base.setOwn(key, v, r.strict)\n\t}\n}\n\nfunc (r *objRef) init(v Value) {\n\tif r.this != nil {\n\t\tr.base.set(r.getKey(), v, r.this, r.strict)\n\t} else {\n\t\tr.base.setOwn(r.getKey(), v, r.strict)\n\t}\n}\n\nfunc (r *objRef) refname() unistring.String {\n\treturn r.getKey().string()\n}\n\ntype objStrRef struct {\n\tbase    *Object\n\tname    unistring.String\n\tthis    Value\n\tstrict  bool\n\tbinding bool\n}\n\nfunc (r *objStrRef) get() Value {\n\treturn r.base.self.getStr(r.name, r.this)\n}\n\nfunc (r *objStrRef) set(v Value) {\n\tif r.strict && r.binding && !r.base.self.hasOwnPropertyStr(r.name) {\n\t\tpanic(referenceError(fmt.Sprintf(\"%s is not defined\", r.name)))\n\t}\n\tif r.this != nil {\n\t\tr.base.setStr(r.name, v, r.this, r.strict)\n\t} else {\n\t\tr.base.self.setOwnStr(r.name, v, r.strict)\n\t}\n}\n\nfunc (r *objStrRef) init(v Value) {\n\tif r.this != nil {\n\t\tr.base.setStr(r.name, v, r.this, r.strict)\n\t} else {\n\t\tr.base.self.setOwnStr(r.name, v, r.strict)\n\t}\n}\n\nfunc (r *objStrRef) refname() unistring.String {\n\treturn r.name\n}\n\ntype privateRefRes struct {\n\tbase *Object\n\tname *resolvedPrivateName\n}\n\nfunc (p *privateRefRes) get() Value {\n\treturn (*getPrivatePropRes)(p.name)._get(p.base, p.base.runtime.vm)\n}\n\nfunc (p *privateRefRes) set(value Value) {\n\t(*setPrivatePropRes)(p.name)._set(p.base, value, p.base.runtime.vm)\n}\n\nfunc (p *privateRefRes) init(value Value) {\n\tpanic(\"not supported\")\n}\n\nfunc (p *privateRefRes) refname() unistring.String {\n\treturn p.name.string()\n}\n\ntype privateRefId struct {\n\tbase *Object\n\tid   *privateId\n}\n\nfunc (p *privateRefId) get() Value {\n\treturn p.base.runtime.vm.getPrivateProp(p.base, p.id.name, p.id.typ, p.id.idx, p.id.isMethod)\n}\n\nfunc (p *privateRefId) set(value Value) {\n\tp.base.runtime.vm.setPrivateProp(p.base, p.id.name, p.id.typ, p.id.idx, p.id.isMethod, value)\n}\n\nfunc (p *privateRefId) init(value Value) {\n\tpanic(\"not supported\")\n}\n\nfunc (p *privateRefId) refname() unistring.String {\n\treturn p.id.string()\n}\n\ntype unresolvedRef struct {\n\truntime *Runtime\n\tname    unistring.String\n}\n\nfunc (r *unresolvedRef) get() Value {\n\tr.runtime.throwReferenceError(r.name)\n\tpanic(\"Unreachable\")\n}\n\nfunc (r *unresolvedRef) set(Value) {\n\tr.get()\n}\n\nfunc (r *unresolvedRef) init(Value) {\n\tr.get()\n}\n\nfunc (r *unresolvedRef) refname() unistring.String {\n\treturn r.name\n}\n\ntype vm struct {\n\tr            *Runtime\n\tprg          *Program\n\tpc           int\n\tstack        valueStack\n\tsp, sb, args int\n\n\tstash     *stash\n\tprivEnv   *privateEnv\n\tcallStack []context\n\titerStack []iterStackItem\n\trefStack  []ref\n\ttryStack  []tryFrame\n\tnewTarget Value\n\tresult    Value\n\n\tmaxCallStackSize int\n\n\tstashAllocs int\n\n\tinterrupted   uint32\n\tinterruptVal  interface{}\n\tinterruptLock sync.Mutex\n\n\tcurAsyncRunner *asyncRunner\n\n\tprofTracker *profTracker\n}\n\ntype instruction interface {\n\texec(*vm)\n}\n\nfunc intToValue(i int64) Value {\n\tif idx := 256 + i; idx >= 0 && idx < 256 {\n\t\treturn intCache[idx]\n\t}\n\tif i >= -maxInt && i <= maxInt {\n\t\treturn valueInt(i)\n\t}\n\treturn valueFloat(i)\n}\n\nfunc floatToInt(f float64) (result int64, ok bool) {\n\tif (f != 0 || !math.Signbit(f)) && !math.IsInf(f, 0) && f == math.Trunc(f) && f >= -maxInt && f <= maxInt {\n\t\treturn int64(f), true\n\t}\n\treturn 0, false\n}\n\nfunc floatToValue(f float64) (result Value) {\n\tif i, ok := floatToInt(f); ok {\n\t\treturn intToValue(i)\n\t}\n\tswitch {\n\tcase f == 0:\n\t\treturn _negativeZero\n\tcase math.IsNaN(f):\n\t\treturn _NaN\n\tcase math.IsInf(f, 1):\n\t\treturn _positiveInf\n\tcase math.IsInf(f, -1):\n\t\treturn _negativeInf\n\t}\n\treturn valueFloat(f)\n}\n\nfunc toNumeric(value Value) Value {\n\tswitch v := value.(type) {\n\tcase valueInt, *valueBigInt:\n\t\treturn v\n\tcase valueFloat:\n\t\treturn floatToValue(float64(v))\n\tcase *Object:\n\t\tprimValue := v.toPrimitiveNumber()\n\t\tif bigint, ok := primValue.(*valueBigInt); ok {\n\t\t\treturn bigint\n\t\t}\n\t\treturn primValue.ToNumber()\n\t}\n\treturn value.ToNumber()\n}\n\nfunc (s *valueStack) expand(idx int) {\n\tif idx < len(*s) {\n\t\treturn\n\t}\n\tidx++\n\tif idx < cap(*s) {\n\t\t*s = (*s)[:idx]\n\t} else {\n\t\tvar newCap int\n\t\tif idx < 1024 {\n\t\t\tnewCap = idx * 2\n\t\t} else {\n\t\t\tnewCap = (idx + 1025) &^ 1023\n\t\t}\n\t\tn := make([]Value, idx, newCap)\n\t\tcopy(n, *s)\n\t\t*s = n\n\t}\n}\n\nfunc stashObjHas(obj *Object, name unistring.String) bool {\n\tif obj.self.hasPropertyStr(name) {\n\t\tif unscopables, ok := obj.self.getSym(SymUnscopables, nil).(*Object); ok {\n\t\t\tif b := unscopables.self.getStr(name, nil); b != nil {\n\t\t\t\treturn !b.ToBoolean()\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *stash) isVariable() bool {\n\treturn s.funcType != funcNone\n}\n\nfunc (s *stash) initByIdx(idx uint32, v Value) {\n\tif s.obj != nil {\n\t\tpanic(\"Attempt to init by idx into an object scope\")\n\t}\n\ts.values[idx] = v\n}\n\nfunc (s *stash) initByName(name unistring.String, v Value) {\n\tif idx, exists := s.names[name]; exists {\n\t\ts.values[idx&^maskTyp] = v\n\t} else {\n\t\tpanic(referenceError(fmt.Sprintf(\"%s is not defined\", name)))\n\t}\n}\n\nfunc (s *stash) getByIdx(idx uint32) Value {\n\treturn s.values[idx]\n}\n\nfunc (s *stash) getByName(name unistring.String) (v Value, exists bool) {\n\tif s.obj != nil {\n\t\tif stashObjHas(s.obj, name) {\n\t\t\treturn nilSafe(s.obj.self.getStr(name, nil)), true\n\t\t}\n\t\treturn nil, false\n\t}\n\tif idx, exists := s.names[name]; exists {\n\t\tv := s.values[idx&^maskTyp]\n\t\tif v == nil {\n\t\t\tif idx&maskVar == 0 {\n\t\t\t\tpanic(errAccessBeforeInit)\n\t\t\t} else {\n\t\t\t\tv = _undefined\n\t\t\t}\n\t\t}\n\t\treturn v, true\n\t}\n\treturn nil, false\n}\n\nfunc (s *stash) getRefByName(name unistring.String, strict bool) ref {\n\tif obj := s.obj; obj != nil {\n\t\tif stashObjHas(obj, name) {\n\t\t\treturn &objStrRef{\n\t\t\t\tbase:    obj,\n\t\t\t\tname:    name,\n\t\t\t\tstrict:  strict,\n\t\t\t\tbinding: true,\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif idx, exists := s.names[name]; exists {\n\t\t\tif idx&maskVar == 0 {\n\t\t\t\tif idx&maskConst == 0 {\n\t\t\t\t\treturn &stashRefLex{\n\t\t\t\t\t\tstashRef: stashRef{\n\t\t\t\t\t\t\tn:   name,\n\t\t\t\t\t\t\tv:   &s.values,\n\t\t\t\t\t\t\tidx: int(idx &^ maskTyp),\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn &stashRefConst{\n\t\t\t\t\t\tstashRefLex: stashRefLex{\n\t\t\t\t\t\t\tstashRef: stashRef{\n\t\t\t\t\t\t\t\tn:   name,\n\t\t\t\t\t\t\t\tv:   &s.values,\n\t\t\t\t\t\t\t\tidx: int(idx &^ maskTyp),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstrictConst: strict || (idx&maskStrict != 0),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn &stashRef{\n\t\t\t\t\tn:   name,\n\t\t\t\t\tv:   &s.values,\n\t\t\t\t\tidx: int(idx &^ maskTyp),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *stash) createBinding(name unistring.String, deletable bool) {\n\tif s.names == nil {\n\t\ts.names = make(map[unistring.String]uint32)\n\t}\n\tif _, exists := s.names[name]; !exists {\n\t\tidx := uint32(len(s.names)) | maskVar\n\t\tif deletable {\n\t\t\tidx |= maskDeletable\n\t\t}\n\t\ts.names[name] = idx\n\t\ts.values = append(s.values, _undefined)\n\t}\n}\n\nfunc (s *stash) createLexBinding(name unistring.String, isConst bool) {\n\tif s.names == nil {\n\t\ts.names = make(map[unistring.String]uint32)\n\t}\n\tif _, exists := s.names[name]; !exists {\n\t\tidx := uint32(len(s.names))\n\t\tif isConst {\n\t\t\tidx |= maskConst | maskStrict\n\t\t}\n\t\ts.names[name] = idx\n\t\ts.values = append(s.values, nil)\n\t}\n}\n\nfunc (s *stash) deleteBinding(name unistring.String) {\n\tdelete(s.names, name)\n}\n\nfunc (vm *vm) newStash() {\n\tvm.stash = &stash{\n\t\touter: vm.stash,\n\t}\n\tvm.stashAllocs++\n}\n\nfunc (vm *vm) init() {\n\tvm.sb = -1\n\tvm.stash = &vm.r.global.stash\n\tvm.maxCallStackSize = math.MaxInt32\n}\n\nfunc (vm *vm) halted() bool {\n\tpc := vm.pc\n\treturn pc < 0 || pc >= len(vm.prg.code)\n}\n\nfunc (vm *vm) run() {\n\tif vm.profTracker != nil && !vm.runWithProfiler() {\n\t\treturn\n\t}\n\tcount := 0\n\tinterrupted := false\n\tfor {\n\t\tif count == 0 {\n\t\t\tif atomic.LoadInt32(&globalProfiler.enabled) == 1 && !vm.runWithProfiler() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcount = 100\n\t\t} else {\n\t\t\tcount--\n\t\t}\n\t\tif interrupted = atomic.LoadUint32(&vm.interrupted) != 0; interrupted {\n\t\t\tbreak\n\t\t}\n\t\tpc := vm.pc\n\t\tif pc < 0 || pc >= len(vm.prg.code) {\n\t\t\tbreak\n\t\t}\n\t\tvm.prg.code[pc].exec(vm)\n\t}\n\n\tif interrupted {\n\t\tvm.interruptLock.Lock()\n\t\tv := &InterruptedError{\n\t\t\tiface: vm.interruptVal,\n\t\t}\n\t\tv.stack = vm.captureStack(nil, 0)\n\t\tvm.interruptLock.Unlock()\n\t\tpanic(v)\n\t}\n}\n\nfunc (vm *vm) runWithProfiler() bool {\n\tpt := vm.profTracker\n\tif pt == nil {\n\t\tpt = globalProfiler.p.registerVm()\n\t\tvm.profTracker = pt\n\t\tdefer func() {\n\t\t\tatomic.StoreInt32(&vm.profTracker.finished, 1)\n\t\t\tvm.profTracker = nil\n\t\t}()\n\t}\n\tinterrupted := false\n\tfor {\n\t\tif interrupted = atomic.LoadUint32(&vm.interrupted) != 0; interrupted {\n\t\t\treturn true\n\t\t}\n\t\tpc := vm.pc\n\t\tif pc < 0 || pc >= len(vm.prg.code) {\n\t\t\tbreak\n\t\t}\n\t\tvm.prg.code[pc].exec(vm)\n\t\treq := atomic.LoadInt32(&pt.req)\n\t\tif req == profReqStop {\n\t\t\treturn true\n\t\t}\n\t\tif req == profReqDoSample {\n\t\t\tpt.stop = time.Now()\n\n\t\t\tpt.numFrames = len(vm.r.CaptureCallStack(len(pt.frames), pt.frames[:0]))\n\t\t\tpt.frames[0].pc = pc\n\t\t\tatomic.StoreInt32(&pt.req, profReqSampleReady)\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (vm *vm) Interrupt(v interface{}) {\n\tvm.interruptLock.Lock()\n\tvm.interruptVal = v\n\tatomic.StoreUint32(&vm.interrupted, 1)\n\tvm.interruptLock.Unlock()\n}\n\nfunc (vm *vm) ClearInterrupt() {\n\tatomic.StoreUint32(&vm.interrupted, 0)\n}\n\nfunc getFuncName(stack []Value, sb int) unistring.String {\n\tif sb > 0 {\n\t\tif f, ok := stack[sb-1].(*Object); ok {\n\t\t\tif _, isProxy := f.self.(*proxyObject); isProxy {\n\t\t\t\treturn \"proxy\"\n\t\t\t}\n\t\t\treturn nilSafe(f.self.getStr(\"name\", nil)).string()\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (vm *vm) captureStack(stack []StackFrame, ctxOffset int) []StackFrame {\n\t// Unroll the context stack\n\tif vm.prg != nil || vm.sb > 0 {\n\t\tvar funcName unistring.String\n\t\tif vm.prg != nil {\n\t\t\tfuncName = vm.prg.funcName\n\t\t} else {\n\t\t\tfuncName = getFuncName(vm.stack, vm.sb)\n\t\t}\n\t\tstack = append(stack, StackFrame{prg: vm.prg, pc: vm.pc, funcName: funcName})\n\t}\n\tfor i := len(vm.callStack) - 1; i > ctxOffset-1; i-- {\n\t\tframe := &vm.callStack[i]\n\t\tif frame.prg != nil || frame.sb > 0 {\n\t\t\tvar funcName unistring.String\n\t\t\tif prg := frame.prg; prg != nil {\n\t\t\t\tfuncName = prg.funcName\n\t\t\t} else {\n\t\t\t\tfuncName = getFuncName(vm.stack, frame.sb)\n\t\t\t}\n\t\t\tstack = append(stack, StackFrame{prg: vm.callStack[i].prg, pc: frame.pc, funcName: funcName})\n\t\t}\n\t}\n\tif ctxOffset == 0 && vm.curAsyncRunner != nil {\n\t\tstack = vm.captureAsyncStack(stack, vm.curAsyncRunner)\n\t}\n\treturn stack\n}\n\nfunc (vm *vm) captureAsyncStack(stack []StackFrame, runner *asyncRunner) []StackFrame {\n\tif promise, _ := runner.promiseCap.promise.self.(*Promise); promise != nil {\n\t\tif len(promise.fulfillReactions) == 1 {\n\t\t\tif r := promise.fulfillReactions[0].asyncRunner; r != nil {\n\t\t\t\tctx := &r.gen.ctx\n\t\t\t\tif ctx.prg != nil || ctx.sb > 0 {\n\t\t\t\t\tvar funcName unistring.String\n\t\t\t\t\tif prg := ctx.prg; prg != nil {\n\t\t\t\t\t\tfuncName = prg.funcName\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfuncName = getFuncName(ctx.stack, 1)\n\t\t\t\t\t}\n\t\t\t\t\tstack = append(stack, StackFrame{prg: ctx.prg, pc: ctx.pc, funcName: funcName})\n\t\t\t\t}\n\t\t\t\tstack = vm.captureAsyncStack(stack, r)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stack\n}\n\nfunc (vm *vm) pushTryFrame(catchPos, finallyPos int32) {\n\tvm.tryStack = append(vm.tryStack, tryFrame{\n\t\tcallStackLen: uint32(len(vm.callStack)),\n\t\titerLen:      uint32(len(vm.iterStack)),\n\t\trefLen:       uint32(len(vm.refStack)),\n\t\tsp:           int32(vm.sp),\n\t\tstash:        vm.stash,\n\t\tprivEnv:      vm.privEnv,\n\t\tcatchPos:     catchPos,\n\t\tfinallyPos:   finallyPos,\n\t\tfinallyRet:   -1,\n\t})\n}\n\nfunc (vm *vm) popTryFrame() {\n\tvm.tryStack = vm.tryStack[:len(vm.tryStack)-1]\n}\n\nfunc (vm *vm) restoreStacks(iterLen, refLen uint32) (ex *Exception) {\n\t// Restore other stacks\n\titerTail := vm.iterStack[iterLen:]\n\tfor i := len(iterTail) - 1; i >= 0; i-- {\n\t\tif iter := iterTail[i].iter; iter != nil {\n\t\t\tex1 := vm.try(func() {\n\t\t\t\titer.returnIter()\n\t\t\t})\n\t\t\tif ex1 != nil && ex == nil {\n\t\t\t\tex = ex1\n\t\t\t}\n\t\t}\n\t\titerTail[i] = iterStackItem{}\n\t}\n\tvm.iterStack = vm.iterStack[:iterLen]\n\trefTail := vm.refStack[refLen:]\n\tfor i := range refTail {\n\t\trefTail[i] = nil\n\t}\n\tvm.refStack = vm.refStack[:refLen]\n\treturn\n}\n\nfunc (vm *vm) handleThrow(arg interface{}) *Exception {\n\tex := vm.exceptionFromValue(arg)\n\tfor len(vm.tryStack) > 0 {\n\t\ttf := &vm.tryStack[len(vm.tryStack)-1]\n\t\tif tf.catchPos == -1 && tf.finallyPos == -1 || ex == nil && tf.catchPos != tryPanicMarker {\n\t\t\ttf.exception = nil\n\t\t\tvm.popTryFrame()\n\t\t\tcontinue\n\t\t}\n\t\tif int(tf.callStackLen) < len(vm.callStack) {\n\t\t\tctx := &vm.callStack[tf.callStackLen]\n\t\t\tvm.prg, vm.newTarget, vm.result, vm.pc, vm.sb, vm.args =\n\t\t\t\tctx.prg, ctx.newTarget, ctx.result, ctx.pc, ctx.sb, ctx.args\n\t\t\tvm.callStack = vm.callStack[:tf.callStackLen]\n\t\t}\n\t\tvm.sp = int(tf.sp)\n\t\tvm.stash = tf.stash\n\t\tvm.privEnv = tf.privEnv\n\t\t_ = vm.restoreStacks(tf.iterLen, tf.refLen)\n\n\t\tif tf.catchPos == tryPanicMarker {\n\t\t\tbreak\n\t\t}\n\n\t\tif tf.catchPos >= 0 {\n\t\t\t// exception is caught\n\t\t\tvm.push(ex.val)\n\t\t\tvm.pc = int(tf.catchPos)\n\t\t\ttf.catchPos = -1\n\t\t\treturn nil\n\t\t}\n\t\tif tf.finallyPos >= 0 {\n\t\t\t// no 'catch' block, but there is a 'finally' block\n\t\t\ttf.exception = ex\n\t\t\tvm.pc = int(tf.finallyPos)\n\t\t\ttf.finallyPos = -1\n\t\t\ttf.finallyRet = -1\n\t\t\treturn nil\n\t\t}\n\t}\n\tif ex == nil {\n\t\tpanic(arg)\n\t}\n\treturn ex\n}\n\n// Calls to this method must be made from the run() loop and must be the last statement before 'return'.\n// In all other cases exceptions must be thrown using panic().\nfunc (vm *vm) throw(v interface{}) {\n\tif ex := vm.handleThrow(v); ex != nil {\n\t\tpanic(ex)\n\t}\n}\n\nfunc (vm *vm) try(f func()) (ex *Exception) {\n\tvm.pushTryFrame(tryPanicMarker, -1)\n\tdefer vm.popTryFrame()\n\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tex = vm.handleThrow(x)\n\t\t}\n\t}()\n\n\tf()\n\treturn\n}\n\nfunc (vm *vm) runTry() (ex *Exception) {\n\tvm.pushTryFrame(tryPanicMarker, -1)\n\tdefer vm.popTryFrame()\n\n\tfor {\n\t\tex = vm.runTryInner()\n\t\tif ex != nil || vm.halted() {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (vm *vm) runTryInner() (ex *Exception) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tex = vm.handleThrow(x)\n\t\t}\n\t}()\n\n\tvm.run()\n\treturn\n}\n\nfunc (vm *vm) push(v Value) {\n\tvm.stack.expand(vm.sp)\n\tvm.stack[vm.sp] = v\n\tvm.sp++\n}\n\nfunc (vm *vm) pop() Value {\n\tvm.sp--\n\treturn vm.stack[vm.sp]\n}\n\nfunc (vm *vm) peek() Value {\n\treturn vm.stack[vm.sp-1]\n}\n\nfunc (vm *vm) saveCtx(ctx *context) {\n\tctx.prg, ctx.stash, ctx.privEnv, ctx.newTarget, ctx.result, ctx.pc, ctx.sb, ctx.args =\n\t\tvm.prg, vm.stash, vm.privEnv, vm.newTarget, vm.result, vm.pc, vm.sb, vm.args\n}\n\nfunc (vm *vm) pushCtx() {\n\tif len(vm.callStack) > vm.maxCallStackSize {\n\t\tex := &StackOverflowError{}\n\t\tex.stack = vm.captureStack(nil, 0)\n\t\tpanic(ex)\n\t}\n\tvm.callStack = append(vm.callStack, context{})\n\tctx := &vm.callStack[len(vm.callStack)-1]\n\tvm.saveCtx(ctx)\n}\n\nfunc (vm *vm) restoreCtx(ctx *context) {\n\tvm.prg, vm.stash, vm.privEnv, vm.newTarget, vm.result, vm.pc, vm.sb, vm.args =\n\t\tctx.prg, ctx.stash, ctx.privEnv, ctx.newTarget, ctx.result, ctx.pc, ctx.sb, ctx.args\n}\n\nfunc (vm *vm) popCtx() {\n\tl := len(vm.callStack) - 1\n\tctx := &vm.callStack[l]\n\tvm.restoreCtx(ctx)\n\n\tif ctx.prg != nil {\n\t\t*ctx = context{}\n\t}\n\n\tvm.callStack = vm.callStack[:l]\n}\n\nfunc (vm *vm) toCallee(v Value) *Object {\n\tif obj, ok := v.(*Object); ok {\n\t\treturn obj\n\t}\n\tswitch unresolved := v.(type) {\n\tcase valueUnresolved:\n\t\tunresolved.throw()\n\t\tpanic(\"Unreachable\")\n\tcase memberUnresolved:\n\t\tpanic(vm.r.NewTypeError(\"Object has no member '%s'\", unresolved.ref))\n\t}\n\tpanic(vm.r.NewTypeError(\"Value is not an object: %s\", v.toString()))\n}\n\ntype loadVal struct {\n\tv Value\n}\n\nfunc (l loadVal) exec(vm *vm) {\n\tvm.push(l.v)\n\tvm.pc++\n}\n\ntype _loadUndef struct{}\n\nvar loadUndef _loadUndef\n\nfunc (_loadUndef) exec(vm *vm) {\n\tvm.push(_undefined)\n\tvm.pc++\n}\n\ntype _loadNil struct{}\n\nvar loadNil _loadNil\n\nfunc (_loadNil) exec(vm *vm) {\n\tvm.push(nil)\n\tvm.pc++\n}\n\ntype _saveResult struct{}\n\nvar saveResult _saveResult\n\nfunc (_saveResult) exec(vm *vm) {\n\tvm.sp--\n\tvm.result = vm.stack[vm.sp]\n\tvm.pc++\n}\n\ntype _loadResult struct{}\n\nvar loadResult _loadResult\n\nfunc (_loadResult) exec(vm *vm) {\n\tvm.push(vm.result)\n\tvm.pc++\n}\n\ntype _clearResult struct{}\n\nvar clearResult _clearResult\n\nfunc (_clearResult) exec(vm *vm) {\n\tvm.result = _undefined\n\tvm.pc++\n}\n\ntype _loadGlobalObject struct{}\n\nvar loadGlobalObject _loadGlobalObject\n\nfunc (_loadGlobalObject) exec(vm *vm) {\n\tvm.push(vm.r.globalObject)\n\tvm.pc++\n}\n\ntype loadStack int\n\nfunc (l loadStack) exec(vm *vm) {\n\t// l > 0 -- var<l-1>\n\t// l == 0 -- this\n\n\tif l > 0 {\n\t\tvm.push(nilSafe(vm.stack[vm.sb+vm.args+int(l)]))\n\t} else {\n\t\tvm.push(vm.stack[vm.sb])\n\t}\n\tvm.pc++\n}\n\ntype loadStack1 int\n\nfunc (l loadStack1) exec(vm *vm) {\n\t// args are in stash\n\t// l > 0 -- var<l-1>\n\t// l == 0 -- this\n\n\tif l > 0 {\n\t\tvm.push(nilSafe(vm.stack[vm.sb+int(l)]))\n\t} else {\n\t\tvm.push(vm.stack[vm.sb])\n\t}\n\tvm.pc++\n}\n\ntype loadStackLex int\n\nfunc (l loadStackLex) exec(vm *vm) {\n\t// l < 0 -- arg<-l-1>\n\t// l > 0 -- var<l-1>\n\t// l == 0 -- this\n\tvar p *Value\n\tif l <= 0 {\n\t\targ := int(-l)\n\t\tif arg > vm.args {\n\t\t\tvm.push(_undefined)\n\t\t\tvm.pc++\n\t\t\treturn\n\t\t} else {\n\t\t\tp = &vm.stack[vm.sb+arg]\n\t\t}\n\t} else {\n\t\tp = &vm.stack[vm.sb+vm.args+int(l)]\n\t}\n\tif *p == nil {\n\t\tvm.throw(errAccessBeforeInit)\n\t\treturn\n\t}\n\tvm.push(*p)\n\tvm.pc++\n}\n\ntype loadStack1Lex int\n\nfunc (l loadStack1Lex) exec(vm *vm) {\n\tp := &vm.stack[vm.sb+int(l)]\n\tif *p == nil {\n\t\tvm.throw(errAccessBeforeInit)\n\t\treturn\n\t}\n\tvm.push(*p)\n\tvm.pc++\n}\n\ntype _loadCallee struct{}\n\nvar loadCallee _loadCallee\n\nfunc (_loadCallee) exec(vm *vm) {\n\tvm.push(vm.stack[vm.sb-1])\n\tvm.pc++\n}\n\nfunc (vm *vm) storeStack(s int) {\n\t// l > 0 -- var<l-1>\n\n\tif s > 0 {\n\t\tvm.stack[vm.sb+vm.args+s] = vm.stack[vm.sp-1]\n\t} else {\n\t\tpanic(\"Illegal stack var index\")\n\t}\n\tvm.pc++\n}\n\nfunc (vm *vm) storeStack1(s int) {\n\t// args are in stash\n\t// l > 0 -- var<l-1>\n\n\tif s > 0 {\n\t\tvm.stack[vm.sb+s] = vm.stack[vm.sp-1]\n\t} else {\n\t\tpanic(\"Illegal stack var index\")\n\t}\n\tvm.pc++\n}\n\nfunc (vm *vm) storeStackLex(s int) {\n\t// l < 0 -- arg<-l-1>\n\t// l > 0 -- var<l-1>\n\tvar p *Value\n\tif s < 0 {\n\t\tp = &vm.stack[vm.sb-s]\n\t} else {\n\t\tp = &vm.stack[vm.sb+vm.args+s]\n\t}\n\n\tif *p != nil {\n\t\t*p = vm.stack[vm.sp-1]\n\t} else {\n\t\tpanic(errAccessBeforeInit)\n\t}\n\tvm.pc++\n}\n\nfunc (vm *vm) storeStack1Lex(s int) {\n\t// args are in stash\n\t// s > 0 -- var<l-1>\n\tif s <= 0 {\n\t\tpanic(\"Illegal stack var index\")\n\t}\n\tp := &vm.stack[vm.sb+s]\n\tif *p != nil {\n\t\t*p = vm.stack[vm.sp-1]\n\t} else {\n\t\tpanic(errAccessBeforeInit)\n\t}\n\tvm.pc++\n}\n\nfunc (vm *vm) initStack(s int) {\n\tif s <= 0 {\n\t\tvm.stack[vm.sb-s] = vm.stack[vm.sp-1]\n\t} else {\n\t\tvm.stack[vm.sb+vm.args+s] = vm.stack[vm.sp-1]\n\t}\n\tvm.pc++\n}\n\nfunc (vm *vm) initStack1(s int) {\n\tif s <= 0 {\n\t\tpanic(\"Illegal stack var index\")\n\t}\n\tvm.stack[vm.sb+s] = vm.stack[vm.sp-1]\n\tvm.pc++\n}\n\ntype storeStack int\n\nfunc (s storeStack) exec(vm *vm) {\n\tvm.storeStack(int(s))\n}\n\ntype storeStack1 int\n\nfunc (s storeStack1) exec(vm *vm) {\n\tvm.storeStack1(int(s))\n}\n\ntype storeStackLex int\n\nfunc (s storeStackLex) exec(vm *vm) {\n\tvm.storeStackLex(int(s))\n}\n\ntype storeStack1Lex int\n\nfunc (s storeStack1Lex) exec(vm *vm) {\n\tvm.storeStack1Lex(int(s))\n}\n\ntype initStack int\n\nfunc (s initStack) exec(vm *vm) {\n\tvm.initStack(int(s))\n}\n\ntype initStackP int\n\nfunc (s initStackP) exec(vm *vm) {\n\tvm.initStack(int(s))\n\tvm.sp--\n}\n\ntype initStack1 int\n\nfunc (s initStack1) exec(vm *vm) {\n\tvm.initStack1(int(s))\n}\n\ntype initStack1P int\n\nfunc (s initStack1P) exec(vm *vm) {\n\tvm.initStack1(int(s))\n\tvm.sp--\n}\n\ntype storeStackP int\n\nfunc (s storeStackP) exec(vm *vm) {\n\tvm.storeStack(int(s))\n\tvm.sp--\n}\n\ntype storeStack1P int\n\nfunc (s storeStack1P) exec(vm *vm) {\n\tvm.storeStack1(int(s))\n\tvm.sp--\n}\n\ntype storeStackLexP int\n\nfunc (s storeStackLexP) exec(vm *vm) {\n\tvm.storeStackLex(int(s))\n\tvm.sp--\n}\n\ntype storeStack1LexP int\n\nfunc (s storeStack1LexP) exec(vm *vm) {\n\tvm.storeStack1Lex(int(s))\n\tvm.sp--\n}\n\ntype _toNumber struct{}\n\nvar toNumber _toNumber\n\nfunc (_toNumber) exec(vm *vm) {\n\tvm.stack[vm.sp-1] = toNumeric(vm.stack[vm.sp-1])\n\tvm.pc++\n}\n\ntype _add struct{}\n\nvar add _add\n\nfunc (_add) exec(vm *vm) {\n\tright := vm.stack[vm.sp-1]\n\tleft := vm.stack[vm.sp-2]\n\n\tif o, ok := left.(*Object); ok {\n\t\tleft = o.toPrimitive()\n\t}\n\n\tif o, ok := right.(*Object); ok {\n\t\tright = o.toPrimitive()\n\t}\n\n\tvar ret Value\n\n\tleftString, isLeftString := left.(String)\n\trightString, isRightString := right.(String)\n\n\tif isLeftString || isRightString {\n\t\tif !isLeftString {\n\t\t\tleftString = left.toString()\n\t\t}\n\t\tif !isRightString {\n\t\t\trightString = right.toString()\n\t\t}\n\t\tret = leftString.Concat(rightString)\n\t} else {\n\t\tswitch left := left.(type) {\n\t\tcase valueInt:\n\t\t\tswitch right := right.(type) {\n\t\t\tcase valueInt:\n\t\t\t\tret = intToValue(int64(left) + int64(right))\n\t\t\tcase *valueBigInt:\n\t\t\t\tpanic(errMixBigIntType)\n\t\t\tdefault:\n\t\t\t\tret = floatToValue(float64(left) + right.ToFloat())\n\t\t\t}\n\t\tcase *valueBigInt:\n\t\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\t\tret = (*valueBigInt)(new(big.Int).Add((*big.Int)(left), (*big.Int)(right)))\n\t\t\t} else {\n\t\t\t\tpanic(errMixBigIntType)\n\t\t\t}\n\t\tdefault:\n\t\t\tif _, ok := right.(*valueBigInt); ok {\n\t\t\t\tpanic(errMixBigIntType)\n\t\t\t}\n\t\t\tret = floatToValue(left.ToFloat() + right.ToFloat())\n\t\t}\n\t}\n\n\tvm.stack[vm.sp-2] = ret\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _sub struct{}\n\nvar sub _sub\n\nfunc (_sub) exec(vm *vm) {\n\tright := vm.stack[vm.sp-1]\n\tleft := vm.stack[vm.sp-2]\n\n\tleft = toNumeric(left)\n\tright = toNumeric(right)\n\n\tvar result Value\n\n\tswitch left := left.(type) {\n\tcase valueInt:\n\t\tswitch right := right.(type) {\n\t\tcase valueInt:\n\t\t\tresult = intToValue(int64(left) - int64(right))\n\t\t\tgoto end\n\t\tcase *valueBigInt:\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase valueFloat:\n\t\tif _, ok := right.(*valueBigInt); ok {\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase *valueBigInt:\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tresult = (*valueBigInt)(new(big.Int).Sub((*big.Int)(left), (*big.Int)(right)))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = floatToValue(left.ToFloat() - right.ToFloat())\nend:\n\tvm.sp--\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _mul struct{}\n\nvar mul _mul\n\nfunc (_mul) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\n\tvar result Value\n\n\tswitch left := left.(type) {\n\tcase valueInt:\n\t\tswitch right := right.(type) {\n\t\tcase valueInt:\n\t\t\tif left == 0 && right == -1 || left == -1 && right == 0 {\n\t\t\t\tresult = _negativeZero\n\t\t\t\tgoto end\n\t\t\t}\n\t\t\tres := left * right\n\t\t\t// check for overflow\n\t\t\tif left == 0 || right == 0 || res/left == right {\n\t\t\t\tresult = intToValue(int64(res))\n\t\t\t\tgoto end\n\t\t\t}\n\t\tcase *valueBigInt:\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase valueFloat:\n\t\tif _, ok := right.(*valueBigInt); ok {\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase *valueBigInt:\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tresult = (*valueBigInt)(new(big.Int).Mul((*big.Int)(left), (*big.Int)(right)))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = floatToValue(left.ToFloat() * right.ToFloat())\n\nend:\n\tvm.sp--\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _exp struct{}\n\nvar exp _exp\n\nfunc (_exp) exec(vm *vm) {\n\tvm.sp--\n\tx := vm.stack[vm.sp-1]\n\ty := vm.stack[vm.sp]\n\n\tx = toNumeric(x)\n\ty = toNumeric(y)\n\n\tvar result Value\n\tif x, ok := x.(*valueBigInt); ok {\n\t\tif y, ok := y.(*valueBigInt); ok {\n\t\t\tif (*big.Int)(y).Cmp(big.NewInt(0)) < 0 {\n\t\t\t\tpanic(vm.r.newError(vm.r.getRangeError(), \"exponent must be positive\"))\n\t\t\t}\n\t\t\tresult = (*valueBigInt)(new(big.Int).Exp((*big.Int)(x), (*big.Int)(y), nil))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := y.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = pow(x, y)\nend:\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _div struct{}\n\nvar div _div\n\nfunc (_div) exec(vm *vm) {\n\tleftValue := toNumeric(vm.stack[vm.sp-2])\n\trightValue := toNumeric(vm.stack[vm.sp-1])\n\n\tvar (\n\t\tresult      Value\n\t\tleft, right float64\n\t)\n\n\tif left, ok := leftValue.(*valueBigInt); ok {\n\t\tif right, ok := rightValue.(*valueBigInt); ok {\n\t\t\tif (*big.Int)(right).Cmp(big.NewInt(0)) == 0 {\n\t\t\t\tpanic(vm.r.newError(vm.r.getRangeError(), \"Division by zero\"))\n\t\t\t}\n\t\t\tif (*big.Int)(left).CmpAbs((*big.Int)(right)) < 0 {\n\t\t\t\tresult = (*valueBigInt)(big.NewInt(0))\n\t\t\t} else {\n\t\t\t\ti, _ := new(big.Int).QuoRem((*big.Int)(left), (*big.Int)(right), big.NewInt(0))\n\t\t\t\tresult = (*valueBigInt)(i)\n\t\t\t}\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := rightValue.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\tleft, right = leftValue.ToFloat(), rightValue.ToFloat()\n\n\tif math.IsNaN(left) || math.IsNaN(right) {\n\t\tresult = _NaN\n\t\tgoto end\n\t}\n\tif math.IsInf(left, 0) && math.IsInf(right, 0) {\n\t\tresult = _NaN\n\t\tgoto end\n\t}\n\tif left == 0 && right == 0 {\n\t\tresult = _NaN\n\t\tgoto end\n\t}\n\n\tif math.IsInf(left, 0) {\n\t\tif math.Signbit(left) == math.Signbit(right) {\n\t\t\tresult = _positiveInf\n\t\t\tgoto end\n\t\t} else {\n\t\t\tresult = _negativeInf\n\t\t\tgoto end\n\t\t}\n\t}\n\tif math.IsInf(right, 0) {\n\t\tif math.Signbit(left) == math.Signbit(right) {\n\t\t\tresult = _positiveZero\n\t\t\tgoto end\n\t\t} else {\n\t\t\tresult = _negativeZero\n\t\t\tgoto end\n\t\t}\n\t}\n\tif right == 0 {\n\t\tif math.Signbit(left) == math.Signbit(right) {\n\t\t\tresult = _positiveInf\n\t\t\tgoto end\n\t\t} else {\n\t\t\tresult = _negativeInf\n\t\t\tgoto end\n\t\t}\n\t}\n\n\tresult = floatToValue(left / right)\n\nend:\n\tvm.sp--\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _mod struct{}\n\nvar mod _mod\n\nfunc (_mod) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\n\tvar result Value\n\n\tswitch left := left.(type) {\n\tcase valueInt:\n\t\tswitch right := right.(type) {\n\t\tcase valueInt:\n\t\t\tif right == 0 {\n\t\t\t\tresult = _NaN\n\t\t\t\tgoto end\n\t\t\t}\n\t\t\tr := left % right\n\t\t\tif r == 0 && left < 0 {\n\t\t\t\tresult = _negativeZero\n\t\t\t} else {\n\t\t\t\tresult = intToValue(int64(left % right))\n\t\t\t}\n\t\t\tgoto end\n\t\tcase *valueBigInt:\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase valueFloat:\n\t\tif _, ok := right.(*valueBigInt); ok {\n\t\t\tpanic(errMixBigIntType)\n\t\t}\n\tcase *valueBigInt:\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tswitch {\n\t\t\tcase (*big.Int)(right).Cmp(big.NewInt(0)) == 0:\n\t\t\t\tpanic(vm.r.newError(vm.r.getRangeError(), \"Division by zero\"))\n\t\t\tcase (*big.Int)(left).Cmp(big.NewInt(0)) < 0:\n\t\t\t\tabs := new(big.Int).Abs((*big.Int)(left))\n\t\t\t\tv := new(big.Int).Mod(abs, (*big.Int)(right))\n\t\t\t\tresult = (*valueBigInt)(v.Neg(v))\n\t\t\tdefault:\n\t\t\t\tresult = (*valueBigInt)(new(big.Int).Mod((*big.Int)(left), (*big.Int)(right)))\n\t\t\t}\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = floatToValue(math.Mod(left.ToFloat(), right.ToFloat()))\nend:\n\tvm.sp--\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _neg struct{}\n\nvar neg _neg\n\nfunc (_neg) exec(vm *vm) {\n\toperand := vm.stack[vm.sp-1]\n\n\tvar result Value\n\n\tswitch n := toNumeric(operand).(type) {\n\tcase *valueBigInt:\n\t\tresult = (*valueBigInt)(new(big.Int).Neg((*big.Int)(n)))\n\tcase valueInt:\n\t\tif n == 0 {\n\t\t\tresult = _negativeZero\n\t\t} else {\n\t\t\tresult = -n\n\t\t}\n\tdefault:\n\t\tf := operand.ToFloat()\n\t\tif !math.IsNaN(f) {\n\t\t\tf = -f\n\t\t}\n\t\tresult = valueFloat(f)\n\t}\n\n\tvm.stack[vm.sp-1] = result\n\tvm.pc++\n}\n\ntype _plus struct{}\n\nvar plus _plus\n\nfunc (_plus) exec(vm *vm) {\n\tvm.stack[vm.sp-1] = vm.stack[vm.sp-1].ToNumber()\n\tvm.pc++\n}\n\ntype _inc struct{}\n\nvar inc _inc\n\nfunc (_inc) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\n\tswitch n := v.(type) {\n\tcase *valueBigInt:\n\t\tv = (*valueBigInt)(new(big.Int).Add((*big.Int)(n), big.NewInt(1)))\n\tcase valueInt:\n\t\tv = intToValue(int64(n + 1))\n\tdefault:\n\t\tv = valueFloat(n.ToFloat() + 1)\n\t}\n\n\tvm.stack[vm.sp-1] = v\n\tvm.pc++\n}\n\ntype _dec struct{}\n\nvar dec _dec\n\nfunc (_dec) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\n\tswitch n := v.(type) {\n\tcase *valueBigInt:\n\t\tv = (*valueBigInt)(new(big.Int).Sub((*big.Int)(n), big.NewInt(1)))\n\tcase valueInt:\n\t\tv = intToValue(int64(n - 1))\n\tdefault:\n\t\tv = valueFloat(n.ToFloat() - 1)\n\t}\n\n\tvm.stack[vm.sp-1] = v\n\tvm.pc++\n}\n\ntype _and struct{}\n\nvar and _and\n\nfunc (_and) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\tvar result Value\n\n\tif left, ok := left.(*valueBigInt); ok {\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tresult = (*valueBigInt)(new(big.Int).And((*big.Int)(left), (*big.Int)(right)))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = intToValue(int64(toInt32(left) & toInt32(right)))\nend:\n\tvm.stack[vm.sp-2] = result\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _or struct{}\n\nvar or _or\n\nfunc (_or) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\tvar result Value\n\n\tif left, ok := left.(*valueBigInt); ok {\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tresult = (*valueBigInt)(new(big.Int).Or((*big.Int)(left), (*big.Int)(right)))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = intToValue(int64(toInt32(left) | toInt32(right)))\nend:\n\tvm.stack[vm.sp-2] = result\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _xor struct{}\n\nvar xor _xor\n\nfunc (_xor) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\tvar result Value\n\n\tif left, ok := left.(*valueBigInt); ok {\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tresult = (*valueBigInt)(new(big.Int).Xor((*big.Int)(left), (*big.Int)(right)))\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = intToValue(int64(toInt32(left) ^ toInt32(right)))\nend:\n\tvm.stack[vm.sp-2] = result\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _bnot struct{}\n\nvar bnot _bnot\n\nfunc (_bnot) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tswitch n := toNumeric(v).(type) {\n\tcase *valueBigInt:\n\t\tv = (*valueBigInt)(new(big.Int).Not((*big.Int)(n)))\n\tdefault:\n\t\tv = intToValue(int64(^toInt32(n)))\n\t}\n\tvm.stack[vm.sp-1] = v\n\tvm.pc++\n}\n\ntype _sal struct{}\n\nvar sal _sal\n\nfunc (_sal) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\tvar result Value\n\n\tif left, ok := left.(*valueBigInt); ok {\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tn := uint((*big.Int)(right).Uint64())\n\t\t\tif (*big.Int)(right).Sign() < 0 {\n\t\t\t\tresult = (*valueBigInt)(new(big.Int).Rsh((*big.Int)(left), n))\n\t\t\t} else {\n\t\t\t\tresult = (*valueBigInt)(new(big.Int).Lsh((*big.Int)(left), n))\n\t\t\t}\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = intToValue(int64(toInt32(left) << (toUint32(right) & 0x1F)))\nend:\n\tvm.stack[vm.sp-2] = result\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _sar struct{}\n\nvar sar _sar\n\nfunc (_sar) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\tvar result Value\n\n\tif left, ok := left.(*valueBigInt); ok {\n\t\tif right, ok := right.(*valueBigInt); ok {\n\t\t\tn := uint((*big.Int)(right).Uint64())\n\t\t\tif (*big.Int)(right).Sign() < 0 {\n\t\t\t\tresult = (*valueBigInt)(new(big.Int).Lsh((*big.Int)(left), n))\n\t\t\t} else {\n\t\t\t\tresult = (*valueBigInt)(new(big.Int).Rsh((*big.Int)(left), n))\n\t\t\t}\n\t\t\tgoto end\n\t\t}\n\t\tpanic(errMixBigIntType)\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(errMixBigIntType)\n\t}\n\n\tresult = intToValue(int64(toInt32(left) >> (toUint32(right) & 0x1F)))\nend:\n\tvm.stack[vm.sp-2] = result\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _shr struct{}\n\nvar shr _shr\n\nfunc (_shr) exec(vm *vm) {\n\tleft := toNumeric(vm.stack[vm.sp-2])\n\tright := toNumeric(vm.stack[vm.sp-1])\n\n\tif _, ok := left.(*valueBigInt); ok {\n\t\t_ = toNumeric(right)\n\t\tpanic(vm.r.NewTypeError(\"BigInts have no unsigned right shift, use >> instead\"))\n\t} else if _, ok := right.(*valueBigInt); ok {\n\t\tpanic(vm.r.NewTypeError(\"BigInts have no unsigned right shift, use >> instead\"))\n\t}\n\n\tvm.stack[vm.sp-2] = intToValue(int64(toUint32(left) >> (toUint32(right) & 0x1F)))\n\tvm.sp--\n\tvm.pc++\n}\n\ntype jump int32\n\nfunc (j jump) exec(vm *vm) {\n\tvm.pc += int(j)\n}\n\ntype _toPropertyKey struct{}\n\nfunc (_toPropertyKey) exec(vm *vm) {\n\tp := vm.sp - 1\n\tvm.stack[p] = toPropertyKey(vm.stack[p])\n\tvm.pc++\n}\n\ntype _toString struct{}\n\nfunc (_toString) exec(vm *vm) {\n\tp := vm.sp - 1\n\tvm.stack[p] = vm.stack[p].toString()\n\tvm.pc++\n}\n\ntype _getElemRef struct{}\n\nvar getElemRef _getElemRef\n\nfunc (_getElemRef) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-2].ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-1]\n\tvm.refStack = append(vm.refStack, &objRef{\n\t\tbase: obj,\n\t\tname: propName,\n\t})\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype _getElemRefRecv struct{}\n\nvar getElemRefRecv _getElemRefRecv\n\nfunc (_getElemRefRecv) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-1].ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-2]\n\tvm.refStack = append(vm.refStack, &objRef{\n\t\tbase: obj,\n\t\tname: propName,\n\t\tthis: vm.stack[vm.sp-3],\n\t})\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype _getElemRefStrict struct{}\n\nvar getElemRefStrict _getElemRefStrict\n\nfunc (_getElemRefStrict) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-2].ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-1]\n\tvm.refStack = append(vm.refStack, &objRef{\n\t\tbase:   obj,\n\t\tname:   propName,\n\t\tstrict: true,\n\t})\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype _getElemRefRecvStrict struct{}\n\nvar getElemRefRecvStrict _getElemRefRecvStrict\n\nfunc (_getElemRefRecvStrict) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-1].ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-2]\n\tvm.refStack = append(vm.refStack, &objRef{\n\t\tbase:   obj,\n\t\tname:   propName,\n\t\tthis:   vm.stack[vm.sp-3],\n\t\tstrict: true,\n\t})\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype _setElem struct{}\n\nvar setElem _setElem\n\nfunc (_setElem) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-3].ToObject(vm.r)\n\tpropName := toPropertyKey(vm.stack[vm.sp-2])\n\tval := vm.stack[vm.sp-1]\n\n\tobj.setOwn(propName, val, false)\n\n\tvm.sp -= 2\n\tvm.stack[vm.sp-1] = val\n\tvm.pc++\n}\n\ntype _setElem1 struct{}\n\nvar setElem1 _setElem1\n\nfunc (_setElem1) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-3].ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\n\tobj.setOwn(propName, val, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype _setElem1Named struct{}\n\nvar setElem1Named _setElem1Named\n\nfunc (_setElem1Named) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-3]\n\tbase := receiver.ToObject(vm.r)\n\tpropName := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tvm.r.toObject(val).self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        funcName(\"\", propName),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\tbase.set(propName, val, receiver, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype defineMethod struct {\n\tenumerable bool\n}\n\nfunc (d *defineMethod) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-3])\n\tpropName := vm.stack[vm.sp-2]\n\tmethod := vm.r.toObject(vm.stack[vm.sp-1])\n\tmethod.self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        funcName(\"\", propName),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\tobj.defineOwnProperty(propName, PropertyDescriptor{\n\t\tValue:        method,\n\t\tWritable:     FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   ToFlag(d.enumerable),\n\t}, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype _setElemP struct{}\n\nvar setElemP _setElemP\n\nfunc (_setElemP) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-3].ToObject(vm.r)\n\tpropName := toPropertyKey(vm.stack[vm.sp-2])\n\tval := vm.stack[vm.sp-1]\n\n\tobj.setOwn(propName, val, false)\n\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype _setElemStrict struct{}\n\nvar setElemStrict _setElemStrict\n\nfunc (_setElemStrict) exec(vm *vm) {\n\tpropName := toPropertyKey(vm.stack[vm.sp-2])\n\treceiver := vm.stack[vm.sp-3]\n\tval := vm.stack[vm.sp-1]\n\tif receiverObj, ok := receiver.(*Object); ok {\n\t\treceiverObj.setOwn(propName, val, true)\n\t} else {\n\t\tbase := receiver.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 2\n\tvm.stack[vm.sp-1] = val\n\tvm.pc++\n}\n\ntype _setElemRecv struct{}\n\nvar setElemRecv _setElemRecv\n\nfunc (_setElemRecv) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-4]\n\tpropName := toPropertyKey(vm.stack[vm.sp-3])\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.set(propName, val, receiver, false)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, false)\n\t}\n\n\tvm.sp -= 3\n\tvm.stack[vm.sp-1] = val\n\tvm.pc++\n}\n\ntype _setElemRecvStrict struct{}\n\nvar setElemRecvStrict _setElemRecvStrict\n\nfunc (_setElemRecvStrict) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-4]\n\tpropName := toPropertyKey(vm.stack[vm.sp-3])\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.set(propName, val, receiver, true)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 3\n\tvm.stack[vm.sp-1] = val\n\tvm.pc++\n}\n\ntype _setElemStrictP struct{}\n\nvar setElemStrictP _setElemStrictP\n\nfunc (_setElemStrictP) exec(vm *vm) {\n\tpropName := toPropertyKey(vm.stack[vm.sp-2])\n\treceiver := vm.stack[vm.sp-3]\n\tval := vm.stack[vm.sp-1]\n\tif receiverObj, ok := receiver.(*Object); ok {\n\t\treceiverObj.setOwn(propName, val, true)\n\t} else {\n\t\tbase := receiver.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype _setElemRecvP struct{}\n\nvar setElemRecvP _setElemRecvP\n\nfunc (_setElemRecvP) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-4]\n\tpropName := toPropertyKey(vm.stack[vm.sp-3])\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.set(propName, val, receiver, false)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, false)\n\t}\n\n\tvm.sp -= 4\n\tvm.pc++\n}\n\ntype _setElemRecvStrictP struct{}\n\nvar setElemRecvStrictP _setElemRecvStrictP\n\nfunc (_setElemRecvStrictP) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-4]\n\tpropName := toPropertyKey(vm.stack[vm.sp-3])\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.set(propName, val, receiver, true)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.set(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 4\n\tvm.pc++\n}\n\ntype _deleteElem struct{}\n\nvar deleteElem _deleteElem\n\nfunc (_deleteElem) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-2].ToObject(vm.r)\n\tpropName := toPropertyKey(vm.stack[vm.sp-1])\n\tif obj.delete(propName, false) {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _deleteElemStrict struct{}\n\nvar deleteElemStrict _deleteElemStrict\n\nfunc (_deleteElemStrict) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-2].ToObject(vm.r)\n\tpropName := toPropertyKey(vm.stack[vm.sp-1])\n\tobj.delete(propName, true)\n\tvm.stack[vm.sp-2] = valueTrue\n\tvm.sp--\n\tvm.pc++\n}\n\ntype deleteProp unistring.String\n\nfunc (d deleteProp) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-1].ToObject(vm.r)\n\tif obj.self.deleteStr(unistring.String(d), false) {\n\t\tvm.stack[vm.sp-1] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-1] = valueFalse\n\t}\n\tvm.pc++\n}\n\ntype deletePropStrict unistring.String\n\nfunc (d deletePropStrict) exec(vm *vm) {\n\tobj := vm.stack[vm.sp-1].ToObject(vm.r)\n\tobj.self.deleteStr(unistring.String(d), true)\n\tvm.stack[vm.sp-1] = valueTrue\n\tvm.pc++\n}\n\ntype getPropRef unistring.String\n\nfunc (p getPropRef) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &objStrRef{\n\t\tbase: vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tname: unistring.String(p),\n\t})\n\tvm.sp--\n\tvm.pc++\n}\n\ntype getPropRefRecv unistring.String\n\nfunc (p getPropRefRecv) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &objStrRef{\n\t\tthis: vm.stack[vm.sp-2],\n\t\tbase: vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tname: unistring.String(p),\n\t})\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype getPropRefStrict unistring.String\n\nfunc (p getPropRefStrict) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &objStrRef{\n\t\tbase:   vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tname:   unistring.String(p),\n\t\tstrict: true,\n\t})\n\tvm.sp--\n\tvm.pc++\n}\n\ntype getPropRefRecvStrict unistring.String\n\nfunc (p getPropRefRecvStrict) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &objStrRef{\n\t\tthis:   vm.stack[vm.sp-2],\n\t\tbase:   vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tname:   unistring.String(p),\n\t\tstrict: true,\n\t})\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype setProp unistring.String\n\nfunc (p setProp) exec(vm *vm) {\n\tval := vm.stack[vm.sp-1]\n\tvm.stack[vm.sp-2].ToObject(vm.r).self.setOwnStr(unistring.String(p), val, false)\n\tvm.stack[vm.sp-2] = val\n\tvm.sp--\n\tvm.pc++\n}\n\ntype setPropP unistring.String\n\nfunc (p setPropP) exec(vm *vm) {\n\tval := vm.stack[vm.sp-1]\n\tvm.stack[vm.sp-2].ToObject(vm.r).self.setOwnStr(unistring.String(p), val, false)\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype setPropStrict unistring.String\n\nfunc (p setPropStrict) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif receiverObj, ok := receiver.(*Object); ok {\n\t\treceiverObj.self.setOwnStr(propName, val, true)\n\t} else {\n\t\tbase := receiver.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, true)\n\t}\n\n\tvm.stack[vm.sp-2] = val\n\tvm.sp--\n\tvm.pc++\n}\n\ntype setPropRecv unistring.String\n\nfunc (p setPropRecv) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-3]\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.setStr(propName, val, receiver, false)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, false)\n\t}\n\n\tvm.stack[vm.sp-3] = val\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype setPropRecvStrict unistring.String\n\nfunc (p setPropRecvStrict) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-3]\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.setStr(propName, val, receiver, true)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, true)\n\t}\n\n\tvm.stack[vm.sp-3] = val\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype setPropRecvP unistring.String\n\nfunc (p setPropRecvP) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-3]\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.setStr(propName, val, receiver, false)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, false)\n\t}\n\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype setPropRecvStrictP unistring.String\n\nfunc (p setPropRecvStrictP) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-3]\n\to := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif obj, ok := o.(*Object); ok {\n\t\tobj.setStr(propName, val, receiver, true)\n\t} else {\n\t\tbase := o.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 3\n\tvm.pc++\n}\n\ntype setPropStrictP unistring.String\n\nfunc (p setPropStrictP) exec(vm *vm) {\n\treceiver := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tpropName := unistring.String(p)\n\tif receiverObj, ok := receiver.(*Object); ok {\n\t\treceiverObj.self.setOwnStr(propName, val, true)\n\t} else {\n\t\tbase := receiver.ToObject(vm.r)\n\t\tbase.setStr(propName, val, receiver, true)\n\t}\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype putProp unistring.String\n\nfunc (p putProp) exec(vm *vm) {\n\tvm.r.toObject(vm.stack[vm.sp-2]).self._putProp(unistring.String(p), vm.stack[vm.sp-1], true, true, true)\n\n\tvm.sp--\n\tvm.pc++\n}\n\n// used in class declarations instead of putProp because DefineProperty must be observable by Proxy\ntype definePropKeyed unistring.String\n\nfunc (p definePropKeyed) exec(vm *vm) {\n\tvm.r.toObject(vm.stack[vm.sp-2]).self.defineOwnPropertyStr(unistring.String(p), PropertyDescriptor{\n\t\tValue:        vm.stack[vm.sp-1],\n\t\tWritable:     FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   FLAG_TRUE,\n\t}, true)\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype defineProp struct{}\n\nfunc (defineProp) exec(vm *vm) {\n\tvm.r.toObject(vm.stack[vm.sp-3]).defineOwnProperty(vm.stack[vm.sp-2], PropertyDescriptor{\n\t\tValue:        vm.stack[vm.sp-1],\n\t\tWritable:     FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   FLAG_TRUE,\n\t}, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype defineMethodKeyed struct {\n\tkey        unistring.String\n\tenumerable bool\n}\n\nfunc (d *defineMethodKeyed) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-2])\n\tmethod := vm.r.toObject(vm.stack[vm.sp-1])\n\n\tobj.self.defineOwnPropertyStr(d.key, PropertyDescriptor{\n\t\tValue:        method,\n\t\tWritable:     FLAG_TRUE,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   ToFlag(d.enumerable),\n\t}, true)\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _setProto struct{}\n\nvar setProto _setProto\n\nfunc (_setProto) exec(vm *vm) {\n\tvm.r.setObjectProto(vm.stack[vm.sp-2], vm.stack[vm.sp-1])\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype defineGetterKeyed struct {\n\tkey        unistring.String\n\tenumerable bool\n}\n\nfunc (s *defineGetterKeyed) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-2])\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\tmethod.self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        asciiString(\"get \").Concat(stringValueFromRaw(s.key)),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\tdescr := PropertyDescriptor{\n\t\tGetter:       val,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   ToFlag(s.enumerable),\n\t}\n\n\tobj.self.defineOwnPropertyStr(s.key, descr, true)\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype defineSetterKeyed struct {\n\tkey        unistring.String\n\tenumerable bool\n}\n\nfunc (s *defineSetterKeyed) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-2])\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\tmethod.self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        asciiString(\"set \").Concat(stringValueFromRaw(s.key)),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\n\tdescr := PropertyDescriptor{\n\t\tSetter:       val,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   ToFlag(s.enumerable),\n\t}\n\n\tobj.self.defineOwnPropertyStr(s.key, descr, true)\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype defineGetter struct {\n\tenumerable bool\n}\n\nfunc (s *defineGetter) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-3])\n\tpropName := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\tmethod.self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        funcName(\"get \", propName),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\n\tdescr := PropertyDescriptor{\n\t\tGetter:       val,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   ToFlag(s.enumerable),\n\t}\n\n\tobj.defineOwnProperty(propName, descr, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype defineSetter struct {\n\tenumerable bool\n}\n\nfunc (s *defineSetter) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-3])\n\tpropName := vm.stack[vm.sp-2]\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\n\tmethod.self.defineOwnPropertyStr(\"name\", PropertyDescriptor{\n\t\tValue:        funcName(\"set \", propName),\n\t\tConfigurable: FLAG_TRUE,\n\t}, true)\n\n\tdescr := PropertyDescriptor{\n\t\tSetter:       val,\n\t\tConfigurable: FLAG_TRUE,\n\t\tEnumerable:   FLAG_TRUE,\n\t}\n\n\tobj.defineOwnProperty(propName, descr, true)\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype getProp unistring.String\n\nfunc (g getProp) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", g))\n\t\treturn\n\t}\n\tvm.stack[vm.sp-1] = nilSafe(obj.self.getStr(unistring.String(g), v))\n\n\tvm.pc++\n}\n\ntype getPropRecv unistring.String\n\nfunc (g getPropRecv) exec(vm *vm) {\n\trecv := vm.stack[vm.sp-2]\n\tv := vm.stack[vm.sp-1]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", g))\n\t\treturn\n\t}\n\tvm.stack[vm.sp-2] = nilSafe(obj.self.getStr(unistring.String(g), recv))\n\tvm.sp--\n\tvm.pc++\n}\n\ntype getPropRecvCallee unistring.String\n\nfunc (g getPropRecvCallee) exec(vm *vm) {\n\trecv := vm.stack[vm.sp-2]\n\tv := vm.stack[vm.sp-1]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", g))\n\t\treturn\n\t}\n\n\tn := unistring.String(g)\n\tprop := obj.self.getStr(n, recv)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: n}}\n\t}\n\n\tvm.stack[vm.sp-1] = prop\n\tvm.pc++\n}\n\ntype getPropCallee unistring.String\n\nfunc (g getPropCallee) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tobj := v.baseObject(vm.r)\n\tn := unistring.String(g)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined or null\", n))\n\t\treturn\n\t}\n\tprop := obj.self.getStr(n, v)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: n}}\n\t}\n\tvm.push(prop)\n\n\tvm.pc++\n}\n\ntype _getElem struct{}\n\nvar getElem _getElem\n\nfunc (_getElem) exec(vm *vm) {\n\tv := vm.stack[vm.sp-2]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", vm.stack[vm.sp-1]))\n\t\treturn\n\t}\n\tpropName := toPropertyKey(vm.stack[vm.sp-1])\n\n\tvm.stack[vm.sp-2] = nilSafe(obj.get(propName, v))\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _getElemRecv struct{}\n\nvar getElemRecv _getElemRecv\n\nfunc (_getElemRecv) exec(vm *vm) {\n\trecv := vm.stack[vm.sp-3]\n\tv := vm.stack[vm.sp-1]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", vm.stack[vm.sp-2]))\n\t\treturn\n\t}\n\tpropName := toPropertyKey(vm.stack[vm.sp-2])\n\n\tvm.stack[vm.sp-3] = nilSafe(obj.get(propName, recv))\n\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype _getKey struct{}\n\nvar getKey _getKey\n\nfunc (_getKey) exec(vm *vm) {\n\tv := vm.stack[vm.sp-2]\n\tobj := v.baseObject(vm.r)\n\tpropName := vm.stack[vm.sp-1]\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", propName.String()))\n\t\treturn\n\t}\n\n\tvm.stack[vm.sp-2] = nilSafe(obj.get(propName, v))\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _getElemCallee struct{}\n\nvar getElemCallee _getElemCallee\n\nfunc (_getElemCallee) exec(vm *vm) {\n\tv := vm.stack[vm.sp-2]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", vm.stack[vm.sp-1]))\n\t\treturn\n\t}\n\n\tpropName := toPropertyKey(vm.stack[vm.sp-1])\n\tprop := obj.get(propName, v)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: propName.string()}}\n\t}\n\tvm.stack[vm.sp-1] = prop\n\n\tvm.pc++\n}\n\ntype _getElemRecvCallee struct{}\n\nvar getElemRecvCallee _getElemRecvCallee\n\nfunc (_getElemRecvCallee) exec(vm *vm) {\n\trecv := vm.stack[vm.sp-3]\n\tv := vm.stack[vm.sp-2]\n\tobj := v.baseObject(vm.r)\n\tif obj == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Cannot read property '%s' of undefined\", vm.stack[vm.sp-1]))\n\t\treturn\n\t}\n\n\tpropName := toPropertyKey(vm.stack[vm.sp-1])\n\tprop := obj.get(propName, recv)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: propName.string()}}\n\t}\n\tvm.stack[vm.sp-2] = prop\n\tvm.sp--\n\n\tvm.pc++\n}\n\ntype _dup struct{}\n\nvar dup _dup\n\nfunc (_dup) exec(vm *vm) {\n\tvm.push(vm.stack[vm.sp-1])\n\tvm.pc++\n}\n\ntype dupN uint32\n\nfunc (d dupN) exec(vm *vm) {\n\tvm.push(vm.stack[vm.sp-1-int(d)])\n\tvm.pc++\n}\n\ntype rdupN uint32\n\nfunc (d rdupN) exec(vm *vm) {\n\tvm.stack[vm.sp-1-int(d)] = vm.stack[vm.sp-1]\n\tvm.pc++\n}\n\ntype dupLast uint32\n\nfunc (d dupLast) exec(vm *vm) {\n\te := vm.sp + int(d)\n\tvm.stack.expand(e)\n\tcopy(vm.stack[vm.sp:e], vm.stack[vm.sp-int(d):])\n\tvm.sp = e\n\tvm.pc++\n}\n\ntype _newObject struct{}\n\nvar newObject _newObject\n\nfunc (_newObject) exec(vm *vm) {\n\tvm.push(vm.r.NewObject())\n\tvm.pc++\n}\n\ntype newArray uint32\n\nfunc (l newArray) exec(vm *vm) {\n\tvalues := make([]Value, 0, l)\n\tvm.push(vm.r.newArrayValues(values))\n\tvm.pc++\n}\n\ntype _pushArrayItem struct{}\n\nvar pushArrayItem _pushArrayItem\n\nfunc (_pushArrayItem) exec(vm *vm) {\n\tarr := vm.stack[vm.sp-2].(*Object).self.(*arrayObject)\n\tif arr.length < math.MaxUint32 {\n\t\tarr.length++\n\t} else {\n\t\tvm.throw(vm.r.newError(vm.r.getRangeError(), \"Invalid array length\"))\n\t\treturn\n\t}\n\tval := vm.stack[vm.sp-1]\n\tarr.values = append(arr.values, val)\n\tif val != nil {\n\t\tarr.objCount++\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _pushArraySpread struct{}\n\nvar pushArraySpread _pushArraySpread\n\nfunc (_pushArraySpread) exec(vm *vm) {\n\tarr := vm.stack[vm.sp-2].(*Object).self.(*arrayObject)\n\tvm.r.getIterator(vm.stack[vm.sp-1], nil).iterate(func(val Value) {\n\t\tif arr.length < math.MaxUint32 {\n\t\t\tarr.length++\n\t\t} else {\n\t\t\tvm.throw(vm.r.newError(vm.r.getRangeError(), \"Invalid array length\"))\n\t\t\treturn\n\t\t}\n\t\tarr.values = append(arr.values, val)\n\t\tarr.objCount++\n\t})\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _pushSpread struct{}\n\nvar pushSpread _pushSpread\n\nfunc (_pushSpread) exec(vm *vm) {\n\tvm.sp--\n\tobj := vm.stack[vm.sp]\n\tvm.r.getIterator(obj, nil).iterate(func(val Value) {\n\t\tvm.push(val)\n\t})\n\tvm.pc++\n}\n\ntype _newArrayFromIter struct{}\n\nvar newArrayFromIter _newArrayFromIter\n\nfunc (_newArrayFromIter) exec(vm *vm) {\n\tvar values []Value\n\tl := len(vm.iterStack) - 1\n\titer := vm.iterStack[l].iter\n\tvm.iterStack[l] = iterStackItem{}\n\tvm.iterStack = vm.iterStack[:l]\n\tif iter.iterator != nil {\n\t\titer.iterate(func(val Value) {\n\t\t\tvalues = append(values, val)\n\t\t})\n\t}\n\tvm.push(vm.r.newArrayValues(values))\n\tvm.pc++\n}\n\ntype newRegexp struct {\n\tpattern *regexpPattern\n\tsrc     String\n}\n\nfunc (n *newRegexp) exec(vm *vm) {\n\tvm.push(vm.r.newRegExpp(n.pattern.clone(), n.src, vm.r.getRegExpPrototype()).val)\n\tvm.pc++\n}\n\nfunc (vm *vm) setLocalLex(s int) {\n\tv := vm.stack[vm.sp-1]\n\tlevel := s >> 24\n\tidx := uint32(s & 0x00FFFFFF)\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\tp := &stash.values[idx]\n\tif *p == nil {\n\t\tpanic(errAccessBeforeInit)\n\t}\n\t*p = v\n\tvm.pc++\n}\n\nfunc (vm *vm) initLocal(s int) {\n\tv := vm.stack[vm.sp-1]\n\tlevel := s >> 24\n\tidx := uint32(s & 0x00FFFFFF)\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\tstash.initByIdx(idx, v)\n\tvm.pc++\n}\n\ntype storeStash uint32\n\nfunc (s storeStash) exec(vm *vm) {\n\tvm.initLocal(int(s))\n}\n\ntype storeStashP uint32\n\nfunc (s storeStashP) exec(vm *vm) {\n\tvm.initLocal(int(s))\n\tvm.sp--\n}\n\ntype storeStashLex uint32\n\nfunc (s storeStashLex) exec(vm *vm) {\n\tvm.setLocalLex(int(s))\n}\n\ntype storeStashLexP uint32\n\nfunc (s storeStashLexP) exec(vm *vm) {\n\tvm.setLocalLex(int(s))\n\tvm.sp--\n}\n\ntype initStash uint32\n\nfunc (s initStash) exec(vm *vm) {\n\tvm.initLocal(int(s))\n}\n\ntype initStashP uint32\n\nfunc (s initStashP) exec(vm *vm) {\n\tvm.initLocal(int(s))\n\tvm.sp--\n}\n\ntype initGlobalP unistring.String\n\nfunc (s initGlobalP) exec(vm *vm) {\n\tvm.sp--\n\tvm.r.global.stash.initByName(unistring.String(s), vm.stack[vm.sp])\n\tvm.pc++\n}\n\ntype initGlobal unistring.String\n\nfunc (s initGlobal) exec(vm *vm) {\n\tvm.r.global.stash.initByName(unistring.String(s), vm.stack[vm.sp])\n\tvm.pc++\n}\n\ntype resolveVar1 unistring.String\n\nfunc (s resolveVar1) exec(vm *vm) {\n\tname := unistring.String(s)\n\tvar ref ref\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tref = stash.getRefByName(name, false)\n\t\tif ref != nil {\n\t\t\tgoto end\n\t\t}\n\t}\n\n\tref = &objStrRef{\n\t\tbase:    vm.r.globalObject,\n\t\tname:    name,\n\t\tbinding: true,\n\t}\n\nend:\n\tvm.refStack = append(vm.refStack, ref)\n\tvm.pc++\n}\n\ntype deleteVar unistring.String\n\nfunc (d deleteVar) exec(vm *vm) {\n\tname := unistring.String(d)\n\tret := true\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif stash.obj != nil {\n\t\t\tif stashObjHas(stash.obj, name) {\n\t\t\t\tret = stash.obj.self.deleteStr(name, false)\n\t\t\t\tgoto end\n\t\t\t}\n\t\t} else {\n\t\t\tif idx, exists := stash.names[name]; exists {\n\t\t\t\tif idx&(maskVar|maskDeletable) == maskVar|maskDeletable {\n\t\t\t\t\tstash.deleteBinding(name)\n\t\t\t\t} else {\n\t\t\t\t\tret = false\n\t\t\t\t}\n\t\t\t\tgoto end\n\t\t\t}\n\t\t}\n\t}\n\n\tif vm.r.globalObject.self.hasPropertyStr(name) {\n\t\tret = vm.r.globalObject.self.deleteStr(name, false)\n\t}\n\nend:\n\tif ret {\n\t\tvm.push(valueTrue)\n\t} else {\n\t\tvm.push(valueFalse)\n\t}\n\tvm.pc++\n}\n\ntype deleteGlobal unistring.String\n\nfunc (d deleteGlobal) exec(vm *vm) {\n\tname := unistring.String(d)\n\tvar ret bool\n\tif vm.r.globalObject.self.hasPropertyStr(name) {\n\t\tret = vm.r.globalObject.self.deleteStr(name, false)\n\t} else {\n\t\tret = true\n\t}\n\tif ret {\n\t\tvm.push(valueTrue)\n\t} else {\n\t\tvm.push(valueFalse)\n\t}\n\tvm.pc++\n}\n\ntype resolveVar1Strict unistring.String\n\nfunc (s resolveVar1Strict) exec(vm *vm) {\n\tname := unistring.String(s)\n\tvar ref ref\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tref = stash.getRefByName(name, true)\n\t\tif ref != nil {\n\t\t\tgoto end\n\t\t}\n\t}\n\n\tif vm.r.globalObject.self.hasPropertyStr(name) {\n\t\tref = &objStrRef{\n\t\t\tbase:    vm.r.globalObject,\n\t\t\tname:    name,\n\t\t\tbinding: true,\n\t\t\tstrict:  true,\n\t\t}\n\t\tgoto end\n\t}\n\n\tref = &unresolvedRef{\n\t\truntime: vm.r,\n\t\tname:    name,\n\t}\n\nend:\n\tvm.refStack = append(vm.refStack, ref)\n\tvm.pc++\n}\n\ntype setGlobal unistring.String\n\nfunc (s setGlobal) exec(vm *vm) {\n\tvm.r.setGlobal(unistring.String(s), vm.peek(), false)\n\tvm.pc++\n}\n\ntype setGlobalStrict unistring.String\n\nfunc (s setGlobalStrict) exec(vm *vm) {\n\tvm.r.setGlobal(unistring.String(s), vm.peek(), true)\n\tvm.pc++\n}\n\n// Load a var from stash\ntype loadStash uint32\n\nfunc (g loadStash) exec(vm *vm) {\n\tlevel := int(g >> 24)\n\tidx := uint32(g & 0x00FFFFFF)\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\n\tvm.push(nilSafe(stash.getByIdx(idx)))\n\tvm.pc++\n}\n\n// Load a lexical binding from stash\ntype loadStashLex uint32\n\nfunc (g loadStashLex) exec(vm *vm) {\n\tlevel := int(g >> 24)\n\tidx := uint32(g & 0x00FFFFFF)\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\n\tv := stash.getByIdx(idx)\n\tif v == nil {\n\t\tvm.throw(errAccessBeforeInit)\n\t\treturn\n\t}\n\tvm.push(v)\n\tvm.pc++\n}\n\n// scan dynamic stashes up to the given level (encoded as 8 most significant bits of idx), if not found\n// return the indexed var binding value from stash\ntype loadMixed struct {\n\tname   unistring.String\n\tidx    uint32\n\tcallee bool\n}\n\nfunc (g *loadMixed) exec(vm *vm) {\n\tlevel := int(g.idx >> 24)\n\tidx := g.idx & 0x00FFFFFF\n\tstash := vm.stash\n\tname := g.name\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tif stash != nil {\n\t\tvm.push(nilSafe(stash.getByIdx(idx)))\n\t}\nend:\n\tvm.pc++\n}\n\n// scan dynamic stashes up to the given level (encoded as 8 most significant bits of idx), if not found\n// return the indexed lexical binding value from stash\ntype loadMixedLex loadMixed\n\nfunc (g *loadMixedLex) exec(vm *vm) {\n\tlevel := int(g.idx >> 24)\n\tidx := g.idx & 0x00FFFFFF\n\tstash := vm.stash\n\tname := g.name\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tif stash != nil {\n\t\tv := stash.getByIdx(idx)\n\t\tif v == nil {\n\t\t\tvm.throw(errAccessBeforeInit)\n\t\t\treturn\n\t\t}\n\t\tvm.push(v)\n\t}\nend:\n\tvm.pc++\n}\n\n// scan dynamic stashes up to the given level (encoded as 8 most significant bits of idx), if not found\n// return the indexed var binding value from stack\ntype loadMixedStack struct {\n\tname   unistring.String\n\tidx    int\n\tlevel  uint8\n\tcallee bool\n}\n\n// same as loadMixedStack, but the args have been moved to stash (therefore stack layout is different)\ntype loadMixedStack1 loadMixedStack\n\nfunc (g *loadMixedStack) exec(vm *vm) {\n\tstash := vm.stash\n\tname := g.name\n\tlevel := int(g.level)\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tloadStack(g.idx).exec(vm)\n\treturn\nend:\n\tvm.pc++\n}\n\nfunc (g *loadMixedStack1) exec(vm *vm) {\n\tstash := vm.stash\n\tname := g.name\n\tlevel := int(g.level)\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tloadStack1(g.idx).exec(vm)\n\treturn\nend:\n\tvm.pc++\n}\n\ntype loadMixedStackLex loadMixedStack\n\n// same as loadMixedStackLex but when the arguments have been moved into stash\ntype loadMixedStack1Lex loadMixedStack\n\nfunc (g *loadMixedStackLex) exec(vm *vm) {\n\tstash := vm.stash\n\tname := g.name\n\tlevel := int(g.level)\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tloadStackLex(g.idx).exec(vm)\n\treturn\nend:\n\tvm.pc++\n}\n\nfunc (g *loadMixedStack1Lex) exec(vm *vm) {\n\tstash := vm.stash\n\tname := g.name\n\tlevel := int(g.level)\n\tfor i := 0; i < level; i++ {\n\t\tif v, found := stash.getByName(name); found {\n\t\t\tif g.callee {\n\t\t\t\tif stash.obj != nil {\n\t\t\t\t\tvm.push(stash.obj)\n\t\t\t\t} else {\n\t\t\t\t\tvm.push(_undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvm.push(v)\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\tif g.callee {\n\t\tvm.push(_undefined)\n\t}\n\tloadStack1Lex(g.idx).exec(vm)\n\treturn\nend:\n\tvm.pc++\n}\n\ntype resolveMixed struct {\n\tname   unistring.String\n\tidx    uint32\n\ttyp    varType\n\tstrict bool\n}\n\nfunc newStashRef(typ varType, name unistring.String, v *[]Value, idx int) ref {\n\tswitch typ {\n\tcase varTypeVar:\n\t\treturn &stashRef{\n\t\t\tn:   name,\n\t\t\tv:   v,\n\t\t\tidx: idx,\n\t\t}\n\tcase varTypeLet:\n\t\treturn &stashRefLex{\n\t\t\tstashRef: stashRef{\n\t\t\t\tn:   name,\n\t\t\t\tv:   v,\n\t\t\t\tidx: idx,\n\t\t\t},\n\t\t}\n\tcase varTypeConst, varTypeStrictConst:\n\t\treturn &stashRefConst{\n\t\t\tstashRefLex: stashRefLex{\n\t\t\t\tstashRef: stashRef{\n\t\t\t\t\tn:   name,\n\t\t\t\t\tv:   v,\n\t\t\t\t\tidx: idx,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrictConst: typ == varTypeStrictConst,\n\t\t}\n\t}\n\tpanic(\"unsupported var type\")\n}\n\nfunc (r *resolveMixed) exec(vm *vm) {\n\tlevel := int(r.idx >> 24)\n\tidx := r.idx & 0x00FFFFFF\n\tstash := vm.stash\n\tvar ref ref\n\tfor i := 0; i < level; i++ {\n\t\tref = stash.getRefByName(r.name, r.strict)\n\t\tif ref != nil {\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\n\tif stash != nil {\n\t\tref = newStashRef(r.typ, r.name, &stash.values, int(idx))\n\t\tgoto end\n\t}\n\n\tref = &unresolvedRef{\n\t\truntime: vm.r,\n\t\tname:    r.name,\n\t}\n\nend:\n\tvm.refStack = append(vm.refStack, ref)\n\tvm.pc++\n}\n\ntype resolveMixedStack struct {\n\tname   unistring.String\n\tidx    int\n\ttyp    varType\n\tlevel  uint8\n\tstrict bool\n}\n\ntype resolveMixedStack1 resolveMixedStack\n\nfunc (r *resolveMixedStack) exec(vm *vm) {\n\tlevel := int(r.level)\n\tstash := vm.stash\n\tvar ref ref\n\tvar idx int\n\tfor i := 0; i < level; i++ {\n\t\tref = stash.getRefByName(r.name, r.strict)\n\t\tif ref != nil {\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\n\tif r.idx > 0 {\n\t\tidx = vm.sb + vm.args + r.idx\n\t} else {\n\t\tidx = vm.sb - r.idx\n\t}\n\n\tref = newStashRef(r.typ, r.name, (*[]Value)(&vm.stack), idx)\n\nend:\n\tvm.refStack = append(vm.refStack, ref)\n\tvm.pc++\n}\n\nfunc (r *resolveMixedStack1) exec(vm *vm) {\n\tlevel := int(r.level)\n\tstash := vm.stash\n\tvar ref ref\n\tfor i := 0; i < level; i++ {\n\t\tref = stash.getRefByName(r.name, r.strict)\n\t\tif ref != nil {\n\t\t\tgoto end\n\t\t}\n\t\tstash = stash.outer\n\t}\n\n\tref = newStashRef(r.typ, r.name, (*[]Value)(&vm.stack), vm.sb+r.idx)\n\nend:\n\tvm.refStack = append(vm.refStack, ref)\n\tvm.pc++\n}\n\ntype _getValue struct{}\n\nvar getValue _getValue\n\nfunc (_getValue) exec(vm *vm) {\n\tref := vm.refStack[len(vm.refStack)-1]\n\tif v := ref.get(); v != nil {\n\t\tvm.push(v)\n\t} else {\n\t\tvm.throw(vm.r.newReferenceError(ref.refname()))\n\t\treturn\n\t}\n\tvm.pc++\n}\n\ntype _putValue struct{}\n\nvar putValue _putValue\n\nfunc (_putValue) exec(vm *vm) {\n\tl := len(vm.refStack) - 1\n\tref := vm.refStack[l]\n\tvm.refStack[l] = nil\n\tvm.refStack = vm.refStack[:l]\n\tref.set(vm.stack[vm.sp-1])\n\tvm.pc++\n}\n\ntype _putValueP struct{}\n\nvar putValueP _putValueP\n\nfunc (_putValueP) exec(vm *vm) {\n\tl := len(vm.refStack) - 1\n\tref := vm.refStack[l]\n\tvm.refStack[l] = nil\n\tvm.refStack = vm.refStack[:l]\n\tref.set(vm.stack[vm.sp-1])\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _initValueP struct{}\n\nvar initValueP _initValueP\n\nfunc (_initValueP) exec(vm *vm) {\n\tl := len(vm.refStack) - 1\n\tref := vm.refStack[l]\n\tvm.refStack[l] = nil\n\tvm.refStack = vm.refStack[:l]\n\tref.init(vm.stack[vm.sp-1])\n\tvm.sp--\n\tvm.pc++\n}\n\ntype loadDynamic unistring.String\n\nfunc (n loadDynamic) exec(vm *vm) {\n\tname := unistring.String(n)\n\tvar val Value\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif v, exists := stash.getByName(name); exists {\n\t\t\tval = v\n\t\t\tbreak\n\t\t}\n\t}\n\tif val == nil {\n\t\tval = vm.r.globalObject.self.getStr(name, nil)\n\t\tif val == nil {\n\t\t\tvm.throw(vm.r.newReferenceError(name))\n\t\t\treturn\n\t\t}\n\t}\n\tvm.push(val)\n\tvm.pc++\n}\n\ntype loadDynamicRef unistring.String\n\nfunc (n loadDynamicRef) exec(vm *vm) {\n\tname := unistring.String(n)\n\tvar val Value\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif v, exists := stash.getByName(name); exists {\n\t\t\tval = v\n\t\t\tbreak\n\t\t}\n\t}\n\tif val == nil {\n\t\tval = vm.r.globalObject.self.getStr(name, nil)\n\t\tif val == nil {\n\t\t\tval = valueUnresolved{r: vm.r, ref: name}\n\t\t}\n\t}\n\tvm.push(val)\n\tvm.pc++\n}\n\ntype loadDynamicCallee unistring.String\n\nfunc (n loadDynamicCallee) exec(vm *vm) {\n\tname := unistring.String(n)\n\tvar val Value\n\tvar callee *Object\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif v, exists := stash.getByName(name); exists {\n\t\t\tcallee = stash.obj\n\t\t\tval = v\n\t\t\tbreak\n\t\t}\n\t}\n\tif val == nil {\n\t\tval = vm.r.globalObject.self.getStr(name, nil)\n\t\tif val == nil {\n\t\t\tval = valueUnresolved{r: vm.r, ref: name}\n\t\t}\n\t}\n\tif callee != nil {\n\t\tvm.push(callee)\n\t} else {\n\t\tvm.push(_undefined)\n\t}\n\tvm.push(val)\n\tvm.pc++\n}\n\ntype _pop struct{}\n\nvar pop _pop\n\nfunc (_pop) exec(vm *vm) {\n\tvm.sp--\n\tvm.pc++\n}\n\nfunc (vm *vm) callEval(n int, strict bool) {\n\tif vm.r.toObject(vm.stack[vm.sp-n-1]) == vm.r.global.Eval {\n\t\tif n > 0 {\n\t\t\tsrcVal := vm.stack[vm.sp-n]\n\t\t\tif src, ok := srcVal.(String); ok {\n\t\t\t\tret := vm.r.eval(src, true, strict)\n\t\t\t\tvm.stack[vm.sp-n-2] = ret\n\t\t\t} else {\n\t\t\t\tvm.stack[vm.sp-n-2] = srcVal\n\t\t\t}\n\t\t} else {\n\t\t\tvm.stack[vm.sp-n-2] = _undefined\n\t\t}\n\n\t\tvm.sp -= n + 1\n\t\tvm.pc++\n\t} else {\n\t\tcall(n).exec(vm)\n\t}\n}\n\ntype callEval uint32\n\nfunc (numargs callEval) exec(vm *vm) {\n\tvm.callEval(int(numargs), false)\n}\n\ntype callEvalStrict uint32\n\nfunc (numargs callEvalStrict) exec(vm *vm) {\n\tvm.callEval(int(numargs), true)\n}\n\ntype _callEvalVariadic struct{}\n\nvar callEvalVariadic _callEvalVariadic\n\nfunc (_callEvalVariadic) exec(vm *vm) {\n\tvm.callEval(vm.countVariadicArgs()-2, false)\n}\n\ntype _callEvalVariadicStrict struct{}\n\nvar callEvalVariadicStrict _callEvalVariadicStrict\n\nfunc (_callEvalVariadicStrict) exec(vm *vm) {\n\tvm.callEval(vm.countVariadicArgs()-2, true)\n}\n\ntype _boxThis struct{}\n\nvar boxThis _boxThis\n\nfunc (_boxThis) exec(vm *vm) {\n\tv := vm.stack[vm.sb]\n\tif v == _undefined || v == _null {\n\t\tvm.stack[vm.sb] = vm.r.globalObject\n\t} else {\n\t\tvm.stack[vm.sb] = v.ToObject(vm.r)\n\t}\n\tvm.pc++\n}\n\nvar variadicMarker Value = newSymbol(asciiString(\"[variadic marker]\"))\n\ntype _startVariadic struct{}\n\nvar startVariadic _startVariadic\n\nfunc (_startVariadic) exec(vm *vm) {\n\tvm.push(variadicMarker)\n\tvm.pc++\n}\n\ntype _callVariadic struct{}\n\nvar callVariadic _callVariadic\n\nfunc (vm *vm) countVariadicArgs() int {\n\tcount := 0\n\tfor i := vm.sp - 1; i >= 0; i-- {\n\t\tif vm.stack[i] == variadicMarker {\n\t\t\treturn count\n\t\t}\n\t\tcount++\n\t}\n\tpanic(\"Variadic marker was not found. Compiler bug.\")\n}\n\nfunc (_callVariadic) exec(vm *vm) {\n\tcall(vm.countVariadicArgs() - 2).exec(vm)\n}\n\ntype _endVariadic struct{}\n\nvar endVariadic _endVariadic\n\nfunc (_endVariadic) exec(vm *vm) {\n\tvm.sp--\n\tvm.stack[vm.sp-1] = vm.stack[vm.sp]\n\tvm.pc++\n}\n\ntype call uint32\n\nfunc (numargs call) exec(vm *vm) {\n\t// this\n\t// callee\n\t// arg0\n\t// ...\n\t// arg<numargs-1>\n\tn := int(numargs)\n\tv := vm.stack[vm.sp-n-1] // callee\n\tobj := vm.toCallee(v)\n\tobj.self.vmCall(vm, n)\n}\n\nfunc (vm *vm) clearStack() {\n\tsp := vm.sp\n\tstackTail := vm.stack[sp:]\n\tfor i := range stackTail {\n\t\tstackTail[i] = nil\n\t}\n\tvm.stack = vm.stack[:sp]\n}\n\ntype enterBlock struct {\n\tnames     map[unistring.String]uint32\n\tstashSize uint32\n\tstackSize uint32\n}\n\nfunc (e *enterBlock) exec(vm *vm) {\n\tif e.stashSize > 0 {\n\t\tvm.newStash()\n\t\tvm.stash.values = make([]Value, e.stashSize)\n\t\tif len(e.names) > 0 {\n\t\t\tvm.stash.names = e.names\n\t\t}\n\t}\n\tss := int(e.stackSize)\n\tvm.stack.expand(vm.sp + ss - 1)\n\tvv := vm.stack[vm.sp : vm.sp+ss]\n\tfor i := range vv {\n\t\tvv[i] = nil\n\t}\n\tvm.sp += ss\n\tvm.pc++\n}\n\ntype enterCatchBlock struct {\n\tnames     map[unistring.String]uint32\n\tstashSize uint32\n\tstackSize uint32\n}\n\nfunc (e *enterCatchBlock) exec(vm *vm) {\n\tvm.newStash()\n\tvm.stash.values = make([]Value, e.stashSize)\n\tif len(e.names) > 0 {\n\t\tvm.stash.names = e.names\n\t}\n\tvm.sp--\n\tvm.stash.values[0] = vm.stack[vm.sp]\n\tss := int(e.stackSize)\n\tvm.stack.expand(vm.sp + ss - 1)\n\tvv := vm.stack[vm.sp : vm.sp+ss]\n\tfor i := range vv {\n\t\tvv[i] = nil\n\t}\n\tvm.sp += ss\n\tvm.pc++\n}\n\ntype leaveBlock struct {\n\tstackSize uint32\n\tpopStash  bool\n}\n\nfunc (l *leaveBlock) exec(vm *vm) {\n\tif l.popStash {\n\t\tvm.stash = vm.stash.outer\n\t}\n\tif ss := l.stackSize; ss > 0 {\n\t\tvm.sp -= int(ss)\n\t}\n\tvm.pc++\n}\n\ntype enterFunc struct {\n\tnames       map[unistring.String]uint32\n\tstashSize   uint32\n\tstackSize   uint32\n\tnumArgs     uint32\n\tfuncType    funcType\n\targsToStash bool\n\textensible  bool\n}\n\nfunc (e *enterFunc) exec(vm *vm) {\n\t// Input stack:\n\t//\n\t// callee\n\t// this\n\t// arg0\n\t// ...\n\t// argN\n\t// <- sp\n\n\t// Output stack:\n\t//\n\t// this <- sb\n\t// <local stack vars...>\n\t// <- sp\n\tsp := vm.sp\n\tvm.sb = sp - vm.args - 1\n\tvm.newStash()\n\tstash := vm.stash\n\tstash.funcType = e.funcType\n\tstash.values = make([]Value, e.stashSize)\n\tif len(e.names) > 0 {\n\t\tif e.extensible {\n\t\t\tm := make(map[unistring.String]uint32, len(e.names))\n\t\t\tfor name, idx := range e.names {\n\t\t\t\tm[name] = idx\n\t\t\t}\n\t\t\tstash.names = m\n\t\t} else {\n\t\t\tstash.names = e.names\n\t\t}\n\t}\n\n\tss := int(e.stackSize)\n\tea := 0\n\tif e.argsToStash {\n\t\toffset := vm.args - int(e.numArgs)\n\t\tcopy(stash.values, vm.stack[sp-vm.args:sp])\n\t\tif offset > 0 {\n\t\t\tvm.stash.extraArgs = make([]Value, offset)\n\t\t\tcopy(stash.extraArgs, vm.stack[sp-offset:])\n\t\t} else {\n\t\t\tvv := stash.values[vm.args:e.numArgs]\n\t\t\tfor i := range vv {\n\t\t\t\tvv[i] = _undefined\n\t\t\t}\n\t\t}\n\t\tsp -= vm.args\n\t} else {\n\t\td := int(e.numArgs) - vm.args\n\t\tif d > 0 {\n\t\t\tss += d\n\t\t\tea = d\n\t\t\tvm.args = int(e.numArgs)\n\t\t}\n\t}\n\tvm.stack.expand(sp + ss - 1)\n\tif ea > 0 {\n\t\tvv := vm.stack[sp : vm.sp+ea]\n\t\tfor i := range vv {\n\t\t\tvv[i] = _undefined\n\t\t}\n\t}\n\tvv := vm.stack[sp+ea : sp+ss]\n\tfor i := range vv {\n\t\tvv[i] = nil\n\t}\n\tvm.sp = sp + ss\n\tvm.pc++\n}\n\n// Similar to enterFunc, but for when arguments may be accessed before they are initialised,\n// e.g. by an eval() code or from a closure, or from an earlier initialiser code.\n// In this case the arguments remain on stack, first argsToCopy of them are copied to the stash.\ntype enterFunc1 struct {\n\tnames      map[unistring.String]uint32\n\tstashSize  uint32\n\tnumArgs    uint32\n\targsToCopy uint32\n\tfuncType   funcType\n\textensible bool\n}\n\nfunc (e *enterFunc1) exec(vm *vm) {\n\tsp := vm.sp\n\tvm.sb = sp - vm.args - 1\n\tvm.newStash()\n\tstash := vm.stash\n\tstash.funcType = e.funcType\n\tstash.values = make([]Value, e.stashSize)\n\tif len(e.names) > 0 {\n\t\tif e.extensible {\n\t\t\tm := make(map[unistring.String]uint32, len(e.names))\n\t\t\tfor name, idx := range e.names {\n\t\t\t\tm[name] = idx\n\t\t\t}\n\t\t\tstash.names = m\n\t\t} else {\n\t\t\tstash.names = e.names\n\t\t}\n\t}\n\toffset := vm.args - int(e.argsToCopy)\n\tif offset > 0 {\n\t\tcopy(stash.values, vm.stack[sp-vm.args:sp-offset])\n\t\tif offset := vm.args - int(e.numArgs); offset > 0 {\n\t\t\tvm.stash.extraArgs = make([]Value, offset)\n\t\t\tcopy(stash.extraArgs, vm.stack[sp-offset:])\n\t\t}\n\t} else {\n\t\tcopy(stash.values, vm.stack[sp-vm.args:sp])\n\t\tif int(e.argsToCopy) > vm.args {\n\t\t\tvv := stash.values[vm.args:e.argsToCopy]\n\t\t\tfor i := range vv {\n\t\t\t\tvv[i] = _undefined\n\t\t\t}\n\t\t}\n\t}\n\n\tvm.pc++\n}\n\n// Finalises the initialisers section and starts the function body which has its own\n// scope. When used in conjunction with enterFunc1 adjustStack is set to true which\n// causes the arguments to be removed from the stack.\ntype enterFuncBody struct {\n\tenterBlock\n\tfuncType    funcType\n\textensible  bool\n\tadjustStack bool\n}\n\nfunc (e *enterFuncBody) exec(vm *vm) {\n\tif e.stashSize > 0 || e.extensible {\n\t\tvm.newStash()\n\t\tstash := vm.stash\n\t\tstash.funcType = e.funcType\n\t\tstash.values = make([]Value, e.stashSize)\n\t\tif len(e.names) > 0 {\n\t\t\tif e.extensible {\n\t\t\t\tm := make(map[unistring.String]uint32, len(e.names))\n\t\t\t\tfor name, idx := range e.names {\n\t\t\t\t\tm[name] = idx\n\t\t\t\t}\n\t\t\t\tstash.names = m\n\t\t\t} else {\n\t\t\t\tstash.names = e.names\n\t\t\t}\n\t\t}\n\t}\n\tsp := vm.sp\n\tif e.adjustStack {\n\t\tsp -= vm.args\n\t}\n\tnsp := sp + int(e.stackSize)\n\tif e.stackSize > 0 {\n\t\tvm.stack.expand(nsp - 1)\n\t\tvv := vm.stack[sp:nsp]\n\t\tfor i := range vv {\n\t\t\tvv[i] = nil\n\t\t}\n\t}\n\tvm.sp = nsp\n\tvm.pc++\n}\n\ntype _ret struct{}\n\nvar ret _ret\n\nfunc (_ret) exec(vm *vm) {\n\t// callee -3\n\t// this -2 <- sb\n\t// retval -1\n\n\tvm.stack[vm.sb-1] = vm.stack[vm.sp-1]\n\tvm.sp = vm.sb\n\tvm.popCtx()\n\tvm.pc++\n}\n\ntype cret uint32\n\nfunc (c cret) exec(vm *vm) {\n\tvm.stack[vm.sb] = *vm.getStashPtr(uint32(c))\n\tret.exec(vm)\n}\n\ntype enterFuncStashless struct {\n\tstackSize uint32\n\targs      uint32\n}\n\nfunc (e *enterFuncStashless) exec(vm *vm) {\n\tsp := vm.sp\n\tvm.sb = sp - vm.args - 1\n\td := int(e.args) - vm.args\n\tif d > 0 {\n\t\tss := sp + int(e.stackSize) + d\n\t\tvm.stack.expand(ss)\n\t\tvv := vm.stack[sp : sp+d]\n\t\tfor i := range vv {\n\t\t\tvv[i] = _undefined\n\t\t}\n\t\tvv = vm.stack[sp+d : ss]\n\t\tfor i := range vv {\n\t\t\tvv[i] = nil\n\t\t}\n\t\tvm.args = int(e.args)\n\t\tvm.sp = ss\n\t} else {\n\t\tif e.stackSize > 0 {\n\t\t\tss := sp + int(e.stackSize)\n\t\t\tvm.stack.expand(ss)\n\t\t\tvv := vm.stack[sp:ss]\n\t\t\tfor i := range vv {\n\t\t\t\tvv[i] = nil\n\t\t\t}\n\t\t\tvm.sp = ss\n\t\t}\n\t}\n\tvm.pc++\n}\n\ntype newFuncInstruction interface {\n\tgetPrg() *Program\n}\n\ntype newFunc struct {\n\tprg    *Program\n\tname   unistring.String\n\tsource string\n\n\tlength int\n\tstrict bool\n}\n\nfunc (n *newFunc) exec(vm *vm) {\n\tobj := vm.r.newFunc(n.name, n.length, n.strict)\n\tobj.prg = n.prg\n\tobj.stash = vm.stash\n\tobj.privEnv = vm.privEnv\n\tobj.src = n.source\n\tvm.push(obj.val)\n\tvm.pc++\n}\n\nfunc (n *newFunc) getPrg() *Program {\n\treturn n.prg\n}\n\ntype newAsyncFunc struct {\n\tnewFunc\n}\n\nfunc (n *newAsyncFunc) exec(vm *vm) {\n\tobj := vm.r.newAsyncFunc(n.name, n.length, n.strict)\n\tobj.prg = n.prg\n\tobj.stash = vm.stash\n\tobj.privEnv = vm.privEnv\n\tobj.src = n.source\n\tvm.push(obj.val)\n\tvm.pc++\n}\n\ntype newGeneratorFunc struct {\n\tnewFunc\n}\n\nfunc (n *newGeneratorFunc) exec(vm *vm) {\n\tobj := vm.r.newGeneratorFunc(n.name, n.length, n.strict)\n\tobj.prg = n.prg\n\tobj.stash = vm.stash\n\tobj.privEnv = vm.privEnv\n\tobj.src = n.source\n\tvm.push(obj.val)\n\tvm.pc++\n}\n\ntype newMethod struct {\n\tnewFunc\n\thomeObjOffset uint32\n}\n\nfunc (n *newMethod) _exec(vm *vm, obj *methodFuncObject) {\n\tobj.prg = n.prg\n\tobj.stash = vm.stash\n\tobj.privEnv = vm.privEnv\n\tobj.src = n.source\n\tif n.homeObjOffset > 0 {\n\t\tobj.homeObject = vm.r.toObject(vm.stack[vm.sp-int(n.homeObjOffset)])\n\t}\n\tvm.push(obj.val)\n\tvm.pc++\n}\n\nfunc (n *newMethod) exec(vm *vm) {\n\tn._exec(vm, vm.r.newMethod(n.name, n.length, n.strict))\n}\n\ntype newAsyncMethod struct {\n\tnewMethod\n}\n\nfunc (n *newAsyncMethod) exec(vm *vm) {\n\tobj := vm.r.newAsyncMethod(n.name, n.length, n.strict)\n\tn._exec(vm, &obj.methodFuncObject)\n}\n\ntype newGeneratorMethod struct {\n\tnewMethod\n}\n\nfunc (n *newGeneratorMethod) exec(vm *vm) {\n\tobj := vm.r.newGeneratorMethod(n.name, n.length, n.strict)\n\tn._exec(vm, &obj.methodFuncObject)\n}\n\ntype newArrowFunc struct {\n\tnewFunc\n}\n\ntype newAsyncArrowFunc struct {\n\tnewArrowFunc\n}\n\nfunc getFuncObject(v Value) *Object {\n\tif o, ok := v.(*Object); ok {\n\t\tif fn, ok := o.self.(*arrowFuncObject); ok {\n\t\t\treturn fn.funcObj\n\t\t}\n\t\treturn o\n\t}\n\tif v == _undefined {\n\t\treturn nil\n\t}\n\tpanic(typeError(\"Value is not an Object\"))\n}\n\nfunc getHomeObject(v Value) *Object {\n\tif o, ok := v.(*Object); ok {\n\t\tswitch fn := o.self.(type) {\n\t\tcase *methodFuncObject:\n\t\t\treturn fn.homeObject\n\t\tcase *generatorMethodFuncObject:\n\t\t\treturn fn.homeObject\n\t\tcase *asyncMethodFuncObject:\n\t\t\treturn fn.homeObject\n\t\tcase *classFuncObject:\n\t\t\treturn o.runtime.toObject(fn.getStr(\"prototype\", nil))\n\t\tcase *arrowFuncObject:\n\t\t\treturn getHomeObject(fn.funcObj)\n\t\tcase *asyncArrowFuncObject:\n\t\t\treturn getHomeObject(fn.funcObj)\n\t\t}\n\t}\n\tpanic(newTypeError(\"Compiler bug: getHomeObject() on the wrong value: %T\", v))\n}\n\nfunc (n *newArrowFunc) _exec(vm *vm, obj *arrowFuncObject) {\n\tobj.prg = n.prg\n\tobj.stash = vm.stash\n\tobj.privEnv = vm.privEnv\n\tobj.src = n.source\n\tif vm.sb > 0 {\n\t\tobj.funcObj = getFuncObject(vm.stack[vm.sb-1])\n\t}\n\tvm.push(obj.val)\n\tvm.pc++\n}\n\nfunc (n *newArrowFunc) exec(vm *vm) {\n\tn._exec(vm, vm.r.newArrowFunc(n.name, n.length, n.strict))\n}\n\nfunc (n *newAsyncArrowFunc) exec(vm *vm) {\n\tobj := vm.r.newAsyncArrowFunc(n.name, n.length, n.strict)\n\tn._exec(vm, &obj.arrowFuncObject)\n}\n\nfunc (vm *vm) alreadyDeclared(name unistring.String) Value {\n\treturn vm.r.newError(vm.r.getSyntaxError(), \"Identifier '%s' has already been declared\", name)\n}\n\nfunc (vm *vm) checkBindVarsGlobal(names []unistring.String) {\n\to := vm.r.globalObject.self\n\tsn := vm.r.global.stash.names\n\tif bo, ok := o.(*baseObject); ok {\n\t\t// shortcut\n\t\tif bo.extensible {\n\t\t\tfor _, name := range names {\n\t\t\t\tif _, exists := sn[name]; exists {\n\t\t\t\t\tpanic(vm.alreadyDeclared(name))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, name := range names {\n\t\t\t\tif !bo.hasOwnPropertyStr(name) {\n\t\t\t\t\tpanic(vm.r.NewTypeError(\"Cannot define global variable '%s', global object is not extensible\", name))\n\t\t\t\t}\n\t\t\t\tif _, exists := sn[name]; exists {\n\t\t\t\t\tpanic(vm.alreadyDeclared(name))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, name := range names {\n\t\t\tif !o.hasOwnPropertyStr(name) && !o.isExtensible() {\n\t\t\t\tpanic(vm.r.NewTypeError(\"Cannot define global variable '%s', global object is not extensible\", name))\n\t\t\t}\n\t\t\tif _, exists := sn[name]; exists {\n\t\t\t\tpanic(vm.alreadyDeclared(name))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (vm *vm) createGlobalVarBindings(names []unistring.String, d bool) {\n\to := vm.r.globalObject.self\n\tif bo, ok := o.(*templatedObject); ok {\n\t\tfor _, name := range names {\n\t\t\tif !bo.hasOwnPropertyStr(name) && bo.extensible {\n\t\t\t\tbo._putProp(name, _undefined, true, true, d)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar cf Flag\n\t\tif d {\n\t\t\tcf = FLAG_TRUE\n\t\t} else {\n\t\t\tcf = FLAG_FALSE\n\t\t}\n\t\tfor _, name := range names {\n\t\t\tif !o.hasOwnPropertyStr(name) && o.isExtensible() {\n\t\t\t\to.defineOwnPropertyStr(name, PropertyDescriptor{\n\t\t\t\t\tValue:        _undefined,\n\t\t\t\t\tWritable:     FLAG_TRUE,\n\t\t\t\t\tEnumerable:   FLAG_TRUE,\n\t\t\t\t\tConfigurable: cf,\n\t\t\t\t}, true)\n\t\t\t\to.setOwnStr(name, _undefined, false)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (vm *vm) createGlobalFuncBindings(names []unistring.String, d bool) {\n\to := vm.r.globalObject.self\n\tb := vm.sp - len(names)\n\tvar shortcutObj *templatedObject\n\tif o, ok := o.(*templatedObject); ok {\n\t\tshortcutObj = o\n\t}\n\tfor i, name := range names {\n\t\tvar desc PropertyDescriptor\n\t\tprop := o.getOwnPropStr(name)\n\t\tdesc.Value = vm.stack[b+i]\n\t\tif shortcutObj != nil && prop == nil && shortcutObj.extensible {\n\t\t\tshortcutObj._putProp(name, desc.Value, true, true, d)\n\t\t} else {\n\t\t\tif prop, ok := prop.(*valueProperty); ok && !prop.configurable {\n\t\t\t\t// no-op\n\t\t\t} else {\n\t\t\t\tdesc.Writable = FLAG_TRUE\n\t\t\t\tdesc.Enumerable = FLAG_TRUE\n\t\t\t\tif d {\n\t\t\t\t\tdesc.Configurable = FLAG_TRUE\n\t\t\t\t} else {\n\t\t\t\t\tdesc.Configurable = FLAG_FALSE\n\t\t\t\t}\n\t\t\t}\n\t\t\tif shortcutObj != nil {\n\t\t\t\tshortcutObj.defineOwnPropertyStr(name, desc, true)\n\t\t\t} else {\n\t\t\t\to.defineOwnPropertyStr(name, desc, true)\n\t\t\t\to.setOwnStr(name, desc.Value, false) // not a bug, see https://262.ecma-international.org/#sec-createglobalfunctionbinding\n\t\t\t}\n\t\t}\n\t}\n\tvm.sp = b\n}\n\nfunc (vm *vm) checkBindFuncsGlobal(names []unistring.String) {\n\to := vm.r.globalObject.self\n\tsn := vm.r.global.stash.names\n\tfor _, name := range names {\n\t\tif _, exists := sn[name]; exists {\n\t\t\tpanic(vm.alreadyDeclared(name))\n\t\t}\n\t\tprop := o.getOwnPropStr(name)\n\t\tallowed := true\n\t\tswitch prop := prop.(type) {\n\t\tcase nil:\n\t\t\tallowed = o.isExtensible()\n\t\tcase *valueProperty:\n\t\t\tallowed = prop.configurable || prop.getterFunc == nil && prop.setterFunc == nil && prop.writable && prop.enumerable\n\t\t}\n\t\tif !allowed {\n\t\t\tpanic(vm.r.NewTypeError(\"Cannot redefine global function '%s'\", name))\n\t\t}\n\t}\n}\n\nfunc (vm *vm) checkBindLexGlobal(names []unistring.String) {\n\to := vm.r.globalObject.self\n\ts := &vm.r.global.stash\n\tfor _, name := range names {\n\t\tif _, exists := s.names[name]; exists {\n\t\t\tgoto fail\n\t\t}\n\t\tif prop, ok := o.getOwnPropStr(name).(*valueProperty); ok && !prop.configurable {\n\t\t\tgoto fail\n\t\t}\n\t\tcontinue\n\tfail:\n\t\tpanic(vm.alreadyDeclared(name))\n\t}\n}\n\ntype bindVars struct {\n\tnames     []unistring.String\n\tdeletable bool\n}\n\nfunc (d *bindVars) exec(vm *vm) {\n\tvar target *stash\n\tfor _, name := range d.names {\n\t\tfor s := vm.stash; s != nil; s = s.outer {\n\t\t\tif idx, exists := s.names[name]; exists && idx&maskVar == 0 {\n\t\t\t\tvm.throw(vm.alreadyDeclared(name))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s.isVariable() {\n\t\t\t\ttarget = s\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif target == nil {\n\t\ttarget = vm.stash\n\t}\n\tdeletable := d.deletable\n\tfor _, name := range d.names {\n\t\ttarget.createBinding(name, deletable)\n\t}\n\tvm.pc++\n}\n\ntype bindGlobal struct {\n\tvars, funcs, lets, consts []unistring.String\n\n\tdeletable bool\n}\n\nfunc (b *bindGlobal) exec(vm *vm) {\n\tvm.checkBindFuncsGlobal(b.funcs)\n\tvm.checkBindLexGlobal(b.lets)\n\tvm.checkBindLexGlobal(b.consts)\n\tvm.checkBindVarsGlobal(b.vars)\n\n\ts := &vm.r.global.stash\n\tfor _, name := range b.lets {\n\t\ts.createLexBinding(name, false)\n\t}\n\tfor _, name := range b.consts {\n\t\ts.createLexBinding(name, true)\n\t}\n\tvm.createGlobalFuncBindings(b.funcs, b.deletable)\n\tvm.createGlobalVarBindings(b.vars, b.deletable)\n\tvm.pc++\n}\n\ntype jne int32\n\nfunc (j jne) exec(vm *vm) {\n\tvm.sp--\n\tif !vm.stack[vm.sp].ToBoolean() {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.pc++\n\t}\n}\n\ntype jeq int32\n\nfunc (j jeq) exec(vm *vm) {\n\tvm.sp--\n\tif vm.stack[vm.sp].ToBoolean() {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.pc++\n\t}\n}\n\ntype jeq1 int32\n\nfunc (j jeq1) exec(vm *vm) {\n\tif vm.stack[vm.sp-1].ToBoolean() {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.sp--\n\t\tvm.pc++\n\t}\n}\n\ntype jneq1 int32\n\nfunc (j jneq1) exec(vm *vm) {\n\tif !vm.stack[vm.sp-1].ToBoolean() {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.sp--\n\t\tvm.pc++\n\t}\n}\n\ntype jdef int32\n\nfunc (j jdef) exec(vm *vm) {\n\tif vm.stack[vm.sp-1] != _undefined {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.sp--\n\t\tvm.pc++\n\t}\n}\n\ntype jdefP int32\n\nfunc (j jdefP) exec(vm *vm) {\n\tif vm.stack[vm.sp-1] != _undefined {\n\t\tvm.pc += int(j)\n\t} else {\n\t\tvm.pc++\n\t}\n\tvm.sp--\n}\n\ntype jopt int32\n\nfunc (j jopt) exec(vm *vm) {\n\tswitch vm.stack[vm.sp-1] {\n\tcase _null:\n\t\tvm.stack[vm.sp-1] = _undefined\n\t\tfallthrough\n\tcase _undefined:\n\t\tvm.pc += int(j)\n\tdefault:\n\t\tvm.pc++\n\t}\n}\n\ntype joptc int32\n\nfunc (j joptc) exec(vm *vm) {\n\tswitch vm.stack[vm.sp-1].(type) {\n\tcase valueNull, valueUndefined, memberUnresolved:\n\t\tvm.sp--\n\t\tvm.stack[vm.sp-1] = _undefined\n\t\tvm.pc += int(j)\n\tdefault:\n\t\tvm.pc++\n\t}\n}\n\ntype jcoalesc int32\n\nfunc (j jcoalesc) exec(vm *vm) {\n\tswitch vm.stack[vm.sp-1] {\n\tcase _undefined, _null:\n\t\tvm.sp--\n\t\tvm.pc++\n\tdefault:\n\t\tvm.pc += int(j)\n\t}\n}\n\ntype _not struct{}\n\nvar not _not\n\nfunc (_not) exec(vm *vm) {\n\tif vm.stack[vm.sp-1].ToBoolean() {\n\t\tvm.stack[vm.sp-1] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-1] = valueTrue\n\t}\n\tvm.pc++\n}\n\nfunc toPrimitiveNumber(v Value) Value {\n\tif o, ok := v.(*Object); ok {\n\t\treturn o.toPrimitiveNumber()\n\t}\n\treturn v\n}\n\nfunc toPrimitive(v Value) Value {\n\tif o, ok := v.(*Object); ok {\n\t\treturn o.toPrimitive()\n\t}\n\treturn v\n}\n\nfunc cmp(px, py Value) Value {\n\tvar ret bool\n\txs, isPxString := px.(String)\n\tys, isPyString := py.(String)\n\n\tif isPxString && isPyString {\n\t\tret = xs.CompareTo(ys) < 0\n\t\tgoto end\n\t} else {\n\t\tif px, ok := px.(*valueBigInt); ok && isPyString {\n\t\t\tny, err := stringToBigInt(ys.toTrimmedUTF8())\n\t\t\tif err != nil {\n\t\t\t\treturn _undefined\n\t\t\t}\n\t\t\tret = (*big.Int)(px).Cmp(ny) < 0\n\t\t\tgoto end\n\t\t}\n\t\tif py, ok := py.(*valueBigInt); ok && isPxString {\n\t\t\tnx, err := stringToBigInt(xs.toTrimmedUTF8())\n\t\t\tif err != nil {\n\t\t\t\treturn _undefined\n\t\t\t}\n\t\t\tret = nx.Cmp((*big.Int)(py)) < 0\n\t\t\tgoto end\n\t\t}\n\t}\n\n\tpx = toNumeric(px)\n\tpy = toNumeric(py)\n\n\tswitch nx := px.(type) {\n\tcase valueInt:\n\t\tswitch ny := py.(type) {\n\t\tcase valueInt:\n\t\t\tret = nx < ny\n\t\t\tgoto end\n\t\tcase *valueBigInt:\n\t\t\tret = big.NewInt(int64(nx)).Cmp((*big.Int)(ny)) < 0\n\t\t\tgoto end\n\t\t}\n\tcase valueFloat:\n\t\tswitch ny := py.(type) {\n\t\tcase *valueBigInt:\n\t\t\tswitch {\n\t\t\tcase math.IsNaN(float64(nx)):\n\t\t\t\treturn _undefined\n\t\t\tcase nx == _negativeInf:\n\t\t\t\tret = true\n\t\t\t\tgoto end\n\t\t\t}\n\t\t\tif nx := big.NewFloat(float64(nx)); nx.IsInt() {\n\t\t\t\tnx, _ := nx.Int(nil)\n\t\t\t\tret = nx.Cmp((*big.Int)(ny)) < 0\n\t\t\t} else {\n\t\t\t\tret = nx.Cmp(new(big.Float).SetInt((*big.Int)(ny))) < 0\n\t\t\t}\n\t\t\tgoto end\n\t\t}\n\tcase *valueBigInt:\n\t\tswitch ny := py.(type) {\n\t\tcase valueInt:\n\t\t\tret = (*big.Int)(nx).Cmp(big.NewInt(int64(ny))) < 0\n\t\t\tgoto end\n\t\tcase valueFloat:\n\t\t\tswitch {\n\t\t\tcase math.IsNaN(float64(ny)):\n\t\t\t\treturn _undefined\n\t\t\tcase ny == _positiveInf:\n\t\t\t\tret = true\n\t\t\t\tgoto end\n\t\t\t}\n\t\t\tif ny := big.NewFloat(float64(ny)); ny.IsInt() {\n\t\t\t\tny, _ := ny.Int(nil)\n\t\t\t\tret = (*big.Int)(nx).Cmp(ny) < 0\n\t\t\t} else {\n\t\t\t\tret = new(big.Float).SetInt((*big.Int)(nx)).Cmp(ny) < 0\n\t\t\t}\n\t\t\tgoto end\n\t\tcase *valueBigInt:\n\t\t\tret = (*big.Int)(nx).Cmp((*big.Int)(ny)) < 0\n\t\t\tgoto end\n\t\t}\n\t}\n\n\tif nx, ny := px.ToFloat(), py.ToFloat(); math.IsNaN(nx) || math.IsNaN(ny) {\n\t\treturn _undefined\n\t} else {\n\t\tret = nx < ny\n\t}\n\nend:\n\tif ret {\n\t\treturn valueTrue\n\t}\n\treturn valueFalse\n\n}\n\ntype _op_lt struct{}\n\nvar op_lt _op_lt\n\nfunc (_op_lt) exec(vm *vm) {\n\tleft := toPrimitiveNumber(vm.stack[vm.sp-2])\n\tright := toPrimitiveNumber(vm.stack[vm.sp-1])\n\n\tr := cmp(left, right)\n\tif r == _undefined {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = r\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_lte struct{}\n\nvar op_lte _op_lte\n\nfunc (_op_lte) exec(vm *vm) {\n\tleft := toPrimitiveNumber(vm.stack[vm.sp-2])\n\tright := toPrimitiveNumber(vm.stack[vm.sp-1])\n\n\tr := cmp(right, left)\n\tif r == _undefined || r == valueTrue {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t}\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_gt struct{}\n\nvar op_gt _op_gt\n\nfunc (_op_gt) exec(vm *vm) {\n\tleft := toPrimitiveNumber(vm.stack[vm.sp-2])\n\tright := toPrimitiveNumber(vm.stack[vm.sp-1])\n\n\tr := cmp(right, left)\n\tif r == _undefined {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = r\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_gte struct{}\n\nvar op_gte _op_gte\n\nfunc (_op_gte) exec(vm *vm) {\n\tleft := toPrimitiveNumber(vm.stack[vm.sp-2])\n\tright := toPrimitiveNumber(vm.stack[vm.sp-1])\n\n\tr := cmp(left, right)\n\tif r == _undefined || r == valueTrue {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t}\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_eq struct{}\n\nvar op_eq _op_eq\n\nfunc (_op_eq) exec(vm *vm) {\n\tif vm.stack[vm.sp-2].Equals(vm.stack[vm.sp-1]) {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_neq struct{}\n\nvar op_neq _op_neq\n\nfunc (_op_neq) exec(vm *vm) {\n\tif vm.stack[vm.sp-2].Equals(vm.stack[vm.sp-1]) {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_strict_eq struct{}\n\nvar op_strict_eq _op_strict_eq\n\nfunc (_op_strict_eq) exec(vm *vm) {\n\tif vm.stack[vm.sp-2].StrictEquals(vm.stack[vm.sp-1]) {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_strict_neq struct{}\n\nvar op_strict_neq _op_strict_neq\n\nfunc (_op_strict_neq) exec(vm *vm) {\n\tif vm.stack[vm.sp-2].StrictEquals(vm.stack[vm.sp-1]) {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_instanceof struct{}\n\nvar op_instanceof _op_instanceof\n\nfunc (_op_instanceof) exec(vm *vm) {\n\tleft := vm.stack[vm.sp-2]\n\tright := vm.r.toObject(vm.stack[vm.sp-1])\n\n\tif instanceOfOperator(left, right) {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t}\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _op_in struct{}\n\nvar op_in _op_in\n\nfunc (_op_in) exec(vm *vm) {\n\tleft := vm.stack[vm.sp-2]\n\tright := vm.r.toObject(vm.stack[vm.sp-1])\n\n\tif right.hasProperty(left) {\n\t\tvm.stack[vm.sp-2] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-2] = valueFalse\n\t}\n\n\tvm.sp--\n\tvm.pc++\n}\n\ntype try struct {\n\tcatchOffset   int32\n\tfinallyOffset int32\n}\n\nfunc (t try) exec(vm *vm) {\n\tvar catchPos, finallyPos int32\n\tif t.catchOffset > 0 {\n\t\tcatchPos = int32(vm.pc) + t.catchOffset\n\t} else {\n\t\tcatchPos = -1\n\t}\n\tif t.finallyOffset > 0 {\n\t\tfinallyPos = int32(vm.pc) + t.finallyOffset\n\t} else {\n\t\tfinallyPos = -1\n\t}\n\tvm.pushTryFrame(catchPos, finallyPos)\n\tvm.pc++\n}\n\ntype leaveTry struct{}\n\nfunc (leaveTry) exec(vm *vm) {\n\ttf := &vm.tryStack[len(vm.tryStack)-1]\n\tif tf.finallyPos >= 0 {\n\t\ttf.finallyRet = int32(vm.pc + 1)\n\t\tvm.pc = int(tf.finallyPos)\n\t\ttf.finallyPos = -1\n\t\ttf.catchPos = -1\n\t} else {\n\t\tvm.popTryFrame()\n\t\tvm.pc++\n\t}\n}\n\ntype enterFinally struct{}\n\nfunc (enterFinally) exec(vm *vm) {\n\ttf := &vm.tryStack[len(vm.tryStack)-1]\n\ttf.finallyPos = -1\n\tvm.pc++\n}\n\ntype leaveFinally struct{}\n\nfunc (leaveFinally) exec(vm *vm) {\n\ttf := &vm.tryStack[len(vm.tryStack)-1]\n\tex, ret := tf.exception, tf.finallyRet\n\ttf.exception = nil\n\tvm.popTryFrame()\n\tif ex != nil {\n\t\tvm.throw(ex)\n\t\treturn\n\t} else {\n\t\tif ret != -1 {\n\t\t\tvm.pc = int(ret)\n\t\t} else {\n\t\t\tvm.pc++\n\t\t}\n\t}\n}\n\ntype _throw struct{}\n\nvar throw _throw\n\nfunc (_throw) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tex := &Exception{\n\t\tval: v,\n\t}\n\n\tif o, ok := v.(*Object); ok {\n\t\tif e, ok := o.self.(*errorObject); ok {\n\t\t\tif len(e.stack) > 0 {\n\t\t\t\tex.stack = e.stack\n\t\t\t}\n\t\t}\n\t}\n\n\tif ex.stack == nil {\n\t\tex.stack = vm.captureStack(make([]StackFrame, 0, len(vm.callStack)+1), 0)\n\t}\n\n\tif ex = vm.handleThrow(ex); ex != nil {\n\t\tpanic(ex)\n\t}\n}\n\ntype _newVariadic struct{}\n\nvar newVariadic _newVariadic\n\nfunc (_newVariadic) exec(vm *vm) {\n\t_new(vm.countVariadicArgs() - 1).exec(vm)\n}\n\ntype _new uint32\n\nfunc (n _new) exec(vm *vm) {\n\tsp := vm.sp - int(n)\n\tobj := vm.stack[sp-1]\n\tctor := vm.r.toConstructor(obj)\n\tvm.stack[sp-1] = ctor(vm.stack[sp:vm.sp], nil)\n\tvm.sp = sp\n\tvm.pc++\n}\n\ntype superCall uint32\n\nfunc (s superCall) exec(vm *vm) {\n\tl := len(vm.refStack) - 1\n\tthisRef := vm.refStack[l]\n\tvm.refStack[l] = nil\n\tvm.refStack = vm.refStack[:l]\n\n\tobj := vm.r.toObject(vm.stack[vm.sb-1])\n\tvar cls *classFuncObject\n\tswitch fn := obj.self.(type) {\n\tcase *classFuncObject:\n\t\tcls = fn\n\tcase *arrowFuncObject:\n\t\tcls, _ = fn.funcObj.self.(*classFuncObject)\n\t}\n\tif cls == nil {\n\t\tvm.throw(vm.r.NewTypeError(\"wrong callee type for super()\"))\n\t\treturn\n\t}\n\tsp := vm.sp - int(s)\n\tnewTarget := vm.r.toObject(vm.newTarget)\n\tv := cls.createInstance(vm.stack[sp:vm.sp], newTarget)\n\tthisRef.set(v)\n\tvm.sp = sp\n\tcls._initFields(v)\n\tvm.push(v)\n\tvm.pc++\n}\n\ntype _superCallVariadic struct{}\n\nvar superCallVariadic _superCallVariadic\n\nfunc (_superCallVariadic) exec(vm *vm) {\n\tsuperCall(vm.countVariadicArgs()).exec(vm)\n}\n\ntype _loadNewTarget struct{}\n\nvar loadNewTarget _loadNewTarget\n\nfunc (_loadNewTarget) exec(vm *vm) {\n\tif t := vm.newTarget; t != nil {\n\t\tvm.push(t)\n\t} else {\n\t\tvm.push(_undefined)\n\t}\n\tvm.pc++\n}\n\ntype _typeof struct{}\n\nvar typeof _typeof\n\nfunc (_typeof) exec(vm *vm) {\n\tvar r Value\n\tswitch v := vm.stack[vm.sp-1].(type) {\n\tcase valueUndefined, valueUnresolved:\n\t\tr = stringUndefined\n\tcase valueNull:\n\t\tr = stringObjectC\n\tcase *Object:\n\t\tr = v.self.typeOf()\n\tcase valueBool:\n\t\tr = stringBoolean\n\tcase String:\n\t\tr = stringString\n\tcase valueInt, valueFloat:\n\t\tr = stringNumber\n\tcase *valueBigInt:\n\t\tr = stringBigInt\n\tcase *Symbol:\n\t\tr = stringSymbol\n\tdefault:\n\t\tpanic(newTypeError(\"Compiler bug: unknown type: %T\", v))\n\t}\n\tvm.stack[vm.sp-1] = r\n\tvm.pc++\n}\n\ntype createArgsMapped uint32\n\nfunc (formalArgs createArgsMapped) exec(vm *vm) {\n\tv := &Object{runtime: vm.r}\n\targs := &argumentsObject{}\n\targs.extensible = true\n\targs.prototype = vm.r.global.ObjectPrototype\n\targs.class = \"Arguments\"\n\tv.self = args\n\targs.val = v\n\targs.length = vm.args\n\targs.init()\n\ti := 0\n\tc := int(formalArgs)\n\tif vm.args < c {\n\t\tc = vm.args\n\t}\n\tfor ; i < c; i++ {\n\t\targs._put(unistring.String(strconv.Itoa(i)), &mappedProperty{\n\t\t\tvalueProperty: valueProperty{\n\t\t\t\twritable:     true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable:   true,\n\t\t\t},\n\t\t\tv: &vm.stash.values[i],\n\t\t})\n\t}\n\n\tfor _, v := range vm.stash.extraArgs {\n\t\targs._put(unistring.String(strconv.Itoa(i)), v)\n\t\ti++\n\t}\n\n\targs._putProp(\"callee\", vm.stack[vm.sb-1], true, false, true)\n\targs._putSym(SymIterator, valueProp(vm.r.getArrayValues(), true, false, true))\n\tvm.push(v)\n\tvm.pc++\n}\n\ntype createArgsUnmapped uint32\n\nfunc (formalArgs createArgsUnmapped) exec(vm *vm) {\n\targs := vm.r.newBaseObject(vm.r.global.ObjectPrototype, \"Arguments\")\n\ti := 0\n\tc := int(formalArgs)\n\tif vm.args < c {\n\t\tc = vm.args\n\t}\n\tfor _, v := range vm.stash.values[:c] {\n\t\targs._put(unistring.String(strconv.Itoa(i)), v)\n\t\ti++\n\t}\n\n\tfor _, v := range vm.stash.extraArgs {\n\t\targs._put(unistring.String(strconv.Itoa(i)), v)\n\t\ti++\n\t}\n\n\targs._putProp(\"length\", intToValue(int64(vm.args)), true, false, true)\n\targs._put(\"callee\", vm.r.newThrowerProperty(false))\n\targs._putSym(SymIterator, valueProp(vm.r.getArrayValues(), true, false, true))\n\tvm.push(args.val)\n\tvm.pc++\n}\n\ntype _enterWith struct{}\n\nvar enterWith _enterWith\n\nfunc (_enterWith) exec(vm *vm) {\n\tvm.newStash()\n\tvm.stash.obj = vm.stack[vm.sp-1].ToObject(vm.r)\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _leaveWith struct{}\n\nvar leaveWith _leaveWith\n\nfunc (_leaveWith) exec(vm *vm) {\n\tvm.stash = vm.stash.outer\n\tvm.pc++\n}\n\nfunc emptyIter() (propIterItem, iterNextFunc) {\n\treturn propIterItem{}, nil\n}\n\ntype _enumerate struct{}\n\nvar enumerate _enumerate\n\nfunc (_enumerate) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tif v == _undefined || v == _null {\n\t\tvm.iterStack = append(vm.iterStack, iterStackItem{f: emptyIter})\n\t} else {\n\t\tvm.iterStack = append(vm.iterStack, iterStackItem{f: enumerateRecursive(v.ToObject(vm.r))})\n\t}\n\tvm.sp--\n\tvm.pc++\n}\n\ntype enumNext int32\n\nfunc (jmp enumNext) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\titem, n := vm.iterStack[l].f()\n\tif n != nil {\n\t\tvm.iterStack[l].val = item.name\n\t\tvm.iterStack[l].f = n\n\t\tvm.pc++\n\t} else {\n\t\tvm.pc += int(jmp)\n\t}\n}\n\ntype _enumGet struct{}\n\nvar enumGet _enumGet\n\nfunc (_enumGet) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\tvm.push(vm.iterStack[l].val)\n\tvm.pc++\n}\n\ntype _enumPop struct{}\n\nvar enumPop _enumPop\n\nfunc (_enumPop) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\tvm.iterStack[l] = iterStackItem{}\n\tvm.iterStack = vm.iterStack[:l]\n\tvm.pc++\n}\n\ntype _enumPopClose struct{}\n\nvar enumPopClose _enumPopClose\n\nfunc (_enumPopClose) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\titem := vm.iterStack[l]\n\tvm.iterStack[l] = iterStackItem{}\n\tvm.iterStack = vm.iterStack[:l]\n\tif iter := item.iter; iter != nil {\n\t\titer.returnIter()\n\t}\n\tvm.pc++\n}\n\ntype _iterateP struct{}\n\nvar iterateP _iterateP\n\nfunc (_iterateP) exec(vm *vm) {\n\titer := vm.r.getIterator(vm.stack[vm.sp-1], nil)\n\tvm.iterStack = append(vm.iterStack, iterStackItem{iter: iter})\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _iterate struct{}\n\nvar iterate _iterate\n\nfunc (_iterate) exec(vm *vm) {\n\titer := vm.r.getIterator(vm.stack[vm.sp-1], nil)\n\tvm.iterStack = append(vm.iterStack, iterStackItem{iter: iter})\n\tvm.pc++\n}\n\ntype iterNext int32\n\nfunc (jmp iterNext) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\titer := vm.iterStack[l].iter\n\tvalue, ex := iter.step()\n\tif ex == nil {\n\t\tif value == nil {\n\t\t\tvm.pc += int(jmp)\n\t\t} else {\n\t\t\tvm.iterStack[l].val = value\n\t\t\tvm.pc++\n\t\t}\n\t} else {\n\t\tl := len(vm.iterStack) - 1\n\t\tvm.iterStack[l] = iterStackItem{}\n\t\tvm.iterStack = vm.iterStack[:l]\n\t\tvm.throw(ex.val)\n\t\treturn\n\t}\n}\n\ntype iterGetNextOrUndef struct{}\n\nfunc (iterGetNextOrUndef) exec(vm *vm) {\n\tl := len(vm.iterStack) - 1\n\titer := vm.iterStack[l].iter\n\tvar value Value\n\tif iter.iterator != nil {\n\t\tvar ex *Exception\n\t\tvalue, ex = iter.step()\n\t\tif ex != nil {\n\t\t\tl := len(vm.iterStack) - 1\n\t\t\tvm.iterStack[l] = iterStackItem{}\n\t\t\tvm.iterStack = vm.iterStack[:l]\n\t\t\tvm.throw(ex.val)\n\t\t\treturn\n\t\t}\n\t}\n\tvm.push(nilSafe(value))\n\tvm.pc++\n}\n\ntype copyStash struct{}\n\nfunc (copyStash) exec(vm *vm) {\n\toldStash := vm.stash\n\tnewStash := &stash{\n\t\touter: oldStash.outer,\n\t}\n\tvm.stashAllocs++\n\tnewStash.values = append([]Value(nil), oldStash.values...)\n\tnewStash.names = oldStash.names\n\tvm.stash = newStash\n\tvm.pc++\n}\n\ntype _throwAssignToConst struct{}\n\nvar throwAssignToConst _throwAssignToConst\n\nfunc (_throwAssignToConst) exec(vm *vm) {\n\tvm.throw(errAssignToConst)\n}\n\nfunc (r *Runtime) copyDataProperties(target, source Value) {\n\ttargetObj := r.toObject(target)\n\tif source == _null || source == _undefined {\n\t\treturn\n\t}\n\tsourceObj := source.ToObject(r)\n\tfor item, next := iterateEnumerableProperties(sourceObj)(); next != nil; item, next = next() {\n\t\tcreateDataPropertyOrThrow(targetObj, item.name, item.value)\n\t}\n}\n\ntype _copySpread struct{}\n\nvar copySpread _copySpread\n\nfunc (_copySpread) exec(vm *vm) {\n\tvm.r.copyDataProperties(vm.stack[vm.sp-2], vm.stack[vm.sp-1])\n\tvm.sp--\n\tvm.pc++\n}\n\ntype _copyRest struct{}\n\nvar copyRest _copyRest\n\nfunc (_copyRest) exec(vm *vm) {\n\tvm.push(vm.r.NewObject())\n\tvm.r.copyDataProperties(vm.stack[vm.sp-1], vm.stack[vm.sp-2])\n\tvm.pc++\n}\n\ntype _createDestructSrc struct{}\n\nvar createDestructSrc _createDestructSrc\n\nfunc (_createDestructSrc) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tvm.r.checkObjectCoercible(v)\n\tvm.push(vm.r.newDestructKeyedSource(v))\n\tvm.pc++\n}\n\ntype _checkObjectCoercible struct{}\n\nvar checkObjectCoercible _checkObjectCoercible\n\nfunc (_checkObjectCoercible) exec(vm *vm) {\n\tvm.r.checkObjectCoercible(vm.stack[vm.sp-1])\n\tvm.pc++\n}\n\ntype createArgsRestStack int\n\nfunc (n createArgsRestStack) exec(vm *vm) {\n\tvar values []Value\n\tdelta := vm.args - int(n)\n\tif delta > 0 {\n\t\tvalues = make([]Value, delta)\n\t\tcopy(values, vm.stack[vm.sb+int(n)+1:])\n\t}\n\tvm.push(vm.r.newArrayValues(values))\n\tvm.pc++\n}\n\ntype _createArgsRestStash struct{}\n\nvar createArgsRestStash _createArgsRestStash\n\nfunc (_createArgsRestStash) exec(vm *vm) {\n\tvm.push(vm.r.newArrayValues(vm.stash.extraArgs))\n\tvm.stash.extraArgs = nil\n\tvm.pc++\n}\n\ntype concatStrings int\n\nfunc (n concatStrings) exec(vm *vm) {\n\tstrs := vm.stack[vm.sp-int(n) : vm.sp]\n\tlength := 0\n\tallAscii := true\n\tfor i, s := range strs {\n\t\tswitch s := s.(type) {\n\t\tcase asciiString:\n\t\t\tlength += s.Length()\n\t\tcase unicodeString:\n\t\t\tlength += s.Length()\n\t\t\tallAscii = false\n\t\tcase *importedString:\n\t\t\ts.ensureScanned()\n\t\t\tif s.u != nil {\n\t\t\t\tstrs[i] = s.u\n\t\t\t\tlength += s.u.Length()\n\t\t\t\tallAscii = false\n\t\t\t} else {\n\t\t\t\tstrs[i] = asciiString(s.s)\n\t\t\t\tlength += len(s.s)\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(unknownStringTypeErr(s))\n\t\t}\n\t}\n\n\tvm.sp -= int(n) - 1\n\tif allAscii {\n\t\tvar buf strings.Builder\n\t\tbuf.Grow(length)\n\t\tfor _, s := range strs {\n\t\t\tbuf.WriteString(string(s.(asciiString)))\n\t\t}\n\t\tvm.stack[vm.sp-1] = asciiString(buf.String())\n\t} else {\n\t\tvar buf unicodeStringBuilder\n\t\tbuf.ensureStarted(length)\n\t\tfor _, s := range strs {\n\t\t\tbuf.writeString(s.(String))\n\t\t}\n\t\tvm.stack[vm.sp-1] = buf.String()\n\t}\n\tvm.pc++\n}\n\ntype getTaggedTmplObject struct {\n\traw, cooked []Value\n}\n\n// As tagged template objects are not cached (because it's hard to ensure the cache is cleaned without using\n// finalizers) this wrapper is needed to override the equality method so that two objects for the same template\n// literal appeared to be equal from the code's point of view.\ntype taggedTemplateArray struct {\n\t*arrayObject\n\tidPtr *[]Value\n}\n\nfunc (a *taggedTemplateArray) equal(other objectImpl) bool {\n\tif o, ok := other.(*taggedTemplateArray); ok {\n\t\treturn a.idPtr == o.idPtr\n\t}\n\treturn false\n}\n\nfunc (c *getTaggedTmplObject) exec(vm *vm) {\n\tcooked := vm.r.newArrayObject()\n\tsetArrayValues(cooked, c.cooked)\n\traw := vm.r.newArrayObject()\n\tsetArrayValues(raw, c.raw)\n\n\tcooked.propValueCount = len(c.cooked)\n\tcooked.lengthProp.writable = false\n\n\traw.propValueCount = len(c.raw)\n\traw.lengthProp.writable = false\n\n\traw.preventExtensions(true)\n\traw.val.self = &taggedTemplateArray{\n\t\tarrayObject: raw,\n\t\tidPtr:       &c.raw,\n\t}\n\n\tcooked._putProp(\"raw\", raw.val, false, false, false)\n\tcooked.preventExtensions(true)\n\tcooked.val.self = &taggedTemplateArray{\n\t\tarrayObject: cooked,\n\t\tidPtr:       &c.cooked,\n\t}\n\n\tvm.push(cooked.val)\n\tvm.pc++\n}\n\ntype _loadSuper struct{}\n\nvar loadSuper _loadSuper\n\nfunc (_loadSuper) exec(vm *vm) {\n\thomeObject := getHomeObject(vm.stack[vm.sb-1])\n\tif proto := homeObject.Prototype(); proto != nil {\n\t\tvm.push(proto)\n\t} else {\n\t\tvm.push(_undefined)\n\t}\n\tvm.pc++\n}\n\ntype newClass struct {\n\tctor       *Program\n\tname       unistring.String\n\tsource     string\n\tinitFields *Program\n\n\tprivateFields, privateMethods       []unistring.String // only set when dynamic resolution is needed\n\tnumPrivateFields, numPrivateMethods uint32\n\n\tlength        int\n\thasPrivateEnv bool\n}\n\ntype newDerivedClass struct {\n\tnewClass\n}\n\nfunc (vm *vm) createPrivateType(f *classFuncObject, numFields, numMethods uint32) {\n\ttyp := &privateEnvType{}\n\ttyp.numFields = numFields\n\ttyp.numMethods = numMethods\n\tf.privateEnvType = typ\n\tf.privateMethods = make([]Value, numMethods)\n}\n\nfunc (vm *vm) fillPrivateNamesMap(typ *privateEnvType, privateFields, privateMethods []unistring.String) {\n\tif len(privateFields) > 0 || len(privateMethods) > 0 {\n\t\tpenv := vm.privEnv.names\n\t\tif penv == nil {\n\t\t\tpenv = make(privateNames)\n\t\t\tvm.privEnv.names = penv\n\t\t}\n\t\tfor idx, field := range privateFields {\n\t\t\tpenv[field] = &privateId{\n\t\t\t\ttyp: typ,\n\t\t\t\tidx: uint32(idx),\n\t\t\t}\n\t\t}\n\t\tfor idx, method := range privateMethods {\n\t\t\tpenv[method] = &privateId{\n\t\t\t\ttyp:      typ,\n\t\t\t\tidx:      uint32(idx),\n\t\t\t\tisMethod: true,\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *newClass) create(protoParent, ctorParent *Object, vm *vm, derived bool) (prototype, cls *Object) {\n\tproto := vm.r.newBaseObject(protoParent, classObject)\n\tf := vm.r.newClassFunc(c.name, c.length, ctorParent, derived)\n\tf._putProp(\"prototype\", proto.val, false, false, false)\n\tproto._putProp(\"constructor\", f.val, true, false, true)\n\tf.prg = c.ctor\n\tf.stash = vm.stash\n\tf.src = c.source\n\tf.initFields = c.initFields\n\tif c.hasPrivateEnv {\n\t\tvm.privEnv = &privateEnv{\n\t\t\touter: vm.privEnv,\n\t\t}\n\t\tvm.createPrivateType(f, c.numPrivateFields, c.numPrivateMethods)\n\t\tvm.fillPrivateNamesMap(f.privateEnvType, c.privateFields, c.privateMethods)\n\t\tvm.privEnv.instanceType = f.privateEnvType\n\t}\n\tf.privEnv = vm.privEnv\n\treturn proto.val, f.val\n}\n\nfunc (c *newClass) exec(vm *vm) {\n\tproto, cls := c.create(vm.r.global.ObjectPrototype, vm.r.getFunctionPrototype(), vm, false)\n\tsp := vm.sp\n\tvm.stack.expand(sp + 1)\n\tvm.stack[sp] = proto\n\tvm.stack[sp+1] = cls\n\tvm.sp = sp + 2\n\tvm.pc++\n}\n\nfunc (c *newDerivedClass) exec(vm *vm) {\n\tvar protoParent *Object\n\tvar superClass *Object\n\tif o := vm.stack[vm.sp-1]; o != _null {\n\t\tif sc, ok := o.(*Object); !ok || sc.self.assertConstructor() == nil {\n\t\t\tvm.throw(vm.r.NewTypeError(\"Class extends value is not a constructor or null\"))\n\t\t\treturn\n\t\t} else {\n\t\t\tv := sc.self.getStr(\"prototype\", nil)\n\t\t\tif v != _null {\n\t\t\t\tif o, ok := v.(*Object); ok {\n\t\t\t\t\tprotoParent = o\n\t\t\t\t} else {\n\t\t\t\t\tvm.throw(vm.r.NewTypeError(\"Class extends value does not have valid prototype property\"))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperClass = sc\n\t\t}\n\t} else {\n\t\tsuperClass = vm.r.getFunctionPrototype()\n\t}\n\n\tproto, cls := c.create(protoParent, superClass, vm, true)\n\tvm.stack[vm.sp-1] = proto\n\tvm.push(cls)\n\tvm.pc++\n}\n\n// Creates a special instance of *classFuncObject which is only used during evaluation of a class declaration\n// to initialise static fields and instance private methods of another class.\ntype newStaticFieldInit struct {\n\tinitFields                          *Program\n\tnumPrivateFields, numPrivateMethods uint32\n}\n\nfunc (c *newStaticFieldInit) exec(vm *vm) {\n\tf := vm.r.newClassFunc(\"\", 0, vm.r.getFunctionPrototype(), false)\n\tif c.numPrivateFields > 0 || c.numPrivateMethods > 0 {\n\t\tvm.createPrivateType(f, c.numPrivateFields, c.numPrivateMethods)\n\t}\n\tf.initFields = c.initFields\n\tf.stash = vm.stash\n\tvm.push(f.val)\n\tvm.pc++\n}\n\nfunc (vm *vm) loadThis(v Value) {\n\tif v != nil {\n\t\tvm.push(v)\n\t} else {\n\t\tvm.throw(vm.r.newError(vm.r.getReferenceError(), \"Must call super constructor in derived class before accessing 'this'\"))\n\t\treturn\n\t}\n\tvm.pc++\n}\n\ntype loadThisStash uint32\n\nfunc (l loadThisStash) exec(vm *vm) {\n\tvm.loadThis(*vm.getStashPtr(uint32(l)))\n}\n\ntype loadThisStack struct{}\n\nfunc (loadThisStack) exec(vm *vm) {\n\tvm.loadThis(vm.stack[vm.sb])\n}\n\nfunc (vm *vm) getStashPtr(s uint32) *Value {\n\tlevel := int(s) >> 24\n\tidx := s & 0x00FFFFFF\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\n\treturn &stash.values[idx]\n}\n\ntype getThisDynamic struct{}\n\nfunc (getThisDynamic) exec(vm *vm) {\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif stash.obj == nil {\n\t\t\tif v, exists := stash.getByName(thisBindingName); exists {\n\t\t\t\tvm.push(v)\n\t\t\t\tvm.pc++\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tvm.push(vm.r.globalObject)\n\tvm.pc++\n}\n\ntype throwConst struct {\n\tv interface{}\n}\n\nfunc (t throwConst) exec(vm *vm) {\n\tvm.throw(t.v)\n}\n\ntype resolveThisStack struct{}\n\nfunc (r resolveThisStack) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &thisRef{v: (*[]Value)(&vm.stack), idx: vm.sb})\n\tvm.pc++\n}\n\ntype resolveThisStash uint32\n\nfunc (r resolveThisStash) exec(vm *vm) {\n\tlevel := int(r) >> 24\n\tidx := r & 0x00FFFFFF\n\tstash := vm.stash\n\tfor i := 0; i < level; i++ {\n\t\tstash = stash.outer\n\t}\n\tvm.refStack = append(vm.refStack, &thisRef{v: &stash.values, idx: int(idx)})\n\tvm.pc++\n}\n\ntype resolveThisDynamic struct{}\n\nfunc (resolveThisDynamic) exec(vm *vm) {\n\tfor stash := vm.stash; stash != nil; stash = stash.outer {\n\t\tif stash.obj == nil {\n\t\t\tif idx, exists := stash.names[thisBindingName]; exists {\n\t\t\t\tvm.refStack = append(vm.refStack, &thisRef{v: &stash.values, idx: int(idx &^ maskTyp)})\n\t\t\t\tvm.pc++\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tpanic(vm.r.newError(vm.r.getReferenceError(), \"Compiler bug: 'this' reference is not found in resolveThisDynamic\"))\n}\n\ntype defineComputedKey int\n\nfunc (offset defineComputedKey) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-int(offset)])\n\tif h, ok := obj.self.(*classFuncObject); ok {\n\t\tkey := toPropertyKey(vm.stack[vm.sp-1])\n\t\th.computedKeys = append(h.computedKeys, key)\n\t\tvm.sp--\n\t\tvm.pc++\n\t\treturn\n\t}\n\tpanic(vm.r.NewTypeError(\"Compiler bug: unexpected target for defineComputedKey: %v\", obj))\n}\n\ntype loadComputedKey int\n\nfunc (idx loadComputedKey) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sb-1])\n\tif h, ok := obj.self.(*classFuncObject); ok {\n\t\tvm.push(h.computedKeys[idx])\n\t\tvm.pc++\n\t\treturn\n\t}\n\tpanic(vm.r.NewTypeError(\"Compiler bug: unexpected target for loadComputedKey: %v\", obj))\n}\n\ntype initStaticElements struct {\n\tprivateFields, privateMethods []unistring.String\n}\n\nfunc (i *initStaticElements) exec(vm *vm) {\n\tcls := vm.stack[vm.sp-1]\n\tstaticInit := vm.r.toObject(vm.stack[vm.sp-3])\n\tvm.sp -= 2\n\tif h, ok := staticInit.self.(*classFuncObject); ok {\n\t\th._putProp(\"prototype\", cls, true, true, true) // so that 'super' resolution work\n\t\th.privEnv = vm.privEnv\n\t\tif h.privateEnvType != nil {\n\t\t\tvm.privEnv.staticType = h.privateEnvType\n\t\t\tvm.fillPrivateNamesMap(h.privateEnvType, i.privateFields, i.privateMethods)\n\t\t}\n\t\th._initFields(vm.r.toObject(cls))\n\t\tvm.stack[vm.sp-1] = cls\n\n\t\tvm.pc++\n\t\treturn\n\t}\n\tpanic(vm.r.NewTypeError(\"Compiler bug: unexpected target for initStaticElements: %v\", staticInit))\n}\n\ntype definePrivateMethod struct {\n\tidx          int\n\ttargetOffset int\n}\n\nfunc (d *definePrivateMethod) getPrivateMethods(vm *vm) []Value {\n\tobj := vm.r.toObject(vm.stack[vm.sp-d.targetOffset])\n\tif cls, ok := obj.self.(*classFuncObject); ok {\n\t\treturn cls.privateMethods\n\t} else {\n\t\tpanic(vm.r.NewTypeError(\"Compiler bug: wrong target type for definePrivateMethod: %T\", obj.self))\n\t}\n}\n\nfunc (d *definePrivateMethod) exec(vm *vm) {\n\tmethods := d.getPrivateMethods(vm)\n\tmethods[d.idx] = vm.stack[vm.sp-1]\n\tvm.sp--\n\tvm.pc++\n}\n\ntype definePrivateGetter struct {\n\tdefinePrivateMethod\n}\n\nfunc (d *definePrivateGetter) exec(vm *vm) {\n\tmethods := d.getPrivateMethods(vm)\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\tp, _ := methods[d.idx].(*valueProperty)\n\tif p == nil {\n\t\tp = &valueProperty{\n\t\t\taccessor: true,\n\t\t}\n\t\tmethods[d.idx] = p\n\t}\n\tif p.getterFunc != nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Private getter has already been declared\"))\n\t\treturn\n\t}\n\tp.getterFunc = method\n\tvm.sp--\n\tvm.pc++\n}\n\ntype definePrivateSetter struct {\n\tdefinePrivateMethod\n}\n\nfunc (d *definePrivateSetter) exec(vm *vm) {\n\tmethods := d.getPrivateMethods(vm)\n\tval := vm.stack[vm.sp-1]\n\tmethod := vm.r.toObject(val)\n\tp, _ := methods[d.idx].(*valueProperty)\n\tif p == nil {\n\t\tp = &valueProperty{\n\t\t\taccessor: true,\n\t\t}\n\t\tmethods[d.idx] = p\n\t}\n\tif p.setterFunc != nil {\n\t\tvm.throw(vm.r.NewTypeError(\"Private setter has already been declared\"))\n\t\treturn\n\t}\n\tp.setterFunc = method\n\tvm.sp--\n\tvm.pc++\n}\n\ntype definePrivateProp struct {\n\tidx int\n}\n\nfunc (d *definePrivateProp) exec(vm *vm) {\n\tf := vm.r.toObject(vm.stack[vm.sb-1]).self.(*classFuncObject)\n\tobj := vm.r.toObject(vm.stack[vm.sp-2])\n\tpenv := obj.self.getPrivateEnv(f.privateEnvType, false)\n\tpenv.fields[d.idx] = vm.stack[vm.sp-1]\n\tvm.sp--\n\tvm.pc++\n}\n\ntype getPrivatePropRes resolvedPrivateName\n\nfunc (vm *vm) getPrivateType(level uint8, isStatic bool) *privateEnvType {\n\te := vm.privEnv\n\tfor i := uint8(0); i < level; i++ {\n\t\te = e.outer\n\t}\n\tif isStatic {\n\t\treturn e.staticType\n\t}\n\treturn e.instanceType\n}\n\nfunc (g *getPrivatePropRes) _get(base Value, vm *vm) Value {\n\treturn vm.getPrivateProp(base, g.name, vm.getPrivateType(g.level, g.isStatic), g.idx, g.isMethod)\n}\n\nfunc (g *getPrivatePropRes) exec(vm *vm) {\n\tvm.stack[vm.sp-1] = g._get(vm.stack[vm.sp-1], vm)\n\tvm.pc++\n}\n\ntype getPrivatePropId privateId\n\nfunc (g *getPrivatePropId) exec(vm *vm) {\n\tvm.stack[vm.sp-1] = vm.getPrivateProp(vm.stack[vm.sp-1], g.name, g.typ, g.idx, g.isMethod)\n\tvm.pc++\n}\n\ntype getPrivatePropIdCallee privateId\n\nfunc (g *getPrivatePropIdCallee) exec(vm *vm) {\n\tprop := vm.getPrivateProp(vm.stack[vm.sp-1], g.name, g.typ, g.idx, g.isMethod)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: (*privateId)(g).string()}}\n\t}\n\tvm.push(prop)\n\n\tvm.pc++\n}\n\nfunc (vm *vm) getPrivateProp(base Value, name unistring.String, typ *privateEnvType, idx uint32, isMethod bool) Value {\n\tobj := vm.r.toObject(base)\n\tpenv := obj.self.getPrivateEnv(typ, false)\n\tvar v Value\n\tif penv != nil {\n\t\tif isMethod {\n\t\t\tv = penv.methods[idx]\n\t\t} else {\n\t\t\tv = penv.fields[idx]\n\t\t\tif v == nil {\n\t\t\t\tpanic(vm.r.NewTypeError(\"Private member #%s is accessed before it is initialized\", name))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpanic(vm.r.NewTypeError(\"Cannot read private member #%s from an object whose class did not declare it\", name))\n\t}\n\tif prop, ok := v.(*valueProperty); ok {\n\t\tif prop.getterFunc == nil {\n\t\t\tpanic(vm.r.NewTypeError(\"'#%s' was defined without a getter\", name))\n\t\t}\n\t\tv = prop.get(obj)\n\t}\n\treturn v\n}\n\ntype getPrivatePropResCallee getPrivatePropRes\n\nfunc (g *getPrivatePropResCallee) exec(vm *vm) {\n\tprop := (*getPrivatePropRes)(g)._get(vm.stack[vm.sp-1], vm)\n\tif prop == nil {\n\t\tprop = memberUnresolved{valueUnresolved{r: vm.r, ref: (*resolvedPrivateName)(g).string()}}\n\t}\n\tvm.push(prop)\n\n\tvm.pc++\n}\n\nfunc (vm *vm) setPrivateProp(base Value, name unistring.String, typ *privateEnvType, idx uint32, isMethod bool, val Value) {\n\tobj := vm.r.toObject(base)\n\tpenv := obj.self.getPrivateEnv(typ, false)\n\tif penv != nil {\n\t\tif isMethod {\n\t\t\tv := penv.methods[idx]\n\t\t\tif prop, ok := v.(*valueProperty); ok {\n\t\t\t\tif prop.setterFunc != nil {\n\t\t\t\t\tprop.set(base, val)\n\t\t\t\t} else {\n\t\t\t\t\tpanic(vm.r.NewTypeError(\"Cannot assign to read only property '#%s'\", name))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(vm.r.NewTypeError(\"Private method '#%s' is not writable\", name))\n\t\t\t}\n\t\t} else {\n\t\t\tptr := &penv.fields[idx]\n\t\t\tif *ptr == nil {\n\t\t\t\tpanic(vm.r.NewTypeError(\"Private member #%s is accessed before it is initialized\", name))\n\t\t\t}\n\t\t\t*ptr = val\n\t\t}\n\t} else {\n\t\tpanic(vm.r.NewTypeError(\"Cannot write private member #%s from an object whose class did not declare it\", name))\n\t}\n}\n\nfunc (vm *vm) exceptionFromValue(x interface{}) *Exception {\n\tvar ex *Exception\n\tswitch x1 := x.(type) {\n\tcase *Object:\n\t\tex = &Exception{\n\t\t\tval: x1,\n\t\t}\n\t\tif er, ok := x1.self.(*errorObject); ok {\n\t\t\tex.stack = er.stack\n\t\t}\n\tcase Value:\n\t\tex = &Exception{\n\t\t\tval: x1,\n\t\t}\n\tcase *Exception:\n\t\tex = x1\n\tcase typeError:\n\t\tex = &Exception{\n\t\t\tval: vm.r.NewTypeError(string(x1)),\n\t\t}\n\tcase referenceError:\n\t\tex = &Exception{\n\t\t\tval: vm.r.newError(vm.r.getReferenceError(), string(x1)),\n\t\t}\n\tcase rangeError:\n\t\tex = &Exception{\n\t\t\tval: vm.r.newError(vm.r.getRangeError(), string(x1)),\n\t\t}\n\tcase syntaxError:\n\t\tex = &Exception{\n\t\t\tval: vm.r.newError(vm.r.getSyntaxError(), string(x1)),\n\t\t}\n\tdefault:\n\t\t/*\n\t\t\tif vm.prg != nil {\n\t\t\t\tvm.prg.dumpCode(log.Printf)\n\t\t\t}\n\t\t\tlog.Print(\"Stack: \", string(debug.Stack()))\n\t\t\tpanic(fmt.Errorf(\"Panic at %d: %v\", vm.pc, x))\n\t\t*/\n\t\treturn nil\n\t}\n\tif ex.stack == nil {\n\t\tex.stack = vm.captureStack(make([]StackFrame, 0, len(vm.callStack)+1), 0)\n\t}\n\treturn ex\n}\n\ntype setPrivatePropRes resolvedPrivateName\n\nfunc (p *setPrivatePropRes) _set(base Value, val Value, vm *vm) {\n\tvm.setPrivateProp(base, p.name, vm.getPrivateType(p.level, p.isStatic), p.idx, p.isMethod, val)\n}\n\nfunc (p *setPrivatePropRes) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tp._set(vm.stack[vm.sp-2], v, vm)\n\tvm.stack[vm.sp-2] = v\n\tvm.sp--\n\tvm.pc++\n}\n\ntype setPrivatePropResP setPrivatePropRes\n\nfunc (p *setPrivatePropResP) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\t(*setPrivatePropRes)(p)._set(vm.stack[vm.sp-2], v, vm)\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype setPrivatePropId privateId\n\nfunc (p *setPrivatePropId) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tvm.setPrivateProp(vm.stack[vm.sp-2], p.name, p.typ, p.idx, p.isMethod, v)\n\tvm.stack[vm.sp-2] = v\n\tvm.sp--\n\tvm.pc++\n}\n\ntype setPrivatePropIdP privateId\n\nfunc (p *setPrivatePropIdP) exec(vm *vm) {\n\tv := vm.stack[vm.sp-1]\n\tvm.setPrivateProp(vm.stack[vm.sp-2], p.name, p.typ, p.idx, p.isMethod, v)\n\tvm.sp -= 2\n\tvm.pc++\n}\n\ntype popPrivateEnv struct{}\n\nfunc (popPrivateEnv) exec(vm *vm) {\n\tvm.privEnv = vm.privEnv.outer\n\tvm.pc++\n}\n\ntype privateInRes resolvedPrivateName\n\nfunc (i *privateInRes) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-1])\n\tpe := obj.self.getPrivateEnv(vm.getPrivateType(i.level, i.isStatic), false)\n\tif pe != nil && (i.isMethod && pe.methods[i.idx] != nil || !i.isMethod && pe.fields[i.idx] != nil) {\n\t\tvm.stack[vm.sp-1] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-1] = valueFalse\n\t}\n\tvm.pc++\n}\n\ntype privateInId privateId\n\nfunc (i *privateInId) exec(vm *vm) {\n\tobj := vm.r.toObject(vm.stack[vm.sp-1])\n\tpe := obj.self.getPrivateEnv(i.typ, false)\n\tif pe != nil && (i.isMethod && pe.methods[i.idx] != nil || !i.isMethod && pe.fields[i.idx] != nil) {\n\t\tvm.stack[vm.sp-1] = valueTrue\n\t} else {\n\t\tvm.stack[vm.sp-1] = valueFalse\n\t}\n\tvm.pc++\n}\n\ntype getPrivateRefRes resolvedPrivateName\n\nfunc (r *getPrivateRefRes) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &privateRefRes{\n\t\tbase: vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tname: (*resolvedPrivateName)(r),\n\t})\n\tvm.sp--\n\tvm.pc++\n}\n\ntype getPrivateRefId privateId\n\nfunc (r *getPrivateRefId) exec(vm *vm) {\n\tvm.refStack = append(vm.refStack, &privateRefId{\n\t\tbase: vm.stack[vm.sp-1].ToObject(vm.r),\n\t\tid:   (*privateId)(r),\n\t})\n\tvm.sp--\n\tvm.pc++\n}\n\nfunc (y *yieldMarker) exec(vm *vm) {\n\tvm.pc = -vm.pc // this will terminate the run loop\n\tvm.push(y)     // marker so the caller knows it's a yield, not a return\n}\n\nfunc (y *yieldMarker) String() string {\n\tif y == yieldEmpty {\n\t\treturn \"empty\"\n\t}\n\tswitch y.resultType {\n\tcase resultYield:\n\t\treturn \"yield\"\n\tcase resultYieldRes:\n\t\treturn \"yieldRes\"\n\tcase resultYieldDelegate:\n\t\treturn \"yield*\"\n\tcase resultYieldDelegateRes:\n\t\treturn \"yield*Res\"\n\tcase resultAwait:\n\t\treturn \"await\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n"
        },
        {
          "name": "vm_test.go",
          "type": "blob",
          "size": 4.5927734375,
          "content": "package goja\n\nimport (\n\t\"github.com/dop251/goja/file\"\n\t\"github.com/dop251/goja/parser\"\n\t\"github.com/dop251/goja/unistring\"\n\t\"testing\"\n)\n\nfunc TestTaggedTemplateArgExport(t *testing.T) {\n\tvm := New()\n\tvm.Set(\"f\", func(v Value) {\n\t\tv.Export()\n\t})\n\tvm.RunString(\"f`test`\")\n}\n\nfunc TestVM1(t *testing.T) {\n\tr := &Runtime{}\n\tr.init()\n\n\tvm := r.vm\n\n\tvm.prg = &Program{\n\t\tsrc: file.NewFile(\"dummy\", \"\", 1),\n\t\tcode: []instruction{\n\t\t\t&bindGlobal{vars: []unistring.String{\"v\"}},\n\t\t\tnewObject,\n\t\t\tsetGlobal(\"v\"),\n\t\t\tloadVal{asciiString(\"test\")},\n\t\t\tloadVal{valueInt(3)},\n\t\t\tloadVal{valueInt(2)},\n\t\t\tadd,\n\t\t\tsetElem,\n\t\t\tpop,\n\t\t\tloadDynamic(\"v\"),\n\t\t},\n\t}\n\n\tvm.run()\n\n\trv := vm.pop()\n\n\tif obj, ok := rv.(*Object); ok {\n\t\tif v := obj.self.getStr(\"test\", nil).ToInteger(); v != 5 {\n\t\t\tt.Fatalf(\"Unexpected property value: %v\", v)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"Unexpected result: %v\", rv)\n\t}\n\n}\n\nfunc TestEvalVar(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction test() {\n\t\tvar a;\n\t\treturn eval(\"var a = 'yes'; var z = 'no'; a;\") === \"yes\" && a === \"yes\";\n\t}\n\ttest();\n\t`\n\n\ttestScript(SCRIPT, valueTrue, t)\n}\n\nfunc TestResolveMixedStack1(t *testing.T) {\n\tconst SCRIPT = `\n\tfunction test(arg) {\n\t\tvar a = 1;\n\t\tvar scope = {};\n\t\t(function() {return arg})(); // move arguments to stash\n\t\twith (scope) {\n\t\t\ta++; // resolveMixedStack1 here\n\t\t\treturn a + arg;\n\t\t}\n\t}\n\ttest(40);\n\t`\n\n\ttestScript(SCRIPT, valueInt(42), t)\n}\n\nfunc TestNewArrayFromIterClosed(t *testing.T) {\n\tconst SCRIPT = `\n\tconst [a, ...other] = [];\n\tassert.sameValue(a, undefined);\n\tassert(Array.isArray(other));\n\tassert.sameValue(other.length, 0);\n\t`\n\ttestScriptWithTestLib(SCRIPT, _undefined, t)\n}\n\nfunc BenchmarkVmNOP2(b *testing.B) {\n\tprg := []func(*vm){\n\t\t//loadVal(0).exec,\n\t\t//loadVal(1).exec,\n\t\t//add.exec,\n\t\tjump(1).exec,\n\t}\n\n\tr := &Runtime{}\n\tr.init()\n\n\tvm := r.vm\n\tvm.prg = &Program{}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.pc = 0\n\t\tfor !vm.halted() {\n\t\t\tprg[vm.pc](vm)\n\t\t}\n\t\t//vm.sp--\n\t\t/*r := vm.pop()\n\t\tif r.ToInteger() != 5 {\n\t\t\tb.Fatalf(\"Unexpected result: %+v\", r)\n\t\t}\n\t\tif vm.sp != 0 {\n\t\t\tb.Fatalf(\"Unexpected sp: %d\", vm.sp)\n\t\t}*/\n\t}\n}\n\nfunc BenchmarkVmNOP(b *testing.B) {\n\tr := &Runtime{}\n\tr.init()\n\n\tvm := r.vm\n\tvm.prg = &Program{\n\t\tcode: []instruction{\n\t\t\tjump(1),\n\t\t\t//jump(1),\n\t\t},\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.pc = 0\n\t\tvm.run()\n\t}\n\n}\n\nfunc BenchmarkVm1(b *testing.B) {\n\tr := &Runtime{}\n\tr.init()\n\n\tvm := r.vm\n\n\t//ins1 := loadVal1(0)\n\t//ins2 := loadVal1(1)\n\n\tvm.prg = &Program{\n\t\tcode: []instruction{\n\t\t\tloadVal{valueInt(2)},\n\t\t\tloadVal{valueInt(3)},\n\t\t\tadd,\n\t\t},\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.pc = 0\n\t\tvm.run()\n\t\tr := vm.pop()\n\t\tif r.ToInteger() != 5 {\n\t\t\tb.Fatalf(\"Unexpected result: %+v\", r)\n\t\t}\n\t\tif vm.sp != 0 {\n\t\t\tb.Fatalf(\"Unexpected sp: %d\", vm.sp)\n\t\t}\n\t}\n}\n\nfunc BenchmarkFib(b *testing.B) {\n\tconst TEST_FIB = `\nfunction fib(n) {\nif (n < 2) return n;\nreturn fib(n - 2) + fib(n - 1);\n}\n\nfib(35);\n`\n\tb.StopTimer()\n\tprg, err := parser.ParseFile(nil, \"test.js\", TEST_FIB, 0)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tc := newCompiler()\n\tc.compile(prg, false, true, nil)\n\tc.p.dumpCode(b.Logf)\n\n\tr := &Runtime{}\n\tr.init()\n\n\tvm := r.vm\n\n\tvar expectedResult Value = valueInt(9227465)\n\n\tb.StartTimer()\n\n\tvm.prg = c.p\n\tvm.run()\n\tv := vm.result\n\n\tb.Logf(\"stack size: %d\", len(vm.stack))\n\tb.Logf(\"stashAllocs: %d\", vm.stashAllocs)\n\n\tif !v.SameAs(expectedResult) {\n\t\tb.Fatalf(\"Result: %+v, expected: %+v\", v, expectedResult)\n\t}\n\n}\n\nfunc BenchmarkEmptyLoop(b *testing.B) {\n\tconst SCRIPT = `\n\tfunction f() {\n\t\tfor (var i = 0; i < 100; i++) {\n\t\t}\n\t}\n\tf()\n\t`\n\tb.StopTimer()\n\tvm := New()\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\t// prg.dumpCode(log.Printf)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.RunProgram(prg)\n\t}\n}\n\nfunc BenchmarkVMAdd(b *testing.B) {\n\tvm := &vm{}\n\tvm.stack = append(vm.stack, nil, nil)\n\tvm.sp = len(vm.stack)\n\n\tvar v1 Value = valueInt(3)\n\tvar v2 Value = valueInt(5)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvm.stack[0] = v1\n\t\tvm.stack[1] = v2\n\t\tadd.exec(vm)\n\t\tvm.sp++\n\t}\n}\n\nfunc BenchmarkFuncCall(b *testing.B) {\n\tconst SCRIPT = `\n\tfunction f(a, b, c, d) {\n\t}\n\t`\n\n\tb.StopTimer()\n\n\tvm := New()\n\tprg := MustCompile(\"test.js\", SCRIPT, false)\n\n\tvm.RunProgram(prg)\n\tif f, ok := AssertFunction(vm.Get(\"f\")); ok {\n\t\tb.StartTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tf(nil, nil, intToValue(1), intToValue(2), intToValue(3), intToValue(4), intToValue(5), intToValue(6))\n\t\t}\n\t} else {\n\t\tb.Fatal(\"f is not a function\")\n\t}\n}\n\nfunc BenchmarkAssertInt(b *testing.B) {\n\tv := intToValue(42)\n\tfor i := 0; i < b.N; i++ {\n\t\tif i, ok := v.(valueInt); !ok || int64(i) != 42 {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}\n\nfunc BenchmarkLoadVal(b *testing.B) {\n\tvar ins instruction\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tins = loadVal{valueInt(1)}\n\t\t_ = ins\n\t}\n}\n"
        }
      ]
    }
  ]
}