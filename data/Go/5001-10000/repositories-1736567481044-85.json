{
  "metadata": {
    "timestamp": 1736567481044,
    "page": 85,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "etcd-io/bbolt",
      "stars": 8426,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.09375,
          "content": "*.prof\n*.test\n*.swp\n/bin/\ncover.out\ncover-*.out\n/.idea\n*.iml\n/bbolt\n/cmd/bbolt/bbolt\n.DS_Store\n\n"
        },
        {
          "name": ".go-version",
          "type": "blob",
          "size": 0.0068359375,
          "content": "1.23.4\n"
        },
        {
          "name": "CHANGELOG",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Ben Johnson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.224609375,
          "content": "BRANCH=`git rev-parse --abbrev-ref HEAD`\nCOMMIT=`git rev-parse --short HEAD`\nGOLDFLAGS=\"-X main.branch $(BRANCH) -X main.commit $(COMMIT)\"\nGOFILES = $(shell find . -name \\*.go)\n\nTESTFLAGS_RACE=-race=false\nifdef ENABLE_RACE\n\tTESTFLAGS_RACE=-race=true\nendif\n\nTESTFLAGS_CPU=\nifdef CPU\n\tTESTFLAGS_CPU=-cpu=$(CPU)\nendif\nTESTFLAGS = $(TESTFLAGS_RACE) $(TESTFLAGS_CPU) $(EXTRA_TESTFLAGS)\n\nTESTFLAGS_TIMEOUT=30m\nifdef TIMEOUT\n\tTESTFLAGS_TIMEOUT=$(TIMEOUT)\nendif\n\nTESTFLAGS_ENABLE_STRICT_MODE=false\nifdef ENABLE_STRICT_MODE\n\tTESTFLAGS_ENABLE_STRICT_MODE=$(ENABLE_STRICT_MODE)\nendif\n\n.EXPORT_ALL_VARIABLES:\nTEST_ENABLE_STRICT_MODE=${TESTFLAGS_ENABLE_STRICT_MODE}\n\n.PHONY: fmt\nfmt:\n\t@echo \"Verifying gofmt, failures can be fixed with ./scripts/fix.sh\"\n\t@!(gofmt -l -s -d ${GOFILES} | grep '[a-z]')\n\n\t@echo \"Verifying goimports, failures can be fixed with ./scripts/fix.sh\"\n\t@!(go run golang.org/x/tools/cmd/goimports@latest -l -d ${GOFILES} | grep '[a-z]')\n\n.PHONY: lint\nlint:\n\tgolangci-lint run ./...\n\n.PHONY: test\ntest:\n\t@echo \"hashmap freelist test\"\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=hashmap go test -v ${TESTFLAGS} -timeout ${TESTFLAGS_TIMEOUT}\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=hashmap go test -v ${TESTFLAGS} ./internal/...\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=hashmap go test -v ${TESTFLAGS} ./cmd/bbolt\n\n\t@echo \"array freelist test\"\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=array go test -v ${TESTFLAGS} -timeout ${TESTFLAGS_TIMEOUT}\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=array go test -v ${TESTFLAGS} ./internal/...\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=array go test -v ${TESTFLAGS} ./cmd/bbolt\n\n.PHONY: coverage\ncoverage:\n\t@echo \"hashmap freelist test\"\n\tTEST_FREELIST_TYPE=hashmap go test -v -timeout ${TESTFLAGS_TIMEOUT} \\\n\t\t-coverprofile cover-freelist-hashmap.out -covermode atomic\n\n\t@echo \"array freelist test\"\n\tTEST_FREELIST_TYPE=array go test -v -timeout ${TESTFLAGS_TIMEOUT} \\\n\t\t-coverprofile cover-freelist-array.out -covermode atomic\n\nBOLT_CMD=bbolt\n\nbuild:\n\tgo build -o bin/${BOLT_CMD} ./cmd/${BOLT_CMD}\n\n.PHONY: clean\nclean: # Clean binaries\n\trm -f ./bin/${BOLT_CMD}\n\n.PHONY: gofail-enable\ngofail-enable: install-gofail\n\tgofail enable .\n\n.PHONY: gofail-disable\ngofail-disable: install-gofail\n\tgofail disable .\n\n.PHONY: install-gofail\ninstall-gofail:\n\tgo install go.etcd.io/gofail\n\n.PHONY: test-failpoint\ntest-failpoint:\n\t@echo \"[failpoint] hashmap freelist test\"\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=hashmap go test -v ${TESTFLAGS} -timeout 30m ./tests/failpoint\n\n\t@echo \"[failpoint] array freelist test\"\n\tBBOLT_VERIFY=all TEST_FREELIST_TYPE=array go test -v ${TESTFLAGS} -timeout 30m ./tests/failpoint\n\n.PHONY: test-robustness # Running robustness tests requires root permission for now\n# TODO: Remove sudo once we fully migrate to the prow infrastructure\ntest-robustness: gofail-enable build\n\tsudo env PATH=$$PATH go test -v ${TESTFLAGS} ./tests/dmflakey -test.root\n\tsudo env PATH=$(PWD)/bin:$$PATH go test -v ${TESTFLAGS} ${ROBUSTNESS_TESTFLAGS} ./tests/robustness -test.root\n\n.PHONY: test-benchmark-compare\n# Runs benchmark tests on the current git ref and the given REF, and compares\n# the two.\ntest-benchmark-compare: install-benchstat\n\t@git fetch\n\t./scripts/compare_benchmarks.sh $(REF)\n\n.PHONY: install-benchstat\ninstall-benchstat:\n\tgo install golang.org/x/perf/cmd/benchstat@latest\n"
        },
        {
          "name": "OWNERS",
          "type": "blob",
          "size": 0.4677734375,
          "content": "# See the OWNERS docs at https://go.k8s.io/owners\n\napprovers:\n  - ahrtr           # Benjamin Wang <benjamin.ahrtr@gmail.com> <benjamin.wang@broadcom.com>\n  - serathius       # Marek Siarkowicz <siarkowicz@google.com> <marek.siarkowicz@gmail.com>\n  - ptabor          # Piotr Tabor <piotr.tabor@gmail.com>\n  - spzala          # Sahdev Zala <spzala@us.ibm.com>\nreviewers:\n  - fuweid          # Wei Fu <fuweid89@gmail.com>\n  - tjungblu        # Thomas Jungblut <tjungblu@redhat.com>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 40.1171875,
          "content": "bbolt\n=====\n\n[![Go Report Card](https://goreportcard.com/badge/go.etcd.io/bbolt?style=flat-square)](https://goreportcard.com/report/go.etcd.io/bbolt)\n[![Go Reference](https://pkg.go.dev/badge/go.etcd.io/bbolt.svg)](https://pkg.go.dev/go.etcd.io/bbolt)\n[![Releases](https://img.shields.io/github/release/etcd-io/bbolt/all.svg?style=flat-square)](https://github.com/etcd-io/bbolt/releases)\n[![LICENSE](https://img.shields.io/github/license/etcd-io/bbolt.svg?style=flat-square)](https://github.com/etcd-io/bbolt/blob/master/LICENSE)\n\nbbolt is a fork of [Ben Johnson's][gh_ben] [Bolt][bolt] key/value\nstore. The purpose of this fork is to provide the Go community with an active\nmaintenance and development target for Bolt; the goal is improved reliability\nand stability. bbolt includes bug fixes, performance enhancements, and features\nnot found in Bolt while preserving backwards compatibility with the Bolt API.\n\nBolt is a pure Go key/value store inspired by [Howard Chu's][hyc_symas]\n[LMDB project][lmdb]. The goal of the project is to provide a simple,\nfast, and reliable database for projects that don't require a full database\nserver such as Postgres or MySQL.\n\nSince Bolt is meant to be used as such a low-level piece of functionality,\nsimplicity is key. The API will be small and only focus on getting values\nand setting values. That's it.\n\n[gh_ben]: https://github.com/benbjohnson\n[bolt]: https://github.com/boltdb/bolt\n[hyc_symas]: https://twitter.com/hyc_symas\n[lmdb]: https://www.symas.com/symas-embedded-database-lmdb\n\n## Project Status\n\nBolt is stable, the API is fixed, and the file format is fixed. Full unit\ntest coverage and randomized black box testing are used to ensure database\nconsistency and thread safety. Bolt is currently used in high-load production\nenvironments serving databases as large as 1TB. Many companies such as\nShopify and Heroku use Bolt-backed services every day.\n\n## Project versioning\n\nbbolt uses [semantic versioning](http://semver.org).\nAPI should not change between patch and minor releases.\nNew minor versions may add additional features to the API.\n\n## Table of Contents\n\n  - [Getting Started](#getting-started)\n    - [Installing](#installing)\n    - [Opening a database](#opening-a-database)\n    - [Transactions](#transactions)\n      - [Read-write transactions](#read-write-transactions)\n      - [Read-only transactions](#read-only-transactions)\n      - [Batch read-write transactions](#batch-read-write-transactions)\n      - [Managing transactions manually](#managing-transactions-manually)\n    - [Using buckets](#using-buckets)\n    - [Using key/value pairs](#using-keyvalue-pairs)\n    - [Autoincrementing integer for the bucket](#autoincrementing-integer-for-the-bucket)\n    - [Iterating over keys](#iterating-over-keys)\n      - [Prefix scans](#prefix-scans)\n      - [Range scans](#range-scans)\n      - [ForEach()](#foreach)\n    - [Nested buckets](#nested-buckets)\n    - [Database backups](#database-backups)\n    - [Statistics](#statistics)\n    - [Read-Only Mode](#read-only-mode)\n    - [Mobile Use (iOS/Android)](#mobile-use-iosandroid)\n  - [Resources](#resources)\n  - [Comparison with other databases](#comparison-with-other-databases)\n    - [Postgres, MySQL, & other relational databases](#postgres-mysql--other-relational-databases)\n    - [LevelDB, RocksDB](#leveldb-rocksdb)\n    - [LMDB](#lmdb)\n  - [Caveats & Limitations](#caveats--limitations)\n  - [Reading the Source](#reading-the-source)\n  - [Known Issues](#known-issues)\n  - [Other Projects Using Bolt](#other-projects-using-bolt)\n\n## Getting Started\n\n### Installing\n\nTo start using `bbolt`, install Go and run `go get`:\n```sh\n$ go get go.etcd.io/bbolt@latest\n```\n\nThis will retrieve the library and update your `go.mod` and `go.sum` files.\n\nTo run the command line utility, execute:\n```sh\n$ go run go.etcd.io/bbolt/cmd/bbolt@latest\n```\n\nRun `go install` to install the `bbolt` command line utility into\nyour `$GOBIN` path, which defaults to `$GOPATH/bin` or `$HOME/go/bin` if the\n`GOPATH` environment variable is not set.\n```sh\n$ go install go.etcd.io/bbolt/cmd/bbolt@latest\n```\n\n### Importing bbolt\n\nTo use bbolt as an embedded key-value store, import as:\n\n```go\nimport bolt \"go.etcd.io/bbolt\"\n\ndb, err := bolt.Open(path, 0600, nil)\nif err != nil {\n  return err\n}\ndefer db.Close()\n```\n\n\n### Opening a database\n\nThe top-level object in Bolt is a `DB`. It is represented as a single file on\nyour disk and represents a consistent snapshot of your data.\n\nTo open your database, simply use the `bolt.Open()` function:\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\tbolt \"go.etcd.io/bbolt\"\n)\n\nfunc main() {\n\t// Open the my.db data file in your current directory.\n\t// It will be created if it doesn't exist.\n\tdb, err := bolt.Open(\"my.db\", 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t...\n}\n```\n\nPlease note that Bolt obtains a file lock on the data file so multiple processes\ncannot open the same database at the same time. Opening an already open Bolt\ndatabase will cause it to hang until the other process closes it. To prevent\nan indefinite wait you can pass a timeout option to the `Open()` function:\n\n```go\ndb, err := bolt.Open(\"my.db\", 0600, &bolt.Options{Timeout: 1 * time.Second})\n```\n\n\n### Transactions\n\nBolt allows only one read-write transaction at a time but allows as many\nread-only transactions as you want at a time. Each transaction has a consistent\nview of the data as it existed when the transaction started.\n\nIndividual transactions and all objects created from them (e.g. buckets, keys)\nare not thread safe. To work with data in multiple goroutines you must start\na transaction for each one or use locking to ensure only one goroutine accesses\na transaction at a time. Creating transaction from the `DB` is thread safe.\n\nTransactions should not depend on one another and generally shouldn't be opened\nsimultaneously in the same goroutine. This can cause a deadlock as the read-write\ntransaction needs to periodically re-map the data file but it cannot do so while\nany read-only transaction is open. Even a nested read-only transaction can cause\na deadlock, as the child transaction can block the parent transaction from releasing\nits resources.\n\n#### Read-write transactions\n\nTo start a read-write transaction, you can use the `DB.Update()` function:\n\n```go\nerr := db.Update(func(tx *bolt.Tx) error {\n\t...\n\treturn nil\n})\n```\n\nInside the closure, you have a consistent view of the database. You commit the\ntransaction by returning `nil` at the end. You can also rollback the transaction\nat any point by returning an error. All database operations are allowed inside\na read-write transaction.\n\nAlways check the return error as it will report any disk failures that can cause\nyour transaction to not complete. If you return an error within your closure\nit will be passed through.\n\n\n#### Read-only transactions\n\nTo start a read-only transaction, you can use the `DB.View()` function:\n\n```go\nerr := db.View(func(tx *bolt.Tx) error {\n\t...\n\treturn nil\n})\n```\n\nYou also get a consistent view of the database within this closure, however,\nno mutating operations are allowed within a read-only transaction. You can only\nretrieve buckets, retrieve values, and copy the database within a read-only\ntransaction.\n\n\n#### Batch read-write transactions\n\nEach `DB.Update()` waits for disk to commit the writes. This overhead\ncan be minimized by combining multiple updates with the `DB.Batch()`\nfunction:\n\n```go\nerr := db.Batch(func(tx *bolt.Tx) error {\n\t...\n\treturn nil\n})\n```\n\nConcurrent Batch calls are opportunistically combined into larger\ntransactions. Batch is only useful when there are multiple goroutines\ncalling it.\n\nThe trade-off is that `Batch` can call the given\nfunction multiple times, if parts of the transaction fail. The\nfunction must be idempotent and side effects must take effect only\nafter a successful return from `DB.Batch()`.\n\nFor example: don't display messages from inside the function, instead\nset variables in the enclosing scope:\n\n```go\nvar id uint64\nerr := db.Batch(func(tx *bolt.Tx) error {\n\t// Find last key in bucket, decode as bigendian uint64, increment\n\t// by one, encode back to []byte, and add new key.\n\t...\n\tid = newValue\n\treturn nil\n})\nif err != nil {\n\treturn ...\n}\nfmt.Println(\"Allocated ID %d\", id)\n```\n\n\n#### Managing transactions manually\n\nThe `DB.View()` and `DB.Update()` functions are wrappers around the `DB.Begin()`\nfunction. These helper functions will start the transaction, execute a function,\nand then safely close your transaction if an error is returned. This is the\nrecommended way to use Bolt transactions.\n\nHowever, sometimes you may want to manually start and end your transactions.\nYou can use the `DB.Begin()` function directly but **please** be sure to close\nthe transaction.\n\n```go\n// Start a writable transaction.\ntx, err := db.Begin(true)\nif err != nil {\n    return err\n}\ndefer tx.Rollback()\n\n// Use the transaction...\n_, err := tx.CreateBucket([]byte(\"MyBucket\"))\nif err != nil {\n    return err\n}\n\n// Commit the transaction and check for error.\nif err := tx.Commit(); err != nil {\n    return err\n}\n```\n\nThe first argument to `DB.Begin()` is a boolean stating if the transaction\nshould be writable.\n\n\n### Using buckets\n\nBuckets are collections of key/value pairs within the database. All keys in a\nbucket must be unique. You can create a bucket using the `Tx.CreateBucket()`\nfunction:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n\tb, err := tx.CreateBucket([]byte(\"MyBucket\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create bucket: %s\", err)\n\t}\n\treturn nil\n})\n```\n\nYou can retrieve an existing bucket using the `Tx.Bucket()` function:\n```go\ndb.Update(func(tx *bolt.Tx) error {\n\tb := tx.Bucket([]byte(\"MyBucket\"))\n\tif b == nil {\n\t\treturn errors.New(\"bucket does not exist\")\n\t}\n\treturn nil\n})\n```\n\nYou can also create a bucket only if it doesn't exist by using the\n`Tx.CreateBucketIfNotExists()` function. It's a common pattern to call this\nfunction for all your top-level buckets after you open your database so you can\nguarantee that they exist for future transactions.\n\nTo delete a bucket, simply call the `Tx.DeleteBucket()` function.\n\nYou can also iterate over all existing top-level buckets with `Tx.ForEach()`:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\ttx.ForEach(func(name []byte, b *bolt.Bucket) error {\n\t\tfmt.Println(string(name))\n\t\treturn nil\n\t})\n\treturn nil\n})\n```\n\n### Using key/value pairs\n\nTo save a key/value pair to a bucket, use the `Bucket.Put()` function:\n\n```go\ndb.Update(func(tx *bolt.Tx) error {\n\tb := tx.Bucket([]byte(\"MyBucket\"))\n\terr := b.Put([]byte(\"answer\"), []byte(\"42\"))\n\treturn err\n})\n```\n\nThis will set the value of the `\"answer\"` key to `\"42\"` in the `MyBucket`\nbucket. To retrieve this value, we can use the `Bucket.Get()` function:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\tb := tx.Bucket([]byte(\"MyBucket\"))\n\tv := b.Get([]byte(\"answer\"))\n\tfmt.Printf(\"The answer is: %s\\n\", v)\n\treturn nil\n})\n```\n\nThe `Get()` function does not return an error because its operation is\nguaranteed to work (unless there is some kind of system failure). If the key\nexists then it will return its byte slice value. If it doesn't exist then it\nwill return `nil`. It's important to note that you can have a zero-length value\nset to a key which is different than the key not existing.\n\nUse the `Bucket.Delete()` function to delete a key from the bucket:\n\n```go\ndb.Update(func (tx *bolt.Tx) error {\n    b := tx.Bucket([]byte(\"MyBucket\"))\n    err := b.Delete([]byte(\"answer\"))\n    return err\n})\n```\n\nThis will delete the key `answers` from the bucket `MyBucket`.\n\nPlease note that values returned from `Get()` are only valid while the\ntransaction is open. If you need to use a value outside of the transaction\nthen you must use `copy()` to copy it to another byte slice.\n\n\n### Autoincrementing integer for the bucket\nBy using the `NextSequence()` function, you can let Bolt determine a sequence\nwhich can be used as the unique identifier for your key/value pairs. See the\nexample below.\n\n```go\n// CreateUser saves u to the store. The new user ID is set on u once the data is persisted.\nfunc (s *Store) CreateUser(u *User) error {\n    return s.db.Update(func(tx *bolt.Tx) error {\n        // Retrieve the users bucket.\n        // This should be created when the DB is first opened.\n        b := tx.Bucket([]byte(\"users\"))\n\n        // Generate ID for the user.\n        // This returns an error only if the Tx is closed or not writeable.\n        // That can't happen in an Update() call so I ignore the error check.\n        id, _ := b.NextSequence()\n        u.ID = int(id)\n\n        // Marshal user data into bytes.\n        buf, err := json.Marshal(u)\n        if err != nil {\n            return err\n        }\n\n        // Persist bytes to users bucket.\n        return b.Put(itob(u.ID), buf)\n    })\n}\n\n// itob returns an 8-byte big endian representation of v.\nfunc itob(v int) []byte {\n    b := make([]byte, 8)\n    binary.BigEndian.PutUint64(b, uint64(v))\n    return b\n}\n\ntype User struct {\n    ID int\n    ...\n}\n```\n\n### Iterating over keys\n\nBolt stores its keys in byte-sorted order within a bucket. This makes sequential\niteration over these keys extremely fast. To iterate over keys we'll use a\n`Cursor`:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\t// Assume bucket exists and has keys\n\tb := tx.Bucket([]byte(\"MyBucket\"))\n\n\tc := b.Cursor()\n\n\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\tfmt.Printf(\"key=%s, value=%s\\n\", k, v)\n\t}\n\n\treturn nil\n})\n```\n\nThe cursor allows you to move to a specific point in the list of keys and move\nforward or backward through the keys one at a time.\n\nThe following functions are available on the cursor:\n\n```\nFirst()  Move to the first key.\nLast()   Move to the last key.\nSeek()   Move to a specific key.\nNext()   Move to the next key.\nPrev()   Move to the previous key.\n```\n\nEach of those functions has a return signature of `(key []byte, value []byte)`.\nYou must seek to a position using `First()`, `Last()`, or `Seek()` before calling\n`Next()` or `Prev()`. If you do not seek to a position then these functions will\nreturn a `nil` key.\n\nWhen you have iterated to the end of the cursor, then `Next()` will return a\n`nil` key and the cursor still points to the last element if present. When you\nhave iterated to the beginning of the cursor, then `Prev()` will return a `nil`\nkey and the cursor still points to the first element if present.\n\nIf you remove key/value pairs during iteration, the cursor may automatically\nmove to the next position if present in current node each time removing a key.\nWhen you call `c.Next()` after removing a key, it may skip one key/value pair.\nRefer to [pull/611](https://github.com/etcd-io/bbolt/pull/611) to get more detailed info.\n\nDuring iteration, if the key is non-`nil` but the value is `nil`, that means\nthe key refers to a bucket rather than a value.  Use `Bucket.Bucket()` to\naccess the sub-bucket.\n\n\n#### Prefix scans\n\nTo iterate over a key prefix, you can combine `Seek()` and `bytes.HasPrefix()`:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\t// Assume bucket exists and has keys\n\tc := tx.Bucket([]byte(\"MyBucket\")).Cursor()\n\n\tprefix := []byte(\"1234\")\n\tfor k, v := c.Seek(prefix); k != nil && bytes.HasPrefix(k, prefix); k, v = c.Next() {\n\t\tfmt.Printf(\"key=%s, value=%s\\n\", k, v)\n\t}\n\n\treturn nil\n})\n```\n\n#### Range scans\n\nAnother common use case is scanning over a range such as a time range. If you\nuse a sortable time encoding such as RFC3339 then you can query a specific\ndate range like this:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\t// Assume our events bucket exists and has RFC3339 encoded time keys.\n\tc := tx.Bucket([]byte(\"Events\")).Cursor()\n\n\t// Our time range spans the 90's decade.\n\tmin := []byte(\"1990-01-01T00:00:00Z\")\n\tmax := []byte(\"2000-01-01T00:00:00Z\")\n\n\t// Iterate over the 90's.\n\tfor k, v := c.Seek(min); k != nil && bytes.Compare(k, max) <= 0; k, v = c.Next() {\n\t\tfmt.Printf(\"%s: %s\\n\", k, v)\n\t}\n\n\treturn nil\n})\n```\n\nNote that, while RFC3339 is sortable, the Golang implementation of RFC3339Nano does not use a fixed number of digits after the decimal point and is therefore not sortable.\n\n\n#### ForEach()\n\nYou can also use the function `ForEach()` if you know you'll be iterating over\nall the keys in a bucket:\n\n```go\ndb.View(func(tx *bolt.Tx) error {\n\t// Assume bucket exists and has keys\n\tb := tx.Bucket([]byte(\"MyBucket\"))\n\n\tb.ForEach(func(k, v []byte) error {\n\t\tfmt.Printf(\"key=%s, value=%s\\n\", k, v)\n\t\treturn nil\n\t})\n\treturn nil\n})\n```\n\nPlease note that keys and values in `ForEach()` are only valid while\nthe transaction is open. If you need to use a key or value outside of\nthe transaction, you must use `copy()` to copy it to another byte\nslice.\n\n### Nested buckets\n\nYou can also store a bucket in a key to create nested buckets. The API is the\nsame as the bucket management API on the `DB` object:\n\n```go\nfunc (*Bucket) CreateBucket(key []byte) (*Bucket, error)\nfunc (*Bucket) CreateBucketIfNotExists(key []byte) (*Bucket, error)\nfunc (*Bucket) DeleteBucket(key []byte) error\n```\n\nSay you had a multi-tenant application where the root level bucket was the account bucket. Inside of this bucket was a sequence of accounts which themselves are buckets. And inside the sequence bucket you could have many buckets pertaining to the Account itself (Users, Notes, etc) isolating the information into logical groupings.\n\n```go\n\n// createUser creates a new user in the given account.\nfunc createUser(accountID int, u *User) error {\n    // Start the transaction.\n    tx, err := db.Begin(true)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Retrieve the root bucket for the account.\n    // Assume this has already been created when the account was set up.\n    root := tx.Bucket([]byte(strconv.FormatUint(accountID, 10)))\n\n    // Setup the users bucket.\n    bkt, err := root.CreateBucketIfNotExists([]byte(\"USERS\"))\n    if err != nil {\n        return err\n    }\n\n    // Generate an ID for the new user.\n    userID, err := bkt.NextSequence()\n    if err != nil {\n        return err\n    }\n    u.ID = userID\n\n    // Marshal and save the encoded user.\n    if buf, err := json.Marshal(u); err != nil {\n        return err\n    } else if err := bkt.Put([]byte(strconv.FormatUint(u.ID, 10)), buf); err != nil {\n        return err\n    }\n\n    // Commit the transaction.\n    if err := tx.Commit(); err != nil {\n        return err\n    }\n\n    return nil\n}\n\n```\n\n\n\n\n### Database backups\n\nBolt is a single file so it's easy to backup. You can use the `Tx.WriteTo()`\nfunction to write a consistent view of the database to a writer. If you call\nthis from a read-only transaction, it will perform a hot backup and not block\nyour other database reads and writes.\n\nBy default, it will use a regular file handle which will utilize the operating\nsystem's page cache. See the [`Tx`](https://godoc.org/go.etcd.io/bbolt#Tx)\ndocumentation for information about optimizing for larger-than-RAM datasets.\n\nOne common use case is to backup over HTTP so you can use tools like `cURL` to\ndo database backups:\n\n```go\nfunc BackupHandleFunc(w http.ResponseWriter, req *http.Request) {\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\tw.Header().Set(\"Content-Disposition\", `attachment; filename=\"my.db\"`)\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(int(tx.Size())))\n\t\t_, err := tx.WriteTo(w)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}\n```\n\nThen you can backup using this command:\n\n```sh\n$ curl http://localhost/backup > my.db\n```\n\nOr you can open your browser to `http://localhost/backup` and it will download\nautomatically.\n\nIf you want to backup to another file you can use the `Tx.CopyFile()` helper\nfunction.\n\n\n### Statistics\n\nThe database keeps a running count of many of the internal operations it\nperforms so you can better understand what's going on. By grabbing a snapshot\nof these stats at two points in time we can see what operations were performed\nin that time range.\n\nFor example, we could start a goroutine to log stats every 10 seconds:\n\n```go\ngo func() {\n\t// Grab the initial stats.\n\tprev := db.Stats()\n\n\tfor {\n\t\t// Wait for 10s.\n\t\ttime.Sleep(10 * time.Second)\n\n\t\t// Grab the current stats and diff them.\n\t\tstats := db.Stats()\n\t\tdiff := stats.Sub(&prev)\n\n\t\t// Encode stats to JSON and print to STDERR.\n\t\tjson.NewEncoder(os.Stderr).Encode(diff)\n\n\t\t// Save stats for the next loop.\n\t\tprev = stats\n\t}\n}()\n```\n\nIt's also useful to pipe these stats to a service such as statsd for monitoring\nor to provide an HTTP endpoint that will perform a fixed-length sample.\n\n\n### Read-Only Mode\n\nSometimes it is useful to create a shared, read-only Bolt database. To this,\nset the `Options.ReadOnly` flag when opening your database. Read-only mode\nuses a shared lock to allow multiple processes to read from the database but\nit will block any processes from opening the database in read-write mode.\n\n```go\ndb, err := bolt.Open(\"my.db\", 0600, &bolt.Options{ReadOnly: true})\nif err != nil {\n\tlog.Fatal(err)\n}\n```\n\n### Mobile Use (iOS/Android)\n\nBolt is able to run on mobile devices by leveraging the binding feature of the\n[gomobile](https://github.com/golang/mobile) tool. Create a struct that will\ncontain your database logic and a reference to a `*bolt.DB` with a initializing\nconstructor that takes in a filepath where the database file will be stored.\nNeither Android nor iOS require extra permissions or cleanup from using this method.\n\n```go\nfunc NewBoltDB(filepath string) *BoltDB {\n\tdb, err := bolt.Open(filepath+\"/demo.db\", 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn &BoltDB{db}\n}\n\ntype BoltDB struct {\n\tdb *bolt.DB\n\t...\n}\n\nfunc (b *BoltDB) Path() string {\n\treturn b.db.Path()\n}\n\nfunc (b *BoltDB) Close() {\n\tb.db.Close()\n}\n```\n\nDatabase logic should be defined as methods on this wrapper struct.\n\nTo initialize this struct from the native language (both platforms now sync\ntheir local storage to the cloud. These snippets disable that functionality for the\ndatabase file):\n\n#### Android\n\n```java\nString path;\nif (android.os.Build.VERSION.SDK_INT >=android.os.Build.VERSION_CODES.LOLLIPOP){\n    path = getNoBackupFilesDir().getAbsolutePath();\n} else{\n    path = getFilesDir().getAbsolutePath();\n}\nBoltmobiledemo.BoltDB boltDB = Boltmobiledemo.NewBoltDB(path)\n```\n\n#### iOS\n\n```objc\n- (void)demo {\n    NSString* path = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,\n                                                          NSUserDomainMask,\n                                                          YES) objectAtIndex:0];\n\tGoBoltmobiledemoBoltDB * demo = GoBoltmobiledemoNewBoltDB(path);\n\t[self addSkipBackupAttributeToItemAtPath:demo.path];\n\t//Some DB Logic would go here\n\t[demo close];\n}\n\n- (BOOL)addSkipBackupAttributeToItemAtPath:(NSString *) filePathString\n{\n    NSURL* URL= [NSURL fileURLWithPath: filePathString];\n    assert([[NSFileManager defaultManager] fileExistsAtPath: [URL path]]);\n\n    NSError *error = nil;\n    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]\n                                  forKey: NSURLIsExcludedFromBackupKey error: &error];\n    if(!success){\n        NSLog(@\"Error excluding %@ from backup %@\", [URL lastPathComponent], error);\n    }\n    return success;\n}\n\n```\n\n## Resources\n\nFor more information on getting started with Bolt, check out the following articles:\n\n* [Intro to BoltDB: Painless Performant Persistence](http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/) by [Nate Finch](https://github.com/natefinch).\n* [Bolt -- an embedded key/value database for Go](https://www.progville.com/go/bolt-embedded-db-golang/) by Progville\n\n\n## Comparison with other databases\n\n### Postgres, MySQL, & other relational databases\n\nRelational databases structure data into rows and are only accessible through\nthe use of SQL. This approach provides flexibility in how you store and query\nyour data but also incurs overhead in parsing and planning SQL statements. Bolt\naccesses all data by a byte slice key. This makes Bolt fast to read and write\ndata by key but provides no built-in support for joining values together.\n\nMost relational databases (with the exception of SQLite) are standalone servers\nthat run separately from your application. This gives your systems\nflexibility to connect multiple application servers to a single database\nserver but also adds overhead in serializing and transporting data over the\nnetwork. Bolt runs as a library included in your application so all data access\nhas to go through your application's process. This brings data closer to your\napplication but limits multi-process access to the data.\n\n\n### LevelDB, RocksDB\n\nLevelDB and its derivatives (RocksDB, HyperLevelDB) are similar to Bolt in that\nthey are libraries bundled into the application, however, their underlying\nstructure is a log-structured merge-tree (LSM tree). An LSM tree optimizes\nrandom writes by using a write ahead log and multi-tiered, sorted files called\nSSTables. Bolt uses a B+tree internally and only a single file. Both approaches\nhave trade-offs.\n\nIf you require a high random write throughput (>10,000 w/sec) or you need to use\nspinning disks then LevelDB could be a good choice. If your application is\nread-heavy or does a lot of range scans then Bolt could be a good choice.\n\nOne other important consideration is that LevelDB does not have transactions.\nIt supports batch writing of key/values pairs and it supports read snapshots\nbut it will not give you the ability to do a compare-and-swap operation safely.\nBolt supports fully serializable ACID transactions.\n\n\n### LMDB\n\nBolt was originally a port of LMDB so it is architecturally similar. Both use\na B+tree, have ACID semantics with fully serializable transactions, and support\nlock-free MVCC using a single writer and multiple readers.\n\nThe two projects have somewhat diverged. LMDB heavily focuses on raw performance\nwhile Bolt has focused on simplicity and ease of use. For example, LMDB allows\nseveral unsafe actions such as direct writes for the sake of performance. Bolt\nopts to disallow actions which can leave the database in a corrupted state. The\nonly exception to this in Bolt is `DB.NoSync`.\n\nThere are also a few differences in API. LMDB requires a maximum mmap size when\nopening an `mdb_env` whereas Bolt will handle incremental mmap resizing\nautomatically. LMDB overloads the getter and setter functions with multiple\nflags whereas Bolt splits these specialized cases into their own functions.\n\n\n## Caveats & Limitations\n\nIt's important to pick the right tool for the job and Bolt is no exception.\nHere are a few things to note when evaluating and using Bolt:\n\n* Bolt is good for read intensive workloads. Sequential write performance is\n  also fast but random writes can be slow. You can use `DB.Batch()` or add a\n  write-ahead log to help mitigate this issue.\n\n* Bolt uses a B+tree internally so there can be a lot of random page access.\n  SSDs provide a significant performance boost over spinning disks.\n\n* Try to avoid long running read transactions. Bolt uses copy-on-write so\n  old pages cannot be reclaimed while an old transaction is using them.\n\n* Byte slices returned from Bolt are only valid during a transaction. Once the\n  transaction has been committed or rolled back then the memory they point to\n  can be reused by a new page or can be unmapped from virtual memory and you'll\n  see an `unexpected fault address` panic when accessing it.\n\n* Bolt uses an exclusive write lock on the database file so it cannot be\n  shared by multiple processes.\n\n* Be careful when using `Bucket.FillPercent`. Setting a high fill percent for\n  buckets that have random inserts will cause your database to have very poor\n  page utilization.\n\n* Use larger buckets in general. Smaller buckets causes poor page utilization\n  once they become larger than the page size (typically 4KB).\n\n* Bulk loading a lot of random writes into a new bucket can be slow as the\n  page will not split until the transaction is committed. Randomly inserting\n  more than 100,000 key/value pairs into a single new bucket in a single\n  transaction is not advised.\n\n* Bolt uses a memory-mapped file so the underlying operating system handles the\n  caching of the data. Typically, the OS will cache as much of the file as it\n  can in memory and will release memory as needed to other processes. This means\n  that Bolt can show very high memory usage when working with large databases.\n  However, this is expected and the OS will release memory as needed. Bolt can\n  handle databases much larger than the available physical RAM, provided its\n  memory-map fits in the process virtual address space. It may be problematic\n  on 32-bits systems.\n\n* The data structures in the Bolt database are memory mapped so the data file\n  will be endian specific. This means that you cannot copy a Bolt file from a\n  little endian machine to a big endian machine and have it work. For most\n  users this is not a concern since most modern CPUs are little endian.\n\n* Because of the way pages are laid out on disk, Bolt cannot truncate data files\n  and return free pages back to the disk. Instead, Bolt maintains a free list\n  of unused pages within its data file. These free pages can be reused by later\n  transactions. This works well for many use cases as databases generally tend\n  to grow. However, it's important to note that deleting large chunks of data\n  will not allow you to reclaim that space on disk.\n\n* Removing key/values pairs in a bucket during iteration on the bucket using\n  cursor may not work properly. Each time when removing a key/value pair, the\n  cursor may automatically move to the next position if present. When users\n  call `c.Next()` after removing a key, it may skip one key/value pair.\n  Refer to https://github.com/etcd-io/bbolt/pull/611 for more detailed info.\n\n  For more information on page allocation, [see this comment][page-allocation].\n\n[page-allocation]: https://github.com/boltdb/bolt/issues/308#issuecomment-74811638\n\n\n## Reading the Source\n\nBolt is a relatively small code base (<5KLOC) for an embedded, serializable,\ntransactional key/value database so it can be a good starting point for people\ninterested in how databases work.\n\nThe best places to start are the main entry points into Bolt:\n\n- `Open()` - Initializes the reference to the database. It's responsible for\n  creating the database if it doesn't exist, obtaining an exclusive lock on the\n  file, reading the meta pages, & memory-mapping the file.\n\n- `DB.Begin()` - Starts a read-only or read-write transaction depending on the\n  value of the `writable` argument. This requires briefly obtaining the \"meta\"\n  lock to keep track of open transactions. Only one read-write transaction can\n  exist at a time so the \"rwlock\" is acquired during the life of a read-write\n  transaction.\n\n- `Bucket.Put()` - Writes a key/value pair into a bucket. After validating the\n  arguments, a cursor is used to traverse the B+tree to the page and position\n  where the key & value will be written. Once the position is found, the bucket\n  materializes the underlying page and the page's parent pages into memory as\n  \"nodes\". These nodes are where mutations occur during read-write transactions.\n  These changes get flushed to disk during commit.\n\n- `Bucket.Get()` - Retrieves a key/value pair from a bucket. This uses a cursor\n  to move to the page & position of a key/value pair. During a read-only\n  transaction, the key and value data is returned as a direct reference to the\n  underlying mmap file so there's no allocation overhead. For read-write\n  transactions, this data may reference the mmap file or one of the in-memory\n  node values.\n\n- `Cursor` - This object is simply for traversing the B+tree of on-disk pages\n  or in-memory nodes. It can seek to a specific key, move to the first or last\n  value, or it can move forward or backward. The cursor handles the movement up\n  and down the B+tree transparently to the end user.\n\n- `Tx.Commit()` - Converts the in-memory dirty nodes and the list of free pages\n  into pages to be written to disk. Writing to disk then occurs in two phases.\n  First, the dirty pages are written to disk and an `fsync()` occurs. Second, a\n  new meta page with an incremented transaction ID is written and another\n  `fsync()` occurs. This two phase write ensures that partially written data\n  pages are ignored in the event of a crash since the meta page pointing to them\n  is never written. Partially written meta pages are invalidated because they\n  are written with a checksum.\n\nIf you have additional notes that could be helpful for others, please submit\nthem via pull request.\n\n## Known Issues\n\n- bbolt might run into data corruption issue on Linux when the feature\n  [ext4: fast commit](https://lwn.net/Articles/842385/), which was introduced in\n  linux kernel version v5.10, is enabled. The fixes to the issue were included in\n  linux kernel version v5.17, please refer to links below,\n\n  * [ext4: fast commit may miss tracking unwritten range during ftruncate](https://lore.kernel.org/linux-ext4/20211223032337.5198-3-yinxin.x@bytedance.com/)\n  * [ext4: fast commit may not fallback for ineligible commit](https://lore.kernel.org/lkml/202201091544.W5HHEXAp-lkp@intel.com/T/#ma0768815e4b5f671e9e451d578256ef9a76fe30e)\n  * [ext4 updates for 5.17](https://lore.kernel.org/lkml/YdyxjTFaLWif6BCM@mit.edu/)\n\n  Please also refer to the discussion in https://github.com/etcd-io/bbolt/issues/562.\n\n- Writing a value with a length of 0 will always result in reading back an empty `[]byte{}` value.\n  Please refer to [issues/726#issuecomment-2061694802](https://github.com/etcd-io/bbolt/issues/726#issuecomment-2061694802).\n\n## Other Projects Using Bolt\n\nBelow is a list of public, open source projects that use Bolt:\n\n* [Algernon](https://github.com/xyproto/algernon) - A HTTP/2 web server with built-in support for Lua. Uses BoltDB as the default database backend.\n* [Bazil](https://bazil.org/) - A file system that lets your data reside where it is most convenient for it to reside.\n* [bolter](https://github.com/hasit/bolter) - Command-line app for viewing BoltDB file in your terminal.\n* [boltcli](https://github.com/spacewander/boltcli) - the redis-cli for boltdb with Lua script support.\n* [BoltHold](https://github.com/timshannon/bolthold) - An embeddable NoSQL store for Go types built on BoltDB\n* [BoltStore](https://github.com/yosssi/boltstore) - Session store using Bolt.\n* [Boltdb Boilerplate](https://github.com/bobintornado/boltdb-boilerplate) - Boilerplate wrapper around bolt aiming to make simple calls one-liners.\n* [BoltDbWeb](https://github.com/evnix/boltdbweb) - A web based GUI for BoltDB files.\n* [BoltDB Viewer](https://github.com/zc310/rich_boltdb) - A BoltDB Viewer Can run on Windowsã€Linuxã€Android system.\n* [bleve](http://www.blevesearch.com/) - A pure Go search engine similar to ElasticSearch that uses Bolt as the default storage backend.\n* [bstore](https://github.com/mjl-/bstore) - Database library storing Go values, with referential/unique/nonzero constraints, indices, automatic schema management with struct tags, and a query API.\n* [btcwallet](https://github.com/btcsuite/btcwallet) - A bitcoin wallet.\n* [buckets](https://github.com/joyrexus/buckets) - a bolt wrapper streamlining\n  simple tx and key scans.\n* [Buildkit](https://github.com/moby/buildkit) - concurrent, cache-efficient, and Dockerfile-agnostic builder toolkit\n* [cayley](https://github.com/google/cayley) - Cayley is an open-source graph database using Bolt as optional backend.\n* [ChainStore](https://github.com/pressly/chainstore) - Simple key-value interface to a variety of storage engines organized as a chain of operations.\n* [ðŸŒ° Chestnut](https://github.com/jrapoport/chestnut) - Chestnut is encrypted storage for Go.\n* [Consul](https://github.com/hashicorp/consul) - Consul is service discovery and configuration made easy. Distributed, highly available, and datacenter-aware.\n* [Containerd](https://github.com/containerd/containerd) - An open and reliable container runtime\n* [DVID](https://github.com/janelia-flyem/dvid) - Added Bolt as optional storage engine and testing it against Basho-tuned leveldb.\n* [dcrwallet](https://github.com/decred/dcrwallet) - A wallet for the Decred cryptocurrency.\n* [drive](https://github.com/odeke-em/drive) - drive is an unofficial Google Drive command line client for \\*NIX operating systems.\n* [event-shuttle](https://github.com/sclasen/event-shuttle) - A Unix system service to collect and reliably deliver messages to Kafka.\n* [Freehold](http://tshannon.bitbucket.org/freehold/) - An open, secure, and lightweight platform for your files and data.\n* [Go Report Card](https://goreportcard.com/) - Go code quality report cards as a (free and open source) service.\n* [GoWebApp](https://github.com/josephspurrier/gowebapp) - A basic MVC web application in Go using BoltDB.\n* [GoShort](https://github.com/pankajkhairnar/goShort) - GoShort is a URL shortener written in Golang and BoltDB for persistent key/value storage and for routing it's using high performent HTTPRouter.\n* [gopherpit](https://github.com/gopherpit/gopherpit) - A web service to manage Go remote import paths with custom domains\n* [gokv](https://github.com/philippgille/gokv) - Simple key-value store abstraction and implementations for Go (Redis, Consul, etcd, bbolt, BadgerDB, LevelDB, Memcached, DynamoDB, S3, PostgreSQL, MongoDB, CockroachDB and many more)\n* [Gitchain](https://github.com/gitchain/gitchain) - Decentralized, peer-to-peer Git repositories aka \"Git meets Bitcoin\".\n* [InfluxDB](https://influxdata.com) - Scalable datastore for metrics, events, and real-time analytics.\n* [ipLocator](https://github.com/AndreasBriese/ipLocator) - A fast ip-geo-location-server using bolt with bloom filters.\n* [ipxed](https://github.com/kelseyhightower/ipxed) - Web interface and api for ipxed.\n* [Ironsmith](https://github.com/timshannon/ironsmith) - A simple, script-driven continuous integration (build - > test -> release) tool, with no external dependencies\n* [Kala](https://github.com/ajvb/kala) - Kala is a modern job scheduler optimized to run on a single node. It is persistent, JSON over HTTP API, ISO 8601 duration notation, and dependent jobs.\n* [Key Value Access Language (KVAL)](https://github.com/kval-access-language) - A proposed grammar for key-value datastores offering a bbolt binding.\n* [LedisDB](https://github.com/siddontang/ledisdb) - A high performance NoSQL, using Bolt as optional storage.\n* [lru](https://github.com/crowdriff/lru) - Easy to use Bolt-backed Least-Recently-Used (LRU) read-through cache with chainable remote stores.\n* [mbuckets](https://github.com/abhigupta912/mbuckets) - A Bolt wrapper that allows easy operations on multi level (nested) buckets.\n* [MetricBase](https://github.com/msiebuhr/MetricBase) - Single-binary version of Graphite.\n* [MuLiFS](https://github.com/dankomiocevic/mulifs) - Music Library Filesystem creates a filesystem to organise your music files.\n* [NATS](https://github.com/nats-io/nats-streaming-server) - NATS Streaming uses bbolt for message and metadata storage.\n* [Portainer](https://github.com/portainer/portainer) - A lightweight service delivery platform for containerized applications that can be used to manage Docker, Swarm, Kubernetes and ACI environments.\n* [Prometheus Annotation Server](https://github.com/oliver006/prom_annotation_server) - Annotation server for PromDash & Prometheus service monitoring system.\n* [Rain](https://github.com/cenkalti/rain) - BitTorrent client and library.\n* [reef-pi](https://github.com/reef-pi/reef-pi) - reef-pi is an award winning, modular, DIY reef tank controller using easy to learn electronics based on a Raspberry Pi.\n* [Request Baskets](https://github.com/darklynx/request-baskets) - A web service to collect arbitrary HTTP requests and inspect them via REST API or simple web UI, similar to [RequestBin](http://requestb.in/) service\n* [Seaweed File System](https://github.com/chrislusf/seaweedfs) - Highly scalable distributed key~file system with O(1) disk read.\n* [stow](https://github.com/djherbis/stow) -  a persistence manager for objects\n  backed by boltdb.\n* [Storm](https://github.com/asdine/storm) - Simple and powerful ORM for BoltDB.\n* [SimpleBolt](https://github.com/xyproto/simplebolt) - A simple way to use BoltDB. Deals mainly with strings.\n* [Skybox Analytics](https://github.com/skybox/skybox) - A standalone funnel analysis tool for web analytics.\n* [Scuttlebutt](https://github.com/benbjohnson/scuttlebutt) - Uses Bolt to store and process all Twitter mentions of GitHub projects.\n* [tentacool](https://github.com/optiflows/tentacool) - REST api server to manage system stuff (IP, DNS, Gateway...) on a linux server.\n* [torrent](https://github.com/anacrolix/torrent) - Full-featured BitTorrent client package and utilities in Go. BoltDB is a storage backend in development.\n* [Wiki](https://github.com/peterhellberg/wiki) - A tiny wiki using Goji, BoltDB and Blackfriday.\n\nIf you are using Bolt in a project please send a pull request to add it to the list.\n"
        },
        {
          "name": "allocate_test.go",
          "type": "blob",
          "size": 0.8876953125,
          "content": "package bbolt\n\nimport (\n\t\"testing\"\n\n\t\"go.etcd.io/bbolt/internal/common\"\n\t\"go.etcd.io/bbolt/internal/freelist\"\n)\n\nfunc TestTx_allocatePageStats(t *testing.T) {\n\tfor n, f := range map[string]freelist.Interface{\"hashmap\": freelist.NewHashMapFreelist(), \"array\": freelist.NewArrayFreelist()} {\n\t\tt.Run(n, func(t *testing.T) {\n\t\t\tids := []common.Pgid{2, 3}\n\t\t\tf.Init(ids)\n\n\t\t\ttx := &Tx{\n\t\t\t\tdb: &DB{\n\t\t\t\t\tfreelist: f,\n\t\t\t\t\tpageSize: common.DefaultPageSize,\n\t\t\t\t},\n\t\t\t\tmeta:  &common.Meta{},\n\t\t\t\tpages: make(map[common.Pgid]*common.Page),\n\t\t\t}\n\n\t\t\ttxStats := tx.Stats()\n\t\t\tprePageCnt := txStats.GetPageCount()\n\t\t\tallocateCnt := f.FreeCount()\n\n\t\t\tif _, err := tx.allocate(allocateCnt); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttxStats = tx.Stats()\n\t\t\tif txStats.GetPageCount() != prePageCnt+int64(allocateCnt) {\n\t\t\t\tt.Errorf(\"Allocated %d but got %d page in stats\", allocateCnt, txStats.GetPageCount())\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "bolt_386.go",
          "type": "blob",
          "size": 0.2080078125,
          "content": "package bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0x7FFFFFFF // 2GB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0xFFFFFFF\n"
        },
        {
          "name": "bolt_aix.go",
          "type": "blob",
          "size": 1.9443359375,
          "content": "//go:build aix\n\npackage bbolt\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// flock acquires an advisory lock on a file descriptor.\nfunc flock(db *DB, exclusive bool, timeout time.Duration) error {\n\tvar t time.Time\n\tif timeout != 0 {\n\t\tt = time.Now()\n\t}\n\tfd := db.file.Fd()\n\tvar lockType int16\n\tif exclusive {\n\t\tlockType = syscall.F_WRLCK\n\t} else {\n\t\tlockType = syscall.F_RDLCK\n\t}\n\tfor {\n\t\t// Attempt to obtain an exclusive lock.\n\t\tlock := syscall.Flock_t{Type: lockType}\n\t\terr := syscall.FcntlFlock(fd, syscall.F_SETLK, &lock)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t} else if err != syscall.EAGAIN {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we timed out then return an error.\n\t\tif timeout != 0 && time.Since(t) > timeout-flockRetryTimeout {\n\t\t\treturn ErrTimeout\n\t\t}\n\n\t\t// Wait for a bit and try again.\n\t\ttime.Sleep(flockRetryTimeout)\n\t}\n}\n\n// funlock releases an advisory lock on a file descriptor.\nfunc funlock(db *DB) error {\n\tvar lock syscall.Flock_t\n\tlock.Start = 0\n\tlock.Len = 0\n\tlock.Type = syscall.F_UNLCK\n\tlock.Whence = 0\n\treturn syscall.FcntlFlock(uintptr(db.file.Fd()), syscall.F_SETLK, &lock)\n}\n\n// mmap memory maps a DB's data file.\nfunc mmap(db *DB, sz int) error {\n\t// Map the data file to memory.\n\tb, err := unix.Mmap(int(db.file.Fd()), 0, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Advise the kernel that the mmap is accessed randomly.\n\tif err := unix.Madvise(b, syscall.MADV_RANDOM); err != nil {\n\t\treturn fmt.Errorf(\"madvise: %s\", err)\n\t}\n\n\t// Save the original byte slice and convert to a byte array pointer.\n\tdb.dataref = b\n\tdb.data = (*[maxMapSize]byte)(unsafe.Pointer(&b[0]))\n\tdb.datasz = sz\n\treturn nil\n}\n\n// munmap unmaps a DB's data file from memory.\nfunc munmap(db *DB) error {\n\t// Ignore the unmap if we have no mapped data.\n\tif db.dataref == nil {\n\t\treturn nil\n\t}\n\n\t// Unmap using the original byte slice.\n\terr := unix.Munmap(db.dataref)\n\tdb.dataref = nil\n\tdb.data = nil\n\tdb.datasz = 0\n\treturn err\n}\n"
        },
        {
          "name": "bolt_amd64.go",
          "type": "blob",
          "size": 0.21484375,
          "content": "package bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_android.go",
          "type": "blob",
          "size": 2.0185546875,
          "content": "package bbolt\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// flock acquires an advisory lock on a file descriptor.\nfunc flock(db *DB, exclusive bool, timeout time.Duration) error {\n\tvar t time.Time\n\tif timeout != 0 {\n\t\tt = time.Now()\n\t}\n\tfd := db.file.Fd()\n\tvar lockType int16\n\tif exclusive {\n\t\tlockType = syscall.F_WRLCK\n\t} else {\n\t\tlockType = syscall.F_RDLCK\n\t}\n\tfor {\n\t\t// Attempt to obtain an exclusive lock.\n\t\tlock := syscall.Flock_t{Type: lockType}\n\t\terr := syscall.FcntlFlock(fd, syscall.F_SETLK, &lock)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t} else if err != syscall.EAGAIN {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we timed out then return an error.\n\t\tif timeout != 0 && time.Since(t) > timeout-flockRetryTimeout {\n\t\t\treturn ErrTimeout\n\t\t}\n\n\t\t// Wait for a bit and try again.\n\t\ttime.Sleep(flockRetryTimeout)\n\t}\n}\n\n// funlock releases an advisory lock on a file descriptor.\nfunc funlock(db *DB) error {\n\tvar lock syscall.Flock_t\n\tlock.Start = 0\n\tlock.Len = 0\n\tlock.Type = syscall.F_UNLCK\n\tlock.Whence = 0\n\treturn syscall.FcntlFlock(uintptr(db.file.Fd()), syscall.F_SETLK, &lock)\n}\n\n// mmap memory maps a DB's data file.\nfunc mmap(db *DB, sz int) error {\n\t// Map the data file to memory.\n\tb, err := unix.Mmap(int(db.file.Fd()), 0, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Advise the kernel that the mmap is accessed randomly.\n\terr = unix.Madvise(b, syscall.MADV_RANDOM)\n\tif err != nil && err != syscall.ENOSYS {\n\t\t// Ignore not implemented error in kernel because it still works.\n\t\treturn fmt.Errorf(\"madvise: %s\", err)\n\t}\n\n\t// Save the original byte slice and convert to a byte array pointer.\n\tdb.dataref = b\n\tdb.data = (*[maxMapSize]byte)(unsafe.Pointer(&b[0]))\n\tdb.datasz = sz\n\treturn nil\n}\n\n// munmap unmaps a DB's data file from memory.\nfunc munmap(db *DB) error {\n\t// Ignore the unmap if we have no mapped data.\n\tif db.dataref == nil {\n\t\treturn nil\n\t}\n\n\t// Unmap using the original byte slice.\n\terr := unix.Munmap(db.dataref)\n\tdb.dataref = nil\n\tdb.data = nil\n\tdb.datasz = 0\n\treturn err\n}\n"
        },
        {
          "name": "bolt_arm.go",
          "type": "blob",
          "size": 0.2080078125,
          "content": "package bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0x7FFFFFFF // 2GB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0xFFFFFFF\n"
        },
        {
          "name": "bolt_arm64.go",
          "type": "blob",
          "size": 0.232421875,
          "content": "//go:build arm64\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_linux.go",
          "type": "blob",
          "size": 0.16796875,
          "content": "package bbolt\n\nimport (\n\t\"syscall\"\n)\n\n// fdatasync flushes written data to a file descriptor.\nfunc fdatasync(db *DB) error {\n\treturn syscall.Fdatasync(int(db.file.Fd()))\n}\n"
        },
        {
          "name": "bolt_loong64.go",
          "type": "blob",
          "size": 0.234375,
          "content": "//go:build loong64\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_mips64x.go",
          "type": "blob",
          "size": 0.2431640625,
          "content": "//go:build mips64 || mips64le\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0x8000000000 // 512GB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_mipsx.go",
          "type": "blob",
          "size": 0.234375,
          "content": "//go:build mips || mipsle\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0x40000000 // 1GB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0xFFFFFFF\n"
        },
        {
          "name": "bolt_openbsd.go",
          "type": "blob",
          "size": 0.2353515625,
          "content": "package bbolt\n\nimport (\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc msync(db *DB) error {\n\treturn unix.Msync(db.data[:db.datasz], unix.MS_INVALIDATE)\n}\n\nfunc fdatasync(db *DB) error {\n\tif db.data != nil {\n\t\treturn msync(db)\n\t}\n\treturn db.file.Sync()\n}\n"
        },
        {
          "name": "bolt_ppc.go",
          "type": "blob",
          "size": 0.2236328125,
          "content": "//go:build ppc\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0x7FFFFFFF // 2GB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0xFFFFFFF\n"
        },
        {
          "name": "bolt_ppc64.go",
          "type": "blob",
          "size": 0.232421875,
          "content": "//go:build ppc64\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_ppc64le.go",
          "type": "blob",
          "size": 0.234375,
          "content": "//go:build ppc64le\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_riscv64.go",
          "type": "blob",
          "size": 0.234375,
          "content": "//go:build riscv64\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_s390x.go",
          "type": "blob",
          "size": 0.232421875,
          "content": "//go:build s390x\n\npackage bbolt\n\n// maxMapSize represents the largest mmap size supported by Bolt.\nconst maxMapSize = 0xFFFFFFFFFFFF // 256TB\n\n// maxAllocSize is the size used when creating array pointers.\nconst maxAllocSize = 0x7FFFFFFF\n"
        },
        {
          "name": "bolt_solaris.go",
          "type": "blob",
          "size": 1.9287109375,
          "content": "package bbolt\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// flock acquires an advisory lock on a file descriptor.\nfunc flock(db *DB, exclusive bool, timeout time.Duration) error {\n\tvar t time.Time\n\tif timeout != 0 {\n\t\tt = time.Now()\n\t}\n\tfd := db.file.Fd()\n\tvar lockType int16\n\tif exclusive {\n\t\tlockType = syscall.F_WRLCK\n\t} else {\n\t\tlockType = syscall.F_RDLCK\n\t}\n\tfor {\n\t\t// Attempt to obtain an exclusive lock.\n\t\tlock := syscall.Flock_t{Type: lockType}\n\t\terr := syscall.FcntlFlock(fd, syscall.F_SETLK, &lock)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t} else if err != syscall.EAGAIN {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we timed out then return an error.\n\t\tif timeout != 0 && time.Since(t) > timeout-flockRetryTimeout {\n\t\t\treturn ErrTimeout\n\t\t}\n\n\t\t// Wait for a bit and try again.\n\t\ttime.Sleep(flockRetryTimeout)\n\t}\n}\n\n// funlock releases an advisory lock on a file descriptor.\nfunc funlock(db *DB) error {\n\tvar lock syscall.Flock_t\n\tlock.Start = 0\n\tlock.Len = 0\n\tlock.Type = syscall.F_UNLCK\n\tlock.Whence = 0\n\treturn syscall.FcntlFlock(uintptr(db.file.Fd()), syscall.F_SETLK, &lock)\n}\n\n// mmap memory maps a DB's data file.\nfunc mmap(db *DB, sz int) error {\n\t// Map the data file to memory.\n\tb, err := unix.Mmap(int(db.file.Fd()), 0, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Advise the kernel that the mmap is accessed randomly.\n\tif err := unix.Madvise(b, syscall.MADV_RANDOM); err != nil {\n\t\treturn fmt.Errorf(\"madvise: %s\", err)\n\t}\n\n\t// Save the original byte slice and convert to a byte array pointer.\n\tdb.dataref = b\n\tdb.data = (*[maxMapSize]byte)(unsafe.Pointer(&b[0]))\n\tdb.datasz = sz\n\treturn nil\n}\n\n// munmap unmaps a DB's data file from memory.\nfunc munmap(db *DB) error {\n\t// Ignore the unmap if we have no mapped data.\n\tif db.dataref == nil {\n\t\treturn nil\n\t}\n\n\t// Unmap using the original byte slice.\n\terr := unix.Munmap(db.dataref)\n\tdb.dataref = nil\n\tdb.data = nil\n\tdb.datasz = 0\n\treturn err\n}\n"
        },
        {
          "name": "bolt_unix.go",
          "type": "blob",
          "size": 1.9443359375,
          "content": "//go:build !windows && !plan9 && !solaris && !aix && !android\n\npackage bbolt\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"go.etcd.io/bbolt/errors\"\n)\n\n// flock acquires an advisory lock on a file descriptor.\nfunc flock(db *DB, exclusive bool, timeout time.Duration) error {\n\tvar t time.Time\n\tif timeout != 0 {\n\t\tt = time.Now()\n\t}\n\tfd := db.file.Fd()\n\tflag := syscall.LOCK_NB\n\tif exclusive {\n\t\tflag |= syscall.LOCK_EX\n\t} else {\n\t\tflag |= syscall.LOCK_SH\n\t}\n\tfor {\n\t\t// Attempt to obtain an exclusive lock.\n\t\terr := syscall.Flock(int(fd), flag)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t} else if err != syscall.EWOULDBLOCK {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we timed out then return an error.\n\t\tif timeout != 0 && time.Since(t) > timeout-flockRetryTimeout {\n\t\t\treturn errors.ErrTimeout\n\t\t}\n\n\t\t// Wait for a bit and try again.\n\t\ttime.Sleep(flockRetryTimeout)\n\t}\n}\n\n// funlock releases an advisory lock on a file descriptor.\nfunc funlock(db *DB) error {\n\treturn syscall.Flock(int(db.file.Fd()), syscall.LOCK_UN)\n}\n\n// mmap memory maps a DB's data file.\nfunc mmap(db *DB, sz int) error {\n\t// Map the data file to memory.\n\tb, err := unix.Mmap(int(db.file.Fd()), 0, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Advise the kernel that the mmap is accessed randomly.\n\terr = unix.Madvise(b, syscall.MADV_RANDOM)\n\tif err != nil && err != syscall.ENOSYS {\n\t\t// Ignore not implemented error in kernel because it still works.\n\t\treturn fmt.Errorf(\"madvise: %s\", err)\n\t}\n\n\t// Save the original byte slice and convert to a byte array pointer.\n\tdb.dataref = b\n\tdb.data = (*[maxMapSize]byte)(unsafe.Pointer(&b[0]))\n\tdb.datasz = sz\n\treturn nil\n}\n\n// munmap unmaps a DB's data file from memory.\nfunc munmap(db *DB) error {\n\t// Ignore the unmap if we have no mapped data.\n\tif db.dataref == nil {\n\t\treturn nil\n\t}\n\n\t// Unmap using the original byte slice.\n\terr := unix.Munmap(db.dataref)\n\tdb.dataref = nil\n\tdb.data = nil\n\tdb.datasz = 0\n\treturn err\n}\n"
        },
        {
          "name": "bolt_windows.go",
          "type": "blob",
          "size": 2.85546875,
          "content": "package bbolt\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/windows\"\n\n\t\"go.etcd.io/bbolt/errors\"\n)\n\n// fdatasync flushes written data to a file descriptor.\nfunc fdatasync(db *DB) error {\n\treturn db.file.Sync()\n}\n\n// flock acquires an advisory lock on a file descriptor.\nfunc flock(db *DB, exclusive bool, timeout time.Duration) error {\n\tvar t time.Time\n\tif timeout != 0 {\n\t\tt = time.Now()\n\t}\n\tvar flags uint32 = windows.LOCKFILE_FAIL_IMMEDIATELY\n\tif exclusive {\n\t\tflags |= windows.LOCKFILE_EXCLUSIVE_LOCK\n\t}\n\tfor {\n\t\t// Fix for https://github.com/etcd-io/bbolt/issues/121. Use byte-range\n\t\t// -1..0 as the lock on the database file.\n\t\tvar m1 uint32 = (1 << 32) - 1 // -1 in a uint32\n\t\terr := windows.LockFileEx(windows.Handle(db.file.Fd()), flags, 0, 1, 0, &windows.Overlapped{\n\t\t\tOffset:     m1,\n\t\t\tOffsetHigh: m1,\n\t\t})\n\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t} else if err != windows.ERROR_LOCK_VIOLATION {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we timed oumercit then return an error.\n\t\tif timeout != 0 && time.Since(t) > timeout-flockRetryTimeout {\n\t\t\treturn errors.ErrTimeout\n\t\t}\n\n\t\t// Wait for a bit and try again.\n\t\ttime.Sleep(flockRetryTimeout)\n\t}\n}\n\n// funlock releases an advisory lock on a file descriptor.\nfunc funlock(db *DB) error {\n\tvar m1 uint32 = (1 << 32) - 1 // -1 in a uint32\n\treturn windows.UnlockFileEx(windows.Handle(db.file.Fd()), 0, 1, 0, &windows.Overlapped{\n\t\tOffset:     m1,\n\t\tOffsetHigh: m1,\n\t})\n}\n\n// mmap memory maps a DB's data file.\n// Based on: https://github.com/edsrzf/mmap-go\nfunc mmap(db *DB, sz int) error {\n\tvar sizelo, sizehi uint32\n\n\tif !db.readOnly {\n\t\t// Truncate the database to the size of the mmap.\n\t\tif err := db.file.Truncate(int64(sz)); err != nil {\n\t\t\treturn fmt.Errorf(\"truncate: %s\", err)\n\t\t}\n\t\tsizehi = uint32(sz >> 32)\n\t\tsizelo = uint32(sz)\n\t}\n\n\t// Open a file mapping handle.\n\th, errno := syscall.CreateFileMapping(syscall.Handle(db.file.Fd()), nil, syscall.PAGE_READONLY, sizehi, sizelo, nil)\n\tif h == 0 {\n\t\treturn os.NewSyscallError(\"CreateFileMapping\", errno)\n\t}\n\n\t// Create the memory map.\n\taddr, errno := syscall.MapViewOfFile(h, syscall.FILE_MAP_READ, 0, 0, 0)\n\tif addr == 0 {\n\t\t// Do our best and report error returned from MapViewOfFile.\n\t\t_ = syscall.CloseHandle(h)\n\t\treturn os.NewSyscallError(\"MapViewOfFile\", errno)\n\t}\n\n\t// Close mapping handle.\n\tif err := syscall.CloseHandle(syscall.Handle(h)); err != nil {\n\t\treturn os.NewSyscallError(\"CloseHandle\", err)\n\t}\n\n\t// Convert to a byte array.\n\tdb.data = (*[maxMapSize]byte)(unsafe.Pointer(addr))\n\tdb.datasz = sz\n\n\treturn nil\n}\n\n// munmap unmaps a pointer from a file.\n// Based on: https://github.com/edsrzf/mmap-go\nfunc munmap(db *DB) error {\n\tif db.data == nil {\n\t\treturn nil\n\t}\n\n\taddr := (uintptr)(unsafe.Pointer(&db.data[0]))\n\tvar err1 error\n\tif err := syscall.UnmapViewOfFile(addr); err != nil {\n\t\terr1 = os.NewSyscallError(\"UnmapViewOfFile\", err)\n\t}\n\tdb.data = nil\n\tdb.datasz = 0\n\treturn err1\n}\n"
        },
        {
          "name": "boltsync_unix.go",
          "type": "blob",
          "size": 0.17578125,
          "content": "//go:build !windows && !plan9 && !linux && !openbsd\n\npackage bbolt\n\n// fdatasync flushes written data to a file descriptor.\nfunc fdatasync(db *DB) error {\n\treturn db.file.Sync()\n}\n"
        },
        {
          "name": "bucket.go",
          "type": "blob",
          "size": 28.0810546875,
          "content": "package bbolt\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"unsafe\"\n\n\t\"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\nconst (\n\t// MaxKeySize is the maximum length of a key, in bytes.\n\tMaxKeySize = 32768\n\n\t// MaxValueSize is the maximum length of a value, in bytes.\n\tMaxValueSize = (1 << 31) - 2\n)\n\nconst (\n\tminFillPercent = 0.1\n\tmaxFillPercent = 1.0\n)\n\n// DefaultFillPercent is the percentage that split pages are filled.\n// This value can be changed by setting Bucket.FillPercent.\nconst DefaultFillPercent = 0.5\n\n// Bucket represents a collection of key/value pairs inside the database.\ntype Bucket struct {\n\t*common.InBucket\n\ttx       *Tx                   // the associated transaction\n\tbuckets  map[string]*Bucket    // subbucket cache\n\tpage     *common.Page          // inline page reference\n\trootNode *node                 // materialized node for the root page.\n\tnodes    map[common.Pgid]*node // node cache\n\n\t// Sets the threshold for filling nodes when they split. By default,\n\t// the bucket will fill to 50% but it can be useful to increase this\n\t// amount if you know that your write workloads are mostly append-only.\n\t//\n\t// This is non-persisted across transactions so it must be set in every Tx.\n\tFillPercent float64\n}\n\n// newBucket returns a new bucket associated with a transaction.\nfunc newBucket(tx *Tx) Bucket {\n\tvar b = Bucket{tx: tx, FillPercent: DefaultFillPercent}\n\tif tx.writable {\n\t\tb.buckets = make(map[string]*Bucket)\n\t\tb.nodes = make(map[common.Pgid]*node)\n\t}\n\treturn b\n}\n\n// Tx returns the tx of the bucket.\nfunc (b *Bucket) Tx() *Tx {\n\treturn b.tx\n}\n\n// Root returns the root of the bucket.\nfunc (b *Bucket) Root() common.Pgid {\n\treturn b.RootPage()\n}\n\n// Writable returns whether the bucket is writable.\nfunc (b *Bucket) Writable() bool {\n\treturn b.tx.writable\n}\n\n// Cursor creates a cursor associated with the bucket.\n// The cursor is only valid as long as the transaction is open.\n// Do not use a cursor after the transaction is closed.\nfunc (b *Bucket) Cursor() *Cursor {\n\t// Update transaction statistics.\n\tb.tx.stats.IncCursorCount(1)\n\n\t// Allocate and return a cursor.\n\treturn &Cursor{\n\t\tbucket: b,\n\t\tstack:  make([]elemRef, 0),\n\t}\n}\n\n// Bucket retrieves a nested bucket by name.\n// Returns nil if the bucket does not exist.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (b *Bucket) Bucket(name []byte) *Bucket {\n\tif b.buckets != nil {\n\t\tif child := b.buckets[string(name)]; child != nil {\n\t\t\treturn child\n\t\t}\n\t}\n\n\t// Move cursor to key.\n\tc := b.Cursor()\n\tk, v, flags := c.seek(name)\n\n\t// Return nil if the key doesn't exist or it is not a bucket.\n\tif !bytes.Equal(name, k) || (flags&common.BucketLeafFlag) == 0 {\n\t\treturn nil\n\t}\n\n\t// Otherwise create a bucket and cache it.\n\tvar child = b.openBucket(v)\n\tif b.buckets != nil {\n\t\tb.buckets[string(name)] = child\n\t}\n\n\treturn child\n}\n\n// Helper method that re-interprets a sub-bucket value\n// from a parent into a Bucket\nfunc (b *Bucket) openBucket(value []byte) *Bucket {\n\tvar child = newBucket(b.tx)\n\n\t// Unaligned access requires a copy to be made.\n\tconst unalignedMask = unsafe.Alignof(struct {\n\t\tcommon.InBucket\n\t\tcommon.Page\n\t}{}) - 1\n\tunaligned := uintptr(unsafe.Pointer(&value[0]))&unalignedMask != 0\n\tif unaligned {\n\t\tvalue = cloneBytes(value)\n\t}\n\n\t// If this is a writable transaction then we need to copy the bucket entry.\n\t// Read-only transactions can point directly at the mmap entry.\n\tif b.tx.writable && !unaligned {\n\t\tchild.InBucket = &common.InBucket{}\n\t\t*child.InBucket = *(*common.InBucket)(unsafe.Pointer(&value[0]))\n\t} else {\n\t\tchild.InBucket = (*common.InBucket)(unsafe.Pointer(&value[0]))\n\t}\n\n\t// Save a reference to the inline page if the bucket is inline.\n\tif child.RootPage() == 0 {\n\t\tchild.page = (*common.Page)(unsafe.Pointer(&value[common.BucketHeaderSize]))\n\t}\n\n\treturn &child\n}\n\n// CreateBucket creates a new bucket at the given key and returns the new bucket.\n// Returns an error if the key already exists, if the bucket name is blank, or if the bucket name is too long.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (b *Bucket) CreateBucket(key []byte) (rb *Bucket, err error) {\n\tif lg := b.tx.db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Creating bucket %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Creating bucket %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Creating bucket %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\tif b.tx.db == nil {\n\t\treturn nil, errors.ErrTxClosed\n\t} else if !b.tx.writable {\n\t\treturn nil, errors.ErrTxNotWritable\n\t} else if len(key) == 0 {\n\t\treturn nil, errors.ErrBucketNameRequired\n\t}\n\n\t// Insert into node.\n\t// Tip: Use a new variable `newKey` instead of reusing the existing `key` to prevent\n\t// it from being marked as leaking, and accordingly cannot be allocated on stack.\n\tnewKey := cloneBytes(key)\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, _, flags := c.seek(newKey)\n\n\t// Return an error if there is an existing key.\n\tif bytes.Equal(newKey, k) {\n\t\tif (flags & common.BucketLeafFlag) != 0 {\n\t\t\treturn nil, errors.ErrBucketExists\n\t\t}\n\t\treturn nil, errors.ErrIncompatibleValue\n\t}\n\n\t// Create empty, inline bucket.\n\tvar bucket = Bucket{\n\t\tInBucket:    &common.InBucket{},\n\t\trootNode:    &node{isLeaf: true},\n\t\tFillPercent: DefaultFillPercent,\n\t}\n\tvar value = bucket.write()\n\n\tc.node().put(newKey, newKey, value, 0, common.BucketLeafFlag)\n\n\t// Since subbuckets are not allowed on inline buckets, we need to\n\t// dereference the inline page, if it exists. This will cause the bucket\n\t// to be treated as a regular, non-inline bucket for the rest of the tx.\n\tb.page = nil\n\n\treturn b.Bucket(newKey), nil\n}\n\n// CreateBucketIfNotExists creates a new bucket if it doesn't already exist and returns a reference to it.\n// Returns an error if the bucket name is blank, or if the bucket name is too long.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (b *Bucket) CreateBucketIfNotExists(key []byte) (rb *Bucket, err error) {\n\tif lg := b.tx.db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Creating bucket if not exist %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Creating bucket if not exist %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Creating bucket if not exist %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif b.tx.db == nil {\n\t\treturn nil, errors.ErrTxClosed\n\t} else if !b.tx.writable {\n\t\treturn nil, errors.ErrTxNotWritable\n\t} else if len(key) == 0 {\n\t\treturn nil, errors.ErrBucketNameRequired\n\t}\n\n\t// Insert into node.\n\t// Tip: Use a new variable `newKey` instead of reusing the existing `key` to prevent\n\t// it from being marked as leaking, and accordingly cannot be allocated on stack.\n\tnewKey := cloneBytes(key)\n\n\tif b.buckets != nil {\n\t\tif child := b.buckets[string(newKey)]; child != nil {\n\t\t\treturn child, nil\n\t\t}\n\t}\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, v, flags := c.seek(newKey)\n\n\t// Return an error if there is an existing non-bucket key.\n\tif bytes.Equal(newKey, k) {\n\t\tif (flags & common.BucketLeafFlag) != 0 {\n\t\t\tvar child = b.openBucket(v)\n\t\t\tif b.buckets != nil {\n\t\t\t\tb.buckets[string(newKey)] = child\n\t\t\t}\n\n\t\t\treturn child, nil\n\t\t}\n\t\treturn nil, errors.ErrIncompatibleValue\n\t}\n\n\t// Create empty, inline bucket.\n\tvar bucket = Bucket{\n\t\tInBucket:    &common.InBucket{},\n\t\trootNode:    &node{isLeaf: true},\n\t\tFillPercent: DefaultFillPercent,\n\t}\n\tvar value = bucket.write()\n\n\tc.node().put(newKey, newKey, value, 0, common.BucketLeafFlag)\n\n\t// Since subbuckets are not allowed on inline buckets, we need to\n\t// dereference the inline page, if it exists. This will cause the bucket\n\t// to be treated as a regular, non-inline bucket for the rest of the tx.\n\tb.page = nil\n\n\treturn b.Bucket(newKey), nil\n}\n\n// DeleteBucket deletes a bucket at the given key.\n// Returns an error if the bucket does not exist, or if the key represents a non-bucket value.\nfunc (b *Bucket) DeleteBucket(key []byte) (err error) {\n\tif lg := b.tx.db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Deleting bucket %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Deleting bucket %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Deleting bucket %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !b.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t}\n\n\tnewKey := cloneBytes(key)\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, _, flags := c.seek(newKey)\n\n\t// Return an error if bucket doesn't exist or is not a bucket.\n\tif !bytes.Equal(newKey, k) {\n\t\treturn errors.ErrBucketNotFound\n\t} else if (flags & common.BucketLeafFlag) == 0 {\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\n\t// Recursively delete all child buckets.\n\tchild := b.Bucket(newKey)\n\terr = child.ForEachBucket(func(k []byte) error {\n\t\tif err := child.DeleteBucket(k); err != nil {\n\t\t\treturn fmt.Errorf(\"delete bucket: %s\", err)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Remove cached copy.\n\tdelete(b.buckets, string(newKey))\n\n\t// Release all bucket pages to freelist.\n\tchild.nodes = nil\n\tchild.rootNode = nil\n\tchild.free()\n\n\t// Delete the node if we have a matching key.\n\tc.node().del(newKey)\n\n\treturn nil\n}\n\n// MoveBucket moves a sub-bucket from the source bucket to the destination bucket.\n// Returns an error if\n//  1. the sub-bucket cannot be found in the source bucket;\n//  2. or the key already exists in the destination bucket;\n//  3. or the key represents a non-bucket value;\n//  4. the source and destination buckets are the same.\nfunc (b *Bucket) MoveBucket(key []byte, dstBucket *Bucket) (err error) {\n\tlg := b.tx.db.Logger()\n\tif lg != discardLogger {\n\t\tlg.Debugf(\"Moving bucket %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Moving bucket %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Moving bucket %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif b.tx.db == nil || dstBucket.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !b.Writable() || !dstBucket.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t}\n\n\tif b.tx.db.Path() != dstBucket.tx.db.Path() || b.tx != dstBucket.tx {\n\t\tlg.Errorf(\"The source and target buckets are not in the same db file, source bucket in %s and target bucket in %s\", b.tx.db.Path(), dstBucket.tx.db.Path())\n\t\treturn errors.ErrDifferentDB\n\t}\n\n\tnewKey := cloneBytes(key)\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, v, flags := c.seek(newKey)\n\n\t// Return an error if bucket doesn't exist or is not a bucket.\n\tif !bytes.Equal(newKey, k) {\n\t\treturn errors.ErrBucketNotFound\n\t} else if (flags & common.BucketLeafFlag) == 0 {\n\t\tlg.Errorf(\"An incompatible key %s exists in the source bucket\", newKey)\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\n\t// Do nothing (return true directly) if the source bucket and the\n\t// destination bucket are actually the same bucket.\n\tif b == dstBucket || (b.RootPage() == dstBucket.RootPage() && b.RootPage() != 0) {\n\t\tlg.Errorf(\"The source bucket (%s) and the target bucket (%s) are the same bucket\", b, dstBucket)\n\t\treturn errors.ErrSameBuckets\n\t}\n\n\t// check whether the key already exists in the destination bucket\n\tcurDst := dstBucket.Cursor()\n\tk, _, flags = curDst.seek(newKey)\n\n\t// Return an error if there is an existing key in the destination bucket.\n\tif bytes.Equal(newKey, k) {\n\t\tif (flags & common.BucketLeafFlag) != 0 {\n\t\t\treturn errors.ErrBucketExists\n\t\t}\n\t\tlg.Errorf(\"An incompatible key %s exists in the target bucket\", newKey)\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\n\t// remove the sub-bucket from the source bucket\n\tdelete(b.buckets, string(newKey))\n\tc.node().del(newKey)\n\n\t// add te sub-bucket to the destination bucket\n\tnewValue := cloneBytes(v)\n\tcurDst.node().put(newKey, newKey, newValue, 0, common.BucketLeafFlag)\n\n\treturn nil\n}\n\n// Inspect returns the structure of the bucket.\nfunc (b *Bucket) Inspect() BucketStructure {\n\treturn b.recursivelyInspect([]byte(\"root\"))\n}\n\nfunc (b *Bucket) recursivelyInspect(name []byte) BucketStructure {\n\tbs := BucketStructure{Name: string(name)}\n\n\tkeyN := 0\n\tc := b.Cursor()\n\tfor k, _, flags := c.first(); k != nil; k, _, flags = c.next() {\n\t\tif flags&common.BucketLeafFlag != 0 {\n\t\t\tchildBucket := b.Bucket(k)\n\t\t\tchildBS := childBucket.recursivelyInspect(k)\n\t\t\tbs.Children = append(bs.Children, childBS)\n\t\t} else {\n\t\t\tkeyN++\n\t\t}\n\t}\n\tbs.KeyN = keyN\n\n\treturn bs\n}\n\n// Get retrieves the value for a key in the bucket.\n// Returns a nil value if the key does not exist or if the key is a nested bucket.\n// The returned value is only valid for the life of the transaction.\n// The returned memory is owned by bbolt and must never be modified; writing to this memory might corrupt the database.\nfunc (b *Bucket) Get(key []byte) []byte {\n\tk, v, flags := b.Cursor().seek(key)\n\n\t// Return nil if this is a bucket.\n\tif (flags & common.BucketLeafFlag) != 0 {\n\t\treturn nil\n\t}\n\n\t// If our target node isn't the same key as what's passed in then return nil.\n\tif !bytes.Equal(key, k) {\n\t\treturn nil\n\t}\n\treturn v\n}\n\n// Put sets the value for a key in the bucket.\n// If the key exist then its previous value will be overwritten.\n// Supplied value must remain valid for the life of the transaction.\n// Returns an error if the bucket was created from a read-only transaction, if the key is blank, if the key is too large, or if the value is too large.\nfunc (b *Bucket) Put(key []byte, value []byte) (err error) {\n\tif lg := b.tx.db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Putting key %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Putting key %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Putting key %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !b.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t} else if len(key) == 0 {\n\t\treturn errors.ErrKeyRequired\n\t} else if len(key) > MaxKeySize {\n\t\treturn errors.ErrKeyTooLarge\n\t} else if int64(len(value)) > MaxValueSize {\n\t\treturn errors.ErrValueTooLarge\n\t}\n\n\t// Insert into node.\n\t// Tip: Use a new variable `newKey` instead of reusing the existing `key` to prevent\n\t// it from being marked as leaking, and accordingly cannot be allocated on stack.\n\tnewKey := cloneBytes(key)\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, _, flags := c.seek(newKey)\n\n\t// Return an error if there is an existing key with a bucket value.\n\tif bytes.Equal(newKey, k) && (flags&common.BucketLeafFlag) != 0 {\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\n\t// gofail: var beforeBucketPut struct{}\n\n\tc.node().put(newKey, newKey, value, 0, 0)\n\n\treturn nil\n}\n\n// Delete removes a key from the bucket.\n// If the key does not exist then nothing is done and a nil error is returned.\n// Returns an error if the bucket was created from a read-only transaction.\nfunc (b *Bucket) Delete(key []byte) (err error) {\n\tif lg := b.tx.db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Deleting key %q\", key)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Deleting key %q failed: %v\", key, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Deleting key %q successfully\", key)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !b.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t}\n\n\t// Move cursor to correct position.\n\tc := b.Cursor()\n\tk, _, flags := c.seek(key)\n\n\t// Return nil if the key doesn't exist.\n\tif !bytes.Equal(key, k) {\n\t\treturn nil\n\t}\n\n\t// Return an error if there is already existing bucket value.\n\tif (flags & common.BucketLeafFlag) != 0 {\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\n\t// Delete the node if we have a matching key.\n\tc.node().del(key)\n\n\treturn nil\n}\n\n// Sequence returns the current integer for the bucket without incrementing it.\nfunc (b *Bucket) Sequence() uint64 {\n\treturn b.InSequence()\n}\n\n// SetSequence updates the sequence number for the bucket.\nfunc (b *Bucket) SetSequence(v uint64) error {\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !b.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t}\n\n\t// Materialize the root node if it hasn't been already so that the\n\t// bucket will be saved during commit.\n\tif b.rootNode == nil {\n\t\t_ = b.node(b.RootPage(), nil)\n\t}\n\n\t// Set the sequence.\n\tb.SetInSequence(v)\n\treturn nil\n}\n\n// NextSequence returns an autoincrementing integer for the bucket.\nfunc (b *Bucket) NextSequence() (uint64, error) {\n\tif b.tx.db == nil {\n\t\treturn 0, errors.ErrTxClosed\n\t} else if !b.Writable() {\n\t\treturn 0, errors.ErrTxNotWritable\n\t}\n\n\t// Materialize the root node if it hasn't been already so that the\n\t// bucket will be saved during commit.\n\tif b.rootNode == nil {\n\t\t_ = b.node(b.RootPage(), nil)\n\t}\n\n\t// Increment and return the sequence.\n\tb.IncSequence()\n\treturn b.Sequence(), nil\n}\n\n// ForEach executes a function for each key/value pair in a bucket.\n// Because ForEach uses a Cursor, the iteration over keys is in lexicographical order.\n// If the provided function returns an error then the iteration is stopped and\n// the error is returned to the caller. The provided function must not modify\n// the bucket; this will result in undefined behavior.\nfunc (b *Bucket) ForEach(fn func(k, v []byte) error) error {\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t}\n\tc := b.Cursor()\n\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\tif err := fn(k, v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (b *Bucket) ForEachBucket(fn func(k []byte) error) error {\n\tif b.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t}\n\tc := b.Cursor()\n\tfor k, _, flags := c.first(); k != nil; k, _, flags = c.next() {\n\t\tif flags&common.BucketLeafFlag != 0 {\n\t\t\tif err := fn(k); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Stats returns stats on a bucket.\nfunc (b *Bucket) Stats() BucketStats {\n\tvar s, subStats BucketStats\n\tpageSize := b.tx.db.pageSize\n\ts.BucketN += 1\n\tif b.RootPage() == 0 {\n\t\ts.InlineBucketN += 1\n\t}\n\tb.forEachPage(func(p *common.Page, depth int, pgstack []common.Pgid) {\n\t\tif p.IsLeafPage() {\n\t\t\ts.KeyN += int(p.Count())\n\n\t\t\t// used totals the used bytes for the page\n\t\t\tused := common.PageHeaderSize\n\n\t\t\tif p.Count() != 0 {\n\t\t\t\t// If page has any elements, add all element headers.\n\t\t\t\tused += common.LeafPageElementSize * uintptr(p.Count()-1)\n\n\t\t\t\t// Add all element key, value sizes.\n\t\t\t\t// The computation takes advantage of the fact that the position\n\t\t\t\t// of the last element's key/value equals to the total of the sizes\n\t\t\t\t// of all previous elements' keys and values.\n\t\t\t\t// It also includes the last element's header.\n\t\t\t\tlastElement := p.LeafPageElement(p.Count() - 1)\n\t\t\t\tused += uintptr(lastElement.Pos() + lastElement.Ksize() + lastElement.Vsize())\n\t\t\t}\n\n\t\t\tif b.RootPage() == 0 {\n\t\t\t\t// For inlined bucket just update the inline stats\n\t\t\t\ts.InlineBucketInuse += int(used)\n\t\t\t} else {\n\t\t\t\t// For non-inlined bucket update all the leaf stats\n\t\t\t\ts.LeafPageN++\n\t\t\t\ts.LeafInuse += int(used)\n\t\t\t\ts.LeafOverflowN += int(p.Overflow())\n\n\t\t\t\t// Collect stats from sub-buckets.\n\t\t\t\t// Do that by iterating over all element headers\n\t\t\t\t// looking for the ones with the bucketLeafFlag.\n\t\t\t\tfor i := uint16(0); i < p.Count(); i++ {\n\t\t\t\t\te := p.LeafPageElement(i)\n\t\t\t\t\tif (e.Flags() & common.BucketLeafFlag) != 0 {\n\t\t\t\t\t\t// For any bucket element, open the element value\n\t\t\t\t\t\t// and recursively call Stats on the contained bucket.\n\t\t\t\t\t\tsubStats.Add(b.openBucket(e.Value()).Stats())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if p.IsBranchPage() {\n\t\t\ts.BranchPageN++\n\t\t\tlastElement := p.BranchPageElement(p.Count() - 1)\n\n\t\t\t// used totals the used bytes for the page\n\t\t\t// Add header and all element headers.\n\t\t\tused := common.PageHeaderSize + (common.BranchPageElementSize * uintptr(p.Count()-1))\n\n\t\t\t// Add size of all keys and values.\n\t\t\t// Again, use the fact that last element's position equals to\n\t\t\t// the total of key, value sizes of all previous elements.\n\t\t\tused += uintptr(lastElement.Pos() + lastElement.Ksize())\n\t\t\ts.BranchInuse += int(used)\n\t\t\ts.BranchOverflowN += int(p.Overflow())\n\t\t}\n\n\t\t// Keep track of maximum page depth.\n\t\tif depth+1 > s.Depth {\n\t\t\ts.Depth = depth + 1\n\t\t}\n\t})\n\n\t// Alloc stats can be computed from page counts and pageSize.\n\ts.BranchAlloc = (s.BranchPageN + s.BranchOverflowN) * pageSize\n\ts.LeafAlloc = (s.LeafPageN + s.LeafOverflowN) * pageSize\n\n\t// Add the max depth of sub-buckets to get total nested depth.\n\ts.Depth += subStats.Depth\n\t// Add the stats for all sub-buckets\n\ts.Add(subStats)\n\treturn s\n}\n\n// forEachPage iterates over every page in a bucket, including inline pages.\nfunc (b *Bucket) forEachPage(fn func(*common.Page, int, []common.Pgid)) {\n\t// If we have an inline page then just use that.\n\tif b.page != nil {\n\t\tfn(b.page, 0, []common.Pgid{b.RootPage()})\n\t\treturn\n\t}\n\n\t// Otherwise traverse the page hierarchy.\n\tb.tx.forEachPage(b.RootPage(), fn)\n}\n\n// forEachPageNode iterates over every page (or node) in a bucket.\n// This also includes inline pages.\nfunc (b *Bucket) forEachPageNode(fn func(*common.Page, *node, int)) {\n\t// If we have an inline page or root node then just use that.\n\tif b.page != nil {\n\t\tfn(b.page, nil, 0)\n\t\treturn\n\t}\n\tb._forEachPageNode(b.RootPage(), 0, fn)\n}\n\nfunc (b *Bucket) _forEachPageNode(pgId common.Pgid, depth int, fn func(*common.Page, *node, int)) {\n\tvar p, n = b.pageNode(pgId)\n\n\t// Execute function.\n\tfn(p, n, depth)\n\n\t// Recursively loop over children.\n\tif p != nil {\n\t\tif p.IsBranchPage() {\n\t\t\tfor i := 0; i < int(p.Count()); i++ {\n\t\t\t\telem := p.BranchPageElement(uint16(i))\n\t\t\t\tb._forEachPageNode(elem.Pgid(), depth+1, fn)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif !n.isLeaf {\n\t\t\tfor _, inode := range n.inodes {\n\t\t\t\tb._forEachPageNode(inode.Pgid(), depth+1, fn)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// spill writes all the nodes for this bucket to dirty pages.\nfunc (b *Bucket) spill() error {\n\t// Spill all child buckets first.\n\tfor name, child := range b.buckets {\n\t\t// If the child bucket is small enough and it has no child buckets then\n\t\t// write it inline into the parent bucket's page. Otherwise spill it\n\t\t// like a normal bucket and make the parent value a pointer to the page.\n\t\tvar value []byte\n\t\tif child.inlineable() {\n\t\t\tchild.free()\n\t\t\tvalue = child.write()\n\t\t} else {\n\t\t\tif err := child.spill(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Update the child bucket header in this bucket.\n\t\t\tvalue = make([]byte, unsafe.Sizeof(common.InBucket{}))\n\t\t\tvar bucket = (*common.InBucket)(unsafe.Pointer(&value[0]))\n\t\t\t*bucket = *child.InBucket\n\t\t}\n\n\t\t// Skip writing the bucket if there are no materialized nodes.\n\t\tif child.rootNode == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Update parent node.\n\t\tvar c = b.Cursor()\n\t\tk, _, flags := c.seek([]byte(name))\n\t\tif !bytes.Equal([]byte(name), k) {\n\t\t\tpanic(fmt.Sprintf(\"misplaced bucket header: %x -> %x\", []byte(name), k))\n\t\t}\n\t\tif flags&common.BucketLeafFlag == 0 {\n\t\t\tpanic(fmt.Sprintf(\"unexpected bucket header flag: %x\", flags))\n\t\t}\n\t\tc.node().put([]byte(name), []byte(name), value, 0, common.BucketLeafFlag)\n\t}\n\n\t// Ignore if there's not a materialized root node.\n\tif b.rootNode == nil {\n\t\treturn nil\n\t}\n\n\t// Spill nodes.\n\tif err := b.rootNode.spill(); err != nil {\n\t\treturn err\n\t}\n\tb.rootNode = b.rootNode.root()\n\n\t// Update the root node for this bucket.\n\tif b.rootNode.pgid >= b.tx.meta.Pgid() {\n\t\tpanic(fmt.Sprintf(\"pgid (%d) above high water mark (%d)\", b.rootNode.pgid, b.tx.meta.Pgid()))\n\t}\n\tb.SetRootPage(b.rootNode.pgid)\n\n\treturn nil\n}\n\n// inlineable returns true if a bucket is small enough to be written inline\n// and if it contains no subbuckets. Otherwise, returns false.\nfunc (b *Bucket) inlineable() bool {\n\tvar n = b.rootNode\n\n\t// Bucket must only contain a single leaf node.\n\tif n == nil || !n.isLeaf {\n\t\treturn false\n\t}\n\n\t// Bucket is not inlineable if it contains subbuckets or if it goes beyond\n\t// our threshold for inline bucket size.\n\tvar size = common.PageHeaderSize\n\tfor _, inode := range n.inodes {\n\t\tsize += common.LeafPageElementSize + uintptr(len(inode.Key())) + uintptr(len(inode.Value()))\n\n\t\tif inode.Flags()&common.BucketLeafFlag != 0 {\n\t\t\treturn false\n\t\t} else if size > b.maxInlineBucketSize() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Returns the maximum total size of a bucket to make it a candidate for inlining.\nfunc (b *Bucket) maxInlineBucketSize() uintptr {\n\treturn uintptr(b.tx.db.pageSize / 4)\n}\n\n// write allocates and writes a bucket to a byte slice.\nfunc (b *Bucket) write() []byte {\n\t// Allocate the appropriate size.\n\tvar n = b.rootNode\n\tvar value = make([]byte, common.BucketHeaderSize+n.size())\n\n\t// Write a bucket header.\n\tvar bucket = (*common.InBucket)(unsafe.Pointer(&value[0]))\n\t*bucket = *b.InBucket\n\n\t// Convert byte slice to a fake page and write the root node.\n\tvar p = (*common.Page)(unsafe.Pointer(&value[common.BucketHeaderSize]))\n\tn.write(p)\n\n\treturn value\n}\n\n// rebalance attempts to balance all nodes.\nfunc (b *Bucket) rebalance() {\n\tfor _, n := range b.nodes {\n\t\tn.rebalance()\n\t}\n\tfor _, child := range b.buckets {\n\t\tchild.rebalance()\n\t}\n}\n\n// node creates a node from a page and associates it with a given parent.\nfunc (b *Bucket) node(pgId common.Pgid, parent *node) *node {\n\tcommon.Assert(b.nodes != nil, \"nodes map expected\")\n\n\t// Retrieve node if it's already been created.\n\tif n := b.nodes[pgId]; n != nil {\n\t\treturn n\n\t}\n\n\t// Otherwise create a node and cache it.\n\tn := &node{bucket: b, parent: parent}\n\tif parent == nil {\n\t\tb.rootNode = n\n\t} else {\n\t\tparent.children = append(parent.children, n)\n\t}\n\n\t// Use the inline page if this is an inline bucket.\n\tvar p = b.page\n\tif p == nil {\n\t\tp = b.tx.page(pgId)\n\t} else {\n\t\t// if p isn't nil, then it's an inline bucket.\n\t\t// The pgId must be 0 in this case.\n\t\tcommon.Verify(func() {\n\t\t\tcommon.Assert(pgId == 0, \"The page ID (%d) isn't 0 for an inline bucket\", pgId)\n\t\t})\n\t}\n\n\t// Read the page into the node and cache it.\n\tn.read(p)\n\tb.nodes[pgId] = n\n\n\t// Update statistics.\n\tb.tx.stats.IncNodeCount(1)\n\n\treturn n\n}\n\n// free recursively frees all pages in the bucket.\nfunc (b *Bucket) free() {\n\tif b.RootPage() == 0 {\n\t\treturn\n\t}\n\n\tvar tx = b.tx\n\tb.forEachPageNode(func(p *common.Page, n *node, _ int) {\n\t\tif p != nil {\n\t\t\ttx.db.freelist.Free(tx.meta.Txid(), p)\n\t\t} else {\n\t\t\tn.free()\n\t\t}\n\t})\n\tb.SetRootPage(0)\n}\n\n// dereference removes all references to the old mmap.\nfunc (b *Bucket) dereference() {\n\tif b.rootNode != nil {\n\t\tb.rootNode.root().dereference()\n\t}\n\n\tfor _, child := range b.buckets {\n\t\tchild.dereference()\n\t}\n}\n\n// pageNode returns the in-memory node, if it exists.\n// Otherwise, returns the underlying page.\nfunc (b *Bucket) pageNode(id common.Pgid) (*common.Page, *node) {\n\t// Inline buckets have a fake page embedded in their value so treat them\n\t// differently. We'll return the rootNode (if available) or the fake page.\n\tif b.RootPage() == 0 {\n\t\tif id != 0 {\n\t\t\tpanic(fmt.Sprintf(\"inline bucket non-zero page access(2): %d != 0\", id))\n\t\t}\n\t\tif b.rootNode != nil {\n\t\t\treturn nil, b.rootNode\n\t\t}\n\t\treturn b.page, nil\n\t}\n\n\t// Check the node cache for non-inline buckets.\n\tif b.nodes != nil {\n\t\tif n := b.nodes[id]; n != nil {\n\t\t\treturn nil, n\n\t\t}\n\t}\n\n\t// Finally lookup the page from the transaction if no node is materialized.\n\treturn b.tx.page(id), nil\n}\n\n// BucketStats records statistics about resources used by a bucket.\ntype BucketStats struct {\n\t// Page count statistics.\n\tBranchPageN     int // number of logical branch pages\n\tBranchOverflowN int // number of physical branch overflow pages\n\tLeafPageN       int // number of logical leaf pages\n\tLeafOverflowN   int // number of physical leaf overflow pages\n\n\t// Tree statistics.\n\tKeyN  int // number of keys/value pairs\n\tDepth int // number of levels in B+tree\n\n\t// Page size utilization.\n\tBranchAlloc int // bytes allocated for physical branch pages\n\tBranchInuse int // bytes actually used for branch data\n\tLeafAlloc   int // bytes allocated for physical leaf pages\n\tLeafInuse   int // bytes actually used for leaf data\n\n\t// Bucket statistics\n\tBucketN           int // total number of buckets including the top bucket\n\tInlineBucketN     int // total number on inlined buckets\n\tInlineBucketInuse int // bytes used for inlined buckets (also accounted for in LeafInuse)\n}\n\nfunc (s *BucketStats) Add(other BucketStats) {\n\ts.BranchPageN += other.BranchPageN\n\ts.BranchOverflowN += other.BranchOverflowN\n\ts.LeafPageN += other.LeafPageN\n\ts.LeafOverflowN += other.LeafOverflowN\n\ts.KeyN += other.KeyN\n\tif s.Depth < other.Depth {\n\t\ts.Depth = other.Depth\n\t}\n\ts.BranchAlloc += other.BranchAlloc\n\ts.BranchInuse += other.BranchInuse\n\ts.LeafAlloc += other.LeafAlloc\n\ts.LeafInuse += other.LeafInuse\n\n\ts.BucketN += other.BucketN\n\ts.InlineBucketN += other.InlineBucketN\n\ts.InlineBucketInuse += other.InlineBucketInuse\n}\n\n// cloneBytes returns a copy of a given slice.\nfunc cloneBytes(v []byte) []byte {\n\tvar clone = make([]byte, len(v))\n\tcopy(clone, v)\n\treturn clone\n}\n\ntype BucketStructure struct {\n\tName     string            `json:\"name\"`              // name of the bucket\n\tKeyN     int               `json:\"keyN\"`              // number of key/value pairs\n\tChildren []BucketStructure `json:\"buckets,omitempty\"` // child buckets\n}\n"
        },
        {
          "name": "bucket_test.go",
          "type": "blob",
          "size": 52.458984375,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/quick\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\tberrors \"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\n// Ensure that a bucket that gets a non-existent key returns nil.\nfunc TestBucket_Get_NonExistent(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v := b.Get([]byte(\"foo\")); v != nil {\n\t\t\tt.Fatal(\"expected nil value\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can read a value that is not flushed yet.\nfunc TestBucket_Get_FromNode(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v := b.Get([]byte(\"foo\")); !bytes.Equal(v, []byte(\"bar\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket retrieved via Get() returns a nil.\nfunc TestBucket_Get_IncompatibleValue(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif _, err := tx.Bucket([]byte(\"widgets\")).CreateBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\")) != nil {\n\t\t\tt.Fatal(\"expected nil value\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a slice returned from a bucket has a capacity equal to its length.\n// This also allows slices to be appended to since it will require a realloc by Go.\n//\n// https://github.com/boltdb/bolt/issues/544\nfunc TestBucket_Get_Capacity(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Write key to a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"bucket\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"val\"))\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Retrieve value and attempt to append to it.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tk, v := tx.Bucket([]byte(\"bucket\")).Cursor().First()\n\n\t\t// Verify capacity.\n\t\tif len(k) != cap(k) {\n\t\t\tt.Fatalf(\"unexpected key slice capacity: %d\", cap(k))\n\t\t} else if len(v) != cap(v) {\n\t\t\tt.Fatalf(\"unexpected value slice capacity: %d\", cap(v))\n\t\t}\n\n\t\t// Ensure slice can be appended to without a segfault.\n\t\tk = append(k, []byte(\"123\")...)\n\t\tv = append(v, []byte(\"123\")...)\n\t\t_, _ = k, v // to pass ineffassign\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can write a key/value.\nfunc TestBucket_Put(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tv := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tif !bytes.Equal([]byte(\"bar\"), v) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can rewrite a key in the same transaction.\nfunc TestBucket_Put_Repeat(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"baz\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tif !bytes.Equal([]byte(\"baz\"), value) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", value)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can write a bunch of large values.\nfunc TestBucket_Put_Large(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tcount, factor := 100, 200\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor i := 1; i < count; i++ {\n\t\t\tif err := b.Put([]byte(strings.Repeat(\"0\", i*factor)), []byte(strings.Repeat(\"X\", (count-i)*factor))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 1; i < count; i++ {\n\t\t\tvalue := b.Get([]byte(strings.Repeat(\"0\", i*factor)))\n\t\t\tif !bytes.Equal(value, []byte(strings.Repeat(\"X\", (count-i)*factor))) {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", value)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a database can perform multiple large appends safely.\nfunc TestDB_Put_VeryLarge(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tn, batchN := 400000, 200000\n\tksize, vsize := 8, 500\n\n\tdb := btesting.MustCreateDB(t)\n\n\tfor i := 0; i < n; i += batchN {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"widgets\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tfor j := 0; j < batchN; j++ {\n\t\t\t\tk, v := make([]byte, ksize), make([]byte, vsize)\n\t\t\t\tbinary.BigEndian.PutUint32(k, uint32(i+j))\n\t\t\t\tif err := b.Put(k, v); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\n// Ensure that a setting a value on a key with a bucket value returns an error.\nfunc TestBucket_Put_IncompatibleValue(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb0, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif _, err := tx.Bucket([]byte(\"widgets\")).CreateBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b0.Put([]byte(\"foo\"), []byte(\"bar\")); err != berrors.ErrIncompatibleValue {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a setting a value while the transaction is closed returns an error.\nfunc TestBucket_Put_Closed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that setting a value on a read-only bucket returns an error.\nfunc TestBucket_Put_ReadOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != berrors.ErrTxNotWritable {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can delete an existing key.\nfunc TestBucket_Delete(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Delete([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v := b.Get([]byte(\"foo\")); v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a large set of keys will work correctly.\nfunc TestBucket_Delete_Large(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif err := b.Put([]byte(strconv.Itoa(i)), []byte(strings.Repeat(\"*\", 1024))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif err := b.Delete([]byte(strconv.Itoa(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif v := b.Get([]byte(strconv.Itoa(i))); v != nil {\n\t\t\t\tt.Fatalf(\"unexpected value: %v, i=%d\", v, i)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Deleting a very large list of keys will cause the freelist to use overflow.\nfunc TestBucket_Delete_FreelistOverflow(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tdb := btesting.MustCreateDB(t)\n\n\tk := make([]byte, 16)\n\t// The bigger the pages - the more values we need to write.\n\tfor i := uint64(0); i < 2*uint64(db.Info().PageSize); i++ {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"0\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"bucket error: %s\", err)\n\t\t\t}\n\n\t\t\tfor j := uint64(0); j < 1000; j++ {\n\t\t\t\tbinary.BigEndian.PutUint64(k[:8], i)\n\t\t\t\tbinary.BigEndian.PutUint64(k[8:], j)\n\t\t\t\tif err := b.Put(k, nil); err != nil {\n\t\t\t\t\tt.Fatalf(\"put error: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Delete all of them in one large transaction\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"0\"))\n\t\tc := b.Cursor()\n\t\tfor k, _ := c.First(); k != nil; k, _ = c.Next() {\n\t\t\tif err := c.Delete(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check more than an overflow's worth of pages are freed.\n\tstats := db.Stats()\n\tfreePages := stats.FreePageN + stats.PendingPageN\n\tif freePages <= 0xFFFF {\n\t\tt.Fatalf(\"expected more than 0xFFFF free pages, got %v\", freePages)\n\t}\n\n\t// Free page count should be preserved on reopen.\n\tdb.MustClose()\n\tdb.MustReopen()\n\tif reopenFreePages := db.Stats().FreePageN; freePages != reopenFreePages {\n\t\tt.Fatalf(\"expected %d free pages, got %+v\", freePages, db.Stats())\n\t}\n\tif reopenPendingPages := db.Stats().PendingPageN; reopenPendingPages != 0 {\n\t\tt.Fatalf(\"expected no pending pages, got %+v\", db.Stats())\n\t}\n}\n\n// Ensure that deleting of non-existing key is a no-op.\nfunc TestBucket_Delete_NonExisting(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif _, err = b.CreateBucket([]byte(\"nested\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tif err := b.Delete([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b.Bucket([]byte(\"nested\")) == nil {\n\t\t\tt.Fatal(\"nested bucket has been deleted\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that accessing and updating nested buckets is ok across transactions.\nfunc TestBucket_Nested(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create a widgets bucket.\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create a widgets/foo bucket.\n\t\t_, err = b.CreateBucket([]byte(\"foo\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create a widgets/bar key.\n\t\tif err := b.Put([]byte(\"bar\"), []byte(\"0000\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.MustCheck()\n\n\t// Update widgets/bar.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tif err := b.Put([]byte(\"bar\"), []byte(\"xxxx\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.MustCheck()\n\n\t// Cause a split.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tvar b = tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\tif err := b.Put([]byte(strconv.Itoa(i)), []byte(strconv.Itoa(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.MustCheck()\n\n\t// Insert into widgets/foo/baz.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tvar b = tx.Bucket([]byte(\"widgets\"))\n\t\tif err := b.Bucket([]byte(\"foo\")).Put([]byte(\"baz\"), []byte(\"yyyy\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.MustCheck()\n\n\t// Verify.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvar b = tx.Bucket([]byte(\"widgets\"))\n\t\tif v := b.Bucket([]byte(\"foo\")).Get([]byte(\"baz\")); !bytes.Equal(v, []byte(\"yyyy\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\tif v := b.Get([]byte(\"bar\")); !bytes.Equal(v, []byte(\"xxxx\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\tif v := b.Get([]byte(strconv.Itoa(i))); !bytes.Equal(v, []byte(strconv.Itoa(i))) {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a bucket using Delete() returns an error.\nfunc TestBucket_Delete_Bucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Delete([]byte(\"foo\")); err != berrors.ErrIncompatibleValue {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a key on a read-only bucket returns an error.\nfunc TestBucket_Delete_ReadOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif err := tx.Bucket([]byte(\"widgets\")).Delete([]byte(\"foo\")); err != berrors.ErrTxNotWritable {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a deleting value while the transaction is closed returns an error.\nfunc TestBucket_Delete_Closed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := b.Delete([]byte(\"foo\")); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that deleting a bucket causes nested buckets to be deleted.\nfunc TestBucket_DeleteBucket_Nested(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfoo, err := widgets.CreateBucket([]byte(\"foo\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tbar, err := foo.CreateBucket([]byte(\"bar\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := bar.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := tx.Bucket([]byte(\"widgets\")).DeleteBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a bucket causes nested buckets to be deleted after they have been committed.\nfunc TestBucket_DeleteBucket_Nested2(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfoo, err := widgets.CreateBucket([]byte(\"foo\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tbar, err := foo.CreateBucket([]byte(\"bar\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := bar.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets := tx.Bucket([]byte(\"widgets\"))\n\t\tif widgets == nil {\n\t\t\tt.Fatal(\"expected widgets bucket\")\n\t\t}\n\n\t\tfoo := widgets.Bucket([]byte(\"foo\"))\n\t\tif foo == nil {\n\t\t\tt.Fatal(\"expected foo bucket\")\n\t\t}\n\n\t\tbar := foo.Bucket([]byte(\"bar\"))\n\t\tif bar == nil {\n\t\t\tt.Fatal(\"expected bar bucket\")\n\t\t}\n\n\t\tif v := bar.Get([]byte(\"baz\")); !bytes.Equal(v, []byte(\"bat\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\tif err := tx.DeleteBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif tx.Bucket([]byte(\"widgets\")) != nil {\n\t\t\tt.Fatal(\"expected bucket to be deleted\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a child bucket with multiple pages causes all pages to get collected.\n// NOTE: Consistency check in bolt_test.DB.Close() will panic if pages not freed properly.\nfunc TestBucket_DeleteBucket_Large(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfoo, err := widgets.CreateBucket([]byte(\"foo\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tif err := foo.Put([]byte(fmt.Sprintf(\"%d\", i)), []byte(fmt.Sprintf(\"%0100d\", i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif err := tx.DeleteBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a simple value retrieved via Bucket() returns a nil.\nfunc TestBucket_Bucket_IncompatibleValue(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := widgets.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b := tx.Bucket([]byte(\"widgets\")).Bucket([]byte(\"foo\")); b != nil {\n\t\t\tt.Fatal(\"expected nil bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that creating a bucket on an existing non-bucket key returns an error.\nfunc TestBucket_CreateBucket_IncompatibleValue(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := widgets.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := widgets.CreateBucket([]byte(\"foo\")); err != berrors.ErrIncompatibleValue {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a bucket on an existing non-bucket key returns an error.\nfunc TestBucket_DeleteBucket_IncompatibleValue(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := widgets.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := tx.Bucket([]byte(\"widgets\")).DeleteBucket([]byte(\"foo\")); err != berrors.ErrIncompatibleValue {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure bucket can set and update its sequence number.\nfunc TestBucket_Sequence(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tbkt, err := tx.CreateBucket([]byte(\"0\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Retrieve sequence.\n\t\tif v := bkt.Sequence(); v != 0 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", v)\n\t\t}\n\n\t\t// Update sequence.\n\t\tif err := bkt.SetSequence(1000); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Read sequence again.\n\t\tif v := bkt.Sequence(); v != 1000 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", v)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Verify sequence in separate transaction.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif v := tx.Bucket([]byte(\"0\")).Sequence(); v != 1000 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can return an autoincrementing sequence.\nfunc TestBucket_NextSequence(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\twidgets, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\twoojits, err := tx.CreateBucket([]byte(\"woojits\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Make sure sequence increments.\n\t\tif seq, err := widgets.NextSequence(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if seq != 1 {\n\t\t\tt.Fatalf(\"unexpecte sequence: %d\", seq)\n\t\t}\n\n\t\tif seq, err := widgets.NextSequence(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if seq != 2 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", seq)\n\t\t}\n\n\t\t// Buckets should be separate.\n\t\tif seq, err := woojits.NextSequence(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if seq != 1 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", 1)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket will persist an autoincrementing sequence even if its\n// the only thing updated on the bucket.\n// https://github.com/boltdb/bolt/issues/296\nfunc TestBucket_NextSequence_Persist(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.Bucket([]byte(\"widgets\")).NextSequence(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tseq, err := tx.Bucket([]byte(\"widgets\")).NextSequence()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t} else if seq != 2 {\n\t\t\tt.Fatalf(\"unexpected sequence: %d\", seq)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that retrieving the next sequence on a read-only bucket returns an error.\nfunc TestBucket_NextSequence_ReadOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t_, err := tx.Bucket([]byte(\"widgets\")).NextSequence()\n\t\tif err != berrors.ErrTxNotWritable {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that retrieving the next sequence for a bucket on a closed database return an error.\nfunc TestBucket_NextSequence_Closed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := b.NextSequence(); err != berrors.ErrTxClosed {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a user can loop over all key/value pairs in a bucket.\nfunc TestBucket_ForEach(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\ttype kv struct {\n\t\tk []byte\n\t\tv []byte\n\t}\n\n\texpectedItems := []kv{\n\t\t{k: []byte(\"bar\"), v: []byte(\"0002\")},\n\t\t{k: []byte(\"baz\"), v: []byte(\"0001\")},\n\t\t{k: []byte(\"csubbucket\"), v: nil},\n\t\t{k: []byte(\"foo\"), v: []byte(\"0000\")},\n\t}\n\n\tverifyReads := func(b *bolt.Bucket) {\n\t\tvar items []kv\n\t\terr := b.ForEach(func(k, v []byte) error {\n\t\t\titems = append(items, kv{k: k, v: v})\n\t\t\treturn nil\n\t\t})\n\t\tassert.NoErrorf(t, err, \"b.ForEach failed\")\n\t\tassert.Equal(t, expectedItems, items, \"what we iterated (ForEach) is not what we put\")\n\t}\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\trequire.NoError(t, err, \"bucket creation failed\")\n\n\t\trequire.NoErrorf(t, b.Put([]byte(\"foo\"), []byte(\"0000\")), \"put 'foo' failed\")\n\t\trequire.NoErrorf(t, b.Put([]byte(\"baz\"), []byte(\"0001\")), \"put 'baz' failed\")\n\t\trequire.NoErrorf(t, b.Put([]byte(\"bar\"), []byte(\"0002\")), \"put 'bar' failed\")\n\t\t_, err = b.CreateBucket([]byte(\"csubbucket\"))\n\t\trequire.NoErrorf(t, err, \"creation of subbucket failed\")\n\n\t\tverifyReads(b)\n\n\t\treturn nil\n\t})\n\trequire.NoErrorf(t, err, \"db.Update failed\")\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\trequire.NotNil(t, b, \"bucket opening failed\")\n\t\tverifyReads(b)\n\t\treturn nil\n\t})\n\tassert.NoErrorf(t, err, \"db.View failed\")\n}\n\nfunc TestBucket_ForEachBucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\texpectedItems := [][]byte{\n\t\t[]byte(\"csubbucket\"),\n\t\t[]byte(\"zsubbucket\"),\n\t}\n\n\tverifyReads := func(b *bolt.Bucket) {\n\t\tvar items [][]byte\n\t\terr := b.ForEachBucket(func(k []byte) error {\n\t\t\titems = append(items, k)\n\t\t\treturn nil\n\t\t})\n\t\tassert.NoErrorf(t, err, \"b.ForEach failed\")\n\t\tassert.Equal(t, expectedItems, items, \"what we iterated (ForEach) is not what we put\")\n\t}\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\trequire.NoError(t, err, \"bucket creation failed\")\n\n\t\trequire.NoErrorf(t, b.Put([]byte(\"foo\"), []byte(\"0000\")), \"put 'foo' failed\")\n\t\t_, err = b.CreateBucket([]byte(\"zsubbucket\"))\n\t\trequire.NoErrorf(t, err, \"creation of subbucket failed\")\n\t\trequire.NoErrorf(t, b.Put([]byte(\"baz\"), []byte(\"0001\")), \"put 'baz' failed\")\n\t\trequire.NoErrorf(t, b.Put([]byte(\"bar\"), []byte(\"0002\")), \"put 'bar' failed\")\n\t\t_, err = b.CreateBucket([]byte(\"csubbucket\"))\n\t\trequire.NoErrorf(t, err, \"creation of subbucket failed\")\n\n\t\tverifyReads(b)\n\n\t\treturn nil\n\t})\n\tassert.NoErrorf(t, err, \"db.Update failed\")\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\trequire.NotNil(t, b, \"bucket opening failed\")\n\t\tverifyReads(b)\n\t\treturn nil\n\t})\n\tassert.NoErrorf(t, err, \"db.View failed\")\n}\n\nfunc TestBucket_ForEachBucket_NoBuckets(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tverifyReads := func(b *bolt.Bucket) {\n\t\tvar items [][]byte\n\t\terr := b.ForEachBucket(func(k []byte) error {\n\t\t\titems = append(items, k)\n\t\t\treturn nil\n\t\t})\n\t\tassert.NoErrorf(t, err, \"b.ForEach failed\")\n\t\tassert.Emptyf(t, items, \"what we iterated (ForEach) is not what we put\")\n\t}\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\trequire.NoError(t, err, \"bucket creation failed\")\n\n\t\trequire.NoErrorf(t, b.Put([]byte(\"foo\"), []byte(\"0000\")), \"put 'foo' failed\")\n\t\trequire.NoErrorf(t, err, \"creation of subbucket failed\")\n\t\trequire.NoErrorf(t, b.Put([]byte(\"baz\"), []byte(\"0001\")), \"put 'baz' failed\")\n\t\trequire.NoErrorf(t, err, \"creation of subbucket failed\")\n\n\t\tverifyReads(b)\n\n\t\treturn nil\n\t})\n\trequire.NoErrorf(t, err, \"db.Update failed\")\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\trequire.NotNil(t, b, \"bucket opening failed\")\n\t\tverifyReads(b)\n\t\treturn nil\n\t})\n\tassert.NoErrorf(t, err, \"db.View failed\")\n}\n\n// Ensure a database can stop iteration early.\nfunc TestBucket_ForEach_ShortCircuit(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"bar\"), []byte(\"0000\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"0000\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"0000\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar index int\n\t\tif err := tx.Bucket([]byte(\"widgets\")).ForEach(func(k, v []byte) error {\n\t\t\tindex++\n\t\t\tif bytes.Equal(k, []byte(\"baz\")) {\n\t\t\t\treturn errors.New(\"marker\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err == nil || err.Error() != \"marker\" {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif index != 2 {\n\t\t\tt.Fatalf(\"unexpected index: %d\", index)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that looping over a bucket on a closed database returns an error.\nfunc TestBucket_ForEach_Closed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := b.ForEach(func(k, v []byte) error { return nil }); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that an error is returned when inserting with an empty key.\nfunc TestBucket_Put_EmptyKey(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"\"), []byte(\"bar\")); err != berrors.ErrKeyRequired {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif err := b.Put(nil, []byte(\"bar\")); err != berrors.ErrKeyRequired {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that an error is returned when inserting with a key that's too large.\nfunc TestBucket_Put_KeyTooLarge(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put(make([]byte, 32769), []byte(\"bar\")); err != berrors.ErrKeyTooLarge {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that an error is returned when inserting a value that's too large.\nfunc TestBucket_Put_ValueTooLarge(t *testing.T) {\n\t// Skip this test on DroneCI because the machine is resource constrained.\n\tif os.Getenv(\"DRONE\") == \"true\" {\n\t\tt.Skip(\"not enough RAM for test\")\n\t}\n\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), make([]byte, bolt.MaxValueSize+1)); err != berrors.ErrValueTooLarge {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a bucket can calculate stats.\nfunc TestBucket_Stats(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode\")\n\t}\n\n\tdb := btesting.MustCreateDB(t)\n\n\t// Add bucket with fewer keys but one big value.\n\tbigKey := []byte(\"really-big-value\")\n\tfor i := 0; i < 500; i++ {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"woojits\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif err := b.Put([]byte(fmt.Sprintf(\"%03d\", i)), []byte(strconv.Itoa(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tlongKeyLength := 10*db.Info().PageSize + 17\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif err := tx.Bucket([]byte(\"woojits\")).Put(bigKey, []byte(strings.Repeat(\"*\", longKeyLength))); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb.MustCheck()\n\n\tpageSize2stats := map[int]bolt.BucketStats{\n\t\t4096: {\n\t\t\tBranchPageN:     1,\n\t\t\tBranchOverflowN: 0,\n\t\t\tLeafPageN:       7,\n\t\t\tLeafOverflowN:   10,\n\t\t\tKeyN:            501,\n\t\t\tDepth:           2,\n\t\t\tBranchAlloc:     4096,\n\t\t\tBranchInuse:     149,\n\t\t\tLeafAlloc:       69632,\n\t\t\tLeafInuse: 0 +\n\t\t\t\t7*16 + // leaf page header (x LeafPageN)\n\t\t\t\t501*16 + // leaf elements\n\t\t\t\t500*3 + len(bigKey) + // leaf keys\n\t\t\t\t1*10 + 2*90 + 3*400 + longKeyLength, // leaf values: 10 * 1digit, 90*2digits, ...\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t\t16384: {\n\t\t\tBranchPageN:     1,\n\t\t\tBranchOverflowN: 0,\n\t\t\tLeafPageN:       3,\n\t\t\tLeafOverflowN:   10,\n\t\t\tKeyN:            501,\n\t\t\tDepth:           2,\n\t\t\tBranchAlloc:     16384,\n\t\t\tBranchInuse:     73,\n\t\t\tLeafAlloc:       212992,\n\t\t\tLeafInuse: 0 +\n\t\t\t\t3*16 + // leaf page header (x LeafPageN)\n\t\t\t\t501*16 + // leaf elements\n\t\t\t\t500*3 + len(bigKey) + // leaf keys\n\t\t\t\t1*10 + 2*90 + 3*400 + longKeyLength, // leaf values: 10 * 1digit, 90*2digits, ...\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t\t65536: {\n\t\t\tBranchPageN:     1,\n\t\t\tBranchOverflowN: 0,\n\t\t\tLeafPageN:       2,\n\t\t\tLeafOverflowN:   10,\n\t\t\tKeyN:            501,\n\t\t\tDepth:           2,\n\t\t\tBranchAlloc:     65536,\n\t\t\tBranchInuse:     54,\n\t\t\tLeafAlloc:       786432,\n\t\t\tLeafInuse: 0 +\n\t\t\t\t2*16 + // leaf page header (x LeafPageN)\n\t\t\t\t501*16 + // leaf elements\n\t\t\t\t500*3 + len(bigKey) + // leaf keys\n\t\t\t\t1*10 + 2*90 + 3*400 + longKeyLength, // leaf values: 10 * 1digit, 90*2digits, ...\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tstats := tx.Bucket([]byte(\"woojits\")).Stats()\n\t\tt.Logf(\"Stats: %#v\", stats)\n\t\tif expected, ok := pageSize2stats[db.Info().PageSize]; ok {\n\t\t\tassert.EqualValues(t, expected, stats, \"stats differs from expectations\")\n\t\t} else {\n\t\t\tt.Skipf(\"No expectations for page size: %d\", db.Info().PageSize)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a bucket with random insertion utilizes fill percentage correctly.\nfunc TestBucket_Stats_RandomFill(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t} else if os.Getpagesize() != 4096 {\n\t\tt.Skip(\"invalid page size for test\")\n\t}\n\n\tdb := btesting.MustCreateDB(t)\n\n\t// Add a set of values in random order. It will be the same random\n\t// order so we can maintain consistency between test runs.\n\tvar count int\n\trand := rand.New(rand.NewSource(42))\n\tfor _, i := range rand.Perm(1000) {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"woojits\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tb.FillPercent = 0.9\n\t\t\tfor _, j := range rand.Perm(100) {\n\t\t\t\tindex := (j * 10000) + i\n\t\t\t\tif err := b.Put([]byte(fmt.Sprintf(\"%d000000000000000\", index)), []byte(\"0000000000\")); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tcount++\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tdb.MustCheck()\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tstats := tx.Bucket([]byte(\"woojits\")).Stats()\n\t\tif stats.KeyN != 100000 {\n\t\t\tt.Fatalf(\"unexpected KeyN: %d\", stats.KeyN)\n\t\t}\n\n\t\tif stats.BranchPageN != 98 {\n\t\t\tt.Fatalf(\"unexpected BranchPageN: %d\", stats.BranchPageN)\n\t\t} else if stats.BranchOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchOverflowN: %d\", stats.BranchOverflowN)\n\t\t} else if stats.BranchInuse != 130984 {\n\t\t\tt.Fatalf(\"unexpected BranchInuse: %d\", stats.BranchInuse)\n\t\t} else if stats.BranchAlloc != 401408 {\n\t\t\tt.Fatalf(\"unexpected BranchAlloc: %d\", stats.BranchAlloc)\n\t\t}\n\n\t\tif stats.LeafPageN != 3412 {\n\t\t\tt.Fatalf(\"unexpected LeafPageN: %d\", stats.LeafPageN)\n\t\t} else if stats.LeafOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafOverflowN: %d\", stats.LeafOverflowN)\n\t\t} else if stats.LeafInuse != 4742482 {\n\t\t\tt.Fatalf(\"unexpected LeafInuse: %d\", stats.LeafInuse)\n\t\t} else if stats.LeafAlloc != 13975552 {\n\t\t\tt.Fatalf(\"unexpected LeafAlloc: %d\", stats.LeafAlloc)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a bucket can calculate stats.\nfunc TestBucket_Stats_Small(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Add a bucket that fits on a single root leaf.\n\t\tb, err := tx.CreateBucket([]byte(\"whozawhats\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb.MustCheck()\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"whozawhats\"))\n\t\tstats := b.Stats()\n\t\tif stats.BranchPageN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchPageN: %d\", stats.BranchPageN)\n\t\t} else if stats.BranchOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchOverflowN: %d\", stats.BranchOverflowN)\n\t\t} else if stats.LeafPageN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafPageN: %d\", stats.LeafPageN)\n\t\t} else if stats.LeafOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafOverflowN: %d\", stats.LeafOverflowN)\n\t\t} else if stats.KeyN != 1 {\n\t\t\tt.Fatalf(\"unexpected KeyN: %d\", stats.KeyN)\n\t\t} else if stats.Depth != 1 {\n\t\t\tt.Fatalf(\"unexpected Depth: %d\", stats.Depth)\n\t\t} else if stats.BranchInuse != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchInuse: %d\", stats.BranchInuse)\n\t\t} else if stats.LeafInuse != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafInuse: %d\", stats.LeafInuse)\n\t\t}\n\n\t\tif db.Info().PageSize == 4096 {\n\t\t\tif stats.BranchAlloc != 0 {\n\t\t\t\tt.Fatalf(\"unexpected BranchAlloc: %d\", stats.BranchAlloc)\n\t\t\t} else if stats.LeafAlloc != 0 {\n\t\t\t\tt.Fatalf(\"unexpected LeafAlloc: %d\", stats.LeafAlloc)\n\t\t\t}\n\t\t}\n\n\t\tif stats.BucketN != 1 {\n\t\t\tt.Fatalf(\"unexpected BucketN: %d\", stats.BucketN)\n\t\t} else if stats.InlineBucketN != 1 {\n\t\t\tt.Fatalf(\"unexpected InlineBucketN: %d\", stats.InlineBucketN)\n\t\t} else if stats.InlineBucketInuse != 16+16+6 {\n\t\t\tt.Fatalf(\"unexpected InlineBucketInuse: %d\", stats.InlineBucketInuse)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBucket_Stats_EmptyBucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Add a bucket that fits on a single root leaf.\n\t\tif _, err := tx.CreateBucket([]byte(\"whozawhats\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb.MustCheck()\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"whozawhats\"))\n\t\tstats := b.Stats()\n\t\tif stats.BranchPageN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchPageN: %d\", stats.BranchPageN)\n\t\t} else if stats.BranchOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchOverflowN: %d\", stats.BranchOverflowN)\n\t\t} else if stats.LeafPageN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafPageN: %d\", stats.LeafPageN)\n\t\t} else if stats.LeafOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafOverflowN: %d\", stats.LeafOverflowN)\n\t\t} else if stats.KeyN != 0 {\n\t\t\tt.Fatalf(\"unexpected KeyN: %d\", stats.KeyN)\n\t\t} else if stats.Depth != 1 {\n\t\t\tt.Fatalf(\"unexpected Depth: %d\", stats.Depth)\n\t\t} else if stats.BranchInuse != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchInuse: %d\", stats.BranchInuse)\n\t\t} else if stats.LeafInuse != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafInuse: %d\", stats.LeafInuse)\n\t\t}\n\n\t\tif db.Info().PageSize == 4096 {\n\t\t\tif stats.BranchAlloc != 0 {\n\t\t\t\tt.Fatalf(\"unexpected BranchAlloc: %d\", stats.BranchAlloc)\n\t\t\t} else if stats.LeafAlloc != 0 {\n\t\t\t\tt.Fatalf(\"unexpected LeafAlloc: %d\", stats.LeafAlloc)\n\t\t\t}\n\t\t}\n\n\t\tif stats.BucketN != 1 {\n\t\t\tt.Fatalf(\"unexpected BucketN: %d\", stats.BucketN)\n\t\t} else if stats.InlineBucketN != 1 {\n\t\t\tt.Fatalf(\"unexpected InlineBucketN: %d\", stats.InlineBucketN)\n\t\t} else if stats.InlineBucketInuse != 16 {\n\t\t\tt.Fatalf(\"unexpected InlineBucketInuse: %d\", stats.InlineBucketInuse)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a bucket can calculate stats.\nfunc TestBucket_Stats_Nested(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"foo\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif err := b.Put([]byte(fmt.Sprintf(\"%02d\", i)), []byte(fmt.Sprintf(\"%02d\", i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tbar, err := b.CreateBucket([]byte(\"bar\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif err := bar.Put([]byte(strconv.Itoa(i)), []byte(strconv.Itoa(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tbaz, err := bar.CreateBucket([]byte(\"baz\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif err := baz.Put([]byte(strconv.Itoa(i)), []byte(strconv.Itoa(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb.MustCheck()\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"foo\"))\n\t\tstats := b.Stats()\n\t\tif stats.BranchPageN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchPageN: %d\", stats.BranchPageN)\n\t\t} else if stats.BranchOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchOverflowN: %d\", stats.BranchOverflowN)\n\t\t} else if stats.LeafPageN != 2 {\n\t\t\tt.Fatalf(\"unexpected LeafPageN: %d\", stats.LeafPageN)\n\t\t} else if stats.LeafOverflowN != 0 {\n\t\t\tt.Fatalf(\"unexpected LeafOverflowN: %d\", stats.LeafOverflowN)\n\t\t} else if stats.KeyN != 122 {\n\t\t\tt.Fatalf(\"unexpected KeyN: %d\", stats.KeyN)\n\t\t} else if stats.Depth != 3 {\n\t\t\tt.Fatalf(\"unexpected Depth: %d\", stats.Depth)\n\t\t} else if stats.BranchInuse != 0 {\n\t\t\tt.Fatalf(\"unexpected BranchInuse: %d\", stats.BranchInuse)\n\t\t}\n\n\t\tfoo := 16            // foo (pghdr)\n\t\tfoo += 101 * 16      // foo leaf elements\n\t\tfoo += 100*2 + 100*2 // foo leaf key/values\n\t\tfoo += 3 + 16        // foo -> bar key/value\n\n\t\tbar := 16      // bar (pghdr)\n\t\tbar += 11 * 16 // bar leaf elements\n\t\tbar += 10 + 10 // bar leaf key/values\n\t\tbar += 3 + 16  // bar -> baz key/value\n\n\t\tbaz := 16      // baz (inline) (pghdr)\n\t\tbaz += 10 * 16 // baz leaf elements\n\t\tbaz += 10 + 10 // baz leaf key/values\n\n\t\tif stats.LeafInuse != foo+bar+baz {\n\t\t\tt.Fatalf(\"unexpected LeafInuse: %d\", stats.LeafInuse)\n\t\t}\n\n\t\tif db.Info().PageSize == 4096 {\n\t\t\tif stats.BranchAlloc != 0 {\n\t\t\t\tt.Fatalf(\"unexpected BranchAlloc: %d\", stats.BranchAlloc)\n\t\t\t} else if stats.LeafAlloc != 8192 {\n\t\t\t\tt.Fatalf(\"unexpected LeafAlloc: %d\", stats.LeafAlloc)\n\t\t\t}\n\t\t}\n\n\t\tif stats.BucketN != 3 {\n\t\t\tt.Fatalf(\"unexpected BucketN: %d\", stats.BucketN)\n\t\t} else if stats.InlineBucketN != 1 {\n\t\t\tt.Fatalf(\"unexpected InlineBucketN: %d\", stats.InlineBucketN)\n\t\t} else if stats.InlineBucketInuse != baz {\n\t\t\tt.Fatalf(\"unexpected InlineBucketInuse: %d\", stats.InlineBucketInuse)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBucket_Inspect(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\texpectedStructure := bolt.BucketStructure{\n\t\tName: \"root\",\n\t\tKeyN: 0,\n\t\tChildren: []bolt.BucketStructure{\n\t\t\t{\n\t\t\t\tName: \"b1\",\n\t\t\t\tKeyN: 3,\n\t\t\t\tChildren: []bolt.BucketStructure{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b1_1\",\n\t\t\t\t\t\tKeyN: 6,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b1_2\",\n\t\t\t\t\t\tKeyN: 7,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b1_3\",\n\t\t\t\t\t\tKeyN: 8,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"b2\",\n\t\t\t\tKeyN: 4,\n\t\t\t\tChildren: []bolt.BucketStructure{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b2_1\",\n\t\t\t\t\t\tKeyN: 10,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b2_2\",\n\t\t\t\t\t\tKeyN: 12,\n\t\t\t\t\t\tChildren: []bolt.BucketStructure{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"b2_2_1\",\n\t\t\t\t\t\t\t\tKeyN: 2,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"b2_2_2\",\n\t\t\t\t\t\t\t\tKeyN: 3,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"b2_3\",\n\t\t\t\t\t\tKeyN: 11,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttype bucketItem struct {\n\t\tb  *bolt.Bucket\n\t\tbs bolt.BucketStructure\n\t}\n\n\tt.Log(\"Populating the database\")\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tqueue := []bucketItem{\n\t\t\t{\n\t\t\t\tb:  nil,\n\t\t\t\tbs: expectedStructure,\n\t\t\t},\n\t\t}\n\n\t\tfor len(queue) > 0 {\n\t\t\titem := queue[0]\n\t\t\tqueue = queue[1:]\n\n\t\t\tif item.b != nil {\n\t\t\t\tfor i := 0; i < item.bs.KeyN; i++ {\n\t\t\t\t\terr := item.b.Put([]byte(fmt.Sprintf(\"%02d\", i)), []byte(fmt.Sprintf(\"%02d\", i)))\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\n\t\t\t\tfor _, child := range item.bs.Children {\n\t\t\t\t\tchildBucket, err := item.b.CreateBucket([]byte(child.Name))\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tqueue = append(queue, bucketItem{b: childBucket, bs: child})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor _, child := range item.bs.Children {\n\t\t\t\t\tchildBucket, err := tx.CreateBucket([]byte(child.Name))\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tqueue = append(queue, bucketItem{b: childBucket, bs: child})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n\n\tt.Log(\"Inspecting the database\")\n\t_ = db.View(func(tx *bolt.Tx) error {\n\t\tactualStructure := tx.Inspect()\n\t\tassert.Equal(t, expectedStructure, actualStructure)\n\t\treturn nil\n\t})\n}\n\n// Ensure a large bucket can calculate stats.\nfunc TestBucket_Stats_Large(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tdb := btesting.MustCreateDB(t)\n\n\tvar index int\n\tfor i := 0; i < 100; i++ {\n\t\t// Add bucket with lots of keys.\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"widgets\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tif err := b.Put([]byte(strconv.Itoa(index)), []byte(strconv.Itoa(index))); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tindex++\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tdb.MustCheck()\n\n\tpageSize2stats := map[int]bolt.BucketStats{\n\t\t4096: {\n\t\t\tBranchPageN:       13,\n\t\t\tBranchOverflowN:   0,\n\t\t\tLeafPageN:         1196,\n\t\t\tLeafOverflowN:     0,\n\t\t\tKeyN:              100000,\n\t\t\tDepth:             3,\n\t\t\tBranchAlloc:       53248,\n\t\t\tBranchInuse:       25257,\n\t\t\tLeafAlloc:         4898816,\n\t\t\tLeafInuse:         2596916,\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t\t16384: {\n\t\t\tBranchPageN:       1,\n\t\t\tBranchOverflowN:   0,\n\t\t\tLeafPageN:         292,\n\t\t\tLeafOverflowN:     0,\n\t\t\tKeyN:              100000,\n\t\t\tDepth:             2,\n\t\t\tBranchAlloc:       16384,\n\t\t\tBranchInuse:       6094,\n\t\t\tLeafAlloc:         4784128,\n\t\t\tLeafInuse:         2582452,\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t\t65536: {\n\t\t\tBranchPageN:       1,\n\t\t\tBranchOverflowN:   0,\n\t\t\tLeafPageN:         73,\n\t\t\tLeafOverflowN:     0,\n\t\t\tKeyN:              100000,\n\t\t\tDepth:             2,\n\t\t\tBranchAlloc:       65536,\n\t\t\tBranchInuse:       1534,\n\t\t\tLeafAlloc:         4784128,\n\t\t\tLeafInuse:         2578948,\n\t\t\tBucketN:           1,\n\t\t\tInlineBucketN:     0,\n\t\t\tInlineBucketInuse: 0},\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tstats := tx.Bucket([]byte(\"widgets\")).Stats()\n\t\tt.Logf(\"Stats: %#v\", stats)\n\t\tif expected, ok := pageSize2stats[db.Info().PageSize]; ok {\n\t\t\tassert.EqualValues(t, expected, stats, \"stats differs from expectations\")\n\t\t} else {\n\t\t\tt.Skipf(\"No expectations for page size: %d\", db.Info().PageSize)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can write random keys and values across multiple transactions.\nfunc TestBucket_Put_Single(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tindex := 0\n\tif err := quick.Check(func(items testdata) bool {\n\t\tdb := btesting.MustCreateDB(t)\n\t\tdefer db.MustClose()\n\n\t\tm := make(map[string][]byte)\n\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor _, item := range items {\n\t\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\t\tif err := tx.Bucket([]byte(\"widgets\")).Put(item.Key, item.Value); err != nil {\n\t\t\t\t\tpanic(\"put error: \" + err.Error())\n\t\t\t\t}\n\t\t\t\tm[string(item.Key)] = item.Value\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// Verify all key/values so far.\n\t\t\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t\t\ti := 0\n\t\t\t\tfor k, v := range m {\n\t\t\t\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(k))\n\t\t\t\t\tif !bytes.Equal(value, v) {\n\t\t\t\t\t\tt.Logf(\"value mismatch [run %d] (%d of %d):\\nkey: %x\\ngot: %x\\nexp: %x\", index, i, len(m), []byte(k), value, v)\n\t\t\t\t\t\tdb.CopyTempFile()\n\t\t\t\t\t\tt.FailNow()\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tindex++\n\t\treturn true\n\t}, qconfig()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// Ensure that a transaction can insert multiple key/value pairs at once.\nfunc TestBucket_Put_Multiple(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tif err := quick.Check(func(items testdata) bool {\n\t\tdb := btesting.MustCreateDB(t)\n\t\tdefer db.MustClose()\n\n\t\t// Bulk insert all values.\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\t\tfor _, item := range items {\n\t\t\t\tif err := b.Put(item.Key, item.Value); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Verify all items exist.\n\t\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\t\tfor _, item := range items {\n\t\t\t\tvalue := b.Get(item.Key)\n\t\t\t\tif !bytes.Equal(item.Value, value) {\n\t\t\t\t\tdb.CopyTempFile()\n\t\t\t\t\tt.Fatalf(\"exp=%x; got=%x\", item.Value, value)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn true\n\t}, qconfig()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// Ensure that a transaction can delete all key/value pairs and return to a single leaf page.\nfunc TestBucket_Delete_Quick(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\tif err := quick.Check(func(items testdata) bool {\n\t\tdb := btesting.MustCreateDB(t)\n\t\tdefer db.MustClose()\n\n\t\t// Bulk insert all values.\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\t\tfor _, item := range items {\n\t\t\t\tif err := b.Put(item.Key, item.Value); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Remove items one at a time and check consistency.\n\t\tfor _, item := range items {\n\t\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\t\treturn tx.Bucket([]byte(\"widgets\")).Delete(item.Key)\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\t// Anything before our deletion index should be nil.\n\t\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t\tif err := tx.Bucket([]byte(\"widgets\")).ForEach(func(k, v []byte) error {\n\t\t\t\tt.Fatalf(\"bucket should be empty; found: %06x\", trunc(k, 3))\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn true\n\t}, qconfig()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc BenchmarkBucket_CreateBucketIfNotExists(b *testing.B) {\n\tdb := btesting.MustCreateDB(b)\n\tdefer db.MustClose()\n\n\tconst bucketCount = 1_000_000\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tfor i := 0; i < bucketCount; i++ {\n\t\t\tbucketName := fmt.Sprintf(\"bucket_%d\", i)\n\t\t\t_, berr := tx.CreateBucket([]byte(bucketName))\n\t\t\trequire.NoError(b, berr)\n\t\t}\n\t\treturn nil\n\t})\n\trequire.NoError(b, err)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t\t_, berr := tx.CreateBucketIfNotExists([]byte(\"bucket_100\"))\n\t\t\treturn berr\n\t\t})\n\t\trequire.NoError(b, err)\n\t}\n}\n\nfunc ExampleBucket_Put() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Start a write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create a bucket.\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the value \"bar\" for the key \"foo\".\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Read value back in a different read-only transaction.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tfmt.Printf(\"The value of 'foo' is: %s\\n\", value)\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// The value of 'foo' is: bar\n}\n\nfunc ExampleBucket_Delete() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Start a write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create a bucket.\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the value \"bar\" for the key \"foo\".\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Retrieve the key back from the database and verify it.\n\t\tvalue := b.Get([]byte(\"foo\"))\n\t\tfmt.Printf(\"The value of 'foo' was: %s\\n\", value)\n\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Delete the key in a different write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\treturn tx.Bucket([]byte(\"widgets\")).Delete([]byte(\"foo\"))\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Retrieve the key again.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tif value == nil {\n\t\t\tfmt.Printf(\"The value of 'foo' is now: nil\\n\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// The value of 'foo' was: bar\n\t// The value of 'foo' is now: nil\n}\n\nfunc ExampleBucket_ForEach() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Insert data into a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"animals\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := b.Put([]byte(\"dog\"), []byte(\"fun\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"cat\"), []byte(\"lame\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"liger\"), []byte(\"awesome\")); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Iterate over items in sorted key order.\n\t\tif err := b.ForEach(func(k, v []byte) error {\n\t\t\tfmt.Printf(\"A %s is %s.\\n\", k, v)\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// A cat is lame.\n\t// A dog is fun.\n\t// A liger is awesome.\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "compact.go",
          "type": "blob",
          "size": 3.07421875,
          "content": "package bbolt\n\n// Compact will create a copy of the source DB and in the destination DB. This may\n// reclaim space that the source database no longer has use for. txMaxSize can be\n// used to limit the transactions size of this process and may trigger intermittent\n// commits. A value of zero will ignore transaction sizes.\n// TODO: merge with: https://github.com/etcd-io/etcd/blob/b7f0f52a16dbf83f18ca1d803f7892d750366a94/mvcc/backend/backend.go#L349\nfunc Compact(dst, src *DB, txMaxSize int64) error {\n\t// commit regularly, or we'll run out of memory for large datasets if using one transaction.\n\tvar size int64\n\ttx, err := dst.Begin(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif tempErr := tx.Rollback(); tempErr != nil {\n\t\t\terr = tempErr\n\t\t}\n\t}()\n\n\tif err := walk(src, func(keys [][]byte, k, v []byte, seq uint64) error {\n\t\t// On each key/value, check if we have exceeded tx size.\n\t\tsz := int64(len(k) + len(v))\n\t\tif size+sz > txMaxSize && txMaxSize != 0 {\n\t\t\t// Commit previous transaction.\n\t\t\tif err := tx.Commit(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Start new transaction.\n\t\t\ttx, err = dst.Begin(true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsize = 0\n\t\t}\n\t\tsize += sz\n\n\t\t// Create bucket on the root transaction if this is the first level.\n\t\tnk := len(keys)\n\t\tif nk == 0 {\n\t\t\tbkt, err := tx.CreateBucket(k)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := bkt.SetSequence(seq); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Create buckets on subsequent levels, if necessary.\n\t\tb := tx.Bucket(keys[0])\n\t\tif nk > 1 {\n\t\t\tfor _, k := range keys[1:] {\n\t\t\t\tb = b.Bucket(k)\n\t\t\t}\n\t\t}\n\n\t\t// Fill the entire page for best compaction.\n\t\tb.FillPercent = 1.0\n\n\t\t// If there is no value then this is a bucket call.\n\t\tif v == nil {\n\t\t\tbkt, err := b.CreateBucket(k)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := bkt.SetSequence(seq); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Otherwise treat it as a key/value pair.\n\t\treturn b.Put(k, v)\n\t}); err != nil {\n\t\treturn err\n\t}\n\terr = tx.Commit()\n\n\treturn err\n}\n\n// walkFunc is the type of the function called for keys (buckets and \"normal\"\n// values) discovered by Walk. keys is the list of keys to descend to the bucket\n// owning the discovered key/value pair k/v.\ntype walkFunc func(keys [][]byte, k, v []byte, seq uint64) error\n\n// walk walks recursively the bolt database db, calling walkFn for each key it finds.\nfunc walk(db *DB, walkFn walkFunc) error {\n\treturn db.View(func(tx *Tx) error {\n\t\treturn tx.ForEach(func(name []byte, b *Bucket) error {\n\t\t\treturn walkBucket(b, nil, name, nil, b.Sequence(), walkFn)\n\t\t})\n\t})\n}\n\nfunc walkBucket(b *Bucket, keypath [][]byte, k, v []byte, seq uint64, fn walkFunc) error {\n\t// Execute callback.\n\tif err := fn(keypath, k, v, seq); err != nil {\n\t\treturn err\n\t}\n\n\t// If this is not a bucket then stop.\n\tif v != nil {\n\t\treturn nil\n\t}\n\n\t// Iterate over each child key/value.\n\tkeypath = append(keypath, k)\n\treturn b.ForEach(func(k, v []byte) error {\n\t\tif v == nil {\n\t\t\tbkt := b.Bucket(k)\n\t\t\treturn walkBucket(bkt, keypath, k, nil, bkt.Sequence(), fn)\n\t\t}\n\t\treturn walkBucket(b, keypath, k, v, b.Sequence(), fn)\n\t})\n}\n"
        },
        {
          "name": "concurrent_test.go",
          "type": "blob",
          "size": 22.98828125,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\tcrand \"crypto/rand\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\tmrand \"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/sync/errgroup\"\n\n\tbolt \"go.etcd.io/bbolt\"\n)\n\nconst (\n\tbucketPrefix = \"bucket\"\n\tkeyPrefix    = \"key\"\n\tnoopTxKey    = \"%magic-no-op-key%\"\n\n\t// TestConcurrentCaseDuration is used as a env variable to specify the\n\t// concurrent test duration.\n\ttestConcurrentCaseDuration    = \"TEST_CONCURRENT_CASE_DURATION\"\n\tdefaultConcurrentTestDuration = 30 * time.Second\n)\n\ntype duration struct {\n\tmin time.Duration\n\tmax time.Duration\n}\n\ntype bytesRange struct {\n\tmin int\n\tmax int\n}\n\ntype operationChance struct {\n\toperation OperationType\n\tchance    int\n}\n\ntype concurrentConfig struct {\n\tbucketCount    int\n\tkeyCount       int\n\tworkInterval   duration\n\toperationRatio []operationChance\n\treadInterval   duration   // only used by readOperation\n\tnoopWriteRatio int        // only used by writeOperation\n\twriteBytes     bytesRange // only used by writeOperation\n}\n\n/*\nTestConcurrentGenericReadAndWrite verifies:\n 1. Repeatable read: a read transaction should always see the same data\n    view during its lifecycle.\n 2. Any data written by a writing transaction should be visible to any\n    following reading transactions (with txid >= previous writing txid).\n 3. The txid should never decrease.\n*/\nfunc TestConcurrentGenericReadAndWrite(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\ttestDuration := concurrentTestDuration(t)\n\tconf := concurrentConfig{\n\t\tbucketCount:  5,\n\t\tkeyCount:     10000,\n\t\tworkInterval: duration{},\n\t\toperationRatio: []operationChance{\n\t\t\t{operation: Read, chance: 60},\n\t\t\t{operation: Write, chance: 20},\n\t\t\t{operation: Delete, chance: 20},\n\t\t},\n\t\treadInterval: duration{\n\t\t\tmin: 50 * time.Millisecond,\n\t\t\tmax: 100 * time.Millisecond,\n\t\t},\n\t\tnoopWriteRatio: 20,\n\t\twriteBytes: bytesRange{\n\t\t\tmin: 200,\n\t\t\tmax: 16000,\n\t\t},\n\t}\n\n\ttestCases := []struct {\n\t\tname         string\n\t\tworkerCount  int\n\t\tconf         concurrentConfig\n\t\ttestDuration time.Duration\n\t}{\n\t\t{\n\t\t\tname:         \"1 worker\",\n\t\t\tworkerCount:  1,\n\t\t\tconf:         conf,\n\t\t\ttestDuration: testDuration,\n\t\t},\n\t\t{\n\t\t\tname:         \"10 workers\",\n\t\t\tworkerCount:  10,\n\t\t\tconf:         conf,\n\t\t\ttestDuration: testDuration,\n\t\t},\n\t\t{\n\t\t\tname:         \"50 workers\",\n\t\t\tworkerCount:  50,\n\t\t\tconf:         conf,\n\t\t\ttestDuration: testDuration,\n\t\t},\n\t\t{\n\t\t\tname:         \"100 workers\",\n\t\t\tworkerCount:  100,\n\t\t\tconf:         conf,\n\t\t\ttestDuration: testDuration,\n\t\t},\n\t\t{\n\t\t\tname:         \"200 workers\",\n\t\t\tworkerCount:  200,\n\t\t\tconf:         conf,\n\t\t\ttestDuration: testDuration,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconcurrentReadAndWrite(t,\n\t\t\t\ttc.workerCount,\n\t\t\t\ttc.conf,\n\t\t\t\ttc.testDuration)\n\t\t})\n\t}\n}\n\nfunc concurrentTestDuration(t *testing.T) time.Duration {\n\tdurationInEnv := strings.ToLower(os.Getenv(testConcurrentCaseDuration))\n\tif durationInEnv == \"\" {\n\t\tt.Logf(\"%q not set, defaults to %s\", testConcurrentCaseDuration, defaultConcurrentTestDuration)\n\t\treturn defaultConcurrentTestDuration\n\t}\n\n\td, err := time.ParseDuration(durationInEnv)\n\tif err != nil {\n\t\tt.Logf(\"Failed to parse %s=%s, error: %v, defaults to %s\", testConcurrentCaseDuration, durationInEnv, err, defaultConcurrentTestDuration)\n\t\treturn defaultConcurrentTestDuration\n\t}\n\n\tt.Logf(\"Concurrent test duration set by %s=%s\", testConcurrentCaseDuration, d)\n\treturn d\n}\n\nfunc concurrentReadAndWrite(t *testing.T,\n\tworkerCount int,\n\tconf concurrentConfig,\n\ttestDuration time.Duration) {\n\n\tt.Log(\"Preparing db.\")\n\tdb := mustCreateDB(t, &bolt.Options{\n\t\tPageSize: 4096,\n\t})\n\tdefer db.Close()\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tfor i := 0; i < conf.bucketCount; i++ {\n\t\t\tif _, err := tx.CreateBucketIfNotExists(bucketName(i)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n\n\tvar records historyRecords\n\t// t.Failed() returns false during panicking. We need to forcibly\n\t// save data on panicking.\n\t// Refer to: https://github.com/golang/go/issues/49929\n\tpanicked := true\n\tdefer func() {\n\t\tt.Log(\"Save data if failed.\")\n\t\tsaveDataIfFailed(t, db, records, panicked)\n\t}()\n\n\tt.Log(\"Starting workers.\")\n\trecords = runWorkers(t,\n\t\tdb,\n\t\tworkerCount,\n\t\tconf,\n\t\ttestDuration)\n\n\tt.Log(\"Analyzing the history records.\")\n\tif err := validateSequential(records); err != nil {\n\t\tt.Errorf(\"The history records are not sequential:\\n %v\", err)\n\t}\n\n\tt.Log(\"Checking database consistency.\")\n\tif err := checkConsistency(t, db); err != nil {\n\t\tt.Errorf(\"The data isn't consistency: %v\", err)\n\t}\n\n\tpanicked = false\n\t// TODO (ahrtr):\n\t//   1. intentionally inject a random failpoint.\n}\n\n// mustCreateDB is created in place of `btesting.MustCreateDB`, and it's\n// only supposed to be used by the concurrent test case. The purpose is\n// to ensure the test case can be executed on old branches or versions,\n// e.g. `release-1.3` or `1.3.[5-7]`.\nfunc mustCreateDB(t *testing.T, o *bolt.Options) *bolt.DB {\n\tf := filepath.Join(t.TempDir(), \"db\")\n\n\treturn mustOpenDB(t, f, o)\n}\n\nfunc mustReOpenDB(t *testing.T, db *bolt.DB, o *bolt.Options) *bolt.DB {\n\tf := db.Path()\n\n\tt.Logf(\"Closing bbolt DB at: %s\", f)\n\terr := db.Close()\n\trequire.NoError(t, err)\n\n\treturn mustOpenDB(t, f, o)\n}\n\nfunc mustOpenDB(t *testing.T, dbPath string, o *bolt.Options) *bolt.DB {\n\tt.Logf(\"Opening bbolt DB at: %s\", dbPath)\n\tif o == nil {\n\t\to = bolt.DefaultOptions\n\t}\n\n\tfreelistType := bolt.FreelistArrayType\n\tif env := os.Getenv(\"TEST_FREELIST_TYPE\"); env == string(bolt.FreelistMapType) {\n\t\tfreelistType = bolt.FreelistMapType\n\t}\n\n\to.FreelistType = freelistType\n\n\tdb, err := bolt.Open(dbPath, 0600, o)\n\trequire.NoError(t, err)\n\n\treturn db\n}\n\nfunc checkConsistency(t *testing.T, db *bolt.DB) error {\n\treturn db.View(func(tx *bolt.Tx) error {\n\t\tcnt := 0\n\t\tfor err := range tx.Check() {\n\t\t\tt.Errorf(\"Consistency error: %v\", err)\n\t\t\tcnt++\n\t\t}\n\t\tif cnt > 0 {\n\t\t\treturn fmt.Errorf(\"%d consistency errors found\", cnt)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n/*\n*********************************************************\nData structures and functions/methods for running concurrent\nworkers, which execute different operations, including `Read`,\n`Write` and `Delete`.\n*********************************************************\n*/\nfunc runWorkers(t *testing.T,\n\tdb *bolt.DB,\n\tworkerCount int,\n\tconf concurrentConfig,\n\ttestDuration time.Duration) historyRecords {\n\tstopCh := make(chan struct{}, 1)\n\terrCh := make(chan error, workerCount)\n\n\tvar mu sync.Mutex\n\tvar rs historyRecords\n\n\tg := new(errgroup.Group)\n\tfor i := 0; i < workerCount; i++ {\n\t\tw := &worker{\n\t\t\tid: i,\n\t\t\tdb: db,\n\n\t\t\tconf: conf,\n\n\t\t\terrCh:  errCh,\n\t\t\tstopCh: stopCh,\n\t\t\tt:      t,\n\t\t}\n\t\tg.Go(func() error {\n\t\t\twrs, err := runWorker(t, w, errCh)\n\t\t\tmu.Lock()\n\t\t\trs = append(rs, wrs...)\n\t\t\tmu.Unlock()\n\t\t\treturn err\n\t\t})\n\t}\n\n\tt.Logf(\"Keep all workers running for about %s.\", testDuration)\n\tselect {\n\tcase <-time.After(testDuration):\n\tcase <-errCh:\n\t}\n\n\tclose(stopCh)\n\tt.Log(\"Waiting for all workers to finish.\")\n\tif err := g.Wait(); err != nil {\n\t\tt.Errorf(\"Received error: %v\", err)\n\t}\n\n\treturn rs\n}\n\nfunc runWorker(t *testing.T, w *worker, errCh chan error) (historyRecords, error) {\n\trs, err := w.run()\n\tif len(rs) > 0 && err == nil {\n\t\tif terr := validateIncrementalTxid(rs); terr != nil {\n\t\t\ttxidErr := fmt.Errorf(\"[%s]: %w\", w.name(), terr)\n\t\t\tt.Error(txidErr)\n\t\t\terrCh <- txidErr\n\t\t\treturn rs, txidErr\n\t\t}\n\t}\n\treturn rs, err\n}\n\ntype worker struct {\n\tid int\n\tdb *bolt.DB\n\n\tconf concurrentConfig\n\n\terrCh  chan error\n\tstopCh chan struct{}\n\n\tt *testing.T\n}\n\nfunc (w *worker) name() string {\n\treturn fmt.Sprintf(\"worker-%d\", w.id)\n}\n\nfunc (w *worker) run() (historyRecords, error) {\n\tvar rs historyRecords\n\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-w.stopCh:\n\t\t\treturn rs, nil\n\t\tdefault:\n\t\t}\n\n\t\terr := w.db.Update(func(tx *bolt.Tx) error {\n\t\t\tfor {\n\t\t\t\top := w.pickOperation()\n\t\t\t\tbucket, key := w.pickBucket(), w.pickKey()\n\t\t\t\trec, eerr := executeOperation(op, tx, bucket, key, w.conf)\n\t\t\t\tif eerr != nil {\n\t\t\t\t\topErr := fmt.Errorf(\"[%s: %s]: %w\", w.name(), op, eerr)\n\t\t\t\t\tw.t.Error(opErr)\n\t\t\t\t\tw.errCh <- opErr\n\t\t\t\t\treturn opErr\n\t\t\t\t}\n\n\t\t\t\trs = append(rs, rec)\n\t\t\t\tif w.conf.workInterval != (duration{}) {\n\t\t\t\t\ttime.Sleep(randomDurationInRange(w.conf.workInterval.min, w.conf.workInterval.max))\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\treturn nil\n\t\t\t\tcase <-w.stopCh:\n\t\t\t\t\treturn nil\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tif err != nil {\n\t\t\treturn rs, err\n\t\t}\n\t}\n}\n\nfunc (w *worker) pickBucket() []byte {\n\treturn bucketName(mrand.Intn(w.conf.bucketCount))\n}\n\nfunc bucketName(index int) []byte {\n\tbucket := fmt.Sprintf(\"%s_%d\", bucketPrefix, index)\n\treturn []byte(bucket)\n}\n\nfunc (w *worker) pickKey() []byte {\n\tkey := fmt.Sprintf(\"%s_%d\", keyPrefix, mrand.Intn(w.conf.keyCount))\n\treturn []byte(key)\n}\n\nfunc (w *worker) pickOperation() OperationType {\n\tsum := 0\n\tfor _, op := range w.conf.operationRatio {\n\t\tsum += op.chance\n\t}\n\troll := mrand.Int() % sum\n\tfor _, op := range w.conf.operationRatio {\n\t\tif roll < op.chance {\n\t\t\treturn op.operation\n\t\t}\n\t\troll -= op.chance\n\t}\n\tpanic(\"unexpected\")\n}\n\nfunc executeOperation(op OperationType, tx *bolt.Tx, bucket []byte, key []byte, conf concurrentConfig) (historyRecord, error) {\n\tswitch op {\n\tcase Read:\n\t\treturn executeRead(tx, bucket, key, conf.readInterval)\n\tcase Write:\n\t\treturn executeWrite(tx, bucket, key, conf.writeBytes, conf.noopWriteRatio)\n\tcase Delete:\n\t\treturn executeDelete(tx, bucket, key)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unexpected operation type: %s\", op))\n\t}\n}\n\nfunc executeRead(tx *bolt.Tx, bucket []byte, key []byte, readInterval duration) (historyRecord, error) {\n\tvar rec historyRecord\n\n\tb := tx.Bucket(bucket)\n\n\tinitialVal := b.Get(key)\n\ttime.Sleep(randomDurationInRange(readInterval.min, readInterval.max))\n\tval := b.Get(key)\n\n\tif !bytes.Equal(initialVal, val) {\n\t\treturn rec, fmt.Errorf(\"read different values for the same key (%q), value1: %q, value2: %q\",\n\t\t\tstring(key), formatBytes(initialVal), formatBytes(val))\n\t}\n\n\tclonedVal := make([]byte, len(val))\n\tcopy(clonedVal, val)\n\n\trec = historyRecord{\n\t\tOperationType: Read,\n\t\tBucket:        string(bucket),\n\t\tKey:           string(key),\n\t\tValue:         clonedVal,\n\t\tTxid:          tx.ID(),\n\t}\n\n\treturn rec, nil\n}\n\nfunc executeWrite(tx *bolt.Tx, bucket []byte, key []byte, writeBytes bytesRange, noopWriteRatio int) (historyRecord, error) {\n\tvar rec historyRecord\n\n\tif mrand.Intn(100) < noopWriteRatio {\n\t\t// A no-op write transaction has two consequences:\n\t\t//    1. The txid increases by 1;\n\t\t//    2. Two meta pages point to the same root page.\n\t\trec = historyRecord{\n\t\t\tOperationType: Write,\n\t\t\tBucket:        string(bucket),\n\t\t\tKey:           noopTxKey,\n\t\t\tValue:         nil,\n\t\t\tTxid:          tx.ID(),\n\t\t}\n\t\treturn rec, nil\n\t}\n\n\tb := tx.Bucket(bucket)\n\n\tvalueBytes := randomIntInRange(writeBytes.min, writeBytes.max)\n\tv := make([]byte, valueBytes)\n\tif _, cErr := crand.Read(v); cErr != nil {\n\t\treturn rec, cErr\n\t}\n\n\tputErr := b.Put(key, v)\n\tif putErr == nil {\n\t\trec = historyRecord{\n\t\t\tOperationType: Write,\n\t\t\tBucket:        string(bucket),\n\t\t\tKey:           string(key),\n\t\t\tValue:         v,\n\t\t\tTxid:          tx.ID(),\n\t\t}\n\t}\n\n\treturn rec, putErr\n}\n\nfunc executeDelete(tx *bolt.Tx, bucket []byte, key []byte) (historyRecord, error) {\n\tvar rec historyRecord\n\n\tb := tx.Bucket(bucket)\n\n\terr := b.Delete(key)\n\tif err == nil {\n\t\trec = historyRecord{\n\t\t\tOperationType: Delete,\n\t\t\tBucket:        string(bucket),\n\t\t\tKey:           string(key),\n\t\t\tTxid:          tx.ID(),\n\t\t}\n\t}\n\n\treturn rec, err\n}\n\nfunc randomDurationInRange(min, max time.Duration) time.Duration {\n\td := int64(max) - int64(min)\n\td = int64(mrand.Intn(int(d))) + int64(min)\n\treturn time.Duration(d)\n}\n\nfunc randomIntInRange(min, max int) int {\n\treturn mrand.Intn(max-min) + min\n}\n\nfunc formatBytes(val []byte) string {\n\tif utf8.ValidString(string(val)) {\n\t\treturn string(val)\n\t}\n\n\treturn hex.EncodeToString(val)\n}\n\n/*\n*********************************************************\nFunctions for persisting test data, including db file\nand operation history\n*********************************************************\n*/\nfunc saveDataIfFailed(t *testing.T, db *bolt.DB, rs historyRecords, force bool) {\n\tif t.Failed() || force {\n\t\tt.Log(\"Saving data...\")\n\t\tdbPath := db.Path()\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Errorf(\"Failed to close db: %v\", err)\n\t\t}\n\t\tbackupPath := testResultsDirectory(t)\n\t\tbackupDB(t, dbPath, backupPath)\n\t\tpersistHistoryRecords(t, rs, backupPath)\n\t}\n}\n\nfunc backupDB(t *testing.T, srcPath string, dstPath string) {\n\ttargetFile := filepath.Join(dstPath, \"db.bak\")\n\tt.Logf(\"Saving the DB file to %s\", targetFile)\n\terr := copyFile(srcPath, targetFile)\n\trequire.NoError(t, err)\n\tt.Logf(\"DB file saved to %s\", targetFile)\n}\n\nfunc copyFile(srcPath, dstPath string) error {\n\t// Ensure source file exists.\n\t_, err := os.Stat(srcPath)\n\tif os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"source file %q not found\", srcPath)\n\t} else if err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure output file not exist.\n\t_, err = os.Stat(dstPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"output file %q already exists\", dstPath)\n\t} else if !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\tsrcDB, err := os.Open(srcPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open source file %q: %w\", srcPath, err)\n\t}\n\tdefer srcDB.Close()\n\tdstDB, err := os.Create(dstPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create output file %q: %w\", dstPath, err)\n\t}\n\tdefer dstDB.Close()\n\twritten, err := io.Copy(dstDB, srcDB)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to copy database file from %q to %q: %w\", srcPath, dstPath, err)\n\t}\n\n\tsrcFi, err := srcDB.Stat()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get source file info %q: %w\", srcPath, err)\n\t}\n\tinitialSize := srcFi.Size()\n\tif initialSize != written {\n\t\treturn fmt.Errorf(\"the byte copied (%q: %d) isn't equal to the initial db size (%q: %d)\", dstPath, written, srcPath, initialSize)\n\t}\n\n\treturn nil\n}\n\nfunc persistHistoryRecords(t *testing.T, rs historyRecords, path string) {\n\trecordFilePath := filepath.Join(path, \"history_records.json\")\n\tt.Logf(\"Saving history records to %s\", recordFilePath)\n\trecordFile, err := os.OpenFile(recordFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)\n\trequire.NoError(t, err)\n\tdefer recordFile.Close()\n\tencoder := json.NewEncoder(recordFile)\n\tfor _, rec := range rs {\n\t\terr := encoder.Encode(rec)\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc testResultsDirectory(t *testing.T) string {\n\tresultsDirectory, ok := os.LookupEnv(\"RESULTS_DIR\")\n\tvar err error\n\tif !ok {\n\t\tresultsDirectory, err = os.MkdirTemp(\"\", \"*.db\")\n\t\trequire.NoError(t, err)\n\t}\n\tresultsDirectory, err = filepath.Abs(resultsDirectory)\n\trequire.NoError(t, err)\n\n\tpath, err := filepath.Abs(filepath.Join(resultsDirectory, strings.ReplaceAll(t.Name(), \"/\", \"_\")))\n\trequire.NoError(t, err)\n\n\terr = os.RemoveAll(path)\n\trequire.NoError(t, err)\n\n\terr = os.MkdirAll(path, 0700)\n\trequire.NoError(t, err)\n\n\treturn path\n}\n\n/*\n*********************************************************\nData structures and functions for analyzing history records\n*********************************************************\n*/\ntype OperationType string\n\nconst (\n\tRead   OperationType = \"read\"\n\tWrite  OperationType = \"write\"\n\tDelete OperationType = \"delete\"\n)\n\ntype historyRecord struct {\n\tOperationType OperationType `json:\"operationType,omitempty\"`\n\tTxid          int           `json:\"txid,omitempty\"`\n\tBucket        string        `json:\"bucket,omitempty\"`\n\tKey           string        `json:\"key,omitempty\"`\n\tValue         []byte        `json:\"value,omitempty\"`\n}\n\ntype historyRecords []historyRecord\n\nfunc (rs historyRecords) Len() int {\n\treturn len(rs)\n}\n\nfunc (rs historyRecords) Less(i, j int) bool {\n\t// Sorted by (bucket, key) firstly: all records in the same\n\t// (bucket, key) are grouped together.\n\tbucketCmp := strings.Compare(rs[i].Bucket, rs[j].Bucket)\n\tif bucketCmp != 0 {\n\t\treturn bucketCmp < 0\n\t}\n\tkeyCmp := strings.Compare(rs[i].Key, rs[j].Key)\n\tif keyCmp != 0 {\n\t\treturn keyCmp < 0\n\t}\n\n\t// Sorted by txid\n\treturn rs[i].Txid < rs[j].Txid\n}\n\nfunc (rs historyRecords) Swap(i, j int) {\n\trs[i], rs[j] = rs[j], rs[i]\n}\n\nfunc validateIncrementalTxid(rs historyRecords) error {\n\tlastTxid := rs[0].Txid\n\n\tfor i := 1; i < len(rs); i++ {\n\t\tif rs[i].Txid < lastTxid {\n\t\t\treturn fmt.Errorf(\"detected non-incremental txid(%d, %d) in %s mode\", lastTxid, rs[i].Txid, rs[i].OperationType)\n\t\t}\n\t\tlastTxid = rs[i].Txid\n\t}\n\n\treturn nil\n}\n\nfunc validateSequential(rs historyRecords) error {\n\tsort.Stable(rs)\n\n\ttype bucketAndKey struct {\n\t\tbucket string\n\t\tkey    string\n\t}\n\tlastWriteKeyValueMap := make(map[bucketAndKey]*historyRecord)\n\n\tfor _, rec := range rs {\n\t\tbk := bucketAndKey{\n\t\t\tbucket: rec.Bucket,\n\t\t\tkey:    rec.Key,\n\t\t}\n\t\tif v, ok := lastWriteKeyValueMap[bk]; ok {\n\t\t\tif rec.OperationType == Write {\n\t\t\t\tv.Txid = rec.Txid\n\t\t\t\tif rec.Key != noopTxKey {\n\t\t\t\t\tv.Value = rec.Value\n\t\t\t\t}\n\t\t\t} else if rec.OperationType == Delete {\n\t\t\t\tdelete(lastWriteKeyValueMap, bk)\n\t\t\t} else {\n\t\t\t\tif !bytes.Equal(v.Value, rec.Value) {\n\t\t\t\t\treturn fmt.Errorf(\"readOperation[txid: %d, bucket: %s, key: %s] read %x, \\nbut writer[txid: %d] wrote %x\",\n\t\t\t\t\t\trec.Txid, rec.Bucket, rec.Key, rec.Value, v.Txid, v.Value)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif rec.OperationType == Write && rec.Key != noopTxKey {\n\t\t\t\tlastWriteKeyValueMap[bk] = &historyRecord{\n\t\t\t\t\tOperationType: Write,\n\t\t\t\t\tBucket:        rec.Bucket,\n\t\t\t\t\tKey:           rec.Key,\n\t\t\t\t\tValue:         rec.Value,\n\t\t\t\t\tTxid:          rec.Txid,\n\t\t\t\t}\n\t\t\t} else if rec.OperationType == Read {\n\t\t\t\tif len(rec.Value) != 0 {\n\t\t\t\t\treturn fmt.Errorf(\"expected the first readOperation[txid: %d, bucket: %s, key: %s] read nil, \\nbut got %x\",\n\t\t\t\t\t\trec.Txid, rec.Bucket, rec.Key, rec.Value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n/*\nTestConcurrentRepeatableRead verifies repeatable read. The case\nintentionally creates a scenario that read and write transactions\nare interleaved. It performs several writing operations after starting\neach long-running read transaction to ensure it has a larger txid\nthan previous read transaction. It verifies that bbolt correctly\nreleases free pages, and will not pollute (e.g. prematurely release)\nany pages which are still being used by any read transaction.\n*/\nfunc TestConcurrentRepeatableRead(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tnoFreelistSync bool\n\t\tfreelistType   bolt.FreelistType\n\t}{\n\t\t// [array] freelist\n\t\t{\n\t\t\tname:           \"sync array freelist\",\n\t\t\tnoFreelistSync: false,\n\t\t\tfreelistType:   bolt.FreelistArrayType,\n\t\t},\n\t\t{\n\t\t\tname:           \"not sync array freelist\",\n\t\t\tnoFreelistSync: true,\n\t\t\tfreelistType:   bolt.FreelistArrayType,\n\t\t},\n\t\t// [map] freelist\n\t\t{\n\t\t\tname:           \"sync map freelist\",\n\t\t\tnoFreelistSync: false,\n\t\t\tfreelistType:   bolt.FreelistMapType,\n\t\t},\n\t\t{\n\t\t\tname:           \"not sync map freelist\",\n\t\t\tnoFreelistSync: true,\n\t\t\tfreelistType:   bolt.FreelistMapType,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\n\t\t\tt.Log(\"Preparing db.\")\n\t\t\tvar (\n\t\t\t\tbucket = []byte(\"data\")\n\t\t\t\tkey    = []byte(\"mykey\")\n\n\t\t\t\toption = &bolt.Options{\n\t\t\t\t\tPageSize:       4096,\n\t\t\t\t\tNoFreelistSync: tc.noFreelistSync,\n\t\t\t\t\tFreelistType:   tc.freelistType,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tdb := mustCreateDB(t, option)\n\t\t\tdefer func() {\n\t\t\t\t// The db will be reopened later, so put `db.Close()` in a function\n\t\t\t\t// to avoid premature evaluation of `db`. Note that the execution\n\t\t\t\t// of a deferred function is deferred to the moment the surrounding\n\t\t\t\t// function returns, but the function value and parameters to the\n\t\t\t\t// call are evaluated as usual and saved anew.\n\t\t\t\tdb.Close()\n\t\t\t}()\n\n\t\t\t// Create lots of K/V to allocate some pages\n\t\t\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t\t\tb, err := tx.CreateBucketIfNotExists(bucket)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\t\tk := fmt.Sprintf(\"key_%d\", i)\n\t\t\t\t\tif err := b.Put([]byte(k), make([]byte, 1024)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Remove all K/V to create some free pages\n\t\t\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t\t\tb := tx.Bucket(bucket)\n\t\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\t\tk := fmt.Sprintf(\"key_%d\", i)\n\t\t\t\t\tif err := b.Delete([]byte(k)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn b.Put(key, []byte(\"randomValue\"))\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// bbolt will not release free pages directly after committing\n\t\t\t// a writing transaction; instead all pages freed are putting\n\t\t\t// into a pending list. Accordingly, the free pages might not\n\t\t\t// be able to be reused by following writing transactions. So\n\t\t\t// we reopen the db to completely release all free pages.\n\t\t\tdb = mustReOpenDB(t, db, option)\n\n\t\t\tvar (\n\t\t\t\twg                     sync.WaitGroup\n\t\t\t\tlongRunningReaderCount = 10\n\t\t\t\tstopCh                 = make(chan struct{})\n\t\t\t\terrCh                  = make(chan error, longRunningReaderCount)\n\t\t\t\treadInterval           = duration{5 * time.Millisecond, 10 * time.Millisecond}\n\n\t\t\t\twriteOperationCountInBetween = 5\n\t\t\t\twriteBytes                   = bytesRange{10, 20}\n\n\t\t\t\ttestDuration = 10 * time.Second\n\t\t\t)\n\n\t\t\tfor i := 0; i < longRunningReaderCount; i++ {\n\t\t\t\treadWorkerName := fmt.Sprintf(\"reader_%d\", i)\n\t\t\t\tt.Logf(\"Starting long running read operation: %s\", readWorkerName)\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\trErr := executeLongRunningRead(t, readWorkerName, db, bucket, key, readInterval, stopCh)\n\t\t\t\t\tif rErr != nil {\n\t\t\t\t\t\terrCh <- rErr\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\t\tt.Logf(\"Perform %d write operations after starting a long running read operation\", writeOperationCountInBetween)\n\t\t\t\tfor j := 0; j < writeOperationCountInBetween; j++ {\n\t\t\t\t\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t\t\t\t\t_, eerr := executeWrite(tx, bucket, key, writeBytes, 0)\n\t\t\t\t\t\treturn eerr\n\t\t\t\t\t})\n\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt.Log(\"Perform lots of write operations to check whether the long running read operations will read dirty data\")\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tcnt := longRunningReaderCount * writeOperationCountInBetween\n\t\t\t\tfor i := 0; i < cnt; i++ {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-stopCh:\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t\t\t\t\t_, eerr := executeWrite(tx, bucket, key, writeBytes, 0)\n\t\t\t\t\t\treturn eerr\n\t\t\t\t\t})\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tt.Log(\"Waiting for result\")\n\t\t\tselect {\n\t\t\tcase err := <-errCh:\n\t\t\t\tclose(stopCh)\n\t\t\t\tt.Errorf(\"Detected dirty read: %v\", err)\n\t\t\tcase <-time.After(testDuration):\n\t\t\t\tclose(stopCh)\n\t\t\t}\n\n\t\t\twg.Wait()\n\t\t})\n\t}\n}\n\nfunc executeLongRunningRead(t *testing.T, name string, db *bolt.DB, bucket []byte, key []byte, readInterval duration, stopCh chan struct{}) error {\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(bucket)\n\n\t\tinitialVal := b.Get(key)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stopCh:\n\t\t\t\tt.Logf(\"%q finished.\", name)\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\ttime.Sleep(randomDurationInRange(readInterval.min, readInterval.max))\n\t\t\tval := b.Get(key)\n\n\t\t\tif !bytes.Equal(initialVal, val) {\n\t\t\t\tdirtyReadErr := fmt.Errorf(\"read different values for the same key (%q), value1: %q, value2: %q\",\n\t\t\t\t\tstring(key), formatBytes(initialVal), formatBytes(val))\n\t\t\t\treturn dirtyReadErr\n\t\t\t}\n\t\t}\n\t})\n\n\treturn err\n}\n"
        },
        {
          "name": "cursor.go",
          "type": "blob",
          "size": 12.3916015625,
          "content": "package bbolt\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sort\"\n\n\t\"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// Cursor represents an iterator that can traverse over all key/value pairs in a bucket\n// in lexicographical order.\n// Cursors see nested buckets with value == nil.\n// Cursors can be obtained from a transaction and are valid as long as the transaction is open.\n//\n// Keys and values returned from the cursor are only valid for the life of the transaction.\n//\n// Changing data while traversing with a cursor may cause it to be invalidated\n// and return unexpected keys and/or values. You must reposition your cursor\n// after mutating data.\ntype Cursor struct {\n\tbucket *Bucket\n\tstack  []elemRef\n}\n\n// Bucket returns the bucket that this cursor was created from.\nfunc (c *Cursor) Bucket() *Bucket {\n\treturn c.bucket\n}\n\n// First moves the cursor to the first item in the bucket and returns its key and value.\n// If the bucket is empty then a nil key and value are returned.\n// The returned key and value are only valid for the life of the transaction.\nfunc (c *Cursor) First() (key []byte, value []byte) {\n\tcommon.Assert(c.bucket.tx.db != nil, \"tx closed\")\n\tk, v, flags := c.first()\n\tif (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil\n\t}\n\treturn k, v\n}\n\nfunc (c *Cursor) first() (key []byte, value []byte, flags uint32) {\n\tc.stack = c.stack[:0]\n\tp, n := c.bucket.pageNode(c.bucket.RootPage())\n\tc.stack = append(c.stack, elemRef{page: p, node: n, index: 0})\n\tc.goToFirstElementOnTheStack()\n\n\t// If we land on an empty page then move to the next value.\n\t// https://github.com/boltdb/bolt/issues/450\n\tif c.stack[len(c.stack)-1].count() == 0 {\n\t\tc.next()\n\t}\n\n\tk, v, flags := c.keyValue()\n\tif (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil, flags\n\t}\n\treturn k, v, flags\n}\n\n// Last moves the cursor to the last item in the bucket and returns its key and value.\n// If the bucket is empty then a nil key and value are returned.\n// The returned key and value are only valid for the life of the transaction.\nfunc (c *Cursor) Last() (key []byte, value []byte) {\n\tcommon.Assert(c.bucket.tx.db != nil, \"tx closed\")\n\tc.stack = c.stack[:0]\n\tp, n := c.bucket.pageNode(c.bucket.RootPage())\n\tref := elemRef{page: p, node: n}\n\tref.index = ref.count() - 1\n\tc.stack = append(c.stack, ref)\n\tc.last()\n\n\t// If this is an empty page (calling Delete may result in empty pages)\n\t// we call prev to find the last page that is not empty\n\tfor len(c.stack) > 1 && c.stack[len(c.stack)-1].count() == 0 {\n\t\tc.prev()\n\t}\n\n\tif len(c.stack) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tk, v, flags := c.keyValue()\n\tif (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil\n\t}\n\treturn k, v\n}\n\n// Next moves the cursor to the next item in the bucket and returns its key and value.\n// If the cursor is at the end of the bucket then a nil key and value are returned.\n// The returned key and value are only valid for the life of the transaction.\nfunc (c *Cursor) Next() (key []byte, value []byte) {\n\tcommon.Assert(c.bucket.tx.db != nil, \"tx closed\")\n\tk, v, flags := c.next()\n\tif (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil\n\t}\n\treturn k, v\n}\n\n// Prev moves the cursor to the previous item in the bucket and returns its key and value.\n// If the cursor is at the beginning of the bucket then a nil key and value are returned.\n// The returned key and value are only valid for the life of the transaction.\nfunc (c *Cursor) Prev() (key []byte, value []byte) {\n\tcommon.Assert(c.bucket.tx.db != nil, \"tx closed\")\n\tk, v, flags := c.prev()\n\tif (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil\n\t}\n\treturn k, v\n}\n\n// Seek moves the cursor to a given key using a b-tree search and returns it.\n// If the key does not exist then the next key is used. If no keys\n// follow, a nil key is returned.\n// The returned key and value are only valid for the life of the transaction.\nfunc (c *Cursor) Seek(seek []byte) (key []byte, value []byte) {\n\tcommon.Assert(c.bucket.tx.db != nil, \"tx closed\")\n\n\tk, v, flags := c.seek(seek)\n\n\t// If we ended up after the last element of a page then move to the next one.\n\tif ref := &c.stack[len(c.stack)-1]; ref.index >= ref.count() {\n\t\tk, v, flags = c.next()\n\t}\n\n\tif k == nil {\n\t\treturn nil, nil\n\t} else if (flags & uint32(common.BucketLeafFlag)) != 0 {\n\t\treturn k, nil\n\t}\n\treturn k, v\n}\n\n// Delete removes the current key/value under the cursor from the bucket.\n// Delete fails if current key/value is a bucket or if the transaction is not writable.\nfunc (c *Cursor) Delete() error {\n\tif c.bucket.tx.db == nil {\n\t\treturn errors.ErrTxClosed\n\t} else if !c.bucket.Writable() {\n\t\treturn errors.ErrTxNotWritable\n\t}\n\n\tkey, _, flags := c.keyValue()\n\t// Return an error if current value is a bucket.\n\tif (flags & common.BucketLeafFlag) != 0 {\n\t\treturn errors.ErrIncompatibleValue\n\t}\n\tc.node().del(key)\n\n\treturn nil\n}\n\n// seek moves the cursor to a given key and returns it.\n// If the key does not exist then the next key is used.\nfunc (c *Cursor) seek(seek []byte) (key []byte, value []byte, flags uint32) {\n\t// Start from root page/node and traverse to correct page.\n\tc.stack = c.stack[:0]\n\tc.search(seek, c.bucket.RootPage())\n\n\t// If this is a bucket then return a nil value.\n\treturn c.keyValue()\n}\n\n// first moves the cursor to the first leaf element under the last page in the stack.\nfunc (c *Cursor) goToFirstElementOnTheStack() {\n\tfor {\n\t\t// Exit when we hit a leaf page.\n\t\tvar ref = &c.stack[len(c.stack)-1]\n\t\tif ref.isLeaf() {\n\t\t\tbreak\n\t\t}\n\n\t\t// Keep adding pages pointing to the first element to the stack.\n\t\tvar pgId common.Pgid\n\t\tif ref.node != nil {\n\t\t\tpgId = ref.node.inodes[ref.index].Pgid()\n\t\t} else {\n\t\t\tpgId = ref.page.BranchPageElement(uint16(ref.index)).Pgid()\n\t\t}\n\t\tp, n := c.bucket.pageNode(pgId)\n\t\tc.stack = append(c.stack, elemRef{page: p, node: n, index: 0})\n\t}\n}\n\n// last moves the cursor to the last leaf element under the last page in the stack.\nfunc (c *Cursor) last() {\n\tfor {\n\t\t// Exit when we hit a leaf page.\n\t\tref := &c.stack[len(c.stack)-1]\n\t\tif ref.isLeaf() {\n\t\t\tbreak\n\t\t}\n\n\t\t// Keep adding pages pointing to the last element in the stack.\n\t\tvar pgId common.Pgid\n\t\tif ref.node != nil {\n\t\t\tpgId = ref.node.inodes[ref.index].Pgid()\n\t\t} else {\n\t\t\tpgId = ref.page.BranchPageElement(uint16(ref.index)).Pgid()\n\t\t}\n\t\tp, n := c.bucket.pageNode(pgId)\n\n\t\tvar nextRef = elemRef{page: p, node: n}\n\t\tnextRef.index = nextRef.count() - 1\n\t\tc.stack = append(c.stack, nextRef)\n\t}\n}\n\n// next moves to the next leaf element and returns the key and value.\n// If the cursor is at the last leaf element then it stays there and returns nil.\nfunc (c *Cursor) next() (key []byte, value []byte, flags uint32) {\n\tfor {\n\t\t// Attempt to move over one element until we're successful.\n\t\t// Move up the stack as we hit the end of each page in our stack.\n\t\tvar i int\n\t\tfor i = len(c.stack) - 1; i >= 0; i-- {\n\t\t\telem := &c.stack[i]\n\t\t\tif elem.index < elem.count()-1 {\n\t\t\t\telem.index++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If we've hit the root page then stop and return. This will leave the\n\t\t// cursor on the last element of the last page.\n\t\tif i == -1 {\n\t\t\treturn nil, nil, 0\n\t\t}\n\n\t\t// Otherwise start from where we left off in the stack and find the\n\t\t// first element of the first leaf page.\n\t\tc.stack = c.stack[:i+1]\n\t\tc.goToFirstElementOnTheStack()\n\n\t\t// If this is an empty page then restart and move back up the stack.\n\t\t// https://github.com/boltdb/bolt/issues/450\n\t\tif c.stack[len(c.stack)-1].count() == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn c.keyValue()\n\t}\n}\n\n// prev moves the cursor to the previous item in the bucket and returns its key and value.\n// If the cursor is at the beginning of the bucket then a nil key and value are returned.\nfunc (c *Cursor) prev() (key []byte, value []byte, flags uint32) {\n\t// Attempt to move back one element until we're successful.\n\t// Move up the stack as we hit the beginning of each page in our stack.\n\tfor i := len(c.stack) - 1; i >= 0; i-- {\n\t\telem := &c.stack[i]\n\t\tif elem.index > 0 {\n\t\t\telem.index--\n\t\t\tbreak\n\t\t}\n\t\t// If we've hit the beginning, we should stop moving the cursor,\n\t\t// and stay at the first element, so that users can continue to\n\t\t// iterate over the elements in reverse direction by calling `Next`.\n\t\t// We should return nil in such case.\n\t\t// Refer to https://github.com/etcd-io/bbolt/issues/733\n\t\tif len(c.stack) == 1 {\n\t\t\tc.first()\n\t\t\treturn nil, nil, 0\n\t\t}\n\t\tc.stack = c.stack[:i]\n\t}\n\n\t// If we've hit the end then return nil.\n\tif len(c.stack) == 0 {\n\t\treturn nil, nil, 0\n\t}\n\n\t// Move down the stack to find the last element of the last leaf under this branch.\n\tc.last()\n\treturn c.keyValue()\n}\n\n// search recursively performs a binary search against a given page/node until it finds a given key.\nfunc (c *Cursor) search(key []byte, pgId common.Pgid) {\n\tp, n := c.bucket.pageNode(pgId)\n\tif p != nil && !p.IsBranchPage() && !p.IsLeafPage() {\n\t\tpanic(fmt.Sprintf(\"invalid page type: %d: %x\", p.Id(), p.Flags()))\n\t}\n\te := elemRef{page: p, node: n}\n\tc.stack = append(c.stack, e)\n\n\t// If we're on a leaf page/node then find the specific node.\n\tif e.isLeaf() {\n\t\tc.nsearch(key)\n\t\treturn\n\t}\n\n\tif n != nil {\n\t\tc.searchNode(key, n)\n\t\treturn\n\t}\n\tc.searchPage(key, p)\n}\n\nfunc (c *Cursor) searchNode(key []byte, n *node) {\n\tvar exact bool\n\tindex := sort.Search(len(n.inodes), func(i int) bool {\n\t\t// TODO(benbjohnson): Optimize this range search. It's a bit hacky right now.\n\t\t// sort.Search() finds the lowest index where f() != -1 but we need the highest index.\n\t\tret := bytes.Compare(n.inodes[i].Key(), key)\n\t\tif ret == 0 {\n\t\t\texact = true\n\t\t}\n\t\treturn ret != -1\n\t})\n\tif !exact && index > 0 {\n\t\tindex--\n\t}\n\tc.stack[len(c.stack)-1].index = index\n\n\t// Recursively search to the next page.\n\tc.search(key, n.inodes[index].Pgid())\n}\n\nfunc (c *Cursor) searchPage(key []byte, p *common.Page) {\n\t// Binary search for the correct range.\n\tinodes := p.BranchPageElements()\n\n\tvar exact bool\n\tindex := sort.Search(int(p.Count()), func(i int) bool {\n\t\t// TODO(benbjohnson): Optimize this range search. It's a bit hacky right now.\n\t\t// sort.Search() finds the lowest index where f() != -1 but we need the highest index.\n\t\tret := bytes.Compare(inodes[i].Key(), key)\n\t\tif ret == 0 {\n\t\t\texact = true\n\t\t}\n\t\treturn ret != -1\n\t})\n\tif !exact && index > 0 {\n\t\tindex--\n\t}\n\tc.stack[len(c.stack)-1].index = index\n\n\t// Recursively search to the next page.\n\tc.search(key, inodes[index].Pgid())\n}\n\n// nsearch searches the leaf node on the top of the stack for a key.\nfunc (c *Cursor) nsearch(key []byte) {\n\te := &c.stack[len(c.stack)-1]\n\tp, n := e.page, e.node\n\n\t// If we have a node then search its inodes.\n\tif n != nil {\n\t\tindex := sort.Search(len(n.inodes), func(i int) bool {\n\t\t\treturn bytes.Compare(n.inodes[i].Key(), key) != -1\n\t\t})\n\t\te.index = index\n\t\treturn\n\t}\n\n\t// If we have a page then search its leaf elements.\n\tinodes := p.LeafPageElements()\n\tindex := sort.Search(int(p.Count()), func(i int) bool {\n\t\treturn bytes.Compare(inodes[i].Key(), key) != -1\n\t})\n\te.index = index\n}\n\n// keyValue returns the key and value of the current leaf element.\nfunc (c *Cursor) keyValue() ([]byte, []byte, uint32) {\n\tref := &c.stack[len(c.stack)-1]\n\n\t// If the cursor is pointing to the end of page/node then return nil.\n\tif ref.count() == 0 || ref.index >= ref.count() {\n\t\treturn nil, nil, 0\n\t}\n\n\t// Retrieve value from node.\n\tif ref.node != nil {\n\t\tinode := &ref.node.inodes[ref.index]\n\t\treturn inode.Key(), inode.Value(), inode.Flags()\n\t}\n\n\t// Or retrieve value from page.\n\telem := ref.page.LeafPageElement(uint16(ref.index))\n\treturn elem.Key(), elem.Value(), elem.Flags()\n}\n\n// node returns the node that the cursor is currently positioned on.\nfunc (c *Cursor) node() *node {\n\tcommon.Assert(len(c.stack) > 0, \"accessing a node with a zero-length cursor stack\")\n\n\t// If the top of the stack is a leaf node then just return it.\n\tif ref := &c.stack[len(c.stack)-1]; ref.node != nil && ref.isLeaf() {\n\t\treturn ref.node\n\t}\n\n\t// Start from root and traverse down the hierarchy.\n\tvar n = c.stack[0].node\n\tif n == nil {\n\t\tn = c.bucket.node(c.stack[0].page.Id(), nil)\n\t}\n\tfor _, ref := range c.stack[:len(c.stack)-1] {\n\t\tcommon.Assert(!n.isLeaf, \"expected branch node\")\n\t\tn = n.childAt(ref.index)\n\t}\n\tcommon.Assert(n.isLeaf, \"expected leaf node\")\n\treturn n\n}\n\n// elemRef represents a reference to an element on a given page/node.\ntype elemRef struct {\n\tpage  *common.Page\n\tnode  *node\n\tindex int\n}\n\n// isLeaf returns whether the ref is pointing at a leaf page/node.\nfunc (r *elemRef) isLeaf() bool {\n\tif r.node != nil {\n\t\treturn r.node.isLeaf\n\t}\n\treturn r.page.IsLeafPage()\n}\n\n// count returns the number of inodes or page elements.\nfunc (r *elemRef) count() int {\n\tif r.node != nil {\n\t\treturn len(r.node.inodes)\n\t}\n\treturn int(r.page.Count())\n}\n"
        },
        {
          "name": "cursor_test.go",
          "type": "blob",
          "size": 22.828125,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\t\"testing/quick\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\n// TestCursor_RepeatOperations verifies that a cursor can continue to\n// iterate over all elements in reverse direction when it has already\n// reached to the end or beginning.\n// Refer to https://github.com/etcd-io/bbolt/issues/733\nfunc TestCursor_RepeatOperations(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ttestFunc func(t2 *testing.T, bucket *bolt.Bucket)\n\t}{\n\t\t{\n\t\t\tname:     \"Repeat NextPrevNext\",\n\t\t\ttestFunc: testRepeatCursorOperations_NextPrevNext,\n\t\t},\n\t\t{\n\t\t\tname:     \"Repeat PrevNextPrev\",\n\t\t\ttestFunc: testRepeatCursorOperations_PrevNextPrev,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{PageSize: 4096})\n\n\t\t\tbucketName := []byte(\"data\")\n\n\t\t\t_ = db.Update(func(tx *bolt.Tx) error {\n\t\t\t\tb, _ := tx.CreateBucketIfNotExists(bucketName)\n\t\t\t\ttestCursorRepeatOperations_PrepareData(t, b)\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\t_ = db.View(func(tx *bolt.Tx) error {\n\t\t\t\tb := tx.Bucket(bucketName)\n\t\t\t\ttc.testFunc(t, b)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc testCursorRepeatOperations_PrepareData(t *testing.T, b *bolt.Bucket) {\n\t// ensure we have at least one branch page.\n\tfor i := 0; i < 1000; i++ {\n\t\tk := []byte(fmt.Sprintf(\"%05d\", i))\n\t\terr := b.Put(k, k)\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc testRepeatCursorOperations_NextPrevNext(t *testing.T, b *bolt.Bucket) {\n\tc := b.Cursor()\n\tc.First()\n\tstartKey := []byte(fmt.Sprintf(\"%05d\", 2))\n\treturnedKey, _ := c.Seek(startKey)\n\trequire.Equal(t, startKey, returnedKey)\n\n\t// Step 1: verify next\n\tfor i := 3; i < 1000; i++ {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Next()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n\n\t// Once we've reached the end, it should always return nil no matter how many times we call `Next`.\n\tfor i := 0; i < 10; i++ {\n\t\tk, _ := c.Next()\n\t\trequire.Equal(t, []byte(nil), k)\n\t}\n\n\t// Step 2: verify prev\n\tfor i := 998; i >= 0; i-- {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Prev()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n\n\t// Once we've reached the beginning, it should always return nil no matter how many times we call `Prev`.\n\tfor i := 0; i < 10; i++ {\n\t\tk, _ := c.Prev()\n\t\trequire.Equal(t, []byte(nil), k)\n\t}\n\n\t// Step 3: verify next again\n\tfor i := 1; i < 1000; i++ {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Next()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n}\n\nfunc testRepeatCursorOperations_PrevNextPrev(t *testing.T, b *bolt.Bucket) {\n\tc := b.Cursor()\n\n\tstartKey := []byte(fmt.Sprintf(\"%05d\", 998))\n\treturnedKey, _ := c.Seek(startKey)\n\trequire.Equal(t, startKey, returnedKey)\n\n\t// Step 1: verify prev\n\tfor i := 997; i >= 0; i-- {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Prev()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n\n\t// Once we've reached the beginning, it should always return nil no matter how many times we call `Prev`.\n\tfor i := 0; i < 10; i++ {\n\t\tk, _ := c.Prev()\n\t\trequire.Equal(t, []byte(nil), k)\n\t}\n\n\t// Step 2: verify next\n\tfor i := 1; i < 1000; i++ {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Next()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n\n\t// Once we've reached the end, it should always return nil no matter how many times we call `Next`.\n\tfor i := 0; i < 10; i++ {\n\t\tk, _ := c.Next()\n\t\trequire.Equal(t, []byte(nil), k)\n\t}\n\n\t// Step 3: verify prev again\n\tfor i := 998; i >= 0; i-- {\n\t\texpectedKey := []byte(fmt.Sprintf(\"%05d\", i))\n\t\tactualKey, _ := c.Prev()\n\t\trequire.Equal(t, expectedKey, actualKey)\n\t}\n}\n\n// Ensure that a cursor can return a reference to the bucket that created it.\nfunc TestCursor_Bucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif cb := b.Cursor().Bucket(); !reflect.DeepEqual(cb, b) {\n\t\t\tt.Fatal(\"cursor bucket mismatch\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can seek to the appropriate keys.\nfunc TestCursor_Seek(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"0001\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"bar\"), []byte(\"0002\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"0003\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif _, err := b.CreateBucket([]byte(\"bkt\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\n\t\t// Exact match should go to the key.\n\t\tif k, v := c.Seek([]byte(\"bar\")); !bytes.Equal(k, []byte(\"bar\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if !bytes.Equal(v, []byte(\"0002\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\n\t\t// Inexact match should go to the next key.\n\t\tif k, v := c.Seek([]byte(\"bas\")); !bytes.Equal(k, []byte(\"baz\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if !bytes.Equal(v, []byte(\"0003\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\n\t\t// Low key should go to the first key.\n\t\tif k, v := c.Seek([]byte(\"\")); !bytes.Equal(k, []byte(\"bar\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if !bytes.Equal(v, []byte(\"0002\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\n\t\t// High key should return no key.\n\t\tif k, v := c.Seek([]byte(\"zzz\")); k != nil {\n\t\t\tt.Fatalf(\"expected nil key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t\t}\n\n\t\t// Buckets should return their key but no value.\n\t\tif k, v := c.Seek([]byte(\"bkt\")); !bytes.Equal(k, []byte(\"bkt\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCursor_Delete(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tconst count = 1000\n\n\t// Insert every other key between 0 and $count.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor i := 0; i < count; i += 1 {\n\t\t\tk := make([]byte, 8)\n\t\t\tbinary.BigEndian.PutUint64(k, uint64(i))\n\t\t\tif err := b.Put(k, make([]byte, 100)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"sub\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tbound := make([]byte, 8)\n\t\tbinary.BigEndian.PutUint64(bound, uint64(count/2))\n\t\tfor key, _ := c.First(); bytes.Compare(key, bound) < 0; key, _ = c.Next() {\n\t\t\tif err := c.Delete(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tc.Seek([]byte(\"sub\"))\n\t\tif err := c.Delete(); err != errors.ErrIncompatibleValue {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tstats := tx.Bucket([]byte(\"widgets\")).Stats()\n\t\tif stats.KeyN != count/2+1 {\n\t\t\tt.Fatalf(\"unexpected KeyN: %d\", stats.KeyN)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can seek to the appropriate keys when there are a\n// large number of keys. This test also checks that seek will always move\n// forward to the next key.\n//\n// Related: https://github.com/boltdb/bolt/pull/187\nfunc TestCursor_Seek_Large(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar count = 10000\n\n\t// Insert every other key between 0 and $count.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < count; i += 100 {\n\t\t\tfor j := i; j < i+100; j += 2 {\n\t\t\t\tk := make([]byte, 8)\n\t\t\t\tbinary.BigEndian.PutUint64(k, uint64(j))\n\t\t\t\tif err := b.Put(k, make([]byte, 100)); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tfor i := 0; i < count; i++ {\n\t\t\tseek := make([]byte, 8)\n\t\t\tbinary.BigEndian.PutUint64(seek, uint64(i))\n\n\t\t\tk, _ := c.Seek(seek)\n\n\t\t\t// The last seek is beyond the end of the range so\n\t\t\t// it should return nil.\n\t\t\tif i == count-1 {\n\t\t\t\tif k != nil {\n\t\t\t\t\tt.Fatal(\"expected nil key\")\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Otherwise we should seek to the exact key or the next key.\n\t\t\tnum := binary.BigEndian.Uint64(k)\n\t\t\tif i%2 == 0 {\n\t\t\t\tif num != uint64(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected num: %d\", num)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif num != uint64(i+1) {\n\t\t\t\t\tt.Fatalf(\"unexpected num: %d\", num)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a cursor can iterate over an empty bucket without error.\nfunc TestCursor_EmptyBucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tk, v := c.First()\n\t\tif k != nil {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can reverse iterate over an empty bucket without error.\nfunc TestCursor_EmptyBucketReverse(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tk, v := c.Last()\n\t\tif k != nil {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can iterate over a single root with a couple elements.\nfunc TestCursor_Iterate_Leaf(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte{}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte{0}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"bar\"), []byte{1}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttx, err := db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() { _ = tx.Rollback() }()\n\n\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\n\tk, v := c.First()\n\tif !bytes.Equal(k, []byte(\"bar\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{1}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tk, v = c.Next()\n\tif !bytes.Equal(k, []byte(\"baz\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tk, v = c.Next()\n\tif !bytes.Equal(k, []byte(\"foo\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{0}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tk, v = c.Next()\n\tif k != nil {\n\t\tt.Fatalf(\"expected nil key: %v\", k)\n\t} else if v != nil {\n\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t}\n\n\tk, v = c.Next()\n\tif k != nil {\n\t\tt.Fatalf(\"expected nil key: %v\", k)\n\t} else if v != nil {\n\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can iterate in reverse over a single root with a couple elements.\nfunc TestCursor_LeafRootReverse(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte{}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte{0}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"bar\"), []byte{1}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttx, err := db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\n\tif k, v := c.Last(); !bytes.Equal(k, []byte(\"foo\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{0}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tif k, v := c.Prev(); !bytes.Equal(k, []byte(\"baz\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tif k, v := c.Prev(); !bytes.Equal(k, []byte(\"bar\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t} else if !bytes.Equal(v, []byte{1}) {\n\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t}\n\n\tif k, v := c.Prev(); k != nil {\n\t\tt.Fatalf(\"expected nil key: %v\", k)\n\t} else if v != nil {\n\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t}\n\n\tif k, v := c.Prev(); k != nil {\n\t\tt.Fatalf(\"expected nil key: %v\", k)\n\t} else if v != nil {\n\t\tt.Fatalf(\"expected nil value: %v\", v)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can restart from the beginning.\nfunc TestCursor_Restart(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"bar\"), []byte{}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte{}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttx, err := db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\n\tif k, _ := c.First(); !bytes.Equal(k, []byte(\"bar\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t}\n\tif k, _ := c.Next(); !bytes.Equal(k, []byte(\"foo\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t}\n\n\tif k, _ := c.First(); !bytes.Equal(k, []byte(\"bar\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t}\n\tif k, _ := c.Next(); !bytes.Equal(k, []byte(\"foo\")) {\n\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a cursor can skip over empty pages that have been deleted.\nfunc TestCursor_First_EmptyPages(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Create 1000 keys in the \"widgets\" bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tif err := b.Put(u64tob(uint64(i)), []byte{}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Delete half the keys and then try to iterate.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 0; i < 600; i++ {\n\t\t\tif err := b.Delete(u64tob(uint64(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tc := b.Cursor()\n\t\tvar n int\n\t\tfor k, _ := c.First(); k != nil; k, _ = c.Next() {\n\t\t\tn++\n\t\t}\n\t\tif n != 400 {\n\t\t\tt.Fatalf(\"unexpected key count: %d\", n)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a cursor can skip over empty pages that have been deleted.\nfunc TestCursor_Last_EmptyPages(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Create 1000 keys in the \"widgets\" bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tif err := b.Put(u64tob(uint64(i)), []byte{}); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Delete last 800 elements to ensure last page is empty\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 200; i < 1000; i++ {\n\t\t\tif err := b.Delete(u64tob(uint64(i))); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\tc := b.Cursor()\n\t\tvar n int\n\t\tfor k, _ := c.Last(); k != nil; k, _ = c.Prev() {\n\t\t\tn++\n\t\t}\n\t\tif n != 200 {\n\t\t\tt.Fatalf(\"unexpected key count: %d\", n)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx can iterate over all elements in a bucket.\nfunc TestCursor_QuickCheck(t *testing.T) {\n\tf := func(items testdata) bool {\n\t\tdb := btesting.MustCreateDB(t)\n\t\tdefer db.MustClose()\n\n\t\t// Bulk insert all values.\n\t\ttx, err := db.Begin(true)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, item := range items {\n\t\t\tif err := b.Put(item.Key, item.Value); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif err := tx.Commit(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Sort test data.\n\t\tsort.Sort(items)\n\n\t\t// Iterate over all items and check consistency.\n\t\tvar index = 0\n\t\ttx, err = db.Begin(false)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tfor k, v := c.First(); k != nil && index < len(items); k, v = c.Next() {\n\t\t\tif !bytes.Equal(k, items[index].Key) {\n\t\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t\t} else if !bytes.Equal(v, items[index].Value) {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t\t}\n\t\t\tindex++\n\t\t}\n\t\tif len(items) != index {\n\t\t\tt.Fatalf(\"unexpected item count: %v, expected %v\", len(items), index)\n\t\t}\n\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn true\n\t}\n\tif err := quick.Check(f, qconfig()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// Ensure that a transaction can iterate over all elements in a bucket in reverse.\nfunc TestCursor_QuickCheck_Reverse(t *testing.T) {\n\tf := func(items testdata) bool {\n\t\tdb := btesting.MustCreateDB(t)\n\t\tdefer db.MustClose()\n\n\t\t// Bulk insert all values.\n\t\ttx, err := db.Begin(true)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, item := range items {\n\t\t\tif err := b.Put(item.Key, item.Value); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif err := tx.Commit(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Sort test data.\n\t\tsort.Sort(revtestdata(items))\n\n\t\t// Iterate over all items and check consistency.\n\t\tvar index = 0\n\t\ttx, err = db.Begin(false)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tfor k, v := c.Last(); k != nil && index < len(items); k, v = c.Prev() {\n\t\t\tif !bytes.Equal(k, items[index].Key) {\n\t\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t\t} else if !bytes.Equal(v, items[index].Value) {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t\t}\n\t\t\tindex++\n\t\t}\n\t\tif len(items) != index {\n\t\t\tt.Fatalf(\"unexpected item count: %v, expected %v\", len(items), index)\n\t\t}\n\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn true\n\t}\n\tif err := quick.Check(f, qconfig()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// Ensure that a Tx cursor can iterate over subbuckets.\nfunc TestCursor_QuickCheck_BucketsOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"baz\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvar names []string\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tnames = append(names, string(k))\n\t\t\tif v != nil {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t\t}\n\t\t}\n\t\tif !reflect.DeepEqual(names, []string{\"bar\", \"baz\", \"foo\"}) {\n\t\t\tt.Fatalf(\"unexpected names: %+v\", names)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx cursor can reverse iterate over subbuckets.\nfunc TestCursor_QuickCheck_BucketsOnly_Reverse(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := b.CreateBucket([]byte(\"baz\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvar names []string\n\t\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tnames = append(names, string(k))\n\t\t\tif v != nil {\n\t\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t\t}\n\t\t}\n\t\tif !reflect.DeepEqual(names, []string{\"foo\", \"baz\", \"bar\"}) {\n\t\t\tt.Fatalf(\"unexpected names: %+v\", names)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc ExampleCursor() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Start a read-write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create a new bucket.\n\t\tb, err := tx.CreateBucket([]byte(\"animals\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Insert data into a bucket.\n\t\tif err := b.Put([]byte(\"dog\"), []byte(\"fun\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"cat\"), []byte(\"lame\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"liger\"), []byte(\"awesome\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Create a cursor for iteration.\n\t\tc := b.Cursor()\n\n\t\t// Iterate over items in sorted key order. This starts from the\n\t\t// first key/value pair and updates the k/v variables to the\n\t\t// next key/value on each iteration.\n\t\t//\n\t\t// The loop finishes at the end of the cursor when a nil key is returned.\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tfmt.Printf(\"A %s is %s.\\n\", k, v)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// A cat is lame.\n\t// A dog is fun.\n\t// A liger is awesome.\n}\n\nfunc ExampleCursor_reverse() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Start a read-write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create a new bucket.\n\t\tb, err := tx.CreateBucket([]byte(\"animals\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Insert data into a bucket.\n\t\tif err := b.Put([]byte(\"dog\"), []byte(\"fun\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"cat\"), []byte(\"lame\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"liger\"), []byte(\"awesome\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Create a cursor for iteration.\n\t\tc := b.Cursor()\n\n\t\t// Iterate over items in reverse sorted key order. This starts\n\t\t// from the last key/value pair and updates the k/v variables to\n\t\t// the previous key/value on each iteration.\n\t\t//\n\t\t// The loop finishes at the beginning of the cursor when a nil key\n\t\t// is returned.\n\t\tfor k, v := c.Last(); k != nil; k, v = c.Prev() {\n\t\t\tfmt.Printf(\"A %s is %s.\\n\", k, v)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close the database to release the file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// A liger is awesome.\n\t// A dog is fun.\n\t// A cat is lame.\n}\n"
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 39.681640625,
          "content": "package bbolt\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\tberrors \"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/common\"\n\tfl \"go.etcd.io/bbolt/internal/freelist\"\n)\n\n// The time elapsed between consecutive file locking attempts.\nconst flockRetryTimeout = 50 * time.Millisecond\n\n// FreelistType is the type of the freelist backend\ntype FreelistType string\n\n// TODO(ahrtr): eventually we should (step by step)\n//  1. default to `FreelistMapType`;\n//  2. remove the `FreelistArrayType`, do not export `FreelistMapType`\n//     and remove field `FreelistType' from both `DB` and `Options`;\nconst (\n\t// FreelistArrayType indicates backend freelist type is array\n\tFreelistArrayType = FreelistType(\"array\")\n\t// FreelistMapType indicates backend freelist type is hashmap\n\tFreelistMapType = FreelistType(\"hashmap\")\n)\n\n// DB represents a collection of buckets persisted to a file on disk.\n// All data access is performed through transactions which can be obtained through the DB.\n// All the functions on DB will return a ErrDatabaseNotOpen if accessed before Open() is called.\ntype DB struct {\n\t// Put `stats` at the first field to ensure it's 64-bit aligned. Note that\n\t// the first word in an allocated struct can be relied upon to be 64-bit\n\t// aligned. Refer to https://pkg.go.dev/sync/atomic#pkg-note-BUG. Also\n\t// refer to discussion in https://github.com/etcd-io/bbolt/issues/577.\n\tstats Stats\n\n\t// When enabled, the database will perform a Check() after every commit.\n\t// A panic is issued if the database is in an inconsistent state. This\n\t// flag has a large performance impact so it should only be used for\n\t// debugging purposes.\n\tStrictMode bool\n\n\t// Setting the NoSync flag will cause the database to skip fsync()\n\t// calls after each commit. This can be useful when bulk loading data\n\t// into a database and you can restart the bulk load in the event of\n\t// a system failure or database corruption. Do not set this flag for\n\t// normal use.\n\t//\n\t// If the package global IgnoreNoSync constant is true, this value is\n\t// ignored.  See the comment on that constant for more details.\n\t//\n\t// THIS IS UNSAFE. PLEASE USE WITH CAUTION.\n\tNoSync bool\n\n\t// When true, skips syncing freelist to disk. This improves the database\n\t// write performance under normal operation, but requires a full database\n\t// re-sync during recovery.\n\tNoFreelistSync bool\n\n\t// FreelistType sets the backend freelist type. There are two options. Array which is simple but endures\n\t// dramatic performance degradation if database is large and fragmentation in freelist is common.\n\t// The alternative one is using hashmap, it is faster in almost all circumstances\n\t// but it doesn't guarantee that it offers the smallest page id available. In normal case it is safe.\n\t// The default type is array\n\tFreelistType FreelistType\n\n\t// When true, skips the truncate call when growing the database.\n\t// Setting this to true is only safe on non-ext3/ext4 systems.\n\t// Skipping truncation avoids preallocation of hard drive space and\n\t// bypasses a truncate() and fsync() syscall on remapping.\n\t//\n\t// https://github.com/boltdb/bolt/issues/284\n\tNoGrowSync bool\n\n\t// When `true`, bbolt will always load the free pages when opening the DB.\n\t// When opening db in write mode, this flag will always automatically\n\t// set to `true`.\n\tPreLoadFreelist bool\n\n\t// If you want to read the entire database fast, you can set MmapFlag to\n\t// syscall.MAP_POPULATE on Linux 2.6.23+ for sequential read-ahead.\n\tMmapFlags int\n\n\t// MaxBatchSize is the maximum size of a batch. Default value is\n\t// copied from DefaultMaxBatchSize in Open.\n\t//\n\t// If <=0, disables batching.\n\t//\n\t// Do not change concurrently with calls to Batch.\n\tMaxBatchSize int\n\n\t// MaxBatchDelay is the maximum delay before a batch starts.\n\t// Default value is copied from DefaultMaxBatchDelay in Open.\n\t//\n\t// If <=0, effectively disables batching.\n\t//\n\t// Do not change concurrently with calls to Batch.\n\tMaxBatchDelay time.Duration\n\n\t// AllocSize is the amount of space allocated when the database\n\t// needs to create new pages. This is done to amortize the cost\n\t// of truncate() and fsync() when growing the data file.\n\tAllocSize int\n\n\t// Mlock locks database file in memory when set to true.\n\t// It prevents major page faults, however used memory can't be reclaimed.\n\t//\n\t// Supported only on Unix via mlock/munlock syscalls.\n\tMlock bool\n\n\tlogger Logger\n\n\tpath     string\n\topenFile func(string, int, os.FileMode) (*os.File, error)\n\tfile     *os.File\n\t// `dataref` isn't used at all on Windows, and the golangci-lint\n\t// always fails on Windows platform.\n\t//nolint\n\tdataref  []byte // mmap'ed readonly, write throws SEGV\n\tdata     *[maxMapSize]byte\n\tdatasz   int\n\tmeta0    *common.Meta\n\tmeta1    *common.Meta\n\tpageSize int\n\topened   bool\n\trwtx     *Tx\n\ttxs      []*Tx\n\n\tfreelist     fl.Interface\n\tfreelistLoad sync.Once\n\n\tpagePool sync.Pool\n\n\tbatchMu sync.Mutex\n\tbatch   *batch\n\n\trwlock   sync.Mutex   // Allows only one writer at a time.\n\tmetalock sync.Mutex   // Protects meta page access.\n\tmmaplock sync.RWMutex // Protects mmap access during remapping.\n\tstatlock sync.RWMutex // Protects stats access.\n\n\tops struct {\n\t\twriteAt func(b []byte, off int64) (n int, err error)\n\t}\n\n\t// Read only mode.\n\t// When true, Update() and Begin(true) return ErrDatabaseReadOnly immediately.\n\treadOnly bool\n}\n\n// Path returns the path to currently open database file.\nfunc (db *DB) Path() string {\n\treturn db.path\n}\n\n// GoString returns the Go string representation of the database.\nfunc (db *DB) GoString() string {\n\treturn fmt.Sprintf(\"bolt.DB{path:%q}\", db.path)\n}\n\n// String returns the string representation of the database.\nfunc (db *DB) String() string {\n\treturn fmt.Sprintf(\"DB<%q>\", db.path)\n}\n\n// Open creates and opens a database at the given path with a given file mode.\n// If the file does not exist then it will be created automatically with a given file mode.\n// Passing in nil options will cause Bolt to open the database with the default options.\n// Note: For read/write transactions, ensure the owner has write permission on the created/opened database file, e.g. 0600\nfunc Open(path string, mode os.FileMode, options *Options) (db *DB, err error) {\n\tdb = &DB{\n\t\topened: true,\n\t}\n\n\t// Set default options if no options are provided.\n\tif options == nil {\n\t\toptions = DefaultOptions\n\t}\n\tdb.NoSync = options.NoSync\n\tdb.NoGrowSync = options.NoGrowSync\n\tdb.MmapFlags = options.MmapFlags\n\tdb.NoFreelistSync = options.NoFreelistSync\n\tdb.PreLoadFreelist = options.PreLoadFreelist\n\tdb.FreelistType = options.FreelistType\n\tdb.Mlock = options.Mlock\n\n\t// Set default values for later DB operations.\n\tdb.MaxBatchSize = common.DefaultMaxBatchSize\n\tdb.MaxBatchDelay = common.DefaultMaxBatchDelay\n\tdb.AllocSize = common.DefaultAllocSize\n\n\tif options.Logger == nil {\n\t\tdb.logger = getDiscardLogger()\n\t} else {\n\t\tdb.logger = options.Logger\n\t}\n\n\tlg := db.Logger()\n\tif lg != discardLogger {\n\t\tlg.Infof(\"Opening db file (%s) with mode %s and with options: %s\", path, mode, options)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Opening bbolt db (%s) failed: %v\", path, err)\n\t\t\t} else {\n\t\t\t\tlg.Infof(\"Opening bbolt db (%s) successfully\", path)\n\t\t\t}\n\t\t}()\n\t}\n\n\tflag := os.O_RDWR\n\tif options.ReadOnly {\n\t\tflag = os.O_RDONLY\n\t\tdb.readOnly = true\n\t} else {\n\t\t// always load free pages in write mode\n\t\tdb.PreLoadFreelist = true\n\t\tflag |= os.O_CREATE\n\t}\n\n\tdb.openFile = options.OpenFile\n\tif db.openFile == nil {\n\t\tdb.openFile = os.OpenFile\n\t}\n\n\t// Open data file and separate sync handler for metadata writes.\n\tif db.file, err = db.openFile(path, flag, mode); err != nil {\n\t\t_ = db.close()\n\t\tlg.Errorf(\"failed to open db file (%s): %v\", path, err)\n\t\treturn nil, err\n\t}\n\tdb.path = db.file.Name()\n\n\t// Lock file so that other processes using Bolt in read-write mode cannot\n\t// use the database  at the same time. This would cause corruption since\n\t// the two processes would write meta pages and free pages separately.\n\t// The database file is locked exclusively (only one process can grab the lock)\n\t// if !options.ReadOnly.\n\t// The database file is locked using the shared lock (more than one process may\n\t// hold a lock at the same time) otherwise (options.ReadOnly is set).\n\tif err = flock(db, !db.readOnly, options.Timeout); err != nil {\n\t\t_ = db.close()\n\t\tlg.Errorf(\"failed to lock db file (%s), readonly: %t, error: %v\", path, db.readOnly, err)\n\t\treturn nil, err\n\t}\n\n\t// Default values for test hooks\n\tdb.ops.writeAt = db.file.WriteAt\n\n\tif db.pageSize = options.PageSize; db.pageSize == 0 {\n\t\t// Set the default page size to the OS page size.\n\t\tdb.pageSize = common.DefaultPageSize\n\t}\n\n\t// Initialize the database if it doesn't exist.\n\tif info, statErr := db.file.Stat(); statErr != nil {\n\t\t_ = db.close()\n\t\tlg.Errorf(\"failed to get db file's stats (%s): %v\", path, err)\n\t\treturn nil, statErr\n\t} else if info.Size() == 0 {\n\t\t// Initialize new files with meta pages.\n\t\tif err = db.init(); err != nil {\n\t\t\t// clean up file descriptor on initialization fail\n\t\t\t_ = db.close()\n\t\t\tlg.Errorf(\"failed to initialize db file (%s): %v\", path, err)\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// try to get the page size from the metadata pages\n\t\tif db.pageSize, err = db.getPageSize(); err != nil {\n\t\t\t_ = db.close()\n\t\t\tlg.Errorf(\"failed to get page size from db file (%s): %v\", path, err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Initialize page pool.\n\tdb.pagePool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn make([]byte, db.pageSize)\n\t\t},\n\t}\n\n\t// Memory map the data file.\n\tif err = db.mmap(options.InitialMmapSize); err != nil {\n\t\t_ = db.close()\n\t\tlg.Errorf(\"failed to map db file (%s): %v\", path, err)\n\t\treturn nil, err\n\t}\n\n\tif db.PreLoadFreelist {\n\t\tdb.loadFreelist()\n\t}\n\n\tif db.readOnly {\n\t\treturn db, nil\n\t}\n\n\t// Flush freelist when transitioning from no sync to sync so\n\t// NoFreelistSync unaware boltdb can open the db later.\n\tif !db.NoFreelistSync && !db.hasSyncedFreelist() {\n\t\ttx, txErr := db.Begin(true)\n\t\tif tx != nil {\n\t\t\ttxErr = tx.Commit()\n\t\t}\n\t\tif txErr != nil {\n\t\t\tlg.Errorf(\"starting readwrite transaction failed: %v\", txErr)\n\t\t\t_ = db.close()\n\t\t\treturn nil, txErr\n\t\t}\n\t}\n\n\t// Mark the database as opened and return.\n\treturn db, nil\n}\n\n// getPageSize reads the pageSize from the meta pages. It tries\n// to read the first meta page firstly. If the first page is invalid,\n// then it tries to read the second page using the default page size.\nfunc (db *DB) getPageSize() (int, error) {\n\tvar (\n\t\tmeta0CanRead, meta1CanRead bool\n\t)\n\n\t// Read the first meta page to determine the page size.\n\tif pgSize, canRead, err := db.getPageSizeFromFirstMeta(); err != nil {\n\t\t// We cannot read the page size from page 0, but can read page 0.\n\t\tmeta0CanRead = canRead\n\t} else {\n\t\treturn pgSize, nil\n\t}\n\n\t// Read the second meta page to determine the page size.\n\tif pgSize, canRead, err := db.getPageSizeFromSecondMeta(); err != nil {\n\t\t// We cannot read the page size from page 1, but can read page 1.\n\t\tmeta1CanRead = canRead\n\t} else {\n\t\treturn pgSize, nil\n\t}\n\n\t// If we can't read the page size from both pages, but can read\n\t// either page, then we assume it's the same as the OS or the one\n\t// given, since that's how the page size was chosen in the first place.\n\t//\n\t// If both pages are invalid, and (this OS uses a different page size\n\t// from what the database was created with or the given page size is\n\t// different from what the database was created with), then we are out\n\t// of luck and cannot access the database.\n\tif meta0CanRead || meta1CanRead {\n\t\treturn db.pageSize, nil\n\t}\n\n\treturn 0, berrors.ErrInvalid\n}\n\n// getPageSizeFromFirstMeta reads the pageSize from the first meta page\nfunc (db *DB) getPageSizeFromFirstMeta() (int, bool, error) {\n\tvar buf [0x1000]byte\n\tvar metaCanRead bool\n\tif bw, err := db.file.ReadAt(buf[:], 0); err == nil && bw == len(buf) {\n\t\tmetaCanRead = true\n\t\tif m := db.pageInBuffer(buf[:], 0).Meta(); m.Validate() == nil {\n\t\t\treturn int(m.PageSize()), metaCanRead, nil\n\t\t}\n\t}\n\treturn 0, metaCanRead, berrors.ErrInvalid\n}\n\n// getPageSizeFromSecondMeta reads the pageSize from the second meta page\nfunc (db *DB) getPageSizeFromSecondMeta() (int, bool, error) {\n\tvar (\n\t\tfileSize    int64\n\t\tmetaCanRead bool\n\t)\n\n\t// get the db file size\n\tif info, err := db.file.Stat(); err != nil {\n\t\treturn 0, metaCanRead, err\n\t} else {\n\t\tfileSize = info.Size()\n\t}\n\n\t// We need to read the second meta page, so we should skip the first page;\n\t// but we don't know the exact page size yet, it's chicken & egg problem.\n\t// The solution is to try all the possible page sizes, which starts from 1KB\n\t// and until 16MB (1024<<14) or the end of the db file\n\t//\n\t// TODO: should we support larger page size?\n\tfor i := 0; i <= 14; i++ {\n\t\tvar buf [0x1000]byte\n\t\tvar pos int64 = 1024 << uint(i)\n\t\tif pos >= fileSize-1024 {\n\t\t\tbreak\n\t\t}\n\t\tbw, err := db.file.ReadAt(buf[:], pos)\n\t\tif (err == nil && bw == len(buf)) || (err == io.EOF && int64(bw) == (fileSize-pos)) {\n\t\t\tmetaCanRead = true\n\t\t\tif m := db.pageInBuffer(buf[:], 0).Meta(); m.Validate() == nil {\n\t\t\t\treturn int(m.PageSize()), metaCanRead, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0, metaCanRead, berrors.ErrInvalid\n}\n\n// loadFreelist reads the freelist if it is synced, or reconstructs it\n// by scanning the DB if it is not synced. It assumes there are no\n// concurrent accesses being made to the freelist.\nfunc (db *DB) loadFreelist() {\n\tdb.freelistLoad.Do(func() {\n\t\tdb.freelist = newFreelist(db.FreelistType)\n\t\tif !db.hasSyncedFreelist() {\n\t\t\t// Reconstruct free list by scanning the DB.\n\t\t\tdb.freelist.Init(db.freepages())\n\t\t} else {\n\t\t\t// Read free list from freelist page.\n\t\t\tdb.freelist.Read(db.page(db.meta().Freelist()))\n\t\t}\n\t\tdb.stats.FreePageN = db.freelist.FreeCount()\n\t})\n}\n\nfunc (db *DB) hasSyncedFreelist() bool {\n\treturn db.meta().Freelist() != common.PgidNoFreelist\n}\n\nfunc (db *DB) fileSize() (int, error) {\n\tinfo, err := db.file.Stat()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"file stat error: %w\", err)\n\t}\n\tsz := int(info.Size())\n\tif sz < db.pageSize*2 {\n\t\treturn 0, fmt.Errorf(\"file size too small %d\", sz)\n\t}\n\treturn sz, nil\n}\n\n// mmap opens the underlying memory-mapped file and initializes the meta references.\n// minsz is the minimum size that the new mmap can be.\nfunc (db *DB) mmap(minsz int) (err error) {\n\tdb.mmaplock.Lock()\n\tdefer db.mmaplock.Unlock()\n\n\tlg := db.Logger()\n\n\t// Ensure the size is at least the minimum size.\n\tvar fileSize int\n\tfileSize, err = db.fileSize()\n\tif err != nil {\n\t\tlg.Errorf(\"getting file size failed: %w\", err)\n\t\treturn err\n\t}\n\tvar size = fileSize\n\tif size < minsz {\n\t\tsize = minsz\n\t}\n\tsize, err = db.mmapSize(size)\n\tif err != nil {\n\t\tlg.Errorf(\"getting map size failed: %w\", err)\n\t\treturn err\n\t}\n\n\tif db.Mlock {\n\t\t// Unlock db memory\n\t\tif err := db.munlock(fileSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Dereference all mmap references before unmapping.\n\tif db.rwtx != nil {\n\t\tdb.rwtx.root.dereference()\n\t}\n\n\t// Unmap existing data before continuing.\n\tif err = db.munmap(); err != nil {\n\t\treturn err\n\t}\n\n\t// Memory-map the data file as a byte slice.\n\t// gofail: var mapError string\n\t// return errors.New(mapError)\n\tif err = mmap(db, size); err != nil {\n\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] mmap failed, size: %d, error: %v\", runtime.GOOS, runtime.GOARCH, size, err)\n\t\treturn err\n\t}\n\n\t// Perform unmmap on any error to reset all data fields:\n\t// dataref, data, datasz, meta0 and meta1.\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif unmapErr := db.munmap(); unmapErr != nil {\n\t\t\t\terr = fmt.Errorf(\"%w; rollback unmap also failed: %v\", err, unmapErr)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif db.Mlock {\n\t\t// Don't allow swapping of data file\n\t\tif err := db.mlock(fileSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Save references to the meta pages.\n\tdb.meta0 = db.page(0).Meta()\n\tdb.meta1 = db.page(1).Meta()\n\n\t// Validate the meta pages. We only return an error if both meta pages fail\n\t// validation, since meta0 failing validation means that it wasn't saved\n\t// properly -- but we can recover using meta1. And vice-versa.\n\terr0 := db.meta0.Validate()\n\terr1 := db.meta1.Validate()\n\tif err0 != nil && err1 != nil {\n\t\tlg.Errorf(\"both meta pages are invalid, meta0: %v, meta1: %v\", err0, err1)\n\t\treturn err0\n\t}\n\n\treturn nil\n}\n\nfunc (db *DB) invalidate() {\n\tdb.dataref = nil\n\tdb.data = nil\n\tdb.datasz = 0\n\n\tdb.meta0 = nil\n\tdb.meta1 = nil\n}\n\n// munmap unmaps the data file from memory.\nfunc (db *DB) munmap() error {\n\tdefer db.invalidate()\n\n\t// gofail: var unmapError string\n\t// return errors.New(unmapError)\n\tif err := munmap(db); err != nil {\n\t\tdb.Logger().Errorf(\"[GOOS: %s, GOARCH: %s] munmap failed, db.datasz: %d, error: %v\", runtime.GOOS, runtime.GOARCH, db.datasz, err)\n\t\treturn fmt.Errorf(\"unmap error: %v\", err.Error())\n\t}\n\n\treturn nil\n}\n\n// mmapSize determines the appropriate size for the mmap given the current size\n// of the database. The minimum size is 32KB and doubles until it reaches 1GB.\n// Returns an error if the new mmap size is greater than the max allowed.\nfunc (db *DB) mmapSize(size int) (int, error) {\n\t// Double the size from 32KB until 1GB.\n\tfor i := uint(15); i <= 30; i++ {\n\t\tif size <= 1<<i {\n\t\t\treturn 1 << i, nil\n\t\t}\n\t}\n\n\t// Verify the requested size is not above the maximum allowed.\n\tif size > maxMapSize {\n\t\treturn 0, errors.New(\"mmap too large\")\n\t}\n\n\t// If larger than 1GB then grow by 1GB at a time.\n\tsz := int64(size)\n\tif remainder := sz % int64(common.MaxMmapStep); remainder > 0 {\n\t\tsz += int64(common.MaxMmapStep) - remainder\n\t}\n\n\t// Ensure that the mmap size is a multiple of the page size.\n\t// This should always be true since we're incrementing in MBs.\n\tpageSize := int64(db.pageSize)\n\tif (sz % pageSize) != 0 {\n\t\tsz = ((sz / pageSize) + 1) * pageSize\n\t}\n\n\t// If we've exceeded the max size then only grow up to the max size.\n\tif sz > maxMapSize {\n\t\tsz = maxMapSize\n\t}\n\n\treturn int(sz), nil\n}\n\nfunc (db *DB) munlock(fileSize int) error {\n\t// gofail: var munlockError string\n\t// return errors.New(munlockError)\n\tif err := munlock(db, fileSize); err != nil {\n\t\tdb.Logger().Errorf(\"[GOOS: %s, GOARCH: %s] munlock failed, fileSize: %d, db.datasz: %d, error: %v\", runtime.GOOS, runtime.GOARCH, fileSize, db.datasz, err)\n\t\treturn fmt.Errorf(\"munlock error: %v\", err.Error())\n\t}\n\treturn nil\n}\n\nfunc (db *DB) mlock(fileSize int) error {\n\t// gofail: var mlockError string\n\t// return errors.New(mlockError)\n\tif err := mlock(db, fileSize); err != nil {\n\t\tdb.Logger().Errorf(\"[GOOS: %s, GOARCH: %s] mlock failed, fileSize: %d, db.datasz: %d, error: %v\", runtime.GOOS, runtime.GOARCH, fileSize, db.datasz, err)\n\t\treturn fmt.Errorf(\"mlock error: %v\", err.Error())\n\t}\n\treturn nil\n}\n\nfunc (db *DB) mrelock(fileSizeFrom, fileSizeTo int) error {\n\tif err := db.munlock(fileSizeFrom); err != nil {\n\t\treturn err\n\t}\n\tif err := db.mlock(fileSizeTo); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// init creates a new database file and initializes its meta pages.\nfunc (db *DB) init() error {\n\t// Create two meta pages on a buffer.\n\tbuf := make([]byte, db.pageSize*4)\n\tfor i := 0; i < 2; i++ {\n\t\tp := db.pageInBuffer(buf, common.Pgid(i))\n\t\tp.SetId(common.Pgid(i))\n\t\tp.SetFlags(common.MetaPageFlag)\n\n\t\t// Initialize the meta page.\n\t\tm := p.Meta()\n\t\tm.SetMagic(common.Magic)\n\t\tm.SetVersion(common.Version)\n\t\tm.SetPageSize(uint32(db.pageSize))\n\t\tm.SetFreelist(2)\n\t\tm.SetRootBucket(common.NewInBucket(3, 0))\n\t\tm.SetPgid(4)\n\t\tm.SetTxid(common.Txid(i))\n\t\tm.SetChecksum(m.Sum64())\n\t}\n\n\t// Write an empty freelist at page 3.\n\tp := db.pageInBuffer(buf, common.Pgid(2))\n\tp.SetId(2)\n\tp.SetFlags(common.FreelistPageFlag)\n\tp.SetCount(0)\n\n\t// Write an empty leaf page at page 4.\n\tp = db.pageInBuffer(buf, common.Pgid(3))\n\tp.SetId(3)\n\tp.SetFlags(common.LeafPageFlag)\n\tp.SetCount(0)\n\n\t// Write the buffer to our data file.\n\tif _, err := db.ops.writeAt(buf, 0); err != nil {\n\t\tdb.Logger().Errorf(\"writeAt failed: %w\", err)\n\t\treturn err\n\t}\n\tif err := fdatasync(db); err != nil {\n\t\tdb.Logger().Errorf(\"[GOOS: %s, GOARCH: %s] fdatasync failed: %w\", runtime.GOOS, runtime.GOARCH, err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Close releases all database resources.\n// It will block waiting for any open transactions to finish\n// before closing the database and returning.\nfunc (db *DB) Close() error {\n\tdb.rwlock.Lock()\n\tdefer db.rwlock.Unlock()\n\n\tdb.metalock.Lock()\n\tdefer db.metalock.Unlock()\n\n\tdb.mmaplock.Lock()\n\tdefer db.mmaplock.Unlock()\n\n\treturn db.close()\n}\n\nfunc (db *DB) close() error {\n\tif !db.opened {\n\t\treturn nil\n\t}\n\n\tdb.opened = false\n\n\tdb.freelist = nil\n\n\t// Clear ops.\n\tdb.ops.writeAt = nil\n\n\tvar errs []error\n\t// Close the mmap.\n\tif err := db.munmap(); err != nil {\n\t\terrs = append(errs, err)\n\t}\n\n\t// Close file handles.\n\tif db.file != nil {\n\t\t// No need to unlock read-only file.\n\t\tif !db.readOnly {\n\t\t\t// Unlock the file.\n\t\t\tif err := funlock(db); err != nil {\n\t\t\t\terrs = append(errs, fmt.Errorf(\"bolt.Close(): funlock error: %w\", err))\n\t\t\t}\n\t\t}\n\n\t\t// Close the file descriptor.\n\t\tif err := db.file.Close(); err != nil {\n\t\t\terrs = append(errs, fmt.Errorf(\"db file close: %w\", err))\n\t\t}\n\t\tdb.file = nil\n\t}\n\n\tdb.path = \"\"\n\n\tif len(errs) > 0 {\n\t\treturn errs[0]\n\t}\n\treturn nil\n}\n\n// Begin starts a new transaction.\n// Multiple read-only transactions can be used concurrently but only one\n// write transaction can be used at a time. Starting multiple write transactions\n// will cause the calls to block and be serialized until the current write\n// transaction finishes.\n//\n// Transactions should not be dependent on one another. Opening a read\n// transaction and a write transaction in the same goroutine can cause the\n// writer to deadlock because the database periodically needs to re-mmap itself\n// as it grows and it cannot do that while a read transaction is open.\n//\n// If a long running read transaction (for example, a snapshot transaction) is\n// needed, you might want to set DB.InitialMmapSize to a large enough value\n// to avoid potential blocking of write transaction.\n//\n// IMPORTANT: You must close read-only transactions after you are finished or\n// else the database will not reclaim old pages.\nfunc (db *DB) Begin(writable bool) (t *Tx, err error) {\n\tif lg := db.Logger(); lg != discardLogger {\n\t\tlg.Debugf(\"Starting a new transaction [writable: %t]\", writable)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Starting a new transaction [writable: %t] failed: %v\", writable, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Starting a new transaction [writable: %t] successfully\", writable)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif writable {\n\t\treturn db.beginRWTx()\n\t}\n\treturn db.beginTx()\n}\n\nfunc (db *DB) Logger() Logger {\n\tif db == nil || db.logger == nil {\n\t\treturn getDiscardLogger()\n\t}\n\treturn db.logger\n}\n\nfunc (db *DB) beginTx() (*Tx, error) {\n\t// Lock the meta pages while we initialize the transaction. We obtain\n\t// the meta lock before the mmap lock because that's the order that the\n\t// write transaction will obtain them.\n\tdb.metalock.Lock()\n\n\t// Obtain a read-only lock on the mmap. When the mmap is remapped it will\n\t// obtain a write lock so all transactions must finish before it can be\n\t// remapped.\n\tdb.mmaplock.RLock()\n\n\t// Exit if the database is not open yet.\n\tif !db.opened {\n\t\tdb.mmaplock.RUnlock()\n\t\tdb.metalock.Unlock()\n\t\treturn nil, berrors.ErrDatabaseNotOpen\n\t}\n\n\t// Exit if the database is not correctly mapped.\n\tif db.data == nil {\n\t\tdb.mmaplock.RUnlock()\n\t\tdb.metalock.Unlock()\n\t\treturn nil, berrors.ErrInvalidMapping\n\t}\n\n\t// Create a transaction associated with the database.\n\tt := &Tx{}\n\tt.init(db)\n\n\t// Keep track of transaction until it closes.\n\tdb.txs = append(db.txs, t)\n\tn := len(db.txs)\n\tif db.freelist != nil {\n\t\tdb.freelist.AddReadonlyTXID(t.meta.Txid())\n\t}\n\n\t// Unlock the meta pages.\n\tdb.metalock.Unlock()\n\n\t// Update the transaction stats.\n\tdb.statlock.Lock()\n\tdb.stats.TxN++\n\tdb.stats.OpenTxN = n\n\tdb.statlock.Unlock()\n\n\treturn t, nil\n}\n\nfunc (db *DB) beginRWTx() (*Tx, error) {\n\t// If the database was opened with Options.ReadOnly, return an error.\n\tif db.readOnly {\n\t\treturn nil, berrors.ErrDatabaseReadOnly\n\t}\n\n\t// Obtain writer lock. This is released by the transaction when it closes.\n\t// This enforces only one writer transaction at a time.\n\tdb.rwlock.Lock()\n\n\t// Once we have the writer lock then we can lock the meta pages so that\n\t// we can set up the transaction.\n\tdb.metalock.Lock()\n\tdefer db.metalock.Unlock()\n\n\t// Exit if the database is not open yet.\n\tif !db.opened {\n\t\tdb.rwlock.Unlock()\n\t\treturn nil, berrors.ErrDatabaseNotOpen\n\t}\n\n\t// Exit if the database is not correctly mapped.\n\tif db.data == nil {\n\t\tdb.rwlock.Unlock()\n\t\treturn nil, berrors.ErrInvalidMapping\n\t}\n\n\t// Create a transaction associated with the database.\n\tt := &Tx{writable: true}\n\tt.init(db)\n\tdb.rwtx = t\n\tdb.freelist.ReleasePendingPages()\n\treturn t, nil\n}\n\n// removeTx removes a transaction from the database.\nfunc (db *DB) removeTx(tx *Tx) {\n\t// Release the read lock on the mmap.\n\tdb.mmaplock.RUnlock()\n\n\t// Use the meta lock to restrict access to the DB object.\n\tdb.metalock.Lock()\n\n\t// Remove the transaction.\n\tfor i, t := range db.txs {\n\t\tif t == tx {\n\t\t\tlast := len(db.txs) - 1\n\t\t\tdb.txs[i] = db.txs[last]\n\t\t\tdb.txs[last] = nil\n\t\t\tdb.txs = db.txs[:last]\n\t\t\tbreak\n\t\t}\n\t}\n\tn := len(db.txs)\n\tif db.freelist != nil {\n\t\tdb.freelist.RemoveReadonlyTXID(tx.meta.Txid())\n\t}\n\n\t// Unlock the meta pages.\n\tdb.metalock.Unlock()\n\n\t// Merge statistics.\n\tdb.statlock.Lock()\n\tdb.stats.OpenTxN = n\n\tdb.stats.TxStats.add(&tx.stats)\n\tdb.statlock.Unlock()\n}\n\n// Update executes a function within the context of a read-write managed transaction.\n// If no error is returned from the function then the transaction is committed.\n// If an error is returned then the entire transaction is rolled back.\n// Any error that is returned from the function or returned from the commit is\n// returned from the Update() method.\n//\n// Attempting to manually commit or rollback within the function will cause a panic.\nfunc (db *DB) Update(fn func(*Tx) error) error {\n\tt, err := db.Begin(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure the transaction rolls back in the event of a panic.\n\tdefer func() {\n\t\tif t.db != nil {\n\t\t\tt.rollback()\n\t\t}\n\t}()\n\n\t// Mark as a managed tx so that the inner function cannot manually commit.\n\tt.managed = true\n\n\t// If an error is returned from the function then rollback and return error.\n\terr = fn(t)\n\tt.managed = false\n\tif err != nil {\n\t\t_ = t.Rollback()\n\t\treturn err\n\t}\n\n\treturn t.Commit()\n}\n\n// View executes a function within the context of a managed read-only transaction.\n// Any error that is returned from the function is returned from the View() method.\n//\n// Attempting to manually rollback within the function will cause a panic.\nfunc (db *DB) View(fn func(*Tx) error) error {\n\tt, err := db.Begin(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure the transaction rolls back in the event of a panic.\n\tdefer func() {\n\t\tif t.db != nil {\n\t\t\tt.rollback()\n\t\t}\n\t}()\n\n\t// Mark as a managed tx so that the inner function cannot manually rollback.\n\tt.managed = true\n\n\t// If an error is returned from the function then pass it through.\n\terr = fn(t)\n\tt.managed = false\n\tif err != nil {\n\t\t_ = t.Rollback()\n\t\treturn err\n\t}\n\n\treturn t.Rollback()\n}\n\n// Batch calls fn as part of a batch. It behaves similar to Update,\n// except:\n//\n// 1. concurrent Batch calls can be combined into a single Bolt\n// transaction.\n//\n// 2. the function passed to Batch may be called multiple times,\n// regardless of whether it returns error or not.\n//\n// This means that Batch function side effects must be idempotent and\n// take permanent effect only after a successful return is seen in\n// caller.\n//\n// The maximum batch size and delay can be adjusted with DB.MaxBatchSize\n// and DB.MaxBatchDelay, respectively.\n//\n// Batch is only useful when there are multiple goroutines calling it.\nfunc (db *DB) Batch(fn func(*Tx) error) error {\n\terrCh := make(chan error, 1)\n\n\tdb.batchMu.Lock()\n\tif (db.batch == nil) || (db.batch != nil && len(db.batch.calls) >= db.MaxBatchSize) {\n\t\t// There is no existing batch, or the existing batch is full; start a new one.\n\t\tdb.batch = &batch{\n\t\t\tdb: db,\n\t\t}\n\t\tdb.batch.timer = time.AfterFunc(db.MaxBatchDelay, db.batch.trigger)\n\t}\n\tdb.batch.calls = append(db.batch.calls, call{fn: fn, err: errCh})\n\tif len(db.batch.calls) >= db.MaxBatchSize {\n\t\t// wake up batch, it's ready to run\n\t\tgo db.batch.trigger()\n\t}\n\tdb.batchMu.Unlock()\n\n\terr := <-errCh\n\tif err == trySolo {\n\t\terr = db.Update(fn)\n\t}\n\treturn err\n}\n\ntype call struct {\n\tfn  func(*Tx) error\n\terr chan<- error\n}\n\ntype batch struct {\n\tdb    *DB\n\ttimer *time.Timer\n\tstart sync.Once\n\tcalls []call\n}\n\n// trigger runs the batch if it hasn't already been run.\nfunc (b *batch) trigger() {\n\tb.start.Do(b.run)\n}\n\n// run performs the transactions in the batch and communicates results\n// back to DB.Batch.\nfunc (b *batch) run() {\n\tb.db.batchMu.Lock()\n\tb.timer.Stop()\n\t// Make sure no new work is added to this batch, but don't break\n\t// other batches.\n\tif b.db.batch == b {\n\t\tb.db.batch = nil\n\t}\n\tb.db.batchMu.Unlock()\n\nretry:\n\tfor len(b.calls) > 0 {\n\t\tvar failIdx = -1\n\t\terr := b.db.Update(func(tx *Tx) error {\n\t\t\tfor i, c := range b.calls {\n\t\t\t\tif err := safelyCall(c.fn, tx); err != nil {\n\t\t\t\t\tfailIdx = i\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tif failIdx >= 0 {\n\t\t\t// take the failing transaction out of the batch. it's\n\t\t\t// safe to shorten b.calls here because db.batch no longer\n\t\t\t// points to us, and we hold the mutex anyway.\n\t\t\tc := b.calls[failIdx]\n\t\t\tb.calls[failIdx], b.calls = b.calls[len(b.calls)-1], b.calls[:len(b.calls)-1]\n\t\t\t// tell the submitter re-run it solo, continue with the rest of the batch\n\t\t\tc.err <- trySolo\n\t\t\tcontinue retry\n\t\t}\n\n\t\t// pass success, or bolt internal errors, to all callers\n\t\tfor _, c := range b.calls {\n\t\t\tc.err <- err\n\t\t}\n\t\tbreak retry\n\t}\n}\n\n// trySolo is a special sentinel error value used for signaling that a\n// transaction function should be re-run. It should never be seen by\n// callers.\nvar trySolo = errors.New(\"batch function returned an error and should be re-run solo\")\n\ntype panicked struct {\n\treason interface{}\n}\n\nfunc (p panicked) Error() string {\n\tif err, ok := p.reason.(error); ok {\n\t\treturn err.Error()\n\t}\n\treturn fmt.Sprintf(\"panic: %v\", p.reason)\n}\n\nfunc safelyCall(fn func(*Tx) error, tx *Tx) (err error) {\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\terr = panicked{p}\n\t\t}\n\t}()\n\treturn fn(tx)\n}\n\n// Sync executes fdatasync() against the database file handle.\n//\n// This is not necessary under normal operation, however, if you use NoSync\n// then it allows you to force the database file to sync against the disk.\nfunc (db *DB) Sync() (err error) {\n\tif lg := db.Logger(); lg != discardLogger {\n\t\tlg.Debug(\"Syncing bbolt db (%s)\", db.path)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] syncing bbolt db (%s) failed: %v\", runtime.GOOS, runtime.GOARCH, db.path, err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Syncing bbolt db (%s) successfully\", db.path)\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn fdatasync(db)\n}\n\n// Stats retrieves ongoing performance stats for the database.\n// This is only updated when a transaction closes.\nfunc (db *DB) Stats() Stats {\n\tdb.statlock.RLock()\n\tdefer db.statlock.RUnlock()\n\treturn db.stats\n}\n\n// This is for internal access to the raw data bytes from the C cursor, use\n// carefully, or not at all.\nfunc (db *DB) Info() *Info {\n\tcommon.Assert(db.data != nil, \"database file isn't correctly mapped\")\n\treturn &Info{uintptr(unsafe.Pointer(&db.data[0])), db.pageSize}\n}\n\n// page retrieves a page reference from the mmap based on the current page size.\nfunc (db *DB) page(id common.Pgid) *common.Page {\n\tpos := id * common.Pgid(db.pageSize)\n\treturn (*common.Page)(unsafe.Pointer(&db.data[pos]))\n}\n\n// pageInBuffer retrieves a page reference from a given byte array based on the current page size.\nfunc (db *DB) pageInBuffer(b []byte, id common.Pgid) *common.Page {\n\treturn (*common.Page)(unsafe.Pointer(&b[id*common.Pgid(db.pageSize)]))\n}\n\n// meta retrieves the current meta page reference.\nfunc (db *DB) meta() *common.Meta {\n\t// We have to return the meta with the highest txid which doesn't fail\n\t// validation. Otherwise, we can cause errors when in fact the database is\n\t// in a consistent state. metaA is the one with the higher txid.\n\tmetaA := db.meta0\n\tmetaB := db.meta1\n\tif db.meta1.Txid() > db.meta0.Txid() {\n\t\tmetaA = db.meta1\n\t\tmetaB = db.meta0\n\t}\n\n\t// Use higher meta page if valid. Otherwise, fallback to previous, if valid.\n\tif err := metaA.Validate(); err == nil {\n\t\treturn metaA\n\t} else if err := metaB.Validate(); err == nil {\n\t\treturn metaB\n\t}\n\n\t// This should never be reached, because both meta1 and meta0 were validated\n\t// on mmap() and we do fsync() on every write.\n\tpanic(\"bolt.DB.meta(): invalid meta pages\")\n}\n\n// allocate returns a contiguous block of memory starting at a given page.\nfunc (db *DB) allocate(txid common.Txid, count int) (*common.Page, error) {\n\t// Allocate a temporary buffer for the page.\n\tvar buf []byte\n\tif count == 1 {\n\t\tbuf = db.pagePool.Get().([]byte)\n\t} else {\n\t\tbuf = make([]byte, count*db.pageSize)\n\t}\n\tp := (*common.Page)(unsafe.Pointer(&buf[0]))\n\tp.SetOverflow(uint32(count - 1))\n\n\t// Use pages from the freelist if they are available.\n\tp.SetId(db.freelist.Allocate(txid, count))\n\tif p.Id() != 0 {\n\t\treturn p, nil\n\t}\n\n\t// Resize mmap() if we're at the end.\n\tp.SetId(db.rwtx.meta.Pgid())\n\tvar minsz = int((p.Id()+common.Pgid(count))+1) * db.pageSize\n\tif minsz >= db.datasz {\n\t\tif err := db.mmap(minsz); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"mmap allocate error: %s\", err)\n\t\t}\n\t}\n\n\t// Move the page id high water mark.\n\tcurPgid := db.rwtx.meta.Pgid()\n\tdb.rwtx.meta.SetPgid(curPgid + common.Pgid(count))\n\n\treturn p, nil\n}\n\n// grow grows the size of the database to the given sz.\nfunc (db *DB) grow(sz int) error {\n\t// Ignore if the new size is less than available file size.\n\tlg := db.Logger()\n\tfileSize, err := db.fileSize()\n\tif err != nil {\n\t\tlg.Errorf(\"getting file size failed: %w\", err)\n\t\treturn err\n\t}\n\tif sz <= fileSize {\n\t\treturn nil\n\t}\n\n\t// If the data is smaller than the alloc size then only allocate what's needed.\n\t// Once it goes over the allocation size then allocate in chunks.\n\tif db.datasz <= db.AllocSize {\n\t\tsz = db.datasz\n\t} else {\n\t\tsz += db.AllocSize\n\t}\n\n\t// Truncate and fsync to ensure file size metadata is flushed.\n\t// https://github.com/boltdb/bolt/issues/284\n\tif !db.NoGrowSync && !db.readOnly {\n\t\tif runtime.GOOS != \"windows\" {\n\t\t\t// gofail: var resizeFileError string\n\t\t\t// return errors.New(resizeFileError)\n\t\t\tif err := db.file.Truncate(int64(sz)); err != nil {\n\t\t\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] truncating file failed, size: %d, db.datasz: %d, error: %v\", runtime.GOOS, runtime.GOARCH, sz, db.datasz, err)\n\t\t\t\treturn fmt.Errorf(\"file resize error: %s\", err)\n\t\t\t}\n\t\t}\n\t\tif err := db.file.Sync(); err != nil {\n\t\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] syncing file failed, db.datasz: %d, error: %v\", runtime.GOOS, runtime.GOARCH, db.datasz, err)\n\t\t\treturn fmt.Errorf(\"file sync error: %s\", err)\n\t\t}\n\t\tif db.Mlock {\n\t\t\t// unlock old file and lock new one\n\t\t\tif err := db.mrelock(fileSize, sz); err != nil {\n\t\t\t\treturn fmt.Errorf(\"mlock/munlock error: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (db *DB) IsReadOnly() bool {\n\treturn db.readOnly\n}\n\nfunc (db *DB) freepages() []common.Pgid {\n\ttx, err := db.beginTx()\n\tdefer func() {\n\t\terr = tx.Rollback()\n\t\tif err != nil {\n\t\t\tpanic(\"freepages: failed to rollback tx\")\n\t\t}\n\t}()\n\tif err != nil {\n\t\tpanic(\"freepages: failed to open read only tx\")\n\t}\n\n\treachable := make(map[common.Pgid]*common.Page)\n\tnofreed := make(map[common.Pgid]bool)\n\tech := make(chan error)\n\tgo func() {\n\t\tfor e := range ech {\n\t\t\tpanic(fmt.Sprintf(\"freepages: failed to get all reachable pages (%v)\", e))\n\t\t}\n\t}()\n\ttx.recursivelyCheckBucket(&tx.root, reachable, nofreed, HexKVStringer(), ech)\n\tclose(ech)\n\n\t// TODO: If check bucket reported any corruptions (ech) we shouldn't proceed to freeing the pages.\n\n\tvar fids []common.Pgid\n\tfor i := common.Pgid(2); i < db.meta().Pgid(); i++ {\n\t\tif _, ok := reachable[i]; !ok {\n\t\t\tfids = append(fids, i)\n\t\t}\n\t}\n\treturn fids\n}\n\nfunc newFreelist(freelistType FreelistType) fl.Interface {\n\tif freelistType == FreelistMapType {\n\t\treturn fl.NewHashMapFreelist()\n\t}\n\treturn fl.NewArrayFreelist()\n}\n\n// Options represents the options that can be set when opening a database.\ntype Options struct {\n\t// Timeout is the amount of time to wait to obtain a file lock.\n\t// When set to zero it will wait indefinitely.\n\tTimeout time.Duration\n\n\t// Sets the DB.NoGrowSync flag before memory mapping the file.\n\tNoGrowSync bool\n\n\t// Do not sync freelist to disk. This improves the database write performance\n\t// under normal operation, but requires a full database re-sync during recovery.\n\tNoFreelistSync bool\n\n\t// PreLoadFreelist sets whether to load the free pages when opening\n\t// the db file. Note when opening db in write mode, bbolt will always\n\t// load the free pages.\n\tPreLoadFreelist bool\n\n\t// FreelistType sets the backend freelist type. There are two options. Array which is simple but endures\n\t// dramatic performance degradation if database is large and fragmentation in freelist is common.\n\t// The alternative one is using hashmap, it is faster in almost all circumstances\n\t// but it doesn't guarantee that it offers the smallest page id available. In normal case it is safe.\n\t// The default type is array\n\tFreelistType FreelistType\n\n\t// Open database in read-only mode. Uses flock(..., LOCK_SH |LOCK_NB) to\n\t// grab a shared lock (UNIX).\n\tReadOnly bool\n\n\t// Sets the DB.MmapFlags flag before memory mapping the file.\n\tMmapFlags int\n\n\t// InitialMmapSize is the initial mmap size of the database\n\t// in bytes. Read transactions won't block write transaction\n\t// if the InitialMmapSize is large enough to hold database mmap\n\t// size. (See DB.Begin for more information)\n\t//\n\t// If <=0, the initial map size is 0.\n\t// If initialMmapSize is smaller than the previous database size,\n\t// it takes no effect.\n\tInitialMmapSize int\n\n\t// PageSize overrides the default OS page size.\n\tPageSize int\n\n\t// NoSync sets the initial value of DB.NoSync. Normally this can just be\n\t// set directly on the DB itself when returned from Open(), but this option\n\t// is useful in APIs which expose Options but not the underlying DB.\n\tNoSync bool\n\n\t// OpenFile is used to open files. It defaults to os.OpenFile. This option\n\t// is useful for writing hermetic tests.\n\tOpenFile func(string, int, os.FileMode) (*os.File, error)\n\n\t// Mlock locks database file in memory when set to true.\n\t// It prevents potential page faults, however\n\t// used memory can't be reclaimed. (UNIX only)\n\tMlock bool\n\n\t// Logger is the logger used for bbolt.\n\tLogger Logger\n}\n\nfunc (o *Options) String() string {\n\tif o == nil {\n\t\treturn \"{}\"\n\t}\n\n\treturn fmt.Sprintf(\"{Timeout: %s, NoGrowSync: %t, NoFreelistSync: %t, PreLoadFreelist: %t, FreelistType: %s, ReadOnly: %t, MmapFlags: %x, InitialMmapSize: %d, PageSize: %d, NoSync: %t, OpenFile: %p, Mlock: %t, Logger: %p}\",\n\t\to.Timeout, o.NoGrowSync, o.NoFreelistSync, o.PreLoadFreelist, o.FreelistType, o.ReadOnly, o.MmapFlags, o.InitialMmapSize, o.PageSize, o.NoSync, o.OpenFile, o.Mlock, o.Logger)\n\n}\n\n// DefaultOptions represent the options used if nil options are passed into Open().\n// No timeout is used which will cause Bolt to wait indefinitely for a lock.\nvar DefaultOptions = &Options{\n\tTimeout:      0,\n\tNoGrowSync:   false,\n\tFreelistType: FreelistArrayType,\n}\n\n// Stats represents statistics about the database.\ntype Stats struct {\n\t// Put `TxStats` at the first field to ensure it's 64-bit aligned. Note\n\t// that the first word in an allocated struct can be relied upon to be\n\t// 64-bit aligned. Refer to https://pkg.go.dev/sync/atomic#pkg-note-BUG.\n\t// Also refer to discussion in https://github.com/etcd-io/bbolt/issues/577.\n\tTxStats TxStats // global, ongoing stats.\n\n\t// Freelist stats\n\tFreePageN     int // total number of free pages on the freelist\n\tPendingPageN  int // total number of pending pages on the freelist\n\tFreeAlloc     int // total bytes allocated in free pages\n\tFreelistInuse int // total bytes used by the freelist\n\n\t// Transaction stats\n\tTxN     int // total number of started read transactions\n\tOpenTxN int // number of currently open read transactions\n}\n\n// Sub calculates and returns the difference between two sets of database stats.\n// This is useful when obtaining stats at two different points and time and\n// you need the performance counters that occurred within that time span.\nfunc (s *Stats) Sub(other *Stats) Stats {\n\tif other == nil {\n\t\treturn *s\n\t}\n\tvar diff Stats\n\tdiff.FreePageN = s.FreePageN\n\tdiff.PendingPageN = s.PendingPageN\n\tdiff.FreeAlloc = s.FreeAlloc\n\tdiff.FreelistInuse = s.FreelistInuse\n\tdiff.TxN = s.TxN - other.TxN\n\tdiff.TxStats = s.TxStats.Sub(&other.TxStats)\n\treturn diff\n}\n\ntype Info struct {\n\tData     uintptr\n\tPageSize int\n}\n"
        },
        {
          "name": "db_test.go",
          "type": "blob",
          "size": 38.9423828125,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash/fnv\"\n\t\"log\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\tberrors \"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\n// pageSize is the size of one page in the data file.\nconst pageSize = 4096\n\n// pageHeaderSize is the size of a page header.\nconst pageHeaderSize = 16\n\n// meta represents a simplified version of a database meta page for testing.\ntype meta struct {\n\t_       uint32\n\tversion uint32\n\t_       uint32\n\t_       uint32\n\t_       [16]byte\n\t_       uint64\n\tpgid    uint64\n\t_       uint64\n\t_       uint64\n}\n\n// Ensure that a database can be opened without error.\nfunc TestOpen(t *testing.T) {\n\tpath := tempfile()\n\tdefer os.RemoveAll(path)\n\n\tdb, err := bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t} else if db == nil {\n\t\tt.Fatal(\"expected db\")\n\t}\n\n\tif s := db.Path(); s != path {\n\t\tt.Fatalf(\"unexpected path: %s\", s)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Regression validation for https://github.com/etcd-io/bbolt/pull/122.\n// Tests multiple goroutines simultaneously opening a database.\nfunc TestOpen_MultipleGoroutines(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode\")\n\t}\n\n\tconst (\n\t\tinstances  = 30\n\t\titerations = 30\n\t)\n\tpath := tempfile()\n\tdefer os.RemoveAll(path)\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, iterations*instances)\n\tfor iteration := 0; iteration < iterations; iteration++ {\n\t\tfor instance := 0; instance < instances; instance++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tdb, err := bolt.Open(path, 0600, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrCh <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := db.Close(); err != nil {\n\t\t\t\t\terrCh <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t}\n\tclose(errCh)\n\tfor err := range errCh {\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error from inside goroutine: %v\", err)\n\t\t}\n\t}\n}\n\n// Ensure that opening a database with a blank path returns an error.\nfunc TestOpen_ErrPathRequired(t *testing.T) {\n\t_, err := bolt.Open(\"\", 0600, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n}\n\n// Ensure that opening a database with a bad path returns an error.\nfunc TestOpen_ErrNotExists(t *testing.T) {\n\t_, err := bolt.Open(filepath.Join(tempfile(), \"bad-path\"), 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\n// Ensure that opening a file that is not a Bolt database returns ErrInvalid.\nfunc TestOpen_ErrInvalid(t *testing.T) {\n\tpath := tempfile()\n\tdefer os.RemoveAll(path)\n\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := fmt.Fprintln(f, \"this is not a bolt database\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := bolt.Open(path, 0600, nil); err != berrors.ErrInvalid {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that opening a file with two invalid versions returns ErrVersionMismatch.\nfunc TestOpen_ErrVersionMismatch(t *testing.T) {\n\tif pageSize != os.Getpagesize() {\n\t\tt.Skip(\"page size mismatch\")\n\t}\n\n\t// Create empty database.\n\tdb := btesting.MustCreateDB(t)\n\tpath := db.Path()\n\n\t// Close database.\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read data file.\n\tbuf, err := os.ReadFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Rewrite meta pages.\n\tmeta0 := (*meta)(unsafe.Pointer(&buf[pageHeaderSize]))\n\tmeta0.version++\n\tmeta1 := (*meta)(unsafe.Pointer(&buf[pageSize+pageHeaderSize]))\n\tmeta1.version++\n\tif err := os.WriteFile(path, buf, 0666); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Reopen data file.\n\tif _, err := bolt.Open(path, 0600, nil); err != berrors.ErrVersionMismatch {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that opening a file with two invalid checksums returns ErrChecksum.\nfunc TestOpen_ErrChecksum(t *testing.T) {\n\tif pageSize != os.Getpagesize() {\n\t\tt.Skip(\"page size mismatch\")\n\t}\n\n\t// Create empty database.\n\tdb := btesting.MustCreateDB(t)\n\tpath := db.Path()\n\n\t// Close database.\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read data file.\n\tbuf, err := os.ReadFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Rewrite meta pages.\n\tmeta0 := (*meta)(unsafe.Pointer(&buf[pageHeaderSize]))\n\tmeta0.pgid++\n\tmeta1 := (*meta)(unsafe.Pointer(&buf[pageSize+pageHeaderSize]))\n\tmeta1.pgid++\n\tif err := os.WriteFile(path, buf, 0666); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Reopen data file.\n\tif _, err := bolt.Open(path, 0600, nil); err != berrors.ErrChecksum {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that it can read the page size from the second meta page if the first one is invalid.\n// The page size is expected to be the OS's page size in this case.\nfunc TestOpen_ReadPageSize_FromMeta1_OS(t *testing.T) {\n\t// Create empty database.\n\tdb := btesting.MustCreateDB(t)\n\tpath := db.Path()\n\t// Close the database\n\tdb.MustClose()\n\n\t// Read data file.\n\tbuf, err := os.ReadFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Rewrite first meta page.\n\tmeta0 := (*meta)(unsafe.Pointer(&buf[pageHeaderSize]))\n\tmeta0.pgid++\n\tif err := os.WriteFile(path, buf, 0666); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Reopen data file.\n\tdb = btesting.MustOpenDBWithOption(t, path, nil)\n\trequire.Equalf(t, os.Getpagesize(), db.Info().PageSize, \"check page size failed\")\n}\n\n// Ensure that it can read the page size from the second meta page if the first one is invalid.\n// The page size is expected to be the given page size in this case.\nfunc TestOpen_ReadPageSize_FromMeta1_Given(t *testing.T) {\n\t// test page size from 1KB (1024<<0) to 16MB(1024<<14)\n\tfor i := 0; i <= 14; i++ {\n\t\tgivenPageSize := 1024 << uint(i)\n\t\tt.Logf(\"Testing page size %d\", givenPageSize)\n\t\t// Create empty database.\n\t\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{PageSize: givenPageSize})\n\t\tpath := db.Path()\n\t\t// Close the database\n\t\tdb.MustClose()\n\n\t\t// Read data file.\n\t\tbuf, err := os.ReadFile(path)\n\t\trequire.NoError(t, err)\n\n\t\t// Rewrite meta pages.\n\t\tif i%3 == 0 {\n\t\t\tt.Logf(\"#%d: Intentionally corrupt the first meta page for pageSize %d\", i, givenPageSize)\n\t\t\tmeta0 := (*meta)(unsafe.Pointer(&buf[pageHeaderSize]))\n\t\t\tmeta0.pgid++\n\t\t\terr = os.WriteFile(path, buf, 0666)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\n\t\t// Reopen data file.\n\t\tdb = btesting.MustOpenDBWithOption(t, path, nil)\n\t\trequire.Equalf(t, givenPageSize, db.Info().PageSize, \"check page size failed\")\n\t\tdb.MustClose()\n\t}\n}\n\n// Ensure that opening a database does not increase its size.\n// https://github.com/boltdb/bolt/issues/291\nfunc TestOpen_Size(t *testing.T) {\n\t// Open a data file.\n\tdb := btesting.MustCreateDB(t)\n\n\tpagesize := db.Info().PageSize\n\n\t// Insert until we get above the minimum 4MB size.\n\terr := db.Fill([]byte(\"data\"), 1, 10000,\n\t\tfunc(tx int, k int) []byte { return []byte(fmt.Sprintf(\"%04d\", k)) },\n\t\tfunc(tx int, k int) []byte { return make([]byte, 1000) },\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpath := db.Path()\n\tdb.MustClose()\n\n\tsz := fileSize(path)\n\tif sz == 0 {\n\t\tt.Fatalf(\"unexpected new file size: %d\", sz)\n\t}\n\n\tdb.MustReopen()\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif err := tx.Bucket([]byte(\"data\")).Put([]byte{0}, []byte{0}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnewSz := fileSize(path)\n\tif newSz == 0 {\n\t\tt.Fatalf(\"unexpected new file size: %d\", newSz)\n\t}\n\n\t// Compare the original size with the new size.\n\t// db size might increase by a few page sizes due to the new small update.\n\tif sz < newSz-5*int64(pagesize) {\n\t\tt.Fatalf(\"unexpected file growth: %d => %d\", sz, newSz)\n\t}\n}\n\n// Ensure that opening a database beyond the max step size does not increase its size.\n// https://github.com/boltdb/bolt/issues/303\nfunc TestOpen_Size_Large(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"short mode\")\n\t}\n\n\t// Open a data file.\n\tdb := btesting.MustCreateDB(t)\n\tpath := db.Path()\n\n\tpagesize := db.Info().PageSize\n\n\t// Insert until we get above the minimum 4MB size.\n\tvar index uint64\n\tfor i := 0; i < 10000; i++ {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, _ := tx.CreateBucketIfNotExists([]byte(\"data\"))\n\t\t\tfor j := 0; j < 1000; j++ {\n\t\t\t\tif err := b.Put(u64tob(index), make([]byte, 50)); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tindex++\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Close database and grab the size.\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsz := fileSize(path)\n\tif sz == 0 {\n\t\tt.Fatalf(\"unexpected new file size: %d\", sz)\n\t} else if sz < (1 << 30) {\n\t\tt.Fatalf(\"expected larger initial size: %d\", sz)\n\t}\n\n\t// Reopen database, update, and check size again.\n\tdb0, err := bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db0.Update(func(tx *bolt.Tx) error {\n\t\treturn tx.Bucket([]byte(\"data\")).Put([]byte{0}, []byte{0})\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db0.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnewSz := fileSize(path)\n\tif newSz == 0 {\n\t\tt.Fatalf(\"unexpected new file size: %d\", newSz)\n\t}\n\n\t// Compare the original size with the new size.\n\t// db size might increase by a few page sizes due to the new small update.\n\tif sz < newSz-5*int64(pagesize) {\n\t\tt.Fatalf(\"unexpected file growth: %d => %d\", sz, newSz)\n\t}\n}\n\n// Ensure that a re-opened database is consistent.\nfunc TestOpen_Check(t *testing.T) {\n\tpath := tempfile()\n\tdefer os.RemoveAll(path)\n\n\tdb, err := bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = db.View(func(tx *bolt.Tx) error { return <-tx.Check() }); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb, err = bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.View(func(tx *bolt.Tx) error { return <-tx.Check() }); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that write errors to the meta file handler during initialization are returned.\nfunc TestOpen_MetaInitWriteError(t *testing.T) {\n\tt.Skip(\"pending\")\n}\n\n// Ensure that a database that is too small returns an error.\nfunc TestOpen_FileTooSmall(t *testing.T) {\n\tpath := tempfile()\n\tdefer os.RemoveAll(path)\n\n\tdb, err := bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpageSize := int64(db.Info().PageSize)\n\tif err = db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// corrupt the database\n\tif err = os.Truncate(path, pageSize); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = bolt.Open(path, 0600, nil)\n\tif err == nil || !strings.Contains(err.Error(), \"file size too small\") {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// TestDB_Open_InitialMmapSize tests if having InitialMmapSize large enough\n// to hold data from concurrent write transaction resolves the issue that\n// read transaction blocks the write transaction and causes deadlock.\n// This is a very hacky test since the mmap size is not exposed.\nfunc TestDB_Open_InitialMmapSize(t *testing.T) {\n\tpath := tempfile()\n\tdefer os.Remove(path)\n\n\tinitMmapSize := 1 << 30  // 1GB\n\ttestWriteSize := 1 << 27 // 134MB\n\n\tdb, err := bolt.Open(path, 0600, &bolt.Options{InitialMmapSize: initMmapSize})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create a long-running read transaction\n\t// that never gets closed while writing\n\trtx, err := db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create a write transaction\n\twtx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := wtx.CreateBucket([]byte(\"test\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// and commit a large write\n\terr = b.Put([]byte(\"foo\"), make([]byte, testWriteSize))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdone := make(chan error, 1)\n\n\tgo func() {\n\t\terr := wtx.Commit()\n\t\tdone <- err\n\t}()\n\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tt.Errorf(\"unexpected that the reader blocks writer\")\n\tcase err := <-done:\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tif err := rtx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// TestDB_Open_ReadOnly checks a database in read only mode can read but not write.\nfunc TestDB_Open_ReadOnly(t *testing.T) {\n\t// Create a writable db, write k-v and close it.\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tf := db.Path()\n\to := &bolt.Options{ReadOnly: true}\n\treadOnlyDB, err := bolt.Open(f, 0600, o)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif !readOnlyDB.IsReadOnly() {\n\t\tt.Fatal(\"expect db in read only mode\")\n\t}\n\n\t// Read from a read-only transaction.\n\tif err := readOnlyDB.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tif !bytes.Equal(value, []byte(\"bar\")) {\n\t\t\tt.Fatal(\"expect value 'bar', got\", value)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Can't launch read-write transaction.\n\tif _, err := readOnlyDB.Begin(true); err != berrors.ErrDatabaseReadOnly {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif err := readOnlyDB.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDB_Open_ReadOnly_NoCreate(t *testing.T) {\n\tf := filepath.Join(t.TempDir(), \"db\")\n\t_, err := bolt.Open(f, 0600, &bolt.Options{ReadOnly: true})\n\trequire.ErrorIs(t, err, os.ErrNotExist)\n}\n\n// TestOpen_BigPage checks the database uses bigger pages when\n// changing PageSize.\nfunc TestOpen_BigPage(t *testing.T) {\n\tpageSize := os.Getpagesize()\n\n\tdb1 := btesting.MustCreateDBWithOption(t, &bolt.Options{PageSize: pageSize * 2})\n\n\tdb2 := btesting.MustCreateDBWithOption(t, &bolt.Options{PageSize: pageSize * 4})\n\n\tif db1sz, db2sz := fileSize(db1.Path()), fileSize(db2.Path()); db1sz >= db2sz {\n\t\tt.Errorf(\"expected %d < %d\", db1sz, db2sz)\n\t}\n}\n\n// TestOpen_RecoverFreeList tests opening the DB with free-list\n// write-out after no free list sync will recover the free list\n// and write it out.\nfunc TestOpen_RecoverFreeList(t *testing.T) {\n\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{NoFreelistSync: true})\n\n\t// Write some pages.\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twbuf := make([]byte, 8192)\n\tfor i := 0; i < 100; i++ {\n\t\ts := fmt.Sprintf(\"%d\", i)\n\t\tb, err := tx.CreateBucket([]byte(s))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err = b.Put([]byte(s), wbuf); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tif err = tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Generate free pages.\n\tif tx, err = db.Begin(true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i := 0; i < 50; i++ {\n\t\ts := fmt.Sprintf(\"%d\", i)\n\t\tb := tx.Bucket([]byte(s))\n\t\tif b == nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Delete([]byte(s)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.MustClose()\n\n\t// Record freelist count from opening with NoFreelistSync.\n\tdb.MustReopen()\n\tfreepages := db.Stats().FreePageN\n\tif freepages == 0 {\n\t\tt.Fatalf(\"no free pages on NoFreelistSync reopen\")\n\t}\n\tdb.MustClose()\n\n\t// Check free page count is reconstructed when opened with freelist sync.\n\tdb.SetOptions(&bolt.Options{})\n\tdb.MustReopen()\n\t// One less free page for syncing the free list on open.\n\tfreepages--\n\tif fp := db.Stats().FreePageN; fp < freepages {\n\t\tt.Fatalf(\"closed with %d free pages, opened with %d\", freepages, fp)\n\t}\n}\n\n// Ensure that a database cannot open a transaction when it's not open.\nfunc TestDB_Begin_ErrDatabaseNotOpen(t *testing.T) {\n\tvar db bolt.DB\n\tif _, err := db.Begin(false); err != berrors.ErrDatabaseNotOpen {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that a read-write transaction can be retrieved.\nfunc TestDB_BeginRW(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\ttx, err := db.Begin(true)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, tx, \"expected tx\")\n\tdefer func() { require.NoError(t, tx.Commit()) }()\n\n\trequire.True(t, tx.Writable(), \"expected writable tx\")\n\trequire.Same(t, db.DB, tx.DB())\n}\n\n// TestDB_Concurrent_WriteTo checks that issuing WriteTo operations concurrently\n// with commits does not produce corrupted db files. It also verifies that all\n// readonly transactions, which are created based on the same data view, should\n// always read the same data.\nfunc TestDB_Concurrent_WriteTo_and_ConsistentRead(t *testing.T) {\n\to := &bolt.Options{\n\t\tNoFreelistSync: false,\n\t\tPageSize:       4096,\n\t}\n\tdb := btesting.MustCreateDBWithOption(t, o)\n\n\twtxs, rtxs := 50, 5\n\tbucketName := []byte(\"data\")\n\n\tvar dataLock sync.Mutex\n\tdataCache := make(map[int][]map[string]string)\n\n\tvar wg sync.WaitGroup\n\twg.Add(wtxs * rtxs)\n\tf := func(round int, tx *bolt.Tx) {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(200)+10) * time.Millisecond)\n\t\tf := filepath.Join(t.TempDir(), fmt.Sprintf(\"%d-bolt-\", round))\n\t\terr := tx.CopyFile(f, 0600)\n\t\trequire.NoError(t, err)\n\n\t\t// read all the data\n\t\tb := tx.Bucket(bucketName)\n\t\tdata := make(map[string]string)\n\t\terr = b.ForEach(func(k, v []byte) error {\n\t\t\tdata[string(k)] = string(v)\n\t\t\treturn nil\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t// cache the data\n\t\tdataLock.Lock()\n\t\tdataSlice := dataCache[round]\n\t\tdataSlice = append(dataSlice, data)\n\t\tdataCache[round] = dataSlice\n\t\tdataLock.Unlock()\n\n\t\terr = tx.Rollback()\n\t\trequire.NoError(t, err)\n\n\t\tcopyOpt := *o\n\t\tsnap := btesting.MustOpenDBWithOption(t, f, &copyOpt)\n\t\tdefer snap.MustClose()\n\t\tsnap.MustCheck()\n\t}\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket(bucketName)\n\t\treturn err\n\t})\n\trequire.NoError(t, err)\n\n\tfor i := 0; i < wtxs; i++ {\n\t\ttx, err := db.Begin(true)\n\t\trequire.NoError(t, err)\n\n\t\tb := tx.Bucket(bucketName)\n\n\t\tfor j := 0; j < rtxs; j++ {\n\t\t\trtx, rerr := db.Begin(false)\n\t\t\trequire.NoError(t, rerr)\n\t\t\tgo f(i, rtx)\n\n\t\t\tfor k := 0; k < 10; k++ {\n\t\t\t\tkey, value := fmt.Sprintf(\"key_%d\", rand.Intn(10)), fmt.Sprintf(\"value_%d\", rand.Intn(100))\n\t\t\t\tperr := b.Put([]byte(key), []byte(value))\n\t\t\t\trequire.NoError(t, perr)\n\t\t\t}\n\t\t}\n\t\terr = tx.Commit()\n\t\trequire.NoError(t, err)\n\t}\n\twg.Wait()\n\n\t// compare the data. The data generated in the same round\n\t// should be exactly the same.\n\tfor round, dataSlice := range dataCache {\n\t\tdata0 := dataSlice[0]\n\n\t\tfor i := 1; i < len(dataSlice); i++ {\n\t\t\tdatai := dataSlice[i]\n\t\t\tsame := reflect.DeepEqual(data0, datai)\n\t\t\trequire.True(t, same, fmt.Sprintf(\"found inconsistent data in round %d, data[0]: %v, data[%d] : %v\", round, data0, i, datai))\n\t\t}\n\t}\n}\n\n// Ensure that opening a transaction while the DB is closed returns an error.\nfunc TestDB_BeginRW_Closed(t *testing.T) {\n\tvar db bolt.DB\n\tif _, err := db.Begin(true); err != berrors.ErrDatabaseNotOpen {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\nfunc TestDB_Close_PendingTx_RW(t *testing.T) { testDB_Close_PendingTx(t, true) }\nfunc TestDB_Close_PendingTx_RO(t *testing.T) { testDB_Close_PendingTx(t, false) }\n\n// Ensure that a database cannot close while transactions are open.\nfunc testDB_Close_PendingTx(t *testing.T, writable bool) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Start transaction.\n\ttx, err := db.Begin(writable)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Open update in separate goroutine.\n\tstartCh := make(chan struct{}, 1)\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tstartCh <- struct{}{}\n\t\terr := db.Close()\n\t\tdone <- err\n\t}()\n\t// wait for the above goroutine to get scheduled.\n\t<-startCh\n\n\t// Ensure database hasn't closed.\n\ttime.Sleep(100 * time.Millisecond)\n\tselect {\n\tcase err := <-done:\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error from inside goroutine: %v\", err)\n\t\t}\n\t\tt.Fatal(\"database closed too early\")\n\tdefault:\n\t}\n\n\t// Commit/close transaction.\n\tif writable {\n\t\terr = tx.Commit()\n\t} else {\n\t\terr = tx.Rollback()\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Ensure database closed now.\n\tselect {\n\tcase err := <-done:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error from inside goroutine: %v\", err)\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"database did not close\")\n\t}\n}\n\n// Ensure a database can provide a transactional block.\nfunc TestDB_Update(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Delete([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tif v := b.Get([]byte(\"foo\")); v != nil {\n\t\t\tt.Fatalf(\"expected nil value, got: %v\", v)\n\t\t}\n\t\tif v := b.Get([]byte(\"baz\")); !bytes.Equal(v, []byte(\"bat\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a closed database returns an error while running a transaction block\nfunc TestDB_Update_Closed(t *testing.T) {\n\tvar db bolt.DB\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != berrors.ErrDatabaseNotOpen {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure a panic occurs while trying to commit a managed transaction.\nfunc TestDB_Update_ManualCommit(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar panicked bool\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicked = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif err := tx.Commit(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t} else if !panicked {\n\t\tt.Fatal(\"expected panic\")\n\t}\n}\n\n// Ensure a panic occurs while trying to rollback a managed transaction.\nfunc TestDB_Update_ManualRollback(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar panicked bool\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicked = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif err := tx.Rollback(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t} else if !panicked {\n\t\tt.Fatal(\"expected panic\")\n\t}\n}\n\n// Ensure a panic occurs while trying to commit a managed transaction.\nfunc TestDB_View_ManualCommit(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar panicked bool\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicked = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif err := tx.Commit(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t} else if !panicked {\n\t\tt.Fatal(\"expected panic\")\n\t}\n}\n\n// Ensure a panic occurs while trying to rollback a managed transaction.\nfunc TestDB_View_ManualRollback(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar panicked bool\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicked = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif err := tx.Rollback(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t} else if !panicked {\n\t\tt.Fatal(\"expected panic\")\n\t}\n}\n\n// Ensure a write transaction that panics does not hold open locks.\nfunc TestDB_Update_Panic(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Panic during update but recover.\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tt.Log(\"recover: update\", r)\n\t\t\t}\n\t\t}()\n\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tpanic(\"omg\")\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\t// Verify we can update again.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Verify that our change persisted.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure a database can return an error through a read-only transactional block.\nfunc TestDB_View_Error(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn errors.New(\"xxx\")\n\t}); err == nil || err.Error() != \"xxx\" {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure a read transaction that panics does not hold open locks.\nfunc TestDB_View_Panic(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Panic during view transaction but recover.\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tt.Log(\"recover: view\", r)\n\t\t\t}\n\t\t}()\n\n\t\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\t\tt.Fatal(\"expected bucket\")\n\t\t\t}\n\t\t\tpanic(\"omg\")\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\t// Verify that we can still use read transactions.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that DB stats can be returned.\nfunc TestDB_Stats(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstats := db.Stats()\n\tif stats.TxStats.GetPageCount() != 2 {\n\t\tt.Fatalf(\"unexpected TxStats.PageCount: %d\", stats.TxStats.GetPageCount())\n\t} else if stats.FreePageN != 0 {\n\t\tt.Fatalf(\"unexpected FreePageN != 0: %d\", stats.FreePageN)\n\t} else if stats.PendingPageN != 2 {\n\t\tt.Fatalf(\"unexpected PendingPageN != 2: %d\", stats.PendingPageN)\n\t}\n}\n\n// Ensure that database pages are in expected order and type.\nfunc TestDB_Consistency(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tif err := tx.Bucket([]byte(\"widgets\")).Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif p, _ := tx.Page(0); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"meta\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(1); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"meta\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(2); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"free\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(3); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"free\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(4); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"leaf\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(5); p == nil {\n\t\t\tt.Fatal(\"expected page\")\n\t\t} else if p.Type != \"freelist\" {\n\t\t\tt.Fatalf(\"unexpected page type: %s\", p.Type)\n\t\t}\n\n\t\tif p, _ := tx.Page(6); p != nil {\n\t\t\tt.Fatal(\"unexpected page\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that DB stats can be subtracted from one another.\nfunc TestDBStats_Sub(t *testing.T) {\n\tvar a, b bolt.Stats\n\ta.TxStats.PageCount = 3\n\ta.FreePageN = 4\n\tb.TxStats.PageCount = 10\n\tb.FreePageN = 14\n\tdiff := b.Sub(&a)\n\tif diff.TxStats.GetPageCount() != 7 {\n\t\tt.Fatalf(\"unexpected TxStats.PageCount: %d\", diff.TxStats.GetPageCount())\n\t}\n\n\t// free page stats are copied from the receiver and not subtracted\n\tif diff.FreePageN != 14 {\n\t\tt.Fatalf(\"unexpected FreePageN: %d\", diff.FreePageN)\n\t}\n}\n\n// Ensure two functions can perform updates in a single batch.\nfunc TestDB_Batch(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Iterate over multiple updates in separate goroutines.\n\tn := 2\n\tch := make(chan error, n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func(i int) {\n\t\t\tch <- db.Batch(func(tx *bolt.Tx) error {\n\t\t\t\treturn tx.Bucket([]byte(\"widgets\")).Put(u64tob(uint64(i)), []byte{})\n\t\t\t})\n\t\t}(i)\n\t}\n\n\t// Check all responses to make sure there's no error.\n\tfor i := 0; i < n; i++ {\n\t\tif err := <-ch; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Ensure data is correct.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif v := b.Get(u64tob(uint64(i))); v == nil {\n\t\t\t\tt.Errorf(\"key not found: %d\", i)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDB_Batch_Panic(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar sentinel int\n\tvar bork = &sentinel\n\tvar problem interface{}\n\tvar err error\n\n\t// Execute a function inside a batch that panics.\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\tproblem = p\n\t\t\t}\n\t\t}()\n\t\terr = db.Batch(func(tx *bolt.Tx) error {\n\t\t\tpanic(bork)\n\t\t})\n\t}()\n\n\t// Verify there is no error.\n\tif g, e := err, error(nil); g != e {\n\t\tt.Fatalf(\"wrong error: %v != %v\", g, e)\n\t}\n\t// Verify the panic was captured.\n\tif g, e := problem, bork; g != e {\n\t\tt.Fatalf(\"wrong error: %v != %v\", g, e)\n\t}\n}\n\nfunc TestDB_BatchFull(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst size = 3\n\t// buffered so we never leak goroutines\n\tch := make(chan error, size)\n\tput := func(i int) {\n\t\tch <- db.Batch(func(tx *bolt.Tx) error {\n\t\t\treturn tx.Bucket([]byte(\"widgets\")).Put(u64tob(uint64(i)), []byte{})\n\t\t})\n\t}\n\n\tdb.MaxBatchSize = size\n\t// high enough to never trigger here\n\tdb.MaxBatchDelay = 1 * time.Hour\n\n\tgo put(1)\n\tgo put(2)\n\n\t// Give the batch a chance to exhibit bugs.\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// not triggered yet\n\tselect {\n\tcase <-ch:\n\t\tt.Fatalf(\"batch triggered too early\")\n\tdefault:\n\t}\n\n\tgo put(3)\n\n\t// Check all responses to make sure there's no error.\n\tfor i := 0; i < size; i++ {\n\t\tif err := <-ch; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Ensure data is correct.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 1; i <= size; i++ {\n\t\t\tif v := b.Get(u64tob(uint64(i))); v == nil {\n\t\t\t\tt.Errorf(\"key not found: %d\", i)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDB_BatchTime(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst size = 1\n\t// buffered so we never leak goroutines\n\tch := make(chan error, size)\n\tput := func(i int) {\n\t\tch <- db.Batch(func(tx *bolt.Tx) error {\n\t\t\treturn tx.Bucket([]byte(\"widgets\")).Put(u64tob(uint64(i)), []byte{})\n\t\t})\n\t}\n\n\tdb.MaxBatchSize = 1000\n\tdb.MaxBatchDelay = 0\n\n\tgo put(1)\n\n\t// Batch must trigger by time alone.\n\n\t// Check all responses to make sure there's no error.\n\tfor i := 0; i < size; i++ {\n\t\tif err := <-ch; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Ensure data is correct.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"widgets\"))\n\t\tfor i := 1; i <= size; i++ {\n\t\t\tif v := b.Get(u64tob(uint64(i))); v == nil {\n\t\t\t\tt.Errorf(\"key not found: %d\", i)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// TestDBUnmap verifes that `dataref`, `data` and `datasz` must be reset\n// to zero values respectively after unmapping the db.\nfunc TestDBUnmap(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\trequire.NoError(t, db.DB.Close())\n\n\t// Ignore the following error:\n\t// Error: copylocks: call of reflect.ValueOf copies lock value: go.etcd.io/bbolt.DB contains sync.Once contains sync.Mutex (govet)\n\t//nolint:govet\n\tv := reflect.ValueOf(*db.DB)\n\tdataref := v.FieldByName(\"dataref\")\n\tdata := v.FieldByName(\"data\")\n\tdatasz := v.FieldByName(\"datasz\")\n\tassert.True(t, dataref.IsNil())\n\tassert.True(t, data.IsNil())\n\tassert.True(t, datasz.IsZero())\n\n\t// Set db.DB to nil to prevent MustCheck from panicking.\n\tdb.DB = nil\n}\n\nfunc ExampleDB_Update() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Execute several commands within a read-write transaction.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Read the value back from a separate read-only transaction.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tfmt.Printf(\"The value of 'foo' is: %s\\n\", value)\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release the file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// The value of 'foo' is: bar\n}\n\nfunc ExampleDB_View() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Insert data into a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"people\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"john\"), []byte(\"doe\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"susy\"), []byte(\"que\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Access data from within a read-only transactional block.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tv := tx.Bucket([]byte(\"people\")).Get([]byte(\"john\"))\n\t\tfmt.Printf(\"John's last name is %s.\\n\", v)\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release the file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// John's last name is doe.\n}\n\nfunc ExampleDB_Begin() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Create a bucket using a read-write transaction.\n\tif err = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Create several keys in a transaction.\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tb := tx.Bucket([]byte(\"widgets\"))\n\tif err = b.Put([]byte(\"john\"), []byte(\"blue\")); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err = b.Put([]byte(\"abby\"), []byte(\"red\")); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err = b.Put([]byte(\"zephyr\"), []byte(\"purple\")); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Iterate over the values in sorted key order.\n\ttx, err = db.Begin(false)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tc := tx.Bucket([]byte(\"widgets\")).Cursor()\n\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\tfmt.Printf(\"%s likes %s\\n\", k, v)\n\t}\n\n\tif err = tx.Rollback(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err = db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// abby likes red\n\t// john likes blue\n\t// zephyr likes purple\n}\n\nfunc BenchmarkDBBatchAutomatic(b *testing.B) {\n\tdb := btesting.MustCreateDB(b)\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"bench\"))\n\t\treturn err\n\t}); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tstart := make(chan struct{})\n\t\tvar wg sync.WaitGroup\n\n\t\tfor round := 0; round < 1000; round++ {\n\t\t\twg.Add(1)\n\n\t\t\tgo func(id uint32) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t<-start\n\n\t\t\t\th := fnv.New32a()\n\t\t\t\tbuf := make([]byte, 4)\n\t\t\t\tbinary.LittleEndian.PutUint32(buf, id)\n\t\t\t\t_, _ = h.Write(buf[:])\n\t\t\t\tk := h.Sum(nil)\n\t\t\t\tinsert := func(tx *bolt.Tx) error {\n\t\t\t\t\tb := tx.Bucket([]byte(\"bench\"))\n\t\t\t\t\treturn b.Put(k, []byte(\"filler\"))\n\t\t\t\t}\n\t\t\t\tif err := db.Batch(insert); err != nil {\n\t\t\t\t\tb.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}(uint32(round))\n\t\t}\n\t\tclose(start)\n\t\twg.Wait()\n\t}\n\n\tb.StopTimer()\n\tvalidateBatchBench(b, db)\n}\n\nfunc BenchmarkDBBatchSingle(b *testing.B) {\n\tdb := btesting.MustCreateDB(b)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"bench\"))\n\t\treturn err\n\t}); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tstart := make(chan struct{})\n\t\tvar wg sync.WaitGroup\n\n\t\tfor round := 0; round < 1000; round++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(id uint32) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t<-start\n\n\t\t\t\th := fnv.New32a()\n\t\t\t\tbuf := make([]byte, 4)\n\t\t\t\tbinary.LittleEndian.PutUint32(buf, id)\n\t\t\t\t_, _ = h.Write(buf[:])\n\t\t\t\tk := h.Sum(nil)\n\t\t\t\tinsert := func(tx *bolt.Tx) error {\n\t\t\t\t\tb := tx.Bucket([]byte(\"bench\"))\n\t\t\t\t\treturn b.Put(k, []byte(\"filler\"))\n\t\t\t\t}\n\t\t\t\tif err := db.Update(insert); err != nil {\n\t\t\t\t\tb.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}(uint32(round))\n\t\t}\n\t\tclose(start)\n\t\twg.Wait()\n\t}\n\n\tb.StopTimer()\n\tvalidateBatchBench(b, db)\n}\n\nfunc BenchmarkDBBatchManual10x100(b *testing.B) {\n\tdb := btesting.MustCreateDB(b)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"bench\"))\n\t\treturn err\n\t}); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tstart := make(chan struct{})\n\t\tvar wg sync.WaitGroup\n\t\terrCh := make(chan error, 10)\n\n\t\tfor major := 0; major < 10; major++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(id uint32) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t<-start\n\n\t\t\t\tinsert100 := func(tx *bolt.Tx) error {\n\t\t\t\t\th := fnv.New32a()\n\t\t\t\t\tbuf := make([]byte, 4)\n\t\t\t\t\tfor minor := uint32(0); minor < 100; minor++ {\n\t\t\t\t\t\tbinary.LittleEndian.PutUint32(buf, uint32(id*100+minor))\n\t\t\t\t\t\th.Reset()\n\t\t\t\t\t\t_, _ = h.Write(buf[:])\n\t\t\t\t\t\tk := h.Sum(nil)\n\t\t\t\t\t\tb := tx.Bucket([]byte(\"bench\"))\n\t\t\t\t\t\tif err := b.Put(k, []byte(\"filler\")); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\terr := db.Update(insert100)\n\t\t\t\terrCh <- err\n\t\t\t}(uint32(major))\n\t\t}\n\t\tclose(start)\n\t\twg.Wait()\n\t\tclose(errCh)\n\t\tfor err := range errCh {\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tb.StopTimer()\n\tvalidateBatchBench(b, db)\n}\n\nfunc validateBatchBench(b *testing.B, db *btesting.DB) {\n\tvar rollback = errors.New(\"sentinel error to cause rollback\")\n\tvalidate := func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"bench\"))\n\t\th := fnv.New32a()\n\t\tbuf := make([]byte, 4)\n\t\tfor id := uint32(0); id < 1000; id++ {\n\t\t\tbinary.LittleEndian.PutUint32(buf, id)\n\t\t\th.Reset()\n\t\t\t_, _ = h.Write(buf[:])\n\t\t\tk := h.Sum(nil)\n\t\t\tv := bucket.Get(k)\n\t\t\tif v == nil {\n\t\t\t\tb.Errorf(\"not found id=%d key=%x\", id, k)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif g, e := v, []byte(\"filler\"); !bytes.Equal(g, e) {\n\t\t\t\tb.Errorf(\"bad value for id=%d key=%x: %s != %q\", id, k, g, e)\n\t\t\t}\n\t\t\tif err := bucket.Delete(k); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// should be empty now\n\t\tc := bucket.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tb.Errorf(\"unexpected key: %x = %q\", k, v)\n\t\t}\n\t\treturn rollback\n\t}\n\tif err := db.Update(validate); err != nil && err != rollback {\n\t\tb.Error(err)\n\t}\n}\n\n// tempfile returns a temporary file path.\nfunc tempfile() string {\n\tf, err := os.CreateTemp(\"\", \"bolt-\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := os.Remove(f.Name()); err != nil {\n\t\tpanic(err)\n\t}\n\treturn f.Name()\n}\n\nfunc trunc(b []byte, length int) []byte {\n\tif length < len(b) {\n\t\treturn b[:length]\n\t}\n\treturn b\n}\n\nfunc fileSize(path string) int64 {\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn fi.Size()\n}\n\n// u64tob converts a uint64 into an 8-byte slice.\nfunc u64tob(v uint64) []byte {\n\tb := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(b, v)\n\treturn b\n}\n"
        },
        {
          "name": "db_whitebox_test.go",
          "type": "blob",
          "size": 2.7314453125,
          "content": "package bbolt\n\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"go.etcd.io/bbolt/errors\"\n)\n\nfunc TestOpenWithPreLoadFreelist(t *testing.T) {\n\ttestCases := []struct {\n\t\tname                    string\n\t\treadonly                bool\n\t\tpreLoadFreePage         bool\n\t\texpectedFreePagesLoaded bool\n\t}{\n\t\t{\n\t\t\tname:                    \"write mode always load free pages\",\n\t\t\treadonly:                false,\n\t\t\tpreLoadFreePage:         false,\n\t\t\texpectedFreePagesLoaded: true,\n\t\t},\n\t\t{\n\t\t\tname:                    \"readonly mode load free pages when flag set\",\n\t\t\treadonly:                true,\n\t\t\tpreLoadFreePage:         true,\n\t\t\texpectedFreePagesLoaded: true,\n\t\t},\n\t\t{\n\t\t\tname:                    \"readonly mode doesn't load free pages when flag not set\",\n\t\t\treadonly:                true,\n\t\t\tpreLoadFreePage:         false,\n\t\t\texpectedFreePagesLoaded: false,\n\t\t},\n\t}\n\n\tfileName, err := prepareData(t)\n\trequire.NoError(t, err)\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdb, err := Open(fileName, 0666, &Options{\n\t\t\t\tReadOnly:        tc.readonly,\n\t\t\t\tPreLoadFreelist: tc.preLoadFreePage,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, tc.expectedFreePagesLoaded, db.freelist != nil)\n\n\t\t\tassert.NoError(t, db.Close())\n\t\t})\n\t}\n}\n\nfunc TestMethodPage(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\treadonly        bool\n\t\tpreLoadFreePage bool\n\t\texpectedError   error\n\t}{\n\t\t{\n\t\t\tname:            \"write mode\",\n\t\t\treadonly:        false,\n\t\t\tpreLoadFreePage: false,\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tname:            \"readonly mode with preloading free pages\",\n\t\t\treadonly:        true,\n\t\t\tpreLoadFreePage: true,\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tname:            \"readonly mode without preloading free pages\",\n\t\t\treadonly:        true,\n\t\t\tpreLoadFreePage: false,\n\t\t\texpectedError:   errors.ErrFreePagesNotLoaded,\n\t\t},\n\t}\n\n\tfileName, err := prepareData(t)\n\trequire.NoError(t, err)\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdb, err := Open(fileName, 0666, &Options{\n\t\t\t\tReadOnly:        tc.readonly,\n\t\t\t\tPreLoadFreelist: tc.preLoadFreePage,\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer db.Close()\n\n\t\t\ttx, err := db.Begin(!tc.readonly)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t_, err = tx.Page(0)\n\t\t\trequire.Equal(t, tc.expectedError, err)\n\n\t\t\tif tc.readonly {\n\t\t\t\trequire.NoError(t, tx.Rollback())\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, tx.Commit())\n\t\t\t}\n\n\t\t\trequire.NoError(t, db.Close())\n\t\t})\n\t}\n}\n\nfunc prepareData(t *testing.T) (string, error) {\n\tfileName := filepath.Join(t.TempDir(), \"db\")\n\tdb, err := Open(fileName, 0666, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := db.Close(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fileName, nil\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.7412109375,
          "content": "/*\npackage bbolt implements a low-level key/value store in pure Go. It supports\nfully serializable transactions, ACID semantics, and lock-free MVCC with\nmultiple readers and a single writer. Bolt can be used for projects that\nwant a simple data store without the need to add large dependencies such as\nPostgres or MySQL.\n\nBolt is a single-level, zero-copy, B+tree data store. This means that Bolt is\noptimized for fast read access and does not require recovery in the event of a\nsystem crash. Transactions which have not finished committing will simply be\nrolled back in the event of a crash.\n\nThe design of Bolt is based on Howard Chu's LMDB database project.\n\nBolt currently works on Windows, Mac OS X, and Linux.\n\n# Basics\n\nThere are only a few types in Bolt: DB, Bucket, Tx, and Cursor. The DB is\na collection of buckets and is represented by a single file on disk. A bucket is\na collection of unique keys that are associated with values.\n\nTransactions provide either read-only or read-write access to the database.\nRead-only transactions can retrieve key/value pairs and can use Cursors to\niterate over the dataset sequentially. Read-write transactions can create and\ndelete buckets and can insert and remove keys. Only one read-write transaction\nis allowed at a time.\n\n# Caveats\n\nThe database uses a read-only, memory-mapped data file to ensure that\napplications cannot corrupt the database, however, this means that keys and\nvalues returned from Bolt cannot be changed. Writing to a read-only byte slice\nwill cause Go to panic.\n\nKeys and values retrieved from the database are only valid for the life of\nthe transaction. When used outside the transaction, these byte slices can\npoint to different data or can point to invalid memory which will cause a panic.\n*/\npackage bbolt\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 4.1259765625,
          "content": "package bbolt\n\nimport \"go.etcd.io/bbolt/errors\"\n\n// These errors can be returned when opening or calling methods on a DB.\nvar (\n\t// ErrDatabaseNotOpen is returned when a DB instance is accessed before it\n\t// is opened or after it is closed.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrDatabaseNotOpen = errors.ErrDatabaseNotOpen\n\n\t// ErrInvalid is returned when both meta pages on a database are invalid.\n\t// This typically occurs when a file is not a bolt database.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrInvalid = errors.ErrInvalid\n\n\t// ErrInvalidMapping is returned when the database file fails to get mapped.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrInvalidMapping = errors.ErrInvalidMapping\n\n\t// ErrVersionMismatch is returned when the data file was created with a\n\t// different version of Bolt.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrVersionMismatch = errors.ErrVersionMismatch\n\n\t// ErrChecksum is returned when a checksum mismatch occurs on either of the two meta pages.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrChecksum = errors.ErrChecksum\n\n\t// ErrTimeout is returned when a database cannot obtain an exclusive lock\n\t// on the data file after the timeout passed to Open().\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrTimeout = errors.ErrTimeout\n)\n\n// These errors can occur when beginning or committing a Tx.\nvar (\n\t// ErrTxNotWritable is returned when performing a write operation on a\n\t// read-only transaction.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrTxNotWritable = errors.ErrTxNotWritable\n\n\t// ErrTxClosed is returned when committing or rolling back a transaction\n\t// that has already been committed or rolled back.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrTxClosed = errors.ErrTxClosed\n\n\t// ErrDatabaseReadOnly is returned when a mutating transaction is started on a\n\t// read-only database.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrDatabaseReadOnly = errors.ErrDatabaseReadOnly\n\n\t// ErrFreePagesNotLoaded is returned when a readonly transaction without\n\t// preloading the free pages is trying to access the free pages.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrFreePagesNotLoaded = errors.ErrFreePagesNotLoaded\n)\n\n// These errors can occur when putting or deleting a value or a bucket.\nvar (\n\t// ErrBucketNotFound is returned when trying to access a bucket that has\n\t// not been created yet.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrBucketNotFound = errors.ErrBucketNotFound\n\n\t// ErrBucketExists is returned when creating a bucket that already exists.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrBucketExists = errors.ErrBucketExists\n\n\t// ErrBucketNameRequired is returned when creating a bucket with a blank name.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrBucketNameRequired = errors.ErrBucketNameRequired\n\n\t// ErrKeyRequired is returned when inserting a zero-length key.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrKeyRequired = errors.ErrKeyRequired\n\n\t// ErrKeyTooLarge is returned when inserting a key that is larger than MaxKeySize.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrKeyTooLarge = errors.ErrKeyTooLarge\n\n\t// ErrValueTooLarge is returned when inserting a value that is larger than MaxValueSize.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrValueTooLarge = errors.ErrValueTooLarge\n\n\t// ErrIncompatibleValue is returned when trying create or delete a bucket\n\t// on an existing non-bucket key or when trying to create or delete a\n\t// non-bucket key on an existing bucket key.\n\t//\n\t// Deprecated: Use the error variables defined in the bbolt/errors package.\n\tErrIncompatibleValue = errors.ErrIncompatibleValue\n)\n"
        },
        {
          "name": "errors",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4375,
          "content": "module go.etcd.io/bbolt\n\ngo 1.23\n\ntoolchain go1.23.4\n\nrequire (\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgo.etcd.io/gofail v0.2.0\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/sys v0.29.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.0048828125,
          "content": "github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngo.etcd.io/gofail v0.2.0 h1:p19drv16FKK345a09a1iubchlw/vmRuksmRzgBIGjcA=\ngo.etcd.io/gofail v0.2.0/go.mod h1:nL3ILMGfkXTekKI3clMBNazKnjUZjYLKmBHzsVAnC1o=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 2.4912109375,
          "content": "package bbolt\n\n// See https://github.com/etcd-io/raft/blob/main/logger.go\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\ntype Logger interface {\n\tDebug(v ...interface{})\n\tDebugf(format string, v ...interface{})\n\n\tError(v ...interface{})\n\tErrorf(format string, v ...interface{})\n\n\tInfo(v ...interface{})\n\tInfof(format string, v ...interface{})\n\n\tWarning(v ...interface{})\n\tWarningf(format string, v ...interface{})\n\n\tFatal(v ...interface{})\n\tFatalf(format string, v ...interface{})\n\n\tPanic(v ...interface{})\n\tPanicf(format string, v ...interface{})\n}\n\nfunc getDiscardLogger() Logger {\n\treturn discardLogger\n}\n\nvar (\n\tdiscardLogger = &DefaultLogger{Logger: log.New(io.Discard, \"\", 0)}\n)\n\nconst (\n\tcalldepth = 2\n)\n\n// DefaultLogger is a default implementation of the Logger interface.\ntype DefaultLogger struct {\n\t*log.Logger\n\tdebug bool\n}\n\nfunc (l *DefaultLogger) EnableTimestamps() {\n\tl.SetFlags(l.Flags() | log.Ldate | log.Ltime)\n}\n\nfunc (l *DefaultLogger) EnableDebug() {\n\tl.debug = true\n}\n\nfunc (l *DefaultLogger) Debug(v ...interface{}) {\n\tif l.debug {\n\t\t_ = l.Output(calldepth, header(\"DEBUG\", fmt.Sprint(v...)))\n\t}\n}\n\nfunc (l *DefaultLogger) Debugf(format string, v ...interface{}) {\n\tif l.debug {\n\t\t_ = l.Output(calldepth, header(\"DEBUG\", fmt.Sprintf(format, v...)))\n\t}\n}\n\nfunc (l *DefaultLogger) Info(v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"INFO\", fmt.Sprint(v...)))\n}\n\nfunc (l *DefaultLogger) Infof(format string, v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"INFO\", fmt.Sprintf(format, v...)))\n}\n\nfunc (l *DefaultLogger) Error(v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"ERROR\", fmt.Sprint(v...)))\n}\n\nfunc (l *DefaultLogger) Errorf(format string, v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"ERROR\", fmt.Sprintf(format, v...)))\n}\n\nfunc (l *DefaultLogger) Warning(v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"WARN\", fmt.Sprint(v...)))\n}\n\nfunc (l *DefaultLogger) Warningf(format string, v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"WARN\", fmt.Sprintf(format, v...)))\n}\n\nfunc (l *DefaultLogger) Fatal(v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"FATAL\", fmt.Sprint(v...)))\n\tos.Exit(1)\n}\n\nfunc (l *DefaultLogger) Fatalf(format string, v ...interface{}) {\n\t_ = l.Output(calldepth, header(\"FATAL\", fmt.Sprintf(format, v...)))\n\tos.Exit(1)\n}\n\nfunc (l *DefaultLogger) Panic(v ...interface{}) {\n\tl.Logger.Panic(v...)\n}\n\nfunc (l *DefaultLogger) Panicf(format string, v ...interface{}) {\n\tl.Logger.Panicf(format, v...)\n}\n\nfunc header(lvl, msg string) string {\n\treturn fmt.Sprintf(\"%s: %s\", lvl, msg)\n}\n"
        },
        {
          "name": "manydbs_test.go",
          "type": "blob",
          "size": 1.2509765625,
          "content": "package bbolt\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc createDb(t *testing.T) (*DB, func()) {\n\t// First, create a temporary directory to be used for the duration of\n\t// this test.\n\ttempDirName, err := os.MkdirTemp(\"\", \"bboltmemtest\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp dir: %v\", err)\n\t}\n\tpath := filepath.Join(tempDirName, \"testdb.db\")\n\n\tbdb, err := Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating bbolt db: %v\", err)\n\t}\n\n\tcleanup := func() {\n\t\tbdb.Close()\n\t\tos.RemoveAll(tempDirName)\n\t}\n\n\treturn bdb, cleanup\n}\n\nfunc createAndPutKeys(t *testing.T) {\n\tt.Parallel()\n\n\tdb, cleanup := createDb(t)\n\tdefer cleanup()\n\n\tbucketName := []byte(\"bucket\")\n\n\tfor i := 0; i < 100; i++ {\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tnodes, err := tx.CreateBucketIfNotExists(bucketName)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar key [16]byte\n\t\t\t_, rerr := rand.Read(key[:])\n\t\t\tif rerr != nil {\n\t\t\t\treturn rerr\n\t\t\t}\n\t\t\tif err := nodes.Put(key[:], nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestManyDBs(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode\")\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tt.Run(fmt.Sprintf(\"%d\", i), createAndPutKeys)\n\t}\n}\n"
        },
        {
          "name": "mlock_unix.go",
          "type": "blob",
          "size": 0.6826171875,
          "content": "//go:build !windows\n\npackage bbolt\n\nimport \"golang.org/x/sys/unix\"\n\n// mlock locks memory of db file\nfunc mlock(db *DB, fileSize int) error {\n\tsizeToLock := fileSize\n\tif sizeToLock > db.datasz {\n\t\t// Can't lock more than mmaped slice\n\t\tsizeToLock = db.datasz\n\t}\n\tif err := unix.Mlock(db.dataref[:sizeToLock]); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// munlock unlocks memory of db file\nfunc munlock(db *DB, fileSize int) error {\n\tif db.dataref == nil {\n\t\treturn nil\n\t}\n\n\tsizeToUnlock := fileSize\n\tif sizeToUnlock > db.datasz {\n\t\t// Can't unlock more than mmaped slice\n\t\tsizeToUnlock = db.datasz\n\t}\n\n\tif err := unix.Munlock(db.dataref[:sizeToUnlock]); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "mlock_windows.go",
          "type": "blob",
          "size": 0.25390625,
          "content": "package bbolt\n\n// mlock locks memory of db file\nfunc mlock(_ *DB, _ int) error {\n\tpanic(\"mlock is supported only on UNIX systems\")\n}\n\n// munlock unlocks memory of db file\nfunc munlock(_ *DB, _ int) error {\n\tpanic(\"munlock is supported only on UNIX systems\")\n}\n"
        },
        {
          "name": "movebucket_test.go",
          "type": "blob",
          "size": 11.9970703125,
          "content": "package bbolt_test\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestTx_MoveBucket(t *testing.T) {\n\ttestCases := []struct {\n\t\tname                    string\n\t\tsrcBucketPath           []string\n\t\tdstBucketPath           []string\n\t\tbucketToMove            string\n\t\tbucketExistInSrc        bool\n\t\tbucketExistInDst        bool\n\t\thasIncompatibleKeyInSrc bool\n\t\thasIncompatibleKeyInDst bool\n\t\texpectedErr             error\n\t}{\n\t\t// normal cases\n\t\t{\n\t\t\tname:                    \"normal case\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             nil,\n\t\t},\n\t\t{\n\t\t\tname:                    \"the source and target bucket share the same grandparent\",\n\t\t\tsrcBucketPath:           []string{\"grandparent\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"grandparent\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             nil,\n\t\t},\n\t\t{\n\t\t\tname:                    \"bucketToMove is a top level bucket\",\n\t\t\tsrcBucketPath:           []string{},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             nil,\n\t\t},\n\t\t{\n\t\t\tname:                    \"convert bucketToMove to a top level bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             nil,\n\t\t},\n\t\t// negative cases\n\t\t{\n\t\t\tname:                    \"bucketToMove not exist in source bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        false,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             errors.ErrBucketNotFound,\n\t\t},\n\t\t{\n\t\t\tname:                    \"bucketToMove exist in target bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        true,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             errors.ErrBucketExists,\n\t\t},\n\t\t{\n\t\t\tname:                    \"incompatible key exist in source bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        false,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: true,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             errors.ErrIncompatibleValue,\n\t\t},\n\t\t{\n\t\t\tname:                    \"incompatible key exist in target bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"db1\", \"db2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: true,\n\t\t\texpectedErr:             errors.ErrIncompatibleValue,\n\t\t},\n\t\t{\n\t\t\tname:                    \"the source and target are the same bucket\",\n\t\t\tsrcBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:           []string{\"sb1\", \"sb2\"},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             errors.ErrSameBuckets,\n\t\t},\n\t\t{\n\t\t\tname:                    \"both the source and target are the root bucket\",\n\t\t\tsrcBucketPath:           []string{},\n\t\t\tdstBucketPath:           []string{},\n\t\t\tbucketToMove:            \"bucketToMove\",\n\t\t\tbucketExistInSrc:        true,\n\t\t\tbucketExistInDst:        false,\n\t\t\thasIncompatibleKeyInSrc: false,\n\t\t\thasIncompatibleKeyInDst: false,\n\t\t\texpectedErr:             errors.ErrSameBuckets,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\n\t\tt.Run(tc.name, func(*testing.T) {\n\t\t\tdb := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\n\t\t\tdumpBucketBeforeMoving := filepath.Join(t.TempDir(), \"dbBeforeMove\")\n\t\t\tdumpBucketAfterMoving := filepath.Join(t.TempDir(), \"dbAfterMove\")\n\n\t\t\tt.Log(\"Creating sample db and populate some data\")\n\t\t\terr := db.Update(func(tx *bbolt.Tx) error {\n\t\t\t\tsrcBucket := prepareBuckets(t, tx, tc.srcBucketPath...)\n\t\t\t\tdstBucket := prepareBuckets(t, tx, tc.dstBucketPath...)\n\n\t\t\t\tif tc.bucketExistInSrc {\n\t\t\t\t\t_ = createBucketAndPopulateData(t, tx, srcBucket, tc.bucketToMove)\n\t\t\t\t}\n\n\t\t\t\tif tc.bucketExistInDst {\n\t\t\t\t\t_ = createBucketAndPopulateData(t, tx, dstBucket, tc.bucketToMove)\n\t\t\t\t}\n\n\t\t\t\tif tc.hasIncompatibleKeyInSrc {\n\t\t\t\t\tputErr := srcBucket.Put([]byte(tc.bucketToMove), []byte(\"bar\"))\n\t\t\t\t\trequire.NoError(t, putErr)\n\t\t\t\t}\n\n\t\t\t\tif tc.hasIncompatibleKeyInDst {\n\t\t\t\t\tputErr := dstBucket.Put([]byte(tc.bucketToMove), []byte(\"bar\"))\n\t\t\t\t\trequire.NoError(t, putErr)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tt.Log(\"Moving bucket\")\n\t\t\terr = db.Update(func(tx *bbolt.Tx) error {\n\t\t\t\tsrcBucket := prepareBuckets(t, tx, tc.srcBucketPath...)\n\t\t\t\tdstBucket := prepareBuckets(t, tx, tc.dstBucketPath...)\n\n\t\t\t\tif tc.expectedErr == nil {\n\t\t\t\t\tt.Logf(\"Dump the bucket to %s before moving it\", dumpBucketBeforeMoving)\n\t\t\t\t\tbk := openBucket(tx, srcBucket, tc.bucketToMove)\n\t\t\t\t\tdumpErr := dumpBucket([]byte(tc.bucketToMove), bk, dumpBucketBeforeMoving)\n\t\t\t\t\trequire.NoError(t, dumpErr)\n\t\t\t\t}\n\n\t\t\t\tmErr := tx.MoveBucket([]byte(tc.bucketToMove), srcBucket, dstBucket)\n\t\t\t\trequire.Equal(t, tc.expectedErr, mErr)\n\n\t\t\t\tif tc.expectedErr == nil {\n\t\t\t\t\tt.Logf(\"Dump the bucket to %s after moving it\", dumpBucketAfterMoving)\n\t\t\t\t\tbk := openBucket(tx, dstBucket, tc.bucketToMove)\n\t\t\t\t\tdumpErr := dumpBucket([]byte(tc.bucketToMove), bk, dumpBucketAfterMoving)\n\t\t\t\t\trequire.NoError(t, dumpErr)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// skip assertion if failure expected\n\t\t\tif tc.expectedErr != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt.Log(\"Verifying the bucket should be identical before and after being moved\")\n\t\t\tdataBeforeMove, err := os.ReadFile(dumpBucketBeforeMoving)\n\t\t\trequire.NoError(t, err)\n\t\t\tdataAfterMove, err := os.ReadFile(dumpBucketAfterMoving)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, dataBeforeMove, dataAfterMove)\n\t\t})\n\t}\n}\n\nfunc TestBucket_MoveBucket_DiffDB(t *testing.T) {\n\tsrcBucketPath := []string{\"sb1\", \"sb2\"}\n\tdstBucketPath := []string{\"db1\", \"db2\"}\n\tbucketToMove := \"bucketToMove\"\n\n\tvar srcBucket *bbolt.Bucket\n\n\tt.Log(\"Creating source bucket and populate some data\")\n\tsrcDB := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\terr := srcDB.Update(func(tx *bbolt.Tx) error {\n\t\tsrcBucket = prepareBuckets(t, tx, srcBucketPath...)\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, srcDB.Close())\n\t}()\n\n\tt.Log(\"Creating target bucket and populate some data\")\n\tdstDB := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\terr = dstDB.Update(func(tx *bbolt.Tx) error {\n\t\tprepareBuckets(t, tx, dstBucketPath...)\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, dstDB.Close())\n\t}()\n\n\tt.Log(\"Reading source bucket in a separate RWTx\")\n\tsTx, sErr := srcDB.Begin(true)\n\trequire.NoError(t, sErr)\n\tdefer func() {\n\t\trequire.NoError(t, sTx.Rollback())\n\t}()\n\tsrcBucket = prepareBuckets(t, sTx, srcBucketPath...)\n\n\tt.Log(\"Moving the sub-bucket in a separate RWTx\")\n\terr = dstDB.Update(func(tx *bbolt.Tx) error {\n\t\tdstBucket := prepareBuckets(t, tx, dstBucketPath...)\n\t\tmErr := srcBucket.MoveBucket([]byte(bucketToMove), dstBucket)\n\t\trequire.Equal(t, errors.ErrDifferentDB, mErr)\n\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n}\n\nfunc TestBucket_MoveBucket_DiffTx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tsrcBucketPath   []string\n\t\tdstBucketPath   []string\n\t\tisSrcReadonlyTx bool\n\t\tisDstReadonlyTx bool\n\t\tbucketToMove    string\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tname:            \"src is RWTx and target is RTx\",\n\t\t\tsrcBucketPath:   []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:   []string{\"db1\", \"db2\"},\n\t\t\tisSrcReadonlyTx: true,\n\t\t\tisDstReadonlyTx: false,\n\t\t\tbucketToMove:    \"bucketToMove\",\n\t\t\texpectedErr:     errors.ErrTxNotWritable,\n\t\t},\n\t\t{\n\t\t\tname:            \"src is RTx and target is RWTx\",\n\t\t\tsrcBucketPath:   []string{\"sb1\", \"sb2\"},\n\t\t\tdstBucketPath:   []string{\"db1\", \"db2\"},\n\t\t\tisSrcReadonlyTx: false,\n\t\t\tisDstReadonlyTx: true,\n\t\t\tbucketToMove:    \"bucketToMove\",\n\t\t\texpectedErr:     errors.ErrTxNotWritable,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar srcBucket *bbolt.Bucket\n\t\t\tvar dstBucket *bbolt.Bucket\n\n\t\t\tt.Log(\"Creating source and target buckets and populate some data\")\n\t\t\tdb := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\t\t\terr := db.Update(func(tx *bbolt.Tx) error {\n\t\t\t\tsrcBucket = prepareBuckets(t, tx, tc.srcBucketPath...)\n\t\t\t\tdstBucket = prepareBuckets(t, tx, tc.dstBucketPath...)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer func() {\n\t\t\t\trequire.NoError(t, db.Close())\n\t\t\t}()\n\n\t\t\tt.Log(\"Opening source bucket in a separate Tx\")\n\t\t\tsTx, sErr := db.Begin(tc.isSrcReadonlyTx)\n\t\t\trequire.NoError(t, sErr)\n\t\t\tdefer func() {\n\t\t\t\trequire.NoError(t, sTx.Rollback())\n\t\t\t}()\n\t\t\tsrcBucket = prepareBuckets(t, sTx, tc.srcBucketPath...)\n\n\t\t\tt.Log(\"Opening target bucket in a separate Tx\")\n\t\t\tdTx, dErr := db.Begin(tc.isDstReadonlyTx)\n\t\t\trequire.NoError(t, dErr)\n\t\t\tdefer func() {\n\t\t\t\trequire.NoError(t, dTx.Rollback())\n\t\t\t}()\n\t\t\tdstBucket = prepareBuckets(t, dTx, tc.dstBucketPath...)\n\n\t\t\tt.Log(\"Moving the sub-bucket\")\n\t\t\terr = db.View(func(tx *bbolt.Tx) error {\n\t\t\t\tmErr := srcBucket.MoveBucket([]byte(tc.bucketToMove), dstBucket)\n\t\t\t\trequire.Equal(t, tc.expectedErr, mErr)\n\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\n// prepareBuckets opens the bucket chain. For each bucket in the chain,\n// open it if existed, otherwise create it and populate sample data.\nfunc prepareBuckets(t testing.TB, tx *bbolt.Tx, buckets ...string) *bbolt.Bucket {\n\tvar bk *bbolt.Bucket\n\n\tfor _, key := range buckets {\n\t\tif childBucket := openBucket(tx, bk, key); childBucket == nil {\n\t\t\tbk = createBucketAndPopulateData(t, tx, bk, key)\n\t\t} else {\n\t\t\tbk = childBucket\n\t\t}\n\t}\n\treturn bk\n}\n\nfunc openBucket(tx *bbolt.Tx, bk *bbolt.Bucket, bucketToOpen string) *bbolt.Bucket {\n\tif bk == nil {\n\t\treturn tx.Bucket([]byte(bucketToOpen))\n\t}\n\treturn bk.Bucket([]byte(bucketToOpen))\n}\n\nfunc createBucketAndPopulateData(t testing.TB, tx *bbolt.Tx, bk *bbolt.Bucket, bucketName string) *bbolt.Bucket {\n\tif bk == nil {\n\t\tnewBucket, err := tx.CreateBucket([]byte(bucketName))\n\t\trequire.NoError(t, err, \"failed to create bucket %s\", bucketName)\n\t\tpopulateSampleDataInBucket(t, newBucket, rand.Intn(4096))\n\t\treturn newBucket\n\t}\n\n\tnewBucket, err := bk.CreateBucket([]byte(bucketName))\n\trequire.NoError(t, err, \"failed to create bucket %s\", bucketName)\n\tpopulateSampleDataInBucket(t, newBucket, rand.Intn(4096))\n\treturn newBucket\n}\n\nfunc populateSampleDataInBucket(t testing.TB, bk *bbolt.Bucket, n int) {\n\tvar min, max = 1, 1024\n\n\tfor i := 0; i < n; i++ {\n\t\t// generate rand key/value length\n\t\tkeyLength := rand.Intn(max-min) + min\n\t\tvalLength := rand.Intn(max-min) + min\n\n\t\tkeyData := make([]byte, keyLength)\n\t\tvalData := make([]byte, valLength)\n\n\t\t_, err := crand.Read(keyData)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = crand.Read(valData)\n\t\trequire.NoError(t, err)\n\n\t\terr = bk.Put(keyData, valData)\n\t\trequire.NoError(t, err)\n\t}\n}\n"
        },
        {
          "name": "node.go",
          "type": "blob",
          "size": 14.3115234375,
          "content": "package bbolt\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sort\"\n\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// node represents an in-memory, deserialized page.\ntype node struct {\n\tbucket     *Bucket\n\tisLeaf     bool\n\tunbalanced bool\n\tspilled    bool\n\tkey        []byte\n\tpgid       common.Pgid\n\tparent     *node\n\tchildren   nodes\n\tinodes     common.Inodes\n}\n\n// root returns the top-level node this node is attached to.\nfunc (n *node) root() *node {\n\tif n.parent == nil {\n\t\treturn n\n\t}\n\treturn n.parent.root()\n}\n\n// minKeys returns the minimum number of inodes this node should have.\nfunc (n *node) minKeys() int {\n\tif n.isLeaf {\n\t\treturn 1\n\t}\n\treturn 2\n}\n\n// size returns the size of the node after serialization.\nfunc (n *node) size() int {\n\tsz, elsz := common.PageHeaderSize, n.pageElementSize()\n\tfor i := 0; i < len(n.inodes); i++ {\n\t\titem := &n.inodes[i]\n\t\tsz += elsz + uintptr(len(item.Key())) + uintptr(len(item.Value()))\n\t}\n\treturn int(sz)\n}\n\n// sizeLessThan returns true if the node is less than a given size.\n// This is an optimization to avoid calculating a large node when we only need\n// to know if it fits inside a certain page size.\nfunc (n *node) sizeLessThan(v uintptr) bool {\n\tsz, elsz := common.PageHeaderSize, n.pageElementSize()\n\tfor i := 0; i < len(n.inodes); i++ {\n\t\titem := &n.inodes[i]\n\t\tsz += elsz + uintptr(len(item.Key())) + uintptr(len(item.Value()))\n\t\tif sz >= v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// pageElementSize returns the size of each page element based on the type of node.\nfunc (n *node) pageElementSize() uintptr {\n\tif n.isLeaf {\n\t\treturn common.LeafPageElementSize\n\t}\n\treturn common.BranchPageElementSize\n}\n\n// childAt returns the child node at a given index.\nfunc (n *node) childAt(index int) *node {\n\tif n.isLeaf {\n\t\tpanic(fmt.Sprintf(\"invalid childAt(%d) on a leaf node\", index))\n\t}\n\treturn n.bucket.node(n.inodes[index].Pgid(), n)\n}\n\n// childIndex returns the index of a given child node.\nfunc (n *node) childIndex(child *node) int {\n\tindex := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].Key(), child.key) != -1 })\n\treturn index\n}\n\n// numChildren returns the number of children.\nfunc (n *node) numChildren() int {\n\treturn len(n.inodes)\n}\n\n// nextSibling returns the next node with the same parent.\nfunc (n *node) nextSibling() *node {\n\tif n.parent == nil {\n\t\treturn nil\n\t}\n\tindex := n.parent.childIndex(n)\n\tif index >= n.parent.numChildren()-1 {\n\t\treturn nil\n\t}\n\treturn n.parent.childAt(index + 1)\n}\n\n// prevSibling returns the previous node with the same parent.\nfunc (n *node) prevSibling() *node {\n\tif n.parent == nil {\n\t\treturn nil\n\t}\n\tindex := n.parent.childIndex(n)\n\tif index == 0 {\n\t\treturn nil\n\t}\n\treturn n.parent.childAt(index - 1)\n}\n\n// put inserts a key/value.\nfunc (n *node) put(oldKey, newKey, value []byte, pgId common.Pgid, flags uint32) {\n\tif pgId >= n.bucket.tx.meta.Pgid() {\n\t\tpanic(fmt.Sprintf(\"pgId (%d) above high water mark (%d)\", pgId, n.bucket.tx.meta.Pgid()))\n\t} else if len(oldKey) <= 0 {\n\t\tpanic(\"put: zero-length old key\")\n\t} else if len(newKey) <= 0 {\n\t\tpanic(\"put: zero-length new key\")\n\t}\n\n\t// Find insertion index.\n\tindex := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].Key(), oldKey) != -1 })\n\n\t// Add capacity and shift nodes if we don't have an exact match and need to insert.\n\texact := len(n.inodes) > 0 && index < len(n.inodes) && bytes.Equal(n.inodes[index].Key(), oldKey)\n\tif !exact {\n\t\tn.inodes = append(n.inodes, common.Inode{})\n\t\tcopy(n.inodes[index+1:], n.inodes[index:])\n\t}\n\n\tinode := &n.inodes[index]\n\tinode.SetFlags(flags)\n\tinode.SetKey(newKey)\n\tinode.SetValue(value)\n\tinode.SetPgid(pgId)\n\tcommon.Assert(len(inode.Key()) > 0, \"put: zero-length inode key\")\n}\n\n// del removes a key from the node.\nfunc (n *node) del(key []byte) {\n\t// Find index of key.\n\tindex := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].Key(), key) != -1 })\n\n\t// Exit if the key isn't found.\n\tif index >= len(n.inodes) || !bytes.Equal(n.inodes[index].Key(), key) {\n\t\treturn\n\t}\n\n\t// Delete inode from the node.\n\tn.inodes = append(n.inodes[:index], n.inodes[index+1:]...)\n\n\t// Mark the node as needing rebalancing.\n\tn.unbalanced = true\n}\n\n// read initializes the node from a page.\nfunc (n *node) read(p *common.Page) {\n\tn.pgid = p.Id()\n\tn.isLeaf = p.IsLeafPage()\n\tn.inodes = common.ReadInodeFromPage(p)\n\n\t// Save first key, so we can find the node in the parent when we spill.\n\tif len(n.inodes) > 0 {\n\t\tn.key = n.inodes[0].Key()\n\t\tcommon.Assert(len(n.key) > 0, \"read: zero-length node key\")\n\t} else {\n\t\tn.key = nil\n\t}\n}\n\n// write writes the items onto one or more pages.\n// The page should have p.id (might be 0 for meta or bucket-inline page) and p.overflow set\n// and the rest should be zeroed.\nfunc (n *node) write(p *common.Page) {\n\tcommon.Assert(p.Count() == 0 && p.Flags() == 0, \"node cannot be written into a not empty page\")\n\n\t// Initialize page.\n\tif n.isLeaf {\n\t\tp.SetFlags(common.LeafPageFlag)\n\t} else {\n\t\tp.SetFlags(common.BranchPageFlag)\n\t}\n\n\tif len(n.inodes) >= 0xFFFF {\n\t\tpanic(fmt.Sprintf(\"inode overflow: %d (pgid=%d)\", len(n.inodes), p.Id()))\n\t}\n\tp.SetCount(uint16(len(n.inodes)))\n\n\t// Stop here if there are no items to write.\n\tif p.Count() == 0 {\n\t\treturn\n\t}\n\n\tcommon.WriteInodeToPage(n.inodes, p)\n\n\t// DEBUG ONLY: n.dump()\n}\n\n// split breaks up a node into multiple smaller nodes, if appropriate.\n// This should only be called from the spill() function.\nfunc (n *node) split(pageSize uintptr) []*node {\n\tvar nodes []*node\n\n\tnode := n\n\tfor {\n\t\t// Split node into two.\n\t\ta, b := node.splitTwo(pageSize)\n\t\tnodes = append(nodes, a)\n\n\t\t// If we can't split then exit the loop.\n\t\tif b == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Set node to b so it gets split on the next iteration.\n\t\tnode = b\n\t}\n\n\treturn nodes\n}\n\n// splitTwo breaks up a node into two smaller nodes, if appropriate.\n// This should only be called from the split() function.\nfunc (n *node) splitTwo(pageSize uintptr) (*node, *node) {\n\t// Ignore the split if the page doesn't have at least enough nodes for\n\t// two pages or if the nodes can fit in a single page.\n\tif len(n.inodes) <= (common.MinKeysPerPage*2) || n.sizeLessThan(pageSize) {\n\t\treturn n, nil\n\t}\n\n\t// Determine the threshold before starting a new node.\n\tvar fillPercent = n.bucket.FillPercent\n\tif fillPercent < minFillPercent {\n\t\tfillPercent = minFillPercent\n\t} else if fillPercent > maxFillPercent {\n\t\tfillPercent = maxFillPercent\n\t}\n\tthreshold := int(float64(pageSize) * fillPercent)\n\n\t// Determine split position and sizes of the two pages.\n\tsplitIndex, _ := n.splitIndex(threshold)\n\n\t// Split node into two separate nodes.\n\t// If there's no parent then we'll need to create one.\n\tif n.parent == nil {\n\t\tn.parent = &node{bucket: n.bucket, children: []*node{n}}\n\t}\n\n\t// Create a new node and add it to the parent.\n\tnext := &node{bucket: n.bucket, isLeaf: n.isLeaf, parent: n.parent}\n\tn.parent.children = append(n.parent.children, next)\n\n\t// Split inodes across two nodes.\n\tnext.inodes = n.inodes[splitIndex:]\n\tn.inodes = n.inodes[:splitIndex]\n\n\t// Update the statistics.\n\tn.bucket.tx.stats.IncSplit(1)\n\n\treturn n, next\n}\n\n// splitIndex finds the position where a page will fill a given threshold.\n// It returns the index as well as the size of the first page.\n// This is only be called from split().\nfunc (n *node) splitIndex(threshold int) (index, sz uintptr) {\n\tsz = common.PageHeaderSize\n\n\t// Loop until we only have the minimum number of keys required for the second page.\n\tfor i := 0; i < len(n.inodes)-common.MinKeysPerPage; i++ {\n\t\tindex = uintptr(i)\n\t\tinode := n.inodes[i]\n\t\telsize := n.pageElementSize() + uintptr(len(inode.Key())) + uintptr(len(inode.Value()))\n\n\t\t// If we have at least the minimum number of keys and adding another\n\t\t// node would put us over the threshold then exit and return.\n\t\tif index >= common.MinKeysPerPage && sz+elsize > uintptr(threshold) {\n\t\t\tbreak\n\t\t}\n\n\t\t// Add the element size to the total size.\n\t\tsz += elsize\n\t}\n\n\treturn\n}\n\n// spill writes the nodes to dirty pages and splits nodes as it goes.\n// Returns an error if dirty pages cannot be allocated.\nfunc (n *node) spill() error {\n\tvar tx = n.bucket.tx\n\tif n.spilled {\n\t\treturn nil\n\t}\n\n\t// Spill child nodes first. Child nodes can materialize sibling nodes in\n\t// the case of split-merge so we cannot use a range loop. We have to check\n\t// the children size on every loop iteration.\n\tsort.Sort(n.children)\n\tfor i := 0; i < len(n.children); i++ {\n\t\tif err := n.children[i].spill(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We no longer need the child list because it's only used for spill tracking.\n\tn.children = nil\n\n\t// Split nodes into appropriate sizes. The first node will always be n.\n\tvar nodes = n.split(uintptr(tx.db.pageSize))\n\tfor _, node := range nodes {\n\t\t// Add node's page to the freelist if it's not new.\n\t\tif node.pgid > 0 {\n\t\t\ttx.db.freelist.Free(tx.meta.Txid(), tx.page(node.pgid))\n\t\t\tnode.pgid = 0\n\t\t}\n\n\t\t// Allocate contiguous space for the node.\n\t\tp, err := tx.allocate((node.size() + tx.db.pageSize - 1) / tx.db.pageSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the node.\n\t\tif p.Id() >= tx.meta.Pgid() {\n\t\t\tpanic(fmt.Sprintf(\"pgid (%d) above high water mark (%d)\", p.Id(), tx.meta.Pgid()))\n\t\t}\n\t\tnode.pgid = p.Id()\n\t\tnode.write(p)\n\t\tnode.spilled = true\n\n\t\t// Insert into parent inodes.\n\t\tif node.parent != nil {\n\t\t\tvar key = node.key\n\t\t\tif key == nil {\n\t\t\t\tkey = node.inodes[0].Key()\n\t\t\t}\n\n\t\t\tnode.parent.put(key, node.inodes[0].Key(), nil, node.pgid, 0)\n\t\t\tnode.key = node.inodes[0].Key()\n\t\t\tcommon.Assert(len(node.key) > 0, \"spill: zero-length node key\")\n\t\t}\n\n\t\t// Update the statistics.\n\t\ttx.stats.IncSpill(1)\n\t}\n\n\t// If the root node split and created a new root then we need to spill that\n\t// as well. We'll clear out the children to make sure it doesn't try to respill.\n\tif n.parent != nil && n.parent.pgid == 0 {\n\t\tn.children = nil\n\t\treturn n.parent.spill()\n\t}\n\n\treturn nil\n}\n\n// rebalance attempts to combine the node with sibling nodes if the node fill\n// size is below a threshold or if there are not enough keys.\nfunc (n *node) rebalance() {\n\tif !n.unbalanced {\n\t\treturn\n\t}\n\tn.unbalanced = false\n\n\t// Update statistics.\n\tn.bucket.tx.stats.IncRebalance(1)\n\n\t// Ignore if node is above threshold (25% when FillPercent is set to DefaultFillPercent) and has enough keys.\n\tvar threshold = int(float64(n.bucket.tx.db.pageSize)*n.bucket.FillPercent) / 2\n\tif n.size() > threshold && len(n.inodes) > n.minKeys() {\n\t\treturn\n\t}\n\n\t// Root node has special handling.\n\tif n.parent == nil {\n\t\t// If root node is a branch and only has one node then collapse it.\n\t\tif !n.isLeaf && len(n.inodes) == 1 {\n\t\t\t// Move root's child up.\n\t\t\tchild := n.bucket.node(n.inodes[0].Pgid(), n)\n\t\t\tn.isLeaf = child.isLeaf\n\t\t\tn.inodes = child.inodes[:]\n\t\t\tn.children = child.children\n\n\t\t\t// Reparent all child nodes being moved.\n\t\t\tfor _, inode := range n.inodes {\n\t\t\t\tif child, ok := n.bucket.nodes[inode.Pgid()]; ok {\n\t\t\t\t\tchild.parent = n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove old child.\n\t\t\tchild.parent = nil\n\t\t\tdelete(n.bucket.nodes, child.pgid)\n\t\t\tchild.free()\n\t\t}\n\n\t\treturn\n\t}\n\n\t// If node has no keys then just remove it.\n\tif n.numChildren() == 0 {\n\t\tn.parent.del(n.key)\n\t\tn.parent.removeChild(n)\n\t\tdelete(n.bucket.nodes, n.pgid)\n\t\tn.free()\n\t\tn.parent.rebalance()\n\t\treturn\n\t}\n\n\tcommon.Assert(n.parent.numChildren() > 1, \"parent must have at least 2 children\")\n\n\t// Merge with right sibling if idx == 0, otherwise left sibling.\n\tvar leftNode, rightNode *node\n\tvar useNextSibling = n.parent.childIndex(n) == 0\n\tif useNextSibling {\n\t\tleftNode = n\n\t\trightNode = n.nextSibling()\n\t} else {\n\t\tleftNode = n.prevSibling()\n\t\trightNode = n\n\t}\n\n\t// If both nodes are too small then merge them.\n\t// Reparent all child nodes being moved.\n\tfor _, inode := range rightNode.inodes {\n\t\tif child, ok := n.bucket.nodes[inode.Pgid()]; ok {\n\t\t\tchild.parent.removeChild(child)\n\t\t\tchild.parent = leftNode\n\t\t\tchild.parent.children = append(child.parent.children, child)\n\t\t}\n\t}\n\n\t// Copy over inodes from right node to left node and remove right node.\n\tleftNode.inodes = append(leftNode.inodes, rightNode.inodes...)\n\tn.parent.del(rightNode.key)\n\tn.parent.removeChild(rightNode)\n\tdelete(n.bucket.nodes, rightNode.pgid)\n\trightNode.free()\n\n\t// Either this node or the sibling node was deleted from the parent so rebalance it.\n\tn.parent.rebalance()\n}\n\n// removes a node from the list of in-memory children.\n// This does not affect the inodes.\nfunc (n *node) removeChild(target *node) {\n\tfor i, child := range n.children {\n\t\tif child == target {\n\t\t\tn.children = append(n.children[:i], n.children[i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// dereference causes the node to copy all its inode key/value references to heap memory.\n// This is required when the mmap is reallocated so inodes are not pointing to stale data.\nfunc (n *node) dereference() {\n\tif n.key != nil {\n\t\tkey := make([]byte, len(n.key))\n\t\tcopy(key, n.key)\n\t\tn.key = key\n\t\tcommon.Assert(n.pgid == 0 || len(n.key) > 0, \"dereference: zero-length node key on existing node\")\n\t}\n\n\tfor i := range n.inodes {\n\t\tinode := &n.inodes[i]\n\n\t\tkey := make([]byte, len(inode.Key()))\n\t\tcopy(key, inode.Key())\n\t\tinode.SetKey(key)\n\t\tcommon.Assert(len(inode.Key()) > 0, \"dereference: zero-length inode key\")\n\n\t\tvalue := make([]byte, len(inode.Value()))\n\t\tcopy(value, inode.Value())\n\t\tinode.SetValue(value)\n\t}\n\n\t// Recursively dereference children.\n\tfor _, child := range n.children {\n\t\tchild.dereference()\n\t}\n\n\t// Update statistics.\n\tn.bucket.tx.stats.IncNodeDeref(1)\n}\n\n// free adds the node's underlying page to the freelist.\nfunc (n *node) free() {\n\tif n.pgid != 0 {\n\t\tn.bucket.tx.db.freelist.Free(n.bucket.tx.meta.Txid(), n.bucket.tx.page(n.pgid))\n\t\tn.pgid = 0\n\t}\n}\n\n// dump writes the contents of the node to STDERR for debugging purposes.\n/*\nfunc (n *node) dump() {\n\t// Write node header.\n\tvar typ = \"branch\"\n\tif n.isLeaf {\n\t\ttyp = \"leaf\"\n\t}\n\twarnf(\"[NODE %d {type=%s count=%d}]\", n.pgid, typ, len(n.inodes))\n\n\t// Write out abbreviated version of each item.\n\tfor _, item := range n.inodes {\n\t\tif n.isLeaf {\n\t\t\tif item.flags&bucketLeafFlag != 0 {\n\t\t\t\tbucket := (*bucket)(unsafe.Pointer(&item.value[0]))\n\t\t\t\twarnf(\"+L %08x -> (bucket root=%d)\", trunc(item.key, 4), bucket.root)\n\t\t\t} else {\n\t\t\t\twarnf(\"+L %08x -> %08x\", trunc(item.key, 4), trunc(item.value, 4))\n\t\t\t}\n\t\t} else {\n\t\t\twarnf(\"+B %08x -> pgid=%d\", trunc(item.key, 4), item.pgid)\n\t\t}\n\t}\n\twarn(\"\")\n}\n*/\n\nfunc compareKeys(left, right []byte) int {\n\treturn bytes.Compare(left, right)\n}\n\ntype nodes []*node\n\nfunc (s nodes) Len() int      { return len(s) }\nfunc (s nodes) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\nfunc (s nodes) Less(i, j int) bool {\n\treturn bytes.Compare(s[i].inodes[0].Key(), s[j].inodes[0].Key()) == -1\n}\n"
        },
        {
          "name": "node_test.go",
          "type": "blob",
          "size": 5.876953125,
          "content": "package bbolt\n\nimport (\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// Ensure that a node can insert a key/value.\nfunc TestNode_put(t *testing.T) {\n\tm := &common.Meta{}\n\tm.SetPgid(1)\n\tn := &node{inodes: make(common.Inodes, 0), bucket: &Bucket{tx: &Tx{meta: m}}}\n\tn.put([]byte(\"baz\"), []byte(\"baz\"), []byte(\"2\"), 0, 0)\n\tn.put([]byte(\"foo\"), []byte(\"foo\"), []byte(\"0\"), 0, 0)\n\tn.put([]byte(\"bar\"), []byte(\"bar\"), []byte(\"1\"), 0, 0)\n\tn.put([]byte(\"foo\"), []byte(\"foo\"), []byte(\"3\"), 0, common.LeafPageFlag)\n\n\tif len(n.inodes) != 3 {\n\t\tt.Fatalf(\"exp=3; got=%d\", len(n.inodes))\n\t}\n\tif k, v := n.inodes[0].Key(), n.inodes[0].Value(); string(k) != \"bar\" || string(v) != \"1\" {\n\t\tt.Fatalf(\"exp=<bar,1>; got=<%s,%s>\", k, v)\n\t}\n\tif k, v := n.inodes[1].Key(), n.inodes[1].Value(); string(k) != \"baz\" || string(v) != \"2\" {\n\t\tt.Fatalf(\"exp=<baz,2>; got=<%s,%s>\", k, v)\n\t}\n\tif k, v := n.inodes[2].Key(), n.inodes[2].Value(); string(k) != \"foo\" || string(v) != \"3\" {\n\t\tt.Fatalf(\"exp=<foo,3>; got=<%s,%s>\", k, v)\n\t}\n\tif n.inodes[2].Flags() != uint32(common.LeafPageFlag) {\n\t\tt.Fatalf(\"not a leaf: %d\", n.inodes[2].Flags())\n\t}\n}\n\n// Ensure that a node can deserialize from a leaf page.\nfunc TestNode_read_LeafPage(t *testing.T) {\n\t// Create a page.\n\tvar buf [4096]byte\n\tpage := (*common.Page)(unsafe.Pointer(&buf[0]))\n\tpage.SetFlags(common.LeafPageFlag)\n\tpage.SetCount(2)\n\n\t// Insert 2 elements at the beginning. sizeof(leafPageElement) == 16\n\tnodes := page.LeafPageElements()\n\t//nodes := (*[3]leafPageElement)(unsafe.Pointer(uintptr(unsafe.Pointer(page)) + unsafe.Sizeof(*page)))\n\tnodes[0] = *common.NewLeafPageElement(0, 32, 3, 4)  // pos = sizeof(leafPageElement) * 2\n\tnodes[1] = *common.NewLeafPageElement(0, 23, 10, 3) // pos = sizeof(leafPageElement) + 3 + 4\n\n\t// Write data for the nodes at the end.\n\tconst s = \"barfoozhelloworldbye\"\n\tdata := common.UnsafeByteSlice(unsafe.Pointer(uintptr(unsafe.Pointer(page))+unsafe.Sizeof(*page)+common.LeafPageElementSize*2), 0, 0, len(s))\n\tcopy(data, s)\n\n\t// Deserialize page into a leaf.\n\tn := &node{}\n\tn.read(page)\n\n\t// Check that there are two inodes with correct data.\n\tif !n.isLeaf {\n\t\tt.Fatal(\"expected leaf\")\n\t}\n\tif len(n.inodes) != 2 {\n\t\tt.Fatalf(\"exp=2; got=%d\", len(n.inodes))\n\t}\n\tif k, v := n.inodes[0].Key(), n.inodes[0].Value(); string(k) != \"bar\" || string(v) != \"fooz\" {\n\t\tt.Fatalf(\"exp=<bar,fooz>; got=<%s,%s>\", k, v)\n\t}\n\tif k, v := n.inodes[1].Key(), n.inodes[1].Value(); string(k) != \"helloworld\" || string(v) != \"bye\" {\n\t\tt.Fatalf(\"exp=<helloworld,bye>; got=<%s,%s>\", k, v)\n\t}\n}\n\n// Ensure that a node can serialize into a leaf page.\nfunc TestNode_write_LeafPage(t *testing.T) {\n\t// Create a node.\n\tm := &common.Meta{}\n\tm.SetPgid(1)\n\tn := &node{isLeaf: true, inodes: make(common.Inodes, 0), bucket: &Bucket{tx: &Tx{db: &DB{}, meta: m}}}\n\tn.put([]byte(\"susy\"), []byte(\"susy\"), []byte(\"que\"), 0, 0)\n\tn.put([]byte(\"ricki\"), []byte(\"ricki\"), []byte(\"lake\"), 0, 0)\n\tn.put([]byte(\"john\"), []byte(\"john\"), []byte(\"johnson\"), 0, 0)\n\n\t// Write it to a page.\n\tvar buf [4096]byte\n\tp := (*common.Page)(unsafe.Pointer(&buf[0]))\n\tn.write(p)\n\n\t// Read the page back in.\n\tn2 := &node{}\n\tn2.read(p)\n\n\t// Check that the two pages are the same.\n\tif len(n2.inodes) != 3 {\n\t\tt.Fatalf(\"exp=3; got=%d\", len(n2.inodes))\n\t}\n\tif k, v := n2.inodes[0].Key(), n2.inodes[0].Value(); string(k) != \"john\" || string(v) != \"johnson\" {\n\t\tt.Fatalf(\"exp=<john,johnson>; got=<%s,%s>\", k, v)\n\t}\n\tif k, v := n2.inodes[1].Key(), n2.inodes[1].Value(); string(k) != \"ricki\" || string(v) != \"lake\" {\n\t\tt.Fatalf(\"exp=<ricki,lake>; got=<%s,%s>\", k, v)\n\t}\n\tif k, v := n2.inodes[2].Key(), n2.inodes[2].Value(); string(k) != \"susy\" || string(v) != \"que\" {\n\t\tt.Fatalf(\"exp=<susy,que>; got=<%s,%s>\", k, v)\n\t}\n}\n\n// Ensure that a node can split into appropriate subgroups.\nfunc TestNode_split(t *testing.T) {\n\t// Create a node.\n\tm := &common.Meta{}\n\tm.SetPgid(1)\n\tn := &node{inodes: make(common.Inodes, 0), bucket: &Bucket{tx: &Tx{db: &DB{}, meta: m}}}\n\tn.put([]byte(\"00000001\"), []byte(\"00000001\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000002\"), []byte(\"00000002\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000003\"), []byte(\"00000003\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000004\"), []byte(\"00000004\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000005\"), []byte(\"00000005\"), []byte(\"0123456701234567\"), 0, 0)\n\n\t// Split between 2 & 3.\n\tn.split(100)\n\n\tvar parent = n.parent\n\tif len(parent.children) != 2 {\n\t\tt.Fatalf(\"exp=2; got=%d\", len(parent.children))\n\t}\n\tif len(parent.children[0].inodes) != 2 {\n\t\tt.Fatalf(\"exp=2; got=%d\", len(parent.children[0].inodes))\n\t}\n\tif len(parent.children[1].inodes) != 3 {\n\t\tt.Fatalf(\"exp=3; got=%d\", len(parent.children[1].inodes))\n\t}\n}\n\n// Ensure that a page with the minimum number of inodes just returns a single node.\nfunc TestNode_split_MinKeys(t *testing.T) {\n\t// Create a node.\n\tm := &common.Meta{}\n\tm.SetPgid(1)\n\tn := &node{inodes: make(common.Inodes, 0), bucket: &Bucket{tx: &Tx{db: &DB{}, meta: m}}}\n\tn.put([]byte(\"00000001\"), []byte(\"00000001\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000002\"), []byte(\"00000002\"), []byte(\"0123456701234567\"), 0, 0)\n\n\t// Split.\n\tn.split(20)\n\tif n.parent != nil {\n\t\tt.Fatalf(\"expected nil parent\")\n\t}\n}\n\n// Ensure that a node that has keys that all fit on a page just returns one leaf.\nfunc TestNode_split_SinglePage(t *testing.T) {\n\t// Create a node.\n\tm := &common.Meta{}\n\tm.SetPgid(1)\n\tn := &node{inodes: make(common.Inodes, 0), bucket: &Bucket{tx: &Tx{db: &DB{}, meta: m}}}\n\tn.put([]byte(\"00000001\"), []byte(\"00000001\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000002\"), []byte(\"00000002\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000003\"), []byte(\"00000003\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000004\"), []byte(\"00000004\"), []byte(\"0123456701234567\"), 0, 0)\n\tn.put([]byte(\"00000005\"), []byte(\"00000005\"), []byte(\"0123456701234567\"), 0, 0)\n\n\t// Split.\n\tn.split(4096)\n\tif n.parent != nil {\n\t\tt.Fatalf(\"expected nil parent\")\n\t}\n}\n"
        },
        {
          "name": "quick_test.go",
          "type": "blob",
          "size": 2.455078125,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n)\n\n// testing/quick defaults to 5 iterations and a random seed.\n// You can override these settings from the command line:\n//\n//   -quick.count     The number of iterations to perform.\n//   -quick.seed      The seed to use for randomizing.\n//   -quick.maxitems  The maximum number of items to insert into a DB.\n//   -quick.maxksize  The maximum size of a key.\n//   -quick.maxvsize  The maximum size of a value.\n//\n\nvar qcount, qseed, qmaxitems, qmaxksize, qmaxvsize int\n\nfunc TestMain(m *testing.M) {\n\tflag.IntVar(&qcount, \"quick.count\", 5, \"\")\n\tflag.IntVar(&qseed, \"quick.seed\", int(time.Now().UnixNano())%100000, \"\")\n\tflag.IntVar(&qmaxitems, \"quick.maxitems\", 1000, \"\")\n\tflag.IntVar(&qmaxksize, \"quick.maxksize\", 1024, \"\")\n\tflag.IntVar(&qmaxvsize, \"quick.maxvsize\", 1024, \"\")\n\tflag.Parse()\n\tfmt.Fprintln(os.Stderr, \"seed:\", qseed)\n\tfmt.Fprintf(os.Stderr, \"quick settings: count=%v, items=%v, ksize=%v, vsize=%v\\n\", qcount, qmaxitems, qmaxksize, qmaxvsize)\n\n\tos.Exit(m.Run())\n}\n\nfunc qconfig() *quick.Config {\n\treturn &quick.Config{\n\t\tMaxCount: qcount,\n\t\tRand:     rand.New(rand.NewSource(int64(qseed))),\n\t}\n}\n\ntype testdata []testdataitem\n\nfunc (t testdata) Len() int           { return len(t) }\nfunc (t testdata) Swap(i, j int)      { t[i], t[j] = t[j], t[i] }\nfunc (t testdata) Less(i, j int) bool { return bytes.Compare(t[i].Key, t[j].Key) == -1 }\n\nfunc (t testdata) Generate(rand *rand.Rand, size int) reflect.Value {\n\tn := rand.Intn(qmaxitems-1) + 1\n\titems := make(testdata, n)\n\tused := make(map[string]bool)\n\tfor i := 0; i < n; i++ {\n\t\titem := &items[i]\n\t\t// Ensure that keys are unique by looping until we find one that we have not already used.\n\t\tfor {\n\t\t\titem.Key = randByteSlice(rand, 1, qmaxksize)\n\t\t\tif !used[string(item.Key)] {\n\t\t\t\tused[string(item.Key)] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\titem.Value = randByteSlice(rand, 0, qmaxvsize)\n\t}\n\treturn reflect.ValueOf(items)\n}\n\ntype revtestdata []testdataitem\n\nfunc (t revtestdata) Len() int           { return len(t) }\nfunc (t revtestdata) Swap(i, j int)      { t[i], t[j] = t[j], t[i] }\nfunc (t revtestdata) Less(i, j int) bool { return bytes.Compare(t[i].Key, t[j].Key) == 1 }\n\ntype testdataitem struct {\n\tKey   []byte\n\tValue []byte\n}\n\nfunc randByteSlice(rand *rand.Rand, minSize, maxSize int) []byte {\n\tn := rand.Intn(maxSize-minSize) + minSize\n\tb := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = byte(rand.Intn(255))\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "simulation_no_freelist_sync_test.go",
          "type": "blob",
          "size": 1.6806640625,
          "content": "package bbolt_test\n\nimport (\n\t\"testing\"\n\n\tbolt \"go.etcd.io/bbolt\"\n)\n\nfunc TestSimulateNoFreeListSync_1op_1p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 1, 1)\n}\nfunc TestSimulateNoFreeListSync_10op_1p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10, 1)\n}\nfunc TestSimulateNoFreeListSync_100op_1p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 100, 1)\n}\nfunc TestSimulateNoFreeListSync_1000op_1p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 1000, 1)\n}\nfunc TestSimulateNoFreeListSync_10000op_1p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10000, 1)\n}\nfunc TestSimulateNoFreeListSync_10op_10p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10, 10)\n}\nfunc TestSimulateNoFreeListSync_100op_10p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 100, 10)\n}\nfunc TestSimulateNoFreeListSync_1000op_10p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 1000, 10)\n}\nfunc TestSimulateNoFreeListSync_10000op_10p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10000, 10)\n}\nfunc TestSimulateNoFreeListSync_100op_100p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 100, 100)\n}\nfunc TestSimulateNoFreeListSync_1000op_100p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 1000, 100)\n}\nfunc TestSimulateNoFreeListSync_10000op_100p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10000, 100)\n}\nfunc TestSimulateNoFreeListSync_10000op_1000p(t *testing.T) {\n\ttestSimulate(t, &bolt.Options{NoFreelistSync: true}, 8, 10000, 1000)\n}\n"
        },
        {
          "name": "simulation_test.go",
          "type": "blob",
          "size": 8.6611328125,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\nfunc TestSimulate_1op_1p(t *testing.T)     { testSimulate(t, nil, 1, 1, 1) }\nfunc TestSimulate_10op_1p(t *testing.T)    { testSimulate(t, nil, 1, 10, 1) }\nfunc TestSimulate_100op_1p(t *testing.T)   { testSimulate(t, nil, 1, 100, 1) }\nfunc TestSimulate_1000op_1p(t *testing.T)  { testSimulate(t, nil, 1, 1000, 1) }\nfunc TestSimulate_10000op_1p(t *testing.T) { testSimulate(t, nil, 1, 10000, 1) }\n\nfunc TestSimulate_10op_10p(t *testing.T)    { testSimulate(t, nil, 1, 10, 10) }\nfunc TestSimulate_100op_10p(t *testing.T)   { testSimulate(t, nil, 1, 100, 10) }\nfunc TestSimulate_1000op_10p(t *testing.T)  { testSimulate(t, nil, 1, 1000, 10) }\nfunc TestSimulate_10000op_10p(t *testing.T) { testSimulate(t, nil, 1, 10000, 10) }\n\nfunc TestSimulate_100op_100p(t *testing.T)   { testSimulate(t, nil, 1, 100, 100) }\nfunc TestSimulate_1000op_100p(t *testing.T)  { testSimulate(t, nil, 1, 1000, 100) }\nfunc TestSimulate_10000op_100p(t *testing.T) { testSimulate(t, nil, 1, 10000, 100) }\n\nfunc TestSimulate_10000op_1000p(t *testing.T) { testSimulate(t, nil, 1, 10000, 1000) }\n\n// Randomly generate operations on a given database with multiple clients to ensure consistency and thread safety.\nfunc testSimulate(t *testing.T, openOption *bolt.Options, round, threadCount, parallelism int) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n\n\t// A list of operations that readers and writers can perform.\n\tvar readerHandlers = []simulateHandler{simulateGetHandler}\n\tvar writerHandlers = []simulateHandler{simulateGetHandler, simulatePutHandler}\n\n\tvar versions = make(map[int]*QuickDB)\n\tversions[1] = NewQuickDB()\n\n\tdb := btesting.MustCreateDBWithOption(t, openOption)\n\n\tvar mutex sync.Mutex\n\n\tfor n := 0; n < round; n++ {\n\t\t// Run n threads in parallel, each with their own operation.\n\t\tvar threads = make(chan bool, parallelism)\n\t\tvar wg sync.WaitGroup\n\n\t\t// counter for how many goroutines were fired\n\t\tvar opCount int64\n\n\t\t// counter for ignored operations\n\t\tvar igCount int64\n\n\t\tvar errCh = make(chan error, threadCount)\n\n\t\tvar i int\n\t\tfor {\n\t\t\t// this buffered channel will keep accepting booleans\n\t\t\t// until it hits the limit defined by the parallelism\n\t\t\t// argument to testSimulate()\n\t\t\tthreads <- true\n\n\t\t\t// this wait group can only be marked \"done\" from inside\n\t\t\t// the subsequent goroutine\n\t\t\twg.Add(1)\n\t\t\twritable := ((rand.Int() % 100) < 20) // 20% writers\n\n\t\t\t// Choose an operation to execute.\n\t\t\tvar handler simulateHandler\n\t\t\tif writable {\n\t\t\t\thandler = writerHandlers[rand.Intn(len(writerHandlers))]\n\t\t\t} else {\n\t\t\t\thandler = readerHandlers[rand.Intn(len(readerHandlers))]\n\t\t\t}\n\n\t\t\t// Execute a thread for the given operation.\n\t\t\tgo func(writable bool, handler simulateHandler) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tatomic.AddInt64(&opCount, 1)\n\t\t\t\t// Start transaction.\n\t\t\t\ttx, err := db.Begin(writable)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrCh <- fmt.Errorf(\"error tx begin: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Obtain current state of the dataset.\n\t\t\t\tmutex.Lock()\n\t\t\t\tvar qdb = versions[tx.ID()]\n\t\t\t\tif writable {\n\t\t\t\t\tqdb = versions[tx.ID()-1].Copy()\n\t\t\t\t}\n\t\t\t\tmutex.Unlock()\n\n\t\t\t\t// Make sure we commit/rollback the tx at the end and update the state.\n\t\t\t\tif writable {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tmutex.Lock()\n\t\t\t\t\t\tversions[tx.ID()] = qdb\n\t\t\t\t\t\tmutex.Unlock()\n\n\t\t\t\t\t\tif err := tx.Commit(); err != nil {\n\t\t\t\t\t\t\terrCh <- err\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t} else {\n\t\t\t\t\tdefer func() { _ = tx.Rollback() }()\n\t\t\t\t}\n\n\t\t\t\t// Ignore operation if we don't have data yet.\n\t\t\t\tif qdb == nil {\n\t\t\t\t\tatomic.AddInt64(&igCount, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Execute handler.\n\t\t\t\thandler(tx, qdb)\n\n\t\t\t\t// Release a thread back to the scheduling loop.\n\t\t\t\t<-threads\n\t\t\t}(writable, handler)\n\n\t\t\ti++\n\t\t\tif i >= threadCount {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Wait until all threads are done.\n\t\twg.Wait()\n\t\tt.Logf(\"transactions:%d ignored:%d\", opCount, igCount)\n\t\tclose(errCh)\n\t\tfor err := range errCh {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error from inside goroutine: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tdb.MustClose()\n\t\t// I have doubts the DB drop is indented here (as 'versions' is not being reset).\n\t\t// But I'm preserving for now the original behavior.\n\t\tdb.MustDeleteFile()\n\t\tdb.MustReopen()\n\t}\n\n}\n\ntype simulateHandler func(tx *bolt.Tx, qdb *QuickDB)\n\n// Retrieves a key from the database and verifies that it is what is expected.\nfunc simulateGetHandler(tx *bolt.Tx, qdb *QuickDB) {\n\t// Randomly retrieve an existing exist.\n\tkeys := qdb.Rand()\n\tif len(keys) == 0 {\n\t\treturn\n\t}\n\n\t// Retrieve root bucket.\n\tb := tx.Bucket(keys[0])\n\tif b == nil {\n\t\tpanic(fmt.Sprintf(\"bucket[0] expected: %08x\\n\", trunc(keys[0], 4)))\n\t}\n\n\t// Drill into nested buckets.\n\tfor _, key := range keys[1 : len(keys)-1] {\n\t\tb = b.Bucket(key)\n\t\tif b == nil {\n\t\t\tpanic(fmt.Sprintf(\"bucket[n] expected: %v -> %v\\n\", keys, key))\n\t\t}\n\t}\n\n\t// Verify key/value on the final bucket.\n\texpected := qdb.Get(keys)\n\tactual := b.Get(keys[len(keys)-1])\n\tif !bytes.Equal(actual, expected) {\n\t\tfmt.Println(\"=== EXPECTED ===\")\n\t\tfmt.Println(expected)\n\t\tfmt.Println(\"=== ACTUAL ===\")\n\t\tfmt.Println(actual)\n\t\tfmt.Println(\"=== END ===\")\n\t\tpanic(\"value mismatch\")\n\t}\n}\n\n// Inserts a key into the database.\nfunc simulatePutHandler(tx *bolt.Tx, qdb *QuickDB) {\n\tvar err error\n\tkeys, value := randKeys(), randValue()\n\n\t// Retrieve root bucket.\n\tb := tx.Bucket(keys[0])\n\tif b == nil {\n\t\tb, err = tx.CreateBucket(keys[0])\n\t\tif err != nil {\n\t\t\tpanic(\"create bucket: \" + err.Error())\n\t\t}\n\t}\n\n\t// Create nested buckets, if necessary.\n\tfor _, key := range keys[1 : len(keys)-1] {\n\t\tchild := b.Bucket(key)\n\t\tif child != nil {\n\t\t\tb = child\n\t\t} else {\n\t\t\tb, err = b.CreateBucket(key)\n\t\t\tif err != nil {\n\t\t\t\tpanic(\"create bucket: \" + err.Error())\n\t\t\t}\n\t\t}\n\t}\n\n\t// Insert into database.\n\tif err := b.Put(keys[len(keys)-1], value); err != nil {\n\t\tpanic(\"put: \" + err.Error())\n\t}\n\n\t// Insert into in-memory database.\n\tqdb.Put(keys, value)\n}\n\n// QuickDB is an in-memory database that replicates the functionality of the\n// Bolt DB type except that it is entirely in-memory. It is meant for testing\n// that the Bolt database is consistent.\ntype QuickDB struct {\n\tsync.RWMutex\n\tm map[string]interface{}\n}\n\n// NewQuickDB returns an instance of QuickDB.\nfunc NewQuickDB() *QuickDB {\n\treturn &QuickDB{m: make(map[string]interface{})}\n}\n\n// Get retrieves the value at a key path.\nfunc (db *QuickDB) Get(keys [][]byte) []byte {\n\tdb.RLock()\n\tdefer db.RUnlock()\n\n\tm := db.m\n\tfor _, key := range keys[:len(keys)-1] {\n\t\tvalue := m[string(key)]\n\t\tif value == nil {\n\t\t\treturn nil\n\t\t}\n\t\tswitch value := value.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tm = value\n\t\tcase []byte:\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Only return if it's a simple value.\n\tif value, ok := m[string(keys[len(keys)-1])].([]byte); ok {\n\t\treturn value\n\t}\n\treturn nil\n}\n\n// Put inserts a value into a key path.\nfunc (db *QuickDB) Put(keys [][]byte, value []byte) {\n\tdb.Lock()\n\tdefer db.Unlock()\n\n\t// Build buckets all the way down the key path.\n\tm := db.m\n\tfor _, key := range keys[:len(keys)-1] {\n\t\tif _, ok := m[string(key)].([]byte); ok {\n\t\t\treturn // Keypath intersects with a simple value. Do nothing.\n\t\t}\n\n\t\tif m[string(key)] == nil {\n\t\t\tm[string(key)] = make(map[string]interface{})\n\t\t}\n\t\tm = m[string(key)].(map[string]interface{})\n\t}\n\n\t// Insert value into the last key.\n\tm[string(keys[len(keys)-1])] = value\n}\n\n// Rand returns a random key path that points to a simple value.\nfunc (db *QuickDB) Rand() [][]byte {\n\tdb.RLock()\n\tdefer db.RUnlock()\n\tif len(db.m) == 0 {\n\t\treturn nil\n\t}\n\tvar keys [][]byte\n\tdb.rand(db.m, &keys)\n\treturn keys\n}\n\nfunc (db *QuickDB) rand(m map[string]interface{}, keys *[][]byte) {\n\ti, index := 0, rand.Intn(len(m))\n\tfor k, v := range m {\n\t\tif i == index {\n\t\t\t*keys = append(*keys, []byte(k))\n\t\t\tif v, ok := v.(map[string]interface{}); ok {\n\t\t\t\tdb.rand(v, keys)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti++\n\t}\n\tpanic(\"quickdb rand: out-of-range\")\n}\n\n// Copy copies the entire database.\nfunc (db *QuickDB) Copy() *QuickDB {\n\tdb.RLock()\n\tdefer db.RUnlock()\n\treturn &QuickDB{m: db.copy(db.m)}\n}\n\nfunc (db *QuickDB) copy(m map[string]interface{}) map[string]interface{} {\n\tclone := make(map[string]interface{}, len(m))\n\tfor k, v := range m {\n\t\tswitch v := v.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tclone[k] = db.copy(v)\n\t\tdefault:\n\t\t\tclone[k] = v\n\t\t}\n\t}\n\treturn clone\n}\n\nfunc randKey() []byte {\n\tvar min, max = 1, 1024\n\tn := rand.Intn(max-min) + min\n\tb := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = byte(rand.Intn(255))\n\t}\n\treturn b\n}\n\nfunc randKeys() [][]byte {\n\tvar keys [][]byte\n\tvar count = rand.Intn(2) + 2\n\tfor i := 0; i < count; i++ {\n\t\tkeys = append(keys, randKey())\n\t}\n\treturn keys\n}\n\nfunc randValue() []byte {\n\tn := rand.Intn(8192)\n\tb := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = byte(rand.Intn(255))\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tx.go",
          "type": "blob",
          "size": 24.3125,
          "content": "package bbolt\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unsafe\"\n\n\tberrors \"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// Tx represents a read-only or read/write transaction on the database.\n// Read-only transactions can be used for retrieving values for keys and creating cursors.\n// Read/write transactions can create and remove buckets and create and remove keys.\n//\n// IMPORTANT: You must commit or rollback transactions when you are done with\n// them. Pages can not be reclaimed by the writer until no more transactions\n// are using them. A long running read transaction can cause the database to\n// quickly grow.\ntype Tx struct {\n\twritable       bool\n\tmanaged        bool\n\tdb             *DB\n\tmeta           *common.Meta\n\troot           Bucket\n\tpages          map[common.Pgid]*common.Page\n\tstats          TxStats\n\tcommitHandlers []func()\n\n\t// WriteFlag specifies the flag for write-related methods like WriteTo().\n\t// Tx opens the database file with the specified flag to copy the data.\n\t//\n\t// By default, the flag is unset, which works well for mostly in-memory\n\t// workloads. For databases that are much larger than available RAM,\n\t// set the flag to syscall.O_DIRECT to avoid trashing the page cache.\n\tWriteFlag int\n}\n\n// init initializes the transaction.\nfunc (tx *Tx) init(db *DB) {\n\ttx.db = db\n\ttx.pages = nil\n\n\t// Copy the meta page since it can be changed by the writer.\n\ttx.meta = &common.Meta{}\n\tdb.meta().Copy(tx.meta)\n\n\t// Copy over the root bucket.\n\ttx.root = newBucket(tx)\n\ttx.root.InBucket = &common.InBucket{}\n\t*tx.root.InBucket = *(tx.meta.RootBucket())\n\n\t// Increment the transaction id and add a page cache for writable transactions.\n\tif tx.writable {\n\t\ttx.pages = make(map[common.Pgid]*common.Page)\n\t\ttx.meta.IncTxid()\n\t}\n}\n\n// ID returns the transaction id.\nfunc (tx *Tx) ID() int {\n\tif tx == nil || tx.meta == nil {\n\t\treturn -1\n\t}\n\treturn int(tx.meta.Txid())\n}\n\n// DB returns a reference to the database that created the transaction.\nfunc (tx *Tx) DB() *DB {\n\treturn tx.db\n}\n\n// Size returns current database size in bytes as seen by this transaction.\nfunc (tx *Tx) Size() int64 {\n\treturn int64(tx.meta.Pgid()) * int64(tx.db.pageSize)\n}\n\n// Writable returns whether the transaction can perform write operations.\nfunc (tx *Tx) Writable() bool {\n\treturn tx.writable\n}\n\n// Cursor creates a cursor associated with the root bucket.\n// All items in the cursor will return a nil value because all root bucket keys point to buckets.\n// The cursor is only valid as long as the transaction is open.\n// Do not use a cursor after the transaction is closed.\nfunc (tx *Tx) Cursor() *Cursor {\n\treturn tx.root.Cursor()\n}\n\n// Stats retrieves a copy of the current transaction statistics.\nfunc (tx *Tx) Stats() TxStats {\n\treturn tx.stats\n}\n\n// Inspect returns the structure of the database.\nfunc (tx *Tx) Inspect() BucketStructure {\n\treturn tx.root.Inspect()\n}\n\n// Bucket retrieves a bucket by name.\n// Returns nil if the bucket does not exist.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (tx *Tx) Bucket(name []byte) *Bucket {\n\treturn tx.root.Bucket(name)\n}\n\n// CreateBucket creates a new bucket.\n// Returns an error if the bucket already exists, if the bucket name is blank, or if the bucket name is too long.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (tx *Tx) CreateBucket(name []byte) (*Bucket, error) {\n\treturn tx.root.CreateBucket(name)\n}\n\n// CreateBucketIfNotExists creates a new bucket if it doesn't already exist.\n// Returns an error if the bucket name is blank, or if the bucket name is too long.\n// The bucket instance is only valid for the lifetime of the transaction.\nfunc (tx *Tx) CreateBucketIfNotExists(name []byte) (*Bucket, error) {\n\treturn tx.root.CreateBucketIfNotExists(name)\n}\n\n// DeleteBucket deletes a bucket.\n// Returns an error if the bucket cannot be found or if the key represents a non-bucket value.\nfunc (tx *Tx) DeleteBucket(name []byte) error {\n\treturn tx.root.DeleteBucket(name)\n}\n\n// MoveBucket moves a sub-bucket from the source bucket to the destination bucket.\n// Returns an error if\n//  1. the sub-bucket cannot be found in the source bucket;\n//  2. or the key already exists in the destination bucket;\n//  3. the key represents a non-bucket value.\n//\n// If src is nil, it means moving a top level bucket into the target bucket.\n// If dst is nil, it means converting the child bucket into a top level bucket.\nfunc (tx *Tx) MoveBucket(child []byte, src *Bucket, dst *Bucket) error {\n\tif src == nil {\n\t\tsrc = &tx.root\n\t}\n\tif dst == nil {\n\t\tdst = &tx.root\n\t}\n\treturn src.MoveBucket(child, dst)\n}\n\n// ForEach executes a function for each bucket in the root.\n// If the provided function returns an error then the iteration is stopped and\n// the error is returned to the caller.\nfunc (tx *Tx) ForEach(fn func(name []byte, b *Bucket) error) error {\n\treturn tx.root.ForEach(func(k, v []byte) error {\n\t\treturn fn(k, tx.root.Bucket(k))\n\t})\n}\n\n// OnCommit adds a handler function to be executed after the transaction successfully commits.\nfunc (tx *Tx) OnCommit(fn func()) {\n\ttx.commitHandlers = append(tx.commitHandlers, fn)\n}\n\n// Commit writes all changes to disk, updates the meta page and closes the transaction.\n// Returns an error if a disk write error occurs, or if Commit is\n// called on a read-only transaction.\nfunc (tx *Tx) Commit() (err error) {\n\ttxId := tx.ID()\n\tlg := tx.db.Logger()\n\tif lg != discardLogger {\n\t\tlg.Debugf(\"Committing transaction %d\", txId)\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlg.Errorf(\"Committing transaction failed: %v\", err)\n\t\t\t} else {\n\t\t\t\tlg.Debugf(\"Committing transaction %d successfully\", txId)\n\t\t\t}\n\t\t}()\n\t}\n\n\tcommon.Assert(!tx.managed, \"managed tx commit not allowed\")\n\tif tx.db == nil {\n\t\treturn berrors.ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn berrors.ErrTxNotWritable\n\t}\n\n\t// TODO(benbjohnson): Use vectorized I/O to write out dirty pages.\n\n\t// Rebalance nodes which have had deletions.\n\tvar startTime = time.Now()\n\ttx.root.rebalance()\n\tif tx.stats.GetRebalance() > 0 {\n\t\ttx.stats.IncRebalanceTime(time.Since(startTime))\n\t}\n\n\topgid := tx.meta.Pgid()\n\n\t// spill data onto dirty pages.\n\tstartTime = time.Now()\n\tif err = tx.root.spill(); err != nil {\n\t\tlg.Errorf(\"spilling data onto dirty pages failed: %v\", err)\n\t\ttx.rollback()\n\t\treturn err\n\t}\n\ttx.stats.IncSpillTime(time.Since(startTime))\n\n\t// Free the old root bucket.\n\ttx.meta.RootBucket().SetRootPage(tx.root.RootPage())\n\n\t// Free the old freelist because commit writes out a fresh freelist.\n\tif tx.meta.Freelist() != common.PgidNoFreelist {\n\t\ttx.db.freelist.Free(tx.meta.Txid(), tx.db.page(tx.meta.Freelist()))\n\t}\n\n\tif !tx.db.NoFreelistSync {\n\t\terr = tx.commitFreelist()\n\t\tif err != nil {\n\t\t\tlg.Errorf(\"committing freelist failed: %v\", err)\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\ttx.meta.SetFreelist(common.PgidNoFreelist)\n\t}\n\n\t// If the high water mark has moved up then attempt to grow the database.\n\tif tx.meta.Pgid() > opgid {\n\t\t_ = errors.New(\"\")\n\t\t// gofail: var lackOfDiskSpace string\n\t\t// tx.rollback()\n\t\t// return errors.New(lackOfDiskSpace)\n\t\tif err = tx.db.grow(int(tx.meta.Pgid()+1) * tx.db.pageSize); err != nil {\n\t\t\tlg.Errorf(\"growing db size failed, pgid: %d, pagesize: %d, error: %v\", tx.meta.Pgid(), tx.db.pageSize, err)\n\t\t\ttx.rollback()\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write dirty pages to disk.\n\tstartTime = time.Now()\n\tif err = tx.write(); err != nil {\n\t\tlg.Errorf(\"writing data failed: %v\", err)\n\t\ttx.rollback()\n\t\treturn err\n\t}\n\n\t// If strict mode is enabled then perform a consistency check.\n\tif tx.db.StrictMode {\n\t\tch := tx.Check()\n\t\tvar errs []string\n\t\tfor {\n\t\t\tchkErr, ok := <-ch\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terrs = append(errs, chkErr.Error())\n\t\t}\n\t\tif len(errs) > 0 {\n\t\t\tpanic(\"check fail: \" + strings.Join(errs, \"\\n\"))\n\t\t}\n\t}\n\n\t// Write meta to disk.\n\tif err = tx.writeMeta(); err != nil {\n\t\tlg.Errorf(\"writeMeta failed: %v\", err)\n\t\ttx.rollback()\n\t\treturn err\n\t}\n\ttx.stats.IncWriteTime(time.Since(startTime))\n\n\t// Finalize the transaction.\n\ttx.close()\n\n\t// Execute commit handlers now that the locks have been removed.\n\tfor _, fn := range tx.commitHandlers {\n\t\tfn()\n\t}\n\n\treturn nil\n}\n\nfunc (tx *Tx) commitFreelist() error {\n\t// Allocate new pages for the new free list. This will overestimate\n\t// the size of the freelist but not underestimate the size (which would be bad).\n\tp, err := tx.allocate((tx.db.freelist.EstimatedWritePageSize() / tx.db.pageSize) + 1)\n\tif err != nil {\n\t\ttx.rollback()\n\t\treturn err\n\t}\n\n\ttx.db.freelist.Write(p)\n\ttx.meta.SetFreelist(p.Id())\n\n\treturn nil\n}\n\n// Rollback closes the transaction and ignores all previous updates. Read-only\n// transactions must be rolled back and not committed.\nfunc (tx *Tx) Rollback() error {\n\tcommon.Assert(!tx.managed, \"managed tx rollback not allowed\")\n\tif tx.db == nil {\n\t\treturn berrors.ErrTxClosed\n\t}\n\ttx.nonPhysicalRollback()\n\treturn nil\n}\n\n// nonPhysicalRollback is called when user calls Rollback directly, in this case we do not need to reload the free pages from disk.\nfunc (tx *Tx) nonPhysicalRollback() {\n\tif tx.db == nil {\n\t\treturn\n\t}\n\tif tx.writable {\n\t\ttx.db.freelist.Rollback(tx.meta.Txid())\n\t}\n\ttx.close()\n}\n\n// rollback needs to reload the free pages from disk in case some system error happens like fsync error.\nfunc (tx *Tx) rollback() {\n\tif tx.db == nil {\n\t\treturn\n\t}\n\tif tx.writable {\n\t\ttx.db.freelist.Rollback(tx.meta.Txid())\n\t\t// When mmap fails, the `data`, `dataref` and `datasz` may be reset to\n\t\t// zero values, and there is no way to reload free page IDs in this case.\n\t\tif tx.db.data != nil {\n\t\t\tif !tx.db.hasSyncedFreelist() {\n\t\t\t\t// Reconstruct free page list by scanning the DB to get the whole free page list.\n\t\t\t\t// Note: scanning the whole db is heavy if your db size is large in NoSyncFreeList mode.\n\t\t\t\ttx.db.freelist.NoSyncReload(tx.db.freepages())\n\t\t\t} else {\n\t\t\t\t// Read free page list from freelist page.\n\t\t\t\ttx.db.freelist.Reload(tx.db.page(tx.db.meta().Freelist()))\n\t\t\t}\n\t\t}\n\t}\n\ttx.close()\n}\n\nfunc (tx *Tx) close() {\n\tif tx.db == nil {\n\t\treturn\n\t}\n\tif tx.writable {\n\t\t// Grab freelist stats.\n\t\tvar freelistFreeN = tx.db.freelist.FreeCount()\n\t\tvar freelistPendingN = tx.db.freelist.PendingCount()\n\t\tvar freelistAlloc = tx.db.freelist.EstimatedWritePageSize()\n\n\t\t// Remove transaction ref & writer lock.\n\t\ttx.db.rwtx = nil\n\t\ttx.db.rwlock.Unlock()\n\n\t\t// Merge statistics.\n\t\ttx.db.statlock.Lock()\n\t\ttx.db.stats.FreePageN = freelistFreeN\n\t\ttx.db.stats.PendingPageN = freelistPendingN\n\t\ttx.db.stats.FreeAlloc = (freelistFreeN + freelistPendingN) * tx.db.pageSize\n\t\ttx.db.stats.FreelistInuse = freelistAlloc\n\t\ttx.db.stats.TxStats.add(&tx.stats)\n\t\ttx.db.statlock.Unlock()\n\t} else {\n\t\ttx.db.removeTx(tx)\n\t}\n\n\t// Clear all references.\n\ttx.db = nil\n\ttx.meta = nil\n\ttx.root = Bucket{tx: tx}\n\ttx.pages = nil\n}\n\n// Copy writes the entire database to a writer.\n// This function exists for backwards compatibility.\n//\n// Deprecated: Use WriteTo() instead.\nfunc (tx *Tx) Copy(w io.Writer) error {\n\t_, err := tx.WriteTo(w)\n\treturn err\n}\n\n// WriteTo writes the entire database to a writer.\n// If err == nil then exactly tx.Size() bytes will be written into the writer.\nfunc (tx *Tx) WriteTo(w io.Writer) (n int64, err error) {\n\t// Attempt to open reader with WriteFlag\n\tf, err := tx.db.openFile(tx.db.path, os.O_RDONLY|tx.WriteFlag, 0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer func() {\n\t\tif cerr := f.Close(); err == nil {\n\t\t\terr = cerr\n\t\t}\n\t}()\n\n\t// Generate a meta page. We use the same page data for both meta pages.\n\tbuf := make([]byte, tx.db.pageSize)\n\tpage := (*common.Page)(unsafe.Pointer(&buf[0]))\n\tpage.SetFlags(common.MetaPageFlag)\n\t*page.Meta() = *tx.meta\n\n\t// Write meta 0.\n\tpage.SetId(0)\n\tpage.Meta().SetChecksum(page.Meta().Sum64())\n\tnn, err := w.Write(buf)\n\tn += int64(nn)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"meta 0 copy: %s\", err)\n\t}\n\n\t// Write meta 1 with a lower transaction id.\n\tpage.SetId(1)\n\tpage.Meta().DecTxid()\n\tpage.Meta().SetChecksum(page.Meta().Sum64())\n\tnn, err = w.Write(buf)\n\tn += int64(nn)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"meta 1 copy: %s\", err)\n\t}\n\n\t// Move past the meta pages in the file.\n\tif _, err := f.Seek(int64(tx.db.pageSize*2), io.SeekStart); err != nil {\n\t\treturn n, fmt.Errorf(\"seek: %s\", err)\n\t}\n\n\t// Copy data pages.\n\twn, err := io.CopyN(w, f, tx.Size()-int64(tx.db.pageSize*2))\n\tn += wn\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\treturn n, nil\n}\n\n// CopyFile copies the entire database to file at the given path.\n// A reader transaction is maintained during the copy so it is safe to continue\n// using the database while a copy is in progress.\nfunc (tx *Tx) CopyFile(path string, mode os.FileMode) error {\n\tf, err := tx.db.openFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = tx.WriteTo(f)\n\tif err != nil {\n\t\t_ = f.Close()\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\n// allocate returns a contiguous block of memory starting at a given page.\nfunc (tx *Tx) allocate(count int) (*common.Page, error) {\n\tlg := tx.db.Logger()\n\tp, err := tx.db.allocate(tx.meta.Txid(), count)\n\tif err != nil {\n\t\tlg.Errorf(\"allocating failed, txid: %d, count: %d, error: %v\", tx.meta.Txid(), count, err)\n\t\treturn nil, err\n\t}\n\n\t// Save to our page cache.\n\ttx.pages[p.Id()] = p\n\n\t// Update statistics.\n\ttx.stats.IncPageCount(int64(count))\n\ttx.stats.IncPageAlloc(int64(count * tx.db.pageSize))\n\n\treturn p, nil\n}\n\n// write writes any dirty pages to disk.\nfunc (tx *Tx) write() error {\n\t// Sort pages by id.\n\tlg := tx.db.Logger()\n\tpages := make(common.Pages, 0, len(tx.pages))\n\tfor _, p := range tx.pages {\n\t\tpages = append(pages, p)\n\t}\n\t// Clear out page cache early.\n\ttx.pages = make(map[common.Pgid]*common.Page)\n\tsort.Sort(pages)\n\n\t// Write pages to disk in order.\n\tfor _, p := range pages {\n\t\trem := (uint64(p.Overflow()) + 1) * uint64(tx.db.pageSize)\n\t\toffset := int64(p.Id()) * int64(tx.db.pageSize)\n\t\tvar written uintptr\n\n\t\t// Write out page in \"max allocation\" sized chunks.\n\t\tfor {\n\t\t\tsz := rem\n\t\t\tif sz > maxAllocSize-1 {\n\t\t\t\tsz = maxAllocSize - 1\n\t\t\t}\n\t\t\tbuf := common.UnsafeByteSlice(unsafe.Pointer(p), written, 0, int(sz))\n\n\t\t\tif _, err := tx.db.ops.writeAt(buf, offset); err != nil {\n\t\t\t\tlg.Errorf(\"writeAt failed, offset: %d: %w\", offset, err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Update statistics.\n\t\t\ttx.stats.IncWrite(1)\n\n\t\t\t// Exit inner for loop if we've written all the chunks.\n\t\t\trem -= sz\n\t\t\tif rem == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Otherwise move offset forward and move pointer to next chunk.\n\t\t\toffset += int64(sz)\n\t\t\twritten += uintptr(sz)\n\t\t}\n\t}\n\n\t// Ignore file sync if flag is set on DB.\n\tif !tx.db.NoSync || common.IgnoreNoSync {\n\t\t// gofail: var beforeSyncDataPages struct{}\n\t\tif err := fdatasync(tx.db); err != nil {\n\t\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] fdatasync failed: %w\", runtime.GOOS, runtime.GOARCH, err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Put small pages back to page pool.\n\tfor _, p := range pages {\n\t\t// Ignore page sizes over 1 page.\n\t\t// These are allocated using make() instead of the page pool.\n\t\tif int(p.Overflow()) != 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tbuf := common.UnsafeByteSlice(unsafe.Pointer(p), 0, 0, tx.db.pageSize)\n\n\t\t// See https://go.googlesource.com/go/+/f03c9202c43e0abb130669852082117ca50aa9b1\n\t\tfor i := range buf {\n\t\t\tbuf[i] = 0\n\t\t}\n\t\ttx.db.pagePool.Put(buf) //nolint:staticcheck\n\t}\n\n\treturn nil\n}\n\n// writeMeta writes the meta to the disk.\nfunc (tx *Tx) writeMeta() error {\n\t// gofail: var beforeWriteMetaError string\n\t// return errors.New(beforeWriteMetaError)\n\n\t// Create a temporary buffer for the meta page.\n\tlg := tx.db.Logger()\n\tbuf := make([]byte, tx.db.pageSize)\n\tp := tx.db.pageInBuffer(buf, 0)\n\ttx.meta.Write(p)\n\n\t// Write the meta page to file.\n\tif _, err := tx.db.ops.writeAt(buf, int64(p.Id())*int64(tx.db.pageSize)); err != nil {\n\t\tlg.Errorf(\"writeAt failed, pgid: %d, pageSize: %d, error: %v\", p.Id(), tx.db.pageSize, err)\n\t\treturn err\n\t}\n\tif !tx.db.NoSync || common.IgnoreNoSync {\n\t\t// gofail: var beforeSyncMetaPage struct{}\n\t\tif err := fdatasync(tx.db); err != nil {\n\t\t\tlg.Errorf(\"[GOOS: %s, GOARCH: %s] fdatasync failed: %w\", runtime.GOOS, runtime.GOARCH, err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Update statistics.\n\ttx.stats.IncWrite(1)\n\n\treturn nil\n}\n\n// page returns a reference to the page with a given id.\n// If page has been written to then a temporary buffered page is returned.\nfunc (tx *Tx) page(id common.Pgid) *common.Page {\n\t// Check the dirty pages first.\n\tif tx.pages != nil {\n\t\tif p, ok := tx.pages[id]; ok {\n\t\t\tp.FastCheck(id)\n\t\t\treturn p\n\t\t}\n\t}\n\n\t// Otherwise return directly from the mmap.\n\tp := tx.db.page(id)\n\tp.FastCheck(id)\n\treturn p\n}\n\n// forEachPage iterates over every page within a given page and executes a function.\nfunc (tx *Tx) forEachPage(pgidnum common.Pgid, fn func(*common.Page, int, []common.Pgid)) {\n\tstack := make([]common.Pgid, 10)\n\tstack[0] = pgidnum\n\ttx.forEachPageInternal(stack[:1], fn)\n}\n\nfunc (tx *Tx) forEachPageInternal(pgidstack []common.Pgid, fn func(*common.Page, int, []common.Pgid)) {\n\tp := tx.page(pgidstack[len(pgidstack)-1])\n\n\t// Execute function.\n\tfn(p, len(pgidstack)-1, pgidstack)\n\n\t// Recursively loop over children.\n\tif p.IsBranchPage() {\n\t\tfor i := 0; i < int(p.Count()); i++ {\n\t\t\telem := p.BranchPageElement(uint16(i))\n\t\t\ttx.forEachPageInternal(append(pgidstack, elem.Pgid()), fn)\n\t\t}\n\t}\n}\n\n// Page returns page information for a given page number.\n// This is only safe for concurrent use when used by a writable transaction.\nfunc (tx *Tx) Page(id int) (*common.PageInfo, error) {\n\tif tx.db == nil {\n\t\treturn nil, berrors.ErrTxClosed\n\t} else if common.Pgid(id) >= tx.meta.Pgid() {\n\t\treturn nil, nil\n\t}\n\n\tif tx.db.freelist == nil {\n\t\treturn nil, berrors.ErrFreePagesNotLoaded\n\t}\n\n\t// Build the page info.\n\tp := tx.db.page(common.Pgid(id))\n\tinfo := &common.PageInfo{\n\t\tID:            id,\n\t\tCount:         int(p.Count()),\n\t\tOverflowCount: int(p.Overflow()),\n\t}\n\n\t// Determine the type (or if it's free).\n\tif tx.db.freelist.Freed(common.Pgid(id)) {\n\t\tinfo.Type = \"free\"\n\t} else {\n\t\tinfo.Type = p.Typ()\n\t}\n\n\treturn info, nil\n}\n\n// TxStats represents statistics about the actions performed by the transaction.\ntype TxStats struct {\n\t// Page statistics.\n\t//\n\t// DEPRECATED: Use GetPageCount() or IncPageCount()\n\tPageCount int64 // number of page allocations\n\t// DEPRECATED: Use GetPageAlloc() or IncPageAlloc()\n\tPageAlloc int64 // total bytes allocated\n\n\t// Cursor statistics.\n\t//\n\t// DEPRECATED: Use GetCursorCount() or IncCursorCount()\n\tCursorCount int64 // number of cursors created\n\n\t// Node statistics\n\t//\n\t// DEPRECATED: Use GetNodeCount() or IncNodeCount()\n\tNodeCount int64 // number of node allocations\n\t// DEPRECATED: Use GetNodeDeref() or IncNodeDeref()\n\tNodeDeref int64 // number of node dereferences\n\n\t// Rebalance statistics.\n\t//\n\t// DEPRECATED: Use GetRebalance() or IncRebalance()\n\tRebalance int64 // number of node rebalances\n\t// DEPRECATED: Use GetRebalanceTime() or IncRebalanceTime()\n\tRebalanceTime time.Duration // total time spent rebalancing\n\n\t// Split/Spill statistics.\n\t//\n\t// DEPRECATED: Use GetSplit() or IncSplit()\n\tSplit int64 // number of nodes split\n\t// DEPRECATED: Use GetSpill() or IncSpill()\n\tSpill int64 // number of nodes spilled\n\t// DEPRECATED: Use GetSpillTime() or IncSpillTime()\n\tSpillTime time.Duration // total time spent spilling\n\n\t// Write statistics.\n\t//\n\t// DEPRECATED: Use GetWrite() or IncWrite()\n\tWrite int64 // number of writes performed\n\t// DEPRECATED: Use GetWriteTime() or IncWriteTime()\n\tWriteTime time.Duration // total time spent writing to disk\n}\n\nfunc (s *TxStats) add(other *TxStats) {\n\ts.IncPageCount(other.GetPageCount())\n\ts.IncPageAlloc(other.GetPageAlloc())\n\ts.IncCursorCount(other.GetCursorCount())\n\ts.IncNodeCount(other.GetNodeCount())\n\ts.IncNodeDeref(other.GetNodeDeref())\n\ts.IncRebalance(other.GetRebalance())\n\ts.IncRebalanceTime(other.GetRebalanceTime())\n\ts.IncSplit(other.GetSplit())\n\ts.IncSpill(other.GetSpill())\n\ts.IncSpillTime(other.GetSpillTime())\n\ts.IncWrite(other.GetWrite())\n\ts.IncWriteTime(other.GetWriteTime())\n}\n\n// Sub calculates and returns the difference between two sets of transaction stats.\n// This is useful when obtaining stats at two different points and time and\n// you need the performance counters that occurred within that time span.\nfunc (s *TxStats) Sub(other *TxStats) TxStats {\n\tvar diff TxStats\n\tdiff.PageCount = s.GetPageCount() - other.GetPageCount()\n\tdiff.PageAlloc = s.GetPageAlloc() - other.GetPageAlloc()\n\tdiff.CursorCount = s.GetCursorCount() - other.GetCursorCount()\n\tdiff.NodeCount = s.GetNodeCount() - other.GetNodeCount()\n\tdiff.NodeDeref = s.GetNodeDeref() - other.GetNodeDeref()\n\tdiff.Rebalance = s.GetRebalance() - other.GetRebalance()\n\tdiff.RebalanceTime = s.GetRebalanceTime() - other.GetRebalanceTime()\n\tdiff.Split = s.GetSplit() - other.GetSplit()\n\tdiff.Spill = s.GetSpill() - other.GetSpill()\n\tdiff.SpillTime = s.GetSpillTime() - other.GetSpillTime()\n\tdiff.Write = s.GetWrite() - other.GetWrite()\n\tdiff.WriteTime = s.GetWriteTime() - other.GetWriteTime()\n\treturn diff\n}\n\n// GetPageCount returns PageCount atomically.\nfunc (s *TxStats) GetPageCount() int64 {\n\treturn atomic.LoadInt64(&s.PageCount)\n}\n\n// IncPageCount increases PageCount atomically and returns the new value.\nfunc (s *TxStats) IncPageCount(delta int64) int64 {\n\treturn atomic.AddInt64(&s.PageCount, delta)\n}\n\n// GetPageAlloc returns PageAlloc atomically.\nfunc (s *TxStats) GetPageAlloc() int64 {\n\treturn atomic.LoadInt64(&s.PageAlloc)\n}\n\n// IncPageAlloc increases PageAlloc atomically and returns the new value.\nfunc (s *TxStats) IncPageAlloc(delta int64) int64 {\n\treturn atomic.AddInt64(&s.PageAlloc, delta)\n}\n\n// GetCursorCount returns CursorCount atomically.\nfunc (s *TxStats) GetCursorCount() int64 {\n\treturn atomic.LoadInt64(&s.CursorCount)\n}\n\n// IncCursorCount increases CursorCount atomically and return the new value.\nfunc (s *TxStats) IncCursorCount(delta int64) int64 {\n\treturn atomic.AddInt64(&s.CursorCount, delta)\n}\n\n// GetNodeCount returns NodeCount atomically.\nfunc (s *TxStats) GetNodeCount() int64 {\n\treturn atomic.LoadInt64(&s.NodeCount)\n}\n\n// IncNodeCount increases NodeCount atomically and returns the new value.\nfunc (s *TxStats) IncNodeCount(delta int64) int64 {\n\treturn atomic.AddInt64(&s.NodeCount, delta)\n}\n\n// GetNodeDeref returns NodeDeref atomically.\nfunc (s *TxStats) GetNodeDeref() int64 {\n\treturn atomic.LoadInt64(&s.NodeDeref)\n}\n\n// IncNodeDeref increases NodeDeref atomically and returns the new value.\nfunc (s *TxStats) IncNodeDeref(delta int64) int64 {\n\treturn atomic.AddInt64(&s.NodeDeref, delta)\n}\n\n// GetRebalance returns Rebalance atomically.\nfunc (s *TxStats) GetRebalance() int64 {\n\treturn atomic.LoadInt64(&s.Rebalance)\n}\n\n// IncRebalance increases Rebalance atomically and returns the new value.\nfunc (s *TxStats) IncRebalance(delta int64) int64 {\n\treturn atomic.AddInt64(&s.Rebalance, delta)\n}\n\n// GetRebalanceTime returns RebalanceTime atomically.\nfunc (s *TxStats) GetRebalanceTime() time.Duration {\n\treturn atomicLoadDuration(&s.RebalanceTime)\n}\n\n// IncRebalanceTime increases RebalanceTime atomically and returns the new value.\nfunc (s *TxStats) IncRebalanceTime(delta time.Duration) time.Duration {\n\treturn atomicAddDuration(&s.RebalanceTime, delta)\n}\n\n// GetSplit returns Split atomically.\nfunc (s *TxStats) GetSplit() int64 {\n\treturn atomic.LoadInt64(&s.Split)\n}\n\n// IncSplit increases Split atomically and returns the new value.\nfunc (s *TxStats) IncSplit(delta int64) int64 {\n\treturn atomic.AddInt64(&s.Split, delta)\n}\n\n// GetSpill returns Spill atomically.\nfunc (s *TxStats) GetSpill() int64 {\n\treturn atomic.LoadInt64(&s.Spill)\n}\n\n// IncSpill increases Spill atomically and returns the new value.\nfunc (s *TxStats) IncSpill(delta int64) int64 {\n\treturn atomic.AddInt64(&s.Spill, delta)\n}\n\n// GetSpillTime returns SpillTime atomically.\nfunc (s *TxStats) GetSpillTime() time.Duration {\n\treturn atomicLoadDuration(&s.SpillTime)\n}\n\n// IncSpillTime increases SpillTime atomically and returns the new value.\nfunc (s *TxStats) IncSpillTime(delta time.Duration) time.Duration {\n\treturn atomicAddDuration(&s.SpillTime, delta)\n}\n\n// GetWrite returns Write atomically.\nfunc (s *TxStats) GetWrite() int64 {\n\treturn atomic.LoadInt64(&s.Write)\n}\n\n// IncWrite increases Write atomically and returns the new value.\nfunc (s *TxStats) IncWrite(delta int64) int64 {\n\treturn atomic.AddInt64(&s.Write, delta)\n}\n\n// GetWriteTime returns WriteTime atomically.\nfunc (s *TxStats) GetWriteTime() time.Duration {\n\treturn atomicLoadDuration(&s.WriteTime)\n}\n\n// IncWriteTime increases WriteTime atomically and returns the new value.\nfunc (s *TxStats) IncWriteTime(delta time.Duration) time.Duration {\n\treturn atomicAddDuration(&s.WriteTime, delta)\n}\n\nfunc atomicAddDuration(ptr *time.Duration, du time.Duration) time.Duration {\n\treturn time.Duration(atomic.AddInt64((*int64)(unsafe.Pointer(ptr)), int64(du)))\n}\n\nfunc atomicLoadDuration(ptr *time.Duration) time.Duration {\n\treturn time.Duration(atomic.LoadInt64((*int64)(unsafe.Pointer(ptr))))\n}\n"
        },
        {
          "name": "tx_check.go",
          "type": "blob",
          "size": 10.0458984375,
          "content": "package bbolt\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// Check performs several consistency checks on the database for this transaction.\n// An error is returned if any inconsistency is found.\n//\n// It can be safely run concurrently on a writable transaction. However, this\n// incurs a high cost for large databases and databases with a lot of subbuckets\n// because of caching. This overhead can be removed if running on a read-only\n// transaction, however, it is not safe to execute other writer transactions at\n// the same time.\n//\n// It also allows users to provide a customized `KVStringer` implementation,\n// so that bolt can generate human-readable diagnostic messages.\nfunc (tx *Tx) Check(options ...CheckOption) <-chan error {\n\tchkConfig := checkConfig{\n\t\tkvStringer: HexKVStringer(),\n\t}\n\tfor _, op := range options {\n\t\top(&chkConfig)\n\t}\n\n\tch := make(chan error)\n\tgo func() {\n\t\t// Close the channel to signal completion.\n\t\tdefer close(ch)\n\t\ttx.check(chkConfig, ch)\n\t}()\n\treturn ch\n}\n\nfunc (tx *Tx) check(cfg checkConfig, ch chan error) {\n\t// Force loading free list if opened in ReadOnly mode.\n\ttx.db.loadFreelist()\n\n\t// Check if any pages are double freed.\n\tfreed := make(map[common.Pgid]bool)\n\tall := make([]common.Pgid, tx.db.freelist.Count())\n\ttx.db.freelist.Copyall(all)\n\tfor _, id := range all {\n\t\tif freed[id] {\n\t\t\tch <- fmt.Errorf(\"page %d: already freed\", id)\n\t\t}\n\t\tfreed[id] = true\n\t}\n\n\t// Track every reachable page.\n\treachable := make(map[common.Pgid]*common.Page)\n\treachable[0] = tx.page(0) // meta0\n\treachable[1] = tx.page(1) // meta1\n\tif tx.meta.Freelist() != common.PgidNoFreelist {\n\t\tfor i := uint32(0); i <= tx.page(tx.meta.Freelist()).Overflow(); i++ {\n\t\t\treachable[tx.meta.Freelist()+common.Pgid(i)] = tx.page(tx.meta.Freelist())\n\t\t}\n\t}\n\n\tif cfg.pageId == 0 {\n\t\t// Check the whole db file, starting from the root bucket and\n\t\t// recursively check all child buckets.\n\t\ttx.recursivelyCheckBucket(&tx.root, reachable, freed, cfg.kvStringer, ch)\n\n\t\t// Ensure all pages below high water mark are either reachable or freed.\n\t\tfor i := common.Pgid(0); i < tx.meta.Pgid(); i++ {\n\t\t\t_, isReachable := reachable[i]\n\t\t\tif !isReachable && !freed[i] {\n\t\t\t\tch <- fmt.Errorf(\"page %d: unreachable unfreed\", int(i))\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Check the db file starting from a specified pageId.\n\t\tif cfg.pageId < 2 || cfg.pageId >= uint64(tx.meta.Pgid()) {\n\t\t\tch <- fmt.Errorf(\"page ID (%d) out of range [%d, %d)\", cfg.pageId, 2, tx.meta.Pgid())\n\t\t\treturn\n\t\t}\n\n\t\ttx.recursivelyCheckPage(common.Pgid(cfg.pageId), reachable, freed, cfg.kvStringer, ch)\n\t}\n}\n\nfunc (tx *Tx) recursivelyCheckPage(pageId common.Pgid, reachable map[common.Pgid]*common.Page, freed map[common.Pgid]bool,\n\tkvStringer KVStringer, ch chan error) {\n\ttx.checkInvariantProperties(pageId, reachable, freed, kvStringer, ch)\n\ttx.recursivelyCheckBucketInPage(pageId, reachable, freed, kvStringer, ch)\n}\n\nfunc (tx *Tx) recursivelyCheckBucketInPage(pageId common.Pgid, reachable map[common.Pgid]*common.Page, freed map[common.Pgid]bool,\n\tkvStringer KVStringer, ch chan error) {\n\tp := tx.page(pageId)\n\n\tswitch {\n\tcase p.IsBranchPage():\n\t\tfor i := range p.BranchPageElements() {\n\t\t\telem := p.BranchPageElement(uint16(i))\n\t\t\ttx.recursivelyCheckBucketInPage(elem.Pgid(), reachable, freed, kvStringer, ch)\n\t\t}\n\tcase p.IsLeafPage():\n\t\tfor i := range p.LeafPageElements() {\n\t\t\telem := p.LeafPageElement(uint16(i))\n\t\t\tif elem.IsBucketEntry() {\n\t\t\t\tinBkt := common.NewInBucket(pageId, 0)\n\t\t\t\ttmpBucket := Bucket{\n\t\t\t\t\tInBucket:    &inBkt,\n\t\t\t\t\trootNode:    &node{isLeaf: p.IsLeafPage()},\n\t\t\t\t\tFillPercent: DefaultFillPercent,\n\t\t\t\t\ttx:          tx,\n\t\t\t\t}\n\t\t\t\tif child := tmpBucket.Bucket(elem.Key()); child != nil {\n\t\t\t\t\ttx.recursivelyCheckBucket(child, reachable, freed, kvStringer, ch)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tch <- fmt.Errorf(\"unexpected page type (flags: %x) for pgId:%d\", p.Flags(), pageId)\n\t}\n}\n\nfunc (tx *Tx) recursivelyCheckBucket(b *Bucket, reachable map[common.Pgid]*common.Page, freed map[common.Pgid]bool,\n\tkvStringer KVStringer, ch chan error) {\n\t// Ignore inline buckets.\n\tif b.RootPage() == 0 {\n\t\treturn\n\t}\n\n\ttx.checkInvariantProperties(b.RootPage(), reachable, freed, kvStringer, ch)\n\n\t// Check each bucket within this bucket.\n\t_ = b.ForEachBucket(func(k []byte) error {\n\t\tif child := b.Bucket(k); child != nil {\n\t\t\ttx.recursivelyCheckBucket(child, reachable, freed, kvStringer, ch)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (tx *Tx) checkInvariantProperties(pageId common.Pgid, reachable map[common.Pgid]*common.Page, freed map[common.Pgid]bool,\n\tkvStringer KVStringer, ch chan error) {\n\ttx.forEachPage(pageId, func(p *common.Page, _ int, stack []common.Pgid) {\n\t\tverifyPageReachable(p, tx.meta.Pgid(), stack, reachable, freed, ch)\n\t})\n\n\ttx.recursivelyCheckPageKeyOrder(pageId, kvStringer.KeyToString, ch)\n}\n\nfunc verifyPageReachable(p *common.Page, hwm common.Pgid, stack []common.Pgid, reachable map[common.Pgid]*common.Page, freed map[common.Pgid]bool, ch chan error) {\n\tif p.Id() > hwm {\n\t\tch <- fmt.Errorf(\"page %d: out of bounds: %d (stack: %v)\", int(p.Id()), int(hwm), stack)\n\t}\n\n\t// Ensure each page is only referenced once.\n\tfor i := common.Pgid(0); i <= common.Pgid(p.Overflow()); i++ {\n\t\tvar id = p.Id() + i\n\t\tif _, ok := reachable[id]; ok {\n\t\t\tch <- fmt.Errorf(\"page %d: multiple references (stack: %v)\", int(id), stack)\n\t\t}\n\t\treachable[id] = p\n\t}\n\n\t// We should only encounter un-freed leaf and branch pages.\n\tif freed[p.Id()] {\n\t\tch <- fmt.Errorf(\"page %d: reachable freed\", int(p.Id()))\n\t} else if !p.IsBranchPage() && !p.IsLeafPage() {\n\t\tch <- fmt.Errorf(\"page %d: invalid type: %s (stack: %v)\", int(p.Id()), p.Typ(), stack)\n\t}\n}\n\n// recursivelyCheckPageKeyOrder verifies database consistency with respect to b-tree\n// key order constraints:\n//   - keys on pages must be sorted\n//   - keys on children pages are between 2 consecutive keys on the parent's branch page).\nfunc (tx *Tx) recursivelyCheckPageKeyOrder(pgId common.Pgid, keyToString func([]byte) string, ch chan error) {\n\ttx.recursivelyCheckPageKeyOrderInternal(pgId, nil, nil, nil, keyToString, ch)\n}\n\n// recursivelyCheckPageKeyOrderInternal verifies that all keys in the subtree rooted at `pgid` are:\n//   - >=`minKeyClosed` (can be nil)\n//   - <`maxKeyOpen` (can be nil)\n//   - Are in right ordering relationship to their parents.\n//     `pagesStack` is expected to contain IDs of pages from the tree root to `pgid` for the clean debugging message.\nfunc (tx *Tx) recursivelyCheckPageKeyOrderInternal(\n\tpgId common.Pgid, minKeyClosed, maxKeyOpen []byte, pagesStack []common.Pgid,\n\tkeyToString func([]byte) string, ch chan error) (maxKeyInSubtree []byte) {\n\n\tp := tx.page(pgId)\n\tpagesStack = append(pagesStack, pgId)\n\tswitch {\n\tcase p.IsBranchPage():\n\t\t// For branch page we navigate ranges of all subpages.\n\t\trunningMin := minKeyClosed\n\t\tfor i := range p.BranchPageElements() {\n\t\t\telem := p.BranchPageElement(uint16(i))\n\t\t\tverifyKeyOrder(elem.Pgid(), \"branch\", i, elem.Key(), runningMin, maxKeyOpen, ch, keyToString, pagesStack)\n\n\t\t\tmaxKey := maxKeyOpen\n\t\t\tif i < len(p.BranchPageElements())-1 {\n\t\t\t\tmaxKey = p.BranchPageElement(uint16(i + 1)).Key()\n\t\t\t}\n\t\t\tmaxKeyInSubtree = tx.recursivelyCheckPageKeyOrderInternal(elem.Pgid(), elem.Key(), maxKey, pagesStack, keyToString, ch)\n\t\t\trunningMin = maxKeyInSubtree\n\t\t}\n\t\treturn maxKeyInSubtree\n\tcase p.IsLeafPage():\n\t\trunningMin := minKeyClosed\n\t\tfor i := range p.LeafPageElements() {\n\t\t\telem := p.LeafPageElement(uint16(i))\n\t\t\tverifyKeyOrder(pgId, \"leaf\", i, elem.Key(), runningMin, maxKeyOpen, ch, keyToString, pagesStack)\n\t\t\trunningMin = elem.Key()\n\t\t}\n\t\tif p.Count() > 0 {\n\t\t\treturn p.LeafPageElement(p.Count() - 1).Key()\n\t\t}\n\tdefault:\n\t\tch <- fmt.Errorf(\"unexpected page type (flags: %x) for pgId:%d\", p.Flags(), pgId)\n\t}\n\treturn maxKeyInSubtree\n}\n\n/***\n * verifyKeyOrder checks whether an entry with given #index on pgId (pageType: \"branch|leaf\") that has given \"key\",\n * is within range determined by (previousKey..maxKeyOpen) and reports found violations to the channel (ch).\n */\nfunc verifyKeyOrder(pgId common.Pgid, pageType string, index int, key []byte, previousKey []byte, maxKeyOpen []byte, ch chan error, keyToString func([]byte) string, pagesStack []common.Pgid) {\n\tif index == 0 && previousKey != nil && compareKeys(previousKey, key) > 0 {\n\t\tch <- fmt.Errorf(\"the first key[%d]=(hex)%s on %s page(%d) needs to be >= the key in the ancestor (%s). Stack: %v\",\n\t\t\tindex, keyToString(key), pageType, pgId, keyToString(previousKey), pagesStack)\n\t}\n\tif index > 0 {\n\t\tcmpRet := compareKeys(previousKey, key)\n\t\tif cmpRet > 0 {\n\t\t\tch <- fmt.Errorf(\"key[%d]=(hex)%s on %s page(%d) needs to be > (found <) than previous element (hex)%s. Stack: %v\",\n\t\t\t\tindex, keyToString(key), pageType, pgId, keyToString(previousKey), pagesStack)\n\t\t}\n\t\tif cmpRet == 0 {\n\t\t\tch <- fmt.Errorf(\"key[%d]=(hex)%s on %s page(%d) needs to be > (found =) than previous element (hex)%s. Stack: %v\",\n\t\t\t\tindex, keyToString(key), pageType, pgId, keyToString(previousKey), pagesStack)\n\t\t}\n\t}\n\tif maxKeyOpen != nil && compareKeys(key, maxKeyOpen) >= 0 {\n\t\tch <- fmt.Errorf(\"key[%d]=(hex)%s on %s page(%d) needs to be < than key of the next element in ancestor (hex)%s. Pages stack: %v\",\n\t\t\tindex, keyToString(key), pageType, pgId, keyToString(previousKey), pagesStack)\n\t}\n}\n\n// ===========================================================================================\n\ntype checkConfig struct {\n\tkvStringer KVStringer\n\tpageId     uint64\n}\n\ntype CheckOption func(options *checkConfig)\n\nfunc WithKVStringer(kvStringer KVStringer) CheckOption {\n\treturn func(c *checkConfig) {\n\t\tc.kvStringer = kvStringer\n\t}\n}\n\n// WithPageId sets a page ID from which the check command starts to check\nfunc WithPageId(pageId uint64) CheckOption {\n\treturn func(c *checkConfig) {\n\t\tc.pageId = pageId\n\t}\n}\n\n// KVStringer allows to prepare human-readable diagnostic messages.\ntype KVStringer interface {\n\tKeyToString([]byte) string\n\tValueToString([]byte) string\n}\n\n// HexKVStringer serializes both key & value to hex representation.\nfunc HexKVStringer() KVStringer {\n\treturn hexKvStringer{}\n}\n\ntype hexKvStringer struct{}\n\nfunc (_ hexKvStringer) KeyToString(key []byte) string {\n\treturn hex.EncodeToString(key)\n}\n\nfunc (_ hexKvStringer) ValueToString(value []byte) string {\n\treturn hex.EncodeToString(value)\n}\n"
        },
        {
          "name": "tx_check_test.go",
          "type": "blob",
          "size": 4.720703125,
          "content": "package bbolt_test\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n\t\"go.etcd.io/bbolt/internal/common\"\n\t\"go.etcd.io/bbolt/internal/guts_cli\"\n)\n\nfunc TestTx_Check_CorruptPage(t *testing.T) {\n\tbucketName := []byte(\"data\")\n\n\tt.Log(\"Creating db file.\")\n\tdb := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\n\t// Each page can hold roughly 20 key/values pair, so 100 such\n\t// key/value pairs will consume about 5 leaf pages.\n\terr := db.Fill(bucketName, 1, 100,\n\t\tfunc(tx int, k int) []byte { return []byte(fmt.Sprintf(\"%04d\", k)) },\n\t\tfunc(tx int, k int) []byte { return make([]byte, 100) },\n\t)\n\trequire.NoError(t, err)\n\n\tt.Log(\"Corrupting a random leaf page.\")\n\tvictimPageId, validPageIds := corruptRandomLeafPageInBucket(t, db.DB, bucketName)\n\n\tt.Log(\"Running consistency check.\")\n\tvErr := db.View(func(tx *bbolt.Tx) error {\n\t\tvar cErrs []error\n\n\t\tt.Log(\"Check corrupted page.\")\n\t\terrChan := tx.Check(bbolt.WithPageId(uint64(victimPageId)))\n\t\tfor cErr := range errChan {\n\t\t\tcErrs = append(cErrs, cErr)\n\t\t}\n\t\trequire.Greater(t, len(cErrs), 0)\n\n\t\tt.Log(\"Check valid pages.\")\n\t\tcErrs = cErrs[:0]\n\t\tfor _, pgId := range validPageIds {\n\t\t\terrChan = tx.Check(bbolt.WithPageId(uint64(pgId)))\n\t\t\tfor cErr := range errChan {\n\t\t\t\tcErrs = append(cErrs, cErr)\n\t\t\t}\n\t\t\trequire.Equal(t, 0, len(cErrs))\n\t\t}\n\t\treturn nil\n\t})\n\trequire.NoError(t, vErr)\n\tt.Log(\"All check passed\")\n\n\t// Manually close the db, otherwise the PostTestCleanup will\n\t// check the db again and accordingly fail the test.\n\tdb.MustClose()\n}\n\nfunc TestTx_Check_WithNestBucket(t *testing.T) {\n\tparentBucketName := []byte(\"parentBucket\")\n\n\tt.Log(\"Creating db file.\")\n\tdb := btesting.MustCreateDBWithOption(t, &bbolt.Options{PageSize: 4096})\n\n\terr := db.Update(func(tx *bbolt.Tx) error {\n\t\tpb, bErr := tx.CreateBucket(parentBucketName)\n\t\tif bErr != nil {\n\t\t\treturn bErr\n\t\t}\n\n\t\tt.Log(\"put some key/values under the parent bucket directly\")\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tk, v := fmt.Sprintf(\"%04d\", i), fmt.Sprintf(\"value_%4d\", i)\n\t\t\tif pErr := pb.Put([]byte(k), []byte(v)); pErr != nil {\n\t\t\t\treturn pErr\n\t\t\t}\n\t\t}\n\n\t\tt.Log(\"create a nested bucket and put some key/values under the nested bucket\")\n\t\tcb, bErr := pb.CreateBucket([]byte(\"nestedBucket\"))\n\t\tif bErr != nil {\n\t\t\treturn bErr\n\t\t}\n\n\t\tfor i := 0; i < 2000; i++ {\n\t\t\tk, v := fmt.Sprintf(\"%04d\", i), fmt.Sprintf(\"value_%4d\", i)\n\t\t\tif pErr := cb.Put([]byte(k), []byte(v)); pErr != nil {\n\t\t\t\treturn pErr\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\trequire.NoError(t, err)\n\n\t// Get the bucket's root page.\n\tbucketRootPageId := mustGetBucketRootPage(t, db.DB, parentBucketName)\n\n\tt.Logf(\"Running consistency check starting from pageId: %d\", bucketRootPageId)\n\tvErr := db.View(func(tx *bbolt.Tx) error {\n\t\tvar cErrs []error\n\n\t\terrChan := tx.Check(bbolt.WithPageId(uint64(bucketRootPageId)))\n\t\tfor cErr := range errChan {\n\t\t\tcErrs = append(cErrs, cErr)\n\t\t}\n\t\trequire.Equal(t, 0, len(cErrs))\n\n\t\treturn nil\n\t})\n\trequire.NoError(t, vErr)\n\tt.Log(\"All check passed\")\n\n\t// Manually close the db, otherwise the PostTestCleanup will\n\t// check the db again and accordingly fail the test.\n\tdb.MustClose()\n}\n\n// corruptRandomLeafPage corrupts one random leaf page.\nfunc corruptRandomLeafPageInBucket(t testing.TB, db *bbolt.DB, bucketName []byte) (victimPageId common.Pgid, validPageIds []common.Pgid) {\n\tbucketRootPageId := mustGetBucketRootPage(t, db, bucketName)\n\tbucketRootPage, _, err := guts_cli.ReadPage(db.Path(), uint64(bucketRootPageId))\n\trequire.NoError(t, err)\n\trequire.True(t, bucketRootPage.IsBranchPage())\n\n\t// Retrieve all the leaf pages included in the branch page, and pick up random one from them.\n\tvar bucketPageIds []common.Pgid\n\tfor _, bpe := range bucketRootPage.BranchPageElements() {\n\t\tbucketPageIds = append(bucketPageIds, bpe.Pgid())\n\t}\n\trandomIdx := rand.Intn(len(bucketPageIds))\n\tvictimPageId = bucketPageIds[randomIdx]\n\tvalidPageIds = append(bucketPageIds[:randomIdx], bucketPageIds[randomIdx+1:]...)\n\n\tvictimPage, victimBuf, err := guts_cli.ReadPage(db.Path(), uint64(victimPageId))\n\trequire.NoError(t, err)\n\trequire.True(t, victimPage.IsLeafPage())\n\trequire.True(t, victimPage.Count() > 1)\n\n\t// intentionally make the second key < the first key.\n\telement := victimPage.LeafPageElement(1)\n\tkey := element.Key()\n\tkey[0] = 0\n\n\t// Write the corrupt page to db file.\n\terr = guts_cli.WritePage(db.Path(), victimBuf)\n\trequire.NoError(t, err)\n\treturn victimPageId, validPageIds\n}\n\n// mustGetBucketRootPage returns the root page for the provided bucket.\nfunc mustGetBucketRootPage(t testing.TB, db *bbolt.DB, bucketName []byte) common.Pgid {\n\tvar rootPageId common.Pgid\n\t_ = db.View(func(tx *bbolt.Tx) error {\n\t\tb := tx.Bucket(bucketName)\n\t\trequire.NotNil(t, b)\n\t\trootPageId = b.RootPage()\n\t\treturn nil\n\t})\n\n\treturn rootPageId\n}\n"
        },
        {
          "name": "tx_stats_test.go",
          "type": "blob",
          "size": 1.427734375,
          "content": "package bbolt\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTxStats_add(t *testing.T) {\n\tstatsA := TxStats{\n\t\tPageCount:     1,\n\t\tPageAlloc:     2,\n\t\tCursorCount:   3,\n\t\tNodeCount:     100,\n\t\tNodeDeref:     101,\n\t\tRebalance:     1000,\n\t\tRebalanceTime: 1001 * time.Second,\n\t\tSplit:         10000,\n\t\tSpill:         10001,\n\t\tSpillTime:     10001 * time.Second,\n\t\tWrite:         100000,\n\t\tWriteTime:     100001 * time.Second,\n\t}\n\n\tstatsB := TxStats{\n\t\tPageCount:     2,\n\t\tPageAlloc:     3,\n\t\tCursorCount:   4,\n\t\tNodeCount:     101,\n\t\tNodeDeref:     102,\n\t\tRebalance:     1001,\n\t\tRebalanceTime: 1002 * time.Second,\n\t\tSplit:         11001,\n\t\tSpill:         11002,\n\t\tSpillTime:     11002 * time.Second,\n\t\tWrite:         110001,\n\t\tWriteTime:     110010 * time.Second,\n\t}\n\n\tstatsB.add(&statsA)\n\tassert.Equal(t, int64(3), statsB.GetPageCount())\n\tassert.Equal(t, int64(5), statsB.GetPageAlloc())\n\tassert.Equal(t, int64(7), statsB.GetCursorCount())\n\tassert.Equal(t, int64(201), statsB.GetNodeCount())\n\tassert.Equal(t, int64(203), statsB.GetNodeDeref())\n\tassert.Equal(t, int64(2001), statsB.GetRebalance())\n\tassert.Equal(t, 2003*time.Second, statsB.GetRebalanceTime())\n\tassert.Equal(t, int64(21001), statsB.GetSplit())\n\tassert.Equal(t, int64(21003), statsB.GetSpill())\n\tassert.Equal(t, 21003*time.Second, statsB.GetSpillTime())\n\tassert.Equal(t, int64(210001), statsB.GetWrite())\n\tassert.Equal(t, 210011*time.Second, statsB.GetWriteTime())\n}\n"
        },
        {
          "name": "tx_test.go",
          "type": "blob",
          "size": 25.4541015625,
          "content": "package bbolt_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\tberrors \"go.etcd.io/bbolt/errors\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\n// TestTx_Check_ReadOnly tests consistency checking on a ReadOnly database.\nfunc TestTx_Check_ReadOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treadOnlyDB, err := bolt.Open(db.Path(), 0600, &bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer readOnlyDB.Close()\n\n\ttx, err := readOnlyDB.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// ReadOnly DB will load freelist on Check call.\n\tnumChecks := 2\n\terrc := make(chan error, numChecks)\n\tcheck := func() {\n\t\terrc <- <-tx.Check()\n\t}\n\t// Ensure the freelist is not reloaded and does not race.\n\tfor i := 0; i < numChecks; i++ {\n\t\tgo check()\n\t}\n\tfor i := 0; i < numChecks; i++ {\n\t\tif err := <-errc; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\t// Close the view transaction\n\terr = tx.Rollback()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that committing a closed transaction returns an error.\nfunc TestTx_Commit_ErrTxClosed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := tx.CreateBucket([]byte(\"foo\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Commit(); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that rolling back a closed transaction returns an error.\nfunc TestTx_Rollback_ErrTxClosed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Rollback(); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that committing a read-only transaction returns an error.\nfunc TestTx_Commit_ErrTxNotWritable(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Commit(); err != berrors.ErrTxNotWritable {\n\t\tt.Fatal(err)\n\t}\n\t// Close the view transaction\n\terr = tx.Rollback()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a transaction can retrieve a cursor on the root bucket.\nfunc TestTx_Cursor(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif _, err := tx.CreateBucket([]byte(\"woojits\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tc := tx.Cursor()\n\t\tif k, v := c.First(); !bytes.Equal(k, []byte(\"widgets\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\n\t\tif k, v := c.Next(); !bytes.Equal(k, []byte(\"woojits\")) {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\n\t\tif k, v := c.Next(); k != nil {\n\t\t\tt.Fatalf(\"unexpected key: %v\", k)\n\t\t} else if v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %v\", k)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that creating a bucket with a read-only transaction returns an error.\nfunc TestTx_CreateBucket_ErrTxNotWritable(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"foo\"))\n\t\tif err != berrors.ErrTxNotWritable {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that creating a bucket on a closed transaction returns an error.\nfunc TestTx_CreateBucket_ErrTxClosed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := tx.CreateBucket([]byte(\"foo\")); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that a Tx can retrieve a bucket.\nfunc TestTx_Bucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a Tx retrieving a non-existent key returns nil.\nfunc TestTx_Get_NotFound(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b.Get([]byte(\"no_such_key\")) != nil {\n\t\t\tt.Fatal(\"expected nil value\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can be created and retrieved.\nfunc TestTx_CreateBucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Create a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if b == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read the bucket through a separate transaction.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can be created if it doesn't already exist.\nfunc TestTx_CreateBucketIfNotExists(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create bucket.\n\t\tif b, err := tx.CreateBucketIfNotExists([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if b == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\n\t\t// Create bucket again.\n\t\tif b, err := tx.CreateBucketIfNotExists([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if b == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read the bucket through a separate transaction.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif tx.Bucket([]byte(\"widgets\")) == nil {\n\t\t\tt.Fatal(\"expected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure transaction returns an error if creating an unnamed bucket.\nfunc TestTx_CreateBucketIfNotExists_ErrBucketNameRequired(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucketIfNotExists([]byte{}); err != berrors.ErrBucketNameRequired {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\n\t\tif _, err := tx.CreateBucketIfNotExists(nil); err != berrors.ErrBucketNameRequired {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket cannot be created twice.\nfunc TestTx_CreateBucket_ErrBucketExists(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Create a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create the same bucket again.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != berrors.ErrBucketExists {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket is created with a non-blank name.\nfunc TestTx_CreateBucket_ErrBucketNameRequired(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif _, err := tx.CreateBucket(nil); err != berrors.ErrBucketNameRequired {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that a bucket can be deleted.\nfunc TestTx_DeleteBucket(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\t// Create a bucket and add a value.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Delete the bucket and make sure we can't get the value.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif err := tx.DeleteBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tx.Bucket([]byte(\"widgets\")) != nil {\n\t\t\tt.Fatal(\"unexpected bucket\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t// Create the bucket again and make sure there's not a phantom value.\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v := b.Get([]byte(\"foo\")); v != nil {\n\t\t\tt.Fatalf(\"unexpected phantom value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that deleting a bucket on a closed transaction returns an error.\nfunc TestTx_DeleteBucket_ErrTxClosed(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.DeleteBucket([]byte(\"foo\")); err != berrors.ErrTxClosed {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n}\n\n// Ensure that deleting a bucket with a read-only transaction returns an error.\nfunc TestTx_DeleteBucket_ReadOnly(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tif err := tx.DeleteBucket([]byte(\"foo\")); err != berrors.ErrTxNotWritable {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that nothing happens when deleting a bucket that doesn't exist.\nfunc TestTx_DeleteBucket_NotFound(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tif err := tx.DeleteBucket([]byte(\"widgets\")); err != berrors.ErrBucketNotFound {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that no error is returned when a tx.ForEach function does not return\n// an error.\nfunc TestTx_ForEach_NoError(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := tx.ForEach(func(name []byte, b *bolt.Bucket) error {\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that an error is returned when a tx.ForEach function returns an error.\nfunc TestTx_ForEach_WithError(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tmarker := errors.New(\"marker\")\n\t\tif err := tx.ForEach(func(name []byte, b *bolt.Bucket) error {\n\t\t\treturn marker\n\t\t}); err != marker {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Ensure that Tx commit handlers are called after a transaction successfully commits.\nfunc TestTx_OnCommit(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar x int\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\ttx.OnCommit(func() { x += 1 })\n\t\ttx.OnCommit(func() { x += 2 })\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t} else if x != 3 {\n\t\tt.Fatalf(\"unexpected x: %d\", x)\n\t}\n}\n\n// Ensure that Tx commit handlers are NOT called after a transaction rolls back.\nfunc TestTx_OnCommit_Rollback(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tvar x int\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\ttx.OnCommit(func() { x += 1 })\n\t\ttx.OnCommit(func() { x += 2 })\n\t\tif _, err := tx.CreateBucket([]byte(\"widgets\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn errors.New(\"rollback this commit\")\n\t}); err == nil || err.Error() != \"rollback this commit\" {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t} else if x != 0 {\n\t\tt.Fatalf(\"unexpected x: %d\", x)\n\t}\n}\n\n// Ensure that the database can be copied to a file path.\nfunc TestTx_CopyFile(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\n\tpath := tempfile()\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn tx.CopyFile(path, 0600)\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb2, err := bolt.Open(path, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db2.View(func(tx *bolt.Tx) error {\n\t\tif v := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\")); !bytes.Equal(v, []byte(\"bar\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\tif v := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"baz\")); !bytes.Equal(v, []byte(\"bat\")) {\n\t\t\tt.Fatalf(\"unexpected value: %v\", v)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db2.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype failWriterError struct{}\n\nfunc (failWriterError) Error() string {\n\treturn \"error injected for tests\"\n}\n\ntype failWriter struct {\n\t// fail after this many bytes\n\tAfter int\n}\n\nfunc (f *failWriter) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\tif n > f.After {\n\t\tn = f.After\n\t\terr = failWriterError{}\n\t}\n\tf.After -= n\n\treturn n, err\n}\n\n// Ensure that Copy handles write errors right.\nfunc TestTx_CopyFile_Error_Meta(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn tx.Copy(&failWriter{})\n\t}); err == nil || err.Error() != \"meta 0 copy: error injected for tests\" {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\n// Ensure that Copy handles write errors right.\nfunc TestTx_CopyFile_Error_Normal(t *testing.T) {\n\tdb := btesting.MustCreateDB(t)\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := b.Put([]byte(\"baz\"), []byte(\"bat\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn tx.Copy(&failWriter{3 * db.Info().PageSize})\n\t}); err == nil || err.Error() != \"error injected for tests\" {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\n// TestTx_Rollback ensures there is no error when tx rollback whether we sync freelist or not.\nfunc TestTx_Rollback(t *testing.T) {\n\tfor _, isSyncFreelist := range []bool{false, true} {\n\t\t// Open the database.\n\t\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer os.Remove(db.Path())\n\t\tdb.NoFreelistSync = isSyncFreelist\n\n\t\ttx, err := db.Begin(true)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error starting tx: %v\", err)\n\t\t}\n\t\tbucket := []byte(\"mybucket\")\n\t\tif _, err := tx.CreateBucket(bucket); err != nil {\n\t\t\tt.Fatalf(\"Error creating bucket: %v\", err)\n\t\t}\n\t\tif err := tx.Commit(); err != nil {\n\t\t\tt.Fatalf(\"Error on commit: %v\", err)\n\t\t}\n\n\t\ttx, err = db.Begin(true)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error starting tx: %v\", err)\n\t\t}\n\t\tb := tx.Bucket(bucket)\n\t\tif err := b.Put([]byte(\"k\"), []byte(\"v\")); err != nil {\n\t\t\tt.Fatalf(\"Error on put: %v\", err)\n\t\t}\n\t\t// Imagine there is an error and tx needs to be rolled-back\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tt.Fatalf(\"Error on rollback: %v\", err)\n\t\t}\n\n\t\ttx, err = db.Begin(false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error starting tx: %v\", err)\n\t\t}\n\t\tb = tx.Bucket(bucket)\n\t\tif v := b.Get([]byte(\"k\")); v != nil {\n\t\t\tt.Fatalf(\"Value for k should not have been stored\")\n\t\t}\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tt.Fatalf(\"Error on rollback: %v\", err)\n\t\t}\n\n\t}\n}\n\n// TestTx_releaseRange ensures db.freePages handles page releases\n// correctly when there are transaction that are no longer reachable\n// via any read/write transactions and are \"between\" ongoing read\n// transactions, which requires they must be freed by\n// freelist.releaseRange.\nfunc TestTx_releaseRange(t *testing.T) {\n\t// Set initial mmap size well beyond the limit we will hit in this\n\t// test, since we are testing with long running read transactions\n\t// and will deadlock if db.grow is triggered.\n\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{InitialMmapSize: os.Getpagesize() * 100})\n\n\tbucket := \"bucket\"\n\n\tput := func(key, value string) {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(bucket))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn b.Put([]byte(key), []byte(value))\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tdel := func(key string) {\n\t\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(bucket))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn b.Delete([]byte(key))\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tgetWithTxn := func(txn *bolt.Tx, key string) []byte {\n\t\treturn txn.Bucket([]byte(bucket)).Get([]byte(key))\n\t}\n\n\topenReadTxn := func() *bolt.Tx {\n\t\treadTx, err := db.Begin(false)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn readTx\n\t}\n\n\tcheckWithReadTxn := func(txn *bolt.Tx, key string, wantValue []byte) {\n\t\tvalue := getWithTxn(txn, key)\n\t\tif !bytes.Equal(value, wantValue) {\n\t\t\tt.Errorf(\"Wanted value to be %s for key %s, but got %s\", wantValue, key, string(value))\n\t\t}\n\t}\n\n\trollback := func(txn *bolt.Tx) {\n\t\tif err := txn.Rollback(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tput(\"k1\", \"v1\")\n\trtx1 := openReadTxn()\n\tput(\"k2\", \"v2\")\n\thold1 := openReadTxn()\n\tput(\"k3\", \"v3\")\n\thold2 := openReadTxn()\n\tdel(\"k3\")\n\trtx2 := openReadTxn()\n\tdel(\"k1\")\n\thold3 := openReadTxn()\n\tdel(\"k2\")\n\thold4 := openReadTxn()\n\tput(\"k4\", \"v4\")\n\thold5 := openReadTxn()\n\n\t// Close the read transactions we established to hold a portion of the pages in pending state.\n\trollback(hold1)\n\trollback(hold2)\n\trollback(hold3)\n\trollback(hold4)\n\trollback(hold5)\n\n\t// Execute a write transaction to trigger a releaseRange operation in the db\n\t// that will free multiple ranges between the remaining open read transactions, now that the\n\t// holds have been rolled back.\n\tput(\"k4\", \"v4\")\n\n\t// Check that all long running reads still read correct values.\n\tcheckWithReadTxn(rtx1, \"k1\", []byte(\"v1\"))\n\tcheckWithReadTxn(rtx2, \"k2\", []byte(\"v2\"))\n\trollback(rtx1)\n\trollback(rtx2)\n\n\t// Check that the final state is correct.\n\trtx7 := openReadTxn()\n\tcheckWithReadTxn(rtx7, \"k1\", nil)\n\tcheckWithReadTxn(rtx7, \"k2\", nil)\n\tcheckWithReadTxn(rtx7, \"k3\", nil)\n\tcheckWithReadTxn(rtx7, \"k4\", []byte(\"v4\"))\n\trollback(rtx7)\n}\n\nfunc ExampleTx_Rollback() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Create a bucket.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\treturn err\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Set a value for a key.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\treturn tx.Bucket([]byte(\"widgets\")).Put([]byte(\"foo\"), []byte(\"bar\"))\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Update the key but rollback the transaction so it never saves.\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tb := tx.Bucket([]byte(\"widgets\"))\n\tif err := b.Put([]byte(\"foo\"), []byte(\"baz\")); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := tx.Rollback(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Ensure that our original value is still set.\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tfmt.Printf(\"The value for 'foo' is still: %s\\n\", value)\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// The value for 'foo' is still: bar\n}\n\nfunc ExampleTx_CopyFile() {\n\t// Open the database.\n\tdb, err := bolt.Open(tempfile(), 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(db.Path())\n\n\t// Create a bucket and a key.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(\"widgets\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.Put([]byte(\"foo\"), []byte(\"bar\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Copy the database to another file.\n\ttoFile := tempfile()\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn tx.CopyFile(toFile, 0666)\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(toFile)\n\n\t// Open the cloned database.\n\tdb2, err := bolt.Open(toFile, 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Ensure that the key exists in the copy.\n\tif err := db2.View(func(tx *bolt.Tx) error {\n\t\tvalue := tx.Bucket([]byte(\"widgets\")).Get([]byte(\"foo\"))\n\t\tfmt.Printf(\"The value for 'foo' in the clone is: %s\\n\", value)\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Close database to release file lock.\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := db2.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// The value for 'foo' in the clone is: bar\n}\n\nfunc TestTxStats_GetAndIncAtomically(t *testing.T) {\n\tvar stats bolt.TxStats\n\n\tstats.IncPageCount(1)\n\tassert.Equal(t, int64(1), stats.GetPageCount())\n\n\tstats.IncPageAlloc(2)\n\tassert.Equal(t, int64(2), stats.GetPageAlloc())\n\n\tstats.IncCursorCount(3)\n\tassert.Equal(t, int64(3), stats.GetCursorCount())\n\n\tstats.IncNodeCount(100)\n\tassert.Equal(t, int64(100), stats.GetNodeCount())\n\n\tstats.IncNodeDeref(101)\n\tassert.Equal(t, int64(101), stats.GetNodeDeref())\n\n\tstats.IncRebalance(1000)\n\tassert.Equal(t, int64(1000), stats.GetRebalance())\n\n\tstats.IncRebalanceTime(1001 * time.Second)\n\tassert.Equal(t, 1001*time.Second, stats.GetRebalanceTime())\n\n\tstats.IncSplit(10000)\n\tassert.Equal(t, int64(10000), stats.GetSplit())\n\n\tstats.IncSpill(10001)\n\tassert.Equal(t, int64(10001), stats.GetSpill())\n\n\tstats.IncSpillTime(10001 * time.Second)\n\tassert.Equal(t, 10001*time.Second, stats.GetSpillTime())\n\n\tstats.IncWrite(100000)\n\tassert.Equal(t, int64(100000), stats.GetWrite())\n\n\tstats.IncWriteTime(100001 * time.Second)\n\tassert.Equal(t, 100001*time.Second, stats.GetWriteTime())\n\n\tassert.Equal(t,\n\t\tbolt.TxStats{\n\t\t\tPageCount:     1,\n\t\t\tPageAlloc:     2,\n\t\t\tCursorCount:   3,\n\t\t\tNodeCount:     100,\n\t\t\tNodeDeref:     101,\n\t\t\tRebalance:     1000,\n\t\t\tRebalanceTime: 1001 * time.Second,\n\t\t\tSplit:         10000,\n\t\t\tSpill:         10001,\n\t\t\tSpillTime:     10001 * time.Second,\n\t\t\tWrite:         100000,\n\t\t\tWriteTime:     100001 * time.Second,\n\t\t},\n\t\tstats,\n\t)\n}\n\nfunc TestTxStats_Sub(t *testing.T) {\n\tstatsA := bolt.TxStats{\n\t\tPageCount:     1,\n\t\tPageAlloc:     2,\n\t\tCursorCount:   3,\n\t\tNodeCount:     100,\n\t\tNodeDeref:     101,\n\t\tRebalance:     1000,\n\t\tRebalanceTime: 1001 * time.Second,\n\t\tSplit:         10000,\n\t\tSpill:         10001,\n\t\tSpillTime:     10001 * time.Second,\n\t\tWrite:         100000,\n\t\tWriteTime:     100001 * time.Second,\n\t}\n\n\tstatsB := bolt.TxStats{\n\t\tPageCount:     2,\n\t\tPageAlloc:     3,\n\t\tCursorCount:   4,\n\t\tNodeCount:     101,\n\t\tNodeDeref:     102,\n\t\tRebalance:     1001,\n\t\tRebalanceTime: 1002 * time.Second,\n\t\tSplit:         11001,\n\t\tSpill:         11002,\n\t\tSpillTime:     11002 * time.Second,\n\t\tWrite:         110001,\n\t\tWriteTime:     110010 * time.Second,\n\t}\n\n\tdiff := statsB.Sub(&statsA)\n\tassert.Equal(t, int64(1), diff.GetPageCount())\n\tassert.Equal(t, int64(1), diff.GetPageAlloc())\n\tassert.Equal(t, int64(1), diff.GetCursorCount())\n\tassert.Equal(t, int64(1), diff.GetNodeCount())\n\tassert.Equal(t, int64(1), diff.GetNodeDeref())\n\tassert.Equal(t, int64(1), diff.GetRebalance())\n\tassert.Equal(t, time.Second, diff.GetRebalanceTime())\n\tassert.Equal(t, int64(1001), diff.GetSplit())\n\tassert.Equal(t, int64(1001), diff.GetSpill())\n\tassert.Equal(t, 1001*time.Second, diff.GetSpillTime())\n\tassert.Equal(t, int64(10001), diff.GetWrite())\n\tassert.Equal(t, 10009*time.Second, diff.GetWriteTime())\n}\n\n// TestTx_TruncateBeforeWrite ensures the file is truncated ahead whether we sync freelist or not.\nfunc TestTx_TruncateBeforeWrite(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn\n\t}\n\tfor _, isSyncFreelist := range []bool{false, true} {\n\t\tt.Run(fmt.Sprintf(\"isSyncFreelist:%v\", isSyncFreelist), func(t *testing.T) {\n\t\t\t// Open the database.\n\t\t\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{\n\t\t\t\tNoFreelistSync: isSyncFreelist,\n\t\t\t})\n\n\t\t\tbigvalue := make([]byte, db.AllocSize/100)\n\t\t\tcount := 0\n\t\t\tfor {\n\t\t\t\tcount++\n\t\t\t\ttx, err := db.Begin(true)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"bucket\"))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = b.Put([]byte{byte(count)}, bigvalue)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = tx.Commit()\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tsize := fileSize(db.Path())\n\n\t\t\t\tif size > int64(db.AllocSize) && size < int64(db.AllocSize)*2 {\n\t\t\t\t\t// db.grow expands the file aggresively, that double the size while smaller than db.AllocSize,\n\t\t\t\t\t// or increase with a step of db.AllocSize if larger, by which we can test if db.grow has run.\n\t\t\t\t\tt.Fatalf(\"db.grow doesn't run when file size changes. file size: %d\", size)\n\t\t\t\t}\n\t\t\t\tif size > int64(db.AllocSize) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tdb.MustClose()\n\t\t\tdb.MustDeleteFile()\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "unix_test.go",
          "type": "blob",
          "size": 2.3701171875,
          "content": "//go:build !windows\n\npackage bbolt_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n\n\tbolt \"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/internal/btesting\"\n)\n\nfunc TestMlock_DbOpen(t *testing.T) {\n\t// 32KB\n\tskipOnMemlockLimitBelow(t, 32*1024)\n\n\tbtesting.MustCreateDBWithOption(t, &bolt.Options{Mlock: true})\n}\n\n// Test change between \"empty\" (16KB) and \"non-empty\" db\nfunc TestMlock_DbCanGrow_Small(t *testing.T) {\n\t// 32KB\n\tskipOnMemlockLimitBelow(t, 32*1024)\n\n\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{Mlock: true})\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"bucket\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tkey := []byte(\"key\")\n\t\tvalue := []byte(\"value\")\n\t\tif err := b.Put(key, value); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n}\n\n// Test crossing of 16MB (AllocSize) of db size\nfunc TestMlock_DbCanGrow_Big(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode\")\n\t}\n\n\t// 32MB\n\tskipOnMemlockLimitBelow(t, 32*1024*1024)\n\n\tchunksBefore := 64\n\tchunksAfter := 64\n\n\tdb := btesting.MustCreateDBWithOption(t, &bolt.Options{Mlock: true})\n\n\tfor chunk := 0; chunk < chunksBefore; chunk++ {\n\t\tinsertChunk(t, db, chunk)\n\t}\n\tdbSize := fileSize(db.Path())\n\n\tfor chunk := 0; chunk < chunksAfter; chunk++ {\n\t\tinsertChunk(t, db, chunksBefore+chunk)\n\t}\n\tnewDbSize := fileSize(db.Path())\n\n\tif newDbSize <= dbSize {\n\t\tt.Errorf(\"db didn't grow: %v <= %v\", newDbSize, dbSize)\n\t}\n}\n\nfunc insertChunk(t *testing.T, db *btesting.DB, chunkId int) {\n\tchunkSize := 1024\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"bucket\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor i := 0; i < chunkSize; i++ {\n\t\t\tkey := []byte(fmt.Sprintf(\"key-%d-%d\", chunkId, i))\n\t\t\tvalue := []byte(\"value\")\n\t\t\tif err := b.Put(key, value); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Main reason for this check is travis limiting mlockable memory to 64KB\n// https://github.com/travis-ci/travis-ci/issues/2462\nfunc skipOnMemlockLimitBelow(t *testing.T, memlockLimitRequest uint64) {\n\tvar info unix.Rlimit\n\tif err := unix.Getrlimit(unix.RLIMIT_MEMLOCK, &info); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif info.Cur < memlockLimitRequest {\n\t\tt.Skipf(\n\t\t\t\"skipping as RLIMIT_MEMLOCK is insufficient: %v < %v\",\n\t\t\tinfo.Cur,\n\t\t\tmemlockLimitRequest,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 1.1962890625,
          "content": "package bbolt_test\n\nimport (\n\tbolt \"go.etcd.io/bbolt\"\n\t\"go.etcd.io/bbolt/internal/common\"\n)\n\n// `dumpBucket` dumps all the data, including both key/value data\n// and child buckets, from the source bucket into the target db file.\nfunc dumpBucket(srcBucketName []byte, srcBucket *bolt.Bucket, dstFilename string) error {\n\tcommon.Assert(len(srcBucketName) != 0, \"source bucket name can't be empty\")\n\tcommon.Assert(srcBucket != nil, \"the source bucket can't be nil\")\n\tcommon.Assert(len(dstFilename) != 0, \"the target file path can't be empty\")\n\n\tdstDB, err := bolt.Open(dstFilename, 0600, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dstDB.Close()\n\n\treturn dstDB.Update(func(tx *bolt.Tx) error {\n\t\tdstBucket, err := tx.CreateBucket(srcBucketName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn cloneBucket(srcBucket, dstBucket)\n\t})\n}\n\nfunc cloneBucket(src *bolt.Bucket, dst *bolt.Bucket) error {\n\treturn src.ForEach(func(k, v []byte) error {\n\t\tif v == nil {\n\t\t\tsrcChild := src.Bucket(k)\n\t\t\tdstChild, err := dst.CreateBucket(k)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err = dstChild.SetSequence(srcChild.Sequence()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn cloneBucket(srcChild, dstChild)\n\t\t}\n\n\t\treturn dst.Put(k, v)\n\t})\n}\n"
        },
        {
          "name": "version",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}