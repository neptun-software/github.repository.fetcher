{
  "metadata": {
    "timestamp": 1736567410510,
    "page": 15,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fsnotify/fsnotify",
      "stars": 9745,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 0.5791015625,
          "content": "freebsd_task:\n  name: 'FreeBSD'\n  freebsd_instance:\n    image_family: freebsd-14-1\n  install_script:\n    - pkg update -f\n    - pkg install -y go\n  test_script:\n      # run tests as user \"cirrus\" instead of root\n    - pw useradd cirrus -m\n    - chown -R cirrus:cirrus .\n    - FSNOTIFY_BUFFER=4096 sudo --preserve-env=FSNOTIFY_BUFFER -u cirrus go test -parallel 1 -race    ./...\n    -                      sudo --preserve-env=FSNOTIFY_BUFFER -u cirrus go test -parallel 1 -race    ./...\n    - FSNOTIFY_DEBUG=1     sudo --preserve-env=FSNOTIFY_BUFFER -u cirrus go test -parallel 1 -race -v ./...\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1220703125,
          "content": "# go test -c output\n*.test\n*.test.exe\n\n# Output of go build ./cmd/fsnotify\n/fsnotify\n/fsnotify.exe\n\n/test/kqueue\n/test/a.out\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.119140625,
          "content": "Chris Howey <howeyc@gmail.com> <chris@howey.me>\nNathan Youngman <git@nathany.com> <4566+nathany@users.noreply.github.com>\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 21.8046875,
          "content": "# Changelog\n\n1.8.0 2023-10-31\n----------------\n\n### Additions\n\n- all: add `FSNOTIFY_DEBUG` to print debug logs to stderr ([#619])\n\n### Changes and fixes\n\n- windows: fix behaviour of `WatchList()` to be consistent with other platforms ([#610])\n\n- kqueue: ignore events with Ident=0 ([#590])\n\n- kqueue: set O_CLOEXEC to prevent passing file descriptors to children ([#617])\n\n- kqueue: emit events as \"/path/dir/file\" instead of \"path/link/file\" when watching a symlink ([#625])\n\n- inotify: don't send event for IN_DELETE_SELF when also watching the parent ([#620])\n\n- inotify: fix panic when calling Remove() in a goroutine ([#650])\n\n- fen: allow watching subdirectories of watched directories ([#621])\n\n[#590]: https://github.com/fsnotify/fsnotify/pull/590\n[#610]: https://github.com/fsnotify/fsnotify/pull/610\n[#617]: https://github.com/fsnotify/fsnotify/pull/617\n[#619]: https://github.com/fsnotify/fsnotify/pull/619\n[#620]: https://github.com/fsnotify/fsnotify/pull/620\n[#621]: https://github.com/fsnotify/fsnotify/pull/621\n[#625]: https://github.com/fsnotify/fsnotify/pull/625\n[#650]: https://github.com/fsnotify/fsnotify/pull/650\n\n1.7.0 - 2023-10-22\n------------------\nThis version of fsnotify needs Go 1.17.\n\n### Additions\n\n- illumos: add FEN backend to support illumos and Solaris. ([#371])\n\n- all: add `NewBufferedWatcher()` to use a buffered channel, which can be useful\n  in cases where you can't control the kernel buffer and receive a large number\n  of events in bursts. ([#550], [#572])\n\n- all: add `AddWith()`, which is identical to `Add()` but allows passing\n  options. ([#521])\n\n- windows: allow setting the ReadDirectoryChangesW() buffer size with\n  `fsnotify.WithBufferSize()`; the default of 64K is the highest value that\n  works on all platforms and is enough for most purposes, but in some cases a\n  highest buffer is needed. ([#521])\n\n### Changes and fixes\n\n- inotify: remove watcher if a watched path is renamed ([#518])\n\n  After a rename the reported name wasn't updated, or even an empty string.\n  Inotify doesn't provide any good facilities to update it, so just remove the\n  watcher. This is already how it worked on kqueue and FEN.\n\n  On Windows this does work, and remains working.\n\n- windows: don't listen for file attribute changes ([#520])\n\n  File attribute changes are sent as `FILE_ACTION_MODIFIED` by the Windows API,\n  with no way to see if they're a file write or attribute change, so would show\n  up as a fsnotify.Write event. This is never useful, and could result in many\n  spurious Write events.\n\n- windows: return `ErrEventOverflow` if the buffer is full ([#525])\n\n  Before it would merely return \"short read\", making it hard to detect this\n  error.\n\n- kqueue: make sure events for all files are delivered properly when removing a\n  watched directory ([#526])\n\n  Previously they would get sent with `\"\"` (empty string) or `\".\"` as the path\n  name.\n\n- kqueue: don't emit spurious Create events for symbolic links ([#524])\n\n  The link would get resolved but kqueue would \"forget\" it already saw the link\n  itself, resulting on a Create for every Write event for the directory.\n\n- all: return `ErrClosed` on `Add()` when the watcher is closed ([#516])\n\n- other: add `Watcher.Errors` and `Watcher.Events` to the no-op `Watcher` in\n  `backend_other.go`, making it easier to use on unsupported platforms such as\n  WASM, AIX, etc. ([#528])\n\n- other: use the `backend_other.go` no-op if the `appengine` build tag is set;\n  Google AppEngine forbids usage of the unsafe package so the inotify backend\n  won't compile there.\n\n[#371]: https://github.com/fsnotify/fsnotify/pull/371\n[#516]: https://github.com/fsnotify/fsnotify/pull/516\n[#518]: https://github.com/fsnotify/fsnotify/pull/518\n[#520]: https://github.com/fsnotify/fsnotify/pull/520\n[#521]: https://github.com/fsnotify/fsnotify/pull/521\n[#524]: https://github.com/fsnotify/fsnotify/pull/524\n[#525]: https://github.com/fsnotify/fsnotify/pull/525\n[#526]: https://github.com/fsnotify/fsnotify/pull/526\n[#528]: https://github.com/fsnotify/fsnotify/pull/528\n[#537]: https://github.com/fsnotify/fsnotify/pull/537\n[#550]: https://github.com/fsnotify/fsnotify/pull/550\n[#572]: https://github.com/fsnotify/fsnotify/pull/572\n\n1.6.0 - 2022-10-13\n------------------\nThis version of fsnotify needs Go 1.16 (this was already the case since 1.5.1,\nbut not documented). It also increases the minimum Linux version to 2.6.32.\n\n### Additions\n\n- all: add `Event.Has()` and `Op.Has()` ([#477])\n\n  This makes checking events a lot easier; for example:\n\n\t    if event.Op&Write == Write && !(event.Op&Remove == Remove) {\n\t    }\n\n\tBecomes:\n\n\t    if event.Has(Write) && !event.Has(Remove) {\n\t    }\n\n- all: add cmd/fsnotify ([#463])\n\n  A command-line utility for testing and some examples.\n\n### Changes and fixes\n\n- inotify: don't ignore events for files that don't exist ([#260], [#470])\n\n  Previously the inotify watcher would call `os.Lstat()` to check if a file\n  still exists before emitting events.\n\n  This was inconsistent with other platforms and resulted in inconsistent event\n  reporting (e.g. when a file is quickly removed and re-created), and generally\n  a source of confusion. It was added in 2013 to fix a memory leak that no\n  longer exists.\n\n- all: return `ErrNonExistentWatch` when `Remove()` is called on a path that's\n  not watched ([#460])\n\n- inotify: replace epoll() with non-blocking inotify ([#434])\n\n  Non-blocking inotify was not generally available at the time this library was\n  written in 2014, but now it is. As a result, the minimum Linux version is\n  bumped from 2.6.27 to 2.6.32. This hugely simplifies the code and is faster.\n\n- kqueue: don't check for events every 100ms ([#480])\n\n  The watcher would wake up every 100ms, even when there was nothing to do. Now\n  it waits until there is something to do.\n\n- macos: retry opening files on EINTR ([#475])\n\n- kqueue: skip unreadable files ([#479])\n\n  kqueue requires a file descriptor for every file in a directory; this would\n  fail if a file was unreadable by the current user. Now these files are simply\n  skipped.\n\n- windows: fix renaming a watched directory if the parent is also watched ([#370])\n\n- windows: increase buffer size from 4K to 64K ([#485])\n\n- windows: close file handle on Remove() ([#288])\n\n- kqueue: put pathname in the error if watching a file fails ([#471])\n\n- inotify, windows: calling Close() more than once could race ([#465])\n\n- kqueue: improve Close() performance ([#233])\n\n- all: various documentation additions and clarifications.\n\n[#233]: https://github.com/fsnotify/fsnotify/pull/233\n[#260]: https://github.com/fsnotify/fsnotify/pull/260\n[#288]: https://github.com/fsnotify/fsnotify/pull/288\n[#370]: https://github.com/fsnotify/fsnotify/pull/370\n[#434]: https://github.com/fsnotify/fsnotify/pull/434\n[#460]: https://github.com/fsnotify/fsnotify/pull/460\n[#463]: https://github.com/fsnotify/fsnotify/pull/463\n[#465]: https://github.com/fsnotify/fsnotify/pull/465\n[#470]: https://github.com/fsnotify/fsnotify/pull/470\n[#471]: https://github.com/fsnotify/fsnotify/pull/471\n[#475]: https://github.com/fsnotify/fsnotify/pull/475\n[#477]: https://github.com/fsnotify/fsnotify/pull/477\n[#479]: https://github.com/fsnotify/fsnotify/pull/479\n[#480]: https://github.com/fsnotify/fsnotify/pull/480\n[#485]: https://github.com/fsnotify/fsnotify/pull/485\n\n## [1.5.4] - 2022-04-25\n\n* Windows: add missing defer to `Watcher.WatchList` [#447](https://github.com/fsnotify/fsnotify/pull/447)\n* go.mod: use latest x/sys [#444](https://github.com/fsnotify/fsnotify/pull/444)\n* Fix compilation for OpenBSD [#443](https://github.com/fsnotify/fsnotify/pull/443)\n\n## [1.5.3] - 2022-04-22\n\n* This version is retracted. An incorrect branch is published accidentally [#445](https://github.com/fsnotify/fsnotify/issues/445)\n\n## [1.5.2] - 2022-04-21\n\n* Add a feature to return the directories and files that are being monitored [#374](https://github.com/fsnotify/fsnotify/pull/374)\n* Fix potential crash on windows if `raw.FileNameLength` exceeds `syscall.MAX_PATH` [#361](https://github.com/fsnotify/fsnotify/pull/361)\n* Allow build on unsupported GOOS [#424](https://github.com/fsnotify/fsnotify/pull/424)\n* Don't set `poller.fd` twice in `newFdPoller` [#406](https://github.com/fsnotify/fsnotify/pull/406)\n* fix go vet warnings: call to `(*T).Fatalf` from a non-test goroutine [#416](https://github.com/fsnotify/fsnotify/pull/416)\n\n## [1.5.1] - 2021-08-24\n\n* Revert Add AddRaw to not follow symlinks [#394](https://github.com/fsnotify/fsnotify/pull/394)\n\n## [1.5.0] - 2021-08-20\n\n* Go: Increase minimum required version to Go 1.12 [#381](https://github.com/fsnotify/fsnotify/pull/381)\n* Feature: Add AddRaw method which does not follow symlinks when adding a watch [#289](https://github.com/fsnotify/fsnotify/pull/298)\n* Windows: Follow symlinks by default like on all other systems [#289](https://github.com/fsnotify/fsnotify/pull/289)\n* CI: Use GitHub Actions for CI and cover go 1.12-1.17\n   [#378](https://github.com/fsnotify/fsnotify/pull/378)\n   [#381](https://github.com/fsnotify/fsnotify/pull/381)\n   [#385](https://github.com/fsnotify/fsnotify/pull/385)\n* Go 1.14+: Fix unsafe pointer conversion [#325](https://github.com/fsnotify/fsnotify/pull/325)\n\n## [1.4.9] - 2020-03-11\n\n* Move example usage to the readme #329. This may resolve #328.\n\n## [1.4.8] - 2020-03-10\n\n* CI: test more go versions (@nathany 1d13583d846ea9d66dcabbfefbfb9d8e6fb05216)\n* Tests: Queued inotify events could have been read by the test before max_queued_events was hit (@matthias-stone #265)\n* Tests:  t.Fatalf -> t.Errorf in go routines (@gdey #266)\n* CI: Less verbosity (@nathany #267)\n* Tests: Darwin: Exchangedata is deprecated on 10.13 (@nathany #267)\n* Tests: Check if channels are closed in the example (@alexeykazakov #244)\n* CI: Only run golint on latest version of go and fix issues (@cpuguy83 #284)\n* CI: Add windows to travis matrix (@cpuguy83 #284)\n* Docs: Remover appveyor badge (@nathany 11844c0959f6fff69ba325d097fce35bd85a8e93)\n* Linux: create epoll and pipe fds with close-on-exec (@JohannesEbke #219)\n* Linux: open files with close-on-exec (@linxiulei #273)\n* Docs: Plan to support fanotify (@nathany ab058b44498e8b7566a799372a39d150d9ea0119 )\n* Project: Add go.mod (@nathany #309)\n* Project: Revise editor config (@nathany #309)\n* Project: Update copyright for 2019 (@nathany #309)\n* CI: Drop go1.8 from CI matrix (@nathany #309)\n* Docs: Updating the FAQ section for supportability with NFS & FUSE filesystems (@Pratik32 4bf2d1fec78374803a39307bfb8d340688f4f28e )\n\n## [1.4.7] - 2018-01-09\n\n* BSD/macOS: Fix possible deadlock on closing the watcher on kqueue (thanks @nhooyr and @glycerine)\n* Tests: Fix missing verb on format string (thanks @rchiossi)\n* Linux: Fix deadlock in Remove (thanks @aarondl)\n* Linux: Watch.Add improvements (avoid race, fix consistency, reduce garbage) (thanks @twpayne)\n* Docs: Moved FAQ into the README (thanks @vahe)\n* Linux: Properly handle inotify's IN_Q_OVERFLOW event (thanks @zeldovich)\n* Docs: replace references to OS X with macOS\n\n## [1.4.2] - 2016-10-10\n\n* Linux: use InotifyInit1 with IN_CLOEXEC to stop leaking a file descriptor to a child process when using fork/exec [#178](https://github.com/fsnotify/fsnotify/pull/178) (thanks @pattyshack)\n\n## [1.4.1] - 2016-10-04\n\n* Fix flaky inotify stress test on Linux [#177](https://github.com/fsnotify/fsnotify/pull/177) (thanks @pattyshack)\n\n## [1.4.0] - 2016-10-01\n\n* add a String() method to Event.Op [#165](https://github.com/fsnotify/fsnotify/pull/165) (thanks @oozie)\n\n## [1.3.1] - 2016-06-28\n\n* Windows: fix for double backslash when watching the root of a drive [#151](https://github.com/fsnotify/fsnotify/issues/151) (thanks @brunoqc)\n\n## [1.3.0] - 2016-04-19\n\n* Support linux/arm64 by [patching](https://go-review.googlesource.com/#/c/21971/) x/sys/unix and switching to to it from syscall (thanks @suihkulokki) [#135](https://github.com/fsnotify/fsnotify/pull/135)\n\n## [1.2.10] - 2016-03-02\n\n* Fix golint errors in windows.go [#121](https://github.com/fsnotify/fsnotify/pull/121) (thanks @tiffanyfj)\n\n## [1.2.9] - 2016-01-13\n\nkqueue: Fix logic for CREATE after REMOVE [#111](https://github.com/fsnotify/fsnotify/pull/111) (thanks @bep)\n\n## [1.2.8] - 2015-12-17\n\n* kqueue: fix race condition in Close [#105](https://github.com/fsnotify/fsnotify/pull/105) (thanks @djui for reporting the issue and @ppknap for writing a failing test)\n* inotify: fix race in test\n* enable race detection for continuous integration (Linux, Mac, Windows)\n\n## [1.2.5] - 2015-10-17\n\n* inotify: use epoll_create1 for arm64 support (requires Linux 2.6.27 or later) [#100](https://github.com/fsnotify/fsnotify/pull/100) (thanks @suihkulokki)\n* inotify: fix path leaks [#73](https://github.com/fsnotify/fsnotify/pull/73) (thanks @chamaken)\n* kqueue: watch for rename events on subdirectories [#83](https://github.com/fsnotify/fsnotify/pull/83) (thanks @guotie)\n* kqueue: avoid infinite loops from symlinks cycles [#101](https://github.com/fsnotify/fsnotify/pull/101) (thanks @illicitonion)\n\n## [1.2.1] - 2015-10-14\n\n* kqueue: don't watch named pipes [#98](https://github.com/fsnotify/fsnotify/pull/98) (thanks @evanphx)\n\n## [1.2.0] - 2015-02-08\n\n* inotify: use epoll to wake up readEvents [#66](https://github.com/fsnotify/fsnotify/pull/66) (thanks @PieterD)\n* inotify: closing watcher should now always shut down goroutine [#63](https://github.com/fsnotify/fsnotify/pull/63) (thanks @PieterD)\n* kqueue: close kqueue after removing watches, fixes [#59](https://github.com/fsnotify/fsnotify/issues/59)\n\n## [1.1.1] - 2015-02-05\n\n* inotify: Retry read on EINTR [#61](https://github.com/fsnotify/fsnotify/issues/61) (thanks @PieterD)\n\n## [1.1.0] - 2014-12-12\n\n* kqueue: rework internals [#43](https://github.com/fsnotify/fsnotify/pull/43)\n    * add low-level functions\n    * only need to store flags on directories\n    * less mutexes [#13](https://github.com/fsnotify/fsnotify/issues/13)\n    * done can be an unbuffered channel\n    * remove calls to os.NewSyscallError\n* More efficient string concatenation for Event.String() [#52](https://github.com/fsnotify/fsnotify/pull/52) (thanks @mdlayher)\n* kqueue: fix regression in  rework causing subdirectories to be watched [#48](https://github.com/fsnotify/fsnotify/issues/48)\n* kqueue: cleanup internal watch before sending remove event [#51](https://github.com/fsnotify/fsnotify/issues/51)\n\n## [1.0.4] - 2014-09-07\n\n* kqueue: add dragonfly to the build tags.\n* Rename source code files, rearrange code so exported APIs are at the top.\n* Add done channel to example code. [#37](https://github.com/fsnotify/fsnotify/pull/37) (thanks @chenyukang)\n\n## [1.0.3] - 2014-08-19\n\n* [Fix] Windows MOVED_TO now translates to Create like on BSD and Linux. [#36](https://github.com/fsnotify/fsnotify/issues/36)\n\n## [1.0.2] - 2014-08-17\n\n* [Fix] Missing create events on macOS. [#14](https://github.com/fsnotify/fsnotify/issues/14) (thanks @zhsso)\n* [Fix] Make ./path and path equivalent. (thanks @zhsso)\n\n## [1.0.0] - 2014-08-15\n\n* [API] Remove AddWatch on Windows, use Add.\n* Improve documentation for exported identifiers. [#30](https://github.com/fsnotify/fsnotify/issues/30)\n* Minor updates based on feedback from golint.\n\n## dev / 2014-07-09\n\n* Moved to [github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify).\n* Use os.NewSyscallError instead of returning errno (thanks @hariharan-uno)\n\n## dev / 2014-07-04\n\n* kqueue: fix incorrect mutex used in Close()\n* Update example to demonstrate usage of Op.\n\n## dev / 2014-06-28\n\n* [API] Don't set the Write Op for attribute notifications [#4](https://github.com/fsnotify/fsnotify/issues/4)\n* Fix for String() method on Event (thanks Alex Brainman)\n* Don't build on Plan 9 or Solaris (thanks @4ad)\n\n## dev / 2014-06-21\n\n* Events channel of type Event rather than *Event.\n* [internal] use syscall constants directly for inotify and kqueue.\n* [internal] kqueue: rename events to kevents and fileEvent to event.\n\n## dev / 2014-06-19\n\n* Go 1.3+ required on Windows (uses syscall.ERROR_MORE_DATA internally).\n* [internal] remove cookie from Event struct (unused).\n* [internal] Event struct has the same definition across every OS.\n* [internal] remove internal watch and removeWatch methods.\n\n## dev / 2014-06-12\n\n* [API] Renamed Watch() to Add() and RemoveWatch() to Remove().\n* [API] Pluralized channel names: Events and Errors.\n* [API] Renamed FileEvent struct to Event.\n* [API] Op constants replace methods like IsCreate().\n\n## dev / 2014-06-12\n\n* Fix data race on kevent buffer (thanks @tilaks) [#98](https://github.com/howeyc/fsnotify/pull/98)\n\n## dev / 2014-05-23\n\n* [API] Remove current implementation of WatchFlags.\n    * current implementation doesn't take advantage of OS for efficiency\n    * provides little benefit over filtering events as they are received, but has  extra bookkeeping and mutexes\n    * no tests for the current implementation\n    * not fully implemented on Windows [#93](https://github.com/howeyc/fsnotify/issues/93#issuecomment-39285195)\n\n## [0.9.3] - 2014-12-31\n\n* kqueue: cleanup internal watch before sending remove event [#51](https://github.com/fsnotify/fsnotify/issues/51)\n\n## [0.9.2] - 2014-08-17\n\n* [Backport] Fix missing create events on macOS. [#14](https://github.com/fsnotify/fsnotify/issues/14) (thanks @zhsso)\n\n## [0.9.1] - 2014-06-12\n\n* Fix data race on kevent buffer (thanks @tilaks) [#98](https://github.com/howeyc/fsnotify/pull/98)\n\n## [0.9.0] - 2014-01-17\n\n* IsAttrib() for events that only concern a file's metadata [#79][] (thanks @abustany)\n* [Fix] kqueue: fix deadlock [#77][] (thanks @cespare)\n* [NOTICE] Development has moved to `code.google.com/p/go.exp/fsnotify` in preparation for inclusion in the Go standard library.\n\n## [0.8.12] - 2013-11-13\n\n* [API] Remove FD_SET and friends from Linux adapter\n\n## [0.8.11] - 2013-11-02\n\n* [Doc] Add Changelog [#72][] (thanks @nathany)\n* [Doc] Spotlight and double modify events on macOS [#62][] (reported by @paulhammond)\n\n## [0.8.10] - 2013-10-19\n\n* [Fix] kqueue: remove file watches when parent directory is removed [#71][] (reported by @mdwhatcott)\n* [Fix] kqueue: race between Close and readEvents [#70][] (reported by @bernerdschaefer)\n* [Doc] specify OS-specific limits in README (thanks @debrando)\n\n## [0.8.9] - 2013-09-08\n\n* [Doc] Contributing (thanks @nathany)\n* [Doc] update package path in example code [#63][] (thanks @paulhammond)\n* [Doc] GoCI badge in README (Linux only) [#60][]\n* [Doc] Cross-platform testing with Vagrant  [#59][] (thanks @nathany)\n\n## [0.8.8] - 2013-06-17\n\n* [Fix] Windows: handle `ERROR_MORE_DATA` on Windows [#49][] (thanks @jbowtie)\n\n## [0.8.7] - 2013-06-03\n\n* [API] Make syscall flags internal\n* [Fix] inotify: ignore event changes\n* [Fix] race in symlink test [#45][] (reported by @srid)\n* [Fix] tests on Windows\n* lower case error messages\n\n## [0.8.6] - 2013-05-23\n\n* kqueue: Use EVT_ONLY flag on Darwin\n* [Doc] Update README with full example\n\n## [0.8.5] - 2013-05-09\n\n* [Fix] inotify: allow monitoring of \"broken\" symlinks (thanks @tsg)\n\n## [0.8.4] - 2013-04-07\n\n* [Fix] kqueue: watch all file events [#40][] (thanks @ChrisBuchholz)\n\n## [0.8.3] - 2013-03-13\n\n* [Fix] inoitfy/kqueue memory leak [#36][] (reported by @nbkolchin)\n* [Fix] kqueue: use fsnFlags for watching a directory [#33][] (reported by @nbkolchin)\n\n## [0.8.2] - 2013-02-07\n\n* [Doc] add Authors\n* [Fix] fix data races for map access [#29][] (thanks @fsouza)\n\n## [0.8.1] - 2013-01-09\n\n* [Fix] Windows path separators\n* [Doc] BSD License\n\n## [0.8.0] - 2012-11-09\n\n* kqueue: directory watching improvements (thanks @vmirage)\n* inotify: add `IN_MOVED_TO` [#25][] (requested by @cpisto)\n* [Fix] kqueue: deleting watched directory [#24][] (reported by @jakerr)\n\n## [0.7.4] - 2012-10-09\n\n* [Fix] inotify: fixes from https://codereview.appspot.com/5418045/ (ugorji)\n* [Fix] kqueue: preserve watch flags when watching for delete [#21][] (reported by @robfig)\n* [Fix] kqueue: watch the directory even if it isn't a new watch (thanks @robfig)\n* [Fix] kqueue: modify after recreation of file\n\n## [0.7.3] - 2012-09-27\n\n* [Fix] kqueue: watch with an existing folder inside the watched folder (thanks @vmirage)\n* [Fix] kqueue: no longer get duplicate CREATE events\n\n## [0.7.2] - 2012-09-01\n\n* kqueue: events for created directories\n\n## [0.7.1] - 2012-07-14\n\n* [Fix] for renaming files\n\n## [0.7.0] - 2012-07-02\n\n* [Feature] FSNotify flags\n* [Fix] inotify: Added file name back to event path\n\n## [0.6.0] - 2012-06-06\n\n* kqueue: watch files after directory created (thanks @tmc)\n\n## [0.5.1] - 2012-05-22\n\n* [Fix] inotify: remove all watches before Close()\n\n## [0.5.0] - 2012-05-03\n\n* [API] kqueue: return errors during watch instead of sending over channel\n* kqueue: match symlink behavior on Linux\n* inotify: add `DELETE_SELF` (requested by @taralx)\n* [Fix] kqueue: handle EINTR (reported by @robfig)\n* [Doc] Godoc example [#1][] (thanks @davecheney)\n\n## [0.4.0] - 2012-03-30\n\n* Go 1 released: build with go tool\n* [Feature] Windows support using winfsnotify\n* Windows does not have attribute change notifications\n* Roll attribute notifications into IsModify\n\n## [0.3.0] - 2012-02-19\n\n* kqueue: add files when watch directory\n\n## [0.2.0] - 2011-12-30\n\n* update to latest Go weekly code\n\n## [0.1.0] - 2011-10-19\n\n* kqueue: add watch on file creation to match inotify\n* kqueue: create file event\n* inotify: ignore `IN_IGNORED` events\n* event String()\n* linux: common FileEvent functions\n* initial commit\n\n[#79]: https://github.com/howeyc/fsnotify/pull/79\n[#77]: https://github.com/howeyc/fsnotify/pull/77\n[#72]: https://github.com/howeyc/fsnotify/issues/72\n[#71]: https://github.com/howeyc/fsnotify/issues/71\n[#70]: https://github.com/howeyc/fsnotify/issues/70\n[#63]: https://github.com/howeyc/fsnotify/issues/63\n[#62]: https://github.com/howeyc/fsnotify/issues/62\n[#60]: https://github.com/howeyc/fsnotify/issues/60\n[#59]: https://github.com/howeyc/fsnotify/issues/59\n[#49]: https://github.com/howeyc/fsnotify/issues/49\n[#45]: https://github.com/howeyc/fsnotify/issues/45\n[#40]: https://github.com/howeyc/fsnotify/issues/40\n[#36]: https://github.com/howeyc/fsnotify/issues/36\n[#33]: https://github.com/howeyc/fsnotify/issues/33\n[#29]: https://github.com/howeyc/fsnotify/issues/29\n[#25]: https://github.com/howeyc/fsnotify/issues/25\n[#24]: https://github.com/howeyc/fsnotify/issues/24\n[#21]: https://github.com/howeyc/fsnotify/issues/21\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.251953125,
          "content": "Thank you for your interest in contributing to fsnotify! We try to review and\nmerge PRs in a reasonable timeframe, but please be aware that:\n\n- To avoid \"wasted\" work, please discuss changes on the issue tracker first. You\n  can just send PRs, but they may end up being rejected for one reason or the\n  other.\n\n- fsnotify is a cross-platform library, and changes must work reasonably well on\n  all supported platforms.\n\n- Changes will need to be compatible; old code should still compile, and the\n  runtime behaviour can't change in ways that are likely to lead to problems for\n  users.\n\nTesting\n-------\nJust `go test ./...` runs all the tests; the CI runs this on all supported\nplatforms. Testing different platforms locally can be done with something like\n[goon] or [Vagrant], but this isn't super-easy to set up at the moment.\n\nUse the `-short` flag to make the \"stress test\" run faster.\n\nWriting new tests\n-----------------\nScripts in the testdata directory allow creating test cases in a \"shell-like\"\nsyntax. The basic format is:\n\n    script\n\n    Output:\n    desired output\n\nFor example:\n\n    # Create a new empty file with some data.\n    watch /\n    echo data >/file\n\n    Output:\n        create  /file\n        write   /file\n\nJust create a new file to add a new test; select which tests to run with\n`-run TestScript/[path]`.\n\nscript\n------\nThe script is a \"shell-like\" script:\n\n    cmd arg arg\n\nComments are supported with `#`:\n\n    # Comment\n    cmd arg arg  # Comment\n\nAll operations are done in a temp directory; a path like \"/foo\" is rewritten to\n\"/tmp/TestFoo/foo\".\n\nArguments can be quoted with `\"` or `'`; there are no escapes and they're\nfunctionally identical right now, but this may change in the future, so best to\nassume shell-like rules.\n\n    touch \"/file with spaces\"\n\nEnd-of-line escapes with `\\` are not supported.\n\n### Supported commands\n\n    watch path [ops]    # Watch the path, reporting events for it. Nothing is\n                        # watched by default. Optionally a list of ops can be\n                        # given, as with AddWith(path, WithOps(...)).\n    unwatch path        # Stop watching the path.\n    watchlist n         # Assert watchlist length.\n\n    stop                # Stop running the script; for debugging.\n    debug [yes/no]      # Enable/disable FSNOTIFY_DEBUG (tests are run in\n                          parallel by default, so -parallel=1 is probably a good\n                          idea).\n\n    touch path\n    mkdir [-p] dir\n    ln -s target link   # Only ln -s supported.\n    mkfifo path\n    mknod dev path\n    mv src dst\n    rm [-r] path\n    chmod mode path     # Octal only\n    sleep time-in-ms\n\n    cat path            # Read path (does nothing with the data; just reads it).\n    echo str >>path     # Append \"str\" to \"path\".\n    echo str >path      # Truncate \"path\" and write \"str\".\n\n    require reason      # Skip the test if \"reason\" is true; \"skip\" and\n    skip reason         # \"require\" behave identical; it supports both for\n                        # readability. Possible reasons are:\n                        #\n                        #   always    Always skip this test.\n                        #   symlink   Symlinks are supported (requires admin\n                        #             permissions on Windows).\n                        #   mkfifo    Platform doesn't support FIFO named sockets.\n                        #   mknod     Platform doesn't support device nodes.\n\n\noutput\n------\nAfter `Output:` the desired output is given; this is indented by convention, but\nthat's not required.\n\nThe format of that is:\n\n    # Comment\n    event  path  # Comment\n\n    system:\n        event  path\n    system2:\n        event  path\n\nEvery event is one line, and any whitespace between the event and path are\nignored. The path can optionally be surrounded in \". Anything after a \"#\" is\nignored.\n\nPlatform-specific tests can be added after GOOS; for example:\n\n    watch /\n    touch /file\n\n    Output:\n        # Tested if nothing else matches\n        create    /file\n\n        # Windows-specific test.\n        windows:\n            write  /file\n\nYou can specify multiple platforms with a comma (e.g. \"windows, linux:\").\n\"kqueue\" is a shortcut for all kqueue systems (BSD, macOS).\n\n\n[goon]: https://github.com/arp242/goon\n[Vagrant]: https://www.vagrantup.com/\n[integration_test.go]: /integration_test.go\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4951171875,
          "content": "Copyright © 2012 The Go Authors. All rights reserved.\nCopyright © fsnotify Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n* Neither the name of Google Inc. nor the names of its contributors may be used\n  to endorse or promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.8720703125,
          "content": "fsnotify is a Go library to provide cross-platform filesystem notifications on\nWindows, Linux, macOS, BSD, and illumos.\n\nGo 1.17 or newer is required; the full documentation is at\nhttps://pkg.go.dev/github.com/fsnotify/fsnotify\n\n---\n\nPlatform support:\n\n| Backend               | OS         | Status                                                                    |\n| :-------------------- | :--------- | :------------------------------------------------------------------------ |\n| inotify               | Linux      | Supported                                                                 |\n| kqueue                | BSD, macOS | Supported                                                                 |\n| ReadDirectoryChangesW | Windows    | Supported                                                                 |\n| FEN                   | illumos    | Supported                                                                 |\n| fanotify              | Linux 5.9+ | [Not yet](https://github.com/fsnotify/fsnotify/issues/114)                |\n| AHAFS                 | AIX        | [aix branch]; experimental due to lack of maintainer and test environment |\n| FSEvents              | macOS      | [Needs support in x/sys/unix][fsevents]                                   |\n| USN Journals          | Windows    | [Needs support in x/sys/windows][usn]                                     |\n| Polling               | *All*      | [Not yet](https://github.com/fsnotify/fsnotify/issues/9)                  |\n\nLinux and illumos should include Android and Solaris, but these are currently\nuntested.\n\n[fsevents]:   https://github.com/fsnotify/fsnotify/issues/11#issuecomment-1279133120\n[usn]:        https://github.com/fsnotify/fsnotify/issues/53#issuecomment-1279829847\n[aix branch]: https://github.com/fsnotify/fsnotify/issues/353#issuecomment-1284590129\n\nUsage\n-----\nA basic example:\n\n```go\npackage main\n\nimport (\n    \"log\"\n\n    \"github.com/fsnotify/fsnotify\"\n)\n\nfunc main() {\n    // Create new watcher.\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer watcher.Close()\n\n    // Start listening for events.\n    go func() {\n        for {\n            select {\n            case event, ok := <-watcher.Events:\n                if !ok {\n                    return\n                }\n                log.Println(\"event:\", event)\n                if event.Has(fsnotify.Write) {\n                    log.Println(\"modified file:\", event.Name)\n                }\n            case err, ok := <-watcher.Errors:\n                if !ok {\n                    return\n                }\n                log.Println(\"error:\", err)\n            }\n        }\n    }()\n\n    // Add a path.\n    err = watcher.Add(\"/tmp\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Block main goroutine forever.\n    <-make(chan struct{})\n}\n```\n\nSome more examples can be found in [cmd/fsnotify](cmd/fsnotify), which can be\nrun with:\n\n    % go run ./cmd/fsnotify\n\nFurther detailed documentation can be found in godoc:\nhttps://pkg.go.dev/github.com/fsnotify/fsnotify\n\nFAQ\n---\n### Will a file still be watched when it's moved to another directory?\nNo, not unless you are watching the location it was moved to.\n\n### Are subdirectories watched?\nNo, you must add watches for any directory you want to watch (a recursive\nwatcher is on the roadmap: [#18]).\n\n[#18]: https://github.com/fsnotify/fsnotify/issues/18\n\n### Do I have to watch the Error and Event channels in a goroutine?\nYes. You can read both channels in the same goroutine using `select` (you don't\nneed a separate goroutine for both channels; see the example).\n\n### Why don't notifications work with NFS, SMB, FUSE, /proc, or /sys?\nfsnotify requires support from underlying OS to work. The current NFS and SMB\nprotocols does not provide network level support for file notifications, and\nneither do the /proc and /sys virtual filesystems.\n\nThis could be fixed with a polling watcher ([#9]), but it's not yet implemented.\n\n[#9]: https://github.com/fsnotify/fsnotify/issues/9\n\n### Why do I get many Chmod events?\nSome programs may generate a lot of attribute changes; for example Spotlight on\nmacOS, anti-virus programs, backup applications, and some others are known to do\nthis. As a rule, it's typically best to ignore Chmod events. They're often not\nuseful, and tend to cause problems.\n\nSpotlight indexing on macOS can result in multiple events (see [#15]). A\ntemporary workaround is to add your folder(s) to the *Spotlight Privacy\nsettings* until we have a native FSEvents implementation (see [#11]).\n\n[#11]: https://github.com/fsnotify/fsnotify/issues/11\n[#15]: https://github.com/fsnotify/fsnotify/issues/15\n\n### Watching a file doesn't work well\nWatching individual files (rather than directories) is generally not recommended\nas many programs (especially editors) update files atomically: it will write to\na temporary file which is then moved to to destination, overwriting the original\n(or some variant thereof). The watcher on the original file is now lost, as that\nno longer exists.\n\nThe upshot of this is that a power failure or crash won't leave a half-written\nfile.\n\nWatch the parent directory and use `Event.Name` to filter out files you're not\ninterested in. There is an example of this in `cmd/fsnotify/file.go`.\n\nPlatform-specific notes\n-----------------------\n### Linux\nWhen a file is removed a REMOVE event won't be emitted until all file\ndescriptors are closed; it will emit a CHMOD instead:\n\n    fp := os.Open(\"file\")\n    os.Remove(\"file\")        // CHMOD\n    fp.Close()               // REMOVE\n\nThis is the event that inotify sends, so not much can be changed about this.\n\nThe `fs.inotify.max_user_watches` sysctl variable specifies the upper limit for\nthe number of watches per user, and `fs.inotify.max_user_instances` specifies\nthe maximum number of inotify instances per user. Every Watcher you create is an\n\"instance\", and every path you add is a \"watch\".\n\nThese are also exposed in `/proc` as `/proc/sys/fs/inotify/max_user_watches` and\n`/proc/sys/fs/inotify/max_user_instances`\n\nTo increase them you can use `sysctl` or write the value to proc file:\n\n    # The default values on Linux 5.18\n    sysctl fs.inotify.max_user_watches=124983\n    sysctl fs.inotify.max_user_instances=128\n\nTo make the changes persist on reboot edit `/etc/sysctl.conf` or\n`/usr/lib/sysctl.d/50-default.conf` (details differ per Linux distro; check your\ndistro's documentation):\n\n    fs.inotify.max_user_watches=124983\n    fs.inotify.max_user_instances=128\n\nReaching the limit will result in a \"no space left on device\" or \"too many open\nfiles\" error.\n\n### kqueue (macOS, all BSD systems)\nkqueue requires opening a file descriptor for every file that's being watched;\nso if you're watching a directory with five files then that's six file\ndescriptors. You will run in to your system's \"max open files\" limit faster on\nthese platforms.\n\nThe sysctl variables `kern.maxfiles` and `kern.maxfilesperproc` can be used to\ncontrol the maximum number of open files.\n"
        },
        {
          "name": "backend_fen.go",
          "type": "blob",
          "size": 11.4775390625,
          "content": "//go:build solaris\n\n// FEN backend for illumos (supported) and Solaris (untested, but should work).\n//\n// See port_create(3c) etc. for docs. https://www.illumos.org/man/3C/port_create\n\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype fen struct {\n\tEvents chan Event\n\tErrors chan error\n\n\tmu      sync.Mutex\n\tport    *unix.EventPort\n\tdone    chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n\tdirs    map[string]Op // Explicitly watched directories\n\twatches map[string]Op // Explicitly watched non-directories\n}\n\nfunc newBackend(ev chan Event, errs chan error) (backend, error) {\n\treturn newBufferedBackend(0, ev, errs)\n}\n\nfunc newBufferedBackend(sz uint, ev chan Event, errs chan error) (backend, error) {\n\tw := &fen{\n\t\tEvents:  ev,\n\t\tErrors:  errs,\n\t\tdirs:    make(map[string]Op),\n\t\twatches: make(map[string]Op),\n\t\tdone:    make(chan struct{}),\n\t}\n\n\tvar err error\n\tw.port, err = unix.NewEventPort()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fsnotify.NewWatcher: %w\", err)\n\t}\n\n\tgo w.readEvents()\n\treturn w, nil\n}\n\n// sendEvent attempts to send an event to the user, returning true if the event\n// was put in the channel successfully and false if the watcher has been closed.\nfunc (w *fen) sendEvent(name string, op Op) (sent bool) {\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Events <- Event{Name: name, Op: op}:\n\t\treturn true\n\t}\n}\n\n// sendError attempts to send an error to the user, returning true if the error\n// was put in the channel successfully and false if the watcher has been closed.\nfunc (w *fen) sendError(err error) (sent bool) {\n\tif err == nil {\n\t\treturn true\n\t}\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Errors <- err:\n\t\treturn true\n\t}\n}\n\nfunc (w *fen) isClosed() bool {\n\tselect {\n\tcase <-w.done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (w *fen) Close() error {\n\t// Take the lock used by associateFile to prevent lingering events from\n\t// being processed after the close\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\tclose(w.done)\n\treturn w.port.Close()\n}\n\nfunc (w *fen) Add(name string) error { return w.AddWith(name) }\n\nfunc (w *fen) AddWith(name string, opts ...addOpt) error {\n\tif w.isClosed() {\n\t\treturn ErrClosed\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  AddWith(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), name)\n\t}\n\n\twith := getOptions(opts...)\n\tif !w.xSupports(with.op) {\n\t\treturn fmt.Errorf(\"%w: %s\", xErrUnsupported, with.op)\n\t}\n\n\t// Currently we resolve symlinks that were explicitly requested to be\n\t// watched. Otherwise we would use LStat here.\n\tstat, err := os.Stat(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Associate all files in the directory.\n\tif stat.IsDir() {\n\t\terr := w.handleDirectory(name, stat, true, w.associateFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tw.mu.Lock()\n\t\tw.dirs[name] = with.op\n\t\tw.mu.Unlock()\n\t\treturn nil\n\t}\n\n\terr = w.associateFile(name, stat, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tw.mu.Lock()\n\tw.watches[name] = with.op\n\tw.mu.Unlock()\n\treturn nil\n}\n\nfunc (w *fen) Remove(name string) error {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\tif !w.port.PathIsWatched(name) {\n\t\treturn fmt.Errorf(\"%w: %s\", ErrNonExistentWatch, name)\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  Remove(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), name)\n\t}\n\n\t// The user has expressed an intent. Immediately remove this name from\n\t// whichever watch list it might be in. If it's not in there the delete\n\t// doesn't cause harm.\n\tw.mu.Lock()\n\tdelete(w.watches, name)\n\tdelete(w.dirs, name)\n\tw.mu.Unlock()\n\n\tstat, err := os.Stat(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Remove associations for every file in the directory.\n\tif stat.IsDir() {\n\t\terr := w.handleDirectory(name, stat, false, w.dissociateFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\terr = w.port.DissociatePath(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// readEvents contains the main loop that runs in a goroutine watching for events.\nfunc (w *fen) readEvents() {\n\t// If this function returns, the watcher has been closed and we can close\n\t// these channels\n\tdefer func() {\n\t\tclose(w.Errors)\n\t\tclose(w.Events)\n\t}()\n\n\tpevents := make([]unix.PortEvent, 8)\n\tfor {\n\t\tcount, err := w.port.Get(pevents, 1, nil)\n\t\tif err != nil && err != unix.ETIME {\n\t\t\t// Interrupted system call (count should be 0) ignore and continue\n\t\t\tif errors.Is(err, unix.EINTR) && count == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Get failed because we called w.Close()\n\t\t\tif errors.Is(err, unix.EBADF) && w.isClosed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// There was an error not caused by calling w.Close()\n\t\t\tif !w.sendError(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tp := pevents[:count]\n\t\tfor _, pevent := range p {\n\t\t\tif pevent.Source != unix.PORT_SOURCE_FILE {\n\t\t\t\t// Event from unexpected source received; should never happen.\n\t\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif debug {\n\t\t\t\tinternal.Debug(pevent.Path, pevent.Events)\n\t\t\t}\n\n\t\t\terr = w.handleEvent(&pevent)\n\t\t\tif !w.sendError(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (w *fen) handleDirectory(path string, stat os.FileInfo, follow bool, handler func(string, os.FileInfo, bool) error) error {\n\tfiles, err := os.ReadDir(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Handle all children of the directory.\n\tfor _, entry := range files {\n\t\tfinfo, err := entry.Info()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = handler(filepath.Join(path, finfo.Name()), finfo, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// And finally handle the directory itself.\n\treturn handler(path, stat, follow)\n}\n\n// handleEvent might need to emit more than one fsnotify event if the events\n// bitmap matches more than one event type (e.g. the file was both modified and\n// had the attributes changed between when the association was created and the\n// when event was returned)\nfunc (w *fen) handleEvent(event *unix.PortEvent) error {\n\tvar (\n\t\tevents     = event.Events\n\t\tpath       = event.Path\n\t\tfmode      = event.Cookie.(os.FileMode)\n\t\treRegister = true\n\t)\n\n\tw.mu.Lock()\n\t_, watchedDir := w.dirs[path]\n\t_, watchedPath := w.watches[path]\n\tw.mu.Unlock()\n\tisWatched := watchedDir || watchedPath\n\n\tif events&unix.FILE_DELETE != 0 {\n\t\tif !w.sendEvent(path, Remove) {\n\t\t\treturn nil\n\t\t}\n\t\treRegister = false\n\t}\n\tif events&unix.FILE_RENAME_FROM != 0 {\n\t\tif !w.sendEvent(path, Rename) {\n\t\t\treturn nil\n\t\t}\n\t\t// Don't keep watching the new file name\n\t\treRegister = false\n\t}\n\tif events&unix.FILE_RENAME_TO != 0 {\n\t\t// We don't report a Rename event for this case, because Rename events\n\t\t// are interpreted as referring to the _old_ name of the file, and in\n\t\t// this case the event would refer to the new name of the file. This\n\t\t// type of rename event is not supported by fsnotify.\n\n\t\t// inotify reports a Remove event in this case, so we simulate this\n\t\t// here.\n\t\tif !w.sendEvent(path, Remove) {\n\t\t\treturn nil\n\t\t}\n\t\t// Don't keep watching the file that was removed\n\t\treRegister = false\n\t}\n\n\t// The file is gone, nothing left to do.\n\tif !reRegister {\n\t\tif watchedDir {\n\t\t\tw.mu.Lock()\n\t\t\tdelete(w.dirs, path)\n\t\t\tw.mu.Unlock()\n\t\t}\n\t\tif watchedPath {\n\t\t\tw.mu.Lock()\n\t\t\tdelete(w.watches, path)\n\t\t\tw.mu.Unlock()\n\t\t}\n\t\treturn nil\n\t}\n\n\t// If we didn't get a deletion the file still exists and we're going to have\n\t// to watch it again. Let's Stat it now so that we can compare permissions\n\t// and have what we need to continue watching the file\n\n\tstat, err := os.Lstat(path)\n\tif err != nil {\n\t\t// This is unexpected, but we should still emit an event. This happens\n\t\t// most often on \"rm -r\" of a subdirectory inside a watched directory We\n\t\t// get a modify event of something happening inside, but by the time we\n\t\t// get here, the sudirectory is already gone. Clearly we were watching\n\t\t// this path but now it is gone. Let's tell the user that it was\n\t\t// removed.\n\t\tif !w.sendEvent(path, Remove) {\n\t\t\treturn nil\n\t\t}\n\t\t// Suppress extra write events on removed directories; they are not\n\t\t// informative and can be confusing.\n\t\treturn nil\n\t}\n\n\t// resolve symlinks that were explicitly watched as we would have at Add()\n\t// time. this helps suppress spurious Chmod events on watched symlinks\n\tif isWatched {\n\t\tstat, err = os.Stat(path)\n\t\tif err != nil {\n\t\t\t// The symlink still exists, but the target is gone. Report the\n\t\t\t// Remove similar to above.\n\t\t\tif !w.sendEvent(path, Remove) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Don't return the error\n\t\t}\n\t}\n\n\tif events&unix.FILE_MODIFIED != 0 {\n\t\tif fmode.IsDir() && watchedDir {\n\t\t\tif err := w.updateDirectory(path); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif !w.sendEvent(path, Write) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tif events&unix.FILE_ATTRIB != 0 && stat != nil {\n\t\t// Only send Chmod if perms changed\n\t\tif stat.Mode().Perm() != fmode.Perm() {\n\t\t\tif !w.sendEvent(path, Chmod) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif stat != nil {\n\t\t// If we get here, it means we've hit an event above that requires us to\n\t\t// continue watching the file or directory\n\t\treturn w.associateFile(path, stat, isWatched)\n\t}\n\treturn nil\n}\n\nfunc (w *fen) updateDirectory(path string) error {\n\t// The directory was modified, so we must find unwatched entities and watch\n\t// them. If something was removed from the directory, nothing will happen,\n\t// as everything else should still be watched.\n\tfiles, err := os.ReadDir(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, entry := range files {\n\t\tpath := filepath.Join(path, entry.Name())\n\t\tif w.port.PathIsWatched(path) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfinfo, err := entry.Info()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = w.associateFile(path, finfo, false)\n\t\tif !w.sendError(err) {\n\t\t\treturn nil\n\t\t}\n\t\tif !w.sendEvent(path, Create) {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (w *fen) associateFile(path string, stat os.FileInfo, follow bool) error {\n\tif w.isClosed() {\n\t\treturn ErrClosed\n\t}\n\t// This is primarily protecting the call to AssociatePath but it is\n\t// important and intentional that the call to PathIsWatched is also\n\t// protected by this mutex. Without this mutex, AssociatePath has been seen\n\t// to error out that the path is already associated.\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tif w.port.PathIsWatched(path) {\n\t\t// Remove the old association in favor of this one If we get ENOENT,\n\t\t// then while the x/sys/unix wrapper still thought that this path was\n\t\t// associated, the underlying event port did not. This call will have\n\t\t// cleared up that discrepancy. The most likely cause is that the event\n\t\t// has fired but we haven't processed it yet.\n\t\terr := w.port.DissociatePath(path)\n\t\tif err != nil && !errors.Is(err, unix.ENOENT) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar events int\n\tif !follow {\n\t\t// Watch symlinks themselves rather than their targets unless this entry\n\t\t// is explicitly watched.\n\t\tevents |= unix.FILE_NOFOLLOW\n\t}\n\tif true { // TODO: implement withOps()\n\t\tevents |= unix.FILE_MODIFIED\n\t}\n\tif true {\n\t\tevents |= unix.FILE_ATTRIB\n\t}\n\treturn w.port.AssociatePath(path, stat, events, stat.Mode())\n}\n\nfunc (w *fen) dissociateFile(path string, stat os.FileInfo, unused bool) error {\n\tif !w.port.PathIsWatched(path) {\n\t\treturn nil\n\t}\n\treturn w.port.DissociatePath(path)\n}\n\nfunc (w *fen) WatchList() []string {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tentries := make([]string, 0, len(w.watches)+len(w.dirs))\n\tfor pathname := range w.dirs {\n\t\tentries = append(entries, pathname)\n\t}\n\tfor pathname := range w.watches {\n\t\tentries = append(entries, pathname)\n\t}\n\n\treturn entries\n}\n\nfunc (w *fen) xSupports(op Op) bool {\n\tif op.Has(xUnportableOpen) || op.Has(xUnportableRead) ||\n\t\top.Has(xUnportableCloseWrite) || op.Has(xUnportableCloseRead) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "backend_fen_test.go",
          "type": "blob",
          "size": 1.2109375,
          "content": "//go:build solaris\n\npackage fsnotify\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRemoveState(t *testing.T) {\n\tvar (\n\t\ttmp  = t.TempDir()\n\t\tdir  = join(tmp, \"dir\")\n\t\tfile = join(dir, \"file\")\n\t)\n\tmkdir(t, dir)\n\ttouch(t, file)\n\n\tw := newWatcher(t, tmp)\n\taddWatch(t, w, tmp)\n\taddWatch(t, w, file)\n\n\tcheck := func(wantDirs, wantFiles int) {\n\t\tt.Helper()\n\t\tif len(w.b.(*fen).watches) != wantFiles {\n\t\t\tvar d []string\n\t\t\tfor k, v := range w.b.(*fen).watches {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches (have %d, want %d):\\n%v\",\n\t\t\t\tlen(w.b.(*fen).watches), wantFiles, strings.Join(d, \"\\n\"))\n\t\t}\n\t\tif len(w.b.(*fen).dirs) != wantDirs {\n\t\t\tvar d []string\n\t\t\tfor k, v := range w.b.(*fen).dirs {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.dirs (have %d, want %d):\\n%v\",\n\t\t\t\tlen(w.b.(*fen).dirs), wantDirs, strings.Join(d, \"\\n\"))\n\t\t}\n\t}\n\n\tcheck(1, 1)\n\n\t// Shouldn't change internal state.\n\tif err := w.Add(\"/path-doesnt-exist\"); err == nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(1, 1)\n\n\tif err := w.Remove(file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(1, 0)\n\n\tif err := w.Remove(tmp); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(0, 0)\n}\n"
        },
        {
          "name": "backend_inotify.go",
          "type": "blob",
          "size": 15.876953125,
          "content": "//go:build linux && !appengine\n\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype inotify struct {\n\tEvents chan Event\n\tErrors chan error\n\n\t// Store fd here as os.File.Read() will no longer return on close after\n\t// calling Fd(). See: https://github.com/golang/go/issues/26439\n\tfd          int\n\tinotifyFile *os.File\n\twatches     *watches\n\tdone        chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n\tdoneMu      sync.Mutex\n\tdoneResp    chan struct{} // Channel to respond to Close\n\n\t// Store rename cookies in an array, with the index wrapping to 0. Almost\n\t// all of the time what we get is a MOVED_FROM to set the cookie and the\n\t// next event inotify sends will be MOVED_TO to read it. However, this is\n\t// not guaranteed – as described in inotify(7) – and we may get other events\n\t// between the two MOVED_* events (including other MOVED_* ones).\n\t//\n\t// A second issue is that moving a file outside the watched directory will\n\t// trigger a MOVED_FROM to set the cookie, but we never see the MOVED_TO to\n\t// read and delete it. So just storing it in a map would slowly leak memory.\n\t//\n\t// Doing it like this gives us a simple fast LRU-cache that won't allocate.\n\t// Ten items should be more than enough for our purpose, and a loop over\n\t// such a short array is faster than a map access anyway (not that it hugely\n\t// matters since we're talking about hundreds of ns at the most, but still).\n\tcookies     [10]koekje\n\tcookieIndex uint8\n\tcookiesMu   sync.Mutex\n}\n\ntype (\n\twatches struct {\n\t\tmu   sync.RWMutex\n\t\twd   map[uint32]*watch // wd → watch\n\t\tpath map[string]uint32 // pathname → wd\n\t}\n\twatch struct {\n\t\twd      uint32 // Watch descriptor (as returned by the inotify_add_watch() syscall)\n\t\tflags   uint32 // inotify flags of this watch (see inotify(7) for the list of valid flags)\n\t\tpath    string // Watch path.\n\t\trecurse bool   // Recursion with ./...?\n\t}\n\tkoekje struct {\n\t\tcookie uint32\n\t\tpath   string\n\t}\n)\n\nfunc newWatches() *watches {\n\treturn &watches{\n\t\twd:   make(map[uint32]*watch),\n\t\tpath: make(map[string]uint32),\n\t}\n}\n\nfunc (w *watches) len() int {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn len(w.wd)\n}\n\nfunc (w *watches) add(ww *watch) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.wd[ww.wd] = ww\n\tw.path[ww.path] = ww.wd\n}\n\nfunc (w *watches) remove(wd uint32) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\twatch := w.wd[wd] // Could have had Remove() called. See #616.\n\tif watch == nil {\n\t\treturn\n\t}\n\tdelete(w.path, watch.path)\n\tdelete(w.wd, wd)\n}\n\nfunc (w *watches) removePath(path string) ([]uint32, error) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tpath, recurse := recursivePath(path)\n\twd, ok := w.path[path]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrNonExistentWatch, path)\n\t}\n\n\twatch := w.wd[wd]\n\tif recurse && !watch.recurse {\n\t\treturn nil, fmt.Errorf(\"can't use /... with non-recursive watch %q\", path)\n\t}\n\n\tdelete(w.path, path)\n\tdelete(w.wd, wd)\n\tif !watch.recurse {\n\t\treturn []uint32{wd}, nil\n\t}\n\n\twds := make([]uint32, 0, 8)\n\twds = append(wds, wd)\n\tfor p, rwd := range w.path {\n\t\tif filepath.HasPrefix(p, path) {\n\t\t\tdelete(w.path, p)\n\t\t\tdelete(w.wd, rwd)\n\t\t\twds = append(wds, rwd)\n\t\t}\n\t}\n\treturn wds, nil\n}\n\nfunc (w *watches) byPath(path string) *watch {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.wd[w.path[path]]\n}\n\nfunc (w *watches) byWd(wd uint32) *watch {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.wd[wd]\n}\n\nfunc (w *watches) updatePath(path string, f func(*watch) (*watch, error)) error {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tvar existing *watch\n\twd, ok := w.path[path]\n\tif ok {\n\t\texisting = w.wd[wd]\n\t}\n\n\tupd, err := f(existing)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif upd != nil {\n\t\tw.wd[upd.wd] = upd\n\t\tw.path[upd.path] = upd.wd\n\n\t\tif upd.wd != wd {\n\t\t\tdelete(w.wd, wd)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc newBackend(ev chan Event, errs chan error) (backend, error) {\n\treturn newBufferedBackend(0, ev, errs)\n}\n\nfunc newBufferedBackend(sz uint, ev chan Event, errs chan error) (backend, error) {\n\t// Need to set nonblocking mode for SetDeadline to work, otherwise blocking\n\t// I/O operations won't terminate on close.\n\tfd, errno := unix.InotifyInit1(unix.IN_CLOEXEC | unix.IN_NONBLOCK)\n\tif fd == -1 {\n\t\treturn nil, errno\n\t}\n\n\tw := &inotify{\n\t\tEvents:      ev,\n\t\tErrors:      errs,\n\t\tfd:          fd,\n\t\tinotifyFile: os.NewFile(uintptr(fd), \"\"),\n\t\twatches:     newWatches(),\n\t\tdone:        make(chan struct{}),\n\t\tdoneResp:    make(chan struct{}),\n\t}\n\n\tgo w.readEvents()\n\treturn w, nil\n}\n\n// Returns true if the event was sent, or false if watcher is closed.\nfunc (w *inotify) sendEvent(e Event) bool {\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Events <- e:\n\t\treturn true\n\t}\n}\n\n// Returns true if the error was sent, or false if watcher is closed.\nfunc (w *inotify) sendError(err error) bool {\n\tif err == nil {\n\t\treturn true\n\t}\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Errors <- err:\n\t\treturn true\n\t}\n}\n\nfunc (w *inotify) isClosed() bool {\n\tselect {\n\tcase <-w.done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (w *inotify) Close() error {\n\tw.doneMu.Lock()\n\tif w.isClosed() {\n\t\tw.doneMu.Unlock()\n\t\treturn nil\n\t}\n\tclose(w.done)\n\tw.doneMu.Unlock()\n\n\t// Causes any blocking reads to return with an error, provided the file\n\t// still supports deadline operations.\n\terr := w.inotifyFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for goroutine to close\n\t<-w.doneResp\n\n\treturn nil\n}\n\nfunc (w *inotify) Add(name string) error { return w.AddWith(name) }\n\nfunc (w *inotify) AddWith(path string, opts ...addOpt) error {\n\tif w.isClosed() {\n\t\treturn ErrClosed\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  AddWith(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), path)\n\t}\n\n\twith := getOptions(opts...)\n\tif !w.xSupports(with.op) {\n\t\treturn fmt.Errorf(\"%w: %s\", xErrUnsupported, with.op)\n\t}\n\n\tpath, recurse := recursivePath(path)\n\tif recurse {\n\t\treturn filepath.WalkDir(path, func(root string, d fs.DirEntry, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !d.IsDir() {\n\t\t\t\tif root == path {\n\t\t\t\t\treturn fmt.Errorf(\"fsnotify: not a directory: %q\", path)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Send a Create event when adding new directory from a recursive\n\t\t\t// watch; this is for \"mkdir -p one/two/three\". Usually all those\n\t\t\t// directories will be created before we can set up watchers on the\n\t\t\t// subdirectories, so only \"one\" would be sent as a Create event and\n\t\t\t// not \"one/two\" and \"one/two/three\" (inotifywait -r has the same\n\t\t\t// problem).\n\t\t\tif with.sendCreate && root != path {\n\t\t\t\tw.sendEvent(Event{Name: root, Op: Create})\n\t\t\t}\n\n\t\t\treturn w.add(root, with, true)\n\t\t})\n\t}\n\n\treturn w.add(path, with, false)\n}\n\nfunc (w *inotify) add(path string, with withOpts, recurse bool) error {\n\tvar flags uint32\n\tif with.noFollow {\n\t\tflags |= unix.IN_DONT_FOLLOW\n\t}\n\tif with.op.Has(Create) {\n\t\tflags |= unix.IN_CREATE\n\t}\n\tif with.op.Has(Write) {\n\t\tflags |= unix.IN_MODIFY\n\t}\n\tif with.op.Has(Remove) {\n\t\tflags |= unix.IN_DELETE | unix.IN_DELETE_SELF\n\t}\n\tif with.op.Has(Rename) {\n\t\tflags |= unix.IN_MOVED_TO | unix.IN_MOVED_FROM | unix.IN_MOVE_SELF\n\t}\n\tif with.op.Has(Chmod) {\n\t\tflags |= unix.IN_ATTRIB\n\t}\n\tif with.op.Has(xUnportableOpen) {\n\t\tflags |= unix.IN_OPEN\n\t}\n\tif with.op.Has(xUnportableRead) {\n\t\tflags |= unix.IN_ACCESS\n\t}\n\tif with.op.Has(xUnportableCloseWrite) {\n\t\tflags |= unix.IN_CLOSE_WRITE\n\t}\n\tif with.op.Has(xUnportableCloseRead) {\n\t\tflags |= unix.IN_CLOSE_NOWRITE\n\t}\n\treturn w.register(path, flags, recurse)\n}\n\nfunc (w *inotify) register(path string, flags uint32, recurse bool) error {\n\treturn w.watches.updatePath(path, func(existing *watch) (*watch, error) {\n\t\tif existing != nil {\n\t\t\tflags |= existing.flags | unix.IN_MASK_ADD\n\t\t}\n\n\t\twd, err := unix.InotifyAddWatch(w.fd, path, flags)\n\t\tif wd == -1 {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif existing == nil {\n\t\t\treturn &watch{\n\t\t\t\twd:      uint32(wd),\n\t\t\t\tpath:    path,\n\t\t\t\tflags:   flags,\n\t\t\t\trecurse: recurse,\n\t\t\t}, nil\n\t\t}\n\n\t\texisting.wd = uint32(wd)\n\t\texisting.flags = flags\n\t\treturn existing, nil\n\t})\n}\n\nfunc (w *inotify) Remove(name string) error {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  Remove(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), name)\n\t}\n\treturn w.remove(filepath.Clean(name))\n}\n\nfunc (w *inotify) remove(name string) error {\n\twds, err := w.watches.removePath(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, wd := range wds {\n\t\t_, err := unix.InotifyRmWatch(w.fd, wd)\n\t\tif err != nil {\n\t\t\t// TODO: Perhaps it's not helpful to return an error here in every\n\t\t\t// case; the only two possible errors are:\n\t\t\t//\n\t\t\t// EBADF, which happens when w.fd is not a valid file descriptor of\n\t\t\t// any kind.\n\t\t\t//\n\t\t\t// EINVAL, which is when fd is not an inotify descriptor or wd is\n\t\t\t// not a valid watch descriptor. Watch descriptors are invalidated\n\t\t\t// when they are removed explicitly or implicitly; explicitly by\n\t\t\t// inotify_rm_watch, implicitly when the file they are watching is\n\t\t\t// deleted.\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (w *inotify) WatchList() []string {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\n\tentries := make([]string, 0, w.watches.len())\n\tw.watches.mu.RLock()\n\tfor pathname := range w.watches.path {\n\t\tentries = append(entries, pathname)\n\t}\n\tw.watches.mu.RUnlock()\n\n\treturn entries\n}\n\n// readEvents reads from the inotify file descriptor, converts the\n// received events into Event objects and sends them via the Events channel\nfunc (w *inotify) readEvents() {\n\tdefer func() {\n\t\tclose(w.doneResp)\n\t\tclose(w.Errors)\n\t\tclose(w.Events)\n\t}()\n\n\tvar (\n\t\tbuf   [unix.SizeofInotifyEvent * 4096]byte // Buffer for a maximum of 4096 raw events\n\t\terrno error                                // Syscall errno\n\t)\n\tfor {\n\t\t// See if we have been closed.\n\t\tif w.isClosed() {\n\t\t\treturn\n\t\t}\n\n\t\tn, err := w.inotifyFile.Read(buf[:])\n\t\tswitch {\n\t\tcase errors.Unwrap(err) == os.ErrClosed:\n\t\t\treturn\n\t\tcase err != nil:\n\t\t\tif !w.sendError(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif n < unix.SizeofInotifyEvent {\n\t\t\tvar err error\n\t\t\tif n == 0 {\n\t\t\t\terr = io.EOF // If EOF is received. This should really never happen.\n\t\t\t} else if n < 0 {\n\t\t\t\terr = errno // If an error occurred while reading.\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"notify: short read in readEvents()\") // Read was too short.\n\t\t\t}\n\t\t\tif !w.sendError(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// We don't know how many events we just read into the buffer\n\t\t// While the offset points to at least one whole event...\n\t\tvar offset uint32\n\t\tfor offset <= uint32(n-unix.SizeofInotifyEvent) {\n\t\t\tvar (\n\t\t\t\t// Point \"raw\" to the event in the buffer\n\t\t\t\traw     = (*unix.InotifyEvent)(unsafe.Pointer(&buf[offset]))\n\t\t\t\tmask    = uint32(raw.Mask)\n\t\t\t\tnameLen = uint32(raw.Len)\n\t\t\t\t// Move to the next event in the buffer\n\t\t\t\tnext = func() { offset += unix.SizeofInotifyEvent + nameLen }\n\t\t\t)\n\n\t\t\tif mask&unix.IN_Q_OVERFLOW != 0 {\n\t\t\t\tif !w.sendError(ErrEventOverflow) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// If the event happened to the watched directory or the watched\n\t\t\t/// file, the kernel doesn't append the filename to the event, but\n\t\t\t/// we would like to always fill the the \"Name\" field with a valid\n\t\t\t/// filename. We retrieve the path of the watch from the \"paths\"\n\t\t\t/// map.\n\t\t\twatch := w.watches.byWd(uint32(raw.Wd))\n\t\t\t/// Can be nil if Remove() was called in another goroutine for this\n\t\t\t/// path inbetween reading the events from the kernel and reading\n\t\t\t/// the internal state. Not much we can do about it, so just skip.\n\t\t\t/// See #616.\n\t\t\tif watch == nil {\n\t\t\t\tnext()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tname := watch.path\n\t\t\tif nameLen > 0 {\n\t\t\t\t/// Point \"bytes\" at the first byte of the filename\n\t\t\t\tbytes := (*[unix.PathMax]byte)(unsafe.Pointer(&buf[offset+unix.SizeofInotifyEvent]))[:nameLen:nameLen]\n\t\t\t\t/// The filename is padded with NULL bytes. TrimRight() gets rid of those.\n\t\t\t\tname += \"/\" + strings.TrimRight(string(bytes[0:nameLen]), \"\\000\")\n\t\t\t}\n\n\t\t\tif debug {\n\t\t\t\tinternal.Debug(name, raw.Mask, raw.Cookie)\n\t\t\t}\n\n\t\t\tif mask&unix.IN_IGNORED != 0 { //&& event.Op != 0\n\t\t\t\tnext()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// inotify will automatically remove the watch on deletes; just need\n\t\t\t// to clean our state here.\n\t\t\tif mask&unix.IN_DELETE_SELF == unix.IN_DELETE_SELF {\n\t\t\t\tw.watches.remove(watch.wd)\n\t\t\t}\n\n\t\t\t// We can't really update the state when a watched path is moved;\n\t\t\t// only IN_MOVE_SELF is sent and not IN_MOVED_{FROM,TO}. So remove\n\t\t\t// the watch.\n\t\t\tif mask&unix.IN_MOVE_SELF == unix.IN_MOVE_SELF {\n\t\t\t\tif watch.recurse {\n\t\t\t\t\tnext() // Do nothing\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\terr := w.remove(watch.path)\n\t\t\t\tif err != nil && !errors.Is(err, ErrNonExistentWatch) {\n\t\t\t\t\tif !w.sendError(err) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Skip if we're watching both this path and the parent; the parent\n\t\t\t/// will already send a delete so no need to do it twice.\n\t\t\tif mask&unix.IN_DELETE_SELF != 0 {\n\t\t\t\tif _, ok := w.watches.path[filepath.Dir(watch.path)]; ok {\n\t\t\t\t\tnext()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tev := w.newEvent(name, mask, raw.Cookie)\n\t\t\t// Need to update watch path for recurse.\n\t\t\tif watch.recurse {\n\t\t\t\tisDir := mask&unix.IN_ISDIR == unix.IN_ISDIR\n\t\t\t\t/// New directory created: set up watch on it.\n\t\t\t\tif isDir && ev.Has(Create) {\n\t\t\t\t\terr := w.register(ev.Name, watch.flags, true)\n\t\t\t\t\tif !w.sendError(err) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// This was a directory rename, so we need to update all\n\t\t\t\t\t// the children.\n\t\t\t\t\t//\n\t\t\t\t\t// TODO: this is of course pretty slow; we should use a\n\t\t\t\t\t// better data structure for storing all of this, e.g. store\n\t\t\t\t\t// children in the watch. I have some code for this in my\n\t\t\t\t\t// kqueue refactor we can use in the future. For now I'm\n\t\t\t\t\t// okay with this as it's not publicly available.\n\t\t\t\t\t// Correctness first, performance second.\n\t\t\t\t\tif ev.renamedFrom != \"\" {\n\t\t\t\t\t\tw.watches.mu.Lock()\n\t\t\t\t\t\tfor k, ww := range w.watches.wd {\n\t\t\t\t\t\t\tif k == watch.wd || ww.path == ev.Name {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif strings.HasPrefix(ww.path, ev.renamedFrom) {\n\t\t\t\t\t\t\t\tww.path = strings.Replace(ww.path, ev.renamedFrom, ev.Name, 1)\n\t\t\t\t\t\t\t\tw.watches.wd[k] = ww\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.watches.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Send the events that are not ignored on the events channel\n\t\t\tif !w.sendEvent(ev) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnext()\n\t\t}\n\t}\n}\n\nfunc (w *inotify) isRecursive(path string) bool {\n\tww := w.watches.byPath(path)\n\tif ww == nil { // path could be a file, so also check the Dir.\n\t\tww = w.watches.byPath(filepath.Dir(path))\n\t}\n\treturn ww != nil && ww.recurse\n}\n\nfunc (w *inotify) newEvent(name string, mask, cookie uint32) Event {\n\te := Event{Name: name}\n\tif mask&unix.IN_CREATE == unix.IN_CREATE || mask&unix.IN_MOVED_TO == unix.IN_MOVED_TO {\n\t\te.Op |= Create\n\t}\n\tif mask&unix.IN_DELETE_SELF == unix.IN_DELETE_SELF || mask&unix.IN_DELETE == unix.IN_DELETE {\n\t\te.Op |= Remove\n\t}\n\tif mask&unix.IN_MODIFY == unix.IN_MODIFY {\n\t\te.Op |= Write\n\t}\n\tif mask&unix.IN_OPEN == unix.IN_OPEN {\n\t\te.Op |= xUnportableOpen\n\t}\n\tif mask&unix.IN_ACCESS == unix.IN_ACCESS {\n\t\te.Op |= xUnportableRead\n\t}\n\tif mask&unix.IN_CLOSE_WRITE == unix.IN_CLOSE_WRITE {\n\t\te.Op |= xUnportableCloseWrite\n\t}\n\tif mask&unix.IN_CLOSE_NOWRITE == unix.IN_CLOSE_NOWRITE {\n\t\te.Op |= xUnportableCloseRead\n\t}\n\tif mask&unix.IN_MOVE_SELF == unix.IN_MOVE_SELF || mask&unix.IN_MOVED_FROM == unix.IN_MOVED_FROM {\n\t\te.Op |= Rename\n\t}\n\tif mask&unix.IN_ATTRIB == unix.IN_ATTRIB {\n\t\te.Op |= Chmod\n\t}\n\n\tif cookie != 0 {\n\t\tif mask&unix.IN_MOVED_FROM == unix.IN_MOVED_FROM {\n\t\t\tw.cookiesMu.Lock()\n\t\t\tw.cookies[w.cookieIndex] = koekje{cookie: cookie, path: e.Name}\n\t\t\tw.cookieIndex++\n\t\t\tif w.cookieIndex > 9 {\n\t\t\t\tw.cookieIndex = 0\n\t\t\t}\n\t\t\tw.cookiesMu.Unlock()\n\t\t} else if mask&unix.IN_MOVED_TO == unix.IN_MOVED_TO {\n\t\t\tw.cookiesMu.Lock()\n\t\t\tvar prev string\n\t\t\tfor _, c := range w.cookies {\n\t\t\t\tif c.cookie == cookie {\n\t\t\t\t\tprev = c.path\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.cookiesMu.Unlock()\n\t\t\te.renamedFrom = prev\n\t\t}\n\t}\n\treturn e\n}\n\nfunc (w *inotify) xSupports(op Op) bool {\n\treturn true // Supports everything.\n}\n\nfunc (w *inotify) state() {\n\tw.watches.mu.Lock()\n\tdefer w.watches.mu.Unlock()\n\tfor wd, ww := range w.watches.wd {\n\t\tfmt.Fprintf(os.Stderr, \"%4d: recurse=%t %q\\n\", wd, ww.recurse, ww.path)\n\t}\n}\n"
        },
        {
          "name": "backend_inotify_test.go",
          "type": "blob",
          "size": 2.5830078125,
          "content": "//go:build linux\n\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestRemoveState(t *testing.T) {\n\tvar (\n\t\ttmp  = t.TempDir()\n\t\tdir  = join(tmp, \"dir\")\n\t\tfile = join(dir, \"file\")\n\t)\n\tmkdir(t, dir)\n\ttouch(t, file)\n\n\tw := newWatcher(t, tmp)\n\taddWatch(t, w, tmp)\n\taddWatch(t, w, file)\n\n\tcheck := func(want int) {\n\t\tt.Helper()\n\t\tif w.b.(*inotify).watches.len() != want {\n\t\t\tt.Error(w.b.(*inotify).watches)\n\t\t}\n\t}\n\n\tcheck(2)\n\n\t// Shouldn't change internal state.\n\tif err := w.Add(\"/path-doesnt-exist\"); err == nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(2)\n\n\tif err := w.Remove(file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(1)\n\n\tif err := w.Remove(tmp); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(0)\n}\n\n// Ensure that the correct error is returned on overflows.\nfunc TestInotifyOverflow(t *testing.T) {\n\tt.Parallel()\n\n\ttmp := t.TempDir()\n\tw := newWatcher(t)\n\tdefer w.Close()\n\n\t// We need to generate many more events than the\n\t// fs.inotify.max_queued_events sysctl setting.\n\tnumDirs, numFiles := 128, 1024\n\n\t// All events need to be in the inotify queue before pulling events off it\n\t// to trigger this error.\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < numDirs; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\tdir := join(tmp, strconv.Itoa(i))\n\t\t\tmkdir(t, dir, noWait)\n\t\t\taddWatch(t, w, dir)\n\n\t\t\tcreateFiles(t, dir, \"\", numFiles, 10*time.Second)\n\t\t}(i)\n\t}\n\twg.Wait()\n\n\tvar (\n\t\tcreates   = 0\n\t\toverflows = 0\n\t)\n\tfor overflows == 0 && creates < numDirs*numFiles {\n\t\tselect {\n\t\tcase <-time.After(10 * time.Second):\n\t\t\tt.Fatalf(\"Not done\")\n\t\tcase err := <-w.Errors:\n\t\t\tif !errors.Is(err, ErrEventOverflow) {\n\t\t\t\tt.Fatalf(\"unexpected error from watcher: %v\", err)\n\t\t\t}\n\t\t\toverflows++\n\t\tcase e := <-w.Events:\n\t\t\tif !strings.HasPrefix(e.Name, tmp) {\n\t\t\t\tt.Fatalf(\"Event for unknown file: %s\", e.Name)\n\t\t\t}\n\t\t\tif e.Op == Create {\n\t\t\t\tcreates++\n\t\t\t}\n\t\t}\n\t}\n\n\tif creates == numDirs*numFiles {\n\t\tt.Fatalf(\"could not trigger overflow\")\n\t}\n\tif overflows == 0 {\n\t\tt.Fatalf(\"no overflow and not enough CREATE events (expected %d, got %d)\",\n\t\t\tnumDirs*numFiles, creates)\n\t}\n}\n\n// Test inotify's \"we don't send REMOVE until all file descriptors are removed\"\n// behaviour.\nfunc TestInotifyDeleteOpenFile(t *testing.T) {\n\tt.Parallel()\n\n\ttmp := t.TempDir()\n\tfile := join(tmp, \"file\")\n\n\ttouch(t, file)\n\tfp, err := os.Open(file)\n\tif err != nil {\n\t\tt.Fatalf(\"Create failed: %v\", err)\n\t}\n\tdefer fp.Close()\n\n\tw := newCollector(t, file)\n\tw.collect(t)\n\n\trm(t, file)\n\twaitForEvents()\n\te := w.events(t)\n\tcmpEvents(t, tmp, e, newEvents(t, `chmod /file`))\n\n\tfp.Close()\n\te = w.stop(t)\n\tcmpEvents(t, tmp, e, newEvents(t, `remove /file`))\n}\n"
        },
        {
          "name": "backend_kqueue.go",
          "type": "blob",
          "size": 17.728515625,
          "content": "//go:build freebsd || openbsd || netbsd || dragonfly || darwin\n\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype kqueue struct {\n\tEvents chan Event\n\tErrors chan error\n\n\tkq        int    // File descriptor (as returned by the kqueue() syscall).\n\tclosepipe [2]int // Pipe used for closing kq.\n\twatches   *watches\n\tdone      chan struct{}\n\tdoneMu    sync.Mutex\n}\n\ntype (\n\twatches struct {\n\t\tmu     sync.RWMutex\n\t\twd     map[int]watch               // wd → watch\n\t\tpath   map[string]int              // pathname → wd\n\t\tbyDir  map[string]map[int]struct{} // dirname(path) → wd\n\t\tseen   map[string]struct{}         // Keep track of if we know this file exists.\n\t\tbyUser map[string]struct{}         // Watches added with Watcher.Add()\n\t}\n\twatch struct {\n\t\twd       int\n\t\tname     string\n\t\tlinkName string // In case of links; name is the target, and this is the link.\n\t\tisDir    bool\n\t\tdirFlags uint32\n\t}\n)\n\nfunc newWatches() *watches {\n\treturn &watches{\n\t\twd:     make(map[int]watch),\n\t\tpath:   make(map[string]int),\n\t\tbyDir:  make(map[string]map[int]struct{}),\n\t\tseen:   make(map[string]struct{}),\n\t\tbyUser: make(map[string]struct{}),\n\t}\n}\n\nfunc (w *watches) listPaths(userOnly bool) []string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\n\tif userOnly {\n\t\tl := make([]string, 0, len(w.byUser))\n\t\tfor p := range w.byUser {\n\t\t\tl = append(l, p)\n\t\t}\n\t\treturn l\n\t}\n\n\tl := make([]string, 0, len(w.path))\n\tfor p := range w.path {\n\t\tl = append(l, p)\n\t}\n\treturn l\n}\n\nfunc (w *watches) watchesInDir(path string) []string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\n\tl := make([]string, 0, 4)\n\tfor fd := range w.byDir[path] {\n\t\tinfo := w.wd[fd]\n\t\tif _, ok := w.byUser[info.name]; !ok {\n\t\t\tl = append(l, info.name)\n\t\t}\n\t}\n\treturn l\n}\n\n// Mark path as added by the user.\nfunc (w *watches) addUserWatch(path string) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.byUser[path] = struct{}{}\n}\n\nfunc (w *watches) addLink(path string, fd int) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tw.path[path] = fd\n\tw.seen[path] = struct{}{}\n}\n\nfunc (w *watches) add(path, linkPath string, fd int, isDir bool) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tw.path[path] = fd\n\tw.wd[fd] = watch{wd: fd, name: path, linkName: linkPath, isDir: isDir}\n\n\tparent := filepath.Dir(path)\n\tbyDir, ok := w.byDir[parent]\n\tif !ok {\n\t\tbyDir = make(map[int]struct{}, 1)\n\t\tw.byDir[parent] = byDir\n\t}\n\tbyDir[fd] = struct{}{}\n}\n\nfunc (w *watches) byWd(fd int) (watch, bool) {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\tinfo, ok := w.wd[fd]\n\treturn info, ok\n}\n\nfunc (w *watches) byPath(path string) (watch, bool) {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\tinfo, ok := w.wd[w.path[path]]\n\treturn info, ok\n}\n\nfunc (w *watches) updateDirFlags(path string, flags uint32) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tfd := w.path[path]\n\tinfo := w.wd[fd]\n\tinfo.dirFlags = flags\n\tw.wd[fd] = info\n}\n\nfunc (w *watches) remove(fd int, path string) bool {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tisDir := w.wd[fd].isDir\n\tdelete(w.path, path)\n\tdelete(w.byUser, path)\n\n\tparent := filepath.Dir(path)\n\tdelete(w.byDir[parent], fd)\n\n\tif len(w.byDir[parent]) == 0 {\n\t\tdelete(w.byDir, parent)\n\t}\n\n\tdelete(w.wd, fd)\n\tdelete(w.seen, path)\n\treturn isDir\n}\n\nfunc (w *watches) markSeen(path string, exists bool) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif exists {\n\t\tw.seen[path] = struct{}{}\n\t} else {\n\t\tdelete(w.seen, path)\n\t}\n}\n\nfunc (w *watches) seenBefore(path string) bool {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\t_, ok := w.seen[path]\n\treturn ok\n}\n\nfunc newBackend(ev chan Event, errs chan error) (backend, error) {\n\treturn newBufferedBackend(0, ev, errs)\n}\n\nfunc newBufferedBackend(sz uint, ev chan Event, errs chan error) (backend, error) {\n\tkq, closepipe, err := newKqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tw := &kqueue{\n\t\tEvents:    ev,\n\t\tErrors:    errs,\n\t\tkq:        kq,\n\t\tclosepipe: closepipe,\n\t\tdone:      make(chan struct{}),\n\t\twatches:   newWatches(),\n\t}\n\n\tgo w.readEvents()\n\treturn w, nil\n}\n\n// newKqueue creates a new kernel event queue and returns a descriptor.\n//\n// This registers a new event on closepipe, which will trigger an event when\n// it's closed. This way we can use kevent() without timeout/polling; without\n// the closepipe, it would block forever and we wouldn't be able to stop it at\n// all.\nfunc newKqueue() (kq int, closepipe [2]int, err error) {\n\tkq, err = unix.Kqueue()\n\tif kq == -1 {\n\t\treturn kq, closepipe, err\n\t}\n\n\t// Register the close pipe.\n\terr = unix.Pipe(closepipe[:])\n\tif err != nil {\n\t\tunix.Close(kq)\n\t\treturn kq, closepipe, err\n\t}\n\tunix.CloseOnExec(closepipe[0])\n\tunix.CloseOnExec(closepipe[1])\n\n\t// Register changes to listen on the closepipe.\n\tchanges := make([]unix.Kevent_t, 1)\n\t// SetKevent converts int to the platform-specific types.\n\tunix.SetKevent(&changes[0], closepipe[0], unix.EVFILT_READ,\n\t\tunix.EV_ADD|unix.EV_ENABLE|unix.EV_ONESHOT)\n\n\tok, err := unix.Kevent(kq, changes, nil, nil)\n\tif ok == -1 {\n\t\tunix.Close(kq)\n\t\tunix.Close(closepipe[0])\n\t\tunix.Close(closepipe[1])\n\t\treturn kq, closepipe, err\n\t}\n\treturn kq, closepipe, nil\n}\n\n// Returns true if the event was sent, or false if watcher is closed.\nfunc (w *kqueue) sendEvent(e Event) bool {\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Events <- e:\n\t\treturn true\n\t}\n}\n\n// Returns true if the error was sent, or false if watcher is closed.\nfunc (w *kqueue) sendError(err error) bool {\n\tif err == nil {\n\t\treturn true\n\t}\n\tselect {\n\tcase <-w.done:\n\t\treturn false\n\tcase w.Errors <- err:\n\t\treturn true\n\t}\n}\n\nfunc (w *kqueue) isClosed() bool {\n\tselect {\n\tcase <-w.done:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (w *kqueue) Close() error {\n\tw.doneMu.Lock()\n\tif w.isClosed() {\n\t\tw.doneMu.Unlock()\n\t\treturn nil\n\t}\n\tclose(w.done)\n\tw.doneMu.Unlock()\n\n\tpathsToRemove := w.watches.listPaths(false)\n\tfor _, name := range pathsToRemove {\n\t\tw.Remove(name)\n\t}\n\n\t// Send \"quit\" message to the reader goroutine.\n\tunix.Close(w.closepipe[1])\n\treturn nil\n}\n\nfunc (w *kqueue) Add(name string) error { return w.AddWith(name) }\n\nfunc (w *kqueue) AddWith(name string, opts ...addOpt) error {\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  AddWith(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), name)\n\t}\n\n\twith := getOptions(opts...)\n\tif !w.xSupports(with.op) {\n\t\treturn fmt.Errorf(\"%w: %s\", xErrUnsupported, with.op)\n\t}\n\n\t_, err := w.addWatch(name, noteAllEvents)\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.watches.addUserWatch(name)\n\treturn nil\n}\n\nfunc (w *kqueue) Remove(name string) error {\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  Remove(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), name)\n\t}\n\treturn w.remove(name, true)\n}\n\nfunc (w *kqueue) remove(name string, unwatchFiles bool) error {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\n\tname = filepath.Clean(name)\n\tinfo, ok := w.watches.byPath(name)\n\tif !ok {\n\t\treturn fmt.Errorf(\"%w: %s\", ErrNonExistentWatch, name)\n\t}\n\n\terr := w.register([]int{info.wd}, unix.EV_DELETE, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tunix.Close(info.wd)\n\n\tisDir := w.watches.remove(info.wd, name)\n\n\t// Find all watched paths that are in this directory that are not external.\n\tif unwatchFiles && isDir {\n\t\tpathsToRemove := w.watches.watchesInDir(name)\n\t\tfor _, name := range pathsToRemove {\n\t\t\t// Since these are internal, not much sense in propagating error to\n\t\t\t// the user, as that will just confuse them with an error about a\n\t\t\t// path they did not explicitly watch themselves.\n\t\t\tw.Remove(name)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (w *kqueue) WatchList() []string {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\treturn w.watches.listPaths(true)\n}\n\n// Watch all events (except NOTE_EXTEND, NOTE_LINK, NOTE_REVOKE)\nconst noteAllEvents = unix.NOTE_DELETE | unix.NOTE_WRITE | unix.NOTE_ATTRIB | unix.NOTE_RENAME\n\n// addWatch adds name to the watched file set; the flags are interpreted as\n// described in kevent(2).\n//\n// Returns the real path to the file which was added, with symlinks resolved.\nfunc (w *kqueue) addWatch(name string, flags uint32) (string, error) {\n\tif w.isClosed() {\n\t\treturn \"\", ErrClosed\n\t}\n\n\tname = filepath.Clean(name)\n\n\tinfo, alreadyWatching := w.watches.byPath(name)\n\tif !alreadyWatching {\n\t\tfi, err := os.Lstat(name)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// Don't watch sockets or named pipes.\n\t\tif (fi.Mode()&os.ModeSocket == os.ModeSocket) || (fi.Mode()&os.ModeNamedPipe == os.ModeNamedPipe) {\n\t\t\treturn \"\", nil\n\t\t}\n\n\t\t// Follow symlinks.\n\t\tif fi.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tlink, err := os.Readlink(name)\n\t\t\tif err != nil {\n\t\t\t\t// Return nil because Linux can add unresolvable symlinks to the\n\t\t\t\t// watch list without problems, so maintain consistency with\n\t\t\t\t// that. There will be no file events for broken symlinks.\n\t\t\t\t// TODO: more specific check; returns os.PathError; ENOENT?\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\n\t\t\t_, alreadyWatching = w.watches.byPath(link)\n\t\t\tif alreadyWatching {\n\t\t\t\t// Add to watches so we don't get spurious Create events later\n\t\t\t\t// on when we diff the directories.\n\t\t\t\tw.watches.addLink(name, 0)\n\t\t\t\treturn link, nil\n\t\t\t}\n\n\t\t\tinfo.linkName = name\n\t\t\tname = link\n\t\t\tfi, err = os.Lstat(name)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\t\t}\n\n\t\t// Retry on EINTR; open() can return EINTR in practice on macOS.\n\t\t// See #354, and Go issues 11180 and 39237.\n\t\tfor {\n\t\t\tinfo.wd, err = unix.Open(name, openMode, 0)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif errors.Is(err, unix.EINTR) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tinfo.isDir = fi.IsDir()\n\t}\n\n\terr := w.register([]int{info.wd}, unix.EV_ADD|unix.EV_CLEAR|unix.EV_ENABLE, flags)\n\tif err != nil {\n\t\tunix.Close(info.wd)\n\t\treturn \"\", err\n\t}\n\n\tif !alreadyWatching {\n\t\tw.watches.add(name, info.linkName, info.wd, info.isDir)\n\t}\n\n\t// Watch the directory if it has not been watched before, or if it was\n\t// watched before, but perhaps only a NOTE_DELETE (watchDirectoryFiles)\n\tif info.isDir {\n\t\twatchDir := (flags&unix.NOTE_WRITE) == unix.NOTE_WRITE &&\n\t\t\t(!alreadyWatching || (info.dirFlags&unix.NOTE_WRITE) != unix.NOTE_WRITE)\n\t\tw.watches.updateDirFlags(name, flags)\n\n\t\tif watchDir {\n\t\t\tif err := w.watchDirectoryFiles(name); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t}\n\treturn name, nil\n}\n\n// readEvents reads from kqueue and converts the received kevents into\n// Event values that it sends down the Events channel.\nfunc (w *kqueue) readEvents() {\n\tdefer func() {\n\t\tclose(w.Events)\n\t\tclose(w.Errors)\n\t\t_ = unix.Close(w.kq)\n\t\tunix.Close(w.closepipe[0])\n\t}()\n\n\teventBuffer := make([]unix.Kevent_t, 10)\n\tfor {\n\t\tkevents, err := w.read(eventBuffer)\n\t\t// EINTR is okay, the syscall was interrupted before timeout expired.\n\t\tif err != nil && err != unix.EINTR {\n\t\t\tif !w.sendError(fmt.Errorf(\"fsnotify.readEvents: %w\", err)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tfor _, kevent := range kevents {\n\t\t\tvar (\n\t\t\t\twd   = int(kevent.Ident)\n\t\t\t\tmask = uint32(kevent.Fflags)\n\t\t\t)\n\n\t\t\t// Shut down the loop when the pipe is closed, but only after all\n\t\t\t// other events have been processed.\n\t\t\tif wd == w.closepipe[0] {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpath, ok := w.watches.byWd(wd)\n\t\t\tif debug {\n\t\t\t\tinternal.Debug(path.name, &kevent)\n\t\t\t}\n\n\t\t\t// On macOS it seems that sometimes an event with Ident=0 is\n\t\t\t// delivered, and no other flags/information beyond that, even\n\t\t\t// though we never saw such a file descriptor. For example in\n\t\t\t// TestWatchSymlink/277 (usually at the end, but sometimes sooner):\n\t\t\t//\n\t\t\t// fmt.Printf(\"READ: %2d  %#v\\n\", kevent.Ident, kevent)\n\t\t\t// unix.Kevent_t{Ident:0x2a, Filter:-4, Flags:0x25, Fflags:0x2, Data:0, Udata:(*uint8)(nil)}\n\t\t\t// unix.Kevent_t{Ident:0x0,  Filter:-4, Flags:0x25, Fflags:0x2, Data:0, Udata:(*uint8)(nil)}\n\t\t\t//\n\t\t\t// The first is a normal event, the second with Ident 0. No error\n\t\t\t// flag, no data, no ... nothing.\n\t\t\t//\n\t\t\t// I read a bit through bsd/kern_event.c from the xnu source, but I\n\t\t\t// don't really see an obvious location where this is triggered –\n\t\t\t// this doesn't seem intentional, but idk...\n\t\t\t//\n\t\t\t// Technically fd 0 is a valid descriptor, so only skip it if\n\t\t\t// there's no path, and if we're on macOS.\n\t\t\tif !ok && kevent.Ident == 0 && runtime.GOOS == \"darwin\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tevent := w.newEvent(path.name, path.linkName, mask)\n\n\t\t\tif event.Has(Rename) || event.Has(Remove) {\n\t\t\t\tw.remove(event.Name, false)\n\t\t\t\tw.watches.markSeen(event.Name, false)\n\t\t\t}\n\n\t\t\tif path.isDir && event.Has(Write) && !event.Has(Remove) {\n\t\t\t\tw.dirChange(event.Name)\n\t\t\t} else if !w.sendEvent(event) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif event.Has(Remove) {\n\t\t\t\t// Look for a file that may have overwritten this; for example,\n\t\t\t\t// mv f1 f2 will delete f2, then create f2.\n\t\t\t\tif path.isDir {\n\t\t\t\t\tfileDir := filepath.Clean(event.Name)\n\t\t\t\t\t_, found := w.watches.byPath(fileDir)\n\t\t\t\t\tif found {\n\t\t\t\t\t\t// TODO: this branch is never triggered in any test.\n\t\t\t\t\t\t// Added in d6220df (2012).\n\t\t\t\t\t\t// isDir check added in 8611c35 (2016): https://github.com/fsnotify/fsnotify/pull/111\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// I don't really get how this can be triggered either.\n\t\t\t\t\t\t// And it wasn't triggered in the patch that added it,\n\t\t\t\t\t\t// either.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Original also had a comment:\n\t\t\t\t\t\t//   make sure the directory exists before we watch for\n\t\t\t\t\t\t//   changes. When we do a recursive watch and perform\n\t\t\t\t\t\t//   rm -rf, the parent directory might have gone\n\t\t\t\t\t\t//   missing, ignore the missing directory and let the\n\t\t\t\t\t\t//   upcoming delete event remove the watch from the\n\t\t\t\t\t\t//   parent directory.\n\t\t\t\t\t\terr := w.dirChange(fileDir)\n\t\t\t\t\t\tif !w.sendError(err) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpath := filepath.Clean(event.Name)\n\t\t\t\t\tif fi, err := os.Lstat(path); err == nil {\n\t\t\t\t\t\terr := w.sendCreateIfNew(path, fi)\n\t\t\t\t\t\tif !w.sendError(err) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// newEvent returns an platform-independent Event based on kqueue Fflags.\nfunc (w *kqueue) newEvent(name, linkName string, mask uint32) Event {\n\te := Event{Name: name}\n\tif linkName != \"\" {\n\t\t// If the user watched \"/path/link\" then emit events as \"/path/link\"\n\t\t// rather than \"/path/target\".\n\t\te.Name = linkName\n\t}\n\n\tif mask&unix.NOTE_DELETE == unix.NOTE_DELETE {\n\t\te.Op |= Remove\n\t}\n\tif mask&unix.NOTE_WRITE == unix.NOTE_WRITE {\n\t\te.Op |= Write\n\t}\n\tif mask&unix.NOTE_RENAME == unix.NOTE_RENAME {\n\t\te.Op |= Rename\n\t}\n\tif mask&unix.NOTE_ATTRIB == unix.NOTE_ATTRIB {\n\t\te.Op |= Chmod\n\t}\n\t// No point sending a write and delete event at the same time: if it's gone,\n\t// then it's gone.\n\tif e.Op.Has(Write) && e.Op.Has(Remove) {\n\t\te.Op &^= Write\n\t}\n\treturn e\n}\n\n// watchDirectoryFiles to mimic inotify when adding a watch on a directory\nfunc (w *kqueue) watchDirectoryFiles(dirPath string) error {\n\tfiles, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, f := range files {\n\t\tpath := filepath.Join(dirPath, f.Name())\n\n\t\tfi, err := f.Info()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%q: %w\", path, err)\n\t\t}\n\n\t\tcleanPath, err := w.internalWatch(path, fi)\n\t\tif err != nil {\n\t\t\t// No permission to read the file; that's not a problem: just skip.\n\t\t\t// But do add it to w.fileExists to prevent it from being picked up\n\t\t\t// as a \"new\" file later (it still shows up in the directory\n\t\t\t// listing).\n\t\t\tswitch {\n\t\t\tcase errors.Is(err, unix.EACCES) || errors.Is(err, unix.EPERM):\n\t\t\t\tcleanPath = filepath.Clean(path)\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"%q: %w\", path, err)\n\t\t\t}\n\t\t}\n\n\t\tw.watches.markSeen(cleanPath, true)\n\t}\n\n\treturn nil\n}\n\n// Search the directory for new files and send an event for them.\n//\n// This functionality is to have the BSD watcher match the inotify, which sends\n// a create event for files created in a watched directory.\nfunc (w *kqueue) dirChange(dir string) error {\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\t// Directory no longer exists: we can ignore this safely. kqueue will\n\t\t// still give us the correct events.\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"fsnotify.dirChange: %w\", err)\n\t}\n\n\tfor _, f := range files {\n\t\tfi, err := f.Info()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"fsnotify.dirChange: %w\", err)\n\t\t}\n\n\t\terr = w.sendCreateIfNew(filepath.Join(dir, fi.Name()), fi)\n\t\tif err != nil {\n\t\t\t// Don't need to send an error if this file isn't readable.\n\t\t\tif errors.Is(err, unix.EACCES) || errors.Is(err, unix.EPERM) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"fsnotify.dirChange: %w\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Send a create event if the file isn't already being tracked, and start\n// watching this file.\nfunc (w *kqueue) sendCreateIfNew(path string, fi os.FileInfo) error {\n\tif !w.watches.seenBefore(path) {\n\t\tif !w.sendEvent(Event{Name: path, Op: Create}) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Like watchDirectoryFiles, but without doing another ReadDir.\n\tpath, err := w.internalWatch(path, fi)\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.watches.markSeen(path, true)\n\treturn nil\n}\n\nfunc (w *kqueue) internalWatch(name string, fi os.FileInfo) (string, error) {\n\tif fi.IsDir() {\n\t\t// mimic Linux providing delete events for subdirectories, but preserve\n\t\t// the flags used if currently watching subdirectory\n\t\tinfo, _ := w.watches.byPath(name)\n\t\treturn w.addWatch(name, info.dirFlags|unix.NOTE_DELETE|unix.NOTE_RENAME)\n\t}\n\n\t// watch file to mimic Linux inotify\n\treturn w.addWatch(name, noteAllEvents)\n}\n\n// Register events with the queue.\nfunc (w *kqueue) register(fds []int, flags int, fflags uint32) error {\n\tchanges := make([]unix.Kevent_t, len(fds))\n\tfor i, fd := range fds {\n\t\t// SetKevent converts int to the platform-specific types.\n\t\tunix.SetKevent(&changes[i], fd, unix.EVFILT_VNODE, flags)\n\t\tchanges[i].Fflags = fflags\n\t}\n\n\t// Register the events.\n\tsuccess, err := unix.Kevent(w.kq, changes, nil, nil)\n\tif success == -1 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// read retrieves pending events, or waits until an event occurs.\nfunc (w *kqueue) read(events []unix.Kevent_t) ([]unix.Kevent_t, error) {\n\tn, err := unix.Kevent(w.kq, nil, events, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn events[0:n], nil\n}\n\nfunc (w *kqueue) xSupports(op Op) bool {\n\tif runtime.GOOS == \"freebsd\" {\n\t\t//return true // Supports everything.\n\t}\n\tif op.Has(xUnportableOpen) || op.Has(xUnportableRead) ||\n\t\top.Has(xUnportableCloseWrite) || op.Has(xUnportableCloseRead) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "backend_kqueue_test.go",
          "type": "blob",
          "size": 2.3310546875,
          "content": "//go:build freebsd || openbsd || netbsd || dragonfly || darwin\n\npackage fsnotify\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRemoveState(t *testing.T) {\n\tvar (\n\t\ttmp  = t.TempDir()\n\t\tdir  = join(tmp, \"dir\")\n\t\tfile = join(dir, \"file\")\n\t)\n\tmkdir(t, dir)\n\ttouch(t, file)\n\n\tw := newWatcher(t, tmp)\n\tkq := w.b.(*kqueue)\n\taddWatch(t, w, tmp)\n\taddWatch(t, w, file)\n\n\tcheck := func(wantUser, wantTotal int) {\n\t\tt.Helper()\n\n\t\tif len(kq.watches.path) != wantTotal {\n\t\t\tvar d []string\n\t\t\tfor k, v := range kq.watches.path {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches.path (have %d, want %d):\\n%v\",\n\t\t\t\tlen(kq.watches.path), wantTotal, strings.Join(d, \"\\n\"))\n\t\t}\n\t\tif len(kq.watches.wd) != wantTotal {\n\t\t\tvar d []string\n\t\t\tfor k, v := range kq.watches.wd {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches.wd (have %d, want %d):\\n%v\",\n\t\t\t\tlen(kq.watches.wd), wantTotal, strings.Join(d, \"\\n\"))\n\t\t}\n\t\tif len(kq.watches.byUser) != wantUser {\n\t\t\tvar d []string\n\t\t\tfor k, v := range kq.watches.byUser {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches.byUser (have %d, want %d):\\n%v\",\n\t\t\t\tlen(kq.watches.byUser), wantUser, strings.Join(d, \"\\n\"))\n\t\t}\n\t}\n\n\tcheck(2, 3)\n\n\t// Shouldn't change internal state.\n\tif err := w.Add(\"/path-doesnt-exist\"); err == nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(2, 3)\n\n\tif err := w.Remove(file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(1, 2)\n\n\tif err := w.Remove(tmp); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(0, 0)\n\n\t// Don't check these after ever remove since they don't map easily to number\n\t// of files watches. Just make sure they're 0 after everything is removed.\n\t{\n\t\twant := 0\n\t\tif len(kq.watches.byDir) != want {\n\t\t\tvar d []string\n\t\t\tfor k, v := range kq.watches.byDir {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches.byDir (have %d, want %d):\\n%v\",\n\t\t\t\tlen(kq.watches.byDir), want, strings.Join(d, \"\\n\"))\n\t\t}\n\n\t\tif len(kq.watches.seen) != want {\n\t\t\tvar d []string\n\t\t\tfor k, v := range kq.watches.seen {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches.seen (have %d, want %d):\\n%v\",\n\t\t\t\tlen(kq.watches.seen), want, strings.Join(d, \"\\n\"))\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "backend_other.go",
          "type": "blob",
          "size": 0.896484375,
          "content": "//go:build appengine || (!darwin && !dragonfly && !freebsd && !openbsd && !linux && !netbsd && !solaris && !windows)\n\npackage fsnotify\n\nimport \"errors\"\n\ntype other struct {\n\tEvents chan Event\n\tErrors chan error\n}\n\nfunc newBackend(ev chan Event, errs chan error) (backend, error) {\n\treturn nil, errors.New(\"fsnotify not supported on the current platform\")\n}\nfunc newBufferedBackend(sz uint, ev chan Event, errs chan error) (backend, error) {\n\treturn newBackend(ev, errs)\n}\nfunc (w *other) Close() error                              { return nil }\nfunc (w *other) WatchList() []string                       { return nil }\nfunc (w *other) Add(name string) error                     { return nil }\nfunc (w *other) AddWith(name string, opts ...addOpt) error { return nil }\nfunc (w *other) Remove(name string) error                  { return nil }\nfunc (w *other) xSupports(op Op) bool                      { return false }\n"
        },
        {
          "name": "backend_windows.go",
          "type": "blob",
          "size": 16.4482421875,
          "content": "//go:build windows\n\n// Windows backend based on ReadDirectoryChangesW()\n//\n// https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readdirectorychangesw\n\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n\t\"golang.org/x/sys/windows\"\n)\n\ntype readDirChangesW struct {\n\tEvents chan Event\n\tErrors chan error\n\n\tport  windows.Handle // Handle to completion port\n\tinput chan *input    // Inputs to the reader are sent on this channel\n\tquit  chan chan<- error\n\n\tmu      sync.Mutex // Protects access to watches, closed\n\twatches watchMap   // Map of watches (key: i-number)\n\tclosed  bool       // Set to true when Close() is first called\n}\n\nfunc newBackend(ev chan Event, errs chan error) (backend, error) {\n\treturn newBufferedBackend(50, ev, errs)\n}\n\nfunc newBufferedBackend(sz uint, ev chan Event, errs chan error) (backend, error) {\n\tport, err := windows.CreateIoCompletionPort(windows.InvalidHandle, 0, 0, 0)\n\tif err != nil {\n\t\treturn nil, os.NewSyscallError(\"CreateIoCompletionPort\", err)\n\t}\n\tw := &readDirChangesW{\n\t\tEvents:  ev,\n\t\tErrors:  errs,\n\t\tport:    port,\n\t\twatches: make(watchMap),\n\t\tinput:   make(chan *input, 1),\n\t\tquit:    make(chan chan<- error, 1),\n\t}\n\tgo w.readEvents()\n\treturn w, nil\n}\n\nfunc (w *readDirChangesW) isClosed() bool {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\treturn w.closed\n}\n\nfunc (w *readDirChangesW) sendEvent(name, renamedFrom string, mask uint64) bool {\n\tif mask == 0 {\n\t\treturn false\n\t}\n\n\tevent := w.newEvent(name, uint32(mask))\n\tevent.renamedFrom = renamedFrom\n\tselect {\n\tcase ch := <-w.quit:\n\t\tw.quit <- ch\n\tcase w.Events <- event:\n\t}\n\treturn true\n}\n\n// Returns true if the error was sent, or false if watcher is closed.\nfunc (w *readDirChangesW) sendError(err error) bool {\n\tif err == nil {\n\t\treturn true\n\t}\n\tselect {\n\tcase w.Errors <- err:\n\t\treturn true\n\tcase <-w.quit:\n\t\treturn false\n\t}\n}\n\nfunc (w *readDirChangesW) Close() error {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\n\tw.mu.Lock()\n\tw.closed = true\n\tw.mu.Unlock()\n\n\t// Send \"quit\" message to the reader goroutine\n\tch := make(chan error)\n\tw.quit <- ch\n\tif err := w.wakeupReader(); err != nil {\n\t\treturn err\n\t}\n\treturn <-ch\n}\n\nfunc (w *readDirChangesW) Add(name string) error { return w.AddWith(name) }\n\nfunc (w *readDirChangesW) AddWith(name string, opts ...addOpt) error {\n\tif w.isClosed() {\n\t\treturn ErrClosed\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  AddWith(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), filepath.ToSlash(name))\n\t}\n\n\twith := getOptions(opts...)\n\tif !w.xSupports(with.op) {\n\t\treturn fmt.Errorf(\"%w: %s\", xErrUnsupported, with.op)\n\t}\n\tif with.bufsize < 4096 {\n\t\treturn fmt.Errorf(\"fsnotify.WithBufferSize: buffer size cannot be smaller than 4096 bytes\")\n\t}\n\n\tin := &input{\n\t\top:      opAddWatch,\n\t\tpath:    filepath.Clean(name),\n\t\tflags:   sysFSALLEVENTS,\n\t\treply:   make(chan error),\n\t\tbufsize: with.bufsize,\n\t}\n\tw.input <- in\n\tif err := w.wakeupReader(); err != nil {\n\t\treturn err\n\t}\n\treturn <-in.reply\n}\n\nfunc (w *readDirChangesW) Remove(name string) error {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\tif debug {\n\t\tfmt.Fprintf(os.Stderr, \"FSNOTIFY_DEBUG: %s  Remove(%q)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000000000\"), filepath.ToSlash(name))\n\t}\n\n\tin := &input{\n\t\top:    opRemoveWatch,\n\t\tpath:  filepath.Clean(name),\n\t\treply: make(chan error),\n\t}\n\tw.input <- in\n\tif err := w.wakeupReader(); err != nil {\n\t\treturn err\n\t}\n\treturn <-in.reply\n}\n\nfunc (w *readDirChangesW) WatchList() []string {\n\tif w.isClosed() {\n\t\treturn nil\n\t}\n\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tentries := make([]string, 0, len(w.watches))\n\tfor _, entry := range w.watches {\n\t\tfor _, watchEntry := range entry {\n\t\t\tfor name := range watchEntry.names {\n\t\t\t\tentries = append(entries, filepath.Join(watchEntry.path, name))\n\t\t\t}\n\t\t\t// the directory itself is being watched\n\t\t\tif watchEntry.mask != 0 {\n\t\t\t\tentries = append(entries, watchEntry.path)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn entries\n}\n\n// These options are from the old golang.org/x/exp/winfsnotify, where you could\n// add various options to the watch. This has long since been removed.\n//\n// The \"sys\" in the name is misleading as they're not part of any \"system\".\n//\n// This should all be removed at some point, and just use windows.FILE_NOTIFY_*\nconst (\n\tsysFSALLEVENTS  = 0xfff\n\tsysFSCREATE     = 0x100\n\tsysFSDELETE     = 0x200\n\tsysFSDELETESELF = 0x400\n\tsysFSMODIFY     = 0x2\n\tsysFSMOVE       = 0xc0\n\tsysFSMOVEDFROM  = 0x40\n\tsysFSMOVEDTO    = 0x80\n\tsysFSMOVESELF   = 0x800\n\tsysFSIGNORED    = 0x8000\n)\n\nfunc (w *readDirChangesW) newEvent(name string, mask uint32) Event {\n\te := Event{Name: name}\n\tif mask&sysFSCREATE == sysFSCREATE || mask&sysFSMOVEDTO == sysFSMOVEDTO {\n\t\te.Op |= Create\n\t}\n\tif mask&sysFSDELETE == sysFSDELETE || mask&sysFSDELETESELF == sysFSDELETESELF {\n\t\te.Op |= Remove\n\t}\n\tif mask&sysFSMODIFY == sysFSMODIFY {\n\t\te.Op |= Write\n\t}\n\tif mask&sysFSMOVE == sysFSMOVE || mask&sysFSMOVESELF == sysFSMOVESELF || mask&sysFSMOVEDFROM == sysFSMOVEDFROM {\n\t\te.Op |= Rename\n\t}\n\treturn e\n}\n\nconst (\n\topAddWatch = iota\n\topRemoveWatch\n)\n\nconst (\n\tprovisional uint64 = 1 << (32 + iota)\n)\n\ntype input struct {\n\top      int\n\tpath    string\n\tflags   uint32\n\tbufsize int\n\treply   chan error\n}\n\ntype inode struct {\n\thandle windows.Handle\n\tvolume uint32\n\tindex  uint64\n}\n\ntype watch struct {\n\tov      windows.Overlapped\n\tino     *inode            // i-number\n\trecurse bool              // Recursive watch?\n\tpath    string            // Directory path\n\tmask    uint64            // Directory itself is being watched with these notify flags\n\tnames   map[string]uint64 // Map of names being watched and their notify flags\n\trename  string            // Remembers the old name while renaming a file\n\tbuf     []byte            // buffer, allocated later\n}\n\ntype (\n\tindexMap map[uint64]*watch\n\twatchMap map[uint32]indexMap\n)\n\nfunc (w *readDirChangesW) wakeupReader() error {\n\terr := windows.PostQueuedCompletionStatus(w.port, 0, 0, nil)\n\tif err != nil {\n\t\treturn os.NewSyscallError(\"PostQueuedCompletionStatus\", err)\n\t}\n\treturn nil\n}\n\nfunc (w *readDirChangesW) getDir(pathname string) (dir string, err error) {\n\tattr, err := windows.GetFileAttributes(windows.StringToUTF16Ptr(pathname))\n\tif err != nil {\n\t\treturn \"\", os.NewSyscallError(\"GetFileAttributes\", err)\n\t}\n\tif attr&windows.FILE_ATTRIBUTE_DIRECTORY != 0 {\n\t\tdir = pathname\n\t} else {\n\t\tdir, _ = filepath.Split(pathname)\n\t\tdir = filepath.Clean(dir)\n\t}\n\treturn\n}\n\nfunc (w *readDirChangesW) getIno(path string) (ino *inode, err error) {\n\th, err := windows.CreateFile(windows.StringToUTF16Ptr(path),\n\t\twindows.FILE_LIST_DIRECTORY,\n\t\twindows.FILE_SHARE_READ|windows.FILE_SHARE_WRITE|windows.FILE_SHARE_DELETE,\n\t\tnil, windows.OPEN_EXISTING,\n\t\twindows.FILE_FLAG_BACKUP_SEMANTICS|windows.FILE_FLAG_OVERLAPPED, 0)\n\tif err != nil {\n\t\treturn nil, os.NewSyscallError(\"CreateFile\", err)\n\t}\n\n\tvar fi windows.ByHandleFileInformation\n\terr = windows.GetFileInformationByHandle(h, &fi)\n\tif err != nil {\n\t\twindows.CloseHandle(h)\n\t\treturn nil, os.NewSyscallError(\"GetFileInformationByHandle\", err)\n\t}\n\tino = &inode{\n\t\thandle: h,\n\t\tvolume: fi.VolumeSerialNumber,\n\t\tindex:  uint64(fi.FileIndexHigh)<<32 | uint64(fi.FileIndexLow),\n\t}\n\treturn ino, nil\n}\n\n// Must run within the I/O thread.\nfunc (m watchMap) get(ino *inode) *watch {\n\tif i := m[ino.volume]; i != nil {\n\t\treturn i[ino.index]\n\t}\n\treturn nil\n}\n\n// Must run within the I/O thread.\nfunc (m watchMap) set(ino *inode, watch *watch) {\n\ti := m[ino.volume]\n\tif i == nil {\n\t\ti = make(indexMap)\n\t\tm[ino.volume] = i\n\t}\n\ti[ino.index] = watch\n}\n\n// Must run within the I/O thread.\nfunc (w *readDirChangesW) addWatch(pathname string, flags uint64, bufsize int) error {\n\tpathname, recurse := recursivePath(pathname)\n\n\tdir, err := w.getDir(pathname)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tino, err := w.getIno(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.mu.Lock()\n\twatchEntry := w.watches.get(ino)\n\tw.mu.Unlock()\n\tif watchEntry == nil {\n\t\t_, err := windows.CreateIoCompletionPort(ino.handle, w.port, 0, 0)\n\t\tif err != nil {\n\t\t\twindows.CloseHandle(ino.handle)\n\t\t\treturn os.NewSyscallError(\"CreateIoCompletionPort\", err)\n\t\t}\n\t\twatchEntry = &watch{\n\t\t\tino:     ino,\n\t\t\tpath:    dir,\n\t\t\tnames:   make(map[string]uint64),\n\t\t\trecurse: recurse,\n\t\t\tbuf:     make([]byte, bufsize),\n\t\t}\n\t\tw.mu.Lock()\n\t\tw.watches.set(ino, watchEntry)\n\t\tw.mu.Unlock()\n\t\tflags |= provisional\n\t} else {\n\t\twindows.CloseHandle(ino.handle)\n\t}\n\tif pathname == dir {\n\t\twatchEntry.mask |= flags\n\t} else {\n\t\twatchEntry.names[filepath.Base(pathname)] |= flags\n\t}\n\n\terr = w.startRead(watchEntry)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pathname == dir {\n\t\twatchEntry.mask &= ^provisional\n\t} else {\n\t\twatchEntry.names[filepath.Base(pathname)] &= ^provisional\n\t}\n\treturn nil\n}\n\n// Must run within the I/O thread.\nfunc (w *readDirChangesW) remWatch(pathname string) error {\n\tpathname, recurse := recursivePath(pathname)\n\n\tdir, err := w.getDir(pathname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tino, err := w.getIno(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tw.mu.Lock()\n\twatch := w.watches.get(ino)\n\tw.mu.Unlock()\n\n\tif recurse && !watch.recurse {\n\t\treturn fmt.Errorf(\"can't use \\\\... with non-recursive watch %q\", pathname)\n\t}\n\n\terr = windows.CloseHandle(ino.handle)\n\tif err != nil {\n\t\tw.sendError(os.NewSyscallError(\"CloseHandle\", err))\n\t}\n\tif watch == nil {\n\t\treturn fmt.Errorf(\"%w: %s\", ErrNonExistentWatch, pathname)\n\t}\n\tif pathname == dir {\n\t\tw.sendEvent(watch.path, \"\", watch.mask&sysFSIGNORED)\n\t\twatch.mask = 0\n\t} else {\n\t\tname := filepath.Base(pathname)\n\t\tw.sendEvent(filepath.Join(watch.path, name), \"\", watch.names[name]&sysFSIGNORED)\n\t\tdelete(watch.names, name)\n\t}\n\n\treturn w.startRead(watch)\n}\n\n// Must run within the I/O thread.\nfunc (w *readDirChangesW) deleteWatch(watch *watch) {\n\tfor name, mask := range watch.names {\n\t\tif mask&provisional == 0 {\n\t\t\tw.sendEvent(filepath.Join(watch.path, name), \"\", mask&sysFSIGNORED)\n\t\t}\n\t\tdelete(watch.names, name)\n\t}\n\tif watch.mask != 0 {\n\t\tif watch.mask&provisional == 0 {\n\t\t\tw.sendEvent(watch.path, \"\", watch.mask&sysFSIGNORED)\n\t\t}\n\t\twatch.mask = 0\n\t}\n}\n\n// Must run within the I/O thread.\nfunc (w *readDirChangesW) startRead(watch *watch) error {\n\terr := windows.CancelIo(watch.ino.handle)\n\tif err != nil {\n\t\tw.sendError(os.NewSyscallError(\"CancelIo\", err))\n\t\tw.deleteWatch(watch)\n\t}\n\tmask := w.toWindowsFlags(watch.mask)\n\tfor _, m := range watch.names {\n\t\tmask |= w.toWindowsFlags(m)\n\t}\n\tif mask == 0 {\n\t\terr := windows.CloseHandle(watch.ino.handle)\n\t\tif err != nil {\n\t\t\tw.sendError(os.NewSyscallError(\"CloseHandle\", err))\n\t\t}\n\t\tw.mu.Lock()\n\t\tdelete(w.watches[watch.ino.volume], watch.ino.index)\n\t\tw.mu.Unlock()\n\t\treturn nil\n\t}\n\n\t// We need to pass the array, rather than the slice.\n\thdr := (*reflect.SliceHeader)(unsafe.Pointer(&watch.buf))\n\trdErr := windows.ReadDirectoryChanges(watch.ino.handle,\n\t\t(*byte)(unsafe.Pointer(hdr.Data)), uint32(hdr.Len),\n\t\twatch.recurse, mask, nil, &watch.ov, 0)\n\tif rdErr != nil {\n\t\terr := os.NewSyscallError(\"ReadDirectoryChanges\", rdErr)\n\t\tif rdErr == windows.ERROR_ACCESS_DENIED && watch.mask&provisional == 0 {\n\t\t\t// Watched directory was probably removed\n\t\t\tw.sendEvent(watch.path, \"\", watch.mask&sysFSDELETESELF)\n\t\t\terr = nil\n\t\t}\n\t\tw.deleteWatch(watch)\n\t\tw.startRead(watch)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// readEvents reads from the I/O completion port, converts the\n// received events into Event objects and sends them via the Events channel.\n// Entry point to the I/O thread.\nfunc (w *readDirChangesW) readEvents() {\n\tvar (\n\t\tn   uint32\n\t\tkey uintptr\n\t\tov  *windows.Overlapped\n\t)\n\truntime.LockOSThread()\n\n\tfor {\n\t\t// This error is handled after the watch == nil check below.\n\t\tqErr := windows.GetQueuedCompletionStatus(w.port, &n, &key, &ov, windows.INFINITE)\n\n\t\twatch := (*watch)(unsafe.Pointer(ov))\n\t\tif watch == nil {\n\t\t\tselect {\n\t\t\tcase ch := <-w.quit:\n\t\t\t\tw.mu.Lock()\n\t\t\t\tvar indexes []indexMap\n\t\t\t\tfor _, index := range w.watches {\n\t\t\t\t\tindexes = append(indexes, index)\n\t\t\t\t}\n\t\t\t\tw.mu.Unlock()\n\t\t\t\tfor _, index := range indexes {\n\t\t\t\t\tfor _, watch := range index {\n\t\t\t\t\t\tw.deleteWatch(watch)\n\t\t\t\t\t\tw.startRead(watch)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terr := windows.CloseHandle(w.port)\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = os.NewSyscallError(\"CloseHandle\", err)\n\t\t\t\t}\n\t\t\t\tclose(w.Events)\n\t\t\t\tclose(w.Errors)\n\t\t\t\tch <- err\n\t\t\t\treturn\n\t\t\tcase in := <-w.input:\n\t\t\t\tswitch in.op {\n\t\t\t\tcase opAddWatch:\n\t\t\t\t\tin.reply <- w.addWatch(in.path, uint64(in.flags), in.bufsize)\n\t\t\t\tcase opRemoveWatch:\n\t\t\t\t\tin.reply <- w.remWatch(in.path)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch qErr {\n\t\tcase nil:\n\t\t\t// No error\n\t\tcase windows.ERROR_MORE_DATA:\n\t\t\tif watch == nil {\n\t\t\t\tw.sendError(errors.New(\"ERROR_MORE_DATA has unexpectedly null lpOverlapped buffer\"))\n\t\t\t} else {\n\t\t\t\t// The i/o succeeded but the buffer is full.\n\t\t\t\t// In theory we should be building up a full packet.\n\t\t\t\t// In practice we can get away with just carrying on.\n\t\t\t\tn = uint32(unsafe.Sizeof(watch.buf))\n\t\t\t}\n\t\tcase windows.ERROR_ACCESS_DENIED:\n\t\t\t// Watched directory was probably removed\n\t\t\tw.sendEvent(watch.path, \"\", watch.mask&sysFSDELETESELF)\n\t\t\tw.deleteWatch(watch)\n\t\t\tw.startRead(watch)\n\t\t\tcontinue\n\t\tcase windows.ERROR_OPERATION_ABORTED:\n\t\t\t// CancelIo was called on this handle\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tw.sendError(os.NewSyscallError(\"GetQueuedCompletionPort\", qErr))\n\t\t\tcontinue\n\t\t}\n\n\t\tvar offset uint32\n\t\tfor {\n\t\t\tif n == 0 {\n\t\t\t\tw.sendError(ErrEventOverflow)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Point \"raw\" to the event in the buffer\n\t\t\traw := (*windows.FileNotifyInformation)(unsafe.Pointer(&watch.buf[offset]))\n\n\t\t\t// Create a buf that is the size of the path name\n\t\t\tsize := int(raw.FileNameLength / 2)\n\t\t\tvar buf []uint16\n\t\t\t// TODO: Use unsafe.Slice in Go 1.17; https://stackoverflow.com/questions/51187973\n\t\t\tsh := (*reflect.SliceHeader)(unsafe.Pointer(&buf))\n\t\t\tsh.Data = uintptr(unsafe.Pointer(&raw.FileName))\n\t\t\tsh.Len = size\n\t\t\tsh.Cap = size\n\t\t\tname := windows.UTF16ToString(buf)\n\t\t\tfullname := filepath.Join(watch.path, name)\n\n\t\t\tif debug {\n\t\t\t\tinternal.Debug(fullname, raw.Action)\n\t\t\t}\n\n\t\t\tvar mask uint64\n\t\t\tswitch raw.Action {\n\t\t\tcase windows.FILE_ACTION_REMOVED:\n\t\t\t\tmask = sysFSDELETESELF\n\t\t\tcase windows.FILE_ACTION_MODIFIED:\n\t\t\t\tmask = sysFSMODIFY\n\t\t\tcase windows.FILE_ACTION_RENAMED_OLD_NAME:\n\t\t\t\twatch.rename = name\n\t\t\tcase windows.FILE_ACTION_RENAMED_NEW_NAME:\n\t\t\t\t// Update saved path of all sub-watches.\n\t\t\t\told := filepath.Join(watch.path, watch.rename)\n\t\t\t\tw.mu.Lock()\n\t\t\t\tfor _, watchMap := range w.watches {\n\t\t\t\t\tfor _, ww := range watchMap {\n\t\t\t\t\t\tif strings.HasPrefix(ww.path, old) {\n\t\t\t\t\t\t\tww.path = filepath.Join(fullname, strings.TrimPrefix(ww.path, old))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tw.mu.Unlock()\n\n\t\t\t\tif watch.names[watch.rename] != 0 {\n\t\t\t\t\twatch.names[name] |= watch.names[watch.rename]\n\t\t\t\t\tdelete(watch.names, watch.rename)\n\t\t\t\t\tmask = sysFSMOVESELF\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif raw.Action != windows.FILE_ACTION_RENAMED_NEW_NAME {\n\t\t\t\tw.sendEvent(fullname, \"\", watch.names[name]&mask)\n\t\t\t}\n\t\t\tif raw.Action == windows.FILE_ACTION_REMOVED {\n\t\t\t\tw.sendEvent(fullname, \"\", watch.names[name]&sysFSIGNORED)\n\t\t\t\tdelete(watch.names, name)\n\t\t\t}\n\n\t\t\tif watch.rename != \"\" && raw.Action == windows.FILE_ACTION_RENAMED_NEW_NAME {\n\t\t\t\tw.sendEvent(fullname, filepath.Join(watch.path, watch.rename), watch.mask&w.toFSnotifyFlags(raw.Action))\n\t\t\t} else {\n\t\t\t\tw.sendEvent(fullname, \"\", watch.mask&w.toFSnotifyFlags(raw.Action))\n\t\t\t}\n\n\t\t\tif raw.Action == windows.FILE_ACTION_RENAMED_NEW_NAME {\n\t\t\t\tw.sendEvent(filepath.Join(watch.path, watch.rename), \"\", watch.names[name]&mask)\n\t\t\t}\n\n\t\t\t// Move to the next event in the buffer\n\t\t\tif raw.NextEntryOffset == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toffset += raw.NextEntryOffset\n\n\t\t\t// Error!\n\t\t\tif offset >= n {\n\t\t\t\t//lint:ignore ST1005 Windows should be capitalized\n\t\t\t\tw.sendError(errors.New(\"Windows system assumed buffer larger than it is, events have likely been missed\"))\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif err := w.startRead(watch); err != nil {\n\t\t\tw.sendError(err)\n\t\t}\n\t}\n}\n\nfunc (w *readDirChangesW) toWindowsFlags(mask uint64) uint32 {\n\tvar m uint32\n\tif mask&sysFSMODIFY != 0 {\n\t\tm |= windows.FILE_NOTIFY_CHANGE_LAST_WRITE\n\t}\n\tif mask&(sysFSMOVE|sysFSCREATE|sysFSDELETE) != 0 {\n\t\tm |= windows.FILE_NOTIFY_CHANGE_FILE_NAME | windows.FILE_NOTIFY_CHANGE_DIR_NAME\n\t}\n\treturn m\n}\n\nfunc (w *readDirChangesW) toFSnotifyFlags(action uint32) uint64 {\n\tswitch action {\n\tcase windows.FILE_ACTION_ADDED:\n\t\treturn sysFSCREATE\n\tcase windows.FILE_ACTION_REMOVED:\n\t\treturn sysFSDELETE\n\tcase windows.FILE_ACTION_MODIFIED:\n\t\treturn sysFSMODIFY\n\tcase windows.FILE_ACTION_RENAMED_OLD_NAME:\n\t\treturn sysFSMOVEDFROM\n\tcase windows.FILE_ACTION_RENAMED_NEW_NAME:\n\t\treturn sysFSMOVEDTO\n\t}\n\treturn 0\n}\n\nfunc (w *readDirChangesW) xSupports(op Op) bool {\n\tif op.Has(xUnportableOpen) || op.Has(xUnportableRead) ||\n\t\top.Has(xUnportableCloseWrite) || op.Has(xUnportableCloseRead) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "backend_windows_test.go",
          "type": "blob",
          "size": 1.3564453125,
          "content": "//go:build windows\n\npackage fsnotify\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRemoveState(t *testing.T) {\n\t// TODO: the Windows backend is too confusing; needs some serious attention.\n\treturn\n\n\tvar (\n\t\ttmp  = t.TempDir()\n\t\tdir  = join(tmp, \"dir\")\n\t\tfile = join(dir, \"file\")\n\t)\n\tmkdir(t, dir)\n\ttouch(t, file)\n\n\tw := newWatcher(t, tmp)\n\taddWatch(t, w, tmp)\n\taddWatch(t, w, file)\n\n\tcheck := func(want int) {\n\t\tt.Helper()\n\t\tif len(w.b.(*readDirChangesW).watches) != want {\n\t\t\tvar d []string\n\t\t\tfor k, v := range w.b.(*readDirChangesW).watches {\n\t\t\t\td = append(d, fmt.Sprintf(\"%#v = %#v\", k, v))\n\t\t\t}\n\t\t\tt.Errorf(\"unexpected number of entries in w.watches (have %d, want %d):\\n%v\",\n\t\t\t\tlen(w.b.(*readDirChangesW).watches), want, strings.Join(d, \"\\n\"))\n\t\t}\n\t}\n\n\tcheck(2)\n\n\t// Shouldn't change internal state.\n\tif err := w.Add(\"/path-doesnt-exist\"); err == nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(2)\n\n\tif err := w.Remove(file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(1)\n\n\tif err := w.Remove(tmp); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheck(0)\n}\n\nfunc TestWindowsRemWatch(t *testing.T) {\n\ttmp := t.TempDir()\n\n\ttouch(t, tmp, \"file\")\n\n\tw := newWatcher(t)\n\tdefer w.Close()\n\n\taddWatch(t, w, tmp)\n\tif err := w.Remove(tmp); err != nil {\n\t\tt.Fatalf(\"Could not remove the watch: %v\\n\", err)\n\t}\n\tif err := w.b.(*readDirChangesW).remWatch(tmp); err == nil {\n\t\tt.Fatal(\"Should be fail with closed handle\\n\")\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsnotify.go",
          "type": "blob",
          "size": 16.9365234375,
          "content": "// Package fsnotify provides a cross-platform interface for file system\n// notifications.\n//\n// Currently supported systems:\n//\n//   - Linux      via inotify\n//   - BSD, macOS via kqueue\n//   - Windows    via ReadDirectoryChangesW\n//   - illumos    via FEN\n//\n// # FSNOTIFY_DEBUG\n//\n// Set the FSNOTIFY_DEBUG environment variable to \"1\" to print debug messages to\n// stderr. This can be useful to track down some problems, especially in cases\n// where fsnotify is used as an indirect dependency.\n//\n// Every event will be printed as soon as there's something useful to print,\n// with as little processing from fsnotify.\n//\n// Example output:\n//\n//\tFSNOTIFY_DEBUG: 11:34:23.633087586   256:IN_CREATE            → \"/tmp/file-1\"\n//\tFSNOTIFY_DEBUG: 11:34:23.633202319     4:IN_ATTRIB            → \"/tmp/file-1\"\n//\tFSNOTIFY_DEBUG: 11:34:28.989728764   512:IN_DELETE            → \"/tmp/file-1\"\npackage fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Watcher watches a set of paths, delivering events on a channel.\n//\n// A watcher should not be copied (e.g. pass it by pointer, rather than by\n// value).\n//\n// # Linux notes\n//\n// When a file is removed a Remove event won't be emitted until all file\n// descriptors are closed, and deletes will always emit a Chmod. For example:\n//\n//\tfp := os.Open(\"file\")\n//\tos.Remove(\"file\")        // Triggers Chmod\n//\tfp.Close()               // Triggers Remove\n//\n// This is the event that inotify sends, so not much can be changed about this.\n//\n// The fs.inotify.max_user_watches sysctl variable specifies the upper limit\n// for the number of watches per user, and fs.inotify.max_user_instances\n// specifies the maximum number of inotify instances per user. Every Watcher you\n// create is an \"instance\", and every path you add is a \"watch\".\n//\n// These are also exposed in /proc as /proc/sys/fs/inotify/max_user_watches and\n// /proc/sys/fs/inotify/max_user_instances\n//\n// To increase them you can use sysctl or write the value to the /proc file:\n//\n//\t# Default values on Linux 5.18\n//\tsysctl fs.inotify.max_user_watches=124983\n//\tsysctl fs.inotify.max_user_instances=128\n//\n// To make the changes persist on reboot edit /etc/sysctl.conf or\n// /usr/lib/sysctl.d/50-default.conf (details differ per Linux distro; check\n// your distro's documentation):\n//\n//\tfs.inotify.max_user_watches=124983\n//\tfs.inotify.max_user_instances=128\n//\n// Reaching the limit will result in a \"no space left on device\" or \"too many open\n// files\" error.\n//\n// # kqueue notes (macOS, BSD)\n//\n// kqueue requires opening a file descriptor for every file that's being watched;\n// so if you're watching a directory with five files then that's six file\n// descriptors. You will run in to your system's \"max open files\" limit faster on\n// these platforms.\n//\n// The sysctl variables kern.maxfiles and kern.maxfilesperproc can be used to\n// control the maximum number of open files, as well as /etc/login.conf on BSD\n// systems.\n//\n// # Windows notes\n//\n// Paths can be added as \"C:\\\\path\\\\to\\\\dir\", but forward slashes\n// (\"C:/path/to/dir\") will also work.\n//\n// When a watched directory is removed it will always send an event for the\n// directory itself, but may not send events for all files in that directory.\n// Sometimes it will send events for all files, sometimes it will send no\n// events, and often only for some files.\n//\n// The default ReadDirectoryChangesW() buffer size is 64K, which is the largest\n// value that is guaranteed to work with SMB filesystems. If you have many\n// events in quick succession this may not be enough, and you will have to use\n// [WithBufferSize] to increase the value.\ntype Watcher struct {\n\tb backend\n\n\t// Events sends the filesystem change events.\n\t//\n\t// fsnotify can send the following events; a \"path\" here can refer to a\n\t// file, directory, symbolic link, or special file like a FIFO.\n\t//\n\t//   fsnotify.Create    A new path was created; this may be followed by one\n\t//                      or more Write events if data also gets written to a\n\t//                      file.\n\t//\n\t//   fsnotify.Remove    A path was removed.\n\t//\n\t//   fsnotify.Rename    A path was renamed. A rename is always sent with the\n\t//                      old path as Event.Name, and a Create event will be\n\t//                      sent with the new name. Renames are only sent for\n\t//                      paths that are currently watched; e.g. moving an\n\t//                      unmonitored file into a monitored directory will\n\t//                      show up as just a Create. Similarly, renaming a file\n\t//                      to outside a monitored directory will show up as\n\t//                      only a Rename.\n\t//\n\t//   fsnotify.Write     A file or named pipe was written to. A Truncate will\n\t//                      also trigger a Write. A single \"write action\"\n\t//                      initiated by the user may show up as one or multiple\n\t//                      writes, depending on when the system syncs things to\n\t//                      disk. For example when compiling a large Go program\n\t//                      you may get hundreds of Write events, and you may\n\t//                      want to wait until you've stopped receiving them\n\t//                      (see the dedup example in cmd/fsnotify).\n\t//\n\t//                      Some systems may send Write event for directories\n\t//                      when the directory content changes.\n\t//\n\t//   fsnotify.Chmod     Attributes were changed. On Linux this is also sent\n\t//                      when a file is removed (or more accurately, when a\n\t//                      link to an inode is removed). On kqueue it's sent\n\t//                      when a file is truncated. On Windows it's never\n\t//                      sent.\n\tEvents chan Event\n\n\t// Errors sends any errors.\n\tErrors chan error\n}\n\n// Event represents a file system notification.\ntype Event struct {\n\t// Path to the file or directory.\n\t//\n\t// Paths are relative to the input; for example with Add(\"dir\") the Name\n\t// will be set to \"dir/file\" if you create that file, but if you use\n\t// Add(\"/path/to/dir\") it will be \"/path/to/dir/file\".\n\tName string\n\n\t// File operation that triggered the event.\n\t//\n\t// This is a bitmask and some systems may send multiple operations at once.\n\t// Use the Event.Has() method instead of comparing with ==.\n\tOp Op\n\n\t// Create events will have this set to the old path if it's a rename. This\n\t// only works when both the source and destination are watched. It's not\n\t// reliable when watching individual files, only directories.\n\t//\n\t// For example \"mv /tmp/file /tmp/rename\" will emit:\n\t//\n\t//   Event{Op: Rename, Name: \"/tmp/file\"}\n\t//   Event{Op: Create, Name: \"/tmp/rename\", RenamedFrom: \"/tmp/file\"}\n\trenamedFrom string\n}\n\n// Op describes a set of file operations.\ntype Op uint32\n\n// The operations fsnotify can trigger; see the documentation on [Watcher] for a\n// full description, and check them with [Event.Has].\nconst (\n\t// A new pathname was created.\n\tCreate Op = 1 << iota\n\n\t// The pathname was written to; this does *not* mean the write has finished,\n\t// and a write can be followed by more writes.\n\tWrite\n\n\t// The path was removed; any watches on it will be removed. Some \"remove\"\n\t// operations may trigger a Rename if the file is actually moved (for\n\t// example \"remove to trash\" is often a rename).\n\tRemove\n\n\t// The path was renamed to something else; any watches on it will be\n\t// removed.\n\tRename\n\n\t// File attributes were changed.\n\t//\n\t// It's generally not recommended to take action on this event, as it may\n\t// get triggered very frequently by some software. For example, Spotlight\n\t// indexing on macOS, anti-virus software, backup software, etc.\n\tChmod\n\n\t// File descriptor was opened.\n\t//\n\t// Only works on Linux and FreeBSD.\n\txUnportableOpen\n\n\t// File was read from.\n\t//\n\t// Only works on Linux and FreeBSD.\n\txUnportableRead\n\n\t// File opened for writing was closed.\n\t//\n\t// Only works on Linux and FreeBSD.\n\t//\n\t// The advantage of using this over Write is that it's more reliable than\n\t// waiting for Write events to stop. It's also faster (if you're not\n\t// listening to Write events): copying a file of a few GB can easily\n\t// generate tens of thousands of Write events in a short span of time.\n\txUnportableCloseWrite\n\n\t// File opened for reading was closed.\n\t//\n\t// Only works on Linux and FreeBSD.\n\txUnportableCloseRead\n)\n\nvar (\n\t// ErrNonExistentWatch is used when Remove() is called on a path that's not\n\t// added.\n\tErrNonExistentWatch = errors.New(\"fsnotify: can't remove non-existent watch\")\n\n\t// ErrClosed is used when trying to operate on a closed Watcher.\n\tErrClosed = errors.New(\"fsnotify: watcher already closed\")\n\n\t// ErrEventOverflow is reported from the Errors channel when there are too\n\t// many events:\n\t//\n\t//  - inotify:      inotify returns IN_Q_OVERFLOW – because there are too\n\t//                  many queued events (the fs.inotify.max_queued_events\n\t//                  sysctl can be used to increase this).\n\t//  - windows:      The buffer size is too small; WithBufferSize() can be used to increase it.\n\t//  - kqueue, fen:  Not used.\n\tErrEventOverflow = errors.New(\"fsnotify: queue or buffer overflow\")\n\n\t// ErrUnsupported is returned by AddWith() when WithOps() specified an\n\t// Unportable event that's not supported on this platform.\n\txErrUnsupported = errors.New(\"fsnotify: not supported with this backend\")\n)\n\n// NewWatcher creates a new Watcher.\nfunc NewWatcher() (*Watcher, error) {\n\tev, errs := make(chan Event), make(chan error)\n\tb, err := newBackend(ev, errs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Watcher{b: b, Events: ev, Errors: errs}, nil\n}\n\n// NewBufferedWatcher creates a new Watcher with a buffered Watcher.Events\n// channel.\n//\n// The main use case for this is situations with a very large number of events\n// where the kernel buffer size can't be increased (e.g. due to lack of\n// permissions). An unbuffered Watcher will perform better for almost all use\n// cases, and whenever possible you will be better off increasing the kernel\n// buffers instead of adding a large userspace buffer.\nfunc NewBufferedWatcher(sz uint) (*Watcher, error) {\n\tev, errs := make(chan Event), make(chan error)\n\tb, err := newBufferedBackend(sz, ev, errs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Watcher{b: b, Events: ev, Errors: errs}, nil\n}\n\n// Add starts monitoring the path for changes.\n//\n// A path can only be watched once; watching it more than once is a no-op and will\n// not return an error. Paths that do not yet exist on the filesystem cannot be\n// watched.\n//\n// A watch will be automatically removed if the watched path is deleted or\n// renamed. The exception is the Windows backend, which doesn't remove the\n// watcher on renames.\n//\n// Notifications on network filesystems (NFS, SMB, FUSE, etc.) or special\n// filesystems (/proc, /sys, etc.) generally don't work.\n//\n// Returns [ErrClosed] if [Watcher.Close] was called.\n//\n// See [Watcher.AddWith] for a version that allows adding options.\n//\n// # Watching directories\n//\n// All files in a directory are monitored, including new files that are created\n// after the watcher is started. Subdirectories are not watched (i.e. it's\n// non-recursive).\n//\n// # Watching files\n//\n// Watching individual files (rather than directories) is generally not\n// recommended as many programs (especially editors) update files atomically: it\n// will write to a temporary file which is then moved to destination,\n// overwriting the original (or some variant thereof). The watcher on the\n// original file is now lost, as that no longer exists.\n//\n// The upshot of this is that a power failure or crash won't leave a\n// half-written file.\n//\n// Watch the parent directory and use Event.Name to filter out files you're not\n// interested in. There is an example of this in cmd/fsnotify/file.go.\nfunc (w *Watcher) Add(path string) error { return w.b.Add(path) }\n\n// AddWith is like [Watcher.Add], but allows adding options. When using Add()\n// the defaults described below are used.\n//\n// Possible options are:\n//\n//   - [WithBufferSize] sets the buffer size for the Windows backend; no-op on\n//     other platforms. The default is 64K (65536 bytes).\nfunc (w *Watcher) AddWith(path string, opts ...addOpt) error { return w.b.AddWith(path, opts...) }\n\n// Remove stops monitoring the path for changes.\n//\n// Directories are always removed non-recursively. For example, if you added\n// /tmp/dir and /tmp/dir/subdir then you will need to remove both.\n//\n// Removing a path that has not yet been added returns [ErrNonExistentWatch].\n//\n// Returns nil if [Watcher.Close] was called.\nfunc (w *Watcher) Remove(path string) error { return w.b.Remove(path) }\n\n// Close removes all watches and closes the Events channel.\nfunc (w *Watcher) Close() error { return w.b.Close() }\n\n// WatchList returns all paths explicitly added with [Watcher.Add] (and are not\n// yet removed).\n//\n// Returns nil if [Watcher.Close] was called.\nfunc (w *Watcher) WatchList() []string { return w.b.WatchList() }\n\n// Supports reports if all the listed operations are supported by this platform.\n//\n// Create, Write, Remove, Rename, and Chmod are always supported. It can only\n// return false for an Op starting with Unportable.\nfunc (w *Watcher) xSupports(op Op) bool { return w.b.xSupports(op) }\n\nfunc (o Op) String() string {\n\tvar b strings.Builder\n\tif o.Has(Create) {\n\t\tb.WriteString(\"|CREATE\")\n\t}\n\tif o.Has(Remove) {\n\t\tb.WriteString(\"|REMOVE\")\n\t}\n\tif o.Has(Write) {\n\t\tb.WriteString(\"|WRITE\")\n\t}\n\tif o.Has(xUnportableOpen) {\n\t\tb.WriteString(\"|OPEN\")\n\t}\n\tif o.Has(xUnportableRead) {\n\t\tb.WriteString(\"|READ\")\n\t}\n\tif o.Has(xUnportableCloseWrite) {\n\t\tb.WriteString(\"|CLOSE_WRITE\")\n\t}\n\tif o.Has(xUnportableCloseRead) {\n\t\tb.WriteString(\"|CLOSE_READ\")\n\t}\n\tif o.Has(Rename) {\n\t\tb.WriteString(\"|RENAME\")\n\t}\n\tif o.Has(Chmod) {\n\t\tb.WriteString(\"|CHMOD\")\n\t}\n\tif b.Len() == 0 {\n\t\treturn \"[no events]\"\n\t}\n\treturn b.String()[1:]\n}\n\n// Has reports if this operation has the given operation.\nfunc (o Op) Has(h Op) bool { return o&h != 0 }\n\n// Has reports if this event has the given operation.\nfunc (e Event) Has(op Op) bool { return e.Op.Has(op) }\n\n// String returns a string representation of the event with their path.\nfunc (e Event) String() string {\n\tif e.renamedFrom != \"\" {\n\t\treturn fmt.Sprintf(\"%-13s %q ← %q\", e.Op.String(), e.Name, e.renamedFrom)\n\t}\n\treturn fmt.Sprintf(\"%-13s %q\", e.Op.String(), e.Name)\n}\n\ntype (\n\tbackend interface {\n\t\tAdd(string) error\n\t\tAddWith(string, ...addOpt) error\n\t\tRemove(string) error\n\t\tWatchList() []string\n\t\tClose() error\n\t\txSupports(Op) bool\n\t}\n\taddOpt   func(opt *withOpts)\n\twithOpts struct {\n\t\tbufsize    int\n\t\top         Op\n\t\tnoFollow   bool\n\t\tsendCreate bool\n\t}\n)\n\nvar debug = func() bool {\n\t// Check for exactly \"1\" (rather than mere existence) so we can add\n\t// options/flags in the future. I don't know if we ever want that, but it's\n\t// nice to leave the option open.\n\treturn os.Getenv(\"FSNOTIFY_DEBUG\") == \"1\"\n}()\n\nvar defaultOpts = withOpts{\n\tbufsize: 65536, // 64K\n\top:      Create | Write | Remove | Rename | Chmod,\n}\n\nfunc getOptions(opts ...addOpt) withOpts {\n\twith := defaultOpts\n\tfor _, o := range opts {\n\t\tif o != nil {\n\t\t\to(&with)\n\t\t}\n\t}\n\treturn with\n}\n\n// WithBufferSize sets the [ReadDirectoryChangesW] buffer size.\n//\n// This only has effect on Windows systems, and is a no-op for other backends.\n//\n// The default value is 64K (65536 bytes) which is the highest value that works\n// on all filesystems and should be enough for most applications, but if you\n// have a large burst of events it may not be enough. You can increase it if\n// you're hitting \"queue or buffer overflow\" errors ([ErrEventOverflow]).\n//\n// [ReadDirectoryChangesW]: https://learn.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-readdirectorychangesw\nfunc WithBufferSize(bytes int) addOpt {\n\treturn func(opt *withOpts) { opt.bufsize = bytes }\n}\n\n// WithOps sets which operations to listen for. The default is [Create],\n// [Write], [Remove], [Rename], and [Chmod].\n//\n// Excluding operations you're not interested in can save quite a bit of CPU\n// time; in some use cases there may be hundreds of thousands of useless Write\n// or Chmod operations per second.\n//\n// This can also be used to add unportable operations not supported by all\n// platforms; unportable operations all start with \"Unportable\":\n// [UnportableOpen], [UnportableRead], [UnportableCloseWrite], and\n// [UnportableCloseRead].\n//\n// AddWith returns an error when using an unportable operation that's not\n// supported. Use [Watcher.Support] to check for support.\nfunc withOps(op Op) addOpt {\n\treturn func(opt *withOpts) { opt.op = op }\n}\n\n// WithNoFollow disables following symlinks, so the symlinks themselves are\n// watched.\nfunc withNoFollow() addOpt {\n\treturn func(opt *withOpts) { opt.noFollow = true }\n}\n\n// \"Internal\" option for recursive watches on inotify.\nfunc withCreate() addOpt {\n\treturn func(opt *withOpts) { opt.sendCreate = true }\n}\n\nvar enableRecurse = false\n\n// Check if this path is recursive (ends with \"/...\" or \"\\...\"), and return the\n// path with the /... stripped.\nfunc recursivePath(path string) (string, bool) {\n\tpath = filepath.Clean(path)\n\tif !enableRecurse { // Only enabled in tests for now.\n\t\treturn path, false\n\t}\n\tif filepath.Base(path) == \"...\" {\n\t\treturn filepath.Dir(path), true\n\t}\n\treturn path, false\n}\n"
        },
        {
          "name": "fsnotify_test.go",
          "type": "blob",
          "size": 16.2119140625,
          "content": "package fsnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n)\n\n// Set soft open file limit to the maximum; on e.g. OpenBSD it's 512/1024.\n//\n// Go 1.19 will always do this when the os package is imported.\n//\n// https://go-review.googlesource.com/c/go/+/393354/\nfunc init() {\n\tinternal.SetRlimit()\n\tenableRecurse = true\n}\n\nfunc TestScript(t *testing.T) {\n\terr := filepath.Walk(\"./testdata\", func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil || info.IsDir() {\n\t\t\treturn err\n\t\t}\n\t\tn := strings.Split(filepath.ToSlash(path), \"/\")\n\t\tt.Run(strings.Join(n[1:], \"/\"), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\td, err := os.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tparseScript(t, string(d))\n\t\t})\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Multiple writes to a file with the same fd.\nfunc TestWatchMultipleWrite(t *testing.T) {\n\tt.Parallel()\n\tw := newCollector(t)\n\tw.collect(t)\n\ttmp := t.TempDir()\n\n\techoAppend(t, \"data\", tmp, \"file\")\n\taddWatch(t, w.w, tmp)\n\tfp, err := os.OpenFile(join(tmp, \"file\"), os.O_RDWR, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := fp.Write([]byte(\"X\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := fp.Sync(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\teventSeparator()\n\tif _, err := fp.Write([]byte(\"Y\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := fp.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcmpEvents(t, tmp, w.stop(t), newEvents(t, `\n\t\twrite  /file  # write X\n\t\twrite  /file  # write Y\n\t`))\n}\n\n// Remove watched file with open fd\nfunc TestWatchRemoveOpenFd(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Windows hard-locks open files so this will never work\")\n\t}\n\n\tt.Parallel()\n\ttmp := t.TempDir()\n\tw := newCollector(t)\n\tw.collect(t)\n\n\ttouch(t, tmp, \"/file\")\n\n\tfp, err := os.Open(join(tmp, \"/file\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer fp.Close()\n\n\taddWatch(t, w.w, tmp, \"/file\")\n\trm(t, tmp, \"/file\")\n\n\tcmpEvents(t, tmp, w.stop(t), newEvents(t, `\n\t\tremove   /file\n\n\t\t# inotify will just emit a CHMOD for the unlink, but won't actually\n\t\t# emit a REMOVE until the descriptor is closed. Bit odd, but not much\n\t\t# we can do about it. The REMOVE is tested in TestInotifyDeleteOpenFile()\n\t\tlinux:\n\t\t\tchmod  /file\n\t`))\n}\n\n// Remove watched directory\nfunc TestWatchRemoveWatchedDir(t *testing.T) {\n\tif runtime.GOOS == \"dragonfly\" {\n\t\tt.Skip(\"broken: inconsistent events\") // TODO\n\t}\n\n\tt.Parallel()\n\ttmp := t.TempDir()\n\tw := newCollector(t)\n\tw.collect(t)\n\n\ttouch(t, tmp, \"a\")\n\ttouch(t, tmp, \"b\")\n\ttouch(t, tmp, \"c\")\n\ttouch(t, tmp, \"d\")\n\ttouch(t, tmp, \"e\")\n\ttouch(t, tmp, \"f\")\n\ttouch(t, tmp, \"g\")\n\tmkdir(t, tmp, \"h\")\n\tmkdir(t, tmp, \"h\", \"a\")\n\tmkdir(t, tmp, \"i\")\n\tmkdir(t, tmp, \"i\", \"a\")\n\tmkdir(t, tmp, \"j\")\n\tmkdir(t, tmp, \"j\", \"a\")\n\taddWatch(t, w.w, tmp)\n\trmAll(t, tmp)\n\n\tif runtime.GOOS != \"windows\" {\n\t\tcmpEvents(t, tmp, w.stop(t), newEvents(t, `\n\t\t\t\tremove    /\n\t\t\t\tremove    /a\n\t\t\t\tremove    /b\n\t\t\t\tremove    /c\n\t\t\t\tremove    /d\n\t\t\t\tremove    /e\n\t\t\t\tremove    /f\n\t\t\t\tremove    /g\n\t\t\t\tremove    /h\n\t\t\t\tremove    /i\n\t\t\t\tremove    /j`))\n\t\treturn\n\t}\n\n\t// ReadDirectoryChangesW gives undefined results: not all files are\n\t// always present. So test only that 1) we got the directory itself, and\n\t// 2) we don't get events for unspected files.\n\tvar (\n\t\tevents = w.stop(t)\n\t\tfound  bool\n\t)\n\tfor _, e := range events {\n\t\tif e.Name == tmp && e.Has(Remove) {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tif filepath.Dir(e.Name) != tmp {\n\t\t\tt.Errorf(\"unexpected event: %s\", e)\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatalf(\"didn't see directory in:\\n%s\", events)\n\t}\n}\n\nfunc TestClose(t *testing.T) {\n\tchanClosed := func(t *testing.T, w *Watcher) {\n\t\tt.Helper()\n\n\t\t// Need a small sleep as Close() on kqueue does all sorts of things,\n\t\t// which may take a little bit.\n\t\tswitch runtime.GOOS {\n\t\tcase \"freebsd\", \"openbsd\", \"netbsd\", \"dragonfly\", \"darwin\", \"solaris\", \"illumos\":\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\n\t\ttim := time.NewTimer(50 * time.Millisecond)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tdefault:\n\t\t\t\tt.Fatal(\"blocking on Events\")\n\t\t\tcase <-tim.C:\n\t\t\t\tt.Fatalf(\"Events not closed\")\n\t\t\tcase _, ok := <-w.Events:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tselect {\n\t\tdefault:\n\t\t\tt.Fatal(\"blocking on Errors\")\n\t\tcase err, ok := <-w.Errors:\n\t\t\tif ok {\n\t\t\t\tt.Fatalf(\"Errors not closed; read:\\n\\t%s\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tt.Run(\"close\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := newWatcher(t)\n\t\tif err := w.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tchanClosed(t, w)\n\n\t\tvar done int32\n\t\tgo func() {\n\t\t\tw.Close()\n\t\t\tatomic.StoreInt32(&done, 1)\n\t\t}()\n\n\t\teventSeparator()\n\t\tif atomic.LoadInt32(&done) == 0 {\n\t\t\tt.Fatal(\"double Close() test failed: second Close() call didn't return\")\n\t\t}\n\n\t\tif err := w.Add(t.TempDir()); err == nil {\n\t\t\tt.Fatal(\"expected error on Watch() after Close(), got nil\")\n\t\t}\n\t})\n\n\t// Make sure that Close() works even when the Events channel isn't being\n\t// read.\n\tt.Run(\"events not read\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\tw := newWatcher(t, tmp)\n\n\t\ttouch(t, tmp, \"file\")\n\t\trm(t, tmp, \"file\")\n\t\teventSeparator()\n\t\tif err := w.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// TODO: windows backend doesn't work well here; can't easily fix it.\n\t\t//       Need to rewrite things a bit.\n\t\tif runtime.GOOS != \"windows\" {\n\t\t\tchanClosed(t, w)\n\t\t}\n\t})\n\n\t// Make sure that calling Close() while REMOVE events are emitted doesn't race.\n\tt.Run(\"close while removing files\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttmp := t.TempDir()\n\n\t\tfiles := make([]string, 0, 200)\n\t\tfor i := 0; i < 200; i++ {\n\t\t\tf := join(tmp, fmt.Sprintf(\"file-%03d\", i))\n\t\t\ttouch(t, f, noWait)\n\t\t\tfiles = append(files, f)\n\t\t}\n\n\t\tw := newWatcher(t, tmp)\n\n\t\tstartC, stopC, errC := make(chan struct{}), make(chan struct{}), make(chan error)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-w.Errors:\n\t\t\t\tcase <-w.Events:\n\t\t\t\tcase <-stopC:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\trmDone := make(chan struct{})\n\t\tgo func() {\n\t\t\t<-startC\n\t\t\tfor _, f := range files {\n\t\t\t\trm(t, f, noWait)\n\t\t\t}\n\t\t\trmDone <- struct{}{}\n\t\t}()\n\t\tgo func() {\n\t\t\t<-startC\n\t\t\terrC <- w.Close()\n\t\t}()\n\t\tclose(startC)\n\t\tdefer close(stopC)\n\t\tif err := <-errC; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t<-rmDone\n\t})\n\n\t// Make sure Close() doesn't race when called more than once; hard to write\n\t// a good reproducible test for this, but running it 150 times seems to\n\t// reproduce it in ~75% of cases and isn't too slow (~0.06s on my system).\n\tt.Run(\"double close\", func(t *testing.T) {\n\t\tt.Run(\"default\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfor i := 0; i < 150; i++ {\n\t\t\t\tw, err := NewWatcher()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif strings.Contains(err.Error(), \"too many\") { // syscall.EMFILE\n\t\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tgo w.Close()\n\t\t\t\tgo w.Close()\n\t\t\t\tgo w.Close()\n\t\t\t}\n\t\t})\n\t\tt.Run(\"buffered=4096\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfor i := 0; i < 150; i++ {\n\t\t\t\tw, err := NewBufferedWatcher(4096)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif strings.Contains(err.Error(), \"too many\") { // syscall.EMFILE\n\t\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tgo w.Close()\n\t\t\t\tgo w.Close()\n\t\t\t\tgo w.Close()\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"closes channels after read\", func(t *testing.T) {\n\t\tif runtime.GOOS == \"netbsd\" {\n\t\t\tt.Skip(\"flaky\") // TODO\n\t\t}\n\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\n\t\tw := newCollector(t, tmp)\n\t\tw.collect(t)\n\t\ttouch(t, tmp, \"qwe\")\n\t\ttouch(t, tmp, \"asd\")\n\n\t\tif err := w.w.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tchanClosed(t, w.w)\n\t})\n\n\tt.Run(\"error after closed\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\tw := newWatcher(t, tmp)\n\t\tif err := w.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfile := join(tmp, \"file\")\n\t\ttouch(t, file)\n\t\tif err := w.Add(file); !errors.Is(err, ErrClosed) {\n\t\t\tt.Fatalf(\"wrong error for Add: %#v\", err)\n\t\t}\n\t\tif err := w.Remove(file); err != nil {\n\t\t\tt.Fatalf(\"wrong error for Remove: %#v\", err)\n\t\t}\n\t\tif l := w.WatchList(); l != nil { // Should return an error, but meh :-/\n\t\t\tt.Fatalf(\"WatchList not nil: %#v\", l)\n\t\t}\n\t})\n}\n\nfunc TestAdd(t *testing.T) {\n\tt.Run(\"doesn't exist\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttmp := t.TempDir()\n\n\t\tw := newWatcher(t)\n\t\terr := w.Add(join(tmp, \"non-existent\"))\n\t\tif err == nil {\n\t\t\tt.Fatal(\"err is nil\")\n\t\t}\n\n\t\t// TODO(v2): errors for this are inconsistent; should be fixed in v2. See #144\n\t\tswitch runtime.GOOS {\n\t\tcase \"linux\":\n\t\t\tif _, ok := err.(syscall.Errno); !ok {\n\t\t\t\tt.Errorf(\"wrong error type: %[1]T: %#[1]v\", err)\n\t\t\t}\n\t\tcase \"windows\":\n\t\t\tif _, ok := err.(*os.SyscallError); !ok {\n\t\t\t\tt.Errorf(\"wrong error type: %[1]T: %#[1]v\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tif _, ok := err.(*fs.PathError); !ok {\n\t\t\t\tt.Errorf(\"wrong error type: %[1]T: %#[1]v\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"permission denied\", func(t *testing.T) {\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tt.Skip(\"chmod doesn't work on Windows\") // TODO: see if we can make a file unreadable\n\t\t}\n\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\tdir := join(tmp, \"dir-unreadable\")\n\t\tmkdir(t, dir)\n\t\ttouch(t, dir, \"/file\")\n\t\tchmod(t, 0, dir)\n\n\t\tw := newWatcher(t)\n\t\tdefer func() {\n\t\t\tw.Close()\n\t\t\tchmod(t, 0o755, dir) // Make TempDir() cleanup work\n\t\t}()\n\t\terr := w.Add(dir)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"error is nil\")\n\t\t}\n\t\tif !errors.Is(err, internal.UnixEACCES) {\n\t\t\tt.Errorf(\"not unix.EACCESS: %T %#[1]v\", err)\n\t\t}\n\t\tif !errors.Is(err, internal.SyscallEACCES) {\n\t\t\tt.Errorf(\"not syscall.EACCESS: %T %#[1]v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"add same path twice\", func(t *testing.T) {\n\t\ttmp := t.TempDir()\n\t\tw := newCollector(t)\n\t\tif err := w.w.Add(tmp); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := w.w.Add(tmp); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tw.collect(t)\n\t\ttouch(t, tmp, \"file\")\n\t\trm(t, tmp, \"file\")\n\n\t\tcmpEvents(t, tmp, w.events(t), newEvents(t, `\n\t\t\tcreate /file\n\t\t\tremove /file\n\t\t`))\n\t})\n}\n\nfunc TestRemove(t *testing.T) {\n\tt.Run(\"works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\ttouch(t, tmp, \"file\")\n\n\t\tw := newCollector(t)\n\t\tw.collect(t)\n\t\taddWatch(t, w.w, tmp)\n\t\tif err := w.w.Remove(tmp); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\techoAppend(t, \"data\", tmp, \"file\")\n\t\tchmod(t, 0o700, tmp, \"file\")\n\n\t\thave := w.stop(t)\n\t\tif len(have) > 0 {\n\t\t\tt.Errorf(\"received events; expected none:\\n%s\", have)\n\t\t}\n\t})\n\n\tt.Run(\"remove same dir twice\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\n\t\ttouch(t, tmp, \"file\")\n\n\t\tw := newWatcher(t)\n\t\tdefer w.Close()\n\n\t\taddWatch(t, w, tmp)\n\n\t\tif err := w.Remove(tmp); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr := w.Remove(tmp)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"no error\")\n\t\t}\n\t\tif !errors.Is(err, ErrNonExistentWatch) {\n\t\t\tt.Fatalf(\"wrong error: %T\", err)\n\t\t}\n\t})\n\n\t// Make sure that concurrent calls to Remove() don't race.\n\tt.Run(\"no race\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\ttouch(t, tmp, \"file\")\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tw := newWatcher(t)\n\t\t\tdefer w.Close()\n\t\t\taddWatch(t, w, tmp)\n\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer func() { done <- struct{}{} }()\n\t\t\t\tw.Remove(tmp)\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tdefer func() { done <- struct{}{} }()\n\t\t\t\tw.Remove(tmp)\n\t\t\t}()\n\t\t\t<-done\n\t\t\t<-done\n\t\t\tw.Close()\n\t\t}\n\t})\n\n\t// Make sure file handles are correctly released.\n\t//\n\t// regression test for #42 see https://gist.github.com/timshannon/603f92824c5294269797\n\tt.Run(\"\", func(t *testing.T) {\n\t\tw := newWatcher(t)\n\t\tdefer w.Close()\n\n\t\t// consume the events\n\t\tvar werr error\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase werr = <-w.Errors:\n\t\t\t\t\treturn\n\t\t\t\tcase <-w.Events:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttmp := t.TempDir()\n\t\tdir := join(tmp, \"child\")\n\t\taddWatch(t, w, tmp)\n\t\tmkdir(t, dir)\n\t\taddWatch(t, w, dir) // start watching child\n\t\trmWatch(t, w, dir)  // stop watching child\n\t\trmAll(t, dir)       // delete child dir\n\n\t\t// Child dir should no longer exist\n\t\t_, err := os.Stat(dir)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"dir %q should no longer exist!\", dir)\n\t\t}\n\t\tif _, ok := err.(*os.PathError); err != nil && !ok {\n\t\t\tt.Errorf(\"Expected a PathError, got %v\", err)\n\t\t}\n\n\t\tw.Close()\n\t\twg.Wait()\n\n\t\tif werr != nil {\n\t\t\tt.Fatal(werr)\n\t\t}\n\t})\n\n\tt.Run(\"remove with ... when non-recursive\", func(t *testing.T) {\n\t\tsupportsRecurse(t)\n\t\tt.Parallel()\n\n\t\ttmp := t.TempDir()\n\t\tw := newWatcher(t)\n\t\taddWatch(t, w, tmp)\n\n\t\tif err := w.Remove(join(tmp, \"...\")); err == nil {\n\t\t\tt.Fatal(\"err was nil\")\n\t\t}\n\t\tif err := w.Remove(tmp); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n}\n\nfunc TestEventString(t *testing.T) {\n\ttests := []struct {\n\t\tin   Event\n\t\twant string\n\t}{\n\t\t{Event{}, `[no events]   \"\"`},\n\t\t{Event{Name: \"/file\", Op: 0}, `[no events]   \"/file\"`},\n\n\t\t{Event{Name: \"/file\", Op: Chmod | Create},\n\t\t\t`CREATE|CHMOD  \"/file\"`},\n\t\t{Event{Name: \"/file\", Op: Rename},\n\t\t\t`RENAME        \"/file\"`},\n\t\t{Event{Name: \"/file\", Op: Remove},\n\t\t\t`REMOVE        \"/file\"`},\n\t\t{Event{Name: \"/file\", Op: Write | Chmod},\n\t\t\t`WRITE|CHMOD   \"/file\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\thave := tt.in.String()\n\t\t\tif have != tt.want {\n\t\t\t\tt.Errorf(\"\\nhave: %q\\nwant: %q\", have, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWatchList(t *testing.T) {\n\tt.Parallel()\n\n\ttmp := t.TempDir()\n\tfile := join(tmp, \"file\")\n\tother := join(tmp, \"other\")\n\n\ttouch(t, file)\n\ttouch(t, other)\n\n\tw := newWatcher(t, file, tmp)\n\tdefer w.Close()\n\n\thave := w.WatchList()\n\tsort.Strings(have)\n\twant := []string{tmp, file}\n\tif !reflect.DeepEqual(have, want) {\n\t\tt.Errorf(\"\\nhave: %s\\nwant: %s\", have, want)\n\t}\n}\n\nfunc TestOpHas(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    Op\n\t\th    Op\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"single bit match\",\n\t\t\to:    Remove,\n\t\t\th:    Remove,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single bit no match\",\n\t\t\to:    Remove,\n\t\t\th:    Create,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"two bits match\",\n\t\t\to:    Remove | Create,\n\t\t\th:    Create,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two bits no match\",\n\t\t\to:    Remove | Create,\n\t\t\th:    Chmod,\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.Has(tt.h); got != tt.want {\n\t\t\t\tt.Errorf(\"Has() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkWatch(b *testing.B) {\n\tdo := func(b *testing.B, w *Watcher) {\n\t\ttmp := b.TempDir()\n\t\tfile := join(tmp, \"file\")\n\t\terr := w.Add(tmp)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase err, ok := <-w.Errors:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tb.Error(err)\n\t\t\t\tcase _, ok := <-w.Events:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tfp, err := os.Create(file)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\terr = fp.Close()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t\terr = w.Close()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\twg.Wait()\n\t}\n\n\tb.Run(\"default\", func(b *testing.B) {\n\t\tw, err := NewWatcher()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=1\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(1)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=1024\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(1024)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=4096\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(4096)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n}\n\nfunc BenchmarkAddRemove(b *testing.B) {\n\tdo := func(b *testing.B, w *Watcher) {\n\t\ttmp := b.TempDir()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tif err := w.Add(tmp); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif err := w.Remove(tmp); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tb.Run(\"default\", func(b *testing.B) {\n\t\tw, err := NewWatcher()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=1\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(1)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=1024\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(1024)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n\tb.Run(\"buffered=4096\", func(b *testing.B) {\n\t\tw, err := NewBufferedWatcher(4096)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tdo(b, w)\n\t})\n}\n\n// Would panic on inotify: https://github.com/fsnotify/fsnotify/issues/616\nfunc TestRemoveRace(t *testing.T) {\n\tt.Parallel()\n\n\ttmp := t.TempDir()\n\tw := newCollector(t, tmp)\n\tw.collect(t)\n\n\tdir := join(tmp, \"/dir\")\n\tfor i := 0; i < 100; i++ {\n\t\tgo os.MkdirAll(dir, 0o0755)\n\t\tgo os.RemoveAll(dir)\n\t\tgo w.w.Add(dir)\n\t\tgo w.w.Remove(dir)\n\t}\n\ttime.Sleep(100 * time.Millisecond)\n\tw.stop(t)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2724609375,
          "content": "module github.com/fsnotify/fsnotify\n\ngo 1.17\n\nrequire golang.org/x/sys v0.13.0\n\nretract (\n\tv1.5.3 // Published an incorrect branch accidentally https://github.com/fsnotify/fsnotify/issues/445\n\tv1.5.0 // Contains symlink regression https://github.com/fsnotify/fsnotify/pull/394\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1494140625,
          "content": "golang.org/x/sys v0.13.0 h1:Af8nKPmuFypiUBjVoU9V20FiaFXOcuZI21p0ycVYYGE=\ngolang.org/x/sys v0.13.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 22.794921875,
          "content": "package fsnotify\n\nimport (\n\t\"fmt\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify/internal\"\n\t\"github.com/fsnotify/fsnotify/internal/ztest\"\n)\n\n// We wait a little bit after most commands; gives the system some time to sync\n// things and makes things more consistent across platforms.\nfunc eventSeparator() { time.Sleep(50 * time.Millisecond) }\nfunc waitForEvents()  { time.Sleep(500 * time.Millisecond) }\n\n// To test the buffered watcher we run the tests twice in the CI: once as \"go\n// test\" and once with FSNOTIFY_BUFFER set. This is a bit hacky, but saves\n// having to refactor a lot of this code. Besides, running the tests in the CI\n// more than once isn't a bad thing, since it helps catch flaky tests (should\n// probably run it even more).\nvar testBuffered = func() uint {\n\ts, ok := os.LookupEnv(\"FSNOTIFY_BUFFER\")\n\tif ok {\n\t\ti, err := strconv.ParseUint(s, 0, 0)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"FSNOTIFY_BUFFER: %s\", err))\n\t\t}\n\t\treturn uint(i)\n\t}\n\treturn 0\n}()\n\n// newWatcher initializes an fsnotify Watcher instance.\nfunc newWatcher(t *testing.T, add ...string) *Watcher {\n\tt.Helper()\n\n\tvar (\n\t\tw   *Watcher\n\t\terr error\n\t)\n\tif testBuffered > 0 {\n\t\tw, err = NewBufferedWatcher(testBuffered)\n\t} else {\n\t\tw, err = NewWatcher()\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"newWatcher: %s\", err)\n\t}\n\tfor _, a := range add {\n\t\terr := w.Add(a)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"newWatcher: add %q: %s\", a, err)\n\t\t}\n\t}\n\treturn w\n}\n\n// addWatch adds a watch for a directory\nfunc addWatch(t *testing.T, w *Watcher, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"addWatch: path must have at least one element: %s\", path)\n\t}\n\terr := w.Add(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"addWatch(%q): %s\", join(path...), err)\n\t}\n}\n\n// rmWatch removes a watch.\nfunc rmWatch(t *testing.T, watcher *Watcher, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"rmWatch: path must have at least one element: %s\", path)\n\t}\n\terr := watcher.Remove(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"rmWatch(%q): %s\", join(path...), err)\n\t}\n}\n\nconst noWait = \"\"\n\nfunc shouldWait(path ...string) bool {\n\t// Take advantage of the fact that join skips empty parameters.\n\tfor _, p := range path {\n\t\tif p == \"\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Create n empty files with the prefix in the directory dir.\nfunc createFiles(t *testing.T, dir, prefix string, n int, d time.Duration) int {\n\tt.Helper()\n\n\tif d == 0 {\n\t\td = 9 * time.Minute\n\t}\n\n\tfmtNum := func(n int) string {\n\t\ts := fmt.Sprintf(\"%09d\", n)\n\t\treturn s[:3] + \"_\" + s[3:6] + \"_\" + s[6:]\n\t}\n\n\tvar (\n\t\tmax     = time.After(d)\n\t\tcreated int\n\t)\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase <-max:\n\t\t\tt.Logf(\"createFiles: stopped at %s files because it took longer than %s\", fmtNum(created), d)\n\t\t\treturn created\n\t\tdefault:\n\t\t\tpath := join(dir, prefix+fmtNum(i))\n\t\t\tfp, err := os.Create(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"create failed for %s: %s\", fmtNum(i), err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := fp.Close(); err != nil {\n\t\t\t\tt.Errorf(\"close failed for %s: %s\", fmtNum(i), err)\n\t\t\t}\n\t\t\tif err := os.Remove(path); err != nil {\n\t\t\t\tt.Errorf(\"remove failed for %s: %s\", fmtNum(i), err)\n\t\t\t}\n\t\t\tif i%10_000 == 0 {\n\t\t\t\tt.Logf(\"createFiles: %s\", fmtNum(i))\n\t\t\t}\n\t\t\tcreated++\n\t\t}\n\t}\n\treturn created\n}\n\n// mkdir\nfunc mkdir(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"mkdir: path must have at least one element: %s\", path)\n\t}\n\terr := os.Mkdir(join(path...), 0o0755)\n\tif err != nil {\n\t\tt.Fatalf(\"mkdir(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// mkdir -p\nfunc mkdirAll(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"mkdirAll: path must have at least one element: %s\", path)\n\t}\n\terr := os.MkdirAll(join(path...), 0o0755)\n\tif err != nil {\n\t\tt.Fatalf(\"mkdirAll(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// ln -s\nfunc symlink(t *testing.T, target string, link ...string) {\n\tt.Helper()\n\tif len(link) < 1 {\n\t\tt.Fatalf(\"symlink: link must have at least one element: %s\", link)\n\t}\n\terr := os.Symlink(target, join(link...))\n\tif err != nil {\n\t\tt.Fatalf(\"symlink(%q, %q): %s\", target, join(link...), err)\n\t}\n\tif shouldWait(link...) {\n\t\teventSeparator()\n\t}\n}\n\n// mkfifo\nfunc mkfifo(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"mkfifo: path must have at least one element: %s\", path)\n\t}\n\terr := internal.Mkfifo(join(path...), 0o644)\n\tif err != nil {\n\t\tt.Fatalf(\"mkfifo(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// mknod\nfunc mknod(t *testing.T, dev int, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"mknod: path must have at least one element: %s\", path)\n\t}\n\terr := internal.Mknod(join(path...), 0o644, dev)\n\tif err != nil {\n\t\tt.Fatalf(\"mknod(%d, %q): %s\", dev, join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// echo > and echo >>\nfunc echoAppend(t *testing.T, data string, path ...string) { t.Helper(); echo(t, false, data, path...) }\nfunc echoTrunc(t *testing.T, data string, path ...string)  { t.Helper(); echo(t, true, data, path...) }\nfunc echo(t *testing.T, trunc bool, data string, path ...string) {\n\tn := \"echoAppend\"\n\tif trunc {\n\t\tn = \"echoTrunc\"\n\t}\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"%s: path must have at least one element: %s\", n, path)\n\t}\n\n\terr := func() error {\n\t\tvar (\n\t\t\tfp  *os.File\n\t\t\terr error\n\t\t)\n\t\tif trunc {\n\t\t\tfp, err = os.Create(join(path...))\n\t\t} else {\n\t\t\tfp, err = os.OpenFile(join(path...), os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := fp.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif shouldWait(path...) {\n\t\t\teventSeparator()\n\t\t}\n\t\tif _, err := fp.WriteString(data); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := fp.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif shouldWait(path...) {\n\t\t\teventSeparator()\n\t\t}\n\t\treturn fp.Close()\n\t}()\n\tif err != nil {\n\t\tt.Fatalf(\"%s(%q): %s\", n, join(path...), err)\n\t}\n}\n\n// touch\nfunc touch(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"touch: path must have at least one element: %s\", path)\n\t}\n\tfp, err := os.Create(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"touch(%q): %s\", join(path...), err)\n\t}\n\terr = fp.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"touch(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// mv\nfunc mv(t *testing.T, src string, dst ...string) {\n\tt.Helper()\n\tif len(dst) < 1 {\n\t\tt.Fatalf(\"mv: dst must have at least one element: %s\", dst)\n\t}\n\n\terr := os.Rename(src, join(dst...))\n\tif err != nil {\n\t\tt.Fatalf(\"mv(%q, %q): %s\", src, join(dst...), err)\n\t}\n\tif shouldWait(dst...) {\n\t\teventSeparator()\n\t}\n}\n\n// rm\nfunc rm(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"rm: path must have at least one element: %s\", path)\n\t}\n\terr := os.Remove(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"rm(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// rm -r\nfunc rmAll(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"rmAll: path must have at least one element: %s\", path)\n\t}\n\terr := os.RemoveAll(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"rmAll(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// cat\nfunc cat(t *testing.T, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"cat: path must have at least one element: %s\", path)\n\t}\n\t_, err := os.ReadFile(join(path...))\n\tif err != nil {\n\t\tt.Fatalf(\"cat(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// chmod\nfunc chmod(t *testing.T, mode fs.FileMode, path ...string) {\n\tt.Helper()\n\tif len(path) < 1 {\n\t\tt.Fatalf(\"chmod: path must have at least one element: %s\", path)\n\t}\n\terr := os.Chmod(join(path...), mode)\n\tif err != nil {\n\t\tt.Fatalf(\"chmod(%q): %s\", join(path...), err)\n\t}\n\tif shouldWait(path...) {\n\t\teventSeparator()\n\t}\n}\n\n// Collect all events in an array.\n//\n// w := newCollector(t)\n// w.collect(r)\n//\n// .. do stuff ..\n//\n// events := w.stop(t)\ntype eventCollector struct {\n\tw    *Watcher\n\te    Events\n\tmu   sync.Mutex\n\tdone chan struct{}\n}\n\nfunc newCollector(t *testing.T, add ...string) *eventCollector {\n\treturn &eventCollector{\n\t\tw:    newWatcher(t, add...),\n\t\tdone: make(chan struct{}),\n\t\te:    make(Events, 0, 8),\n\t}\n}\n\n// stop collecting events and return what we've got.\nfunc (w *eventCollector) stop(t *testing.T) Events {\n\treturn w.stopWait(t, time.Second)\n}\n\nfunc (w *eventCollector) stopWait(t *testing.T, waitFor time.Duration) Events {\n\twaitForEvents()\n\n\tgo func() {\n\t\terr := w.w.Close()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-time.After(waitFor):\n\t\tt.Fatalf(\"event stream was not closed after %s\", waitFor)\n\tcase <-w.done:\n\t}\n\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\treturn w.e\n}\n\n// Get all events we've found up to now and clear the event buffer.\nfunc (w *eventCollector) events(t *testing.T) Events {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\te := make(Events, len(w.e))\n\tcopy(e, w.e)\n\tw.e = make(Events, 0, 16)\n\treturn e\n}\n\n// Start collecting events.\nfunc (w *eventCollector) collect(t *testing.T) {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase e, ok := <-w.w.Errors:\n\t\t\t\tif !ok {\n\t\t\t\t\tw.done <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tt.Error(e)\n\t\t\t\tw.done <- struct{}{}\n\t\t\t\treturn\n\t\t\tcase e, ok := <-w.w.Events:\n\t\t\t\tif !ok {\n\t\t\t\t\tw.done <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tw.mu.Lock()\n\t\t\t\tw.e = append(w.e, e)\n\t\t\t\tw.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}()\n}\n\ntype Events []Event\n\nfunc (e Events) String() string {\n\tb := new(strings.Builder)\n\tfor i, ee := range e {\n\t\tif i > 0 {\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t\tif ee.renamedFrom != \"\" {\n\t\t\tfmt.Fprintf(b, \"%-8s %s ← %s\", ee.Op.String(), filepath.ToSlash(ee.Name), filepath.ToSlash(ee.renamedFrom))\n\t\t} else {\n\t\t\tfmt.Fprintf(b, \"%-8s %s\", ee.Op.String(), filepath.ToSlash(ee.Name))\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc (e Events) TrimPrefix(prefix string) Events {\n\tfor i := range e {\n\t\tif e[i].Name == prefix {\n\t\t\te[i].Name = \"/\"\n\t\t} else {\n\t\t\te[i].Name = strings.TrimPrefix(e[i].Name, prefix)\n\t\t}\n\t\tif e[i].renamedFrom == prefix {\n\t\t\te[i].renamedFrom = \"/\"\n\t\t} else {\n\t\t\te[i].renamedFrom = strings.TrimPrefix(e[i].renamedFrom, prefix)\n\t\t}\n\t}\n\treturn e\n}\n\nfunc (e Events) copy() Events {\n\tcp := make(Events, len(e))\n\tcopy(cp, e)\n\treturn cp\n}\n\n// Create a new Events list from a string; for example:\n//\n//\tCREATE        path\n//\tCREATE|WRITE  path\n//\n// Every event is one line, and any whitespace between the event and path are\n// ignored. The path can optionally be surrounded in \". Anything after a \"#\" is\n// ignored.\n//\n// Platform-specific tests can be added after GOOS:\n//\n//\t# Tested if nothing else matches\n//\tCREATE   path\n//\n//\t# Windows-specific test.\n//\twindows:\n//\t  WRITE    path\n//\n// You can specify multiple platforms with a comma (e.g. \"windows, linux:\").\n// \"kqueue\" is a shortcut for all kqueue systems (BSD, macOS).\nfunc newEvents(t *testing.T, s string) Events {\n\tt.Helper()\n\n\tvar (\n\t\tlines  = strings.Split(s, \"\\n\")\n\t\tgroups = []string{\"\"}\n\t\tevents = make(map[string]Events)\n\t)\n\tfor no, line := range lines {\n\t\tif i := strings.IndexByte(line, '#'); i > -1 {\n\t\t\tline = line[:i]\n\t\t}\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasSuffix(line, \":\") {\n\t\t\tgroups = strings.Split(strings.TrimRight(line, \":\"), \",\")\n\t\t\tfor i := range groups {\n\t\t\t\tgroups[i] = strings.TrimSpace(groups[i])\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tif len(fields) != 2 && len(fields) != 4 {\n\t\t\tif strings.ToLower(fields[0]) == \"empty\" || strings.ToLower(fields[0]) == \"no-events\" {\n\t\t\t\tfor _, g := range groups {\n\t\t\t\t\tevents[g] = Events{}\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Fatalf(\"newEvents: line %d: needs 2 or 4 fields: %s\", no+1, line)\n\t\t}\n\n\t\tvar op Op\n\t\tfor _, ee := range strings.Split(fields[0], \"|\") {\n\t\t\tswitch strings.ToUpper(ee) {\n\t\t\tcase \"CREATE\":\n\t\t\t\top |= Create\n\t\t\tcase \"WRITE\":\n\t\t\t\top |= Write\n\t\t\tcase \"REMOVE\":\n\t\t\t\top |= Remove\n\t\t\tcase \"RENAME\":\n\t\t\t\top |= Rename\n\t\t\tcase \"CHMOD\":\n\t\t\t\top |= Chmod\n\t\t\tcase \"OPEN\":\n\t\t\t\top |= xUnportableOpen\n\t\t\tcase \"READ\":\n\t\t\t\top |= xUnportableRead\n\t\t\tcase \"CLOSE_WRITE\":\n\t\t\t\top |= xUnportableCloseWrite\n\t\t\tcase \"CLOSE_READ\":\n\t\t\t\top |= xUnportableCloseRead\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"newEvents: line %d has unknown event %q: %s\", no+1, ee, line)\n\t\t\t}\n\t\t}\n\n\t\tvar from string\n\t\tif len(fields) > 2 {\n\t\t\tif fields[2] != \"←\" {\n\t\t\t\tt.Fatalf(\"newEvents: line %d: invalid format: %s\", no+1, line)\n\t\t\t}\n\t\t\tfrom = strings.Trim(fields[3], `\"`)\n\t\t}\n\t\tif !supportsRename() {\n\t\t\tfrom = \"\"\n\t\t}\n\n\t\tfor _, g := range groups {\n\t\t\tevents[g] = append(events[g], Event{Name: strings.Trim(fields[1], `\"`), renamedFrom: from, Op: op})\n\t\t}\n\t}\n\n\tif e, ok := events[runtime.GOOS]; ok {\n\t\treturn e\n\t}\n\tswitch runtime.GOOS {\n\t// kqueue shortcut\n\tcase \"freebsd\", \"netbsd\", \"openbsd\", \"dragonfly\", \"darwin\":\n\t\tif e, ok := events[\"kqueue\"]; ok {\n\t\t\treturn e\n\t\t}\n\t// fen shortcut\n\tcase \"solaris\", \"illumos\":\n\t\tif e, ok := events[\"fen\"]; ok {\n\t\t\treturn e\n\t\t}\n\t}\n\treturn events[\"\"]\n}\n\nfunc cmpEvents(t *testing.T, tmp string, have, want Events) {\n\tt.Helper()\n\n\thave = have.TrimPrefix(tmp)\n\n\thaveSort, wantSort := have.copy(), want.copy()\n\tsort.Slice(haveSort, func(i, j int) bool {\n\t\treturn haveSort[i].String() > haveSort[j].String()\n\t})\n\tsort.Slice(wantSort, func(i, j int) bool {\n\t\treturn wantSort[i].String() > wantSort[j].String()\n\t})\n\n\tif haveSort.String() != wantSort.String() {\n\t\tb := new(strings.Builder)\n\t\tb.WriteString(strings.TrimSpace(ztest.Diff(indent(haveSort), indent(wantSort))))\n\t\tt.Errorf(\"\\nhave:\\n%s\\nwant:\\n%s\\ndiff:\\n%s\", indent(have), indent(want), indent(b))\n\t}\n}\n\nfunc indent(s fmt.Stringer) string {\n\treturn \"\\t\" + strings.ReplaceAll(s.String(), \"\\n\", \"\\n\\t\")\n}\n\nvar join = filepath.Join\n\nfunc isKqueue() bool {\n\tswitch runtime.GOOS {\n\tcase \"darwin\", \"freebsd\", \"openbsd\", \"netbsd\", \"dragonfly\":\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isSolaris() bool {\n\tswitch runtime.GOOS {\n\tcase \"illumos\", \"solaris\":\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc supportsRecurse(t *testing.T) {\n\tswitch runtime.GOOS {\n\tcase \"windows\", \"linux\":\n\t\t// Run test.\n\tdefault:\n\t\tt.Skip(\"recursion not yet supported on \" + runtime.GOOS)\n\t}\n}\n\nfunc supportsFilter(t *testing.T) {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\t// Run test.\n\tdefault:\n\t\tt.Skip(\"withOps() not yet supported on \" + runtime.GOOS)\n\t}\n}\n\nfunc supportsRename() bool {\n\tswitch runtime.GOOS {\n\tcase \"linux\", \"windows\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc supportsNofollow(t *testing.T) {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\t// Run test.\n\tdefault:\n\t\tt.Skip(\"withNoFollow() not yet supported on \" + runtime.GOOS)\n\t}\n}\n\nfunc tmppath(tmp, s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\tif !strings.HasPrefix(s, \"./\") {\n\t\treturn filepath.Join(tmp, s)\n\t}\n\t// Needed for creating relative links. Support that only with explicit \"./\"\n\t// – otherwise too easy to forget leading \"/\" and create files outside of\n\t// the tmp dir.\n\treturn s\n}\n\ntype command struct {\n\tline int\n\tcmd  string\n\targs []string\n}\n\nfunc parseScript(t *testing.T, in string) {\n\tvar (\n\t\tlines = strings.Split(in, \"\\n\")\n\t\tcmds  = make([]command, 0, 8)\n\t\treadW bool\n\t\twant  string\n\t\ttmp   = t.TempDir()\n\t)\n\tfor i, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" || line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\t\tif i := strings.IndexByte(line, '#'); i > -1 {\n\t\t\tline = strings.TrimSpace(line[:i])\n\t\t}\n\t\tif line == \"Output:\" {\n\t\t\treadW = true\n\t\t\tcontinue\n\t\t}\n\t\tif readW {\n\t\t\twant += line + \"\\n\"\n\t\t\tcontinue\n\t\t}\n\n\t\tcmd := command{line: i + 1, args: make([]string, 0, 4)}\n\t\tvar (\n\t\t\tq   bool\n\t\t\tcur = make([]rune, 0, 16)\n\t\t\tapp = func() {\n\t\t\t\tif len(cur) == 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif cmd.cmd == \"\" {\n\t\t\t\t\tcmd.cmd = string(cur)\n\t\t\t\t} else {\n\t\t\t\t\tcmd.args = append(cmd.args, string(cur))\n\t\t\t\t}\n\t\t\t\tcur = cur[:0]\n\t\t\t}\n\t\t)\n\t\tfor _, c := range line {\n\t\t\tswitch c {\n\t\t\tcase ' ', '\\t':\n\t\t\t\tif q {\n\t\t\t\t\tcur = append(cur, c)\n\t\t\t\t} else {\n\t\t\t\t\tapp()\n\t\t\t\t}\n\t\t\tcase '\"', '\\'': // '\n\t\t\t\tq = !q\n\t\t\tdefault:\n\t\t\t\tcur = append(cur, c)\n\t\t\t}\n\t\t}\n\t\tapp()\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\tvar (\n\t\tdo      = make([]func(), 0, len(cmds))\n\t\tw       = newCollector(t)\n\t\tmustArg = func(c command, n int) {\n\t\t\tif len(c.args) != n {\n\t\t\t\tt.Fatalf(\"line %d: %q requires exactly %d argument (have %d: %q)\",\n\t\t\t\t\tc.line, c.cmd, n, len(c.args), c.args)\n\t\t\t}\n\t\t}\n\t)\nloop:\n\tfor _, c := range cmds {\n\t\tc := c\n\t\t//fmt.Printf(\"line %d: %q  %q\\n\", c.line, c.cmd, c.args)\n\t\tswitch c.cmd {\n\t\tcase \"skip\", \"require\":\n\t\t\tmustArg(c, 1)\n\t\t\tswitch c.args[0] {\n\t\t\tcase \"op_all\":\n\t\t\t\tif runtime.GOOS != \"linux\" {\n\t\t\t\t\tt.Skip(\"No op_all on this platform\")\n\t\t\t\t}\n\t\t\tcase \"op_open\":\n\t\t\t\tif runtime.GOOS != \"linux\" {\n\t\t\t\t\tt.Skip(\"No Open on this platform\")\n\t\t\t\t}\n\t\t\tcase \"op_read\":\n\t\t\t\tif runtime.GOOS != \"linux\" {\n\t\t\t\t\tt.Skip(\"No Read on this platform\")\n\t\t\t\t}\n\t\t\tcase \"op_close_write\":\n\t\t\t\tif runtime.GOOS != \"linux\" {\n\t\t\t\t\tt.Skip(\"No CloseWrite on this platform\")\n\t\t\t\t}\n\t\t\tcase \"op_close_read\":\n\t\t\t\tif runtime.GOOS != \"linux\" {\n\t\t\t\t\tt.Skip(\"No CloseRead on this platform\")\n\t\t\t\t}\n\t\t\tcase \"always\":\n\t\t\t\tt.Skip()\n\t\t\tcase \"symlink\":\n\t\t\t\tif !internal.HasPrivilegesForSymlink() {\n\t\t\t\t\tt.Skipf(\"%s symlink: admin permissions required on Windows\", c.cmd)\n\t\t\t\t}\n\t\t\tcase \"mkfifo\":\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tt.Skip(\"No named pipes on Windows\")\n\t\t\t\t}\n\t\t\tcase \"mknod\":\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tt.Skip(\"No device nodes on Windows\")\n\t\t\t\t}\n\t\t\t\tif isKqueue() {\n\t\t\t\t\t// Don't want to use os/user to check uid, since that pulls\n\t\t\t\t\t// in cgo by default and stuff that uses fsnotify won't be\n\t\t\t\t\t// statically linked by default.\n\t\t\t\t\tt.Skip(\"needs root on BSD\")\n\t\t\t\t}\n\t\t\t\tif isSolaris() {\n\t\t\t\t\tt.Skip(`\"mknod fails with \"not owner\"`)\n\t\t\t\t}\n\t\t\tcase \"recurse\":\n\t\t\t\tsupportsRecurse(t)\n\t\t\tcase \"filter\":\n\t\t\t\tsupportsFilter(t)\n\t\t\tcase \"nofollow\":\n\t\t\t\tsupportsNofollow(t)\n\t\t\tcase \"windows\":\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tt.Skip(\"Skipping on Windows\")\n\t\t\t\t}\n\t\t\tcase \"netbsd\":\n\t\t\t\tif runtime.GOOS == \"netbsd\" {\n\t\t\t\t\tt.Skip(\"Skipping on NetBSD\")\n\t\t\t\t}\n\t\t\tcase \"openbsd\":\n\t\t\t\tif runtime.GOOS == \"openbsd\" {\n\t\t\t\t\tt.Skip(\"Skipping on OpenBSD\")\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"line %d: unknown %s reason: %q\", c.line, c.cmd, c.args[0])\n\t\t\t}\n\t\t//case \"state\":\n\t\t//\tmustArg(c, 0)\n\t\t//\tdo = append(do, func() { eventSeparator(); fmt.Fprintln(os.Stderr); w.w.state(); fmt.Fprintln(os.Stderr) })\n\t\tcase \"debug\":\n\t\t\tmustArg(c, 1)\n\t\t\tswitch c.args[0] {\n\t\t\tcase \"1\", \"on\", \"true\", \"yes\":\n\t\t\t\tdo = append(do, func() { debug = true })\n\t\t\tcase \"0\", \"off\", \"false\", \"no\":\n\t\t\t\tdo = append(do, func() { debug = false })\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"line %d: unknown debug: %q\", c.line, c.args[0])\n\t\t\t}\n\t\tcase \"stop\":\n\t\t\tmustArg(c, 0)\n\t\t\tbreak loop\n\t\tcase \"watch\":\n\t\t\tif len(c.args) < 1 {\n\t\t\t\tt.Fatalf(\"line %d: %q requires at least %d arguments (have %d: %q)\",\n\t\t\t\t\tc.line, c.cmd, 1, len(c.args), c.args)\n\t\t\t}\n\t\t\tif len(c.args) == 1 {\n\t\t\t\tdo = append(do, func() { addWatch(t, w.w, tmppath(tmp, c.args[0])) })\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar follow addOpt\n\t\t\tfor i := range c.args {\n\t\t\t\tif c.args[i] == \"nofollow\" || c.args[i] == \"no-follow\" {\n\t\t\t\t\tc.args = append(c.args[:i], c.args[i+1:]...)\n\t\t\t\t\tfollow = withNoFollow()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar op Op\n\t\t\tfor _, o := range c.args[1:] {\n\t\t\t\tswitch strings.ToLower(o) {\n\t\t\t\tdefault:\n\t\t\t\t\tt.Fatalf(\"line %d: unknown: %q\", c.line+1, o)\n\t\t\t\tcase \"default\":\n\t\t\t\t\top |= Create | Write | Remove | Rename | Chmod\n\t\t\t\tcase \"create\":\n\t\t\t\t\top |= Create\n\t\t\t\tcase \"write\":\n\t\t\t\t\top |= Write\n\t\t\t\tcase \"remove\":\n\t\t\t\t\top |= Remove\n\t\t\t\tcase \"rename\":\n\t\t\t\t\top |= Rename\n\t\t\t\tcase \"chmod\":\n\t\t\t\t\top |= Chmod\n\t\t\t\tcase \"open\":\n\t\t\t\t\top |= xUnportableOpen\n\t\t\t\tcase \"read\":\n\t\t\t\t\top |= xUnportableRead\n\t\t\t\tcase \"close_write\":\n\t\t\t\t\top |= xUnportableCloseWrite\n\t\t\t\tcase \"close_read\":\n\t\t\t\t\top |= xUnportableCloseRead\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo = append(do, func() {\n\t\t\t\tp := tmppath(tmp, c.args[0])\n\t\t\t\terr := w.w.AddWith(p, withOps(op), follow)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"line %d: addWatch(%q): %s\", c.line+1, p, err)\n\t\t\t\t}\n\t\t\t})\n\t\tcase \"unwatch\":\n\t\t\tmustArg(c, 1)\n\t\t\tdo = append(do, func() { rmWatch(t, w.w, tmppath(tmp, c.args[0])) })\n\t\tcase \"watchlist\":\n\t\t\tmustArg(c, 1)\n\t\t\tn, err := strconv.ParseInt(c.args[0], 10, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"line %d: %s\", c.line, err)\n\t\t\t}\n\t\t\tdo = append(do, func() {\n\t\t\t\twl := w.w.WatchList()\n\t\t\t\tif l := int64(len(wl)); l != n {\n\t\t\t\t\tt.Errorf(\"line %d: watchlist has %d entries, not %d\\n%q\", c.line, l, n, wl)\n\t\t\t\t}\n\t\t\t})\n\t\tcase \"touch\":\n\t\t\tmustArg(c, 1)\n\t\t\tdo = append(do, func() { touch(t, tmppath(tmp, c.args[0])) })\n\t\tcase \"mkdir\":\n\t\t\trecur := false\n\t\t\tif len(c.args) == 2 && c.args[0] == \"-p\" {\n\t\t\t\trecur, c.args = true, c.args[1:]\n\t\t\t}\n\t\t\tmustArg(c, 1)\n\t\t\tif recur {\n\t\t\t\tdo = append(do, func() { mkdirAll(t, tmppath(tmp, c.args[0])) })\n\t\t\t} else {\n\t\t\t\tdo = append(do, func() { mkdir(t, tmppath(tmp, c.args[0])) })\n\t\t\t}\n\t\tcase \"ln\":\n\t\t\tmustArg(c, 3)\n\t\t\tif c.args[0] != \"-s\" {\n\t\t\t\tt.Fatalf(\"line %d: only ln -s is supported\", c.line)\n\t\t\t}\n\t\t\tdo = append(do, func() { symlink(t, tmppath(tmp, c.args[1]), tmppath(tmp, c.args[2])) })\n\t\tcase \"mkfifo\":\n\t\t\tmustArg(c, 1)\n\t\t\tdo = append(do, func() { mkfifo(t, tmppath(tmp, c.args[0])) })\n\t\tcase \"mknod\":\n\t\t\tmustArg(c, 2)\n\t\t\tn, err := strconv.ParseInt(c.args[0], 10, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"line %d: %s\", c.line, err)\n\t\t\t}\n\t\t\tdo = append(do, func() { mknod(t, int(n), tmppath(tmp, c.args[1])) })\n\t\tcase \"mv\":\n\t\t\tmustArg(c, 2)\n\t\t\tdo = append(do, func() { mv(t, tmppath(tmp, c.args[0]), tmppath(tmp, c.args[1])) })\n\t\tcase \"rm\":\n\t\t\trecur := false\n\t\t\tif len(c.args) == 2 && c.args[0] == \"-r\" {\n\t\t\t\trecur, c.args = true, c.args[1:]\n\t\t\t}\n\t\t\tmustArg(c, 1)\n\t\t\tif recur {\n\t\t\t\tdo = append(do, func() { rmAll(t, tmppath(tmp, c.args[0])) })\n\t\t\t} else {\n\t\t\t\tdo = append(do, func() { rm(t, tmppath(tmp, c.args[0])) })\n\t\t\t}\n\t\tcase \"chmod\":\n\t\t\tmustArg(c, 2)\n\t\t\tn, err := strconv.ParseUint(c.args[0], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"line %d: %s\", c.line, err)\n\t\t\t}\n\t\t\tdo = append(do, func() { chmod(t, fs.FileMode(n), tmppath(tmp, c.args[1])) })\n\t\tcase \"cat\":\n\t\t\tmustArg(c, 1)\n\t\t\tdo = append(do, func() { cat(t, tmppath(tmp, c.args[0])) })\n\t\tcase \"echo\":\n\t\t\tif len(c.args) < 2 || len(c.args) > 3 {\n\t\t\t\tt.Fatalf(\"line %d: %q requires 2 or 3 arguments (have %d: %q)\",\n\t\t\t\t\tc.line, c.cmd, len(c.args), c.args)\n\t\t\t}\n\n\t\t\tvar data, op, dst string\n\t\t\tif len(c.args) == 2 { // echo foo >dst\n\t\t\t\tdata, op, dst = c.args[0], c.args[1][:1], c.args[1][1:]\n\t\t\t\tif strings.HasPrefix(dst, \">\") {\n\t\t\t\t\top, dst = op+dst[:1], dst[1:]\n\t\t\t\t}\n\t\t\t} else { // echo foo > dst\n\t\t\t\tdata, op, dst = c.args[0], c.args[1], c.args[2]\n\t\t\t}\n\n\t\t\tswitch op {\n\t\t\tcase \">\":\n\t\t\t\tdo = append(do, func() { echoTrunc(t, data, tmppath(tmp, dst)) })\n\t\t\tcase \">>\":\n\t\t\t\tdo = append(do, func() { echoAppend(t, data, tmppath(tmp, dst)) })\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"line %d: echo requires > (truncate) or >> (append): echo data >file\", c.line)\n\t\t\t}\n\t\tcase \"sleep\":\n\t\t\tmustArg(c, 1)\n\t\t\tn, err := strconv.ParseInt(strings.TrimRight(c.args[0], \"ms\"), 10, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"line %d: %s\", c.line, err)\n\t\t\t}\n\t\t\tdo = append(do, func() { time.Sleep(time.Duration(n) * time.Millisecond) })\n\t\tdefault:\n\t\t\tt.Errorf(\"line %d: unknown command %q\", c.line, c.cmd)\n\t\t}\n\t}\n\n\tw.collect(t)\n\tfor _, d := range do {\n\t\td()\n\t}\n\tev := w.stop(t)\n\tcmpEvents(t, tmp, ev, newEvents(t, want))\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "system_bsd.go",
          "type": "blob",
          "size": 0.166015625,
          "content": "//go:build freebsd || openbsd || netbsd || dragonfly\n\npackage fsnotify\n\nimport \"golang.org/x/sys/unix\"\n\nconst openMode = unix.O_NONBLOCK | unix.O_RDONLY | unix.O_CLOEXEC\n"
        },
        {
          "name": "system_darwin.go",
          "type": "blob",
          "size": 0.1591796875,
          "content": "//go:build darwin\n\npackage fsnotify\n\nimport \"golang.org/x/sys/unix\"\n\n// note: this constant is not defined on BSD\nconst openMode = unix.O_EVTONLY | unix.O_CLOEXEC\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}