{
  "metadata": {
    "timestamp": 1736567781816,
    "page": 365,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/uuid",
      "stars": 5435,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.609375,
          "content": "# Changelog\n\n## [1.6.0](https://github.com/google/uuid/compare/v1.5.0...v1.6.0) (2024-01-16)\n\n\n### Features\n\n* add Max UUID constant ([#149](https://github.com/google/uuid/issues/149)) ([c58770e](https://github.com/google/uuid/commit/c58770eb495f55fe2ced6284f93c5158a62e53e3))\n\n\n### Bug Fixes\n\n* fix typo in version 7 uuid documentation ([#153](https://github.com/google/uuid/issues/153)) ([016b199](https://github.com/google/uuid/commit/016b199544692f745ffc8867b914129ecb47ef06))\n* Monotonicity in UUIDv7 ([#150](https://github.com/google/uuid/issues/150)) ([a2b2b32](https://github.com/google/uuid/commit/a2b2b32373ff0b1a312b7fdf6d38a977099698a6))\n\n## [1.5.0](https://github.com/google/uuid/compare/v1.4.0...v1.5.0) (2023-12-12)\n\n\n### Features\n\n* Validate UUID without creating new UUID ([#141](https://github.com/google/uuid/issues/141)) ([9ee7366](https://github.com/google/uuid/commit/9ee7366e66c9ad96bab89139418a713dc584ae29))\n\n## [1.4.0](https://github.com/google/uuid/compare/v1.3.1...v1.4.0) (2023-10-26)\n\n\n### Features\n\n* UUIDs slice type with Strings() convenience method ([#133](https://github.com/google/uuid/issues/133)) ([cd5fbbd](https://github.com/google/uuid/commit/cd5fbbdd02f3e3467ac18940e07e062be1f864b4))\n\n### Fixes\n\n* Clarify that Parse's job is to parse but not necessarily validate strings. (Documents current behavior)\n\n## [1.3.1](https://github.com/google/uuid/compare/v1.3.0...v1.3.1) (2023-08-18)\n\n\n### Bug Fixes\n\n* Use .EqualFold() to parse urn prefixed UUIDs ([#118](https://github.com/google/uuid/issues/118)) ([574e687](https://github.com/google/uuid/commit/574e6874943741fb99d41764c705173ada5293f0))\n\n## Changelog\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.93359375,
          "content": "# How to contribute\n\nWe definitely welcome patches and contribution to this project!\n\n### Tips\n\nCommits must be formatted according to the [Conventional Commits Specification](https://www.conventionalcommits.org).\n\nAlways try to include a test case! If it is not possible or not necessary,\nplease explain why in the pull request description.\n\n### Releasing\n\nCommits that would precipitate a SemVer change, as described in the Conventional\nCommits Specification, will trigger [`release-please`](https://github.com/google-github-actions/release-please-action)\nto create a release candidate pull request. Once submitted, `release-please`\nwill create a release.\n\nFor tips on how to work with `release-please`, see its documentation.\n\n### Legal requirements\n\nIn order to protect both you and ourselves, you will need to sign the\n[Contributor License Agreement](https://cla.developers.google.com/clas).\n\nYou may have already signed it for other Google projects.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.1025390625,
          "content": "Paul Borman <borman@google.com>\nbmatsuo\nshawnps\ntheory\njboverfelt\ndsymonds\ncd1\nwallclockbuilder\ndansouza\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4453125,
          "content": "Copyright (c) 2009,2014 Google Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8203125,
          "content": "# uuid\nThe uuid package generates and inspects UUIDs based on\n[RFC 9562](https://datatracker.ietf.org/doc/html/rfc9562)\nand DCE 1.1: Authentication and Security Services. \n\nThis package is based on the github.com/pborman/uuid package (previously named\ncode.google.com/p/go-uuid).  It differs from these earlier packages in that\na UUID is a 16 byte array rather than a byte slice.  One loss due to this\nchange is the ability to represent an invalid UUID (vs a NIL UUID).\n\n###### Install\n```sh\ngo get github.com/google/uuid\n```\n\n###### Documentation \n[![Go Reference](https://pkg.go.dev/badge/github.com/google/uuid.svg)](https://pkg.go.dev/github.com/google/uuid)\n\nFull `go doc` style documentation for the package can be viewed online without\ninstalling this package by using the GoDoc site here: \nhttps://pkg.go.dev/github.com/google/uuid\n"
        },
        {
          "name": "dce.go",
          "type": "blob",
          "size": 2.0234375,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// A Domain represents a Version 2 domain\ntype Domain byte\n\n// Domain constants for DCE Security (Version 2) UUIDs.\nconst (\n\tPerson = Domain(0)\n\tGroup  = Domain(1)\n\tOrg    = Domain(2)\n)\n\n// NewDCESecurity returns a DCE Security (Version 2) UUID.\n//\n// The domain should be one of Person, Group or Org.\n// On a POSIX system the id should be the users UID for the Person\n// domain and the users GID for the Group.  The meaning of id for\n// the domain Org or on non-POSIX systems is site defined.\n//\n// For a given domain/id pair the same token may be returned for up to\n// 7 minutes and 10 seconds.\nfunc NewDCESecurity(domain Domain, id uint32) (UUID, error) {\n\tuuid, err := NewUUID()\n\tif err == nil {\n\t\tuuid[6] = (uuid[6] & 0x0f) | 0x20 // Version 2\n\t\tuuid[9] = byte(domain)\n\t\tbinary.BigEndian.PutUint32(uuid[0:], id)\n\t}\n\treturn uuid, err\n}\n\n// NewDCEPerson returns a DCE Security (Version 2) UUID in the person\n// domain with the id returned by os.Getuid.\n//\n//  NewDCESecurity(Person, uint32(os.Getuid()))\nfunc NewDCEPerson() (UUID, error) {\n\treturn NewDCESecurity(Person, uint32(os.Getuid()))\n}\n\n// NewDCEGroup returns a DCE Security (Version 2) UUID in the group\n// domain with the id returned by os.Getgid.\n//\n//  NewDCESecurity(Group, uint32(os.Getgid()))\nfunc NewDCEGroup() (UUID, error) {\n\treturn NewDCESecurity(Group, uint32(os.Getgid()))\n}\n\n// Domain returns the domain for a Version 2 UUID.  Domains are only defined\n// for Version 2 UUIDs.\nfunc (uuid UUID) Domain() Domain {\n\treturn Domain(uuid[9])\n}\n\n// ID returns the id for a Version 2 UUID. IDs are only defined for Version 2\n// UUIDs.\nfunc (uuid UUID) ID() uint32 {\n\treturn binary.BigEndian.Uint32(uuid[0:4])\n}\n\nfunc (d Domain) String() string {\n\tswitch d {\n\tcase Person:\n\t\treturn \"Person\"\n\tcase Group:\n\t\treturn \"Group\"\n\tcase Org:\n\t\treturn \"Org\"\n\t}\n\treturn fmt.Sprintf(\"Domain%d\", int(d))\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.4169921875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package uuid generates and inspects UUIDs.\n//\n// UUIDs are based on RFC 9562(obsoletes RFC 4122) and DCE 1.1: Authentication and Security\n// Services.\n//\n// A UUID is a 16 byte (128 bit) array.  UUIDs may be used as keys to\n// maps or compared directly.\npackage uuid\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.029296875,
          "content": "module github.com/google/uuid\n"
        },
        {
          "name": "hash.go",
          "type": "blob",
          "size": 1.9091796875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"hash\"\n)\n\n// Well known namespace IDs and UUIDs\nvar (\n\tNameSpaceDNS  = MustParse(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\tNameSpaceURL  = MustParse(\"6ba7b811-9dad-11d1-80b4-00c04fd430c8\")\n\tNameSpaceOID  = MustParse(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\")\n\tNameSpaceX500 = MustParse(\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\")\n\tNil           UUID // empty UUID, all zeros\n\n\t// The Max UUID is special form of UUID that is specified to have all 128 bits set to 1.\n\tMax = UUID{\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t}\n)\n\n// NewHash returns a new UUID derived from the hash of space concatenated with\n// data generated by h.  The hash should be at least 16 byte in length.  The\n// first 16 bytes of the hash are used to form the UUID.  The version of the\n// UUID will be the lower 4 bits of version.  NewHash is used to implement\n// NewMD5 and NewSHA1.\nfunc NewHash(h hash.Hash, space UUID, data []byte, version int) UUID {\n\th.Reset()\n\th.Write(space[:]) //nolint:errcheck\n\th.Write(data)     //nolint:errcheck\n\ts := h.Sum(nil)\n\tvar uuid UUID\n\tcopy(uuid[:], s)\n\tuuid[6] = (uuid[6] & 0x0f) | uint8((version&0xf)<<4)\n\tuuid[8] = (uuid[8] & 0x3f) | 0x80 // RFC 9562 variant\n\treturn uuid\n}\n\n// NewMD5 returns a new MD5 (Version 3) UUID based on the\n// supplied name space and data.  It is the same as calling:\n//\n//  NewHash(md5.New(), space, data, 3)\nfunc NewMD5(space UUID, data []byte) UUID {\n\treturn NewHash(md5.New(), space, data, 3)\n}\n\n// NewSHA1 returns a new SHA1 (Version 5) UUID based on the\n// supplied name space and data.  It is the same as calling:\n//\n//  NewHash(sha1.New(), space, data, 5)\nfunc NewSHA1(space UUID, data []byte) UUID {\n\treturn NewHash(sha1.New(), space, data, 5)\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 2.4248046875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testUUID = MustParse(\"f47ac10b-58cc-0372-8567-0e02b2c3d479\")\n\nfunc TestJSON(t *testing.T) {\n\ttype S struct {\n\t\tID1 UUID\n\t\tID2 UUID\n\t}\n\ts1 := S{ID1: testUUID}\n\tdata, err := json.Marshal(&s1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar s2 S\n\tif err := json.Unmarshal(data, &s2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(&s1, &s2) {\n\t\tt.Errorf(\"got %#v, want %#v\", s2, s1)\n\t}\n}\n\nfunc TestJSONUnmarshal(t *testing.T) {\n\ttype S struct {\n\t\tID1 UUID\n\t\tID2 UUID `json:\"ID2,omitempty\"`\n\t}\n\n\ttestCases := map[string]struct {\n\t\tdata           []byte\n\t\texpectedError  error\n\t\texpectedResult UUID\n\t}{\n\t\t\"success\": {\n\t\t\tdata:           []byte(`{\"ID1\": \"f47ac10b-58cc-0372-8567-0e02b2c3d479\"}`),\n\t\t\texpectedError:  nil,\n\t\t\texpectedResult: testUUID,\n\t\t},\n\t\t\"zero\": {\n\t\t\tdata:           []byte(`{\"ID1\": \"00000000-0000-0000-0000-000000000000\"}`),\n\t\t\texpectedError:  nil,\n\t\t\texpectedResult: Nil,\n\t\t},\n\t\t\"null\": {\n\t\t\tdata:           []byte(`{\"ID1\": null}`),\n\t\t\texpectedError:  nil,\n\t\t\texpectedResult: Nil,\n\t\t},\n\t\t\"empty\": {\n\t\t\tdata:           []byte(`{\"ID1\": \"\"}`),\n\t\t\texpectedError:  invalidLengthError{len: 0},\n\t\t\texpectedResult: Nil,\n\t\t},\n\t\t\"omitempty\": {\n\t\t\tdata:           []byte(`{\"ID2\": \"\"}`),\n\t\t\texpectedError:  invalidLengthError{len: 0},\n\t\t\texpectedResult: Nil,\n\t\t},\n\t}\n\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tvar s S\n\t\t\tif err := json.Unmarshal(tc.data, &s); err != tc.expectedError {\n\t\t\t\tt.Errorf(\"unexpected error: got %v, want %v\", err, tc.expectedError)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(s.ID1, tc.expectedResult) {\n\t\t\t\tt.Errorf(\"got %#v, want %#v\", s.ID1, tc.expectedResult)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkUUID_MarshalJSON(b *testing.B) {\n\tx := &struct {\n\t\tUUID UUID `json:\"uuid\"`\n\t}{}\n\tvar err error\n\tx.UUID, err = Parse(\"f47ac10b-58cc-0372-8567-0e02b2c3d479\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tjs, err := json.Marshal(x)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"marshal json: %#v (%v)\", js, err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkUUID_UnmarshalJSON(b *testing.B) {\n\tjs := []byte(`{\"uuid\":\"f47ac10b-58cc-0372-8567-0e02b2c3d479\"}`)\n\tvar x *struct {\n\t\tUUID UUID `json:\"uuid\"`\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\terr := json.Unmarshal(js, &x)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"marshal json: %#v (%v)\", js, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "marshal.go",
          "type": "blob",
          "size": 0.8857421875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport \"fmt\"\n\n// MarshalText implements encoding.TextMarshaler.\nfunc (uuid UUID) MarshalText() ([]byte, error) {\n\tvar js [36]byte\n\tencodeHex(js[:], uuid)\n\treturn js[:], nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler.\nfunc (uuid *UUID) UnmarshalText(data []byte) error {\n\tid, err := ParseBytes(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*uuid = id\n\treturn nil\n}\n\n// MarshalBinary implements encoding.BinaryMarshaler.\nfunc (uuid UUID) MarshalBinary() ([]byte, error) {\n\treturn uuid[:], nil\n}\n\n// UnmarshalBinary implements encoding.BinaryUnmarshaler.\nfunc (uuid *UUID) UnmarshalBinary(data []byte) error {\n\tif len(data) != 16 {\n\t\treturn fmt.Errorf(\"invalid UUID (got %d bytes)\", len(data))\n\t}\n\tcopy(uuid[:], data)\n\treturn nil\n}\n"
        },
        {
          "name": "node.go",
          "type": "blob",
          "size": 2.2685546875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"sync\"\n)\n\nvar (\n\tnodeMu sync.Mutex\n\tifname string  // name of interface being used\n\tnodeID [6]byte // hardware for version 1 UUIDs\n\tzeroID [6]byte // nodeID with only 0's\n)\n\n// NodeInterface returns the name of the interface from which the NodeID was\n// derived.  The interface \"user\" is returned if the NodeID was set by\n// SetNodeID.\nfunc NodeInterface() string {\n\tdefer nodeMu.Unlock()\n\tnodeMu.Lock()\n\treturn ifname\n}\n\n// SetNodeInterface selects the hardware address to be used for Version 1 UUIDs.\n// If name is \"\" then the first usable interface found will be used or a random\n// Node ID will be generated.  If a named interface cannot be found then false\n// is returned.\n//\n// SetNodeInterface never fails when name is \"\".\nfunc SetNodeInterface(name string) bool {\n\tdefer nodeMu.Unlock()\n\tnodeMu.Lock()\n\treturn setNodeInterface(name)\n}\n\nfunc setNodeInterface(name string) bool {\n\tiname, addr := getHardwareInterface(name) // null implementation for js\n\tif iname != \"\" && addr != nil {\n\t\tifname = iname\n\t\tcopy(nodeID[:], addr)\n\t\treturn true\n\t}\n\n\t// We found no interfaces with a valid hardware address.  If name\n\t// does not specify a specific interface generate a random Node ID\n\t// (section 4.1.6)\n\tif name == \"\" {\n\t\tifname = \"random\"\n\t\trandomBits(nodeID[:])\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NodeID returns a slice of a copy of the current Node ID, setting the Node ID\n// if not already set.\nfunc NodeID() []byte {\n\tdefer nodeMu.Unlock()\n\tnodeMu.Lock()\n\tif nodeID == zeroID {\n\t\tsetNodeInterface(\"\")\n\t}\n\tnid := nodeID\n\treturn nid[:]\n}\n\n// SetNodeID sets the Node ID to be used for Version 1 UUIDs.  The first 6 bytes\n// of id are used.  If id is less than 6 bytes then false is returned and the\n// Node ID is not set.\nfunc SetNodeID(id []byte) bool {\n\tif len(id) < 6 {\n\t\treturn false\n\t}\n\tdefer nodeMu.Unlock()\n\tnodeMu.Lock()\n\tcopy(nodeID[:], id)\n\tifname = \"user\"\n\treturn true\n}\n\n// NodeID returns the 6 byte node id encoded in uuid.  It returns nil if uuid is\n// not valid.  The NodeID is only well defined for version 1 and 2 UUIDs.\nfunc (uuid UUID) NodeID() []byte {\n\tvar node [6]byte\n\tcopy(node[:], uuid[10:])\n\treturn node[:]\n}\n"
        },
        {
          "name": "node_js.go",
          "type": "blob",
          "size": 0.486328125,
          "content": "// Copyright 2017 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build js\n\npackage uuid\n\n// getHardwareInterface returns nil values for the JS version of the code.\n// This removes the \"net\" dependency, because it is not used in the browser.\n// Using the \"net\" library inflates the size of the transpiled JS code by 673k bytes.\nfunc getHardwareInterface(name string) (string, []byte) { return \"\", nil }\n"
        },
        {
          "name": "node_net.go",
          "type": "blob",
          "size": 0.9267578125,
          "content": "// Copyright 2017 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !js\n\npackage uuid\n\nimport \"net\"\n\nvar interfaces []net.Interface // cached list of interfaces\n\n// getHardwareInterface returns the name and hardware address of interface name.\n// If name is \"\" then the name and hardware address of one of the system's\n// interfaces is returned.  If no interfaces are found (name does not exist or\n// there are no interfaces) then \"\", nil is returned.\n//\n// Only addresses of at least 6 bytes are returned.\nfunc getHardwareInterface(name string) (string, []byte) {\n\tif interfaces == nil {\n\t\tvar err error\n\t\tinterfaces, err = net.Interfaces()\n\t\tif err != nil {\n\t\t\treturn \"\", nil\n\t\t}\n\t}\n\tfor _, ifs := range interfaces {\n\t\tif len(ifs.HardwareAddr) >= 6 && (name == \"\" || name == ifs.Name) {\n\t\t\treturn ifs.Name, ifs.HardwareAddr\n\t\t}\n\t}\n\treturn \"\", nil\n}\n"
        },
        {
          "name": "null.go",
          "type": "blob",
          "size": 2.4033203125,
          "content": "// Copyright 2021 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nvar jsonNull = []byte(\"null\")\n\n// NullUUID represents a UUID that may be null.\n// NullUUID implements the SQL driver.Scanner interface so\n// it can be used as a scan destination:\n//\n//  var u uuid.NullUUID\n//  err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&u)\n//  ...\n//  if u.Valid {\n//     // use u.UUID\n//  } else {\n//     // NULL value\n//  }\n//\ntype NullUUID struct {\n\tUUID  UUID\n\tValid bool // Valid is true if UUID is not NULL\n}\n\n// Scan implements the SQL driver.Scanner interface.\nfunc (nu *NullUUID) Scan(value interface{}) error {\n\tif value == nil {\n\t\tnu.UUID, nu.Valid = Nil, false\n\t\treturn nil\n\t}\n\n\terr := nu.UUID.Scan(value)\n\tif err != nil {\n\t\tnu.Valid = false\n\t\treturn err\n\t}\n\n\tnu.Valid = true\n\treturn nil\n}\n\n// Value implements the driver Valuer interface.\nfunc (nu NullUUID) Value() (driver.Value, error) {\n\tif !nu.Valid {\n\t\treturn nil, nil\n\t}\n\t// Delegate to UUID Value function\n\treturn nu.UUID.Value()\n}\n\n// MarshalBinary implements encoding.BinaryMarshaler.\nfunc (nu NullUUID) MarshalBinary() ([]byte, error) {\n\tif nu.Valid {\n\t\treturn nu.UUID[:], nil\n\t}\n\n\treturn []byte(nil), nil\n}\n\n// UnmarshalBinary implements encoding.BinaryUnmarshaler.\nfunc (nu *NullUUID) UnmarshalBinary(data []byte) error {\n\tif len(data) != 16 {\n\t\treturn fmt.Errorf(\"invalid UUID (got %d bytes)\", len(data))\n\t}\n\tcopy(nu.UUID[:], data)\n\tnu.Valid = true\n\treturn nil\n}\n\n// MarshalText implements encoding.TextMarshaler.\nfunc (nu NullUUID) MarshalText() ([]byte, error) {\n\tif nu.Valid {\n\t\treturn nu.UUID.MarshalText()\n\t}\n\n\treturn jsonNull, nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler.\nfunc (nu *NullUUID) UnmarshalText(data []byte) error {\n\tid, err := ParseBytes(data)\n\tif err != nil {\n\t\tnu.Valid = false\n\t\treturn err\n\t}\n\tnu.UUID = id\n\tnu.Valid = true\n\treturn nil\n}\n\n// MarshalJSON implements json.Marshaler.\nfunc (nu NullUUID) MarshalJSON() ([]byte, error) {\n\tif nu.Valid {\n\t\treturn json.Marshal(nu.UUID)\n\t}\n\n\treturn jsonNull, nil\n}\n\n// UnmarshalJSON implements json.Unmarshaler.\nfunc (nu *NullUUID) UnmarshalJSON(data []byte) error {\n\tif bytes.Equal(data, jsonNull) {\n\t\t*nu = NullUUID{}\n\t\treturn nil // valid null UUID\n\t}\n\terr := json.Unmarshal(data, &nu.UUID)\n\tnu.Valid = err == nil\n\treturn err\n}\n"
        },
        {
          "name": "null_test.go",
          "type": "blob",
          "size": 4.9248046875,
          "content": "// Copyright 2021 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestNullUUIDScan(t *testing.T) {\n\tvar u UUID\n\tvar nu NullUUID\n\n\tuNilErr := u.Scan(nil)\n\tnuNilErr := nu.Scan(nil)\n\tif uNilErr != nil &&\n\t\tnuNilErr != nil &&\n\t\tuNilErr.Error() != nuNilErr.Error() {\n\t\tt.Errorf(\"expected errors to be equal, got %s, %s\", uNilErr, nuNilErr)\n\t}\n\n\tuInvalidStringErr := u.Scan(\"test\")\n\tnuInvalidStringErr := nu.Scan(\"test\")\n\tif uInvalidStringErr != nil &&\n\t\tnuInvalidStringErr != nil &&\n\t\tuInvalidStringErr.Error() != nuInvalidStringErr.Error() {\n\t\tt.Errorf(\"expected errors to be equal, got %s, %s\", uInvalidStringErr, nuInvalidStringErr)\n\t}\n\n\tvalid := \"12345678-abcd-1234-abcd-0123456789ab\"\n\tuValidErr := u.Scan(valid)\n\tnuValidErr := nu.Scan(valid)\n\tif uValidErr != nuValidErr {\n\t\tt.Errorf(\"expected errors to be equal, got %s, %s\", uValidErr, nuValidErr)\n\t}\n}\n\nfunc TestNullUUIDValue(t *testing.T) {\n\tvar u UUID\n\tvar nu NullUUID\n\n\tnuValue, nuErr := nu.Value()\n\tif nuErr != nil {\n\t\tt.Errorf(\"expected nil err, got err %s\", nuErr)\n\t}\n\tif nuValue != nil {\n\t\tt.Errorf(\"expected nil value, got non-nil %s\", nuValue)\n\t}\n\n\tu = MustParse(\"12345678-abcd-1234-abcd-0123456789ab\")\n\tnu = NullUUID{\n\t\tUUID:  MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"),\n\t\tValid: true,\n\t}\n\n\tuValue, uErr := u.Value()\n\tnuValue, nuErr = nu.Value()\n\tif uErr != nil {\n\t\tt.Errorf(\"expected nil err, got err %s\", uErr)\n\t}\n\tif nuErr != nil {\n\t\tt.Errorf(\"expected nil err, got err %s\", nuErr)\n\t}\n\tif uValue != nuValue {\n\t\tt.Errorf(\"expected uuid %s and nulluuid %s to be equal \", uValue, nuValue)\n\t}\n}\n\nfunc TestNullUUIDMarshalText(t *testing.T) {\n\ttests := []struct {\n\t\tnullUUID NullUUID\n\t}{\n\t\t{\n\t\t\tnullUUID: NullUUID{},\n\t\t},\n\t\t{\n\t\t\tnullUUID: NullUUID{\n\t\t\t\tUUID:  MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"),\n\t\t\t\tValid: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tvar uText []byte\n\t\tvar uErr error\n\t\tnuText, nuErr := test.nullUUID.MarshalText()\n\t\tif test.nullUUID.Valid {\n\t\t\tuText, uErr = test.nullUUID.UUID.MarshalText()\n\t\t} else {\n\t\t\tuText = []byte(\"null\")\n\t\t}\n\t\tif nuErr != uErr {\n\t\t\tt.Errorf(\"expected error %e, got %e\", nuErr, uErr)\n\t\t}\n\t\tif !bytes.Equal(nuText, uText) {\n\t\t\tt.Errorf(\"expected text data %s, got %s\", string(nuText), string(uText))\n\t\t}\n\t}\n}\n\nfunc TestNullUUIDUnmarshalText(t *testing.T) {\n\ttests := []struct {\n\t\tnullUUID NullUUID\n\t}{\n\t\t{\n\t\t\tnullUUID: NullUUID{},\n\t\t},\n\t\t{\n\t\t\tnullUUID: NullUUID{\n\t\t\t\tUUID:  MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"),\n\t\t\t\tValid: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tvar uText []byte\n\t\tvar uErr error\n\t\tnuText, nuErr := test.nullUUID.MarshalText()\n\t\tif test.nullUUID.Valid {\n\t\t\tuText, uErr = test.nullUUID.UUID.MarshalText()\n\t\t} else {\n\t\t\tuText = []byte(\"null\")\n\t\t}\n\t\tif nuErr != uErr {\n\t\t\tt.Errorf(\"expected error %e, got %e\", nuErr, uErr)\n\t\t}\n\t\tif !bytes.Equal(nuText, uText) {\n\t\t\tt.Errorf(\"expected text data %s, got %s\", string(nuText), string(uText))\n\t\t}\n\t}\n}\n\nfunc TestNullUUIDMarshalBinary(t *testing.T) {\n\ttests := []struct {\n\t\tnullUUID NullUUID\n\t}{\n\t\t{\n\t\t\tnullUUID: NullUUID{},\n\t\t},\n\t\t{\n\t\t\tnullUUID: NullUUID{\n\t\t\t\tUUID:  MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"),\n\t\t\t\tValid: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tvar uBinary []byte\n\t\tvar uErr error\n\t\tnuBinary, nuErr := test.nullUUID.MarshalBinary()\n\t\tif test.nullUUID.Valid {\n\t\t\tuBinary, uErr = test.nullUUID.UUID.MarshalBinary()\n\t\t} else {\n\t\t\tuBinary = []byte(nil)\n\t\t}\n\t\tif nuErr != uErr {\n\t\t\tt.Errorf(\"expected error %e, got %e\", nuErr, uErr)\n\t\t}\n\t\tif !bytes.Equal(nuBinary, uBinary) {\n\t\t\tt.Errorf(\"expected binary data %s, got %s\", string(nuBinary), string(uBinary))\n\t\t}\n\t}\n}\n\nfunc TestNullUUIDMarshalJSON(t *testing.T) {\n\tjsonNull, _ := json.Marshal(nil)\n\tjsonUUID, _ := json.Marshal(MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"))\n\ttests := []struct {\n\t\tnullUUID    NullUUID\n\t\texpected    []byte\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tnullUUID:    NullUUID{},\n\t\t\texpected:    jsonNull,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tnullUUID: NullUUID{\n\t\t\t\tUUID:  MustParse(string(jsonUUID)),\n\t\t\t\tValid: true,\n\t\t\t},\n\t\t\texpected:    []byte(`\"12345678-abcd-1234-abcd-0123456789ab\"`),\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tdata, err := json.Marshal(&test.nullUUID)\n\t\tif err != test.expectedErr {\n\t\t\tt.Errorf(\"expected error %e, got %e\", test.expectedErr, err)\n\t\t}\n\t\tif !bytes.Equal(data, test.expected) {\n\t\t\tt.Errorf(\"expected json data %s, got %s\", string(test.expected), string(data))\n\t\t}\n\t}\n}\n\nfunc TestNullUUIDUnmarshalJSON(t *testing.T) {\n\tjsonNull, _ := json.Marshal(nil)\n\tjsonUUID, _ := json.Marshal(MustParse(\"12345678-abcd-1234-abcd-0123456789ab\"))\n\n\tvar nu NullUUID\n\terr := json.Unmarshal(jsonNull, &nu)\n\tif err != nil || nu.Valid {\n\t\tt.Errorf(\"expected nil when unmarshalling null, got %s\", err)\n\t}\n\terr = json.Unmarshal(jsonUUID, &nu)\n\tif err != nil || !nu.Valid {\n\t\tt.Errorf(\"expected nil when unmarshalling null, got %s\", err)\n\t}\n}\n"
        },
        {
          "name": "seq_test.go",
          "type": "blob",
          "size": 1.4091796875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"flag\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n)\n\n// This test is only run when --regressions is passed on the go test line.\nvar regressions = flag.Bool(\"regressions\", false, \"run uuid regression tests\")\n\n// TestClockSeqRace tests for a particular race condition of returning two\n// identical Version1 UUIDs.  The duration of 1 minute was chosen as the race\n// condition, before being fixed, nearly always occurred in under 30 seconds.\nfunc TestClockSeqRace(t *testing.T) {\n\tif !*regressions {\n\t\tt.Skip(\"skipping regression tests\")\n\t}\n\tduration := time.Minute\n\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tch := make(chan UUID, 10000)\n\tncpu := runtime.NumCPU()\n\tswitch ncpu {\n\tcase 0, 1:\n\t\t// We can't run the test effectively.\n\t\tt.Skip(\"skipping race test, only one CPU detected\")\n\t\treturn\n\tdefault:\n\t\truntime.GOMAXPROCS(ncpu)\n\t}\n\tfor i := 0; i < ncpu; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\tcase ch <- Must(NewUUID()):\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tuuids := make(map[string]bool)\n\tcnt := 0\n\tstart := time.Now()\n\tfor u := range ch {\n\t\ts := u.String()\n\t\tif uuids[s] {\n\t\t\tt.Errorf(\"duplicate uuid after %d in %v: %s\", cnt, time.Since(start), s)\n\t\t\treturn\n\t\t}\n\t\tuuids[s] = true\n\t\tif time.Since(start) > duration {\n\t\t\treturn\n\t\t}\n\t\tcnt++\n\t}\n}\n"
        },
        {
          "name": "sql.go",
          "type": "blob",
          "size": 1.4248046875,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n)\n\n// Scan implements sql.Scanner so UUIDs can be read from databases transparently.\n// Currently, database types that map to string and []byte are supported. Please\n// consult database-specific driver documentation for matching types.\nfunc (uuid *UUID) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase nil:\n\t\treturn nil\n\n\tcase string:\n\t\t// if an empty UUID comes from a table, we return a null UUID\n\t\tif src == \"\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// see Parse for required string format\n\t\tu, err := Parse(src)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Scan: %v\", err)\n\t\t}\n\n\t\t*uuid = u\n\n\tcase []byte:\n\t\t// if an empty UUID comes from a table, we return a null UUID\n\t\tif len(src) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// assumes a simple slice of bytes if 16 bytes\n\t\t// otherwise attempts to parse\n\t\tif len(src) != 16 {\n\t\t\treturn uuid.Scan(string(src))\n\t\t}\n\t\tcopy((*uuid)[:], src)\n\n\tdefault:\n\t\treturn fmt.Errorf(\"Scan: unable to scan type %T into UUID\", src)\n\t}\n\n\treturn nil\n}\n\n// Value implements sql.Valuer so that UUIDs can be written to databases\n// transparently. Currently, UUIDs map to strings. Please consult\n// database-specific driver documentation for matching types.\nfunc (uuid UUID) Value() (driver.Value, error) {\n\treturn uuid.String(), nil\n}\n"
        },
        {
          "name": "sql_test.go",
          "type": "blob",
          "size": 2.31640625,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestScan(t *testing.T) {\n\tstringTest := \"f47ac10b-58cc-0372-8567-0e02b2c3d479\"\n\tbadTypeTest := 6\n\tinvalidTest := \"f47ac10b-58cc-0372-8567-0e02b2c3d4\"\n\n\tbyteTest := make([]byte, 16)\n\tbyteTestUUID := MustParse(stringTest)\n\tcopy(byteTest, byteTestUUID[:])\n\n\t// sunny day tests\n\n\tvar uuid UUID\n\terr := (&uuid).Scan(stringTest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = (&uuid).Scan([]byte(stringTest))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = (&uuid).Scan(byteTest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bad type tests\n\n\terr = (&uuid).Scan(badTypeTest)\n\tif err == nil {\n\t\tt.Error(\"int correctly parsed and shouldn't have\")\n\t}\n\tif !strings.Contains(err.Error(), \"unable to scan type\") {\n\t\tt.Error(\"attempting to parse an int returned an incorrect error message\")\n\t}\n\n\t// invalid/incomplete uuids\n\n\terr = (&uuid).Scan(invalidTest)\n\tif err == nil {\n\t\tt.Error(\"invalid uuid was parsed without error\")\n\t}\n\tif !strings.Contains(err.Error(), \"invalid UUID\") {\n\t\tt.Error(\"attempting to parse an invalid UUID returned an incorrect error message\")\n\t}\n\n\terr = (&uuid).Scan(byteTest[:len(byteTest)-2])\n\tif err == nil {\n\t\tt.Error(\"invalid byte uuid was parsed without error\")\n\t}\n\tif !strings.Contains(err.Error(), \"invalid UUID\") {\n\t\tt.Error(\"attempting to parse an invalid byte UUID returned an incorrect error message\")\n\t}\n\n\t// empty tests\n\n\tuuid = UUID{}\n\tvar emptySlice []byte\n\terr = (&uuid).Scan(emptySlice)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, v := range uuid {\n\t\tif v != 0 {\n\t\t\tt.Error(\"UUID was not nil after scanning empty byte slice\")\n\t\t}\n\t}\n\n\tuuid = UUID{}\n\tvar emptyString string\n\terr = (&uuid).Scan(emptyString)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, v := range uuid {\n\t\tif v != 0 {\n\t\t\tt.Error(\"UUID was not nil after scanning empty byte slice\")\n\t\t}\n\t}\n\n\tuuid = UUID{}\n\terr = (&uuid).Scan(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, v := range uuid {\n\t\tif v != 0 {\n\t\t\tt.Error(\"UUID was not nil after scanning nil\")\n\t\t}\n\t}\n}\n\nfunc TestValue(t *testing.T) {\n\tstringTest := \"f47ac10b-58cc-0372-8567-0e02b2c3d479\"\n\tuuid := MustParse(stringTest)\n\tval, _ := uuid.Value()\n\tif val != stringTest {\n\t\tt.Error(\"Value() did not return expected string\")\n\t}\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 3.939453125,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"encoding/binary\"\n\t\"sync\"\n\t\"time\"\n)\n\n// A Time represents a time as the number of 100's of nanoseconds since 15 Oct\n// 1582.\ntype Time int64\n\nconst (\n\tlillian    = 2299160          // Julian day of 15 Oct 1582\n\tunix       = 2440587          // Julian day of 1 Jan 1970\n\tepoch      = unix - lillian   // Days between epochs\n\tg1582      = epoch * 86400    // seconds between epochs\n\tg1582ns100 = g1582 * 10000000 // 100s of a nanoseconds between epochs\n)\n\nvar (\n\ttimeMu   sync.Mutex\n\tlasttime uint64 // last time we returned\n\tclockSeq uint16 // clock sequence for this run\n\n\ttimeNow = time.Now // for testing\n)\n\n// UnixTime converts t the number of seconds and nanoseconds using the Unix\n// epoch of 1 Jan 1970.\nfunc (t Time) UnixTime() (sec, nsec int64) {\n\tsec = int64(t - g1582ns100)\n\tnsec = (sec % 10000000) * 100\n\tsec /= 10000000\n\treturn sec, nsec\n}\n\n// GetTime returns the current Time (100s of nanoseconds since 15 Oct 1582) and\n// clock sequence as well as adjusting the clock sequence as needed.  An error\n// is returned if the current time cannot be determined.\nfunc GetTime() (Time, uint16, error) {\n\tdefer timeMu.Unlock()\n\ttimeMu.Lock()\n\treturn getTime(nil)\n}\n\nfunc getTime(customTime *time.Time) (Time, uint16, error) {\n\tvar t time.Time\n\tif customTime == nil { // When not provided, use the current time\n\t\tt = timeNow()\n\t} else {\n\t\tt = *customTime\n\t}\n\n\t// If we don't have a clock sequence already, set one.\n\tif clockSeq == 0 {\n\t\tsetClockSequence(-1)\n\t}\n\tnow := uint64(t.UnixNano()/100) + g1582ns100\n\n\t// If time has gone backwards with this clock sequence then we\n\t// increment the clock sequence\n\tif now <= lasttime {\n\t\tclockSeq = ((clockSeq + 1) & 0x3fff) | 0x8000\n\t}\n\tlasttime = now\n\treturn Time(now), clockSeq, nil\n}\n\n// ClockSequence returns the current clock sequence, generating one if not\n// already set.  The clock sequence is only used for Version 1 UUIDs.\n//\n// The uuid package does not use global static storage for the clock sequence or\n// the last time a UUID was generated.  Unless SetClockSequence is used, a new\n// random clock sequence is generated the first time a clock sequence is\n// requested by ClockSequence, GetTime, or NewUUID.  (section 4.2.1.1)\nfunc ClockSequence() int {\n\tdefer timeMu.Unlock()\n\ttimeMu.Lock()\n\treturn clockSequence()\n}\n\nfunc clockSequence() int {\n\tif clockSeq == 0 {\n\t\tsetClockSequence(-1)\n\t}\n\treturn int(clockSeq & 0x3fff)\n}\n\n// SetClockSequence sets the clock sequence to the lower 14 bits of seq.  Setting to\n// -1 causes a new sequence to be generated.\nfunc SetClockSequence(seq int) {\n\tdefer timeMu.Unlock()\n\ttimeMu.Lock()\n\tsetClockSequence(seq)\n}\n\nfunc setClockSequence(seq int) {\n\tif seq == -1 {\n\t\tvar b [2]byte\n\t\trandomBits(b[:]) // clock sequence\n\t\tseq = int(b[0])<<8 | int(b[1])\n\t}\n\toldSeq := clockSeq\n\tclockSeq = uint16(seq&0x3fff) | 0x8000 // Set our variant\n\tif oldSeq != clockSeq {\n\t\tlasttime = 0\n\t}\n}\n\n// Time returns the time in 100s of nanoseconds since 15 Oct 1582 encoded in\n// uuid.  The time is only defined for version 1, 2, 6 and 7 UUIDs.\nfunc (uuid UUID) Time() Time {\n\tvar t Time\n\tswitch uuid.Version() {\n\tcase 6:\n\t\ttime := int64(binary.BigEndian.Uint32(uuid[0:4])) << 28\n\t\ttime |= int64(binary.BigEndian.Uint16(uuid[4:6])) << 12\n\t\ttime |= int64(binary.BigEndian.Uint16(uuid[6:8]) & 0xfff)\n\t\tt = Time(time)\n\tcase 7:\n\t\ttime := binary.BigEndian.Uint64(uuid[:8])\n\t\tt = Time((time>>16)*10000 + g1582ns100)\n\tdefault: // forward compatible\n\t\ttime := int64(binary.BigEndian.Uint32(uuid[0:4]))\n\t\ttime |= int64(binary.BigEndian.Uint16(uuid[4:6])) << 32\n\t\ttime |= int64(binary.BigEndian.Uint16(uuid[6:8])&0xfff) << 48\n\t\tt = Time(time)\n\t}\n\treturn t\n}\n\n// ClockSequence returns the clock sequence encoded in uuid.\n// The clock sequence is only well defined for version 1 and 2 UUIDs.\nfunc (uuid UUID) ClockSequence() int {\n\treturn int(binary.BigEndian.Uint16(uuid[8:10])) & 0x3fff\n}\n"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 0.884765625,
          "content": "package uuid\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGetTime(t *testing.T) {\n\tnow := time.Now()\n\ttt := map[string]struct {\n\t\tinput        func() *time.Time\n\t\texpectedTime int64\n\t}{\n\t\t\"it should return the current time\": {\n\t\t\tinput: func() *time.Time {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\texpectedTime: now.Unix(),\n\t\t},\n\t\t\"it should return the provided time\": {\n\t\t\tinput: func() *time.Time {\n\t\t\t\tparsed, err := time.Parse(time.RFC3339, \"2024-10-15T09:32:23Z\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"timeParse unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn &parsed\n\t\t\t},\n\t\t\texpectedTime: 1728984743,\n\t\t},\n\t}\n\n\tfor name, tc := range tt {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tresult, _, err := getTime(tc.input())\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"getTime unexpected error: %v\", err)\n\t\t\t}\n\t\t\tsec, _ := result.UnixTime()\n\t\t\tif sec != tc.expectedTime {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expectedTime, result)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.0771484375,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\n// randomBits completely fills slice b with random data.\nfunc randomBits(b []byte) {\n\tif _, err := io.ReadFull(rander, b); err != nil {\n\t\tpanic(err.Error()) // rand should never fail\n\t}\n}\n\n// xvalues returns the value of a byte as a hexadecimal digit or 255.\nvar xvalues = [256]byte{\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255, 255,\n\t255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n}\n\n// xtob converts hex characters x1 and x2 into a byte.\nfunc xtob(x1, x2 byte) (byte, bool) {\n\tb1 := xvalues[x1]\n\tb2 := xvalues[x2]\n\treturn (b1 << 4) | b2, b1 != 255 && b2 != 255\n}\n\n// Compare returns an integer comparing two uuids lexicographically. The result will be 0 if a == b, -1 if a < b, and +1 if a > b.\nfunc Compare(a, b UUID) int {\n\treturn bytes.Compare(a[:], b[:])\n}\n"
        },
        {
          "name": "uuid.go",
          "type": "blob",
          "size": 10.013671875,
          "content": "// Copyright 2018 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// A UUID is a 128 bit (16 byte) Universal Unique IDentifier as defined in RFC\n// 9562.\ntype UUID [16]byte\n\n// A Version represents a UUID's version.\ntype Version byte\n\n// A Variant represents a UUID's variant.\ntype Variant byte\n\n// Constants returned by Variant.\nconst (\n\tInvalid   = Variant(iota) // Invalid UUID\n\tRFC4122                   // The variant specified in RFC9562(obsoletes RFC4122).\n\tReserved                  // Reserved, NCS backward compatibility.\n\tMicrosoft                 // Reserved, Microsoft Corporation backward compatibility.\n\tFuture                    // Reserved for future definition.\n)\n\n// RFC9562 added V6 and V7 of UUID, but did not change specification of V1 and V4\n// implemented in this module. To avoid creating new major module version,\n// we still use RFC4122 for constant name.\nconst Standard = RFC4122\n\nconst randPoolSize = 16 * 16\n\nvar (\n\trander      = rand.Reader // random function\n\tpoolEnabled = false\n\tpoolMu      sync.Mutex\n\tpoolPos     = randPoolSize     // protected with poolMu\n\tpool        [randPoolSize]byte // protected with poolMu\n\n\tErrInvalidUUIDFormat      = errors.New(\"invalid UUID format\")\n\tErrInvalidBracketedFormat = errors.New(\"invalid bracketed UUID format\")\n)\n\ntype URNPrefixError struct { prefix string }\n\nfunc (e URNPrefixError) Error() string {\n\treturn fmt.Sprintf(\"invalid urn prefix: %q\", e.prefix)\n}\n\nfunc (e URNPrefixError) Is(target error) bool {\n\t_, ok := target.(URNPrefixError)\n\treturn ok\n}\n\nvar ErrInvalidURNPrefix = URNPrefixError{}\n\ntype invalidLengthError struct{ len int }\n\nfunc (err invalidLengthError) Error() string {\n\treturn fmt.Sprintf(\"invalid UUID length: %d\", err.len)\n}\n\nfunc (e invalidLengthError) Is(target error) bool {\n\t_, ok := target.(invalidLengthError)\n\treturn ok\n}\n\nvar ErrInvalidLength = invalidLengthError{}\n\n// IsInvalidLengthError is matcher function for custom error invalidLengthError\nfunc IsInvalidLengthError(err error) bool {\n\treturn errors.Is(err, ErrInvalidLength)\n}\n\n// Parse decodes s into a UUID or returns an error if it cannot be parsed.  Both\n// the standard UUID forms defined in RFC 9562\n// (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx and\n// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx) are decoded.  In addition,\n// Parse accepts non-standard strings such as the raw hex encoding\n// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx and 38 byte \"Microsoft style\" encodings,\n// e.g.  {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}.  Only the middle 36 bytes are\n// examined in the latter case.  Parse should not be used to validate strings as\n// it parses non-standard encodings as indicated above.\nfunc Parse(s string) (UUID, error) {\n\tvar uuid UUID\n\tswitch len(s) {\n\t// xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\tcase 36:\n\n\t// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\tcase 36 + 9:\n\t\tif !strings.EqualFold(s[:9], \"urn:uuid:\") {\n\t\t\treturn uuid, URNPrefixError{s[:9]}\n\t\t}\n\t\ts = s[9:]\n\n\t// {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n\tcase 36 + 2:\n\t\ts = s[1:]\n\n\t// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\tcase 32:\n\t\tvar ok bool\n\t\tfor i := range uuid {\n\t\t\tuuid[i], ok = xtob(s[i*2], s[i*2+1])\n\t\t\tif !ok {\n\t\t\t\treturn uuid, ErrInvalidUUIDFormat\n\t\t\t}\n\t\t}\n\t\treturn uuid, nil\n\tdefault:\n\t\treturn uuid, invalidLengthError{len(s)}\n\t}\n\t// s is now at least 36 bytes long\n\t// it must be of the form  xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\tif s[8] != '-' || s[13] != '-' || s[18] != '-' || s[23] != '-' {\n\t\treturn uuid, ErrInvalidUUIDFormat\n\n\t}\n\tfor i, x := range [16]int{\n\t\t0, 2, 4, 6,\n\t\t9, 11,\n\t\t14, 16,\n\t\t19, 21,\n\t\t24, 26, 28, 30, 32, 34,\n\t} {\n\t\tv, ok := xtob(s[x], s[x+1])\n\t\tif !ok {\n\t\t\treturn uuid, ErrInvalidUUIDFormat\n\t\t}\n\t\tuuid[i] = v\n\t}\n\treturn uuid, nil\n}\n\n// ParseBytes is like Parse, except it parses a byte slice instead of a string.\nfunc ParseBytes(b []byte) (UUID, error) {\n\tvar uuid UUID\n\tswitch len(b) {\n\tcase 36: // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\tcase 36 + 9: // urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\t\tif !bytes.EqualFold(b[:9], []byte(\"urn:uuid:\")) {\n\t\t\treturn uuid, URNPrefixError{string(b[:9])}\n\t\t}\n\t\tb = b[9:]\n\tcase 36 + 2: // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n\t\tb = b[1:]\n\tcase 32: // xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\t\tvar ok bool\n\t\tfor i := 0; i < 32; i += 2 {\n\t\t\tuuid[i/2], ok = xtob(b[i], b[i+1])\n\t\t\tif !ok {\n\t\t\t\treturn uuid, ErrInvalidUUIDFormat\n\t\t\t}\n\t\t}\n\t\treturn uuid, nil\n\tdefault:\n\t\treturn uuid, invalidLengthError{len(b)}\n\t}\n\t// s is now at least 36 bytes long\n\t// it must be of the form  xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\tif b[8] != '-' || b[13] != '-' || b[18] != '-' || b[23] != '-' {\n\t\treturn uuid, ErrInvalidUUIDFormat\n\t}\n\tfor i, x := range [16]int{\n\t\t0, 2, 4, 6,\n\t\t9, 11,\n\t\t14, 16,\n\t\t19, 21,\n\t\t24, 26, 28, 30, 32, 34,\n\t} {\n\t\tv, ok := xtob(b[x], b[x+1])\n\t\tif !ok {\n\t\t\treturn uuid, ErrInvalidUUIDFormat\n\t\t}\n\t\tuuid[i] = v\n\t}\n\treturn uuid, nil\n}\n\n// MustParse is like Parse but panics if the string cannot be parsed.\n// It simplifies safe initialization of global variables holding compiled UUIDs.\nfunc MustParse(s string) UUID {\n\tuuid, err := Parse(s)\n\tif err != nil {\n\t\tpanic(`uuid: Parse(` + s + `): ` + err.Error())\n\t}\n\treturn uuid\n}\n\n// FromBytes creates a new UUID from a byte slice. Returns an error if the slice\n// does not have a length of 16. The bytes are copied from the slice.\nfunc FromBytes(b []byte) (uuid UUID, err error) {\n\terr = uuid.UnmarshalBinary(b)\n\treturn uuid, err\n}\n\n// Must returns uuid if err is nil and panics otherwise.\nfunc Must(uuid UUID, err error) UUID {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn uuid\n}\n\n// Validate returns an error if s is not a properly formatted UUID in one of the following formats:\n//   xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n//   urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n//   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n//   {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n// It returns an error if the format is invalid, otherwise nil.\nfunc Validate(s string) error {\n\tswitch len(s) {\n\t// Standard UUID format\n\tcase 36:\n\n\t// UUID with \"urn:uuid:\" prefix\n\tcase 36 + 9:\n\t\tif !strings.EqualFold(s[:9], \"urn:uuid:\") {\n\t\t\treturn URNPrefixError{s[:9]}\n\t\t}\n\t\ts = s[9:]\n\n\t// UUID enclosed in braces\n\tcase 36 + 2:\n\t\tif s[0] != '{' || s[len(s)-1] != '}' {\n\t\t\treturn ErrInvalidBracketedFormat\n\t\t}\n\t\ts = s[1 : len(s)-1]\n\n\t// UUID without hyphens\n\tcase 32:\n\t\tfor i := 0; i < len(s); i += 2 {\n\t\t\t_, ok := xtob(s[i], s[i+1])\n\t\t\tif !ok {\n\t\t\t\treturn ErrInvalidUUIDFormat\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\treturn invalidLengthError{len(s)}\n\t}\n\n\t// Check for standard UUID format\n\tif len(s) == 36 {\n\t\tif s[8] != '-' || s[13] != '-' || s[18] != '-' || s[23] != '-' {\n\t\t\treturn ErrInvalidUUIDFormat\n\t\t}\n\t\tfor _, x := range []int{0, 2, 4, 6, 9, 11, 14, 16, 19, 21, 24, 26, 28, 30, 32, 34} {\n\t\t\tif _, ok := xtob(s[x], s[x+1]); !ok {\n\t\t\t\treturn ErrInvalidUUIDFormat\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// String returns the string form of uuid, xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n// , or \"\" if uuid is invalid.\nfunc (uuid UUID) String() string {\n\tvar buf [36]byte\n\tencodeHex(buf[:], uuid)\n\treturn string(buf[:])\n}\n\n// URN returns the RFC 2141 URN form of uuid,\n// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx,  or \"\" if uuid is invalid.\nfunc (uuid UUID) URN() string {\n\tvar buf [36 + 9]byte\n\tcopy(buf[:], \"urn:uuid:\")\n\tencodeHex(buf[9:], uuid)\n\treturn string(buf[:])\n}\n\nfunc encodeHex(dst []byte, uuid UUID) {\n\thex.Encode(dst, uuid[:4])\n\tdst[8] = '-'\n\thex.Encode(dst[9:13], uuid[4:6])\n\tdst[13] = '-'\n\thex.Encode(dst[14:18], uuid[6:8])\n\tdst[18] = '-'\n\thex.Encode(dst[19:23], uuid[8:10])\n\tdst[23] = '-'\n\thex.Encode(dst[24:], uuid[10:])\n}\n\n// Variant returns the variant encoded in uuid.\nfunc (uuid UUID) Variant() Variant {\n\tswitch {\n\tcase (uuid[8] & 0xc0) == 0x80:\n\t\treturn RFC4122\n\tcase (uuid[8] & 0xe0) == 0xc0:\n\t\treturn Microsoft\n\tcase (uuid[8] & 0xe0) == 0xe0:\n\t\treturn Future\n\tdefault:\n\t\treturn Reserved\n\t}\n}\n\n// Version returns the version of uuid.\nfunc (uuid UUID) Version() Version {\n\treturn Version(uuid[6] >> 4)\n}\n\nfunc (v Version) String() string {\n\tif v > 15 {\n\t\treturn fmt.Sprintf(\"BAD_VERSION_%d\", v)\n\t}\n\treturn fmt.Sprintf(\"VERSION_%d\", v)\n}\n\nfunc (v Variant) String() string {\n\tswitch v {\n\tcase RFC4122:\n\t\treturn \"RFC4122\"\n\tcase Reserved:\n\t\treturn \"Reserved\"\n\tcase Microsoft:\n\t\treturn \"Microsoft\"\n\tcase Future:\n\t\treturn \"Future\"\n\tcase Invalid:\n\t\treturn \"Invalid\"\n\t}\n\treturn fmt.Sprintf(\"BadVariant%d\", int(v))\n}\n\n// SetRand sets the random number generator to r, which implements io.Reader.\n// If r.Read returns an error when the package requests random data then\n// a panic will be issued.\n//\n// Calling SetRand with nil sets the random number generator to the default\n// generator.\nfunc SetRand(r io.Reader) {\n\tif r == nil {\n\t\trander = rand.Reader\n\t\treturn\n\t}\n\trander = r\n}\n\n// EnableRandPool enables internal randomness pool used for Random\n// (Version 4) UUID generation. The pool contains random bytes read from\n// the random number generator on demand in batches. Enabling the pool\n// may improve the UUID generation throughput significantly.\n//\n// Since the pool is stored on the Go heap, this feature may be a bad fit\n// for security sensitive applications.\n//\n// Both EnableRandPool and DisableRandPool are not thread-safe and should\n// only be called when there is no possibility that New or any other\n// UUID Version 4 generation function will be called concurrently.\nfunc EnableRandPool() {\n\tpoolEnabled = true\n}\n\n// DisableRandPool disables the randomness pool if it was previously\n// enabled with EnableRandPool.\n//\n// Both EnableRandPool and DisableRandPool are not thread-safe and should\n// only be called when there is no possibility that New or any other\n// UUID Version 4 generation function will be called concurrently.\nfunc DisableRandPool() {\n\tpoolEnabled = false\n\tdefer poolMu.Unlock()\n\tpoolMu.Lock()\n\tpoolPos = randPoolSize\n}\n\n// UUIDs is a slice of UUID types.\ntype UUIDs []UUID\n\n// Strings returns a string slice containing the string form of each UUID in uuids.\nfunc (uuids UUIDs) Strings() []string {\n\tvar uuidStrs = make([]string, len(uuids))\n\tfor i, uuid := range uuids {\n\t\tuuidStrs[i] = uuid.String()\n\t}\n\treturn uuidStrs\n}\n"
        },
        {
          "name": "uuid_test.go",
          "type": "blob",
          "size": 22.7412109375,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n)\n\ntype test struct {\n\tin      string\n\tversion Version\n\tvariant Variant\n\tisuuid  bool\n}\n\nvar tests = []test{\n\t{\"f47ac10b-58cc-0372-8567-0e02b2c3d479\", 0, RFC4122, true},\n\t{\"f47ac10b-58cc-1372-8567-0e02b2c3d479\", 1, RFC4122, true},\n\t{\"f47ac10b-58cc-2372-8567-0e02b2c3d479\", 2, RFC4122, true},\n\t{\"f47ac10b-58cc-3372-8567-0e02b2c3d479\", 3, RFC4122, true},\n\t{\"f47ac10b-58cc-4372-8567-0e02b2c3d479\", 4, RFC4122, true},\n\t{\"f47ac10b-58cc-5372-8567-0e02b2c3d479\", 5, RFC4122, true},\n\t{\"f47ac10b-58cc-6372-8567-0e02b2c3d479\", 6, RFC4122, true},\n\t{\"f47ac10b-58cc-7372-8567-0e02b2c3d479\", 7, RFC4122, true},\n\t{\"f47ac10b-58cc-8372-8567-0e02b2c3d479\", 8, RFC4122, true},\n\t{\"f47ac10b-58cc-9372-8567-0e02b2c3d479\", 9, RFC4122, true},\n\t{\"f47ac10b-58cc-a372-8567-0e02b2c3d479\", 10, RFC4122, true},\n\t{\"f47ac10b-58cc-b372-8567-0e02b2c3d479\", 11, RFC4122, true},\n\t{\"f47ac10b-58cc-c372-8567-0e02b2c3d479\", 12, RFC4122, true},\n\t{\"f47ac10b-58cc-d372-8567-0e02b2c3d479\", 13, RFC4122, true},\n\t{\"f47ac10b-58cc-e372-8567-0e02b2c3d479\", 14, RFC4122, true},\n\t{\"f47ac10b-58cc-f372-8567-0e02b2c3d479\", 15, RFC4122, true},\n\n\t{\"urn:uuid:f47ac10b-58cc-4372-0567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"URN:UUID:f47ac10b-58cc-4372-0567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-0567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-1567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-2567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-3567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-4567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-5567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-6567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-7567-0e02b2c3d479\", 4, Reserved, true},\n\t{\"f47ac10b-58cc-4372-8567-0e02b2c3d479\", 4, RFC4122, true},\n\t{\"f47ac10b-58cc-4372-9567-0e02b2c3d479\", 4, RFC4122, true},\n\t{\"f47ac10b-58cc-4372-a567-0e02b2c3d479\", 4, RFC4122, true},\n\t{\"f47ac10b-58cc-4372-b567-0e02b2c3d479\", 4, RFC4122, true},\n\t{\"f47ac10b-58cc-4372-c567-0e02b2c3d479\", 4, Microsoft, true},\n\t{\"f47ac10b-58cc-4372-d567-0e02b2c3d479\", 4, Microsoft, true},\n\t{\"f47ac10b-58cc-4372-e567-0e02b2c3d479\", 4, Future, true},\n\t{\"f47ac10b-58cc-4372-f567-0e02b2c3d479\", 4, Future, true},\n\n\t{\"f47ac10b158cc-5372-a567-0e02b2c3d479\", 0, Invalid, false},\n\t{\"f47ac10b-58cc25372-a567-0e02b2c3d479\", 0, Invalid, false},\n\t{\"f47ac10b-58cc-53723a567-0e02b2c3d479\", 0, Invalid, false},\n\t{\"f47ac10b-58cc-5372-a56740e02b2c3d479\", 0, Invalid, false},\n\t{\"f47ac10b-58cc-5372-a567-0e02-2c3d479\", 0, Invalid, false},\n\t{\"g47ac10b-58cc-4372-a567-0e02b2c3d479\", 0, Invalid, false},\n\n\t{\"{f47ac10b-58cc-0372-8567-0e02b2c3d479}\", 0, RFC4122, true},\n\t{\"{f47ac10b-58cc-0372-8567-0e02b2c3d479\", 0, Invalid, false},\n\t{\"f47ac10b-58cc-0372-8567-0e02b2c3d479}\", 0, Invalid, false},\n\n\t{\"f47ac10b58cc037285670e02b2c3d479\", 0, RFC4122, true},\n\t{\"f47ac10b58cc037285670e02b2c3d4790\", 0, Invalid, false},\n\t{\"f47ac10b58cc037285670e02b2c3d47\", 0, Invalid, false},\n\n\t{\"01ee836c-e7c9-619d-929a-525400475911\", 6, RFC4122, true},\n\t{\"018bd12c-58b0-7683-8a5b-8752d0e86651\", 7, RFC4122, true},\n}\n\nvar constants = []struct {\n\tc    interface{}\n\tname string\n}{\n\t{Person, \"Person\"},\n\t{Group, \"Group\"},\n\t{Org, \"Org\"},\n\t{Invalid, \"Invalid\"},\n\t{RFC4122, \"RFC4122\"},\n\t{Reserved, \"Reserved\"},\n\t{Microsoft, \"Microsoft\"},\n\t{Future, \"Future\"},\n\t{Domain(17), \"Domain17\"},\n\t{Variant(42), \"BadVariant42\"},\n}\n\nfunc testTest(t *testing.T, in string, tt test) {\n\tuuid, err := Parse(in)\n\tif ok := (err == nil); ok != tt.isuuid {\n\t\tt.Errorf(\"Parse(%s) got %v expected %v\\b\", in, ok, tt.isuuid)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif v := uuid.Variant(); v != tt.variant {\n\t\tt.Errorf(\"Variant(%s) got %d expected %d\\b\", in, v, tt.variant)\n\t}\n\tif v := uuid.Version(); v != tt.version {\n\t\tt.Errorf(\"Version(%s) got %d expected %d\\b\", in, v, tt.version)\n\t}\n}\n\nfunc testBytes(t *testing.T, in []byte, tt test) {\n\tuuid, err := ParseBytes(in)\n\tif ok := (err == nil); ok != tt.isuuid {\n\t\tt.Errorf(\"ParseBytes(%s) got %v expected %v\\b\", in, ok, tt.isuuid)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\tsuuid, _ := Parse(string(in))\n\tif uuid != suuid {\n\t\tt.Errorf(\"ParseBytes(%s) got %v expected %v\\b\", in, uuid, suuid)\n\t}\n}\n\nfunc TestUUID(t *testing.T) {\n\tfor _, tt := range tests {\n\t\ttestTest(t, tt.in, tt)\n\t\ttestTest(t, strings.ToUpper(tt.in), tt)\n\t\ttestBytes(t, []byte(tt.in), tt)\n\t}\n}\n\nfunc TestFromBytes(t *testing.T) {\n\tb := []byte{\n\t\t0x7d, 0x44, 0x48, 0x40,\n\t\t0x9d, 0xc0,\n\t\t0x11, 0xd1,\n\t\t0xb2, 0x45,\n\t\t0x5f, 0xfd, 0xce, 0x74, 0xfa, 0xd2,\n\t}\n\tuuid, err := FromBytes(b)\n\tif err != nil {\n\t\tt.Fatalf(\"%s\", err)\n\t}\n\tfor i := 0; i < len(uuid); i++ {\n\t\tif b[i] != uuid[i] {\n\t\t\tt.Fatalf(\"FromBytes() got %v expected %v\\b\", uuid[:], b)\n\t\t}\n\t}\n}\n\nfunc TestConstants(t *testing.T) {\n\tfor x, tt := range constants {\n\t\tv, ok := tt.c.(fmt.Stringer)\n\t\tif !ok {\n\t\t\tt.Errorf(\"%x: %v: not a stringer\", x, v)\n\t\t} else if s := v.String(); s != tt.name {\n\t\t\tv, _ := tt.c.(int)\n\t\t\tt.Errorf(\"%x: Constant %T:%d gives %q, expected %q\", x, tt.c, v, s, tt.name)\n\t\t}\n\t}\n}\n\nfunc TestRandomUUID(t *testing.T) {\n\tm := make(map[string]bool)\n\tfor x := 1; x < 32; x++ {\n\t\tuuid := New()\n\t\ts := uuid.String()\n\t\tif m[s] {\n\t\t\tt.Errorf(\"NewRandom returned duplicated UUID %s\", s)\n\t\t}\n\t\tm[s] = true\n\t\tif v := uuid.Version(); v != 4 {\n\t\t\tt.Errorf(\"Random UUID of version %s\", v)\n\t\t}\n\t\tif uuid.Variant() != RFC4122 {\n\t\t\tt.Errorf(\"Random UUID is variant %d\", uuid.Variant())\n\t\t}\n\t}\n}\n\nfunc TestRandomUUID_Pooled(t *testing.T) {\n\tdefer DisableRandPool()\n\tEnableRandPool()\n\tm := make(map[string]bool)\n\tfor x := 1; x < 128; x++ {\n\t\tuuid := New()\n\t\ts := uuid.String()\n\t\tif m[s] {\n\t\t\tt.Errorf(\"NewRandom returned duplicated UUID %s\", s)\n\t\t}\n\t\tm[s] = true\n\t\tif v := uuid.Version(); v != 4 {\n\t\t\tt.Errorf(\"Random UUID of version %s\", v)\n\t\t}\n\t\tif uuid.Variant() != RFC4122 {\n\t\t\tt.Errorf(\"Random UUID is variant %d\", uuid.Variant())\n\t\t}\n\t}\n}\n\nfunc TestNew(t *testing.T) {\n\tm := make(map[UUID]bool)\n\tfor x := 1; x < 32; x++ {\n\t\ts := New()\n\t\tif m[s] {\n\t\t\tt.Errorf(\"New returned duplicated UUID %s\", s)\n\t\t}\n\t\tm[s] = true\n\t\tuuid, err := Parse(s.String())\n\t\tif err != nil {\n\t\t\tt.Errorf(\"New.String() returned %q which does not decode\", s)\n\t\t\tcontinue\n\t\t}\n\t\tif v := uuid.Version(); v != 4 {\n\t\t\tt.Errorf(\"Random UUID of version %s\", v)\n\t\t}\n\t\tif uuid.Variant() != RFC4122 {\n\t\t\tt.Errorf(\"Random UUID is variant %d\", uuid.Variant())\n\t\t}\n\t}\n}\n\nfunc TestClockSeq(t *testing.T) {\n\t// Fake time.Now for this test to return a monotonically advancing time; restore it at end.\n\tdefer func(orig func() time.Time) { timeNow = orig }(timeNow)\n\tmonTime := time.Now()\n\ttimeNow = func() time.Time {\n\t\tmonTime = monTime.Add(1 * time.Second)\n\t\treturn monTime\n\t}\n\n\tSetClockSequence(-1)\n\tuuid1, err := NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\tuuid2, err := NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\n\tif s1, s2 := uuid1.ClockSequence(), uuid2.ClockSequence(); s1 != s2 {\n\t\tt.Errorf(\"clock sequence %d != %d\", s1, s2)\n\t}\n\n\tSetClockSequence(-1)\n\tuuid2, err = NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\n\t// Just on the very off chance we generated the same sequence\n\t// two times we try again.\n\tif uuid1.ClockSequence() == uuid2.ClockSequence() {\n\t\tSetClockSequence(-1)\n\t\tuuid2, err = NewUUID()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t\t}\n\t}\n\tif s1, s2 := uuid1.ClockSequence(), uuid2.ClockSequence(); s1 == s2 {\n\t\tt.Errorf(\"Duplicate clock sequence %d\", s1)\n\t}\n\n\tSetClockSequence(0x1234)\n\tuuid1, err = NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\tif seq := uuid1.ClockSequence(); seq != 0x1234 {\n\t\tt.Errorf(\"%s: expected seq 0x1234 got 0x%04x\", uuid1, seq)\n\t}\n}\n\nfunc TestCoding(t *testing.T) {\n\ttext := \"7d444840-9dc0-11d1-b245-5ffdce74fad2\"\n\turn := \"urn:uuid:7d444840-9dc0-11d1-b245-5ffdce74fad2\"\n\tdata := UUID{\n\t\t0x7d, 0x44, 0x48, 0x40,\n\t\t0x9d, 0xc0,\n\t\t0x11, 0xd1,\n\t\t0xb2, 0x45,\n\t\t0x5f, 0xfd, 0xce, 0x74, 0xfa, 0xd2,\n\t}\n\tif v := data.String(); v != text {\n\t\tt.Errorf(\"%x: encoded to %s, expected %s\", data, v, text)\n\t}\n\tif v := data.URN(); v != urn {\n\t\tt.Errorf(\"%x: urn is %s, expected %s\", data, v, urn)\n\t}\n\n\tuuid, err := Parse(text)\n\tif err != nil {\n\t\tt.Errorf(\"Parse returned unexpected error %v\", err)\n\t}\n\tif data != uuid {\n\t\tt.Errorf(\"%s: decoded to %s, expected %s\", text, uuid, data)\n\t}\n}\n\nfunc TestVersion1(t *testing.T) {\n\tuuid1, err := NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\tuuid2, err := NewUUID()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\n\tif uuid1 == uuid2 {\n\t\tt.Errorf(\"%s:duplicate uuid\", uuid1)\n\t}\n\tif v := uuid1.Version(); v != 1 {\n\t\tt.Errorf(\"%s: version %s expected 1\", uuid1, v)\n\t}\n\tif v := uuid2.Version(); v != 1 {\n\t\tt.Errorf(\"%s: version %s expected 1\", uuid2, v)\n\t}\n\tn1 := uuid1.NodeID()\n\tn2 := uuid2.NodeID()\n\tif !bytes.Equal(n1, n2) {\n\t\tt.Errorf(\"Different nodes %x != %x\", n1, n2)\n\t}\n\tt1 := uuid1.Time()\n\tt2 := uuid2.Time()\n\tq1 := uuid1.ClockSequence()\n\tq2 := uuid2.ClockSequence()\n\n\tswitch {\n\tcase t1 == t2 && q1 == q2:\n\t\tt.Error(\"time stopped\")\n\tcase t1 > t2 && q1 == q2:\n\t\tt.Error(\"time reversed\")\n\tcase t1 < t2 && q1 != q2:\n\t\tt.Error(\"clock sequence changed unexpectedly\")\n\t}\n}\n\nfunc TestNode(t *testing.T) {\n\t// This test is mostly to make sure we don't leave nodeMu locked.\n\tifname = \"\"\n\tif ni := NodeInterface(); ni != \"\" {\n\t\tt.Errorf(\"NodeInterface got %q, want %q\", ni, \"\")\n\t}\n\tif SetNodeInterface(\"xyzzy\") {\n\t\tt.Error(\"SetNodeInterface succeeded on a bad interface name\")\n\t}\n\tif !SetNodeInterface(\"\") {\n\t\tt.Error(\"SetNodeInterface failed\")\n\t}\n\tif runtime.GOARCH != \"js\" {\n\t\tif ni := NodeInterface(); ni == \"\" {\n\t\t\tt.Error(\"NodeInterface returned an empty string\")\n\t\t}\n\t}\n\n\tni := NodeID()\n\tif len(ni) != 6 {\n\t\tt.Errorf(\"ni got %d bytes, want 6\", len(ni))\n\t}\n\thasData := false\n\tfor _, b := range ni {\n\t\tif b != 0 {\n\t\t\thasData = true\n\t\t}\n\t}\n\tif !hasData {\n\t\tt.Error(\"nodeid is all zeros\")\n\t}\n\n\tid := []byte{1, 2, 3, 4, 5, 6, 7, 8}\n\tSetNodeID(id)\n\tni = NodeID()\n\tif !bytes.Equal(ni, id[:6]) {\n\t\tt.Errorf(\"got nodeid %v, want %v\", ni, id[:6])\n\t}\n\n\tif ni := NodeInterface(); ni != \"user\" {\n\t\tt.Errorf(\"got interface %q, want %q\", ni, \"user\")\n\t}\n}\n\nfunc TestNodeAndTime(t *testing.T) {\n\t// Time is February 5, 1998 12:30:23.136364800 AM GMT\n\n\tuuid, err := Parse(\"7d444840-9dc0-11d1-b245-5ffdce74fad2\")\n\tif err != nil {\n\t\tt.Fatalf(\"Parser returned unexpected error %v\", err)\n\t}\n\tnode := []byte{0x5f, 0xfd, 0xce, 0x74, 0xfa, 0xd2}\n\n\tts := uuid.Time()\n\tc := time.Unix(ts.UnixTime())\n\twant := time.Date(1998, 2, 5, 0, 30, 23, 136364800, time.UTC)\n\tif !c.Equal(want) {\n\t\tt.Errorf(\"Got time %v, want %v\", c, want)\n\t}\n\tif !bytes.Equal(node, uuid.NodeID()) {\n\t\tt.Errorf(\"Expected node %v got %v\", node, uuid.NodeID())\n\t}\n}\n\nfunc TestMD5(t *testing.T) {\n\tuuid := NewMD5(NameSpaceDNS, []byte(\"python.org\")).String()\n\twant := \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"\n\tif uuid != want {\n\t\tt.Errorf(\"MD5: got %q expected %q\", uuid, want)\n\t}\n}\n\nfunc TestSHA1(t *testing.T) {\n\tuuid := NewSHA1(NameSpaceDNS, []byte(\"python.org\")).String()\n\twant := \"886313e1-3b8a-5372-9b90-0c9aee199e5d\"\n\tif uuid != want {\n\t\tt.Errorf(\"SHA1: got %q expected %q\", uuid, want)\n\t}\n}\n\nfunc TestNodeID(t *testing.T) {\n\tnid := []byte{1, 2, 3, 4, 5, 6}\n\tSetNodeInterface(\"\")\n\ts := NodeInterface()\n\tif runtime.GOARCH != \"js\" {\n\t\tif s == \"\" || s == \"user\" {\n\t\t\tt.Errorf(\"NodeInterface %q after SetInterface\", s)\n\t\t}\n\t}\n\tnode1 := NodeID()\n\tif node1 == nil {\n\t\tt.Error(\"NodeID nil after SetNodeInterface\", s)\n\t}\n\tSetNodeID(nid)\n\ts = NodeInterface()\n\tif s != \"user\" {\n\t\tt.Errorf(\"Expected NodeInterface %q got %q\", \"user\", s)\n\t}\n\tnode2 := NodeID()\n\tif node2 == nil {\n\t\tt.Error(\"NodeID nil after SetNodeID\", s)\n\t}\n\tif bytes.Equal(node1, node2) {\n\t\tt.Error(\"NodeID not changed after SetNodeID\", s)\n\t} else if !bytes.Equal(nid, node2) {\n\t\tt.Errorf(\"NodeID is %x, expected %x\", node2, nid)\n\t}\n}\n\nfunc testDCE(t *testing.T, name string, uuid UUID, err error, domain Domain, id uint32) {\n\tif err != nil {\n\t\tt.Errorf(\"%s failed: %v\", name, err)\n\t\treturn\n\t}\n\tif v := uuid.Version(); v != 2 {\n\t\tt.Errorf(\"%s: %s: expected version 2, got %s\", name, uuid, v)\n\t\treturn\n\t}\n\tif v := uuid.Domain(); v != domain {\n\t\tt.Errorf(\"%s: %s: expected domain %d, got %d\", name, uuid, domain, v)\n\t}\n\tif v := uuid.ID(); v != id {\n\t\tt.Errorf(\"%s: %s: expected id %d, got %d\", name, uuid, id, v)\n\t}\n}\n\nfunc TestDCE(t *testing.T) {\n\tuuid, err := NewDCESecurity(42, 12345678)\n\ttestDCE(t, \"NewDCESecurity\", uuid, err, 42, 12345678)\n\tuuid, err = NewDCEPerson()\n\ttestDCE(t, \"NewDCEPerson\", uuid, err, Person, uint32(os.Getuid()))\n\tuuid, err = NewDCEGroup()\n\ttestDCE(t, \"NewDCEGroup\", uuid, err, Group, uint32(os.Getgid()))\n}\n\ntype badRand struct{}\n\nfunc (r badRand) Read(buf []byte) (int, error) {\n\tfor i := range buf {\n\t\tbuf[i] = byte(i)\n\t}\n\treturn len(buf), nil\n}\n\nfunc TestBadRand(t *testing.T) {\n\tSetRand(badRand{})\n\tuuid1 := New()\n\tuuid2 := New()\n\tif uuid1 != uuid2 {\n\t\tt.Errorf(\"expected duplicates, got %q and %q\", uuid1, uuid2)\n\t}\n\tSetRand(nil)\n\tuuid1 = New()\n\tuuid2 = New()\n\tif uuid1 == uuid2 {\n\t\tt.Errorf(\"unexpected duplicates, got %q\", uuid1)\n\t}\n}\n\nfunc TestSetRand(t *testing.T) {\n\tmyString := \"805-9dd6-1a877cb526c678e71d38-7122-44c0-9b7c-04e7001cc78783ac3e82-47a3-4cc3-9951-13f3339d88088f5d685a-11f7-4078-ada9-de44ad2daeb7\"\n\n\tSetRand(strings.NewReader(myString))\n\tuuid1 := New()\n\tuuid2 := New()\n\n\tSetRand(strings.NewReader(myString))\n\tuuid3 := New()\n\tuuid4 := New()\n\n\tif uuid1 != uuid3 {\n\t\tt.Errorf(\"expected duplicates, got %q and %q\", uuid1, uuid3)\n\t}\n\tif uuid2 != uuid4 {\n\t\tt.Errorf(\"expected duplicates, got %q and %q\", uuid2, uuid4)\n\t}\n}\n\nfunc TestRandomFromReader(t *testing.T) {\n\tmyString := \"8059ddhdle77cb52\"\n\tr := bytes.NewReader([]byte(myString))\n\tr2 := bytes.NewReader([]byte(myString))\n\tuuid1, err := NewRandomFromReader(r)\n\tif err != nil {\n\t\tt.Errorf(\"failed generating UUID from a reader\")\n\t}\n\t_, err = NewRandomFromReader(r)\n\tif err == nil {\n\t\tt.Errorf(\"expecting an error as reader has no more bytes. Got uuid. NewRandomFromReader may not be using the provided reader\")\n\t}\n\tuuid3, err := NewRandomFromReader(r2)\n\tif err != nil {\n\t\tt.Errorf(\"failed generating UUID from a reader\")\n\t}\n\tif uuid1 != uuid3 {\n\t\tt.Errorf(\"expected duplicates, got %q and %q\", uuid1, uuid3)\n\t}\n}\n\nfunc TestRandPool(t *testing.T) {\n\tmyString := \"8059ddhdle77cb52\"\n\tEnableRandPool()\n\tSetRand(strings.NewReader(myString))\n\t_, err := NewRandom()\n\tif err == nil {\n\t\tt.Errorf(\"expecting an error as reader has no more bytes\")\n\t}\n\tDisableRandPool()\n\tSetRand(strings.NewReader(myString))\n\t_, err = NewRandom()\n\tif err != nil {\n\t\tt.Errorf(\"failed generating UUID from a reader\")\n\t}\n}\n\nfunc TestWrongLength(t *testing.T) {\n\t_, err := Parse(\"12345\")\n\tif err == nil {\n\t\tt.Errorf(\"expected ‘12345’ was invalid\")\n\t} else if err.Error() != \"invalid UUID length: 5\" {\n\t\tt.Errorf(\"expected a different error message for an invalid length\")\n\t}\n}\n\nfunc TestIsWrongLength(t *testing.T) {\n\t_, err := Parse(\"12345\")\n\tif !IsInvalidLengthError(err) {\n\t\tt.Errorf(\"IsInvalidLength returned incorrect type %T\", err)\n\t}\n}\n\nfunc FuzzParse(f *testing.F) {\n\tfor _, tt := range tests {\n\t\tf.Add(tt.in)\n\t\tf.Add(strings.ToUpper(tt.in))\n\t}\n\tf.Fuzz(func(t *testing.T, in string) {\n\t\tParse(in)\n\t})\n}\n\nfunc FuzzParseBytes(f *testing.F) {\n\tfor _, tt := range tests {\n\t\tf.Add([]byte(tt.in))\n\t}\n\tf.Fuzz(func(t *testing.T, in []byte) {\n\t\tParseBytes(in)\n\t})\n}\n\nfunc FuzzFromBytes(f *testing.F) {\n\t// Copied from TestFromBytes.\n\tf.Add([]byte{\n\t\t0x7d, 0x44, 0x48, 0x40,\n\t\t0x9d, 0xc0,\n\t\t0x11, 0xd1,\n\t\t0xb2, 0x45,\n\t\t0x5f, 0xfd, 0xce, 0x74, 0xfa, 0xd2,\n\t})\n\tf.Fuzz(func(t *testing.T, in []byte) {\n\t\tFromBytes(in)\n\t})\n}\n\n// TestValidate checks various scenarios for the Validate function\nfunc TestValidate(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tinput  string\n\t\texpect error\n\t}{\n\t\t{\"Valid UUID\", \"123e4567-e89b-12d3-a456-426655440000\", nil},\n\t\t{\"Valid UUID with URN\", \"urn:uuid:123e4567-e89b-12d3-a456-426655440000\", nil},\n\t\t{\"Valid UUID with Braces\", \"{123e4567-e89b-12d3-a456-426655440000}\", nil},\n\t\t{\"Valid UUID No Hyphens\", \"123e4567e89b12d3a456426655440000\", nil},\n\t\t{\"Invalid UUID\", \"invalid-uuid\", errors.New(\"invalid UUID length: 12\")},\n\t\t{\"Invalid Length\", \"123\", fmt.Errorf(\"invalid UUID length: %d\", len(\"123\"))},\n\t\t{\"Invalid URN Prefix\", \"urn:test:123e4567-e89b-12d3-a456-426655440000\", fmt.Errorf(\"invalid urn prefix: %q\", \"urn:test:\")},\n\t\t{\"Invalid Brackets\", \"[123e4567-e89b-12d3-a456-426655440000]\", fmt.Errorf(\"invalid bracketed UUID format\")},\n\t\t{\"Invalid UUID Format\", \"12345678gabc1234abcd1234abcd1234\", fmt.Errorf(\"invalid UUID format\")},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := Validate(tc.input)\n\t\t\tif (err != nil) != (tc.expect != nil) || (err != nil && err.Error() != tc.expect.Error()) {\n\t\t\t\tt.Errorf(\"Validate(%q) = %v, want %v\", tc.input, err, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar asString = \"f47ac10b-58cc-0372-8567-0e02b2c3d479\"\nvar asBytes = []byte(asString)\n\nfunc BenchmarkParse(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := Parse(asString)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseBytes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := ParseBytes(asBytes)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\n// parseBytesUnsafe is to benchmark using unsafe.\nfunc parseBytesUnsafe(b []byte) (UUID, error) {\n\treturn Parse(*(*string)(unsafe.Pointer(&b)))\n}\n\nfunc BenchmarkParseBytesUnsafe(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := parseBytesUnsafe(asBytes)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\n// parseBytesCopy is to benchmark not using unsafe.\nfunc parseBytesCopy(b []byte) (UUID, error) {\n\treturn Parse(string(b))\n}\n\nfunc BenchmarkParseBytesCopy(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := parseBytesCopy(asBytes)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNew()\n\t}\n}\n\nfunc BenchmarkUUID_String(b *testing.B) {\n\tuuid, err := Parse(\"f47ac10b-58cc-0372-8567-0e02b2c3d479\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tif uuid.String() == \"\" {\n\t\t\tb.Fatal(\"invalid uuid\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkUUID_URN(b *testing.B) {\n\tuuid, err := Parse(\"f47ac10b-58cc-0372-8567-0e02b2c3d479\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tif uuid.URN() == \"\" {\n\t\t\tb.Fatal(\"invalid uuid\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseBadLength(b *testing.B) {\n\tshort := asString[:10]\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := Parse(short)\n\t\tif err == nil {\n\t\t\tb.Fatalf(\"expected ‘%s’ was invalid\", short)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseLen32Truncated(b *testing.B) {\n\tpartial := asString[:len(asString)-4]\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := Parse(partial)\n\t\tif err == nil {\n\t\t\tb.Fatalf(\"expected ‘%s’ was invalid\", partial)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseLen36Corrupted(b *testing.B) {\n\twrong := asString[:len(asString)-1] + \"x\"\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := Parse(wrong)\n\t\tif err == nil {\n\t\t\tb.Fatalf(\"expected ‘%s’ was invalid\", wrong)\n\t\t}\n\t}\n}\n\nfunc BenchmarkUUID_New(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := NewRandom()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkUUID_NewPooled(b *testing.B) {\n\tEnableRandPool()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := NewRandom()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkUUIDs_Strings(b *testing.B) {\n\tuuid1, err := Parse(\"f47ac10b-58cc-0372-8567-0e02b2c3d479\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tuuid2, err := Parse(\"7d444840-9dc0-11d1-b245-5ffdce74fad2\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tuuids := UUIDs{uuid1, uuid2}\n\tfor i := 0; i < b.N; i++ {\n\t\tuuids.Strings()\n\t}\n}\n\nfunc TestVersion6(t *testing.T) {\n\tuuid1, err := NewV6()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\tuuid2, err := NewV6()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t}\n\n\tif uuid1 == uuid2 {\n\t\tt.Errorf(\"%s:duplicate uuid\", uuid1)\n\t}\n\tif v := uuid1.Version(); v != 6 {\n\t\tt.Errorf(\"%s: version %s expected 6\", uuid1, v)\n\t}\n\tif v := uuid2.Version(); v != 6 {\n\t\tt.Errorf(\"%s: version %s expected 6\", uuid2, v)\n\t}\n\tn1 := uuid1.NodeID()\n\tn2 := uuid2.NodeID()\n\tif !bytes.Equal(n1, n2) {\n\t\tt.Errorf(\"Different nodes %x != %x\", n1, n2)\n\t}\n\tt1 := uuid1.Time()\n\tt2 := uuid2.Time()\n\tq1 := uuid1.ClockSequence()\n\tq2 := uuid2.ClockSequence()\n\n\tswitch {\n\tcase t1 == t2 && q1 == q2:\n\t\tt.Error(\"time stopped\")\n\tcase t1 > t2 && q1 == q2:\n\t\tt.Error(\"time reversed\")\n\tcase t1 < t2 && q1 != q2:\n\t\tt.Error(\"clock sequence changed unexpectedly\")\n\t}\n}\n\n// uuid v7 time is only unix milliseconds, so\n// uuid1.Time() == uuid2.Time() is right, but uuid1 must != uuid2\nfunc TestVersion7(t *testing.T) {\n\tSetRand(nil)\n\tm := make(map[string]bool)\n\tfor x := 1; x < 128; x++ {\n\t\tuuid, err := NewV7()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t\t}\n\t\ts := uuid.String()\n\t\tif m[s] {\n\t\t\tt.Errorf(\"NewV7 returned duplicated UUID %s\", s)\n\t\t}\n\t\tm[s] = true\n\t\tif v := uuid.Version(); v != 7 {\n\t\t\tt.Errorf(\"UUID of version %s\", v)\n\t\t}\n\t\tif uuid.Variant() != RFC4122 {\n\t\t\tt.Errorf(\"UUID is variant %d\", uuid.Variant())\n\t\t}\n\t}\n}\n\n// uuid v7 time is only unix milliseconds, so\n// uuid1.Time() == uuid2.Time() is right, but uuid1 must != uuid2\nfunc TestVersion7_pooled(t *testing.T) {\n\tSetRand(nil)\n\tEnableRandPool()\n\tdefer DisableRandPool()\n\n\tm := make(map[string]bool)\n\tfor x := 1; x < 128; x++ {\n\t\tuuid, err := NewV7()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not create UUID: %v\", err)\n\t\t}\n\t\ts := uuid.String()\n\t\tif m[s] {\n\t\t\tt.Errorf(\"NewV7 returned duplicated UUID %s\", s)\n\t\t}\n\t\tm[s] = true\n\t\tif v := uuid.Version(); v != 7 {\n\t\t\tt.Errorf(\"UUID of version %s\", v)\n\t\t}\n\t\tif uuid.Variant() != RFC4122 {\n\t\t\tt.Errorf(\"UUID is variant %d\", uuid.Variant())\n\t\t}\n\t}\n}\n\nfunc TestVersion7FromReader(t *testing.T) {\n\tmyString := \"8059ddhdle77cb52\"\n\tr := bytes.NewReader([]byte(myString))\n\t_, err := NewV7FromReader(r)\n\tif err != nil {\n\t\tt.Errorf(\"failed generating UUID from a reader\")\n\t}\n\t_, err = NewV7FromReader(r)\n\tif err == nil {\n\t\tt.Errorf(\"expecting an error as reader has no more bytes. Got uuid. NewV7FromReader may not be using the provided reader\")\n\t}\n}\n\nfunc TestVersion7Monotonicity(t *testing.T) {\n\tlength := 10000\n\tu1 := Must(NewV7()).String()\n\tfor i := 0; i < length; i++ {\n\t\tu2 := Must(NewV7()).String()\n\t\tif u2 <= u1 {\n\t\t\tt.Errorf(\"monotonicity failed at #%d: %s(next) < %s(before)\", i, u2, u1)\n\t\t\tbreak\n\t\t}\n\t\tu1 = u2\n\t}\n}\n\ntype fakeRand struct{}\n\nfunc (g fakeRand) Read(bs []byte) (int, error) {\n\tfor i, _ := range bs {\n\t\tbs[i] = 0x88\n\t}\n\treturn len(bs), nil\n}\n\nfunc TestVersion7MonotonicityStrict(t *testing.T) {\n\ttimeNow = func() time.Time {\n\t\treturn time.Date(2008, 8, 8, 8, 8, 8, 8, time.UTC)\n\t}\n\tdefer func() {\n\t\ttimeNow = time.Now\n\t}()\n\n\tSetRand(fakeRand{})\n\tdefer SetRand(nil)\n\n\tlength := 100000 // > 3906\n\tu1 := Must(NewV7())\n\tfor i := 0; i < length; i++ {\n\t\tu2 := Must(NewV7())\n\t\tif Compare(u1, u2) >= 0 {\n\t\t\tt.Errorf(\"monotonicity failed at #%d: %s(next) < %s(before)\", i, u2, u1)\n\t\t\tbreak\n\t\t}\n\t\tu1 = u2\n\t}\n}\n"
        },
        {
          "name": "version1.go",
          "type": "blob",
          "size": 1.2275390625,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"encoding/binary\"\n)\n\n// NewUUID returns a Version 1 UUID based on the current NodeID and clock\n// sequence, and the current time.  If the NodeID has not been set by SetNodeID\n// or SetNodeInterface then it will be set automatically.  If the NodeID cannot\n// be set NewUUID returns nil.  If clock sequence has not been set by\n// SetClockSequence then it will be set automatically.  If GetTime fails to\n// return the current NewUUID returns nil and an error.\n//\n// In most cases, New should be used.\nfunc NewUUID() (UUID, error) {\n\tvar uuid UUID\n\tnow, seq, err := GetTime()\n\tif err != nil {\n\t\treturn uuid, err\n\t}\n\n\ttimeLow := uint32(now & 0xffffffff)\n\ttimeMid := uint16((now >> 32) & 0xffff)\n\ttimeHi := uint16((now >> 48) & 0x0fff)\n\ttimeHi |= 0x1000 // Version 1\n\n\tbinary.BigEndian.PutUint32(uuid[0:], timeLow)\n\tbinary.BigEndian.PutUint16(uuid[4:], timeMid)\n\tbinary.BigEndian.PutUint16(uuid[6:], timeHi)\n\tbinary.BigEndian.PutUint16(uuid[8:], seq)\n\n\tnodeMu.Lock()\n\tif nodeID == zeroID {\n\t\tsetNodeInterface(\"\")\n\t}\n\tcopy(uuid[10:], nodeID[:])\n\tnodeMu.Unlock()\n\n\treturn uuid, nil\n}\n"
        },
        {
          "name": "version4.go",
          "type": "blob",
          "size": 2.0087890625,
          "content": "// Copyright 2016 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport \"io\"\n\n// New creates a new random UUID or panics.  New is equivalent to\n// the expression\n//\n//    uuid.Must(uuid.NewRandom())\nfunc New() UUID {\n\treturn Must(NewRandom())\n}\n\n// NewString creates a new random UUID and returns it as a string or panics.\n// NewString is equivalent to the expression\n//\n//    uuid.New().String()\nfunc NewString() string {\n\treturn Must(NewRandom()).String()\n}\n\n// NewRandom returns a Random (Version 4) UUID.\n//\n// The strength of the UUIDs is based on the strength of the crypto/rand\n// package.\n//\n// Uses the randomness pool if it was enabled with EnableRandPool.\n//\n// A note about uniqueness derived from the UUID Wikipedia entry:\n//\n//  Randomly generated UUIDs have 122 random bits.  One's annual risk of being\n//  hit by a meteorite is estimated to be one chance in 17 billion, that\n//  means the probability is about 0.00000000006 (6 × 10−11),\n//  equivalent to the odds of creating a few tens of trillions of UUIDs in a\n//  year and having one duplicate.\nfunc NewRandom() (UUID, error) {\n\tif !poolEnabled {\n\t\treturn NewRandomFromReader(rander)\n\t}\n\treturn newRandomFromPool()\n}\n\n// NewRandomFromReader returns a UUID based on bytes read from a given io.Reader.\nfunc NewRandomFromReader(r io.Reader) (UUID, error) {\n\tvar uuid UUID\n\t_, err := io.ReadFull(r, uuid[:])\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\tuuid[6] = (uuid[6] & 0x0f) | 0x40 // Version 4\n\tuuid[8] = (uuid[8] & 0x3f) | 0x80 // Variant is 10\n\treturn uuid, nil\n}\n\nfunc newRandomFromPool() (UUID, error) {\n\tvar uuid UUID\n\tpoolMu.Lock()\n\tif poolPos == randPoolSize {\n\t\t_, err := io.ReadFull(rander, pool[:])\n\t\tif err != nil {\n\t\t\tpoolMu.Unlock()\n\t\t\treturn Nil, err\n\t\t}\n\t\tpoolPos = 0\n\t}\n\tcopy(uuid[:], pool[poolPos:(poolPos+16)])\n\tpoolPos += 16\n\tpoolMu.Unlock()\n\n\tuuid[6] = (uuid[6] & 0x0f) | 0x40 // Version 4\n\tuuid[8] = (uuid[8] & 0x3f) | 0x80 // Variant is 10\n\treturn uuid, nil\n}\n"
        },
        {
          "name": "version6.go",
          "type": "blob",
          "size": 3.029296875,
          "content": "// Copyright 2023 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"encoding/binary\"\n\t\"time\"\n)\n\n// UUID version 6 is a field-compatible version of UUIDv1, reordered for improved DB locality.\n// It is expected that UUIDv6 will primarily be used in contexts where there are existing v1 UUIDs.\n// Systems that do not involve legacy UUIDv1 SHOULD consider using UUIDv7 instead.\n//\n// see https://datatracker.ietf.org/doc/html/rfc9562#uuidv6\n//\n// NewV6 returns a Version 6 UUID based on the current NodeID and clock\n// sequence, and the current time. If the NodeID has not been set by SetNodeID\n// or SetNodeInterface then it will be set automatically. If the NodeID cannot\n// be set NewV6 set NodeID is random bits automatically . If clock sequence has not been set by\n// SetClockSequence then it will be set automatically. If GetTime fails to\n// return the current NewV6 returns Nil and an error.\nfunc NewV6() (UUID, error) {\n\tnow, seq, err := GetTime()\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\treturn generateV6(now, seq), nil\n}\n\n// NewV6WithTime returns a Version 6 UUID based on the current NodeID, clock\n// sequence, and a specified time. It is similar to the NewV6 function, but allows\n// you to specify the time. If time is passed as nil, then the current time is used.\n//\n// There is a limit on how many UUIDs can be generated for the same time, so if you\n// are generating multiple UUIDs, it is recommended to increment the time.\n// If getTime fails to return the current NewV6WithTime returns Nil and an error.\nfunc NewV6WithTime(customTime *time.Time) (UUID, error) {\n\tnow, seq, err := getTime(customTime)\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\n\treturn generateV6(now, seq), nil\n}\n\nfunc generateV6(now Time, seq uint16) UUID {\n\tvar uuid UUID\n\n\t/*\n\t    0                   1                   2                   3\n\t    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t   |                           time_high                           |\n\t   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t   |           time_mid            |      time_low_and_version     |\n\t   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |\n\t   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t   |                         node (2-5)                            |\n\t   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t*/\n\n\ttimeHigh := uint32((now >> 28) & 0xffffffff)\n\ttimeMid := uint16((now >> 12) & 0xffff)\n\ttimeLow := uint16(now & 0x0fff)\n\ttimeLow |= 0x6000 // Version 6\n\n\tbinary.BigEndian.PutUint32(uuid[0:], timeHigh)\n\tbinary.BigEndian.PutUint16(uuid[4:], timeMid)\n\tbinary.BigEndian.PutUint16(uuid[6:], timeLow)\n\tbinary.BigEndian.PutUint16(uuid[8:], seq)\n\n\tnodeMu.Lock()\n\tif nodeID == zeroID {\n\t\tsetNodeInterface(\"\")\n\t}\n\tcopy(uuid[10:], nodeID[:])\n\tnodeMu.Unlock()\n\n\treturn uuid\n}\n"
        },
        {
          "name": "version6_test.go",
          "type": "blob",
          "size": 2.5537109375,
          "content": "package uuid\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNewV6WithTime(t *testing.T) {\n\ttestCases := map[string]string{\n\t\t\"test with current date\":                      time.Now().Format(time.RFC3339),                                // now\n\t\t\"test with past date\":                         time.Now().Add(-1 * time.Hour * 24 * 365).Format(time.RFC3339), // 1 year ago\n\t\t\"test with future date\":                       time.Now().Add(time.Hour * 24 * 365).Format(time.RFC3339),      // 1 year from now\n\t\t\"test with different timezone\":                \"2021-09-01T12:00:00+04:00\",\n\t\t\"test with negative timezone\":                 \"2021-09-01T12:00:00-12:00\",\n\t\t\"test with future date in different timezone\": \"2124-09-23T12:43:30+09:00\",\n\t}\n\n\tfor testName, inputTime := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tcustomTime, err := time.Parse(time.RFC3339, inputTime)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"time.Parse returned unexpected error %v\", err)\n\t\t\t}\n\t\t\tid, err := NewV6WithTime(&customTime)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"NewV6WithTime returned unexpected error %v\", err)\n\t\t\t}\n\n\t\t\tif id.Version() != 6 {\n\t\t\t\tt.Errorf(\"got %d, want version 6\", id.Version())\n\t\t\t}\n\t\t\tunixTime := time.Unix(id.Time().UnixTime())\n\t\t\t// Compare the times in UTC format, since the input time might have different timezone,\n\t\t\t// and the result is always in system timezone\n\t\t\tif customTime.UTC().Format(time.RFC3339) != unixTime.UTC().Format(time.RFC3339) {\n\t\t\t\tt.Errorf(\"got %s, want %s\", unixTime.Format(time.RFC3339), customTime.Format(time.RFC3339))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewV6FromTimeGeneratesUniqueUUIDs(t *testing.T) {\n\tnow := time.Now()\n\tids := make([]string, 0)\n\truns := 26000\n\n\tfor i := 0; i < runs; i++ {\n\t\tnow = now.Add(time.Nanosecond) // Without this line, we can generate only 16384 UUIDs for the same timestamp\n\t\tid, err := NewV6WithTime(&now)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"NewV6WithTime returned unexpected error %v\", err)\n\t\t}\n\t\tif id.Version() != 6 {\n\t\t\tt.Errorf(\"got %d, want version 6\", id.Version())\n\t\t}\n\n\t\t// Make sure we add only unique values\n\t\tif !contains(t, ids, id.String()) {\n\t\t\tids = append(ids, id.String())\n\t\t}\n\t}\n\n\t// Check we added all the UIDs\n\tif len(ids) != runs {\n\t\tt.Errorf(\"got %d UUIDs, want %d\", len(ids), runs)\n\t}\n}\n\nfunc BenchmarkNewV6WithTime(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tnow := time.Now()\n\t\t\t_, err := NewV6WithTime(&now)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc contains(t *testing.T, arr []string, str string) bool {\n\tt.Helper()\n\n\tfor _, a := range arr {\n\t\tif a == str {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "version7.go",
          "type": "blob",
          "size": 3.2587890625,
          "content": "// Copyright 2023 Google Inc.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage uuid\n\nimport (\n\t\"io\"\n)\n\n// UUID version 7 features a time-ordered value field derived from the widely\n// implemented and well known Unix Epoch timestamp source,\n// the number of milliseconds seconds since midnight 1 Jan 1970 UTC, leap seconds excluded.\n// As well as improved entropy characteristics over versions 1 or 6.\n//\n// see https://datatracker.ietf.org/doc/html/rfc9562#name-uuid-version-7\n//\n// Implementations SHOULD utilize UUID version 7 over UUID version 1 and 6 if possible.\n//\n// NewV7 returns a Version 7 UUID based on the current time(Unix Epoch).\n// Uses the randomness pool if it was enabled with EnableRandPool.\n// On error, NewV7 returns Nil and an error\nfunc NewV7() (UUID, error) {\n\tuuid, err := NewRandom()\n\tif err != nil {\n\t\treturn uuid, err\n\t}\n\tmakeV7(uuid[:])\n\treturn uuid, nil\n}\n\n// NewV7FromReader returns a Version 7 UUID based on the current time(Unix Epoch).\n// it use NewRandomFromReader fill random bits.\n// On error, NewV7FromReader returns Nil and an error.\nfunc NewV7FromReader(r io.Reader) (UUID, error) {\n\tuuid, err := NewRandomFromReader(r)\n\tif err != nil {\n\t\treturn uuid, err\n\t}\n\n\tmakeV7(uuid[:])\n\treturn uuid, nil\n}\n\n// makeV7 fill 48 bits time (uuid[0] - uuid[5]), set version b0111 (uuid[6])\n// uuid[8] already has the right version number (Variant is 10)\n// see function NewV7 and NewV7FromReader\nfunc makeV7(uuid []byte) {\n\t/*\n\t\t 0                   1                   2                   3\n\t\t 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t|                           unix_ts_ms                          |\n\t\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t|          unix_ts_ms           |  ver  |  rand_a (12 bit seq)  |\n\t\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t|var|                        rand_b                             |\n\t\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t|                            rand_b                             |\n\t\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t*/\n\t_ = uuid[15] // bounds check\n\n\tt, s := getV7Time()\n\n\tuuid[0] = byte(t >> 40)\n\tuuid[1] = byte(t >> 32)\n\tuuid[2] = byte(t >> 24)\n\tuuid[3] = byte(t >> 16)\n\tuuid[4] = byte(t >> 8)\n\tuuid[5] = byte(t)\n\n\tuuid[6] = 0x70 | (0x0F & byte(s>>8))\n\tuuid[7] = byte(s)\n}\n\n// lastV7time is the last time we returned stored as:\n//\n//\t52 bits of time in milliseconds since epoch\n//\t12 bits of (fractional nanoseconds) >> 8\nvar lastV7time int64\n\nconst nanoPerMilli = 1000000\n\n// getV7Time returns the time in milliseconds and nanoseconds / 256.\n// The returned (milli << 12 + seq) is guaranteed to be greater than\n// (milli << 12 + seq) returned by any previous call to getV7Time.\nfunc getV7Time() (milli, seq int64) {\n\ttimeMu.Lock()\n\tdefer timeMu.Unlock()\n\n\tnano := timeNow().UnixNano()\n\tmilli = nano / nanoPerMilli\n\t// Sequence number is between 0 and 3906 (nanoPerMilli>>8)\n\tseq = (nano - milli*nanoPerMilli) >> 8\n\tnow := milli<<12 + seq\n\tif now <= lastV7time {\n\t\tnow = lastV7time + 1\n\t\tmilli = now >> 12\n\t\tseq = now & 0xfff\n\t}\n\tlastV7time = now\n\treturn milli, seq\n}\n"
        }
      ]
    }
  ]
}