{
  "metadata": {
    "timestamp": 1736567792471,
    "page": 377,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "disintegration/imaging",
      "stars": 5327,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2158203125,
          "content": "language: go\ngo:\n  - \"1.13.x\"\n  - \"1.14.x\"\n  - \"1.15.x\"\narch:\n  - AMD64\n  - ppc64le\n\nbefore_install:\n  - go get github.com/mattn/goveralls\n\nscript:\n  - go test -v -race -cover\n  - $GOPATH/bin/goveralls -service=travis-ci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2012 Grigory Dryapak\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3544921875,
          "content": "# Imaging\r\n\r\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/disintegration/imaging)](https://pkg.go.dev/github.com/disintegration/imaging)\r\n[![Build Status](https://travis-ci.org/disintegration/imaging.svg?branch=master)](https://travis-ci.org/disintegration/imaging)\r\n[![Coverage Status](https://coveralls.io/repos/github/disintegration/imaging/badge.svg?branch=master&service=github)](https://coveralls.io/github/disintegration/imaging?branch=master)\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/disintegration/imaging)](https://goreportcard.com/report/github.com/disintegration/imaging)\r\n\r\nPackage imaging provides basic image processing functions (resize, rotate, crop, brightness/contrast adjustments, etc.).\r\n\r\nAll the image processing functions provided by the package accept any image type that implements `image.Image` interface\r\nas an input, and return a new image of `*image.NRGBA` type (32bit RGBA colors, non-premultiplied alpha).\r\n\r\n## Installation\r\n\r\n    go get -u github.com/disintegration/imaging\r\n\r\n## Documentation\r\n\r\nhttps://pkg.go.dev/github.com/disintegration/imaging\r\n\r\n## Usage examples\r\n\r\nA few usage examples can be found below. See the documentation for the full list of supported functions.\r\n\r\n### Image resizing\r\n\r\n```go\r\n// Resize srcImage to size = 128x128px using the Lanczos filter.\r\ndstImage128 := imaging.Resize(srcImage, 128, 128, imaging.Lanczos)\r\n\r\n// Resize srcImage to width = 800px preserving the aspect ratio.\r\ndstImage800 := imaging.Resize(srcImage, 800, 0, imaging.Lanczos)\r\n\r\n// Scale down srcImage to fit the 800x600px bounding box.\r\ndstImageFit := imaging.Fit(srcImage, 800, 600, imaging.Lanczos)\r\n\r\n// Resize and crop the srcImage to fill the 100x100px area.\r\ndstImageFill := imaging.Fill(srcImage, 100, 100, imaging.Center, imaging.Lanczos)\r\n```\r\n\r\nImaging supports image resizing using various resampling filters. The most notable ones:\r\n- `Lanczos` - A high-quality resampling filter for photographic images yielding sharp results.\r\n- `CatmullRom` - A sharp cubic filter that is faster than Lanczos filter while providing similar results.\r\n- `MitchellNetravali` - A cubic filter that produces smoother results with less ringing artifacts than CatmullRom.\r\n- `Linear` - Bilinear resampling filter, produces smooth output. Faster than cubic filters.\r\n- `Box` - Simple and fast averaging filter appropriate for downscaling. When upscaling it's similar to NearestNeighbor.\r\n- `NearestNeighbor` - Fastest resampling filter, no antialiasing.\r\n\r\nThe full list of supported filters:  NearestNeighbor, Box, Linear, Hermite, MitchellNetravali, CatmullRom, BSpline, Gaussian, Lanczos, Hann, Hamming, Blackman, Bartlett, Welch, Cosine. Custom filters can be created using ResampleFilter struct.\r\n\r\n**Resampling filters comparison**\r\n\r\nOriginal image:\r\n\r\n![srcImage](testdata/branches.png)\r\n\r\nThe same image resized from 600x400px to 150x100px using different resampling filters.\r\nFrom faster (lower quality) to slower (higher quality):\r\n\r\nFilter                    | Resize result\r\n--------------------------|---------------------------------------------\r\n`imaging.NearestNeighbor` | ![dstImage](testdata/out_resize_nearest.png)\r\n`imaging.Linear`          | ![dstImage](testdata/out_resize_linear.png)\r\n`imaging.CatmullRom`      | ![dstImage](testdata/out_resize_catrom.png)\r\n`imaging.Lanczos`         | ![dstImage](testdata/out_resize_lanczos.png)\r\n\r\n\r\n### Gaussian Blur\r\n\r\n```go\r\ndstImage := imaging.Blur(srcImage, 0.5)\r\n```\r\n\r\nSigma parameter allows to control the strength of the blurring effect.\r\n\r\nOriginal image                     | Sigma = 0.5                            | Sigma = 1.5\r\n-----------------------------------|----------------------------------------|---------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_blur_0.5.png) | ![dstImage](testdata/out_blur_1.5.png)\r\n\r\n### Sharpening\r\n\r\n```go\r\ndstImage := imaging.Sharpen(srcImage, 0.5)\r\n```\r\n\r\n`Sharpen` uses gaussian function internally. Sigma parameter allows to control the strength of the sharpening effect.\r\n\r\nOriginal image                     | Sigma = 0.5                               | Sigma = 1.5\r\n-----------------------------------|-------------------------------------------|------------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_sharpen_0.5.png) | ![dstImage](testdata/out_sharpen_1.5.png)\r\n\r\n### Gamma correction\r\n\r\n```go\r\ndstImage := imaging.AdjustGamma(srcImage, 0.75)\r\n```\r\n\r\nOriginal image                     | Gamma = 0.75                             | Gamma = 1.25\r\n-----------------------------------|------------------------------------------|-----------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_gamma_0.75.png) | ![dstImage](testdata/out_gamma_1.25.png)\r\n\r\n### Contrast adjustment\r\n\r\n```go\r\ndstImage := imaging.AdjustContrast(srcImage, 20)\r\n```\r\n\r\nOriginal image                     | Contrast = 15                              | Contrast = -15\r\n-----------------------------------|--------------------------------------------|-------------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_contrast_p15.png) | ![dstImage](testdata/out_contrast_m15.png)\r\n\r\n### Brightness adjustment\r\n\r\n```go\r\ndstImage := imaging.AdjustBrightness(srcImage, 20)\r\n```\r\n\r\nOriginal image                     | Brightness = 10                              | Brightness = -10\r\n-----------------------------------|----------------------------------------------|---------------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_brightness_p10.png) | ![dstImage](testdata/out_brightness_m10.png)\r\n\r\n### Saturation adjustment\r\n\r\n```go\r\ndstImage := imaging.AdjustSaturation(srcImage, 20)\r\n```\r\n\r\nOriginal image                     | Saturation = 30                              | Saturation = -30\r\n-----------------------------------|----------------------------------------------|---------------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_saturation_p30.png) | ![dstImage](testdata/out_saturation_m30.png)\r\n\r\n### Hue adjustment\r\n\r\n```go\r\ndstImage := imaging.AdjustHue(srcImage, 20)\r\n```\r\n\r\nOriginal image                     | Hue = 60                                     | Hue = -60\r\n-----------------------------------|----------------------------------------------|---------------------------------------------\r\n![srcImage](testdata/flowers_small.png) | ![dstImage](testdata/out_hue_p60.png) | ![dstImage](testdata/out_hue_m60.png)\r\n\r\n## FAQ\r\n\r\n### Incorrect image orientation after processing (e.g. an image appears rotated after resizing)\r\n\r\nMost probably, the given image contains the EXIF orientation tag.\r\nThe standard `image/*` packages do not support loading and saving\r\nthis kind of information. To fix the issue, try opening images with\r\nthe `AutoOrientation` decode option. If this option is set to `true`,\r\nthe image orientation is changed after decoding, according to the\r\norientation tag (if present). Here's the example:\r\n\r\n```go\r\nimg, err := imaging.Open(\"test.jpg\", imaging.AutoOrientation(true))\r\n```\r\n\r\n### What's the difference between `imaging` and `gift` packages?\r\n\r\n[imaging](https://github.com/disintegration/imaging)\r\nis designed to be a lightweight and simple image manipulation package.\r\nIt provides basic image processing functions and a few helper functions\r\nsuch as `Open` and `Save`. It consistently returns *image.NRGBA image \r\ntype (8 bits per channel, RGBA).\r\n\r\n[gift](https://github.com/disintegration/gift)\r\nsupports more advanced image processing, for example, sRGB/Linear color\r\nspace conversions. It also supports different output image types\r\n(e.g. 16 bits per channel) and provides easy-to-use API for chaining\r\nmultiple processing steps together.\r\n\r\n## Example code\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"image\"\r\n\t\"image/color\"\r\n\t\"log\"\r\n\r\n\t\"github.com/disintegration/imaging\"\r\n)\r\n\r\nfunc main() {\r\n\t// Open a test image.\r\n\tsrc, err := imaging.Open(\"testdata/flowers.png\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"failed to open image: %v\", err)\r\n\t}\r\n\r\n\t// Crop the original image to 300x300px size using the center anchor.\r\n\tsrc = imaging.CropAnchor(src, 300, 300, imaging.Center)\r\n\r\n\t// Resize the cropped image to width = 200px preserving the aspect ratio.\r\n\tsrc = imaging.Resize(src, 200, 0, imaging.Lanczos)\r\n\r\n\t// Create a blurred version of the image.\r\n\timg1 := imaging.Blur(src, 5)\r\n\r\n\t// Create a grayscale version of the image with higher contrast and sharpness.\r\n\timg2 := imaging.Grayscale(src)\r\n\timg2 = imaging.AdjustContrast(img2, 20)\r\n\timg2 = imaging.Sharpen(img2, 2)\r\n\r\n\t// Create an inverted version of the image.\r\n\timg3 := imaging.Invert(src)\r\n\r\n\t// Create an embossed version of the image using a convolution filter.\r\n\timg4 := imaging.Convolve3x3(\r\n\t\tsrc,\r\n\t\t[9]float64{\r\n\t\t\t-1, -1, 0,\r\n\t\t\t-1, 1, 1,\r\n\t\t\t0, 1, 1,\r\n\t\t},\r\n\t\tnil,\r\n\t)\r\n\r\n\t// Create a new image and paste the four produced images into it.\r\n\tdst := imaging.New(400, 400, color.NRGBA{0, 0, 0, 0})\r\n\tdst = imaging.Paste(dst, img1, image.Pt(0, 0))\r\n\tdst = imaging.Paste(dst, img2, image.Pt(0, 200))\r\n\tdst = imaging.Paste(dst, img3, image.Pt(200, 0))\r\n\tdst = imaging.Paste(dst, img4, image.Pt(200, 200))\r\n\r\n\t// Save the resulting image as JPEG.\r\n\terr = imaging.Save(dst, \"testdata/out_example.jpg\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"failed to save image: %v\", err)\r\n\t}\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n![dstImage](testdata/out_example.jpg)\r\n"
        },
        {
          "name": "adjust.go",
          "type": "blob",
          "size": 8.3720703125,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n)\n\n// Grayscale produces a grayscale version of the image.\nfunc Grayscale(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := y * dst.Stride\n\t\t\tsrc.scan(0, y, src.w, y+1, dst.Pix[i:i+src.w*4])\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\td := dst.Pix[i : i+3 : i+3]\n\t\t\t\tr := d[0]\n\t\t\t\tg := d[1]\n\t\t\t\tb := d[2]\n\t\t\t\tf := 0.299*float64(r) + 0.587*float64(g) + 0.114*float64(b)\n\t\t\t\ty := uint8(f + 0.5)\n\t\t\t\td[0] = y\n\t\t\t\td[1] = y\n\t\t\t\td[2] = y\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\n// Invert produces an inverted (negated) version of the image.\nfunc Invert(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := y * dst.Stride\n\t\t\tsrc.scan(0, y, src.w, y+1, dst.Pix[i:i+src.w*4])\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\td := dst.Pix[i : i+3 : i+3]\n\t\t\t\td[0] = 255 - d[0]\n\t\t\t\td[1] = 255 - d[1]\n\t\t\t\td[2] = 255 - d[2]\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\n// AdjustSaturation changes the saturation of the image using the percentage parameter and returns the adjusted image.\n// The percentage must be in the range (-100, 100).\n// The percentage = 0 gives the original image.\n// The percentage = 100 gives the image with the saturation value doubled for each pixel.\n// The percentage = -100 gives the image with the saturation value zeroed for each pixel (grayscale).\n//\n// Examples:\n//  dstImage = imaging.AdjustSaturation(srcImage, 25) // Increase image saturation by 25%.\n//  dstImage = imaging.AdjustSaturation(srcImage, -10) // Decrease image saturation by 10%.\n//\nfunc AdjustSaturation(img image.Image, percentage float64) *image.NRGBA {\n\tif percentage == 0 {\n\t\treturn Clone(img)\n\t}\n\n\tpercentage = math.Min(math.Max(percentage, -100), 100)\n\tmultiplier := 1 + percentage/100\n\n\treturn AdjustFunc(img, func(c color.NRGBA) color.NRGBA {\n\t\th, s, l := rgbToHSL(c.R, c.G, c.B)\n\t\ts *= multiplier\n\t\tif s > 1 {\n\t\t\ts = 1\n\t\t}\n\t\tr, g, b := hslToRGB(h, s, l)\n\t\treturn color.NRGBA{r, g, b, c.A}\n\t})\n}\n\n// AdjustHue changes the hue of the image using the shift parameter (measured in degrees) and returns the adjusted image.\n// The shift = 0 (or 360 / -360 / etc.) gives the original image.\n// The shift = 180 (or -180) corresponds to a 180° degree rotation of the color wheel and thus gives the image with its hue inverted for each pixel.\n//\n// Examples:\n//  dstImage = imaging.AdjustHue(srcImage, 90) // Shift Hue by 90°.\n//  dstImage = imaging.AdjustHue(srcImage, -30) // Shift Hue by -30°.\n//\nfunc AdjustHue(img image.Image, shift float64) *image.NRGBA {\n\tif math.Mod(shift, 360) == 0 {\n\t\treturn Clone(img)\n\t}\n\n\tsummand := shift / 360\n\n\treturn AdjustFunc(img, func(c color.NRGBA) color.NRGBA {\n\t\th, s, l := rgbToHSL(c.R, c.G, c.B)\n\t\th += summand\n\t\th = math.Mod(h, 1)\n\t\t//Adding 1 because Golang's Modulo function behaves differently to similar operators in most other languages.\n\t\tif h < 0 {\n\t\t\th++\n\t\t}\n\t\tr, g, b := hslToRGB(h, s, l)\n\t\treturn color.NRGBA{r, g, b, c.A}\n\t})\n}\n\n// AdjustContrast changes the contrast of the image using the percentage parameter and returns the adjusted image.\n// The percentage must be in range (-100, 100). The percentage = 0 gives the original image.\n// The percentage = -100 gives solid gray image.\n//\n// Examples:\n//\n//\tdstImage = imaging.AdjustContrast(srcImage, -10) // Decrease image contrast by 10%.\n//\tdstImage = imaging.AdjustContrast(srcImage, 20) // Increase image contrast by 20%.\n//\nfunc AdjustContrast(img image.Image, percentage float64) *image.NRGBA {\n\tif percentage == 0 {\n\t\treturn Clone(img)\n\t}\n\n\tpercentage = math.Min(math.Max(percentage, -100.0), 100.0)\n\tlut := make([]uint8, 256)\n\n\tv := (100.0 + percentage) / 100.0\n\tfor i := 0; i < 256; i++ {\n\t\tswitch {\n\t\tcase 0 <= v && v <= 1:\n\t\t\tlut[i] = clamp((0.5 + (float64(i)/255.0-0.5)*v) * 255.0)\n\t\tcase 1 < v && v < 2:\n\t\t\tlut[i] = clamp((0.5 + (float64(i)/255.0-0.5)*(1/(2.0-v))) * 255.0)\n\t\tdefault:\n\t\t\tlut[i] = uint8(float64(i)/255.0+0.5) * 255\n\t\t}\n\t}\n\n\treturn adjustLUT(img, lut)\n}\n\n// AdjustBrightness changes the brightness of the image using the percentage parameter and returns the adjusted image.\n// The percentage must be in range (-100, 100). The percentage = 0 gives the original image.\n// The percentage = -100 gives solid black image. The percentage = 100 gives solid white image.\n//\n// Examples:\n//\n//\tdstImage = imaging.AdjustBrightness(srcImage, -15) // Decrease image brightness by 15%.\n//\tdstImage = imaging.AdjustBrightness(srcImage, 10) // Increase image brightness by 10%.\n//\nfunc AdjustBrightness(img image.Image, percentage float64) *image.NRGBA {\n\tif percentage == 0 {\n\t\treturn Clone(img)\n\t}\n\n\tpercentage = math.Min(math.Max(percentage, -100.0), 100.0)\n\tlut := make([]uint8, 256)\n\n\tshift := 255.0 * percentage / 100.0\n\tfor i := 0; i < 256; i++ {\n\t\tlut[i] = clamp(float64(i) + shift)\n\t}\n\n\treturn adjustLUT(img, lut)\n}\n\n// AdjustGamma performs a gamma correction on the image and returns the adjusted image.\n// Gamma parameter must be positive. Gamma = 1.0 gives the original image.\n// Gamma less than 1.0 darkens the image and gamma greater than 1.0 lightens it.\n//\n// Example:\n//\n//\tdstImage = imaging.AdjustGamma(srcImage, 0.7)\n//\nfunc AdjustGamma(img image.Image, gamma float64) *image.NRGBA {\n\tif gamma == 1 {\n\t\treturn Clone(img)\n\t}\n\n\te := 1.0 / math.Max(gamma, 0.0001)\n\tlut := make([]uint8, 256)\n\n\tfor i := 0; i < 256; i++ {\n\t\tlut[i] = clamp(math.Pow(float64(i)/255.0, e) * 255.0)\n\t}\n\n\treturn adjustLUT(img, lut)\n}\n\n// AdjustSigmoid changes the contrast of the image using a sigmoidal function and returns the adjusted image.\n// It's a non-linear contrast change useful for photo adjustments as it preserves highlight and shadow detail.\n// The midpoint parameter is the midpoint of contrast that must be between 0 and 1, typically 0.5.\n// The factor parameter indicates how much to increase or decrease the contrast, typically in range (-10, 10).\n// If the factor parameter is positive the image contrast is increased otherwise the contrast is decreased.\n//\n// Examples:\n//\n//\tdstImage = imaging.AdjustSigmoid(srcImage, 0.5, 3.0) // Increase the contrast.\n//\tdstImage = imaging.AdjustSigmoid(srcImage, 0.5, -3.0) // Decrease the contrast.\n//\nfunc AdjustSigmoid(img image.Image, midpoint, factor float64) *image.NRGBA {\n\tif factor == 0 {\n\t\treturn Clone(img)\n\t}\n\n\tlut := make([]uint8, 256)\n\ta := math.Min(math.Max(midpoint, 0.0), 1.0)\n\tb := math.Abs(factor)\n\tsig0 := sigmoid(a, b, 0)\n\tsig1 := sigmoid(a, b, 1)\n\te := 1.0e-6\n\n\tif factor > 0 {\n\t\tfor i := 0; i < 256; i++ {\n\t\t\tx := float64(i) / 255.0\n\t\t\tsigX := sigmoid(a, b, x)\n\t\t\tf := (sigX - sig0) / (sig1 - sig0)\n\t\t\tlut[i] = clamp(f * 255.0)\n\t\t}\n\t} else {\n\t\tfor i := 0; i < 256; i++ {\n\t\t\tx := float64(i) / 255.0\n\t\t\targ := math.Min(math.Max((sig1-sig0)*x+sig0, e), 1.0-e)\n\t\t\tf := a - math.Log(1.0/arg-1.0)/b\n\t\t\tlut[i] = clamp(f * 255.0)\n\t\t}\n\t}\n\n\treturn adjustLUT(img, lut)\n}\n\nfunc sigmoid(a, b, x float64) float64 {\n\treturn 1 / (1 + math.Exp(b*(a-x)))\n}\n\n// adjustLUT applies the given lookup table to the colors of the image.\nfunc adjustLUT(img image.Image, lut []uint8) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tlut = lut[0:256]\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := y * dst.Stride\n\t\t\tsrc.scan(0, y, src.w, y+1, dst.Pix[i:i+src.w*4])\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\td := dst.Pix[i : i+3 : i+3]\n\t\t\t\td[0] = lut[d[0]]\n\t\t\t\td[1] = lut[d[1]]\n\t\t\t\td[2] = lut[d[2]]\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\n// AdjustFunc applies the fn function to each pixel of the img image and returns the adjusted image.\n//\n// Example:\n//\n//\tdstImage = imaging.AdjustFunc(\n//\t\tsrcImage,\n//\t\tfunc(c color.NRGBA) color.NRGBA {\n//\t\t\t// Shift the red channel by 16.\n//\t\t\tr := int(c.R) + 16\n//\t\t\tif r > 255 {\n//\t\t\t\tr = 255\n//\t\t\t}\n//\t\t\treturn color.NRGBA{uint8(r), c.G, c.B, c.A}\n//\t\t}\n//\t)\n//\nfunc AdjustFunc(img image.Image, fn func(c color.NRGBA) color.NRGBA) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := y * dst.Stride\n\t\t\tsrc.scan(0, y, src.w, y+1, dst.Pix[i:i+src.w*4])\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\td := dst.Pix[i : i+4 : i+4]\n\t\t\t\tr := d[0]\n\t\t\t\tg := d[1]\n\t\t\t\tb := d[2]\n\t\t\t\ta := d[3]\n\t\t\t\tc := fn(color.NRGBA{r, g, b, a})\n\t\t\t\td[0] = c.R\n\t\t\t\td[1] = c.G\n\t\t\t\td[2] = c.B\n\t\t\t\td[3] = c.A\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n"
        },
        {
          "name": "adjust_test.go",
          "type": "blob",
          "size": 32.0263671875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"testing\"\n)\n\nfunc TestGrayscale(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Grayscale 3x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x3d, 0x3d, 0x3d, 0x01, 0x78, 0x78, 0x78, 0x02, 0x17, 0x17, 0x17, 0x03,\n\t\t\t\t\t0x1f, 0x1f, 0x1f, 0xff, 0x25, 0x25, 0x25, 0xff, 0x66, 0x66, 0x66, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Grayscale(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkGrayscale(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tGrayscale(testdataBranchesJPG)\n\t}\n}\n\nfunc TestInvert(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Invert 3x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x33, 0xff, 0xff, 0x01, 0xff, 0x33, 0xff, 0x02, 0xff, 0xff, 0x33, 0x03,\n\t\t\t\t\t0xee, 0xdd, 0xcc, 0xff, 0xcc, 0xdd, 0xee, 0xff, 0x55, 0xcc, 0x44, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Invert(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkInvert(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tInvert(testdataBranchesJPG)\n\t}\n}\n\nfunc TestAdjustSaturation(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustSaturation 3x3 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x0f, 0x22, 0x35, 0xff, 0x35, 0x22, 0x0f, 0xff, 0xaf, 0x2c, 0xc2, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSaturation 3x3 100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x00, 0x22, 0x44, 0xff, 0x44, 0x22, 0x00, 0xff, 0xd0, 0x00, 0xee, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSaturation 3x3 -10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xc2, 0x0a, 0x0a, 0x01, 0x0a, 0xc2, 0x0a, 0x02, 0x0a, 0x0a, 0xc2, 0x03,\n\t\t\t\t\t0x13, 0x22, 0x31, 0xff, 0x31, 0x22, 0x13, 0xff, 0xa5, 0x3a, 0xb4, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSaturation 3x3 -100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x01, 0x66, 0x66, 0x66, 0x02, 0x66, 0x66, 0x66, 0x03,\n\t\t\t\t\t0x22, 0x22, 0x22, 0xff, 0x22, 0x22, 0x22, 0xff, 0x77, 0x77, 0x77, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSaturation 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustSaturation(tc.src, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdjustSaturationGolden(t *testing.T) {\n\tfor name, p := range map[string]float64{\n\t\t\"out_saturation_m30.png\": -30,\n\t\t\"out_saturation_p30.png\": 30,\n\t} {\n\t\tgot := AdjustSaturation(testdataFlowersSmallPNG, p)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Errorf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAdjustSaturation(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustSaturation(testdataBranchesJPG, 10)\n\t}\n}\n\nfunc TestAdjustHue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustHue 3x3 -540\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-540,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xcc, 0xcc, 0x01, 0xcc, 0x00, 0xcc, 0x02, 0xcc, 0xcc, 0x00, 0x03,\n\t\t\t\t\t0x33, 0x22, 0x11, 0xff, 0x11, 0x22, 0x33, 0xff, 0x44, 0xbb, 0x33, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 -360\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-360,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 -350\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-350,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x22, 0x00, 0x01, 0x00, 0xcc, 0x22, 0x02, 0x22, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x1c, 0x33, 0xff, 0x33, 0x28, 0x11, 0xff, 0xbb, 0x33, 0xb5, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 -180\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-180,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xcc, 0xcc, 0x01, 0xcc, 0x00, 0xcc, 0x02, 0xcc, 0xcc, 0x00, 0x03,\n\t\t\t\t\t0x33, 0x22, 0x11, 0xff, 0x11, 0x22, 0x33, 0xff, 0x44, 0xbb, 0x33, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 -10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x22, 0x01, 0x22, 0xcc, 0x00, 0x02, 0x00, 0x22, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x28, 0x33, 0xff, 0x33, 0x1c, 0x11, 0xff, 0x93, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x22, 0x00, 0x01, 0x00, 0xcc, 0x22, 0x02, 0x22, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x1c, 0x33, 0xff, 0x33, 0x28, 0x11, 0xff, 0xbb, 0x33, 0xb5, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 180\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t180,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xcc, 0xcc, 0x01, 0xcc, 0x00, 0xcc, 0x02, 0xcc, 0xcc, 0x00, 0x03,\n\t\t\t\t\t0x33, 0x22, 0x11, 0xff, 0x11, 0x22, 0x33, 0xff, 0x44, 0xbb, 0x33, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 350\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t350,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x22, 0x01, 0x22, 0xcc, 0x00, 0x02, 0x00, 0x22, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x28, 0x33, 0xff, 0x33, 0x1c, 0x11, 0xff, 0x93, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 360\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t360,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustHue 3x3 540\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t540,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xcc, 0xcc, 0x01, 0xcc, 0x00, 0xcc, 0x02, 0xcc, 0xcc, 0x00, 0x03,\n\t\t\t\t\t0x33, 0x22, 0x11, 0xff, 0x11, 0x22, 0x33, 0xff, 0x44, 0xbb, 0x33, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustHue(tc.src, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdjustHueGolden(t *testing.T) {\n\tfor name, p := range map[string]float64{\n\t\t\"out_hue_m480.png\": -480,\n\t\t\"out_hue_m120.png\": -120,\n\t\t\"out_hue_m60.png\":  -60,\n\t\t\"out_hue_p60.png\":  60,\n\t\t\"out_hue_p120.png\": 120,\n\t\t\"out_hue_p480.png\": 480,\n\t} {\n\t\tgot := AdjustHue(testdataFlowersSmallPNG, p)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Errorf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAdjustHue(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustHue(testdataBranchesJPG, 10)\n\t}\n}\n\nfunc TestAdjustContrast(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustContrast 3x3 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xd5, 0x00, 0x00, 0x01, 0x00, 0xd5, 0x00, 0x02, 0x00, 0x00, 0xd5, 0x03,\n\t\t\t\t\t0x05, 0x18, 0x2b, 0xff, 0x2b, 0x18, 0x05, 0xff, 0xaf, 0x2b, 0xc2, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x2b, 0x2b, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustContrast 3x3 100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0x01, 0x00, 0xff, 0x00, 0x02, 0x00, 0x00, 0xff, 0x03,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustContrast 3x3 -10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xc4, 0x0d, 0x0d, 0x01, 0x0d, 0xc4, 0x0d, 0x02, 0x0d, 0x0d, 0xc4, 0x03,\n\t\t\t\t\t0x1c, 0x2b, 0x3b, 0xff, 0x3b, 0x2b, 0x1c, 0xff, 0xa6, 0x3b, 0xb5, 0xff,\n\t\t\t\t\t0x0d, 0x0d, 0x0d, 0xff, 0x3b, 0x3b, 0x3b, 0xff, 0xf2, 0xf2, 0xf2, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustContrast 3x3 -100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x80, 0x80, 0x80, 0x01, 0x80, 0x80, 0x80, 0x02, 0x80, 0x80, 0x80, 0x03,\n\t\t\t\t\t0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0xff,\n\t\t\t\t\t0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustContrast 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustContrast(tc.src, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdjustContrastGolden(t *testing.T) {\n\tfor name, p := range map[string]float64{\n\t\t\"out_contrast_m15.png\": -15,\n\t\t\"out_contrast_p15.png\": 15,\n\t} {\n\t\tgot := AdjustContrast(testdataFlowersSmallPNG, p)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAdjustContrast(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustContrast(testdataBranchesJPG, 10)\n\t}\n}\n\nfunc TestAdjustBrightness(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustBrightness 3x3 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xe6, 0x1a, 0x1a, 0x01, 0x1a, 0xe6, 0x1a, 0x02, 0x1a, 0x1a, 0xe6, 0x03,\n\t\t\t\t\t0x2b, 0x3c, 0x4d, 0xff, 0x4d, 0x3c, 0x2b, 0xff, 0xc4, 0x4d, 0xd5, 0xff,\n\t\t\t\t\t0x1a, 0x1a, 0x1a, 0xff, 0x4d, 0x4d, 0x4d, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustBrightness 3x3 100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x02, 0xff, 0xff, 0xff, 0x03,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustBrightness 3x3 -10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xb3, 0x00, 0x00, 0x01, 0x00, 0xb3, 0x00, 0x02, 0x00, 0x00, 0xb3, 0x03,\n\t\t\t\t\t0x00, 0x09, 0x1a, 0xff, 0x1a, 0x09, 0x00, 0xff, 0x91, 0x1a, 0xa2, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x1a, 0x1a, 0x1a, 0xff, 0xe6, 0xe6, 0xe6, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustBrightness 3x3 -100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustBrightness 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustBrightness(tc.src, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdjustBrightnessGolden(t *testing.T) {\n\tfor name, p := range map[string]float64{\n\t\t\"out_brightness_m10.png\": -10,\n\t\t\"out_brightness_p10.png\": 10,\n\t} {\n\t\tgot := AdjustBrightness(testdataFlowersSmallPNG, p)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAdjustBrightness(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustBrightness(testdataBranchesJPG, 10)\n\t}\n}\n\nfunc TestAdjustGamma(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustGamma 3x3 0.75\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.75,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xbd, 0x00, 0x00, 0x01, 0x00, 0xbd, 0x00, 0x02, 0x00, 0x00, 0xbd, 0x03,\n\t\t\t\t\t0x07, 0x11, 0x1e, 0xff, 0x1e, 0x11, 0x07, 0xff, 0x95, 0x1e, 0xa9, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x1e, 0x1e, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustGamma 3x3 1.5\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xdc, 0x00, 0x00, 0x01, 0x00, 0xdc, 0x00, 0x02, 0x00, 0x00, 0xdc, 0x03,\n\t\t\t\t\t0x2a, 0x43, 0x57, 0xff, 0x57, 0x43, 0x2a, 0xff, 0xc3, 0x57, 0xcf, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x57, 0x57, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustGamma 3x3 1.0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustGamma(tc.src, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdjustGammaGolden(t *testing.T) {\n\tfor name, g := range map[string]float64{\n\t\t\"out_gamma_0.75.png\": 0.75,\n\t\t\"out_gamma_1.25.png\": 1.25,\n\t} {\n\t\tgot := AdjustGamma(testdataFlowersSmallPNG, g)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAdjustGamma(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustGamma(testdataBranchesJPG, 1.5)\n\t}\n}\n\nfunc TestAdjustSigmoid(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tm    float64\n\t\tp    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"AdjustSigmoid 3x3 0.5 3.0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t3.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xd4, 0x00, 0x00, 0x01, 0x00, 0xd4, 0x00, 0x02, 0x00, 0x00, 0xd4, 0x03,\n\t\t\t\t\t0x0d, 0x1b, 0x2b, 0xff, 0x2b, 0x1b, 0x0d, 0xff, 0xb1, 0x2b, 0xc3, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x2b, 0x2b, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSigmoid 3x3 0.5 -3.0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t-3.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xc4, 0x00, 0x00, 0x01, 0x00, 0xc4, 0x00, 0x02, 0x00, 0x00, 0xc4, 0x03,\n\t\t\t\t\t0x16, 0x2a, 0x3b, 0xff, 0x3b, 0x2a, 0x16, 0xff, 0xa4, 0x3b, 0xb3, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x3b, 0x3b, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"AdjustSigmoid 3x3 0.5 0.0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t0.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustSigmoid(tc.src, tc.m, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkAdjustSigmoid(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustSigmoid(testdataBranchesJPG, 0.5, 3.0)\n\t}\n}\n\nfunc TestAdjustFunc(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tfn   func(c color.NRGBA) color.NRGBA\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"invert\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c color.NRGBA) color.NRGBA {\n\t\t\t\treturn color.NRGBA{255 - c.R, 255 - c.G, 255 - c.B, c.A}\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x33, 0xff, 0xff, 0x01, 0xff, 0x33, 0xff, 0x02, 0xff, 0xff, 0x33, 0x03,\n\t\t\t\t\t0xee, 0xdd, 0xcc, 0xff, 0xcc, 0xdd, 0xee, 0xff, 0x55, 0xcc, 0x44, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"threshold\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,\n\t\t\t\t\t0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c color.NRGBA) color.NRGBA {\n\t\t\t\ty := 0.299*float64(c.R) + 0.587*float64(c.G) + 0.114*float64(c.B)\n\t\t\t\tif y > 0x55 {\n\t\t\t\t\treturn color.NRGBA{0xff, 0xff, 0xff, c.A}\n\t\t\t\t}\n\t\t\t\treturn color.NRGBA{0x00, 0x00, 0x00, c.A}\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x03,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AdjustFunc(tc.src, tc.fn)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkAdjustFunc(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjustFunc(testdataBranchesJPG, func(c color.NRGBA) color.NRGBA {\n\t\t\treturn color.NRGBA{c.B, c.G, c.R, c.A}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "convolution.go",
          "type": "blob",
          "size": 2.859375,
          "content": "package imaging\n\nimport (\n\t\"image\"\n)\n\n// ConvolveOptions are convolution parameters.\ntype ConvolveOptions struct {\n\t// If Normalize is true the kernel is normalized before convolution.\n\tNormalize bool\n\n\t// If Abs is true the absolute value of each color channel is taken after convolution.\n\tAbs bool\n\n\t// Bias is added to each color channel value after convolution.\n\tBias int\n}\n\n// Convolve3x3 convolves the image with the specified 3x3 convolution kernel.\n// Default parameters are used if a nil *ConvolveOptions is passed.\nfunc Convolve3x3(img image.Image, kernel [9]float64, options *ConvolveOptions) *image.NRGBA {\n\treturn convolve(img, kernel[:], options)\n}\n\n// Convolve5x5 convolves the image with the specified 5x5 convolution kernel.\n// Default parameters are used if a nil *ConvolveOptions is passed.\nfunc Convolve5x5(img image.Image, kernel [25]float64, options *ConvolveOptions) *image.NRGBA {\n\treturn convolve(img, kernel[:], options)\n}\n\nfunc convolve(img image.Image, kernel []float64, options *ConvolveOptions) *image.NRGBA {\n\tsrc := toNRGBA(img)\n\tw := src.Bounds().Max.X\n\th := src.Bounds().Max.Y\n\tdst := image.NewNRGBA(image.Rect(0, 0, w, h))\n\n\tif w < 1 || h < 1 {\n\t\treturn dst\n\t}\n\n\tif options == nil {\n\t\toptions = &ConvolveOptions{}\n\t}\n\n\tif options.Normalize {\n\t\tnormalizeKernel(kernel)\n\t}\n\n\ttype coef struct {\n\t\tx, y int\n\t\tk    float64\n\t}\n\tvar coefs []coef\n\tvar m int\n\n\tswitch len(kernel) {\n\tcase 9:\n\t\tm = 1\n\tcase 25:\n\t\tm = 2\n\t}\n\n\ti := 0\n\tfor y := -m; y <= m; y++ {\n\t\tfor x := -m; x <= m; x++ {\n\t\t\tif kernel[i] != 0 {\n\t\t\t\tcoefs = append(coefs, coef{x: x, y: y, k: kernel[i]})\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\tparallel(0, h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\tfor x := 0; x < w; x++ {\n\t\t\t\tvar r, g, b float64\n\t\t\t\tfor _, c := range coefs {\n\t\t\t\t\tix := x + c.x\n\t\t\t\t\tif ix < 0 {\n\t\t\t\t\t\tix = 0\n\t\t\t\t\t} else if ix >= w {\n\t\t\t\t\t\tix = w - 1\n\t\t\t\t\t}\n\n\t\t\t\t\tiy := y + c.y\n\t\t\t\t\tif iy < 0 {\n\t\t\t\t\t\tiy = 0\n\t\t\t\t\t} else if iy >= h {\n\t\t\t\t\t\tiy = h - 1\n\t\t\t\t\t}\n\n\t\t\t\t\toff := iy*src.Stride + ix*4\n\t\t\t\t\ts := src.Pix[off : off+3 : off+3]\n\t\t\t\t\tr += float64(s[0]) * c.k\n\t\t\t\t\tg += float64(s[1]) * c.k\n\t\t\t\t\tb += float64(s[2]) * c.k\n\t\t\t\t}\n\n\t\t\t\tif options.Abs {\n\t\t\t\t\tif r < 0 {\n\t\t\t\t\t\tr = -r\n\t\t\t\t\t}\n\t\t\t\t\tif g < 0 {\n\t\t\t\t\t\tg = -g\n\t\t\t\t\t}\n\t\t\t\t\tif b < 0 {\n\t\t\t\t\t\tb = -b\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif options.Bias != 0 {\n\t\t\t\t\tr += float64(options.Bias)\n\t\t\t\t\tg += float64(options.Bias)\n\t\t\t\t\tb += float64(options.Bias)\n\t\t\t\t}\n\n\t\t\t\tsrcOff := y*src.Stride + x*4\n\t\t\t\tdstOff := y*dst.Stride + x*4\n\t\t\t\td := dst.Pix[dstOff : dstOff+4 : dstOff+4]\n\t\t\t\td[0] = clamp(r)\n\t\t\t\td[1] = clamp(g)\n\t\t\t\td[2] = clamp(b)\n\t\t\t\td[3] = src.Pix[srcOff+3]\n\t\t\t}\n\t\t}\n\t})\n\n\treturn dst\n}\n\nfunc normalizeKernel(kernel []float64) {\n\tvar sum, sumpos float64\n\tfor i := range kernel {\n\t\tsum += kernel[i]\n\t\tif kernel[i] > 0 {\n\t\t\tsumpos += kernel[i]\n\t\t}\n\t}\n\tif sum != 0 {\n\t\tfor i := range kernel {\n\t\t\tkernel[i] /= sum\n\t\t}\n\t} else if sumpos != 0 {\n\t\tfor i := range kernel {\n\t\t\tkernel[i] /= sumpos\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "convolution_test.go",
          "type": "blob",
          "size": 8.9716796875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"testing\"\n)\n\nfunc TestConvolve3x3(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tsrc     image.Image\n\t\tkernel  [9]float64\n\t\toptions *ConvolveOptions\n\t\twant    *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Convolve3x3 0x0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t\tnil,\n\t\t\t&image.NRGBA{Rect: image.Rect(0, 0, 0, 0)},\n\t\t},\n\t\t{\n\t\t\t\"Convolve3x3 4x4 identity\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t\tnil,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Convolve3x3 4x4 abs\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, -1, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t\t&ConvolveOptions{Abs: true},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Convolve3x3 4x4 bias\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t\t&ConvolveOptions{Bias: 0x10},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x03, 0x14, 0x15, 0x16, 0x07, 0x18, 0x19, 0x1a, 0x0b, 0x1c, 0x1d, 0x1e, 0x0f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x13, 0x24, 0x25, 0x26, 0x17, 0x28, 0x29, 0x2a, 0x1b, 0x2c, 0x2d, 0x2e, 0x1f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x23, 0x34, 0x35, 0x36, 0x27, 0x38, 0x39, 0x3a, 0x2b, 0x3c, 0x3d, 0x3e, 0x2f,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x33, 0x44, 0x45, 0x46, 0x37, 0x48, 0x49, 0x4a, 0x3b, 0x4c, 0x4d, 0x4e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Convolve3x3 4x4 norm\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t1, 1, 1,\n\t\t\t\t1, 1, 1,\n\t\t\t\t1, 1, 1,\n\t\t\t},\n\t\t\t&ConvolveOptions{Normalize: true},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x07, 0x08, 0x09, 0x03, 0x09, 0x0a, 0x0b, 0x07, 0x0d, 0x0e, 0x0f, 0x0b, 0x10, 0x11, 0x12, 0x0f,\n\t\t\t\t\t0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d, 0x1f,\n\t\t\t\t\t0x21, 0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2f,\n\t\t\t\t\t0x2c, 0x2d, 0x2e, 0x33, 0x2f, 0x30, 0x31, 0x37, 0x33, 0x34, 0x35, 0x3b, 0x35, 0x36, 0x37, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Convolve3x3 3x3 laplacian\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x01, 0xff, 0x00, 0x01, 0x02, 0xff, 0x00, 0x01, 0x03, 0xff,\n\t\t\t\t\t0x00, 0x01, 0x04, 0xff, 0x10, 0x10, 0x10, 0xff, 0x00, 0x01, 0x05, 0xff,\n\t\t\t\t\t0x00, 0x01, 0x06, 0xff, 0x00, 0x01, 0x07, 0xff, 0x00, 0x01, 0x08, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[9]float64{\n\t\t\t\t-1, -1, -1,\n\t\t\t\t-1, 8, -1,\n\t\t\t\t-1, -1, -1,\n\t\t\t},\n\t\t\tnil,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x80, 0x78, 0x5c, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Convolve3x3(tc.src, tc.kernel, tc.options)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConvolve5x5(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tsrc     image.Image\n\t\tkernel  [25]float64\n\t\toptions *ConvolveOptions\n\t\twant    *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Convolve5x5 4x4 translate\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[25]float64{\n\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t0, 0, 0, 0, 1,\n\t\t\t},\n\t\t\tnil,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x28, 0x29, 0x2a, 0x03, 0x2c, 0x2d, 0x2e, 0x07, 0x2c, 0x2d, 0x2e, 0x0b, 0x2c, 0x2d, 0x2e, 0x0f,\n\t\t\t\t\t0x38, 0x39, 0x3a, 0x13, 0x3c, 0x3d, 0x3e, 0x17, 0x3c, 0x3d, 0x3e, 0x1b, 0x3c, 0x3d, 0x3e, 0x1f,\n\t\t\t\t\t0x38, 0x39, 0x3a, 0x23, 0x3c, 0x3d, 0x3e, 0x27, 0x3c, 0x3d, 0x3e, 0x2b, 0x3c, 0x3d, 0x3e, 0x2f,\n\t\t\t\t\t0x38, 0x39, 0x3a, 0x33, 0x3c, 0x3d, 0x3e, 0x37, 0x3c, 0x3d, 0x3e, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Convolve5x5(tc.src, tc.kernel, tc.options)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNormalizeKernel(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tkernel []float64\n\t\twant   []float64\n\t}{\n\t\t{\n\t\t\tname: \"positive sum\",\n\t\t\tkernel: []float64{\n\t\t\t\t2, 0, 2,\n\t\t\t\t0, 2, 0,\n\t\t\t\t2, 0, 2,\n\t\t\t},\n\t\t\twant: []float64{\n\t\t\t\t0.2, 0, 0.2,\n\t\t\t\t0, 0.2, 0,\n\t\t\t\t0.2, 0, 0.2,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"negative sum\",\n\t\t\tkernel: []float64{\n\t\t\t\t-2, 0, -2,\n\t\t\t\t2, 2, 2,\n\t\t\t\t-2, 0, -2,\n\t\t\t},\n\t\t\twant: []float64{\n\t\t\t\t1, 0, 1,\n\t\t\t\t-1, -1, -1,\n\t\t\t\t1, 0, 1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero sum\",\n\t\t\tkernel: []float64{\n\t\t\t\t0, 2, 0,\n\t\t\t\t2, 0, -2,\n\t\t\t\t0, -2, 0,\n\t\t\t},\n\t\t\twant: []float64{\n\t\t\t\t0, 0.5, 0,\n\t\t\t\t0.5, 0, -0.5,\n\t\t\t\t0, -0.5, 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all zero\",\n\t\t\tkernel: []float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t\twant: []float64{\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnormalizeKernel(tc.kernel)\n\t\t\tfor i := range tc.kernel {\n\t\t\t\tif tc.kernel[i] != tc.want[i] {\n\t\t\t\t\tt.Fatalf(\"got kernel %v want %v\", tc.kernel, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkConvolve3x3(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tConvolve3x3(\n\t\t\ttestdataBranchesJPG,\n\t\t\t[9]float64{\n\t\t\t\t-1, -1, 0,\n\t\t\t\t-1, 0, 1,\n\t\t\t\t0, 1, 1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\t}\n}\n\nfunc BenchmarkConvolve5x5(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tConvolve5x5(\n\t\t\ttestdataBranchesJPG,\n\t\t\t[25]float64{\n\t\t\t\t-1, -1, -1, -1, 0,\n\t\t\t\t-1, -1, -1, 0, 1,\n\t\t\t\t-1, -1, 0, 1, 1,\n\t\t\t\t-1, 0, 1, 1, 1,\n\t\t\t\t0, 1, 1, 1, 1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.357421875,
          "content": "/*\nPackage imaging provides basic image processing functions (resize, rotate, crop, brightness/contrast adjustments, etc.).\n\nAll the image processing functions provided by the package accept any image type that implements image.Image interface\nas an input, and return a new image of *image.NRGBA type (32bit RGBA colors, non-premultiplied alpha).\n*/\npackage imaging\n"
        },
        {
          "name": "effects.go",
          "type": "blob",
          "size": 3.6845703125,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"math\"\n)\n\nfunc gaussianBlurKernel(x, sigma float64) float64 {\n\treturn math.Exp(-(x*x)/(2*sigma*sigma)) / (sigma * math.Sqrt(2*math.Pi))\n}\n\n// Blur produces a blurred version of the image using a Gaussian function.\n// Sigma parameter must be positive and indicates how much the image will be blurred.\n//\n// Example:\n//\n//\tdstImage := imaging.Blur(srcImage, 3.5)\n//\nfunc Blur(img image.Image, sigma float64) *image.NRGBA {\n\tif sigma <= 0 {\n\t\treturn Clone(img)\n\t}\n\n\tradius := int(math.Ceil(sigma * 3.0))\n\tkernel := make([]float64, radius+1)\n\n\tfor i := 0; i <= radius; i++ {\n\t\tkernel[i] = gaussianBlurKernel(float64(i), sigma)\n\t}\n\n\treturn blurVertical(blurHorizontal(img, kernel), kernel)\n}\n\nfunc blurHorizontal(img image.Image, kernel []float64) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tradius := len(kernel) - 1\n\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tscanLine := make([]uint8, src.w*4)\n\t\tscanLineF := make([]float64, len(scanLine))\n\t\tfor y := range ys {\n\t\t\tsrc.scan(0, y, src.w, y+1, scanLine)\n\t\t\tfor i, v := range scanLine {\n\t\t\t\tscanLineF[i] = float64(v)\n\t\t\t}\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\tmin := x - radius\n\t\t\t\tif min < 0 {\n\t\t\t\t\tmin = 0\n\t\t\t\t}\n\t\t\t\tmax := x + radius\n\t\t\t\tif max > src.w-1 {\n\t\t\t\t\tmax = src.w - 1\n\t\t\t\t}\n\t\t\t\tvar r, g, b, a, wsum float64\n\t\t\t\tfor ix := min; ix <= max; ix++ {\n\t\t\t\t\ti := ix * 4\n\t\t\t\t\tweight := kernel[absint(x-ix)]\n\t\t\t\t\twsum += weight\n\t\t\t\t\ts := scanLineF[i : i+4 : i+4]\n\t\t\t\t\twa := s[3] * weight\n\t\t\t\t\tr += s[0] * wa\n\t\t\t\t\tg += s[1] * wa\n\t\t\t\t\tb += s[2] * wa\n\t\t\t\t\ta += wa\n\t\t\t\t}\n\t\t\t\tif a != 0 {\n\t\t\t\t\taInv := 1 / a\n\t\t\t\t\tj := y*dst.Stride + x*4\n\t\t\t\t\td := dst.Pix[j : j+4 : j+4]\n\t\t\t\t\td[0] = clamp(r * aInv)\n\t\t\t\t\td[1] = clamp(g * aInv)\n\t\t\t\t\td[2] = clamp(b * aInv)\n\t\t\t\t\td[3] = clamp(a / wsum)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\treturn dst\n}\n\nfunc blurVertical(img image.Image, kernel []float64) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tradius := len(kernel) - 1\n\n\tparallel(0, src.w, func(xs <-chan int) {\n\t\tscanLine := make([]uint8, src.h*4)\n\t\tscanLineF := make([]float64, len(scanLine))\n\t\tfor x := range xs {\n\t\t\tsrc.scan(x, 0, x+1, src.h, scanLine)\n\t\t\tfor i, v := range scanLine {\n\t\t\t\tscanLineF[i] = float64(v)\n\t\t\t}\n\t\t\tfor y := 0; y < src.h; y++ {\n\t\t\t\tmin := y - radius\n\t\t\t\tif min < 0 {\n\t\t\t\t\tmin = 0\n\t\t\t\t}\n\t\t\t\tmax := y + radius\n\t\t\t\tif max > src.h-1 {\n\t\t\t\t\tmax = src.h - 1\n\t\t\t\t}\n\t\t\t\tvar r, g, b, a, wsum float64\n\t\t\t\tfor iy := min; iy <= max; iy++ {\n\t\t\t\t\ti := iy * 4\n\t\t\t\t\tweight := kernel[absint(y-iy)]\n\t\t\t\t\twsum += weight\n\t\t\t\t\ts := scanLineF[i : i+4 : i+4]\n\t\t\t\t\twa := s[3] * weight\n\t\t\t\t\tr += s[0] * wa\n\t\t\t\t\tg += s[1] * wa\n\t\t\t\t\tb += s[2] * wa\n\t\t\t\t\ta += wa\n\t\t\t\t}\n\t\t\t\tif a != 0 {\n\t\t\t\t\taInv := 1 / a\n\t\t\t\t\tj := y*dst.Stride + x*4\n\t\t\t\t\td := dst.Pix[j : j+4 : j+4]\n\t\t\t\t\td[0] = clamp(r * aInv)\n\t\t\t\t\td[1] = clamp(g * aInv)\n\t\t\t\t\td[2] = clamp(b * aInv)\n\t\t\t\t\td[3] = clamp(a / wsum)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\treturn dst\n}\n\n// Sharpen produces a sharpened version of the image.\n// Sigma parameter must be positive and indicates how much the image will be sharpened.\n//\n// Example:\n//\n//\tdstImage := imaging.Sharpen(srcImage, 3.5)\n//\nfunc Sharpen(img image.Image, sigma float64) *image.NRGBA {\n\tif sigma <= 0 {\n\t\treturn Clone(img)\n\t}\n\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tblurred := Blur(img, sigma)\n\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tscanLine := make([]uint8, src.w*4)\n\t\tfor y := range ys {\n\t\t\tsrc.scan(0, y, src.w, y+1, scanLine)\n\t\t\tj := y * dst.Stride\n\t\t\tfor i := 0; i < src.w*4; i++ {\n\t\t\t\tval := int(scanLine[i])<<1 - int(blurred.Pix[j])\n\t\t\t\tif val < 0 {\n\t\t\t\t\tval = 0\n\t\t\t\t} else if val > 0xff {\n\t\t\t\t\tval = 0xff\n\t\t\t\t}\n\t\t\t\tdst.Pix[j] = uint8(val)\n\t\t\t\tj++\n\t\t\t}\n\t\t}\n\t})\n\n\treturn dst\n}\n"
        },
        {
          "name": "effects_test.go",
          "type": "blob",
          "size": 6.30859375,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"testing\"\n)\n\nfunc TestBlur(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tsrc   image.Image\n\t\tsigma float64\n\t\twant  *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Blur 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x66, 0xaa, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x66, 0xaa, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Blur 3x3 0.5\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x66, 0xaa, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x04, 0x66, 0xaa, 0xff, 0x18, 0x66, 0xaa, 0xff, 0x04,\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x18, 0x66, 0xaa, 0xff, 0x9e, 0x66, 0xaa, 0xff, 0x18,\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x04, 0x66, 0xaa, 0xff, 0x18, 0x66, 0xaa, 0xff, 0x04,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Blur 3x3 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x66, 0xaa, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c,\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c,\n\t\t\t\t\t0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c, 0x66, 0xaa, 0xff, 0x1c,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Blur(tc.src, tc.sigma)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBlurGolden(t *testing.T) {\n\tfor name, sigma := range map[string]float64{\n\t\t\"out_blur_0.5.png\": 0.5,\n\t\t\"out_blur_1.5.png\": 1.5,\n\t} {\n\t\tgot := Blur(testdataFlowersSmallPNG, sigma)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkBlur(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tBlur(testdataBranchesJPG, 3)\n\t}\n}\n\nfunc TestSharpen(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tsrc   image.Image\n\t\tsigma float64\n\t\twant  *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Sharpen 3x3 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77, 0x77, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77, 0x77, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Sharpen 3x3 0.5\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77, 0x77, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x64, 0x64, 0x64, 0x64, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x64, 0x64, 0x64, 0x64, 0x7d, 0x7d, 0x7d, 0x7e, 0x64, 0x64, 0x64, 0x64,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x64, 0x64, 0x64, 0x64, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Sharpen 3x3 100\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77, 0x77, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n\t\t\t\t},\n\t\t\t},\n\t\t\t100,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,\n\t\t\t\t\t0x64, 0x64, 0x64, 0x64, 0x86, 0x86, 0x86, 0x86, 0x64, 0x64, 0x64, 0x64,\n\t\t\t\t\t0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Sharpen 3x1 10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 0),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 1),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Sharpen(tc.src, tc.sigma)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSharpenGolden(t *testing.T) {\n\tfor name, sigma := range map[string]float64{\n\t\t\"out_sharpen_0.5.png\": 0.5,\n\t\t\"out_sharpen_1.5.png\": 1.5,\n\t} {\n\t\tgot := Sharpen(testdataFlowersSmallPNG, sigma)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc BenchmarkSharpen(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tSharpen(testdataBranchesJPG, 3)\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.4775390625,
          "content": "package imaging_test\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"log\"\n\n\t\"github.com/disintegration/imaging\"\n)\n\nfunc Example() {\n\t// Open a test image.\n\tsrc, err := imaging.Open(\"testdata/flowers.png\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to open image: %v\", err)\n\t}\n\n\t// Crop the original image to 300x300px size using the center anchor.\n\tsrc = imaging.CropAnchor(src, 300, 300, imaging.Center)\n\n\t// Resize the cropped image to width = 200px preserving the aspect ratio.\n\tsrc = imaging.Resize(src, 200, 0, imaging.Lanczos)\n\n\t// Create a blurred version of the image.\n\timg1 := imaging.Blur(src, 5)\n\n\t// Create a grayscale version of the image with higher contrast and sharpness.\n\timg2 := imaging.Grayscale(src)\n\timg2 = imaging.AdjustContrast(img2, 20)\n\timg2 = imaging.Sharpen(img2, 2)\n\n\t// Create an inverted version of the image.\n\timg3 := imaging.Invert(src)\n\n\t// Create an embossed version of the image using a convolution filter.\n\timg4 := imaging.Convolve3x3(\n\t\tsrc,\n\t\t[9]float64{\n\t\t\t-1, -1, 0,\n\t\t\t-1, 1, 1,\n\t\t\t0, 1, 1,\n\t\t},\n\t\tnil,\n\t)\n\n\t// Create a new image and paste the four produced images into it.\n\tdst := imaging.New(400, 400, color.NRGBA{0, 0, 0, 0})\n\tdst = imaging.Paste(dst, img1, image.Pt(0, 0))\n\tdst = imaging.Paste(dst, img2, image.Pt(0, 200))\n\tdst = imaging.Paste(dst, img3, image.Pt(200, 0))\n\tdst = imaging.Paste(dst, img4, image.Pt(200, 200))\n\n\t// Save the resulting image as JPEG.\n\terr = imaging.Save(dst, \"testdata/out_example.jpg\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to save image: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1015625,
          "content": "module github.com/disintegration/imaging\n\nrequire golang.org/x/image v0.0.0-20191009234506-e7c1f5e7dbb8\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2841796875,
          "content": "golang.org/x/image v0.0.0-20191009234506-e7c1f5e7dbb8 h1:hVwzHzIUGRjiF7EcUjqNxk3NCfkPxbDKRdnNE1Rpg0U=\ngolang.org/x/image v0.0.0-20191009234506-e7c1f5e7dbb8/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n"
        },
        {
          "name": "histogram.go",
          "type": "blob",
          "size": 1.0732421875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"sync\"\n)\n\n// Histogram returns a normalized histogram of an image.\n//\n// Resulting histogram is represented as an array of 256 floats, where\n// histogram[i] is a probability of a pixel being of a particular luminance i.\nfunc Histogram(img image.Image) [256]float64 {\n\tvar mu sync.Mutex\n\tvar histogram [256]float64\n\tvar total float64\n\n\tsrc := newScanner(img)\n\tif src.w == 0 || src.h == 0 {\n\t\treturn histogram\n\t}\n\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tvar tmpHistogram [256]float64\n\t\tvar tmpTotal float64\n\t\tscanLine := make([]uint8, src.w*4)\n\t\tfor y := range ys {\n\t\t\tsrc.scan(0, y, src.w, y+1, scanLine)\n\t\t\ti := 0\n\t\t\tfor x := 0; x < src.w; x++ {\n\t\t\t\ts := scanLine[i : i+3 : i+3]\n\t\t\t\tr := s[0]\n\t\t\t\tg := s[1]\n\t\t\t\tb := s[2]\n\t\t\t\ty := 0.299*float32(r) + 0.587*float32(g) + 0.114*float32(b)\n\t\t\t\ttmpHistogram[int(y+0.5)]++\n\t\t\t\ttmpTotal++\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\t\tmu.Lock()\n\t\tfor i := 0; i < 256; i++ {\n\t\t\thistogram[i] += tmpHistogram[i]\n\t\t}\n\t\ttotal += tmpTotal\n\t\tmu.Unlock()\n\t})\n\n\tfor i := 0; i < 256; i++ {\n\t\thistogram[i] = histogram[i] / total\n\t}\n\treturn histogram\n}\n"
        },
        {
          "name": "histogram_test.go",
          "type": "blob",
          "size": 1.154296875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"testing\"\n)\n\nfunc TestHistogram(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\timg  image.Image\n\t\twant [256]float64\n\t}{\n\t\t{\n\t\t\tname: \"grayscale\",\n\t\t\timg: &image.RGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0x80, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [256]float64{0x00: 0.25, 0x80: 0.25, 0xff: 0.5},\n\t\t},\n\t\t{\n\t\t\tname: \"colorful\",\n\t\t\timg: &image.RGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x33, 0x44, 0x55, 0xff,\n\t\t\t\t\t0x55, 0x44, 0x33, 0xff, 0x77, 0x66, 0x55, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [256]float64{0x00: 0.25, 0x41: 0.25, 0x47: 0.25, 0x69: 0.25},\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\timg:  &image.RGBA{},\n\t\t\twant: [256]float64{},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Histogram(tc.img)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Fatalf(\"got histogram %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkHistogram(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tHistogram(testdataBranchesJPG)\n\t}\n}\n"
        },
        {
          "name": "io.go",
          "type": "blob",
          "size": 11.041015625,
          "content": "package imaging\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/gif\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/image/bmp\"\n\t\"golang.org/x/image/tiff\"\n)\n\ntype fileSystem interface {\n\tCreate(string) (io.WriteCloser, error)\n\tOpen(string) (io.ReadCloser, error)\n}\n\ntype localFS struct{}\n\nfunc (localFS) Create(name string) (io.WriteCloser, error) { return os.Create(name) }\nfunc (localFS) Open(name string) (io.ReadCloser, error)    { return os.Open(name) }\n\nvar fs fileSystem = localFS{}\n\ntype decodeConfig struct {\n\tautoOrientation bool\n}\n\nvar defaultDecodeConfig = decodeConfig{\n\tautoOrientation: false,\n}\n\n// DecodeOption sets an optional parameter for the Decode and Open functions.\ntype DecodeOption func(*decodeConfig)\n\n// AutoOrientation returns a DecodeOption that sets the auto-orientation mode.\n// If auto-orientation is enabled, the image will be transformed after decoding\n// according to the EXIF orientation tag (if present). By default it's disabled.\nfunc AutoOrientation(enabled bool) DecodeOption {\n\treturn func(c *decodeConfig) {\n\t\tc.autoOrientation = enabled\n\t}\n}\n\n// Decode reads an image from r.\nfunc Decode(r io.Reader, opts ...DecodeOption) (image.Image, error) {\n\tcfg := defaultDecodeConfig\n\tfor _, option := range opts {\n\t\toption(&cfg)\n\t}\n\n\tif !cfg.autoOrientation {\n\t\timg, _, err := image.Decode(r)\n\t\treturn img, err\n\t}\n\n\tvar orient orientation\n\tpr, pw := io.Pipe()\n\tr = io.TeeReader(r, pw)\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\torient = readOrientation(pr)\n\t\tio.Copy(ioutil.Discard, pr)\n\t}()\n\n\timg, _, err := image.Decode(r)\n\tpw.Close()\n\t<-done\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fixOrientation(img, orient), nil\n}\n\n// Open loads an image from file.\n//\n// Examples:\n//\n//\t// Load an image from file.\n//\timg, err := imaging.Open(\"test.jpg\")\n//\n//\t// Load an image and transform it depending on the EXIF orientation tag (if present).\n//\timg, err := imaging.Open(\"test.jpg\", imaging.AutoOrientation(true))\n//\nfunc Open(filename string, opts ...DecodeOption) (image.Image, error) {\n\tfile, err := fs.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\treturn Decode(file, opts...)\n}\n\n// Format is an image file format.\ntype Format int\n\n// Image file formats.\nconst (\n\tJPEG Format = iota\n\tPNG\n\tGIF\n\tTIFF\n\tBMP\n)\n\nvar formatExts = map[string]Format{\n\t\"jpg\":  JPEG,\n\t\"jpeg\": JPEG,\n\t\"png\":  PNG,\n\t\"gif\":  GIF,\n\t\"tif\":  TIFF,\n\t\"tiff\": TIFF,\n\t\"bmp\":  BMP,\n}\n\nvar formatNames = map[Format]string{\n\tJPEG: \"JPEG\",\n\tPNG:  \"PNG\",\n\tGIF:  \"GIF\",\n\tTIFF: \"TIFF\",\n\tBMP:  \"BMP\",\n}\n\nfunc (f Format) String() string {\n\treturn formatNames[f]\n}\n\n// ErrUnsupportedFormat means the given image format is not supported.\nvar ErrUnsupportedFormat = errors.New(\"imaging: unsupported image format\")\n\n// FormatFromExtension parses image format from filename extension:\n// \"jpg\" (or \"jpeg\"), \"png\", \"gif\", \"tif\" (or \"tiff\") and \"bmp\" are supported.\nfunc FormatFromExtension(ext string) (Format, error) {\n\tif f, ok := formatExts[strings.ToLower(strings.TrimPrefix(ext, \".\"))]; ok {\n\t\treturn f, nil\n\t}\n\treturn -1, ErrUnsupportedFormat\n}\n\n// FormatFromFilename parses image format from filename:\n// \"jpg\" (or \"jpeg\"), \"png\", \"gif\", \"tif\" (or \"tiff\") and \"bmp\" are supported.\nfunc FormatFromFilename(filename string) (Format, error) {\n\text := filepath.Ext(filename)\n\treturn FormatFromExtension(ext)\n}\n\ntype encodeConfig struct {\n\tjpegQuality         int\n\tgifNumColors        int\n\tgifQuantizer        draw.Quantizer\n\tgifDrawer           draw.Drawer\n\tpngCompressionLevel png.CompressionLevel\n}\n\nvar defaultEncodeConfig = encodeConfig{\n\tjpegQuality:         95,\n\tgifNumColors:        256,\n\tgifQuantizer:        nil,\n\tgifDrawer:           nil,\n\tpngCompressionLevel: png.DefaultCompression,\n}\n\n// EncodeOption sets an optional parameter for the Encode and Save functions.\ntype EncodeOption func(*encodeConfig)\n\n// JPEGQuality returns an EncodeOption that sets the output JPEG quality.\n// Quality ranges from 1 to 100 inclusive, higher is better. Default is 95.\nfunc JPEGQuality(quality int) EncodeOption {\n\treturn func(c *encodeConfig) {\n\t\tc.jpegQuality = quality\n\t}\n}\n\n// GIFNumColors returns an EncodeOption that sets the maximum number of colors\n// used in the GIF-encoded image. It ranges from 1 to 256.  Default is 256.\nfunc GIFNumColors(numColors int) EncodeOption {\n\treturn func(c *encodeConfig) {\n\t\tc.gifNumColors = numColors\n\t}\n}\n\n// GIFQuantizer returns an EncodeOption that sets the quantizer that is used to produce\n// a palette of the GIF-encoded image.\nfunc GIFQuantizer(quantizer draw.Quantizer) EncodeOption {\n\treturn func(c *encodeConfig) {\n\t\tc.gifQuantizer = quantizer\n\t}\n}\n\n// GIFDrawer returns an EncodeOption that sets the drawer that is used to convert\n// the source image to the desired palette of the GIF-encoded image.\nfunc GIFDrawer(drawer draw.Drawer) EncodeOption {\n\treturn func(c *encodeConfig) {\n\t\tc.gifDrawer = drawer\n\t}\n}\n\n// PNGCompressionLevel returns an EncodeOption that sets the compression level\n// of the PNG-encoded image. Default is png.DefaultCompression.\nfunc PNGCompressionLevel(level png.CompressionLevel) EncodeOption {\n\treturn func(c *encodeConfig) {\n\t\tc.pngCompressionLevel = level\n\t}\n}\n\n// Encode writes the image img to w in the specified format (JPEG, PNG, GIF, TIFF or BMP).\nfunc Encode(w io.Writer, img image.Image, format Format, opts ...EncodeOption) error {\n\tcfg := defaultEncodeConfig\n\tfor _, option := range opts {\n\t\toption(&cfg)\n\t}\n\n\tswitch format {\n\tcase JPEG:\n\t\tif nrgba, ok := img.(*image.NRGBA); ok && nrgba.Opaque() {\n\t\t\trgba := &image.RGBA{\n\t\t\t\tPix:    nrgba.Pix,\n\t\t\t\tStride: nrgba.Stride,\n\t\t\t\tRect:   nrgba.Rect,\n\t\t\t}\n\t\t\treturn jpeg.Encode(w, rgba, &jpeg.Options{Quality: cfg.jpegQuality})\n\t\t}\n\t\treturn jpeg.Encode(w, img, &jpeg.Options{Quality: cfg.jpegQuality})\n\n\tcase PNG:\n\t\tencoder := png.Encoder{CompressionLevel: cfg.pngCompressionLevel}\n\t\treturn encoder.Encode(w, img)\n\n\tcase GIF:\n\t\treturn gif.Encode(w, img, &gif.Options{\n\t\t\tNumColors: cfg.gifNumColors,\n\t\t\tQuantizer: cfg.gifQuantizer,\n\t\t\tDrawer:    cfg.gifDrawer,\n\t\t})\n\n\tcase TIFF:\n\t\treturn tiff.Encode(w, img, &tiff.Options{Compression: tiff.Deflate, Predictor: true})\n\n\tcase BMP:\n\t\treturn bmp.Encode(w, img)\n\t}\n\n\treturn ErrUnsupportedFormat\n}\n\n// Save saves the image to file with the specified filename.\n// The format is determined from the filename extension:\n// \"jpg\" (or \"jpeg\"), \"png\", \"gif\", \"tif\" (or \"tiff\") and \"bmp\" are supported.\n//\n// Examples:\n//\n//\t// Save the image as PNG.\n//\terr := imaging.Save(img, \"out.png\")\n//\n//\t// Save the image as JPEG with optional quality parameter set to 80.\n//\terr := imaging.Save(img, \"out.jpg\", imaging.JPEGQuality(80))\n//\nfunc Save(img image.Image, filename string, opts ...EncodeOption) (err error) {\n\tf, err := FormatFromFilename(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfile, err := fs.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = Encode(file, img, f, opts...)\n\terrc := file.Close()\n\tif err == nil {\n\t\terr = errc\n\t}\n\treturn err\n}\n\n// orientation is an EXIF flag that specifies the transformation\n// that should be applied to image to display it correctly.\ntype orientation int\n\nconst (\n\torientationUnspecified = 0\n\torientationNormal      = 1\n\torientationFlipH       = 2\n\torientationRotate180   = 3\n\torientationFlipV       = 4\n\torientationTranspose   = 5\n\torientationRotate270   = 6\n\torientationTransverse  = 7\n\torientationRotate90    = 8\n)\n\n// readOrientation tries to read the orientation EXIF flag from image data in r.\n// If the EXIF data block is not found or the orientation flag is not found\n// or any other error occures while reading the data, it returns the\n// orientationUnspecified (0) value.\nfunc readOrientation(r io.Reader) orientation {\n\tconst (\n\t\tmarkerSOI      = 0xffd8\n\t\tmarkerAPP1     = 0xffe1\n\t\texifHeader     = 0x45786966\n\t\tbyteOrderBE    = 0x4d4d\n\t\tbyteOrderLE    = 0x4949\n\t\torientationTag = 0x0112\n\t)\n\n\t// Check if JPEG SOI marker is present.\n\tvar soi uint16\n\tif err := binary.Read(r, binary.BigEndian, &soi); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\tif soi != markerSOI {\n\t\treturn orientationUnspecified // Missing JPEG SOI marker.\n\t}\n\n\t// Find JPEG APP1 marker.\n\tfor {\n\t\tvar marker, size uint16\n\t\tif err := binary.Read(r, binary.BigEndian, &marker); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t\tif err := binary.Read(r, binary.BigEndian, &size); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t\tif marker>>8 != 0xff {\n\t\t\treturn orientationUnspecified // Invalid JPEG marker.\n\t\t}\n\t\tif marker == markerAPP1 {\n\t\t\tbreak\n\t\t}\n\t\tif size < 2 {\n\t\t\treturn orientationUnspecified // Invalid block size.\n\t\t}\n\t\tif _, err := io.CopyN(ioutil.Discard, r, int64(size-2)); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t}\n\n\t// Check if EXIF header is present.\n\tvar header uint32\n\tif err := binary.Read(r, binary.BigEndian, &header); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\tif header != exifHeader {\n\t\treturn orientationUnspecified\n\t}\n\tif _, err := io.CopyN(ioutil.Discard, r, 2); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\n\t// Read byte order information.\n\tvar (\n\t\tbyteOrderTag uint16\n\t\tbyteOrder    binary.ByteOrder\n\t)\n\tif err := binary.Read(r, binary.BigEndian, &byteOrderTag); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\tswitch byteOrderTag {\n\tcase byteOrderBE:\n\t\tbyteOrder = binary.BigEndian\n\tcase byteOrderLE:\n\t\tbyteOrder = binary.LittleEndian\n\tdefault:\n\t\treturn orientationUnspecified // Invalid byte order flag.\n\t}\n\tif _, err := io.CopyN(ioutil.Discard, r, 2); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\n\t// Skip the EXIF offset.\n\tvar offset uint32\n\tif err := binary.Read(r, byteOrder, &offset); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\tif offset < 8 {\n\t\treturn orientationUnspecified // Invalid offset value.\n\t}\n\tif _, err := io.CopyN(ioutil.Discard, r, int64(offset-8)); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\n\t// Read the number of tags.\n\tvar numTags uint16\n\tif err := binary.Read(r, byteOrder, &numTags); err != nil {\n\t\treturn orientationUnspecified\n\t}\n\n\t// Find the orientation tag.\n\tfor i := 0; i < int(numTags); i++ {\n\t\tvar tag uint16\n\t\tif err := binary.Read(r, byteOrder, &tag); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t\tif tag != orientationTag {\n\t\t\tif _, err := io.CopyN(ioutil.Discard, r, 10); err != nil {\n\t\t\t\treturn orientationUnspecified\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif _, err := io.CopyN(ioutil.Discard, r, 6); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t\tvar val uint16\n\t\tif err := binary.Read(r, byteOrder, &val); err != nil {\n\t\t\treturn orientationUnspecified\n\t\t}\n\t\tif val < 1 || val > 8 {\n\t\t\treturn orientationUnspecified // Invalid tag value.\n\t\t}\n\t\treturn orientation(val)\n\t}\n\treturn orientationUnspecified // Missing orientation tag.\n}\n\n// fixOrientation applies a transform to img corresponding to the given orientation flag.\nfunc fixOrientation(img image.Image, o orientation) image.Image {\n\tswitch o {\n\tcase orientationNormal:\n\tcase orientationFlipH:\n\t\timg = FlipH(img)\n\tcase orientationFlipV:\n\t\timg = FlipV(img)\n\tcase orientationRotate90:\n\t\timg = Rotate90(img)\n\tcase orientationRotate180:\n\t\timg = Rotate180(img)\n\tcase orientationRotate270:\n\t\timg = Rotate270(img)\n\tcase orientationTranspose:\n\t\timg = Transpose(img)\n\tcase orientationTransverse:\n\t\timg = Transverse(img)\n\t}\n\treturn img\n}\n"
        },
        {
          "name": "io_test.go",
          "type": "blob",
          "size": 10.44921875,
          "content": "package imaging\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/color/palette\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar (\n\terrCreate = errors.New(\"failed to create file\")\n\terrClose  = errors.New(\"failed to close file\")\n\terrOpen   = errors.New(\"failed to open file\")\n)\n\ntype badFS struct{}\n\nfunc (badFS) Create(name string) (io.WriteCloser, error) {\n\tif name == \"badFile.jpg\" {\n\t\treturn badFile{ioutil.Discard}, nil\n\t}\n\treturn nil, errCreate\n}\n\nfunc (badFS) Open(name string) (io.ReadCloser, error) {\n\treturn nil, errOpen\n}\n\ntype badFile struct {\n\tio.Writer\n}\n\nfunc (badFile) Close() error {\n\treturn errClose\n}\n\ntype quantizer struct {\n\tpalette []color.Color\n}\n\nfunc (q quantizer) Quantize(p color.Palette, m image.Image) color.Palette {\n\tpal := make([]color.Color, len(p), cap(p))\n\tcopy(pal, p)\n\tn := cap(p) - len(p)\n\tif n > len(q.palette) {\n\t\tn = len(q.palette)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tpal = append(pal, q.palette[i])\n\t}\n\treturn pal\n}\n\nfunc TestOpenSave(t *testing.T) {\n\timgWithoutAlpha := image.NewNRGBA(image.Rect(0, 0, 4, 6))\n\timgWithoutAlpha.Pix = []uint8{\n\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x88, 0x88, 0x88, 0xff, 0x88, 0x88, 0x88, 0xff,\n\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x88, 0x88, 0x88, 0xff, 0x88, 0x88, 0x88, 0xff,\n\t}\n\timgWithAlpha := image.NewNRGBA(image.Rect(0, 0, 4, 6))\n\timgWithAlpha.Pix = []uint8{\n\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x80, 0x00, 0xff, 0x00, 0x80, 0x00, 0xff, 0x00, 0x80,\n\t\t0xff, 0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x80, 0x00, 0xff, 0x00, 0x80, 0x00, 0xff, 0x00, 0x80,\n\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x88, 0x88, 0x88, 0x00, 0x88, 0x88, 0x88, 0x00,\n\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x88, 0x88, 0x88, 0x00, 0x88, 0x88, 0x88, 0x00,\n\t}\n\n\toptions := [][]EncodeOption{\n\t\t{\n\t\t\tJPEGQuality(100),\n\t\t},\n\t\t{\n\t\t\tJPEGQuality(99),\n\t\t\tGIFDrawer(draw.FloydSteinberg),\n\t\t\tGIFNumColors(256),\n\t\t\tGIFQuantizer(quantizer{palette.Plan9}),\n\t\t\tPNGCompressionLevel(png.BestSpeed),\n\t\t},\n\t}\n\n\tdir, err := ioutil.TempDir(\"\", \"imaging\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(dir)\n\n\tfor _, ext := range []string{\"jpg\", \"jpeg\", \"png\", \"gif\", \"bmp\", \"tif\", \"tiff\"} {\n\t\tfilename := filepath.Join(dir, \"test.\"+ext)\n\n\t\timg := imgWithoutAlpha\n\t\tif ext == \"png\" {\n\t\t\timg = imgWithAlpha\n\t\t}\n\n\t\tfor _, opts := range options {\n\t\t\terr := Save(img, filename, opts...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to save image (%q): %v\", filename, err)\n\t\t\t}\n\n\t\t\timg2, err := Open(filename)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to open image (%q): %v\", filename, err)\n\t\t\t}\n\t\t\tgot := Clone(img2)\n\n\t\t\tdelta := 0\n\t\t\tif ext == \"jpg\" || ext == \"jpeg\" || ext == \"gif\" {\n\t\t\t\tdelta = 3\n\t\t\t}\n\n\t\t\tif !compareNRGBA(got, img, delta) {\n\t\t\t\tt.Fatalf(\"bad encode-decode result (ext=%q): got %#v want %#v\", ext, got, img)\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf := &bytes.Buffer{}\n\terr = Encode(buf, imgWithAlpha, JPEG)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to encode alpha to JPEG: %v\", err)\n\t}\n\n\tbuf = &bytes.Buffer{}\n\terr = Encode(buf, imgWithAlpha, Format(100))\n\tif err != ErrUnsupportedFormat {\n\t\tt.Fatalf(\"got %v want ErrUnsupportedFormat\", err)\n\t}\n\n\tbuf = bytes.NewBuffer([]byte(\"bad data\"))\n\t_, err = Decode(buf)\n\tif err == nil {\n\t\tt.Fatalf(\"decoding bad data: expected error got nil\")\n\t}\n\n\terr = Save(imgWithAlpha, filepath.Join(dir, \"test.unknown\"))\n\tif err != ErrUnsupportedFormat {\n\t\tt.Fatalf(\"got %v want ErrUnsupportedFormat\", err)\n\t}\n\n\tprevFS := fs\n\tfs = badFS{}\n\tdefer func() { fs = prevFS }()\n\n\terr = Save(imgWithAlpha, \"test.jpg\")\n\tif err != errCreate {\n\t\tt.Fatalf(\"got error %v want errCreate\", err)\n\t}\n\n\terr = Save(imgWithAlpha, \"badFile.jpg\")\n\tif err != errClose {\n\t\tt.Fatalf(\"got error %v want errClose\", err)\n\t}\n\n\t_, err = Open(\"test.jpg\")\n\tif err != errOpen {\n\t\tt.Fatalf(\"got error %v want errOpen\", err)\n\t}\n}\n\nfunc TestFormats(t *testing.T) {\n\tformatNames := map[Format]string{\n\t\tJPEG:       \"JPEG\",\n\t\tPNG:        \"PNG\",\n\t\tGIF:        \"GIF\",\n\t\tBMP:        \"BMP\",\n\t\tTIFF:       \"TIFF\",\n\t\tFormat(-1): \"\",\n\t}\n\tfor format, name := range formatNames {\n\t\tgot := format.String()\n\t\tif got != name {\n\t\t\tt.Fatalf(\"got format name %q want %q\", got, name)\n\t\t}\n\t}\n}\n\nfunc TestFormatFromExtension(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\text  string\n\t\twant Format\n\t\terr  error\n\t}{\n\t\t{\n\t\t\tname: \"jpg without leading dot\",\n\t\t\text:  \"jpg\",\n\t\t\twant: JPEG,\n\t\t},\n\t\t{\n\t\t\tname: \"jpg with leading dot\",\n\t\t\text:  \".jpg\",\n\t\t\twant: JPEG,\n\t\t},\n\t\t{\n\t\t\tname: \"jpg uppercase\",\n\t\t\text:  \".JPG\",\n\t\t\twant: JPEG,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported\",\n\t\t\text:  \".unsupportedextension\",\n\t\t\twant: -1,\n\t\t\terr:  ErrUnsupportedFormat,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := FormatFromExtension(tc.ext)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"got error %#v want %#v\", err, tc.err)\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReadOrientation(t *testing.T) {\n\ttestCases := []struct {\n\t\tpath   string\n\t\torient orientation\n\t}{\n\t\t{\"testdata/orientation_0.jpg\", 0},\n\t\t{\"testdata/orientation_1.jpg\", 1},\n\t\t{\"testdata/orientation_2.jpg\", 2},\n\t\t{\"testdata/orientation_3.jpg\", 3},\n\t\t{\"testdata/orientation_4.jpg\", 4},\n\t\t{\"testdata/orientation_5.jpg\", 5},\n\t\t{\"testdata/orientation_6.jpg\", 6},\n\t\t{\"testdata/orientation_7.jpg\", 7},\n\t\t{\"testdata/orientation_8.jpg\", 8},\n\t}\n\tfor _, tc := range testCases {\n\t\tf, err := os.Open(tc.path)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%q: failed to open: %v\", tc.path, err)\n\t\t}\n\t\torient := readOrientation(f)\n\t\tif orient != tc.orient {\n\t\t\tt.Fatalf(\"%q: got orientation %d want %d\", tc.path, orient, tc.orient)\n\t\t}\n\t}\n}\n\nfunc TestReadOrientationFails(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tdata string\n\t}{\n\t\t{\n\t\t\t\"empty\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"missing SOI marker\",\n\t\t\t\"\\xff\\xe1\",\n\t\t},\n\t\t{\n\t\t\t\"missing APP1 marker\",\n\t\t\t\"\\xff\\xd8\",\n\t\t},\n\t\t{\n\t\t\t\"short read marker\",\n\t\t\t\"\\xff\\xd8\\xff\",\n\t\t},\n\t\t{\n\t\t\t\"short read block size\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"invalid marker\",\n\t\t\t\"\\xff\\xd8\\x00\\xe1\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"block size too small\",\n\t\t\t\"\\xff\\xd8\\xff\\xe0\\x00\\x01\",\n\t\t},\n\t\t{\n\t\t\t\"short read block\",\n\t\t\t\"\\xff\\xd8\\xff\\xe0\\x00\\x08\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing EXIF header\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\",\n\t\t},\n\t\t{\n\t\t\t\"invalid EXIF header\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x00\\x00\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing EXIF header tail\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\",\n\t\t},\n\t\t{\n\t\t\t\"missing byte order tag\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"invalid byte order tag\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing byte order tail\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x49\\x49\",\n\t\t},\n\t\t{\n\t\t\t\"missing exif offset\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x49\\x49\\x00\\x2a\",\n\t\t},\n\t\t{\n\t\t\t\"invalid exif offset\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x07\",\n\t\t},\n\t\t{\n\t\t\t\"read exif offset error\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x09\",\n\t\t},\n\t\t{\n\t\t\t\"missing number of tags\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\",\n\t\t},\n\t\t{\n\t\t\t\"zero number of tags\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing tag\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\",\n\t\t},\n\t\t{\n\t\t\t\"missing tag offset\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing orientation tag\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t},\n\t\t{\n\t\t\t\"missing orientation tag value offset\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\\x01\\x12\",\n\t\t},\n\t\t{\n\t\t\t\"missing orientation value\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\\x01\\x12\\x00\\x03\\x00\\x00\\x00\\x01\",\n\t\t},\n\t\t{\n\t\t\t\"invalid orientation value\",\n\t\t\t\"\\xff\\xd8\\xff\\xe1\\x00\\xff\\x45\\x78\\x69\\x66\\x00\\x00\\x4d\\x4d\\x00\\x2a\\x00\\x00\\x00\\x08\\x00\\x01\\x01\\x12\\x00\\x03\\x00\\x00\\x00\\x01\\x00\\x09\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif o := readOrientation(strings.NewReader(tc.data)); o != orientationUnspecified {\n\t\t\t\tt.Fatalf(\"got orientation %d want %d\", o, orientationUnspecified)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAutoOrientation(t *testing.T) {\n\ttoBW := func(img image.Image) []byte {\n\t\tb := img.Bounds()\n\t\tdata := make([]byte, 0, b.Dx()*b.Dy())\n\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n\t\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n\t\t\t\tc := color.GrayModel.Convert(img.At(x, y)).(color.Gray)\n\t\t\t\tif c.Y < 128 {\n\t\t\t\t\tdata = append(data, 1)\n\t\t\t\t} else {\n\t\t\t\t\tdata = append(data, 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn data\n\t}\n\n\tf, err := os.Open(\"testdata/orientation_0.jpg\")\n\tif err != nil {\n\t\tt.Fatalf(\"os.Open(%q): %v\", \"testdata/orientation_0.jpg\", err)\n\t}\n\torig, _, err := image.Decode(f)\n\tif err != nil {\n\t\tt.Fatalf(\"image.Decode(%q): %v\", \"testdata/orientation_0.jpg\", err)\n\t}\n\torigBW := toBW(orig)\n\n\ttestCases := []struct {\n\t\tpath string\n\t}{\n\t\t{\"testdata/orientation_0.jpg\"},\n\t\t{\"testdata/orientation_1.jpg\"},\n\t\t{\"testdata/orientation_2.jpg\"},\n\t\t{\"testdata/orientation_3.jpg\"},\n\t\t{\"testdata/orientation_4.jpg\"},\n\t\t{\"testdata/orientation_5.jpg\"},\n\t\t{\"testdata/orientation_6.jpg\"},\n\t\t{\"testdata/orientation_7.jpg\"},\n\t\t{\"testdata/orientation_8.jpg\"},\n\t}\n\tfor _, tc := range testCases {\n\t\timg, err := Open(tc.path, AutoOrientation(true))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif img.Bounds() != orig.Bounds() {\n\t\t\tt.Fatalf(\"%s: got bounds %v want %v\", tc.path, img.Bounds(), orig.Bounds())\n\t\t}\n\t\timgBW := toBW(img)\n\t\tif !bytes.Equal(imgBW, origBW) {\n\t\t\tt.Fatalf(\"%s: got bw data %v want %v\", tc.path, imgBW, origBW)\n\t\t}\n\t}\n\n\tif _, err := Decode(strings.NewReader(\"invalid data\"), AutoOrientation(true)); err == nil {\n\t\tt.Fatal(\"expected error got nil\")\n\t}\n}\n"
        },
        {
          "name": "resize.go",
          "type": "blob",
          "size": 13.833984375,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"math\"\n)\n\ntype indexWeight struct {\n\tindex  int\n\tweight float64\n}\n\nfunc precomputeWeights(dstSize, srcSize int, filter ResampleFilter) [][]indexWeight {\n\tdu := float64(srcSize) / float64(dstSize)\n\tscale := du\n\tif scale < 1.0 {\n\t\tscale = 1.0\n\t}\n\tru := math.Ceil(scale * filter.Support)\n\n\tout := make([][]indexWeight, dstSize)\n\ttmp := make([]indexWeight, 0, dstSize*int(ru+2)*2)\n\n\tfor v := 0; v < dstSize; v++ {\n\t\tfu := (float64(v)+0.5)*du - 0.5\n\n\t\tbegin := int(math.Ceil(fu - ru))\n\t\tif begin < 0 {\n\t\t\tbegin = 0\n\t\t}\n\t\tend := int(math.Floor(fu + ru))\n\t\tif end > srcSize-1 {\n\t\t\tend = srcSize - 1\n\t\t}\n\n\t\tvar sum float64\n\t\tfor u := begin; u <= end; u++ {\n\t\t\tw := filter.Kernel((float64(u) - fu) / scale)\n\t\t\tif w != 0 {\n\t\t\t\tsum += w\n\t\t\t\ttmp = append(tmp, indexWeight{index: u, weight: w})\n\t\t\t}\n\t\t}\n\t\tif sum != 0 {\n\t\t\tfor i := range tmp {\n\t\t\t\ttmp[i].weight /= sum\n\t\t\t}\n\t\t}\n\n\t\tout[v] = tmp\n\t\ttmp = tmp[len(tmp):]\n\t}\n\n\treturn out\n}\n\n// Resize resizes the image to the specified width and height using the specified resampling\n// filter and returns the transformed image. If one of width or height is 0, the image aspect\n// ratio is preserved.\n//\n// Example:\n//\n//\tdstImage := imaging.Resize(srcImage, 800, 600, imaging.Lanczos)\n//\nfunc Resize(img image.Image, width, height int, filter ResampleFilter) *image.NRGBA {\n\tdstW, dstH := width, height\n\tif dstW < 0 || dstH < 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\tif dstW == 0 && dstH == 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tsrcW := img.Bounds().Dx()\n\tsrcH := img.Bounds().Dy()\n\tif srcW <= 0 || srcH <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\t// If new width or height is 0 then preserve aspect ratio, minimum 1px.\n\tif dstW == 0 {\n\t\ttmpW := float64(dstH) * float64(srcW) / float64(srcH)\n\t\tdstW = int(math.Max(1.0, math.Floor(tmpW+0.5)))\n\t}\n\tif dstH == 0 {\n\t\ttmpH := float64(dstW) * float64(srcH) / float64(srcW)\n\t\tdstH = int(math.Max(1.0, math.Floor(tmpH+0.5)))\n\t}\n\n\tif srcW == dstW && srcH == dstH {\n\t\treturn Clone(img)\n\t}\n\n\tif filter.Support <= 0 {\n\t\t// Nearest-neighbor special case.\n\t\treturn resizeNearest(img, dstW, dstH)\n\t}\n\n\tif srcW != dstW && srcH != dstH {\n\t\treturn resizeVertical(resizeHorizontal(img, dstW, filter), dstH, filter)\n\t}\n\tif srcW != dstW {\n\t\treturn resizeHorizontal(img, dstW, filter)\n\t}\n\treturn resizeVertical(img, dstH, filter)\n\n}\n\nfunc resizeHorizontal(img image.Image, width int, filter ResampleFilter) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, width, src.h))\n\tweights := precomputeWeights(width, src.w, filter)\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tscanLine := make([]uint8, src.w*4)\n\t\tfor y := range ys {\n\t\t\tsrc.scan(0, y, src.w, y+1, scanLine)\n\t\t\tj0 := y * dst.Stride\n\t\t\tfor x := range weights {\n\t\t\t\tvar r, g, b, a float64\n\t\t\t\tfor _, w := range weights[x] {\n\t\t\t\t\ti := w.index * 4\n\t\t\t\t\ts := scanLine[i : i+4 : i+4]\n\t\t\t\t\taw := float64(s[3]) * w.weight\n\t\t\t\t\tr += float64(s[0]) * aw\n\t\t\t\t\tg += float64(s[1]) * aw\n\t\t\t\t\tb += float64(s[2]) * aw\n\t\t\t\t\ta += aw\n\t\t\t\t}\n\t\t\t\tif a != 0 {\n\t\t\t\t\taInv := 1 / a\n\t\t\t\t\tj := j0 + x*4\n\t\t\t\t\td := dst.Pix[j : j+4 : j+4]\n\t\t\t\t\td[0] = clamp(r * aInv)\n\t\t\t\t\td[1] = clamp(g * aInv)\n\t\t\t\t\td[2] = clamp(b * aInv)\n\t\t\t\t\td[3] = clamp(a)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\nfunc resizeVertical(img image.Image, height int, filter ResampleFilter) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, height))\n\tweights := precomputeWeights(height, src.h, filter)\n\tparallel(0, src.w, func(xs <-chan int) {\n\t\tscanLine := make([]uint8, src.h*4)\n\t\tfor x := range xs {\n\t\t\tsrc.scan(x, 0, x+1, src.h, scanLine)\n\t\t\tfor y := range weights {\n\t\t\t\tvar r, g, b, a float64\n\t\t\t\tfor _, w := range weights[y] {\n\t\t\t\t\ti := w.index * 4\n\t\t\t\t\ts := scanLine[i : i+4 : i+4]\n\t\t\t\t\taw := float64(s[3]) * w.weight\n\t\t\t\t\tr += float64(s[0]) * aw\n\t\t\t\t\tg += float64(s[1]) * aw\n\t\t\t\t\tb += float64(s[2]) * aw\n\t\t\t\t\ta += aw\n\t\t\t\t}\n\t\t\t\tif a != 0 {\n\t\t\t\t\taInv := 1 / a\n\t\t\t\t\tj := y*dst.Stride + x*4\n\t\t\t\t\td := dst.Pix[j : j+4 : j+4]\n\t\t\t\t\td[0] = clamp(r * aInv)\n\t\t\t\t\td[1] = clamp(g * aInv)\n\t\t\t\t\td[2] = clamp(b * aInv)\n\t\t\t\t\td[3] = clamp(a)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\n// resizeNearest is a fast nearest-neighbor resize, no filtering.\nfunc resizeNearest(img image.Image, width, height int) *image.NRGBA {\n\tdst := image.NewNRGBA(image.Rect(0, 0, width, height))\n\tdx := float64(img.Bounds().Dx()) / float64(width)\n\tdy := float64(img.Bounds().Dy()) / float64(height)\n\n\tif dx > 1 && dy > 1 {\n\t\tsrc := newScanner(img)\n\t\tparallel(0, height, func(ys <-chan int) {\n\t\t\tfor y := range ys {\n\t\t\t\tsrcY := int((float64(y) + 0.5) * dy)\n\t\t\t\tdstOff := y * dst.Stride\n\t\t\t\tfor x := 0; x < width; x++ {\n\t\t\t\t\tsrcX := int((float64(x) + 0.5) * dx)\n\t\t\t\t\tsrc.scan(srcX, srcY, srcX+1, srcY+1, dst.Pix[dstOff:dstOff+4])\n\t\t\t\t\tdstOff += 4\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t} else {\n\t\tsrc := toNRGBA(img)\n\t\tparallel(0, height, func(ys <-chan int) {\n\t\t\tfor y := range ys {\n\t\t\t\tsrcY := int((float64(y) + 0.5) * dy)\n\t\t\t\tsrcOff0 := srcY * src.Stride\n\t\t\t\tdstOff := y * dst.Stride\n\t\t\t\tfor x := 0; x < width; x++ {\n\t\t\t\t\tsrcX := int((float64(x) + 0.5) * dx)\n\t\t\t\t\tsrcOff := srcOff0 + srcX*4\n\t\t\t\t\tcopy(dst.Pix[dstOff:dstOff+4], src.Pix[srcOff:srcOff+4])\n\t\t\t\t\tdstOff += 4\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\treturn dst\n}\n\n// Fit scales down the image using the specified resample filter to fit the specified\n// maximum width and height and returns the transformed image.\n//\n// Example:\n//\n//\tdstImage := imaging.Fit(srcImage, 800, 600, imaging.Lanczos)\n//\nfunc Fit(img image.Image, width, height int, filter ResampleFilter) *image.NRGBA {\n\tmaxW, maxH := width, height\n\n\tif maxW <= 0 || maxH <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tsrcBounds := img.Bounds()\n\tsrcW := srcBounds.Dx()\n\tsrcH := srcBounds.Dy()\n\n\tif srcW <= 0 || srcH <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tif srcW <= maxW && srcH <= maxH {\n\t\treturn Clone(img)\n\t}\n\n\tsrcAspectRatio := float64(srcW) / float64(srcH)\n\tmaxAspectRatio := float64(maxW) / float64(maxH)\n\n\tvar newW, newH int\n\tif srcAspectRatio > maxAspectRatio {\n\t\tnewW = maxW\n\t\tnewH = int(float64(newW) / srcAspectRatio)\n\t} else {\n\t\tnewH = maxH\n\t\tnewW = int(float64(newH) * srcAspectRatio)\n\t}\n\n\treturn Resize(img, newW, newH, filter)\n}\n\n// Fill creates an image with the specified dimensions and fills it with the scaled source image.\n// To achieve the correct aspect ratio without stretching, the source image will be cropped.\n//\n// Example:\n//\n//\tdstImage := imaging.Fill(srcImage, 800, 600, imaging.Center, imaging.Lanczos)\n//\nfunc Fill(img image.Image, width, height int, anchor Anchor, filter ResampleFilter) *image.NRGBA {\n\tdstW, dstH := width, height\n\n\tif dstW <= 0 || dstH <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tsrcBounds := img.Bounds()\n\tsrcW := srcBounds.Dx()\n\tsrcH := srcBounds.Dy()\n\n\tif srcW <= 0 || srcH <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tif srcW == dstW && srcH == dstH {\n\t\treturn Clone(img)\n\t}\n\n\tif srcW >= 100 && srcH >= 100 {\n\t\treturn cropAndResize(img, dstW, dstH, anchor, filter)\n\t}\n\treturn resizeAndCrop(img, dstW, dstH, anchor, filter)\n}\n\n// cropAndResize crops the image to the smallest possible size that has the required aspect ratio using\n// the given anchor point, then scales it to the specified dimensions and returns the transformed image.\n//\n// This is generally faster than resizing first, but may result in inaccuracies when used on small source images.\nfunc cropAndResize(img image.Image, width, height int, anchor Anchor, filter ResampleFilter) *image.NRGBA {\n\tdstW, dstH := width, height\n\n\tsrcBounds := img.Bounds()\n\tsrcW := srcBounds.Dx()\n\tsrcH := srcBounds.Dy()\n\tsrcAspectRatio := float64(srcW) / float64(srcH)\n\tdstAspectRatio := float64(dstW) / float64(dstH)\n\n\tvar tmp *image.NRGBA\n\tif srcAspectRatio < dstAspectRatio {\n\t\tcropH := float64(srcW) * float64(dstH) / float64(dstW)\n\t\ttmp = CropAnchor(img, srcW, int(math.Max(1, cropH)+0.5), anchor)\n\t} else {\n\t\tcropW := float64(srcH) * float64(dstW) / float64(dstH)\n\t\ttmp = CropAnchor(img, int(math.Max(1, cropW)+0.5), srcH, anchor)\n\t}\n\n\treturn Resize(tmp, dstW, dstH, filter)\n}\n\n// resizeAndCrop resizes the image to the smallest possible size that will cover the specified dimensions,\n// crops the resized image to the specified dimensions using the given anchor point and returns\n// the transformed image.\nfunc resizeAndCrop(img image.Image, width, height int, anchor Anchor, filter ResampleFilter) *image.NRGBA {\n\tdstW, dstH := width, height\n\n\tsrcBounds := img.Bounds()\n\tsrcW := srcBounds.Dx()\n\tsrcH := srcBounds.Dy()\n\tsrcAspectRatio := float64(srcW) / float64(srcH)\n\tdstAspectRatio := float64(dstW) / float64(dstH)\n\n\tvar tmp *image.NRGBA\n\tif srcAspectRatio < dstAspectRatio {\n\t\ttmp = Resize(img, dstW, 0, filter)\n\t} else {\n\t\ttmp = Resize(img, 0, dstH, filter)\n\t}\n\n\treturn CropAnchor(tmp, dstW, dstH, anchor)\n}\n\n// Thumbnail scales the image up or down using the specified resample filter, crops it\n// to the specified width and hight and returns the transformed image.\n//\n// Example:\n//\n//\tdstImage := imaging.Thumbnail(srcImage, 100, 100, imaging.Lanczos)\n//\nfunc Thumbnail(img image.Image, width, height int, filter ResampleFilter) *image.NRGBA {\n\treturn Fill(img, width, height, Center, filter)\n}\n\n// ResampleFilter specifies a resampling filter to be used for image resizing.\n//\n//\tGeneral filter recommendations:\n//\n//\t- Lanczos\n//\t\tA high-quality resampling filter for photographic images yielding sharp results.\n//\n//\t- CatmullRom\n//\t\tA sharp cubic filter that is faster than Lanczos filter while providing similar results.\n//\n//\t- MitchellNetravali\n//\t\tA cubic filter that produces smoother results with less ringing artifacts than CatmullRom.\n//\n//\t- Linear\n//\t\tBilinear resampling filter, produces a smooth output. Faster than cubic filters.\n//\n//\t- Box\n//\t\tSimple and fast averaging filter appropriate for downscaling.\n//\t\tWhen upscaling it's similar to NearestNeighbor.\n//\n//\t- NearestNeighbor\n//\t\tFastest resampling filter, no antialiasing.\n//\ntype ResampleFilter struct {\n\tSupport float64\n\tKernel  func(float64) float64\n}\n\n// NearestNeighbor is a nearest-neighbor filter (no anti-aliasing).\nvar NearestNeighbor ResampleFilter\n\n// Box filter (averaging pixels).\nvar Box ResampleFilter\n\n// Linear filter.\nvar Linear ResampleFilter\n\n// Hermite cubic spline filter (BC-spline; B=0; C=0).\nvar Hermite ResampleFilter\n\n// MitchellNetravali is Mitchell-Netravali cubic filter (BC-spline; B=1/3; C=1/3).\nvar MitchellNetravali ResampleFilter\n\n// CatmullRom is a Catmull-Rom - sharp cubic filter (BC-spline; B=0; C=0.5).\nvar CatmullRom ResampleFilter\n\n// BSpline is a smooth cubic filter (BC-spline; B=1; C=0).\nvar BSpline ResampleFilter\n\n// Gaussian is a Gaussian blurring filter.\nvar Gaussian ResampleFilter\n\n// Bartlett is a Bartlett-windowed sinc filter (3 lobes).\nvar Bartlett ResampleFilter\n\n// Lanczos filter (3 lobes).\nvar Lanczos ResampleFilter\n\n// Hann is a Hann-windowed sinc filter (3 lobes).\nvar Hann ResampleFilter\n\n// Hamming is a Hamming-windowed sinc filter (3 lobes).\nvar Hamming ResampleFilter\n\n// Blackman is a Blackman-windowed sinc filter (3 lobes).\nvar Blackman ResampleFilter\n\n// Welch is a Welch-windowed sinc filter (parabolic window, 3 lobes).\nvar Welch ResampleFilter\n\n// Cosine is a Cosine-windowed sinc filter (3 lobes).\nvar Cosine ResampleFilter\n\nfunc bcspline(x, b, c float64) float64 {\n\tvar y float64\n\tx = math.Abs(x)\n\tif x < 1.0 {\n\t\ty = ((12-9*b-6*c)*x*x*x + (-18+12*b+6*c)*x*x + (6 - 2*b)) / 6\n\t} else if x < 2.0 {\n\t\ty = ((-b-6*c)*x*x*x + (6*b+30*c)*x*x + (-12*b-48*c)*x + (8*b + 24*c)) / 6\n\t}\n\treturn y\n}\n\nfunc sinc(x float64) float64 {\n\tif x == 0 {\n\t\treturn 1\n\t}\n\treturn math.Sin(math.Pi*x) / (math.Pi * x)\n}\n\nfunc init() {\n\tNearestNeighbor = ResampleFilter{\n\t\tSupport: 0.0, // special case - not applying the filter\n\t}\n\n\tBox = ResampleFilter{\n\t\tSupport: 0.5,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x <= 0.5 {\n\t\t\t\treturn 1.0\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tLinear = ResampleFilter{\n\t\tSupport: 1.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 1.0 {\n\t\t\t\treturn 1.0 - x\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tHermite = ResampleFilter{\n\t\tSupport: 1.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 1.0 {\n\t\t\t\treturn bcspline(x, 0.0, 0.0)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tMitchellNetravali = ResampleFilter{\n\t\tSupport: 2.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 2.0 {\n\t\t\t\treturn bcspline(x, 1.0/3.0, 1.0/3.0)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tCatmullRom = ResampleFilter{\n\t\tSupport: 2.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 2.0 {\n\t\t\t\treturn bcspline(x, 0.0, 0.5)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tBSpline = ResampleFilter{\n\t\tSupport: 2.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 2.0 {\n\t\t\t\treturn bcspline(x, 1.0, 0.0)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tGaussian = ResampleFilter{\n\t\tSupport: 2.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 2.0 {\n\t\t\t\treturn math.Exp(-2 * x * x)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tBartlett = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * (3.0 - x) / 3.0\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tLanczos = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * sinc(x/3.0)\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tHann = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * (0.5 + 0.5*math.Cos(math.Pi*x/3.0))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tHamming = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * (0.54 + 0.46*math.Cos(math.Pi*x/3.0))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tBlackman = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * (0.42 - 0.5*math.Cos(math.Pi*x/3.0+math.Pi) + 0.08*math.Cos(2.0*math.Pi*x/3.0))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tWelch = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * (1.0 - (x * x / 9.0))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n\n\tCosine = ResampleFilter{\n\t\tSupport: 3.0,\n\t\tKernel: func(x float64) float64 {\n\t\t\tx = math.Abs(x)\n\t\t\tif x < 3.0 {\n\t\t\t\treturn sinc(x) * math.Cos((math.Pi/2.0)*(x/3.0))\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "resize_test.go",
          "type": "blob",
          "size": 25.6513671875,
          "content": "package imaging\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestResize(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Resize 2x2 1x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x55, 0x55, 0x55, 0xc0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 1x2 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 2,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0x80,\n\t\t\t\t\t0x00, 0x80, 0x80, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 2x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0x80, 0x80, 0x00, 0x80, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 2x2 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 3x1 1x1 nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 0),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0xff, 0x00, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 0x4 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 4,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 4x0 linear\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4, 0,\n\t\t\tLinear,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x40, 0xff, 0x00, 0x00, 0xbf, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0x40, 0x6e, 0x6d, 0x25, 0x70, 0xb0, 0x14, 0x3b, 0xcf, 0xbf, 0x00, 0x40, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xbf, 0x14, 0xb0, 0x3b, 0xcf, 0x33, 0x33, 0x99, 0xef, 0x40, 0x00, 0xbf, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xbf, 0x40, 0xff, 0x00, 0x40, 0xbf, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Resize 0x0 1x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, -1, -1),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 0x0 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 0,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Resize 2x2 -1x0 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-1, 0,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Resize(tc.src, tc.w, tc.h, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResampleFilters(t *testing.T) {\n\tfor _, filter := range []ResampleFilter{\n\t\tNearestNeighbor,\n\t\tBox,\n\t\tLinear,\n\t\tHermite,\n\t\tMitchellNetravali,\n\t\tCatmullRom,\n\t\tBSpline,\n\t\tGaussian,\n\t\tLanczos,\n\t\tHann,\n\t\tHamming,\n\t\tBlackman,\n\t\tBartlett,\n\t\tWelch,\n\t\tCosine,\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tsrc := image.NewNRGBA(image.Rect(-1, -1, 2, 3))\n\t\t\tgot := Resize(src, 5, 6, filter)\n\t\t\twant := image.NewNRGBA(image.Rect(0, 0, 5, 6))\n\t\t\tif !compareNRGBA(got, want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, want)\n\t\t\t}\n\t\t\tif filter.Kernel != nil {\n\t\t\t\tif x := filter.Kernel(filter.Support + 0.0001); x != 0 {\n\t\t\t\t\tt.Fatalf(\"got kernel value %f want 0\", x)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResizeGolden(t *testing.T) {\n\tfor name, filter := range map[string]ResampleFilter{\n\t\t\"out_resize_nearest.png\": NearestNeighbor,\n\t\t\"out_resize_linear.png\":  Linear,\n\t\t\"out_resize_catrom.png\":  CatmullRom,\n\t\t\"out_resize_lanczos.png\": Lanczos,\n\t} {\n\t\tgot := Resize(testdataBranchesPNG, 150, 0, filter)\n\t\twant, err := Open(\"testdata/\" + name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc TestFit(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Fit 2x2 1x10 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 10,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x55, 0x55, 0x55, 0xc0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Fit 2x2 10x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x55, 0x55, 0x55, 0xc0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Fit 2x2 10x10 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t10, 10,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Fit 0x0 1x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, -1, -1),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Fit 2x2 0x0 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 0,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Fit 2x2 -1x0 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-1, 0,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Fit(tc.src, tc.w, tc.h, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFitGolden(t *testing.T) {\n\tgot := Fit(testdataBranchesPNG, 150, 150, Box)\n\tname := filepath.Join(\"testdata\", \"out_fit.png\")\n\twant, err := Open(name)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t}\n\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t}\n}\n\nfunc TestFill(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\ta    Anchor\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Fill 4x4 4x4 TopRight Box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4, 4,\n\t\t\tTopRight,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Fill 4x4 0x4 Left Box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 4,\n\t\t\tLeft,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Fill 0x0 4x4 Right Box\",\n\t\t\t&image.NRGBA{},\n\t\t\t4, 4,\n\t\t\tRight,\n\t\t\tBox,\n\t\t\t&image.NRGBA{},\n\t\t},\n\t\t{\n\t\t\t\"Fill 100x200 20x10 Center Linear\",\n\t\t\timage.NewRGBA(image.Rect(0, 0, 100, 200)),\n\t\t\t20, 10,\n\t\t\tCenter,\n\t\t\tLinear,\n\t\t\timage.NewNRGBA(image.Rect(0, 0, 20, 10)),\n\t\t},\n\t\t{\n\t\t\t\"Fill 10x20 20x10 Center Linear\",\n\t\t\timage.NewRGBA(image.Rect(0, 0, 10, 20)),\n\t\t\t20, 10,\n\t\t\tCenter,\n\t\t\tLinear,\n\t\t\timage.NewNRGBA(image.Rect(0, 0, 20, 10)),\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Fill(tc.src, tc.w, tc.h, tc.a, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFillGolden(t *testing.T) {\n\tanchorPoints := map[string]Anchor{\n\t\t\"left\":   Left,\n\t\t\"center\": Center,\n\t\t\"right\":  Right,\n\t}\n\tfor apName, ap := range anchorPoints {\n\t\tgot := Fill(testdataBranchesPNG, 150, 150, ap, Box)\n\t\tname := filepath.Join(\"testdata\", \"out_fill_\"+apName+\".png\")\n\t\twant, err := Open(name)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to open image: %v\", err)\n\t\t}\n\t\tif !compareNRGBAGolden(got, toNRGBA(want)) {\n\t\t\tt.Fatalf(\"resulting image differs from golden: %s\", name)\n\t\t}\n\t}\n}\n\nfunc TestResizeAndCrop(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\ta    Anchor\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"resizeAndCrop 4x4 2x2 Center Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tCenter,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"resizeAndCrop 4x4 1x4 TopLeft Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 4,\n\t\t\tTopLeft,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 4),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"resizeAndCrop 4x4 8x2 Bottom Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t8, 2,\n\t\t\tBottom,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 8, 2),\n\t\t\t\tStride: 8 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"resizeAndCrop 4x4 2x8 Top Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 8,\n\t\t\tTop,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 8),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n\t\t\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"resizeAndCrop 4x4 4x4 TopRight Box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4, 4,\n\t\t\tTopRight,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := resizeAndCrop(tc.src, tc.w, tc.h, tc.a, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCropAndResize(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\ta    Anchor\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"cropAndResize 4x4 2x2 Center Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tCenter,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"cropAndResize 4x4 1x4 TopLeft Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 4,\n\t\t\tTopLeft,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 4),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"cropAndResize 4x4 8x2 Bottom Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t8, 2,\n\t\t\tBottom,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 8, 2),\n\t\t\t\tStride: 8 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"cropAndResize 4x4 2x8 Top Nearest\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 8,\n\t\t\tTop,\n\t\t\tNearestNeighbor,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 8),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x04, 0x05, 0x06, 0x07, 0x04, 0x05, 0x06, 0x07,\n\t\t\t\t\t0x04, 0x05, 0x06, 0x07, 0x04, 0x05, 0x06, 0x07,\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x14, 0x15, 0x16, 0x17,\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x14, 0x15, 0x16, 0x17,\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x24, 0x25, 0x26, 0x27,\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x24, 0x25, 0x26, 0x27,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x34, 0x35, 0x36, 0x37,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"cropAndResize 4x4 4x4 TopRight Box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4, 4,\n\t\t\tTopRight,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := cropAndResize(tc.src, tc.w, tc.h, tc.a, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestThumbnail(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\tf    ResampleFilter\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Thumbnail 6x2 1x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 5, 1),\n\t\t\t\tStride: 6 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x55, 0x55, 0x55, 0xc0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Thumbnail 2x6 1x1 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 5),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 1,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x55, 0x55, 0x55, 0xc0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Thumbnail 1x3 2x2 box\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tBox,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Thumbnail(tc.src, tc.w, tc.h, tc.f)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkResize(b *testing.B) {\n\tfor _, dir := range []string{\"Down\", \"Up\"} {\n\t\tfor _, filter := range []string{\"NearestNeighbor\", \"Linear\", \"CatmullRom\", \"Lanczos\"} {\n\t\t\tfor _, format := range []string{\"JPEG\", \"PNG\"} {\n\t\t\t\tvar size int\n\t\t\t\tswitch dir {\n\t\t\t\tcase \"Down\":\n\t\t\t\t\tsize = 100\n\t\t\t\tcase \"Up\":\n\t\t\t\t\tsize = 1000\n\t\t\t\t}\n\n\t\t\t\tvar f ResampleFilter\n\t\t\t\tswitch filter {\n\t\t\t\tcase \"NearestNeighbor\":\n\t\t\t\t\tf = NearestNeighbor\n\t\t\t\tcase \"Linear\":\n\t\t\t\t\tf = Linear\n\t\t\t\tcase \"CatmullRom\":\n\t\t\t\t\tf = CatmullRom\n\t\t\t\tcase \"Lanczos\":\n\t\t\t\t\tf = Lanczos\n\t\t\t\t}\n\n\t\t\t\tvar img image.Image\n\t\t\t\tswitch format {\n\t\t\t\tcase \"JPEG\":\n\t\t\t\t\timg = testdataBranchesJPG\n\t\t\t\tcase \"PNG\":\n\t\t\t\t\timg = testdataBranchesPNG\n\t\t\t\t}\n\n\t\t\t\tb.Run(fmt.Sprintf(\"%s %s %s\", dir, filter, format), func(b *testing.B) {\n\t\t\t\t\tb.ReportAllocs()\n\t\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\t\tResize(img, size, size, f)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkFill(b *testing.B) {\n\tfor _, dir := range []string{\"Vertical\", \"Horizontal\"} {\n\t\tfor _, filter := range []string{\"NearestNeighbor\", \"Linear\", \"CatmullRom\", \"Lanczos\"} {\n\t\t\tfor _, format := range []string{\"JPEG\", \"PNG\"} {\n\t\t\t\tvar width, height int\n\t\t\t\tswitch dir {\n\t\t\t\tcase \"Vertical\":\n\t\t\t\t\twidth = 100\n\t\t\t\t\theight = 1000\n\t\t\t\tcase \"Horizontal\":\n\t\t\t\t\twidth = 1000\n\t\t\t\t\theight = 100\n\t\t\t\t}\n\n\t\t\t\tvar f ResampleFilter\n\t\t\t\tswitch filter {\n\t\t\t\tcase \"NearestNeighbor\":\n\t\t\t\t\tf = NearestNeighbor\n\t\t\t\tcase \"Linear\":\n\t\t\t\t\tf = Linear\n\t\t\t\tcase \"CatmullRom\":\n\t\t\t\t\tf = CatmullRom\n\t\t\t\tcase \"Lanczos\":\n\t\t\t\t\tf = Lanczos\n\t\t\t\t}\n\n\t\t\t\tvar img image.Image\n\t\t\t\tswitch format {\n\t\t\t\tcase \"JPEG\":\n\t\t\t\t\timg = testdataBranchesJPG\n\t\t\t\tcase \"PNG\":\n\t\t\t\t\timg = testdataBranchesPNG\n\t\t\t\t}\n\n\t\t\t\tb.Run(fmt.Sprintf(\"%s %s %s\", dir, filter, format), func(b *testing.B) {\n\t\t\t\t\tb.ReportAllocs()\n\t\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\t\tFill(img, width, height, Center, f)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 5.47265625,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"image/color\"\n)\n\ntype scanner struct {\n\timage   image.Image\n\tw, h    int\n\tpalette []color.NRGBA\n}\n\nfunc newScanner(img image.Image) *scanner {\n\ts := &scanner{\n\t\timage: img,\n\t\tw:     img.Bounds().Dx(),\n\t\th:     img.Bounds().Dy(),\n\t}\n\tif img, ok := img.(*image.Paletted); ok {\n\t\ts.palette = make([]color.NRGBA, len(img.Palette))\n\t\tfor i := 0; i < len(img.Palette); i++ {\n\t\t\ts.palette[i] = color.NRGBAModel.Convert(img.Palette[i]).(color.NRGBA)\n\t\t}\n\t}\n\treturn s\n}\n\n// scan scans the given rectangular region of the image into dst.\nfunc (s *scanner) scan(x1, y1, x2, y2 int, dst []uint8) {\n\tswitch img := s.image.(type) {\n\tcase *image.NRGBA:\n\t\tsize := (x2 - x1) * 4\n\t\tj := 0\n\t\ti := y1*img.Stride + x1*4\n\t\tif size == 4 {\n\t\t\tfor y := y1; y < y2; y++ {\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\ts := img.Pix[i : i+4 : i+4]\n\t\t\t\td[0] = s[0]\n\t\t\t\td[1] = s[1]\n\t\t\t\td[2] = s[2]\n\t\t\t\td[3] = s[3]\n\t\t\t\tj += size\n\t\t\t\ti += img.Stride\n\t\t\t}\n\t\t} else {\n\t\t\tfor y := y1; y < y2; y++ {\n\t\t\t\tcopy(dst[j:j+size], img.Pix[i:i+size])\n\t\t\t\tj += size\n\t\t\t\ti += img.Stride\n\t\t\t}\n\t\t}\n\n\tcase *image.NRGBA64:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1*8\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\ts := img.Pix[i : i+8 : i+8]\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\td[0] = s[0]\n\t\t\t\td[1] = s[2]\n\t\t\t\td[2] = s[4]\n\t\t\t\td[3] = s[6]\n\t\t\t\tj += 4\n\t\t\t\ti += 8\n\t\t\t}\n\t\t}\n\n\tcase *image.RGBA:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1*4\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\ta := img.Pix[i+3]\n\t\t\t\tswitch a {\n\t\t\t\tcase 0:\n\t\t\t\t\td[0] = 0\n\t\t\t\t\td[1] = 0\n\t\t\t\t\td[2] = 0\n\t\t\t\t\td[3] = a\n\t\t\t\tcase 0xff:\n\t\t\t\t\ts := img.Pix[i : i+4 : i+4]\n\t\t\t\t\td[0] = s[0]\n\t\t\t\t\td[1] = s[1]\n\t\t\t\t\td[2] = s[2]\n\t\t\t\t\td[3] = a\n\t\t\t\tdefault:\n\t\t\t\t\ts := img.Pix[i : i+4 : i+4]\n\t\t\t\t\tr16 := uint16(s[0])\n\t\t\t\t\tg16 := uint16(s[1])\n\t\t\t\t\tb16 := uint16(s[2])\n\t\t\t\t\ta16 := uint16(a)\n\t\t\t\t\td[0] = uint8(r16 * 0xff / a16)\n\t\t\t\t\td[1] = uint8(g16 * 0xff / a16)\n\t\t\t\t\td[2] = uint8(b16 * 0xff / a16)\n\t\t\t\t\td[3] = a\n\t\t\t\t}\n\t\t\t\tj += 4\n\t\t\t\ti += 4\n\t\t\t}\n\t\t}\n\n\tcase *image.RGBA64:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1*8\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\ts := img.Pix[i : i+8 : i+8]\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\ta := s[6]\n\t\t\t\tswitch a {\n\t\t\t\tcase 0:\n\t\t\t\t\td[0] = 0\n\t\t\t\t\td[1] = 0\n\t\t\t\t\td[2] = 0\n\t\t\t\tcase 0xff:\n\t\t\t\t\td[0] = s[0]\n\t\t\t\t\td[1] = s[2]\n\t\t\t\t\td[2] = s[4]\n\t\t\t\tdefault:\n\t\t\t\t\tr32 := uint32(s[0])<<8 | uint32(s[1])\n\t\t\t\t\tg32 := uint32(s[2])<<8 | uint32(s[3])\n\t\t\t\t\tb32 := uint32(s[4])<<8 | uint32(s[5])\n\t\t\t\t\ta32 := uint32(s[6])<<8 | uint32(s[7])\n\t\t\t\t\td[0] = uint8((r32 * 0xffff / a32) >> 8)\n\t\t\t\t\td[1] = uint8((g32 * 0xffff / a32) >> 8)\n\t\t\t\t\td[2] = uint8((b32 * 0xffff / a32) >> 8)\n\t\t\t\t}\n\t\t\t\td[3] = a\n\t\t\t\tj += 4\n\t\t\t\ti += 8\n\t\t\t}\n\t\t}\n\n\tcase *image.Gray:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\tc := img.Pix[i]\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\td[0] = c\n\t\t\t\td[1] = c\n\t\t\t\td[2] = c\n\t\t\t\td[3] = 0xff\n\t\t\t\tj += 4\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\tcase *image.Gray16:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1*2\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\tc := img.Pix[i]\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\td[0] = c\n\t\t\t\td[1] = c\n\t\t\t\td[2] = c\n\t\t\t\td[3] = 0xff\n\t\t\t\tj += 4\n\t\t\t\ti += 2\n\t\t\t}\n\t\t}\n\n\tcase *image.YCbCr:\n\t\tj := 0\n\t\tx1 += img.Rect.Min.X\n\t\tx2 += img.Rect.Min.X\n\t\ty1 += img.Rect.Min.Y\n\t\ty2 += img.Rect.Min.Y\n\n\t\thy := img.Rect.Min.Y / 2\n\t\thx := img.Rect.Min.X / 2\n\t\tfor y := y1; y < y2; y++ {\n\t\t\tiy := (y-img.Rect.Min.Y)*img.YStride + (x1 - img.Rect.Min.X)\n\n\t\t\tvar yBase int\n\t\t\tswitch img.SubsampleRatio {\n\t\t\tcase image.YCbCrSubsampleRatio444, image.YCbCrSubsampleRatio422:\n\t\t\t\tyBase = (y - img.Rect.Min.Y) * img.CStride\n\t\t\tcase image.YCbCrSubsampleRatio420, image.YCbCrSubsampleRatio440:\n\t\t\t\tyBase = (y/2 - hy) * img.CStride\n\t\t\t}\n\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\tvar ic int\n\t\t\t\tswitch img.SubsampleRatio {\n\t\t\t\tcase image.YCbCrSubsampleRatio444, image.YCbCrSubsampleRatio440:\n\t\t\t\t\tic = yBase + (x - img.Rect.Min.X)\n\t\t\t\tcase image.YCbCrSubsampleRatio422, image.YCbCrSubsampleRatio420:\n\t\t\t\t\tic = yBase + (x/2 - hx)\n\t\t\t\tdefault:\n\t\t\t\t\tic = img.COffset(x, y)\n\t\t\t\t}\n\n\t\t\t\tyy1 := int32(img.Y[iy]) * 0x10101\n\t\t\t\tcb1 := int32(img.Cb[ic]) - 128\n\t\t\t\tcr1 := int32(img.Cr[ic]) - 128\n\n\t\t\t\tr := yy1 + 91881*cr1\n\t\t\t\tif uint32(r)&0xff000000 == 0 {\n\t\t\t\t\tr >>= 16\n\t\t\t\t} else {\n\t\t\t\t\tr = ^(r >> 31)\n\t\t\t\t}\n\n\t\t\t\tg := yy1 - 22554*cb1 - 46802*cr1\n\t\t\t\tif uint32(g)&0xff000000 == 0 {\n\t\t\t\t\tg >>= 16\n\t\t\t\t} else {\n\t\t\t\t\tg = ^(g >> 31)\n\t\t\t\t}\n\n\t\t\t\tb := yy1 + 116130*cb1\n\t\t\t\tif uint32(b)&0xff000000 == 0 {\n\t\t\t\t\tb >>= 16\n\t\t\t\t} else {\n\t\t\t\t\tb = ^(b >> 31)\n\t\t\t\t}\n\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\td[0] = uint8(r)\n\t\t\t\td[1] = uint8(g)\n\t\t\t\td[2] = uint8(b)\n\t\t\t\td[3] = 0xff\n\n\t\t\t\tiy++\n\t\t\t\tj += 4\n\t\t\t}\n\t\t}\n\n\tcase *image.Paletted:\n\t\tj := 0\n\t\tfor y := y1; y < y2; y++ {\n\t\t\ti := y*img.Stride + x1\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\tc := s.palette[img.Pix[i]]\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\td[0] = c.R\n\t\t\t\td[1] = c.G\n\t\t\t\td[2] = c.B\n\t\t\t\td[3] = c.A\n\t\t\t\tj += 4\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tj := 0\n\t\tb := s.image.Bounds()\n\t\tx1 += b.Min.X\n\t\tx2 += b.Min.X\n\t\ty1 += b.Min.Y\n\t\ty2 += b.Min.Y\n\t\tfor y := y1; y < y2; y++ {\n\t\t\tfor x := x1; x < x2; x++ {\n\t\t\t\tr16, g16, b16, a16 := s.image.At(x, y).RGBA()\n\t\t\t\td := dst[j : j+4 : j+4]\n\t\t\t\tswitch a16 {\n\t\t\t\tcase 0xffff:\n\t\t\t\t\td[0] = uint8(r16 >> 8)\n\t\t\t\t\td[1] = uint8(g16 >> 8)\n\t\t\t\t\td[2] = uint8(b16 >> 8)\n\t\t\t\t\td[3] = 0xff\n\t\t\t\tcase 0:\n\t\t\t\t\td[0] = 0\n\t\t\t\t\td[1] = 0\n\t\t\t\t\td[2] = 0\n\t\t\t\t\td[3] = 0\n\t\t\t\tdefault:\n\t\t\t\t\td[0] = uint8(((r16 * 0xffff) / a16) >> 8)\n\t\t\t\t\td[1] = uint8(((g16 * 0xffff) / a16) >> 8)\n\t\t\t\t\td[2] = uint8(((b16 * 0xffff) / a16) >> 8)\n\t\t\t\t\td[3] = uint8(a16 >> 8)\n\t\t\t\t}\n\t\t\t\tj += 4\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 5.2568359375,
          "content": "package imaging\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/color/palette\"\n\t\"image/draw\"\n\t\"testing\"\n)\n\nfunc TestScanner(t *testing.T) {\n\trect := image.Rect(-1, -1, 15, 15)\n\tcolors := palette.Plan9\n\ttestCases := []struct {\n\t\tname string\n\t\timg  image.Image\n\t}{\n\t\t{\n\t\t\tname: \"NRGBA\",\n\t\t\timg:  makeNRGBAImage(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"NRGBA64\",\n\t\t\timg:  makeNRGBA64Image(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"RGBA\",\n\t\t\timg:  makeRGBAImage(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"RGBA64\",\n\t\t\timg:  makeRGBA64Image(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"Gray\",\n\t\t\timg:  makeGrayImage(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"Gray16\",\n\t\t\timg:  makeGray16Image(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-444\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio444),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-422\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio422),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-420\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio420),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-440\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio440),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-410\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio410),\n\t\t},\n\t\t{\n\t\t\tname: \"YCbCr-411\",\n\t\t\timg:  makeYCbCrImage(rect, colors, image.YCbCrSubsampleRatio411),\n\t\t},\n\t\t{\n\t\t\tname: \"Paletted\",\n\t\t\timg:  makePalettedImage(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"Alpha\",\n\t\t\timg:  makeAlphaImage(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"Alpha16\",\n\t\t\timg:  makeAlpha16Image(rect, colors),\n\t\t},\n\t\t{\n\t\t\tname: \"Generic\",\n\t\t\timg:  makeGenericImage(rect, colors),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := tc.img.Bounds()\n\t\t\ts := newScanner(tc.img)\n\t\t\tfor y := r.Min.Y; y < r.Max.Y; y++ {\n\t\t\t\tbuf := make([]byte, r.Dx()*4)\n\t\t\t\ts.scan(0, y-r.Min.Y, r.Dx(), y+1-r.Min.Y, buf)\n\t\t\t\twantBuf := readRow(tc.img, y)\n\t\t\t\tif !compareBytes(buf, wantBuf, 1) {\n\t\t\t\t\tfmt.Println(tc.img)\n\t\t\t\t\tt.Fatalf(\"scan horizontal line (y=%d): got %v want %v\", y, buf, wantBuf)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor x := r.Min.X; x < r.Max.X; x++ {\n\t\t\t\tbuf := make([]byte, r.Dy()*4)\n\t\t\t\ts.scan(x-r.Min.X, 0, x+1-r.Min.X, r.Dy(), buf)\n\t\t\t\twantBuf := readColumn(tc.img, x)\n\t\t\t\tif !compareBytes(buf, wantBuf, 1) {\n\t\t\t\t\tt.Fatalf(\"scan vertical line (x=%d): got %v want %v\", x, buf, wantBuf)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeYCbCrImage(rect image.Rectangle, colors []color.Color, sr image.YCbCrSubsampleRatio) *image.YCbCr {\n\timg := image.NewYCbCr(rect, sr)\n\tj := 0\n\tfor y := rect.Min.Y; y < rect.Max.Y; y++ {\n\t\tfor x := rect.Min.X; x < rect.Max.X; x++ {\n\t\t\tiy := img.YOffset(x, y)\n\t\t\tic := img.COffset(x, y)\n\t\t\tc := color.NRGBAModel.Convert(colors[j]).(color.NRGBA)\n\t\t\timg.Y[iy], img.Cb[ic], img.Cr[ic] = color.RGBToYCbCr(c.R, c.G, c.B)\n\t\t\tj++\n\t\t}\n\t}\n\treturn img\n}\n\nfunc makeNRGBAImage(rect image.Rectangle, colors []color.Color) *image.NRGBA {\n\timg := image.NewNRGBA(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeNRGBA64Image(rect image.Rectangle, colors []color.Color) *image.NRGBA64 {\n\timg := image.NewNRGBA64(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeRGBAImage(rect image.Rectangle, colors []color.Color) *image.RGBA {\n\timg := image.NewRGBA(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeRGBA64Image(rect image.Rectangle, colors []color.Color) *image.RGBA64 {\n\timg := image.NewRGBA64(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeGrayImage(rect image.Rectangle, colors []color.Color) *image.Gray {\n\timg := image.NewGray(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeGray16Image(rect image.Rectangle, colors []color.Color) *image.Gray16 {\n\timg := image.NewGray16(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makePalettedImage(rect image.Rectangle, colors []color.Color) *image.Paletted {\n\timg := image.NewPaletted(rect, colors)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeAlphaImage(rect image.Rectangle, colors []color.Color) *image.Alpha {\n\timg := image.NewAlpha(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeAlpha16Image(rect image.Rectangle, colors []color.Color) *image.Alpha16 {\n\timg := image.NewAlpha16(rect)\n\tfillDrawImage(img, colors)\n\treturn img\n}\n\nfunc makeGenericImage(rect image.Rectangle, colors []color.Color) image.Image {\n\timg := image.NewRGBA(rect)\n\tfillDrawImage(img, colors)\n\ttype genericImage struct{ *image.RGBA }\n\treturn &genericImage{img}\n}\n\nfunc fillDrawImage(img draw.Image, colors []color.Color) {\n\tcolorsNRGBA := make([]color.NRGBA, len(colors))\n\tfor i, c := range colors {\n\t\tnrgba := color.NRGBAModel.Convert(c).(color.NRGBA)\n\t\tnrgba.A = uint8(i % 256)\n\t\tcolorsNRGBA[i] = nrgba\n\t}\n\trect := img.Bounds()\n\ti := 0\n\tfor y := rect.Min.Y; y < rect.Max.Y; y++ {\n\t\tfor x := rect.Min.X; x < rect.Max.X; x++ {\n\t\t\timg.Set(x, y, colorsNRGBA[i])\n\t\t\ti++\n\t\t}\n\t}\n}\n\nfunc readRow(img image.Image, y int) []uint8 {\n\trow := make([]byte, img.Bounds().Dx()*4)\n\ti := 0\n\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\tc := color.NRGBAModel.Convert(img.At(x, y)).(color.NRGBA)\n\t\trow[i+0] = c.R\n\t\trow[i+1] = c.G\n\t\trow[i+2] = c.B\n\t\trow[i+3] = c.A\n\t\ti += 4\n\t}\n\treturn row\n}\n\nfunc readColumn(img image.Image, x int) []uint8 {\n\tcolumn := make([]byte, img.Bounds().Dy()*4)\n\ti := 0\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tc := color.NRGBAModel.Convert(img.At(x, y)).(color.NRGBA)\n\t\tcolumn[i+0] = c.R\n\t\tcolumn[i+1] = c.G\n\t\tcolumn[i+2] = c.B\n\t\tcolumn[i+3] = c.A\n\t\ti += 4\n\t}\n\treturn column\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools.go",
          "type": "blob",
          "size": 6.873046875,
          "content": "package imaging\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n)\n\n// New creates a new image with the specified width and height, and fills it with the specified color.\nfunc New(width, height int, fillColor color.Color) *image.NRGBA {\n\tif width <= 0 || height <= 0 {\n\t\treturn &image.NRGBA{}\n\t}\n\n\tc := color.NRGBAModel.Convert(fillColor).(color.NRGBA)\n\tif (c == color.NRGBA{0, 0, 0, 0}) {\n\t\treturn image.NewNRGBA(image.Rect(0, 0, width, height))\n\t}\n\n\treturn &image.NRGBA{\n\t\tPix:    bytes.Repeat([]byte{c.R, c.G, c.B, c.A}, width*height),\n\t\tStride: 4 * width,\n\t\tRect:   image.Rect(0, 0, width, height),\n\t}\n}\n\n// Clone returns a copy of the given image.\nfunc Clone(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, src.w, src.h))\n\tsize := src.w * 4\n\tparallel(0, src.h, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := y * dst.Stride\n\t\t\tsrc.scan(0, y, src.w, y+1, dst.Pix[i:i+size])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Anchor is the anchor point for image alignment.\ntype Anchor int\n\n// Anchor point positions.\nconst (\n\tCenter Anchor = iota\n\tTopLeft\n\tTop\n\tTopRight\n\tLeft\n\tRight\n\tBottomLeft\n\tBottom\n\tBottomRight\n)\n\nfunc anchorPt(b image.Rectangle, w, h int, anchor Anchor) image.Point {\n\tvar x, y int\n\tswitch anchor {\n\tcase TopLeft:\n\t\tx = b.Min.X\n\t\ty = b.Min.Y\n\tcase Top:\n\t\tx = b.Min.X + (b.Dx()-w)/2\n\t\ty = b.Min.Y\n\tcase TopRight:\n\t\tx = b.Max.X - w\n\t\ty = b.Min.Y\n\tcase Left:\n\t\tx = b.Min.X\n\t\ty = b.Min.Y + (b.Dy()-h)/2\n\tcase Right:\n\t\tx = b.Max.X - w\n\t\ty = b.Min.Y + (b.Dy()-h)/2\n\tcase BottomLeft:\n\t\tx = b.Min.X\n\t\ty = b.Max.Y - h\n\tcase Bottom:\n\t\tx = b.Min.X + (b.Dx()-w)/2\n\t\ty = b.Max.Y - h\n\tcase BottomRight:\n\t\tx = b.Max.X - w\n\t\ty = b.Max.Y - h\n\tdefault:\n\t\tx = b.Min.X + (b.Dx()-w)/2\n\t\ty = b.Min.Y + (b.Dy()-h)/2\n\t}\n\treturn image.Pt(x, y)\n}\n\n// Crop cuts out a rectangular region with the specified bounds\n// from the image and returns the cropped image.\nfunc Crop(img image.Image, rect image.Rectangle) *image.NRGBA {\n\tr := rect.Intersect(img.Bounds()).Sub(img.Bounds().Min)\n\tif r.Empty() {\n\t\treturn &image.NRGBA{}\n\t}\n\tif r.Eq(img.Bounds().Sub(img.Bounds().Min)) {\n\t\treturn Clone(img)\n\t}\n\n\tsrc := newScanner(img)\n\tdst := image.NewNRGBA(image.Rect(0, 0, r.Dx(), r.Dy()))\n\trowSize := r.Dx() * 4\n\tparallel(r.Min.Y, r.Max.Y, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\ti := (y - r.Min.Y) * dst.Stride\n\t\t\tsrc.scan(r.Min.X, y, r.Max.X, y+1, dst.Pix[i:i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// CropAnchor cuts out a rectangular region with the specified size\n// from the image using the specified anchor point and returns the cropped image.\nfunc CropAnchor(img image.Image, width, height int, anchor Anchor) *image.NRGBA {\n\tsrcBounds := img.Bounds()\n\tpt := anchorPt(srcBounds, width, height, anchor)\n\tr := image.Rect(0, 0, width, height).Add(pt)\n\tb := srcBounds.Intersect(r)\n\treturn Crop(img, b)\n}\n\n// CropCenter cuts out a rectangular region with the specified size\n// from the center of the image and returns the cropped image.\nfunc CropCenter(img image.Image, width, height int) *image.NRGBA {\n\treturn CropAnchor(img, width, height, Center)\n}\n\n// Paste pastes the img image to the background image at the specified position and returns the combined image.\nfunc Paste(background, img image.Image, pos image.Point) *image.NRGBA {\n\tdst := Clone(background)\n\tpos = pos.Sub(background.Bounds().Min)\n\tpasteRect := image.Rectangle{Min: pos, Max: pos.Add(img.Bounds().Size())}\n\tinterRect := pasteRect.Intersect(dst.Bounds())\n\tif interRect.Empty() {\n\t\treturn dst\n\t}\n\tif interRect.Eq(dst.Bounds()) {\n\t\treturn Clone(img)\n\t}\n\n\tsrc := newScanner(img)\n\tparallel(interRect.Min.Y, interRect.Max.Y, func(ys <-chan int) {\n\t\tfor y := range ys {\n\t\t\tx1 := interRect.Min.X - pasteRect.Min.X\n\t\t\tx2 := interRect.Max.X - pasteRect.Min.X\n\t\t\ty1 := y - pasteRect.Min.Y\n\t\t\ty2 := y1 + 1\n\t\t\ti1 := y*dst.Stride + interRect.Min.X*4\n\t\t\ti2 := i1 + interRect.Dx()*4\n\t\t\tsrc.scan(x1, y1, x2, y2, dst.Pix[i1:i2])\n\t\t}\n\t})\n\treturn dst\n}\n\n// PasteCenter pastes the img image to the center of the background image and returns the combined image.\nfunc PasteCenter(background, img image.Image) *image.NRGBA {\n\tbgBounds := background.Bounds()\n\tbgW := bgBounds.Dx()\n\tbgH := bgBounds.Dy()\n\tbgMinX := bgBounds.Min.X\n\tbgMinY := bgBounds.Min.Y\n\n\tcenterX := bgMinX + bgW/2\n\tcenterY := bgMinY + bgH/2\n\n\tx0 := centerX - img.Bounds().Dx()/2\n\ty0 := centerY - img.Bounds().Dy()/2\n\n\treturn Paste(background, img, image.Pt(x0, y0))\n}\n\n// Overlay draws the img image over the background image at given position\n// and returns the combined image. Opacity parameter is the opacity of the img\n// image layer, used to compose the images, it must be from 0.0 to 1.0.\n//\n// Examples:\n//\n//\t// Draw spriteImage over backgroundImage at the given position (x=50, y=50).\n//\tdstImage := imaging.Overlay(backgroundImage, spriteImage, image.Pt(50, 50), 1.0)\n//\n//\t// Blend two opaque images of the same size.\n//\tdstImage := imaging.Overlay(imageOne, imageTwo, image.Pt(0, 0), 0.5)\n//\nfunc Overlay(background, img image.Image, pos image.Point, opacity float64) *image.NRGBA {\n\topacity = math.Min(math.Max(opacity, 0.0), 1.0) // Ensure 0.0 <= opacity <= 1.0.\n\tdst := Clone(background)\n\tpos = pos.Sub(background.Bounds().Min)\n\tpasteRect := image.Rectangle{Min: pos, Max: pos.Add(img.Bounds().Size())}\n\tinterRect := pasteRect.Intersect(dst.Bounds())\n\tif interRect.Empty() {\n\t\treturn dst\n\t}\n\tsrc := newScanner(img)\n\tparallel(interRect.Min.Y, interRect.Max.Y, func(ys <-chan int) {\n\t\tscanLine := make([]uint8, interRect.Dx()*4)\n\t\tfor y := range ys {\n\t\t\tx1 := interRect.Min.X - pasteRect.Min.X\n\t\t\tx2 := interRect.Max.X - pasteRect.Min.X\n\t\t\ty1 := y - pasteRect.Min.Y\n\t\t\ty2 := y1 + 1\n\t\t\tsrc.scan(x1, y1, x2, y2, scanLine)\n\t\t\ti := y*dst.Stride + interRect.Min.X*4\n\t\t\tj := 0\n\t\t\tfor x := interRect.Min.X; x < interRect.Max.X; x++ {\n\t\t\t\td := dst.Pix[i : i+4 : i+4]\n\t\t\t\tr1 := float64(d[0])\n\t\t\t\tg1 := float64(d[1])\n\t\t\t\tb1 := float64(d[2])\n\t\t\t\ta1 := float64(d[3])\n\n\t\t\t\ts := scanLine[j : j+4 : j+4]\n\t\t\t\tr2 := float64(s[0])\n\t\t\t\tg2 := float64(s[1])\n\t\t\t\tb2 := float64(s[2])\n\t\t\t\ta2 := float64(s[3])\n\n\t\t\t\tcoef2 := opacity * a2 / 255\n\t\t\t\tcoef1 := (1 - coef2) * a1 / 255\n\t\t\t\tcoefSum := coef1 + coef2\n\t\t\t\tcoef1 /= coefSum\n\t\t\t\tcoef2 /= coefSum\n\n\t\t\t\td[0] = uint8(r1*coef1 + r2*coef2)\n\t\t\t\td[1] = uint8(g1*coef1 + g2*coef2)\n\t\t\t\td[2] = uint8(b1*coef1 + b2*coef2)\n\t\t\t\td[3] = uint8(math.Min(a1+a2*opacity*(255-a1)/255, 255))\n\n\t\t\t\ti += 4\n\t\t\t\tj += 4\n\t\t\t}\n\t\t}\n\t})\n\treturn dst\n}\n\n// OverlayCenter overlays the img image to the center of the background image and\n// returns the combined image. Opacity parameter is the opacity of the img\n// image layer, used to compose the images, it must be from 0.0 to 1.0.\nfunc OverlayCenter(background, img image.Image, opacity float64) *image.NRGBA {\n\tbgBounds := background.Bounds()\n\tbgW := bgBounds.Dx()\n\tbgH := bgBounds.Dy()\n\tbgMinX := bgBounds.Min.X\n\tbgMinY := bgBounds.Min.Y\n\n\tcenterX := bgMinX + bgW/2\n\tcenterY := bgMinY + bgH/2\n\n\tx0 := centerX - img.Bounds().Dx()/2\n\ty0 := centerY - img.Bounds().Dy()/2\n\n\treturn Overlay(background, img, image.Point{x0, y0}, opacity)\n}\n"
        },
        {
          "name": "tools_test.go",
          "type": "blob",
          "size": 34.19921875,
          "content": "package imaging\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"image/color\"\n\t\"testing\"\n)\n\nfunc TestNew(t *testing.T) {\n\ttestCases := []struct {\n\t\tname      string\n\t\tw, h      int\n\t\tc         color.Color\n\t\tdstBounds image.Rectangle\n\t\tdstPix    []uint8\n\t}{\n\t\t{\n\t\t\t\"New 1x1 transparent\",\n\t\t\t1, 1,\n\t\t\tcolor.Transparent,\n\t\t\timage.Rect(0, 0, 1, 1),\n\t\t\t[]uint8{0x00, 0x00, 0x00, 0x00},\n\t\t},\n\t\t{\n\t\t\t\"New 1x2 red\",\n\t\t\t1, 2,\n\t\t\tcolor.RGBA{255, 0, 0, 255},\n\t\t\timage.Rect(0, 0, 1, 2),\n\t\t\t[]uint8{0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff},\n\t\t},\n\t\t{\n\t\t\t\"New 2x1 white\",\n\t\t\t2, 1,\n\t\t\tcolor.White,\n\t\t\timage.Rect(0, 0, 2, 1),\n\t\t\t[]uint8{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t},\n\t\t{\n\t\t\t\"New 3x3 with alpha\",\n\t\t\t3, 3,\n\t\t\tcolor.NRGBA{0x01, 0x23, 0x45, 0x67},\n\t\t\timage.Rect(0, 0, 3, 3),\n\t\t\t[]uint8{\n\t\t\t\t0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67,\n\t\t\t\t0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67,\n\t\t\t\t0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67, 0x01, 0x23, 0x45, 0x67,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"New 0x0 white\",\n\t\t\t0, 0,\n\t\t\tcolor.White,\n\t\t\timage.Rect(0, 0, 0, 0),\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"New 800x600 custom\",\n\t\t\t800, 600,\n\t\t\tcolor.NRGBA{1, 2, 3, 4},\n\t\t\timage.Rect(0, 0, 800, 600),\n\t\t\tbytes.Repeat([]byte{1, 2, 3, 4}, 800*600),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := New(tc.w, tc.h, tc.c)\n\t\t\twant := image.NewNRGBA(tc.dstBounds)\n\t\t\twant.Pix = tc.dstPix\n\t\t\tif !compareNRGBA(got, want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tNew(1024, 1024, color.White)\n\t}\n}\n\nfunc TestClone(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Clone NRGBA\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone NRGBA64\",\n\t\t\t&image.NRGBA64{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 8,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33,\n\t\t\t\t\t0xcc, 0xcc, 0xdd, 0xdd, 0xee, 0xee, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone RGBA\",\n\t\t\t&image.RGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 3),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone RGBA64\",\n\t\t\t&image.RGBA64{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 2),\n\t\t\t\tStride: 1 * 8,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33,\n\t\t\t\t\t0xcc, 0xcc, 0xdd, 0xdd, 0xee, 0xee, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 3),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0x33, 0xcc, 0xdd, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone Gray\",\n\t\t\t&image.Gray{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 1,\n\t\t\t\tPix:    []uint8{0x11, 0xee},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x11, 0x11, 0x11, 0xff, 0xee, 0xee, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone Gray16\",\n\t\t\t&image.Gray16{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 2,\n\t\t\t\tPix:    []uint8{0x11, 0x11, 0xee, 0xee},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0x11, 0x11, 0x11, 0xff, 0xee, 0xee, 0xee, 0xff},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone Alpha\",\n\t\t\t&image.Alpha{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 1,\n\t\t\t\tPix:    []uint8{0x11, 0xee},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix:    []uint8{0xff, 0xff, 0xff, 0x11, 0xff, 0xff, 0xff, 0xee},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone YCbCr\",\n\t\t\t&image.YCbCr{\n\t\t\t\tRect:           image.Rect(-1, -1, 5, 0),\n\t\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio444,\n\t\t\t\tYStride:        6,\n\t\t\t\tCStride:        6,\n\t\t\t\tY:              []uint8{0x00, 0xff, 0x7f, 0x26, 0x4b, 0x0e},\n\t\t\t\tCb:             []uint8{0x80, 0x80, 0x80, 0x6b, 0x56, 0xc0},\n\t\t\t\tCr:             []uint8{0x80, 0x80, 0x80, 0xc0, 0x4b, 0x76},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 6, 1),\n\t\t\t\tStride: 6 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0x7f, 0x7f, 0x7f, 0xff,\n\t\t\t\t\t0x7f, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x7f, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x7f, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone YCbCr 444\",\n\t\t\t&image.YCbCr{\n\t\t\t\tY:              []uint8{0x4c, 0x69, 0x1d, 0xb1, 0x96, 0xe2, 0x26, 0x34, 0xe, 0x59, 0x4b, 0x71, 0x0, 0x4c, 0x99, 0xff},\n\t\t\t\tCb:             []uint8{0x55, 0xd4, 0xff, 0x8e, 0x2c, 0x01, 0x6b, 0xaa, 0xc0, 0x95, 0x56, 0x40, 0x80, 0x80, 0x80, 0x80},\n\t\t\t\tCr:             []uint8{0xff, 0xeb, 0x6b, 0x36, 0x15, 0x95, 0xc0, 0xb5, 0x76, 0x41, 0x4b, 0x8c, 0x80, 0x80, 0x80, 0x80},\n\t\t\t\tYStride:        4,\n\t\t\t\tCStride:        4,\n\t\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio444,\n\t\t\t\tRect:           image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tPix:    []uint8{0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x49, 0xe1, 0xca, 0xff, 0x0, 0xff, 0x0, 0xff, 0xff, 0xff, 0x0, 0xff, 0x7f, 0x0, 0x0, 0xff, 0x7f, 0x0, 0x7f, 0xff, 0x0, 0x0, 0x7f, 0xff, 0x0, 0x7f, 0x7f, 0xff, 0x0, 0x7f, 0x0, 0xff, 0x82, 0x7f, 0x0, 0xff, 0x0, 0x0, 0x0, 0xff, 0x4c, 0x4c, 0x4c, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t\t\tStride: 16,\n\t\t\t\tRect:   image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone YCbCr 440\",\n\t\t\t&image.YCbCr{\n\t\t\t\tY:              []uint8{0x4c, 0x69, 0x1d, 0xb1, 0x96, 0xe2, 0x26, 0x34, 0xe, 0x59, 0x4b, 0x71, 0x0, 0x4c, 0x99, 0xff},\n\t\t\t\tCb:             []uint8{0x2c, 0x01, 0x6b, 0xaa, 0x80, 0x80, 0x80, 0x80},\n\t\t\t\tCr:             []uint8{0x15, 0x95, 0xc0, 0xb5, 0x80, 0x80, 0x80, 0x80},\n\t\t\t\tYStride:        4,\n\t\t\t\tCStride:        4,\n\t\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio440,\n\t\t\t\tRect:           image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tPix:    []uint8{0x0, 0xb5, 0x0, 0xff, 0x86, 0x86, 0x0, 0xff, 0x77, 0x0, 0x0, 0xff, 0xfb, 0x7d, 0xfb, 0xff, 0x0, 0xff, 0x1, 0xff, 0xff, 0xff, 0x1, 0xff, 0x80, 0x0, 0x1, 0xff, 0x7e, 0x0, 0x7e, 0xff, 0xe, 0xe, 0xe, 0xff, 0x59, 0x59, 0x59, 0xff, 0x4b, 0x4b, 0x4b, 0xff, 0x71, 0x71, 0x71, 0xff, 0x0, 0x0, 0x0, 0xff, 0x4c, 0x4c, 0x4c, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t\t\tStride: 16,\n\t\t\t\tRect:   image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone YCbCr 422\",\n\t\t\t&image.YCbCr{\n\t\t\t\tY:              []uint8{0x4c, 0x69, 0x1d, 0xb1, 0x96, 0xe2, 0x26, 0x34, 0xe, 0x59, 0x4b, 0x71, 0x0, 0x4c, 0x99, 0xff},\n\t\t\t\tCb:             []uint8{0xd4, 0x8e, 0x01, 0xaa, 0x95, 0x40, 0x80, 0x80},\n\t\t\t\tCr:             []uint8{0xeb, 0x36, 0x95, 0xb5, 0x41, 0x8c, 0x80, 0x80},\n\t\t\t\tYStride:        4,\n\t\t\t\tCStride:        2,\n\t\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio422,\n\t\t\t\tRect:           image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tPix:    []uint8{0xe2, 0x0, 0xe1, 0xff, 0xff, 0x0, 0xfe, 0xff, 0x0, 0x4d, 0x36, 0xff, 0x49, 0xe1, 0xca, 0xff, 0xb3, 0xb3, 0x0, 0xff, 0xff, 0xff, 0x1, 0xff, 0x70, 0x0, 0x70, 0xff, 0x7e, 0x0, 0x7e, 0xff, 0x0, 0x34, 0x33, 0xff, 0x1, 0x7f, 0x7e, 0xff, 0x5c, 0x58, 0x0, 0xff, 0x82, 0x7e, 0x0, 0xff, 0x0, 0x0, 0x0, 0xff, 0x4c, 0x4c, 0x4c, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t\t\tStride: 16,\n\t\t\t\tRect:   image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone YCbCr 420\",\n\t\t\t&image.YCbCr{\n\t\t\t\tY:       []uint8{0x4c, 0x69, 0x1d, 0xb1, 0x96, 0xe2, 0x26, 0x34, 0xe, 0x59, 0x4b, 0x71, 0x0, 0x4c, 0x99, 0xff},\n\t\t\t\tCb:      []uint8{0x01, 0xaa, 0x80, 0x80},\n\t\t\t\tCr:      []uint8{0x95, 0xb5, 0x80, 0x80},\n\t\t\t\tYStride: 4, CStride: 2,\n\t\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio420,\n\t\t\t\tRect:           image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tPix:    []uint8{0x69, 0x69, 0x0, 0xff, 0x86, 0x86, 0x0, 0xff, 0x67, 0x0, 0x67, 0xff, 0xfb, 0x7d, 0xfb, 0xff, 0xb3, 0xb3, 0x0, 0xff, 0xff, 0xff, 0x1, 0xff, 0x70, 0x0, 0x70, 0xff, 0x7e, 0x0, 0x7e, 0xff, 0xe, 0xe, 0xe, 0xff, 0x59, 0x59, 0x59, 0xff, 0x4b, 0x4b, 0x4b, 0xff, 0x71, 0x71, 0x71, 0xff, 0x0, 0x0, 0x0, 0xff, 0x4c, 0x4c, 0x4c, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t\t\tStride: 16,\n\t\t\t\tRect:   image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: 4, Y: 4}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Clone Paletted\",\n\t\t\t&image.Paletted{\n\t\t\t\tRect:   image.Rect(-1, -1, 5, 0),\n\t\t\t\tStride: 6 * 1,\n\t\t\t\tPalette: color.Palette{\n\t\t\t\t\tcolor.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0xff},\n\t\t\t\t\tcolor.NRGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t\t\t\tcolor.NRGBA{R: 0x7f, G: 0x7f, B: 0x7f, A: 0xff},\n\t\t\t\t\tcolor.NRGBA{R: 0x7f, G: 0x00, B: 0x00, A: 0xff},\n\t\t\t\t\tcolor.NRGBA{R: 0x00, G: 0x7f, B: 0x00, A: 0xff},\n\t\t\t\t\tcolor.NRGBA{R: 0x00, G: 0x00, B: 0x7f, A: 0xff},\n\t\t\t\t},\n\t\t\t\tPix: []uint8{0x0, 0x1, 0x2, 0x3, 0x4, 0x5},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 6, 1),\n\t\t\t\tStride: 6 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0x7f, 0x7f, 0x7f, 0xff,\n\t\t\t\t\t0x7f, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x7f, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x7f, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Clone(tc.src)\n\t\t\tdelta := 0\n\t\t\tif _, ok := tc.src.(*image.YCbCr); ok {\n\t\t\t\tdelta = 1\n\t\t\t}\n\t\t\tif !compareNRGBA(got, tc.want, delta) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCrop(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tr    image.Rectangle\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Crop 2x3 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Rect(-1, -1, 1, 2),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Crop 2x3 2x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Rect(-1, 0, 1, 1),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Crop(tc.src, tc.r)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkCrop(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tCrop(testdataBranchesJPG, image.Rect(100, 100, 300, 300))\n\t}\n}\n\nfunc TestCropCenter(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\tw, h int\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"CropCenter 2x3 2x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 1,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropCenter 2x3 0x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 1,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropCenter 2x3 5x5\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t5, 5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := CropCenter(tc.src, tc.w, tc.h)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCropAnchor(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tsrc    image.Image\n\t\tw, h   int\n\t\tanchor Anchor\n\t\twant   *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 TopLeft\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tTopLeft,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 Top\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tTop,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 TopRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tTopRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 Left\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tLeft,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 Center\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tCenter,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 Right\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 BottomLeft\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tBottomLeft,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 Bottom\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tBottom,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 2x2 BottomRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t2, 2,\n\t\t\tBottomRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 0x0 BottomRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 0,\n\t\t\tBottomRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 100x100 BottomRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t100, 100,\n\t\t\tBottomRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 1x100 BottomRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t1, 100,\n\t\t\tBottomRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 4),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"CropAnchor 4x4 0x100 BottomRight\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0, 100,\n\t\t\tBottomRight,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := CropAnchor(tc.src, tc.w, tc.h, tc.anchor)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPaste(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc1 image.Image\n\t\tsrc2 image.Image\n\t\tp    image.Point\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Paste 2x3 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t\t0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(0, 0),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t\t0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Paste 2x3 2x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 3, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-1, 0),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Paste 3x4 4x3 bottom right intersection\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 5, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n\t\t\t\t\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n\t\t\t\t\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(0, 1),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 4),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Paste 3x4 4x3 top left intersection\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 5, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n\t\t\t\t\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n\t\t\t\t\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-3, -2),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 4),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Paste 3x4 4x3 no intersection\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 2, 3),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 5, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n\t\t\t\t\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n\t\t\t\t\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-20, 20),\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 4),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n\t\t\t\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n\t\t\t\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n\t\t\t\t\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Paste(tc.src1, tc.src2, tc.p)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkPaste(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tPaste(testdataBranchesJPG, testdataFlowersSmallPNG, image.Pt(100, 100))\n\t}\n}\n\nfunc TestPasteCenter(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc1 image.Image\n\t\tsrc2 image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"PasteCenter 2x3 2x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 3, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := PasteCenter(tc.src1, tc.src2)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOverlay(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc1 image.Image\n\t\tsrc2 image.Image\n\t\tp    image.Point\n\t\ta    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Overlay 2x3 2x1 1.0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0x60, 0x00, 0x90, 0xff, 0xff, 0x00, 0x99, 0x7f,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 3, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x20, 0x40, 0x80, 0x7f, 0xaa, 0xbb, 0xcc, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-1, 0),\n\t\t\t1.0,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0x40, 0x1f, 0x88, 0xff, 0xaa, 0xbb, 0xcc, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Overlay 2x2 2x2 0.5\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x20, 0x20, 0x20, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0xff, 0xff, 0x00, 0xff, 0x20, 0x20, 0x20, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-1, -1),\n\t\t\t0.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x7f, 0x7f, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x7f, 0x7f, 0x7f, 0xff, 0x20, 0x20, 0x20, 0x7f,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Overlay 2x2 2x2 0.5 no intersection\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x20, 0x20, 0x20, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t0xff, 0xff, 0x00, 0xff, 0x20, 0x20, 0x20, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\timage.Pt(-10, 10),\n\t\t\t0.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x20, 0x20, 0x20, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Overlay(tc.src1, tc.src2, tc.p, tc.a)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkOverlay(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tOverlay(testdataBranchesJPG, testdataFlowersSmallPNG, image.Pt(100, 100), 0.5)\n\t}\n}\n\nfunc TestOverlayCenter(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc1 image.Image\n\t\tsrc2 image.Image\n\t\ta    float64\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"OverlayCenter 2x3 2x1\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x10, 0x10, 0xff, 0x10, 0x10, 0x10, 0xff,\n\t\t\t\t\t0x10, 0x10, 0x10, 0xff, 0x10, 0x10, 0x10, 0xff,\n\t\t\t\t\t0x10, 0x10, 0x10, 0xff, 0x10, 0x10, 0x10, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(1, 1, 3, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0.5,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x10, 0x10, 0x10, 0xff, 0x10, 0x10, 0x10, 0xff,\n\t\t\t\t\t0x2c, 0x2c, 0x2c, 0xff, 0x2c, 0x2c, 0x2c, 0xff,\n\t\t\t\t\t0x10, 0x10, 0x10, 0xff, 0x10, 0x10, 0x10, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := OverlayCenter(tc.src1, tc.src2, 0.5)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "transform.go",
          "type": "blob",
          "size": 6.587890625,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n)\n\n// FlipH flips the image horizontally (from left to right) and returns the transformed image.\nfunc FlipH(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.w\n\tdstH := src.h\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcY := dstY\n\t\t\tsrc.scan(0, srcY, src.w, srcY+1, dst.Pix[i:i+rowSize])\n\t\t\treverse(dst.Pix[i : i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// FlipV flips the image vertically (from top to bottom) and returns the transformed image.\nfunc FlipV(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.w\n\tdstH := src.h\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcY := dstH - dstY - 1\n\t\t\tsrc.scan(0, srcY, src.w, srcY+1, dst.Pix[i:i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Transpose flips the image horizontally and rotates 90 degrees counter-clockwise.\nfunc Transpose(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.h\n\tdstH := src.w\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcX := dstY\n\t\t\tsrc.scan(srcX, 0, srcX+1, src.h, dst.Pix[i:i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Transverse flips the image vertically and rotates 90 degrees counter-clockwise.\nfunc Transverse(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.h\n\tdstH := src.w\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcX := dstH - dstY - 1\n\t\t\tsrc.scan(srcX, 0, srcX+1, src.h, dst.Pix[i:i+rowSize])\n\t\t\treverse(dst.Pix[i : i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Rotate90 rotates the image 90 degrees counter-clockwise and returns the transformed image.\nfunc Rotate90(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.h\n\tdstH := src.w\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcX := dstH - dstY - 1\n\t\t\tsrc.scan(srcX, 0, srcX+1, src.h, dst.Pix[i:i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Rotate180 rotates the image 180 degrees counter-clockwise and returns the transformed image.\nfunc Rotate180(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.w\n\tdstH := src.h\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcY := dstH - dstY - 1\n\t\t\tsrc.scan(0, srcY, src.w, srcY+1, dst.Pix[i:i+rowSize])\n\t\t\treverse(dst.Pix[i : i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Rotate270 rotates the image 270 degrees counter-clockwise and returns the transformed image.\nfunc Rotate270(img image.Image) *image.NRGBA {\n\tsrc := newScanner(img)\n\tdstW := src.h\n\tdstH := src.w\n\trowSize := dstW * 4\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\ti := dstY * dst.Stride\n\t\t\tsrcX := dstY\n\t\t\tsrc.scan(srcX, 0, srcX+1, src.h, dst.Pix[i:i+rowSize])\n\t\t\treverse(dst.Pix[i : i+rowSize])\n\t\t}\n\t})\n\treturn dst\n}\n\n// Rotate rotates an image by the given angle counter-clockwise .\n// The angle parameter is the rotation angle in degrees.\n// The bgColor parameter specifies the color of the uncovered zone after the rotation.\nfunc Rotate(img image.Image, angle float64, bgColor color.Color) *image.NRGBA {\n\tangle = angle - math.Floor(angle/360)*360\n\n\tswitch angle {\n\tcase 0:\n\t\treturn Clone(img)\n\tcase 90:\n\t\treturn Rotate90(img)\n\tcase 180:\n\t\treturn Rotate180(img)\n\tcase 270:\n\t\treturn Rotate270(img)\n\t}\n\n\tsrc := toNRGBA(img)\n\tsrcW := src.Bounds().Max.X\n\tsrcH := src.Bounds().Max.Y\n\tdstW, dstH := rotatedSize(srcW, srcH, angle)\n\tdst := image.NewNRGBA(image.Rect(0, 0, dstW, dstH))\n\n\tif dstW <= 0 || dstH <= 0 {\n\t\treturn dst\n\t}\n\n\tsrcXOff := float64(srcW)/2 - 0.5\n\tsrcYOff := float64(srcH)/2 - 0.5\n\tdstXOff := float64(dstW)/2 - 0.5\n\tdstYOff := float64(dstH)/2 - 0.5\n\n\tbgColorNRGBA := color.NRGBAModel.Convert(bgColor).(color.NRGBA)\n\tsin, cos := math.Sincos(math.Pi * angle / 180)\n\n\tparallel(0, dstH, func(ys <-chan int) {\n\t\tfor dstY := range ys {\n\t\t\tfor dstX := 0; dstX < dstW; dstX++ {\n\t\t\t\txf, yf := rotatePoint(float64(dstX)-dstXOff, float64(dstY)-dstYOff, sin, cos)\n\t\t\t\txf, yf = xf+srcXOff, yf+srcYOff\n\t\t\t\tinterpolatePoint(dst, dstX, dstY, src, xf, yf, bgColorNRGBA)\n\t\t\t}\n\t\t}\n\t})\n\n\treturn dst\n}\n\nfunc rotatePoint(x, y, sin, cos float64) (float64, float64) {\n\treturn x*cos - y*sin, x*sin + y*cos\n}\n\nfunc rotatedSize(w, h int, angle float64) (int, int) {\n\tif w <= 0 || h <= 0 {\n\t\treturn 0, 0\n\t}\n\n\tsin, cos := math.Sincos(math.Pi * angle / 180)\n\tx1, y1 := rotatePoint(float64(w-1), 0, sin, cos)\n\tx2, y2 := rotatePoint(float64(w-1), float64(h-1), sin, cos)\n\tx3, y3 := rotatePoint(0, float64(h-1), sin, cos)\n\n\tminx := math.Min(x1, math.Min(x2, math.Min(x3, 0)))\n\tmaxx := math.Max(x1, math.Max(x2, math.Max(x3, 0)))\n\tminy := math.Min(y1, math.Min(y2, math.Min(y3, 0)))\n\tmaxy := math.Max(y1, math.Max(y2, math.Max(y3, 0)))\n\n\tneww := maxx - minx + 1\n\tif neww-math.Floor(neww) > 0.1 {\n\t\tneww++\n\t}\n\tnewh := maxy - miny + 1\n\tif newh-math.Floor(newh) > 0.1 {\n\t\tnewh++\n\t}\n\n\treturn int(neww), int(newh)\n}\n\nfunc interpolatePoint(dst *image.NRGBA, dstX, dstY int, src *image.NRGBA, xf, yf float64, bgColor color.NRGBA) {\n\tj := dstY*dst.Stride + dstX*4\n\td := dst.Pix[j : j+4 : j+4]\n\n\tx0 := int(math.Floor(xf))\n\ty0 := int(math.Floor(yf))\n\tbounds := src.Bounds()\n\tif !image.Pt(x0, y0).In(image.Rect(bounds.Min.X-1, bounds.Min.Y-1, bounds.Max.X, bounds.Max.Y)) {\n\t\td[0] = bgColor.R\n\t\td[1] = bgColor.G\n\t\td[2] = bgColor.B\n\t\td[3] = bgColor.A\n\t\treturn\n\t}\n\n\txq := xf - float64(x0)\n\tyq := yf - float64(y0)\n\tpoints := [4]image.Point{\n\t\t{x0, y0},\n\t\t{x0 + 1, y0},\n\t\t{x0, y0 + 1},\n\t\t{x0 + 1, y0 + 1},\n\t}\n\tweights := [4]float64{\n\t\t(1 - xq) * (1 - yq),\n\t\txq * (1 - yq),\n\t\t(1 - xq) * yq,\n\t\txq * yq,\n\t}\n\n\tvar r, g, b, a float64\n\tfor i := 0; i < 4; i++ {\n\t\tp := points[i]\n\t\tw := weights[i]\n\t\tif p.In(bounds) {\n\t\t\ti := p.Y*src.Stride + p.X*4\n\t\t\ts := src.Pix[i : i+4 : i+4]\n\t\t\twa := float64(s[3]) * w\n\t\t\tr += float64(s[0]) * wa\n\t\t\tg += float64(s[1]) * wa\n\t\t\tb += float64(s[2]) * wa\n\t\t\ta += wa\n\t\t} else {\n\t\t\twa := float64(bgColor.A) * w\n\t\t\tr += float64(bgColor.R) * wa\n\t\t\tg += float64(bgColor.G) * wa\n\t\t\tb += float64(bgColor.B) * wa\n\t\t\ta += wa\n\t\t}\n\t}\n\tif a != 0 {\n\t\taInv := 1 / a\n\t\td[0] = clamp(r * aInv)\n\t\td[1] = clamp(g * aInv)\n\t\td[2] = clamp(b * aInv)\n\t\td[3] = clamp(a)\n\t}\n}\n"
        },
        {
          "name": "transform_test.go",
          "type": "blob",
          "size": 15.654296875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"testing\"\n)\n\nfunc TestFlipH(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"FlipH 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t\t0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := FlipH(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkFlipH(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tFlipH(testdataBranchesJPG)\n\t}\n}\n\nfunc TestFlipV(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"FlipV 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := FlipV(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkFlipV(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tFlipV(testdataBranchesJPG)\n\t}\n}\n\nfunc TestTranspose(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Transpose 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Transpose(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTranspose(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tTranspose(testdataBranchesJPG)\n\t}\n}\n\nfunc TestTransverse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Transverse 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Transverse(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTransverse(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tTransverse(testdataBranchesJPG)\n\t}\n}\n\nfunc TestRotate90(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Rotate90 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Rotate90(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRotate90(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tRotate90(testdataBranchesJPG)\n\t}\n}\n\nfunc TestRotate180(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Rotate180 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 3),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,\n\t\t\t\t\t0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n\t\t\t\t\t0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Rotate180(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRotate180(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tRotate180(testdataBranchesJPG)\n\t}\n}\n\nfunc TestRotate270(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tsrc  image.Image\n\t\twant *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Rotate270 2x3\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 1, 2),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x11, 0x22, 0x33, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 3, 2),\n\t\t\t\tStride: 3 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xcc, 0xdd, 0xee, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Rotate270(tc.src)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRotate270(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tRotate270(testdataBranchesJPG)\n\t}\n}\n\nfunc TestRotate(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tsrc   image.Image\n\t\tangle float64\n\t\tbg    color.Color\n\t\twant  *image.NRGBA\n\t}{\n\t\t{\n\t\t\t\"Rotate 0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 90\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t90,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 180\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t180,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 4, 4),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 45\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 3, 3),\n\t\t\t\tStride: 4 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n\t\t\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t45,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 6, 6),\n\t\t\t\tStride: 6 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x61, 0x00, 0x00, 0xff, 0x58, 0x08, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x61, 0x00, 0x00, 0xff, 0xe9, 0x16, 0x00, 0xff, 0x35, 0xca, 0x00, 0xff, 0x00, 0x30, 0x30, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x61, 0x00, 0x00, 0xff, 0xe9, 0x16, 0x00, 0xff, 0x35, 0xca, 0x00, 0xff, 0x00, 0x80, 0x80, 0xff, 0x35, 0x35, 0xff, 0xff, 0x58, 0x58, 0x61, 0xff,\n\t\t\t\t\t0x58, 0x08, 0x00, 0xff, 0x35, 0xca, 0x00, 0xff, 0x00, 0x80, 0x80, 0xff, 0x35, 0x35, 0xff, 0xff, 0xe9, 0xe9, 0xff, 0xff, 0x61, 0x61, 0x61, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x30, 0x30, 0xff, 0x35, 0x35, 0xff, 0xff, 0xe9, 0xe9, 0xff, 0xff, 0x61, 0x61, 0x61, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x58, 0x58, 0x61, 0xff, 0x61, 0x61, 0x61, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 0x0\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t\t123,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 0, 0),\n\t\t\t\tStride: 0,\n\t\t\t\tPix:    []uint8{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate -90\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-90,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate -360*10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-360 * 10,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate -360*10 + 90\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-360*10 + 90,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate -360*10 + 180\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-360*10 + 180,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate -360*10 + 270\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t-360*10 + 270,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 360*10\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t360 * 10,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 360*10 + 90\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t360*10 + 90,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 360*10 + 180\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t360*10 + 180,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 1, 2),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Rotate 360*10 + 270\",\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(-1, -1, 0, 1),\n\t\t\t\tStride: 1 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0xff, 0x00, 0x00, 0xff,\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t\t360*10 + 270,\n\t\t\tcolor.Black,\n\t\t\t&image.NRGBA{\n\t\t\t\tRect:   image.Rect(0, 0, 2, 1),\n\t\t\t\tStride: 2 * 4,\n\t\t\t\tPix: []uint8{\n\t\t\t\t\t0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Rotate(tc.src, tc.angle, tc.bg)\n\t\t\tif !compareNRGBA(got, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got result %#v want %#v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRotate(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tRotate(testdataBranchesJPG, 30, color.Transparent)\n\t}\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 2.8046875,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nvar maxProcs int64\n\n// SetMaxProcs limits the number of concurrent processing goroutines to the given value.\n// A value <= 0 clears the limit.\nfunc SetMaxProcs(value int) {\n\tatomic.StoreInt64(&maxProcs, int64(value))\n}\n\n// parallel processes the data in separate goroutines.\nfunc parallel(start, stop int, fn func(<-chan int)) {\n\tcount := stop - start\n\tif count < 1 {\n\t\treturn\n\t}\n\n\tprocs := runtime.GOMAXPROCS(0)\n\tlimit := int(atomic.LoadInt64(&maxProcs))\n\tif procs > limit && limit > 0 {\n\t\tprocs = limit\n\t}\n\tif procs > count {\n\t\tprocs = count\n\t}\n\n\tc := make(chan int, count)\n\tfor i := start; i < stop; i++ {\n\t\tc <- i\n\t}\n\tclose(c)\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < procs; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfn(c)\n\t\t}()\n\t}\n\twg.Wait()\n}\n\n// absint returns the absolute value of i.\nfunc absint(i int) int {\n\tif i < 0 {\n\t\treturn -i\n\t}\n\treturn i\n}\n\n// clamp rounds and clamps float64 value to fit into uint8.\nfunc clamp(x float64) uint8 {\n\tv := int64(x + 0.5)\n\tif v > 255 {\n\t\treturn 255\n\t}\n\tif v > 0 {\n\t\treturn uint8(v)\n\t}\n\treturn 0\n}\n\nfunc reverse(pix []uint8) {\n\tif len(pix) <= 4 {\n\t\treturn\n\t}\n\ti := 0\n\tj := len(pix) - 4\n\tfor i < j {\n\t\tpi := pix[i : i+4 : i+4]\n\t\tpj := pix[j : j+4 : j+4]\n\t\tpi[0], pj[0] = pj[0], pi[0]\n\t\tpi[1], pj[1] = pj[1], pi[1]\n\t\tpi[2], pj[2] = pj[2], pi[2]\n\t\tpi[3], pj[3] = pj[3], pi[3]\n\t\ti += 4\n\t\tj -= 4\n\t}\n}\n\nfunc toNRGBA(img image.Image) *image.NRGBA {\n\tif img, ok := img.(*image.NRGBA); ok {\n\t\treturn &image.NRGBA{\n\t\t\tPix:    img.Pix,\n\t\t\tStride: img.Stride,\n\t\t\tRect:   img.Rect.Sub(img.Rect.Min),\n\t\t}\n\t}\n\treturn Clone(img)\n}\n\n// rgbToHSL converts a color from RGB to HSL.\nfunc rgbToHSL(r, g, b uint8) (float64, float64, float64) {\n\trr := float64(r) / 255\n\tgg := float64(g) / 255\n\tbb := float64(b) / 255\n\n\tmax := math.Max(rr, math.Max(gg, bb))\n\tmin := math.Min(rr, math.Min(gg, bb))\n\n\tl := (max + min) / 2\n\n\tif max == min {\n\t\treturn 0, 0, l\n\t}\n\n\tvar h, s float64\n\td := max - min\n\tif l > 0.5 {\n\t\ts = d / (2 - max - min)\n\t} else {\n\t\ts = d / (max + min)\n\t}\n\n\tswitch max {\n\tcase rr:\n\t\th = (gg - bb) / d\n\t\tif g < b {\n\t\t\th += 6\n\t\t}\n\tcase gg:\n\t\th = (bb-rr)/d + 2\n\tcase bb:\n\t\th = (rr-gg)/d + 4\n\t}\n\th /= 6\n\n\treturn h, s, l\n}\n\n// hslToRGB converts a color from HSL to RGB.\nfunc hslToRGB(h, s, l float64) (uint8, uint8, uint8) {\n\tvar r, g, b float64\n\tif s == 0 {\n\t\tv := clamp(l * 255)\n\t\treturn v, v, v\n\t}\n\n\tvar q float64\n\tif l < 0.5 {\n\t\tq = l * (1 + s)\n\t} else {\n\t\tq = l + s - l*s\n\t}\n\tp := 2*l - q\n\n\tr = hueToRGB(p, q, h+1/3.0)\n\tg = hueToRGB(p, q, h)\n\tb = hueToRGB(p, q, h-1/3.0)\n\n\treturn clamp(r * 255), clamp(g * 255), clamp(b * 255)\n}\n\nfunc hueToRGB(p, q, t float64) float64 {\n\tif t < 0 {\n\t\tt++\n\t}\n\tif t > 1 {\n\t\tt--\n\t}\n\tif t < 1/6.0 {\n\t\treturn p + (q-p)*6*t\n\t}\n\tif t < 1/2.0 {\n\t\treturn q\n\t}\n\tif t < 2/3.0 {\n\t\treturn p + (q-p)*(2/3.0-t)*6\n\t}\n\treturn p\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 5.537109375,
          "content": "package imaging\n\nimport (\n\t\"image\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"testing\"\n)\n\nvar (\n\ttestdataBranchesJPG     = mustOpen(\"testdata/branches.jpg\")\n\ttestdataBranchesPNG     = mustOpen(\"testdata/branches.png\")\n\ttestdataFlowersSmallPNG = mustOpen(\"testdata/flowers_small.png\")\n)\n\nfunc mustOpen(filename string) image.Image {\n\timg, err := Open(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn img\n}\n\nfunc TestParallel(t *testing.T) {\n\tfor _, n := range []int{0, 1, 10, 100, 1000} {\n\t\tfor _, p := range []int{1, 2, 4, 8, 16, 100} {\n\t\t\tif !testParallelN(n, p) {\n\t\t\t\tt.Fatalf(\"test [parallel %d %d] failed\", n, p)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc testParallelN(n, procs int) bool {\n\tdata := make([]bool, n)\n\tbefore := runtime.GOMAXPROCS(0)\n\truntime.GOMAXPROCS(procs)\n\tparallel(0, n, func(is <-chan int) {\n\t\tfor i := range is {\n\t\t\tdata[i] = true\n\t\t}\n\t})\n\truntime.GOMAXPROCS(before)\n\tfor i := 0; i < n; i++ {\n\t\tif !data[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestParallelMaxProcs(t *testing.T) {\n\tfor _, n := range []int{0, 1, 10, 100, 1000} {\n\t\tfor _, p := range []int{1, 2, 4, 8, 16, 100} {\n\t\t\tif !testParallelMaxProcsN(n, p) {\n\t\t\t\tt.Fatalf(\"test [parallel max procs %d %d] failed\", n, p)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc testParallelMaxProcsN(n, procs int) bool {\n\tdata := make([]bool, n)\n\tSetMaxProcs(procs)\n\tparallel(0, n, func(is <-chan int) {\n\t\tfor i := range is {\n\t\t\tdata[i] = true\n\t\t}\n\t})\n\tSetMaxProcs(0)\n\tfor i := 0; i < n; i++ {\n\t\tif !data[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestSetMaxProcs(t *testing.T) {\n\tfor _, p := range []int{-1, 0, 10} {\n\t\tSetMaxProcs(p)\n\t\tif int(atomic.LoadInt64(&maxProcs)) != p {\n\t\t\tt.Fatalf(\"test [set max procs %d] failed\", p)\n\t\t}\n\t}\n\n\tSetMaxProcs(0)\n}\n\nfunc TestClamp(t *testing.T) {\n\ttestCases := []struct {\n\t\tf float64\n\t\tu uint8\n\t}{\n\t\t{0, 0},\n\t\t{255, 255},\n\t\t{128, 128},\n\t\t{0.49, 0},\n\t\t{0.50, 1},\n\t\t{254.9, 255},\n\t\t{254.0, 254},\n\t\t{256, 255},\n\t\t{2500, 255},\n\t\t{-10, 0},\n\t\t{127.6, 128},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif clamp(tc.f) != tc.u {\n\t\t\tt.Fatalf(\"test [clamp %v %v] failed: %v\", tc.f, tc.u, clamp(tc.f))\n\t\t}\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\ttestCases := []struct {\n\t\tpix  []uint8\n\t\twant []uint8\n\t}{\n\t\t{\n\t\t\tpix:  []uint8{},\n\t\t\twant: []uint8{},\n\t\t},\n\t\t{\n\t\t\tpix:  []uint8{1, 2, 3, 4},\n\t\t\twant: []uint8{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tpix:  []uint8{1, 2, 3, 4, 5, 6, 7, 8},\n\t\t\twant: []uint8{5, 6, 7, 8, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tpix:  []uint8{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},\n\t\t\twant: []uint8{9, 10, 11, 12, 5, 6, 7, 8, 1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\treverse(tc.pix)\n\t\t\tif !compareBytes(tc.pix, tc.want, 0) {\n\t\t\t\tt.Fatalf(\"got pix %v want %v\", tc.pix, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareNRGBA(img1, img2 *image.NRGBA, delta int) bool {\n\tif !img1.Rect.Eq(img2.Rect) {\n\t\treturn false\n\t}\n\treturn compareBytes(img1.Pix, img2.Pix, delta)\n}\n\nfunc compareBytes(a, b []uint8, delta int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(a); i++ {\n\t\tif absint(int(a[i])-int(b[i])) > delta {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// compareNRGBAGolden is a special version of compareNRGBA used in golden tests.\n// All the golden images are generated on amd64 architecture. Due to differences\n// in floating-point rounding on different architectures, we need to add some\n// level of tolerance when comparing images on architectures other than amd64.\n// See https://golang.org/ref/spec#Floating_point_operators for information on\n// fused multiply and add (FMA) instruction.\nfunc compareNRGBAGolden(img1, img2 *image.NRGBA) bool {\n\tdelta := 0\n\tif runtime.GOARCH != \"amd64\" {\n\t\tdelta = 1\n\t}\n\treturn compareNRGBA(img1, img2, delta)\n}\n\nfunc compareFloat64(a, b, delta float64) bool {\n\treturn math.Abs(a-b) <= delta\n}\n\nvar rgbHSLTestCases = []struct {\n\tr, g, b uint8\n\th, s, l float64\n}{\n\t{\n\t\tr: 255,\n\t\tg: 0,\n\t\tb: 0,\n\t\th: 0.000,\n\t\ts: 1.000,\n\t\tl: 0.500,\n\t},\n\t{\n\t\tr: 191,\n\t\tg: 191,\n\t\tb: 0,\n\t\th: 0.167,\n\t\ts: 1.000,\n\t\tl: 0.375,\n\t},\n\t{\n\t\tr: 0,\n\t\tg: 128,\n\t\tb: 0,\n\t\th: 0.333,\n\t\ts: 1.000,\n\t\tl: 0.251,\n\t},\n\t{\n\t\tr: 128,\n\t\tg: 255,\n\t\tb: 255,\n\t\th: 0.500,\n\t\ts: 1.000,\n\t\tl: 0.751,\n\t},\n\t{\n\t\tr: 128,\n\t\tg: 128,\n\t\tb: 255,\n\t\th: 0.667,\n\t\ts: 1.000,\n\t\tl: 0.751,\n\t},\n\t{\n\t\tr: 191,\n\t\tg: 64,\n\t\tb: 191,\n\t\th: 0.833,\n\t\ts: 0.498,\n\t\tl: 0.500,\n\t},\n\t{\n\t\tr: 160,\n\t\tg: 164,\n\t\tb: 36,\n\t\th: 0.172,\n\t\ts: 0.640,\n\t\tl: 0.392,\n\t},\n\t{\n\t\tr: 65,\n\t\tg: 27,\n\t\tb: 234,\n\t\th: 0.697,\n\t\ts: 0.831,\n\t\tl: 0.512,\n\t},\n\t{\n\t\tr: 30,\n\t\tg: 172,\n\t\tb: 65,\n\t\th: 0.374,\n\t\ts: 0.703,\n\t\tl: 0.396,\n\t},\n\t{\n\t\tr: 240,\n\t\tg: 200,\n\t\tb: 14,\n\t\th: 0.137,\n\t\ts: 0.890,\n\t\tl: 0.498,\n\t},\n\t{\n\t\tr: 180,\n\t\tg: 48,\n\t\tb: 229,\n\t\th: 0.788,\n\t\ts: 0.777,\n\t\tl: 0.543,\n\t},\n\t{\n\t\tr: 237,\n\t\tg: 119,\n\t\tb: 81,\n\t\th: 0.040,\n\t\ts: 0.813,\n\t\tl: 0.624,\n\t},\n\t{\n\t\tr: 254,\n\t\tg: 248,\n\t\tb: 136,\n\t\th: 0.158,\n\t\ts: 0.983,\n\t\tl: 0.765,\n\t},\n\t{\n\t\tr: 25,\n\t\tg: 203,\n\t\tb: 151,\n\t\th: 0.451,\n\t\ts: 0.781,\n\t\tl: 0.447,\n\t},\n\t{\n\t\tr: 54,\n\t\tg: 38,\n\t\tb: 152,\n\t\th: 0.690,\n\t\ts: 0.600,\n\t\tl: 0.373,\n\t},\n\t{\n\t\tr: 126,\n\t\tg: 126,\n\t\tb: 184,\n\t\th: 0.667,\n\t\ts: 0.290,\n\t\tl: 0.608,\n\t},\n}\n\nfunc TestRGBToHSL(t *testing.T) {\n\tfor _, tc := range rgbHSLTestCases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\th, s, l := rgbToHSL(tc.r, tc.g, tc.b)\n\t\t\tif !compareFloat64(h, tc.h, 0.001) || !compareFloat64(s, tc.s, 0.001) || !compareFloat64(l, tc.l, 0.001) {\n\t\t\t\tt.Fatalf(\"(%d, %d, %d): got (%.3f, %.3f, %.3f) want (%.3f, %.3f, %.3f)\", tc.r, tc.g, tc.b, h, s, l, tc.h, tc.s, tc.l)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHSLToRGB(t *testing.T) {\n\tfor _, tc := range rgbHSLTestCases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tr, g, b := hslToRGB(tc.h, tc.s, tc.l)\n\t\t\tif r != tc.r || g != tc.g || b != tc.b {\n\t\t\t\tt.Fatalf(\"(%.3f, %.3f, %.3f): got (%d, %d, %d) want (%d, %d, %d)\", tc.h, tc.s, tc.l, r, g, b, tc.r, tc.g, tc.b)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}