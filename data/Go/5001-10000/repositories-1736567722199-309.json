{
  "metadata": {
    "timestamp": 1736567722199,
    "page": 309,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bitfield/script",
      "stars": 5777,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.259765625,
          "content": "# Treat all files in this repo as binary, with no git magic updating line\n# endings. Windows users contributing to the project will need to use a modern\n# version of git and editors capable of LF line endings.\n#\n# See https://github.com/golang/go/issues/9281\n* -text"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1806640625,
          "content": ".DS_Store\nexamples/cat/cat\nexamples/grep/grep\nexamples/cat2/cat2\nexamples/echo/echo\nexamples/head/head\nexamples/visitors/visitors\nexamples/*/go.sum\n.vscode/settings.json\nexamples/ls/ls\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.21875,
          "content": "# CONTRIBUTOR CODE OF CONDUCT\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others’ private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at go@bitfieldconsulting.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\nFor answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 13.548828125,
          "content": "So you'd like to contribute to the `script` library? Excellent! Thank you very much. I can absolutely use your help.\n\n# Getting started\n\nHere are some hints on a good workflow for contributing to the project.\n\n## Look for existing issues\n\nFirst of all, check the [issues](https://github.com/bitfield/script/issues) list. If you see an outstanding issue that you would like to tackle, by all means comment on the issue and let me know.\n\nIf you already have an idea for a feature you want to add, check the issues list anyway, just to make sure it hasn't already been discussed.\n\n## Open a new issue before making a PR\n\nI _don't_ recommend just making a pull request for some new feature—it probably won't be accepted! Usually it's better to [open an issue](https://github.com/bitfield/script/issues/new) first, and we can discuss what the feature is about, how best to design it, other people can weigh in with contributions, and so forth. Design is, in fact, the hard part. Once we have a solid, well-thought-out design, implementing it is usually fairly easy. (Implementing a bad design may be easy too, but it's a waste of effort.)\n\n## Write a use case\n\nThis is probably the most important thing to bear in mind. A great design principle for software libraries is to start with a real-world use case, and try to implement it using the feature you have in mind. _No issues or PRs will be accepted into `script` without an accompanying use case_. And I hold myself to that rule just as much as anybody else.\n\nWhat do I mean by \"use case\"? I mean a real problem that you or someone else actually has, that could be solved using the feature. For example, you might think it's a very cool idea to add a `Frobnicate()` method to `script`. Maybe it is, but what's it for? Where would this be used in the real world? Can you give an example of a problem that could be solved by a `script` program using `Frobnicate()`? If so, what would the program look like?\n\nThe reason for insisting on this up front is that it's much easier to design a feature the right way if you start with its usage in mind. It's all too easy to design something in the abstract, and then find later that when you try to use it in a program, the API is completely unsuitable.\n\nA concrete use case also provides a helpful example program that can be included with the library to show how the feature is used.\n\nThe final reason is that it's tempting to over-elaborate a design and add all sorts of bells and whistles that nobody actually wants. Simple APIs are best. If you think of an enhancement, but it's not needed for your use case, leave it out. Things can always be enhanced later if necessary.\n\n# Coding standards\n\nA library is easier to use, and easier for contributors to work on, if it has a consistent, unified style, approach, and layout. Here are a few hints on how to make a `script` PR that will be accepted right away.\n\n## Tests\n\nIt goes without saying, but I'll say it anyway, that you must provide comprehensive tests for your feature. Code coverage doesn't need to be 100% (that's a waste of time and effort), but it does need to be very good. The [awesome-go](https://github.com/avelino/awesome-go) collection (which `script` is part of) mandates at least 80% coverage, and I'd rather it were 90% or better.\n\nTest data should go in the `testdata` directory. If you create a file of data for input to your method, name it `method_name.input.txt`. If you create a 'golden' file (of correct output, to compare with the output from your method) name it `method_name.golden.txt`. This will help keep things organised.\n\n### Use the standard library\n\nAll `script` tests use the standard Go `testing` library; they don't use `testify` or `gock` or any of the other tempting and shiny test libraries. There's nothing wrong with those libraries, but it's good to keep things consistent, and not import any libraries we don't absolutely need.\n\nYou'll get the feel of things by reading the existing tests, and maybe copying and adapting them for your own feature.\n\nAll tests should call `t.Parallel()`. If there is some really good reason why your test can't be run in parallel, we'll talk about it.\n\n### Spend time on your test cases\n\nAdd lots of test cases; they're cheap. Don't just test the obvious happy-path cases; test the null case, where your feature does nothing (make sure it does!). Test edge cases, strange inputs, missing inputs, non-ASCII characters, zeroes, and nils. Knowing what you know about your implementation, what inputs and cases might possibly cause it to break? Test those.\n\nRemember people are using `script` to write mission-critical system administration programs where their data, their privacy, and even their business could be at stake. Now, of course it's up to them to make sure that their programs are safe and correct; library maintainers bear no responsibility for that. But we can at least ensure that the code is as reliable and trustworthy as we can make it.\n\n### Add your method to `doMethodsOnPipe` for stress testing\n\nOne final point: a common source of errors in Go programs is methods being called on zero or nil values. All `script` pipe methods should handle this situation, as well as being called on a valid pipe that just happens to have no contents (such as a newly-created pipe).\n\nTo ensure this, we call every possible method on (in turn) a nil pipe, a zero pipe, and an empty pipe, using the `doMethodsOnPipe` helper function. If you add a new method to `script`, add a call to your method to this helper function, and it will automatically be stress tested.\n\nMethods on a nil, zero, or empty pipe should not necessarily do nothing; that depends on the method semantics. For example, `WriteFile()` on an empty pipe creates the required file, writes nothing to it, and closes it. This is correct behaviour.\n\n## Dealing with errors\n\nRuntime errors (as opposed to test failures or compilation errors) are handled in a special way in `script`.\n\n### Don't panic\n\nMethods should not, in any situation, panic. In fact, no `script` method panics, nor should any library method. Because calling `panic()` ends the program, this decision should be reserved for the `main()` function. In other words, it's up to the user, not us, when to crash the program. This is a good design principle for Go libraries in general, but especially here because we have a better way of dealing with errors.\n\n### Set the pipe's error status\n\nNormally, Go library code that encounters a problem would return an error to the caller, but `script` methods are specifically designed not to do this (see [Handling errors](README.md#Handling-errors)). Instead, set the error status on the pipe and return. Before you do anything at all in your method, you should check whether the pipe is nil, or the error status is set, and if so, return immediately.\n\nHere's an example:\n\n```go\nfunc (p *Pipe) Frobnicate() *Pipe {\n\t// If the pipe has an error, or is nil, this is a no-op\n\tif p == nil || p.Error() != nil {\n\t\treturn p\n\t}\n\toutput, err := doSomething()\n\tif err != nil {\n\t\t// Something went wrong, so save the error in the pipe. The user can\n\t\t// check it afterwards.\n\t\tp.SetError(err)\n\t\treturn p\n\t}\n\treturn NewPipe().WithReader(bytes.NewReader(output))\n}\n```\n\n## Style and formatting\n\nThis is easy in Go. Just use `gofmt`. End of.\n\nYour code should also pass `golint` and `go vet` without errors (and if you want to run other linters too, that would be excellent). Very, very occasionally there are situations where `golint` incorrectly detects a problem, and the workaround is awkward or annoying. In that situation, comment on the PR and we'll work out how best to handle it.\n\n# Documentation\n\nIt doesn't matter if you write the greatest piece of code in the history of the world, if no one knows it exists, or how to use it.\n\n## Write doc comments\n\nAny functions or methods you write should have useful documentation comments in the standard `go doc` format. Specifically, they should say what inputs the function takes, what it does (in detail), and what outputs it returns. If it returns an error value, explain under what circumstances this happens.\n\nFor example:\n\n```go\n// WriteFile writes the contents of the pipe to the specified file, and closes\n// the pipe after reading. If the file already exists, it is truncated and the\n// new data will replace the old. It returns the number of bytes successfully\n// written, or an error.\nfunc (p *Pipe) WriteFile(fileName string) (int64, error) {\n```\n\nThis is the _whole_ user manual for your code. It will be included in the autogenerated documentation for the whole package. Remember that readers will often see it _without_ the accompanying code, so it needs to make sense on its own.\n\n## Update the README\n\nAny change to the `script` API should also be accompanied by an update to the README. If you add a new method, add it to the appropriate table (sources, filters, or sinks), and if it's the equivalent of a command Unix command, add it to the table of Unix equivalents too.\n\n# Before submitting your pull request\n\nHere's a handy checklist for making sure your PR will be accepted as quickly as possible.\n\n- [ ] Have you opened an issue to discuss the feature and agree its general design?\n- [ ] Do you have a use case and, ideally, an example program using the feature?\n- [ ] Do you have tests covering 90%+ of the feature code (and, of course passing)\n- [ ] Have you added your method to the `doMethodsOnPipe` stress tests?\n- [ ] Have you written complete and accurate doc comments?\n- [ ] Have you updated the README and its table of contents?\n- [ ] You rock. Thanks a lot.\n\n# After submitting your PR\n\nHere's a nice tip for PR-driven development in general. After you've submitted the PR, do a 'pre-code-review'. Go through the diffs, line by line, and be your own code reviewer. Does something look weird? Is something not quite straightforward? It's quite likely that you'll spot errors at this stage that you missed before, simply because you're looking at the code with a reviewer's mindset.\n\nIf so, fix them! But if you can foresee a question from a code reviewer, comment on the code to answer it in advance. (Even better, improve the code so that the question doesn't arise.)\n\n# The code review process\n\nIf you've completed all these steps, I _will_ invest significant time and energy in giving your PR a detailed code review. This is a powerful and beneficial process that can not only improve the code, but can also help you learn to be a better engineer and a better Go programmer—and the same goes for me!\n\n## Expect to be taken seriously\n\nDon't think of code review as a \"you got this wrong, fix it\" kind of conversation (this isn't a helpful review comment). Instead, think of it as a discussion where both sides can ask questions, make suggestions, clarify problems and misunderstandings, catch mistakes, and add improvements.\n\nYou shouldn't be disappointed if you don't get a simple 'LGTM' and an instant merge. If this is what you're used to, then your team isn't really doing code review to its full potential. Instead, the more comments you get, the more seriously it means I'm taking your work. Where appropriate, I'll say what I liked as well as what I'd like to see improved.\n\n## Dealing with comments\n\nNow comes the tricky bit. You may not agree with some of the code review comments. Reviewing code is a delicate business in the first place, requiring diplomacy as well as discretion, but responding to code reviews is also a skilled task.\n\nIf you find yourself reacting emotionally, take a break. Go walk in the woods for a while, or play with a laughing child. When you come back to the code, approach it as though it were someone else's, not your own, and ask yourself seriously whether or not the reviewer _has a point_.\n\nIf you genuinely think the reviewer has just misunderstood something, or made a mistake, try to clarify the issue. Ask questions, don't make accusations. Remember that every project has a certain way of doing things that may not be _your_ way. It's polite to go along with these practices and conventions.\n\nYou may feel as though you're doing the project maintainer a favour by contributing, as indeed you are, but an open source project is like somebody's home. They're used to living there, they probably like it the way it is, and they don't always respond well to strangers marching in and rearranging the furniture. Be considerate, and be willing to listen and make changes.\n\n## This may take a while\n\nDon't be impatient. We've all had the experience of sending in our beautifully-crafted PR and then waiting, waiting, waiting. Why won't those idiots just merge it? How come other issues and PRs are getting dealt with ahead of mine? Am I invisible?\n\nIn fact, doing a _proper_ and serious code review is a time-consuming business. It's not just a case of skim-reading the diffs. The reviewer will need to check out your branch, run the tests, think carefully about what you've done, make suggestions, test alternatives. It's almost as much work as writing the PR in the first place.\n\nOpen source maintainers are just regular folk with jobs, kids, and zero free time or energy. They may not be able to drop everything and put in several hours on your PR. The task may have to wait a week or two until they can get sufficient time and peace and quiet to work on it. Don't pester them. It's fine to add a comment on the PR if you haven't heard anything for a while, asking if the reviewer's been able to look at it and whether there's anything you can do to help speed things up. Comments like 'Y U NO MERGE' are unlikely to elicit a positive response.\n\nThanks again for helping out!\n\n## Code of Conduct\n\nAs a contributor you can help keep the `script` community inclusive and open to everyone. Please read and adhere to our [Code of Conduct](CODE_OF_CONDUCT.md).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2019 John Arundel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.7578125,
          "content": "[![Go Reference](https://pkg.go.dev/badge/github.com/bitfield/script.svg)](https://pkg.go.dev/github.com/bitfield/script)\n[![Go Report Card](https://goreportcard.com/badge/github.com/bitfield/script)](https://goreportcard.com/report/github.com/bitfield/script)\n[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge-flat.svg)](https://github.com/avelino/awesome-go)\n![CI](https://github.com/bitfield/script/actions/workflows/ci.yml/badge.svg)\n![Audit](https://github.com/bitfield/script/actions/workflows/audit.yml/badge.svg)\n\n```go\nimport \"github.com/bitfield/script\"\n```\n\n[![Magical gopher logo](img/magic.png)](https://bitfieldconsulting.com/golang/scripting)\n\n# What is `script`?\n\n`script` is a Go library for doing the kind of tasks that shell scripts are good at: reading files, executing subprocesses, counting lines, matching strings, and so on.\n\nWhy shouldn't it be as easy to write system administration programs in Go as it is in a typical shell? `script` aims to make it just that easy.\n\nShell scripts often compose a sequence of operations on a stream of data (a _pipeline_). This is how `script` works, too.\n\n> *This is one absolutely superb API design. Taking inspiration from shell pipes and turning it into a Go library with syntax this clean is really impressive.*\\\n> —[Simon Willison](https://news.ycombinator.com/item?id=30649524)\n\nRead more: [Scripting with Go](https://bitfieldconsulting.com/golang/scripting)\n\n# Quick start: Unix equivalents\n\nIf you're already familiar with shell scripting and the Unix toolset, here is a rough guide to the equivalent `script` operation for each listed Unix command.\n\n| Unix / shell       | `script` equivalent |\n| ------------------ | ------------------- |\n| (any program name) | [`Exec`](https://pkg.go.dev/github.com/bitfield/script#Exec) |\n| `[ -f FILE ]`      | [`IfExists`](https://pkg.go.dev/github.com/bitfield/script#IfExists) |\n| `>`                | [`WriteFile`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WriteFile) |\n| `>>`               | [`AppendFile`](https://pkg.go.dev/github.com/bitfield/script#Pipe.AppendFile) |\n| `$*`               | [`Args`](https://pkg.go.dev/github.com/bitfield/script#Args) |\n| `base64`           | [`DecodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64) / [`EncodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64) |\n| `basename`         | [`Basename`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Basename) |\n| `cat`              | [`File`](https://pkg.go.dev/github.com/bitfield/script#File) / [`Concat`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Concat) |\n| `curl`             | [`Do`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Do) / [`Get`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Get) / [`Post`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Post) |\n| `cut`              | [`Column`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Column) |\n| `dirname`          | [`Dirname`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Dirname) |\n| `echo`             | [`Echo`](https://pkg.go.dev/github.com/bitfield/script#Echo) |\n| `find`             | [`FindFiles`](https://pkg.go.dev/github.com/bitfield/script#FindFiles) |\n| `grep`             | [`Match`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Match) / [`MatchRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.MatchRegexp) |\n| `grep -v`          | [`Reject`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Reject) / [`RejectRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.RejectRegexp) |\n| `head`             | [`First`](https://pkg.go.dev/github.com/bitfield/script#Pipe.First) |\n| `jq`     | [`JQ`](https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ) |\n| `ls`               | [`ListFiles`](https://pkg.go.dev/github.com/bitfield/script#ListFiles) |\n| `sed`              | [`Replace`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Replace) / [`ReplaceRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.ReplaceRegexp) |\n| `sha256sum`        | [`Hash`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash) / [`HashSums`](https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums) |\n| `tail`             | [`Last`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Last) |\n| `tee`              | [`Tee`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee) |\n| `uniq -c`          | [`Freq`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Freq) |\n| `wc -l`            | [`CountLines`](https://pkg.go.dev/github.com/bitfield/script#Pipe.CountLines) |\n| `xargs`            | [`ExecForEach`](https://pkg.go.dev/github.com/bitfield/script#Pipe.ExecForEach) |\n\n# Some examples\n\nLet's see some simple examples. Suppose you want to read the contents of a file as a string:\n\n```go\ncontents, err := script.File(\"test.txt\").String()\n```\n\nThat looks straightforward enough, but suppose you now want to count the lines in that file.\n\n```go\nnumLines, err := script.File(\"test.txt\").CountLines()\n```\n\nFor something a bit more challenging, let's try counting the number of lines in the file that match the string `Error`:\n\n```go\nnumErrors, err := script.File(\"test.txt\").Match(\"Error\").CountLines()\n```\n\nBut what if, instead of reading a specific file, we want to simply pipe input into this program, and have it output only matching lines (like `grep`)?\n\n```go\nscript.Stdin().Match(\"Error\").Stdout()\n```\n\nJust for fun, let's filter all the results through some arbitrary Go function:\n\n```go\nscript.Stdin().Match(\"Error\").FilterLine(strings.ToUpper).Stdout()\n```\n\nThat was almost too easy! So let's pass in a list of files on the command line, and have our program read them all in sequence and output the matching lines:\n\n```go\nscript.Args().Concat().Match(\"Error\").Stdout()\n```\n\nMaybe we're only interested in the first 10 matches. No problem:\n\n```go\nscript.Args().Concat().Match(\"Error\").First(10).Stdout()\n```\n\nWhat's that? You want to append that output to a file instead of printing it to the terminal? *You've got some attitude, mister*. But okay:\n\n```go\nscript.Args().Concat().Match(\"Error\").First(10).AppendFile(\"/var/log/errors.txt\")\n```\n\nAnd if we'd like to send the output to the terminal *as well as* to the file, we can do that:\n\n```go\nscript.Echo(\"data\").Tee().AppendFile(\"data.txt\")\n```\n\nWe're not limited to getting data only from files or standard input. We can get it from HTTP requests too:\n\n```go\nscript.Get(\"https://wttr.in/London?format=3\").Stdout()\n// Output:\n// London: 🌦   +13°C\n```\n\nThat's great for simple GET requests, but suppose we want to *send* some data in the body of a POST request, for example. Here's how that works:\n\n```go\nscript.Echo(data).Post(URL).Stdout()\n```\n\nIf we need to customise the HTTP behaviour in some way, such as using our own HTTP client, we can do that:\n\n```go\nscript.NewPipe().WithHTTPClient(&http.Client{\n\tTimeout: 10 * time.Second,\n}).Get(\"https://example.com\").Stdout()\n```\n\nOr maybe we need to set some custom header on the request. No problem. We can just create the request in the usual way, and set it up however we want. Then we pass it to `Do`, which will actually perform the request:\n\n```go\nreq, err := http.NewRequest(http.MethodGet, \"http://example.com\", nil)\nreq.Header.Add(\"Authorization\", \"Bearer \"+token)\nscript.Do(req).Stdout()\n```\n\nThe HTTP server could return some non-okay response, though; for example, “404 Not Found”. So what happens then?\n\nIn general, when any pipe stage (such as `Do`) encounters an error, it produces no output to subsequent stages. And `script` treats HTTP response status codes outside the range 200-299 as errors. So the answer for the previous example is that we just won't *see* any output from this program if the server returns an error response.\n\nInstead, the pipe “remembers” any error that occurs, and we can retrieve it later by calling its `Error` method, or by using a *sink* method such as `String`, which returns an `error` value along with the result.\n\n`Stdout` also returns an error, plus the number of bytes successfully written (which we don't care about for this particular case). So we can check that error, which is always a good idea in Go:\n\n```go\n_, err := script.Do(req).Stdout()\nif err != nil {\n\tlog.Fatal(err)\n}\n```\n\nIf, as is common, the data we get from an HTTP request is in JSON format, we can use [JQ](https://stedolan.github.io/jq/) queries to interrogate it:\n\n```go\ndata, err := script.Do(req).JQ(\".[0] | {message: .commit.message, name: .commit.committer.name}\").String()\n```\n\nWe can also run external programs and get their output:\n\n```go\nscript.Exec(\"ping 127.0.0.1\").Stdout()\n```\n\nNote that `Exec` runs the command concurrently: it doesn't wait for the command to complete before returning any output. That's good, because this `ping` command will run forever (or until we get bored).\n\nInstead, when we read from the pipe using `Stdout`, we see each line of output as it's produced:\n\n```\nPING 127.0.0.1 (127.0.0.1): 56 data bytes\n64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.056 ms\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.054 ms\n...\n```\n\nIn the `ping` example, we knew the exact arguments we wanted to send the command, and we just needed to run it once. But what if we don't know the arguments yet? We might get them from the user, for example.\n\nWe might like to be able to run the external command repeatedly, each time passing it the next line of data from the pipe as an argument. No worries:\n\n```go\nscript.Args().ExecForEach(\"ping -c 1 {{.}}\").Stdout()\n```\n\nThat `{{.}}` is standard Go template syntax; it'll substitute each line of data from the pipe into the command line before it's executed. You can write as fancy a Go template expression as you want here (but this simple example probably covers most use cases).\n\nIf there isn't a built-in operation that does what we want, we can just write our own, using `Filter`:\n\n```go\nscript.Echo(\"hello world\").Filter(func (r io.Reader, w io.Writer) error {\n\tn, err := io.Copy(w, r)\n\tfmt.Fprintf(w, \"\\nfiltered %d bytes\\n\", n)\n\treturn err\n}).Stdout()\n// Output:\n// hello world\n// filtered 11 bytes\n```\n\nThe `func` we supply to `Filter` takes just two parameters: a reader to read from, and a writer to write to. The reader reads the previous stages of the pipe, as you might expect, and anything written to the writer goes to the *next* stage of the pipe.\n\nIf our `func` returns some error, then, just as with the `Do` example, the pipe's error status is set, and subsequent stages become a no-op.\n\nFilters run concurrently, so the pipeline can start producing output before the input has been fully read, as it did in the `ping` example. In fact, most built-in pipe methods, including `Exec`, are implemented *using* `Filter`.\n\nIf we want to scan input line by line, we could do that with a `Filter` function that creates a `bufio.Scanner` on its input, but we don't need to:\n\n```go\nscript.Echo(\"a\\nb\\nc\").FilterScan(func(line string, w io.Writer) {\n\tfmt.Fprintf(w, \"scanned line: %q\\n\", line)\n}).Stdout()\n// Output:\n// scanned line: \"a\"\n// scanned line: \"b\"\n// scanned line: \"c\"\n```\n\nAnd there's more. Much more. [Read the docs](https://pkg.go.dev/github.com/bitfield/script) for full details, and more examples.\n\n# A realistic use case\n\nLet's use `script` to write a program that system administrators might actually need. One thing I often find myself doing is counting the most frequent visitors to a website over a given period of time. Given an Apache log in the Common Log Format like this:\n\n```\n212.205.21.11 - - [30/Jun/2019:17:06:15 +0000] \"GET / HTTP/1.1\" 200 2028 \"https://example.com/ \"Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX1 Build/HUAWEIFIG-LX1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.156 Mobile Safari/537.36\"\n```\n\nwe would like to extract the visitor's IP address (the first column in the logfile), and count the number of times this IP address occurs in the file. Finally, we might like to list the top 10 visitors by frequency. In a shell script we might do something like:\n\n```sh\ncut -d' ' -f 1 access.log |sort |uniq -c |sort -rn |head\n```\n\nThere's a lot going on there, and it's pleasing to find that the equivalent `script` program is quite brief:\n\n```go\npackage main\n\nimport (\n\t\"github.com/bitfield/script\"\n)\n\nfunc main() {\n\tscript.Stdin().Column(1).Freq().First(10).Stdout()\n}\n```\n\nLet's try it out with some [sample data](testdata/access.log):\n\n```\n16 176.182.2.191\n 7 212.205.21.11\n 1 190.253.121.1\n 1 90.53.111.17\n```\n\n# Documentation\n\nSee [pkg.go.dev](https://pkg.go.dev/github.com/bitfield/script) for the full documentation, or read on for a summary.\n\n## Sources\n\nThese are functions that create a pipe with a given contents:\n\n| Source | Contents |\n| -------- | ------------- |\n| [`Args`](https://pkg.go.dev/github.com/bitfield/script#Args) | command-line arguments |\n| [`Do`](https://pkg.go.dev/github.com/bitfield/script#Do) | HTTP response |\n| [`Echo`](https://pkg.go.dev/github.com/bitfield/script#Echo) | a string |\n| [`Exec`](https://pkg.go.dev/github.com/bitfield/script#Exec) | command output |\n| [`File`](https://pkg.go.dev/github.com/bitfield/script#File) | file contents |\n| [`FindFiles`](https://pkg.go.dev/github.com/bitfield/script#FindFiles) | recursive file listing |\n| [`Get`](https://pkg.go.dev/github.com/bitfield/script#Get) | HTTP response |\n| [`IfExists`](https://pkg.go.dev/github.com/bitfield/script#IfExists) | do something only if some file exists |\n| [`ListFiles`](https://pkg.go.dev/github.com/bitfield/script#ListFiles) | file listing (including wildcards) |\n| [`Post`](https://pkg.go.dev/github.com/bitfield/script#Post) | HTTP response |\n| [`Slice`](https://pkg.go.dev/github.com/bitfield/script#Slice) | slice elements, one per line |\n| [`Stdin`](https://pkg.go.dev/github.com/bitfield/script#Stdin) | standard input |\n\n## Modifiers\n\nThese are methods on a pipe that change its configuration:\n\n| Source | Modifies |\n| -------- | ------------- |\n| [`WithEnv`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithEnv) | environment for commands |\n| [`WithError`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithError) | pipe error status |\n| [`WithHTTPClient`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithHTTPClient) | client for HTTP requests |\n| [`WithReader`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithReader) | pipe source |\n| [`WithStderr`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStderr) | standard error output stream for command |\n| [`WithStdout`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStdout) | standard output stream for pipe |\n\n## Filters\n\nFilters are methods on an existing pipe that also return a pipe, allowing you to chain filters indefinitely. The filters modify each line of their input according to the following rules:\n\n| Filter | Results |\n| -------- | ------------- |\n| [`Basename`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Basename) | removes leading path components from each line, leaving only the filename |\n| [`Column`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Column) | Nth column of input |\n| [`Concat`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Concat) | contents of multiple files |\n| [`DecodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64) | input decoded from base64 |\n| [`Dirname`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Dirname) | removes filename from each line, leaving only leading path components |\n| [`Do`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Do) | response to supplied HTTP request |\n| [`Echo`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Echo) | all input replaced by given string |\n| [`EncodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64) | input encoded to base64 |\n| [`Exec`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Exec) | filtered through external command |\n| [`ExecForEach`](https://pkg.go.dev/github.com/bitfield/script#Pipe.ExecForEach) | execute given command template for each line of input |\n| [`Filter`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Filter) | user-supplied function filtering a reader to a writer |\n| [`FilterLine`](https://pkg.go.dev/github.com/bitfield/script#Pipe.FilterLine) | user-supplied function filtering each line to a string|\n| [`FilterScan`](https://pkg.go.dev/github.com/bitfield/script#Pipe.FilterScan) | user-supplied function filtering each line to a writer |\n| [`First`](https://pkg.go.dev/github.com/bitfield/script#Pipe.First) | first N lines of input |\n| [`Freq`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Freq) | frequency count of unique input lines, most frequent first |\n| [`Get`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Get) | response to HTTP GET on supplied URL |\n| [`HashSums`](https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums) | hashes of each listed file |\n| [`Join`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Join) | replace all newlines with spaces |\n| [`JQ`](https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ) | result of `jq` query |\n| [`Last`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Last) | last N lines of input|\n| [`Match`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Match) | lines matching given string |\n| [`MatchRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.MatchRegexp) | lines matching given regexp |\n| [`Post`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Post) | response to HTTP POST on supplied URL |\n| [`Reject`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Reject) | lines not matching given string |\n| [`RejectRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.RejectRegexp) | lines not matching given regexp |\n| [`Replace`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Replace) | matching text replaced with given string |\n| [`ReplaceRegexp`](https://pkg.go.dev/github.com/bitfield/script#Pipe.ReplaceRegexp) | matching text replaced with given string |\n| [`Tee`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee) | input copied to supplied writers |\n\nNote that filters run concurrently, rather than producing nothing until each stage has fully read its input. This is convenient for executing long-running commands, for example. If you do need to wait for the pipeline to complete, call [`Wait`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait).\n\n## Sinks\n\nSinks are methods that return some data from a pipe, ending the pipeline and extracting its full contents in a specified way:\n\n| Sink | Destination | Results |\n| ---- | ----------- | ------- |\n| [`AppendFile`](https://pkg.go.dev/github.com/bitfield/script#Pipe.AppendFile) | appended to file, creating if it doesn't exist | bytes written, error |\n| [`Bytes`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Bytes) | | data as `[]byte`, error\n| [`Hash`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash) | | hash, error  |\n| [`CountLines`](https://pkg.go.dev/github.com/bitfield/script#Pipe.CountLines) | |number of lines, error  |\n| [`Read`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Read) | given `[]byte` | bytes read, error  |\n| [`Slice`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Slice) | | data as `[]string`, error  |\n| [`Stdout`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Stdout) | standard output | bytes written, error  |\n| [`String`](https://pkg.go.dev/github.com/bitfield/script#Pipe.String) | | data as `string`, error  |\n| [`Wait`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait) | | error  |\n| [`WriteFile`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WriteFile) | specified file, truncating if it exists | bytes written, error  |\n\n# What's new\n\n| Version | New |\n| ----------- | ------- |\n| 0.24.0  | [`Hash`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash) |\n|         | [`HashSums`](https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums) |\n| 0.23.0  | [`WithEnv`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithEnv) |\n|         | [`DecodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64) / [`EncodeBase64`](https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64) |\n|         | [`Wait`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait) returns error |\n| v0.22.0 | [`Tee`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee), [`WithStderr`](https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStderr) |\n| v0.21.0 | HTTP support: [`Do`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Do), [`Get`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Get), [`Post`](https://pkg.go.dev/github.com/bitfield/script#Pipe.Post) |\n| v0.20.0 | [`JQ`](https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ) |\n\n# Contributing\n\nSee the [contributor's guide](CONTRIBUTING.md) for some helpful tips if you'd like to contribute to the `script` project.\n\n# Links\n\n- [Scripting with Go](https://bitfieldconsulting.com/posts/scripting)\n- [Code Club: Script](https://www.youtube.com/watch?v=6S5EqzVwpEg)\n- [Bitfield Consulting](https://bitfieldconsulting.com/)\n- [Go books by John Arundel](https://bitfieldconsulting.com/books)\n\n<small>Gopher image by [MariaLetta](https://github.com/MariaLetta/free-gophers-pack)</small>\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1943359375,
          "content": "// Package script aims to make it easy to write shell-type scripts in Go, for\n// general system administration purposes: reading files, counting lines,\n// matching strings, and so on.\npackage script\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3203125,
          "content": "module github.com/bitfield/script\n\ngo 1.18\n\nrequire (\n\tgithub.com/google/go-cmp v0.5.9\n\tgithub.com/itchyny/gojq v0.12.13\n\tgithub.com/rogpeppe/go-internal v1.11.0\n\tmvdan.cc/sh/v3 v3.7.0\n)\n\nrequire (\n\tgithub.com/itchyny/timefmt-go v0.1.5 // indirect\n\tgolang.org/x/sys v0.10.0 // indirect\n\tgolang.org/x/tools v0.11.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.927734375,
          "content": "github.com/frankban/quicktest v1.14.4 h1:g2rn0vABPOOXmZUj+vbmUp0lPoXEMuhTpIluN0XL9UY=\ngithub.com/frankban/quicktest v1.14.5 h1:dfYrrRyLtiqT9GyKXgdh+k4inNeTvmGbuSgZ3lx3GhA=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/itchyny/gojq v0.12.12 h1:x+xGI9BXqKoJQZkr95ibpe3cdrTbY8D9lonrK433rcA=\ngithub.com/itchyny/gojq v0.12.12/go.mod h1:j+3sVkjxwd7A7Z5jrbKibgOLn0ZfLWkV+Awxr/pyzJE=\ngithub.com/itchyny/gojq v0.12.13 h1:IxyYlHYIlspQHHTE0f3cJF0NKDMfajxViuhBLnHd/QU=\ngithub.com/itchyny/gojq v0.12.13/go.mod h1:JzwzAqenfhrPUuwbmEz3nu3JQmFLlQTQMUcOdnu/Sf4=\ngithub.com/itchyny/timefmt-go v0.1.5 h1:G0INE2la8S6ru/ZI5JecgyzbbJNs5lG1RcBqa7Jm6GE=\ngithub.com/itchyny/timefmt-go v0.1.5/go.mod h1:nEP7L+2YmAbT2kZ2HfSs1d8Xtw9LY8D2stDBckWakZ8=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=\ngithub.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=\ngolang.org/x/sys v0.10.0 h1:SqMFp9UcQJZa+pmYuAKjd9xq1f0j5rLcDIk0mj4qAsA=\ngolang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/tools v0.11.0 h1:EMCa6U9S2LtZXLAMoWiR/R8dAQFRqbAitmbJ2UKhoi8=\ngolang.org/x/tools v0.11.0/go.mod h1:anzJrxPjNtfgiYQYirP2CPGzGLxrH2u2QBhn6Bf3qY8=\nmvdan.cc/sh/v3 v3.6.0 h1:gtva4EXJ0dFNvl5bHjcUEvws+KRcDslT8VKheTYkbGU=\nmvdan.cc/sh/v3 v3.6.0/go.mod h1:U4mhtBLZ32iWhif5/lD+ygy1zrgaQhUu+XFy7C8+TTA=\nmvdan.cc/sh/v3 v3.7.0 h1:lSTjdP/1xsddtaKfGg7Myu7DnlHItd3/M2tomOcNNBg=\nmvdan.cc/sh/v3 v3.7.0/go.mod h1:K2gwkaesF/D7av7Kxl0HbF5kGOd2ArupNTX3X44+8l8=\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "script.go",
          "type": "blob",
          "size": 30.1357421875,
          "content": "package script\n\nimport (\n\t\"bufio\"\n\t\"container/ring\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"io/fs\"\n\t\"math\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\n\t\"github.com/itchyny/gojq\"\n\t\"mvdan.cc/sh/v3/shell\"\n)\n\n// Pipe represents a pipe object with an associated [ReadAutoCloser].\ntype Pipe struct {\n\t// Reader is the underlying reader.\n\tReader     ReadAutoCloser\n\tstdout     io.Writer\n\thttpClient *http.Client\n\n\tmu     *sync.Mutex\n\terr    error\n\tstderr io.Writer\n\tenv    []string\n}\n\n// Args creates a pipe containing the program's command-line arguments from\n// [os.Args], excluding the program name, one per line.\nfunc Args() *Pipe {\n\treturn Slice(os.Args[1:])\n}\n\n// Do creates a pipe that makes the HTTP request req and produces the response.\n// See [Pipe.Do] for how the HTTP response status is interpreted.\nfunc Do(req *http.Request) *Pipe {\n\treturn NewPipe().Do(req)\n}\n\n// Echo creates a pipe containing the string s.\nfunc Echo(s string) *Pipe {\n\treturn NewPipe().WithReader(strings.NewReader(s))\n}\n\n// Exec creates a pipe that runs cmdLine as an external command and produces\n// its combined output (interleaving standard output and standard error). See\n// [Pipe.Exec] for error handling details.\n//\n// Use [Pipe.Exec] to send the contents of an existing pipe to the command's\n// standard input.\nfunc Exec(cmdLine string) *Pipe {\n\treturn NewPipe().Exec(cmdLine)\n}\n\n// File creates a pipe that reads from the file path.\nfunc File(path string) *Pipe {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn NewPipe().WithError(err)\n\t}\n\treturn NewPipe().WithReader(f)\n}\n\n// FindFiles creates a pipe listing all the files in the directory dir and its\n// subdirectories recursively, one per line, like Unix find(1).\n// Errors are ignored unless no files are found (in which case the pipe's error\n// status will be set to the last error encountered).\n//\n// Each line of the output consists of a slash-separated path, starting with\n// the initial directory. For example, if the directory looks like this:\n//\n//\ttest/\n//\t        1.txt\n//\t        2.txt\n//\n// the pipe's output will be:\n//\n//\ttest/1.txt\n//\ttest/2.txt\nfunc FindFiles(dir string) *Pipe {\n\tvar paths []string\n\tvar innerErr error\n\tfs.WalkDir(os.DirFS(dir), \".\", func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\tinnerErr = err\n\t\t\treturn fs.SkipDir\n\t\t}\n\t\tif !d.IsDir() {\n\t\t\tpaths = append(paths, filepath.Join(dir, path))\n\t\t}\n\t\treturn nil\n\t})\n\tif innerErr != nil && len(paths) == 0 {\n\t\treturn NewPipe().WithError(innerErr)\n\t}\n\treturn Slice(paths)\n}\n\n// Get creates a pipe that makes an HTTP GET request to url, and produces the\n// response. See [Pipe.Do] for how the HTTP response status is interpreted.\nfunc Get(url string) *Pipe {\n\treturn NewPipe().Get(url)\n}\n\n// IfExists tests whether path exists, and creates a pipe whose error status\n// reflects the result. If the file doesn't exist, the pipe's error status will\n// be set, and if the file does exist, the pipe will have no error status. This\n// can be used to do some operation only if a given file exists:\n//\n//\tIfExists(\"/foo/bar\").Exec(\"/usr/bin/something\")\nfunc IfExists(path string) *Pipe {\n\t_, err := os.Stat(path)\n\tif err != nil {\n\t\treturn NewPipe().WithError(err)\n\t}\n\treturn NewPipe()\n}\n\n// ListFiles creates a pipe containing the files or directories specified by\n// path, one per line. path can be a glob expression, as for [filepath.Match].\n// For example:\n//\n//\tListFiles(\"/data/*\").Stdout()\n//\n// ListFiles does not recurse into subdirectories; use [FindFiles] instead.\nfunc ListFiles(path string) *Pipe {\n\tif strings.ContainsAny(path, \"[]^*?\\\\{}!\") {\n\t\tfileNames, err := filepath.Glob(path)\n\t\tif err != nil {\n\t\t\treturn NewPipe().WithError(err)\n\t\t}\n\t\treturn Slice(fileNames)\n\t}\n\tentries, err := os.ReadDir(path)\n\tif err != nil {\n\t\t// Check for the case where the path matches exactly one file\n\t\ts, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn NewPipe().WithError(err)\n\t\t}\n\t\tif !s.IsDir() {\n\t\t\treturn Echo(path)\n\t\t}\n\t\treturn NewPipe().WithError(err)\n\t}\n\tmatches := make([]string, len(entries))\n\tfor i, e := range entries {\n\t\tmatches[i] = filepath.Join(path, e.Name())\n\t}\n\treturn Slice(matches)\n}\n\n// NewPipe creates a new pipe with an empty reader (use [Pipe.WithReader] to\n// attach another reader to it).\nfunc NewPipe() *Pipe {\n\treturn &Pipe{\n\t\tReader:     ReadAutoCloser{},\n\t\tmu:         new(sync.Mutex),\n\t\tstdout:     os.Stdout,\n\t\thttpClient: http.DefaultClient,\n\t\tenv:        nil,\n\t}\n}\n\n// Post creates a pipe that makes an HTTP POST request to url, with an empty\n// body, and produces the response. See [Pipe.Do] for how the HTTP response\n// status is interpreted.\nfunc Post(url string) *Pipe {\n\treturn NewPipe().Post(url)\n}\n\n// Slice creates a pipe containing each element of s, one per line. If s is\n// empty or nil, then the pipe is empty.\nfunc Slice(s []string) *Pipe {\n\tif len(s) == 0 {\n\t\treturn NewPipe()\n\t}\n\treturn Echo(strings.Join(s, \"\\n\") + \"\\n\")\n}\n\n// Stdin creates a pipe that reads from [os.Stdin].\nfunc Stdin() *Pipe {\n\treturn NewPipe().WithReader(os.Stdin)\n}\n\n// AppendFile appends the contents of the pipe to the file path, creating it if\n// necessary, and returns the number of bytes successfully written, or an\n// error.\nfunc (p *Pipe) AppendFile(path string) (int64, error) {\n\treturn p.writeOrAppendFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY)\n}\n\n// Basename reads paths from the pipe, one per line, and removes any leading\n// directory components from each. So, for example, /usr/local/bin/foo would\n// become just foo. This is the complementary operation to [Pipe.Dirname].\n//\n// If any line is empty, Basename will transform it to a single dot. Trailing\n// slashes are removed. The behaviour of Basename is the same as\n// [filepath.Base] (not by coincidence).\nfunc (p *Pipe) Basename() *Pipe {\n\treturn p.FilterLine(filepath.Base)\n}\n\n// Bytes returns the contents of the pipe as a []byte, or an error.\nfunc (p *Pipe) Bytes() ([]byte, error) {\n\tif p.Error() != nil {\n\t\treturn nil, p.Error()\n\t}\n\tdata, err := io.ReadAll(p)\n\tif err != nil {\n\t\tp.SetError(err)\n\t}\n\treturn data, p.Error()\n}\n\n// Close closes the pipe's associated reader. This is a no-op if the reader is\n// not an [io.Closer].\nfunc (p *Pipe) Close() error {\n\treturn p.Reader.Close()\n}\n\n// Column produces column col of each line of input, where the first column is\n// column 1, and columns are delimited by Unicode whitespace. Lines containing\n// fewer than col columns will be skipped.\nfunc (p *Pipe) Column(col int) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tcolumns := strings.Fields(line)\n\t\tif col > 0 && col <= len(columns) {\n\t\t\tfmt.Fprintln(w, columns[col-1])\n\t\t}\n\t})\n}\n\n// Concat reads paths from the pipe, one per line, and produces the contents of\n// all the corresponding files in sequence. If there are any errors (for\n// example, non-existent files), these will be ignored, execution will\n// continue, and the pipe's error status will not be set.\n//\n// This makes it convenient to write programs that take a list of paths on the\n// command line. For example:\n//\n//\tscript.Args().Concat().Stdout()\n//\n// The list of paths could also come from a file:\n//\n//\tscript.File(\"filelist.txt\").Concat()\n//\n// Or from the output of a command:\n//\n//\tscript.Exec(\"ls /var/app/config/\").Concat().Stdout()\n//\n// Each input file will be closed once it has been fully read. If any of the\n// files can't be opened or read, Concat will simply skip these and carry on,\n// without setting the pipe's error status. This mimics the behaviour of Unix\n// cat(1).\nfunc (p *Pipe) Concat() *Pipe {\n\tvar readers []io.Reader\n\tp.FilterScan(func(line string, w io.Writer) {\n\t\tinput, err := os.Open(line)\n\t\tif err == nil {\n\t\t\treaders = append(readers, NewReadAutoCloser(input))\n\t\t}\n\t}).Wait()\n\treturn p.WithReader(io.MultiReader(readers...))\n}\n\n// CountLines returns the number of lines of input, or an error.\nfunc (p *Pipe) CountLines() (lines int, err error) {\n\tp.FilterScan(func(line string, w io.Writer) {\n\t\tlines++\n\t}).Wait()\n\treturn lines, p.Error()\n}\n\n// DecodeBase64 produces the string represented by the base64 encoded input.\nfunc (p *Pipe) DecodeBase64() *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tdecoder := base64.NewDecoder(base64.StdEncoding, r)\n\t\t_, err := io.Copy(w, decoder)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Dirname reads paths from the pipe, one per line, and produces only the\n// parent directories of each path. For example, /usr/local/bin/foo would\n// become just /usr/local/bin. This is the complementary operation to\n// [Pipe.Basename].\n//\n// If a line is empty, Dirname will transform it to a single dot. Trailing\n// slashes are removed, unless Dirname returns the root folder. Otherwise, the\n// behaviour of Dirname is the same as [filepath.Dir] (not by coincidence).\nfunc (p *Pipe) Dirname() *Pipe {\n\treturn p.FilterLine(func(line string) string {\n\t\t// filepath.Dir() does not handle trailing slashes correctly\n\t\tif len(line) > 1 && strings.HasSuffix(line, \"/\") {\n\t\t\tline = line[:len(line)-1]\n\t\t}\n\t\tdirname := filepath.Dir(line)\n\t\t// filepath.Dir() does not preserve a leading './'\n\t\tif strings.HasPrefix(line, \"./\") {\n\t\t\treturn \"./\" + dirname\n\t\t}\n\t\treturn dirname\n\t})\n}\n\n// Do performs the HTTP request req using the pipe's configured HTTP client, as\n// set by [Pipe.WithHTTPClient], or [http.DefaultClient] otherwise. The\n// response body is streamed concurrently to the pipe's output. If the response\n// status is anything other than HTTP 200-299, the pipe's error status is set.\nfunc (p *Pipe) Do(req *http.Request) *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tresp, err := p.httpClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\t_, err = io.Copy(w, resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Any HTTP 2xx status code is considered okay\n\t\tif resp.StatusCode/100 != 2 {\n\t\t\treturn fmt.Errorf(\"unexpected HTTP response status: %s\", resp.Status)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EachLine calls the function process on each line of input, passing it the\n// line as a string, and a [*strings.Builder] to write its output to.\n//\n// Deprecated: use [Pipe.FilterLine] or [Pipe.FilterScan] instead, which run\n// concurrently and don't do unnecessary reads on the input.\nfunc (p *Pipe) EachLine(process func(string, *strings.Builder)) *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\toutput := new(strings.Builder)\n\t\tfor scanner.Scan() {\n\t\t\tprocess(scanner.Text(), output)\n\t\t}\n\t\tfmt.Fprint(w, output.String())\n\t\treturn scanner.Err()\n\t})\n}\n\n// Echo sets the pipe's reader to one that produces the string s, detaching any\n// existing reader without draining or closing it.\nfunc (p *Pipe) Echo(s string) *Pipe {\n\tif p.Error() != nil {\n\t\treturn p\n\t}\n\treturn p.WithReader(strings.NewReader(s))\n}\n\n// EncodeBase64 produces the base64 encoding of the input.\nfunc (p *Pipe) EncodeBase64() *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tencoder := base64.NewEncoder(base64.StdEncoding, w)\n\t\tdefer encoder.Close()\n\t\t_, err := io.Copy(encoder, r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (p *Pipe) environment() []string {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\treturn p.env\n}\n\n// Error returns any error present on the pipe, or nil otherwise.\n// Error is not a sink and does not wait until the pipe reaches\n// completion. To wait for completion before returning the error,\n// see [Pipe.Wait].\nfunc (p *Pipe) Error() error {\n\tif p.mu == nil { // uninitialised pipe\n\t\treturn nil\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\treturn p.err\n}\n\n// Exec runs cmdLine as an external command, sending it the contents of the\n// pipe as input, and produces the command's standard output (see below for\n// error output). The effect of this is to filter the contents of the pipe\n// through the external command.\n//\n// # Environment\n//\n// The command inherits the current process's environment, optionally modified\n// by [Pipe.WithEnv].\n//\n// # Error handling\n//\n// If the command had a non-zero exit status, the pipe's error status will also\n// be set to the string “exit status X”, where X is the integer exit status.\n// Even in the event of a non-zero exit status, the command's output will still\n// be available in the pipe. This is often helpful for debugging. However,\n// because [Pipe.String] is a no-op if the pipe's error status is set, if you\n// want output you will need to reset the error status before calling\n// [Pipe.String].\n//\n// If the command writes to its standard error stream, this will also go to the\n// pipe, along with its standard output. However, the standard error text can\n// instead be redirected to a supplied writer, using [Pipe.WithStderr].\nfunc (p *Pipe) Exec(cmdLine string) *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\targs, err := shell.Fields(cmdLine, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd := exec.Command(args[0], args[1:]...)\n\t\tcmd.Stdin = r\n\t\tcmd.Stdout = w\n\t\tcmd.Stderr = w\n\t\tpipeStderr := p.stdErr()\n\t\tif pipeStderr != nil {\n\t\t\tcmd.Stderr = pipeStderr\n\t\t}\n\t\tpipeEnv := p.environment()\n\t\tif pipeEnv != nil {\n\t\t\tcmd.Env = pipeEnv\n\t\t}\n\t\terr = cmd.Start()\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(cmd.Stderr, err)\n\t\t\treturn err\n\t\t}\n\t\treturn cmd.Wait()\n\t})\n}\n\n// ExecForEach renders cmdLine as a Go template for each line of input, running\n// the resulting command, and produces the combined output of all these\n// commands in sequence. See [Pipe.Exec] for details on error handling and\n// environment variables.\n//\n// This is mostly useful for substituting data into commands using Go template\n// syntax. For example:\n//\n//\tListFiles(\"*\").ExecForEach(\"touch {{.}}\").Wait()\nfunc (p *Pipe) ExecForEach(cmdLine string) *Pipe {\n\ttpl, err := template.New(\"\").Parse(cmdLine)\n\tif err != nil {\n\t\treturn p.WithError(err)\n\t}\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tfor scanner.Scan() {\n\t\t\tcmdLine := new(strings.Builder)\n\t\t\terr := tpl.Execute(cmdLine, scanner.Text())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\targs, err := shell.Fields(cmdLine.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmd := exec.Command(args[0], args[1:]...)\n\t\t\tcmd.Stdout = w\n\t\t\tcmd.Stderr = w\n\t\t\tpipeStderr := p.stdErr()\n\t\t\tif pipeStderr != nil {\n\t\t\t\tcmd.Stderr = pipeStderr\n\t\t\t}\n\t\t\tif p.env != nil {\n\t\t\t\tcmd.Env = p.env\n\t\t\t}\n\t\t\terr = cmd.Start()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintln(cmd.Stderr, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = cmd.Wait()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintln(cmd.Stderr, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\treturn scanner.Err()\n\t})\n}\n\nvar exitStatusPattern = regexp.MustCompile(`exit status (\\d+)$`)\n\n// ExitStatus returns the integer exit status of a previous command (for\n// example run by [Pipe.Exec]). This will be zero unless the pipe's error\n// status is set and the error matches the pattern “exit status %d”.\nfunc (p *Pipe) ExitStatus() int {\n\tif p.Error() == nil {\n\t\treturn 0\n\t}\n\tmatch := exitStatusPattern.FindStringSubmatch(p.Error().Error())\n\tif len(match) < 2 {\n\t\treturn 0\n\t}\n\tstatus, err := strconv.Atoi(match[1])\n\tif err != nil {\n\t\t// This seems unlikely, but...\n\t\treturn 0\n\t}\n\treturn status\n}\n\n// Filter sends the contents of the pipe to the function filter and produces\n// the result. filter takes an [io.Reader] to read its input from and an\n// [io.Writer] to write its output to, and returns an error, which will be set\n// on the pipe.\n//\n// filter runs concurrently, so its goroutine will not exit until the pipe has\n// been fully read. Use [Pipe.Wait] to wait for all concurrent filters to\n// complete.\nfunc (p *Pipe) Filter(filter func(io.Reader, io.Writer) error) *Pipe {\n\tif p.Error() != nil {\n\t\treturn p\n\t}\n\tpr, pw := io.Pipe()\n\torigReader := p.Reader\n\tp = p.WithReader(pr)\n\tgo func() {\n\t\tdefer pw.Close()\n\t\terr := filter(origReader, pw)\n\t\tif err != nil {\n\t\t\tp.SetError(err)\n\t\t}\n\t}()\n\treturn p\n}\n\n// FilterLine sends the contents of the pipe to the function filter, a line at\n// a time, and produces the result. filter takes each line as a string and\n// returns a string as its output. See [Pipe.Filter] for concurrency handling.\nfunc (p *Pipe) FilterLine(filter func(string) string) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tfmt.Fprintln(w, filter(line))\n\t})\n}\n\n// FilterScan sends the contents of the pipe to the function filter, a line at\n// a time, and produces the result. filter takes each line as a string and an\n// [io.Writer] to write its output to. See [Pipe.Filter] for concurrency\n// handling.\nfunc (p *Pipe) FilterScan(filter func(string, io.Writer)) *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tfor scanner.Scan() {\n\t\t\tfilter(scanner.Text(), w)\n\t\t}\n\t\treturn scanner.Err()\n\t})\n}\n\n// First produces only the first n lines of the pipe's contents, or all the\n// lines if there are less than n. If n is zero or negative, there is no output\n// at all. When n lines have been produced, First stops reading its input and\n// sends EOF to its output.\nfunc (p *Pipe) First(n int) *Pipe {\n\tif p.Error() != nil {\n\t\treturn p\n\t}\n\tif n <= 0 {\n\t\treturn NewPipe()\n\t}\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tfor i := 0; i < n && scanner.Scan(); i++ {\n\t\t\t_, err := fmt.Fprintln(w, scanner.Text())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn scanner.Err()\n\t})\n}\n\n// Freq produces only the unique lines from the pipe's contents, each prefixed\n// with a frequency count, in descending numerical order (most frequent lines\n// first). Lines with equal frequency will be sorted alphabetically.\n//\n// For example, we could take a common shell pipeline like this:\n//\n//\tsort input.txt |uniq -c |sort -rn\n//\n// and replace it with:\n//\n//\tFile(\"input.txt\").Freq().Stdout()\n//\n// Or to get only the ten most common lines:\n//\n//\tFile(\"input.txt\").Freq().First(10).Stdout()\n//\n// Like Unix uniq(1), Freq right-justifies its count values in a column for\n// readability, padding with spaces if necessary.\nfunc (p *Pipe) Freq() *Pipe {\n\tfreq := map[string]int{}\n\ttype frequency struct {\n\t\tline  string\n\t\tcount int\n\t}\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tfor scanner.Scan() {\n\t\t\tfreq[scanner.Text()]++\n\t\t}\n\t\tfreqs := make([]frequency, 0, len(freq))\n\t\tmax := 0\n\t\tfor line, count := range freq {\n\t\t\tfreqs = append(freqs, frequency{line, count})\n\t\t\tif count > max {\n\t\t\t\tmax = count\n\t\t\t}\n\t\t}\n\t\tsort.Slice(freqs, func(i, j int) bool {\n\t\t\tx, y := freqs[i].count, freqs[j].count\n\t\t\tif x == y {\n\t\t\t\treturn freqs[i].line < freqs[j].line\n\t\t\t}\n\t\t\treturn x > y\n\t\t})\n\t\tfieldWidth := len(strconv.Itoa(max))\n\t\tfor _, item := range freqs {\n\t\t\tfmt.Fprintf(w, \"%*d %s\\n\", fieldWidth, item.count, item.line)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Get makes an HTTP GET request to url, sending the contents of the pipe as\n// the request body, and produces the server's response. See [Pipe.Do] for how\n// the HTTP response status is interpreted.\nfunc (p *Pipe) Get(url string) *Pipe {\n\treq, err := http.NewRequest(http.MethodGet, url, p.Reader)\n\tif err != nil {\n\t\treturn p.WithError(err)\n\t}\n\treturn p.Do(req)\n}\n\n// Hash returns the hex-encoded hash of the entire contents of the\n// pipe based on the provided hasher, or an error.\n// To perform hashing on files, see [Pipe.HashSums].\nfunc (p *Pipe) Hash(hasher hash.Hash) (string, error) {\n\tif p.Error() != nil {\n\t\treturn \"\", p.Error()\n\t}\n\t_, err := io.Copy(hasher, p)\n\tif err != nil {\n\t\tp.SetError(err)\n\t\treturn \"\", err\n\t}\n\treturn hex.EncodeToString(hasher.Sum(nil)), nil\n}\n\n// HashSums reads paths from the pipe, one per line, and produces the\n// hex-encoded hash of each corresponding file based on the provided hasher,\n// one per line. Any files that cannot be opened or read will be ignored.\n// To perform hashing on the contents of the pipe, see [Pipe.Hash].\nfunc (p *Pipe) HashSums(hasher hash.Hash) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tf, err := os.Open(line)\n\t\tif err != nil {\n\t\t\treturn // skip unopenable files\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(hasher, f)\n\t\tif err != nil {\n\t\t\treturn // skip unreadable files\n\t\t}\n\t\tfmt.Fprintln(w, hex.EncodeToString(hasher.Sum(nil)))\n\t})\n}\n\n// Join joins all the lines in the pipe's contents into a single\n// space-separated string, which will always end with a newline.\nfunc (p *Pipe) Join() *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tfirst := true\n\t\tfor scanner.Scan() {\n\t\t\tif !first {\n\t\t\t\tfmt.Fprint(w, \" \")\n\t\t\t}\n\t\t\tline := scanner.Text()\n\t\t\tfmt.Fprint(w, line)\n\t\t\tfirst = false\n\t\t}\n\t\tfmt.Fprintln(w)\n\t\treturn scanner.Err()\n\t})\n}\n\n// JQ executes query on the pipe's contents (presumed to be JSON), producing\n// the result. An invalid query will set the appropriate error on the pipe.\n//\n// The exact dialect of JQ supported is that provided by\n// [github.com/itchyny/gojq], whose documentation explains the differences\n// between it and standard JQ.\nfunc (p *Pipe) JQ(query string) *Pipe {\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tq, err := gojq.Parse(query)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar input interface{}\n\t\terr = json.NewDecoder(r).Decode(&input)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\titer := q.Run(input)\n\t\tfor {\n\t\t\tv, ok := iter.Next()\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err, ok := v.(error); ok {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresult, err := gojq.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfmt.Fprintln(w, string(result))\n\t\t}\n\t})\n}\n\n// Last produces only the last n lines of the pipe's contents, or all the lines\n// if there are less than n. If n is zero or negative, there is no output at\n// all.\nfunc (p *Pipe) Last(n int) *Pipe {\n\tif p.Error() != nil {\n\t\treturn p\n\t}\n\tif n <= 0 {\n\t\treturn NewPipe()\n\t}\n\treturn p.Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := newScanner(r)\n\t\tinput := ring.New(n)\n\t\tfor scanner.Scan() {\n\t\t\tinput.Value = scanner.Text()\n\t\t\tinput = input.Next()\n\t\t}\n\t\tinput.Do(func(p interface{}) {\n\t\t\tif p != nil {\n\t\t\t\tfmt.Fprintln(w, p)\n\t\t\t}\n\t\t})\n\t\treturn scanner.Err()\n\t})\n}\n\n// Match produces only the input lines that contain the string s.\nfunc (p *Pipe) Match(s string) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tif strings.Contains(line, s) {\n\t\t\tfmt.Fprintln(w, line)\n\t\t}\n\t})\n}\n\n// MatchRegexp produces only the input lines that match the compiled regexp re.\nfunc (p *Pipe) MatchRegexp(re *regexp.Regexp) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tif re.MatchString(line) {\n\t\t\tfmt.Fprintln(w, line)\n\t\t}\n\t})\n}\n\n// Post makes an HTTP POST request to url, using the contents of the pipe as\n// the request body, and produces the server's response. See [Pipe.Do] for how\n// the HTTP response status is interpreted.\nfunc (p *Pipe) Post(url string) *Pipe {\n\treq, err := http.NewRequest(http.MethodPost, url, p.Reader)\n\tif err != nil {\n\t\treturn p.WithError(err)\n\t}\n\treturn p.Do(req)\n}\n\n// Reject produces only lines that do not contain the string s.\nfunc (p *Pipe) Reject(s string) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tif !strings.Contains(line, s) {\n\t\t\tfmt.Fprintln(w, line)\n\t\t}\n\t})\n}\n\n// RejectRegexp produces only lines that don't match the compiled regexp re.\nfunc (p *Pipe) RejectRegexp(re *regexp.Regexp) *Pipe {\n\treturn p.FilterScan(func(line string, w io.Writer) {\n\t\tif !re.MatchString(line) {\n\t\t\tfmt.Fprintln(w, line)\n\t\t}\n\t})\n}\n\n// Replace replaces all occurrences of the string search with the string\n// replace.\nfunc (p *Pipe) Replace(search, replace string) *Pipe {\n\treturn p.FilterLine(func(line string) string {\n\t\treturn strings.ReplaceAll(line, search, replace)\n\t})\n}\n\n// ReplaceRegexp replaces all matches of the compiled regexp re with the string\n// replace. $x variables in the replace string are interpreted as by\n// [regexp#Regexp.Expand]; for example, $1 represents the text of the first submatch.\nfunc (p *Pipe) ReplaceRegexp(re *regexp.Regexp, replace string) *Pipe {\n\treturn p.FilterLine(func(line string) string {\n\t\treturn re.ReplaceAllString(line, replace)\n\t})\n}\n\n// Read reads up to len(b) bytes from the pipe into b. It returns the number of\n// bytes read and any error encountered. At end of file, or on a nil pipe, Read\n// returns 0, [io.EOF].\nfunc (p *Pipe) Read(b []byte) (int, error) {\n\tif p.Error() != nil {\n\t\treturn 0, p.Error()\n\t}\n\treturn p.Reader.Read(b)\n}\n\n// SetError sets the error err on the pipe.\nfunc (p *Pipe) SetError(err error) {\n\tif p.mu == nil { // uninitialised pipe\n\t\treturn\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.err = err\n}\n\n// SHA256Sum returns the hex-encoded SHA-256 hash of the entire contents of the\n// pipe, or an error.\n// Deprecated: SHA256Sum has been deprecated by [Pipe.Hash]. To get the SHA-256\n// hash for the contents of the pipe, call `Hash(sha256.new())`\nfunc (p *Pipe) SHA256Sum() (string, error) {\n\treturn p.Hash(sha256.New())\n}\n\n// SHA256Sums reads paths from the pipe, one per line, and produces the\n// hex-encoded SHA-256 hash of each corresponding file, one per line. Any files\n// that cannot be opened or read will be ignored.\n// Deprecated: SHA256Sums has been deprecated by [Pipe.HashSums]. To get the SHA-256\n// hash for each file path in the pipe, call `HashSums(sha256.new())`\nfunc (p *Pipe) SHA256Sums() *Pipe {\n\treturn p.HashSums(sha256.New())\n}\n\n// Slice returns the pipe's contents as a slice of strings, one element per\n// line, or an error.\n//\n// An empty pipe will produce an empty slice. A pipe containing a single empty\n// line (that is, a single \\n character) will produce a slice containing the\n// empty string as its single element.\nfunc (p *Pipe) Slice() ([]string, error) {\n\tresult := []string{}\n\tp.FilterScan(func(line string, w io.Writer) {\n\t\tresult = append(result, line)\n\t}).Wait()\n\treturn result, p.Error()\n}\n\n// stdErr returns the pipe's configured standard error writer for commands run\n// via [Pipe.Exec] and [Pipe.ExecForEach]. The default is nil, which means that\n// error output will go to the pipe.\nfunc (p *Pipe) stdErr() io.Writer {\n\tif p.mu == nil { // uninitialised pipe\n\t\treturn nil\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\treturn p.stderr\n}\n\n// Stdout copies the pipe's contents to its configured standard output (using\n// [Pipe.WithStdout]), or to [os.Stdout] otherwise, and returns the number of\n// bytes successfully written, together with any error.\nfunc (p *Pipe) Stdout() (int, error) {\n\tif p.Error() != nil {\n\t\treturn 0, p.Error()\n\t}\n\tn64, err := io.Copy(p.stdout, p)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn := int(n64)\n\tif int64(n) != n64 {\n\t\treturn 0, fmt.Errorf(\"length %d overflows int\", n64)\n\t}\n\treturn n, p.Error()\n}\n\n// String returns the pipe's contents as a string, together with any error.\nfunc (p *Pipe) String() (string, error) {\n\tdata, err := p.Bytes()\n\tif err != nil {\n\t\tp.SetError(err)\n\t}\n\treturn string(data), p.Error()\n}\n\n// Tee copies the pipe's contents to each of the supplied writers, like Unix\n// tee(1). If no writers are supplied, the default is the pipe's standard\n// output.\nfunc (p *Pipe) Tee(writers ...io.Writer) *Pipe {\n\tteeWriter := p.stdout\n\tif len(writers) > 0 {\n\t\tteeWriter = io.MultiWriter(writers...)\n\t}\n\treturn p.WithReader(io.TeeReader(p.Reader, teeWriter))\n}\n\n// Wait reads the pipe to completion and returns any error present on\n// the pipe, or nil otherwise. This is mostly useful for waiting until\n// concurrent filters have completed (see [Pipe.Filter]).\nfunc (p *Pipe) Wait() error {\n\t_, err := io.Copy(io.Discard, p)\n\tif err != nil {\n\t\tp.SetError(err)\n\t}\n\treturn p.Error()\n}\n\n// WithEnv sets the environment for subsequent [Pipe.Exec] and [Pipe.ExecForEach]\n// commands to the string slice env, using the same format as [os/exec.Cmd.Env].\n// An empty slice unsets all existing environment variables.\nfunc (p *Pipe) WithEnv(env []string) *Pipe {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.env = env\n\treturn p\n}\n\n// WithError sets the error err on the pipe.\nfunc (p *Pipe) WithError(err error) *Pipe {\n\tp.SetError(err)\n\treturn p\n}\n\n// WithHTTPClient sets the HTTP client c for use with subsequent requests via\n// [Pipe.Do], [Pipe.Get], or [Pipe.Post]. For example, to make a request using\n// a client with a timeout:\n//\n//\tNewPipe().WithHTTPClient(&http.Client{\n//\t        Timeout: 10 * time.Second,\n//\t}).Get(\"https://example.com\").Stdout()\nfunc (p *Pipe) WithHTTPClient(c *http.Client) *Pipe {\n\tp.httpClient = c\n\treturn p\n}\n\n// WithReader sets the pipe's input reader to r. Once r has been completely\n// read, it will be closed if necessary.\nfunc (p *Pipe) WithReader(r io.Reader) *Pipe {\n\tp.Reader = NewReadAutoCloser(r)\n\treturn p\n}\n\n// WithStderr sets the standard error output for [Pipe.Exec] or\n// [Pipe.ExecForEach] commands to w, instead of the pipe.\nfunc (p *Pipe) WithStderr(w io.Writer) *Pipe {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.stderr = w\n\treturn p\n}\n\n// WithStdout sets the pipe's standard output to the writer w, instead of the\n// default [os.Stdout].\nfunc (p *Pipe) WithStdout(w io.Writer) *Pipe {\n\tp.stdout = w\n\treturn p\n}\n\n// WriteFile writes the pipe's contents to the file path, truncating it if it\n// exists, and returns the number of bytes successfully written, or an error.\nfunc (p *Pipe) WriteFile(path string) (int64, error) {\n\treturn p.writeOrAppendFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n}\n\nfunc (p *Pipe) writeOrAppendFile(path string, mode int) (int64, error) {\n\tif p.Error() != nil {\n\t\treturn 0, p.Error()\n\t}\n\tout, err := os.OpenFile(path, mode, 0o666)\n\tif err != nil {\n\t\tp.SetError(err)\n\t\treturn 0, err\n\t}\n\tdefer out.Close()\n\twrote, err := io.Copy(out, p)\n\tif err != nil {\n\t\tp.SetError(err)\n\t}\n\treturn wrote, p.Error()\n}\n\n// ReadAutoCloser wraps an [io.ReadCloser] so that it will be automatically\n// closed once it has been fully read.\ntype ReadAutoCloser struct {\n\tr io.ReadCloser\n}\n\n// NewReadAutoCloser returns a [ReadAutoCloser] wrapping the reader r.\nfunc NewReadAutoCloser(r io.Reader) ReadAutoCloser {\n\tif _, ok := r.(io.Closer); !ok {\n\t\treturn ReadAutoCloser{io.NopCloser(r)}\n\t}\n\trc, ok := r.(io.ReadCloser)\n\tif !ok {\n\t\t// This can never happen, but just in case it does...\n\t\tpanic(\"internal error: type assertion to io.ReadCloser failed\")\n\t}\n\treturn ReadAutoCloser{rc}\n}\n\n// Close closes ra's reader, returning any resulting error.\nfunc (ra ReadAutoCloser) Close() error {\n\tif ra.r == nil {\n\t\treturn nil\n\t}\n\treturn ra.r.Close()\n}\n\n// Read reads up to len(b) bytes from ra's reader into b. It returns the number\n// of bytes read and any error encountered. At end of file, Read returns 0,\n// [io.EOF]. If end-of-file is reached, the reader will be closed.\nfunc (ra ReadAutoCloser) Read(b []byte) (n int, err error) {\n\tif ra.r == nil {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = ra.r.Read(b)\n\tif err == io.EOF {\n\t\tra.Close()\n\t}\n\treturn n, err\n}\n\nfunc newScanner(r io.Reader) *bufio.Scanner {\n\tscanner := bufio.NewScanner(r)\n\tscanner.Buffer(make([]byte, 4096), math.MaxInt)\n\treturn scanner\n}\n"
        },
        {
          "name": "script_test.go",
          "type": "blob",
          "size": 58.6494140625,
          "content": "package script_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/iotest\"\n\n\t\"github.com/bitfield/script\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/rogpeppe/go-internal/testscript\"\n)\n\nfunc TestMain(m *testing.M) {\n\tos.Exit(testscript.RunMain(m, map[string]func() int{\n\t\t\"args\": func() int {\n\t\t\tscript.Args().Stdout()\n\t\t\treturn 0\n\t\t},\n\t\t\"echostdin\": func() int {\n\t\t\tscript.Stdin().Stdout()\n\t\t\treturn 0\n\t\t},\n\t}))\n}\n\nfunc TestScript(t *testing.T) {\n\tt.Parallel()\n\ttestscript.Run(t, testscript.Params{\n\t\tDir: \"testdata/script\",\n\t})\n}\n\nfunc TestBasenameRemovesLeadingPathComponentsFromInputLines(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"\\n\", \".\\n\"},\n\t\t{\"/\", \"/\\n\"},\n\t\t{\"/root\", \"root\\n\"},\n\t\t{\"/tmp/example.php\", \"example.php\\n\"},\n\t\t{\"./src/filters\", \"filters\\n\"},\n\t\t{\"/var/tmp/example.php\", \"example.php\\n\"},\n\t\t{\"/tmp/script-21345.txt\\n/tmp/script-5371253.txt\", \"script-21345.txt\\nscript-5371253.txt\\n\"},\n\t\t{\"C:/Program Files\", \"Program Files\\n\"},\n\t\t{\"C:/Program Files/\", \"Program Files\\n\"},\n\t}\n\tfor _, tc := range tcs {\n\t\t// Expect results to use this platform's path separator\n\t\twant := filepath.Clean(tc.want)\n\t\tgot, err := script.Echo(tc.path).Basename().String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif want != got {\n\t\t\tt.Errorf(\"%q: want %q, got %q\", tc.path, want, got)\n\t\t}\n\t}\n}\n\nfunc TestColumnSelects(t *testing.T) {\n\tt.Parallel()\n\tinput := []string{\n\t\t\"60916 s003  Ss+    0:00.51 /bin/bash -l\",\n\t\t\" 6653 s004  R+     0:00.01 ps ax\",\n\t\t\"short line\",\n\t\t\"80159 s004  Ss     0:00.56 /bin/bash -l\",\n\t\t\"60942 s006  Ss+    0:00.53 /bin/bash -l\",\n\t\t\"60943 s007  Ss+    0:00.51 /bin/bash -l\",\n\t\t\"60977 s009  Ss+  \t0:00.52 /bin/bash -l\",\n\t\t\"  60978 s010  Ss+    0:00.53 /bin/bash -l\",\n\t\t\"61356 s011\tSs     0:00.54 /bin/bash -l\",\n\t}\n\ttcs := []struct {\n\t\tcol  int\n\t\twant []string\n\t}{\n\t\t{\n\t\t\tcol:  -1,\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\tcol:  0,\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\tcol: 1,\n\t\t\twant: []string{\n\t\t\t\t\"60916\",\n\t\t\t\t\"6653\",\n\t\t\t\t\"short\",\n\t\t\t\t\"80159\",\n\t\t\t\t\"60942\",\n\t\t\t\t\"60943\",\n\t\t\t\t\"60977\",\n\t\t\t\t\"60978\",\n\t\t\t\t\"61356\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol: 2,\n\t\t\twant: []string{\n\t\t\t\t\"s003\",\n\t\t\t\t\"s004\",\n\t\t\t\t\"line\",\n\t\t\t\t\"s004\",\n\t\t\t\t\"s006\",\n\t\t\t\t\"s007\",\n\t\t\t\t\"s009\",\n\t\t\t\t\"s010\",\n\t\t\t\t\"s011\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol: 3,\n\t\t\twant: []string{\n\t\t\t\t\"Ss+\",\n\t\t\t\t\"R+\",\n\t\t\t\t\"Ss\",\n\t\t\t\t\"Ss+\",\n\t\t\t\t\"Ss+\",\n\t\t\t\t\"Ss+\",\n\t\t\t\t\"Ss+\",\n\t\t\t\t\"Ss\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol: 4,\n\t\t\twant: []string{\n\t\t\t\t\"0:00.51\",\n\t\t\t\t\"0:00.01\",\n\t\t\t\t\"0:00.56\",\n\t\t\t\t\"0:00.53\",\n\t\t\t\t\"0:00.51\",\n\t\t\t\t\"0:00.52\",\n\t\t\t\t\"0:00.53\",\n\t\t\t\t\"0:00.54\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol: 5,\n\t\t\twant: []string{\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"ps\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t\t\"/bin/bash\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol: 6,\n\t\t\twant: []string{\n\t\t\t\t\"-l\",\n\t\t\t\t\"ax\",\n\t\t\t\t\"-l\",\n\t\t\t\t\"-l\",\n\t\t\t\t\"-l\",\n\t\t\t\t\"-l\",\n\t\t\t\t\"-l\",\n\t\t\t\t\"-l\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcol:  7,\n\t\t\twant: []string{},\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tt.Run(fmt.Sprintf(\"column %d of input\", tc.col), func(t *testing.T) {\n\t\t\tgot, err := script.Slice(input).Column(tc.col).Slice()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !cmp.Equal(tc.want, got) {\n\t\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConcatOutputsContentsOfSpecifiedFilesInOrder(t *testing.T) {\n\tt.Parallel()\n\twant := \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\nhello world\"\n\tgot, err := script.Echo(\"testdata/test.txt\\ntestdata/doesntexist.txt\\ntestdata/hello.txt\").Concat().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestDirname_RemovesFilenameComponentFromInputLines(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"/\", \"/\\n\"},\n\t\t{\"./\", \".\\n\"},\n\t\t{\"\\n\", \".\\n\"},\n\t\t{\"/root\", \"/\\n\"},\n\t\t{\"/tmp/example.php\", \"/tmp\\n\"},\n\t\t{\"/var/tmp/example.php\", \"/var/tmp\\n\"},\n\t\t{\"/var/tmp\", \"/var\\n\"},\n\t\t{\"/var/tmp/\", \"/var\\n\"},\n\t\t{\"src/filters\", \"./src\\n\"},\n\t\t{\"src/filters/\", \"./src\\n\"},\n\t\t{\"/tmp/script-21345.txt\\n/tmp/script-5371253.txt\", \"/tmp\\n/tmp\\n\"},\n\t\t{\"C:/Program Files/PHP\", \"C:/Program Files\\n\"},\n\t\t{\"C:/Program Files/PHP/\", \"C:/Program Files\\n\"},\n\t}\n\tfor _, tc := range tcs {\n\t\t// Expect results to use this platform's path separator\n\t\twant := filepath.Clean(tc.want)\n\t\tgot, err := script.Echo(tc.path).Dirname().String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif want != got {\n\t\t\tt.Errorf(\"%q: want %q, got %q\", tc.path, want, got)\n\t\t}\n\t}\n}\n\nfunc TestDoPerformsSuppliedHTTPRequest(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\treq, err := http.NewRequest(http.MethodGet, ts.URL, http.NoBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"some data\\n\"\n\tgot, err := script.Do(req).String()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestEachLine_FiltersInputThroughSuppliedFunction(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello world\\nGoodbye world\\n\"\n\tgot, err := script.Echo(\"Hello\\nGoodbye\").\n\t\tEachLine(func(line string, out *strings.Builder) {\n\t\t\tout.WriteString(line + \" world\\n\")\n\t\t}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestEachLine_HandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\tvar got int\n\t_, err := script.Echo(longLine).\n\t\tEachLine(func(line string, out *strings.Builder) {\n\t\t\tgot++\n\t\t}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := 2\n\tif want != got {\n\t\tt.Errorf(\"want %d lines counted, got %d\", want, got)\n\t}\n}\n\nfunc TestEchoProducesSuppliedString(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello, world.\"\n\tp := script.Echo(want)\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestEchoReplacesInputWithSuppliedStringWhenUsedAsFilter(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello, world.\"\n\tp := script.Echo(\"bogus\").Echo(want)\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestExecForEach_ErrorsOnInvalidTemplateSyntax(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"{{invalid template syntax}}\")\n\tp.Wait()\n\tif p.Error() == nil {\n\t\tt.Error(\"want error with invalid template syntax\")\n\t}\n}\n\nfunc TestExecForEach_ErrorsOnUnbalancedQuotes(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"echo \\\"{{.}}\")\n\tp.Wait()\n\tif p.Error() == nil {\n\t\tt.Error(\"want error with unbalanced quotes in command line\")\n\t}\n}\n\nfunc TestExecForEach_SendsStderrOutputToPipeStderr(t *testing.T) {\n\tt.Parallel()\n\tbuf := new(bytes.Buffer)\n\tout, err := script.Echo(\"go\").WithStderr(buf).ExecForEach(\"{{.}}\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif out != \"\" {\n\t\tt.Fatalf(\"unexpected output: %q\", out)\n\t}\n\tif !strings.Contains(buf.String(), \"Usage\") {\n\t\tt.Errorf(\"want stderr output containing the word 'Usage', got %q\", buf.String())\n\t}\n}\n\nfunc TestExecSendsStderrOutputToPipeStderr(t *testing.T) {\n\tt.Parallel()\n\tbuf := new(bytes.Buffer)\n\tout, err := script.NewPipe().WithStderr(buf).Exec(\"go\").String()\n\tif err == nil {\n\t\tt.Fatal(\"want error when command returns a non-zero exit status\")\n\t}\n\tif out != \"\" {\n\t\tt.Fatalf(\"unexpected output: %q\", out)\n\t}\n\tif !strings.Contains(buf.String(), \"Usage\") {\n\t\tt.Errorf(\"want stderr output containing the word 'Usage', got %q\", buf.String())\n\t}\n}\n\nfunc TestFilterByCopyPassesInputThroughUnchanged(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"hello\").Filter(func(r io.Reader, w io.Writer) error {\n\t\t_, err := io.Copy(w, r)\n\t\treturn err\n\t})\n\twant := \"hello\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterCanChainFilters(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"hello\").Filter(func(r io.Reader, w io.Writer) error {\n\t\t_, err := io.Copy(w, r)\n\t\treturn err\n\t}).Filter(func(r io.Reader, w io.Writer) error {\n\t\t_, err := io.Copy(w, r)\n\t\treturn err\n\t})\n\twant := \"hello\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterByCopyToDiscardGivesNoOutput(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"hello\").Filter(func(r io.Reader, w io.Writer) error {\n\t\t_, err := io.Copy(io.Discard, r)\n\t\treturn err\n\t})\n\twant := \"\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterReadsNoMoreThanRequested(t *testing.T) {\n\tt.Parallel()\n\tinput := \"firstline\\nsecondline\"\n\tsource := bytes.NewBufferString(input)\n\tp := script.NewPipe().WithReader(source).Filter(func(r io.Reader, w io.Writer) error {\n\t\t// read just the first line of input\n\t\tvar text string\n\t\t_, err := fmt.Fscanln(r, &text)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintln(w, text)\n\t\treturn nil\n\t})\n\twant := \"firstline\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Fatal(cmp.Diff(want, got))\n\t}\n\twantRemaining := \"secondline\"\n\tif wantRemaining != source.String() {\n\t\tt.Errorf(\"want %q remaining, got %q\", wantRemaining, source.String())\n\t}\n}\n\nfunc TestFilterByFirstLineOnlyGivesFirstLineOfInput(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"hello\\nworld\").Filter(func(r io.Reader, w io.Writer) error {\n\t\tscanner := bufio.NewScanner(r)\n\t\tfor scanner.Scan() {\n\t\t\tfmt.Fprintln(w, scanner.Text())\n\t\t\tbreak\n\t\t}\n\t\treturn scanner.Err()\n\t})\n\twant := \"hello\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterSetsErrorOnPipeIfFilterFuncReturnsError(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"hello\").Filter(func(io.Reader, io.Writer) error {\n\t\treturn errors.New(\"oh no\")\n\t})\n\tio.ReadAll(p)\n\tif p.Error() == nil {\n\t\tt.Error(\"no error\")\n\t}\n}\n\nfunc TestFilterLine_FiltersEachLineThroughSuppliedFunction(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello\\nworld\"\n\twant := \"HELLO\\nWORLD\\n\"\n\tgot, err := script.Echo(input).FilterLine(strings.ToUpper).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterScan_FiltersInputLineByLine(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello\\nworld\\ngoodbye\"\n\twant := \"world\\n\"\n\tgot, err := script.Echo(input).\n\t\tFilterScan(func(line string, w io.Writer) {\n\t\t\tif strings.HasPrefix(line, \"w\") {\n\t\t\t\tfmt.Fprintln(w, line)\n\t\t\t}\n\t\t}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFilterScan_HandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\twant := \"last line\\n\"\n\tgot, err := script.Echo(longLine).\n\t\tFilterScan(func(line string, w io.Writer) {\n\t\t\tif strings.HasPrefix(line, \"last\") {\n\t\t\t\tfmt.Fprintln(w, line)\n\t\t\t}\n\t\t}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFirstDropsAllButFirstNLinesOfInput(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"a\\nb\\n\"\n\tgot, err := script.Echo(input).First(2).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFirstHasNoOutputWhenNIs0(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"\"\n\tgot, err := script.Echo(input).First(0).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFirstHasNoOutputWhenNIsNegative(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"\"\n\tgot, err := script.Echo(input).First(-1).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFirstHasNoEffectGivenLessThanNInputLines(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"a\\nb\\nc\\n\"\n\tgot, err := script.Echo(input).First(4).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFirstDoesNotConsumeUnnecessaryData(t *testing.T) {\n\tt.Parallel()\n\t// First uses a 4096-byte buffer, so will always read at least\n\t// that much, but no more (once N lines have been read).\n\tr := strings.NewReader(strings.Repeat(\"line\\n\", 1000))\n\tgot, err := script.NewPipe().WithReader(r).First(1).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"line\\n\"\n\tif want != got {\n\t\tt.Errorf(\"want output %q, got %q\", want, got)\n\t}\n\tif r.Len() == 0 {\n\t\tt.Errorf(\"no data left in reader\")\n\t}\n}\n\nfunc TestFreqHandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\tgot, err := script.Echo(longLine).Freq().Slice()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(got) != 2 {\n\t\tt.Fatalf(\"want 2 results, got %d: %q\", len(got), got)\n\t}\n\tif got[0] != \"1 last line\" {\n\t\tt.Fatalf(\"wrong result: %q\", got)\n\t}\n}\n\nfunc TestFreqProducesCorrectFrequencyTableForInput(t *testing.T) {\n\tt.Parallel()\n\tinput := strings.Join([]string{\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"banana\",\n\t\t\"banana\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"kumquat\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"apple\",\n\t\t\"banana\",\n\t\t\"banana\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t}, \"\\n\")\n\twant := \"10 apple\\n 4 banana\\n 4 orange\\n 1 kumquat\\n\"\n\tgot, err := script.Echo(input).Freq().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestGetMakesHTTPGetRequestToGivenURL(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\tt.Fatalf(\"want HTTP method GET, got %q\", r.Method)\n\t\t}\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\twant := \"some data\\n\"\n\tgot, err := script.Get(ts.URL).String()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestGetSetsErrorStatusWhenHTTPResponseStatusIsNotOK(t *testing.T) {\n\tt.Parallel()\n\t// With no handler, all requests will get 404\n\tts := httptest.NewServer(nil)\n\tdefer ts.Close()\n\tp := script.Get(ts.URL)\n\tp.Wait()\n\tif p.Error() == nil {\n\t\tt.Fatalf(\"want error for non-OK request, got nil\")\n\t}\n}\n\nfunc TestGetConsidersHTTPStatus201CreatedToBeOK(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\twant := \"some data\\n\"\n\tgot, err := script.Get(ts.URL).String()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestGetUsesPipeContentsAsRequestBody(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\twant := []byte(\"request data\")\n\t\tgot, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"reading request body\", err)\n\t\t}\n\t\tif !cmp.Equal(want, got) {\n\t\t\tt.Fatalf(cmp.Diff(want, string(got)))\n\t\t}\n\t}))\n\tdefer ts.Close()\n\t_, err := script.Echo(\"request data\").Get(ts.URL).String()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc TestJoinHandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\tresult, err := script.Echo(longLine).Join().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := len(longLine)\n\tif want != len(result) {\n\t\tt.Errorf(\"want result length %d, got %d\", want, len(result))\n\t}\n}\n\nfunc TestJoinJoinsInputLinesIntoSpaceSeparatedString(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello\\nfrom\\nthe\\njoin\\ntest\"\n\twant := \"hello from the join test\\n\"\n\tgot, err := script.Echo(input).Join().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestJQWithDotQueryPrettyPrintsInput(t *testing.T) {\n\tt.Parallel()\n\tinput := `{\"timestamp\": 1649264191, \"iss_position\": {\"longitude\": \"52.8439\", \"latitude\": \"10.8107\"}, \"message\": \"success\"}`\n\t// Fields should be sorted by key, with whitespace removed\n\twant := `{\"iss_position\":{\"latitude\":\"10.8107\",\"longitude\":\"52.8439\"},\"message\":\"success\",\"timestamp\":1649264191}` + \"\\n\"\n\tgot, err := script.Echo(input).JQ(\".\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(want, got)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestJQWithFieldQueryProducesSelectedField(t *testing.T) {\n\tt.Parallel()\n\tinput := `{\"timestamp\": 1649264191, \"iss_position\": {\"longitude\": \"52.8439\", \"latitude\": \"10.8107\"}, \"message\": \"success\"}`\n\twant := `{\"latitude\":\"10.8107\",\"longitude\":\"52.8439\"}` + \"\\n\"\n\tgot, err := script.Echo(input).JQ(\".iss_position\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(want, got)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestJQWithArrayQueryProducesRequiredArray(t *testing.T) {\n\tt.Parallel()\n\tinput := `{\"timestamp\": 1649264191, \"iss_position\": {\"longitude\": \"52.8439\", \"latitude\": \"10.8107\"}, \"message\": \"success\"}`\n\twant := `[\"10.8107\",\"52.8439\"]` + \"\\n\"\n\tgot, err := script.Echo(input).JQ(\"[.iss_position.latitude, .iss_position.longitude]\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(want, got)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestJQWithArrayInputAndElementQueryProducesSelectedElement(t *testing.T) {\n\tt.Parallel()\n\tinput := `[1, 2, 3]`\n\twant := \"1\\n\"\n\tgot, err := script.Echo(input).JQ(\".[0]\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(want, got)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestJQHandlesGithubJSONWithRealWorldExampleQuery(t *testing.T) {\n\tt.Parallel()\n\twant := `{\"message\":\"restore sample log data (fixes #102)\",\"name\":\"John Arundel\"}` + \"\\n\"\n\tgot, err := script.File(\"testdata/commits.json\").\n\t\tJQ(\".[0] | {message: .commit.message, name: .commit.committer.name}\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(want, got)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestJQErrorsWithInvalidQuery(t *testing.T) {\n\tt.Parallel()\n\tinput := `[1, 2, 3]`\n\t_, err := script.Echo(input).JQ(\".foo & .bar\").String()\n\tif err == nil {\n\t\tt.Error(\"want error from invalid JQ query, got nil\")\n\t}\n}\n\nfunc TestLastDropsAllButLastNLinesOfInput(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"b\\nc\\n\"\n\tgot, err := script.Echo(input).Last(2).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestLastHandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\twant := \"last line\\n\"\n\tgot, err := script.Echo(longLine).Last(1).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestLastHasNoOutputWhenNIs0(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"\"\n\tgot, err := script.Echo(input).Last(0).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestLastHasNoOutputWhenNIsNegative(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"\"\n\tgot, err := script.Echo(input).Last(-1).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestLastHasNoEffectGivenLessThanNInputLines(t *testing.T) {\n\tt.Parallel()\n\tinput := \"a\\nb\\nc\\n\"\n\twant := \"a\\nb\\nc\\n\"\n\tgot, err := script.Echo(input).Last(4).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestMatchOutputsOnlyMatchingLinesOfInput(t *testing.T) {\n\tt.Parallel()\n\tinput := \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\"\n\ttcs := []struct {\n\t\tmatch, want string\n\t}{\n\t\t{\n\t\t\tmatch: \"line\",\n\t\t\twant:  \"This is the first line in the file.\\nThis is another line in the file.\\n\",\n\t\t},\n\t\t{\n\t\t\tmatch: \"another\",\n\t\t\twant:  \"This is another line in the file.\\n\",\n\t\t},\n\t\t{\n\t\t\tmatch: \"definitely won't match any lines\",\n\t\t\twant:  \"\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).Match(tc.match).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestMatchOutputsNothingGivenEmptyInput(t *testing.T) {\n\tt.Parallel()\n\tgot, err := script.NewPipe().Match(\"anything\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != \"\" {\n\t\tt.Error(\"want no output given empty input\")\n\t}\n}\n\nfunc TestMatchRegexp_OutputsOnlyLinesMatchingRegexp(t *testing.T) {\n\tt.Parallel()\n\tinput := \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\"\n\ttcs := []struct {\n\t\tregex, want string\n\t}{\n\t\t{\n\t\t\tregex: `Hello|file`,\n\t\t\twant:  \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\",\n\t\t},\n\t\t{\n\t\t\tregex: `an.ther`,\n\t\t\twant:  \"This is another line in the file.\\n\",\n\t\t},\n\t\t{\n\t\t\tregex: `r[a-z]*s`,\n\t\t\twant:  \"This is the first line in the file.\\n\",\n\t\t},\n\t\t{\n\t\t\tregex: `r[a-z]+s`,\n\t\t\twant:  \"\",\n\t\t},\n\t\t{\n\t\t\tregex: `bogus$`,\n\t\t\twant:  \"\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).MatchRegexp(regexp.MustCompile(tc.regex)).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestReplaceReplacesMatchesWithSpecifiedText(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello world\"\n\ttcs := []struct {\n\t\tsearch, replace, want string\n\t}{\n\t\t{\n\t\t\tsearch:  \"hello\",\n\t\t\treplace: \"bye\",\n\t\t\twant:    \"bye world\\n\",\n\t\t},\n\t\t{\n\t\t\tsearch:  \"Does not exist in input\",\n\t\t\treplace: \"Will not appear in output\",\n\t\t\twant:    \"hello world\\n\",\n\t\t},\n\t\t{\n\t\t\tsearch:  \" world\",\n\t\t\treplace: \" string with newline\\n\",\n\t\t\twant:    \"hello string with newline\\n\\n\",\n\t\t},\n\t\t{\n\t\t\tsearch:  \"hello\",\n\t\t\treplace: \"Ж9\",\n\t\t\twant:    \"Ж9 world\\n\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).Replace(tc.search, tc.replace).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestReplaceRegexp_ReplacesMatchesWithSpecifiedText(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello world\"\n\ttcs := []struct {\n\t\tregex, replace, want string\n\t}{\n\t\t{\n\t\t\tregex:   \"hel+o\",\n\t\t\treplace: \"bye\",\n\t\t\twant:    \"bye world\\n\",\n\t\t},\n\t\t{\n\t\t\tregex:   \"Does not .* in input\",\n\t\t\treplace: \"Will not appear in output\",\n\t\t\twant:    \"hello world\\n\",\n\t\t},\n\t\t{\n\t\t\tregex:   \"^([a-z]+) ([a-z]+)\",\n\t\t\treplace: \"$1 cruel $2\",\n\t\t\twant:    \"hello cruel world\\n\",\n\t\t},\n\t\t{\n\t\t\tregex:   \"hello{1}\",\n\t\t\treplace: \"Ж9\",\n\t\t\twant:    \"Ж9 world\\n\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).ReplaceRegexp(regexp.MustCompile(tc.regex), tc.replace).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestRejectDropsMatchingLinesFromInput(t *testing.T) {\n\tt.Parallel()\n\tinput := \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\"\n\ttcs := []struct {\n\t\treject, want string\n\t}{\n\t\t{\n\t\t\treject: \"line\",\n\t\t\twant:   \"Hello, world.\\n\",\n\t\t},\n\t\t{\n\t\t\treject: \"another\",\n\t\t\twant:   \"This is the first line in the file.\\nHello, world.\\n\",\n\t\t},\n\t\t{\n\t\t\treject: \"definitely won't match any lines\",\n\t\t\twant:   \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).Reject(tc.reject).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestPostPostsToGivenURLUsingPipeAsRequestBody(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\tt.Errorf(\"want HTTP method POST, got %q\", r.Method)\n\t\t}\n\t\twant := []byte(\"request data\")\n\t\tgot, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"reading request body\", err)\n\t\t}\n\t\tif !cmp.Equal(want, got) {\n\t\t\tt.Fatal(cmp.Diff(want, string(got)))\n\t\t}\n\t\tfmt.Fprintln(w, \"response data\")\n\t}))\n\tdefer ts.Close()\n\twant := \"response data\\n\"\n\tgot, err := script.Echo(\"request data\").Post(ts.URL).String()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestRejectRegexp_DropsMatchingLinesFromInput(t *testing.T) {\n\tt.Parallel()\n\tinput := \"hello world\"\n\ttcs := []struct {\n\t\tregex, want string\n\t}{\n\t\t{\n\t\t\tregex: `Hello|line`,\n\t\t\twant:  \"hello world\\n\",\n\t\t},\n\t\t{\n\t\t\tregex: `hello|bogus`,\n\t\t\twant:  \"\",\n\t\t},\n\t\t{\n\t\t\tregex: `w.*d`,\n\t\t\twant:  \"\",\n\t\t},\n\t\t{\n\t\t\tregex: \"wontmatch\",\n\t\t\twant:  \"hello world\\n\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.Echo(input).RejectRegexp(regexp.MustCompile(tc.regex)).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Error(cmp.Diff(tc.want, got))\n\t\t}\n\t}\n}\n\nfunc TestSHA256Sums_OutputsCorrectHashForEachSpecifiedFile(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\ttestFileName string\n\t\twant         string\n\t}{\n\t\t// To get the checksum run: openssl dgst -sha256 <file_name>\n\t\t{\"testdata/hashSum.input.txt\", \"1870478d23b0b4db37735d917f4f0ff9393dd3e52d8b0efa852ab85536ddad8e\\n\"},\n\t\t{\"testdata/hello.txt\", \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\\n\"},\n\t\t{\"testdata/multiple_files\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\n\"},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.ListFiles(tc.testFileName).SHA256Sums().String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"%q: want %q, got %q\", tc.testFileName, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc TestTeeUsesConfiguredStdoutAsDefault(t *testing.T) {\n\tt.Parallel()\n\tbuf := new(bytes.Buffer)\n\t_, err := script.Echo(\"hello\").WithStdout(buf).Tee().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"hello\"\n\tgot := buf.String()\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestTeeWritesDataToSuppliedWritersAsWellAsToPipe(t *testing.T) {\n\tt.Parallel()\n\tbuf1, buf2 := new(bytes.Buffer), new(bytes.Buffer)\n\tgot, err := script.Echo(\"hello world\").Tee(buf1, buf2).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"hello world\"\n\tif want != got {\n\t\tt.Errorf(\"want %q on pipe, got %q\", want, got)\n\t}\n\tif want != buf1.String() {\n\t\tt.Errorf(\"want %q on writer 1, got %q\", want, buf1.String())\n\t}\n\tif want != buf2.String() {\n\t\tt.Errorf(\"want %q on writer 2, got %q\", want, buf2.String())\n\t}\n}\n\nfunc TestExecErrorsWhenTheSpecifiedCommandDoesNotExist(t *testing.T) {\n\tt.Parallel()\n\tp := script.Exec(\"doesntexist\")\n\tp.Wait()\n\tif p.Error() == nil {\n\t\tt.Error(\"want error running non-existent command\")\n\t}\n}\n\nfunc TestExecRunsGoWithNoArgsAndGetsUsageMessagePlusErrorExitStatus2(t *testing.T) {\n\tt.Parallel()\n\t// We can't make many cross-platform assumptions about what external\n\t// commands will be available, but it seems logical that 'go' would be\n\t// (though it may not be in the user's path)\n\tp := script.Exec(\"go\")\n\toutput, err := p.String()\n\tif err == nil {\n\t\tt.Fatal(\"want error when command returns a non-zero exit status\")\n\t}\n\tif !strings.Contains(output, \"Usage\") {\n\t\tt.Fatalf(\"want output containing the word 'Usage', got %q\", output)\n\t}\n\twant := 2\n\tgot := p.ExitStatus()\n\tif want != got {\n\t\tt.Errorf(\"want exit status %d, got %d\", want, got)\n\t}\n}\n\nfunc TestExecRunsGoHelpAndGetsUsageMessage(t *testing.T) {\n\tt.Parallel()\n\tp := script.Exec(\"go help\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\toutput, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(output, \"Usage\") {\n\t\tt.Fatalf(\"want output containing the word 'Usage', got %q\", output)\n\t}\n}\n\nfunc TestFileOutputsContentsOfSpecifiedFile(t *testing.T) {\n\tt.Parallel()\n\twant := \"This is the first line in the file.\\nHello, world.\\nThis is another line in the file.\\n\"\n\tgot, err := script.File(\"testdata/test.txt\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFileErrorsOnNonexistentFile(t *testing.T) {\n\tt.Parallel()\n\tp := script.File(\"doesntexist\")\n\tif p.Error() == nil {\n\t\tt.Error(\"want error for non-existent file\")\n\t}\n}\n\nfunc TestFindFiles_ReturnsListOfFiles(t *testing.T) {\n\tt.Parallel()\n\tp := script.FindFiles(\"testdata/multiple_files\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\tp.SetError(nil) // else p.String() would be a no-op\n\t// Expect result to use this platform's path separator\n\twant := filepath.Clean(\"testdata/multiple_files/1.txt\\ntestdata/multiple_files/2.txt\\ntestdata/multiple_files/3.tar.zip\\n\")\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Fatal(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFindFiles_RecursesIntoSubdirectories(t *testing.T) {\n\tt.Parallel()\n\tp := script.FindFiles(\"testdata/multiple_files_with_subdirectory\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\tp.SetError(nil) // else p.String() would be a no-op\n\t// Expect result to use this platform's path separator\n\twant := filepath.Clean(\"testdata/multiple_files_with_subdirectory/1.txt\\ntestdata/multiple_files_with_subdirectory/2.txt\\ntestdata/multiple_files_with_subdirectory/3.tar.zip\\ntestdata/multiple_files_with_subdirectory/dir/.hidden\\ntestdata/multiple_files_with_subdirectory/dir/1.txt\\ntestdata/multiple_files_with_subdirectory/dir/2.txt\\n\")\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Fatal(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFindFiles_InNonexistentPathReturnsError(t *testing.T) {\n\tt.Parallel()\n\tp := script.FindFiles(\"nonexistent_path\")\n\tif p.Error() == nil {\n\t\tt.Fatal(\"want error for nonexistent path\")\n\t}\n}\n\nfunc TestIfExists_ProducesErrorPlusNoOutputForNonexistentFile(t *testing.T) {\n\tt.Parallel()\n\twant := \"\"\n\tgot, err := script.IfExists(\"testdata/doesntexist\").Echo(\"hello\").String()\n\tif err == nil {\n\t\tt.Fatal(\"want error\")\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestIfExists_ProducesOutputAndNoErrorWhenFileExists(t *testing.T) {\n\tt.Parallel()\n\twant := \"hello\"\n\tgot, err := script.IfExists(\"testdata/empty.txt\").Echo(\"hello\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestListFiles_OutputsDirectoryContentsGivenDirectoryPath(t *testing.T) {\n\tt.Parallel()\n\twant := filepath.Clean(\"testdata/multiple_files/1.txt\\ntestdata/multiple_files/2.txt\\ntestdata/multiple_files/3.tar.zip\\n\")\n\tgot, err := script.ListFiles(\"testdata/multiple_files\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"Want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestListFiles_ErrorsOnNonexistentPath(t *testing.T) {\n\tt.Parallel()\n\tp := script.ListFiles(\"nonexistentpath\")\n\tif p.Error() == nil {\n\t\tt.Error(\"want error status on listing non-existent path, but got nil\")\n\t}\n}\n\nfunc TestListFiles_OutputsSingleFileGivenFilePath(t *testing.T) {\n\tt.Parallel()\n\tgot, err := script.ListFiles(\"testdata/multiple_files/1.txt\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"testdata/multiple_files/1.txt\"\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestListFiles_OutputsAllFilesMatchingSpecifiedGlobExpression(t *testing.T) {\n\tt.Parallel()\n\twant := filepath.Clean(\"testdata/multiple_files/1.txt\\ntestdata/multiple_files/2.txt\\n\")\n\tgot, err := script.ListFiles(\"testdata/multi?le_files/*.txt\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Errorf(\"Want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestReadAutoCloser_ReadsAllDataFromSourceAndClosesItAutomatically(t *testing.T) {\n\tt.Parallel()\n\twant := []byte(\"hello world\")\n\tinput, err := os.Open(\"testdata/hello.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tacr := script.NewReadAutoCloser(input)\n\tgot, err := io.ReadAll(acr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Fatal(cmp.Diff(want, got))\n\t}\n\t_, err = io.ReadAll(acr)\n\tif err == nil {\n\t\tt.Error(\"input not closed after reading\")\n\t}\n}\n\nfunc TestSliceProducesElementsOfSpecifiedSliceOnePerLine(t *testing.T) {\n\tt.Parallel()\n\twant := \"1\\n2\\n3\\n\"\n\tgot, err := script.Slice([]string{\"1\", \"2\", \"3\"}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestSliceGivenEmptySliceProducesEmptyPipe(t *testing.T) {\n\tt.Parallel()\n\twant := \"\"\n\tgot, err := script.Slice([]string{}).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestStdoutReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithStdout(io.Discard).\n\t\tWithReader(brokenReader).Stdout()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestStdoutSendsPipeContentsToConfiguredStandardOutput(t *testing.T) {\n\tt.Parallel()\n\tbuf := new(bytes.Buffer)\n\twant := \"hello world\"\n\tp := script.File(\"testdata/hello.txt\").WithStdout(buf)\n\twrote, err := p.Stdout()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif wrote != len(want) {\n\t\tt.Fatalf(\"want %d bytes written, got %d\", len(want), wrote)\n\t}\n\tgot := buf.String()\n\tif want != got {\n\t\tt.Fatalf(\"want %q, got %q\", want, string(got))\n\t}\n\t_, err = p.String()\n\tif err == nil {\n\t\tt.Error(\"input not closed after reading\")\n\t}\n}\n\nfunc TestAppendFile_AppendsAllItsInputToSpecifiedFile(t *testing.T) {\n\tt.Parallel()\n\torig := \"Hello, world\"\n\tpath := t.TempDir() + \"/\" + t.Name()\n\t_, err := script.Echo(orig).WriteFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\textra := \" and goodbye\"\n\twrote, err := script.Echo(extra).AppendFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif int(wrote) != len(extra) {\n\t\tt.Fatalf(\"want %d bytes written, got %d\", len(extra), int(wrote))\n\t}\n\t// check file contains both contents\n\tgot, err := script.File(path).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != orig+extra {\n\t\tt.Errorf(\"want %q, got %q\", orig+extra, got)\n\t}\n}\n\nfunc TestAppendFile_ReturnsBytesWrittenAndErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tvar want int64 = 1\n\tgot, err := script.NewPipe().WithReader(partialErrReader{}).AppendFile(t.TempDir() + \"/tmp\")\n\tif err == nil {\n\t\tt.Fatal(\"want error reading pipe with error status, got nil\")\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestBytesOutputsInputBytesUnchanged(t *testing.T) {\n\tt.Parallel()\n\twant := []byte{8, 0, 0, 16}\n\tinput := bytes.NewReader(want)\n\tgot, err := script.NewPipe().WithReader(input).Bytes()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestBytesReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).Bytes()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestCountLines_CountsCorrectNumberOfLinesInInput(t *testing.T) {\n\tt.Parallel()\n\twant := 3\n\tgot, err := script.Echo(\"a\\nb\\nc\").CountLines()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %d, got %d\", want, got)\n\t}\n}\n\nfunc TestCountLines_Counts0LinesInEmptyInput(t *testing.T) {\n\tt.Parallel()\n\twant := 0\n\tgot, err := script.Echo(\"\").CountLines()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %d, got %d\", want, got)\n\t}\n}\n\nfunc TestCountLines_ReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).CountLines()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestSHA256Sum_OutputsCorrectHash(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\tname, input, want string\n\t}{\n\t\t{\n\t\t\tname:  \"for no data\",\n\t\t\tinput: \"\",\n\t\t\twant:  \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n\t\t},\n\t\t{\n\t\t\tname:  \"for short string\",\n\t\t\tinput: \"hello, world\",\n\t\t\twant:  \"09ca7e4eaa6e8ae9c7d261167129184883644d07dfba7cbfbc4c8a2e08360d5b\",\n\t\t},\n\t\t{\n\t\t\tname:  \"for string containing newline\",\n\t\t\tinput: \"The tao that can be told\\nis not the eternal Tao\",\n\t\t\twant:  \"788542cb92d37f67e187992bdb402fdfb68228a1802947f74c6576e04790a688\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := script.Echo(tc.input).SHA256Sum()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"want %q, got %q\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSHA256Sum_ReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).SHA256Sum()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestSliceSink_ReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).Slice()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestSliceSink_(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname string\n\t\tpipe *script.Pipe\n\t\twant []string\n\t}{\n\t\t{\n\t\t\tname: \"returns three elements for three lines of input\",\n\t\t\tpipe: script.Echo(\"testdata/multiple_files/1.txt\\ntestdata/multiple_files/2.txt\\ntestdata/multiple_files/3.tar.zip\\n\"),\n\t\t\twant: []string{\n\t\t\t\t\"testdata/multiple_files/1.txt\",\n\t\t\t\t\"testdata/multiple_files/2.txt\",\n\t\t\t\t\"testdata/multiple_files/3.tar.zip\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"returns an empty slice given empty input\",\n\t\t\tpipe: script.Echo(\"\"),\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"returns one empty string given input containing a single newline\",\n\t\t\tpipe: script.Echo(\"\\n\"),\n\t\t\twant: []string{\"\"},\n\t\t},\n\t\t{\n\t\t\tname: \"returns an empty string for each empty input line\",\n\t\t\tpipe: script.Echo(\"testdata/multiple_files/1.txt\\n\\ntestdata/multiple_files/3.tar.zip\"),\n\t\t\twant: []string{\n\t\t\t\t\"testdata/multiple_files/1.txt\",\n\t\t\t\t\"\",\n\t\t\t\t\"testdata/multiple_files/3.tar.zip\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := tt.pipe\n\t\t\tgot, err := p.Slice()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !cmp.Equal(tt.want, got) {\n\t\t\t\tt.Error(cmp.Diff(tt.want, got))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestStringOutputsInputStringUnchanged(t *testing.T) {\n\tt.Parallel()\n\twant := \"hello, world\"\n\tgot, err := script.Echo(want).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestStringReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).String()\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestWaitReadsPipeSourceToCompletion(t *testing.T) {\n\tt.Parallel()\n\tsource := bytes.NewBufferString(\"hello\")\n\tscript.NewPipe().WithReader(source).FilterLine(strings.ToUpper).Wait()\n\tif source.Len() > 0 {\n\t\tt.Errorf(\"incomplete read: %d bytes of input remaining: %q\", source.Len(), source.String())\n\t}\n}\n\nfunc TestWriteFile_WritesInputToFileCreatingItIfNecessary(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello, world\"\n\tpath := t.TempDir() + \"/\" + t.Name()\n\twrote, err := script.Echo(want).WriteFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif int(wrote) != len(want) {\n\t\tt.Fatalf(\"want %d bytes written, got %d\", len(want), int(wrote))\n\t}\n\tgot, err := script.File(path).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\n// partialErrReader returns 1 and a non-EOF error on reading.\ntype partialErrReader struct{}\n\nfunc (r partialErrReader) Read(p []byte) (int, error) {\n\treturn 1, errors.New(\"oh no\")\n}\n\nfunc TestWriteFile_ReturnsBytesWrittenAndErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tvar want int64 = 1\n\tgot, err := script.NewPipe().WithReader(partialErrReader{}).WriteFile(t.TempDir() + \"/tmp\")\n\tif err == nil {\n\t\tt.Fatal(\"want error reading pipe with error status, got nil\")\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestWriteFile_TruncatesExistingFile(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello, world\"\n\tpath := t.TempDir() + \"/\" + t.Name()\n\t// write some data first so we can check for truncation\n\tdata := make([]byte, 15)\n\terr := os.WriteFile(path, data, 0o600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twrote, err := script.Echo(want).WriteFile(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif int(wrote) != len(want) {\n\t\tt.Fatalf(\"want %d bytes written, got %d\", len(want), int(wrote))\n\t}\n\tgot, err := script.File(path).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got == want+\"\\x00\\x00\\x00\" {\n\t\tt.Fatalf(\"file not truncated on write\")\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestWithHTTPClient_SetsSuppliedClientOnPipe(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\treq, err := http.NewRequest(http.MethodGet, ts.URL, http.NoBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"some data\\n\"\n\t// Unless the pipe uses the supplied ts.Client, we'll get a\n\t// 'certificate is not trusted' error on making the request\n\tgot, err := script.NewPipe().WithHTTPClient(ts.Client()).Do(req).String()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestWithReader_SetsSuppliedReaderOnPipe(t *testing.T) {\n\tt.Parallel()\n\twant := \"Hello, world.\"\n\tp := script.NewPipe().WithReader(strings.NewReader(want))\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestWithError_SetsSpecifiedErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tfakeErr := errors.New(\"oh no\")\n\tp := script.NewPipe().WithError(fakeErr)\n\tif p.Error() != fakeErr {\n\t\tt.Errorf(\"want %q, got %q\", fakeErr, p.Error())\n\t}\n}\n\nfunc TestWithStdout_SetsSpecifiedWriterAsStdout(t *testing.T) {\n\tt.Parallel()\n\tbuf := new(bytes.Buffer)\n\twant := \"Hello, world.\"\n\t_, err := script.Echo(want).WithStdout(buf).Stdout()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot := buf.String()\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestWithEnv_UnsetsAllEnvVarsGivenEmptySlice(t *testing.T) {\n\tt.Parallel()\n\tp := script.NewPipe().WithEnv([]string{\"ENV1=test1\"}).Exec(\"sh -c 'echo ENV1=$ENV1'\")\n\twant := \"ENV1=test1\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t}\n\tgot, err = p.Echo(\"\").WithEnv([]string{}).Exec(\"sh -c 'echo ENV1=$ENV1'\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant = \"ENV1=\\n\"\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestWithEnv_SetsGivenVariablesForSubsequentExec(t *testing.T) {\n\tt.Parallel()\n\tenv := []string{\"ENV1=test1\", \"ENV2=test2\"}\n\tgot, err := script.NewPipe().WithEnv(env).Exec(\"sh -c 'echo ENV1=$ENV1 ENV2=$ENV2'\").String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"ENV1=test1 ENV2=test2\\n\"\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestErrorReturnsErrorSetByPreviousPipeStage(t *testing.T) {\n\tt.Parallel()\n\tp := script.File(\"testdata/nonexistent.txt\")\n\tif p.Error() == nil {\n\t\tt.Error(\"want error status reading nonexistent file, but got nil\")\n\t}\n}\n\nfunc TestSetError_SetsSuppliedErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tp := script.NewPipe()\n\te := errors.New(\"fake error\")\n\tp.SetError(e)\n\tif p.Error() != e {\n\t\tt.Errorf(\"want %v when setting pipe error, got %v\", e, p.Error())\n\t}\n}\n\nfunc TestExitStatus_CorrectlyParsesExitStatusValueFromErrorMessage(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\tinput string\n\t\twant  int\n\t}{\n\t\t{\"\", 0},\n\t\t{\"bogus\", 0},\n\t\t{\"exit status bogus\", 0},\n\t\t{\"exit status 127\", 127},\n\t\t{\"exit status 1\", 1},\n\t\t{\"exit status 0\", 0},\n\t\t{\"exit status 1 followed by junk\", 0},\n\t}\n\tfor _, tc := range tcs {\n\t\tp := script.NewPipe()\n\t\tp.SetError(errors.New(tc.input))\n\t\tgot := p.ExitStatus()\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"input %q: want %d, got %d\", tc.input, tc.want, got)\n\t\t}\n\t}\n\tgot := script.NewPipe().ExitStatus()\n\tif got != 0 {\n\t\tt.Errorf(\"want 0, got %d\", got)\n\t}\n}\n\nfunc TestReadProducesCompletePipeContents(t *testing.T) {\n\tt.Parallel()\n\twant := []byte(\"hello\")\n\tp := script.Echo(\"hello\")\n\tgot, err := io.ReadAll(p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestReadReturnsEOFOnUninitialisedPipe(t *testing.T) {\n\tt.Parallel()\n\tp := &script.Pipe{}\n\tbuf := []byte{0} // try to read at least 1 byte\n\tn, err := p.Read(buf)\n\tif !errors.Is(err, io.EOF) {\n\t\tt.Fatalf(\"want io.EOF, got %v\", err)\n\t}\n\tif n > 0 {\n\t\tt.Errorf(\"unexpectedly read %d bytes\", n)\n\t}\n}\n\nfunc TestReadReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\tbuf := make([]byte, 0)\n\t_, err := script.NewPipe().WithReader(brokenReader).Read(buf)\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestWait_ReturnsErrorPresentOnPipe(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"{{invalid template syntax}}\")\n\tif p.Wait() == nil {\n\t\tt.Error(\"want error, got nil\")\n\t}\n}\n\nfunc TestWait_DoesNotReturnErrorForValidExecution(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"echo \\\"{{.}}\\\"\")\n\tif err := p.Wait(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nvar base64Cases = []struct {\n\tname    string\n\tdecoded string\n\tencoded string\n}{\n\t{\n\t\tname:    \"empty string\",\n\t\tdecoded: \"\",\n\t\tencoded: \"\",\n\t},\n\t{\n\t\tname:    \"single line string\",\n\t\tdecoded: \"hello world\",\n\t\tencoded: \"aGVsbG8gd29ybGQ=\",\n\t},\n\t{\n\t\tname:    \"multi line string\",\n\t\tdecoded: \"hello\\nthere\\nworld\\n\",\n\t\tencoded: \"aGVsbG8KdGhlcmUKd29ybGQK\",\n\t},\n}\n\nfunc TestEncodeBase64_CorrectlyEncodes(t *testing.T) {\n\tt.Parallel()\n\tfor _, tc := range base64Cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := script.Echo(tc.decoded).EncodeBase64().String()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif got != tc.encoded {\n\t\t\t\tt.Logf(\"input %q incorrectly encoded:\", tc.decoded)\n\t\t\t\tt.Error(cmp.Diff(tc.encoded, got))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeBase64_CorrectlyDecodes(t *testing.T) {\n\tt.Parallel()\n\tfor _, tc := range base64Cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := script.Echo(tc.encoded).DecodeBase64().String()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif got != tc.decoded {\n\t\t\t\tt.Logf(\"input %q incorrectly decoded:\", tc.encoded)\n\t\t\t\tt.Error(cmp.Diff(tc.decoded, got))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEncodeBase64_FollowedByDecodeRecoversOriginal(t *testing.T) {\n\tt.Parallel()\n\tfor _, tc := range base64Cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdecoded, err := script.Echo(tc.decoded).EncodeBase64().DecodeBase64().String()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif decoded != tc.decoded {\n\t\t\t\tt.Error(\"encode-decode round trip failed:\", cmp.Diff(tc.decoded, decoded))\n\t\t\t}\n\t\t\tencoded, err := script.Echo(tc.encoded).DecodeBase64().EncodeBase64().String()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif encoded != tc.encoded {\n\t\t\t\tt.Error(\"decode-encode round trip failed:\", cmp.Diff(tc.encoded, encoded))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeBase64_CorrectlyDecodesInputToBytes(t *testing.T) {\n\tt.Parallel()\n\tinput := \"CAAAEA==\"\n\tgot, err := script.Echo(input).DecodeBase64().Bytes()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := []byte{8, 0, 0, 16}\n\tif !bytes.Equal(want, got) {\n\t\tt.Logf(\"input %#v incorrectly decoded:\", input)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestEncodeBase64_CorrectlyEncodesInputBytes(t *testing.T) {\n\tt.Parallel()\n\tinput := []byte{8, 0, 0, 16}\n\treader := bytes.NewReader(input)\n\twant := \"CAAAEA==\"\n\tgot, err := script.NewPipe().WithReader(reader).EncodeBase64().String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Logf(\"input %#v incorrectly encoded:\", input)\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestWithStdErr_IsConcurrencySafeAfterExec(t *testing.T) {\n\tt.Parallel()\n\terr := script.Exec(\"echo\").WithStderr(nil).Wait()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestHash_OutputsCorrectHash(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\tname, input, want string\n\t\thasher            hash.Hash\n\t}{\n\t\t{\n\t\t\tname:   \"for no data\",\n\t\t\tinput:  \"\",\n\t\t\thasher: sha256.New(),\n\t\t\twant:   \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n\t\t},\n\t\t{\n\t\t\tname:   \"for short string with SHA 256 hasher\",\n\t\t\tinput:  \"hello, world\",\n\t\t\thasher: sha256.New(),\n\t\t\twant:   \"09ca7e4eaa6e8ae9c7d261167129184883644d07dfba7cbfbc4c8a2e08360d5b\",\n\t\t},\n\t\t{\n\t\t\tname:   \"for short string with SHA 512 hasher\",\n\t\t\tinput:  \"hello, world\",\n\t\t\thasher: sha512.New(),\n\t\t\twant:   \"8710339dcb6814d0d9d2290ef422285c9322b7163951f9a0ca8f883d3305286f44139aa374848e4174f5aada663027e4548637b6d19894aec4fb6c46a139fbf9\",\n\t\t},\n\t\t{\n\t\t\tname:   \"for string containing newline with SHA 256 hasher\",\n\t\t\tinput:  \"The tao that can be told\\nis not the eternal Tao\",\n\t\t\thasher: sha256.New(),\n\t\t\twant:   \"788542cb92d37f67e187992bdb402fdfb68228a1802947f74c6576e04790a688\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := script.Echo(tc.input).Hash(tc.hasher)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"want %q, got %q\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHashSums_OutputsCorrectHashForEachSpecifiedFile(t *testing.T) {\n\tt.Parallel()\n\ttcs := []struct {\n\t\ttestFileName string\n\t\thasher       hash.Hash\n\t\twant         string\n\t}{\n\t\t// To get the checksum run: openssl dgst -sha256 <file_name>\n\t\t{\n\t\t\ttestFileName: \"testdata/hashSum.input.txt\",\n\t\t\thasher:       sha256.New(),\n\t\t\twant:         \"1870478d23b0b4db37735d917f4f0ff9393dd3e52d8b0efa852ab85536ddad8e\\n\",\n\t\t},\n\t\t{\n\t\t\ttestFileName: \"testdata/hashSum.input.txt\",\n\t\t\thasher:       sha512.New(),\n\t\t\twant:         \"3543bd0d68129e860598ccabcee1beb6bb90d91105cea74a8e555588634ec6f6d6d02033139972da2dc4929b1fb61bd24c91c8e82054e9ae865cf7f70909be8c\\n\",\n\t\t},\n\t\t{\n\t\t\ttestFileName: \"testdata/hello.txt\",\n\t\t\thasher:       sha256.New(),\n\t\t\twant:         \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\\n\",\n\t\t},\n\t\t{\n\t\t\ttestFileName: \"testdata/multiple_files\",\n\t\t\thasher:       sha256.New(),\n\t\t\twant:         \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\\n\",\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tgot, err := script.ListFiles(tc.testFileName).HashSums(tc.hasher).String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"%q: want %q, got %q\", tc.testFileName, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc TestHash_ReturnsErrorGivenReadErrorOnPipe(t *testing.T) {\n\tt.Parallel()\n\tbrokenReader := iotest.ErrReader(errors.New(\"oh no\"))\n\t_, err := script.NewPipe().WithReader(brokenReader).Hash(sha256.New())\n\tif err == nil {\n\t\tt.Fatal(nil)\n\t}\n}\n\nfunc TestHashSums_OutputsEmptyStringForFileThatCannotBeHashed(t *testing.T) {\n\tgot, err := script.Echo(\"file_does_not_exist.txt\").HashSums(sha256.New()).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"\"\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc ExampleArgs() {\n\tscript.Args().Stdout()\n\t// prints command-line arguments\n}\n\nfunc ExampleDo() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\treq, err := http.NewRequest(http.MethodGet, ts.URL, http.NoBody)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tscript.Do(req).Stdout()\n\t// Output:\n\t// some data\n}\n\nfunc ExampleEcho() {\n\tscript.Echo(\"Hello, world!\").Stdout()\n\t// Output:\n\t// Hello, world!\n}\n\nfunc ExampleExec_exit_status_zero() {\n\tp := script.Exec(\"echo\")\n\tp.Wait()\n\tfmt.Println(p.ExitStatus())\n\t// Output:\n\t// 0\n}\n\nfunc ExampleExec_exit_status_not_zero() {\n\tp := script.Exec(\"false\")\n\tp.Wait()\n\tfmt.Println(p.ExitStatus())\n\t// Output:\n\t// 1\n}\n\nfunc ExampleFile() {\n\tscript.File(\"testdata/hello.txt\").Stdout()\n\t// Output:\n\t// hello world\n}\n\nfunc ExampleGet() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"some data\")\n\t}))\n\tdefer ts.Close()\n\tscript.Get(ts.URL).Stdout()\n\t// Output:\n\t// some data\n}\n\nfunc ExampleIfExists_true() {\n\tscript.IfExists(\"./testdata/hello.txt\").Echo(\"found it\").Stdout()\n\t// Output:\n\t// found it\n}\n\nfunc ExampleIfExists_false() {\n\tscript.IfExists(\"doesntexist\").Echo(\"found it\").Stdout()\n\t// Output:\n\t//\n}\n\nfunc ExamplePipe_Bytes() {\n\tdata, err := script.Echo(\"hello\").Bytes()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(data)\n\t// Output:\n\t// [104 101 108 108 111]\n}\n\nfunc ExamplePipe_Column() {\n\tinput := []string{\n\t\t\"PID   TT  STAT      TIME COMMAND\",\n\t\t\"  1   ??  Ss   873:17.62 /sbin/launchd\",\n\t\t\" 50   ??  Ss    13:18.13 /usr/libexec/UserEventAgent (System)\",\n\t\t\" 51   ??  Ss    22:56.75 /usr/sbin/syslogd\",\n\t}\n\tscript.Slice(input).Column(1).Stdout()\n\t// Output:\n\t// PID\n\t// 1\n\t// 50\n\t// 51\n}\n\nfunc ExamplePipe_Concat() {\n\tinput := []string{\n\t\t\"testdata/test.txt\",\n\t\t\"testdata/doesntexist.txt\",\n\t\t\"testdata/hello.txt\",\n\t}\n\tscript.Slice(input).Concat().Stdout()\n\t// Output:\n\t// This is the first line in the file.\n\t// Hello, world.\n\t// This is another line in the file.\n\t// hello world\n}\n\nfunc ExamplePipe_CountLines() {\n\tn, err := script.Echo(\"a\\nb\\nc\\n\").CountLines()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(n)\n\t// Output:\n\t// 3\n}\n\nfunc ExamplePipe_DecodeBase64() {\n\tscript.Echo(\"SGVsbG8sIHdvcmxkIQ==\").DecodeBase64().Stdout()\n\t// Output:\n\t// Hello, world!\n}\n\nfunc ExamplePipe_Do() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Fprintf(w, \"You said: %s\", data)\n\t}))\n\tdefer ts.Close()\n\treq, err := http.NewRequest(http.MethodGet, ts.URL, strings.NewReader(\"hello\"))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tscript.NewPipe().Do(req).Stdout()\n\t// Output:\n\t// You said: hello\n}\n\nfunc ExamplePipe_EachLine() {\n\tscript.File(\"testdata/test.txt\").EachLine(func(line string, out *strings.Builder) {\n\t\tout.WriteString(\"> \" + line + \"\\n\")\n\t}).Stdout()\n\t// Output:\n\t// > This is the first line in the file.\n\t// > Hello, world.\n\t// > This is another line in the file.\n}\n\nfunc ExamplePipe_Echo() {\n\tscript.NewPipe().Echo(\"Hello, world!\").Stdout()\n\t// Output:\n\t// Hello, world!\n}\n\nfunc ExamplePipe_EncodeBase64() {\n\tscript.Echo(\"Hello, world!\").EncodeBase64().Stdout()\n\t// Output:\n\t// SGVsbG8sIHdvcmxkIQ==\n}\n\nfunc ExamplePipe_ExitStatus() {\n\tp := script.Exec(\"echo\")\n\tfmt.Println(p.ExitStatus())\n\t// Output:\n\t// 0\n}\n\nfunc ExamplePipe_First() {\n\tscript.Echo(\"a\\nb\\nc\\n\").First(2).Stdout()\n\t// Output:\n\t// a\n\t// b\n}\n\nfunc ExamplePipe_Filter() {\n\tscript.Echo(\"hello world\").Filter(func(r io.Reader, w io.Writer) error {\n\t\tn, err := io.Copy(w, r)\n\t\tfmt.Fprintf(w, \"\\nfiltered %d bytes\\n\", n)\n\t\treturn err\n\t}).Stdout()\n\t// Output:\n\t// hello world\n\t// filtered 11 bytes\n}\n\nfunc ExamplePipe_FilterScan() {\n\tscript.Echo(\"a\\nb\\nc\").FilterScan(func(line string, w io.Writer) {\n\t\tfmt.Fprintf(w, \"scanned line: %q\\n\", line)\n\t}).Stdout()\n\t// Output:\n\t// scanned line: \"a\"\n\t// scanned line: \"b\"\n\t// scanned line: \"c\"\n}\n\nfunc ExamplePipe_FilterLine_user() {\n\tscript.Echo(\"a\\nb\\nc\").FilterLine(func(line string) string {\n\t\treturn \"> \" + line\n\t}).Stdout()\n\t// Output:\n\t// > a\n\t// > b\n\t// > c\n}\n\nfunc ExamplePipe_FilterLine_stdlib() {\n\tscript.Echo(\"a\\nb\\nc\").FilterLine(strings.ToUpper).Stdout()\n\t// Output:\n\t// A\n\t// B\n\t// C\n}\n\nfunc ExamplePipe_Freq() {\n\tinput := strings.Join([]string{\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"banana\",\n\t\t\"banana\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"kumquat\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"apple\",\n\t\t\"banana\",\n\t\t\"banana\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"orange\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t\t\"apple\",\n\t}, \"\\n\")\n\tscript.Echo(input).Freq().Stdout()\n\t// Output:\n\t// 10 apple\n\t//  4 banana\n\t//  4 orange\n\t//  1 kumquat\n}\n\nfunc ExamplePipe_Get() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Fprintf(w, \"You said: %s\", data)\n\t}))\n\tdefer ts.Close()\n\tscript.Echo(\"hello\").Get(ts.URL).Stdout()\n\t// Output:\n\t// You said: hello\n}\n\nfunc ExamplePipe_Hash() {\n\tsum, err := script.Echo(\"hello world\").Hash(sha512.New())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(sum)\n\t// Output:\n\t// 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f\n}\n\nfunc ExamplePipe_HashSums() {\n\tscript.ListFiles(\"testdata/multiple_files\").HashSums(sha256.New()).Stdout()\n\t// Output:\n\t// e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n\t// e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n\t// e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n}\n\nfunc ExamplePipe_Join() {\n\tscript.Echo(\"hello\\nworld\\n\").Join().Stdout()\n\t// Output:\n\t// hello world\n}\n\nfunc ExamplePipe_JQ() {\n\tkernel := \"Darwin\"\n\tarch := \"x86_64\"\n\tquery := fmt.Sprintf(\".assets[] | select(.name | endswith(\\\"%s_%s.tar.gz\\\")).browser_download_url\", kernel, arch)\n\tscript.File(\"testdata/releases.json\").JQ(query).Stdout()\n\t// Output:\n\t// \"https://github.com/mbarley333/blackjack/releases/download/v0.3.3/blackjack_0.3.3_Darwin_x86_64.tar.gz\"\n}\n\nfunc ExamplePipe_Last() {\n\tscript.Echo(\"a\\nb\\nc\\n\").Last(2).Stdout()\n\t// Output:\n\t// b\n\t// c\n}\n\nfunc ExamplePipe_Match() {\n\tscript.Echo(\"a\\nb\\nc\\n\").Match(\"b\").Stdout()\n\t// Output:\n\t// b\n}\n\nfunc ExamplePipe_MatchRegexp() {\n\tre := regexp.MustCompile(\"w.*d\")\n\tscript.Echo(\"hello\\nworld\\n\").MatchRegexp(re).Stdout()\n\t// Output:\n\t// world\n}\n\nfunc ExamplePipe_Post() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Fprintf(w, \"You said: %s\", data)\n\t}))\n\tdefer ts.Close()\n\tscript.Echo(\"hello\").Post(ts.URL).Stdout()\n\t// Output:\n\t// You said: hello\n}\n\nfunc ExamplePipe_Read() {\n\tbuf := make([]byte, 12)\n\tn, err := script.Echo(\"hello world\\n\").Read(buf)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(n)\n\t// Output:\n\t// 12\n}\n\nfunc ExamplePipe_Reject() {\n\tscript.Echo(\"a\\nb\\nc\\n\").Reject(\"b\").Stdout()\n\t// Output:\n\t// a\n\t// c\n}\n\nfunc ExamplePipe_RejectRegexp() {\n\tre := regexp.MustCompile(\"w.*d\")\n\tscript.Echo(\"hello\\nworld\\n\").RejectRegexp(re).Stdout()\n\t// Output:\n\t// hello\n}\n\nfunc ExamplePipe_Replace() {\n\tscript.Echo(\"a\\nb\\nc\\n\").Replace(\"b\", \"replacement\").Stdout()\n\t// Output:\n\t// a\n\t// replacement\n\t// c\n}\n\nfunc ExamplePipe_ReplaceRegexp() {\n\tre := regexp.MustCompile(\"w.*d\")\n\tscript.Echo(\"hello\\nworld\\n\").ReplaceRegexp(re, \"replacement\").Stdout()\n\t// Output:\n\t// hello\n\t// replacement\n}\n\nfunc ExamplePipe_SHA256Sum() {\n\tsum, err := script.Echo(\"hello world\").SHA256Sum()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(sum)\n\t// Output:\n\t// b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n}\n\nfunc ExamplePipe_SHA256Sums() {\n\tscript.Echo(\"testdata/test.txt\").SHA256Sums().Stdout()\n\t// Output:\n\t// a562c9c95e2ff3403e7ffcd8508c6b54d47d5f251387758d3e63dbaaa8296341\n}\n\nfunc ExamplePipe_Slice() {\n\ts, err := script.Echo(\"a\\nb\\nc\\n\").Slice()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(s)\n\t// Output:\n\t// [a b c]\n}\n\nfunc ExamplePipe_Stdout() {\n\tn, err := script.Echo(\"a\\nb\\nc\\n\").Stdout()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(n)\n\t// Output:\n\t// a\n\t// b\n\t// c\n\t// 6\n}\n\nfunc ExamplePipe_String() {\n\ts, err := script.Echo(\"hello\\nworld\").String()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(s)\n\t// Output:\n\t// hello\n\t// world\n}\n\nfunc ExamplePipe_Tee_stdout() {\n\ts, err := script.Echo(\"hello\\n\").Tee().String()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(s)\n\t// Output:\n\t// hello\n\t// hello\n}\n\nfunc ExamplePipe_Tee_writers() {\n\tbuf1, buf2 := new(bytes.Buffer), new(bytes.Buffer)\n\ts, err := script.Echo(\"hello\\n\").Tee(buf1, buf2).String()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Print(s)\n\tfmt.Print(buf1.String())\n\tfmt.Print(buf2.String())\n\t// Output:\n\t// hello\n\t// hello\n\t// hello\n}\n\nfunc ExamplePipe_WithStderr() {\n\tbuf := new(bytes.Buffer)\n\tscript.NewPipe().WithStderr(buf).Exec(\"go\").Wait()\n\tfmt.Println(strings.Contains(buf.String(), \"Usage\"))\n\t// Output:\n\t// true\n}\n\nfunc ExampleSlice() {\n\tinput := []string{\"1\", \"2\", \"3\"}\n\tscript.Slice(input).Stdout()\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n}\n\n// A string containing a line longer than bufio.MaxScanTokenSize, for testing\n// methods that buffer input. We want to make sure they don't throw\n// \"bufio.Scanner: token too long\" errors.\nvar longLine = strings.Repeat(\"super long line \", 4096) + \"\\nlast line\\n\"\n"
        },
        {
          "name": "script_unix_test.go",
          "type": "blob",
          "size": 4.6376953125,
          "content": "//go:build !windows\n\npackage script_test\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/bitfield/script\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestExecForEach_HandlesLongLines(t *testing.T) {\n\tt.Parallel()\n\tgot, err := script.Echo(longLine).ExecForEach(`echo \"{{.}}\"`).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif longLine != got {\n\t\tt.Error(cmp.Diff(longLine, got))\n\t}\n}\n\nfunc TestExecRunsShWithEchoHelloAndGetsOutputHello(t *testing.T) {\n\tt.Parallel()\n\tp := script.Exec(\"sh -c 'echo hello'\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\twant := \"hello\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestExecRunsShWithinShWithEchoInceptionAndGetsOutputInception(t *testing.T) {\n\tt.Parallel()\n\tp := script.Exec(\"sh -c 'sh -c \\\"echo inception\\\"'\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\twant := \"inception\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestExecErrorsRunningShellCommandWithUnterminatedStringArgument(t *testing.T) {\n\tt.Parallel()\n\tp := script.Exec(\"sh -c 'echo oh no\")\n\tp.Wait()\n\tif p.Error() == nil {\n\t\tt.Error(\"want error running 'sh' command line containing unterminated string\")\n\t}\n}\n\nfunc TestExecForEach_RunsEchoWithABCAndGetsOutputABC(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"echo {{.}}\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\twant := \"a\\nb\\nc\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestExecForEach_CorrectlyEvaluatesTemplateContainingIfStatement(t *testing.T) {\n\tt.Parallel()\n\tp := script.Echo(\"a\").ExecForEach(\"echo {{if .}}it worked!{{end}}\")\n\tif p.Error() != nil {\n\t\tt.Fatal(p.Error())\n\t}\n\twant := \"it worked!\\n\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestExecPipesDataToExternalCommandAndGetsExpectedOutput(t *testing.T) {\n\tt.Parallel()\n\tp := script.File(\"testdata/hello.txt\").Exec(\"cat\")\n\twant := \"hello world\"\n\tgot, err := p.String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want != got {\n\t\tt.Error(cmp.Diff(want, got))\n\t}\n}\n\nfunc TestFindFiles_DoesNotErrorWhenSubDirectoryIsNotReadable(t *testing.T) {\n\tt.Parallel()\n\ttmpDir := t.TempDir()\n\trestrictedDirPath := filepath.Join(tmpDir, \"a_restricted_dir\")\n\tif err := os.Mkdir(restrictedDirPath, 0o000); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfileAPath := filepath.Join(tmpDir, \"file_a.txt\")\n\tif err := os.WriteFile(fileAPath, []byte(\"hello world!\"), os.ModePerm); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := script.FindFiles(tmpDir).String()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := fileAPath + \"\\n\"\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !cmp.Equal(want, got) {\n\t\tt.Fatal(cmp.Diff(want, got))\n\t}\n}\n\nfunc ExampleExec_ok() {\n\tscript.Exec(\"echo Hello, world!\").Stdout()\n\t// Output:\n\t// Hello, world!\n}\n\nfunc ExampleFindFiles() {\n\tscript.FindFiles(\"testdata/multiple_files_with_subdirectory\").Stdout()\n\t// Output:\n\t// testdata/multiple_files_with_subdirectory/1.txt\n\t// testdata/multiple_files_with_subdirectory/2.txt\n\t// testdata/multiple_files_with_subdirectory/3.tar.zip\n\t// testdata/multiple_files_with_subdirectory/dir/.hidden\n\t// testdata/multiple_files_with_subdirectory/dir/1.txt\n\t// testdata/multiple_files_with_subdirectory/dir/2.txt\n}\n\nfunc ExampleIfExists_exec() {\n\tscript.IfExists(\"./testdata/hello.txt\").Exec(\"echo hello\").Stdout()\n\t// Output:\n\t// hello\n}\n\nfunc ExampleIfExists_noExec() {\n\tscript.IfExists(\"doesntexist\").Exec(\"echo hello\").Stdout()\n\t// Output:\n\t//\n}\n\nfunc ExampleListFiles() {\n\tscript.ListFiles(\"testdata/multiple_files_with_subdirectory\").Stdout()\n\t// Output:\n\t// testdata/multiple_files_with_subdirectory/1.txt\n\t// testdata/multiple_files_with_subdirectory/2.txt\n\t// testdata/multiple_files_with_subdirectory/3.tar.zip\n\t// testdata/multiple_files_with_subdirectory/dir\n}\n\nfunc ExamplePipe_Basename() {\n\tinput := []string{\n\t\t\"\",\n\t\t\"/\",\n\t\t\"/root\",\n\t\t\"/tmp/example.php\",\n\t\t\"/var/tmp/\",\n\t\t\"./src/filters\",\n\t\t\"C:/Program Files\",\n\t}\n\tscript.Slice(input).Basename().Stdout()\n\t// Output:\n\t// .\n\t// /\n\t// root\n\t// example.php\n\t// tmp\n\t// filters\n\t// Program Files\n}\n\nfunc ExamplePipe_Dirname() {\n\tinput := []string{\n\t\t\"\",\n\t\t\"/\",\n\t\t\"/root\",\n\t\t\"/tmp/example.php\",\n\t\t\"/var/tmp/\",\n\t\t\"./src/filters\",\n\t\t\"C:/Program Files\",\n\t}\n\tscript.Slice(input).Dirname().Stdout()\n\t// Output:\n\t// .\n\t// /\n\t// /\n\t// /tmp\n\t// /var\n\t// ./src\n\t// C:\n}\n\nfunc ExamplePipe_Exec() {\n\tscript.Echo(\"Hello, world!\").Exec(\"tr a-z A-Z\").Stdout()\n\t// Output:\n\t// HELLO, WORLD!\n}\n\nfunc ExamplePipe_ExecForEach() {\n\tscript.Echo(\"a\\nb\\nc\\n\").ExecForEach(\"echo {{.}}\").Stdout()\n\t// Output:\n\t// a\n\t// b\n\t// c\n}\n"
        },
        {
          "name": "script_windows_test.go",
          "type": "blob",
          "size": 1.9384765625,
          "content": "package script_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/bitfield/script\"\n)\n\nfunc TestDirnameReturnsExpectedResultsOnPlatformsWithBackslashPathSeparator(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{`C:\\`, \"C:\\\\\\n\"},\n\t\t{`C:\\a\\b`, \"C:\\\\a\\n\"},\n\t\t{`C:a\\b`, \"C:a\\n\"},\n\t\t{`\\\\host\\share`, \"\\\\\\\\host\\\\share\\n\"},\n\t\t{`\\\\host\\share\\a\\b`, \"\\\\\\\\host\\\\share\\\\a\\n\"},\n\t\t{`C:\\Program Files\\PHP\\a`, \"C:\\\\Program Files\\\\PHP\\n\"},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot, err := script.Echo(tc.path).Dirname().String()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif tc.want != got {\n\t\t\tt.Errorf(\"%q: want %q, got %q\", tc.path, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc ExampleFindFiles() {\n\tscript.FindFiles(\"testdata/multiple_files_with_subdirectory\").Stdout()\n\t// Output:\n\t// testdata\\multiple_files_with_subdirectory\\1.txt\n\t// testdata\\multiple_files_with_subdirectory\\2.txt\n\t// testdata\\multiple_files_with_subdirectory\\3.tar.zip\n\t// testdata\\multiple_files_with_subdirectory\\dir\\.hidden\n\t// testdata\\multiple_files_with_subdirectory\\dir\\1.txt\n\t// testdata\\multiple_files_with_subdirectory\\dir\\2.txt\n}\n\nfunc ExampleListFiles() {\n\tscript.ListFiles(\"testdata/multiple_files_with_subdirectory\").Stdout()\n\t// Output:\n\t// testdata\\multiple_files_with_subdirectory\\1.txt\n\t// testdata\\multiple_files_with_subdirectory\\2.txt\n\t// testdata\\multiple_files_with_subdirectory\\3.tar.zip\n\t// testdata\\multiple_files_with_subdirectory\\dir\n}\n\nfunc ExamplePipe_Basename() {\n\tinput := []string{\n\t\t\"\",\n\t\t\"/\",\n\t\t\"/root\",\n\t\t\"/tmp/example.php\",\n\t\t\"/var/tmp/\",\n\t\t\"./src/filters\",\n\t\t\"C:\\\\Program Files\",\n\t}\n\tscript.Slice(input).Basename().Stdout()\n\t// Output:\n\t// .\n\t// \\\n\t// root\n\t// example.php\n\t// tmp\n\t// filters\n\t// Program Files\n}\n\nfunc ExamplePipe_Dirname() {\n\tinput := []string{\n\t\t\"\",\n\t\t\"/\",\n\t\t\"/root\",\n\t\t\"/tmp/example.php\",\n\t\t\"/var/tmp/\",\n\t\t\"./src/filters\",\n\t\t\"C:/Program Files\",\n\t}\n\tscript.Slice(input).Dirname().Stdout()\n\t// Output:\n\t// .\n\t// \\\n\t// \\\n\t// \\tmp\n\t// \\var\n\t// ./src\n\t// C:\\\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}