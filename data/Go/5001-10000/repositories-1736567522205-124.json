{
  "metadata": {
    "timestamp": 1736567522205,
    "page": 124,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mitchellh/mapstructure",
      "stars": 7949,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.0615234375,
          "content": "## 1.5.1\n\n* Wrap errors so they're compatible with `errors.Is` and `errors.As` [GH-282]\n* Fix map of slices not decoding properly in certain cases. [GH-266]\n\n## 1.5.0\n\n* New option `IgnoreUntaggedFields` to ignore decoding to any fields\n  without `mapstructure` (or the configured tag name) set [GH-277]\n* New option `ErrorUnset` which makes it an error if any fields\n  in a target struct are not set by the decoding process. [GH-225]\n* New function `OrComposeDecodeHookFunc` to help compose decode hooks. [GH-240]\n* Decoding to slice from array no longer crashes [GH-265]\n* Decode nested struct pointers to map [GH-271]\n* Fix issue where `,squash` was ignored if `Squash` option was set. [GH-280]\n* Fix issue where fields with `,omitempty` would sometimes decode\n  into a map with an empty string key [GH-281]\n\n## 1.4.3\n\n* Fix cases where `json.Number` didn't decode properly [GH-261]\n\n## 1.4.2\n\n* Custom name matchers to support any sort of casing, formatting, etc. for\n  field names. [GH-250]\n* Fix possible panic in ComposeDecodeHookFunc [GH-251]\n\n## 1.4.1\n\n* Fix regression where `*time.Time` value would be set to empty and not be sent\n  to decode hooks properly [GH-232]\n\n## 1.4.0\n\n* A new decode hook type `DecodeHookFuncValue` has been added that has\n  access to the full values. [GH-183]\n* Squash is now supported with embedded fields that are struct pointers [GH-205]\n* Empty strings will convert to 0 for all numeric types when weakly decoding [GH-206]\n\n## 1.3.3\n\n* Decoding maps from maps creates a settable value for decode hooks [GH-203]\n\n## 1.3.2\n\n* Decode into interface type with a struct value is supported [GH-187]\n\n## 1.3.1\n\n* Squash should only squash embedded structs. [GH-194]\n\n## 1.3.0\n\n* Added `\",omitempty\"` support. This will ignore zero values in the source\n  structure when encoding. [GH-145]\n\n## 1.2.3\n\n* Fix duplicate entries in Keys list with pointer values. [GH-185]\n\n## 1.2.2\n\n* Do not add unsettable (unexported) values to the unused metadata key\n  or \"remain\" value. [GH-150]\n\n## 1.2.1\n\n* Go modules checksum mismatch fix\n\n## 1.2.0\n\n* Added support to capture unused values in a field using the `\",remain\"` value\n  in the mapstructure tag. There is an example to showcase usage.\n* Added `DecoderConfig` option to always squash embedded structs\n* `json.Number` can decode into `uint` types\n* Empty slices are preserved and not replaced with nil slices\n* Fix panic that can occur in when decoding a map into a nil slice of structs\n* Improved package documentation for godoc\n\n## 1.1.2\n\n* Fix error when decode hook decodes interface implementation into interface\n  type. [GH-140]\n\n## 1.1.1\n\n* Fix panic that can happen in `decodePtr`\n\n## 1.1.0\n\n* Added `StringToIPHookFunc` to convert `string` to `net.IP` and `net.IPNet` [GH-133]\n* Support struct to struct decoding [GH-137]\n* If source map value is nil, then destination map value is nil (instead of empty)\n* If source slice value is nil, then destination slice value is nil (instead of empty)\n* If source pointer is nil, then destination pointer is set to nil (instead of\n  allocated zero value of type)\n\n## 1.0.0\n\n* Initial tagged stable release.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Mitchell Hashimoto\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.638671875,
          "content": "# mapstructure [![Godoc](https://godoc.org/github.com/mitchellh/mapstructure?status.svg)](https://godoc.org/github.com/mitchellh/mapstructure)\n\nmapstructure is a Go library for decoding generic map values to structures\nand vice versa, while providing helpful error handling.\n\nThis library is most useful when decoding values from some data stream (JSON,\nGob, etc.) where you don't _quite_ know the structure of the underlying data\nuntil you read a part of it. You can therefore read a `map[string]interface{}`\nand use this library to decode it into the proper underlying native Go\nstructure.\n\n## Installation\n\nStandard `go get`:\n\n```\n$ go get github.com/mitchellh/mapstructure\n```\n\n## Usage & Example\n\nFor usage and examples see the [Godoc](http://godoc.org/github.com/mitchellh/mapstructure).\n\nThe `Decode` function has examples associated with it there.\n\n## But Why?!\n\nGo offers fantastic standard libraries for decoding formats such as JSON.\nThe standard method is to have a struct pre-created, and populate that struct\nfrom the bytes of the encoded format. This is great, but the problem is if\nyou have configuration or an encoding that changes slightly depending on\nspecific fields. For example, consider this JSON:\n\n```json\n{\n  \"type\": \"person\",\n  \"name\": \"Mitchell\"\n}\n```\n\nPerhaps we can't populate a specific structure without first reading\nthe \"type\" field from the JSON. We could always do two passes over the\ndecoding of the JSON (reading the \"type\" first, and the rest later).\nHowever, it is much simpler to just decode this into a `map[string]interface{}`\nstructure, read the \"type\" key, then use something like this library\nto decode it into the proper structure.\n"
        },
        {
          "name": "decode_hooks.go",
          "type": "blob",
          "size": 6.841796875,
          "content": "package mapstructure\n\nimport (\n\t\"encoding\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// typedDecodeHook takes a raw DecodeHookFunc (an interface{}) and turns\n// it into the proper DecodeHookFunc type, such as DecodeHookFuncType.\nfunc typedDecodeHook(h DecodeHookFunc) DecodeHookFunc {\n\t// Create variables here so we can reference them with the reflect pkg\n\tvar f1 DecodeHookFuncType\n\tvar f2 DecodeHookFuncKind\n\tvar f3 DecodeHookFuncValue\n\n\t// Fill in the variables into this interface and the rest is done\n\t// automatically using the reflect package.\n\tpotential := []interface{}{f1, f2, f3}\n\n\tv := reflect.ValueOf(h)\n\tvt := v.Type()\n\tfor _, raw := range potential {\n\t\tpt := reflect.ValueOf(raw).Type()\n\t\tif vt.ConvertibleTo(pt) {\n\t\t\treturn v.Convert(pt).Interface()\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// DecodeHookExec executes the given decode hook. This should be used\n// since it'll naturally degrade to the older backwards compatible DecodeHookFunc\n// that took reflect.Kind instead of reflect.Type.\nfunc DecodeHookExec(\n\traw DecodeHookFunc,\n\tfrom reflect.Value, to reflect.Value) (interface{}, error) {\n\n\tswitch f := typedDecodeHook(raw).(type) {\n\tcase DecodeHookFuncType:\n\t\treturn f(from.Type(), to.Type(), from.Interface())\n\tcase DecodeHookFuncKind:\n\t\treturn f(from.Kind(), to.Kind(), from.Interface())\n\tcase DecodeHookFuncValue:\n\t\treturn f(from, to)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid decode hook signature\")\n\t}\n}\n\n// ComposeDecodeHookFunc creates a single DecodeHookFunc that\n// automatically composes multiple DecodeHookFuncs.\n//\n// The composed funcs are called in order, with the result of the\n// previous transformation.\nfunc ComposeDecodeHookFunc(fs ...DecodeHookFunc) DecodeHookFunc {\n\treturn func(f reflect.Value, t reflect.Value) (interface{}, error) {\n\t\tvar err error\n\t\tdata := f.Interface()\n\n\t\tnewFrom := f\n\t\tfor _, f1 := range fs {\n\t\t\tdata, err = DecodeHookExec(f1, newFrom, t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tnewFrom = reflect.ValueOf(data)\n\t\t}\n\n\t\treturn data, nil\n\t}\n}\n\n// OrComposeDecodeHookFunc executes all input hook functions until one of them returns no error. In that case its value is returned.\n// If all hooks return an error, OrComposeDecodeHookFunc returns an error concatenating all error messages.\nfunc OrComposeDecodeHookFunc(ff ...DecodeHookFunc) DecodeHookFunc {\n\treturn func(a, b reflect.Value) (interface{}, error) {\n\t\tvar allErrs string\n\t\tvar out interface{}\n\t\tvar err error\n\n\t\tfor _, f := range ff {\n\t\t\tout, err = DecodeHookExec(f, a, b)\n\t\t\tif err != nil {\n\t\t\t\tallErrs += err.Error() + \"\\n\"\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn out, nil\n\t\t}\n\n\t\treturn nil, errors.New(allErrs)\n\t}\n}\n\n// StringToSliceHookFunc returns a DecodeHookFunc that converts\n// string to []string by splitting on the given sep.\nfunc StringToSliceHookFunc(sep string) DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f != reflect.String || t != reflect.Slice {\n\t\t\treturn data, nil\n\t\t}\n\n\t\traw := data.(string)\n\t\tif raw == \"\" {\n\t\t\treturn []string{}, nil\n\t\t}\n\n\t\treturn strings.Split(raw, sep), nil\n\t}\n}\n\n// StringToTimeDurationHookFunc returns a DecodeHookFunc that converts\n// strings to time.Duration.\nfunc StringToTimeDurationHookFunc() DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tif t != reflect.TypeOf(time.Duration(5)) {\n\t\t\treturn data, nil\n\t\t}\n\n\t\t// Convert it by parsing\n\t\treturn time.ParseDuration(data.(string))\n\t}\n}\n\n// StringToIPHookFunc returns a DecodeHookFunc that converts\n// strings to net.IP\nfunc StringToIPHookFunc() DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tif t != reflect.TypeOf(net.IP{}) {\n\t\t\treturn data, nil\n\t\t}\n\n\t\t// Convert it by parsing\n\t\tip := net.ParseIP(data.(string))\n\t\tif ip == nil {\n\t\t\treturn net.IP{}, fmt.Errorf(\"failed parsing ip %v\", data)\n\t\t}\n\n\t\treturn ip, nil\n\t}\n}\n\n// StringToIPNetHookFunc returns a DecodeHookFunc that converts\n// strings to net.IPNet\nfunc StringToIPNetHookFunc() DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tif t != reflect.TypeOf(net.IPNet{}) {\n\t\t\treturn data, nil\n\t\t}\n\n\t\t// Convert it by parsing\n\t\t_, net, err := net.ParseCIDR(data.(string))\n\t\treturn net, err\n\t}\n}\n\n// StringToTimeHookFunc returns a DecodeHookFunc that converts\n// strings to time.Time.\nfunc StringToTimeHookFunc(layout string) DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tif t != reflect.TypeOf(time.Time{}) {\n\t\t\treturn data, nil\n\t\t}\n\n\t\t// Convert it by parsing\n\t\treturn time.Parse(layout, data.(string))\n\t}\n}\n\n// WeaklyTypedHook is a DecodeHookFunc which adds support for weak typing to\n// the decoder.\n//\n// Note that this is significantly different from the WeaklyTypedInput option\n// of the DecoderConfig.\nfunc WeaklyTypedHook(\n\tf reflect.Kind,\n\tt reflect.Kind,\n\tdata interface{}) (interface{}, error) {\n\tdataVal := reflect.ValueOf(data)\n\tswitch t {\n\tcase reflect.String:\n\t\tswitch f {\n\t\tcase reflect.Bool:\n\t\t\tif dataVal.Bool() {\n\t\t\t\treturn \"1\", nil\n\t\t\t}\n\t\t\treturn \"0\", nil\n\t\tcase reflect.Float32:\n\t\t\treturn strconv.FormatFloat(dataVal.Float(), 'f', -1, 64), nil\n\t\tcase reflect.Int:\n\t\t\treturn strconv.FormatInt(dataVal.Int(), 10), nil\n\t\tcase reflect.Slice:\n\t\t\tdataType := dataVal.Type()\n\t\t\telemKind := dataType.Elem().Kind()\n\t\t\tif elemKind == reflect.Uint8 {\n\t\t\t\treturn string(dataVal.Interface().([]uint8)), nil\n\t\t\t}\n\t\tcase reflect.Uint:\n\t\t\treturn strconv.FormatUint(dataVal.Uint(), 10), nil\n\t\t}\n\t}\n\n\treturn data, nil\n}\n\nfunc RecursiveStructToMapHookFunc() DecodeHookFunc {\n\treturn func(f reflect.Value, t reflect.Value) (interface{}, error) {\n\t\tif f.Kind() != reflect.Struct {\n\t\t\treturn f.Interface(), nil\n\t\t}\n\n\t\tvar i interface{} = struct{}{}\n\t\tif t.Type() != reflect.TypeOf(&i).Elem() {\n\t\t\treturn f.Interface(), nil\n\t\t}\n\n\t\tm := make(map[string]interface{})\n\t\tt.Set(reflect.ValueOf(m))\n\n\t\treturn f.Interface(), nil\n\t}\n}\n\n// TextUnmarshallerHookFunc returns a DecodeHookFunc that applies\n// strings to the UnmarshalText function, when the target type\n// implements the encoding.TextUnmarshaler interface\nfunc TextUnmarshallerHookFunc() DecodeHookFuncType {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{}) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tresult := reflect.New(t).Interface()\n\t\tunmarshaller, ok := result.(encoding.TextUnmarshaler)\n\t\tif !ok {\n\t\t\treturn data, nil\n\t\t}\n\t\tstr, ok := data.(string)\n\t\tif !ok {\n\t\t\tstr = reflect.Indirect(reflect.ValueOf(&data)).Elem().String()\n\t\t}\n\t\tif err := unmarshaller.UnmarshalText([]byte(str)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\t}\n}\n"
        },
        {
          "name": "decode_hooks_test.go",
          "type": "blob",
          "size": 11.171875,
          "content": "package mapstructure\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"math/big\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestComposeDecodeHookFunc(t *testing.T) {\n\tf1 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn data.(string) + \"foo\", nil\n\t}\n\n\tf2 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn data.(string) + \"bar\", nil\n\t}\n\n\tf := ComposeDecodeHookFunc(f1, f2)\n\n\tresult, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\tif result.(string) != \"foobar\" {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestComposeDecodeHookFunc_err(t *testing.T) {\n\tf1 := func(reflect.Kind, reflect.Kind, interface{}) (interface{}, error) {\n\t\treturn nil, errors.New(\"foo\")\n\t}\n\n\tf2 := func(reflect.Kind, reflect.Kind, interface{}) (interface{}, error) {\n\t\tpanic(\"NOPE\")\n\t}\n\n\tf := ComposeDecodeHookFunc(f1, f2)\n\n\t_, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err.Error() != \"foo\" {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n}\n\nfunc TestComposeDecodeHookFunc_kinds(t *testing.T) {\n\tvar f2From reflect.Kind\n\n\tf1 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn int(42), nil\n\t}\n\n\tf2 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\tf2From = f\n\t\treturn data, nil\n\t}\n\n\tf := ComposeDecodeHookFunc(f1, f2)\n\n\t_, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\tif f2From != reflect.Int {\n\t\tt.Fatalf(\"bad: %#v\", f2From)\n\t}\n}\n\nfunc TestOrComposeDecodeHookFunc(t *testing.T) {\n\tf1 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn data.(string) + \"foo\", nil\n\t}\n\n\tf2 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn data.(string) + \"bar\", nil\n\t}\n\n\tf := OrComposeDecodeHookFunc(f1, f2)\n\n\tresult, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\tif result.(string) != \"foo\" {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestOrComposeDecodeHookFunc_correctValueIsLast(t *testing.T) {\n\tf1 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn nil, errors.New(\"f1 error\")\n\t}\n\n\tf2 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn nil, errors.New(\"f2 error\")\n\t}\n\n\tf3 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn data.(string) + \"bar\", nil\n\t}\n\n\tf := OrComposeDecodeHookFunc(f1, f2, f3)\n\n\tresult, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\tif result.(string) != \"bar\" {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestOrComposeDecodeHookFunc_err(t *testing.T) {\n\tf1 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn nil, errors.New(\"f1 error\")\n\t}\n\n\tf2 := func(\n\t\tf reflect.Kind,\n\t\tt reflect.Kind,\n\t\tdata interface{}) (interface{}, error) {\n\t\treturn nil, errors.New(\"f2 error\")\n\t}\n\n\tf := OrComposeDecodeHookFunc(f1, f2)\n\n\t_, err := DecodeHookExec(\n\t\tf, reflect.ValueOf(\"\"), reflect.ValueOf([]byte(\"\")))\n\tif err == nil {\n\t\tt.Fatalf(\"bad: should return an error\")\n\t}\n\tif err.Error() != \"f1 error\\nf2 error\\n\" {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n}\n\nfunc TestComposeDecodeHookFunc_safe_nofuncs(t *testing.T) {\n\tf := ComposeDecodeHookFunc()\n\ttype myStruct2 struct {\n\t\tMyInt int\n\t}\n\n\ttype myStruct1 struct {\n\t\tBlah map[string]myStruct2\n\t}\n\n\tsrc := &myStruct1{Blah: map[string]myStruct2{\n\t\t\"test\": {\n\t\t\tMyInt: 1,\n\t\t},\n\t}}\n\n\tdst := &myStruct1{}\n\tdConf := &DecoderConfig{\n\t\tResult:      dst,\n\t\tErrorUnused: true,\n\t\tDecodeHook:  f,\n\t}\n\td, err := NewDecoder(dConf)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = d.Decode(src)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestStringToSliceHookFunc(t *testing.T) {\n\tf := StringToSliceHookFunc(\",\")\n\n\tstrValue := reflect.ValueOf(\"42\")\n\tsliceValue := reflect.ValueOf([]byte(\"42\"))\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{sliceValue, sliceValue, []byte(\"42\"), false},\n\t\t{strValue, strValue, \"42\", false},\n\t\t{\n\t\t\treflect.ValueOf(\"foo,bar,baz\"),\n\t\t\tsliceValue,\n\t\t\t[]string{\"foo\", \"bar\", \"baz\"},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\treflect.ValueOf(\"\"),\n\t\t\tsliceValue,\n\t\t\t[]string{},\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, tc := range cases {\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestStringToTimeDurationHookFunc(t *testing.T) {\n\tf := StringToTimeDurationHookFunc()\n\n\ttimeValue := reflect.ValueOf(time.Duration(5))\n\tstrValue := reflect.ValueOf(\"\")\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{reflect.ValueOf(\"5s\"), timeValue, 5 * time.Second, false},\n\t\t{reflect.ValueOf(\"5\"), timeValue, time.Duration(0), true},\n\t\t{reflect.ValueOf(\"5\"), strValue, \"5\", false},\n\t}\n\n\tfor i, tc := range cases {\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestStringToTimeHookFunc(t *testing.T) {\n\tstrValue := reflect.ValueOf(\"5\")\n\ttimeValue := reflect.ValueOf(time.Time{})\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tlayout string\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{reflect.ValueOf(\"2006-01-02T15:04:05Z\"), timeValue, time.RFC3339,\n\t\t\ttime.Date(2006, 1, 2, 15, 4, 5, 0, time.UTC), false},\n\t\t{strValue, timeValue, time.RFC3339, time.Time{}, true},\n\t\t{strValue, strValue, time.RFC3339, \"5\", false},\n\t}\n\n\tfor i, tc := range cases {\n\t\tf := StringToTimeHookFunc(tc.layout)\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestStringToIPHookFunc(t *testing.T) {\n\tstrValue := reflect.ValueOf(\"5\")\n\tipValue := reflect.ValueOf(net.IP{})\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{reflect.ValueOf(\"1.2.3.4\"), ipValue,\n\t\t\tnet.IPv4(0x01, 0x02, 0x03, 0x04), false},\n\t\t{strValue, ipValue, net.IP{}, true},\n\t\t{strValue, strValue, \"5\", false},\n\t}\n\n\tfor i, tc := range cases {\n\t\tf := StringToIPHookFunc()\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestStringToIPNetHookFunc(t *testing.T) {\n\tstrValue := reflect.ValueOf(\"5\")\n\tipNetValue := reflect.ValueOf(net.IPNet{})\n\tvar nilNet *net.IPNet = nil\n\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{reflect.ValueOf(\"1.2.3.4/24\"), ipNetValue,\n\t\t\t&net.IPNet{\n\t\t\t\tIP:   net.IP{0x01, 0x02, 0x03, 0x00},\n\t\t\t\tMask: net.IPv4Mask(0xff, 0xff, 0xff, 0x00),\n\t\t\t}, false},\n\t\t{strValue, ipNetValue, nilNet, true},\n\t\t{strValue, strValue, \"5\", false},\n\t}\n\n\tfor i, tc := range cases {\n\t\tf := StringToIPNetHookFunc()\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestWeaklyTypedHook(t *testing.T) {\n\tvar f DecodeHookFunc = WeaklyTypedHook\n\n\tstrValue := reflect.ValueOf(\"\")\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t// TO STRING\n\t\t{\n\t\t\treflect.ValueOf(false),\n\t\t\tstrValue,\n\t\t\t\"0\",\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\treflect.ValueOf(true),\n\t\t\tstrValue,\n\t\t\t\"1\",\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\treflect.ValueOf(float32(7)),\n\t\t\tstrValue,\n\t\t\t\"7\",\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\treflect.ValueOf(int(7)),\n\t\t\tstrValue,\n\t\t\t\"7\",\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\treflect.ValueOf([]uint8(\"foo\")),\n\t\t\tstrValue,\n\t\t\t\"foo\",\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\treflect.ValueOf(uint(7)),\n\t\t\tstrValue,\n\t\t\t\"7\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, tc := range cases {\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n\nfunc TestStructToMapHookFuncTabled(t *testing.T) {\n\tvar f DecodeHookFunc = RecursiveStructToMapHookFunc()\n\n\ttype b struct {\n\t\tTestKey string\n\t}\n\n\ttype a struct {\n\t\tSub b\n\t}\n\n\ttestStruct := a{\n\t\tSub: b{\n\t\t\tTestKey: \"testval\",\n\t\t},\n\t}\n\n\ttestMap := map[string]interface{}{\n\t\t\"Sub\": map[string]interface{}{\n\t\t\t\"TestKey\": \"testval\",\n\t\t},\n\t}\n\n\tcases := []struct {\n\t\tname     string\n\t\treceiver interface{}\n\t\tinput    interface{}\n\t\texpected interface{}\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\t\"map receiver\",\n\t\t\tfunc() interface{} {\n\t\t\t\tvar res map[string]interface{}\n\t\t\t\treturn &res\n\t\t\t}(),\n\t\t\ttestStruct,\n\t\t\t&testMap,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"interface receiver\",\n\t\t\tfunc() interface{} {\n\t\t\t\tvar res interface{}\n\t\t\t\treturn &res\n\t\t\t}(),\n\t\t\ttestStruct,\n\t\t\tfunc() interface{} {\n\t\t\t\tvar exp interface{} = testMap\n\t\t\t\treturn &exp\n\t\t\t}(),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"slice receiver errors\",\n\t\t\tfunc() interface{} {\n\t\t\t\tvar res []string\n\t\t\t\treturn &res\n\t\t\t}(),\n\t\t\ttestStruct,\n\t\t\tnew([]string),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"slice to slice - no change\",\n\t\t\tfunc() interface{} {\n\t\t\t\tvar res []string\n\t\t\t\treturn &res\n\t\t\t}(),\n\t\t\t[]string{\"a\", \"b\"},\n\t\t\t&[]string{\"a\", \"b\"},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"string to string - no change\",\n\t\t\tfunc() interface{} {\n\t\t\t\tvar res string\n\t\t\t\treturn &res\n\t\t\t}(),\n\t\t\t\"test\",\n\t\t\tfunc() *string {\n\t\t\t\ts := \"test\"\n\t\t\t\treturn &s\n\t\t\t}(),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcfg := &DecoderConfig{\n\t\t\t\tDecodeHook: f,\n\t\t\t\tResult:     tc.receiver,\n\t\t\t}\n\n\t\t\td, err := NewDecoder(cfg)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %#v\", err)\n\t\t\t}\n\n\t\t\terr = d.Decode(tc.input)\n\t\t\tif tc.err != (err != nil) {\n\t\t\t\tt.Fatalf(\"expected err %#v\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.expected, tc.receiver) {\n\t\t\t\tt.Fatalf(\"expected %#v, got %#v\",\n\t\t\t\t\ttc.expected, tc.receiver)\n\t\t\t}\n\t\t})\n\n\t}\n}\n\nfunc TestTextUnmarshallerHookFunc(t *testing.T) {\n\ttype MyString string\n\n\tcases := []struct {\n\t\tf, t   reflect.Value\n\t\tresult interface{}\n\t\terr    bool\n\t}{\n\t\t{reflect.ValueOf(\"42\"), reflect.ValueOf(big.Int{}), big.NewInt(42), false},\n\t\t{reflect.ValueOf(\"invalid\"), reflect.ValueOf(big.Int{}), nil, true},\n\t\t{reflect.ValueOf(\"5\"), reflect.ValueOf(\"5\"), \"5\", false},\n\t\t{reflect.ValueOf(json.Number(\"42\")), reflect.ValueOf(big.Int{}), big.NewInt(42), false},\n\t\t{reflect.ValueOf(MyString(\"42\")), reflect.ValueOf(big.Int{}), big.NewInt(42), false},\n\t}\n\tfor i, tc := range cases {\n\t\tf := TextUnmarshallerHookFunc()\n\t\tactual, err := DecodeHookExec(f, tc.f, tc.t)\n\t\tif tc.err != (err != nil) {\n\t\t\tt.Fatalf(\"case %d: expected err %#v\", i, tc.err)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\tt.Fatalf(\n\t\t\t\t\"case %d: expected %#v, got %#v\",\n\t\t\t\ti, tc.result, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.0048828125,
          "content": "package mapstructure\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// Error implements the error interface and can represents multiple\n// errors that occur in the course of a single decode.\ntype Error struct {\n\tErrors []string\n}\n\nfunc (e *Error) Error() string {\n\tpoints := make([]string, len(e.Errors))\n\tfor i, err := range e.Errors {\n\t\tpoints[i] = fmt.Sprintf(\"* %s\", err)\n\t}\n\n\tsort.Strings(points)\n\treturn fmt.Sprintf(\n\t\t\"%d error(s) decoding:\\n\\n%s\",\n\t\tlen(e.Errors), strings.Join(points, \"\\n\"))\n}\n\n// WrappedErrors implements the errwrap.Wrapper interface to make this\n// return value more useful with the errwrap and go-multierror libraries.\nfunc (e *Error) WrappedErrors() []error {\n\tif e == nil {\n\t\treturn nil\n\t}\n\n\tresult := make([]error, len(e.Errors))\n\tfor i, e := range e.Errors {\n\t\tresult[i] = errors.New(e)\n\t}\n\n\treturn result\n}\n\nfunc appendErrors(errors []string, err error) []string {\n\tswitch e := err.(type) {\n\tcase *Error:\n\t\treturn append(errors, e.Errors...)\n\tdefault:\n\t\treturn append(errors, e.Error())\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.048828125,
          "content": "module github.com/mitchellh/mapstructure\n\ngo 1.14\n"
        },
        {
          "name": "mapstructure.go",
          "type": "blob",
          "size": 44.0986328125,
          "content": "// Package mapstructure exposes functionality to convert one arbitrary\n// Go type into another, typically to convert a map[string]interface{}\n// into a native Go structure.\n//\n// The Go structure can be arbitrarily complex, containing slices,\n// other structs, etc. and the decoder will properly decode nested\n// maps and so on into the proper structures in the native Go struct.\n// See the examples to see what the decoder is capable of.\n//\n// The simplest function to start with is Decode.\n//\n// Field Tags\n//\n// When decoding to a struct, mapstructure will use the field name by\n// default to perform the mapping. For example, if a struct has a field\n// \"Username\" then mapstructure will look for a key in the source value\n// of \"username\" (case insensitive).\n//\n//     type User struct {\n//         Username string\n//     }\n//\n// You can change the behavior of mapstructure by using struct tags.\n// The default struct tag that mapstructure looks for is \"mapstructure\"\n// but you can customize it using DecoderConfig.\n//\n// Renaming Fields\n//\n// To rename the key that mapstructure looks for, use the \"mapstructure\"\n// tag and set a value directly. For example, to change the \"username\" example\n// above to \"user\":\n//\n//     type User struct {\n//         Username string `mapstructure:\"user\"`\n//     }\n//\n// Embedded Structs and Squashing\n//\n// Embedded structs are treated as if they're another field with that name.\n// By default, the two structs below are equivalent when decoding with\n// mapstructure:\n//\n//     type Person struct {\n//         Name string\n//     }\n//\n//     type Friend struct {\n//         Person\n//     }\n//\n//     type Friend struct {\n//         Person Person\n//     }\n//\n// This would require an input that looks like below:\n//\n//     map[string]interface{}{\n//         \"person\": map[string]interface{}{\"name\": \"alice\"},\n//     }\n//\n// If your \"person\" value is NOT nested, then you can append \",squash\" to\n// your tag value and mapstructure will treat it as if the embedded struct\n// were part of the struct directly. Example:\n//\n//     type Friend struct {\n//         Person `mapstructure:\",squash\"`\n//     }\n//\n// Now the following input would be accepted:\n//\n//     map[string]interface{}{\n//         \"name\": \"alice\",\n//     }\n//\n// When decoding from a struct to a map, the squash tag squashes the struct\n// fields into a single map. Using the example structs from above:\n//\n//     Friend{Person: Person{Name: \"alice\"}}\n//\n// Will be decoded into a map:\n//\n//     map[string]interface{}{\n//         \"name\": \"alice\",\n//     }\n//\n// DecoderConfig has a field that changes the behavior of mapstructure\n// to always squash embedded structs.\n//\n// Remainder Values\n//\n// If there are any unmapped keys in the source value, mapstructure by\n// default will silently ignore them. You can error by setting ErrorUnused\n// in DecoderConfig. If you're using Metadata you can also maintain a slice\n// of the unused keys.\n//\n// You can also use the \",remain\" suffix on your tag to collect all unused\n// values in a map. The field with this tag MUST be a map type and should\n// probably be a \"map[string]interface{}\" or \"map[interface{}]interface{}\".\n// See example below:\n//\n//     type Friend struct {\n//         Name  string\n//         Other map[string]interface{} `mapstructure:\",remain\"`\n//     }\n//\n// Given the input below, Other would be populated with the other\n// values that weren't used (everything but \"name\"):\n//\n//     map[string]interface{}{\n//         \"name\":    \"bob\",\n//         \"address\": \"123 Maple St.\",\n//     }\n//\n// Omit Empty Values\n//\n// When decoding from a struct to any other value, you may use the\n// \",omitempty\" suffix on your tag to omit that value if it equates to\n// the zero value. The zero value of all types is specified in the Go\n// specification.\n//\n// For example, the zero type of a numeric type is zero (\"0\"). If the struct\n// field value is zero and a numeric type, the field is empty, and it won't\n// be encoded into the destination type.\n//\n//     type Source struct {\n//         Age int `mapstructure:\",omitempty\"`\n//     }\n//\n// Unexported fields\n//\n// Since unexported (private) struct fields cannot be set outside the package\n// where they are defined, the decoder will simply skip them.\n//\n// For this output type definition:\n//\n//     type Exported struct {\n//         private string // this unexported field will be skipped\n//         Public string\n//     }\n//\n// Using this map as input:\n//\n//     map[string]interface{}{\n//         \"private\": \"I will be ignored\",\n//         \"Public\":  \"I made it through!\",\n//     }\n//\n// The following struct will be decoded:\n//\n//     type Exported struct {\n//         private: \"\" // field is left with an empty string (zero value)\n//         Public: \"I made it through!\"\n//     }\n//\n// Other Configuration\n//\n// mapstructure is highly configurable. See the DecoderConfig struct\n// for other features and options that are supported.\npackage mapstructure\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// DecodeHookFunc is the callback function that can be used for\n// data transformations. See \"DecodeHook\" in the DecoderConfig\n// struct.\n//\n// The type must be one of DecodeHookFuncType, DecodeHookFuncKind, or\n// DecodeHookFuncValue.\n// Values are a superset of Types (Values can return types), and Types are a\n// superset of Kinds (Types can return Kinds) and are generally a richer thing\n// to use, but Kinds are simpler if you only need those.\n//\n// The reason DecodeHookFunc is multi-typed is for backwards compatibility:\n// we started with Kinds and then realized Types were the better solution,\n// but have a promise to not break backwards compat so we now support\n// both.\ntype DecodeHookFunc interface{}\n\n// DecodeHookFuncType is a DecodeHookFunc which has complete information about\n// the source and target types.\ntype DecodeHookFuncType func(reflect.Type, reflect.Type, interface{}) (interface{}, error)\n\n// DecodeHookFuncKind is a DecodeHookFunc which knows only the Kinds of the\n// source and target types.\ntype DecodeHookFuncKind func(reflect.Kind, reflect.Kind, interface{}) (interface{}, error)\n\n// DecodeHookFuncValue is a DecodeHookFunc which has complete access to both the source and target\n// values.\ntype DecodeHookFuncValue func(from reflect.Value, to reflect.Value) (interface{}, error)\n\n// DecoderConfig is the configuration that is used to create a new decoder\n// and allows customization of various aspects of decoding.\ntype DecoderConfig struct {\n\t// DecodeHook, if set, will be called before any decoding and any\n\t// type conversion (if WeaklyTypedInput is on). This lets you modify\n\t// the values before they're set down onto the resulting struct. The\n\t// DecodeHook is called for every map and value in the input. This means\n\t// that if a struct has embedded fields with squash tags the decode hook\n\t// is called only once with all of the input data, not once for each\n\t// embedded struct.\n\t//\n\t// If an error is returned, the entire decode will fail with that error.\n\tDecodeHook DecodeHookFunc\n\n\t// If ErrorUnused is true, then it is an error for there to exist\n\t// keys in the original map that were unused in the decoding process\n\t// (extra keys).\n\tErrorUnused bool\n\n\t// If ErrorUnset is true, then it is an error for there to exist\n\t// fields in the result that were not set in the decoding process\n\t// (extra fields). This only applies to decoding to a struct. This\n\t// will affect all nested structs as well.\n\tErrorUnset bool\n\n\t// ZeroFields, if set to true, will zero fields before writing them.\n\t// For example, a map will be emptied before decoded values are put in\n\t// it. If this is false, a map will be merged.\n\tZeroFields bool\n\n\t// If WeaklyTypedInput is true, the decoder will make the following\n\t// \"weak\" conversions:\n\t//\n\t//   - bools to string (true = \"1\", false = \"0\")\n\t//   - numbers to string (base 10)\n\t//   - bools to int/uint (true = 1, false = 0)\n\t//   - strings to int/uint (base implied by prefix)\n\t//   - int to bool (true if value != 0)\n\t//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F,\n\t//     FALSE, false, False. Anything else is an error)\n\t//   - empty array = empty map and vice versa\n\t//   - negative numbers to overflowed uint values (base 10)\n\t//   - slice of maps to a merged map\n\t//   - single values are converted to slices if required. Each\n\t//     element is weakly decoded. For example: \"4\" can become []int{4}\n\t//     if the target type is an int slice.\n\t//\n\tWeaklyTypedInput bool\n\n\t// Squash will squash embedded structs.  A squash tag may also be\n\t// added to an individual struct field using a tag.  For example:\n\t//\n\t//  type Parent struct {\n\t//      Child `mapstructure:\",squash\"`\n\t//  }\n\tSquash bool\n\n\t// Metadata is the struct that will contain extra metadata about\n\t// the decoding. If this is nil, then no metadata will be tracked.\n\tMetadata *Metadata\n\n\t// Result is a pointer to the struct that will contain the decoded\n\t// value.\n\tResult interface{}\n\n\t// The tag name that mapstructure reads for field names. This\n\t// defaults to \"mapstructure\"\n\tTagName string\n\n\t// IgnoreUntaggedFields ignores all struct fields without explicit\n\t// TagName, comparable to `mapstructure:\"-\"` as default behaviour.\n\tIgnoreUntaggedFields bool\n\n\t// MatchName is the function used to match the map key to the struct\n\t// field name or tag. Defaults to `strings.EqualFold`. This can be used\n\t// to implement case-sensitive tag values, support snake casing, etc.\n\tMatchName func(mapKey, fieldName string) bool\n}\n\n// A Decoder takes a raw interface value and turns it into structured\n// data, keeping track of rich error information along the way in case\n// anything goes wrong. Unlike the basic top-level Decode method, you can\n// more finely control how the Decoder behaves using the DecoderConfig\n// structure. The top-level Decode method is just a convenience that sets\n// up the most basic Decoder.\ntype Decoder struct {\n\tconfig *DecoderConfig\n}\n\n// Metadata contains information about decoding a structure that\n// is tedious or difficult to get otherwise.\ntype Metadata struct {\n\t// Keys are the keys of the structure which were successfully decoded\n\tKeys []string\n\n\t// Unused is a slice of keys that were found in the raw value but\n\t// weren't decoded since there was no matching field in the result interface\n\tUnused []string\n\n\t// Unset is a slice of field names that were found in the result interface\n\t// but weren't set in the decoding process since there was no matching value\n\t// in the input\n\tUnset []string\n}\n\n// Decode takes an input structure and uses reflection to translate it to\n// the output structure. output must be a pointer to a map or struct.\nfunc Decode(input interface{}, output interface{}) error {\n\tconfig := &DecoderConfig{\n\t\tMetadata: nil,\n\t\tResult:   output,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder.Decode(input)\n}\n\n// WeakDecode is the same as Decode but is shorthand to enable\n// WeaklyTypedInput. See DecoderConfig for more info.\nfunc WeakDecode(input, output interface{}) error {\n\tconfig := &DecoderConfig{\n\t\tMetadata:         nil,\n\t\tResult:           output,\n\t\tWeaklyTypedInput: true,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder.Decode(input)\n}\n\n// DecodeMetadata is the same as Decode, but is shorthand to\n// enable metadata collection. See DecoderConfig for more info.\nfunc DecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error {\n\tconfig := &DecoderConfig{\n\t\tMetadata: metadata,\n\t\tResult:   output,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder.Decode(input)\n}\n\n// WeakDecodeMetadata is the same as Decode, but is shorthand to\n// enable both WeaklyTypedInput and metadata collection. See\n// DecoderConfig for more info.\nfunc WeakDecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error {\n\tconfig := &DecoderConfig{\n\t\tMetadata:         metadata,\n\t\tResult:           output,\n\t\tWeaklyTypedInput: true,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder.Decode(input)\n}\n\n// NewDecoder returns a new decoder for the given configuration. Once\n// a decoder has been returned, the same configuration must not be used\n// again.\nfunc NewDecoder(config *DecoderConfig) (*Decoder, error) {\n\tval := reflect.ValueOf(config.Result)\n\tif val.Kind() != reflect.Ptr {\n\t\treturn nil, errors.New(\"result must be a pointer\")\n\t}\n\n\tval = val.Elem()\n\tif !val.CanAddr() {\n\t\treturn nil, errors.New(\"result must be addressable (a pointer)\")\n\t}\n\n\tif config.Metadata != nil {\n\t\tif config.Metadata.Keys == nil {\n\t\t\tconfig.Metadata.Keys = make([]string, 0)\n\t\t}\n\n\t\tif config.Metadata.Unused == nil {\n\t\t\tconfig.Metadata.Unused = make([]string, 0)\n\t\t}\n\n\t\tif config.Metadata.Unset == nil {\n\t\t\tconfig.Metadata.Unset = make([]string, 0)\n\t\t}\n\t}\n\n\tif config.TagName == \"\" {\n\t\tconfig.TagName = \"mapstructure\"\n\t}\n\n\tif config.MatchName == nil {\n\t\tconfig.MatchName = strings.EqualFold\n\t}\n\n\tresult := &Decoder{\n\t\tconfig: config,\n\t}\n\n\treturn result, nil\n}\n\n// Decode decodes the given raw interface to the target pointer specified\n// by the configuration.\nfunc (d *Decoder) Decode(input interface{}) error {\n\treturn d.decode(\"\", input, reflect.ValueOf(d.config.Result).Elem())\n}\n\n// Decodes an unknown data type into a specific reflection value.\nfunc (d *Decoder) decode(name string, input interface{}, outVal reflect.Value) error {\n\tvar inputVal reflect.Value\n\tif input != nil {\n\t\tinputVal = reflect.ValueOf(input)\n\n\t\t// We need to check here if input is a typed nil. Typed nils won't\n\t\t// match the \"input == nil\" below so we check that here.\n\t\tif inputVal.Kind() == reflect.Ptr && inputVal.IsNil() {\n\t\t\tinput = nil\n\t\t}\n\t}\n\n\tif input == nil {\n\t\t// If the data is nil, then we don't set anything, unless ZeroFields is set\n\t\t// to true.\n\t\tif d.config.ZeroFields {\n\t\t\toutVal.Set(reflect.Zero(outVal.Type()))\n\n\t\t\tif d.config.Metadata != nil && name != \"\" {\n\t\t\t\td.config.Metadata.Keys = append(d.config.Metadata.Keys, name)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tif !inputVal.IsValid() {\n\t\t// If the input value is invalid, then we just set the value\n\t\t// to be the zero value.\n\t\toutVal.Set(reflect.Zero(outVal.Type()))\n\t\tif d.config.Metadata != nil && name != \"\" {\n\t\t\td.config.Metadata.Keys = append(d.config.Metadata.Keys, name)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif d.config.DecodeHook != nil {\n\t\t// We have a DecodeHook, so let's pre-process the input.\n\t\tvar err error\n\t\tinput, err = DecodeHookExec(d.config.DecodeHook, inputVal, outVal)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error decoding '%s': %w\", name, err)\n\t\t}\n\t}\n\n\tvar err error\n\toutputKind := getKind(outVal)\n\taddMetaKey := true\n\tswitch outputKind {\n\tcase reflect.Bool:\n\t\terr = d.decodeBool(name, input, outVal)\n\tcase reflect.Interface:\n\t\terr = d.decodeBasic(name, input, outVal)\n\tcase reflect.String:\n\t\terr = d.decodeString(name, input, outVal)\n\tcase reflect.Int:\n\t\terr = d.decodeInt(name, input, outVal)\n\tcase reflect.Uint:\n\t\terr = d.decodeUint(name, input, outVal)\n\tcase reflect.Float32:\n\t\terr = d.decodeFloat(name, input, outVal)\n\tcase reflect.Struct:\n\t\terr = d.decodeStruct(name, input, outVal)\n\tcase reflect.Map:\n\t\terr = d.decodeMap(name, input, outVal)\n\tcase reflect.Ptr:\n\t\taddMetaKey, err = d.decodePtr(name, input, outVal)\n\tcase reflect.Slice:\n\t\terr = d.decodeSlice(name, input, outVal)\n\tcase reflect.Array:\n\t\terr = d.decodeArray(name, input, outVal)\n\tcase reflect.Func:\n\t\terr = d.decodeFunc(name, input, outVal)\n\tdefault:\n\t\t// If we reached this point then we weren't able to decode it\n\t\treturn fmt.Errorf(\"%s: unsupported type: %s\", name, outputKind)\n\t}\n\n\t// If we reached here, then we successfully decoded SOMETHING, so\n\t// mark the key as used if we're tracking metainput.\n\tif addMetaKey && d.config.Metadata != nil && name != \"\" {\n\t\td.config.Metadata.Keys = append(d.config.Metadata.Keys, name)\n\t}\n\n\treturn err\n}\n\n// This decodes a basic type (bool, int, string, etc.) and sets the\n// value to \"data\" of that type.\nfunc (d *Decoder) decodeBasic(name string, data interface{}, val reflect.Value) error {\n\tif val.IsValid() && val.Elem().IsValid() {\n\t\telem := val.Elem()\n\n\t\t// If we can't address this element, then its not writable. Instead,\n\t\t// we make a copy of the value (which is a pointer and therefore\n\t\t// writable), decode into that, and replace the whole value.\n\t\tcopied := false\n\t\tif !elem.CanAddr() {\n\t\t\tcopied = true\n\n\t\t\t// Make *T\n\t\t\tcopy := reflect.New(elem.Type())\n\n\t\t\t// *T = elem\n\t\t\tcopy.Elem().Set(elem)\n\n\t\t\t// Set elem so we decode into it\n\t\t\telem = copy\n\t\t}\n\n\t\t// Decode. If we have an error then return. We also return right\n\t\t// away if we're not a copy because that means we decoded directly.\n\t\tif err := d.decode(name, data, elem); err != nil || !copied {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we're a copy, we need to set te final result\n\t\tval.Set(elem.Elem())\n\t\treturn nil\n\t}\n\n\tdataVal := reflect.ValueOf(data)\n\n\t// If the input data is a pointer, and the assigned type is the dereference\n\t// of that exact pointer, then indirect it so that we can assign it.\n\t// Example: *string to string\n\tif dataVal.Kind() == reflect.Ptr && dataVal.Type().Elem() == val.Type() {\n\t\tdataVal = reflect.Indirect(dataVal)\n\t}\n\n\tif !dataVal.IsValid() {\n\t\tdataVal = reflect.Zero(val.Type())\n\t}\n\n\tdataValType := dataVal.Type()\n\tif !dataValType.AssignableTo(val.Type()) {\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got '%s'\",\n\t\t\tname, val.Type(), dataValType)\n\t}\n\n\tval.Set(dataVal)\n\treturn nil\n}\n\nfunc (d *Decoder) decodeString(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataKind := getKind(dataVal)\n\n\tconverted := true\n\tswitch {\n\tcase dataKind == reflect.String:\n\t\tval.SetString(dataVal.String())\n\tcase dataKind == reflect.Bool && d.config.WeaklyTypedInput:\n\t\tif dataVal.Bool() {\n\t\t\tval.SetString(\"1\")\n\t\t} else {\n\t\t\tval.SetString(\"0\")\n\t\t}\n\tcase dataKind == reflect.Int && d.config.WeaklyTypedInput:\n\t\tval.SetString(strconv.FormatInt(dataVal.Int(), 10))\n\tcase dataKind == reflect.Uint && d.config.WeaklyTypedInput:\n\t\tval.SetString(strconv.FormatUint(dataVal.Uint(), 10))\n\tcase dataKind == reflect.Float32 && d.config.WeaklyTypedInput:\n\t\tval.SetString(strconv.FormatFloat(dataVal.Float(), 'f', -1, 64))\n\tcase dataKind == reflect.Slice && d.config.WeaklyTypedInput,\n\t\tdataKind == reflect.Array && d.config.WeaklyTypedInput:\n\t\tdataType := dataVal.Type()\n\t\telemKind := dataType.Elem().Kind()\n\t\tswitch elemKind {\n\t\tcase reflect.Uint8:\n\t\t\tvar uints []uint8\n\t\t\tif dataKind == reflect.Array {\n\t\t\t\tuints = make([]uint8, dataVal.Len(), dataVal.Len())\n\t\t\t\tfor i := range uints {\n\t\t\t\t\tuints[i] = dataVal.Index(i).Interface().(uint8)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuints = dataVal.Interface().([]uint8)\n\t\t\t}\n\t\t\tval.SetString(string(uints))\n\t\tdefault:\n\t\t\tconverted = false\n\t\t}\n\tdefault:\n\t\tconverted = false\n\t}\n\n\tif !converted {\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeInt(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataKind := getKind(dataVal)\n\tdataType := dataVal.Type()\n\n\tswitch {\n\tcase dataKind == reflect.Int:\n\t\tval.SetInt(dataVal.Int())\n\tcase dataKind == reflect.Uint:\n\t\tval.SetInt(int64(dataVal.Uint()))\n\tcase dataKind == reflect.Float32:\n\t\tval.SetInt(int64(dataVal.Float()))\n\tcase dataKind == reflect.Bool && d.config.WeaklyTypedInput:\n\t\tif dataVal.Bool() {\n\t\t\tval.SetInt(1)\n\t\t} else {\n\t\t\tval.SetInt(0)\n\t\t}\n\tcase dataKind == reflect.String && d.config.WeaklyTypedInput:\n\t\tstr := dataVal.String()\n\t\tif str == \"\" {\n\t\t\tstr = \"0\"\n\t\t}\n\n\t\ti, err := strconv.ParseInt(str, 0, val.Type().Bits())\n\t\tif err == nil {\n\t\t\tval.SetInt(i)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as int: %s\", name, err)\n\t\t}\n\tcase dataType.PkgPath() == \"encoding/json\" && dataType.Name() == \"Number\":\n\t\tjn := data.(json.Number)\n\t\ti, err := jn.Int64()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"error decoding json.Number into %s: %s\", name, err)\n\t\t}\n\t\tval.SetInt(i)\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeUint(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataKind := getKind(dataVal)\n\tdataType := dataVal.Type()\n\n\tswitch {\n\tcase dataKind == reflect.Int:\n\t\ti := dataVal.Int()\n\t\tif i < 0 && !d.config.WeaklyTypedInput {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s', %d overflows uint\",\n\t\t\t\tname, i)\n\t\t}\n\t\tval.SetUint(uint64(i))\n\tcase dataKind == reflect.Uint:\n\t\tval.SetUint(dataVal.Uint())\n\tcase dataKind == reflect.Float32:\n\t\tf := dataVal.Float()\n\t\tif f < 0 && !d.config.WeaklyTypedInput {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s', %f overflows uint\",\n\t\t\t\tname, f)\n\t\t}\n\t\tval.SetUint(uint64(f))\n\tcase dataKind == reflect.Bool && d.config.WeaklyTypedInput:\n\t\tif dataVal.Bool() {\n\t\t\tval.SetUint(1)\n\t\t} else {\n\t\t\tval.SetUint(0)\n\t\t}\n\tcase dataKind == reflect.String && d.config.WeaklyTypedInput:\n\t\tstr := dataVal.String()\n\t\tif str == \"\" {\n\t\t\tstr = \"0\"\n\t\t}\n\n\t\ti, err := strconv.ParseUint(str, 0, val.Type().Bits())\n\t\tif err == nil {\n\t\t\tval.SetUint(i)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as uint: %s\", name, err)\n\t\t}\n\tcase dataType.PkgPath() == \"encoding/json\" && dataType.Name() == \"Number\":\n\t\tjn := data.(json.Number)\n\t\ti, err := strconv.ParseUint(string(jn), 0, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"error decoding json.Number into %s: %s\", name, err)\n\t\t}\n\t\tval.SetUint(i)\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeBool(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataKind := getKind(dataVal)\n\n\tswitch {\n\tcase dataKind == reflect.Bool:\n\t\tval.SetBool(dataVal.Bool())\n\tcase dataKind == reflect.Int && d.config.WeaklyTypedInput:\n\t\tval.SetBool(dataVal.Int() != 0)\n\tcase dataKind == reflect.Uint && d.config.WeaklyTypedInput:\n\t\tval.SetBool(dataVal.Uint() != 0)\n\tcase dataKind == reflect.Float32 && d.config.WeaklyTypedInput:\n\t\tval.SetBool(dataVal.Float() != 0)\n\tcase dataKind == reflect.String && d.config.WeaklyTypedInput:\n\t\tb, err := strconv.ParseBool(dataVal.String())\n\t\tif err == nil {\n\t\t\tval.SetBool(b)\n\t\t} else if dataVal.String() == \"\" {\n\t\t\tval.SetBool(false)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as bool: %s\", name, err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeFloat(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataKind := getKind(dataVal)\n\tdataType := dataVal.Type()\n\n\tswitch {\n\tcase dataKind == reflect.Int:\n\t\tval.SetFloat(float64(dataVal.Int()))\n\tcase dataKind == reflect.Uint:\n\t\tval.SetFloat(float64(dataVal.Uint()))\n\tcase dataKind == reflect.Float32:\n\t\tval.SetFloat(dataVal.Float())\n\tcase dataKind == reflect.Bool && d.config.WeaklyTypedInput:\n\t\tif dataVal.Bool() {\n\t\t\tval.SetFloat(1)\n\t\t} else {\n\t\t\tval.SetFloat(0)\n\t\t}\n\tcase dataKind == reflect.String && d.config.WeaklyTypedInput:\n\t\tstr := dataVal.String()\n\t\tif str == \"\" {\n\t\t\tstr = \"0\"\n\t\t}\n\n\t\tf, err := strconv.ParseFloat(str, val.Type().Bits())\n\t\tif err == nil {\n\t\t\tval.SetFloat(f)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as float: %s\", name, err)\n\t\t}\n\tcase dataType.PkgPath() == \"encoding/json\" && dataType.Name() == \"Number\":\n\t\tjn := data.(json.Number)\n\t\ti, err := jn.Float64()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"error decoding json.Number into %s: %s\", name, err)\n\t\t}\n\t\tval.SetFloat(i)\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeMap(name string, data interface{}, val reflect.Value) error {\n\tvalType := val.Type()\n\tvalKeyType := valType.Key()\n\tvalElemType := valType.Elem()\n\n\t// By default we overwrite keys in the current map\n\tvalMap := val\n\n\t// If the map is nil or we're purposely zeroing fields, make a new map\n\tif valMap.IsNil() || d.config.ZeroFields {\n\t\t// Make a new map to hold our result\n\t\tmapType := reflect.MapOf(valKeyType, valElemType)\n\t\tvalMap = reflect.MakeMap(mapType)\n\t}\n\n\t// Check input type and based on the input type jump to the proper func\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tswitch dataVal.Kind() {\n\tcase reflect.Map:\n\t\treturn d.decodeMapFromMap(name, dataVal, val, valMap)\n\n\tcase reflect.Struct:\n\t\treturn d.decodeMapFromStruct(name, dataVal, val, valMap)\n\n\tcase reflect.Array, reflect.Slice:\n\t\tif d.config.WeaklyTypedInput {\n\t\t\treturn d.decodeMapFromSlice(name, dataVal, val, valMap)\n\t\t}\n\n\t\tfallthrough\n\n\tdefault:\n\t\treturn fmt.Errorf(\"'%s' expected a map, got '%s'\", name, dataVal.Kind())\n\t}\n}\n\nfunc (d *Decoder) decodeMapFromSlice(name string, dataVal reflect.Value, val reflect.Value, valMap reflect.Value) error {\n\t// Special case for BC reasons (covered by tests)\n\tif dataVal.Len() == 0 {\n\t\tval.Set(valMap)\n\t\treturn nil\n\t}\n\n\tfor i := 0; i < dataVal.Len(); i++ {\n\t\terr := d.decode(\n\t\t\tname+\"[\"+strconv.Itoa(i)+\"]\",\n\t\t\tdataVal.Index(i).Interface(), val)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeMapFromMap(name string, dataVal reflect.Value, val reflect.Value, valMap reflect.Value) error {\n\tvalType := val.Type()\n\tvalKeyType := valType.Key()\n\tvalElemType := valType.Elem()\n\n\t// Accumulate errors\n\terrors := make([]string, 0)\n\n\t// If the input data is empty, then we just match what the input data is.\n\tif dataVal.Len() == 0 {\n\t\tif dataVal.IsNil() {\n\t\t\tif !val.IsNil() {\n\t\t\t\tval.Set(dataVal)\n\t\t\t}\n\t\t} else {\n\t\t\t// Set to empty allocated value\n\t\t\tval.Set(valMap)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfor _, k := range dataVal.MapKeys() {\n\t\tfieldName := name + \"[\" + k.String() + \"]\"\n\n\t\t// First decode the key into the proper type\n\t\tcurrentKey := reflect.Indirect(reflect.New(valKeyType))\n\t\tif err := d.decode(fieldName, k.Interface(), currentKey); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Next decode the data into the proper type\n\t\tv := dataVal.MapIndex(k).Interface()\n\t\tcurrentVal := reflect.Indirect(reflect.New(valElemType))\n\t\tif err := d.decode(fieldName, v, currentVal); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvalMap.SetMapIndex(currentKey, currentVal)\n\t}\n\n\t// Set the built up map to the value\n\tval.Set(valMap)\n\n\t// If we had errors, return those\n\tif len(errors) > 0 {\n\t\treturn &Error{errors}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeMapFromStruct(name string, dataVal reflect.Value, val reflect.Value, valMap reflect.Value) error {\n\ttyp := dataVal.Type()\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\t// Get the StructField first since this is a cheap operation. If the\n\t\t// field is unexported, then ignore it.\n\t\tf := typ.Field(i)\n\t\tif f.PkgPath != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Next get the actual value of this field and verify it is assignable\n\t\t// to the map value.\n\t\tv := dataVal.Field(i)\n\t\tif !v.Type().AssignableTo(valMap.Type().Elem()) {\n\t\t\treturn fmt.Errorf(\"cannot assign type '%s' to map value field of type '%s'\", v.Type(), valMap.Type().Elem())\n\t\t}\n\n\t\ttagValue := f.Tag.Get(d.config.TagName)\n\t\tkeyName := f.Name\n\n\t\tif tagValue == \"\" && d.config.IgnoreUntaggedFields {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If Squash is set in the config, we squash the field down.\n\t\tsquash := d.config.Squash && v.Kind() == reflect.Struct && f.Anonymous\n\n\t\tv = dereferencePtrToStructIfNeeded(v, d.config.TagName)\n\n\t\t// Determine the name of the key in the map\n\t\tif index := strings.Index(tagValue, \",\"); index != -1 {\n\t\t\tif tagValue[:index] == \"-\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If \"omitempty\" is specified in the tag, it ignores empty values.\n\t\t\tif strings.Index(tagValue[index+1:], \"omitempty\") != -1 && isEmptyValue(v) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If \"squash\" is specified in the tag, we squash the field down.\n\t\t\tsquash = squash || strings.Index(tagValue[index+1:], \"squash\") != -1\n\t\t\tif squash {\n\t\t\t\t// When squashing, the embedded type can be a pointer to a struct.\n\t\t\t\tif v.Kind() == reflect.Ptr && v.Elem().Kind() == reflect.Struct {\n\t\t\t\t\tv = v.Elem()\n\t\t\t\t}\n\n\t\t\t\t// The final type must be a struct\n\t\t\t\tif v.Kind() != reflect.Struct {\n\t\t\t\t\treturn fmt.Errorf(\"cannot squash non-struct type '%s'\", v.Type())\n\t\t\t\t}\n\t\t\t}\n\t\t\tif keyNameTagValue := tagValue[:index]; keyNameTagValue != \"\" {\n\t\t\t\tkeyName = keyNameTagValue\n\t\t\t}\n\t\t} else if len(tagValue) > 0 {\n\t\t\tif tagValue == \"-\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tkeyName = tagValue\n\t\t}\n\n\t\tswitch v.Kind() {\n\t\t// this is an embedded struct, so handle it differently\n\t\tcase reflect.Struct:\n\t\t\tx := reflect.New(v.Type())\n\t\t\tx.Elem().Set(v)\n\n\t\t\tvType := valMap.Type()\n\t\t\tvKeyType := vType.Key()\n\t\t\tvElemType := vType.Elem()\n\t\t\tmType := reflect.MapOf(vKeyType, vElemType)\n\t\t\tvMap := reflect.MakeMap(mType)\n\n\t\t\t// Creating a pointer to a map so that other methods can completely\n\t\t\t// overwrite the map if need be (looking at you decodeMapFromMap). The\n\t\t\t// indirection allows the underlying map to be settable (CanSet() == true)\n\t\t\t// where as reflect.MakeMap returns an unsettable map.\n\t\t\taddrVal := reflect.New(vMap.Type())\n\t\t\treflect.Indirect(addrVal).Set(vMap)\n\n\t\t\terr := d.decode(keyName, x.Interface(), reflect.Indirect(addrVal))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// the underlying map may have been completely overwritten so pull\n\t\t\t// it indirectly out of the enclosing value.\n\t\t\tvMap = reflect.Indirect(addrVal)\n\n\t\t\tif squash {\n\t\t\t\tfor _, k := range vMap.MapKeys() {\n\t\t\t\t\tvalMap.SetMapIndex(k, vMap.MapIndex(k))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalMap.SetMapIndex(reflect.ValueOf(keyName), vMap)\n\t\t\t}\n\n\t\tdefault:\n\t\t\tvalMap.SetMapIndex(reflect.ValueOf(keyName), v)\n\t\t}\n\t}\n\n\tif val.CanAddr() {\n\t\tval.Set(valMap)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodePtr(name string, data interface{}, val reflect.Value) (bool, error) {\n\t// If the input data is nil, then we want to just set the output\n\t// pointer to be nil as well.\n\tisNil := data == nil\n\tif !isNil {\n\t\tswitch v := reflect.Indirect(reflect.ValueOf(data)); v.Kind() {\n\t\tcase reflect.Chan,\n\t\t\treflect.Func,\n\t\t\treflect.Interface,\n\t\t\treflect.Map,\n\t\t\treflect.Ptr,\n\t\t\treflect.Slice:\n\t\t\tisNil = v.IsNil()\n\t\t}\n\t}\n\tif isNil {\n\t\tif !val.IsNil() && val.CanSet() {\n\t\t\tnilValue := reflect.New(val.Type()).Elem()\n\t\t\tval.Set(nilValue)\n\t\t}\n\n\t\treturn true, nil\n\t}\n\n\t// Create an element of the concrete (non pointer) type and decode\n\t// into that. Then set the value of the pointer to this type.\n\tvalType := val.Type()\n\tvalElemType := valType.Elem()\n\tif val.CanSet() {\n\t\trealVal := val\n\t\tif realVal.IsNil() || d.config.ZeroFields {\n\t\t\trealVal = reflect.New(valElemType)\n\t\t}\n\n\t\tif err := d.decode(name, data, reflect.Indirect(realVal)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tval.Set(realVal)\n\t} else {\n\t\tif err := d.decode(name, data, reflect.Indirect(val)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc (d *Decoder) decodeFunc(name string, data interface{}, val reflect.Value) error {\n\t// Create an element of the concrete (non pointer) type and decode\n\t// into that. Then set the value of the pointer to this type.\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tif val.Type() != dataVal.Type() {\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' expected type '%s', got unconvertible type '%s', value: '%v'\",\n\t\t\tname, val.Type(), dataVal.Type(), data)\n\t}\n\tval.Set(dataVal)\n\treturn nil\n}\n\nfunc (d *Decoder) decodeSlice(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataValKind := dataVal.Kind()\n\tvalType := val.Type()\n\tvalElemType := valType.Elem()\n\tsliceType := reflect.SliceOf(valElemType)\n\n\t// If we have a non array/slice type then we first attempt to convert.\n\tif dataValKind != reflect.Array && dataValKind != reflect.Slice {\n\t\tif d.config.WeaklyTypedInput {\n\t\t\tswitch {\n\t\t\t// Slice and array we use the normal logic\n\t\t\tcase dataValKind == reflect.Slice, dataValKind == reflect.Array:\n\t\t\t\tbreak\n\n\t\t\t// Empty maps turn into empty slices\n\t\t\tcase dataValKind == reflect.Map:\n\t\t\t\tif dataVal.Len() == 0 {\n\t\t\t\t\tval.Set(reflect.MakeSlice(sliceType, 0, 0))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Create slice of maps of other sizes\n\t\t\t\treturn d.decodeSlice(name, []interface{}{data}, val)\n\n\t\t\tcase dataValKind == reflect.String && valElemType.Kind() == reflect.Uint8:\n\t\t\t\treturn d.decodeSlice(name, []byte(dataVal.String()), val)\n\n\t\t\t// All other types we try to convert to the slice type\n\t\t\t// and \"lift\" it into it. i.e. a string becomes a string slice.\n\t\t\tdefault:\n\t\t\t\t// Just re-try this function with data as a slice.\n\t\t\t\treturn d.decodeSlice(name, []interface{}{data}, val)\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s': source data must be an array or slice, got %s\", name, dataValKind)\n\t}\n\n\t// If the input value is nil, then don't allocate since empty != nil\n\tif dataValKind != reflect.Array && dataVal.IsNil() {\n\t\treturn nil\n\t}\n\n\tvalSlice := val\n\tif valSlice.IsNil() || d.config.ZeroFields {\n\t\t// Make a new slice to hold our result, same size as the original data.\n\t\tvalSlice = reflect.MakeSlice(sliceType, dataVal.Len(), dataVal.Len())\n\t} else if valSlice.Len() > dataVal.Len() {\n\t\tvalSlice = valSlice.Slice(0, dataVal.Len())\n\t}\n\n\t// Accumulate any errors\n\terrors := make([]string, 0)\n\n\tfor i := 0; i < dataVal.Len(); i++ {\n\t\tcurrentData := dataVal.Index(i).Interface()\n\t\tfor valSlice.Len() <= i {\n\t\t\tvalSlice = reflect.Append(valSlice, reflect.Zero(valElemType))\n\t\t}\n\t\tcurrentField := valSlice.Index(i)\n\n\t\tfieldName := name + \"[\" + strconv.Itoa(i) + \"]\"\n\t\tif err := d.decode(fieldName, currentData, currentField); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t}\n\t}\n\n\t// Finally, set the value to the slice we built up\n\tval.Set(valSlice)\n\n\t// If there were errors, we return those\n\tif len(errors) > 0 {\n\t\treturn &Error{errors}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeArray(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\tdataValKind := dataVal.Kind()\n\tvalType := val.Type()\n\tvalElemType := valType.Elem()\n\tarrayType := reflect.ArrayOf(valType.Len(), valElemType)\n\n\tvalArray := val\n\n\tif valArray.Interface() == reflect.Zero(valArray.Type()).Interface() || d.config.ZeroFields {\n\t\t// Check input type\n\t\tif dataValKind != reflect.Array && dataValKind != reflect.Slice {\n\t\t\tif d.config.WeaklyTypedInput {\n\t\t\t\tswitch {\n\t\t\t\t// Empty maps turn into empty arrays\n\t\t\t\tcase dataValKind == reflect.Map:\n\t\t\t\t\tif dataVal.Len() == 0 {\n\t\t\t\t\t\tval.Set(reflect.Zero(arrayType))\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\n\t\t\t\t// All other types we try to convert to the array type\n\t\t\t\t// and \"lift\" it into it. i.e. a string becomes a string array.\n\t\t\t\tdefault:\n\t\t\t\t\t// Just re-try this function with data as a slice.\n\t\t\t\t\treturn d.decodeArray(name, []interface{}{data}, val)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"'%s': source data must be an array or slice, got %s\", name, dataValKind)\n\n\t\t}\n\t\tif dataVal.Len() > arrayType.Len() {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"'%s': expected source data to have length less or equal to %d, got %d\", name, arrayType.Len(), dataVal.Len())\n\n\t\t}\n\n\t\t// Make a new array to hold our result, same size as the original data.\n\t\tvalArray = reflect.New(arrayType).Elem()\n\t}\n\n\t// Accumulate any errors\n\terrors := make([]string, 0)\n\n\tfor i := 0; i < dataVal.Len(); i++ {\n\t\tcurrentData := dataVal.Index(i).Interface()\n\t\tcurrentField := valArray.Index(i)\n\n\t\tfieldName := name + \"[\" + strconv.Itoa(i) + \"]\"\n\t\tif err := d.decode(fieldName, currentData, currentField); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t}\n\t}\n\n\t// Finally, set the value to the array we built up\n\tval.Set(valArray)\n\n\t// If there were errors, we return those\n\tif len(errors) > 0 {\n\t\treturn &Error{errors}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeStruct(name string, data interface{}, val reflect.Value) error {\n\tdataVal := reflect.Indirect(reflect.ValueOf(data))\n\n\t// If the type of the value to write to and the data match directly,\n\t// then we just set it directly instead of recursing into the structure.\n\tif dataVal.Type() == val.Type() {\n\t\tval.Set(dataVal)\n\t\treturn nil\n\t}\n\n\tdataValKind := dataVal.Kind()\n\tswitch dataValKind {\n\tcase reflect.Map:\n\t\treturn d.decodeStructFromMap(name, dataVal, val)\n\n\tcase reflect.Struct:\n\t\t// Not the most efficient way to do this but we can optimize later if\n\t\t// we want to. To convert from struct to struct we go to map first\n\t\t// as an intermediary.\n\n\t\t// Make a new map to hold our result\n\t\tmapType := reflect.TypeOf((map[string]interface{})(nil))\n\t\tmval := reflect.MakeMap(mapType)\n\n\t\t// Creating a pointer to a map so that other methods can completely\n\t\t// overwrite the map if need be (looking at you decodeMapFromMap). The\n\t\t// indirection allows the underlying map to be settable (CanSet() == true)\n\t\t// where as reflect.MakeMap returns an unsettable map.\n\t\taddrVal := reflect.New(mval.Type())\n\n\t\treflect.Indirect(addrVal).Set(mval)\n\t\tif err := d.decodeMapFromStruct(name, dataVal, reflect.Indirect(addrVal), mval); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresult := d.decodeStructFromMap(name, reflect.Indirect(addrVal), val)\n\t\treturn result\n\n\tdefault:\n\t\treturn fmt.Errorf(\"'%s' expected a map, got '%s'\", name, dataVal.Kind())\n\t}\n}\n\nfunc (d *Decoder) decodeStructFromMap(name string, dataVal, val reflect.Value) error {\n\tdataValType := dataVal.Type()\n\tif kind := dataValType.Key().Kind(); kind != reflect.String && kind != reflect.Interface {\n\t\treturn fmt.Errorf(\n\t\t\t\"'%s' needs a map with string keys, has '%s' keys\",\n\t\t\tname, dataValType.Key().Kind())\n\t}\n\n\tdataValKeys := make(map[reflect.Value]struct{})\n\tdataValKeysUnused := make(map[interface{}]struct{})\n\tfor _, dataValKey := range dataVal.MapKeys() {\n\t\tdataValKeys[dataValKey] = struct{}{}\n\t\tdataValKeysUnused[dataValKey.Interface()] = struct{}{}\n\t}\n\n\ttargetValKeysUnused := make(map[interface{}]struct{})\n\terrors := make([]string, 0)\n\n\t// This slice will keep track of all the structs we'll be decoding.\n\t// There can be more than one struct if there are embedded structs\n\t// that are squashed.\n\tstructs := make([]reflect.Value, 1, 5)\n\tstructs[0] = val\n\n\t// Compile the list of all the fields that we're going to be decoding\n\t// from all the structs.\n\ttype field struct {\n\t\tfield reflect.StructField\n\t\tval   reflect.Value\n\t}\n\n\t// remainField is set to a valid field set with the \"remain\" tag if\n\t// we are keeping track of remaining values.\n\tvar remainField *field\n\n\tfields := []field{}\n\tfor len(structs) > 0 {\n\t\tstructVal := structs[0]\n\t\tstructs = structs[1:]\n\n\t\tstructType := structVal.Type()\n\n\t\tfor i := 0; i < structType.NumField(); i++ {\n\t\t\tfieldType := structType.Field(i)\n\t\t\tfieldVal := structVal.Field(i)\n\t\t\tif fieldVal.Kind() == reflect.Ptr && fieldVal.Elem().Kind() == reflect.Struct {\n\t\t\t\t// Handle embedded struct pointers as embedded structs.\n\t\t\t\tfieldVal = fieldVal.Elem()\n\t\t\t}\n\n\t\t\t// If \"squash\" is specified in the tag, we squash the field down.\n\t\t\tsquash := d.config.Squash && fieldVal.Kind() == reflect.Struct && fieldType.Anonymous\n\t\t\tremain := false\n\n\t\t\t// We always parse the tags cause we're looking for other tags too\n\t\t\ttagParts := strings.Split(fieldType.Tag.Get(d.config.TagName), \",\")\n\t\t\tfor _, tag := range tagParts[1:] {\n\t\t\t\tif tag == \"squash\" {\n\t\t\t\t\tsquash = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif tag == \"remain\" {\n\t\t\t\t\tremain = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif squash {\n\t\t\t\tif fieldVal.Kind() != reflect.Struct {\n\t\t\t\t\terrors = appendErrors(errors,\n\t\t\t\t\t\tfmt.Errorf(\"%s: unsupported type for squash: %s\", fieldType.Name, fieldVal.Kind()))\n\t\t\t\t} else {\n\t\t\t\t\tstructs = append(structs, fieldVal)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Build our field\n\t\t\tif remain {\n\t\t\t\tremainField = &field{fieldType, fieldVal}\n\t\t\t} else {\n\t\t\t\t// Normal struct field, store it away\n\t\t\t\tfields = append(fields, field{fieldType, fieldVal})\n\t\t\t}\n\t\t}\n\t}\n\n\t// for fieldType, field := range fields {\n\tfor _, f := range fields {\n\t\tfield, fieldValue := f.field, f.val\n\t\tfieldName := field.Name\n\n\t\ttagValue := field.Tag.Get(d.config.TagName)\n\t\ttagValue = strings.SplitN(tagValue, \",\", 2)[0]\n\t\tif tagValue != \"\" {\n\t\t\tfieldName = tagValue\n\t\t}\n\n\t\trawMapKey := reflect.ValueOf(fieldName)\n\t\trawMapVal := dataVal.MapIndex(rawMapKey)\n\t\tif !rawMapVal.IsValid() {\n\t\t\t// Do a slower search by iterating over each key and\n\t\t\t// doing case-insensitive search.\n\t\t\tfor dataValKey := range dataValKeys {\n\t\t\t\tmK, ok := dataValKey.Interface().(string)\n\t\t\t\tif !ok {\n\t\t\t\t\t// Not a string key\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif d.config.MatchName(mK, fieldName) {\n\t\t\t\t\trawMapKey = dataValKey\n\t\t\t\t\trawMapVal = dataVal.MapIndex(dataValKey)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !rawMapVal.IsValid() {\n\t\t\t\t// There was no matching key in the map for the value in\n\t\t\t\t// the struct. Remember it for potential errors and metadata.\n\t\t\t\ttargetValKeysUnused[fieldName] = struct{}{}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif !fieldValue.IsValid() {\n\t\t\t// This should never happen\n\t\t\tpanic(\"field is not valid\")\n\t\t}\n\n\t\t// If we can't set the field, then it is unexported or something,\n\t\t// and we just continue onwards.\n\t\tif !fieldValue.CanSet() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Delete the key we're using from the unused map so we stop tracking\n\t\tdelete(dataValKeysUnused, rawMapKey.Interface())\n\n\t\t// If the name is empty string, then we're at the root, and we\n\t\t// don't dot-join the fields.\n\t\tif name != \"\" {\n\t\t\tfieldName = name + \".\" + fieldName\n\t\t}\n\n\t\tif err := d.decode(fieldName, rawMapVal.Interface(), fieldValue); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t}\n\t}\n\n\t// If we have a \"remain\"-tagged field and we have unused keys then\n\t// we put the unused keys directly into the remain field.\n\tif remainField != nil && len(dataValKeysUnused) > 0 {\n\t\t// Build a map of only the unused values\n\t\tremain := map[interface{}]interface{}{}\n\t\tfor key := range dataValKeysUnused {\n\t\t\tremain[key] = dataVal.MapIndex(reflect.ValueOf(key)).Interface()\n\t\t}\n\n\t\t// Decode it as-if we were just decoding this map onto our map.\n\t\tif err := d.decodeMap(name, remain, remainField.val); err != nil {\n\t\t\terrors = appendErrors(errors, err)\n\t\t}\n\n\t\t// Set the map to nil so we have none so that the next check will\n\t\t// not error (ErrorUnused)\n\t\tdataValKeysUnused = nil\n\t}\n\n\tif d.config.ErrorUnused && len(dataValKeysUnused) > 0 {\n\t\tkeys := make([]string, 0, len(dataValKeysUnused))\n\t\tfor rawKey := range dataValKeysUnused {\n\t\t\tkeys = append(keys, rawKey.(string))\n\t\t}\n\t\tsort.Strings(keys)\n\n\t\terr := fmt.Errorf(\"'%s' has invalid keys: %s\", name, strings.Join(keys, \", \"))\n\t\terrors = appendErrors(errors, err)\n\t}\n\n\tif d.config.ErrorUnset && len(targetValKeysUnused) > 0 {\n\t\tkeys := make([]string, 0, len(targetValKeysUnused))\n\t\tfor rawKey := range targetValKeysUnused {\n\t\t\tkeys = append(keys, rawKey.(string))\n\t\t}\n\t\tsort.Strings(keys)\n\n\t\terr := fmt.Errorf(\"'%s' has unset fields: %s\", name, strings.Join(keys, \", \"))\n\t\terrors = appendErrors(errors, err)\n\t}\n\n\tif len(errors) > 0 {\n\t\treturn &Error{errors}\n\t}\n\n\t// Add the unused keys to the list of unused keys if we're tracking metadata\n\tif d.config.Metadata != nil {\n\t\tfor rawKey := range dataValKeysUnused {\n\t\t\tkey := rawKey.(string)\n\t\t\tif name != \"\" {\n\t\t\t\tkey = name + \".\" + key\n\t\t\t}\n\n\t\t\td.config.Metadata.Unused = append(d.config.Metadata.Unused, key)\n\t\t}\n\t\tfor rawKey := range targetValKeysUnused {\n\t\t\tkey := rawKey.(string)\n\t\t\tif name != \"\" {\n\t\t\t\tkey = name + \".\" + key\n\t\t\t}\n\n\t\t\td.config.Metadata.Unset = append(d.config.Metadata.Unset, key)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc isEmptyValue(v reflect.Value) bool {\n\tswitch getKind(v) {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Ptr:\n\t\treturn v.IsNil()\n\t}\n\treturn false\n}\n\nfunc getKind(val reflect.Value) reflect.Kind {\n\tkind := val.Kind()\n\n\tswitch {\n\tcase kind >= reflect.Int && kind <= reflect.Int64:\n\t\treturn reflect.Int\n\tcase kind >= reflect.Uint && kind <= reflect.Uint64:\n\t\treturn reflect.Uint\n\tcase kind >= reflect.Float32 && kind <= reflect.Float64:\n\t\treturn reflect.Float32\n\tdefault:\n\t\treturn kind\n\t}\n}\n\nfunc isStructTypeConvertibleToMap(typ reflect.Type, checkMapstructureTags bool, tagName string) bool {\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tf := typ.Field(i)\n\t\tif f.PkgPath == \"\" && !checkMapstructureTags { // check for unexported fields\n\t\t\treturn true\n\t\t}\n\t\tif checkMapstructureTags && f.Tag.Get(tagName) != \"\" { // check for mapstructure tags inside\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc dereferencePtrToStructIfNeeded(v reflect.Value, tagName string) reflect.Value {\n\tif v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {\n\t\treturn v\n\t}\n\tderef := v.Elem()\n\tderefT := deref.Type()\n\tif isStructTypeConvertibleToMap(derefT, true, tagName) {\n\t\treturn deref\n\t}\n\treturn v\n}\n"
        },
        {
          "name": "mapstructure_benchmark_test.go",
          "type": "blob",
          "size": 5.62890625,
          "content": "package mapstructure\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\ntype Person struct {\n\tName   string\n\tAge    int\n\tEmails []string\n\tExtra  map[string]string\n}\n\nfunc Benchmark_Decode(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"name\":   \"Mitchell\",\n\t\t\"age\":    91,\n\t\t\"emails\": []string{\"one\", \"two\", \"three\"},\n\t\t\"extra\": map[string]string{\n\t\t\t\"twitter\": \"mitchellh\",\n\t\t},\n\t}\n\n\tvar result Person\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\n// decodeViaJSON takes the map data and passes it through encoding/json to convert it into the\n// given Go native structure pointed to by v. v must be a pointer to a struct.\nfunc decodeViaJSON(data interface{}, v interface{}) error {\n\t// Perform the task by simply marshalling the input into JSON,\n\t// then unmarshalling it into target native Go struct.\n\tb, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, v)\n}\n\nfunc Benchmark_DecodeViaJSON(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"name\":   \"Mitchell\",\n\t\t\"age\":    91,\n\t\t\"emails\": []string{\"one\", \"two\", \"three\"},\n\t\t\"extra\": map[string]string{\n\t\t\t\"twitter\": \"mitchellh\",\n\t\t},\n\t}\n\n\tvar result Person\n\tfor i := 0; i < b.N; i++ {\n\t\tdecodeViaJSON(input, &result)\n\t}\n}\n\nfunc Benchmark_JSONUnmarshal(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"name\":   \"Mitchell\",\n\t\t\"age\":    91,\n\t\t\"emails\": []string{\"one\", \"two\", \"three\"},\n\t\t\"extra\": map[string]string{\n\t\t\t\"twitter\": \"mitchellh\",\n\t\t},\n\t}\n\n\tinputB, err := json.Marshal(input)\n\tif err != nil {\n\t\tb.Fatal(\"Failed to marshal test input:\", err)\n\t}\n\n\tvar result Person\n\tfor i := 0; i < b.N; i++ {\n\t\tjson.Unmarshal(inputB, &result)\n\t}\n}\n\nfunc Benchmark_DecodeBasic(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"vstring\":     \"foo\",\n\t\t\"vint\":        42,\n\t\t\"Vuint\":       42,\n\t\t\"vbool\":       true,\n\t\t\"Vfloat\":      42.42,\n\t\t\"vsilent\":     true,\n\t\t\"vdata\":       42,\n\t\t\"vjsonInt\":    json.Number(\"1234\"),\n\t\t\"vjsonFloat\":  json.Number(\"1234.5\"),\n\t\t\"vjsonNumber\": json.Number(\"1234.5\"),\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar result Basic\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeEmbedded(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"Basic\": map[string]interface{}{\n\t\t\t\"vstring\": \"innerfoo\",\n\t\t},\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar result Embedded\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeTypeConversion(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"IntToFloat\":    42,\n\t\t\"IntToUint\":     42,\n\t\t\"IntToBool\":     1,\n\t\t\"IntToString\":   42,\n\t\t\"UintToInt\":     42,\n\t\t\"UintToFloat\":   42,\n\t\t\"UintToBool\":    42,\n\t\t\"UintToString\":  42,\n\t\t\"BoolToInt\":     true,\n\t\t\"BoolToUint\":    true,\n\t\t\"BoolToFloat\":   true,\n\t\t\"BoolToString\":  true,\n\t\t\"FloatToInt\":    42.42,\n\t\t\"FloatToUint\":   42.42,\n\t\t\"FloatToBool\":   42.42,\n\t\t\"FloatToString\": 42.42,\n\t\t\"StringToInt\":   \"42\",\n\t\t\"StringToUint\":  \"42\",\n\t\t\"StringToBool\":  \"1\",\n\t\t\"StringToFloat\": \"42.42\",\n\t\t\"SliceToMap\":    []interface{}{},\n\t\t\"MapToSlice\":    map[string]interface{}{},\n\t}\n\n\tvar resultStrict TypeConversionResult\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &resultStrict)\n\t}\n}\n\nfunc Benchmark_DecodeMap(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vother\": map[interface{}]interface{}{\n\t\t\t\"foo\": \"foo\",\n\t\t\t\"bar\": \"bar\",\n\t\t},\n\t}\n\n\tvar result Map\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeMapOfStruct(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"value\": map[string]interface{}{\n\t\t\t\"foo\": map[string]string{\"vstring\": \"one\"},\n\t\t\t\"bar\": map[string]string{\"vstring\": \"two\"},\n\t\t},\n\t}\n\n\tvar result MapOfStruct\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeSlice(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": []string{\"foo\", \"bar\", \"baz\"},\n\t}\n\n\tvar result Slice\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeSliceOfStruct(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"value\": []map[string]interface{}{\n\t\t\t{\"vstring\": \"one\"},\n\t\t\t{\"vstring\": \"two\"},\n\t\t},\n\t}\n\n\tvar result SliceOfStruct\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n\nfunc Benchmark_DecodeWeaklyTypedInput(b *testing.B) {\n\t// This input can come from anywhere, but typically comes from\n\t// something like decoding JSON, generated by a weakly typed language\n\t// such as PHP.\n\tinput := map[string]interface{}{\n\t\t\"name\":   123,                      // number => string\n\t\t\"age\":    \"42\",                     // string => number\n\t\t\"emails\": map[string]interface{}{}, // empty map => empty array\n\t}\n\n\tvar result Person\n\tconfig := &DecoderConfig{\n\t\tWeaklyTypedInput: true,\n\t\tResult:           &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdecoder.Decode(input)\n\t}\n}\n\nfunc Benchmark_DecodeMetadata(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"name\":  \"Mitchell\",\n\t\t\"age\":   91,\n\t\t\"email\": \"foo@bar.com\",\n\t}\n\n\tvar md Metadata\n\tvar result Person\n\tconfig := &DecoderConfig{\n\t\tMetadata: &md,\n\t\tResult:   &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdecoder.Decode(input)\n\t}\n}\n\nfunc Benchmark_DecodeMetadataEmbedded(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar md Metadata\n\tvar result EmbeddedSquash\n\tconfig := &DecoderConfig{\n\t\tMetadata: &md,\n\t\tResult:   &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tb.Fatalf(\"err: %s\", err)\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdecoder.Decode(input)\n\t}\n}\n\nfunc Benchmark_DecodeTagged(b *testing.B) {\n\tinput := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"value\",\n\t}\n\n\tvar result Tagged\n\tfor i := 0; i < b.N; i++ {\n\t\tDecode(input, &result)\n\t}\n}\n"
        },
        {
          "name": "mapstructure_bugs_test.go",
          "type": "blob",
          "size": 13.1044921875,
          "content": "package mapstructure\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\n// GH-1, GH-10, GH-96\nfunc TestDecode_NilValue(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\tin         interface{}\n\t\ttarget     interface{}\n\t\tout        interface{}\n\t\tmetaKeys   []string\n\t\tmetaUnused []string\n\t}{\n\t\t{\n\t\t\t\"all nil\",\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"vfoo\":   nil,\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"partial nil\",\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"vfoo\":   \"baz\",\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"baz\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"partial decode\",\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"foo\", Vother: nil},\n\t\t\t[]string{\"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"unused values\",\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"vbar\":   \"bar\",\n\t\t\t\t\"vfoo\":   nil,\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{\"vbar\"},\n\t\t},\n\t\t{\n\t\t\t\"map interface all nil\",\n\t\t\t&map[interface{}]interface{}{\n\t\t\t\t\"vfoo\":   nil,\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"map interface partial nil\",\n\t\t\t&map[interface{}]interface{}{\n\t\t\t\t\"vfoo\":   \"baz\",\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"baz\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"map interface partial decode\",\n\t\t\t&map[interface{}]interface{}{\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"foo\", Vother: nil},\n\t\t\t[]string{\"Vother\"},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"map interface unused values\",\n\t\t\t&map[interface{}]interface{}{\n\t\t\t\t\"vbar\":   \"bar\",\n\t\t\t\t\"vfoo\":   nil,\n\t\t\t\t\"vother\": nil,\n\t\t\t},\n\t\t\t&Map{Vfoo: \"foo\", Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&Map{Vfoo: \"\", Vother: nil},\n\t\t\t[]string{\"Vfoo\", \"Vother\"},\n\t\t\t[]string{\"vbar\"},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconfig := &DecoderConfig{\n\t\t\t\tMetadata:   new(Metadata),\n\t\t\t\tResult:     tc.target,\n\t\t\t\tZeroFields: true,\n\t\t\t}\n\n\t\t\tdecoder, err := NewDecoder(config)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"should not error: %s\", err)\n\t\t\t}\n\n\t\t\terr = decoder.Decode(tc.in)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"should not error: %s\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.out, tc.target) {\n\t\t\t\tt.Fatalf(\"%q: TestDecode_NilValue() expected: %#v, got: %#v\", tc.name, tc.out, tc.target)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.metaKeys, config.Metadata.Keys) {\n\t\t\t\tt.Fatalf(\"%q: Metadata.Keys mismatch expected: %#v, got: %#v\", tc.name, tc.metaKeys, config.Metadata.Keys)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.metaUnused, config.Metadata.Unused) {\n\t\t\t\tt.Fatalf(\"%q: Metadata.Unused mismatch expected: %#v, got: %#v\", tc.name, tc.metaUnused, config.Metadata.Unused)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// #48\nfunc TestNestedTypePointerWithDefaults(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"vint\":    42,\n\t\t\t\"vbool\":   true,\n\t\t},\n\t}\n\n\tresult := NestedPointer{\n\t\tVbar: &Basic{\n\t\t\tVuint: 42,\n\t\t},\n\t}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbar.Vstring)\n\t}\n\n\tif result.Vbar.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vbar.Vint)\n\t}\n\n\tif result.Vbar.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbar.Vbool)\n\t}\n\n\tif result.Vbar.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vbar.Vextra)\n\t}\n\n\t// this is the error\n\tif result.Vbar.Vuint != 42 {\n\t\tt.Errorf(\"vuint value should be 42: %#v\", result.Vbar.Vuint)\n\t}\n\n}\n\ntype NestedSlice struct {\n\tVfoo   string\n\tVbars  []Basic\n\tVempty []Basic\n}\n\n// #48\nfunc TestNestedTypeSliceWithDefaults(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbars\": []map[string]interface{}{\n\t\t\t{\"vstring\": \"foo\", \"vint\": 42, \"vbool\": true},\n\t\t\t{\"vint\": 42, \"vbool\": true},\n\t\t},\n\t\t\"vempty\": []map[string]interface{}{\n\t\t\t{\"vstring\": \"foo\", \"vint\": 42, \"vbool\": true},\n\t\t\t{\"vint\": 42, \"vbool\": true},\n\t\t},\n\t}\n\n\tresult := NestedSlice{\n\t\tVbars: []Basic{\n\t\t\t{Vuint: 42},\n\t\t\t{Vstring: \"foo\"},\n\t\t},\n\t}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbars[0].Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbars[0].Vstring)\n\t}\n\t// this is the error\n\tif result.Vbars[0].Vuint != 42 {\n\t\tt.Errorf(\"vuint value should be 42: %#v\", result.Vbars[0].Vuint)\n\t}\n}\n\n// #48 workaround\nfunc TestNestedTypeWithDefaults(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"vint\":    42,\n\t\t\t\"vbool\":   true,\n\t\t},\n\t}\n\n\tresult := Nested{\n\t\tVbar: Basic{\n\t\t\tVuint: 42,\n\t\t},\n\t}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbar.Vstring)\n\t}\n\n\tif result.Vbar.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vbar.Vint)\n\t}\n\n\tif result.Vbar.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbar.Vbool)\n\t}\n\n\tif result.Vbar.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vbar.Vextra)\n\t}\n\n\t// this is the error\n\tif result.Vbar.Vuint != 42 {\n\t\tt.Errorf(\"vuint value should be 42: %#v\", result.Vbar.Vuint)\n\t}\n\n}\n\n// #67 panic() on extending slices (decodeSlice with disabled ZeroValues)\nfunc TestDecodeSliceToEmptySliceWOZeroing(t *testing.T) {\n\tt.Parallel()\n\n\ttype TestStruct struct {\n\t\tVfoo []string\n\t}\n\n\tdecode := func(m interface{}, rawVal interface{}) error {\n\t\tconfig := &DecoderConfig{\n\t\t\tMetadata:   nil,\n\t\t\tResult:     rawVal,\n\t\t\tZeroFields: false,\n\t\t}\n\n\t\tdecoder, err := NewDecoder(config)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn decoder.Decode(m)\n\t}\n\n\t{\n\t\tinput := map[string]interface{}{\n\t\t\t\"vfoo\": []string{\"1\"},\n\t\t}\n\n\t\tresult := &TestStruct{}\n\n\t\terr := decode(input, &result)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t\t}\n\t}\n\n\t{\n\t\tinput := map[string]interface{}{\n\t\t\t\"vfoo\": []string{\"1\"},\n\t\t}\n\n\t\tresult := &TestStruct{\n\t\t\tVfoo: []string{},\n\t\t}\n\n\t\terr := decode(input, &result)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t\t}\n\t}\n\n\t{\n\t\tinput := map[string]interface{}{\n\t\t\t\"vfoo\": []string{\"2\", \"3\"},\n\t\t}\n\n\t\tresult := &TestStruct{\n\t\t\tVfoo: []string{\"1\"},\n\t\t}\n\n\t\terr := decode(input, &result)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t\t}\n\t}\n}\n\n// #70\nfunc TestNextSquashMapstructure(t *testing.T) {\n\tdata := &struct {\n\t\tLevel1 struct {\n\t\t\tLevel2 struct {\n\t\t\t\tFoo string\n\t\t\t} `mapstructure:\",squash\"`\n\t\t} `mapstructure:\",squash\"`\n\t}{}\n\terr := Decode(map[interface{}]interface{}{\"foo\": \"baz\"}, &data)\n\tif err != nil {\n\t\tt.Fatalf(\"should not error: %s\", err)\n\t}\n\tif data.Level1.Level2.Foo != \"baz\" {\n\t\tt.Fatal(\"value should be baz\")\n\t}\n}\n\ntype ImplementsInterfacePointerReceiver struct {\n\tName string\n}\n\nfunc (i *ImplementsInterfacePointerReceiver) DoStuff() {}\n\ntype ImplementsInterfaceValueReceiver string\n\nfunc (i ImplementsInterfaceValueReceiver) DoStuff() {}\n\n// GH-140 Type error when using DecodeHook to decode into interface\nfunc TestDecode_DecodeHookInterface(t *testing.T) {\n\tt.Parallel()\n\n\ttype Interface interface {\n\t\tDoStuff()\n\t}\n\ttype DecodeIntoInterface struct {\n\t\tTest Interface\n\t}\n\n\ttestData := map[string]string{\"test\": \"test\"}\n\n\tstringToPointerInterfaceDecodeHook := func(from, to reflect.Type, data interface{}) (interface{}, error) {\n\t\tif from.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\n\t\tif to != reflect.TypeOf((*Interface)(nil)).Elem() {\n\t\t\treturn data, nil\n\t\t}\n\t\t// Ensure interface is satisfied\n\t\tvar impl Interface = &ImplementsInterfacePointerReceiver{data.(string)}\n\t\treturn impl, nil\n\t}\n\n\tstringToValueInterfaceDecodeHook := func(from, to reflect.Type, data interface{}) (interface{}, error) {\n\t\tif from.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\n\t\tif to != reflect.TypeOf((*Interface)(nil)).Elem() {\n\t\t\treturn data, nil\n\t\t}\n\t\t// Ensure interface is satisfied\n\t\tvar impl Interface = ImplementsInterfaceValueReceiver(data.(string))\n\t\treturn impl, nil\n\t}\n\n\t{\n\t\tdecodeInto := new(DecodeIntoInterface)\n\n\t\tdecoder, _ := NewDecoder(&DecoderConfig{\n\t\t\tDecodeHook: stringToPointerInterfaceDecodeHook,\n\t\t\tResult:     decodeInto,\n\t\t})\n\n\t\terr := decoder.Decode(testData)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Decode returned error: %s\", err)\n\t\t}\n\n\t\texpected := &ImplementsInterfacePointerReceiver{\"test\"}\n\t\tif !reflect.DeepEqual(decodeInto.Test, expected) {\n\t\t\tt.Fatalf(\"expected: %#v (%T), got: %#v (%T)\", decodeInto.Test, decodeInto.Test, expected, expected)\n\t\t}\n\t}\n\n\t{\n\t\tdecodeInto := new(DecodeIntoInterface)\n\n\t\tdecoder, _ := NewDecoder(&DecoderConfig{\n\t\t\tDecodeHook: stringToValueInterfaceDecodeHook,\n\t\t\tResult:     decodeInto,\n\t\t})\n\n\t\terr := decoder.Decode(testData)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Decode returned error: %s\", err)\n\t\t}\n\n\t\texpected := ImplementsInterfaceValueReceiver(\"test\")\n\t\tif !reflect.DeepEqual(decodeInto.Test, expected) {\n\t\t\tt.Fatalf(\"expected: %#v (%T), got: %#v (%T)\", decodeInto.Test, decodeInto.Test, expected, expected)\n\t\t}\n\t}\n}\n\n// #103 Check for data type before trying to access its composants prevent a panic error\n// in decodeSlice\nfunc TestDecodeBadDataTypeInSlice(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"Toto\": \"titi\",\n\t}\n\tresult := []struct {\n\t\tToto string\n\t}{}\n\n\tif err := Decode(input, &result); err == nil {\n\t\tt.Error(\"An error was expected, got nil\")\n\t}\n}\n\n// #202 Ensure that intermediate maps in the struct -> struct decode process are settable\n// and not just the elements within them.\nfunc TestDecodeIntermediateMapsSettable(t *testing.T) {\n\ttype Timestamp struct {\n\t\tSeconds int64\n\t\tNanos   int32\n\t}\n\n\ttype TsWrapper struct {\n\t\tTimestamp *Timestamp\n\t}\n\n\ttype TimeWrapper struct {\n\t\tTimestamp time.Time\n\t}\n\n\tinput := TimeWrapper{\n\t\tTimestamp: time.Unix(123456789, 987654),\n\t}\n\n\texpected := TsWrapper{\n\t\tTimestamp: &Timestamp{\n\t\t\tSeconds: 123456789,\n\t\t\tNanos:   987654,\n\t\t},\n\t}\n\n\ttimePtrType := reflect.TypeOf((*time.Time)(nil))\n\tmapStrInfType := reflect.TypeOf((map[string]interface{})(nil))\n\n\tvar actual TsWrapper\n\tdecoder, err := NewDecoder(&DecoderConfig{\n\t\tResult: &actual,\n\t\tDecodeHook: func(from, to reflect.Type, data interface{}) (interface{}, error) {\n\t\t\tif from == timePtrType && to == mapStrInfType {\n\t\t\t\tts := data.(*time.Time)\n\t\t\t\tnanos := ts.UnixNano()\n\n\t\t\t\tseconds := nanos / 1000000000\n\t\t\t\tnanos = nanos % 1000000000\n\n\t\t\t\treturn &map[string]interface{}{\n\t\t\t\t\t\"Seconds\": seconds,\n\t\t\t\t\t\"Nanos\":   int32(nanos),\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\treturn data, nil\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create decoder: %v\", err)\n\t}\n\n\tif err := decoder.Decode(&input); err != nil {\n\t\tt.Fatalf(\"failed to decode input: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Fatalf(\"expected: %#[1]v (%[1]T), got: %#[2]v (%[2]T)\", expected, actual)\n\t}\n}\n\n// GH-206: decodeInt throws an error for an empty string\nfunc TestDecode_weakEmptyStringToInt(t *testing.T) {\n\tinput := map[string]interface{}{\n\t\t\"StringToInt\":   \"\",\n\t\t\"StringToUint\":  \"\",\n\t\t\"StringToBool\":  \"\",\n\t\t\"StringToFloat\": \"\",\n\t}\n\n\texpectedResultWeak := TypeConversionResult{\n\t\tStringToInt:   0,\n\t\tStringToUint:  0,\n\t\tStringToBool:  false,\n\t\tStringToFloat: 0,\n\t}\n\n\t// Test weak type conversion\n\tvar resultWeak TypeConversionResult\n\terr := WeakDecode(input, &resultWeak)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif !reflect.DeepEqual(resultWeak, expectedResultWeak) {\n\t\tt.Errorf(\"expected \\n%#v, got: \\n%#v\", expectedResultWeak, resultWeak)\n\t}\n}\n\n// GH-228: Squash cause *time.Time set to zero\nfunc TestMapSquash(t *testing.T) {\n\ttype AA struct {\n\t\tT *time.Time\n\t}\n\ttype A struct {\n\t\tAA\n\t}\n\n\tv := time.Now()\n\tin := &AA{\n\t\tT: &v,\n\t}\n\tout := &A{}\n\td, err := NewDecoder(&DecoderConfig{\n\t\tSquash: true,\n\t\tResult: out,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif err := d.Decode(in); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// these failed\n\tif !v.Equal(*out.T) {\n\t\tt.Fatal(\"expected equal\")\n\t}\n\tif out.T.IsZero() {\n\t\tt.Fatal(\"expected false\")\n\t}\n}\n\n// GH-238: Empty key name when decoding map from struct with only omitempty flag\nfunc TestMapOmitEmptyWithEmptyFieldnameInTag(t *testing.T) {\n\ttype Struct struct {\n\t\tUsername string `mapstructure:\",omitempty\"`\n\t\tAge      int    `mapstructure:\",omitempty\"`\n\t}\n\n\ts := Struct{\n\t\tUsername: \"Joe\",\n\t}\n\tvar m map[string]interface{}\n\n\tif err := Decode(s, &m); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(m) != 1 {\n\t\tt.Fatalf(\"fail: %#v\", m)\n\t}\n\tif m[\"Username\"] != \"Joe\" {\n\t\tt.Fatalf(\"fail: %#v\", m)\n\t}\n}\n"
        },
        {
          "name": "mapstructure_examples_test.go",
          "type": "blob",
          "size": 5.81640625,
          "content": "package mapstructure\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleDecode() {\n\ttype Person struct {\n\t\tName   string\n\t\tAge    int\n\t\tEmails []string\n\t\tExtra  map[string]string\n\t}\n\n\t// This input can come from anywhere, but typically comes from\n\t// something like decoding JSON where we're not quite sure of the\n\t// struct initially.\n\tinput := map[string]interface{}{\n\t\t\"name\":   \"Mitchell\",\n\t\t\"age\":    91,\n\t\t\"emails\": []string{\"one\", \"two\", \"three\"},\n\t\t\"extra\": map[string]string{\n\t\t\t\"twitter\": \"mitchellh\",\n\t\t},\n\t}\n\n\tvar result Person\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%#v\", result)\n\t// Output:\n\t// mapstructure.Person{Name:\"Mitchell\", Age:91, Emails:[]string{\"one\", \"two\", \"three\"}, Extra:map[string]string{\"twitter\":\"mitchellh\"}}\n}\n\nfunc ExampleDecode_errors() {\n\ttype Person struct {\n\t\tName   string\n\t\tAge    int\n\t\tEmails []string\n\t\tExtra  map[string]string\n\t}\n\n\t// This input can come from anywhere, but typically comes from\n\t// something like decoding JSON where we're not quite sure of the\n\t// struct initially.\n\tinput := map[string]interface{}{\n\t\t\"name\":   123,\n\t\t\"age\":    \"bad value\",\n\t\t\"emails\": []int{1, 2, 3},\n\t}\n\n\tvar result Person\n\terr := Decode(input, &result)\n\tif err == nil {\n\t\tpanic(\"should have an error\")\n\t}\n\n\tfmt.Println(err.Error())\n\t// Output:\n\t// 5 error(s) decoding:\n\t//\n\t// * 'Age' expected type 'int', got unconvertible type 'string', value: 'bad value'\n\t// * 'Emails[0]' expected type 'string', got unconvertible type 'int', value: '1'\n\t// * 'Emails[1]' expected type 'string', got unconvertible type 'int', value: '2'\n\t// * 'Emails[2]' expected type 'string', got unconvertible type 'int', value: '3'\n\t// * 'Name' expected type 'string', got unconvertible type 'int', value: '123'\n}\n\nfunc ExampleDecode_metadata() {\n\ttype Person struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\t// This input can come from anywhere, but typically comes from\n\t// something like decoding JSON where we're not quite sure of the\n\t// struct initially.\n\tinput := map[string]interface{}{\n\t\t\"name\":  \"Mitchell\",\n\t\t\"age\":   91,\n\t\t\"email\": \"foo@bar.com\",\n\t}\n\n\t// For metadata, we make a more advanced DecoderConfig so we can\n\t// more finely configure the decoder that is used. In this case, we\n\t// just tell the decoder we want to track metadata.\n\tvar md Metadata\n\tvar result Person\n\tconfig := &DecoderConfig{\n\t\tMetadata: &md,\n\t\tResult:   &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := decoder.Decode(input); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Unused keys: %#v\", md.Unused)\n\t// Output:\n\t// Unused keys: []string{\"email\"}\n}\n\nfunc ExampleDecode_weaklyTypedInput() {\n\ttype Person struct {\n\t\tName   string\n\t\tAge    int\n\t\tEmails []string\n\t}\n\n\t// This input can come from anywhere, but typically comes from\n\t// something like decoding JSON, generated by a weakly typed language\n\t// such as PHP.\n\tinput := map[string]interface{}{\n\t\t\"name\":   123,                      // number => string\n\t\t\"age\":    \"42\",                     // string => number\n\t\t\"emails\": map[string]interface{}{}, // empty map => empty array\n\t}\n\n\tvar result Person\n\tconfig := &DecoderConfig{\n\t\tWeaklyTypedInput: true,\n\t\tResult:           &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%#v\", result)\n\t// Output: mapstructure.Person{Name:\"123\", Age:42, Emails:[]string{}}\n}\n\nfunc ExampleDecode_tags() {\n\t// Note that the mapstructure tags defined in the struct type\n\t// can indicate which fields the values are mapped to.\n\ttype Person struct {\n\t\tName string `mapstructure:\"person_name\"`\n\t\tAge  int    `mapstructure:\"person_age\"`\n\t}\n\n\tinput := map[string]interface{}{\n\t\t\"person_name\": \"Mitchell\",\n\t\t\"person_age\":  91,\n\t}\n\n\tvar result Person\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%#v\", result)\n\t// Output:\n\t// mapstructure.Person{Name:\"Mitchell\", Age:91}\n}\n\nfunc ExampleDecode_embeddedStruct() {\n\t// Squashing multiple embedded structs is allowed using the squash tag.\n\t// This is demonstrated by creating a composite struct of multiple types\n\t// and decoding into it. In this case, a person can carry with it both\n\t// a Family and a Location, as well as their own FirstName.\n\ttype Family struct {\n\t\tLastName string\n\t}\n\ttype Location struct {\n\t\tCity string\n\t}\n\ttype Person struct {\n\t\tFamily    `mapstructure:\",squash\"`\n\t\tLocation  `mapstructure:\",squash\"`\n\t\tFirstName string\n\t}\n\n\tinput := map[string]interface{}{\n\t\t\"FirstName\": \"Mitchell\",\n\t\t\"LastName\":  \"Hashimoto\",\n\t\t\"City\":      \"San Francisco\",\n\t}\n\n\tvar result Person\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%s %s, %s\", result.FirstName, result.LastName, result.City)\n\t// Output:\n\t// Mitchell Hashimoto, San Francisco\n}\n\nfunc ExampleDecode_remainingData() {\n\t// Note that the mapstructure tags defined in the struct type\n\t// can indicate which fields the values are mapped to.\n\ttype Person struct {\n\t\tName  string\n\t\tAge   int\n\t\tOther map[string]interface{} `mapstructure:\",remain\"`\n\t}\n\n\tinput := map[string]interface{}{\n\t\t\"name\":  \"Mitchell\",\n\t\t\"age\":   91,\n\t\t\"email\": \"mitchell@example.com\",\n\t}\n\n\tvar result Person\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%#v\", result)\n\t// Output:\n\t// mapstructure.Person{Name:\"Mitchell\", Age:91, Other:map[string]interface {}{\"email\":\"mitchell@example.com\"}}\n}\n\nfunc ExampleDecode_omitempty() {\n\t// Add omitempty annotation to avoid map keys for empty values\n\ttype Family struct {\n\t\tLastName string\n\t}\n\ttype Location struct {\n\t\tCity string\n\t}\n\ttype Person struct {\n\t\t*Family   `mapstructure:\",omitempty\"`\n\t\t*Location `mapstructure:\",omitempty\"`\n\t\tAge       int\n\t\tFirstName string\n\t}\n\n\tresult := &map[string]interface{}{}\n\tinput := Person{FirstName: \"Somebody\"}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"%+v\", result)\n\t// Output:\n\t// &map[Age:0 FirstName:Somebody]\n}\n"
        },
        {
          "name": "mapstructure_test.go",
          "type": "blob",
          "size": 55.6826171875,
          "content": "package mapstructure\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype Basic struct {\n\tVstring     string\n\tVint        int\n\tVint8       int8\n\tVint16      int16\n\tVint32      int32\n\tVint64      int64\n\tVuint       uint\n\tVbool       bool\n\tVfloat      float64\n\tVextra      string\n\tvsilent     bool\n\tVdata       interface{}\n\tVjsonInt    int\n\tVjsonUint   uint\n\tVjsonUint64 uint64\n\tVjsonFloat  float64\n\tVjsonNumber json.Number\n}\n\ntype BasicPointer struct {\n\tVstring     *string\n\tVint        *int\n\tVuint       *uint\n\tVbool       *bool\n\tVfloat      *float64\n\tVextra      *string\n\tvsilent     *bool\n\tVdata       *interface{}\n\tVjsonInt    *int\n\tVjsonFloat  *float64\n\tVjsonNumber *json.Number\n}\n\ntype BasicSquash struct {\n\tTest Basic `mapstructure:\",squash\"`\n}\n\ntype Embedded struct {\n\tBasic\n\tVunique string\n}\n\ntype EmbeddedPointer struct {\n\t*Basic\n\tVunique string\n}\n\ntype EmbeddedSquash struct {\n\tBasic   `mapstructure:\",squash\"`\n\tVunique string\n}\n\ntype EmbeddedPointerSquash struct {\n\t*Basic  `mapstructure:\",squash\"`\n\tVunique string\n}\n\ntype BasicMapStructure struct {\n\tVunique string     `mapstructure:\"vunique\"`\n\tVtime   *time.Time `mapstructure:\"time\"`\n}\n\ntype NestedPointerWithMapstructure struct {\n\tVbar *BasicMapStructure `mapstructure:\"vbar\"`\n}\n\ntype EmbeddedPointerSquashWithNestedMapstructure struct {\n\t*NestedPointerWithMapstructure `mapstructure:\",squash\"`\n\tVunique                        string\n}\n\ntype EmbeddedAndNamed struct {\n\tBasic\n\tNamed   Basic\n\tVunique string\n}\n\ntype SliceAlias []string\n\ntype EmbeddedSlice struct {\n\tSliceAlias `mapstructure:\"slice_alias\"`\n\tVunique    string\n}\n\ntype ArrayAlias [2]string\n\ntype EmbeddedArray struct {\n\tArrayAlias `mapstructure:\"array_alias\"`\n\tVunique    string\n}\n\ntype SquashOnNonStructType struct {\n\tInvalidSquashType int `mapstructure:\",squash\"`\n}\n\ntype Map struct {\n\tVfoo   string\n\tVother map[string]string\n}\n\ntype MapOfStruct struct {\n\tValue map[string]Basic\n}\n\ntype Nested struct {\n\tVfoo string\n\tVbar Basic\n}\n\ntype NestedPointer struct {\n\tVfoo string\n\tVbar *Basic\n}\n\ntype NilInterface struct {\n\tW io.Writer\n}\n\ntype NilPointer struct {\n\tValue *string\n}\n\ntype Slice struct {\n\tVfoo string\n\tVbar []string\n}\n\ntype SliceOfByte struct {\n\tVfoo string\n\tVbar []byte\n}\n\ntype SliceOfAlias struct {\n\tVfoo string\n\tVbar SliceAlias\n}\n\ntype SliceOfStruct struct {\n\tValue []Basic\n}\n\ntype SlicePointer struct {\n\tVbar *[]string\n}\n\ntype Array struct {\n\tVfoo string\n\tVbar [2]string\n}\n\ntype ArrayOfStruct struct {\n\tValue [2]Basic\n}\n\ntype Func struct {\n\tFoo func() string\n}\n\ntype Tagged struct {\n\tExtra string `mapstructure:\"bar,what,what\"`\n\tValue string `mapstructure:\"foo\"`\n}\n\ntype Remainder struct {\n\tA     string\n\tExtra map[string]interface{} `mapstructure:\",remain\"`\n}\n\ntype StructWithOmitEmpty struct {\n\tVisibleStringField string                 `mapstructure:\"visible-string\"`\n\tOmitStringField    string                 `mapstructure:\"omittable-string,omitempty\"`\n\tVisibleIntField    int                    `mapstructure:\"visible-int\"`\n\tOmitIntField       int                    `mapstructure:\"omittable-int,omitempty\"`\n\tVisibleFloatField  float64                `mapstructure:\"visible-float\"`\n\tOmitFloatField     float64                `mapstructure:\"omittable-float,omitempty\"`\n\tVisibleSliceField  []interface{}          `mapstructure:\"visible-slice\"`\n\tOmitSliceField     []interface{}          `mapstructure:\"omittable-slice,omitempty\"`\n\tVisibleMapField    map[string]interface{} `mapstructure:\"visible-map\"`\n\tOmitMapField       map[string]interface{} `mapstructure:\"omittable-map,omitempty\"`\n\tNestedField        *Nested                `mapstructure:\"visible-nested\"`\n\tOmitNestedField    *Nested                `mapstructure:\"omittable-nested,omitempty\"`\n}\n\ntype TypeConversionResult struct {\n\tIntToFloat         float32\n\tIntToUint          uint\n\tIntToBool          bool\n\tIntToString        string\n\tUintToInt          int\n\tUintToFloat        float32\n\tUintToBool         bool\n\tUintToString       string\n\tBoolToInt          int\n\tBoolToUint         uint\n\tBoolToFloat        float32\n\tBoolToString       string\n\tFloatToInt         int\n\tFloatToUint        uint\n\tFloatToBool        bool\n\tFloatToString      string\n\tSliceUint8ToString string\n\tStringToSliceUint8 []byte\n\tArrayUint8ToString string\n\tStringToInt        int\n\tStringToUint       uint\n\tStringToBool       bool\n\tStringToFloat      float32\n\tStringToStrSlice   []string\n\tStringToIntSlice   []int\n\tStringToStrArray   [1]string\n\tStringToIntArray   [1]int\n\tSliceToMap         map[string]interface{}\n\tMapToSlice         []interface{}\n\tArrayToMap         map[string]interface{}\n\tMapToArray         [1]interface{}\n}\n\nfunc TestBasicTypes(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\":     \"foo\",\n\t\t\"vint\":        42,\n\t\t\"vint8\":       42,\n\t\t\"vint16\":      42,\n\t\t\"vint32\":      42,\n\t\t\"vint64\":      42,\n\t\t\"Vuint\":       42,\n\t\t\"vbool\":       true,\n\t\t\"Vfloat\":      42.42,\n\t\t\"vsilent\":     true,\n\t\t\"vdata\":       42,\n\t\t\"vjsonInt\":    json.Number(\"1234\"),\n\t\t\"vjsonUint\":   json.Number(\"1234\"),\n\t\t\"vjsonUint64\": json.Number(\"9223372036854775809\"), // 2^63 + 1\n\t\t\"vjsonFloat\":  json.Number(\"1234.5\"),\n\t\t\"vjsonNumber\": json.Number(\"1234.5\"),\n\t}\n\n\tvar result Basic\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Errorf(\"got an err: %s\", err.Error())\n\t\tt.FailNow()\n\t}\n\n\tif result.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vstring)\n\t}\n\n\tif result.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vint)\n\t}\n\tif result.Vint8 != 42 {\n\t\tt.Errorf(\"vint8 value should be 42: %#v\", result.Vint)\n\t}\n\tif result.Vint16 != 42 {\n\t\tt.Errorf(\"vint16 value should be 42: %#v\", result.Vint)\n\t}\n\tif result.Vint32 != 42 {\n\t\tt.Errorf(\"vint32 value should be 42: %#v\", result.Vint)\n\t}\n\tif result.Vint64 != 42 {\n\t\tt.Errorf(\"vint64 value should be 42: %#v\", result.Vint)\n\t}\n\n\tif result.Vuint != 42 {\n\t\tt.Errorf(\"vuint value should be 42: %#v\", result.Vuint)\n\t}\n\n\tif result.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbool)\n\t}\n\n\tif result.Vfloat != 42.42 {\n\t\tt.Errorf(\"vfloat value should be 42.42: %#v\", result.Vfloat)\n\t}\n\n\tif result.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vextra)\n\t}\n\n\tif result.vsilent != false {\n\t\tt.Error(\"vsilent should not be set, it is unexported\")\n\t}\n\n\tif result.Vdata != 42 {\n\t\tt.Error(\"vdata should be valid\")\n\t}\n\n\tif result.VjsonInt != 1234 {\n\t\tt.Errorf(\"vjsonint value should be 1234: %#v\", result.VjsonInt)\n\t}\n\n\tif result.VjsonUint != 1234 {\n\t\tt.Errorf(\"vjsonuint value should be 1234: %#v\", result.VjsonUint)\n\t}\n\n\tif result.VjsonUint64 != 9223372036854775809 {\n\t\tt.Errorf(\"vjsonuint64 value should be 9223372036854775809: %#v\", result.VjsonUint64)\n\t}\n\n\tif result.VjsonFloat != 1234.5 {\n\t\tt.Errorf(\"vjsonfloat value should be 1234.5: %#v\", result.VjsonFloat)\n\t}\n\n\tif !reflect.DeepEqual(result.VjsonNumber, json.Number(\"1234.5\")) {\n\t\tt.Errorf(\"vjsonnumber value should be '1234.5': %T, %#v\", result.VjsonNumber, result.VjsonNumber)\n\t}\n}\n\nfunc TestBasic_IntWithFloat(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vint\": float64(42),\n\t}\n\n\tvar result Basic\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n}\n\nfunc TestBasic_Merge(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vint\": 42,\n\t}\n\n\tvar result Basic\n\tresult.Vuint = 100\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\texpected := Basic{\n\t\tVint:  42,\n\t\tVuint: 100,\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\n// Test for issue #46.\nfunc TestBasic_Struct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vdata\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t},\n\t}\n\n\tvar result, inner Basic\n\tresult.Vdata = &inner\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\texpected := Basic{\n\t\tVdata: &Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestBasic_interfaceStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t}\n\n\tvar iface interface{} = &Basic{}\n\terr := Decode(input, &iface)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\texpected := &Basic{\n\t\tVstring: \"foo\",\n\t}\n\tif !reflect.DeepEqual(iface, expected) {\n\t\tt.Fatalf(\"bad: %#v\", iface)\n\t}\n}\n\n// Issue 187\nfunc TestBasic_interfaceStructNonPtr(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t}\n\n\tvar iface interface{} = Basic{}\n\terr := Decode(input, &iface)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\texpected := Basic{\n\t\tVstring: \"foo\",\n\t}\n\tif !reflect.DeepEqual(iface, expected) {\n\t\tt.Fatalf(\"bad: %#v\", iface)\n\t}\n}\n\nfunc TestDecode_BasicSquash(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t}\n\n\tvar result BasicSquash\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Test.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Test.Vstring)\n\t}\n}\n\nfunc TestDecodeFrom_BasicSquash(t *testing.T) {\n\tt.Parallel()\n\n\tvar v interface{}\n\tvar ok bool\n\n\tinput := BasicSquash{\n\t\tTest: Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t}\n\n\tvar result map[string]interface{}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif _, ok = result[\"Test\"]; ok {\n\t\tt.Error(\"test should not be present in map\")\n\t}\n\n\tv, ok = result[\"Vstring\"]\n\tif !ok {\n\t\tt.Error(\"vstring should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"foo\") {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", v)\n\t}\n}\n\nfunc TestDecode_Embedded(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"Basic\": map[string]interface{}{\n\t\t\t\"vstring\": \"innerfoo\",\n\t\t},\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar result Embedded\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vstring != \"innerfoo\" {\n\t\tt.Errorf(\"vstring value should be 'innerfoo': %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_EmbeddedPointer(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"Basic\": map[string]interface{}{\n\t\t\t\"vstring\": \"innerfoo\",\n\t\t},\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar result EmbeddedPointer\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\texpected := EmbeddedPointer{\n\t\tBasic: &Basic{\n\t\t\tVstring: \"innerfoo\",\n\t\t},\n\t\tVunique: \"bar\",\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestDecode_EmbeddedSlice(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"slice_alias\": []string{\"foo\", \"bar\"},\n\t\t\"vunique\":     \"bar\",\n\t}\n\n\tvar result EmbeddedSlice\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif !reflect.DeepEqual(result.SliceAlias, SliceAlias([]string{\"foo\", \"bar\"})) {\n\t\tt.Errorf(\"slice value: %#v\", result.SliceAlias)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_EmbeddedArray(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"array_alias\": [2]string{\"foo\", \"bar\"},\n\t\t\"vunique\":     \"bar\",\n\t}\n\n\tvar result EmbeddedArray\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif !reflect.DeepEqual(result.ArrayAlias, ArrayAlias([2]string{\"foo\", \"bar\"})) {\n\t\tt.Errorf(\"array value: %#v\", result.ArrayAlias)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_decodeSliceWithArray(t *testing.T) {\n\tt.Parallel()\n\n\tvar result []int\n\tinput := [1]int{1}\n\texpected := []int{1}\n\tif err := Decode(input, &result); err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif !reflect.DeepEqual(expected, result) {\n\t\tt.Errorf(\"wanted %+v, got %+v\", expected, result)\n\t}\n}\n\nfunc TestDecode_EmbeddedNoSquash(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar result Embedded\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vstring != \"\" {\n\t\tt.Errorf(\"vstring value should be empty: %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_EmbeddedPointerNoSquash(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tresult := EmbeddedPointer{\n\t\tBasic: &Basic{},\n\t}\n\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif result.Vstring != \"\" {\n\t\tt.Errorf(\"vstring value should be empty: %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_EmbeddedSquash(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar result EmbeddedSquash\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecodeFrom_EmbeddedSquash(t *testing.T) {\n\tt.Parallel()\n\n\tvar v interface{}\n\tvar ok bool\n\n\tinput := EmbeddedSquash{\n\t\tBasic: Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t\tVunique: \"bar\",\n\t}\n\n\tvar result map[string]interface{}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif _, ok = result[\"Basic\"]; ok {\n\t\tt.Error(\"basic should not be present in map\")\n\t}\n\n\tv, ok = result[\"Vstring\"]\n\tif !ok {\n\t\tt.Error(\"vstring should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"foo\") {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", v)\n\t}\n\n\tv, ok = result[\"Vunique\"]\n\tif !ok {\n\t\tt.Error(\"vunique should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"bar\") {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", v)\n\t}\n}\n\nfunc TestDecode_EmbeddedPointerSquash_FromStructToMap(t *testing.T) {\n\tt.Parallel()\n\n\tinput := EmbeddedPointerSquash{\n\t\tBasic: &Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t\tVunique: \"bar\",\n\t}\n\n\tvar result map[string]interface{}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result[\"Vstring\"] != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result[\"Vstring\"])\n\t}\n\n\tif result[\"Vunique\"] != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result[\"Vunique\"])\n\t}\n}\n\nfunc TestDecode_EmbeddedPointerSquash_FromMapToStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"Vstring\": \"foo\",\n\t\t\"Vunique\": \"bar\",\n\t}\n\n\tresult := EmbeddedPointerSquash{\n\t\tBasic: &Basic{},\n\t}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n}\n\nfunc TestDecode_EmbeddedPointerSquashWithNestedMapstructure_FromStructToMap(t *testing.T) {\n\tt.Parallel()\n\n\tvTime := time.Now()\n\n\tinput := EmbeddedPointerSquashWithNestedMapstructure{\n\t\tNestedPointerWithMapstructure: &NestedPointerWithMapstructure{\n\t\t\tVbar: &BasicMapStructure{\n\t\t\t\tVunique: \"bar\",\n\t\t\t\tVtime:   &vTime,\n\t\t\t},\n\t\t},\n\t\tVunique: \"foo\",\n\t}\n\n\tvar result map[string]interface{}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\texpected := map[string]interface{}{\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vunique\": \"bar\",\n\t\t\t\"time\":    &vTime,\n\t\t},\n\t\t\"Vunique\": \"foo\",\n\t}\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"result should be %#v: got %#v\", expected, result)\n\t}\n}\n\nfunc TestDecode_EmbeddedPointerSquashWithNestedMapstructure_FromMapToStruct(t *testing.T) {\n\tt.Parallel()\n\n\tvTime := time.Now()\n\n\tinput := map[string]interface{}{\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vunique\": \"bar\",\n\t\t\t\"time\":    &vTime,\n\t\t},\n\t\t\"Vunique\": \"foo\",\n\t}\n\n\tresult := EmbeddedPointerSquashWithNestedMapstructure{\n\t\tNestedPointerWithMapstructure: &NestedPointerWithMapstructure{},\n\t}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\texpected := EmbeddedPointerSquashWithNestedMapstructure{\n\t\tNestedPointerWithMapstructure: &NestedPointerWithMapstructure{\n\t\t\tVbar: &BasicMapStructure{\n\t\t\t\tVunique: \"bar\",\n\t\t\t\tVtime:   &vTime,\n\t\t\t},\n\t\t},\n\t\tVunique: \"foo\",\n\t}\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"result should be %#v: got %#v\", expected, result)\n\t}\n}\n\nfunc TestDecode_EmbeddedSquashConfig(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t\t\"Named\": map[string]interface{}{\n\t\t\t\"vstring\": \"baz\",\n\t\t},\n\t}\n\n\tvar result EmbeddedAndNamed\n\tconfig := &DecoderConfig{\n\t\tSquash: true,\n\t\tResult: &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vstring)\n\t}\n\n\tif result.Vunique != \"bar\" {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", result.Vunique)\n\t}\n\n\tif result.Named.Vstring != \"baz\" {\n\t\tt.Errorf(\"Named.vstring value should be 'baz': %#v\", result.Named.Vstring)\n\t}\n}\n\nfunc TestDecodeFrom_EmbeddedSquashConfig(t *testing.T) {\n\tt.Parallel()\n\n\tinput := EmbeddedAndNamed{\n\t\tBasic:   Basic{Vstring: \"foo\"},\n\t\tNamed:   Basic{Vstring: \"baz\"},\n\t\tVunique: \"bar\",\n\t}\n\n\tresult := map[string]interface{}{}\n\tconfig := &DecoderConfig{\n\t\tSquash: true,\n\t\tResult: &result,\n\t}\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif _, ok := result[\"Basic\"]; ok {\n\t\tt.Error(\"basic should not be present in map\")\n\t}\n\n\tv, ok := result[\"Vstring\"]\n\tif !ok {\n\t\tt.Error(\"vstring should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"foo\") {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", v)\n\t}\n\n\tv, ok = result[\"Vunique\"]\n\tif !ok {\n\t\tt.Error(\"vunique should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"bar\") {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", v)\n\t}\n\n\tv, ok = result[\"Named\"]\n\tif !ok {\n\t\tt.Error(\"Named should be present in map\")\n\t} else {\n\t\tnamed := v.(map[string]interface{})\n\t\tv, ok := named[\"Vstring\"]\n\t\tif !ok {\n\t\t\tt.Error(\"Named: vstring should be present in map\")\n\t\t} else if !reflect.DeepEqual(v, \"baz\") {\n\t\t\tt.Errorf(\"Named: vstring should be 'baz': %#v\", v)\n\t\t}\n\t}\n}\n\nfunc TestDecodeFrom_EmbeddedSquashConfig_WithTags(t *testing.T) {\n\tt.Parallel()\n\n\tvar v interface{}\n\tvar ok bool\n\n\tinput := EmbeddedSquash{\n\t\tBasic: Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t\tVunique: \"bar\",\n\t}\n\n\tresult := map[string]interface{}{}\n\tconfig := &DecoderConfig{\n\t\tSquash: true,\n\t\tResult: &result,\n\t}\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif _, ok = result[\"Basic\"]; ok {\n\t\tt.Error(\"basic should not be present in map\")\n\t}\n\n\tv, ok = result[\"Vstring\"]\n\tif !ok {\n\t\tt.Error(\"vstring should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"foo\") {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", v)\n\t}\n\n\tv, ok = result[\"Vunique\"]\n\tif !ok {\n\t\tt.Error(\"vunique should be present in map\")\n\t} else if !reflect.DeepEqual(v, \"bar\") {\n\t\tt.Errorf(\"vunique value should be 'bar': %#v\", v)\n\t}\n}\n\nfunc TestDecode_SquashOnNonStructType(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"InvalidSquashType\": 42,\n\t}\n\n\tvar result SquashOnNonStructType\n\terr := Decode(input, &result)\n\tif err == nil {\n\t\tt.Fatal(\"unexpected success decoding invalid squash field type\")\n\t} else if !strings.Contains(err.Error(), \"unsupported type for squash\") {\n\t\tt.Fatalf(\"unexpected error message for invalid squash field type: %s\", err)\n\t}\n}\n\nfunc TestDecode_DecodeHook(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vint\": \"WHAT\",\n\t}\n\n\tdecodeHook := func(from reflect.Kind, to reflect.Kind, v interface{}) (interface{}, error) {\n\t\tif from == reflect.String && to != reflect.String {\n\t\t\treturn 5, nil\n\t\t}\n\n\t\treturn v, nil\n\t}\n\n\tvar result Basic\n\tconfig := &DecoderConfig{\n\t\tDecodeHook: decodeHook,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Vint != 5 {\n\t\tt.Errorf(\"vint should be 5: %#v\", result.Vint)\n\t}\n}\n\nfunc TestDecode_DecodeHookType(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vint\": \"WHAT\",\n\t}\n\n\tdecodeHook := func(from reflect.Type, to reflect.Type, v interface{}) (interface{}, error) {\n\t\tif from.Kind() == reflect.String &&\n\t\t\tto.Kind() != reflect.String {\n\t\t\treturn 5, nil\n\t\t}\n\n\t\treturn v, nil\n\t}\n\n\tvar result Basic\n\tconfig := &DecoderConfig{\n\t\tDecodeHook: decodeHook,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Vint != 5 {\n\t\tt.Errorf(\"vint should be 5: %#v\", result.Vint)\n\t}\n}\n\nfunc TestDecode_Nil(t *testing.T) {\n\tt.Parallel()\n\n\tvar input interface{}\n\tresult := Basic{\n\t\tVstring: \"foo\",\n\t}\n\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif result.Vstring != \"foo\" {\n\t\tt.Fatalf(\"bad: %#v\", result.Vstring)\n\t}\n}\n\nfunc TestDecode_NilInterfaceHook(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"w\": \"\",\n\t}\n\n\tdecodeHook := func(f, t reflect.Type, v interface{}) (interface{}, error) {\n\t\tif t.String() == \"io.Writer\" {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn v, nil\n\t}\n\n\tvar result NilInterface\n\tconfig := &DecoderConfig{\n\t\tDecodeHook: decodeHook,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.W != nil {\n\t\tt.Errorf(\"W should be nil: %#v\", result.W)\n\t}\n}\n\nfunc TestDecode_NilPointerHook(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"value\": \"\",\n\t}\n\n\tdecodeHook := func(f, t reflect.Type, v interface{}) (interface{}, error) {\n\t\tif typed, ok := v.(string); ok {\n\t\t\tif typed == \"\" {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t}\n\t\treturn v, nil\n\t}\n\n\tvar result NilPointer\n\tconfig := &DecoderConfig{\n\t\tDecodeHook: decodeHook,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Value != nil {\n\t\tt.Errorf(\"W should be nil: %#v\", result.Value)\n\t}\n}\n\nfunc TestDecode_FuncHook(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"foo\": \"baz\",\n\t}\n\n\tdecodeHook := func(f, t reflect.Type, v interface{}) (interface{}, error) {\n\t\tif t.Kind() != reflect.Func {\n\t\t\treturn v, nil\n\t\t}\n\t\tval := v.(string)\n\t\treturn func() string { return val }, nil\n\t}\n\n\tvar result Func\n\tconfig := &DecoderConfig{\n\t\tDecodeHook: decodeHook,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Foo() != \"baz\" {\n\t\tt.Errorf(\"Foo call result should be 'baz': %s\", result.Foo())\n\t}\n}\n\nfunc TestDecode_NonStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"baz\",\n\t}\n\n\tvar result map[string]string\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif result[\"foo\"] != \"bar\" {\n\t\tt.Fatal(\"foo is not bar\")\n\t}\n}\n\nfunc TestDecode_StructMatch(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vbar\": Basic{\n\t\t\tVstring: \"foo\",\n\t\t},\n\t}\n\n\tvar result Nested\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestDecode_TypeConversion(t *testing.T) {\n\tinput := map[string]interface{}{\n\t\t\"IntToFloat\":         42,\n\t\t\"IntToUint\":          42,\n\t\t\"IntToBool\":          1,\n\t\t\"IntToString\":        42,\n\t\t\"UintToInt\":          42,\n\t\t\"UintToFloat\":        42,\n\t\t\"UintToBool\":         42,\n\t\t\"UintToString\":       42,\n\t\t\"BoolToInt\":          true,\n\t\t\"BoolToUint\":         true,\n\t\t\"BoolToFloat\":        true,\n\t\t\"BoolToString\":       true,\n\t\t\"FloatToInt\":         42.42,\n\t\t\"FloatToUint\":        42.42,\n\t\t\"FloatToBool\":        42.42,\n\t\t\"FloatToString\":      42.42,\n\t\t\"SliceUint8ToString\": []uint8(\"foo\"),\n\t\t\"StringToSliceUint8\": \"foo\",\n\t\t\"ArrayUint8ToString\": [3]uint8{'f', 'o', 'o'},\n\t\t\"StringToInt\":        \"42\",\n\t\t\"StringToUint\":       \"42\",\n\t\t\"StringToBool\":       \"1\",\n\t\t\"StringToFloat\":      \"42.42\",\n\t\t\"StringToStrSlice\":   \"A\",\n\t\t\"StringToIntSlice\":   \"42\",\n\t\t\"StringToStrArray\":   \"A\",\n\t\t\"StringToIntArray\":   \"42\",\n\t\t\"SliceToMap\":         []interface{}{},\n\t\t\"MapToSlice\":         map[string]interface{}{},\n\t\t\"ArrayToMap\":         []interface{}{},\n\t\t\"MapToArray\":         map[string]interface{}{},\n\t}\n\n\texpectedResultStrict := TypeConversionResult{\n\t\tIntToFloat:  42.0,\n\t\tIntToUint:   42,\n\t\tUintToInt:   42,\n\t\tUintToFloat: 42,\n\t\tBoolToInt:   0,\n\t\tBoolToUint:  0,\n\t\tBoolToFloat: 0,\n\t\tFloatToInt:  42,\n\t\tFloatToUint: 42,\n\t}\n\n\texpectedResultWeak := TypeConversionResult{\n\t\tIntToFloat:         42.0,\n\t\tIntToUint:          42,\n\t\tIntToBool:          true,\n\t\tIntToString:        \"42\",\n\t\tUintToInt:          42,\n\t\tUintToFloat:        42,\n\t\tUintToBool:         true,\n\t\tUintToString:       \"42\",\n\t\tBoolToInt:          1,\n\t\tBoolToUint:         1,\n\t\tBoolToFloat:        1,\n\t\tBoolToString:       \"1\",\n\t\tFloatToInt:         42,\n\t\tFloatToUint:        42,\n\t\tFloatToBool:        true,\n\t\tFloatToString:      \"42.42\",\n\t\tSliceUint8ToString: \"foo\",\n\t\tStringToSliceUint8: []byte(\"foo\"),\n\t\tArrayUint8ToString: \"foo\",\n\t\tStringToInt:        42,\n\t\tStringToUint:       42,\n\t\tStringToBool:       true,\n\t\tStringToFloat:      42.42,\n\t\tStringToStrSlice:   []string{\"A\"},\n\t\tStringToIntSlice:   []int{42},\n\t\tStringToStrArray:   [1]string{\"A\"},\n\t\tStringToIntArray:   [1]int{42},\n\t\tSliceToMap:         map[string]interface{}{},\n\t\tMapToSlice:         []interface{}{},\n\t\tArrayToMap:         map[string]interface{}{},\n\t\tMapToArray:         [1]interface{}{},\n\t}\n\n\t// Test strict type conversion\n\tvar resultStrict TypeConversionResult\n\terr := Decode(input, &resultStrict)\n\tif err == nil {\n\t\tt.Errorf(\"should return an error\")\n\t}\n\tif !reflect.DeepEqual(resultStrict, expectedResultStrict) {\n\t\tt.Errorf(\"expected %v, got: %v\", expectedResultStrict, resultStrict)\n\t}\n\n\t// Test weak type conversion\n\tvar decoder *Decoder\n\tvar resultWeak TypeConversionResult\n\n\tconfig := &DecoderConfig{\n\t\tWeaklyTypedInput: true,\n\t\tResult:           &resultWeak,\n\t}\n\n\tdecoder, err = NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif !reflect.DeepEqual(resultWeak, expectedResultWeak) {\n\t\tt.Errorf(\"expected \\n%#v, got: \\n%#v\", expectedResultWeak, resultWeak)\n\t}\n}\n\nfunc TestDecoder_ErrorUnused(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"hello\",\n\t\t\"foo\":     \"bar\",\n\t}\n\n\tvar result Basic\n\tconfig := &DecoderConfig{\n\t\tErrorUnused: true,\n\t\tResult:      &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestDecoder_ErrorUnused_NotSetable(t *testing.T) {\n\tt.Parallel()\n\n\t// lowercase vsilent is unexported and cannot be set\n\tinput := map[string]interface{}{\n\t\t\"vsilent\": \"false\",\n\t}\n\n\tvar result Basic\n\tconfig := &DecoderConfig{\n\t\tErrorUnused: true,\n\t\tResult:      &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\nfunc TestDecoder_ErrorUnset(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"hello\",\n\t\t\"foo\":     \"bar\",\n\t}\n\n\tvar result Basic\n\tconfig := &DecoderConfig{\n\t\tErrorUnset: true,\n\t\tResult:     &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestMap(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vother\": map[interface{}]interface{}{\n\t\t\t\"foo\": \"foo\",\n\t\t\t\"bar\": \"bar\",\n\t\t},\n\t}\n\n\tvar result Map\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an error: %s\", err)\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vother == nil {\n\t\tt.Fatal(\"vother should not be nil\")\n\t}\n\n\tif len(result.Vother) != 2 {\n\t\tt.Error(\"vother should have two items\")\n\t}\n\n\tif result.Vother[\"foo\"] != \"foo\" {\n\t\tt.Errorf(\"'foo' key should be foo, got: %#v\", result.Vother[\"foo\"])\n\t}\n\n\tif result.Vother[\"bar\"] != \"bar\" {\n\t\tt.Errorf(\"'bar' key should be bar, got: %#v\", result.Vother[\"bar\"])\n\t}\n}\n\nfunc TestMapMerge(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vother\": map[interface{}]interface{}{\n\t\t\t\"foo\": \"foo\",\n\t\t\t\"bar\": \"bar\",\n\t\t},\n\t}\n\n\tvar result Map\n\tresult.Vother = map[string]string{\"hello\": \"world\"}\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an error: %s\", err)\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\texpected := map[string]string{\n\t\t\"foo\":   \"foo\",\n\t\t\"bar\":   \"bar\",\n\t\t\"hello\": \"world\",\n\t}\n\tif !reflect.DeepEqual(result.Vother, expected) {\n\t\tt.Errorf(\"bad: %#v\", result.Vother)\n\t}\n}\n\nfunc TestMapOfStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"value\": map[string]interface{}{\n\t\t\t\"foo\": map[string]string{\"vstring\": \"one\"},\n\t\t\t\"bar\": map[string]string{\"vstring\": \"two\"},\n\t\t},\n\t}\n\n\tvar result MapOfStruct\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err)\n\t}\n\n\tif result.Value == nil {\n\t\tt.Fatal(\"value should not be nil\")\n\t}\n\n\tif len(result.Value) != 2 {\n\t\tt.Error(\"value should have two items\")\n\t}\n\n\tif result.Value[\"foo\"].Vstring != \"one\" {\n\t\tt.Errorf(\"foo value should be 'one', got: %s\", result.Value[\"foo\"].Vstring)\n\t}\n\n\tif result.Value[\"bar\"].Vstring != \"two\" {\n\t\tt.Errorf(\"bar value should be 'two', got: %s\", result.Value[\"bar\"].Vstring)\n\t}\n}\n\nfunc TestNestedType(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"vint\":    42,\n\t\t\t\"vbool\":   true,\n\t\t},\n\t}\n\n\tvar result Nested\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbar.Vstring)\n\t}\n\n\tif result.Vbar.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vbar.Vint)\n\t}\n\n\tif result.Vbar.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbar.Vbool)\n\t}\n\n\tif result.Vbar.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vbar.Vextra)\n\t}\n}\n\nfunc TestNestedTypePointer(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": &map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"vint\":    42,\n\t\t\t\"vbool\":   true,\n\t\t},\n\t}\n\n\tvar result NestedPointer\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbar.Vstring)\n\t}\n\n\tif result.Vbar.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vbar.Vint)\n\t}\n\n\tif result.Vbar.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbar.Vbool)\n\t}\n\n\tif result.Vbar.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vbar.Vextra)\n\t}\n}\n\n// Test for issue #46.\nfunc TestNestedTypeInterface(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": &map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"vint\":    42,\n\t\t\t\"vbool\":   true,\n\n\t\t\t\"vdata\": map[string]interface{}{\n\t\t\t\t\"vstring\": \"bar\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar result NestedPointer\n\tresult.Vbar = new(Basic)\n\tresult.Vbar.Vdata = new(Basic)\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an err: %s\", err.Error())\n\t}\n\n\tif result.Vfoo != \"foo\" {\n\t\tt.Errorf(\"vfoo value should be 'foo': %#v\", result.Vfoo)\n\t}\n\n\tif result.Vbar.Vstring != \"foo\" {\n\t\tt.Errorf(\"vstring value should be 'foo': %#v\", result.Vbar.Vstring)\n\t}\n\n\tif result.Vbar.Vint != 42 {\n\t\tt.Errorf(\"vint value should be 42: %#v\", result.Vbar.Vint)\n\t}\n\n\tif result.Vbar.Vbool != true {\n\t\tt.Errorf(\"vbool value should be true: %#v\", result.Vbar.Vbool)\n\t}\n\n\tif result.Vbar.Vextra != \"\" {\n\t\tt.Errorf(\"vextra value should be empty: %#v\", result.Vbar.Vextra)\n\t}\n\n\tif result.Vbar.Vdata.(*Basic).Vstring != \"bar\" {\n\t\tt.Errorf(\"vstring value should be 'bar': %#v\", result.Vbar.Vdata.(*Basic).Vstring)\n\t}\n}\n\nfunc TestSlice(t *testing.T) {\n\tt.Parallel()\n\n\tinputStringSlice := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": []string{\"foo\", \"bar\", \"baz\"},\n\t}\n\n\tinputStringSlicePointer := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": &[]string{\"foo\", \"bar\", \"baz\"},\n\t}\n\n\toutputStringSlice := &Slice{\n\t\t\"foo\",\n\t\t[]string{\"foo\", \"bar\", \"baz\"},\n\t}\n\n\ttestSliceInput(t, inputStringSlice, outputStringSlice)\n\ttestSliceInput(t, inputStringSlicePointer, outputStringSlice)\n}\n\nfunc TestNotEmptyByteSlice(t *testing.T) {\n\tt.Parallel()\n\n\tinputByteSlice := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": []byte(`{\"bar\": \"bar\"}`),\n\t}\n\n\tresult := SliceOfByte{\n\t\tVfoo: \"another foo\",\n\t\tVbar: []byte(`{\"bar\": \"bar bar bar bar bar bar bar bar\"}`),\n\t}\n\n\terr := Decode(inputByteSlice, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got unexpected error: %s\", err)\n\t}\n\n\texpected := SliceOfByte{\n\t\tVfoo: \"foo\",\n\t\tVbar: []byte(`{\"bar\": \"bar\"}`),\n\t}\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestInvalidSlice(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": 42,\n\t}\n\n\tresult := Slice{}\n\terr := Decode(input, &result)\n\tif err == nil {\n\t\tt.Errorf(\"expected failure\")\n\t}\n}\n\nfunc TestSliceOfStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"value\": []map[string]interface{}{\n\t\t\t{\"vstring\": \"one\"},\n\t\t\t{\"vstring\": \"two\"},\n\t\t},\n\t}\n\n\tvar result SliceOfStruct\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got unexpected error: %s\", err)\n\t}\n\n\tif len(result.Value) != 2 {\n\t\tt.Fatalf(\"expected two values, got %d\", len(result.Value))\n\t}\n\n\tif result.Value[0].Vstring != \"one\" {\n\t\tt.Errorf(\"first value should be 'one', got: %s\", result.Value[0].Vstring)\n\t}\n\n\tif result.Value[1].Vstring != \"two\" {\n\t\tt.Errorf(\"second value should be 'two', got: %s\", result.Value[1].Vstring)\n\t}\n}\n\nfunc TestSliceCornerCases(t *testing.T) {\n\tt.Parallel()\n\n\t// Input with a map with zero values\n\tinput := map[string]interface{}{}\n\tvar resultWeak []Basic\n\n\terr := WeakDecode(input, &resultWeak)\n\tif err != nil {\n\t\tt.Fatalf(\"got unexpected error: %s\", err)\n\t}\n\n\tif len(resultWeak) != 0 {\n\t\tt.Errorf(\"length should be 0\")\n\t}\n\t// Input with more values\n\tinput = map[string]interface{}{\n\t\t\"Vstring\": \"foo\",\n\t}\n\n\tresultWeak = nil\n\terr = WeakDecode(input, &resultWeak)\n\tif err != nil {\n\t\tt.Fatalf(\"got unexpected error: %s\", err)\n\t}\n\n\tif resultWeak[0].Vstring != \"foo\" {\n\t\tt.Errorf(\"value does not match\")\n\t}\n}\n\nfunc TestSliceToMap(t *testing.T) {\n\tt.Parallel()\n\n\tinput := []map[string]interface{}{\n\t\t{\n\t\t\t\"foo\": \"bar\",\n\t\t},\n\t\t{\n\t\t\t\"bar\": \"baz\",\n\t\t},\n\t}\n\n\tvar result map[string]interface{}\n\terr := WeakDecode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an error: %s\", err)\n\t}\n\n\texpected := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"baz\",\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestArray(t *testing.T) {\n\tt.Parallel()\n\n\tinputStringArray := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": [2]string{\"foo\", \"bar\"},\n\t}\n\n\tinputStringArrayPointer := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": &[2]string{\"foo\", \"bar\"},\n\t}\n\n\toutputStringArray := &Array{\n\t\t\"foo\",\n\t\t[2]string{\"foo\", \"bar\"},\n\t}\n\n\ttestArrayInput(t, inputStringArray, outputStringArray)\n\ttestArrayInput(t, inputStringArrayPointer, outputStringArray)\n}\n\nfunc TestInvalidArray(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": 42,\n\t}\n\n\tresult := Array{}\n\terr := Decode(input, &result)\n\tif err == nil {\n\t\tt.Errorf(\"expected failure\")\n\t}\n}\n\nfunc TestArrayOfStruct(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"value\": []map[string]interface{}{\n\t\t\t{\"vstring\": \"one\"},\n\t\t\t{\"vstring\": \"two\"},\n\t\t},\n\t}\n\n\tvar result ArrayOfStruct\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got unexpected error: %s\", err)\n\t}\n\n\tif len(result.Value) != 2 {\n\t\tt.Fatalf(\"expected two values, got %d\", len(result.Value))\n\t}\n\n\tif result.Value[0].Vstring != \"one\" {\n\t\tt.Errorf(\"first value should be 'one', got: %s\", result.Value[0].Vstring)\n\t}\n\n\tif result.Value[1].Vstring != \"two\" {\n\t\tt.Errorf(\"second value should be 'two', got: %s\", result.Value[1].Vstring)\n\t}\n}\n\nfunc TestArrayToMap(t *testing.T) {\n\tt.Parallel()\n\n\tinput := []map[string]interface{}{\n\t\t{\n\t\t\t\"foo\": \"bar\",\n\t\t},\n\t\t{\n\t\t\t\"bar\": \"baz\",\n\t\t},\n\t}\n\n\tvar result map[string]interface{}\n\terr := WeakDecode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got an error: %s\", err)\n\t}\n\n\texpected := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"baz\",\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestDecodeTable(t *testing.T) {\n\tt.Parallel()\n\n\t// We need to make new types so that we don't get the short-circuit\n\t// copy functionality. We want to test the deep copying functionality.\n\ttype BasicCopy Basic\n\ttype NestedPointerCopy NestedPointer\n\ttype MapCopy Map\n\n\ttests := []struct {\n\t\tname    string\n\t\tin      interface{}\n\t\ttarget  interface{}\n\t\tout     interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\t\"basic struct input\",\n\t\t\t&Basic{\n\t\t\t\tVstring: \"vstring\",\n\t\t\t\tVint:    2,\n\t\t\t\tVint8:   2,\n\t\t\t\tVint16:  2,\n\t\t\t\tVint32:  2,\n\t\t\t\tVint64:  2,\n\t\t\t\tVuint:   3,\n\t\t\t\tVbool:   true,\n\t\t\t\tVfloat:  4.56,\n\t\t\t\tVextra:  \"vextra\",\n\t\t\t\tvsilent: true,\n\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Vstring\":     \"vstring\",\n\t\t\t\t\"Vint\":        2,\n\t\t\t\t\"Vint8\":       int8(2),\n\t\t\t\t\"Vint16\":      int16(2),\n\t\t\t\t\"Vint32\":      int32(2),\n\t\t\t\t\"Vint64\":      int64(2),\n\t\t\t\t\"Vuint\":       uint(3),\n\t\t\t\t\"Vbool\":       true,\n\t\t\t\t\"Vfloat\":      4.56,\n\t\t\t\t\"Vextra\":      \"vextra\",\n\t\t\t\t\"Vdata\":       []byte(\"data\"),\n\t\t\t\t\"VjsonInt\":    0,\n\t\t\t\t\"VjsonUint\":   uint(0),\n\t\t\t\t\"VjsonUint64\": uint64(0),\n\t\t\t\t\"VjsonFloat\":  0.0,\n\t\t\t\t\"VjsonNumber\": json.Number(\"\"),\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"embedded struct input\",\n\t\t\t&Embedded{\n\t\t\t\tVunique: \"vunique\",\n\t\t\t\tBasic: Basic{\n\t\t\t\t\tVstring: \"vstring\",\n\t\t\t\t\tVint:    2,\n\t\t\t\t\tVint8:   2,\n\t\t\t\t\tVint16:  2,\n\t\t\t\t\tVint32:  2,\n\t\t\t\t\tVint64:  2,\n\t\t\t\t\tVuint:   3,\n\t\t\t\t\tVbool:   true,\n\t\t\t\t\tVfloat:  4.56,\n\t\t\t\t\tVextra:  \"vextra\",\n\t\t\t\t\tvsilent: true,\n\t\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Vunique\": \"vunique\",\n\t\t\t\t\"Basic\": map[string]interface{}{\n\t\t\t\t\t\"Vstring\":     \"vstring\",\n\t\t\t\t\t\"Vint\":        2,\n\t\t\t\t\t\"Vint8\":       int8(2),\n\t\t\t\t\t\"Vint16\":      int16(2),\n\t\t\t\t\t\"Vint32\":      int32(2),\n\t\t\t\t\t\"Vint64\":      int64(2),\n\t\t\t\t\t\"Vuint\":       uint(3),\n\t\t\t\t\t\"Vbool\":       true,\n\t\t\t\t\t\"Vfloat\":      4.56,\n\t\t\t\t\t\"Vextra\":      \"vextra\",\n\t\t\t\t\t\"Vdata\":       []byte(\"data\"),\n\t\t\t\t\t\"VjsonInt\":    0,\n\t\t\t\t\t\"VjsonUint\":   uint(0),\n\t\t\t\t\t\"VjsonUint64\": uint64(0),\n\t\t\t\t\t\"VjsonFloat\":  0.0,\n\t\t\t\t\t\"VjsonNumber\": json.Number(\"\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct => struct\",\n\t\t\t&Basic{\n\t\t\t\tVstring: \"vstring\",\n\t\t\t\tVint:    2,\n\t\t\t\tVuint:   3,\n\t\t\t\tVbool:   true,\n\t\t\t\tVfloat:  4.56,\n\t\t\t\tVextra:  \"vextra\",\n\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t\tvsilent: true,\n\t\t\t},\n\t\t\t&BasicCopy{},\n\t\t\t&BasicCopy{\n\t\t\t\tVstring: \"vstring\",\n\t\t\t\tVint:    2,\n\t\t\t\tVuint:   3,\n\t\t\t\tVbool:   true,\n\t\t\t\tVfloat:  4.56,\n\t\t\t\tVextra:  \"vextra\",\n\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct => struct with pointers\",\n\t\t\t&NestedPointer{\n\t\t\t\tVfoo: \"hello\",\n\t\t\t\tVbar: nil,\n\t\t\t},\n\t\t\t&NestedPointerCopy{},\n\t\t\t&NestedPointerCopy{\n\t\t\t\tVfoo: \"hello\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"basic pointer to non-pointer\",\n\t\t\t&BasicPointer{\n\t\t\t\tVstring: stringPtr(\"vstring\"),\n\t\t\t\tVint:    intPtr(2),\n\t\t\t\tVuint:   uintPtr(3),\n\t\t\t\tVbool:   boolPtr(true),\n\t\t\t\tVfloat:  floatPtr(4.56),\n\t\t\t\tVdata:   interfacePtr([]byte(\"data\")),\n\t\t\t},\n\t\t\t&Basic{},\n\t\t\t&Basic{\n\t\t\t\tVstring: \"vstring\",\n\t\t\t\tVint:    2,\n\t\t\t\tVuint:   3,\n\t\t\t\tVbool:   true,\n\t\t\t\tVfloat:  4.56,\n\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"slice non-pointer to pointer\",\n\t\t\t&Slice{},\n\t\t\t&SlicePointer{},\n\t\t\t&SlicePointer{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"slice non-pointer to pointer, zero field\",\n\t\t\t&Slice{},\n\t\t\t&SlicePointer{\n\t\t\t\tVbar: &[]string{\"yo\"},\n\t\t\t},\n\t\t\t&SlicePointer{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"slice to slice alias\",\n\t\t\t&Slice{},\n\t\t\t&SliceOfAlias{},\n\t\t\t&SliceOfAlias{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"nil map to map\",\n\t\t\t&Map{},\n\t\t\t&MapCopy{},\n\t\t\t&MapCopy{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"nil map to non-empty map\",\n\t\t\t&Map{},\n\t\t\t&MapCopy{Vother: map[string]string{\"foo\": \"bar\"}},\n\t\t\t&MapCopy{},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t\"slice input - should error\",\n\t\t\t[]string{\"foo\", \"bar\"},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"struct with slice property\",\n\t\t\t&Slice{\n\t\t\t\tVfoo: \"vfoo\",\n\t\t\t\tVbar: []string{\"foo\", \"bar\"},\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Vfoo\": \"vfoo\",\n\t\t\t\t\"Vbar\": []string{\"foo\", \"bar\"},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct with empty slice\",\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Vbar\": []string{},\n\t\t\t},\n\t\t\t&Slice{},\n\t\t\t&Slice{\n\t\t\t\tVbar: []string{},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct with slice of struct property\",\n\t\t\t&SliceOfStruct{\n\t\t\t\tValue: []Basic{\n\t\t\t\t\tBasic{\n\t\t\t\t\t\tVstring: \"vstring\",\n\t\t\t\t\t\tVint:    2,\n\t\t\t\t\t\tVuint:   3,\n\t\t\t\t\t\tVbool:   true,\n\t\t\t\t\t\tVfloat:  4.56,\n\t\t\t\t\t\tVextra:  \"vextra\",\n\t\t\t\t\t\tvsilent: true,\n\t\t\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Value\": []Basic{\n\t\t\t\t\tBasic{\n\t\t\t\t\t\tVstring: \"vstring\",\n\t\t\t\t\t\tVint:    2,\n\t\t\t\t\t\tVuint:   3,\n\t\t\t\t\t\tVbool:   true,\n\t\t\t\t\t\tVfloat:  4.56,\n\t\t\t\t\t\tVextra:  \"vextra\",\n\t\t\t\t\t\tvsilent: true,\n\t\t\t\t\t\tVdata:   []byte(\"data\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct with map property\",\n\t\t\t&Map{\n\t\t\t\tVfoo:   \"vfoo\",\n\t\t\t\tVother: map[string]string{\"vother\": \"vother\"},\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\n\t\t\t\t\"Vfoo\": \"vfoo\",\n\t\t\t\t\"Vother\": map[string]string{\n\t\t\t\t\t\"vother\": \"vother\",\n\t\t\t\t}},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"tagged struct\",\n\t\t\t&Tagged{\n\t\t\t\tExtra: \"extra\",\n\t\t\t\tValue: \"value\",\n\t\t\t},\n\t\t\t&map[string]string{},\n\t\t\t&map[string]string{\n\t\t\t\t\"bar\": \"extra\",\n\t\t\t\t\"foo\": \"value\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"omit tag struct\",\n\t\t\t&struct {\n\t\t\t\tValue string `mapstructure:\"value\"`\n\t\t\t\tOmit  string `mapstructure:\"-\"`\n\t\t\t}{\n\t\t\t\tValue: \"value\",\n\t\t\t\tOmit:  \"omit\",\n\t\t\t},\n\t\t\t&map[string]string{},\n\t\t\t&map[string]string{\n\t\t\t\t\"value\": \"value\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"decode to wrong map type\",\n\t\t\t&struct {\n\t\t\t\tValue string\n\t\t\t}{\n\t\t\t\tValue: \"string\",\n\t\t\t},\n\t\t\t&map[string]int{},\n\t\t\t&map[string]int{},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"remainder\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"A\": \"hello\",\n\t\t\t\t\"B\": \"goodbye\",\n\t\t\t\t\"C\": \"yo\",\n\t\t\t},\n\t\t\t&Remainder{},\n\t\t\t&Remainder{\n\t\t\t\tA: \"hello\",\n\t\t\t\tExtra: map[string]interface{}{\n\t\t\t\t\t\"B\": \"goodbye\",\n\t\t\t\t\t\"C\": \"yo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"remainder with no extra\",\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"A\": \"hello\",\n\t\t\t},\n\t\t\t&Remainder{},\n\t\t\t&Remainder{\n\t\t\t\tA:     \"hello\",\n\t\t\t\tExtra: nil,\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct with omitempty tag return non-empty values\",\n\t\t\t&struct {\n\t\t\t\tVisibleField interface{} `mapstructure:\"visible\"`\n\t\t\t\tOmitField    interface{} `mapstructure:\"omittable,omitempty\"`\n\t\t\t}{\n\t\t\t\tVisibleField: nil,\n\t\t\t\tOmitField:    \"string\",\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\"visible\": nil, \"omittable\": \"string\"},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"struct with omitempty tag ignore empty values\",\n\t\t\t&struct {\n\t\t\t\tVisibleField interface{} `mapstructure:\"visible\"`\n\t\t\t\tOmitField    interface{} `mapstructure:\"omittable,omitempty\"`\n\t\t\t}{\n\t\t\t\tVisibleField: nil,\n\t\t\t\tOmitField:    nil,\n\t\t\t},\n\t\t\t&map[string]interface{}{},\n\t\t\t&map[string]interface{}{\"visible\": nil},\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := Decode(tt.in, tt.target); (err != nil) != tt.wantErr {\n\t\t\t\tt.Fatalf(\"%q: TestMapOutputForStructuredInputs() unexpected error: %s\", tt.name, err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tt.out, tt.target) {\n\t\t\t\tt.Fatalf(\"%q: TestMapOutputForStructuredInputs() expected: %#v, got: %#v\", tt.name, tt.out, tt.target)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInvalidType(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": 42,\n\t}\n\n\tvar result Basic\n\terr := Decode(input, &result)\n\tif err == nil {\n\t\tt.Fatal(\"error should exist\")\n\t}\n\n\tderr, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"error should be kind of Error, instead: %#v\", err)\n\t}\n\n\tif derr.Errors[0] !=\n\t\t\"'Vstring' expected type 'string', got unconvertible type 'int', value: '42'\" {\n\t\tt.Errorf(\"got unexpected error: %s\", err)\n\t}\n\n\tinputNegIntUint := map[string]interface{}{\n\t\t\"vuint\": -42,\n\t}\n\n\terr = Decode(inputNegIntUint, &result)\n\tif err == nil {\n\t\tt.Fatal(\"error should exist\")\n\t}\n\n\tderr, ok = err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"error should be kind of Error, instead: %#v\", err)\n\t}\n\n\tif derr.Errors[0] != \"cannot parse 'Vuint', -42 overflows uint\" {\n\t\tt.Errorf(\"got unexpected error: %s\", err)\n\t}\n\n\tinputNegFloatUint := map[string]interface{}{\n\t\t\"vuint\": -42.0,\n\t}\n\n\terr = Decode(inputNegFloatUint, &result)\n\tif err == nil {\n\t\tt.Fatal(\"error should exist\")\n\t}\n\n\tderr, ok = err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"error should be kind of Error, instead: %#v\", err)\n\t}\n\n\tif derr.Errors[0] != \"cannot parse 'Vuint', -42.000000 overflows uint\" {\n\t\tt.Errorf(\"got unexpected error: %s\", err)\n\t}\n}\n\nfunc TestDecodeMetadata(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"Vuint\":   42,\n\t\t\t\"vsilent\": \"false\",\n\t\t\t\"foo\":     \"bar\",\n\t\t},\n\t\t\"bar\": \"nil\",\n\t}\n\n\tvar md Metadata\n\tvar result Nested\n\n\terr := DecodeMetadata(input, &result, &md)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err.Error())\n\t}\n\n\texpectedKeys := []string{\"Vbar\", \"Vbar.Vstring\", \"Vbar.Vuint\", \"Vfoo\"}\n\tsort.Strings(md.Keys)\n\tif !reflect.DeepEqual(md.Keys, expectedKeys) {\n\t\tt.Fatalf(\"bad keys: %#v\", md.Keys)\n\t}\n\n\texpectedUnused := []string{\"Vbar.foo\", \"Vbar.vsilent\", \"bar\"}\n\tsort.Strings(md.Unused)\n\tif !reflect.DeepEqual(md.Unused, expectedUnused) {\n\t\tt.Fatalf(\"bad unused: %#v\", md.Unused)\n\t}\n}\n\nfunc TestMetadata(t *testing.T) {\n\tt.Parallel()\n\n\ttype testResult struct {\n\t\tVfoo string\n\t\tVbar BasicPointer\n\t}\n\n\tinput := map[string]interface{}{\n\t\t\"vfoo\": \"foo\",\n\t\t\"vbar\": map[string]interface{}{\n\t\t\t\"vstring\": \"foo\",\n\t\t\t\"Vuint\":   42,\n\t\t\t\"vsilent\": \"false\",\n\t\t\t\"foo\":     \"bar\",\n\t\t},\n\t\t\"bar\": \"nil\",\n\t}\n\n\tvar md Metadata\n\tvar result testResult\n\tconfig := &DecoderConfig{\n\t\tMetadata: &md,\n\t\tResult:   &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err.Error())\n\t}\n\n\texpectedKeys := []string{\"Vbar\", \"Vbar.Vstring\", \"Vbar.Vuint\", \"Vfoo\"}\n\tsort.Strings(md.Keys)\n\tif !reflect.DeepEqual(md.Keys, expectedKeys) {\n\t\tt.Fatalf(\"bad keys: %#v\", md.Keys)\n\t}\n\n\texpectedUnused := []string{\"Vbar.foo\", \"Vbar.vsilent\", \"bar\"}\n\tsort.Strings(md.Unused)\n\tif !reflect.DeepEqual(md.Unused, expectedUnused) {\n\t\tt.Fatalf(\"bad unused: %#v\", md.Unused)\n\t}\n\n\texpectedUnset := []string{\n\t\t\"Vbar.Vbool\", \"Vbar.Vdata\", \"Vbar.Vextra\", \"Vbar.Vfloat\", \"Vbar.Vint\",\n\t\t\"Vbar.VjsonFloat\", \"Vbar.VjsonInt\", \"Vbar.VjsonNumber\"}\n\tsort.Strings(md.Unset)\n\tif !reflect.DeepEqual(md.Unset, expectedUnset) {\n\t\tt.Fatalf(\"bad unset: %#v\", md.Unset)\n\t}\n}\n\nfunc TestMetadata_Embedded(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"vstring\": \"foo\",\n\t\t\"vunique\": \"bar\",\n\t}\n\n\tvar md Metadata\n\tvar result EmbeddedSquash\n\tconfig := &DecoderConfig{\n\t\tMetadata: &md,\n\t\tResult:   &result,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err.Error())\n\t}\n\n\texpectedKeys := []string{\"Vstring\", \"Vunique\"}\n\n\tsort.Strings(md.Keys)\n\tif !reflect.DeepEqual(md.Keys, expectedKeys) {\n\t\tt.Fatalf(\"bad keys: %#v\", md.Keys)\n\t}\n\n\texpectedUnused := []string{}\n\tif !reflect.DeepEqual(md.Unused, expectedUnused) {\n\t\tt.Fatalf(\"bad unused: %#v\", md.Unused)\n\t}\n}\n\nfunc TestNonPtrValue(t *testing.T) {\n\tt.Parallel()\n\n\terr := Decode(map[string]interface{}{}, Basic{})\n\tif err == nil {\n\t\tt.Fatal(\"error should exist\")\n\t}\n\n\tif err.Error() != \"result must be a pointer\" {\n\t\tt.Errorf(\"got unexpected error: %s\", err)\n\t}\n}\n\nfunc TestTagged(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"value\",\n\t}\n\n\tvar result Tagged\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif result.Value != \"bar\" {\n\t\tt.Errorf(\"value should be 'bar', got: %#v\", result.Value)\n\t}\n\n\tif result.Extra != \"value\" {\n\t\tt.Errorf(\"extra should be 'value', got: %#v\", result.Extra)\n\t}\n}\n\nfunc TestWeakDecode(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"foo\": \"4\",\n\t\t\"bar\": \"value\",\n\t}\n\n\tvar result struct {\n\t\tFoo int\n\t\tBar string\n\t}\n\n\tif err := WeakDecode(input, &result); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif result.Foo != 4 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\tif result.Bar != \"value\" {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestWeakDecodeMetadata(t *testing.T) {\n\tt.Parallel()\n\n\tinput := map[string]interface{}{\n\t\t\"foo\":        \"4\",\n\t\t\"bar\":        \"value\",\n\t\t\"unused\":     \"value\",\n\t\t\"unexported\": \"value\",\n\t}\n\n\tvar md Metadata\n\tvar result struct {\n\t\tFoo        int\n\t\tBar        string\n\t\tunexported string\n\t}\n\n\tif err := WeakDecodeMetadata(input, &result, &md); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif result.Foo != 4 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\tif result.Bar != \"value\" {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\texpectedKeys := []string{\"Bar\", \"Foo\"}\n\tsort.Strings(md.Keys)\n\tif !reflect.DeepEqual(md.Keys, expectedKeys) {\n\t\tt.Fatalf(\"bad keys: %#v\", md.Keys)\n\t}\n\n\texpectedUnused := []string{\"unexported\", \"unused\"}\n\tsort.Strings(md.Unused)\n\tif !reflect.DeepEqual(md.Unused, expectedUnused) {\n\t\tt.Fatalf(\"bad unused: %#v\", md.Unused)\n\t}\n}\n\nfunc TestDecode_StructTaggedWithOmitempty_OmitEmptyValues(t *testing.T) {\n\tt.Parallel()\n\n\tinput := &StructWithOmitEmpty{}\n\n\tvar emptySlice []interface{}\n\tvar emptyMap map[string]interface{}\n\tvar emptyNested *Nested\n\texpected := &map[string]interface{}{\n\t\t\"visible-string\": \"\",\n\t\t\"visible-int\":    0,\n\t\t\"visible-float\":  0.0,\n\t\t\"visible-slice\":  emptySlice,\n\t\t\"visible-map\":    emptyMap,\n\t\t\"visible-nested\": emptyNested,\n\t}\n\n\tactual := &map[string]interface{}{}\n\tDecode(input, actual)\n\n\tif !reflect.DeepEqual(actual, expected) {\n\t\tt.Fatalf(\"Decode() expected: %#v, got: %#v\", expected, actual)\n\t}\n}\n\nfunc TestDecode_StructTaggedWithOmitempty_KeepNonEmptyValues(t *testing.T) {\n\tt.Parallel()\n\n\tinput := &StructWithOmitEmpty{\n\t\tVisibleStringField: \"\",\n\t\tOmitStringField:    \"string\",\n\t\tVisibleIntField:    0,\n\t\tOmitIntField:       1,\n\t\tVisibleFloatField:  0.0,\n\t\tOmitFloatField:     1.0,\n\t\tVisibleSliceField:  nil,\n\t\tOmitSliceField:     []interface{}{1},\n\t\tVisibleMapField:    nil,\n\t\tOmitMapField:       map[string]interface{}{\"k\": \"v\"},\n\t\tNestedField:        nil,\n\t\tOmitNestedField:    &Nested{},\n\t}\n\n\tvar emptySlice []interface{}\n\tvar emptyMap map[string]interface{}\n\tvar emptyNested *Nested\n\texpected := &map[string]interface{}{\n\t\t\"visible-string\":   \"\",\n\t\t\"omittable-string\": \"string\",\n\t\t\"visible-int\":      0,\n\t\t\"omittable-int\":    1,\n\t\t\"visible-float\":    0.0,\n\t\t\"omittable-float\":  1.0,\n\t\t\"visible-slice\":    emptySlice,\n\t\t\"omittable-slice\":  []interface{}{1},\n\t\t\"visible-map\":      emptyMap,\n\t\t\"omittable-map\":    map[string]interface{}{\"k\": \"v\"},\n\t\t\"visible-nested\":   emptyNested,\n\t\t\"omittable-nested\": &Nested{},\n\t}\n\n\tactual := &map[string]interface{}{}\n\tDecode(input, actual)\n\n\tif !reflect.DeepEqual(actual, expected) {\n\t\tt.Fatalf(\"Decode() expected: %#v, got: %#v\", expected, actual)\n\t}\n}\n\nfunc TestDecode_mapToStruct(t *testing.T) {\n\ttype Target struct {\n\t\tString    string\n\t\tStringPtr *string\n\t}\n\n\texpected := Target{\n\t\tString: \"hello\",\n\t}\n\n\tvar target Target\n\terr := Decode(map[string]interface{}{\n\t\t\"string\":    \"hello\",\n\t\t\"StringPtr\": \"goodbye\",\n\t}, &target)\n\tif err != nil {\n\t\tt.Fatalf(\"got error: %s\", err)\n\t}\n\n\t// Pointers fail reflect test so do those manually\n\tif target.StringPtr == nil || *target.StringPtr != \"goodbye\" {\n\t\tt.Fatalf(\"bad: %#v\", target)\n\t}\n\ttarget.StringPtr = nil\n\n\tif !reflect.DeepEqual(target, expected) {\n\t\tt.Fatalf(\"bad: %#v\", target)\n\t}\n}\n\nfunc TestDecoder_MatchName(t *testing.T) {\n\tt.Parallel()\n\n\ttype Target struct {\n\t\tFirstMatch  string `mapstructure:\"first_match\"`\n\t\tSecondMatch string\n\t\tNoMatch     string `mapstructure:\"no_match\"`\n\t}\n\n\tinput := map[string]interface{}{\n\t\t\"first_match\": \"foo\",\n\t\t\"SecondMatch\": \"bar\",\n\t\t\"NO_MATCH\":    \"baz\",\n\t}\n\n\texpected := Target{\n\t\tFirstMatch:  \"foo\",\n\t\tSecondMatch: \"bar\",\n\t}\n\n\tvar actual Target\n\tconfig := &DecoderConfig{\n\t\tResult: &actual,\n\t\tMatchName: func(mapKey, fieldName string) bool {\n\t\t\treturn mapKey == fieldName\n\t\t},\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Fatalf(\"Decode() expected: %#v, got: %#v\", expected, actual)\n\t}\n}\n\nfunc TestDecoder_IgnoreUntaggedFields(t *testing.T) {\n\ttype Input struct {\n\t\tUntaggedNumber int\n\t\tTaggedNumber   int `mapstructure:\"tagged_number\"`\n\t\tUntaggedString string\n\t\tTaggedString   string `mapstructure:\"tagged_string\"`\n\t}\n\tinput := &Input{\n\t\tUntaggedNumber: 31,\n\t\tTaggedNumber:   42,\n\t\tUntaggedString: \"hidden\",\n\t\tTaggedString:   \"visible\",\n\t}\n\n\tactual := make(map[string]interface{})\n\tconfig := &DecoderConfig{\n\t\tResult:               &actual,\n\t\tIgnoreUntaggedFields: true,\n\t}\n\n\tdecoder, err := NewDecoder(config)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\terr = decoder.Decode(input)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\texpected := map[string]interface{}{\n\t\t\"tagged_number\": 42,\n\t\t\"tagged_string\": \"visible\",\n\t}\n\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Fatalf(\"Decode() expected: %#v\\ngot: %#v\", expected, actual)\n\t}\n}\n\nfunc testSliceInput(t *testing.T, input map[string]interface{}, expected *Slice) {\n\tvar result Slice\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got error: %s\", err)\n\t}\n\n\tif result.Vfoo != expected.Vfoo {\n\t\tt.Errorf(\"Vfoo expected '%s', got '%s'\", expected.Vfoo, result.Vfoo)\n\t}\n\n\tif result.Vbar == nil {\n\t\tt.Fatalf(\"Vbar a slice, got '%#v'\", result.Vbar)\n\t}\n\n\tif len(result.Vbar) != len(expected.Vbar) {\n\t\tt.Errorf(\"Vbar length should be %d, got %d\", len(expected.Vbar), len(result.Vbar))\n\t}\n\n\tfor i, v := range result.Vbar {\n\t\tif v != expected.Vbar[i] {\n\t\t\tt.Errorf(\n\t\t\t\t\"Vbar[%d] should be '%#v', got '%#v'\",\n\t\t\t\ti, expected.Vbar[i], v)\n\t\t}\n\t}\n}\n\nfunc testArrayInput(t *testing.T, input map[string]interface{}, expected *Array) {\n\tvar result Array\n\terr := Decode(input, &result)\n\tif err != nil {\n\t\tt.Fatalf(\"got error: %s\", err)\n\t}\n\n\tif result.Vfoo != expected.Vfoo {\n\t\tt.Errorf(\"Vfoo expected '%s', got '%s'\", expected.Vfoo, result.Vfoo)\n\t}\n\n\tif result.Vbar == [2]string{} {\n\t\tt.Fatalf(\"Vbar a slice, got '%#v'\", result.Vbar)\n\t}\n\n\tif len(result.Vbar) != len(expected.Vbar) {\n\t\tt.Errorf(\"Vbar length should be %d, got %d\", len(expected.Vbar), len(result.Vbar))\n\t}\n\n\tfor i, v := range result.Vbar {\n\t\tif v != expected.Vbar[i] {\n\t\t\tt.Errorf(\n\t\t\t\t\"Vbar[%d] should be '%#v', got '%#v'\",\n\t\t\t\ti, expected.Vbar[i], v)\n\t\t}\n\t}\n}\n\nfunc stringPtr(v string) *string              { return &v }\nfunc intPtr(v int) *int                       { return &v }\nfunc uintPtr(v uint) *uint                    { return &v }\nfunc boolPtr(v bool) *bool                    { return &v }\nfunc floatPtr(v float64) *float64             { return &v }\nfunc interfacePtr(v interface{}) *interface{} { return &v }\n"
        }
      ]
    }
  ]
}