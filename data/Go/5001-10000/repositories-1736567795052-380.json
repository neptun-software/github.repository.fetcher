{
  "metadata": {
    "timestamp": 1736567795052,
    "page": 380,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "v2fly/domain-list-community",
      "stars": 5322,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.12890625,
          "content": ".idea\n.vscode\n\n/domain-list-community\n/domain-list-community.exe\n\n# Generated dat file.\ndlc.dat\n\n# Exported plaintext lists.\n/*.txt\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2018-2019 V2Ray\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.6328125,
          "content": "# Domain list community\n\nThis project manages a list of domains, to be used as geosites for routing purpose in Project V.\n\n## Purpose of this project\n\nThis project is not opinionated. In other words, it does NOT endorse, claim or imply that a domain should be blocked or proxied. It can be used to generate routing rules on demand.\n\n## Download links\n\n- **dlc.dat**：[https://github.com/v2fly/domain-list-community/releases/latest/download/dlc.dat](https://github.com/v2fly/domain-list-community/releases/latest/download/dlc.dat)\n- **dlc.dat.sha256sum**：[https://github.com/v2fly/domain-list-community/releases/latest/download/dlc.dat.sha256sum](https://github.com/v2fly/domain-list-community/releases/latest/download/dlc.dat.sha256sum)\n\n## Usage example\n\nEach file in the `data` directory can be used as a rule in this format: `geosite:filename`.\n\n```json\n\"routing\": {\n  \"domainStrategy\": \"IPIfNonMatch\",\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Reject\",\n      \"domain\": [\n        \"geosite:category-ads-all\",\n        \"geosite:category-porn\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Direct\",\n      \"domain\": [\n        \"domain:icloud.com\",\n        \"domain:icloud-content.com\",\n        \"domain:cdn-apple.com\",\n        \"geosite:cn\",\n        \"geosite:private\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-1\",\n      \"domain\": [\n        \"geosite:category-anticensorship\",\n        \"geosite:category-media\",\n        \"geosite:category-vpnservices\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-2\",\n      \"domain\": [\n        \"geosite:category-dev\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-3\",\n      \"domain\": [\n        \"geosite:geolocation-!cn\"\n      ]\n    }\n  ]\n}\n```\n\n## Generate `dlc.dat` manually\n\n- Install `golang` and `git`\n- Clone project code: `git clone https://github.com/v2fly/domain-list-community.git`\n- Navigate to project root directory: `cd domain-list-community`\n- Install project dependencies: `go mod download`\n- Generate `dlc.dat` (without `datapath` option means to use domain lists in `data` directory of current working directory):\n  - `go run ./`\n  - `go run ./ --datapath=/path/to/your/custom/data/directory`\n\nRun `go run ./ --help` for more usage information.\n\n## Structure of data\n\nAll data are under `data` directory. Each file in the directory represents a sub-list of domains, named by the file name. File content is in the following format.\n\n```\n# comments\ninclude:another-file\ndomain:google.com @attr1 @attr2\nkeyword:google\nregexp:www\\.google\\.com$\nfull:www.google.com\n```\n\n**Syntax:**\n\n> The following types of rules are **NOT** fully compatible with the ones that defined by user in V2Ray config file. Do **Not** copy and paste directly.\n\n* Comment begins with `#`. It may begin anywhere in the file. The content in the line after `#` is treated as comment and ignored in production.\n* Inclusion begins with `include:`, followed by the file name of an existing file in the same directory.\n* Subdomain begins with `domain:`, followed by a valid domain name. The prefix `domain:` may be omitted.\n* Keyword begins with `keyword:`, followed by a string.\n* Regular expression begins with `regexp:`, followed by a valid regular expression (per Golang's standard).\n* Full domain begins with `full:`, followed by a complete and valid domain name.\n* Domains (including `domain`, `keyword`, `regexp` and `full`) may have one or more attributes. Each attribute begins with `@` and followed by the name of the attribute.\n\n## How it works\n\nThe entire `data` directory will be built into an external `geosite` file for Project V. Each file in the directory represents a section in the generated file.\n\nTo generate a section:\n\n1. Remove all the comments in the file.\n2. Replace `include:` lines with the actual content of the file.\n3. Omit all empty lines.\n4. Generate each `domain:` line into a [sub-domain routing rule](https://github.com/v2fly/v2ray-core/blob/master/app/router/config.proto#L21).\n5. Generate each `keyword:` line into a [plain domain routing rule](https://github.com/v2fly/v2ray-core/blob/master/app/router/config.proto#L17).\n6. Generate each `regexp:` line into a [regex domain routing rule](https://github.com/v2fly/v2ray-core/blob/master/app/router/config.proto#L19).\n7. Generate each `full:` line into a [full domain routing rule](https://github.com/v2fly/v2ray-core/blob/master/app/router/config.proto#L23).\n\n## How to organize domains\n\n### File name\n\nTheoretically any string can be used as the name, as long as it is a valid file name. In practice, we prefer names for determinic group of domains, such as the owner (usually a company name) of the domains, e.g., \"google\", \"netflix\". Names with unclear scope are generally unrecommended, such as \"evil\", or \"local\".\n\n### Attributes\n\nAttribute is useful for sub-group of domains, especially for filtering purpose. For example, the list of `google` domains may contains its main domains, as well as domains that serve ads. The ads domains may be marked by attribute `@ads`, and can be used as `geosite:google@ads` in V2Ray routing.\n\n## Contribution guideline\n\n* Fork this repo, make modifications to your own repo, file a PR.\n* Please begin with small size PRs, say modification in a single file.\n* A PR must be reviewed and approved by another member.\n* A script will verify your pull request to test whether your PR is correct or not every time you update the PR. Only the PR which passes the test will be merged. Please go to the Action label to get detailed information if you didn't pass it. We also provide the file which has been generated to make you test.\n* After a few successful PRs, you may apply for manager access to this repository.\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.294921875,
          "content": "module github.com/v2fly/domain-list-community\n\ngo 1.22\n\ntoolchain go1.22.2\n\nrequire (\n\tgithub.com/v2fly/v2ray-core/v5 v5.16.0\n\tgoogle.golang.org/protobuf v1.34.0\n)\n\nrequire (\n\tgithub.com/adrg/xdg v0.4.0 // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgolang.org/x/sys v0.19.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.208984375,
          "content": "github.com/adrg/xdg v0.4.0 h1:RzRqFcjH4nE5C6oTAxhBtoE2IRyjBSa62SCbyPidvls=\ngithub.com/adrg/xdg v0.4.0/go.mod h1:N6ag73EX4wyxeaoeHctc1mas01KZgsj5tYiAIwqJE/E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/v2fly/v2ray-core/v5 v5.16.0 h1:GOwn0u2qzfBhBKk1mfgGaxYbfTp9J19JD7iENBsQRkM=\ngithub.com/v2fly/v2ray-core/v5 v5.16.0/go.mod h1:3pWIBTmNagMKpzd9/QicXq/7JZCQt716GsGZdBNmYkU=\ngolang.org/x/sys v0.0.0-20211025201205-69cdffdb9359/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=\ngolang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngoogle.golang.org/protobuf v1.34.0 h1:Qo/qEd2RZPCf2nKuorzksSknv0d3ERwp1vFG38gSmH4=\ngoogle.golang.org/protobuf v1.34.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 9.1875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\trouter \"github.com/v2fly/v2ray-core/v5/app/router/routercommon\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar (\n\tdataPath    = flag.String(\"datapath\", \"./data\", \"Path to your custom 'data' directory\")\n\toutputName  = flag.String(\"outputname\", \"dlc.dat\", \"Name of the generated dat file\")\n\toutputDir   = flag.String(\"outputdir\", \"./\", \"Directory to place all generated files\")\n\texportLists = flag.String(\"exportlists\", \"\", \"Lists to be flattened and exported in plaintext format, separated by ',' comma\")\n)\n\ntype Entry struct {\n\tType  string\n\tValue string\n\tAttrs []*router.Domain_Attribute\n}\n\ntype List struct {\n\tName  string\n\tEntry []Entry\n}\n\ntype ParsedList struct {\n\tName      string\n\tInclusion map[string]bool\n\tEntry     []Entry\n}\n\nfunc (l *ParsedList) toPlainText(listName string) error {\n\tvar entryBytes []byte\n\tfor _, entry := range l.Entry {\n\t\tvar attrString string\n\t\tif entry.Attrs != nil {\n\t\t\tfor _, attr := range entry.Attrs {\n\t\t\t\tattrString += \"@\" + attr.GetKey() + \",\"\n\t\t\t}\n\t\t\tattrString = strings.TrimRight(\":\"+attrString, \",\")\n\t\t}\n\t\t// Entry output format is: type:domain.tld:@attr1,@attr2\n\t\tentryBytes = append(entryBytes, []byte(entry.Type+\":\"+entry.Value+attrString+\"\\n\")...)\n\t}\n\tif err := os.WriteFile(filepath.Join(*outputDir, listName+\".txt\"), entryBytes, 0644); err != nil {\n\t\treturn fmt.Errorf(err.Error())\n\t}\n\treturn nil\n}\n\nfunc (l *ParsedList) toProto() (*router.GeoSite, error) {\n\tsite := &router.GeoSite{\n\t\tCountryCode: l.Name,\n\t}\n\tfor _, entry := range l.Entry {\n\t\tswitch entry.Type {\n\t\tcase \"domain\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_RootDomain,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"regexp\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Regex,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"keyword\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Plain,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"full\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Full,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unknown domain type: \" + entry.Type)\n\t\t}\n\t}\n\treturn site, nil\n}\n\nfunc exportPlainTextList(list []string, refName string, pl *ParsedList) {\n\tfor _, listName := range list {\n\t\tif strings.EqualFold(refName, listName) {\n\t\t\tif err := pl.toPlainText(strings.ToLower(refName)); err != nil {\n\t\t\t\tfmt.Println(\"Failed: \", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Printf(\"'%s' has been generated successfully.\\n\", listName)\n\t\t}\n\t}\n}\n\nfunc removeComment(line string) string {\n\tidx := strings.Index(line, \"#\")\n\tif idx == -1 {\n\t\treturn line\n\t}\n\treturn strings.TrimSpace(line[:idx])\n}\n\nfunc parseDomain(domain string, entry *Entry) error {\n\tkv := strings.Split(domain, \":\")\n\tif len(kv) == 1 {\n\t\tentry.Type = \"domain\"\n\t\tentry.Value = strings.ToLower(kv[0])\n\t\treturn nil\n\t}\n\n\tif len(kv) == 2 {\n\t\tentry.Type = strings.ToLower(kv[0])\n\t\tentry.Value = strings.ToLower(kv[1])\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"Invalid format: \" + domain)\n}\n\nfunc parseAttribute(attr string) (*router.Domain_Attribute, error) {\n\tvar attribute router.Domain_Attribute\n\tif len(attr) == 0 || attr[0] != '@' {\n\t\treturn &attribute, errors.New(\"invalid attribute: \" + attr)\n\t}\n\n\t// Trim attribute prefix `@` character\n\tattr = attr[1:]\n\tparts := strings.Split(attr, \"=\")\n\tif len(parts) == 1 {\n\t\tattribute.Key = strings.ToLower(parts[0])\n\t\tattribute.TypedValue = &router.Domain_Attribute_BoolValue{BoolValue: true}\n\t} else {\n\t\tattribute.Key = strings.ToLower(parts[0])\n\t\tintv, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn &attribute, errors.New(\"invalid attribute: \" + attr + \": \" + err.Error())\n\t\t}\n\t\tattribute.TypedValue = &router.Domain_Attribute_IntValue{IntValue: int64(intv)}\n\t}\n\treturn &attribute, nil\n}\n\nfunc parseEntry(line string) (Entry, error) {\n\tline = strings.TrimSpace(line)\n\tparts := strings.Split(line, \" \")\n\n\tvar entry Entry\n\tif len(parts) == 0 {\n\t\treturn entry, errors.New(\"empty entry\")\n\t}\n\n\tif err := parseDomain(parts[0], &entry); err != nil {\n\t\treturn entry, err\n\t}\n\n\tfor i := 1; i < len(parts); i++ {\n\t\tattr, err := parseAttribute(parts[i])\n\t\tif err != nil {\n\t\t\treturn entry, err\n\t\t}\n\t\tentry.Attrs = append(entry.Attrs, attr)\n\t}\n\n\treturn entry, nil\n}\n\nfunc Load(path string) (*List, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tlist := &List{\n\t\tName: strings.ToUpper(filepath.Base(path)),\n\t}\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tline = removeComment(line)\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tentry, err := parseEntry(line)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlist.Entry = append(list.Entry, entry)\n\t}\n\n\treturn list, nil\n}\n\nfunc isMatchAttr(Attrs []*router.Domain_Attribute, includeKey string) bool {\n\tisMatch := false\n\tmustMatch := true\n\tmatchName := includeKey\n\tif strings.HasPrefix(includeKey, \"!\") {\n\t\tisMatch = true\n\t\tmustMatch = false\n\t\tmatchName = strings.TrimLeft(includeKey, \"!\")\n\t}\n\n\tfor _, Attr := range Attrs {\n\t\tattrName := Attr.Key\n\t\tif mustMatch {\n\t\t\tif matchName == attrName {\n\t\t\t\tisMatch = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tif matchName == attrName {\n\t\t\t\tisMatch = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn isMatch\n}\n\nfunc createIncludeAttrEntrys(list *List, matchAttr *router.Domain_Attribute) []Entry {\n\tnewEntryList := make([]Entry, 0, len(list.Entry))\n\tmatchName := matchAttr.Key\n\tfor _, entry := range list.Entry {\n\t\tmatched := isMatchAttr(entry.Attrs, matchName)\n\t\tif matched {\n\t\t\tnewEntryList = append(newEntryList, entry)\n\t\t}\n\t}\n\treturn newEntryList\n}\n\nfunc ParseList(list *List, ref map[string]*List) (*ParsedList, error) {\n\tpl := &ParsedList{\n\t\tName:      list.Name,\n\t\tInclusion: make(map[string]bool),\n\t}\n\tentryList := list.Entry\n\tfor {\n\t\tnewEntryList := make([]Entry, 0, len(entryList))\n\t\thasInclude := false\n\t\tfor _, entry := range entryList {\n\t\t\tif entry.Type == \"include\" {\n\t\t\t\trefName := strings.ToUpper(entry.Value)\n\t\t\t\tif entry.Attrs != nil {\n\t\t\t\t\tfor _, attr := range entry.Attrs {\n\t\t\t\t\t\tInclusionName := strings.ToUpper(refName + \"@\" + attr.Key)\n\t\t\t\t\t\tif pl.Inclusion[InclusionName] {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpl.Inclusion[InclusionName] = true\n\n\t\t\t\t\t\trefList := ref[refName]\n\t\t\t\t\t\tif refList == nil {\n\t\t\t\t\t\t\treturn nil, errors.New(entry.Value + \" not found.\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattrEntrys := createIncludeAttrEntrys(refList, attr)\n\t\t\t\t\t\tif len(attrEntrys) != 0 {\n\t\t\t\t\t\t\tnewEntryList = append(newEntryList, attrEntrys...)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tInclusionName := refName\n\t\t\t\t\tif pl.Inclusion[InclusionName] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tpl.Inclusion[InclusionName] = true\n\t\t\t\t\trefList := ref[refName]\n\t\t\t\t\tif refList == nil {\n\t\t\t\t\t\treturn nil, errors.New(entry.Value + \" not found.\")\n\t\t\t\t\t}\n\t\t\t\t\tnewEntryList = append(newEntryList, refList.Entry...)\n\t\t\t\t}\n\t\t\t\thasInclude = true\n\t\t\t} else {\n\t\t\t\tnewEntryList = append(newEntryList, entry)\n\t\t\t}\n\t\t}\n\t\tentryList = newEntryList\n\t\tif !hasInclude {\n\t\t\tbreak\n\t\t}\n\t}\n\tpl.Entry = entryList\n\n\treturn pl, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tdir := *dataPath\n\tfmt.Println(\"Use domain lists in\", dir)\n\n\tref := make(map[string]*List)\n\terr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tlist, err := Load(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tref[list.Name] = list\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tfmt.Println(\"Failed: \", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Create output directory if not exist\n\tif _, err := os.Stat(*outputDir); os.IsNotExist(err) {\n\t\tif mkErr := os.MkdirAll(*outputDir, 0755); mkErr != nil {\n\t\t\tfmt.Println(\"Failed: \", mkErr)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tprotoList := new(router.GeoSiteList)\n\tvar existList []string\n\tfor refName, list := range ref {\n\t\tpl, err := ParseList(list, ref)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed: \", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tsite, err := pl.toProto()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed: \", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tprotoList.Entry = append(protoList.Entry, site)\n\n\t\t// Flatten and export plaintext list\n\t\tif *exportLists != \"\" {\n\t\t\tif existList != nil {\n\t\t\t\texportPlainTextList(existList, refName, pl)\n\t\t\t} else {\n\t\t\t\texportedListSlice := strings.Split(*exportLists, \",\")\n\t\t\t\tfor _, exportedListName := range exportedListSlice {\n\t\t\t\t\tfileName := filepath.Join(dir, exportedListName)\n\t\t\t\t\t_, err := os.Stat(fileName)\n\t\t\t\t\tif err == nil || os.IsExist(err) {\n\t\t\t\t\t\texistList = append(existList, exportedListName)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt.Printf(\"'%s' list does not exist in '%s' directory.\\n\", exportedListName, dir)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif existList != nil {\n\t\t\t\t\texportPlainTextList(existList, refName, pl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort protoList so the marshaled list is reproducible\n\tsort.SliceStable(protoList.Entry, func(i, j int) bool {\n\t\treturn protoList.Entry[i].CountryCode < protoList.Entry[j].CountryCode\n\t})\n\n\tprotoBytes, err := proto.Marshal(protoList)\n\tif err != nil {\n\t\tfmt.Println(\"Failed:\", err)\n\t\tos.Exit(1)\n\t}\n\tif err := os.WriteFile(filepath.Join(*outputDir, *outputName), protoBytes, 0644); err != nil {\n\t\tfmt.Println(\"Failed: \", err)\n\t\tos.Exit(1)\n\t} else {\n\t\tfmt.Println(*outputName, \"has been generated successfully.\")\n\t}\n}\n"
        }
      ]
    }
  ]
}