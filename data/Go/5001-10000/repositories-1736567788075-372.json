{
  "metadata": {
    "timestamp": 1736567788075,
    "page": 372,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hashicorp/go-plugin",
      "stars": 5356,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": ".DS_Store\n.idea\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.677734375,
          "content": "## v1.6.2\n\nENHANCEMENTS:\n\n* Added support for gRPC dial options to the `Dial` API [[GH-257](https://github.com/hashicorp/go-plugin/pull/257)]\n\nBUGS:\n\n* Fixed a bug where reattaching to a plugin that exits could kill an unrelated process [[GH-320](https://github.com/hashicorp/go-plugin/pull/320)]\n\n## v1.6.1\n\nBUGS:\n\n* Suppress spurious `os.ErrClosed` on plugin shutdown [[GH-299](https://github.com/hashicorp/go-plugin/pull/299)]\n\nENHANCEMENTS:\n\n* deps: bump google.golang.org/grpc to v1.58.3 [[GH-296](https://github.com/hashicorp/go-plugin/pull/296)]\n\n## v1.6.0\n\nCHANGES:\n\n* plugin: Plugins written in other languages can optionally start to advertise whether they support gRPC broker multiplexing.\n  If the environment variable `PLUGIN_MULTIPLEX_GRPC` is set, it is safe to include a seventh field containing a boolean\n  value in the `|`-separated protocol negotiation line.\n\nENHANCEMENTS:\n\n* Support muxing gRPC broker connections over a single listener [[GH-288](https://github.com/hashicorp/go-plugin/pull/288)]\n* client: Configurable buffer size for reading plugin log lines [[GH-265](https://github.com/hashicorp/go-plugin/pull/265)]\n* Use `buf` for proto generation [[GH-286](https://github.com/hashicorp/go-plugin/pull/286)]\n* deps: bump golang.org/x/net to v0.17.0 [[GH-285](https://github.com/hashicorp/go-plugin/pull/285)]\n* deps: bump golang.org/x/sys to v0.13.0 [[GH-285](https://github.com/hashicorp/go-plugin/pull/285)]\n* deps: bump golang.org/x/text to v0.13.0 [[GH-285](https://github.com/hashicorp/go-plugin/pull/285)]\n\n## v1.5.2\n\nENHANCEMENTS:\n\nclient: New `UnixSocketConfig.TempDir` option allows setting the directory to use when creating plugin-specific Unix socket directories [[GH-282](https://github.com/hashicorp/go-plugin/pull/282)]\n\n## v1.5.1\n\nBUGS:\n\n* server: `PLUGIN_UNIX_SOCKET_DIR` is consistently used for gRPC broker sockets as well as the initial socket [[GH-277](https://github.com/hashicorp/go-plugin/pull/277)]\n\nENHANCEMENTS:\n\n* client: New `UnixSocketConfig` option in `ClientConfig` to support making the client's Unix sockets group-writable [[GH-277](https://github.com/hashicorp/go-plugin/pull/277)]\n\n## v1.5.0\n\nENHANCEMENTS:\n\n* client: New `runner.Runner` interface to support clients providing custom plugin command runner implementations [[GH-270](https://github.com/hashicorp/go-plugin/pull/270)]\n    * Accessible via new `ClientConfig` field `RunnerFunc`, which is mutually exclusive with `Cmd` and `Reattach`\n    * Reattaching support via `ReattachConfig` field `ReattachFunc`\n* client: New `ClientConfig` field `SkipHostEnv` allows omitting the client process' own environment variables from the plugin command's environment [[GH-270](https://github.com/hashicorp/go-plugin/pull/270)]\n* client: Add `ID()` method to `Client` for retrieving the pid or other unique ID of a running plugin [[GH-272](https://github.com/hashicorp/go-plugin/pull/272)]\n* server: Support setting the directory to create Unix sockets in with the env var `PLUGIN_UNIX_SOCKET_DIR` [[GH-270](https://github.com/hashicorp/go-plugin/pull/270)]\n* server: Support setting group write permission and a custom group name or gid owner with the env var `PLUGIN_UNIX_SOCKET_GROUP` [[GH-270](https://github.com/hashicorp/go-plugin/pull/270)]\n\n## v1.4.11-rc1\n\nENHANCEMENTS:\n\n* deps: bump protoreflect to v1.15.1 [[GH-264](https://github.com/hashicorp/go-plugin/pull/264)]\n\n## v1.4.10\n\nBUG FIXES:\n\n* additional notes: ensure to close files [[GH-241](https://github.com/hashicorp/go-plugin/pull/241)]\n\nENHANCEMENTS:\n\n* deps: Remove direct dependency on golang.org/x/net [[GH-240](https://github.com/hashicorp/go-plugin/pull/240)]\n\n## v1.4.9\n\nENHANCEMENTS:\n\n* client: Remove log warning introduced in 1.4.5 when SecureConfig is nil. [[GH-238](https://github.com/hashicorp/go-plugin/pull/238)]\n\n## v1.4.8\n\nBUG FIXES:\n\n* Fix windows build: [[GH-227](https://github.com/hashicorp/go-plugin/pull/227)]\n\n## v1.4.7\n\nENHANCEMENTS:\n\n* More detailed error message on plugin start failure: [[GH-223](https://github.com/hashicorp/go-plugin/pull/223)]\n\n## v1.4.6\n\nBUG FIXES:\n\n* server: Prevent gRPC broker goroutine leak when using `GRPCServer` type `GracefulStop()` or `Stop()` methods [[GH-220](https://github.com/hashicorp/go-plugin/pull/220)]\n\n## v1.4.5\n\nENHANCEMENTS:\n\n* client: log warning when SecureConfig is nil [[GH-207](https://github.com/hashicorp/go-plugin/pull/207)]\n\n\n## v1.4.4\n\nENHANCEMENTS:\n\n* client: increase level of plugin exit logs [[GH-195](https://github.com/hashicorp/go-plugin/pull/195)]\n\nBUG FIXES:\n\n* Bidirectional communication: fix bidirectional communication when AutoMTLS is enabled [[GH-193](https://github.com/hashicorp/go-plugin/pull/193)]\n* RPC: Trim a spurious log message for plugins using RPC [[GH-186](https://github.com/hashicorp/go-plugin/pull/186)]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 15.63671875,
          "content": "Copyright (c) 2016 HashiCorp, Inc.\n\nMozilla Public License, version 2.0\n\n1. Definitions\n\n1.1. “Contributor”\n\n     means each individual or legal entity that creates, contributes to the\n     creation of, or owns Covered Software.\n\n1.2. “Contributor Version”\n\n     means the combination of the Contributions of others (if any) used by a\n     Contributor and that particular Contributor’s Contribution.\n\n1.3. “Contribution”\n\n     means Covered Software of a particular Contributor.\n\n1.4. “Covered Software”\n\n     means Source Code Form to which the initial Contributor has attached the\n     notice in Exhibit A, the Executable Form of such Source Code Form, and\n     Modifications of such Source Code Form, in each case including portions\n     thereof.\n\n1.5. “Incompatible With Secondary Licenses”\n     means\n\n     a. that the initial Contributor has attached the notice described in\n        Exhibit B to the Covered Software; or\n\n     b. that the Covered Software was made available under the terms of version\n        1.1 or earlier of the License, but not also under the terms of a\n        Secondary License.\n\n1.6. “Executable Form”\n\n     means any form of the work other than Source Code Form.\n\n1.7. “Larger Work”\n\n     means a work that combines Covered Software with other material, in a separate\n     file or files, that is not Covered Software.\n\n1.8. “License”\n\n     means this document.\n\n1.9. “Licensable”\n\n     means having the right to grant, to the maximum extent possible, whether at the\n     time of the initial grant or subsequently, any and all of the rights conveyed by\n     this License.\n\n1.10. “Modifications”\n\n     means any of the following:\n\n     a. any file in Source Code Form that results from an addition to, deletion\n        from, or modification of the contents of Covered Software; or\n\n     b. any new file in Source Code Form that contains any Covered Software.\n\n1.11. “Patent Claims” of a Contributor\n\n      means any patent claim(s), including without limitation, method, process,\n      and apparatus claims, in any patent Licensable by such Contributor that\n      would be infringed, but for the grant of the License, by the making,\n      using, selling, offering for sale, having made, import, or transfer of\n      either its Contributions or its Contributor Version.\n\n1.12. “Secondary License”\n\n      means either the GNU General Public License, Version 2.0, the GNU Lesser\n      General Public License, Version 2.1, the GNU Affero General Public\n      License, Version 3.0, or any later versions of those licenses.\n\n1.13. “Source Code Form”\n\n      means the form of the work preferred for making modifications.\n\n1.14. “You” (or “Your”)\n\n      means an individual or a legal entity exercising rights under this\n      License. For legal entities, “You” includes any entity that controls, is\n      controlled by, or is under common control with You. For purposes of this\n      definition, “control” means (a) the power, direct or indirect, to cause\n      the direction or management of such entity, whether by contract or\n      otherwise, or (b) ownership of more than fifty percent (50%) of the\n      outstanding shares or beneficial ownership of such entity.\n\n\n2. License Grants and Conditions\n\n2.1. Grants\n\n     Each Contributor hereby grants You a world-wide, royalty-free,\n     non-exclusive license:\n\n     a. under intellectual property rights (other than patent or trademark)\n        Licensable by such Contributor to use, reproduce, make available,\n        modify, display, perform, distribute, and otherwise exploit its\n        Contributions, either on an unmodified basis, with Modifications, or as\n        part of a Larger Work; and\n\n     b. under Patent Claims of such Contributor to make, use, sell, offer for\n        sale, have made, import, and otherwise transfer either its Contributions\n        or its Contributor Version.\n\n2.2. Effective Date\n\n     The licenses granted in Section 2.1 with respect to any Contribution become\n     effective for each Contribution on the date the Contributor first distributes\n     such Contribution.\n\n2.3. Limitations on Grant Scope\n\n     The licenses granted in this Section 2 are the only rights granted under this\n     License. No additional rights or licenses will be implied from the distribution\n     or licensing of Covered Software under this License. Notwithstanding Section\n     2.1(b) above, no patent license is granted by a Contributor:\n\n     a. for any code that a Contributor has removed from Covered Software; or\n\n     b. for infringements caused by: (i) Your and any other third party’s\n        modifications of Covered Software, or (ii) the combination of its\n        Contributions with other software (except as part of its Contributor\n        Version); or\n\n     c. under Patent Claims infringed by Covered Software in the absence of its\n        Contributions.\n\n     This License does not grant any rights in the trademarks, service marks, or\n     logos of any Contributor (except as may be necessary to comply with the\n     notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\n     No Contributor makes additional grants as a result of Your choice to\n     distribute the Covered Software under a subsequent version of this License\n     (see Section 10.2) or under the terms of a Secondary License (if permitted\n     under the terms of Section 3.3).\n\n2.5. Representation\n\n     Each Contributor represents that the Contributor believes its Contributions\n     are its original creation(s) or it has sufficient rights to grant the\n     rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\n     This License is not intended to limit any rights You have under applicable\n     copyright doctrines of fair use, fair dealing, or other equivalents.\n\n2.7. Conditions\n\n     Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in\n     Section 2.1.\n\n\n3. Responsibilities\n\n3.1. Distribution of Source Form\n\n     All distribution of Covered Software in Source Code Form, including any\n     Modifications that You create or to which You contribute, must be under the\n     terms of this License. You must inform recipients that the Source Code Form\n     of the Covered Software is governed by the terms of this License, and how\n     they can obtain a copy of this License. You may not attempt to alter or\n     restrict the recipients’ rights in the Source Code Form.\n\n3.2. Distribution of Executable Form\n\n     If You distribute Covered Software in Executable Form then:\n\n     a. such Covered Software must also be made available in Source Code Form,\n        as described in Section 3.1, and You must inform recipients of the\n        Executable Form how they can obtain a copy of such Source Code Form by\n        reasonable means in a timely manner, at a charge no more than the cost\n        of distribution to the recipient; and\n\n     b. You may distribute such Executable Form under the terms of this License,\n        or sublicense it under different terms, provided that the license for\n        the Executable Form does not attempt to limit or alter the recipients’\n        rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\n     You may create and distribute a Larger Work under terms of Your choice,\n     provided that You also comply with the requirements of this License for the\n     Covered Software. If the Larger Work is a combination of Covered Software\n     with a work governed by one or more Secondary Licenses, and the Covered\n     Software is not Incompatible With Secondary Licenses, this License permits\n     You to additionally distribute such Covered Software under the terms of\n     such Secondary License(s), so that the recipient of the Larger Work may, at\n     their option, further distribute the Covered Software under the terms of\n     either this License or such Secondary License(s).\n\n3.4. Notices\n\n     You may not remove or alter the substance of any license notices (including\n     copyright notices, patent notices, disclaimers of warranty, or limitations\n     of liability) contained within the Source Code Form of the Covered\n     Software, except that You may alter any license notices to the extent\n     required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\n     You may choose to offer, and to charge a fee for, warranty, support,\n     indemnity or liability obligations to one or more recipients of Covered\n     Software. However, You may do so only on Your own behalf, and not on behalf\n     of any Contributor. You must make it absolutely clear that any such\n     warranty, support, indemnity, or liability obligation is offered by You\n     alone, and You hereby agree to indemnify every Contributor for any\n     liability incurred by such Contributor as a result of warranty, support,\n     indemnity or liability terms You offer. You may include additional\n     disclaimers of warranty and limitations of liability specific to any\n     jurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n\n   If it is impossible for You to comply with any of the terms of this License\n   with respect to some or all of the Covered Software due to statute, judicial\n   order, or regulation then You must: (a) comply with the terms of this License\n   to the maximum extent possible; and (b) describe the limitations and the code\n   they affect. Such description must be placed in a text file included with all\n   distributions of the Covered Software under this License. Except to the\n   extent prohibited by statute or regulation, such description must be\n   sufficiently detailed for a recipient of ordinary skill to be able to\n   understand it.\n\n5. Termination\n\n5.1. The rights granted under this License will terminate automatically if You\n     fail to comply with any of its terms. However, if You become compliant,\n     then the rights granted under this License from a particular Contributor\n     are reinstated (a) provisionally, unless and until such Contributor\n     explicitly and finally terminates Your grants, and (b) on an ongoing basis,\n     if such Contributor fails to notify You of the non-compliance by some\n     reasonable means prior to 60 days after You have come back into compliance.\n     Moreover, Your grants from a particular Contributor are reinstated on an\n     ongoing basis if such Contributor notifies You of the non-compliance by\n     some reasonable means, this is the first time You have received notice of\n     non-compliance with this License from such Contributor, and You become\n     compliant prior to 30 days after Your receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\n     infringement claim (excluding declaratory judgment actions, counter-claims,\n     and cross-claims) alleging that a Contributor Version directly or\n     indirectly infringes any patent, then the rights granted to You by any and\n     all Contributors for the Covered Software under Section 2.1 of this License\n     shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user\n     license agreements (excluding distributors and resellers) which have been\n     validly granted by You or Your distributors under this License prior to\n     termination shall survive termination.\n\n6. Disclaimer of Warranty\n\n   Covered Software is provided under this License on an “as is” basis, without\n   warranty of any kind, either expressed, implied, or statutory, including,\n   without limitation, warranties that the Covered Software is free of defects,\n   merchantable, fit for a particular purpose or non-infringing. The entire\n   risk as to the quality and performance of the Covered Software is with You.\n   Should any Covered Software prove defective in any respect, You (not any\n   Contributor) assume the cost of any necessary servicing, repair, or\n   correction. This disclaimer of warranty constitutes an essential part of this\n   License. No use of  any Covered Software is authorized under this License\n   except under this disclaimer.\n\n7. Limitation of Liability\n\n   Under no circumstances and under no legal theory, whether tort (including\n   negligence), contract, or otherwise, shall any Contributor, or anyone who\n   distributes Covered Software as permitted above, be liable to You for any\n   direct, indirect, special, incidental, or consequential damages of any\n   character including, without limitation, damages for lost profits, loss of\n   goodwill, work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses, even if such party shall have been\n   informed of the possibility of such damages. This limitation of liability\n   shall not apply to liability for death or personal injury resulting from such\n   party’s negligence to the extent applicable law prohibits such limitation.\n   Some jurisdictions do not allow the exclusion or limitation of incidental or\n   consequential damages, so this exclusion and limitation may not apply to You.\n\n8. Litigation\n\n   Any litigation relating to this License may be brought only in the courts of\n   a jurisdiction where the defendant maintains its principal place of business\n   and such litigation shall be governed by laws of that jurisdiction, without\n   reference to its conflict-of-law provisions. Nothing in this Section shall\n   prevent a party’s ability to bring cross-claims or counter-claims.\n\n9. Miscellaneous\n\n   This License represents the complete agreement concerning the subject matter\n   hereof. If any provision of this License is held to be unenforceable, such\n   provision shall be reformed only to the extent necessary to make it\n   enforceable. Any law or regulation which provides that the language of a\n   contract shall be construed against the drafter shall not be used to construe\n   this License against a Contributor.\n\n\n10. Versions of the License\n\n10.1. New Versions\n\n      Mozilla Foundation is the license steward. Except as provided in Section\n      10.3, no one other than the license steward has the right to modify or\n      publish new versions of this License. Each version will be given a\n      distinguishing version number.\n\n10.2. Effect of New Versions\n\n      You may distribute the Covered Software under the terms of the version of\n      the License under which You originally received the Covered Software, or\n      under the terms of any subsequent version published by the license\n      steward.\n\n10.3. Modified Versions\n\n      If you create software not governed by this License, and you want to\n      create a new license for such software, you may create and use a modified\n      version of this License if you rename the license and remove any\n      references to the name of the license steward (except to note that such\n      modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses\n      If You choose to distribute Source Code Form that is Incompatible With\n      Secondary Licenses under the terms of this version of the License, the\n      notice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n\n      This Source Code Form is subject to the\n      terms of the Mozilla Public License, v.\n      2.0. If a copy of the MPL was not\n      distributed with this file, You can\n      obtain one at\n      http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular file, then\nYou may include the notice in a location (such as a LICENSE file in a relevant\ndirectory) where a recipient would be likely to look for such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - “Incompatible With Secondary Licenses” Notice\n\n      This Source Code Form is “Incompatible\n      With Secondary Licenses”, as defined by\n      the Mozilla Public License, v. 2.0.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.6669921875,
          "content": "# Go Plugin System over RPC\n\n`go-plugin` is a Go (golang) plugin system over RPC. It is the plugin system\nthat has been in use by HashiCorp tooling for over 4 years. While initially\ncreated for [Packer](https://www.packer.io), it is additionally in use by\n[Terraform](https://www.terraform.io), [Nomad](https://www.nomadproject.io),\n[Vault](https://www.vaultproject.io),\n[Boundary](https://www.boundaryproject.io),\nand [Waypoint](https://www.waypointproject.io).\n\nWhile the plugin system is over RPC, it is currently only designed to work\nover a local [reliable] network. Plugins over a real network are not supported\nand will lead to unexpected behavior.\n\nThis plugin system has been used on millions of machines across many different\nprojects and has proven to be battle hardened and ready for production use.\n\n## Features\n\nThe HashiCorp plugin system supports a number of features:\n\n**Plugins are Go interface implementations.** This makes writing and consuming\nplugins feel very natural. To a plugin author: you just implement an\ninterface as if it were going to run in the same process. For a plugin user:\nyou just use and call functions on an interface as if it were in the same\nprocess. This plugin system handles the communication in between.\n\n**Cross-language support.** Plugins can be written (and consumed) by\nalmost every major language. This library supports serving plugins via\n[gRPC](http://www.grpc.io). gRPC-based plugins enable plugins to be written\nin any language.\n\n**Complex arguments and return values are supported.** This library\nprovides APIs for handling complex arguments and return values such\nas interfaces, `io.Reader/Writer`, etc. We do this by giving you a library\n(`MuxBroker`) for creating new connections between the client/server to\nserve additional interfaces or transfer raw data.\n\n**Bidirectional communication.** Because the plugin system supports\ncomplex arguments, the host process can send it interface implementations\nand the plugin can call back into the host process.\n\n**Built-in Logging.** Any plugins that use the `log` standard library\nwill have log data automatically sent to the host process. The host\nprocess will mirror this output prefixed with the path to the plugin\nbinary. This makes debugging with plugins simple. If the host system\nuses [hclog](https://github.com/hashicorp/go-hclog) then the log data\nwill be structured. If the plugin also uses hclog, logs from the plugin\nwill be sent to the host hclog and be structured.\n\n**Protocol Versioning.** A very basic \"protocol version\" is supported that\ncan be incremented to invalidate any previous plugins. This is useful when\ninterface signatures are changing, protocol level changes are necessary,\netc. When a protocol version is incompatible, a human friendly error\nmessage is shown to the end user.\n\n**Stdout/Stderr Syncing.** While plugins are subprocesses, they can continue\nto use stdout/stderr as usual and the output will get mirrored back to\nthe host process. The host process can control what `io.Writer` these\nstreams go to to prevent this from happening.\n\n**TTY Preservation.** Plugin subprocesses are connected to the identical\nstdin file descriptor as the host process, allowing software that requires\na TTY to work. For example, a plugin can execute `ssh` and even though there\nare multiple subprocesses and RPC happening, it will look and act perfectly\nto the end user.\n\n**Host upgrade while a plugin is running.** Plugins can be \"reattached\"\nso that the host process can be upgraded while the plugin is still running.\nThis requires the host/plugin to know this is possible and daemonize\nproperly. `NewClient` takes a `ReattachConfig` to determine if and how to\nreattach.\n\n**Cryptographically Secure Plugins.** Plugins can be verified with an expected\nchecksum and RPC communications can be configured to use TLS. The host process\nmust be properly secured to protect this configuration.\n\n## Architecture\n\nThe HashiCorp plugin system works by launching subprocesses and communicating\nover RPC (using standard `net/rpc` or [gRPC](http://www.grpc.io)). A single\nconnection is made between any plugin and the host process. For net/rpc-based\nplugins, we use a [connection multiplexing](https://github.com/hashicorp/yamux)\nlibrary to multiplex any other connections on top. For gRPC-based plugins,\nthe HTTP2 protocol handles multiplexing.\n\nThis architecture has a number of benefits:\n\n  * Plugins can't crash your host process: A panic in a plugin doesn't\n    panic the plugin user.\n\n  * Plugins are very easy to write: just write a Go application and `go build`.\n    Or use any other language to write a gRPC server with a tiny amount of\n    boilerplate to support go-plugin.\n\n  * Plugins are very easy to install: just put the binary in a location where\n    the host will find it (depends on the host but this library also provides\n    helpers), and the plugin host handles the rest.\n\n  * Plugins can be relatively secure: The plugin only has access to the\n    interfaces and args given to it, not to the entire memory space of the\n    process. Additionally, go-plugin can communicate with the plugin over\n    TLS.\n\n## Usage\n\nTo use the plugin system, you must take the following steps. These are\nhigh-level steps that must be done. Examples are available in the\n`examples/` directory.\n\n  1. Choose the interface(s) you want to expose for plugins.\n\n  2. For each interface, implement an implementation of that interface\n     that communicates over a `net/rpc` connection or over a\n     [gRPC](http://www.grpc.io) connection or both. You'll have to implement\n     both a client and server implementation.\n\n  3. Create a `Plugin` implementation that knows how to create the RPC\n     client/server for a given plugin type.\n\n  4. Plugin authors call `plugin.Serve` to serve a plugin from the\n     `main` function.\n\n  5. Plugin users use `plugin.Client` to launch a subprocess and request\n     an interface implementation over RPC.\n\nThat's it! In practice, step 2 is the most tedious and time consuming step.\nEven so, it isn't very difficult and you can see examples in the `examples/`\ndirectory as well as throughout our various open source projects.\n\nFor complete API documentation, see [GoDoc](https://godoc.org/github.com/hashicorp/go-plugin).\n\n## Roadmap\n\nOur plugin system is constantly evolving. As we use the plugin system for\nnew projects or for new features in existing projects, we constantly find\nimprovements we can make.\n\nAt this point in time, the roadmap for the plugin system is:\n\n**Semantic Versioning.** Plugins will be able to implement a semantic version.\nThis plugin system will give host processes a system for constraining\nversions. This is in addition to the protocol versioning already present\nwhich is more for larger underlying changes.\n\n## What About Shared Libraries?\n\nWhen we started using plugins (late 2012, early 2013), plugins over RPC\nwere the only option since Go didn't support dynamic library loading. Today,\nGo supports the [plugin](https://golang.org/pkg/plugin/) standard library with\na number of  limitations. Since 2012, our plugin system has stabilized \nfrom tens of millions of users using it, and has many benefits we've come to \nvalue greatly.\n\nFor example, we use this plugin system in\n[Vault](https://www.vaultproject.io) where dynamic library loading is\nnot acceptable for security reasons. That is an extreme\nexample, but we believe our library system has more upsides than downsides\nover dynamic library loading and since we've had it built and tested for years,\nwe'll continue to use it.\n\nShared libraries have one major advantage over our system which is much\nhigher performance. In real world scenarios across our various tools,\nwe've never required any more performance out of our plugin system and it\nhas seen very high throughput, so this isn't a concern for us at the moment.\n"
        },
        {
          "name": "buf.gen.yaml",
          "type": "blob",
          "size": 0.3037109375,
          "content": "# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: MPL-2.0\n\nversion: v1\nplugins:\n  - plugin: buf.build/protocolbuffers/go\n    out: .\n    opt:\n      - paths=source_relative\n  - plugin: buf.build/grpc/go:v1.3.0\n    out: .\n    opt:\n      - paths=source_relative\n      - require_unimplemented_servers=false\n"
        },
        {
          "name": "buf.yaml",
          "type": "blob",
          "size": 0.111328125,
          "content": "# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: MPL-2.0\n\nversion: v1\nbuild:\n  excludes:\n    - examples/"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 36.44921875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/cmdrunner\"\n\t\"github.com/hashicorp/go-plugin/internal/grpcmux\"\n\t\"github.com/hashicorp/go-plugin/runner\"\n\t\"google.golang.org/grpc\"\n)\n\n// If this is 1, then we've called CleanupClients. This can be used\n// by plugin RPC implementations to change error behavior since you\n// can expected network connection errors at this point. This should be\n// read by using sync/atomic.\nvar Killed uint32 = 0\n\n// This is a slice of the \"managed\" clients which are cleaned up when\n// calling Cleanup\nvar managedClients = make([]*Client, 0, 5)\nvar managedClientsLock sync.Mutex\n\n// Error types\nvar (\n\t// ErrProcessNotFound is returned when a client is instantiated to\n\t// reattach to an existing process and it isn't found.\n\tErrProcessNotFound = cmdrunner.ErrProcessNotFound\n\n\t// ErrChecksumsDoNotMatch is returned when binary's checksum doesn't match\n\t// the one provided in the SecureConfig.\n\tErrChecksumsDoNotMatch = errors.New(\"checksums did not match\")\n\n\t// ErrSecureNoChecksum is returned when an empty checksum is provided to the\n\t// SecureConfig.\n\tErrSecureConfigNoChecksum = errors.New(\"no checksum provided\")\n\n\t// ErrSecureNoHash is returned when a nil Hash object is provided to the\n\t// SecureConfig.\n\tErrSecureConfigNoHash = errors.New(\"no hash implementation provided\")\n\n\t// ErrSecureConfigAndReattach is returned when both Reattach and\n\t// SecureConfig are set.\n\tErrSecureConfigAndReattach = errors.New(\"only one of Reattach or SecureConfig can be set\")\n\n\t// ErrGRPCBrokerMuxNotSupported is returned when the client requests\n\t// multiplexing over the gRPC broker, but the plugin does not support the\n\t// feature. In most cases, this should be resolvable by updating and\n\t// rebuilding the plugin, or restarting the plugin with\n\t// ClientConfig.GRPCBrokerMultiplex set to false.\n\tErrGRPCBrokerMuxNotSupported = errors.New(\"client requested gRPC broker multiplexing but plugin does not support the feature\")\n)\n\n// defaultPluginLogBufferSize is the default size of the buffer used to read from stderr for plugin log lines.\nconst defaultPluginLogBufferSize = 64 * 1024\n\n// Client handles the lifecycle of a plugin application. It launches\n// plugins, connects to them, dispenses interface implementations, and handles\n// killing the process.\n//\n// Plugin hosts should use one Client for each plugin executable. To\n// dispense a plugin type, use the `Client.Client` function, and then\n// call `Dispense`. This awkward API is mostly historical but is used to split\n// the client that deals with subprocess management and the client that\n// does RPC management.\n//\n// See NewClient and ClientConfig for using a Client.\ntype Client struct {\n\tconfig            *ClientConfig\n\texited            bool\n\tl                 sync.Mutex\n\taddress           net.Addr\n\trunner            runner.AttachedRunner\n\tclient            ClientProtocol\n\tprotocol          Protocol\n\tlogger            hclog.Logger\n\tdoneCtx           context.Context\n\tctxCancel         context.CancelFunc\n\tnegotiatedVersion int\n\n\t// clientWaitGroup is used to manage the lifecycle of the plugin management\n\t// goroutines.\n\tclientWaitGroup sync.WaitGroup\n\n\t// pipesWaitGroup is used to prevent the command's Wait() function from\n\t// being called before we've finished reading from the stdout and stderr pipe.\n\tpipesWaitGroup sync.WaitGroup\n\n\t// processKilled is used for testing only, to flag when the process was\n\t// forcefully killed.\n\tprocessKilled bool\n\n\tunixSocketCfg UnixSocketConfig\n\n\tgrpcMuxerOnce sync.Once\n\tgrpcMuxer     *grpcmux.GRPCClientMuxer\n}\n\n// NegotiatedVersion returns the protocol version negotiated with the server.\n// This is only valid after Start() is called.\nfunc (c *Client) NegotiatedVersion() int {\n\treturn c.negotiatedVersion\n}\n\n// ID returns a unique ID for the running plugin. By default this is the process\n// ID (pid), but it could take other forms if RunnerFunc was provided.\nfunc (c *Client) ID() string {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.runner != nil {\n\t\treturn c.runner.ID()\n\t}\n\n\treturn \"\"\n}\n\n// ClientConfig is the configuration used to initialize a new\n// plugin client. After being used to initialize a plugin client,\n// that configuration must not be modified again.\ntype ClientConfig struct {\n\t// HandshakeConfig is the configuration that must match servers.\n\tHandshakeConfig\n\n\t// Plugins are the plugins that can be consumed.\n\t// The implied version of this PluginSet is the Handshake.ProtocolVersion.\n\tPlugins PluginSet\n\n\t// VersionedPlugins is a map of PluginSets for specific protocol versions.\n\t// These can be used to negotiate a compatible version between client and\n\t// server. If this is set, Handshake.ProtocolVersion is not required.\n\tVersionedPlugins map[int]PluginSet\n\n\t// One of the following must be set, but not both.\n\t//\n\t// Cmd is the unstarted subprocess for starting the plugin. If this is\n\t// set, then the Client starts the plugin process on its own and connects\n\t// to it.\n\t//\n\t// Reattach is configuration for reattaching to an existing plugin process\n\t// that is already running. This isn't common.\n\tCmd      *exec.Cmd\n\tReattach *ReattachConfig\n\n\t// RunnerFunc allows consumers to provide their own implementation of\n\t// runner.Runner and control the context within which a plugin is executed.\n\t// The cmd argument will have been copied from the config and populated with\n\t// environment variables that a go-plugin server expects to read such as\n\t// AutoMTLS certs and the magic cookie key.\n\tRunnerFunc func(l hclog.Logger, cmd *exec.Cmd, tmpDir string) (runner.Runner, error)\n\n\t// SecureConfig is configuration for verifying the integrity of the\n\t// executable. It can not be used with Reattach.\n\tSecureConfig *SecureConfig\n\n\t// TLSConfig is used to enable TLS on the RPC client.\n\tTLSConfig *tls.Config\n\n\t// Managed represents if the client should be managed by the\n\t// plugin package or not. If true, then by calling CleanupClients,\n\t// it will automatically be cleaned up. Otherwise, the client\n\t// user is fully responsible for making sure to Kill all plugin\n\t// clients. By default the client is _not_ managed.\n\tManaged bool\n\n\t// The minimum and maximum port to use for communicating with\n\t// the subprocess. If not set, this defaults to 10,000 and 25,000\n\t// respectively.\n\tMinPort, MaxPort uint\n\n\t// StartTimeout is the timeout to wait for the plugin to say it\n\t// has started successfully.\n\tStartTimeout time.Duration\n\n\t// If non-nil, then the stderr of the client will be written to here\n\t// (as well as the log). This is the original os.Stderr of the subprocess.\n\t// This isn't the output of synced stderr.\n\tStderr io.Writer\n\n\t// SyncStdout, SyncStderr can be set to override the\n\t// respective os.Std* values in the plugin. Care should be taken to\n\t// avoid races here. If these are nil, then this will be set to\n\t// ioutil.Discard.\n\tSyncStdout io.Writer\n\tSyncStderr io.Writer\n\n\t// AllowedProtocols is a list of allowed protocols. If this isn't set,\n\t// then only netrpc is allowed. This is so that older go-plugin systems\n\t// can show friendly errors if they see a plugin with an unknown\n\t// protocol.\n\t//\n\t// By setting this, you can cause an error immediately on plugin start\n\t// if an unsupported protocol is used with a good error message.\n\t//\n\t// If this isn't set at all (nil value), then only net/rpc is accepted.\n\t// This is done for legacy reasons. You must explicitly opt-in to\n\t// new protocols.\n\tAllowedProtocols []Protocol\n\n\t// Logger is the logger that the client will used. If none is provided,\n\t// it will default to hclog's default logger.\n\tLogger hclog.Logger\n\n\t// PluginLogBufferSize is the buffer size(bytes) to read from stderr for plugin log lines.\n\t// If this is 0, then the default of 64KB is used.\n\tPluginLogBufferSize int\n\n\t// AutoMTLS has the client and server automatically negotiate mTLS for\n\t// transport authentication. This ensures that only the original client will\n\t// be allowed to connect to the server, and all other connections will be\n\t// rejected. The client will also refuse to connect to any server that isn't\n\t// the original instance started by the client.\n\t//\n\t// In this mode of operation, the client generates a one-time use tls\n\t// certificate, sends the public x.509 certificate to the new server, and\n\t// the server generates a one-time use tls certificate, and sends the public\n\t// x.509 certificate back to the client. These are used to authenticate all\n\t// rpc connections between the client and server.\n\t//\n\t// Setting AutoMTLS to true implies that the server must support the\n\t// protocol, and correctly negotiate the tls certificates, or a connection\n\t// failure will result.\n\t//\n\t// The client should not set TLSConfig, nor should the server set a\n\t// TLSProvider, because AutoMTLS implies that a new certificate and tls\n\t// configuration will be generated at startup.\n\t//\n\t// You cannot Reattach to a server with this option enabled.\n\tAutoMTLS bool\n\n\t// GRPCDialOptions allows plugin users to pass custom grpc.DialOption\n\t// to create gRPC connections. This only affects plugins using the gRPC\n\t// protocol.\n\tGRPCDialOptions []grpc.DialOption\n\n\t// GRPCBrokerMultiplex turns on multiplexing for the gRPC broker. The gRPC\n\t// broker will multiplex all brokered gRPC servers over the plugin's original\n\t// listener socket instead of making a new listener for each server. The\n\t// go-plugin library currently only includes a Go implementation for the\n\t// server (i.e. plugin) side of gRPC broker multiplexing.\n\t//\n\t// Does not support reattaching.\n\t//\n\t// Multiplexed gRPC streams MUST be established sequentially, i.e. after\n\t// calling AcceptAndServe from one side, wait for the other side to Dial\n\t// before calling AcceptAndServe again.\n\tGRPCBrokerMultiplex bool\n\n\t// SkipHostEnv allows plugins to run without inheriting the parent process'\n\t// environment variables.\n\tSkipHostEnv bool\n\n\t// UnixSocketConfig configures additional options for any Unix sockets\n\t// that are created. Not normally required. Not supported on Windows.\n\tUnixSocketConfig *UnixSocketConfig\n}\n\ntype UnixSocketConfig struct {\n\t// If set, go-plugin will change the owner of any Unix sockets created to\n\t// this group, and set them as group-writable. Can be a name or gid. The\n\t// client process must be a member of this group or chown will fail.\n\tGroup string\n\n\t// TempDir specifies the base directory to use when creating a plugin-specific\n\t// temporary directory. It is expected to already exist and be writable. If\n\t// not set, defaults to the directory chosen by os.MkdirTemp.\n\tTempDir string\n\n\t// The directory to create Unix sockets in. Internally created and managed\n\t// by go-plugin and deleted when the plugin is killed. Will be created\n\t// inside TempDir if specified.\n\tsocketDir string\n}\n\n// ReattachConfig is used to configure a client to reattach to an\n// already-running plugin process. You can retrieve this information by\n// calling ReattachConfig on Client.\ntype ReattachConfig struct {\n\tProtocol        Protocol\n\tProtocolVersion int\n\tAddr            net.Addr\n\tPid             int\n\n\t// ReattachFunc allows consumers to provide their own implementation of\n\t// runner.AttachedRunner and attach to something other than a plain process.\n\t// At least one of Pid or ReattachFunc must be set.\n\tReattachFunc runner.ReattachFunc\n\n\t// Test is set to true if this is reattaching to to a plugin in \"test mode\"\n\t// (see ServeConfig.Test). In this mode, client.Kill will NOT kill the\n\t// process and instead will rely on the plugin to terminate itself. This\n\t// should not be used in non-test environments.\n\tTest bool\n}\n\n// SecureConfig is used to configure a client to verify the integrity of an\n// executable before running. It does this by verifying the checksum is\n// expected. Hash is used to specify the hashing method to use when checksumming\n// the file.  The configuration is verified by the client by calling the\n// SecureConfig.Check() function.\n//\n// The host process should ensure the checksum was provided by a trusted and\n// authoritative source. The binary should be installed in such a way that it\n// can not be modified by an unauthorized user between the time of this check\n// and the time of execution.\ntype SecureConfig struct {\n\tChecksum []byte\n\tHash     hash.Hash\n}\n\n// Check takes the filepath to an executable and returns true if the checksum of\n// the file matches the checksum provided in the SecureConfig.\nfunc (s *SecureConfig) Check(filePath string) (bool, error) {\n\tif len(s.Checksum) == 0 {\n\t\treturn false, ErrSecureConfigNoChecksum\n\t}\n\n\tif s.Hash == nil {\n\t\treturn false, ErrSecureConfigNoHash\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(s.Hash, file)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tsum := s.Hash.Sum(nil)\n\n\treturn subtle.ConstantTimeCompare(sum, s.Checksum) == 1, nil\n}\n\n// This makes sure all the managed subprocesses are killed and properly\n// logged. This should be called before the parent process running the\n// plugins exits.\n//\n// This must only be called _once_.\nfunc CleanupClients() {\n\t// Set the killed to true so that we don't get unexpected panics\n\tatomic.StoreUint32(&Killed, 1)\n\n\t// Kill all the managed clients in parallel and use a WaitGroup\n\t// to wait for them all to finish up.\n\tvar wg sync.WaitGroup\n\tmanagedClientsLock.Lock()\n\tfor _, client := range managedClients {\n\t\twg.Add(1)\n\n\t\tgo func(client *Client) {\n\t\t\tclient.Kill()\n\t\t\twg.Done()\n\t\t}(client)\n\t}\n\tmanagedClientsLock.Unlock()\n\n\twg.Wait()\n}\n\n// NewClient creates a new plugin client which manages the lifecycle of an external\n// plugin and gets the address for the RPC connection.\n//\n// The client must be cleaned up at some point by calling Kill(). If\n// the client is a managed client (created with ClientConfig.Managed) you\n// can just call CleanupClients at the end of your program and they will\n// be properly cleaned.\nfunc NewClient(config *ClientConfig) (c *Client) {\n\tif config.MinPort == 0 && config.MaxPort == 0 {\n\t\tconfig.MinPort = 10000\n\t\tconfig.MaxPort = 25000\n\t}\n\n\tif config.StartTimeout == 0 {\n\t\tconfig.StartTimeout = 1 * time.Minute\n\t}\n\n\tif config.Stderr == nil {\n\t\tconfig.Stderr = ioutil.Discard\n\t}\n\n\tif config.SyncStdout == nil {\n\t\tconfig.SyncStdout = io.Discard\n\t}\n\tif config.SyncStderr == nil {\n\t\tconfig.SyncStderr = io.Discard\n\t}\n\n\tif config.AllowedProtocols == nil {\n\t\tconfig.AllowedProtocols = []Protocol{ProtocolNetRPC}\n\t}\n\n\tif config.Logger == nil {\n\t\tconfig.Logger = hclog.New(&hclog.LoggerOptions{\n\t\t\tOutput: hclog.DefaultOutput,\n\t\t\tLevel:  hclog.Trace,\n\t\t\tName:   \"plugin\",\n\t\t})\n\t}\n\n\tif config.PluginLogBufferSize == 0 {\n\t\tconfig.PluginLogBufferSize = defaultPluginLogBufferSize\n\t}\n\n\tc = &Client{\n\t\tconfig: config,\n\t\tlogger: config.Logger,\n\t}\n\tif config.Managed {\n\t\tmanagedClientsLock.Lock()\n\t\tmanagedClients = append(managedClients, c)\n\t\tmanagedClientsLock.Unlock()\n\t}\n\n\treturn\n}\n\n// Client returns the protocol client for this connection.\n//\n// Subsequent calls to this will return the same client.\nfunc (c *Client) Client() (ClientProtocol, error) {\n\t_, err := c.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.client != nil {\n\t\treturn c.client, nil\n\t}\n\n\tswitch c.protocol {\n\tcase ProtocolNetRPC:\n\t\tc.client, err = newRPCClient(c)\n\n\tcase ProtocolGRPC:\n\t\tc.client, err = newGRPCClient(c.doneCtx, c)\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown server protocol: %s\", c.protocol)\n\t}\n\n\tif err != nil {\n\t\tc.client = nil\n\t\treturn nil, err\n\t}\n\n\treturn c.client, nil\n}\n\n// Tells whether or not the underlying process has exited.\nfunc (c *Client) Exited() bool {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\treturn c.exited\n}\n\n// killed is used in tests to check if a process failed to exit gracefully, and\n// needed to be killed.\nfunc (c *Client) killed() bool {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\treturn c.processKilled\n}\n\n// End the executing subprocess (if it is running) and perform any cleanup\n// tasks necessary such as capturing any remaining logs and so on.\n//\n// This method blocks until the process successfully exits.\n//\n// This method can safely be called multiple times.\nfunc (c *Client) Kill() {\n\t// Grab a lock to read some private fields.\n\tc.l.Lock()\n\trunner := c.runner\n\taddr := c.address\n\thostSocketDir := c.unixSocketCfg.socketDir\n\tc.l.Unlock()\n\n\t// If there is no runner or ID, there is nothing to kill.\n\tif runner == nil || runner.ID() == \"\" {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\t// Wait for the all client goroutines to finish.\n\t\tc.clientWaitGroup.Wait()\n\n\t\tif hostSocketDir != \"\" {\n\t\t\tos.RemoveAll(hostSocketDir)\n\t\t}\n\n\t\t// Make sure there is no reference to the old process after it has been\n\t\t// killed.\n\t\tc.l.Lock()\n\t\tc.runner = nil\n\t\tc.l.Unlock()\n\t}()\n\n\t// We need to check for address here. It is possible that the plugin\n\t// started (process != nil) but has no address (addr == nil) if the\n\t// plugin failed at startup. If we do have an address, we need to close\n\t// the plugin net connections.\n\tgraceful := false\n\tif addr != nil {\n\t\t// Close the client to cleanly exit the process.\n\t\tclient, err := c.Client()\n\t\tif err == nil {\n\t\t\terr = client.Close()\n\n\t\t\t// If there is no error, then we attempt to wait for a graceful\n\t\t\t// exit. If there was an error, we assume that graceful cleanup\n\t\t\t// won't happen and just force kill.\n\t\t\tgraceful = err == nil\n\t\t\tif err != nil {\n\t\t\t\t// If there was an error just log it. We're going to force\n\t\t\t\t// kill in a moment anyways.\n\t\t\t\tc.logger.Warn(\"error closing client during Kill\", \"err\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tc.logger.Error(\"client\", \"error\", err)\n\t\t}\n\t}\n\n\t// If we're attempting a graceful exit, then we wait for a short period\n\t// of time to allow that to happen. To wait for this we just wait on the\n\t// doneCh which would be closed if the process exits.\n\tif graceful {\n\t\tselect {\n\t\tcase <-c.doneCtx.Done():\n\t\t\tc.logger.Debug(\"plugin exited\")\n\t\t\treturn\n\t\tcase <-time.After(2 * time.Second):\n\t\t}\n\t}\n\n\t// If graceful exiting failed, just kill it\n\tc.logger.Warn(\"plugin failed to exit gracefully\")\n\tif err := runner.Kill(context.Background()); err != nil {\n\t\tc.logger.Debug(\"error killing plugin\", \"error\", err)\n\t}\n\n\tc.l.Lock()\n\tc.processKilled = true\n\tc.l.Unlock()\n}\n\n// Start the underlying subprocess, communicating with it to negotiate\n// a port for RPC connections, and returning the address to connect via RPC.\n//\n// This method is safe to call multiple times. Subsequent calls have no effect.\n// Once a client has been started once, it cannot be started again, even if\n// it was killed.\nfunc (c *Client) Start() (addr net.Addr, err error) {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.address != nil {\n\t\treturn c.address, nil\n\t}\n\n\t// If one of cmd or reattach isn't set, then it is an error. We wrap\n\t// this in a {} for scoping reasons, and hopeful that the escape\n\t// analysis will pop the stack here.\n\t{\n\t\tvar mutuallyExclusiveOptions int\n\t\tif c.config.Cmd != nil {\n\t\t\tmutuallyExclusiveOptions += 1\n\t\t}\n\t\tif c.config.Reattach != nil {\n\t\t\tmutuallyExclusiveOptions += 1\n\t\t}\n\t\tif c.config.RunnerFunc != nil {\n\t\t\tmutuallyExclusiveOptions += 1\n\t\t}\n\t\tif mutuallyExclusiveOptions != 1 {\n\t\t\treturn nil, fmt.Errorf(\"exactly one of Cmd, or Reattach, or RunnerFunc must be set\")\n\t\t}\n\n\t\tif c.config.SecureConfig != nil && c.config.Reattach != nil {\n\t\t\treturn nil, ErrSecureConfigAndReattach\n\t\t}\n\n\t\tif c.config.GRPCBrokerMultiplex && c.config.Reattach != nil {\n\t\t\treturn nil, fmt.Errorf(\"gRPC broker multiplexing is not supported with Reattach config\")\n\t\t}\n\t}\n\n\tif c.config.Reattach != nil {\n\t\treturn c.reattach()\n\t}\n\n\tif c.config.VersionedPlugins == nil {\n\t\tc.config.VersionedPlugins = make(map[int]PluginSet)\n\t}\n\n\t// handle all plugins as versioned, using the handshake config as the default.\n\tversion := int(c.config.ProtocolVersion)\n\n\t// Make sure we're not overwriting a real version 0. If ProtocolVersion was\n\t// non-zero, then we have to just assume the user made sure that\n\t// VersionedPlugins doesn't conflict.\n\tif _, ok := c.config.VersionedPlugins[version]; !ok && c.config.Plugins != nil {\n\t\tc.config.VersionedPlugins[version] = c.config.Plugins\n\t}\n\n\tvar versionStrings []string\n\tfor v := range c.config.VersionedPlugins {\n\t\tversionStrings = append(versionStrings, strconv.Itoa(v))\n\t}\n\n\tenv := []string{\n\t\tfmt.Sprintf(\"%s=%s\", c.config.MagicCookieKey, c.config.MagicCookieValue),\n\t\tfmt.Sprintf(\"PLUGIN_MIN_PORT=%d\", c.config.MinPort),\n\t\tfmt.Sprintf(\"PLUGIN_MAX_PORT=%d\", c.config.MaxPort),\n\t\tfmt.Sprintf(\"PLUGIN_PROTOCOL_VERSIONS=%s\", strings.Join(versionStrings, \",\")),\n\t}\n\tif c.config.GRPCBrokerMultiplex {\n\t\tenv = append(env, fmt.Sprintf(\"%s=true\", envMultiplexGRPC))\n\t}\n\n\tcmd := c.config.Cmd\n\tif cmd == nil {\n\t\t// It's only possible to get here if RunnerFunc is non-nil, but we'll\n\t\t// still use cmd as a spec to populate metadata for the external\n\t\t// implementation to consume.\n\t\tcmd = exec.Command(\"\")\n\t}\n\tif !c.config.SkipHostEnv {\n\t\tcmd.Env = append(cmd.Env, os.Environ()...)\n\t}\n\tcmd.Env = append(cmd.Env, env...)\n\tcmd.Stdin = os.Stdin\n\n\tif c.config.SecureConfig != nil {\n\t\tif ok, err := c.config.SecureConfig.Check(cmd.Path); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error verifying checksum: %s\", err)\n\t\t} else if !ok {\n\t\t\treturn nil, ErrChecksumsDoNotMatch\n\t\t}\n\t}\n\n\t// Setup a temporary certificate for client/server mtls, and send the public\n\t// certificate to the plugin.\n\tif c.config.AutoMTLS {\n\t\tc.logger.Info(\"configuring client automatic mTLS\")\n\t\tcertPEM, keyPEM, err := generateCert()\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"failed to generate client certificate\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tcert, err := tls.X509KeyPair(certPEM, keyPEM)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"failed to parse client certificate\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"PLUGIN_CLIENT_CERT=%s\", certPEM))\n\n\t\tc.config.TLSConfig = &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tMinVersion:   tls.VersionTLS12,\n\t\t\tServerName:   \"localhost\",\n\t\t}\n\t}\n\n\tif c.config.UnixSocketConfig != nil {\n\t\tc.unixSocketCfg = *c.config.UnixSocketConfig\n\t}\n\n\tif c.unixSocketCfg.Group != \"\" {\n\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"%s=%s\", EnvUnixSocketGroup, c.unixSocketCfg.Group))\n\t}\n\n\tvar runner runner.Runner\n\tswitch {\n\tcase c.config.RunnerFunc != nil:\n\t\tc.unixSocketCfg.socketDir, err = os.MkdirTemp(c.unixSocketCfg.TempDir, \"plugin-dir\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// os.MkdirTemp creates folders with 0o700, so if we have a group\n\t\t// configured we need to make it group-writable.\n\t\tif c.unixSocketCfg.Group != \"\" {\n\t\t\terr = setGroupWritable(c.unixSocketCfg.socketDir, c.unixSocketCfg.Group, 0o770)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"%s=%s\", EnvUnixSocketDir, c.unixSocketCfg.socketDir))\n\t\tc.logger.Trace(\"created temporary directory for unix sockets\", \"dir\", c.unixSocketCfg.socketDir)\n\n\t\trunner, err = c.config.RunnerFunc(c.logger, cmd, c.unixSocketCfg.socketDir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\trunner, err = cmdrunner.NewCmdRunner(c.logger, cmd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t}\n\n\tc.runner = runner\n\tstartCtx, startCtxCancel := context.WithTimeout(context.Background(), c.config.StartTimeout)\n\tdefer startCtxCancel()\n\terr = runner.Start(startCtx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure the command is properly cleaned up if there is an error\n\tdefer func() {\n\t\trErr := recover()\n\n\t\tif err != nil || rErr != nil {\n\t\t\trunner.Kill(context.Background())\n\t\t}\n\n\t\tif rErr != nil {\n\t\t\tpanic(rErr)\n\t\t}\n\t}()\n\n\t// Create a context for when we kill\n\tc.doneCtx, c.ctxCancel = context.WithCancel(context.Background())\n\n\t// Start goroutine that logs the stderr\n\tc.clientWaitGroup.Add(1)\n\tc.pipesWaitGroup.Add(1)\n\t// logStderr calls c.pipesWaitGroup.Done()\n\tgo c.logStderr(runner.Name(), runner.Stderr())\n\n\tc.clientWaitGroup.Add(1)\n\tgo func() {\n\t\t// ensure the context is cancelled when we're done\n\t\tdefer c.ctxCancel()\n\n\t\tdefer c.clientWaitGroup.Done()\n\n\t\t// wait to finish reading from stdout/stderr since the stdout/stderr pipe readers\n\t\t// will be closed by the subsequent call to cmd.Wait().\n\t\tc.pipesWaitGroup.Wait()\n\n\t\t// Wait for the command to end.\n\t\terr := runner.Wait(context.Background())\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"plugin process exited\", \"plugin\", runner.Name(), \"id\", runner.ID(), \"error\", err.Error())\n\t\t} else {\n\t\t\t// Log and make sure to flush the logs right away\n\t\t\tc.logger.Info(\"plugin process exited\", \"plugin\", runner.Name(), \"id\", runner.ID())\n\t\t}\n\n\t\tos.Stderr.Sync()\n\n\t\t// Set that we exited, which takes a lock\n\t\tc.l.Lock()\n\t\tdefer c.l.Unlock()\n\t\tc.exited = true\n\t}()\n\n\t// Start a goroutine that is going to be reading the lines\n\t// out of stdout\n\tlinesCh := make(chan string)\n\tc.clientWaitGroup.Add(1)\n\tc.pipesWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer c.clientWaitGroup.Done()\n\t\tdefer c.pipesWaitGroup.Done()\n\t\tdefer close(linesCh)\n\n\t\tscanner := bufio.NewScanner(runner.Stdout())\n\t\tfor scanner.Scan() {\n\t\t\tlinesCh <- scanner.Text()\n\t\t}\n\t\tif scanner.Err() != nil {\n\t\t\tc.logger.Error(\"error encountered while scanning stdout\", \"error\", scanner.Err())\n\t\t}\n\t}()\n\n\t// Make sure after we exit we read the lines from stdout forever\n\t// so they don't block since it is a pipe.\n\t// The scanner goroutine above will close this, but track it with a wait\n\t// group for completeness.\n\tc.clientWaitGroup.Add(1)\n\tdefer func() {\n\t\tgo func() {\n\t\t\tdefer c.clientWaitGroup.Done()\n\t\t\tfor range linesCh {\n\t\t\t}\n\t\t}()\n\t}()\n\n\t// Some channels for the next step\n\ttimeout := time.After(c.config.StartTimeout)\n\n\t// Start looking for the address\n\tc.logger.Debug(\"waiting for RPC address\", \"plugin\", runner.Name())\n\tselect {\n\tcase <-timeout:\n\t\terr = errors.New(\"timeout while waiting for plugin to start\")\n\tcase <-c.doneCtx.Done():\n\t\terr = errors.New(\"plugin exited before we could connect\")\n\tcase line, ok := <-linesCh:\n\t\t// Trim the line and split by \"|\" in order to get the parts of\n\t\t// the output.\n\t\tline = strings.TrimSpace(line)\n\t\tparts := strings.Split(line, \"|\")\n\t\tif len(parts) < 4 {\n\t\t\terrText := fmt.Sprintf(\"Unrecognized remote plugin message: %s\", line)\n\t\t\tif !ok {\n\t\t\t\terrText += \"\\n\" + \"Failed to read any lines from plugin's stdout\"\n\t\t\t}\n\t\t\tadditionalNotes := runner.Diagnose(context.Background())\n\t\t\tif additionalNotes != \"\" {\n\t\t\t\terrText += \"\\n\" + additionalNotes\n\t\t\t}\n\t\t\terr = errors.New(errText)\n\t\t\treturn\n\t\t}\n\n\t\t// Check the core protocol. Wrapped in a {} for scoping.\n\t\t{\n\t\t\tvar coreProtocol int\n\t\t\tcoreProtocol, err = strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\terr = fmt.Errorf(\"Error parsing core protocol version: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif coreProtocol != CoreProtocolVersion {\n\t\t\t\terr = fmt.Errorf(\"Incompatible core API version with plugin. \"+\n\t\t\t\t\t\"Plugin version: %s, Core version: %d\\n\\n\"+\n\t\t\t\t\t\"To fix this, the plugin usually only needs to be recompiled.\\n\"+\n\t\t\t\t\t\"Please report this to the plugin author.\", parts[0], CoreProtocolVersion)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Test the API version\n\t\tversion, pluginSet, err := c.checkProtoVersion(parts[1])\n\t\tif err != nil {\n\t\t\treturn addr, err\n\t\t}\n\n\t\t// set the Plugins value to the compatible set, so the version\n\t\t// doesn't need to be passed through to the ClientProtocol\n\t\t// implementation.\n\t\tc.config.Plugins = pluginSet\n\t\tc.negotiatedVersion = version\n\t\tc.logger.Debug(\"using plugin\", \"version\", version)\n\n\t\tnetwork, address, err := runner.PluginToHost(parts[2], parts[3])\n\t\tif err != nil {\n\t\t\treturn addr, err\n\t\t}\n\n\t\tswitch network {\n\t\tcase \"tcp\":\n\t\t\taddr, err = net.ResolveTCPAddr(\"tcp\", address)\n\t\tcase \"unix\":\n\t\t\taddr, err = net.ResolveUnixAddr(\"unix\", address)\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"Unknown address type: %s\", address)\n\t\t}\n\n\t\t// If we have a server type, then record that. We default to net/rpc\n\t\t// for backwards compatibility.\n\t\tc.protocol = ProtocolNetRPC\n\t\tif len(parts) >= 5 {\n\t\t\tc.protocol = Protocol(parts[4])\n\t\t}\n\n\t\tfound := false\n\t\tfor _, p := range c.config.AllowedProtocols {\n\t\t\tif p == c.protocol {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\terr = fmt.Errorf(\"Unsupported plugin protocol %q. Supported: %v\",\n\t\t\t\tc.protocol, c.config.AllowedProtocols)\n\t\t\treturn addr, err\n\t\t}\n\n\t\t// See if we have a TLS certificate from the server.\n\t\t// Checking if the length is > 50 rules out catching the unused \"extra\"\n\t\t// data returned from some older implementations.\n\t\tif len(parts) >= 6 && len(parts[5]) > 50 {\n\t\t\terr := c.loadServerCert(parts[5])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error parsing server cert: %s\", err)\n\t\t\t}\n\t\t}\n\n\t\tif c.config.GRPCBrokerMultiplex && c.protocol == ProtocolGRPC {\n\t\t\tif len(parts) <= 6 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w; for Go plugins, you will need to update the \"+\n\t\t\t\t\t\"github.com/hashicorp/go-plugin dependency and recompile\", ErrGRPCBrokerMuxNotSupported)\n\t\t\t}\n\t\t\tif muxSupported, err := strconv.ParseBool(parts[6]); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error parsing %q as a boolean for gRPC broker multiplexing support\", parts[6])\n\t\t\t} else if !muxSupported {\n\t\t\t\treturn nil, ErrGRPCBrokerMuxNotSupported\n\t\t\t}\n\t\t}\n\t}\n\n\tc.address = addr\n\treturn\n}\n\n// loadServerCert is used by AutoMTLS to read an x.509 cert returned by the\n// server, and load it as the RootCA and ClientCA for the client TLSConfig.\nfunc (c *Client) loadServerCert(cert string) error {\n\tcertPool := x509.NewCertPool()\n\n\tasn1, err := base64.RawStdEncoding.DecodeString(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tx509Cert, err := x509.ParseCertificate([]byte(asn1))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertPool.AddCert(x509Cert)\n\n\tc.config.TLSConfig.RootCAs = certPool\n\tc.config.TLSConfig.ClientCAs = certPool\n\treturn nil\n}\n\nfunc (c *Client) reattach() (net.Addr, error) {\n\treattachFunc := c.config.Reattach.ReattachFunc\n\t// For backwards compatibility default to cmdrunner.ReattachFunc\n\tif reattachFunc == nil {\n\t\treattachFunc = cmdrunner.ReattachFunc(c.config.Reattach.Pid, c.config.Reattach.Addr)\n\t}\n\n\tr, err := reattachFunc()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a context for when we kill\n\tc.doneCtx, c.ctxCancel = context.WithCancel(context.Background())\n\n\tc.clientWaitGroup.Add(1)\n\t// Goroutine to mark exit status\n\tgo func(r runner.AttachedRunner) {\n\t\tdefer c.clientWaitGroup.Done()\n\n\t\t// ensure the context is cancelled when we're done\n\t\tdefer c.ctxCancel()\n\n\t\t// Wait for the process to die\n\t\tr.Wait(context.Background())\n\n\t\t// Log so we can see it\n\t\tc.logger.Debug(\"reattached plugin process exited\")\n\n\t\t// Mark it\n\t\tc.l.Lock()\n\t\tdefer c.l.Unlock()\n\t\tc.exited = true\n\t}(r)\n\n\t// Set the address and protocol\n\tc.address = c.config.Reattach.Addr\n\tc.protocol = c.config.Reattach.Protocol\n\tif c.protocol == \"\" {\n\t\t// Default the protocol to net/rpc for backwards compatibility\n\t\tc.protocol = ProtocolNetRPC\n\t}\n\n\tif c.config.Reattach.Test {\n\t\tc.negotiatedVersion = c.config.Reattach.ProtocolVersion\n\t} else {\n\t\t// If we're in test mode, we do NOT set the runner. This avoids the\n\t\t// runner being killed (the only purpose we have for setting c.runner\n\t\t// when reattaching), since in test mode the process is responsible for\n\t\t// exiting on its own.\n\t\tc.runner = r\n\t}\n\n\treturn c.address, nil\n}\n\n// checkProtoVersion returns the negotiated version and PluginSet.\n// This returns an error if the server returned an incompatible protocol\n// version, or an invalid handshake response.\nfunc (c *Client) checkProtoVersion(protoVersion string) (int, PluginSet, error) {\n\tserverVersion, err := strconv.Atoi(protoVersion)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"Error parsing protocol version %q: %s\", protoVersion, err)\n\t}\n\n\t// record these for the error message\n\tvar clientVersions []int\n\n\t// all versions, including the legacy ProtocolVersion have been added to\n\t// the versions set\n\tfor version, plugins := range c.config.VersionedPlugins {\n\t\tclientVersions = append(clientVersions, version)\n\n\t\tif serverVersion != version {\n\t\t\tcontinue\n\t\t}\n\t\treturn version, plugins, nil\n\t}\n\n\treturn 0, nil, fmt.Errorf(\"Incompatible API version with plugin. \"+\n\t\t\"Plugin version: %d, Client versions: %d\", serverVersion, clientVersions)\n}\n\n// ReattachConfig returns the information that must be provided to NewClient\n// to reattach to the plugin process that this client started. This is\n// useful for plugins that detach from their parent process.\n//\n// If this returns nil then the process hasn't been started yet. Please\n// call Start or Client before calling this.\n//\n// Clients who specified a RunnerFunc will need to populate their own\n// ReattachFunc in the returned ReattachConfig before it can be used.\nfunc (c *Client) ReattachConfig() *ReattachConfig {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.address == nil {\n\t\treturn nil\n\t}\n\n\tif c.config.Cmd != nil && c.config.Cmd.Process == nil {\n\t\treturn nil\n\t}\n\n\t// If we connected via reattach, just return the information as-is\n\tif c.config.Reattach != nil {\n\t\treturn c.config.Reattach\n\t}\n\n\treattach := &ReattachConfig{\n\t\tProtocol: c.protocol,\n\t\tAddr:     c.address,\n\t}\n\n\tif c.config.Cmd != nil && c.config.Cmd.Process != nil {\n\t\treattach.Pid = c.config.Cmd.Process.Pid\n\t}\n\n\treturn reattach\n}\n\n// Protocol returns the protocol of server on the remote end. This will\n// start the plugin process if it isn't already started. Errors from\n// starting the plugin are surpressed and ProtocolInvalid is returned. It\n// is recommended you call Start explicitly before calling Protocol to ensure\n// no errors occur.\nfunc (c *Client) Protocol() Protocol {\n\t_, err := c.Start()\n\tif err != nil {\n\t\treturn ProtocolInvalid\n\t}\n\n\treturn c.protocol\n}\n\nfunc netAddrDialer(addr net.Addr) func(string, time.Duration) (net.Conn, error) {\n\treturn func(_ string, _ time.Duration) (net.Conn, error) {\n\t\t// Connect to the client\n\t\tconn, err := net.Dial(addr.Network(), addr.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\t\t// Make sure to set keep alive so that the connection doesn't die\n\t\t\ttcpConn.SetKeepAlive(true)\n\t\t}\n\n\t\treturn conn, nil\n\t}\n}\n\n// dialer is compatible with grpc.WithDialer and creates the connection\n// to the plugin.\nfunc (c *Client) dialer(_ string, timeout time.Duration) (net.Conn, error) {\n\tmuxer, err := c.getGRPCMuxer(c.address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar conn net.Conn\n\tif muxer.Enabled() {\n\t\tconn, err = muxer.Dial()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tconn, err = netAddrDialer(c.address)(\"\", timeout)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If we have a TLS config we wrap our connection. We only do this\n\t// for net/rpc since gRPC uses its own mechanism for TLS.\n\tif c.protocol == ProtocolNetRPC && c.config.TLSConfig != nil {\n\t\tconn = tls.Client(conn, c.config.TLSConfig)\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) getGRPCMuxer(addr net.Addr) (*grpcmux.GRPCClientMuxer, error) {\n\tif c.protocol != ProtocolGRPC || !c.config.GRPCBrokerMultiplex {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tc.grpcMuxerOnce.Do(func() {\n\t\tc.grpcMuxer, err = grpcmux.NewGRPCClientMuxer(c.logger, addr)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c.grpcMuxer, nil\n}\n\nfunc (c *Client) logStderr(name string, r io.Reader) {\n\tdefer c.clientWaitGroup.Done()\n\tdefer c.pipesWaitGroup.Done()\n\tl := c.logger.Named(filepath.Base(name))\n\n\treader := bufio.NewReaderSize(r, c.config.PluginLogBufferSize)\n\t// continuation indicates the previous line was a prefix\n\tcontinuation := false\n\n\tfor {\n\t\tline, isPrefix, err := reader.ReadLine()\n\t\tswitch {\n\t\tcase err == io.EOF:\n\t\t\treturn\n\t\tcase err != nil:\n\t\t\tl.Error(\"reading plugin stderr\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tc.config.Stderr.Write(line)\n\n\t\t// The line was longer than our max token size, so it's likely\n\t\t// incomplete and won't unmarshal.\n\t\tif isPrefix || continuation {\n\t\t\tl.Debug(string(line))\n\n\t\t\t// if we're finishing a continued line, add the newline back in\n\t\t\tif !isPrefix {\n\t\t\t\tc.config.Stderr.Write([]byte{'\\n'})\n\t\t\t}\n\n\t\t\tcontinuation = isPrefix\n\t\t\tcontinue\n\t\t}\n\n\t\tc.config.Stderr.Write([]byte{'\\n'})\n\n\t\tentry, err := parseJSON(line)\n\t\t// If output is not JSON format, print directly to Debug\n\t\tif err != nil {\n\t\t\t// Attempt to infer the desired log level from the commonly used\n\t\t\t// string prefixes\n\t\t\tswitch line := string(line); {\n\t\t\tcase strings.HasPrefix(line, \"[TRACE]\"):\n\t\t\t\tl.Trace(line)\n\t\t\tcase strings.HasPrefix(line, \"[DEBUG]\"):\n\t\t\t\tl.Debug(line)\n\t\t\tcase strings.HasPrefix(line, \"[INFO]\"):\n\t\t\t\tl.Info(line)\n\t\t\tcase strings.HasPrefix(line, \"[WARN]\"):\n\t\t\t\tl.Warn(line)\n\t\t\tcase strings.HasPrefix(line, \"[ERROR]\"):\n\t\t\t\tl.Error(line)\n\t\t\tdefault:\n\t\t\t\tl.Debug(line)\n\t\t\t}\n\t\t} else {\n\t\t\tout := flattenKVPairs(entry.KVPairs)\n\n\t\t\tout = append(out, \"timestamp\", entry.Timestamp.Format(hclog.TimeFormat))\n\t\t\tswitch hclog.LevelFromString(entry.Level) {\n\t\t\tcase hclog.Trace:\n\t\t\t\tl.Trace(entry.Message, out...)\n\t\t\tcase hclog.Debug:\n\t\t\t\tl.Debug(entry.Message, out...)\n\t\t\tcase hclog.Info:\n\t\t\t\tl.Info(entry.Message, out...)\n\t\t\tcase hclog.Warn:\n\t\t\t\tl.Warn(entry.Message, out...)\n\t\t\tcase hclog.Error:\n\t\t\t\tl.Error(entry.Message, out...)\n\t\t\tdefault:\n\t\t\t\t// if there was no log level, it's likely this is unexpected\n\t\t\t\t// json from something other than hclog, and we should output\n\t\t\t\t// it verbatim.\n\t\t\t\tl.Debug(string(line))\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "client_posix_test.go",
          "type": "blob",
          "size": 2.130859375,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\n//go:build !windows\n// +build !windows\n\npackage plugin\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestClient_testInterfaceReattach(t *testing.T) {\n\t// Setup the process for daemonization\n\tprocess := helperProcess(\"test-interface-daemon\")\n\tif process.SysProcAttr == nil {\n\t\tprocess.SysProcAttr = &syscall.SysProcAttr{}\n\t}\n\tprocess.SysProcAttr.Setsid = true\n\tsyscall.Umask(0)\n\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\n\t// Start it so we can get the reattach info\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// New client with reattach info\n\treattach := c.ReattachConfig()\n\tif reattach == nil {\n\t\tc.Kill()\n\t\tt.Fatal(\"reattach config should be non-nil\")\n\t}\n\n\t// Find the process and defer a kill so we know it is gone\n\tp, err := os.FindProcess(reattach.Pid)\n\tif err != nil {\n\t\tc.Kill()\n\t\tt.Fatalf(\"couldn't find process: %s\", err)\n\t}\n\tdefer p.Kill()\n\n\t// Reattach\n\tc = NewClient(&ClientConfig{\n\t\tReattach:        reattach,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\n\t// Start shouldn't error\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// It should still be alive\n\ttime.Sleep(1 * time.Second)\n\tif c.Exited() {\n\t\tt.Fatal(\"should not be exited\")\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Test the resulting reattach config\n\treattach2 := c.ReattachConfig()\n\tif reattach2 == nil {\n\t\tt.Fatal(\"reattach from reattached should not be nil\")\n\t}\n\tif !reflect.DeepEqual(reattach, reattach2) {\n\t\tt.Fatalf(\"bad: %#v\", reattach)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 34.0712890625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/cmdrunner\"\n\t\"github.com/hashicorp/go-plugin/runner\"\n)\n\nfunc TestClient(t *testing.T) {\n\tprocess := helperProcess(\"mock\")\n\tlogger := &trackingLogger{Logger: hclog.Default()}\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tLogger:          logger,\n\t})\n\tdefer c.Kill()\n\n\t// Test that it parses the proper address\n\taddr, err := c.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\tif addr.Network() != \"tcp\" {\n\t\tt.Fatalf(\"bad: %#v\", addr)\n\t}\n\n\tif addr.String() != \":1234\" {\n\t\tt.Fatalf(\"bad: %#v\", addr)\n\t}\n\n\t// Test that it exits properly if killed\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\t// this test isn't expected to get a client\n\tif !c.killed() {\n\t\tt.Fatal(\"Client should have failed\")\n\t}\n\n\t// One error for connection refused, one for plugin exited.\n\tassertLines(t, logger.errorLogs, 2)\n}\n\n// This tests a bug where Kill would start\nfunc TestClient_killStart(t *testing.T) {\n\t// Create a temporary dir to store the result file\n\ttd := t.TempDir()\n\tdefer os.RemoveAll(td)\n\n\t// Start the client\n\tpath := filepath.Join(td, \"booted\")\n\tprocess := helperProcess(\"bad-version\", path)\n\tc := NewClient(&ClientConfig{Cmd: process, HandshakeConfig: testHandshake})\n\tdefer c.Kill()\n\n\t// Verify our path doesn't exist\n\tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\n\t// Test that it parses the proper address\n\tif _, err := c.Start(); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\n\t// Verify we started\n\tif _, err := os.Stat(path); err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\tif err := os.Remove(path); err != nil {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n\n\t// Test that Kill does nothing really\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif !c.killed() {\n\t\tt.Fatal(\"process should have failed\")\n\t}\n\n\t// Verify our path doesn't exist\n\tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n\t\tt.Fatalf(\"bad: %s\", err)\n\t}\n}\n\nfunc TestClient_testCleanup(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a path that the helper process will write on cleanup\n\tpath := filepath.Join(t.TempDir(), \"output\")\n\n\t// Test the cleanup\n\tprocess := helperProcess(\"cleanup\", path)\n\tlogger := &trackingLogger{Logger: hclog.Default()}\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tLogger:          logger,\n\t})\n\n\t// Grab the client so the process starts\n\tif _, err := c.Client(); err != nil {\n\t\tc.Kill()\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Kill it gracefully\n\tc.Kill()\n\n\t// Test for the file\n\tif _, err := os.Stat(path); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tassertLines(t, logger.errorLogs, 0)\n}\n\nfunc TestClient_noStdoutScannerRace(t *testing.T) {\n\tt.Parallel()\n\n\tprocess := helperProcess(\"test-grpc\")\n\tlogger := &trackingLogger{Logger: hclog.Default()}\n\tc := NewClient(&ClientConfig{\n\t\tRunnerFunc: func(l hclog.Logger, cmd *exec.Cmd, tmpDir string) (runner.Runner, error) {\n\t\t\tprocess.Env = append(process.Env, cmd.Env...)\n\t\t\tconcreteRunner, err := cmdrunner.NewCmdRunner(l, process)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// Inject a delay before calling .Read() method on the command's\n\t\t\t// stdout reader. This ensures that if there is a race between the\n\t\t\t// stdout scanner loop reading stdout and runner.Wait() closing\n\t\t\t// stdout, .Wait() will win and trigger a scanner error in the logs.\n\t\t\treturn &delayedStdoutCmdRunner{concreteRunner}, nil\n\t\t},\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t\tLogger:           logger,\n\t})\n\n\t// Grab the client so the process starts\n\tif _, err := c.Client(); err != nil {\n\t\tc.Kill()\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Kill it gracefully\n\tc.Kill()\n\n\tassertLines(t, logger.errorLogs, 0)\n}\n\ntype delayedStdoutCmdRunner struct {\n\t*cmdrunner.CmdRunner\n}\n\nfunc (m *delayedStdoutCmdRunner) Stdout() io.ReadCloser {\n\treturn &delayedReader{m.CmdRunner.Stdout()}\n}\n\ntype delayedReader struct {\n\tio.ReadCloser\n}\n\nfunc (d *delayedReader) Read(p []byte) (n int, err error) {\n\ttime.Sleep(100 * time.Millisecond)\n\treturn d.ReadCloser.Read(p)\n}\n\nfunc TestClient_testInterface(t *testing.T) {\n\tprocess := helperProcess(\"test-interface\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_grpc_servercrash(t *testing.T) {\n\tprocess := helperProcess(\"test-grpc\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif v := c.Protocol(); v != ProtocolGRPC {\n\t\tt.Fatalf(\"bad: %s\", v)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t_, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tc.runner.Kill(context.Background())\n\n\tselect {\n\tcase <-c.doneCtx.Done():\n\tcase <-time.After(time.Second * 2):\n\t\tt.Fatal(\"Context was not closed\")\n\t}\n}\n\nfunc TestClient_grpc(t *testing.T) {\n\tprocess := helperProcess(\"test-grpc\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif v := c.Protocol(); v != ProtocolGRPC {\n\t\tt.Fatalf(\"bad: %s\", v)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_grpcNotAllowed(t *testing.T) {\n\tprocess := helperProcess(\"test-grpc\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err == nil {\n\t\tt.Fatal(\"should error\")\n\t}\n}\n\nfunc TestClient_grpcSyncStdio(t *testing.T) {\n\tfor name, tc := range map[string]struct {\n\t\tuseRunnerFunc bool\n\t}{\n\t\t\"default\":        {false},\n\t\t\"use RunnerFunc\": {true},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\ttestClient_grpcSyncStdio(t, tc.useRunnerFunc)\n\t\t})\n\t}\n}\n\nfunc testClient_grpcSyncStdio(t *testing.T, useRunnerFunc bool) {\n\tvar syncOut, syncErr safeBuffer\n\n\tprocess := helperProcess(\"test-grpc\")\n\tcfg := &ClientConfig{\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t\tSyncStdout:       &syncOut,\n\t\tSyncStderr:       &syncErr,\n\t}\n\n\tif useRunnerFunc {\n\t\tcfg.RunnerFunc = func(l hclog.Logger, cmd *exec.Cmd, _ string) (runner.Runner, error) {\n\t\t\tprocess.Env = append(process.Env, cmd.Env...)\n\t\t\treturn cmdrunner.NewCmdRunner(l, process)\n\t\t}\n\t} else {\n\t\tcfg.Cmd = process\n\t}\n\tc := NewClient(cfg)\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif v := c.Protocol(); v != ProtocolGRPC {\n\t\tt.Fatalf(\"bad: %s\", v)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\t// Check reattach config is sensible.\n\treattach := c.ReattachConfig()\n\tif useRunnerFunc {\n\t\tif reattach.Pid != 0 {\n\t\t\tt.Fatal(reattach.Pid)\n\t\t}\n\t} else {\n\t\tif reattach.Pid == 0 {\n\t\t\tt.Fatal(reattach.Pid)\n\t\t}\n\t}\n\n\t// Print the data\n\tstdout := []byte(\"hello\\nworld!\")\n\tstderr := []byte(\"and some error\\n messages!\")\n\timpl.PrintStdio(stdout, stderr)\n\n\t// Wait for it to be copied\n\tfor syncOut.String() == \"\" || syncErr.String() == \"\" {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\t// We should get the data\n\tif syncOut.String() != string(stdout) {\n\t\tt.Fatalf(\"stdout didn't match: %s\", syncOut.String())\n\t}\n\tif syncErr.String() != string(stderr) {\n\t\tt.Fatalf(\"stderr didn't match: %s\", syncErr.String())\n\t}\n}\n\nfunc TestClient_cmdAndReattach(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tCmd:      helperProcess(\"start-timeout\"),\n\t\tReattach: &ReattachConfig{},\n\t}\n\n\tc := NewClient(config)\n\tdefer c.Kill()\n\n\t_, err := c.Start()\n\tif err == nil {\n\t\tt.Fatal(\"err should not be nil\")\n\t}\n}\n\nfunc TestClient_reattach(t *testing.T) {\n\tprocess := helperProcess(\"test-interface\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\t_, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Get the reattach configuration\n\treattach := c.ReattachConfig()\n\n\t// Create a new client\n\tc = NewClient(&ClientConfig{\n\t\tReattach:        reattach,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_reattachNoProtocol(t *testing.T) {\n\tprocess := helperProcess(\"test-interface\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\t_, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Get the reattach configuration\n\treattach := c.ReattachConfig()\n\treattach.Protocol = \"\"\n\n\t// Create a new client\n\tc = NewClient(&ClientConfig{\n\t\tReattach:        reattach,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_reattachGRPC(t *testing.T) {\n\tfor name, tc := range map[string]struct {\n\t\tuseReattachFunc bool\n\t}{\n\t\t\"default\":          {false},\n\t\t\"use ReattachFunc\": {true},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\ttestClient_reattachGRPC(t, tc.useReattachFunc)\n\t\t})\n\t}\n}\n\nfunc testClient_reattachGRPC(t *testing.T, useReattachFunc bool) {\n\tprocess := helperProcess(\"test-grpc\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\t_, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Get the reattach configuration\n\treattach := c.ReattachConfig()\n\n\tif useReattachFunc {\n\t\tpid := reattach.Pid\n\t\treattach.Pid = 0\n\t\treattach.ReattachFunc = cmdrunner.ReattachFunc(pid, reattach.Addr)\n\t}\n\n\t// Create a new client\n\tc = NewClient(&ClientConfig{\n\t\tReattach:         reattach,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_reattachNotFound(t *testing.T) {\n\t// Find a bad pid\n\tvar pid int = 5000\n\tfor i := pid; i < 32000; i++ {\n\t\tif _, err := os.FindProcess(i); err != nil {\n\t\t\tpid = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Addr that won't work\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\taddr := l.Addr()\n\tl.Close()\n\n\t// Reattach\n\tc := NewClient(&ClientConfig{\n\t\tReattach: &ReattachConfig{\n\t\t\tAddr: addr,\n\t\t\tPid:  pid,\n\t\t},\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\n\tif _, err := c.Start(); err == nil {\n\t\tt.Fatal(\"should error\")\n\t} else if err != ErrProcessNotFound {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n}\n\nfunc TestClientStart_badVersion(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tCmd:             helperProcess(\"bad-version\"),\n\t\tStartTimeout:    50 * time.Millisecond,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t}\n\n\tc := NewClient(config)\n\tdefer c.Kill()\n\n\t_, err := c.Start()\n\tif err == nil {\n\t\tt.Fatal(\"err should not be nil\")\n\t}\n}\n\nfunc TestClientStart_badNegotiatedVersion(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tCmd:          helperProcess(\"test-versioned-plugins\"),\n\t\tStartTimeout: 50 * time.Millisecond,\n\t\t// test-versioned-plugins only has version 2\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t}\n\n\tc := NewClient(config)\n\tdefer c.Kill()\n\n\t_, err := c.Start()\n\tif err == nil {\n\t\tt.Fatal(\"err should not be nil\")\n\t}\n\tfmt.Println(err)\n}\n\nfunc TestClient_Start_Timeout(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tCmd:             helperProcess(\"start-timeout\"),\n\t\tStartTimeout:    50 * time.Millisecond,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t}\n\n\tc := NewClient(config)\n\tdefer c.Kill()\n\n\t_, err := c.Start()\n\tif err == nil {\n\t\tt.Fatal(\"err should not be nil\")\n\t}\n}\n\nfunc TestClient_Stderr(t *testing.T) {\n\tstderr := new(bytes.Buffer)\n\tprocess := helperProcess(\"stderr\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tStderr:          stderr,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tfor !c.Exited() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n\n\tif !strings.Contains(stderr.String(), \"HELLO\\n\") {\n\t\tt.Fatalf(\"bad log data: '%s'\", stderr.String())\n\t}\n\n\tif !strings.Contains(stderr.String(), \"WORLD\\n\") {\n\t\tt.Fatalf(\"bad log data: '%s'\", stderr.String())\n\t}\n}\n\nfunc TestClient_StderrJSON(t *testing.T) {\n\tstderr := new(bytes.Buffer)\n\tprocess := helperProcess(\"stderr-json\")\n\n\tvar logBuf bytes.Buffer\n\tmutex := new(sync.Mutex)\n\t// Custom hclog.Logger\n\ttestLogger := hclog.New(&hclog.LoggerOptions{\n\t\tName:   \"test-logger\",\n\t\tLevel:  hclog.Trace,\n\t\tOutput: &logBuf,\n\t\tMutex:  mutex,\n\t})\n\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tStderr:          stderr,\n\t\tHandshakeConfig: testHandshake,\n\t\tLogger:          testLogger,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tfor !c.Exited() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n\n\tlogOut := logBuf.String()\n\n\tif !strings.Contains(logOut, \"[\\\"HELLO\\\"]\\n\") {\n\t\tt.Fatalf(\"missing json list: '%s'\", logOut)\n\t}\n\n\tif !strings.Contains(logOut, \"12345\\n\") {\n\t\tt.Fatalf(\"missing line with raw number: '%s'\", logOut)\n\t}\n\n\tif !strings.Contains(logOut, \"{\\\"a\\\":1}\") {\n\t\tt.Fatalf(\"missing json object: '%s'\", logOut)\n\t}\n}\n\nfunc TestClient_textLogLevel(t *testing.T) {\n\tstderr := new(bytes.Buffer)\n\tprocess := helperProcess(\"level-warn-text\")\n\n\tvar logBuf bytes.Buffer\n\tmutex := new(sync.Mutex)\n\t// Custom hclog.Logger\n\ttestLogger := hclog.New(&hclog.LoggerOptions{\n\t\tName:   \"test-logger\",\n\t\tLevel:  hclog.Warn,\n\t\tOutput: &logBuf,\n\t\tMutex:  mutex,\n\t})\n\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tStderr:          stderr,\n\t\tHandshakeConfig: testHandshake,\n\t\tLogger:          testLogger,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tfor !c.Exited() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n\n\tlogOut := logBuf.String()\n\n\tif !strings.Contains(logOut, \"test line 98765\") {\n\t\tlog.Fatalf(\"test string not found in log: %q\\n\", logOut)\n\t}\n}\n\nfunc TestClient_Stdin(t *testing.T) {\n\t// Overwrite stdin for this test with a temporary file\n\ttf, err := os.CreateTemp(\"\", \"terraform\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tdefer os.Remove(tf.Name())\n\tdefer tf.Close()\n\n\tif _, err = tf.WriteString(\"hello\"); err != nil {\n\t\tt.Fatalf(\"error: %s\", err)\n\t}\n\n\tif err = tf.Sync(); err != nil {\n\t\tt.Fatalf(\"error: %s\", err)\n\t}\n\n\tif _, err = tf.Seek(0, 0); err != nil {\n\t\tt.Fatalf(\"error: %s\", err)\n\t}\n\n\toldStdin := os.Stdin\n\tdefer func() { os.Stdin = oldStdin }()\n\tos.Stdin = tf\n\n\tprocess := helperProcess(\"stdin\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\t_, err = c.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"error: %s\", err)\n\t}\n\n\tfor {\n\t\tif c.Exited() {\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\n\tif !process.ProcessState.Success() {\n\t\tt.Fatal(\"process didn't exit cleanly\")\n\t}\n}\n\nfunc TestClient_SkipHostEnv(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\thelper string\n\t\tskip   bool\n\t}{\n\t\t{\"test-skip-host-env-true\", true},\n\t\t{\"test-skip-host-env-false\", false},\n\t} {\n\t\tt.Run(tc.helper, func(t *testing.T) {\n\t\t\tprocess := helperProcess(tc.helper)\n\t\t\t// Set env in the host process, which we'll look for in the plugin.\n\t\t\tt.Setenv(\"PLUGIN_TEST_SKIP_HOST_ENV\", \"foo\")\n\t\t\tc := NewClient(&ClientConfig{\n\t\t\t\tCmd:             process,\n\t\t\t\tHandshakeConfig: testHandshake,\n\t\t\t\tPlugins:         testPluginMap,\n\t\t\t\tSkipHostEnv:     tc.skip,\n\t\t\t})\n\t\t\tdefer c.Kill()\n\n\t\t\t_, err := c.Start()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error: %s\", err)\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\tif c.Exited() {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t}\n\n\t\t\tif !process.ProcessState.Success() {\n\t\t\t\tt.Fatal(\"process didn't exit cleanly\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestClient_RequestGRPCMultiplexing_UnsupportedByPlugin(t *testing.T) {\n\tfor _, name := range []string{\n\t\t\"mux-grpc-with-old-plugin\",\n\t\t\"mux-grpc-with-unsupported-plugin\",\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tprocess := helperProcess(name)\n\t\t\tc := NewClient(&ClientConfig{\n\t\t\t\tCmd:                 process,\n\t\t\t\tHandshakeConfig:     testHandshake,\n\t\t\t\tPlugins:             testGRPCPluginMap,\n\t\t\t\tAllowedProtocols:    []Protocol{ProtocolGRPC},\n\t\t\t\tGRPCBrokerMultiplex: true,\n\t\t\t})\n\t\t\tdefer c.Kill()\n\n\t\t\t_, err := c.Start()\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\n\t\t\tif !errors.Is(err, ErrGRPCBrokerMuxNotSupported) {\n\t\t\t\tt.Fatalf(\"expected %s, but got %s\", ErrGRPCBrokerMuxNotSupported, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestClient_SecureConfig(t *testing.T) {\n\t// Test failure case\n\tsecureConfig := &SecureConfig{\n\t\tChecksum: []byte{'1'},\n\t\tHash:     sha256.New(),\n\t}\n\tprocess := helperProcess(\"test-interface\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tSecureConfig:    secureConfig,\n\t})\n\n\t// Grab the RPC client, should error\n\t_, err := c.Client()\n\tc.Kill()\n\tif err != ErrChecksumsDoNotMatch {\n\t\tt.Fatalf(\"err should be %s, got %s\", ErrChecksumsDoNotMatch, err)\n\t}\n\n\t// Get the checksum of the executable\n\tfile, err := os.Open(os.Args[0])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\thash := sha256.New()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsum := hash.Sum(nil)\n\n\tsecureConfig = &SecureConfig{\n\t\tChecksum: sum,\n\t\tHash:     sha256.New(),\n\t}\n\n\tprocess = helperProcess(\"test-interface\")\n\tc = NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tSecureConfig:    secureConfig,\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\t_, err = c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n}\n\nfunc TestClient_TLS(t *testing.T) {\n\t// Test failure case\n\tprocess := helperProcess(\"test-interface-tls\")\n\tcBad := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer cBad.Kill()\n\n\t// Grab the RPC client\n\tclientBad, err := cBad.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := clientBad.Dispense(\"test\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error, got nil\")\n\t}\n\n\tcBad.Kill()\n\n\t// Add TLS config to client\n\ttlsConfig, err := helperTLSProvider()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\tprocess = helperProcess(\"test-interface-tls\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tTLSConfig:       tlsConfig,\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err = client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_TLS_grpc(t *testing.T) {\n\t// Add TLS config to client\n\ttlsConfig, err := helperTLSProvider()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\tprocess := helperProcess(\"test-grpc-tls\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tTLSConfig:        tlsConfig,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\nfunc TestClient_secureConfigAndReattach(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tSecureConfig: &SecureConfig{},\n\t\tReattach:     &ReattachConfig{},\n\t}\n\n\tc := NewClient(config)\n\tdefer c.Kill()\n\n\t_, err := c.Start()\n\tif err != ErrSecureConfigAndReattach {\n\t\tt.Fatalf(\"err should not be %s, got %s\", ErrSecureConfigAndReattach, err)\n\t}\n}\n\nfunc TestClient_ping(t *testing.T) {\n\tprocess := helperProcess(\"test-interface\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t})\n\tdefer c.Kill()\n\n\t// Get the client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Ping, should work\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Kill it\n\tc.Kill()\n\tif err := client.Ping(); err == nil {\n\t\tt.Fatal(\"should error\")\n\t}\n}\n\nfunc TestClient_wrongVersion(t *testing.T) {\n\tprocess := helperProcess(\"test-proto-upgraded-plugin\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\t// Get the client\n\t_, err := c.Client()\n\tif err == nil {\n\t\tt.Fatal(\"expected incorrect protocol version server\")\n\t}\n\n}\n\nfunc TestClient_legacyClient(t *testing.T) {\n\tprocess := helperProcess(\"test-proto-upgraded-plugin\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t1: testPluginMap,\n\t\t},\n\t})\n\tdefer c.Kill()\n\n\t// Get the client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif c.NegotiatedVersion() != 1 {\n\t\tt.Fatal(\"using incorrect version\", c.NegotiatedVersion())\n\t}\n\n\t// Ping, should work\n\tif err := client.Ping(); err == nil {\n\t\tt.Fatal(\"expected error, should negotiate wrong plugin\")\n\t}\n}\n\nfunc TestClient_legacyServer(t *testing.T) {\n\t// test using versioned plugins version when the server supports only\n\t// supports one\n\tprocess := helperProcess(\"test-proto-upgraded-client\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\t// Get the client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif c.NegotiatedVersion() != 2 {\n\t\tt.Fatal(\"using incorrect version\", c.NegotiatedVersion())\n\t}\n\n\t// Ping, should work\n\tif err := client.Ping(); err == nil {\n\t\tt.Fatal(\"expected error, should negotiate wrong plugin\")\n\t}\n}\n\nfunc TestClient_versionedClient(t *testing.T) {\n\tprocess := helperProcess(\"test-versioned-plugins\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif v := c.Protocol(); v != ProtocolGRPC {\n\t\tt.Fatalf(\"bad: %s\", v)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\tif c.NegotiatedVersion() != 2 {\n\t\tt.Fatal(\"using incorrect version\", c.NegotiatedVersion())\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t_, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tc.runner.Kill(context.Background())\n\n\tselect {\n\tcase <-c.doneCtx.Done():\n\tcase <-time.After(time.Second * 2):\n\t\tt.Fatal(\"Context was not closed\")\n\t}\n}\n\nfunc TestClient_mtlsClient(t *testing.T) {\n\tprocess := helperProcess(\"test-mtls\")\n\tc := NewClient(&ClientConfig{\n\t\tAutoMTLS:        true,\n\t\tCmd:             process,\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tif v := c.Protocol(); v != ProtocolGRPC {\n\t\tt.Fatalf(\"bad: %s\", v)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\tif c.NegotiatedVersion() != 2 {\n\t\tt.Fatal(\"using incorrect version\", c.NegotiatedVersion())\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\ttester, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tn := tester.Double(3)\n\tif n != 6 {\n\t\tt.Fatal(\"invalid response\", n)\n\t}\n\n\tc.runner.Kill(context.Background())\n\n\tselect {\n\tcase <-c.doneCtx.Done():\n\tcase <-time.After(time.Second * 2):\n\t\tt.Fatal(\"Context was not closed\")\n\t}\n}\n\nfunc TestClient_mtlsNetRPCClient(t *testing.T) {\n\tprocess := helperProcess(\"test-interface-mtls\")\n\tc := NewClient(&ClientConfig{\n\t\tAutoMTLS:         true,\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testVersionedHandshake,\n\t\tPlugins:          testPluginMap,\n\t\tAllowedProtocols: []Protocol{ProtocolNetRPC},\n\t})\n\tdefer c.Kill()\n\n\tif _, err := c.Start(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\ttester, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tn := tester.Double(3)\n\tif n != 6 {\n\t\tt.Fatal(\"invalid response\", n)\n\t}\n\n\tc.runner.Kill(context.Background())\n\n\tselect {\n\tcase <-c.doneCtx.Done():\n\tcase <-time.After(time.Second * 2):\n\t\tt.Fatal(\"Context was not closed\")\n\t}\n}\n\nfunc TestClient_logger(t *testing.T) {\n\tt.Run(\"net/rpc\", func(t *testing.T) { testClient_logger(t, \"netrpc\") })\n\tt.Run(\"grpc\", func(t *testing.T) { testClient_logger(t, \"grpc\") })\n}\n\nfunc testClient_logger(t *testing.T, proto string) {\n\tvar buffer bytes.Buffer\n\tmutex := new(sync.Mutex)\n\tstderr := io.MultiWriter(os.Stderr, &buffer)\n\t// Custom hclog.Logger\n\tclientLogger := hclog.New(&hclog.LoggerOptions{\n\t\tName:   \"test-logger\",\n\t\tLevel:  hclog.Trace,\n\t\tOutput: stderr,\n\t\tMutex:  mutex,\n\t})\n\n\tprocess := helperProcess(\"test-interface-logger-\" + proto)\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              process,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tLogger:           clientLogger,\n\t\tAllowedProtocols: []Protocol{ProtocolNetRPC, ProtocolGRPC},\n\t})\n\tdefer c.Kill()\n\n\t// Grab the RPC client\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\t{\n\t\t// Discard everything else, and capture the output we care about\n\t\tmutex.Lock()\n\t\tbuffer.Reset()\n\t\tmutex.Unlock()\n\t\timpl.PrintKV(\"foo\", \"bar\")\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tmutex.Lock()\n\t\tline, err := buffer.ReadString('\\n')\n\t\tmutex.Unlock()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !strings.Contains(line, \"foo=bar\") {\n\t\t\tt.Fatalf(\"bad: %q\", line)\n\t\t}\n\t}\n\n\t{\n\t\t// Try an integer type\n\t\tmutex.Lock()\n\t\tbuffer.Reset()\n\t\tmutex.Unlock()\n\t\timpl.PrintKV(\"foo\", 12)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tmutex.Lock()\n\t\tline, err := buffer.ReadString('\\n')\n\t\tmutex.Unlock()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !strings.Contains(line, \"foo=12\") {\n\t\t\tt.Fatalf(\"bad: %q\", line)\n\t\t}\n\t}\n\n\t// Kill it\n\tc.Kill()\n\n\t// Test that it knows it is exited\n\tif !c.Exited() {\n\t\tt.Fatal(\"should say client has exited\")\n\t}\n\n\tif c.killed() {\n\t\tt.Fatal(\"process failed to exit gracefully\")\n\t}\n}\n\n// Test that we continue to consume stderr over long lines.\nfunc TestClient_logStderr(t *testing.T) {\n\tstderr := bytes.Buffer{}\n\tc := NewClient(&ClientConfig{\n\t\tStderr: &stderr,\n\t\tCmd: &exec.Cmd{\n\t\t\tPath: \"test\",\n\t\t},\n\t\tPluginLogBufferSize: 32,\n\t})\n\tc.clientWaitGroup.Add(1)\n\n\tmsg := `\nthis line is more than 32 bytes long\nand this line is more than 32 bytes long\n{\"a\": \"b\", \"@level\": \"debug\"}\nthis line is short\n`\n\n\treader := strings.NewReader(msg)\n\n\tc.pipesWaitGroup.Add(1)\n\tc.logStderr(c.config.Cmd.Path, reader)\n\tread := stderr.String()\n\n\tif read != msg {\n\t\tt.Fatalf(\"\\nexpected output: %q\\ngot output:      %q\", msg, read)\n\t}\n}\n\nfunc TestClient_logStderrParseJSON(t *testing.T) {\n\tlogBuf := bytes.Buffer{}\n\tc := NewClient(&ClientConfig{\n\t\tStderr:              bytes.NewBuffer(nil),\n\t\tCmd:                 &exec.Cmd{Path: \"test\"},\n\t\tPluginLogBufferSize: 64,\n\t\tLogger: hclog.New(&hclog.LoggerOptions{\n\t\t\tName:       \"test-logger\",\n\t\t\tLevel:      hclog.Trace,\n\t\t\tOutput:     &logBuf,\n\t\t\tJSONFormat: true,\n\t\t}),\n\t})\n\tc.clientWaitGroup.Add(1)\n\n\tmsg := `{\"@message\": \"this is a message\", \"@level\": \"info\"}\n{\"@message\": \"this is a large message that is more than 64 bytes long\", \"@level\": \"info\"}`\n\treader := strings.NewReader(msg)\n\n\tc.pipesWaitGroup.Add(1)\n\tc.logStderr(c.config.Cmd.Path, reader)\n\tlogs := strings.Split(strings.TrimSpace(logBuf.String()), \"\\n\")\n\n\twants := []struct {\n\t\twantLevel   string\n\t\twantMessage string\n\t}{\n\t\t{\"info\", \"this is a message\"},\n\t\t{\"debug\", `{\"@message\": \"this is a large message that is more than 64 bytes`},\n\t\t{\"debug\", ` long\", \"@level\": \"info\"}`},\n\t}\n\n\tif len(logs) != len(wants) {\n\t\tt.Fatalf(\"expected %d logs, got %d\", len(wants), len(logs))\n\t}\n\n\tfor i, tt := range wants {\n\t\tl := make(map[string]interface{})\n\t\tif err := json.Unmarshal([]byte(logs[i]), &l); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif l[\"@level\"] != tt.wantLevel {\n\t\t\tt.Fatalf(\"expected level %q, got %q\", tt.wantLevel, l[\"@level\"])\n\t\t}\n\n\t\tif l[\"@message\"] != tt.wantMessage {\n\t\t\tt.Fatalf(\"expected message %q, got %q\", tt.wantMessage, l[\"@message\"])\n\t\t}\n\t}\n}\n\ntype trackingLogger struct {\n\thclog.Logger\n\terrorLogs []string\n}\n\nfunc (l *trackingLogger) Error(msg string, args ...interface{}) {\n\tl.errorLogs = append(l.errorLogs, fmt.Sprintf(\"%s: %v\", msg, args))\n\tl.Logger.Error(msg, args...)\n}\n\nfunc assertLines(t *testing.T, lines []string, expected int) {\n\tt.Helper()\n\tif len(lines) != expected {\n\t\tt.Errorf(\"expected %d, got %d\", expected, len(lines))\n\t\tfor _, log := range lines {\n\t\t\tt.Error(log)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "client_unix_test.go",
          "type": "blob",
          "size": 2.783203125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\n//go:build !windows\n// +build !windows\n\npackage plugin\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/cmdrunner\"\n\t\"github.com/hashicorp/go-plugin/runner\"\n)\n\nfunc TestSetGroup(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"go-plugin doesn't support unix sockets on Windows\")\n\t}\n\n\tgroup, err := user.LookupGroupId(fmt.Sprintf(\"%d\", os.Getgid()))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbaseTempDir := t.TempDir()\n\tbaseTempDir, err = filepath.EvalSymlinks(baseTempDir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor name, tc := range map[string]struct {\n\t\tgroup string\n\t}{\n\t\t\"as integer\": {fmt.Sprintf(\"%d\", os.Getgid())},\n\t\t\"as name\":    {group.Name},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tprocess := helperProcess(\"mock\")\n\t\t\tc := NewClient(&ClientConfig{\n\t\t\t\tHandshakeConfig: testHandshake,\n\t\t\t\tPlugins:         testPluginMap,\n\t\t\t\tUnixSocketConfig: &UnixSocketConfig{\n\t\t\t\t\tGroup:   tc.group,\n\t\t\t\t\tTempDir: baseTempDir,\n\t\t\t\t},\n\t\t\t\tRunnerFunc: func(l hclog.Logger, cmd *exec.Cmd, tmpDir string) (runner.Runner, error) {\n\t\t\t\t\t// Run tests inside the RunnerFunc to ensure we don't race\n\t\t\t\t\t// with the code that deletes tmpDir when the client fails\n\t\t\t\t\t// to start properly.\n\n\t\t\t\t\t// Test that it creates a directory with the proper owners and permissions.\n\t\t\t\t\tif filepath.Dir(tmpDir) != baseTempDir {\n\t\t\t\t\t\tt.Errorf(\"Expected base TempDir to be %s, but tmpDir was %s\", baseTempDir, tmpDir)\n\t\t\t\t\t}\n\t\t\t\t\tinfo, err := os.Lstat(tmpDir)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t\tif info.Mode()&os.ModePerm != 0o770 {\n\t\t\t\t\t\tt.Fatal(info.Mode())\n\t\t\t\t\t}\n\t\t\t\t\tstat, ok := info.Sys().(*syscall.Stat_t)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tt.Fatal()\n\t\t\t\t\t}\n\t\t\t\t\tif stat.Gid != uint32(os.Getgid()) {\n\t\t\t\t\t\tt.Fatalf(\"Expected %d, but got %d\", os.Getgid(), stat.Gid)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the correct environment variables were set to forward\n\t\t\t\t\t// Unix socket config onto the plugin.\n\t\t\t\t\tvar foundUnixSocketDir, foundUnixSocketGroup bool\n\t\t\t\t\tfor _, env := range cmd.Env {\n\t\t\t\t\t\tif env == fmt.Sprintf(\"%s=%s\", EnvUnixSocketDir, tmpDir) {\n\t\t\t\t\t\t\tfoundUnixSocketDir = true\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif env == fmt.Sprintf(\"%s=%s\", EnvUnixSocketGroup, tc.group) {\n\t\t\t\t\t\t\tfoundUnixSocketGroup = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !foundUnixSocketDir {\n\t\t\t\t\t\tt.Errorf(\"Did not find correct %s env in %v\", EnvUnixSocketDir, cmd.Env)\n\t\t\t\t\t}\n\t\t\t\t\tif !foundUnixSocketGroup {\n\t\t\t\t\t\tt.Errorf(\"Did not find correct %s env in %v\", EnvUnixSocketGroup, cmd.Env)\n\t\t\t\t\t}\n\n\t\t\t\t\tprocess.Env = append(process.Env, cmd.Env...)\n\t\t\t\t\treturn cmdrunner.NewCmdRunner(l, process)\n\t\t\t\t},\n\t\t\t})\n\t\t\tdefer c.Kill()\n\n\t\t\t_, err := c.Start()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "constants.go",
          "type": "blob",
          "size": 0.4951171875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nconst (\n\t// EnvUnixSocketDir specifies the directory that _plugins_ should create unix\n\t// sockets in. Does not affect client behavior.\n\tEnvUnixSocketDir = \"PLUGIN_UNIX_SOCKET_DIR\"\n\n\t// EnvUnixSocketGroup specifies the owning, writable group to set for Unix\n\t// sockets created by _plugins_. Does not affect client behavior.\n\tEnvUnixSocketGroup = \"PLUGIN_UNIX_SOCKET_GROUP\"\n\n\tenvMultiplexGRPC = \"PLUGIN_MULTIPLEX_GRPC\"\n)\n"
        },
        {
          "name": "discover.go",
          "type": "blob",
          "size": 0.6923828125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"path/filepath\"\n)\n\n// Discover discovers plugins that are in a given directory.\n//\n// The directory doesn't need to be absolute. For example, \".\" will work fine.\n//\n// This currently assumes any file matching the glob is a plugin.\n// In the future this may be smarter about checking that a file is\n// executable and so on.\n//\n// TODO: test\nfunc Discover(glob, dir string) ([]string, error) {\n\tvar err error\n\n\t// Make the directory absolute if it isn't already\n\tif !filepath.IsAbs(dir) {\n\t\tdir, err = filepath.Abs(dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn filepath.Glob(filepath.Join(dir, glob))\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 0.6220703125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\n// This is a type that wraps error types so that they can be messaged\n// across RPC channels. Since \"error\" is an interface, we can't always\n// gob-encode the underlying structure. This is a valid error interface\n// implementer that we will push across.\ntype BasicError struct {\n\tMessage string\n}\n\n// NewBasicError is used to create a BasicError.\n//\n// err is allowed to be nil.\nfunc NewBasicError(err error) *BasicError {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\treturn &BasicError{err.Error()}\n}\n\nfunc (e *BasicError) Error() string {\n\treturn e.Message\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 0.4990234375,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestBasicError_ImplementsError(t *testing.T) {\n\tvar _ error = new(BasicError)\n}\n\nfunc TestBasicError_MatchesMessage(t *testing.T) {\n\terr := errors.New(\"foo\")\n\twrapped := NewBasicError(err)\n\n\tif wrapped.Error() != err.Error() {\n\t\tt.Fatalf(\"bad: %#v\", wrapped.Error())\n\t}\n}\n\nfunc TestNewBasicError_nil(t *testing.T) {\n\tr := NewBasicError(nil)\n\tif r != nil {\n\t\tt.Fatalf(\"bad: %#v\", r)\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.7470703125,
          "content": "module github.com/hashicorp/go-plugin\n\ngo 1.17\n\nrequire (\n\tgithub.com/golang/protobuf v1.5.3\n\tgithub.com/hashicorp/go-hclog v0.14.1\n\tgithub.com/hashicorp/yamux v0.1.1\n\tgithub.com/jhump/protoreflect v1.15.1\n\tgithub.com/oklog/run v1.0.0\n\tgoogle.golang.org/grpc v1.58.3\n\tgoogle.golang.org/protobuf v1.31.0\n)\n\nrequire (\n\tgithub.com/bufbuild/protocompile v0.4.0 // indirect\n\tgithub.com/fatih/color v1.7.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.4 // indirect\n\tgithub.com/mattn/go-isatty v0.0.17 // indirect\n\tgithub.com/stretchr/testify v1.8.3 // indirect\n\tgolang.org/x/net v0.17.0 // indirect\n\tgolang.org/x/sys v0.13.0 // indirect\n\tgolang.org/x/text v0.13.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 168.953125,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.44.3/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=\ncloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=\ncloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=\ncloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=\ncloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=\ncloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=\ncloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=\ncloud.google.com/go v0.78.0/go.mod h1:QjdrLG0uq+YwhjoVOLsS1t7TW8fs36kLs4XO5R5ECHg=\ncloud.google.com/go v0.79.0/go.mod h1:3bzgcEeQlzbuEAYu4mrWhKqWjmpprinYgKJLgKHnbb8=\ncloud.google.com/go v0.81.0/go.mod h1:mk/AM35KwGk/Nm2YSeZbxXdrNK3KZOYHmLkOqC2V6E0=\ncloud.google.com/go v0.83.0/go.mod h1:Z7MJUsANfY0pYPdw0lbnivPx4/vhy/e2FEkSkF7vAVY=\ncloud.google.com/go v0.84.0/go.mod h1:RazrYuxIK6Kb7YrzzhPoLmCVzl7Sup4NrbKPg8KHSUM=\ncloud.google.com/go v0.87.0/go.mod h1:TpDYlFy7vuLzZMMZ+B6iRiELaY7z/gJPaqbMx6mlWcY=\ncloud.google.com/go v0.90.0/go.mod h1:kRX0mNRHe0e2rC6oNakvwQqzyDmg57xJ+SZU1eT2aDQ=\ncloud.google.com/go v0.93.3/go.mod h1:8utlLll2EF5XMAV15woO4lSbWQlk8rer9aLOfLh7+YI=\ncloud.google.com/go v0.94.1/go.mod h1:qAlAugsXlC+JWO+Bke5vCtc9ONxjQT3drlTTnAplMW4=\ncloud.google.com/go v0.97.0/go.mod h1:GF7l59pYBVlXQIBLx3a761cZ41F9bBH3JUlihCt2Udc=\ncloud.google.com/go v0.99.0/go.mod h1:w0Xx2nLzqWJPuozYQX+hFfCSI8WioryfRDzkoI/Y2ZA=\ncloud.google.com/go v0.100.1/go.mod h1:fs4QogzfH5n2pBXBP9vRiU+eCny7lD2vmFZy79Iuw1U=\ncloud.google.com/go v0.100.2/go.mod h1:4Xra9TjzAeYHrl5+oeLlzbM2k3mjVhZh4UqTZ//w99A=\ncloud.google.com/go v0.102.0/go.mod h1:oWcCzKlqJ5zgHQt9YsaeTY9KzIvjyy0ArmiBUgpQ+nc=\ncloud.google.com/go v0.102.1/go.mod h1:XZ77E9qnTEnrgEOvr4xzfdX5TRo7fB4T2F4O6+34hIU=\ncloud.google.com/go v0.104.0/go.mod h1:OO6xxXdJyvuJPcEPBLN9BJPD+jep5G1+2U5B5gkRYtA=\ncloud.google.com/go v0.105.0/go.mod h1:PrLgOJNe5nfE9UMxKxgXj4mD3voiP+YQ6gdt6KMFOKM=\ncloud.google.com/go v0.107.0/go.mod h1:wpc2eNrD7hXUTy8EKS10jkxpZBjASrORK7goS+3YX2I=\ncloud.google.com/go v0.110.0/go.mod h1:SJnCLqQ0FCFGSZMUNUf84MV3Aia54kn7pi8st7tMzaY=\ncloud.google.com/go v0.110.2/go.mod h1:k04UEeEtb6ZBRTv3dZz4CeJC3jKGxyhl0sAiVVquxiw=\ncloud.google.com/go v0.110.4/go.mod h1:+EYjdK8e5RME/VY/qLCAtuyALQ9q67dvuum8i+H5xsI=\ncloud.google.com/go/accessapproval v1.4.0/go.mod h1:zybIuC3KpDOvotz59lFe5qxRZx6C75OtwbisN56xYB4=\ncloud.google.com/go/accessapproval v1.5.0/go.mod h1:HFy3tuiGvMdcd/u+Cu5b9NkO1pEICJ46IR82PoUdplw=\ncloud.google.com/go/accessapproval v1.6.0/go.mod h1:R0EiYnwV5fsRFiKZkPHr6mwyk2wxUJ30nL4j2pcFY2E=\ncloud.google.com/go/accessapproval v1.7.1/go.mod h1:JYczztsHRMK7NTXb6Xw+dwbs/WnOJxbo/2mTI+Kgg68=\ncloud.google.com/go/accesscontextmanager v1.3.0/go.mod h1:TgCBehyr5gNMz7ZaH9xubp+CE8dkrszb4oK9CWyvD4o=\ncloud.google.com/go/accesscontextmanager v1.4.0/go.mod h1:/Kjh7BBu/Gh83sv+K60vN9QE5NJcd80sU33vIe2IFPE=\ncloud.google.com/go/accesscontextmanager v1.6.0/go.mod h1:8XCvZWfYw3K/ji0iVnp+6pu7huxoQTLmxAbVjbloTtM=\ncloud.google.com/go/accesscontextmanager v1.7.0/go.mod h1:CEGLewx8dwa33aDAZQujl7Dx+uYhS0eay198wB/VumQ=\ncloud.google.com/go/accesscontextmanager v1.8.0/go.mod h1:uI+AI/r1oyWK99NN8cQ3UK76AMelMzgZCvJfsi2c+ps=\ncloud.google.com/go/accesscontextmanager v1.8.1/go.mod h1:JFJHfvuaTC+++1iL1coPiG1eu5D24db2wXCDWDjIrxo=\ncloud.google.com/go/aiplatform v1.22.0/go.mod h1:ig5Nct50bZlzV6NvKaTwmplLLddFx0YReh9WfTO5jKw=\ncloud.google.com/go/aiplatform v1.24.0/go.mod h1:67UUvRBKG6GTayHKV8DBv2RtR1t93YRu5B1P3x99mYY=\ncloud.google.com/go/aiplatform v1.27.0/go.mod h1:Bvxqtl40l0WImSb04d0hXFU7gDOiq9jQmorivIiWcKg=\ncloud.google.com/go/aiplatform v1.35.0/go.mod h1:7MFT/vCaOyZT/4IIFfxH4ErVg/4ku6lKv3w0+tFTgXQ=\ncloud.google.com/go/aiplatform v1.36.1/go.mod h1:WTm12vJRPARNvJ+v6P52RDHCNe4AhvjcIZ/9/RRHy/k=\ncloud.google.com/go/aiplatform v1.37.0/go.mod h1:IU2Cv29Lv9oCn/9LkFiiuKfwrRTq+QQMbW+hPCxJGZw=\ncloud.google.com/go/aiplatform v1.45.0/go.mod h1:Iu2Q7sC7QGhXUeOhAj/oCK9a+ULz1O4AotZiqjQ8MYA=\ncloud.google.com/go/analytics v0.11.0/go.mod h1:DjEWCu41bVbYcKyvlws9Er60YE4a//bK6mnhWvQeFNI=\ncloud.google.com/go/analytics v0.12.0/go.mod h1:gkfj9h6XRf9+TS4bmuhPEShsh3hH8PAZzm/41OOhQd4=\ncloud.google.com/go/analytics v0.17.0/go.mod h1:WXFa3WSym4IZ+JiKmavYdJwGG/CvpqiqczmL59bTD9M=\ncloud.google.com/go/analytics v0.18.0/go.mod h1:ZkeHGQlcIPkw0R/GW+boWHhCOR43xz9RN/jn7WcqfIE=\ncloud.google.com/go/analytics v0.19.0/go.mod h1:k8liqf5/HCnOUkbawNtrWWc+UAzyDlW89doe8TtoDsE=\ncloud.google.com/go/analytics v0.21.2/go.mod h1:U8dcUtmDmjrmUTnnnRnI4m6zKn/yaA5N9RlEkYFHpQo=\ncloud.google.com/go/apigateway v1.3.0/go.mod h1:89Z8Bhpmxu6AmUxuVRg/ECRGReEdiP3vQtk4Z1J9rJk=\ncloud.google.com/go/apigateway v1.4.0/go.mod h1:pHVY9MKGaH9PQ3pJ4YLzoj6U5FUDeDFBllIz7WmzJoc=\ncloud.google.com/go/apigateway v1.5.0/go.mod h1:GpnZR3Q4rR7LVu5951qfXPJCHquZt02jf7xQx7kpqN8=\ncloud.google.com/go/apigateway v1.6.1/go.mod h1:ufAS3wpbRjqfZrzpvLC2oh0MFlpRJm2E/ts25yyqmXA=\ncloud.google.com/go/apigeeconnect v1.3.0/go.mod h1:G/AwXFAKo0gIXkPTVfZDd2qA1TxBXJ3MgMRBQkIi9jc=\ncloud.google.com/go/apigeeconnect v1.4.0/go.mod h1:kV4NwOKqjvt2JYR0AoIWo2QGfoRtn/pkS3QlHp0Ni04=\ncloud.google.com/go/apigeeconnect v1.5.0/go.mod h1:KFaCqvBRU6idyhSNyn3vlHXc8VMDJdRmwDF6JyFRqZ8=\ncloud.google.com/go/apigeeconnect v1.6.1/go.mod h1:C4awq7x0JpLtrlQCr8AzVIzAaYgngRqWf9S5Uhg+wWs=\ncloud.google.com/go/apigeeregistry v0.4.0/go.mod h1:EUG4PGcsZvxOXAdyEghIdXwAEi/4MEaoqLMLDMIwKXY=\ncloud.google.com/go/apigeeregistry v0.5.0/go.mod h1:YR5+s0BVNZfVOUkMa5pAR2xGd0A473vA5M7j247o1wM=\ncloud.google.com/go/apigeeregistry v0.6.0/go.mod h1:BFNzW7yQVLZ3yj0TKcwzb8n25CFBri51GVGOEUcgQsc=\ncloud.google.com/go/apigeeregistry v0.7.1/go.mod h1:1XgyjZye4Mqtw7T9TsY4NW10U7BojBvG4RMD+vRDrIw=\ncloud.google.com/go/apikeys v0.4.0/go.mod h1:XATS/yqZbaBK0HOssf+ALHp8jAlNHUgyfprvNcBIszU=\ncloud.google.com/go/apikeys v0.5.0/go.mod h1:5aQfwY4D+ewMMWScd3hm2en3hCj+BROlyrt3ytS7KLI=\ncloud.google.com/go/apikeys v0.6.0/go.mod h1:kbpXu5upyiAlGkKrJgQl8A0rKNNJ7dQ377pdroRSSi8=\ncloud.google.com/go/appengine v1.4.0/go.mod h1:CS2NhuBuDXM9f+qscZ6V86m1MIIqPj3WC/UoEuR1Sno=\ncloud.google.com/go/appengine v1.5.0/go.mod h1:TfasSozdkFI0zeoxW3PTBLiNqRmzraodCWatWI9Dmak=\ncloud.google.com/go/appengine v1.6.0/go.mod h1:hg6i0J/BD2cKmDJbaFSYHFyZkgBEfQrDg/X0V5fJn84=\ncloud.google.com/go/appengine v1.7.0/go.mod h1:eZqpbHFCqRGa2aCdope7eC0SWLV1j0neb/QnMJVWx6A=\ncloud.google.com/go/appengine v1.7.1/go.mod h1:IHLToyb/3fKutRysUlFO0BPt5j7RiQ45nrzEJmKTo6E=\ncloud.google.com/go/appengine v1.8.1/go.mod h1:6NJXGLVhZCN9aQ/AEDvmfzKEfoYBlfB80/BHiKVputY=\ncloud.google.com/go/area120 v0.5.0/go.mod h1:DE/n4mp+iqVyvxHN41Vf1CR602GiHQjFPusMFW6bGR4=\ncloud.google.com/go/area120 v0.6.0/go.mod h1:39yFJqWVgm0UZqWTOdqkLhjoC7uFfgXRC8g/ZegeAh0=\ncloud.google.com/go/area120 v0.7.0/go.mod h1:a3+8EUD1SX5RUcCs3MY5YasiO1z6yLiNLRiFrykbynY=\ncloud.google.com/go/area120 v0.7.1/go.mod h1:j84i4E1RboTWjKtZVWXPqvK5VHQFJRF2c1Nm69pWm9k=\ncloud.google.com/go/area120 v0.8.1/go.mod h1:BVfZpGpB7KFVNxPiQBuHkX6Ed0rS51xIgmGyjrAfzsg=\ncloud.google.com/go/artifactregistry v1.6.0/go.mod h1:IYt0oBPSAGYj/kprzsBjZ/4LnG/zOcHyFHjWPCi6SAQ=\ncloud.google.com/go/artifactregistry v1.7.0/go.mod h1:mqTOFOnGZx8EtSqK/ZWcsm/4U8B77rbcLP6ruDU2Ixk=\ncloud.google.com/go/artifactregistry v1.8.0/go.mod h1:w3GQXkJX8hiKN0v+at4b0qotwijQbYUqF2GWkZzAhC0=\ncloud.google.com/go/artifactregistry v1.9.0/go.mod h1:2K2RqvA2CYvAeARHRkLDhMDJ3OXy26h3XW+3/Jh2uYc=\ncloud.google.com/go/artifactregistry v1.11.1/go.mod h1:lLYghw+Itq9SONbCa1YWBoWs1nOucMH0pwXN1rOBZFI=\ncloud.google.com/go/artifactregistry v1.11.2/go.mod h1:nLZns771ZGAwVLzTX/7Al6R9ehma4WUEhZGWV6CeQNQ=\ncloud.google.com/go/artifactregistry v1.12.0/go.mod h1:o6P3MIvtzTOnmvGagO9v/rOjjA0HmhJ+/6KAXrmYDCI=\ncloud.google.com/go/artifactregistry v1.13.0/go.mod h1:uy/LNfoOIivepGhooAUpL1i30Hgee3Cu0l4VTWHUC08=\ncloud.google.com/go/artifactregistry v1.14.1/go.mod h1:nxVdG19jTaSTu7yA7+VbWL346r3rIdkZ142BSQqhn5E=\ncloud.google.com/go/asset v1.5.0/go.mod h1:5mfs8UvcM5wHhqtSv8J1CtxxaQq3AdBxxQi2jGW/K4o=\ncloud.google.com/go/asset v1.7.0/go.mod h1:YbENsRK4+xTiL+Ofoj5Ckf+O17kJtgp3Y3nn4uzZz5s=\ncloud.google.com/go/asset v1.8.0/go.mod h1:mUNGKhiqIdbr8X7KNayoYvyc4HbbFO9URsjbytpUaW0=\ncloud.google.com/go/asset v1.9.0/go.mod h1:83MOE6jEJBMqFKadM9NLRcs80Gdw76qGuHn8m3h8oHQ=\ncloud.google.com/go/asset v1.10.0/go.mod h1:pLz7uokL80qKhzKr4xXGvBQXnzHn5evJAEAtZiIb0wY=\ncloud.google.com/go/asset v1.11.1/go.mod h1:fSwLhbRvC9p9CXQHJ3BgFeQNM4c9x10lqlrdEUYXlJo=\ncloud.google.com/go/asset v1.12.0/go.mod h1:h9/sFOa4eDIyKmH6QMpm4eUK3pDojWnUhTgJlk762Hg=\ncloud.google.com/go/asset v1.13.0/go.mod h1:WQAMyYek/b7NBpYq/K4KJWcRqzoalEsxz/t/dTk4THw=\ncloud.google.com/go/asset v1.14.1/go.mod h1:4bEJ3dnHCqWCDbWJ/6Vn7GVI9LerSi7Rfdi03hd+WTQ=\ncloud.google.com/go/assuredworkloads v1.5.0/go.mod h1:n8HOZ6pff6re5KYfBXcFvSViQjDwxFkAkmUFffJRbbY=\ncloud.google.com/go/assuredworkloads v1.6.0/go.mod h1:yo2YOk37Yc89Rsd5QMVECvjaMKymF9OP+QXWlKXUkXw=\ncloud.google.com/go/assuredworkloads v1.7.0/go.mod h1:z/736/oNmtGAyU47reJgGN+KVoYoxeLBoj4XkKYscNI=\ncloud.google.com/go/assuredworkloads v1.8.0/go.mod h1:AsX2cqyNCOvEQC8RMPnoc0yEarXQk6WEKkxYfL6kGIo=\ncloud.google.com/go/assuredworkloads v1.9.0/go.mod h1:kFuI1P78bplYtT77Tb1hi0FMxM0vVpRC7VVoJC3ZoT0=\ncloud.google.com/go/assuredworkloads v1.10.0/go.mod h1:kwdUQuXcedVdsIaKgKTp9t0UJkE5+PAVNhdQm4ZVq2E=\ncloud.google.com/go/assuredworkloads v1.11.1/go.mod h1:+F04I52Pgn5nmPG36CWFtxmav6+7Q+c5QyJoL18Lry0=\ncloud.google.com/go/automl v1.5.0/go.mod h1:34EjfoFGMZ5sgJ9EoLsRtdPSNZLcfflJR39VbVNS2M0=\ncloud.google.com/go/automl v1.6.0/go.mod h1:ugf8a6Fx+zP0D59WLhqgTDsQI9w07o64uf/Is3Nh5p8=\ncloud.google.com/go/automl v1.7.0/go.mod h1:RL9MYCCsJEOmt0Wf3z9uzG0a7adTT1fe+aObgSpkCt8=\ncloud.google.com/go/automl v1.8.0/go.mod h1:xWx7G/aPEe/NP+qzYXktoBSDfjO+vnKMGgsApGJJquM=\ncloud.google.com/go/automl v1.12.0/go.mod h1:tWDcHDp86aMIuHmyvjuKeeHEGq76lD7ZqfGLN6B0NuU=\ncloud.google.com/go/automl v1.13.1/go.mod h1:1aowgAHWYZU27MybSCFiukPO7xnyawv7pt3zK4bheQE=\ncloud.google.com/go/baremetalsolution v0.3.0/go.mod h1:XOrocE+pvK1xFfleEnShBlNAXf+j5blPPxrhjKgnIFc=\ncloud.google.com/go/baremetalsolution v0.4.0/go.mod h1:BymplhAadOO/eBa7KewQ0Ppg4A4Wplbn+PsFKRLo0uI=\ncloud.google.com/go/baremetalsolution v0.5.0/go.mod h1:dXGxEkmR9BMwxhzBhV0AioD0ULBmuLZI8CdwalUxuss=\ncloud.google.com/go/batch v0.3.0/go.mod h1:TR18ZoAekj1GuirsUsR1ZTKN3FC/4UDnScjT8NXImFE=\ncloud.google.com/go/batch v0.4.0/go.mod h1:WZkHnP43R/QCGQsZ+0JyG4i79ranE2u8xvjq/9+STPE=\ncloud.google.com/go/batch v0.7.0/go.mod h1:vLZN95s6teRUqRQ4s3RLDsH8PvboqBK+rn1oevL159g=\ncloud.google.com/go/beyondcorp v0.2.0/go.mod h1:TB7Bd+EEtcw9PCPQhCJtJGjk/7TC6ckmnSFS+xwTfm4=\ncloud.google.com/go/beyondcorp v0.3.0/go.mod h1:E5U5lcrcXMsCuoDNyGrpyTm/hn7ne941Jz2vmksAxW8=\ncloud.google.com/go/beyondcorp v0.4.0/go.mod h1:3ApA0mbhHx6YImmuubf5pyW8srKnCEPON32/5hj+RmM=\ncloud.google.com/go/beyondcorp v0.5.0/go.mod h1:uFqj9X+dSfrheVp7ssLTaRHd2EHqSL4QZmH4e8WXGGU=\ncloud.google.com/go/beyondcorp v0.6.1/go.mod h1:YhxDWw946SCbmcWo3fAhw3V4XZMSpQ/VYfcKGAEU8/4=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=\ncloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=\ncloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=\ncloud.google.com/go/bigquery v1.42.0/go.mod h1:8dRTJxhtG+vwBKzE5OseQn/hiydoQN3EedCaOdYmxRA=\ncloud.google.com/go/bigquery v1.43.0/go.mod h1:ZMQcXHsl+xmU1z36G2jNGZmKp9zNY5BUua5wDgmNCfw=\ncloud.google.com/go/bigquery v1.44.0/go.mod h1:0Y33VqXTEsbamHJvJHdFmtqHvMIY28aK1+dFsvaChGc=\ncloud.google.com/go/bigquery v1.47.0/go.mod h1:sA9XOgy0A8vQK9+MWhEQTY6Tix87M/ZurWFIxmF9I/E=\ncloud.google.com/go/bigquery v1.48.0/go.mod h1:QAwSz+ipNgfL5jxiaK7weyOhzdoAy1zFm0Nf1fysJac=\ncloud.google.com/go/bigquery v1.49.0/go.mod h1:Sv8hMmTFFYBlt/ftw2uN6dFdQPzBlREY9yBh7Oy7/4Q=\ncloud.google.com/go/bigquery v1.50.0/go.mod h1:YrleYEh2pSEbgTBZYMJ5SuSr0ML3ypjRB1zgf7pvQLU=\ncloud.google.com/go/bigquery v1.52.0/go.mod h1:3b/iXjRQGU4nKa87cXeg6/gogLjO8C6PmuM8i5Bi/u4=\ncloud.google.com/go/billing v1.4.0/go.mod h1:g9IdKBEFlItS8bTtlrZdVLWSSdSyFUZKXNS02zKMOZY=\ncloud.google.com/go/billing v1.5.0/go.mod h1:mztb1tBc3QekhjSgmpf/CV4LzWXLzCArwpLmP2Gm88s=\ncloud.google.com/go/billing v1.6.0/go.mod h1:WoXzguj+BeHXPbKfNWkqVtDdzORazmCjraY+vrxcyvI=\ncloud.google.com/go/billing v1.7.0/go.mod h1:q457N3Hbj9lYwwRbnlD7vUpyjq6u5U1RAOArInEiD5Y=\ncloud.google.com/go/billing v1.12.0/go.mod h1:yKrZio/eu+okO/2McZEbch17O5CB5NpZhhXG6Z766ss=\ncloud.google.com/go/billing v1.13.0/go.mod h1:7kB2W9Xf98hP9Sr12KfECgfGclsH3CQR0R08tnRlRbc=\ncloud.google.com/go/billing v1.16.0/go.mod h1:y8vx09JSSJG02k5QxbycNRrN7FGZB6F3CAcgum7jvGA=\ncloud.google.com/go/binaryauthorization v1.1.0/go.mod h1:xwnoWu3Y84jbuHa0zd526MJYmtnVXn0syOjaJgy4+dM=\ncloud.google.com/go/binaryauthorization v1.2.0/go.mod h1:86WKkJHtRcv5ViNABtYMhhNWRrD1Vpi//uKEy7aYEfI=\ncloud.google.com/go/binaryauthorization v1.3.0/go.mod h1:lRZbKgjDIIQvzYQS1p99A7/U1JqvqeZg0wiI5tp6tg0=\ncloud.google.com/go/binaryauthorization v1.4.0/go.mod h1:tsSPQrBd77VLplV70GUhBf/Zm3FsKmgSqgm4UmiDItk=\ncloud.google.com/go/binaryauthorization v1.5.0/go.mod h1:OSe4OU1nN/VswXKRBmciKpo9LulY41gch5c68htf3/Q=\ncloud.google.com/go/binaryauthorization v1.6.1/go.mod h1:TKt4pa8xhowwffiBmbrbcxijJRZED4zrqnwZ1lKH51U=\ncloud.google.com/go/certificatemanager v1.3.0/go.mod h1:n6twGDvcUBFu9uBgt4eYvvf3sQ6My8jADcOVwHmzadg=\ncloud.google.com/go/certificatemanager v1.4.0/go.mod h1:vowpercVFyqs8ABSmrdV+GiFf2H/ch3KyudYQEMM590=\ncloud.google.com/go/certificatemanager v1.6.0/go.mod h1:3Hh64rCKjRAX8dXgRAyOcY5vQ/fE1sh8o+Mdd6KPgY8=\ncloud.google.com/go/certificatemanager v1.7.1/go.mod h1:iW8J3nG6SaRYImIa+wXQ0g8IgoofDFRp5UMzaNk1UqI=\ncloud.google.com/go/channel v1.8.0/go.mod h1:W5SwCXDJsq/rg3tn3oG0LOxpAo6IMxNa09ngphpSlnk=\ncloud.google.com/go/channel v1.9.0/go.mod h1:jcu05W0my9Vx4mt3/rEHpfxc9eKi9XwsdDL8yBMbKUk=\ncloud.google.com/go/channel v1.11.0/go.mod h1:IdtI0uWGqhEeatSB62VOoJ8FSUhJ9/+iGkJVqp74CGE=\ncloud.google.com/go/channel v1.12.0/go.mod h1:VkxCGKASi4Cq7TbXxlaBezonAYpp1GCnKMY6tnMQnLU=\ncloud.google.com/go/channel v1.16.0/go.mod h1:eN/q1PFSl5gyu0dYdmxNXscY/4Fi7ABmeHCJNf/oHmc=\ncloud.google.com/go/cloudbuild v1.3.0/go.mod h1:WequR4ULxlqvMsjDEEEFnOG5ZSRSgWOywXYDb1vPE6U=\ncloud.google.com/go/cloudbuild v1.4.0/go.mod h1:5Qwa40LHiOXmz3386FrjrYM93rM/hdRr7b53sySrTqA=\ncloud.google.com/go/cloudbuild v1.6.0/go.mod h1:UIbc/w9QCbH12xX+ezUsgblrWv+Cv4Tw83GiSMHOn9M=\ncloud.google.com/go/cloudbuild v1.7.0/go.mod h1:zb5tWh2XI6lR9zQmsm1VRA+7OCuve5d8S+zJUul8KTg=\ncloud.google.com/go/cloudbuild v1.9.0/go.mod h1:qK1d7s4QlO0VwfYn5YuClDGg2hfmLZEb4wQGAbIgL1s=\ncloud.google.com/go/cloudbuild v1.10.1/go.mod h1:lyJg7v97SUIPq4RC2sGsz/9tNczhyv2AjML/ci4ulzU=\ncloud.google.com/go/clouddms v1.3.0/go.mod h1:oK6XsCDdW4Ib3jCCBugx+gVjevp2TMXFtgxvPSee3OM=\ncloud.google.com/go/clouddms v1.4.0/go.mod h1:Eh7sUGCC+aKry14O1NRljhjyrr0NFC0G2cjwX0cByRk=\ncloud.google.com/go/clouddms v1.5.0/go.mod h1:QSxQnhikCLUw13iAbffF2CZxAER3xDGNHjsTAkQJcQA=\ncloud.google.com/go/clouddms v1.6.1/go.mod h1:Ygo1vL52Ov4TBZQquhz5fiw2CQ58gvu+PlS6PVXCpZI=\ncloud.google.com/go/cloudtasks v1.5.0/go.mod h1:fD92REy1x5woxkKEkLdvavGnPJGEn8Uic9nWuLzqCpY=\ncloud.google.com/go/cloudtasks v1.6.0/go.mod h1:C6Io+sxuke9/KNRkbQpihnW93SWDU3uXt92nu85HkYI=\ncloud.google.com/go/cloudtasks v1.7.0/go.mod h1:ImsfdYWwlWNJbdgPIIGJWC+gemEGTBK/SunNQQNCAb4=\ncloud.google.com/go/cloudtasks v1.8.0/go.mod h1:gQXUIwCSOI4yPVK7DgTVFiiP0ZW/eQkydWzwVMdHxrI=\ncloud.google.com/go/cloudtasks v1.9.0/go.mod h1:w+EyLsVkLWHcOaqNEyvcKAsWp9p29dL6uL9Nst1cI7Y=\ncloud.google.com/go/cloudtasks v1.10.0/go.mod h1:NDSoTLkZ3+vExFEWu2UJV1arUyzVDAiZtdWcsUyNwBs=\ncloud.google.com/go/cloudtasks v1.11.1/go.mod h1:a9udmnou9KO2iulGscKR0qBYjreuX8oHwpmFsKspEvM=\ncloud.google.com/go/compute v0.1.0/go.mod h1:GAesmwr110a34z04OlxYkATPBEfVhkymfTBXtfbBFow=\ncloud.google.com/go/compute v1.3.0/go.mod h1:cCZiE1NHEtai4wiufUhW8I8S1JKkAnhnQJWM7YD99wM=\ncloud.google.com/go/compute v1.5.0/go.mod h1:9SMHyhJlzhlkJqrPAc839t2BZFTSk6Jdj6mkzQJeu0M=\ncloud.google.com/go/compute v1.6.0/go.mod h1:T29tfhtVbq1wvAPo0E3+7vhgmkOYeXjhFvz/FMzPu0s=\ncloud.google.com/go/compute v1.6.1/go.mod h1:g85FgpzFvNULZ+S8AYq87axRKuf2Kh7deLqV/jJ3thU=\ncloud.google.com/go/compute v1.7.0/go.mod h1:435lt8av5oL9P3fv1OEzSbSUe+ybHXGMPQHHZWZxy9U=\ncloud.google.com/go/compute v1.10.0/go.mod h1:ER5CLbMxl90o2jtNbGSbtfOpQKR0t15FOtRsugnLrlU=\ncloud.google.com/go/compute v1.12.0/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=\ncloud.google.com/go/compute v1.12.1/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=\ncloud.google.com/go/compute v1.13.0/go.mod h1:5aPTS0cUNMIc1CE546K+Th6weJUNQErARyZtRXDJ8GE=\ncloud.google.com/go/compute v1.14.0/go.mod h1:YfLtxrj9sU4Yxv+sXzZkyPjEyPBZfXHUvjxega5vAdo=\ncloud.google.com/go/compute v1.15.1/go.mod h1:bjjoF/NtFUrkD/urWfdHaKuOPDR5nWIs63rR+SXhcpA=\ncloud.google.com/go/compute v1.18.0/go.mod h1:1X7yHxec2Ga+Ss6jPyjxRxpu2uu7PLgsOVXvgU0yacs=\ncloud.google.com/go/compute v1.19.0/go.mod h1:rikpw2y+UMidAe9tISo04EHNOIf42RLYF/q8Bs93scU=\ncloud.google.com/go/compute v1.19.1/go.mod h1:6ylj3a05WF8leseCdIf77NK0g1ey+nj5IKd5/kvShxE=\ncloud.google.com/go/compute v1.19.3/go.mod h1:qxvISKp/gYnXkSAD1ppcSOveRAmzxicEv/JlizULFrI=\ncloud.google.com/go/compute v1.20.1/go.mod h1:4tCnrn48xsqlwSAiLf1HXMQk8CONslYbdiEZc9FEIbM=\ncloud.google.com/go/compute v1.21.0/go.mod h1:4tCnrn48xsqlwSAiLf1HXMQk8CONslYbdiEZc9FEIbM=\ncloud.google.com/go/compute/metadata v0.1.0/go.mod h1:Z1VN+bulIf6bt4P/C37K4DyZYZEXYonfTBHHFPO/4UU=\ncloud.google.com/go/compute/metadata v0.2.0/go.mod h1:zFmK7XCadkQkj6TtorcaGlCW1hT1fIilQDwofLpJ20k=\ncloud.google.com/go/compute/metadata v0.2.1/go.mod h1:jgHgmJd2RKBGzXqF5LR2EZMGxBkeanZ9wwa75XHJgOM=\ncloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=\ncloud.google.com/go/contactcenterinsights v1.3.0/go.mod h1:Eu2oemoePuEFc/xKFPjbTuPSj0fYJcPls9TFlPNnHHY=\ncloud.google.com/go/contactcenterinsights v1.4.0/go.mod h1:L2YzkGbPsv+vMQMCADxJoT9YiTTnSEd6fEvCeHTYVck=\ncloud.google.com/go/contactcenterinsights v1.6.0/go.mod h1:IIDlT6CLcDoyv79kDv8iWxMSTZhLxSCofVV5W6YFM/w=\ncloud.google.com/go/contactcenterinsights v1.9.1/go.mod h1:bsg/R7zGLYMVxFFzfh9ooLTruLRCG9fnzhH9KznHhbM=\ncloud.google.com/go/container v1.6.0/go.mod h1:Xazp7GjJSeUYo688S+6J5V+n/t+G5sKBTFkKNudGRxg=\ncloud.google.com/go/container v1.7.0/go.mod h1:Dp5AHtmothHGX3DwwIHPgq45Y8KmNsgN3amoYfxVkLo=\ncloud.google.com/go/container v1.13.1/go.mod h1:6wgbMPeQRw9rSnKBCAJXnds3Pzj03C4JHamr8asWKy4=\ncloud.google.com/go/container v1.14.0/go.mod h1:3AoJMPhHfLDxLvrlVWaK57IXzaPnLaZq63WX59aQBfM=\ncloud.google.com/go/container v1.15.0/go.mod h1:ft+9S0WGjAyjDggg5S06DXj+fHJICWg8L7isCQe9pQA=\ncloud.google.com/go/container v1.22.1/go.mod h1:lTNExE2R7f+DLbAN+rJiKTisauFCaoDq6NURZ83eVH4=\ncloud.google.com/go/containeranalysis v0.5.1/go.mod h1:1D92jd8gRR/c0fGMlymRgxWD3Qw9C1ff6/T7mLgVL8I=\ncloud.google.com/go/containeranalysis v0.6.0/go.mod h1:HEJoiEIu+lEXM+k7+qLCci0h33lX3ZqoYFdmPcoO7s4=\ncloud.google.com/go/containeranalysis v0.7.0/go.mod h1:9aUL+/vZ55P2CXfuZjS4UjQ9AgXoSw8Ts6lemfmxBxI=\ncloud.google.com/go/containeranalysis v0.9.0/go.mod h1:orbOANbwk5Ejoom+s+DUCTTJ7IBdBQJDcSylAx/on9s=\ncloud.google.com/go/containeranalysis v0.10.1/go.mod h1:Ya2jiILITMY68ZLPaogjmOMNkwsDrWBSTyBubGXO7j0=\ncloud.google.com/go/datacatalog v1.3.0/go.mod h1:g9svFY6tuR+j+hrTw3J2dNcmI0dzmSiyOzm8kpLq0a0=\ncloud.google.com/go/datacatalog v1.5.0/go.mod h1:M7GPLNQeLfWqeIm3iuiruhPzkt65+Bx8dAKvScX8jvs=\ncloud.google.com/go/datacatalog v1.6.0/go.mod h1:+aEyF8JKg+uXcIdAmmaMUmZ3q1b/lKLtXCmXdnc0lbc=\ncloud.google.com/go/datacatalog v1.7.0/go.mod h1:9mEl4AuDYWw81UGc41HonIHH7/sn52H0/tc8f8ZbZIE=\ncloud.google.com/go/datacatalog v1.8.0/go.mod h1:KYuoVOv9BM8EYz/4eMFxrr4DUKhGIOXxZoKYF5wdISM=\ncloud.google.com/go/datacatalog v1.8.1/go.mod h1:RJ58z4rMp3gvETA465Vg+ag8BGgBdnRPEMMSTr5Uv+M=\ncloud.google.com/go/datacatalog v1.12.0/go.mod h1:CWae8rFkfp6LzLumKOnmVh4+Zle4A3NXLzVJ1d1mRm0=\ncloud.google.com/go/datacatalog v1.13.0/go.mod h1:E4Rj9a5ZtAxcQJlEBTLgMTphfP11/lNaAshpoBgemX8=\ncloud.google.com/go/datacatalog v1.14.0/go.mod h1:h0PrGtlihoutNMp/uvwhawLQ9+c63Kz65UFqh49Yo+E=\ncloud.google.com/go/datacatalog v1.14.1/go.mod h1:d2CevwTG4yedZilwe+v3E3ZBDRMobQfSG/a6cCCN5R4=\ncloud.google.com/go/dataflow v0.6.0/go.mod h1:9QwV89cGoxjjSR9/r7eFDqqjtvbKxAK2BaYU6PVk9UM=\ncloud.google.com/go/dataflow v0.7.0/go.mod h1:PX526vb4ijFMesO1o202EaUmouZKBpjHsTlCtB4parQ=\ncloud.google.com/go/dataflow v0.8.0/go.mod h1:Rcf5YgTKPtQyYz8bLYhFoIV/vP39eL7fWNcSOyFfLJE=\ncloud.google.com/go/dataflow v0.9.1/go.mod h1:Wp7s32QjYuQDWqJPFFlnBKhkAtiFpMTdg00qGbnIHVw=\ncloud.google.com/go/dataform v0.3.0/go.mod h1:cj8uNliRlHpa6L3yVhDOBrUXH+BPAO1+KFMQQNSThKo=\ncloud.google.com/go/dataform v0.4.0/go.mod h1:fwV6Y4Ty2yIFL89huYlEkwUPtS7YZinZbzzj5S9FzCE=\ncloud.google.com/go/dataform v0.5.0/go.mod h1:GFUYRe8IBa2hcomWplodVmUx/iTL0FrsauObOM3Ipr0=\ncloud.google.com/go/dataform v0.6.0/go.mod h1:QPflImQy33e29VuapFdf19oPbE4aYTJxr31OAPV+ulA=\ncloud.google.com/go/dataform v0.7.0/go.mod h1:7NulqnVozfHvWUBpMDfKMUESr+85aJsC/2O0o3jWPDE=\ncloud.google.com/go/dataform v0.8.1/go.mod h1:3BhPSiw8xmppbgzeBbmDvmSWlwouuJkXsXsb8UBih9M=\ncloud.google.com/go/datafusion v1.4.0/go.mod h1:1Zb6VN+W6ALo85cXnM1IKiPw+yQMKMhB9TsTSRDo/38=\ncloud.google.com/go/datafusion v1.5.0/go.mod h1:Kz+l1FGHB0J+4XF2fud96WMmRiq/wj8N9u007vyXZ2w=\ncloud.google.com/go/datafusion v1.6.0/go.mod h1:WBsMF8F1RhSXvVM8rCV3AeyWVxcC2xY6vith3iw3S+8=\ncloud.google.com/go/datafusion v1.7.1/go.mod h1:KpoTBbFmoToDExJUso/fcCiguGDk7MEzOWXUsJo0wsI=\ncloud.google.com/go/datalabeling v0.5.0/go.mod h1:TGcJ0G2NzcsXSE/97yWjIZO0bXj0KbVlINXMG9ud42I=\ncloud.google.com/go/datalabeling v0.6.0/go.mod h1:WqdISuk/+WIGeMkpw/1q7bK/tFEZxsrFJOJdY2bXvTQ=\ncloud.google.com/go/datalabeling v0.7.0/go.mod h1:WPQb1y08RJbmpM3ww0CSUAGweL0SxByuW2E+FU+wXcM=\ncloud.google.com/go/datalabeling v0.8.1/go.mod h1:XS62LBSVPbYR54GfYQsPXZjTW8UxCK2fkDciSrpRFdY=\ncloud.google.com/go/dataplex v1.3.0/go.mod h1:hQuRtDg+fCiFgC8j0zV222HvzFQdRd+SVX8gdmFcZzA=\ncloud.google.com/go/dataplex v1.4.0/go.mod h1:X51GfLXEMVJ6UN47ESVqvlsRplbLhcsAt0kZCCKsU0A=\ncloud.google.com/go/dataplex v1.5.2/go.mod h1:cVMgQHsmfRoI5KFYq4JtIBEUbYwc3c7tXmIDhRmNNVQ=\ncloud.google.com/go/dataplex v1.6.0/go.mod h1:bMsomC/aEJOSpHXdFKFGQ1b0TDPIeL28nJObeO1ppRs=\ncloud.google.com/go/dataplex v1.8.1/go.mod h1:7TyrDT6BCdI8/38Uvp0/ZxBslOslP2X2MPDucliyvSE=\ncloud.google.com/go/dataproc v1.7.0/go.mod h1:CKAlMjII9H90RXaMpSxQ8EU6dQx6iAYNPcYPOkSbi8s=\ncloud.google.com/go/dataproc v1.8.0/go.mod h1:5OW+zNAH0pMpw14JVrPONsxMQYMBqJuzORhIBfBn9uI=\ncloud.google.com/go/dataproc v1.12.0/go.mod h1:zrF3aX0uV3ikkMz6z4uBbIKyhRITnxvr4i3IjKsKrw4=\ncloud.google.com/go/dataqna v0.5.0/go.mod h1:90Hyk596ft3zUQ8NkFfvICSIfHFh1Bc7C4cK3vbhkeo=\ncloud.google.com/go/dataqna v0.6.0/go.mod h1:1lqNpM7rqNLVgWBJyk5NF6Uen2PHym0jtVJonplVsDA=\ncloud.google.com/go/dataqna v0.7.0/go.mod h1:Lx9OcIIeqCrw1a6KdO3/5KMP1wAmTc0slZWwP12Qq3c=\ncloud.google.com/go/dataqna v0.8.1/go.mod h1:zxZM0Bl6liMePWsHA8RMGAfmTG34vJMapbHAxQ5+WA8=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/datastore v1.10.0/go.mod h1:PC5UzAmDEkAmkfaknstTYbNpgE49HAgW2J1gcgUfmdM=\ncloud.google.com/go/datastore v1.11.0/go.mod h1:TvGxBIHCS50u8jzG+AW/ppf87v1of8nwzFNgEZU1D3c=\ncloud.google.com/go/datastore v1.12.0/go.mod h1:KjdB88W897MRITkvWWJrg2OUtrR5XVj1EoLgSp6/N70=\ncloud.google.com/go/datastore v1.12.1/go.mod h1:KjdB88W897MRITkvWWJrg2OUtrR5XVj1EoLgSp6/N70=\ncloud.google.com/go/datastream v1.2.0/go.mod h1:i/uTP8/fZwgATHS/XFu0TcNUhuA0twZxxQ3EyCUQMwo=\ncloud.google.com/go/datastream v1.3.0/go.mod h1:cqlOX8xlyYF/uxhiKn6Hbv6WjwPPuI9W2M9SAXwaLLQ=\ncloud.google.com/go/datastream v1.4.0/go.mod h1:h9dpzScPhDTs5noEMQVWP8Wx8AFBRyS0s8KWPx/9r0g=\ncloud.google.com/go/datastream v1.5.0/go.mod h1:6TZMMNPwjUqZHBKPQ1wwXpb0d5VDVPl2/XoS5yi88q4=\ncloud.google.com/go/datastream v1.6.0/go.mod h1:6LQSuswqLa7S4rPAOZFVjHIG3wJIjZcZrw8JDEDJuIs=\ncloud.google.com/go/datastream v1.7.0/go.mod h1:uxVRMm2elUSPuh65IbZpzJNMbuzkcvu5CjMqVIUHrww=\ncloud.google.com/go/datastream v1.9.1/go.mod h1:hqnmr8kdUBmrnk65k5wNRoHSCYksvpdZIcZIEl8h43Q=\ncloud.google.com/go/deploy v1.4.0/go.mod h1:5Xghikd4VrmMLNaF6FiRFDlHb59VM59YoDQnOUdsH/c=\ncloud.google.com/go/deploy v1.5.0/go.mod h1:ffgdD0B89tToyW/U/D2eL0jN2+IEV/3EMuXHA0l4r+s=\ncloud.google.com/go/deploy v1.6.0/go.mod h1:f9PTHehG/DjCom3QH0cntOVRm93uGBDt2vKzAPwpXQI=\ncloud.google.com/go/deploy v1.8.0/go.mod h1:z3myEJnA/2wnB4sgjqdMfgxCA0EqC3RBTNcVPs93mtQ=\ncloud.google.com/go/deploy v1.11.0/go.mod h1:tKuSUV5pXbn67KiubiUNUejqLs4f5cxxiCNCeyl0F2g=\ncloud.google.com/go/dialogflow v1.15.0/go.mod h1:HbHDWs33WOGJgn6rfzBW1Kv807BE3O1+xGbn59zZWI4=\ncloud.google.com/go/dialogflow v1.16.1/go.mod h1:po6LlzGfK+smoSmTBnbkIZY2w8ffjz/RcGSS+sh1el0=\ncloud.google.com/go/dialogflow v1.17.0/go.mod h1:YNP09C/kXA1aZdBgC/VtXX74G/TKn7XVCcVumTflA+8=\ncloud.google.com/go/dialogflow v1.18.0/go.mod h1:trO7Zu5YdyEuR+BhSNOqJezyFQ3aUzz0njv7sMx/iek=\ncloud.google.com/go/dialogflow v1.19.0/go.mod h1:JVmlG1TwykZDtxtTXujec4tQ+D8SBFMoosgy+6Gn0s0=\ncloud.google.com/go/dialogflow v1.29.0/go.mod h1:b+2bzMe+k1s9V+F2jbJwpHPzrnIyHihAdRFMtn2WXuM=\ncloud.google.com/go/dialogflow v1.31.0/go.mod h1:cuoUccuL1Z+HADhyIA7dci3N5zUssgpBJmCzI6fNRB4=\ncloud.google.com/go/dialogflow v1.32.0/go.mod h1:jG9TRJl8CKrDhMEcvfcfFkkpp8ZhgPz3sBGmAUYJ2qE=\ncloud.google.com/go/dialogflow v1.38.0/go.mod h1:L7jnH+JL2mtmdChzAIcXQHXMvQkE3U4hTaNltEuxXn4=\ncloud.google.com/go/dlp v1.6.0/go.mod h1:9eyB2xIhpU0sVwUixfBubDoRwP+GjeUoxxeueZmqvmM=\ncloud.google.com/go/dlp v1.7.0/go.mod h1:68ak9vCiMBjbasxeVD17hVPxDEck+ExiHavX8kiHG+Q=\ncloud.google.com/go/dlp v1.9.0/go.mod h1:qdgmqgTyReTz5/YNSSuueR8pl7hO0o9bQ39ZhtgkWp4=\ncloud.google.com/go/dlp v1.10.1/go.mod h1:IM8BWz1iJd8njcNcG0+Kyd9OPnqnRNkDV8j42VT5KOI=\ncloud.google.com/go/documentai v1.7.0/go.mod h1:lJvftZB5NRiFSX4moiye1SMxHx0Bc3x1+p9e/RfXYiU=\ncloud.google.com/go/documentai v1.8.0/go.mod h1:xGHNEB7CtsnySCNrCFdCyyMz44RhFEEX2Q7UD0c5IhU=\ncloud.google.com/go/documentai v1.9.0/go.mod h1:FS5485S8R00U10GhgBC0aNGrJxBP8ZVpEeJ7PQDZd6k=\ncloud.google.com/go/documentai v1.10.0/go.mod h1:vod47hKQIPeCfN2QS/jULIvQTugbmdc0ZvxxfQY1bg4=\ncloud.google.com/go/documentai v1.16.0/go.mod h1:o0o0DLTEZ+YnJZ+J4wNfTxmDVyrkzFvttBXXtYRMHkM=\ncloud.google.com/go/documentai v1.18.0/go.mod h1:F6CK6iUH8J81FehpskRmhLq/3VlwQvb7TvwOceQ2tbs=\ncloud.google.com/go/documentai v1.20.0/go.mod h1:yJkInoMcK0qNAEdRnqY/D5asy73tnPe88I1YTZT+a8E=\ncloud.google.com/go/domains v0.6.0/go.mod h1:T9Rz3GasrpYk6mEGHh4rymIhjlnIuB4ofT1wTxDeT4Y=\ncloud.google.com/go/domains v0.7.0/go.mod h1:PtZeqS1xjnXuRPKE/88Iru/LdfoRyEHYA9nFQf4UKpg=\ncloud.google.com/go/domains v0.8.0/go.mod h1:M9i3MMDzGFXsydri9/vW+EWz9sWb4I6WyHqdlAk0idE=\ncloud.google.com/go/domains v0.9.1/go.mod h1:aOp1c0MbejQQ2Pjf1iJvnVyT+z6R6s8pX66KaCSDYfE=\ncloud.google.com/go/edgecontainer v0.1.0/go.mod h1:WgkZ9tp10bFxqO8BLPqv2LlfmQF1X8lZqwW4r1BTajk=\ncloud.google.com/go/edgecontainer v0.2.0/go.mod h1:RTmLijy+lGpQ7BXuTDa4C4ssxyXT34NIuHIgKuP4s5w=\ncloud.google.com/go/edgecontainer v0.3.0/go.mod h1:FLDpP4nykgwwIfcLt6zInhprzw0lEi2P1fjO6Ie0qbc=\ncloud.google.com/go/edgecontainer v1.0.0/go.mod h1:cttArqZpBB2q58W/upSG++ooo6EsblxDIolxa3jSjbY=\ncloud.google.com/go/edgecontainer v1.1.1/go.mod h1:O5bYcS//7MELQZs3+7mabRqoWQhXCzenBu0R8bz2rwk=\ncloud.google.com/go/errorreporting v0.3.0/go.mod h1:xsP2yaAp+OAW4OIm60An2bbLpqIhKXdWR/tawvl7QzU=\ncloud.google.com/go/essentialcontacts v1.3.0/go.mod h1:r+OnHa5jfj90qIfZDO/VztSFqbQan7HV75p8sA+mdGI=\ncloud.google.com/go/essentialcontacts v1.4.0/go.mod h1:8tRldvHYsmnBCHdFpvU+GL75oWiBKl80BiqlFh9tp+8=\ncloud.google.com/go/essentialcontacts v1.5.0/go.mod h1:ay29Z4zODTuwliK7SnX8E86aUF2CTzdNtvv42niCX0M=\ncloud.google.com/go/essentialcontacts v1.6.2/go.mod h1:T2tB6tX+TRak7i88Fb2N9Ok3PvY3UNbUsMag9/BARh4=\ncloud.google.com/go/eventarc v1.7.0/go.mod h1:6ctpF3zTnaQCxUjHUdcfgcA1A2T309+omHZth7gDfmc=\ncloud.google.com/go/eventarc v1.8.0/go.mod h1:imbzxkyAU4ubfsaKYdQg04WS1NvncblHEup4kvF+4gw=\ncloud.google.com/go/eventarc v1.10.0/go.mod h1:u3R35tmZ9HvswGRBnF48IlYgYeBcPUCjkr4BTdem2Kw=\ncloud.google.com/go/eventarc v1.11.0/go.mod h1:PyUjsUKPWoRBCHeOxZd/lbOOjahV41icXyUY5kSTvVY=\ncloud.google.com/go/eventarc v1.12.1/go.mod h1:mAFCW6lukH5+IZjkvrEss+jmt2kOdYlN8aMx3sRJiAI=\ncloud.google.com/go/filestore v1.3.0/go.mod h1:+qbvHGvXU1HaKX2nD0WEPo92TP/8AQuCVEBXNY9z0+w=\ncloud.google.com/go/filestore v1.4.0/go.mod h1:PaG5oDfo9r224f8OYXURtAsY+Fbyq/bLYoINEK8XQAI=\ncloud.google.com/go/filestore v1.5.0/go.mod h1:FqBXDWBp4YLHqRnVGveOkHDf8svj9r5+mUDLupOWEDs=\ncloud.google.com/go/filestore v1.6.0/go.mod h1:di5unNuss/qfZTw2U9nhFqo8/ZDSc466dre85Kydllg=\ncloud.google.com/go/filestore v1.7.1/go.mod h1:y10jsorq40JJnjR/lQ8AfFbbcGlw3g+Dp8oN7i7FjV4=\ncloud.google.com/go/firestore v1.9.0/go.mod h1:HMkjKHNTtRyZNiMzu7YAsLr9K3X2udY2AMwDaMEQiiE=\ncloud.google.com/go/firestore v1.11.0/go.mod h1:b38dKhgzlmNNGTNZZwe7ZRFEuRab1Hay3/DBsIGKKy4=\ncloud.google.com/go/functions v1.6.0/go.mod h1:3H1UA3qiIPRWD7PeZKLvHZ9SaQhR26XIJcC0A5GbvAk=\ncloud.google.com/go/functions v1.7.0/go.mod h1:+d+QBcWM+RsrgZfV9xo6KfA1GlzJfxcfZcRPEhDDfzg=\ncloud.google.com/go/functions v1.8.0/go.mod h1:RTZ4/HsQjIqIYP9a9YPbU+QFoQsAlYgrwOXJWHn1POY=\ncloud.google.com/go/functions v1.9.0/go.mod h1:Y+Dz8yGguzO3PpIjhLTbnqV1CWmgQ5UwtlpzoyquQ08=\ncloud.google.com/go/functions v1.10.0/go.mod h1:0D3hEOe3DbEvCXtYOZHQZmD+SzYsi1YbI7dGvHfldXw=\ncloud.google.com/go/functions v1.12.0/go.mod h1:AXWGrF3e2C/5ehvwYo/GH6O5s09tOPksiKhz+hH8WkA=\ncloud.google.com/go/functions v1.13.0/go.mod h1:EU4O007sQm6Ef/PwRsI8N2umygGqPBS/IZQKBQBcJ3c=\ncloud.google.com/go/functions v1.15.1/go.mod h1:P5yNWUTkyU+LvW/S9O6V+V423VZooALQlqoXdoPz5AE=\ncloud.google.com/go/gaming v1.5.0/go.mod h1:ol7rGcxP/qHTRQE/RO4bxkXq+Fix0j6D4LFPzYTIrDM=\ncloud.google.com/go/gaming v1.6.0/go.mod h1:YMU1GEvA39Qt3zWGyAVA9bpYz/yAhTvaQ1t2sK4KPUA=\ncloud.google.com/go/gaming v1.7.0/go.mod h1:LrB8U7MHdGgFG851iHAfqUdLcKBdQ55hzXy9xBJz0+w=\ncloud.google.com/go/gaming v1.8.0/go.mod h1:xAqjS8b7jAVW0KFYeRUxngo9My3f33kFmua++Pi+ggM=\ncloud.google.com/go/gaming v1.9.0/go.mod h1:Fc7kEmCObylSWLO334NcO+O9QMDyz+TKC4v1D7X+Bc0=\ncloud.google.com/go/gaming v1.10.1/go.mod h1:XQQvtfP8Rb9Rxnxm5wFVpAp9zCQkJi2bLIb7iHGwB3s=\ncloud.google.com/go/gkebackup v0.2.0/go.mod h1:XKvv/4LfG829/B8B7xRkk8zRrOEbKtEam6yNfuQNH60=\ncloud.google.com/go/gkebackup v0.3.0/go.mod h1:n/E671i1aOQvUxT541aTkCwExO/bTer2HDlj4TsBRAo=\ncloud.google.com/go/gkebackup v0.4.0/go.mod h1:byAyBGUwYGEEww7xsbnUTBHIYcOPy/PgUWUtOeRm9Vg=\ncloud.google.com/go/gkeconnect v0.5.0/go.mod h1:c5lsNAg5EwAy7fkqX/+goqFsU1Da/jQFqArp+wGNr/o=\ncloud.google.com/go/gkeconnect v0.6.0/go.mod h1:Mln67KyU/sHJEBY8kFZ0xTeyPtzbq9StAVvEULYK16A=\ncloud.google.com/go/gkeconnect v0.7.0/go.mod h1:SNfmVqPkaEi3bF/B3CNZOAYPYdg7sU+obZ+QTky2Myw=\ncloud.google.com/go/gkeconnect v0.8.1/go.mod h1:KWiK1g9sDLZqhxB2xEuPV8V9NYzrqTUmQR9shJHpOZw=\ncloud.google.com/go/gkehub v0.9.0/go.mod h1:WYHN6WG8w9bXU0hqNxt8rm5uxnk8IH+lPY9J2TV7BK0=\ncloud.google.com/go/gkehub v0.10.0/go.mod h1:UIPwxI0DsrpsVoWpLB0stwKCP+WFVG9+y977wO+hBH0=\ncloud.google.com/go/gkehub v0.11.0/go.mod h1:JOWHlmN+GHyIbuWQPl47/C2RFhnFKH38jH9Ascu3n0E=\ncloud.google.com/go/gkehub v0.12.0/go.mod h1:djiIwwzTTBrF5NaXCGv3mf7klpEMcST17VBTVVDcuaw=\ncloud.google.com/go/gkehub v0.14.1/go.mod h1:VEXKIJZ2avzrbd7u+zeMtW00Y8ddk/4V9511C9CQGTY=\ncloud.google.com/go/gkemulticloud v0.3.0/go.mod h1:7orzy7O0S+5kq95e4Hpn7RysVA7dPs8W/GgfUtsPbrA=\ncloud.google.com/go/gkemulticloud v0.4.0/go.mod h1:E9gxVBnseLWCk24ch+P9+B2CoDFJZTyIgLKSalC7tuI=\ncloud.google.com/go/gkemulticloud v0.5.0/go.mod h1:W0JDkiyi3Tqh0TJr//y19wyb1yf8llHVto2Htf2Ja3Y=\ncloud.google.com/go/gkemulticloud v0.6.1/go.mod h1:kbZ3HKyTsiwqKX7Yw56+wUGwwNZViRnxWK2DVknXWfw=\ncloud.google.com/go/grafeas v0.2.0/go.mod h1:KhxgtF2hb0P191HlY5besjYm6MqTSTj3LSI+M+ByZHc=\ncloud.google.com/go/grafeas v0.3.0/go.mod h1:P7hgN24EyONOTMyeJH6DxG4zD7fwiYa5Q6GUgyFSOU8=\ncloud.google.com/go/gsuiteaddons v1.3.0/go.mod h1:EUNK/J1lZEZO8yPtykKxLXI6JSVN2rg9bN8SXOa0bgM=\ncloud.google.com/go/gsuiteaddons v1.4.0/go.mod h1:rZK5I8hht7u7HxFQcFei0+AtfS9uSushomRlg+3ua1o=\ncloud.google.com/go/gsuiteaddons v1.5.0/go.mod h1:TFCClYLd64Eaa12sFVmUyG62tk4mdIsI7pAnSXRkcFo=\ncloud.google.com/go/gsuiteaddons v1.6.1/go.mod h1:CodrdOqRZcLp5WOwejHWYBjZvfY0kOphkAKpF/3qdZY=\ncloud.google.com/go/iam v0.1.0/go.mod h1:vcUNEa0pEm0qRVpmWepWaFMIAI8/hjB9mO8rNCJtF6c=\ncloud.google.com/go/iam v0.3.0/go.mod h1:XzJPvDayI+9zsASAFO68Hk07u3z+f+JrT2xXNdp4bnY=\ncloud.google.com/go/iam v0.5.0/go.mod h1:wPU9Vt0P4UmCux7mqtRu6jcpPAb74cP1fh50J3QpkUc=\ncloud.google.com/go/iam v0.6.0/go.mod h1:+1AH33ueBne5MzYccyMHtEKqLE4/kJOibtffMHDMFMc=\ncloud.google.com/go/iam v0.7.0/go.mod h1:H5Br8wRaDGNc8XP3keLc4unfUUZeyH3Sfl9XpQEYOeg=\ncloud.google.com/go/iam v0.8.0/go.mod h1:lga0/y3iH6CX7sYqypWJ33hf7kkfXJag67naqGESjkE=\ncloud.google.com/go/iam v0.11.0/go.mod h1:9PiLDanza5D+oWFZiH1uG+RnRCfEGKoyl6yo4cgWZGY=\ncloud.google.com/go/iam v0.12.0/go.mod h1:knyHGviacl11zrtZUoDuYpDgLjvr28sLQaG0YB2GYAY=\ncloud.google.com/go/iam v0.13.0/go.mod h1:ljOg+rcNfzZ5d6f1nAUJ8ZIxOaZUVoS14bKCtaLZ/D0=\ncloud.google.com/go/iam v1.0.1/go.mod h1:yR3tmSL8BcZB4bxByRv2jkSIahVmCtfKZwLYGBalRE8=\ncloud.google.com/go/iam v1.1.0/go.mod h1:nxdHjaKfCr7fNYx/HJMM8LgiMugmveWlkatear5gVyk=\ncloud.google.com/go/iam v1.1.1/go.mod h1:A5avdyVL2tCppe4unb0951eI9jreack+RJ0/d+KUZOU=\ncloud.google.com/go/iap v1.4.0/go.mod h1:RGFwRJdihTINIe4wZ2iCP0zF/qu18ZwyKxrhMhygBEc=\ncloud.google.com/go/iap v1.5.0/go.mod h1:UH/CGgKd4KyohZL5Pt0jSKE4m3FR51qg6FKQ/z/Ix9A=\ncloud.google.com/go/iap v1.6.0/go.mod h1:NSuvI9C/j7UdjGjIde7t7HBz+QTwBcapPE07+sSRcLk=\ncloud.google.com/go/iap v1.7.0/go.mod h1:beqQx56T9O1G1yNPph+spKpNibDlYIiIixiqsQXxLIo=\ncloud.google.com/go/iap v1.7.1/go.mod h1:WapEwPc7ZxGt2jFGB/C/bm+hP0Y6NXzOYGjpPnmMS74=\ncloud.google.com/go/iap v1.8.1/go.mod h1:sJCbeqg3mvWLqjZNsI6dfAtbbV1DL2Rl7e1mTyXYREQ=\ncloud.google.com/go/ids v1.1.0/go.mod h1:WIuwCaYVOzHIj2OhN9HAwvW+DBdmUAdcWlFxRl+KubM=\ncloud.google.com/go/ids v1.2.0/go.mod h1:5WXvp4n25S0rA/mQWAg1YEEBBq6/s+7ml1RDCW1IrcY=\ncloud.google.com/go/ids v1.3.0/go.mod h1:JBdTYwANikFKaDP6LtW5JAi4gubs57SVNQjemdt6xV4=\ncloud.google.com/go/ids v1.4.1/go.mod h1:np41ed8YMU8zOgv53MMMoCntLTn2lF+SUzlM+O3u/jw=\ncloud.google.com/go/iot v1.3.0/go.mod h1:r7RGh2B61+B8oz0AGE+J72AhA0G7tdXItODWsaA2oLs=\ncloud.google.com/go/iot v1.4.0/go.mod h1:dIDxPOn0UvNDUMD8Ger7FIaTuvMkj+aGk94RPP0iV+g=\ncloud.google.com/go/iot v1.5.0/go.mod h1:mpz5259PDl3XJthEmh9+ap0affn/MqNSP4My77Qql9o=\ncloud.google.com/go/iot v1.6.0/go.mod h1:IqdAsmE2cTYYNO1Fvjfzo9po179rAtJeVGUvkLN3rLE=\ncloud.google.com/go/iot v1.7.1/go.mod h1:46Mgw7ev1k9KqK1ao0ayW9h0lI+3hxeanz+L1zmbbbk=\ncloud.google.com/go/kms v1.4.0/go.mod h1:fajBHndQ+6ubNw6Ss2sSd+SWvjL26RNo/dr7uxsnnOA=\ncloud.google.com/go/kms v1.5.0/go.mod h1:QJS2YY0eJGBg3mnDfuaCyLauWwBJiHRboYxJ++1xJNg=\ncloud.google.com/go/kms v1.6.0/go.mod h1:Jjy850yySiasBUDi6KFUwUv2n1+o7QZFyuUJg6OgjA0=\ncloud.google.com/go/kms v1.8.0/go.mod h1:4xFEhYFqvW+4VMELtZyxomGSYtSQKzM178ylFW4jMAg=\ncloud.google.com/go/kms v1.9.0/go.mod h1:qb1tPTgfF9RQP8e1wq4cLFErVuTJv7UsSC915J8dh3w=\ncloud.google.com/go/kms v1.10.0/go.mod h1:ng3KTUtQQU9bPX3+QGLsflZIHlkbn8amFAMY63m8d24=\ncloud.google.com/go/kms v1.10.1/go.mod h1:rIWk/TryCkR59GMC3YtHtXeLzd634lBbKenvyySAyYI=\ncloud.google.com/go/kms v1.11.0/go.mod h1:hwdiYC0xjnWsKQQCQQmIQnS9asjYVSK6jtXm+zFqXLM=\ncloud.google.com/go/kms v1.12.1/go.mod h1:c9J991h5DTl+kg7gi3MYomh12YEENGrf48ee/N/2CDM=\ncloud.google.com/go/language v1.4.0/go.mod h1:F9dRpNFQmJbkaop6g0JhSBXCNlO90e1KWx5iDdxbWic=\ncloud.google.com/go/language v1.6.0/go.mod h1:6dJ8t3B+lUYfStgls25GusK04NLh3eDLQnWM3mdEbhI=\ncloud.google.com/go/language v1.7.0/go.mod h1:DJ6dYN/W+SQOjF8e1hLQXMF21AkH2w9wiPzPCJa2MIE=\ncloud.google.com/go/language v1.8.0/go.mod h1:qYPVHf7SPoNNiCL2Dr0FfEFNil1qi3pQEyygwpgVKB8=\ncloud.google.com/go/language v1.9.0/go.mod h1:Ns15WooPM5Ad/5no/0n81yUetis74g3zrbeJBE+ptUY=\ncloud.google.com/go/language v1.10.1/go.mod h1:CPp94nsdVNiQEt1CNjF5WkTcisLiHPyIbMhvR8H2AW0=\ncloud.google.com/go/lifesciences v0.5.0/go.mod h1:3oIKy8ycWGPUyZDR/8RNnTOYevhaMLqh5vLUXs9zvT8=\ncloud.google.com/go/lifesciences v0.6.0/go.mod h1:ddj6tSX/7BOnhxCSd3ZcETvtNr8NZ6t/iPhY2Tyfu08=\ncloud.google.com/go/lifesciences v0.8.0/go.mod h1:lFxiEOMqII6XggGbOnKiyZ7IBwoIqA84ClvoezaA/bo=\ncloud.google.com/go/lifesciences v0.9.1/go.mod h1:hACAOd1fFbCGLr/+weUKRAJas82Y4vrL3O5326N//Wc=\ncloud.google.com/go/logging v1.6.1/go.mod h1:5ZO0mHHbvm8gEmeEUHrmDlTDSu5imF6MUP9OfilNXBw=\ncloud.google.com/go/logging v1.7.0/go.mod h1:3xjP2CjkM3ZkO73aj4ASA5wRPGGCRrPIAeNqVNkzY8M=\ncloud.google.com/go/longrunning v0.1.1/go.mod h1:UUFxuDWkv22EuY93jjmDMFT5GPQKeFVJBIF6QlTqdsE=\ncloud.google.com/go/longrunning v0.3.0/go.mod h1:qth9Y41RRSUE69rDcOn6DdK3HfQfsUI0YSmW3iIlLJc=\ncloud.google.com/go/longrunning v0.4.1/go.mod h1:4iWDqhBZ70CvZ6BfETbvam3T8FMvLK+eFj0E6AaRQTo=\ncloud.google.com/go/longrunning v0.4.2/go.mod h1:OHrnaYyLUV6oqwh0xiS7e5sLQhP1m0QU9R+WhGDMgIQ=\ncloud.google.com/go/longrunning v0.5.0/go.mod h1:0JNuqRShmscVAhIACGtskSAWtqtOoPkwP0YF1oVEchc=\ncloud.google.com/go/longrunning v0.5.1/go.mod h1:spvimkwdz6SPWKEt/XBij79E9fiTkHSQl/fRUUQJYJc=\ncloud.google.com/go/managedidentities v1.3.0/go.mod h1:UzlW3cBOiPrzucO5qWkNkh0w33KFtBJU281hacNvsdE=\ncloud.google.com/go/managedidentities v1.4.0/go.mod h1:NWSBYbEMgqmbZsLIyKvxrYbtqOsxY1ZrGM+9RgDqInM=\ncloud.google.com/go/managedidentities v1.5.0/go.mod h1:+dWcZ0JlUmpuxpIDfyP5pP5y0bLdRwOS4Lp7gMni/LA=\ncloud.google.com/go/managedidentities v1.6.1/go.mod h1:h/irGhTN2SkZ64F43tfGPMbHnypMbu4RB3yl8YcuEak=\ncloud.google.com/go/maps v0.1.0/go.mod h1:BQM97WGyfw9FWEmQMpZ5T6cpovXXSd1cGmFma94eubI=\ncloud.google.com/go/maps v0.6.0/go.mod h1:o6DAMMfb+aINHz/p/jbcY+mYeXBoZoxTfdSQ8VAJaCw=\ncloud.google.com/go/maps v0.7.0/go.mod h1:3GnvVl3cqeSvgMcpRlQidXsPYuDGQ8naBis7MVzpXsY=\ncloud.google.com/go/mediatranslation v0.5.0/go.mod h1:jGPUhGTybqsPQn91pNXw0xVHfuJ3leR1wj37oU3y1f4=\ncloud.google.com/go/mediatranslation v0.6.0/go.mod h1:hHdBCTYNigsBxshbznuIMFNe5QXEowAuNmmC7h8pu5w=\ncloud.google.com/go/mediatranslation v0.7.0/go.mod h1:LCnB/gZr90ONOIQLgSXagp8XUW1ODs2UmUMvcgMfI2I=\ncloud.google.com/go/mediatranslation v0.8.1/go.mod h1:L/7hBdEYbYHQJhX2sldtTO5SZZ1C1vkapubj0T2aGig=\ncloud.google.com/go/memcache v1.4.0/go.mod h1:rTOfiGZtJX1AaFUrOgsMHX5kAzaTQ8azHiuDoTPzNsE=\ncloud.google.com/go/memcache v1.5.0/go.mod h1:dk3fCK7dVo0cUU2c36jKb4VqKPS22BTkf81Xq617aWM=\ncloud.google.com/go/memcache v1.6.0/go.mod h1:XS5xB0eQZdHtTuTF9Hf8eJkKtR3pVRCcvJwtm68T3rA=\ncloud.google.com/go/memcache v1.7.0/go.mod h1:ywMKfjWhNtkQTxrWxCkCFkoPjLHPW6A7WOTVI8xy3LY=\ncloud.google.com/go/memcache v1.9.0/go.mod h1:8oEyzXCu+zo9RzlEaEjHl4KkgjlNDaXbCQeQWlzNFJM=\ncloud.google.com/go/memcache v1.10.1/go.mod h1:47YRQIarv4I3QS5+hoETgKO40InqzLP6kpNLvyXuyaA=\ncloud.google.com/go/metastore v1.5.0/go.mod h1:2ZNrDcQwghfdtCwJ33nM0+GrBGlVuh8rakL3vdPY3XY=\ncloud.google.com/go/metastore v1.6.0/go.mod h1:6cyQTls8CWXzk45G55x57DVQ9gWg7RiH65+YgPsNh9s=\ncloud.google.com/go/metastore v1.7.0/go.mod h1:s45D0B4IlsINu87/AsWiEVYbLaIMeUSoxlKKDqBGFS8=\ncloud.google.com/go/metastore v1.8.0/go.mod h1:zHiMc4ZUpBiM7twCIFQmJ9JMEkDSyZS9U12uf7wHqSI=\ncloud.google.com/go/metastore v1.10.0/go.mod h1:fPEnH3g4JJAk+gMRnrAnoqyv2lpUCqJPWOodSaf45Eo=\ncloud.google.com/go/metastore v1.11.1/go.mod h1:uZuSo80U3Wd4zi6C22ZZliOUJ3XeM/MlYi/z5OAOWRA=\ncloud.google.com/go/monitoring v1.7.0/go.mod h1:HpYse6kkGo//7p6sT0wsIC6IBDET0RhIsnmlA53dvEk=\ncloud.google.com/go/monitoring v1.8.0/go.mod h1:E7PtoMJ1kQXWxPjB6mv2fhC5/15jInuulFdYYtlcvT4=\ncloud.google.com/go/monitoring v1.12.0/go.mod h1:yx8Jj2fZNEkL/GYZyTLS4ZtZEZN8WtDEiEqG4kLK50w=\ncloud.google.com/go/monitoring v1.13.0/go.mod h1:k2yMBAB1H9JT/QETjNkgdCGD9bPF712XiLTVr+cBrpw=\ncloud.google.com/go/monitoring v1.15.1/go.mod h1:lADlSAlFdbqQuwwpaImhsJXu1QSdd3ojypXrFSMr2rM=\ncloud.google.com/go/networkconnectivity v1.4.0/go.mod h1:nOl7YL8odKyAOtzNX73/M5/mGZgqqMeryi6UPZTk/rA=\ncloud.google.com/go/networkconnectivity v1.5.0/go.mod h1:3GzqJx7uhtlM3kln0+x5wyFvuVH1pIBJjhCpjzSt75o=\ncloud.google.com/go/networkconnectivity v1.6.0/go.mod h1:OJOoEXW+0LAxHh89nXd64uGG+FbQoeH8DtxCHVOMlaM=\ncloud.google.com/go/networkconnectivity v1.7.0/go.mod h1:RMuSbkdbPwNMQjB5HBWD5MpTBnNm39iAVpC3TmsExt8=\ncloud.google.com/go/networkconnectivity v1.10.0/go.mod h1:UP4O4sWXJG13AqrTdQCD9TnLGEbtNRqjuaaA7bNjF5E=\ncloud.google.com/go/networkconnectivity v1.11.0/go.mod h1:iWmDD4QF16VCDLXUqvyspJjIEtBR/4zq5hwnY2X3scM=\ncloud.google.com/go/networkconnectivity v1.12.1/go.mod h1:PelxSWYM7Sh9/guf8CFhi6vIqf19Ir/sbfZRUwXh92E=\ncloud.google.com/go/networkmanagement v1.4.0/go.mod h1:Q9mdLLRn60AsOrPc8rs8iNV6OHXaGcDdsIQe1ohekq8=\ncloud.google.com/go/networkmanagement v1.5.0/go.mod h1:ZnOeZ/evzUdUsnvRt792H0uYEnHQEMaz+REhhzJRcf4=\ncloud.google.com/go/networkmanagement v1.6.0/go.mod h1:5pKPqyXjB/sgtvB5xqOemumoQNB7y95Q7S+4rjSOPYY=\ncloud.google.com/go/networkmanagement v1.8.0/go.mod h1:Ho/BUGmtyEqrttTgWEe7m+8vDdK74ibQc+Be0q7Fof0=\ncloud.google.com/go/networksecurity v0.5.0/go.mod h1:xS6fOCoqpVC5zx15Z/MqkfDwH4+m/61A3ODiDV1xmiQ=\ncloud.google.com/go/networksecurity v0.6.0/go.mod h1:Q5fjhTr9WMI5mbpRYEbiexTzROf7ZbDzvzCrNl14nyU=\ncloud.google.com/go/networksecurity v0.7.0/go.mod h1:mAnzoxx/8TBSyXEeESMy9OOYwo1v+gZ5eMRnsT5bC8k=\ncloud.google.com/go/networksecurity v0.8.0/go.mod h1:B78DkqsxFG5zRSVuwYFRZ9Xz8IcQ5iECsNrPn74hKHU=\ncloud.google.com/go/networksecurity v0.9.1/go.mod h1:MCMdxOKQ30wsBI1eI659f9kEp4wuuAueoC9AJKSPWZQ=\ncloud.google.com/go/notebooks v1.2.0/go.mod h1:9+wtppMfVPUeJ8fIWPOq1UnATHISkGXGqTkxeieQ6UY=\ncloud.google.com/go/notebooks v1.3.0/go.mod h1:bFR5lj07DtCPC7YAAJ//vHskFBxA5JzYlH68kXVdk34=\ncloud.google.com/go/notebooks v1.4.0/go.mod h1:4QPMngcwmgb6uw7Po99B2xv5ufVoIQ7nOGDyL4P8AgA=\ncloud.google.com/go/notebooks v1.5.0/go.mod h1:q8mwhnP9aR8Hpfnrc5iN5IBhrXUy8S2vuYs+kBJ/gu0=\ncloud.google.com/go/notebooks v1.7.0/go.mod h1:PVlaDGfJgj1fl1S3dUwhFMXFgfYGhYQt2164xOMONmE=\ncloud.google.com/go/notebooks v1.8.0/go.mod h1:Lq6dYKOYOWUCTvw5t2q1gp1lAp0zxAxRycayS0iJcqQ=\ncloud.google.com/go/notebooks v1.9.1/go.mod h1:zqG9/gk05JrzgBt4ghLzEepPHNwE5jgPcHZRKhlC1A8=\ncloud.google.com/go/optimization v1.1.0/go.mod h1:5po+wfvX5AQlPznyVEZjGJTMr4+CAkJf2XSTQOOl9l4=\ncloud.google.com/go/optimization v1.2.0/go.mod h1:Lr7SOHdRDENsh+WXVmQhQTrzdu9ybg0NecjHidBq6xs=\ncloud.google.com/go/optimization v1.3.1/go.mod h1:IvUSefKiwd1a5p0RgHDbWCIbDFgKuEdB+fPPuP0IDLI=\ncloud.google.com/go/optimization v1.4.1/go.mod h1:j64vZQP7h9bO49m2rVaTVoNM0vEBEN5eKPUPbZyXOrk=\ncloud.google.com/go/orchestration v1.3.0/go.mod h1:Sj5tq/JpWiB//X/q3Ngwdl5K7B7Y0KZ7bfv0wL6fqVA=\ncloud.google.com/go/orchestration v1.4.0/go.mod h1:6W5NLFWs2TlniBphAViZEVhrXRSMgUGDfW7vrWKvsBk=\ncloud.google.com/go/orchestration v1.6.0/go.mod h1:M62Bevp7pkxStDfFfTuCOaXgaaqRAga1yKyoMtEoWPQ=\ncloud.google.com/go/orchestration v1.8.1/go.mod h1:4sluRF3wgbYVRqz7zJ1/EUNc90TTprliq9477fGobD8=\ncloud.google.com/go/orgpolicy v1.4.0/go.mod h1:xrSLIV4RePWmP9P3tBl8S93lTmlAxjm06NSm2UTmKvE=\ncloud.google.com/go/orgpolicy v1.5.0/go.mod h1:hZEc5q3wzwXJaKrsx5+Ewg0u1LxJ51nNFlext7Tanwc=\ncloud.google.com/go/orgpolicy v1.10.0/go.mod h1:w1fo8b7rRqlXlIJbVhOMPrwVljyuW5mqssvBtU18ONc=\ncloud.google.com/go/orgpolicy v1.11.0/go.mod h1:2RK748+FtVvnfuynxBzdnyu7sygtoZa1za/0ZfpOs1M=\ncloud.google.com/go/orgpolicy v1.11.1/go.mod h1:8+E3jQcpZJQliP+zaFfayC2Pg5bmhuLK755wKhIIUCE=\ncloud.google.com/go/osconfig v1.7.0/go.mod h1:oVHeCeZELfJP7XLxcBGTMBvRO+1nQ5tFG9VQTmYS2Fs=\ncloud.google.com/go/osconfig v1.8.0/go.mod h1:EQqZLu5w5XA7eKizepumcvWx+m8mJUhEwiPqWiZeEdg=\ncloud.google.com/go/osconfig v1.9.0/go.mod h1:Yx+IeIZJ3bdWmzbQU4fxNl8xsZ4amB+dygAwFPlvnNo=\ncloud.google.com/go/osconfig v1.10.0/go.mod h1:uMhCzqC5I8zfD9zDEAfvgVhDS8oIjySWh+l4WK6GnWw=\ncloud.google.com/go/osconfig v1.11.0/go.mod h1:aDICxrur2ogRd9zY5ytBLV89KEgT2MKB2L/n6x1ooPw=\ncloud.google.com/go/osconfig v1.12.0/go.mod h1:8f/PaYzoS3JMVfdfTubkowZYGmAhUCjjwnjqWI7NVBc=\ncloud.google.com/go/osconfig v1.12.1/go.mod h1:4CjBxND0gswz2gfYRCUoUzCm9zCABp91EeTtWXyz0tE=\ncloud.google.com/go/oslogin v1.4.0/go.mod h1:YdgMXWRaElXz/lDk1Na6Fh5orF7gvmJ0FGLIs9LId4E=\ncloud.google.com/go/oslogin v1.5.0/go.mod h1:D260Qj11W2qx/HVF29zBg+0fd6YCSjSqLUkY/qEenQU=\ncloud.google.com/go/oslogin v1.6.0/go.mod h1:zOJ1O3+dTU8WPlGEkFSh7qeHPPSoxrcMbbK1Nm2iX70=\ncloud.google.com/go/oslogin v1.7.0/go.mod h1:e04SN0xO1UNJ1M5GP0vzVBFicIe4O53FOfcixIqTyXo=\ncloud.google.com/go/oslogin v1.9.0/go.mod h1:HNavntnH8nzrn8JCTT5fj18FuJLFJc4NaZJtBnQtKFs=\ncloud.google.com/go/oslogin v1.10.1/go.mod h1:x692z7yAue5nE7CsSnoG0aaMbNoRJRXO4sn73R+ZqAs=\ncloud.google.com/go/phishingprotection v0.5.0/go.mod h1:Y3HZknsK9bc9dMi+oE8Bim0lczMU6hrX0UpADuMefr0=\ncloud.google.com/go/phishingprotection v0.6.0/go.mod h1:9Y3LBLgy0kDTcYET8ZH3bq/7qni15yVUoAxiFxnlSUA=\ncloud.google.com/go/phishingprotection v0.7.0/go.mod h1:8qJI4QKHoda/sb/7/YmMQ2omRLSLYSu9bU0EKCNI+Lk=\ncloud.google.com/go/phishingprotection v0.8.1/go.mod h1:AxonW7GovcA8qdEk13NfHq9hNx5KPtfxXNeUxTDxB6I=\ncloud.google.com/go/policytroubleshooter v1.3.0/go.mod h1:qy0+VwANja+kKrjlQuOzmlvscn4RNsAc0e15GGqfMxg=\ncloud.google.com/go/policytroubleshooter v1.4.0/go.mod h1:DZT4BcRw3QoO8ota9xw/LKtPa8lKeCByYeKTIf/vxdE=\ncloud.google.com/go/policytroubleshooter v1.5.0/go.mod h1:Rz1WfV+1oIpPdN2VvvuboLVRsB1Hclg3CKQ53j9l8vw=\ncloud.google.com/go/policytroubleshooter v1.6.0/go.mod h1:zYqaPTsmfvpjm5ULxAyD/lINQxJ0DDsnWOP/GZ7xzBc=\ncloud.google.com/go/policytroubleshooter v1.7.1/go.mod h1:0NaT5v3Ag1M7U5r0GfDCpUFkWd9YqpubBWsQlhanRv0=\ncloud.google.com/go/privatecatalog v0.5.0/go.mod h1:XgosMUvvPyxDjAVNDYxJ7wBW8//hLDDYmnsNcMGq1K0=\ncloud.google.com/go/privatecatalog v0.6.0/go.mod h1:i/fbkZR0hLN29eEWiiwue8Pb+GforiEIBnV9yrRUOKI=\ncloud.google.com/go/privatecatalog v0.7.0/go.mod h1:2s5ssIFO69F5csTXcwBP7NPFTZvps26xGzvQ2PQaBYg=\ncloud.google.com/go/privatecatalog v0.8.0/go.mod h1:nQ6pfaegeDAq/Q5lrfCQzQLhubPiZhSaNhIgfJlnIXs=\ncloud.google.com/go/privatecatalog v0.9.1/go.mod h1:0XlDXW2unJXdf9zFz968Hp35gl/bhF4twwpXZAW50JA=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=\ncloud.google.com/go/pubsub v1.26.0/go.mod h1:QgBH3U/jdJy/ftjPhTkyXNj543Tin1pRYcdcPRnFIRI=\ncloud.google.com/go/pubsub v1.27.1/go.mod h1:hQN39ymbV9geqBnfQq6Xf63yNhUAhv9CZhzp5O6qsW0=\ncloud.google.com/go/pubsub v1.28.0/go.mod h1:vuXFpwaVoIPQMGXqRyUQigu/AX1S3IWugR9xznmcXX8=\ncloud.google.com/go/pubsub v1.30.0/go.mod h1:qWi1OPS0B+b5L+Sg6Gmc9zD1Y+HaM0MdUr7LsupY1P4=\ncloud.google.com/go/pubsub v1.32.0/go.mod h1:f+w71I33OMyxf9VpMVcZbnG5KSUkCOUHYpFd5U1GdRc=\ncloud.google.com/go/pubsublite v1.5.0/go.mod h1:xapqNQ1CuLfGi23Yda/9l4bBCKz/wC3KIJ5gKcxveZg=\ncloud.google.com/go/pubsublite v1.6.0/go.mod h1:1eFCS0U11xlOuMFV/0iBqw3zP12kddMeCbj/F3FSj9k=\ncloud.google.com/go/pubsublite v1.7.0/go.mod h1:8hVMwRXfDfvGm3fahVbtDbiLePT3gpoiJYJY+vxWxVM=\ncloud.google.com/go/pubsublite v1.8.1/go.mod h1:fOLdU4f5xldK4RGJrBMm+J7zMWNj/k4PxwEZXy39QS0=\ncloud.google.com/go/recaptchaenterprise v1.3.1/go.mod h1:OdD+q+y4XGeAlxRaMn1Y7/GveP6zmq76byL6tjPE7d4=\ncloud.google.com/go/recaptchaenterprise/v2 v2.1.0/go.mod h1:w9yVqajwroDNTfGuhmOjPDN//rZGySaf6PtFVcSCa7o=\ncloud.google.com/go/recaptchaenterprise/v2 v2.2.0/go.mod h1:/Zu5jisWGeERrd5HnlS3EUGb/D335f9k51B/FVil0jk=\ncloud.google.com/go/recaptchaenterprise/v2 v2.3.0/go.mod h1:O9LwGCjrhGHBQET5CA7dd5NwwNQUErSgEDit1DLNTdo=\ncloud.google.com/go/recaptchaenterprise/v2 v2.4.0/go.mod h1:Am3LHfOuBstrLrNCBrlI5sbwx9LBg3te2N6hGvHn2mE=\ncloud.google.com/go/recaptchaenterprise/v2 v2.5.0/go.mod h1:O8LzcHXN3rz0j+LBC91jrwI3R+1ZSZEWrfL7XHgNo9U=\ncloud.google.com/go/recaptchaenterprise/v2 v2.6.0/go.mod h1:RPauz9jeLtB3JVzg6nCbe12qNoaa8pXc4d/YukAmcnA=\ncloud.google.com/go/recaptchaenterprise/v2 v2.7.0/go.mod h1:19wVj/fs5RtYtynAPJdDTb69oW0vNHYDBTbB4NvMD9c=\ncloud.google.com/go/recaptchaenterprise/v2 v2.7.2/go.mod h1:kR0KjsJS7Jt1YSyWFkseQ756D45kaYNTlDPPaRAvDBU=\ncloud.google.com/go/recommendationengine v0.5.0/go.mod h1:E5756pJcVFeVgaQv3WNpImkFP8a+RptV6dDLGPILjvg=\ncloud.google.com/go/recommendationengine v0.6.0/go.mod h1:08mq2umu9oIqc7tDy8sx+MNJdLG0fUi3vaSVbztHgJ4=\ncloud.google.com/go/recommendationengine v0.7.0/go.mod h1:1reUcE3GIu6MeBz/h5xZJqNLuuVjNg1lmWMPyjatzac=\ncloud.google.com/go/recommendationengine v0.8.1/go.mod h1:MrZihWwtFYWDzE6Hz5nKcNz3gLizXVIDI/o3G1DLcrE=\ncloud.google.com/go/recommender v1.5.0/go.mod h1:jdoeiBIVrJe9gQjwd759ecLJbxCDED4A6p+mqoqDvTg=\ncloud.google.com/go/recommender v1.6.0/go.mod h1:+yETpm25mcoiECKh9DEScGzIRyDKpZ0cEhWGo+8bo+c=\ncloud.google.com/go/recommender v1.7.0/go.mod h1:XLHs/W+T8olwlGOgfQenXBTbIseGclClff6lhFVe9Bs=\ncloud.google.com/go/recommender v1.8.0/go.mod h1:PkjXrTT05BFKwxaUxQmtIlrtj0kph108r02ZZQ5FE70=\ncloud.google.com/go/recommender v1.9.0/go.mod h1:PnSsnZY7q+VL1uax2JWkt/UegHssxjUVVCrX52CuEmQ=\ncloud.google.com/go/recommender v1.10.1/go.mod h1:XFvrE4Suqn5Cq0Lf+mCP6oBHD/yRMA8XxP5sb7Q7gpA=\ncloud.google.com/go/redis v1.7.0/go.mod h1:V3x5Jq1jzUcg+UNsRvdmsfuFnit1cfe3Z/PGyq/lm4Y=\ncloud.google.com/go/redis v1.8.0/go.mod h1:Fm2szCDavWzBk2cDKxrkmWBqoCiL1+Ctwq7EyqBCA/A=\ncloud.google.com/go/redis v1.9.0/go.mod h1:HMYQuajvb2D0LvMgZmLDZW8V5aOC/WxstZHiy4g8OiA=\ncloud.google.com/go/redis v1.10.0/go.mod h1:ThJf3mMBQtW18JzGgh41/Wld6vnDDc/F/F35UolRZPM=\ncloud.google.com/go/redis v1.11.0/go.mod h1:/X6eicana+BWcUda5PpwZC48o37SiFVTFSs0fWAJ7uQ=\ncloud.google.com/go/redis v1.13.1/go.mod h1:VP7DGLpE91M6bcsDdMuyCm2hIpB6Vp2hI090Mfd1tcg=\ncloud.google.com/go/resourcemanager v1.3.0/go.mod h1:bAtrTjZQFJkiWTPDb1WBjzvc6/kifjj4QBYuKCCoqKA=\ncloud.google.com/go/resourcemanager v1.4.0/go.mod h1:MwxuzkumyTX7/a3n37gmsT3py7LIXwrShilPh3P1tR0=\ncloud.google.com/go/resourcemanager v1.5.0/go.mod h1:eQoXNAiAvCf5PXxWxXjhKQoTMaUSNrEfg+6qdf/wots=\ncloud.google.com/go/resourcemanager v1.6.0/go.mod h1:YcpXGRs8fDzcUl1Xw8uOVmI8JEadvhRIkoXXUNVYcVo=\ncloud.google.com/go/resourcemanager v1.7.0/go.mod h1:HlD3m6+bwhzj9XCouqmeiGuni95NTrExfhoSrkC/3EI=\ncloud.google.com/go/resourcemanager v1.9.1/go.mod h1:dVCuosgrh1tINZ/RwBufr8lULmWGOkPS8gL5gqyjdT8=\ncloud.google.com/go/resourcesettings v1.3.0/go.mod h1:lzew8VfESA5DQ8gdlHwMrqZs1S9V87v3oCnKCWoOuQU=\ncloud.google.com/go/resourcesettings v1.4.0/go.mod h1:ldiH9IJpcrlC3VSuCGvjR5of/ezRrOxFtpJoJo5SmXg=\ncloud.google.com/go/resourcesettings v1.5.0/go.mod h1:+xJF7QSG6undsQDfsCJyqWXyBwUoJLhetkRMDRnIoXA=\ncloud.google.com/go/resourcesettings v1.6.1/go.mod h1:M7mk9PIZrC5Fgsu1kZJci6mpgN8o0IUzVx3eJU3y4Jw=\ncloud.google.com/go/retail v1.8.0/go.mod h1:QblKS8waDmNUhghY2TI9O3JLlFk8jybHeV4BF19FrE4=\ncloud.google.com/go/retail v1.9.0/go.mod h1:g6jb6mKuCS1QKnH/dpu7isX253absFl6iE92nHwlBUY=\ncloud.google.com/go/retail v1.10.0/go.mod h1:2gDk9HsL4HMS4oZwz6daui2/jmKvqShXKQuB2RZ+cCc=\ncloud.google.com/go/retail v1.11.0/go.mod h1:MBLk1NaWPmh6iVFSz9MeKG/Psyd7TAgm6y/9L2B4x9Y=\ncloud.google.com/go/retail v1.12.0/go.mod h1:UMkelN/0Z8XvKymXFbD4EhFJlYKRx1FGhQkVPU5kF14=\ncloud.google.com/go/retail v1.14.1/go.mod h1:y3Wv3Vr2k54dLNIrCzenyKG8g8dhvhncT2NcNjb/6gE=\ncloud.google.com/go/run v0.2.0/go.mod h1:CNtKsTA1sDcnqqIFR3Pb5Tq0usWxJJvsWOCPldRU3Do=\ncloud.google.com/go/run v0.3.0/go.mod h1:TuyY1+taHxTjrD0ZFk2iAR+xyOXEA0ztb7U3UNA0zBo=\ncloud.google.com/go/run v0.8.0/go.mod h1:VniEnuBwqjigv0A7ONfQUaEItaiCRVujlMqerPPiktM=\ncloud.google.com/go/run v0.9.0/go.mod h1:Wwu+/vvg8Y+JUApMwEDfVfhetv30hCG4ZwDR/IXl2Qg=\ncloud.google.com/go/scheduler v1.4.0/go.mod h1:drcJBmxF3aqZJRhmkHQ9b3uSSpQoltBPGPxGAWROx6s=\ncloud.google.com/go/scheduler v1.5.0/go.mod h1:ri073ym49NW3AfT6DZi21vLZrG07GXr5p3H1KxN5QlI=\ncloud.google.com/go/scheduler v1.6.0/go.mod h1:SgeKVM7MIwPn3BqtcBntpLyrIJftQISRrYB5ZtT+KOk=\ncloud.google.com/go/scheduler v1.7.0/go.mod h1:jyCiBqWW956uBjjPMMuX09n3x37mtyPJegEWKxRsn44=\ncloud.google.com/go/scheduler v1.8.0/go.mod h1:TCET+Y5Gp1YgHT8py4nlg2Sew8nUHMqcpousDgXJVQc=\ncloud.google.com/go/scheduler v1.9.0/go.mod h1:yexg5t+KSmqu+njTIh3b7oYPheFtBWGcbVUYF1GGMIc=\ncloud.google.com/go/scheduler v1.10.1/go.mod h1:R63Ldltd47Bs4gnhQkmNDse5w8gBRrhObZ54PxgR2Oo=\ncloud.google.com/go/secretmanager v1.6.0/go.mod h1:awVa/OXF6IiyaU1wQ34inzQNc4ISIDIrId8qE5QGgKA=\ncloud.google.com/go/secretmanager v1.8.0/go.mod h1:hnVgi/bN5MYHd3Gt0SPuTPPp5ENina1/LxM+2W9U9J4=\ncloud.google.com/go/secretmanager v1.9.0/go.mod h1:b71qH2l1yHmWQHt9LC80akm86mX8AL6X1MA01dW8ht4=\ncloud.google.com/go/secretmanager v1.10.0/go.mod h1:MfnrdvKMPNra9aZtQFvBcvRU54hbPD8/HayQdlUgJpU=\ncloud.google.com/go/secretmanager v1.11.1/go.mod h1:znq9JlXgTNdBeQk9TBW/FnR/W4uChEKGeqQWAJ8SXFw=\ncloud.google.com/go/security v1.5.0/go.mod h1:lgxGdyOKKjHL4YG3/YwIL2zLqMFCKs0UbQwgyZmfJl4=\ncloud.google.com/go/security v1.7.0/go.mod h1:mZklORHl6Bg7CNnnjLH//0UlAlaXqiG7Lb9PsPXLfD0=\ncloud.google.com/go/security v1.8.0/go.mod h1:hAQOwgmaHhztFhiQ41CjDODdWP0+AE1B3sX4OFlq+GU=\ncloud.google.com/go/security v1.9.0/go.mod h1:6Ta1bO8LXI89nZnmnsZGp9lVoVWXqsVbIq/t9dzI+2Q=\ncloud.google.com/go/security v1.10.0/go.mod h1:QtOMZByJVlibUT2h9afNDWRZ1G96gVywH8T5GUSb9IA=\ncloud.google.com/go/security v1.12.0/go.mod h1:rV6EhrpbNHrrxqlvW0BWAIawFWq3X90SduMJdFwtLB8=\ncloud.google.com/go/security v1.13.0/go.mod h1:Q1Nvxl1PAgmeW0y3HTt54JYIvUdtcpYKVfIB8AOMZ+0=\ncloud.google.com/go/security v1.15.1/go.mod h1:MvTnnbsWnehoizHi09zoiZob0iCHVcL4AUBj76h9fXA=\ncloud.google.com/go/securitycenter v1.13.0/go.mod h1:cv5qNAqjY84FCN6Y9z28WlkKXyWsgLO832YiWwkCWcU=\ncloud.google.com/go/securitycenter v1.14.0/go.mod h1:gZLAhtyKv85n52XYWt6RmeBdydyxfPeTrpToDPw4Auc=\ncloud.google.com/go/securitycenter v1.15.0/go.mod h1:PeKJ0t8MoFmmXLXWm41JidyzI3PJjd8sXWaVqg43WWk=\ncloud.google.com/go/securitycenter v1.16.0/go.mod h1:Q9GMaLQFUD+5ZTabrbujNWLtSLZIZF7SAR0wWECrjdk=\ncloud.google.com/go/securitycenter v1.18.1/go.mod h1:0/25gAzCM/9OL9vVx4ChPeM/+DlfGQJDwBy/UC8AKK0=\ncloud.google.com/go/securitycenter v1.19.0/go.mod h1:LVLmSg8ZkkyaNy4u7HCIshAngSQ8EcIRREP3xBnyfag=\ncloud.google.com/go/securitycenter v1.23.0/go.mod h1:8pwQ4n+Y9WCWM278R8W3nF65QtY172h4S8aXyI9/hsQ=\ncloud.google.com/go/servicecontrol v1.4.0/go.mod h1:o0hUSJ1TXJAmi/7fLJAedOovnujSEvjKCAFNXPQ1RaU=\ncloud.google.com/go/servicecontrol v1.5.0/go.mod h1:qM0CnXHhyqKVuiZnGKrIurvVImCs8gmqWsDoqe9sU1s=\ncloud.google.com/go/servicecontrol v1.10.0/go.mod h1:pQvyvSRh7YzUF2efw7H87V92mxU8FnFDawMClGCNuAA=\ncloud.google.com/go/servicecontrol v1.11.0/go.mod h1:kFmTzYzTUIuZs0ycVqRHNaNhgR+UMUpw9n02l/pY+mc=\ncloud.google.com/go/servicecontrol v1.11.1/go.mod h1:aSnNNlwEFBY+PWGQ2DoM0JJ/QUXqV5/ZD9DOLB7SnUk=\ncloud.google.com/go/servicedirectory v1.4.0/go.mod h1:gH1MUaZCgtP7qQiI+F+A+OpeKF/HQWgtAddhTbhL2bs=\ncloud.google.com/go/servicedirectory v1.5.0/go.mod h1:QMKFL0NUySbpZJ1UZs3oFAmdvVxhhxB6eJ/Vlp73dfg=\ncloud.google.com/go/servicedirectory v1.6.0/go.mod h1:pUlbnWsLH9c13yGkxCmfumWEPjsRs1RlmJ4pqiNjVL4=\ncloud.google.com/go/servicedirectory v1.7.0/go.mod h1:5p/U5oyvgYGYejufvxhgwjL8UVXjkuw7q5XcG10wx1U=\ncloud.google.com/go/servicedirectory v1.8.0/go.mod h1:srXodfhY1GFIPvltunswqXpVxFPpZjf8nkKQT7XcXaY=\ncloud.google.com/go/servicedirectory v1.9.0/go.mod h1:29je5JjiygNYlmsGz8k6o+OZ8vd4f//bQLtvzkPPT/s=\ncloud.google.com/go/servicedirectory v1.10.1/go.mod h1:Xv0YVH8s4pVOwfM/1eMTl0XJ6bzIOSLDt8f8eLaGOxQ=\ncloud.google.com/go/servicemanagement v1.4.0/go.mod h1:d8t8MDbezI7Z2R1O/wu8oTggo3BI2GKYbdG4y/SJTco=\ncloud.google.com/go/servicemanagement v1.5.0/go.mod h1:XGaCRe57kfqu4+lRxaFEAuqmjzF0r+gWHjWqKqBvKFo=\ncloud.google.com/go/servicemanagement v1.6.0/go.mod h1:aWns7EeeCOtGEX4OvZUWCCJONRZeFKiptqKf1D0l/Jc=\ncloud.google.com/go/servicemanagement v1.8.0/go.mod h1:MSS2TDlIEQD/fzsSGfCdJItQveu9NXnUniTrq/L8LK4=\ncloud.google.com/go/serviceusage v1.3.0/go.mod h1:Hya1cozXM4SeSKTAgGXgj97GlqUvF5JaoXacR1JTP/E=\ncloud.google.com/go/serviceusage v1.4.0/go.mod h1:SB4yxXSaYVuUBYUml6qklyONXNLt83U0Rb+CXyhjEeU=\ncloud.google.com/go/serviceusage v1.5.0/go.mod h1:w8U1JvqUqwJNPEOTQjrMHkw3IaIFLoLsPLvsE3xueec=\ncloud.google.com/go/serviceusage v1.6.0/go.mod h1:R5wwQcbOWsyuOfbP9tGdAnCAc6B9DRwPG1xtWMDeuPA=\ncloud.google.com/go/shell v1.3.0/go.mod h1:VZ9HmRjZBsjLGXusm7K5Q5lzzByZmJHf1d0IWHEN5X4=\ncloud.google.com/go/shell v1.4.0/go.mod h1:HDxPzZf3GkDdhExzD/gs8Grqk+dmYcEjGShZgYa9URw=\ncloud.google.com/go/shell v1.6.0/go.mod h1:oHO8QACS90luWgxP3N9iZVuEiSF84zNyLytb+qE2f9A=\ncloud.google.com/go/shell v1.7.1/go.mod h1:u1RaM+huXFaTojTbW4g9P5emOrrmLE69KrxqQahKn4g=\ncloud.google.com/go/spanner v1.41.0/go.mod h1:MLYDBJR/dY4Wt7ZaMIQ7rXOTLjYrmxLE/5ve9vFfWos=\ncloud.google.com/go/spanner v1.44.0/go.mod h1:G8XIgYdOK+Fbcpbs7p2fiprDw4CaZX63whnSMLVBxjk=\ncloud.google.com/go/spanner v1.45.0/go.mod h1:FIws5LowYz8YAE1J8fOS7DJup8ff7xJeetWEo5REA2M=\ncloud.google.com/go/spanner v1.47.0/go.mod h1:IXsJwVW2j4UKs0eYDqodab6HgGuA1bViSqW4uH9lfUI=\ncloud.google.com/go/speech v1.6.0/go.mod h1:79tcr4FHCimOp56lwC01xnt/WPJZc4v3gzyT7FoBkCM=\ncloud.google.com/go/speech v1.7.0/go.mod h1:KptqL+BAQIhMsj1kOP2la5DSEEerPDuOP/2mmkhHhZQ=\ncloud.google.com/go/speech v1.8.0/go.mod h1:9bYIl1/tjsAnMgKGHKmBZzXKEkGgtU+MpdDPTE9f7y0=\ncloud.google.com/go/speech v1.9.0/go.mod h1:xQ0jTcmnRFFM2RfX/U+rk6FQNUF6DQlydUSyoooSpco=\ncloud.google.com/go/speech v1.14.1/go.mod h1:gEosVRPJ9waG7zqqnsHpYTOoAS4KouMRLDFMekpJ0J0=\ncloud.google.com/go/speech v1.15.0/go.mod h1:y6oH7GhqCaZANH7+Oe0BhgIogsNInLlz542tg3VqeYI=\ncloud.google.com/go/speech v1.17.1/go.mod h1:8rVNzU43tQvxDaGvqOhpDqgkJTFowBpDvCJ14kGlJYo=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=\ncloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=\ncloud.google.com/go/storage v1.14.0/go.mod h1:GrKmX003DSIwi9o29oFT7YDnHYwZoctc3fOKtUw0Xmo=\ncloud.google.com/go/storage v1.22.1/go.mod h1:S8N1cAStu7BOeFfE8KAQzmyyLkK8p/vmRq6kuBTW58Y=\ncloud.google.com/go/storage v1.23.0/go.mod h1:vOEEDNFnciUMhBeT6hsJIn3ieU5cFRmzeLgDvXzfIXc=\ncloud.google.com/go/storage v1.27.0/go.mod h1:x9DOL8TK/ygDUMieqwfhdpQryTeEkhGKMi80i/iqR2s=\ncloud.google.com/go/storage v1.28.1/go.mod h1:Qnisd4CqDdo6BGs2AD5LLnEsmSQ80wQ5ogcBBKhU86Y=\ncloud.google.com/go/storage v1.29.0/go.mod h1:4puEjyTKnku6gfKoTfNOU/W+a9JyuVNxjpS5GBrB8h4=\ncloud.google.com/go/storage v1.30.1/go.mod h1:NfxhC0UJE1aXSx7CIIbCf7y9HKT7BiccwkR7+P7gN8E=\ncloud.google.com/go/storagetransfer v1.5.0/go.mod h1:dxNzUopWy7RQevYFHewchb29POFv3/AaBgnhqzqiK0w=\ncloud.google.com/go/storagetransfer v1.6.0/go.mod h1:y77xm4CQV/ZhFZH75PLEXY0ROiS7Gh6pSKrM8dJyg6I=\ncloud.google.com/go/storagetransfer v1.7.0/go.mod h1:8Giuj1QNb1kfLAiWM1bN6dHzfdlDAVC9rv9abHot2W4=\ncloud.google.com/go/storagetransfer v1.8.0/go.mod h1:JpegsHHU1eXg7lMHkvf+KE5XDJ7EQu0GwNJbbVGanEw=\ncloud.google.com/go/storagetransfer v1.10.0/go.mod h1:DM4sTlSmGiNczmV6iZyceIh2dbs+7z2Ayg6YAiQlYfA=\ncloud.google.com/go/talent v1.1.0/go.mod h1:Vl4pt9jiHKvOgF9KoZo6Kob9oV4lwd/ZD5Cto54zDRw=\ncloud.google.com/go/talent v1.2.0/go.mod h1:MoNF9bhFQbiJ6eFD3uSsg0uBALw4n4gaCaEjBw9zo8g=\ncloud.google.com/go/talent v1.3.0/go.mod h1:CmcxwJ/PKfRgd1pBjQgU6W3YBwiewmUzQYH5HHmSCmM=\ncloud.google.com/go/talent v1.4.0/go.mod h1:ezFtAgVuRf8jRsvyE6EwmbTK5LKciD4KVnHuDEFmOOA=\ncloud.google.com/go/talent v1.5.0/go.mod h1:G+ODMj9bsasAEJkQSzO2uHQWXHHXUomArjWQQYkqK6c=\ncloud.google.com/go/talent v1.6.2/go.mod h1:CbGvmKCG61mkdjcqTcLOkb2ZN1SrQI8MDyma2l7VD24=\ncloud.google.com/go/texttospeech v1.4.0/go.mod h1:FX8HQHA6sEpJ7rCMSfXuzBcysDAuWusNNNvN9FELDd8=\ncloud.google.com/go/texttospeech v1.5.0/go.mod h1:oKPLhR4n4ZdQqWKURdwxMy0uiTS1xU161C8W57Wkea4=\ncloud.google.com/go/texttospeech v1.6.0/go.mod h1:YmwmFT8pj1aBblQOI3TfKmwibnsfvhIBzPXcW4EBovc=\ncloud.google.com/go/texttospeech v1.7.1/go.mod h1:m7QfG5IXxeneGqTapXNxv2ItxP/FS0hCZBwXYqucgSk=\ncloud.google.com/go/tpu v1.3.0/go.mod h1:aJIManG0o20tfDQlRIej44FcwGGl/cD0oiRyMKG19IQ=\ncloud.google.com/go/tpu v1.4.0/go.mod h1:mjZaX8p0VBgllCzF6wcU2ovUXN9TONFLd7iz227X2Xg=\ncloud.google.com/go/tpu v1.5.0/go.mod h1:8zVo1rYDFuW2l4yZVY0R0fb/v44xLh3llq7RuV61fPM=\ncloud.google.com/go/tpu v1.6.1/go.mod h1:sOdcHVIgDEEOKuqUoi6Fq53MKHJAtOwtz0GuKsWSH3E=\ncloud.google.com/go/trace v1.3.0/go.mod h1:FFUE83d9Ca57C+K8rDl/Ih8LwOzWIV1krKgxg6N0G28=\ncloud.google.com/go/trace v1.4.0/go.mod h1:UG0v8UBqzusp+z63o7FK74SdFE+AXpCLdFb1rshXG+Y=\ncloud.google.com/go/trace v1.8.0/go.mod h1:zH7vcsbAhklH8hWFig58HvxcxyQbaIqMarMg9hn5ECA=\ncloud.google.com/go/trace v1.9.0/go.mod h1:lOQqpE5IaWY0Ixg7/r2SjixMuc6lfTFeO4QGM4dQWOk=\ncloud.google.com/go/trace v1.10.1/go.mod h1:gbtL94KE5AJLH3y+WVpfWILmqgc6dXcqgNXdOPAQTYk=\ncloud.google.com/go/translate v1.3.0/go.mod h1:gzMUwRjvOqj5i69y/LYLd8RrNQk+hOmIXTi9+nb3Djs=\ncloud.google.com/go/translate v1.4.0/go.mod h1:06Dn/ppvLD6WvA5Rhdp029IX2Mi3Mn7fpMRLPvXT5Wg=\ncloud.google.com/go/translate v1.5.0/go.mod h1:29YDSYveqqpA1CQFD7NQuP49xymq17RXNaUDdc0mNu0=\ncloud.google.com/go/translate v1.6.0/go.mod h1:lMGRudH1pu7I3n3PETiOB2507gf3HnfLV8qlkHZEyos=\ncloud.google.com/go/translate v1.7.0/go.mod h1:lMGRudH1pu7I3n3PETiOB2507gf3HnfLV8qlkHZEyos=\ncloud.google.com/go/translate v1.8.1/go.mod h1:d1ZH5aaOA0CNhWeXeC8ujd4tdCFw8XoNWRljklu5RHs=\ncloud.google.com/go/video v1.8.0/go.mod h1:sTzKFc0bUSByE8Yoh8X0mn8bMymItVGPfTuUBUyRgxk=\ncloud.google.com/go/video v1.9.0/go.mod h1:0RhNKFRF5v92f8dQt0yhaHrEuH95m068JYOvLZYnJSw=\ncloud.google.com/go/video v1.12.0/go.mod h1:MLQew95eTuaNDEGriQdcYn0dTwf9oWiA4uYebxM5kdg=\ncloud.google.com/go/video v1.13.0/go.mod h1:ulzkYlYgCp15N2AokzKjy7MQ9ejuynOJdf1tR5lGthk=\ncloud.google.com/go/video v1.14.0/go.mod h1:SkgaXwT+lIIAKqWAJfktHT/RbgjSuY6DobxEp0C5yTQ=\ncloud.google.com/go/video v1.15.0/go.mod h1:SkgaXwT+lIIAKqWAJfktHT/RbgjSuY6DobxEp0C5yTQ=\ncloud.google.com/go/video v1.17.1/go.mod h1:9qmqPqw/Ib2tLqaeHgtakU+l5TcJxCJbhFXM7UJjVzU=\ncloud.google.com/go/videointelligence v1.6.0/go.mod h1:w0DIDlVRKtwPCn/C4iwZIJdvC69yInhW0cfi+p546uU=\ncloud.google.com/go/videointelligence v1.7.0/go.mod h1:k8pI/1wAhjznARtVT9U1llUaFNPh7muw8QyOUpavru4=\ncloud.google.com/go/videointelligence v1.8.0/go.mod h1:dIcCn4gVDdS7yte/w+koiXn5dWVplOZkE+xwG9FgK+M=\ncloud.google.com/go/videointelligence v1.9.0/go.mod h1:29lVRMPDYHikk3v8EdPSaL8Ku+eMzDljjuvRs105XoU=\ncloud.google.com/go/videointelligence v1.10.0/go.mod h1:LHZngX1liVtUhZvi2uNS0VQuOzNi2TkY1OakiuoUOjU=\ncloud.google.com/go/videointelligence v1.11.1/go.mod h1:76xn/8InyQHarjTWsBR058SmlPCwQjgcvoW0aZykOvo=\ncloud.google.com/go/vision v1.2.0/go.mod h1:SmNwgObm5DpFBme2xpyOyasvBc1aPdjvMk2bBk0tKD0=\ncloud.google.com/go/vision/v2 v2.2.0/go.mod h1:uCdV4PpN1S0jyCyq8sIM42v2Y6zOLkZs+4R9LrGYwFo=\ncloud.google.com/go/vision/v2 v2.3.0/go.mod h1:UO61abBx9QRMFkNBbf1D8B1LXdS2cGiiCRx0vSpZoUo=\ncloud.google.com/go/vision/v2 v2.4.0/go.mod h1:VtI579ll9RpVTrdKdkMzckdnwMyX2JILb+MhPqRbPsY=\ncloud.google.com/go/vision/v2 v2.5.0/go.mod h1:MmaezXOOE+IWa+cS7OhRRLK2cNv1ZL98zhqFFZaaH2E=\ncloud.google.com/go/vision/v2 v2.6.0/go.mod h1:158Hes0MvOS9Z/bDMSFpjwsUrZ5fPrdwuyyvKSGAGMY=\ncloud.google.com/go/vision/v2 v2.7.0/go.mod h1:H89VysHy21avemp6xcf9b9JvZHVehWbET0uT/bcuY/0=\ncloud.google.com/go/vision/v2 v2.7.2/go.mod h1:jKa8oSYBWhYiXarHPvP4USxYANYUEdEsQrloLjrSwJU=\ncloud.google.com/go/vmmigration v1.2.0/go.mod h1:IRf0o7myyWFSmVR1ItrBSFLFD/rJkfDCUTO4vLlJvsE=\ncloud.google.com/go/vmmigration v1.3.0/go.mod h1:oGJ6ZgGPQOFdjHuocGcLqX4lc98YQ7Ygq8YQwHh9A7g=\ncloud.google.com/go/vmmigration v1.5.0/go.mod h1:E4YQ8q7/4W9gobHjQg4JJSgXXSgY21nA5r8swQV+Xxc=\ncloud.google.com/go/vmmigration v1.6.0/go.mod h1:bopQ/g4z+8qXzichC7GW1w2MjbErL54rk3/C843CjfY=\ncloud.google.com/go/vmmigration v1.7.1/go.mod h1:WD+5z7a/IpZ5bKK//YmT9E047AD+rjycCAvyMxGJbro=\ncloud.google.com/go/vmwareengine v0.1.0/go.mod h1:RsdNEf/8UDvKllXhMz5J40XxDrNJNN4sagiox+OI208=\ncloud.google.com/go/vmwareengine v0.2.2/go.mod h1:sKdctNJxb3KLZkE/6Oui94iw/xs9PRNC2wnNLXsHvH8=\ncloud.google.com/go/vmwareengine v0.3.0/go.mod h1:wvoyMvNWdIzxMYSpH/R7y2h5h3WFkx6d+1TIsP39WGY=\ncloud.google.com/go/vmwareengine v0.4.1/go.mod h1:Px64x+BvjPZwWuc4HdmVhoygcXqEkGHXoa7uyfTgSI0=\ncloud.google.com/go/vpcaccess v1.4.0/go.mod h1:aQHVbTWDYUR1EbTApSVvMq1EnT57ppDmQzZ3imqIk4w=\ncloud.google.com/go/vpcaccess v1.5.0/go.mod h1:drmg4HLk9NkZpGfCmZ3Tz0Bwnm2+DKqViEpeEpOq0m8=\ncloud.google.com/go/vpcaccess v1.6.0/go.mod h1:wX2ILaNhe7TlVa4vC5xce1bCnqE3AeH27RV31lnmZes=\ncloud.google.com/go/vpcaccess v1.7.1/go.mod h1:FogoD46/ZU+JUBX9D606X21EnxiszYi2tArQwLY4SXs=\ncloud.google.com/go/webrisk v1.4.0/go.mod h1:Hn8X6Zr+ziE2aNd8SliSDWpEnSS1u4R9+xXZmFiHmGE=\ncloud.google.com/go/webrisk v1.5.0/go.mod h1:iPG6fr52Tv7sGk0H6qUFzmL3HHZev1htXuWDEEsqMTg=\ncloud.google.com/go/webrisk v1.6.0/go.mod h1:65sW9V9rOosnc9ZY7A7jsy1zoHS5W9IAXv6dGqhMQMc=\ncloud.google.com/go/webrisk v1.7.0/go.mod h1:mVMHgEYH0r337nmt1JyLthzMr6YxwN1aAIEc2fTcq7A=\ncloud.google.com/go/webrisk v1.8.0/go.mod h1:oJPDuamzHXgUc+b8SiHRcVInZQuybnvEW72PqTc7sSg=\ncloud.google.com/go/webrisk v1.9.1/go.mod h1:4GCmXKcOa2BZcZPn6DCEvE7HypmEJcJkr4mtM+sqYPc=\ncloud.google.com/go/websecurityscanner v1.3.0/go.mod h1:uImdKm2wyeXQevQJXeh8Uun/Ym1VqworNDlBXQevGMo=\ncloud.google.com/go/websecurityscanner v1.4.0/go.mod h1:ebit/Fp0a+FWu5j4JOmJEV8S8CzdTkAS77oDsiSqYWQ=\ncloud.google.com/go/websecurityscanner v1.5.0/go.mod h1:Y6xdCPy81yi0SQnDY1xdNTNpfY1oAgXUlcfN3B3eSng=\ncloud.google.com/go/websecurityscanner v1.6.1/go.mod h1:Njgaw3rttgRHXzwCB8kgCYqv5/rGpFCsBOvPbYgszpg=\ncloud.google.com/go/workflows v1.6.0/go.mod h1:6t9F5h/unJz41YqfBmqSASJSXccBLtD1Vwf+KmJENM0=\ncloud.google.com/go/workflows v1.7.0/go.mod h1:JhSrZuVZWuiDfKEFxU0/F1PQjmpnpcoISEXH2bcHC3M=\ncloud.google.com/go/workflows v1.8.0/go.mod h1:ysGhmEajwZxGn1OhGOGKsTXc5PyxOc0vfKf5Af+to4M=\ncloud.google.com/go/workflows v1.9.0/go.mod h1:ZGkj1aFIOd9c8Gerkjjq7OW7I5+l6cSvT3ujaO/WwSA=\ncloud.google.com/go/workflows v1.10.0/go.mod h1:fZ8LmRmZQWacon9UCX1r/g/DfAXx5VcPALq2CxzdePw=\ncloud.google.com/go/workflows v1.11.1/go.mod h1:Z+t10G1wF7h8LgdY/EmRcQY8ptBD/nvofaL6FqlET6g=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngioui.org v0.0.0-20210308172011-57750fc8a0a6/go.mod h1:RSH6KIUZ0p2xy5zHDxgAM4zumjgTw83q2ge/PI+yyw8=\ngit.sr.ht/~sbinet/gg v0.3.1/go.mod h1:KGYtlADtqsqANL9ueOFkWymvzUvLMQllU5Ixo+8v3pc=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/JohnCGriffin/overflow v0.0.0-20211019200055-46fa312c352c/go.mod h1:X0CRv0ky0k6m906ixxpzmDRLvX58TFUKS2eePweuyxk=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/ajstarks/deck v0.0.0-20200831202436-30c9fc6549a9/go.mod h1:JynElWSGnm/4RlzPXRlREEwqTHAN3T56Bv2ITsFT3gY=\ngithub.com/ajstarks/deck/generate v0.0.0-20210309230005-c3f852c02e19/go.mod h1:T13YZdzov6OU0A1+RfKZiZN9ca6VeKdBdyDV+BY97Tk=\ngithub.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=\ngithub.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b/go.mod h1:1KcenG0jGWcpt8ov532z81sp/kMMUG485J2InIOyADM=\ngithub.com/andybalholm/brotli v1.0.4/go.mod h1:fO7iG3H7G2nSZ7m0zPUDn85XEX2GTukHGRSepvi9Eig=\ngithub.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=\ngithub.com/apache/arrow/go/v10 v10.0.1/go.mod h1:YvhnlEePVnBS4+0z3fhPfUy7W1Ikj0Ih0vcRo/gZ1M0=\ngithub.com/apache/arrow/go/v11 v11.0.0/go.mod h1:Eg5OsL5H+e299f7u5ssuXsuHQVEGC4xei5aX110hRiI=\ngithub.com/apache/arrow/go/v12 v12.0.0/go.mod h1:d+tV/eHZZ7Dz7RPrFKtPK02tpr+c9/PEd/zm8mDS9Vg=\ngithub.com/apache/thrift v0.16.0/go.mod h1:PHK3hniurgQaNMZYaCLEqXKsYK8upmhPbmdP2FXSqgU=\ngithub.com/boombuler/barcode v1.0.0/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/boombuler/barcode v1.0.1/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/bufbuild/protocompile v0.4.0 h1:LbFKd2XowZvQ/kajzguUp2DC9UEIQhIq77fZZlaQsNA=\ngithub.com/bufbuild/protocompile v0.4.0/go.mod h1:3v93+mbWn/v3xzN+31nwkJfrEpAUwp+BagBSZWx+TP8=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.3.0/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=\ngithub.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=\ngithub.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=\ngithub.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=\ngithub.com/cncf/xds/go v0.0.0-20210312221358-fbca930ec8ed/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20210805033703-aa0b78936158/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20220314180256-7f1daf1720fc/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20230105202645-06c439db220b/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20230310173818-32f1caf87195/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20230428030218-4003588d1b74/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20230607035331-e9ce68804cb4/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/docopt/docopt-go v0.0.0-20180111231733-ee0de3bc6815/go.mod h1:WwZ+bS3ebgob9U8Nd0kOddGdZWjyMGR8Wziv+TBNwSE=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/go-control-plane v0.9.7/go.mod h1:cwu0lG7PUMfa9snN8LXBig5ynNVH9qI8YYLbd1fK2po=\ngithub.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=\ngithub.com/envoyproxy/go-control-plane v0.9.9-0.20210217033140-668b12f5399d/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=\ngithub.com/envoyproxy/go-control-plane v0.9.9-0.20210512163311-63b5d3c536b0/go.mod h1:hliV/p42l8fGbc6Y9bQ70uLwIvmJyVE5k4iMKlh8wCQ=\ngithub.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021/go.mod h1:AFq3mo9L8Lqqiid3OhADV3RfLJnjiw63cSpi+fDTRC0=\ngithub.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=\ngithub.com/envoyproxy/go-control-plane v0.10.3/go.mod h1:fJJn/j26vwOu972OllsvAgJJM//w9BV6Fxbg2LuVd34=\ngithub.com/envoyproxy/go-control-plane v0.11.0/go.mod h1:VnHyVMpzcLvCFt9yUz1UnCwHLhwx1WguiVDV7pTG/tI=\ngithub.com/envoyproxy/go-control-plane v0.11.1-0.20230524094728-9239064ad72f/go.mod h1:sfYdkwUW4BA3PbKjySwjJy+O4Pu0h62rlqCMHNk+K+Q=\ngithub.com/envoyproxy/go-control-plane v0.11.1/go.mod h1:uhMcXKCQMEJHiAb0w+YGefQLaTEw+YhGluxZkrTmD0g=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/envoyproxy/protoc-gen-validate v0.6.7/go.mod h1:dyJXwwfPK2VSqiB9Klm1J6romD608Ba7Hij42vrOBCo=\ngithub.com/envoyproxy/protoc-gen-validate v0.9.1/go.mod h1:OKNgG7TCp5pF4d6XftA0++PMirau2/yoOwVac3AbF2w=\ngithub.com/envoyproxy/protoc-gen-validate v0.10.0/go.mod h1:DRjgyB0I43LtJapqN6NiRwroiAU2PaFuvk/vjgh61ss=\ngithub.com/envoyproxy/protoc-gen-validate v0.10.1/go.mod h1:DRjgyB0I43LtJapqN6NiRwroiAU2PaFuvk/vjgh61ss=\ngithub.com/envoyproxy/protoc-gen-validate v1.0.1/go.mod h1:0vj8bNkYbSTNS2PIyH87KZaeN4x9zpL9Qt8fQC7d+vs=\ngithub.com/envoyproxy/protoc-gen-validate v1.0.2/go.mod h1:GpiZQP3dDbg4JouG/NNS7QWXpgx6x8QiMKdmN72jogE=\ngithub.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fogleman/gg v1.2.1-0.20190220221249-0403632d5b90/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/fogleman/gg v1.3.0/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-fonts/dejavu v0.1.0/go.mod h1:4Wt4I4OU2Nq9asgDCteaAaWZOV24E+0/Pwo0gppep4g=\ngithub.com/go-fonts/latin-modern v0.2.0/go.mod h1:rQVLdDMK+mK1xscDwsqM5J8U2jrRa3T0ecnM9pNujks=\ngithub.com/go-fonts/liberation v0.1.1/go.mod h1:K6qoJYypsmfVjWg8KOVDQhLc8UDgIK2HYqyqAO9z7GY=\ngithub.com/go-fonts/liberation v0.2.0/go.mod h1:K6qoJYypsmfVjWg8KOVDQhLc8UDgIK2HYqyqAO9z7GY=\ngithub.com/go-fonts/stix v0.1.0/go.mod h1:w/c1f0ldAUlJmLBvlbkvVXLAD+tAMqobIIQpmnUIzUY=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-latex/latex v0.0.0-20210118124228-b3d85cf34e07/go.mod h1:CO1AlKB2CSIqUrmQPqA0gdRIlnLEY0gK5JGjh37zN5U=\ngithub.com/go-latex/latex v0.0.0-20210823091927-c0d11ff05a81/go.mod h1:SX0U8uGpxhq9o2S/CELCSUxEWWAuoCUcVCQWv7G2OCk=\ngithub.com/go-pdf/fpdf v0.5.0/go.mod h1:HzcnA+A23uwogo0tp9yU+l3V+KXhiESpt1PMayhOh5M=\ngithub.com/go-pdf/fpdf v0.6.0/go.mod h1:HzcnA+A23uwogo0tp9yU+l3V+KXhiESpt1PMayhOh5M=\ngithub.com/goccy/go-json v0.9.11/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/glog v1.0.0/go.mod h1:EWib/APOK0SL3dFbYqvxE3UYd8E6s1ouQ7iEp/0LWV4=\ngithub.com/golang/glog v1.1.0/go.mod h1:pfYeQZ3JWZoXTV5sFc986z3HTpwQs9At6P4ImfuP3NQ=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngithub.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=\ngithub.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.1/go.mod h1:DopwsBzvsk0Fs44TXzsVbJyPhcCPeIwnvohx4u74HPM=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/flatbuffers v2.0.8+incompatible/go.mod h1:1AeVuKshWv4vARoZatz6mlQ0JxURH0Kv5+zNeJKJCa8=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=\ngithub.com/google/go-cmp v0.5.8/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/martian/v3 v3.2.1/go.mod h1:oBOf6HBosgwRXnUGWUB05QECsc6uvmMiJ3+6W4l/CUk=\ngithub.com/google/martian/v3 v3.3.2/go.mod h1:oBOf6HBosgwRXnUGWUB05QECsc6uvmMiJ3+6W4l/CUk=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20201218002935-b9804c9f04c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210122040257-d980be63207e/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210226084205-cbba55b83ad5/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210601050228-01bbb1931b22/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210609004039-a478d1d731e9/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210720184732-4bb14d4b1be1/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/s2a-go v0.1.0/go.mod h1:OJpEgntRZo8ugHpF9hkoLJbS5dSI20XZeXJ9JVywLlM=\ngithub.com/google/s2a-go v0.1.3/go.mod h1:Ej+mSEMGRnqRzjc7VtF+jdBwYG5fuJfiZ8ELkjEwM0A=\ngithub.com/google/s2a-go v0.1.4/go.mod h1:Ej+mSEMGRnqRzjc7VtF+jdBwYG5fuJfiZ8ELkjEwM0A=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.0.0-20220520183353-fd19c99a87aa/go.mod h1:17drOmN3MwGY7t0e+Ei9b45FFGA3fBs3x36SsCg1hq8=\ngithub.com/googleapis/enterprise-certificate-proxy v0.1.0/go.mod h1:17drOmN3MwGY7t0e+Ei9b45FFGA3fBs3x36SsCg1hq8=\ngithub.com/googleapis/enterprise-certificate-proxy v0.2.0/go.mod h1:8C0jb7/mgJe/9KK8Lm7X9ctZC2t60YyIpYEI16jx0Qg=\ngithub.com/googleapis/enterprise-certificate-proxy v0.2.1/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=\ngithub.com/googleapis/enterprise-certificate-proxy v0.2.3/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/googleapis/gax-go/v2 v2.1.0/go.mod h1:Q3nei7sK6ybPYH7twZdmQpAd1MKb7pfu6SK+H1/DsU0=\ngithub.com/googleapis/gax-go/v2 v2.1.1/go.mod h1:hddJymUZASv3XPyGkUpKj8pPO47Rmb0eJc8R6ouapiM=\ngithub.com/googleapis/gax-go/v2 v2.2.0/go.mod h1:as02EH8zWkzwUoLbBaFeQ+arQaj/OthfcblKl4IGNaM=\ngithub.com/googleapis/gax-go/v2 v2.3.0/go.mod h1:b8LNqSzNabLiUpXKkY7HAR5jr6bIT99EXz9pXxye9YM=\ngithub.com/googleapis/gax-go/v2 v2.4.0/go.mod h1:XOTVJ59hdnfJLIP/dh8n5CGryZR2LxK9wbMD5+iXC6c=\ngithub.com/googleapis/gax-go/v2 v2.5.1/go.mod h1:h6B0KMMFNtI2ddbGJn3T3ZbwkeT6yqEF02fYlzkUCyo=\ngithub.com/googleapis/gax-go/v2 v2.6.0/go.mod h1:1mjbznJAPHFpesgE5ucqfYEscaz5kMdcIDwU/6+DDoY=\ngithub.com/googleapis/gax-go/v2 v2.7.0/go.mod h1:TEop28CZZQ2y+c0VxMUmu1lV+fQx57QpBWsYpwqHJx8=\ngithub.com/googleapis/gax-go/v2 v2.7.1/go.mod h1:4orTrqY6hXxxaUL4LHIPl6lGo8vAE38/qKbhSAKP6QI=\ngithub.com/googleapis/gax-go/v2 v2.8.0/go.mod h1:4orTrqY6hXxxaUL4LHIPl6lGo8vAE38/qKbhSAKP6QI=\ngithub.com/googleapis/gax-go/v2 v2.10.0/go.mod h1:4UOEnMCrxsSqQ940WnTiD6qJ63le2ev3xfyagutxiPw=\ngithub.com/googleapis/gax-go/v2 v2.11.0/go.mod h1:DxmR61SGKkGLa2xigwuZIQpkCI2S5iydzRfb3peWZJI=\ngithub.com/googleapis/go-type-adapters v1.0.0/go.mod h1:zHW75FOG2aur7gAO2B+MLby+cLsWGBF62rFAi7WjWO4=\ngithub.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8/go.mod h1:dvDLG8qkwmyD9a/MJJN3XJcT3xFxOKAvTZGvuZmac9g=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.7.0/go.mod h1:hgWBS7lorOAVIJEQMi4ZsPv9hVvWI6+ch50m39Pf2Ks=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.11.3/go.mod h1:o//XUCC/F+yRGJoPO/VU0GSB0f8Nhgmxx0VIRUvaC0w=\ngithub.com/hashicorp/go-hclog v0.14.1 h1:nQcJDQwIAGnmoUWp8ubocEX40cCml/17YkF6csQLReU=\ngithub.com/hashicorp/go-hclog v0.14.1/go.mod h1:whpDNt7SSdeAju8AWKIWsul05p54N/39EeqMAyrmvFQ=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/yamux v0.1.1 h1:yrQxtgseBDrq9Y652vSRDvsKCJKOUD+GzTS4Y0Y8pvE=\ngithub.com/hashicorp/yamux v0.1.1/go.mod h1:CtWFDAQgb7dxtzFs4tWbplKIe2jSi3+5vKbgIO0SLnQ=\ngithub.com/iancoleman/strcase v0.2.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/jhump/gopoet v0.0.0-20190322174617-17282ff210b3/go.mod h1:me9yfT6IJSlOL3FCfrg+L6yzUEZ+5jW6WHt4Sk+UPUI=\ngithub.com/jhump/gopoet v0.1.0/go.mod h1:me9yfT6IJSlOL3FCfrg+L6yzUEZ+5jW6WHt4Sk+UPUI=\ngithub.com/jhump/goprotoc v0.5.0/go.mod h1:VrbvcYrQOrTi3i0Vf+m+oqQWk9l72mjkJCYo7UvLHRQ=\ngithub.com/jhump/protoreflect v1.11.0/go.mod h1:U7aMIjN0NWq9swDP7xDdoMfRHb35uiuTd3Z9nFXJf5E=\ngithub.com/jhump/protoreflect v1.15.1 h1:HUMERORf3I3ZdX05WaQ6MIpd/NJ434hTp5YiKgfCL6c=\ngithub.com/jhump/protoreflect v1.15.1/go.mod h1:jD/2GMKKE6OqX8qTjhADU1e6DShO+gavG9e0Q693nKo=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/asmfmt v1.3.2/go.mod h1:AG8TuvYojzulgDAMCnYn50l/5QV3Bs/tp6j0HLHbNSE=\ngithub.com/klauspost/compress v1.15.9/go.mod h1:PhcZ0MbTNciWF3rruxRgKxI5NkcHHrHUDtV4Yw2GlzU=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/lyft/protoc-gen-star v0.6.0/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=\ngithub.com/lyft/protoc-gen-star v0.6.1/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=\ngithub.com/lyft/protoc-gen-star/v2 v2.0.1/go.mod h1:RcCdONR2ScXaYnQC5tUzxzlpA3WVYF7/opLeUgcQs/o=\ngithub.com/lyft/protoc-gen-star/v2 v2.0.3/go.mod h1:amey7yeodaJhXSbf/TlLvWiqQfLOSpEk//mLlc+axEk=\ngithub.com/mattn/go-colorable v0.1.4 h1:snbPLB8fVfU9iwbbo30TPtbLRzwWu6aJS6Xh4eaaviA=\ngithub.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.10/go.mod h1:qgIWMr58cqv1PHHyhnkY9lrL7etaEgOFcMEpPG5Rm84=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.17 h1:BTarxUcIeDqL27Mc+vyvdWYSL28zpIhv3RoTdsLMPng=\ngithub.com/mattn/go-isatty v0.0.17/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-sqlite3 v1.14.14/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=\ngithub.com/mattn/go-sqlite3 v1.14.15/go.mod h1:2eHXhiwb8IkHr+BDWZGa96P6+rkvnG63S2DGjv9HUNg=\ngithub.com/minio/asm2plan9s v0.0.0-20200509001527-cdd76441f9d8/go.mod h1:mC1jAcsrzbxHt8iiaC+zU4b1ylILSosueou12R++wfY=\ngithub.com/minio/c2goasm v0.0.0-20190812172519-36a3d3bbc4f3/go.mod h1:RagcQ7I8IeTMnF8JTXieKnO4Z6JCsikNEzj0DwauVzE=\ngithub.com/oklog/run v1.0.0 h1:Ru7dDtJNOyC66gQ5dQmaCa0qIsAUFY3sFpK1Xk8igrw=\ngithub.com/oklog/run v1.0.0/go.mod h1:dlhp/R75TPv97u0XWUtDeV/lRKWPKSdTuV0TZvrmrQA=\ngithub.com/phpdave11/gofpdf v1.4.2/go.mod h1:zpO6xFn9yxo3YLyMvW8HcKWVdbNqgIfOOp2dXMnm1mY=\ngithub.com/phpdave11/gofpdi v1.0.12/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=\ngithub.com/phpdave11/gofpdi v1.0.13/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=\ngithub.com/pierrec/lz4/v4 v4.1.15/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=\ngithub.com/pkg/sftp v1.13.1/go.mod h1:3HaPG6Dq1ILlpPZRO0HVMrsydcdLt6HRDccSgb87qRg=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.3.0/go.mod h1:LDGWKZIo7rky3hgvBe+caln+Dr3dPggB5dvjtD7w9+w=\ngithub.com/prometheus/client_model v0.4.0/go.mod h1:oMQmHW1/JoDwqLtg57MGgP/Fb1CJEYF2imWWhWtMkYU=\ngithub.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=\ngithub.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58/go.mod h1:6lfFZQK844Gfx8o5WFuvpxWRwnSoipWe/p622j1v06w=\ngithub.com/ruudk/golang-pdf417 v0.0.0-20201230142125-a7e3863a1245/go.mod h1:pQAZKsJ8yyVxGRWYNEm9oFB8ieLgKFnamEyDmSA0BRk=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.3.3/go.mod h1:5KUK8ByomD5Ti5Artl0RtHeI5pTF7MIDuXL3yY520V4=\ngithub.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=\ngithub.com/spf13/afero v1.9.2/go.mod h1:iUV7ddyEEZPO5gA3zD4fJt6iStLlL+Lg4m2cihcDf8Y=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.3 h1:RP3t2pwF7cMEbC1dqtB6poj3niw/9gnV4Cjg5oW5gtY=\ngithub.com/stretchr/testify v1.8.3/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/goldmark v1.4.1/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngithub.com/zeebo/assert v1.3.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=\ngithub.com/zeebo/xxh3 v1.0.2/go.mod h1:5NWz9Sef7zIDm2JHfFlcQvNekmcEl9ekUZQQKCYaDcA=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=\ngo.opencensus.io v0.23.0/go.mod h1:XItmlyltB5F7CS4xOC1DcqMoFqwtC6OG2xF7mCv7P7E=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=\ngo.opentelemetry.io/proto/otlp v0.15.0/go.mod h1:H7XAot3MsfNsj7EXtrA2q5xSNQ10UqI405h3+duxN4U=\ngo.opentelemetry.io/proto/otlp v0.19.0/go.mod h1:H7XAot3MsfNsj7EXtrA2q5xSNQ10UqI405h3+duxN4U=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.0.0-20211108221036-ceb1ce70b4fa/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.0.0-20220314234659-1baeb1ce4c0b/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\ngolang.org/x/crypto v0.7.0/go.mod h1:pYwdfH91IfpZVANVyUOhSIPZaFoJGxTFbZhFTx+dXZU=\ngolang.org/x/crypto v0.9.0/go.mod h1:yrmDGqONDYtNj3tH8X9dzUun2m2lzPa9ngI6/RUPGR0=\ngolang.org/x/crypto v0.10.0/go.mod h1:o4eNf7Ede1fv+hwOwZsTHl9EsPFO6q6ZvYR8vYfY45I=\ngolang.org/x/crypto v0.11.0/go.mod h1:xgJhtzW8F9jGdVFWZESrid1U1bjeNy4zgy5cRr/CIio=\ngolang.org/x/crypto v0.14.0/go.mod h1:MVFd36DqK4CsrnJYDkBA3VC4m2GkXAM0PvzMCn4JQf4=\ngolang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191002040644-a1355ae1e2c3/go.mod h1:NOZ3BPKG0ec/BKJQgnvsSFpcKLM5xXVWnvZS97DWHgE=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/exp v0.0.0-20220827204233-334a2380cb91/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=\ngolang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20190910094157-69e4b8554b2a/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20200119044424-58c23975cae1/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20200430140353-33d19683fad8/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20200618115811-c13761719519/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20201208152932-35266b937fa6/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20210216034530-4410531fe030/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20210607152325-775e3b0c77b9/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=\ngolang.org/x/image v0.0.0-20210628002857-a66eb6448b8d/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=\ngolang.org/x/image v0.0.0-20211028202545-6944b10bf410/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=\ngolang.org/x/image v0.0.0-20220302094943-723b81ca9867/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.5.0/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=\ngolang.org/x/mod v0.5.1/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.7.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.10.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.11.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210119194325-5f4716e94777/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210316092652-d523dce5a7f4/go.mod h1:RBQZq4jEuRlivfhVLdyRGr576XBO4/greRjx4P4O3yc=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.0.0-20210503060351-7fd8e65b6420/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210813160813-60bc85c4be6d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211015210444-4f30a5c0130f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220225172249-27dd8689420f/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220325170049-de3da57026de/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220412020605-290c469a71a5/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220425223048-2871e0cb64e4/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220607020251-c690dde0001d/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.0.0-20220617184016-355a448f1bc9/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.0.0-20220624214902-1bab6f366d9e/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.0.0-20220909164309-bea034e7d591/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=\ngolang.org/x/net v0.0.0-20221012135044-0b7e1fb9d458/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=\ngolang.org/x/net v0.0.0-20221014081412-f15817d10f9b/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=\ngolang.org/x/net v0.1.0/go.mod h1:Cx3nUiGt4eDBEyega/BKRp+/AlGL8hYe7U9odMt2Cco=\ngolang.org/x/net v0.2.0/go.mod h1:KqCZLdyyvdV855qA2rE3GC2aiw5xGR5TEjj8smXukLY=\ngolang.org/x/net v0.4.0/go.mod h1:MBQ8lrhLObU/6UmLb4fmbmk5OcyYmqtbGd/9yIeKjEE=\ngolang.org/x/net v0.5.0/go.mod h1:DivGGAXEgPSlEBzxGzZI+ZLohi+xUj054jfeKui00ws=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.8.0/go.mod h1:QVkue5JL9kW//ek3r6jTKnTFis1tRmNAW2P1shuFdJc=\ngolang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.11.0/go.mod h1:2L/ixqYpgIVXmeoSA/4Lu7BzTG4KIyPIryS4IsOd1oQ=\ngolang.org/x/net v0.12.0/go.mod h1:zEVYFnQC7m/vmpQFELhcD1EWkZlX69l4oqgmer6hfKA=\ngolang.org/x/net v0.17.0 h1:pVaXccu2ozPjCXewfr1S7xza/zcXTity9cCdXQYSjIM=\ngolang.org/x/net v0.17.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210220000619-9bb904979d93/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210313182246-cd4f82c27b84/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210628180205-a41e5a781914/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210805134026-6f1e6394065a/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20211104180415-d3ed0bb246c8/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20220223155221-ee480838109b/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=\ngolang.org/x/oauth2 v0.0.0-20220309155454-6242fa91716a/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=\ngolang.org/x/oauth2 v0.0.0-20220411215720-9780585627b5/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=\ngolang.org/x/oauth2 v0.0.0-20220608161450-d0670ef3b1eb/go.mod h1:jaDAt6Dkxork7LmZnYtzbRWj0W47D86a3TGe0YHBvmE=\ngolang.org/x/oauth2 v0.0.0-20220622183110-fd043fe589d2/go.mod h1:jaDAt6Dkxork7LmZnYtzbRWj0W47D86a3TGe0YHBvmE=\ngolang.org/x/oauth2 v0.0.0-20220822191816-0ebed06d0094/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=\ngolang.org/x/oauth2 v0.0.0-20220909003341-f21342109be1/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=\ngolang.org/x/oauth2 v0.0.0-20221006150949-b44042a4b9c1/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=\ngolang.org/x/oauth2 v0.0.0-20221014153046-6fdb5e3db783/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=\ngolang.org/x/oauth2 v0.4.0/go.mod h1:RznEsdpjGAINPTOF0UH/t+xJ75L18YO3Ho6Pyn+uRec=\ngolang.org/x/oauth2 v0.5.0/go.mod h1:9/XBHVqLaWO3/BRHs5jbpYCnOZVjj5V0ndyaAM7KB4I=\ngolang.org/x/oauth2 v0.6.0/go.mod h1:ycmewcwgD4Rpr3eZJLSB4Kyyljb3qDh40vJ8STE5HKw=\ngolang.org/x/oauth2 v0.7.0/go.mod h1:hPLQkd9LyjfXTiRohC/41GhcFqxisoUQ99sCUOHO9x4=\ngolang.org/x/oauth2 v0.8.0/go.mod h1:yr7u4HXZRm1R1kBWqr/xKNqewf0plRYoB7sla+BCIXE=\ngolang.org/x/oauth2 v0.10.0/go.mod h1:kTpgurOux7LqtuxjuyZa4Gj2gdezIt/jQtGnNFfypQI=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220819030929-7fc1605a5dde/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220929204114-8fcdb60fdcc0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.2.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191008105621-543471e840be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210220050731-9a76102bfb43/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210225134936-a50acf3fe073/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210304124612-50617c2ba197/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210305230114-8fe3ee5dd75b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210315160823-c6e025ad8005/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210514084401-e8d321eab015/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210603125802-9665404d3644/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210806184541-e5e7981a1069/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210816183151-1e6c022a8912/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210823070655-63515b42dcdf/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210908233432-aa78b53d3365/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211007075335-d3039528d8ac/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211019181941-9d821ace8654/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211124211545-fe61309f8881/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211210111614-af8b64212486/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220209214540-3681064d5158/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220227234510-4e6760a101f9/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220328115105-d36c6a25d886/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220502124256-b6088ccd6cba/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220503163025-988cb79eb6c6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220610221304-9f5ed59c137d/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220615213510-4f61da869c0c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220624220833-87e55d714810/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220728004956-3c1f35247d10/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220829200755-d48e67d00261/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.9.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.13.0 h1:Af8nKPmuFypiUBjVoU9V20FiaFXOcuZI21p0ycVYYGE=\ngolang.org/x/sys v0.13.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=\ngolang.org/x/term v0.3.0/go.mod h1:q750SLmJuPmVoN1blW3UFBPREJfb1KmY3vwxfr+nFDA=\ngolang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.6.0/go.mod h1:m6U89DPEgQRMq3DNkDClhWw02AUbt2daBVO4cn4Hv9U=\ngolang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.9.0/go.mod h1:M6DEAAIenWoTxdKrOltXcmDY3rSplQUkrvaDU5FcQyo=\ngolang.org/x/term v0.10.0/go.mod h1:lpqdcUyK/oCiQxvxVrppt5ggO2KCZ5QblwqPnfZ6d5o=\ngolang.org/x/term v0.13.0/go.mod h1:LTmsnFJwVN6bCy1rVCoS+qHT1HhALEFxKncY3WNNh4U=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.5.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.10.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.11.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.13.0 h1:ablQoSUd0tRdKxZewP80B+BaqeKJuVhuRxj/dkrun3k=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20220922220347-f3bd1da661af/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.1.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.3.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190206041539-40960b6deb8e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190927191325-030b2cf1153e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=\ngolang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=\ngolang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201124115921-2c860bdd6e78/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210108195828-e2f9c7f1fc8e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\ngolang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.4/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.9/go.mod h1:nABZi5QlRsZVlzPpHl034qft6wpY4eDcsTt5AaioBiU=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.3.0/go.mod h1:/rWhSS2+zyEVwoJf8YAX6L2f0ntZ7Kn/mGgAWcipA5k=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=\ngolang.org/x/tools v0.8.0/go.mod h1:JxBZ99ISMI5ViVkT1tr6tdNmXeTrcpVSD3vZ1RsRdN4=\ngolang.org/x/tools v0.9.1/go.mod h1:owI94Op576fPu3cIGQeHs3joujW/2Oc6MtlxbF5dfNc=\ngolang.org/x/tools v0.10.0/go.mod h1:UJwyiVBsOA2uwvK/e5OY3GTpDUJriEd+/YlqAwLPmyM=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20220411194840-2f41105eb62f/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20220517211312-f3a8303e98df/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\ngolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\ngolang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\ngonum.org/v1/gonum v0.0.0-20180816165407-929014505bf4/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=\ngonum.org/v1/gonum v0.8.2/go.mod h1:oe/vMfY3deqTw+1EZJhuvEW2iwGF1bW9wwu7XCu0+v0=\ngonum.org/v1/gonum v0.9.3/go.mod h1:TZumC3NeyVQskjXqmyWt4S3bINhy7B4eYwW69EbyX+0=\ngonum.org/v1/gonum v0.11.0/go.mod h1:fSG4YDCxxUZQJ7rKsQrj0gMOg00Il0Z96/qMA4bVQhA=\ngonum.org/v1/netlib v0.0.0-20190313105609-8cb42192e0e0/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=\ngonum.org/v1/plot v0.0.0-20190515093506-e2840ee46a6b/go.mod h1:Wt8AAjI+ypCyYX3nZBvf6cAIx93T+c/OS2HFAYskSZc=\ngonum.org/v1/plot v0.9.0/go.mod h1:3Pcqqmp6RHvJI72kgb8fThyUnav364FOsdDo2aGW5lY=\ngonum.org/v1/plot v0.10.1/go.mod h1:VZW5OlhkL1mysU9vaqNHnsy86inf6Ot+jB3r+BczCEo=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=\ngoogle.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=\ngoogle.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=\ngoogle.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=\ngoogle.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=\ngoogle.golang.org/api v0.41.0/go.mod h1:RkxM5lITDfTzmyKFPt+wGrCJbVfniCr2ool8kTBzRTU=\ngoogle.golang.org/api v0.43.0/go.mod h1:nQsDGjRXMo4lvh5hP0TKqF244gqhGcr/YSIykhUk/94=\ngoogle.golang.org/api v0.47.0/go.mod h1:Wbvgpq1HddcWVtzsVLyfLp8lDg6AA241LmgIL59tHXo=\ngoogle.golang.org/api v0.48.0/go.mod h1:71Pr1vy+TAZRPkPs/xlCf5SsU8WjuAWv1Pfjbtukyy4=\ngoogle.golang.org/api v0.50.0/go.mod h1:4bNT5pAuq5ji4SRZm+5QIkjny9JAyVD/3gaSihNefaw=\ngoogle.golang.org/api v0.51.0/go.mod h1:t4HdrdoNgyN5cbEfm7Lum0lcLDLiise1F8qDKX00sOU=\ngoogle.golang.org/api v0.54.0/go.mod h1:7C4bFFOvVDGXjfDTAsgGwDgAxRDeQ4X8NvUedIt6z3k=\ngoogle.golang.org/api v0.55.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=\ngoogle.golang.org/api v0.56.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=\ngoogle.golang.org/api v0.57.0/go.mod h1:dVPlbZyBo2/OjBpmvNdpn2GRm6rPy75jyU7bmhdrMgI=\ngoogle.golang.org/api v0.61.0/go.mod h1:xQRti5UdCmoCEqFxcz93fTl338AVqDgyaDRuOZ3hg9I=\ngoogle.golang.org/api v0.63.0/go.mod h1:gs4ij2ffTRXwuzzgJl/56BdwJaA194ijkfn++9tDuPo=\ngoogle.golang.org/api v0.67.0/go.mod h1:ShHKP8E60yPsKNw/w8w+VYaj9H6buA5UqDp8dhbQZ6g=\ngoogle.golang.org/api v0.70.0/go.mod h1:Bs4ZM2HGifEvXwd50TtW70ovgJffJYw2oRCOFU/SkfA=\ngoogle.golang.org/api v0.71.0/go.mod h1:4PyU6e6JogV1f9eA4voyrTY2batOLdgZ5qZ5HOCc4j8=\ngoogle.golang.org/api v0.74.0/go.mod h1:ZpfMZOVRMywNyvJFeqL9HRWBgAuRfSjJFpe9QtRRyDs=\ngoogle.golang.org/api v0.75.0/go.mod h1:pU9QmyHLnzlpar1Mjt4IbapUCy8J+6HD6GeELN69ljA=\ngoogle.golang.org/api v0.77.0/go.mod h1:pU9QmyHLnzlpar1Mjt4IbapUCy8J+6HD6GeELN69ljA=\ngoogle.golang.org/api v0.78.0/go.mod h1:1Sg78yoMLOhlQTeF+ARBoytAcH1NNyyl390YMy6rKmw=\ngoogle.golang.org/api v0.80.0/go.mod h1:xY3nI94gbvBrE0J6NHXhxOmW97HG7Khjkku6AFB3Hyg=\ngoogle.golang.org/api v0.84.0/go.mod h1:NTsGnUFJMYROtiquksZHBWtHfeMC7iYthki7Eq3pa8o=\ngoogle.golang.org/api v0.85.0/go.mod h1:AqZf8Ep9uZ2pyTvgL+x0D3Zt0eoT9b5E8fmzfu6FO2g=\ngoogle.golang.org/api v0.90.0/go.mod h1:+Sem1dnrKlrXMR/X0bPnMWyluQe4RsNoYfmNLhOIkzw=\ngoogle.golang.org/api v0.93.0/go.mod h1:+Sem1dnrKlrXMR/X0bPnMWyluQe4RsNoYfmNLhOIkzw=\ngoogle.golang.org/api v0.95.0/go.mod h1:eADj+UBuxkh5zlrSntJghuNeg8HwQ1w5lTKkuqaETEI=\ngoogle.golang.org/api v0.96.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=\ngoogle.golang.org/api v0.97.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=\ngoogle.golang.org/api v0.98.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=\ngoogle.golang.org/api v0.99.0/go.mod h1:1YOf74vkVndF7pG6hIHuINsM7eWwpVTAfNMNiL91A08=\ngoogle.golang.org/api v0.100.0/go.mod h1:ZE3Z2+ZOr87Rx7dqFsdRQkRBk36kDtp/h+QpHbB7a70=\ngoogle.golang.org/api v0.102.0/go.mod h1:3VFl6/fzoA+qNuS1N1/VfXY4LjoXN/wzeIp7TweWwGo=\ngoogle.golang.org/api v0.103.0/go.mod h1:hGtW6nK1AC+d9si/UBhw8Xli+QMOf6xyNAyJw4qU9w0=\ngoogle.golang.org/api v0.106.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=\ngoogle.golang.org/api v0.107.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=\ngoogle.golang.org/api v0.108.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=\ngoogle.golang.org/api v0.110.0/go.mod h1:7FC4Vvx1Mooxh8C5HWjzZHcavuS2f6pmJpZx60ca7iI=\ngoogle.golang.org/api v0.111.0/go.mod h1:qtFHvU9mhgTJegR31csQ+rwxyUTHOKFqCKWp1J0fdw0=\ngoogle.golang.org/api v0.114.0/go.mod h1:ifYI2ZsFK6/uGddGfAD5BMxlnkBqCmqHSDUVi45N5Yg=\ngoogle.golang.org/api v0.118.0/go.mod h1:76TtD3vkgmZ66zZzp72bUUklpmQmKlhh6sYtIjYK+5E=\ngoogle.golang.org/api v0.122.0/go.mod h1:gcitW0lvnyWjSp9nKxAbdHKIZ6vF4aajGueeslZOyms=\ngoogle.golang.org/api v0.124.0/go.mod h1:xu2HQurE5gi/3t1aFCvhPD781p0a3p11sdunTJ2BlP4=\ngoogle.golang.org/api v0.125.0/go.mod h1:mBwVAtz+87bEN6CbA1GtZPDOqY2R5ONPqJeIlvyo4Aw=\ngoogle.golang.org/api v0.126.0/go.mod h1:mBwVAtz+87bEN6CbA1GtZPDOqY2R5ONPqJeIlvyo4Aw=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=\ngoogle.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210108203827-ffc7fda8c3d7/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210222152913-aa3ee6e6a81c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210226172003-ab064af71705/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210303154014-9728d6b83eeb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210310155132-4ce2db91004e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210319143718-93e7006c17a6/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210329143202-679c6ae281ee/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=\ngoogle.golang.org/genproto v0.0.0-20210402141018-6c239bbf2bb1/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=\ngoogle.golang.org/genproto v0.0.0-20210513213006-bf773b8c8384/go.mod h1:P3QM42oQyzQSnHPnZ/vqoCdDmzH28fzWByN9asMeM8A=\ngoogle.golang.org/genproto v0.0.0-20210602131652-f16073e35f0c/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=\ngoogle.golang.org/genproto v0.0.0-20210604141403-392c879c8b08/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=\ngoogle.golang.org/genproto v0.0.0-20210608205507-b6d2f5bf0d7d/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=\ngoogle.golang.org/genproto v0.0.0-20210624195500-8bfb893ecb84/go.mod h1:SzzZ/N+nwJDaO1kznhnlzqS8ocJICar6hYhVyhi++24=\ngoogle.golang.org/genproto v0.0.0-20210713002101-d411969a0d9a/go.mod h1:AxrInvYm1dci+enl5hChSFPOmmUF1+uAa/UsgNRWd7k=\ngoogle.golang.org/genproto v0.0.0-20210716133855-ce7ef5c701ea/go.mod h1:AxrInvYm1dci+enl5hChSFPOmmUF1+uAa/UsgNRWd7k=\ngoogle.golang.org/genproto v0.0.0-20210728212813-7823e685a01f/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=\ngoogle.golang.org/genproto v0.0.0-20210805201207-89edb61ffb67/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=\ngoogle.golang.org/genproto v0.0.0-20210813162853-db860fec028c/go.mod h1:cFeNkxwySK631ADgubI+/XFU/xp8FD5KIVV4rj8UC5w=\ngoogle.golang.org/genproto v0.0.0-20210821163610-241b8fcbd6c8/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/genproto v0.0.0-20210828152312-66f60bf46e71/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/genproto v0.0.0-20210903162649-d08c68adba83/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/genproto v0.0.0-20210909211513-a8c4777a87af/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/genproto v0.0.0-20210924002016-3dee208752a0/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20211118181313-81c1377c94b1/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20211206160659-862468c7d6e0/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20211208223120-3a66f561d7aa/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20211221195035-429b39de9b1c/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20220126215142-9970aeb2e350/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20220207164111-0872dc986b00/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=\ngoogle.golang.org/genproto v0.0.0-20220218161850-94dd64e39d7c/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=\ngoogle.golang.org/genproto v0.0.0-20220222213610-43724f9ea8cf/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=\ngoogle.golang.org/genproto v0.0.0-20220304144024-325a89244dc8/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=\ngoogle.golang.org/genproto v0.0.0-20220310185008-1973136f34c6/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=\ngoogle.golang.org/genproto v0.0.0-20220324131243-acbaeb5b85eb/go.mod h1:hAL49I2IFola2sVEjAn7MEwsja0xp51I0tlGAf9hz4E=\ngoogle.golang.org/genproto v0.0.0-20220329172620-7be39ac1afc7/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220407144326-9054f6ed7bac/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220413183235-5e96e2839df9/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220414192740-2d67ff6cf2b4/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220421151946-72621c1f0bd3/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220429170224-98d788798c3e/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=\ngoogle.golang.org/genproto v0.0.0-20220502173005-c8bf987b8c21/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=\ngoogle.golang.org/genproto v0.0.0-20220505152158-f39f71e6c8f3/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=\ngoogle.golang.org/genproto v0.0.0-20220518221133-4f43b3371335/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=\ngoogle.golang.org/genproto v0.0.0-20220523171625-347a074981d8/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=\ngoogle.golang.org/genproto v0.0.0-20220608133413-ed9918b62aac/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=\ngoogle.golang.org/genproto v0.0.0-20220616135557-88e70c0c3a90/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=\ngoogle.golang.org/genproto v0.0.0-20220617124728-180714bec0ad/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=\ngoogle.golang.org/genproto v0.0.0-20220624142145-8cd45d7dbd1f/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=\ngoogle.golang.org/genproto v0.0.0-20220628213854-d9e0b6570c03/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=\ngoogle.golang.org/genproto v0.0.0-20220722212130-b98a9ff5e252/go.mod h1:GkXuJDJ6aQ7lnJcRF+SJVgFdQhypqgl3LB1C9vabdRE=\ngoogle.golang.org/genproto v0.0.0-20220801145646-83ce21fca29f/go.mod h1:iHe1svFLAZg9VWz891+QbRMwUv9O/1Ww+/mngYeThbc=\ngoogle.golang.org/genproto v0.0.0-20220815135757-37a418bb8959/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=\ngoogle.golang.org/genproto v0.0.0-20220817144833-d7fd3f11b9b1/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=\ngoogle.golang.org/genproto v0.0.0-20220822174746-9e6da59bd2fc/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=\ngoogle.golang.org/genproto v0.0.0-20220829144015-23454907ede3/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=\ngoogle.golang.org/genproto v0.0.0-20220829175752-36a9c930ecbf/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=\ngoogle.golang.org/genproto v0.0.0-20220913154956-18f8339a66a5/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=\ngoogle.golang.org/genproto v0.0.0-20220914142337-ca0e39ece12f/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=\ngoogle.golang.org/genproto v0.0.0-20220915135415-7fd63a7952de/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=\ngoogle.golang.org/genproto v0.0.0-20220916172020-2692e8806bfa/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=\ngoogle.golang.org/genproto v0.0.0-20220919141832-68c03719ef51/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=\ngoogle.golang.org/genproto v0.0.0-20220920201722-2b89144ce006/go.mod h1:ht8XFiar2npT/g4vkk7O0WYS1sHOHbdujxbEp7CJWbw=\ngoogle.golang.org/genproto v0.0.0-20220926165614-551eb538f295/go.mod h1:woMGP53BroOrRY3xTxlbr8Y3eB/nzAvvFM83q7kG2OI=\ngoogle.golang.org/genproto v0.0.0-20220926220553-6981cbe3cfce/go.mod h1:woMGP53BroOrRY3xTxlbr8Y3eB/nzAvvFM83q7kG2OI=\ngoogle.golang.org/genproto v0.0.0-20221010155953-15ba04fc1c0e/go.mod h1:3526vdqwhZAwq4wsRUaVG555sVgsNmIjRtO7t/JH29U=\ngoogle.golang.org/genproto v0.0.0-20221014173430-6e2ab493f96b/go.mod h1:1vXfmgAz9N9Jx0QA82PqRVauvCz1SGSz739p0f183jM=\ngoogle.golang.org/genproto v0.0.0-20221014213838-99cd37c6964a/go.mod h1:1vXfmgAz9N9Jx0QA82PqRVauvCz1SGSz739p0f183jM=\ngoogle.golang.org/genproto v0.0.0-20221024153911-1573dae28c9c/go.mod h1:9qHF0xnpdSfF6knlcsnpzUu5y+rpwgbvsyGAZPBMg4s=\ngoogle.golang.org/genproto v0.0.0-20221024183307-1bc688fe9f3e/go.mod h1:9qHF0xnpdSfF6knlcsnpzUu5y+rpwgbvsyGAZPBMg4s=\ngoogle.golang.org/genproto v0.0.0-20221027153422-115e99e71e1c/go.mod h1:CGI5F/G+E5bKwmfYo09AXuVN4dD894kIKUFmVbP2/Fo=\ngoogle.golang.org/genproto v0.0.0-20221109142239-94d6d90a7d66/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221114212237-e4508ebdbee1/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221117204609-8f9c96812029/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221118155620-16455021b5e6/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221201164419-0e50fba7f41c/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221201204527-e3fa12d562f3/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=\ngoogle.golang.org/genproto v0.0.0-20221202195650-67e5cbc046fd/go.mod h1:cTsE614GARnxrLsqKREzmNYJACSWWpAWdNMwnD7c2BE=\ngoogle.golang.org/genproto v0.0.0-20221227171554-f9683d7f8bef/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230110181048-76db0878b65f/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230112194545-e10362b5ecf9/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230113154510-dbe35b8444a5/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230123190316-2c411cf9d197/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230124163310-31e0e69b6fc2/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230125152338-dcaf20b6aeaa/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230127162408-596548ed4efa/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230209215440-0dfe4f8abfcc/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=\ngoogle.golang.org/genproto v0.0.0-20230216225411-c8e22ba71e44/go.mod h1:8B0gmkoRebU8ukX6HP+4wrVQUY1+6PkQ44BSyIlflHA=\ngoogle.golang.org/genproto v0.0.0-20230222225845-10f96fb3dbec/go.mod h1:3Dl5ZL0q0isWJt+FVcfpQyirqemEuLAK/iFvg1UP1Hw=\ngoogle.golang.org/genproto v0.0.0-20230223222841-637eb2293923/go.mod h1:3Dl5ZL0q0isWJt+FVcfpQyirqemEuLAK/iFvg1UP1Hw=\ngoogle.golang.org/genproto v0.0.0-20230303212802-e74f57abe488/go.mod h1:TvhZT5f700eVlTNwND1xoEZQeWTB2RY/65kplwl/bFA=\ngoogle.golang.org/genproto v0.0.0-20230306155012-7f2fa6fef1f4/go.mod h1:NWraEVixdDnqcqQ30jipen1STv2r/n24Wb7twVTGR4s=\ngoogle.golang.org/genproto v0.0.0-20230320184635-7606e756e683/go.mod h1:NWraEVixdDnqcqQ30jipen1STv2r/n24Wb7twVTGR4s=\ngoogle.golang.org/genproto v0.0.0-20230323212658-478b75c54725/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=\ngoogle.golang.org/genproto v0.0.0-20230330154414-c0448cd141ea/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=\ngoogle.golang.org/genproto v0.0.0-20230331144136-dcfb400f0633/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=\ngoogle.golang.org/genproto v0.0.0-20230403163135-c38d8f061ccd/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=\ngoogle.golang.org/genproto v0.0.0-20230410155749-daa745c078e1/go.mod h1:nKE/iIaLqn2bQwXBg8f1g2Ylh6r5MN5CmZvuzZCgsCU=\ngoogle.golang.org/genproto v0.0.0-20230525234025-438c736192d0/go.mod h1:9ExIQyXL5hZrHzQceCwuSYwZZ5QZBazOcprJ5rgs3lY=\ngoogle.golang.org/genproto v0.0.0-20230526203410-71b5a4ffd15e/go.mod h1:zqTuNwFlFRsw5zIts5VnzLQxSRqh+CGOTVMlYbY0Eyk=\ngoogle.golang.org/genproto v0.0.0-20230530153820-e85fd2cbaebc/go.mod h1:xZnkP7mREFX5MORlOPEzLMr+90PPZQ2QWzrVTWfAq64=\ngoogle.golang.org/genproto v0.0.0-20230629202037-9506855d4529/go.mod h1:xZnkP7mREFX5MORlOPEzLMr+90PPZQ2QWzrVTWfAq64=\ngoogle.golang.org/genproto v0.0.0-20230706204954-ccb25ca9f130/go.mod h1:O9kGHb51iE/nOGvQaDUuadVYqovW56s5emA88lQnj6Y=\ngoogle.golang.org/genproto v0.0.0-20230711160842-782d3b101e98 h1:Z0hjGZePRE0ZBWotvtrwxFNrNE9CUAGtplaDK5NNI/g=\ngoogle.golang.org/genproto v0.0.0-20230711160842-782d3b101e98/go.mod h1:S7mY02OqCJTD0E1OiQy1F72PWFB4bZJ87cAtLPYgDR0=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230525234020-1aefcd67740a/go.mod h1:ts19tUU+Z0ZShN1y3aPyq2+O3d5FUNNgT6FtOzmrNn8=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230525234035-dd9d682886f9/go.mod h1:vHYtlOoi6TsQ3Uk2yxR7NI5z8uoV+3pZtR4jmHIkRig=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230526203410-71b5a4ffd15e/go.mod h1:vHYtlOoi6TsQ3Uk2yxR7NI5z8uoV+3pZtR4jmHIkRig=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230530153820-e85fd2cbaebc/go.mod h1:vHYtlOoi6TsQ3Uk2yxR7NI5z8uoV+3pZtR4jmHIkRig=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230629202037-9506855d4529/go.mod h1:vHYtlOoi6TsQ3Uk2yxR7NI5z8uoV+3pZtR4jmHIkRig=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230706204954-ccb25ca9f130/go.mod h1:mPBs5jNgx2GuQGvFwUvVKqtn6HsUw9nP64BedgvqEsQ=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20230711160842-782d3b101e98/go.mod h1:rsr7RhLuwsDKL7RmgDDCUc6yaGr1iqceVb5Wv6f6YvQ=\ngoogle.golang.org/genproto/googleapis/bytestream v0.0.0-20230530153820-e85fd2cbaebc/go.mod h1:ylj+BE99M198VPbBh6A8d9n3w8fChvyLK3wwBOjXBFA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230525234015-3fc162c6f38a/go.mod h1:xURIpW9ES5+/GZhnV6beoEtxQrnkRGIfP5VQG2tCBLc=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230525234030-28d5490b6b19/go.mod h1:66JfowdXAEgad5O9NnYcsNPLCPZJD++2L9X0PCMODrA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230526203410-71b5a4ffd15e/go.mod h1:66JfowdXAEgad5O9NnYcsNPLCPZJD++2L9X0PCMODrA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230530153820-e85fd2cbaebc/go.mod h1:66JfowdXAEgad5O9NnYcsNPLCPZJD++2L9X0PCMODrA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230629202037-9506855d4529/go.mod h1:66JfowdXAEgad5O9NnYcsNPLCPZJD++2L9X0PCMODrA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230706204954-ccb25ca9f130/go.mod h1:8mL13HKkDa+IuJ8yruA3ci0q+0vsUz4m//+ottjwS5o=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98 h1:bVf09lpb+OJbByTj913DRJioFFAjf/ZGxEz7MajTp2U=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20230711160842-782d3b101e98/go.mod h1:TUfxEVdsvPg18p6AslUXFoLdpED4oBnGwyqk3dV1XzM=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\ngoogle.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=\ngoogle.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=\ngoogle.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/grpc v1.31.1/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=\ngoogle.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=\ngoogle.golang.org/grpc v1.34.0/go.mod h1:WotjhfgOW/POjDeRt8vscBtXq+2VjORFy659qA51WJ8=\ngoogle.golang.org/grpc v1.35.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=\ngoogle.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=\ngoogle.golang.org/grpc v1.36.1/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=\ngoogle.golang.org/grpc v1.37.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=\ngoogle.golang.org/grpc v1.37.1/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=\ngoogle.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=\ngoogle.golang.org/grpc v1.39.0/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=\ngoogle.golang.org/grpc v1.39.1/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=\ngoogle.golang.org/grpc v1.40.0/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=\ngoogle.golang.org/grpc v1.40.1/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=\ngoogle.golang.org/grpc v1.42.0/go.mod h1:k+4IHHFw41K8+bbowsex27ge2rCb65oeWqe4jJ590SU=\ngoogle.golang.org/grpc v1.44.0/go.mod h1:k+4IHHFw41K8+bbowsex27ge2rCb65oeWqe4jJ590SU=\ngoogle.golang.org/grpc v1.45.0/go.mod h1:lN7owxKUQEqMfSyQikvvk5tf/6zMPsrK+ONuO11+0rQ=\ngoogle.golang.org/grpc v1.46.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=\ngoogle.golang.org/grpc v1.46.2/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=\ngoogle.golang.org/grpc v1.47.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=\ngoogle.golang.org/grpc v1.48.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=\ngoogle.golang.org/grpc v1.49.0/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=\ngoogle.golang.org/grpc v1.50.0/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=\ngoogle.golang.org/grpc v1.50.1/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=\ngoogle.golang.org/grpc v1.51.0/go.mod h1:wgNDFcnuBGmxLKI/qn4T+m5BtEBYXJPvibbUPsAIPww=\ngoogle.golang.org/grpc v1.52.0/go.mod h1:pu6fVzoFb+NBYNAvQL08ic+lvB2IojljRYuun5vorUY=\ngoogle.golang.org/grpc v1.52.3/go.mod h1:pu6fVzoFb+NBYNAvQL08ic+lvB2IojljRYuun5vorUY=\ngoogle.golang.org/grpc v1.53.0/go.mod h1:OnIrk0ipVdj4N5d9IUoFUx72/VlD7+jUsHwZgwSMQpw=\ngoogle.golang.org/grpc v1.54.0/go.mod h1:PUSEXI6iWghWaB6lXM4knEgpJNu2qUcKfDtNci3EC2g=\ngoogle.golang.org/grpc v1.55.0/go.mod h1:iYEXKGkEBhg1PjZQvoYEVPTDkHo1/bjTnfwTeGONTY8=\ngoogle.golang.org/grpc v1.56.2/go.mod h1:I9bI3vqKfayGqPUAwGdOSu7kt6oIJLixfffKrpXqQ9s=\ngoogle.golang.org/grpc v1.58.3 h1:BjnpXut1btbtgN/6sp+brB2Kbm2LjNXnidYujAVbSoQ=\ngoogle.golang.org/grpc v1.58.3/go.mod h1:tgX3ZQDlNJGU96V6yHh1T/JeoBQ2TXdr43YbYSsCJk0=\ngoogle.golang.org/grpc/cmd/protoc-gen-go-grpc v1.1.0/go.mod h1:6Kw0yEErY5E/yWrBtf03jp27GLLJujG4z/JK95pnjjw=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.28.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.28.2-0.20230222093303-bc1253ad3743/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.29.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.30.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.31.0 h1:g0LDEJHgrBl9N9r17Ru3sqWhkIx2NB67okBHPwC7hs8=\ngoogle.golang.org/protobuf v1.31.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.1.3/go.mod h1:NgwopIslSNH47DimFoV78dnkksY2EFtX0ajyb3K/las=\nlukechampine.com/uint128 v1.1.1/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=\nlukechampine.com/uint128 v1.2.0/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=\nmodernc.org/cc/v3 v3.36.0/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=\nmodernc.org/cc/v3 v3.36.2/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=\nmodernc.org/cc/v3 v3.36.3/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=\nmodernc.org/cc/v3 v3.37.0/go.mod h1:vtL+3mdHx/wcj3iEGz84rQa8vEqR6XM84v5Lcvfph20=\nmodernc.org/cc/v3 v3.40.0/go.mod h1:/bTg4dnWkSXowUO6ssQKnOV0yMVxDYNIsIrzqTFDGH0=\nmodernc.org/ccgo/v3 v3.0.0-20220428102840-41399a37e894/go.mod h1:eI31LL8EwEBKPpNpA4bU1/i+sKOwOrQy8D87zWUcRZc=\nmodernc.org/ccgo/v3 v3.0.0-20220430103911-bc99d88307be/go.mod h1:bwdAnOoaIt8Ax9YdWGjxWsdkPcZyRPHqrOvJxaKAKGw=\nmodernc.org/ccgo/v3 v3.0.0-20220904174949-82d86e1b6d56/go.mod h1:YSXjPL62P2AMSxBphRHPn7IkzhVHqkvOnRKAKh+W6ZI=\nmodernc.org/ccgo/v3 v3.16.4/go.mod h1:tGtX0gE9Jn7hdZFeU88slbTh1UtCYKusWOoCJuvkWsQ=\nmodernc.org/ccgo/v3 v3.16.6/go.mod h1:tGtX0gE9Jn7hdZFeU88slbTh1UtCYKusWOoCJuvkWsQ=\nmodernc.org/ccgo/v3 v3.16.8/go.mod h1:zNjwkizS+fIFDrDjIAgBSCLkWbJuHF+ar3QRn+Z9aws=\nmodernc.org/ccgo/v3 v3.16.9/go.mod h1:zNMzC9A9xeNUepy6KuZBbugn3c0Mc9TeiJO4lgvkJDo=\nmodernc.org/ccgo/v3 v3.16.13-0.20221017192402-261537637ce8/go.mod h1:fUB3Vn0nVPReA+7IG7yZDfjv1TMWjhQP8gCxrFAtL5g=\nmodernc.org/ccgo/v3 v3.16.13/go.mod h1:2Quk+5YgpImhPjv2Qsob1DnZ/4som1lJTodubIcoUkY=\nmodernc.org/ccorpus v1.11.6/go.mod h1:2gEUTrWqdpH2pXsmTM1ZkjeSrUWDpjMu2T6m29L/ErQ=\nmodernc.org/httpfs v1.0.6/go.mod h1:7dosgurJGp0sPaRanU53W4xZYKh14wfzX420oZADeHM=\nmodernc.org/libc v0.0.0-20220428101251-2d5f3daf273b/go.mod h1:p7Mg4+koNjc8jkqwcoFBJx7tXkpj00G77X7A72jXPXA=\nmodernc.org/libc v1.16.0/go.mod h1:N4LD6DBE9cf+Dzf9buBlzVJndKr/iJHG97vGLHYnb5A=\nmodernc.org/libc v1.16.1/go.mod h1:JjJE0eu4yeK7tab2n4S1w8tlWd9MxXLRzheaRnAKymU=\nmodernc.org/libc v1.16.17/go.mod h1:hYIV5VZczAmGZAnG15Vdngn5HSF5cSkbvfz2B7GRuVU=\nmodernc.org/libc v1.16.19/go.mod h1:p7Mg4+koNjc8jkqwcoFBJx7tXkpj00G77X7A72jXPXA=\nmodernc.org/libc v1.17.0/go.mod h1:XsgLldpP4aWlPlsjqKRdHPqCxCjISdHfM/yeWC5GyW0=\nmodernc.org/libc v1.17.1/go.mod h1:FZ23b+8LjxZs7XtFMbSzL/EhPxNbfZbErxEHc7cbD9s=\nmodernc.org/libc v1.17.4/go.mod h1:WNg2ZH56rDEwdropAJeZPQkXmDwh+JCA1s/htl6r2fA=\nmodernc.org/libc v1.18.0/go.mod h1:vj6zehR5bfc98ipowQOM2nIDUZnVew/wNC/2tOGS+q0=\nmodernc.org/libc v1.20.3/go.mod h1:ZRfIaEkgrYgZDl6pa4W39HgN5G/yDW+NRmNKZBDFrk0=\nmodernc.org/libc v1.21.4/go.mod h1:przBsL5RDOZajTVslkugzLBj1evTue36jEomFQOoYuI=\nmodernc.org/libc v1.22.2/go.mod h1:uvQavJ1pZ0hIoC/jfqNoMLURIMhKzINIWypNM17puug=\nmodernc.org/mathutil v1.2.2/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=\nmodernc.org/mathutil v1.4.1/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=\nmodernc.org/mathutil v1.5.0/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=\nmodernc.org/memory v1.1.1/go.mod h1:/0wo5ibyrQiaoUoH7f9D8dnglAmILJ5/cxZlRECf+Nw=\nmodernc.org/memory v1.2.0/go.mod h1:/0wo5ibyrQiaoUoH7f9D8dnglAmILJ5/cxZlRECf+Nw=\nmodernc.org/memory v1.2.1/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=\nmodernc.org/memory v1.3.0/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=\nmodernc.org/memory v1.4.0/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=\nmodernc.org/memory v1.5.0/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=\nmodernc.org/opt v0.1.1/go.mod h1:WdSiB5evDcignE70guQKxYUl14mgWtbClRi5wmkkTX0=\nmodernc.org/opt v0.1.3/go.mod h1:WdSiB5evDcignE70guQKxYUl14mgWtbClRi5wmkkTX0=\nmodernc.org/sqlite v1.18.1/go.mod h1:6ho+Gow7oX5V+OiOQ6Tr4xeqbx13UZ6t+Fw9IRUG4d4=\nmodernc.org/sqlite v1.18.2/go.mod h1:kvrTLEWgxUcHa2GfHBQtanR1H9ht3hTJNtKpzH9k1u0=\nmodernc.org/strutil v1.1.1/go.mod h1:DE+MQQ/hjKBZS2zNInV5hhcipt5rLPWkmpbGeW5mmdw=\nmodernc.org/strutil v1.1.3/go.mod h1:MEHNA7PdEnEwLvspRMtWTNnp2nnyvMfkimT1NKNAGbw=\nmodernc.org/tcl v1.13.1/go.mod h1:XOLfOwzhkljL4itZkK6T72ckMgvj0BDsnKNdZVUOecw=\nmodernc.org/tcl v1.13.2/go.mod h1:7CLiGIPo1M8Rv1Mitpv5akc2+8fxUd2y2UzC/MfMzy0=\nmodernc.org/token v1.0.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\nmodernc.org/token v1.0.1/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\nmodernc.org/token v1.1.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\nmodernc.org/z v1.5.1/go.mod h1:eWFB510QWW5Th9YGZT81s+LwvaAs3Q2yr4sP0rmLkv8=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n"
        },
        {
          "name": "grpc_broker.go",
          "type": "blob",
          "size": 15.54296875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-plugin/internal/grpcmux\"\n\t\"github.com/hashicorp/go-plugin/internal/plugin\"\n\t\"github.com/hashicorp/go-plugin/runner\"\n\n\t\"github.com/oklog/run\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n)\n\n// streamer interface is used in the broker to send/receive connection\n// information.\ntype streamer interface {\n\tSend(*plugin.ConnInfo) error\n\tRecv() (*plugin.ConnInfo, error)\n\tClose()\n}\n\n// sendErr is used to pass errors back during a send.\ntype sendErr struct {\n\ti  *plugin.ConnInfo\n\tch chan error\n}\n\n// gRPCBrokerServer is used by the plugin to start a stream and to send\n// connection information to/from the plugin. Implements GRPCBrokerServer and\n// streamer interfaces.\ntype gRPCBrokerServer struct {\n\tplugin.UnimplementedGRPCBrokerServer\n\n\t// send is used to send connection info to the gRPC stream.\n\tsend chan *sendErr\n\n\t// recv is used to receive connection info from the gRPC stream.\n\trecv chan *plugin.ConnInfo\n\n\t// quit closes down the stream.\n\tquit chan struct{}\n\n\t// o is used to ensure we close the quit channel only once.\n\to sync.Once\n}\n\nfunc newGRPCBrokerServer() *gRPCBrokerServer {\n\treturn &gRPCBrokerServer{\n\t\tsend: make(chan *sendErr),\n\t\trecv: make(chan *plugin.ConnInfo),\n\t\tquit: make(chan struct{}),\n\t}\n}\n\n// StartStream implements the GRPCBrokerServer interface and will block until\n// the quit channel is closed or the context reports Done. The stream will pass\n// connection information to/from the client.\nfunc (s *gRPCBrokerServer) StartStream(stream plugin.GRPCBroker_StartStreamServer) error {\n\tdoneCh := stream.Context().Done()\n\tdefer s.Close()\n\n\t// Proccess send stream\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-doneCh:\n\t\t\t\treturn\n\t\t\tcase <-s.quit:\n\t\t\t\treturn\n\t\t\tcase se := <-s.send:\n\t\t\t\terr := stream.Send(se.i)\n\t\t\t\tse.ch <- err\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Process receive stream\n\tfor {\n\t\ti, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-doneCh:\n\t\t\treturn nil\n\t\tcase <-s.quit:\n\t\t\treturn nil\n\t\tcase s.recv <- i:\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Send is used by the GRPCBroker to pass connection information into the stream\n// to the client.\nfunc (s *gRPCBrokerServer) Send(i *plugin.ConnInfo) error {\n\tch := make(chan error)\n\tdefer close(ch)\n\n\tselect {\n\tcase <-s.quit:\n\t\treturn errors.New(\"broker closed\")\n\tcase s.send <- &sendErr{\n\t\ti:  i,\n\t\tch: ch,\n\t}:\n\t}\n\n\treturn <-ch\n}\n\n// Recv is used by the GRPCBroker to pass connection information that has been\n// sent from the client from the stream to the broker.\nfunc (s *gRPCBrokerServer) Recv() (*plugin.ConnInfo, error) {\n\tselect {\n\tcase <-s.quit:\n\t\treturn nil, errors.New(\"broker closed\")\n\tcase i := <-s.recv:\n\t\treturn i, nil\n\t}\n}\n\n// Close closes the quit channel, shutting down the stream.\nfunc (s *gRPCBrokerServer) Close() {\n\ts.o.Do(func() {\n\t\tclose(s.quit)\n\t})\n}\n\n// gRPCBrokerClientImpl is used by the client to start a stream and to send\n// connection information to/from the client. Implements GRPCBrokerClient and\n// streamer interfaces.\ntype gRPCBrokerClientImpl struct {\n\t// client is the underlying GRPC client used to make calls to the server.\n\tclient plugin.GRPCBrokerClient\n\n\t// send is used to send connection info to the gRPC stream.\n\tsend chan *sendErr\n\n\t// recv is used to receive connection info from the gRPC stream.\n\trecv chan *plugin.ConnInfo\n\n\t// quit closes down the stream.\n\tquit chan struct{}\n\n\t// o is used to ensure we close the quit channel only once.\n\to sync.Once\n}\n\nfunc newGRPCBrokerClient(conn *grpc.ClientConn) *gRPCBrokerClientImpl {\n\treturn &gRPCBrokerClientImpl{\n\t\tclient: plugin.NewGRPCBrokerClient(conn),\n\t\tsend:   make(chan *sendErr),\n\t\trecv:   make(chan *plugin.ConnInfo),\n\t\tquit:   make(chan struct{}),\n\t}\n}\n\n// StartStream implements the GRPCBrokerClient interface and will block until\n// the quit channel is closed or the context reports Done. The stream will pass\n// connection information to/from the plugin.\nfunc (s *gRPCBrokerClientImpl) StartStream() error {\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\tdefer cancelFunc()\n\tdefer s.Close()\n\n\tstream, err := s.client.StartStream(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdoneCh := stream.Context().Done()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-doneCh:\n\t\t\t\treturn\n\t\t\tcase <-s.quit:\n\t\t\t\treturn\n\t\t\tcase se := <-s.send:\n\t\t\t\terr := stream.Send(se.i)\n\t\t\t\tse.ch <- err\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\ti, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-doneCh:\n\t\t\treturn nil\n\t\tcase <-s.quit:\n\t\t\treturn nil\n\t\tcase s.recv <- i:\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Send is used by the GRPCBroker to pass connection information into the stream\n// to the plugin.\nfunc (s *gRPCBrokerClientImpl) Send(i *plugin.ConnInfo) error {\n\tch := make(chan error)\n\tdefer close(ch)\n\n\tselect {\n\tcase <-s.quit:\n\t\treturn errors.New(\"broker closed\")\n\tcase s.send <- &sendErr{\n\t\ti:  i,\n\t\tch: ch,\n\t}:\n\t}\n\n\treturn <-ch\n}\n\n// Recv is used by the GRPCBroker to pass connection information that has been\n// sent from the plugin to the broker.\nfunc (s *gRPCBrokerClientImpl) Recv() (*plugin.ConnInfo, error) {\n\tselect {\n\tcase <-s.quit:\n\t\treturn nil, errors.New(\"broker closed\")\n\tcase i := <-s.recv:\n\t\treturn i, nil\n\t}\n}\n\n// Close closes the quit channel, shutting down the stream.\nfunc (s *gRPCBrokerClientImpl) Close() {\n\ts.o.Do(func() {\n\t\tclose(s.quit)\n\t})\n}\n\n// GRPCBroker is responsible for brokering connections by unique ID.\n//\n// It is used by plugins to create multiple gRPC connections and data\n// streams between the plugin process and the host process.\n//\n// This allows a plugin to request a channel with a specific ID to connect to\n// or accept a connection from, and the broker handles the details of\n// holding these channels open while they're being negotiated.\n//\n// The Plugin interface has access to these for both Server and Client.\n// The broker can be used by either (optionally) to reserve and connect to\n// new streams. This is useful for complex args and return values,\n// or anything else you might need a data stream for.\ntype GRPCBroker struct {\n\tnextId   uint32\n\tstreamer streamer\n\ttls      *tls.Config\n\tdoneCh   chan struct{}\n\to        sync.Once\n\n\tclientStreams map[uint32]*gRPCBrokerPending\n\tserverStreams map[uint32]*gRPCBrokerPending\n\n\tunixSocketCfg  UnixSocketConfig\n\taddrTranslator runner.AddrTranslator\n\n\tdialMutex sync.Mutex\n\n\tmuxer grpcmux.GRPCMuxer\n\n\tsync.Mutex\n}\n\ntype gRPCBrokerPending struct {\n\tch     chan *plugin.ConnInfo\n\tdoneCh chan struct{}\n\tonce   sync.Once\n}\n\nfunc newGRPCBroker(s streamer, tls *tls.Config, unixSocketCfg UnixSocketConfig, addrTranslator runner.AddrTranslator, muxer grpcmux.GRPCMuxer) *GRPCBroker {\n\treturn &GRPCBroker{\n\t\tstreamer: s,\n\t\ttls:      tls,\n\t\tdoneCh:   make(chan struct{}),\n\n\t\tclientStreams: make(map[uint32]*gRPCBrokerPending),\n\t\tserverStreams: make(map[uint32]*gRPCBrokerPending),\n\t\tmuxer:         muxer,\n\n\t\tunixSocketCfg:  unixSocketCfg,\n\t\taddrTranslator: addrTranslator,\n\t}\n}\n\n// Accept accepts a connection by ID.\n//\n// This should not be called multiple times with the same ID at one time.\nfunc (b *GRPCBroker) Accept(id uint32) (net.Listener, error) {\n\tif b.muxer.Enabled() {\n\t\tp := b.getServerStream(id)\n\t\tgo func() {\n\t\t\terr := b.listenForKnocks(id)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[ERR]: error listening for knocks, id: %d, error: %s\", id, err)\n\t\t\t}\n\t\t}()\n\n\t\tln, err := b.muxer.Listener(id, p.doneCh)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tln = &rmListener{\n\t\t\tListener: ln,\n\t\t\tclose: func() error {\n\t\t\t\t// We could have multiple listeners on the same ID, so use sync.Once\n\t\t\t\t// for closing doneCh to ensure we don't get a panic.\n\t\t\t\tp.once.Do(func() {\n\t\t\t\t\tclose(p.doneCh)\n\t\t\t\t})\n\n\t\t\t\tb.Lock()\n\t\t\t\tdefer b.Unlock()\n\n\t\t\t\t// No longer need to listen for knocks once the listener is closed.\n\t\t\t\tdelete(b.serverStreams, id)\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\n\t\treturn ln, nil\n\t}\n\n\tlistener, err := serverListener(b.unixSocketCfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tadvertiseNet := listener.Addr().Network()\n\tadvertiseAddr := listener.Addr().String()\n\tif b.addrTranslator != nil {\n\t\tadvertiseNet, advertiseAddr, err = b.addrTranslator.HostToPlugin(advertiseNet, advertiseAddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\terr = b.streamer.Send(&plugin.ConnInfo{\n\t\tServiceId: id,\n\t\tNetwork:   advertiseNet,\n\t\tAddress:   advertiseAddr,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn listener, nil\n}\n\n// AcceptAndServe is used to accept a specific stream ID and immediately\n// serve a gRPC server on that stream ID. This is used to easily serve\n// complex arguments. Each AcceptAndServe call opens a new listener socket and\n// sends the connection info down the stream to the dialer. Since a new\n// connection is opened every call, these calls should be used sparingly.\n// Multiple gRPC server implementations can be registered to a single\n// AcceptAndServe call.\nfunc (b *GRPCBroker) AcceptAndServe(id uint32, newGRPCServer func([]grpc.ServerOption) *grpc.Server) {\n\tln, err := b.Accept(id)\n\tif err != nil {\n\t\tlog.Printf(\"[ERR] plugin: plugin acceptAndServe error: %s\", err)\n\t\treturn\n\t}\n\tdefer ln.Close()\n\n\tvar opts []grpc.ServerOption\n\tif b.tls != nil {\n\t\topts = []grpc.ServerOption{grpc.Creds(credentials.NewTLS(b.tls))}\n\t}\n\n\tserver := newGRPCServer(opts)\n\n\t// Here we use a run group to close this goroutine if the server is shutdown\n\t// or the broker is shutdown.\n\tvar g run.Group\n\t{\n\t\t// Serve on the listener, if shutting down call GracefulStop.\n\t\tg.Add(func() error {\n\t\t\treturn server.Serve(ln)\n\t\t}, func(err error) {\n\t\t\tserver.GracefulStop()\n\t\t})\n\t}\n\t{\n\t\t// block on the closeCh or the doneCh. If we are shutting down close the\n\t\t// closeCh.\n\t\tcloseCh := make(chan struct{})\n\t\tg.Add(func() error {\n\t\t\tselect {\n\t\t\tcase <-b.doneCh:\n\t\t\tcase <-closeCh:\n\t\t\t}\n\t\t\treturn nil\n\t\t}, func(err error) {\n\t\t\tclose(closeCh)\n\t\t})\n\t}\n\n\t// Block until we are done\n\tg.Run()\n}\n\n// Close closes the stream and all servers.\nfunc (b *GRPCBroker) Close() error {\n\tb.streamer.Close()\n\tb.o.Do(func() {\n\t\tclose(b.doneCh)\n\t})\n\treturn nil\n}\n\nfunc (b *GRPCBroker) listenForKnocks(id uint32) error {\n\tp := b.getServerStream(id)\n\tfor {\n\t\tselect {\n\t\tcase msg := <-p.ch:\n\t\t\t// Shouldn't be possible.\n\t\t\tif msg.ServiceId != id {\n\t\t\t\treturn fmt.Errorf(\"knock received with wrong service ID; expected %d but got %d\", id, msg.ServiceId)\n\t\t\t}\n\n\t\t\t// Also shouldn't be possible.\n\t\t\tif msg.Knock == nil || !msg.Knock.Knock || msg.Knock.Ack {\n\t\t\t\treturn fmt.Errorf(\"knock received for service ID %d with incorrect values; knock=%+v\", id, msg.Knock)\n\t\t\t}\n\n\t\t\t// Successful knock, open the door for the given ID.\n\t\t\tvar ackError string\n\t\t\terr := b.muxer.AcceptKnock(id)\n\t\t\tif err != nil {\n\t\t\t\tackError = err.Error()\n\t\t\t}\n\n\t\t\t// Send back an acknowledgement to allow the client to start dialling.\n\t\t\terr = b.streamer.Send(&plugin.ConnInfo{\n\t\t\t\tServiceId: id,\n\t\t\t\tKnock: &plugin.ConnInfo_Knock{\n\t\t\t\t\tKnock: true,\n\t\t\t\t\tAck:   true,\n\t\t\t\t\tError: ackError,\n\t\t\t\t},\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error sending back knock acknowledgement: %w\", err)\n\t\t\t}\n\t\tcase <-p.doneCh:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (b *GRPCBroker) knock(id uint32) error {\n\t// Send a knock.\n\terr := b.streamer.Send(&plugin.ConnInfo{\n\t\tServiceId: id,\n\t\tKnock: &plugin.ConnInfo_Knock{\n\t\t\tKnock: true,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the ack.\n\tp := b.getClientStream(id)\n\tselect {\n\tcase msg := <-p.ch:\n\t\tif msg.ServiceId != id {\n\t\t\treturn fmt.Errorf(\"handshake failed for multiplexing on id %d; got response for %d\", id, msg.ServiceId)\n\t\t}\n\t\tif msg.Knock == nil || !msg.Knock.Knock || !msg.Knock.Ack {\n\t\t\treturn fmt.Errorf(\"handshake failed for multiplexing on id %d; expected knock and ack, but got %+v\", id, msg.Knock)\n\t\t}\n\t\tif msg.Knock.Error != \"\" {\n\t\t\treturn fmt.Errorf(\"failed to knock for id %d: %s\", id, msg.Knock.Error)\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\treturn fmt.Errorf(\"timeout waiting for multiplexing knock handshake on id %d\", id)\n\t}\n\n\treturn nil\n}\n\nfunc (b *GRPCBroker) muxDial(id uint32) func(string, time.Duration) (net.Conn, error) {\n\treturn func(string, time.Duration) (net.Conn, error) {\n\t\tb.dialMutex.Lock()\n\t\tdefer b.dialMutex.Unlock()\n\n\t\t// Tell the other side the listener ID it should give the next stream to.\n\t\terr := b.knock(id)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to knock before dialling client: %w\", err)\n\t\t}\n\n\t\tconn, err := b.muxer.Dial()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn conn, nil\n\t}\n}\n\n// Dial opens a connection by ID.\nfunc (b *GRPCBroker) Dial(id uint32) (conn *grpc.ClientConn, err error) { return b.DialWithOptions(id) }\n\n// Dial opens a connection by ID with options.\nfunc (b *GRPCBroker) DialWithOptions(id uint32, opts ...grpc.DialOption) (conn *grpc.ClientConn, err error) {\n\tif b.muxer.Enabled() {\n\t\treturn dialGRPCConn(b.tls, b.muxDial(id), opts...)\n\t}\n\n\tvar c *plugin.ConnInfo\n\n\t// Open the stream\n\tp := b.getClientStream(id)\n\tselect {\n\tcase c = <-p.ch:\n\t\tclose(p.doneCh)\n\tcase <-time.After(5 * time.Second):\n\t\treturn nil, fmt.Errorf(\"timeout waiting for connection info\")\n\t}\n\n\tnetwork, address := c.Network, c.Address\n\tif b.addrTranslator != nil {\n\t\tnetwork, address, err = b.addrTranslator.PluginToHost(network, address)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar addr net.Addr\n\tswitch network {\n\tcase \"tcp\":\n\t\taddr, err = net.ResolveTCPAddr(\"tcp\", address)\n\tcase \"unix\":\n\t\taddr, err = net.ResolveUnixAddr(\"unix\", address)\n\tdefault:\n\t\terr = fmt.Errorf(\"Unknown address type: %s\", c.Address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn dialGRPCConn(b.tls, netAddrDialer(addr), opts...)\n}\n\n// NextId returns a unique ID to use next.\n//\n// It is possible for very long-running plugin hosts to wrap this value,\n// though it would require a very large amount of calls. In practice\n// we've never seen it happen.\nfunc (m *GRPCBroker) NextId() uint32 {\n\treturn atomic.AddUint32(&m.nextId, 1)\n}\n\n// Run starts the brokering and should be executed in a goroutine, since it\n// blocks forever, or until the session closes.\n//\n// Uses of GRPCBroker never need to call this. It is called internally by\n// the plugin host/client.\nfunc (m *GRPCBroker) Run() {\n\tfor {\n\t\tmsg, err := m.streamer.Recv()\n\t\tif err != nil {\n\t\t\t// Once we receive an error, just exit\n\t\t\tbreak\n\t\t}\n\n\t\t// Initialize the waiter\n\t\tvar p *gRPCBrokerPending\n\t\tif msg.Knock != nil && msg.Knock.Knock && !msg.Knock.Ack {\n\t\t\tp = m.getServerStream(msg.ServiceId)\n\t\t\t// The server side doesn't close the channel immediately as it needs\n\t\t\t// to continuously listen for knocks.\n\t\t} else {\n\t\t\tp = m.getClientStream(msg.ServiceId)\n\t\t\tgo m.timeoutWait(msg.ServiceId, p)\n\t\t}\n\t\tselect {\n\t\tcase p.ch <- msg:\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// getClientStream is a buffer to receive new connection info and knock acks\n// by stream ID.\nfunc (m *GRPCBroker) getClientStream(id uint32) *gRPCBrokerPending {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tp, ok := m.clientStreams[id]\n\tif ok {\n\t\treturn p\n\t}\n\n\tm.clientStreams[id] = &gRPCBrokerPending{\n\t\tch:     make(chan *plugin.ConnInfo, 1),\n\t\tdoneCh: make(chan struct{}),\n\t}\n\treturn m.clientStreams[id]\n}\n\n// getServerStream is a buffer to receive knocks to a multiplexed stream ID\n// that its side is listening on. Not used unless multiplexing is enabled.\nfunc (m *GRPCBroker) getServerStream(id uint32) *gRPCBrokerPending {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tp, ok := m.serverStreams[id]\n\tif ok {\n\t\treturn p\n\t}\n\n\tm.serverStreams[id] = &gRPCBrokerPending{\n\t\tch:     make(chan *plugin.ConnInfo, 1),\n\t\tdoneCh: make(chan struct{}),\n\t}\n\treturn m.serverStreams[id]\n}\n\nfunc (m *GRPCBroker) timeoutWait(id uint32, p *gRPCBrokerPending) {\n\t// Wait for the stream to either be picked up and connected, or\n\t// for a timeout.\n\tselect {\n\tcase <-p.doneCh:\n\tcase <-time.After(5 * time.Second):\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\t// Delete the stream so no one else can grab it\n\tdelete(m.clientStreams, id)\n}\n"
        },
        {
          "name": "grpc_client.go",
          "type": "blob",
          "size": 3.4150390625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-plugin/internal/plugin\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\n\nfunc dialGRPCConn(tls *tls.Config, dialer func(string, time.Duration) (net.Conn, error), dialOpts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t// Build dialing options.\n\topts := make([]grpc.DialOption, 0)\n\n\t// We use a custom dialer so that we can connect over unix domain sockets.\n\topts = append(opts, grpc.WithDialer(dialer))\n\n\t// Fail right away\n\topts = append(opts, grpc.FailOnNonTempDialError(true))\n\n\t// If we have no TLS configuration set, we need to explicitly tell grpc\n\t// that we're connecting with an insecure connection.\n\tif tls == nil {\n\t\topts = append(opts, grpc.WithInsecure())\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(\n\t\t\tcredentials.NewTLS(tls)))\n\t}\n\n\topts = append(opts,\n\t\tgrpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(math.MaxInt32)),\n\t\tgrpc.WithDefaultCallOptions(grpc.MaxCallSendMsgSize(math.MaxInt32)))\n\n\t// Add our custom options if we have any\n\topts = append(opts, dialOpts...)\n\n\t// Connect. Note the first parameter is unused because we use a custom\n\t// dialer that has the state to see the address.\n\tconn, err := grpc.Dial(\"unused\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\n// newGRPCClient creates a new GRPCClient. The Client argument is expected\n// to be successfully started already with a lock held.\nfunc newGRPCClient(doneCtx context.Context, c *Client) (*GRPCClient, error) {\n\tconn, err := dialGRPCConn(c.config.TLSConfig, c.dialer, c.config.GRPCDialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmuxer, err := c.getGRPCMuxer(c.address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Start the broker.\n\tbrokerGRPCClient := newGRPCBrokerClient(conn)\n\tbroker := newGRPCBroker(brokerGRPCClient, c.config.TLSConfig, c.unixSocketCfg, c.runner, muxer)\n\tgo broker.Run()\n\tgo brokerGRPCClient.StartStream()\n\n\t// Start the stdio client\n\tstdioClient, err := newGRPCStdioClient(doneCtx, c.logger.Named(\"stdio\"), conn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgo stdioClient.Run(c.config.SyncStdout, c.config.SyncStderr)\n\n\tcl := &GRPCClient{\n\t\tConn:       conn,\n\t\tPlugins:    c.config.Plugins,\n\t\tdoneCtx:    doneCtx,\n\t\tbroker:     broker,\n\t\tcontroller: plugin.NewGRPCControllerClient(conn),\n\t}\n\n\treturn cl, nil\n}\n\n// GRPCClient connects to a GRPCServer over gRPC to dispense plugin types.\ntype GRPCClient struct {\n\tConn    *grpc.ClientConn\n\tPlugins map[string]Plugin\n\n\tdoneCtx context.Context\n\tbroker  *GRPCBroker\n\n\tcontroller plugin.GRPCControllerClient\n}\n\n// ClientProtocol impl.\nfunc (c *GRPCClient) Close() error {\n\tc.broker.Close()\n\tc.controller.Shutdown(c.doneCtx, &plugin.Empty{})\n\treturn c.Conn.Close()\n}\n\n// ClientProtocol impl.\nfunc (c *GRPCClient) Dispense(name string) (interface{}, error) {\n\traw, ok := c.Plugins[name]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unknown plugin type: %s\", name)\n\t}\n\n\tp, ok := raw.(GRPCPlugin)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"plugin %q doesn't support gRPC\", name)\n\t}\n\n\treturn p.GRPCClient(c.doneCtx, c.broker, c.Conn)\n}\n\n// ClientProtocol impl.\nfunc (c *GRPCClient) Ping() error {\n\tclient := grpc_health_v1.NewHealthClient(c.Conn)\n\t_, err := client.Check(context.Background(), &grpc_health_v1.HealthCheckRequest{\n\t\tService: GRPCServiceName,\n\t})\n\n\treturn err\n}\n"
        },
        {
          "name": "grpc_client_test.go",
          "type": "blob",
          "size": 4.28125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"testing\"\n\n\tgrpctest \"github.com/hashicorp/go-plugin/test/grpc\"\n\t\"github.com/jhump/protoreflect/grpcreflect\"\n\t\"google.golang.org/grpc\"\n\treflectpb \"google.golang.org/grpc/reflection/grpc_reflection_v1alpha\"\n)\n\nfunc TestGRPC_App(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\ttestGRPCClientApp(t, false)\n\t})\n\tt.Run(\"mux\", func(t *testing.T) {\n\t\ttestGRPCClientApp(t, true)\n\t})\n}\n\nfunc testGRPCClientApp(t *testing.T, multiplex bool) {\n\tclient, server := TestPluginGRPCConn(t, multiplex, map[string]Plugin{\n\t\t\"test\": new(testGRPCInterfacePlugin),\n\t})\n\tdefer client.Close()\n\tdefer server.Stop()\n\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n\n\terr = impl.Bidirectional()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGRPCConn_BidirectionalPing(t *testing.T) {\n\tconn, _ := TestGRPCConn(t, func(s *grpc.Server) {\n\t\tgrpctest.RegisterPingPongServer(s, &pingPongServer{})\n\t})\n\tdefer conn.Close()\n\tpingPongClient := grpctest.NewPingPongClient(conn)\n\n\tpResp, err := pingPongClient.Ping(context.Background(), &grpctest.PingRequest{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pResp.Msg != \"pong\" {\n\t\tt.Fatal(\"Bad PingPong\")\n\t}\n}\n\nfunc TestGRPCC_Stream(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\ttestGRPCStream(t, false)\n\t})\n\tt.Run(\"mux\", func(t *testing.T) {\n\t\ttestGRPCStream(t, true)\n\t})\n}\n\nfunc testGRPCStream(t *testing.T, multiplex bool) {\n\tclient, server := TestPluginGRPCConn(t, multiplex, map[string]Plugin{\n\t\t\"test\": new(testGRPCInterfacePlugin),\n\t})\n\tdefer client.Close()\n\tdefer server.Stop()\n\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\timpl, ok := raw.(testStreamer)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\texpected := []int32{21, 22, 23, 24, 25, 26}\n\tresult, err := impl.Stream(21, 27)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Fatalf(\"expected: %v\\ngot: %v\", expected, result)\n\t}\n}\n\nfunc TestGRPC_Ping(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\ttestGRPCClientPing(t, false)\n\t})\n\tt.Run(\"mux\", func(t *testing.T) {\n\t\ttestGRPCClientPing(t, true)\n\t})\n}\n\nfunc testGRPCClientPing(t *testing.T, multiplex bool) {\n\tclient, server := TestPluginGRPCConn(t, multiplex, map[string]Plugin{\n\t\t\"test\": new(testGRPCInterfacePlugin),\n\t})\n\tdefer client.Close()\n\tdefer server.Stop()\n\n\t// Run a couple pings\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Close the remote end\n\tserver.server.Stop()\n\n\t// Test ping fails\n\tif err := client.Ping(); err == nil {\n\t\tt.Fatal(\"should error\")\n\t}\n}\n\nfunc TestGRPC_Reflection(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\ttestGRPCClientReflection(t, false)\n\t})\n\tt.Run(\"mux\", func(t *testing.T) {\n\t\ttestGRPCClientReflection(t, true)\n\t})\n}\n\nfunc testGRPCClientReflection(t *testing.T, multiplex bool) {\n\tctx := context.Background()\n\n\tclient, server := TestPluginGRPCConn(t, multiplex, map[string]Plugin{\n\t\t\"test\": new(testGRPCInterfacePlugin),\n\t})\n\tdefer client.Close()\n\tdefer server.Stop()\n\n\trefClient := grpcreflect.NewClient(ctx, reflectpb.NewServerReflectionClient(client.Conn))\n\n\tsvcs, err := refClient.ListServices()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// TODO: maybe only assert some specific services here to make test more resilient\n\texpectedSvcs := []string{\"grpc.health.v1.Health\", \"grpc.reflection.v1.ServerReflection\", \"grpc.reflection.v1alpha.ServerReflection\", \"grpctest.Test\", \"plugin.GRPCBroker\", \"plugin.GRPCController\", \"plugin.GRPCStdio\"}\n\n\tif !reflect.DeepEqual(svcs, expectedSvcs) {\n\t\tt.Fatalf(\"expected: %v\\ngot: %v\", expectedSvcs, svcs)\n\t}\n\n\thealthDesc, err := refClient.ResolveService(\"grpc.health.v1.Health\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tmethods := healthDesc.GetMethods()\n\tvar methodNames []string\n\tfor _, m := range methods {\n\t\tmethodNames = append(methodNames, m.GetName())\n\t}\n\n\texpectedMethodNames := []string{\"Check\", \"Watch\"}\n\n\tif !reflect.DeepEqual(methodNames, expectedMethodNames) {\n\t\tt.Fatalf(\"expected: %v\\ngot: %v\", expectedMethodNames, methodNames)\n\t}\n}\n"
        },
        {
          "name": "grpc_controller.go",
          "type": "blob",
          "size": 0.638671875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\n\t\"github.com/hashicorp/go-plugin/internal/plugin\"\n)\n\n// GRPCControllerServer handles shutdown calls to terminate the server when the\n// plugin client is closed.\ntype grpcControllerServer struct {\n\tserver *GRPCServer\n}\n\n// Shutdown stops the grpc server. It first will attempt a graceful stop, then a\n// full stop on the server.\nfunc (s *grpcControllerServer) Shutdown(ctx context.Context, _ *plugin.Empty) (*plugin.Empty, error) {\n\tresp := &plugin.Empty{}\n\n\t// TODO: figure out why GracefullStop doesn't work.\n\ts.server.Stop()\n\treturn resp, nil\n}\n"
        },
        {
          "name": "grpc_server.go",
          "type": "blob",
          "size": 4.599609375,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\thclog \"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/grpcmux\"\n\t\"github.com/hashicorp/go-plugin/internal/plugin\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\n// GRPCServiceName is the name of the service that the health check should\n// return as passing.\nconst GRPCServiceName = \"plugin\"\n\n// DefaultGRPCServer can be used with the \"GRPCServer\" field for Server\n// as a default factory method to create a gRPC server with no extra options.\nfunc DefaultGRPCServer(opts []grpc.ServerOption) *grpc.Server {\n\treturn grpc.NewServer(opts...)\n}\n\n// GRPCServer is a ServerType implementation that serves plugins over\n// gRPC. This allows plugins to easily be written for other languages.\n//\n// The GRPCServer outputs a custom configuration as a base64-encoded\n// JSON structure represented by the GRPCServerConfig config structure.\ntype GRPCServer struct {\n\t// Plugins are the list of plugins to serve.\n\tPlugins map[string]Plugin\n\n\t// Server is the actual server that will accept connections. This\n\t// will be used for plugin registration as well.\n\tServer func([]grpc.ServerOption) *grpc.Server\n\n\t// TLS should be the TLS configuration if available. If this is nil,\n\t// the connection will not have transport security.\n\tTLS *tls.Config\n\n\t// DoneCh is the channel that is closed when this server has exited.\n\tDoneCh chan struct{}\n\n\t// Stdout/StderrLis are the readers for stdout/stderr that will be copied\n\t// to the stdout/stderr connection that is output.\n\tStdout io.Reader\n\tStderr io.Reader\n\n\tconfig      GRPCServerConfig\n\tserver      *grpc.Server\n\tbroker      *GRPCBroker\n\tstdioServer *grpcStdioServer\n\n\tlogger hclog.Logger\n\n\tmuxer *grpcmux.GRPCServerMuxer\n}\n\n// ServerProtocol impl.\nfunc (s *GRPCServer) Init() error {\n\t// Create our server\n\tvar opts []grpc.ServerOption\n\tif s.TLS != nil {\n\t\topts = append(opts, grpc.Creds(credentials.NewTLS(s.TLS)))\n\t}\n\ts.server = s.Server(opts)\n\n\t// Register the health service\n\thealthCheck := health.NewServer()\n\thealthCheck.SetServingStatus(\n\t\tGRPCServiceName, grpc_health_v1.HealthCheckResponse_SERVING)\n\tgrpc_health_v1.RegisterHealthServer(s.server, healthCheck)\n\n\t// Register the reflection service\n\treflection.Register(s.server)\n\n\t// Register the broker service\n\tbrokerServer := newGRPCBrokerServer()\n\tplugin.RegisterGRPCBrokerServer(s.server, brokerServer)\n\ts.broker = newGRPCBroker(brokerServer, s.TLS, unixSocketConfigFromEnv(), nil, s.muxer)\n\tgo s.broker.Run()\n\n\t// Register the controller\n\tcontrollerServer := &grpcControllerServer{server: s}\n\tplugin.RegisterGRPCControllerServer(s.server, controllerServer)\n\n\t// Register the stdio service\n\ts.stdioServer = newGRPCStdioServer(s.logger, s.Stdout, s.Stderr)\n\tplugin.RegisterGRPCStdioServer(s.server, s.stdioServer)\n\n\t// Register all our plugins onto the gRPC server.\n\tfor k, raw := range s.Plugins {\n\t\tp, ok := raw.(GRPCPlugin)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"%q is not a GRPC-compatible plugin\", k)\n\t\t}\n\n\t\tif err := p.GRPCServer(s.broker, s.server); err != nil {\n\t\t\treturn fmt.Errorf(\"error registering %q: %s\", k, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Stop calls Stop on the underlying grpc.Server and Close on the underlying\n// grpc.Broker if present.\nfunc (s *GRPCServer) Stop() {\n\ts.server.Stop()\n\n\tif s.broker != nil {\n\t\ts.broker.Close()\n\t\ts.broker = nil\n\t}\n}\n\n// GracefulStop calls GracefulStop on the underlying grpc.Server and Close on\n// the underlying grpc.Broker if present.\nfunc (s *GRPCServer) GracefulStop() {\n\ts.server.GracefulStop()\n\n\tif s.broker != nil {\n\t\ts.broker.Close()\n\t\ts.broker = nil\n\t}\n}\n\n// Config is the GRPCServerConfig encoded as JSON then base64.\nfunc (s *GRPCServer) Config() string {\n\t// Create a buffer that will contain our final contents\n\tvar buf bytes.Buffer\n\n\t// Wrap the base64 encoding with JSON encoding.\n\tif err := json.NewEncoder(&buf).Encode(s.config); err != nil {\n\t\t// We panic since ths shouldn't happen under any scenario. We\n\t\t// carefully control the structure being encoded here and it should\n\t\t// always be successful.\n\t\tpanic(err)\n\t}\n\n\treturn buf.String()\n}\n\nfunc (s *GRPCServer) Serve(lis net.Listener) {\n\tdefer close(s.DoneCh)\n\terr := s.server.Serve(lis)\n\tif err != nil {\n\t\ts.logger.Error(\"grpc server\", \"error\", err)\n\t}\n}\n\n// GRPCServerConfig is the extra configuration passed along for consumers\n// to facilitate using GRPC plugins.\ntype GRPCServerConfig struct {\n\tStdoutAddr string `json:\"stdout_addr\"`\n\tStderrAddr string `json:\"stderr_addr\"`\n}\n"
        },
        {
          "name": "grpc_stdio.go",
          "type": "blob",
          "size": 5.8408203125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\n\tempty \"github.com/golang/protobuf/ptypes/empty\"\n\thclog \"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/plugin\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\n// grpcStdioBuffer is the buffer size we try to fill when sending a chunk of\n// stdio data. This is currently 1 KB for no reason other than that seems like\n// enough (stdio data isn't that common) and is fairly low.\nconst grpcStdioBuffer = 1 * 1024\n\n// grpcStdioServer implements the Stdio service and streams stdiout/stderr.\ntype grpcStdioServer struct {\n\tstdoutCh <-chan []byte\n\tstderrCh <-chan []byte\n}\n\n// newGRPCStdioServer creates a new grpcStdioServer and starts the stream\n// copying for the given out and err readers.\n//\n// This must only be called ONCE per srcOut, srcErr.\nfunc newGRPCStdioServer(log hclog.Logger, srcOut, srcErr io.Reader) *grpcStdioServer {\n\tstdoutCh := make(chan []byte)\n\tstderrCh := make(chan []byte)\n\n\t// Begin copying the streams\n\tgo copyChan(log, stdoutCh, srcOut)\n\tgo copyChan(log, stderrCh, srcErr)\n\n\t// Construct our server\n\treturn &grpcStdioServer{\n\t\tstdoutCh: stdoutCh,\n\t\tstderrCh: stderrCh,\n\t}\n}\n\n// StreamStdio streams our stdout/err as the response.\nfunc (s *grpcStdioServer) StreamStdio(\n\t_ *empty.Empty,\n\tsrv plugin.GRPCStdio_StreamStdioServer,\n) error {\n\t// Share the same data value between runs. Sending this over the wire\n\t// marshals it so we can reuse this.\n\tvar data plugin.StdioData\n\n\tfor {\n\t\t// Read our data\n\t\tselect {\n\t\tcase data.Data = <-s.stdoutCh:\n\t\t\tdata.Channel = plugin.StdioData_STDOUT\n\n\t\tcase data.Data = <-s.stderrCh:\n\t\t\tdata.Channel = plugin.StdioData_STDERR\n\n\t\tcase <-srv.Context().Done():\n\t\t\treturn nil\n\t\t}\n\n\t\t// Not sure if this is possible, but if we somehow got here and\n\t\t// we didn't populate any data at all, then just continue.\n\t\tif len(data.Data) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Send our data to the client.\n\t\tif err := srv.Send(&data); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// grpcStdioClient wraps the stdio service as a client to copy\n// the stdio data to output writers.\ntype grpcStdioClient struct {\n\tlog         hclog.Logger\n\tstdioClient plugin.GRPCStdio_StreamStdioClient\n}\n\n// newGRPCStdioClient creates a grpcStdioClient. This will perform the\n// initial connection to the stdio service. If the stdio service is unavailable\n// then this will be a no-op. This allows this to work without error for\n// plugins that don't support this.\nfunc newGRPCStdioClient(\n\tctx context.Context,\n\tlog hclog.Logger,\n\tconn *grpc.ClientConn,\n) (*grpcStdioClient, error) {\n\tclient := plugin.NewGRPCStdioClient(conn)\n\n\t// Connect immediately to the endpoint\n\tstdioClient, err := client.StreamStdio(ctx, &empty.Empty{})\n\n\t// If we get an Unavailable or Unimplemented error, this means that the plugin isn't\n\t// updated and linking to the latest version of go-plugin that supports\n\t// this. We fall back to the previous behavior of just not syncing anything.\n\tif status.Code(err) == codes.Unavailable || status.Code(err) == codes.Unimplemented {\n\t\tlog.Warn(\"stdio service not available, stdout/stderr syncing unavailable\")\n\t\tstdioClient = nil\n\t\terr = nil\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &grpcStdioClient{\n\t\tlog:         log,\n\t\tstdioClient: stdioClient,\n\t}, nil\n}\n\n// Run starts the loop that receives stdio data and writes it to the given\n// writers. This blocks and should be run in a goroutine.\nfunc (c *grpcStdioClient) Run(stdout, stderr io.Writer) {\n\t// This will be nil if stdio is not supported by the plugin\n\tif c.stdioClient == nil {\n\t\tc.log.Warn(\"stdio service unavailable, run will do nothing\")\n\t\treturn\n\t}\n\n\tfor {\n\t\tc.log.Trace(\"waiting for stdio data\")\n\t\tdata, err := c.stdioClient.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF ||\n\t\t\t\tstatus.Code(err) == codes.Unavailable ||\n\t\t\t\tstatus.Code(err) == codes.Canceled ||\n\t\t\t\tstatus.Code(err) == codes.Unimplemented ||\n\t\t\t\terr == context.Canceled {\n\t\t\t\tc.log.Debug(\"received EOF, stopping recv loop\", \"err\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tc.log.Error(\"error receiving data\", \"err\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Determine our output writer based on channel\n\t\tvar w io.Writer\n\t\tswitch data.Channel {\n\t\tcase plugin.StdioData_STDOUT:\n\t\t\tw = stdout\n\n\t\tcase plugin.StdioData_STDERR:\n\t\t\tw = stderr\n\n\t\tdefault:\n\t\t\tc.log.Warn(\"unknown channel, dropping\", \"channel\", data.Channel)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Write! In the event of an error we just continue.\n\t\tif c.log.IsTrace() {\n\t\t\tc.log.Trace(\"received data\", \"channel\", data.Channel.String(), \"len\", len(data.Data))\n\t\t}\n\t\tif _, err := io.Copy(w, bytes.NewReader(data.Data)); err != nil {\n\t\t\tc.log.Error(\"failed to copy all bytes\", \"err\", err)\n\t\t}\n\t}\n}\n\n// copyChan copies an io.Reader into a channel.\nfunc copyChan(log hclog.Logger, dst chan<- []byte, src io.Reader) {\n\tbufsrc := bufio.NewReader(src)\n\n\tfor {\n\t\t// Make our data buffer. We allocate a new one per loop iteration\n\t\t// so that we can send it over the channel.\n\t\tvar data [1024]byte\n\n\t\t// Read the data, this will block until data is available\n\t\tn, err := bufsrc.Read(data[:])\n\n\t\t// We have to check if we have data BEFORE err != nil. The bufio\n\t\t// docs guarantee n == 0 on EOF but its better to be safe here.\n\t\tif n > 0 {\n\t\t\t// We have data! Send it on the channel. This will block if there\n\t\t\t// is no reader on the other side. We expect that go-plugin will\n\t\t\t// connect immediately to the stdio server to drain this so we want\n\t\t\t// this block to happen for backpressure.\n\t\t\tdst <- data[:n]\n\t\t}\n\n\t\t// If we hit EOF we're done copying\n\t\tif err == io.EOF {\n\t\t\tlog.Debug(\"stdio EOF, exiting copy loop\")\n\t\t\treturn\n\t\t}\n\n\t\t// Any other error we just exit the loop. We don't expect there to\n\t\t// be errors since our use case for this is reading/writing from\n\t\t// a in-process pipe (os.Pipe).\n\t\tif err != nil {\n\t\t\tlog.Warn(\"error copying stdio data, stopping copy\", \"err\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "log_entry.go",
          "type": "blob",
          "size": 1.63671875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\n// logEntry is the JSON payload that gets sent to Stderr from the plugin to the host\ntype logEntry struct {\n\tMessage   string        `json:\"@message\"`\n\tLevel     string        `json:\"@level\"`\n\tTimestamp time.Time     `json:\"timestamp\"`\n\tKVPairs   []*logEntryKV `json:\"kv_pairs\"`\n}\n\n// logEntryKV is a key value pair within the Output payload\ntype logEntryKV struct {\n\tKey   string      `json:\"key\"`\n\tValue interface{} `json:\"value\"`\n}\n\n// flattenKVPairs is used to flatten KVPair slice into []interface{}\n// for hclog consumption.\nfunc flattenKVPairs(kvs []*logEntryKV) []interface{} {\n\tvar result []interface{}\n\tfor _, kv := range kvs {\n\t\tresult = append(result, kv.Key)\n\t\tresult = append(result, kv.Value)\n\t}\n\n\treturn result\n}\n\n// parseJSON handles parsing JSON output\nfunc parseJSON(input []byte) (*logEntry, error) {\n\tvar raw map[string]interface{}\n\tentry := &logEntry{}\n\n\terr := json.Unmarshal(input, &raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse hclog-specific objects\n\tif v, ok := raw[\"@message\"]; ok {\n\t\tentry.Message = v.(string)\n\t\tdelete(raw, \"@message\")\n\t}\n\n\tif v, ok := raw[\"@level\"]; ok {\n\t\tentry.Level = v.(string)\n\t\tdelete(raw, \"@level\")\n\t}\n\n\tif v, ok := raw[\"@timestamp\"]; ok {\n\t\tt, err := time.Parse(\"2006-01-02T15:04:05.000000Z07:00\", v.(string))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentry.Timestamp = t\n\t\tdelete(raw, \"@timestamp\")\n\t}\n\n\t// Parse dynamic KV args from the hclog payload.\n\tfor k, v := range raw {\n\t\tentry.KVPairs = append(entry.KVPairs, &logEntryKV{\n\t\t\tKey:   k,\n\t\t\tValue: v,\n\t\t})\n\t}\n\n\treturn entry, nil\n}\n"
        },
        {
          "name": "mtls.go",
          "type": "blob",
          "size": 1.8818359375,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"math/big\"\n\t\"time\"\n)\n\n// generateCert generates a temporary certificate for plugin authentication. The\n// certificate and private key are returns in PEM format.\nfunc generateCert() (cert []byte, privateKey []byte, err error) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tsn, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\thost := \"localhost\"\n\n\ttemplate := &x509.Certificate{\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   host,\n\t\t\tOrganization: []string{\"HashiCorp\"},\n\t\t},\n\t\tDNSNames: []string{host},\n\t\tExtKeyUsage: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageClientAuth,\n\t\t\tx509.ExtKeyUsageServerAuth,\n\t\t},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment | x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,\n\t\tBasicConstraintsValid: true,\n\t\tSerialNumber:          sn,\n\t\tNotBefore:             time.Now().Add(-30 * time.Second),\n\t\tNotAfter:              time.Now().Add(262980 * time.Hour),\n\t\tIsCA:                  true,\n\t}\n\n\tder, err := x509.CreateCertificate(rand.Reader, template, template, key.Public(), key)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar certOut bytes.Buffer\n\tif err := pem.Encode(&certOut, &pem.Block{Type: \"CERTIFICATE\", Bytes: der}); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tkeyBytes, err := x509.MarshalECPrivateKey(key)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar keyOut bytes.Buffer\n\tif err := pem.Encode(&keyOut, &pem.Block{Type: \"EC PRIVATE KEY\", Bytes: keyBytes}); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert = certOut.Bytes()\n\tprivateKey = keyOut.Bytes()\n\n\treturn cert, privateKey, nil\n}\n"
        },
        {
          "name": "mux_broker.go",
          "type": "blob",
          "size": 4.70703125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/hashicorp/yamux\"\n)\n\n// MuxBroker is responsible for brokering multiplexed connections by unique ID.\n//\n// It is used by plugins to multiplex multiple RPC connections and data\n// streams on top of a single connection between the plugin process and the\n// host process.\n//\n// This allows a plugin to request a channel with a specific ID to connect to\n// or accept a connection from, and the broker handles the details of\n// holding these channels open while they're being negotiated.\n//\n// The Plugin interface has access to these for both Server and Client.\n// The broker can be used by either (optionally) to reserve and connect to\n// new multiplexed streams. This is useful for complex args and return values,\n// or anything else you might need a data stream for.\ntype MuxBroker struct {\n\tnextId  uint32\n\tsession *yamux.Session\n\tstreams map[uint32]*muxBrokerPending\n\n\tsync.Mutex\n}\n\ntype muxBrokerPending struct {\n\tch     chan net.Conn\n\tdoneCh chan struct{}\n}\n\nfunc newMuxBroker(s *yamux.Session) *MuxBroker {\n\treturn &MuxBroker{\n\t\tsession: s,\n\t\tstreams: make(map[uint32]*muxBrokerPending),\n\t}\n}\n\n// Accept accepts a connection by ID.\n//\n// This should not be called multiple times with the same ID at one time.\nfunc (m *MuxBroker) Accept(id uint32) (net.Conn, error) {\n\tvar c net.Conn\n\tp := m.getStream(id)\n\tselect {\n\tcase c = <-p.ch:\n\t\tclose(p.doneCh)\n\tcase <-time.After(5 * time.Second):\n\t\tm.Lock()\n\t\tdefer m.Unlock()\n\t\tdelete(m.streams, id)\n\n\t\treturn nil, fmt.Errorf(\"timeout waiting for accept\")\n\t}\n\n\t// Ack our connection\n\tif err := binary.Write(c, binary.LittleEndian, id); err != nil {\n\t\tc.Close()\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}\n\n// AcceptAndServe is used to accept a specific stream ID and immediately\n// serve an RPC server on that stream ID. This is used to easily serve\n// complex arguments.\n//\n// The served interface is always registered to the \"Plugin\" name.\nfunc (m *MuxBroker) AcceptAndServe(id uint32, v interface{}) {\n\tconn, err := m.Accept(id)\n\tif err != nil {\n\t\tlog.Printf(\"[ERR] plugin: plugin acceptAndServe error: %s\", err)\n\t\treturn\n\t}\n\n\tserve(conn, \"Plugin\", v)\n}\n\n// Close closes the connection and all sub-connections.\nfunc (m *MuxBroker) Close() error {\n\treturn m.session.Close()\n}\n\n// Dial opens a connection by ID.\nfunc (m *MuxBroker) Dial(id uint32) (net.Conn, error) {\n\t// Open the stream\n\tstream, err := m.session.OpenStream()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Write the stream ID onto the wire.\n\tif err := binary.Write(stream, binary.LittleEndian, id); err != nil {\n\t\tstream.Close()\n\t\treturn nil, err\n\t}\n\n\t// Read the ack that we connected. Then we're off!\n\tvar ack uint32\n\tif err := binary.Read(stream, binary.LittleEndian, &ack); err != nil {\n\t\tstream.Close()\n\t\treturn nil, err\n\t}\n\tif ack != id {\n\t\tstream.Close()\n\t\treturn nil, fmt.Errorf(\"bad ack: %d (expected %d)\", ack, id)\n\t}\n\n\treturn stream, nil\n}\n\n// NextId returns a unique ID to use next.\n//\n// It is possible for very long-running plugin hosts to wrap this value,\n// though it would require a very large amount of RPC calls. In practice\n// we've never seen it happen.\nfunc (m *MuxBroker) NextId() uint32 {\n\treturn atomic.AddUint32(&m.nextId, 1)\n}\n\n// Run starts the brokering and should be executed in a goroutine, since it\n// blocks forever, or until the session closes.\n//\n// Uses of MuxBroker never need to call this. It is called internally by\n// the plugin host/client.\nfunc (m *MuxBroker) Run() {\n\tfor {\n\t\tstream, err := m.session.AcceptStream()\n\t\tif err != nil {\n\t\t\t// Once we receive an error, just exit\n\t\t\tbreak\n\t\t}\n\n\t\t// Read the stream ID from the stream\n\t\tvar id uint32\n\t\tif err := binary.Read(stream, binary.LittleEndian, &id); err != nil {\n\t\t\tstream.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\t// Initialize the waiter\n\t\tp := m.getStream(id)\n\t\tselect {\n\t\tcase p.ch <- stream:\n\t\tdefault:\n\t\t}\n\n\t\t// Wait for a timeout\n\t\tgo m.timeoutWait(id, p)\n\t}\n}\n\nfunc (m *MuxBroker) getStream(id uint32) *muxBrokerPending {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tp, ok := m.streams[id]\n\tif ok {\n\t\treturn p\n\t}\n\n\tm.streams[id] = &muxBrokerPending{\n\t\tch:     make(chan net.Conn, 1),\n\t\tdoneCh: make(chan struct{}),\n\t}\n\treturn m.streams[id]\n}\n\nfunc (m *MuxBroker) timeoutWait(id uint32, p *muxBrokerPending) {\n\t// Wait for the stream to either be picked up and connected, or\n\t// for a timeout.\n\ttimeout := false\n\tselect {\n\tcase <-p.doneCh:\n\tcase <-time.After(5 * time.Second):\n\t\ttimeout = true\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\t// Delete the stream so no one else can grab it\n\tdelete(m.streams, id)\n\n\t// If we timed out, then check if we have a channel in the buffer,\n\t// and if so, close it.\n\tif timeout {\n\t\tselect {\n\t\tcase s := <-p.ch:\n\t\t\ts.Close()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "plugin.go",
          "type": "blob",
          "size": 2.1748046875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\n// The plugin package exposes functions and helpers for communicating to\n// plugins which are implemented as standalone binary applications.\n//\n// plugin.Client fully manages the lifecycle of executing the application,\n// connecting to it, and returning the RPC client for dispensing plugins.\n//\n// plugin.Serve fully manages listeners to expose an RPC server from a binary\n// that plugin.Client can connect to.\npackage plugin\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/rpc\"\n\n\t\"google.golang.org/grpc\"\n)\n\n// Plugin is the interface that is implemented to serve/connect to an\n// inteface implementation.\ntype Plugin interface {\n\t// Server should return the RPC server compatible struct to serve\n\t// the methods that the Client calls over net/rpc.\n\tServer(*MuxBroker) (interface{}, error)\n\n\t// Client returns an interface implementation for the plugin you're\n\t// serving that communicates to the server end of the plugin.\n\tClient(*MuxBroker, *rpc.Client) (interface{}, error)\n}\n\n// GRPCPlugin is the interface that is implemented to serve/connect to\n// a plugin over gRPC.\ntype GRPCPlugin interface {\n\t// GRPCServer should register this plugin for serving with the\n\t// given GRPCServer. Unlike Plugin.Server, this is only called once\n\t// since gRPC plugins serve singletons.\n\tGRPCServer(*GRPCBroker, *grpc.Server) error\n\n\t// GRPCClient should return the interface implementation for the plugin\n\t// you're serving via gRPC. The provided context will be canceled by\n\t// go-plugin in the event of the plugin process exiting.\n\tGRPCClient(context.Context, *GRPCBroker, *grpc.ClientConn) (interface{}, error)\n}\n\n// NetRPCUnsupportedPlugin implements Plugin but returns errors for the\n// Server and Client functions. This will effectively disable support for\n// net/rpc based plugins.\n//\n// This struct can be embedded in your struct.\ntype NetRPCUnsupportedPlugin struct{}\n\nfunc (p NetRPCUnsupportedPlugin) Server(*MuxBroker) (interface{}, error) {\n\treturn nil, errors.New(\"net/rpc plugin protocol not supported\")\n}\n\nfunc (p NetRPCUnsupportedPlugin) Client(*MuxBroker, *rpc.Client) (interface{}, error) {\n\treturn nil, errors.New(\"net/rpc plugin protocol not supported\")\n}\n"
        },
        {
          "name": "plugin_test.go",
          "type": "blob",
          "size": 22.37890625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/rpc\"\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"github.com/hashicorp/go-hclog\"\n\tgrpctest \"github.com/hashicorp/go-plugin/test/grpc\"\n\t\"google.golang.org/grpc\"\n)\n\n// Test that NetRPCUnsupportedPlugin implements the correct interfaces.\nvar _ Plugin = new(NetRPCUnsupportedPlugin)\n\nvar testHandshake = HandshakeConfig{\n\tProtocolVersion:  1,\n\tMagicCookieKey:   \"TEST_MAGIC_COOKIE\",\n\tMagicCookieValue: \"test\",\n}\n\nvar testVersionedHandshake = HandshakeConfig{\n\tMagicCookieKey:   \"TEST_MAGIC_COOKIE\",\n\tMagicCookieValue: \"test\",\n}\n\n// testInterface is the test interface we use for plugins.\ntype testInterface interface {\n\tDouble(int) int\n\tPrintKV(string, interface{})\n\tBidirectional() error\n\tPrintStdio(stdout, stderr []byte)\n}\n\n// testStreamer is used to test the grpc streaming interface\ntype testStreamer interface {\n\tStream(int32, int32) ([]int32, error)\n}\n\n// testInterfacePlugin implements the Plugin interface\nvar _ Plugin = (*testInterfacePlugin)(nil)\n\n// testInterfacePlugin is the implementation of Plugin to create\n// RPC client/server implementations for testInterface.\ntype testInterfacePlugin struct {\n\tImpl testInterface\n}\n\nfunc (p *testInterfacePlugin) Server(b *MuxBroker) (interface{}, error) {\n\treturn &testInterfaceServer{Impl: p.impl()}, nil\n}\n\nfunc (p *testInterfacePlugin) Client(b *MuxBroker, c *rpc.Client) (interface{}, error) {\n\treturn &testInterfaceClient{Client: c}, nil\n}\n\nfunc (p *testInterfacePlugin) impl() testInterface {\n\tif p.Impl != nil {\n\t\treturn p.Impl\n\t}\n\n\treturn &testInterfaceImpl{\n\t\tlogger: hclog.New(&hclog.LoggerOptions{\n\t\t\tLevel:      hclog.Trace,\n\t\t\tOutput:     os.Stderr,\n\t\t\tJSONFormat: true,\n\t\t}),\n\t}\n}\n\n// testGRPCInterfacePlugin implements both Plugin and GRPCPlugin interfaces\nvar _ Plugin = (*testGRPCInterfacePlugin)(nil)\nvar _ GRPCPlugin = (*testGRPCInterfacePlugin)(nil)\n\n// testGRPCInterfacePlugin is a test implementation of the GRPCPlugin interface\ntype testGRPCInterfacePlugin struct {\n\tImpl testInterface\n}\n\nfunc (p *testGRPCInterfacePlugin) Server(b *MuxBroker) (interface{}, error) {\n\treturn &testInterfaceServer{Impl: p.impl()}, nil\n}\n\nfunc (p *testGRPCInterfacePlugin) Client(b *MuxBroker, c *rpc.Client) (interface{}, error) {\n\treturn &testInterfaceClient{Client: c}, nil\n}\n\nfunc (p *testGRPCInterfacePlugin) GRPCServer(b *GRPCBroker, s *grpc.Server) error {\n\tgrpctest.RegisterTestServer(s, &testGRPCServer{broker: b, Impl: p.impl()})\n\treturn nil\n}\n\nfunc (p *testGRPCInterfacePlugin) GRPCClient(doneCtx context.Context, b *GRPCBroker, c *grpc.ClientConn) (interface{}, error) {\n\treturn &testGRPCClient{broker: b, Client: grpctest.NewTestClient(c)}, nil\n}\n\nfunc (p *testGRPCInterfacePlugin) impl() testInterface {\n\tif p.Impl != nil {\n\t\treturn p.Impl\n\t}\n\n\treturn &testInterfaceImpl{\n\t\tlogger: hclog.New(&hclog.LoggerOptions{\n\t\t\tLevel:      hclog.Trace,\n\t\t\tOutput:     os.Stderr,\n\t\t\tJSONFormat: true,\n\t\t}),\n\t}\n}\n\n// testInterfaceImpl implements testInterface concretely\nvar _ testInterface = (*testInterfaceImpl)(nil)\n\ntype testInterfaceImpl struct {\n\tlogger hclog.Logger\n}\n\nfunc (i *testInterfaceImpl) Double(v int) int { return v * 2 }\n\nfunc (i *testInterfaceImpl) PrintKV(key string, value interface{}) {\n\ti.logger.Info(\"PrintKV called\", key, value)\n}\n\nfunc (i *testInterfaceImpl) Bidirectional() error {\n\treturn nil\n}\n\nfunc (i *testInterfaceImpl) PrintStdio(stdout, stderr []byte) {\n\tif len(stdout) > 0 {\n\t\tfmt.Fprint(os.Stdout, string(stdout))\n\t\tos.Stdout.Sync()\n\t}\n\n\tif len(stderr) > 0 {\n\t\tfmt.Fprint(os.Stderr, string(stderr))\n\t\tos.Stderr.Sync()\n\t}\n}\n\n// testInterfaceClient implements testInterface to communicate over RPC\ntype testInterfaceClient struct {\n\tClient *rpc.Client\n}\n\nfunc (impl *testInterfaceClient) Double(v int) int {\n\tvar resp int\n\terr := impl.Client.Call(\"Plugin.Double\", v, &resp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn resp\n}\n\nfunc (impl *testInterfaceClient) PrintKV(key string, value interface{}) {\n\terr := impl.Client.Call(\"Plugin.PrintKV\", map[string]interface{}{\n\t\t\"key\":   key,\n\t\t\"value\": value,\n\t}, &struct{}{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (impl *testInterfaceClient) Bidirectional() error {\n\treturn nil\n}\n\nfunc (impl *testInterfaceClient) PrintStdio(stdout, stderr []byte) {\n\t// We don't implement this because we test stream syncing another\n\t// way (see rpc_client_test.go). We probably should test this way\n\t// but very few people use the net/rpc protocol nowadays so we didn'\n\t// put in the effort.\n\treturn\n}\n\n// testInterfaceServer is the RPC server for testInterfaceClient\ntype testInterfaceServer struct {\n\tBroker *MuxBroker\n\tImpl   testInterface\n}\n\nfunc (s *testInterfaceServer) Double(arg int, resp *int) error {\n\t*resp = s.Impl.Double(arg)\n\treturn nil\n}\n\nfunc (s *testInterfaceServer) PrintKV(args map[string]interface{}, _ *struct{}) error {\n\ts.Impl.PrintKV(args[\"key\"].(string), args[\"value\"])\n\treturn nil\n}\n\n// testPluginMap can be used for tests as a plugin map\nvar testPluginMap = map[string]Plugin{\n\t\"test\": new(testInterfacePlugin),\n}\n\n// testGRPCPluginMap can be used for tests as that need a GRPC plugin\nvar testGRPCPluginMap = map[string]Plugin{\n\t\"test\": new(testGRPCInterfacePlugin),\n}\n\n// testGRPCServer is the implementation of our GRPC service.\ntype testGRPCServer struct {\n\tImpl   testInterface\n\tbroker *GRPCBroker\n}\n\nfunc (s *testGRPCServer) Double(\n\tctx context.Context,\n\treq *grpctest.TestRequest) (*grpctest.TestResponse, error) {\n\treturn &grpctest.TestResponse{\n\t\tOutput: int32(s.Impl.Double(int(req.Input))),\n\t}, nil\n}\n\nfunc (s *testGRPCServer) PrintKV(\n\tctx context.Context,\n\treq *grpctest.PrintKVRequest) (*grpctest.PrintKVResponse, error) {\n\tvar v interface{}\n\tswitch rv := req.Value.(type) {\n\tcase *grpctest.PrintKVRequest_ValueString:\n\t\tv = rv.ValueString\n\n\tcase *grpctest.PrintKVRequest_ValueInt:\n\t\tv = rv.ValueInt\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown value: %#v\", req.Value))\n\t}\n\n\ts.Impl.PrintKV(req.Key, v)\n\treturn &grpctest.PrintKVResponse{}, nil\n}\n\nfunc (s *testGRPCServer) Bidirectional(ctx context.Context, req *grpctest.BidirectionalRequest) (*grpctest.BidirectionalResponse, error) {\n\tconn, err := s.broker.Dial(req.Id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"server dial error: %w\", err)\n\t}\n\n\tpingPongClient := grpctest.NewPingPongClient(conn)\n\tresp, err := pingPongClient.Ping(ctx, &grpctest.PingRequest{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"server Ping() error: %w\", err)\n\t}\n\tif resp.Msg != \"pong\" {\n\t\treturn nil, errors.New(\"server Bad PingPong\")\n\t}\n\n\tnextID := s.broker.NextId()\n\tgo s.broker.AcceptAndServe(nextID, func(opts []grpc.ServerOption) *grpc.Server {\n\t\ts := grpc.NewServer(opts...)\n\t\tgrpctest.RegisterPingPongServer(s, &pingPongServer{})\n\t\treturn s\n\t})\n\n\treturn &grpctest.BidirectionalResponse{\n\t\tId: nextID,\n\t}, nil\n}\n\nfunc (s *testGRPCServer) PrintStdio(\n\tctx context.Context,\n\treq *grpctest.PrintStdioRequest,\n) (*empty.Empty, error) {\n\ts.Impl.PrintStdio(req.Stdout, req.Stderr)\n\treturn &empty.Empty{}, nil\n}\n\ntype pingPongServer struct{}\n\nfunc (p *pingPongServer) Ping(ctx context.Context, req *grpctest.PingRequest) (*grpctest.PongResponse, error) {\n\treturn &grpctest.PongResponse{\n\t\tMsg: \"pong\",\n\t}, nil\n}\n\nfunc (s testGRPCServer) Stream(stream grpctest.Test_StreamServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := stream.Send(&grpctest.TestResponse{Output: req.Input}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// testGRPCClient is an implementation of TestInterface that communicates\n// over gRPC.\ntype testGRPCClient struct {\n\tClient grpctest.TestClient\n\tbroker *GRPCBroker\n}\n\nfunc (c *testGRPCClient) Double(v int) int {\n\tresp, err := c.Client.Double(context.Background(), &grpctest.TestRequest{\n\t\tInput: int32(v),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn int(resp.Output)\n}\n\nfunc (c *testGRPCClient) PrintKV(key string, value interface{}) {\n\treq := &grpctest.PrintKVRequest{Key: key}\n\tswitch v := value.(type) {\n\tcase string:\n\t\treq.Value = &grpctest.PrintKVRequest_ValueString{\n\t\t\tValueString: v,\n\t\t}\n\n\tcase int:\n\t\treq.Value = &grpctest.PrintKVRequest_ValueInt{\n\t\t\tValueInt: int32(v),\n\t\t}\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown type: %T\", value))\n\t}\n\n\t_, err := c.Client.PrintKV(context.Background(), req)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (c *testGRPCClient) Bidirectional() error {\n\tnextID := c.broker.NextId()\n\tgo c.broker.AcceptAndServe(nextID, func(opts []grpc.ServerOption) *grpc.Server {\n\t\ts := grpc.NewServer(opts...)\n\t\tgrpctest.RegisterPingPongServer(s, &pingPongServer{})\n\t\treturn s\n\t})\n\n\tresp, err := c.Client.Bidirectional(context.Background(), &grpctest.BidirectionalRequest{\n\t\tId: nextID,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"client Bidirectional() error: %w\", err)\n\t}\n\n\tconn, err := c.broker.Dial(resp.Id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"client dial error: %w\", err)\n\t}\n\n\tpingPongClient := grpctest.NewPingPongClient(conn)\n\tpResp, err := pingPongClient.Ping(context.Background(), &grpctest.PingRequest{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"client Ping() error: %w\", err)\n\t}\n\tif pResp.Msg != \"pong\" {\n\t\treturn errors.New(\"client Bad PingPong\")\n\t}\n\treturn nil\n}\n\n// Stream sends a series of requests from [start, stop) using a bidirectional\n// streaming service, and returns the streamed responses.\nfunc (impl *testGRPCClient) Stream(start, stop int32) ([]int32, error) {\n\tif stop <= start {\n\t\treturn nil, fmt.Errorf(\"invalid range [%d, %d)\", start, stop)\n\t}\n\tstreamClient, err := impl.Client.Stream(context.Background())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp []int32\n\tfor i := start; i < stop; i++ {\n\t\tif err := streamClient.Send(&grpctest.TestRequest{Input: i}); err != nil {\n\t\t\treturn resp, err\n\t\t}\n\n\t\tout, err := streamClient.Recv()\n\t\tif err != nil {\n\t\t\treturn resp, err\n\t\t}\n\n\t\tresp = append(resp, out.Output)\n\t}\n\n\tstreamClient.CloseSend()\n\n\treturn resp, nil\n}\n\nfunc (c *testGRPCClient) PrintStdio(stdout, stderr []byte) {\n\t_, err := c.Client.PrintStdio(context.Background(), &grpctest.PrintStdioRequest{\n\t\tStdout: stdout,\n\t\tStderr: stderr,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc helperProcess(s ...string) *exec.Cmd {\n\tcs := []string{\"-test.run=TestHelperProcess\", \"--\"}\n\tcs = append(cs, s...)\n\tenv := []string{\n\t\t\"GO_WANT_HELPER_PROCESS=1\",\n\t}\n\n\tcmd := exec.Command(os.Args[0], cs...)\n\tcmd.Env = append(env, os.Environ()...)\n\treturn cmd\n}\n\n// This is not a real test. This is just a helper process kicked off by\n// tests.\nfunc TestHelperProcess(*testing.T) {\n\tif os.Getenv(\"GO_WANT_HELPER_PROCESS\") != \"1\" {\n\t\treturn\n\t}\n\n\tdefer os.Exit(0)\n\n\targs := os.Args\n\tfor len(args) > 0 {\n\t\tif args[0] == \"--\" {\n\t\t\targs = args[1:]\n\t\t\tbreak\n\t\t}\n\n\t\targs = args[1:]\n\t}\n\n\tif len(args) == 0 {\n\t\tfmt.Fprintf(os.Stderr, \"No command\\n\")\n\t\tos.Exit(2)\n\t}\n\n\t// override testPluginMap with one that uses\n\t// hclog logger on its implementation\n\tpluginLogger := hclog.New(&hclog.LoggerOptions{\n\t\tLevel:      hclog.Trace,\n\t\tOutput:     os.Stderr,\n\t\tJSONFormat: true,\n\t})\n\n\ttestPlugin := &testInterfaceImpl{\n\t\tlogger: pluginLogger,\n\t}\n\n\ttestPluginMap := map[string]Plugin{\n\t\t\"test\": &testInterfacePlugin{Impl: testPlugin},\n\t}\n\n\ttestGRPCPluginMap := map[string]Plugin{\n\t\t\"test\": &testGRPCInterfacePlugin{Impl: testPlugin},\n\t}\n\n\tcmd, args := args[0], args[1:]\n\tswitch cmd {\n\tcase \"bad-version\":\n\t\t// If we have an arg, we write there on start\n\t\tif len(args) > 0 {\n\t\t\tpath := args[0]\n\t\t\terr := ioutil.WriteFile(path, []byte(\"foo\"), 0644)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Printf(\"%d|%d1|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\t<-make(chan int)\n\tcase \"invalid-rpc-address\":\n\t\tfmt.Println(\"lolinvalid\")\n\tcase \"mock\":\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\t<-make(chan int)\n\tcase \"start-timeout\":\n\t\ttime.Sleep(1 * time.Minute)\n\t\tos.Exit(1)\n\tcase \"stderr\":\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tos.Stderr.WriteString(\"HELLO\\n\")\n\t\tos.Stderr.WriteString(\"WORLD\\n\")\n\tcase \"stderr-json\":\n\t\t// write values that might be JSON, but aren't KVs\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tos.Stderr.WriteString(\"[\\\"HELLO\\\"]\\n\")\n\t\tos.Stderr.WriteString(\"12345\\n\")\n\t\tos.Stderr.WriteString(\"{\\\"a\\\":1}\\n\")\n\tcase \"level-warn-text\":\n\t\t// write values that might be JSON, but aren't KVs\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tos.Stderr.WriteString(\"[WARN] test line 98765\\n\")\n\tcase \"stdin\":\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tdata := make([]byte, 5)\n\t\tif _, err := os.Stdin.Read(data); err != nil {\n\t\t\tlog.Printf(\"stdin read error: %s\", err)\n\t\t\tos.Exit(100)\n\t\t}\n\n\t\tif string(data) == \"hello\" {\n\t\t\tos.Exit(0)\n\t\t}\n\n\t\tos.Exit(1)\n\tcase \"cleanup\":\n\t\t// Create a defer to write the file. This tests that we get cleaned\n\t\t// up properly versus just calling os.Exit\n\t\tpath := args[0]\n\t\tdefer func() {\n\t\t\terr := ioutil.WriteFile(path, []byte(\"foo\"), 0644)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}()\n\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t})\n\n\t\t// Exit\n\t\treturn\n\tcase \"test-grpc\":\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testGRPCPluginMap,\n\t\t\tGRPCServer:      DefaultGRPCServer,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-grpc-tls\":\n\t\t// Serve!\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testGRPCPluginMap,\n\t\t\tGRPCServer:      DefaultGRPCServer,\n\t\t\tTLSProvider:     helperTLSProvider,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-interface\":\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-interface-logger-netrpc\":\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t})\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-interface-logger-grpc\":\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t\tGRPCServer:      DefaultGRPCServer,\n\t\t})\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-interface-daemon\":\n\t\t// Serve!\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-interface-tls\":\n\t\t// Serve!\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t\tTLSProvider:     helperTLSProvider,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\n\tcase \"test-interface-mtls\":\n\t\t// Serve!\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testVersionedHandshake,\n\t\t\tPlugins:         testPluginMap,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\n\tcase \"test-versioned-plugins\":\n\t\t// Serve!\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testVersionedHandshake,\n\t\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t\t2: testGRPCPluginMap,\n\t\t\t},\n\t\t\tGRPCServer:  DefaultGRPCServer,\n\t\t\tTLSProvider: helperTLSProvider,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-proto-upgraded-plugin\":\n\t\t// Serve 2 plugins over different protocols\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: testVersionedHandshake,\n\t\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t\t1: PluginSet{\n\t\t\t\t\t\"old\": &testInterfacePlugin{Impl: testPlugin},\n\t\t\t\t},\n\t\t\t\t2: testGRPCPluginMap,\n\t\t\t},\n\t\t\tGRPCServer:  DefaultGRPCServer,\n\t\t\tTLSProvider: helperTLSProvider,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-proto-upgraded-client\":\n\t\t// Serve 2 plugins over different protocols\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: HandshakeConfig{\n\t\t\t\tProtocolVersion:  2,\n\t\t\t\tMagicCookieKey:   \"TEST_MAGIC_COOKIE\",\n\t\t\t\tMagicCookieValue: \"test\",\n\t\t\t},\n\t\t\tPlugins:     testGRPCPluginMap,\n\t\t\tGRPCServer:  DefaultGRPCServer,\n\t\t\tTLSProvider: helperTLSProvider,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-mtls\":\n\t\t// Serve 2 plugins over different protocols\n\t\tServe(&ServeConfig{\n\t\t\tHandshakeConfig: HandshakeConfig{\n\t\t\t\tProtocolVersion:  2,\n\t\t\t\tMagicCookieKey:   \"TEST_MAGIC_COOKIE\",\n\t\t\t\tMagicCookieValue: \"test\",\n\t\t\t},\n\t\t\tPlugins:    testGRPCPluginMap,\n\t\t\tGRPCServer: DefaultGRPCServer,\n\t\t})\n\n\t\t// Shouldn't reach here but make sure we exit anyways\n\t\tos.Exit(0)\n\tcase \"test-skip-host-env-true\":\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tif os.Getenv(\"PLUGIN_TEST_SKIP_HOST_ENV\") == \"\" {\n\t\t\tos.Exit(0)\n\t\t}\n\n\t\tos.Exit(1)\n\tcase \"test-skip-host-env-false\":\n\t\tfmt.Printf(\"%d|%d|tcp|:1234\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion)\n\t\tif os.Getenv(\"PLUGIN_TEST_SKIP_HOST_ENV\") != \"\" {\n\t\t\tos.Exit(0)\n\t\t}\n\n\t\tos.Exit(1)\n\tcase \"mux-grpc-with-old-plugin\":\n\t\t// gRPC broker multiplexing requested, but plugin has no awareness of the\n\t\t// feature, so just prints 6 segments in the protocol negotiation line.\n\t\t// Client should fail with a helpful error.\n\t\tif os.Getenv(envMultiplexGRPC) == \"\" {\n\t\t\tfmt.Println(\"failed precondition for mux test\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"%d|%d|tcp|:1234|%s|\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion, ProtocolGRPC)\n\t\t<-make(chan int)\n\tcase \"mux-grpc-with-unsupported-plugin\":\n\t\t// gRPC broker multiplexing requested, but plugin explicitly does not\n\t\t// support it. Client should fail with a helpful error.\n\t\tif os.Getenv(envMultiplexGRPC) == \"\" {\n\t\t\tfmt.Println(\"failed precondition for mux test\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"%d|%d|tcp|:1234|%s||false\\n\", CoreProtocolVersion, testHandshake.ProtocolVersion, ProtocolGRPC)\n\t\t<-make(chan int)\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"Unknown command: %q\\n\", cmd)\n\t\tos.Exit(2)\n\t}\n}\n\nfunc helperTLSProvider() (*tls.Config, error) {\n\tserverCert, err := tls.X509KeyPair([]byte(TestClusterServerCert), []byte(TestClusterServerKey))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trootCAs := x509.NewCertPool()\n\trootCAs.AppendCertsFromPEM([]byte(TestClusterCACert))\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{serverCert},\n\t\tRootCAs:      rootCAs,\n\t\tClientCAs:    rootCAs,\n\t\tClientAuth:   tls.VerifyClientCertIfGiven,\n\t\tServerName:   \"127.0.0.1\",\n\t}\n\ttlsConfig.BuildNameToCertificate()\n\n\treturn tlsConfig, nil\n}\n\nconst (\n\tTestClusterCACert = `-----BEGIN CERTIFICATE-----\nMIIDPjCCAiagAwIBAgIUfIKsF2VPT7sdFcKOHJH2Ii6K4MwwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAxMLbXl2YXVsdC5jb20wIBcNMTYwNTAyMTYwNTQyWhgPMjA2\nNjA0MjAxNjA2MTJaMBYxFDASBgNVBAMTC215dmF1bHQuY29tMIIBIjANBgkqhkiG\n9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuOimEXawD2qBoLCFP3Skq5zi1XzzcMAJlfdS\nxz9hfymuJb+cN8rB91HOdU9wQCwVKnkUtGWxUnMp0tT0uAZj5NzhNfyinf0JGAbP\n67HDzVZhGBHlHTjPX0638yaiUx90cTnucX0N20SgCYct29dMSgcPl+W78D3Jw3xE\nJsHQPYS9ASe2eONxG09F/qNw7w/RO5/6WYoV2EmdarMMxq52pPe2chtNMQdSyOUb\ncCcIZyk4QVFZ1ZLl6jTnUPb+JoCx1uMxXvMek4NF/5IL0Wr9dw2gKXKVKoHDr6SY\nWrCONRw61A5Zwx1V+kn73YX3USRlkufQv/ih6/xThYDAXDC9cwIDAQABo4GBMH8w\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFOuKvPiU\nG06iHkRXAOeMiUdBfHFyMB8GA1UdIwQYMBaAFOuKvPiUG06iHkRXAOeMiUdBfHFy\nMBwGA1UdEQQVMBOCC215dmF1bHQuY29thwR/AAABMA0GCSqGSIb3DQEBCwUAA4IB\nAQBcN/UdAMzc7UjRdnIpZvO+5keBGhL/vjltnGM1dMWYHa60Y5oh7UIXF+P1RdNW\nn7g80lOyvkSR15/r1rDkqOK8/4oruXU31EcwGhDOC4hU6yMUy4ltV/nBoodHBXNh\nMfKiXeOstH1vdI6G0P6W93Bcww6RyV1KH6sT2dbETCw+iq2VN9CrruGIWzd67UT/\nspe/kYttr3UYVV3O9kqgffVVgVXg/JoRZ3J7Hy2UEXfh9UtWNanDlRuXaZgE9s/d\nCpA30CHpNXvKeyNeW2ktv+2nAbSpvNW+e6MecBCTBIoDSkgU8ShbrzmDKVwNN66Q\n5gn6KxUPBKHEtNzs5DgGM7nq\n-----END CERTIFICATE-----`\n\n\tTestClusterServerCert = `-----BEGIN CERTIFICATE-----\nMIIDtzCCAp+gAwIBAgIUBLqh6ctGWVDUxFhxJX7m6S/bnrcwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAxMLbXl2YXVsdC5jb20wIBcNMTYwNTAyMTYwOTI2WhgPMjA2\nNjA0MjAxNTA5NTZaMBsxGTAXBgNVBAMTEGNlcnQubXl2YXVsdC5jb20wggEiMA0G\nCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDY3gPB29kkdbu0mPO6J0efagQhSiXB\n9OyDuLf5sMk6CVDWVWal5hISkyBmw/lXgF7qC2XFKivpJOrcGQd5Ep9otBqyJLzI\nb0IWdXuPIrVnXDwcdWr86ybX2iC42zKWfbXgjzGijeAVpl0UJLKBj+fk5q6NvkRL\n5FUL6TRV7Krn9mrmnrV9J5IqV15pTd9W2aVJ6IqWvIPCACtZKulqWn4707uy2X2W\n1Stq/5qnp1pDshiGk1VPyxCwQ6yw3iEcgecbYo3vQfhWcv7Q8LpSIM9ZYpXu6OmF\n+czqRZS9gERl+wipmmrN1MdYVrTuQem21C/PNZ4jo4XUk1SFx6JrcA+lAgMBAAGj\ngfUwgfIwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBSe\nCl9WV3BjGCwmS/KrDSLRjfwyqjAfBgNVHSMEGDAWgBTrirz4lBtOoh5EVwDnjIlH\nQXxxcjA7BggrBgEFBQcBAQQvMC0wKwYIKwYBBQUHMAKGH2h0dHA6Ly8xMjcuMC4w\nLjE6ODIwMC92MS9wa2kvY2EwIQYDVR0RBBowGIIQY2VydC5teXZhdWx0LmNvbYcE\nfwAAATAxBgNVHR8EKjAoMCagJKAihiBodHRwOi8vMTI3LjAuMC4xOjgyMDAvdjEv\ncGtpL2NybDANBgkqhkiG9w0BAQsFAAOCAQEAWGholPN8buDYwKbUiDavbzjsxUIX\nlU4MxEqOHw7CD3qIYIauPboLvB9EldBQwhgOOy607Yvdg3rtyYwyBFwPhHo/hK3Z\n6mn4hc6TF2V+AUdHBvGzp2dbYLeo8noVoWbQ/lBulggwlIHNNF6+a3kALqsqk1Ch\nf/hzsjFnDhAlNcYFgG8TgfE2lE/FckvejPqBffo7Q3I+wVAw0buqiz5QL81NOT+D\nY2S9LLKLRaCsWo9wRU1Az4Rhd7vK5SEMh16jJ82GyEODWPvuxOTI1MnzfnbWyLYe\nTTp6YBjGMVf1I6NEcWNur7U17uIOiQjMZ9krNvoMJ1A/cxCoZ98QHgcIPg==\n-----END CERTIFICATE-----`\n\n\tTestClusterServerKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA2N4DwdvZJHW7tJjzuidHn2oEIUolwfTsg7i3+bDJOglQ1lVm\npeYSEpMgZsP5V4Be6gtlxSor6STq3BkHeRKfaLQasiS8yG9CFnV7jyK1Z1w8HHVq\n/Osm19oguNsyln214I8xoo3gFaZdFCSygY/n5Oaujb5ES+RVC+k0Veyq5/Zq5p61\nfSeSKldeaU3fVtmlSeiKlryDwgArWSrpalp+O9O7stl9ltUrav+ap6daQ7IYhpNV\nT8sQsEOssN4hHIHnG2KN70H4VnL+0PC6UiDPWWKV7ujphfnM6kWUvYBEZfsIqZpq\nzdTHWFa07kHpttQvzzWeI6OF1JNUhceia3APpQIDAQABAoIBAQCH3vEzr+3nreug\nRoPNCXcSJXXY9X+aeT0FeeGqClzIg7Wl03OwVOjVwl/2gqnhbIgK0oE8eiNwurR6\nmSPZcxV0oAJpwiKU4T/imlCDaReGXn86xUX2l82KRxthNdQH/VLKEmzij0jpx4Vh\nbWx5SBPdkbmjDKX1dmTiRYWIn/KjyNPvNvmtwdi8Qluhf4eJcNEUr2BtblnGOmfL\nFdSu+brPJozpoQ1QdDnbAQRgqnh7Shl0tT85whQi0uquqIj1gEOGVjmBvDDnL3GV\nWOENTKqsmIIoEzdZrql1pfmYTk7WNaD92bfpN128j8BF7RmAV4/DphH0pvK05y9m\ntmRhyHGxAoGBAOV2BBocsm6xup575VqmFN+EnIOiTn+haOvfdnVsyQHnth63fOQx\nPNtMpTPR1OMKGpJ13e2bV0IgcYRsRkScVkUtoa/17VIgqZXffnJJ0A/HT67uKBq3\n8o7RrtyK5N20otw0lZHyqOPhyCdpSsurDhNON1kPVJVYY4N1RiIxfut/AoGBAPHz\nHfsJ5ZkyELE9N/r4fce04lprxWH+mQGK0/PfjS9caXPhj/r5ZkVMvzWesF3mmnY8\ngoE5S35TuTvV1+6rKGizwlCFAQlyXJiFpOryNWpLwCmDDSzLcm+sToAlML3tMgWU\njM3dWHx3C93c3ft4rSWJaUYI9JbHsMzDW6Yh+GbbAoGBANIbKwxh5Hx5XwEJP2yu\nkIROYCYkMy6otHLujgBdmPyWl+suZjxoXWoMl2SIqR8vPD+Jj6mmyNJy9J6lqf3f\nDRuQ+fEuBZ1i7QWfvJ+XuN0JyovJ5Iz6jC58D1pAD+p2IX3y5FXcVQs8zVJRFjzB\np0TEJOf2oqORaKWRd6ONoMKvAoGALKu6aVMWdQZtVov6/fdLIcgf0pn7Q3CCR2qe\nX3Ry2L+zKJYIw0mwvDLDSt8VqQCenB3n6nvtmFFU7ds5lvM67rnhsoQcAOaAehiS\nrl4xxoJd5Ewx7odRhZTGmZpEOYzFo4odxRSM9c30/u18fqV1Mm0AZtHYds4/sk6P\naUj0V+kCgYBMpGrJk8RSez5g0XZ35HfpI4ENoWbiwB59FIpWsLl2LADEh29eC455\nt9Muq7MprBVBHQo11TMLLFxDIjkuMho/gcKgpYXCt0LfiNm8EZehvLJUXH+3WqUx\nwe6ywrbFCs6LaxaOCtTiLsN+GbZCatITL0UJaeBmTAbiw0KQjUuZPQ==\n-----END RSA PRIVATE KEY-----`\n)\n"
        },
        {
          "name": "process.go",
          "type": "blob",
          "size": 0.0830078125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n"
        },
        {
          "name": "protocol.go",
          "type": "blob",
          "size": 1.3173828125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"io\"\n\t\"net\"\n)\n\n// Protocol is an enum representing the types of protocols.\ntype Protocol string\n\nconst (\n\tProtocolInvalid Protocol = \"\"\n\tProtocolNetRPC  Protocol = \"netrpc\"\n\tProtocolGRPC    Protocol = \"grpc\"\n)\n\n// ServerProtocol is an interface that must be implemented for new plugin\n// protocols to be servers.\ntype ServerProtocol interface {\n\t// Init is called once to configure and initialize the protocol, but\n\t// not start listening. This is the point at which all validation should\n\t// be done and errors returned.\n\tInit() error\n\n\t// Config is extra configuration to be outputted to stdout. This will\n\t// be automatically base64 encoded to ensure it can be parsed properly.\n\t// This can be an empty string if additional configuration is not needed.\n\tConfig() string\n\n\t// Serve is called to serve connections on the given listener. This should\n\t// continue until the listener is closed.\n\tServe(net.Listener)\n}\n\n// ClientProtocol is an interface that must be implemented for new plugin\n// protocols to be clients.\ntype ClientProtocol interface {\n\tio.Closer\n\n\t// Dispense dispenses a new instance of the plugin with the given name.\n\tDispense(string) (interface{}, error)\n\n\t// Ping checks that the client connection is still healthy.\n\tPing() error\n}\n"
        },
        {
          "name": "rpc_client.go",
          "type": "blob",
          "size": 4.2939453125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/rpc\"\n\n\t\"github.com/hashicorp/yamux\"\n)\n\n// RPCClient connects to an RPCServer over net/rpc to dispense plugin types.\ntype RPCClient struct {\n\tbroker  *MuxBroker\n\tcontrol *rpc.Client\n\tplugins map[string]Plugin\n\n\t// These are the streams used for the various stdout/err overrides\n\tstdout, stderr net.Conn\n}\n\n// newRPCClient creates a new RPCClient. The Client argument is expected\n// to be successfully started already with a lock held.\nfunc newRPCClient(c *Client) (*RPCClient, error) {\n\t// Connect to the client\n\tconn, err := net.Dial(c.address.Network(), c.address.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\t// Make sure to set keep alive so that the connection doesn't die\n\t\ttcpConn.SetKeepAlive(true)\n\t}\n\n\tif c.config.TLSConfig != nil {\n\t\tconn = tls.Client(conn, c.config.TLSConfig)\n\t}\n\n\t// Create the actual RPC client\n\tresult, err := NewRPCClient(conn, c.config.Plugins)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Begin the stream syncing so that stdin, out, err work properly\n\terr = result.SyncStreams(\n\t\tc.config.SyncStdout,\n\t\tc.config.SyncStderr)\n\tif err != nil {\n\t\tresult.Close()\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\n// NewRPCClient creates a client from an already-open connection-like value.\n// Dial is typically used instead.\nfunc NewRPCClient(conn io.ReadWriteCloser, plugins map[string]Plugin) (*RPCClient, error) {\n\t// Create the yamux client so we can multiplex\n\tmux, err := yamux.Client(conn, nil)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Connect to the control stream.\n\tcontrol, err := mux.Open()\n\tif err != nil {\n\t\tmux.Close()\n\t\treturn nil, err\n\t}\n\n\t// Connect stdout, stderr streams\n\tstdstream := make([]net.Conn, 2)\n\tfor i, _ := range stdstream {\n\t\tstdstream[i], err = mux.Open()\n\t\tif err != nil {\n\t\t\tmux.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Create the broker and start it up\n\tbroker := newMuxBroker(mux)\n\tgo broker.Run()\n\n\t// Build the client using our broker and control channel.\n\treturn &RPCClient{\n\t\tbroker:  broker,\n\t\tcontrol: rpc.NewClient(control),\n\t\tplugins: plugins,\n\t\tstdout:  stdstream[0],\n\t\tstderr:  stdstream[1],\n\t}, nil\n}\n\n// SyncStreams should be called to enable syncing of stdout,\n// stderr with the plugin.\n//\n// This will return immediately and the syncing will continue to happen\n// in the background. You do not need to launch this in a goroutine itself.\n//\n// This should never be called multiple times.\nfunc (c *RPCClient) SyncStreams(stdout io.Writer, stderr io.Writer) error {\n\tgo copyStream(\"stdout\", stdout, c.stdout)\n\tgo copyStream(\"stderr\", stderr, c.stderr)\n\treturn nil\n}\n\n// Close closes the connection. The client is no longer usable after this\n// is called.\nfunc (c *RPCClient) Close() error {\n\t// Call the control channel and ask it to gracefully exit. If this\n\t// errors, then we save it so that we always return an error but we\n\t// want to try to close the other channels anyways.\n\tvar empty struct{}\n\treturnErr := c.control.Call(\"Control.Quit\", true, &empty)\n\n\t// Close the other streams we have\n\tif err := c.control.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.stdout.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.stderr.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.broker.Close(); err != nil {\n\t\treturn err\n\t}\n\n\t// Return back the error we got from Control.Quit. This is very important\n\t// since we MUST return non-nil error if this fails so that Client.Kill\n\t// will properly try a process.Kill.\n\treturn returnErr\n}\n\nfunc (c *RPCClient) Dispense(name string) (interface{}, error) {\n\tp, ok := c.plugins[name]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unknown plugin type: %s\", name)\n\t}\n\n\tvar id uint32\n\tif err := c.control.Call(\n\t\t\"Dispenser.Dispense\", name, &id); err != nil {\n\t\treturn nil, err\n\t}\n\n\tconn, err := c.broker.Dial(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p.Client(c.broker, rpc.NewClient(conn))\n}\n\n// Ping pings the connection to ensure it is still alive.\n//\n// The error from the RPC call is returned exactly if you want to inspect\n// it for further error analysis. Any error returned from here would indicate\n// that the connection to the plugin is not healthy.\nfunc (c *RPCClient) Ping() error {\n\tvar empty struct{}\n\treturn c.control.Call(\"Control.Ping\", true, &empty)\n}\n"
        },
        {
          "name": "rpc_client_test.go",
          "type": "blob",
          "size": 2.2578125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\thclog \"github.com/hashicorp/go-hclog\"\n)\n\nfunc TestClient_App(t *testing.T) {\n\tpluginLogger := hclog.New(&hclog.LoggerOptions{\n\t\tLevel:      hclog.Trace,\n\t\tOutput:     os.Stderr,\n\t\tJSONFormat: true,\n\t})\n\n\ttestPlugin := &testInterfaceImpl{\n\t\tlogger: pluginLogger,\n\t}\n\n\tclient, _ := TestPluginRPCConn(t, map[string]Plugin{\n\t\t\"test\": &testInterfacePlugin{Impl: testPlugin},\n\t}, nil)\n\tdefer client.Close()\n\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\timpl, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tresult := impl.Double(21)\n\tif result != 42 {\n\t\tt.Fatalf(\"bad: %#v\", result)\n\t}\n}\n\nfunc TestClient_syncStreams(t *testing.T) {\n\t// Create streams for the server that we can talk to\n\tstdout_r, stdout_w := io.Pipe()\n\tstderr_r, stderr_w := io.Pipe()\n\n\tclient, _ := TestPluginRPCConn(t, map[string]Plugin{}, &TestOptions{\n\t\tServerStdout: stdout_r,\n\t\tServerStderr: stderr_r,\n\t})\n\n\t// Start the data copying\n\tvar stdout_out, stderr_out safeBuffer\n\tstdout := &safeBuffer{\n\t\tb: bytes.NewBufferString(\"stdouttest\"),\n\t}\n\tstderr := &safeBuffer{\n\t\tb: bytes.NewBufferString(\"stderrtest\"),\n\t}\n\tgo client.SyncStreams(&stdout_out, &stderr_out)\n\tgo io.Copy(stdout_w, stdout)\n\tgo io.Copy(stderr_w, stderr)\n\n\t// Unfortunately I can't think of a better way to make sure all the\n\t// copies above go through so let's just exit.\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Close everything, and lets test the result\n\tclient.Close()\n\tstdout_w.Close()\n\tstderr_w.Close()\n\n\tif v := stdout_out.String(); v != \"stdouttest\" {\n\t\tt.Fatalf(\"bad: %q\", v)\n\t}\n\tif v := stderr_out.String(); v != \"stderrtest\" {\n\t\tt.Fatalf(\"bad: %q\", v)\n\t}\n}\n\ntype safeBuffer struct {\n\tsync.Mutex\n\tb *bytes.Buffer\n}\n\nfunc (s *safeBuffer) Write(p []byte) (n int, err error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tif s.b == nil {\n\t\ts.b = new(bytes.Buffer)\n\t}\n\treturn s.b.Write(p)\n}\n\nfunc (s *safeBuffer) Read(p []byte) (n int, err error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tif s.b == nil {\n\t\ts.b = new(bytes.Buffer)\n\t}\n\treturn s.b.Read(p)\n}\n\nfunc (s *safeBuffer) String() string {\n\ts.Lock()\n\tdefer s.Unlock()\n\tif s.b == nil {\n\t\ts.b = new(bytes.Buffer)\n\t}\n\treturn s.b.String()\n}\n"
        },
        {
          "name": "rpc_server.go",
          "type": "blob",
          "size": 4.7763671875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"sync\"\n\n\t\"github.com/hashicorp/yamux\"\n)\n\n// RPCServer listens for network connections and then dispenses interface\n// implementations over net/rpc.\n//\n// After setting the fields below, they shouldn't be read again directly\n// from the structure which may be reading/writing them concurrently.\ntype RPCServer struct {\n\tPlugins map[string]Plugin\n\n\t// Stdout, Stderr are what this server will use instead of the\n\t// normal stdin/out/err. This is because due to the multi-process nature\n\t// of our plugin system, we can't use the normal process values so we\n\t// make our own custom one we pipe across.\n\tStdout io.Reader\n\tStderr io.Reader\n\n\t// DoneCh should be set to a non-nil channel that will be closed\n\t// when the control requests the RPC server to end.\n\tDoneCh chan<- struct{}\n\n\tlock sync.Mutex\n}\n\n// ServerProtocol impl.\nfunc (s *RPCServer) Init() error { return nil }\n\n// ServerProtocol impl.\nfunc (s *RPCServer) Config() string { return \"\" }\n\n// ServerProtocol impl.\nfunc (s *RPCServer) Serve(lis net.Listener) {\n\tdefer s.done()\n\n\tfor {\n\t\tconn, err := lis.Accept()\n\t\tif err != nil {\n\t\t\tseverity := \"ERR\"\n\t\t\tif errors.Is(err, net.ErrClosed) {\n\t\t\t\tseverity = \"DEBUG\"\n\t\t\t}\n\t\t\tlog.Printf(\"[%s] plugin: plugin server: %s\", severity, err)\n\t\t\treturn\n\t\t}\n\n\t\tgo s.ServeConn(conn)\n\t}\n}\n\n// ServeConn runs a single connection.\n//\n// ServeConn blocks, serving the connection until the client hangs up.\nfunc (s *RPCServer) ServeConn(conn io.ReadWriteCloser) {\n\t// First create the yamux server to wrap this connection\n\tmux, err := yamux.Server(conn, nil)\n\tif err != nil {\n\t\tconn.Close()\n\t\tlog.Printf(\"[ERR] plugin: error creating yamux server: %s\", err)\n\t\treturn\n\t}\n\n\t// Accept the control connection\n\tcontrol, err := mux.Accept()\n\tif err != nil {\n\t\tmux.Close()\n\t\tif err != io.EOF {\n\t\t\tlog.Printf(\"[ERR] plugin: error accepting control connection: %s\", err)\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Connect the stdstreams (in, out, err)\n\tstdstream := make([]net.Conn, 2)\n\tfor i := range stdstream {\n\t\tstdstream[i], err = mux.Accept()\n\t\tif err != nil {\n\t\t\tmux.Close()\n\t\t\tlog.Printf(\"[ERR] plugin: accepting stream %d: %s\", i, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Copy std streams out to the proper place\n\tgo copyStream(\"stdout\", stdstream[0], s.Stdout)\n\tgo copyStream(\"stderr\", stdstream[1], s.Stderr)\n\n\t// Create the broker and start it up\n\tbroker := newMuxBroker(mux)\n\tgo broker.Run()\n\n\t// Use the control connection to build the dispenser and serve the\n\t// connection.\n\tserver := rpc.NewServer()\n\tserver.RegisterName(\"Control\", &controlServer{\n\t\tserver: s,\n\t})\n\tserver.RegisterName(\"Dispenser\", &dispenseServer{\n\t\tbroker:  broker,\n\t\tplugins: s.Plugins,\n\t})\n\tserver.ServeConn(control)\n}\n\n// done is called internally by the control server to trigger the\n// doneCh to close which is listened to by the main process to cleanly\n// exit.\nfunc (s *RPCServer) done() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif s.DoneCh != nil {\n\t\tclose(s.DoneCh)\n\t\ts.DoneCh = nil\n\t}\n}\n\n// dispenseServer dispenses variousinterface implementations for Terraform.\ntype controlServer struct {\n\tserver *RPCServer\n}\n\n// Ping can be called to verify the connection (and likely the binary)\n// is still alive to a plugin.\nfunc (c *controlServer) Ping(\n\tnull bool, response *struct{},\n) error {\n\t*response = struct{}{}\n\treturn nil\n}\n\nfunc (c *controlServer) Quit(\n\tnull bool, response *struct{},\n) error {\n\t// End the server\n\tc.server.done()\n\n\t// Always return true\n\t*response = struct{}{}\n\n\treturn nil\n}\n\n// dispenseServer dispenses variousinterface implementations for Terraform.\ntype dispenseServer struct {\n\tbroker  *MuxBroker\n\tplugins map[string]Plugin\n}\n\nfunc (d *dispenseServer) Dispense(\n\tname string, response *uint32,\n) error {\n\t// Find the function to create this implementation\n\tp, ok := d.plugins[name]\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown plugin type: %s\", name)\n\t}\n\n\t// Create the implementation first so we know if there is an error.\n\timpl, err := p.Server(d.broker)\n\tif err != nil {\n\t\t// We turn the error into an errors error so that it works across RPC\n\t\treturn errors.New(err.Error())\n\t}\n\n\t// Reserve an ID for our implementation\n\tid := d.broker.NextId()\n\t*response = id\n\n\t// Run the rest in a goroutine since it can only happen once this RPC\n\t// call returns. We wait for a connection for the plugin implementation\n\t// and serve it.\n\tgo func() {\n\t\tconn, err := d.broker.Accept(id)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[ERR] go-plugin: plugin dispense error: %s: %s\", name, err)\n\t\t\treturn\n\t\t}\n\n\t\tserve(conn, \"Plugin\", impl)\n\t}()\n\n\treturn nil\n}\n\nfunc serve(conn io.ReadWriteCloser, name string, v interface{}) {\n\tserver := rpc.NewServer()\n\tif err := server.RegisterName(name, v); err != nil {\n\t\tlog.Printf(\"[ERR] go-plugin: plugin dispense error: %s\", err)\n\t\treturn\n\t}\n\n\tserver.ServeConn(conn)\n}\n"
        },
        {
          "name": "runner",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 20.3046875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"os/user\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\thclog \"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/grpcmux\"\n\t\"google.golang.org/grpc\"\n)\n\n// CoreProtocolVersion is the ProtocolVersion of the plugin system itself.\n// We will increment this whenever we change any protocol behavior. This\n// will invalidate any prior plugins but will at least allow us to iterate\n// on the core in a safe way. We will do our best to do this very\n// infrequently.\nconst CoreProtocolVersion = 1\n\n// HandshakeConfig is the configuration used by client and servers to\n// handshake before starting a plugin connection. This is embedded by\n// both ServeConfig and ClientConfig.\n//\n// In practice, the plugin host creates a HandshakeConfig that is exported\n// and plugins then can easily consume it.\ntype HandshakeConfig struct {\n\t// ProtocolVersion is the version that clients must match on to\n\t// agree they can communicate. This should match the ProtocolVersion\n\t// set on ClientConfig when using a plugin.\n\t// This field is not required if VersionedPlugins are being used in the\n\t// Client or Server configurations.\n\tProtocolVersion uint\n\n\t// MagicCookieKey and value are used as a very basic verification\n\t// that a plugin is intended to be launched. This is not a security\n\t// measure, just a UX feature. If the magic cookie doesn't match,\n\t// we show human-friendly output.\n\tMagicCookieKey   string\n\tMagicCookieValue string\n}\n\n// PluginSet is a set of plugins provided to be registered in the plugin\n// server.\ntype PluginSet map[string]Plugin\n\n// ServeConfig configures what sorts of plugins are served.\ntype ServeConfig struct {\n\t// HandshakeConfig is the configuration that must match clients.\n\tHandshakeConfig\n\n\t// TLSProvider is a function that returns a configured tls.Config.\n\tTLSProvider func() (*tls.Config, error)\n\n\t// Plugins are the plugins that are served.\n\t// The implied version of this PluginSet is the Handshake.ProtocolVersion.\n\tPlugins PluginSet\n\n\t// VersionedPlugins is a map of PluginSets for specific protocol versions.\n\t// These can be used to negotiate a compatible version between client and\n\t// server. If this is set, Handshake.ProtocolVersion is not required.\n\tVersionedPlugins map[int]PluginSet\n\n\t// GRPCServer should be non-nil to enable serving the plugins over\n\t// gRPC. This is a function to create the server when needed with the\n\t// given server options. The server options populated by go-plugin will\n\t// be for TLS if set. You may modify the input slice.\n\t//\n\t// Note that the grpc.Server will automatically be registered with\n\t// the gRPC health checking service. This is not optional since go-plugin\n\t// relies on this to implement Ping().\n\tGRPCServer func([]grpc.ServerOption) *grpc.Server\n\n\t// Logger is used to pass a logger into the server. If none is provided the\n\t// server will create a default logger.\n\tLogger hclog.Logger\n\n\t// Test, if non-nil, will put plugin serving into \"test mode\". This is\n\t// meant to be used as part of `go test` within a plugin's codebase to\n\t// launch the plugin in-process and output a ReattachConfig.\n\t//\n\t// This changes the behavior of the server in a number of ways to\n\t// accomodate the expectation of running in-process:\n\t//\n\t//   * The handshake cookie is not validated.\n\t//   * Stdout/stderr will receive plugin reads and writes\n\t//   * Connection information will not be sent to stdout\n\t//\n\tTest *ServeTestConfig\n}\n\n// ServeTestConfig configures plugin serving for test mode. See ServeConfig.Test.\ntype ServeTestConfig struct {\n\t// Context, if set, will force the plugin serving to end when cancelled.\n\t// This is only a test configuration because the non-test configuration\n\t// expects to take over the process and therefore end on an interrupt or\n\t// kill signal. For tests, we need to kill the plugin serving routinely\n\t// and this provides a way to do so.\n\t//\n\t// If you want to wait for the plugin process to close before moving on,\n\t// you can wait on CloseCh.\n\tContext context.Context\n\n\t// If this channel is non-nil, we will send the ReattachConfig via\n\t// this channel. This can be encoded (via JSON recommended) to the\n\t// plugin client to attach to this plugin.\n\tReattachConfigCh chan<- *ReattachConfig\n\n\t// CloseCh, if non-nil, will be closed when serving exits. This can be\n\t// used along with Context to determine when the server is fully shut down.\n\t// If this is not set, you can still use Context on its own, but note there\n\t// may be a period of time between canceling the context and the plugin\n\t// server being shut down.\n\tCloseCh chan<- struct{}\n\n\t// SyncStdio, if true, will enable the client side \"SyncStdout/Stderr\"\n\t// functionality to work. This defaults to false because the implementation\n\t// of making this work within test environments is particularly messy\n\t// and SyncStdio functionality is fairly rare, so we default to the simple\n\t// scenario.\n\tSyncStdio bool\n}\n\nfunc unixSocketConfigFromEnv() UnixSocketConfig {\n\treturn UnixSocketConfig{\n\t\tGroup:     os.Getenv(EnvUnixSocketGroup),\n\t\tsocketDir: os.Getenv(EnvUnixSocketDir),\n\t}\n}\n\n// protocolVersion determines the protocol version and plugin set to be used by\n// the server. In the event that there is no suitable version, the last version\n// in the config is returned leaving the client to report the incompatibility.\nfunc protocolVersion(opts *ServeConfig) (int, Protocol, PluginSet) {\n\tprotoVersion := int(opts.ProtocolVersion)\n\tpluginSet := opts.Plugins\n\tprotoType := ProtocolNetRPC\n\t// Check if the client sent a list of acceptable versions\n\tvar clientVersions []int\n\tif vs := os.Getenv(\"PLUGIN_PROTOCOL_VERSIONS\"); vs != \"\" {\n\t\tfor _, s := range strings.Split(vs, \",\") {\n\t\t\tv, err := strconv.Atoi(s)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"server sent invalid plugin version %q\", s)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tclientVersions = append(clientVersions, v)\n\t\t}\n\t}\n\n\t// We want to iterate in reverse order, to ensure we match the newest\n\t// compatible plugin version.\n\tsort.Sort(sort.Reverse(sort.IntSlice(clientVersions)))\n\n\t// set the old un-versioned fields as if they were versioned plugins\n\tif opts.VersionedPlugins == nil {\n\t\topts.VersionedPlugins = make(map[int]PluginSet)\n\t}\n\n\tif pluginSet != nil {\n\t\topts.VersionedPlugins[protoVersion] = pluginSet\n\t}\n\n\t// Sort the version to make sure we match the latest first\n\tvar versions []int\n\tfor v := range opts.VersionedPlugins {\n\t\tversions = append(versions, v)\n\t}\n\n\tsort.Sort(sort.Reverse(sort.IntSlice(versions)))\n\n\t// See if we have multiple versions of Plugins to choose from\n\tfor _, version := range versions {\n\t\t// Record each version, since we guarantee that this returns valid\n\t\t// values even if they are not a protocol match.\n\t\tprotoVersion = version\n\t\tpluginSet = opts.VersionedPlugins[version]\n\n\t\t// If we have a configured gRPC server we should select a protocol\n\t\tif opts.GRPCServer != nil {\n\t\t\t// All plugins in a set must use the same transport, so check the first\n\t\t\t// for the protocol type\n\t\t\tfor _, p := range pluginSet {\n\t\t\t\tswitch p.(type) {\n\t\t\t\tcase GRPCPlugin:\n\t\t\t\t\tprotoType = ProtocolGRPC\n\t\t\t\tdefault:\n\t\t\t\t\tprotoType = ProtocolNetRPC\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tfor _, clientVersion := range clientVersions {\n\t\t\tif clientVersion == protoVersion {\n\t\t\t\treturn protoVersion, protoType, pluginSet\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the lowest version as the fallback.\n\t// Since we iterated over all the versions in reverse order above, these\n\t// values are from the lowest version number plugins (which may be from\n\t// a combination of the Handshake.ProtocolVersion and ServeConfig.Plugins\n\t// fields). This allows serving the oldest version of our plugins to a\n\t// legacy client that did not send a PLUGIN_PROTOCOL_VERSIONS list.\n\treturn protoVersion, protoType, pluginSet\n}\n\n// Serve serves the plugins given by ServeConfig.\n//\n// Serve doesn't return until the plugin is done being executed. Any\n// fixable errors will be output to os.Stderr and the process will\n// exit with a status code of 1. Serve will panic for unexpected\n// conditions where a user's fix is unknown.\n//\n// This is the method that plugins should call in their main() functions.\nfunc Serve(opts *ServeConfig) {\n\texitCode := -1\n\t// We use this to trigger an `os.Exit` so that we can execute our other\n\t// deferred functions. In test mode, we just output the err to stderr\n\t// and return.\n\tdefer func() {\n\t\tif opts.Test == nil && exitCode >= 0 {\n\t\t\tos.Exit(exitCode)\n\t\t}\n\n\t\tif opts.Test != nil && opts.Test.CloseCh != nil {\n\t\t\tclose(opts.Test.CloseCh)\n\t\t}\n\t}()\n\n\tif opts.Test == nil {\n\t\t// Validate the handshake config\n\t\tif opts.MagicCookieKey == \"\" || opts.MagicCookieValue == \"\" {\n\t\t\tfmt.Fprintf(os.Stderr,\n\t\t\t\t\"Misconfigured ServeConfig given to serve this plugin: no magic cookie\\n\"+\n\t\t\t\t\t\"key or value was set. Please notify the plugin author and report\\n\"+\n\t\t\t\t\t\"this as a bug.\\n\")\n\t\t\texitCode = 1\n\t\t\treturn\n\t\t}\n\n\t\t// First check the cookie\n\t\tif os.Getenv(opts.MagicCookieKey) != opts.MagicCookieValue {\n\t\t\tfmt.Fprintf(os.Stderr,\n\t\t\t\t\"This binary is a plugin. These are not meant to be executed directly.\\n\"+\n\t\t\t\t\t\"Please execute the program that consumes these plugins, which will\\n\"+\n\t\t\t\t\t\"load any plugins automatically\\n\")\n\t\t\texitCode = 1\n\t\t\treturn\n\t\t}\n\t}\n\n\t// negotiate the version and plugins\n\t// start with default version in the handshake config\n\tprotoVersion, protoType, pluginSet := protocolVersion(opts)\n\n\tlogger := opts.Logger\n\tif logger == nil {\n\t\t// internal logger to os.Stderr\n\t\tlogger = hclog.New(&hclog.LoggerOptions{\n\t\t\tLevel:      hclog.Trace,\n\t\t\tOutput:     os.Stderr,\n\t\t\tJSONFormat: true,\n\t\t})\n\t}\n\n\t// Register a listener so we can accept a connection\n\tlistener, err := serverListener(unixSocketConfigFromEnv())\n\tif err != nil {\n\t\tlogger.Error(\"plugin init error\", \"error\", err)\n\t\treturn\n\t}\n\n\t// Close the listener on return. We wrap this in a func() on purpose\n\t// because the \"listener\" reference may change to TLS.\n\tdefer func() {\n\t\tlistener.Close()\n\t}()\n\n\tvar tlsConfig *tls.Config\n\tif opts.TLSProvider != nil {\n\t\ttlsConfig, err = opts.TLSProvider()\n\t\tif err != nil {\n\t\t\tlogger.Error(\"plugin tls init\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar serverCert string\n\tclientCert := os.Getenv(\"PLUGIN_CLIENT_CERT\")\n\t// If the client is configured using AutoMTLS, the certificate will be here,\n\t// and we need to generate our own in response.\n\tif tlsConfig == nil && clientCert != \"\" {\n\t\tlogger.Info(\"configuring server automatic mTLS\")\n\t\tclientCertPool := x509.NewCertPool()\n\t\tif !clientCertPool.AppendCertsFromPEM([]byte(clientCert)) {\n\t\t\tlogger.Error(\"client cert provided but failed to parse\", \"cert\", clientCert)\n\t\t}\n\n\t\tcertPEM, keyPEM, err := generateCert()\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to generate server certificate\", \"error\", err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcert, err := tls.X509KeyPair(certPEM, keyPEM)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to parse server certificate\", \"error\", err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\ttlsConfig = &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tClientCAs:    clientCertPool,\n\t\t\tMinVersion:   tls.VersionTLS12,\n\t\t\tRootCAs:      clientCertPool,\n\t\t\tServerName:   \"localhost\",\n\t\t}\n\n\t\t// We send back the raw leaf cert data for the client rather than the\n\t\t// PEM, since the protocol can't handle newlines.\n\t\tserverCert = base64.RawStdEncoding.EncodeToString(cert.Certificate[0])\n\t}\n\n\t// Create the channel to tell us when we're done\n\tdoneCh := make(chan struct{})\n\n\t// Create our new stdout, stderr files. These will override our built-in\n\t// stdout/stderr so that it works across the stream boundary.\n\tvar stdout_r, stderr_r io.Reader\n\tstdout_r, stdout_w, err := os.Pipe()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error preparing plugin: %s\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tstderr_r, stderr_w, err := os.Pipe()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error preparing plugin: %s\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// If we're in test mode, we tee off the reader and write the data\n\t// as-is to our normal Stdout and Stderr so that they continue working\n\t// while stdio works. This is because in test mode, we assume we're running\n\t// in `go test` or some equivalent and we want output to go to standard\n\t// locations.\n\tif opts.Test != nil {\n\t\t// TODO(mitchellh): This isn't super ideal because a TeeReader\n\t\t// only works if the reader side is actively read. If we never\n\t\t// connect via a plugin client, the output still gets swallowed.\n\t\tstdout_r = io.TeeReader(stdout_r, os.Stdout)\n\t\tstderr_r = io.TeeReader(stderr_r, os.Stderr)\n\t}\n\n\t// Build the server type\n\tvar server ServerProtocol\n\tswitch protoType {\n\tcase ProtocolNetRPC:\n\t\t// If we have a TLS configuration then we wrap the listener\n\t\t// ourselves and do it at that level.\n\t\tif tlsConfig != nil {\n\t\t\tlistener = tls.NewListener(listener, tlsConfig)\n\t\t}\n\n\t\t// Create the RPC server to dispense\n\t\tserver = &RPCServer{\n\t\t\tPlugins: pluginSet,\n\t\t\tStdout:  stdout_r,\n\t\t\tStderr:  stderr_r,\n\t\t\tDoneCh:  doneCh,\n\t\t}\n\n\tcase ProtocolGRPC:\n\t\tvar muxer *grpcmux.GRPCServerMuxer\n\t\tif multiplex, _ := strconv.ParseBool(os.Getenv(envMultiplexGRPC)); multiplex {\n\t\t\tmuxer = grpcmux.NewGRPCServerMuxer(logger, listener)\n\t\t\tlistener = muxer\n\t\t}\n\n\t\t// Create the gRPC server\n\t\tserver = &GRPCServer{\n\t\t\tPlugins: pluginSet,\n\t\t\tServer:  opts.GRPCServer,\n\t\t\tTLS:     tlsConfig,\n\t\t\tStdout:  stdout_r,\n\t\t\tStderr:  stderr_r,\n\t\t\tDoneCh:  doneCh,\n\t\t\tlogger:  logger,\n\t\t\tmuxer:   muxer,\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unknown server protocol: \" + protoType)\n\t}\n\n\t// Initialize the servers\n\tif err := server.Init(); err != nil {\n\t\tlogger.Error(\"protocol init\", \"error\", err)\n\t\treturn\n\t}\n\n\tlogger.Debug(\"plugin address\", \"network\", listener.Addr().Network(), \"address\", listener.Addr().String())\n\n\t// Output the address and service name to stdout so that the client can\n\t// bring it up. In test mode, we don't do this because clients will\n\t// attach via a reattach config.\n\tif opts.Test == nil {\n\t\tconst grpcBrokerMultiplexingSupported = true\n\t\tprotocolLine := fmt.Sprintf(\"%d|%d|%s|%s|%s|%s\",\n\t\t\tCoreProtocolVersion,\n\t\t\tprotoVersion,\n\t\t\tlistener.Addr().Network(),\n\t\t\tlistener.Addr().String(),\n\t\t\tprotoType,\n\t\t\tserverCert)\n\n\t\t// Old clients will error with new plugins if we blindly append the\n\t\t// seventh segment for gRPC broker multiplexing support, because old\n\t\t// client code uses strings.SplitN(line, \"|\", 6), which means a seventh\n\t\t// segment will get appended to the sixth segment as \"sixthpart|true\".\n\t\t//\n\t\t// If the environment variable is set, we assume the client is new enough\n\t\t// to handle a seventh segment, as it should now use\n\t\t// strings.Split(line, \"|\") and always handle each segment individually.\n\t\tif os.Getenv(envMultiplexGRPC) != \"\" {\n\t\t\tprotocolLine += fmt.Sprintf(\"|%v\", grpcBrokerMultiplexingSupported)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", protocolLine)\n\t\tos.Stdout.Sync()\n\t} else if ch := opts.Test.ReattachConfigCh; ch != nil {\n\t\t// Send back the reattach config that can be used. This isn't\n\t\t// quite ready if they connect immediately but the client should\n\t\t// retry a few times.\n\t\tch <- &ReattachConfig{\n\t\t\tProtocol:        protoType,\n\t\t\tProtocolVersion: protoVersion,\n\t\t\tAddr:            listener.Addr(),\n\t\t\tPid:             os.Getpid(),\n\t\t\tTest:            true,\n\t\t}\n\t}\n\n\t// Eat the interrupts. In test mode we disable this so that go test\n\t// can be cancelled properly.\n\tif opts.Test == nil {\n\t\tch := make(chan os.Signal, 1)\n\t\tsignal.Notify(ch, os.Interrupt)\n\t\tgo func() {\n\t\t\tcount := 0\n\t\t\tfor {\n\t\t\t\t<-ch\n\t\t\t\tcount++\n\t\t\t\tlogger.Trace(\"plugin received interrupt signal, ignoring\", \"count\", count)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Set our stdout, stderr to the stdio stream that clients can retrieve\n\t// using ClientConfig.SyncStdout/err. We only do this for non-test mode\n\t// or if the test mode explicitly requests it.\n\t//\n\t// In test mode, we use a multiwriter so that the data continues going\n\t// to the normal stdout/stderr so output can show up in test logs. We\n\t// also send to the stdio stream so that clients can continue working\n\t// if they depend on that.\n\tif opts.Test == nil || opts.Test.SyncStdio {\n\t\tif opts.Test != nil {\n\t\t\t// In test mode we need to maintain the original values so we can\n\t\t\t// reset it.\n\t\t\tdefer func(out, err *os.File) {\n\t\t\t\tos.Stdout = out\n\t\t\t\tos.Stderr = err\n\t\t\t}(os.Stdout, os.Stderr)\n\t\t}\n\t\tos.Stdout = stdout_w\n\t\tos.Stderr = stderr_w\n\t}\n\n\t// Accept connections and wait for completion\n\tgo server.Serve(listener)\n\n\tctx := context.Background()\n\tif opts.Test != nil && opts.Test.Context != nil {\n\t\tctx = opts.Test.Context\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\t// Cancellation. We can stop the server by closing the listener.\n\t\t// This isn't graceful at all but this is currently only used by\n\t\t// tests and its our only way to stop.\n\t\tlistener.Close()\n\n\t\t// If this is a grpc server, then we also ask the server itself to\n\t\t// end which will kill all connections. There isn't an easy way to do\n\t\t// this for net/rpc currently but net/rpc is more and more unused.\n\t\tif s, ok := server.(*GRPCServer); ok {\n\t\t\ts.Stop()\n\t\t}\n\n\t\t// Wait for the server itself to shut down\n\t\t<-doneCh\n\n\tcase <-doneCh:\n\t\t// Note that given the documentation of Serve we should probably be\n\t\t// setting exitCode = 0 and using os.Exit here. That's how it used to\n\t\t// work before extracting this library. However, for years we've done\n\t\t// this so we'll keep this functionality.\n\t}\n}\n\nfunc serverListener(unixSocketCfg UnixSocketConfig) (net.Listener, error) {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn serverListener_tcp()\n\t}\n\n\treturn serverListener_unix(unixSocketCfg)\n}\n\nfunc serverListener_tcp() (net.Listener, error) {\n\tenvMinPort := os.Getenv(\"PLUGIN_MIN_PORT\")\n\tenvMaxPort := os.Getenv(\"PLUGIN_MAX_PORT\")\n\n\tvar minPort, maxPort int64\n\tvar err error\n\n\tswitch {\n\tcase len(envMinPort) == 0:\n\t\tminPort = 0\n\tdefault:\n\t\tminPort, err = strconv.ParseInt(envMinPort, 10, 32)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Couldn't get value from PLUGIN_MIN_PORT: %v\", err)\n\t\t}\n\t}\n\n\tswitch {\n\tcase len(envMaxPort) == 0:\n\t\tmaxPort = 0\n\tdefault:\n\t\tmaxPort, err = strconv.ParseInt(envMaxPort, 10, 32)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Couldn't get value from PLUGIN_MAX_PORT: %v\", err)\n\t\t}\n\t}\n\n\tif minPort > maxPort {\n\t\treturn nil, fmt.Errorf(\"PLUGIN_MIN_PORT value of %d is greater than PLUGIN_MAX_PORT value of %d\", minPort, maxPort)\n\t}\n\n\tfor port := minPort; port <= maxPort; port++ {\n\t\taddress := fmt.Sprintf(\"127.0.0.1:%d\", port)\n\t\tlistener, err := net.Listen(\"tcp\", address)\n\t\tif err == nil {\n\t\t\treturn listener, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"Couldn't bind plugin TCP listener\")\n}\n\nfunc serverListener_unix(unixSocketCfg UnixSocketConfig) (net.Listener, error) {\n\ttf, err := os.CreateTemp(unixSocketCfg.socketDir, \"plugin\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpath := tf.Name()\n\n\t// Close the file and remove it because it has to not exist for\n\t// the domain socket.\n\tif err := tf.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := os.Remove(path); err != nil {\n\t\treturn nil, err\n\t}\n\n\tl, err := net.Listen(\"unix\", path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// By default, unix sockets are only writable by the owner. Set up a custom\n\t// group owner and group write permissions if configured.\n\tif unixSocketCfg.Group != \"\" {\n\t\terr = setGroupWritable(path, unixSocketCfg.Group, 0o660)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Wrap the listener in rmListener so that the Unix domain socket file\n\t// is removed on close.\n\treturn newDeleteFileListener(l, path), nil\n}\n\nfunc setGroupWritable(path, groupString string, mode os.FileMode) error {\n\tgroupID, err := strconv.Atoi(groupString)\n\tif err != nil {\n\t\tgroup, err := user.LookupGroup(groupString)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to find gid from %q: %w\", groupString, err)\n\t\t}\n\t\tgroupID, err = strconv.Atoi(group.Gid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse %q group's gid as an integer: %w\", groupString, err)\n\t\t}\n\t}\n\n\terr = os.Chown(path, -1, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.Chmod(path, mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// rmListener is an implementation of net.Listener that forwards most\n// calls to the listener but also calls an additional close function. We\n// use this to cleanup the unix domain socket on close, as well as clean\n// up multiplexed listeners.\ntype rmListener struct {\n\tnet.Listener\n\tclose func() error\n}\n\nfunc newDeleteFileListener(ln net.Listener, path string) *rmListener {\n\treturn &rmListener{\n\t\tListener: ln,\n\t\tclose: func() error {\n\t\t\treturn os.Remove(path)\n\t\t},\n\t}\n}\n\nfunc (l *rmListener) Close() error {\n\t// Close the listener itself\n\tif err := l.Listener.Close(); err != nil {\n\t\treturn err\n\t}\n\n\t// Remove the file\n\treturn l.close()\n}\n"
        },
        {
          "name": "server_mux.go",
          "type": "blob",
          "size": 0.7666015625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// ServeMuxMap is the type that is used to configure ServeMux\ntype ServeMuxMap map[string]*ServeConfig\n\n// ServeMux is like Serve, but serves multiple types of plugins determined\n// by the argument given on the command-line.\n//\n// This command doesn't return until the plugin is done being executed. Any\n// errors are logged or output to stderr.\nfunc ServeMux(m ServeMuxMap) {\n\tif len(os.Args) != 2 {\n\t\tfmt.Fprintf(os.Stderr,\n\t\t\t\"Invoked improperly. This is an internal command that shouldn't\\n\"+\n\t\t\t\t\"be manually invoked.\\n\")\n\t\tos.Exit(1)\n\t}\n\n\topts, ok := m[os.Args[1]]\n\tif !ok {\n\t\tfmt.Fprintf(os.Stderr, \"Unknown plugin: %s\\n\", os.Args[1])\n\t\tos.Exit(1)\n\t}\n\n\tServe(opts)\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 7.8603515625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\thclog \"github.com/hashicorp/go-hclog\"\n)\n\nfunc TestServer_testMode(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tch := make(chan *ReattachConfig, 1)\n\tcloseCh := make(chan struct{})\n\tgo Serve(&ServeConfig{\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testGRPCPluginMap,\n\t\tGRPCServer:      DefaultGRPCServer,\n\t\tTest: &ServeTestConfig{\n\t\t\tContext:          ctx,\n\t\t\tReattachConfigCh: ch,\n\t\t\tCloseCh:          closeCh,\n\t\t},\n\t})\n\n\t// We should get a config\n\tvar config *ReattachConfig\n\tselect {\n\tcase config = <-ch:\n\tcase <-time.After(2000 * time.Millisecond):\n\t\tt.Fatal(\"should've received reattach\")\n\t}\n\tif config == nil {\n\t\tt.Fatal(\"config should not be nil\")\n\t}\n\n\t// Check that the reattach config includes the negotiated protocol version\n\tif config.ProtocolVersion != int(testHandshake.ProtocolVersion) {\n\t\tt.Fatalf(\"wrong protocol version in reattach config. got %d, expected %d\", config.ProtocolVersion, testHandshake.ProtocolVersion)\n\t}\n\n\t// Connect!\n\tc := NewClient(&ClientConfig{\n\t\tCmd:              nil,\n\t\tHandshakeConfig:  testHandshake,\n\t\tPlugins:          testGRPCPluginMap,\n\t\tReattach:         config,\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t})\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Pinging should work\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"should not err: %s\", err)\n\t}\n\n\t// Kill which should do nothing\n\tc.Kill()\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"should not err: %s\", err)\n\t}\n\n\t// Canceling should cause an exit\n\tcancel()\n\t<-closeCh\n\tif err := client.Ping(); err == nil {\n\t\tt.Fatal(\"should error\")\n\t}\n\n\t// Try logging, this should show out in tests. We have to manually verify.\n\tt.Logf(\"HELLO\")\n}\n\nfunc TestServer_testMode_AutoMTLS(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tcloseCh := make(chan struct{})\n\tgo Serve(&ServeConfig{\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tGRPCServer: DefaultGRPCServer,\n\t\tLogger:     hclog.NewNullLogger(),\n\t\tTest: &ServeTestConfig{\n\t\t\tContext:          ctx,\n\t\t\tReattachConfigCh: nil,\n\t\t\tCloseCh:          closeCh,\n\t\t},\n\t})\n\n\t// Connect!\n\tprocess := helperProcess(\"test-mtls\")\n\tc := NewClient(&ClientConfig{\n\t\tCmd:             process,\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tAllowedProtocols: []Protocol{ProtocolGRPC},\n\t\tAutoMTLS:         true,\n\t})\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Pinging should work\n\tif err := client.Ping(); err != nil {\n\t\tt.Fatalf(\"should not err: %s\", err)\n\t}\n\n\t// Grab the impl\n\traw, err := client.Dispense(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"err should be nil, got %s\", err)\n\t}\n\n\ttester, ok := raw.(testInterface)\n\tif !ok {\n\t\tt.Fatalf(\"bad: %#v\", raw)\n\t}\n\n\tn := tester.Double(3)\n\tif n != 6 {\n\t\tt.Fatal(\"invalid response\", n)\n\t}\n\n\t// ensure we can make use of bidirectional communication with AutoMTLS\n\t// enabled\n\terr = tester.Bidirectional()\n\tif err != nil {\n\t\tt.Fatal(\"invalid response\", err)\n\t}\n\n\tc.Kill()\n\t// Canceling should cause an exit\n\tcancel()\n\t<-closeCh\n}\n\nfunc TestServer_RPC(t *testing.T) {\n\tcloseCh := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// make a server, but we don't need to attach to it\n\tch := make(chan *ReattachConfig, 1)\n\tgo Serve(&ServeConfig{\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testPluginMap,\n\t\tTest: &ServeTestConfig{\n\t\t\tContext:          ctx,\n\t\t\tCloseCh:          closeCh,\n\t\t\tReattachConfigCh: ch,\n\t\t},\n\t})\n\n\t// Wait for the server\n\tselect {\n\tcase cfg := <-ch:\n\t\tif cfg == nil {\n\t\t\tt.Fatal(\"attach config should not be nil\")\n\t\t}\n\tcase <-time.After(2000 * time.Millisecond):\n\t\tt.Fatal(\"should've received reattach\")\n\t}\n\n\tcancel()\n\t<-closeCh\n}\n\nfunc TestRmListener_impl(t *testing.T) {\n\tvar _ net.Listener = new(rmListener)\n}\n\nfunc TestRmListener(t *testing.T) {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\ttf, err := os.CreateTemp(\"\", \"plugin\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tpath := tf.Name()\n\n\t// Close the file\n\tif err := tf.Close(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Create the listener and test close\n\trmL := newDeleteFileListener(l, path)\n\tif err := rmL.Close(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// File should be goe\n\tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n}\n\nfunc TestProtocolSelection_no_server(t *testing.T) {\n\tconf := &ServeConfig{\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tGRPCServer:  DefaultGRPCServer,\n\t\tTLSProvider: helperTLSProvider,\n\t}\n\n\t_, protocol, _ := protocolVersion(conf)\n\tif protocol != ProtocolGRPC {\n\t\tt.Fatalf(\"bad protocol %s\", protocol)\n\t}\n\n\tconf = &ServeConfig{\n\t\tHandshakeConfig: testVersionedHandshake,\n\t\tVersionedPlugins: map[int]PluginSet{\n\t\t\t2: testGRPCPluginMap,\n\t\t},\n\t\tTLSProvider: helperTLSProvider,\n\t}\n\n\t_, protocol, _ = protocolVersion(conf)\n\tif protocol != ProtocolNetRPC {\n\t\tt.Fatalf(\"bad protocol %s\", protocol)\n\t}\n}\n\nfunc TestServer_testStdLogger(t *testing.T) {\n\tcloseCh := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tvar logOut bytes.Buffer\n\n\thclogger := hclog.New(&hclog.LoggerOptions{\n\t\tName:       \"test\",\n\t\tLevel:      hclog.Trace,\n\t\tOutput:     &logOut,\n\t\tJSONFormat: true,\n\t})\n\n\t// Wrap the hclog.Logger to use it from the default std library logger\n\t// (and restore the original logger)\n\tdefer func() {\n\t\tlog.SetOutput(os.Stderr)\n\t\tlog.SetFlags(log.LstdFlags)\n\t\tlog.SetPrefix(log.Prefix())\n\t}()\n\tlog.SetOutput(hclogger.StandardWriter(&hclog.StandardLoggerOptions{InferLevels: true}))\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\n\t// make a server, but we don't need to attach to it\n\tch := make(chan *ReattachConfig, 1)\n\tgo Serve(&ServeConfig{\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testGRPCPluginMap,\n\t\tGRPCServer:      DefaultGRPCServer,\n\t\tLogger:          hclog.NewNullLogger(),\n\t\tTest: &ServeTestConfig{\n\t\t\tContext:          ctx,\n\t\t\tCloseCh:          closeCh,\n\t\t\tReattachConfigCh: ch,\n\t\t},\n\t})\n\n\t// Wait for the server\n\tselect {\n\tcase cfg := <-ch:\n\t\tif cfg == nil {\n\t\t\tt.Fatal(\"attach config should not be nil\")\n\t\t}\n\tcase <-time.After(2000 * time.Millisecond):\n\t\tt.Fatal(\"should've received reattach\")\n\t}\n\n\tlog.Println(\"[DEBUG] test log\")\n\t// shut down the server so there's no race on the buffer\n\tcancel()\n\t<-closeCh\n\n\tif !strings.Contains(logOut.String(), \"test log\") {\n\t\tt.Fatalf(\"expected: %q\\ngot: %q\", \"test log\", logOut.String())\n\t}\n}\n\nfunc TestUnixSocketDir(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"go-plugin doesn't support unix sockets on Windows\")\n\t}\n\n\ttmpDir := t.TempDir()\n\tt.Setenv(EnvUnixSocketDir, tmpDir)\n\n\tcloseCh := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// make a server, but we don't need to attach to it\n\tch := make(chan *ReattachConfig, 1)\n\tgo Serve(&ServeConfig{\n\t\tHandshakeConfig: testHandshake,\n\t\tPlugins:         testGRPCPluginMap,\n\t\tGRPCServer:      DefaultGRPCServer,\n\t\tLogger:          hclog.NewNullLogger(),\n\t\tTest: &ServeTestConfig{\n\t\t\tContext:          ctx,\n\t\t\tCloseCh:          closeCh,\n\t\t\tReattachConfigCh: ch,\n\t\t},\n\t})\n\n\t// Wait for the server\n\tvar cfg *ReattachConfig\n\tselect {\n\tcase cfg = <-ch:\n\t\tif cfg == nil {\n\t\t\tt.Fatal(\"attach config should not be nil\")\n\t\t}\n\tcase <-time.After(2000 * time.Millisecond):\n\t\tt.Fatal(\"should've received reattach\")\n\t}\n\n\tactualDir := path.Clean(path.Dir(cfg.Addr.String()))\n\texpectedDir := path.Clean(tmpDir)\n\tif actualDir != expectedDir {\n\t\tt.Fatalf(\"Expected socket in dir: %s, but was in %s\", expectedDir, actualDir)\n\t}\n\n\tcancel()\n\t<-closeCh\n}\n"
        },
        {
          "name": "server_unix_test.go",
          "type": "blob",
          "size": 1.0830078125,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\n//go:build !windows\n// +build !windows\n\npackage plugin\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/user\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nfunc TestUnixSocketGroupPermissions(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"go-plugin doesn't support unix sockets on Windows\")\n\t}\n\n\tgroup, err := user.LookupGroupId(fmt.Sprintf(\"%d\", os.Getgid()))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor name, tc := range map[string]struct {\n\t\tgroup string\n\t}{\n\t\t\"as integer\": {fmt.Sprintf(\"%d\", os.Getgid())},\n\t\t\"as name\":    {group.Name},\n\t} {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tln, err := serverListener_unix(UnixSocketConfig{Group: tc.group})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer ln.Close()\n\n\t\t\tinfo, err := os.Lstat(ln.Addr().String())\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif info.Mode()&os.ModePerm != 0o660 {\n\t\t\t\tt.Fatal(info.Mode())\n\t\t\t}\n\t\t\tstat, ok := info.Sys().(*syscall.Stat_t)\n\t\t\tif !ok {\n\t\t\t\tt.Fatal()\n\t\t\t}\n\t\t\tif stat.Gid != uint32(os.Getgid()) {\n\t\t\t\tt.Fatalf(\"Expected %d, but got %d\", os.Getgid(), stat.Gid)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 0.400390625,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"io\"\n\t\"log\"\n)\n\nfunc copyStream(name string, dst io.Writer, src io.Reader) {\n\tif src == nil {\n\t\tpanic(name + \": src is nil\")\n\t}\n\tif dst == nil {\n\t\tpanic(name + \": dst is nil\")\n\t}\n\tif _, err := io.Copy(dst, src); err != nil && err != io.EOF {\n\t\tlog.Printf(\"[ERR] plugin: stream copy '%s' error: %s\", name, err)\n\t}\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testing.go",
          "type": "blob",
          "size": 4.544921875,
          "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage plugin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"testing\"\n\n\thclog \"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-plugin/internal/grpcmux\"\n\t\"google.golang.org/grpc\"\n)\n\n// TestOptions allows specifying options that can affect the behavior of the\n// test functions\ntype TestOptions struct {\n\t//ServerStdout causes the given value to be used in place of a blank buffer\n\t//for RPCServer's Stdout\n\tServerStdout io.ReadCloser\n\n\t//ServerStderr causes the given value to be used in place of a blank buffer\n\t//for RPCServer's Stderr\n\tServerStderr io.ReadCloser\n}\n\n// The testing file contains test helpers that you can use outside of\n// this package for making it easier to test plugins themselves.\n\n// TestConn is a helper function for returning a client and server\n// net.Conn connected to each other.\nfunc TestConn(t testing.TB) (net.Conn, net.Conn) {\n\t// Listen to any local port. This listener will be closed\n\t// after a single connection is established.\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Start a goroutine to accept our client connection\n\tvar serverConn net.Conn\n\tdoneCh := make(chan struct{})\n\tgo func() {\n\t\tdefer close(doneCh)\n\t\tdefer l.Close()\n\t\tvar err error\n\t\tserverConn, err = l.Accept()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %s\", err)\n\t\t}\n\t}()\n\n\t// Connect to the server\n\tclientConn, err := net.Dial(\"tcp\", l.Addr().String())\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Wait for the server side to acknowledge it has connected\n\t<-doneCh\n\n\treturn clientConn, serverConn\n}\n\n// TestRPCConn returns a rpc client and server connected to each other.\nfunc TestRPCConn(t testing.TB) (*rpc.Client, *rpc.Server) {\n\tclientConn, serverConn := TestConn(t)\n\n\tserver := rpc.NewServer()\n\tgo server.ServeConn(serverConn)\n\n\tclient := rpc.NewClient(clientConn)\n\treturn client, server\n}\n\n// TestPluginRPCConn returns a plugin RPC client and server that are connected\n// together and configured.\nfunc TestPluginRPCConn(t testing.TB, ps map[string]Plugin, opts *TestOptions) (*RPCClient, *RPCServer) {\n\t// Create two net.Conns we can use to shuttle our control connection\n\tclientConn, serverConn := TestConn(t)\n\n\t// Start up the server\n\tserver := &RPCServer{Plugins: ps, Stdout: new(bytes.Buffer), Stderr: new(bytes.Buffer)}\n\tif opts != nil {\n\t\tif opts.ServerStdout != nil {\n\t\t\tserver.Stdout = opts.ServerStdout\n\t\t}\n\t\tif opts.ServerStderr != nil {\n\t\t\tserver.Stderr = opts.ServerStderr\n\t\t}\n\t}\n\tgo server.ServeConn(serverConn)\n\n\t// Connect the client to the server\n\tclient, err := NewRPCClient(clientConn, ps)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\treturn client, server\n}\n\n// TestGRPCConn returns a gRPC client conn and grpc server that are connected\n// together and configured. The register function is used to register services\n// prior to the Serve call. This is used to test gRPC connections.\nfunc TestGRPCConn(t testing.TB, register func(*grpc.Server)) (*grpc.ClientConn, *grpc.Server) {\n\t// Create a listener\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\tregister(server)\n\tgo server.Serve(l)\n\n\t// Connect to the server\n\tconn, err := grpc.Dial(\n\t\tl.Addr().String(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithInsecure())\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\t// Connection successful, close the listener\n\tl.Close()\n\n\treturn conn, server\n}\n\n// TestPluginGRPCConn returns a plugin gRPC client and server that are connected\n// together and configured. This is used to test gRPC connections.\nfunc TestPluginGRPCConn(t testing.TB, multiplex bool, ps map[string]Plugin) (*GRPCClient, *GRPCServer) {\n\t// Create a listener\n\tln, err := serverListener(UnixSocketConfig{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlogger := hclog.New(&hclog.LoggerOptions{\n\t\tLevel: hclog.Debug,\n\t})\n\n\t// Start up the server\n\tvar muxer *grpcmux.GRPCServerMuxer\n\tif multiplex {\n\t\tmuxer = grpcmux.NewGRPCServerMuxer(logger, ln)\n\t\tln = muxer\n\t}\n\tserver := &GRPCServer{\n\t\tPlugins: ps,\n\t\tDoneCh:  make(chan struct{}),\n\t\tServer:  DefaultGRPCServer,\n\t\tStdout:  new(bytes.Buffer),\n\t\tStderr:  new(bytes.Buffer),\n\t\tlogger:  logger,\n\t\tmuxer:   muxer,\n\t}\n\tif err := server.Init(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tgo server.Serve(ln)\n\n\tclient := &Client{\n\t\taddress:  ln.Addr(),\n\t\tprotocol: ProtocolGRPC,\n\t\tconfig: &ClientConfig{\n\t\t\tPlugins:             ps,\n\t\t\tGRPCBrokerMultiplex: multiplex,\n\t\t},\n\t\tlogger: logger,\n\t}\n\n\tgrpcClient, err := newGRPCClient(context.Background(), client)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn grpcClient, server\n}\n"
        }
      ]
    }
  ]
}