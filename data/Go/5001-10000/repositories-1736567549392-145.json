{
  "metadata": {
    "timestamp": 1736567549392,
    "page": 145,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "peco/peco",
      "stars": 7707,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3232421875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n\n/peco\n\nbuild/src\n\nc.out\nout\n\n.build\n\n_internal_bin\nvendor\ngithub_token\n"
        },
        {
          "name": "Changes",
          "type": "blob",
          "size": 18.91015625,
          "content": "Changes\n=======\n\nv0.5.11 - 21 Mar 2023\n  [Features]\n  * Added new option for \"FuzzyLongestSort\" flag that can be specified in your config file\n    as \n    ```\n    {\n      \"FuzzyLongestSort\": true,\n      ...\n    }\n    ```\n    allows you to sort matched lines with the following ordering precedence (#539):\n      1. longer substring\n      2. earlier (left positioned) substring, and\n      3. shorter line.\n\n  [Miscellaneous]\n  * Posted project status at https://github.com/peco/peco/discussions/540\n\nv0.5.10 - 08 Jun 2021\n  * Previous release was botched. No code change except for version string,\n    and Makefile typo.\n\nv0.5.9 - 08 Jun 2021\n  * Remove support for 386 arch\n  * Add go.sum\n  * Add darwin-arm\n  * Fix double cursor issue (#513)\n\nv0.5.8 - 18 Jul 2020\n  Features:\n  * Add support for 256-colors in the configuration. You must first enable\n    this in the config file by specifying \"Use256Colors\": true\n\nv0.5.7 - 10 Jan 2020\n  Bugs/Fixes:\n  * Code introduced in v0.5.5 introduced a bug where if the input is coming\n    from standard input and is possibly infinite, the user would see the\n    query being \"stuck\" after the first character is entered.\n    If peco was applied on a finite set of data, this did not manifest itself.\n    (#494 fixed by #495)\n\nv0.5.6 - 07 Jan 2020\n  Miscellaneous:\n  * I completely messed up the release process. Retagging and uploading\n    binaries properly. No code changes except for the version number (#493)\n\nv0.5.5 - 02 Jan 2020\n  Features:\n  * Properly exit out of pec if --select-1 and --query  are both specified,\n\t  and the query produces exactly one result (#490)\n\nv0.5.4 - 19 Dec 2019\n  Miscellaneous:\n  * Properly set cursor position (#450)\n  * Update termbox-go version (#487/#488)\n  * Update go version to go 1.13\n\nv0.5.3 - 12 Mar 2018\n  Features:\n  * New --print-query option prints out the query upon successful exit\n  * New actions ScrollFirstItem and ScrollLastItem\n  Miscellaneous:\n  * Update termbox-go version (#447)\n  * Documentation fixes (#444)\n  * Build peco using go1.10\n\nv0.5.2 - 08 Dec 2017\n  Backwards Incompatible Change:\n  * --version flag now prints out the Go version used to build the binary\n  Micellaneous:\n  * Various doc fixes\n  * Build peco using go1.9.2.\n  * There have apparently been problems running the stock peco binary in\n    MacOS High Sierra, with an error message like \"failed MSpanList_Insert...\",\n    which can averted by compiling the binary with a newer Go.\n\n    Reports suggest that peco v0.5.1 is not affected by this problem, but\n    we're making this release anyway just to make sure that we're building\n    on a new-ish Go, and that users have a way to see what Go version was\n    used to build their binaries\n\nv0.5.1 - 17 Mar 2017\n  Bugs/Fixes\n  * When --exec is used, and you come back from the external command,\n    you lost your selected location in the peco view. #410\n  Backwards Incompatible Change:\n  * --tty has been removed. it was not being used anyways.\n  Miscellaneous\n  * When scrolling right, you could potentially keep on scrolling\n    infinitely. This has been addressed by #409, #412\n  * External commands specified in --exec now receive\n    PECO_FILENAME, PECO_LINE_COUNT, PECO_QUERY, and\n    PECO_MATCHED_LINE_COUNT as environment variables\n  * Removed unused structs\n  * Fixed glide related Makefile actions\n\nv0.5.0 - 06 Mar 2017\n  Backwards Incompatible Change:\n  * ExecuteCommand has been removed. \n  Features:\n  * A new command line option `--exec` has been added. This allows you to\n    execute external commands via shell, and should be used as replacement\n    to `ExecuteCommand`\n  * A new configuration option `MaxScanBufferSize` has been added. Whereas\n    bufio.Scanner (which peco internally relies on) only accepts lines that\n    are < 64kb when reading the input, specifying this option in the config\n    allows you to change this limit.\n    The default MaxScanBuferSize is 256kb.\n  Bugs/Fixes\n  * When executing external commands, the screen and the capturing of user\n    input would interfere when getting back to peco.\n\nv0.4.9 - 01 Mar 2017\n  Bugs/Fixes\n  * SavedSelection under `--selection-prefix` was not properly working\n    (#388)\n  * An outstanding bug from v0.4.0 where specifying `--query` for a large\n    enough input would lose results in the first query execution has been\n    fixed (#389)\n\nv0.4.8 - 26 Feb 2017\n  Features:\n  * A new command line option `--on-cancel` has been added. This allows you\n    to determine if the user has canceled the query, which can be useful in\n    a pipeline of commands.\n  * `OnCancel` does the equivalent of `--on-cancel` in the config file.\n  * A new command line option `--selection-prefix` has been added. This\n    allows you to use a string prefix instead of highlighting currently\n    selected lines.\n  * `SelectionPrefix` does the equivalent of `--selection-prefix` in the\n    config file.\n  Miscellaneous\n  * Build using go 1.8\n\nv0.4.7 - 17 Dec 2016\n  Bugs/Fixes\n  * A regression of #363 appeared again, because the test was not testing\n    for the correct behavior (#376)\n  Miscellaneous\n  * Internal house cleaning\n\nv0.4.6 - 14 Dec 2016\n  Features:\n  * A new fuzzy filter has now been added. See README for details (#369, #370)\n  Bugs/Fixes\n  * A very subtle timing issue that causes the search to be reset\n    has been resolved (#368)\n\nv0.4.5 - 30 Oct 2016\n  Bugs/Fixes\n  * v0.4.4 broke --select-1 :/ (#363)\n\nv0.4.4 - 23 Oct 2016 \n  Bugs/Fixes\n  * Fix to force a redraw of the screen when the query becomes empty (#346)\n  * Fix blocking when read from an slow input source is interrupted in\n    the middle (#359)\n  * Remove gratuitous use of panic that could happen occasionally when we\n    bail out of setup (like the scenario above)\n\nv0.4.3 - 05 Oct 2016\n  Bugs/Fixes\n  * Fix to apply InitialFilter setting from config file (#343)\n  * Fix --buffer-size option\n  * Fix --prompt option\n  * Fix deadlock when certain actions are combined in the custom\n    action sequence. This bug probably existed for a long time,\n    but probably nobody bothered to report or didn't use the\n    combinations that causes the deadlock (#345)\n  * Force redraw when SelectNone/RefreshScreen is called (#346)\n\nv0.4.2 - 23 Aug 2016\n  Bugs/Fixes\n  * Fix single key jump mode (#331, #332)\n\nv0.4.1 - 21 Aug 2016\n  Bugs/Fixes\n  * Fix a panic that went unnoticed (#328, #329)\n\nv0.4.0 - 19 Aug 2016\n  Miscellaneous:\n  * There is no real user visible change for this release\n  * Build using go 1.7\n  * LOTS of internal cleanup\n    * Eliminated (hopefully) all of potential races\n    * Remove silly embedded structs that existed all over the place\n    * New pipeline mechanism should allow slightly faster filtering\n    * Many fixes to properly release resources acquired by goroutines\n\nv0.3.6 - 11 May 2016\n  Features:\n  * Implement way to execute arbitrary commands via ExecuteCommand config\n  Bugs/Fixes:\n  * Fixed wrong default value for LayoutType\n  * Fixed wrong (actually lack of) extension for Windows binary\n  Miscellaneous:\n  * Changed textual cursor representation\n  * Changed dependency manager to glide\n  * Changed build system to... make. Yes. Make.\n  * Compile with go1.6\n\nv0.3.5 - 30 Oct 2015\n  Features:\n  * Implement --select-1 option (#278)\n  Bugs/Fixes:\n  * Do not switch lines when there's no output (#274)\n  Miscellaneous:\n  * Fix automatic gzip generation (#275)\n\nv0.3.4 - 29 Sep 2015\n  Features:\n  * Implemented SingleKeyJump mode, a.k.a. hit-a-hint\n  Bugs/Fixes:\n  * Fix a problem where lines were sometimes not highlighted\n  * Executing a query may sometimes result in a shorter list of entries\n    such that the page you were at before the query is no longer valid.\n    The cursor would now move to the closest page instead of an empty buffer\n  Miscellaneous:\n  * Only support go1.5 (we now use cross compilation and internal packages)\n  * `go run build/make.go build` will now build all of the peco release files\n\nv0.3.3 - 11 Jul 2015\n  Features:\n  * Implemented ScrollLeft/ScrollRight, to read long lines\n  * Implemented BackToInitialFilter, to make it easier to create combined actions\n    that change the filter type\n  Bugs/Fixes\n  * Build properly on *BSDs\n\nv0.3.2 - 24 Mar 2015\n  Bugs/Fixes\n  * Filtered results could be wrong when QueryExecutionDelay is set to 0 (#241)\n\nv0.3.1 - 24 Mar 2015\n  Bugs/Fixes\n  * Regexp filter was accidentally disabled (#239/#240). Now it's back\n\nv0.3.0 - 20 Mar 2015\n  * BEWARE! 50% of the code has been rewritten!\n  Features\n  * Matchers are now known as Filters\n  * Added StickySelection configuration option\n  * Added QueryExecutionDelay configuration option\n  * Added CustomFilter.BufferThreshold option\n  * For Windows, an extra space at the bottom has been added to facilitate\n    those users using an IM (which consumes an extra line)\n  Deprecations\n  * --no-ignore-case has been completely removed\n  * InitialMatcher configuration option has been deprecated. Use InitialFilter\n  * CustomMatcher configuration option has been deprecated. Use CustomFilter\n  * RotateMatcher action has been deprecated. Use RotateFilter\n  Miscellaneous\n  * To enable trace logs, compile with `-tags debug`, and enable the logs\n    via PECO_TRACE environment variable. e.g. `PECO_TRACE=1 peco ...`\n\nv0.2.12 - 27 Feb 2015\n  Bugs/Fixes\n  * Lines with tabs didn't display properly.\n  * Matches that would fail to hilight certain parts of the text\n    depending on the term order\n  * SelectNext/SelectPrevious actions were reversed (however, these were\n    deprecated anyways)\n  Miscellaneous\n  * You no longer need to tap our custom tap for peco to be installed from\n    homebrew.\n  * Custom matcher processing is fater now\n\nv0.2.11 - 16 Dec 2014\n  Features\n  * Add a InvertSelection action. Not default keymapping has been assigned\n    as of this change, so you need to explicitly set one in your config file.\n  * Display total entries in additin to number of pages\n  * Add experimental ToggleQuery action which enables/disables the current \n    query. \n  Miscellaneous\n  * Massive refactoring to avoid possible race conditions. Note that I am\n    not aware of any breakage caused by previous builds of peco. Even\n    without these changes you most likely did not see a race or it was\n    something you could totally ignore by simply redrawing the page.\n    However, since I was in the mood, and since go is awesome for providing\n    us the `-race` switch, I decided to silence these warnings.\n  * Fix handling of --layout option when no config file is not present.\n\nv0.2.10 - 24 Sep 2014\n  Bugs/Fixes\n  * There was a race condition in the way status messages were cleared,\n    which could leave a message to be not cleared. This has no serious\n    practical impact as it's just the status message, but has been fixed.\n  Miscellaneous\n  * We stopped using godep because it no longer allowed us to use -copy=false.\n    This should have no effect on users.\n  * Update termbox-go dependency\n  * Remove stdout hack\n\nv0.2.9 - 08 Sep 2014\n  Features\n  * Add SmartCase matcher, which automatically toggles between case sensitive\n    and insensitive modes depending on the case of your query.\n  * Ctrl-l is now \"peco.RefreshScreen\", which basically runs the current query\n    again\n  Bugs/Fixes\n  * User prompt is now draw *before* the filtering is executed.\n  * Be more strict about checking invalid matchers.\n  * Add more tests (work in progress...)\n\nv0.2.8 - 01 Sep 2014\n  Bugs/Fixes\n  * Fix in v0.2.7 was apparently not enough. Things should be fixed now.\n  * Long standing bugs against DeleteForwardWord/DeleteBackwardWord have\n    been fixed\n\nv0.2.7 - 01 Sep 2014\n  Bugs/Fixes\n  * A regression introduced in v0.2.6 for DeleteForwardChar/DeleteBackwardChar \n    has been fixed\n  * Some entries in the Keymap section of the README was wrong, and has\n    been fixed\n\nv0.2.6 - 30 Aug 2014\n  Bugs/Fixes\n  * --prompt option was not properly working\n  Miscellaneous\n  * Bunch of internal cleanups to make testing easier\n\nv0.2.5 - 18 Aug 2014\n  Features\n  * Add --layout option, which allows you to switch between `top-down`\n    and `bottom-up` layout mode. This is equivalent of percol's\n    `--prompt-bottom --result-bottom-up`. Default is `top-down`.\n    The same option can be specified in the config file as \"Layout\"\n  Miscellaneous\n  * Because of the layout option, SelectNext/SelectPrevious and\n    SelectNextPage/SelectPreviousPage no longer made sense.\n    Now all of these are DEPRECATED, and are aliases to different\n    action names. See the README for the details.\n    In particular, you would need to configure your key bindings\n    using these if you want to use the `bottom-up` layout\n\nv0.2.4 - 13 Aug 2014\n  Features\n  * Add --initial-matcher command line option to specify which\n    matcher type to use upon start up. --no-ignore-case is deprecated\n  * Add InitialMatcher option to the config file. Matcher option is\n    deprecated.\n  Miscellaneous\n  * Binaries are now built using go1.3.1\n\nv0.2.3 - 28 Jul 2014\n  Bugs/Fixes\n  * Escape sequences are now stripped from input, so for example,\n    colored output can now be fed into peco. Filtering is done against\n    this stripped down buffer, but the original line is used for output.\n  * Some color specification combinations caused weird color variations\n    and in some worst cases caused crashes on Windows.\n\nv0.2.2 - 23 Jul 2014\n  Bugs/Fixes\n  * Fixed display of characters with ambigous width\n  Features\n  * on_bold style attribute has been added.\n\nv0.2.1 - 15 Jul 2014\n  Features\n  * Added the ability to setup custom combined keymap. You can now\n    assign multiple commands to one key sequence.\n  * Key sequence that is being processed currently is displayed in the\n    status message bar\n\nv0.2.0 - 07 Jul 2014\n  Bugs/Fixes\n  * Keymaps have gone through an overhaul. Hopefully it's easier for\n    people who want to modify it to hack on it than before.\n  * Piping multiple commands that use stdin now works properly\n    (v0.1.12 was affected)\n  * After multiple lines are selected, typing Enter (or \"peco.Finish\")\n    prints out only the selected lines, and no longer adds the line where\n    the cursor currently is placed on\n  Features\n  * --initial-index option has been added\n  * --buffer-size option has been added\n  * --prompt option has been added\n  * Background color can now be changed\n  * SelectAll/SelectNone/SelectVisible has bee added\n  * Keymaps can now handle key sequences. For example, \"C-x,C-c\" can now\n    be mapped to \"peco.Cancel\" for Emacs-like behavior\n  * Selection by range is implemented. Now you can start a selection,\n    move the cursor around, and select everything between the starting\n    line and the last line the cursor was on. No default keys are available\n    at this point, so assign peco.ToggleRangeMode to your favorite key\n\nv0.1.12 - 01 Jul 2014\n  Bugs/Fixes\n  * Properly report an error if specified file does not exist\n  Features\n  * Previously peco only read from fixed size input, but now it can\n    read from streaming input such as the result of tail -f <file>.\n    Do note that this buffer does take up memory, so you do not want\n    to be running it for large data.\n\nv0.1.11 - 30 Jun 2014\n  Bugs/Fixes\n  * CustoMatchers are now verified, i.e., exec.LookPath() is applied to\n    the first argument to check if the command is actually executable\n  * Exit code upon receiving signals are now non-zero, as it should have\n    been to start with\n  * Cross-compilation introduced problems with binary builds for darwin.\n    This has now been fixed, but if you do get your hands on peco binaries\n    before v0.1.11, don't expect it to read your config file.\n  * A panic that may occur when you send new queries in very fast succession\n    has been fixed for custom matchers.\n  Features\n  * C-c has been added to the default key binding. It causes peco to cancel\n    the operation (exits with a non-zero status code)\n\nv0.1.10 - 25 Jun 2014\n  Bugs/Fixes\n  * A panic that may occur when you send new queries in very fast succession\n    has been fixed\n  * Fixed the problem where Windows binaries were not able to handle Esc/Alt\n    correctly\n\nv0.1.9 - 25 Jun 2014\n  Bugs/Fixes\n  * Change the base go version to build binary to 1.3\n\nv0.1.8 - 25 Jun 2014\n  Bugs/Fixes\n  * Check for terminal update errors while drawing.\n  Features\n  * Support Alt key prefixes to keybindings (Note: currently does not work\n    on windows)\n\nv0.1.7 - 22 Jun 2014\n  Bugs/Fixes:\n  * Moved repository to a GitHub organization: http://github.com/peco/peco\n  * Because of the above change, a lot of links, imports needed fixing.\n  Features:\n  * Automatically set GOMAXPROCS to NumCPU. If you would like to\n    avoid this behavior, you can explicitly set GOMAXPROC env var to 1\n    (or whatever desired value)\n  Miscellaneous\n  * If you have cool uses for peco, please share them on the wiki:\n    https://github.com/peco/peco/wiki/Sample-Usage\n\nv0.1.6 - 18 Jun 2014\n  Bugs/Fixes:\n  * (You know you will get a bug report only AFTER you release a\n    new version :)\n  * Highlighting wide characters had some issues. This has been\n    there since the first release, apparently\n\nv0.1.5 - 18 Jun 2014\n  Features:\n  * Add experimental --null option\n  \nv0.1.4 - 17 Jun 2014\n  Bugs/Fixes:\n  * Check for ev.Ch and ev.Key (should fix input problems)\n  * Fix crashing issue on empty match\n  Features:\n  * In your config, setting the value to \"-\" will remove the\n    binding.\n  * Default ToggleSelect binding has been changed to\n    ToggleSelectAndSelectNext\n\nv0.1.3 - 17 Jun 2014\n  Bugs/Fixes:\n  * When dealing with fast/successive user input on large buffers,\n    peco was taking too long to execute queries.\n  * XDG style config directories are now searched, and if all fails,\n    falls back to the original ~/.peco/config.json\n  * Some internal cleanup\n  Features:\n  * Multiple line selection has been implemented. Ctrl-Space will\n    toggle the currently selected line, and peco will exit after\n    printing all the selected lines. Note that on OS X, Spotlight\n    by default captures these keys. You may need to reconfigure\n    your settings.\n  * Custom matchers via external processes have been implemented.\n    See the README for more details\n\nv0.1.2 - 16 Jun 2014\n  Bugs/Fixes:\n  * Multiple queries were not being match fully until the end of line\n    (i.e. matches showed up correctly, but the display was not)\n  * Going back to previous item from first item now pages back to last item.\n  * Sending INT/TERM to peco now properly exits.\n  * Some synchronization issues have been fixed (although, it would have\n    never manifested itself when we were running with non-buffered channels)\n  * Make sure default matcher is IgnoreCase\n  Features:\n  * RegExp match mode. e.g. match against \"^root\" or \"2014-[0-9]+\", etc\n  * Default match mode is now configurable.\n  * The entire selected line is now highlighted\n  * Styles (colors and what not) can now be configured.\n  * Add C-d as a default keymap for ForwardDelete\n  * Add EOF handler\n\nv0.1.1 - 12 Jun 2014\n  * Fix handling malformed input (e.g. cp932 or euc-jp)\n  * Make non case sensitive matching the default. C-r allows you to toggle\n    between match algorithms. You can also change the default behavior\n    by passing --no-ignore-case\n  * Fix terminal not being updated upon executing DeleteAll\n  * Fix prompt spacing\n  * Add more default keymappings\n  * Add peco --version\n\nv0.1.0 - 12 Jun 2014\n  * Initial versioned release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 lestrrat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.0859375,
          "content": "INTERNAL_BIN_DIR=_internal_bin\nGOVERSION=$(shell go version)\nTHIS_GOOS=$(word 1,$(subst /, ,$(lastword $(GOVERSION))))\nTHIS_GOARCH=$(word 2,$(subst /, ,$(lastword $(GOVERSION))))\nGOOS=$(THIS_GOOS)\nGOARCH=$(THIS_GOARCH)\nVERSION=$(patsubst \"%\",%,$(lastword $(shell grep 'const version' peco.go)))\nRELEASE_DIR=releases\nARTIFACTS_DIR=$(RELEASE_DIR)/artifacts/$(VERSION)\nSRC_FILES = $(wildcard *.go cmd/peco/*.go internal/*/*.go)\nGITHUB_USERNAME=peco\nBUILD_TARGETS= \\\n\tbuild-linux-arm64 \\\n\tbuild-linux-arm \\\n\tbuild-linux-amd64 \\\n\tbuild-darwin-amd64 \\\n\tbuild-darwin-arm64 \\\n\tbuild-windows-amd64\nRELEASE_TARGETS=\\\n\trelease-linux-arm64 \\\n\trelease-linux-arm \\\n\trelease-linux-amd64 \\\n\trelease-darwin-amd64 \\\n\trelease-darwin-arm64 \\\n\trelease-windows-amd64\n\n.PHONY: clean build $(RELEASE_TARGETS) $(BUILD_TARGETS) $(RELEASE_DIR)/$(GOOS)/$(GOARCH)/peco$(SUFFIX)\n\nbuild: $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/peco$(SUFFIX)\n\n$(INTERNAL_BIN_DIR):\n\t@echo \"Creating $(INTERNAL_BIN_DIR)\"\n\t@mkdir -p $(INTERNAL_BIN_DIR)\n\ndeps: \n\t@echo \"Downloading dependencies...\"\n\t@GO111MODULE=on go mod download\n\nbuild-windows-amd64:\n\t@$(MAKE) build GOOS=windows GOARCH=amd64 SUFFIX=.exe\n\nbuild-windows-386:\n\t@$(MAKE) build GOOS=windows GOARCH=386 SUFFIX=.exe\n\nbuild-linux-amd64:\n\t@$(MAKE) build GOOS=linux GOARCH=amd64\n\nbuild-linux-arm:\n\t@$(MAKE) build GOOS=linux GOARCH=arm\n\nbuild-linux-arm64:\n\t@$(MAKE) build GOOS=linux GOARCH=arm64\n\nbuild-linux-386:\n\t@$(MAKE) build GOOS=linux GOARCH=386\n\nbuild-darwin-amd64:\n\t@$(MAKE) build GOOS=darwin GOARCH=amd64\n\nbuild-darwin-arm64:\n\t@$(MAKE) build GOOS=darwin GOARCH=arm64\n\n$(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/peco$(SUFFIX): deps\n\t@GO111MODULE=on go build -o $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/peco$(SUFFIX) cmd/peco/peco.go\n\nall: $(BUILD_TARGETS)\n\nrelease: $(RELEASE_TARGETS)\n\n$(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/Changes:\n\t@cp Changes $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)\n\n$(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/README.md:\n\t@cp README.md $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)\n\nrelease-changes: $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/Changes\nrelease-readme: $(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/README.md\n\nrelease-windows-amd64: build-windows-amd64\n\t@$(MAKE) release-changes release-readme release-zip GOOS=windows GOARCH=amd64\n\nrelease-windows-386: build-windows-386\n\t@$(MAKE) release-changes release-readme release-zip GOOS=windows GOARCH=386\n\nrelease-linux-amd64: build-linux-amd64\n\t@$(MAKE) release-changes release-readme release-targz GOOS=linux GOARCH=amd64\n\nrelease-linux-arm: build-linux-arm\n\t@$(MAKE) release-changes release-readme release-targz GOOS=linux GOARCH=arm\n\nrelease-linux-arm64: build-linux-arm64\n\t@$(MAKE) release-changes release-readme release-targz GOOS=linux GOARCH=arm64\n\nrelease-linux-386: build-linux-386\n\t@$(MAKE) release-changes release-readme release-targz GOOS=linux GOARCH=386\n\nrelease-darwin-amd64: build-darwin-amd64\n\t@$(MAKE) release-changes release-readme release-zip GOOS=darwin GOARCH=amd64\n\nrelease-darwin-arm64: build-darwin-arm64\n\t@$(MAKE) release-changes release-readme release-zip GOOS=darwin GOARCH=arm64\n\n$(ARTIFACTS_DIR):\n\t@mkdir -p $(ARTIFACTS_DIR)\n\n# note: I dreamt of using tar.bz2 for my releases, but then historically\n# (for whatever reason that is unknown to me now) I was creating .zip for\n# darwin/windows, and .tar.gz for linux, so I guess we'll stick with those.\n# (I think this is from goxc days)\nrelease-tarbz: $(ARTIFACTS_DIR)\n\ttar -cjf $(ARTIFACTS_DIR)/peco_$(GOOS)_$(GOARCH).tar.bz2 -C $(RELEASE_DIR) peco_$(GOOS)_$(GOARCH)\n\nrelease-targz: $(ARTIFACTS_DIR)\n\ttar -czf $(ARTIFACTS_DIR)/peco_$(GOOS)_$(GOARCH).tar.gz -C $(RELEASE_DIR) peco_$(GOOS)_$(GOARCH)\n\nrelease-zip: $(ARTIFACTS_DIR)\n\tcd $(RELEASE_DIR) && zip -9 $(CURDIR)/$(ARTIFACTS_DIR)/peco_$(GOOS)_$(GOARCH).zip peco_$(GOOS)_$(GOARCH)/*\n\nrelease-github-token: github_token\n\t@echo \"file `github_token` is required\"\n\nrelease-upload: release release-github-token\n\tghr -u $(GITHUB_USERNAME) -t $(shell cat github_token) --draft --replace $(VERSION) $(ARTIFACTS_DIR)\n\ntest: deps\n\t@echo \"Running tests...\"\n\t@GO111MODULE=on PATH=$(INTERNAL_BIN_DIR)/$(GOOS)/$(GOARCH):$(PATH) go test -v ./...\n\nclean:\n\t-rm -rf $(RELEASE_DIR)/*/*\n\t-rm -rf $(ARTIFACTS_DIR)/*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.5458984375,
          "content": "# peco\n\nSimplistic interactive filtering tool\n\n*NOTE*: If you are viewing this on GitHub, this document refers to the state of `peco` in whatever current branch you are viewing, _not_ necessarily the state of a currently released version. Please make sure to checkout the [Changes](./Changes) file for features and changes.\n\nThis README is long and comprehensive. Use the [Table of Contents](#table-of-contents) to navigate to the section that interests you. It has been placed at the bottom of the README file because of its length.\n\n> If you use peco, please consider sponsoring the authors of this project from the \"Sponsor\" button on the project page at https://github.com/peco/peco. Sponsorship plans start at $1 :)\n\n# Description\n\n`peco` (pronounced *peh-koh*) is based on a python tool, [percol](https://github.com/mooz/percol). `percol` was darn useful, but I wanted a tool that was a single binary, and forget about python. `peco` is written in Go, and therefore you can just grab [the binary releases](https://github.com/peco/peco/releases) and drop it in your $PATH.\n\n`peco` can be a great tool to filter stuff like logs, process stats, find files, because unlike grep, you can type as you think and look through the current results.\n\nFor basic usage, continue down below. For more cool elaborate usage samples, [please see the wiki](https://github.com/peco/peco/wiki/Sample-Usage), and if you have any other tricks you want to share, please add to it!\n\n## Demo\n\nDemos speak more than a thousand words! Here's me looking for a process on my mac. As you can see, you can page through your results, and you can keep changing the query:\n\n![Executed `ps -ef | peco`, then the query `root` was typed. This shows all lines containing the word root](http://peco.github.io/images/peco-demo-ps.gif)\n\nHere's me trying to figure out which file to open:\n\n![Executed `find . -name '*.go' | peco` (within camlistore repository), then the query `camget` was typed. This shows all lines including the word `camget`](http://peco.github.io/images/peco-demo-filename.gif)\n\nWhen you combine tools like zsh, peco, and [ghq](https://github.com/motemen/ghq), you can make managing/moving around your huge dev area a piece of cake! (this example doesn't use zsh functions so you can see what I'm doing)\n\n![Executed `cd $(ghq list --full-path | peco --query peco)` to show all repositories containing the word `peco`, then to change directories into the one selected](http://peco.github.io/images/peco-demo-ghq.gif)\n\n\n# Features\n\n## Incremental Search\n\nSearch results are filtered as you type. This is great to drill down to the\nline you are looking for\n\nMultiple terms turn the query into an \"AND\" query:\n\n![Executed `ps aux | peco`, then the query `root app` was typed. This shows all lines containing both `root` and `app`](http://peco.github.io/images/peco-demo-multiple-queries.gif)\n\nWhen you find that line that you want, press enter, and the resulting line\nis printed to stdout, which allows you to pipe it to other tools\n\n## Select Multiple Lines\n\nYou can select multiple lines! (this example uses C-Space)\n\n![Executed `ls -l | peco`, then used peco.ToggleSelection to select multiple lines](http://peco.github.io/images/peco-demo-multiple-selection.gif)\n\n## Select Range Of Lines\n\nNot only can you select multiple lines one by one, you can select a range of lines (Note: The ToggleRangeMode action is not enabled by default. You need to put a custom key binding in your config file)\n\n![Executed `ps -ef | peco`, then used peco.ToggleRangeMode to select a range of lines](http://peco.github.io/images/peco-demo-range-mode.gif)\n\n## Select Filters\n\nDifferent types of filters are available. Default is case-insensitive filter, so lines with any case will match. You can toggle between IgnoreCase, CaseSensitive, SmartCase, Regexp and Fuzzy filters.\n\nThe SmartCase filter uses case-*insensitive* matching when all of the queries are lower case, and case-*sensitive* matching otherwise.\n\nThe Regexp filter allows you to use any valid regular expression to match lines.\n\nThe Fuzzy filter allows you to find matches using partial patterns. For example, when searching for `ALongString`, you can enable the Fuzzy filter and search `ALS` to find it. The Fuzzy filter uses smart case search like the SmartCase filter. With the `FuzzyLongestSort` flag enabled in the configuration file, it does a smarter match. It sorts the matched lines by the following precedence: 1. longer substring, 2. earlier (left positioned) substring, and 3. shorter line.\n\n![Executed `ps aux | peco`, then typed `google`, which matches the Chrome.app under IgnoreCase filter type. When you change it to Regexp filter, this is no longer the case. But you can type `(?i)google` instead to toggle case-insensitive mode](http://peco.github.io/images/peco-demo-matcher.gif)\n\n## Selectable Layout\n\nAs of v0.2.5, if you would rather not move your eyes off of the bottom of the screen, you can change the screen layout by either providing the `--layout=bottom-up` command line option, or set the `Layout` variable in your configuration file\n\n![Executed `ps -ef | peco --layout=bottom-up` to toggle inverted layout mode](http://peco.github.io/images/peco-demo-layout-bottom-up.gif)\n\n## Works on Windows!\n\nI have been told that peco even works on windows :) Look ma! I'm not lying!\n\n![Showing peco running on Windows cmd.exe](https://gist.githubusercontent.com/taichi/26814518d8b00352693b/raw/b7745987de32dbf068e81a8308c0c5ed38138649/peco.gif)\n\n# Installation\n\n### Just want the binary?\n\nGo to the [releases page](https://github.com/peco/peco/releases), find the version you want, and download the zip file. Unpack the zip file, and put the binary to somewhere you want (on UNIX-y systems, /usr/local/bin or the like). Make sure it has execution bits turned on. Yes, it is a single binary! You can put it anywhere you want :)\n\n_THIS IS THE RECOMMENDED WAY_ (except for macOS homebrew users)\n\n### macOS (Homebrew, Scarf)\n\nIf you're on macOS and want to use homebrew:\n\n```\nbrew install peco\n```\n\nor with Scarf:\n\n```\nscarf install peco\n```\n\n### Debian and Ubuntu based distributions (APT, Scarf)\n\nThere is an official Debian package that can be installed via APT:\n\n```\napt install peco\n```\n\nor with Scarf:\n\n```\nscarf install peco\n```\n\n### Void Linux (XBPS)\n\n```\nxbps-install -S peco\n```\n\n### Arch Linux\n\nThere is an official Arch Linux package that can be installed via `pacman`:\n\n```\npacman -Syu peco\n```\n\n### Windows (Chocolatey NuGet Users)\n\nThere's a third-party [peco package available](https://chocolatey.org/packages/peco) for Chocolatey NuGet.\n\n```\nC:\\> choco install peco\n```\n\n### Building peco yourself\n\nMake sure to clone the source code under $GOPATH (i.e. $GOPATH/src/github.com/peco/peco). This is required\nas the main binary refers to an internal package, which requires that the source code be located in\nthe correct package location.\n\nNavigate to the directory above, then run:\n\n```\nmake build\n```\n\nThis will do the following:\n\n1. Run `go build` to create `releases/$VERSION_NUMBER/peco`\n\nYou can copy the binary to somewhere in your $PATH, and it should just work.\n\nThe above installs the correct versions of peco's dependencies. Then build it:\n\n```\ngo build cmd/peco/peco.go\n```\n\nThis compiles a peco binary in the root of the cloned peco repository. Copy this file to an appropriate location.\n\n### go get IS NOT RECOMMENDED\n\nPlease DO NOT use `go get` to install this tool. It bypasses the developers' intention of controlling the dependency versioning.\n\n# Command Line Options\n\n### -h, --help\n\nDisplay a help message\n\n### --version\n\nDisplay the version of peco\n\n### --query <query>\n\nSpecifies the default query to be used upon startup. This is useful for scripts and functions where you can figure out beforehand what the most likely query string is.\n\n### --print-query\n\nWhen exiting, prints out the query typed by the user as the first line of output. The query will be printed even if there are no matches, if the program is terminated normally (i.e. enter key). On the other hand, the query will NOT be printed if the user exits via a cancel (i.e. esc key).\n\n### --rcfile <filename>\n\nPass peco a configuration file, which currently must be a JSON file. If unspecified it will try a series of files by default. See `Configuration File` for the actual locations searched.\n\n### -b, --buffer-size <num>\n\nLimits the buffer size to `num`. This is an important feature when you are using peco against a possibly infinite stream, as it limits the number of lines that peco holds at any given time, preventing it from exhausting all the memory. By default the buffer size is unlimited.\n\n### --null\n\nWARNING: EXPERIMENTAL. This feature will probably stay, but the option name may change in the future.\n\nChanges how peco interprets incoming data. When this flag is set, you may insert NUL ('\\0') characters in your input. Anything before the NUL character is treated as the string to be displayed by peco and is used for matching against user query. Anything after the NUL character is used as the \"result\": i.e., when peco is about to exit, it displays this string instead of the original string displayed.\n\n[Here's a simple example of how to use this feature](https://gist.github.com/mattn/3c7a14c1677ecb193acd)\n\n### --initial-index\n\nSpecifies the initial line position upon start up. E.g. If you want to start out with the second line selected, set it to \"1\" (because the index is 0 based).\n\n### --initial-filter `IgnoreCase|CaseSensitive|SmartCase|Regexp|Fuzzy`\n\nSpecifies the initial filter to use upon start up. You should specify the name of the filter like `IgnoreCase`, `CaseSensitive`, `SmartCase`, `Regexp` and `Fuzzy`. Default is `IgnoreCase`.\n\n### --prompt\n\nSpecifies the query line's prompt string. When specified, takes precedence over the configuration file's `Prompt` section. The default value is `QUERY>`.\n\n### --layout `top-down|bottom-up`\n\nSpecifies the display layout. Default is `top-down`, where query prompt is at the top, followed by the list, then the system status message line. `bottom-up` changes this to the list first (displayed in reverse order), the query prompt, and then the system status message line.\n\nFor `percol` users, `--layout=bottom-up` is almost equivalent of `--prompt-bottom --result-bottom-up`.\n\n### --select-1\n\nWhen specified *and* the input contains exactly 1 line, peco skips prompting you for a choice, and selects the only line in the input and immediately exits.\n\nIf there are multiple lines in the input, the usual selection view is displayed.\n\n### --on-cancel `success|error`\n\nSpecifies the exit status to use when the user cancels the query execution.\nFor historical and back-compatibility reasons, the default is `success`, meaning if the user cancels the query, the exit status is 0. When you choose `error`, peco will exit with a non-zero value.\n\n### --selection-prefix `string`\n\nWhen specified, peco uses the specified prefix instead of changing line color to indicate currently selected line(s). default is to use colors. This option is experimental.\n\n### --exec `string`\n\nWhen specified, peco executes the specified external command (via shell), with peco's currently selected line(s) as its input from STDIN.\n\nUpon exiting from the external command, the control goes back to peco where you can keep browsing your search buffer, and to possibly execute your external command repeatedly afterwards.\n\nTo exit out of peco when running in this mode, you must execute the Cancel command, usually the escape key.\n\n# Configuration File\n\npeco by default consults a few locations for the config files.\n\n1. Location specified in --rcfile. If this doesn't exist, peco complains and exits\n2. $XDG\\_CONFIG\\_HOME/peco/config.json\n3. $HOME/.config/peco/config.json\n4. for each directory listed in $XDG\\_CONFIG\\_DIRS, $DIR/peco/config.json\n5. If all else fails, $HOME/.peco/config.json\n\nBelow are configuration sections that you may specify in your config file:\n\n* [Global](#global)\n* [Keymaps](#keymaps)\n* [Styles](#styles)\n* [CustomFilter](#customfilter)\n* [Prompt](#prompt)\n* [InitialMatcher](#initialmatcher)\n* [Use256Color](#use256color)\n\n## Global\n\nGlobal configurations that change the global behavior.\n\n### Prompt\n\nYou can change the query line's prompt, which is `QUERY>` by default.\n\n```json\n{\n    \"Prompt\": \"[peco]\"\n}\n```\n\n### InitialMatcher\n\n*InitialMatcher* has been deprecated. Please use `InitialFilter` instead.\n\n### InitialFilter\n\nSpecifies the filter name to start peco with. You should specify the name of the filter, such as `IgnoreCase`, `CaseSensitive`, `SmartCase`, `Regexp` and `Fuzzy`.\n\n### FuzzyLongestSort\n\nEnables the longest substring match and sorts the output. It affects only the Fuzzy filter.\n\nDefault value for FuzzyLongestSort is false.\n\n### StickySelection\n\n```json\n{\n    \"StickySelection\": true\n}\n```\n\nStickySelection allows selections to persist even between changes to the query.\nFor example, when you set this to true you can select a few lines, type in a\nnew query, select those lines, and then delete the query. The result is all\nthe lines that you selected before and after the modification to the query are\nleft intact.\n\nDefault value for StickySelection is false.\n\n### OnCancel\n\n```json\n{\n    \"OnCancel\": \"error\"\n}\n```\n\nOnCancel is equivalent to `--on-cancel` command line option.\n\n### MaxScanBufferSize\n\n```json\n{\n    \"MaxScanBufferSize\": 256\n}\n```\n\nControls the buffer sized (in kilobytes) used by `bufio.Scanner`, which is\nresponsible for reading the input lines. If you believe that your input has\nvery long lines that prohibit peco from reading them, try increasing this number.\n\nThe same time, the default MaxScanBuferSize is 256kb.\n\n## Keymaps\n\nExample:\n\n```json\n{\n    \"Keymap\": {\n        \"M-v\": \"peco.ScrollPageUp\",\n        \"C-v\": \"peco.ScrollPageDown\",\n        \"C-x,C-c\": \"peco.Cancel\"\n    }\n}\n```\n\n### Key sequences\n\nAs of v0.2.0, you can use a list of keys (separated by comma) to register an action that is associated with a key sequence (instead of a single key). Please note that if there is a conflict in the key map, *the longest sequence always wins*. So In the above example, if you add another sequence, say, `C-x,C-c,C-c`, then the above `peco.Cancel` will never be invoked.\n\n### Combined actions\n\nAs of v0.2.1, you can create custom combined actions. For example, if you find yourself repeatedly needing to select 4 lines out of the list, you may want to define your own action like this:\n\n```json\n{\n    \"Action\": {\n        \"foo.SelectFour\": [\n            \"peco.ToggleRangeMode\",\n            \"peco.SelectDown\",\n            \"peco.SelectDown\",\n            \"peco.SelectDown\",\n            \"peco.ToggleRangeMode\"\n        ]\n    },\n    \"Keymap\": {\n        \"M-f\": \"foo.SelectFour\"\n    }\n}\n```\n\nThis creates a new combined action `foo.SelectFour` (the format of the name is totally arbitrary, I just like to put namespaces), and assigns that action to `M-f`. When it's fired, it toggles the range selection mode and highlights 4 lines, and then goes back to waiting for your input.\n\nAs a similar example, a common idiom in emacs is that `C-c C-c` means \"take the contents of this buffer and accept it\", whatever that means.  This adds exactly that keybinding:\n\n```json\n{\n    \"Action\": {\n        \"selectAllAndFinish\": [\n            \"peco.SelectAll\",\n            \"peco.Finish\"\n        ]\n    },\n    \"Keymap\": {\n        \"C-c,C-c\": \"selectAllAndFinish\"\n    }\n}\n```\n\n### Available keys\n\nSince v0.1.8, in addition to values below, you may put a `M-` prefix on any\nkey item to use Alt/Option key as a mask.\n\n| Name        | Notes |\n|-------------|-------|\n| C-a ... C-z | Control + whatever character |\n| C-2 ... C-8 | Control + 2..8 |\n| C-[         ||\n| C-]         ||\n| C-~         ||\n| C-\\_        ||\n| C-\\\\\\\\      | Note that you need to escape the backslash |\n| C-/         ||\n| C-Space     ||\n| F1 ... F12  ||\n| Esc         ||\n| Tab         ||\n| Enter       ||\n| Insert      ||\n| Delete      ||\n| BS          ||\n| BS2         ||\n| Home        ||\n| End         ||\n| Pgup        ||\n| Pgdn        ||\n| ArrowUp     ||\n| ArrowDown   ||\n| ArrowLeft   ||\n| ArrowRight  ||\n| MouseLeft   ||\n| MouseMiddle ||\n| MouseRight  ||\n\n\n### Key workarounds\n\nSome keys just... don't map correctly / too easily for various reasons. Here, we'll list possible workarounds for key sequences that are often asked for:\n\n\n| You want this | Use this instead | Notes             |\n|---------------|------------------|-------------------|\n| Shift+Tab     | M-\\[,Z           | Verified on macOS |\n\n### Available actions\n\n| Name | Notes |\n|------|-------|\n| peco.ForwardChar        | Move caret forward 1 character |\n| peco.BackwardChar       | Move caret backward 1 character |\n| peco.ForwardWord        | Move caret forward 1 word |\n| peco.BackwardWord       | Move caret backward 1 word|\n| peco.BackToInitialFilter| Switch to first filter in the list |\n| peco.BeginningOfLine    | Move caret to the beginning of line |\n| peco.EndOfLine          | Move caret to the end of line |\n| peco.EndOfFile          | Delete one character forward, otherwise exit from peco with failure status |\n| peco.DeleteForwardChar  | Delete one character forward |\n| peco.DeleteBackwardChar | Delete one character backward |\n| peco.DeleteForwardWord  | Delete one word forward |\n| peco.DeleteBackwardWord | Delete one word backward |\n| peco.InvertSelection    | Inverts the selected lines |\n| peco.KillBeginningOfLine | Delete the characters under the cursor backward until the beginning of the line |\n| peco.KillEndOfLine      | Delete the characters under the cursor until the end of the line |\n| peco.DeleteAll          | Delete all entered characters |\n| peco.RefreshScreen      | Redraws the screen. Note that this effectively re-runs your query |\n| peco.SelectPreviousPage | (DEPRECATED) Alias to ScrollPageUp |\n| peco.SelectNextPage     | (DEPRECATED) Alias to ScrollPageDown |\n| peco.ScrollPageDown     | Moves the selected line cursor for an entire page, downwards |\n| peco.ScrollPageUp       | Moves the selected line cursor for an entire page, upwards |\n| peco.SelectUp           | Moves the selected line cursor to one line above |\n| peco.SelectDown         | Moves the selected line cursor to one line below |\n| peco.SelectPrevious     | (DEPRECATED) Alias to SelectUp |\n| peco.SelectNext         | (DEPRECATED) Alias to SelectDown |\n| peco.ScrollLeft         | Scrolls the screen to the left |\n| peco.ScrollRight        | Scrolls the screen to the right |\n| peco.ScrollFirstItem    | Scrolls to the first item (in the entire buffer, not the current screen) |\n| peco.ScrollLastItem     | Scrolls to the last item (in the entire buffer, not the current screen) |\n| peco.ToggleSelection    | Selects the current line, and saves it |\n| peco.ToggleSelectionAndSelectNext | Selects the current line, saves it, and proceeds to the next line |\n| peco.ToggleSingleKeyJump | Enables SingleKeyJump mode a.k.a. \"hit-a-hint\" |\n| peco.SelectNone         | Remove all saved selections |\n| peco.SelectAll          | Selects the all line, and save it  |\n| peco.SelectVisible      | Selects the all visible line, and save it |\n| peco.ToggleSelectMode   | (DEPRECATED) Alias to ToggleRangeMode |\n| peco.CancelSelectMode   | (DEPRECATED) Alias to CancelRangeMode |\n| peco.ToggleQuery        | Toggle list between filtered by query and not filtered. |\n| peco.ToggleRangeMode   | Start selecting by range, or append selecting range to selections |\n| peco.CancelRangeMode   | Finish selecting by range and cancel range selection |\n| peco.RotateMatcher     | (DEPRECATED) Use peco.RotateFilter |\n| peco.RotateFilter       | Rotate between filters (by default, ignore-case/no-ignore-case)|\n| peco.Finish             | Exits from peco with success status |\n| peco.Cancel             | Exits from peco with failure status, or cancel select mode |\n\n\n### Default Keymap\n\nNote: If in case below keymap seems wrong, check the source code in [keymap.go](https://github.com/peco/peco/blob/master/keymap.go) (look for NewKeymap).\n\n|Key|Action|\n|---|------|\n|Esc|peco.Cancel|\n|C-c|peco.Cancel|\n|Enter|peco.Finish|\n|C-f|peco.ForwardChar|\n|C-a|peco.BeginningOfLine|\n|C-b|peco.BackwardChar|\n|C-d|peco.DeleteForwardChar|\n|C-e|peco.EndOfLine|\n|C-k|peco.KillEndOfLine|\n|C-u|peco.KillBeginningOfLine|\n|BS|peco.DeleteBackwardChar|\n|C-8|peco.DeleteBackwardChar|\n|C-w|peco.DeleteBackwardWord|\n|C-g|peco.SelectNone|\n|C-n|peco.SelectDown|\n|C-p|peco.SelectUp|\n|C-r|peco.RotateFilter|\n|C-t|peco.ToggleQuery|\n|C-Space|peco.ToggleSelectionAndSelectNext|\n|ArrowUp|peco.SelectUp|\n|ArrowDown|peco.SelectDown|\n|ArrowLeft|peco.ScrollPageUp|\n|ArrowRight|peco.ScrollPageDown|\n\n## Styles\n\nFor now, styles of following 5 items can be customized in `config.json`.\n\n```json\n{\n    \"Style\": {\n        \"Basic\": [\"on_default\", \"default\"],\n        \"SavedSelection\": [\"bold\", \"on_yellow\", \"white\"],\n        \"Selected\": [\"underline\", \"on_cyan\", \"black\"],\n        \"Query\": [\"yellow\", \"bold\"],\n        \"Matched\": [\"red\", \"on_blue\"]\n    }\n}\n```\n\n- `Basic` for not selected lines\n- `SavedSelection` for lines of saved selection\n- `Selected` for a currently selecting line\n- `Query` for a query line\n- `Matched` for a query matched word\n\n### Foreground Colors\n\n- `\"black\"` for `termbox.ColorBlack`\n- `\"red\"` for `termbox.ColorRed`\n- `\"green\"` for `termbox.ColorGreen`\n- `\"yellow\"` for `termbox.ColorYellow`\n- `\"blue\"` for `termbox.ColorBlue`\n- `\"magenta\"` for `termbox.ColorMagenta`\n- `\"cyan\"` for `termbox.ColorCyan`\n- `\"white\"` for `termbox.ColorWhite`\n- `\"0\"`-`\"255\"` for 256color ([Use256Color](#use256color) must be enabled)\n\n### Background Colors\n\n- `\"on_black\"` for `termbox.ColorBlack`\n- `\"on_red\"` for `termbox.ColorRed`\n- `\"on_green\"` for `termbox.ColorGreen`\n- `\"on_yellow\"` for `termbox.ColorYellow`\n- `\"on_blue\"` for `termbox.ColorBlue`\n- `\"on_magenta\"` for `termbox.ColorMagenta`\n- `\"on_cyan\"` for `termbox.ColorCyan`\n- `\"on_white\"` for `termbox.ColorWhite`\n- `\"on_0\"`-`\"on_255\"` for 256color ([Use256Color](#use256color) must be enabled)\n\n### Attributes\n\n- `\"bold\"` for fg: `termbox.AttrBold`\n- `\"underline\"` for fg: `termbox.AttrUnderline`\n- `\"reverse\"` for fg: `termbox.AttrReverse`\n- `\"on_bold\"` for bg: `termbox.AttrBold` (this attribute actually makes the background blink on some platforms/environments, e.g. linux console, xterm...)\n\n## CustomFilter\n\nThis is an experimental feature. Please note that some details of this specification may change\n\nBy default `peco` comes with `IgnoreCase`, `CaseSensitive`, `SmartCase`, `Regexp` and `Fuzzy` filters, but since v0.1.3, it is possible to create your own custom filter.\n\nThe filter will be executed via  `Command.Run()` as an external process, and it will be passed the query values in the command line, and the original unaltered buffer is passed via `os.Stdin`. Your filter must perform the matching, and print out to `os.Stdout` matched lines. Your filter MAY be called multiple times if the buffer\ngiven to peco is big enough. See `BufferThreshold` below.\n\nNote that currently there is no way for the custom filter to specify where in the line the match occurred, so matched portions in the string WILL NOT BE HIGHLIGHTED.\n\nThe filter does not need to be a go program. It can be a perl/ruby/python/bash script, or anything else that is executable.\n\nOnce you have a filter, you must specify how the matcher is spawned:\n\n```json\n{\n    \"CustomFilter\": {\n        \"MyFilter\": {\n            \"Cmd\": \"/path/to/my-matcher\",\n            \"Args\": [ \"$QUERY\" ],\n            \"BufferThreshold\": 100\n        }\n    }\n}\n```\n\n`Cmd` specifies the command name. This must be searchable via `exec.LookPath`.\n\nElements in the `Args` section are string keys to array of program arguments. The special token `$QUERY` will be replaced with the unaltered query as the user typed in (i.e. multiple-word queries will be passed as a single string). You may pass in any other arguments in this array. If you omit this in your config, a default value of `[]string{\"$QUERY\"}` will be used\n\n`BufferThreshold` specifies that the filter command should be invoked when peco has this many lines to process\nin the buffer. For example, if you are using peco against a 1000-line input, and your `BufferThreshold` is 100 (which is the default), then your filter will be invoked 10 times. For obvious reasons, the larger this threshold is, the faster the overall performance will be, but the longer you will have to wait to see the filter results.\n\nYou may specify as many filters as you like in the `CustomFilter` section.\n\n### Examples\n\n* [An example of a simple perl regexp matcher](https://gist.github.com/mattn/24712964da6e3112251c)\n* [An example using migemogrep Japanese grep using latin-1 chars](https://github.com/peco/peco/wiki/CustomFilter)\n\n## Layout\n\nSee --layout.\n\n## SingleKeyJump\n\n```\n{\n  \"SingleKeyJump\": {\n    \"ShowPrefix\": true\n  }\n}\n```\n\n## SelectionPrefix\n\n`SelectionPrefix` is equivalent to using `--selection-prefix` in the command line.\n\n```\n{\n  \"SelectionPrefix\": \">\"\n}\n```\n\n## Use256Color\n\nBoolean value that determines whether or not to use 256color. The default is `false`.\n\nNote: This has no effect on Windows because Windows console does not support extra color modes.\n\n```json\n{\n    \"Use256Color\": true\n}\n```\n\n# FAQ\n\n## Does peco work on (msys2|cygwin)?\n\nNo. https://github.com/peco/peco/issues/336#issuecomment-243939696\n(Updated Feb 23, 2017: \"Maybe\" on cygwin https://github.com/peco/peco/issues/336#issuecomment-281912949)\n\n## Non-latin fonts (e.g. Japanese) look weird on my Windows machine...?\n\nAre you using raster fonts? https://github.com/peco/peco/issues/341\n\n## Seeing escape sequences `[200~` and `[201~` when pasting text?\n\nDisable bracketed paste mode. https://github.com/peco/peco/issues/417\n\n# Hacking\n\nFirst, fork this repo, and get your clone locally.\n\n1. Make sure you have [go](http://golang.org) installed, with GOPATH appropriately set\n2. Make sure you have `make` installed\n3. Run `make installdeps` (You only need to do this once)\n\nTo test, run\n\n```\nmake test\n```\n\nTo build, run\n\n```\nmake build\n```\n\nThis will create a `peco` binary in `$(RELEASE_DIR)/peco_$(GOOS)_$(GOARCH)/peco$(SUFFIX)`. Or, of course, you can just run\n\n```\ngo build cmd/peco/peco.go\n```\n\nwhich will create the binary in the local directory.\n\n# TODO\n\nUnit test it.\n\n# AUTHORS\n\n* Daisuke Maki (lestrrat)\n* mattn\n* syohex\n\n# CONTRIBUTORS\n\n* HIROSE Masaaki\n* Joel Segerlind\n* Lukas Lueg\n* Mitsuoka Mimura\n* Ryota Arai\n* Shinya Ohyanagi\n* Takashi Kokubun\n* Yuya Takeyama\n* cho45\n* cubicdaiya\n* kei\\_q\n* negipo\n* sona\\_tar\n* sugyan\n* swdyh\n* MURAOKA Taro (kaoriya/koron), for aho-corasick search\n* taichi, for the gif working on Windows\n* uobikiemukot\n* Samuel Lemaitre\n* Yousuke Ushiki\n* Linda\\_pp\n* Tomohiro Nishimura (Sixeight)\n* Naruki Tanabe (narugit)\n\n# Notes\n\nObviously, kudos to the original percol: https://github.com/mooz/percol\nMuch code stolen from https://github.com/mattn/gof\n\n# Table of Contents\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [peco](#peco)\n- [Description](#description)\n  - [Demo](#demo)\n- [Features](#features)\n  - [Incremental Search](#incremental-search)\n  - [Select Multiple Lines](#select-multiple-lines)\n  - [Select Range Of Lines](#select-range-of-lines)\n  - [Select Filters](#select-filters)\n  - [Selectable Layout](#selectable-layout)\n  - [Works on Windows!](#works-on-windows)\n- [Installation](#installation)\n    - [Just want the binary?](#just-want-the-binary)\n    - [macOS (Homebrew, Scarf)](#macos-homebrew-scarf)\n    - [Debian and Ubuntu based distributions (APT, Scarf)](#debian-and-ubuntu-based-distributions-apt-scarf)\n    - [Void Linux (XBPS)](#void-linux-xbps)\n    - [Arch Linux](#arch-linux)\n    - [Windows (Chocolatey NuGet Users)](#windows-chocolatey-nuget-users)\n    - [Building peco yourself](#building-peco-yourself)\n    - [go get IS NOT RECOMMENDED](#go-get-is-not-recommended)\n- [Command Line Options](#command-line-options)\n    - [-h, --help](#-h---help)\n    - [--version](#--version)\n    - [--query <query>](#--query-query)\n    - [--print-query](#--print-query)\n    - [--rcfile <filename>](#--rcfile-filename)\n    - [-b, --buffer-size <num>](#-b---buffer-size-num)\n    - [--null](#--null)\n    - [--initial-index](#--initial-index)\n    - [--initial-filter `IgnoreCase|CaseSensitive|SmartCase|Regexp|Fuzzy`](#--initial-filter-ignorecasecasesensitivesmartcaseregexpfuzzy)\n    - [--prompt](#--prompt)\n    - [--layout `top-down|bottom-up`](#--layout-top-downbottom-up)\n    - [--select-1](#--select-1)\n    - [--on-cancel `success|error`](#--on-cancel-successerror)\n    - [--selection-prefix `string`](#--selection-prefix-string)\n    - [--exec `string`](#--exec-string)\n- [Configuration File](#configuration-file)\n  - [Global](#global)\n    - [Prompt](#prompt)\n    - [InitialMatcher](#initialmatcher)\n    - [InitialFilter](#initialfilter)\n    - [FuzzyLongestSort](#fuzzylongestsort)\n    - [StickySelection](#stickyselection)\n    - [OnCancel](#oncancel)\n    - [MaxScanBufferSize](#maxscanbuffersize)\n  - [Keymaps](#keymaps)\n    - [Key sequences](#key-sequences)\n    - [Combined actions](#combined-actions)\n    - [Available keys](#available-keys)\n    - [Key workarounds](#key-workarounds)\n    - [Available actions](#available-actions)\n    - [Default Keymap](#default-keymap)\n  - [Styles](#styles)\n    - [Foreground Colors](#foreground-colors)\n    - [Background Colors](#background-colors)\n    - [Attributes](#attributes)\n  - [CustomFilter](#customfilter)\n    - [Examples](#examples)\n  - [Layout](#layout)\n  - [SingleKeyJump](#singlekeyjump)\n  - [SelectionPrefix](#selectionprefix)\n  - [Use256Color](#use256color)\n- [FAQ](#faq)\n  - [Does peco work on (msys2|cygwin)?](#does-peco-work-on-msys2cygwin)\n  - [Non-latin fonts (e.g. Japanese) look weird on my Windows machine...?](#non-latin-fonts-eg-japanese-look-weird-on-my-windows-machine)\n  - [Seeing escape sequences `[200~` and `[201~` when pasting text?](#seeing-escape-sequences-200-and-201-when-pasting-text)\n- [Hacking](#hacking)\n- [TODO](#todo)\n- [AUTHORS](#authors)\n- [CONTRIBUTORS](#contributors)\n- [Notes](#notes)\n- [Table of Contents](#table-of-contents)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n"
        },
        {
          "name": "action.go",
          "type": "blob",
          "size": 22.9033203125,
          "content": "package peco\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"unicode\"\n\n\t\"context\"\n\n\t\"github.com/google/btree\"\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/internal/keyseq\"\n\t\"github.com/peco/peco/internal/util\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/pkg/errors\"\n)\n\n// This is the global map of canonical action name to actions\nvar nameToActions map[string]Action\n\n// This is the default keybinding used by NewKeymap()\nvar defaultKeyBinding map[string]Action\n\n// Execute fulfills the Action interface for AfterFunc\nfunc (a ActionFunc) Execute(ctx context.Context, state *Peco, e termbox.Event) {\n\ta(ctx, state, e)\n}\n\nfunc (a ActionFunc) registerKeySequence(k keyseq.KeyList) {\n\tdefaultKeyBinding[k.String()] = a\n}\n\n// Register fulfills the Action interface for AfterFunc. Registers `a`\n// into the global action registry by the name `name`, and maps to\n// default keys via `defaultKeys`\nfunc (a ActionFunc) Register(name string, defaultKeys ...termbox.Key) {\n\tnameToActions[\"peco.\"+name] = a\n\tfor _, k := range defaultKeys {\n\t\ta.registerKeySequence(keyseq.KeyList{keyseq.NewKeyFromKey(k)})\n\t}\n}\n\n// RegisterKeySequence satisfies the Action interface for AfterFunc.\n// Registers the action to be mapped against a key sequence\nfunc (a ActionFunc) RegisterKeySequence(name string, k keyseq.KeyList) {\n\tnameToActions[\"peco.\"+name] = a\n\ta.registerKeySequence(k)\n}\n\nfunc wrapDeprecated(fn func(context.Context, *Peco, termbox.Event), oldName, newName string) ActionFunc {\n\treturn ActionFunc(func(ctx context.Context, state *Peco, e termbox.Event) {\n\t\tstate.Hub().SendStatusMsg(ctx, fmt.Sprintf(\"%s is deprecated. Use %s\", oldName, newName))\n\t\tfn(ctx, state, e)\n\t})\n}\n\nfunc init() {\n\t// Build the global maps\n\tnameToActions = map[string]Action{}\n\tdefaultKeyBinding = map[string]Action{}\n\n\tActionFunc(doInvertSelection).Register(\"InvertSelection\")\n\tActionFunc(doBeginningOfLine).Register(\"BeginningOfLine\", termbox.KeyCtrlA)\n\tActionFunc(doBackwardChar).Register(\"BackwardChar\", termbox.KeyCtrlB)\n\tActionFunc(doBackwardWord).Register(\"BackwardWord\")\n\tActionFunc(doCancel).Register(\"Cancel\", termbox.KeyCtrlC, termbox.KeyEsc)\n\tActionFunc(doDeleteAll).Register(\"DeleteAll\")\n\tActionFunc(doDeleteBackwardChar).Register(\n\t\t\"DeleteBackwardChar\",\n\t\ttermbox.KeyBackspace,\n\t\ttermbox.KeyBackspace2,\n\t)\n\tActionFunc(doDeleteBackwardWord).Register(\n\t\t\"DeleteBackwardWord\",\n\t\ttermbox.KeyCtrlW,\n\t)\n\tActionFunc(doDeleteForwardChar).Register(\"DeleteForwardChar\", termbox.KeyCtrlD)\n\tActionFunc(doDeleteForwardWord).Register(\"DeleteForwardWord\")\n\tActionFunc(doEndOfFile).Register(\"EndOfFile\")\n\tActionFunc(doEndOfLine).Register(\"EndOfLine\", termbox.KeyCtrlE)\n\tActionFunc(doFinish).Register(\"Finish\", termbox.KeyEnter)\n\tActionFunc(doForwardChar).Register(\"ForwardChar\", termbox.KeyCtrlF)\n\tActionFunc(doForwardWord).Register(\"ForwardWord\")\n\tActionFunc(doKillEndOfLine).Register(\"KillEndOfLine\", termbox.KeyCtrlK)\n\tActionFunc(doKillBeginningOfLine).Register(\"KillBeginningOfLine\", termbox.KeyCtrlU)\n\tActionFunc(doRotateFilter).Register(\"RotateFilter\", termbox.KeyCtrlR)\n\twrapDeprecated(doRotateFilter, \"RotateMatcher\", \"RotateFilter\").Register(\"RotateMatcher\")\n\tActionFunc(doBackToInitialFilter).Register(\"BackToInitialFilter\")\n\n\tActionFunc(doSelectUp).Register(\"SelectUp\", termbox.KeyArrowUp, termbox.KeyCtrlP)\n\twrapDeprecated(doSelectDown, \"SelectNext\", \"SelectUp/SelectDown\").Register(\"SelectNext\")\n\n\tActionFunc(doScrollPageDown).Register(\"ScrollPageDown\", termbox.KeyArrowRight)\n\twrapDeprecated(doScrollPageDown, \"SelectNextPage\", \"ScrollPageDown/ScrollPageUp\").Register(\"SelectNextPage\")\n\n\tActionFunc(doSelectDown).Register(\"SelectDown\", termbox.KeyArrowDown, termbox.KeyCtrlN)\n\twrapDeprecated(doSelectUp, \"SelectPrevious\", \"SelectUp/SelectDown\").Register(\"SelectPrevious\")\n\n\tActionFunc(doScrollPageUp).Register(\"ScrollPageUp\", termbox.KeyArrowLeft)\n\twrapDeprecated(doScrollPageUp, \"SelectPreviousPage\", \"ScrollPageDown/ScrollPageUp\").Register(\"SelectPreviousPage\")\n\n\tActionFunc(doScrollLeft).Register(\"ScrollLeft\")\n\tActionFunc(doScrollRight).Register(\"ScrollRight\")\n\n\tActionFunc(doScrollFirstItem).Register(\"ScrollFirstItem\", termbox.KeyHome)\n\tActionFunc(doScrollLastItem).Register(\"ScrollLastItem\", termbox.KeyEnd)\n\n\tActionFunc(doToggleSelection).Register(\"ToggleSelection\")\n\tActionFunc(doToggleSelectionAndSelectNext).Register(\n\t\t\"ToggleSelectionAndSelectNext\",\n\t\ttermbox.KeyCtrlSpace,\n\t)\n\tActionFunc(doSelectNone).Register(\n\t\t\"SelectNone\",\n\t\ttermbox.KeyCtrlG,\n\t)\n\tActionFunc(doSelectAll).Register(\"SelectAll\")\n\tActionFunc(doSelectVisible).Register(\"SelectVisible\")\n\twrapDeprecated(doToggleRangeMode, \"ToggleSelectMode\", \"ToggleRangeMode\").Register(\"ToggleSelectMode\")\n\twrapDeprecated(doCancelRangeMode, \"CancelSelectMode\", \"CancelRangeMode\").Register(\"CancelSelectMode\")\n\tActionFunc(doToggleRangeMode).Register(\"ToggleRangeMode\")\n\tActionFunc(doCancelRangeMode).Register(\"CancelRangeMode\")\n\tActionFunc(doToggleQuery).Register(\"ToggleQuery\", termbox.KeyCtrlT)\n\tActionFunc(doRefreshScreen).Register(\"RefreshScreen\", termbox.KeyCtrlL)\n\tActionFunc(doToggleSingleKeyJump).Register(\"ToggleSingleKeyJump\")\n\n\tActionFunc(doToggleViewArround).Register(\"ViewArround\", termbox.KeyCtrlV)\n\n\tActionFunc(doGoToNextSelection).Register(\"GoToNextSelection\", termbox.KeyCtrlK)\n\tActionFunc(doGoToPreviousSelection).Register(\"\tdoGoToPreviousSelection\", termbox.KeyCtrlJ)\n\n\tActionFunc(doKonamiCommand).RegisterKeySequence(\n\t\t\"KonamiCommand\",\n\t\tkeyseq.KeyList{\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyCtrlX, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowUp, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowUp, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowDown, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowDown, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowLeft, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowRight, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowLeft, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: termbox.KeyArrowRight, Ch: 0},\n\t\t\tkeyseq.Key{Modifier: 0, Key: 0, Ch: 'b'},\n\t\t\tkeyseq.Key{Modifier: 0, Key: 0, Ch: 'a'},\n\t\t},\n\t)\n}\n\n// This is a noop action\nfunc doNothing(_ context.Context, _ *Peco, _ termbox.Event) {}\n\n// This is an exception to the rule. This does not get registered\n// anywhere. You just call it directly\nfunc doAcceptChar(ctx context.Context, state *Peco, e termbox.Event) {\n\tif e.Key == termbox.KeySpace {\n\t\te.Ch = ' '\n\t}\n\n\tch := e.Ch\n\tif ch <= 0 {\n\t\treturn\n\t}\n\n\tif state.SingleKeyJumpMode() {\n\t\tdoSingleKeyJump(ctx, state, e)\n\t\treturn\n\t}\n\n\tq := state.Query()\n\tc := state.Caret()\n\n\tq.InsertAt(ch, c.Pos())\n\tc.Move(1)\n\n\th := state.Hub()\n\th.SendDrawPrompt(ctx) // Update prompt before running query\n\n\tstate.ExecQuery(nil)\n}\n\nfunc doRotateFilter(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doRotateFilter\")\n\t\tdefer g.End()\n\t}\n\n\tfilters := state.Filters()\n\tfilters.Rotate()\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doBackToInitialFilter(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doBackToInitialFilter\")\n\t\tdefer g.End()\n\t}\n\n\tfilters := state.Filters()\n\tfilters.Reset()\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doToggleSelection(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doToggleSelection\")\n\t\tdefer g.End()\n\t}\n\n\tl, err := state.CurrentLineBuffer().LineAt(state.Location().LineNumber())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tselection := state.Selection()\n\tif selection.Has(l) {\n\t\tselection.Remove(l)\n\t\treturn\n\t}\n\tselection.Add(l)\n}\n\nfunc doToggleRangeMode(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doToggleRangeMode\")\n\t\tdefer g.End()\n\t}\n\n\tr := state.SelectionRangeStart()\n\tif r.Valid() {\n\t\tr.Reset()\n\t} else {\n\t\tcl := state.Location().LineNumber()\n\t\tr.SetValue(cl)\n\t\tif l, err := state.CurrentLineBuffer().LineAt(cl); err == nil {\n\t\t\tstate.selection.Add(l)\n\t\t}\n\t}\n}\n\nfunc doCancelRangeMode(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.SelectionRangeStart().Reset()\n}\n\nfunc doSelectNone(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.Selection().Reset()\n\tstate.Hub().SendDraw(ctx, &DrawOptions{DisableCache: true})\n}\n\nfunc doSelectAll(ctx context.Context, state *Peco, _ termbox.Event) {\n\tselection := state.Selection()\n\tb := state.CurrentLineBuffer()\n\tfor x := 0; x < b.Size(); x++ {\n\t\tif l, err := b.LineAt(x); err == nil {\n\t\t\tl.SetDirty(true)\n\t\t\tselection.Add(l)\n\t\t} else {\n\t\t\tselection.Remove(l)\n\t\t}\n\t}\n\tstate.Hub().SendDraw(ctx, nil)\n}\n\nfunc doSelectVisible(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doSelectVisible\")\n\t\tdefer g.End()\n\t}\n\n\tb := state.CurrentLineBuffer()\n\tselection := state.Selection()\n\tloc := state.Location()\n\tpc := loc.PageCrop()\n\tlb := pc.Crop(b)\n\tfor x := 0; x < lb.Size(); x++ {\n\t\tl, err := lb.LineAt(x)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tl.SetDirty(true)\n\t\tselection.Add(l)\n\t}\n\tstate.Hub().SendDraw(ctx, nil)\n}\n\ntype errCollectResults struct{}\n\nfunc (err errCollectResults) Error() string {\n\treturn \"collect results\"\n}\nfunc (err errCollectResults) CollectResults() bool {\n\treturn true\n}\nfunc doFinish(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doFinish\")\n\t\tdefer g.End()\n\t}\n\n\tccarg := state.execOnFinish\n\tif len(ccarg) == 0 {\n\t\tstate.Exit(errCollectResults{})\n\t\treturn\n\t}\n\n\tsel := NewSelection()\n\tstate.Selection().Copy(sel)\n\tif sel.Len() == 0 {\n\t\tif l, err := state.CurrentLineBuffer().LineAt(state.Location().LineNumber()); err == nil {\n\t\t\tsel.Add(l)\n\t\t}\n\t}\n\n\tvar stdin bytes.Buffer\n\tsel.Ascend(func(it btree.Item) bool {\n\t\tline := it.(line.Line)\n\t\tstdin.WriteString(line.Buffer())\n\t\tstdin.WriteRune('\\n')\n\t\treturn true\n\t})\n\n\tvar err error\n\tstate.Hub().SendStatusMsg(ctx, \"Executing \" + ccarg)\n\tcmd := util.Shell(ccarg)\n\tcmd.Stdin = &stdin\n\tcmd.Stdout = state.Stdout\n\tcmd.Stderr = state.Stderr\n\t// Setup some environment variables. Start with a copy of the current\n\t// environment...\n\tenv := os.Environ()\n\n\t// Add some PECO specific ones...\n\t// PECO_QUERY: current query value\n\t// PECO_FILENAME: input file name, if any. \"-\" for stdin\n\t// PECO_LINE_COUNT: number of lines in the original input\n\t// PECO_MATCHED_LINE_COUNT: number of lines matched (number of lines being\n\t//     sent to stdin of the command being executed)\n\n\tif s, ok := state.Source().(*Source); ok {\n\t\tenv = append(env,\n\t\t\t`PECO_FILENAME=`+s.Name(),\n\t\t\t`PECO_LINE_COUNT=`+strconv.Itoa(s.Size()),\n\t\t)\n\t}\n\n\tenv = append(env,\n\t\t`PECO_QUERY=`+state.Query().String(),\n\t\t`PECO_MATCHED_LINE_COUNT=`+strconv.Itoa(sel.Len()),\n\t)\n\tcmd.Env = env\n\n\tstate.screen.Suspend()\n\n\terr = cmd.Run()\n\tstate.screen.Resume()\n\tstate.Hub().SendDraw(ctx, &DrawOptions{DisableCache: true})\n\tif err != nil {\n\t\t// bail out, or otherwise the user cannot know what happened\n\t\tstate.Exit(errors.Wrap(err, `failed to execute command`))\n\t}\n}\n\nfunc doCancel(ctx context.Context, state *Peco, e termbox.Event) {\n\tkm := state.Keymap()\n\n\tif seq := km.Sequence(); seq.InMiddleOfChain() {\n\t\tseq.CancelChain()\n\t\treturn\n\t}\n\n\tif state.SelectionRangeStart().Valid() {\n\t\tdoCancelRangeMode(ctx, state, e)\n\t\treturn\n\t}\n\n\t// peco.Cancel -> end program, exit with failure\n\terr := makeIgnorable(errors.New(\"user canceled\"))\n\tif state.onCancel == errorKey {\n\t\terr = setExitStatus(err, 1)\n\t}\n\tstate.Exit(err)\n}\n\nfunc doSelectDown(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doSelectDown\")\n\t\tdefer g.End()\n\t}\n\tstate.Hub().SendPaging(ctx, ToLineBelow)\n}\n\nfunc doSelectUp(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doSelectUp\")\n\t\tdefer g.End()\n\t}\n\tstate.Hub().SendPaging(ctx, ToLineAbove)\n}\n\nfunc doScrollPageUp(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollPageUp)\n}\n\nfunc doScrollPageDown(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollPageDown)\n}\n\nfunc doScrollLeft(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollLeft)\n}\n\nfunc doScrollRight(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollRight)\n}\n\nfunc doScrollFirstItem(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollFirstItem)\n}\n\nfunc doScrollLastItem(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendPaging(ctx, ToScrollLastItem)\n}\n\nfunc doToggleSelectionAndSelectNext(ctx context.Context, state *Peco, e termbox.Event) {\n\ttoplevel, _ := ctx.Value(isTopLevelActionCall).(bool)\n\tstate.Hub().Batch(ctx, func(ctx context.Context) {\n\t\tctx = context.WithValue(ctx, isTopLevelActionCall, false)\n\t\tdoToggleSelection(ctx, state, e)\n\t\t// XXX This is sucky. Fix later\n\t\tif state.LayoutType() == \"top-down\" {\n\t\t\tdoSelectDown(ctx, state, e)\n\t\t} else {\n\t\t\tdoSelectUp(ctx, state, e)\n\t\t}\n\t}, toplevel)\n}\n\nfunc doInvertSelection(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doInvertSelection\")\n\t\tdefer g.End()\n\t}\n\n\tselection := state.Selection()\n\tb := state.CurrentLineBuffer()\n\n\tfor x := 0; x < b.Size(); x++ {\n\t\tif l, err := b.LineAt(x); err == nil {\n\t\t\tl.SetDirty(true)\n\t\t\tif selection.Has(l) {\n\t\t\t\tselection.Remove(l)\n\t\t\t} else {\n\t\t\t\tselection.Add(l)\n\t\t\t}\n\t\t} else {\n\t\t\tselection.Remove(l)\n\t\t}\n\t}\n\n\tstate.Hub().SendDraw(ctx, nil)\n}\n\nfunc doDeleteBackwardWord(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doDeleteBackwardWord\")\n\t\tdefer g.End()\n\t}\n\n\tc := state.Caret()\n\tif c.Pos() == 0 {\n\t\treturn\n\t}\n\n\tq := state.Query()\n\tpos := q.Len()\n\tif l := q.Len(); l <= c.Pos() {\n\t\tpos = l\n\t}\n\n\tsepFunc := unicode.IsSpace\n\tif unicode.IsSpace(q.RuneAt(pos - 1)) {\n\t\tsepFunc = func(r rune) bool { return !unicode.IsSpace(r) }\n\t}\n\n\tfound := false\n\tstart := pos\n\tfor pos = start - 1; pos >= 0; pos-- {\n\t\tif sepFunc(q.RuneAt(pos)) {\n\t\t\tq.DeleteRange(pos+1, start)\n\t\t\tc.SetPos(pos + 1)\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tq.DeleteRange(0, start)\n\t\tc.SetPos(0)\n\t}\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doForwardWord(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif state.Caret().Pos() >= state.Query().Len() {\n\t\treturn\n\t}\n\tdefer state.Hub().SendDrawPrompt(ctx)\n\n\tfoundSpace := false\n\tq := state.Query()\n\tc := state.Caret()\n\tfor pos := c.Pos(); pos < q.Len(); pos++ {\n\t\tr := q.RuneAt(pos)\n\t\tif foundSpace {\n\t\t\tif !unicode.IsSpace(r) {\n\t\t\t\tc.SetPos(pos)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif unicode.IsSpace(r) {\n\t\t\t\tfoundSpace = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// not found. just move to the end of the buffer\n\tc.SetPos(q.Len())\n}\n\nfunc doBackwardWord(ctx context.Context, state *Peco, _ termbox.Event) {\n\tc := state.Caret()\n\tq := state.Query()\n\tif c.Pos() == 0 {\n\t\treturn\n\t}\n\tdefer state.Hub().SendDrawPrompt(ctx)\n\n\tif c.Pos() >= q.Len() {\n\t\tc.Move(-1)\n\t}\n\n\t// if we start from a whitespace-ish position, we should\n\t// rewind to the end of the previous word, and then do the\n\t// search all over again\nSEARCH_PREV_WORD:\n\tif unicode.IsSpace(q.RuneAt(c.Pos())) {\n\t\tfor pos := c.Pos(); pos > 0; pos-- {\n\t\t\tif !unicode.IsSpace(q.RuneAt(pos)) {\n\t\t\t\tc.SetPos(pos)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we start from the first character of a word, we\n\t// should attempt to move back and search for the previous word\n\tif c.Pos() > 0 && unicode.IsSpace(q.RuneAt(c.Pos()-1)) {\n\t\tc.Move(-1)\n\t\tgoto SEARCH_PREV_WORD\n\t}\n\n\t// Now look for a space\n\tfor pos := c.Pos(); pos > 0; pos-- {\n\t\tif unicode.IsSpace(q.RuneAt(pos)) {\n\t\t\tc.SetPos(int(pos + 1))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// not found. just move to the beginning of the buffer\n\tc.SetPos(0)\n}\n\nfunc doForwardChar(ctx context.Context, state *Peco, _ termbox.Event) {\n\tc := state.Caret()\n\tif c.Pos() >= state.Query().Len() {\n\t\treturn\n\t}\n\tc.Move(1)\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doBackwardChar(ctx context.Context, state *Peco, _ termbox.Event) {\n\tc := state.Caret()\n\tif c.Pos() <= 0 {\n\t\treturn\n\t}\n\tc.Move(-1)\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doDeleteForwardWord(ctx context.Context, state *Peco, _ termbox.Event) {\n\tc := state.Caret()\n\tq := state.Query()\n\tstart := c.Pos()\n\n\tif q.Len() <= start {\n\t\treturn\n\t}\n\n\t// If we are on a word (non-Space, delete till the end of the word.\n\t// If we are on a space, delete till the end of space.\n\tsepFunc := unicode.IsSpace\n\tif unicode.IsSpace(q.RuneAt(start)) {\n\t\tsepFunc = func(r rune) bool { return !unicode.IsSpace(r) }\n\t}\n\n\tfor pos := start; pos < q.Len(); pos++ {\n\t\tif pos == q.Len()-1 {\n\t\t\tq.DeleteRange(start, q.Len())\n\t\t\tc.SetPos(start)\n\t\t\tbreak\n\t\t}\n\n\t\tif sepFunc(q.RuneAt(pos)) {\n\t\t\tq.DeleteRange(start, pos)\n\t\t\tc.SetPos(start)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doBeginningOfLine(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.Caret().SetPos(0)\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doEndOfLine(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.Caret().SetPos(state.Query().Len())\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doEndOfFile(ctx context.Context, state *Peco, e termbox.Event) {\n\tif state.Query().Len() > 0 {\n\t\tdoDeleteForwardChar(ctx, state, e)\n\t} else {\n\t\tdoCancel(ctx, state, e)\n\t}\n}\n\nfunc doKillBeginningOfLine(ctx context.Context, state *Peco, _ termbox.Event) {\n\tq := state.Query()\n\tq.DeleteRange(0, state.Caret().Pos())\n\tstate.Caret().SetPos(0)\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doKillEndOfLine(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif state.Query().Len() <= state.Caret().Pos() {\n\t\treturn\n\t}\n\n\tq := state.Query()\n\tq.DeleteRange(state.Caret().Pos(), q.Len())\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doDeleteAll(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.Query().Reset()\n\tstate.ExecQuery(nil)\n}\n\nfunc doDeleteForwardChar(ctx context.Context, state *Peco, _ termbox.Event) {\n\tq := state.Query()\n\tc := state.Caret()\n\tif q.Len() <= c.Pos() {\n\t\treturn\n\t}\n\n\tpos := c.Pos()\n\tq.DeleteRange(pos, pos+1)\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doDeleteBackwardChar(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doDeleteBackwardChar\")\n\t\tdefer g.End()\n\t}\n\n\tq := state.Query()\n\tc := state.Caret()\n\tqlen := q.Len()\n\tif qlen <= 0 {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"doDeleteBackwardChar: QueryLen <= 0, do nothing\")\n\t\t}\n\t\treturn\n\t}\n\n\tpos := c.Pos()\n\tif pos == 0 {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"doDeleteBackwardChar: Already at position 0\")\n\t\t}\n\t\t// No op\n\t\treturn\n\t}\n\n\tif qlen == 1 {\n\t\t// Micro optimization\n\t\tq.Reset()\n\t} else {\n\t\tq.DeleteRange(pos-1, pos)\n\t}\n\tc.SetPos(pos - 1)\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doRefreshScreen(ctx context.Context, state *Peco, _ termbox.Event) {\n\tstate.Hub().SendDraw(ctx, &DrawOptions{DisableCache: true})\n}\n\nfunc doToggleQuery(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doToggleQuery\")\n\t\tdefer g.End()\n\t}\n\n\tq := state.Query()\n\tif q.Len() == 0 {\n\t\tq.RestoreSavedQuery()\n\t} else {\n\t\tq.SaveQuery()\n\t}\n\n\tif state.ExecQuery(nil) {\n\t\treturn\n\t}\n\tstate.Hub().SendDrawPrompt(ctx)\n}\n\nfunc doKonamiCommand(ctx context.Context, state *Peco, e termbox.Event) {\n\tstate.Hub().SendStatusMsg(ctx, \"All your filters are belongs to us\")\n}\n\nfunc doToggleSingleKeyJump(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doToggleSingleKeyJump\")\n\t\tdefer g.End()\n\t}\n\tstate.ToggleSingleKeyJumpMode()\n}\n\nfunc doToggleViewArround(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doToggleViewArround\")\n\t\tdefer g.End()\n\t}\n\tq := state.Query()\n\n\tif q.Len() > 0 {\n\t\tl, err := state.CurrentLineBuffer().LineAt(state.Location().LineNumber())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tcurrentLine := l.ID()\n\n\t\tdoDeleteAll(ctx, state, e)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(currentLine))\n\t}\n}\n\nfunc doGoToNextSelection(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doGoToNextSelection\")\n\t\tdefer g.End()\n\t}\n\n\tselection := state.Selection()\n\n\tif selection.Len() == 0 {\n\t\tstate.Hub().SendStatusMsg(ctx, \"No Selection\")\n\t\treturn\n\t}\n\n\tb := state.CurrentLineBuffer()\n\tl, err := b.LineAt(state.Location().LineNumber())\n\tif err != nil {\n\t\treturn\n\t}\n\tcurrentLine := l.ID()\n\tnextLine := uint64(math.MaxUint64)\n\tfirstLine := uint64(math.MaxUint64)\n\tfound := false\n\n\tselection.Ascend(func(it btree.Item) bool {\n\t\tselectedLine := it.(line.Line)\n\t\tif selectedLine.ID() > currentLine {\n\t\t\tif selectedLine.ID() < nextLine {\n\t\t\t\tnextLine = selectedLine.ID()\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\n\t\tif selectedLine.ID() <= firstLine {\n\t\t\tfirstLine = selectedLine.ID()\n\t\t}\n\n\t\treturn true\n\t})\n\n\tif found {\n\t\tstate.Hub().SendStatusMsg(ctx, \"Next Selection\")\n\t\tstate.Hub().SendPaging(ctx, ToScrollFirstItem)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(nextLine))\n\t} else {\n\t\tstate.Hub().SendStatusMsg(ctx, \"Next Selection (first)\")\n\t\tstate.Hub().SendPaging(ctx, ToScrollFirstItem)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(firstLine))\n\t}\n}\n\nfunc doGoToPreviousSelection(ctx context.Context, state *Peco, _ termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doGoToPreviousSelection\")\n\t\tdefer g.End()\n\t}\n\n\tselection := state.Selection()\n\n\tif selection.Len() == 0 {\n\t\tstate.Hub().SendStatusMsg(ctx, \"No Selection\")\n\t\treturn\n\t}\n\n\tb := state.CurrentLineBuffer()\n\tl, err := b.LineAt(state.Location().LineNumber())\n\tif err != nil {\n\t\treturn\n\t}\n\tcurrentLine := l.ID()\n\tpreviousLine := uint64(0)\n\tlastLine := uint64(math.MaxUint64)\n\tfound := false\n\n\tselection.Ascend(func(it btree.Item) bool {\n\t\tselectedLine := it.(line.Line)\n\t\tif selectedLine.ID() < currentLine {\n\t\t\tif selectedLine.ID() > previousLine {\n\t\t\t\tpreviousLine = selectedLine.ID()\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\n\t\tif selectedLine.ID() >= lastLine {\n\t\t\tlastLine = selectedLine.ID()\n\t\t}\n\n\t\treturn true\n\t})\n\n\tif found {\n\t\tstate.Hub().SendStatusMsg(ctx, \"Previous Selection\")\n\t\tstate.Hub().SendPaging(ctx, ToScrollFirstItem)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(previousLine))\n\t} else {\n\t\tstate.Hub().SendStatusMsg(ctx, \"Previous Selection (first)\")\n\t\tstate.Hub().SendPaging(ctx, ToScrollFirstItem)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(lastLine))\n\t}\n}\n\nfunc doSingleKeyJump(ctx context.Context, state *Peco, e termbox.Event) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"doSingleKeyJump %c\", e.Ch)\n\t\tdefer g.End()\n\t}\n\tindex, ok := state.SingleKeyJumpIndex(e.Ch)\n\tif !ok {\n\t\t// Couldn't find it? Do nothing\n\t\treturn\n\t}\n\n\ttoplevel, _ := ctx.Value(isTopLevelActionCall).(bool)\n\tstate.Hub().Batch(ctx, func(ctx context.Context) {\n\t\tctx = context.WithValue(ctx, isTopLevelActionCall, false)\n\t\tstate.Hub().SendPaging(ctx, JumpToLineRequest(index))\n\t\tdoFinish(ctx, state, e)\n\t}, toplevel)\n}\n\nfunc makeCombinedAction(actions ...Action) ActionFunc {\n\treturn ActionFunc(func(ctx context.Context, state *Peco, e termbox.Event) {\n\t\ttoplevel, _ := ctx.Value(isTopLevelActionCall).(bool)\n\t\tstate.Hub().Batch(ctx, func(ctx context.Context) {\n\t\t\tctx = context.WithValue(ctx, isTopLevelActionCall, false)\n\t\t\tfor _, a := range actions {\n\t\t\t\ta.Execute(ctx, state, e)\n\t\t\t}\n\t\t}, toplevel)\n\t})\n}\n"
        },
        {
          "name": "action_test.go",
          "type": "blob",
          "size": 8.017578125,
          "content": "package peco\n\nimport (\n\t\"testing\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"context\"\n\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/filter\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestActionFunc(t *testing.T) {\n\tcalled := 0\n\taf := ActionFunc(func(_ context.Context, _ *Peco, _ termbox.Event) {\n\t\tcalled++\n\t})\n\taf.Execute(nil, nil, termbox.Event{})\n\tif !assert.Equal(t, called, 1, \"Expected ActionFunc to be called once, but it got called %d times\", called) {\n\t\treturn\n\t}\n}\n\nfunc TestActionNames(t *testing.T) {\n\t// These names MUST exist\n\tnames := []string{\n\t\t\"peco.ForwardChar\",\n\t\t\"peco.BackwardChar\",\n\t\t\"peco.ForwardWord\",\n\t\t\"peco.BackwardWord\",\n\t\t\"peco.BeginningOfLine\",\n\t\t\"peco.EndOfLine\",\n\t\t\"peco.EndOfFile\",\n\t\t\"peco.DeleteForwardChar\",\n\t\t\"peco.DeleteBackwardChar\",\n\t\t\"peco.DeleteForwardWord\",\n\t\t\"peco.DeleteBackwardWord\",\n\t\t\"peco.KillEndOfLine\",\n\t\t\"peco.DeleteAll\",\n\t\t\"peco.SelectPreviousPage\",\n\t\t\"peco.SelectNextPage\",\n\t\t\"peco.SelectPrevious\",\n\t\t\"peco.SelectNext\",\n\t\t\"peco.ToggleSelection\",\n\t\t\"peco.ToggleSelectionAndSelectNext\",\n\t\t\"peco.RotateMatcher\",\n\t\t\"peco.Finish\",\n\t\t\"peco.Cancel\",\n\t}\n\tfor _, name := range names {\n\t\tif _, ok := nameToActions[name]; !ok {\n\t\t\tt.Errorf(\"Action %s should exist, but it does not\", name)\n\t\t}\n\t}\n}\n\nfunc expectCaretPos(t *testing.T, c *Caret, expect int) bool {\n\treturn assert.Equal(t, expect, c.Pos(), \"Expected caret position %d, got %d\", expect, c.Pos())\n}\n\nfunc expectQueryString(t *testing.T, q *Query, expect string) bool {\n\treturn assert.Equal(t, expect, q.String(), \"Expected '%s', got '%s'\", expect, q.String())\n}\n\nfunc TestDoDeleteForwardChar(t *testing.T) {\n\tstate := newPeco()\n\tq := state.Query()\n\tc := state.Caret()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tq.Set(\"Hello, World!\")\n\tc.SetPos(5)\n\n\tdoDeleteForwardChar(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \"Hello World!\") {\n\t\treturn\n\t}\n\tif !expectCaretPos(t, c, 5) {\n\t\treturn\n\t}\n\n\tc.SetPos(q.Len())\n\tdoDeleteForwardChar(ctx, state, termbox.Event{})\n\n\texpectQueryString(t, q, \"Hello World!\")\n\texpectCaretPos(t, c, q.Len())\n\n\tc.SetPos(0)\n\tdoDeleteForwardChar(ctx, state, termbox.Event{})\n\n\texpectQueryString(t, q, \"ello World!\")\n\texpectCaretPos(t, c, 0)\n}\n\nfunc TestDoDeleteForwardWord(t *testing.T) {\n\tstate := newPeco()\n\tq := state.Query()\n\tc := state.Caret()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tq.Set(\"Hello, World!\")\n\tc.SetPos(5)\n\n\t// delete the comma\n\tdoDeleteForwardWord(ctx, state, termbox.Event{})\n\tif !expectQueryString(t, q, \"Hello World!\") {\n\t\treturn\n\t}\n\n\tif !expectCaretPos(t, c, 5) {\n\t\treturn\n\t}\n\n\t// at the end of the query, should not delete anything\n\tc.SetPos(q.Len())\n\tdoDeleteForwardWord(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \"Hello World!\") {\n\t\treturn\n\t}\n\tif !expectCaretPos(t, c, q.Len()) {\n\t\treturn\n\t}\n\n\t// back to the first column, should delete 'Hello'\n\tc.SetPos(0)\n\tdoDeleteForwardWord(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \" World!\") {\n\t\treturn\n\t}\n\n\tif !expectCaretPos(t, c, 0) {\n\t\treturn\n\t}\n\n\t// should delete \"World\"\n\tc.SetPos(1)\n\tdoDeleteForwardWord(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \" \") {\n\t\treturn\n\t}\n}\n\nfunc TestDoDeleteBackwardChar(t *testing.T) {\n\tstate := newPeco()\n\tq := state.Query()\n\tc := state.Caret()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tq.Set(\"Hello, World!\")\n\tc.SetPos(5)\n\n\tdoDeleteBackwardChar(ctx, state, termbox.Event{})\n\n\texpectQueryString(t, q, \"Hell, World!\")\n\texpectCaretPos(t, c, 4)\n\n\tc.SetPos(q.Len())\n\tdoDeleteBackwardChar(ctx, state, termbox.Event{})\n\n\texpectQueryString(t, q, \"Hell, World\")\n\texpectCaretPos(t, c, q.Len())\n\n\tc.SetPos(0)\n\tdoDeleteBackwardChar(ctx, state, termbox.Event{})\n\n\texpectQueryString(t, q, \"Hell, World\")\n\texpectCaretPos(t, c, 0)\n}\n\nfunc TestDoDeleteBackwardWord(t *testing.T) {\n\tstate := newPeco()\n\tq := state.Query()\n\tc := state.Caret()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\t// In case of an overflow (bug)\n\tq.Set(\"foo\")\n\tc.SetPos(5)\n\tdoDeleteBackwardWord(ctx, state, termbox.Event{})\n\n\t// https://github.com/peco/peco/pull/184#issuecomment-54026739\n\n\t// Case 1. \" foo<caret>\" -> \" \"\n\tq.Set(\" foo\")\n\tc.SetPos(4)\n\tdoDeleteBackwardWord(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \" \") {\n\t\treturn\n\t}\n\n\tif !expectCaretPos(t, c, 1) {\n\t\treturn\n\t}\n\n\t// Case 2. \"foo bar<caret>\" -> \"foo \"\n\tq.Set(\"foo bar\")\n\tc.SetPos(7)\n\tdoDeleteBackwardWord(ctx, state, termbox.Event{})\n\n\tif !expectQueryString(t, q, \"foo \") {\n\t\treturn\n\t}\n\n\tif !expectCaretPos(t, c, 4) {\n\t\treturn\n\t}\n}\n\nfunc writeQueryToPrompt(t *testing.T, screen Screen, message string) {\n\tfor str := message; true; {\n\t\tr, size := utf8.DecodeRuneInString(str)\n\t\tif r == utf8.RuneError {\n\t\t\tassert.Equal(t, 0, size, \"when in error, we should have size == 0\")\n\t\t\treturn\n\t\t}\n\n\t\tif r == ' ' {\n\t\t\tscreen.SendEvent(termbox.Event{Key: termbox.KeySpace})\n\t\t} else {\n\t\t\tscreen.SendEvent(termbox.Event{Ch: r})\n\t\t}\n\t\tstr = str[size:]\n\t}\n}\n\nfunc TestDoAcceptChar(t *testing.T) {\n\tstate := newPeco()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tmessage := \"Hello, World!\"\n\twriteQueryToPrompt(t, state.screen, message)\n\ttime.Sleep(500 * time.Millisecond)\n\n\tif qs := state.Query().String(); qs != message {\n\t\tt.Errorf(\"Expected query to be populated as '%s', but got '%s'\", message, qs)\n\t}\n\n\tstate.Caret().Move(-1 * len(\"World!\"))\n\twriteQueryToPrompt(t, state.screen, \"Cruel \")\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\texpected := \"Hello, Cruel World!\"\n\tif qs := state.Query().String(); qs != expected {\n\t\tt.Errorf(\"Expected query to be populated as '%s', but got '%s'\", expected, qs)\n\t}\n}\n\nfunc TestRotateFilter(t *testing.T) {\n\tstate := newPeco()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tsize := state.filters.Size()\n\tif size <= 1 {\n\t\tt.Skip(\"Can't proceed testing, only have 1 filter registered\")\n\t\treturn\n\t}\n\n\tvar prev filter.Filter\n\tfirst := state.Filters().Current()\n\tprev = first\n\tfor i := 0; i < size; i++ {\n\t\tstate.screen.SendEvent(termbox.Event{Key: termbox.KeyCtrlR})\n\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tf := state.Filters().Current()\n\t\tif f == prev {\n\t\t\tt.Errorf(\"failed to rotate\")\n\t\t}\n\t\tprev = f\n\t}\n\n\tif first != prev {\n\t\tt.Errorf(\"should have rotated back to first one, but didn't\")\n\t}\n\n\t// TODO toggle ExecQuery()\n}\n\nfunc TestBeginningOfLineAndEndOfLine(t *testing.T) {\n\tstate := newPeco()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tmessage := \"Hello, World!\"\n\twriteQueryToPrompt(t, state.screen, message)\n\tstate.screen.SendEvent(termbox.Event{Key: termbox.KeyCtrlA})\n\n\ttime.Sleep(time.Second)\n\tif !assert.Equal(t, state.Caret().Pos(), 0, \"Expected caret position to be 0, got %d\", state.Caret().Pos()) {\n\t\treturn\n\t}\n\n\tstate.screen.SendEvent(termbox.Event{Key: termbox.KeyCtrlE})\n\ttime.Sleep(time.Second)\n\n\tif !assert.Equal(t, state.Caret().Pos(), len(message), \"Expected caret position to be %d, got %d\", len(message), state.Caret().Pos()) {\n\t\treturn\n\t}\n\n}\n\nfunc TestBackToInitialFilter(t *testing.T) {\n\tstate := newPeco()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tstate.config.Keymap[\"C-q\"] = \"peco.BackToInitialFilter\"\n\tif !assert.NoError(t, state.populateKeymap(), \"populateKeymap expected to succeed\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, state.Filters().Index(), 0, \"Expected filter to be at position 0, got %d\", state.Filters().Index()) {\n\t\treturn\n\t}\n\n\tstate.screen.SendEvent(termbox.Event{Key: termbox.KeyCtrlR})\n\ttime.Sleep(time.Second)\n\tif !assert.Equal(t, state.Filters().Index(), 1, \"Expected filter to be at position 1, got %d\", state.Filters().Index()) {\n\t\treturn\n\t}\n\n\tstate.screen.SendEvent(termbox.Event{Key: termbox.KeyCtrlQ})\n\ttime.Sleep(time.Second)\n\tif !assert.Equal(t, state.Filters().Index(), 0, \"Expected filter to be at position 0, got %d\", state.Filters().Index()) {\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "buffer.go",
          "type": "blob",
          "size": 3.515625,
          "content": "package peco\n\nimport (\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\trunewidth \"github.com/mattn/go-runewidth\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/peco/peco/pipeline\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc NewFilteredBuffer(src Buffer, page, perPage int) *FilteredBuffer {\n\tfb := FilteredBuffer{\n\t\tsrc: src,\n\t}\n\n\tstart := perPage * (page - 1)\n\n\t// if for whatever reason we wanted a page that goes over the\n\t// capacity of the original buffer, we don't need to do any more\n\t// calculations. bail out\n\tif start > src.Size() {\n\t\treturn &fb\n\t}\n\n\t// Copy over the selections that are applicable to this filtered buffer.\n\tselection := make([]int, 0, src.Size())\n\tend := start + perPage\n\tif end >= src.Size() {\n\t\tend = src.Size()\n\t}\n\n\tlines := src.linesInRange(start, end)\n\tvar maxcols int\n\tfor i := start; i < end; i++ {\n\t\tselection = append(selection, i)\n\t\tcols := runewidth.StringWidth(lines[i-start].DisplayString())\n\t\tif cols > maxcols {\n\t\t\tmaxcols = cols\n\t\t}\n\t}\n\tfb.selection = selection\n\tfb.maxcols = maxcols\n\n\treturn &fb\n}\n\n// MaxColumn returns the max column size, which controls the amount we\n// can scroll to the right\nfunc (flb *FilteredBuffer) MaxColumn() int {\n\treturn flb.maxcols\n}\n\n// LineAt returns the line at index `i`. Note that the i-th element\n// in this filtered buffer may actually correspond to a totally\n// different line number in the source buffer.\nfunc (flb FilteredBuffer) LineAt(i int) (line.Line, error) {\n\tif i >= len(flb.selection) {\n\t\treturn nil, errors.Errorf(\"specified index %d is out of range\", len(flb.selection))\n\t}\n\treturn flb.src.LineAt(flb.selection[i])\n}\n\n// Size returns the number of lines in the buffer\nfunc (flb FilteredBuffer) Size() int {\n\treturn len(flb.selection)\n}\n\nfunc NewMemoryBuffer() *MemoryBuffer {\n\tmb := &MemoryBuffer{}\n\tmb.Reset()\n\treturn mb\n}\n\nfunc (mb *MemoryBuffer) Size() int {\n\tmb.mutex.RLock()\n\tdefer mb.mutex.RUnlock()\n\treturn bufferSize(mb.lines)\n}\n\nfunc bufferSize(lines []line.Line) int {\n\treturn len(lines)\n}\n\nfunc (mb *MemoryBuffer) Reset() {\n\tmb.mutex.Lock()\n\tdefer mb.mutex.Unlock()\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"MemoryBuffer.Reset\")\n\t\tdefer g.End()\n\t}\n\tmb.done = make(chan struct{})\n\tmb.lines = []line.Line(nil)\n}\n\nfunc (mb *MemoryBuffer) Done() <-chan struct{} {\n\tmb.mutex.RLock()\n\tdefer mb.mutex.RUnlock()\n\treturn mb.done\n}\n\nfunc (mb *MemoryBuffer) Accept(ctx context.Context, in chan interface{}, _ pipeline.ChanOutput) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"MemoryBuffer.Accept\")\n\t\tdefer g.End()\n\t}\n\tdefer func() {\n\t\tmb.mutex.Lock()\n\t\tclose(mb.done)\n\t\tmb.mutex.Unlock()\n\t}()\n\n\tstart := time.Now()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif pdebug.Enabled {\n\t\t\t\tpdebug.Printf(\"MemoryBuffer received context done\")\n\t\t\t}\n\t\t\treturn\n\t\tcase v := <-in:\n\t\t\tswitch v.(type) {\n\t\t\tcase error:\n\t\t\t\tif pipeline.IsEndMark(v.(error)) {\n\t\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\t\tpdebug.Printf(\"MemoryBuffer received end mark (read %d lines, %s since starting accept loop)\", len(mb.lines), time.Since(start).String())\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase line.Line:\n\t\t\t\tmb.mutex.Lock()\n\t\t\t\tmb.lines = append(mb.lines, v.(line.Line))\n\t\t\t\tmb.mutex.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (mb *MemoryBuffer) LineAt(n int) (line.Line, error) {\n\tmb.mutex.RLock()\n\tdefer mb.mutex.RUnlock()\n\treturn bufferLineAt(mb.lines, n)\n}\n\nfunc (mb *MemoryBuffer) linesInRange(start, end int) []line.Line {\n\tmb.mutex.RLock()\n\tdefer mb.mutex.RUnlock()\n\treturn mb.lines[start:end]\n}\n\nfunc bufferLineAt(lines []line.Line, n int) (line.Line, error) {\n\tif s := len(lines); s <= 0 || n >= s {\n\t\treturn nil, errors.New(\"empty buffer\")\n\t}\n\n\treturn lines[n], nil\n}\n"
        },
        {
          "name": "caret.go",
          "type": "blob",
          "size": 0.3447265625,
          "content": "package peco\n\nfunc (c *Caret) Pos() int {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\treturn c.pos\n}\n\nfunc (c *Caret) setPos_nolock(p int) {\n\tc.pos = p\n}\n\nfunc (c *Caret) SetPos(p int) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tc.setPos_nolock(p)\n}\n\nfunc (c *Caret) Move(diff int) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tc.setPos_nolock(c.pos + diff)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 5.7626953125,
          "content": "package peco\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"strconv\"\n\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/filter\"\n\t\"github.com/peco/peco/internal/util\"\n\t\"github.com/pkg/errors\"\n)\n\nvar homedirFunc = util.Homedir\n\n// NewConfig creates a new Config\nfunc (c *Config) Init() error {\n\tc.Keymap = make(map[string]string)\n\tc.InitialMatcher = IgnoreCaseMatch\n\tc.Style.Init()\n\tc.Prompt = \"QUERY>\"\n\tc.Layout = LayoutTypeTopDown\n\tc.Use256Color = false\n\treturn nil\n}\n\n// ReadFilename reads the config from the given file, and\n// does the appropriate processing, if any\nfunc (c *Config) ReadFilename(filename string) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to open file %s\", filename)\n\t}\n\tdefer f.Close()\n\n\terr = json.NewDecoder(f).Decode(c)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to decode JSON\")\n\t}\n\n\tif !IsValidLayoutType(LayoutType(c.Layout)) {\n\t\treturn errors.Errorf(\"invalid layout type: %s\", c.Layout)\n\t}\n\n\tif len(c.CustomMatcher) > 0 {\n\t\tfmt.Fprintf(os.Stderr, \"'CustomMatcher' is deprecated. Use CustomFilter instead\\n\")\n\n\t\tfor n, cfg := range c.CustomMatcher {\n\t\t\tif _, ok := c.CustomFilter[n]; ok {\n\t\t\t\treturn errors.Errorf(\"failed to create CustomFilter: '%s' already exists. Refusing to overwrite with deprecated CustomMatcher config\", n)\n\t\t\t}\n\n\t\t\tc.CustomFilter[n] = CustomFilterConfig{\n\t\t\t\tCmd:             cfg[0],\n\t\t\t\tArgs:            cfg[1:],\n\t\t\t\tBufferThreshold: filter.DefaultCustomFilterBufferThreshold,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nvar (\n\tstringToFg = map[string]termbox.Attribute{\n\t\t\"default\": termbox.ColorDefault,\n\t\t\"black\":   termbox.ColorBlack,\n\t\t\"red\":     termbox.ColorRed,\n\t\t\"green\":   termbox.ColorGreen,\n\t\t\"yellow\":  termbox.ColorYellow,\n\t\t\"blue\":    termbox.ColorBlue,\n\t\t\"magenta\": termbox.ColorMagenta,\n\t\t\"cyan\":    termbox.ColorCyan,\n\t\t\"white\":   termbox.ColorWhite,\n\t}\n\tstringToBg = map[string]termbox.Attribute{\n\t\t\"on_default\": termbox.ColorDefault,\n\t\t\"on_black\":   termbox.ColorBlack,\n\t\t\"on_red\":     termbox.ColorRed,\n\t\t\"on_green\":   termbox.ColorGreen,\n\t\t\"on_yellow\":  termbox.ColorYellow,\n\t\t\"on_blue\":    termbox.ColorBlue,\n\t\t\"on_magenta\": termbox.ColorMagenta,\n\t\t\"on_cyan\":    termbox.ColorCyan,\n\t\t\"on_white\":   termbox.ColorWhite,\n\t}\n\tstringToFgAttr = map[string]termbox.Attribute{\n\t\t\"bold\":      termbox.AttrBold,\n\t\t\"underline\": termbox.AttrUnderline,\n\t\t\"reverse\":   termbox.AttrReverse,\n\t}\n\tstringToBgAttr = map[string]termbox.Attribute{\n\t\t\"on_bold\": termbox.AttrBold,\n\t}\n)\n\n// NewStyleSet creates a new StyleSet struct\nfunc NewStyleSet() *StyleSet {\n\tss := &StyleSet{}\n\tss.Init()\n\treturn ss\n}\n\nfunc (ss *StyleSet) Init() {\n\tss.Basic.fg = termbox.ColorDefault\n\tss.Basic.bg = termbox.ColorDefault\n\tss.Query.fg = termbox.ColorDefault\n\tss.Query.bg = termbox.ColorDefault\n\tss.Matched.fg = termbox.ColorCyan\n\tss.Matched.bg = termbox.ColorDefault\n\tss.SavedSelection.fg = termbox.ColorBlack | termbox.AttrBold\n\tss.SavedSelection.bg = termbox.ColorCyan\n\tss.Selected.fg = termbox.ColorDefault | termbox.AttrUnderline\n\tss.Selected.bg = termbox.ColorMagenta\n}\n\n// UnmarshalJSON satisfies json.RawMessage.\nfunc (s *Style) UnmarshalJSON(buf []byte) error {\n\traw := []string{}\n\tif err := json.Unmarshal(buf, &raw); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to unmarshal Style\")\n\t}\n\treturn stringsToStyle(s, raw)\n}\n\nfunc stringsToStyle(style *Style, raw []string) error {\n\tstyle.fg = termbox.ColorDefault\n\tstyle.bg = termbox.ColorDefault\n\n\tfor _, s := range raw {\n\t\tfg, ok := stringToFg[s]\n\t\tif ok {\n\t\t\tstyle.fg = fg\n\t\t} else {\n\t\t\tif fg, err := strconv.ParseUint(s, 10, 8); err == nil {\n\t\t\t\tstyle.fg = termbox.Attribute(fg+1)\n\t\t\t}\n\t\t}\n\n\t\tbg, ok := stringToBg[s]\n\t\tif ok {\n\t\t\tstyle.bg = bg\n\t\t} else {\n\t\t\tif strings.HasPrefix(s, \"on_\") {\n\t\t\t\tif bg, err := strconv.ParseUint(s[3:], 10, 8); err == nil {\n\t\t\t\t\tstyle.bg = termbox.Attribute(bg+1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, s := range raw {\n\t\tif fgAttr, ok := stringToFgAttr[s]; ok {\n\t\t\tstyle.fg |= fgAttr\n\t\t}\n\n\t\tif bgAttr, ok := stringToBgAttr[s]; ok {\n\t\t\tstyle.bg |= bgAttr\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// This is a variable because we want to change its behavior\n// when we run tests.\ntype configLocateFunc func(string) (string, error)\n\nfunc locateRcfileIn(dir string) (string, error) {\n\tconst basename = \"config.json\"\n\tfile := filepath.Join(dir, basename)\n\tif _, err := os.Stat(file); err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"failed to stat file %s\", file)\n\t}\n\treturn file, nil\n}\n\n// LocateRcfile attempts to find the config file in various locations\nfunc LocateRcfile(locater configLocateFunc) (string, error) {\n\t// http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n\t//\n\t// Try in this order:\n\t//\t  $XDG_CONFIG_HOME/peco/config.json\n\t//    $XDG_CONFIG_DIR/peco/config.json (where XDG_CONFIG_DIR is listed in $XDG_CONFIG_DIRS)\n\t//\t  ~/.peco/config.json\n\n\thome, uErr := homedirFunc()\n\n\t// Try dir supplied via env var\n\tif dir := os.Getenv(\"XDG_CONFIG_HOME\"); dir != \"\" {\n\t\tif file, err := locater(filepath.Join(dir, \"peco\")); err == nil {\n\t\t\treturn file, nil\n\t\t}\n\t} else if uErr == nil { // silently ignore failure for homedir()\n\t\t// Try \"default\" XDG location, is user is available\n\t\tif file, err := locater(filepath.Join(home, \".config\", \"peco\")); err == nil {\n\t\t\treturn file, nil\n\t\t}\n\t}\n\n\t// this standard does not take into consideration windows (duh)\n\t// while the spec says use \":\" as the separator, Go provides us\n\t// with filepath.ListSeparator, so use it\n\tif dirs := os.Getenv(\"XDG_CONFIG_DIRS\"); dirs != \"\" {\n\t\tfor _, dir := range strings.Split(dirs, fmt.Sprintf(\"%c\", filepath.ListSeparator)) {\n\t\t\tif file, err := locater(filepath.Join(dir, \"peco\")); err == nil {\n\t\t\t\treturn file, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif uErr == nil { // silently ignore failure for homedir()\n\t\tif file, err := locater(filepath.Join(home, \".peco\")); err == nil {\n\t\t\treturn file, nil\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"config file not found\")\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 4.08203125,
          "content": "package peco\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestReadRC(t *testing.T) {\n\ttxt := `\n{\n\t\"Keymap\": {\n\t\t\"C-j\": \"peco.Finish\",\n\t\t\"C-x,C-c\": \"peco.Finish\"\n\t},\n\t\"Style\": {\n\t\t\"Basic\": [\"on_default\", \"default\"],\n\t\t\"Selected\": [\"underline\", \"on_cyan\", \"black\"],\n\t\t\"Query\": [\"yellow\", \"bold\"],\n\t\t\"Matched\": [\"cyan\", \"bold\", \"on_red\"]\n\t},\n\t\"Prompt\": \"[peco]\"\n}\n`\n\tvar cfg Config\n\tif !assert.NoError(t, cfg.Init(), \"Config.Init should succeed\") {\n\t\treturn\n\t}\n\n\tif !assert.NoError(t, json.Unmarshal([]byte(txt), &cfg), \"Unmarshalling config should succeed\") {\n\t\treturn\n\t}\n\n\texpected := Config{\n\t\tKeymap: map[string]string{\n\t\t\t\"C-j\":     \"peco.Finish\",\n\t\t\t\"C-x,C-c\": \"peco.Finish\",\n\t\t},\n\t\tInitialMatcher: IgnoreCaseMatch,\n\t\tLayout:         DefaultLayoutType,\n\t\tPrompt:         \"[peco]\",\n\t\tStyle: StyleSet{\n\t\t\tMatched: Style{\n\t\t\t\tfg: termbox.ColorCyan | termbox.AttrBold,\n\t\t\t\tbg: termbox.ColorRed,\n\t\t\t},\n\t\t\tQuery: Style{\n\t\t\t\tfg: termbox.ColorYellow | termbox.AttrBold,\n\t\t\t\tbg: termbox.ColorDefault,\n\t\t\t},\n\t\t\tSelected: Style{\n\t\t\t\tfg: termbox.ColorBlack | termbox.AttrUnderline,\n\t\t\t\tbg: termbox.ColorCyan,\n\t\t\t},\n\t\t\tSavedSelection: Style{\n\t\t\t\tfg: termbox.ColorBlack | termbox.AttrBold,\n\t\t\t\tbg: termbox.ColorCyan,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !assert.Equal(t, expected, cfg, \"configuration matches expected\") {\n\t\treturn\n\t}\n}\n\ntype stringsToStyleTest struct {\n\tstrings []string\n\tstyle   *Style\n}\n\nfunc TestStringsToStyle(t *testing.T) {\n\ttests := []stringsToStyleTest{\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"on_default\", \"default\"},\n\t\t\tstyle:   &Style{fg: termbox.ColorDefault, bg: termbox.ColorDefault},\n\t\t},\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"bold\", \"on_blue\", \"yellow\"},\n\t\t\tstyle:   &Style{fg: termbox.ColorYellow | termbox.AttrBold, bg: termbox.ColorBlue},\n\t\t},\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"underline\", \"on_cyan\", \"black\"},\n\t\t\tstyle:   &Style{fg: termbox.ColorBlack | termbox.AttrUnderline, bg: termbox.ColorCyan},\n\t\t},\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"reverse\", \"on_red\", \"white\"},\n\t\t\tstyle:   &Style{fg: termbox.ColorWhite | termbox.AttrReverse, bg: termbox.ColorRed},\n\t\t},\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"on_bold\", \"on_magenta\", \"green\"},\n\t\t\tstyle:   &Style{fg: termbox.ColorGreen, bg: termbox.ColorMagenta | termbox.AttrBold},\n\t\t},\n\t\tstringsToStyleTest{\n\t\t\tstrings: []string{\"underline\", \"on_240\", \"214\"},\n\t\t\tstyle:   &Style{fg: (214+1) | termbox.AttrUnderline, bg: 240+1},\n\t\t},\n\t}\n\n\tt.Logf(\"Checking strings -> color mapping...\")\n\tvar a Style\n\tfor _, test := range tests {\n\t\tt.Logf(\"    checking %s...\", test.strings)\n\t\tif !assert.NoError(t, stringsToStyle(&a, test.strings), \"stringsToStyle should succeed\") {\n\t\t\treturn\n\t\t}\n\n\t\tif !assert.Equal(t, test.style, &a, \"Expected '%s' to be '%#v', but got '%#v'\", test.strings, test.style, a) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestLocateRcfile(t *testing.T) {\n\tdir, err := ioutil.TempDir(\"\", \"peco-\")\n\tif !assert.NoError(t, err, \"Failed to create temporary directory: %s\", err) {\n\t\treturn\n\t}\n\n\thomedirFunc = func() (string, error) {\n\t\treturn dir, nil\n\t}\n\n\texpected := []string{\n\t\tfilepath.Join(dir, \"peco\"),\n\t\tfilepath.Join(dir, \"1\", \"peco\"),\n\t\tfilepath.Join(dir, \"2\", \"peco\"),\n\t\tfilepath.Join(dir, \"3\", \"peco\"),\n\t\tfilepath.Join(dir, \".peco\"),\n\t}\n\n\ti := 0\n\tlocater := func(dir string) (string, error) {\n\t\tt.Logf(\"looking for file in %s\", dir)\n\t\tif !assert.True(t, i <= len(expected)-1, \"Got %d directories, only have %d\", i+1, len(expected)) {\n\t\t\treturn \"\", errors.New(\"error: Not found\")\n\t\t}\n\n\t\tif !assert.Equal(t, expected[i], dir, \"Expected %s, got %s\", expected[i], dir) {\n\t\t\treturn \"\", errors.New(\"error: Not found\")\n\t\t}\n\t\ti++\n\t\treturn \"\", errors.New(\"error: Not found\")\n\t}\n\n\tos.Setenv(\"XDG_CONFIG_HOME\", dir)\n\tos.Setenv(\"XDG_CONFIG_DIRS\", strings.Join(\n\t\t[]string{\n\t\t\tfilepath.Join(dir, \"1\"),\n\t\t\tfilepath.Join(dir, \"2\"),\n\t\t\tfilepath.Join(dir, \"3\"),\n\t\t},\n\t\tfmt.Sprintf(\"%c\", filepath.ListSeparator),\n\t))\n\n\tLocateRcfile(locater)\n\texpected[0] = filepath.Join(dir, \".config\", \"peco\")\n\tos.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\ti = 0\n\tLocateRcfile(locater)\n\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 5.2099609375,
          "content": "package peco\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/peco/peco/filter\"\n\t\"github.com/peco/peco/hub\"\n\t\"github.com/peco/peco/internal/buffer\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/peco/peco/pipeline\"\n)\n\nfunc newFilterProcessor(f filter.Filter, q string) *filterProcessor {\n\treturn &filterProcessor{\n\t\tfilter: f,\n\t\tquery:  q,\n\t}\n}\n\nfunc (fp *filterProcessor) Accept(ctx context.Context, in chan interface{}, out pipeline.ChanOutput) {\n\tacceptAndFilter(ctx, fp.filter, in, out)\n}\n\n// This flusher is run in a separate goroutine so that the filter can\n// run separately from accepting incoming messages\nfunc flusher(ctx context.Context, f filter.Filter, incoming chan []line.Line, done chan struct{}, out pipeline.ChanOutput) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"flusher goroutine\")\n\t\tdefer g.End()\n\t}\n\n\tdefer close(done)\n\tdefer out.SendEndMark(\"end of filter\")\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase buf, ok := <-incoming:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpdebug.Printf(\"flusher: %#v\", buf)\n\t\t\tf.Apply(ctx, buf, out)\n\t\t\tbuffer.ReleaseLineListBuf(buf)\n\t\t}\n\t}\n}\n\nfunc acceptAndFilter(ctx context.Context, f filter.Filter, in chan interface{}, out pipeline.ChanOutput) {\n\tflush := make(chan []line.Line)\n\tflushDone := make(chan struct{})\n\tgo flusher(ctx, f, flush, flushDone, out)\n\n\tbuf := buffer.GetLineListBuf()\n\tbufsiz := f.BufSize()\n\tif bufsiz <= 0 {\n\t\tbufsiz = cap(buf)\n\t}\n\tdefer func() { <-flushDone }() // Wait till the flush goroutine is done\n\tdefer close(flush)             // Kill the flush goroutine\n\n\tflushTicker := time.NewTicker(50 * time.Millisecond)\n\tdefer flushTicker.Stop()\n\n\tstart := time.Now()\n\tlines := 0\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif pdebug.Enabled {\n\t\t\t\tpdebug.Printf(\"filter received done\")\n\t\t\t}\n\t\t\treturn\n\t\tcase <-flushTicker.C:\n\t\t\tif len(buf) > 0 {\n\t\t\t\tflush <- buf\n\t\t\t\tbuf = buffer.GetLineListBuf()\n\t\t\t}\n\t\tcase v := <-in:\n\t\t\tswitch v.(type) {\n\t\t\tcase error:\n\t\t\t\tif pipeline.IsEndMark(v.(error)) {\n\t\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\t\tpdebug.Printf(\"filter received end mark (read %d lines, %s since starting accept loop)\", lines+len(buf), time.Since(start).String())\n\t\t\t\t\t}\n\t\t\t\t\tif len(buf) > 0 {\n\t\t\t\t\t\tflush <- buf\n\t\t\t\t\t\tbuf = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tcase line.Line:\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"incoming line\")\n\t\t\t\t\tlines++\n\t\t\t\t}\n\t\t\t\t// We buffer the lines so that we can receive more lines to\n\t\t\t\t// process while we filter what we already have. The buffer\n\t\t\t\t// size is fairly big, because this really only makes a\n\t\t\t\t// difference if we have a lot of lines to process.\n\t\t\t\tbuf = append(buf, v.(line.Line))\n\t\t\t\tif len(buf) >= bufsiz {\n\t\t\t\t\tflush <- buf\n\t\t\t\t\tbuf = buffer.GetLineListBuf()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc NewFilter(state *Peco) *Filter {\n\treturn &Filter{\n\t\tstate: state,\n\t}\n}\n\n// Work is the actual work horse that that does the matching\n// in a goroutine of its own. It wraps Matcher.Match().\nfunc (f *Filter) Work(ctx context.Context, q hub.Payload) {\n\tdefer q.Done()\n\n\tquery, ok := q.Data().(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Filter.Work (query=%#v, batch=%#v)\", query, q.Batch())\n\t\tdefer g.End()\n\t}\n\n\tstate := f.state\n\tif query == \"\" {\n\t\tstate.ResetCurrentLineBuffer()\n\t\tif !state.config.StickySelection {\n\t\t\tstate.Selection().Reset()\n\t\t}\n\t\treturn\n\t}\n\n\t// Create a new pipeline\n\tp := pipeline.New()\n\tp.SetSource(state.Source())\n\n\t// Wraps the actual filter\n\tselectedFilter := state.Filters().Current()\n\tctx = selectedFilter.NewContext(ctx, query)\n\tp.Add(newFilterProcessor(selectedFilter, query))\n\n\tbuf := NewMemoryBuffer()\n\tp.SetDestination(buf)\n\tstate.SetCurrentLineBuffer(buf)\n\n\tgo func(ctx context.Context) {\n\t\tdefer state.Hub().SendDraw(ctx, &DrawOptions{RunningQuery: true})\n\t\tif err := p.Run(ctx); err != nil {\n\t\t\tstate.Hub().SendStatusMsg(ctx, err.Error())\n\t\t}\n\t}(ctx)\n\n\tgo func() {\n\t\tif pdebug.Enabled {\n\t\t\tg := pdebug.Marker(\"Periodic draw request for '%s'\", query)\n\t\t\tdefer g.End()\n\t\t}\n\t\tt := time.NewTicker(5 * time.Millisecond)\n\t\tdefer t.Stop()\n\t\tdefer state.Hub().SendStatusMsg(ctx, \"\")\n\t\tdefer state.Hub().SendDraw(ctx, &DrawOptions{RunningQuery: true})\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-p.Done():\n\t\t\t\treturn\n\t\t\tcase <-t.C:\n\t\t\t\tstate.Hub().SendDraw(ctx, &DrawOptions{RunningQuery: true})\n\t\t\t}\n\t\t}\n\t}()\n\n\t<-p.Done()\n\n\tif !state.config.StickySelection {\n\t\tstate.Selection().Reset()\n\t}\n}\n\n// Loop keeps watching for incoming queries, and upon receiving\n// a query, spawns a goroutine to do the heavy work. It also\n// checks for previously running queries, so we can avoid\n// running many goroutines doing the grep at the same time\nfunc (f *Filter) Loop(ctx context.Context, cancel func()) error {\n\tdefer cancel()\n\n\t// previous holds the function that can cancel the previous\n\t// query. This is used when multiple queries come in succession\n\t// and the previous query is discarded anyway\n\tvar mutex sync.Mutex\n\tvar previous func()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase q := <-f.state.Hub().QueryCh():\n\t\t\tworkctx, workcancel := context.WithCancel(ctx)\n\n\t\t\tmutex.Lock()\n\t\t\tif previous != nil {\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"Canceling previous query\")\n\t\t\t\t}\n\t\t\t\tprevious()\n\t\t\t}\n\t\t\tprevious = workcancel\n\t\t\tmutex.Unlock()\n\n\t\t\tf.state.Hub().SendStatusMsg(ctx, \"Running query...\")\n\n\t\t\tgo f.Work(workctx, q)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "filter",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3583984375,
          "content": "module github.com/peco/peco\n\ngo 1.12\n\nrequire (\n\tgithub.com/google/btree v1.1.2\n\tgithub.com/jessevdk/go-flags v1.5.0\n\tgithub.com/lestrrat-go/pdebug v0.0.0-20180220043849-39f9a71bcabe\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgithub.com/nsf/termbox-go v1.1.1\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgithub.com/stretchr/testify v1.8.4\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.0732421875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/google/btree v1.1.2 h1:xf4v41cLI2Z6FxbKm+8Bu+m8ifhj15JuZ9sa0jZCMUU=\ngithub.com/google/btree v1.1.2/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=\ngithub.com/jessevdk/go-flags v1.5.0 h1:1jKYvbxEjfUl0fmqTCOfonvskHHXMjBySTLW4y9LFvc=\ngithub.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=\ngithub.com/lestrrat-go/pdebug v0.0.0-20180220043849-39f9a71bcabe h1:S7XSBlgc/eI2v47LkPPVa+infH3FuTS4tPJbqCtJovo=\ngithub.com/lestrrat-go/pdebug v0.0.0-20180220043849-39f9a71bcabe/go.mod h1:zvUY6gZZVL2nu7NM+/3b51Z/hxyFZCZxV0hvfZ3NJlg=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/nsf/termbox-go v1.1.1 h1:nksUPLCb73Q++DwbYUBEglYBRPZyoXJdrj5L+TkjyZY=\ngithub.com/nsf/termbox-go v1.1.1/go.mod h1:T0cTdVuOwf7pHQNtfhnEbzHbcNyCEcVU4YPpouCbVxo=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4 h1:EZ2mChiOa8udjfp6rRmswTbtZN/QzUQp4ptM4rnjHvc=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "hub",
          "type": "tree",
          "content": null
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 1.7626953125,
          "content": "package peco\n\nimport (\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/nsf/termbox-go\"\n)\n\nfunc NewInput(state *Peco, am ActionMap, src chan termbox.Event) *Input {\n\treturn &Input{\n\t\tactions: am,\n\t\tevsrc:   src,\n\t\tstate:   state,\n\t}\n}\n\nfunc (i *Input) Loop(ctx context.Context, cancel func()) error {\n\tdefer cancel()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase ev := <-i.evsrc:\n\t\t\tif err := i.handleInputEvent(ctx, ev); err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (i *Input) handleInputEvent(ctx context.Context, ev termbox.Event) error {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"event received from user: %#v\", ev)\n\t\tdefer g.End()\n\t}\n\n\tswitch ev.Type {\n\tcase termbox.EventError:\n\t\treturn nil\n\tcase termbox.EventResize:\n\t\ti.state.Hub().SendDraw(ctx, nil)\n\t\treturn nil\n\tcase termbox.EventKey:\n\t\t// ModAlt is a sequence of letters with a leading \\x1b (=Esc).\n\t\t// It would be nice if termbox differentiated this for us, but\n\t\t// we workaround it by waiting (juuuust a few milliseconds) for\n\t\t// extra key events. If no extra events arrive, it should be Esc\n\n\t\tm := &i.mutex\n\n\t\t// Smells like Esc or Alt. mod == nil checks for the presence\n\t\t// of a previous timer\n\t\tm.Lock()\n\t\tif ev.Ch == 0 && ev.Key == 27 && i.mod == nil {\n\t\t\ttmp := ev\n\t\t\ti.mod = time.AfterFunc(50*time.Millisecond, func() {\n\t\t\t\tm.Lock()\n\t\t\t\ti.mod = nil\n\t\t\t\tm.Unlock()\n\t\t\t\ti.state.Keymap().ExecuteAction(ctx, i.state, tmp)\n\t\t\t})\n\t\t\tm.Unlock()\n\t\t\treturn nil\n\t\t}\n\t\tm.Unlock()\n\n\t\t// it doesn't look like this is Esc or Alt. If we have a previous\n\t\t// timer, stop it because this is probably Alt+ this new key\n\t\tm.Lock()\n\t\tif i.mod != nil {\n\t\t\ti.mod.Stop()\n\t\t\ti.mod = nil\n\t\t\tev.Mod |= termbox.ModAlt\n\t\t}\n\t\tm.Unlock()\n\n\t\ti.state.Keymap().ExecuteAction(ctx, i.state, ev)\n\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "interface.go",
          "type": "blob",
          "size": 14.3369140625,
          "content": "package peco\n\nimport (\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/google/btree\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/filter\"\n\t\"github.com/peco/peco/hub\"\n\t\"github.com/peco/peco/internal/keyseq\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/peco/peco/pipeline\"\n)\n\nconst (\n\tsuccessKey = \"success\"\n\terrorKey   = \"error\"\n)\n\nconst (\n\tToLineAbove       PagingRequestType = iota // ToLineAbove moves the selection to the line above\n\tToScrollPageDown                           // ToScrollPageDown moves the selection to the next page\n\tToLineBelow                                // ToLineBelow moves the selection to the line below\n\tToScrollPageUp                             // ToScrollPageUp moves the selection to the previous page\n\tToScrollLeft                               // ToScrollLeft scrolls screen to the left\n\tToScrollRight                              // ToScrollRight scrolls screen to the right\n\tToLineInPage                               // ToLineInPage jumps to a particular line on the page\n\tToScrollFirstItem                          // ToScrollFirstItem\n\tToScrollLastItem                           // ToScrollLastItem\n)\n\nconst (\n\tDefaultLayoutType  = LayoutTypeTopDown // LayoutTypeTopDown makes the layout so the items read from top to bottom\n\tLayoutTypeTopDown  = \"top-down\"        // LayoutTypeBottomUp changes the layout to read from bottom to up\n\tLayoutTypeBottomUp = \"bottom-up\"\n)\n\nconst (\n\tAnchorTop    VerticalAnchor = iota + 1 // AnchorTop anchors elements towards the top of the screen\n\tAnchorBottom                           // AnchorBottom anchors elements towards the bottom of the screen\n)\n\n// These are used as keys in the config file\nconst (\n\tIgnoreCaseMatch    = \"IgnoreCase\"\n\tCaseSensitiveMatch = \"CaseSensitive\"\n\tSmartCaseMatch     = \"SmartCase\"\n\tRegexpMatch        = \"Regexp\"\n)\n\ntype idgen struct {\n\tch chan uint64\n}\n\n// Peco is the global object containing everything required to run peco.\n// It also contains the global state of the program.\ntype Peco struct {\n\tArgv   []string\n\tStdin  io.Reader\n\tStdout io.Writer\n\tStderr io.Writer\n\thub    MessageHub\n\n\targs       []string\n\tbufferSize int\n\tcaret      Caret\n\t// Config contains the values read in from config file\n\tconfig                  Config\n\tcurrentLineBuffer       Buffer\n\tenableSep               bool // Enable parsing on separators\n\texecOnFinish            string\n\tfilters                 filter.Set\n\tidgen                   *idgen\n\tinitialFilter           string\n\tinitialQuery            string   // populated if --query is specified\n\tinputseq                Inputseq // current key sequence (just the names)\n\tkeymap                  Keymap\n\tlayoutType              string\n\tlocation                Location\n\tmaxScanBufferSize       int\n\tmutex                   sync.Mutex\n\tonCancel                string\n\tprintQuery              bool\n\tprompt                  string\n\tquery                   Query\n\tqueryExecDelay          time.Duration\n\tqueryExecMutex          sync.Mutex\n\tqueryExecTimer          *time.Timer\n\treadyCh                 chan struct{}\n\tresultCh                chan line.Line\n\tscreen                  Screen\n\tselection               *Selection\n\tselectionPrefix         string\n\tselectionRangeStart     RangeStart\n\tselectOneAndExit        bool // True if --select-1 is enabled\n\tsingleKeyJumpMode       bool\n\tsingleKeyJumpPrefixes   []rune\n\tsingleKeyJumpPrefixMap  map[rune]uint\n\tsingleKeyJumpShowPrefix bool\n\tskipReadConfig          bool\n\tstyles                  StyleSet\n\tuse256Color             bool\n\tfuzzyLongestSort        bool\n\n\t// Source is where we buffer input. It gets reused when a new query is\n\t// executed.\n\tsource *Source\n\n\t// cancelFunc is called for Exit()\n\tcancelFunc func()\n\t// Errors are stored here\n\terr error\n}\n\ntype MatchIndexer interface {\n\t// Indices return the matched portion(s) of a string after filtering.\n\t// Note that while Indices may return nil, that just means that there are\n\t// no substrings to be highlighted. It doesn't mean there were no matches\n\tIndices() [][]int\n}\n\ntype Keyseq interface {\n\tAdd(keyseq.KeyList, interface{})\n\tAcceptKey(keyseq.Key) (interface{}, error)\n\tCancelChain()\n\tClear()\n\tCompile() error\n\tInMiddleOfChain() bool\n}\n\n// PagingRequest can be sent to move the selection cursor\ntype PagingRequestType int\n\ntype PagingRequest interface {\n\tType() PagingRequestType\n}\n\ntype JumpToLineRequest int\n\n// Selection stores the line ids that were selected by the user.\n// The contents of the Selection is always sorted from smallest to\n// largest line ID\ntype Selection struct {\n\tmutex sync.Mutex\n\ttree  *btree.BTree\n}\n\n// Screen hides termbox from the consuming code so that\n// it can be swapped out for testing\ntype Screen interface {\n\tInit(*Config) error\n\tClose() error\n\tFlush() error\n\tPollEvent(context.Context, *Config) chan termbox.Event\n\tPrint(PrintArgs) int\n\tResume()\n\tSetCell(int, int, rune, termbox.Attribute, termbox.Attribute)\n\tSetCursor(int, int)\n\tSize() (int, int)\n\tSendEvent(termbox.Event)\n\tSuspend()\n}\n\n// Termbox just hands out the processing to the termbox library\ntype Termbox struct {\n\tmutex     sync.Mutex\n\tresumeCh  chan chan struct{}\n\tsuspendCh chan struct{}\n}\n\n// View handles the drawing/updating the screen\ntype View struct {\n\tlayout Layout\n\tstate  *Peco\n}\n\n// PageCrop filters out a new LineBuffer based on entries\n// per page and the page number\ntype PageCrop struct {\n\tperPage     int\n\tcurrentPage int\n}\n\n// LayoutType describes the types of layout that peco can take\ntype LayoutType string\n\n// VerticalAnchor describes the direction to which elements in the\n// layout are anchored to\ntype VerticalAnchor int\n\n// Layout represents the component that controls where elements are placed on screen\ntype Layout interface {\n\tPrintStatus(string, time.Duration)\n\tDrawPrompt(*Peco)\n\tDrawScreen(*Peco, *DrawOptions)\n\tMovePage(*Peco, PagingRequest) (moved bool)\n\tPurgeDisplayCache()\n}\n\n// AnchorSettings groups items that are required to control\n// where an anchored item is actually placed\ntype AnchorSettings struct {\n\tanchor       VerticalAnchor // AnchorTop or AnchorBottom\n\tanchorOffset int            // offset this many lines from the anchor\n\tscreen       Screen\n}\n\n// UserPrompt draws the prompt line\ntype UserPrompt struct {\n\t*AnchorSettings\n\tprompt    string\n\tpromptLen int\n\tstyles    *StyleSet\n}\n\n// StatusBar draws the status message bar\ntype StatusBar struct {\n\t*AnchorSettings\n\tclearTimer *time.Timer\n\tstyles     *StyleSet\n\ttimerMutex sync.Mutex\n}\n\n// ListArea represents the area where the actual line buffer is\n// displayed in the screen\ntype ListArea struct {\n\t*AnchorSettings\n\tsortTopDown  bool\n\tdisplayCache []line.Line\n\tdirty        bool\n\tstyles       *StyleSet\n}\n\n// BasicLayout is... the basic layout :) At this point this is the\n// only struct for layouts, which means that while the position\n// of components may be configurable, the actual types of components\n// that are used are set and static\ntype BasicLayout struct {\n\t*StatusBar\n\tprompt *UserPrompt\n\tlist   *ListArea\n}\n\n// Keymap holds all the key sequence to action map\ntype Keymap struct {\n\tConfig map[string]string\n\tAction map[string][]string // custom actions\n\tseq    Keyseq\n}\n\n// Filter is responsible for the actual \"grep\" part of peco\ntype Filter struct {\n\tstate *Peco\n}\n\n// Action describes an action that can be executed upon receiving user\n// input. It's an interface so you can create any kind of Action you need,\n// but most everything is implemented in terms of ActionFunc, which is\n// callback based Action\ntype Action interface {\n\tRegister(string, ...termbox.Key)\n\tRegisterKeySequence(string, keyseq.KeyList)\n\tExecute(context.Context, *Peco, termbox.Event)\n}\n\n// ActionFunc is a type of Action that is basically just a callback.\ntype ActionFunc func(context.Context, *Peco, termbox.Event)\n\n// FilteredBuffer holds a \"filtered\" buffer. It holds a reference to\n// the source buffer (note: should be immutable) and a list of indices\n// into the source buffer\ntype FilteredBuffer struct {\n\tmaxcols   int\n\tsrc       Buffer\n\tselection []int // maps from our index to src's index\n}\n\n// Config holds all the data that can be configured in the\n// external configuration file\ntype Config struct {\n\tAction map[string][]string `json:\"Action\"`\n\t// Keymap used to be directly responsible for dispatching\n\t// events against user input, but since then this has changed\n\t// into something that just records the user's config input\n\tKeymap              map[string]string `json:\"Keymap\"`\n\tMatcher             string            `json:\"Matcher\"`        // Deprecated.\n\tInitialMatcher      string            `json:\"InitialMatcher\"` // Use this instead of Matcher\n\tInitialFilter       string            `json:\"InitialFilter\"`\n\tStyle               StyleSet          `json:\"Style\"`\n\tPrompt              string            `json:\"Prompt\"`\n\tLayout              string            `json:\"Layout\"`\n\tUse256Color         bool              `json:\"Use256Color\"`\n\tOnCancel            string            `json:\"OnCancel\"`\n\tCustomMatcher       map[string][]string\n\tCustomFilter        map[string]CustomFilterConfig\n\tQueryExecutionDelay int\n\tStickySelection     bool\n\tMaxScanBufferSize   int\n\tFuzzyLongestSort    bool\n\n\t// If this is true, then the prefix for single key jump mode\n\t// is displayed by default.\n\tSingleKeyJump SingleKeyJumpConfig `json:\"SingleKeyJump\"`\n\n\t// Use this prefix to denote currently selected line\n\tSelectionPrefix string `json:\"SelectionPrefix\"`\n}\n\ntype SingleKeyJumpConfig struct {\n\tShowPrefix bool `json:\"ShowPrefix\"`\n}\n\n// CustomFilterConfig is used to specify configuration parameters\n// to CustomFilters\ntype CustomFilterConfig struct {\n\t// Cmd is the name of the command to invoke\n\tCmd string\n\n\t// TODO: need to check if how we use this is correct\n\tArgs []string\n\n\t// BufferThreshold defines how many lines peco buffers before\n\t// invoking the external command. If this value is big, we\n\t// will execute the external command fewer times, but the\n\t// results will not be generated for longer periods of time.\n\t// If this value is small, we will execute the external command\n\t// more often, but you pay the penalty of invoking that command\n\t// more times.\n\tBufferThreshold int\n}\n\n// StyleSet holds styles for various sections\ntype StyleSet struct {\n\tBasic          Style `json:\"Basic\"`\n\tSavedSelection Style `json:\"SavedSelection\"`\n\tSelected       Style `json:\"Selected\"`\n\tQuery          Style `json:\"Query\"`\n\tMatched        Style `json:\"Matched\"`\n}\n\n// Style describes termbox styles\ntype Style struct {\n\tfg termbox.Attribute\n\tbg termbox.Attribute\n}\n\ntype Caret struct {\n\tmutex sync.Mutex\n\tpos   int\n}\n\ntype Location struct {\n\tcol     int\n\tlineno  int\n\tmaxPage int\n\tpage    int\n\tperPage int\n\toffset  int\n\ttotal   int\n}\n\ntype Query struct {\n\tquery      []rune\n\tsavedQuery []rune\n\tmutex      sync.Mutex\n}\n\ntype FilterQuery Query\n\n// Source implements pipeline.Source, and is the buffer for the input\ntype Source struct {\n\tpipeline.ChanOutput\n\n\tcapacity   int\n\tenableSep  bool\n\tidgen      line.IDGenerator\n\tin         io.Reader\n\tinClosed   bool\n\tisInfinite bool\n\tlines      []line.Line\n\tname       string\n\tmutex      sync.RWMutex\n\tready      chan struct{}\n\tsetupDone  chan struct{}\n\tsetupOnce  sync.Once\n}\n\ntype State interface {\n\tKeymap() *Keymap\n\tQuery() Query\n\tScreen() Screen\n\tSetCurrentCol(int)\n\tCurrentCol() int\n\tSetCurrentLine(int)\n\tCurrentLine() int\n\tSetSingleKeyJumpMode(bool)\n\tSingleKeyJumpMode() bool\n}\n\ntype CLIOptions struct {\n\tOptHelp            bool   `short:\"h\" long:\"help\" description:\"show this help message and exit\"`\n\tOptQuery           string `long:\"query\" description:\"initial value for query\"`\n\tOptRcfile          string `long:\"rcfile\" description:\"path to the settings file\"`\n\tOptVersion         bool   `long:\"version\" description:\"print the version and exit\"`\n\tOptBufferSize      int    `long:\"buffer-size\" short:\"b\" description:\"number of lines to keep in search buffer\"`\n\tOptEnableNullSep   bool   `long:\"null\" description:\"expect NUL (\\\\0) as separator for target/output\"`\n\tOptInitialIndex    int    `long:\"initial-index\" description:\"position of the initial index of the selection (0 base)\"`\n\tOptInitialMatcher  string `long:\"initial-matcher\" description:\"specify the default matcher (deprecated)\"`\n\tOptInitialFilter   string `long:\"initial-filter\" description:\"specify the default filter\"`\n\tOptPrompt          string `long:\"prompt\" description:\"specify the prompt string\"`\n\tOptLayout          string `long:\"layout\" description:\"layout to be used. 'top-down' or 'bottom-up'. default is 'top-down'\"`\n\tOptSelect1         bool   `long:\"select-1\" description:\"select first item and immediately exit if the input contains only 1 item\"`\n\tOptOnCancel        string `long:\"on-cancel\" description:\"specify action on user cancel. 'success' or 'error'.\\ndefault is 'success'. This may change in future versions\"`\n\tOptSelectionPrefix string `long:\"selection-prefix\" description:\"use a prefix instead of changing line color to indicate currently selected lines.\\ndefault is to use colors. This option is experimental\"`\n\tOptExec            string `long:\"exec\" description:\"execute command instead of finishing/terminating peco.\\nPlease note that this command will receive selected line(s) from stdin,\\nand will be executed via '/bin/sh -c' or 'cmd /c'\"`\n\tOptPrintQuery      bool   `long:\"print-query\" description:\"print out the current query as first line of output\"`\n}\n\ntype CLI struct {\n}\n\ntype RangeStart struct {\n\tval   int\n\tvalid bool\n}\n\n// Buffer interface is used for containers for lines to be\n// processed by peco.\ntype Buffer interface {\n\tlinesInRange(int, int) []line.Line\n\tLineAt(int) (line.Line, error)\n\tSize() int\n}\n\n// MemoryBuffer is an implementation of Buffer\ntype MemoryBuffer struct {\n\tdone         chan struct{}\n\tlines        []line.Line\n\tmutex        sync.RWMutex\n\tPeriodicFunc func()\n}\n\ntype ActionMap interface {\n\tExecuteAction(context.Context, *Peco, termbox.Event) error\n}\n\ntype Input struct {\n\tactions ActionMap\n\tevsrc   chan termbox.Event\n\tmod     *time.Timer\n\tmutex   sync.Mutex\n\tstate   *Peco\n}\n\n// MessageHub is the interface that must be satisfied by the\n// message hub component. Unless we're in testing, github.com/peco/peco/hub.Hub\n// is used.\ntype MessageHub interface {\n\tBatch(context.Context, func(context.Context), bool)\n\tDrawCh() chan hub.Payload\n\tPagingCh() chan hub.Payload\n\tQueryCh() chan hub.Payload\n\tSendDraw(context.Context, interface{})\n\tSendDrawPrompt(context.Context)\n\tSendPaging(context.Context, interface{})\n\tSendQuery(context.Context, string)\n\tSendStatusMsg(context.Context, string)\n\tSendStatusMsgAndClear(context.Context, string, time.Duration)\n\tStatusMsgCh() chan hub.Payload\n}\n\ntype filterProcessor struct {\n\tfilter filter.Filter\n\tquery  string\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "issues_test.go",
          "type": "blob",
          "size": 2.658203125,
          "content": "package peco\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"context\"\n\ttermbox \"github.com/nsf/termbox-go\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIssue212_SanityCheck(t *testing.T) {\n\tstate := newPeco()\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\t// Check if the default layout type is honored */\n\t// This the main issue on 212, but while we're at it, we're just\n\t// going to check that all the default values are as expected\n\tif !assert.Equal(t, state.config.Layout, \"top-down\", \"Default layout type should be 'top-down', got '%s'\", state.config.Layout) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, len(state.config.Keymap), 0, \"Default keymap should be empty, but got '%#v'\", state.config.Keymap) {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, state.config.InitialMatcher, IgnoreCaseMatch, \"Default matcher should be IgnoreCaseMatch, but got '%s'\", state.config.InitialMatcher) {\n\t\treturn\n\t}\n\n\tdefstyle := StyleSet{}\n\tdefstyle.Init()\n\tif !assert.Equal(t, state.config.Style, defstyle, \"should be default style\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, state.config.Prompt, \"QUERY>\", \"Default prompt should be 'QUERY>', but got '%s'\", state.config.Prompt) {\n\t\treturn\n\t}\n\n\t// Okay, this time create a dummy config file, and read that in\n\tf, err := ioutil.TempFile(\"\", \"peco-test-config\")\n\tif !assert.NoError(t, err, \"Failed to create temporary config file: %s\", err) {\n\t\treturn\n\t}\n\tfn := f.Name()\n\tdefer os.Remove(fn)\n\n\tio.WriteString(f, `{\n    \"Layout\": \"bottom-up\"\n}`)\n\tf.Close()\n\n\tstate = newPeco()\n\tgo state.Run(ctx)\n\n\t<-state.Ready()\n\n\tif !assert.NoError(t, state.config.ReadFilename(fn), \"Failed to read config: %s\", err) {\n\t\treturn\n\t}\n\tif !assert.Equal(t, state.config.Layout, \"bottom-up\", \"Default layout type should be 'bottom-up', got '%s'\", state.config.Layout) {\n\t\treturn\n\t}\n}\n\nfunc TestIssue345(t *testing.T) {\n\tcfg, err := newConfig(`{\n\t\"Keymap\": {\n    \"C-t\": \"my.ToggleSelectionInAboveLine\"\n\t},\n\t\"Action\": {\n\t\t\"my.ToggleSelectionInAboveLine\": [\n\t\t\t\"peco.SelectUp\",\n\t\t\t\"peco.ToggleSelectionAndSelectNext\"\n\t\t]\n\t}\n}`)\n\tif !assert.NoError(t, err, \"newConfig should succeed\") {\n\t\treturn\n\t}\n\tdefer os.Remove(cfg)\n\n\tstate := newPeco()\n\tstate.skipReadConfig = false\n\tif !assert.NoError(t, state.config.Init(), \"Config.Init should succeed\") {\n\t\treturn\n\t}\n\n\tstate.Argv = append(state.Argv, []string{\"--rcfile\", cfg}...)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo state.Run(ctx)\n\tdefer cancel()\n\n\t<-state.Ready()\n\n\tev := termbox.Event{\n\t\tType: termbox.EventKey,\n\t\tKey:  termbox.KeyCtrlT,\n\t}\n\tif !assert.NoError(t, state.Keymap().ExecuteAction(ctx, state, ev), \"ExecuteAction should succeed\") {\n\t\treturn\n\t}\n\n\ttime.Sleep(time.Second)\n\n}\n"
        },
        {
          "name": "keymap.go",
          "type": "blob",
          "size": 4.244140625,
          "content": "package peco\n\nimport (\n\t\"context\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/internal/keyseq\"\n\t\"github.com/pkg/errors\"\n)\n\n// NewKeymap creates a new Keymap struct\nfunc NewKeymap(config map[string]string, actions map[string][]string) Keymap {\n\treturn Keymap{\n\t\tConfig: config,\n\t\tAction: actions,\n\t\tseq:    keyseq.New(),\n\t}\n}\n\nfunc (km Keymap) Sequence() Keyseq {\n\treturn km.seq\n}\n\nconst isTopLevelActionCall = \"peco.isTopLevelActionCall\"\n\nfunc (km Keymap) ExecuteAction(ctx context.Context, state *Peco, ev termbox.Event) (err error) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Keymap.ExecuteAction %v\", ev).BindError(&err)\n\t\tdefer g.End()\n\t}\n\n\ta := km.LookupAction(ev)\n\tif a == nil {\n\t\treturn errors.New(\"action not found\")\n\t}\n\n\tctx = context.WithValue(ctx, isTopLevelActionCall, true)\n\ta.Execute(ctx, state, ev)\n\treturn nil\n}\n\n// LookupAction returns the appropriate action for the given termbox event\nfunc (km Keymap) LookupAction(ev termbox.Event) Action {\n\tmodifier := keyseq.ModNone\n\tif (ev.Mod & termbox.ModAlt) != 0 {\n\t\tmodifier = keyseq.ModAlt\n\t}\n\n\tkey := keyseq.Key{\n\t\tModifier: modifier,\n\t\tKey:      ev.Key,\n\t\tCh:       ev.Ch,\n\t}\n\taction, err := km.seq.AcceptKey(key)\n\n\tswitch err {\n\tcase nil:\n\t\t// Found an action!\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Keymap.Handler: Fetched action\")\n\t\t}\n\t\treturn wrapClearSequence(action.(Action))\n\tcase keyseq.ErrInSequence:\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Keymap.Handler: Waiting for more commands...\")\n\t\t}\n\t\treturn wrapRememberSequence(ActionFunc(doNothing))\n\tdefault:\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Keymap.Handler: Defaulting to doAcceptChar\")\n\t\t}\n\t\treturn wrapClearSequence(ActionFunc(doAcceptChar))\n\t}\n}\n\nfunc wrapRememberSequence(a Action) Action {\n\treturn ActionFunc(func(ctx context.Context, state *Peco, ev termbox.Event) {\n\t\tif s, err := keyseq.EventToString(ev); err == nil {\n\t\t\tseq := state.Inputseq()\n\t\t\tseq.Add(s)\n\t\t\tstate.Hub().SendStatusMsg(ctx, strings.Join(seq.KeyNames(), \" \"))\n\t\t}\n\t\ta.Execute(ctx, state, ev)\n\t})\n}\n\nfunc wrapClearSequence(a Action) Action {\n\treturn ActionFunc(func(ctx context.Context, state *Peco, ev termbox.Event) {\n\t\tseq := state.Inputseq()\n\t\tif s, err := keyseq.EventToString(ev); err == nil {\n\t\t\tseq.Add(s)\n\t\t}\n\n\t\tif seq.Len() > 0 {\n\t\t\tmsg := strings.Join(seq.KeyNames(), \" \")\n\t\t\tstate.Hub().SendStatusMsgAndClear(ctx, msg, 500*time.Millisecond)\n\t\t\tseq.Reset()\n\t\t}\n\n\t\ta.Execute(ctx, state, ev)\n\t})\n}\n\nconst maxResolveActionDepth = 100\n\nfunc (km Keymap) resolveActionName(name string, depth int) (Action, error) {\n\tif depth >= maxResolveActionDepth {\n\t\treturn nil, errors.Errorf(\"could not resolve %s: deep recursion\", name)\n\t}\n\n\t// Can it be resolved via regular nameToActions ?\n\tv, ok := nameToActions[name]\n\tif ok {\n\t\treturn v, nil\n\t}\n\n\t// Can it be resolved via combined actions?\n\tl, ok := km.Action[name]\n\tif ok {\n\t\tactions := []Action{}\n\t\tfor _, actionName := range l {\n\t\t\tchild, err := km.resolveActionName(actionName, depth+1)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tactions = append(actions, child)\n\t\t}\n\t\tv = makeCombinedAction(actions...)\n\t\tnameToActions[name] = v\n\t\treturn v, nil\n\t}\n\n\treturn nil, errors.Errorf(\"could not resolve %s: no such action\", name)\n}\n\n// ApplyKeybinding applies all of the custom key bindings on top of\n// the default key bindings\nfunc (km *Keymap) ApplyKeybinding() error {\n\tk := km.seq\n\tk.Clear()\n\n\t// Copy the map\n\tkb := map[string]Action{}\n\tfor s, a := range defaultKeyBinding {\n\t\tkb[s] = a\n\t}\n\n\t// munge the map using config\n\tfor s, as := range km.Config {\n\t\tif as == \"-\" {\n\t\t\tdelete(kb, s)\n\t\t\tcontinue\n\t\t}\n\n\t\tv, err := km.resolveActionName(as, 0)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to resolve action name %s\", as)\n\t\t}\n\t\tkb[s] = v\n\t}\n\n\t// now compile using kb\n\t// there's no need to do this, but we sort keys here just to make\n\t// debugging easier\n\tkeys := make([]string, 0, len(kb))\n\tfor s := range kb {\n\t\tkeys = append(keys, s)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, s := range keys {\n\t\ta := kb[s]\n\t\tlist, err := keyseq.ToKeyList(s)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"urnknown key %s: %s\", s, err)\n\t\t}\n\n\t\tk.Add(list, a)\n\t}\n\n\treturn errors.Wrap(k.Compile(), \"failed to compile key binding patterns\")\n}\n\n// TODO: this needs to be fixed.\nfunc (km Keymap) hasModifierMaps() bool {\n\treturn false\n}\n"
        },
        {
          "name": "layout.go",
          "type": "blob",
          "size": 20.130859375,
          "content": "package peco\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/pkg/errors\"\n)\n\nvar extraOffset int = 0\n\n// IsValidLayoutType checks if a string is a supported layout type\nfunc IsValidLayoutType(v LayoutType) bool {\n\treturn v == LayoutTypeTopDown || v == LayoutTypeBottomUp\n}\n\n// IsValidVerticalAnchor checks if the specified anchor is supported\nfunc IsValidVerticalAnchor(anchor VerticalAnchor) bool {\n\treturn anchor == AnchorTop || anchor == AnchorBottom\n}\n\n// Utility function\nfunc mergeAttribute(a, b termbox.Attribute) termbox.Attribute {\n\tif a&0x0F == 0 || b&0x0F == 0 {\n\t\treturn a | b\n\t}\n\treturn ((a - 1) | (b - 1)) + 1\n}\n\n// NewAnchorSettings creates a new AnchorSetting struct. Panics if\n// an unknown VerticalAnchor is sent\nfunc NewAnchorSettings(screen Screen, anchor VerticalAnchor, offset int) *AnchorSettings {\n\tif !IsValidVerticalAnchor(anchor) {\n\t\tpanic(\"Invalid vertical anchor specified\")\n\t}\n\n\treturn &AnchorSettings{\n\t\tanchor:       anchor,\n\t\tanchorOffset: offset,\n\t\tscreen:       screen,\n\t}\n}\n\n// AnchorPosition returns the starting y-offset, based on the\n// anchor type and offset\nfunc (as AnchorSettings) AnchorPosition() int {\n\tvar pos int\n\tswitch as.anchor {\n\tcase AnchorTop:\n\t\tpos = as.anchorOffset\n\tcase AnchorBottom:\n\t\t_, h := as.screen.Size()\n\t\tpos = int(h) - as.anchorOffset - 1 // -1 is required because y is 0 base, but h is 1 base\n\tdefault:\n\t\tpanic(\"Unknown anchor type!\")\n\t}\n\n\treturn pos\n}\n\n// NewUserPrompt creates a new UserPrompt struct\nfunc NewUserPrompt(screen Screen, anchor VerticalAnchor, anchorOffset int, prompt string, styles *StyleSet) *UserPrompt {\n\tif len(prompt) <= 0 { // default\n\t\tprompt = \"QUERY>\"\n\t}\n\tpromptLen := runewidth.StringWidth(prompt)\n\n\treturn &UserPrompt{\n\t\tAnchorSettings: NewAnchorSettings(screen, anchor, anchorOffset),\n\t\tprompt:         prompt,\n\t\tpromptLen:      int(promptLen),\n\t\tstyles:         styles,\n\t}\n}\n\n// Draw draws the query prompt\nfunc (u UserPrompt) Draw(state *Peco) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"UserPrompt.Draw\")\n\t\tdefer g.End()\n\t}\n\n\tlocation := u.AnchorPosition()\n\n\t// print \"QUERY>\"\n\tu.screen.Print(PrintArgs{\n\t\tY:   location,\n\t\tFg:  u.styles.Basic.fg,\n\t\tBg:  u.styles.Basic.bg,\n\t\tMsg: u.prompt,\n\t})\n\n\tc := state.Caret()\n\tif c.Pos() <= 0 { // XXX Do we really need this?\n\t\tc.SetPos(0) // sanity\n\t}\n\n\tq := state.Query()\n\tqs := q.String()\n\tql := q.Len()\n\tif c.Pos() > ql { // XXX Do we really need this?\n\t\tc.SetPos(ql)\n\t}\n\n\tfg := u.styles.Query.fg\n\tbg := u.styles.Query.bg\n\n\t// Used to notify termbox where our cursor is\n\tvar posX int\n\n\tswitch ql {\n\tcase 0:\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    u.promptLen,\n\t\t\tY:    location,\n\t\t\tFg:   fg,\n\t\t\tBg:   bg,\n\t\t\tFill: true,\n\t\t})\n\t\tposX = u.promptLen + 1\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    u.promptLen + 1,\n\t\t\tY:    location,\n\t\t\tBg:   bg | termbox.AttrReverse,\n\t\t\tFg:   fg | termbox.AttrReverse,\n\t\t\tMsg:  \" \",\n\t\t\tFill: false,\n\t\t})\n\tcase c.Pos():\n\t\t// the entire string + the caret after the string\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    u.promptLen,\n\t\t\tY:    location,\n\t\t\tFg:   fg,\n\t\t\tBg:   bg,\n\t\t\tFill: true,\n\t\t})\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    u.promptLen + 1,\n\t\t\tY:    location,\n\t\t\tFg:   fg,\n\t\t\tBg:   bg,\n\t\t\tMsg:  qs,\n\t\t\tFill: false,\n\t\t})\n\t\tposX = u.promptLen + 1 + int(runewidth.StringWidth(qs))\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    posX,\n\t\t\tY:    location,\n\t\t\tFg:   fg | termbox.AttrReverse,\n\t\t\tBg:   bg | termbox.AttrReverse,\n\t\t\tMsg:  \" \",\n\t\t\tFill: false,\n\t\t})\n\tdefault:\n\t\tposX = c.Pos() + u.promptLen + 1\n\t\t// the caret is in the middle of the string\n\t\tprev := int(0)\n\t\tvar i int\n\t\tfor r := range q.Runes() {\n\t\t\tfg := u.styles.Query.fg\n\t\t\tbg := u.styles.Query.bg\n\t\t\tif i == c.Pos() {\n\t\t\t\tfg |= termbox.AttrReverse\n\t\t\t\tbg |= termbox.AttrReverse\n\t\t\t}\n\t\t\tu.screen.SetCell(int(u.promptLen+1+prev), int(location), r, fg, bg)\n\t\t\tprev += int(runewidth.RuneWidth(r))\n\t\t\ti++\n\t\t}\n\t\tfg := u.styles.Query.fg\n\t\tbg := u.styles.Query.bg\n\t\tu.screen.Print(PrintArgs{\n\t\t\tX:    u.promptLen + prev + 1,\n\t\t\tY:    location,\n\t\t\tFg:   fg,\n\t\t\tBg:   bg,\n\t\t\tFill: true,\n\t\t})\n\t}\n\n\tu.screen.SetCursor(posX, location)\n\n\twidth, _ := u.screen.Size()\n\n\tloc := state.Location()\n\tpmsg := fmt.Sprintf(\"%s [%d (%d/%d)]\", state.Filters().Current().String(), loc.Total(), loc.Page(), loc.MaxPage())\n\tu.screen.Print(PrintArgs{\n\t\tX:   int(width - runewidth.StringWidth(pmsg)),\n\t\tY:   location,\n\t\tFg:  u.styles.Basic.fg,\n\t\tBg:  u.styles.Basic.bg,\n\t\tMsg: pmsg,\n\t})\n\n\tu.screen.Flush()\n}\n\n// NewStatusBar creates a new StatusBar struct\nfunc NewStatusBar(screen Screen, anchor VerticalAnchor, anchorOffset int, styles *StyleSet) *StatusBar {\n\treturn &StatusBar{\n\t\tAnchorSettings: NewAnchorSettings(screen, anchor, anchorOffset),\n\t\tclearTimer:     nil,\n\t\tstyles:         styles,\n\t}\n}\n\nfunc (s *StatusBar) stopTimer() {\n\ts.timerMutex.Lock()\n\tdefer s.timerMutex.Unlock()\n\tif t := s.clearTimer; t != nil {\n\t\tt.Stop()\n\t\ts.clearTimer = nil\n\t}\n}\n\nfunc (s *StatusBar) setClearTimer(t *time.Timer) {\n\ts.timerMutex.Lock()\n\tdefer s.timerMutex.Unlock()\n\ts.clearTimer = t\n}\n\n// PrintStatus prints a new status message. This also resets the\n// timer created by ClearStatus()\nfunc (s *StatusBar) PrintStatus(msg string, clearDelay time.Duration) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"StatusBar.PrintStatus\")\n\t\tdefer g.End()\n\t}\n\n\ts.stopTimer()\n\n\tlocation := s.AnchorPosition()\n\n\tw, _ := s.screen.Size()\n\twidth := runewidth.StringWidth(msg)\n\tfor width > w {\n\t\t_, rw := utf8.DecodeRuneInString(msg)\n\t\twidth = width - rw\n\t\tmsg = msg[rw:]\n\t}\n\n\tvar pad []byte\n\tif w > width {\n\t\tpad = make([]byte, w-width)\n\t\tfor i := 0; i < w-width; i++ {\n\t\t\tpad[i] = ' '\n\t\t}\n\t}\n\n\tfgAttr := s.styles.Basic.fg\n\tbgAttr := s.styles.Basic.bg\n\n\tif w > width {\n\t\ts.screen.Print(PrintArgs{\n\t\t\tY:   location,\n\t\t\tFg:  fgAttr,\n\t\t\tBg:  bgAttr,\n\t\t\tMsg: string(pad),\n\t\t})\n\t}\n\n\tif width > 0 {\n\t\ts.screen.Print(PrintArgs{\n\t\t\tX:   int(w - width),\n\t\t\tY:   location,\n\t\t\tFg:  fgAttr | termbox.AttrReverse | termbox.AttrBold | termbox.AttrReverse,\n\t\t\tBg:  bgAttr | termbox.AttrReverse,\n\t\t\tMsg: msg,\n\t\t})\n\t}\n\ts.screen.Flush()\n\n\t// if everything is successful AND the clearDelay timer is specified,\n\t// then set a timer to clear the status\n\tif clearDelay != 0 {\n\t\ts.setClearTimer(time.AfterFunc(clearDelay, func() {\n\t\t\ts.PrintStatus(\"\", 0)\n\t\t}))\n\t}\n}\n\n// NewListArea creates a new ListArea struct\nfunc NewListArea(screen Screen, anchor VerticalAnchor, anchorOffset int, sortTopDown bool, styles *StyleSet) *ListArea {\n\treturn &ListArea{\n\t\tAnchorSettings: NewAnchorSettings(screen, anchor, anchorOffset),\n\t\tdisplayCache:   []line.Line{},\n\t\tdirty:          false,\n\t\tsortTopDown:    sortTopDown,\n\t\tstyles:         styles,\n\t}\n}\n\nfunc (l *ListArea) purgeDisplayCache() {\n\tl.displayCache = []line.Line{}\n}\n\nfunc (l *ListArea) IsDirty() bool {\n\treturn l.dirty\n}\n\nfunc (l *ListArea) SetDirty(dirty bool) {\n\tl.dirty = dirty\n}\n\nfunc selectionContains(state *Peco, n int) bool {\n\tif l, err := state.CurrentLineBuffer().LineAt(n); err == nil {\n\t\treturn state.Selection().Has(l)\n\t}\n\treturn false\n}\n\ntype DrawOptions struct {\n\tRunningQuery bool\n\tDisableCache bool\n}\n\n// Draw displays the ListArea on the screen\nfunc (l *ListArea) Draw(state *Peco, parent Layout, perPage int, options *DrawOptions) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"ListArea.Draw pp = %d, options = %#v\", perPage, options)\n\t\tdefer g.End()\n\t}\n\n\tif perPage < 1 {\n\t\tpanic(\"perPage < 1 (was \" + strconv.Itoa(perPage) + \")\")\n\t}\n\n\tloc := state.Location()\n\n\tlinebuf := state.CurrentLineBuffer()\n\n\t// Should only get into this clause if we are RUNNING A QUERY.\n\t// regular paging shouldn't be affected. This clause basically\n\t// makes sure that we never have an empty screen when we are\n\t// at a large enough page, but we don't have enough entries\n\t// to fill that many pages in the buffer\n\tif options != nil && options.RunningQuery {\n\t\tbufsiz := linebuf.Size()\n\t\tpage := loc.Page()\n\n\t\tfor page > 1 {\n\t\t\tif (loc.PerPage()*(page-1) < bufsiz) &&\n\t\t\t\t(loc.PerPage()*page) >= bufsiz {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tpage--\n\t\t}\n\t\tif loc.Page() != page {\n\t\t\tloc.SetPage(page)\n\t\t\tparent.DrawPrompt(state)\n\t\t}\n\t}\n\n\tpf := loc.PageCrop()\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"Cropping linebuf which contains %d lines at page %d (%d entries per page)\", linebuf.Size(), pf.currentPage, pf.perPage)\n\t}\n\tbuf := pf.Crop(linebuf)\n\tbufsiz := buf.Size()\n\n\t// This protects us from losing the selected line in case our selected\n\t// line is greater than the buffer\n\tif lbufsiz := linebuf.Size(); lbufsiz > 0 && loc.LineNumber() >= lbufsiz {\n\t\tloc.SetLineNumber(lbufsiz - 1)\n\t}\n\n\t// The max column size is calculated by buf. we check against where the\n\t// loc variable thinks we should be scrolling to, and make sure that this\n\t// falls in range with what we got\n\twidth, _ := state.screen.Size()\n\tif max := maxOf(buf.MaxColumn()-width, 0); loc.Column() > max {\n\t\tloc.SetColumn(max)\n\t}\n\n\t// previously drawn lines are cached. first, truncate the cache\n\t// to current size of the drawable area\n\tif ldc := int(len(l.displayCache)); ldc != perPage {\n\t\tnewCache := make([]line.Line, perPage)\n\t\tcopy(newCache, l.displayCache)\n\t\tl.displayCache = newCache\n\t} else if perPage > bufsiz {\n\t\tl.displayCache = l.displayCache[:bufsiz]\n\t}\n\n\tvar y int\n\tstart := l.AnchorPosition()\n\n\t// If our buffer is smaller than perPage, we may need to\n\t// clear some lines\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"ListArea.Draw: buffer size is %d, our view area is %d\", bufsiz, perPage)\n\t}\n\n\tfor n := bufsiz; n < perPage; n++ {\n\t\tif l.sortTopDown {\n\t\t\ty = n + start\n\t\t} else {\n\t\t\ty = start - n\n\t\t}\n\n\t\tl.screen.Print(PrintArgs{\n\t\t\tY:    y,\n\t\t\tFg:   l.styles.Basic.fg,\n\t\t\tBg:   l.styles.Basic.bg,\n\t\t\tFill: true,\n\t\t})\n\t}\n\n\tvar cached, written int\n\tvar fgAttr, bgAttr termbox.Attribute\n\tvar selectionPrefix = state.selectionPrefix\n\tvar prefix = \"\"\n\n\tvar prefixCurrentSelection string\n\tvar prefixSavedSelection string\n\tvar prefixDefault string\n\tif len := len(selectionPrefix); len > 0 {\n\t\tprefixCurrentSelection = selectionPrefix + \" \"\n\t\tprefixSavedSelection = \"*\" + strings.Repeat(\" \", len)\n\t\tprefixDefault = strings.Repeat(\" \", len+1)\n\t}\n\n\tfor n := 0; n < perPage; n++ {\n\t\tif len(selectionPrefix) > 0 {\n\t\t\tswitch {\n\t\t\tcase n+loc.Offset() == loc.LineNumber():\n\t\t\t\tprefix = prefixCurrentSelection\n\t\t\tcase selectionContains(state, n+loc.Offset()):\n\t\t\t\tprefix = prefixSavedSelection\n\t\t\tdefault:\n\t\t\t\tprefix = prefixDefault\n\t\t\t}\n\t\t} else {\n\t\t\tswitch {\n\t\t\tcase n+loc.Offset() == loc.LineNumber():\n\t\t\t\tfgAttr = l.styles.Selected.fg\n\t\t\t\tbgAttr = l.styles.Selected.bg\n\t\t\tcase selectionContains(state, n+loc.Offset()):\n\t\t\t\tfgAttr = l.styles.SavedSelection.fg\n\t\t\t\tbgAttr = l.styles.SavedSelection.bg\n\t\t\tdefault:\n\t\t\t\tfgAttr = l.styles.Basic.fg\n\t\t\t\tbgAttr = l.styles.Basic.bg\n\t\t\t}\n\t\t}\n\n\t\tif n >= bufsiz {\n\t\t\tbreak\n\t\t}\n\n\t\tif l.sortTopDown {\n\t\t\ty = n + start\n\t\t} else {\n\t\t\ty = start - n\n\t\t}\n\n\t\ttarget, err := buf.LineAt(n)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif (options != nil && options.DisableCache) || l.IsDirty() || target.IsDirty() {\n\t\t\ttarget.SetDirty(false)\n\t\t} else if l.displayCache[n] == target {\n\t\t\tcached++\n\t\t\tcontinue\n\t\t}\n\n\t\twritten++\n\t\tl.displayCache[n] = target\n\n\t\tx := -1 * loc.Column()\n\t\txOffset := loc.Column()\n\t\tline := target.DisplayString()\n\n\t\tif len := len(prefix); len > 0 {\n\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\tX:       x,\n\t\t\t\tY:       y,\n\t\t\t\tXOffset: xOffset,\n\t\t\t\tFg:      fgAttr,\n\t\t\t\tBg:      bgAttr,\n\t\t\t\tMsg:     prefix,\n\t\t\t})\n\t\t\tx += len\n\t\t}\n\t\tif state.SingleKeyJumpMode() || state.SingleKeyJumpShowPrefix() {\n\t\t\tprefixes := state.SingleKeyJumpPrefixes()\n\t\t\tif n < int(len(prefixes)) {\n\t\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\t\tX:       x,\n\t\t\t\t\tY:       y,\n\t\t\t\t\tXOffset: xOffset,\n\t\t\t\t\tFg:      fgAttr | termbox.AttrBold | termbox.AttrReverse,\n\t\t\t\t\tBg:      bgAttr,\n\t\t\t\t\tMsg:     string(prefixes[n]),\n\t\t\t\t})\n\t\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\t\tX:       x + 1,\n\t\t\t\t\tY:       y,\n\t\t\t\t\tXOffset: xOffset,\n\t\t\t\t\tFg:      fgAttr,\n\t\t\t\t\tBg:      bgAttr,\n\t\t\t\t\tMsg:     \" \",\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\t\tX:       x,\n\t\t\t\t\tY:       y,\n\t\t\t\t\tXOffset: xOffset,\n\t\t\t\t\tFg:      fgAttr,\n\t\t\t\t\tBg:      bgAttr,\n\t\t\t\t\tMsg:     \"  \",\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tx += 2\n\t\t}\n\n\t\tix, ok := target.(MatchIndexer)\n\t\tif !ok {\n\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\tX:       x,\n\t\t\t\tY:       y,\n\t\t\t\tXOffset: xOffset,\n\t\t\t\tFg:      fgAttr,\n\t\t\t\tBg:      bgAttr,\n\t\t\t\tMsg:     line,\n\t\t\t\tFill:    true,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\n\t\tmatches := ix.Indices()\n\t\tprev := x\n\t\tindex := 0\n\n\t\tfor _, m := range matches {\n\t\t\tif m[0] > index {\n\t\t\t\tc := line[index:m[0]]\n\t\t\t\tn := l.screen.Print(PrintArgs{\n\t\t\t\t\tX:       prev,\n\t\t\t\t\tY:       y,\n\t\t\t\t\tXOffset: xOffset,\n\t\t\t\t\tFg:      fgAttr,\n\t\t\t\t\tBg:      bgAttr,\n\t\t\t\t\tMsg:     c,\n\t\t\t\t})\n\t\t\t\tprev += n\n\t\t\t\tindex += len(c)\n\t\t\t}\n\t\t\tc := line[m[0]:m[1]]\n\n\t\t\tn := l.screen.Print(PrintArgs{\n\t\t\t\tX:       prev,\n\t\t\t\tY:       y,\n\t\t\t\tXOffset: xOffset,\n\t\t\t\tFg:      l.styles.Matched.fg,\n\t\t\t\tBg:      mergeAttribute(bgAttr, l.styles.Matched.bg),\n\t\t\t\tMsg:     c,\n\t\t\t\tFill:    true,\n\t\t\t})\n\t\t\tprev += n\n\t\t\tindex += len(c)\n\t\t}\n\n\t\tm := matches[len(matches)-1]\n\t\tif m[0] > index {\n\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\tX:       prev,\n\t\t\t\tY:       y,\n\t\t\t\tXOffset: xOffset,\n\t\t\t\tFg:      l.styles.Query.fg,\n\t\t\t\tBg:      mergeAttribute(bgAttr, l.styles.Query.bg),\n\t\t\t\tMsg:     line[m[0]:m[1]],\n\t\t\t\tFill:    true,\n\t\t\t})\n\t\t} else if len(line) > m[1] {\n\t\t\tl.screen.Print(PrintArgs{\n\t\t\t\tX:       prev,\n\t\t\t\tY:       y,\n\t\t\t\tXOffset: xOffset,\n\t\t\t\tFg:      fgAttr,\n\t\t\t\tBg:      bgAttr,\n\t\t\t\tMsg:     line[m[1]:len(line)],\n\t\t\t\tFill:    true,\n\t\t\t})\n\t\t}\n\t}\n\tl.SetDirty(false)\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"ListArea.Draw: Written total of %d lines (%d cached)\", written+cached, cached)\n\t}\n}\n\nfunc maxOf(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// NewDefaultLayout creates a new Layout in the default format (top-down)\nfunc NewDefaultLayout(state *Peco) *BasicLayout {\n\treturn &BasicLayout{\n\t\tStatusBar: NewStatusBar(state.Screen(), AnchorBottom, 0+extraOffset, state.Styles()),\n\t\t// The prompt is at the top\n\t\tprompt: NewUserPrompt(state.Screen(), AnchorTop, 0, state.Prompt(), state.Styles()),\n\t\t// The list area is at the top, after the prompt\n\t\t// It's also displayed top-to-bottom order\n\t\tlist: NewListArea(state.Screen(), AnchorTop, 1, true, state.Styles()),\n\t}\n}\n\n// NewBottomUpLayout creates a new Layout in bottom-up format\nfunc NewBottomUpLayout(state *Peco) *BasicLayout {\n\treturn &BasicLayout{\n\t\tStatusBar: NewStatusBar(state.Screen(), AnchorBottom, 0+extraOffset, state.Styles()),\n\t\t// The prompt is at the bottom, above the status bar\n\t\tprompt: NewUserPrompt(state.Screen(), AnchorBottom, 1+extraOffset, state.Prompt(), state.Styles()),\n\t\t// The list area is at the bottom, above the prompt\n\t\t// It's displayed in bottom-to-top order\n\t\tlist: NewListArea(state.Screen(), AnchorBottom, 2+extraOffset, false, state.Styles()),\n\t}\n}\n\nfunc (l *BasicLayout) PurgeDisplayCache() {\n\tl.list.purgeDisplayCache()\n}\n\n// CalculatePage calculates which page we're displaying\nfunc (l *BasicLayout) CalculatePage(state *Peco, perPage int) error {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"BasicLayout.Calculate %d\", perPage)\n\t\tdefer g.End()\n\t}\n\tbuf := state.CurrentLineBuffer()\n\tloc := state.Location()\n\tloc.SetPage((loc.LineNumber() / perPage) + 1)\n\tloc.SetOffset((loc.Page() - 1) * perPage)\n\tloc.SetPerPage(perPage)\n\tloc.SetTotal(buf.Size())\n\n\tif loc.Total() == 0 {\n\t\tloc.SetMaxPage(1)\n\t} else {\n\t\tloc.SetMaxPage((loc.Total() + perPage - 1) / perPage)\n\t}\n\n\tif loc.MaxPage() < loc.Page() {\n\t\tif buf.Size() == 0 {\n\t\t\t// wait for targets\n\t\t\treturn errors.New(\"no targets or query. nothing to do\")\n\t\t}\n\t\tloc.SetLineNumber(loc.Offset())\n\t}\n\n\treturn nil\n}\n\n// DrawPrompt draws the prompt to the terminal\nfunc (l *BasicLayout) DrawPrompt(state *Peco) {\n\tl.prompt.Draw(state)\n}\n\n// DrawScreen draws the entire screen\nfunc (l *BasicLayout) DrawScreen(state *Peco, options *DrawOptions) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"BasicLayout.DrawScreen\")\n\t\tdefer g.End()\n\t}\n\n\tperPage := l.linesPerPage()\n\n\tif err := l.CalculatePage(state, perPage); err != nil {\n\t\treturn\n\t}\n\n\tl.DrawPrompt(state)\n\tl.list.Draw(state, l, perPage, options)\n\n\tif err := l.screen.Flush(); err != nil {\n\t\treturn\n\t}\n}\n\nfunc (l *BasicLayout) linesPerPage() int {\n\t_, height := l.screen.Size()\n\n\t// list area is always the display area - 2 lines for prompt and status\n\treservedLines := 2 + extraOffset\n\tpp := height - reservedLines\n\tif pp < 1 {\n\t\t// This is an error condition, and while we probably should handle this\n\t\t// error more gracefully, the consumers of this method do not really\n\t\t// do anything with this error. I think it's just safe to \"2\", which just\n\t\t// means no space left to draw anything\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\n\t\t\t\t\"linesPerPage is < 1 (height = %d, reservedLines = %d), forcing return value of 2\",\n\t\t\t\theight,\n\t\t\t\treservedLines,\n\t\t\t)\n\t\t}\n\t\treturn 2\n\t}\n\treturn pp\n}\n\n// MovePage scrolls the screen\nfunc (l *BasicLayout) MovePage(state *Peco, p PagingRequest) (moved bool) {\n\tswitch p.Type() {\n\tcase ToScrollLeft, ToScrollRight:\n\t\tmoved = horizontalScroll(state, l, p)\n\tdefault:\n\t\tmoved = verticalScroll(state, l, p)\n\t}\n\treturn\n}\n\n// verticalScroll moves the cursor position vertically\nfunc verticalScroll(state *Peco, l *BasicLayout, p PagingRequest) bool {\n\t// Before we move, on which line were we located?\n\tloc := state.Location()\n\tlineBefore := loc.LineNumber()\n\tlineno := lineBefore\n\n\tif pdebug.Enabled {\n\t\tdefer func() {\n\t\t\tpdebug.Printf(\"currentLine changed from %d -> %d\", lineBefore, state.Location().LineNumber())\n\t\t}()\n\t}\n\n\tbuf := state.CurrentLineBuffer()\n\tlcur := buf.Size()\n\n\tdefer func() {\n\t\tfor _, lno := range []int{lineBefore, loc.LineNumber()} {\n\t\t\tif oldLine, err := buf.LineAt(lno); err == nil {\n\t\t\t\toldLine.SetDirty(true)\n\t\t\t}\n\t\t}\n\t}()\n\n\tlpp := l.linesPerPage()\n\tif l.list.sortTopDown {\n\t\tswitch p.Type() {\n\t\tcase ToLineAbove:\n\t\t\tlineno--\n\t\tcase ToLineBelow:\n\t\t\tlineno++\n\t\tcase ToScrollPageDown:\n\t\t\tlineno += lpp\n\t\t\tif loc.Page() == loc.MaxPage()-1 && lcur < lineno && (lcur-lineBefore) < lpp {\n\t\t\t\tlineno = lcur - 1\n\t\t\t}\n\t\tcase ToScrollPageUp:\n\t\t\tlineno -= lpp\n\t\tcase ToLineInPage:\n\t\t\tlineno = loc.PerPage()*(loc.Page()-1) + p.(JumpToLineRequest).Line()\n\t\tcase ToScrollFirstItem:\n\t\t\tlineno = 0\n\t\tcase ToScrollLastItem:\n\t\t\tlineno = lcur - 1\n\t\t}\n\t} else {\n\t\tswitch p.Type() {\n\t\tcase ToLineAbove:\n\t\t\tlineno++\n\t\tcase ToLineBelow:\n\t\t\tlineno--\n\t\tcase ToScrollPageDown:\n\t\t\tlineno -= lpp\n\t\tcase ToScrollPageUp:\n\t\t\tlineno += lpp\n\t\tcase ToLineInPage:\n\t\t\tlineno = loc.PerPage()*(loc.Page()-1) - p.(JumpToLineRequest).Line()\n\t\t}\n\t}\n\n\tif lineno < 0 {\n\t\tif lcur > 0 {\n\t\t\t// Go to last page, if possible\n\t\t\tlineno = lcur - 1\n\t\t} else {\n\t\t\tlineno = 0\n\t\t}\n\t} else if lcur > 0 && lineno >= lcur {\n\t\tlineno = 0\n\t}\n\n\t// XXX DO NOT RETURN UNTIL YOU SET THE LINE NUMBER HERE\n\tloc.SetLineNumber(lineno)\n\n\t// if we were in range mode, we need to do stuff. otherwise\n\t// just bail out\n\tr := state.SelectionRangeStart()\n\tif !r.Valid() {\n\t\treturn true\n\t}\n\n\tsel := state.Selection()\n\tif l.list.sortTopDown {\n\t\tif loc.LineNumber() < r.Value() {\n\t\t\tfor lineno := loc.LineNumber(); lineno <= r.Value(); lineno++ {\n\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\tsel.Add(line)\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch {\n\t\t\tcase r.Value() <= lineBefore:\n\t\t\t\tfor lineno := r.Value(); lineno <= lcur && lineno < lineBefore; lineno++ {\n\t\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\t\tsel.Remove(line)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase lineBefore < loc.LineNumber():\n\t\t\t\tfor lineno := lineBefore; lineno < loc.LineNumber(); lineno++ {\n\t\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\t\tsel.Remove(line)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor lineno := r.Value(); lineno <= lcur && lineno <= loc.LineNumber(); lineno++ {\n\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\tsel.Add(line)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase lineBefore <= r.Value():\n\t\t\t\tfor lineno := lineBefore; lineno < r.Value(); lineno++ {\n\t\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\t\tsel.Remove(line)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase loc.LineNumber() < lineBefore:\n\t\t\t\tfor lineno := loc.LineNumber(); lineno <= lineBefore; lineno++ {\n\t\t\t\t\tif line, err := buf.LineAt(lineno); err == nil {\n\t\t\t\t\t\tsel.Remove(line)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\n// horizontalScroll scrolls screen horizontal\nfunc horizontalScroll(state *Peco, l *BasicLayout, p PagingRequest) bool {\n\twidth, _ := state.screen.Size()\n\tloc := state.Location()\n\tif p.Type() == ToScrollRight {\n\t\tloc.SetColumn(loc.Column() + width/2)\n\t} else if loc.Column() > 0 {\n\t\tloc.SetColumn(loc.Column() - width/2)\n\t\tif loc.Column() < 0 {\n\t\t\tloc.SetColumn(0)\n\t\t}\n\t} else {\n\t\treturn false\n\t}\n\n\tl.list.SetDirty(true)\n\n\treturn true\n}\n"
        },
        {
          "name": "layout_test.go",
          "type": "blob",
          "size": 2.9013671875,
          "content": "package peco\n\nimport (\n\t\"testing\"\n\t\"unicode/utf8\"\n\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/nsf/termbox-go\"\n)\n\nfunc TestLayoutType(t *testing.T) {\n\tlayouts := []struct {\n\t\tvalue    LayoutType\n\t\texpectOK bool\n\t}{\n\t\t{LayoutTypeTopDown, true},\n\t\t{LayoutTypeBottomUp, true},\n\t\t{\"foobar\", false},\n\t}\n\tfor _, l := range layouts {\n\t\tvalid := IsValidLayoutType(l.value)\n\t\tif valid != l.expectOK {\n\t\t\tt.Errorf(\"LayoutType %s, expected IsValidLayoutType to return %t, but got %t\",\n\t\t\t\tl.value,\n\t\t\t\tl.expectOK,\n\t\t\t\tvalid,\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestPrintScreen(t *testing.T) {\n\tscreen := NewDummyScreen()\n\n\tmakeVerifier := func(initX, initY int, fill bool) func(string) {\n\t\treturn func(msg string) {\n\t\t\tscreen.interceptor.reset()\n\t\t\tt.Logf(\"Checking printScreen(%d, %d, %s, %t)\", initX, initY, msg, fill)\n\t\t\twidth := utf8.RuneCountInString(msg)\n\t\t\tscreen.Print(PrintArgs{\n\t\t\t\tX:    initX,\n\t\t\t\tY:    initY,\n\t\t\t\tFg:   termbox.ColorDefault,\n\t\t\t\tBg:   termbox.ColorDefault,\n\t\t\t\tMsg:  msg,\n\t\t\t\tFill: fill,\n\t\t\t})\n\t\t\tevents := screen.interceptor.events[\"SetCell\"]\n\t\t\tif !fill {\n\t\t\t\tif len(events) != width {\n\t\t\t\t\tt.Errorf(\"Expected %d SetCell events, got %d\",\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tlen(events),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// fill == true\n\t\t\tw, _ := screen.Size()\n\t\t\tif rw := runewidth.StringWidth(msg); rw != width {\n\t\t\t\tw -= rw - width\n\t\t\t}\n\t\t\tif len(events) != w {\n\t\t\t\tt.Errorf(\"Expected %d SetCell events, got %d\",\n\t\t\t\t\tw,\n\t\t\t\t\tlen(events),\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tverify := makeVerifier(0, 0, false)\n\tverify(\"Hello, World!\")\n\tverify(\"日本語\")\n\n\tverify = makeVerifier(0, 0, true)\n\tverify(\"Hello, World!\")\n\tverify(\"日本語\")\n}\n\nfunc TestStatusBar(t *testing.T) {\n\tscreen := NewDummyScreen()\n\tst := NewStatusBar(screen, AnchorBottom, 0, NewStyleSet())\n\tst.PrintStatus(\"Hello, World!\", 0)\n\n\tevents := screen.interceptor.events\n\tif l := len(events[\"Flush\"]); l != 1 {\n\t\tt.Errorf(\"Expected 1 Flush event, got %d\", l)\n\t\treturn\n\t}\n}\n\nfunc TestMergeAttribute(t *testing.T) {\n\tcolors := stringToFg\n\n\t// merge colors\n\ttests := [][]string{\n\t\t{\"red\", \"green\", \"yellow\"},\n\t\t{\"red\", \"blue\", \"magenta\"},\n\t\t{\"green\", \"blue\", \"cyan\"},\n\t\t{\"yellow\", \"blue\", \"white\"},\n\t\t{\"magenta\", \"green\", \"white\"},\n\t\t{\"cyan\", \"red\", \"white\"},\n\t\t{\"yellow\", \"magenta\", \"white\"},\n\t\t{\"magenta\", \"cyan\", \"white\"},\n\t\t{\"cyan\", \"yellow\", \"white\"},\n\t}\n\n\tfor _, c := range tests {\n\t\tif m := mergeAttribute(colors[c[0]], colors[c[1]]); m != colors[c[2]] {\n\t\t\tt.Errorf(\"(%s + %s) expected %d(%s), got %d\", c[0], c[1], colors[c[2]], c[2], m)\n\t\t}\n\t}\n\n\t// merge with white\n\tfor _, c := range colors {\n\t\tif m := mergeAttribute(c, colors[\"white\"]); m != colors[\"white\"] {\n\t\t\tt.Errorf(\"expected white(%d), got %d\", colors[\"white\"], m)\n\t\t}\n\t}\n\n\t// merge attributes\n\tif m := mergeAttribute(termbox.AttrBold|colors[\"red\"], termbox.AttrUnderline|colors[\"cyan\"]); m != termbox.AttrBold|termbox.AttrUnderline|colors[\"white\"] {\n\t\tt.Errorf(\"expected %d, got %d\", termbox.AttrBold|termbox.AttrUnderline|colors[\"white\"], m)\n\t}\n\n}\n"
        },
        {
          "name": "layout_windows.go",
          "type": "blob",
          "size": 0.1337890625,
          "content": "package peco\n\nfunc init() {\n\t// This is the value we pass to anchor offset when we're running\n\t// on windows platform\n\textraOffset = 1\n}\n"
        },
        {
          "name": "line",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 1.8046875,
          "content": "package peco\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/jessevdk/go-flags\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc (options *CLIOptions) parse(s []string) ([]string, error) {\n\tp := flags.NewParser(options, flags.PrintErrors)\n\targs, err := p.ParseArgs(s)\n\tif err != nil {\n\t\tos.Stderr.Write(options.help())\n\t\treturn nil, errors.Wrap(err, \"invalid command line options\")\n\t}\n\n\tif err := options.Validate(); err != nil {\n\t\treturn nil, errors.Wrap(err, \"invalid command line arguments\")\n\t}\n\n\treturn args, nil\n}\n\nfunc (options CLIOptions) Validate() error {\n\tif options.OptLayout != \"\" {\n\t\tif !IsValidLayoutType(LayoutType(options.OptLayout)) {\n\t\t\treturn errors.New(\"unknown layout: '\" + options.OptLayout + \"'\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (options CLIOptions) help() []byte {\n\tbuf := bytes.Buffer{}\n\n\tfmt.Fprintf(&buf, `\nUsage: peco [options] [FILE]\n\nOptions:\n`)\n\n\tt := reflect.TypeOf(options)\n\tfor i := 0; i < t.NumField(); i++ {\n\t\ttag := t.Field(i).Tag\n\n\t\tvar o string\n\t\tif s := tag.Get(\"short\"); s != \"\" {\n\t\t\to = fmt.Sprintf(\"-%s, --%s\", tag.Get(\"short\"), tag.Get(\"long\"))\n\t\t} else {\n\t\t\to = fmt.Sprintf(\"--%s\", tag.Get(\"long\"))\n\t\t}\n\n\t\t// if multiline, we need to indent the proceeding lines\n\t\tdesc := tag.Get(\"description\")\n\t\tif i := strings.Index(desc, \"\\n\"); i >= 0 {\n\t\t\t// first line does not need indenting, so get that out of the way\n\t\t\tvar buf bytes.Buffer\n\t\t\tbuf.WriteString(desc[:i+1])\n\t\t\tdesc = desc[i+1:]\n\t\t\tconst indent = \"                        \"\n\t\t\tfor {\n\t\t\t\tif i = strings.Index(desc, \"\\n\"); i >= 0 {\n\t\t\t\t\tbuf.WriteString(indent)\n\t\t\t\t\tbuf.WriteString(desc[:i+1])\n\t\t\t\t\tdesc = desc[i+1:]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif len(desc) > 0 {\n\t\t\t\tbuf.WriteString(indent)\n\t\t\t\tbuf.WriteString(desc)\n\t\t\t}\n\t\t\tdesc = buf.String()\n\t\t}\n\n\t\tfmt.Fprintf(\n\t\t\t&buf,\n\t\t\t\"  %-21s %s\\n\",\n\t\t\to,\n\t\t\tdesc,\n\t\t)\n\t}\n\n\treturn buf.Bytes()\n}\n"
        },
        {
          "name": "page.go",
          "type": "blob",
          "size": 1.048828125,
          "content": "package peco\n\nfunc (l *Location) SetColumn(n int) {\n\tl.col = n\n}\n\nfunc (l Location) Column() int {\n\treturn l.col\n}\n\nfunc (l *Location) SetLineNumber(n int) {\n\tl.lineno = n\n}\n\nfunc (l Location) LineNumber() int {\n\treturn l.lineno\n}\n\nfunc (l *Location) SetOffset(n int) {\n\tl.offset = n\n}\n\nfunc (l Location) Offset() int {\n\treturn l.offset\n}\n\nfunc (l *Location) SetPerPage(n int) {\n\tl.perPage = n\n}\n\nfunc (l Location) PerPage() int {\n\treturn l.perPage\n}\n\nfunc (l *Location) SetPage(n int) {\n\tl.page = n\n}\n\nfunc (l Location) Page() int {\n\treturn l.page\n}\n\nfunc (l *Location) SetTotal(n int) {\n\tl.total = n\n}\n\nfunc (l Location) Total() int {\n\treturn l.total\n}\n\nfunc (l *Location) SetMaxPage(n int) {\n\tl.maxPage = n\n}\n\nfunc (l Location) MaxPage() int {\n\treturn l.maxPage\n}\n\nfunc (l Location) PageCrop() PageCrop {\n\treturn PageCrop{\n\t\tperPage:     l.perPage,\n\t\tcurrentPage: l.page,\n\t}\n}\n\n// Crop returns a new Buffer whose contents are\n// bound within the given range\nfunc (pf PageCrop) Crop(in Buffer) *FilteredBuffer {\n\treturn NewFilteredBuffer(in, pf.currentPage, pf.perPage)\n}\n"
        },
        {
          "name": "peco.go",
          "type": "blob",
          "size": 17.8046875,
          "content": "//go:generate stringer -type PagingRequestType -output stringer_paging_request_type.go .\n//go:generate stringer -type VerticalAnchor    -output stringer_vertical_anchor.go     .\n\npackage peco\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"context\"\n\n\t\"github.com/google/btree\"\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/peco/peco/filter\"\n\t\"github.com/peco/peco/hub\"\n\t\"github.com/peco/peco/internal/util\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/peco/peco/pipeline\"\n\t\"github.com/peco/peco/sig\"\n\t\"github.com/pkg/errors\"\n)\n\nconst version = \"v0.5.11\"\n\ntype errIgnorable struct {\n\terr error\n}\n\nfunc (e errIgnorable) Ignorable() bool { return true }\nfunc (e errIgnorable) Cause() error {\n\treturn e.err\n}\nfunc (e errIgnorable) Error() string {\n\treturn e.err.Error()\n}\nfunc makeIgnorable(err error) error {\n\treturn &errIgnorable{err: err}\n}\n\ntype errWithExitStatus struct {\n\terr    error\n\tstatus int\n}\n\nfunc (e errWithExitStatus) Error() string {\n\treturn e.err.Error()\n}\nfunc (e errWithExitStatus) Cause() error {\n\treturn e.err\n}\nfunc (e errWithExitStatus) ExitStatus() int {\n\treturn e.status\n}\n\nfunc setExitStatus(err error, status int) error {\n\treturn &errWithExitStatus{err: err, status: status}\n}\n\n// Inputseq is a list of keys that the user typed\ntype Inputseq []string\n\nfunc (is *Inputseq) Add(s string) {\n\t*is = append(*is, s)\n}\n\nfunc (is Inputseq) KeyNames() []string {\n\treturn is\n}\n\nfunc (is Inputseq) Len() int {\n\treturn len(is)\n}\n\nfunc (is *Inputseq) Reset() {\n\t*is = []string(nil)\n}\n\nfunc newIDGen() *idgen {\n\treturn &idgen{\n\t\tch: make(chan uint64),\n\t}\n}\n\nfunc (ig *idgen) Run(ctx context.Context) {\n\tvar i uint64\n\tfor ; ; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase ig.ch <- i:\n\t\t}\n\n\t\tif i >= uint64(1<<63)-1 {\n\t\t\t// If this happens, it's a disaster, but what can we do...\n\t\t\ti = 0\n\t\t}\n\t}\n}\n\nfunc (ig *idgen) Next() uint64 {\n\treturn <-ig.ch\n}\n\nfunc New() *Peco {\n\treturn &Peco{\n\t\tArgv:              os.Args,\n\t\tStderr:            os.Stderr,\n\t\tStdin:             os.Stdin,\n\t\tStdout:            os.Stdout,\n\t\tcurrentLineBuffer: NewMemoryBuffer(), // XXX revisit this\n\t\tidgen:             newIDGen(),\n\t\tqueryExecDelay:    50 * time.Millisecond,\n\t\treadyCh:           make(chan struct{}),\n\t\tscreen:            NewTermbox(),\n\t\tselection:         NewSelection(),\n\t\tmaxScanBufferSize: bufio.MaxScanTokenSize,\n\t}\n}\n\nfunc (p *Peco) Ready() <-chan struct{} {\n\treturn p.readyCh\n}\n\nfunc (p *Peco) Screen() Screen {\n\treturn p.screen\n}\n\nfunc (p *Peco) Styles() *StyleSet {\n\treturn &p.styles\n}\n\nfunc (p *Peco) Use256Color() bool {\n\treturn p.use256Color\n}\n\nfunc (p *Peco) Prompt() string {\n\treturn p.prompt\n}\n\nfunc (p *Peco) Inputseq() *Inputseq {\n\treturn &p.inputseq\n}\n\nfunc (p *Peco) LayoutType() string {\n\treturn p.layoutType\n}\n\nfunc (p *Peco) Location() *Location {\n\treturn &p.location\n}\n\nfunc (p *Peco) ResultCh() chan line.Line {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\treturn p.resultCh\n}\n\nfunc (p *Peco) SetResultCh(ch chan line.Line) {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\tp.resultCh = ch\n}\n\nfunc (p *Peco) Selection() *Selection {\n\treturn p.selection\n}\n\nfunc (s RangeStart) Valid() bool {\n\treturn s.valid\n}\n\nfunc (s RangeStart) Value() int {\n\treturn s.val\n}\n\nfunc (s *RangeStart) SetValue(n int) {\n\ts.val = n\n\ts.valid = true\n}\n\nfunc (s *RangeStart) Reset() {\n\ts.valid = false\n}\n\nfunc (p *Peco) SelectionRangeStart() *RangeStart {\n\treturn &p.selectionRangeStart\n}\n\nfunc (p *Peco) SingleKeyJumpShowPrefix() bool {\n\treturn p.singleKeyJumpShowPrefix\n}\n\nfunc (p *Peco) SingleKeyJumpPrefixes() []rune {\n\treturn p.singleKeyJumpPrefixes\n}\n\nfunc (p *Peco) SingleKeyJumpMode() bool {\n\treturn p.singleKeyJumpMode\n}\n\nfunc (p *Peco) SetSingleKeyJumpMode(b bool) {\n\tp.singleKeyJumpMode = b\n}\n\nfunc (p *Peco) ToggleSingleKeyJumpMode() {\n\tp.singleKeyJumpMode = !p.singleKeyJumpMode\n\tgo p.Hub().SendDraw(context.Background(), &DrawOptions{DisableCache: true})\n}\n\nfunc (p *Peco) SingleKeyJumpIndex(ch rune) (uint, bool) {\n\tn, ok := p.singleKeyJumpPrefixMap[ch]\n\treturn n, ok\n}\n\nfunc (p *Peco) Source() pipeline.Source {\n\treturn p.source\n}\n\nfunc (p *Peco) Filters() *filter.Set {\n\treturn &p.filters\n}\n\nfunc (p *Peco) Query() *Query {\n\treturn &p.query\n}\n\nfunc (p *Peco) QueryExecDelay() time.Duration {\n\treturn p.queryExecDelay\n}\n\nfunc (p *Peco) Caret() *Caret {\n\treturn &p.caret\n}\n\nfunc (p *Peco) Hub() MessageHub {\n\treturn p.hub\n}\n\nfunc (p *Peco) Err() error {\n\treturn p.err\n}\n\nfunc (p *Peco) Exit(err error) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.Exit (err = %s)\", err)\n\t\tdefer g.End()\n\t}\n\tp.err = err\n\tif cf := p.cancelFunc; cf != nil {\n\t\tcf()\n\t}\n}\n\nfunc (p *Peco) Keymap() Keymap {\n\treturn p.keymap\n}\n\nfunc (p *Peco) Setup() (err error) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.Setup\").BindError(&err)\n\t\tdefer g.End()\n\t}\n\n\tif err := p.config.Init(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to initialize config\")\n\t}\n\n\tvar opts CLIOptions\n\tif err := p.parseCommandLine(&opts, &p.args, p.Argv); err != nil {\n\t\treturn errors.Wrap(err, \"failed to parse command line\")\n\t}\n\n\t// Read config\n\tif !p.skipReadConfig { // This can only be set via test\n\t\tif err := readConfig(&p.config, opts.OptRcfile); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to setup configuration\")\n\t\t}\n\t}\n\n\t// Take Args, Config, Options, and apply the configuration to\n\t// the peco object\n\tif err := p.ApplyConfig(opts); err != nil {\n\t\treturn errors.Wrap(err, \"failed to apply configuration\")\n\t}\n\n\t// XXX p.Keymap et al should be initialized around here\n\tp.hub = hub.New(5)\n\n\treturn nil\n}\n\nfunc (p *Peco) selectOneAndExitIfPossible() {\n\t// TODO: mutex\n\t// If we have only one line, we just want to bail out\n\t// printing that one line as the result\n\tif b := p.CurrentLineBuffer(); b.Size() == 1 {\n\t\tif l, err := b.LineAt(0); err == nil {\n\t\t\tp.resultCh = make(chan line.Line)\n\t\t\tp.Exit(errCollectResults{})\n\t\t\tp.resultCh <- l\n\t\t\tclose(p.resultCh)\n\t\t}\n\t}\n}\n\nfunc (p *Peco) Run(ctx context.Context) (err error) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.Run\").BindError(&err)\n\t\tdefer g.End()\n\t}\n\n\t// do this only once\n\tvar readyOnce sync.Once\n\tdefer readyOnce.Do(func() { close(p.readyCh) })\n\n\tif err := p.Setup(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to setup peco\")\n\t}\n\n\tvar _cancelOnce sync.Once\n\tvar _cancel func()\n\tctx, _cancel = context.WithCancel(ctx)\n\tcancel := func() {\n\t\t_cancelOnce.Do(func() {\n\t\t\tif pdebug.Enabled {\n\t\t\t\tpdebug.Printf(\"Peco.Run cancel called\")\n\t\t\t}\n\t\t\t_cancel()\n\t\t})\n\t}\n\n\t// start the ID generator\n\tgo p.idgen.Run(ctx)\n\n\t// remember this cancel func so p.Exit works (XXX requires locking?)\n\tp.cancelFunc = cancel\n\n\tsigH := sig.New(sig.SigReceivedHandlerFunc(func(sig os.Signal) {\n\t\tp.Exit(errors.New(\"received signal: \" + sig.String()))\n\t}))\n\n\tgo sigH.Loop(ctx, cancel)\n\n\t// SetupSource is done AFTER other components are ready, otherwise\n\t// we can't draw onto the screen while we are reading a really big\n\t// buffer.\n\t// Setup source buffer\n\tsrc, err := p.SetupSource(ctx)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to setup input source\")\n\t}\n\tp.source = src\n\n\tgo func() {\n\t\t<-p.source.Ready()\n\t\t// screen.Init must be called within Run() because we\n\t\t// want to make sure to call screen.Close() after getting\n\t\t// out of Run()\n\t\tp.screen.Init(&p.config)\n\t\tgo NewInput(p, p.Keymap(), p.screen.PollEvent(ctx, &p.config)).Loop(ctx, cancel)\n\t\tgo NewView(p).Loop(ctx, cancel)\n\t\tgo NewFilter(p).Loop(ctx, cancel)\n\t}()\n\tdefer p.screen.Close()\n\n\tif p.Query().Len() <= 0 {\n\t\t// Re-set the source only if there are no queries\n\t\tp.ResetCurrentLineBuffer()\n\t}\n\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"peco is now ready, go go go!\")\n\t}\n\n\t// If this is enabled, we need to check if we have 1 line only\n\t// in the buffer. If we do, we select that line and bail out\n\tif p.selectOneAndExit {\n\t\tgo func() {\n\t\t\t// Wait till source has read all lines. We should not wait\n\t\t\t// source.Ready(), because Ready returns as soon as we get\n\t\t\t// a line, where as SetupDone waits until we're completely\n\t\t\t// done reading the input\n\t\t\t<-p.source.SetupDone()\n\t\t\tp.selectOneAndExitIfPossible()\n\t\t}()\n\t}\n\n\treadyOnce.Do(func() { close(p.readyCh) })\n\n\t// This has tobe AFTER close(p.readyCh), otherwise the query is\n\t// ignored by us (queries are not run until peco thinks it's ready)\n\tif q := p.initialQuery; q != \"\" {\n\t\tp.Query().Set(q)\n\t\tp.Caret().SetPos(utf8.RuneCountInString(q))\n\t}\n\n\tif p.Query().Len() > 0 {\n\t\tgo func() {\n\t\t\t<-p.source.Ready()\n\n\t\t\t// iff p.selectOneAndExit is true, we should check after exec query is run\n\t\t\t// if we only have one item\n\t\t\tif p.selectOneAndExit {\n\t\t\t\tp.ExecQuery(p.selectOneAndExitIfPossible)\n\t\t\t} else {\n\t\t\t\tp.ExecQuery(nil)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Alright, done everything we need to do automatically. We'll let\n\t// the user play with peco, and when we receive notification to\n\t// bail out, the context should be canceled appropriately\n\t<-ctx.Done()\n\n\t// ...and we return any errors that we might have been informed about.\n\treturn p.Err()\n}\n\nfunc (p *Peco) parseCommandLine(opts *CLIOptions, args *[]string, argv []string) error {\n\tremaining, err := opts.parse(argv)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to parse command line options\")\n\t}\n\n\tif opts.OptHelp {\n\t\tp.Stdout.Write(opts.help())\n\t\treturn makeIgnorable(errors.New(\"user asked to show help message\"))\n\t}\n\n\tif opts.OptVersion {\n\t\tfmt.Fprintf(p.Stdout, \"peco version %s (built with %s)\\n\", version, runtime.Version())\n\t\treturn makeIgnorable(errors.New(\"user asked to show version\"))\n\t}\n\n\tif opts.OptRcfile == \"\" {\n\t\tif file, err := LocateRcfile(locateRcfileIn); err == nil {\n\t\t\topts.OptRcfile = file\n\t\t}\n\t}\n\n\t*args = remaining\n\n\treturn nil\n}\n\nfunc (p *Peco) SetupSource(ctx context.Context) (s *Source, err error) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.SetupSource\").BindError(&err)\n\t\tdefer g.End()\n\t}\n\n\tvar in io.Reader\n\tvar filename string\n\tvar isInfinite bool\n\tswitch {\n\tcase len(p.args) > 1:\n\t\tf, err := os.Open(p.args[1])\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to open file for input\")\n\t\t}\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Using %s as input\", p.args[1])\n\t\t}\n\t\tin = f\n\t\tfilename = p.args[1]\n\tcase !util.IsTty(p.Stdin):\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Using p.Stdin as input\")\n\t\t}\n\t\tin = p.Stdin\n\t\tfilename = `-`\n\t\t// XXX we detect that this is potentially an \"infinite\" source if\n\t\t// the input is coming from Stdin. This is important b/c we need to\n\t\t// know NOT to use batch mode processing when the incoming source\n\t\t// is never-ending\n\t\tisInfinite = true\n\tdefault:\n\t\treturn nil, errors.New(\"you must supply something to work with via filename or stdin\")\n\t}\n\n\tsrc := NewSource(filename, in, isInfinite, p.idgen, p.bufferSize, p.enableSep)\n\n\t// Block until we receive something from `in`\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"Blocking until we read something in source...\")\n\t}\n\n\tgo src.Setup(ctx, p)\n\t<-src.Ready()\n\n\treturn src, nil\n}\n\nfunc readConfig(cfg *Config, filename string) error {\n\tif filename != \"\" {\n\t\tif err := cfg.ReadFilename(filename); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to read config file\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Peco) ApplyConfig(opts CLIOptions) error {\n\t// If layoutType is not set and is set in the config, set it\n\tif p.layoutType == \"\" {\n\t\tif v := p.config.Layout; v != \"\" {\n\t\t\tp.layoutType = v\n\t\t} else {\n\t\t\tp.layoutType = DefaultLayoutType\n\t\t}\n\t}\n\n\tp.maxScanBufferSize = 256\n\tif v := p.config.MaxScanBufferSize; v > 0 {\n\t\tp.maxScanBufferSize = v\n\t}\n\n\tif v := opts.OptExec; len(v) > 0 {\n\t\tp.execOnFinish = v\n\t}\n\n\tp.enableSep = opts.OptEnableNullSep\n\n\tif i := opts.OptInitialIndex; i >= 0 {\n\t\tp.Location().SetLineNumber(i)\n\t}\n\n\tif v := opts.OptLayout; v != \"\" {\n\t\tp.layoutType = v\n\t}\n\n\tp.prompt = p.config.Prompt\n\tif v := opts.OptPrompt; len(v) > 0 {\n\t\tp.prompt = v\n\t} else if v := p.config.Prompt; len(v) > 0 {\n\t\tp.prompt = v\n\t}\n\n\tp.use256Color = p.config.Use256Color\n\n\tp.onCancel = successKey\n\tif opts.OptOnCancel == errorKey || p.config.OnCancel == errorKey {\n\t\tp.onCancel = errorKey\n\t}\n\tp.bufferSize = opts.OptBufferSize\n\tif v := opts.OptSelectionPrefix; len(v) > 0 {\n\t\tp.selectionPrefix = v\n\t} else {\n\t\tp.selectionPrefix = p.config.SelectionPrefix\n\t}\n\tp.selectOneAndExit = opts.OptSelect1\n\tp.printQuery = opts.OptPrintQuery\n\tp.initialQuery = opts.OptQuery\n\tp.initialFilter = opts.OptInitialFilter\n\tif len(p.initialFilter) <= 0 {\n\t\tp.initialFilter = p.config.InitialFilter\n\t}\n\tif len(p.initialFilter) <= 0 {\n\t\tp.initialFilter = opts.OptInitialMatcher\n\t}\n\tp.fuzzyLongestSort = p.config.FuzzyLongestSort\n\n\tif err := p.populateFilters(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to populate filters\")\n\t}\n\n\tif err := p.populateKeymap(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to populate keymap\")\n\t}\n\n\tif err := p.populateStyles(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to populate styles\")\n\t}\n\n\tif err := p.populateInitialFilter(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to populate initial filter\")\n\t}\n\n\tif err := p.populateSingleKeyJump(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to populate single key jump configuration\")\n\t}\n\n\treturn nil\n}\n\nfunc (p *Peco) populateInitialFilter() error {\n\tif v := p.initialFilter; len(v) > 0 {\n\t\tif err := p.filters.SetCurrentByName(v); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to set filter\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Peco) populateSingleKeyJump() error {\n\tp.singleKeyJumpShowPrefix = p.config.SingleKeyJump.ShowPrefix\n\n\tjumpMap := make(map[rune]uint)\n\tchrs := \"asdfghjklzxcvbnmqwertyuiop\"\n\tfor i := 0; i < len(chrs); i++ {\n\t\tjumpMap[rune(chrs[i])] = uint(i)\n\t}\n\tp.singleKeyJumpPrefixMap = jumpMap\n\n\tp.singleKeyJumpPrefixes = make([]rune, len(jumpMap))\n\tfor k, v := range p.singleKeyJumpPrefixMap {\n\t\tp.singleKeyJumpPrefixes[v] = k\n\t}\n\treturn nil\n}\n\nfunc (p *Peco) populateFilters() error {\n\tp.filters.Add(filter.NewIgnoreCase())\n\tp.filters.Add(filter.NewCaseSensitive())\n\tp.filters.Add(filter.NewSmartCase())\n\tp.filters.Add(filter.NewRegexp())\n\tp.filters.Add(filter.NewFuzzy(p.fuzzyLongestSort))\n\n\tfor name, c := range p.config.CustomFilter {\n\t\tf := filter.NewExternalCmd(name, c.Cmd, c.Args, c.BufferThreshold, p.idgen, p.enableSep)\n\t\tp.filters.Add(f)\n\t}\n\n\treturn nil\n}\n\nfunc (p *Peco) populateKeymap() error {\n\t// Create a new keymap object\n\tk := NewKeymap(p.config.Keymap, p.config.Action)\n\tif err := k.ApplyKeybinding(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to apply key bindings\")\n\t}\n\tp.keymap = k\n\treturn nil\n}\n\nfunc (p *Peco) populateStyles() error {\n\tp.styles = p.config.Style\n\treturn nil\n}\n\nfunc (p *Peco) CurrentLineBuffer() Buffer {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\treturn p.currentLineBuffer\n}\n\nfunc (p *Peco) SetCurrentLineBuffer(b Buffer) {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.SetCurrentLineBuffer %s\", reflect.TypeOf(b).String())\n\t\tdefer g.End()\n\t}\n\tp.currentLineBuffer = b\n\tgo p.Hub().SendDraw(context.Background(), nil)\n}\n\nfunc (p *Peco) ResetCurrentLineBuffer() {\n\tp.SetCurrentLineBuffer(p.source)\n}\n\nfunc (p *Peco) sendQuery(ctx context.Context, q string, nextFunc func()) {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"sending query to filter goroutine (q=%v, isInfinite=%t)\", q, p.source.IsInfinite())\n\t\tdefer g.End()\n\t}\n\n\tif p.source.IsInfinite() {\n\t\t// If the source is a stream, we can't do batch mode, and hence\n\t\t// we can't guarantee proper timing. But... okay, we simulate\n\t\t// something like it\n\t\tp.Hub().SendQuery(ctx, q)\n\t\tif nextFunc != nil {\n\t\t\ttime.AfterFunc(time.Second, nextFunc)\n\t\t}\n\t} else {\n\t\t// No delay, execute immediately\n\t\tp.Hub().Batch(context.Background(), func(ctx context.Context) {\n\t\t\tp.Hub().SendQuery(ctx, q)\n\t\t\tif nextFunc != nil {\n\t\t\t\tnextFunc()\n\t\t\t}\n\t\t}, false)\n\t}\n}\n\n// ExecQuery executes the query, taking in consideration things like the\n// exec-delay, and user's multiple successive inputs in a very short span\n//\n// if nextFunc is non-nil, then nextFunc is executed after the query is\n// executed\nfunc (p *Peco) ExecQuery(nextFunc func()) bool {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.ExecQuery\")\n\t\tdefer g.End()\n\t}\n\n\thub := p.Hub()\n\n\tselect {\n\tcase <-p.Ready():\n\tdefault:\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"peco is not ready yet, ignoring.\")\n\t\t}\n\t\treturn false\n\t}\n\n\t// If this is an empty query, reset the display to show\n\t// the raw source buffer\n\tq := p.Query()\n\tif q.Len() <= 0 {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"empty query, reset buffer\")\n\t\t}\n\t\tp.ResetCurrentLineBuffer()\n\n\t\thub.Batch(context.Background(), func(ctx context.Context) {\n\t\t\thub.SendDraw(ctx, &DrawOptions{DisableCache: true})\n\t\t\tif nextFunc != nil {\n\t\t\t\tnextFunc()\n\t\t\t}\n\t\t}, false)\n\t\treturn true\n\t}\n\n\tdelay := p.QueryExecDelay()\n\tif delay <= 0 {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"sending query (immediate)\")\n\t\t}\n\n\t\tp.sendQuery(context.Background(), q.String(), nextFunc)\n\t\treturn true\n\t}\n\n\tp.queryExecMutex.Lock()\n\tdefer p.queryExecMutex.Unlock()\n\n\tif p.queryExecTimer != nil {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"timer is non-nil\")\n\t\t}\n\t\treturn true\n\t}\n\n\t// Wait $delay millisecs before sending the query\n\t// if a new input comes in, batch them up\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"sending query (with delay)\")\n\t}\n\tp.queryExecTimer = time.AfterFunc(delay, func() {\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"delayed query sent\")\n\t\t}\n\t\tp.sendQuery(context.Background(), q.String(), nextFunc)\n\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"delayed query executed\")\n\t\t}\n\n\t\tp.queryExecMutex.Lock()\n\t\tdefer p.queryExecMutex.Unlock()\n\n\t\tp.queryExecTimer = nil\n\t})\n\treturn true\n}\n\nfunc (p *Peco) PrintResults() {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Peco.PrintResults\")\n\t\tdefer g.End()\n\t}\n\tselection := p.Selection()\n\tif selection.Len() == 0 {\n\t\tif l, err := p.CurrentLineBuffer().LineAt(p.Location().LineNumber()); err == nil {\n\t\t\tselection.Add(l)\n\t\t}\n\t}\n\tp.SetResultCh(make(chan line.Line))\n\tgo func() {\n\t\tdefer close(p.resultCh)\n\t\tp.selection.Ascend(func(it btree.Item) bool {\n\t\t\tp.ResultCh() <- it.(line.Line)\n\t\t\treturn true\n\t\t})\n\t}()\n\n\tvar buf bytes.Buffer\n\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"--print-query was %t\", p.printQuery)\n\t}\n\tif p.printQuery {\n\t\tbuf.WriteString(p.Query().String())\n\t\tbuf.WriteByte('\\n')\n\t}\n\tfor line := range p.ResultCh() {\n\t\tbuf.WriteString(line.Output())\n\t\tbuf.WriteByte('\\n')\n\t}\n\tp.Stdout.Write(buf.Bytes())\n}\n"
        },
        {
          "name": "peco_test.go",
          "type": "blob",
          "size": 11.46875,
          "content": "package peco\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/peco/peco/hub\"\n\t\"github.com/peco/peco/internal/util\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype nullHub struct{}\n\nfunc (h nullHub) Batch(_ context.Context, _ func(context.Context), _ bool)           {}\nfunc (h nullHub) DrawCh() chan hub.Payload                                           { return nil }\nfunc (h nullHub) PagingCh() chan hub.Payload                                         { return nil }\nfunc (h nullHub) QueryCh() chan hub.Payload                                          { return nil }\nfunc (h nullHub) SendDraw(_ context.Context, _ interface{})                          {}\nfunc (h nullHub) SendDrawPrompt(context.Context)                                     {}\nfunc (h nullHub) SendPaging(_ context.Context, _ interface{})                        {}\nfunc (h nullHub) SendQuery(_ context.Context, _ string)                              {}\nfunc (h nullHub) SendStatusMsg(_ context.Context, _ string)                          {}\nfunc (h nullHub) SendStatusMsgAndClear(_ context.Context, _ string, _ time.Duration) {}\nfunc (h nullHub) StatusMsgCh() chan hub.Payload                                      { return nil }\n\ntype interceptorArgs []interface{}\ntype interceptor struct {\n\tm      sync.Mutex\n\tevents map[string][]interceptorArgs\n}\n\nfunc newInterceptor() *interceptor {\n\treturn &interceptor{\n\t\tevents: make(map[string][]interceptorArgs),\n\t}\n}\n\nfunc (i *interceptor) reset() {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\n\ti.events = make(map[string][]interceptorArgs)\n}\n\nfunc (i *interceptor) record(name string, args []interface{}) {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\n\tevents := i.events\n\tv, ok := events[name]\n\tif !ok {\n\t\tv = []interceptorArgs{}\n\t}\n\n\tevents[name] = append(v, interceptorArgs(args))\n}\n\nfunc newConfig(s string) (string, error) {\n\tf, err := ioutil.TempFile(\"\", \"peco-test-config-\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tio.WriteString(f, s)\n\tf.Close()\n\treturn f.Name(), nil\n}\n\nfunc newPeco() *Peco {\n\t_, file, _, _ := runtime.Caller(0)\n\tstate := New()\n\tstate.Argv = []string{\"peco\", file}\n\tstate.screen = NewDummyScreen()\n\tstate.skipReadConfig = true\n\treturn state\n}\n\ntype dummyScreen struct {\n\t*interceptor\n\twidth  int\n\theight int\n\tpollCh chan termbox.Event\n}\n\nfunc NewDummyScreen() *dummyScreen {\n\treturn &dummyScreen{\n\t\tinterceptor: newInterceptor(),\n\t\twidth:       80,\n\t\theight:      10,\n\t\tpollCh:      make(chan termbox.Event),\n\t}\n}\n\nfunc (d dummyScreen) SetCursor(_, _ int) {\n}\n\nfunc (d dummyScreen) Init(cfg *Config) error {\n\treturn nil\n}\n\nfunc (d dummyScreen) Close() error {\n\treturn nil\n}\n\nfunc (d dummyScreen) Print(args PrintArgs) int {\n\treturn screenPrint(d, args)\n}\n\nfunc (d dummyScreen) SendEvent(e termbox.Event) {\n\t// XXX FIXME SendEvent should receive a context\n\tt := time.NewTimer(time.Second)\n\tdefer t.Stop()\n\tselect {\n\tcase <-t.C:\n\t\tpanic(\"timed out sending an event\")\n\tcase d.pollCh <- e:\n\t}\n}\n\nfunc (d dummyScreen) SetCell(x, y int, ch rune, fg, bg termbox.Attribute) {\n\td.record(\"SetCell\", interceptorArgs{x, y, ch, fg, bg})\n}\nfunc (d dummyScreen) Flush() error {\n\td.record(\"Flush\", interceptorArgs{})\n\treturn nil\n}\nfunc (d dummyScreen) PollEvent(ctx context.Context, cfg *Config) chan termbox.Event {\n\treturn d.pollCh\n}\nfunc (d dummyScreen) Size() (int, int) {\n\treturn d.width, d.height\n}\nfunc (d dummyScreen) Resume()  {}\nfunc (d dummyScreen) Suspend() {}\n\nfunc TestIDGen(t *testing.T) {\n\tidgen := newIDGen()\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tgo idgen.Run(ctx)\n\n\tlines := []*line.Raw{}\n\tfor i := 0; i < 1000000; i++ {\n\t\tlines = append(lines, line.NewRaw(idgen.Next(), fmt.Sprintf(\"%d\", i), false))\n\t}\n\n\tsel := NewSelection()\n\tfor _, l := range lines {\n\t\tif sel.Has(l) {\n\t\t\tt.Errorf(\"Collision detected %d\", l.ID())\n\t\t}\n\t\tsel.Add(l)\n\t}\n}\n\nfunc TestPeco(t *testing.T) {\n\tp := newPeco()\n\tctx, cancel := context.WithCancel(context.Background())\n\ttime.AfterFunc(time.Second, cancel)\n\tif !assert.NoError(t, p.Run(ctx), \"p.Run() succeeds\") {\n\t\treturn\n\t}\n}\n\ntype testCauser interface {\n\tCause() error\n}\ntype testIgnorableError interface {\n\tIgnorable() bool\n}\n\nfunc TestPecoHelp(t *testing.T) {\n\tp := newPeco()\n\tp.Argv = []string{\"peco\", \"-h\"}\n\tp.Stdout = &bytes.Buffer{}\n\tctx, cancel := context.WithCancel(context.Background())\n\ttime.AfterFunc(time.Second, cancel)\n\n\terr := p.Run(ctx)\n\tif !assert.True(t, util.IsIgnorableError(err), \"p.Run() should return error with Ignorable() method, and it should return true\") {\n\t\treturn\n\t}\n}\n\nfunc TestGHIssue331(t *testing.T) {\n\t// Note: we should check that the drawing process did not\n\t// use cached display, but ATM this seemed hard to do,\n\t// so we just check that the proper fields were populated\n\t// when peco was instantiated\n\tctx, cancel := context.WithCancel(context.Background())\n\ttime.AfterFunc(time.Second, cancel)\n\n\tp := newPeco()\n\tp.Run(ctx)\n\n\tif !assert.NotEmpty(t, p.singleKeyJumpPrefixes, \"singleKeyJumpPrefixes is not empty\") {\n\t\treturn\n\t}\n\tif !assert.NotEmpty(t, p.singleKeyJumpPrefixMap, \"singleKeyJumpPrefixMap is not empty\") {\n\t\treturn\n\t}\n}\n\nfunc TestConfigFuzzyFilter(t *testing.T) {\n\tvar opts CLIOptions\n\tp := newPeco()\n\n\t// Ensure that it's possible to enable the Fuzzy filter\n\topts.OptInitialFilter = \"Fuzzy\"\n\tif !assert.NoError(t, p.ApplyConfig(opts), \"p.ApplyConfig should succeed\") {\n\t\treturn\n\t}\n}\n\nfunc TestApplyConfig(t *testing.T) {\n\t// XXX We should add all the possible configurations that needs to be\n\t// propagated to Peco from config\n\n\t// This is a placeholder test address\n\t// https://github.com/peco/peco/pull/338#issuecomment-244462220\n\tvar opts CLIOptions\n\n\topts.OptPrompt = \"tpmorp>\"\n\topts.OptQuery = \"Hello, World\"\n\topts.OptBufferSize = 256\n\topts.OptInitialIndex = 2\n\topts.OptInitialFilter = \"Regexp\"\n\topts.OptLayout = \"bottom-up\"\n\topts.OptSelect1 = true\n\topts.OptOnCancel = \"error\"\n\topts.OptSelectionPrefix = \">\"\n\topts.OptPrintQuery = true\n\n\tp := newPeco()\n\tif !assert.NoError(t, p.ApplyConfig(opts), \"p.ApplyConfig should succeed\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptQuery, p.initialQuery, \"p.initialQuery should be equal to opts.Query\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptBufferSize, p.bufferSize, \"p.bufferSize should be equal to opts.BufferSize\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptEnableNullSep, p.enableSep, \"p.enableSep should be equal to opts.OptEnableNullSep\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptInitialIndex, p.Location().LineNumber(), \"p.Location().LineNumber() should be equal to opts.OptInitialIndex\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptInitialFilter, p.filters.Current().String(), \"p.initialFilter should be equal to opts.OptInitialFilter\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptPrompt, p.prompt, \"p.prompt should be equal to opts.OptPrompt\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptLayout, p.layoutType, \"p.layoutType should be equal to opts.OptLayout\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptSelect1, p.selectOneAndExit, \"p.selectOneAndExit should be equal to opts.OptSelect1\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptOnCancel, p.onCancel, \"p.onCancel should be equal to opts.OptOnCancel\") {\n\t\treturn\n\t}\n\n\tif !assert.Equal(t, opts.OptSelectionPrefix, p.selectionPrefix, \"p.selectionPrefix should be equal to opts.OptSelectionPrefix\") {\n\t\treturn\n\t}\n\tif !assert.Equal(t, opts.OptPrintQuery, p.printQuery, \"p.printQuery should be equal to opts.OptPrintQuery\") {\n\t\treturn\n\t}\n}\n\n// While this issue is labeled for Issue363, it tests against 376 as well.\n// The test should have caught the bug for 376, but the premise of the test\n// itself was wrong\nfunc TestGHIssue363(t *testing.T) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tp := newPeco()\n\tp.Argv = []string{\"--select-1\"}\n\tp.Stdin = bytes.NewBufferString(\"foo\\n\")\n\tvar out bytes.Buffer\n\tp.Stdout = &out\n\n\tresultCh := make(chan error)\n\tgo func() {\n\t\tdefer close(resultCh)\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase resultCh <- p.Run(ctx):\n\t\t\treturn\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tt.Errorf(\"timeout reached\")\n\t\treturn\n\tcase err := <-resultCh:\n\t\tif !assert.True(t, util.IsCollectResultsError(err), \"isCollectResultsError\") {\n\t\t\treturn\n\t\t}\n\t\tp.PrintResults()\n\t}\n\n\tif !assert.Equal(t, \"foo\\n\", out.String(), \"output should match\") {\n\t\treturn\n\t}\n}\n\ntype readerFunc func([]byte) (int, error)\n\nfunc (f readerFunc) Read(p []byte) (int, error) {\n\treturn f(p)\n}\n\nfunc TestGHIssue367(t *testing.T) {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tp := newPeco()\n\tp.Argv = []string{}\n\tsrc := [][]byte{\n\t\t[]byte(\"foo\\n\"),\n\t\t[]byte(\"bar\\n\"),\n\t}\n\tac := time.After(50 * time.Millisecond)\n\tp.Stdin = readerFunc(func(p []byte) (int, error) {\n\t\tif ac != nil {\n\t\t\t<-ac\n\t\t\tac = nil\n\t\t}\n\n\t\tif len(src) == 0 {\n\t\t\treturn 0, io.EOF\n\t\t}\n\n\t\tl := len(src[0])\n\t\tcopy(p, src[0])\n\t\tp = p[:l]\n\t\tsrc = src[1:]\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"reader func returning %#v\", string(p))\n\t\t}\n\t\treturn l, nil\n\t})\n\tbuf := bytes.Buffer{}\n\tp.Stdout = &buf\n\n\twaitCh := make(chan struct{})\n\tgo func() {\n\t\tdefer close(waitCh)\n\t\tp.Run(ctx)\n\t}()\n\n\tselect {\n\tcase <-time.After(100 * time.Millisecond):\n\t\tp.screen.SendEvent(termbox.Event{Ch: 'b'})\n\tcase <-time.After(200 * time.Millisecond):\n\t\tp.screen.SendEvent(termbox.Event{Ch: 'a'})\n\tcase <-time.After(300 * time.Millisecond):\n\t\tp.screen.SendEvent(termbox.Event{Ch: 'r'})\n\tcase <-time.After(900 * time.Millisecond):\n\t\tp.screen.SendEvent(termbox.Event{Key: termbox.KeyEnter})\n\t}\n\n\t<-waitCh\n\n\tp.PrintResults()\n\n\tcurbuf := p.CurrentLineBuffer()\n\n\tif !assert.Equal(t, curbuf.Size(), 1, \"There should be one element in buffer\") {\n\t\treturn\n\t}\n\n\tfor i := 0; i < curbuf.Size(); i++ {\n\t\t_, err := curbuf.LineAt(i)\n\t\tif !assert.NoError(t, err, \"LineAt(%d) should succeed\", i) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !assert.Equal(t, \"bar\\n\", buf.String(), \"output should match\") {\n\t\treturn\n\t}\n}\n\nfunc TestPrintQuery(t *testing.T) {\n\tt.Run(\"Match and print query\", func(t *testing.T) {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tp := newPeco()\n\t\tp.Argv = []string{\"--print-query\", \"--query\", \"oo\", \"--select-1\"}\n\t\tp.Stdin = bytes.NewBufferString(\"foo\\n\")\n\t\tvar out bytes.Buffer\n\t\tp.Stdout = &out\n\n\t\tresultCh := make(chan error)\n\t\tgo func() {\n\t\t\tdefer close(resultCh)\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase resultCh <- p.Run(ctx):\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tt.Errorf(\"timeout reached\")\n\t\t\treturn\n\t\tcase err := <-resultCh:\n\t\t\tif !assert.True(t, util.IsCollectResultsError(err), \"isCollectResultsError\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.PrintResults()\n\t\t}\n\n\t\tif !assert.Equal(t, \"oo\\nfoo\\n\", out.String(), \"output should match\") {\n\t\t\treturn\n\t\t}\n\t})\n\tt.Run(\"No match and print query\", func(t *testing.T) {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\tp := newPeco()\n\t\tp.Argv = []string{\"--print-query\", \"--query\", \"oo\"}\n\t\tp.Stdin = bytes.NewBufferString(\"bar\\n\")\n\t\tvar out bytes.Buffer\n\t\tp.Stdout = &out\n\n\t\tresultCh := make(chan error)\n\t\tgo func() {\n\t\t\tdefer close(resultCh)\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase resultCh <- p.Run(ctx):\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\n\t\t<-p.Ready()\n\n\t\ttime.AfterFunc(100*time.Millisecond, func() {\n\t\t\tp.screen.SendEvent(termbox.Event{Key: termbox.KeyEnter})\n\t\t})\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tt.Errorf(\"timeout reached\")\n\t\t\treturn\n\t\tcase err := <-resultCh:\n\t\t\tif !assert.True(t, util.IsCollectResultsError(err), \"isCollectResultsError\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.PrintResults()\n\t\t}\n\n\t\tif !assert.Equal(t, \"oo\\n\", out.String(), \"output should match\") {\n\t\t\treturn\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "pipeline",
          "type": "tree",
          "content": null
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 1.791015625,
          "content": "package peco\n\nfunc (q *Query) Set(s string) {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tq.query = []rune(s)\n}\n\nfunc (q *Query) Reset() {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tq.query = []rune(nil)\n}\n\nfunc (q *Query) RestoreSavedQuery() {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tq.query = q.savedQuery\n\tq.query = []rune(nil)\n}\n\nfunc (q *Query) SaveQuery() {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tq.savedQuery = q.query\n\tq.savedQuery = []rune(nil)\n}\n\nfunc (q *Query) DeleteRange(start, end int) {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tif start == -1 {\n\t\treturn\n\t}\n\n\tl := len(q.query)\n\tif end > l {\n\t\tend = l\n\t}\n\n\tif start > end {\n\t\treturn\n\t}\n\n\t// everything up to \"start\" is left in tact\n\t// everything between start <-> end is deleted\n\t// everything up to \"start\" is left in tact\n\t// everything between start <-> end is deleted\n\tcopy(q.query[start:], q.query[end:])\n\tq.query = q.query[:l-(end-start)]\n}\n\nfunc (q *Query) String() string {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\treturn string(q.query)\n}\n\nfunc (q *Query) Len() int {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\treturn len(q.query)\n}\n\n// Runes returns a channel that gives you the list of runes in the query\nfunc (q *Query) Runes() <-chan rune {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\tc := make(chan rune, len(q.query))\n\n\tgo func() {\n\t\tdefer close(c)\n\t\tq.mutex.Lock()\n\t\tdefer q.mutex.Unlock()\n\n\t\tfor _, r := range q.query {\n\t\t\tc <- r\n\t\t}\n\t}()\n\n\treturn c\n}\n\nfunc (q *Query) RuneAt(where int) rune {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\treturn q.query[where]\n}\n\nfunc (q *Query) InsertAt(ch rune, where int) {\n\tq.mutex.Lock()\n\tdefer q.mutex.Unlock()\n\n\tif where == len(q.query) {\n\t\tq.query = append(q.query, ch)\n\t\treturn\n\t}\n\n\tsq := q.query\n\tbuf := make([]rune, len(sq)+1)\n\tcopy(buf, sq[:where])\n\tbuf[where] = ch\n\tcopy(buf[where+1:], sq[where:])\n\tq.query = buf\n}\n"
        },
        {
          "name": "screen.go",
          "type": "blob",
          "size": 4.05078125,
          "content": "package peco\n\nimport (\n\t\"context\"\n\t\"unicode/utf8\"\n\n\tpdebug \"github.com/lestrrat-go/pdebug\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/nsf/termbox-go\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc (t *Termbox) Init(cfg *Config) error {\n\tif err := termbox.Init(); err != nil {\n\t\treturn errors.Wrap(err, \"failed to initialized termbox\")\n\t}\n\n\treturn t.PostInit(cfg)\n}\n\nfunc NewTermbox() *Termbox {\n\treturn &Termbox{\n\t\tsuspendCh: make(chan struct{}),\n\t\tresumeCh:  make(chan chan struct{}),\n\t}\n}\n\nfunc (t *Termbox) Close() error {\n\tif pdebug.Enabled {\n\t\tpdebug.Printf(\"Termbox: Close\")\n\t}\n\ttermbox.Interrupt()\n\ttermbox.Close()\n\treturn nil\n}\n\nfunc (t *Termbox) SetCursor(x, y int) {\n\ttermbox.SetCursor(x, y)\n}\n\n// SendEvent is used to allow programmers generate random\n// events, but it's only useful for testing purposes.\n// When interactiving with termbox-go, this method is a noop\nfunc (t *Termbox) SendEvent(_ termbox.Event) {\n\t// no op\n}\n\n// Flush calls termbox.Flush\nfunc (t *Termbox) Flush() error {\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\treturn errors.Wrap(termbox.Flush(), \"failed to flush termbox\")\n}\n\n// PollEvent returns a channel that you can listen to for\n// termbox's events. The actual polling is done in a\n// separate gouroutine\nfunc (t *Termbox) PollEvent(ctx context.Context, cfg *Config) chan termbox.Event {\n\t// XXX termbox.PollEvent() can get stuck on unexpected signal\n\t// handling cases. We still would like to wait until the user\n\t// (termbox) has some event for us to process, but we don't\n\t// want to allow termbox to control/block our input loop.\n\t//\n\t// Solution: put termbox polling in a separate goroutine,\n\t// and we just watch for a channel. The loop can now\n\t// safely be implemented in terms of select {} which is\n\t// safe from being stuck.\n\tevCh := make(chan termbox.Event)\n\n\tgo func() {\n\t\t// keep listening to suspend requests here\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-t.suspendCh:\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"poll event suspended!\")\n\t\t\t\t}\n\t\t\t\tt.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() { recover() }()\n\t\tdefer func() { close(evCh) }()\n\n\t\tfor {\n\t\t\tev := termbox.PollEvent()\n\t\t\tif ev.Type != termbox.EventInterrupt {\n\t\t\t\tevCh <- ev\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase replyCh := <-t.resumeCh:\n\t\t\t\tt.Init(cfg)\n\t\t\t\tclose(replyCh)\n\t\t\t}\n\t\t}\n\t}()\n\treturn evCh\n\n}\n\nfunc (t *Termbox) Suspend() {\n\tselect {\n\tcase t.suspendCh <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (t *Termbox) Resume() {\n\t// Resume must be a block operation, because we can't safely proceed\n\t// without actually knowing that termbox has been re-initialized.\n\t// So we send a channel where we expect a reply back, and wait for that\n\tch := make(chan struct{})\n\tselect {\n\tcase t.resumeCh <- ch:\n\tdefault:\n\t}\n\n\t<-ch\n}\n\n// SetCell writes to the terminal\nfunc (t *Termbox) SetCell(x, y int, ch rune, fg, bg termbox.Attribute) {\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\ttermbox.SetCell(x, y, ch, fg, bg)\n}\n\n// Size returns the dimensions of the current terminal\nfunc (t *Termbox) Size() (int, int) {\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\treturn termbox.Size()\n}\n\ntype PrintArgs struct {\n\tX       int\n\tXOffset int\n\tY       int\n\tFg      termbox.Attribute\n\tBg      termbox.Attribute\n\tMsg     string\n\tFill    bool\n}\n\nfunc (t *Termbox) Print(args PrintArgs) int {\n\treturn screenPrint(t, args)\n}\n\nfunc screenPrint(t Screen, args PrintArgs) int {\n\tvar written int\n\n\tbg := args.Bg\n\tfg := args.Fg\n\tmsg := args.Msg\n\tx := args.X\n\ty := args.Y\n\txOffset := args.XOffset\n\tfor len(msg) > 0 {\n\t\tc, w := utf8.DecodeRuneInString(msg)\n\t\tif c == utf8.RuneError {\n\t\t\tc = '?'\n\t\t\tw = 1\n\t\t}\n\t\tmsg = msg[w:]\n\t\tif c == '\\t' {\n\t\t\t// In case we found a tab, we draw it as 4 spaces\n\t\t\tn := 4 - (x+xOffset)%4\n\t\t\tfor i := int(0); i <= n; i++ {\n\t\t\t\tt.SetCell(int(x+i), int(y), ' ', fg, bg)\n\t\t\t}\n\t\t\twritten += n\n\t\t\tx += n\n\t\t} else {\n\t\t\tt.SetCell(int(x), int(y), c, fg, bg)\n\t\t\tn := int(runewidth.RuneWidth(c))\n\t\t\tx += n\n\t\t\twritten += n\n\t\t}\n\t}\n\n\tif !args.Fill {\n\t\treturn written\n\t}\n\n\twidth, _ := t.Size()\n\tfor ; x < int(width); x++ {\n\t\tt.SetCell(int(x), int(y), ' ', fg, bg)\n\t}\n\twritten += int(width) - x\n\treturn written\n}\n"
        },
        {
          "name": "screen_posix.go",
          "type": "blob",
          "size": 0.3076171875,
          "content": "// +build !windows\n\npackage peco\n\nimport \"github.com/nsf/termbox-go\"\n\nfunc (t *Termbox) PostInit(cfg *Config) error {\n\t// This has no effect on Windows,\n\t// because termbox.SetOutputMode always sets termbox.OutputNormal on Windows.\n\tif cfg.Use256Color {\n\t\ttermbox.SetOutputMode(termbox.Output256)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "screen_windows.go",
          "type": "blob",
          "size": 0.19921875,
          "content": "package peco\n\nimport \"github.com/nsf/termbox-go\"\n\nfunc (t *Termbox) PostInit(cfg *Config) error {\n\t// Windows handle Esc/Alt self\n\ttermbox.SetInputMode(termbox.InputEsc | termbox.InputAlt)\n\n\treturn nil\n}\n"
        },
        {
          "name": "selection.go",
          "type": "blob",
          "size": 1.09765625,
          "content": "package peco\n\nimport (\n\t\"github.com/google/btree\"\n\t\"github.com/peco/peco/line\"\n)\n\n// NewSelection creates a new empty Selection\nfunc NewSelection() *Selection {\n\ts := &Selection{}\n\ts.Reset()\n\treturn s\n}\n\n// Add adds a new line to the selection. If the line already\n// exists in the selection, it is silently ignored\nfunc (s *Selection) Add(l line.Line) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.tree.ReplaceOrInsert(l)\n}\n\nfunc (s *Selection) Copy(dst *Selection) {\n\ts.Ascend(func(it btree.Item) bool {\n\t\tdst.Add(it.(line.Line))\n\t\treturn true\n\t})\n}\n\n// Remove removes the specified line from the selection\nfunc (s *Selection) Remove(l line.Line) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.tree.Delete(l)\n}\n\nfunc (s *Selection) Reset() {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.tree = btree.New(32)\n}\n\nfunc (s *Selection) Has(x line.Line) bool {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\treturn s.tree.Has(x)\n}\n\nfunc (s *Selection) Len() int {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\treturn s.tree.Len()\n}\n\nfunc (s *Selection) Ascend(i btree.ItemIterator) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.tree.Ascend(i)\n}\n"
        },
        {
          "name": "selection_test.go",
          "type": "blob",
          "size": 0.5439453125,
          "content": "package peco\n\nimport (\n\t\"testing\"\n\n\t\"github.com/peco/peco/line\"\n)\n\nfunc TestSelection(t *testing.T) {\n\ts := NewSelection()\n\n\tvar i uint64 = 0\n\talice := line.NewRaw(i, \"Alice\", false)\n\ti++\n\ts.Add(alice)\n\tif s.Len() != 1 {\n\t\tt.Errorf(\"expected Len = 1, got %d\", s.Len())\n\t}\n\ts.Add(line.NewRaw(i, \"Bob\", false))\n\ti++\n\tif s.Len() != 2 {\n\t\tt.Errorf(\"expected Len = 2, got %d\", s.Len())\n\t}\n\ts.Add(alice)\n\tif s.Len() != 2 {\n\t\tt.Errorf(\"expected Len = 2, got %d\", s.Len())\n\t}\n\ts.Remove(alice)\n\tif s.Len() != 1 {\n\t\tt.Errorf(\"expected Len = 1, got %d\", s.Len())\n\t}\n}\n"
        },
        {
          "name": "sig",
          "type": "tree",
          "content": null
        },
        {
          "name": "source.go",
          "type": "blob",
          "size": 6.3486328125,
          "content": "package peco\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/lestrrat-go/pdebug\"\n\t\"github.com/peco/peco/internal/util\"\n\t\"github.com/peco/peco/line\"\n\t\"github.com/peco/peco/pipeline\"\n)\n\n// Creates a new Source. Does not start processing the input until you\n// call Setup()\nfunc NewSource(name string, in io.Reader, isInfinite bool, idgen line.IDGenerator, capacity int, enableSep bool) *Source {\n\ts := &Source{\n\t\tname:       name,\n\t\tcapacity:   capacity,\n\t\tenableSep:  enableSep,\n\t\tidgen:      idgen,\n\t\tin:         in, // Note that this may be closed, so do not rely on it\n\t\tinClosed:   false,\n\t\tisInfinite: isInfinite,\n\t\tready:      make(chan struct{}),\n\t\tsetupDone:  make(chan struct{}),\n\t\tChanOutput: pipeline.ChanOutput(make(chan interface{})),\n\t}\n\ts.Reset()\n\treturn s\n}\n\nfunc (s *Source) Name() string {\n\treturn s.name\n}\n\nfunc (s *Source) IsInfinite() bool {\n\treturn s.isInfinite && !s.inClosed\n}\n\n// Setup reads from the input os.File.\nfunc (s *Source) Setup(ctx context.Context, state *Peco) {\n\ts.setupOnce.Do(func() {\n\t\tdone := make(chan struct{})\n\t\trefresh := make(chan struct{}, 1)\n\t\tdefer close(done)\n\t\tdefer close(refresh)\n\t\t// And also, close the done channel so we can tell the consumers\n\t\t// we have finished reading everything\n\t\tdefer close(s.setupDone)\n\n\t\tdraw := func(state *Peco) {\n\t\t\tstate.Hub().SendDraw(ctx, nil)\n\t\t}\n\n\t\tgo func() {\n\t\t\tticker := time.NewTicker(100 * time.Millisecond)\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\t\tdraw(state)\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\tdraw(state)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// This sync.Once var is used to receive the notification\n\t\t// that there was at least 1 line read from the source\n\t\t// This is wrapped in a sync.Notify so we can safely call\n\t\t// it in multiple places\n\t\tvar notify sync.Once\n\t\tnotifycb := func() {\n\t\t\t// close the ready channel so others can be notified\n\t\t\t// that there's at least 1 line in the buffer\n\t\t\tstate.Hub().SendStatusMsg(ctx, \"\")\n\t\t\tclose(s.ready)\n\t\t}\n\n\t\t// Register this to be called in a defer, just in case we could bailed\n\t\t// out without reading a single line.\n\t\t// Note: this will be a no-op if notify.Do has been called before\n\t\tdefer notify.Do(notifycb)\n\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Source: using buffer size of %dkb\", state.maxScanBufferSize)\n\t\t}\n\t\tscanbuf := make([]byte, state.maxScanBufferSize*1024)\n\t\tscanner := bufio.NewScanner(s.in)\n\t\tscanner.Buffer(scanbuf, state.maxScanBufferSize*1024)\n\t\tdefer func() {\n\t\t\tif util.IsTty(s.in) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif closer, ok := s.in.(io.Closer); ok {\n\t\t\t\ts.inClosed = true\n\t\t\t\tcloser.Close()\n\t\t\t}\n\t\t}()\n\n\t\tlines := make(chan string)\n\t\tgo func() {\n\t\t\tvar scanned int\n\t\t\tif pdebug.Enabled {\n\t\t\t\tdefer func() { pdebug.Printf(\"Source scanned %d lines\", scanned) }()\n\t\t\t}\n\n\t\t\tdefer close(lines)\n\t\t\tfor scanner.Scan() {\n\t\t\t\tnewLine := scanner.Text()\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\t\tpdebug.Printf(\"Bailing out of source setup text reader loop, because ctx was canceled\")\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\tcase lines <- newLine:\n\t\t\t\t}\n\t\t\t\tscanned++\n\t\t\t}\n\t\t}()\n\n\t\tstate.Hub().SendStatusMsg(ctx, \"Waiting for input...\")\n\n\t\treadCount := 0\n\t\tfor loop := true; loop; {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"Bailing out of source setup, because ctx was canceled\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tcase l, ok := <-lines:\n\t\t\t\tif !ok {\n\t\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\t\tpdebug.Printf(\"No more lines to read...\")\n\t\t\t\t\t}\n\t\t\t\t\tloop = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treadCount++\n\t\t\t\ts.Append(line.NewRaw(s.idgen.Next(), l, s.enableSep))\n\t\t\t\tnotify.Do(notifycb)\n\t\t\t}\n\t\t}\n\n\t\tif pdebug.Enabled {\n\t\t\tpdebug.Printf(\"Read all %d lines from source\", readCount)\n\t\t}\n\t})\n}\n\n// Start starts\nfunc (s *Source) Start(ctx context.Context, out pipeline.ChanOutput) {\n\tvar sent int\n\t// I should be the only one running this method until I bail out\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Source.Start (%d lines in buffer)\", len(s.lines))\n\t\tdefer g.End()\n\t\tdefer func() { pdebug.Printf(\"Source sent %d lines\", sent) }()\n\t}\n\tdefer out.SendEndMark(\"end of input\")\n\n\tvar resume bool\n\tselect {\n\tcase <-s.setupDone:\n\tdefault:\n\t\tresume = true\n\t}\n\n\tif !resume {\n\t\t// no fancy resume handling needed. just go\n\t\tfor _, l := range s.lines {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"Source: context.Done detected\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tout.Send(l)\n\t\t\t\tsent++\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\t// For the first time we get called, we may possibly be in the\n\t// middle of reading a really long input stream. In this case,\n\t// we should resume where we left off.\n\n\tvar prev = 0\n\tvar setupDone bool\n\tfor {\n\t\t// This is where we are ready up to\n\t\tupto := s.Size()\n\t\t// We bail out if we are done with the setup, and our\n\t\t// buffer has not grown\n\t\tif setupDone && upto == prev {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := prev; i < upto; i++ {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif pdebug.Enabled {\n\t\t\t\t\tpdebug.Printf(\"Source: context.Done detected\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tl, _ := s.LineAt(i)\n\t\t\t\tout.Send(l)\n\t\t\t\tsent++\n\t\t\t}\n\t\t}\n\t\t// Remember how far we have processed\n\t\tprev = upto\n\n\t\t// Check if we're done with setup\n\t\tselect {\n\t\tcase <-s.setupDone:\n\t\t\tsetupDone = true\n\t\tdefault:\n\t\t}\n\n\t}\n}\n\n// Reset resets the state of the source object so that it\n// is ready to feed the filters\nfunc (s *Source) Reset() {\n\tif pdebug.Enabled {\n\t\tg := pdebug.Marker(\"Source.Reset\")\n\t\tdefer g.End()\n\t}\n\ts.ChanOutput = pipeline.ChanOutput(make(chan interface{}))\n}\n\n// Ready returns the \"input ready\" channel. It will be closed as soon as\n// the first line of input is processed via Setup()\nfunc (s *Source) Ready() <-chan struct{} {\n\treturn s.ready\n}\n\n// SetupDone returns the \"read all lines\" channel. It will be closed as soon as\n// the all input has been read\nfunc (s *Source) SetupDone() <-chan struct{} {\n\treturn s.setupDone\n}\n\nfunc (s *Source) linesInRange(start, end int) []line.Line {\n\ts.mutex.RLock()\n\tdefer s.mutex.RUnlock()\n\treturn s.lines[start:end]\n}\n\nfunc (s *Source) LineAt(n int) (line.Line, error) {\n\ts.mutex.RLock()\n\tdefer s.mutex.RUnlock()\n\treturn bufferLineAt(s.lines, n)\n}\n\nfunc (s *Source) Size() int {\n\ts.mutex.RLock()\n\tdefer s.mutex.RUnlock()\n\treturn bufferSize(s.lines)\n}\n\nfunc (s *Source) Append(l line.Line) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\ts.lines = append(s.lines, l)\n\tif s.capacity > 0 && len(s.lines) > s.capacity {\n\t\tdiff := len(s.lines) - s.capacity\n\n\t\t// Golang's version of array realloc\n\t\ts.lines = s.lines[diff:s.capacity:s.capacity]\n\t}\n}\n"
        },
        {
          "name": "source_test.go",
          "type": "blob",
          "size": 1.728515625,
          "content": "package peco\n\nimport (\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"context\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// delay reading so we can see that\ntype delayedReader struct {\n\tio.Reader\n\tdelay time.Duration\n\tonce  sync.Once\n}\n\nfunc addReadDelay(r io.Reader, delay time.Duration) io.Reader {\n\treturn &delayedReader{\n\t\tReader: r,\n\t\tdelay:  delay,\n\t}\n}\n\nfunc (r *delayedReader) Read(b []byte) (int, error) {\n\tr.once.Do(func() { time.Sleep(r.delay) })\n\treturn r.Reader.Read(b)\n}\n\nfunc TestSource(t *testing.T) {\n\tlines := []string{\n\t\t\"foo\",\n\t\t\"bar\",\n\t\t\"baz\",\n\t}\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tig := newIDGen()\n\tgo ig.Run(ctx)\n\n\tr := addReadDelay(strings.NewReader(strings.Join(lines, \"\\n\")), 2*time.Second)\n\ts := NewSource(\"-\", r, false, ig, 0, false)\n\tp := New()\n\tp.hub = nullHub{}\n\tgo s.Setup(ctx, p)\n\n\ttimeout := time.After(5 * time.Second)\n\twaitout := time.After(1 * time.Second)\n\tselect {\n\tcase <-waitout:\n\t\t_, ok := <-s.Ready()\n\t\tif !assert.False(t, ok, \"s.Ready should be false at this point\") {\n\t\t\treturn\n\t\t}\n\tcase <-timeout:\n\t\tassert.Fail(t, \"timed out waiting for source\")\n\t\treturn\n\tcase <-s.Ready():\n\t}\n\n\t// Even if s.Ready() returns, we may still be reading.\n\t// Wait for another few seconds for the buffer to fill up to\n\t// the expected number of lines\n\ttimeout = time.After(5 * time.Second)\n\tfor s.Size() != len(lines) {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\tassert.Fail(t, \"timed out waiting for the buffer to fill\")\n\t\t\treturn\n\t\tdefault:\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n\n\tfor i := 0; i < len(lines); i++ {\n\t\tline, err := s.LineAt(i)\n\t\tif !assert.NoError(t, err, \"s.LineAt(%d) should succeed\", i) {\n\t\t\treturn\n\t\t}\n\t\tif !assert.Equal(t, line.DisplayString(), lines[i], \"expected lien found\") {\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "stringer_paging_request_type.go",
          "type": "blob",
          "size": 0.62890625,
          "content": "// Code generated by \"stringer -type PagingRequestType -output stringer_paging_request_type.go .\"; DO NOT EDIT.\n\npackage peco\n\nimport \"fmt\"\n\nconst _PagingRequestType_name = \"ToLineAboveToScrollPageDownToLineBelowToScrollPageUpToScrollLeftToScrollRightToLineInPageToScrollFirstItemToScrollLastItem\"\n\nvar _PagingRequestType_index = [...]uint8{0, 11, 27, 38, 52, 64, 77, 89, 106, 122}\n\nfunc (i PagingRequestType) String() string {\n\tif i < 0 || i >= PagingRequestType(len(_PagingRequestType_index)-1) {\n\t\treturn fmt.Sprintf(\"PagingRequestType(%d)\", i)\n\t}\n\treturn _PagingRequestType_name[_PagingRequestType_index[i]:_PagingRequestType_index[i+1]]\n}\n"
        },
        {
          "name": "stringer_vertical_anchor.go",
          "type": "blob",
          "size": 0.4765625,
          "content": "// Code generated by \"stringer -type VerticalAnchor -output stringer_vertical_anchor.go .\"; DO NOT EDIT.\n\npackage peco\n\nimport \"fmt\"\n\nconst _VerticalAnchor_name = \"AnchorTopAnchorBottom\"\n\nvar _VerticalAnchor_index = [...]uint8{0, 9, 21}\n\nfunc (i VerticalAnchor) String() string {\n\ti -= 1\n\tif i < 0 || i >= VerticalAnchor(len(_VerticalAnchor_index)-1) {\n\t\treturn fmt.Sprintf(\"VerticalAnchor(%d)\", i+1)\n\t}\n\treturn _VerticalAnchor_name[_VerticalAnchor_index[i]:_VerticalAnchor_index[i+1]]\n}\n"
        },
        {
          "name": "view.go",
          "type": "blob",
          "size": 1.7822265625,
          "content": "package peco\n\nimport (\n\t\"time\"\n\n\t\"context\"\n\t\"github.com/peco/peco/hub\"\n)\n\ntype statusMsgReq interface {\n\tMessage() string\n\tDelay() time.Duration\n}\n\nfunc (prt PagingRequestType) Type() PagingRequestType {\n\treturn prt\n}\n\nfunc (jlr JumpToLineRequest) Type() PagingRequestType {\n\treturn ToLineInPage\n}\n\nfunc (jlr JumpToLineRequest) Line() int {\n\treturn int(jlr)\n}\n\nfunc NewView(state *Peco) *View {\n\tvar layout Layout\n\tswitch state.LayoutType() {\n\tcase LayoutTypeBottomUp:\n\t\tlayout = NewBottomUpLayout(state)\n\tdefault:\n\t\tlayout = NewDefaultLayout(state)\n\t}\n\treturn &View{\n\t\tstate:  state,\n\t\tlayout: layout,\n\t}\n}\n\nfunc (v *View) Loop(ctx context.Context, cancel func()) error {\n\tdefer cancel()\n\n\th := v.state.Hub()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase r := <-h.StatusMsgCh():\n\t\t\tv.printStatus(r, r.Data().(statusMsgReq))\n\t\tcase r := <-h.PagingCh():\n\t\t\tv.movePage(r, r.Data().(PagingRequest))\n\t\tcase r := <-h.DrawCh():\n\t\t\ttmp := r.Data()\n\t\t\tswitch tmp.(type) {\n\t\t\tcase string:\n\t\t\t\tswitch tmp.(string) {\n\t\t\t\tcase \"prompt\":\n\t\t\t\t\tv.drawPrompt(r)\n\t\t\t\tcase \"purgeCache\":\n\t\t\t\t\tv.purgeDisplayCache(r)\n\t\t\t\t}\n\t\t\tcase *DrawOptions:\n\t\t\t\tv.drawScreen(r, tmp.(*DrawOptions))\n\t\t\tdefault:\n\t\t\t\tv.drawScreen(r, nil)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (v *View) printStatus(p hub.Payload, r statusMsgReq) {\n\tdefer p.Done()\n\tv.layout.PrintStatus(r.Message(), r.Delay())\n}\n\nfunc (v *View) purgeDisplayCache(p hub.Payload) {\n\tdefer p.Done()\n\n\tv.layout.PurgeDisplayCache()\n}\n\nfunc (v *View) drawScreen(p hub.Payload, options *DrawOptions) {\n\tdefer p.Done()\n\n\tv.layout.DrawScreen(v.state, options)\n}\n\nfunc (v *View) drawPrompt(p hub.Payload) {\n\tdefer p.Done()\n\n\tv.layout.DrawPrompt(v.state)\n}\n\nfunc (v *View) movePage(p hub.Payload, r PagingRequest) {\n\tdefer p.Done()\n\n\tif v.layout.MovePage(v.state, r) {\n\t\tv.layout.DrawScreen(v.state, nil)\n\t}\n}\n"
        }
      ]
    }
  ]
}