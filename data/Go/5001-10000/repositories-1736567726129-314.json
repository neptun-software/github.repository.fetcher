{
  "metadata": {
    "timestamp": 1736567726129,
    "page": 314,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "googollee/go-socket.io",
      "stars": 5759,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".deepsource.toml",
          "type": "blob",
          "size": 0.1953125,
          "content": "version = 1\n\ntest_patterns = [\"**/*_test.go\"]\n\nexclude_patterns = [\"/_example/**\"]\n\n[[analyzers]]\nname = \"go\"\nenabled = true\n\n  [analyzers.meta]\n  import_paths = [\"github.com/googollee/go-socket.io\"]\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0966796875,
          "content": "/bin\n/vendor\n/vendor.pb\n.DS_STORE\n/.idea\n/.vscode\n*.o\n*.out\nprofile.cov\n*.prof\n*.svg\n*/node_modules"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3056640625,
          "content": "# More info on config here: https://github.com/golangci/golangci-lint#config-file\nrun:\n  timeout: 3m\n  deadline: 5m\n\noutput:\n  format: colored-line-number\n  print-issued-lines: true\n  print-linter-name: true\n\nissues:\n  exclude-use-default: false\n  exclude:\n    # support go 1.13 with deprecated APIs\n    - SA1019\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.59765625,
          "content": "# Contributing\n\nWhen contributing to this repository, please first discuss the change you wish to make via issue,\nemail, or any other method with the owners of this repository before making a change. \n\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\n\n## Pull Request Process\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\nPlease make an issue first if the change is likely to increase."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.353515625,
          "content": "Copyright (c) 2014-2014 Googol Lee <i@googol.im>\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the author may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3798828125,
          "content": ".PHONY: all\nall:\n\tgo install ./...\n\n.PHONY: get_dev\nget_dev:\n\tgo get -t ./...\n\n.PHONY: test\ntest:\n\tgo clean -testcache && go test -v -race -count=1 ./...\n\n.PHONY: bench\nbench:\n\tgo clean -testcache && go test -bench . -benchmem ./...\n\n.PHONY: lint\nlint:\n\tgolangci-lint run \n\n.PHONY: cover\ncover:\n\tgo clean -testcache && go test ./... -cover -coverprofile=c.out && go tool cover -html=c.out\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.5390625,
          "content": "# WARNING\n\n**This repo is archived. Please check the forked one https://github.com/feederco/go-socket.io.**\n\n# go-socket.io\n\ngo-socket.io is library an implementation of [Socket.IO](http://socket.io) in Golang, which is a realtime application framework.\n\nCurrent this library supports 1.4 version of the Socket.IO client. It supports room, namespaces and broadcast at now.\n\n**Help wanted** This project is looking for contributors to help fix bugs and implement new features. Please check [Issue 192](https://github.com/googollee/go-socket.io/issues/192). All help is much appreciated.\n\n## Badges\n\n![Build Status](https://github.com/googollee/go-socket.io/workflows/CI/badge.svg)\n[![GoDoc](http://godoc.org/github.com/googollee/go-socket.io?status.svg)](http://godoc.org/github.com/googollee/go-socket.io)\n[![License](https://img.shields.io/github/license/golangci/golangci-lint)](/LICENSE)\n[![Release](https://img.shields.io/github/release/googollee/go-socket.io.svg)](https://github.com/googollee/go-socket.io/releases/latest)\n[![Go Report Card](https://goreportcard.com/badge/github.com/googollee/go-socket.io)](https://goreportcard.com/report/github.com/googollee/go-socket.io)\n\n## Contents\n\n- [Install](#install)\n- [Example](#example)\n- [FAQ](#faq)\n- [Engine.io](#engineio)\n- [Community](#community)\n- [License](#license)\n\n## Install\n\nInstall the package with:\n\n```bash\ngo get github.com/googollee/go-socket.io\n```\n\nImport it with:\n\n```go\nimport \"github.com/googollee/go-socket.io\"\n```\n\nand use `socketio` as the package name inside the code.\n\n## Example\n\nPlease check more examples into folder in project for details. [Examples](https://github.com/googollee/go-socket.io/tree/master/_examples)\n\n## FAQ\n\nIt is some popular questions about this repository: \n\n- Is this library supported socket.io version 2?\n    - No, but if you wanna you can help to do it. Join us in community chat Telegram   \n- How to use go-socket.io with CORS?\n    - Please see examples in [directory](https://github.com/googollee/go-socket.io/tree/master/_examples)\n\n## Community\n\nTelegram chat: [@go_socketio](https://t.me/go_socketio)\n\n## Engineio\n\nThis project contains a sub-package called `engineio`. This used to be a separate package under https://github.com/googollee/go-engine.io.\n\nIt contains the `engine.io` analog implementation of the original node-package. https://github.com/socketio/engine.io It can be used without the socket.io-implementation. Please check the README.md in `engineio/`.\n\n## License\n\nThe 3-clause BSD License  - see [LICENSE](https://opensource.org/licenses/BSD-3-Clause) for more details\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "adapter_options.go",
          "type": "blob",
          "size": 1.14453125,
          "content": "package socketio\n\nimport \"fmt\"\n\n// RedisAdapterOptions is configuration to create new adapter\ntype RedisAdapterOptions struct {\n\t// deprecated. Usage Addr options\n\tHost string\n\t// deprecated. Usage Addr options\n\tPort     string\n\tAddr     string\n\tPrefix   string\n\tNetwork  string\n\tPassword string\n\t// DB : specifies the database to select when dialing a connection.\n\tDB int\n}\n\nfunc (ro *RedisAdapterOptions) getAddr() string {\n\tif ro.Addr == \"\" {\n\t\tro.Addr = fmt.Sprintf(\"%s:%s\", ro.Host, ro.Port)\n\t}\n\treturn ro.Addr\n}\n\nfunc defaultOptions() *RedisAdapterOptions {\n\treturn &RedisAdapterOptions{\n\t\tAddr:    \"127.0.0.1:6379\",\n\t\tPrefix:  \"socket.io\",\n\t\tNetwork: \"tcp\",\n\t}\n}\n\nfunc getOptions(opts *RedisAdapterOptions) *RedisAdapterOptions {\n\toptions := defaultOptions()\n\n\tif opts != nil {\n\t\tif opts.Host != \"\" {\n\t\t\toptions.Host = opts.Host\n\t\t}\n\n\t\tif opts.Port != \"\" {\n\t\t\toptions.Port = opts.Port\n\t\t}\n\n\t\tif opts.Addr != \"\" {\n\t\t\toptions.Addr = opts.Addr\n\t\t}\n\n\t\tif opts.Prefix != \"\" {\n\t\t\toptions.Prefix = opts.Prefix\n\t\t}\n\n\t\tif opts.Network != \"\" {\n\t\t\toptions.Network = opts.Network\n\t\t}\n\n\t\tif len(opts.Password) > 0 {\n\t\t\toptions.Password = opts.Password\n\t\t}\n\t}\n\n\treturn options\n}\n"
        },
        {
          "name": "broadcast.go",
          "type": "blob",
          "size": 4.5576171875,
          "content": "package socketio\n\nimport \"sync\"\n\n// EachFunc typed for each callback function\ntype EachFunc func(Conn)\n\n// Broadcast is the adaptor to handle broadcasts & rooms for socket.io server API\ntype Broadcast interface {\n\tJoin(room string, connection Conn)            // Join causes the connection to join a room\n\tLeave(room string, connection Conn)           // Leave causes the connection to leave a room\n\tLeaveAll(connection Conn)                     // LeaveAll causes given connection to leave all rooms\n\tClear(room string)                            // Clear causes removal of all connections from the room\n\tSend(room, event string, args ...interface{}) // Send will send an event with args to the room\n\tSendAll(event string, args ...interface{})    // SendAll will send an event with args to all the rooms\n\tForEach(room string, f EachFunc)              // ForEach sends data by DataFunc, if room does not exits sends nothing\n\tLen(room string) int                          // Len gives number of connections in the room\n\tRooms(connection Conn) []string               // Gives list of all the rooms if no connection given, else list of all the rooms the connection joined\n\tAllRooms() []string                           // Gives list of all the rooms the connection joined\n}\n\n// broadcast gives Join, Leave & BroadcastTO server API support to socket.io along with room management\n// map of rooms where each room contains a map of connection id to connections in that room\ntype broadcast struct {\n\trooms map[string]map[string]Conn\n\n\tlock sync.RWMutex\n}\n\n// newBroadcast creates a new broadcast adapter\nfunc newBroadcast() *broadcast {\n\treturn &broadcast{\n\t\trooms: make(map[string]map[string]Conn),\n\t}\n}\n\n// Join joins the given connection to the broadcast room\nfunc (bc *broadcast) Join(room string, connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tif _, ok := bc.rooms[room]; !ok {\n\t\tbc.rooms[room] = make(map[string]Conn)\n\t}\n\n\tbc.rooms[room][connection.ID()] = connection\n}\n\n// Leave leaves the given connection from given room (if exist)\nfunc (bc *broadcast) Leave(room string, connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tif connections, ok := bc.rooms[room]; ok {\n\t\tdelete(connections, connection.ID())\n\n\t\tif len(connections) == 0 {\n\t\t\tdelete(bc.rooms, room)\n\t\t}\n\t}\n}\n\n// LeaveAll leaves the given connection from all rooms\nfunc (bc *broadcast) LeaveAll(connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tfor room, connections := range bc.rooms {\n\t\tdelete(connections, connection.ID())\n\n\t\tif len(connections) == 0 {\n\t\t\tdelete(bc.rooms, room)\n\t\t}\n\t}\n}\n\n// Clear clears the room\nfunc (bc *broadcast) Clear(room string) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tdelete(bc.rooms, room)\n}\n\n// Send sends given event & args to all the connections in the specified room\nfunc (bc *broadcast) Send(room, event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tfor _, connection := range bc.rooms[room] {\n\t\tconnection.Emit(event, args...)\n\t}\n}\n\n// SendAll sends given event & args to all the connections to all the rooms\nfunc (bc *broadcast) SendAll(event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tfor _, connections := range bc.rooms {\n\t\tfor _, connection := range connections {\n\t\t\tconnection.Emit(event, args...)\n\t\t}\n\t}\n}\n\n// ForEach sends data returned by DataFunc, if room does not exits sends nothing\nfunc (bc *broadcast) ForEach(room string, f EachFunc) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\toccupants, ok := bc.rooms[room]\n\tif !ok {\n\t\treturn\n\t}\n\n\tfor _, connection := range occupants {\n\t\tf(connection)\n\t}\n}\n\n// Len gives number of connections in the room\nfunc (bc *broadcast) Len(room string) int {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\treturn len(bc.rooms[room])\n}\n\n// Rooms gives the list of all the rooms available for broadcast in case of\n// no connection is given, in case of a connection is given, it gives\n// list of all the rooms the connection is joined to\nfunc (bc *broadcast) Rooms(connection Conn) []string {\n\tif connection == nil {\n\t\treturn bc.AllRooms()\n\t}\n\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\treturn bc.getRoomsByConn(connection)\n}\n\n// AllRooms gives list of all rooms available for broadcast\nfunc (bc *broadcast) AllRooms() []string {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\trooms := make([]string, 0, len(bc.rooms))\n\tfor room := range bc.rooms {\n\t\trooms = append(rooms, room)\n\t}\n\n\treturn rooms\n}\n\nfunc (bc *broadcast) getRoomsByConn(connection Conn) []string {\n\tvar rooms []string\n\n\tfor room, connections := range bc.rooms {\n\t\tif _, ok := connections[connection.ID()]; ok {\n\t\t\trooms = append(rooms, room)\n\t\t}\n\t}\n\n\treturn rooms\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 5.4853515625,
          "content": "package socketio\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/googollee/go-socket.io/engineio\"\n\t\"github.com/googollee/go-socket.io/engineio/transport\"\n\t\"github.com/googollee/go-socket.io/engineio/transport/polling\"\n\t\"github.com/googollee/go-socket.io/logger\"\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\nvar EmptyAddrErr = errors.New(\"empty addr\")\n\n// Client is client for socket.io server\ntype Client struct {\n\tnamespace string\n\turl       string\n\n\tconn     *conn\n\thandlers *namespaceHandlers\n\n\topts *engineio.Options\n}\n\n// NewClient returns a server\n// addr like http://asd.com:8080/{$namespace}\nfunc NewClient(addr string, opts *engineio.Options) (*Client, error) {\n\tif addr == \"\" {\n\t\treturn nil, EmptyAddrErr\n\t}\n\n\tu, err := url.Parse(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnamespace := fmtNS(u.Path)\n\n\t// Not allowing other than default\n\tu.Path = path.Join(\"/socket.io\", namespace)\n\tu.Path = u.EscapedPath()\n\tif strings.HasSuffix(u.Path, \"socket.io\") {\n\t\tu.Path += \"/\"\n\t}\n\n\treturn &Client{\n\t\tnamespace: namespace,\n\t\turl:       u.String(),\n\t\thandlers:  newNamespaceHandlers(),\n\t\topts:      opts,\n\t}, nil\n}\n\nfunc fmtNS(ns string) string {\n\tif ns == aliasRootNamespace {\n\t\treturn rootNamespace\n\t}\n\n\treturn ns\n}\n\nfunc (c *Client) Connect() error {\n\tdialer := engineio.Dialer{\n\t\tTransports: []transport.Transport{polling.Default},\n\t}\n\n\tenginioCon, err := dialer.Dial(c.url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.conn = newConn(enginioCon, c.handlers)\n\n\tif err := c.conn.connectClient(); err != nil {\n\t\t_ = c.Close()\n\t\tif root, ok := c.handlers.Get(rootNamespace); ok && root.onError != nil {\n\t\t\troot.onError(nil, err)\n\t\t}\n\n\t\treturn err\n\t}\n\n\tgo c.clientError()\n\tgo c.clientWrite()\n\tgo c.clientRead()\n\n\treturn nil\n}\n\n// Close closes server.\nfunc (c *Client) Close() error {\n\treturn c.conn.Close()\n}\n\nfunc (c *Client) Emit(event string, args ...interface{}) {\n\tnsConn, ok := c.conn.namespaces.Get(c.namespace)\n\tif !ok {\n\t\tlogger.Info(\"Connection Namespace not initialized\")\n\t\treturn\n\t}\n\n\tnsConn.Emit(event, args...)\n}\n\n// OnConnect set a handler function f to handle open event for namespace.\nfunc (c *Client) OnConnect(f func(Conn) error) {\n\th := c.getNamespace(c.namespace)\n\tif h == nil {\n\t\th = c.createNamespace(c.namespace)\n\t}\n\n\th.OnConnect(f)\n}\n\n// OnDisconnect set a handler function f to handle disconnect event for namespace.\nfunc (c *Client) OnDisconnect(f func(Conn, string)) {\n\th := c.getNamespace(c.namespace)\n\tif h == nil {\n\t\th = c.createNamespace(c.namespace)\n\t}\n\n\th.OnDisconnect(f)\n}\n\n// OnError set a handler function f to handle error for namespace.\nfunc (c *Client) OnError(f func(Conn, error)) {\n\th := c.getNamespace(c.namespace)\n\tif h == nil {\n\t\th = c.createNamespace(c.namespace)\n\t}\n\n\th.OnError(f)\n}\n\n// OnEvent set a handler function f to handle event for namespace.\nfunc (c *Client) OnEvent(event string, f interface{}) {\n\th := c.getNamespace(c.namespace)\n\tif h == nil {\n\t\th = c.createNamespace(c.namespace)\n\t}\n\n\th.OnEvent(event, f)\n}\n\nfunc (c *Client) clientError() {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.conn.quitChan:\n\t\t\treturn\n\t\tcase err := <-c.conn.errorChan:\n\t\t\tlogger.Error(\"clientError\", err)\n\n\t\t\tvar errMsg *errorMessage\n\t\t\tif !errors.As(err, &errMsg) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif handler := c.conn.namespace(errMsg.namespace); handler != nil {\n\t\t\t\tif handler.onError != nil {\n\t\t\t\t\tnsConn, ok := c.conn.namespaces.Get(errMsg.namespace)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\thandler.onError(nsConn, errMsg.err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Client) clientWrite() {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.conn.quitChan:\n\t\t\tlogger.Info(\"clientWrite Writer loop has stopped\")\n\t\t\treturn\n\t\tcase pkg := <-c.conn.writeChan:\n\t\t\tif err := c.conn.encoder.Encode(pkg.Header, pkg.Data); err != nil {\n\t\t\t\tc.conn.onError(pkg.Header.Namespace, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Client) clientRead() {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\t}()\n\n\tvar event string\n\n\tfor {\n\t\tvar header parser.Header\n\n\t\tif err := c.conn.decoder.DecodeHeader(&header, &event); err != nil {\n\t\t\tc.conn.onError(rootNamespace, err)\n\n\t\t\tlogger.Error(\"clientRead Error in Decoder\", err)\n\n\t\t\treturn\n\t\t}\n\n\t\tif header.Namespace == aliasRootNamespace {\n\t\t\theader.Namespace = rootNamespace\n\t\t}\n\n\t\tvar err error\n\t\tswitch header.Type {\n\t\tcase parser.Ack:\n\t\t\terr = ackPacketHandler(c.conn, header)\n\t\tcase parser.Connect:\n\t\t\terr = clientConnectPacketHandler(c.conn, header)\n\t\tcase parser.Disconnect:\n\t\t\terr = clientDisconnectPacketHandler(c.conn, header)\n\t\tcase parser.Event:\n\t\t\terr = eventPacketHandler(c.conn, event, header)\n\t\tdefault:\n\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"client read:\", err)\n\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *Client) createNamespace(ns string) *namespaceHandler {\n\thandler := newNamespaceHandler(ns, nil)\n\tc.handlers.Set(ns, handler)\n\n\treturn handler\n}\n\nfunc (c *Client) getNamespace(ns string) *namespaceHandler {\n\tret, ok := c.handlers.Get(ns)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn ret\n}\n\nfunc (c *conn) connectClient() error {\n\trootHandler, ok := c.handlers.Get(rootNamespace)\n\tif !ok {\n\t\treturn errUnavailableRootHandler\n\t}\n\n\troot := newNamespaceConn(c, aliasRootNamespace, rootHandler.broadcast)\n\tc.namespaces.Set(rootNamespace, root)\n\n\troot.Join(root.Conn.ID())\n\n\tc.namespaces.Range(func(ns string, nc *namespaceConn) {\n\t\tnc.SetContext(c.Conn.Context())\n\t})\n\n\theader := parser.Header{\n\t\tType: parser.Connect,\n\t}\n\n\treturn c.encoder.Encode(header)\n}\n"
        },
        {
          "name": "connection.go",
          "type": "blob",
          "size": 2.6259765625,
          "content": "package socketio\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/googollee/go-socket.io/engineio\"\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\n// Conn is a connection in go-socket.io\ntype Conn interface {\n\tio.Closer\n\tNamespace\n\n\t// ID returns session id\n\tID() string\n\tURL() url.URL\n\tLocalAddr() net.Addr\n\tRemoteAddr() net.Addr\n\tRemoteHeader() http.Header\n}\n\ntype conn struct {\n\tengineio.Conn\n\n\tid         uint64\n\thandlers   *namespaceHandlers\n\tnamespaces *namespaces\n\n\tencoder *parser.Encoder\n\tdecoder *parser.Decoder\n\n\twriteChan chan parser.Payload\n\terrorChan chan error\n\tquitChan  chan struct{}\n\n\tcloseOnce sync.Once\n}\n\nfunc newConn(engineConn engineio.Conn, handlers *namespaceHandlers) *conn {\n\treturn &conn{\n\t\tConn:       engineConn,\n\t\tencoder:    parser.NewEncoder(engineConn),\n\t\tdecoder:    parser.NewDecoder(engineConn),\n\t\terrorChan:  make(chan error),\n\t\twriteChan:  make(chan parser.Payload),\n\t\tquitChan:   make(chan struct{}),\n\t\thandlers:   handlers,\n\t\tnamespaces: newNamespaces(),\n\t}\n}\n\nfunc (c *conn) Close() error {\n\tvar err error\n\n\tc.closeOnce.Do(func() {\n\t\t// for each namespace, leave all rooms, and call the disconnect handler.\n\t\tc.namespaces.Range(func(ns string, nc *namespaceConn) {\n\t\t\tif nh, _ := c.handlers.Get(ns); nh != nil && nh.onDisconnect != nil {\n\t\t\t\tnh.onDisconnect(nc, clientDisconnectMsg)\n\t\t\t}\n\t\t\tnc.LeaveAll()\n\t\t})\n\t\terr = c.Conn.Close()\n\n\t\tclose(c.quitChan)\n\t})\n\n\treturn err\n}\n\nfunc (c *conn) connect() error {\n\trootHandler, ok := c.handlers.Get(rootNamespace)\n\tif !ok {\n\t\treturn errUnavailableRootHandler\n\t}\n\n\troot := newNamespaceConn(c, aliasRootNamespace, rootHandler.broadcast)\n\tc.namespaces.Set(rootNamespace, root)\n\n\troot.Join(root.Conn.ID())\n\n\tc.namespaces.Range(func(ns string, nc *namespaceConn) {\n\t\tnc.SetContext(c.Conn.Context())\n\t})\n\n\theader := parser.Header{\n\t\tType: parser.Connect,\n\t}\n\n\tif err := c.encoder.Encode(header); err != nil {\n\t\treturn err\n\t}\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif ok {\n\t\t_, err := handler.dispatch(root, header)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *conn) nextID() uint64 {\n\tc.id++\n\n\treturn c.id\n}\n\nfunc (c *conn) write(header parser.Header, args ...reflect.Value) {\n\tdata := make([]interface{}, len(args))\n\n\tfor i := range data {\n\t\tdata[i] = args[i].Interface()\n\t}\n\n\tpkg := parser.Payload{\n\t\tHeader: header,\n\t\tData:   data,\n\t}\n\n\tselect {\n\tcase c.writeChan <- pkg:\n\tcase <-c.quitChan:\n\t\treturn\n\t}\n}\n\nfunc (c *conn) onError(namespace string, err error) {\n\tselect {\n\tcase c.errorChan <- newErrorMessage(namespace, err):\n\tcase <-c.quitChan:\n\t\treturn\n\t}\n}\n\nfunc (c *conn) namespace(nsp string) *namespaceHandler {\n\thandler, _ := c.handlers.Get(nsp)\n\treturn handler\n}\n"
        },
        {
          "name": "connection_handlers.go",
          "type": "blob",
          "size": 5.400390625,
          "content": "package socketio\n\nimport (\n\t\"log\"\n\n\t\"github.com/googollee/go-socket.io/logger\"\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\nvar emtpyFH = newAckFunc(func() {})\n\nfunc ackPacketHandler(c *conn, header parser.Header) error {\n\tnc, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\t_ = c.decoder.DiscardLast()\n\t\treturn nil\n\t}\n\n\tdefer nc.ack.Delete(header.ID)\n\n\trawFunc, ok := nc.ack.Load(header.ID)\n\tif !ok {\n\t\t// No function for this ack, but still need to read body\n\t\trawFunc = emtpyFH\n\t}\n\n\thandler, ok := rawFunc.(*funcHandler)\n\tif !ok {\n\t\t// This should never get here and would be solved with generic sync.Map\n\t\tlogger.Info(\"Incorrect Ack functinxo type\")\n\t\thandler = emtpyFH // keep going\n\t}\n\n\t// Read the body because Ack can have body as well\n\targs, err := c.decoder.DecodeArgs(handler.argTypes)\n\tif err != nil {\n\t\tlogger.Info(\"Error decoding the ACK message type\", \"namespace\", header.Namespace, \"eventType\", handler.argTypes, \"err\", err.Error())\n\t\tc.onError(header.Namespace, err)\n\t\treturn errDecodeArgs\n\t}\n\n\t// Return value is ignored\n\t_, err = handler.Call(args)\n\tif err != nil {\n\t\tlogger.Info(\"Error for event type\", \"namespace\", header.Namespace)\n\t\tc.onError(header.Namespace, err)\n\t\treturn errHandleDispatch\n\t}\n\n\treturn nil\n}\n\nfunc eventPacketHandler(c *conn, event string, header parser.Header) error {\n\tconn, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\t_ = c.decoder.DiscardLast()\n\t\treturn nil\n\t}\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif !ok {\n\t\t_ = c.decoder.DiscardLast()\n\t\tlogger.Info(\"missing handler for namespace\", \"namespace\", header.Namespace)\n\t\treturn nil\n\t}\n\n\targs, err := c.decoder.DecodeArgs(handler.getEventTypes(event))\n\tif err != nil {\n\t\tc.onError(header.Namespace, err)\n\t\tlogger.Info(\"Error decoding the message type\", \"namespace\", header.Namespace, \"event\", event, \"eventType\", handler.getEventTypes(event), \"err\", err.Error())\n\t\treturn errDecodeArgs\n\t}\n\n\tret, err := handler.dispatchEvent(conn, event, args...)\n\tif err != nil {\n\t\tc.onError(header.Namespace, err)\n\t\tlogger.Info(\"Error for event type\", \"namespace\", header.Namespace, \"event\", event)\n\t\treturn errHandleDispatch\n\t}\n\n\tif len(ret) > 0 || header.NeedAck {\n\t\theader.Type = parser.Ack\n\t\tc.write(header, ret...)\n\t}\n\n\treturn nil\n}\n\nfunc connectPacketHandler(c *conn, header parser.Header) error {\n\tif err := c.decoder.DiscardLast(); err != nil {\n\t\tc.onError(header.Namespace, err)\n\t\tlogger.Info(\"connectPacketHandler DiscardLast\", err, \"namespace\", header.Namespace)\n\t\treturn nil\n\t}\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif !ok {\n\t\tc.onError(header.Namespace, errFailedConnectNamespace)\n\t\tlogger.Info(\"connectPacketHandler get namespace handler\", \"namespace\", header.Namespace)\n\t\treturn errFailedConnectNamespace\n\t}\n\n\tconn, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\tconn = newNamespaceConn(c, header.Namespace, handler.broadcast)\n\t\tc.namespaces.Set(header.Namespace, conn)\n\t\tconn.Join(c.Conn.ID())\n\t}\n\n\t_, err := handler.dispatch(conn, header)\n\tif err != nil {\n\t\tlogger.Info(\"connectPacketHandler dispatch error\", \"namespace\", header.Namespace)\n\t\tlog.Println(\"dispatch connect packet\", err)\n\t\tc.onError(header.Namespace, err)\n\t\treturn errHandleDispatch\n\t}\n\n\tc.write(header)\n\n\treturn nil\n}\n\nfunc disconnectPacketHandler(c *conn, header parser.Header) error {\n\targs, err := c.decoder.DecodeArgs(defaultHeaderType)\n\tif err != nil {\n\t\tc.onError(header.Namespace, err)\n\t\treturn errDecodeArgs\n\t}\n\n\tconn, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\t_ = c.decoder.DiscardLast()\n\t\treturn nil\n\t}\n\n\tconn.LeaveAll()\n\n\tc.namespaces.Delete(header.Namespace)\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t_, err = handler.dispatch(conn, header, args...)\n\tif err != nil {\n\t\tlog.Println(\"dispatch disconnect packet\", err)\n\t\tc.onError(header.Namespace, err)\n\t\treturn errHandleDispatch\n\t}\n\n\treturn nil\n}\n\n// ////////////////////\n// Client\n// ////////////////////\n\nfunc clientConnectPacketHandler(c *conn, header parser.Header) error {\n\tif err := c.decoder.DiscardLast(); err != nil {\n\t\tlogger.Info(\"connectPacketHandler DiscardLast\", err, \"namespace\", header.Namespace)\n\t\tc.onError(header.Namespace, err)\n\t\treturn nil\n\t}\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif !ok {\n\t\tlogger.Info(\"connectPacketHandler get namespace handler\", \"namespace\", header.Namespace)\n\t\tc.onError(header.Namespace, errFailedConnectNamespace)\n\t\treturn errFailedConnectNamespace\n\t}\n\n\tconn, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\tconn = newNamespaceConn(c, header.Namespace, handler.broadcast)\n\t\tc.namespaces.Set(header.Namespace, conn)\n\t\tconn.Join(c.Conn.ID())\n\t}\n\n\t_, err := handler.dispatch(conn, header)\n\tif err != nil {\n\t\tlogger.Info(\"connectPacketHandler  dispatch\", \"namespace\", header.Namespace)\n\t\tlog.Println(\"dispatch connect packet\", err)\n\t\tc.onError(header.Namespace, err)\n\t\treturn errHandleDispatch\n\t}\n\n\treturn nil\n}\n\nfunc clientDisconnectPacketHandler(c *conn, header parser.Header) error {\n\targs, err := c.decoder.DecodeArgs(defaultHeaderType)\n\tif err != nil {\n\t\tc.onError(header.Namespace, err)\n\t\treturn errDecodeArgs\n\t}\n\n\tconn, ok := c.namespaces.Get(header.Namespace)\n\tif !ok {\n\t\t_ = c.decoder.DiscardLast()\n\t\treturn nil\n\t}\n\n\tconn.LeaveAll()\n\n\tc.namespaces.Delete(header.Namespace)\n\n\thandler, ok := c.handlers.Get(header.Namespace)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t_, err = handler.dispatch(conn, header, args...)\n\tif err != nil {\n\t\tlog.Println(\"dispatch disconnect packet\", err)\n\t\tc.onError(header.Namespace, err)\n\t\treturn errHandleDispatch\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "connection_handlers_test.go",
          "type": "blob",
          "size": 1.5625,
          "content": "package socketio\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/googollee/go-socket.io/engineio/session\"\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\ntype testStr struct {\n\tResult string `json:\"result,omitempty\"`\n}\n\ntype fakeReader struct {\n\tdata  [][]byte\n\tindex int\n\tbuf   *bytes.Buffer\n}\n\nfunc (r *fakeReader) NextReader() (session.FrameType, io.ReadCloser, error) {\n\tif r.index >= len(r.data) {\n\t\treturn 0, nil, io.EOF\n\t}\n\tr.buf = bytes.NewBuffer(r.data[r.index])\n\tft := session.BINARY\n\tif r.index == 0 {\n\t\tft = session.TEXT\n\t}\n\treturn ft, r, nil\n}\n\nfunc (r *fakeReader) Read(p []byte) (int, error) {\n\treturn r.buf.Read(p)\n}\n\nfunc (r *fakeReader) Close() error {\n\tr.index++\n\treturn nil\n}\n\nfunc TestAck(t *testing.T) {\n\tshould := assert.New(t)\n\tmust := require.New(t)\n\n\tnamespace := \"/test\"\n\tvar id uint64 = 12\n\tc := &conn{\n\t\thandlers:   newNamespaceHandlers(),\n\t\tnamespaces: newNamespaces(),\n\t\tdecoder:    parser.NewDecoder(&fakeReader{data: [][]byte{[]byte(\"3-/test,12[{\\\"result\\\":\\\"pass\\\"}]\")}}),\n\t}\n\n\tconn := newNamespaceConn(c, namespace, nil)\n\tc.namespaces.Set(namespace, conn)\n\n\theader := parser.Header{}\n\n\tcalled := false\n\tf := newAckFunc(func(t *testStr) {\n\t\tcalled = true\n\t\tshould.Equal(\"pass\", t.Result)\n\t})\n\tconn.ack.Store(id, f)\n\n\tevent := \"a\"\n\n\terr := c.decoder.DecodeHeader(&header, &event)\n\tmust.NoError(err)\n\tshould.Equal(parser.Ack, header.Type)\n\tshould.Equal(12, int(header.ID))\n\tshould.Equal(\"/test\", header.Namespace)\n\terr = ackPacketHandler(c, header)\n\tmust.NoError(err)\n\tmust.True(called)\n}\n"
        },
        {
          "name": "engineio",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.71875,
          "content": "package socketio\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// connect errors.\nvar (\n\terrUnavailableRootHandler = errors.New(\"root ('/') doesn't have a namespace handler\")\n\n\terrFailedConnectNamespace = errors.New(\"failed connect to namespace without handler\")\n)\n\n// common connection dispatch errors.\nvar (\n\terrHandleDispatch = errors.New(\"handler dispatch error\")\n\n\terrDecodeArgs = errors.New(\"decode args error\")\n)\n\ntype errorMessage struct {\n\tnamespace string\n\n\terr error\n}\n\nfunc (e errorMessage) Error() string {\n\treturn fmt.Sprintf(\"error in namespace: (%s) with error: (%s)\", e.namespace, e.err.Error())\n}\n\nfunc newErrorMessage(namespace string, err error) *errorMessage {\n\treturn &errorMessage{\n\t\tnamespace: namespace,\n\t\terr:       err,\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2607421875,
          "content": "module github.com/googollee/go-socket.io\n\ngo 1.16\n\nrequire (\n\tgithub.com/gofrs/uuid v4.4.0+incompatible\n\tgithub.com/gomodule/redigo v1.8.9\n\tgithub.com/gorilla/websocket v1.5.0\n\tgithub.com/stretchr/testify v1.8.4\n\tgolang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.3076171875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gofrs/uuid v4.4.0+incompatible h1:3qXRTX8/NbyulANqlc0lchS1gqAVxRgsuW1YrTJupqA=\ngithub.com/gofrs/uuid v4.4.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gomodule/redigo v1.8.9 h1:Sl3u+2BI/kk+VEatbj0scLdrFhjPmbxOc1myhDP41ws=\ngithub.com/gomodule/redigo v1.8.9/go.mod h1:7ArFNvsTjH8GMMzB4uy1snslv2BwmginuMs06a1uzZE=\ngithub.com/google/go-cmp v0.5.8/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=\ngithub.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\ngolang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1 h1:MGwJjxBy0HJshjDNfLsYO8xppfqWlA5ZT9OhtUUhTNw=\ngolang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1/go.mod h1:FXUEEKJgO7OQYeo8N01OfiKP8RXMtf6e8aTskBGqWdc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.6.0/go.mod h1:4mET923SAdbXp2ki8ey+zGs1SLqsuM2Y0uvdZR/fUNI=\ngolang.org/x/mod v0.11.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.1.0/go.mod h1:Cx3nUiGt4eDBEyega/BKRp+/AlGL8hYe7U9odMt2Cco=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.2.0/go.mod h1:y4OqIKeOV/fWJetJ8bXPU1sEVniLMIyDAZWeHdV+NTA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "handler.go",
          "type": "blob",
          "size": 1.3251953125,
          "content": "package socketio\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nconst (\n\tgoSocketIOConnInterface = \"Conn\"\n)\n\ntype funcHandler struct {\n\targTypes []reflect.Type\n\tf        reflect.Value\n}\n\nfunc (h *funcHandler) Call(args []reflect.Value) (ret []reflect.Value, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tvar ok bool\n\t\t\terr, ok = r.(error)\n\t\t\tif !ok {\n\t\t\t\terr = fmt.Errorf(\"event call error: %s\", r)\n\t\t\t}\n\t\t}\n\t}()\n\n\tret = h.f.Call(args)\n\n\treturn\n}\n\nfunc newEventFunc(f interface{}) *funcHandler {\n\tfv := reflect.ValueOf(f)\n\n\tif fv.Kind() != reflect.Func {\n\t\tpanic(\"event handler must be a func.\")\n\t}\n\tft := fv.Type()\n\n\tif ft.NumIn() < 1 || ft.In(0).Name() != goSocketIOConnInterface {\n\t\tpanic(\"handler function should be like func(socketio.Conn, ...)\")\n\t}\n\n\targTypes := make([]reflect.Type, ft.NumIn()-1)\n\tfor i := range argTypes {\n\t\targTypes[i] = ft.In(i + 1)\n\t}\n\n\tif len(argTypes) == 0 {\n\t\targTypes = nil\n\t}\n\n\treturn &funcHandler{\n\t\targTypes: argTypes,\n\t\tf:        fv,\n\t}\n}\n\nfunc newAckFunc(f interface{}) *funcHandler {\n\tfv := reflect.ValueOf(f)\n\n\tif fv.Kind() != reflect.Func {\n\t\tpanic(\"ack callback must be a func.\")\n\t}\n\n\tft := fv.Type()\n\targTypes := make([]reflect.Type, ft.NumIn())\n\n\tfor i := range argTypes {\n\t\targTypes[i] = ft.In(i)\n\t}\n\tif len(argTypes) == 0 {\n\t\targTypes = nil\n\t}\n\n\treturn &funcHandler{\n\t\targTypes: argTypes,\n\t\tf:        fv,\n\t}\n}\n"
        },
        {
          "name": "handler_test.go",
          "type": "blob",
          "size": 2.6494140625,
          "content": "package socketio\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewEventFunc(t *testing.T) {\n\ttests := []struct {\n\t\tf        interface{}\n\t\tok       bool\n\t\targTypes []interface{}\n\t}{\n\t\t{1, false, []interface{}{}},\n\t\t{func() {}, false, []interface{}{}},\n\t\t{func(int) {}, false, []interface{}{}},\n\t\t{func() error { return nil }, false, []interface{}{}},\n\n\t\t{func(Conn) {}, true, []interface{}{}},\n\t\t{func(Conn, int) {}, true, []interface{}{1}},\n\t\t{func(Conn, int) error { return nil }, true, []interface{}{1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%#v\", test.argTypes), func(t *testing.T) {\n\t\t\tshould := assert.New(t)\n\t\t\tmust := require.New(t)\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tmust.Equal(test.ok, r == nil)\n\t\t\t}()\n\n\t\t\th := newEventFunc(test.f)\n\t\t\tmust.Equal(len(test.argTypes), len(h.argTypes))\n\t\t\tfor i := range h.argTypes {\n\t\t\t\tshould.Equal(reflect.TypeOf(test.argTypes[i]), h.argTypes[i])\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewAckFunc(t *testing.T) {\n\ttests := []struct {\n\t\tf        interface{}\n\t\tok       bool\n\t\targTypes []interface{}\n\t}{\n\t\t{1, false, []interface{}{}},\n\n\t\t{func() {}, true, []interface{}{}},\n\t\t{func(int) {}, true, []interface{}{1}},\n\t\t{func(int) error { return nil }, true, []interface{}{1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%#v\", test.argTypes), func(t *testing.T) {\n\t\t\tshould := assert.New(t)\n\t\t\tmust := require.New(t)\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tmust.Equal(test.ok, r == nil)\n\t\t\t}()\n\n\t\t\th := newAckFunc(test.f)\n\t\t\tmust.Equal(len(test.argTypes), len(h.argTypes))\n\n\t\t\tfor i := range h.argTypes {\n\t\t\t\tshould.Equal(reflect.TypeOf(test.argTypes[i]), h.argTypes[i])\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHandlerCall(t *testing.T) {\n\ttests := []struct {\n\t\tf    interface{}\n\t\targs []interface{}\n\t\tok   bool\n\t\trets []interface{}\n\t}{\n\t\t{func() {}, []interface{}{1}, false, nil},\n\n\t\t{func() {}, nil, true, nil},\n\t\t{func(int) {}, []interface{}{1}, true, nil},\n\t\t{func() int { return 1 }, nil, true, []interface{}{1}},\n\t\t{func(int) int { return 1 }, []interface{}{1}, true, []interface{}{1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%#v\", test.f), func(t *testing.T) {\n\t\t\tshould := assert.New(t)\n\t\t\tmust := require.New(t)\n\n\t\t\th := newAckFunc(test.f)\n\n\t\t\targs := make([]reflect.Value, len(test.args))\n\t\t\tfor i := range args {\n\t\t\t\targs[i] = reflect.ValueOf(test.args[i])\n\t\t\t}\n\n\t\t\tretV, err := h.Call(args)\n\t\t\tmust.Equal(test.ok, err == nil)\n\n\t\t\tif len(retV) == len(test.rets) && len(test.rets) == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trets := make([]interface{}, len(retV))\n\t\t\tfor i := range rets {\n\t\t\t\trets[i] = retV[i].Interface()\n\t\t\t}\n\n\t\t\tshould.Equal(test.rets, rets)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 0.1162109375,
          "content": "package socketio\n\nimport \"github.com/gofrs/uuid\"\n\nfunc newV4UUID() string {\n\treturn uuid.Must(uuid.NewV4()).String()\n}\n"
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "namespace_conn.go",
          "type": "blob",
          "size": 2.0859375,
          "content": "package socketio\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\n// Namespace describes a communication channel that allows you to split the logic of your application\n// over a single shared connection.\ntype Namespace interface {\n\t// Context of this connection. You can save one context for one\n\t// connection, and share it between all handlers. The handlers\n\t// are called in one goroutine, so no need to lock context if it\n\t// only accessed in one connection.\n\tContext() interface{}\n\tSetContext(ctx interface{})\n\n\tNamespace() string\n\tEmit(eventName string, v ...interface{})\n\n\tJoin(room string)\n\tLeave(room string)\n\tLeaveAll()\n\tRooms() []string\n}\n\ntype namespaceConn struct {\n\t*conn\n\tbroadcast Broadcast\n\n\tnamespace string\n\tcontext   interface{}\n\n\tack sync.Map\n}\n\nfunc newNamespaceConn(conn *conn, namespace string, broadcast Broadcast) *namespaceConn {\n\treturn &namespaceConn{\n\t\tconn:      conn,\n\t\tnamespace: namespace,\n\t\tbroadcast: broadcast,\n\t}\n}\n\nfunc (nc *namespaceConn) SetContext(ctx interface{}) {\n\tnc.context = ctx\n}\n\nfunc (nc *namespaceConn) Context() interface{} {\n\treturn nc.context\n}\n\nfunc (nc *namespaceConn) Namespace() string {\n\treturn nc.namespace\n}\n\nfunc (nc *namespaceConn) Emit(eventName string, v ...interface{}) {\n\theader := parser.Header{\n\t\tType: parser.Event,\n\t}\n\n\tif nc.namespace != aliasRootNamespace {\n\t\theader.Namespace = nc.namespace\n\t}\n\n\tif l := len(v); l > 0 {\n\t\tlast := v[l-1]\n\t\tlastV := reflect.TypeOf(last)\n\n\t\tif lastV.Kind() == reflect.Func {\n\t\t\tf := newAckFunc(last)\n\n\t\t\theader.ID = nc.conn.nextID()\n\t\t\theader.NeedAck = true\n\n\t\t\tnc.ack.Store(header.ID, f)\n\t\t\tv = v[:l-1]\n\t\t}\n\t}\n\n\targs := make([]reflect.Value, len(v)+1)\n\targs[0] = reflect.ValueOf(eventName)\n\n\tfor i := 1; i < len(args); i++ {\n\t\targs[i] = reflect.ValueOf(v[i-1])\n\t}\n\n\tnc.conn.write(header, args...)\n}\n\nfunc (nc *namespaceConn) Join(room string) {\n\tnc.broadcast.Join(room, nc)\n}\n\nfunc (nc *namespaceConn) Leave(room string) {\n\tnc.broadcast.Leave(room, nc)\n}\n\nfunc (nc *namespaceConn) LeaveAll() {\n\tnc.broadcast.LeaveAll(nc)\n}\n\nfunc (nc *namespaceConn) Rooms() []string {\n\treturn nc.broadcast.Rooms(nc)\n}\n"
        },
        {
          "name": "namespace_handler.go",
          "type": "blob",
          "size": 2.375,
          "content": "package socketio\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\ntype namespaceHandler struct {\n\tbroadcast Broadcast\n\n\tevents     map[string]*funcHandler\n\teventsLock sync.RWMutex\n\n\tonConnect    func(conn Conn) error\n\tonDisconnect func(conn Conn, msg string)\n\tonError      func(conn Conn, err error)\n}\n\nfunc newNamespaceHandler(nsp string, adapterOpts *RedisAdapterOptions) *namespaceHandler {\n\tvar broadcast Broadcast\n\tif adapterOpts == nil {\n\t\tbroadcast = newBroadcast()\n\t} else {\n\t\tbroadcast, _ = newRedisBroadcast(nsp, adapterOpts)\n\t}\n\n\treturn &namespaceHandler{\n\t\tbroadcast: broadcast,\n\t\tevents:    make(map[string]*funcHandler),\n\t}\n}\n\nfunc (nh *namespaceHandler) OnConnect(f func(Conn) error) {\n\tnh.onConnect = f\n}\n\nfunc (nh *namespaceHandler) OnDisconnect(f func(Conn, string)) {\n\tnh.onDisconnect = f\n}\n\nfunc (nh *namespaceHandler) OnError(f func(Conn, error)) {\n\tnh.onError = f\n}\n\nfunc (nh *namespaceHandler) OnEvent(event string, f interface{}) {\n\tnh.eventsLock.Lock()\n\tdefer nh.eventsLock.Unlock()\n\n\tnh.events[event] = newEventFunc(f)\n}\n\nfunc (nh *namespaceHandler) getEventTypes(event string) []reflect.Type {\n\tnh.eventsLock.RLock()\n\tnamespaceHandler := nh.events[event]\n\tnh.eventsLock.RUnlock()\n\n\tif namespaceHandler != nil {\n\t\treturn namespaceHandler.argTypes\n\t}\n\n\treturn nil\n}\n\nfunc (nh *namespaceHandler) dispatch(conn Conn, header parser.Header, args ...reflect.Value) ([]reflect.Value, error) {\n\tswitch header.Type {\n\tcase parser.Connect:\n\t\tif nh.onConnect != nil {\n\t\t\treturn nil, nh.onConnect(conn)\n\t\t}\n\t\treturn nil, nil\n\n\tcase parser.Disconnect:\n\t\tif nh.onDisconnect != nil {\n\t\t\tnh.onDisconnect(conn, getDispatchMessage(args...))\n\t\t}\n\t\treturn nil, nil\n\n\tcase parser.Error:\n\t\tif nh.onError != nil {\n\t\t\tmsg := getDispatchMessage(args...)\n\t\t\tif msg == \"\" {\n\t\t\t\tmsg = \"parser error dispatch\"\n\t\t\t}\n\t\t\tnh.onError(conn, errors.New(msg))\n\t\t}\n\t}\n\n\treturn nil, parser.ErrInvalidPacketType\n}\n\nfunc (nh *namespaceHandler) dispatchEvent(conn Conn, event string, args ...reflect.Value) ([]reflect.Value, error) {\n\tnh.eventsLock.RLock()\n\tnamespaceHandler := nh.events[event]\n\tnh.eventsLock.RUnlock()\n\n\tif namespaceHandler == nil {\n\t\treturn nil, nil\n\t}\n\n\treturn namespaceHandler.Call(append([]reflect.Value{reflect.ValueOf(conn)}, args...))\n}\n\nfunc getDispatchMessage(args ...reflect.Value) string {\n\tvar msg string\n\tif len(args) > 0 {\n\t\tmsg = args[0].Interface().(string)\n\t}\n\n\treturn msg\n}\n"
        },
        {
          "name": "namespace_handler_test.go",
          "type": "blob",
          "size": 2.5263671875,
          "content": "package socketio\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\nfunc TestNamespaceHandler(t *testing.T) {\n\tshould := assert.New(t)\n\tmust := require.New(t)\n\n\th := newNamespaceHandler(t.Name(), nil)\n\n\tonConnectCalled := false\n\th.OnConnect(func(c Conn) error {\n\t\tonConnectCalled = true\n\t\treturn nil\n\t})\n\n\tdisconnectMsg := \"\"\n\th.OnDisconnect(func(c Conn, reason string) {\n\t\tdisconnectMsg = reason\n\t})\n\n\tvar onError error\n\th.OnError(func(conn Conn, err error) {\n\t\tonError = err\n\t})\n\n\theader := parser.Header{\n\t\tType: parser.Connect,\n\t}\n\n\t_, err := h.dispatch(&namespaceConn{}, header)\n\tmust.NoError(err)\n\n\tshould.True(onConnectCalled)\n\n\theader.Type = parser.Disconnect\n\n\t_, err = h.dispatch(&namespaceConn{}, header, []reflect.Value{reflect.ValueOf(\"disconnect\")}...)\n\tmust.NoError(err)\n\n\tshould.Equal(\"disconnect\", disconnectMsg)\n\n\theader.Type = parser.Error\n\n\t_, err = h.dispatch(&namespaceConn{}, header, []reflect.Value{reflect.ValueOf(\"failed\")}...)\n\tmust.Error(err)\n\n\tshould.Equal(onError.Error(), \"failed\")\n\n\theader.Type = parser.Event\n\targs := h.getEventTypes(\"not_exist\")\n\n\tshould.Nil(args)\n\n\tret, err := h.dispatchEvent(&namespaceConn{}, \"not_exist\")\n\tmust.NoError(err)\n\n\tshould.Nil(ret)\n}\n\nfunc TestNamespaceHandlerEvent(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\tevents   []string\n\t\thandlers []interface{}\n\n\t\tevent string\n\t\targs  []interface{}\n\n\t\tok  bool\n\t\tret []interface{}\n\t}{\n\t\t{\n\t\t\tname: \"string handler\",\n\n\t\t\tevents: []string{\"e\", \"n\"},\n\t\t\thandlers: []interface{}{\n\t\t\t\tfunc(c Conn, str string) string {\n\t\t\t\t\treturn \"handled \" + str\n\t\t\t\t},\n\t\t\t\tfunc(c Conn) {},\n\t\t\t},\n\n\t\t\tevent: \"e\",\n\t\t\targs:  []interface{}{\"str\"},\n\n\t\t\tok:  true,\n\t\t\tret: []interface{}{\"handled str\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tshould := assert.New(t)\n\t\t\tmust := require.New(t)\n\n\t\t\th := newNamespaceHandler(test.name, nil)\n\t\t\tfor i, e := range test.events {\n\t\t\t\th.OnEvent(e, test.handlers[i])\n\t\t\t}\n\n\t\t\ttarget := make([]reflect.Type, len(test.args))\n\t\t\targs := make([]reflect.Value, len(test.args))\n\n\t\t\tfor i := range test.args {\n\t\t\t\ttarget[i] = reflect.TypeOf(test.args[i])\n\t\t\t\targs[i] = reflect.ValueOf(test.args[i])\n\t\t\t}\n\n\t\t\ttypes := h.getEventTypes(test.event)\n\t\t\tshould.Equal(target, types)\n\n\t\t\tret, err := h.dispatchEvent(&namespaceConn{}, test.event, args...)\n\t\t\tmust.NoError(err)\n\n\t\t\tres := make([]interface{}, len(ret))\n\t\t\tfor i := range ret {\n\t\t\t\tres[i] = ret[i].Interface()\n\t\t\t}\n\n\t\t\tshould.Equal(test.ret, res)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "namespace_handlers.go",
          "type": "blob",
          "size": 0.560546875,
          "content": "package socketio\n\nimport \"sync\"\n\ntype namespaceHandlers struct {\n\thandlers map[string]*namespaceHandler\n\tmu       sync.RWMutex\n}\n\nfunc newNamespaceHandlers() *namespaceHandlers {\n\treturn &namespaceHandlers{\n\t\thandlers: make(map[string]*namespaceHandler),\n\t}\n}\n\nfunc (h *namespaceHandlers) Set(namespace string, handler *namespaceHandler) {\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\n\th.handlers[namespace] = handler\n}\n\nfunc (h *namespaceHandlers) Get(nsp string) (*namespaceHandler, bool) {\n\th.mu.RLock()\n\tdefer h.mu.RUnlock()\n\n\thandler, ok := h.handlers[nsp]\n\treturn handler, ok\n}\n"
        },
        {
          "name": "namespaces.go",
          "type": "blob",
          "size": 0.7587890625,
          "content": "package socketio\n\nimport \"sync\"\n\ntype namespaces struct {\n\tnamespaces map[string]*namespaceConn\n\tmu         sync.RWMutex\n}\n\nfunc newNamespaces() *namespaces {\n\treturn &namespaces{\n\t\tnamespaces: make(map[string]*namespaceConn),\n\t}\n}\n\nfunc (n *namespaces) Get(ns string) (*namespaceConn, bool) {\n\tn.mu.RLock()\n\tdefer n.mu.RUnlock()\n\n\tnamespace, ok := n.namespaces[ns]\n\treturn namespace, ok\n}\n\nfunc (n *namespaces) Set(ns string, conn *namespaceConn) {\n\tn.mu.Lock()\n\tdefer n.mu.Unlock()\n\n\tn.namespaces[ns] = conn\n}\n\nfunc (n *namespaces) Delete(ns string) {\n\tn.mu.Lock()\n\tdefer n.mu.Unlock()\n\n\tdelete(n.namespaces, ns)\n}\n\nfunc (n *namespaces) Range(fn func(ns string, nc *namespaceConn)) {\n\tn.mu.RLock()\n\tdefer n.mu.RUnlock()\n\n\tfor ns, nc := range n.namespaces {\n\t\tfn(ns, nc)\n\t}\n}\n"
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "redis_broadcast.go",
          "type": "blob",
          "size": 11.5419921875,
          "content": "package socketio\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\n// redisBroadcast gives Join, Leave & BroadcastTO server API support to socket.io along with room management\n// map of rooms where each room contains a map of connection id to connections in that room\ntype redisBroadcast struct {\n\tpub *redis.PubSubConn\n\tsub *redis.PubSubConn\n\n\tnsp        string\n\tuid        string\n\tkey        string\n\treqChannel string\n\tresChannel string\n\n\trequests map[string]interface{}\n\n\trooms map[string]map[string]Conn\n\n\tlock sync.RWMutex\n}\n\n// request types\nconst (\n\troomLenReqType   = \"0\"\n\tclearRoomReqType = \"1\"\n\tallRoomReqType   = \"2\"\n)\n\n// request structs\ntype roomLenRequest struct {\n\tRequestType string\n\tRequestID   string\n\tRoom        string\n\tnumSub      int        `json:\"-\"`\n\tmsgCount    int        `json:\"-\"`\n\tconnections int        `json:\"-\"`\n\tmutex       sync.Mutex `json:\"-\"`\n\tdone        chan bool  `json:\"-\"`\n}\n\ntype clearRoomRequest struct {\n\tRequestType string\n\tRequestID   string\n\tRoom        string\n\tUUID        string\n}\n\ntype allRoomRequest struct {\n\tRequestType string\n\tRequestID   string\n\trooms       map[string]bool `json:\"-\"`\n\tnumSub      int             `json:\"-\"`\n\tmsgCount    int             `json:\"-\"`\n\tmutex       sync.Mutex      `json:\"-\"`\n\tdone        chan bool       `json:\"-\"`\n}\n\n// response struct\ntype roomLenResponse struct {\n\tRequestType string\n\tRequestID   string\n\tConnections int\n}\n\ntype allRoomResponse struct {\n\tRequestType string\n\tRequestID   string\n\tRooms       []string\n}\n\nfunc newRedisBroadcast(nsp string, opts *RedisAdapterOptions) (*redisBroadcast, error) {\n\taddr := opts.getAddr()\n\tvar redisOpts []redis.DialOption\n\tif len(opts.Password) > 0 {\n\t\tredisOpts = append(redisOpts, redis.DialPassword(opts.Password))\n\t}\n\tif opts.DB > 0 {\n\t\tredisOpts = append(redisOpts, redis.DialDatabase(opts.DB))\n\t}\n\n\tpub, err := redis.Dial(opts.Network, addr, redisOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsub, err := redis.Dial(opts.Network, addr, redisOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubConn := &redis.PubSubConn{Conn: sub}\n\tpubConn := &redis.PubSubConn{Conn: pub}\n\n\tif err = subConn.PSubscribe(fmt.Sprintf(\"%s#%s#*\", opts.Prefix, nsp)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tuid := newV4UUID()\n\trbc := &redisBroadcast{\n\t\trooms:      make(map[string]map[string]Conn),\n\t\trequests:   make(map[string]interface{}),\n\t\tsub:        subConn,\n\t\tpub:        pubConn,\n\t\tkey:        fmt.Sprintf(\"%s#%s#%s\", opts.Prefix, nsp, uid),\n\t\treqChannel: fmt.Sprintf(\"%s-request#%s\", opts.Prefix, nsp),\n\t\tresChannel: fmt.Sprintf(\"%s-response#%s\", opts.Prefix, nsp),\n\t\tnsp:        nsp,\n\t\tuid:        uid,\n\t}\n\n\tif err = subConn.Subscribe(rbc.reqChannel, rbc.resChannel); err != nil {\n\t\treturn nil, err\n\t}\n\n\tgo rbc.dispatch()\n\n\treturn rbc, nil\n}\n\n// AllRooms gives list of all rooms available for redisBroadcast.\nfunc (bc *redisBroadcast) AllRooms() []string {\n\treq := allRoomRequest{\n\t\tRequestType: allRoomReqType,\n\t\tRequestID:   newV4UUID(),\n\t}\n\treqJSON, _ := json.Marshal(&req)\n\n\treq.rooms = make(map[string]bool)\n\tnumSub, _ := bc.getNumSub(bc.reqChannel)\n\treq.numSub = numSub\n\treq.done = make(chan bool, 1)\n\n\tbc.requests[req.RequestID] = &req\n\t_, err := bc.pub.Conn.Do(\"PUBLISH\", bc.reqChannel, reqJSON)\n\tif err != nil {\n\t\treturn []string{} // if error occurred,return empty\n\t}\n\n\t<-req.done\n\n\trooms := make([]string, 0, len(req.rooms))\n\tfor room := range req.rooms {\n\t\trooms = append(rooms, room)\n\t}\n\n\tdelete(bc.requests, req.RequestID)\n\treturn rooms\n}\n\n// Join joins the given connection to the redisBroadcast room.\nfunc (bc *redisBroadcast) Join(room string, connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tif _, ok := bc.rooms[room]; !ok {\n\t\tbc.rooms[room] = make(map[string]Conn)\n\t}\n\n\tbc.rooms[room][connection.ID()] = connection\n}\n\n// Leave leaves the given connection from given room (if exist)\nfunc (bc *redisBroadcast) Leave(room string, connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tif connections, ok := bc.rooms[room]; ok {\n\t\tdelete(connections, connection.ID())\n\n\t\tif len(connections) == 0 {\n\t\t\tdelete(bc.rooms, room)\n\t\t}\n\t}\n}\n\n// LeaveAll leaves the given connection from all rooms.\nfunc (bc *redisBroadcast) LeaveAll(connection Conn) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tfor room, connections := range bc.rooms {\n\t\tdelete(connections, connection.ID())\n\n\t\tif len(connections) == 0 {\n\t\t\tdelete(bc.rooms, room)\n\t\t}\n\t}\n}\n\n// Clear clears the room.\nfunc (bc *redisBroadcast) Clear(room string) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tdelete(bc.rooms, room)\n\tgo bc.publishClear(room)\n}\n\n// Send sends given event & args to all the connections in the specified room.\nfunc (bc *redisBroadcast) Send(room, event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tconnections, ok := bc.rooms[room]\n\tif ok {\n\t\tfor _, connection := range connections {\n\t\t\tconnection.Emit(event, args...)\n\t\t}\n\t}\n\n\tbc.publishMessage(room, event, args...)\n}\n\n// SendAll sends given event & args to all the connections to all the rooms.\nfunc (bc *redisBroadcast) SendAll(event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tfor _, connections := range bc.rooms {\n\t\tfor _, connection := range connections {\n\t\t\tconnection.Emit(event, args...)\n\t\t}\n\t}\n\tbc.publishMessage(\"\", event, args...)\n}\n\n// ForEach sends data returned by DataFunc, if room does not exits sends nothing.\nfunc (bc *redisBroadcast) ForEach(room string, f EachFunc) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\toccupants, ok := bc.rooms[room]\n\tif !ok {\n\t\treturn\n\t}\n\n\tfor _, connection := range occupants {\n\t\tf(connection)\n\t}\n}\n\n// Len gives number of connections in the room.\nfunc (bc *redisBroadcast) Len(room string) int {\n\treq := roomLenRequest{\n\t\tRequestType: roomLenReqType,\n\t\tRequestID:   newV4UUID(),\n\t\tRoom:        room,\n\t}\n\n\treqJSON, err := json.Marshal(&req)\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\tnumSub, err := bc.getNumSub(bc.reqChannel)\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\treq.numSub = numSub\n\n\treq.done = make(chan bool, 1)\n\n\tbc.requests[req.RequestID] = &req\n\t_, err = bc.pub.Conn.Do(\"PUBLISH\", bc.reqChannel, reqJSON)\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\t<-req.done\n\n\tdelete(bc.requests, req.RequestID)\n\treturn req.connections\n}\n\n// Rooms gives the list of all the rooms available for redisBroadcast in case of\n// no connection is given, in case of a connection is given, it gives\n// list of all the rooms the connection is joined to.\nfunc (bc *redisBroadcast) Rooms(connection Conn) []string {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tif connection == nil {\n\t\treturn bc.AllRooms()\n\t}\n\n\treturn bc.getRoomsByConn(connection)\n}\n\nfunc (bc *redisBroadcast) onMessage(channel string, msg []byte) error {\n\tchannelParts := strings.Split(channel, \"#\")\n\tnsp := channelParts[len(channelParts)-2]\n\tif bc.nsp != nsp {\n\t\treturn nil\n\t}\n\n\tuid := channelParts[len(channelParts)-1]\n\tif bc.uid == uid {\n\t\treturn nil\n\t}\n\n\tvar bcMessage map[string][]interface{}\n\terr := json.Unmarshal(msg, &bcMessage)\n\tif err != nil {\n\t\treturn errors.New(\"invalid broadcast message\")\n\t}\n\n\targs := bcMessage[\"args\"]\n\topts := bcMessage[\"opts\"]\n\n\troom, ok := opts[0].(string)\n\tif !ok {\n\t\treturn errors.New(\"invalid room\")\n\t}\n\n\tevent, ok := opts[1].(string)\n\tif !ok {\n\t\treturn errors.New(\"invalid event\")\n\t}\n\n\tif room != \"\" {\n\t\tbc.send(room, event, args...)\n\t} else {\n\t\tbc.sendAll(event, args...)\n\t}\n\n\treturn nil\n}\n\n// Get the number of subscribers of a channel.\nfunc (bc *redisBroadcast) getNumSub(channel string) (int, error) {\n\trs, err := bc.pub.Conn.Do(\"PUBSUB\", \"NUMSUB\", channel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tnumSub64, ok := rs.([]interface{})[1].(int64)\n\tif !ok {\n\t\treturn 0, errors.New(\"redis reply cast to int error\")\n\t}\n\treturn int(numSub64), nil\n}\n\n// Handle request from redis channel.\nfunc (bc *redisBroadcast) onRequest(msg []byte) {\n\tvar req map[string]string\n\n\tif err := json.Unmarshal(msg, &req); err != nil {\n\t\treturn\n\t}\n\n\tvar res interface{}\n\tswitch req[\"RequestType\"] {\n\tcase roomLenReqType:\n\t\tres = roomLenResponse{\n\t\t\tRequestType: req[\"RequestType\"],\n\t\t\tRequestID:   req[\"RequestID\"],\n\t\t\tConnections: len(bc.rooms[req[\"Room\"]]),\n\t\t}\n\t\tbc.publish(bc.resChannel, &res)\n\n\tcase allRoomReqType:\n\t\tres := allRoomResponse{\n\t\t\tRequestType: req[\"RequestType\"],\n\t\t\tRequestID:   req[\"RequestID\"],\n\t\t\tRooms:       bc.allRooms(),\n\t\t}\n\t\tbc.publish(bc.resChannel, &res)\n\n\tcase clearRoomReqType:\n\t\tif bc.uid == req[\"UUID\"] {\n\t\t\treturn\n\t\t}\n\t\tbc.clear(req[\"Room\"])\n\n\tdefault:\n\t}\n}\n\nfunc (bc *redisBroadcast) publish(channel string, msg interface{}) {\n\tresJSON, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = bc.pub.Conn.Do(\"PUBLISH\", channel, resJSON)\n\tif err != nil {\n\t\treturn\n\t}\n}\n\n// Handle response from redis channel.\nfunc (bc *redisBroadcast) onResponse(msg []byte) {\n\tvar res map[string]interface{}\n\n\terr := json.Unmarshal(msg, &res)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treq, ok := bc.requests[res[\"RequestID\"].(string)]\n\tif !ok {\n\t\treturn\n\t}\n\n\tswitch res[\"RequestType\"] {\n\tcase roomLenReqType:\n\t\troomLenReq := req.(*roomLenRequest)\n\n\t\troomLenReq.mutex.Lock()\n\t\troomLenReq.msgCount++\n\t\troomLenReq.connections += int(res[\"Connections\"].(float64))\n\t\troomLenReq.mutex.Unlock()\n\n\t\tif roomLenReq.numSub == roomLenReq.msgCount {\n\t\t\troomLenReq.done <- true\n\t\t}\n\n\tcase allRoomReqType:\n\t\tallRoomReq := req.(*allRoomRequest)\n\t\trooms, ok := res[\"Rooms\"].([]interface{})\n\t\tif !ok {\n\t\t\tallRoomReq.done <- true\n\t\t\treturn\n\t\t}\n\n\t\tallRoomReq.mutex.Lock()\n\t\tallRoomReq.msgCount++\n\t\tfor _, room := range rooms {\n\t\t\tallRoomReq.rooms[room.(string)] = true\n\t\t}\n\t\tallRoomReq.mutex.Unlock()\n\n\t\tif allRoomReq.numSub == allRoomReq.msgCount {\n\t\t\tallRoomReq.done <- true\n\t\t}\n\n\tdefault:\n\t}\n}\n\nfunc (bc *redisBroadcast) publishClear(room string) {\n\treq := clearRoomRequest{\n\t\tRequestType: clearRoomReqType,\n\t\tRequestID:   newV4UUID(),\n\t\tRoom:        room,\n\t\tUUID:        bc.uid,\n\t}\n\n\tbc.publish(bc.reqChannel, &req)\n}\n\nfunc (bc *redisBroadcast) clear(room string) {\n\tbc.lock.Lock()\n\tdefer bc.lock.Unlock()\n\n\tdelete(bc.rooms, room)\n}\n\nfunc (bc *redisBroadcast) send(room string, event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tconnections, ok := bc.rooms[room]\n\tif !ok {\n\t\treturn\n\t}\n\n\tfor _, connection := range connections {\n\t\tconnection.Emit(event, args...)\n\t}\n}\n\nfunc (bc *redisBroadcast) publishMessage(room string, event string, args ...interface{}) {\n\topts := make([]interface{}, 2)\n\topts[0] = room\n\topts[1] = event\n\n\tbcMessage := map[string][]interface{}{\n\t\t\"opts\": opts,\n\t\t\"args\": args,\n\t}\n\tbcMessageJSON, err := json.Marshal(bcMessage)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = bc.pub.Conn.Do(\"PUBLISH\", bc.key, bcMessageJSON)\n\tif err != nil {\n\t\treturn\n\t}\n}\n\nfunc (bc *redisBroadcast) sendAll(event string, args ...interface{}) {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\tfor _, connections := range bc.rooms {\n\t\tfor _, connection := range connections {\n\t\t\tconnection.Emit(event, args...)\n\t\t}\n\t}\n}\n\nfunc (bc *redisBroadcast) allRooms() []string {\n\tbc.lock.RLock()\n\tdefer bc.lock.RUnlock()\n\n\trooms := make([]string, 0, len(bc.rooms))\n\tfor room := range bc.rooms {\n\t\trooms = append(rooms, room)\n\t}\n\n\treturn rooms\n}\n\nfunc (bc *redisBroadcast) getRoomsByConn(connection Conn) []string {\n\tvar rooms []string\n\n\tfor room, connections := range bc.rooms {\n\t\tif _, ok := connections[connection.ID()]; ok {\n\t\t\trooms = append(rooms, room)\n\t\t}\n\t}\n\n\treturn rooms\n}\n\nfunc (bc *redisBroadcast) dispatch() {\n\tfor {\n\t\tswitch m := bc.sub.Receive().(type) {\n\t\tcase redis.Message:\n\t\t\tif m.Channel == bc.reqChannel {\n\t\t\t\tbc.onRequest(m.Data)\n\t\t\t\tbreak\n\t\t\t} else if m.Channel == bc.resChannel {\n\t\t\t\tbc.onResponse(m.Data)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\terr := bc.onMessage(m.Channel, m.Data)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase redis.Subscription:\n\t\t\tif m.Count == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase error:\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 7.6435546875,
          "content": "package socketio\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/gomodule/redigo/redis\"\n\n\t\"github.com/googollee/go-socket.io/engineio\"\n\t\"github.com/googollee/go-socket.io/logger\"\n\t\"github.com/googollee/go-socket.io/parser\"\n)\n\n// Server is a go-socket.io server.\ntype Server struct {\n\tengine *engineio.Server\n\n\thandlers *namespaceHandlers\n\n\tredisAdapter *RedisAdapterOptions\n}\n\n// NewServer returns a server.\nfunc NewServer(opts *engineio.Options) *Server {\n\treturn &Server{\n\t\thandlers: newNamespaceHandlers(),\n\t\tengine:   engineio.NewServer(opts),\n\t}\n}\n\n// Adapter sets redis broadcast adapter.\nfunc (s *Server) Adapter(opts *RedisAdapterOptions) (bool, error) {\n\topts = getOptions(opts)\n\tvar redisOpts []redis.DialOption\n\tif len(opts.Password) > 0 {\n\t\tredisOpts = append(redisOpts, redis.DialPassword(opts.Password))\n\t}\n\tif opts.DB > 0 {\n\t\tredisOpts = append(redisOpts, redis.DialDatabase(opts.DB))\n\t}\n\n\tconn, err := redis.Dial(opts.Network, opts.getAddr(), redisOpts...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\ts.redisAdapter = opts\n\n\treturn true, conn.Close()\n}\n\n// Close closes server.\nfunc (s *Server) Close() error {\n\treturn s.engine.Close()\n}\n\n// ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ts.engine.ServeHTTP(w, r)\n}\n\n// OnConnect set a handler function f to handle open event for namespace.\nfunc (s *Server) OnConnect(namespace string, f func(Conn) error) {\n\th := s.getNamespace(namespace)\n\tif h == nil {\n\t\th = s.createNamespace(namespace)\n\t}\n\n\th.OnConnect(f)\n}\n\n// OnDisconnect set a handler function f to handle disconnect event for namespace.\nfunc (s *Server) OnDisconnect(namespace string, f func(Conn, string)) {\n\th := s.getNamespace(namespace)\n\tif h == nil {\n\t\th = s.createNamespace(namespace)\n\t}\n\n\th.OnDisconnect(f)\n}\n\n// OnError set a handler function f to handle error for namespace.\nfunc (s *Server) OnError(namespace string, f func(Conn, error)) {\n\th := s.getNamespace(namespace)\n\tif h == nil {\n\t\th = s.createNamespace(namespace)\n\t}\n\n\th.OnError(f)\n}\n\n// OnEvent set a handler function f to handle event for namespace.\nfunc (s *Server) OnEvent(namespace, event string, f interface{}) {\n\th := s.getNamespace(namespace)\n\tif h == nil {\n\t\th = s.createNamespace(namespace)\n\t}\n\n\th.OnEvent(event, f)\n}\n\n// Serve serves go-socket.io server.\nfunc (s *Server) Serve() error {\n\tfor {\n\t\tconn, err := s.engine.Accept()\n\t\t//todo maybe need check EOF from Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo s.serveConn(conn)\n\t}\n}\n\n// JoinRoom joins given connection to the room.\nfunc (s *Server) JoinRoom(namespace string, room string, connection Conn) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.Join(room, connection)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// LeaveRoom leaves given connection from the room.\nfunc (s *Server) LeaveRoom(namespace string, room string, connection Conn) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.Leave(room, connection)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// LeaveAllRooms leaves the given connection from all rooms.\nfunc (s *Server) LeaveAllRooms(namespace string, connection Conn) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.LeaveAll(connection)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// ClearRoom clears the room.\nfunc (s *Server) ClearRoom(namespace string, room string) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.Clear(room)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// BroadcastToRoom broadcasts given event & args to all the connections in the room.\nfunc (s *Server) BroadcastToRoom(namespace string, room, event string, args ...interface{}) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.Send(room, event, args...)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// BroadcastToNamespace broadcasts given event & args to all the connections in the same namespace.\nfunc (s *Server) BroadcastToNamespace(namespace string, event string, args ...interface{}) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.SendAll(event, args...)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// RoomLen gives number of connections in the room.\nfunc (s *Server) RoomLen(namespace string, room string) int {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\treturn nspHandler.broadcast.Len(room)\n\t}\n\n\treturn -1\n}\n\n// Rooms gives list of all the rooms.\nfunc (s *Server) Rooms(namespace string) []string {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\treturn nspHandler.broadcast.Rooms(nil)\n\t}\n\n\treturn nil\n}\n\n// Count number of connections.\nfunc (s *Server) Count() int {\n\treturn s.engine.Count()\n}\n\n// Remove session from sessions pool. Fixed the sessions map leak(connections, mem).\nfunc (s *Server) Remove(sid string) {\n\ts.engine.Remove(sid)\n}\n\n// ForEach sends data by DataFunc, if room does not exit sends anything.\nfunc (s *Server) ForEach(namespace string, room string, f EachFunc) bool {\n\tnspHandler := s.getNamespace(namespace)\n\tif nspHandler != nil {\n\t\tnspHandler.broadcast.ForEach(room, f)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (s *Server) serveConn(conn engineio.Conn) {\n\tc := newConn(conn, s.handlers)\n\tif err := c.connect(); err != nil {\n\t\t_ = c.Close()\n\t\tif root, ok := s.handlers.Get(rootNamespace); ok && root.onError != nil {\n\t\t\troot.onError(nil, err)\n\t\t}\n\n\t\treturn\n\t}\n\n\tgo s.serveError(c)\n\tgo s.serveWrite(c)\n\tgo s.serveRead(c)\n}\n\nfunc (s *Server) serveError(c *conn) {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\n\t\ts.engine.Remove(c.Conn.ID())\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.quitChan:\n\t\t\treturn\n\t\tcase err := <-c.errorChan:\n\t\t\tvar errMsg *errorMessage\n\t\t\tif !errors.As(err, &errMsg) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif handler := c.namespace(errMsg.namespace); handler != nil {\n\t\t\t\tif handler.onError != nil {\n\t\t\t\t\tnsConn, ok := c.namespaces.Get(errMsg.namespace)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\thandler.onError(nsConn, errMsg.err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) serveWrite(c *conn) {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\n\t\ts.engine.Remove(c.Conn.ID())\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.quitChan:\n\t\t\treturn\n\t\tcase pkg := <-c.writeChan:\n\t\t\tif err := c.encoder.Encode(pkg.Header, pkg.Data); err != nil {\n\t\t\t\tc.onError(pkg.Header.Namespace, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) serveRead(c *conn) {\n\tdefer func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tlogger.Error(\"close connect:\", err)\n\t\t}\n\n\t\ts.engine.Remove(c.Conn.ID())\n\t}()\n\n\tvar event string\n\n\tfor {\n\t\tvar header parser.Header\n\n\t\tif err := c.decoder.DecodeHeader(&header, &event); err != nil {\n\t\t\tlogger.Error(\"DecodeHeader Error in serveRead\", err)\n\t\t\tc.onError(rootNamespace, err)\n\t\t\treturn\n\t\t}\n\n\t\tif header.Namespace == aliasRootNamespace {\n\t\t\theader.Namespace = rootNamespace\n\t\t}\n\n\t\tvar err error\n\t\tswitch header.Type {\n\t\tcase parser.Ack:\n\t\t\terr = ackPacketHandler(c, header)\n\t\tcase parser.Connect:\n\t\t\terr = connectPacketHandler(c, header)\n\t\tcase parser.Disconnect:\n\t\t\terr = disconnectPacketHandler(c, header)\n\t\tcase parser.Event:\n\t\t\terr = eventPacketHandler(c, event, header)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"serve read:\", err)\n\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Server) createNamespace(nsp string) *namespaceHandler {\n\tif nsp == aliasRootNamespace {\n\t\tnsp = rootNamespace\n\t}\n\n\thandler := newNamespaceHandler(nsp, s.redisAdapter)\n\ts.handlers.Set(nsp, handler)\n\n\treturn handler\n}\n\nfunc (s *Server) getNamespace(nsp string) *namespaceHandler {\n\tif nsp == aliasRootNamespace {\n\t\tnsp = rootNamespace\n\t}\n\n\tret, ok := s.handlers.Get(nsp)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn ret\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 0.2490234375,
          "content": "package socketio\n\nimport (\n\t\"reflect\"\n)\n\n// namespace\nconst (\n\taliasRootNamespace = \"/\"\n\trootNamespace      = \"\"\n)\n\n// message\nconst (\n\tclientDisconnectMsg = \"client namespace disconnect\"\n)\n\nvar (\n\tdefaultHeaderType = []reflect.Type{reflect.TypeOf(\"\")}\n)\n"
        },
        {
          "name": "upgrade workflow.md",
          "type": "blob",
          "size": 0.41796875,
          "content": "```mermaid\nsequenceDiagram\nclient->>server: dial\nserver->>client: reply open\nclient->>server: dial upgrade\nclient->>server: upgrade ping probe\nserver->>client: upgrade pong probe\nclient->>client: pause old conn\nclient->>client: switch old conn to upgraded conn\nclient->>server: upgrade\nserver->>server: pause old conn(return noop if waiting)\nserver->>server: switch old conn to upgraded conn\nserver->>server: close old conn\n```\n"
        }
      ]
    }
  ]
}