{
  "metadata": {
    "timestamp": 1736567693411,
    "page": 275,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-go/fx",
      "stars": 6057,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.8017578125,
          "content": "ignore:\n  - \"docs/ex/**/*.go\"\n  - \"internal/e2e/**/*.go\"\n\ncoverage:\n  range: 80..100\n  round: down\n  precision: 2\n\n  status:\n    project:                   # measuring the overall project coverage\n      default:                 # context, you can create multiple ones with custom titles\n        enabled: yes           # must be yes|true to enable this status\n        target: 90%             # specify the target coverage for each commit status\n                               #   option: \"auto\" (must increase from parent commit or pull request base)\n                               #   option: \"X%\" a static target percentage to hit\n        if_not_found: success  # if parent is not found report status as success, error, or failure\n        if_ci_failed: error    # if ci fails report status as success, error, or failure\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.125,
          "content": "/vendor\n/.bench\n*.mem\n*.cpu\n*.test\n*.log\n*.out\n*.html\n*.coverprofile\ncoverage.txt\n*.pprof\n/.bin\n/.cache\n/bin\n.vscode\n.mdoxcache\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 3.134765625,
          "content": "output:\n  # Make output more digestible with quickfix in vim/emacs/etc.\n  sort-results: true\n  print-issued-lines: false\n\nlinters:\n  # We'll track the golangci-lint default linters manually\n  # instead of letting them change without our control.\n  disable-all: true\n  enable:\n    # golangci-lint defaults:\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n\n    # Our own extras:\n    - gofumpt\n    - nolintlint # lints nolint directives\n    - revive\n    - errorlint\n\n    # License header check:\n    - goheader\n\nlinters-settings:\n  govet:\n    # These govet checks are disabled by default, but they're useful.\n    enable:\n      - niliness\n      - reflectvaluecompare\n      - sortslice\n      - unusedwrite\n\n  goheader:\n    values:\n      const:\n        COMPANY: 'Uber Technologies, Inc.'\n      regexp:\n        YEAR_RANGE: '\\d{4}(-\\d{4})?'\n    template: |-\n      Copyright (c) {{ YEAR_RANGE }} {{ COMPANY }}\n\n      Permission is hereby granted, free of charge, to any person obtaining a copy\n      of this software and associated documentation files (the \"Software\"), to deal\n      in the Software without restriction, including without limitation the rights\n      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n      copies of the Software, and to permit persons to whom the Software is\n      furnished to do so, subject to the following conditions:\n\n      The above copyright notice and this permission notice shall be included in\n      all copies or substantial portions of the Software.\n\n      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n      THE SOFTWARE.\n\n\nissues:\n  # Print all issues reported by all linters.\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\n  # Don't ignore some of the issues that golangci-lint considers okay.\n  # This includes documenting all exported entities.\n  exclude-use-default: false\n\n  exclude-rules:\n    # Don't warn on unused parameters.\n    # Parameter names are useful; replacing them with '_' is undesirable.\n    - linters: [revive]\n      text: 'unused-parameter: parameter \\S+ seems to be unused, consider removing or renaming it as _'\n\n    # staticcheck already has smarter checks for empty blocks.\n    # revive's empty-block linter has false positives.\n    # For example, as of writing this, the following is not allowed.\n    #   for foo() { }\n    - linters: [revive]\n      text: 'empty-block: this block is empty, you can remove it'\n\n    # It's okay if internal packages and examples in docs/\n    # don't have package comments.\n    - linters: [revive]\n      path: '.+/internal/.+|^internal/.+|^docs/.+'\n      text: 'should have a package comment'\n\n    # It's okay for tests to use dot imports.\n    - linters: [revive]\n      path: '_test\\.go$'\n      text: 'should not use dot imports'\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 18.634765625,
          "content": "---\nsearch:\n  exclude: true\n---\n\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## Unreleased\n- No changes yet.\n\n## [1.23.0](https://github.com/uber-go/fx/compare/v1.22.2...v1.22.3) - 2024-10-11\n\n### Added\n- Added `Runtime` to `fxevent.Run` event, which stores the runtime of\n  a constructor or a decorator that's run, including functions created\n  by `fx.Supply` and `fx.Replace`.\n\n### Changed\n- Overhauled the documentation website. (https://uber-go.github.io/fx/)\n\n## [1.22.2](https://github.com/uber-go/fx/compare/v1.22.1...v1.22.2) - 2024-08-07\n\n### Fixed\n- A deadlock with the relayer in signal receivers.\n\n### Changed\n- Upgrade Dig dependency to v1.18.0\n\n## [1.22.1](https://github.com/uber-go/fx/compare/v1.22.0...v1.22.1) - 2024-06-25\n\n### Fixed\n- Fx apps will only listen to signals when `.Run()`, `.Wait()`, or `.Done()`\n  are called, fixing a regression introduced in v1.19.0.\n\n## [1.22.0](https://github.com/uber-go/fx/compare/v1.21.1...v1.22.0) - 2024-05-30\n\n### Added\n- Add `fx.Self` which can be passed to the `fx.As` annotation to signify\n  that a type should be provided as itself.\n- Add `fxtest.EnforceTimeout` that can be passed to `fxtest.NewLifecycle`\n  to force `Start` and `Stop` to return context errors when hook context expires.\n\n### Changed\n- `fx.Private` can now be used with `fx.Supply`.\n\n### Fixed\n- Fx apps will no longer listen to OS signals when they are stopped,\n  solving blocking issues in programs that depended on OS signals\n  after an Fx app stops.\n\n## [1.21.1](https://github.com/uber-go/fx/compare/v1.21.0...v1.21.1) - 2024-04-24\n\n### Changed\n- Register Fx provides (e.g. fx.Lifecycle, fx.Shutdowner, fx.DotGraph) before\n  user provides, to increase likelihood of successful custom logger creation.\n\n## [1.21.0](https://github.com/uber-go/fx/compare/v1.20.1...v1.21.0) - 2024-03-13\n\n### Added\n- fxtest: Add WithTestLogger option that uses a `testing.TB` as the\n  Fx event logger.\n- An fxevent logger that can log events using a slog logger has been added.\n\n### Changed\n- Upgrade Dig dependency to v1.17.1\n\n## [1.20.1](https://github.com/uber-go/fx/compare/v1.20.0...v1.20.1) - 2023-10-17\n\n### Added\n- Provided, Decorated, Supplied, and Replaced events now include a trace\n  of module locations through which the option was given to the App.\n- wasi support.\n\n## [1.20.0](https://github.com/uber-go/fx/compare/v1.19.3...v1.20.0) - 2023-06-12\n\n### Added\n- A new event `fxevent.Run` is now emitted when Fx runs a constructor, decorator,\n  or supply/replace stub.\n\n### Changed\n- `fx.Populate` now works with `fx.Annotate`.\n- Upgrade Dig dependency to v1.17.0.\n\n## [1.19.3](https://github.com/uber-go/fx/compare/v1.19.2...v1.19.3) - 2023-04-17\n\n### Changed\n- Fixed several typos in docs.\n- WASM build support.\n- Annotating In and Out structs with From/As annotations generated invalid results.\n  The annotation check now blocks this.\n- `Shutdown`: Support calling from `Invoke`.\n\n### Deprecated\n- Deprecate `ShutdownTimeout` option.\n\n### Fixed\n- Respect Shutdowner ExitCode from calling `Run`.\n\n## [1.19.2](https://github.com/uber-go/fx/compare/v1.19.1...v1.19.2) - 2023-02-21\n\n### Changed\n- Update Dig dependency to v1.16.1.\n\n## [1.19.1](https://github.com/uber-go/fx/compare/v1.19.0...v1.19.1) - 2023-01-10\n\n### Changed\n- Calling `fx.Stop()` after the `App` has already stopped no longer errors out.\n\n### Fixed\n- Addressed a regression in 1.19.0 release which caused apps to ignore OS signals\n  after running for startTimeout duration.\n\n## [1.19.0](https://github.com/uber-go/fx/compare/v1.18.2...v1.19.0) - 2023-01-03\n\n### Added\n- `fx.RecoverFromPanics` Option which allows Fx to recover from user-provided constructors\n  and invoked functions.\n- `fx.Private` that allows the constructor to limit the scope of its outputs to the wrapping\n  `fx.Module`.\n- `ExitCode` ShutdownOption which allows setting custom exit code at the end of app\n  lifecycle.\n- `Wait` which returns a channel that can be used for waiting on application shutdown.\n- fxevent/ZapLogger now exposes `UseLogLevel` and `UseErrorLevel` methods to set\n  the level of the Zap logs produced by it.\n- Add lifecycle hook-convertible methods: `StartHook`, `StopHook`, `StartStopHook`\n  that can be used with more function signatures.\n\n### Changed\n- `fx.WithLogger` can now be passed at `fx.Module` level, setting custom logger at\n  `Module` scope instead of the whole `App`.\n\n### Fixed\n- `fx.OnStart` and `fx.OnStop` Annotations now work with annotated types that was\n  provided by the annotated constructor.\n- fxevent/ZapLogger: Errors from `fx.Supply` are now logged at `Error` level, not\n  `Info`.\n- A race condition in lifecycle Start/Stop methods.\n- Typos in docs.\n\n## [1.18.2](https://github.com/uber-go/fx/compare/v1.18.1...v1.18.2) - 2022-09-28\n\n### Added\n- Clarify ordering of `Invoke`s in `Module`s.\n\n### Fixed\n- Fix `Decorate` not being applied to transitive dependencies at root `App` level.\n\n## [1.18.1](https://github.com/uber-go/fx/compare/v1.18.0...v1.18.1) - 2022-08-08\n\n### Fixed\n- Fix a nil panic when `nil` is passed to `OnStart` and `OnStop` lifecycle methods.\n\n## [1.18.0](https://github.com/uber-go/fx/compare/v1.17.1...v1.18.0) - 2022-08-05\n\n### Added\n- Soft value groups that lets you specify value groups as best-effort dependencies.\n- `fx.OnStart` and `fx.OnStop` annotations which lets you annotate dependencies to provide\n  OnStart and OnStop lifecycle hooks.\n- A new `fxevent.Replaced` event written to `fxevent.Logger` following an `fx.Replace`.\n\n### Fixed\n- Upgrade Dig dependency to v1.14.1 to address a couple of issues with decorations. Refer to\n  Dig v1.14.1 release notes for more details.\n- `fx.WithLogger` no longer ignores decorations and replacements of types that\n  it depends on.\n- Don't run lifecycle hooks if the context for them has already expired.\n- `App.Start` and `App.Stop` no longer deadlock if the OnStart/OnStop hook\n  exits the current goroutine.\n- `fxevent.ConsoleLogger` no longer emits an extraneous argument for the\n  Supplied event.\n\n### Deprecated\n- `fx.Extract` in favor of `fx.Populate`.\n\n## [1.17.1](https://github.com/uber-go/fx/compare/v1.17.0...v1.17.1) - 2022-03-23\n\n### Added\n- Logging for provide/invoke/decorate now includes the associated `fx.Module` name.\n\n## [1.17.0](https://github.com/uber-go/fx/compare/v1.16.0...v1.17.0) - 2022-02-28\n\n### Added\n- Add `fx.Module` which scopes any modifications made to the dependency graph.\n- Add `fx.Decorate` and `fx.Replace` that lets you modify a dependency graph with decorators.\n- Add `fxevent.Decorated` event which gets emitted upon a dependency getting decorated.\n\n### Changed\n- `fx.Annotate`: Validate that `fx.In` or `fx.Out` structs are not passed to it.\n- `fx.Annotate`: Upon failure to Provide, the error contains the actual location\n  of the provided constructor.\n\n## [1.16.0](https://github.com/uber-go/fx/compare/v1.15.0...v1.16.0) - 2021-12-02\n\n### Added\n- Add the ability to provide a function as multiple interfaces at once using `fx.As`.\n\n### Changed\n- `fx.Annotate`: support variadic functions, and feeding value groups into them.\n\n### Fixed\n- Fix an issue where OnStop hooks weren't getting called on SIGINT on Windows.\n- Fix a data race between app.Done() and shutdown.\n\n## [1.15.0](https://github.com/uber-go/fx/compare/v1.14.2...v1.15.0) - 2021-11-08\n\n### Added\n- Add `fx.Annotate` to allow users to provide parameter and result tags easily without\n  having to create `fx.In` or `fx.Out` structs.\n- Add `fx.As` that allows users to annotate a constructor to provide its result type(s) as\n  interface(s) that they implement instead of the types themselves.\n\n### Fixed\n- Fix `fxevent.Stopped` not being logged when `App.Stop` is called.\n- Fix `fxevent.Started` or `fxevent.Stopped` not being logged when start or\n  stop times out.\n\n## [1.14.2](https://github.com/uber-go/fx/compare/v1.14.1...v1.14.2) - 2021-08-16\n\n### Changed\n- For `fxevent` console implementation: no longer log non-error case for `fxevent.Invoke`\n  event, while for zap implementation, start logging `fx.Invoking` case without stack.\n\n## [1.14.1](https://github.com/uber-go/fx/compare/v1.14.0...v1.14.1) - 2021-08-16\n\n### Changed\n- `fxevent.Invoked` was being logged at `Error` level even upon successful `Invoke`.\n  This was changed to log at `Info` level when `Invoke` succeeded.\n\n## [1.14.0](https://github.com/uber-go/fx/compare/v1.13.1...v1.14.0) - 2021-08-12\n\n### Added\n- Introduce the new `fx.WithLogger` option. Provide a constructor for\n  `fxevent.Logger` objects with it to customize how Fx logs events.\n- Add new `fxevent` package that exposes events from Fx in a structured way.\n  Use this to write custom logger implementations for use with the\n  `fx.WithLogger` option.\n- Expose and log additional information when lifecycle hooks time out.\n\n### Changed\n- Fx now emits structured JSON logs by default. These may be parsed and\n  processed by log ingestion systems.\n- `fxtest.Lifecycle` now logs to the provided `testing.TB` instead of stderr.\n- `fx.In` and `fx.Out` are now type aliases instead of structs.\n\n## [1.13.1](https://github.com/uber-go/fx/compare/v1.13.0...v1.13.1) - 2020-08-19\n\n### Fixed\n- Fix minimum version constraint for dig. `fx.ValidateGraph` requires at least\n  dig 1.10.\n\n## [1.13.0](https://github.com/uber-go/fx/compare/v1.12.0...v1.13.0) - 2020-06-16\n\n### Added\n- Added `fx.ValidateGraph` which allows graph cycle validation and dependency correctness\n  without running anything. This is useful if `fx.Invoke` has side effects, does I/O, etc.\n\n## [1.12.0](https://github.com/uber-go/fx/compare/v1.11.0...v1.12.0) - 2020-04-09\n\n### Added\n- Added `fx.Supply` to provide externally created values to Fx containers\n  without building anonymous constructors.\n\n### Changed\n- Drop library dependency on development tools.\n\n## [1.11.0](https://github.com/uber-go/fx/compare/v1.10.0...v1.11.0) - 2020-04-01\n\n### Added\n- Value groups can use the `flatten` option to indicate values in a slice should\n  be provided individually rather than providing the slice itself. See package\n  documentation for details.\n\n## [1.10.0](https://github.com/uber-go/fx/compare/v1.9.0...v1.10.0) - 2019-11-20\n\n### Added\n- All `fx.Option`s now include readable string representations.\n- Report stack traces when `fx.Provide` and `fx.Invoke` calls fail. This\n  should make these errors more debuggable.\n\n### Changed\n- Migrated to Go modules.\n\n## [1.9.0](https://github.com/uber-go/fx/compare/v1.8.0...v1.9.0) - 2019-01-22\n\n### Added\n- Add the ability to shutdown Fx applications from inside the container. See\n  the Shutdowner documentation for details.\n- Add `fx.Annotated` to allow users to provide named values without creating a\n  new constructor.\n\n## [1.8.0](https://github.com/uber-go/fx/compare/v1.7.1...v1.8.0) - 2018-11-06\n\n### Added\n- Provide DOT graph of dependencies in the container.\n\n## [1.7.1](https://github.com/uber-go/fx/compare/v1.7.0...v1.7.1) - 2018-09-26\n\n### Fixed\n- Make `fxtest.New` ensure that the app was created successfully. Previously,\n  it would return the app (similar to `fx.New`, which expects the user to verify\n  the error).\n- Update dig container to defer acyclic validation until after Invoke. Application\n  startup time should improve proportional to the size of the dependency graph.\n- Fix a goroutine leak in `fxtest.Lifecycle`.\n\n## [1.7.0](https://github.com/uber-go/fx/compare/v1.6.0...v1.7.0) - 2018-08-16\n\n### Added\n- Add `fx.ErrorHook` option to allow users to provide `ErrorHandler`s on invoke\n  failures.\n- `VisualizeError` returns the visualization wrapped in the error if available.\n\n## [1.6.0](https://github.com/uber-go/fx/compare/v1.5.0...v1.6.0) - 2018-06-12\n\n### Added\n- Add `fx.Error` option to short-circuit application startup.\n\n## [1.5.0](https://github.com/uber-go/fx/compare/v1.4.0...v1.5.0) - 2018-04-11\n\n### Added\n- Add `fx.StartTimeout` and `fx.StopTimeout` to make configuring application\n  start and stop timeouts easier.\n- Export the default start and stop timeout as `fx.DefaultTimeout`.\n\n### Fixed\n- Make `fxtest` respect the application's start and stop timeouts.\n\n## [1.4.0](https://github.com/uber-go/fx/compare/v1.3.0...v1.4.0) - 2017-12-07\n\n### Added\n- Add `fx.Populate` to populate variables with values from the dependency\n  injection container without requiring intermediate structs.\n\n## [1.3.0](https://github.com/uber-go/fx/compare/v1.2.0...v1.3.0) - 2017-11-28\n\n### Changed\n- Improve readability of hook logging in addition to provide and invoke.\n\n### Fixed\n- Fix bug which caused the OnStop for a lifecycle hook to be called even if it\n  failed to start.\n\n## [1.2.0](https://github.com/uber-go/fx/compare/v1.1.0...v1.2.0) - 2017-09-06\n\n### Added\n- Add `fx.NopLogger` which disables the Fx application's log output.\n\n## [1.1.0](https://github.com/uber-go/fx/compare/v1.0.0...v1.1.0) - 2017-08-22\n\n### Changed\n- Improve readability of start up logging.\n\n## [1.0.0](https://github.com/uber-go/fx/compare/v1.0.0-rc2...v1.0.0) - 2017-07-31\n\nFirst stable release: no breaking changes will be made in the 1.x series.\n\n### Added\n- `fx.Extract` now supports `fx.In` tags on target structs.\n\n### Changed\n- **[Breaking]** Rename `fx.Inject` to `fx.Extract`.\n- **[Breaking]** Rename `fxtest.Must*` to `fxtest.Require*`.\n\n### Removed\n- **[Breaking]** Remove `fx.Timeout` and `fx.DefaultTimeout`.\n\n## [1.0.0-rc2](https://github.com/uber-go/fx/compare/v1.0.0-rc1...v1.0.0-rc2) - 2017-07-21\n\n- **[Breaking]** Lifecycle hooks now take a context.\n- Add `fx.In` and `fx.Out` which exposes optional and named types.\n  Modules should embed these types instead of relying on `dig.In` and `dig.Out`.\n- Add an `Err` method to retrieve the underlying errors during the dependency\n  graph construction. The same error is also returned from `Start`.\n- Graph resolution now happens as part of `fx.New`, rather than at the beginning\n  of `app.Start`. This allows inspection of the graph errors through `app.Err()`\n  before the decision to start the app.\n- Add a `Logger` option, which allows users to send Fx's logs to different\n  sink.\n- Add `fxtest.App`, which redirects log output to the user's `testing.TB` and\n  provides some lifecycle helpers.\n\n## [1.0.0-rc1](https://github.com/uber-go/fx/compare/v1.0.0-beta4...v1.0.0-rc1) - 2017-06-20\n\n- **[Breaking]** Providing types into `fx.App` and invoking functions are now\n  options passed during application construction. This makes users'\n  interactions with modules and collections of modules identical.\n- **[Breaking]** `TestLifecycle` is now in a separate `fxtest` subpackage.\n- Add `fx.Inject()` to pull values from the container into a struct.\n\n## [1.0.0-beta4](https://github.com/uber-go/fx/compare/v1.0.0-beta3...v1.0.0-beta4) - 2017-06-12\n\n- **[Breaking]** Monolithic framework, as released in initial betas, has been\n  broken into smaller pieces as a result of recent advances in `dig` library.\n  This is a radical departure from the previous direction, but it needed to\n  be done for the long-term good of the project.\n- **[Breaking]** `Module interface` has been scoped all the way down to being\n  *a single dig constructor*. This allows for very sophisticated module\n  compositions. See `go.uber.org/dig` for more information on the constructors.\n- **[Breaking]** `package config` has been moved to its own repository.\n  see `go.uber.org/config` for more information.\n- `fx.Lifecycle` has been added for modules to hook into the framework\n  lifecycle events.\n- `service.Host` interface which composed a number of primitives together\n  (configuration, metrics, tracing) has been deprecated in favor of\n  `fx.App`.\n\n## [1.0.0-beta3](https://github.com/uber-go/fx/compare/v1.0.0-beta2...v1.0.0-beta3) - 2017-03-28\n\n- **[Breaking]** Environment config provider was removed. If you were using\n  environment variables to override YAML values, see config documentation for\n  more information.\n- **[Breaking]** Simplify Provider interface: remove `Scope` method from the\n  `config.Provider` interface, one can use either ScopedProvider and Value.Get()\n  to access sub fields.\n- Add `task.MustRegister` convenience function which fails fast by panicking\n  Note that this should only be used during app initialization, and is provided\n  to avoid repetetive error checking for services which register many tasks.\n- Expose options on task module to disable execution. This will allow users to\n  enqueue and consume tasks on different clusters.\n- **[Breaking]** Rename Backend interface `Publish` to `Enqueue`. Created a new\n  `ExecuteAsync` method that will kick off workers to consume tasks and this is\n  subsumed by module Start.\n- **[Breaking]** Rename package `uhttp/client` to `uhttp/uhttpclient` for clarity.\n- **[Breaking]** Rename `PopulateStruct` method in value to `Populate`.\n  The method can now populate not only structs, but anything: slices,\n  maps, builtin types and maps.\n- **[Breaking]** `package dig` has moved from `go.uber.org/fx/dig` to a new home\n  at `go.uber.org/dig`.\n- **[Breaking]** Pass a tracer the `uhttp/uhttpclient` constructor explicitly, instead\n  of using a global tracer. This will allow to use http client in parallel tests.\n\n## [1.0.0-beta2](https://github.com/uber-go/fx/compare/v1.0.0-beta1...v1.0.0-beta2) - 2017-03-09\n\n- **[Breaking]** Remove `ulog.Logger` interface and expose `*zap.Logger` directly.\n- **[Breaking]** Rename config and module from `modules.rpc` to `modules.yarpc`\n- **[Breaking]** Rename config key from `modules.http` to `modules.uhttp` to match\n  the module name\n- **[Breaking]** Upgrade `zap` to `v1.0.0-rc.3` (now go.uber.org/zap, was\n  github.com/uber-go/zap)\n- Remove now-unused `config.IsDevelopmentEnv()` helper to encourage better\n  testing practices. Not a breaking change as nobody is using this func\n  themselves according to our code search tool.\n- Log `traceID` and `spanID` in hex format to match Jaeger UI. Upgrade Jaeger to\n  min version 2.1.0\n  and use jaeger's adapters for jaeger and tally initialization.\n- Tally now supports reporting histogram samples for a bucket. Upgrade Tally to 2.1.0\n- **[Breaking]** Make new module naming consistent `yarpc.ThriftModule` to\n  `yarpc.New`, `task.NewModule`\n  to `task.New`\n- **[Breaking]** Rename `yarpc.CreateThriftServiceFunc` to `yarpc.ServiceCreateFunc`\n  as it is not thrift-specific.\n- Report version metrics for company-wide version usage information.\n- Allow configurable service name and module name via service options.\n- DIG constructors now support returning a tuple with the second argument being\n  an error.\n\n## 1.0.0-beta1 - 2017-02-20\n\nThis is the first beta release of the framework, where we invite users to start\nbuilding services on it and provide us feedback. **Warning** we are not\npromising API compatibility between beta releases and the final 1.0.0 release.\nIn fact, we expect our beta user feedback to require some changes to the way\nthings work. Once we reach 1.0, we will provider proper version compatibility.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 7.0625,
          "content": "---\nsearch:\n  exclude: true\n---\n\n# Contributing\n\nThanks for helping to make Fx better for everyone!\n\nIf you'd like to add new exported APIs,\nplease [open an issue](https://github.com/uber-go/fx/issues/new)\ndescribing your proposal.\nDiscussing API changes ahead of time makes pull request review much smoother.\n\n!!! tip\n\n    You'll need to sign [Uber's CLA](https://cla-assistant.io/uber-go/fx)\n    before we can accept any of your contributions.\n    If necessary, a bot will remind\n    you to accept the CLA when you open your pull request.\n\n\n## Contribute code\n\nSet up your local development environment to contribute to Fx.\n\n1. [Fork](https://github.com/uber-go/fx/fork), then clone the repository.\n\n    === \"Git\"\n\n        ```bash\n        git clone https://github.com/your_github_username/fx.git\n        cd fx\n        git remote add upstream https://github.com/uber-go/fx.git\n        git fetch upstream\n        ```\n\n    === \"GitHub CLI\"\n\n        ```bash\n        gh repo fork --clone uber-go/fx\n        ```\n\n2. Install Fx's dependencies:\n\n     ```bash\n     go mod download\n     ```\n\n3. Verify that tests and other checks pass locally.\n\n     ```bash\n     make lint\n     make test\n     ```\n\n     Note that for `make lint` to work,\n     you must be using the latest stable version of Go.\n     If you're on an older version, you can still contribute your change,\n     but we may discover style violations when you open the pull request.\n\nNext, make your changes.\n\n1. Create a new feature branch.\n\n     ```bash\n     git checkout master\n     git pull\n     git checkout -b cool_new_feature\n     ```\n\n2. Make your changes, and verify that all tests and lints still pass.\n\n     ```bash\n     $EDITOR app.go\n     make lint\n     make test\n     ```\n\n3. When you're satisfied with the change,\n   push it to your fork and make a pull request.\n\n    === \"Git\"\n\n        ```bash\n        git push origin cool_new_feature\n        # Open a PR at https://github.com/uber-go/fx/compare\n        ```\n\n    === \"GitHub CLI\"\n\n        ```bash\n        gh pr create\n        ```\n\nAt this point, you're waiting on us to review your changes.\nWe *try* to respond to issues and pull requests within a few business days,\nand we may suggest some improvements or alternatives.\nOnce your changes are approved, one of the project maintainers will merge them.\n\nThe review process will go more smoothly if you:\n\n- add tests for new functionality\n- write a [good commit message](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)\n- maintain backward compatibility\n- follow our [style guide](https://github.com/uber-go/guide/blob/master/style.md)\n\n## Contribute documentation\n\nTo contribute documentation to Fx,\n\n1. Set up your local development environment\n   as you would to [contribute code](#contribute-code).\n\n2. [Install uv](https://docs.astral.sh/uv/getting-started/installation/).\n   We use this to manage our Python dependencies.\n\n3. Run the development server.\n\n     ```bash\n     make serve\n     ```\n\n4. Make your changes.\n\nDocumentation changes should adhere to the guidance laid out below.\n\n### Document by purpose\n\nDocumentation is organized in one of the following categories.\n\n- **Tutorials**: These hold step-by-step instructions for an end-to-end project\n  that a beginner could follow along to.\n  Don't spend time explaining things.\n  If explanations are available elsewhere, link to them.\n  These are entry points to answer the prompt,\n  \"I don't know what Fx is, show me what it can do,\"\n  so there won't be too many of these.\n- **Explanations**: These hold long-form explanations of concepts and ideas.\n  These are intended to build an understanding of Fx.\n  Feel free to go wild here--use learning aids like diagrams, tables, etc.\n- **How-tos**: These are step-by-step instructions for a *specific problem*.\n  Unlike tutorials, these are not meant to be end-to-end.\n  Feel free to leave things out, make assumptions,\n  or provide options (\"if you're doing this, do this\").\n  As with tutorials, don't spend time explaining;\n  link to explanations elsewhere.\n\nAs an example,\n\n- A tutorial will use lifecycle hooks as part of\n  a larger set of instructions for a full end-to-end application.\n- An explanation will explain what lifecycle hooks are, how they work,\n  when and how you should use them, and link to relevant APIs and guides.\n- A how-to guide will demonstrate how to use lifecycle hooks\n  with an HTTP server, a gRPC server, etc.\n\nExplanations and how-to guides are often on the same page,\nbut they should be in distinct sections.\n\nThis separation is inspired by the\n[Divio documentation system](https://documentation.divio.com/),\n\n### Formatting\n\n#### ATX-style headers\n\nUse ATX-style headers (`#`-prefixed),\nnot Setext-style (underlined with `===` or `---`).\n\n```markdown\nBad header\n==========\n\n## Good header\n```\n\n#### Semantic Line Breaks\n\n- **Do not** write overly long lines of text\n- **Do not** \"reflow\" Markdown paragraphs\n- **Do** use [Semantic Line Breaks](https://sembr.org/) to break these lines down\n\n```markdown\nThis is a bad paragraph because it's really long, all on one line. When I open this in a text editor, I'll have to scroll right.\n\nThis is a bad paragraph because even though it's not all one one line, it adds\nline breaks when it reaches the line length limit. This means that anytime I\nchange anything in this paragraph, I have to \"reflow\" it, which will change\nother lines and make the change I'm making more difficult to review.\n\nThis is a good paragraph. It uses semantic line breaks.\nI can add words or modify an existing sentence,\nor even parts of a sentence,\neasily and without affecting other lines.\nWhen I change something, the actual change I made is easy to review.\nMarkdown will reflow this into a \"normal\" pargraph when rendering.\n```\n\n### Test everything\n\nAll code samples in documentation must be buildable and testable.\n\nTo make this possible, we put code samples in the \"ex/\" directory,\nand use the [PyMdown Snippets extension](https://facelessuser.github.io/pymdown-extensions/extensions/snippets/)\nto include them in the documentation.\n\nTo include code snippets in your documentation,\ntake the following steps:\n\n1. Add source code under the `ex/` directory.\n   Usually, the file will be placed in a directory\n   with a name matching the documentation file\n   that will include the snippet.\n\n     For example,\n     for src/annotation.md, examples will reside in ex/annotation/.\n\n2. Inside the source file, name regions of code with comments in the forms:\n\n     ```\n     // --8<-- [start:name]\n     ...\n     // --8<-- [end:name]\n     ```\n\n     Where `name` is the name of the snippet.\n     For example:\n\n     ```go\n     // --8<-- [start:New]\n     func New() *http.Server {\n         // ...\n     }\n     // --8<-- [end:New]\n     ```\n\n3. Include the snippet in a code block with the following syntax:\n\n    ```markdown\n    ```go\n    ;--8<-- \"path/to/file.go:name\"\n    ```\n\n    Where `path/to/file.go` is the path to the file containing the snippet\n    relative to the `ex/` directory,\n    and `name` is the name of the snippet.\n\n    You can include multiple snippets from the same file like so:\n\n    ```\n    ;--8<-- \"path/to/file.go:snippet1\"\n    ;--8<-- \"path/to/file.go:snippet2\"\n    ```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "Copyright (c) 2016-2018 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.439453125,
          "content": "# Directory containing the Makefile.\nPROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))\n\nexport GOBIN ?= $(PROJECT_ROOT)/bin\nexport PATH := $(GOBIN):$(PATH)\n\nFXLINT = $(GOBIN)/fxlint\n\nMODULES = . ./tools ./docs ./internal/e2e\n\n# 'make cover' should not run on docs by default.\n# We run that separately explicitly on a specific platform.\nCOVER_MODULES ?= $(filter-out ./docs,$(MODULES))\n\n.PHONY: all\nall: build lint test\n\n.PHONY: build\nbuild:\n\tgo build ./...\n\n.PHONY: lint\nlint: golangci-lint tidy-lint fx-lint\n\n.PHONY: test\ntest:\n\t@$(foreach dir,$(MODULES),(cd $(dir) && go test -race ./...) &&) true\n\n.PHONY: cover\ncover:\n\t@$(foreach dir,$(COVER_MODULES), \\\n\t\t(cd $(dir) && \\\n\t\techo \"[cover] $(dir)\" && \\\n\t\tgo test -race -coverprofile=cover.out -coverpkg=./... ./... && \\\n\t\tgo tool cover -html=cover.out -o cover.html) &&) true\n\n.PHONY: tidy\ntidy:\n\t@$(foreach dir,$(MODULES),(cd $(dir) && go mod tidy) &&) true\n\n.PHONY: docs\ndocs:\n\tcd docs && make build\n\n.PHONY: golangci-lint\ngolangci-lint:\n\t@$(foreach mod,$(MODULES), \\\n\t\t(cd $(mod) && \\\n\t\techo \"[lint] golangci-lint: $(mod)\" && \\\n\t\tgolangci-lint run --path-prefix $(mod)) &&) true\n\n.PHONY: tidy-lint\ntidy-lint:\n\t@$(foreach mod,$(MODULES), \\\n\t\t(cd $(mod) && \\\n\t\techo \"[lint] tidy: $(mod)\" && \\\n\t\tgo mod tidy && \\\n\t\tgit diff --exit-code -- go.mod go.sum) &&) true\n\n.PHONY: fx-lint\nfx-lint: $(FXLINT)\n\t@$(FXLINT) ./...\n\n$(FXLINT): tools/cmd/fxlint/main.go\n\tcd tools && go install go.uber.org/fx/tools/cmd/fxlint\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.7119140625,
          "content": "# :unicorn: Fx [![GoDoc](https://pkg.go.dev/badge/go.uber.org/fx)](https://pkg.go.dev/go.uber.org/fx) [![Github release](https://img.shields.io/github/release/uber-go/fx.svg)](https://github.com/uber-go/fx/releases) [![Build Status](https://github.com/uber-go/fx/actions/workflows/go.yml/badge.svg)](https://github.com/uber-go/fx/actions/workflows/go.yml) [![Coverage Status](https://codecov.io/gh/uber-go/fx/branch/master/graph/badge.svg)](https://codecov.io/gh/uber-go/fx/branch/master) [![Go Report Card](https://goreportcard.com/badge/go.uber.org/fx)](https://goreportcard.com/report/go.uber.org/fx)\n\nFx is a dependency injection system for Go.\n\n**Benefits**\n\n- Eliminate globals: Fx helps you remove global state from your application.\n  No more `init()` or global variables. Use Fx-managed singletons.\n- Code reuse: Fx lets teams within your organization build loosely-coupled\n  and well-integrated shareable components.\n- Battle tested: Fx is the backbone of nearly all Go services at Uber.\n\nSee our [docs](https://uber-go.github.io/fx/) to get started and/or\nlearn more about Fx.\n\n## Installation\n\nUse Go modules to install Fx in your application.\n\n```shell\ngo get go.uber.org/fx@v1\n```\n\n## Getting started\n\nTo get started with Fx, [start here](https://uber-go.github.io/fx/get-started/).\n\n## Stability\n\nThis library is `v1` and follows [SemVer](https://semver.org/) strictly.\n\nNo breaking changes will be made to exported APIs before `v2.0.0`.\n\nThis project follows the [Go Release Policy](https://golang.org/doc/devel/release.html#policy). Each major\nversion of Go is supported until there are two newer major releases.\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/uber-go/fx.svg)](https://starchart.cc/uber-go/fx)\n\n"
        },
        {
          "name": "annotated.go",
          "type": "blob",
          "size": 49.517578125,
          "content": "// Copyright (c) 2020-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Annotated annotates a constructor provided to Fx with additional options.\n//\n// For example,\n//\n//\tfunc NewReadOnlyConnection(...) (*Connection, error)\n//\n//\tfx.Provide(fx.Annotated{\n//\t  Name: \"ro\",\n//\t  Target: NewReadOnlyConnection,\n//\t})\n//\n// Is equivalent to,\n//\n//\ttype result struct {\n//\t  fx.Out\n//\n//\t  Connection *Connection `name:\"ro\"`\n//\t}\n//\n//\tfx.Provide(func(...) (result, error) {\n//\t  conn, err := NewReadOnlyConnection(...)\n//\t  return result{Connection: conn}, err\n//\t})\n//\n// Annotated cannot be used with constructors which produce fx.Out objects.\n// When used with [Supply], Target is a value instead of a constructor.\n//\n// This type represents a less powerful version of the [Annotate] construct;\n// prefer [Annotate] where possible.\ntype Annotated struct {\n\t// If specified, this will be used as the name for all non-error values returned\n\t// by the constructor. For more information on named values, see the documentation\n\t// for the fx.Out type.\n\t//\n\t// A name option may not be provided if a group option is provided.\n\tName string\n\n\t// If specified, this will be used as the group name for all non-error values returned\n\t// by the constructor. For more information on value groups, see the package documentation.\n\t//\n\t// A group option may not be provided if a name option is provided.\n\t//\n\t// Similar to group tags, the group name may be followed by a `,flatten`\n\t// option to indicate that each element in the slice returned by the\n\t// constructor should be injected into the value group individually.\n\tGroup string\n\n\t// Target is the constructor or value being annotated with fx.Annotated.\n\tTarget interface{}\n}\n\nfunc (a Annotated) String() string {\n\tvar fields []string\n\tif len(a.Name) > 0 {\n\t\tfields = append(fields, fmt.Sprintf(\"Name: %q\", a.Name))\n\t}\n\tif len(a.Group) > 0 {\n\t\tfields = append(fields, fmt.Sprintf(\"Group: %q\", a.Group))\n\t}\n\tif a.Target != nil {\n\t\tfields = append(fields, fmt.Sprintf(\"Target: %v\", fxreflect.FuncName(a.Target)))\n\t}\n\treturn fmt.Sprintf(\"fx.Annotated{%v}\", strings.Join(fields, \", \"))\n}\n\nvar (\n\t// field used for embedding fx.In type in generated struct.\n\t_inAnnotationField = reflect.StructField{\n\t\tName:      \"In\",\n\t\tType:      reflect.TypeOf(In{}),\n\t\tAnonymous: true,\n\t}\n\t// field used for embedding fx.Out type in generated struct.\n\t_outAnnotationField = reflect.StructField{\n\t\tName:      \"Out\",\n\t\tType:      reflect.TypeOf(Out{}),\n\t\tAnonymous: true,\n\t}\n)\n\n// Annotation specifies how to wrap a target for [Annotate].\n// It can be used to set up additional options for a constructor,\n// or with [Supply], for a value.\ntype Annotation interface {\n\tapply(*annotated) error\n\tbuild(*annotated) (interface{}, error)\n}\n\nvar (\n\t_typeOfError = reflect.TypeOf((*error)(nil)).Elem()\n\t_nilError    = reflect.Zero(_typeOfError)\n)\n\n// annotationError is a wrapper for an error that was encountered while\n// applying annotation to a function. It contains the specific error\n// that it encountered as well as the target interface that was attempted\n// to be annotated.\ntype annotationError struct {\n\ttarget interface{}\n\terr    error\n}\n\nfunc (e *annotationError) Error() string {\n\treturn e.err.Error()\n}\n\n// Unwrap the wrapped error.\nfunc (e *annotationError) Unwrap() error {\n\treturn e.err\n}\n\ntype paramTagsAnnotation struct {\n\ttags []string\n}\n\nvar _ Annotation = paramTagsAnnotation{}\nvar (\n\terrTagSyntaxSpace            = errors.New(`multiple tags are not separated by space`)\n\terrTagKeySyntax              = errors.New(\"tag key is invalid, Use group, name or optional as tag keys\")\n\terrTagValueSyntaxQuote       = errors.New(`tag value should start with double quote. i.e. key:\"value\" `)\n\terrTagValueSyntaxEndingQuote = errors.New(`tag value should end in double quote. i.e. key:\"value\" `)\n)\n\n// Collections of key value pairs within a tag should be separated by a space.\n// Eg: `group:\"some\" optional:\"true\"`.\nfunc verifyTagsSpaceSeparated(tagIdx int, tag string) error {\n\tif tagIdx > 0 && tag != \"\" && tag[0] != ' ' {\n\t\treturn errTagSyntaxSpace\n\t}\n\treturn nil\n}\n\n// verify tag values are delimited with double quotes.\nfunc verifyValueQuote(value string) (string, error) {\n\t// starting quote should be a double quote\n\tif value[0] != '\"' {\n\t\treturn \"\", errTagValueSyntaxQuote\n\t}\n\t// validate tag value is within quotes\n\ti := 1\n\tfor i < len(value) && value[i] != '\"' {\n\t\tif value[i] == '\\\\' {\n\t\t\ti++\n\t\t}\n\t\ti++\n\t}\n\tif i >= len(value) {\n\t\treturn \"\", errTagValueSyntaxEndingQuote\n\t}\n\treturn value[i+1:], nil\n}\n\n// Check whether the tag follows valid struct.\n// format and returns an error if it's invalid. (i.e. not following\n// tag:\"value\" space-separated list )\n// Currently dig accepts only 'name', 'group', 'optional' as valid tag keys.\nfunc verifyAnnotateTag(tag string) error {\n\ttagIdx := 0\n\tvalidKeys := map[string]struct{}{\"group\": {}, \"optional\": {}, \"name\": {}}\n\tfor ; tag != \"\"; tagIdx++ {\n\t\tif err := verifyTagsSpaceSeparated(tagIdx, tag); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti := 0\n\t\tif strings.TrimSpace(tag) == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// parsing the key i.e. till reaching colon :\n\t\tfor i < len(tag) && tag[i] != ':' {\n\t\t\ti++\n\t\t}\n\t\tkey := strings.TrimSpace(tag[:i])\n\t\tif _, ok := validKeys[key]; !ok {\n\t\t\treturn errTagKeySyntax\n\t\t}\n\t\tvalue, err := verifyValueQuote(tag[i+1:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttag = value\n\t}\n\treturn nil\n}\n\n// Given func(T1, T2, T3, ..., TN), this generates a type roughly\n// equivalent to,\n//\n//   struct {\n//     fx.In\n//\n//     Field1 T1 `$tags[0]`\n//     Field2 T2 `$tags[1]`\n//     ...\n//     FieldN TN `$tags[N-1]`\n//   }\n//\n// If there has already been a ParamTag that was applied, this\n// will return an error.\n//\n// If the tag is invalid and has mismatched quotation for example,\n// (`tag_name:\"tag_value') , this will return an error.\n\nfunc (pt paramTagsAnnotation) apply(ann *annotated) error {\n\tif len(ann.ParamTags) > 0 {\n\t\treturn errors.New(\"cannot apply more than one line of ParamTags\")\n\t}\n\tfor _, tag := range pt.tags {\n\t\tif err := verifyAnnotateTag(tag); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tann.ParamTags = pt.tags\n\treturn nil\n}\n\n// build builds and returns a constructor after applying a ParamTags annotation\nfunc (pt paramTagsAnnotation) build(ann *annotated) (interface{}, error) {\n\tparamTypes, remap := pt.parameters(ann)\n\tresultTypes, _ := ann.currentResultTypes()\n\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\targs = remap(args)\n\t\treturn origFn.Call(args)\n\t})\n\treturn newFn.Interface(), nil\n}\n\n// parameters returns the type for the parameters of the annotated function,\n// and a function that maps the arguments of the annotated function\n// back to the arguments of the target function.\nfunc (pt paramTagsAnnotation) parameters(ann *annotated) (\n\ttypes []reflect.Type,\n\tremap func([]reflect.Value) []reflect.Value,\n) {\n\tft := reflect.TypeOf(ann.Target)\n\ttypes = make([]reflect.Type, ft.NumIn())\n\tfor i := 0; i < ft.NumIn(); i++ {\n\t\ttypes[i] = ft.In(i)\n\t}\n\n\t// No parameter annotations. Return the original types\n\t// and an identity function.\n\tif len(pt.tags) == 0 {\n\t\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\t\treturn args\n\t\t}\n\t}\n\n\t// Turn parameters into an fx.In struct.\n\tinFields := []reflect.StructField{_inAnnotationField}\n\n\t// there was a variadic argument, so it was pre-transformed\n\tif len(types) > 0 && isIn(types[0]) {\n\t\tparamType := types[0]\n\n\t\tfor i := 1; i < paramType.NumField(); i++ {\n\t\t\torigField := paramType.Field(i)\n\t\t\tfield := reflect.StructField{\n\t\t\t\tName: origField.Name,\n\t\t\t\tType: origField.Type,\n\t\t\t\tTag:  origField.Tag,\n\t\t\t}\n\t\t\tif i-1 < len(pt.tags) {\n\t\t\t\tfield.Tag = reflect.StructTag(pt.tags[i-1])\n\t\t\t}\n\n\t\t\tinFields = append(inFields, field)\n\t\t}\n\n\t\ttypes = []reflect.Type{reflect.StructOf(inFields)}\n\t\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\t\tparam := args[0]\n\t\t\targs[0] = reflect.New(paramType).Elem()\n\t\t\tfor i := 1; i < paramType.NumField(); i++ {\n\t\t\t\targs[0].Field(i).Set(param.Field(i))\n\t\t\t}\n\t\t\treturn args\n\t\t}\n\t}\n\n\tfor i, t := range types {\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: t,\n\t\t}\n\t\tif i < len(pt.tags) {\n\t\t\tfield.Tag = reflect.StructTag(pt.tags[i])\n\t\t}\n\n\t\tinFields = append(inFields, field)\n\t}\n\n\ttypes = []reflect.Type{reflect.StructOf(inFields)}\n\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\tparams := args[0]\n\t\targs = args[:0]\n\t\tfor i := 0; i < ft.NumIn(); i++ {\n\t\t\targs = append(args, params.Field(i+1))\n\t\t}\n\t\treturn args\n\t}\n}\n\n// ParamTags is an Annotation that annotates the parameter(s) of a function.\n//\n// When multiple tags are specified, each tag is mapped to the corresponding\n// positional parameter.\n// For example, the following will refer to a named database connection,\n// and the default, unnamed logger:\n//\n//\tfx.Annotate(func(log *log.Logger, conn *sql.DB) *Handler {\n//\t\t// ...\n//\t}, fx.ParamTags(\"\", `name:\"ro\"`))\n//\n// ParamTags cannot be used in a function that takes an fx.In struct as a\n// parameter.\nfunc ParamTags(tags ...string) Annotation {\n\treturn paramTagsAnnotation{tags}\n}\n\ntype resultTagsAnnotation struct {\n\ttags []string\n}\n\nvar _ Annotation = resultTagsAnnotation{}\n\n// Given func(T1, T2, T3, ..., TN), this generates a type roughly\n// equivalent to,\n//\n//\tstruct {\n//\t  fx.Out\n//\n//\t  Field1 T1 `$tags[0]`\n//\t  Field2 T2 `$tags[1]`\n//\t  ...\n//\t  FieldN TN `$tags[N-1]`\n//\t}\n//\n// If there has already been a ResultTag that was applied, this\n// will return an error.\n//\n// If the tag is invalid and has mismatched quotation for example,\n// (`tag_name:\"tag_value') , this will return an error.\nfunc (rt resultTagsAnnotation) apply(ann *annotated) error {\n\tif len(ann.ResultTags) > 0 {\n\t\treturn errors.New(\"cannot apply more than one line of ResultTags\")\n\t}\n\tfor _, tag := range rt.tags {\n\t\tif err := verifyAnnotateTag(tag); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tann.ResultTags = rt.tags\n\treturn nil\n}\n\n// build builds and returns a constructor after applying a ResultTags annotation\nfunc (rt resultTagsAnnotation) build(ann *annotated) (interface{}, error) {\n\tparamTypes := ann.currentParamTypes()\n\tresultTypes, remapResults := rt.results(ann)\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\tresults := origFn.Call(args)\n\t\treturn remapResults(results)\n\t})\n\treturn newFn.Interface(), nil\n}\n\n// results returns the types of the results of the annotated function,\n// and a function that maps the results of the target function,\n// into a result compatible with the annotated function.\nfunc (rt resultTagsAnnotation) results(ann *annotated) (\n\ttypes []reflect.Type,\n\tremap func([]reflect.Value) []reflect.Value,\n) {\n\ttypes, hasError := ann.currentResultTypes()\n\n\tif hasError {\n\t\ttypes = types[:len(types)-1]\n\t}\n\n\t// No result annotations. Return the original types\n\t// and an identity function.\n\tif len(rt.tags) == 0 {\n\t\treturn types, func(results []reflect.Value) []reflect.Value {\n\t\t\treturn results\n\t\t}\n\t}\n\n\t// if there's no Out struct among the return types, there was no As annotation applied\n\t// just replace original result types with an Out struct and apply tags\n\tvar (\n\t\tnewOut       outStructInfo\n\t\texistingOuts []reflect.Type\n\t)\n\n\tnewOut.Fields = []reflect.StructField{_outAnnotationField}\n\tnewOut.Offsets = []int{}\n\n\tfor i, t := range types {\n\t\tif !isOut(t) {\n\t\t\t// this must be from the original function.\n\t\t\t// apply the tags\n\t\t\tfield := reflect.StructField{\n\t\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\t\tType: t,\n\t\t\t}\n\t\t\tif i < len(rt.tags) {\n\t\t\t\tfield.Tag = reflect.StructTag(rt.tags[i])\n\t\t\t}\n\t\t\tnewOut.Offsets = append(newOut.Offsets, len(newOut.Fields))\n\t\t\tnewOut.Fields = append(newOut.Fields, field)\n\t\t\tcontinue\n\t\t}\n\t\t// this must be from an As annotation\n\t\t// apply the tags to the existing type\n\t\ttaggedFields := make([]reflect.StructField, t.NumField())\n\t\ttaggedFields[0] = _outAnnotationField\n\t\tfor j, tag := range rt.tags {\n\t\t\tif j+1 < t.NumField() {\n\t\t\t\tfield := t.Field(j + 1)\n\t\t\t\ttaggedFields[j+1] = reflect.StructField{\n\t\t\t\t\tName: field.Name,\n\t\t\t\t\tType: field.Type,\n\t\t\t\t\tTag:  reflect.StructTag(tag),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texistingOuts = append(existingOuts, reflect.StructOf(taggedFields))\n\t}\n\n\tresType := reflect.StructOf(newOut.Fields)\n\n\toutTypes := []reflect.Type{resType}\n\t// append existing outs back to outTypes\n\toutTypes = append(outTypes, existingOuts...)\n\tif hasError {\n\t\toutTypes = append(outTypes, _typeOfError)\n\t}\n\n\treturn outTypes, func(results []reflect.Value) []reflect.Value {\n\t\tvar (\n\t\t\toutErr     error\n\t\t\toutResults []reflect.Value\n\t\t)\n\t\toutResults = append(outResults, reflect.New(resType).Elem())\n\n\t\ttIdx := 0\n\t\tfor i, r := range results {\n\t\t\tif i == len(results)-1 && hasError {\n\t\t\t\t// If hasError and this is the last item,\n\t\t\t\t// we are guaranteed that this is an error\n\t\t\t\t// object.\n\t\t\t\tif err, _ := r.Interface().(error); err != nil {\n\t\t\t\t\toutErr = err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i < len(newOut.Offsets) {\n\t\t\t\tif fieldIdx := newOut.Offsets[i]; fieldIdx > 0 {\n\t\t\t\t\t// fieldIdx 0 is an invalid index\n\t\t\t\t\t// because it refers to uninitialized\n\t\t\t\t\t// outs and would point to fx.Out in the\n\t\t\t\t\t// struct definition. We need to check this\n\t\t\t\t\t// to prevent panic from setting fx.Out to\n\t\t\t\t\t// a value.\n\t\t\t\t\toutResults[0].Field(fieldIdx).Set(r)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif isOut(r.Type()) {\n\t\t\t\ttIdx++\n\t\t\t\tif tIdx < len(outTypes) {\n\t\t\t\t\tnewResult := reflect.New(outTypes[tIdx]).Elem()\n\t\t\t\t\tfor j := 1; j < outTypes[tIdx].NumField(); j++ {\n\t\t\t\t\t\tnewResult.Field(j).Set(r.Field(j))\n\t\t\t\t\t}\n\t\t\t\t\toutResults = append(outResults, newResult)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif hasError {\n\t\t\tif outErr != nil {\n\t\t\t\toutResults = append(outResults, reflect.ValueOf(outErr))\n\t\t\t} else {\n\t\t\t\toutResults = append(outResults, _nilError)\n\t\t\t}\n\t\t}\n\n\t\treturn outResults\n\t}\n}\n\n// ResultTags is an Annotation that annotates the result(s) of a function.\n// When multiple tags are specified, each tag is mapped to the corresponding\n// positional result.\n//\n// For example, the following will produce a named database connection.\n//\n//\tfx.Annotate(func() (*sql.DB, error) {\n//\t\t// ...\n//\t}, fx.ResultTags(`name:\"ro\"`))\n//\n// ResultTags cannot be used on a function that returns an fx.Out struct.\nfunc ResultTags(tags ...string) Annotation {\n\treturn resultTagsAnnotation{tags}\n}\n\ntype outStructInfo struct {\n\tFields  []reflect.StructField // fields of the struct\n\tOffsets []int                 // Offsets[i] is the index of result i in Fields\n}\n\ntype _lifecycleHookAnnotationType int\n\nconst (\n\t_unknownHookType _lifecycleHookAnnotationType = iota\n\t_onStartHookType\n\t_onStopHookType\n)\n\ntype lifecycleHookAnnotation struct {\n\tType   _lifecycleHookAnnotationType\n\tTarget interface{}\n}\n\nvar _ Annotation = (*lifecycleHookAnnotation)(nil)\n\nfunc (la *lifecycleHookAnnotation) String() string {\n\tname := \"UnknownHookAnnotation\"\n\tswitch la.Type {\n\tcase _onStartHookType:\n\t\tname = _onStartHook\n\tcase _onStopHookType:\n\t\tname = _onStopHook\n\t}\n\treturn name\n}\n\nfunc (la *lifecycleHookAnnotation) apply(ann *annotated) error {\n\tif la.Target == nil {\n\t\treturn fmt.Errorf(\n\t\t\t\"cannot use nil function for %q hook annotation\",\n\t\t\tla,\n\t\t)\n\t}\n\n\tfor _, h := range ann.Hooks {\n\t\tif la.Type == h.Type {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"cannot apply more than one %q hook annotation\",\n\t\t\t\tla,\n\t\t\t)\n\t\t}\n\t}\n\n\tft := reflect.TypeOf(la.Target)\n\n\tif ft.Kind() != reflect.Func {\n\t\treturn fmt.Errorf(\n\t\t\t\"must provide function for %q hook, got %v (%T)\",\n\t\t\tla,\n\t\t\tla.Target,\n\t\t\tla.Target,\n\t\t)\n\t}\n\n\tif n := ft.NumOut(); n > 0 {\n\t\tif n > 1 || ft.Out(0) != _typeOfError {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"optional hook return may only be an error, got %v (%T)\",\n\t\t\t\tla.Target,\n\t\t\t\tla.Target,\n\t\t\t)\n\t\t}\n\t}\n\n\tif ft.IsVariadic() {\n\t\treturn fmt.Errorf(\n\t\t\t\"hooks must not accept variadic parameters, got %v (%T)\",\n\t\t\tla.Target,\n\t\t\tla.Target,\n\t\t)\n\t}\n\n\tann.Hooks = append(ann.Hooks, la)\n\treturn nil\n}\n\n// build builds and returns a constructor after applying a lifecycle hook annotation.\nfunc (la *lifecycleHookAnnotation) build(ann *annotated) (interface{}, error) {\n\tresultTypes, hasError := ann.currentResultTypes()\n\tif !hasError {\n\t\tresultTypes = append(resultTypes, _typeOfError)\n\t}\n\n\thookInstaller, paramTypes, remapParams := la.buildHookInstaller(ann)\n\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\t// copy the original arguments before remapping the parameters\n\t\t// so that we can apply them to the hookInstaller.\n\t\torigArgs := make([]reflect.Value, len(args))\n\t\tcopy(origArgs, args)\n\t\targs = remapParams(args)\n\t\tresults := origFn.Call(args)\n\t\tif hasError {\n\t\t\terrVal := results[len(results)-1]\n\t\t\tresults = results[:len(results)-1]\n\t\t\tif err, _ := errVal.Interface().(error); err != nil {\n\t\t\t\t// if constructor returned error, do not call hook installer\n\t\t\t\treturn append(results, errVal)\n\t\t\t}\n\t\t}\n\t\thookInstallerResults := hookInstaller.Call(append(results, origArgs...))\n\t\tresults = append(results, hookInstallerResults[0])\n\t\treturn results\n\t})\n\treturn newFn.Interface(), nil\n}\n\nvar (\n\t_typeOfLifecycle = reflect.TypeOf((*Lifecycle)(nil)).Elem()\n\t_typeOfContext   = reflect.TypeOf((*context.Context)(nil)).Elem()\n)\n\n// buildHookInstaller returns a function that appends a hook to Lifecycle when called,\n// along with the new parameter types and a function that maps arguments to the annotated constructor\nfunc (la *lifecycleHookAnnotation) buildHookInstaller(ann *annotated) (\n\thookInstaller reflect.Value,\n\tparamTypes []reflect.Type,\n\tremapParams func([]reflect.Value) []reflect.Value, // function to remap parameters to function being annotated\n) {\n\tparamTypes = ann.currentParamTypes()\n\tparamTypes, remapParams = injectLifecycle(paramTypes)\n\n\tresultTypes, hasError := ann.currentResultTypes()\n\tif hasError {\n\t\tresultTypes = resultTypes[:len(resultTypes)-1]\n\t}\n\n\t// look for the context.Context type from the original hook function\n\t// and then exclude it from the paramTypes of invokeFn because context.Context\n\t// will be injected by the lifecycle\n\tctxPos := -1\n\tctxStructPos := -1\n\torigHookFn := reflect.ValueOf(la.Target)\n\torigHookFnT := reflect.TypeOf(la.Target)\n\tinvokeParamTypes := []reflect.Type{\n\t\t_typeOfLifecycle,\n\t}\n\tfor i := 0; i < origHookFnT.NumIn(); i++ {\n\t\tt := origHookFnT.In(i)\n\t\tif t == _typeOfContext && ctxPos < 0 {\n\t\t\tctxPos = i\n\t\t\tcontinue\n\t\t}\n\t\tif !isIn(t) {\n\t\t\tinvokeParamTypes = append(invokeParamTypes, origHookFnT.In(i))\n\t\t\tcontinue\n\t\t}\n\t\tfields := []reflect.StructField{_inAnnotationField}\n\t\tfor j := 1; j < t.NumField(); j++ {\n\t\t\tfield := t.Field(j)\n\t\t\tif field.Type == _typeOfContext && ctxPos < 0 {\n\t\t\t\tctxStructPos = i\n\t\t\t\tctxPos = j\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfields = append(fields, field)\n\t\t}\n\t\tinvokeParamTypes = append(invokeParamTypes, reflect.StructOf(fields))\n\n\t}\n\tinvokeFnT := reflect.FuncOf(invokeParamTypes, []reflect.Type{}, false)\n\tinvokeFn := reflect.MakeFunc(invokeFnT, func(args []reflect.Value) (results []reflect.Value) {\n\t\tlc := args[0].Interface().(Lifecycle)\n\t\targs = args[1:]\n\t\thookArgs := make([]reflect.Value, origHookFnT.NumIn())\n\n\t\thookFn := func(ctx context.Context) (err error) {\n\t\t\t// If the hook function has multiple parameters, and the first\n\t\t\t// parameter is a context, inject the provided context.\n\t\t\tif ctxStructPos < 0 {\n\t\t\t\toffset := 0\n\t\t\t\tfor i := 0; i < len(hookArgs); i++ {\n\t\t\t\t\tif i == ctxPos {\n\t\t\t\t\t\thookArgs[i] = reflect.ValueOf(ctx)\n\t\t\t\t\t\toffset = 1\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif i-offset >= 0 && i-offset < len(args) {\n\t\t\t\t\t\thookArgs[i] = args[i-offset]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor i := 0; i < origHookFnT.NumIn(); i++ {\n\t\t\t\t\tif i != ctxStructPos {\n\t\t\t\t\t\thookArgs[i] = args[i]\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tt := origHookFnT.In(i)\n\t\t\t\t\tv := reflect.New(t).Elem()\n\t\t\t\t\tfor j := 1; j < t.NumField(); j++ {\n\t\t\t\t\t\tif j < ctxPos {\n\t\t\t\t\t\t\tv.Field(j).Set(args[i].Field(j))\n\t\t\t\t\t\t} else if j == ctxPos {\n\t\t\t\t\t\t\tv.Field(j).Set(reflect.ValueOf(ctx))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv.Field(j).Set(args[i].Field(j - 1))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thookArgs[i] = v\n\t\t\t\t}\n\t\t\t}\n\t\t\thookResults := origHookFn.Call(hookArgs)\n\t\t\tif len(hookResults) > 0 && hookResults[0].Type() == _typeOfError {\n\t\t\t\terr, _ = hookResults[0].Interface().(error)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tlc.Append(la.buildHook(hookFn))\n\t\treturn results\n\t})\n\n\tinstallerType := reflect.FuncOf(append(resultTypes, paramTypes...), []reflect.Type{_typeOfError}, false)\n\thookInstaller = reflect.MakeFunc(installerType, func(args []reflect.Value) (results []reflect.Value) {\n\t\t// build a private scope for hook function\n\t\tvar scope *dig.Scope\n\t\tswitch la.Type {\n\t\tcase _onStartHookType:\n\t\t\tscope = ann.container.Scope(\"onStartHookScope\")\n\t\tcase _onStopHookType:\n\t\t\tscope = ann.container.Scope(\"onStopHookScope\")\n\t\t}\n\n\t\t// provide the private scope with the current dependencies and results of the annotated function\n\t\tresults = []reflect.Value{_nilError}\n\t\tctor := makeHookScopeCtor(paramTypes, resultTypes, args)\n\t\tif err := scope.Provide(ctor); err != nil {\n\t\t\tresults[0] = reflect.ValueOf(fmt.Errorf(\"error providing possible parameters for hook installer: %w\", err))\n\t\t\treturn results\n\t\t}\n\n\t\t// invoking invokeFn appends the hook function to lifecycle\n\t\tif err := scope.Invoke(invokeFn.Interface()); err != nil {\n\t\t\tresults[0] = reflect.ValueOf(fmt.Errorf(\"error invoking hook installer: %w\", err))\n\t\t\treturn results\n\t\t}\n\t\treturn results\n\t})\n\treturn hookInstaller, paramTypes, remapParams\n}\n\nvar (\n\t_nameTag  = \"name\"\n\t_groupTag = \"group\"\n)\n\n// makeHookScopeCtor makes a constructor that provides all possible parameters\n// that the lifecycle hook being appended can depend on. It also deduplicates\n// duplicate param and result types, which is possible when using fx.Decorate,\n// and uses values from results for providing the deduplicated types.\nfunc makeHookScopeCtor(paramTypes []reflect.Type, resultTypes []reflect.Type, args []reflect.Value) interface{} {\n\ttype key struct {\n\t\tt     reflect.Type\n\t\tname  string\n\t\tgroup string\n\t}\n\tseen := map[key]struct{}{}\n\toutTypes := make([]reflect.Type, len(resultTypes))\n\tfor i, t := range resultTypes {\n\t\toutTypes[i] = t\n\t\tif isOut(t) {\n\t\t\tfor j := 1; j < t.NumField(); j++ {\n\t\t\t\tfield := t.Field(j)\n\t\t\t\tseen[key{\n\t\t\t\t\tt:     field.Type,\n\t\t\t\t\tname:  field.Tag.Get(_nameTag),\n\t\t\t\t\tgroup: field.Tag.Get(_groupTag),\n\t\t\t\t}] = struct{}{}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tseen[key{t: t}] = struct{}{}\n\t}\n\n\tfields := []reflect.StructField{_outAnnotationField}\n\n\tskippedParams := make([][]int, len(paramTypes))\n\n\tfor i, t := range paramTypes {\n\t\tskippedParams[i] = []int{}\n\t\tif isIn(t) {\n\t\t\tfor j := 1; j < t.NumField(); j++ {\n\t\t\t\torigField := t.Field(j)\n\t\t\t\tk := key{\n\t\t\t\t\tt:     origField.Type,\n\t\t\t\t\tname:  origField.Tag.Get(_nameTag),\n\t\t\t\t\tgroup: origField.Tag.Get(_groupTag),\n\t\t\t\t}\n\n\t\t\t\tif _, ok := seen[k]; ok {\n\t\t\t\t\tskippedParams[i] = append(skippedParams[i], j)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfield := reflect.StructField{\n\t\t\t\t\tName: fmt.Sprintf(\"Field%d\", j-1),\n\t\t\t\t\tType: origField.Type,\n\t\t\t\t\tTag:  origField.Tag,\n\t\t\t\t}\n\t\t\t\tfields = append(fields, field)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tk := key{t: t}\n\n\t\tif _, ok := seen[k]; ok {\n\t\t\tskippedParams[i] = append(skippedParams[i], i)\n\t\t\tcontinue\n\t\t}\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: t,\n\t\t}\n\t\tfields = append(fields, field)\n\t}\n\n\toutTypes = append(outTypes, reflect.StructOf(fields))\n\tctorType := reflect.FuncOf([]reflect.Type{}, outTypes, false)\n\tctor := reflect.MakeFunc(ctorType, func(_ []reflect.Value) []reflect.Value {\n\t\tnOut := len(outTypes)\n\t\tresults := make([]reflect.Value, nOut)\n\t\tfor i := 0; i < nOut-1; i++ {\n\t\t\tresults[i] = args[i]\n\t\t}\n\n\t\tv := reflect.New(outTypes[nOut-1]).Elem()\n\t\tfieldIdx := 1\n\t\tfor i := nOut - 1; i < len(args); i++ {\n\t\t\tparamIdx := i - (nOut - 1)\n\t\t\tif isIn(paramTypes[paramIdx]) {\n\t\t\t\tskippedIdx := 0\n\t\t\t\tfor j := 1; j < paramTypes[paramIdx].NumField(); j++ {\n\t\t\t\t\tif len(skippedParams[paramIdx]) > 0 && skippedParams[paramIdx][skippedIdx] == j {\n\t\t\t\t\t\t// skip\n\t\t\t\t\t\tskippedIdx++\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tv.Field(fieldIdx).Set(args[i].Field(j))\n\t\t\t\t\tfieldIdx++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(skippedParams[paramIdx]) > 0 && skippedParams[paramIdx][0] == paramIdx {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tv.Field(fieldIdx).Set(args[i])\n\t\t\t\tfieldIdx++\n\t\t\t}\n\t\t}\n\t\tresults[nOut-1] = v\n\n\t\treturn results\n\t})\n\treturn ctor.Interface()\n}\n\nfunc injectLifecycle(paramTypes []reflect.Type) ([]reflect.Type, func([]reflect.Value) []reflect.Value) {\n\t// since lifecycle already exists in param types, no need to inject again\n\tif lifecycleExists(paramTypes) {\n\t\treturn paramTypes, func(args []reflect.Value) []reflect.Value {\n\t\t\treturn args\n\t\t}\n\t}\n\t// If params are tagged or there's an untagged variadic argument,\n\t// add a Lifecycle field to the param struct\n\tif len(paramTypes) > 0 && isIn(paramTypes[0]) {\n\t\ttaggedParam := paramTypes[0]\n\t\tfields := []reflect.StructField{\n\t\t\ttaggedParam.Field(0),\n\t\t\t{\n\t\t\t\tName: \"Lifecycle\",\n\t\t\t\tType: _typeOfLifecycle,\n\t\t\t},\n\t\t}\n\t\tfor i := 1; i < taggedParam.NumField(); i++ {\n\t\t\tfields = append(fields, taggedParam.Field(i))\n\t\t}\n\t\tnewParamType := reflect.StructOf(fields)\n\t\treturn []reflect.Type{newParamType}, func(args []reflect.Value) []reflect.Value {\n\t\t\tparam := args[0]\n\t\t\targs[0] = reflect.New(taggedParam).Elem()\n\t\t\tfor i := 1; i < taggedParam.NumField(); i++ {\n\t\t\t\targs[0].Field(i).Set(param.Field(i + 1))\n\t\t\t}\n\t\t\treturn args\n\t\t}\n\t}\n\n\treturn append([]reflect.Type{_typeOfLifecycle}, paramTypes...), func(args []reflect.Value) []reflect.Value {\n\t\treturn args[1:]\n\t}\n}\n\nfunc lifecycleExists(paramTypes []reflect.Type) bool {\n\tfor _, t := range paramTypes {\n\t\tif t == _typeOfLifecycle {\n\t\t\treturn true\n\t\t}\n\t\tif isIn(t) {\n\t\t\tfor i := 1; i < t.NumField(); i++ {\n\t\t\t\tif t.Field(i).Type == _typeOfLifecycle {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (la *lifecycleHookAnnotation) buildHook(fn func(context.Context) error) (hook Hook) {\n\tswitch la.Type {\n\tcase _onStartHookType:\n\t\thook.OnStart = fn\n\tcase _onStopHookType:\n\t\thook.OnStop = fn\n\t}\n\treturn hook\n}\n\n// OnStart is an Annotation that appends an OnStart Hook to the application\n// Lifecycle when that function is called. This provides a way to create\n// Lifecycle OnStart (see Lifecycle type documentation) hooks without building a\n// function that takes a dependency on the Lifecycle type.\n//\n//\tfx.Provide(\n//\t\tfx.Annotate(\n//\t\t\tNewServer,\n//\t\t\tfx.OnStart(func(ctx context.Context, server Server) error {\n//\t\t\t\treturn server.Listen(ctx)\n//\t\t\t}),\n//\t\t)\n//\t)\n//\n// Which is functionally the same as:\n//\n//\t fx.Provide(\n//\t   func(lifecycle fx.Lifecycle, p Params) Server {\n//\t     server := NewServer(p)\n//\t     lifecycle.Append(fx.Hook{\n//\t\t      OnStart: func(ctx context.Context) error {\n//\t\t\t    return server.Listen(ctx)\n//\t\t      },\n//\t     })\n//\t\t return server\n//\t   }\n//\t )\n//\n// It is also possible to use OnStart annotation with other parameter and result\n// annotations, provided that the parameter of the function passed to OnStart\n// matches annotated parameters and results.\n//\n// For example, the following is possible:\n//\n//\tfx.Provide(\n//\t\tfx.Annotate(\n//\t\t\tfunc (a A) B {...},\n//\t\t\tfx.ParamTags(`name:\"A\"`),\n//\t\t\tfx.ResultTags(`name:\"B\"`),\n//\t\t\tfx.OnStart(func (p OnStartParams) {...}),\n//\t\t),\n//\t)\n//\n// As long as OnStartParams looks like the following and has no other dependencies\n// besides Context or Lifecycle:\n//\n//\ttype OnStartParams struct {\n//\t\tfx.In\n//\t\tFieldA A `name:\"A\"`\n//\t\tFieldB B `name:\"B\"`\n//\t}\n//\n// Only one OnStart annotation may be applied to a given function at a time,\n// however functions may be annotated with other types of lifecycle Hooks, such\n// as OnStop. The hook function passed into OnStart cannot take any arguments\n// outside of the annotated constructor's existing dependencies or results, except\n// a context.Context.\nfunc OnStart(onStart interface{}) Annotation {\n\treturn &lifecycleHookAnnotation{\n\t\tType:   _onStartHookType,\n\t\tTarget: onStart,\n\t}\n}\n\n// OnStop is an Annotation that appends an OnStop Hook to the application\n// Lifecycle when that function is called. This provides a way to create\n// Lifecycle OnStop (see Lifecycle type documentation) hooks without building a\n// function that takes a dependency on the Lifecycle type.\n//\n//\tfx.Provide(\n//\t\tfx.Annotate(\n//\t\t\tNewServer,\n//\t\t\tfx.OnStop(func(ctx context.Context, server Server) error {\n//\t\t\t\treturn server.Shutdown(ctx)\n//\t\t\t}),\n//\t\t)\n//\t)\n//\n// Which is functionally the same as:\n//\n//\t fx.Provide(\n//\t   func(lifecycle fx.Lifecycle, p Params) Server {\n//\t     server := NewServer(p)\n//\t     lifecycle.Append(fx.Hook{\n//\t\t      OnStop: func(ctx context.Context) error {\n//\t\t\t    return server.Shutdown(ctx)\n//\t\t      },\n//\t     })\n//\t\t return server\n//\t   }\n//\t )\n//\n// It is also possible to use OnStop annotation with other parameter and result\n// annotations, provided that the parameter of the function passed to OnStop\n// matches annotated parameters and results.\n//\n// For example, the following is possible:\n//\n//\tfx.Provide(\n//\t\tfx.Annotate(\n//\t\t\tfunc (a A) B {...},\n//\t\t\tfx.ParamTags(`name:\"A\"`),\n//\t\t\tfx.ResultTags(`name:\"B\"`),\n//\t\t\tfx.OnStop(func (p OnStopParams) {...}),\n//\t\t),\n//\t)\n//\n// As long as OnStopParams looks like the following and has no other dependencies\n// besides Context or Lifecycle:\n//\n//\ttype OnStopParams struct {\n//\t\tfx.In\n//\t\tFieldA A `name:\"A\"`\n//\t\tFieldB B `name:\"B\"`\n//\t}\n//\n// Only one OnStop annotation may be applied to a given function at a time,\n// however functions may be annotated with other types of lifecycle Hooks, such\n// as OnStart. The hook function passed into OnStop cannot take any arguments\n// outside of the annotated constructor's existing dependencies or results, except\n// a context.Context.\nfunc OnStop(onStop interface{}) Annotation {\n\treturn &lifecycleHookAnnotation{\n\t\tType:   _onStopHookType,\n\t\tTarget: onStop,\n\t}\n}\n\ntype asAnnotation struct {\n\ttargets []interface{}\n\ttypes   []asType\n}\n\ntype asType struct {\n\tself bool\n\ttyp  reflect.Type // May be nil if self is true.\n}\n\nfunc (a asType) String() string {\n\tif a.self {\n\t\treturn \"self\"\n\t}\n\treturn a.typ.String()\n}\n\nfunc isOut(t reflect.Type) bool {\n\treturn (t.Kind() == reflect.Struct &&\n\t\tdig.IsOut(reflect.New(t).Elem().Interface()))\n}\n\nfunc isIn(t reflect.Type) bool {\n\treturn (t.Kind() == reflect.Struct &&\n\t\tdig.IsIn(reflect.New(t).Elem().Interface()))\n}\n\nvar _ Annotation = (*asAnnotation)(nil)\n\n// As is an Annotation that annotates the result of a function (i.e. a\n// constructor) to be provided as another interface.\n//\n// For example, the following code specifies that the return type of\n// bytes.NewBuffer (bytes.Buffer) should be provided as io.Writer type:\n//\n//\tfx.Provide(\n//\t  fx.Annotate(bytes.NewBuffer, fx.As(new(io.Writer)))\n//\t)\n//\n// In other words, the code above is equivalent to:\n//\n//\tfx.Provide(func() io.Writer {\n//\t  return bytes.NewBuffer()\n//\t  // provides io.Writer instead of *bytes.Buffer\n//\t})\n//\n// Note that the bytes.Buffer type is provided as an io.Writer type, so this\n// constructor does NOT provide both bytes.Buffer and io.Writer type; it just\n// provides io.Writer type.\n//\n// When multiple values are returned by the annotated function, each type\n// gets mapped to corresponding positional result of the annotated function.\n//\n// For example,\n//\n//\tfunc a() (bytes.Buffer, bytes.Buffer) {\n//\t  ...\n//\t}\n//\tfx.Provide(\n//\t  fx.Annotate(a, fx.As(new(io.Writer), new(io.Reader)))\n//\t)\n//\n// Is equivalent to,\n//\n//\tfx.Provide(func() (io.Writer, io.Reader) {\n//\t  w, r := a()\n//\t  return w, r\n//\t}\n//\n// As entirely replaces the default return types of a function. In order\n// to maintain the original return types when using As, see [Self].\n//\n// As annotation cannot be used in a function that returns an [Out] struct as a return type.\nfunc As(interfaces ...interface{}) Annotation {\n\treturn &asAnnotation{targets: interfaces}\n}\n\n// Self returns a special value that can be passed to [As] to indicate\n// that a type should be provided as its original type, in addition to whatever other\n// types it gets provided as via other [As] annotations.\n//\n// For example,\n//\n//\tfx.Provide(\n//\t  fx.Annotate(\n//\t    bytes.NewBuffer,\n//\t    fx.As(new(io.Writer)),\n//\t    fx.As(fx.Self()),\n//\t  )\n//\t)\n//\n// Is equivalent to,\n//\n//\tfx.Provide(\n//\t  bytes.NewBuffer,\n//\t  func(b *bytes.Buffer) io.Writer {\n//\t    return b\n//\t  },\n//\t)\n//\n// in that it provides the same *bytes.Buffer instance\n// as both a *bytes.Buffer and an io.Writer.\nfunc Self() any {\n\treturn &self{}\n}\n\ntype self struct{}\n\nfunc (at *asAnnotation) apply(ann *annotated) error {\n\tat.types = make([]asType, len(at.targets))\n\tfor i, typ := range at.targets {\n\t\tif _, ok := typ.(*self); ok {\n\t\t\tat.types[i] = asType{self: true}\n\t\t\tcontinue\n\t\t}\n\t\tt := reflect.TypeOf(typ)\n\t\tif t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Interface {\n\t\t\treturn fmt.Errorf(\"fx.As: argument must be a pointer to an interface: got %v\", t)\n\t\t}\n\t\tt = t.Elem()\n\t\tat.types[i] = asType{typ: t}\n\t}\n\n\tann.As = append(ann.As, at.types)\n\treturn nil\n}\n\n// build implements Annotation\nfunc (at *asAnnotation) build(ann *annotated) (interface{}, error) {\n\tparamTypes := ann.currentParamTypes()\n\n\tresultTypes, remapResults, err := at.results(ann)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\tresults := origFn.Call(args)\n\t\treturn remapResults(results)\n\t})\n\treturn newFn.Interface(), nil\n}\n\nfunc (at *asAnnotation) results(ann *annotated) (\n\ttypes []reflect.Type,\n\tremap func([]reflect.Value) []reflect.Value,\n\terr error,\n) {\n\ttypes, hasError := ann.currentResultTypes()\n\tfields := []reflect.StructField{_outAnnotationField}\n\tif hasError {\n\t\ttypes = types[:len(types)-1]\n\t}\n\tresultFields, getResult := extractResultFields(types)\n\n\tfor i, f := range resultFields {\n\t\tt := f.Type\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: t,\n\t\t\tTag:  f.Tag,\n\t\t}\n\n\t\tif i >= len(at.types) || at.types[i].self {\n\t\t\tfields = append(fields, field)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !t.Implements(at.types[i].typ) {\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid fx.As: %v does not implement %v\", t, at.types[i])\n\t\t}\n\t\tfield.Type = at.types[i].typ\n\t\tfields = append(fields, field)\n\t}\n\tresType := reflect.StructOf(fields)\n\n\tvar outTypes []reflect.Type\n\toutTypes = append(types, resType)\n\tif hasError {\n\t\toutTypes = append(outTypes, _typeOfError)\n\t}\n\n\treturn outTypes, func(results []reflect.Value) []reflect.Value {\n\t\tvar (\n\t\t\toutErr     error\n\t\t\toutResults []reflect.Value\n\t\t)\n\n\t\tfor i, r := range results {\n\t\t\tif i == len(results)-1 && hasError {\n\t\t\t\t// If hasError and this is the last item,\n\t\t\t\t// we are guaranteed that this is an error\n\t\t\t\t// object.\n\t\t\t\tif err, _ := r.Interface().(error); err != nil {\n\t\t\t\t\toutErr = err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toutResults = append(outResults, r)\n\t\t}\n\n\t\tnewOutResult := reflect.New(resType).Elem()\n\t\tfor i := 1; i < resType.NumField(); i++ {\n\t\t\tnewOutResult.Field(i).Set(getResult(i, results))\n\t\t}\n\t\toutResults = append(outResults, newOutResult)\n\n\t\tif hasError {\n\t\t\tif outErr != nil {\n\t\t\t\toutResults = append(outResults, reflect.ValueOf(outErr))\n\t\t\t} else {\n\t\t\t\toutResults = append(outResults, _nilError)\n\t\t\t}\n\t\t}\n\n\t\treturn outResults\n\t}, nil\n}\n\nfunc extractResultFields(types []reflect.Type) ([]reflect.StructField, func(int, []reflect.Value) reflect.Value) {\n\tvar resultFields []reflect.StructField\n\tif len(types) > 0 && isOut(types[0]) {\n\t\tfor i := 1; i < types[0].NumField(); i++ {\n\t\t\tresultFields = append(resultFields, types[0].Field(i))\n\t\t}\n\t\treturn resultFields, func(idx int, results []reflect.Value) reflect.Value {\n\t\t\treturn results[0].Field(idx)\n\t\t}\n\t}\n\tfor i, t := range types {\n\t\tif isOut(t) {\n\t\t\tcontinue\n\t\t}\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: t,\n\t\t}\n\t\tresultFields = append(resultFields, field)\n\t}\n\treturn resultFields, func(idx int, results []reflect.Value) reflect.Value {\n\t\treturn results[idx-1]\n\t}\n}\n\ntype fromAnnotation struct {\n\ttargets []interface{}\n\ttypes   []reflect.Type\n}\n\nvar _ Annotation = (*fromAnnotation)(nil)\n\n// From is an [Annotation] that annotates the parameter(s) for a function (i.e. a\n// constructor) to be accepted from other provided types. It is analogous to the\n// [As] for parameter types to the constructor.\n//\n// For example,\n//\n//\ttype Runner interface { Run() }\n//\tfunc NewFooRunner() *FooRunner // implements Runner\n//\tfunc NewRunnerWrap(r Runner) *RunnerWrap\n//\n//\tfx.Provide(\n//\t  fx.Annotate(\n//\t    NewRunnerWrap,\n//\t    fx.From(new(*FooRunner)),\n//\t  ),\n//\t)\n//\n// Is equivalent to,\n//\n//\tfx.Provide(func(r *FooRunner) *RunnerWrap {\n//\t  // need *FooRunner instead of Runner\n//\t  return NewRunnerWrap(r)\n//\t})\n//\n// When the annotated function takes in multiple parameters, each type gets\n// mapped to corresponding positional parameter of the annotated function\n//\n// For example,\n//\n//\tfunc NewBarRunner() *BarRunner // implements Runner\n//\tfunc NewRunnerWraps(r1 Runner, r2 Runner) *RunnerWraps\n//\n//\tfx.Provide(\n//\t  fx.Annotate(\n//\t    NewRunnerWraps,\n//\t    fx.From(new(*FooRunner), new(*BarRunner)),\n//\t  ),\n//\t)\n//\n// Is equivalent to,\n//\n//\tfx.Provide(func(r1 *FooRunner, r2 *BarRunner) *RunnerWraps {\n//\t  return NewRunnerWraps(r1, r2)\n//\t})\n//\n// From annotation cannot be used in a function that takes an [In] struct as a\n// parameter.\nfunc From(interfaces ...interface{}) Annotation {\n\treturn &fromAnnotation{targets: interfaces}\n}\n\nfunc (fr *fromAnnotation) apply(ann *annotated) error {\n\tif len(ann.From) > 0 {\n\t\treturn errors.New(\"cannot apply more than one line of From\")\n\t}\n\tft := reflect.TypeOf(ann.Target)\n\tfr.types = make([]reflect.Type, len(fr.targets))\n\tfor i, typ := range fr.targets {\n\t\tif ft.IsVariadic() && i == ft.NumIn()-1 {\n\t\t\treturn errors.New(\"fx.From: cannot annotate a variadic argument\")\n\t\t}\n\t\tt := reflect.TypeOf(typ)\n\t\tif t == nil || t.Kind() != reflect.Ptr {\n\t\t\treturn fmt.Errorf(\"fx.From: argument must be a pointer to a type that implements some interface: got %v\", t)\n\t\t}\n\t\tfr.types[i] = t.Elem()\n\t}\n\tann.From = fr.types\n\treturn nil\n}\n\n// build builds and returns a constructor after applying a From annotation\nfunc (fr *fromAnnotation) build(ann *annotated) (interface{}, error) {\n\tparamTypes, remap, err := fr.parameters(ann)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresultTypes, _ := ann.currentResultTypes()\n\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\targs = remap(args)\n\t\treturn origFn.Call(args)\n\t})\n\treturn newFn.Interface(), nil\n}\n\n// parameters returns the type for the parameters of the annotated function,\n// and a function that maps the arguments of the annotated function\n// back to the arguments of the target function.\nfunc (fr *fromAnnotation) parameters(ann *annotated) (\n\ttypes []reflect.Type,\n\tremap func([]reflect.Value) []reflect.Value,\n\terr error,\n) {\n\tft := reflect.TypeOf(ann.Target)\n\ttypes = make([]reflect.Type, ft.NumIn())\n\tfor i := 0; i < ft.NumIn(); i++ {\n\t\ttypes[i] = ft.In(i)\n\t}\n\n\t// No parameter annotations. Return the original types\n\t// and an identity function.\n\tif len(fr.targets) == 0 {\n\t\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\t\treturn args\n\t\t}, nil\n\t}\n\n\t// Turn parameters into an fx.In struct.\n\tinFields := []reflect.StructField{_inAnnotationField}\n\n\t// The following situations may occur:\n\t// 1. there was a variadic argument, so it was pre-transformed.\n\t// 2. another parameter annotation was transformed (ex: ParamTags).\n\t// so need to visit fields of the fx.In struct.\n\tif len(types) > 0 && isIn(types[0]) {\n\t\tparamType := types[0]\n\n\t\tfor i := 1; i < paramType.NumField(); i++ {\n\t\t\torigField := paramType.Field(i)\n\t\t\tfield := reflect.StructField{\n\t\t\t\tName: origField.Name,\n\t\t\t\tType: origField.Type,\n\t\t\t\tTag:  origField.Tag,\n\t\t\t}\n\t\t\tif i-1 < len(fr.types) {\n\t\t\t\tt := fr.types[i-1]\n\t\t\t\tif !t.Implements(field.Type) {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid fx.From: %v does not implement %v\", t, field.Type)\n\t\t\t\t}\n\t\t\t\tfield.Type = t\n\t\t\t}\n\n\t\t\tinFields = append(inFields, field)\n\t\t}\n\n\t\ttypes = []reflect.Type{reflect.StructOf(inFields)}\n\t\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\t\tparam := args[0]\n\t\t\targs[0] = reflect.New(paramType).Elem()\n\t\t\tfor i := 1; i < paramType.NumField(); i++ {\n\t\t\t\targs[0].Field(i).Set(param.Field(i))\n\t\t\t}\n\t\t\treturn args\n\t\t}, nil\n\t}\n\n\tfor i, t := range types {\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: t,\n\t\t}\n\t\tif i < len(fr.types) {\n\t\t\tt := fr.types[i]\n\t\t\tif !t.Implements(field.Type) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid fx.From: %v does not implement %v\", t, field.Type)\n\t\t\t}\n\t\t\tfield.Type = t\n\t\t}\n\n\t\tinFields = append(inFields, field)\n\t}\n\n\ttypes = []reflect.Type{reflect.StructOf(inFields)}\n\treturn types, func(args []reflect.Value) []reflect.Value {\n\t\tparams := args[0]\n\t\targs = args[:0]\n\t\tfor i := 0; i < ft.NumIn(); i++ {\n\t\t\targs = append(args, params.Field(i+1))\n\t\t}\n\t\treturn args\n\t}, nil\n}\n\ntype annotated struct {\n\tTarget      interface{}\n\tAnnotations []Annotation\n\tParamTags   []string\n\tResultTags  []string\n\tAs          [][]asType\n\tFrom        []reflect.Type\n\tFuncPtr     uintptr\n\tHooks       []*lifecycleHookAnnotation\n\t// container is used to build private scopes for lifecycle hook functions\n\t// added via fx.OnStart and fx.OnStop annotations.\n\tcontainer *dig.Container\n}\n\nfunc (ann annotated) String() string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"fx.Annotate(\")\n\tsb.WriteString(fxreflect.FuncName(ann.Target))\n\tif tags := ann.ParamTags; len(tags) > 0 {\n\t\tfmt.Fprintf(&sb, \", fx.ParamTags(%q)\", tags)\n\t}\n\tif tags := ann.ResultTags; len(tags) > 0 {\n\t\tfmt.Fprintf(&sb, \", fx.ResultTags(%q)\", tags)\n\t}\n\tif as := ann.As; len(as) > 0 {\n\t\tfmt.Fprintf(&sb, \", fx.As(%v)\", as)\n\t}\n\tif from := ann.From; len(from) > 0 {\n\t\tfmt.Fprintf(&sb, \", fx.From(%v)\", from)\n\t}\n\treturn sb.String()\n}\n\n// Build builds and returns a constructor based on fx.In/fx.Out params and\n// results wrapping the original constructor passed to fx.Annotate.\nfunc (ann *annotated) Build() (interface{}, error) {\n\tann.container = dig.New()\n\tft := reflect.TypeOf(ann.Target)\n\tif ft.Kind() != reflect.Func {\n\t\treturn nil, fmt.Errorf(\"must provide constructor function, got %v (%T)\", ann.Target, ann.Target)\n\t}\n\n\tif err := ann.typeCheckOrigFn(); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid annotation function %T: %w\", ann.Target, err)\n\t}\n\n\tann.applyOptionalTag()\n\n\tvar (\n\t\terr        error\n\t\tlcHookAnns []*lifecycleHookAnnotation\n\t)\n\tfor _, annotation := range ann.Annotations {\n\t\tif lcHookAnn, ok := annotation.(*lifecycleHookAnnotation); ok {\n\t\t\tlcHookAnns = append(lcHookAnns, lcHookAnn)\n\t\t\tcontinue\n\t\t}\n\t\tif ann.Target, err = annotation.build(ann); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// need to call cleanUpAsResults before applying lifecycle annotations\n\t// to exclude the original results from the hook's scope if any\n\t// fx.As annotations were applied\n\tann.cleanUpAsResults()\n\n\tfor _, la := range lcHookAnns {\n\t\tif ann.Target, err = la.build(ann); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn ann.Target, nil\n}\n\n// applyOptionalTag checks if function being annotated is variadic\n// and applies optional tag to the variadic argument before\n// applying any other annotations\nfunc (ann *annotated) applyOptionalTag() {\n\tft := reflect.TypeOf(ann.Target)\n\tif !ft.IsVariadic() {\n\t\treturn\n\t}\n\n\tresultTypes, _ := ann.currentResultTypes()\n\n\tfields := []reflect.StructField{_inAnnotationField}\n\tfor i := 0; i < ft.NumIn(); i++ {\n\t\tfield := reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: ft.In(i),\n\t\t}\n\t\tif i == ft.NumIn()-1 {\n\t\t\t// Mark a variadic argument optional by default\n\t\t\t// so that just wrapping a function in fx.Annotate does not\n\t\t\t// suddenly introduce a required []arg dependency.\n\t\t\tfield.Tag = reflect.StructTag(`optional:\"true\"`)\n\t\t}\n\t\tfields = append(fields, field)\n\t}\n\tparamType := reflect.StructOf(fields)\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf([]reflect.Type{paramType}, resultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) []reflect.Value {\n\t\tparams := args[0]\n\t\targs = args[:0]\n\t\tfor i := 0; i < ft.NumIn(); i++ {\n\t\t\targs = append(args, params.Field(i+1))\n\t\t}\n\t\treturn origFn.CallSlice(args)\n\t})\n\tann.Target = newFn.Interface()\n}\n\n// cleanUpAsResults does a check to see if an As annotation was applied.\n// If there was any fx.As annotation applied, cleanUpAsResults wraps the\n// function one more time to remove the results from the original function.\nfunc (ann *annotated) cleanUpAsResults() {\n\t// clean up orig function results if there were any As annotations\n\tif len(ann.As) < 1 {\n\t\treturn\n\t}\n\tparamTypes := ann.currentParamTypes()\n\tresultTypes, hasError := ann.currentResultTypes()\n\tnumRes := len(ann.As)\n\tif hasError {\n\t\tnumRes++\n\t}\n\tnewResultTypes := resultTypes[len(resultTypes)-numRes:]\n\torigFn := reflect.ValueOf(ann.Target)\n\tnewFnType := reflect.FuncOf(paramTypes, newResultTypes, false)\n\tnewFn := reflect.MakeFunc(newFnType, func(args []reflect.Value) (results []reflect.Value) {\n\t\tresults = origFn.Call(args)\n\t\tresults = results[len(results)-numRes:]\n\t\treturn\n\t})\n\tann.Target = newFn.Interface()\n}\n\n// checks and returns a non-nil error if the target function:\n// - returns an fx.Out struct as a result and has either a ResultTags or an As annotation\n// - takes in an fx.In struct as a parameter and has either a ParamTags or a From annotation\n// - has an error result not as the last result.\nfunc (ann *annotated) typeCheckOrigFn() error {\n\tft := reflect.TypeOf(ann.Target)\n\tnumOut := ft.NumOut()\n\tfor i := 0; i < numOut; i++ {\n\t\tot := ft.Out(i)\n\t\tif ot == _typeOfError && i != numOut-1 {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"only the last result can be an error: \"+\n\t\t\t\t\t\"%v (%v) returns error as result %d\",\n\t\t\t\tfxreflect.FuncName(ann.Target), ft, i)\n\t\t}\n\t\tif ot.Kind() != reflect.Struct {\n\t\t\tcontinue\n\t\t}\n\t\tif !dig.IsOut(reflect.New(ft.Out(i)).Elem().Interface()) {\n\t\t\tcontinue\n\t\t}\n\t\tif len(ann.ResultTags) > 0 || len(ann.As) > 0 {\n\t\t\treturn errors.New(\"fx.Out structs cannot be annotated with fx.ResultTags or fx.As\")\n\t\t}\n\t}\n\tfor i := 0; i < ft.NumIn(); i++ {\n\t\tit := ft.In(i)\n\t\tif it.Kind() != reflect.Struct {\n\t\t\tcontinue\n\t\t}\n\t\tif !dig.IsIn(reflect.New(ft.In(i)).Elem().Interface()) {\n\t\t\tcontinue\n\t\t}\n\t\tif len(ann.ParamTags) > 0 || len(ann.From) > 0 {\n\t\t\treturn errors.New(\"fx.In structs cannot be annotated with fx.ParamTags or fx.From\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ann *annotated) currentResultTypes() (resultTypes []reflect.Type, hasError bool) {\n\tft := reflect.TypeOf(ann.Target)\n\tnumOut := ft.NumOut()\n\tresultTypes = make([]reflect.Type, numOut)\n\n\tfor i := 0; i < numOut; i++ {\n\t\tresultTypes[i] = ft.Out(i)\n\t\tif resultTypes[i] == _typeOfError && i == numOut-1 {\n\t\t\thasError = true\n\t\t}\n\t}\n\treturn resultTypes, hasError\n}\n\nfunc (ann *annotated) currentParamTypes() []reflect.Type {\n\tft := reflect.TypeOf(ann.Target)\n\tparamTypes := make([]reflect.Type, ft.NumIn())\n\n\tfor i := 0; i < ft.NumIn(); i++ {\n\t\tparamTypes[i] = ft.In(i)\n\t}\n\treturn paramTypes\n}\n\n// Annotate lets you annotate a function's parameters and returns\n// without you having to declare separate struct definitions for them.\n//\n// For example,\n//\n//\tfunc NewGateway(ro, rw *db.Conn) *Gateway { ... }\n//\tfx.Provide(\n//\t  fx.Annotate(\n//\t    NewGateway,\n//\t    fx.ParamTags(`name:\"ro\" optional:\"true\"`, `name:\"rw\"`),\n//\t    fx.ResultTags(`name:\"foo\"`),\n//\t  ),\n//\t)\n//\n// Is equivalent to,\n//\n//\ttype params struct {\n//\t  fx.In\n//\n//\t  RO *db.Conn `name:\"ro\" optional:\"true\"`\n//\t  RW *db.Conn `name:\"rw\"`\n//\t}\n//\n//\ttype result struct {\n//\t  fx.Out\n//\n//\t  GW *Gateway `name:\"foo\"`\n//\t}\n//\n//\tfx.Provide(func(p params) result {\n//\t   return result{GW: NewGateway(p.RO, p.RW)}\n//\t})\n//\n// Using the same annotation multiple times is invalid.\n// For example, the following will fail with an error:\n//\n//\tfx.Provide(\n//\t  fx.Annotate(\n//\t    NewGateWay,\n//\t    fx.ParamTags(`name:\"ro\" optional:\"true\"`),\n//\t    fx.ParamTags(`name:\"rw\"), // ERROR: ParamTags was already used above\n//\t    fx.ResultTags(`name:\"foo\"`)\n//\t  )\n//\t)\n//\n// If more tags are given than the number of parameters/results, only\n// the ones up to the number of parameters/results will be applied.\n//\n// # Variadic functions\n//\n// If the provided function is variadic, Annotate treats its parameter as a\n// slice. For example,\n//\n//\tfx.Annotate(func(w io.Writer, rs ...io.Reader) {\n//\t  // ...\n//\t}, ...)\n//\n// Is equivalent to,\n//\n//\tfx.Annotate(func(w io.Writer, rs []io.Reader) {\n//\t  // ...\n//\t}, ...)\n//\n// You can use variadic parameters with Fx's value groups.\n// For example,\n//\n//\tfx.Annotate(func(mux *http.ServeMux, handlers ...http.Handler) {\n//\t  // ...\n//\t}, fx.ParamTags(``, `group:\"server\"`))\n//\n// If we provide the above to the application,\n// any constructor in the Fx application can inject its HTTP handlers\n// by using [Annotate], [Annotated], or [Out].\n//\n//\tfx.Annotate(\n//\t  func(..) http.Handler { ... },\n//\t  fx.ResultTags(`group:\"server\"`),\n//\t)\n//\n//\tfx.Annotated{\n//\t  Target: func(..) http.Handler { ... },\n//\t  Group:  \"server\",\n//\t}\nfunc Annotate(t interface{}, anns ...Annotation) interface{} {\n\tresult := annotated{Target: t}\n\tfor _, ann := range anns {\n\t\tif err := ann.apply(&result); err != nil {\n\t\t\treturn annotationError{\n\t\t\t\ttarget: t,\n\t\t\t\terr:    err,\n\t\t\t}\n\t\t}\n\t}\n\tresult.Annotations = anns\n\treturn result\n}\n"
        },
        {
          "name": "annotated_test.go",
          "type": "blob",
          "size": 58.5078125,
          "content": "// Copyright (c) 2019-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestAnnotated(t *testing.T) {\n\tt.Parallel()\n\n\ttype a struct {\n\t\tname string\n\t}\n\ttype in struct {\n\t\tfx.In\n\n\t\tA *a `name:\"foo\"`\n\t}\n\tnewA := func() *a {\n\t\treturn &a{name: \"foo\"}\n\t}\n\tt.Run(\"Provide\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar in in\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotated{\n\t\t\t\t\tName:   \"foo\",\n\t\t\t\t\tTarget: newA,\n\t\t\t\t},\n\t\t\t),\n\t\t\tfx.Populate(&in),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, in.A, \"expected in.A to be injected\")\n\t\tassert.Equal(t, \"foo\", in.A.name, \"expected to get a type 'a' of name 'foo'\")\n\t})\n}\n\ntype fromStringer struct {\n\tname string\n}\n\nfunc (from *fromStringer) String() string {\n\treturn from.name\n}\n\ntype asStringer struct {\n\tname string\n}\n\nfunc (as *asStringer) String() string {\n\treturn as.name\n}\n\ntype anotherStringer struct {\n\tname string\n}\n\nfunc (a anotherStringer) String() string {\n\treturn a.name\n}\n\nfunc TestAnnotatedFrom(t *testing.T) {\n\tt.Parallel()\n\ttype myStringer interface {\n\t\tString() string\n\t}\n\n\tnewFromStringer := func() *fromStringer {\n\t\treturn &fromStringer{\n\t\t\tname: \"a good stringer\",\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tdesc    string\n\t\tprovide fx.Option\n\t\tinvoke  interface{}\n\t}{\n\t\t{\n\t\t\tdesc: \"provide a good stringer\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tnewFromStringer,\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"value type implementing interface\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfunc() anotherStringer {\n\t\t\t\t\treturn anotherStringer{\n\t\t\t\t\t\t\"another stringer\",\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(anotherStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"another stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide with multiple types From\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tnewFromStringer,\n\t\t\t\tfunc() anotherStringer {\n\t\t\t\t\treturn anotherStringer{\n\t\t\t\t\t\t\"another stringer\",\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer1 myStringer, myStringer2 myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer1.String() + \" and \" + myStringer2.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(anotherStringer), new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"another stringer and a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide from with param annotation\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewFromStringer,\n\t\t\t\t\tfx.ResultTags(`name:\"struct1\"`),\n\t\t\t\t),\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t\tfx.ParamTags(`name:\"struct1\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// same as the test above, except now we annotate\n\t\t\t// it in a different order.\n\t\t\tdesc: \"provide from with param annotation, in different order\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewFromStringer,\n\t\t\t\t\tfx.ResultTags(`name:\"struct1\"`),\n\t\t\t\t),\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.ParamTags(`name:\"struct1\"`),\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate fewer items than required for constructor\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tnewFromStringer,\n\t\t\t\tfunc() anotherStringer {\n\t\t\t\t\treturn anotherStringer{\n\t\t\t\t\t\t\"another stringer\",\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer1 myStringer, fromStringer2 *fromStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer1.String() + \" and \" + fromStringer2.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(anotherStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"another stringer and a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Provide with empty From type\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tnewFromStringer,\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer *fromStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Provide with variadic function\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tnewFromStringer,\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer, x ...int) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t\t}),\n\t\t\t\ttt.provide,\n\t\t\t\tfx.Invoke(tt.invoke),\n\t\t\t)\n\t\t\trequire.NoError(t, app.Err())\n\t\t})\n\t}\n}\n\nfunc TestAnnotatedFromFailures(t *testing.T) {\n\tt.Parallel()\n\ttype myStringer interface {\n\t\tString() string\n\t}\n\n\tnewFromStringer := func() *fromStringer {\n\t\treturn &fromStringer{name: \"stringer\"}\n\t}\n\n\ttests := []struct {\n\t\tdesc          string\n\t\tprovide       fx.Option\n\t\tinvoke        interface{}\n\t\terrorContains string\n\t}{\n\t\t{\n\t\t\tdesc: \"provide when an illegal type From\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(writer io.Writer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(stringer fmt.Stringer) {\n\t\t\t\tfmt.Println(stringer.String())\n\t\t\t},\n\t\t\terrorContains: \"*fx_test.fromStringer does not implement io.Writer\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide with variadic function and an illegal type From\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(writer io.Writer, x ...int) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(stringer fmt.Stringer) {\n\t\t\t\tfmt.Println(stringer.String())\n\t\t\t},\n\t\t\terrorContains: \"*fx_test.fromStringer does not implement io.Writer\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"don't provide original type using From\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(stringer fmt.Stringer) {\n\t\t\t\tfmt.Println(stringer.String())\n\t\t\t},\n\t\t\terrorContains: \"missing type: *fx_test.fromStringer\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"fail to provide with name annotation\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewFromStringer,\n\t\t\t\t),\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(myStringer myStringer) fmt.Stringer {\n\t\t\t\t\t\treturn &fromStringer{\n\t\t\t\t\t\t\tname: myStringer.String(),\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfx.From(new(*fromStringer)),\n\t\t\t\t\tfx.ParamTags(`name:\"struct1\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t\terrorContains: `missing type: *fx_test.fromStringer[name=\"struct1\"]`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"non-pointer argument to From\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewFromStringer,\n\t\t\t\t\tfx.From(\"foo\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\terrorContains: \"argument must be a pointer\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"multiple from annotations\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewFromStringer,\n\t\t\t\t\tfx.From(new(asStringer)),\n\t\t\t\t\tfx.From(new(asStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\terrorContains: \"cannot apply more than one line of From\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"variadic argument\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(ss ...myStringer) {},\n\t\t\t\t\tfx.From(new(asStringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\terrorContains: \"cannot annotate a variadic argument\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t\t}),\n\t\t\t\ttt.provide,\n\t\t\t\tfx.Invoke(tt.invoke),\n\t\t\t)\n\t\t\terr := app.Err()\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), tt.errorContains)\n\t\t})\n\t}\n}\n\nfunc TestAnnotatedAs(t *testing.T) {\n\tt.Parallel()\n\ttype in struct {\n\t\tfx.In\n\n\t\tS fmt.Stringer `name:\"goodStringer\"`\n\t}\n\ttype inSelf struct {\n\t\tfx.In\n\n\t\tS1 fmt.Stringer `name:\"goodStringer\"`\n\t\tS2 *asStringer  `name:\"goodStringer\"`\n\t}\n\ttype myStringer interface {\n\t\tString() string\n\t}\n\n\tnewAsStringer := func() *asStringer {\n\t\treturn &asStringer{\n\t\t\tname: \"a good stringer\",\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tdesc     string\n\t\tprovide  fx.Option\n\t\tinvoke   interface{}\n\t\tstartApp bool\n\t}{\n\t\t{\n\t\t\tdesc: \"provide a good stringer\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(newAsStringer, fx.As(new(fmt.Stringer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"a good stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"value type implementing interface\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() anotherStringer {\n\t\t\t\t\treturn anotherStringer{\n\t\t\t\t\t\t\"another stringer\",\n\t\t\t\t\t}\n\t\t\t\t}, fx.As(new(fmt.Stringer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, s.String(), \"another stringer\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide with multiple types As\",\n\t\t\tprovide: fx.Provide(fx.Annotate(func() (*asStringer, *bytes.Buffer) {\n\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\tb := bytes.NewBuffer(buf)\n\t\t\t\treturn &asStringer{name: \"stringer\"}, b\n\t\t\t}, fx.As(new(fmt.Stringer), new(io.Writer)))),\n\t\t\tinvoke: func(s fmt.Stringer, w io.Writer) {\n\t\t\t\tw.Write([]byte(s.String()))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide as with result annotation\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() *asStringer {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t},\n\t\t\t\t\tfx.ResultTags(`name:\"goodStringer\"`),\n\t\t\t\t\tfx.As(new(fmt.Stringer))),\n\t\t\t),\n\t\t\tinvoke: func(i in) {\n\t\t\t\tassert.Equal(t, \"stringer\", i.S.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// same as the test above, except now we annotate\n\t\t\t// it in a different order.\n\t\t\tdesc: \"provide as with result annotation, in different order\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() *asStringer {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t},\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t\tfx.ResultTags(`name:\"goodStringer\"`)),\n\t\t\t),\n\t\t\tinvoke: func(i in) {\n\t\t\t\tassert.Equal(t, \"stringer\", i.S.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide as with result annotation with error\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, error) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}, nil\n\t\t\t\t},\n\t\t\t\t\tfx.ResultTags(`name:\"goodStringer\"`),\n\t\t\t\t\tfx.As(new(fmt.Stringer))),\n\t\t\t),\n\t\t\tinvoke: func(i in) {\n\t\t\t\tassert.Equal(t, \"stringer\", i.S.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide as with result annotation in different order with error\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, error) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}, nil\n\t\t\t\t},\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t\tfx.ResultTags(`name:\"goodStringer\"`)),\n\t\t\t),\n\t\t\tinvoke: func(i in) {\n\t\t\t\tassert.Equal(t, \"stringer\", i.S.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide multiple constructors annotated As\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() *asStringer {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t}, fx.As(new(fmt.Stringer))),\n\t\t\t\tfx.Annotate(func() *bytes.Buffer {\n\t\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\t\treturn bytes.NewBuffer(buf)\n\t\t\t\t}, fx.As(new(io.Writer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\t_, err := w.Write([]byte{1})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"provide the same provider as multiple types\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(newAsStringer, fx.As(new(fmt.Stringer))),\n\t\t\t\tfx.Annotate(newAsStringer, fx.As(new(myStringer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, ms myStringer) {\n\t\t\t\tassert.Equal(t, \"a good stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"a good stringer\", ms.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate fx.Supply\",\n\t\t\tprovide: fx.Supply(\n\t\t\t\tfx.Annotate(&asStringer{\"foo\"}, fx.As(new(fmt.Stringer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer) {\n\t\t\t\tassert.Equal(t, \"foo\", s.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate as many interfaces\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, error) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"}, nil\n\t\t\t\t},\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t\tfx.As(new(myStringer)),\n\t\t\t\t\tfx.ResultTags(`name:\"stringer\"`)),\n\t\t\t),\n\t\t\tinvoke: fx.Annotate(\n\t\t\t\tfunc(\n\t\t\t\t\tS fmt.Stringer,\n\t\t\t\t\tMS myStringer,\n\t\t\t\t) {\n\t\t\t\t\tassert.Equal(t, \"stringer\", S.String())\n\t\t\t\t\tassert.Equal(t, \"stringer\", MS.String())\n\t\t\t\t}, fx.ParamTags(`name:\"stringer\"`, `name:\"stringer\"`),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate as many interfaces with both-annotated return values\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"},\n\t\t\t\t\t\tbytes.NewBuffer(make([]byte, 1))\n\t\t\t\t},\n\t\t\t\t\tfx.As(new(fmt.Stringer), new(io.Reader)),\n\t\t\t\t\tfx.As(new(myStringer), new(io.Writer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, ms myStringer, r io.Reader, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", ms.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\t_, err = r.Read(buf)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate as many interfaces with different numbers of annotations\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"},\n\t\t\t\t\t\tbytes.NewBuffer(make([]byte, 1))\n\t\t\t\t},\n\t\t\t\t\t// annotate both in here\n\t\t\t\t\tfx.As(new(fmt.Stringer), new(io.Writer)),\n\t\t\t\t\t// annotate just myStringer here\n\t\t\t\t\tfx.As(new(myStringer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, ms myStringer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", ms.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate many interfaces with varying annotation count and check original type\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"},\n\t\t\t\t\t\tbytes.NewBuffer(make([]byte, 1))\n\t\t\t\t},\n\t\t\t\t\t// annotate just myStringer here\n\t\t\t\t\tfx.As(new(myStringer)),\n\t\t\t\t\t// annotate both in here\n\t\t\t\t\tfx.As(new(fmt.Stringer), new(io.Writer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, ms myStringer, buf *bytes.Buffer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", ms.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\t_, err = buf.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"annotate fewer items than provided constructor\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*bytes.Buffer, *strings.Builder) {\n\t\t\t\t\ts := \"Hello\"\n\t\t\t\t\treturn bytes.NewBuffer([]byte(s)), &strings.Builder{}\n\t\t\t\t},\n\t\t\t\t\tfx.As(new(io.Reader))),\n\t\t\t),\n\t\t\tinvoke: func(r io.Reader) {\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"results annotated as are provided to hooks as annotated types\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(func() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\treturn &asStringer{name: \"stringer\"},\n\t\t\t\t\t\tbytes.NewBuffer([]byte{})\n\t\t\t\t},\n\t\t\t\t\t// lifecycle hook added is able to receive results as annotated\n\t\t\t\t\tfx.OnStart(func(s fmt.Stringer, ms myStringer, buf *bytes.Buffer, w io.Writer) {\n\t\t\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\t\t\tassert.Equal(t, \"stringer\", ms.String())\n\t\t\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\t\t_, err = buf.Write([]byte(\".\"))\n\t\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\t}),\n\t\t\t\t\tfx.OnStop(func(buf *bytes.Buffer) {\n\t\t\t\t\t\tassert.Equal(t, \"....\", buf.String(), \"buffer should contain bytes written in Invoke func and OnStart hook\")\n\t\t\t\t\t}),\n\t\t\t\t\t// annotate just myStringer here\n\t\t\t\t\tfx.As(new(myStringer)),\n\t\t\t\t\t// annotate both in here\n\t\t\t\t\tfx.As(new(fmt.Stringer), new(io.Writer))),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, ms myStringer, buf *bytes.Buffer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", ms.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\t_, err = buf.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t\tstartApp: true,\n\t\t},\n\t\t{\n\t\t\tdesc: \"self w other As annotations\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() *asStringer {\n\t\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t\t},\n\t\t\t\t\tfx.As(fx.Self()),\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, as *asStringer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", as.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"self as one As target\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\t\ts := &asStringer{name: \"stringer\"}\n\t\t\t\t\t\tb := &bytes.Buffer{}\n\t\t\t\t\t\treturn s, b\n\t\t\t\t\t},\n\t\t\t\t\tfx.As(fx.Self(), new(io.Writer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s *asStringer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"two as, two self, four types\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() (*asStringer, *bytes.Buffer) {\n\t\t\t\t\t\ts := &asStringer{name: \"stringer\"}\n\t\t\t\t\t\tb := &bytes.Buffer{}\n\t\t\t\t\t\treturn s, b\n\t\t\t\t\t},\n\t\t\t\t\tfx.As(fx.Self(), new(io.Writer)),\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s1 *asStringer, s2 fmt.Stringer, b *bytes.Buffer, w io.Writer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s1.String())\n\t\t\t\tassert.Equal(t, \"stringer\", s2.String())\n\t\t\t\t_, err := w.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\t_, err = b.Write([]byte(\".\"))\n\t\t\t\tassert.NoError(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"self with lifecycle hook\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() *asStringer {\n\t\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t\t},\n\t\t\t\t\tfx.As(fx.Self()),\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t\tfx.OnStart(func(s fmt.Stringer, as *asStringer) {\n\t\t\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\t\t\tassert.Equal(t, \"stringer\", as.String())\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(s fmt.Stringer, as *asStringer) {\n\t\t\t\tassert.Equal(t, \"stringer\", s.String())\n\t\t\t\tassert.Equal(t, \"stringer\", as.String())\n\t\t\t},\n\t\t\tstartApp: true,\n\t\t},\n\t\t{\n\t\t\tdesc: \"self with result tags\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() *asStringer {\n\t\t\t\t\t\treturn &asStringer{name: \"stringer\"}\n\t\t\t\t\t},\n\t\t\t\t\tfx.As(fx.Self()),\n\t\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t\t\tfx.ResultTags(`name:\"goodStringer\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinvoke: func(i inSelf) {\n\t\t\t\tassert.Equal(t, \"stringer\", i.S1.String())\n\t\t\t\tassert.Equal(t, \"stringer\", i.S2.String())\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t\t}),\n\t\t\t\ttt.provide,\n\t\t\t\tfx.Invoke(tt.invoke),\n\t\t\t)\n\t\t\trequire.NoError(t, app.Err())\n\t\t\tif tt.startApp {\n\t\t\t\tctx := context.Background()\n\t\t\t\trequire.NoError(t, app.Start(ctx))\n\t\t\t\trequire.NoError(t, app.Stop(ctx))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAnnotatedAsFailures(t *testing.T) {\n\tt.Parallel()\n\n\tnewAsStringer := func() *asStringer {\n\t\treturn &asStringer{name: \"stringer\"}\n\t}\n\n\tnewAsStringerWithErr := func() (*asStringer, error) {\n\t\treturn nil, errors.New(\"great sadness\")\n\t}\n\n\ttests := []struct {\n\t\tdesc          string\n\t\tprovide       fx.Option\n\t\tinvoke        interface{}\n\t\terrorContains string\n\t}{\n\t\t{\n\t\t\tdesc:          \"provide when an illegal type As\",\n\t\t\tprovide:       fx.Provide(fx.Annotate(newAsStringer, fx.As(new(io.Writer)))),\n\t\t\tinvoke:        func() {},\n\t\t\terrorContains: \"asStringer does not implement io.Writer\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"provide when an illegal type As with result tag\",\n\t\t\tprovide:       fx.Provide(fx.Annotate(newAsStringer, fx.ResultTags(`name:\"stringer\"`), fx.As(new(io.Writer)))),\n\t\t\tinvoke:        func() {},\n\t\t\terrorContains: \"asStringer does not implement io.Writer\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"error is propagated without result tag\",\n\t\t\tprovide:       fx.Provide(fx.Annotate(newAsStringerWithErr, fx.As(new(fmt.Stringer)))),\n\t\t\tinvoke:        func(_ fmt.Stringer) {},\n\t\t\terrorContains: \"great sadness\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"error is propagated with result tag\",\n\t\t\tprovide:       fx.Provide(fx.Annotate(newAsStringerWithErr, fx.ResultTags(`name:\"stringer\"`), fx.As(new(fmt.Stringer)))),\n\t\t\tinvoke:        fx.Annotate(func(_ fmt.Stringer) {}, fx.ParamTags(`name:\"stringer\"`)),\n\t\t\terrorContains: \"great sadness\",\n\t\t},\n\t\t{\n\t\t\tdesc:    \"don't provide original type using As\",\n\t\t\tprovide: fx.Provide(fx.Annotate(newAsStringer, fx.As(new(fmt.Stringer)))),\n\t\t\tinvoke: func(as *asStringer) {\n\t\t\t\tfmt.Println(as.String())\n\t\t\t},\n\t\t\terrorContains: \"missing type: *fx_test.asStringer\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"fail to provide with name annotation\",\n\t\t\tprovide: fx.Provide(fx.Annotate(func(n string) *asStringer {\n\t\t\t\treturn &asStringer{name: n}\n\t\t\t}, fx.As(new(fmt.Stringer)), fx.ParamTags(`name:\"n\"`))),\n\t\t\tinvoke: func(a fmt.Stringer) {\n\t\t\t\tfmt.Println(a)\n\t\t\t},\n\t\t\terrorContains: `missing type: string[name=\"n\"]`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"non-pointer argument to As\",\n\t\t\tprovide: fx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewAsStringer,\n\t\t\t\t\tfx.As(\"foo\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\terrorContains: \"argument must be a pointer to an interface: got string\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t\t}),\n\t\t\t\ttt.provide,\n\t\t\t\tfx.Invoke(tt.invoke),\n\t\t\t)\n\t\t\terr := app.Err()\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), tt.errorContains)\n\t\t})\n\t}\n}\n\nfunc TestAnnotatedWrongUsage(t *testing.T) {\n\tt.Parallel()\n\n\ttype a struct {\n\t\tname string\n\t}\n\ttype in struct {\n\t\tfx.In\n\n\t\tA *a `name:\"foo\"`\n\t}\n\tnewA := func() *a {\n\t\treturn &a{name: \"foo\"}\n\t}\n\n\tt.Run(\"In Constructor\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar in in\n\t\tapp := NewForTest(t,\n\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t}),\n\t\t\tfx.Provide(\n\t\t\t\tfunc() fx.Annotated {\n\t\t\t\t\treturn fx.Annotated{\n\t\t\t\t\t\tName:   \"foo\",\n\t\t\t\t\t\tTarget: newA,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t),\n\t\t\tfx.Populate(&in),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\t// Example:\n\t\t// fx.Annotated should be passed to fx.Provide directly, it should not be returned by the constructor: fx.Provide received go.uber.org/fx_test.TestAnnotatedWrongUsage.func2.1() from:\n\t\t// go.uber.org/fx_test.TestAnnotatedWrongUsage.func2\n\t\t//         /.../fx/annotated_test.go:76\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\tassert.Contains(t, err.Error(), \"fx.Annotated should be passed to fx.Provide directly, it should not be returned by the constructor\")\n\t\tassert.Contains(t, err.Error(), \"fx.Provide received go.uber.org/fx_test.TestAnnotatedWrongUsage\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestAnnotatedWrongUsage\")\n\t\tassert.Contains(t, err.Error(), \"/annotated_test.go\")\n\t})\n\n\tt.Run(\"Result Type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.WithLogger(func() fxevent.Logger {\n\t\t\t\treturn fxtest.NewTestLogger(t)\n\t\t\t}),\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotated{\n\t\t\t\t\tName: \"foo\",\n\t\t\t\t\tTarget: func() in {\n\t\t\t\t\t\treturn in{A: &a{name: \"foo\"}}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\t\tassert.Contains(t, app.Err().Error(), \"embeds a dig.In\", \"expected error when result types were annotated\")\n\t})\n\n\tt.Run(\"invalid group option\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() string { return \"sad times\" },\n\t\t\t\t\tfx.ResultTags(`group:\"foo,soft\"`)),\n\t\t\t),\n\t\t)\n\t\tassert.Contains(t, app.Err().Error(), \"cannot use soft with result value groups\", \"expected error when invalid group option is provided\")\n\t})\n}\n\nfunc TestAnnotatedString(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive fx.Annotated\n\t\twant string\n\t}{\n\t\t{\n\t\t\tdesc: \"empty\",\n\t\t\tgive: fx.Annotated{},\n\t\t\twant: \"fx.Annotated{}\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"name\",\n\t\t\tgive: fx.Annotated{Name: \"foo\"},\n\t\t\twant: `fx.Annotated{Name: \"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"group\",\n\t\t\tgive: fx.Annotated{Group: \"foo\"},\n\t\t\twant: `fx.Annotated{Group: \"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"name and group\",\n\t\t\tgive: fx.Annotated{Name: \"foo\", Group: \"bar\"},\n\t\t\twant: `fx.Annotated{Name: \"foo\", Group: \"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"target\",\n\t\t\tgive: fx.Annotated{Target: func() {}},\n\t\t\twant: \"fx.Annotated{Target: go.uber.org/fx_test.TestAnnotatedString.func1()}\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"name and target\",\n\t\t\tgive: fx.Annotated{Name: \"foo\", Target: func() {}},\n\t\t\twant: `fx.Annotated{Name: \"foo\", Target: go.uber.org/fx_test.TestAnnotatedString.func2()}`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"group and target\",\n\t\t\tgive: fx.Annotated{Group: \"foo\", Target: func() {}},\n\t\t\twant: `fx.Annotated{Group: \"foo\", Target: go.uber.org/fx_test.TestAnnotatedString.func3()}`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"name, group and target\",\n\t\t\tgive: fx.Annotated{Name: \"foo\", Group: \"bar\", Target: func() {}},\n\t\t\twant: `fx.Annotated{Name: \"foo\", Group: \"bar\", Target: go.uber.org/fx_test.TestAnnotatedString.func4()}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tassert.Equal(t, tt.want, tt.give.String())\n\t\t})\n\t}\n}\n\nfunc TestAnnotate(t *testing.T) {\n\tt.Parallel()\n\n\ttype a struct{}\n\ttype b struct{ a *a }\n\ttype c struct{ b *b }\n\ttype sliceA struct{ sa []*a }\n\tnewA := func() *a { return &a{} }\n\tnewB := func(a *a) *b {\n\t\treturn &b{a}\n\t}\n\tnewC := func(b *b) *c {\n\t\treturn &c{b}\n\t}\n\tnewSliceA := func(sa ...*a) *sliceA {\n\t\treturn &sliceA{sa}\n\t}\n\tnewSliceAWithB := func(b *b, sa ...*a) *sliceA {\n\t\ttotal := append(sa, b.a)\n\t\treturn &sliceA{total}\n\t}\n\n\tt.Run(\"Provide with empty param+result tags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tnewA,\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(), fx.ResultTags()),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"Provide with optional\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`name:\"a\" optional:\"true\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"Provide with many annotated params\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`optional:\"true\"`)),\n\t\t\t\tfx.Annotate(func(a *a, b *b) interface{} { return nil },\n\t\t\t\t\tfx.ParamTags(`name:\"a\" optional:\"true\"`, `name:\"b\"`),\n\t\t\t\t\tfx.ResultTags(`name:\"nil\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"Invoke with optional\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`optional:\"true\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"Invoke with a missing dependency\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`name:\"a\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), `missing dependencies`)\n\t\tassert.Contains(t, err.Error(), `missing type: *fx_test.a[name=\"a\"]`)\n\t})\n\n\tt.Run(\"Provide with variadic function\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar got *sliceA\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotated{Group: \"as\", Target: newA},\n\t\t\t\tfx.Annotated{Group: \"as\", Target: newA},\n\t\t\t\tfx.Annotate(newSliceA,\n\t\t\t\t\tfx.ParamTags(`group:\"as\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Populate(&got),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\n\t\tassert.Len(t, got.sa, 2)\n\t})\n\n\tt.Run(\"Provide variadic function with no optional params\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar got struct {\n\t\t\tfx.In\n\n\t\t\tResult *sliceA `name:\"as\"`\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply([]*a{{}, {}, {}}),\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(newSliceA,\n\t\t\t\t\tfx.ResultTags(`name:\"as\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Populate(&got),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t\tassert.Len(t, got.Result.sa, 3)\n\t})\n\n\tt.Run(\"Provide variadic function named with no given params\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar got *sliceA\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(newSliceA, fx.ParamTags(`name:\"a\"`)),\n\t\t\t),\n\t\t\tfx.Populate(&got),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), `missing dependencies`)\n\t\tassert.Contains(t, err.Error(), `missing type: []*fx_test.a[name=\"a\"]`)\n\t})\n\n\tt.Run(\"Invoke function with soft group param\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tnewF := func(foos []int, bar string) {\n\t\t\tassert.ElementsMatch(t, []int{10}, foos)\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() (int, string) { return 10, \"hello\" },\n\t\t\t\t\tfx.ResultTags(`group:\"foos\"`),\n\t\t\t\t),\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() int {\n\t\t\t\t\t\trequire.FailNow(t, \"this function should not be called\")\n\t\t\t\t\t\treturn 20\n\t\t\t\t\t},\n\t\t\t\t\tfx.ResultTags(`group:\"foos\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(newF, fx.ParamTags(`group:\"foos,soft\"`)),\n\t\t\t),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"Invoke variadic function with multiple params\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotate(newB(newA()), fx.ResultTags(`name:\"b\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(fx.Annotate(newSliceAWithB, fx.ParamTags(`name:\"b\"`))),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"Invoke non-optional variadic function with a missing dependency\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(newSliceA, fx.ParamTags(`optional:\"false\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), `missing dependencies`)\n\t\tassert.Contains(t, err.Error(), `missing type: []*fx_test.a`)\n\t})\n\n\tt.Run(\"Invoke with variadic function\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype T1 struct{ s string }\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotate(T1{\"foo\"}, fx.ResultTags(`group:\"t\"`)),\n\t\t\t\tfx.Annotate(T1{\"bar\"}, fx.ResultTags(`group:\"t\"`)),\n\t\t\t\tfx.Annotate(T1{\"baz\"}, fx.ResultTags(`group:\"t\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(fx.Annotate(func(got ...T1) {\n\t\t\t\tassert.ElementsMatch(t, []T1{{\"foo\"}, {\"bar\"}, {\"baz\"}}, got)\n\t\t\t}, fx.ParamTags(`group:\"t\"`))),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"provide with annotated results\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"firstA\"`)),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"secondA\"`)),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"thirdA\"`)),\n\t\t\t\tfx.Annotate(func(a1 *a, a2 *a, a3 *a) *b {\n\t\t\t\t\treturn &b{a1}\n\t\t\t\t}, fx.ParamTags(\n\t\t\t\t\t`name:\"firstA\"`,\n\t\t\t\t\t`name:\"secondA\"`,\n\t\t\t\t\t`name:\"thirdA\"`,\n\t\t\t\t)),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\n\t\trequire.NoError(t, app.Err())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide with missing annotated results\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"firstA\"`)),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"secondA\"`)),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"fourthA\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(func(a1 *a, a2 *a, a3 *a) *b {\n\t\t\t\t\treturn &b{a1}\n\t\t\t\t}, fx.ParamTags(\n\t\t\t\t\t`name:\"firstA\"`,\n\t\t\t\t\t`name:\"secondA\"`,\n\t\t\t\t\t`name:\"thirdA\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), `missing type: *fx_test.a[name=\"thirdA\"]`)\n\t})\n\n\tt.Run(\"error in the middle of a function\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\t//lint:ignore ST1008 we want to test error in the middle.\n\t\t\t\tfx.Annotate(func() (*a, error, *a) {\n\t\t\t\t\treturn &a{}, nil, &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"firstA\"`, ``, `name:\"secondA\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(func(*a) {}, fx.ParamTags(`name:\"firstA\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"only the last result can be an error\")\n\t\tassert.Contains(t, err.Error(), \"returns error as result 1\")\n\t})\n\n\tt.Run(\"provide with annotated results with error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() (*a, *a, error) {\n\t\t\t\t\treturn &a{}, &a{}, nil\n\t\t\t\t}, fx.ResultTags(`name:\"firstA\"`, `name:\"secondA\"`)),\n\t\t\t\tfx.Annotate(func() (*a, error) {\n\t\t\t\t\treturn &a{}, nil\n\t\t\t\t}, fx.ResultTags(`name:\"thirdA\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(fx.Annotate(func(a1 *a, a2 *a, a3 *a) *b {\n\t\t\t\treturn &b{a2}\n\t\t\t}, fx.ParamTags(`name:\"firstA\"`, `name:\"secondA\"`, `name:\"thirdA\"`))))\n\n\t\trequire.NoError(t, app.Err())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide an already provided function using Annotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(fx.Annotate(newA, fx.ResultTags(`name:\"a\"`))),\n\t\t\tfx.Provide(fx.Annotate(newA, fx.ResultTags(`name:\"a\"`))),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`name:\"a\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"already provided\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestAnnotate.func\")\n\t})\n\n\tt.Run(\"specify more ParamTags than Params\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\t// This should just leave newA as it is.\n\t\t\t\tfx.Annotate(newA, fx.ParamTags(`name:\"something\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(newB),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.NoError(t, err)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"specify two ParamTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\t// This should just leave newA as it is.\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewA,\n\t\t\t\t\tfx.ParamTags(`name:\"something\"`),\n\t\t\t\t\tfx.ParamTags(`name:\"anotherThing\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(newB),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"encountered error while applying annotation using fx.Annotate to go.uber.org/fx_test.TestAnnotate.func1(): cannot apply more than one line of ParamTags\")\n\t})\n\n\tt.Run(\"specify two ResultTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\t// This should just leave newA as it is.\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewA,\n\t\t\t\t\tfx.ResultTags(`name:\"A\"`),\n\t\t\t\t\tfx.ResultTags(`name:\"AA\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(newB),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"encountered error while applying annotation using fx.Annotate to go.uber.org/fx_test.TestAnnotate.func1(): cannot apply more than one line of ResultTags\")\n\t})\n\n\tt.Run(\"annotate with a non-nil error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() (*bytes.Buffer, error) {\n\t\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\t\treturn bytes.NewBuffer(buf), errors.New(\"some error\")\n\t\t\t\t}, fx.ResultTags(`name:\"buf\"`))),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(func(b *bytes.Buffer) {\n\t\t\t\t\tb.Write([]byte{1})\n\t\t\t\t}, fx.ParamTags(`name:\"buf\"`))),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"some error\")\n\t})\n\n\tt.Run(\"annotate with a non-nil error and nil error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() (*bytes.Buffer, error) {\n\t\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\t\treturn bytes.NewBuffer(buf), errors.New(\"some error\")\n\t\t\t\t}, fx.ResultTags(`name:\"buf1\"`)),\n\t\t\t\tfx.Annotate(func() (*bytes.Buffer, error) {\n\t\t\t\t\tbuf := make([]byte, 1)\n\t\t\t\t\treturn bytes.NewBuffer(buf), nil\n\t\t\t\t}, fx.ResultTags(`name:\"buf2\"`))),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(func(b1 *bytes.Buffer, b2 *bytes.Buffer) {\n\t\t\t\t\tb1.Write([]byte{1})\n\t\t\t\t\tb2.Write([]byte{1})\n\t\t\t\t}, fx.ParamTags(`name:\"buf1\"`, `name:\"buf2\"`))),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"some error\")\n\t})\n\n\tt.Run(\"provide annotated non-function\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(42, fx.ResultTags(`name:\"buf\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\t// Example:\n\t\t// fx.Provide(fx.Annotate(42, fx.ResultTags([\"name:\\\"buf\\\"\"])) from:\n\t\t// go.uber.org/fx_test.TestAnnotate.func17\n\t\t//     /Users/abg/dev/fx/annotated_test.go:697\n\t\t// testing.tRunner\n\t\t//     /usr/local/Cellar/go/1.17.2/libexec/src/testing/testing.go:1259\n\t\t// Failed: must provide constructor function, got 42 (int)\n\n\t\tassert.Contains(t, err.Error(), \"fx.Provide(fx.Annotate(42\")\n\t\tassert.Contains(t, err.Error(), \"must provide constructor function, got 42 (int)\")\n\t})\n\n\tt.Run(\"invoke annotated non-function\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(42, fx.ParamTags(`name:\"buf\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"must provide constructor function, got 42 (int)\")\n\t})\n\n\tt.Run(\"annotate a fx.Out with ResultTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\ts string\n\n\t\t\tfx.Out\n\t\t}\n\n\t\tf := func() A {\n\t\t\treturn A{s: \"hi\"}\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(f, fx.ResultTags(`name:\"out\"`)),\n\t\t\t),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"fx.Out structs cannot be annotated with fx.ResultTags or fx.As\")\n\t})\n\n\tt.Run(\"annotate a fx.Out with As\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype I interface{}\n\n\t\ttype B struct {\n\t\t\t// implements I\n\t\t}\n\n\t\ttype Res struct {\n\t\t\tfx.Out\n\n\t\t\tAB B\n\t\t}\n\n\t\tf := func() Res {\n\t\t\treturn Res{AB: B{}}\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(f, fx.As(new(I))),\n\t\t\t),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"fx.Out structs cannot be annotated with fx.ResultTags or fx.As\")\n\t})\n\n\tt.Run(\"annotate a fx.In with ParamTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tS string\n\t\t}\n\t\ttype B struct {\n\t\t\tfx.In\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func(i A) string { return i.S }, fx.ParamTags(`optional:\"true\"`)),\n\t\t\t\tfx.Annotate(func(i B) string { return \"ok\" }, fx.ParamTags(`name:\"problem\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.NotContains(t, err.Error(), \"invalid annotation function func(fx_test.A) string\")\n\t\tassert.Contains(t, err.Error(), \"invalid annotation function func(fx_test.B) string\")\n\t\tassert.Contains(t, err.Error(), \"fx.In structs cannot be annotated with fx.ParamTags or fx.From\")\n\t})\n\n\tt.Run(\"annotate a fx.In with From\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype I interface{}\n\n\t\ttype B struct {\n\t\t\t// implements I\n\t\t}\n\n\t\ttype Param struct {\n\t\t\tfx.In\n\t\t\tBInterface I\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func(p Param) string { return \"ok\" }, fx.From(new(B))),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"invalid annotation function func(fx_test.Param) string\")\n\t\tassert.Contains(t, err.Error(), \"fx.In structs cannot be annotated with fx.ParamTags or fx.From\")\n\t})\n\n\tt.Run(\"annotate fx.In with fx.ResultTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tfx.In\n\n\t\t\tI int\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func(a A) string { return \"ok\" + strconv.Itoa(a.I) }, fx.ResultTags(`name:\"val\"`)),\n\t\t\t\tfunc() int {\n\t\t\t\t\treturn 1\n\t\t\t\t},\n\t\t\t),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(func(s string) {\n\t\t\t\t\tassert.Equal(t, \"ok1\", s)\n\t\t\t\t}, fx.ParamTags(`name:\"val\"`)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"annotate fx.Out with fx.ParamTags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tfx.Out\n\n\t\t\tS string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() int { return 1 }, fx.ResultTags(`name:\"val\"`)),\n\t\t\t\tfx.Annotate(func(i int) A { return A{S: strconv.Itoa(i)} }, fx.ParamTags(`name:\"val\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(func(s string) {\n\t\t\t\tassert.Equal(t, \"1\", s)\n\t\t\t}),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.NoError(t, err)\n\t})\n}\n\nfunc TestAnnotateApplyFail(t *testing.T) {\n\ttype a struct{}\n\ttype b struct{ a *a }\n\tnewA := func() *a { return &a{} }\n\tnewB := func(a *a) *b {\n\t\treturn &b{a}\n\t}\n\n\tvar (\n\t\terrTagSyntaxSpace            = `multiple tags are not separated by space`\n\t\terrTagKeySyntax              = \"tag key is invalid, Use group, name or optional as tag keys\"\n\t\terrTagValueSyntaxQuote       = `tag value should start with double quote. i.e. key:\"value\" `\n\t\terrTagValueSyntaxEndingQuote = `tag value should end in double quote. i.e. key:\"value\" `\n\t)\n\ttests := []struct {\n\t\tgive                 string\n\t\twantErr              string\n\t\tgiveAnnotationParam  fx.Annotation\n\t\tgiveAnnotationResult fx.Annotation\n\t}{\n\t\t{\n\t\t\tgive:                 \"Tags value invalid ending quote\",\n\t\t\twantErr:              errTagValueSyntaxEndingQuote,\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name:\"something'`),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`name:\"something'`),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"Tags value wrong starting quote\",\n\t\t\twantErr:              errTagValueSyntaxQuote,\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name:\"something\" optional:'true\"`),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`name:\"something\" optional:'true\"`),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"Tags multiple tags not separated by space\",\n\t\t\twantErr:              errTagSyntaxSpace,\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name:\"something\"group:\"something\"`),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`name:\"something\"group:\"something\"`),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"Tags key not equal to group, name or optional\",\n\t\t\twantErr:              errTagKeySyntax,\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name1:\"something\"`),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`name1:\"something\"`),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"Tags key empty\",\n\t\t\twantErr:              errTagKeySyntax,\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`:\"something\"`),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`:\"something\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(\"Param \"+tt.give, func(t *testing.T) {\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.Provide(\n\t\t\t\t\tfx.Annotate(\n\t\t\t\t\t\tnewA,\n\t\t\t\t\t\ttt.giveAnnotationParam,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tfx.Invoke(newB),\n\t\t\t)\n\t\t\tassert.ErrorContains(t, app.Err(), tt.wantErr)\n\t\t})\n\t\tt.Run(\"Result \"+tt.give, func(t *testing.T) {\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.Provide(\n\t\t\t\t\tfx.Annotate(\n\t\t\t\t\t\tnewA,\n\t\t\t\t\t\ttt.giveAnnotationResult,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tfx.Invoke(newB),\n\t\t\t)\n\t\t\tassert.ErrorContains(t, app.Err(), tt.wantErr)\n\t\t})\n\t}\n}\n\nfunc TestAnnotateApplySuccess(t *testing.T) {\n\ttype a struct{}\n\ttype b struct{ a *a }\n\tnewA := func() *a { return &a{} }\n\tnewB := func(a *a) *b {\n\t\treturn &b{a}\n\t}\n\n\ttests := []struct {\n\t\tgive                 string\n\t\tgiveAnnotationParam  fx.Annotation\n\t\tgiveAnnotationResult fx.Annotation\n\t}{\n\t\t{\n\t\t\tgive:                 \"ParamTags Tag Empty\",\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`  `),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`  `),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"ParamTags Tag Empty with extra spaces\",\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name:\"versionNum\"`, `  `),\n\t\t\tgiveAnnotationResult: fx.ResultTags(`   `, `group:\"versionNum\"`),\n\t\t},\n\t\t{\n\t\t\tgive:                 \"ParamTags Tag with \\\\ \",\n\t\t\tgiveAnnotationParam:  fx.ParamTags(`name:\"version\\\\Num\"`, `  `),\n\t\t\tgiveAnnotationResult: fx.ResultTags(``, `group:\"version\\\\Num\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.give, func(t *testing.T) {\n\t\t\tapp := NewForTest(t,\n\t\t\t\tfx.Provide(\n\t\t\t\t\tfx.Annotate(\n\t\t\t\t\t\tnewA,\n\t\t\t\t\t\ttt.giveAnnotationParam,\n\t\t\t\t\t\ttt.giveAnnotationResult,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tfx.Invoke(newB),\n\t\t\t)\n\t\t\trequire.NoError(t, app.Err())\n\t\t})\n\t}\n}\n\nfunc assertApp(\n\tt *testing.T,\n\tapp interface {\n\t\tStart(context.Context) error\n\t\tStop(context.Context) error\n\t},\n\tstarted *bool,\n\tstopped *bool,\n\tinvoked *bool,\n) {\n\tt.Helper()\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.False(t, *started)\n\trequire.NoError(t, app.Start(ctx))\n\tassert.True(t, *started)\n\n\tif invoked != nil {\n\t\tassert.True(t, *invoked)\n\t}\n\n\tif stopped != nil {\n\t\tassert.False(t, *stopped)\n\t\trequire.NoError(t, app.Stop(ctx))\n\t\tassert.True(t, *stopped)\n\t}\n\n\tdefer app.Stop(ctx)\n}\n\nfunc TestHookAnnotations(t *testing.T) {\n\tt.Parallel()\n\n\ttype a struct{}\n\ttype b struct{ a *a }\n\ttype c struct{ b *b }\n\tnewB := func(a *a) *b {\n\t\treturn &b{a}\n\t}\n\tnewC := func(b *b) *c {\n\t\treturn &c{b}\n\t}\n\n\tt.Run(\"with hook on invoke\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar (\n\t\t\tstarted bool\n\t\t\tstopped bool\n\t\t\tinvoked bool\n\t\t)\n\t\thook := fx.Annotate(\n\t\t\tfunc() {\n\t\t\t\tinvoked = true\n\t\t\t},\n\t\t\tfx.OnStart(func(context.Context) error {\n\t\t\t\tstarted = true\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t\tfx.OnStop(func(context.Context) error {\n\t\t\t\tstopped = true\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\t\tapp := fxtest.New(t, fx.Invoke(hook))\n\n\t\tassertApp(t, app, &started, &stopped, &invoked)\n\t})\n\n\tt.Run(\"depend on result interface of target\", func(t *testing.T) {\n\t\ttype stub interface {\n\t\t\tString() string\n\t\t}\n\n\t\tvar started bool\n\n\t\thook := fx.Annotate(\n\t\t\tfunc() (stub, error) {\n\t\t\t\tb := []byte(\"expected\")\n\t\t\t\treturn bytes.NewBuffer(b), nil\n\t\t\t},\n\t\t\tfx.OnStart(func(_ context.Context, s stub) error {\n\t\t\t\tstarted = true\n\t\t\t\trequire.Equal(t, \"expected\", s.String())\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(hook),\n\t\t\tfx.Invoke(func(s stub) {\n\t\t\t\trequire.Equal(t, \"expected\", s.String())\n\t\t\t}),\n\t\t)\n\n\t\tassertApp(t, app, &started, nil, nil)\n\t})\n\n\tt.Run(\"start and stop without dependencies\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype stub interface{}\n\n\t\tvar (\n\t\t\tinvoked bool\n\t\t\tstarted bool\n\t\t\tstopped bool\n\t\t)\n\n\t\thook := fx.Annotate(\n\t\t\tfunc() (stub, error) { return nil, nil },\n\t\t\tfx.OnStart(func(context.Context) error {\n\t\t\t\tstarted = true\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t\tfx.OnStop(func(context.Context) error {\n\t\t\t\tstopped = true\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(hook),\n\t\t\tfx.Invoke(func(s stub) {\n\t\t\t\tinvoked = s == nil\n\t\t\t}),\n\t\t)\n\n\t\tassertApp(t, app, &started, &stopped, &invoked)\n\t})\n\n\tt.Run(\"with multiple extra dependency parameters\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype (\n\t\t\tA interface{}\n\t\t\tB interface{}\n\t\t\tC interface{}\n\t\t)\n\n\t\tvar value int\n\n\t\thook := fx.Annotate(\n\t\t\tfunc(b B, c C) (A, error) { return nil, nil },\n\t\t\tfx.OnStart(func(_ context.Context, b B, c C) error {\n\t\t\t\tb1, _ := b.(int)\n\t\t\t\tc1, _ := c.(int)\n\t\t\t\tvalue = b1 + c1\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(hook),\n\t\t\tfx.Provide(func() B { return int(1) }),\n\t\t\tfx.Provide(func() C { return int(2) }),\n\t\t\tfx.Invoke(func(A) {}),\n\t\t)\n\n\t\tctx := context.Background()\n\t\tassert.Zero(t, value)\n\t\trequire.NoError(t, app.Start(ctx))\n\t\tdefer func() {\n\t\t\trequire.NoError(t, app.Stop(ctx))\n\t\t}()\n\t\tassert.Equal(t, 3, value)\n\t})\n\n\tt.Run(\"with Supply\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A interface {\n\t\t\tWriteString(string) (int, error)\n\t\t}\n\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tvar called bool\n\n\t\tctor := fx.Provide(\n\t\t\tfx.Annotate(\n\t\t\t\tfunc(s fmt.Stringer) A {\n\t\t\t\t\treturn buf\n\t\t\t\t},\n\t\t\t\tfx.OnStart(func(_ context.Context, a A, s fmt.Stringer) error {\n\t\t\t\t\ta.WriteString(s.String())\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\n\t\tsupply := fx.Supply(\n\t\t\tfx.Annotate(\n\t\t\t\t&asStringer{\"supply\"},\n\t\t\t\tfx.OnStart(func(context.Context) error {\n\t\t\t\t\tcalled = true\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t\tfx.As(new(fmt.Stringer)),\n\t\t\t))\n\n\t\topts := fx.Options(\n\t\t\tctor,\n\t\t\tsupply,\n\t\t\tfx.Invoke(func(A) {}),\n\t\t)\n\n\t\tapp := fxtest.New(t, opts)\n\t\tctx := context.Background()\n\t\trequire.False(t, called)\n\t\terr := app.Start(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, app.Stop(ctx))\n\t\trequire.Equal(t, \"supply\", buf.String())\n\t\trequire.True(t, called)\n\t})\n\n\tt.Run(\"with Decorate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A interface {\n\t\t\tWriteString(string) (int, error)\n\t\t}\n\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tctor := fx.Provide(func() A { return buf })\n\n\t\tvar called bool\n\n\t\thook := fx.Annotate(\n\t\t\tfunc(in A) A {\n\t\t\t\tin.WriteString(\"decorated\")\n\t\t\t\treturn in\n\t\t\t},\n\t\t\tfx.OnStart(func(_ context.Context, _ A) error {\n\t\t\t\tcalled = assert.Equal(t, \"decorated\", buf.String())\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tdecorated := fx.Decorate(hook)\n\n\t\topts := fx.Options(\n\t\t\tctor,\n\t\t\tdecorated,\n\t\t\tfx.Invoke(func(A) {}),\n\t\t)\n\n\t\tapp := fxtest.New(t, opts)\n\t\tctx := context.Background()\n\t\trequire.NoError(t, app.Start(ctx))\n\t\trequire.NoError(t, app.Stop(ctx))\n\t\trequire.True(t, called)\n\t\trequire.Equal(t, \"decorated\", buf.String())\n\t})\n\n\tt.Run(\"with Decorate and tags\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A interface {\n\t\t\tWriteString(string) (int, error)\n\t\t}\n\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tctor := fx.Provide(\n\t\t\tfx.Annotate(\n\t\t\t\tfunc() A { return buf },\n\t\t\t\tfx.ResultTags(`name:\"name\"`),\n\t\t\t),\n\t\t)\n\n\t\tvar called bool\n\n\t\ttype hookParam struct {\n\t\t\tfx.In\n\t\t\tA A `name:\"name\"`\n\t\t}\n\n\t\thook := fx.Annotate(\n\t\t\tfunc(in A) A {\n\t\t\t\tin.WriteString(\"decorated\")\n\t\t\t\treturn in\n\t\t\t},\n\t\t\tfx.ParamTags(`name:\"name\"`),\n\t\t\tfx.ResultTags(`name:\"name\"`),\n\t\t\tfx.OnStart(func(_ context.Context, _ hookParam) error {\n\t\t\t\tcalled = assert.Equal(t, \"decorated\", buf.String())\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tdecorated := fx.Decorate(hook)\n\n\t\topts := fx.Options(\n\t\t\tctor,\n\t\t\tdecorated,\n\t\t\tfx.Invoke(fx.Annotate(func(A) {}, fx.ParamTags(`name:\"name\"`))),\n\t\t)\n\n\t\tapp := fxtest.New(t, opts)\n\t\tctx := context.Background()\n\t\trequire.NoError(t, app.Start(ctx))\n\t\trequire.NoError(t, app.Stop(ctx))\n\t\trequire.True(t, called)\n\t\trequire.Equal(t, \"decorated\", buf.String())\n\t})\n\n\tt.Run(\"with Supply and Decorate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A interface{}\n\n\t\tch := make(chan string, 3)\n\n\t\thook := fx.Annotate(\n\t\t\tfunc(s fmt.Stringer) A { return nil },\n\t\t\tfx.OnStart(func(_ context.Context, s fmt.Stringer) error {\n\t\t\t\tch <- \"constructor\"\n\t\t\t\trequire.Equal(t, \"supply\", s.String())\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tctor := fx.Provide(hook)\n\n\t\thook = fx.Annotate(\n\t\t\t&asStringer{\"supply\"},\n\t\t\tfx.OnStart(func(_ context.Context) error {\n\t\t\t\tch <- \"supply\"\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t\tfx.As(new(fmt.Stringer)),\n\t\t)\n\n\t\tsupply := fx.Supply(hook)\n\n\t\thook = fx.Annotate(\n\t\t\tfunc(in A) A { return in },\n\t\t\tfx.OnStart(func(_ context.Context) error {\n\t\t\t\tch <- \"decorated\"\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\n\t\tdecorated := fx.Decorate(hook)\n\n\t\topts := fx.Options(\n\t\t\tctor,\n\t\t\tsupply,\n\t\t\tdecorated,\n\t\t\tfx.Invoke(func(A) {}),\n\t\t)\n\n\t\tapp := fxtest.New(t, opts)\n\t\tctx := context.Background()\n\t\terr := app.Start(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, app.Stop(ctx))\n\t\tclose(ch)\n\n\t\trequire.Equal(t, \"supply\", <-ch)\n\t\trequire.Equal(t, \"constructor\", <-ch)\n\t\trequire.Equal(t, \"decorated\", <-ch)\n\t})\n\n\tt.Run(\"Annotated params work with lifecycle hook annotations\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype paramStruct struct {\n\t\t\tfx.In\n\t\t\tA *a `name:\"a\" optional:\"true\"`\n\t\t\tB *b `name:\"b\"`\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(newB, fx.ParamTags(`optional:\"true\"`)),\n\t\t\t\tfx.Annotate(func(a *a, b *b) interface{} { return nil },\n\t\t\t\t\tfx.ParamTags(`name:\"a\" optional:\"true\"`, `name:\"b\"`),\n\t\t\t\t\tfx.ResultTags(`name:\"nil\"`),\n\t\t\t\t\tfx.OnStart(func(_ paramStruct) error {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}),\n\t\t\t\t\tfx.OnStop(func(_ paramStruct) error {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"provide with annotated results and lifecycle hook appended\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype firstAHookParam struct {\n\t\t\tfx.In\n\t\t\tCtx context.Context\n\t\t\tA   *a `name:\"firstA\"`\n\t\t}\n\t\ttype secondAHookParam struct {\n\t\t\tfx.In\n\t\t\tA   *a `name:\"secondA\"`\n\t\t\tCtx context.Context\n\t\t}\n\t\ttype thirdAHookParam struct {\n\t\t\tfx.In\n\t\t\tCtx context.Context\n\t\t\tA   *a `name:\"thirdA\"`\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"firstA\"`),\n\t\t\t\t\tfx.OnStart(func(param firstAHookParam) error {\n\t\t\t\t\t\trequire.NotNil(t, param.Ctx, \"context should be given\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"secondA\"`),\n\t\t\t\t\tfx.OnStart(func(param secondAHookParam) error {\n\t\t\t\t\t\trequire.NotNil(t, param.Ctx, \"context not correctly injected\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})),\n\t\t\t\tfx.Annotate(func() *a {\n\t\t\t\t\treturn &a{}\n\t\t\t\t}, fx.ResultTags(`name:\"thirdA\"`),\n\t\t\t\t\tfx.OnStart(func(param thirdAHookParam) error {\n\t\t\t\t\t\trequire.NotNil(t, param.Ctx, \"context not correctly injected\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})),\n\t\t\t\tfx.Annotate(func(a1 *a, a2 *a, a3 *a) *b {\n\t\t\t\t\treturn &b{a1}\n\t\t\t\t}, fx.ParamTags(\n\t\t\t\t\t`name:\"firstA\"`,\n\t\t\t\t\t`name:\"secondA\"`,\n\t\t\t\t\t`name:\"thirdA\"`,\n\t\t\t\t)),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\n\t\trequire.NoError(t, app.Err())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide with optional params and lifecycle hook\", func(t *testing.T) {\n\t\ttype taggedHookParam struct {\n\t\t\tfx.In\n\t\t\tCtx context.Context\n\t\t\tA   *a `optional:\"true\"`\n\t\t}\n\t\tt.Parallel()\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tnewB,\n\t\t\t\t\tfx.ParamTags(`optional:\"true\"`),\n\t\t\t\t\tfx.OnStart(func(tp taggedHookParam, B *b) {\n\t\t\t\t\t\tfmt.Println(tp.A)\n\t\t\t\t\t\trequire.NotNil(t, tp.Ctx, \"context not correctly injected\")\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(newC),\n\t\t)\n\n\t\trequire.NoError(t, app.Err())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n}\n\nfunc TestHookAnnotationFailures(t *testing.T) {\n\tt.Parallel()\n\tvalidateApp := func(t *testing.T, opts ...fx.Option) error {\n\t\treturn fx.ValidateApp(\n\t\t\tappend(opts, fx.Logger(fxtest.NewTestPrinter(t)))...,\n\t\t)\n\t}\n\n\ttype (\n\t\tA interface{}\n\t\tB interface{}\n\t)\n\n\ttable := []struct {\n\t\tname        string\n\t\tannotation  interface{}\n\t\textraOpts   fx.Option\n\t\tuseNew      bool\n\t\terrContains string\n\t}{\n\t\t{\n\t\t\tname:        \"with unprovided dependency\",\n\t\t\terrContains: \"error invoking hook installer\",\n\t\t\tuseNew:      true,\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(func(context.Context, B) error {\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"with hook that errors\",\n\t\t\terrContains: \"hook failed\",\n\t\t\tuseNew:      true,\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() (A, error) { return nil, nil },\n\t\t\t\tfx.OnStart(func(context.Context) error {\n\t\t\t\t\treturn errors.New(\"hook failed\")\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"with multiple hooks of the same type\",\n\t\t\terrContains: `cannot apply more than one \"OnStart\" hook annotation`,\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(func(context.Context) error { return nil }),\n\t\t\t\tfx.OnStart(func(context.Context) error { return nil }),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"with constructor that errors\",\n\t\t\terrContains: \"hooks should not be installed\",\n\t\t\tuseNew:      true,\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() (A, error) {\n\t\t\t\t\treturn nil, errors.New(\"hooks should not be installed\")\n\t\t\t\t},\n\t\t\t\tfx.OnStart(func(context.Context) error {\n\t\t\t\t\trequire.FailNow(t, \"hook should not be called\")\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"without a function target\",\n\t\t\terrContains: \"must provide function\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(&struct{}{}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid return: non-error return\",\n\t\t\terrContains: \"optional hook return may only be an error\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(func(context.Context) any {\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid return: too many returns\",\n\t\t\terrContains: \"optional hook return may only be an error\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(func(context.Context) (any, any) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"with variactic hook\",\n\t\t\terrContains: \"must not accept variadic\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStart(func(context.Context, ...A) error {\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"with nil hook target\",\n\t\t\terrContains: \"cannot use nil function\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc() A { return nil },\n\t\t\t\tfx.OnStop(nil),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:        \"cannot pull in any extra dependency other than params or results of the annotated function\",\n\t\t\terrContains: \"error invoking hook installer\",\n\t\t\tuseNew:      true,\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc(s string) A { return nil },\n\t\t\t\tfx.OnStart(func(b B) error { return nil }),\n\t\t\t),\n\t\t\textraOpts: fx.Options(\n\t\t\t\tfx.Provide(func() string { return \"test\" }),\n\t\t\t\tfx.Provide(func() B { return nil }),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, tt := range table {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\topts := fx.Options(\n\t\t\t\tfx.Provide(tt.annotation),\n\t\t\t\tfx.Invoke(func(A) {}),\n\t\t\t)\n\n\t\t\tif tt.extraOpts != nil {\n\t\t\t\topts = fx.Options(opts, tt.extraOpts)\n\t\t\t}\n\n\t\t\tif !tt.useNew {\n\t\t\t\terr := validateApp(t, opts)\n\t\t\t\trequire.Error(t, err)\n\t\t\t\trequire.Contains(t, err.Error(), tt.errContains)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tapp := NewForTest(t, opts)\n\t\t\terr := app.Start(context.Background())\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), tt.errContains)\n\t\t})\n\t}\n}\n\nfunc TestHookAnnotationFunctionFlexibility(t *testing.T) {\n\ttype A interface{}\n\n\ttable := []struct {\n\t\tname       string\n\t\tannotation interface{}\n\t}{\n\t\t{\n\t\t\tname: \"without error return\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc(called *atomic.Bool) A { return nil },\n\t\t\t\tfx.OnStart(func(_ context.Context, called *atomic.Bool) {\n\t\t\t\t\tcalled.Store(true)\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"without context param\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc(called *atomic.Bool) A { return nil },\n\t\t\t\tfx.OnStart(func(called *atomic.Bool) error {\n\t\t\t\t\tcalled.Store(true)\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"without context param or error return\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc(called *atomic.Bool) A { return nil },\n\t\t\t\tfx.OnStart(func(called *atomic.Bool) {\n\t\t\t\t\tcalled.Store(true)\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"with context param and error return\",\n\t\t\tannotation: fx.Annotate(\n\t\t\t\tfunc(called *atomic.Bool) A { return nil },\n\t\t\t\tfx.OnStart(func(_ context.Context, called *atomic.Bool) error {\n\t\t\t\t\tcalled.Store(true)\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, tt := range table {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar (\n\t\t\t\tcalled atomic.Bool\n\t\t\t\topts   = fx.Options(\n\t\t\t\t\tfx.Provide(tt.annotation),\n\t\t\t\t\tfx.Supply(&called),\n\t\t\t\t\tfx.Invoke(func(A) {}),\n\t\t\t\t)\n\t\t\t)\n\n\t\t\tfxtest.New(t, opts).RequireStart().RequireStop()\n\t\t\trequire.True(t, called.Load())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 25.31640625,
          "content": "// Copyright (c) 2020-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/internal/fxclock\"\n\t\"go.uber.org/fx/internal/fxlog\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n\t\"go.uber.org/fx/internal/lifecycle\"\n\t\"go.uber.org/multierr\"\n)\n\n// DefaultTimeout is the default timeout for starting or stopping an\n// application. It can be configured with the [StartTimeout] and [StopTimeout]\n// options.\nconst DefaultTimeout = 15 * time.Second\n\n// An Option specifies the behavior of the application.\n// This is the primary means by which you interface with Fx.\n//\n// Zero or more options are specified at startup with [New].\n// Options cannot be changed once an application has been initialized.\n// Options may be grouped into a single option using the [Options] function.\n// A group of options providing a logical unit of functionality\n// may use [Module] to name that functionality\n// and scope certain operations to within that module.\ntype Option interface {\n\tfmt.Stringer\n\n\tapply(*module)\n}\n\n// Error registers any number of errors with the application to short-circuit\n// startup. If more than one error is given, the errors are combined into a\n// single error.\n//\n// Similar to invocations, errors are applied in order. All Provide and Invoke\n// options registered before or after an Error option will not be applied.\nfunc Error(errs ...error) Option {\n\treturn errorOption(errs)\n}\n\ntype errorOption []error\n\nfunc (errs errorOption) apply(mod *module) {\n\tmod.app.err = multierr.Append(mod.app.err, multierr.Combine(errs...))\n}\n\nfunc (errs errorOption) String() string {\n\treturn fmt.Sprintf(\"fx.Error(%v)\", multierr.Combine(errs...))\n}\n\n// Options bundles a group of options together into a single option.\n//\n// Use Options to group together options that don't belong in a [Module].\n//\n//\tvar loggingAndMetrics = fx.Options(\n//\t\tlogging.Module,\n//\t\tmetrics.Module,\n//\t\tfx.Invoke(func(logger *log.Logger) {\n//\t\t\tapp.globalLogger = logger\n//\t\t}),\n//\t)\nfunc Options(opts ...Option) Option {\n\treturn optionGroup(opts)\n}\n\ntype optionGroup []Option\n\nfunc (og optionGroup) apply(mod *module) {\n\tfor _, opt := range og {\n\t\topt.apply(mod)\n\t}\n}\n\nfunc (og optionGroup) String() string {\n\titems := make([]string, len(og))\n\tfor i, opt := range og {\n\t\titems[i] = fmt.Sprint(opt)\n\t}\n\treturn fmt.Sprintf(\"fx.Options(%s)\", strings.Join(items, \", \"))\n}\n\n// StartTimeout changes the application's start timeout.\n// This controls the total time that all [OnStart] hooks have to complete.\n// If the timeout is exceeded, the application will fail to start.\n//\n// Defaults to [DefaultTimeout].\nfunc StartTimeout(v time.Duration) Option {\n\treturn startTimeoutOption(v)\n}\n\ntype startTimeoutOption time.Duration\n\nfunc (t startTimeoutOption) apply(m *module) {\n\tif m.parent != nil {\n\t\tm.app.err = fmt.Errorf(\"fx.StartTimeout Option should be passed to top-level App, \" +\n\t\t\t\"not to fx.Module\")\n\t} else {\n\t\tm.app.startTimeout = time.Duration(t)\n\t}\n}\n\nfunc (t startTimeoutOption) String() string {\n\treturn fmt.Sprintf(\"fx.StartTimeout(%v)\", time.Duration(t))\n}\n\n// StopTimeout changes the application's stop timeout.\n// This controls the total time that all [OnStop] hooks have to complete.\n// If the timeout is exceeded, the application will exit early.\n//\n// Defaults to [DefaultTimeout].\nfunc StopTimeout(v time.Duration) Option {\n\treturn stopTimeoutOption(v)\n}\n\ntype stopTimeoutOption time.Duration\n\nfunc (t stopTimeoutOption) apply(m *module) {\n\tif m.parent != nil {\n\t\tm.app.err = fmt.Errorf(\"fx.StopTimeout Option should be passed to top-level App, \" +\n\t\t\t\"not to fx.Module\")\n\t} else {\n\t\tm.app.stopTimeout = time.Duration(t)\n\t}\n}\n\nfunc (t stopTimeoutOption) String() string {\n\treturn fmt.Sprintf(\"fx.StopTimeout(%v)\", time.Duration(t))\n}\n\n// RecoverFromPanics causes panics that occur in functions given to [Provide],\n// [Decorate], and [Invoke] to be recovered from.\n// This error can be retrieved as any other error, by using (*App).Err().\nfunc RecoverFromPanics() Option {\n\treturn recoverFromPanicsOption{}\n}\n\ntype recoverFromPanicsOption struct{}\n\nfunc (o recoverFromPanicsOption) apply(m *module) {\n\tif m.parent != nil {\n\t\tm.app.err = fmt.Errorf(\"fx.RecoverFromPanics Option should be passed to top-level \" +\n\t\t\t\"App, not to fx.Module\")\n\t} else {\n\t\tm.app.recoverFromPanics = true\n\t}\n}\n\nfunc (o recoverFromPanicsOption) String() string {\n\treturn \"fx.RecoverFromPanics()\"\n}\n\n// WithLogger specifies the [fxevent.Logger] used by Fx to log its own events\n// (e.g. a constructor was provided, a function was invoked, etc.).\n//\n// The argument to this is a constructor with one of the following return\n// types:\n//\n//\tfxevent.Logger\n//\t(fxevent.Logger, error)\n//\n// The constructor may depend on any other types provided to the application.\n// For example,\n//\n//\tWithLogger(func(logger *zap.Logger) fxevent.Logger {\n//\t  return &fxevent.ZapLogger{Logger: logger}\n//\t})\n//\n// If specified, Fx will construct the logger and log all its events to the\n// specified logger.\n//\n// If Fx fails to build the logger, or no logger is specified, it will fall back to\n// [fxevent.ConsoleLogger] configured to write to stderr.\nfunc WithLogger(constructor interface{}) Option {\n\treturn withLoggerOption{\n\t\tconstructor: constructor,\n\t\tStack:       fxreflect.CallerStack(1, 0),\n\t}\n}\n\ntype withLoggerOption struct {\n\tconstructor interface{}\n\tStack       fxreflect.Stack\n}\n\nfunc (l withLoggerOption) apply(m *module) {\n\tm.logConstructor = &provide{\n\t\tTarget: l.constructor,\n\t\tStack:  l.Stack,\n\t}\n}\n\nfunc (l withLoggerOption) String() string {\n\treturn fmt.Sprintf(\"fx.WithLogger(%s)\", fxreflect.FuncName(l.constructor))\n}\n\n// Printer is the interface required by Fx's logging backend. It's implemented\n// by most loggers, including the one bundled with the standard library.\n//\n// Note, this will be deprecated in a future release.\n// Prefer to use [fxevent.Logger] instead.\ntype Printer interface {\n\tPrintf(string, ...interface{})\n}\n\n// Logger redirects the application's log output to the provided printer.\n//\n// Prefer to use [WithLogger] instead.\nfunc Logger(p Printer) Option {\n\treturn loggerOption{p}\n}\n\ntype loggerOption struct{ p Printer }\n\nfunc (l loggerOption) apply(m *module) {\n\tif m.parent != nil {\n\t\tm.app.err = fmt.Errorf(\"fx.Logger Option should be passed to top-level App, \" +\n\t\t\t\"not to fx.Module\")\n\t} else {\n\t\tnp := writerFromPrinter(l.p)\n\t\tm.log = fxlog.DefaultLogger(np) // assuming np is thread-safe.\n\t}\n}\n\nfunc (l loggerOption) String() string {\n\treturn fmt.Sprintf(\"fx.Logger(%v)\", l.p)\n}\n\n// NopLogger disables the application's log output.\n//\n// Note that this makes some failures difficult to debug,\n// since no errors are printed to console.\n// Prefer to log to an in-memory buffer instead.\nvar NopLogger = WithLogger(func() fxevent.Logger { return fxevent.NopLogger })\n\n// An App is a modular application built around dependency injection. Most\n// users will only need to use the New constructor and the all-in-one Run\n// convenience method. In more unusual cases, users may need to use the Err,\n// Start, Done, and Stop methods by hand instead of relying on Run.\n//\n// [New] creates and initializes an App. All applications begin with a\n// constructor for the Lifecycle type already registered.\n//\n// In addition to that built-in functionality, users typically pass a handful\n// of [Provide] options and one or more [Invoke] options. The Provide options\n// teach the application how to instantiate a variety of types, and the Invoke\n// options describe how to initialize the application.\n//\n// When created, the application immediately executes all the functions passed\n// via Invoke options. To supply these functions with the parameters they\n// need, the application looks for constructors that return the appropriate\n// types; if constructors for any required types are missing or any\n// invocations return an error, the application will fail to start (and Err\n// will return a descriptive error message).\n//\n// Once all the invocations (and any required constructors) have been called,\n// New returns and the application is ready to be started using Run or Start.\n// On startup, it executes any OnStart hooks registered with its Lifecycle.\n// OnStart hooks are executed one at a time, in order, and must all complete\n// within a configurable deadline (by default, 15 seconds). For details on the\n// order in which OnStart hooks are executed, see the documentation for the\n// Start method.\n//\n// At this point, the application has successfully started up. If started via\n// Run, it will continue operating until it receives a shutdown signal from\n// Done (see the [App.Done] documentation for details); if started explicitly via\n// Start, it will operate until the user calls Stop. On shutdown, OnStop hooks\n// execute one at a time, in reverse order, and must all complete within a\n// configurable deadline (again, 15 seconds by default).\ntype App struct {\n\terr       error\n\tclock     fxclock.Clock\n\tlifecycle *lifecycleWrapper\n\n\tcontainer *dig.Container\n\troot      *module\n\n\t// Timeouts used\n\tstartTimeout time.Duration\n\tstopTimeout  time.Duration\n\t// Decides how we react to errors when building the graph.\n\terrorHooks []ErrorHandler\n\tvalidate   bool\n\t// Whether to recover from panics in Dig container\n\trecoverFromPanics bool\n\n\t// Used to signal shutdowns.\n\treceivers signalReceivers\n\n\tosExit func(code int) // os.Exit override; used for testing only\n}\n\n// provide is a single constructor provided to Fx.\ntype provide struct {\n\t// Constructor provided to Fx. This may be an fx.Annotated.\n\tTarget interface{}\n\n\t// Stack trace of where this provide was made.\n\tStack fxreflect.Stack\n\n\t// IsSupply is true when the Target constructor was emitted by fx.Supply.\n\tIsSupply   bool\n\tSupplyType reflect.Type // set only if IsSupply\n\n\t// Set if the type should be provided at private scope.\n\tPrivate bool\n}\n\n// invoke is a single invocation request to Fx.\ntype invoke struct {\n\t// Function to invoke.\n\tTarget interface{}\n\n\t// Stack trace of where this invoke was made.\n\tStack fxreflect.Stack\n}\n\n// ErrorHandler handles Fx application startup errors.\n// Register these with [ErrorHook].\n// If specified, and the application fails to start up,\n// the failure will still cause a crash,\n// but you'll have a chance to log the error or take some other action.\ntype ErrorHandler interface {\n\tHandleError(error)\n}\n\n// ErrorHook registers error handlers that implement error handling functions.\n// They are executed on invoke failures. Passing multiple ErrorHandlers appends\n// the new handlers to the application's existing list.\nfunc ErrorHook(funcs ...ErrorHandler) Option {\n\treturn errorHookOption(funcs)\n}\n\ntype errorHookOption []ErrorHandler\n\nfunc (eho errorHookOption) apply(m *module) {\n\tm.app.errorHooks = append(m.app.errorHooks, eho...)\n}\n\nfunc (eho errorHookOption) String() string {\n\titems := make([]string, len(eho))\n\tfor i, eh := range eho {\n\t\titems[i] = fmt.Sprint(eh)\n\t}\n\treturn fmt.Sprintf(\"fx.ErrorHook(%v)\", strings.Join(items, \", \"))\n}\n\ntype errorHandlerList []ErrorHandler\n\nfunc (ehl errorHandlerList) HandleError(err error) {\n\tfor _, eh := range ehl {\n\t\teh.HandleError(err)\n\t}\n}\n\n// validate sets *App into validation mode without running invoked functions.\nfunc validate(validate bool) Option {\n\treturn &validateOption{\n\t\tvalidate: validate,\n\t}\n}\n\ntype validateOption struct {\n\tvalidate bool\n}\n\nfunc (o validateOption) apply(m *module) {\n\tif m.parent != nil {\n\t\tm.app.err = fmt.Errorf(\"fx.validate Option should be passed to top-level App, \" +\n\t\t\t\"not to fx.Module\")\n\t} else {\n\t\tm.app.validate = o.validate\n\t}\n}\n\nfunc (o validateOption) String() string {\n\treturn fmt.Sprintf(\"fx.validate(%v)\", o.validate)\n}\n\n// ValidateApp validates that supplied graph would run and is not missing any dependencies. This\n// method does not invoke actual input functions.\nfunc ValidateApp(opts ...Option) error {\n\topts = append(opts, validate(true))\n\tapp := New(opts...)\n\n\treturn app.Err()\n}\n\n// New creates and initializes an App, immediately executing any functions\n// registered via [Invoke] options. See the documentation of the App struct for\n// details on the application's initialization, startup, and shutdown logic.\nfunc New(opts ...Option) *App {\n\tlogger := fxlog.DefaultLogger(os.Stderr)\n\n\tapp := &App{\n\t\tclock:        fxclock.System,\n\t\tstartTimeout: DefaultTimeout,\n\t\tstopTimeout:  DefaultTimeout,\n\t\treceivers:    newSignalReceivers(),\n\t}\n\tapp.root = &module{\n\t\tapp: app,\n\t\t// We start with a logger that writes to stderr. One of the\n\t\t// following three things can change this:\n\t\t//\n\t\t// - fx.Logger was provided to change the output stream\n\t\t// - fx.WithLogger was provided to change the logger\n\t\t//   implementation\n\t\t// - Both, fx.Logger and fx.WithLogger were provided\n\t\t//\n\t\t// The first two cases are straightforward: we use what the\n\t\t// user gave us. For the last case, however, we need to fall\n\t\t// back to what was provided to fx.Logger if fx.WithLogger\n\t\t// fails.\n\t\tlog:   logger,\n\t\ttrace: []string{fxreflect.CallerStack(1, 2)[0].String()},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.apply(app.root)\n\t}\n\n\t// There are a few levels of wrapping on the lifecycle here. To quickly\n\t// cover them:\n\t//\n\t// - lifecycleWrapper ensures that we don't unintentionally expose the\n\t//   Start and Stop methods of the internal lifecycle.Lifecycle type\n\t// - lifecycleWrapper also adapts the internal lifecycle.Hook type into\n\t//   the public fx.Hook type.\n\t// - appLogger ensures that the lifecycle always logs events to the\n\t//   \"current\" logger associated with the fx.App.\n\tapp.lifecycle = &lifecycleWrapper{\n\t\tlifecycle.New(appLogger{app}, app.clock),\n\t}\n\n\tcontainerOptions := []dig.Option{\n\t\tdig.DeferAcyclicVerification(),\n\t\tdig.DryRun(app.validate),\n\t}\n\n\tif app.recoverFromPanics {\n\t\tcontainerOptions = append(containerOptions, dig.RecoverFromPanics())\n\t}\n\n\tapp.container = dig.New(containerOptions...)\n\tapp.root.build(app, app.container)\n\n\t// Provide Fx types first to increase the chance a custom logger\n\t// can be successfully built in the face of unrelated DI failure.\n\t// E.g., for a custom logger that relies on the Lifecycle type.\n\tframes := fxreflect.CallerStack(0, 0) // include New in the stack for default Provides\n\tapp.root.provide(provide{\n\t\tTarget: func() Lifecycle { return app.lifecycle },\n\t\tStack:  frames,\n\t})\n\tapp.root.provide(provide{Target: app.shutdowner, Stack: frames})\n\tapp.root.provide(provide{Target: app.dotGraph, Stack: frames})\n\tapp.root.provideAll()\n\n\t// Run decorators before executing any Invokes\n\t// (including the ones inside installAllEventLoggers).\n\tapp.err = multierr.Append(app.err, app.root.decorateAll())\n\n\t// If you are thinking about returning here after provides: do not (just yet)!\n\t// If a custom logger was being used, we're still buffering messages.\n\t// We'll want to flush them to the logger.\n\n\t// custom app logger will be initialized by the root module.\n\tapp.root.installAllEventLoggers()\n\n\t// This error might have come from the provide loop above. We've\n\t// already flushed to the custom logger, so we can return.\n\tif app.err != nil {\n\t\treturn app\n\t}\n\n\tif err := app.root.invokeAll(); err != nil {\n\t\tapp.err = err\n\n\t\tif dig.CanVisualizeError(err) {\n\t\t\tvar b bytes.Buffer\n\t\t\tdig.Visualize(app.container, &b, dig.VisualizeError(err))\n\t\t\terr = errorWithGraph{\n\t\t\t\tgraph: b.String(),\n\t\t\t\terr:   err,\n\t\t\t}\n\t\t}\n\t\terrorHandlerList(app.errorHooks).HandleError(err)\n\t}\n\n\treturn app\n}\n\nfunc (app *App) log() fxevent.Logger {\n\treturn app.root.log\n}\n\n// DotGraph contains a DOT language visualization of the dependency graph in\n// an Fx application. It is provided in the container by default at\n// initialization. On failure to build the dependency graph, it is attached\n// to the error and if possible, colorized to highlight the root cause of the\n// failure.\n//\n// Note that DotGraph does not yet recognize [Decorate] and [Replace].\ntype DotGraph string\n\ntype errWithGraph interface {\n\tGraph() DotGraph\n}\n\ntype errorWithGraph struct {\n\tgraph string\n\terr   error\n}\n\nfunc (err errorWithGraph) Graph() DotGraph {\n\treturn DotGraph(err.graph)\n}\n\nfunc (err errorWithGraph) Error() string {\n\treturn err.err.Error()\n}\n\n// VisualizeError returns the visualization of the error if available.\n//\n// Note that VisualizeError does not yet recognize [Decorate] and [Replace].\nfunc VisualizeError(err error) (string, error) {\n\tvar erg errWithGraph\n\tif errors.As(err, &erg) {\n\t\tif g := erg.Graph(); g != \"\" {\n\t\t\treturn string(g), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"unable to visualize error\")\n}\n\n// Exits the application with the given exit code.\nfunc (app *App) exit(code int) {\n\tosExit := os.Exit\n\tif app.osExit != nil {\n\t\tosExit = app.osExit\n\t}\n\tosExit(code)\n}\n\n// Run starts the application, blocks on the signals channel, and then\n// gracefully shuts the application down. It uses [DefaultTimeout] to set a\n// deadline for application startup and shutdown, unless the user has\n// configured different timeouts with the [StartTimeout] or [StopTimeout] options.\n// It's designed to make typical applications simple to run.\n// The minimal Fx application looks like this:\n//\n//\tfx.New().Run()\n//\n// All of Run's functionality is implemented in terms of the exported\n// Start, Done, and Stop methods. Applications with more specialized needs\n// can use those methods directly instead of relying on Run.\n//\n// After the application has started,\n// it can be shut down by sending a signal or calling [Shutdowner.Shutdown].\n// On successful shutdown, whether initiated by a signal or by the user,\n// Run will return to the caller, allowing it to exit cleanly.\n// Run will exit with a non-zero status code\n// if startup or shutdown operations fail,\n// or if the [Shutdowner] supplied a non-zero exit code.\nfunc (app *App) Run() {\n\t// Historically, we do not os.Exit(0) even though most applications\n\t// cede control to Fx with they call app.Run. To avoid a breaking\n\t// change, never os.Exit for success.\n\tif code := app.run(app.Wait); code != 0 {\n\t\tapp.exit(code)\n\t}\n}\n\nfunc (app *App) run(done func() <-chan ShutdownSignal) (exitCode int) {\n\tstartCtx, cancel := app.clock.WithTimeout(context.Background(), app.StartTimeout())\n\tdefer cancel()\n\n\tif err := app.Start(startCtx); err != nil {\n\t\treturn 1\n\t}\n\n\tsig := <-done()\n\tapp.log().LogEvent(&fxevent.Stopping{Signal: sig.Signal})\n\texitCode = sig.ExitCode\n\n\tstopCtx, cancel := app.clock.WithTimeout(context.Background(), app.StopTimeout())\n\tdefer cancel()\n\n\tif err := app.Stop(stopCtx); err != nil {\n\t\treturn 1\n\t}\n\n\treturn exitCode\n}\n\n// Err returns any error encountered during New's initialization. See the\n// documentation of the New method for details, but typical errors include\n// missing constructors, circular dependencies, constructor errors, and\n// invocation errors.\n//\n// Most users won't need to use this method, since both Run and Start\n// short-circuit if initialization failed.\nfunc (app *App) Err() error {\n\treturn app.err\n}\n\nvar (\n\t_onStartHook = \"OnStart\"\n\t_onStopHook  = \"OnStop\"\n)\n\n// Start kicks off all long-running goroutines, like network servers or\n// message queue consumers. It does this by interacting with the application's\n// Lifecycle.\n//\n// By taking a dependency on the Lifecycle type, some of the user-supplied\n// functions called during initialization may have registered start and stop\n// hooks. Because initialization calls constructors serially and in dependency\n// order, hooks are naturally registered in serial and dependency order too.\n//\n// Start executes all OnStart hooks registered with the application's\n// Lifecycle, one at a time and in order. This ensures that each constructor's\n// start hooks aren't executed until all its dependencies' start hooks\n// complete. If any of the start hooks return an error, Start short-circuits,\n// calls Stop, and returns the inciting error.\n//\n// Note that Start short-circuits immediately if the New constructor\n// encountered any errors in application initialization.\nfunc (app *App) Start(ctx context.Context) (err error) {\n\tdefer func() {\n\t\tapp.log().LogEvent(&fxevent.Started{Err: err})\n\t}()\n\n\tif app.err != nil {\n\t\t// Some provides failed, short-circuit immediately.\n\t\treturn app.err\n\t}\n\n\treturn withTimeout(ctx, &withTimeoutParams{\n\t\thook:      _onStartHook,\n\t\tcallback:  app.start,\n\t\tlifecycle: app.lifecycle,\n\t\tlog:       app.log(),\n\t})\n}\n\n// withRollback will execute an anonymous function with a given context.\n// if the anon func returns an error, rollback methods will be called and related events emitted\nfunc (app *App) withRollback(\n\tctx context.Context,\n\tf func(context.Context) error,\n) error {\n\tif err := f(ctx); err != nil {\n\t\tapp.log().LogEvent(&fxevent.RollingBack{StartErr: err})\n\n\t\tstopErr := app.lifecycle.Stop(ctx)\n\t\tapp.log().LogEvent(&fxevent.RolledBack{Err: stopErr})\n\n\t\tif stopErr != nil {\n\t\t\treturn multierr.Append(err, stopErr)\n\t\t}\n\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (app *App) start(ctx context.Context) error {\n\treturn app.withRollback(ctx, func(ctx context.Context) error {\n\t\tif err := app.lifecycle.Start(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Stop gracefully stops the application. It executes any registered OnStop\n// hooks in reverse order, so that each constructor's stop hooks are called\n// before its dependencies' stop hooks.\n//\n// If the application didn't start cleanly, only hooks whose OnStart phase was\n// called are executed. However, all those hooks are executed, even if some\n// fail.\nfunc (app *App) Stop(ctx context.Context) (err error) {\n\tdefer func() {\n\t\tapp.log().LogEvent(&fxevent.Stopped{Err: err})\n\t}()\n\n\tcb := func(ctx context.Context) error {\n\t\tdefer app.receivers.Stop(ctx)\n\t\treturn app.lifecycle.Stop(ctx)\n\t}\n\n\treturn withTimeout(ctx, &withTimeoutParams{\n\t\thook:      _onStopHook,\n\t\tcallback:  cb,\n\t\tlifecycle: app.lifecycle,\n\t\tlog:       app.log(),\n\t})\n}\n\n// Done returns a channel of signals to block on after starting the\n// application. Applications listen for the SIGINT and SIGTERM signals; during\n// development, users can send the application SIGTERM by pressing Ctrl-C in\n// the same terminal as the running process.\n//\n// Alternatively, a signal can be broadcast to all done channels manually by\n// using the Shutdown functionality (see the [Shutdowner] documentation for details).\nfunc (app *App) Done() <-chan os.Signal {\n\tapp.receivers.Start() // No-op if running\n\treturn app.receivers.Done()\n}\n\n// Wait returns a channel of [ShutdownSignal] to block on after starting the\n// application and function, similar to [App.Done], but with a minor difference:\n// if the app was shut down via [Shutdowner.Shutdown],\n// the exit code (if provied via [ExitCode]) will be available\n// in the [ShutdownSignal] struct.\n// Otherwise, the signal that was received will be set.\nfunc (app *App) Wait() <-chan ShutdownSignal {\n\tapp.receivers.Start() // No-op if running\n\treturn app.receivers.Wait()\n}\n\n// StartTimeout returns the configured startup timeout.\n// This defaults to [DefaultTimeout], and can be changed with the\n// [StartTimeout] option.\nfunc (app *App) StartTimeout() time.Duration {\n\treturn app.startTimeout\n}\n\n// StopTimeout returns the configured shutdown timeout.\n// This defaults to [DefaultTimeout], and can be changed with the\n// [StopTimeout] option.\nfunc (app *App) StopTimeout() time.Duration {\n\treturn app.stopTimeout\n}\n\nfunc (app *App) dotGraph() (DotGraph, error) {\n\tvar b bytes.Buffer\n\terr := dig.Visualize(app.container, &b)\n\treturn DotGraph(b.String()), err\n}\n\ntype withTimeoutParams struct {\n\tlog       fxevent.Logger\n\thook      string\n\tcallback  func(context.Context) error\n\tlifecycle *lifecycleWrapper\n}\n\n// errHookCallbackExited is returned when a hook callback does not finish executing\nvar errHookCallbackExited = errors.New(\"goroutine exited without returning\")\n\nfunc withTimeout(ctx context.Context, param *withTimeoutParams) error {\n\tc := make(chan error, 1)\n\tgo func() {\n\t\t// If runtime.Goexit() is called from within the callback\n\t\t// then nothing is written to the chan.\n\t\t// However the defer will still be called, so we can write to the chan,\n\t\t// to avoid hanging until the timeout is reached.\n\t\tcallbackExited := false\n\t\tdefer func() {\n\t\t\tif !callbackExited {\n\t\t\t\tc <- errHookCallbackExited\n\t\t\t}\n\t\t}()\n\n\t\tc <- param.callback(ctx)\n\t\tcallbackExited = true\n\t}()\n\n\tvar err error\n\n\tselect {\n\tcase <-ctx.Done():\n\t\terr = ctx.Err()\n\tcase err = <-c:\n\t\t// If the context finished at the same time as the callback\n\t\t// prefer the context error.\n\t\t// This eliminates non-determinism in select-case selection.\n\t\tif ctx.Err() != nil {\n\t\t\terr = ctx.Err()\n\t\t}\n\t}\n\n\treturn err\n}\n\n// appLogger logs events to the given Fx app's \"current\" logger.\n//\n// Use this with lifecycle, for example, to ensure that events always go to the\n// correct logger.\ntype appLogger struct{ app *App }\n\nfunc (l appLogger) LogEvent(ev fxevent.Event) {\n\tl.app.log().LogEvent(ev)\n}\n"
        },
        {
          "name": "app_internal_test.go",
          "type": "blob",
          "size": 4.02734375,
          "content": "// Copyright (c) 2019-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/internal/fxclock\"\n\t\"go.uber.org/fx/internal/fxlog\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\nfunc TestAppRun(t *testing.T) {\n\tt.Parallel()\n\n\tspy := new(fxlog.Spy)\n\tapp := New(\n\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t)\n\tdone := make(chan ShutdownSignal)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tapp.run(func() <-chan ShutdownSignal { return done })\n\t}()\n\n\tdone <- ShutdownSignal{Signal: _sigINT}\n\twg.Wait()\n\n\tassert.Equal(t, []string{\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"LoggerInitialized\",\n\t\t\"Started\",\n\t\t\"Stopping\",\n\t\t\"Stopped\",\n\t}, spy.EventTypes())\n}\n\n// TestValidateString verifies private option. Public options are tested in app_test.go.\nfunc TestValidateString(t *testing.T) {\n\tt.Parallel()\n\n\tstringer, ok := validate(true).(fmt.Stringer)\n\trequire.True(t, ok, \"option must implement stringer\")\n\tassert.Equal(t, \"fx.validate(true)\", stringer.String())\n}\n\n// WithExit is an internal option available only to tests defined in this\n// package. It changes how os.Exit behaves for the application.\nfunc WithExit(f func(int)) Option {\n\treturn withExitOption(f)\n}\n\ntype withExitOption func(int)\n\nfunc (o withExitOption) String() string {\n\treturn fmt.Sprintf(\"WithExit(%v)\", fxreflect.FuncName(o))\n}\n\nfunc (o withExitOption) apply(m *module) {\n\tm.app.osExit = o\n}\n\n// WithClock specifies how Fx accesses time operations.\n//\n// This is an internal option available only to tests defined in this package.\nfunc WithClock(clock fxclock.Clock) Option {\n\treturn withClockOption{clock}\n}\n\ntype withClockOption struct{ clock fxclock.Clock }\n\nfunc (o withClockOption) apply(m *module) {\n\tm.app.clock = o.clock\n}\n\nfunc (o withClockOption) String() string {\n\treturn fmt.Sprintf(\"WithClock(%v)\", o.clock)\n}\n\nfunc TestAnnotationError(t *testing.T) {\n\twantErr := errors.New(\"want error\")\n\terr := &annotationError{\n\t\terr: wantErr,\n\t}\n\trequire.Error(t, err)\n\tassert.ErrorIs(t, err, wantErr)\n\tassert.Contains(t, err.Error(), wantErr.Error())\n}\n\n// TestStartDoesNotRegisterSignals verifies that signal.Notify is not called\n// when a user starts an app. signal.Notify should only be called when the\n// .Wait/.Done are called. Note that app.Run calls .Wait() implicitly.\nfunc TestStartDoesNotRegisterSignals(t *testing.T) {\n\tapp := New()\n\tcalledNotify := false\n\n\t// Mock notify function to spy when this is called.\n\tapp.receivers.notify = func(c chan<- os.Signal, sig ...os.Signal) {\n\t\tcalledNotify = true\n\t}\n\tapp.receivers.stopNotify = func(c chan<- os.Signal) {}\n\n\tapp.Start(context.Background())\n\tdefer app.Stop(context.Background())\n\tassert.False(t, calledNotify, \"notify should not be called when app starts\")\n\n\t_ = app.Wait() // User signals intent have fx listen for signals. This should call notify\n\tassert.True(t, calledNotify, \"notify should be called after Wait\")\n}\n"
        },
        {
          "name": "app_test.go",
          "type": "blob",
          "size": 66.7158203125,
          "content": "// Copyright (c) 2023 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t. \"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/fxtest\"\n\t\"go.uber.org/fx/internal/fxclock\"\n\t\"go.uber.org/fx/internal/fxlog\"\n\t\"go.uber.org/goleak\"\n\t\"go.uber.org/multierr\"\n\t\"go.uber.org/zap\"\n)\n\nfunc NewForTest(tb testing.TB, opts ...Option) *App {\n\ttestOpts := []Option{\n\t\t// Provide both: Logger and WithLogger so that if the test\n\t\t// WithLogger fails, we don't pollute stderr.\n\t\tLogger(fxtest.NewTestPrinter(tb)),\n\t\tfxtest.WithTestLogger(tb),\n\t}\n\topts = append(testOpts, opts...)\n\n\treturn New(opts...)\n}\n\nfunc NewSpied(opts ...Option) (*App, *fxlog.Spy) {\n\tspy := new(fxlog.Spy)\n\topts = append([]Option{\n\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t}, opts...)\n\treturn New(opts...), spy\n}\n\nfunc validateTestApp(tb testing.TB, opts ...Option) error {\n\ttestOpts := []Option{\n\t\t// Provide both: Logger and WithLogger so that if the test\n\t\t// WithLogger fails, we don't pollute stderr.\n\t\tLogger(fxtest.NewTestPrinter(tb)),\n\t\tfxtest.WithTestLogger(tb),\n\t}\n\topts = append(testOpts, opts...)\n\n\treturn ValidateApp(opts...)\n}\n\nfunc TestNewApp(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ProvidesLifecycleAndShutdowner\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar (\n\t\t\tl Lifecycle\n\t\t\ts Shutdowner\n\t\t)\n\t\tfxtest.New(\n\t\t\tt,\n\t\t\tPopulate(&l, &s),\n\t\t)\n\t\tassert.NotNil(t, l)\n\t\tassert.NotNil(t, s)\n\t})\n\n\tt.Run(\"OptionsHappensBeforeProvides\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t// Should be grouping all provides and pushing them into the container\n\t\t// after applying other options. This prevents the app configuration\n\t\t// (e.g., logging) from changing halfway through our provides.\n\n\t\tspy := new(fxlog.Spy)\n\t\tapp := fxtest.New(t, Provide(func() struct{} { return struct{}{} }),\n\t\t\tWithLogger(func() fxevent.Logger { return spy }))\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.Equal(t,\n\t\t\t[]string{\"Provided\", \"Provided\", \"Provided\", \"Provided\", \"LoggerInitialized\", \"Started\"},\n\t\t\tspy.EventTypes())\n\n\t\t// Fx types get provided first to increase chance of\n\t\t// successful custom logger build.\n\t\tassert.Contains(t, spy.Events()[0].(*fxevent.Provided).OutputTypeNames, \"fx.Lifecycle\")\n\t\tassert.Contains(t, spy.Events()[1].(*fxevent.Provided).OutputTypeNames, \"fx.Shutdowner\")\n\t\tassert.Contains(t, spy.Events()[2].(*fxevent.Provided).OutputTypeNames, \"fx.DotGraph\")\n\t\t// Our type should be index 3.\n\t\tassert.Contains(t, spy.Events()[3].(*fxevent.Provided).OutputTypeNames, \"struct {}\")\n\t})\n\n\tt.Run(\"CircularGraphReturnsError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\tapp := NewForTest(t,\n\t\t\tProvide(func(A) B { return B{} }),\n\t\t\tProvide(func(B) A { return A{} }),\n\t\t\tInvoke(func(B) {}),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err, \"fx.New should return an error\")\n\n\t\terrMsg := err.Error()\n\t\tassert.Contains(t, errMsg, \"cycle detected in dependency graph\")\n\t\tassert.Contains(t, errMsg, \"depends on func(fx_test.B) fx_test.A\")\n\t\tassert.Contains(t, errMsg, \"depends on func(fx_test.A) fx_test.B\")\n\t})\n\n\tt.Run(\"ProvidesDotGraph\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\tvar g DotGraph\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() A { return A{} }),\n\t\t\tProvide(func(A) B { return B{} }),\n\t\t\tProvide(func(A, B) C { return C{} }),\n\t\t\tPopulate(&g),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t\tassert.Contains(t, g, `\"fx.DotGraph\" [label=<fx.DotGraph>];`)\n\t})\n\n\tt.Run(\"ProvidesWithAnnotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\ttype B struct {\n\t\t\tIn\n\n\t\t\tFoo  A   `name:\"foo\"`\n\t\t\tBar  A   `name:\"bar\"`\n\t\t\tFoos []A `group:\"foo\"`\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(\n\t\t\t\tAnnotated{\n\t\t\t\t\tTarget: func() A { return A{} },\n\t\t\t\t\tName:   \"foo\",\n\t\t\t\t},\n\t\t\t\tAnnotated{\n\t\t\t\t\tTarget: func() A { return A{} },\n\t\t\t\t\tName:   \"bar\",\n\t\t\t\t},\n\t\t\t\tAnnotated{\n\t\t\t\t\tTarget: func() A { return A{} },\n\t\t\t\t\tGroup:  \"foo\",\n\t\t\t\t},\n\t\t\t),\n\t\t\tInvoke(\n\t\t\t\tfunc(b B) {\n\t\t\t\t\tassert.NotNil(t, b.Foo)\n\t\t\t\t\tassert.NotNil(t, b.Bar)\n\t\t\t\t\tassert.Len(t, b.Foos, 1)\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"ProvidesWithAnnotateFlattened\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(Annotated{\n\t\t\t\tTarget: func() []int { return []int{1} },\n\t\t\t\tGroup:  \"foo,flatten\",\n\t\t\t}),\n\t\t\tInvoke(\n\t\t\t\tfunc(b struct {\n\t\t\t\t\tIn\n\t\t\t\t\tFoos []int `group:\"foo\"`\n\t\t\t\t},\n\t\t\t\t) {\n\t\t\t\t\tassert.Len(t, b.Foos, 1)\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"ProvidesWithEmptyAnnotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\ttype B struct {\n\t\t\tIn\n\n\t\t\tFoo A\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(\n\t\t\t\tAnnotated{\n\t\t\t\t\tTarget: func() A { return A{} },\n\t\t\t\t},\n\t\t\t),\n\t\t\tInvoke(\n\t\t\t\tfunc(b B) {\n\t\t\t\t\tassert.NotNil(t, b.Foo)\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"CannotNameAndGroup\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(\n\t\t\t\tAnnotated{\n\t\t\t\t\tTarget: func() A { return A{} },\n\t\t\t\t\tName:   \"foo\",\n\t\t\t\t\tGroup:  \"bar\",\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\t// fx.Annotated may specify only one of Name or Group: received fx.Annotated{Name: \"foo\", Group: \"bar\", Target: go.uber.org/fx_test.TestAnnotatedWithGroupAndName.func1()} from:\n\t\t// go.uber.org/fx_test.TestAnnotatedWithGroupAndName\n\t\t//         /.../fx/annotated_test.go:164\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\tassert.Contains(t, err.Error(), \"fx.Annotated may specify only one of Name or Group:\")\n\t\tassert.Contains(t, err.Error(), `received fx.Annotated{Name: \"foo\", Group: \"bar\", Target: go.uber.org/fx_test.TestNewApp`)\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestNewApp\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t})\n\n\tt.Run(\"ErrorProvidingAnnotated\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := NewForTest(t, Provide(Annotated{\n\t\t\tTarget: 42, // not a constructor\n\t\t\tName:   \"foo\",\n\t\t}))\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\t// Example:\n\t\t// fx.Provide(fx.Annotated{...}) from:\n\t\t//     go.uber.org/fx_test.TestNewApp.func8\n\t\t//         /.../fx/app_test.go:206\n\t\t//     testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\t//     Failed: must provide constructor function, got 42 (type int)\n\t\tassert.Contains(t, err.Error(), `fx.Provide(fx.Annotated{Name: \"foo\", Target: 42}) from:`)\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestNewApp\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t\tassert.Contains(t, err.Error(), \"Failed: must provide constructor function\")\n\t})\n\n\tt.Run(\"ErrorProvidingAnnotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype t1 struct{}\n\t\tnewT1 := func() t1 { return t1{} }\n\n\t\t// Provide twice.\n\t\tapp := NewForTest(t, Provide(\n\t\t\tAnnotate(newT1, ResultTags(`name:\"foo\"`)),\n\t\t\tAnnotate(newT1, ResultTags(`name:\"foo\"`)),\n\t\t))\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\t// Example:\n\t\t// fx.Provide(fx.Annotate(go.uber.org/fx_test.TestNewApp.func10.1(), fx.ResultTags([\"name:\\\"foo\\\"\"])) from:\n\t\t//     go.uber.org/fx_test.TestNewApp.func10\n\t\t//         /.../fx/app_test.go:305\n\t\t//     testing.tRunner\n\t\t//         /.../src/testing/testing.go:1259\n\t\t//     Failed: cannot provide function \"reflect\".makeFuncStub (/.../reflect/asm_amd64.s:30):\n\t\t//     cannot provide fx_test.t1[name=\"foo\"] from [0].Field0:\n\t\t//     already provided by \"reflect\".makeFuncStub (/.../reflect/asm_amd64.s:30)\n\t\tassert.Contains(t, err.Error(), `fx.Provide(fx.Annotate(`)\n\t\tassert.Contains(t, err.Error(), `fx.ResultTags([\"name:\\\"foo\\\"\"])`)\n\t\tassert.Contains(t, err.Error(), \"already provided\")\n\t})\n\n\tt.Run(\"ErrorProviding\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\terr := NewForTest(t, Provide(42)).Err()\n\t\trequire.Error(t, err)\n\n\t\t// Example:\n\t\t// fx.Provide(..) from:\n\t\t//     go.uber.org/fx_test.TestNewApp.func8\n\t\t//         /.../fx/app_test.go:206\n\t\t//     testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\t//     Failed: must provide constructor function, got 42 (type int)\n\t\tassert.Contains(t, err.Error(), \"fx.Provide(42) from:\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestNewApp\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t\tassert.Contains(t, err.Error(), \"Failed: must provide constructor function\")\n\t})\n\n\tt.Run(\"Decorates\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tspy := new(fxlog.Spy)\n\n\t\ttype A struct{ value int }\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() A { return A{value: 0} }),\n\t\t\tDecorate(func(a A) A { return A{value: a.value + 1} }),\n\t\t\tInvoke(func(a A) { assert.Equal(t, a.value, 1) }),\n\t\t\tWithLogger(func() fxevent.Logger { return spy }))\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\trequire.Equal(t,\n\t\t\t[]string{\"Provided\", \"Provided\", \"Provided\", \"Provided\", \"Decorated\", \"LoggerInitialized\", \"Invoking\", \"Run\", \"Run\", \"Invoked\", \"Started\"},\n\t\t\tspy.EventTypes())\n\t})\n\n\tt.Run(\"DecoratesFromManyModules\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tspy := new(fxlog.Spy)\n\n\t\ttype A struct{ value int }\n\t\tm := Module(\"decorator\",\n\t\t\tDecorate(func(a A) A { return A{value: a.value + 1} }),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tm,\n\t\t\tProvide(func() A { return A{value: 0} }),\n\t\t\tDecorate(func(a A) A { return A{value: a.value + 1} }),\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\trequire.Equal(t,\n\t\t\t[]string{\"Provided\", \"Provided\", \"Provided\", \"Provided\", \"Decorated\", \"Decorated\", \"LoggerInitialized\", \"Started\"},\n\t\t\tspy.EventTypes())\n\t})\n}\n\n// TestPrivate tests Private when used with both fx.Provide and fx.Supply.\nfunc TestPrivate(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tdesc string\n\n\t\t// provide is either a Supply or Provide wrapper around the given int\n\t\t// that allows us to generalize these test cases for both APIs.\n\t\tprovide func(int, bool) Option\n\t}{\n\t\t{\n\t\t\tdesc: \"Provide\",\n\t\t\tprovide: func(i int, private bool) Option {\n\t\t\t\topts := []any{func() int { return i }}\n\t\t\t\tif private {\n\t\t\t\t\topts = append(opts, Private)\n\t\t\t\t}\n\t\t\t\treturn Provide(opts...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Supply\",\n\t\t\tprovide: func(i int, private bool) Option {\n\t\t\t\topts := []any{i}\n\t\t\t\tif private {\n\t\t\t\t\topts = append(opts, Private)\n\t\t\t\t}\n\t\t\t\treturn Supply(opts...)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range testCases {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tt.Run(\"CanUsePrivateFromParentModule\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar invoked bool\n\t\t\t\tapp := fxtest.New(t,\n\t\t\t\t\tModule(\"SubModule\", Invoke(func(a int, b string) {\n\t\t\t\t\t\tassert.Equal(t, 0, a)\n\t\t\t\t\t\tinvoked = true\n\t\t\t\t\t})),\n\t\t\t\t\tProvide(func() string { return \"\" }),\n\t\t\t\t\ttt.provide(0, true /* private */),\n\t\t\t\t)\n\t\t\t\tapp.RequireStart().RequireStop()\n\t\t\t\tassert.True(t, invoked)\n\t\t\t})\n\n\t\t\tt.Run(\"CannotUsePrivateFromSubModule\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tapp := NewForTest(t,\n\t\t\t\t\tModule(\"SubModule\", tt.provide(0, true /* private */)),\n\t\t\t\t\tInvoke(func(a int) {}),\n\t\t\t\t)\n\t\t\t\terr := app.Err()\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), \"missing dependencies for function\")\n\t\t\t\tassert.Contains(t, err.Error(), \"missing type: int\")\n\t\t\t})\n\n\t\t\tt.Run(\"MultipleModulesSameType\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar invoked int\n\t\t\t\tapp := fxtest.New(t,\n\t\t\t\t\tModule(\"SubModuleA\",\n\t\t\t\t\t\ttt.provide(1, true /* private */),\n\t\t\t\t\t\tInvoke(func(s int) {\n\t\t\t\t\t\t\tassert.Equal(t, 1, s)\n\t\t\t\t\t\t\tinvoked++\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t\tModule(\"SubModuleB\",\n\t\t\t\t\t\ttt.provide(2, true /* private */),\n\t\t\t\t\t\tInvoke(func(s int) {\n\t\t\t\t\t\t\tassert.Equal(t, 2, s)\n\t\t\t\t\t\t\tinvoked++\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t\ttt.provide(3, false /* private */),\n\t\t\t\t\tInvoke(func(s int) {\n\t\t\t\t\t\tassert.Equal(t, 3, s)\n\t\t\t\t\t\tinvoked++\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\tapp.RequireStart().RequireStop()\n\t\t\t\tassert.Equal(t, 3, invoked)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrivateProvideWithDecorators(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tdesc string\n\n\t\t// provide is either a Supply or Provide wrapper around the given int\n\t\t// that allows us to generalize these test cases for both APIs.\n\t\tprovide func(int) Option\n\t\tprivate bool\n\t}{\n\t\t{\n\t\t\tdesc: \"Private/Provide\",\n\t\t\tprovide: func(i int) Option {\n\t\t\t\treturn Provide(\n\t\t\t\t\tfunc() int { return i },\n\t\t\t\t\tPrivate,\n\t\t\t\t)\n\t\t\t},\n\t\t\tprivate: true,\n\t\t},\n\t\t{\n\t\t\tdesc: \"Private/Supply\",\n\t\t\tprovide: func(i int) Option {\n\t\t\t\treturn Supply(i, Private)\n\t\t\t},\n\t\t\tprivate: true,\n\t\t},\n\t\t{\n\t\t\tdesc: \"Public/Provide\",\n\t\t\tprovide: func(i int) Option {\n\t\t\t\treturn Provide(func() int { return i })\n\t\t\t},\n\t\t\tprivate: false,\n\t\t},\n\t\t{\n\t\t\tdesc: \"Public/Supply\",\n\t\t\tprovide: func(i int) Option {\n\t\t\t\treturn Supply(i)\n\t\t\t},\n\t\t\tprivate: false,\n\t\t},\n\t}\n\n\tfor _, tt := range testCases {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tt.Run(\"DecoratedTypeInSubModule\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar invoked bool\n\t\t\t\tapp := NewForTest(t,\n\t\t\t\t\tModule(\"SubModule\",\n\t\t\t\t\t\ttt.provide(0),\n\t\t\t\t\t\tDecorate(func(a int) int { return a + 2 }),\n\t\t\t\t\t\tInvoke(func(a int) { assert.Equal(t, 2, a) }),\n\t\t\t\t\t),\n\t\t\t\t\tInvoke(func(a int) {\n\t\t\t\t\t\t// Decoration is always \"private\",\n\t\t\t\t\t\t// so raw provided value is expected here\n\t\t\t\t\t\t// when the submodule provides it as public.\n\t\t\t\t\t\tassert.Equal(t, 0, a)\n\t\t\t\t\t\tinvoked = true\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\terr := app.Err()\n\t\t\t\tif tt.private {\n\t\t\t\t\trequire.Error(t, err)\n\t\t\t\t\tassert.Contains(t, err.Error(), \"missing dependencies for function\")\n\t\t\t\t\tassert.Contains(t, err.Error(), \"missing type: int\")\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.True(t, invoked)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"DecoratedTypeInParentModule\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar invoked int\n\t\t\t\tapp := fxtest.New(t,\n\t\t\t\t\ttt.provide(0),\n\t\t\t\t\tDecorate(func(a int) int { return a - 5 }),\n\t\t\t\t\tInvoke(func(a int) {\n\t\t\t\t\t\tassert.Equal(t, -5, a)\n\t\t\t\t\t\tinvoked++\n\t\t\t\t\t}),\n\t\t\t\t\tModule(\"Child\",\n\t\t\t\t\t\tDecorate(func(a int) int { return a + 10 }),\n\t\t\t\t\t\tInvoke(func(a int) {\n\t\t\t\t\t\t\tassert.Equal(t, 5, a)\n\t\t\t\t\t\t\tinvoked++\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tapp.RequireStart().RequireStop()\n\t\t\t\tassert.Equal(t, 2, invoked)\n\t\t\t})\n\n\t\t\tt.Run(\"ParentDecorateChildType\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar invoked bool\n\t\t\t\tapp := NewForTest(t,\n\t\t\t\t\tModule(\"Child\", tt.provide(0)),\n\t\t\t\t\tDecorate(func(a int) int { return a + 5 }),\n\t\t\t\t\tInvoke(func(a int) {\n\t\t\t\t\t\tinvoked = true\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\terr := app.Err()\n\t\t\t\tif tt.private {\n\t\t\t\t\trequire.Error(t, err)\n\t\t\t\t\tassert.Contains(t, err.Error(), \"missing dependencies for function\")\n\t\t\t\t\tassert.Contains(t, err.Error(), \"missing type: int\")\n\t\t\t\t} else {\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.True(t, invoked)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestWithLoggerErrorUseDefault(t *testing.T) {\n\t// This test cannot be run in paralllel with the others because\n\t// it hijacks stderr.\n\n\t// Temporarily hijack stderr and restore it after this test so\n\t// that we can assert its contents.\n\tf, err := os.CreateTemp(t.TempDir(), \"stderr\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not open a file for writing\")\n\t}\n\tdefer func(oldStderr *os.File) {\n\t\tassert.NoError(t, f.Close())\n\t\tos.Stderr = oldStderr\n\t}(os.Stderr)\n\tos.Stderr = f\n\n\tapp := New(\n\t\tSupply(zap.NewNop()),\n\t\tWithLogger(&bytes.Buffer{}),\n\t)\n\terr = app.Err()\n\trequire.Error(t, err)\n\tassert.Contains(t,\n\t\terr.Error(),\n\t\t\"must provide constructor function, got  (type *bytes.Buffer)\",\n\t)\n\n\tstderr, err := os.ReadFile(f.Name())\n\trequire.NoError(t, err)\n\n\t// Example output:\n\t// [Fx] SUPPLY  *zap.Logger\n\t// [Fx] ERROR   Failed to initialize custom logger: fx.WithLogger() from:\n\t// go.uber.org/fx_test.TestSetupLogger.func3\n\t//        /Users/abg/dev/fx/app_test.go:334\n\t// testing.tRunner\n\t//        /usr/local/Cellar/go/1.16.4/libexec/src/testing/testing.go:1193\n\t// Failed: must provide constructor function, got  (type *bytes.Buffer)\n\n\tout := string(stderr)\n\tassert.Contains(t, out, \"[Fx] SUPPLY\\t*zap.Logger\\n\")\n\tassert.Contains(t, out, \"[Fx] ERROR\\t\\tFailed to initialize custom logger: fx.WithLogger\")\n\tassert.Contains(t, out, \"must provide constructor function, got  (type *bytes.Buffer)\\n\")\n}\n\nfunc TestWithLogger(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"initializing custom logger\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar spy fxlog.Spy\n\t\tapp := fxtest.New(t,\n\t\t\tSupply(&spy),\n\t\t\tWithLogger(func(spy *fxlog.Spy) fxevent.Logger {\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t)\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Run\", \"LoggerInitialized\",\n\t\t}, spy.EventTypes())\n\n\t\tspy.Reset()\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NoError(t, app.Err())\n\n\t\tassert.Equal(t, []string{\"Started\", \"Stopped\"}, spy.EventTypes())\n\t})\n\n\tt.Run(\"error in Provide shows logs\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar spy fxlog.Spy\n\t\tapp := New(\n\t\t\tSupply(&spy),\n\t\t\tWithLogger(func(spy *fxlog.Spy) fxevent.Logger {\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t\tProvide(&bytes.Buffer{}), // not passing in a constructor.\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t,\n\t\t\terr.Error(),\n\t\t\t\"must provide constructor function, got  (type *bytes.Buffer)\",\n\t\t)\n\n\t\tassert.Equal(t, []string{\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Provided\", \"Run\", \"LoggerInitialized\"}, spy.EventTypes())\n\t})\n\n\tt.Run(\"logger failed to build\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar buff bytes.Buffer\n\t\tapp := New(\n\t\t\tLogger(log.New(&buff, \"\", 0)),\n\t\t\tWithLogger(func() (fxevent.Logger, error) {\n\t\t\t\treturn nil, errors.New(\"great sadness\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"great sadness\")\n\n\t\tout := buff.String()\n\t\tassert.Contains(t, out, \"[Fx] ERROR\\t\\tFailed to initialize custom logger\")\n\t})\n\n\tt.Run(\"logger dependency failed to build\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar buff bytes.Buffer\n\t\tapp := New(\n\t\t\tLogger(log.New(&buff, \"\", 0)),\n\t\t\tProvide(func() (*zap.Logger, error) {\n\t\t\t\treturn nil, errors.New(\"great sadness\")\n\t\t\t}),\n\t\t\tWithLogger(func(log *zap.Logger) fxevent.Logger {\n\t\t\t\tt.Errorf(\"WithLogger must not be called\")\n\t\t\t\tpanic(\"must not be called\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"great sadness\")\n\n\t\tout := buff.String()\n\t\tassert.Contains(t, out, \"[Fx] PROVIDE\\t*zap.Logger\")\n\t\tassert.Contains(t, out, \"[Fx] ERROR\\t\\tFailed to initialize custom logger\")\n\t})\n}\n\nfunc getInt() int { return 0 }\n\nfunc decorateInt(i int) int { return i }\n\nvar moduleA = Module(\n\t\"ModuleA\",\n\tProvide(getInt),\n\tDecorate(decorateInt),\n\tSupply(int64(14)),\n\tReplace(\"foo\"),\n)\n\nfunc getModuleB() Option {\n\treturn Module(\n\t\t\"ModuleB\",\n\t\tmoduleA,\n\t)\n}\n\nfunc TestModuleTrace(t *testing.T) {\n\tt.Parallel()\n\n\tmoduleC := Module(\n\t\t\"ModuleC\",\n\t\tgetModuleB(),\n\t)\n\n\tapp, spy := NewSpied(moduleC)\n\trequire.NoError(t, app.Err())\n\n\twantTrace, err := regexp.Compile(\n\t\t// Provide/decorate itself, initialized via init.\n\t\t\"^go.uber.org/fx_test.init \\\\(.*fx/app_test.go:.*\\\\)\\n\" +\n\t\t\t// ModuleA initialized via init.\n\t\t\t\"go.uber.org/fx_test.init \\\\(.*fx/app_test.go:.*\\\\) \\\\(ModuleA\\\\)\\n\" +\n\t\t\t// ModuleB from getModuleB.\n\t\t\t\"go.uber.org/fx_test.getModuleB \\\\(.*fx/app_test.go:.*\\\\) \\\\(ModuleB\\\\)\\n\" +\n\t\t\t// ModuleC above.\n\t\t\t\"go.uber.org/fx_test.TestModuleTrace \\\\(.*fx/app_test.go:.*\\\\) \\\\(ModuleC\\\\)\\n\" +\n\t\t\t// Top-level app & corresponding module created by NewSpied.\n\t\t\t\"go.uber.org/fx_test.NewSpied \\\\(.*fx/app_test.go:.*\\\\)$\",\n\t)\n\trequire.NoError(t, err, \"test regexp compilation error\")\n\n\tfor _, tt := range []struct {\n\t\tdesc     string\n\t\tgetTrace func(t *testing.T) []string\n\t}{\n\t\t{\n\t\t\tdesc: \"Provide\",\n\t\t\tgetTrace: func(t *testing.T) []string {\n\t\t\t\tt.Helper()\n\t\t\t\tvar event *fxevent.Provided\n\t\t\t\tfor _, e := range spy.Events().SelectByTypeName(\"Provided\") {\n\t\t\t\t\tpe, ok := e.(*fxevent.Provided)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tif strings.HasSuffix(pe.ConstructorName, \"getInt()\") {\n\t\t\t\t\t\tevent = pe\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trequire.NotNil(t, event, \"could not find provide event for getInt()\")\n\t\t\t\treturn event.ModuleTrace\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Decorate\",\n\t\t\tgetTrace: func(t *testing.T) []string {\n\t\t\t\tt.Helper()\n\t\t\t\tevents := spy.Events().SelectByTypeName(\"Decorated\")\n\t\t\t\trequire.Len(t, events, 1)\n\t\t\t\tevent, ok := events[0].(*fxevent.Decorated)\n\t\t\t\trequire.True(t, ok)\n\t\t\t\treturn event.ModuleTrace\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Supply\",\n\t\t\tgetTrace: func(t *testing.T) []string {\n\t\t\t\tt.Helper()\n\t\t\t\tevents := spy.Events().SelectByTypeName(\"Supplied\")\n\t\t\t\trequire.Len(t, events, 1)\n\t\t\t\tevent, ok := events[0].(*fxevent.Supplied)\n\t\t\t\trequire.True(t, ok)\n\t\t\t\treturn event.ModuleTrace\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Replaced\",\n\t\t\tgetTrace: func(t *testing.T) []string {\n\t\t\t\tt.Helper()\n\t\t\t\tevents := spy.Events().SelectByTypeName(\"Replaced\")\n\t\t\t\trequire.Len(t, events, 1)\n\t\t\t\tevent, ok := events[0].(*fxevent.Replaced)\n\t\t\t\trequire.True(t, ok)\n\t\t\t\treturn event.ModuleTrace\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tgotTrace := strings.Join(tt.getTrace(t), \"\\n\")\n\t\t\tassert.Regexp(t, wantTrace, gotTrace)\n\t\t})\n\t}\n}\n\nfunc TestRunEventEmission(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, tt := range []struct {\n\t\tdesc          string\n\t\tgiveOpts      []Option\n\t\twantRunEvents []fxevent.Run\n\t\twantErr       string\n\t}{\n\t\t{\n\t\t\tdesc: \"Simple Provide And Decorate\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tProvide(func() int { return 5 }),\n\t\t\t\tDecorate(func(int) int { return 6 }),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func1()\",\n\t\t\t\t\tKind: \"provide\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func2()\",\n\t\t\t\t\tKind: \"decorate\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Supply and Decorator Error\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tSupply(5),\n\t\t\t\tDecorate(func(int) (int, error) {\n\t\t\t\t\treturn 0, errors.New(\"humongous despair\")\n\t\t\t\t}),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"stub(int)\",\n\t\t\t\t\tKind: \"supply\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func4()\",\n\t\t\t\t\tKind: \"decorate\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"humongous despair\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Replace\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tProvide(func() int { return 5 }),\n\t\t\t\tReplace(6),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"stub(int)\",\n\t\t\t\t\tKind: \"replace\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Provide Error\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tProvide(func() (int, error) {\n\t\t\t\t\treturn 0, errors.New(\"terrible sadness\")\n\t\t\t\t}),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func8()\",\n\t\t\t\t\tKind: \"provide\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"terrible sadness\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Provide Panic\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tProvide(func() int {\n\t\t\t\t\tpanic(\"bad provide\")\n\t\t\t\t}),\n\t\t\t\tRecoverFromPanics(),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func10()\",\n\t\t\t\t\tKind: \"provide\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: `panic: \"bad provide\"`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"Decorate Panic\",\n\t\t\tgiveOpts: []Option{\n\t\t\t\tSupply(5),\n\t\t\t\tDecorate(func(int) int {\n\t\t\t\t\tpanic(\"bad decorate\")\n\t\t\t\t}),\n\t\t\t\tRecoverFromPanics(),\n\t\t\t\tInvoke(func(int) {}),\n\t\t\t},\n\t\t\twantRunEvents: []fxevent.Run{\n\t\t\t\t{\n\t\t\t\t\tName: \"stub(int)\",\n\t\t\t\t\tKind: \"supply\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName: \"go.uber.org/fx_test.TestRunEventEmission.func12()\",\n\t\t\t\t\tKind: \"decorate\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: `panic: \"bad decorate\"`,\n\t\t},\n\t} {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tapp, spy := NewSpied(tt.giveOpts...)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tassert.ErrorContains(t, app.Err(), tt.wantErr)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, app.Err())\n\t\t\t}\n\n\t\t\tgotEvents := spy.Events().SelectByTypeName(\"Run\")\n\t\t\trequire.Len(t, gotEvents, len(tt.wantRunEvents))\n\t\t\tfor i, event := range gotEvents {\n\t\t\t\trEvent, ok := event.(*fxevent.Run)\n\t\t\t\trequire.True(t, ok)\n\n\t\t\t\tassert.Equal(t, tt.wantRunEvents[i].Name, rEvent.Name)\n\t\t\t\tassert.Equal(t, tt.wantRunEvents[i].Kind, rEvent.Kind)\n\t\t\t\tif tt.wantErr != \"\" && i == len(gotEvents)-1 {\n\t\t\t\t\tassert.ErrorContains(t, rEvent.Err, tt.wantErr)\n\t\t\t\t} else {\n\t\t\t\t\tassert.NoError(t, rEvent.Err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype customError struct {\n\terr error\n}\n\nfunc (e *customError) Error() string {\n\treturn fmt.Sprintf(\"custom error: %v\", e.err)\n}\n\nfunc (e *customError) Unwrap() error {\n\treturn e.err\n}\n\ntype errHandlerFunc func(error)\n\nfunc (f errHandlerFunc) HandleError(err error) { f(err) }\n\nfunc TestInvokes(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"Success event\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp, spy := NewSpied(\n\t\t\tInvoke(func() {}),\n\t\t)\n\t\trequire.NoError(t, app.Err())\n\n\t\tinvoked := spy.Events().SelectByTypeName(\"Invoked\")\n\t\trequire.Len(t, invoked, 1)\n\t\tassert.NoError(t, invoked[0].(*fxevent.Invoked).Err)\n\t})\n\n\tt.Run(\"Failure event\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\twantErr := errors.New(\"great sadness\")\n\t\tapp, spy := NewSpied(\n\t\t\tInvoke(func() error {\n\t\t\t\treturn wantErr\n\t\t\t}),\n\t\t)\n\t\trequire.Error(t, app.Err())\n\n\t\tinvoked := spy.Events().SelectByTypeName(\"Invoked\")\n\t\trequire.Len(t, invoked, 1)\n\t\trequire.Error(t, invoked[0].(*fxevent.Invoked).Err)\n\t\trequire.ErrorIs(t, invoked[0].(*fxevent.Invoked).Err, wantErr)\n\t})\n\n\tt.Run(\"ErrorsAreNotOverriden\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(func() B { return B{} }), // B inserted into the graph\n\t\t\tInvoke(func(A) {}),               // failed A invoke\n\t\t\tInvoke(func(B) {}),               // successful B invoke\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing type: fx_test.A\")\n\t})\n\n\tt.Run(\"ErrorHooksAreCalled\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\tcount := 0\n\t\th := errHandlerFunc(func(err error) {\n\t\t\tcount++\n\t\t})\n\t\tNewForTest(t,\n\t\t\tInvoke(func(A) {}),\n\t\t\tErrorHook(h),\n\t\t)\n\t\tassert.Equal(t, 1, count)\n\t})\n\n\tt.Run(\"ErrorsAreWrapped\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twantErr := errors.New(\"err\")\n\n\t\tapp := NewForTest(t,\n\t\t\tInvoke(func() error {\n\t\t\t\treturn &customError{err: wantErr}\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.ErrorIs(t, err, wantErr)\n\t\tvar ce *customError\n\t\tassert.ErrorAs(t, err, &ce)\n\t})\n}\n\nfunc TestError(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"NilErrorOption\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar invoked bool\n\n\t\tapp := NewForTest(t,\n\t\t\tError(nil),\n\t\t\tInvoke(func() { invoked = true }),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, invoked)\n\t})\n\n\tt.Run(\"SingleErrorOption\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\twantErr := errors.New(\"module failure\")\n\t\tapp := NewForTest(t,\n\t\t\tError(wantErr),\n\t\t\tInvoke(func() { t.Errorf(\"Invoke should not be called\") }),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.EqualError(t, err, \"module failure\")\n\t\tassert.ErrorIs(t, err, wantErr)\n\t})\n\n\tt.Run(\"MultipleErrorOption\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\terrA := errors.New(\"module A failure\")\n\t\terrB := errors.New(\"module B failure\")\n\t\tapp := NewForTest(t,\n\t\t\tProvide(func() A {\n\t\t\t\tt.Errorf(\"Provide should not be called\")\n\t\t\t\treturn A{}\n\t\t\t},\n\t\t\t),\n\t\t\tInvoke(func(A) { t.Errorf(\"Invoke should not be called\") }),\n\t\t\tError(\n\t\t\t\terrA,\n\t\t\t\terrB,\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.ErrorIs(t, err, errA)\n\t\tassert.ErrorIs(t, err, errB)\n\t\tassert.NotContains(t, err.Error(), \"not in the container\")\n\t})\n\n\tt.Run(\"ProvideAndInvokeErrorsAreIgnored\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(func(b B) A {\n\t\t\t\tt.Errorf(\"B is missing from the container; Provide should not be called\")\n\t\t\t\treturn A{}\n\t\t\t},\n\t\t\t),\n\t\t\tError(errors.New(\"module failure\")),\n\t\t\tInvoke(func(A) { t.Errorf(\"A was not provided; Invoke should not be called\") }),\n\t\t)\n\t\terr := app.Err()\n\t\tassert.EqualError(t, err, \"module failure\")\n\t})\n}\n\nfunc TestOptions(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"OptionsComposition\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar n int\n\t\tconstruct := func() struct{} {\n\t\t\tn++\n\t\t\treturn struct{}{}\n\t\t}\n\t\tuse := func(struct{}) {\n\t\t\tn++\n\t\t}\n\t\tapp := fxtest.New(t, Options(Provide(construct), Invoke(use)))\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.Equal(t, 2, n)\n\t})\n\n\tt.Run(\"ProvidesCalledInGraphOrder\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\tinitOrder := 0\n\t\tnew1 := func() type1 {\n\t\t\tinitOrder++\n\t\t\tassert.Equal(t, 1, initOrder)\n\t\t\treturn type1{}\n\t\t}\n\t\tnew2 := func(type1) type2 {\n\t\t\tinitOrder++\n\t\t\tassert.Equal(t, 2, initOrder)\n\t\t\treturn type2{}\n\t\t}\n\t\tnew3 := func(type1, type2) type3 {\n\t\t\tinitOrder++\n\t\t\tassert.Equal(t, 3, initOrder)\n\t\t\treturn type3{}\n\t\t}\n\t\tbiz := func(s1 type1, s2 type2, s3 type3) {\n\t\t\tinitOrder++\n\t\t\tassert.Equal(t, 4, initOrder)\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2, new3),\n\t\t\tInvoke(biz),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.Equal(t, 4, initOrder)\n\t})\n\n\tt.Run(\"ProvidesCalledLazily\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tcount := 0\n\t\tnewBuffer := func() *bytes.Buffer {\n\t\t\tt.Error(\"this module should not init: no provided type relies on it\")\n\t\t\treturn nil\n\t\t}\n\t\tnewEmpty := func() struct{} {\n\t\t\tcount++\n\t\t\treturn struct{}{}\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(newBuffer, newEmpty),\n\t\t\tInvoke(func(struct{}) { count++ }),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.Equal(t, 2, count)\n\t})\n\n\tt.Run(\"Error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tspy := new(fxlog.Spy)\n\t\tNew(\n\t\t\tProvide(&bytes.Buffer{}), // error, not a constructor\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t)\n\t\trequire.Equal(t, []string{\"Provided\", \"Provided\", \"Provided\", \"Provided\", \"LoggerInitialized\"}, spy.EventTypes())\n\t\t// First 3 provides are Fx types (Lifecycle, Shutdowner, DotGraph).\n\t\tassert.Contains(t, spy.Events()[3].(*fxevent.Provided).Err.Error(), \"must provide constructor function\")\n\t})\n}\n\nfunc TestTimeoutOptions(t *testing.T) {\n\tt.Parallel()\n\n\tconst timeout = time.Minute\n\t// Further assertions can't succeed unless the test timeout is greater than the default.\n\trequire.True(t, timeout > DefaultTimeout, \"test assertions require timeout greater than default\")\n\n\tvar started, stopped bool\n\tassertCustomContext := func(ctx context.Context, phase string) {\n\t\tdeadline, ok := ctx.Deadline()\n\t\tif assert.True(t, ok, \"no %s deadline\", phase) {\n\t\t\tremaining := time.Until(deadline)\n\t\t\tassert.True(t, remaining > DefaultTimeout, \"didn't respect customized %s timeout\", phase)\n\t\t}\n\t}\n\tverify := func(lc Lifecycle) {\n\t\tlc.Append(Hook{\n\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\tassertCustomContext(ctx, \"start\")\n\t\t\t\tstarted = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tOnStop: func(ctx context.Context) error {\n\t\t\t\tassertCustomContext(ctx, \"stop\")\n\t\t\t\tstopped = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t}\n\tapp := fxtest.New(\n\t\tt,\n\t\tInvoke(verify),\n\t\tStartTimeout(timeout),\n\t\tStopTimeout(timeout),\n\t)\n\n\tapp.RequireStart().RequireStop()\n\tassert.True(t, started, \"app wasn't started\")\n\tassert.True(t, stopped, \"app wasn't stopped\")\n}\n\nfunc TestAppRunTimeout(t *testing.T) {\n\tt.Parallel()\n\n\t// Fails with an error immediately.\n\tfailure := func() error {\n\t\treturn errors.New(\"great sadness\")\n\t}\n\n\t// Builds a hook that takes much longer than the application timeout.\n\ttakeVeryLong := func(clock *fxclock.Mock) func() error {\n\t\treturn func() error {\n\t\t\t// We'll exceed the start and stop timeouts,\n\t\t\t// and then some.\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\tclock.Add(time.Second)\n\t\t\t}\n\n\t\t\treturn errors.New(\"user should not see this\")\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tdesc string\n\n\t\t// buildHook builds and returns the hooks for this test case.\n\t\tbuildHooks func(*fxclock.Mock) []Hook\n\n\t\t// Type of the fxevent we want.\n\t\t// Does not reflect the exact value.\n\t\twantEventType fxevent.Event\n\t}{\n\t\t{\n\t\t\t// Timeout starting an application.\n\t\t\tdesc: \"OnStart timeout\",\n\t\t\tbuildHooks: func(clock *fxclock.Mock) []Hook {\n\t\t\t\treturn []Hook{\n\t\t\t\t\tStartHook(takeVeryLong(clock)),\n\t\t\t\t}\n\t\t\t},\n\t\t\twantEventType: &fxevent.Started{},\n\t\t},\n\t\t{\n\t\t\t// Timeout during a rollback because start failed.\n\t\t\tdesc: \"rollback timeout\",\n\t\t\tbuildHooks: func(clock *fxclock.Mock) []Hook {\n\t\t\t\treturn []Hook{\n\t\t\t\t\t// The hooks are separate because\n\t\t\t\t\t// OnStop will not be run if that hook failed.\n\t\t\t\t\tStartHook(takeVeryLong(clock)),\n\t\t\t\t\tStopHook(failure),\n\t\t\t\t}\n\t\t\t},\n\t\t\twantEventType: &fxevent.Started{},\n\t\t},\n\t\t{\n\t\t\t// Timeout during a stop.\n\t\t\tdesc: \"OnStop timeout\",\n\t\t\tbuildHooks: func(clock *fxclock.Mock) []Hook {\n\t\t\t\treturn []Hook{\n\t\t\t\t\tStopHook(takeVeryLong(clock)),\n\t\t\t\t}\n\t\t\t},\n\t\t\twantEventType: &fxevent.Stopped{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tmockClock := fxclock.NewMock()\n\n\t\t\tvar (\n\t\t\t\texitCode int\n\t\t\t\texited   bool\n\t\t\t)\n\t\t\texit := func(code int) {\n\t\t\t\texited = true\n\t\t\t\texitCode = code\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tassert.True(t, exited,\n\t\t\t\t\t\"os.Exit must be called\")\n\t\t\t}()\n\n\t\t\t// If the OnStart hook for this is invoked,\n\t\t\t// it means that the Start did not fail.\n\t\t\t// In that case, shut down immediately\n\t\t\t// rather than block forever.\n\t\t\tshutdown := func(sd Shutdowner, lc Lifecycle) {\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\t\treturn sd.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tapp, spy := NewSpied(\n\t\t\t\tStartTimeout(time.Second),\n\t\t\t\tStopTimeout(time.Second),\n\t\t\t\tWithExit(exit),\n\t\t\t\tWithClock(mockClock),\n\t\t\t\tInvoke(func(lc Lifecycle) {\n\t\t\t\t\thooks := tt.buildHooks(mockClock)\n\t\t\t\t\tfor _, h := range hooks {\n\t\t\t\t\t\tlc.Append(h)\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tInvoke(shutdown),\n\t\t\t)\n\n\t\t\tapp.Run()\n\t\t\tassert.NotZero(t, exitCode,\n\t\t\t\t\"exit code mismatch\")\n\n\t\t\teventType := reflect.TypeOf(tt.wantEventType).Elem().Name()\n\t\t\tmatchingEvents := spy.Events().SelectByTypeName(eventType)\n\t\t\trequire.Len(t, matchingEvents, 1,\n\t\t\t\t\"expected a %q event\", eventType)\n\n\t\t\tevent := matchingEvents[0]\n\t\t\terrv := reflect.ValueOf(event).Elem().FieldByName(\"Err\")\n\t\t\trequire.True(t, errv.IsValid(),\n\t\t\t\t\"event %q does not have an Err attribute\", eventType)\n\n\t\t\terr, _ := errv.Interface().(error)\n\t\t\tassert.ErrorIs(t, err, context.DeadlineExceeded,\n\t\t\t\t\"should fail because of a timeout\")\n\t\t})\n\t}\n}\n\nfunc TestAppStart(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"Timeout\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmockClock := fxclock.NewMock()\n\n\t\ttype A struct{}\n\t\tblocker := func(lc Lifecycle) *A {\n\t\t\tlc.Append(\n\t\t\t\tHook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\t\tmockClock.Add(5 * time.Second)\n\t\t\t\t\t\treturn ctx.Err()\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn &A{}\n\t\t}\n\t\t// NOTE: for tests that gets cancelled/times out during lifecycle methods, it's possible\n\t\t// for them to run into race with fxevent logs getting written to testing.T with the\n\t\t// remainder of the tests. As a workaround, we provide fxlog.Spy to prevent the lifecycle\n\t\t// goroutine from writing to testing.T.\n\t\tspy := new(fxlog.Spy)\n\t\tapp := NewForTest(t,\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t\tWithClock(mockClock),\n\t\t\tProvide(blocker),\n\t\t\tInvoke(func(*A) {}),\n\t\t)\n\n\t\tctx, cancel := mockClock.WithTimeout(context.Background(), time.Second)\n\n\t\terr := app.Start(ctx)\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, \"context deadline exceeded\", err.Error())\n\t\tcancel()\n\t})\n\n\tt.Run(\"TimeoutWithFinishedHooks\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmockClock := fxclock.NewMock()\n\n\t\ttype A struct{}\n\t\ttype B struct{ A *A }\n\t\ttype C struct{ B *B }\n\t\tnewA := func(lc Lifecycle) *A {\n\t\t\tlc.Append(\n\t\t\t\tHook{\n\t\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\t\tmockClock.Add(100 * time.Millisecond)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn &A{}\n\t\t}\n\t\tnewB := func(lc Lifecycle, a *A) *B {\n\t\t\tlc.Append(\n\t\t\t\tHook{\n\t\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\t\tmockClock.Add(300 * time.Millisecond)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn &B{a}\n\t\t}\n\t\tnewC := func(lc Lifecycle, b *B) *C {\n\t\t\tlc.Append(\n\t\t\t\tHook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\t\tmockClock.Add(5 * time.Second)\n\t\t\t\t\t\treturn ctx.Err()\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn &C{b}\n\t\t}\n\n\t\t// NOTE: for tests that gets cancelled/times out during lifecycle methods, it's possible\n\t\t// for them to run into race with fxevent logs getting written to testing.T with the\n\t\t// remainder of the tests. As a workaround, we provide fxlog.Spy to prevent the lifecycle\n\t\t// goroutine from writing to testing.T.\n\t\tspy := new(fxlog.Spy)\n\t\tapp := New(\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t\tWithClock(mockClock),\n\t\t\tProvide(newA, newB, newC),\n\t\t\tInvoke(func(*C) {}),\n\t\t)\n\n\t\tctx, cancel := mockClock.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\terr := app.Start(ctx)\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, \"context deadline exceeded\", err.Error())\n\t})\n\n\tt.Run(\"CtxCancelledDuringStart\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\trunning := make(chan struct{})\n\t\tnewA := func(lc Lifecycle) *A {\n\t\t\tlc.Append(\n\t\t\t\tHook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\t\tclose(running)\n\t\t\t\t\t\t<-ctx.Done()\n\t\t\t\t\t\treturn ctx.Err()\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn &A{}\n\t\t}\n\n\t\t// NOTE: for tests that gets cancelled/times out during lifecycle methods, it's possible\n\t\t// for them to run into race with fxevent logs getting written to testing.T with the\n\t\t// remainder of the tests. As a workaround, we provide fxlog.Spy to prevent the lifecycle\n\t\t// goroutine from writing to testing.T.\n\t\tspy := new(fxlog.Spy)\n\t\tapp := New(\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t\tProvide(newA),\n\t\t\tInvoke(func(*A) {}),\n\t\t)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tgo func() {\n\t\t\t<-running\n\t\t\tcancel()\n\t\t}()\n\t\terr := app.Start(ctx)\n\t\trequire.Error(t, err)\n\t\tassert.NotContains(t, err.Error(), \"context deadline exceeded\")\n\t\tassert.NotContains(t, err.Error(), \"timed out while executing hook OnStart\")\n\t})\n\n\tt.Run(\"race test\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tsecondStart := make(chan struct{}, 1)\n\t\tfirstStop := make(chan struct{}, 1)\n\t\tstartReturn := make(chan struct{}, 1)\n\n\t\tvar stop1Run bool\n\t\tapp := New(\n\t\t\tInvoke(func(lc Lifecycle) {\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t\tOnStop: func(context.Context) error {\n\t\t\t\t\t\tif stop1Run {\n\t\t\t\t\t\t\trequire.Fail(t, \"Hooks should only run once\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstop1Run = true\n\t\t\t\t\t\tclose(firstStop)\n\t\t\t\t\t\t<-startReturn\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\t\tclose(secondStart)\n\t\t\t\t\t\t<-firstStop\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t\tOnStop: func(context.Context) error {\n\t\t\t\t\t\tassert.Fail(t, \"Stop hook 2 should not be called \"+\n\t\t\t\t\t\t\t\"if start hook 2 does not finish\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\tgo func() {\n\t\t\tapp.Start(context.Background())\n\t\t\tclose(startReturn)\n\t\t}()\n\n\t\t<-secondStart\n\t\tapp.Stop(context.Background())\n\t\tassert.True(t, stop1Run)\n\t})\n\n\tt.Run(\"CtxTimeoutDuringStartStillRunsStopHooks\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar ran bool\n\t\tmockClock := fxclock.NewMock()\n\t\tapp := New(\n\t\t\tWithClock(mockClock),\n\t\t\tInvoke(func(lc Lifecycle) {\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t\tOnStop: func(ctx context.Context) error {\n\t\t\t\t\t\tran = true\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\t\tmockClock.Add(5 * time.Second)\n\t\t\t\t\t\treturn ctx.Err()\n\t\t\t\t\t},\n\t\t\t\t\tOnStop: func(ctx context.Context) error {\n\t\t\t\t\t\tassert.Fail(t, \"This Stop hook should not be called\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\n\t\tstartCtx, cancelStart := mockClock.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancelStart()\n\t\terr := app.Start(startCtx)\n\t\trequire.Error(t, err)\n\t\tassert.ErrorContains(t, err, \"context deadline exceeded\")\n\t\trequire.NoError(t, app.Stop(context.Background()))\n\t\tassert.True(t, ran, \"Stop hook for the Start hook that finished running should have been called\")\n\t})\n\n\tt.Run(\"Rollback\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfailStart := func(lc Lifecycle) struct{} {\n\t\t\tlc.Append(Hook{OnStart: func(context.Context) error {\n\t\t\t\treturn errors.New(\"OnStart fail\")\n\t\t\t}})\n\t\t\treturn struct{}{}\n\t\t}\n\t\tapp, spy := NewSpied(\n\t\t\tProvide(failStart),\n\t\t\tInvoke(func(struct{}) {}),\n\t\t)\n\t\terr := app.Start(context.Background())\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"OnStart fail\")\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Provided\",\n\t\t\t\"LoggerInitialized\",\n\t\t\t\"Invoking\",\n\t\t\t\"Run\",\n\t\t\t\"Run\",\n\t\t\t\"Invoked\",\n\t\t\t\"OnStartExecuting\", \"OnStartExecuted\",\n\t\t\t\"RollingBack\",\n\t\t\t\"RolledBack\",\n\t\t\t\"Started\",\n\t\t}, spy.EventTypes())\n\t})\n\n\tt.Run(\"StartAndStopErrors\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\terrStop1 := errors.New(\"OnStop fail 1\")\n\t\terrStart2 := errors.New(\"OnStart fail 2\")\n\t\tfail := func(lc Lifecycle) struct{} {\n\t\t\tlc.Append(Hook{\n\t\t\t\tOnStart: func(context.Context) error { return nil },\n\t\t\t\tOnStop:  func(context.Context) error { return errStop1 },\n\t\t\t})\n\t\t\tlc.Append(Hook{\n\t\t\t\tOnStart: func(context.Context) error { return errStart2 },\n\t\t\t\tOnStop:  func(context.Context) error { assert.Fail(t, \"should be never called\"); return nil },\n\t\t\t})\n\t\t\treturn struct{}{}\n\t\t}\n\t\tapp, spy := NewSpied(\n\t\t\tProvide(fail),\n\t\t\tInvoke(func(struct{}) {}),\n\t\t)\n\t\terr := app.Start(context.Background())\n\t\trequire.Error(t, err)\n\t\tassert.Equal(t, []error{errStart2, errStop1}, multierr.Errors(err))\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Provided\",\n\t\t\t\"LoggerInitialized\",\n\t\t\t\"Invoking\",\n\t\t\t\"Run\",\n\t\t\t\"Run\",\n\t\t\t\"Invoked\",\n\t\t\t\"OnStartExecuting\", \"OnStartExecuted\",\n\t\t\t\"OnStartExecuting\", \"OnStartExecuted\",\n\t\t\t\"RollingBack\",\n\t\t\t\"OnStopExecuting\", \"OnStopExecuted\",\n\t\t\t\"RolledBack\",\n\t\t\t\"Started\",\n\t\t}, spy.EventTypes())\n\t})\n\n\tt.Run(\"InvokeNonFunction\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tspy := new(fxlog.Spy)\n\n\t\tapp := New(WithLogger(func() fxevent.Logger { return spy }), Invoke(struct{}{}))\n\t\terr := app.Err()\n\t\trequire.Error(t, err, \"expected start failure\")\n\t\tassert.Contains(t, err.Error(), \"can't invoke non-function\")\n\n\t\t// Example\n\t\t// fx.Invoke({}) called from:\n\t\t// go.uber.org/fx_test.TestAppStart.func4\n\t\t//         /.../fx/app_test.go:525\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\t// Failed: can't invoke non-function {} (type struct {})\n\t\trequire.Equal(t,\n\t\t\t[]string{\"Provided\", \"Provided\", \"Provided\", \"LoggerInitialized\", \"Invoking\", \"Invoked\"},\n\t\t\tspy.EventTypes())\n\t\tfailedEvent := spy.Events()[len(spy.EventTypes())-1].(*fxevent.Invoked)\n\t\tassert.Contains(t, failedEvent.Err.Error(), \"can't invoke non-function\")\n\t\tassert.Contains(t, failedEvent.Trace, \"go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, failedEvent.Trace, \"/app_test.go\")\n\t})\n\n\tt.Run(\"ProvidingAProvideShouldFail\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(\n\t\t\t\tfunc() type1 { return type1{} },\n\t\t\t\tProvide(\n\t\t\t\t\tfunc() type2 { return type2{} },\n\t\t\t\t\tfunc() type3 { return type3{} },\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err, \"expected start failure\")\n\n\t\t// Example:\n\t\t// fx.Option should be passed to fx.New directly, not to fx.Provide: fx.Provide received fx.Provide(go.uber.org/fx_test.TestAppStart.func5.2(), go.uber.org/fx_test.TestAppStart.func5.3()) from:\n\t\t// go.uber.org/fx_test.TestAppStart.func5\n\t\t//         /.../fx/app_test.go:550\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\tassert.Contains(t, err.Error(), \"fx.Option should be passed to fx.New directly, not to fx.Provide\")\n\t\tassert.Contains(t, err.Error(), \"fx.Provide received fx.Provide(go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t})\n\n\tt.Run(\"InvokingAnInvokeShouldFail\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(func() type1 { return type1{} }),\n\t\t\tInvoke(Invoke(func(type1) {\n\t\t\t})),\n\t\t)\n\t\tnewErr := app.Err()\n\t\trequire.Error(t, newErr)\n\n\t\terr := app.Start(context.Background())\n\t\trequire.Error(t, err, \"expected start failure\")\n\t\tassert.Equal(t, err, newErr, \"start should return the same error fx.New encountered\")\n\n\t\t// Example\n\t\t// fx.Option should be passed to fx.New directly, not to fx.Invoke: fx.Invoke received fx.Invoke(go.uber.org/fx_test.TestAppStart.func6.2()) from:\n\t\t// go.uber.org/fx_test.TestAppStart.func6\n\t\t//         /.../fx/app_test.go:579\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\tassert.Contains(t, err.Error(), \"fx.Option should be passed to fx.New directly, not to fx.Invoke\")\n\t\tassert.Contains(t, err.Error(), \"fx.Invoke received fx.Invoke(go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t})\n\n\tt.Run(\"ProvidingOptionsShouldFail\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\tmodule := Options(\n\t\t\tProvide(\n\t\t\t\tfunc() type1 { return type1{} },\n\t\t\t\tfunc() type2 { return type2{} },\n\t\t\t),\n\t\t\tInvoke(func(type1) {\n\t\t\t\trequire.FailNow(t, \"module Invoked must not be called\")\n\t\t\t}),\n\t\t)\n\n\t\tapp := NewForTest(t,\n\t\t\tProvide(\n\t\t\t\tfunc() type3 { return type3{} },\n\t\t\t\tmodule,\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err, \"expected start failure\")\n\n\t\t// Example:\n\t\t// fx.Annotated should be passed to fx.Provide directly, it should not be returned by the constructor: fx.Provide received go.uber.org/fx_test.TestAnnotatedWrongUsage.func2.1() from:\n\t\t// go.uber.org/fx_test.TestAnnotatedWrongUsage.func2\n\t\t//         /.../fx/annotated_test.go:76\n\t\t// testing.tRunner\n\t\t//         /.../go/1.13.3/libexec/src/testing/testing.go:909\n\t\tassert.Contains(t, err.Error(), \"fx.Option should be passed to fx.New directly, not to fx.Provide\")\n\t\tassert.Contains(t, err.Error(), \"fx.Provide received fx.Options(fx.Provide(go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"go.uber.org/fx_test.TestAppStart\")\n\t\tassert.Contains(t, err.Error(), \"/app_test.go\")\n\t})\n\n\tt.Run(\"HookGoroutineExitsErrorMsg\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\taddHook := func(lc Lifecycle) {\n\t\t\tlc.Append(Hook{\n\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\truntime.Goexit()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tInvoke(addHook),\n\t\t)\n\t\terr := app.Start(context.Background()).Error()\n\t\tassert.Contains(t, \"goroutine exited without returning\", err)\n\t})\n\n\tt.Run(\"StartTwiceWithHooksErrors\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tInvoke(func(lc Lifecycle) {\n\t\t\t\tlc.Append(Hook{\n\t\t\t\t\tOnStart: func(ctx context.Context) error { return nil },\n\t\t\t\t\tOnStop:  func(ctx context.Context) error { return nil },\n\t\t\t\t})\n\t\t\t}),\n\t\t)\n\t\tassert.NoError(t, app.Start(ctx))\n\t\terr := app.Start(ctx)\n\t\tif assert.Error(t, err) {\n\t\t\tassert.ErrorContains(t, err, \"attempted to start lifecycle when in state: started\")\n\t\t}\n\t\tapp.Stop(ctx)\n\t\tassert.NoError(t, app.Start(ctx))\n\t\tapp.Stop(ctx)\n\t})\n}\n\nfunc TestAppStop(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"Timeout\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmockClock := fxclock.NewMock()\n\n\t\tblock := func(ctx context.Context) error {\n\t\t\tmockClock.Add(5 * time.Second)\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// NOTE: for tests that gets cancelled/times out during lifecycle methods, it's possible\n\t\t// for them to run into race with fxevent logs getting written to testing.T with the\n\t\t// remainder of the tests. As a workaround, we provide fxlog.Spy to prevent the lifecycle\n\t\t// goroutine from writing to testing.T.\n\t\tspy := new(fxlog.Spy)\n\t\tapp := New(Invoke(func(l Lifecycle) { l.Append(Hook{OnStop: block}) }),\n\t\t\tWithLogger(func() fxevent.Logger { return spy }),\n\t\t\tWithClock(mockClock),\n\t\t)\n\n\t\terr := app.Start(context.Background())\n\t\trequire.Nil(t, err)\n\n\t\tctx, cancel := mockClock.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\terr = app.Stop(ctx)\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"context deadline exceeded\")\n\t})\n\n\tt.Run(\"StopError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfailStop := func(lc Lifecycle) struct{} {\n\t\t\tlc.Append(Hook{OnStop: func(context.Context) error {\n\t\t\t\treturn errors.New(\"OnStop fail\")\n\t\t\t}})\n\t\t\treturn struct{}{}\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(failStop),\n\t\t\tInvoke(func(struct{}) {}),\n\t\t)\n\t\tapp.RequireStart()\n\t\terr := app.Stop(context.Background())\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"OnStop fail\")\n\t})\n}\n\nfunc TestValidateApp(t *testing.T) {\n\tt.Parallel()\n\n\t// helper to use the test logger\n\tvalidateApp := func(t *testing.T, opts ...Option) error {\n\t\treturn ValidateApp(\n\t\t\tappend(opts, Logger(fxtest.NewTestPrinter(t)))...,\n\t\t)\n\t}\n\n\tt.Run(\"do not run provides on graph validation\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\terr := validateApp(t,\n\t\t\tProvide(func() *type1 {\n\t\t\t\tt.Error(\"provide must not be called\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t\tInvoke(func(*type1) {}),\n\t\t)\n\t\trequire.NoError(t, err)\n\t})\n\tt.Run(\"do not run provides nor invokes on graph validation\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\terr := validateApp(t,\n\t\t\tProvide(func() *type1 {\n\t\t\t\tt.Error(\"provide must not be called\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t\tInvoke(func(*type1) {\n\t\t\t\tt.Error(\"invoke must not be called\")\n\t\t\t}),\n\t\t)\n\t\trequire.NoError(t, err)\n\t})\n\tt.Run(\"provide depends on something not available\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type1 struct{}\n\t\terr := validateApp(t,\n\t\t\tProvide(func(type1) int { return 0 }),\n\t\t\tInvoke(func(int) error { return nil }),\n\t\t)\n\t\trequire.Error(t, err, \"fx.ValidateApp should error on argument not available\")\n\t\terrMsg := err.Error()\n\t\tassert.Contains(t, errMsg, \"could not build arguments for function\")\n\t\tassert.Contains(t, errMsg, \"failed to build int: missing dependencies for function\")\n\t\tassert.Contains(t, errMsg, \"missing type: fx_test.type1\")\n\t})\n\tt.Run(\"provide introduces a cycle\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\terr := validateApp(t,\n\t\t\tProvide(func(A) B { return B{} }),\n\t\t\tProvide(func(B) A { return A{} }),\n\t\t\tInvoke(func(B) {}),\n\t\t)\n\t\trequire.Error(t, err, \"fx.ValidateApp should error on cycle\")\n\t\terrMsg := err.Error()\n\t\tassert.Contains(t, errMsg, \"cycle detected in dependency graph\")\n\t})\n\tt.Run(\"invoke a type that's not available\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\terr := validateApp(t,\n\t\t\tInvoke(func(A) {}),\n\t\t)\n\t\trequire.Error(t, err, \"fx.ValidateApp should return an error on missing invoke dep\")\n\t\terrMsg := err.Error()\n\t\tassert.Contains(t, errMsg, \"missing dependencies for function\")\n\t\tassert.Contains(t, errMsg, \"missing type: fx_test.A\")\n\t})\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\terr := validateApp(t,\n\t\t\tProvide(func() A {\n\t\t\t\treturn A{}\n\t\t\t}),\n\t\t\tInvoke(func(A) {}),\n\t\t)\n\t\trequire.NoError(t, err, \"fx.ValidateApp should not return an error\")\n\t})\n}\n\nfunc TestHookConstructors(t *testing.T) {\n\tt.Run(\"all\", func(t *testing.T) {\n\t\tvar (\n\t\t\tcalls = map[string]int{\n\t\t\t\t\"start func\":         0,\n\t\t\t\t\"start func err\":     0,\n\t\t\t\t\"start ctx func\":     0,\n\t\t\t\t\"start ctx func err\": 0,\n\t\t\t\t\"stop func\":          0,\n\t\t\t\t\"stop func err\":      0,\n\t\t\t\t\"stop ctx func\":      0,\n\t\t\t\t\"stop ctx func err\":  0,\n\t\t\t}\n\t\t\tnilFunc             func()\n\t\t\tnilErrorFunc        func() error\n\t\t\tnilContextFunc      func(context.Context)\n\t\t\tnilContextErrorFunc func(context.Context) error\n\t\t)\n\n\t\tfxtest.New(\n\t\t\tt,\n\t\t\tInvoke(func(lc Lifecycle) {\n\t\t\t\t// Nil functions\n\t\t\t\tlc.Append(StartStopHook(nilFunc, nilErrorFunc))\n\t\t\t\tlc.Append(StartStopHook(nilContextFunc, nilContextErrorFunc))\n\n\t\t\t\t// Start hooks\n\t\t\t\tlc.Append(StartHook(func() {\n\t\t\t\t\tcalls[\"start func\"]++\n\t\t\t\t}))\n\t\t\t\tlc.Append(StartHook(func() error {\n\t\t\t\t\tcalls[\"start func err\"]++\n\t\t\t\t\treturn nil\n\t\t\t\t}))\n\t\t\t\tlc.Append(StartHook(func(context.Context) {\n\t\t\t\t\tcalls[\"start ctx func\"]++\n\t\t\t\t}))\n\t\t\t\tlc.Append(StartHook(func(context.Context) error {\n\t\t\t\t\tcalls[\"start ctx func err\"]++\n\t\t\t\t\treturn nil\n\t\t\t\t}))\n\n\t\t\t\t// Stop hooks\n\t\t\t\tlc.Append(StopHook(func() {\n\t\t\t\t\tcalls[\"stop func\"]++\n\t\t\t\t}))\n\t\t\t\tlc.Append(StopHook(func() error {\n\t\t\t\t\tcalls[\"stop func err\"]++\n\t\t\t\t\treturn nil\n\t\t\t\t}))\n\t\t\t\tlc.Append(StopHook(func(context.Context) {\n\t\t\t\t\tcalls[\"stop ctx func\"]++\n\t\t\t\t}))\n\t\t\t\tlc.Append(StopHook(func(context.Context) error {\n\t\t\t\t\tcalls[\"stop ctx func err\"]++\n\t\t\t\t\treturn nil\n\t\t\t\t}))\n\n\t\t\t\t// StartStop hooks\n\t\t\t\tlc.Append(StartStopHook(\n\t\t\t\t\tfunc() {\n\t\t\t\t\t\tcalls[\"start func\"]++\n\t\t\t\t\t},\n\t\t\t\t\tfunc() error {\n\t\t\t\t\t\tcalls[\"stop func err\"]++\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t\tlc.Append(StartStopHook(\n\t\t\t\t\tfunc() error {\n\t\t\t\t\t\tcalls[\"start func err\"]++\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t\tfunc(context.Context) {\n\t\t\t\t\t\tcalls[\"stop ctx func\"]++\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t\tlc.Append(StartStopHook(\n\t\t\t\t\tfunc(context.Context) {\n\t\t\t\t\t\tcalls[\"start ctx func\"]++\n\t\t\t\t\t},\n\t\t\t\t\tfunc(context.Context) error {\n\t\t\t\t\t\tcalls[\"stop ctx func err\"]++\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t\tlc.Append(StartStopHook(\n\t\t\t\t\tfunc(context.Context) error {\n\t\t\t\t\t\tcalls[\"start ctx func err\"]++\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t\tfunc() {\n\t\t\t\t\t\tcalls[\"stop func\"]++\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}),\n\t\t).RequireStart().RequireStop()\n\n\t\tfor name, count := range calls {\n\t\t\trequire.Equalf(t, 2, count, \"bad call count: %s (%d)\", name, count)\n\t\t}\n\t})\n\n\tt.Run(\"start errors\", func(t *testing.T) {\n\t\twantErr := errors.New(\"oh no\")\n\n\t\t// Verify that wrapped `func() error` funcs produce the expected error.\n\t\terr := New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StartHook(func() error {\n\t\t\t\treturn wantErr\n\t\t\t}))\n\t\t})).Start(context.Background())\n\t\trequire.ErrorContains(t, err, wantErr.Error())\n\n\t\t// Verify that wrapped `func(context.Context) error` funcs produce the\n\t\t// expected error.\n\t\terr = New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StartHook(func(ctx context.Context) error {\n\t\t\t\treturn wantErr\n\t\t\t}))\n\t\t})).Start(context.Background())\n\t\trequire.ErrorContains(t, err, wantErr.Error())\n\t})\n\n\tt.Run(\"start deadline\", func(t *testing.T) {\n\t\twantCtx, cancel := context.WithTimeout(context.Background(), 123*time.Second)\n\t\tdefer cancel()\n\n\t\t// Verify that `func(context.Context)` funcs receive the expected\n\t\t// deadline.\n\t\tapp := New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StartHook(func(ctx context.Context) {\n\t\t\t\tvar (\n\t\t\t\t\twant, wantOK = wantCtx.Deadline()\n\t\t\t\t\tgive, giveOK = ctx.Deadline()\n\t\t\t\t)\n\n\t\t\t\trequire.Equal(t, wantOK, giveOK)\n\t\t\t\trequire.True(t, want.Equal(give))\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(wantCtx))\n\t\trequire.NoError(t, app.Stop(wantCtx))\n\n\t\t// Verify that `func(context.Context) error` funcs receive the expected\n\t\t// deadline.\n\t\tapp = New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StartHook(func(ctx context.Context) error {\n\t\t\t\tvar (\n\t\t\t\t\twant, wantOK = wantCtx.Deadline()\n\t\t\t\t\tgive, giveOK = ctx.Deadline()\n\t\t\t\t)\n\n\t\t\t\trequire.Equal(t, wantOK, giveOK)\n\t\t\t\trequire.True(t, want.Equal(give))\n\n\t\t\t\treturn nil\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(wantCtx))\n\t\trequire.NoError(t, app.Stop(wantCtx))\n\t})\n\n\tt.Run(\"stop errors\", func(t *testing.T) {\n\t\tvar (\n\t\t\tctx     = context.Background()\n\t\t\twantErr = errors.New(\"oh no\")\n\t\t)\n\n\t\t// Verify that wrapped `func() error` funcs produce the expected error.\n\t\tapp := New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StopHook(func() error {\n\t\t\t\treturn wantErr\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(ctx))\n\t\trequire.ErrorContains(t, app.Stop(ctx), wantErr.Error())\n\n\t\t// Verify that wrapped `func(context.Context) error` funcs produce the\n\t\t// expected error.\n\t\tapp = New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StopHook(func(ctx context.Context) error {\n\t\t\t\treturn wantErr\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(ctx))\n\t\trequire.ErrorIs(t, app.Stop(ctx), wantErr)\n\t})\n\n\tt.Run(\"stop deadline\", func(t *testing.T) {\n\t\twantCtx, cancel := context.WithTimeout(\n\t\t\tcontext.Background(),\n\t\t\t123*time.Second,\n\t\t)\n\t\tdefer cancel()\n\n\t\t// Verify that `func(context.Context)` funcs receive the expected\n\t\t// deadline.\n\t\tapp := New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StopHook(func(ctx context.Context) {\n\t\t\t\tvar (\n\t\t\t\t\twant, wantOK = wantCtx.Deadline()\n\t\t\t\t\tgive, giveOK = ctx.Deadline()\n\t\t\t\t)\n\n\t\t\t\trequire.Equal(t, wantOK, giveOK)\n\t\t\t\trequire.True(t, want.Equal(give))\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(wantCtx))\n\t\trequire.NoError(t, app.Stop(wantCtx))\n\n\t\t// Verify that `func(context.Context) error` funcs receive the expected\n\t\t// deadline.\n\t\tapp = New(Invoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StopHook(func(ctx context.Context) error {\n\t\t\t\tvar (\n\t\t\t\t\twant, wantOK = wantCtx.Deadline()\n\t\t\t\t\tgive, giveOK = ctx.Deadline()\n\t\t\t\t)\n\n\t\t\t\trequire.Equal(t, wantOK, giveOK)\n\t\t\t\trequire.True(t, want.Equal(give))\n\n\t\t\t\treturn nil\n\t\t\t}))\n\t\t}))\n\t\trequire.NoError(t, app.Start(wantCtx))\n\t\trequire.NoError(t, app.Stop(wantCtx))\n\t})\n\n\tt.Run(\"typed\", func(t *testing.T) {\n\t\ttype (\n\t\t\tfuncType       func()\n\t\t\tfuncErrType    func() error\n\t\t\tctxFuncType    func(context.Context)\n\t\t\tctxFuncErrType func(context.Context) error\n\t\t)\n\n\t\tvar (\n\t\t\tcalls  int\n\t\t\tmyFunc = funcType(func() {\n\t\t\t\tcalls++\n\t\t\t})\n\t\t\tmyFuncErr = funcErrType(func() error {\n\t\t\t\tcalls++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tmyCtxFunc = ctxFuncType(func(context.Context) {\n\t\t\t\tcalls++\n\t\t\t})\n\t\t\tmyCtxFuncErr = ctxFuncErrType(func(context.Context) error {\n\t\t\t\tcalls++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t)\n\n\t\t// Ensure that user function types that are assignable to supported\n\t\t// base function types are converted as expected.\n\t\trequire.NotPanics(t, func() {\n\t\t\tfxtest.New(t, Invoke(func(lc Lifecycle) {\n\t\t\t\tlc.Append(StartStopHook(myFunc, myFuncErr))\n\t\t\t\tlc.Append(StartStopHook(myCtxFunc, myCtxFuncErr))\n\t\t\t})).RequireStart().RequireStop()\n\t\t})\n\t\trequire.Equal(t, 4, calls)\n\t})\n}\n\nfunc TestDone(t *testing.T) {\n\tt.Parallel()\n\n\tapp := fxtest.New(t)\n\tdefer app.RequireStop()\n\tdone := app.Done()\n\trequire.NotNil(t, done, \"Got a nil channel.\")\n\tselect {\n\tcase sig := <-done:\n\t\tt.Fatalf(\"Got unexpected signal %v from application's Done channel.\", sig)\n\tdefault:\n\t}\n}\n\n// TestShutdownThenWait tests that if we call .Shutdown before waiting, the wait\n// will still return the last shutdown signal.\nfunc TestShutdownThenWait(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\ts       Shutdowner\n\t\tstopped bool\n\t)\n\tapp := fxtest.New(\n\t\tt,\n\t\tPopulate(&s),\n\t\tInvoke(func(lc Lifecycle) {\n\t\t\tlc.Append(StopHook(func() {\n\t\t\t\tstopped = true\n\t\t\t}))\n\t\t}),\n\t).RequireStart()\n\trequire.NotNil(t, s)\n\n\terr := s.Shutdown(ExitCode(1337))\n\tassert.NoError(t, err)\n\tassert.False(t, stopped)\n\n\tshutdownSig := <-app.Wait()\n\tassert.Equal(t, 1337, shutdownSig.ExitCode)\n\tassert.False(t, stopped)\n\n\tapp.RequireStop()\n\tassert.True(t, stopped)\n}\n\nfunc TestReplaceLogger(t *testing.T) {\n\tt.Parallel()\n\n\tspy := new(fxlog.Spy)\n\tapp := fxtest.New(t, WithLogger(func() fxevent.Logger { return spy }))\n\tapp.RequireStart().RequireStop()\n\tassert.Equal(t, []string{\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"LoggerInitialized\",\n\t\t\"Started\",\n\t\t\"Stopped\",\n\t}, spy.EventTypes())\n}\n\nfunc TestNopLogger(t *testing.T) {\n\tt.Parallel()\n\n\tapp := fxtest.New(t, NopLogger)\n\tapp.RequireStart().RequireStop()\n}\n\nfunc TestNopLoggerOptionString(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t,\n\t\t\"fx.WithLogger(go.uber.org/fx.init.func1())\",\n\t\tNopLogger.String(),\n\t)\n}\n\nfunc TestCustomLoggerWithPrinter(t *testing.T) {\n\tt.Parallel()\n\n\t// If we provide both, an fx.Logger and fx.WithLogger, and the logger\n\t// fails, we should fall back to the fx.Logger.\n\n\tvar buff bytes.Buffer\n\tapp := New(\n\t\tLogger(log.New(&buff, \"\", 0)),\n\t\tWithLogger(func() (fxevent.Logger, error) {\n\t\t\treturn nil, errors.New(\"great sadness\")\n\t\t}),\n\t)\n\terr := app.Start(context.Background())\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"great sadness\")\n\n\tout := buff.String()\n\tassert.Contains(t, out, \"failed to build fxevent.Logger\")\n\tassert.Contains(t, out, \"great sadness\")\n}\n\nfunc TestCustomLoggerWithLifecycle(t *testing.T) {\n\tt.Parallel()\n\n\tvar started, stopped bool\n\tdefer func() {\n\t\tassert.True(t, started, \"never started\")\n\t\tassert.True(t, stopped, \"never stopped\")\n\t}()\n\n\tvar buff bytes.Buffer\n\tdefer func() {\n\t\tassert.Empty(t, buff.String(), \"unexpectedly wrote to the fallback logger\")\n\t}()\n\n\tvar spy fxlog.Spy\n\tapp := New(\n\t\t// We expect WithLogger to do its job. This means we shouldn't\n\t\t// print anything to this buffer.\n\t\tLogger(log.New(&buff, \"\", 0)),\n\t\tWithLogger(func(lc Lifecycle) fxevent.Logger {\n\t\t\tlc.Append(Hook{\n\t\t\t\tOnStart: func(context.Context) error {\n\t\t\t\t\tassert.False(t, started, \"started twice\")\n\t\t\t\t\tstarted = true\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tOnStop: func(context.Context) error {\n\t\t\t\t\tassert.False(t, stopped, \"stopped twice\")\n\t\t\t\t\tstopped = true\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn &spy\n\t\t}),\n\t)\n\n\trequire.NoError(t, app.Start(context.Background()))\n\trequire.NoError(t, app.Stop(context.Background()))\n\n\tassert.Equal(t, []string{\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"Provided\",\n\t\t\"Run\",\n\t\t\"LoggerInitialized\",\n\t\t\"OnStartExecuting\", \"OnStartExecuted\",\n\t\t\"Started\",\n\t\t\"OnStopExecuting\", \"OnStopExecuted\",\n\t\t\"Stopped\",\n\t}, spy.EventTypes())\n}\n\nfunc TestCustomLoggerFailure(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\tapp := New(\n\t\t// We expect WithLogger to fail, so this buffer should be\n\t\t// contain information about the failure.\n\t\tLogger(log.New(&buff, \"\", 0)),\n\t\tWithLogger(func() (fxevent.Logger, error) {\n\t\t\treturn nil, errors.New(\"great sadness\")\n\t\t}),\n\t)\n\trequire.Error(t, app.Err())\n\n\tout := buff.String()\n\tassert.Contains(t, out, \"Failed to initialize custom logger\")\n\tassert.Contains(t, out, \"failed to build fxevent.Logger\")\n\tassert.Contains(t, out, \"received non-nil error from function\")\n\tassert.Contains(t, out, \"great sadness\")\n}\n\ntype testErrorWithGraph struct {\n\tgraph string\n}\n\nfunc (we testErrorWithGraph) Graph() DotGraph {\n\treturn DotGraph(we.graph)\n}\n\nfunc (we testErrorWithGraph) Error() string {\n\treturn \"great sadness\"\n}\n\nfunc TestVisualizeError(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"NotWrappedError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t_, err := VisualizeError(errors.New(\"great sadness\"))\n\t\trequire.Error(t, err)\n\t})\n\n\tt.Run(\"WrappedErrorWithEmptyGraph\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tgraph, err := VisualizeError(testErrorWithGraph{graph: \"\"})\n\t\tassert.Empty(t, graph)\n\t\trequire.Error(t, err)\n\t})\n\n\tt.Run(\"WrappedError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tgraph, err := VisualizeError(testErrorWithGraph{graph: \"graph\"})\n\t\tassert.Equal(t, \"graph\", graph)\n\t\trequire.NoError(t, err)\n\t})\n}\n\nfunc TestErrorHook(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"UnvisualizableError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\tvar graphErr error\n\t\th := errHandlerFunc(func(err error) {\n\t\t\t_, graphErr = VisualizeError(err)\n\t\t})\n\t\tNewForTest(t,\n\t\t\tProvide(func() A { return A{} }),\n\t\t\tInvoke(func(A) error { return errors.New(\"great sadness\") }),\n\t\t\tErrorHook(h),\n\t\t)\n\t\tassert.Equal(t, errors.New(\"unable to visualize error\"), graphErr)\n\t})\n\n\tt.Run(\"GraphWithError\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tvar errStr, graphStr string\n\t\th := errHandlerFunc(func(err error) {\n\t\t\terrStr = err.Error()\n\t\t\tgraphStr, _ = VisualizeError(err)\n\t\t})\n\t\tNewForTest(t,\n\t\t\tProvide(func() (B, error) { return B{}, fmt.Errorf(\"great sadness\") }),\n\t\t\tProvide(func(B) A { return A{} }),\n\t\t\tInvoke(func(A) {}),\n\t\t\tErrorHook(&h),\n\t\t)\n\t\tassert.Contains(t, errStr, \"great sadness\")\n\t\tassert.Contains(t, graphStr, `\"fx_test.B\" [color=red];`)\n\t\tassert.Contains(t, graphStr, `\"fx_test.A\" [color=orange];`)\n\t})\n\n\tt.Run(\"GraphWithErrorInModule\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tvar errStr, graphStr string\n\t\th := errHandlerFunc(func(err error) {\n\t\t\terrStr = err.Error()\n\t\t\tgraphStr, _ = VisualizeError(err)\n\t\t})\n\t\tNewForTest(t,\n\t\t\tModule(\"module\",\n\t\t\t\tProvide(func() (B, error) { return B{}, fmt.Errorf(\"great sadness\") }),\n\t\t\t\tProvide(func(B) A { return A{} }),\n\t\t\t\tInvoke(func(A) {}),\n\t\t\t\tErrorHook(&h),\n\t\t\t),\n\t\t)\n\t\tassert.Contains(t, errStr, \"great sadness\")\n\t\tassert.Contains(t, graphStr, `\"fx_test.B\" [color=red];`)\n\t\tassert.Contains(t, graphStr, `\"fx_test.A\" [color=orange];`)\n\t})\n}\n\nfunc TestOptionString(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive Option\n\t\twant string\n\t}{\n\t\t{\n\t\t\tdesc: \"Provide\",\n\t\t\tgive: Provide(bytes.NewReader),\n\t\t\twant: \"fx.Provide(bytes.NewReader())\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Invoked\",\n\t\t\tgive: Invoke(func(c io.Closer) error {\n\t\t\t\treturn c.Close()\n\t\t\t}),\n\t\t\twant: \"fx.Invoke(go.uber.org/fx_test.TestOptionString.func1())\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Error/single\",\n\t\t\tgive: Error(errors.New(\"great sadness\")),\n\t\t\twant: \"fx.Error(great sadness)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Error/multiple\",\n\t\t\tgive: Error(errors.New(\"foo\"), errors.New(\"bar\")),\n\t\t\twant: \"fx.Error(foo; bar)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Options/single\",\n\t\t\tgive: Options(Provide(bytes.NewBuffer)),\n\t\t\t// NOTE: We don't prune away fx.Options for the empty\n\t\t\t// case because we want to attach additional\n\t\t\t// information to the fx.Options object in the future.\n\t\t\twant: \"fx.Options(fx.Provide(bytes.NewBuffer()))\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Options/multiple\",\n\t\t\tgive: Options(\n\t\t\t\tProvide(bytes.NewBufferString),\n\t\t\t\tInvoke(func(buf *bytes.Buffer) {\n\t\t\t\t\tbuf.WriteString(\"hello\")\n\t\t\t\t}),\n\t\t\t),\n\t\t\twant: \"fx.Options(\" +\n\t\t\t\t\"fx.Provide(bytes.NewBufferString()), \" +\n\t\t\t\t\"fx.Invoke(go.uber.org/fx_test.TestOptionString.func2())\" +\n\t\t\t\t\")\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"StartTimeout\",\n\t\t\tgive: StartTimeout(time.Second),\n\t\t\twant: \"fx.StartTimeout(1s)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"StopTimeout\",\n\t\t\tgive: StopTimeout(5 * time.Second),\n\t\t\twant: \"fx.StopTimeout(5s)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"RecoverFromPanics\",\n\t\t\tgive: RecoverFromPanics(),\n\t\t\twant: \"fx.RecoverFromPanics()\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Logger\",\n\t\t\tgive: WithLogger(func() fxevent.Logger { return testLogger{t} }),\n\t\t\twant: \"fx.WithLogger(go.uber.org/fx_test.TestOptionString.func3())\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"ErrorHook\",\n\t\t\tgive: ErrorHook(testErrorHandler{t}),\n\t\t\twant: \"fx.ErrorHook(TestOptionString)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Supplied/simple\",\n\t\t\tgive: Supply(bytes.NewReader(nil), bytes.NewBuffer(nil)),\n\t\t\twant: \"fx.Supply(*bytes.Reader, *bytes.Buffer)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Supplied/Annotated\",\n\t\t\tgive: Supply(Annotated{Target: bytes.NewReader(nil)}),\n\t\t\twant: \"fx.Supply(*bytes.Reader)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Decorate\",\n\t\t\tgive: Decorate(bytes.NewBufferString),\n\t\t\twant: \"fx.Decorate(bytes.NewBufferString())\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"Replace\",\n\t\t\tgive: Replace(bytes.NewReader(nil)),\n\t\t\twant: \"fx.Replace(*bytes.Reader)\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tstringer, ok := tt.give.(fmt.Stringer)\n\t\t\trequire.True(t, ok, \"option must implement stringer\")\n\t\t\tassert.Equal(t, tt.want, stringer.String())\n\t\t})\n\t}\n}\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n\ntype testLogger struct{ t *testing.T }\n\nfunc (l testLogger) Printf(s string, args ...interface{}) {\n\tl.t.Logf(s, args...)\n}\n\nfunc (l testLogger) LogEvent(event fxevent.Event) {\n\tl.t.Logf(\"emitted event %#v\", event)\n}\n\nfunc (l testLogger) String() string {\n\treturn l.t.Name()\n}\n\ntype testErrorHandler struct{ t *testing.T }\n\nfunc (h testErrorHandler) HandleError(err error) {\n\th.t.Error(err)\n}\n\nfunc (h testErrorHandler) String() string {\n\treturn h.t.Name()\n}\n"
        },
        {
          "name": "app_unixes.go",
          "type": "blob",
          "size": 1.3515625,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris\n// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n\npackage fx\n\nimport \"golang.org/x/sys/unix\"\n\nconst (\n\t_sigINT  = unix.SIGINT\n\t_sigTERM = unix.SIGTERM\n)\n"
        },
        {
          "name": "app_wasm.go",
          "type": "blob",
          "size": 1.26171875,
          "content": "// Copyright (c) 2023 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//go:build (js && wasm) || (wasip1 && wasm)\n// +build js,wasm wasip1,wasm\n\npackage fx\n\nimport \"syscall\"\n\nconst (\n\t_sigINT  = syscall.SIGINT\n\t_sigTERM = syscall.SIGTERM\n)\n"
        },
        {
          "name": "app_windows.go",
          "type": "blob",
          "size": 1.2421875,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//go:build windows\n// +build windows\n\npackage fx\n\nimport \"golang.org/x/sys/windows\"\n\nconst (\n\t_sigINT  = windows.SIGINT\n\t_sigTERM = windows.SIGTERM\n)\n"
        },
        {
          "name": "app_windows_test.go",
          "type": "blob",
          "size": 3.697265625,
          "content": "// Copyright (c) 2020-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//go:build windows\n// +build windows\n\npackage fx_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"golang.org/x/sys/windows\"\n)\n\n// Regression test for https://github.com/uber-go/fx/issues/781.\nfunc TestWindowsCtrlCHandler(t *testing.T) {\n\t// This test operates by launching a separate process,\n\t// which we'll send a SIGINT to,\n\t// and verifying the output of the application.\n\n\t// Launch a separate process we will send SIGINT to.\n\ttestExe, err := os.Executable()\n\trequire.NoError(t, err, \"determine test executable\")\n\tcmd := exec.Command(testExe, \"-test.run\", \"TestWindowsMinimalApp\")\n\tcmd.Env = append(os.Environ(), \"FX_TEST_FAKE=1\")\n\n\t// On Windows, we need to use GenerateConsoleCtrlEvent\n\t// to SIGINT the child process.\n\t//\n\t// That API operates on Group ID granularity,\n\t// so we need to make sure our new child process\n\t// gets a new group ID rather than using the same ID\n\t// as the test we're running.\n\tcmd.SysProcAttr = &syscall.SysProcAttr{\n\t\tCreationFlags: windows.CREATE_NEW_PROCESS_GROUP,\n\t}\n\n\tstdout, err := cmd.StdoutPipe()\n\trequire.NoError(t, err, \"create stdout\")\n\n\tstderr, err := cmd.StderrPipe()\n\trequire.NoError(t, err, \"create stderr\")\n\n\trequire.NoError(t, cmd.Start())\n\n\t// Block until the child is ready by waiting for the \"ready\" text\n\t// printed to stderr.\n\tready := make(chan struct{})\n\tgo func() {\n\t\tdefer close(ready)\n\t\tstderr.Read(make([]byte, 1024))\n\t}()\n\t<-ready\n\n\trequire.NoError(t,\n\t\twindows.GenerateConsoleCtrlEvent(1, uint32(cmd.Process.Pid)),\n\t\t\"SIGINT child process\")\n\n\t// Drain stdout and stderr, and wait for the process to exit.\n\toutput, err := io.ReadAll(stdout)\n\trequire.NoError(t, err)\n\t_, err = io.Copy(io.Discard, stderr)\n\trequire.NoError(t, err)\n\trequire.NoError(t, cmd.Wait())\n\n\tassert.Contains(t, string(output), \"ONSTOP\",\n\t\t\"stdout should include ONSTOP\")\n}\n\nfunc TestWindowsMinimalApp(t *testing.T) {\n\t// This is not a real test.\n\t// It defines the behavior of the fake application\n\t// that we spawn from TestWindowsCtrlCHandler.\n\tif os.Getenv(\"FX_TEST_FAKE\") != \"1\" {\n\t\treturn\n\t}\n\n\t// An Fx application that prints \"ready\" to stderr\n\t// once its start hooks have been invoked,\n\t// and \"ONSTOP\" to stdout when its stop hooks have been invoked.\n\tfx.New(\n\t\tfx.NopLogger,\n\t\tfx.Invoke(func(lifecycle fx.Lifecycle) {\n\t\t\tlifecycle.Append(fx.Hook{\n\t\t\t\tOnStart: func(ctx context.Context) error {\n\t\t\t\t\tfmt.Fprintln(os.Stderr, \"ready\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tOnStop: func(ctx context.Context) error {\n\t\t\t\t\tfmt.Fprintln(os.Stdout, \"ONSTOP\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t})\n\t\t}),\n\t).Run()\n}\n"
        },
        {
          "name": "broadcast.go",
          "type": "blob",
          "size": 4.4892578125,
          "content": "// Copyright (c) 2024 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\n// broadcaster broadcasts signals to registered signal listeners.\n// All methods on the broadcaster are concurrency-safe.\ntype broadcaster struct {\n\t// This lock is used to protect all fields of broadcaster.\n\t// Methods on broadcaster should protect all concurrent access\n\t// by taking this lock when accessing its fields.\n\t// Conversely, this lock should NOT be taken outside of broadcaster.\n\tm sync.Mutex\n\n\t// last will contain a pointer to the last ShutdownSignal received, or\n\t// nil if none, if a new channel is created by Wait or Done, this last\n\t// signal will be immediately written to, this allows Wait or Done state\n\t// to be read after application stop\n\tlast *ShutdownSignal\n\n\t// contains channels created by Done\n\tdone []chan os.Signal\n\n\t// contains channels created by Wait\n\twait []chan ShutdownSignal\n}\n\nfunc (b *broadcaster) reset() {\n\tb.m.Lock()\n\tdefer b.m.Unlock()\n\tb.last = nil\n}\n\n// Done creates a new channel that will receive signals being broadcast\n// via the broadcaster.\n//\n// If a signal has been received prior to the call of Done,\n// the signal will be sent to the new channel.\nfunc (b *broadcaster) Done() <-chan os.Signal {\n\tb.m.Lock()\n\tdefer b.m.Unlock()\n\n\tch := make(chan os.Signal, 1)\n\t// If we had received a signal prior to the call of done, send it's\n\t// os.Signal to the new channel.\n\t// However we still want to have the operating system notify signals to this\n\t// channel should the application receive another.\n\tif b.last != nil {\n\t\tch <- b.last.Signal\n\t}\n\tb.done = append(b.done, ch)\n\treturn ch\n}\n\n// Wait creates a new channel that will receive signals being broadcast\n// via the broadcaster.\n//\n// If a signal has been received prior to the call of Wait,\n// the signal will be sent to the new channel.\nfunc (b *broadcaster) Wait() <-chan ShutdownSignal {\n\tb.m.Lock()\n\tdefer b.m.Unlock()\n\n\tch := make(chan ShutdownSignal, 1)\n\n\tif b.last != nil {\n\t\tch <- *b.last\n\t}\n\n\tb.wait = append(b.wait, ch)\n\treturn ch\n}\n\n// Broadcast sends the given signal to all channels that have been created\n// via Done or Wait. It does not block on sending, and returns an unsentSignalError\n// if any send did not go through.\nfunc (b *broadcaster) Broadcast(signal ShutdownSignal) error {\n\tb.m.Lock()\n\tdefer b.m.Unlock()\n\n\tb.last = &signal\n\n\tchannels, unsent := b.broadcast(\n\t\tsignal,\n\t\tb.broadcastDone,\n\t\tb.broadcastWait,\n\t)\n\n\tif unsent != 0 {\n\t\treturn &unsentSignalError{\n\t\t\tSignal: signal,\n\t\t\tTotal:  channels,\n\t\t\tUnsent: unsent,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (b *broadcaster) broadcast(\n\tsignal ShutdownSignal,\n\tanchors ...func(ShutdownSignal) (int, int),\n) (int, int) {\n\tvar channels, unsent int\n\n\tfor _, anchor := range anchors {\n\t\tc, u := anchor(signal)\n\t\tchannels += c\n\t\tunsent += u\n\t}\n\n\treturn channels, unsent\n}\n\nfunc (b *broadcaster) broadcastDone(signal ShutdownSignal) (int, int) {\n\tvar unsent int\n\n\tfor _, reader := range b.done {\n\t\tselect {\n\t\tcase reader <- signal.Signal:\n\t\tdefault:\n\t\t\tunsent++\n\t\t}\n\t}\n\n\treturn len(b.done), unsent\n}\n\nfunc (b *broadcaster) broadcastWait(signal ShutdownSignal) (int, int) {\n\tvar unsent int\n\n\tfor _, reader := range b.wait {\n\t\tselect {\n\t\tcase reader <- signal:\n\t\tdefault:\n\t\t\tunsent++\n\t\t}\n\t}\n\n\treturn len(b.wait), unsent\n}\n\ntype unsentSignalError struct {\n\tSignal ShutdownSignal\n\tUnsent int\n\tTotal  int\n}\n\nfunc (err *unsentSignalError) Error() string {\n\treturn fmt.Sprintf(\n\t\t\"send %v signal: %v/%v channels are blocked\",\n\t\terr.Signal,\n\t\terr.Unsent,\n\t\terr.Total,\n\t)\n}\n"
        },
        {
          "name": "decorate.go",
          "type": "blob",
          "size": 6.6298828125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Decorate specifies one or more decorator functions to an Fx application.\n//\n// # Decorator functions\n//\n// Decorator functions let users augment objects in the graph.\n// They can take in zero or more dependencies that must be provided to the\n// application with fx.Provide, and produce one or more values that can be used\n// by other fx.Provide and fx.Invoke calls.\n//\n//\tfx.Decorate(func(log *zap.Logger) *zap.Logger {\n//\t  return log.Named(\"myapp\")\n//\t})\n//\tfx.Invoke(func(log *zap.Logger) {\n//\t  log.Info(\"hello\")\n//\t  // Output:\n//\t  // {\"level\": \"info\",\"logger\":\"myapp\",\"msg\":\"hello\"}\n//\t})\n//\n// The following decorator accepts multiple dependencies from the graph,\n// augments and returns one of them.\n//\n//\tfx.Decorate(func(log *zap.Logger, cfg *Config) *zap.Logger {\n//\t  return log.Named(cfg.Name)\n//\t})\n//\n// Similar to fx.Provide, functions passed to fx.Decorate may optionally return\n// an error as their last result.\n// If a decorator returns a non-nil error, it will halt application startup.\n//\n//\tfx.Decorate(func(conn *sql.DB, cfg *Config) (*sql.DB, error) {\n//\t  if err := conn.Ping(); err != nil {\n//\t    return sql.Open(\"driver-name\", cfg.FallbackDB)\n//\t  }\n//\t  return conn, nil\n//\t})\n//\n// Decorators support both, fx.In and fx.Out structs, similar to fx.Provide and\n// fx.Invoke.\n//\n//\ttype Params struct {\n//\t  fx.In\n//\n//\t  Client usersvc.Client `name:\"readOnly\"`\n//\t}\n//\n//\ttype Result struct {\n//\t  fx.Out\n//\n//\t  Client usersvc.Client `name:\"readOnly\"`\n//\t}\n//\n//\tfx.Decorate(func(p Params) Result {\n//\t  ...\n//\t})\n//\n// Decorators can be annotated with the fx.Annotate function, but not with the\n// fx.Annotated type. Refer to documentation on fx.Annotate() to learn how to\n// use it for annotating functions.\n//\n//\tfx.Decorate(\n//\t  fx.Annotate(\n//\t    func(client usersvc.Client) usersvc.Client {\n//\t      // ...\n//\t    },\n//\t    fx.ParamTags(`name:\"readOnly\"`),\n//\t    fx.ResultTags(`name:\"readOnly\"`),\n//\t  ),\n//\t)\n//\n// Decorators support augmenting, filtering, or replacing value groups.\n// To decorate a value group, expect the entire value group slice and produce\n// the new slice.\n//\n//\ttype HandlerParam struct {\n//\t  fx.In\n//\n//\t  Log      *zap.Logger\n//\t  Handlers []Handler `group:\"server\"\n//\t}\n//\n//\ttype HandlerResult struct {\n//\t  fx.Out\n//\n//\t  Handlers []Handler `group:\"server\"\n//\t}\n//\n//\tfx.Decorate(func(p HandlerParam) HandlerResult {\n//\t  var r HandlerResult\n//\t  for _, handler := range p.Handlers {\n//\t    r.Handlers = append(r.Handlers, wrapWithLogger(p.Log, handler))\n//\t  }\n//\t  return r\n//\t}),\n//\n// Decorators can not add new values to the graph,\n// only modify or replace existing ones.\n// Types returned by a decorator that are not already in the graph\n// will be ignored.\n//\n// # Decorator scope\n//\n// Modifications made to the Fx graph with fx.Decorate are scoped to the\n// deepest fx.Module inside which the decorator was specified.\n//\n//\tfx.Module(\"mymodule\",\n//\t  fx.Decorate(func(log *zap.Logger) *zap.Logger {\n//\t    return log.Named(\"myapp\")\n//\t  }),\n//\t  fx.Invoke(func(log *zap.Logger) {\n//\t    log.Info(\"decorated logger\")\n//\t    // Output:\n//\t    // {\"level\": \"info\",\"logger\":\"myapp\",\"msg\":\"decorated logger\"}\n//\t  }),\n//\t),\n//\tfx.Invoke(func(log *zap.Logger) {\n//\t  log.Info(\"plain logger\")\n//\t  // Output:\n//\t  // {\"level\": \"info\",\"msg\":\"plain logger\"}\n//\t}),\n//\n// Decorations specified in the top-level fx.New call apply across the\n// application and chain with module-specific decorators.\n//\n//\tfx.New(\n//\t  // ...\n//\t  fx.Decorate(func(log *zap.Logger) *zap.Logger {\n//\t    return log.With(zap.Field(\"service\", \"myservice\"))\n//\t  }),\n//\t  // ...\n//\t  fx.Invoke(func(log *zap.Logger) {\n//\t    log.Info(\"outer decorator\")\n//\t    // Output:\n//\t    // {\"level\": \"info\",\"service\":\"myservice\",\"msg\":\"outer decorator\"}\n//\t  }),\n//\t  // ...\n//\t  fx.Module(\"mymodule\",\n//\t    fx.Decorate(func(log *zap.Logger) *zap.Logger {\n//\t      return log.Named(\"myapp\")\n//\t    }),\n//\t    fx.Invoke(func(log *zap.Logger) {\n//\t      log.Info(\"inner decorator\")\n//\t      // Output:\n//\t      // {\"level\": \"info\",\"logger\":\"myapp\",\"service\":\"myservice\",\"msg\":\"inner decorator\"}\n//\t    }),\n//\t  ),\n//\t)\nfunc Decorate(decorators ...interface{}) Option {\n\treturn decorateOption{\n\t\tTargets: decorators,\n\t\tStack:   fxreflect.CallerStack(1, 0),\n\t}\n}\n\ntype decorateOption struct {\n\tTargets []interface{}\n\tStack   fxreflect.Stack\n}\n\nfunc (o decorateOption) apply(mod *module) {\n\tfor _, target := range o.Targets {\n\t\tmod.decorators = append(mod.decorators, decorator{\n\t\t\tTarget: target,\n\t\t\tStack:  o.Stack,\n\t\t})\n\t}\n}\n\nfunc (o decorateOption) String() string {\n\titems := make([]string, len(o.Targets))\n\tfor i, f := range o.Targets {\n\t\titems[i] = fxreflect.FuncName(f)\n\t}\n\treturn fmt.Sprintf(\"fx.Decorate(%s)\", strings.Join(items, \", \"))\n}\n\n// decorator is a single decorator used in Fx.\ntype decorator struct {\n\t// Decorator provided to Fx.\n\tTarget interface{}\n\n\t// Stack trace of where this provide was made.\n\tStack fxreflect.Stack\n\n\t// Whether this decorator was specified via fx.Replace\n\tIsReplace   bool\n\tReplaceType reflect.Type // set only if IsReplace\n}\n\nfunc runDecorator(c container, d decorator, opts ...dig.DecorateOption) (err error) {\n\tdecorator := d.Target\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"fx.Decorate(%v) from:\\n%+vFailed: %w\", decorator, d.Stack, err)\n\t\t}\n\t}()\n\n\tswitch decorator := decorator.(type) {\n\tcase annotated:\n\t\tif dcor, derr := decorator.Build(); derr == nil {\n\t\t\terr = c.Decorate(dcor, opts...)\n\t\t}\n\tdefault:\n\t\terr = c.Decorate(decorator, opts...)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "decorate_test.go",
          "type": "blob",
          "size": 12.1484375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestDecorateSuccess(t *testing.T) {\n\ttype Logger struct {\n\t\tName string\n\t}\n\n\tt.Run(\"objects provided by other modules are decorated\", func(t *testing.T) {\n\t\tredis := fx.Module(\"redis\",\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"redis\"}\n\t\t\t}),\n\t\t)\n\n\t\ttestRedis := fx.Module(\"testRedis\",\n\t\t\tredis,\n\t\t\tfx.Decorate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"testRedis\"}\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"testRedis\", l.Name)\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\ttestRedis,\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"redis\", l.Name)\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"objects in child modules are decorated.\", func(t *testing.T) {\n\t\tredis := fx.Module(\"redis\",\n\t\t\tfx.Decorate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"redis\"}\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"redis\", l.Name)\n\t\t\t}),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tredis,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\tassert.Fail(t, \"should not run this\")\n\t\t\t\treturn &Logger{Name: \"root\"}\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"root decoration applies to all modules\", func(t *testing.T) {\n\t\tredis := fx.Module(\"redis\",\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"decorated logger\", l.Name)\n\t\t\t}),\n\t\t)\n\t\tlogger := fx.Module(\"logger\",\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"logger\"}\n\t\t\t}),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tredis,\n\t\t\tlogger,\n\t\t\tfx.Decorate(func(l *Logger) *Logger {\n\t\t\t\treturn &Logger{Name: \"decorated \" + l.Name}\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"use Decorate with Annotate\", func(t *testing.T) {\n\t\ttype Coffee struct {\n\t\t\tName  string\n\t\t\tPrice int\n\t\t}\n\n\t\tcafe := fx.Module(\"cafe\",\n\t\t\tfx.Provide(fx.Annotate(func() *Coffee {\n\t\t\t\treturn &Coffee{Name: \"Americano\", Price: 3}\n\t\t\t}, fx.ResultTags(`group:\"coffee\"`))),\n\t\t\tfx.Provide(fx.Annotate(func() *Coffee {\n\t\t\t\treturn &Coffee{Name: \"Cappucino\", Price: 4}\n\t\t\t}, fx.ResultTags(`group:\"coffee\"`))),\n\t\t\tfx.Provide(fx.Annotate(func() *Coffee {\n\t\t\t\treturn &Coffee{Name: \"Cold Brew\", Price: 4}\n\t\t\t}, fx.ResultTags(`group:\"coffee\"`))),\n\t\t)\n\n\t\ttakeout := fx.Module(\"takeout\",\n\t\t\tcafe,\n\t\t\tfx.Decorate(fx.Annotate(func(coffee []*Coffee) []*Coffee {\n\t\t\t\tvar newC []*Coffee\n\t\t\t\tfor _, c := range coffee {\n\t\t\t\t\tnewC = append(newC, &Coffee{\n\t\t\t\t\t\tName:  c.Name,\n\t\t\t\t\t\tPrice: c.Price + 1,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn newC\n\t\t\t}, fx.ParamTags(`group:\"coffee\"`), fx.ResultTags(`group:\"coffee\"`))),\n\t\t\tfx.Invoke(fx.Annotate(func(coffee []*Coffee) {\n\t\t\t\tassert.Equal(t, 3, len(coffee))\n\t\t\t\ttotalPrice := 0\n\t\t\t\tfor _, c := range coffee {\n\t\t\t\t\ttotalPrice += c.Price\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, 4+5+5, totalPrice)\n\t\t\t}, fx.ParamTags(`group:\"coffee\"`))),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\ttakeout,\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"use Decorate with parameter/result struct\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\t\ttype A struct {\n\t\t\tfx.In\n\n\t\t\tLog     *Logger\n\t\t\tVersion int `name:\"versionNum\"`\n\t\t}\n\t\ttype B struct {\n\t\t\tfx.Out\n\n\t\t\tLog     *Logger\n\t\t\tVersion int `name:\"versionNum\"`\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(func() int { return 1 },\n\t\t\t\t\tfx.ResultTags(`name:\"versionNum\"`)),\n\t\t\t\tfunc() *Logger {\n\t\t\t\t\treturn &Logger{Name: \"logger\"}\n\t\t\t\t},\n\t\t\t),\n\t\t\tfx.Decorate(func(a A) B {\n\t\t\t\treturn B{\n\t\t\t\t\tLog:     &Logger{Name: a.Log.Name + \" decorated\"},\n\t\t\t\t\tVersion: a.Version + 1,\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfx.Invoke(fx.Annotate(func(l *Logger, ver int) {\n\t\t\t\tassert.Equal(t, \"logger decorated\", l.Name)\n\t\t\t\tassert.Equal(t, 2, ver)\n\t\t\t}, fx.ParamTags(``, `name:\"versionNum\"`))),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"decorator with soft value group\", func(t *testing.T) {\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() (string, int) { return \"cheeseburger\", 15 },\n\t\t\t\t\tfx.ResultTags(`group:\"burger\"`, `group:\"potato\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() (string, int) { return \"mushroomburger\", 35 },\n\t\t\t\t\tfx.ResultTags(`group:\"burger\"`, `group:\"potato\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Provide(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc() string {\n\t\t\t\t\t\trequire.FailNow(t, \"should not be called\")\n\t\t\t\t\t\treturn \"veggieburger\"\n\t\t\t\t\t},\n\t\t\t\t\tfx.ResultTags(`group:\"burger\"`, `group:\"potato\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Decorate(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(burgers []string) []string {\n\t\t\t\t\t\tretBurg := make([]string, len(burgers))\n\t\t\t\t\t\tfor i, burger := range burgers {\n\t\t\t\t\t\t\tretBurg[i] = strings.ToUpper(burger)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn retBurg\n\t\t\t\t\t},\n\t\t\t\t\tfx.ParamTags(`group:\"burger,soft\"`),\n\t\t\t\t\tfx.ResultTags(`group:\"burger\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(\n\t\t\t\tfx.Annotate(\n\t\t\t\t\tfunc(burgers []string, fries []int) {\n\t\t\t\t\t\tassert.ElementsMatch(t, []string{\"CHEESEBURGER\", \"MUSHROOMBURGER\"}, burgers)\n\t\t\t\t\t},\n\t\t\t\t\tfx.ParamTags(`group:\"burger,soft\"`, `group:\"potato\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"decorator with optional parameter\", func(t *testing.T) {\n\t\ttype Config struct {\n\t\t\tName string\n\t\t}\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\t\ttype DecoratorParam struct {\n\t\t\tfx.In\n\n\t\t\tCfg *Config `optional:\"true\"`\n\t\t\tLog *Logger\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *Logger { return &Logger{Name: \"log\"} }),\n\t\t\tfx.Decorate(func(p DecoratorParam) *Logger {\n\t\t\t\tif p.Cfg != nil {\n\t\t\t\t\treturn &Logger{Name: p.Cfg.Name}\n\t\t\t\t}\n\t\t\t\treturn &Logger{Name: p.Log.Name}\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, l.Name, \"log\")\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"transitive decoration\", func(t *testing.T) {\n\t\ttype Config struct {\n\t\t\tScope string\n\t\t}\n\t\ttype Logger struct {\n\t\t\tCfg *Config\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *Config { return &Config{Scope: \"root\"} }),\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Decorate(func() *Config { return &Config{Scope: \"child\"} }),\n\t\t\t\tfx.Provide(func(cfg *Config) *Logger { return &Logger{Cfg: cfg} }),\n\t\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\t\tassert.Equal(t, \"child\", l.Cfg.Scope)\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"ineffective transitive decoration\", func(t *testing.T) {\n\t\ttype Config struct {\n\t\t\tScope string\n\t\t}\n\t\ttype Logger struct {\n\t\t\tCfg *Config\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *Config {\n\t\t\t\treturn &Config{Scope: \"root\"}\n\t\t\t}),\n\t\t\tfx.Provide(func(cfg *Config) *Logger {\n\t\t\t\treturn &Logger{Cfg: &Config{\n\t\t\t\t\tScope: cfg.Scope + \" logger\",\n\t\t\t\t}}\n\t\t\t}),\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Decorate(func() *Config {\n\t\t\t\t\treturn &Config{Scope: \"child\"}\n\t\t\t\t}),\n\t\t\t\t// Logger does not get replaced since it was provided\n\t\t\t\t// from a different Scope.\n\t\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\t\tassert.Equal(t, \"root logger\", l.Cfg.Scope)\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"decoration must execute when required by a member of group\", func(t *testing.T) {\n\t\ttype Drinks interface{}\n\t\ttype Coffee struct {\n\t\t\tType  string\n\t\t\tName  string\n\t\t\tPrice int\n\t\t}\n\t\ttype PriceService struct {\n\t\t\tDefaultPrice int\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *PriceService {\n\t\t\t\treturn &PriceService{DefaultPrice: 3}\n\t\t\t}),\n\t\t\tfx.Decorate(func(service *PriceService) *PriceService {\n\t\t\t\tservice.DefaultPrice = 10\n\t\t\t\treturn service\n\t\t\t}),\n\t\t\tfx.Provide(fx.Annotate(func(service *PriceService) Drinks {\n\t\t\t\tassert.Equal(t, 10, service.DefaultPrice)\n\t\t\t\treturn &Coffee{Type: \"coffee\", Name: \"Americano\", Price: service.DefaultPrice}\n\t\t\t}, fx.ResultTags(`group:\"drinks\"`))),\n\t\t\tfx.Provide(fx.Annotated{Group: \"drinks\", Target: func() Drinks {\n\t\t\t\treturn &Coffee{Type: \"coffee\", Name: \"Cold Brew\", Price: 4}\n\t\t\t}}),\n\t\t\tfx.Invoke(fx.Annotate(func(drinks []Drinks) {\n\t\t\t\tassert.Len(t, drinks, 2)\n\t\t\t}, fx.ParamTags(`group:\"drinks\"`))),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n}\n\nfunc TestDecorateFailure(t *testing.T) {\n\tt.Run(\"decorator returns an error\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"root\"}\n\t\t\t}),\n\t\t\tfx.Decorate(func(l *Logger) (*Logger, error) {\n\t\t\t\treturn &Logger{Name: l.Name + \"decorated\"}, errors.New(\"minor sadness\")\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Fail(t, \"this should not be executed\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"minor sadness\")\n\t})\n\n\tt.Run(\"decorator in a nested module returns an error\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"root\"}\n\t\t\t}),\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Decorate(func(l *Logger) *Logger {\n\t\t\t\t\treturn &Logger{Name: l.Name + \"decorated\"}\n\t\t\t\t}),\n\t\t\t\tfx.Decorate(func(l *Logger) *Logger {\n\t\t\t\t\treturn &Logger{Name: l.Name + \"decorated\"}\n\t\t\t\t}),\n\t\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\t\tassert.Fail(t, \"this should not be executed\")\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"*fx_test.Logger already decorated\")\n\t})\n\n\tt.Run(\"decorating a type more than once in the same Module errors\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"root\"}\n\t\t\t}),\n\t\t\tfx.Decorate(func(l *Logger) *Logger {\n\t\t\t\treturn &Logger{Name: \"dec1 \" + l.Name}\n\t\t\t}),\n\t\t\tfx.Decorate(func(l *Logger) *Logger {\n\t\t\t\treturn &Logger{Name: \"dec2 \" + l.Name}\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"*fx_test.Logger already decorated\")\n\t})\n\n\tt.Run(\"annotated decorator returns an error\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\n\t\ttag := `name:\"decoratedLogger\"`\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(fx.Annotate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"root\"}\n\t\t\t}, fx.ResultTags(tag))),\n\t\t\tfx.Decorate(fx.Annotate(func(l *Logger) (*Logger, error) {\n\t\t\t\treturn &Logger{Name: \"dec1 \" + l.Name}, errors.New(\"major sadness\")\n\t\t\t}, fx.ParamTags(tag), fx.ResultTags(tag))),\n\t\t\tfx.Invoke(fx.Annotate(func(l *Logger) {\n\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t}, fx.ParamTags(tag))),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"major sadness\")\n\t})\n\n\tt.Run(\"all decorator dependencies must be provided\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\t\ttype Config struct {\n\t\t\tName string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"logger\"}\n\t\t\t}),\n\t\t\tfx.Decorate(func(l *Logger, c *Config) *Logger {\n\t\t\t\treturn &Logger{Name: l.Name + c.Name}\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing dependencies\")\n\t})\n\n\tt.Run(\"decorate cannot provide a non-existent type\", func(t *testing.T) {\n\t\ttype Logger struct {\n\t\t\tName string\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Decorate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"decorator\"}\n\t\t\t}),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing dependencies\")\n\t})\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 11.333984375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package fx is a framework that makes it easy to build applications out of\n// reusable, composable modules.\n//\n// Fx applications use dependency injection to eliminate globals without the\n// tedium of manually wiring together function calls. Unlike other approaches\n// to dependency injection, Fx works with plain Go functions: you don't need\n// to use struct tags or embed special types, so Fx automatically works well\n// with most Go packages.\n//\n// # Basic usage\n//\n// Basic usage is explained in the package-level example.\n// If you're new to Fx, start there!\n//\n// Advanced features, including named instances, optional parameters,\n// and value groups, are explained in this section further down.\n//\n// # Testing Fx Applications\n//\n// To test functions that use the Lifecycle type or to write end-to-end tests\n// of your Fx application, use the helper functions and types provided by the\n// go.uber.org/fx/fxtest package.\n//\n// # Parameter Structs\n//\n// Fx constructors declare their dependencies as function parameters. This can\n// quickly become unreadable if the constructor has a lot of dependencies.\n//\n//\tfunc NewHandler(users *UserGateway, comments *CommentGateway, posts *PostGateway, votes *VoteGateway, authz *AuthZGateway) *Handler {\n//\t\t// ...\n//\t}\n//\n// To improve the readability of constructors like this, create a struct that\n// lists all the dependencies as fields and change the function to accept that\n// struct instead. The new struct is called a parameter struct.\n//\n// Fx has first class support for parameter structs: any struct embedding\n// fx.In gets treated as a parameter struct, so the individual fields in the\n// struct are supplied via dependency injection. Using a parameter struct, we\n// can make the constructor above much more readable:\n//\n//\ttype HandlerParams struct {\n//\t\tfx.In\n//\n//\t\tUsers    *UserGateway\n//\t\tComments *CommentGateway\n//\t\tPosts    *PostGateway\n//\t\tVotes    *VoteGateway\n//\t\tAuthZ    *AuthZGateway\n//\t}\n//\n//\tfunc NewHandler(p HandlerParams) *Handler {\n//\t\t// ...\n//\t}\n//\n// Though it's rarelly necessary to mix the two, constructors can receive any\n// combination of parameter structs and parameters.\n//\n//\tfunc NewHandler(p HandlerParams, l *log.Logger) *Handler {\n//\t\t// ...\n//\t}\n//\n// # Result Structs\n//\n// Result structs are the inverse of parameter structs.\n// These structs represent multiple outputs from a\n// single function as fields. Fx treats all structs embedding fx.Out as result\n// structs, so other constructors can rely on the result struct's fields\n// directly.\n//\n// Without result structs, we sometimes have function definitions like this:\n//\n//\tfunc SetupGateways(conn *sql.DB) (*UserGateway, *CommentGateway, *PostGateway, error) {\n//\t\t// ...\n//\t}\n//\n// With result structs, we can make this both more readable and easier to\n// modify in the future:\n//\n//\ttype Gateways struct {\n//\t\tfx.Out\n//\n//\t\tUsers    *UserGateway\n//\t\tComments *CommentGateway\n//\t\tPosts    *PostGateway\n//\t}\n//\n//\tfunc SetupGateways(conn *sql.DB) (Gateways, error) {\n//\t\t// ...\n//\t}\n//\n// # Named Values\n//\n// Some use cases require the application container to hold multiple values of\n// the same type.\n//\n// A constructor that produces a result struct can tag any field with\n// `name:\"..\"` to have the corresponding value added to the graph under the\n// specified name. An application may contain at most one unnamed value of a\n// given type, but may contain any number of named values of the same type.\n//\n//\ttype ConnectionResult struct {\n//\t\tfx.Out\n//\n//\t\tReadWrite *sql.DB `name:\"rw\"`\n//\t\tReadOnly  *sql.DB `name:\"ro\"`\n//\t}\n//\n//\tfunc ConnectToDatabase(...) (ConnectionResult, error) {\n//\t\t// ...\n//\t\treturn ConnectionResult{ReadWrite: rw, ReadOnly:  ro}, nil\n//\t}\n//\n// Similarly, a constructor that accepts a parameter struct can tag any field\n// with `name:\"..\"` to have the corresponding value injected by name.\n//\n//\ttype GatewayParams struct {\n//\t\tfx.In\n//\n//\t\tWriteToConn  *sql.DB `name:\"rw\"`\n//\t\tReadFromConn *sql.DB `name:\"ro\"`\n//\t}\n//\n//\tfunc NewCommentGateway(p GatewayParams) (*CommentGateway, error) {\n//\t\t// ...\n//\t}\n//\n// Note that both the name AND type of the fields on the\n// parameter struct must match the corresponding result struct.\n//\n// # Optional Dependencies\n//\n// Constructors often have optional dependencies on some types: if those types are\n// missing, they can operate in a degraded state. Fx supports optional\n// dependencies via the `optional:\"true\"` tag to fields on parameter structs.\n//\n//\ttype UserGatewayParams struct {\n//\t\tfx.In\n//\n//\t\tConn  *sql.DB\n//\t\tCache *redis.Client `optional:\"true\"`\n//\t}\n//\n// If an optional field isn't available in the container, the constructor\n// receives the field's zero value.\n//\n//\tfunc NewUserGateway(p UserGatewayParams, log *log.Logger) (*UserGateway, error) {\n//\t\tif p.Cache == nil {\n//\t\t\tlog.Print(\"Caching disabled\")\n//\t\t}\n//\t\t// ...\n//\t}\n//\n// Constructors that declare optional dependencies MUST gracefully handle\n// situations in which those dependencies are absent.\n//\n// The optional tag also allows adding new dependencies without breaking\n// existing consumers of the constructor.\n//\n// The optional tag may be combined with the name tag to declare a named\n// value dependency optional.\n//\n//\ttype GatewayParams struct {\n//\t\tfx.In\n//\n//\t\tWriteToConn  *sql.DB `name:\"rw\"`\n//\t\tReadFromConn *sql.DB `name:\"ro\" optional:\"true\"`\n//\t}\n//\n//\tfunc NewCommentGateway(p GatewayParams, log *log.Logger) (*CommentGateway, error) {\n//\t\tif p.ReadFromConn == nil {\n//\t\t\tlog.Print(\"Warning: Using RW connection for reads\")\n//\t\t\tp.ReadFromConn = p.WriteToConn\n//\t\t}\n//\t\t// ...\n//\t}\n//\n// # Value Groups\n//\n// To make it easier to produce and consume many values of the same type, Fx\n// supports named, unordered collections called value groups.\n//\n// Constructors can send values into value groups by returning a result struct\n// tagged with `group:\"..\"`.\n//\n//\ttype HandlerResult struct {\n//\t\tfx.Out\n//\n//\t\tHandler Handler `group:\"server\"`\n//\t}\n//\n//\tfunc NewHelloHandler() HandlerResult {\n//\t\t// ...\n//\t}\n//\n//\tfunc NewEchoHandler() HandlerResult {\n//\t\t// ...\n//\t}\n//\n// Any number of constructors may provide values to this named collection, but\n// the ordering of the final collection is unspecified.\n//\n// Value groups require parameter and result structs to use fields with\n// different types: if a group of constructors each returns type T, parameter\n// structs consuming the group must use a field of type []T.\n//\n// Parameter structs can request a value group by using a field of type []T\n// tagged with `group:\"..\"`.\n// This will execute all constructors that provide a value to\n// that group in an unspecified order, then collect all the results into a\n// single slice.\n//\n//\ttype ServerParams struct {\n//\t\tfx.In\n//\n//\t\tHandlers []Handler `group:\"server\"`\n//\t}\n//\n//\tfunc NewServer(p ServerParams) *Server {\n//\t\tserver := newServer()\n//\t\tfor _, h := range p.Handlers {\n//\t\t\tserver.Register(h)\n//\t\t}\n//\t\treturn server\n//\t}\n//\n// Note that values in a value group are unordered. Fx makes no guarantees\n// about the order in which these values will be produced.\n//\n// # Soft Value Groups\n//\n// By default, when a constructor declares a dependency on a value group,\n// all values provided to that value group are eagerly instantiated.\n// That is undesirable for cases where an optional component wants to\n// constribute to a value group, but only if it was actually used\n// by the rest of the application.\n//\n// A soft value group can be thought of as a best-attempt at populating the\n// group with values from constructors that have already run. In other words,\n// if a constructor's output type is only consumed by a soft value group,\n// it will not be run.\n//\n// Note that Fx randomizes the order of values in the value group,\n// so the slice of values may not match the order in which constructors\n// were run.\n//\n// To declare a soft relationship between a group and its constructors, use\n// the `soft` option on the input group tag (`group:\"[groupname],soft\"`).\n// This option is only valid for input parameters.\n//\n//\ttype Params struct {\n//\t\tfx.In\n//\n//\t\tHandlers []Handler `group:\"server,soft\"`\n//\t\tLogger   *zap.Logger\n//\t}\n//\n//\tfunc NewServer(p Params) *Server {\n//\t\t// ...\n//\t}\n//\n// With such a declaration, a constructor that provides a value to the 'server'\n// value group will be called only if there's another instantiated component\n// that consumes the results of that constructor.\n//\n//\tfunc NewHandlerAndLogger() (Handler, *zap.Logger) {\n//\t\t// ...\n//\t}\n//\n//\tfunc NewHandler() Handler {\n//\t\t// ...\n//\t}\n//\n//\tfx.Provide(\n//\t\tfx.Annotate(NewHandlerAndLogger, fx.ResultTags(`group:\"server\"`)),\n//\t\tfx.Annotate(NewHandler, fx.ResultTags(`group:\"server\"`)),\n//\t)\n//\n// NewHandlerAndLogger will be called because the Logger is consumed by the\n// application, but NewHandler will not be called because it's only consumed\n// by the soft value group.\n//\n// # Value group flattening\n//\n// By default, values of type T produced to a value group are consumed as []T.\n//\n//\ttype HandlerResult struct {\n//\t\tfx.Out\n//\n//\t\tHandler Handler `group:\"server\"`\n//\t}\n//\n//\ttype ServerParams struct {\n//\t\tfx.In\n//\n//\t\tHandlers []Handler `group:\"server\"`\n//\t}\n//\n// This means that if the producer produces []T,\n// the consumer must consume [][]T.\n//\n// There are cases where it's desirable\n// for the producer (the fx.Out) to produce multiple values ([]T),\n// and for the consumer (the fx.In) consume them as a single slice ([]T).\n// Fx offers flattened value groups for this purpose.\n//\n// To provide multiple values for a group from a result struct, produce a\n// slice and use the `,flatten` option on the group tag. This indicates that\n// each element in the slice should be injected into the group individually.\n//\n//\ttype HandlerResult struct {\n//\t\tfx.Out\n//\n//\t\tHandler []Handler `group:\"server,flatten\"`\n//\t\t// Consumed as []Handler in ServerParams.\n//\t}\n//\n// # Unexported fields\n//\n// By default, a type that embeds fx.In may not have any unexported fields. The\n// following will return an error if used with Fx.\n//\n//\ttype Params struct {\n//\t\tfx.In\n//\n//\t\tLogger *zap.Logger\n//\t\tmu     sync.Mutex\n//\t}\n//\n// If you have need of unexported fields on such a type, you may opt-into\n// ignoring unexported fields by adding the ignore-unexported struct tag to the\n// fx.In. For example,\n//\n//\ttype Params struct {\n//\t\tfx.In `ignore-unexported:\"true\"`\n//\n//\t\tLogger *zap.Logger\n//\t\tmu     sync.Mutex\n//\t}\npackage fx // import \"go.uber.org/fx\"\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error_example_test.go",
          "type": "blob",
          "size": 1.7529296875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"go.uber.org/fx\"\n)\n\nfunc ExampleError() {\n\t// A module that provides a HTTP server depends on\n\t// the $PORT environment variable. If the variable\n\t// is unset, the module returns an fx.Error option.\n\tnewHTTPServer := func() fx.Option {\n\t\tport := os.Getenv(\"PORT\")\n\t\tif port == \"\" {\n\t\t\treturn fx.Error(errors.New(\"$PORT is not set\"))\n\t\t}\n\t\treturn fx.Provide(&http.Server{\n\t\t\tAddr: fmt.Sprintf(\"127.0.0.1:%s\", port),\n\t\t})\n\t}\n\n\tapp := fx.New(\n\t\tfx.NopLogger,\n\t\tnewHTTPServer(),\n\t\tfx.Invoke(func(s *http.Server) error { return s.ListenAndServe() }),\n\t)\n\n\tfmt.Println(app.Err())\n\n\t// Output:\n\t// $PORT is not set\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 9.4853515625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxevent\"\n)\n\n// NewLogger constructs a logger. It's just a regular Go function, without any\n// special relationship to Fx.\n//\n// Since it returns a *log.Logger, Fx will treat NewLogger as the constructor\n// function for the standard library's logger. (We'll see how to integrate\n// NewLogger into an Fx application in the main function.) Since NewLogger\n// doesn't have any parameters, Fx will infer that loggers don't depend on any\n// other types - we can create them from thin air.\n//\n// Fx calls constructors lazily, so NewLogger will only be called only if some\n// other function needs a logger. Once instantiated, the logger is cached and\n// reused - within the application, it's effectively a singleton.\n//\n// By default, Fx applications only allow one constructor for each type. See\n// the documentation of the In and Out types for ways around this restriction.\nfunc NewLogger() *log.Logger {\n\tlogger := log.New(os.Stdout, \"\" /* prefix */, 0 /* flags */)\n\tlogger.Print(\"Executing NewLogger.\")\n\treturn logger\n}\n\n// NewHandler constructs a simple HTTP handler. Since it returns an\n// http.Handler, Fx will treat NewHandler as the constructor for the\n// http.Handler type.\n//\n// Like many Go functions, NewHandler also returns an error. If the error is\n// non-nil, Go convention tells the caller to assume that NewHandler failed\n// and the other returned values aren't safe to use. Fx understands this\n// idiom, and assumes that any function whose last return value is an error\n// follows this convention.\n//\n// Unlike NewLogger, NewHandler has formal parameters. Fx will interpret these\n// parameters as dependencies: in order to construct an HTTP handler,\n// NewHandler needs a logger. If the application has access to a *log.Logger\n// constructor (like NewLogger above), it will use that constructor or its\n// cached output and supply a logger to NewHandler. If the application doesn't\n// know how to construct a logger and needs an HTTP handler, it will fail to\n// start.\n//\n// Functions may also return multiple objects. For example, we could combine\n// NewHandler and NewLogger into a single function:\n//\n//\tfunc NewHandlerAndLogger() (*log.Logger, http.Handler, error)\n//\n// Fx also understands this idiom, and would treat NewHandlerAndLogger as the\n// constructor for both the *log.Logger and http.Handler types. Just like\n// constructors for a single type, NewHandlerAndLogger would be called at most\n// once, and both the handler and the logger would be cached and reused as\n// necessary.\nfunc NewHandler(logger *log.Logger) (http.Handler, error) {\n\tlogger.Print(\"Executing NewHandler.\")\n\treturn http.HandlerFunc(func(http.ResponseWriter, *http.Request) {\n\t\tlogger.Print(\"Got a request.\")\n\t}), nil\n}\n\n// NewMux constructs an HTTP mux. Like NewHandler, it depends on *log.Logger.\n// However, it also depends on the Fx-specific Lifecycle interface.\n//\n// A Lifecycle is available in every Fx application. It lets objects hook into\n// the application's start and stop phases. In a non-Fx application, the main\n// function often includes blocks like this:\n//\n//\tsrv, err := NewServer() // some long-running network server\n//\tif err != nil {\n//\t  log.Fatalf(\"failed to construct server: %v\", err)\n//\t}\n//\t// Construct other objects as necessary.\n//\tgo srv.Start()\n//\tdefer srv.Stop()\n//\n// In this example, the programmer explicitly constructs a bunch of objects,\n// crashing the program if any of the constructors encounter unrecoverable\n// errors. Once all the objects are constructed, we start any background\n// goroutines and defer cleanup functions.\n//\n// Fx removes the manual object construction with dependency injection. It\n// replaces the inline goroutine spawning and deferred cleanups with the\n// Lifecycle type.\n//\n// Here, NewMux makes an HTTP mux available to other functions. Since\n// constructors are called lazily, we know that NewMux won't be called unless\n// some other function wants to register a handler. This makes it easy to use\n// Fx's Lifecycle to start an HTTP server only if we have handlers registered.\nfunc NewMux(lc fx.Lifecycle, logger *log.Logger) *http.ServeMux {\n\tlogger.Print(\"Executing NewMux.\")\n\t// First, we construct the mux and server. We don't want to start the server\n\t// until all handlers are registered.\n\tmux := http.NewServeMux()\n\tserver := &http.Server{\n\t\tAddr:    \"127.0.0.1:8080\",\n\t\tHandler: mux,\n\t}\n\t// If NewMux is called, we know that another function is using the mux. In\n\t// that case, we'll use the Lifecycle type to register a Hook that starts\n\t// and stops our HTTP server.\n\t//\n\t// Hooks are executed in dependency order. At startup, NewLogger's hooks run\n\t// before NewMux's. On shutdown, the order is reversed.\n\t//\n\t// Returning an error from OnStart hooks interrupts application startup. Fx\n\t// immediately runs the OnStop portions of any successfully-executed OnStart\n\t// hooks (so that types which started cleanly can also shut down cleanly),\n\t// then exits.\n\t//\n\t// Returning an error from OnStop hooks logs a warning, but Fx continues to\n\t// run the remaining hooks.\n\tlc.Append(fx.Hook{\n\t\t// To mitigate the impact of deadlocks in application startup and\n\t\t// shutdown, Fx imposes a time limit on OnStart and OnStop hooks. By\n\t\t// default, hooks have a total of 15 seconds to complete. Timeouts are\n\t\t// passed via Go's usual context.Context.\n\t\tOnStart: func(context.Context) error {\n\t\t\tlogger.Print(\"Starting HTTP server.\")\n\t\t\tln, err := net.Listen(\"tcp\", server.Addr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tgo server.Serve(ln)\n\t\t\treturn nil\n\t\t},\n\t\tOnStop: func(ctx context.Context) error {\n\t\t\tlogger.Print(\"Stopping HTTP server.\")\n\t\t\treturn server.Shutdown(ctx)\n\t\t},\n\t})\n\n\treturn mux\n}\n\n// Register mounts our HTTP handler on the mux.\n//\n// Register is a typical top-level application function: it takes a generic\n// type like ServeMux, which typically comes from a third-party library, and\n// introduces it to a type that contains our application logic. In this case,\n// that introduction consists of registering an HTTP handler. Other typical\n// examples include registering RPC procedures and starting queue consumers.\n//\n// Fx calls these functions invocations, and they're treated differently from\n// the constructor functions above. Their arguments are still supplied via\n// dependency injection and they may still return an error to indicate\n// failure, but any other return values are ignored.\n//\n// Unlike constructors, invocations are called eagerly. See the main function\n// below for details.\nfunc Register(mux *http.ServeMux, h http.Handler) {\n\tmux.Handle(\"/\", h)\n}\n\nfunc Example() {\n\tapp := fx.New(\n\t\t// Provide all the constructors we need, which teaches Fx how we'd like to\n\t\t// construct the *log.Logger, http.Handler, and *http.ServeMux types.\n\t\t// Remember that constructors are called lazily, so this block doesn't do\n\t\t// much on its own.\n\t\tfx.Provide(\n\t\t\tNewLogger,\n\t\t\tNewHandler,\n\t\t\tNewMux,\n\t\t),\n\t\t// Since constructors are called lazily, we need some invocations to\n\t\t// kick-start our application. In this case, we'll use Register. Since it\n\t\t// depends on an http.Handler and *http.ServeMux, calling it requires Fx\n\t\t// to build those types using the constructors above. Since we call\n\t\t// NewMux, we also register Lifecycle hooks to start and stop an HTTP\n\t\t// server.\n\t\tfx.Invoke(Register),\n\n\t\t// This is optional. With this, you can control where Fx logs\n\t\t// its events. In this case, we're using a NopLogger to keep\n\t\t// our test silent. Normally, you'll want to use an\n\t\t// fxevent.ZapLogger or an fxevent.ConsoleLogger.\n\t\tfx.WithLogger(\n\t\t\tfunc() fxevent.Logger {\n\t\t\t\treturn fxevent.NopLogger\n\t\t\t},\n\t\t),\n\t)\n\n\t// In a typical application, we could just use app.Run() here. Since we\n\t// don't want this example to run forever, we'll use the more-explicit Start\n\t// and Stop.\n\tstartCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)\n\tdefer cancel()\n\tif err := app.Start(startCtx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Normally, we'd block here with <-app.Done(). Instead, we'll make an HTTP\n\t// request to demonstrate that our server is running.\n\tif _, err := http.Get(\"http://localhost:8080/\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstopCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)\n\tdefer cancel()\n\tif err := app.Stop(stopCtx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// Executing NewLogger.\n\t// Executing NewMux.\n\t// Executing NewHandler.\n\t// Starting HTTP server.\n\t// Got a request.\n\t// Stopping HTTP server.\n}\n"
        },
        {
          "name": "extract.go",
          "type": "blob",
          "size": 4.0283203125,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nvar _typeOfIn = reflect.TypeOf(In{})\n\n// Extract fills the given struct with values from the dependency injection\n// container on application initialization. The target MUST be a pointer to a\n// struct. Only exported fields will be filled.\n//\n// Deprecated: Use Populate instead.\nfunc Extract(target interface{}) Option {\n\tv := reflect.ValueOf(target)\n\n\tif t := v.Type(); t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {\n\t\treturn Error(fmt.Errorf(\"Extract expected a pointer to a struct, got a %v\", t))\n\t}\n\n\tv = v.Elem()\n\tt := v.Type()\n\n\t// We generate a function which accepts a single fx.In struct as an\n\t// argument. This struct contains all exported fields of the target\n\t// struct.\n\n\t// Fields of the generated fx.In struct.\n\tfields := make([]reflect.StructField, 0, t.NumField()+1)\n\n\t// Anonymous dig.In field.\n\tfields = append(fields, reflect.StructField{\n\t\tName:      _typeOfIn.Name(),\n\t\tAnonymous: true,\n\t\tType:      _typeOfIn,\n\t})\n\n\t// List of values in the target struct aligned with the fields of the\n\t// generated struct.\n\t//\n\t// So for example, if the target is,\n\t//\n\t// \tvar target struct {\n\t// \t\tFoo io.Reader\n\t// \t\tbar []byte\n\t// \t\tBaz io.Writer\n\t// \t}\n\t//\n\t// The generated struct has the shape,\n\t//\n\t// \tstruct {\n\t// \t\tfx.In\n\t//\n\t// \t\tF0 io.Reader\n\t// \t\tF2 io.Writer\n\t// \t}\n\t//\n\t// And `targets` is,\n\t//\n\t// \t[\n\t// \t\ttarget.Field(0),  // Foo io.Reader\n\t// \t\ttarget.Field(2),  // Baz io.Writer\n\t// \t]\n\t//\n\t// As we iterate through the fields of the generated struct, we can copy\n\t// the value into the corresponding value in the targets list.\n\ttargets := make([]reflect.Value, 0, t.NumField())\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\n\t\t// Skip unexported fields.\n\t\tif f.Anonymous {\n\t\t\t// If embedded, StructField.PkgPath is not a reliable indicator of\n\t\t\t// whether the field is exported. See\n\t\t\t// https://github.com/golang/go/issues/21122\n\n\t\t\tt := f.Type\n\t\t\tif t.Kind() == reflect.Ptr {\n\t\t\t\tt = t.Elem()\n\t\t\t}\n\n\t\t\tif !isExported(t.Name()) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else if f.PkgPath != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We don't copy over names or embedded semantics.\n\t\tfields = append(fields, reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"F%d\", i),\n\t\t\tType: f.Type,\n\t\t\tTag:  f.Tag,\n\t\t})\n\t\ttargets = append(targets, v.Field(i))\n\t}\n\n\t// Equivalent to,\n\t//\n\t// \tfunc(r struct {\n\t// \t\tfx.In\n\t//\n\t// \t\tF1 Foo\n\t// \t\tF2 Bar\n\t// \t}) {\n\t// \t\ttarget.Foo = r.F1\n\t// \t\ttarget.Bar = r.F2\n\t// \t}\n\n\tfn := reflect.MakeFunc(\n\t\treflect.FuncOf(\n\t\t\t[]reflect.Type{reflect.StructOf(fields)},\n\t\t\tnil,   /* results */\n\t\t\tfalse, /* variadic */\n\t\t),\n\t\tfunc(args []reflect.Value) []reflect.Value {\n\t\t\tresult := args[0]\n\t\t\tfor i := 1; i < result.NumField(); i++ {\n\t\t\t\ttargets[i-1].Set(result.Field(i))\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t)\n\n\treturn Invoke(fn.Interface())\n}\n\n// isExported reports whether the identifier is exported.\nfunc isExported(id string) bool {\n\tr, _ := utf8.DecodeRuneInString(id)\n\treturn unicode.IsUpper(r)\n}\n"
        },
        {
          "name": "extract_test.go",
          "type": "blob",
          "size": 7.9560546875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n\n\t. \"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/dig\"\n)\n\nfunc TestExtract(t *testing.T) {\n\tt.Parallel()\n\n\ttype type1 struct{}\n\ttype type2 struct{}\n\ttype type3 struct{}\n\n\tt.Run(\"Failures\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttests := []interface{}{\n\t\t\t3,\n\t\t\tfunc() {},\n\t\t\tstruct{}{},\n\t\t\tstruct{ Foo *bytes.Buffer }{},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\ttt := tt\n\t\t\tt.Run(fmt.Sprintf(\"%T\", tt), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tapp := NewForTest(t,\n\t\t\t\t\tProvide(func() *bytes.Buffer { return &bytes.Buffer{} }),\n\t\t\t\t\tExtract(&tt),\n\t\t\t\t)\n\t\t\t\terr := app.Err()\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), \"Extract expected a pointer to a struct\")\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"ValidateApp\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttests := []interface{}{\n\t\t\t3,\n\t\t\tfunc() {},\n\t\t\tstruct{}{},\n\t\t\tstruct{ Foo *bytes.Buffer }{},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\ttt := tt\n\t\t\tt.Run(fmt.Sprintf(\"%T\", tt), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\terr := validateTestApp(t,\n\t\t\t\t\tProvide(func() *bytes.Buffer { return &bytes.Buffer{} }),\n\t\t\t\t\tExtract(&tt),\n\t\t\t\t)\n\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), \"Extract expected a pointer to a struct\")\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"Empty\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tnew1 := func() *type1 { panic(\"new1 must not be called\") }\n\t\tnew2 := func() *type2 { panic(\"new2 must not be called\") }\n\n\t\tvar out struct{}\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2),\n\t\t\tExtract(&out),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"StructIsExtracted\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave1 *type1\n\t\tnew1 := func() *type1 {\n\t\t\tgave1 = &type1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tvar gave2 *type2\n\t\tnew2 := func() *type2 {\n\t\t\tgave2 = &type2{}\n\t\t\treturn gave2\n\t\t}\n\n\t\tvar out struct {\n\t\t\tT1 *type1\n\t\t\tT2 *type2\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.T1, \"T1 must not be nil\")\n\t\tassert.NotNil(t, out.T2, \"T2 must not be nil\")\n\t\tassert.True(t, gave1 == out.T1, \"T1 must match\")\n\t\tassert.True(t, gave2 == out.T2, \"T2 must match\")\n\t})\n\n\tt.Run(\"EmbeddedExportedField\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype T1 struct{}\n\n\t\tvar gave1 *T1\n\t\tnew1 := func() *T1 {\n\t\t\tgave1 = &T1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tvar out struct{ *T1 }\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.T1, \"T1 must not be nil\")\n\t\tassert.True(t, gave1 == out.T1, \"T1 must match\")\n\t})\n\n\tt.Run(\"EmbeddedUnexportedField\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tnew1 := func() *type1 { return &type1{} }\n\t\tvar out struct{ *type1 }\n\n\t\tapp := fxtest.New(t, Provide(new1), Extract(&out))\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\t// Unexported fields are left unchanged.\n\t\tassert.Nil(t, out.type1, \"type1 must be nil\")\n\t})\n\n\tt.Run(\"EmbeddedUnexportedFieldValue\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype type4 struct{ foo string }\n\t\tnew4 := func() type4 { return type4{\"foo\"} }\n\t\tvar out struct{ type4 }\n\n\t\tapp := fxtest.New(t, Provide(new4), Extract(&out))\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\t// Unexported fields are left unchanged.\n\t\tassert.NotEqual(t, \"foo\", out.type4.foo)\n\t})\n\n\tt.Run(\"DuplicateFields\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave *type1\n\t\tnew1 := func() *type1 {\n\t\t\trequire.Nil(t, gave, \"gave must be nil\")\n\t\t\tgave = &type1{}\n\t\t\treturn gave\n\t\t}\n\n\t\tvar out struct {\n\t\t\tX *type1\n\t\t\tY *type1\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.X, \"X must not be nil\")\n\t\tassert.NotNil(t, out.Y, \"Y must not be nil\")\n\t\tassert.True(t, gave == out.X, \"X must match\")\n\t\tassert.True(t, gave == out.Y, \"Y must match\")\n\t})\n\n\tt.Run(\"SkipsUnexported\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave1 *type1\n\t\tnew1 := func() *type1 {\n\t\t\tgave1 = &type1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tnew2 := func() *type2 { panic(\"new2 must not be called\") }\n\n\t\tvar gave3 *type3\n\t\tnew3 := func() *type3 {\n\t\t\tgave3 = &type3{}\n\t\t\treturn gave3\n\t\t}\n\n\t\tvar out struct {\n\t\t\tT1 *type1\n\t\t\tt2 *type2\n\t\t\tT3 *type3\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2, new3),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.T1, \"T1 must not be nil\")\n\t\tassert.Nil(t, out.t2, \"t2 must be nil\")\n\t\tassert.NotNil(t, out.T3, \"T3 must not be nil\")\n\t\tassert.True(t, gave1 == out.T1, \"T1 must match\")\n\t\tassert.True(t, gave3 == out.T3, \"T3 must match\")\n\t})\n\n\tt.Run(\"DoesNotZeroUnexported\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave1 *type1\n\t\tnew1 := func() *type1 {\n\t\t\tgave1 = &type1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tnew2 := func() *type2 { panic(\"new2 must not be called\") }\n\n\t\tvar out struct {\n\t\t\tT1 *type1\n\t\t\tt2 *type2\n\t\t}\n\t\tt2 := &type2{}\n\t\tout.t2 = t2\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.T1, \"T1 must not be nil\")\n\t\tassert.NotNil(t, out.t2, \"t2 must not be nil\")\n\t\tassert.True(t, gave1 == out.T1, \"T1 must match\")\n\t\tassert.True(t, t2 == out.t2, \"t2 must match\")\n\t})\n\n\tt.Run(\"TopLevelDigIn\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar out struct{ dig.In }\n\t\tapp := fxtest.New(t, Extract(&out))\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"TopLevelFxIn\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tnew1 := func() *type1 { panic(\"new1 must not be called\") }\n\t\tnew2 := func() *type2 { panic(\"new2 must not be called\") }\n\n\t\tvar out struct{ In }\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1, new2),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"NestedFxIn\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave1 *type1\n\t\tnew1 := func() *type1 {\n\t\t\tgave1 = &type1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tvar out struct {\n\t\t\tResult struct {\n\t\t\t\tIn\n\n\t\t\t\tT1 *type1\n\t\t\t\tT2 *type2 `optional:\"true\"`\n\t\t\t}\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.Result.T1, \"T1 must not be nil\")\n\t\tassert.Nil(t, out.Result.T2, \"T2 must be nil\")\n\t\tassert.True(t, gave1 == out.Result.T1, \"T1 must match\")\n\t})\n\n\tt.Run(\"FurtherNestedFxIn\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar out struct {\n\t\t\tIn\n\n\t\t\tB struct {\n\t\t\t\tIn\n\n\t\t\t\tC int\n\t\t\t}\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() int { return 42 }),\n\t\t\tExtract(&out),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.Equal(t, 42, out.B.C, \"B.C must match\")\n\t})\n\n\tt.Run(\"FieldsCanBeOptional\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar gave1 *type1\n\t\tnew1 := func() *type1 {\n\t\t\tgave1 = &type1{}\n\t\t\treturn gave1\n\t\t}\n\n\t\tvar out struct {\n\t\t\tT1 *type1\n\t\t\tT2 *type2 `optional:\"true\"`\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(new1),\n\t\t\tExtract(&out),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NotNil(t, out.T1, \"T1 must not be nil\")\n\t\tassert.Nil(t, out.T2, \"T2 must be nil\")\n\n\t\tassert.True(t, gave1 == out.T1, \"T1 must match\")\n\t})\n}\n"
        },
        {
          "name": "fxevent",
          "type": "tree",
          "content": null
        },
        {
          "name": "fxtest",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3779296875,
          "content": "module go.uber.org/fx\n\ngo 1.22\n\nrequire (\n\tgithub.com/stretchr/testify v1.8.1\n\tgo.uber.org/dig v1.18.0\n\tgo.uber.org/goleak v1.2.0\n\tgo.uber.org/multierr v1.10.0\n\tgo.uber.org/zap v1.26.0\n\tgolang.org/x/sys v0.0.0-20220412211240-33da011f77ad\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.0556640625,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngo.uber.org/dig v1.18.0 h1:imUL1UiY0Mg4bqbFfsRQO5G4CGRBec/ZujWTvSVp3pw=\ngo.uber.org/dig v1.18.0/go.mod h1:Us0rSJiThwCv2GteUN0Q7OKvU7n5J4dxZ9JKUXozFdE=\ngo.uber.org/goleak v1.2.0 h1:xqgm/S+aQvhWFTtR0XK3Jvg7z8kGV8P4X14IzwN3Eqk=\ngo.uber.org/goleak v1.2.0/go.mod h1:XJYK+MuIchqpmGmUSAzotztawfKvYLUIgg7guXrwVUo=\ngo.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=\ngo.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/zap v1.26.0 h1:sI7k6L95XOKS281NhVKOFCUNIvv9e0w4BF8N3u+tCRo=\ngo.uber.org/zap v1.26.0/go.mod h1:dtElttAiwGvoJ/vj4IwHBS/gXsEu/pZ50mUIRWuG0so=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de h1:5hukYrvBGR8/eNkX5mdUezrA6JiaEZDtJb9Ei+1LlBs=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/sys v0.0.0-20220412211240-33da011f77ad h1:ntjMns5wyP/fN65tdBD4g8J5w8n015+iIIs9rtjXkY0=\ngolang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/tools v0.1.5 h1:ouewzE6p+/VEB31YYnTbEJdi8pFqKp4P4n85vwo3DHA=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "inout.go",
          "type": "blob",
          "size": 1.97265625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport \"go.uber.org/dig\"\n\n// In can be embedded into a struct to mark it as a parameter struct.\n// This allows it to make use of advanced dependency injection features.\n// See package documentation for more information.\n//\n// It's recommended that shared modules use a single parameter struct to\n// provide a forward-compatible API:\n// adding new optional fields to a struct is backward-compatible,\n// so modules can evolve as needs change.\ntype In = dig.In\n\n// Out is the inverse of In: it marks a struct as a result struct so that\n// it can be used with advanced dependency injection features.\n// See package documentation for more information.\n//\n// It's recommended that shared modules use a single result struct to\n// provide a forward-compatible API:\n// adding new fields to a struct is backward-compatible,\n// so modules can produce more outputs as they grow.\ntype Out = dig.Out\n"
        },
        {
          "name": "inout_test.go",
          "type": "blob",
          "size": 4.2578125,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestIn(t *testing.T) {\n\tt.Parallel()\n\n\ttype in struct {\n\t\tfx.In\n\t}\n\tassert.True(t, dig.IsIn(in{}), \"Expected dig.In to work with fx.In\")\n}\n\nfunc TestOut(t *testing.T) {\n\tt.Parallel()\n\n\ttype out struct {\n\t\tfx.Out\n\t}\n\tassert.True(t, dig.IsOut(out{}), \"expected dig.Out to work with fx.Out\")\n}\n\nfunc TestOptionalTypes(t *testing.T) {\n\tt.Parallel()\n\n\ttype foo struct{}\n\tnewFoo := func() *foo { return &foo{} }\n\n\ttype bar struct{}\n\tnewBar := func() *bar { return &bar{} }\n\n\ttype in struct {\n\t\tfx.In\n\n\t\tFoo *foo\n\t\tBar *bar `optional:\"true\"`\n\t}\n\n\tt.Run(\"NotProvided\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tran := false\n\t\tapp := fxtest.New(t, fx.Provide(newFoo), fx.Invoke(func(in in) {\n\t\t\tassert.NotNil(t, in.Foo, \"foo was not optional and provided, expected not nil\")\n\t\t\tassert.Nil(t, in.Bar, \"bar was optional and not provided, expected nil\")\n\t\t\tran = true\n\t\t}))\n\t\tapp.RequireStart().RequireStop()\n\t\tassert.True(t, ran, \"expected invoke to run\")\n\t})\n\n\tt.Run(\"Provided\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tran := false\n\t\tapp := fxtest.New(t, fx.Provide(newFoo, newBar), fx.Invoke(func(in in) {\n\t\t\tassert.NotNil(t, in.Foo, \"foo was not optional and provided, expected not nil\")\n\t\t\tassert.NotNil(t, in.Bar, \"bar was optional and provided, expected not nil\")\n\t\t\tran = true\n\t\t}))\n\t\tapp.RequireStart().RequireStop()\n\t\tassert.True(t, ran, \"expected invoke to run\")\n\t})\n}\n\nfunc TestNamedTypes(t *testing.T) {\n\tt.Parallel()\n\n\ttype a struct {\n\t\tname string\n\t}\n\n\t// a constructor that returns the type a with name \"foo\"\n\ttype fooOut struct {\n\t\tfx.Out\n\n\t\tA *a `name:\"foo\"`\n\t}\n\tnewFoo := func() fooOut {\n\t\treturn fooOut{\n\t\t\tA: &a{name: \"foo\"},\n\t\t}\n\t}\n\n\t// another constructor that returns the same type a with name \"bar\"\n\ttype barOut struct {\n\t\tfx.Out\n\n\t\tA *a `name:\"bar\"`\n\t}\n\tnewBar := func() barOut {\n\t\treturn barOut{\n\t\t\tA: &a{name: \"bar\"},\n\t\t}\n\t}\n\n\t// invoke with an fx.In that resolves both named types\n\ttype in struct {\n\t\tfx.In\n\n\t\tFoo *a `name:\"foo\"`\n\t\tBar *a `name:\"bar\"`\n\t}\n\tran := false\n\tapp := fxtest.New(t, fx.Provide(newFoo, newBar), fx.Invoke(func(in in) {\n\t\tassert.NotNil(t, in.Foo, \"expected in.Foo to be injected\")\n\t\tassert.Equal(t, \"foo\", in.Foo.name, \"expected to get type 'a' of name 'foo'\")\n\n\t\tassert.NotNil(t, in.Bar, \"expected in.Bar to be injected\")\n\t\tassert.Equal(t, \"bar\", in.Bar.name, \"expected to get a type 'a' of name 'bar'\")\n\n\t\tran = true\n\t}))\n\tapp.RequireStart().RequireStop()\n\tassert.True(t, ran, \"expected invoke to run\")\n}\n\nfunc TestIgnoreUnexported(t *testing.T) {\n\tt.Parallel()\n\n\ttype A struct{ ID int }\n\ttype B struct{ ID int }\n\n\ttype Params struct {\n\t\tfx.In `ignore-unexported:\"true\"`\n\n\t\tA A\n\t\tb B // will be ignored\n\t}\n\n\tran := false\n\trun := func(in Params) {\n\t\tdefer func() { ran = true }()\n\n\t\tassert.Equal(t, A{1}, in.A, \"A must be set\")\n\n\t\t// We provide a B to the container, but because the \"b\" field\n\t\t// is unexported, we don't expect it to be set.\n\t\tassert.Equal(t, B{0}, in.b, \"b must be unset\")\n\t}\n\tdefer func() {\n\t\tassert.True(t, ran, \"run was never called\")\n\t}()\n\n\tfxtest.New(t,\n\t\tfx.Supply(A{1}, B{2}),\n\t\tfx.Invoke(run),\n\t).RequireStart().RequireStop()\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "invoke.go",
          "type": "blob",
          "size": 3.5068359375,
          "content": "// Copyright (c) 2019-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Invoke registers functions that are executed eagerly on application start.\n// Arguments for these invocations are built using the constructors registered\n// by Provide. Passing multiple Invoke options appends the new invocations to\n// the application's existing list.\n//\n// Unlike constructors, invocations are always executed, and they're always\n// run in order. Invocations may have any number of returned values.\n// If the final returned object is an error, it indicates whether the operation\n// was successful.\n// All other returned values are discarded.\n//\n// Invokes registered in [Module]s are run before the ones registered at the\n// scope of the parent. Invokes within the same Module is run in the order\n// they were provided. For example,\n//\n//\tfx.New(\n//\t\tfx.Invoke(func3),\n//\t\tfx.Module(\"someModule\",\n//\t\t\tfx.Invoke(func1),\n//\t\t\tfx.Invoke(func2),\n//\t\t),\n//\t\tfx.Invoke(func4),\n//\t)\n//\n// invokes func1, func2, func3, func4 in that order.\n//\n// Typically, invoked functions take a handful of high-level objects (whose\n// constructors depend on lower-level objects) and introduce them to each\n// other. This kick-starts the application by forcing it to instantiate a\n// variety of types.\n//\n// To see an invocation in use, read through the package-level example. For\n// advanced features, including optional parameters and named instances, see\n// the documentation of the In and Out types.\nfunc Invoke(funcs ...interface{}) Option {\n\treturn invokeOption{\n\t\tTargets: funcs,\n\t\tStack:   fxreflect.CallerStack(1, 0),\n\t}\n}\n\ntype invokeOption struct {\n\tTargets []interface{}\n\tStack   fxreflect.Stack\n}\n\nfunc (o invokeOption) apply(mod *module) {\n\tfor _, target := range o.Targets {\n\t\tmod.invokes = append(mod.invokes, invoke{\n\t\t\tTarget: target,\n\t\t\tStack:  o.Stack,\n\t\t})\n\t}\n}\n\nfunc (o invokeOption) String() string {\n\titems := make([]string, len(o.Targets))\n\tfor i, f := range o.Targets {\n\t\titems[i] = fxreflect.FuncName(f)\n\t}\n\treturn fmt.Sprintf(\"fx.Invoke(%s)\", strings.Join(items, \", \"))\n}\n\nfunc runInvoke(c container, i invoke) error {\n\tfn := i.Target\n\tswitch fn := fn.(type) {\n\tcase Option:\n\t\treturn fmt.Errorf(\"fx.Option should be passed to fx.New directly, \"+\n\t\t\t\"not to fx.Invoke: fx.Invoke received %v from:\\n%+v\",\n\t\t\tfn, i.Stack)\n\n\tcase annotated:\n\t\taf, err := fn.Build()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn c.Invoke(af)\n\tdefault:\n\t\treturn c.Invoke(fn)\n\t}\n}\n"
        },
        {
          "name": "lifecycle.go",
          "type": "blob",
          "size": 4.4423828125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"context\"\n\n\t\"go.uber.org/fx/internal/lifecycle\"\n)\n\n// A HookFunc is a function that can be used as a [Hook].\ntype HookFunc interface {\n\t~func() | ~func() error | ~func(context.Context) | ~func(context.Context) error\n}\n\n// Lifecycle allows constructors to register callbacks that are executed on\n// application start and stop. See the documentation for App for details on Fx\n// applications' initialization, startup, and shutdown logic.\ntype Lifecycle interface {\n\tAppend(Hook)\n}\n\n// A Hook is a pair of start and stop callbacks, either of which can be nil.\n// If a Hook's OnStart callback isn't executed (because a previous OnStart\n// failure short-circuited application startup), its OnStop callback won't be\n// executed.\ntype Hook struct {\n\tOnStart func(context.Context) error\n\tOnStop  func(context.Context) error\n\n\tonStartName string\n\tonStopName  string\n}\n\n// StartHook returns a new Hook with start as its [Hook.OnStart] function,\n// wrapping its signature as needed. For example, given the following function:\n//\n//\tfunc myfunc() {\n//\t  fmt.Println(\"hook called\")\n//\t}\n//\n// then calling:\n//\n//\tlifecycle.Append(StartHook(myfunc))\n//\n// is functionally equivalent to calling:\n//\n//\tlifecycle.Append(fx.Hook{\n//\t  OnStart: func(context.Context) error {\n//\t    myfunc()\n//\t    return nil\n//\t  },\n//\t})\n//\n// The same is true for all functions that satisfy the HookFunc constraint.\n// Note that any context.Context parameter or error return will be propagated\n// as expected. If propagation is not intended, users should instead provide a\n// closure that discards the undesired value(s), or construct a Hook directly.\nfunc StartHook[T HookFunc](start T) Hook {\n\tonstart, startname := lifecycle.Wrap(start)\n\n\treturn Hook{\n\t\tOnStart:     onstart,\n\t\tonStartName: startname,\n\t}\n}\n\n// StopHook returns a new Hook with stop as its [Hook.OnStop] function,\n// wrapping its signature as needed. For example, given the following function:\n//\n//\tfunc myfunc() {\n//\t  fmt.Println(\"hook called\")\n//\t}\n//\n// then calling:\n//\n//\tlifecycle.Append(StopHook(myfunc))\n//\n// is functionally equivalent to calling:\n//\n//\tlifecycle.Append(fx.Hook{\n//\t  OnStop: func(context.Context) error {\n//\t    myfunc()\n//\t    return nil\n//\t  },\n//\t})\n//\n// The same is true for all functions that satisfy the HookFunc constraint.\n// Note that any context.Context parameter or error return will be propagated\n// as expected. If propagation is not intended, users should instead provide a\n// closure that discards the undesired value(s), or construct a Hook directly.\nfunc StopHook[T HookFunc](stop T) Hook {\n\tonstop, stopname := lifecycle.Wrap(stop)\n\n\treturn Hook{\n\t\tOnStop:     onstop,\n\t\tonStopName: stopname,\n\t}\n}\n\n// StartStopHook returns a new Hook with start as its [Hook.OnStart] function\n// and stop as its [Hook.OnStop] function, independently wrapping the signature\n// of each as needed.\nfunc StartStopHook[T1 HookFunc, T2 HookFunc](start T1, stop T2) Hook {\n\tvar (\n\t\tonstart, startname = lifecycle.Wrap(start)\n\t\tonstop, stopname   = lifecycle.Wrap(stop)\n\t)\n\n\treturn Hook{\n\t\tOnStart:     onstart,\n\t\tOnStop:      onstop,\n\t\tonStartName: startname,\n\t\tonStopName:  stopname,\n\t}\n}\n\ntype lifecycleWrapper struct {\n\t*lifecycle.Lifecycle\n}\n\nfunc (l *lifecycleWrapper) Append(h Hook) {\n\tl.Lifecycle.Append(lifecycle.Hook{\n\t\tOnStart:     h.OnStart,\n\t\tOnStop:      h.OnStop,\n\t\tOnStartName: h.onStartName,\n\t\tOnStopName:  h.onStopName,\n\t})\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 1.69140625,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"go.uber.org/fx/fxevent\"\n)\n\n// logBuffer will buffer all messages until a logger has been\n// initialized.\ntype logBuffer struct {\n\tevents []fxevent.Event\n\tlogger fxevent.Logger\n}\n\n// LogEvent buffers or logs an event.\nfunc (l *logBuffer) LogEvent(event fxevent.Event) {\n\tif l.logger == nil {\n\t\tl.events = append(l.events, event)\n\t} else {\n\t\tl.logger.LogEvent(event)\n\t}\n}\n\n// Connect flushes out all buffered events to a logger and resets them.\nfunc (l *logBuffer) Connect(logger fxevent.Logger) {\n\tl.logger = logger\n\tfor _, e := range l.events {\n\t\tlogger.LogEvent(e)\n\t}\n\tl.events = nil\n}\n"
        },
        {
          "name": "log_test.go",
          "type": "blob",
          "size": 2.17578125,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/internal/fxlog\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zaptest\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\nfunc TestLogBufferConnect(t *testing.T) {\n\tt.Parallel()\n\n\tspy := new(fxlog.Spy)\n\tevent := &fxevent.Started{}\n\tlb := &logBuffer{\n\t\tevents: []fxevent.Event{event},\n\t\tlogger: nil,\n\t}\n\n\tlb.Connect(spy)\n\tassert.Equal(t, fxlog.Events{event}, spy.Events())\n}\n\nfunc TestLogBufferLog(t *testing.T) {\n\tt.Parallel()\n\n\tspy := new(fxlog.Spy)\n\tevent := &fxevent.Started{}\n\tlb := &logBuffer{\n\t\tevents: nil,\n\t\tlogger: nil,\n\t}\n\n\tlb.LogEvent(event)\n\n\tlb.Connect(spy)\n\tassert.Equal(t, fxlog.Events{event}, spy.Events())\n}\n\nfunc TestWithLoggerDecorate(t *testing.T) {\n\tt.Parallel()\n\n\tcore, logs := observer.New(zap.DebugLevel)\n\tNew(\n\t\tSupply(zaptest.NewLogger(t)), // provide a logger\n\t\tReplace(zap.New(core)),       // and replace it\n\t\tWithLogger(func(log *zap.Logger) fxevent.Logger {\n\t\t\treturn &fxevent.ZapLogger{Logger: log}\n\t\t}),\n\t)\n\n\tassert.NotZero(t, logs.Len(),\n\t\t\"should post to replacement logger\")\n}\n"
        },
        {
          "name": "module.go",
          "type": "blob",
          "size": 10.5927734375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n\t\"go.uber.org/multierr\"\n)\n\n// A container represents a set of constructors to provide\n// dependencies, and a set of functions to invoke once all the\n// dependencies have been initialized.\n//\n// This definition corresponds to the dig.Container and dig.Scope.\ntype container interface {\n\tInvoke(interface{}, ...dig.InvokeOption) error\n\tProvide(interface{}, ...dig.ProvideOption) error\n\tDecorate(interface{}, ...dig.DecorateOption) error\n}\n\n// Module is a named group of zero or more fx.Options.\n//\n// A Module scopes the effect of certain operations to within the module.\n// For more information, see [Decorate], [Replace], or [Invoke].\n//\n// Module allows packages to bundle sophisticated functionality into easy-to-use\n// logical units.\n// For example, a logging package might export a simple option like this:\n//\n//\tpackage logging\n//\n//\tvar Module = fx.Module(\"logging\",\n//\t\tfx.Provide(func() *log.Logger {\n//\t\t\treturn log.New(os.Stdout, \"\", 0)\n//\t\t}),\n//\t\t// ...\n//\t)\n//\n// A shared all-in-one microservice package could use Module to bundle\n// all required components of a microservice:\n//\n//\tpackage server\n//\n//\tvar Module = fx.Module(\"server\",\n//\t\tlogging.Module,\n//\t\tmetrics.Module,\n//\t\ttracing.Module,\n//\t\trpc.Module,\n//\t)\n//\n// When new global functionality is added to the service ecosystem,\n// it can be added to the shared module with minimal churn for users.\n//\n// Use the all-in-one pattern sparingly.\n// It limits the flexibility available to the application.\nfunc Module(name string, opts ...Option) Option {\n\tmo := moduleOption{\n\t\tname:     name,\n\t\tlocation: fxreflect.CallerStack(1, 2)[0],\n\t\toptions:  opts,\n\t}\n\treturn mo\n}\n\ntype moduleOption struct {\n\tname     string\n\tlocation fxreflect.Frame\n\toptions  []Option\n}\n\nfunc (o moduleOption) String() string {\n\treturn fmt.Sprintf(\"fx.Module(%q, %v)\", o.name, o.options)\n}\n\nfunc (o moduleOption) apply(mod *module) {\n\t// This get called on any submodules' that are declared\n\t// as part of another module.\n\n\t// 1. Create a new module with the parent being the specified\n\t// module.\n\t// 2. Apply child Options on the new module.\n\t// 3. Append it to the parent module.\n\n\t// Create trace as parent's trace with this module's location pre-pended.\n\ttrace := append([]string{fmt.Sprintf(\"%v (%v)\", o.location, o.name)}, mod.trace...)\n\tnewModule := &module{\n\t\tname:   o.name,\n\t\tparent: mod,\n\t\ttrace:  trace,\n\t\tapp:    mod.app,\n\t}\n\tfor _, opt := range o.options {\n\t\topt.apply(newModule)\n\t}\n\tmod.modules = append(mod.modules, newModule)\n}\n\ntype module struct {\n\tparent         *module\n\tname           string\n\ttrace          []string\n\tscope          scope\n\tprovides       []provide\n\tinvokes        []invoke\n\tdecorators     []decorator\n\tmodules        []*module\n\tapp            *App\n\tlog            fxevent.Logger\n\tfallbackLogger fxevent.Logger\n\tlogConstructor *provide\n}\n\n// scope is a private wrapper interface for dig.Container and dig.Scope.\n// We can consider moving this into Fx using type constraints after Go 1.20\n// is released and 1.17 is deprecated.\ntype scope interface {\n\tDecorate(f interface{}, opts ...dig.DecorateOption) error\n\tInvoke(f interface{}, opts ...dig.InvokeOption) error\n\tProvide(f interface{}, opts ...dig.ProvideOption) error\n\tScope(name string, opts ...dig.ScopeOption) *dig.Scope\n\tString() string\n}\n\n// builds the Scopes using the App's Container. Note that this happens\n// after applyModules' are called because the App's Container needs to\n// be built for any Scopes to be initialized, and applys' should be called\n// before the Container can get initialized.\nfunc (m *module) build(app *App, root *dig.Container) {\n\tif m.parent == nil {\n\t\tm.scope = root\n\t} else {\n\t\tparentScope := m.parent.scope\n\t\tm.scope = parentScope.Scope(m.name)\n\t\t// use parent module's logger by default\n\t\tm.log = m.parent.log\n\t}\n\n\tif m.logConstructor != nil {\n\t\t// Since user supplied a custom logger, use a buffered logger\n\t\t// to hold all messages until user supplied logger is\n\t\t// instantiated. Then we flush those messages after fully\n\t\t// constructing the custom logger.\n\t\tm.fallbackLogger, m.log = m.log, new(logBuffer)\n\t}\n\n\tfor _, mod := range m.modules {\n\t\tmod.build(app, root)\n\t}\n}\n\nfunc (m *module) provideAll() {\n\tfor _, p := range m.provides {\n\t\tm.provide(p)\n\t}\n\n\tfor _, m := range m.modules {\n\t\tm.provideAll()\n\t}\n}\n\nfunc (m *module) provide(p provide) {\n\tif m.app.err != nil {\n\t\treturn\n\t}\n\n\tif p.IsSupply {\n\t\tm.supply(p)\n\t\treturn\n\t}\n\n\tfuncName := fxreflect.FuncName(p.Target)\n\tvar info dig.ProvideInfo\n\topts := []dig.ProvideOption{\n\t\tdig.FillProvideInfo(&info),\n\t\tdig.Export(!p.Private),\n\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\tm.log.LogEvent(&fxevent.Run{\n\t\t\t\tName:       funcName,\n\t\t\t\tKind:       \"provide\",\n\t\t\t\tModuleName: m.name,\n\t\t\t\tRuntime:    ci.Runtime,\n\t\t\t\tErr:        ci.Error,\n\t\t\t})\n\t\t}),\n\t}\n\n\tif err := runProvide(m.scope, p, opts...); err != nil {\n\t\tm.app.err = err\n\t}\n\toutputNames := make([]string, len(info.Outputs))\n\tfor i, o := range info.Outputs {\n\t\toutputNames[i] = o.String()\n\t}\n\n\tm.log.LogEvent(&fxevent.Provided{\n\t\tConstructorName: funcName,\n\t\tStackTrace:      p.Stack.Strings(),\n\t\tModuleTrace:     append([]string{p.Stack[0].String()}, m.trace...),\n\t\tModuleName:      m.name,\n\t\tOutputTypeNames: outputNames,\n\t\tErr:             m.app.err,\n\t\tPrivate:         p.Private,\n\t})\n}\n\nfunc (m *module) supply(p provide) {\n\ttypeName := p.SupplyType.String()\n\topts := []dig.ProvideOption{\n\t\tdig.Export(!p.Private),\n\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\tm.log.LogEvent(&fxevent.Run{\n\t\t\t\tName:       fmt.Sprintf(\"stub(%v)\", typeName),\n\t\t\t\tKind:       \"supply\",\n\t\t\t\tRuntime:    ci.Runtime,\n\t\t\t\tModuleName: m.name,\n\t\t\t})\n\t\t}),\n\t}\n\n\tif err := runProvide(m.scope, p, opts...); err != nil {\n\t\tm.app.err = err\n\t}\n\n\tm.log.LogEvent(&fxevent.Supplied{\n\t\tTypeName:    typeName,\n\t\tStackTrace:  p.Stack.Strings(),\n\t\tModuleTrace: append([]string{p.Stack[0].String()}, m.trace...),\n\t\tModuleName:  m.name,\n\t\tErr:         m.app.err,\n\t})\n}\n\n// Constructs custom loggers for all modules in the tree\nfunc (m *module) installAllEventLoggers() {\n\tif m.logConstructor != nil {\n\t\tif buffer, ok := m.log.(*logBuffer); ok {\n\t\t\t// default to parent's logger if custom logger constructor fails\n\t\t\tif err := m.installEventLogger(buffer); err != nil {\n\t\t\t\tm.app.err = multierr.Append(m.app.err, err)\n\t\t\t\tm.log = m.fallbackLogger\n\t\t\t\tbuffer.Connect(m.log)\n\t\t\t}\n\t\t}\n\t\tm.fallbackLogger = nil\n\t} else if m.parent != nil {\n\t\tm.log = m.parent.log\n\t}\n\n\tfor _, mod := range m.modules {\n\t\tmod.installAllEventLoggers()\n\t}\n}\n\nfunc (m *module) installEventLogger(buffer *logBuffer) (err error) {\n\tp := m.logConstructor\n\tfname := fxreflect.FuncName(p.Target)\n\tdefer func() {\n\t\tm.log.LogEvent(&fxevent.LoggerInitialized{\n\t\t\tErr:             err,\n\t\t\tConstructorName: fname,\n\t\t})\n\t}()\n\n\t// TODO: Use dig.FillProvideInfo to inspect the provided constructor\n\t// and fail the application if its signature didn't match.\n\tif err := m.scope.Provide(p.Target); err != nil {\n\t\treturn fmt.Errorf(\"fx.WithLogger(%v) from:\\n%+v\\nin Module: %q\\nFailed: %w\",\n\t\t\tfname, p.Stack, m.name, err)\n\t}\n\n\treturn m.scope.Invoke(func(log fxevent.Logger) {\n\t\tm.log = log\n\t\tbuffer.Connect(log)\n\t})\n}\n\nfunc (m *module) invokeAll() error {\n\tfor _, m := range m.modules {\n\t\tif err := m.invokeAll(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, invoke := range m.invokes {\n\t\tif err := m.invoke(invoke); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *module) invoke(i invoke) (err error) {\n\tfnName := fxreflect.FuncName(i.Target)\n\tm.log.LogEvent(&fxevent.Invoking{\n\t\tFunctionName: fnName,\n\t\tModuleName:   m.name,\n\t})\n\terr = runInvoke(m.scope, i)\n\tm.log.LogEvent(&fxevent.Invoked{\n\t\tFunctionName: fnName,\n\t\tModuleName:   m.name,\n\t\tErr:          err,\n\t\tTrace:        fmt.Sprintf(\"%+v\", i.Stack), // format stack trace as multi-line\n\t})\n\treturn err\n}\n\nfunc (m *module) decorateAll() error {\n\tfor _, d := range m.decorators {\n\t\tif err := m.decorate(d); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, m := range m.modules {\n\t\tif err := m.decorateAll(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *module) decorate(d decorator) (err error) {\n\tif d.IsReplace {\n\t\treturn m.replace(d)\n\t}\n\n\tfuncName := fxreflect.FuncName(d.Target)\n\tvar info dig.DecorateInfo\n\topts := []dig.DecorateOption{\n\t\tdig.FillDecorateInfo(&info),\n\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\tm.log.LogEvent(&fxevent.Run{\n\t\t\t\tName:       funcName,\n\t\t\t\tKind:       \"decorate\",\n\t\t\t\tModuleName: m.name,\n\t\t\t\tRuntime:    ci.Runtime,\n\t\t\t\tErr:        ci.Error,\n\t\t\t})\n\t\t}),\n\t}\n\n\terr = runDecorator(m.scope, d, opts...)\n\toutputNames := make([]string, len(info.Outputs))\n\tfor i, o := range info.Outputs {\n\t\toutputNames[i] = o.String()\n\t}\n\n\tm.log.LogEvent(&fxevent.Decorated{\n\t\tDecoratorName:   funcName,\n\t\tStackTrace:      d.Stack.Strings(),\n\t\tModuleTrace:     append([]string{d.Stack[0].String()}, m.trace...),\n\t\tModuleName:      m.name,\n\t\tOutputTypeNames: outputNames,\n\t\tErr:             err,\n\t})\n\n\treturn err\n}\n\nfunc (m *module) replace(d decorator) error {\n\ttypeName := d.ReplaceType.String()\n\topts := []dig.DecorateOption{\n\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\tm.log.LogEvent(&fxevent.Run{\n\t\t\t\tName:       fmt.Sprintf(\"stub(%v)\", typeName),\n\t\t\t\tKind:       \"replace\",\n\t\t\t\tModuleName: m.name,\n\t\t\t\tRuntime:    ci.Runtime,\n\t\t\t\tErr:        ci.Error,\n\t\t\t})\n\t\t}),\n\t}\n\n\terr := runDecorator(m.scope, d, opts...)\n\tm.log.LogEvent(&fxevent.Replaced{\n\t\tModuleName:      m.name,\n\t\tStackTrace:      d.Stack.Strings(),\n\t\tModuleTrace:     append([]string{d.Stack[0].String()}, m.trace...),\n\t\tOutputTypeNames: []string{typeName},\n\t\tErr:             err,\n\t})\n\treturn err\n}\n"
        },
        {
          "name": "module_test.go",
          "type": "blob",
          "size": 16.7607421875,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"log\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/fxtest\"\n\t\"go.uber.org/fx/internal/fxlog\"\n\t\"go.uber.org/zap\"\n)\n\nfunc TestModuleSuccess(t *testing.T) {\n\tt.Parallel()\n\n\ttype Logger struct {\n\t\tName string\n\t}\n\n\ttype Foo struct {\n\t\tName string\n\t}\n\n\tt.Run(\"provide a dependency from a submodule\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tredis := fx.Module(\"redis\",\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"redis\"}\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tredis,\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"redis\", l.Name)\n\t\t\t}),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide a dependency from nested modules\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Module(\"grandchild\",\n\t\t\t\t\tfx.Provide(func() *Logger {\n\t\t\t\t\t\treturn &Logger{Name: \"redis\"}\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"redis\", l.Name)\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide a value to a soft group value from nested modules\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype Param struct {\n\t\t\tfx.In\n\n\t\t\tFoos []string `group:\"foo,soft\"`\n\t\t\tBar  int\n\t\t}\n\t\ttype Result struct {\n\t\t\tfx.Out\n\n\t\t\tFoo string `group:\"foo\"`\n\t\t\tBar int\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Module(\"grandchild\",\n\t\t\t\t\tfx.Provide(fx.Annotate(\n\t\t\t\t\t\tfunc() string {\n\t\t\t\t\t\t\trequire.FailNow(t, \"should not be called\")\n\t\t\t\t\t\t\treturn \"there\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfx.ResultTags(`group:\"foo\"`),\n\t\t\t\t\t)),\n\t\t\t\t\tfx.Provide(func() Result {\n\t\t\t\t\t\treturn Result{Foo: \"hello\", Bar: 10}\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(func(p Param) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"hello\"}, p.Foos)\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"invoke from nested module\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tinvokeRan := false\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{\n\t\t\t\t\tName: \"redis\",\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Module(\"grandchild\",\n\t\t\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\t\t\tassert.Equal(t, \"redis\", l.Name)\n\t\t\t\t\t\tinvokeRan = true\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\trequire.True(t, invokeRan)\n\t\trequire.NoError(t, app.Err())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"invoke in module with dep from top module\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tchild := fx.Module(\"child\",\n\t\t\tfx.Invoke(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"my logger\", l.Name)\n\t\t\t}),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tchild,\n\t\t\tfx.Provide(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"my logger\"}\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"provide in module with annotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tchild := fx.Module(\"child\",\n\t\t\tfx.Provide(fx.Annotate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"good logger\"}\n\t\t\t}, fx.ResultTags(`name:\"goodLogger\"`))),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tchild,\n\t\t\tfx.Invoke(fx.Annotate(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"good logger\", l.Name)\n\t\t\t}, fx.ParamTags(`name:\"goodLogger\"`))),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"invoke in module with annotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tranInvoke := false\n\t\tchild := fx.Module(\"child\",\n\t\t\t// use something provided by the root module.\n\t\t\tfx.Invoke(fx.Annotate(func(l *Logger) {\n\t\t\t\tassert.Equal(t, \"good logger\", l.Name)\n\t\t\t\tranInvoke = true\n\t\t\t})),\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tchild,\n\t\t\tfx.Provide(fx.Annotate(func() *Logger {\n\t\t\t\treturn &Logger{Name: \"good logger\"}\n\t\t\t})),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.True(t, ranInvoke)\n\t})\n\n\tt.Run(\"use Options in Module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topts := fx.Options(\n\t\t\tfx.Provide(fx.Annotate(func() string {\n\t\t\t\treturn \"dog\"\n\t\t\t}, fx.ResultTags(`group:\"pets\"`))),\n\t\t\tfx.Provide(fx.Annotate(func() string {\n\t\t\t\treturn \"cat\"\n\t\t\t}, fx.ResultTags(`group:\"pets\"`))),\n\t\t)\n\n\t\tpetModule := fx.Module(\"pets\", opts)\n\n\t\tapp := fxtest.New(t,\n\t\t\tpetModule,\n\t\t\tfx.Invoke(fx.Annotate(func(pets []string) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"dog\", \"cat\"}, pets)\n\t\t\t}, fx.ParamTags(`group:\"pets\"`))),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"Invoke order in Modules\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype person struct {\n\t\t\tage int\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *person {\n\t\t\t\treturn &person{\n\t\t\t\t\tage: 1,\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfx.Invoke(func(p *person) {\n\t\t\t\tassert.Equal(t, 2, p.age)\n\t\t\t\tp.age++\n\t\t\t}),\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Invoke(func(p *person) {\n\t\t\t\t\tassert.Equal(t, 1, p.age)\n\t\t\t\t\tp.age++\n\t\t\t\t}),\n\t\t\t),\n\t\t\tfx.Invoke(func(p *person) {\n\t\t\t\tassert.Equal(t, 3, p.age)\n\t\t\t}),\n\t\t)\n\t\trequire.NoError(t, app.Err())\n\t})\n\n\tt.Run(\"custom logger for module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttests := []struct {\n\t\t\tdesc           string\n\t\t\tgiveWithLogger fx.Option\n\t\t\twantEvents     []string\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc:           \"custom logger for module\",\n\t\t\t\tgiveWithLogger: fx.NopLogger,\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\",\n\t\t\t\t\t\"Run\", \"LoggerInitialized\", \"Invoking\", \"Invoked\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:           \"Not using a custom logger for module defaults to app logger\",\n\t\t\t\tgiveWithLogger: fx.Options(),\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Provided\", \"Run\",\n\t\t\t\t\t\"LoggerInitialized\", \"Invoking\", \"Run\", \"Invoked\", \"Invoking\", \"Invoked\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\ttt := tt\n\t\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\tvar spy fxlog.Spy\n\n\t\t\t\tredis := fx.Module(\"redis\",\n\t\t\t\t\tfx.Provide(func() *Foo {\n\t\t\t\t\t\treturn &Foo{Name: \"redis\"}\n\t\t\t\t\t}),\n\t\t\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\t\t\tassert.Equal(t, \"redis\", r.Name)\n\t\t\t\t\t}),\n\t\t\t\t\ttt.giveWithLogger,\n\t\t\t\t)\n\n\t\t\t\tapp := fxtest.New(t,\n\t\t\t\t\tredis,\n\t\t\t\t\tfx.Supply(&spy),\n\t\t\t\t\tfx.WithLogger(func(spy *fxlog.Spy) fxevent.Logger {\n\t\t\t\t\t\treturn spy\n\t\t\t\t\t}),\n\t\t\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\t\t\tassert.Equal(t, \"redis\", r.Name)\n\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t// events from module with a custom logger not logged in app logger\n\t\t\t\tassert.Equal(t, tt.wantEvents, spy.EventTypes())\n\n\t\t\t\tspy.Reset()\n\t\t\t\tapp.RequireStart().RequireStop()\n\n\t\t\t\trequire.NoError(t, app.Err())\n\n\t\t\t\tassert.Equal(t, []string{\"Started\", \"Stopped\"}, spy.EventTypes())\n\t\t\t})\n\t\t}\n\t})\n\n\ttype NamedSpy struct {\n\t\tfxlog.Spy\n\t\tname string\n\t}\n\n\tt.Run(\"decorator on module logger does not affect app logger\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tappSpy := NamedSpy{name: \"app\"}\n\t\tmoduleSpy := NamedSpy{name: \"redis\"}\n\n\t\tredis := fx.Module(\"redis\",\n\t\t\tfx.Provide(func() *Foo {\n\t\t\t\treturn &Foo{Name: \"redis\"}\n\t\t\t}),\n\t\t\tfx.Supply(&appSpy),\n\t\t\tfx.Replace(&moduleSpy),\n\t\t\tfx.WithLogger(func(spy *NamedSpy) fxevent.Logger {\n\t\t\t\tassert.Equal(t, \"redis\", spy.name)\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\tassert.Equal(t, \"redis\", r.Name)\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tredis,\n\t\t\tfx.WithLogger(func(spy *NamedSpy) fxevent.Logger {\n\t\t\t\tassert.Equal(t, \"app\", spy.name)\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\tassert.Equal(t, \"redis\", r.Name)\n\t\t\t}),\n\t\t)\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Supplied\", \"Replaced\", \"Run\", \"Run\",\n\t\t\t\"LoggerInitialized\", \"Invoking\", \"Run\", \"Invoked\",\n\t\t}, moduleSpy.EventTypes())\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Provided\", \"Provided\",\n\t\t\t\"LoggerInitialized\", \"Invoking\", \"Invoked\",\n\t\t}, appSpy.EventTypes())\n\n\t\tappSpy.Reset()\n\t\tmoduleSpy.Reset()\n\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NoError(t, app.Err())\n\n\t\tassert.Equal(t, []string{\"Started\", \"Stopped\"}, appSpy.EventTypes())\n\t\tassert.Empty(t, moduleSpy.EventTypes())\n\t})\n\n\tt.Run(\"module uses parent module's logger to log events\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tappSpy := NamedSpy{name: \"app\"}\n\t\tchildSpy := NamedSpy{name: \"child\"}\n\n\t\tgrandchild := fx.Module(\"grandchild\",\n\t\t\tfx.Provide(func() *Foo {\n\t\t\t\treturn &Foo{Name: \"grandchild\"}\n\t\t\t}),\n\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\tassert.Equal(t, \"grandchild\", r.Name)\n\t\t\t}),\n\t\t)\n\n\t\tchild := fx.Module(\"child\",\n\t\t\tgrandchild,\n\t\t\tfx.Supply(&appSpy),\n\t\t\tfx.Replace(&childSpy),\n\t\t\tfx.WithLogger(func(spy *NamedSpy) fxevent.Logger {\n\t\t\t\tassert.Equal(t, \"child\", spy.name)\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\tassert.Equal(t, \"grandchild\", r.Name)\n\t\t\t}),\n\t\t)\n\n\t\tapp := fxtest.New(t,\n\t\t\tchild,\n\t\t\tfx.WithLogger(func(spy *NamedSpy) fxevent.Logger {\n\t\t\t\tassert.Equal(t, \"app\", spy.name)\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t\tfx.Invoke(func(r *Foo) {\n\t\t\t\tassert.Equal(t, \"grandchild\", r.Name)\n\t\t\t}),\n\t\t)\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Supplied\", \"Provided\", \"Replaced\", \"Run\", \"Run\", \"LoggerInitialized\",\n\t\t\t// Invoke logged twice, once from child and another from grandchild\n\t\t\t\"Invoking\", \"Run\", \"Invoked\", \"Invoking\", \"Invoked\",\n\t\t}, childSpy.EventTypes(), \"events from grandchild also logged in child logger\")\n\n\t\tassert.Equal(t, []string{\n\t\t\t\"Provided\", \"Provided\", \"Provided\",\n\t\t\t\"LoggerInitialized\", \"Invoking\", \"Invoked\",\n\t\t}, appSpy.EventTypes(), \"events from modules do not appear in app logger\")\n\n\t\tappSpy.Reset()\n\t\tchildSpy.Reset()\n\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NoError(t, app.Err())\n\n\t\tassert.Equal(t, []string{\"Started\", \"Stopped\"}, appSpy.EventTypes())\n\t\tassert.Empty(t, childSpy.EventTypes())\n\t})\n}\n\nfunc TestModuleFailures(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"invoke from submodule failed\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tsub := fx.Module(\"sub\",\n\t\t\tfx.Provide(func() *A { return &A{} }),\n\t\t\tfx.Invoke(func(*A, *B) { // missing dependency.\n\t\t\t\trequire.Fail(t, \"this should not be called\")\n\t\t\t}),\n\t\t)\n\n\t\tapp := NewForTest(t,\n\t\t\tsub,\n\t\t\tfx.Invoke(func(a *A) {\n\t\t\t\tassert.NotNil(t, a)\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing type: *fx_test.B\")\n\t})\n\n\tt.Run(\"provide the same dependency from multiple modules\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Module(\"mod1\", fx.Provide(func() A { return A{} })),\n\t\t\tfx.Module(\"mod2\", fx.Provide(func() A { return A{} })),\n\t\t\tfx.Invoke(func(a A) {}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"already provided by \")\n\t})\n\n\tt.Run(\"providing Modules should fail\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := NewForTest(t,\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Provide(\n\t\t\t\t\tfx.Module(\"module\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"fx.Option should be passed to fx.New directly, not to fx.Provide\")\n\t})\n\n\tt.Run(\"invoking Modules should fail\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := NewForTest(t,\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Invoke(\n\t\t\t\t\tfx.Invoke(\"module\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"fx.Option should be passed to fx.New directly, not to fx.Invoke\")\n\t})\n\n\tt.Run(\"annotate failure in Module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\tnewA := func() A {\n\t\t\treturn A{}\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Provide(fx.Annotate(newA,\n\t\t\t\t\tfx.ParamTags(`name:\"A1\"`),\n\t\t\t\t\tfx.ParamTags(`name:\"A2\"`),\n\t\t\t\t)),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\n\t\tassert.Contains(t, err.Error(), \"encountered error while applying annotation\")\n\t\tassert.Contains(t, err.Error(), \"cannot apply more than one line of ParamTags\")\n\t})\n\n\tt.Run(\"soft provided to fx.Out struct\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Result struct {\n\t\t\tfx.Out\n\n\t\t\tBars []int `group:\"bar,soft\"`\n\t\t}\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() Result { return Result{Bars: []int{1, 2, 3}} }),\n\t\t)\n\t\terr := app.Err()\n\t\trequire.Error(t, err, \"failed to create app\")\n\t\tassert.Contains(t, err.Error(), \"cannot use soft with result value groups\")\n\t})\n\n\tt.Run(\"provider in Module fails\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tnewA := func() (A, error) {\n\t\t\treturn A{}, nil\n\t\t}\n\t\tnewB := func() (B, error) {\n\t\t\treturn B{}, errors.New(\"minor sadness\")\n\t\t}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Provide(\n\t\t\t\t\tnewA,\n\t\t\t\t\tnewB,\n\t\t\t\t),\n\t\t\t),\n\t\t\tfx.Invoke(func(A, B) {\n\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t}),\n\t\t)\n\n\t\terr := app.Err()\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"failed to build fx_test.B\")\n\t\tassert.Contains(t, err.Error(), \"minor sadness\")\n\t})\n\n\tt.Run(\"invalid Options in Module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttests := []struct {\n\t\t\tdesc string\n\t\t\topt  fx.Option\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc: \"StartTimeout Option\",\n\t\t\t\topt:  fx.StartTimeout(time.Second),\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc: \"StopTimeout Option\",\n\t\t\t\topt:  fx.StopTimeout(time.Second),\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc: \"Logger Option\",\n\t\t\t\topt:  fx.Logger(log.New(&bytes.Buffer{}, \"\", 0)),\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\ttt := tt\n\t\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tapp := NewForTest(t,\n\t\t\t\t\tfx.Module(\"module\",\n\t\t\t\t\t\ttt.opt,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\trequire.Error(t, app.Err())\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid WithLogger in Module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar spy fxlog.Spy\n\n\t\tspyAsLogger := fx.Options(\n\t\t\tfx.Supply(&spy),\n\t\t\tfx.WithLogger(func(spy *fxlog.Spy) fxevent.Logger {\n\t\t\t\treturn spy\n\t\t\t}),\n\t\t)\n\n\t\tdefaultModuleOpts := fx.Options(\n\t\t\tfx.Provide(func() string {\n\t\t\t\treturn \"redis\"\n\t\t\t}),\n\t\t\tfx.Invoke(func(s string) {\n\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t}),\n\t\t)\n\n\t\ttests := []struct {\n\t\t\tdesc            string\n\t\t\tgiveModuleOpts  fx.Option\n\t\t\tgiveAppOpts     fx.Option\n\t\t\twantErrContains []string\n\t\t\twantEvents      []string\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc:           \"error in Provide shows logs in module\",\n\t\t\t\tgiveModuleOpts: fx.Options(spyAsLogger, fx.Provide(&bytes.Buffer{})), // not passing in a constructor\n\t\t\t\tgiveAppOpts:    fx.Options(),\n\t\t\t\twantErrContains: []string{\n\t\t\t\t\t\"must provide constructor function, got  (type *bytes.Buffer)\",\n\t\t\t\t},\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Supplied\", \"Provided\", \"Run\", \"LoggerInitialized\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc: \"logger in module failed to build\",\n\t\t\t\tgiveModuleOpts: fx.WithLogger(func() (fxevent.Logger, error) {\n\t\t\t\t\treturn nil, errors.New(\"error building logger\")\n\t\t\t\t}),\n\t\t\t\tgiveAppOpts:     spyAsLogger,\n\t\t\t\twantErrContains: []string{\"error building logger\"},\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Run\",\n\t\t\t\t\t\"LoggerInitialized\", \"Provided\", \"LoggerInitialized\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc: \"logger dependency in module failed to build\",\n\t\t\t\tgiveModuleOpts: fx.Options(\n\t\t\t\t\tfx.Provide(func() (*zap.Logger, error) {\n\t\t\t\t\t\treturn nil, errors.New(\"error building logger dependency\")\n\t\t\t\t\t}),\n\t\t\t\t\tfx.WithLogger(func(log *zap.Logger) fxevent.Logger {\n\t\t\t\t\t\tt.Errorf(\"WithLogger must not be called\")\n\t\t\t\t\t\tpanic(\"must not be called\")\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\tgiveAppOpts:     spyAsLogger,\n\t\t\t\twantErrContains: []string{\"error building logger dependency\"},\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Run\",\n\t\t\t\t\t\"LoggerInitialized\", \"Provided\", \"Provided\", \"Run\", \"LoggerInitialized\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:           \"Invalid input for WithLogger\",\n\t\t\t\tgiveModuleOpts: fx.WithLogger(&fxlog.Spy{}), // not passing in a constructor for WithLogger\n\t\t\t\tgiveAppOpts:    spyAsLogger,\n\t\t\t\twantErrContains: []string{\n\t\t\t\t\t\"fx.WithLogger\", \"from:\", \"Failed\",\n\t\t\t\t},\n\t\t\t\twantEvents: []string{\n\t\t\t\t\t\"Provided\", \"Provided\", \"Provided\", \"Supplied\", \"Run\",\n\t\t\t\t\t\"LoggerInitialized\", \"Provided\", \"LoggerInitialized\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tspy.Reset()\n\t\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t\tredis := fx.Module(\"redis\",\n\t\t\t\t\ttt.giveModuleOpts,\n\t\t\t\t\tdefaultModuleOpts,\n\t\t\t\t)\n\n\t\t\t\tapp := fx.New(\n\t\t\t\t\ttt.giveAppOpts,\n\t\t\t\t\tredis,\n\t\t\t\t\tfx.Invoke(func(s string) {\n\t\t\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\terr := app.Err()\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tfor _, contains := range tt.wantErrContains {\n\t\t\t\t\tassert.Contains(t, err.Error(), contains)\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t,\n\t\t\t\t\ttt.wantEvents,\n\t\t\t\t\tspy.EventTypes(),\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "populate.go",
          "type": "blob",
          "size": 3.4296875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Populate sets targets with values from the dependency injection container\n// during application initialization. All targets must be pointers to the\n// values that must be populated. Pointers to structs that embed In are\n// supported, which can be used to populate multiple values in a struct.\n//\n// Annotating each pointer with ParamTags is also supported as a shorthand\n// to passing a pointer to a struct that embeds In with field tags. For example:\n//\n//\t var a A\n//\t var b B\n//\t fx.Populate(\n//\t\tfx.Annotate(\n//\t\t\t\t&a,\n//\t\t\t\tfx.ParamTags(`name:\"A\"`)\n//\t \t),\n//\t\tfx.Annotate(\n//\t\t\t\t&b,\n//\t\t\t\tfx.ParamTags(`name:\"B\"`)\n//\t \t)\n//\t )\n//\n// Code above is equivalent to the following:\n//\n//\ttype Target struct {\n//\t\tfx.In\n//\n//\t\ta A `name:\"A\"`\n//\t\tb B `name:\"B\"`\n//\t}\n//\tvar target Target\n//\t...\n//\tfx.Populate(&target)\n//\n// This is most helpful in unit tests: it lets tests leverage Fx's automatic\n// constructor wiring to build a few structs, but then extract those structs\n// for further testing.\nfunc Populate(targets ...interface{}) Option {\n\t// Validate all targets are non-nil pointers.\n\tfields := make([]reflect.StructField, len(targets)+1)\n\tfields[0] = reflect.StructField{\n\t\tName:      \"In\",\n\t\tType:      reflect.TypeOf(In{}),\n\t\tAnonymous: true,\n\t}\n\tfor i, t := range targets {\n\t\tif t == nil {\n\t\t\treturn Error(fmt.Errorf(\"failed to Populate: target %v is nil\", i+1))\n\t\t}\n\t\tvar (\n\t\t\trt  reflect.Type\n\t\t\ttag reflect.StructTag\n\t\t)\n\t\tswitch t := t.(type) {\n\t\tcase annotated:\n\t\t\trt = reflect.TypeOf(t.Target)\n\t\t\ttag = reflect.StructTag(t.ParamTags[0])\n\t\t\ttargets[i] = t.Target\n\t\tdefault:\n\t\t\trt = reflect.TypeOf(t)\n\t\t}\n\t\tif rt.Kind() != reflect.Ptr {\n\t\t\treturn Error(fmt.Errorf(\"failed to Populate: target %v is not a pointer type, got %T\", i+1, t))\n\t\t}\n\t\tfields[i+1] = reflect.StructField{\n\t\t\tName: fmt.Sprintf(\"Field%d\", i),\n\t\t\tType: rt.Elem(),\n\t\t\tTag:  tag,\n\t\t}\n\t}\n\n\t// Build a function that looks like:\n\t//\n\t// func(t1 T1, t2 T2, ...) {\n\t//   *targets[0] = t1\n\t//   *targets[1] = t2\n\t//   [...]\n\t// }\n\t//\n\tfnType := reflect.FuncOf([]reflect.Type{reflect.StructOf(fields)}, nil, false /* variadic */)\n\tfn := reflect.MakeFunc(fnType, func(args []reflect.Value) []reflect.Value {\n\t\targ := args[0]\n\t\tfor i, target := range targets {\n\t\t\treflect.ValueOf(target).Elem().Set(arg.Field(i + 1))\n\t\t}\n\t\treturn nil\n\t})\n\treturn Invoke(fn.Interface())\n}\n"
        },
        {
          "name": "populate_example_test.go",
          "type": "blob",
          "size": 1.841796875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"go.uber.org/fx\"\n)\n\nfunc ExamplePopulate() {\n\t// Some external module that provides a user name.\n\ttype Username string\n\tUserModule := fx.Provide(func() Username { return \"john\" })\n\n\t// We want to use Fx to wire up our constructors, but don't actually want to\n\t// run the application - we just want to yank out the user name.\n\t//\n\t// This is common in unit tests, and is even easier with the fxtest\n\t// package's RequireStart and RequireStop helpers.\n\tvar user Username\n\tapp := fx.New(\n\t\tUserModule,\n\t\tfx.NopLogger, // silence test output\n\t\tfx.Populate(&user),\n\t)\n\tif err := app.Start(context.Background()); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer app.Stop(context.Background())\n\n\tfmt.Println(user)\n\n\t// Output:\n\t// john\n}\n"
        },
        {
          "name": "populate_test.go",
          "type": "blob",
          "size": 8.494140625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t. \"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestPopulate(t *testing.T) {\n\tt.Parallel()\n\n\t// We make sure t1 has a size so when we compare pointers, 2 different\n\t// objects are not equal.\n\ttype t1 struct {\n\t\tbuf [1024]byte\n\t}\n\ttype t2 struct{}\n\n\t_ = new(t1).buf // buf is unused\n\n\tt.Run(\"populate nothing\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() *t1 { panic(\"should not be called \") }),\n\t\t\tPopulate(),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"populate single\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar v1 *t1\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() *t1 { return &t1{} }),\n\t\t\tPopulate(&v1),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\t\trequire.NotNil(t, v1, \"did not populate value\")\n\t})\n\n\tt.Run(\"populate interface\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar reader io.Reader\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() io.Reader { return strings.NewReader(\"hello world\") }),\n\t\t\tPopulate(&reader),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\tbs, err := io.ReadAll(reader)\n\t\trequire.NoError(t, err, \"Failed to use populated io.Reader\")\n\t\tassert.Equal(t, \"hello world\", string(bs), \"Unexpected reader\")\n\t})\n\n\tt.Run(\"populate multiple inline values\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar (\n\t\t\tv1 *t1\n\t\t\tv2 *t2\n\t\t)\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() *t1 { return &t1{} }),\n\t\t\tProvide(func() *t2 { return &t2{} }),\n\n\t\t\tPopulate(&v1),\n\t\t\tPopulate(&v2),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NotNil(t, v1, \"did not populate argument 1\")\n\t\trequire.NotNil(t, v2, \"did not populate argument 2\")\n\t})\n\n\tt.Run(\"populate fx.In struct\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttargets := struct {\n\t\t\tIn\n\n\t\t\tV1 *t1\n\t\t\tV2 *t2\n\t\t}{}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() *t1 { return &t1{} }),\n\t\t\tProvide(func() *t2 { return &t2{} }),\n\n\t\t\tPopulate(&targets),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NotNil(t, targets.V1, \"did not populate field 1\")\n\t\trequire.NotNil(t, targets.V2, \"did not populate field 2\")\n\t})\n\n\tt.Run(\"populate named field\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype result struct {\n\t\t\tOut\n\n\t\t\tV1 *t1 `name:\"n1\"`\n\t\t\tV2 *t1 `name:\"n2\"`\n\t\t}\n\n\t\ttargets := struct {\n\t\t\tIn\n\n\t\t\tV1 *t1 `name:\"n1\"`\n\t\t\tV2 *t1 `name:\"n2\"`\n\t\t}{}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() result {\n\t\t\t\treturn result{\n\t\t\t\t\tV1: &t1{},\n\t\t\t\t\tV2: &t1{},\n\t\t\t\t}\n\t\t\t}),\n\n\t\t\tPopulate(&targets),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NotNil(t, targets.V1, \"did not populate field 1\")\n\t\trequire.NotNil(t, targets.V2, \"did not populate field 2\")\n\t\t// Cannot use assert.Equal here as we want to compare pointers.\n\t\tassert.False(t, targets.V1 == targets.V2, \"fields should be different\")\n\t})\n\n\tt.Run(\"annotated populate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype result struct {\n\t\t\tOut\n\n\t\t\tV1 *t1 `name:\"n1\"`\n\t\t\tV2 *t1 `name:\"n2\"`\n\t\t}\n\t\tvar v1, v2 *t1\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() result {\n\t\t\t\treturn result{\n\t\t\t\t\tV1: &t1{},\n\t\t\t\t\tV2: &t1{},\n\t\t\t\t}\n\t\t\t}),\n\t\t\tPopulate(\n\t\t\t\tAnnotate(\n\t\t\t\t\t&v1,\n\t\t\t\t\tParamTags(`name:\"n1\"`),\n\t\t\t\t),\n\t\t\t\tAnnotate(\n\t\t\t\t\t&v2,\n\t\t\t\t\tParamTags(`name:\"n2\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NotNil(t, v1, \"did not populate argument 1\")\n\t\trequire.NotNil(t, v2, \"did not populate argument 2\")\n\t\t// Cannot use assert.Equal here as we want to compare pointers.\n\t\tassert.False(t, v1 == v2, \"values should be different\")\n\t})\n\n\tt.Run(\"annotated populate with annotated provide\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar v1, v2 *t1\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(\n\t\t\t\tAnnotate(\n\t\t\t\t\tfunc() (*t1, *t1) {\n\t\t\t\t\t\treturn &t1{}, &t1{}\n\t\t\t\t\t},\n\t\t\t\t\tResultTags(`name:\"n1\"`, `name:\"n2\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t\tPopulate(\n\t\t\t\tAnnotate(\n\t\t\t\t\t&v1,\n\t\t\t\t\tParamTags(`name:\"n1\"`),\n\t\t\t\t),\n\t\t\t\tAnnotate(\n\t\t\t\t\t&v2,\n\t\t\t\t\tParamTags(`name:\"n2\"`),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.NotNil(t, v1, \"did not populate argument 1\")\n\t\trequire.NotNil(t, v2, \"did not populate argument 2\")\n\t\t// Cannot use assert.Equal here as we want to compare pointers.\n\t\tassert.False(t, v1 == v2, \"values should be different\")\n\t})\n\n\tt.Run(\"populate group\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype result struct {\n\t\t\tOut\n\n\t\t\tV1 *t1 `group:\"g\"`\n\t\t\tV2 *t1 `group:\"g\"`\n\t\t}\n\n\t\ttargets := struct {\n\t\t\tIn\n\n\t\t\tGroup []*t1 `group:\"g\"`\n\t\t}{}\n\n\t\tapp := fxtest.New(t,\n\t\t\tProvide(func() result {\n\t\t\t\treturn result{\n\t\t\t\t\tV1: &t1{},\n\t\t\t\t\tV2: &t1{},\n\t\t\t\t}\n\t\t\t}),\n\n\t\t\tPopulate(&targets),\n\t\t)\n\t\tapp.RequireStart().RequireStop()\n\n\t\trequire.Len(t, targets.Group, 2, \"Expected group to have 2 values\")\n\t\trequire.NotNil(t, targets.Group[0], \"did not populate group value 1\")\n\t\trequire.NotNil(t, targets.Group[1], \"did not populate group value 2\")\n\t\t// Cannot use assert.Equal here as we want to compare pointers.\n\t\tassert.False(t, targets.Group[0] == targets.Group[1], \"group values should be different\")\n\t})\n}\n\nfunc TestPopulateErrors(t *testing.T) {\n\tt.Parallel()\n\n\ttype t1 struct{}\n\ttype container struct {\n\t\tIn\n\n\t\tT1 t1\n\t}\n\ttype containerNoIn struct {\n\t\tT1 t1\n\t}\n\tfn := func() {}\n\tvar v *t1\n\n\ttests := []struct {\n\t\tmsg     string\n\t\topt     Option\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tmsg:     \"inline value\",\n\t\t\topt:     Populate(t1{}),\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"container value\",\n\t\t\topt:     Populate(container{}),\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"container pointer without fx.In\",\n\t\t\topt:     Populate(&containerNoIn{}),\n\t\t\twantErr: \"missing type: fx_test.containerNoIn\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"function\",\n\t\t\topt:     Populate(fn),\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"function pointer\",\n\t\t\topt:     Populate(&fn),\n\t\t\twantErr: \"missing type: func()\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"invalid last argument\",\n\t\t\topt:     Populate(&v, t1{}),\n\t\t\twantErr: \"target 2 is not a pointer type\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"nil argument\",\n\t\t\topt:     Populate(&v, nil, &v),\n\t\t\twantErr: \"target 2 is nil\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tapp := NewForTest(t,\n\t\t\tNopLogger,\n\t\t\tProvide(func() *t1 { return &t1{} }),\n\n\t\t\ttt.opt,\n\t\t)\n\t\trequire.Error(t, app.Err())\n\t\tassert.Contains(t, app.Err().Error(), tt.wantErr)\n\t}\n}\n\nfunc TestPopulateValidateApp(t *testing.T) {\n\tt.Parallel()\n\n\ttype t1 struct{}\n\ttype container struct {\n\t\tIn\n\n\t\tT1 t1\n\t}\n\ttype containerNoIn struct {\n\t\tT1 t1\n\t}\n\tfn := func() {}\n\tvar v *t1\n\n\ttests := []struct {\n\t\tmsg     string\n\t\topts    []interface{}\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tmsg:     \"inline value\",\n\t\t\topts:    []interface{}{t1{}},\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"container value\",\n\t\t\topts:    []interface{}{container{}},\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"container pointer without fx.In\",\n\t\t\topts:    []interface{}{&containerNoIn{}},\n\t\t\twantErr: \"missing type: fx_test.containerNoIn\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"function\",\n\t\t\topts:    []interface{}{fn},\n\t\t\twantErr: \"not a pointer\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"function pointer\",\n\t\t\topts:    []interface{}{&fn},\n\t\t\twantErr: \"missing type: func()\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"invalid last argument\",\n\t\t\topts:    []interface{}{&v, t1{}},\n\t\t\twantErr: \"target 2 is not a pointer type\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"nil argument\",\n\t\t\topts:    []interface{}{&v, nil, &v},\n\t\t\twantErr: \"target 2 is nil\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttestOpts := []Option{\n\t\t\t\tNopLogger,\n\t\t\t\tProvide(func() *t1 { return &t1{} }),\n\t\t\t\tPopulate(tt.opts...),\n\t\t\t}\n\n\t\t\terr := validateTestApp(t, testOpts...)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), tt.wantErr)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "printer_writer.go",
          "type": "blob",
          "size": 1.4697265625,
          "content": "// Copyright (c) 2020-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport \"io\"\n\ntype printerWriter struct{ p Printer }\n\n// writerFromPrinter returns an implementation of io.Writer used to support\n// Logger option which implements Printer interface.\nfunc writerFromPrinter(p Printer) io.Writer {\n\treturn &printerWriter{p: p}\n}\n\nfunc (w *printerWriter) Write(b []byte) (n int, err error) {\n\tw.p.Printf(string(b))\n\treturn len(b), nil\n}\n"
        },
        {
          "name": "provide.go",
          "type": "blob",
          "size": 6.298828125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Provide registers any number of constructor functions, teaching the\n// application how to instantiate various types. The supplied constructor\n// function(s) may depend on other types available in the application, must\n// return one or more objects, and may return an error. For example:\n//\n//\t// Constructs type *C, depends on *A and *B.\n//\tfunc(*A, *B) *C\n//\n//\t// Constructs type *C, depends on *A and *B, and indicates failure by\n//\t// returning an error.\n//\tfunc(*A, *B) (*C, error)\n//\n//\t// Constructs types *B and *C, depends on *A, and can fail.\n//\tfunc(*A) (*B, *C, error)\n//\n// The order in which constructors are provided doesn't matter, and passing\n// multiple Provide options appends to the application's collection of\n// constructors. Constructors are called only if one or more of their returned\n// types are needed, and their results are cached for reuse (so instances of a\n// type are effectively singletons within an application). Taken together,\n// these properties make it perfectly reasonable to Provide a large number of\n// constructors even if only a fraction of them are used.\n//\n// See the documentation of the In and Out types for advanced features,\n// including optional parameters and named instances.\n//\n// See the documentation for [Private] for restricting access to constructors.\n//\n// Constructor functions should perform as little external interaction as\n// possible, and should avoid spawning goroutines. Things like server listen\n// loops, background timer loops, and background processing goroutines should\n// instead be managed using Lifecycle callbacks.\nfunc Provide(constructors ...interface{}) Option {\n\treturn provideOption{\n\t\tTargets: constructors,\n\t\tStack:   fxreflect.CallerStack(1, 0),\n\t}\n}\n\ntype provideOption struct {\n\tTargets []interface{}\n\tStack   fxreflect.Stack\n}\n\nfunc (o provideOption) apply(mod *module) {\n\tvar private bool\n\n\ttargets := make([]interface{}, 0, len(o.Targets))\n\tfor _, target := range o.Targets {\n\t\tif _, ok := target.(privateOption); ok {\n\t\t\tprivate = true\n\t\t\tcontinue\n\t\t}\n\t\ttargets = append(targets, target)\n\t}\n\n\tfor _, target := range targets {\n\t\tmod.provides = append(mod.provides, provide{\n\t\t\tTarget:  target,\n\t\t\tStack:   o.Stack,\n\t\t\tPrivate: private,\n\t\t})\n\t}\n}\n\ntype privateOption struct{}\n\n// Private is an option that can be passed as an argument to [Provide] or [Supply] to\n// restrict access to the constructors being provided. Specifically,\n// corresponding constructors can only be used within the current module\n// or modules the current module contains. Other modules that contain this\n// module won't be able to use the constructor.\n//\n// For example, the following would fail because the app doesn't have access\n// to the inner module's constructor.\n//\n//\tfx.New(\n//\t\tfx.Module(\"SubModule\", fx.Provide(func() int { return 0 }, fx.Private)),\n//\t\tfx.Invoke(func(a int) {}),\n//\t)\nvar Private = privateOption{}\n\nfunc (o provideOption) String() string {\n\titems := make([]string, len(o.Targets))\n\tfor i, c := range o.Targets {\n\t\titems[i] = fxreflect.FuncName(c)\n\t}\n\treturn fmt.Sprintf(\"fx.Provide(%s)\", strings.Join(items, \", \"))\n}\n\nfunc runProvide(c container, p provide, opts ...dig.ProvideOption) error {\n\tconstructor := p.Target\n\tif _, ok := constructor.(Option); ok {\n\t\treturn fmt.Errorf(\"fx.Option should be passed to fx.New directly, \"+\n\t\t\t\"not to fx.Provide: fx.Provide received %v from:\\n%+v\",\n\t\t\tconstructor, p.Stack)\n\t}\n\n\tswitch constructor := constructor.(type) {\n\tcase annotationError:\n\t\t// fx.Annotate failed. Turn it into an Fx error.\n\t\treturn fmt.Errorf(\n\t\t\t\"encountered error while applying annotation using fx.Annotate to %s: %w\",\n\t\t\tfxreflect.FuncName(constructor.target), constructor.err)\n\n\tcase annotated:\n\t\tctor, err := constructor.Build()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"fx.Provide(%v) from:\\n%+vFailed: %w\", constructor, p.Stack, err)\n\t\t}\n\n\t\topts = append(opts, dig.LocationForPC(constructor.FuncPtr))\n\t\tif err := c.Provide(ctor, opts...); err != nil {\n\t\t\treturn fmt.Errorf(\"fx.Provide(%v) from:\\n%+vFailed: %w\", constructor, p.Stack, err)\n\t\t}\n\n\tcase Annotated:\n\t\tann := constructor\n\t\tswitch {\n\t\tcase len(ann.Group) > 0 && len(ann.Name) > 0:\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"fx.Annotated may specify only one of Name or Group: received %v from:\\n%+v\",\n\t\t\t\tann, p.Stack)\n\t\tcase len(ann.Name) > 0:\n\t\t\topts = append(opts, dig.Name(ann.Name))\n\t\tcase len(ann.Group) > 0:\n\t\t\topts = append(opts, dig.Group(ann.Group))\n\t\t}\n\n\t\tif err := c.Provide(ann.Target, opts...); err != nil {\n\t\t\treturn fmt.Errorf(\"fx.Provide(%v) from:\\n%+vFailed: %w\", ann, p.Stack, err)\n\t\t}\n\n\tdefault:\n\t\tif reflect.TypeOf(constructor).Kind() == reflect.Func {\n\t\t\tft := reflect.ValueOf(constructor).Type()\n\n\t\t\tfor i := 0; i < ft.NumOut(); i++ {\n\t\t\t\tt := ft.Out(i)\n\n\t\t\t\tif t == reflect.TypeOf(Annotated{}) {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"fx.Annotated should be passed to fx.Provide directly, \"+\n\t\t\t\t\t\t\t\"it should not be returned by the constructor: \"+\n\t\t\t\t\t\t\t\"fx.Provide received %v from:\\n%+v\",\n\t\t\t\t\t\tfxreflect.FuncName(constructor), p.Stack)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := c.Provide(constructor, opts...); err != nil {\n\t\t\treturn fmt.Errorf(\"fx.Provide(%v) from:\\n%+vFailed: %w\", fxreflect.FuncName(constructor), p.Stack, err)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "replace.go",
          "type": "blob",
          "size": 4.2412109375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Replace provides instantiated values for graph modification as if\n// they had been provided using a decorator with fx.Decorate.\n// The most specific type of each value (as determined by reflection) is used.\n//\n// Refer to the documentation on fx.Decorate to see how graph modifications\n// work with fx.Module.\n//\n// This serves a purpose similar to what fx.Supply does for fx.Provide.\n//\n// For example, given,\n//\n//\tvar log *zap.Logger = ...\n//\n// The following two forms are equivalent.\n//\n//\tfx.Replace(log)\n//\n//\tfx.Decorate(\n//\t\tfunc() *zap.Logger {\n//\t\t\treturn log\n//\t\t},\n//\t)\n//\n// Replace panics if a value (or annotation target) is an untyped nil or an error.\n//\n// # Replace Caveats\n//\n// As mentioned above, Replace uses the most specific type of the provided\n// value. For interface values, this refers to the type of the implementation,\n// not the interface. So if you try to replace an io.Writer, fx.Replace will\n// use the type of the implementation.\n//\n//\tvar stderr io.Writer = os.Stderr\n//\tfx.Replace(stderr)\n//\n// Is equivalent to,\n//\n//\tfx.Decorate(func() *os.File { return os.Stderr })\n//\n// This is typically NOT what you intended. To replace the io.Writer in the\n// container with the value above, we need to use the fx.Annotate function with\n// the fx.As annotation.\n//\n//\tfx.Replace(\n//\t\tfx.Annotate(os.Stderr, fx.As(new(io.Writer)))\n//\t)\nfunc Replace(values ...interface{}) Option {\n\tdecorators := make([]interface{}, len(values)) // one function per value\n\ttypes := make([]reflect.Type, len(values))\n\tfor i, value := range values {\n\t\tswitch value := value.(type) {\n\t\tcase annotated:\n\t\t\tvar typ reflect.Type\n\t\t\tvalue.Target, typ = newReplaceDecorator(value.Target)\n\t\t\tdecorators[i] = value\n\t\t\ttypes[i] = typ\n\t\tdefault:\n\t\t\tdecorators[i], types[i] = newReplaceDecorator(value)\n\t\t}\n\t}\n\n\treturn replaceOption{\n\t\tTargets: decorators,\n\t\tTypes:   types,\n\t\tStack:   fxreflect.CallerStack(1, 0),\n\t}\n}\n\ntype replaceOption struct {\n\tTargets []interface{}\n\tTypes   []reflect.Type // type of value produced by constructor[i]\n\tStack   fxreflect.Stack\n}\n\nfunc (o replaceOption) apply(m *module) {\n\tfor i, target := range o.Targets {\n\t\tm.decorators = append(m.decorators, decorator{\n\t\t\tTarget:      target,\n\t\t\tStack:       o.Stack,\n\t\t\tIsReplace:   true,\n\t\t\tReplaceType: o.Types[i],\n\t\t})\n\t}\n}\n\nfunc (o replaceOption) String() string {\n\titems := make([]string, 0, len(o.Targets))\n\tfor _, typ := range o.Types {\n\t\titems = append(items, typ.String())\n\t}\n\treturn fmt.Sprintf(\"fx.Replace(%s)\", strings.Join(items, \", \"))\n}\n\n// Returns a function that takes no parameters, and returns the given value.\nfunc newReplaceDecorator(value interface{}) (interface{}, reflect.Type) {\n\tswitch value.(type) {\n\tcase nil:\n\t\tpanic(\"untyped nil passed to fx.Replace\")\n\tcase error:\n\t\tpanic(\"error value passed to fx.Replace\")\n\t}\n\n\ttyp := reflect.TypeOf(value)\n\treturnTypes := []reflect.Type{typ}\n\treturnValues := []reflect.Value{reflect.ValueOf(value)}\n\n\tft := reflect.FuncOf([]reflect.Type{}, returnTypes, false)\n\tfv := reflect.MakeFunc(ft, func([]reflect.Value) []reflect.Value {\n\t\treturn returnValues\n\t})\n\n\treturn fv.Interface(), typ\n}\n"
        },
        {
          "name": "replace_test.go",
          "type": "blob",
          "size": 4.798828125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestReplaceSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"replace a value\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tValue string\n\t\t}\n\t\ta := &A{Value: \"a'\"}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Provide(func() *A {\n\t\t\t\treturn &A{\n\t\t\t\t\tValue: \"a\",\n\t\t\t\t}\n\t\t\t}),\n\t\t\tfx.Replace(a),\n\t\t\tfx.Invoke(func(a *A) {\n\t\t\t\tassert.Equal(t, \"a'\", a.Value)\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"replace in a module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tValue string\n\t\t}\n\n\t\ta := &A{Value: \"A\"}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Replace(a),\n\t\t\t\tfx.Invoke(func(a *A) {\n\t\t\t\t\tassert.Equal(t, \"A\", a.Value)\n\t\t\t\t}),\n\t\t\t),\n\t\t\tfx.Provide(func() *A {\n\t\t\t\treturn &A{\n\t\t\t\t\tValue: \"a\",\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"replace with annotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tValue string\n\t\t}\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotate(A{\"A\"}, fx.ResultTags(`name:\"t\"`)),\n\t\t\t),\n\t\t\tfx.Replace(\n\t\t\t\tfx.Annotate(A{\"B\"}, fx.ResultTags(`name:\"t\"`)),\n\t\t\t),\n\t\t\tfx.Invoke(fx.Annotate(func(a A) {\n\t\t\t\tassert.Equal(t, a.Value, \"B\")\n\t\t\t}, fx.ParamTags(`name:\"t\"`))),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"replace a value group with annotate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotate([]string{\"A\", \"B\", \"C\"}, fx.ResultTags(`group:\"t,flatten\"`)),\n\t\t\t),\n\t\t\tfx.Replace(fx.Annotate([]string{\"a\", \"b\", \"c\"}, fx.ResultTags(`group:\"t\"`))),\n\t\t\tfx.Invoke(fx.Annotate(func(ss ...string) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"a\", \"b\", \"c\"}, ss)\n\t\t\t}, fx.ParamTags(`group:\"t\"`))),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"replace a value group supplied by a child module from root module\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfoo := fx.Module(\"foo\",\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotate([]string{\"a\", \"b\", \"c\"}, fx.ResultTags(`group:\"t,flatten\"`)),\n\t\t\t),\n\t\t)\n\n\t\tfxtest.New(t,\n\t\t\tfx.Module(\"wrapfoo\",\n\t\t\t\tfoo,\n\t\t\t\tfx.Replace(\n\t\t\t\t\tfx.Annotate([]string{\"d\", \"e\", \"f\"}, fx.ResultTags(`group:\"t\"`)),\n\t\t\t\t),\n\t\t\t\tfx.Invoke(fx.Annotate(func(ss []string) {\n\t\t\t\t\tassert.ElementsMatch(t, []string{\"d\", \"e\", \"f\"}, ss)\n\t\t\t\t}, fx.ParamTags(`group:\"t\"`))),\n\t\t\t),\n\t\t)\n\t})\n}\n\nfunc TestReplaceFailure(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"replace same value twice\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tValue string\n\t\t}\n\t\ta := &A{Value: \"A\"}\n\t\tapp := NewForTest(t,\n\t\t\tfx.Provide(func() *A {\n\t\t\t\treturn &A{Value: \"a\"}\n\t\t\t}),\n\t\t\tfx.Module(\"child\",\n\t\t\t\tfx.Replace(a),\n\t\t\t\tfx.Replace(a),\n\t\t\t\tfx.Invoke(func(a *A) {\n\t\t\t\t\tassert.Fail(t, \"this should never run\")\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\terr := app.Err()\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"*fx_test.A already decorated\")\n\t})\n\n\tt.Run(\"replace a value that wasn't provided\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\n\t\tapp := NewForTest(t,\n\t\t\tfx.Replace(A{}),\n\t\t\tfx.Invoke(func(a *A) {\n\t\t\t}),\n\t\t)\n\t\terr := app.Err()\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing type: *fx_test.A\")\n\t})\n\n\tt.Run(\"replace panics on invalid values\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\trequire.PanicsWithValuef(\n\t\t\tt,\n\t\t\t\"untyped nil passed to fx.Replace\",\n\t\t\tfunc() { fx.Replace(A{}, nil) },\n\t\t\t\"a naked nil should panic\",\n\t\t)\n\n\t\trequire.PanicsWithValuef(\n\t\t\tt,\n\t\t\t\"error value passed to fx.Replace\",\n\t\t\tfunc() { fx.Replace(A{}, errors.New(\"some error\")) },\n\t\t\t\"replacing with an error should panic\",\n\t\t)\n\n\t\trequire.NotPanicsf(\n\t\t\tt,\n\t\t\tfunc() { fx.Replace(A{}, (*B)(nil)) },\n\t\t\t\"a wrapped nil should not panic\")\n\t})\n}\n"
        },
        {
          "name": "shutdown.go",
          "type": "blob",
          "size": 3.1611328125,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"time\"\n)\n\n// Shutdowner provides a method that can manually trigger the shutdown of the\n// application by sending a signal to all open Done channels. Shutdowner works\n// on applications using Run as well as Start, Done, and Stop. The Shutdowner is\n// provided to all Fx applications.\ntype Shutdowner interface {\n\tShutdown(...ShutdownOption) error\n}\n\n// ShutdownOption provides a way to configure properties of the shutdown\n// process. Currently, no options have been implemented.\ntype ShutdownOption interface {\n\tapply(*shutdowner)\n}\n\ntype exitCodeOption int\n\nfunc (code exitCodeOption) apply(s *shutdowner) {\n\ts.exitCode = int(code)\n}\n\nvar _ ShutdownOption = exitCodeOption(0)\n\n// ExitCode is a [ShutdownOption] that may be passed to the Shutdown method of the\n// [Shutdowner] interface.\n// The given integer exit code will be broadcasted to any receiver waiting\n// on a [ShutdownSignal] from the [Wait] method.\nfunc ExitCode(code int) ShutdownOption {\n\treturn exitCodeOption(code)\n}\n\ntype shutdownTimeoutOption time.Duration\n\nfunc (shutdownTimeoutOption) apply(*shutdowner) {}\n\nvar _ ShutdownOption = shutdownTimeoutOption(0)\n\n// ShutdownTimeout is a [ShutdownOption] that allows users to specify a timeout\n// for a given call to Shutdown method of the [Shutdowner] interface. As the\n// Shutdown method will block while waiting for a signal receiver relay\n// goroutine to stop.\n//\n// Deprecated: This option has no effect. Shutdown is not a blocking operation.\nfunc ShutdownTimeout(timeout time.Duration) ShutdownOption {\n\treturn shutdownTimeoutOption(timeout)\n}\n\ntype shutdowner struct {\n\tapp      *App\n\texitCode int\n}\n\n// Shutdown broadcasts a signal to all of the application's Done channels\n// and begins the Stop process. Applications can be shut down only after they\n// have finished starting up.\nfunc (s *shutdowner) Shutdown(opts ...ShutdownOption) error {\n\tfor _, opt := range opts {\n\t\topt.apply(s)\n\t}\n\n\treturn s.app.receivers.b.Broadcast(ShutdownSignal{\n\t\tSignal:   _sigTERM,\n\t\tExitCode: s.exitCode,\n\t})\n}\n\nfunc (app *App) shutdowner() Shutdowner {\n\treturn &shutdowner{app: app}\n}\n"
        },
        {
          "name": "shutdown_test.go",
          "type": "blob",
          "size": 5.5419921875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxtest\"\n)\n\nfunc TestShutdown(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"BroadcastsToMultipleChannels\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar s fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&s),\n\t\t)\n\n\t\tdone1, done2 := app.Done(), app.Done()\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\tassert.NoError(t, s.Shutdown(), \"error in app shutdown\")\n\t\tassert.NotNil(t, <-done1, \"done channel 1 did not receive signal\")\n\t\tassert.NotNil(t, <-done2, \"done channel 2 did not receive signal\")\n\t})\n\n\tt.Run(\"ErrorOnUnsentSignal\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar s fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&s),\n\t\t)\n\n\t\tdone := app.Done()\n\t\twait := app.Wait()\n\t\tdefer app.RequireStart().RequireStop()\n\t\tassert.NoError(t, s.Shutdown(), \"error returned from first shutdown call\")\n\n\t\tassert.EqualError(t, s.Shutdown(), \"send terminated signal: 2/2 channels are blocked\",\n\t\t\t\"unexpected error returned when shutdown is called with a blocked channel\")\n\t\tassert.NotNil(t, <-done, \"done channel did not receive signal\")\n\t\tassert.NotNil(t, <-wait, \"wait channel did not receive signal\")\n\t})\n\n\tt.Run(\"shutdown app before calling Done()\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar s fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&s),\n\t\t)\n\n\t\trequire.NoError(t, app.Start(context.Background()), \"error starting app\")\n\t\tassert.NoError(t, s.Shutdown(), \"error in app shutdown\")\n\t\tdone1, done2 := app.Done(), app.Done()\n\t\tdefer app.Stop(context.Background())\n\t\t// Receiving on done1 and done2 will deadlock in the event that app.Done()\n\t\t// doesn't work as expected.\n\t\tassert.NotNil(t, <-done1, \"done channel 1 did not receive signal\")\n\t\tassert.NotNil(t, <-done2, \"done channel 2 did not receive signal\")\n\t})\n\n\tt.Run(\"with exit code\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar s fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&s),\n\t\t)\n\n\t\trequire.NoError(t, app.Start(context.Background()), \"error starting app\")\n\t\tassert.NoError(t, s.Shutdown(fx.ExitCode(2)), \"error in app shutdown\")\n\t\twait := <-app.Wait()\n\t\tdefer app.Stop(context.Background())\n\t\trequire.Equal(t, 2, wait.ExitCode)\n\t})\n\n\tt.Run(\"with exit code and multiple Wait\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar s fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&s),\n\t\t)\n\n\t\trequire.NoError(t, app.Start(context.Background()), \"error starting app\")\n\t\tt.Cleanup(func() { app.Stop(context.Background()) }) // in t.Cleanup so this happens after all subtests return (not just this function)\n\t\tdefer require.NoError(t, app.Stop(context.Background()))\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tt.Run(fmt.Sprintf(\"Wait %v\", i), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\twait := <-app.Wait()\n\t\t\t\trequire.Equal(t, 2, wait.ExitCode)\n\t\t\t})\n\t\t}\n\n\t\tassert.NoError(t, s.Shutdown(fx.ExitCode(2), fx.ShutdownTimeout(time.Second)))\n\t})\n\n\tt.Run(\"from invoke\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Invoke(func(s fx.Shutdowner) {\n\t\t\t\ts.Shutdown()\n\t\t\t}),\n\t\t)\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\trequire.NoError(t, app.Start(ctx), \"error starting app\")\n\t\tdefer app.Stop(ctx)\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tassert.Fail(t, \"app did not shutdown in time\")\n\t\tcase <-app.Wait():\n\t\t\t// success\n\t\t}\n\t})\n\n\tt.Run(\"many times\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar shutdowner fx.Shutdowner\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Populate(&shutdowner),\n\t\t)\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tapp.RequireStart()\n\t\t\tshutdowner.Shutdown(fx.ExitCode(i))\n\t\t\tassert.Equal(t, i, (<-app.Wait()).ExitCode, \"run %d\", i)\n\t\t\tapp.RequireStop()\n\t\t}\n\t})\n}\n\nfunc TestDataRace(t *testing.T) {\n\tt.Parallel()\n\n\tvar s fx.Shutdowner\n\tapp := fxtest.New(\n\t\tt,\n\t\tfx.Populate(&s),\n\t)\n\tdefer app.RequireStart().RequireStop()\n\n\tconst N = 50\n\tready := make(chan struct{}) // used to orchestrate goroutines for Done() and ShutdownOption()\n\tvar wg sync.WaitGroup        // tracks and waits for all goroutines\n\n\t// Spawn N goroutines, each of which call app.Done() and assert\n\t// the signal received.\n\twg.Add(N)\n\tfor i := 0; i < N; i++ {\n\t\ti := i\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t<-ready\n\t\t\tdone := app.Done()\n\t\t\tassert.NotNil(t, <-done, \"done channel %v did not receive signal\", i)\n\t\t}()\n\t}\n\n\t// call Shutdown()\n\twg.Add(1)\n\tgo func() {\n\t\t<-ready\n\t\tdefer wg.Done()\n\t\tassert.NoError(t, s.Shutdown(), \"error in app shutdown\")\n\t}()\n\n\tclose(ready)\n\twg.Wait()\n}\n"
        },
        {
          "name": "signal.go",
          "type": "blob",
          "size": 4.103515625,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n)\n\n// ShutdownSignal represents a signal to be written to Wait or Done.\n// Should a user call the Shutdown method via the Shutdowner interface with\n// a provided ExitCode, that exit code will be populated in the ExitCode field.\n//\n// Should the application receive an operating system signal,\n// the Signal field will be populated with the received os.Signal.\ntype ShutdownSignal struct {\n\tSignal   os.Signal\n\tExitCode int\n}\n\n// String will render a ShutdownSignal type as a string suitable for printing.\nfunc (sig ShutdownSignal) String() string {\n\treturn fmt.Sprintf(\"%v\", sig.Signal)\n}\n\nfunc newSignalReceivers() signalReceivers {\n\treturn signalReceivers{\n\t\tnotify:     signal.Notify,\n\t\tstopNotify: signal.Stop,\n\t\tsignals:    make(chan os.Signal, 1),\n\t\tb:          &broadcaster{},\n\t}\n}\n\n// signalReceivers listens to OS signals and shutdown signals,\n// and relays them to registered listeners when started.\ntype signalReceivers struct {\n\t// this mutex protects writes and reads of this struct to prevent\n\t// race conditions in a parallel execution pattern\n\tm sync.Mutex\n\n\t// our os.Signal channel we relay from\n\tsignals chan os.Signal\n\t// when written to, will instruct the signal relayer to shutdown\n\tshutdown chan struct{}\n\t// is written to when signal relay has finished shutting down\n\tfinished chan struct{}\n\n\t// this stub allows us to unit test signal relay functionality\n\tnotify     func(c chan<- os.Signal, sig ...os.Signal)\n\tstopNotify func(c chan<- os.Signal)\n\n\t// used to register and broadcast to signal listeners\n\t// created via Done and Wait\n\tb *broadcaster\n}\n\nfunc (recv *signalReceivers) relayer() {\n\tdefer func() {\n\t\trecv.finished <- struct{}{}\n\t}()\n\n\tselect {\n\tcase <-recv.shutdown:\n\t\treturn\n\tcase signal := <-recv.signals:\n\t\trecv.b.Broadcast(ShutdownSignal{\n\t\t\tSignal: signal,\n\t\t})\n\t}\n}\n\n// running returns true if the the signal relay go-routine is running.\n// this method must be invoked under locked mutex to avoid race condition.\nfunc (recv *signalReceivers) running() bool {\n\treturn recv.shutdown != nil && recv.finished != nil\n}\n\nfunc (recv *signalReceivers) Start() {\n\trecv.m.Lock()\n\tdefer recv.m.Unlock()\n\n\t// if the receiver has already been started; don't start it again\n\tif recv.running() {\n\t\treturn\n\t}\n\n\trecv.finished = make(chan struct{}, 1)\n\trecv.shutdown = make(chan struct{}, 1)\n\trecv.notify(recv.signals, os.Interrupt, _sigINT, _sigTERM)\n\tgo recv.relayer()\n}\n\nfunc (recv *signalReceivers) Stop(ctx context.Context) error {\n\trecv.m.Lock()\n\tdefer recv.m.Unlock()\n\trecv.stopNotify(recv.signals)\n\n\t// if the relayer is not running; return nil error\n\tif !recv.running() {\n\t\treturn nil\n\t}\n\n\trecv.shutdown <- struct{}{}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase <-recv.finished:\n\t\tclose(recv.shutdown)\n\t\tclose(recv.finished)\n\t\trecv.shutdown = nil\n\t\trecv.finished = nil\n\t\trecv.b.reset()\n\t\treturn nil\n\t}\n}\n\nfunc (recv *signalReceivers) Done() <-chan os.Signal {\n\treturn recv.b.Done()\n}\n\nfunc (recv *signalReceivers) Wait() <-chan ShutdownSignal {\n\treturn recv.b.Wait()\n}\n"
        },
        {
          "name": "signal_test.go",
          "type": "blob",
          "size": 4.1533203125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc assertUnsentSignalError(\n\tt *testing.T,\n\terr error,\n\texpected *unsentSignalError,\n) {\n\tt.Helper()\n\n\tactual := new(unsentSignalError)\n\n\tassert.ErrorContains(t, err, \"channels are blocked\")\n\tif assert.ErrorAs(t, err, &actual, \"is unsentSignalError\") {\n\t\tassert.Equal(t, expected, actual)\n\t}\n}\n\nfunc TestSignal(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"Done\", func(t *testing.T) {\n\t\trecv := newSignalReceivers()\n\t\ta := recv.Done()\n\t\t_ = recv.Done() // we never listen on this\n\n\t\texpected := ShutdownSignal{\n\t\t\tSignal: syscall.SIGTERM,\n\t\t}\n\n\t\trequire.NoError(t, recv.b.Broadcast(expected), \"first broadcast should succeed\")\n\n\t\tassertUnsentSignalError(t, recv.b.Broadcast(expected), &unsentSignalError{\n\t\t\tSignal: expected,\n\t\t\tTotal:  2,\n\t\t\tUnsent: 2,\n\t\t})\n\n\t\tassert.Equal(t, expected.Signal, <-a)\n\t\tassert.Equal(t, expected.Signal, <-recv.Done(), \"expect cached signal\")\n\t})\n\n\tt.Run(\"signal notify relayer\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tt.Run(\"start and stop\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tt.Run(\"timeout\", func(t *testing.T) {\n\t\t\t\trecv := newSignalReceivers()\n\t\t\t\trecv.Start()\n\t\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 0)\n\t\t\t\tdefer cancel()\n\t\t\t\terr := recv.Stop(timeoutCtx)\n\t\t\t\trequire.ErrorIs(t, err, context.DeadlineExceeded)\n\t\t\t})\n\t\t\tt.Run(\"no error\", func(t *testing.T) {\n\t\t\t\trecv := newSignalReceivers()\n\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\tdefer cancel()\n\t\t\t\trecv.Start()\n\t\t\t\trecv.Start() // should be a no-op if already running\n\t\t\t\trequire.NoError(t, recv.Stop(ctx))\n\t\t\t})\n\t\t\tt.Run(\"notify\", func(t *testing.T) {\n\t\t\t\tstub := make(chan os.Signal)\n\t\t\t\trecv := newSignalReceivers()\n\t\t\t\trecv.notify = func(ch chan<- os.Signal, _ ...os.Signal) {\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tfor sig := range stub {\n\t\t\t\t\t\t\tch <- sig\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t\tvar stopCalledTimes int\n\t\t\t\trecv.stopNotify = func(ch chan<- os.Signal) {\n\t\t\t\t\tstopCalledTimes++\n\t\t\t\t}\n\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\tdefer cancel()\n\t\t\t\trecv.Start()\n\t\t\t\tstub <- syscall.SIGTERM\n\t\t\t\tstub <- syscall.SIGTERM\n\t\t\t\trequire.Equal(t, syscall.SIGTERM, <-recv.Done())\n\t\t\t\trequire.Equal(t, syscall.SIGTERM, <-recv.Done())\n\t\t\t\tsig := <-recv.Wait()\n\t\t\t\trequire.Equal(t, syscall.SIGTERM, sig.Signal)\n\t\t\t\trequire.NoError(t, recv.Stop(ctx))\n\t\t\t\trequire.Equal(t, 1, stopCalledTimes)\n\t\t\t\tclose(stub)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"stop deadlock\", func(t *testing.T) {\n\t\trecv := newSignalReceivers()\n\n\t\tvar notify chan<- os.Signal\n\t\trecv.notify = func(ch chan<- os.Signal, _ ...os.Signal) {\n\t\t\tnotify = ch\n\t\t}\n\t\trecv.Start()\n\n\t\t// Artificially create a race where the relayer receives an OS signal\n\t\t// while Stop() holds the lock. If this leads to deadlock,\n\t\t// we will receive a context timeout error.\n\t\tgotErr := make(chan error, 1)\n\t\tnotify <- syscall.SIGTERM\n\t\tgo func() {\n\t\t\tstopCtx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\t\t\tgotErr <- recv.Stop(stopCtx)\n\t\t}()\n\t\tassert.NoError(t, <-gotErr)\n\t})\n}\n"
        },
        {
          "name": "supply.go",
          "type": "blob",
          "size": 4.6259765625,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/fx/internal/fxreflect\"\n)\n\n// Supply provides instantiated values for dependency injection as if\n// they had been provided using a constructor that simply returns them.\n// The most specific type of each value (as determined by reflection) is used.\n//\n// This serves a purpose similar to what fx.Replace does for fx.Decorate.\n//\n// For example, given:\n//\n//\ttype (\n//\t\tTypeA struct{}\n//\t\tTypeB struct{}\n//\t\tTypeC struct{}\n//\t)\n//\n//\tvar a, b, c = &TypeA{}, TypeB{}, &TypeC{}\n//\n// The following two forms are equivalent:\n//\n//\tfx.Supply(a, b, fx.Annotated{Target: c})\n//\n//\tfx.Provide(\n//\t\tfunc() *TypeA { return a },\n//\t\tfunc() TypeB { return b },\n//\t\tfx.Annotated{Target: func() *TypeC { return c }},\n//\t)\n//\n// Supply panics if a value (or annotation target) is an untyped nil or an error.\n//\n// [Private] can be used to restrict access to supplied values.\n//\n// # Supply Caveats\n//\n// As mentioned above, Supply uses the most specific type of the provided\n// value. For interface values, this refers to the type of the implementation,\n// not the interface. So if you supply an http.Handler, fx.Supply will use the\n// type of the implementation.\n//\n//\tvar handler http.Handler = http.HandlerFunc(f)\n//\tfx.Supply(handler)\n//\n// Is equivalent to,\n//\n//\tfx.Provide(func() http.HandlerFunc { return f })\n//\n// This is typically NOT what you intended. To supply the handler above as an\n// http.Handler, we need to use the fx.Annotate function with the fx.As\n// annotation.\n//\n//\tfx.Supply(\n//\t\tfx.Annotate(handler, fx.As(new(http.Handler))),\n//\t)\nfunc Supply(values ...interface{}) Option {\n\tconstructors := make([]interface{}, 0, len(values))\n\ttypes := make([]reflect.Type, 0, len(values))\n\tvar private bool\n\tfor _, value := range values {\n\t\tvar (\n\t\t\ttyp  reflect.Type\n\t\t\tctor any\n\t\t)\n\t\tswitch value := value.(type) {\n\t\tcase privateOption:\n\t\t\tprivate = true\n\t\t\tcontinue\n\t\tcase annotated:\n\t\t\tvalue.Target, typ = newSupplyConstructor(value.Target)\n\t\t\tctor = value\n\t\tcase Annotated:\n\t\t\tvalue.Target, typ = newSupplyConstructor(value.Target)\n\t\t\tctor = value\n\t\tdefault:\n\t\t\tctor, typ = newSupplyConstructor(value)\n\t\t}\n\t\tconstructors = append(constructors, ctor)\n\t\ttypes = append(types, typ)\n\t}\n\n\treturn supplyOption{\n\t\tTargets: constructors,\n\t\tTypes:   types,\n\t\tStack:   fxreflect.CallerStack(1, 0),\n\t\tPrivate: private,\n\t}\n}\n\ntype supplyOption struct {\n\tTargets []interface{}\n\tTypes   []reflect.Type // type of value produced by constructor[i]\n\tStack   fxreflect.Stack\n\tPrivate bool\n}\n\nfunc (o supplyOption) apply(m *module) {\n\tfor i, target := range o.Targets {\n\t\tm.provides = append(m.provides, provide{\n\t\t\tTarget:     target,\n\t\t\tStack:      o.Stack,\n\t\t\tIsSupply:   true,\n\t\t\tSupplyType: o.Types[i],\n\t\t\tPrivate:    o.Private,\n\t\t})\n\t}\n}\n\nfunc (o supplyOption) String() string {\n\titems := make([]string, 0, len(o.Targets))\n\tfor _, typ := range o.Types {\n\t\titems = append(items, typ.String())\n\t}\n\treturn fmt.Sprintf(\"fx.Supply(%s)\", strings.Join(items, \", \"))\n}\n\n// Returns a function that takes no parameters, and returns the given value.\nfunc newSupplyConstructor(value interface{}) (interface{}, reflect.Type) {\n\tswitch value.(type) {\n\tcase nil:\n\t\tpanic(\"untyped nil passed to fx.Supply\")\n\tcase error:\n\t\tpanic(\"error value passed to fx.Supply\")\n\t}\n\n\ttyp := reflect.TypeOf(value)\n\treturnTypes := []reflect.Type{typ}\n\treturnValues := []reflect.Value{reflect.ValueOf(value)}\n\n\tft := reflect.FuncOf([]reflect.Type{}, returnTypes, false)\n\tfv := reflect.MakeFunc(ft, func([]reflect.Value) []reflect.Value {\n\t\treturn returnValues\n\t})\n\n\treturn fv.Interface(), typ\n}\n"
        },
        {
          "name": "supply_test.go",
          "type": "blob",
          "size": 4.728515625,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"go.uber.org/fx\"\n\t\"go.uber.org/fx/fxevent\"\n\t\"go.uber.org/fx/fxtest\"\n\t\"go.uber.org/fx/internal/fxlog\"\n)\n\nfunc TestSupply(t *testing.T) {\n\tt.Parallel()\n\n\ttype A struct{}\n\ttype B struct{}\n\n\tt.Run(\"NothingIsSupplied\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := fxtest.New(t, fx.Supply())\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n\n\tt.Run(\"SomethingIsSupplied\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\taIn, bIn := &A{}, &B{}\n\t\tvar aOut *A\n\t\tvar bOut *B\n\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Supply(aIn, bIn),\n\t\t\tfx.Populate(&aOut, &bOut),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\trequire.Same(t, aIn, aOut)\n\t\trequire.Same(t, bIn, bOut)\n\t})\n\n\tt.Run(\"SupplyInModule\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\taIn, bIn := &A{}, &B{}\n\t\tvar aOut *A\n\t\tvar bOut *B\n\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Module(\"module\",\n\t\t\t\tfx.Supply(aIn, bIn),\n\t\t\t),\n\t\t\tfx.Populate(&aOut, &bOut),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\t\trequire.Same(t, aIn, aOut)\n\t\trequire.Same(t, bIn, bOut)\n\t})\n\n\tt.Run(\"AnnotateIsSupplied\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfirstIn, secondIn, thirdIn := &A{}, &A{}, &B{}\n\t\tvar out struct {\n\t\t\tfx.In\n\n\t\t\tFirst  *A `name:\"first\"`\n\t\t\tSecond *A `name:\"second\"`\n\t\t\tThird  *B\n\t\t}\n\n\t\tapp := fxtest.New(\n\t\t\tt,\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotated{Name: \"first\", Target: firstIn},\n\t\t\t\tfx.Annotated{Name: \"second\", Target: secondIn},\n\t\t\t\tthirdIn),\n\t\t\tfx.Populate(&out),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\trequire.Same(t, firstIn, out.First)\n\t\trequire.Same(t, secondIn, out.Second)\n\t\trequire.Same(t, thirdIn, out.Third)\n\t})\n\n\tt.Run(\"AnnotateIsSupported\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar out struct {\n\t\t\tfx.In\n\n\t\t\tGot io.Writer\n\t\t}\n\n\t\tvar give bytes.Buffer\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(fx.Annotate(&give, fx.As(new(io.Writer)))),\n\t\t\tfx.Populate(&out),\n\t\t)\n\t\tdefer app.RequireStart().RequireStop()\n\n\t\trequire.Same(t, &give, out.Got)\n\t})\n\n\tt.Run(\"InvalidArgumentIsSupplied\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\trequire.PanicsWithValuef(\n\t\t\tt,\n\t\t\t\"untyped nil passed to fx.Supply\",\n\t\t\tfunc() { fx.Supply(A{}, nil) },\n\t\t\t\"a naked nil should panic\",\n\t\t)\n\n\t\trequire.NotPanicsf(\n\t\t\tt,\n\t\t\tfunc() { fx.Supply(A{}, (*B)(nil)) },\n\t\t\t\"a wrapped nil should not panic\")\n\n\t\trequire.PanicsWithValuef(\n\t\t\tt,\n\t\t\t\"error value passed to fx.Supply\",\n\t\t\tfunc() { fx.Supply(A{}, errors.New(\"fail\")) },\n\t\t\t\"an error value should panic\",\n\t\t)\n\t})\n\n\tt.Run(\"SupplyCollision\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype foo struct{}\n\n\t\tvar spy fxlog.Spy\n\t\tapp := fx.New(\n\t\t\tfx.WithLogger(func() fxevent.Logger { return &spy }),\n\t\t\tfx.Supply(&foo{}, &foo{}),\n\t\t)\n\n\t\trequire.Error(t, app.Err())\n\t\tassert.Contains(t, app.Err().Error(), \"already provided\")\n\n\t\tsupplied := spy.Events().SelectByTypeName(\"Supplied\")\n\t\trequire.Len(t, supplied, 2)\n\t\trequire.NoError(t, supplied[0].(*fxevent.Supplied).Err)\n\t\trequire.Error(t, supplied[1].(*fxevent.Supplied).Err)\n\t})\n\n\tt.Run(\"SupplyToASoftGroup\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Param struct {\n\t\t\tfx.In\n\n\t\t\tFoos []string `group:\"foo,soft\"`\n\t\t\tBar  []int    `group:\"bar\"`\n\t\t}\n\t\ttype Result struct {\n\t\t\tfx.Out\n\n\t\t\tFoo string `group:\"foo\"`\n\t\t\tBar int    `group:\"bar\"`\n\t\t}\n\t\tapp := fxtest.New(t,\n\t\t\tfx.Supply(\n\t\t\t\tResult{\n\t\t\t\t\tFoo: \"sad\",\n\t\t\t\t\tBar: 20,\n\t\t\t\t}),\n\t\t\tfx.Supply(\n\t\t\t\tfx.Annotated{\n\t\t\t\t\tTarget: 10,\n\t\t\t\t\tGroup:  \"bar\",\n\t\t\t\t},\n\t\t\t\tfx.Annotated{\n\t\t\t\t\tTarget: \"bye\",\n\t\t\t\t\tGroup:  \"foo\",\n\t\t\t\t}),\n\t\t\tfx.Supply(fx.Annotated{\n\t\t\t\tTarget: \"hello\",\n\t\t\t\tGroup:  \"foo\",\n\t\t\t}),\n\t\t\tfx.Invoke(func(p Param) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"sad\"}, p.Foos)\n\t\t\t}),\n\t\t)\n\n\t\tdefer app.RequireStart().RequireStop()\n\t})\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.19140625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage fx\n\n// Version is exported for runtime compatibility checks.\nconst Version = \"1.23.1-dev\"\n"
        }
      ]
    }
  ]
}