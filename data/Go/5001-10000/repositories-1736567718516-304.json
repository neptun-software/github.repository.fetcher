{
  "metadata": {
    "timestamp": 1736567718516,
    "page": 304,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/ethr",
      "stars": 5802,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.369140625,
          "content": "# Files without extension (Linux binary, for example)\n*\n!/**/\n!*.*\n!Makefile\n!LICENSE\n!Dockerfile\n\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# VIM related files\n*.un~\n*.swp\n\n# Log files\n*.log\n\n# Golang vendor directory\nvendor/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.3896484375,
          "content": "language: go\n\ngo:\n- stable\n\nos:\n- linux\n- windows\n- osx\n\nenv:\n  - GO111MODULE=on\n\nmatrix:\n  allow_failures:\n  - os: windows\n    go: master\n  fast_finish: true\n\nbefore_install:\n- go get -u golang.org/x/tools/cmd/goimports\n- go get -u golang.org/x/lint/golint\n- chmod +x travis_build.sh\n\ninstall:\n- go get -t -v ./...\n\nnotifications:\n  email: false\n\nscript:\n- go test -v -race ./...\n- go vet ./...\n- goimports -d $(find . -type f -name '*.go' -not -path \"./vendor/*\")\n- golint $(go list ./... | grep -v /vendor/)\n- \"./travis_build.sh\"\n\ndeploy:\n  provider: releases\n  skip_cleanup: true\n  api_key:\n    secure: abQ1+sEMMsTMQk3aBHc2cD4yi46X38yPPZrY4AIotZTTutrbcfBzuKE7fCOh7C49wi2PS1LsJVtivfe2EBRm/yOV32tKorUL7AzqRSuvIQ6vKvsMU1U10Ix5VghYo+YYTpjPCQb77NNJDDOpjoROnADTXUASCZYw0mOIAHzjFeSBCx5LADOSvQ0JSM8UEBi/n32esBvRuDN1a/2Bp1vzjHrUZ3pN4GZmQxJBrQvE1cNMCwWQvi58Tuqhpu0yL1dCGA3yVG2GOkirSom6UMWGGxtadIdVUjyGzmlV1uGGakkggWazOp+Bw1M2Wrr48kcM9dYWO0YG+FYNroSq13CyBtJiDVG0bAwKHi4VmCtctB1RCBw5UkKQ33z+bDf+aW39/+G/f5OGRHkFB4N0udR8+Z2AmH80jY8PHakRRBbiKBOIkUnWKdbKB4EeosN1BT6+4xbdey3gaeDBU4ERHnceqnGjKRZd24dBu30xfDDfxrexyJsIqM5/uCpv5xgcBdcFIKcPj7hAfGG2v+JgFbQfF/hdRpxlM4xwwArEXEAYILy1OUkOOzsiNatYciOKpzh6uTkroi9DMYrZpJOXIcRjryhQvbe6i/vWC2NimVOa1bv6tJpH2ru/KR5aMhcglZyNGvKU8IJ5jgVN/2EQBIMxD2L92VksV7Hj6pawFrYCixg=\n  file:\n  - ethr_linux.zip\n  - ethr_windows.zip\n  - ethr_osx.zip\n  on:\n    repo: microsoft/ethr\n    branch: master\n    tags: true\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.078125,
          "content": "FROM golang:1.13\n\nWORKDIR /app\n\nADD ./ /app\n\nRUN mkdir /out && \\\n    go build .\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.134765625,
          "content": "    MIT License\n\n    Copyright (c) Microsoft Corporation. All rights reserved.\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.685546875,
          "content": "#!make\n#-----------------------------------------------------------------------------\n# Copyright (C) Microsoft. All rights reserved.\n# Licensed under the MIT license.\n# See LICENSE.txt file in the project root for full license information.\n#-----------------------------------------------------------------------------\n\nGO_BIN ?= go\nGO_LINT ?= golint\nGO_FMT ?= gofmt\nBINARY_NAME ?= ethr\n\n.PHONY: fmt\nfmt:\n\tfind . -name '*.go' | \\\n\t    while read -r file; \\\n\t        do $(GO_FMT) -w -s \"$$file\"; \\\n\t    done\n\n.PHONY: build-docker\nbuild-docker: \n\t$(GO_BIN) build -o /out/$(BINARY_NAME)\n\n.PHONY: build\nbuild:\n\t$(GO_BIN) build -o $(BINARY_NAME) .\n\n.PHONY: lint\nlint:\n\t$(GO_LINT) .\n\n.DEFAULT_GOAL := build\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0478515625,
          "content": "# Ethr [![Build Status](https://travis-ci.org/Microsoft/ethr.svg?branch=master)](https://travis-ci.org/Microsoft/ethr)\n\nEthr is a cross platform network performance measurement tool written in golang. The goal of this project is to provide a native tool for comprehensive network performance measurements of bandwidth, connections/s, packets/s, latency, loss & jitter, across multiple protocols such as TCP, UDP, HTTP, HTTPS, and across multiple platforms such as Windows, Linux and other Unix systems.\n\n<p align=\"center\">\n  <img alt=\"Ethr server in action\" src=\"https://user-images.githubusercontent.com/44273634/49815752-506f0000-fd21-11e8-954e-d587e79c5d85.png\">\n</p>\n\nEthr takes inspiration from existing open source network performance tools and builds upon those ideas. For Bandwidth measurement, it is similar to iPerf3, for TCP & UDP traffic. iPerf3 has many more options for doing such as throttled testing, richer feature set, while Ethr has support for multiple threads, that allows it to scale to 1024 or even higher number of connections, multiple clients communication to a single server etc. For latency measurements, it is similar to latte on Windows or sockperf on Linux.\n\nEthr provides more test measurements as compared to other tools, e.g. it provides measurements for bandwidth, connections/s, packets/s, latency, and TCP connection setup latency, all in a single tool. In the future, there are plans to add more features (hoping for others to contribute) as well as more protocol support to make it a comprehensive tool for network performance measurements.\n\nEthr is natively cross platform, thanks to golang, as compared to compiling via an abstraction layer like cygwin that may limit functionality. It hopes to unify performance measurement by combining the functionality of tools like iPerf3, ntttcp, psping, sockperf, and latte and offering a single tool across multiple platforms and multiple protocols.\n\n# Installation\n\n## Download\n\nhttps://github.com/Microsoft/ethr/releases/latest\n\n**Linux**\n```\nwget https://github.com/microsoft/ethr/releases/latest/download/ethr_linux.zip\nunzip ethr_linux.zip\n```\n\n**Windows Powershell**\n```\nwget https://github.com/microsoft/ethr/releases/latest/download/ethr_windows.zip -OutFile ethr_windows.zip\nExpand-Archive .\\ethr_windows.zip -DestinationPath .\n```\n\n**OSX**\n```\nwget https://github.com/microsoft/ethr/releases/latest/download/ethr_osx.zip\nunzip ethr_osx.zip\n```\n\n## Building from Source\n\nNote: go version 1.11 or higher is required building it from the source.\n\nWe use go-module to manage Ethr dependencies. for more information please check [how to use go-modules!](https://github.com/golang/go/wiki/Modules#how-to-use-modules)\n\n```\ngit clone https://github.com/Microsoft/ethr.git\ncd ethr\ngo build\n```\n\nIf ethr is cloned inside of the `$GOPATH/src` tree, please make sure you invoke the `go` command with `GO111MODULE=on`!\n\n## Docker\n\nBuild image using command: \n```\ndocker build -t microsoft/ethr .\n```\n\nMake binary:\n\n**Linux**\n```\ndocker run -e GOOS=linux -v $(pwd):/out microsoft/ethr make build-docker\n```\n\n**Windows**\n\n```\ndocker run -e BINARY_NAME=ethr.exe -e GOOS=windows -v $(pwd):/out microsoft/ethr make build-docker\n```\n\n**OS X**\n```\ndocker run -e BINARY_NAME=ethr -e GOOS=darwin -v $(pwd):/out microsoft/ethr make build-docker\n```\n\n## Using go get\n\n```\ngo get github.com/microsoft/ethr\n```\n\n## Using ArchLinux AUR\n\nAssuming you are using [`yay`](https://aur.archlinux.org/packages/yay/) (https://github.com/Jguer/yay):\n\n```\nyay -S ethr\n```\n# Publishing Nuget package\nFollow the topic Building from Source to build ethr.exe\n\nModify ethr.nuspec to add new release version\n```\nvim ethr.nuspec\n```\nCreate a nuget package(like Ethr.0.2.1.nupkg)\n```\nnuget.exe pack ethr.nuspec\n```\nUpload the package to nuget.org.\n\n# Usage\n\n## Simple Usage\nHelp:\n```\nethr -h\n```\n\nServer:\n```\nethr -s\n```\n\nServer with Text UI:\n```\nethr -s -ui\n```\n\nClient:\n```\nethr -c <server ip>\n```\n\nExamples:\n```\n// Start server\nethr -s\n\n// Start client for default (bandwidth) test measurement using 1 thread\nethr -c localhost\n\n// Start bandwidth test using 8 threads\nethr -c localhost -n 8\n\n// Start connections/s test using 64 threads to server 10.1.0.11\nethr -c 10.1.0.11 -t c -n 64\n\n// Run Ethr server on port 9999\n./ethr -s -port 9999\n\n// Measure TCP connection setup latency to ethr server on port 9999\n// Assuming Ethr server is running on server with IP address: 10.1.1.100\n./ethr -c 10.1.1.100 -p tcp -t pi -d 0 -4 -port 9999\n\n// Measure TCP connection setup latency to www.github.com at port 443\n./ethr -x www.github.com:443 -p tcp -t pi -d 0 -4\n\n// Measure TCP connection setup latency to www.github.com at port 443\n// Note: Here port 443 is driven automatically from https\n./ethr -x https://www.github.com -p tcp -t pi -d 0 -4\n\n// Measure ICMP ping latency to www.github.com\nsudo ./ethr -x www.github.com -p icmp -t pi -d 0 -4\n\n// Run measurement similar to mtr on Linux\nsudo ./ethr -x www.github.com -p icmp -t mtr -d 0 -4\n\n// Measure packets/s over UDP by sending small 1-byte packets\n./ethr -c 172.28.192.1 -p udp -t p -d 0\n```\n\n## Known Issues & Requirements\n### Windows\nFor ICMP related tests, Ping, TraceRoute, MyTraceRoute, Windows requires ICMP to be allowed via Firewall. This can be done using PowerShell by following commands. However, use this only if security policy of your setup allows that.\n```\n// Allow ICMP packets via Firewall for IPv4\nNew-NetFirewallRule -DisplayName \"ICMP_Allow_Any\" -Direction Inbound -Protocol ICMPv4 -IcmpType Any -Action Allow  -Profile Any -RemotePort Any\n\n// Allow ICMP packets via Firewall for IPv6\nNew-NetFirewallRule -DisplayName \"ICMPV6_Allow_Any\" -Direction Inbound -Protocol ICMPv6 -IcmpType Any -Action Allow  -Profile Any -RemotePort Any\n```\nIn addition, for TCP based TraceRoute and MyTraceRoute, Administrator mode is required, otherwise Ethr won't be able to receive ICMP TTL exceeded messages.\n### Linux\nFor ICMP Ping, ICMP/TCP TraceRoute and MyTraceRoute, privileged mode is required via sudo.\n\n## Complete Command Line\n### Common Parameters\n```\n\t-h \n\t\tHelp\n\t-no \n\t\tDisable logging to file. Logging to file is enabled by default.\n\t-o <filename>\n\t\tName of log file. By default, following file names are used:\n\t\tServer mode: 'ethrs.log'\n\t\tClient mode: 'ethrc.log'\n\t-debug \n\t\tEnable debug information in logging output.\n\t-4 \n\t\tUse only IP v4 version\n\t-6 \n\t\tUse only IP v6 version\n```\n### Server Mode Parameters\n```\nIn this mode, Ethr runs as a server, allowing multiple clients to run\nperformance tests against it.\n\t-s \n\t\tRun in server mode.\n\t-ip <string>\n\t\tBind to specified local IP address for TCP & UDP tests.\n\t\tThis must be a valid IPv4 or IPv6 address.\n\t\tDefault: <empty> - Any IP\n\t-port <number>\n\t\tUse specified port number for TCP & UDP tests.\n\t\tDefault: 8888\n\t-ui \n\t\tShow output in text UI.\n```\n### Client Mode Parameters\n```\nIn this mode, Ethr client can only talk to an Ethr server.\n\t-c <server>\n\t\tRun in client mode and connect to <server>.\n\t\tServer is specified using name, FQDN or IP address.\n\t-b <rate>\n\t\tTransmit only Bits per second (format: <num>[K | M | G])\n\t\tOnly valid for Bandwidth tests. Default: 0 - Unlimited\n\t\tExamples: 100 (100bits/s), 1M (1Mbits/s).\n\t-cport <number>\n\t\tUse specified local port number in client for TCP & UDP tests.\n\t\tDefault: 0 - Ephemeral Port\n\t-d <duration>\n\t\tDuration for the test (format: <num>[ms | s | m | h]\n\t\t0: Run forever\n\t\tDefault: 10s\n\t-g <gap>\n\t\tTime interval between successive measurements (format: <num>[ms | s | m | h]\n\t\tOnly valid for latency, ping and traceRoute tests.\n\t\t0: No gap\n\t\tDefault: 1s\n\t-i <iterations>\n\t\tNumber of round trip iterations for each latency measurement.\n\t\tOnly valid for latency testing.\n\t\tDefault: 1000\n\t-ip <string>\n\t\tBind to specified local IP address for TCP & UDP tests.\n\t\tThis must be a valid IPv4 or IPv6 address.\n\t\tDefault: <empty> - Any IP\n\t-l <length>\n\t\tLength of buffer to use (format: <num>[KB | MB | GB])\n\t\tOnly valid for Bandwidth tests. Max 1GB.\n\t\tDefault: 16KB\n\t-n <number>\n\t\tNumber of Parallel Sessions (and Threads).\n\t\t0: Equal to number of CPUs\n\t\tDefault: 1\n\t-p <protocol>\n\t\tProtocol (\"tcp\", \"udp\", \"http\", \"https\", or \"icmp\")\n\t\tDefault: tcp\n\t-port <number>\n\t\tUse specified port number for TCP & UDP tests.\n\t\tDefault: 8888\n\t-r \n\t\tFor Bandwidth tests, send data from server to client.\n\t-t <test>\n\t\tTest to run (\"b\", \"c\", \"p\", \"l\", \"cl\" or \"tr\")\n\t\tb: Bandwidth\n\t\tc: Connections/s\n\t\tp: Packets/s\n\t\tl: Latency, Loss & Jitter\n\t\tpi: Ping Loss & Latency\n\t\ttr: TraceRoute\n\t\tmtr: MyTraceRoute with Loss & Latency\n\t\tDefault: b - Bandwidth measurement.\n\t-tos \n\t\tSpecifies 8-bit value to use in IPv4 TOS field or IPv6 Traffic Class field.\n\t-w <number>\n\t\tUse specified number of iterations for warmup.\n\t\tDefault: 1\n\t-T <string>\n\t\tUse the given title in log files for logging results.\n\t\tDefault: <empty>\t\t\n```\n### External Mode Parameters\n```\nIn this mode, Ethr talks to a non-Ethr server. This mode supports only a\nfew types of measurements, such as Ping, Connections/s and TraceRoute.\n\t-x <destination>\n\t\tRun in external client mode and connect to <destination>.\n\t\t<destination> is specified in URL or Host:Port format.\n\t\tFor URL, if port is not specified, it is assumed to be 80 for http and 443 for https.\n\t\tExample: For TCP - www.microsoft.com:443 or 10.1.0.4:22 or https://www.github.com\n\t\t         For ICMP - www.microsoft.com or 10.1.0.4\n\t-cport <number>\n\t\tUse specified local port number in client for TCP & UDP tests.\n\t\tDefault: 0 - Ephemeral Port\n\t-d <duration>\n\t\tDuration for the test (format: <num>[ms | s | m | h]\n\t\t0: Run forever\n\t\tDefault: 10s\n\t-g <gap>\n\t\tTime interval between successive measurements (format: <num>[ms | s | m | h]\n\t\tOnly valid for latency, ping and traceRoute tests.\n\t\t0: No gap\n\t\tDefault: 1s\n\t-ip <string>\n\t\tBind to specified local IP address for TCP & UDP tests.\n\t\tThis must be a valid IPv4 or IPv6 address.\n\t\tDefault: <empty> - Any IP\n\t-n <number>\n\t\tNumber of Parallel Sessions (and Threads).\n\t\t0: Equal to number of CPUs\n\t\tDefault: 1\n\t-p <protocol>\n\t\tProtocol (\"tcp\", or \"icmp\")\n\t\tDefault: tcp\n\t-t <test>\n\t\tTest to run (\"c\", \"cl\", or \"tr\")\n\t\tc: Connections/s\n\t\tpi: Ping Loss & Latency\n\t\ttr: TraceRoute\n\t\tmtr: MyTraceRoute with Loss & Latency\n\t\tDefault: pi - Ping Loss & Latency.\n\t-tos \n\t\tSpecifies 8-bit value to use in IPv4 TOS field or IPv6 Traffic Class field.\n\t-w <number>\n\t\tUse specified number of iterations for warmup.\n\t\tDefault: 1\n\t-T <string>\n\t\tUse the given title in log files for logging results.\n\t\tDefault: <empty>\t\t\n```\n\n# Status\n\nProtocol  | Bandwidth | Connections/s | Packets/s | Latency | Ping | TraceRoute | MyTraceRoute\n------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------\nTCP  | Yes | Yes | NA | Yes | Yes | Yes | Yes\nUDP  | Yes | NA | Yes | No | NA | No | No\nICMP | No | NA | NA | NA | Yes | Yes | Yes\n\n# Platform Support\n\n**Windows**\n\nTested: Windows 10, Windows 7 SP1\n\nUntested: Other Windows versions\n\n**Linux**\n\nTested: Ubuntu Linux 18.04.1 LTS, OpenSuse Leap 15\n\nUntested: Other Linux versions\n\n**OSX**\n\nTested: OSX is tested by contributors\n\n**Other**\n\nNo other platforms are tested at this time\n\n# Todo List\n\nTodo list work items are shown below. Contributions are most welcome for these work items or any other features and bugfixes.\n\n* Test Ethr on other Windows versions, other Linux versions, FreeBSD and other OS\n* Support for UDP latency, TraceRoute and MyTraceRoute\n\n# Contributing\n\nThis project welcomes contributions and suggestions.  Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit https://cla.microsoft.com.\n\nWhen you submit a pull request, a CLA-bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\nFor more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or\ncontact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.6923828125,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.8 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 26.6904296875,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t//\t\"bytes\"\n\t//\t\"crypto/tls\"\n\t//\t\"crypto/x509\"\n\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t//\t\"io\"\n\t//\t\"io/ioutil\"\n\t\"net\"\n\t//\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\n\t//\t\"sort\"\n\t//\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/net/icmp\"\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/ipv6\"\n)\n\nvar gIgnoreCert bool\n\nconst (\n\tdone       = 0\n\ttimeout    = 1\n\tinterrupt  = 2\n\tdisconnect = 3\n)\n\nfunc handleInterrupt(toStop chan<- int) {\n\tsigChan := make(chan os.Signal)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\ttoStop <- interrupt\n\t}()\n}\n\nfunc runDurationTimer(d time.Duration, toStop chan int) {\n\tgo func() {\n\t\tdSeconds := uint64(d.Seconds())\n\t\tif dSeconds == 0 {\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(d)\n\t\t// Sleep extra 200ms to ensure stats print for correct number of seconds.\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\ttoStop <- timeout\n\t}()\n}\n\nfunc initClient(title string) {\n\tinitClientUI(title)\n}\n\nfunc handshakeWithServer(test *ethrTest, conn net.Conn) (err error) {\n\tethrMsg := createSynMsg(test.testID, test.clientParam)\n\terr = sendSessionMsg(conn, ethrMsg)\n\tif err != nil {\n\t\tui.printDbg(\"Failed to send SYN message to Ethr server. Error: %v\", err)\n\t\treturn\n\t}\n\tethrMsg = recvSessionMsg(conn)\n\tif ethrMsg.Type != EthrAck {\n\t\tui.printDbg(\"Failed to receive ACK message from Ethr server. Error: %v\", err)\n\t\terr = os.ErrInvalid\n\t}\n\treturn\n}\n\nfunc getServerIPandPort(server string) (string, string, string, error) {\n\thostName := \"\"\n\thostIP := \"\"\n\tport := \"\"\n\tu, err := url.Parse(server)\n\tif err == nil && u.Hostname() != \"\" {\n\t\thostName = u.Hostname()\n\t\tif u.Port() != \"\" {\n\t\t\tport = u.Port()\n\t\t} else {\n\t\t\t// Only implicitly derive port in External client mode.\n\t\t\tif gIsExternalClient {\n\t\t\t\tif u.Scheme == \"http\" {\n\t\t\t\t\tport = \"80\"\n\t\t\t\t} else if u.Scheme == \"https\" {\n\t\t\t\t\tport = \"443\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\thostName, port, err = net.SplitHostPort(server)\n\t\tif err != nil {\n\t\t\thostName = server\n\t\t}\n\t}\n\t_, hostIP, err = ethrLookupIP(hostName)\n\treturn hostName, hostIP, port, err\n}\n\nfunc runClient(testID EthrTestID, title string, clientParam EthrClientParam, server string) {\n\tinitClient(title)\n\thostName, hostIP, port, err := getServerIPandPort(server)\n\tif err != nil {\n\t\treturn\n\t}\n\tip := net.ParseIP(hostIP)\n\tif ip != nil {\n\t\tif ip.To4() != nil {\n\t\t\tgIPVersion = ethrIPv4\n\t\t} else {\n\t\t\tgIPVersion = ethrIPv6\n\t\t}\n\t} else {\n\t\treturn\n\t}\n\n\tif gIsExternalClient {\n\t\tif testID.Protocol != ICMP && port == \"\" {\n\t\t\tui.printErr(\"In external mode, port cannot be empty for TCP tests.\")\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tif port != \"\" {\n\t\t\tui.printErr(\"In client mode, port (%s) cannot be specified in destination (%s).\", port, server)\n\t\t\tui.printMsg(\"Hint: Use external mode (-x).\")\n\t\t\treturn\n\t\t}\n\t\tport = gEthrPortStr\n\t}\n\tui.printMsg(\"Using destination: %s, ip: %s, port: %s\", hostName, hostIP, port)\n\ttest, err := newTest(hostIP, testID, clientParam)\n\tif err != nil {\n\t\tui.printErr(\"Failed to create the new test.\")\n\t\treturn\n\t}\n\ttest.remoteAddr = server\n\ttest.remoteIP = hostIP\n\ttest.remotePort = port\n\tif testID.Protocol == ICMP {\n\t\ttest.dialAddr = hostIP\n\t} else {\n\t\ttest.dialAddr = fmt.Sprintf(\"[%s]:%s\", hostIP, port)\n\t}\n\trunTest(test)\n}\n\nfunc runTest(test *ethrTest) {\n\ttoStop := make(chan int, 16)\n\tstartStatsTimer()\n\tgap := test.clientParam.Gap\n\tduration := test.clientParam.Duration\n\trunDurationTimer(duration, toStop)\n\ttest.isActive = true\n\tif test.testID.Protocol == TCP {\n\t\tif test.testID.Type == Bandwidth {\n\t\t\ttcpRunBandwidthTest(test, toStop)\n\t\t} else if test.testID.Type == Latency {\n\t\t\tgo runTCPLatencyTest(test, gap, toStop)\n\t\t} else if test.testID.Type == Cps {\n\t\t\tgo tcpRunCpsTest(test)\n\t\t} else if test.testID.Type == Ping {\n\t\t\tgo clientRunPingTest(test, gap, test.clientParam.WarmupCount)\n\t\t} else if test.testID.Type == TraceRoute {\n\t\t\tVerifyPermissionForTest(test.testID)\n\t\t\tgo tcpRunTraceRoute(test, gap, toStop)\n\t\t} else if test.testID.Type == MyTraceRoute {\n\t\t\tVerifyPermissionForTest(test.testID)\n\t\t\tgo tcpRunMyTraceRoute(test, gap, toStop)\n\t\t}\n\t} else if test.testID.Protocol == UDP {\n\t\tif test.testID.Type == Bandwidth ||\n\t\t\ttest.testID.Type == Pps {\n\t\t\trunUDPBandwidthAndPpsTest(test)\n\t\t}\n\t} else if test.testID.Protocol == ICMP {\n\t\tVerifyPermissionForTest(test.testID)\n\t\tif test.testID.Type == Ping {\n\t\t\tgo clientRunPingTest(test, gap, test.clientParam.WarmupCount)\n\t\t} else if test.testID.Type == TraceRoute {\n\t\t\tgo icmpRunTraceRoute(test, gap, toStop)\n\t\t} else if test.testID.Type == MyTraceRoute {\n\t\t\tgo icmpRunMyTraceRoute(test, gap, toStop)\n\t\t}\n\t}\n\thandleInterrupt(toStop)\n\treason := <-toStop\n\tstopStatsTimer()\n\tclose(test.done)\n\tif test.testID.Type == Ping {\n\t\ttime.Sleep(2 * time.Second)\n\t}\n\tswitch reason {\n\tcase done:\n\t\tui.printMsg(\"Ethr done, measurement complete.\")\n\tcase timeout:\n\t\tui.printMsg(\"Ethr done, duration: \" + duration.String() + \".\")\n\t\tui.printMsg(\"Hint: Use -d parameter to change duration of the test.\")\n\tcase interrupt:\n\t\tui.printMsg(\"Ethr done, received interrupt signal.\")\n\tcase disconnect:\n\t\tui.printMsg(\"Ethr done, connection terminated.\")\n\t}\n\treturn\n}\n\nfunc tcpRunBandwidthTest(test *ethrTest, toStop chan int) {\n\tvar wg sync.WaitGroup\n\ttcpRunBanwidthTestThreads(test, &wg)\n\tgo func(wg *sync.WaitGroup) {\n\t\twg.Wait()\n\t\ttoStop <- disconnect\n\t}(&wg)\n}\n\nfunc tcpRunBanwidthTestThreads(test *ethrTest, wg *sync.WaitGroup) {\n\tfor th := uint32(0); th < test.clientParam.NumThreads; th++ {\n\t\tconn, err := ethrDialInc(TCP, test.dialAddr, uint16(th))\n\t\tif err != nil {\n\t\t\tui.printErr(\"Error dialing connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\terr = handshakeWithServer(test, conn)\n\t\tif err != nil {\n\t\t\tui.printErr(\"Failed in handshake with the server. Error: %v\", err)\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\t\twg.Add(1)\n\t\tgo runTCPBandwidthTestHandler(test, conn, wg)\n\t}\n}\n\nfunc runTCPBandwidthTestHandler(test *ethrTest, conn net.Conn, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\tec := test.newConn(conn)\n\trserver, rport, _ := net.SplitHostPort(conn.RemoteAddr().String())\n\tlserver, lport, _ := net.SplitHostPort(conn.LocalAddr().String())\n\tui.printMsg(\"[%3d] local %s port %s connected to %s port %s\",\n\t\tec.fd, lserver, lport, rserver, rport)\n\tsize := test.clientParam.BufferSize\n\tbuff := make([]byte, size)\n\tfor i := uint32(0); i < size; i++ {\n\t\tbuff[i] = byte(i)\n\t}\n\tbufferLen := len(buff)\n\ttotalBytesToSend := test.clientParam.BwRate\n\tsentBytes := uint64(0)\n\tstart, waitTime, bytesToSend := beginThrottle(totalBytesToSend, bufferLen)\nExitForLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-test.done:\n\t\t\tbreak ExitForLoop\n\t\tdefault:\n\t\t\tn := 0\n\t\t\tvar err error = nil\n\t\t\tif test.clientParam.Reverse {\n\t\t\t\tn, err = conn.Read(buff)\n\t\t\t} else {\n\t\t\t\tn, err = conn.Write(buff[:bytesToSend])\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tui.printDbg(\"Error sending/receiving data on a connection for bandwidth test: %v\", err)\n\t\t\t\tbreak ExitForLoop\n\t\t\t}\n\t\t\tatomic.AddUint64(&ec.bw, uint64(n))\n\t\t\tatomic.AddUint64(&test.testResult.bw, uint64(n))\n\t\t\tif !test.clientParam.Reverse {\n\t\t\t\tsentBytes += uint64(n)\n\t\t\t\tstart, waitTime, sentBytes, bytesToSend = enforceThrottle(start, waitTime, totalBytesToSend, sentBytes, bufferLen)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc runTCPLatencyTest(test *ethrTest, g time.Duration, toStop chan int) {\n\tui.printMsg(\"Running latency test: %v, %v\", test.clientParam.RttCount, test.clientParam.BufferSize)\n\tconn, err := ethrDial(TCP, test.dialAddr)\n\tif err != nil {\n\t\tui.printErr(\"Error dialing the latency connection: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\terr = handshakeWithServer(test, conn)\n\tif err != nil {\n\t\tui.printErr(\"Failed in handshake with the server. Error: %v\", err)\n\t\treturn\n\t}\n\tui.emitLatencyHdr()\n\tbuffSize := test.clientParam.BufferSize\n\tbuff := make([]byte, buffSize)\n\tfor i := uint32(0); i < buffSize; i++ {\n\t\tbuff[i] = byte(i)\n\t}\n\tblen := len(buff)\n\trttCount := test.clientParam.RttCount\n\tlatencyNumbers := make([]time.Duration, rttCount)\nExitForLoop:\n\tfor {\n\tExitSelect:\n\t\tselect {\n\t\tcase <-test.done:\n\t\t\tbreak ExitForLoop\n\t\tdefault:\n\t\t\tt0 := time.Now()\n\t\t\tfor i := uint32(0); i < rttCount; i++ {\n\t\t\t\ts1 := time.Now()\n\t\t\t\tn, err := conn.Write(buff)\n\t\t\t\tif err != nil || n < blen {\n\t\t\t\t\tui.printDbg(\"Error sending/receiving data on a connection for latency test: %v\", err)\n\t\t\t\t\ttoStop <- disconnect\n\t\t\t\t\tbreak ExitSelect\n\t\t\t\t}\n\t\t\t\t_, err = io.ReadFull(conn, buff)\n\t\t\t\tif err != nil {\n\t\t\t\t\tui.printDbg(\"Error sending/receiving data on a connection for latency test: %v\", err)\n\t\t\t\t\ttoStop <- disconnect\n\t\t\t\t\tbreak ExitSelect\n\t\t\t\t}\n\t\t\t\te2 := time.Since(s1)\n\t\t\t\tlatencyNumbers[i] = e2\n\t\t\t}\n\t\t\t// TODO temp code, fix it better, this is to allow server to do\n\t\t\t// server side latency measurements as well.\n\t\t\t_, _ = conn.Write(buff)\n\t\t\tcalcAndPrintLatency(test, rttCount, latencyNumbers)\n\t\t\tt1 := time.Since(t0)\n\t\t\tif t1 < g {\n\t\t\t\ttime.Sleep(g - t1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc calcAndPrintLatency(test *ethrTest, rttCount uint32, latencyNumbers []time.Duration) {\n\tsum := int64(0)\n\tfor _, d := range latencyNumbers {\n\t\tsum += d.Nanoseconds()\n\t}\n\telapsed := time.Duration(sum / int64(rttCount))\n\tsort.SliceStable(latencyNumbers, func(i, j int) bool {\n\t\treturn latencyNumbers[i] < latencyNumbers[j]\n\t})\n\t//\n\t// Special handling for rttCount == 1. This prevents negative index\n\t// in the latencyNumber index. The other option is to use\n\t// roundUpToZero() but that is more expensive.\n\t//\n\trttCountFixed := rttCount\n\tif rttCountFixed == 1 {\n\t\trttCountFixed = 2\n\t}\n\tavg := elapsed\n\tmin := latencyNumbers[0]\n\tmax := latencyNumbers[rttCount-1]\n\tp50 := latencyNumbers[((rttCountFixed*50)/100)-1]\n\tp90 := latencyNumbers[((rttCountFixed*90)/100)-1]\n\tp95 := latencyNumbers[((rttCountFixed*95)/100)-1]\n\tp99 := latencyNumbers[((rttCountFixed*99)/100)-1]\n\tp999 := latencyNumbers[uint64(((float64(rttCountFixed)*99.9)/100)-1)]\n\tp9999 := latencyNumbers[uint64(((float64(rttCountFixed)*99.99)/100)-1)]\n\tui.emitLatencyResults(\n\t\ttest.session.remoteIP,\n\t\tprotoToString(test.testID.Protocol),\n\t\tavg, min, max, p50, p90, p95, p99, p999, p9999)\n}\n\nfunc tcpRunCpsTest(test *ethrTest) {\n\tfor th := uint32(0); th < test.clientParam.NumThreads; th++ {\n\t\tgo func(th uint32) {\n\t\tExitForLoop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-test.done:\n\t\t\t\t\tbreak ExitForLoop\n\t\t\t\tdefault:\n\t\t\t\t\tconn, err := ethrDialAll(TCP, test.dialAddr)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tatomic.AddUint64(&test.testResult.cps, 1)\n\t\t\t\t\t\ttcpconn, ok := conn.(*net.TCPConn)\n\t\t\t\t\t\tif ok {\n\t\t\t\t\t\t\ttcpconn.SetLinger(0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tui.printDbg(\"Unable to dial TCP connection to %s, error: %v\", test.dialAddr, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(th)\n\t}\n}\n\nfunc clientRunPingTest(test *ethrTest, g time.Duration, warmupCount uint32) {\n\t// TODO: Override NumThreads for now, fix it later to support parallel\n\t// threads.\n\ttest.clientParam.NumThreads = 1\n\tfor th := uint32(0); th < test.clientParam.NumThreads; th++ {\n\t\tgo func() {\n\t\t\tvar sent, rcvd, lost uint32\n\t\t\twarmupText := \"[warmup] \"\n\t\t\tlatencyNumbers := make([]time.Duration, 0)\n\t\tExitForLoop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-test.done:\n\t\t\t\t\tprintConnectionLatencyResults(test.dialAddr, test, sent, rcvd, lost, latencyNumbers)\n\t\t\t\t\tbreak ExitForLoop\n\t\t\t\tdefault:\n\t\t\t\t\tt0 := time.Now()\n\t\t\t\t\tif warmupCount > 0 {\n\t\t\t\t\t\twarmupCount--\n\t\t\t\t\t\tclientRunPing(test, warmupText)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsent++\n\t\t\t\t\t\tlatency, err := clientRunPing(test, \"\")\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\trcvd++\n\t\t\t\t\t\t\tlatencyNumbers = append(latencyNumbers, latency)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlost++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif rcvd >= 1000 {\n\t\t\t\t\t\tprintConnectionLatencyResults(test.dialAddr, test, sent, rcvd, lost, latencyNumbers)\n\t\t\t\t\t\tlatencyNumbers = make([]time.Duration, 0)\n\t\t\t\t\t\tsent, rcvd, lost = 0, 0, 0\n\t\t\t\t\t}\n\t\t\t\t\tt1 := time.Since(t0)\n\t\t\t\t\tif t1 < g {\n\t\t\t\t\t\ttime.Sleep(g - t1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc clientRunPing(test *ethrTest, prefix string) (time.Duration, error) {\n\tif test.testID.Protocol == TCP {\n\t\treturn tcpRunPing(test, prefix)\n\t} else {\n\t\treturn icmpRunPing(test, prefix)\n\t}\n}\n\nfunc tcpRunPing(test *ethrTest, prefix string) (timeTaken time.Duration, err error) {\n\tt0 := time.Now()\n\tconn, err := ethrDial(TCP, test.dialAddr)\n\tif err != nil {\n\t\tui.printMsg(\"[tcp] %sConnection to %s: Timed out (%v)\", prefix, test.dialAddr, err)\n\t\treturn\n\t}\n\ttimeTaken = time.Since(t0)\n\trserver, rport, _ := net.SplitHostPort(conn.RemoteAddr().String())\n\tlserver, lport, _ := net.SplitHostPort(conn.LocalAddr().String())\n\tui.printMsg(\"[tcp] %sConnection from [%s]:%s to [%s]:%s: %s\",\n\t\tprefix, lserver, lport, rserver, rport, durationToString(timeTaken))\n\ttcpconn, ok := conn.(*net.TCPConn)\n\tif ok {\n\t\ttcpconn.SetLinger(0)\n\t}\n\tconn.Close()\n\treturn\n}\n\nfunc printConnectionLatencyResults(server string, test *ethrTest, sent, rcvd, lost uint32, latencyNumbers []time.Duration) {\n\tfmt.Println(\"-----------------------------------------------------------------------------------------\")\n\tui.printMsg(\"TCP connect statistics for %s:\", server)\n\tui.printMsg(\"  Sent = %d, Received = %d, Lost = %d\", sent, rcvd, lost)\n\tif rcvd > 0 {\n\t\tui.emitLatencyHdr()\n\t\tcalcAndPrintLatency(test, rcvd, latencyNumbers)\n\t\tfmt.Println(\"-----------------------------------------------------------------------------------------\")\n\t}\n}\n\nfunc tcpRunTraceRoute(test *ethrTest, gap time.Duration, toStop chan int) {\n\ttcpRunTraceRouteInternal(test, gap, toStop, false)\n}\n\nfunc tcpRunMyTraceRoute(test *ethrTest, gap time.Duration, toStop chan int) {\n\ttcpRunTraceRouteInternal(test, gap, toStop, true)\n}\n\nfunc tcpRunTraceRouteInternal(test *ethrTest, gap time.Duration, toStop chan int, mtrMode bool) {\n\tgHop = make([]ethrHopData, gMaxHops)\n\terr := tcpDiscoverHops(test, mtrMode)\n\tif err != nil {\n\t\tui.printErr(\"Destination %s is not responding to TCP connection.\", test.session.remoteIP)\n\t\tui.printErr(\"Terminating tracing...\")\n\t\ttoStop <- interrupt\n\t\treturn\n\t}\n\tif !mtrMode {\n\t\ttoStop <- done\n\t\treturn\n\t}\n\tfor i := 0; i < gCurHops; i++ {\n\t\tif gHop[i].addr != \"\" {\n\t\t\tgo tcpProbeHop(test, gap, i)\n\t\t}\n\t}\n}\n\nfunc tcpProbeHop(test *ethrTest, gap time.Duration, hop int) {\n\tseq := 0\nExitForLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-test.done:\n\t\t\tbreak ExitForLoop\n\t\tdefault:\n\t\t\tt0 := time.Now()\n\t\t\terr, _ := tcpProbe(test, hop+1, gHop[hop].addr, &gHop[hop])\n\t\t\tif err == nil {\n\t\t\t}\n\t\t\tseq++\n\t\t\tt1 := time.Since(t0)\n\t\t\tif t1 < gap {\n\t\t\t\ttime.Sleep(gap - t1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc tcpDiscoverHops(test *ethrTest, mtrMode bool) error {\n\tui.printMsg(\"Tracing route to %s over %d hops:\", test.session.remoteIP, gMaxHops)\n\tfor i := 0; i < gMaxHops; i++ {\n\t\tvar hopData ethrHopData\n\t\terr, isLast := tcpProbe(test, i+1, \"\", &hopData)\n\t\tif err == nil {\n\t\t\thopData.name, hopData.fullName = lookupHopName(hopData.addr)\n\t\t}\n\t\tif hopData.addr != \"\" {\n\t\t\tif mtrMode {\n\t\t\t\tui.printMsg(\"%2d.|--%s\", i+1, hopData.addr+\" [\"+hopData.fullName+\"]\")\n\t\t\t} else {\n\t\t\t\tui.printMsg(\"%2d.|--%-70s %s\", i+1, hopData.addr+\" [\"+hopData.fullName+\"]\", durationToString(hopData.last))\n\t\t\t}\n\t\t} else {\n\t\t\tui.printMsg(\"%2d.|--%s\", i+1, \"???\")\n\t\t}\n\t\tcopyInitialHopData(i, hopData)\n\t\tif isLast {\n\t\t\tgCurHops = i + 1\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn os.ErrNotExist\n}\n\nfunc tcpProbe(test *ethrTest, hop int, hopIP string, hopData *ethrHopData) (error, bool) {\n\tisLast := false\n\tc, err := IcmpNewConn(test.remoteIP)\n\tif err != nil {\n\t\tui.printErr(\"Failed to create ICMP connection. Error: %v\", err)\n\t\treturn err, isLast\n\t}\n\tdefer c.Close()\n\tlocalPortNum := uint16(8888)\n\tif gClientPort != 0 {\n\t\tlocalPortNum = gClientPort\n\t}\n\tlocalPortNum += uint16(hop)\n\tb := make([]byte, 4)\n\tbinary.BigEndian.PutUint16(b[0:], localPortNum)\n\tremotePortNum, err := strconv.ParseUint(test.remotePort, 10, 16)\n\tbinary.BigEndian.PutUint16(b[2:], uint16(remotePortNum))\n\tpeerAddrChan := make(chan string)\n\tendTimeChan := make(chan time.Time)\n\tgo func() {\n\t\tpeerAddr, _, _ := icmpRecvMsg(c, TCP, time.Second*2, hopIP, b, nil, 0)\n\t\tendTimeChan <- time.Now()\n\t\tpeerAddrChan <- peerAddr\n\t}()\n\tstartTime := time.Now()\n\tconn, err := ethrDialEx(TCP, test.dialAddr, gLocalIP, localPortNum, hop, int(gTOS))\n\tif err != nil {\n\t\tui.printDbg(\"Failed to Dial the connection. Error: %v\", err)\n\t} else {\n\t\tconn.Close()\n\t}\n\thopData.sent++\n\tpeerAddr := \"\"\n\tendTime := time.Now()\n\tif err == nil {\n\t\tisLast = true\n\t\tpeerAddr = test.remoteIP\n\t} else {\n\t\tendTime = <-endTimeChan\n\t\tpeerAddr = <-peerAddrChan\n\t}\n\telapsed := endTime.Sub(startTime)\n\tif peerAddr == \"\" || (hopIP != \"\" && peerAddr != hopIP) {\n\t\thopData.lost++\n\t\tui.printDbg(\"Neither connection completed, nor ICMP TTL exceeded received.\")\n\t\treturn os.ErrNotExist, isLast\n\t}\n\tgenHopData(hopData, peerAddr, elapsed)\n\treturn nil, isLast\n}\n\ntype ethrHopData struct {\n\taddr     string\n\tsent     uint32\n\trcvd     uint32\n\tlost     uint32\n\tlast     time.Duration\n\tbest     time.Duration\n\tworst    time.Duration\n\ttotal    time.Duration\n\tname     string\n\tfullName string\n}\n\nvar gMaxHops int = 30\nvar gCurHops int\nvar gHop []ethrHopData\n\nfunc icmpRunPing(test *ethrTest, prefix string) (time.Duration, error) {\n\tdstIPAddr, _, err := ethrLookupIP(test.dialAddr)\n\tif err != nil {\n\t\treturn time.Second, err\n\t}\n\n\tvar hopData ethrHopData\n\terr, isLast := icmpProbe(test, dstIPAddr, time.Second, \"\", &hopData, 254, 255)\n\tif err != nil {\n\t\tui.printMsg(\"[icmp] %sPing to %s: %v\", prefix, test.dialAddr, err)\n\t\treturn time.Second, err\n\t}\n\tif !isLast {\n\t\tui.printMsg(\"[icmp] %sPing to %s: %s\",\n\t\t\tprefix, test.dialAddr, \"Non-EchoReply Received.\")\n\t\treturn time.Second, os.ErrNotExist\n\t}\n\tui.printMsg(\"[icmp] %sPing to %s: %s\",\n\t\tprefix, test.dialAddr, durationToString(hopData.last))\n\treturn hopData.last, nil\n}\n\nfunc icmpRunTraceRoute(test *ethrTest, gap time.Duration, toStop chan int) {\n\ticmpRunTraceRouteInternal(test, gap, toStop, false)\n}\n\nfunc icmpRunMyTraceRoute(test *ethrTest, gap time.Duration, toStop chan int) {\n\ticmpRunTraceRouteInternal(test, gap, toStop, true)\n}\n\nfunc icmpRunTraceRouteInternal(test *ethrTest, gap time.Duration, toStop chan int, mtrMode bool) {\n\tgHop = make([]ethrHopData, gMaxHops)\n\tdstIPAddr, _, err := ethrLookupIP(test.session.remoteIP)\n\tif err != nil {\n\t\ttoStop <- interrupt\n\t\treturn\n\t}\n\terr = icmpDiscoverHops(test, dstIPAddr, mtrMode)\n\tif err != nil {\n\t\tui.printErr(\"Destination %s is not responding to ICMP Echo.\", test.session.remoteIP)\n\t\tui.printErr(\"Terminating tracing...\")\n\t\ttoStop <- interrupt\n\t\treturn\n\t}\n\tif !mtrMode {\n\t\ttoStop <- done\n\t\treturn\n\t}\n\tfor i := 0; i < gCurHops; i++ {\n\t\tif gHop[i].addr != \"\" {\n\t\t\tgo icmpProbeHop(test, gap, i, dstIPAddr)\n\t\t}\n\t}\n}\n\nfunc copyInitialHopData(hop int, hopData ethrHopData) {\n\tgHop[hop].addr = hopData.addr\n\tgHop[hop].best = hopData.last\n\tgHop[hop].name = hopData.name\n\tgHop[hop].fullName = hopData.fullName\n}\n\nfunc genHopData(hopData *ethrHopData, peerAddr string, elapsed time.Duration) {\n\thopData.addr = peerAddr\n\thopData.last = elapsed\n\tif hopData.best > elapsed {\n\t\thopData.best = elapsed\n\t}\n\tif hopData.worst < elapsed {\n\t\thopData.worst = elapsed\n\t}\n\thopData.total += elapsed\n\thopData.rcvd++\n}\n\nfunc lookupHopName(addr string) (string, string) {\n\tname := \"\"\n\ttname := \"\"\n\tif addr == \"\" {\n\t\treturn tname, name\n\t}\n\tnames, err := net.LookupAddr(addr)\n\tif err == nil && len(names) > 0 {\n\t\tname = names[0]\n\t\tsz := len(name)\n\n\t\tif sz > 0 && name[sz-1] == '.' {\n\t\t\tname = name[:sz-1]\n\t\t}\n\t\ttname = truncateStringFromEnd(name, 16)\n\t}\n\treturn tname, name\n}\n\nfunc icmpDiscoverHops(test *ethrTest, dstIPAddr net.IPAddr, mtrMode bool) error {\n\tif test.session.remoteIP == dstIPAddr.String() {\n\t\tui.printMsg(\"Tracing route to %s over %d hops:\", test.session.remoteIP, gMaxHops)\n\t} else {\n\t\tui.printMsg(\"Tracing route to %s (%s) over %d hops:\", test.session.remoteIP, dstIPAddr.String(), gMaxHops)\n\t}\n\tfor i := 0; i < gMaxHops; i++ {\n\t\tvar hopData ethrHopData\n\t\terr, isLast := icmpProbe(test, dstIPAddr, time.Second*2, \"\", &hopData, i, 1)\n\t\tif err == nil {\n\t\t\thopData.name, hopData.fullName = lookupHopName(hopData.addr)\n\t\t}\n\t\tif hopData.addr != \"\" {\n\t\t\tif mtrMode {\n\t\t\t\tui.printMsg(\"%2d.|--%s\", i+1, hopData.addr+\" [\"+hopData.fullName+\"]\")\n\t\t\t} else {\n\t\t\t\tui.printMsg(\"%2d.|--%-70s %s\", i+1, hopData.addr+\" [\"+hopData.fullName+\"]\", durationToString(hopData.last))\n\t\t\t}\n\t\t} else {\n\t\t\tui.printMsg(\"%2d.|--%s\", i+1, \"???\")\n\t\t}\n\t\tcopyInitialHopData(i, hopData)\n\t\tif isLast {\n\t\t\tgCurHops = i + 1\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn os.ErrNotExist\n}\n\nfunc icmpProbeHop(test *ethrTest, gap time.Duration, hop int, dstIPAddr net.IPAddr) {\n\tseq := 0\nExitForLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-test.done:\n\t\t\tbreak ExitForLoop\n\t\tdefault:\n\t\t\tt0 := time.Now()\n\t\t\terr, _ := icmpProbe(test, dstIPAddr, time.Second, gHop[hop].addr, &gHop[hop], hop, seq)\n\t\t\tif err == nil {\n\t\t\t}\n\t\t\tseq++\n\t\t\tt1 := time.Since(t0)\n\t\t\tif t1 < gap {\n\t\t\t\ttime.Sleep(gap - t1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc icmpProbe(test *ethrTest, dstIPAddr net.IPAddr, icmpTimeout time.Duration, hopIP string, hopData *ethrHopData, hop, seq int) (error, bool) {\n\tisLast := false\n\techoMsg := fmt.Sprintf(\"Hello: Ethr - %v\", hop)\n\n\tc, err := IcmpNewConn(test.remoteIP)\n\tif err != nil {\n\t\tui.printErr(\"Failed to create ICMP connection. Error: %v\", err)\n\t\treturn err, isLast\n\t}\n\tdefer c.Close()\n\tstart, wb, err := icmpSendMsg(c, dstIPAddr, hop, seq, echoMsg, icmpTimeout)\n\tif err != nil {\n\t\treturn err, isLast\n\t}\n\thopData.sent++\n\tneededSeq := hop<<8 | seq\n\tpeerAddr, isLast, err := icmpRecvMsg(c, ICMP, icmpTimeout, hopIP, wb[4:8], []byte(echoMsg), neededSeq)\n\tif err != nil {\n\t\thopData.lost++\n\t\tui.printDbg(\"Failed to receive ICMP reply packet. Error: %v\", err)\n\t\treturn err, isLast\n\t}\n\telapsed := time.Since(start)\n\tgenHopData(hopData, peerAddr, elapsed)\n\treturn nil, isLast\n}\n\nfunc icmpSetTTL(c net.PacketConn, ttl int) error {\n\terr := os.ErrInvalid\n\tif gIPVersion == ethrIPv4 {\n\t\tcIPv4 := ipv4.NewPacketConn(c)\n\t\terr = cIPv4.SetTTL(ttl)\n\t} else if gIPVersion == ethrIPv6 {\n\t\tcIPv6 := ipv6.NewPacketConn(c)\n\t\terr = cIPv6.SetHopLimit(ttl)\n\t}\n\treturn err\n}\n\nfunc icmpSetTOS(c net.PacketConn, tos int) error {\n\tif tos == 0 {\n\t\treturn nil\n\t}\n\terr := os.ErrInvalid\n\tif gIPVersion == ethrIPv4 {\n\t\tcIPv4 := ipv4.NewPacketConn(c)\n\t\terr = cIPv4.SetTOS(tos)\n\t} else if gIPVersion == ethrIPv6 {\n\t\tcIPv6 := ipv6.NewPacketConn(c)\n\t\terr = cIPv6.SetTrafficClass(tos)\n\t}\n\treturn err\n}\n\nfunc icmpSendMsg(c net.PacketConn, dstIPAddr net.IPAddr, hop, seq int, body string, timeout time.Duration) (time.Time, []byte, error) {\n\tstart := time.Now()\n\terr := icmpSetTTL(c, hop+1)\n\tif err != nil {\n\t\tui.printErr(\"Failed to set TTL. Error: %v\", err)\n\t\treturn start, nil, err\n\t}\n\ticmpSetTOS(c, int(gTOS))\n\n\terr = c.SetDeadline(time.Now().Add(timeout))\n\tif err != nil {\n\t\tui.printErr(\"Failed to set Deadline. Error: %v\", err)\n\t\treturn start, nil, err\n\t}\n\n\tpid := os.Getpid() & 0xffff\n\tpid = 9999\n\twm := icmp.Message{\n\t\tType: ipv4.ICMPTypeEcho, Code: 0,\n\t\tBody: &icmp.Echo{\n\t\t\tID: pid, Seq: hop<<8 | seq,\n\t\t\tData: []byte(body),\n\t\t},\n\t}\n\tif gIPVersion == ethrIPv6 {\n\t\twm.Type = ipv6.ICMPTypeEchoRequest\n\t}\n\twb, err := wm.Marshal(nil)\n\tif err != nil {\n\t\tui.printErr(\"Failed to Marshal data. Error: %v\", err)\n\t\treturn start, nil, err\n\t}\n\tstart = time.Now()\n\tif _, err := c.WriteTo(wb, &dstIPAddr); err != nil {\n\t\tui.printErr(\"Failed to send ICMP data. Error: %v\", err)\n\t\treturn start, nil, err\n\t}\n\treturn start, wb, nil\n}\n\nfunc icmpRecvMsg(c net.PacketConn, proto EthrProtocol, timeout time.Duration, neededPeer string, neededSig []byte, neededIcmpBody []byte, neededIcmpSeq int) (string, bool, error) {\n\tpeerAddr := \"\"\n\tisLast := false\n\terr := c.SetDeadline(time.Now().Add(timeout))\n\tif err != nil {\n\t\tui.printErr(\"Failed to set Deadline. Error: %v\", err)\n\t\treturn peerAddr, isLast, err\n\t}\n\tfor {\n\t\tpeerAddr = \"\"\n\t\tb := make([]byte, 1500)\n\t\tn, peer, err := c.ReadFrom(b)\n\t\tif err != nil {\n\t\t\tif proto == ICMP {\n\t\t\t\t// In case of non-ICMP TraceRoute, it is expected that no packet is received\n\t\t\t\t// in some case, e.g. when packet reach final hop and TCP connection establishes.\n\t\t\t\tui.printDbg(\"Failed to receive ICMP packet. Error: %v\", err)\n\t\t\t}\n\t\t\treturn peerAddr, isLast, err\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tui.printDbg(\"Packet:\\n%s\", hex.Dump(b[:n]))\n\t\tui.printDbg(\"Finding Pattern\\n%v\", hex.Dump(neededSig[:4]))\n\t\tpeerAddr = peer.String()\n\t\tif neededPeer != \"\" && peerAddr != neededPeer {\n\t\t\tui.printDbg(\"Matching peer is not found.\")\n\t\t\tcontinue\n\t\t}\n\t\ticmpMsg, err := icmp.ParseMessage(IcmpProto(), b[:n])\n\t\tif err != nil {\n\t\t\tui.printDbg(\"Failed to parse ICMP message: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif icmpMsg.Type == ipv4.ICMPTypeTimeExceeded || icmpMsg.Type == ipv6.ICMPTypeTimeExceeded {\n\t\t\tbody := icmpMsg.Body.(*icmp.TimeExceeded).Data\n\t\t\tindex := bytes.Index(body, neededSig[:4])\n\t\t\tif index > 0 {\n\t\t\t\tif proto == TCP {\n\t\t\t\t\tui.printDbg(\"Found correct ICMP error message. PeerAddr: %v\", peerAddr)\n\t\t\t\t\treturn peerAddr, isLast, nil\n\t\t\t\t} else if proto == ICMP {\n\t\t\t\t\tif index < 4 {\n\t\t\t\t\t\tui.printDbg(\"Incorrect length of ICMP message.\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tinnerIcmpMsg, _ := icmp.ParseMessage(IcmpProto(), body[index-4:])\n\t\t\t\t\tswitch innerIcmpMsg.Body.(type) {\n\t\t\t\t\tcase *icmp.Echo:\n\t\t\t\t\t\tseq := innerIcmpMsg.Body.(*icmp.Echo).Seq\n\t\t\t\t\t\tif seq == neededIcmpSeq {\n\t\t\t\t\t\t\treturn peerAddr, isLast, nil\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Ignore as this is not the right ICMP packet.\n\t\t\t\t\t\tui.printDbg(\"Unable to recognize packet.\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tui.printDbg(\"Pattern %v not found.\", hex.Dump(neededSig[:4]))\n\t\t\t}\n\t\t}\n\n\t\tif proto == ICMP && (icmpMsg.Type == ipv4.ICMPTypeEchoReply || icmpMsg.Type == ipv6.ICMPTypeEchoReply) {\n\t\t\techo := icmpMsg.Body.(*icmp.Echo)\n\t\t\tethrUnused(echo)\n\t\t\tb, _ := icmpMsg.Body.Marshal(1)\n\t\t\tif string(b[4:]) != string(neededIcmpBody) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tisLast = true\n\t\t\treturn peerAddr, isLast, nil\n\t\t}\n\t}\n}\n\nfunc runUDPBandwidthAndPpsTest(test *ethrTest) {\n\tfor th := uint32(0); th < test.clientParam.NumThreads; th++ {\n\t\tgo func(th uint32) {\n\t\t\tsize := test.clientParam.BufferSize\n\t\t\tbuff := make([]byte, size)\n\t\t\tconn, err := ethrDialInc(UDP, test.dialAddr, uint16(th))\n\t\t\tif err != nil {\n\t\t\t\tui.printDbg(\"Unable to dial UDP, error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer conn.Close()\n\t\t\tec := test.newConn(conn)\n\t\t\trserver, rport, _ := net.SplitHostPort(conn.RemoteAddr().String())\n\t\t\tlserver, lport, _ := net.SplitHostPort(conn.LocalAddr().String())\n\t\t\tui.printMsg(\"[%3d] local %s port %s connected to %s port %s\",\n\t\t\t\tec.fd, lserver, lport, rserver, rport)\n\t\t\tbufferLen := len(buff)\n\t\t\ttotalBytesToSend := test.clientParam.BwRate\n\t\t\tsentBytes := uint64(0)\n\t\t\tstart, waitTime, bytesToSend := beginThrottle(totalBytesToSend, bufferLen)\n\t\tExitForLoop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-test.done:\n\t\t\t\t\tbreak ExitForLoop\n\t\t\t\tdefault:\n\t\t\t\t\tn, err := conn.Write(buff[:bytesToSend])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tui.printDbg(\"%v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif n < bytesToSend {\n\t\t\t\t\t\tui.printDbg(\"Partial write: %d\", n)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tatomic.AddUint64(&ec.bw, uint64(n))\n\t\t\t\t\tatomic.AddUint64(&ec.pps, 1)\n\t\t\t\t\tatomic.AddUint64(&test.testResult.bw, uint64(n))\n\t\t\t\t\tatomic.AddUint64(&test.testResult.pps, 1)\n\t\t\t\t\tif !test.clientParam.Reverse {\n\t\t\t\t\t\tsentBytes += uint64(n)\n\t\t\t\t\t\tstart, waitTime, sentBytes, bytesToSend = enforceThrottle(start, waitTime, totalBytesToSend, sentBytes, bufferLen)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(th)\n\t}\n}\n"
        },
        {
          "name": "clientui.go",
          "type": "blob",
          "size": 6.4697265625,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype clientUI struct {\n\ttitle string\n}\n\nfunc (u *clientUI) fini() {\n}\n\nfunc (u *clientUI) getTitle() string {\n\treturn u.title\n}\n\nfunc (u *clientUI) printMsg(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tlogInfo(s)\n\tfmt.Println(s)\n}\n\nfunc (u *clientUI) printErr(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tlogError(s)\n\tfmt.Println(s)\n}\n\nfunc (u *clientUI) printDbg(format string, a ...interface{}) {\n\tif loggingLevel == LogLevelDebug {\n\t\ts := fmt.Sprintf(format, a...)\n\t\tlogDebug(s)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc (u *clientUI) paint(seconds uint64) {\n}\n\nfunc (u *clientUI) emitTestResultBegin() {\n}\n\nfunc (u *clientUI) emitTestHdr() {\n\ts := []string{\"ServerAddress\", \"Proto\", \"Bits/s\", \"Conn/s\", \"Pkt/s\"}\n\tfmt.Println(\"-----------------------------------------------------------\")\n\tfmt.Printf(\"%-15s %-5s %7s %7s %7s\\n\", s[0], s[1], s[2], s[3], s[4])\n}\n\nfunc (u *clientUI) emitLatencyHdr() {\n\ts := []string{\"Avg\", \"Min\", \"50%\", \"90%\", \"95%\", \"99%\", \"99.9%\", \"99.99%\", \"Max\"}\n\tfmt.Println(\"-----------------------------------------------------------------------------------------\")\n\tfmt.Printf(\"%9s %9s %9s %9s %9s %9s %9s %9s %9s\\n\", s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8])\n}\n\nfunc (u *clientUI) emitLatencyResults(remote, proto string, avg, min, max, p50, p90, p95, p99, p999, p9999 time.Duration) {\n\tlogLatency(remote, proto, avg, min, max, p50, p90, p95, p99, p999, p9999)\n\tfmt.Printf(\"%9s %9s %9s %9s %9s %9s %9s %9s %9s\\n\",\n\t\tdurationToString(avg), durationToString(min),\n\t\tdurationToString(p50), durationToString(p90),\n\t\tdurationToString(p95), durationToString(p99),\n\t\tdurationToString(p999), durationToString(p9999),\n\t\tdurationToString(max))\n}\n\nfunc (u *clientUI) emitTestResultEnd() {\n}\n\nfunc (u *clientUI) emitStats(netStats ethrNetStat) {\n}\n\nfunc (u *clientUI) printTestResults(s []string) {\n}\n\nfunc initClientUI(title string) {\n\tcli := &clientUI{title}\n\tui = cli\n}\n\nvar gInterval uint64\nvar gNoConnectionStats bool\n\nfunc printBwTestDivider(p EthrProtocol) {\n\tif p == TCP {\n\t\tui.printMsg(\"- - - - - - - - - - - - - - - - - - - - - - -\")\n\t} else if p == UDP {\n\t\tui.printMsg(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\")\n\t}\n}\n\nfunc printBwTestHeader(p EthrProtocol) {\n\tif p == TCP {\n\t\tui.printMsg(\"[  ID ]   Protocol    Interval      Bits/s\")\n\t} else if p == UDP {\n\t\t// Printing packets only makes sense for UDP as it is a datagram protocol.\n\t\t// For TCP, TCP itself decides how to chunk the stream to send as packets.\n\t\tui.printMsg(\"[  ID ]   Protocol    Interval      Bits/s    Pkts/s\")\n\t}\n}\n\nfunc printBwTestResult(p EthrProtocol, fd string, t0, t1, bw, pps uint64) {\n\tif p == TCP {\n\t\tui.printMsg(\"[%5s]     %-5s    %03d-%03d sec   %7s\", fd,\n\t\t\tprotoToString(p), t0, t1, bytesToRate(bw))\n\t} else if p == UDP {\n\t\tui.printMsg(\"[%5s]     %-5s    %03d-%03d sec   %7s   %7s\", fd,\n\t\t\tprotoToString(p), t0, t1, bytesToRate(bw), ppsToString(pps))\n\t}\n}\n\nfunc printTestResult(test *ethrTest, seconds uint64) {\n\tif test.testID.Type == Bandwidth &&\n\t\t(test.testID.Protocol == TCP || test.testID.Protocol == UDP) {\n\t\tif gInterval == 0 {\n\t\t\tprintBwTestDivider(test.testID.Protocol)\n\t\t\tprintBwTestHeader(test.testID.Protocol)\n\t\t}\n\t\tcbw := uint64(0)\n\t\tcpps := uint64(0)\n\t\tccount := 0\n\t\ttest.connListDo(func(ec *ethrConn) {\n\t\t\tbw := atomic.SwapUint64(&ec.bw, 0)\n\t\t\tpps := atomic.SwapUint64(&ec.pps, 0)\n\t\t\tbw /= seconds\n\t\t\tif !gNoConnectionStats {\n\t\t\t\tfd := fmt.Sprintf(\"%5d\", ec.fd)\n\t\t\t\tprintBwTestResult(test.testID.Protocol, fd, gInterval, gInterval+1, bw, pps)\n\t\t\t}\n\t\t\tcbw += bw\n\t\t\tcpps += pps\n\t\t\tccount++\n\t\t})\n\t\tif ccount > 1 || gNoConnectionStats {\n\t\t\tprintBwTestResult(test.testID.Protocol, \"SUM\", gInterval, gInterval+1, cbw, cpps)\n\t\t\tif !gNoConnectionStats {\n\t\t\t\tprintBwTestDivider(test.testID.Protocol)\n\t\t\t}\n\t\t}\n\t\tlogResults([]string{test.session.remoteIP, protoToString(test.testID.Protocol),\n\t\t\tbytesToRate(cbw), \"\", ppsToString(cpps), \"\"})\n\t} else if test.testID.Type == Cps {\n\t\tif gInterval == 0 {\n\t\t\tui.printMsg(\"- - - - - - - - - - - - - - - - - - \")\n\t\t\tui.printMsg(\"Protocol    Interval      Conn/s\")\n\t\t}\n\t\tcps := atomic.SwapUint64(&test.testResult.cps, 0)\n\t\tui.printMsg(\"  %-5s    %03d-%03d sec   %7s\",\n\t\t\tprotoToString(test.testID.Protocol),\n\t\t\tgInterval, gInterval+1, cpsToString(cps))\n\t\tlogResults([]string{test.session.remoteIP, protoToString(test.testID.Protocol),\n\t\t\t\"\", cpsToString(cps), \"\", \"\"})\n\t} else if test.testID.Type == Pps {\n\t\tif gInterval == 0 {\n\t\t\tui.printMsg(\"- - - - - - - - - - - - - - - - - - - - - - -\")\n\t\t\tui.printMsg(\"Protocol    Interval      Bits/s    Pkts/s\")\n\t\t}\n\t\tbw := atomic.SwapUint64(&test.testResult.bw, 0)\n\t\tpps := atomic.SwapUint64(&test.testResult.pps, 0)\n\t\tui.printMsg(\"  %-5s    %03d-%03d sec   %7s   %7s\",\n\t\t\tprotoToString(test.testID.Protocol),\n\t\t\tgInterval, gInterval+1, bytesToRate(bw), ppsToString(pps))\n\t\tlogResults([]string{test.session.remoteIP, protoToString(test.testID.Protocol),\n\t\t\tbytesToRate(bw), \"\", ppsToString(pps), \"\"})\n\t} else if test.testID.Type == MyTraceRoute {\n\t\tif gCurHops > 0 {\n\t\t\tui.printMsg(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \")\n\t\t\tui.printMsg(\"Host: %-40s    Sent    Recv        Last         Avg        Best        Wrst\", test.session.remoteIP)\n\t\t}\n\t\tfor i := 0; i < gCurHops; i++ {\n\t\t\thopData := gHop[i]\n\t\t\tif hopData.addr != \"\" {\n\t\t\t\tif hopData.sent > 0 {\n\t\t\t\t\tavg := time.Duration(0)\n\t\t\t\t\tif hopData.rcvd > 0 {\n\t\t\t\t\t\tavg = time.Duration(hopData.total.Nanoseconds() / int64(hopData.rcvd))\n\t\t\t\t\t}\n\t\t\t\t\tui.printMsg(\"%2d.|--%-40s   %5d   %5d   %9s   %9s   %9s   %9s\", i+1, hopData.addr, hopData.sent, hopData.rcvd,\n\t\t\t\t\t\tdurationToString(hopData.last), durationToString(avg), durationToString(hopData.best), durationToString(hopData.worst))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tui.printMsg(\"%2d.|--%-40s   %5s   %5s   %9s   %9s   %9s   %9s\", i+1, \"???\", \"-\", \"-\", \"-\", \"-\", \"-\", \"-\")\n\t\t\t}\n\t\t}\n\t}\n\tgInterval++\n}\n\nfunc (u *clientUI) emitTestResult(s *ethrSession, proto EthrProtocol, seconds uint64) {\n\tvar testList = []EthrTestType{Bandwidth, Cps, Pps, TraceRoute, MyTraceRoute}\n\n\tfor _, testType := range testList {\n\t\ttest, found := s.tests[EthrTestID{proto, testType}]\n\t\tif found && test.isActive {\n\t\t\tprintTestResult(test, seconds)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ethr.go",
          "type": "blob",
          "size": 15.75,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst defaultLogFileName = \"./ethrs.log for server, ./ethrc.log for client\"\nconst latencyDefaultBufferLenStr = \"1B\"\nconst defaultBufferLenStr = \"16KB\"\n\nvar (\n\tgVersion     string\n\tloggingLevel LogLevel = LogLevelInfo\n)\n\nfunc main() {\n\t//\n\t// If version is not set via ldflags, then default to UNKNOWN\n\t//\n\tif gVersion == \"\" {\n\t\tgVersion = \"UNKNOWN\"\n\t}\n\n\tfmt.Println(\"\\nEthr: Comprehensive Network Performance Measurement Tool (Version: \" + gVersion + \")\")\n\tfmt.Println(\"Maintainer: Pankaj Garg (ipankajg @ LinkedIn | GitHub | Gmail | Twitter)\")\n\tfmt.Println(\"\")\n\n\t//\n\t// Set GOMAXPROCS to 1024 as running large number of goroutines that send\n\t// data in a tight loop over network is resulting in unfair time allocation\n\t// across goroutines causing starvation of many TCP connections. Using a\n\t// higher number of threads via GOMAXPROCS solves this problem.\n\t//\n\truntime.GOMAXPROCS(1024)\n\n\t// Common\n\tflag.Usage = func() { ethrUsage() }\n\tnoOutput := flag.Bool(\"no\", false, \"\")\n\toutputFile := flag.String(\"o\", defaultLogFileName, \"\")\n\tdebug := flag.Bool(\"debug\", false, \"\")\n\tuse4 := flag.Bool(\"4\", false, \"\")\n\tuse6 := flag.Bool(\"6\", false, \"\")\n\tport := flag.Int(\"port\", 8888, \"\")\n\tip := flag.String(\"ip\", \"\", \"\")\n\t// Server\n\tisServer := flag.Bool(\"s\", false, \"\")\n\tshowUI := flag.Bool(\"ui\", false, \"\")\n\t// Client & External Client\n\tclientDest := flag.String(\"c\", \"\", \"\")\n\tbufLenStr := flag.String(\"l\", \"\", \"\")\n\tbwRateStr := flag.String(\"b\", \"\", \"\")\n\tcport := flag.Int(\"cport\", 0, \"\")\n\tduration := flag.Duration(\"d\", 10*time.Second, \"\")\n\tgap := flag.Duration(\"g\", time.Second, \"\")\n\titerCount := flag.Int(\"i\", 1000, \"\")\n\tncs := flag.Bool(\"ncs\", false, \"\")\n\tprotocol := flag.String(\"p\", \"tcp\", \"\")\n\treverse := flag.Bool(\"r\", false, \"\")\n\ttestTypePtr := flag.String(\"t\", \"\", \"\")\n\ttos := flag.Int(\"tos\", 0, \"\")\n\ttitle := flag.String(\"T\", \"\", \"\")\n\tthCount := flag.Int(\"n\", 1, \"\")\n\twc := flag.Int(\"w\", 1, \"\")\n\txClientDest := flag.String(\"x\", \"\", \"\")\n\n\tflag.Parse()\n\n\tif *isServer {\n\t\tif *clientDest != \"\" {\n\t\t\tprintUsageError(\"Invalid arguments, \\\"-c\\\" cannot be used with \\\"-s\\\".\")\n\t\t}\n\t\tif *xClientDest != \"\" {\n\t\t\tprintUsageError(\"Invalid arguments, \\\"-x\\\" cannot be used with \\\"-s\\\".\")\n\t\t}\n\t\tif *bufLenStr != \"\" {\n\t\t\tprintServerModeArgError(\"l\")\n\t\t}\n\t\tif *bwRateStr != \"\" {\n\t\t\tprintServerModeArgError(\"b\")\n\t\t}\n\t\tif *cport != 0 {\n\t\t\tprintServerModeArgError(\"cport\")\n\t\t}\n\t\tif *duration != 10*time.Second {\n\t\t\tprintServerModeArgError(\"d\")\n\t\t}\n\t\tif *gap != time.Second {\n\t\t\tprintServerModeArgError(\"g\")\n\t\t}\n\t\tif *iterCount != 1000 {\n\t\t\tprintServerModeArgError(\"i\")\n\t\t}\n\t\tif *ncs {\n\t\t\tprintServerModeArgError(\"ncs\")\n\t\t}\n\t\tif *protocol != \"tcp\" {\n\t\t\tprintServerModeArgError(\"p\")\n\t\t}\n\t\tif *reverse {\n\t\t\tprintServerModeArgError(\"r\")\n\t\t}\n\t\tif *testTypePtr != \"\" {\n\t\t\tprintServerModeArgError(\"t\")\n\t\t}\n\t\tif *tos != 0 {\n\t\t\tprintServerModeArgError(\"tos\")\n\t\t}\n\t\tif *thCount != 1 {\n\t\t\tprintServerModeArgError(\"n\")\n\t\t}\n\t\tif *wc != 1 {\n\t\t\tprintServerModeArgError(\"wc\")\n\t\t}\n\t\tif *title != \"\" {\n\t\t\tprintServerModeArgError(\"T\")\n\t\t}\n\t} else if *clientDest != \"\" || *xClientDest != \"\" {\n\t\tif *clientDest != \"\" && *xClientDest != \"\" {\n\t\t\tprintUsageError(\"Invalid argument, both \\\"-c\\\" and \\\"-x\\\" cannot be specified at the same time.\")\n\t\t}\n\t\tif *showUI {\n\t\t\tprintUsageError(fmt.Sprintf(\"Invalid argument, \\\"-%s\\\" can only be used in server (\\\"-s\\\") mode.\", \"ui\"))\n\t\t}\n\t} else {\n\t\tprintUsageError(\"Invalid arguments, use either \\\"-s\\\" or \\\"-c\\\".\")\n\t}\n\n\t// Process common parameters.\n\n\tif *debug {\n\t\tloggingLevel = LogLevelDebug\n\t}\n\n\tif *use4 && !*use6 {\n\t\tgIPVersion = ethrIPv4\n\t} else if *use6 && !*use4 {\n\t\tgIPVersion = ethrIPv6\n\t}\n\n\tif *ip != \"\" {\n\t\tgLocalIP = *ip\n\t\tipAddr := net.ParseIP(gLocalIP)\n\t\tif ipAddr == nil {\n\t\t\tprintUsageError(fmt.Sprintf(\"Invalid IP address: <%s> specified.\", *ip))\n\t\t}\n\t\tif (gIPVersion == ethrIPv4 && ipAddr.To4() == nil) || (gIPVersion == ethrIPv6 && ipAddr.To16() == nil) {\n\t\t\tprintUsageError(fmt.Sprintf(\"Invalid IP address version: <%s> specified.\", *ip))\n\t\t}\n\t}\n\tgEthrPort = uint16(*port)\n\tgEthrPortStr = fmt.Sprintf(\"%d\", gEthrPort)\n\n\tlogFileName := *outputFile\n\tif !*noOutput {\n\t\tif logFileName == defaultLogFileName {\n\t\t\tif *isServer {\n\t\t\t\tlogFileName = \"ethrs.log\"\n\t\t\t} else {\n\t\t\t\tlogFileName = \"ethrc.log\"\n\t\t\t}\n\t\t}\n\t\tlogInit(logFileName)\n\t}\n\n\tvar testType EthrTestType\n\tvar destination string\n\tif *isServer {\n\t\t// Server side parameter processing.\n\t\ttestType = All\n\t\tserverParam := ethrServerParam{*showUI}\n\t\trunServer(serverParam)\n\t} else {\n\t\tgIsExternalClient = false\n\t\tdestination = *clientDest\n\t\tif *xClientDest != \"\" {\n\t\t\tgIsExternalClient = true\n\t\t\tdestination = *xClientDest\n\t\t}\n\t\tgNoConnectionStats = *ncs\n\t\ttestType = getTestType(*testTypePtr)\n\t\tproto := getProtocol(*protocol)\n\n\t\t// Default latency test to 1B if length is not specified\n\t\tswitch *bufLenStr {\n\t\tcase \"\":\n\t\t\t*bufLenStr = getDefaultBufferLenStr(*testTypePtr)\n\t\t}\n\t\tbufLen := unitToNumber(*bufLenStr)\n\t\tif bufLen == 0 {\n\t\t\tprintUsageError(fmt.Sprintf(\"Invalid length specified: %s\" + *bufLenStr))\n\t\t}\n\n\t\t// Check specific bwRate if any.\n\t\tbwRate := uint64(0)\n\t\tif *bwRateStr != \"\" {\n\t\t\tbwRate = unitToNumber(*bwRateStr)\n\t\t\tbwRate /= 8\n\t\t}\n\n\t\t//\n\t\t// For Pkt/s, we always override the buffer size to be just 1 byte.\n\t\t// TODO: Evaluate in future, if we need to support > 1 byte packets for\n\t\t//       Pkt/s testing.\n\t\t//\n\t\tif testType == Pps {\n\t\t\tbufLen = 1\n\t\t}\n\n\t\tif *iterCount <= 0 {\n\t\t\tprintUsageError(fmt.Sprintf(\"Invalid iteration count for latency test: %d\", *iterCount))\n\t\t}\n\n\t\tif *thCount <= 0 {\n\t\t\t*thCount = runtime.NumCPU()\n\t\t}\n\n\t\tgClientPort = uint16(*cport)\n\n\t\ttestId := EthrTestID{EthrProtocol(proto), testType}\n\t\tclientParam := EthrClientParam{\n\t\t\tuint32(*thCount),\n\t\t\tuint32(bufLen),\n\t\t\tuint32(*iterCount),\n\t\t\t*reverse,\n\t\t\t*duration,\n\t\t\t*gap,\n\t\t\tuint32(*wc),\n\t\t\tuint64(bwRate),\n\t\t\tuint8(*tos)}\n\t\tvalidateClientParams(testId, clientParam)\n\n\t\trServer := destination\n\t\trunClient(testId, *title, clientParam, rServer)\n\t}\n}\n\nfunc getProtocol(protoStr string) (proto EthrProtocol) {\n\tp := strings.ToUpper(protoStr)\n\tproto = TCP\n\tswitch p {\n\tcase \"TCP\":\n\t\tproto = TCP\n\tcase \"UDP\":\n\t\tproto = UDP\n\tcase \"ICMP\":\n\t\tproto = ICMP\n\tdefault:\n\t\tprintUsageError(fmt.Sprintf(\"Invalid value \\\"%s\\\" specified for parameter \\\"-p\\\".\\n\"+\n\t\t\t\"Valid parameters and values are:\\n\", protoStr))\n\t}\n\treturn\n}\n\nfunc getTestType(testTypeStr string) (testType EthrTestType) {\n\tswitch testTypeStr {\n\tcase \"\":\n\t\tif gIsExternalClient {\n\t\t\ttestType = Ping\n\t\t} else {\n\t\t\ttestType = Bandwidth\n\t\t}\n\tcase \"b\":\n\t\ttestType = Bandwidth\n\tcase \"c\":\n\t\ttestType = Cps\n\tcase \"p\":\n\t\ttestType = Pps\n\tcase \"l\":\n\t\ttestType = Latency\n\tcase \"pi\":\n\t\ttestType = Ping\n\tcase \"tr\":\n\t\ttestType = TraceRoute\n\tcase \"mtr\":\n\t\ttestType = MyTraceRoute\n\tdefault:\n\t\tprintUsageError(fmt.Sprintf(\"Invalid value \\\"%s\\\" specified for parameter \\\"-t\\\".\\n\"+\n\t\t\t\"Valid parameters and values are:\\n\", testTypeStr))\n\t}\n\treturn\n}\n\nfunc getDefaultBufferLenStr(testTypePtr string) string {\n\tif testTypePtr == \"l\" {\n\t\treturn latencyDefaultBufferLenStr\n\t}\n\treturn defaultBufferLenStr\n}\n\nfunc validateClientParams(testID EthrTestID, clientParam EthrClientParam) {\n\tif !gIsExternalClient {\n\t\tvalidateClientTest(testID, clientParam)\n\t} else {\n\t\tvalidateExtModeClientTest(testID)\n\t}\n}\n\nfunc validateClientTest(testID EthrTestID, clientParam EthrClientParam) {\n\ttestType := testID.Type\n\tprotocol := testID.Protocol\n\tswitch protocol {\n\tcase TCP:\n\t\tif testType != Bandwidth && testType != Cps && testType != Latency && testType != Ping && testType != TraceRoute && testType != MyTraceRoute {\n\t\t\temitUnsupportedTest(testID)\n\t\t}\n\t\tif clientParam.Reverse && testType != Bandwidth {\n\t\t\tprintReverseModeError()\n\t\t}\n\t\tif clientParam.BufferSize > 2*GIGA {\n\t\t\tprintUsageError(\"Maximum allowed value for \\\"-l\\\" for TCP is 2GB.\")\n\t\t}\n\tcase UDP:\n\t\tif testType != Bandwidth && testType != Pps {\n\t\t\temitUnsupportedTest(testID)\n\t\t}\n\t\tif testType == Bandwidth {\n\t\t\tif clientParam.BufferSize > (64 * 1024) {\n\t\t\t\tprintUsageError(\"Maximum supported buffer size for UDP is 64K\\n\")\n\t\t\t}\n\t\t}\n\t\tif clientParam.Reverse {\n\t\t\tprintReverseModeError()\n\t\t}\n\t\tif clientParam.BufferSize > 64*KILO {\n\t\t\tprintUsageError(\"Maximum allowed value for \\\"-l\\\" for TCP is 64KB.\")\n\t\t}\n\tdefault:\n\t\temitUnsupportedTest(testID)\n\t}\n}\n\nfunc validateExtModeClientTest(testID EthrTestID) {\n\ttestType := testID.Type\n\tprotocol := testID.Protocol\n\tswitch protocol {\n\tcase TCP:\n\t\tif testType != Ping && testType != Cps && testType != TraceRoute && testType != MyTraceRoute {\n\t\t\temitUnsupportedTest(testID)\n\t\t}\n\tcase ICMP:\n\t\tif testType != Ping && testType != TraceRoute && testType != MyTraceRoute {\n\t\t\temitUnsupportedTest(testID)\n\t\t}\n\tdefault:\n\t\temitUnsupportedTest(testID)\n\t}\n}\n\nfunc printServerModeArgError(arg string) {\n\tprintUsageError(fmt.Sprintf(\"Invalid argument, \\\"-%s\\\" can only be used in client (\\\"-c\\\") mode.\", arg))\n}\n\nfunc emitUnsupportedTest(testID EthrTestID) {\n\tprintUsageError(fmt.Sprintf(\"Test: \\\"%s\\\" for Protocol: \\\"%s\\\" is not supported.\\n\",\n\t\ttestToString(testID.Type), protoToString(testID.Protocol)))\n}\n\nfunc printReverseModeError() {\n\tprintUsageError(\"Reverse mode (-r) is only supported for TCP Bandwidth tests.\")\n}\n\nfunc printUsageError(s string) {\n\tfmt.Printf(\"Error: %s\\n\", s)\n\tfmt.Printf(\"Please use \\\"ethr -h\\\" for complete list of command line arguments.\\n\")\n\tos.Exit(1)\n}\n\n// ethrUsage prints the command-line usage text\nfunc ethrUsage() {\n\tfmt.Println(\"Ethr supports three modes. Usage of each mode is described below:\")\n\n\tfmt.Println(\"\\nCommon Parameters\")\n\tfmt.Println(\"================================================================================\")\n\tprintFlagUsage(\"h\", \"\", \"Help\")\n\tprintFlagUsage(\"no\", \"\", \"Disable logging to file. Logging to file is enabled by default.\")\n\tprintFlagUsage(\"o\", \"<filename>\", \"Name of log file. By default, following file names are used:\",\n\t\t\"Server mode: 'ethrs.log'\",\n\t\t\"Client mode: 'ethrc.log'\")\n\tprintFlagUsage(\"debug\", \"\", \"Enable debug information in logging output.\")\n\tprintFlagUsage(\"4\", \"\", \"Use only IP v4 version\")\n\tprintFlagUsage(\"6\", \"\", \"Use only IP v6 version\")\n\n\tfmt.Println(\"\\nMode: Server\")\n\tfmt.Println(\"================================================================================\")\n\tfmt.Println(\"In this mode, Ethr runs as a server, allowing multiple clients to run\")\n\tfmt.Println(\"performance tests against it.\")\n\tprintServerUsage()\n\tprintIPUsage()\n\tprintPortUsage()\n\tprintFlagUsage(\"ui\", \"\", \"Show output in text UI.\")\n\n\tfmt.Println(\"\\nMode: Client\")\n\tfmt.Println(\"================================================================================\")\n\tfmt.Println(\"In this mode, Ethr client can only talk to an Ethr server.\")\n\tprintClientUsage()\n\tprintBwRateUsage()\n\tprintCPortUsage()\n\tprintDurationUsage()\n\tprintGapUsage()\n\tprintIterationUsage()\n\tprintIPUsage()\n\tprintBufLenUsage()\n\tprintThreadUsage()\n\tprintProtocolUsage()\n\tprintPortUsage()\n\tprintFlagUsage(\"r\", \"\", \"For Bandwidth tests, send data from server to client.\")\n\tprintTestType()\n\tprintToSUsage()\n\tprintWarmupUsage()\n\tprintTitleUsage()\n\n\tfmt.Println(\"\\nMode: External\")\n\tfmt.Println(\"================================================================================\")\n\tfmt.Println(\"In this mode, Ethr talks to a non-Ethr server. This mode supports only a\")\n\tfmt.Println(\"few types of measurements, such as Ping, Connections/s and TraceRoute.\")\n\tprintExtClientUsage()\n\tprintCPortUsage()\n\tprintDurationUsage()\n\tprintGapUsage()\n\tprintIPUsage()\n\tprintThreadUsage()\n\tprintExtProtocolUsage()\n\tprintExtTestType()\n\tprintToSUsage()\n\tprintWarmupUsage()\n\tprintTitleUsage()\n}\n\nfunc printFlagUsage(flag, info string, helptext ...string) {\n\tfmt.Printf(\"\\t-%s %s\\n\", flag, info)\n\tfor _, help := range helptext {\n\t\tfmt.Printf(\"\\t\\t%s\\n\", help)\n\t}\n}\n\nfunc printServerUsage() {\n\tprintFlagUsage(\"s\", \"\", \"Run in server mode.\")\n}\n\nfunc printClientUsage() {\n\tprintFlagUsage(\"c\", \"<server>\", \"Run in client mode and connect to <server>.\",\n\t\t\"Server is specified using name, FQDN or IP address.\")\n}\n\nfunc printExtClientUsage() {\n\tprintFlagUsage(\"x\", \"<destination>\", \"Run in external client mode and connect to <destination>.\",\n\t\t\"<destination> is specified in URL or Host:Port format.\",\n\t\t\"For URL, if port is not specified, it is assumed to be 80 for http and 443 for https.\",\n\t\t\"Example: For TCP - www.microsoft.com:443 or 10.1.0.4:22 or https://www.github.com\",\n\t\t\"         For ICMP - www.microsoft.com or 10.1.0.4\")\n}\n\nfunc printPortUsage() {\n\tprintFlagUsage(\"port\", \"<number>\", \"Use specified port number for TCP & UDP tests.\",\n\t\t\"Default: 8888\")\n}\n\nfunc printTestType() {\n\tprintFlagUsage(\"t\", \"<test>\", \"Test to run (\\\"b\\\", \\\"c\\\", \\\"p\\\", \\\"l\\\", \\\"cl\\\" or \\\"tr\\\")\",\n\t\t\"b: Bandwidth\",\n\t\t\"c: Connections/s\",\n\t\t\"p: Packets/s\",\n\t\t\"l: Latency, Loss & Jitter\",\n\t\t\"pi: Ping Loss & Latency\",\n\t\t\"tr: TraceRoute\",\n\t\t\"mtr: MyTraceRoute with Loss & Latency\",\n\t\t\"Default: b - Bandwidth measurement.\")\n}\n\nfunc printExtTestType() {\n\tprintFlagUsage(\"t\", \"<test>\", \"Test to run (\\\"c\\\", \\\"cl\\\", or \\\"tr\\\")\",\n\t\t\"c: Connections/s\",\n\t\t\"pi: Ping Loss & Latency\",\n\t\t\"tr: TraceRoute\",\n\t\t\"mtr: MyTraceRoute with Loss & Latency\",\n\t\t\"Default: pi - Ping Loss & Latency.\")\n}\n\nfunc printThreadUsage() {\n\tprintFlagUsage(\"n\", \"<number>\", \"Number of Parallel Sessions (and Threads).\",\n\t\t\"0: Equal to number of CPUs\",\n\t\t\"Default: 1\")\n}\n\nfunc printDurationUsage() {\n\tprintFlagUsage(\"d\", \"<duration>\",\n\t\t\"Duration for the test (format: <num>[ms | s | m | h]\",\n\t\t\"0: Run forever\",\n\t\t\"Default: 10s\")\n}\n\nfunc printGapUsage() {\n\tprintFlagUsage(\"g\", \"<gap>\",\n\t\t\"Time interval between successive measurements (format: <num>[ms | s | m | h]\",\n\t\t\"Only valid for latency, ping and traceRoute tests.\",\n\t\t\"0: No gap\",\n\t\t\"Default: 1s\")\n}\n\nfunc printBufLenUsage() {\n\tprintFlagUsage(\"l\", \"<length>\",\n\t\t\"Length of buffer (in Bytes) to use (format: <num>[KB | MB | GB])\",\n\t\t\"Only valid for Bandwidth tests. Max 1GB.\",\n\t\t\"Default: 16KB\")\n}\n\nfunc printProtocolUsage() {\n\tprintFlagUsage(\"p\", \"<protocol>\",\n\t\t\"Protocol (\\\"tcp\\\", \\\"udp\\\", \\\"http\\\", \\\"https\\\", or \\\"icmp\\\")\",\n\t\t\"Default: tcp\")\n}\n\nfunc printExtProtocolUsage() {\n\tprintFlagUsage(\"p\", \"<protocol>\",\n\t\t\"Protocol (\\\"tcp\\\", or \\\"icmp\\\")\",\n\t\t\"Default: tcp\")\n}\n\nfunc printIterationUsage() {\n\tprintFlagUsage(\"i\", \"<iterations>\",\n\t\t\"Number of round trip iterations for each latency measurement.\",\n\t\t\"Only valid for latency testing.\",\n\t\t\"Default: 1000\")\n}\n\nfunc printNoConnStatUsage() {\n\tprintFlagUsage(\"ncs\", \"\",\n\t\t\"No per Connection Stats would be printed if this flag is specified.\",\n\t\t\"This is useful to suppress verbose logging when large number of\",\n\t\t\"connections are used as specified by -n option for Bandwidth tests.\")\n}\n\nfunc printIgnoreCertUsage() {\n\tprintFlagUsage(\"ic\", \"\",\n\t\t\"Ignore Certificate is useful for HTTPS tests, for cases where a\",\n\t\t\"middle box like a proxy is not able to supply a valid Ethr cert.\")\n}\n\nfunc printWarmupUsage() {\n\tprintFlagUsage(\"w\", \"<number>\", \"Use specified number of iterations for warmup.\",\n\t\t\"Default: 1\")\n}\n\nfunc printToSUsage() {\n\tprintFlagUsage(\"tos\", \"\",\n\t\t\"Specifies 8-bit value to use in IPv4 TOS field or IPv6 Traffic Class field.\")\n}\n\nfunc printBwRateUsage() {\n\tprintFlagUsage(\"b\", \"<rate>\",\n\t\t\"Transmit only Bits per second (format: <num>[K | M | G])\",\n\t\t\"Only valid for Bandwidth tests. Default: 0 - Unlimited\",\n\t\t\"Examples: 100 (100bits/s), 1M (1Mbits/s).\")\n}\n\nfunc printCPortUsage() {\n\tprintFlagUsage(\"cport\", \"<number>\", \"Use specified local port number in client for TCP & UDP tests.\",\n\t\t\"Default: 0 - Ephemeral Port\")\n}\n\nfunc printIPUsage() {\n\tprintFlagUsage(\"ip\", \"<string>\", \"Bind to specified local IP address for TCP & UDP tests.\",\n\t\t\"This must be a valid IPv4 or IPv6 address.\",\n\t\t\"Default: <empty> - Any IP\")\n}\n\nfunc printTitleUsage() {\n\tprintFlagUsage(\"T\", \"<string>\",\n\t\t\"Use the given title in log files for logging results.\",\n\t\t\"Default: <empty>\")\n}\n"
        },
        {
          "name": "ethr.nuspec",
          "type": "blob",
          "size": 0.8017578125,
          "content": "<?xml version=\"1.0\"?>\n<package >\n  <metadata>\n    <id>Ethr</id>\n    <version>0.2.1</version>\n    <authors>Pankaj Garg</authors>\n    <owners>Pankaj Garg</owners>\n    <projectUrl>https://github.com/microsoft/ethr</projectUrl>\n    <requireLicenseAcceptance>false</requireLicenseAcceptance>\n    <description>Ethr is a Network Performance Measurement Tool for TCP, UDP and HTTP.</description>\n    <releaseNotes>This version supports many new options and features described below:\n\t    1> -4 or -6 to use specific IP version\n\t    2> Reverse mode for TCP\n\t    3> HTTPS support\n\t    4> External mode for server and client\n\t    5> Many more features and options</releaseNotes>\n    <copyright>Copyright 2020</copyright>\n    <tags>Network Performance</tags>\n  </metadata>\n  <files>\n    <file src=\"ethr.exe\" />\n  </files>\n</package>\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.203125,
          "content": "module github.com/microsoft/ethr\n\nrequire (\n\tgithub.com/mattn/go-runewidth v0.0.9\n\tgithub.com/nsf/termbox-go v0.0.0-20200418040025-38ba6e5628f1\n\tgolang.org/x/sys v0.0.0-20200918174421-af09f7315aff\n)\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.5947265625,
          "content": "github.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/nsf/termbox-go v0.0.0-20200418040025-38ba6e5628f1 h1:lh3PyZvY+B9nFliSGTn5uFuqQQJGuNrD0MLCokv09ag=\ngithub.com/nsf/termbox-go v0.0.0-20200418040025-38ba6e5628f1/go.mod h1:IuKpRQcYE1Tfu+oAQqaLisqDeXgjyyltCfsaoYN18NQ=\ngolang.org/x/sys v0.0.0-20200918174421-af09f7315aff h1:1CPUrky56AcgSpxz/KfgzQWzfG09u5YOL8MvPYBlrL8=\ngolang.org/x/sys v0.0.0-20200918174421-af09f7315aff/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 3.3681640625,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\n// LogLevel specifies the logging level to use in both screen and\n// file-based logging\ntype LogLevel int\n\nconst (\n\tLogLevelInfo LogLevel = iota\n\tLogLevelDebug\n)\n\ntype logMessage struct {\n\tTime    string\n\tTitle   string\n\tType    string\n\tMessage string\n}\n\ntype logLatencyData struct {\n\tTime       string\n\tTitle      string\n\tType       string\n\tRemoteAddr string\n\tProtocol   string\n\tAvg        string\n\tMin        string\n\tP50        string\n\tP90        string\n\tP95        string\n\tP99        string\n\tP999       string\n\tP9999      string\n\tMax        string\n}\n\ntype logTestResults struct {\n\tTime                 string\n\tTitle                string\n\tType                 string\n\tRemoteAddr           string\n\tProtocol             string\n\tBitsPerSecond        string\n\tConnectionsPerSecond string\n\tPacketsPerSecond     string\n\tAverageLatency       string\n}\n\nvar loggingActive = false\nvar logChan = make(chan string, 64)\n\nfunc logInit(fileName string) {\n\tif fileName == \"\" {\n\t\treturn\n\t}\n\tlogFile, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)\n\tif err != nil {\n\t\tfmt.Printf(\"Unable to open the log file %s, Error: %v\\n\", fileName, err)\n\t\treturn\n\t}\n\tlog.SetFlags(0)\n\tlog.SetOutput(logFile)\n\tloggingActive = true\n\tgo runLogger(logFile)\n}\n\nfunc logFini() {\n\tloggingActive = false\n}\n\nfunc runLogger(logFile *os.File) {\n\tfor loggingActive {\n\t\ts := <-logChan\n\t\tlog.Println(s)\n\t}\n\tlogFile.Close()\n}\n\nfunc logMsg(prefix, msg string) {\n\tif loggingActive {\n\t\tlogData := logMessage{}\n\t\tlogData.Time = time.Now().UTC().Format(time.RFC3339)\n\t\tlogData.Title = ui.getTitle()\n\t\tlogData.Type = prefix\n\t\tlogData.Message = msg\n\t\tlogJSON, _ := json.Marshal(logData)\n\t\tlogChan <- string(logJSON)\n\t}\n}\n\nfunc logInfo(msg string) {\n\tlogMsg(\"INFO\", msg)\n}\n\nfunc logError(msg string) {\n\tlogMsg(\"ERROR\", msg)\n}\n\nfunc logDebug(msg string) {\n\tlogMsg(\"DEBUG\", msg)\n}\n\nfunc logResults(s []string) {\n\tif loggingActive {\n\t\tlogData := logTestResults{}\n\t\tlogData.Time = time.Now().UTC().Format(time.RFC3339)\n\t\tlogData.Title = ui.getTitle()\n\t\tlogData.Type = \"TestResult\"\n\t\tlogData.RemoteAddr = s[0]\n\t\tlogData.Protocol = s[1]\n\t\tlogData.BitsPerSecond = s[2]\n\t\tlogData.ConnectionsPerSecond = s[3]\n\t\tlogData.PacketsPerSecond = s[4]\n\t\tlogData.AverageLatency = s[5]\n\t\tlogJSON, _ := json.Marshal(logData)\n\t\tlogChan <- string(logJSON)\n\t}\n}\n\nfunc logLatency(remoteIP, proto string, avg, min, p50, p90, p95, p99, p999, p9999, max time.Duration) {\n\tif loggingActive {\n\t\tlogData := logLatencyData{}\n\t\tlogData.Time = time.Now().UTC().Format(time.RFC3339)\n\t\tlogData.Title = ui.getTitle()\n\t\tlogData.Type = \"LatencyResult\"\n\t\tlogData.RemoteAddr = remoteIP\n\t\tlogData.Protocol = proto\n\t\tlogData.Avg = durationToString(avg)\n\t\tlogData.Min = durationToString(min)\n\t\tlogData.P50 = durationToString(p50)\n\t\tlogData.P90 = durationToString(p90)\n\t\tlogData.P95 = durationToString(p95)\n\t\tlogData.P99 = durationToString(p99)\n\t\tlogData.P999 = durationToString(p999)\n\t\tlogData.P9999 = durationToString(p9999)\n\t\tlogData.Max = durationToString(max)\n\t\tlogJSON, _ := json.Marshal(logData)\n\t\tlogChan <- string(logJSON)\n\t}\n}\n"
        },
        {
          "name": "plt_darwin.go",
          "type": "blob",
          "size": 13.1865234375,
          "content": "// +build darwin\n\n//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"net\"\n\t\"syscall\"\n\n\ttm \"github.com/nsf/termbox-go\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc getNetDevStats(stats *ethrNetStat) {\n\tifs, err := net.Interfaces()\n\tif err != nil {\n\t\tui.printErr(\"%v\", err)\n\t\treturn\n\t}\n\n\tfor _, iface := range ifs {\n\t\tif iface.Flags&net.FlagUp == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tifaceData, err := getIfaceData(iface.Index)\n\t\tif err != nil {\n\t\t\tui.printErr(\"Failed to load data for interface %q: %v\", iface.Name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tstats.netDevStats = append(stats.netDevStats, ethrNetDevStat{\n\t\t\tinterfaceName: iface.Name,\n\t\t\trxBytes:       ifaceData.Data.Ibytes,\n\t\t\trxPkts:        ifaceData.Data.Ipackets,\n\t\t\ttxBytes:       ifaceData.Data.Obytes,\n\t\t\ttxPkts:        ifaceData.Data.Opackets,\n\t\t})\n\t}\n}\n\nfunc getTCPStats(stats *ethrNetStat) {\n\tvar data tcpStat\n\trawData, err := unix.SysctlRaw(\"net.inet.tcp.stats\")\n\tif err != nil {\n\t\t// return EthrTCPStat{}, errors.Wrap(err, \"GetTCPStats: could not get net.inet.tcp.stats\")\n\t\treturn\n\t}\n\tbuf := bytes.NewReader(rawData)\n\tbinary.Read(buf, binary.LittleEndian, &data)\n\n\t// return EthrTCPStat{uint64(data.Sndrexmitpack)}, nil\n\t// return the TCP Retransmits\n\tstats.tcpStats.segRetrans = uint64(data.Sndrexmitpack)\n\treturn\n}\n\nfunc hideCursor() {\n\ttm.SetCursor(0, 0)\n}\n\nfunc blockWindowResize() {\n}\n\nfunc getIfaceData(index int) (*ifMsghdr2, error) {\n\tvar data ifMsghdr2\n\trawData, err := unix.SysctlRaw(\"net\", unix.AF_ROUTE, 0, 0, unix.NET_RT_IFLIST2, index)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = binary.Read(bytes.NewReader(rawData), binary.LittleEndian, &data)\n\treturn &data, err\n}\n\ntype ifMsghdr2 struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tAddrs     int32\n\tFlags     int32\n\tIndex     uint16\n\t_         [2]byte\n\tSndLen    int32\n\tSndMaxlen int32\n\tSndDrops  int32\n\tTimer     int32\n\tData      ifData64\n}\n\ntype ifData64 struct {\n\tType       uint8\n\tTypelen    uint8\n\tPhysical   uint8\n\tAddrlen    uint8\n\tHdrlen     uint8\n\tRecvquota  uint8\n\tXmitquota  uint8\n\tUnused1    uint8\n\tMtu        uint32\n\tMetric     uint32\n\tBaudrate   uint64\n\tIpackets   uint64\n\tIerrors    uint64\n\tOpackets   uint64\n\tOerrors    uint64\n\tCollisions uint64\n\tIbytes     uint64\n\tObytes     uint64\n\tImcasts    uint64\n\tOmcasts    uint64\n\tIqdrops    uint64\n\tNoproto    uint64\n\tRecvtiming uint32\n\tXmittiming uint32\n\tLastchange unix.Timeval32\n}\n\ntype tcpStat struct {\n\tConnattempt                      uint32\n\tAccepts                          uint32\n\tConnects                         uint32\n\tDrops                            uint32\n\tConndrops                        uint32\n\tClosed                           uint32\n\tSegstimed                        uint32\n\tRttupdated                       uint32\n\tDelack                           uint32\n\tTimeoutdrop                      uint32\n\tRexmttimeo                       uint32\n\tPersisttimeo                     uint32\n\tKeeptimeo                        uint32\n\tKeepprobe                        uint32\n\tKeepdrops                        uint32\n\tSndtotal                         uint32\n\tSndpack                          uint32\n\tSndbyte                          uint32\n\tSndrexmitpack                    uint32\n\tSndrexmitbyte                    uint32\n\tSndacks                          uint32\n\tSndprobe                         uint32\n\tSndurg                           uint32\n\tSndwinup                         uint32\n\tSndctrl                          uint32\n\tRcvtotal                         uint32\n\tRcvpack                          uint32\n\tRcvbyte                          uint32\n\tRcvbadsum                        uint32\n\tRcvbadoff                        uint32\n\tRcvmemdrop                       uint32\n\tRcvshort                         uint32\n\tRcvduppack                       uint32\n\tRcvdupbyte                       uint32\n\tRcvpartduppack                   uint32\n\tRcvpartdupbyte                   uint32\n\tRcvoopack                        uint32\n\tRcvoobyte                        uint32\n\tRcvpackafterwin                  uint32\n\tRcvbyteafterwin                  uint32\n\tRcvafterclose                    uint32\n\tRcvwinprobe                      uint32\n\tRcvdupack                        uint32\n\tRcvacktoomuch                    uint32\n\tRcvackpack                       uint32\n\tRcvackbyte                       uint32\n\tRcvwinupd                        uint32\n\tPawsdrop                         uint32\n\tPredack                          uint32\n\tPreddat                          uint32\n\tPcbcachemiss                     uint32\n\tCachedrtt                        uint32\n\tCachedrttvar                     uint32\n\tCachedssthresh                   uint32\n\tUsedrtt                          uint32\n\tUsedrttvar                       uint32\n\tUsedssthresh                     uint32\n\tPersistdrop                      uint32\n\tBadsyn                           uint32\n\tMturesent                        uint32\n\tListendrop                       uint32\n\tMinmssdrops                      uint32\n\tSndrexmitbad                     uint32\n\tBadrst                           uint32\n\tSc_added                         uint32\n\tSc_retransmitted                 uint32\n\tSc_dupsyn                        uint32\n\tSc_dropped                       uint32\n\tSc_completed                     uint32\n\tSc_bucketoverflow                uint32\n\tSc_cacheoverflow                 uint32\n\tSc_reset                         uint32\n\tSc_stale                         uint32\n\tSc_aborted                       uint32\n\tSc_badack                        uint32\n\tSc_unreach                       uint32\n\tSc_zonefail                      uint32\n\tSc_sendcookie                    uint32\n\tSc_recvcookie                    uint32\n\tHc_added                         uint32\n\tHc_bucketoverflow                uint32\n\tSack_recovery_episode            uint32\n\tSack_rexmits                     uint32\n\tSack_rexmit_bytes                uint32\n\tSack_rcv_blocks                  uint32\n\tSack_send_blocks                 uint32\n\tSack_sboverflow                  uint32\n\tBg_rcvtotal                      uint32\n\tRxtfindrop                       uint32\n\tFcholdpacket                     uint32\n\tCoalesced_pack                   uint32\n\tFlowtbl_full                     uint32\n\tFlowtbl_collision                uint32\n\tLro_twopack                      uint32\n\tLro_multpack                     uint32\n\tLro_largepack                    uint32\n\tLimited_txt                      uint32\n\tEarly_rexmt                      uint32\n\tSack_ackadv                      uint32\n\tRcv_swcsum                       uint32\n\tRcv_swcsum_bytes                 uint32\n\tRcv6_swcsum                      uint32\n\tRcv6_swcsum_bytes                uint32\n\tSnd_swcsum                       uint32\n\tSnd_swcsum_bytes                 uint32\n\tSnd6_swcsum                      uint32\n\tSnd6_swcsum_bytes                uint32\n\tMsg_unopkts                      uint32\n\tMsg_unoappendfail                uint32\n\tMsg_sndwaithipri                 uint32\n\tInvalid_mpcap                    uint32\n\tInvalid_joins                    uint32\n\tMpcap_fallback                   uint32\n\tJoin_fallback                    uint32\n\tEstab_fallback                   uint32\n\tInvalid_opt                      uint32\n\tMp_outofwin                      uint32\n\tMp_reducedwin                    uint32\n\tMp_badcsum                       uint32\n\tMp_oodata                        uint32\n\tMp_switches                      uint32\n\tMp_rcvtotal                      uint32\n\tMp_rcvbytes                      uint32\n\tMp_sndpacks                      uint32\n\tMp_sndbytes                      uint32\n\tJoin_rxmts                       uint32\n\tTailloss_rto                     uint32\n\tReordered_pkts                   uint32\n\tRecovered_pkts                   uint32\n\tPto                              uint32\n\tRto_after_pto                    uint32\n\tTlp_recovery                     uint32\n\tTlp_recoverlastpkt               uint32\n\tEcn_client_success               uint32\n\tEcn_recv_ece                     uint32\n\tEcn_sent_ece                     uint32\n\tDetect_reordering                uint32\n\tDelay_recovery                   uint32\n\tAvoid_rxmt                       uint32\n\tUnnecessary_rxmt                 uint32\n\tNostretchack                     uint32\n\tRescue_rxmt                      uint32\n\tPto_in_recovery                  uint32\n\tPmtudbh_reverted                 uint32\n\tDsack_disable                    uint32\n\tDsack_ackloss                    uint32\n\tDsack_badrexmt                   uint32\n\tDsack_sent                       uint32\n\tDsack_recvd                      uint32\n\tDsack_recvd_old                  uint32\n\tMp_sel_symtomsd                  uint32\n\tMp_sel_rtt                       uint32\n\tMp_sel_rto                       uint32\n\tMp_sel_peer                      uint32\n\tMp_num_probes                    uint32\n\tMp_verdowngrade                  uint32\n\tDrop_after_sleep                 uint32\n\tProbe_if                         uint32\n\tProbe_if_conflict                uint32\n\tEcn_client_setup                 uint32\n\tEcn_server_setup                 uint32\n\tEcn_server_success               uint32\n\tEcn_lost_synack                  uint32\n\tEcn_lost_syn                     uint32\n\tEcn_not_supported                uint32\n\tEcn_recv_ce                      uint32\n\tEcn_conn_recv_ce                 uint32\n\tEcn_conn_recv_ece                uint32\n\tEcn_conn_plnoce                  uint32\n\tEcn_conn_pl_ce                   uint32\n\tEcn_conn_nopl_ce                 uint32\n\tEcn_fallback_synloss             uint32\n\tEcn_fallback_reorder             uint32\n\tEcn_fallback_ce                  uint32\n\tTfo_syn_data_rcv                 uint32\n\tTfo_cookie_req_rcv               uint32\n\tTfo_cookie_sent                  uint32\n\tTfo_cookie_invalid               uint32\n\tTfo_cookie_req                   uint32\n\tTfo_cookie_rcv                   uint32\n\tTfo_syn_data_sent                uint32\n\tTfo_syn_data_acked               uint32\n\tTfo_syn_loss                     uint32\n\tTfo_blackhole                    uint32\n\tTfo_cookie_wrong                 uint32\n\tTfo_no_cookie_rcv                uint32\n\tTfo_heuristics_disable           uint32\n\tTfo_sndblackhole                 uint32\n\tMss_to_default                   uint32\n\tMss_to_medium                    uint32\n\tMss_to_low                       uint32\n\tEcn_fallback_droprst             uint32\n\tEcn_fallback_droprxmt            uint32\n\tEcn_fallback_synrst              uint32\n\tMptcp_rcvmemdrop                 uint32\n\tMptcp_rcvduppack                 uint32\n\tMptcp_rcvpackafterwin            uint32\n\tTimer_drift_le_1_ms              uint32\n\tTimer_drift_le_10_ms             uint32\n\tTimer_drift_le_20_ms             uint32\n\tTimer_drift_le_50_ms             uint32\n\tTimer_drift_le_100_ms            uint32\n\tTimer_drift_le_200_ms            uint32\n\tTimer_drift_le_500_ms            uint32\n\tTimer_drift_le_1000_ms           uint32\n\tTimer_drift_gt_1000_ms           uint32\n\tMptcp_handover_attempt           uint32\n\tMptcp_interactive_attempt        uint32\n\tMptcp_aggregate_attempt          uint32\n\tMptcp_fp_handover_attempt        uint32\n\tMptcp_fp_interactive_attempt     uint32\n\tMptcp_fp_aggregate_attempt       uint32\n\tMptcp_heuristic_fallback         uint32\n\tMptcp_fp_heuristic_fallback      uint32\n\tMptcp_handover_success_wifi      uint32\n\tMptcp_handover_success_cell      uint32\n\tMptcp_interactive_success        uint32\n\tMptcp_aggregate_success          uint32\n\tMptcp_fp_handover_success_wifi   uint32\n\tMptcp_fp_handover_success_cell   uint32\n\tMptcp_fp_interactive_success     uint32\n\tMptcp_fp_aggregate_success       uint32\n\tMptcp_handover_cell_from_wifi    uint32\n\tMptcp_handover_wifi_from_cell    uint32\n\tMptcp_interactive_cell_from_wifi uint32\n\t_                                [4]byte\n\tMptcp_handover_cell_bytes        uint64\n\tMptcp_interactive_cell_bytes     uint64\n\tMptcp_aggregate_cell_bytes       uint64\n\tMptcp_handover_all_bytes         uint64\n\tMptcp_interactive_all_bytes      uint64\n\tMptcp_aggregate_all_bytes        uint64\n\tMptcp_back_to_wifi               uint32\n\tMptcp_wifi_proxy                 uint32\n\tMptcp_cell_proxy                 uint32\n\t_                                [4]byte\n}\n\nfunc setSockOptInt(fd uintptr, level, opt, val int) (err error) {\n\terr = syscall.SetsockoptInt(int(fd), level, opt, val)\n\tif err != nil {\n\t\tui.printErr(\"Failed to set socket option (%v) to value (%v) during Dial. Error: %s\", opt, val, err)\n\t}\n\treturn\n}\n\nfunc IcmpNewConn(address string) (net.PacketConn, error) {\n\tdialedConn, err := net.Dial(Icmp(), address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlocalAddr := dialedConn.LocalAddr()\n\tdialedConn.Close()\n\tconn, err := net.ListenPacket(Icmp(), localAddr.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\nfunc VerifyPermissionForTest(testID EthrTestID) {\n\tif testID.Protocol == ICMP || (testID.Protocol == TCP &&\n\t\t(testID.Type == TraceRoute || testID.Type == MyTraceRoute)) {\n\t\tif !IsAdmin() {\n\t\t\tui.printMsg(\"Warning: You are not running as administrator. For %s based %s\",\n\t\t\t\tprotoToString(testID.Protocol), testToString(testID.Type))\n\t\t\tui.printMsg(\"test, running as administrator is required.\\n\")\n\t\t}\n\t}\n}\n\nfunc IsAdmin() bool {\n\treturn true\n}\n\nfunc SetTClass(fd uintptr, tos int) {\n\tsetSockOptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, tos)\n}\n"
        },
        {
          "name": "plt_linux.go",
          "type": "blob",
          "size": 4.55078125,
          "content": "// +build linux\n\n//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\ttm \"github.com/nsf/termbox-go\"\n)\n\ntype ethrNetDevInfo struct {\n\tbytes      uint64\n\tpackets    uint64\n\tdrop       uint64\n\terrs       uint64\n\tfifo       uint64\n\tframe      uint64\n\tcompressed uint64\n\tmulticast  uint64\n}\n\ntype osStats struct {\n}\n\nfunc getNetDevStats(stats *ethrNetStat) {\n\tifs, err := net.Interfaces()\n\tif err != nil {\n\t\tui.printErr(\"%v\", err)\n\t\treturn\n\t}\n\n\tnetStatsFile, err := os.Open(\"/proc/net/dev\")\n\tif err != nil {\n\t\tui.printErr(\"%v\", err)\n\t\treturn\n\t}\n\tdefer netStatsFile.Close()\n\n\treader := bufio.NewReader(netStatsFile)\n\n\t// Pass the header\n\t// Inter-|   Receive                                             |  Transmit\n\t//  face |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed\n\treader.ReadString('\\n')\n\treader.ReadString('\\n')\n\n\tvar line string\n\tfor err == nil {\n\t\tline, err = reader.ReadString('\\n')\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tnetDevStat := buildNetDevStat(line)\n\t\tif isIfUp(netDevStat.interfaceName, ifs) {\n\t\t\tstats.netDevStats = append(stats.netDevStats, buildNetDevStat(line))\n\t\t}\n\t}\n}\n\nfunc getTCPStats(stats *ethrNetStat) {\n\tsnmpStatsFile, err := os.Open(\"/proc/net/snmp\")\n\tif err != nil {\n\t\tui.printDbg(\"%v\", err)\n\t\treturn\n\t}\n\tdefer snmpStatsFile.Close()\n\n\treader := bufio.NewReader(snmpStatsFile)\n\n\tvar line string\n\tfor err == nil {\n\t\t// Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets\n\t\t//      CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors\n\t\tline, err = reader.ReadString('\\n')\n\t\tif line == \"\" || !strings.HasPrefix(line, \"Tcp\") {\n\t\t\tcontinue\n\t\t}\n\t\t// Skip the first line starting with Tcp\n\t\tline, err = reader.ReadString('\\n')\n\t\tif !strings.HasPrefix(line, \"Tcp\") {\n\t\t\tbreak\n\t\t}\n\t\tfields := strings.Fields(line)\n\t\tstats.tcpStats.segRetrans = toUInt64(fields[12])\n\t}\n}\n\nfunc hideCursor() {\n\ttm.SetCursor(0, 0)\n}\n\nfunc blockWindowResize() {\n}\n\nfunc buildNetDevStat(line string) ethrNetDevStat {\n\tfields := strings.Fields(line)\n\tif len(fields) < 17 {\n\t\treturn ethrNetDevStat{}\n\t}\n\tinterfaceName := strings.TrimSuffix(fields[0], \":\")\n\trxInfo := toNetDevInfo(fields[1:9])\n\ttxInfo := toNetDevInfo(fields[9:17])\n\treturn ethrNetDevStat{\n\t\tinterfaceName: interfaceName,\n\t\trxBytes:       rxInfo.bytes,\n\t\ttxBytes:       txInfo.bytes,\n\t\trxPkts:        rxInfo.packets,\n\t\ttxPkts:        txInfo.packets,\n\t}\n}\n\nfunc toNetDevInfo(fields []string) ethrNetDevInfo {\n\treturn ethrNetDevInfo{\n\t\tbytes:      toUInt64(fields[0]),\n\t\tpackets:    toUInt64(fields[1]),\n\t\terrs:       toUInt64(fields[2]),\n\t\tdrop:       toUInt64(fields[3]),\n\t\tfifo:       toUInt64(fields[4]),\n\t\tframe:      toUInt64(fields[5]),\n\t\tcompressed: toUInt64(fields[6]),\n\t\tmulticast:  toUInt64(fields[7]),\n\t}\n}\n\nfunc toUInt64(str string) uint64 {\n\tres, err := strconv.ParseUint(str, 10, 64)\n\tif err != nil {\n\t\tui.printDbg(\"Error in string conversion: %v\", err)\n\t\treturn 0\n\t}\n\treturn res\n}\n\nfunc isIfUp(ifName string, ifs []net.Interface) bool {\n\tfor _, ifi := range ifs {\n\t\tif ifi.Name == ifName {\n\t\t\tif (ifi.Flags & net.FlagUp) != 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t}\n\treturn false\n}\n\nfunc setSockOptInt(fd uintptr, level, opt, val int) (err error) {\n\terr = syscall.SetsockoptInt(int(fd), level, opt, val)\n\tif err != nil {\n\t\tui.printErr(\"Failed to set socket option (%v) to value (%v) during Dial. Error: %s\", opt, val, err)\n\t}\n\treturn\n}\n\nfunc IcmpNewConn(address string) (net.PacketConn, error) {\n\tdialedConn, err := net.Dial(Icmp(), address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlocalAddr := dialedConn.LocalAddr()\n\tdialedConn.Close()\n\tconn, err := net.ListenPacket(Icmp(), localAddr.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\nfunc VerifyPermissionForTest(testID EthrTestID) {\n\tif testID.Protocol == ICMP || (testID.Protocol == TCP &&\n\t\t(testID.Type == TraceRoute || testID.Type == MyTraceRoute)) {\n\t\tif !IsAdmin() {\n\t\t\tui.printMsg(\"Warning: You are not running as administrator. For %s based %s\",\n\t\t\t\tprotoToString(testID.Protocol), testToString(testID.Type))\n\t\t\tui.printMsg(\"test, running as administrator is required.\\n\")\n\t\t}\n\t}\n}\n\nfunc IsAdmin() bool {\n\treturn os.Geteuid() == 0\n}\n\nfunc SetTClass(fd uintptr, tos int) {\n\tsetSockOptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, tos)\n}\n"
        },
        {
          "name": "plt_windows.go",
          "type": "blob",
          "size": 7.7939453125,
          "content": "// +build windows\n\n//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\ttm \"github.com/nsf/termbox-go\"\n)\n\nvar (\n\tkernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\n\tuser32   = syscall.NewLazyDLL(\"user32.dll\")\n\tiphlpapi = syscall.NewLazyDLL(\"iphlpapi.dll\")\n\n\tproc_get_tcp_statistics_ex = iphlpapi.NewProc(\"GetTcpStatisticsEx\")\n\tproc_get_if_entry2         = iphlpapi.NewProc(\"GetIfEntry2\")\n\tproc_get_console_window    = kernel32.NewProc(\"GetConsoleWindow\")\n\tproc_get_system_menu       = user32.NewProc(\"GetSystemMenu\")\n\tproc_delete_menu           = user32.NewProc(\"DeleteMenu\")\n)\n\ntype ethrNetDevInfo struct {\n\tbytes   uint64\n\tpackets uint64\n\tdrop    uint64\n\terrs    uint64\n}\n\nfunc getNetDevStats(stats *ethrNetStat) {\n\tifs, err := net.Interfaces()\n\tif err != nil {\n\t\tui.printErr(\"%v\", err)\n\t\treturn\n\t}\n\n\tfor _, ifi := range ifs {\n\t\tif (ifi.Flags&net.FlagUp) == 0 || strings.Contains(ifi.Name, \"Pseudo\") {\n\t\t\tcontinue\n\t\t}\n\t\trow, err := getIfEntry2(uint32(ifi.Index))\n\t\tif err != nil {\n\t\t\tui.printErr(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\trxInfo := ethrNetDevInfo{\n\t\t\tbytes:   uint64(row.InOctets),\n\t\t\tpackets: uint64(row.InUcastPkts),\n\t\t\tdrop:    uint64(row.InDiscards),\n\t\t\terrs:    uint64(row.InErrors),\n\t\t}\n\t\ttxInfo := ethrNetDevInfo{\n\t\t\tbytes:   uint64(row.OutOctets),\n\t\t\tpackets: uint64(row.OutUcastPkts),\n\t\t\tdrop:    uint64(row.OutDiscards),\n\t\t\terrs:    uint64(row.OutErrors),\n\t\t}\n\t\tnetStats := ethrNetDevStat{\n\t\t\tinterfaceName: ifi.Name,\n\t\t\trxBytes:       rxInfo.bytes,\n\t\t\ttxBytes:       txInfo.bytes,\n\t\t\trxPkts:        rxInfo.packets,\n\t\t\ttxPkts:        txInfo.packets,\n\t\t}\n\t\tstats.netDevStats = append(stats.netDevStats, netStats)\n\t}\n}\n\ntype mib_tcpstats struct {\n\tDwRtoAlgorithm uint32\n\tDwRtoMin       uint32\n\tDwRtoMax       uint32\n\tDwMaxConn      uint32\n\tDwActiveOpens  uint32\n\tDwPassiveOpens uint32\n\tDwAttemptFails uint32\n\tDwEstabResets  uint32\n\tDwCurrEstab    uint32\n\tDwInSegs       uint32\n\tDwOutSegs      uint32\n\tDwRetransSegs  uint32\n\tDwInErrs       uint32\n\tDwOutRsts      uint32\n\tDwNumConns     uint32\n}\n\nconst (\n\tAF_INET  = 2\n\tAF_INET6 = 23\n)\n\nfunc getTCPStats(stats *ethrNetStat) (errcode error) {\n\ttcpStats := &mib_tcpstats{}\n\tr0, _, _ := syscall.Syscall(proc_get_tcp_statistics_ex.Addr(), 2,\n\t\tuintptr(unsafe.Pointer(tcpStats)), uintptr(AF_INET), 0)\n\n\tif r0 != 0 {\n\t\terrcode = syscall.Errno(r0)\n\t\treturn\n\t}\n\tstats.tcpStats.segRetrans = uint64(tcpStats.DwRetransSegs)\n\treturn\n}\n\ntype guid struct {\n\tData1 uint32\n\tData2 uint16\n\tData3 uint16\n\tData4 [8]byte\n}\n\nconst (\n\tMAX_STRING_SIZE         = 256\n\tMAX_PHYS_ADDRESS_LENGTH = 32\n\tpad0for64_4for32        = 0\n)\n\ntype mibIfRow2 struct {\n\tInterfaceLuid               uint64\n\tInterfaceIndex              uint32\n\tInterfaceGuid               guid\n\tAlias                       [MAX_STRING_SIZE + 1]uint16\n\tDescription                 [MAX_STRING_SIZE + 1]uint16\n\tPhysicalAddressLength       uint32\n\tPhysicalAddress             [MAX_PHYS_ADDRESS_LENGTH]uint8\n\tPermanentPhysicalAddress    [MAX_PHYS_ADDRESS_LENGTH]uint8\n\tMtu                         uint32\n\tType                        uint32\n\tTunnelType                  uint32\n\tMediaType                   uint32\n\tPhysicalMediumType          uint32\n\tAccessType                  uint32\n\tDirectionType               uint32\n\tInterfaceAndOperStatusFlags uint32\n\tOperStatus                  uint32\n\tAdminStatus                 uint32\n\tMediaConnectState           uint32\n\tNetworkGuid                 guid\n\tConnectionType              uint32\n\tpadding1                    [pad0for64_4for32]byte\n\tTransmitLinkSpeed           uint64\n\tReceiveLinkSpeed            uint64\n\tInOctets                    uint64\n\tInUcastPkts                 uint64\n\tInNUcastPkts                uint64\n\tInDiscards                  uint64\n\tInErrors                    uint64\n\tInUnknownProtos             uint64\n\tInUcastOctets               uint64\n\tInMulticastOctets           uint64\n\tInBroadcastOctets           uint64\n\tOutOctets                   uint64\n\tOutUcastPkts                uint64\n\tOutNUcastPkts               uint64\n\tOutDiscards                 uint64\n\tOutErrors                   uint64\n\tOutUcastOctets              uint64\n\tOutMulticastOctets          uint64\n\tOutBroadcastOctets          uint64\n\tOutQLen                     uint64\n}\n\nfunc getIfEntry2(ifIndex uint32) (mibIfRow2, error) {\n\tvar res *mibIfRow2\n\n\tres = &mibIfRow2{InterfaceIndex: ifIndex}\n\tr0, _, _ := syscall.Syscall(proc_get_if_entry2.Addr(), 1,\n\t\tuintptr(unsafe.Pointer(res)), 0, 0)\n\tif r0 != 0 {\n\t\treturn mibIfRow2{}, syscall.Errno(r0)\n\t}\n\treturn *res, nil\n}\n\nfunc hideCursor() {\n\ttm.HideCursor()\n}\n\nconst (\n\tMF_BYCOMMAND = 0x00000000\n\tSC_CLOSE     = 0xF060\n\tSC_MINIMIZE  = 0xF020\n\tSC_MAXIMIZE  = 0xF030\n\tSC_SIZE      = 0xF000\n)\n\nfunc blockWindowResize() {\n\th, _, err := syscall.Syscall(proc_get_console_window.Addr(), 0, 0, 0, 0)\n\tif err != 0 {\n\t\treturn\n\t}\n\n\tsysMenu, _, err := syscall.Syscall(proc_get_system_menu.Addr(), 2, h, 0, 0)\n\tif err != 0 {\n\t\treturn\n\t}\n\n\tsyscall.Syscall(proc_delete_menu.Addr(), 3, sysMenu, SC_MAXIMIZE, MF_BYCOMMAND)\n\tsyscall.Syscall(proc_delete_menu.Addr(), 3, sysMenu, SC_SIZE, MF_BYCOMMAND)\n}\n\nfunc setSockOptInt(fd uintptr, level, opt, val int) (err error) {\n\terr = syscall.SetsockoptInt(syscall.Handle(fd), level, opt, val)\n\tif err != nil {\n\t\tui.printErr(\"Failed to set socket option (%v) to value (%v) during Dial. Error: %s\", opt, val, err)\n\t}\n\treturn\n}\n\nconst (\n\tSIO_RCVALL             = syscall.IOC_IN | syscall.IOC_VENDOR | 1\n\tRCVALL_OFF             = 0\n\tRCVALL_ON              = 1\n\tRCVALL_SOCKETLEVELONLY = 2\n\tRCVALL_IPLEVEL         = 3\n)\n\nfunc IcmpNewConn(address string) (net.PacketConn, error) {\n\t// This is an attempt to work around the problem described here:\n\t// https://github.com/golang/go/issues/38427\n\n\t// First, get the correct local interface address, as SIO_RCVALL can't be set on a 0.0.0.0 listeners.\n\tdialedConn, err := net.Dial(Icmp(), address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlocalAddr := dialedConn.LocalAddr()\n\tdialedConn.Close()\n\n\t// Configure the setup routine in order to extract the socket handle.\n\tvar socketHandle syscall.Handle\n\tcfg := net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t\treturn c.Control(func(s uintptr) {\n\t\t\t\tsocketHandle = syscall.Handle(s)\n\t\t\t})\n\t\t},\n\t}\n\n\t// Bind to interface.\n\tconn, err := cfg.ListenPacket(context.Background(), Icmp(), localAddr.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set socket option to receive all packets, such as ICMP error messages.\n\t// This is somewhat dirty, as there is guarantee that socketHandle is still valid.\n\t// WARNING: The Windows Firewall might just drop the incoming packets you might want to receive.\n\tunused := uint32(0) // Documentation states that this is unused, but WSAIoctl fails without it.\n\tflag := uint32(RCVALL_IPLEVEL)\n\tsize := uint32(unsafe.Sizeof(flag))\n\terr = syscall.WSAIoctl(socketHandle, SIO_RCVALL, (*byte)(unsafe.Pointer(&flag)), size, nil, 0, &unused, nil, 0)\n\tif err != nil {\n\t\t// Ignore the error as for ICMP related TraceRoute, this is not required.\n\t}\n\n\treturn conn, nil\n}\n\nfunc VerifyPermissionForTest(testID EthrTestID) {\n\tif (testID.Type == TraceRoute || testID.Type == MyTraceRoute) &&\n\t\t(testID.Protocol == TCP) {\n\t\tif !IsAdmin() {\n\t\t\tui.printMsg(\"Warning: You are not running as administrator. For %s based %s\",\n\t\t\t\tprotoToString(testID.Protocol), testToString(testID.Type))\n\t\t\tui.printMsg(\"test, running as administrator is required.\\n\")\n\t\t}\n\t}\n}\n\nfunc IsAdmin() bool {\n\tc, err := os.Open(\"\\\\\\\\.\\\\PHYSICALDRIVE0\")\n\tif err != nil {\n\t\tui.printDbg(\"Process is not running as admin. Error: %v\", err)\n\t\treturn false\n\t}\n\tc.Close()\n\treturn true\n}\n\nfunc SetTClass(fd uintptr, tos int) {\n\treturn\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 9.548828125,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sort\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nvar gCert []byte\n\nfunc initServer(showUI bool) {\n\tinitServerUI(showUI)\n}\n\nfunc finiServer() {\n\tui.fini()\n\tlogFini()\n}\n\nfunc showAcceptedIPVersion() {\n\tvar ipVerString = \"ipv4, ipv6\"\n\tif gIPVersion == ethrIPv4 {\n\t\tipVerString = \"ipv4\"\n\t} else if gIPVersion == ethrIPv6 {\n\t\tipVerString = \"ipv6\"\n\t}\n\tui.printMsg(\"Accepting IP version: %s\", ipVerString)\n}\n\nfunc runServer(serverParam ethrServerParam) {\n\tdefer stopStatsTimer()\n\tinitServer(serverParam.showUI)\n\tstartStatsTimer()\n\tfmt.Println(\"-----------------------------------------------------------\")\n\tshowAcceptedIPVersion()\n\tui.printMsg(\"Listening on port %d for TCP & UDP\", gEthrPort)\n\tsrvrRunUDPServer()\n\terr := srvrRunTCPServer()\n\tif err != nil {\n\t\tfiniServer()\n\t\tfmt.Printf(\"Fatal error running TCP server: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc handshakeWithClient(test *ethrTest, conn net.Conn) (testID EthrTestID, clientParam EthrClientParam, err error) {\n\tethrMsg := recvSessionMsg(conn)\n\tif ethrMsg.Type != EthrSyn {\n\t\tui.printDbg(\"Failed to receive SYN message from client.\")\n\t\terr = os.ErrInvalid\n\t\treturn\n\t}\n\ttestID = ethrMsg.Syn.TestID\n\tclientParam = ethrMsg.Syn.ClientParam\n\tethrMsg = createAckMsg()\n\terr = sendSessionMsg(conn, ethrMsg)\n\treturn\n}\n\nfunc srvrRunTCPServer() error {\n\tl, err := net.Listen(Tcp(), gLocalIP+\":\"+gEthrPortStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer l.Close()\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tui.printErr(\"Error accepting new TCP connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo srvrHandleNewTcpConn(conn)\n\t}\n}\n\nfunc srvrHandleNewTcpConn(conn net.Conn) {\n\tdefer conn.Close()\n\n\tserver, port, err := net.SplitHostPort(conn.RemoteAddr().String())\n\tethrUnused(server, port)\n\tif err != nil {\n\t\tui.printDbg(\"RemoteAddr: Split host port failed: %v\", err)\n\t\treturn\n\t}\n\tlserver, lport, err := net.SplitHostPort(conn.LocalAddr().String())\n\tif err != nil {\n\t\tui.printDbg(\"LocalAddr: Split host port failed: %v\", err)\n\t\treturn\n\t}\n\tethrUnused(lserver, lport)\n\tui.printDbg(\"New connection from %v, port %v to %v, port %v\", server, port, lserver, lport)\n\n\ttest, isNew := createOrGetTest(server, TCP, All)\n\tif test == nil {\n\t\treturn\n\t}\n\tif isNew {\n\t\tui.emitTestHdr()\n\t}\n\n\tisCPSorPing := true\n\t// For CPS and Ping tests, there is no deterministic way to know when the test starts\n\t// from the client side and when it ends. This defer function ensures that test is not\n\t// created/deleted repeatedly by doing a deferred deletion. If another connection\n\t// comes with-in 2s, then another reference would be taken on existing test object\n\t// and it won't be deleted by safeDeleteTest call. This also ensures, test header is\n\t// not printed repeatedly via emitTestHdr.\n\t// Note: Similar mechanism is used in UDP tests to handle test lifetime as well.\n\tdefer func() {\n\t\tif isCPSorPing {\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t\tsafeDeleteTest(test)\n\t}()\n\n\t// Always increment CPS count and then check if the test is Bandwidth etc. and handle\n\t// those cases as well.\n\tatomic.AddUint64(&test.testResult.cps, 1)\n\n\ttestID, clientParam, err := handshakeWithClient(test, conn)\n\tif err != nil {\n\t\tui.printDbg(\"Failed in handshake with the client. Error: %v\", err)\n\t\treturn\n\t}\n\tisCPSorPing = false\n\tif testID.Protocol == TCP {\n\t\tif testID.Type == Bandwidth {\n\t\t\tsrvrRunTCPBandwidthTest(test, clientParam, conn)\n\t\t} else if testID.Type == Latency {\n\t\t\tui.emitLatencyHdr()\n\t\t\tsrvrRunTCPLatencyTest(test, clientParam, conn)\n\t\t}\n\t}\n}\n\nfunc srvrRunTCPBandwidthTest(test *ethrTest, clientParam EthrClientParam, conn net.Conn) {\n\tsize := clientParam.BufferSize\n\tbuff := make([]byte, size)\n\tfor i := uint32(0); i < size; i++ {\n\t\tbuff[i] = byte(i)\n\t}\n\tbufferLen := len(buff)\n\ttotalBytesToSend := test.clientParam.BwRate\n\tsentBytes := uint64(0)\n\tstart, waitTime, bytesToSend := beginThrottle(totalBytesToSend, bufferLen)\n\tfor {\n\t\tn := 0\n\t\tvar err error\n\t\tif clientParam.Reverse {\n\t\t\tn, err = conn.Write(buff[:bytesToSend])\n\t\t} else {\n\t\t\tn, err = conn.Read(buff)\n\t\t}\n\t\tif err != nil {\n\t\t\tui.printDbg(\"Error sending/receiving data on a connection for bandwidth test: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tatomic.AddUint64(&test.testResult.bw, uint64(n))\n\t\tif clientParam.Reverse {\n\t\t\tsentBytes += uint64(n)\n\t\t\tstart, waitTime, sentBytes, bytesToSend = enforceThrottle(start, waitTime, totalBytesToSend, sentBytes, bufferLen)\n\t\t}\n\t}\n}\n\nfunc srvrRunTCPLatencyTest(test *ethrTest, clientParam EthrClientParam, conn net.Conn) {\n\tbytes := make([]byte, clientParam.BufferSize)\n\trttCount := clientParam.RttCount\n\tlatencyNumbers := make([]time.Duration, rttCount)\n\tfor {\n\t\t_, err := io.ReadFull(conn, bytes)\n\t\tif err != nil {\n\t\t\tui.printDbg(\"Error receiving data for latency test: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tfor i := uint32(0); i < rttCount; i++ {\n\t\t\ts1 := time.Now()\n\t\t\t_, err = conn.Write(bytes)\n\t\t\tif err != nil {\n\t\t\t\tui.printDbg(\"Error sending data for latency test: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err = io.ReadFull(conn, bytes)\n\t\t\tif err != nil {\n\t\t\t\tui.printDbg(\"Error receiving data for latency test: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\te2 := time.Since(s1)\n\t\t\tlatencyNumbers[i] = e2\n\t\t}\n\t\tsum := int64(0)\n\t\tfor _, d := range latencyNumbers {\n\t\t\tsum += d.Nanoseconds()\n\t\t}\n\t\telapsed := time.Duration(sum / int64(rttCount))\n\t\tsort.SliceStable(latencyNumbers, func(i, j int) bool {\n\t\t\treturn latencyNumbers[i] < latencyNumbers[j]\n\t\t})\n\t\t//\n\t\t// Special handling for rttCount == 1. This prevents negative index\n\t\t// in the latencyNumber index. The other option is to use\n\t\t// roundUpToZero() but that is more expensive.\n\t\t//\n\t\trttCountFixed := rttCount\n\t\tif rttCountFixed == 1 {\n\t\t\trttCountFixed = 2\n\t\t}\n\t\tatomic.SwapUint64(&test.testResult.latency, uint64(elapsed.Nanoseconds()))\n\t\tavg := elapsed\n\t\tmin := latencyNumbers[0]\n\t\tmax := latencyNumbers[rttCount-1]\n\t\tp50 := latencyNumbers[((rttCountFixed*50)/100)-1]\n\t\tp90 := latencyNumbers[((rttCountFixed*90)/100)-1]\n\t\tp95 := latencyNumbers[((rttCountFixed*95)/100)-1]\n\t\tp99 := latencyNumbers[((rttCountFixed*99)/100)-1]\n\t\tp999 := latencyNumbers[uint64(((float64(rttCountFixed)*99.9)/100)-1)]\n\t\tp9999 := latencyNumbers[uint64(((float64(rttCountFixed)*99.99)/100)-1)]\n\t\tui.emitLatencyResults(\n\t\t\ttest.session.remoteIP,\n\t\t\tprotoToString(test.testID.Protocol),\n\t\t\tavg, min, max, p50, p90, p95, p99, p999, p9999)\n\t}\n}\n\nfunc srvrRunUDPServer() error {\n\tudpAddr, err := net.ResolveUDPAddr(Udp(), gLocalIP+\":\"+gEthrPortStr)\n\tif err != nil {\n\t\tui.printDbg(\"Unable to resolve UDP address: %v\", err)\n\t\treturn err\n\t}\n\tl, err := net.ListenUDP(Udp(), udpAddr)\n\tif err != nil {\n\t\tui.printDbg(\"Error listening on %s for UDP pkt/s tests: %v\", gEthrPortStr, err)\n\t\treturn err\n\t}\n\t// Set socket buffer to 4MB per CPU so we can queue 4MB per CPU in case Ethr is not\n\t// able to keep up temporarily.\n\terr = l.SetReadBuffer(runtime.NumCPU() * 4 * 1024 * 1024)\n\tif err != nil {\n\t\tui.printDbg(\"Failed to set ReadBuffer on UDP socket: %v\", err)\n\t}\n\t//\n\t// We use NumCPU here instead of NumThreads passed from client. The\n\t// reason is that for UDP, there is no connection, so all packets come\n\t// on same CPU, so it isn't clear if there are any benefits to running\n\t// more threads than NumCPU(). TODO: Evaluate this in future.\n\t//\n\tfor i := 0; i < runtime.NumCPU(); i++ {\n\t\tgo srvrRunUDPPacketHandler(l)\n\t}\n\treturn nil\n}\n\nfunc srvrRunUDPPacketHandler(conn *net.UDPConn) {\n\t// This local map aids in efficiency to look up a test based on client's IP\n\t// address. We could use createOrGetTest but that takes a global lock.\n\ttests := make(map[string]*ethrTest)\n\t// For UDP, allocate buffer that can accomodate largest UDP datagram.\n\treadBuffer := make([]byte, 64*1024)\n\tn, remoteIP, err := 0, new(net.UDPAddr), error(nil)\n\n\t// This function handles UDP tests that came from clients that are no longer\n\t// sending any traffic. This is poor man's garbage collection to ensure the\n\t// server doesn't end up printing dormant client related statistics as UDP\n\t// has no reliable way to detect if client is active or not.\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\tfor k, v := range tests {\n\t\t\t\tui.printDbg(\"Found Test from server: %v, time: %v\", k, v.lastAccess)\n\t\t\t\t// At 200ms of no activity, mark the test in-active so stats stop\n\t\t\t\t// printing.\n\t\t\t\tif time.Since(v.lastAccess) > (200 * time.Millisecond) {\n\t\t\t\t\tv.isDormant = true\n\t\t\t\t}\n\t\t\t\t// At 2s of no activity, delete the test by assuming that client\n\t\t\t\t// has stopped.\n\t\t\t\tif time.Since(v.lastAccess) > (2 * time.Second) {\n\t\t\t\t\tui.printDbg(\"Deleting UDP test from server: %v, lastAccess: %v\", k, v.lastAccess)\n\t\t\t\t\tsafeDeleteTest(v)\n\t\t\t\t\tdelete(tests, k)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tfor err == nil {\n\t\tn, remoteIP, err = conn.ReadFromUDP(readBuffer)\n\t\tif err != nil {\n\t\t\tui.printDbg(\"Error receiving data from UDP for bandwidth test: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tethrUnused(remoteIP)\n\t\tethrUnused(n)\n\t\tserver, port, _ := net.SplitHostPort(remoteIP.String())\n\t\ttest, found := tests[server]\n\t\tif !found {\n\t\t\ttest, isNew := createOrGetTest(server, UDP, All)\n\t\t\tif test != nil {\n\t\t\t\ttests[server] = test\n\t\t\t}\n\t\t\tif isNew {\n\t\t\t\tui.printDbg(\"Creating UDP test from server: %v, lastAccess: %v\", server, time.Now())\n\t\t\t\tui.emitTestHdr()\n\t\t\t}\n\t\t}\n\t\tif test != nil {\n\t\t\ttest.isDormant = false\n\t\t\ttest.lastAccess = time.Now()\n\t\t\tatomic.AddUint64(&test.testResult.pps, 1)\n\t\t\tatomic.AddUint64(&test.testResult.bw, uint64(n))\n\t\t} else {\n\t\t\tui.printDbg(\"Unable to create test for UDP traffic on port %s from %s port %s\", gEthrPortStr, server, port)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "serverui.go",
          "type": "blob",
          "size": 11.5205078125,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\ttm \"github.com/nsf/termbox-go\"\n)\n\ntype ethrTestResultAggregate struct {\n\tbw, cps, pps    uint64\n\tcbw, ccps, cpps uint64\n}\n\nvar gAggregateTestResults = make(map[EthrProtocol]*ethrTestResultAggregate)\n\n//\n// Initialization functions.\n//\nfunc initServerUI(showUI bool) {\n\tgAggregateTestResults[TCP] = &ethrTestResultAggregate{}\n\tgAggregateTestResults[UDP] = &ethrTestResultAggregate{}\n\tgAggregateTestResults[ICMP] = &ethrTestResultAggregate{}\n\tif !showUI || !initServerTui() {\n\t\tinitServerCli()\n\t}\n}\n\n//\n// Text based UI\n//\ntype serverTui struct {\n\th, w                               int\n\tresX, resY, resW                   int\n\tlatX, latY, latW                   int\n\ttopVSplitX, topVSplitY, topVSplitH int\n\tstatX, statY, statW                int\n\tmsgX, msgY, msgW                   int\n\tbotVSplitX, botVSplitY, botVSplitH int\n\terrX, errY, errW                   int\n\tres                                table\n\tresults                            [][]string\n\tresultHdr                          []string\n\tmsg                                table\n\tmsgRing                            []string\n\terr                                table\n\terrRing                            []string\n\tringLock                           sync.RWMutex\n}\n\nfunc initServerTui() bool {\n\terr := initServerTuiInternal()\n\tif err != nil {\n\t\tfmt.Println(\"Error: Failed to initialize UI.\", err)\n\t\tfmt.Println(\"Using command line view instead of UI\")\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc initServerTuiInternal() error {\n\terr := tm.Init()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tw, h := tm.Size()\n\tif h < 40 || w < 80 {\n\t\ttm.Close()\n\t\ts := fmt.Sprintf(\"Terminal too small (%dwx%dh), must be at least 40hx80w\", w, h)\n\t\treturn errors.New(s)\n\t}\n\n\ttm.SetInputMode(tm.InputEsc | tm.InputMouse)\n\ttm.Clear(tm.ColorDefault, tm.ColorDefault)\n\ttm.Sync()\n\ttm.Flush()\n\thideCursor()\n\tblockWindowResize()\n\n\ttui := &serverTui{}\n\tbotScnH := 8\n\tstatScnW := 26\n\ttui.h = h\n\ttui.w = w\n\ttui.resX = 0\n\ttui.resY = 2\n\ttui.resW = w - statScnW\n\ttui.latX = 0\n\ttui.latY = h - botScnH\n\ttui.latW = w\n\ttui.topVSplitX = tui.resW\n\ttui.topVSplitY = 1\n\ttui.topVSplitH = h - botScnH\n\ttui.statX = tui.topVSplitX + 1\n\ttui.statY = 2\n\ttui.statW = statScnW\n\ttui.msgX = 0\n\ttui.msgY = h - botScnH + 1\n\ttui.msgW = (w+1)/2 + 1\n\ttui.botVSplitX = tui.msgW\n\ttui.botVSplitY = h - botScnH\n\ttui.botVSplitH = botScnH\n\ttui.errX = tui.botVSplitX + 1\n\ttui.errY = h - botScnH + 1\n\ttui.errW = w - tui.msgW - 1\n\ttui.res = table{6, []int{13, 5, 7, 7, 7, 8}, 0, 2, 0, justifyRight, noBorder}\n\ttui.results = make([][]string, 0)\n\ttui.msg = table{1, []int{tui.msgW}, tui.msgX, tui.msgY, 0, justifyLeft, noBorder}\n\ttui.msgRing = make([]string, botScnH-1)\n\ttui.err = table{1, []int{tui.errW}, tui.errX, tui.errY, 0, justifyLeft, noBorder}\n\ttui.errRing = make([]string, botScnH-1)\n\tui = tui\n\n\tgo func() {\n\t\tfor {\n\t\t\tswitch ev := tm.PollEvent(); ev.Type {\n\t\t\tcase tm.EventKey:\n\t\t\t\tif ev.Key == tm.KeyEsc || ev.Key == tm.KeyCtrlC {\n\t\t\t\t\tfiniServer()\n\t\t\t\t\tos.Exit(0)\n\t\t\t\t}\n\t\t\tcase tm.EventResize:\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (u *serverTui) fini() {\n\ttm.Close()\n}\n\nfunc (u *serverTui) getTitle() string {\n\treturn \"\"\n}\n\nfunc (u *serverTui) printMsg(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tlogInfo(s)\n\tss := splitString(s, u.msgW)\n\tu.ringLock.Lock()\n\tu.msgRing = u.msgRing[len(ss):]\n\tu.msgRing = append(u.msgRing, ss...)\n\tu.ringLock.Unlock()\n}\n\nfunc (u *serverTui) printErr(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tlogError(s)\n\tss := splitString(s, u.errW)\n\tu.ringLock.Lock()\n\tu.errRing = u.errRing[len(ss):]\n\tu.errRing = append(u.errRing, ss...)\n\tu.ringLock.Unlock()\n}\n\nfunc (u *serverTui) printDbg(format string, a ...interface{}) {\n\tif loggingLevel == LogLevelDebug {\n\t\ts := fmt.Sprintf(format, a...)\n\t\tlogDebug(s)\n\t\tss := splitString(s, u.errW)\n\t\tu.ringLock.Lock()\n\t\tu.errRing = u.errRing[len(ss):]\n\t\tu.errRing = append(u.errRing, ss...)\n\t\tu.ringLock.Unlock()\n\t}\n}\n\nfunc (u *serverTui) emitTestResultBegin() {\n\tu.results = nil\n}\n\nfunc (u *serverTui) emitTestResult(s *ethrSession, proto EthrProtocol, seconds uint64) {\n\tstr := getTestResults(s, proto, seconds)\n\tif len(str) > 0 {\n\t\tui.printTestResults(str)\n\t}\n}\n\nfunc (u *serverTui) printTestResults(s []string) {\n\t// Log before truncation of remote address.\n\tlogResults(s)\n\ts[0] = truncateStringFromStart(s[0], 13)\n\tu.results = append(u.results, s)\n}\n\nfunc (u *serverTui) emitTestResultEnd() {\n\temitAggregateResults()\n}\n\nfunc (u *serverTui) emitTestHdr() {\n\ts := []string{\"RemoteAddress\", \"Proto\", \"Bits/s\", \"Conn/s\", \"Pkts/s\", \"Latency\"}\n\tu.resultHdr = s\n}\n\nfunc (u *serverTui) emitLatencyHdr() {\n}\n\nfunc (u *serverTui) emitLatencyResults(remote, proto string, avg, min, max, p50, p90, p95, p99, p999, p9999 time.Duration) {\n\tlogLatency(remote, proto, avg, min, max, p50, p90, p95, p99, p999, p9999)\n}\n\nfunc (u *serverTui) paint(seconds uint64) {\n\ttm.Clear(tm.ColorDefault, tm.ColorDefault)\n\tdefer tm.Flush()\n\tprintCenterText(0, 0, u.w, \"Ethr (Version: \"+gVersion+\")\", tm.ColorBlack, tm.ColorWhite)\n\tprintHLineText(u.resX, u.resY-1, u.resW, \"Test Results\")\n\tprintHLineText(u.statX, u.statY-1, u.statW, \"Statistics\")\n\tprintVLine(u.topVSplitX, u.topVSplitY, u.topVSplitH)\n\n\tprintHLineText(u.msgX, u.msgY-1, u.msgW, \"Messages\")\n\tprintHLineText(u.errX, u.errY-1, u.errW, \"Errors\")\n\n\tu.ringLock.Lock()\n\tu.msg.cr = 0\n\tfor _, s := range u.msgRing {\n\t\tu.msg.addTblRow([]string{s})\n\t}\n\n\tu.err.cr = 0\n\tfor _, s := range u.errRing {\n\t\tu.err.addTblRow([]string{s})\n\t}\n\tu.ringLock.Unlock()\n\n\tprintVLine(u.botVSplitX, u.botVSplitY, u.botVSplitH)\n\n\tu.res.cr = 0\n\tif u.resultHdr != nil {\n\t\tu.res.addTblHdr()\n\t\tu.res.addTblRow(u.resultHdr)\n\t\tu.res.addTblSpr()\n\t}\n\tfor _, s := range u.results {\n\t\tu.res.addTblRow(s)\n\t\tu.res.addTblSpr()\n\t}\n\n\tif len(gPrevNetStats.netDevStats) == 0 {\n\t\treturn\n\t}\n\n\tx := u.statX\n\tw := u.statW\n\ty := u.statY\n\tfor _, ns := range gCurNetStats.netDevStats {\n\t\tnsDiff := getNetDevStatDiff(ns, gPrevNetStats, seconds)\n\t\t// TODO: Log the network adapter stats in file as well.\n\t\tprintText(x, y, w, fmt.Sprintf(\"if: %s\", ns.interfaceName), tm.ColorWhite, tm.ColorBlack)\n\t\ty++\n\t\tprintText(x, y, w, fmt.Sprintf(\"Tx %sbps\", bytesToRate(nsDiff.txBytes)), tm.ColorWhite, tm.ColorBlack)\n\t\tbw := nsDiff.txBytes * 8\n\t\tprintUsageBar(x+14, y, 10, bw, KILO, tm.ColorYellow)\n\t\ty++\n\t\tprintText(x, y, w, fmt.Sprintf(\"Rx %sbps\", bytesToRate(nsDiff.rxBytes)), tm.ColorWhite, tm.ColorBlack)\n\t\tbw = nsDiff.rxBytes * 8\n\t\tprintUsageBar(x+14, y, 10, bw, KILO, tm.ColorGreen)\n\t\ty++\n\t\tprintText(x, y, w, fmt.Sprintf(\"Tx %spps\", numberToUnit(nsDiff.txPkts)), tm.ColorWhite, tm.ColorBlack)\n\t\tprintUsageBar(x+14, y, 10, nsDiff.txPkts, 10, tm.ColorWhite)\n\t\ty++\n\t\tprintText(x, y, w, fmt.Sprintf(\"Rx %spps\", numberToUnit(nsDiff.rxPkts)), tm.ColorWhite, tm.ColorBlack)\n\t\tprintUsageBar(x+14, y, 10, nsDiff.rxPkts, 10, tm.ColorCyan)\n\t\ty++\n\t\tprintText(x, y, w, \"-------------------------\", tm.ColorDefault, tm.ColorDefault)\n\t\ty++\n\t}\n\tprintText(x, y, w,\n\t\tfmt.Sprintf(\"Tcp Retrans: %s\",\n\t\t\tnumberToUnit((gCurNetStats.tcpStats.segRetrans-gPrevNetStats.tcpStats.segRetrans)/seconds)),\n\t\ttm.ColorDefault, tm.ColorDefault)\n}\n\nvar gPrevNetStats ethrNetStat\nvar gCurNetStats ethrNetStat\n\nfunc (u *serverTui) emitStats(netStats ethrNetStat) {\n\tgPrevNetStats = gCurNetStats\n\tgCurNetStats = netStats\n}\n\n//\n// Simple command window based output\n//\ntype serverCli struct {\n}\n\nfunc initServerCli() {\n\tcli := &serverCli{}\n\tui = cli\n}\n\nfunc (u *serverCli) fini() {\n}\n\nfunc (u *serverCli) getTitle() string {\n\treturn \"\"\n}\n\nfunc (u *serverCli) printMsg(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tfmt.Println(s)\n\tlogInfo(s)\n}\n\nfunc (u *serverCli) printDbg(format string, a ...interface{}) {\n\tif loggingLevel != LogLevelDebug {\n\t\treturn\n\t}\n\ts := fmt.Sprintf(format, a...)\n\tfmt.Println(s)\n\tlogDebug(s)\n}\n\nfunc (u *serverCli) printErr(format string, a ...interface{}) {\n\ts := fmt.Sprintf(format, a...)\n\tfmt.Println(s)\n\tlogError(s)\n}\n\nfunc (u *serverCli) paint(seconds uint64) {\n}\n\nfunc (u *serverCli) emitTestResultBegin() {\n\tgSessionLock.RLock()\n\tl := len(gSessionKeys)\n\tgSessionLock.RUnlock()\n\tif l > 1 {\n\t\tfmt.Println(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\")\n\t}\n}\n\nfunc (u *serverCli) emitTestResult(s *ethrSession, proto EthrProtocol, seconds uint64) {\n\tstr := getTestResults(s, proto, seconds)\n\tif len(str) > 0 {\n\t\tui.printTestResults(str)\n\t}\n}\n\nfunc (u *serverCli) emitTestResultEnd() {\n\temitAggregateResults()\n}\n\nfunc (u *serverCli) emitTestHdr() {\n\ts := []string{\"RemoteAddress\", \"Proto\", \"Bits/s\", \"Conn/s\", \"Pkt/s\", \"Latency\"}\n\tfmt.Println(\"-----------------------------------------------------------\")\n\tfmt.Printf(\"[%13s]  %5s  %7s  %7s  %7s  %8s\\n\", s[0], s[1], s[2], s[3], s[4], s[5])\n}\n\nfunc (u *serverCli) emitLatencyHdr() {\n}\n\nfunc (u *serverCli) emitLatencyResults(remote, proto string, avg, min, max, p50, p90, p95, p99, p999, p9999 time.Duration) {\n\tlogLatency(remote, proto, avg, min, max, p50, p90, p95, p99, p999, p9999)\n}\n\nfunc (u *serverCli) emitStats(netStats ethrNetStat) {\n}\n\nfunc (u *serverCli) printTestResults(s []string) {\n\tlogResults(s)\n\tfmt.Printf(\"[%13s]  %5s  %7s  %7s  %7s  %8s\\n\", truncateStringFromStart(s[0], 13),\n\t\ts[1], s[2], s[3], s[4], s[5])\n}\n\nfunc emitAggregateResults() {\n\tvar protoList = []EthrProtocol{TCP, UDP, ICMP}\n\tfor _, proto := range protoList {\n\t\temitAggregate(proto)\n\t}\n}\n\nfunc emitAggregate(proto EthrProtocol) {\n\tstr := []string{}\n\taggTestResult, _ := gAggregateTestResults[proto]\n\tif aggTestResult.cbw > 1 || aggTestResult.ccps > 1 || aggTestResult.cpps > 1 {\n\t\tstr = []string{\"[SUM]\", protoToString(proto),\n\t\t\tbytesToRate(aggTestResult.bw),\n\t\t\tcpsToString(aggTestResult.cps),\n\t\t\tppsToString(aggTestResult.pps),\n\t\t\t\"\"}\n\t}\n\taggTestResult.bw = 0\n\taggTestResult.cps = 0\n\taggTestResult.pps = 0\n\taggTestResult.cbw = 0\n\taggTestResult.ccps = 0\n\taggTestResult.cpps = 0\n\tif len(str) > 0 {\n\t\tui.printTestResults(str)\n\t}\n}\n\nfunc getTestResults(s *ethrSession, proto EthrProtocol, seconds uint64) []string {\n\tvar bwTestOn, cpsTestOn, ppsTestOn, latTestOn bool\n\tvar bw, cps, pps, latency uint64\n\taggTestResult, _ := gAggregateTestResults[proto]\n\ttest, found := s.tests[EthrTestID{proto, All}]\n\tif found && test.isActive {\n\t\tbwTestOn = true\n\t\tbw = atomic.SwapUint64(&test.testResult.bw, 0)\n\t\tbw /= seconds\n\t\taggTestResult.bw += bw\n\t\taggTestResult.cbw++\n\n\t\tif proto == TCP {\n\t\t\tcpsTestOn = true\n\t\t\tcps = atomic.SwapUint64(&test.testResult.cps, 0)\n\t\t\tcps /= seconds\n\t\t\taggTestResult.cps += cps\n\t\t\taggTestResult.ccps++\n\t\t}\n\n\t\tif proto == UDP {\n\t\t\tppsTestOn = true\n\t\t\tpps = atomic.SwapUint64(&test.testResult.pps, 0)\n\t\t\tpps /= seconds\n\t\t\taggTestResult.pps += pps\n\t\t\taggTestResult.cpps++\n\t\t}\n\n\t\tif proto == TCP {\n\t\t\tlatency = atomic.LoadUint64(&test.testResult.latency)\n\t\t\tif latency > 0 {\n\t\t\t\tlatTestOn = true\n\t\t\t}\n\t\t}\n\n\t\tif test.isDormant && !((bwTestOn && bw != 0) || (cpsTestOn && cps != 0) || (ppsTestOn && pps != 0) || (latTestOn && latency != 0)) {\n\t\t\treturn []string{}\n\t\t}\n\t}\n\n\tif bwTestOn || cpsTestOn || ppsTestOn || latTestOn {\n\t\tvar bwStr, cpsStr, ppsStr, latStr string = \"--  \", \"--  \", \"--  \", \"--  \"\n\t\tif bwTestOn {\n\t\t\tbwStr = bytesToRate(bw)\n\t\t}\n\t\tif cpsTestOn {\n\t\t\tcpsStr = cpsToString(cps)\n\t\t}\n\t\tif ppsTestOn {\n\t\t\tppsStr = ppsToString(pps)\n\t\t}\n\t\tif latTestOn {\n\t\t\tlatStr = durationToString(time.Duration(latency))\n\t\t}\n\t\tstr := []string{s.remoteIP, protoToString(proto),\n\t\t\tbwStr, cpsStr, ppsStr, latStr}\n\t\treturn str\n\t}\n\n\treturn []string{}\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 8.5107421875,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"bytes\"\n\t\"container/list\"\n\t\"encoding/binary\"\n\t\"encoding/gob\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype EthrTestType uint32\n\nconst (\n\tAll EthrTestType = iota\n\tBandwidth\n\tCps\n\tPps\n\tLatency\n\tPing\n\tTraceRoute\n\tMyTraceRoute\n)\n\ntype EthrProtocol uint32\n\nconst (\n\tTCP EthrProtocol = iota\n\tUDP\n\tICMP\n)\n\nconst (\n\tICMPv4 = 1  // ICMP for IPv4\n\tICMPv6 = 58 // ICMP for IPv6\n)\n\ntype EthrTestID struct {\n\tProtocol EthrProtocol\n\tType     EthrTestType\n}\n\ntype EthrMsgType uint32\n\nconst (\n\tEthrInv EthrMsgType = iota\n\tEthrSyn\n\tEthrAck\n)\n\ntype EthrMsgVer uint32\n\ntype EthrMsg struct {\n\tVersion EthrMsgVer\n\tType    EthrMsgType\n\tSyn     *EthrMsgSyn\n\tAck     *EthrMsgAck\n}\n\ntype EthrMsgSyn struct {\n\tTestID      EthrTestID\n\tClientParam EthrClientParam\n}\n\ntype EthrMsgAck struct {\n}\n\ntype ethrTestResult struct {\n\tbw      uint64\n\tcps     uint64\n\tpps     uint64\n\tlatency uint64\n\t// clatency uint64\n}\n\ntype ethrTest struct {\n\tisActive    bool\n\tisDormant   bool\n\tsession     *ethrSession\n\tremoteAddr  string\n\tremoteIP    string\n\tremotePort  string\n\tdialAddr    string\n\trefCount    int32\n\ttestID      EthrTestID\n\tclientParam EthrClientParam\n\ttestResult  ethrTestResult\n\tdone        chan struct{}\n\tconnList    *list.List\n\tlastAccess  time.Time\n}\n\ntype ethrIPVer uint32\n\nconst (\n\tethrIPAny ethrIPVer = iota\n\tethrIPv4\n\tethrIPv6\n)\n\ntype EthrClientParam struct {\n\tNumThreads  uint32\n\tBufferSize  uint32\n\tRttCount    uint32\n\tReverse     bool\n\tDuration    time.Duration\n\tGap         time.Duration\n\tWarmupCount uint32\n\tBwRate      uint64\n\tToS         uint8\n}\n\ntype ethrServerParam struct {\n\tshowUI bool\n}\n\nvar gIPVersion ethrIPVer = ethrIPAny\nvar gIsExternalClient bool\n\ntype ethrConn struct {\n\tbw      uint64\n\tpps     uint64\n\ttest    *ethrTest\n\tconn    net.Conn\n\telem    *list.Element\n\tfd      uintptr\n\tretrans uint64\n}\n\ntype ethrSession struct {\n\tremoteIP  string\n\ttestCount uint32\n\ttests     map[EthrTestID]*ethrTest\n}\n\nvar gSessions = make(map[string]*ethrSession)\nvar gSessionKeys = make([]string, 0)\nvar gSessionLock sync.RWMutex\n\nfunc deleteKey(key string) {\n\ti := 0\n\tfor _, x := range gSessionKeys {\n\t\tif x != key {\n\t\t\tgSessionKeys[i] = x\n\t\t\ti++\n\t\t}\n\t}\n\tgSessionKeys = gSessionKeys[:i]\n}\n\nfunc newTest(remoteIP string, testID EthrTestID, clientParam EthrClientParam) (*ethrTest, error) {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\treturn newTestInternal(remoteIP, testID, clientParam)\n}\n\nfunc newTestInternal(remoteIP string, testID EthrTestID, clientParam EthrClientParam) (*ethrTest, error) {\n\tvar session *ethrSession\n\tsession, found := gSessions[remoteIP]\n\tif !found {\n\t\tsession = &ethrSession{}\n\t\tsession.remoteIP = remoteIP\n\t\tsession.tests = make(map[EthrTestID]*ethrTest)\n\t\tgSessions[remoteIP] = session\n\t\tgSessionKeys = append(gSessionKeys, remoteIP)\n\t}\n\n\ttest, found := session.tests[testID]\n\tif found {\n\t\treturn test, os.ErrExist\n\t}\n\tsession.testCount++\n\ttest = &ethrTest{}\n\ttest.session = session\n\ttest.refCount = 0\n\ttest.testID = testID\n\ttest.clientParam = clientParam\n\ttest.done = make(chan struct{})\n\ttest.connList = list.New()\n\ttest.lastAccess = time.Now()\n\ttest.isDormant = true\n\tsession.tests[testID] = test\n\n\treturn test, nil\n}\n\nfunc deleteTest(test *ethrTest) {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\tdeleteTestInternal(test)\n}\n\nfunc deleteTestInternal(test *ethrTest) {\n\tsession := test.session\n\ttestID := test.testID\n\t//\n\t// TODO fix this, we need to decide where to close this, inside this\n\t// function or by the caller. The reason we may need it to be done by\n\t// the caller is, because done is used for test done notification and\n\t// there may be some time after done that consumers are still accessing it\n\t//\n\t// Since we have not added any refCounting on test object, we are doing\n\t// hacky timeout based solution by closing \"done\" outside and sleeping\n\t// for sufficient time. ugh!\n\t//\n\t// close(test.done)\n\t// test.ctrlConn.Close()\n\t// test.session = nil\n\t// test.connList = test.connList.Init()\n\t//\n\tdelete(session.tests, testID)\n\tsession.testCount--\n\n\tif session.testCount == 0 {\n\t\tdeleteKey(session.remoteIP)\n\t\tdelete(gSessions, session.remoteIP)\n\t}\n}\n\nfunc getTest(remoteIP string, proto EthrProtocol, testType EthrTestType) (test *ethrTest) {\n\tgSessionLock.RLock()\n\tdefer gSessionLock.RUnlock()\n\treturn getTestInternal(remoteIP, proto, testType)\n}\n\nfunc getTestInternal(remoteIP string, proto EthrProtocol, testType EthrTestType) (test *ethrTest) {\n\ttest = nil\n\tsession, found := gSessions[remoteIP]\n\tif !found {\n\t\treturn\n\t}\n\ttest, _ = session.tests[EthrTestID{proto, testType}]\n\treturn\n}\n\nfunc createOrGetTest(remoteIP string, proto EthrProtocol, testType EthrTestType) (test *ethrTest, isNew bool) {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\tisNew = false\n\ttest = getTestInternal(remoteIP, proto, testType)\n\tif test == nil {\n\t\tisNew = true\n\t\ttestID := EthrTestID{proto, testType}\n\t\ttest, _ = newTestInternal(remoteIP, testID, EthrClientParam{})\n\t\ttest.isActive = true\n\t}\n\tatomic.AddInt32(&test.refCount, 1)\n\treturn\n}\n\nfunc safeDeleteTest(test *ethrTest) bool {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\tif atomic.AddInt32(&test.refCount, -1) == 0 {\n\t\tdeleteTestInternal(test)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc addRef(test *ethrTest) {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\t// TODO: Since we already take lock, atomic is not needed. Fix this later.\n\tatomic.AddInt32(&test.refCount, 1)\n}\n\nfunc (test *ethrTest) newConn(conn net.Conn) (ec *ethrConn) {\n\tgSessionLock.Lock()\n\tdefer gSessionLock.Unlock()\n\tec = &ethrConn{}\n\tec.test = test\n\tec.conn = conn\n\tec.fd = getFd(conn)\n\tec.elem = test.connList.PushBack(ec)\n\treturn\n}\n\nfunc (test *ethrTest) delConn(conn net.Conn) {\n\tfor e := test.connList.Front(); e != nil; e = e.Next() {\n\t\tec := e.Value.(*ethrConn)\n\t\tif ec.conn == conn {\n\t\t\ttest.connList.Remove(e)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (test *ethrTest) connListDo(f func(*ethrConn)) {\n\tgSessionLock.RLock()\n\tdefer gSessionLock.RUnlock()\n\tfor e := test.connList.Front(); e != nil; e = e.Next() {\n\t\tec := e.Value.(*ethrConn)\n\t\tf(ec)\n\t}\n}\n\nfunc createSynMsg(testID EthrTestID, clientParam EthrClientParam) (ethrMsg *EthrMsg) {\n\tethrMsg = &EthrMsg{Version: 0, Type: EthrSyn}\n\tethrMsg.Syn = &EthrMsgSyn{}\n\tethrMsg.Syn.TestID = testID\n\tethrMsg.Syn.ClientParam = clientParam\n\treturn\n}\n\nfunc createAckMsg() (ethrMsg *EthrMsg) {\n\tethrMsg = &EthrMsg{Version: 0, Type: EthrAck}\n\tethrMsg.Ack = &EthrMsgAck{}\n\treturn\n}\n\nfunc recvSessionMsg(conn net.Conn) (ethrMsg *EthrMsg) {\n\tethrMsg = &EthrMsg{}\n\tethrMsg.Type = EthrInv\n\tmsgBytes := make([]byte, 4)\n\t_, err := io.ReadFull(conn, msgBytes)\n\tif err != nil {\n\t\tui.printDbg(\"Error receiving message on control channel. Error: %v\", err)\n\t\treturn\n\t}\n\tmsgSize := binary.BigEndian.Uint32(msgBytes[0:])\n\t// TODO: Assuming max ethr message size as 16K sent over gob.\n\tif msgSize > 16384 {\n\t\treturn\n\t}\n\tmsgBytes = make([]byte, msgSize)\n\t_, err = io.ReadFull(conn, msgBytes)\n\tif err != nil {\n\t\tui.printDbg(\"Error receiving message on control channel. Error: %v\", err)\n\t\treturn\n\t}\n\tethrMsg = decodeMsg(msgBytes)\n\treturn\n}\n\nfunc recvSessionMsgFromBuffer(msgBytes []byte) (ethrMsg *EthrMsg) {\n\tethrMsg = decodeMsg(msgBytes)\n\treturn\n}\n\nfunc sendSessionMsg(conn net.Conn, ethrMsg *EthrMsg) (err error) {\n\tmsgBytes, err := encodeMsg(ethrMsg)\n\tif err != nil {\n\t\tui.printDbg(\"Error sending message on control channel. Message: %v, Error: %v\", ethrMsg, err)\n\t\treturn\n\t}\n\tmsgSize := len(msgBytes)\n\ttempBuf := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(tempBuf[0:], uint32(msgSize))\n\t_, err = conn.Write(tempBuf)\n\tif err != nil {\n\t\tui.printDbg(\"Error sending message on control channel. Message: %v, Error: %v\", ethrMsg, err)\n\t}\n\t_, err = conn.Write(msgBytes)\n\tif err != nil {\n\t\tui.printDbg(\"Error sending message on control channel. Message: %v, Error: %v\", ethrMsg, err)\n\t}\n\treturn err\n}\n\nfunc decodeMsg(msgBytes []byte) (ethrMsg *EthrMsg) {\n\tethrMsg = &EthrMsg{}\n\tbuffer := bytes.NewBuffer(msgBytes)\n\tdecoder := gob.NewDecoder(buffer)\n\terr := decoder.Decode(ethrMsg)\n\tif err != nil {\n\t\tui.printDbg(\"Failed to decode message using Gob: %v\", err)\n\t\tethrMsg.Type = EthrInv\n\t}\n\treturn\n}\n\nfunc encodeMsg(ethrMsg *EthrMsg) (msgBytes []byte, err error) {\n\tvar writeBuffer bytes.Buffer\n\tencoder := gob.NewEncoder(&writeBuffer)\n\terr = encoder.Encode(ethrMsg)\n\tif err != nil {\n\t\tui.printDbg(\"Failed to encode message using Gob: %v\", err)\n\t\treturn\n\t}\n\tmsgBytes = writeBuffer.Bytes()\n\treturn\n}\n"
        },
        {
          "name": "snap",
          "type": "tree",
          "content": null
        },
        {
          "name": "stats.go",
          "type": "blob",
          "size": 3.7060546875,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"sort\"\n\t\"time\"\n)\n\ntype ethrNetStat struct {\n\tnetDevStats []ethrNetDevStat\n\ttcpStats    ethrTCPStat\n}\n\ntype ethrNetDevStat struct {\n\tinterfaceName string\n\trxBytes       uint64\n\ttxBytes       uint64\n\trxPkts        uint64\n\ttxPkts        uint64\n}\n\ntype ethrTCPStat struct {\n\tsegRetrans uint64\n}\n\nfunc getNetworkStats() ethrNetStat {\n\tstats := &ethrNetStat{}\n\tgetNetDevStats(stats)\n\t/*\n\t\tdevStats, err := osStats.GetNetDevStats()\n\t\tif err != nil {\n\t\t\treturn stats.EthrNetStats{}, errors.Wrap(err, \"getNetworkStats: could not get net device stats\")\n\t\t}\n\t*/\n\tsort.SliceStable(stats.netDevStats, func(i, j int) bool {\n\t\treturn stats.netDevStats[i].interfaceName < stats.netDevStats[j].interfaceName\n\t})\n\tgetTCPStats(stats)\n\n\t/*\n\t\ttcpStats, err := osStats.GetTCPStats()\n\t\tif err != nil {\n\t\t\treturn stats.EthrNetStats{}, errors.Wrap(err, \"getNetworkStats: could not get net TCP stats\")\n\t\t}\n\n\t\treturn stats.EthrNetStats{NetDevStats: devStats, TCPStats: tcpStats}, nil\n\t*/\n\treturn *stats\n}\n\nfunc getNetDevStatDiff(curStats ethrNetDevStat, prevNetStats ethrNetStat, seconds uint64) ethrNetDevStat {\n\tfor _, prevStats := range prevNetStats.netDevStats {\n\t\tif prevStats.interfaceName != curStats.interfaceName {\n\t\t\tcontinue\n\t\t}\n\n\t\tif curStats.rxBytes >= prevStats.rxBytes {\n\t\t\tcurStats.rxBytes -= prevStats.rxBytes\n\t\t} else {\n\t\t\tcurStats.rxBytes += (^uint64(0) - prevStats.rxBytes)\n\t\t}\n\n\t\tif curStats.txBytes >= prevStats.txBytes {\n\t\t\tcurStats.txBytes -= prevStats.txBytes\n\t\t} else {\n\t\t\tcurStats.txBytes += (^uint64(0) - prevStats.txBytes)\n\t\t}\n\n\t\tif curStats.rxPkts >= prevStats.rxPkts {\n\t\t\tcurStats.rxPkts -= prevStats.rxPkts\n\t\t} else {\n\t\t\tcurStats.rxPkts += (^uint64(0) - prevStats.rxPkts)\n\t\t}\n\n\t\tif curStats.txPkts >= prevStats.txPkts {\n\t\t\tcurStats.txPkts -= prevStats.txPkts\n\t\t} else {\n\t\t\tcurStats.txPkts += (^uint64(0) - prevStats.txPkts)\n\t\t}\n\n\t\tbreak\n\t}\n\tcurStats.rxBytes /= seconds\n\tcurStats.txBytes /= seconds\n\tcurStats.rxPkts /= seconds\n\tcurStats.txPkts /= seconds\n\treturn curStats\n}\n\nvar statsEnabled bool\n\nfunc startStatsTimer() {\n\tif statsEnabled {\n\t\treturn\n\t}\n\n\t// In an ideal setup, client and server should print stats at the same time.\n\t// However, instead of building a whole time synchronization mechanism, a\n\t// hack is used that starts stat at a second granularity. This is done on\n\t// both client and sever, and as long as both client & server have time\n\t// synchronized e.g. with a time server, both would print stats of the running\n\t// test at _almost_ the same time.\n\tSleepUntilNextWholeSecond()\n\n\tlastStatsTime = time.Now()\n\tticker := time.NewTicker(time.Second)\n\tstatsEnabled = true\n\tgo func() {\n\t\tfor statsEnabled {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\temitStats()\n\t\t\t}\n\t\t}\n\t\tticker.Stop()\n\t\treturn\n\t}()\n}\n\nfunc stopStatsTimer() {\n\tstatsEnabled = false\n}\n\nvar lastStatsTime time.Time = time.Now()\n\nfunc timeToNextTick() time.Duration {\n\tnextTick := lastStatsTime.Add(time.Second)\n\treturn time.Until(nextTick)\n}\n\nfunc emitStats() {\n\td := time.Since(lastStatsTime)\n\tlastStatsTime = time.Now()\n\tseconds := int64(d.Seconds())\n\tif seconds < 1 {\n\t\tseconds = 1\n\t}\n\tui.emitTestResultBegin()\n\temitTestResults(uint64(seconds))\n\tui.emitTestResultEnd()\n\tui.emitStats(getNetworkStats())\n\tui.paint(uint64(seconds))\n}\n\nfunc emitTestResults(s uint64) {\n\tgSessionLock.RLock()\n\tdefer gSessionLock.RUnlock()\n\tfor _, k := range gSessionKeys {\n\t\tv := gSessions[k]\n\t\tui.emitTestResult(v, TCP, s)\n\t\tui.emitTestResult(v, UDP, s)\n\t\tui.emitTestResult(v, ICMP, s)\n\t}\n}\n"
        },
        {
          "name": "travis_build.sh",
          "type": "blob",
          "size": 0.5126953125,
          "content": "#!/bin/bash\necho \"${TRAVIS_OS_NAME}\"\necho \"${TRAVIS_GO_VERSION}\"\nif [ \"${TRAVIS_OS_NAME}\" = \"linux\" ]; then\n    export GOOS=windows\n    export GOARCH=amd64\n    go build -o windows/ethr.exe -ldflags \"-X main.gVersion=$TRAVIS_TAG\"\n    export GOOS=linux\n    go build -o linux/ethr -ldflags \"-X main.gVersion=$TRAVIS_TAG\"\n    export GOOS=darwin\n    go build -o osx/ethr -ldflags \"-X main.gVersion=$TRAVIS_TAG\"\n    zip -j ethr_windows.zip windows/ethr.exe\n    zip -j ethr_linux.zip linux/ethr\n    zip -j ethr_osx.zip osx/ethr\nfi\n\n"
        },
        {
          "name": "ui.go",
          "type": "blob",
          "size": 5.14453125,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n\n\t\"github.com/mattn/go-runewidth\"\n\ttm \"github.com/nsf/termbox-go\"\n)\n\nconst (\n\tlefttop = iota\n\thorizontal\n\trighttop\n\tvertical\n\tleftbottom\n\trightbottom\n\tmiddlebottom\n\tmiddletop\n\tmiddleleft\n\tmiddleright\n\tmiddlemiddle\n\tspace\n\tbox1\n\tbox2\n\tbox3\n\tbox4\n\tuparrow\n\tdnarrow\n)\n\nvar symbols = []rune{'', '', '', '', '', '', '', '', '', '', '', ' ', '', '', '', '', '', ''}\n\nconst (\n\tjustifyLeft = iota\n\tjustifyRight\n\tjustifyCenter\n)\n\nconst (\n\tborder = iota\n\tnoBorder\n)\n\ntype table struct {\n\tccount  int\n\tcwidth  []int\n\tx       int\n\ty       int\n\tcr      int\n\tjustify int\n\tborder  int\n}\n\nfunc init() {\n\tif runewidth.IsEastAsian() {\n\t\tsymbols = []rune{'+', '-', '+', '|', '+', '+', '+', '+', '+', '+', '+', ' ', '', '', '', '', '^', 'v'}\n\t}\n}\n\nfunc (t *table) drawTblRow(ledge, redge, middle, spr rune, fg, bg tm.Attribute) {\n\ttwidth := t.ccount + 1\n\tfor _, w := range t.cwidth {\n\t\ttwidth += w\n\t}\n\n\tfor i := 0; i < twidth; i++ {\n\t\ttm.SetCell(t.x+i, t.y+t.cr, middle, fg, bg)\n\t}\n\n\tif t.border == border {\n\t\ttm.SetCell(t.x, t.y+t.cr, ledge, fg, bg)\n\t\ttm.SetCell(t.x+twidth, t.y+t.cr, redge, fg, bg)\n\t}\n\n\to := 0\n\tfor c, w := range t.cwidth {\n\t\to += w + 1\n\t\tif c < t.ccount-1 {\n\t\t\ttm.SetCell(t.x+o, t.y+t.cr, spr, fg, bg)\n\t\t}\n\t}\n\tt.cr++\n}\n\nfunc (t *table) addTblRow(row []string) {\n\tt.drawTblRow(symbols[vertical], symbols[vertical], symbols[space],\n\t\tsymbols[vertical], tm.ColorDefault, tm.ColorDefault)\n\tt.cr--\n\n\to := 1\n\talignOffset := 0\n\tfor i := 0; i < t.ccount; i++ {\n\t\tw := t.cwidth[i]\n\t\tvar s string\n\t\tif t.justify == justifyLeft {\n\t\t\ts = fmt.Sprintf(\"%-*s\", w, row[i])\n\t\t\tif i == 0 && t.border == noBorder {\n\t\t\t\talignOffset = -1\n\t\t\t}\n\t\t} else {\n\t\t\ts = fmt.Sprintf(\"%*s\", w, row[i])\n\t\t}\n\t\tprintText(t.x+o+alignOffset, t.y+t.cr, w, s, tm.ColorDefault, tm.ColorDefault)\n\t\to += w + 1\n\t\talignOffset = 0\n\t}\n\n\tt.cr++\n}\n\nfunc (t *table) addTblSpr() {\n\tt.drawTblRow(symbols[middleleft], symbols[middleright], symbols[horizontal],\n\t\tsymbols[middlemiddle], tm.ColorDefault, tm.ColorDefault)\n}\n\nfunc (t *table) addTblHdr() {\n\tt.drawTblRow(symbols[lefttop], symbols[righttop], symbols[horizontal],\n\t\tsymbols[middletop], tm.ColorDefault, tm.ColorDefault)\n}\n\nfunc (t *table) addTblFtr() {\n\tt.drawTblRow(symbols[leftbottom], symbols[rightbottom], symbols[horizontal],\n\t\tsymbols[middlebottom], tm.ColorDefault, tm.ColorDefault)\n}\n\nfunc printHLineText(x, y int, w int, text string) {\n\tfor i := 0; i < w; i++ {\n\t\ttm.SetCell(x+i, y, symbols[horizontal], tm.ColorWhite, tm.ColorDefault)\n\t}\n\toffset := (w - runewidth.StringWidth(text)) / 2\n\ttextArr := []rune(text)\n\txoff := 0\n\tfor i := 0; i < len(text); i++ {\n\t\ttm.SetCell(x+offset+i+xoff, y, textArr[i], tm.ColorWhite, tm.ColorDefault)\n\t\tif runewidth.RuneWidth(textArr[i]) == 2 {\n\t\t\txoff++\n\t\t}\n\t}\n}\n\nfunc printVLine(x, y int, h int) {\n\ttm.SetCell(x, y, symbols[middletop], tm.ColorWhite, tm.ColorDefault)\n\tfor i := 1; i < h; i++ {\n\t\ttm.SetCell(x, y+i, symbols[vertical], tm.ColorWhite, tm.ColorDefault)\n\t}\n}\n\nfunc printText(x, y, w int, text string, fg, bg tm.Attribute) {\n\ttextArr := []rune(text)\n\tfor i := 0; i < w; i++ {\n\t\ttm.SetCell(x+i, y, ' ', fg, bg)\n\t}\n\txoff := 0\n\tfor i := 0; i < len(textArr); i++ {\n\t\ttm.SetCell(x+i+xoff, y, textArr[i], fg, bg)\n\t\tif runewidth.RuneWidth(textArr[i]) == 2 {\n\t\t\txoff++\n\t\t}\n\t}\n}\n\nfunc printCenterText(x, y, w int, text string, fg, bg tm.Attribute) {\n\toffset := (w - runewidth.StringWidth(text)) / 2\n\ttextArr := []rune(text)\n\tfor i := 0; i < w; i++ {\n\t\ttm.SetCell(x+i, y, ' ', fg, bg)\n\t}\n\txoff := 0\n\tfor i := 0; i < len(textArr); i++ {\n\t\ttm.SetCell(x+offset+i+xoff, y, textArr[i], fg, bg)\n\t\tif runewidth.RuneWidth(textArr[i]) == 2 {\n\t\t\txoff++\n\t\t}\n\t}\n}\n\nfunc printHLine(x, y int, w int) {\n\tfor i := 0; i < w; i++ {\n\t\ttm.SetCell(x+i, y, symbols[horizontal], tm.ColorWhite, tm.ColorDefault)\n\t}\n}\n\nfunc printUsageBar(x, y, w int, usage, scale uint64, clr tm.Attribute) {\n\tbarw := int(math.Log10(float64(uint64((usage + scale - 1) / (scale / 10)))))\n\tif barw > w {\n\t\tbarw = w\n\t} else if barw < 0 {\n\t\tbarw = 0\n\t}\n\tfor j := 0; j < w; j++ {\n\t\ttm.SetCell(x+j, y, symbols[box3], clr, tm.ColorDefault)\n\t}\n\tfor j := 0; j < barw; j++ {\n\t\ttm.SetCell(x+j, y, symbols[box3], clr|tm.AttrBold, clr)\n\t}\n}\n\nfunc printDivider() {\n\tui.printMsg(\"-----------------------------------------------------------\")\n}\nfunc printDivider2() {\n\tui.printMsg(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\")\n}\n\ntype ethrUI interface {\n\tfini()\n\tgetTitle() string\n\tprintMsg(format string, a ...interface{})\n\tprintErr(format string, a ...interface{})\n\tprintDbg(format string, a ...interface{})\n\tpaint(uint64)\n\temitTestHdr()\n\temitLatencyHdr()\n\temitLatencyResults(remote, proto string, avg, min, max, p50, p90, p95, p99, p999, p9999 time.Duration)\n\temitTestResultBegin()\n\temitTestResult(*ethrSession, EthrProtocol, uint64)\n\tprintTestResults([]string)\n\temitTestResultEnd()\n\temitStats(ethrNetStat)\n}\n\nvar ui ethrUI\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 9.654296875,
          "content": "//-----------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license.\n// See LICENSE.txt file in the project root for full license information.\n//-----------------------------------------------------------------------------\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nvar gLocalIP = \"\"\nvar gEthrPort = uint16(8888)\nvar gEthrPortStr = \"\"\nvar gClientPort = uint16(0)\nvar gTOS = uint8(0)\nvar gTTL = uint8(0)\n\nconst (\n\tUNO  = 1\n\tKILO = 1000\n\tMEGA = 1000 * 1000\n\tGIGA = 1000 * 1000 * 1000\n\tTERA = 1000 * 1000 * 1000 * 1000\n)\n\nfunc numberToUnit(num uint64) string {\n\tunit := \"\"\n\tvalue := float64(num)\n\n\tswitch {\n\tcase num >= TERA:\n\t\tunit = \"T\"\n\t\tvalue = value / TERA\n\tcase num >= GIGA:\n\t\tunit = \"G\"\n\t\tvalue = value / GIGA\n\tcase num >= MEGA:\n\t\tunit = \"M\"\n\t\tvalue = value / MEGA\n\tcase num >= KILO:\n\t\tunit = \"K\"\n\t\tvalue = value / KILO\n\t}\n\n\tresult := strconv.FormatFloat(value, 'f', 2, 64)\n\tresult = strings.TrimSuffix(result, \".00\")\n\treturn result + unit\n}\n\nfunc unitToNumber(s string) uint64 {\n\ts = strings.TrimSpace(s)\n\ts = strings.ToUpper(s)\n\n\ti := strings.IndexFunc(s, unicode.IsLetter)\n\n\tif i == -1 {\n\t\tbytes, err := strconv.ParseFloat(s, 64)\n\t\tif err != nil || bytes <= 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn uint64(bytes)\n\t}\n\n\tbytesString, multiple := s[:i], s[i:]\n\tbytes, err := strconv.ParseFloat(bytesString, 64)\n\tif err != nil || bytes <= 0 {\n\t\treturn 0\n\t}\n\n\tswitch multiple {\n\tcase \"T\", \"TB\", \"TIB\":\n\t\treturn uint64(bytes * TERA)\n\tcase \"G\", \"GB\", \"GIB\":\n\t\treturn uint64(bytes * GIGA)\n\tcase \"M\", \"MB\", \"MIB\":\n\t\treturn uint64(bytes * MEGA)\n\tcase \"K\", \"KB\", \"KIB\":\n\t\treturn uint64(bytes * KILO)\n\tcase \"B\":\n\t\treturn uint64(bytes)\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc bytesToRate(bytes uint64) string {\n\tbits := bytes * 8\n\tresult := numberToUnit(bits)\n\treturn result\n}\n\nfunc cpsToString(cps uint64) string {\n\tresult := numberToUnit(cps)\n\treturn result\n}\n\nfunc ppsToString(pps uint64) string {\n\tresult := numberToUnit(pps)\n\treturn result\n}\n\nfunc testToString(testType EthrTestType) string {\n\tswitch testType {\n\tcase Bandwidth:\n\t\treturn \"Bandwidth\"\n\tcase Cps:\n\t\treturn \"Connections/s\"\n\tcase Pps:\n\t\treturn \"Packets/s\"\n\tcase Latency:\n\t\treturn \"Latency\"\n\tcase Ping:\n\t\treturn \"Ping\"\n\tcase TraceRoute:\n\t\treturn \"TraceRoute\"\n\tcase MyTraceRoute:\n\t\treturn \"MyTraceRoute\"\n\tdefault:\n\t\treturn \"Invalid\"\n\t}\n}\n\nfunc durationToString(d time.Duration) string {\n\tif d < 0 {\n\t\treturn d.String()\n\t}\n\tud := uint64(d)\n\tval := float64(ud)\n\tunit := \"\"\n\tif ud < uint64(60*time.Second) {\n\t\tswitch {\n\t\tcase ud < uint64(time.Microsecond):\n\t\t\tunit = \"ns\"\n\t\tcase ud < uint64(time.Millisecond):\n\t\t\tval = val / 1000\n\t\t\tunit = \"us\"\n\t\tcase ud < uint64(time.Second):\n\t\t\tval = val / (1000 * 1000)\n\t\t\tunit = \"ms\"\n\t\tdefault:\n\t\t\tval = val / (1000 * 1000 * 1000)\n\t\t\tunit = \"s\"\n\t\t}\n\n\t\tresult := strconv.FormatFloat(val, 'f', 3, 64)\n\t\treturn result + unit\n\t}\n\n\treturn d.String()\n}\n\nfunc protoToString(proto EthrProtocol) string {\n\tswitch proto {\n\tcase TCP:\n\t\treturn \"TCP\"\n\tcase UDP:\n\t\treturn \"UDP\"\n\tcase ICMP:\n\t\treturn \"ICMP\"\n\t}\n\treturn \"\"\n}\n\nfunc Tcp() string {\n\tswitch gIPVersion {\n\tcase ethrIPv4:\n\t\treturn \"tcp4\"\n\tcase ethrIPv6:\n\t\treturn \"tcp6\"\n\t}\n\treturn \"tcp\"\n}\n\nfunc Udp() string {\n\tswitch gIPVersion {\n\tcase ethrIPv4:\n\t\treturn \"udp4\"\n\tcase ethrIPv6:\n\t\treturn \"udp6\"\n\t}\n\treturn \"udp\"\n}\n\nfunc Icmp() string {\n\tswitch gIPVersion {\n\tcase ethrIPv6:\n\t\treturn \"ip6:ipv6-icmp\"\n\tdefault:\n\t\treturn \"ip4:icmp\"\n\t}\n}\n\nfunc IcmpProto() int {\n\tif gIPVersion == ethrIPv6 {\n\t\treturn ICMPv6\n\t}\n\treturn ICMPv4\n}\n\nfunc ethrUnused(vals ...interface{}) {\n\tfor _, val := range vals {\n\t\t_ = val\n\t}\n}\n\nfunc splitString(longString string, maxLen int) []string {\n\tsplits := []string{}\n\n\tvar l, r int\n\tfor l, r = 0, maxLen; r < len(longString); l, r = r, r+maxLen {\n\t\tfor !utf8.RuneStart(longString[r]) {\n\t\t\tr--\n\t\t}\n\t\tsplits = append(splits, longString[l:r])\n\t}\n\tsplits = append(splits, longString[l:])\n\treturn splits\n}\n\nfunc max(x, y uint64) uint64 {\n\tif x < y {\n\t\treturn y\n\t}\n\treturn x\n}\n\nfunc toString(n int) string {\n\treturn fmt.Sprintf(\"%d\", n)\n}\n\nfunc toInt(s string) int {\n\tres, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tui.printDbg(\"Error in string conversion: %v\", err)\n\t\treturn 0\n\t}\n\treturn res\n}\n\nfunc truncateStringFromStart(str string, num int) string {\n\ts := str\n\tl := len(str)\n\tif l > num {\n\t\tif num > 3 {\n\t\t\ts = \"...\" + str[l-num+3:l]\n\t\t} else {\n\t\t\ts = str[l-num : l]\n\t\t}\n\t}\n\treturn s\n}\n\nfunc truncateStringFromEnd(str string, num int) string {\n\ts := str\n\tl := len(str)\n\tif l > num {\n\t\tif num > 3 {\n\t\t\ts = str[0:num] + \"...\"\n\t\t} else {\n\t\t\ts = str[0:num]\n\t\t}\n\t}\n\treturn s\n}\n\nfunc roundUpToZero(n int64) int64 {\n\ty := n >> 63\n\treturn (n ^ y) - y\n}\n\nfunc getFd(conn net.Conn) uintptr {\n\tvar fd uintptr\n\tvar rc syscall.RawConn\n\tvar err error\n\tswitch ct := conn.(type) {\n\tcase *net.TCPConn:\n\t\trc, err = ct.SyscallConn()\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\tcase *net.UDPConn:\n\t\trc, err = ct.SyscallConn()\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\tdefault:\n\t\treturn 0\n\t}\n\tfn := func(s uintptr) {\n\t\tfd = s\n\t}\n\trc.Control(fn)\n\treturn fd\n}\n\ntype tcpKeepAliveListener struct {\n\t*net.TCPListener\n}\n\nfunc (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {\n\ttc, err := ln.AcceptTCP()\n\tif err != nil {\n\t\treturn\n\t}\n\ttc.SetKeepAlive(true)\n\ttc.SetKeepAlivePeriod(3 * time.Minute)\n\treturn tc, nil\n}\n\nfunc SleepUntilNextWholeSecond() {\n\tt0 := time.Now()\n\tt1 := t0.Add(time.Second)\n\tres := t1.Round(time.Second)\n\ttime.Sleep(time.Until(res))\n}\n\nfunc ethrSetTTL(fd uintptr, ttl int) {\n\tif ttl == 0 {\n\t\treturn\n\t}\n\tif gIPVersion == ethrIPv4 {\n\t\tsetSockOptInt(fd, syscall.IPPROTO_IP, syscall.IP_TTL, ttl)\n\t} else {\n\t\tsetSockOptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, ttl)\n\t}\n}\n\nfunc ethrSetTOS(fd uintptr, tos int) {\n\tif tos == 0 {\n\t\treturn\n\t}\n\tif gIPVersion == ethrIPv4 {\n\t\tsetSockOptInt(fd, syscall.IPPROTO_IP, syscall.IP_TOS, tos)\n\t} else {\n\t\tSetTClass(fd, tos)\n\t}\n}\n\nfunc ethrDial(p EthrProtocol, dialAddr string) (conn net.Conn, err error) {\n\treturn ethrDialEx(p, dialAddr, gLocalIP, gClientPort, int(gTTL), int(gTOS))\n}\n\nfunc ethrDialInc(p EthrProtocol, dialAddr string, inc uint16) (conn net.Conn, err error) {\n\tif gClientPort != 0 {\n\t\treturn ethrDialEx(p, dialAddr, gLocalIP, gClientPort+inc, int(gTTL), int(gTOS))\n\t} else {\n\t\treturn ethrDial(p, dialAddr)\n\t}\n}\n\nfunc ethrDialAll(p EthrProtocol, dialAddr string) (conn net.Conn, err error) {\n\treturn ethrDialEx(p, dialAddr, gLocalIP, 0, int(gTTL), int(gTOS))\n}\n\nfunc ethrDialEx(p EthrProtocol, dialAddr, localIP string, localPortNum uint16, ttl int, tos int) (conn net.Conn, err error) {\n\tlocalAddr := fmt.Sprintf(\"%v:%v\", localIP, localPortNum)\n\tvar la net.Addr\n\tnetwork := Tcp()\n\tif p == TCP {\n\t\tla, err = net.ResolveTCPAddr(network, localAddr)\n\t} else if p == UDP {\n\t\tnetwork = Udp()\n\t\tla, err = net.ResolveUDPAddr(network, localAddr)\n\t} else {\n\t\tui.printDbg(\"Only TCP or UDP are allowed in ethrDial\")\n\t\terr = os.ErrInvalid\n\t\treturn\n\t}\n\tif err != nil {\n\t\tui.printErr(\"Unable to resolve TCP or UDP address. Error: %v\", err)\n\t\treturn\n\t}\n\tdialer := &net.Dialer{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t\treturn c.Control(func(fd uintptr) {\n\t\t\t\tethrSetTTL(fd, ttl)\n\t\t\t\tethrSetTOS(fd, tos)\n\t\t\t})\n\t\t},\n\t}\n\tdialer.LocalAddr = la\n\tdialer.Timeout = time.Second\n\tconn, err = dialer.Dial(network, dialAddr)\n\tif err != nil {\n\t\tui.printDbg(\"ethrTCPDial Error: %v\", err)\n\t} else {\n\t\ttcpconn, ok := conn.(*net.TCPConn)\n\t\tif ok {\n\t\t\ttcpconn.SetLinger(0)\n\t\t}\n\t\tudpconn, ok := conn.(*net.UDPConn)\n\t\tif ok {\n\t\t\terr = udpconn.SetWriteBuffer(4 * 1024 * 1024)\n\t\t\tif err != nil {\n\t\t\t\tui.printDbg(\"Failed to set ReadBuffer on UDP socket: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc ethrLookupIP(server string) (net.IPAddr, string, error) {\n\tvar ipAddr net.IPAddr\n\tvar ipStr string\n\n\tip := net.ParseIP(server)\n\tif ip != nil {\n\t\tipAddr.IP = ip\n\t\tipStr = server\n\t\treturn ipAddr, ipStr, nil\n\t}\n\n\tips, err := net.LookupIP(server)\n\tif err != nil {\n\t\tui.printErr(\"Failed to lookup IP address for the server: %v. Error: %v\", server, err)\n\t\treturn ipAddr, ipStr, err\n\t}\n\tfor _, ip := range ips {\n\t\tif gIPVersion == ethrIPAny || (gIPVersion == ethrIPv4 && ip.To4() != nil) || (gIPVersion == ethrIPv6 && ip.To16() != nil) {\n\t\t\tipAddr.IP = ip\n\t\t\tipStr = ip.String()\n\t\t\tui.printDbg(\"Resolved server: %v to IP address: %v\\n\", server, ip)\n\t\t\treturn ipAddr, ipStr, nil\n\t\t}\n\t}\n\tui.printErr(\"Unable to resolve the given server: %v to an IP address.\", server)\n\treturn ipAddr, ipStr, os.ErrNotExist\n}\n\n// This is a workaround to ensure we generate traffic at certain rate\n// and stats are printed correctly. We ensure that current interval lasts\n// 100ms after stats are printed, not perfect but workable.\nfunc beginThrottle(totalBytesToSend uint64, bufferLen int) (start time.Time, waitTime time.Duration, bytesToSend int) {\n\tstart = time.Now()\n\twaitTime = time.Until(lastStatsTime.Add(time.Second + 50*time.Millisecond))\n\tbytesToSend = bufferLen\n\tif totalBytesToSend > 0 && totalBytesToSend < uint64(bufferLen) {\n\t\tbytesToSend = int(totalBytesToSend)\n\t}\n\treturn\n}\n\nfunc enforceThrottle(s time.Time, wt time.Duration, totalBytesToSend, oldSentBytes uint64, bufferLen int) (start time.Time, waitTime time.Duration, newSentBytes uint64, bytesToSend int) {\n\tstart = s\n\twaitTime = wt\n\tnewSentBytes = oldSentBytes\n\tbytesToSend = bufferLen\n\tif totalBytesToSend > 0 {\n\t\tremainingBytes := totalBytesToSend - oldSentBytes\n\t\tif remainingBytes > 0 {\n\t\t\tif remainingBytes < uint64(bufferLen) {\n\t\t\t\tbytesToSend = int(remainingBytes)\n\t\t\t}\n\t\t} else {\n\t\t\ttimeTaken := time.Since(s)\n\t\t\tif timeTaken < wt {\n\t\t\t\ttime.Sleep(wt - timeTaken)\n\t\t\t}\n\t\t\tstart = time.Now()\n\t\t\twaitTime = time.Until(lastStatsTime.Add(time.Second + 50*time.Millisecond))\n\t\t\tnewSentBytes = 0\n\t\t\tif totalBytesToSend < uint64(bufferLen) {\n\t\t\t\tbytesToSend = int(totalBytesToSend)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n"
        }
      ]
    }
  ]
}