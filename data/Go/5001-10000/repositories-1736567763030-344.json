{
  "metadata": {
    "timestamp": 1736567763030,
    "page": 344,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-rod/rod",
      "stars": 5596,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".eslintrc.yml",
          "type": "blob",
          "size": 0.115234375,
          "content": "extends:\n  - eslint:recommended\nenv:\n  browser: true\n  es6: true\nparserOptions:\n  ecmaVersion: 2018\nplugins:\n  - html\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0654296875,
          "content": "vendor/\nnode_modules/\ntmp/\n\n.git\n.dockerignore\n*.out\n*.test\n*.json\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.73828125,
          "content": "linters:\n  enable-all: true\n  disable:\n    - gochecknoinits\n    - paralleltest\n    - wrapcheck\n    - gosec\n    - gochecknoglobals\n    - musttag\n    - varnamelen\n    - wsl\n    - nonamedreturns\n    - tagliatelle\n    - nlreturn\n    - nakedret\n    - gomnd\n    - mnd\n    - err113\n    - exhaustruct\n    - godox\n    - depguard\n    - testpackage\n    - exhaustive\n    - containedctx\n    - prealloc\n    - perfsprint\n    - ireturn\n    - contextcheck\n    - canonicalheader\n    - copyloopvar\n    - intrange\n\n    # Deprecated ones:\n    - execinquery\n    - structcheck\n    - interfacer\n    - deadcode\n    - varcheck\n    - ifshort\n    - exhaustivestruct\n    - golint\n    - maligned\n    - nosnakecase\n    - scopelint\n\nlinters-settings:\n  cyclop:\n    max-complexity: 15\n  gocyclo:\n    min-complexity: 15\n  nestif:\n    min-complexity: 6\n  funlen:\n    lines: 120\n\nissues:\n  exclude-use-default: false\n\n  exclude-rules:\n    - path: _test.go$\n      linters:\n        - lll\n        - funlen\n        - dupword\n        - goconst\n        - contextcheck\n        - errorlint\n        - testableexamples\n        - forcetypeassert\n\n    # Generated code\n    - path: lib/proto/\n      linters:\n        - lll\n        - gocritic\n        - dupword\n        - forcetypeassert\n    - path: lib/devices/list.go\n      linters:\n        - lll\n    - path: lib/js/helper.go\n      linters:\n        - lll\n\n    - path: /fixtures/\n      linters:\n        - forbidigo\n\n    - path: lib/examples/\n      linters:\n        - forbidigo\n        - noctx\n        - gocritic\n\n    - path: examples?_test.go$\n      linters:\n        - forbidigo\n        - noctx\n        - gocritic\n\n    - path: main.go$\n      linters:\n        - forbidigo\n        - noctx\n        - forcetypeassert\n        - lll\n\n    - path: lib/assets/\n      linters:\n        - lll\n"
        },
        {
          "name": ".prettierrc.yml",
          "type": "blob",
          "size": 0.048828125,
          "content": "semi: false\nsingleQuote: true\ntrailingComma: none\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "The MIT License\n\nCopyright 2019 Yad Smood\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8837890625,
          "content": "# Overview\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/go-rod/rod.svg)](https://pkg.go.dev/github.com/go-rod/rod)\n[![Discord Chat](https://img.shields.io/discord/719933559456006165.svg)][discord room]\n\n## [Documentation](https://go-rod.github.io/) | [API reference](https://pkg.go.dev/github.com/go-rod/rod?tab=doc) | [FAQ](https://go-rod.github.io/#/faq/README)\n\nRod is a high-level driver directly based on [DevTools Protocol](https://chromedevtools.github.io/devtools-protocol).\nIt's designed for web automation and scraping for both high-level and low-level use, senior developers can use the low-level packages and functions to easily\ncustomize or build up their own version of Rod, the high-level functions are just examples to build a default version of Rod.\n\n[中文 API 文档](https://pkg.go.dev/github.com/go-rod/go-rod-chinese)\n\n## Features\n\n- Chained context design, intuitive to timeout or cancel the long-running task\n- Auto-wait elements to be ready\n- Debugging friendly, auto input tracing, remote monitoring headless browser\n- Thread-safe for all operations\n- Automatically find or download [browser](lib/launcher)\n- High-level helpers like WaitStable, WaitRequestIdle, HijackRequests, WaitDownload, etc\n- Two-step WaitEvent design, never miss an event ([how it works](https://github.com/ysmood/goob))\n- Correctly handles nested iframes or shadow DOMs\n- No zombie browser process after the crash ([how it works](https://github.com/ysmood/leakless))\n- [CI](https://github.com/go-rod/rod/actions) enforced 100% test coverage\n\n## Examples\n\nPlease check the [examples_test.go](examples_test.go) file first, then check the [examples](lib/examples) folder.\n\nFor more detailed examples, please search the unit tests.\nSuch as the usage of method `HandleAuth`, you can search all the `*_test.go` files that contain `HandleAuth`,\nfor example, use GitHub online [search in repository](https://github.com/go-rod/rod/search?q=HandleAuth&unscoped_q=HandleAuth).\nYou can also search the GitHub [issues](https://github.com/go-rod/rod/issues) or [discussions](https://github.com/go-rod/rod/discussions),\na lot of usage examples are recorded there.\n\n[Here](lib/examples/compare-chromedp) is a comparison of the examples between rod and Chromedp.\n\nIf you have questions, please raise an [issues](https://github.com/go-rod/rod/issues)/[discussions](https://github.com/go-rod/rod/discussions) or join the [chat room][discord room].\n\n## Join us\n\nYour help is more than welcome! Even just open an issue to ask a question may greatly help others.\n\nPlease read [How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html) before you ask questions.\n\nWe use GitHub Projects to manage tasks, you can see the priority and progress of the issues [here](https://github.com/go-rod/rod/projects).\n\nIf you want to contribute please read the [Contributor Guide](.github/CONTRIBUTING.md).\n\n[discord room]: https://discord.gg/CpevuvY\n"
        },
        {
          "name": "browser.go",
          "type": "blob",
          "size": 13.994140625,
          "content": "//go:generate go run ./lib/utils/setup\n//go:generate go run ./lib/proto/generate\n//go:generate go run ./lib/js/generate\n//go:generate go run ./lib/assets/generate\n//go:generate go run ./lib/utils/lint\n\n// Package rod is a high-level driver directly based on DevTools Protocol.\npackage rod\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/defaults\"\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/goob\"\n)\n\n// Browser implements these interfaces.\nvar (\n\t_ proto.Client      = &Browser{}\n\t_ proto.Contextable = &Browser{}\n)\n\n// Browser represents the browser.\n// It doesn't depends on file system, it should work with remote browser seamlessly.\n// To check the env var you can use to quickly enable options from CLI, check here:\n// https://pkg.go.dev/github.com/go-rod/rod/lib/defaults\ntype Browser struct {\n\t// BrowserContextID is the id for incognito window\n\tBrowserContextID proto.BrowserBrowserContextID\n\n\te eFunc\n\n\tctx context.Context\n\n\tsleeper func() utils.Sleeper\n\n\tlogger utils.Logger\n\n\tslowMotion time.Duration // see defaults.slow\n\ttrace      bool          // see defaults.Trace\n\tmonitor    string\n\n\tdefaultDevice devices.Device\n\n\tcontrolURL  string\n\tclient      CDPClient\n\tevent       *goob.Observable // all the browser events from cdp client\n\ttargetsLock *sync.Mutex\n\n\t// stores all the previous cdp call of same type. Browser doesn't have enough API\n\t// for us to retrieve all its internal states. This is an workaround to map them to local.\n\t// For example you can't use cdp API to get the current position of mouse.\n\tstates *sync.Map\n}\n\n// New creates a controller.\n// DefaultDevice to emulate is set to [devices.LaptopWithMDPIScreen].Landscape(), it will change the default\n// user-agent and can make the actual view area smaller than the browser window on headful mode,\n// you can use [Browser.NoDefaultDevice] to disable it.\nfunc New() *Browser {\n\treturn (&Browser{\n\t\tctx:           context.Background(),\n\t\tsleeper:       DefaultSleeper,\n\t\tcontrolURL:    defaults.URL,\n\t\tslowMotion:    defaults.Slow,\n\t\ttrace:         defaults.Trace,\n\t\tmonitor:       defaults.Monitor,\n\t\tlogger:        DefaultLogger,\n\t\tdefaultDevice: devices.LaptopWithMDPIScreen.Landscape(),\n\t\ttargetsLock:   &sync.Mutex{},\n\t\tstates:        &sync.Map{},\n\t}).WithPanic(utils.Panic)\n}\n\n// Incognito creates a new incognito browser.\nfunc (b *Browser) Incognito() (*Browser, error) {\n\tres, err := proto.TargetCreateBrowserContext{}.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tincognito := *b\n\tincognito.BrowserContextID = res.BrowserContextID\n\n\treturn &incognito, nil\n}\n\n// ControlURL set the url to remote control browser.\nfunc (b *Browser) ControlURL(url string) *Browser {\n\tb.controlURL = url\n\treturn b\n}\n\n// SlowMotion set the delay for each control action, such as the simulation of the human inputs.\nfunc (b *Browser) SlowMotion(delay time.Duration) *Browser {\n\tb.slowMotion = delay\n\treturn b\n}\n\n// Trace enables/disables the visual tracing of the input actions on the page.\nfunc (b *Browser) Trace(enable bool) *Browser {\n\tb.trace = enable\n\treturn b\n}\n\n// Monitor address to listen if not empty. Shortcut for [Browser.ServeMonitor].\nfunc (b *Browser) Monitor(url string) *Browser {\n\tb.monitor = url\n\treturn b\n}\n\n// Logger overrides the default log functions for tracing.\nfunc (b *Browser) Logger(l utils.Logger) *Browser {\n\tb.logger = l\n\treturn b\n}\n\n// Client set the cdp client.\nfunc (b *Browser) Client(c CDPClient) *Browser {\n\tb.client = c\n\treturn b\n}\n\n// DefaultDevice sets the default device for new page to emulate in the future.\n// Default is [devices.LaptopWithMDPIScreen].\n// Set it to [devices.Clear] to disable it.\nfunc (b *Browser) DefaultDevice(d devices.Device) *Browser {\n\tb.defaultDevice = d\n\treturn b\n}\n\n// NoDefaultDevice is the same as [Browser.DefaultDevice](devices.Clear).\nfunc (b *Browser) NoDefaultDevice() *Browser {\n\treturn b.DefaultDevice(devices.Clear)\n}\n\n// Connect to the browser and start to control it.\n// If fails to connect, try to launch a local browser, if local browser not found try to download one.\nfunc (b *Browser) Connect() error {\n\tif b.client == nil {\n\t\tu := b.controlURL\n\t\tif u == \"\" {\n\t\t\tvar err error\n\t\t\tu, err = launcher.New().Context(b.ctx).Launch()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tc, err := cdp.StartWithURL(b.ctx, u, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.client = c\n\t} else if b.controlURL != \"\" {\n\t\tpanic(\"Browser.Client and Browser.ControlURL can't be set at the same time\")\n\t}\n\n\tb.initEvents()\n\n\tif b.monitor != \"\" {\n\t\tlauncher.Open(b.ServeMonitor(b.monitor))\n\t}\n\n\treturn proto.TargetSetDiscoverTargets{Discover: true}.Call(b)\n}\n\n// Close the browser.\nfunc (b *Browser) Close() error {\n\tif b.BrowserContextID == \"\" {\n\t\treturn proto.BrowserClose{}.Call(b)\n\t}\n\treturn proto.TargetDisposeBrowserContext{BrowserContextID: b.BrowserContextID}.Call(b)\n}\n\n// Page creates a new browser tab. If opts.URL is empty, the default target will be \"about:blank\".\nfunc (b *Browser) Page(opts proto.TargetCreateTarget) (p *Page, err error) {\n\treq := opts\n\treq.BrowserContextID = b.BrowserContextID\n\treq.URL = \"about:blank\"\n\n\ttarget, err := req.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\t// If Navigate or PageFromTarget fails we should close the target to prevent leak\n\t\tif err != nil {\n\t\t\t_, _ = proto.TargetCloseTarget{TargetID: target.TargetID}.Call(b)\n\t\t}\n\t}()\n\n\tp, err = b.PageFromTarget(target.TargetID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif opts.URL == \"\" {\n\t\treturn\n\t}\n\n\terr = p.Navigate(opts.URL)\n\n\treturn\n}\n\n// Pages retrieves all visible pages.\nfunc (b *Browser) Pages() (Pages, error) {\n\tlist, err := proto.TargetGetTargets{}.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpageList := Pages{}\n\tfor _, target := range list.TargetInfos {\n\t\tif target.Type != proto.TargetTargetInfoTypePage {\n\t\t\tcontinue\n\t\t}\n\n\t\tpage, err := b.PageFromTarget(target.TargetID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpageList = append(pageList, page)\n\t}\n\n\treturn pageList, nil\n}\n\n// Call implements the [proto.Client] to call raw cdp interface directly.\nfunc (b *Browser) Call(ctx context.Context, sessionID, methodName string, params interface{}) (res []byte, err error) {\n\tres, err = b.client.Call(ctx, sessionID, methodName, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb.set(proto.TargetSessionID(sessionID), methodName, params)\n\treturn\n}\n\n// PageFromSession is used for low-level debugging.\nfunc (b *Browser) PageFromSession(sessionID proto.TargetSessionID) *Page {\n\tsessionCtx, cancel := context.WithCancel(b.ctx)\n\treturn &Page{\n\t\te:             b.e,\n\t\tctx:           sessionCtx,\n\t\tsessionCancel: cancel,\n\t\tsleeper:       b.sleeper,\n\t\tbrowser:       b,\n\t\tSessionID:     sessionID,\n\t}\n}\n\n// PageFromTarget gets or creates a Page instance.\nfunc (b *Browser) PageFromTarget(targetID proto.TargetTargetID) (*Page, error) {\n\tb.targetsLock.Lock()\n\tdefer b.targetsLock.Unlock()\n\n\tpage := b.loadCachedPage(targetID)\n\tif page != nil {\n\t\treturn page, nil\n\t}\n\n\tsession, err := proto.TargetAttachToTarget{\n\t\tTargetID: targetID,\n\t\tFlatten:  true, // if it's not set no response will return\n\t}.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsessionCtx, cancel := context.WithCancel(b.ctx)\n\n\tpage = &Page{\n\t\te:             b.e,\n\t\tctx:           sessionCtx,\n\t\tsessionCancel: cancel,\n\t\tsleeper:       b.sleeper,\n\t\tbrowser:       b,\n\t\tTargetID:      targetID,\n\t\tSessionID:     session.SessionID,\n\t\tFrameID:       proto.PageFrameID(targetID),\n\t\tjsCtxLock:     &sync.Mutex{},\n\t\tjsCtxID:       new(proto.RuntimeRemoteObjectID),\n\t\thelpersLock:   &sync.Mutex{},\n\t}\n\n\tpage.root = page\n\tpage.newKeyboard().newMouse().newTouch()\n\n\tif !b.defaultDevice.IsClear() {\n\t\terr = page.Emulate(b.defaultDevice)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb.cachePage(page)\n\n\tpage.initEvents()\n\n\t// If we don't enable it, it will cause a lot of unexpected browser behavior.\n\t// Such as proto.PageAddScriptToEvaluateOnNewDocument won't work.\n\tpage.EnableDomain(&proto.PageEnable{})\n\n\treturn page, nil\n}\n\n// EachEvent is similar to [Page.EachEvent], but catches events of the entire browser.\nfunc (b *Browser) EachEvent(callbacks ...interface{}) (wait func()) {\n\treturn b.eachEvent(\"\", callbacks...)\n}\n\n// WaitEvent waits for the next event for one time. It will also load the data into the event object.\nfunc (b *Browser) WaitEvent(e proto.Event) (wait func()) {\n\treturn b.waitEvent(\"\", e)\n}\n\n// waits for the next event for one time. It will also load the data into the event object.\nfunc (b *Browser) waitEvent(sessionID proto.TargetSessionID, e proto.Event) (wait func()) {\n\tvalE := reflect.ValueOf(e)\n\tvalTrue := reflect.ValueOf(true)\n\n\tif valE.Kind() != reflect.Ptr {\n\t\tvalE = reflect.New(valE.Type())\n\t}\n\n\t// dynamically creates a function on runtime:\n\t//\n\t// func(ee proto.Event) bool {\n\t//   *e = *ee\n\t//   return true\n\t// }\n\tfnType := reflect.FuncOf([]reflect.Type{valE.Type()}, []reflect.Type{valTrue.Type()}, false)\n\tfnVal := reflect.MakeFunc(fnType, func(args []reflect.Value) []reflect.Value {\n\t\tvalE.Elem().Set(args[0].Elem())\n\t\treturn []reflect.Value{valTrue}\n\t})\n\n\treturn b.eachEvent(sessionID, fnVal.Interface())\n}\n\n// If the any callback returns true the event loop will stop.\n// It will enable the related domains if not enabled, and restore them after wait ends.\nfunc (b *Browser) eachEvent(sessionID proto.TargetSessionID, callbacks ...interface{}) (wait func()) {\n\tcbMap := map[string]reflect.Value{}\n\trestores := []func(){}\n\n\tfor _, cb := range callbacks {\n\t\tcbVal := reflect.ValueOf(cb)\n\t\teType := cbVal.Type().In(0)\n\t\tname := reflect.New(eType.Elem()).Interface().(proto.Event).ProtoEvent() //nolint: forcetypeassert\n\t\tcbMap[name] = cbVal\n\n\t\t// Only enabled domains will emit events to cdp client.\n\t\t// We enable the domains for the event types if it's not enabled.\n\t\t// We restore the domains to their previous states after the wait ends.\n\t\tdomain, _ := proto.ParseMethodName(name)\n\t\tif req := proto.GetType(domain + \".enable\"); req != nil {\n\t\t\tenable := reflect.New(req).Interface().(proto.Request) //nolint: forcetypeassert\n\t\t\trestores = append(restores, b.EnableDomain(sessionID, enable))\n\t\t}\n\t}\n\n\tb, cancel := b.WithCancel()\n\tmessages := b.Event()\n\n\treturn func() {\n\t\tif messages == nil {\n\t\t\tpanic(\"can't use wait function twice\")\n\t\t}\n\n\t\tdefer func() {\n\t\t\tcancel()\n\t\t\tmessages = nil\n\t\t\tfor _, restore := range restores {\n\t\t\t\trestore()\n\t\t\t}\n\t\t}()\n\n\t\tfor msg := range messages {\n\t\t\tif !(sessionID == \"\" || msg.SessionID == sessionID) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif cbVal, has := cbMap[msg.Method]; has {\n\t\t\t\te := reflect.New(proto.GetType(msg.Method))\n\t\t\t\tmsg.Load(e.Interface().(proto.Event)) //nolint: forcetypeassert\n\t\t\t\targs := []reflect.Value{e}\n\t\t\t\tif cbVal.Type().NumIn() == 2 {\n\t\t\t\t\targs = append(args, reflect.ValueOf(msg.SessionID))\n\t\t\t\t}\n\t\t\t\tres := cbVal.Call(args)\n\t\t\t\tif len(res) > 0 {\n\t\t\t\t\tif res[0].Bool() {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Event of the browser.\nfunc (b *Browser) Event() <-chan *Message {\n\tsrc := b.event.Subscribe(b.ctx)\n\tdst := make(chan *Message)\n\tgo func() {\n\t\tdefer close(dst)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-b.ctx.Done():\n\t\t\t\treturn\n\t\t\tcase e, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-b.ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase dst <- e.(*Message): //nolint: forcetypeassert\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn dst\n}\n\nfunc (b *Browser) initEvents() {\n\tctx, cancel := context.WithCancel(b.ctx)\n\tb.event = goob.New(ctx)\n\tevent := b.client.Event()\n\n\tgo func() {\n\t\tdefer cancel()\n\t\tfor e := range event {\n\t\t\tb.event.Publish(&Message{\n\t\t\t\tSessionID: proto.TargetSessionID(e.SessionID),\n\t\t\t\tMethod:    e.Method,\n\t\t\t\tlock:      &sync.Mutex{},\n\t\t\t\tdata:      e.Params,\n\t\t\t})\n\t\t}\n\t}()\n}\n\nfunc (b *Browser) pageInfo(id proto.TargetTargetID) (*proto.TargetTargetInfo, error) {\n\tres, err := proto.TargetGetTargetInfo{TargetID: id}.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.TargetInfo, nil\n}\n\nfunc (b *Browser) isHeadless() (enabled bool) {\n\tres, _ := proto.BrowserGetBrowserCommandLine{}.Call(b)\n\tfor _, v := range res.Arguments {\n\t\tif strings.Contains(v, \"headless\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IgnoreCertErrors switch. If enabled, all certificate errors will be ignored.\nfunc (b *Browser) IgnoreCertErrors(enable bool) error {\n\treturn proto.SecuritySetIgnoreCertificateErrors{Ignore: enable}.Call(b)\n}\n\n// GetCookies from the browser.\nfunc (b *Browser) GetCookies() ([]*proto.NetworkCookie, error) {\n\tres, err := proto.StorageGetCookies{BrowserContextID: b.BrowserContextID}.Call(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.Cookies, nil\n}\n\n// SetCookies to the browser. If the cookies is nil it will clear all the cookies.\nfunc (b *Browser) SetCookies(cookies []*proto.NetworkCookieParam) error {\n\tif cookies == nil {\n\t\treturn proto.StorageClearCookies{BrowserContextID: b.BrowserContextID}.Call(b)\n\t}\n\n\treturn proto.StorageSetCookies{\n\t\tCookies:          cookies,\n\t\tBrowserContextID: b.BrowserContextID,\n\t}.Call(b)\n}\n\n// WaitDownload returns a helper to get the next download file.\n// The file path will be:\n//\n//\tfilepath.Join(dir, info.GUID)\nfunc (b *Browser) WaitDownload(dir string) func() (info *proto.PageDownloadWillBegin) {\n\tvar oldDownloadBehavior proto.BrowserSetDownloadBehavior\n\thas := b.LoadState(\"\", &oldDownloadBehavior)\n\n\t_ = proto.BrowserSetDownloadBehavior{\n\t\tBehavior:         proto.BrowserSetDownloadBehaviorBehaviorAllowAndName,\n\t\tBrowserContextID: b.BrowserContextID,\n\t\tDownloadPath:     dir,\n\t}.Call(b)\n\n\tvar start *proto.PageDownloadWillBegin\n\n\twaitProgress := b.EachEvent(func(e *proto.PageDownloadWillBegin) {\n\t\tstart = e\n\t}, func(e *proto.PageDownloadProgress) bool {\n\t\treturn start != nil && start.GUID == e.GUID && e.State == proto.PageDownloadProgressStateCompleted\n\t})\n\n\treturn func() *proto.PageDownloadWillBegin {\n\t\tdefer func() {\n\t\t\tif has {\n\t\t\t\t_ = oldDownloadBehavior.Call(b)\n\t\t\t} else {\n\t\t\t\t_ = proto.BrowserSetDownloadBehavior{\n\t\t\t\t\tBehavior:         proto.BrowserSetDownloadBehaviorBehaviorDefault,\n\t\t\t\t\tBrowserContextID: b.BrowserContextID,\n\t\t\t\t}.Call(b)\n\t\t\t}\n\t\t}()\n\n\t\twaitProgress()\n\n\t\treturn start\n\t}\n}\n\n// Version info of the browser.\nfunc (b *Browser) Version() (*proto.BrowserGetVersionResult, error) {\n\treturn proto.BrowserGetVersion{}.Call(b)\n}\n"
        },
        {
          "name": "browser_test.go",
          "type": "blob",
          "size": 9.767578125,
          "content": "package rod_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/got\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestIncognito(t *testing.T) {\n\tg := setup(t)\n\n\tk := g.RandStr(16)\n\n\tb := g.browser.MustIncognito().Sleeper(rod.DefaultSleeper)\n\tdefer b.MustClose()\n\n\tpage := b.MustPage(g.blank())\n\tdefer page.MustClose()\n\tpage.MustEval(`k => localStorage[k] = 1`, k)\n\n\tg.True(g.page.MustNavigate(g.blank()).MustEval(`k => localStorage[k]`, k).Nil())\n\tg.Eq(page.MustEval(`k => localStorage[k]`, k).Str(), \"1\") // localStorage can only store string\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.TargetCreateBrowserContext{})\n\t\tg.browser.MustIncognito()\n\t})\n}\n\nfunc TestBrowserResetControlURL(_ *testing.T) {\n\trod.New().ControlURL(\"test\").ControlURL(\"\")\n}\n\nfunc TestDefaultDevice(t *testing.T) {\n\tg := setup(t)\n\n\tua := \"\"\n\n\ts := g.Serve()\n\ts.Mux.HandleFunc(\"/t\", func(_ http.ResponseWriter, r *http.Request) {\n\t\tua = r.Header.Get(\"User-Agent\")\n\t})\n\n\t// TODO: https://github.com/golang/go/issues/51459\n\tb := *g.browser\n\tb.DefaultDevice(devices.IPhoneX)\n\n\tb.MustPage(s.URL(\"/t\")).MustClose()\n\tg.Eq(ua, devices.IPhoneX.UserAgentEmulation().UserAgent)\n\n\tb.NoDefaultDevice()\n\tb.MustPage(s.URL(\"/t\")).MustClose()\n\tg.Neq(ua, devices.IPhoneX.UserAgentEmulation().UserAgent)\n}\n\nfunc TestPageErr(t *testing.T) {\n\tg := setup(t)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.TargetAttachToTarget{})\n\t\tg.browser.MustPage()\n\t})\n}\n\nfunc TestPageFromTarget(t *testing.T) {\n\tg := setup(t)\n\n\tg.Panic(func() {\n\t\tres, err := proto.TargetCreateTarget{URL: \"about:blank\"}.Call(g.browser)\n\t\tg.E(err)\n\t\tdefer func() {\n\t\t\tg.browser.MustPageFromTargetID(res.TargetID).MustClose()\n\t\t}()\n\n\t\tg.mc.stubErr(1, proto.EmulationSetDeviceMetricsOverride{})\n\t\tg.browser.MustPageFromTargetID(res.TargetID)\n\t})\n}\n\nfunc TestBrowserPages(t *testing.T) {\n\tg := setup(t)\n\n\tb := g.browser\n\tpages := b.MustPages()\n\tg.Gte(len(pages), 1)\n\n\t{\n\t\tg.mc.stub(1, proto.TargetGetTargets{}, func(send StubSend) (gson.JSON, error) {\n\t\t\td, _ := send()\n\t\t\treturn *d.Set(\"targetInfos.0.type\", \"iframe\"), nil\n\t\t})\n\t\tb.MustPages()\n\t}\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.TargetCreateTarget{})\n\t\tb.MustPage()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.TargetGetTargets{})\n\t\tb.MustPages()\n\t})\n\tg.Panic(func() {\n\t\t_, err := proto.TargetCreateTarget{URL: \"about:blank\"}.Call(b)\n\t\tg.E(err)\n\t\tg.mc.stubErr(1, proto.TargetAttachToTarget{})\n\t\tb.MustPages()\n\t})\n}\n\nfunc TestBrowserClearStates(t *testing.T) {\n\tg := setup(t)\n\n\tg.E(proto.EmulationClearGeolocationOverride{}.Call(g.page))\n}\n\nfunc TestBrowserEvent(t *testing.T) {\n\tg := setup(t)\n\n\tmessages := g.browser.Context(g.Context()).Event()\n\tp := g.newPage()\n\twait := make(chan struct{})\n\tfor msg := range messages {\n\t\te := proto.TargetAttachedToTarget{}\n\t\tif msg.Load(&e) {\n\t\t\tg.Eq(e.TargetInfo.TargetID, p.TargetID)\n\t\t\tclose(wait)\n\t\t\tbreak\n\t\t}\n\t}\n\t<-wait\n}\n\nfunc TestBrowserWaitEvent(t *testing.T) {\n\tg := setup(t)\n\n\tg.NotNil(g.browser.Context(g.Context()).Event())\n\n\twait := g.page.WaitEvent(proto.PageFrameNavigated{})\n\tg.page.MustNavigate(g.blank())\n\twait()\n\n\twait = g.browser.EachEvent(func(_ *proto.PageFrameNavigated, _ proto.TargetSessionID) bool {\n\t\treturn true\n\t})\n\tg.page.MustNavigate(g.blank())\n\twait()\n}\n\nfunc TestBrowserCrash(t *testing.T) {\n\tg := setup(t)\n\n\tbrowser := rod.New().Context(g.Context()).MustConnect()\n\tpage := browser.MustPage()\n\tjs := `() => new Promise(r => setTimeout(r, 10000))`\n\n\tgo g.Panic(func() {\n\t\tpage.MustEval(js)\n\t})\n\n\tutils.Sleep(0.2)\n\n\t_ = proto.BrowserCrash{}.Call(browser)\n\n\tutils.Sleep(0.3)\n\n\t_, err := page.Eval(js)\n\tg.Has(err.Error(), \"use of closed network connection\")\n}\n\nfunc TestBrowserCall(t *testing.T) {\n\tg := setup(t)\n\n\tv, err := proto.BrowserGetVersion{}.Call(g.browser)\n\tg.E(err)\n\n\tg.Regex(\"1.3\", v.ProtocolVersion)\n}\n\nfunc TestBlockingNavigation(t *testing.T) {\n\tg := setup(t)\n\n\t/*\n\t\tNavigate can take forever if a page doesn't response.\n\t\tIf one page is blocked, other pages should still work.\n\t*/\n\n\ts := g.Serve()\n\tpause := g.Context()\n\n\ts.Mux.HandleFunc(\"/a\", func(_ http.ResponseWriter, _ *http.Request) {\n\t\t<-pause.Done()\n\t})\n\ts.Route(\"/b\", \".html\", `<html>ok</html>`)\n\n\tblocked := g.newPage()\n\n\tgo func() {\n\t\tg.Panic(func() {\n\t\t\tblocked.MustNavigate(s.URL(\"/a\"))\n\t\t})\n\t}()\n\n\tutils.Sleep(0.3)\n\n\tg.newPage(s.URL(\"/b\"))\n}\n\nfunc TestResolveBlocking(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\tpause := g.Context()\n\n\ts.Mux.HandleFunc(\"/\", func(_ http.ResponseWriter, _ *http.Request) {\n\t\t<-pause.Done()\n\t})\n\n\tp := g.newPage()\n\n\tgo func() {\n\t\tutils.Sleep(0.1)\n\t\tp.MustStopLoading()\n\t}()\n\n\tg.Panic(func() {\n\t\tp.MustNavigate(s.URL())\n\t})\n}\n\nfunc TestTestTry(t *testing.T) {\n\tg := setup(t)\n\n\tg.Nil(rod.Try(func() {}))\n\n\terr := rod.Try(func() { panic(1) })\n\tvar errVal *rod.TryError\n\tg.True(errors.As(err, &errVal))\n\tg.Is(err, &rod.TryError{})\n\tg.Eq(errVal.Unwrap().Error(), \"1\")\n\tg.Eq(1, errVal.Value)\n\tg.Has(errVal.Error(), \"error value: 1\\ngoroutine\")\n\n\terrVal = rod.Try(func() { panic(errors.New(\"t\")) }).(*rod.TryError)\n\tg.Eq(errVal.Unwrap().Error(), \"t\")\n}\n\nfunc TestBrowserOthers(t *testing.T) {\n\tg := setup(t)\n\n\tg.browser.Timeout(time.Second).CancelTimeout().MustGetCookies()\n}\n\nfunc TestBinarySize(t *testing.T) {\n\tg := setup(t)\n\n\tif runtime.GOOS == \"windows\" || utils.InContainer {\n\t\tg.SkipNow()\n\t}\n\n\tcmd := exec.Command(\"go\", \"build\",\n\t\t\"-trimpath\",\n\t\t\"-ldflags\", \"-w -s\",\n\t\t\"-o\", \"tmp/translator\",\n\t\t\"./lib/examples/translator\")\n\n\tcmd.Env = append(os.Environ(), \"GOOS=linux\")\n\n\tg.Nil(cmd.Run())\n\n\tstat, err := os.Stat(\"tmp/translator\")\n\tg.E(err)\n\n\tg.Lte(float64(stat.Size())/1024/1024, 11) // mb\n}\n\nfunc TestBrowserCookies(t *testing.T) {\n\tg := setup(t)\n\n\tb := g.browser.MustIncognito()\n\tdefer b.MustClose()\n\n\tb.MustSetCookies(&proto.NetworkCookie{\n\t\tName:   \"a\",\n\t\tValue:  \"val\",\n\t\tDomain: \"test.com\",\n\t})\n\n\tcookies := b.MustGetCookies()\n\n\tg.Len(cookies, 1)\n\tg.Eq(cookies[0].Name, \"a\")\n\tg.Eq(cookies[0].Value, \"val\")\n\n\t{\n\t\tb.MustSetCookies()\n\t\tcookies := b.MustGetCookies()\n\t\tg.Len(cookies, 0)\n\t}\n\n\tg.mc.stubErr(1, proto.StorageGetCookies{})\n\tg.Err(b.GetCookies())\n}\n\nfunc TestWaitDownload(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\tcontent := \"test content\"\n\n\ts.Route(\"/d\", \".bin\", []byte(content))\n\ts.Route(\"/page\", \".html\", fmt.Sprintf(`<html><a href=\"%s/d\" download>click</a></html>`, s.URL()))\n\n\tpage := g.page.MustNavigate(s.URL(\"/page\"))\n\n\twait := g.browser.MustWaitDownload()\n\tpage.MustElement(\"a\").MustClick()\n\tdata := wait()\n\n\tg.Eq(content, string(data))\n}\n\nfunc TestWaitDownloadDataURI(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\ts.Route(\"/\", \".html\",\n\t\t`<html>\n\t\t\t<a id=\"a\" href=\"data:text/plain;,test%20data\" download>click</a>\n\t\t\t<a id=\"b\" download>click</a>\n\t\t\t<script>\n\t\t\t\tconst b = document.getElementById('b')\n\t\t\t\tb.href = URL.createObjectURL(new Blob(['test blob'], {\n\t\t\t\t\ttype: \"text/plain; charset=utf-8\"\n\t\t\t\t}))\n\t\t\t</script>\n\t\t</html>`,\n\t)\n\n\tpage := g.page.MustNavigate(s.URL())\n\n\twait1 := g.browser.MustWaitDownload()\n\tpage.MustElement(\"#a\").MustClick()\n\tdata := wait1()\n\tg.Eq(\"test data\", string(data))\n\n\twait2 := g.browser.MustWaitDownload()\n\tpage.MustElement(\"#b\").MustClick()\n\tdata = wait2()\n\tg.Eq(\"test blob\", string(data))\n}\n\nfunc TestWaitDownloadCancel(t *testing.T) {\n\tg := setup(t)\n\n\twait := g.browser.Context(g.Timeout(0)).WaitDownload(os.TempDir())\n\tg.Eq(wait(), (*proto.PageDownloadWillBegin)(nil))\n}\n\nfunc TestWaitDownloadFromNewPage(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\tcontent := \"test content\"\n\n\ts.Route(\"/d\", \".bin\", content)\n\ts.Route(\"/page\", \".html\", fmt.Sprintf(\n\t\t`<html><a href=\"%s/d\" download target=\"_blank\">click</a></html>`,\n\t\ts.URL()),\n\t)\n\n\tpage := g.page.MustNavigate(s.URL(\"/page\"))\n\twait := g.browser.MustWaitDownload()\n\tpage.MustElement(\"a\").MustClick()\n\tdata := wait()\n\n\tg.Eq(content, string(data))\n}\n\nfunc TestBrowserConnectErr(t *testing.T) {\n\tg := setup(t)\n\n\tg.Panic(func() {\n\t\trod.New().ControlURL(g.RandStr(16)).MustConnect()\n\t})\n}\n\nfunc TestStreamReader(t *testing.T) {\n\tg := setup(t)\n\n\tr := rod.NewStreamReader(g.page, \"\")\n\n\tg.mc.stub(1, proto.IORead{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(proto.IOReadResult{\n\t\t\tData: \"test\",\n\t\t}), nil\n\t})\n\tb := make([]byte, 4)\n\t_, _ = r.Read(b)\n\tg.Eq(\"test\", string(b))\n\n\tg.mc.stubErr(1, proto.IORead{})\n\t_, err := r.Read(nil)\n\tg.Err(err)\n\n\tg.mc.stub(1, proto.IORead{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(proto.IOReadResult{\n\t\t\tBase64Encoded: true,\n\t\t\tData:          \"@\",\n\t\t}), nil\n\t})\n\t_, err = r.Read(nil)\n\tg.Err(err)\n}\n\nfunc TestBrowserConnectFailure(t *testing.T) {\n\tg := setup(t)\n\n\tc := g.Context()\n\tc.Cancel()\n\terr := rod.New().Context(c).Connect()\n\tif err == nil {\n\t\tg.Fatal(\"expected an error on connect failure\")\n\t}\n}\n\nfunc TestBrowserPool(t *testing.T) {\n\tg := got.T(t)\n\n\tpool := rod.NewBrowserPool(3)\n\n\tb, err := pool.Get(func() (*rod.Browser, error) {\n\t\tbrowser := rod.New()\n\t\treturn browser, browser.Connect()\n\t})\n\tg.E(err)\n\tpool.Put(b)\n\n\tb = pool.MustGet(func() *rod.Browser { return rod.New().MustConnect() })\n\tpool.Put(b)\n\n\tpool.Cleanup(func(p *rod.Browser) {\n\t\tp.MustClose()\n\t})\n}\n\nfunc TestOldBrowser(t *testing.T) {\n\tt.Skip()\n\n\tg := setup(t)\n\tu := launcher.New().Revision(686378).MustLaunch()\n\tb := rod.New().ControlURL(u).MustConnect()\n\tg.Cleanup(b.MustClose)\n\tres, err := proto.BrowserGetVersion{}.Call(b)\n\tg.E(err)\n\tg.Eq(res.Revision, \"@19d4547535ab5aba70b4730443f84e8153052174\")\n}\n\nfunc TestBrowserLostConnection(t *testing.T) {\n\tg := setup(t)\n\n\tl := launcher.New()\n\tp := rod.New().ControlURL(l.MustLaunch()).MustConnect().MustPage(g.blank())\n\n\tgo func() {\n\t\tutils.Sleep(1)\n\t\tl.Kill()\n\t}()\n\n\t_, err := p.Eval(`() => new Promise(r => {})`)\n\tg.Err(err)\n}\n\nfunc TestBrowserConnectConflict(t *testing.T) {\n\tg := setup(t)\n\tg.Panic(func() {\n\t\trod.New().Client(&cdp.Client{}).ControlURL(\"test\").MustConnect()\n\t})\n}\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 3.9033203125,
          "content": "package rod\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\ntype (\n\ttimeoutContextKey struct{}\n\ttimeoutContextVal struct {\n\t\tparent context.Context\n\t\tcancel context.CancelFunc\n\t}\n)\n\n// Context returns a clone with the specified ctx for chained sub-operations.\nfunc (b *Browser) Context(ctx context.Context) *Browser {\n\tnewObj := *b\n\tnewObj.ctx = ctx\n\treturn &newObj\n}\n\n// GetContext of current instance.\nfunc (b *Browser) GetContext() context.Context {\n\treturn b.ctx\n}\n\n// Timeout returns a clone with the specified total timeout of all chained sub-operations.\nfunc (b *Browser) Timeout(d time.Duration) *Browser {\n\tctx, cancel := context.WithTimeout(b.ctx, d)\n\treturn b.Context(context.WithValue(ctx, timeoutContextKey{}, &timeoutContextVal{b.ctx, cancel}))\n}\n\n// CancelTimeout cancels the current timeout context and returns a clone with the parent context.\nfunc (b *Browser) CancelTimeout() *Browser {\n\tval := b.ctx.Value(timeoutContextKey{}).(*timeoutContextVal) //nolint:forcetypeassert\n\tval.cancel()\n\treturn b.Context(val.parent)\n}\n\n// WithCancel returns a clone with a context cancel function.\nfunc (b *Browser) WithCancel() (*Browser, func()) {\n\tctx, cancel := context.WithCancel(b.ctx)\n\treturn b.Context(ctx), cancel\n}\n\n// Sleeper returns a clone with the specified sleeper for chained sub-operations.\nfunc (b *Browser) Sleeper(sleeper func() utils.Sleeper) *Browser {\n\tnewObj := *b\n\tnewObj.sleeper = sleeper\n\treturn &newObj\n}\n\n// Context returns a clone with the specified ctx for chained sub-operations.\nfunc (p *Page) Context(ctx context.Context) *Page {\n\tp.helpersLock.Lock()\n\tnewObj := *p\n\tp.helpersLock.Unlock()\n\tnewObj.ctx = ctx\n\treturn &newObj\n}\n\n// GetContext of current instance.\nfunc (p *Page) GetContext() context.Context {\n\treturn p.ctx\n}\n\n// Timeout returns a clone with the specified total timeout of all chained sub-operations.\nfunc (p *Page) Timeout(d time.Duration) *Page {\n\tctx, cancel := context.WithTimeout(p.ctx, d)\n\treturn p.Context(context.WithValue(ctx, timeoutContextKey{}, &timeoutContextVal{p.ctx, cancel}))\n}\n\n// CancelTimeout cancels the current timeout context and returns a clone with the parent context.\nfunc (p *Page) CancelTimeout() *Page {\n\tval := p.ctx.Value(timeoutContextKey{}).(*timeoutContextVal) //nolint: forcetypeassert\n\tval.cancel()\n\treturn p.Context(val.parent)\n}\n\n// WithCancel returns a clone with a context cancel function.\nfunc (p *Page) WithCancel() (*Page, func()) {\n\tctx, cancel := context.WithCancel(p.ctx)\n\treturn p.Context(ctx), cancel\n}\n\n// Sleeper returns a clone with the specified sleeper for chained sub-operations.\nfunc (p *Page) Sleeper(sleeper func() utils.Sleeper) *Page {\n\tnewObj := *p\n\tnewObj.sleeper = sleeper\n\treturn &newObj\n}\n\n// Context returns a clone with the specified ctx for chained sub-operations.\nfunc (el *Element) Context(ctx context.Context) *Element {\n\tnewObj := *el\n\tnewObj.ctx = ctx\n\treturn &newObj\n}\n\n// GetContext of current instance.\nfunc (el *Element) GetContext() context.Context {\n\treturn el.ctx\n}\n\n// Timeout returns a clone with the specified total timeout of all chained sub-operations.\nfunc (el *Element) Timeout(d time.Duration) *Element {\n\tctx, cancel := context.WithTimeout(el.ctx, d)\n\treturn el.Context(context.WithValue(ctx, timeoutContextKey{}, &timeoutContextVal{el.ctx, cancel}))\n}\n\n// CancelTimeout cancels the current timeout context and returns a clone with the parent context.\nfunc (el *Element) CancelTimeout() *Element {\n\tval := el.ctx.Value(timeoutContextKey{}).(*timeoutContextVal) //nolint: forcetypeassert\n\tval.cancel()\n\treturn el.Context(val.parent)\n}\n\n// WithCancel returns a clone with a context cancel function.\nfunc (el *Element) WithCancel() (*Element, func()) {\n\tctx, cancel := context.WithCancel(el.ctx)\n\treturn el.Context(ctx), cancel\n}\n\n// Sleeper returns a clone with the specified sleeper for chained sub-operations.\nfunc (el *Element) Sleeper(sleeper func() utils.Sleeper) *Element {\n\tnewObj := *el\n\tnewObj.sleeper = sleeper\n\treturn &newObj\n}\n"
        },
        {
          "name": "cspell.json",
          "type": "blob",
          "size": 2.4404296875,
          "content": "// cSpell Settings\n{\n  // Version of the setting file.  Always 0.2\n  \"version\": \"0.2\",\n  // language - current active spelling language\n  \"language\": \"en\",\n  \"ignorePaths\": [\n    \"**/*.{out,sketch,svg}\",\n    \"fixtures/fonts.html\",\n    \"**/tmp/**\",\n    \"lib/devices/list.go\",\n    \"lib/js/helper.go\",\n    \"lib/proto/!(a_*)\",\n    \"**/go.{mod,sum}\",\n    \".golangci.yml\"\n  ],\n  // words - list of words to be always considered correct\n  \"words\": [\n    \"APPDATA\",\n    \"Arraybuffer\",\n    \"backgrounding\",\n    \"backoff\",\n    \"Backquote\",\n    \"beforeunload\",\n    \"bodyclose\",\n    \"breakpad\",\n    \"Chromedp\",\n    \"codesearch\",\n    \"commandline\",\n    \"COMSPEC\",\n    \"containerenv\",\n    \"contenteditable\",\n    \"Contentful\",\n    \"Contextable\",\n    \"contextcheck\",\n    \"coverprofile\",\n    \"Dataview\",\n    \"datetime\",\n    \"dockerenv\",\n    \"dropzone\",\n    \"duckduckgo\",\n    \"enctype\",\n    \"errcheck\",\n    \"evenodd\",\n    \"excludesfile\",\n    \"fetchup\",\n    \"fontconfig\",\n    \"forbidigo\",\n    \"forcetypeassert\",\n    \"Fullscreen\",\n    \"Geolocation\",\n    \"getent\",\n    \"gobwas\",\n    \"gocognit\",\n    \"gocyclo\",\n    \"GODEBUG\",\n    \"gofmt\",\n    \"gofumpt\",\n    \"goimports\",\n    \"golangci\",\n    \"goob\",\n    \"gopls\",\n    \"goproxy\",\n    \"gotrace\",\n    \"gson\",\n    \"headful\",\n    \"iframe\",\n    \"iframes\",\n    \"Interactable\",\n    \"ioutil\",\n    \"keychain\",\n    \"KHTML\",\n    \"ldflags\",\n    \"leakless\",\n    \"libasound\",\n    \"libcairo\",\n    \"libgbm\",\n    \"libgobject\",\n    \"libgtk\",\n    \"libnss\",\n    \"libxss\",\n    \"libxtst\",\n    \"Lmsgprefix\",\n    \"loglevel\",\n    \"MDPI\",\n    \"MITM\",\n    \"mitmproxy\",\n    \"mvdan\",\n    \"nilnil\",\n    \"noctx\",\n    \"nolint\",\n    \"Noto\",\n    \"Numpad\",\n    \"onbeforeunload\",\n    \"onclick\",\n    \"onmouseenter\",\n    \"onmouseout\",\n    \"OOPIF\",\n    \"opencontainers\",\n    \"osversion\",\n    \"progresser\",\n    \"proto\",\n    \"proxyauth\",\n    \"Rects\",\n    \"repost\",\n    \"sattributes\",\n    \"schildren\",\n    \"Sessionable\",\n    \"Smood\",\n    \"Socketable\",\n    \"spki\",\n    \"spkis\",\n    \"srgb\",\n    \"staticcheck\",\n    \"stdlib\",\n    \"termux\",\n    \"tlid\",\n    \"touchend\",\n    \"touchstart\",\n    \"tparallel\",\n    \"tracebackancestors\",\n    \"trimpath\",\n    \"Typedarray\",\n    \"tzdata\",\n    \"Unserializable\",\n    \"Wasmvalue\",\n    \"Weakmap\",\n    \"Weakset\",\n    \"Webassemblymemory\",\n    \"wsutil\",\n    \"xlink\",\n    \"XVFB\",\n    \"ysmood\"\n  ],\n  // flagWords - list of words to be always considered incorrect\n  // This is useful for offensive words and common spelling errors.\n  // For example \"hte\" should be \"the\"\n  \"flagWords\": []\n}\n"
        },
        {
          "name": "dev_helpers.go",
          "type": "blob",
          "size": 6.1748046875,
          "content": "// This file defines the helpers to develop automation.\n// Such as when running automation we can use trace to visually\n// see where the mouse going to click.\n\npackage rod\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/assets\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\n// TraceType for logger.\ntype TraceType string\n\n// String interface.\nfunc (t TraceType) String() string {\n\treturn fmt.Sprintf(\"[%s]\", string(t))\n}\n\nconst (\n\t// TraceTypeWaitRequestsIdle type.\n\tTraceTypeWaitRequestsIdle TraceType = \"wait requests idle\"\n\n\t// TraceTypeWaitRequests type.\n\tTraceTypeWaitRequests TraceType = \"wait requests\"\n\n\t// TraceTypeQuery type.\n\tTraceTypeQuery TraceType = \"query\"\n\n\t// TraceTypeWait type.\n\tTraceTypeWait TraceType = \"wait\"\n\n\t// TraceTypeInput type.\n\tTraceTypeInput TraceType = \"input\"\n)\n\n// ServeMonitor starts the monitor server.\n// The reason why not to use \"chrome://inspect/#devices\" is one target cannot be driven by multiple controllers.\nfunc (b *Browser) ServeMonitor(host string) string {\n\tu, mux, closeSvr := serve(host)\n\tgo func() {\n\t\t<-b.ctx.Done()\n\t\tutils.E(closeSvr())\n\t}()\n\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, _ *http.Request) {\n\t\thttHTML(w, assets.Monitor)\n\t})\n\tmux.HandleFunc(\"/api/pages\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tres, err := proto.TargetGetTargets{}.Call(b) //nolint: contextcheck\n\t\tutils.E(err)\n\n\t\tlist := []*proto.TargetTargetInfo{}\n\t\tfor _, info := range res.TargetInfos {\n\t\t\tif info.Type == proto.TargetTargetInfoTypePage {\n\t\t\t\tlist = append(list, info)\n\t\t\t}\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tutils.E(w.Write(utils.MustToJSONBytes(list)))\n\t})\n\tmux.HandleFunc(\"/page/\", func(w http.ResponseWriter, _ *http.Request) {\n\t\thttHTML(w, assets.MonitorPage)\n\t})\n\tmux.HandleFunc(\"/api/page/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := r.URL.Path[strings.LastIndex(r.URL.Path, \"/\")+1:]\n\t\tinfo, err := b.pageInfo(proto.TargetTargetID(id)) //nolint: contextcheck\n\t\tutils.E(err)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tutils.E(w.Write(utils.MustToJSONBytes(info)))\n\t})\n\tmux.HandleFunc(\"/screenshot/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := r.URL.Path[strings.LastIndex(r.URL.Path, \"/\")+1:]\n\t\ttarget := proto.TargetTargetID(id)\n\t\tp := b.MustPageFromTargetID(target)\n\n\t\tw.Header().Add(\"Content-Type\", \"image/png;\")\n\t\tutils.E(w.Write(p.MustScreenshot())) //nolint: contextcheck\n\t})\n\n\treturn u\n}\n\n// check method and sleep if needed.\nfunc (b *Browser) trySlowMotion() {\n\tif b.slowMotion == 0 {\n\t\treturn\n\t}\n\n\ttime.Sleep(b.slowMotion)\n}\n\n// ExposeHelpers helper functions to page's js context so that we can use the Devtools' console to debug them.\nfunc (p *Page) ExposeHelpers(list ...*js.Function) {\n\tp.MustEvaluate(evalHelper(&js.Function{\n\t\tName:         \"_\" + utils.RandString(8), // use a random name so it won't hit the cache\n\t\tDefinition:   \"() => { window.rod = functions }\",\n\t\tDependencies: list,\n\t}))\n}\n\n// Overlay a rectangle on the main frame with specified message.\nfunc (p *Page) Overlay(left, top, width, height float64, msg string) (remove func()) {\n\tid := utils.RandString(8)\n\n\t_, _ = p.root.Evaluate(evalHelper(js.Overlay,\n\t\tid,\n\t\tleft,\n\t\ttop,\n\t\twidth,\n\t\theight,\n\t\tmsg,\n\t).ByPromise())\n\n\tremove = func() {\n\t\t_, _ = p.root.Evaluate(evalHelper(js.RemoveOverlay, id))\n\t}\n\n\treturn\n}\n\nfunc (p *Page) tryTrace(typ TraceType, msg ...interface{}) func() {\n\tif !p.browser.trace {\n\t\treturn func() {}\n\t}\n\n\tmsg = append([]interface{}{typ}, msg...)\n\tmsg = append(msg, p)\n\n\tp.browser.logger.Println(msg...)\n\n\treturn p.Overlay(0, 0, 500, 0, fmt.Sprint(msg))\n}\n\nfunc (p *Page) tryTraceQuery(opts *EvalOptions) func() {\n\tif !p.browser.trace {\n\t\treturn func() {}\n\t}\n\n\tp.browser.logger.Println(TraceTypeQuery, opts, p)\n\n\tmsg := fmt.Sprintf(\"<code>%s</code>\", html.EscapeString(opts.String()))\n\treturn p.Overlay(0, 0, 500, 0, msg)\n}\n\nfunc (p *Page) tryTraceReq(includes, excludes []string) func(map[proto.NetworkRequestID]string) {\n\tif !p.browser.trace {\n\t\treturn func(map[proto.NetworkRequestID]string) {}\n\t}\n\n\tmsg := map[string][]string{\n\t\t\"includes\": includes,\n\t\t\"excludes\": excludes,\n\t}\n\tp.browser.logger.Println(TraceTypeWaitRequestsIdle, msg, p)\n\tcleanup := p.Overlay(0, 0, 500, 0, utils.MustToJSON(msg))\n\n\tch := make(chan map[string]string)\n\tupdate := func(list map[proto.NetworkRequestID]string) {\n\t\tclone := map[string]string{}\n\t\tfor k, v := range list {\n\t\t\tclone[string(k)] = v\n\t\t}\n\t\tch <- clone\n\t}\n\n\tgo func() {\n\t\tvar waitList map[string]string\n\t\tt := time.NewTicker(time.Second)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-p.ctx.Done():\n\t\t\t\tt.Stop()\n\t\t\t\tcleanup()\n\t\t\t\treturn\n\t\t\tcase waitList = <-ch:\n\t\t\tcase <-t.C:\n\t\t\t\tp.browser.logger.Println(TraceTypeWaitRequests, p, waitList)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn update\n}\n\n// Overlay msg on the element.\nfunc (el *Element) Overlay(msg string) (removeOverlay func()) {\n\tid := utils.RandString(8)\n\n\t_, _ = el.Evaluate(evalHelper(js.ElementOverlay,\n\t\tid,\n\t\tmsg,\n\t).ByPromise())\n\n\tremoveOverlay = func() {\n\t\t_, _ = el.Evaluate(evalHelper(js.RemoveOverlay, id))\n\t}\n\n\treturn\n}\n\nfunc (el *Element) tryTrace(typ TraceType, msg ...interface{}) func() {\n\tif !el.page.browser.trace {\n\t\treturn func() {}\n\t}\n\n\tmsg = append([]interface{}{typ}, msg...)\n\tmsg = append(msg, el)\n\n\tel.page.browser.logger.Println(msg...)\n\n\treturn el.Overlay(fmt.Sprint(msg))\n}\n\nfunc (m *Mouse) initMouseTracer() {\n\t_, _ = m.page.Evaluate(evalHelper(js.InitMouseTracer, m.id, assets.MousePointer).ByPromise())\n}\n\nfunc (m *Mouse) updateMouseTracer() bool {\n\tres, err := m.page.Evaluate(evalHelper(js.UpdateMouseTracer, m.id, m.pos.X, m.pos.Y))\n\tif err != nil {\n\t\treturn true\n\t}\n\treturn res.Value.Bool()\n}\n\n// Serve a port, if host is empty a random port will be used.\nfunc serve(host string) (string, *http.ServeMux, func() error) {\n\tif host == \"\" {\n\t\thost = \"127.0.0.1:0\"\n\t}\n\n\tmux := http.NewServeMux()\n\tsrv := &http.Server{Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\tutils.E(json.NewEncoder(w).Encode(err))\n\t\t\t}\n\t\t}()\n\n\t\tmux.ServeHTTP(w, r)\n\t})}\n\n\tl, err := net.Listen(\"tcp\", host)\n\tutils.E(err)\n\n\tgo func() { _ = srv.Serve(l) }()\n\n\turl := \"http://\" + l.Addr().String()\n\n\treturn url, mux, srv.Close\n}\n"
        },
        {
          "name": "dev_helpers_test.go",
          "type": "blob",
          "size": 2.44140625,
          "content": "package rod_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/defaults\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestMonitor(t *testing.T) {\n\tg := setup(t)\n\n\tb := rod.New().MustConnect()\n\tdefer b.MustClose()\n\tp := b.MustPage(g.blank()).MustWaitLoad()\n\n\tb, cancel := b.WithCancel()\n\tdefer cancel()\n\thost := b.Context(g.Context()).ServeMonitor(\"\")\n\n\tpage := g.page.MustNavigate(host)\n\tg.Has(page.MustElement(\"#targets a\").MustParent().MustHTML(), string(p.TargetID))\n\n\tpage.MustNavigate(host + \"/page/\" + string(p.TargetID))\n\tpage.MustWait(`(id) => document.title.includes(id)`, p.TargetID)\n\n\timg := g.Req(\"\", host+\"/screenshot\").Bytes()\n\tg.Gt(img.Len(), 10)\n\n\tres := g.Req(\"\", host+\"/api/page/test\")\n\tg.Eq(400, res.StatusCode)\n\tg.Eq(-32602, gson.New(res.Body).Get(\"code\").Int())\n}\n\nfunc TestMonitorErr(t *testing.T) {\n\tg := setup(t)\n\n\tl := launcher.New()\n\tu := l.MustLaunch()\n\tdefer l.Kill()\n\n\tg.Panic(func() {\n\t\trod.New().Monitor(\"abc\").ControlURL(u).MustConnect()\n\t})\n}\n\nfunc TestTrace(t *testing.T) {\n\tg := setup(t)\n\n\tg.Eq(rod.TraceTypeInput.String(), \"[input]\")\n\n\tvar msg []interface{}\n\tg.browser.Logger(utils.Log(func(list ...interface{}) { msg = list }))\n\tg.browser.Trace(true).SlowMotion(time.Microsecond)\n\tdefer func() {\n\t\tg.browser.Logger(rod.DefaultLogger)\n\t\tg.browser.Trace(defaults.Trace).SlowMotion(defaults.Slow)\n\t}()\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\")).MustWaitLoad()\n\n\tg.Eq(rod.TraceTypeWait, msg[0])\n\tg.Eq(\"load\", msg[1])\n\tg.Eq(p, msg[2])\n\n\tel := p.MustElement(\"button\")\n\tel.MustClick()\n\n\tg.Eq(rod.TraceTypeInput, msg[0])\n\tg.Eq(\"left click\", msg[1])\n\tg.Eq(el, msg[2])\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t_ = p.Mouse.MoveTo(proto.NewPoint(10, 10))\n}\n\nfunc TestTraceLogs(t *testing.T) {\n\tg := setup(t)\n\n\tg.browser.Logger(utils.LoggerQuiet)\n\tg.browser.Trace(true)\n\tdefer func() {\n\t\tg.browser.Logger(rod.DefaultLogger)\n\t\tg.browser.Trace(defaults.Trace)\n\t}()\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\tel.MustClick()\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tp.Overlay(0, 0, 100, 30, \"\")\n}\n\nfunc TestExposeHelpers(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage(g.srcFile(\"fixtures/click.html\"))\n\tp.ExposeHelpers(js.ElementR)\n\n\tg.Eq(p.MustElementByJS(`() => rod.elementR('button', 'click me')`).MustText(), \"click me\")\n}\n"
        },
        {
          "name": "element.go",
          "type": "blob",
          "size": 19.3408203125,
          "content": "package rod\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// Element implements these interfaces.\nvar (\n\t_ proto.Client      = &Element{}\n\t_ proto.Contextable = &Element{}\n\t_ proto.Sessionable = &Element{}\n)\n\n// Element represents the DOM element.\ntype Element struct {\n\tObject *proto.RuntimeRemoteObject\n\n\te eFunc\n\n\tctx context.Context\n\n\tsleeper func() utils.Sleeper\n\n\tpage *Page\n}\n\n// GetSessionID interface.\nfunc (el *Element) GetSessionID() proto.TargetSessionID {\n\treturn el.page.SessionID\n}\n\n// String interface.\nfunc (el *Element) String() string {\n\treturn fmt.Sprintf(\"<%s>\", el.Object.Description)\n}\n\n// Page of the element.\nfunc (el *Element) Page() *Page {\n\treturn el.page\n}\n\n// Focus sets focus on the specified element.\n// Before the action, it will try to scroll to the element.\nfunc (el *Element) Focus() error {\n\terr := el.ScrollIntoView()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = el.Evaluate(Eval(`() => this.focus()`).ByUser())\n\treturn err\n}\n\n// ScrollIntoView scrolls the current element into the visible area of the browser\n// window if it's not already within the visible area.\nfunc (el *Element) ScrollIntoView() error {\n\tdefer el.tryTrace(TraceTypeInput, \"scroll into view\")()\n\tel.page.browser.trySlowMotion()\n\n\terr := el.WaitStableRAF()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn proto.DOMScrollIntoViewIfNeeded{ObjectID: el.id()}.Call(el)\n}\n\n// Hover the mouse over the center of the element.\n// Before the action, it will try to scroll to the element and wait until it's interactable.\nfunc (el *Element) Hover() error {\n\tpt, err := el.WaitInteractable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn el.page.Context(el.ctx).Mouse.MoveTo(*pt)\n}\n\n// MoveMouseOut of the current element.\nfunc (el *Element) MoveMouseOut() error {\n\tshape, err := el.Shape()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbox := shape.Box()\n\treturn el.page.Mouse.MoveTo(proto.NewPoint(box.X+box.Width, box.Y))\n}\n\n// Click will press then release the button just like a human.\n// Before the action, it will try to scroll to the element, hover the mouse over it,\n// wait until the it's interactable and enabled.\nfunc (el *Element) Click(button proto.InputMouseButton, clickCount int) error {\n\terr := el.Hover()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitEnabled()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, string(button)+\" click\")()\n\n\treturn el.page.Context(el.ctx).Mouse.Click(button, clickCount)\n}\n\n// Tap will scroll to the button and tap it just like a human.\n// Before the action, it will try to scroll to the element and wait until it's interactable and enabled.\nfunc (el *Element) Tap() error {\n\terr := el.ScrollIntoView()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitEnabled()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpt, err := el.WaitInteractable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, \"tap\")()\n\n\treturn el.page.Context(el.ctx).Touch.Tap(pt.X, pt.Y)\n}\n\n// Interactable checks if the element is interactable with cursor.\n// The cursor can be mouse, finger, stylus, etc.\n// If not interactable err will be ErrNotInteractable, such as when covered by a modal,.\nfunc (el *Element) Interactable() (pt *proto.Point, err error) {\n\tnoPointerEvents, err := el.Eval(`() => getComputedStyle(this).pointerEvents === 'none'`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif noPointerEvents.Value.Bool() {\n\t\treturn nil, &NoPointerEventsError{el}\n\t}\n\n\tshape, err := el.Shape()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpt = shape.OnePointInside()\n\tif pt == nil {\n\t\terr = &InvisibleShapeError{el}\n\t\treturn\n\t}\n\n\tscroll, err := el.page.root.Context(el.ctx).Eval(`() => ({ x: window.scrollX, y: window.scrollY })`)\n\tif err != nil {\n\t\treturn\n\t}\n\n\telAtPoint, err := el.page.Context(el.ctx).ElementFromPoint(\n\t\tint(pt.X)+scroll.Value.Get(\"x\").Int(),\n\t\tint(pt.Y)+scroll.Value.Get(\"y\").Int(),\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, cdp.ErrNodeNotFoundAtPos) {\n\t\t\terr = &InvisibleShapeError{el}\n\t\t}\n\t\treturn\n\t}\n\n\tisParent, err := el.ContainsElement(elAtPoint)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif !isParent {\n\t\terr = &CoveredError{elAtPoint}\n\t}\n\treturn\n}\n\n// Shape of the DOM element content. The shape is a group of 4-sides polygons.\n// A 4-sides polygon is not necessary a rectangle. 4-sides polygons can be apart from each other.\n// For example, we use 2 4-sides polygons to describe the shape below:\n//\n//\t  ____________          ____________\n//\t /        ___/    =    /___________/    +     _________\n//\t/________/                                   /________/\nfunc (el *Element) Shape() (*proto.DOMGetContentQuadsResult, error) {\n\treturn proto.DOMGetContentQuads{ObjectID: el.id()}.Call(el)\n}\n\n// Type is similar with Keyboard.Type.\n// Before the action, it will try to scroll to the element and focus on it.\nfunc (el *Element) Type(keys ...input.Key) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn el.page.Context(el.ctx).Keyboard.Type(keys...)\n}\n\n// KeyActions is similar with Page.KeyActions.\n// Before the action, it will try to scroll to the element and focus on it.\nfunc (el *Element) KeyActions() (*KeyActions, error) {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn el.page.Context(el.ctx).KeyActions(), nil\n}\n\n// SelectText selects the text that matches the regular expression.\n// Before the action, it will try to scroll to the element and focus on it.\nfunc (el *Element) SelectText(regex string) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, \"select text: \"+regex)()\n\tel.page.browser.trySlowMotion()\n\n\t_, err = el.Evaluate(evalHelper(js.SelectText, regex).ByUser())\n\treturn err\n}\n\n// SelectAllText selects all text\n// Before the action, it will try to scroll to the element and focus on it.\nfunc (el *Element) SelectAllText() error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, \"select all text\")()\n\tel.page.browser.trySlowMotion()\n\n\t_, err = el.Evaluate(evalHelper(js.SelectAllText).ByUser())\n\treturn err\n}\n\n// Input focuses on the element and input text to it.\n// Before the action, it will scroll to the element, wait until it's visible, enabled and writable.\n// To empty the input you can use something like\n//\n//\tel.SelectAllText().MustInput(\"\")\nfunc (el *Element) Input(text string) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitEnabled()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitWritable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.page.Context(el.ctx).InsertText(text)\n\t_, _ = el.Evaluate(evalHelper(js.InputEvent).ByUser())\n\treturn err\n}\n\n// InputTime focuses on the element and input time to it.\n// Before the action, it will scroll to the element, wait until it's visible, enabled and writable.\n// It will wait until the element is visible, enabled and writable.\nfunc (el *Element) InputTime(t time.Time) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitEnabled()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitWritable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, \"input \"+t.String())()\n\n\t_, err = el.Evaluate(evalHelper(js.InputTime, t.UnixNano()/1e6).ByUser())\n\treturn err\n}\n\n// InputColor focuses on the element and inputs a color string to it.\n// Before the action, it will scroll to the element, wait until it's visible, enabled and writable.\nfunc (el *Element) InputColor(color string) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitEnabled()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = el.WaitWritable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, \"input \"+color)()\n\n\t_, err = el.Evaluate(evalHelper(js.InputColor, color))\n\treturn err\n}\n\n// Blur removes focus from the element.\nfunc (el *Element) Blur() error {\n\t_, err := el.Evaluate(Eval(\"() => this.blur()\").ByUser())\n\treturn err\n}\n\n// Select the children option elements that match the selectors.\n// Before the action, it will scroll to the element, wait until it's visible.\n// If no option matches the selectors, it will return [ErrElementNotFound].\nfunc (el *Element) Select(selectors []string, selected bool, t SelectorType) error {\n\terr := el.Focus()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeInput, fmt.Sprintf(`select \"%s\"`, strings.Join(selectors, \"; \")))()\n\tel.page.browser.trySlowMotion()\n\n\tres, err := el.Evaluate(evalHelper(js.Select, selectors, selected, t).ByUser())\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !res.Value.Bool() {\n\t\treturn &ElementNotFoundError{}\n\t}\n\treturn nil\n}\n\n// Matches checks if the element can be selected by the css selector.\nfunc (el *Element) Matches(selector string) (bool, error) {\n\tres, err := el.Eval(`s => this.matches(s)`, selector)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn res.Value.Bool(), nil\n}\n\n// Attribute of the DOM object.\n// Attribute vs Property:\n// https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html\nfunc (el *Element) Attribute(name string) (*string, error) {\n\tattr, err := el.Eval(\"(n) => this.getAttribute(n)\", name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif attr.Value.Nil() {\n\t\treturn nil, nil //nolint: nilnil\n\t}\n\n\ts := attr.Value.Str()\n\treturn &s, nil\n}\n\n// Property of the DOM object.\n// Property vs Attribute:\n// https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html\nfunc (el *Element) Property(name string) (gson.JSON, error) {\n\tprop, err := el.Eval(\"(n) => this[n]\", name)\n\tif err != nil {\n\t\treturn gson.New(nil), err\n\t}\n\n\treturn prop.Value, nil\n}\n\n// Disabled checks if the element is disabled.\nfunc (el *Element) Disabled() (bool, error) {\n\tprop, err := el.Property(\"disabled\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn prop.Bool(), nil\n}\n\n// SetFiles of the current file input element.\nfunc (el *Element) SetFiles(paths []string) error {\n\tabsPaths := utils.AbsolutePaths(paths)\n\n\tdefer el.tryTrace(TraceTypeInput, fmt.Sprintf(\"set files: %v\", absPaths))()\n\tel.page.browser.trySlowMotion()\n\n\terr := proto.DOMSetFileInputFiles{\n\t\tFiles:    absPaths,\n\t\tObjectID: el.id(),\n\t}.Call(el)\n\n\treturn err\n}\n\n// Describe the current element. The depth is the maximum depth at which children should be retrieved, defaults to 1,\n// use -1 for the entire subtree or provide an integer larger than 0.\n// The pierce decides whether or not iframes and shadow roots should be traversed when returning the subtree.\n// The returned [proto.DOMNode.NodeID] will always be empty,\n// because NodeID is not stable (when [proto.DOMDocumentUpdated]\n// is fired all NodeID on the page will be reassigned to another value)\n// we don't recommend using the NodeID, instead, use the [proto.DOMBackendNodeID] to identify the element.\nfunc (el *Element) Describe(depth int, pierce bool) (*proto.DOMNode, error) {\n\tval, err := proto.DOMDescribeNode{ObjectID: el.id(), Depth: gson.Int(depth), Pierce: pierce}.Call(el)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn val.Node, nil\n}\n\n// ShadowRoot returns the shadow root of this element.\nfunc (el *Element) ShadowRoot() (*Element, error) {\n\tnode, err := el.Describe(1, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// though now it's an array, w3c changed the spec of it to be a single.\n\tif len(node.ShadowRoots) == 0 {\n\t\treturn nil, &NoShadowRootError{el}\n\t}\n\tid := node.ShadowRoots[0].BackendNodeID\n\n\tshadowNode, err := proto.DOMResolveNode{BackendNodeID: id}.Call(el)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn el.page.Context(el.ctx).ElementFromObject(shadowNode.Object)\n}\n\n// Frame creates a page instance that represents the iframe.\nfunc (el *Element) Frame() (*Page, error) {\n\tnode, err := el.Describe(1, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclone := *el.page\n\tclone.FrameID = node.FrameID\n\tclone.jsCtxID = new(proto.RuntimeRemoteObjectID)\n\tclone.element = el\n\tclone.sleeper = el.sleeper\n\n\treturn &clone, nil\n}\n\n// ContainsElement check if the target is equal or inside the element.\nfunc (el *Element) ContainsElement(target *Element) (bool, error) {\n\tres, err := el.Evaluate(evalHelper(js.ContainsElement, target.Object))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn res.Value.Bool(), nil\n}\n\n// Text that the element displays.\nfunc (el *Element) Text() (string, error) {\n\tstr, err := el.Evaluate(evalHelper(js.Text))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn str.Value.String(), nil\n}\n\n// HTML of the element.\nfunc (el *Element) HTML() (string, error) {\n\tres, err := proto.DOMGetOuterHTML{ObjectID: el.Object.ObjectID}.Call(el)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn res.OuterHTML, nil\n}\n\n// Visible returns true if the element is visible on the page.\nfunc (el *Element) Visible() (bool, error) {\n\tres, err := el.Evaluate(evalHelper(js.Visible))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn res.Value.Bool(), nil\n}\n\n// WaitLoad for element like <img>.\nfunc (el *Element) WaitLoad() error {\n\tdefer el.tryTrace(TraceTypeWait, \"load\")()\n\t_, err := el.Evaluate(evalHelper(js.WaitLoad).ByPromise())\n\treturn err\n}\n\n// WaitStable waits until no shape or position change for d duration.\n// Be careful, d is not the max wait timeout, it's the least stable time.\n// If you want to set a timeout you can use the [Element.Timeout] function.\nfunc (el *Element) WaitStable(d time.Duration) error {\n\terr := el.WaitVisible()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeWait, \"stable\")()\n\n\tshape, err := el.Shape()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := time.NewTicker(d)\n\tdefer t.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-t.C:\n\t\tcase <-el.ctx.Done():\n\t\t\treturn el.ctx.Err()\n\t\t}\n\t\tcurrent, err := el.Shape()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif reflect.DeepEqual(shape, current) {\n\t\t\tbreak\n\t\t}\n\t\tshape = current\n\t}\n\treturn nil\n}\n\n// WaitStableRAF waits until no shape or position change for 2 consecutive animation frames.\n// If you want to wait animation that is triggered by JS not CSS, you'd better use [Element.WaitStable].\n// About animation frame: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\nfunc (el *Element) WaitStableRAF() error {\n\terr := el.WaitVisible()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer el.tryTrace(TraceTypeWait, \"stable RAF\")()\n\n\tvar shape *proto.DOMGetContentQuadsResult\n\tpage := el.page.Context(el.ctx)\n\n\tfor {\n\t\terr = page.WaitRepaint()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcurrent, err := el.Shape()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif reflect.DeepEqual(shape, current) {\n\t\t\tbreak\n\t\t}\n\t\tshape = current\n\t}\n\treturn nil\n}\n\n// WaitInteractable waits for the element to be interactable.\n// It will try to scroll to the element on each try.\nfunc (el *Element) WaitInteractable() (pt *proto.Point, err error) {\n\tdefer el.tryTrace(TraceTypeWait, \"interactable\")()\n\n\terr = utils.Retry(el.ctx, el.sleeper(), func() (bool, error) {\n\t\t// For lazy loading page the element can be outside of the viewport.\n\t\t// If we don't scroll to it, it will never be available.\n\t\terr := el.ScrollIntoView()\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tpt, err = el.Interactable()\n\t\tif errors.Is(err, &CoveredError{}) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn true, err\n\t})\n\treturn\n}\n\n// Wait until the js returns true.\nfunc (el *Element) Wait(opts *EvalOptions) error {\n\treturn el.page.Context(el.ctx).Sleeper(el.sleeper).Wait(opts.This(el.Object))\n}\n\n// WaitVisible until the element is visible.\nfunc (el *Element) WaitVisible() error {\n\tdefer el.tryTrace(TraceTypeWait, \"visible\")()\n\treturn el.Wait(evalHelper(js.Visible))\n}\n\n// WaitEnabled until the element is not disabled.\n// Doc for readonly: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly\nfunc (el *Element) WaitEnabled() error {\n\tdefer el.tryTrace(TraceTypeWait, \"enabled\")()\n\treturn el.Wait(Eval(`() => !this.disabled`))\n}\n\n// WaitWritable until the element is not readonly.\n// Doc for disabled: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled\nfunc (el *Element) WaitWritable() error {\n\tdefer el.tryTrace(TraceTypeWait, \"writable\")()\n\treturn el.Wait(Eval(`() => !this.readonly`))\n}\n\n// WaitInvisible until the element invisible.\nfunc (el *Element) WaitInvisible() error {\n\tdefer el.tryTrace(TraceTypeWait, \"invisible\")()\n\treturn el.Wait(evalHelper(js.Invisible))\n}\n\n// CanvasToImage get image data of a canvas.\n// The default format is image/png.\n// The default quality is 0.92.\n// doc: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL\nfunc (el *Element) CanvasToImage(format string, quality float64) ([]byte, error) {\n\tres, err := el.Eval(`(format, quality) => this.toDataURL(format, quality)`, format, quality)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, bin := parseDataURI(res.Value.Str())\n\treturn bin, nil\n}\n\n// Resource returns the \"src\" content of current element. Such as the jpg of <img src=\"a.jpg\">.\nfunc (el *Element) Resource() ([]byte, error) {\n\tsrc, err := el.Evaluate(evalHelper(js.Resource).ByPromise())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn el.page.Context(el.ctx).GetResource(src.Value.String())\n}\n\n// BackgroundImage returns the css background-image of the element.\nfunc (el *Element) BackgroundImage() ([]byte, error) {\n\tres, err := el.Eval(`() => window.getComputedStyle(this).backgroundImage.replace(/^url\\(\"/, '').replace(/\"\\)$/, '')`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu := res.Value.Str()\n\n\treturn el.page.Context(el.ctx).GetResource(u)\n}\n\n// Screenshot of the area of the element.\nfunc (el *Element) Screenshot(format proto.PageCaptureScreenshotFormat, quality int) ([]byte, error) {\n\terr := el.ScrollIntoView()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\topts := &proto.PageCaptureScreenshot{\n\t\tQuality: gson.Int(quality),\n\t\tFormat:  format,\n\t}\n\n\tbin, err := el.page.Context(el.ctx).Screenshot(false, opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// so that it won't clip the css-transformed element\n\tshape, err := el.Shape()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbox := shape.Box()\n\n\t// TODO: proto.PageCaptureScreenshot has a Clip option, but it's buggy, so now we do in Go.\n\treturn utils.CropImage(bin, quality,\n\t\tint(box.X),\n\t\tint(box.Y),\n\t\tint(box.Width),\n\t\tint(box.Height),\n\t)\n}\n\n// Release is a shortcut for [Page.Release] current element.\nfunc (el *Element) Release() error {\n\treturn el.page.Context(el.ctx).Release(el.Object)\n}\n\n// Remove the element from the page.\nfunc (el *Element) Remove() error {\n\t_, err := el.Eval(`() => this.remove()`)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn el.Release()\n}\n\n// Call implements the [proto.Client].\nfunc (el *Element) Call(ctx context.Context, sessionID, methodName string, params interface{}) (res []byte, err error) {\n\treturn el.page.Call(ctx, sessionID, methodName, params)\n}\n\n// Eval is a shortcut for [Element.Evaluate] with AwaitPromise, ByValue and AutoExp set to true.\nfunc (el *Element) Eval(js string, params ...interface{}) (*proto.RuntimeRemoteObject, error) {\n\treturn el.Evaluate(Eval(js, params...).ByPromise())\n}\n\n// Evaluate is just a shortcut of [Page.Evaluate] with This set to current element.\nfunc (el *Element) Evaluate(opts *EvalOptions) (*proto.RuntimeRemoteObject, error) {\n\treturn el.page.Context(el.ctx).Evaluate(opts.This(el.Object))\n}\n\n// Equal checks if the two elements are equal.\nfunc (el *Element) Equal(elm *Element) (bool, error) {\n\tres, err := el.Eval(`elm => this === elm`, elm.Object)\n\treturn res.Value.Bool(), err\n}\n\nfunc (el *Element) id() proto.RuntimeRemoteObjectID {\n\treturn el.Object.ObjectID\n}\n\n// GetXPath returns the xpath of the element.\nfunc (el *Element) GetXPath(optimized bool) (string, error) {\n\tstr, err := el.Evaluate(evalHelper(js.GetXPath, optimized))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn str.Value.String(), nil\n}\n"
        },
        {
          "name": "element_test.go",
          "type": "blob",
          "size": 23.4375,
          "content": "package rod_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestGetElementPage(t *testing.T) {\n\tg := setup(t)\n\n\tel := g.page.MustNavigate(g.blank()).MustElement(\"html\")\n\tg.Eq(el.Page().SessionID, g.page.SessionID)\n}\n\nfunc TestClick(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\tel.MustClick()\n\n\tg.True(p.MustHas(\"[a=ok]\"))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustClick()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(8, proto.RuntimeCallFunctionOn{})\n\t\tel.MustClick()\n\t})\n}\n\nfunc TestClickWrapped(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click-wrapped.html\")).MustWaitLoad()\n\tel := p.MustElement(\"#target\")\n\n\tshape := el.MustShape()\n\tg.Len(shape.Quads, 2)\n\n\tel.MustClick()\n\tg.True(p.MustHas(\"[a=ok]\"))\n}\n\nfunc TestTap(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage()\n\n\tpage.MustEmulate(devices.IPad).\n\t\tMustNavigate(g.srcFile(\"fixtures/touch.html\")).\n\t\tMustWaitLoad()\n\tel := page.MustElement(\"button\")\n\n\tel.MustTap()\n\n\tg.True(page.MustHas(\"[tapped=true]\"))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustTap()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\t\tel.MustTap()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(4, proto.RuntimeCallFunctionOn{})\n\t\tel.MustTap()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(7, proto.RuntimeCallFunctionOn{})\n\t\tel.MustTap()\n\t})\n}\n\nfunc TestInteractable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\tg.True(el.MustInteractable())\n\n\tg.mc.stubErr(4, proto.RuntimeCallFunctionOn{})\n\tg.Err(el.Interactable())\n}\n\nfunc TestNotInteractable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\n\t// cover the button with a green div\n\tp.MustWaitLoad().MustEval(`() => {\n\t\tlet div = document.createElement('div')\n\t\tdiv.style = 'position: absolute; left: 0; top: 0; width: 500px; height: 500px;'\n\t\tdocument.body.append(div)\n\t}`)\n\t_, err := el.Interactable()\n\tg.Has(err.Error(), \"element covered by: <div>\")\n\tg.Is(err, &rod.NotInteractableError{})\n\tg.Is(err, &rod.CoveredError{})\n\tg.False(el.MustInteractable())\n\tvar ee *rod.NotInteractableError\n\tg.True(errors.As(err, &ee))\n\tg.Eq(ee.Error(), \"element is not cursor interactable\")\n\n\tp.MustElement(\"div\").MustRemove()\n\n\tg.mc.stubErr(1, proto.DOMGetContentQuads{})\n\t_, err = el.Interactable()\n\tg.Err(err)\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(el.Interactable())\n\n\tg.mc.stubErr(1, proto.DOMDescribeNode{})\n\tg.Err(el.Interactable())\n\n\tg.mc.stubErr(2, proto.RuntimeCallFunctionOn{})\n\tg.Err(el.Interactable())\n}\n\nfunc TestInteractableWithNoShape(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/interactable.html\"))\n\n\tel := p.MustElement(\"#no-shape\")\n\t_, err := el.Interactable()\n\tg.Is(err, &rod.InvisibleShapeError{})\n\tg.Is(err, &rod.NotInteractableError{})\n\tg.Eq(err.Error(), \"element has no visible shape or outside the viewport: <div#no-shape>\")\n\n\tel = p.MustElement(\"#outside\")\n\t_, err = el.Interactable()\n\tg.Is(err, &rod.InvisibleShapeError{})\n\n\tel = p.MustElement(\"#invisible\")\n\t_, err = el.Interactable()\n\tg.Is(err, &rod.InvisibleShapeError{})\n}\n\nfunc TestNotInteractableWithNoPointerEvents(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/interactable.html\"))\n\t_, err := p.MustElementR(\"#no-pointer-events\", \"click me\").Interactable()\n\tg.Is(err, &rod.NoPointerEventsError{})\n\tg.Is(err, &rod.NotInteractableError{})\n\tg.Eq(err.Error(), \"element's pointer-events is none: <span#no-pointer-events>\")\n}\n\nfunc TestWaitInteractable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\n\tstart := time.Now()\n\n\t// cover the button with a green div for 1sec\n\tp.MustWaitLoad().MustEval(`() => {\n\t\tlet div = document.createElement('div')\n\t\tdiv.style = 'position: absolute; left: 0; top: 0; width: 500px; height: 500px;'\n\t\tdocument.body.append(div)\n\t\tsetTimeout(() => div.remove(), 1000)\n\t}`)\n\n\tel.MustWaitInteractable()\n\n\tg.Gt(time.Since(start), time.Second)\n\n\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\tg.Err(el.WaitInteractable())\n}\n\nfunc TestHover(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\tel.MustEval(`() => this.onmouseenter = () => this.dataset['a'] = 1`)\n\tel.MustHover()\n\tg.Eq(\"1\", el.MustEval(`() => this.dataset['a']`).String())\n\n\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\tg.Err(el.Hover())\n\n\tg.mc.stubErr(1, proto.DOMGetContentQuads{})\n\tg.Err(el.Hover())\n\n\tg.mc.stubErr(3, proto.DOMGetContentQuads{})\n\tg.Err(el.Hover())\n\n\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\tg.Err(el.Hover())\n}\n\nfunc TestElementMoveMouseOut(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tbtn := p.MustElement(\"button\")\n\tbtn.MustEval(`() => this.onmouseout = () => this.setAttribute('name', 'mouse moved.')`)\n\tg.Eq(\"mouse moved.\", *btn.MustHover().MustMoveMouseOut().MustAttribute(\"name\"))\n\n\tg.mc.stubErr(1, proto.DOMGetContentQuads{})\n\tg.Err(btn.MoveMouseOut())\n}\n\nfunc TestElementContext(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\").Timeout(time.Hour).CancelTimeout()\n\tel, cancel := el.WithCancel()\n\tdefer cancel()\n\tel.Sleeper(rod.DefaultSleeper).MustClick()\n}\n\nfunc TestElementCancelContext(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.Timeout(time.Second).MustElement(\"button\")\n\tel = el.CancelTimeout()\n\tutils.Sleep(1.1)\n\tel.MustClick()\n}\n\nfunc TestIframes(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click-iframes.html\"))\n\n\tframe01 := p.MustElement(\"iframe\").MustFrame()\n\n\tframe02 := frame01.MustElement(\"iframe\").MustFrame()\n\tel := frame02.MustElement(\"button\")\n\tel.MustClick()\n\n\tg.Eq(frame01.MustEval(`() => testIsolation()`).Str(), \"ok\")\n\tg.True(frame02.MustHas(\"[a=ok]\"))\n}\n\nfunc TestIframeCrossDomains(t *testing.T) {\n\tg := setup(t)\n\n\tr1 := g.Serve()\n\tr2 := g.Serve()\n\n\t// Same domain name with different ports won't trigger OOPIF (out-of-process iframes)\n\t// To check the page OOPIF status, you can use chrome://process-internals tab in the browser.\n\thost1 := net.JoinHostPort(\"localhost\", r1.HostURL.Port())\n\thost2 := net.JoinHostPort(\"127.0.0.1\", r2.HostURL.Port())\n\n\tu1 := fmt.Sprintf(\"http://%s/iframe\", host1)\n\tu2 := fmt.Sprintf(\"http://%s/page\", host2)\n\n\tr1.Route(\"/iframe\", \".html\", `<html>\n\t\t<div id=\"a\">a</div>\n\t</html>`)\n\n\tr2.Route(\"/page\", \".html\", `<html>\n\t\t<iframe sandbox src=\"`+u1+`\"></iframe>\n\t</html>`)\n\n\tu := launcher.New().HeadlessNew(true).NoSandbox(true).MustLaunch()\n\tbrowser := rod.New().ControlURL(u).NoDefaultDevice().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(u2)\n\n\tg.Eq(page.MustElement(\"iframe\").MustFrame().MustElement(\"#a\").MustText(), \"a\")\n}\n\nfunc TestContains(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\ta := p.MustElement(\"button\")\n\n\tb := p.MustElementFromNode(a.MustDescribe())\n\tg.True(a.MustContainsElement(b))\n\n\tpt := a.MustShape().OnePointInside()\n\tel := p.MustElementFromPoint(int(pt.X), int(pt.Y))\n\tg.True(a.MustContainsElement(el))\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(a.ContainsElement(el))\n}\n\nfunc TestShadowDOM(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/shadow-dom.html\")).MustWaitLoad()\n\tel := p.MustElement(\"#container\")\n\tg.Eq(\"inside\", el.MustShadowRoot().MustElement(\"p\").MustText())\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMDescribeNode{})\n\t\tel.MustShadowRoot()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMResolveNode{})\n\t\tel.MustShadowRoot()\n\t})\n\n\telNoShadow := p.MustElement(\"script\")\n\t_, err := elNoShadow.ShadowRoot()\n\tg.True((&rod.NoShadowRootError{}).Is(err))\n\tg.Has(err.Error(), \"element has no shadow root:\")\n}\n\nfunc TestInputTime(t *testing.T) {\n\tg := setup(t)\n\n\tnow := time.Date(2006, 1, 2, 3, 4, 5, 0, time.Local)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\n\tvar el *rod.Element\n\t{\n\t\tel = p.MustElement(\"[type=date]\")\n\t\tel.MustInputTime(now)\n\n\t\tg.Eq(el.MustText(), now.Format(\"2006-01-02\"))\n\t\tg.True(p.MustHas(\"[event=input-date-change]\"))\n\t}\n\n\t{\n\t\tel = p.MustElement(\"[type=datetime-local]\")\n\t\tel.MustInputTime(now)\n\n\t\tg.Eq(el.MustText(), now.Format(\"2006-01-02T15:04\"))\n\t\tg.True(p.MustHas(\"[event=input-datetime-local-change]\"))\n\t}\n\n\t{\n\t\tel = p.MustElement(\"[type=time]\")\n\t\tel.MustInputTime(now)\n\n\t\tg.Eq(el.MustText(), fmt.Sprintf(\"%02d:%02d\", now.Hour(), now.Minute()))\n\t\tg.True(p.MustHas(\"[event=input-time-change]\"))\n\t}\n\n\t{\n\t\tel = p.MustElement(\"[type=month]\")\n\t\tel.MustInputTime(now)\n\n\t\tg.Eq(el.MustText(), now.Format(\"2006-01\"))\n\t\tg.True(p.MustHas(\"[event=input-month-change]\"))\n\t}\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputTime(now)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(5, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputTime(now)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(6, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputTime(now)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(7, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputTime(now)\n\t})\n}\n\nfunc TestInputColor(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\n\tvar el *rod.Element\n\t{\n\t\tel = p.MustElement(\"[type=color]\")\n\t\tel.MustInputColor(\"#ff6f00\")\n\n\t\tg.Eq(el.MustText(), \"#ff6f00\")\n\t\tg.True(p.MustHas(\"[event=input-color-change]\"))\n\t}\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputColor(\"#ff6f00\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(5, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputColor(\"#ff6f00\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(6, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInputColor(\"#ff6f00\")\n\t})\n}\n\nfunc TestElementInputDate(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tp.MustElement(\"[type=date]\").MustInput(\"12\")\n}\n\nfunc TestCheckbox(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"[type=checkbox]\")\n\tg.True(el.MustClick().MustProperty(\"checked\").Bool())\n}\n\nfunc TestSelectText(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"textarea\")\n\tel.MustInput(\"test\")\n\tel.MustSelectAllText()\n\tel.MustInput(\"test\")\n\tg.Eq(\"test\", el.MustText())\n\n\tel.MustSelectText(`es`)\n\tel.MustInput(\"__\")\n\n\tg.Eq(\"t__t\", el.MustText())\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\t\tel.MustSelectText(\"\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\t\tel.MustSelectAllText()\n\t})\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\t\tel.MustInput(\"\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputInsertText{})\n\t\tel.MustInput(\"\")\n\t})\n}\n\nfunc TestBlur(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"#blur\").MustInput(\"test\").MustBlur()\n\n\tg.Eq(\"ok\", *el.MustAttribute(\"a\"))\n}\n\nfunc TestSelectQuery(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"select\")\n\terr := el.Select([]string{`[value=\"c\"]`}, true, rod.SelectorTypeCSSSector)\n\tg.E(err)\n\n\tg.Eq(2, el.MustEval(\"() => this.selectedIndex\").Int())\n}\n\nfunc TestSelectOptions(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"select\")\n\tel.MustSelect(\"B\", \"C\")\n\tg.Eq(\"B,C\", el.MustText())\n\tg.Eq(1, el.MustProperty(\"selectedIndex\").Int())\n\n\t// unselect with regex\n\terr := el.Select([]string{`^B$`}, false, rod.SelectorTypeRegex)\n\tg.E(err)\n\tg.Eq(\"C\", el.MustText())\n\n\t// unselect with css selector\n\terr = el.Select([]string{`[value=\"c\"]`}, false, rod.SelectorTypeCSSSector)\n\tg.E(err)\n\tg.Eq(\"\", el.MustText())\n\n\t// option not found error\n\tg.Is(el.Select([]string{\"not-exists\"}, true, rod.SelectorTypeCSSSector), &rod.ElementNotFoundError{})\n\n\t{\n\t\tg.mc.stubErr(5, proto.RuntimeCallFunctionOn{})\n\t\tg.Err(el.Select([]string{\"B\"}, true, rod.SelectorTypeText))\n\t}\n}\n\nfunc TestMatches(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"textarea\")\n\tg.True(el.MustMatches(`[cols=\"30\"]`))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustMatches(\"\")\n\t})\n}\n\nfunc TestAttribute(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"textarea\")\n\tcols := el.MustAttribute(\"cols\")\n\trows := el.MustAttribute(\"rows\")\n\n\tg.Eq(\"30\", *cols)\n\tg.Eq(\"10\", *rows)\n\n\tp = g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel = p.MustElement(\"button\").MustClick()\n\n\tg.Eq(\"ok\", *el.MustAttribute(\"a\"))\n\tg.Nil(el.MustAttribute(\"b\"))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustAttribute(\"\")\n\t})\n}\n\nfunc TestProperty(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"textarea\")\n\tcols := el.MustProperty(\"cols\")\n\trows := el.MustProperty(\"rows\")\n\n\tg.Eq(float64(30), cols.Num())\n\tg.Eq(float64(10), rows.Num())\n\n\tp = g.page.MustNavigate(g.srcFile(\"fixtures/open-page.html\"))\n\tel = p.MustElement(\"a\")\n\n\tg.Eq(\"link\", el.MustProperty(\"id\").Str())\n\tg.Eq(\"_blank\", el.MustProperty(\"target\").Str())\n\tg.True(el.MustProperty(\"test\").Nil())\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustProperty(\"\")\n\t})\n}\n\nfunc TestDisabled(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\n\tg.False(p.MustElement(\"#EnabledButton\").MustDisabled())\n\tg.True(p.MustElement(\"#DisabledButton\").MustDisabled())\n\n\tg.Panic(func() {\n\t\tel := p.MustElement(\"#EnabledButton\")\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustDisabled()\n\t})\n}\n\nfunc TestSetFiles(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(`[type=file]`)\n\tel.MustSetFiles(\n\t\tslash(\"fixtures/click.html\"),\n\t\tslash(\"fixtures/alert.html\"),\n\t)\n\n\tlist := el.MustEval(\"() => Array.from(this.files).map(f => f.name)\").Arr()\n\tg.Len(list, 2)\n\tg.Eq(\"alert.html\", list[1].String())\n}\n\nfunc TestEnter(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"[type=submit]\")\n\tel.MustType(input.Enter)\n\n\tg.True(p.MustHas(\"[event=submit]\"))\n}\n\nfunc TestWaitInvisible(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\th4 := p.MustElement(\"h4\")\n\tbtn := p.MustElement(\"button\")\n\n\tg.True(h4.MustVisible())\n\n\th4.MustWaitVisible()\n\n\tgo func() {\n\t\tutils.Sleep(0.03)\n\t\th4.MustEval(`() => this.remove()`)\n\t\tutils.Sleep(0.03)\n\t\tbtn.MustEval(`() => this.style.visibility = 'hidden'`)\n\t}()\n\n\th4.MustWaitInvisible()\n\tbtn.MustWaitInvisible()\n\n\tg.False(p.MustHas(\"h4\"))\n}\n\nfunc TestWaitEnabled(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tp.MustElement(\"button\").MustWaitEnabled()\n}\n\nfunc TestWaitWritable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tp.MustElement(\"input\").MustWaitWritable()\n}\n\nfunc TestWaitStable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/wait-stable.html\"))\n\tel := p.MustElement(\"button\")\n\tgo func() {\n\t\tutils.Sleep(1)\n\t\tel.MustEval(`() => this.classList.remove(\"play\")`)\n\t}()\n\tstart := time.Now()\n\tel.MustWaitStable()\n\tg.Gt(time.Since(start), time.Second)\n\n\tctx := g.Context()\n\tg.mc.stub(1, proto.DOMGetContentQuads{}, func(send StubSend) (gson.JSON, error) {\n\t\tgo func() {\n\t\t\tutils.Sleep(0.1)\n\t\t\tctx.Cancel()\n\t\t}()\n\t\treturn send()\n\t})\n\tg.Err(el.Context(ctx).WaitStable(time.Minute))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMGetContentQuads{})\n\t\tel.MustWaitStable()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(2, proto.DOMGetContentQuads{})\n\t\tel.MustWaitStable()\n\t})\n}\n\nfunc TestWaitStableRAP(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/wait-stable.html\"))\n\tel := p.MustElement(\"button\")\n\tgo func() {\n\t\tutils.Sleep(1)\n\t\tel.MustEval(`() => this.classList.remove(\"play\")`)\n\t}()\n\tstart := time.Now()\n\tg.E(el.WaitStableRAF())\n\tg.Gt(time.Since(start), time.Second)\n\n\tg.mc.stubErr(2, proto.RuntimeCallFunctionOn{})\n\tg.Err(el.WaitStableRAF())\n\n\tg.mc.stubErr(1, proto.DOMGetContentQuads{})\n\tg.Err(el.WaitStableRAF())\n}\n\nfunc TestCanvasToImage(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/canvas.html\"))\n\tsrc, err := png.Decode(bytes.NewBuffer(p.MustElement(\"#canvas\").MustCanvasToImage()))\n\tg.E(err)\n\tg.Eq(src.At(50, 50), color.NRGBA{0xFF, 0x00, 0x00, 0xFF})\n}\n\nfunc TestElementWaitLoad(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/resource.html\"))\n\tp.MustElement(\"img\").MustWaitLoad()\n}\n\nfunc TestResource(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/resource.html\"))\n\tel := p.MustElement(\"img\")\n\tg.Eq(len(el.MustResource()), 22661)\n\n\tg.mc.stub(1, proto.PageGetResourceContent{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(proto.PageGetResourceContentResult{\n\t\t\tContent:       \"ok\",\n\t\t\tBase64Encoded: false,\n\t\t}), nil\n\t})\n\tg.Eq([]byte(\"ok\"), el.MustResource())\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustResource()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageGetResourceContent{})\n\t\tel.MustResource()\n\t})\n}\n\nfunc TestBackgroundImage(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/resource.html\")).MustWaitStable()\n\tel := p.MustElement(\"div\")\n\tg.Eq(len(el.MustBackgroundImage()), 22661)\n\n\t{\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tg.Err(el.BackgroundImage())\n\t}\n}\n\nfunc TestElementScreenshot(t *testing.T) {\n\tg := setup(t)\n\n\tf := filepath.Join(\"tmp\", \"screenshots\", g.RandStr(16)+\".png\")\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"h4\")\n\n\tdata := el.MustScreenshot(f)\n\timg, err := png.Decode(bytes.NewBuffer(data))\n\tg.E(err)\n\tg.Eq(200, img.Bounds().Dx())\n\tg.Eq(30, img.Bounds().Dy())\n\tg.Nil(os.Stat(f))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMScrollIntoViewIfNeeded{})\n\t\tel.MustScreenshot()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageCaptureScreenshot{})\n\t\tel.MustScreenshot()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(3, proto.DOMGetContentQuads{})\n\t\tel.MustScreenshot()\n\t})\n}\n\nfunc TestUseReleasedElement(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tbtn := p.MustElement(\"button\")\n\tbtn.MustRelease()\n\tg.Err(btn.Click(\"left\", 1))\n\n\tbtn = p.MustElement(\"button\")\n\tg.E(proto.RuntimeReleaseObject{ObjectID: btn.Object.ObjectID}.Call(p))\n\tg.Is(btn.Click(\"left\", 1), cdp.ErrObjNotFound)\n}\n\nfunc TestElementRemove(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tbtn := p.MustElement(\"button\")\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(btn.Remove())\n}\n\nfunc TestElementMultipleTimes(t *testing.T) {\n\tg := setup(t)\n\n\t// To see whether chrome will reuse the remote object ID or not.\n\t// Seems like it will not.\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\n\tbtn01 := page.MustElement(\"button\")\n\tbtn02 := page.MustElement(\"button\")\n\n\tg.Eq(btn01.MustText(), btn02.MustText())\n\tg.Neq(btn01.Object, btn02.Object)\n}\n\nfunc TestFnErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\n\t_, err := el.Eval(\"foo()\")\n\tg.Err(err)\n\tg.Has(err.Error(), \"ReferenceError: foo is not defined\")\n\tvar e *rod.EvalError\n\tg.True(errors.As(err, &e))\n\tg.Eq(proto.RuntimeRemoteObjectSubtypeError, e.Exception.Subtype)\n\n\t_, err = el.ElementByJS(rod.Eval(\"() => foo()\"))\n\tg.Err(err)\n\tg.Has(err.Error(), \"ReferenceError: foo is not defined\")\n\tg.True(errors.Is(err, &rod.EvalError{}))\n}\n\nfunc TestElementEWithDepth(t *testing.T) {\n\tg := setup(t)\n\n\tcheckStr := `green tea`\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/describe.html\"))\n\n\tulDOMNode, err := p.MustElement(`ul`).Describe(-1, true)\n\tg.Nil(errors.Unwrap(err))\n\n\tdata, err := json.Marshal(ulDOMNode)\n\tg.Nil(errors.Unwrap(err))\n\t// The depth is -1, should contain checkStr\n\tg.Has(string(data), checkStr)\n}\n\nfunc TestElementOthers(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"form\")\n\tel.MustFocus()\n\tel.MustScrollIntoView()\n\tg.Eq(\"submit\", el.MustElement(\"[type=submit]\").MustText())\n\tg.Eq(\"<input type=\\\"submit\\\" value=\\\"submit\\\">\", el.MustElement(\"[type=submit]\").MustHTML())\n\tel.MustWait(`() => true`)\n\tg.Eq(\"form\", el.MustElementByJS(`() => this`).MustDescribe().LocalName)\n\tg.Len(el.MustElementsByJS(`() => []`), 0)\n}\n\nfunc TestElementEqual(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/describe.html\"))\n\tel1 := p.MustElement(\"body > ul\")\n\tel2 := p.MustElement(\"html > body > ul\")\n\tg.True(el1.MustEqual(el2))\n\n\tel3 := p.MustElement(\"ul ul\")\n\tg.False(el1.MustEqual(el3))\n}\n\nfunc TestElementWait(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/describe.html\"))\n\te1 := p.MustElement(\"body > ul > li\")\n\tg.Eq(e1.MustText(), \"coffee\")\n\n\tparams := []interface{}{1, 3, 4}\n\tgo func() {\n\t\tutils.Sleep(0.3)\n\t\te1.MustEval(`(a, b, c) => this.innerText = 'x'.repeat(a + b + c)`, params...)\n\t}()\n\n\te1.MustWait(`(a, b, c) => this.innerText.length === (a + b + c)`, params...)\n\tg.Eq(e1.MustText(), \"xxxxxxxx\")\n}\n\nfunc TestShapeInIframe(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click-iframe.html\"))\n\tpt := p.MustElement(\"iframe\").MustFrame().MustElement(\"button\").MustShape().OnePointInside()\n\n\tg.InDelta(pt.X, 238, 1)\n\tg.InDelta(pt.Y, 287, 1)\n}\n\nfunc TestElementFromPointErr(t *testing.T) {\n\tg := setup(t)\n\n\tg.mc.stubErr(1, proto.DOMGetNodeForLocation{})\n\tg.Err(g.page.ElementFromPoint(10, 10))\n}\n\nfunc TestElementFromNodeErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElementX(\"//button/text()\")\n\n\tg.mc.stubErr(3, proto.RuntimeCallFunctionOn{})\n\tg.Err(p.ElementFromNode(el.MustDescribe()))\n}\n\nfunc TestElementErrors(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"form\")\n\n\tctx := g.Timeout(0)\n\n\t_, err := el.Context(ctx).Describe(-1, true)\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).Frame()\n\tg.Err(err)\n\n\terr = el.Context(ctx).Focus()\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).KeyActions()\n\tg.Err(err)\n\n\terr = el.Context(ctx).Input(\"a\")\n\tg.Err(err)\n\n\terr = el.Context(ctx).Select([]string{\"a\"}, true, rod.SelectorTypeText)\n\tg.Err(err)\n\n\terr = el.Context(ctx).WaitStable(0)\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).Resource()\n\tg.Err(err)\n\n\terr = el.Context(ctx).Input(\"a\")\n\tg.Err(err)\n\n\terr = el.Context(ctx).Input(\"a\")\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).HTML()\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).Visible()\n\tg.Err(err)\n\n\t_, err = el.Context(ctx).CanvasToImage(\"\", 0)\n\tg.Err(err)\n\n\terr = el.Context(ctx).Release()\n\tg.Err(err)\n}\n\nfunc TestElementGetXPath(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"textarea\")\n\txpath := el.MustGetXPath(true)\n\tg.Eq(xpath, \"/html/body/form/textarea\")\n\n\txpath = el.MustGetXPath(false)\n\tg.Eq(xpath, \"/html/body/form/textarea\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustGetXPath(true)\n\t})\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 4.447265625,
          "content": "package rod\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\n// TryError error.\ntype TryError struct {\n\tValue interface{}\n\tStack string\n}\n\nfunc (e *TryError) Error() string {\n\treturn fmt.Sprintf(\"error value: %#v\\n%s\", e.Value, e.Stack)\n}\n\n// Is interface.\nfunc (e *TryError) Is(err error) bool { _, ok := err.(*TryError); return ok }\n\n// Unwrap stdlib interface.\nfunc (e *TryError) Unwrap() error {\n\tif err, ok := e.Value.(error); ok {\n\t\treturn err\n\t}\n\treturn fmt.Errorf(\"%v\", e.Value)\n}\n\n// ExpectElementError error.\ntype ExpectElementError struct {\n\t*proto.RuntimeRemoteObject\n}\n\nfunc (e *ExpectElementError) Error() string {\n\treturn fmt.Sprintf(\"expect js to return an element, but got: %s\", utils.MustToJSON(e))\n}\n\n// Is interface.\nfunc (e *ExpectElementError) Is(err error) bool { _, ok := err.(*ExpectElementError); return ok }\n\n// ExpectElementsError error.\ntype ExpectElementsError struct {\n\t*proto.RuntimeRemoteObject\n}\n\nfunc (e *ExpectElementsError) Error() string {\n\treturn fmt.Sprintf(\"expect js to return an array of elements, but got: %s\", utils.MustToJSON(e))\n}\n\n// Is interface.\nfunc (e *ExpectElementsError) Is(err error) bool { _, ok := err.(*ExpectElementsError); return ok }\n\n// ElementNotFoundError error.\ntype ElementNotFoundError struct{}\n\nfunc (e *ElementNotFoundError) Error() string {\n\treturn \"cannot find element\"\n}\n\n// NotFoundSleeper returns ErrElementNotFound on the first call.\nfunc NotFoundSleeper() utils.Sleeper {\n\treturn func(context.Context) error {\n\t\treturn &ElementNotFoundError{}\n\t}\n}\n\n// ObjectNotFoundError error.\ntype ObjectNotFoundError struct {\n\t*proto.RuntimeRemoteObject\n}\n\nfunc (e *ObjectNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"cannot find object: %s\", utils.MustToJSON(e))\n}\n\n// Is interface.\nfunc (e *ObjectNotFoundError) Is(err error) bool { _, ok := err.(*ObjectNotFoundError); return ok }\n\n// EvalError error.\ntype EvalError struct {\n\t*proto.RuntimeExceptionDetails\n}\n\nfunc (e *EvalError) Error() string {\n\texp := e.Exception\n\treturn fmt.Sprintf(\"eval js error: %s %s\", exp.Description, exp.Value)\n}\n\n// Is interface.\nfunc (e *EvalError) Is(err error) bool { _, ok := err.(*EvalError); return ok }\n\n// NavigationError error.\ntype NavigationError struct {\n\tReason string\n}\n\nfunc (e *NavigationError) Error() string {\n\treturn \"navigation failed: \" + e.Reason\n}\n\n// Is interface.\nfunc (e *NavigationError) Is(err error) bool { _, ok := err.(*NavigationError); return ok }\n\n// PageCloseCanceledError error.\ntype PageCloseCanceledError struct{}\n\nfunc (e *PageCloseCanceledError) Error() string {\n\treturn \"page close canceled\"\n}\n\n// NotInteractableError error. Check the doc of Element.Interactable for details.\ntype NotInteractableError struct{}\n\nfunc (e *NotInteractableError) Error() string {\n\treturn \"element is not cursor interactable\"\n}\n\n// InvisibleShapeError error.\ntype InvisibleShapeError struct {\n\t*Element\n}\n\n// Error ...\nfunc (e *InvisibleShapeError) Error() string {\n\treturn fmt.Sprintf(\"element has no visible shape or outside the viewport: %s\", e.String())\n}\n\n// Is interface.\nfunc (e *InvisibleShapeError) Is(err error) bool { _, ok := err.(*InvisibleShapeError); return ok }\n\n// Unwrap ...\nfunc (e *InvisibleShapeError) Unwrap() error {\n\treturn &NotInteractableError{}\n}\n\n// CoveredError error.\ntype CoveredError struct {\n\t*Element\n}\n\n// Error ...\nfunc (e *CoveredError) Error() string {\n\treturn fmt.Sprintf(\"element covered by: %s\", e.String())\n}\n\n// Unwrap ...\nfunc (e *CoveredError) Unwrap() error {\n\treturn &NotInteractableError{}\n}\n\n// Is interface.\nfunc (e *CoveredError) Is(err error) bool { _, ok := err.(*CoveredError); return ok }\n\n// NoPointerEventsError error.\ntype NoPointerEventsError struct {\n\t*Element\n}\n\n// Error ...\nfunc (e *NoPointerEventsError) Error() string {\n\treturn fmt.Sprintf(\"element's pointer-events is none: %s\", e.String())\n}\n\n// Unwrap ...\nfunc (e *NoPointerEventsError) Unwrap() error {\n\treturn &NotInteractableError{}\n}\n\n// Is interface.\nfunc (e *NoPointerEventsError) Is(err error) bool { _, ok := err.(*NoPointerEventsError); return ok }\n\n// PageNotFoundError error.\ntype PageNotFoundError struct{}\n\nfunc (e *PageNotFoundError) Error() string {\n\treturn \"cannot find page\"\n}\n\n// NoShadowRootError error.\ntype NoShadowRootError struct {\n\t*Element\n}\n\n// Error ...\nfunc (e *NoShadowRootError) Error() string {\n\treturn fmt.Sprintf(\"element has no shadow root: %s\", e.String())\n}\n\n// Is interface.\nfunc (e *NoShadowRootError) Is(err error) bool { _, ok := err.(*NoShadowRootError); return ok }\n"
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 19.740234375,
          "content": "package rod_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// This example opens https://github.com/, searches for \"git\",\n// and then gets the header element which gives the description for Git.\nfunc Example_basic() {\n\t// Launch a new browser with default options, and connect to it.\n\tbrowser := rod.New().MustConnect()\n\n\t// Even you forget to close, rod will close it after main process ends.\n\tdefer browser.MustClose()\n\n\t// Create a new page\n\tpage := browser.MustPage(\"https://github.com\").MustWaitStable()\n\n\t// Trigger the search input with hotkey \"/\"\n\tpage.Keyboard.MustType(input.Slash)\n\n\t// We use css selector to get the search input element and input \"git\"\n\tpage.MustElement(\"#query-builder-test\").MustInput(\"git\").MustType(input.Enter)\n\n\t// Wait until css selector get the element then get the text content of it.\n\ttext := page.MustElementR(\"span\", \"most widely used\").MustText()\n\n\tfmt.Println(text)\n\n\t// Get all input elements. Rod supports query elements by css selector, xpath, and regex.\n\t// For more detailed usage, check the query_test.go file.\n\tfmt.Println(\"Found\", len(page.MustElements(\"input\")), \"input elements\")\n\n\t// Eval js on the page\n\tpage.MustEval(`() => console.log(\"hello world\")`)\n\n\t// Pass parameters as json objects to the js function. This MustEval will result 3\n\tfmt.Println(\"1 + 2 =\", page.MustEval(`(a, b) => a + b`, 1, 2).Int())\n\n\t// When eval on an element, \"this\" in the js is the current DOM element.\n\tfmt.Println(page.MustElement(\"title\").MustEval(`() => this.innerText`).String())\n\n\t// Output:\n\t// Git is the most widely used version control system.\n\t// Found 9 input elements\n\t// 1 + 2 = 3\n\t// Repository search results · GitHub\n}\n\n// Shows how to disable headless mode and debug.\n// Rod provides a lot of debug options, you can set them with setter methods or use environment variables.\n// Doc for environment variables: https://pkg.go.dev/github.com/go-rod/rod/lib/defaults\nfunc Example_disable_headless_to_debug() {\n\t// Headless runs the browser on foreground, you can also use flag \"-rod=show\"\n\t// Devtools opens the tab in each new tab opened automatically\n\tl := launcher.New().\n\t\tHeadless(false).\n\t\tDevtools(true)\n\n\tdefer l.Cleanup()\n\n\turl := l.MustLaunch()\n\n\t// Trace shows verbose debug information for each action executed\n\t// SlowMotion is a debug related function that waits 2 seconds between\n\t// each action, making it easier to inspect what your code is doing.\n\tbrowser := rod.New().\n\t\tControlURL(url).\n\t\tTrace(true).\n\t\tSlowMotion(2 * time.Second).\n\t\tMustConnect()\n\n\t// ServeMonitor plays screenshots of each tab. This feature is extremely\n\t// useful when debugging with headless mode.\n\t// You can also enable it with flag \"-rod=monitor\"\n\tlauncher.Open(browser.ServeMonitor(\"\"))\n\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://github.com/\")\n\n\tpage.MustElement(\"input\").MustInput(\"git\").MustType(input.Enter)\n\n\ttext := page.MustElement(\".codesearch-results p\").MustText()\n\n\tfmt.Println(text)\n\n\tutils.Pause() // pause goroutine\n}\n\n// Rod use https://golang.org/pkg/context to handle cancellations for IO blocking operations, most times it's timeout.\n// Context will be recursively passed to all sub-methods.\n// For example, methods like Page.Context(ctx) will return a clone of the page with the ctx,\n// all the methods of the returned page will use the ctx if they have IO blocking operations.\n// [Page.Timeout] or [Page.WithCancel] is just a shortcut for Page.Context.\n// Of course, Browser or Element works the same way.\nfunc Example_context_and_timeout() {\n\tpage := rod.New().MustConnect().MustPage(\"https://github.com\")\n\n\tpage.\n\t\t// Set a 5-second timeout for all chained methods\n\t\tTimeout(5 * time.Second).\n\n\t\t// The total time for MustWaitLoad and MustElement must be less than 5 seconds\n\t\tMustWaitLoad().\n\t\tMustElement(\"title\").\n\n\t\t// Methods after CancelTimeout won't be affected by the 5-second timeout\n\t\tCancelTimeout().\n\n\t\t// Set a 10-second timeout for all chained methods\n\t\tTimeout(10 * time.Second).\n\n\t\t// Panics if it takes more than 10 seconds\n\t\tMustText()\n\n\t// The two code blocks below are basically the same:\n\t{\n\t\tpage.Timeout(5 * time.Second).MustElement(\"a\").CancelTimeout()\n\t}\n\t{\n\t\t// Use this way you can customize your own way to cancel long-running task\n\t\tpage, cancel := page.WithCancel()\n\t\tgo func() {\n\t\t\ttime.Sleep(time.Duration(rand.Int())) // cancel after randomly time\n\t\t\tcancel()\n\t\t}()\n\t\tpage.MustElement(\"a\")\n\t}\n}\n\nfunc Example_context_and_EachEvent() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://github.com\").MustWaitLoad()\n\n\tpage, cancel := page.WithCancel()\n\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\tcancel()\n\t}()\n\n\t// It's a blocking method, it will wait until the context is cancelled\n\tpage.EachEvent(func(_ *proto.PageLifecycleEvent) {})()\n\n\tif page.GetContext().Err() == context.Canceled {\n\t\tfmt.Println(\"cancelled\")\n\t}\n}\n\n// We use \"Must\" prefixed functions to write example code. But in production you may want to use\n// the no-prefix version of them.\n// About why we use \"Must\" as the prefix, it's similar to https://golang.org/pkg/regexp/#MustCompile\nfunc Example_error_handling() {\n\tpage := rod.New().MustConnect().MustPage(\"https://mdn.dev\")\n\n\t// We use Go's standard way to check error types, no magic.\n\tcheck := func(err error) {\n\t\tvar evalErr *rod.EvalError\n\t\tif errors.Is(err, context.DeadlineExceeded) { // timeout error\n\t\t\tfmt.Println(\"timeout err\")\n\t\t} else if errors.As(err, &evalErr) { // eval error\n\t\t\tfmt.Println(evalErr.LineNumber)\n\t\t} else if err != nil {\n\t\t\tfmt.Println(\"can't handle\", err)\n\t\t}\n\t}\n\n\t// The two code blocks below are doing the same thing in two styles:\n\n\t// The block below is better for debugging or quick scripting. We use panic to short-circuit logics.\n\t// So that we can take advantage of fluent interface (https://en.wikipedia.org/wiki/Fluent_interface)\n\t// and fail-fast (https://en.wikipedia.org/wiki/Fail-fast).\n\t// This style will reduce code, but it may also catch extra errors (less consistent and precise).\n\t{\n\t\terr := rod.Try(func() {\n\t\t\tfmt.Println(page.MustElement(\"a\").MustHTML()) // use \"Must\" prefixed functions\n\t\t})\n\t\tcheck(err)\n\t}\n\n\t// The block below is better for production code. It's the standard way to handle errors.\n\t// Usually, this style is more consistent and precise.\n\t{\n\t\tel, err := page.Element(\"a\")\n\t\tif err != nil {\n\t\t\tcheck(err)\n\t\t\treturn\n\t\t}\n\t\thtml, err := el.HTML()\n\t\tif err != nil {\n\t\t\tcheck(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(html)\n\t}\n}\n\n// Example_search shows how to use Search to get element inside nested iframes or shadow DOMs.\n// It works the same as https://developers.google.com/web/tools/chrome-devtools/dom#search\nfunc Example_search() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe\")\n\n\t// Click the zoom-in button of the OpenStreetMap\n\tpage.MustSearch(\".leaflet-control-zoom-in\").MustClick()\n\n\tfmt.Println(\"done\")\n\n\t// Output: done\n}\n\nfunc Example_page_screenshot() {\n\tpage := rod.New().MustConnect().MustPage(\"https://github.com\").MustWaitLoad()\n\n\t// simple version\n\tpage.MustScreenshot(\"my.png\")\n\n\t// customization version\n\timg, _ := page.Screenshot(true, &proto.PageCaptureScreenshot{\n\t\tFormat:  proto.PageCaptureScreenshotFormatJpeg,\n\t\tQuality: gson.Int(90),\n\t\tClip: &proto.PageViewport{\n\t\t\tX:      0,\n\t\t\tY:      0,\n\t\t\tWidth:  300,\n\t\t\tHeight: 200,\n\t\t\tScale:  1,\n\t\t},\n\t\tFromSurface: true,\n\t})\n\t_ = utils.OutputFile(\"my.jpg\", img)\n}\n\nfunc Example_page_scroll_screenshot() {\n\tbrowser := rod.New().MustConnect()\n\n\t// capture entire browser viewport, returning jpg with quality=90\n\timg, err := browser.MustPage(\"https://desktop.github.com/\").MustWaitStable().ScrollScreenshot(&rod.ScrollScreenshotOptions{\n\t\tFormat:  proto.PageCaptureScreenshotFormatJpeg,\n\t\tQuality: gson.Int(90),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_ = utils.OutputFile(\"my.jpg\", img)\n}\n\nfunc Example_page_pdf() {\n\tpage := rod.New().MustConnect().MustPage(\"https://github.com\").MustWaitLoad()\n\n\t// simple version\n\tpage.MustPDF(\"my.pdf\")\n\n\t// customized version\n\tpdf, _ := page.PDF(&proto.PagePrintToPDF{\n\t\tPaperWidth:  gson.Num(8.5),\n\t\tPaperHeight: gson.Num(11),\n\t\tPageRanges:  \"1-3\",\n\t})\n\t_ = utils.OutputFile(\"my.pdf\", pdf)\n}\n\n// Show how to handle multiple results of an action.\n// Such as when you login a page, the result can be success or wrong password.\nfunc Example_race_selectors() {\n\tconst username = \"\"\n\tconst password = \"\"\n\n\tbrowser := rod.New().MustConnect()\n\n\tpage := browser.MustPage(\"https://leetcode.com/accounts/login/\")\n\n\tpage.MustElement(\"#id_login\").MustInput(username)\n\tpage.MustElement(\"#id_password\").MustInput(password).MustType(input.Enter)\n\n\t// It will keep retrying until one selector has found a match\n\telm := page.Race().Element(\".nav-user-icon-base\").MustHandle(func(e *rod.Element) {\n\t\t// print the username after successful login\n\t\tfmt.Println(*e.MustAttribute(\"title\"))\n\t}).Element(\"[data-cy=sign-in-error]\").MustDo()\n\n\tif elm.MustMatches(\"[data-cy=sign-in-error]\") {\n\t\t// when wrong username or password\n\t\tpanic(elm.MustText())\n\t}\n}\n\n// Rod uses mouse cursor to simulate clicks, so if a button is moving because of animation, the click may not work as expected.\n// We usually use WaitStable to make sure the target isn't changing anymore.\nfunc Example_wait_for_animation() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://getbootstrap.com/docs/4.0/components/modal/\")\n\n\tpage.MustWaitLoad().MustElement(\"[data-target='#exampleModalLive']\").MustClick()\n\n\tsaveBtn := page.MustElementR(\"#exampleModalLive button\", \"Close\")\n\n\t// Here, WaitStable will wait until the button's position and size become stable.\n\tsaveBtn.MustWaitStable().MustClick().MustWaitInvisible()\n\n\tfmt.Println(\"done\")\n\n\t// Output: done\n}\n\n// When you want to wait for an ajax request to complete, this example will be useful.\nfunc Example_wait_for_request() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://www.wikipedia.org/\").MustWaitLoad()\n\n\t// Start to analyze request events\n\twait := page.MustWaitRequestIdle()\n\n\t// This will trigger the search ajax request\n\tpage.MustElement(\"#searchInput\").MustClick().MustInput(\"lisp\")\n\n\t// Wait until there's no active requests\n\twait()\n\n\t// We want to make sure that after waiting, there are some autocomplete\n\t// suggestions available.\n\tfmt.Println(len(page.MustElements(\".suggestion-link\")) > 0)\n\n\t// Output: true\n}\n\n// Shows how to change the retry/polling options that is used to query elements.\n// This is useful when you want to customize the element query retry logic.\nfunc Example_customize_retry_strategy() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage(\"https://github.com\")\n\n\t// sleep for 0.5 seconds before every retry\n\tsleeper := func() utils.Sleeper {\n\t\treturn func(context.Context) error {\n\t\t\ttime.Sleep(time.Second / 2)\n\t\t\treturn nil\n\t\t}\n\t}\n\tel, _ := page.Sleeper(sleeper).Element(\"input\")\n\tfmt.Println(el.MustProperty(\"name\"))\n\n\t// If sleeper is nil page.ElementE will query without retrying.\n\t// If nothing found it will return an error.\n\tel, err := page.Sleeper(rod.NotFoundSleeper).Element(\"input\")\n\tif errors.Is(err, &rod.ElementNotFoundError{}) {\n\t\tfmt.Println(\"element not found\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(el.MustProperty(\"name\"))\n\n\t// Output:\n\t// type\n\t// type\n}\n\n// Shows how we can further customize the browser with the launcher library.\n// Usually you use launcher lib to set the browser's command line flags (switches).\n// Doc for flags: https://peter.sh/experiments/chromium-command-line-switches\nfunc Example_customize_browser_launch() {\n\turl := launcher.New().\n\t\tProxy(\"127.0.0.1:8080\").     // set flag \"--proxy-server=127.0.0.1:8080\"\n\t\tDelete(\"use-mock-keychain\"). // delete flag \"--use-mock-keychain\"\n\t\tMustLaunch()\n\n\tbrowser := rod.New().ControlURL(url).MustConnect()\n\tdefer browser.MustClose()\n\n\t// So that we don't have to self issue certs for MITM\n\tbrowser.MustIgnoreCertErrors(true)\n\n\t// Adding authentication to the proxy, for the next auth request.\n\t// We use CLI tool \"mitmproxy --proxyauth user:pass\" as an example.\n\tgo browser.MustHandleAuth(\"user\", \"pass\")()\n\n\t// mitmproxy needs a cert config to support https. We use http here instead,\n\t// for example\n\tfmt.Println(browser.MustPage(\"https://mdn.dev/\").MustElement(\"title\").MustText())\n}\n\n// When rod doesn't have a feature that you need. You can easily call the cdp to achieve it.\n// List of cdp API: https://github.com/go-rod/rod/tree/main/lib/proto\nfunc Example_direct_cdp() {\n\tpage := rod.New().MustConnect().MustPage()\n\n\t// Rod doesn't have a method to enable AD blocking,\n\t// but you can call cdp interface directly to achieve it.\n\n\t// The two code blocks below are equal to enable AD blocking\n\n\t{\n\t\t_ = proto.PageSetAdBlockingEnabled{\n\t\t\tEnabled: true,\n\t\t}.Call(page)\n\t}\n\n\t{\n\t\t// Interact with the cdp JSON API directly\n\t\t_, _ = page.Call(context.TODO(), \"\", \"Page.setAdBlockingEnabled\", map[string]bool{\n\t\t\t\"enabled\": true,\n\t\t})\n\t}\n}\n\n// Shows how to listen for events.\nfunc Example_handle_events() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage()\n\n\tdone := make(chan struct{})\n\n\t// Listen for all events of console output.\n\tgo page.EachEvent(func(e *proto.RuntimeConsoleAPICalled) {\n\t\tif e.Type == proto.RuntimeConsoleAPICalledTypeLog {\n\t\t\tfmt.Println(page.MustObjectsToJSON(e.Args))\n\t\t\tclose(done)\n\t\t}\n\t})()\n\n\twait := page.WaitEvent(&proto.PageLoadEventFired{})\n\tpage.MustNavigate(\"https://mdn.dev\")\n\twait()\n\n\t// EachEvent allows us to achieve the same functionality as above.\n\tif false {\n\t\t// Subscribe events before they happen, run the \"wait()\" to start consuming\n\t\t// the events. We can return an optional stop signal to unsubscribe events.\n\t\twait := page.EachEvent(func(_ *proto.PageLoadEventFired) (stop bool) {\n\t\t\treturn true\n\t\t})\n\t\tpage.MustNavigate(\"https://mdn.dev\")\n\t\twait()\n\t}\n\n\t// Or the for-loop style to handle events to do the same thing above.\n\tif false {\n\t\tpage.MustNavigate(\"https://mdn.dev\")\n\n\t\tfor msg := range page.Event() {\n\t\t\te := proto.PageLoadEventFired{}\n\t\t\tif msg.Load(&e) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tpage.MustEval(`() => console.log(\"hello\", \"world\")`)\n\n\t<-done\n\n\t// Output:\n\t// [hello world]\n}\n\nfunc Example_download_file() {\n\tbrowser := rod.New().MustConnect()\n\tpage := browser.MustPage(\"https://file-examples.com/index.php/sample-documents-download/sample-pdf-download/\")\n\n\twait := browser.MustWaitDownload()\n\n\tpage.MustElementR(\"a\", \"DOWNLOAD SAMPLE PDF FILE\").MustClick()\n\n\t_ = utils.OutputFile(\"t.pdf\", wait())\n}\n\n// Shows how to intercept requests and modify\n// both the request and the response.\n// The entire process of hijacking one request:\n//\n//\tbrowser --req-> rod ---> server ---> rod --res-> browser\n//\n// The --req-> and --res-> are the parts that can be modified.\nfunc Example_hijack_requests() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\trouter := browser.HijackRequests()\n\tdefer router.MustStop()\n\n\trouter.MustAdd(\"*.js\", func(ctx *rod.Hijack) {\n\t\t// Here we update the request's header. Rod gives functionality to\n\t\t// change or update all parts of the request. Refer to the documentation\n\t\t// for more information.\n\t\tctx.Request.Req().Header.Set(\"My-Header\", \"test\")\n\n\t\t// LoadResponse runs the default request to the destination of the request.\n\t\t// Not calling this will require you to mock the entire response.\n\t\t// This can be done with the SetXxx (Status, Header, Body) functions on the\n\t\t// ctx.Response struct.\n\t\t_ = ctx.LoadResponse(http.DefaultClient, true)\n\n\t\t// Here we append some code to every js file.\n\t\t// The code will update the document title to \"hi\"\n\t\tctx.Response.SetBody(ctx.Response.Body() + \"\\n document.title = 'hi' \")\n\t})\n\n\tgo router.Run()\n\n\tbrowser.MustPage(\"https://go-rod.github.io\").MustWait(`() => document.title === 'hi'`)\n\n\tfmt.Println(\"done\")\n\n\t// Output: done\n}\n\n// Shows how to share a remote object reference between two Eval.\nfunc Example_eval_reuse_remote_object() {\n\tpage := rod.New().MustConnect().MustPage()\n\n\tfn := page.MustEvaluate(rod.Eval(`() => Math.random`).ByObject())\n\n\tres := page.MustEval(`f => f()`, fn)\n\n\t// print a random number\n\tfmt.Println(res.Num())\n}\n\n// Shows how to update the state of the current page.\n// In this example we enable the network domain.\nfunc Example_states() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\tpage := browser.MustPage()\n\n\t// LoadState detects whether the network domain is enabled or not.\n\tfmt.Println(page.LoadState(&proto.NetworkEnable{}))\n\n\t_ = proto.NetworkEnable{}.Call(page)\n\n\t// Check if the network domain is successfully enabled.\n\tfmt.Println(page.LoadState(&proto.NetworkEnable{}))\n\n\t// Output:\n\t// false\n\t// true\n}\n\n// We can use [rod.PagePool] to concurrently control and reuse pages.\nfunc ExamplePage_pool() {\n\tbrowser := rod.New().MustConnect()\n\tdefer browser.MustClose()\n\n\t// We create a pool that will hold at most 3 pages which means the max concurrency is 3\n\tpool := rod.NewPagePool(3)\n\n\t// Create a page if needed\n\tcreate := func() *rod.Page {\n\t\t// We use MustIncognito to isolate pages with each other\n\t\treturn browser.MustIncognito().MustPage()\n\t}\n\n\tyourJob := func() {\n\t\tpage := pool.MustGet(create)\n\n\t\t// Put the instance back to the pool after we're done,\n\t\t// so the instance can be reused by other goroutines.\n\t\tdefer pool.Put(page)\n\n\t\tpage.MustNavigate(\"http://mdn.dev\").MustWaitLoad()\n\t\tfmt.Println(page.MustInfo().Title)\n\t}\n\n\t// Run jobs concurrently\n\twg := sync.WaitGroup{}\n\tfor range \"....\" {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tyourJob()\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// cleanup pool\n\tpool.Cleanup(func(p *rod.Page) { p.MustClose() })\n\n\t// Output:\n\t// MDN Web Docs\n\t// MDN Web Docs\n\t// MDN Web Docs\n\t// MDN Web Docs\n}\n\n// We can use [rod.BrowserPool] to concurrently control and reuse browsers.\nfunc ExampleBrowser_pool() {\n\t// Create a new browser pool with a limit of 3\n\tpool := rod.NewBrowserPool(3)\n\n\t// Create a function that returns a new browser instance\n\tcreate := func() *rod.Browser {\n\t\tbrowser := rod.New().MustConnect()\n\t\treturn browser\n\t}\n\n\t// Use the browser instances in separate goroutines\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 3; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Get a browser instance from the pool\n\t\t\tbrowser := pool.MustGet(create)\n\n\t\t\t// Put the instance back to the pool after we're done,\n\t\t\t// so the instance can be reused by other goroutines.\n\t\t\tdefer pool.Put(browser)\n\n\t\t\t// Use the browser instance\n\t\t\tpage := browser.MustPage(\"https://www.google.com\")\n\t\t\tfmt.Println(page.MustInfo().Title)\n\t\t}()\n\t}\n\n\t// Wait for all the goroutines to finish\n\twg.Wait()\n\n\t// Cleanup the pool by closing all the browser instances\n\tpool.Cleanup(func(p *rod.Browser) {\n\t\tp.MustClose()\n\t})\n}\n\nfunc Example_load_extension() {\n\textPath, _ := filepath.Abs(\"fixtures/chrome-extension\")\n\n\tu := launcher.New().\n\t\t// Must use abs path for an extension\n\t\tSet(\"load-extension\", extPath).\n\t\t// Headless mode doesn't support extension yet.\n\t\t// Reason: https://bugs.chromium.org/p/chromium/issues/detail?id=706008#c5\n\t\t// You can use XVFB to get rid of it: https://github.com/go-rod/rod/blob/main/lib/examples/launch-managed/main.go\n\t\tHeadless(false).\n\t\tMustLaunch()\n\n\tpage := rod.New().ControlURL(u).MustConnect().MustPage(\"http://mdn.dev\")\n\n\tpage.MustWait(`() => document.title === 'test-extension'`)\n\n\tfmt.Println(\"ok\")\n\n\t// Skip\n\t// Output: ok\n}\n\nfunc Example_log_cdp_traffic() {\n\tcdp := cdp.New().\n\t\t// Here we can customize how to log the requests, responses, and events transferred between Rod and the browser.\n\t\tLogger(utils.Log(func(args ...interface{}) {\n\t\t\tswitch v := args[0].(type) {\n\t\t\tcase *cdp.Request:\n\t\t\t\tfmt.Printf(\"id: %d\", v.ID)\n\t\t\t}\n\t\t})).\n\t\tStart(cdp.MustConnectWS(launcher.New().MustLaunch()))\n\n\trod.New().Client(cdp).MustConnect().MustPage(\"http://mdn.dev\")\n}\n"
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2900390625,
          "content": "module github.com/go-rod/rod\n\ngo 1.21\n\nrequire (\n\tgithub.com/ysmood/fetchup v0.2.3\n\tgithub.com/ysmood/goob v0.4.0\n\tgithub.com/ysmood/got v0.40.0\n\tgithub.com/ysmood/gotrace v0.6.0\n\tgithub.com/ysmood/gson v0.7.3\n\tgithub.com/ysmood/leakless v0.9.0\n)\n\nrequire github.com/ysmood/gop v0.2.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1318359375,
          "content": "github.com/ysmood/fetchup v0.2.3 h1:ulX+SonA0Vma5zUFXtv52Kzip/xe7aj4vqT5AJwQ+ZQ=\ngithub.com/ysmood/fetchup v0.2.3/go.mod h1:xhibcRKziSvol0H1/pj33dnKrYyI2ebIvz5cOOkYGns=\ngithub.com/ysmood/goob v0.4.0 h1:HsxXhyLBeGzWXnqVKtmT9qM7EuVs/XOgkX7T6r1o1AQ=\ngithub.com/ysmood/goob v0.4.0/go.mod h1:u6yx7ZhS4Exf2MwciFr6nIM8knHQIE22lFpWHnfql18=\ngithub.com/ysmood/gop v0.2.0 h1:+tFrG0TWPxT6p9ZaZs+VY+opCvHU8/3Fk6BaNv6kqKg=\ngithub.com/ysmood/gop v0.2.0/go.mod h1:rr5z2z27oGEbyB787hpEcx4ab8cCiPnKxn0SUHt6xzk=\ngithub.com/ysmood/got v0.40.0 h1:ZQk1B55zIvS7zflRrkGfPDrPG3d7+JOza1ZkNxcc74Q=\ngithub.com/ysmood/got v0.40.0/go.mod h1:W7DdpuX6skL3NszLmAsC5hT7JAhuLZhByVzHTq874Qg=\ngithub.com/ysmood/gotrace v0.6.0 h1:SyI1d4jclswLhg7SWTL6os3L1WOKeNn/ZtzVQF8QmdY=\ngithub.com/ysmood/gotrace v0.6.0/go.mod h1:TzhIG7nHDry5//eYZDYcTzuJLYQIkykJzCRIo4/dzQM=\ngithub.com/ysmood/gson v0.7.3 h1:QFkWbTH8MxyUTKPkVWAENJhxqdBa4lYTQWqZCiLG6kE=\ngithub.com/ysmood/gson v0.7.3/go.mod h1:3Kzs5zDl21g5F/BlLTNcuAGAYLKt2lV5G8D1zF3RNmg=\ngithub.com/ysmood/leakless v0.9.0 h1:qxCG5VirSBvmi3uynXFkcnLMzkphdh3xx5FtrORwDCU=\ngithub.com/ysmood/leakless v0.9.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=\n"
        },
        {
          "name": "go.work",
          "type": "blob",
          "size": 0.103515625,
          "content": "go 1.22\n\nuse (\n\t.\n\t./lib/examples/custom-websocket\n\t./lib/examples/e2e-testing\n\t./lib/utils/check-issue\n)\n"
        },
        {
          "name": "go.work.sum",
          "type": "blob",
          "size": 0.32421875,
          "content": "github.com/ysmood/fetchup v0.2.1 h1:n/NgIx92KOXFiKAhK3d+LlKpl8JuSjh5U27ULmHKtag=\ngithub.com/ysmood/fetchup v0.2.1/go.mod h1:94ROLWpn5fmCD4LPlcZ+LOE/iE/kRTU3kL+0ue/V+Os=\ngithub.com/ysmood/got v0.33.2 h1:mz0PaCMzR//YBtDDkDf6z0O09SfotXBHzw3zLrrS2sw=\ngithub.com/ysmood/got v0.33.2/go.mod h1:P3C/Wwttv4uq/tpovaH+c8ANmHePyFPxEbNzdxcEGDU=\n"
        },
        {
          "name": "hijack.go",
          "type": "blob",
          "size": 10.83203125,
          "content": "package rod\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// HijackRequests same as Page.HijackRequests, but can intercept requests of the entire browser.\nfunc (b *Browser) HijackRequests() *HijackRouter {\n\treturn newHijackRouter(b, b).initEvents()\n}\n\n// HijackRequests creates a new router instance for requests hijacking.\n// When use Fetch domain outside the router should be stopped. Enabling hijacking disables page caching,\n// but such as 304 Not Modified will still work as expected.\n// The entire process of hijacking one request:\n//\n//\tbrowser --req-> rod ---> server ---> rod --res-> browser\n//\n// The --req-> and --res-> are the parts that can be modified.\nfunc (p *Page) HijackRequests() *HijackRouter {\n\treturn newHijackRouter(p.browser, p).initEvents()\n}\n\n// HijackRouter context.\ntype HijackRouter struct {\n\trun      func()\n\tstop     func()\n\thandlers []*hijackHandler\n\tenable   *proto.FetchEnable\n\tclient   proto.Client\n\tbrowser  *Browser\n}\n\nfunc newHijackRouter(browser *Browser, client proto.Client) *HijackRouter {\n\treturn &HijackRouter{\n\t\tenable:   &proto.FetchEnable{},\n\t\tbrowser:  browser,\n\t\tclient:   client,\n\t\thandlers: []*hijackHandler{},\n\t}\n}\n\nfunc (r *HijackRouter) initEvents() *HijackRouter { //nolint: gocognit\n\tctx := r.browser.ctx\n\tif cta, ok := r.client.(proto.Contextable); ok {\n\t\tctx = cta.GetContext()\n\t}\n\n\tvar sessionID proto.TargetSessionID\n\tif tsa, ok := r.client.(proto.Sessionable); ok {\n\t\tsessionID = tsa.GetSessionID()\n\t}\n\n\teventCtx, cancel := context.WithCancel(ctx)\n\tr.stop = cancel\n\n\t_ = r.enable.Call(r.client)\n\n\tr.run = r.browser.Context(eventCtx).eachEvent(sessionID, func(e *proto.FetchRequestPaused) bool {\n\t\tgo func() {\n\t\t\tctx := r.new(eventCtx, e)\n\t\t\tfor _, h := range r.handlers {\n\t\t\t\tif !h.regexp.MatchString(e.Request.URL) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\th.handler(ctx)\n\n\t\t\t\tif ctx.continueRequest != nil {\n\t\t\t\t\tctx.continueRequest.RequestID = e.RequestID\n\t\t\t\t\terr := ctx.continueRequest.Call(r.client)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tctx.OnError(err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif ctx.Skip {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif ctx.Response.fail.ErrorReason != \"\" {\n\t\t\t\t\terr := ctx.Response.fail.Call(r.client)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tctx.OnError(err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\terr := ctx.Response.payload.Call(r.client)\n\t\t\t\tif err != nil {\n\t\t\t\t\tctx.OnError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\treturn false\n\t})\n\treturn r\n}\n\n// Add a hijack handler to router, the doc of the pattern is the same as \"proto.FetchRequestPattern.URLPattern\".\nfunc (r *HijackRouter) Add(pattern string, resourceType proto.NetworkResourceType, handler func(*Hijack)) error {\n\tr.enable.Patterns = append(r.enable.Patterns, &proto.FetchRequestPattern{\n\t\tURLPattern:   pattern,\n\t\tResourceType: resourceType,\n\t})\n\n\treg := regexp.MustCompile(proto.PatternToReg(pattern))\n\n\tr.handlers = append(r.handlers, &hijackHandler{\n\t\tpattern: pattern,\n\t\tregexp:  reg,\n\t\thandler: handler,\n\t})\n\n\treturn r.enable.Call(r.client)\n}\n\n// Remove handler via the pattern.\nfunc (r *HijackRouter) Remove(pattern string) error {\n\tpatterns := []*proto.FetchRequestPattern{}\n\thandlers := []*hijackHandler{}\n\tfor _, h := range r.handlers {\n\t\tif h.pattern != pattern {\n\t\t\tpatterns = append(patterns, &proto.FetchRequestPattern{URLPattern: h.pattern})\n\t\t\thandlers = append(handlers, h)\n\t\t}\n\t}\n\tr.enable.Patterns = patterns\n\tr.handlers = handlers\n\n\treturn r.enable.Call(r.client)\n}\n\n// new context.\nfunc (r *HijackRouter) new(ctx context.Context, e *proto.FetchRequestPaused) *Hijack {\n\theaders := http.Header{}\n\tfor k, v := range e.Request.Headers {\n\t\theaders[k] = []string{v.String()}\n\t}\n\n\tu, _ := url.Parse(e.Request.URL)\n\n\treq := &http.Request{\n\t\tMethod: e.Request.Method,\n\t\tURL:    u,\n\t\tBody:   io.NopCloser(strings.NewReader(e.Request.PostData)),\n\t\tHeader: headers,\n\t}\n\n\treturn &Hijack{\n\t\tRequest: &HijackRequest{\n\t\t\tevent: e,\n\t\t\treq:   req.WithContext(ctx),\n\t\t},\n\t\tResponse: &HijackResponse{\n\t\t\tpayload: &proto.FetchFulfillRequest{\n\t\t\t\tResponseCode: 200,\n\t\t\t\tRequestID:    e.RequestID,\n\t\t\t},\n\t\t\tfail: &proto.FetchFailRequest{\n\t\t\t\tRequestID: e.RequestID,\n\t\t\t},\n\t\t},\n\t\tOnError: func(_ error) {},\n\n\t\tbrowser: r.browser,\n\t}\n}\n\n// Run the router, after you call it, you shouldn't add new handler to it.\nfunc (r *HijackRouter) Run() {\n\tr.run()\n}\n\n// Stop the router.\nfunc (r *HijackRouter) Stop() error {\n\tr.stop()\n\treturn proto.FetchDisable{}.Call(r.client)\n}\n\n// hijackHandler to handle each request that match the regexp.\ntype hijackHandler struct {\n\tpattern string\n\tregexp  *regexp.Regexp\n\thandler func(*Hijack)\n}\n\n// Hijack context.\ntype Hijack struct {\n\tRequest  *HijackRequest\n\tResponse *HijackResponse\n\tOnError  func(error)\n\n\t// Skip to next handler\n\tSkip bool\n\n\tcontinueRequest *proto.FetchContinueRequest\n\n\t// CustomState is used to store things for this context\n\tCustomState interface{}\n\n\tbrowser *Browser\n}\n\n// ContinueRequest without hijacking. The RequestID will be set by the router, you don't have to set it.\nfunc (h *Hijack) ContinueRequest(cq *proto.FetchContinueRequest) {\n\th.continueRequest = cq\n}\n\n// LoadResponse will send request to the real destination and load the response as default response to override.\nfunc (h *Hijack) LoadResponse(client *http.Client, loadBody bool) error {\n\tres, err := client.Do(h.Request.req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() { _ = res.Body.Close() }()\n\n\th.Response.payload.ResponseCode = res.StatusCode\n\th.Response.RawResponse = res\n\n\tfor k, vs := range res.Header {\n\t\tfor _, v := range vs {\n\t\t\th.Response.SetHeader(k, v)\n\t\t}\n\t}\n\n\tif loadBody {\n\t\tb, err := io.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\th.Response.payload.Body = b\n\t}\n\n\treturn nil\n}\n\n// HijackRequest context.\ntype HijackRequest struct {\n\tevent *proto.FetchRequestPaused\n\treq   *http.Request\n}\n\n// Type of the resource.\nfunc (ctx *HijackRequest) Type() proto.NetworkResourceType {\n\treturn ctx.event.ResourceType\n}\n\n// Method of the request.\nfunc (ctx *HijackRequest) Method() string {\n\treturn ctx.event.Request.Method\n}\n\n// URL of the request.\nfunc (ctx *HijackRequest) URL() *url.URL {\n\tu, _ := url.Parse(ctx.event.Request.URL)\n\treturn u\n}\n\n// Header via a key.\nfunc (ctx *HijackRequest) Header(key string) string {\n\treturn ctx.event.Request.Headers[key].String()\n}\n\n// Headers of request.\nfunc (ctx *HijackRequest) Headers() proto.NetworkHeaders {\n\treturn ctx.event.Request.Headers\n}\n\n// Body of the request, devtools API doesn't support binary data yet, only string can be captured.\nfunc (ctx *HijackRequest) Body() string {\n\treturn ctx.event.Request.PostData\n}\n\n// JSONBody of the request.\nfunc (ctx *HijackRequest) JSONBody() gson.JSON {\n\treturn gson.NewFrom(ctx.Body())\n}\n\n// Req returns the underlying http.Request instance that will be used to send the request.\nfunc (ctx *HijackRequest) Req() *http.Request {\n\treturn ctx.req\n}\n\n// SetContext of the underlying http.Request instance.\nfunc (ctx *HijackRequest) SetContext(c context.Context) *HijackRequest {\n\tctx.req = ctx.req.WithContext(c)\n\treturn ctx\n}\n\n// SetBody of the request, if obj is []byte or string, raw body will be used, else it will be encoded as json.\nfunc (ctx *HijackRequest) SetBody(obj interface{}) *HijackRequest {\n\tvar b []byte\n\n\tswitch body := obj.(type) {\n\tcase []byte:\n\t\tb = body\n\tcase string:\n\t\tb = []byte(body)\n\tdefault:\n\t\tb = utils.MustToJSONBytes(body)\n\t}\n\n\tctx.req.Body = io.NopCloser(bytes.NewBuffer(b))\n\n\treturn ctx\n}\n\n// IsNavigation determines whether the request is a navigation request.\nfunc (ctx *HijackRequest) IsNavigation() bool {\n\treturn ctx.Type() == proto.NetworkResourceTypeDocument\n}\n\n// HijackResponse context.\ntype HijackResponse struct {\n\tpayload     *proto.FetchFulfillRequest\n\tRawResponse *http.Response\n\tfail        *proto.FetchFailRequest\n}\n\n// Payload to respond the request from the browser.\nfunc (ctx *HijackResponse) Payload() *proto.FetchFulfillRequest {\n\treturn ctx.payload\n}\n\n// Body of the payload.\nfunc (ctx *HijackResponse) Body() string {\n\treturn string(ctx.payload.Body)\n}\n\n// Headers returns the clone of response headers.\n// If you want to modify the response headers use HijackResponse.SetHeader .\nfunc (ctx *HijackResponse) Headers() http.Header {\n\theader := http.Header{}\n\n\tfor _, h := range ctx.payload.ResponseHeaders {\n\t\theader.Add(h.Name, h.Value)\n\t}\n\n\treturn header\n}\n\n// SetHeader of the payload via key-value pairs.\nfunc (ctx *HijackResponse) SetHeader(pairs ...string) *HijackResponse {\n\theaderIndex := make(map[string]int, len(ctx.payload.ResponseHeaders))\n\tfor i, header := range ctx.payload.ResponseHeaders {\n\t\theaderIndex[header.Name] = i\n\t}\n\n\tfor i := 0; i < len(pairs); i += 2 {\n\t\tname := pairs[i]\n\t\tvalue := pairs[i+1]\n\n\t\tif idx, exists := headerIndex[name]; exists {\n\t\t\tctx.payload.ResponseHeaders[idx].Value = value\n\t\t} else {\n\t\t\tctx.payload.ResponseHeaders = append(ctx.payload.ResponseHeaders, &proto.FetchHeaderEntry{\n\t\t\t\tName:  name,\n\t\t\t\tValue: value,\n\t\t\t})\n\t\t\theaderIndex[name] = len(ctx.payload.ResponseHeaders) - 1\n\t\t}\n\t}\n\treturn ctx\n}\n\n// AddHeader appends key-value pairs to the end of the response headers.\n// Duplicate keys will be preserved.\nfunc (ctx *HijackResponse) AddHeader(pairs ...string) *HijackResponse {\n\tfor i := 0; i < len(pairs); i += 2 {\n\t\tctx.payload.ResponseHeaders = append(ctx.payload.ResponseHeaders, &proto.FetchHeaderEntry{\n\t\t\tName:  pairs[i],\n\t\t\tValue: pairs[i+1],\n\t\t})\n\t}\n\treturn ctx\n}\n\n// SetBody of the payload, if obj is []byte or string, raw body will be used, else it will be encoded as json.\nfunc (ctx *HijackResponse) SetBody(obj interface{}) *HijackResponse {\n\tswitch body := obj.(type) {\n\tcase []byte:\n\t\tctx.payload.Body = body\n\tcase string:\n\t\tctx.payload.Body = []byte(body)\n\tdefault:\n\t\tctx.payload.Body = utils.MustToJSONBytes(body)\n\t}\n\treturn ctx\n}\n\n// Fail request.\nfunc (ctx *HijackResponse) Fail(reason proto.NetworkErrorReason) *HijackResponse {\n\tctx.fail.ErrorReason = reason\n\treturn ctx\n}\n\n// HandleAuth for the next basic HTTP authentication.\n// It will prevent the popup that requires user to input user name and password.\n// Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\nfunc (b *Browser) HandleAuth(username, password string) func() error {\n\tenable := b.DisableDomain(\"\", &proto.FetchEnable{})\n\tdisable := b.EnableDomain(\"\", &proto.FetchEnable{\n\t\tHandleAuthRequests: true,\n\t})\n\n\tpaused := &proto.FetchRequestPaused{}\n\tauth := &proto.FetchAuthRequired{}\n\n\tctx, cancel := context.WithCancel(b.ctx)\n\twaitPaused := b.Context(ctx).WaitEvent(paused)\n\twaitAuth := b.Context(ctx).WaitEvent(auth)\n\n\treturn func() (err error) {\n\t\tdefer enable()\n\t\tdefer disable()\n\t\tdefer cancel()\n\n\t\twaitPaused()\n\n\t\terr = proto.FetchContinueRequest{\n\t\t\tRequestID: paused.RequestID,\n\t\t}.Call(b)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\twaitAuth()\n\n\t\terr = proto.FetchContinueWithAuth{\n\t\t\tRequestID: auth.RequestID,\n\t\t\tAuthChallengeResponse: &proto.FetchAuthChallengeResponse{\n\t\t\t\tResponse: proto.FetchAuthChallengeResponseResponseProvideCredentials,\n\t\t\t\tUsername: username,\n\t\t\t\tPassword: password,\n\t\t\t},\n\t\t}.Call(b)\n\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "hijack_test.go",
          "type": "blob",
          "size": 8.279296875,
          "content": "package rod_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestHijack(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\t// to simulate a backend server\n\ts.Route(\"/\", slash(\"fixtures/fetch.html\"))\n\ts.Mux.HandleFunc(\"/a\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\tpanic(\"wrong http method\")\n\t\t}\n\n\t\tg.Eq(\"header\", r.Header.Get(\"Test\"))\n\n\t\tb, err := io.ReadAll(r.Body)\n\t\tg.E(err)\n\t\tg.Eq(\"a\", string(b))\n\n\t\tg.HandleHTTP(\".html\", \"test\")(w, r)\n\t})\n\ts.Route(\"/b\", \"\", \"b\")\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tr := ctx.Request.SetContext(g.Context())\n\t\tr.Req().Header.Set(\"Test\", \"header\") // override request header\n\t\tr.SetBody([]byte(\"test\"))            // override request body\n\t\tr.SetBody(123)                       // override request body\n\t\tr.SetBody(r.Body())                  // override request body\n\n\t\ttype MyState struct {\n\t\t\tVal int\n\t\t}\n\n\t\tctx.CustomState = &MyState{10}\n\n\t\tg.Eq(http.MethodPost, r.Method())\n\t\tg.Eq(s.URL(\"/a\"), r.URL().String())\n\n\t\tg.Eq(proto.NetworkResourceTypeXHR, ctx.Request.Type())\n\t\tg.Is(ctx.Request.IsNavigation(), false)\n\t\tg.Has(s.URL(), ctx.Request.Header(\"Origin\"))\n\t\tg.Len(ctx.Request.Headers(), 6)\n\t\tg.True(ctx.Request.JSONBody().Nil())\n\n\t\t// send request load response from real destination as the default value to hijack\n\t\tctx.MustLoadResponse()\n\n\t\tg.Eq(200, ctx.Response.Payload().ResponseCode)\n\n\t\t// override status code\n\t\tctx.Response.Payload().ResponseCode = http.StatusCreated\n\n\t\tg.Eq(\"4\", ctx.Response.Headers().Get(\"Content-Length\"))\n\t\tg.Has(ctx.Response.Headers().Get(\"Content-Type\"), \"text/html; charset=utf-8\")\n\n\t\t// override response header\n\t\tctx.Response.AddHeader(\"Set-Cookie\", \"key=val1\")\n\t\t// This should override the previous one\n\t\tctx.Response.SetHeader(\"Set-Cookie\", \"key=val\")\n\n\t\t// override response body\n\t\tctx.Response.SetBody([]byte(\"test\"))\n\t\tctx.Response.SetBody(\"test\")\n\t\tctx.Response.SetBody(map[string]string{\n\t\t\t\"text\": \"test\",\n\t\t})\n\n\t\tg.Eq(\"{\\\"text\\\":\\\"test\\\"}\", ctx.Response.Body())\n\t})\n\n\trouter.MustAdd(s.URL(\"/b\"), func(_ *rod.Hijack) {\n\t\tpanic(\"should not come to here\")\n\t})\n\trouter.MustRemove(s.URL(\"/b\"))\n\n\trouter.MustAdd(s.URL(\"/b\"), func(ctx *rod.Hijack) {\n\t\t// transparent proxy\n\t\tctx.MustLoadResponse()\n\t})\n\n\tgo router.Run()\n\n\tg.page.MustNavigate(s.URL())\n\n\tg.Eq(\"201 test key=val\", g.page.MustElement(\"#a\").MustText())\n\tg.Eq(\"b\", g.page.MustElement(\"#b\").MustText())\n}\n\nfunc TestHijackContinue(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve().Route(\"/\", \".html\", `<body>ok</body>`)\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\twg := &sync.WaitGroup{}\n\twg.Add(1)\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tctx.ContinueRequest(&proto.FetchContinueRequest{})\n\t\twg.Done()\n\t})\n\n\tgo router.Run()\n\n\tg.page.MustNavigate(s.URL(\"/a\"))\n\n\tg.Eq(\"ok\", g.page.MustElement(\"body\").MustText())\n\twg.Wait()\n}\n\nfunc TestHijackMockWholeResponseEmptyBody(t *testing.T) {\n\tg := setup(t)\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\trouter.MustAdd(\"*\", func(ctx *rod.Hijack) {\n\t\tctx.Response.SetBody(\"\")\n\t})\n\n\tgo router.Run()\n\n\t// needs to timeout or will hang when \"omitempty\" does not get removed from body in fulfillRequest\n\ttimed := g.page.Timeout(time.Second)\n\ttimed.MustNavigate(g.Serve().Route(\"/\", \".txt\", \"OK\").URL())\n\n\tg.Eq(\"\", g.page.MustElement(\"body\").MustText())\n}\n\nfunc TestHijackMockWholeResponseNoBody(t *testing.T) {\n\t// TODO: remove the skip\n\tt.Skip(\"Because of flaky test result\")\n\n\tg := setup(t)\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\t// intercept and reply without setting a body\n\trouter.MustAdd(\"*\", func(_ *rod.Hijack) {\n\t\t// we don't set any body here\n\t})\n\n\tgo router.Run()\n\n\t// has to timeout as it will lock up the browser reading the reply.\n\terr := g.page.Timeout(time.Second).Navigate(g.Serve().Route(\"/\", \"\").URL())\n\tg.Is(err, context.DeadlineExceeded)\n}\n\nfunc TestHijackMockWholeResponse(t *testing.T) {\n\tg := setup(t)\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\trouter.MustAdd(\"*\", func(ctx *rod.Hijack) {\n\t\tctx.Response.SetHeader(\"Content-Type\", mime.TypeByExtension(\".html\"))\n\t\tctx.Response.SetBody(\"<body>ok</body>\")\n\t})\n\n\tgo router.Run()\n\n\tg.page.MustNavigate(\"http://localhost\")\n\n\tg.Eq(\"ok\", g.page.MustElement(\"body\").MustText())\n}\n\nfunc TestHijackSkip(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\twg := &sync.WaitGroup{}\n\twg.Add(2)\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tctx.Skip = true\n\t\twg.Done()\n\t})\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tctx.ContinueRequest(&proto.FetchContinueRequest{})\n\t\twg.Done()\n\t})\n\n\tgo router.Run()\n\n\tg.page.MustNavigate(s.URL(\"/a\"))\n\n\twg.Wait()\n}\n\nfunc TestHijackOnErrorLog(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve().Route(\"/\", \".html\", `<body>ok</body>`)\n\n\trouter := g.page.HijackRequests()\n\tdefer router.MustStop()\n\n\twg := &sync.WaitGroup{}\n\twg.Add(1)\n\tvar err error\n\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tctx.OnError = func(e error) {\n\t\t\terr = e\n\t\t\twg.Done()\n\t\t}\n\t\tctx.ContinueRequest(&proto.FetchContinueRequest{})\n\t})\n\n\tgo router.Run()\n\n\tg.mc.stub(1, proto.FetchContinueRequest{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(nil), errors.New(\"err\")\n\t})\n\n\tgo func() {\n\t\t_ = g.page.Context(g.Context()).Navigate(s.URL(\"/a\"))\n\t}()\n\twg.Wait()\n\n\tg.Eq(err.Error(), \"err\")\n}\n\nfunc TestHijackFailRequest(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve().Route(\"/page\", \".html\", `<html>\n\t<body></body>\n\t<script>\n\t\tfetch('/a').catch(async (err) => {\n\t\t\tdocument.title = err.message\n\t\t})\n\t</script></html>`)\n\n\trouter := g.browser.HijackRequests()\n\tdefer router.MustStop()\n\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) {\n\t\tctx.Response.Fail(proto.NetworkErrorReasonAborted)\n\t})\n\n\tgo router.Run()\n\n\tg.page.MustNavigate(s.URL(\"/page\")).MustWaitLoad()\n\n\tg.page.MustWait(`() => document.title === 'Failed to fetch'`)\n\n\t{ // test error log\n\t\tg.mc.stub(1, proto.FetchFailRequest{}, func(send StubSend) (gson.JSON, error) {\n\t\t\t_, _ = send()\n\t\t\treturn gson.JSON{}, errors.New(\"err\")\n\t\t})\n\t\t_ = g.page.Navigate(s.URL(\"/a\"))\n\t}\n}\n\nfunc TestHijackLoadResponseErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage().Context(g.Context())\n\trouter := p.HijackRequests()\n\tdefer router.MustStop()\n\n\twg := &sync.WaitGroup{}\n\twg.Add(1)\n\n\trouter.MustAdd(\"http://localhost/a\", func(ctx *rod.Hijack) {\n\t\tg.Err(ctx.LoadResponse(&http.Client{\n\t\t\tTransport: &MockRoundTripper{err: errors.New(\"err\")},\n\t\t}, true))\n\n\t\tg.Err(ctx.LoadResponse(&http.Client{\n\t\t\tTransport: &MockRoundTripper{res: &http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\tBody:       io.NopCloser(&MockReader{err: errors.New(\"err\")}),\n\t\t\t}},\n\t\t}, true))\n\n\t\twg.Done()\n\n\t\tctx.Response.Fail(proto.NetworkErrorReasonAborted)\n\t})\n\n\tgo router.Run()\n\n\t_ = p.Navigate(\"http://localhost/a\")\n\n\twg.Wait()\n}\n\nfunc TestHijackResponseErr(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve().Route(\"/\", \".html\", `ok`)\n\n\tp := g.newPage().Context(g.Context())\n\trouter := p.HijackRequests()\n\tdefer router.MustStop()\n\n\twg := &sync.WaitGroup{}\n\twg.Add(1)\n\n\trouter.MustAdd(s.URL(\"/a\"), func(ctx *rod.Hijack) { // to ignore favicon\n\t\tctx.OnError = func(err error) {\n\t\t\tg.Err(err)\n\t\t\twg.Done()\n\t\t}\n\n\t\tctx.MustLoadResponse()\n\t\tg.mc.stub(1, proto.FetchFulfillRequest{}, func(send StubSend) (gson.JSON, error) {\n\t\t\tres, _ := send()\n\t\t\treturn res, errors.New(\"err\")\n\t\t})\n\t})\n\n\tgo router.Run()\n\n\tp.MustNavigate(s.URL(\"/a\"))\n\n\twg.Wait()\n}\n\nfunc TestHandleAuth(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\t// mock the server\n\ts.Mux.HandleFunc(\"/a\", func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Add(\"WWW-Authenticate\", `Basic realm=\"web\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tg.Eq(\"a\", u)\n\t\tg.Eq(\"b\", p)\n\t\tg.HandleHTTP(\".html\", `<p>ok</p>`)(w, r)\n\t})\n\ts.Route(\"/err\", \".html\", \"err page\")\n\n\tgo g.browser.MustHandleAuth(\"a\", \"b\")()\n\n\tpage := g.newPage(s.URL(\"/a\"))\n\tpage.MustElementR(\"p\", \"ok\")\n\n\twait := g.browser.HandleAuth(\"a\", \"b\")\n\tvar page2 *rod.Page\n\twait2 := utils.All(func() {\n\t\tpage2, _ = g.browser.Page(proto.TargetCreateTarget{URL: s.URL(\"/err\")})\n\t})\n\tg.mc.stubErr(1, proto.FetchContinueRequest{})\n\tg.Err(wait())\n\twait2()\n\tpage2.MustClose()\n}\n"
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 10.2177734375,
          "content": "package rod\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// Keyboard represents the keyboard on a page, it's always related the main frame.\ntype Keyboard struct {\n\tsync.Mutex\n\n\tpage *Page\n\n\t// pressed keys must be released before it can be pressed again\n\tpressed map[input.Key]struct{}\n}\n\nfunc (p *Page) newKeyboard() *Page {\n\tp.Keyboard = &Keyboard{page: p, pressed: map[input.Key]struct{}{}}\n\treturn p\n}\n\nfunc (k *Keyboard) getModifiers() int {\n\tk.Lock()\n\tdefer k.Unlock()\n\treturn k.modifiers()\n}\n\nfunc (k *Keyboard) modifiers() int {\n\tms := 0\n\tfor key := range k.pressed {\n\t\tms |= key.Modifier()\n\t}\n\treturn ms\n}\n\n// Press the key down.\n// To input characters that are not on the keyboard, such as Chinese or Japanese, you should\n// use method like [Page.InsertText].\nfunc (k *Keyboard) Press(key input.Key) error {\n\tdefer k.page.tryTrace(TraceTypeInput, \"press key: \"+key.Info().Code)()\n\tk.page.browser.trySlowMotion()\n\n\tk.Lock()\n\tdefer k.Unlock()\n\n\tk.pressed[key] = struct{}{}\n\n\treturn key.Encode(proto.InputDispatchKeyEventTypeKeyDown, k.modifiers()).Call(k.page)\n}\n\n// Release the key.\nfunc (k *Keyboard) Release(key input.Key) error {\n\tdefer k.page.tryTrace(TraceTypeInput, \"release key: \"+key.Info().Code)()\n\n\tk.Lock()\n\tdefer k.Unlock()\n\n\tif _, has := k.pressed[key]; !has {\n\t\treturn nil\n\t}\n\n\tdelete(k.pressed, key)\n\n\treturn key.Encode(proto.InputDispatchKeyEventTypeKeyUp, k.modifiers()).Call(k.page)\n}\n\n// Type releases the key after the press.\nfunc (k *Keyboard) Type(keys ...input.Key) (err error) {\n\tfor _, key := range keys {\n\t\terr = k.Press(key)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = k.Release(key)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// KeyActionType enum.\ntype KeyActionType int\n\n// KeyActionTypes.\nconst (\n\tKeyActionPress KeyActionType = iota\n\tKeyActionRelease\n\tKeyActionTypeKey\n)\n\n// KeyAction to perform.\ntype KeyAction struct {\n\tType KeyActionType\n\tKey  input.Key\n}\n\n// KeyActions to simulate.\ntype KeyActions struct {\n\tkeyboard *Keyboard\n\n\tActions []KeyAction\n}\n\n// KeyActions simulates the type actions on a physical keyboard.\n// Useful when input shortcuts like ctrl+enter .\nfunc (p *Page) KeyActions() *KeyActions {\n\treturn &KeyActions{keyboard: p.Keyboard}\n}\n\n// Press keys is guaranteed to have a release at the end of actions.\nfunc (ka *KeyActions) Press(keys ...input.Key) *KeyActions {\n\tfor _, key := range keys {\n\t\tka.Actions = append(ka.Actions, KeyAction{KeyActionPress, key})\n\t}\n\treturn ka\n}\n\n// Release keys.\nfunc (ka *KeyActions) Release(keys ...input.Key) *KeyActions {\n\tfor _, key := range keys {\n\t\tka.Actions = append(ka.Actions, KeyAction{KeyActionRelease, key})\n\t}\n\treturn ka\n}\n\n// Type will release the key immediately after the pressing.\nfunc (ka *KeyActions) Type(keys ...input.Key) *KeyActions {\n\tfor _, key := range keys {\n\t\tka.Actions = append(ka.Actions, KeyAction{KeyActionTypeKey, key})\n\t}\n\treturn ka\n}\n\n// Do the actions.\nfunc (ka *KeyActions) Do() (err error) {\n\tfor _, a := range ka.balance() {\n\t\tswitch a.Type {\n\t\tcase KeyActionPress:\n\t\t\terr = ka.keyboard.Press(a.Key)\n\t\tcase KeyActionRelease:\n\t\t\terr = ka.keyboard.Release(a.Key)\n\t\tcase KeyActionTypeKey:\n\t\t\terr = ka.keyboard.Type(a.Key)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// Make sure there's at least one release after the presses, such as:\n//\n//\tp1,p2,p1,r1 => p1,p2,p1,r1,r2\nfunc (ka *KeyActions) balance() []KeyAction {\n\tactions := ka.Actions\n\n\th := map[input.Key]bool{}\n\tfor _, a := range actions {\n\t\tswitch a.Type {\n\t\tcase KeyActionPress:\n\t\t\th[a.Key] = true\n\t\tcase KeyActionRelease, KeyActionTypeKey:\n\t\t\th[a.Key] = false\n\t\t}\n\t}\n\n\tfor key, needRelease := range h {\n\t\tif needRelease {\n\t\t\tactions = append(actions, KeyAction{KeyActionRelease, key})\n\t\t}\n\t}\n\n\treturn actions\n}\n\n// InsertText is like pasting text into the page.\nfunc (p *Page) InsertText(text string) error {\n\tdefer p.tryTrace(TraceTypeInput, \"insert text \"+text)()\n\tp.browser.trySlowMotion()\n\n\terr := proto.InputInsertText{Text: text}.Call(p)\n\treturn err\n}\n\n// Mouse represents the mouse on a page, it's always related the main frame.\ntype Mouse struct {\n\tsync.Mutex\n\n\tpage *Page\n\n\tid string // mouse svg dom element id\n\n\tpos proto.Point\n\n\t// the buttons is currently being pressed, reflects the press order\n\tbuttons []proto.InputMouseButton\n}\n\nfunc (p *Page) newMouse() *Page {\n\tp.Mouse = &Mouse{page: p, id: utils.RandString(8)}\n\treturn p\n}\n\n// Position of current cursor.\nfunc (m *Mouse) Position() proto.Point {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.pos\n}\n\n// MoveTo the absolute position.\nfunc (m *Mouse) MoveTo(p proto.Point) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tbutton, buttons := input.EncodeMouseButton(m.buttons)\n\n\tm.page.browser.trySlowMotion()\n\n\terr := proto.InputDispatchMouseEvent{\n\t\tType:      proto.InputDispatchMouseEventTypeMouseMoved,\n\t\tX:         p.X,\n\t\tY:         p.Y,\n\t\tButton:    button,\n\t\tButtons:   gson.Int(buttons),\n\t\tModifiers: m.page.Keyboard.getModifiers(),\n\t}.Call(m.page)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// to make sure set only when call is successful\n\tm.pos = p\n\n\tif m.page.browser.trace {\n\t\tif !m.updateMouseTracer() {\n\t\t\tm.initMouseTracer()\n\t\t\tm.updateMouseTracer()\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MoveAlong the guide function.\n// Every time the guide function is called it should return the next mouse position, return true to stop.\n// Read the source code of [Mouse.MoveLinear] as an example to use this method.\nfunc (m *Mouse) MoveAlong(guide func() (proto.Point, bool)) error {\n\tfor {\n\t\tp, stop := guide()\n\t\tif stop {\n\t\t\treturn m.MoveTo(p)\n\t\t}\n\n\t\terr := m.MoveTo(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// MoveLinear to the absolute position with the given steps.\n// Such as move from (0,0) to (6,6) with 3 steps, the mouse will first move to (2,2) then (4,4) then (6,6).\nfunc (m *Mouse) MoveLinear(to proto.Point, steps int) error {\n\tp := m.Position()\n\tstep := to.Minus(p).Scale(1 / float64(steps))\n\tcount := 0\n\n\treturn m.MoveAlong(func() (proto.Point, bool) {\n\t\tcount++\n\t\tif count == steps {\n\t\t\treturn to, true\n\t\t}\n\n\t\tp = p.Add(step)\n\t\treturn p, false\n\t})\n}\n\n// Scroll the relative offset with specified steps.\nfunc (m *Mouse) Scroll(offsetX, offsetY float64, steps int) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tdefer m.page.tryTrace(TraceTypeInput, fmt.Sprintf(\"scroll (%.2f, %.2f)\", offsetX, offsetY))()\n\tm.page.browser.trySlowMotion()\n\n\tif steps < 1 {\n\t\tsteps = 1\n\t}\n\n\tbutton, buttons := input.EncodeMouseButton(m.buttons)\n\n\tstepX := offsetX / float64(steps)\n\tstepY := offsetY / float64(steps)\n\n\tfor i := 0; i < steps; i++ {\n\t\terr := proto.InputDispatchMouseEvent{\n\t\t\tType:      proto.InputDispatchMouseEventTypeMouseWheel,\n\t\t\tButton:    button,\n\t\t\tButtons:   gson.Int(buttons),\n\t\t\tModifiers: m.page.Keyboard.getModifiers(),\n\t\t\tDeltaX:    stepX,\n\t\t\tDeltaY:    stepY,\n\t\t\tX:         m.pos.X,\n\t\t\tY:         m.pos.Y,\n\t\t}.Call(m.page)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Down holds the button down.\nfunc (m *Mouse) Down(button proto.InputMouseButton, clickCount int) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\ttoButtons := append(append([]proto.InputMouseButton{}, m.buttons...), button)\n\n\t_, buttons := input.EncodeMouseButton(toButtons)\n\n\terr := proto.InputDispatchMouseEvent{\n\t\tType:       proto.InputDispatchMouseEventTypeMousePressed,\n\t\tButton:     button,\n\t\tButtons:    gson.Int(buttons),\n\t\tClickCount: clickCount,\n\t\tModifiers:  m.page.Keyboard.getModifiers(),\n\t\tX:          m.pos.X,\n\t\tY:          m.pos.Y,\n\t}.Call(m.page)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.buttons = toButtons\n\treturn nil\n}\n\n// Up releases the button.\nfunc (m *Mouse) Up(button proto.InputMouseButton, clickCount int) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\ttoButtons := []proto.InputMouseButton{}\n\tfor _, btn := range m.buttons {\n\t\tif btn == button {\n\t\t\tcontinue\n\t\t}\n\t\ttoButtons = append(toButtons, btn)\n\t}\n\n\t_, buttons := input.EncodeMouseButton(toButtons)\n\n\terr := proto.InputDispatchMouseEvent{\n\t\tType:       proto.InputDispatchMouseEventTypeMouseReleased,\n\t\tButton:     button,\n\t\tButtons:    gson.Int(buttons),\n\t\tClickCount: clickCount,\n\t\tModifiers:  m.page.Keyboard.getModifiers(),\n\t\tX:          m.pos.X,\n\t\tY:          m.pos.Y,\n\t}.Call(m.page)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.buttons = toButtons\n\treturn nil\n}\n\n// Click the button. It's the combination of [Mouse.Down] and [Mouse.Up].\nfunc (m *Mouse) Click(button proto.InputMouseButton, clickCount int) error {\n\tm.page.browser.trySlowMotion()\n\n\terr := m.Down(button, clickCount)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn m.Up(button, clickCount)\n}\n\n// Touch presents a touch device, such as a hand with fingers, each finger is a [proto.InputTouchPoint].\n// Touch events is stateless, we use the struct here only as a namespace to make the API style unified.\ntype Touch struct {\n\tpage *Page\n}\n\nfunc (p *Page) newTouch() *Page {\n\tp.Touch = &Touch{page: p}\n\treturn p\n}\n\n// Start a touch action.\nfunc (t *Touch) Start(points ...*proto.InputTouchPoint) error {\n\t// TODO: https://crbug.com/613219\n\t_ = t.page.WaitRepaint()\n\t_ = t.page.WaitRepaint()\n\n\treturn proto.InputDispatchTouchEvent{\n\t\tType:        proto.InputDispatchTouchEventTypeTouchStart,\n\t\tTouchPoints: points,\n\t\tModifiers:   t.page.Keyboard.getModifiers(),\n\t}.Call(t.page)\n}\n\n// Move touch points. Use the [proto.InputTouchPoint.ID] (Touch.identifier) to track points.\n// Doc: https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\nfunc (t *Touch) Move(points ...*proto.InputTouchPoint) error {\n\treturn proto.InputDispatchTouchEvent{\n\t\tType:        proto.InputDispatchTouchEventTypeTouchMove,\n\t\tTouchPoints: points,\n\t\tModifiers:   t.page.Keyboard.getModifiers(),\n\t}.Call(t.page)\n}\n\n// End touch action.\nfunc (t *Touch) End() error {\n\treturn proto.InputDispatchTouchEvent{\n\t\tType:        proto.InputDispatchTouchEventTypeTouchEnd,\n\t\tTouchPoints: []*proto.InputTouchPoint{},\n\t\tModifiers:   t.page.Keyboard.getModifiers(),\n\t}.Call(t.page)\n}\n\n// Cancel touch action.\nfunc (t *Touch) Cancel() error {\n\treturn proto.InputDispatchTouchEvent{\n\t\tType:        proto.InputDispatchTouchEventTypeTouchCancel,\n\t\tTouchPoints: []*proto.InputTouchPoint{},\n\t\tModifiers:   t.page.Keyboard.getModifiers(),\n\t}.Call(t.page)\n}\n\n// Tap dispatches a touchstart and touchend event.\nfunc (t *Touch) Tap(x, y float64) error {\n\tdefer t.page.tryTrace(TraceTypeInput, \"touch\")()\n\tt.page.browser.trySlowMotion()\n\n\tp := &proto.InputTouchPoint{X: x, Y: y}\n\n\terr := t.Start(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn t.End()\n}\n"
        },
        {
          "name": "input_test.go",
          "type": "blob",
          "size": 6.7265625,
          "content": "package rod_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\nfunc TestKeyActions(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/keys.html\"))\n\tbody := p.MustElement(\"body\")\n\n\tp.KeyActions().Press(input.ControlLeft).Type(input.Enter).MustDo()\n\tg.Eq(body.MustText(), `↓ \"Control\" ControlLeft 17 modifiers(ctrl)\n↓ \"Enter\" Enter 13 modifiers(ctrl)\n↑ \"Enter\" Enter 13 modifiers(ctrl)\n↑ \"Control\" ControlLeft 17 modifiers()\n`)\n\n\tbody.MustEval(\"() => this.innerText = ''\")\n\tbody.MustKeyActions().\n\t\tPress(input.ShiftLeft).Type('A', 'X').Release(input.ShiftLeft).\n\t\tType('a').MustDo()\n\tg.Eq(body.MustText(), `↓ \"Shift\" ShiftLeft 16 modifiers(shift)\n↓ \"A\" KeyA 65 modifiers(shift)\n↑ \"A\" KeyA 65 modifiers(shift)\n↓ \"X\" KeyX 88 modifiers(shift)\n↑ \"X\" KeyX 88 modifiers(shift)\n↑ \"Shift\" ShiftLeft 16 modifiers()\n↓ \"a\" KeyA 65 modifiers()\n↑ \"a\" KeyA 65 modifiers()\n`)\n\n\tg.Nil(p.Keyboard.Release('a'))\n}\n\nfunc TestKeyType(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"[type=text]\")\n\n\tel.MustKeyActions().Type('1', '2', input.Backspace, ' ').MustDo()\n\tel.MustKeyActions().Type('A', ' ', 'b').MustDo()\n\tp.MustInsertText(\" test\")\n\tp.Keyboard.MustType(input.Tab)\n\n\tg.Eq(\"1 A b test\", el.MustText())\n}\n\nfunc TestKeyTypeErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/keys.html\"))\n\tbody := p.MustElement(\"body\")\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(body.Type('a'))\n\n\tg.mc.stubErr(1, proto.InputDispatchKeyEvent{})\n\tg.Err(p.Keyboard.Type('a'))\n\n\tg.mc.stubErr(2, proto.InputDispatchKeyEvent{})\n\tg.Err(p.Keyboard.Type('a'))\n\n\tg.mc.stubErr(1, proto.InputDispatchKeyEvent{})\n\tg.Err(p.KeyActions().Press('a').Do())\n}\n\nfunc TestInput(t *testing.T) {\n\tg := setup(t)\n\n\ttext := \"雲の上は\\nいつも晴れ\"\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\n\t{\n\t\tel := p.MustElement(\"[contenteditable=true]\").MustInput(text)\n\t\tg.Eq(text, el.MustText())\n\t}\n\n\tel := p.MustElement(\"textarea\")\n\tel.MustInput(text)\n\n\tg.Eq(text, el.MustText())\n\tg.True(p.MustHas(\"[event=textarea-change]\"))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustText()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(4, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInput(\"\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(5, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInput(\"\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(6, proto.RuntimeCallFunctionOn{})\n\t\tel.MustInput(\"\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputInsertText{})\n\t\tel.MustInput(\"\")\n\t})\n}\n\nfunc TestMouse(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tpage.MustElement(\"button\")\n\tmouse := page.Mouse\n\n\tmouse.MustScroll(0, 10)\n\tmouse.MustMoveTo(140, 160)\n\tmouse.MustDown(\"left\")\n\tmouse.MustUp(\"left\")\n\n\tg.True(page.MustHas(\"[a=ok]\"))\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\t\tmouse.MustScroll(0, 10)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\t\tmouse.MustDown(proto.InputMouseButtonLeft)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\t\tmouse.MustUp(proto.InputMouseButtonLeft)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\t\tmouse.MustClick(proto.InputMouseButtonLeft)\n\t})\n}\n\nfunc TestMouseHoldMultiple(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank())\n\n\tp.Mouse.MustDown(\"left\")\n\tdefer p.Mouse.MustUp(\"left\")\n\tp.Mouse.MustDown(\"right\")\n\tdefer p.Mouse.MustUp(\"right\")\n}\n\nfunc TestMouseClick(t *testing.T) {\n\tg := setup(t)\n\n\tg.browser.SlowMotion(1)\n\tdefer func() { g.browser.SlowMotion(0) }()\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tpage.MustElement(\"button\")\n\tmouse := page.Mouse\n\tmouse.MustMoveTo(140, 160)\n\tmouse.MustClick(\"left\")\n\tg.True(page.MustHas(\"[a=ok]\"))\n}\n\nfunc TestMouseDoubleClick(t *testing.T) {\n\tg := setup(t)\n\n\tg.browser.SlowMotion(1)\n\tdefer func() { g.browser.SlowMotion(0) }()\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/double-click.html\"))\n\tel := page.MustElement(\"button\")\n\tel.MustDoubleClick()\n\tg.Eq(el.MustText(), \"ok\")\n}\n\nfunc TestMouseDrag(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage().MustNavigate(g.srcFile(\"fixtures/drag.html\")).MustWaitLoad()\n\tmouse := page.Mouse\n\n\tmouse.MustMoveTo(3, 3)\n\tmouse.MustDown(\"left\")\n\tg.E(mouse.MoveLinear(proto.NewPoint(60, 80), 3))\n\tmouse.MustUp(\"left\")\n\n\tutils.Sleep(0.3)\n\tg.Eq(page.MustEval(`() => dragTrack`).Str(), \" move 3 3 down 3 3 move 22 28 move 41 54 move 60 80 up 60 80\")\n}\n\nfunc TestMouseScroll(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/scroll.html\")).MustWaitLoad()\n\n\tp.Mouse.MustMoveTo(30, 30)\n\tp.Mouse.MustClick(proto.InputMouseButtonLeft)\n\n\tp.Mouse.MustScroll(0, 10)\n\tp.Mouse.MustScroll(100, 190)\n\tg.E(p.Mouse.Scroll(200, 300, 5))\n\n\tp.MustWait(`() => pageXOffset > 200 && pageYOffset > 300`)\n}\n\nfunc TestMouseMoveLinear(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage().MustNavigate(g.srcFile(\"fixtures/mouse-move.html\")).MustWaitLoad()\n\tmouse := page.Mouse\n\n\tmouse.MustMoveTo(1, 2)\n\tg.E(mouse.MoveLinear(proto.NewPoint(3, 4), 3))\n\n\tutils.Sleep(0.3)\n\tg.Eq(page.MustEval(`() => moveTrack`).Str(), \" move 1 2 move 1 2 move 2 3 move 3 4\")\n}\n\nfunc TestMouseMoveErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tg.mc.stubErr(2, proto.InputDispatchMouseEvent{})\n\tg.Err(p.Mouse.MoveLinear(proto.NewPoint(10, 10), 3))\n}\n\nfunc TestNativeDrag(t *testing.T) { // devtools doesn't support to use mouse event to simulate it for now\n\tt.Skip()\n\n\tg := setup(t)\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/drag.html\"))\n\tmouse := page.Mouse\n\n\tpt := page.MustElement(\"#draggable\").MustShape().OnePointInside()\n\ttoY := page.MustElement(\".dropzone:nth-child(2)\").MustShape().OnePointInside().Y\n\n\tpage.Overlay(pt.X, pt.Y, 10, 10, \"from\")\n\tpage.Overlay(pt.X, toY, 10, 10, \"to\")\n\n\tmouse.MustMoveTo(pt.X, pt.Y)\n\tmouse.MustDown(\"left\")\n\tg.E(mouse.MoveLinear(proto.NewPoint(pt.X, toY), 5))\n\tpage.MustScreenshot(\"\")\n\tmouse.MustUp(\"left\")\n\n\tpage.MustElement(\".dropzone:nth-child(2) #draggable\")\n}\n\nfunc TestTouch(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage().MustEmulate(devices.IPad)\n\n\twait := page.WaitNavigation(proto.PageLifecycleEventNameLoad)\n\tpage.MustNavigate(g.srcFile(\"fixtures/touch.html\"))\n\twait()\n\n\ttouch := page.Touch\n\n\ttouch.MustTap(10, 20)\n\n\tp := &proto.InputTouchPoint{X: 30, Y: 40}\n\n\ttouch.MustStart(p).MustEnd()\n\ttouch.MustStart(p)\n\tp.MoveTo(50, 60)\n\ttouch.MustMove(p).MustCancel()\n\n\tpage.MustWait(`() => touchTrack == ' start 10 20 end start 30 40 end start 30 40 move 50 60 cancel'`)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.InputDispatchTouchEvent{})\n\t\ttouch.MustTap(1, 2)\n\t})\n}\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "must.go",
          "type": "blob",
          "size": 28.888671875,
          "content": "// This file contains the methods that panics when error return value is not nil.\n// Their function names are all prefixed with Must.\n// A function here is usually a wrapper for the error version with fixed default options to make it easier to use.\n//\n// For example the source code of [Element.Click] and [Element.MustClick]. MustClick has no argument.\n// But `Click` has a `button` argument to decide which button to click.\n// `MustClick` feels like a version of `Click` with some default behaviors.\n\npackage rod\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/input\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// It must be generated by genE.\ntype eFunc func(args ...interface{})\n\n// Generate a eFunc with the specified fail function.\n// If the last arg of eFunc is error the fail will be called.\nfunc genE(fail func(interface{})) eFunc {\n\treturn func(args ...interface{}) {\n\t\terr, ok := args[len(args)-1].(error)\n\t\tif ok {\n\t\t\tfail(err)\n\t\t}\n\t}\n}\n\n// WithPanic returns a browser clone with the specified panic function.\n// The fail must stop the current goroutine's execution immediately, such as use [runtime.Goexit] or panic inside it.\nfunc (b *Browser) WithPanic(fail func(interface{})) *Browser {\n\tn := *b\n\tn.e = genE(fail)\n\treturn &n\n}\n\n// MustConnect is similar to [Browser.Connect].\nfunc (b *Browser) MustConnect() *Browser {\n\tb.e(b.Connect())\n\treturn b\n}\n\n// MustClose is similar to [Browser.Close].\nfunc (b *Browser) MustClose() {\n\t_ = b.Close()\n}\n\n// MustIncognito is similar to [Browser.Incognito].\nfunc (b *Browser) MustIncognito() *Browser {\n\tp, err := b.Incognito()\n\tb.e(err)\n\treturn p\n}\n\n// MustPage is similar to [Browser.Page].\n// The url list will be joined by \"/\".\nfunc (b *Browser) MustPage(url ...string) *Page {\n\tp, err := b.Page(proto.TargetCreateTarget{URL: strings.Join(url, \"/\")})\n\tb.e(err)\n\treturn p\n}\n\n// MustPages is similar to [Browser.Pages].\nfunc (b *Browser) MustPages() Pages {\n\tlist, err := b.Pages()\n\tb.e(err)\n\treturn list\n}\n\n// MustPageFromTargetID is similar to [Browser.PageFromTargetID].\nfunc (b *Browser) MustPageFromTargetID(targetID proto.TargetTargetID) *Page {\n\tp, err := b.PageFromTarget(targetID)\n\tb.e(err)\n\treturn p\n}\n\n// MustHandleAuth is similar to [Browser.HandleAuth].\nfunc (b *Browser) MustHandleAuth(username, password string) (wait func()) {\n\tw := b.HandleAuth(username, password)\n\treturn func() { b.e(w()) }\n}\n\n// MustIgnoreCertErrors is similar to [Browser.IgnoreCertErrors].\nfunc (b *Browser) MustIgnoreCertErrors(enable bool) *Browser {\n\tb.e(b.IgnoreCertErrors(enable))\n\treturn b\n}\n\n// MustGetCookies is similar to [Browser.GetCookies].\nfunc (b *Browser) MustGetCookies() []*proto.NetworkCookie {\n\tnc, err := b.GetCookies()\n\tb.e(err)\n\treturn nc\n}\n\n// MustSetCookies is similar to [Browser.SetCookies].\n// If the len(cookies) is 0 it will clear all the cookies.\nfunc (b *Browser) MustSetCookies(cookies ...*proto.NetworkCookie) *Browser {\n\tif len(cookies) == 0 {\n\t\tb.e(b.SetCookies(nil))\n\t} else {\n\t\tb.e(b.SetCookies(proto.CookiesToParams(cookies)))\n\t}\n\treturn b\n}\n\n// MustWaitDownload is similar to [Browser.WaitDownload].\n// It will read the file into bytes then remove the file.\nfunc (b *Browser) MustWaitDownload() func() []byte {\n\ttmpDir := filepath.Join(os.TempDir(), \"rod\", \"downloads\")\n\twait := b.WaitDownload(tmpDir)\n\n\treturn func() []byte {\n\t\tinfo := wait()\n\t\tpath := filepath.Join(tmpDir, info.GUID)\n\t\tdefer func() { _ = os.Remove(path) }()\n\t\tdata, err := os.ReadFile(path)\n\t\tb.e(err)\n\t\treturn data\n\t}\n}\n\n// MustVersion is similar to [Browser.Version].\nfunc (b *Browser) MustVersion() *proto.BrowserGetVersionResult {\n\tv, err := b.Version()\n\tb.e(err)\n\treturn v\n}\n\n// MustFind is similar to [Browser.Find].\nfunc (ps Pages) MustFind(selector string) *Page {\n\tp, err := ps.Find(selector)\n\tif err != nil {\n\t\tif len(ps) > 0 {\n\t\t\tps[0].e(err)\n\t\t} else {\n\t\t\t// fallback to utils.E, because we don't have enough\n\t\t\t// context to call the scope `.e`.\n\t\t\tutils.E(err)\n\t\t}\n\t}\n\treturn p\n}\n\n// MustFindByURL is similar to [Page.FindByURL].\nfunc (ps Pages) MustFindByURL(regex string) *Page {\n\tp, err := ps.FindByURL(regex)\n\tif err != nil {\n\t\tif len(ps) > 0 {\n\t\t\tps[0].e(err)\n\t\t} else {\n\t\t\t// fallback to utils.E, because we don't have enough\n\t\t\t// context to call the scope `.e`.\n\t\t\tutils.E(err)\n\t\t}\n\t}\n\treturn p\n}\n\n// WithPanic returns a page clone with the specified panic function.\n// The fail must stop the current goroutine's execution immediately, such as use [runtime.Goexit] or panic inside it.\nfunc (p *Page) WithPanic(fail func(interface{})) *Page {\n\tn := *p\n\tn.e = genE(fail)\n\treturn &n\n}\n\n// MustInfo is similar to [Page.Info].\nfunc (p *Page) MustInfo() *proto.TargetTargetInfo {\n\tinfo, err := p.Info()\n\tp.e(err)\n\treturn info\n}\n\n// MustHTML is similar to [Page.HTML].\nfunc (p *Page) MustHTML() string {\n\thtml, err := p.HTML()\n\tp.e(err)\n\treturn html\n}\n\n// MustCookies is similar to [Page.Cookies].\nfunc (p *Page) MustCookies(urls ...string) []*proto.NetworkCookie {\n\tcookies, err := p.Cookies(urls)\n\tp.e(err)\n\treturn cookies\n}\n\n// MustSetCookies is similar to [Page.SetCookies].\n// If the len(cookies) is 0 it will clear all the cookies.\nfunc (p *Page) MustSetCookies(cookies ...*proto.NetworkCookieParam) *Page {\n\tif len(cookies) == 0 {\n\t\tcookies = nil\n\t}\n\tp.e(p.SetCookies(cookies))\n\treturn p\n}\n\n// MustSetExtraHeaders is similar to [Page.SetExtraHeaders].\nfunc (p *Page) MustSetExtraHeaders(dict ...string) (cleanup func()) {\n\tcleanup, err := p.SetExtraHeaders(dict)\n\tp.e(err)\n\treturn\n}\n\n// MustSetUserAgent is similar to [Page.SetUserAgent].\nfunc (p *Page) MustSetUserAgent(req *proto.NetworkSetUserAgentOverride) *Page {\n\tp.e(p.SetUserAgent(req))\n\treturn p\n}\n\n// MustSetBlockedURLs is similar to [Page.SetBlockedURLs].\nfunc (p *Page) MustSetBlockedURLs(urls ...string) *Page {\n\tp.e(p.SetBlockedURLs(urls))\n\treturn p\n}\n\n// MustNavigate is similar to [Page.Navigate].\nfunc (p *Page) MustNavigate(url string) *Page {\n\tp.e(p.Navigate(url))\n\treturn p\n}\n\n// MustResetNavigationHistory is similar to [Page.ResetNavigationHistory].\nfunc (p *Page) MustResetNavigationHistory() *Page {\n\tp.e(p.ResetNavigationHistory())\n\treturn p\n}\n\n// MustReload is similar to [Page.Reload].\nfunc (p *Page) MustReload() *Page {\n\tp.e(p.Reload())\n\treturn p\n}\n\n// MustActivate is similar to [Page.Activate].\nfunc (p *Page) MustActivate() *Page {\n\tp.e(p.Activate())\n\treturn p\n}\n\n// MustNavigateBack is similar to [Page.NavigateBack].\nfunc (p *Page) MustNavigateBack() *Page {\n\tp.e(p.NavigateBack())\n\treturn p\n}\n\n// MustNavigateForward is similar to [Page.NavigateForward].\nfunc (p *Page) MustNavigateForward() *Page {\n\tp.e(p.NavigateForward())\n\treturn p\n}\n\n// MustGetWindow is similar to [Page.GetWindow].\nfunc (p *Page) MustGetWindow() *proto.BrowserBounds {\n\tbounds, err := p.GetWindow()\n\tp.e(err)\n\treturn bounds\n}\n\n// MustSetWindow is similar to [Page.SetWindow].\nfunc (p *Page) MustSetWindow(left, top, width, height int) *Page {\n\tp.e(p.SetWindow(&proto.BrowserBounds{\n\t\tLeft:        gson.Int(left),\n\t\tTop:         gson.Int(top),\n\t\tWidth:       gson.Int(width),\n\t\tHeight:      gson.Int(height),\n\t\tWindowState: proto.BrowserWindowStateNormal,\n\t}))\n\treturn p\n}\n\n// MustWindowMinimize is similar to [Page.WindowMinimize].\nfunc (p *Page) MustWindowMinimize() *Page {\n\tp.e(p.SetWindow(&proto.BrowserBounds{\n\t\tWindowState: proto.BrowserWindowStateMinimized,\n\t}))\n\treturn p\n}\n\n// MustWindowMaximize is similar to [Page.WindowMaximize].\nfunc (p *Page) MustWindowMaximize() *Page {\n\tp.e(p.SetWindow(&proto.BrowserBounds{\n\t\tWindowState: proto.BrowserWindowStateMaximized,\n\t}))\n\treturn p\n}\n\n// MustWindowFullscreen is similar to [Page.WindowFullscreen].\nfunc (p *Page) MustWindowFullscreen() *Page {\n\tp.e(p.SetWindow(&proto.BrowserBounds{\n\t\tWindowState: proto.BrowserWindowStateFullscreen,\n\t}))\n\treturn p\n}\n\n// MustWindowNormal is similar to [Page.WindowNormal].\nfunc (p *Page) MustWindowNormal() *Page {\n\tp.e(p.SetWindow(&proto.BrowserBounds{\n\t\tWindowState: proto.BrowserWindowStateNormal,\n\t}))\n\treturn p\n}\n\n// MustSetViewport is similar to [Page.SetViewport].\nfunc (p *Page) MustSetViewport(width, height int, deviceScaleFactor float64, mobile bool) *Page {\n\tp.e(p.SetViewport(&proto.EmulationSetDeviceMetricsOverride{\n\t\tWidth:             width,\n\t\tHeight:            height,\n\t\tDeviceScaleFactor: deviceScaleFactor,\n\t\tMobile:            mobile,\n\t}))\n\treturn p\n}\n\n// MustEmulate is similar to [Page.Emulate].\nfunc (p *Page) MustEmulate(device devices.Device) *Page {\n\tp.e(p.Emulate(device))\n\treturn p\n}\n\n// MustStopLoading is similar to [Page.StopLoading].\nfunc (p *Page) MustStopLoading() *Page {\n\tp.e(p.StopLoading())\n\treturn p\n}\n\n// MustClose is similar to [Page.Close].\nfunc (p *Page) MustClose() {\n\tp.e(p.Close())\n}\n\n// MustHandleDialog is similar to [Page.HandleDialog].\nfunc (p *Page) MustHandleDialog() (wait func() *proto.PageJavascriptDialogOpening, handle func(bool, string)) {\n\tw, h := p.HandleDialog()\n\treturn w, func(accept bool, promptText string) {\n\t\tp.e(h(&proto.PageHandleJavaScriptDialog{\n\t\t\tAccept:     accept,\n\t\t\tPromptText: promptText,\n\t\t}))\n\t}\n}\n\n// MustHandleFileDialog is similar to [Page.HandleFileDialog].\nfunc (p *Page) MustHandleFileDialog() func(...string) {\n\tsetFiles, err := p.HandleFileDialog()\n\tp.e(err)\n\treturn func(paths ...string) {\n\t\tp.e(setFiles(paths))\n\t}\n}\n\n// MustScreenshot is similar to [Page.Screenshot].\n// If the toFile is \"\", it Page.will save output to \"tmp/screenshots\" folder, time as the file name.\nfunc (p *Page) MustScreenshot(toFile ...string) []byte {\n\tbin, err := p.Screenshot(false, nil)\n\tp.e(err)\n\tp.e(saveFile(saveFileTypeScreenshot, bin, toFile))\n\treturn bin\n}\n\n// MustCaptureDOMSnapshot is similar to [Page.CaptureDOMSnapshot].\nfunc (p *Page) MustCaptureDOMSnapshot() (domSnapshot *proto.DOMSnapshotCaptureSnapshotResult) {\n\tdomSnapshot, err := p.CaptureDOMSnapshot()\n\tp.e(err)\n\treturn domSnapshot\n}\n\n// MustTriggerFavicon is similar to [PageTriggerFavicon].\nfunc (p *Page) MustTriggerFavicon() *Page {\n\tp.e(p.TriggerFavicon())\n\treturn p\n}\n\n// MustScreenshotFullPage is similar to [Page.ScreenshotFullPage].\n// If the toFile is \"\", it Page.will save output to \"tmp/screenshots\" folder, time as the file name.\nfunc (p *Page) MustScreenshotFullPage(toFile ...string) []byte {\n\tbin, err := p.Screenshot(true, nil)\n\tp.e(err)\n\tp.e(saveFile(saveFileTypeScreenshot, bin, toFile))\n\treturn bin\n}\n\n// MustScrollScreenshot is similar to [Page.ScrollScreenshot].\n// If the toFile is \"\", it Page.will save output to \"tmp/screenshots\" folder, time as the file name.\nfunc (p *Page) MustScrollScreenshot(toFile ...string) []byte {\n\tbin, err := p.ScrollScreenshot(nil)\n\tp.e(err)\n\tp.e(saveFile(saveFileTypeScreenshot, bin, toFile))\n\treturn bin\n}\n\n// MustPDF is similar to [Page.PDF].\n// If the toFile is \"\", it Page.will save output to \"tmp/pdf\" folder, time as the file name.\nfunc (p *Page) MustPDF(toFile ...string) []byte {\n\tr, err := p.PDF(&proto.PagePrintToPDF{})\n\tp.e(err)\n\tbin, err := io.ReadAll(r)\n\tp.e(err)\n\n\tp.e(saveFile(saveFileTypePDF, bin, toFile))\n\treturn bin\n}\n\n// MustWaitOpen is similar to [Page.WaitOpen].\nfunc (p *Page) MustWaitOpen() (wait func() (newPage *Page)) {\n\tw := p.WaitOpen()\n\treturn func() *Page {\n\t\tpage, err := w()\n\t\tp.e(err)\n\t\treturn page\n\t}\n}\n\n// MustWaitNavigation is similar to [Page.WaitNavigation].\nfunc (p *Page) MustWaitNavigation() func() {\n\treturn p.WaitNavigation(proto.PageLifecycleEventNameNetworkAlmostIdle)\n}\n\n// MustWaitRequestIdle is similar to [Page.WaitRequestIdle].\nfunc (p *Page) MustWaitRequestIdle(excludes ...string) (wait func()) {\n\treturn p.WaitRequestIdle(300*time.Millisecond, nil, excludes, nil)\n}\n\n// MustWaitIdle is similar to [Page.WaitIdle].\nfunc (p *Page) MustWaitIdle() *Page {\n\tp.e(p.WaitIdle(time.Minute))\n\treturn p\n}\n\n// MustWaitDOMStable is similar to [Page.WaitDOMStable].\nfunc (p *Page) MustWaitDOMStable() *Page {\n\tp.e(p.WaitDOMStable(time.Second, 0))\n\treturn p\n}\n\n// MustWaitStable is similar to [Page.WaitStable].\nfunc (p *Page) MustWaitStable() *Page {\n\tp.e(p.WaitStable(time.Second))\n\treturn p\n}\n\n// MustWaitLoad is similar to [Page.WaitLoad].\nfunc (p *Page) MustWaitLoad() *Page {\n\tp.e(p.WaitLoad())\n\treturn p\n}\n\n// MustAddScriptTag is similar to [Page.AddScriptTag].\nfunc (p *Page) MustAddScriptTag(url string) *Page {\n\tp.e(p.AddScriptTag(url, \"\"))\n\treturn p\n}\n\n// MustAddStyleTag is similar to [Page.AddStyleTag].\nfunc (p *Page) MustAddStyleTag(url string) *Page {\n\tp.e(p.AddStyleTag(url, \"\"))\n\treturn p\n}\n\n// MustEvalOnNewDocument is similar to [Page.EvalOnNewDocument].\nfunc (p *Page) MustEvalOnNewDocument(js string) {\n\t_, err := p.EvalOnNewDocument(js)\n\tp.e(err)\n}\n\n// MustExpose is similar to [Page.Expose].\nfunc (p *Page) MustExpose(name string, fn func(gson.JSON) (interface{}, error)) (stop func()) {\n\ts, err := p.Expose(name, fn)\n\tp.e(err)\n\treturn func() { p.e(s()) }\n}\n\n// MustEval is similar to [Page.Eval].\nfunc (p *Page) MustEval(js string, params ...interface{}) gson.JSON {\n\tres, err := p.Eval(js, params...)\n\tp.e(err)\n\treturn res.Value\n}\n\n// MustEvaluate is similar to [Page.Evaluate].\nfunc (p *Page) MustEvaluate(opts *EvalOptions) *proto.RuntimeRemoteObject {\n\tres, err := p.Evaluate(opts)\n\tp.e(err)\n\treturn res\n}\n\n// MustWait is similar to [Page.Wait].\nfunc (p *Page) MustWait(js string, params ...interface{}) *Page {\n\tp.e(p.Wait(Eval(js, params...)))\n\treturn p\n}\n\n// MustWaitElementsMoreThan is similar to [Page.WaitElementsMoreThan].\nfunc (p *Page) MustWaitElementsMoreThan(selector string, num int) *Page {\n\tp.e(p.WaitElementsMoreThan(selector, num))\n\treturn p\n}\n\n// MustObjectToJSON is similar to [Page.ObjectToJSON].\nfunc (p *Page) MustObjectToJSON(obj *proto.RuntimeRemoteObject) gson.JSON {\n\tj, err := p.ObjectToJSON(obj)\n\tp.e(err)\n\treturn j\n}\n\n// MustObjectsToJSON is similar to [Page.ObjectsToJSON].\nfunc (p *Page) MustObjectsToJSON(list []*proto.RuntimeRemoteObject) gson.JSON {\n\tarr := []interface{}{}\n\tfor _, obj := range list {\n\t\tj, err := p.ObjectToJSON(obj)\n\t\tp.e(err)\n\t\tarr = append(arr, j.Val())\n\t}\n\treturn gson.New(arr)\n}\n\n// MustElementFromNode is similar to [Page.ElementFromNode].\nfunc (p *Page) MustElementFromNode(node *proto.DOMNode) *Element {\n\tel, err := p.ElementFromNode(node)\n\tp.e(err)\n\treturn el\n}\n\n// MustElementFromPoint is similar to [Page.ElementFromPoint].\nfunc (p *Page) MustElementFromPoint(left, top int) *Element {\n\tel, err := p.ElementFromPoint(left, top)\n\tp.e(err)\n\treturn el\n}\n\n// MustRelease is similar to [Page.Release].\nfunc (p *Page) MustRelease(obj *proto.RuntimeRemoteObject) *Page {\n\tp.e(p.Release(obj))\n\treturn p\n}\n\n// MustHas is similar to [Page.Has].\nfunc (p *Page) MustHas(selector string) bool {\n\thas, _, err := p.Has(selector)\n\tp.e(err)\n\treturn has\n}\n\n// MustHasX is similar to [Page.HasX].\nfunc (p *Page) MustHasX(selector string) bool {\n\thas, _, err := p.HasX(selector)\n\tp.e(err)\n\treturn has\n}\n\n// MustHasR is similar to [Page.HasR].\nfunc (p *Page) MustHasR(selector, regex string) bool {\n\thas, _, err := p.HasR(selector, regex)\n\tp.e(err)\n\treturn has\n}\n\n// MustSearch is similar to [Page.Search].\n// It only returns the first element in the search result.\nfunc (p *Page) MustSearch(query string) *Element {\n\tres, err := p.Search(query)\n\tp.e(err)\n\tres.Release()\n\treturn res.First\n}\n\n// MustElement is similar to [Page.Element].\nfunc (p *Page) MustElement(selector string) *Element {\n\tel, err := p.Element(selector)\n\tp.e(err)\n\treturn el\n}\n\n// MustElementR is similar to [Page.ElementR].\nfunc (p *Page) MustElementR(selector, jsRegex string) *Element {\n\tel, err := p.ElementR(selector, jsRegex)\n\tp.e(err)\n\treturn el\n}\n\n// MustElementX is similar to [Page.ElementX].\nfunc (p *Page) MustElementX(xPath string) *Element {\n\tel, err := p.ElementX(xPath)\n\tp.e(err)\n\treturn el\n}\n\n// MustElementByJS is similar to [Page.ElementByJS].\nfunc (p *Page) MustElementByJS(js string, params ...interface{}) *Element {\n\tel, err := p.ElementByJS(Eval(js, params...))\n\tp.e(err)\n\treturn el\n}\n\n// MustElements is similar to [Page.Elements].\nfunc (p *Page) MustElements(selector string) Elements {\n\tlist, err := p.Elements(selector)\n\tp.e(err)\n\treturn list\n}\n\n// MustElementsX is similar to [Page.ElementsX].\nfunc (p *Page) MustElementsX(xpath string) Elements {\n\tlist, err := p.ElementsX(xpath)\n\tp.e(err)\n\treturn list\n}\n\n// MustElementsByJS is similar to [Page.ElementsByJS].\nfunc (p *Page) MustElementsByJS(js string, params ...interface{}) Elements {\n\tlist, err := p.ElementsByJS(Eval(js, params...))\n\tp.e(err)\n\treturn list\n}\n\n// MustElementByJS is similar to [RaceContext.ElementByJS].\nfunc (rc *RaceContext) MustElementByJS(js string, params []interface{}) *RaceContext {\n\treturn rc.ElementByJS(Eval(js, params...))\n}\n\n// MustHandle is similar to [RaceContext.Handle].\nfunc (rc *RaceContext) MustHandle(callback func(*Element)) *RaceContext {\n\treturn rc.Handle(func(e *Element) error {\n\t\tcallback(e)\n\t\treturn nil\n\t})\n}\n\n// MustDo is similar to [RaceContext.Do].\nfunc (rc *RaceContext) MustDo() *Element {\n\tel, err := rc.Do()\n\trc.page.e(err)\n\treturn el\n}\n\n// MustMoveTo is similar to [Mouse.Move].\nfunc (m *Mouse) MustMoveTo(x, y float64) *Mouse {\n\tm.page.e(m.MoveTo(proto.NewPoint(x, y)))\n\treturn m\n}\n\n// MustScroll is similar to [Mouse.Scroll].\nfunc (m *Mouse) MustScroll(x, y float64) *Mouse {\n\tm.page.e(m.Scroll(x, y, 0))\n\treturn m\n}\n\n// MustDown is similar to [Mouse.Down].\nfunc (m *Mouse) MustDown(button proto.InputMouseButton) *Mouse {\n\tm.page.e(m.Down(button, 1))\n\treturn m\n}\n\n// MustUp is similar to [Mouse.Up].\nfunc (m *Mouse) MustUp(button proto.InputMouseButton) *Mouse {\n\tm.page.e(m.Up(button, 1))\n\treturn m\n}\n\n// MustClick is similar to [Mouse.Click].\nfunc (m *Mouse) MustClick(button proto.InputMouseButton) *Mouse {\n\tm.page.e(m.Click(button, 1))\n\treturn m\n}\n\n// MustType is similar to [Keyboard.Type].\nfunc (k *Keyboard) MustType(key ...input.Key) *Keyboard {\n\tk.page.e(k.Type(key...))\n\treturn k\n}\n\n// MustDo is similar to [KeyActions.Do].\nfunc (ka *KeyActions) MustDo() {\n\tka.keyboard.page.e(ka.Do())\n}\n\n// MustInsertText is similar to [Page.InsertText].\nfunc (p *Page) MustInsertText(text string) *Page {\n\tp.e(p.InsertText(text))\n\treturn p\n}\n\n// MustStart is similar to [Touch.Start].\nfunc (t *Touch) MustStart(points ...*proto.InputTouchPoint) *Touch {\n\tt.page.e(t.Start(points...))\n\treturn t\n}\n\n// MustMove is similar to [Touch.Move].\nfunc (t *Touch) MustMove(points ...*proto.InputTouchPoint) *Touch {\n\tt.page.e(t.Move(points...))\n\treturn t\n}\n\n// MustEnd is similar to [Touch.End].\nfunc (t *Touch) MustEnd() *Touch {\n\tt.page.e(t.End())\n\treturn t\n}\n\n// MustCancel is similar to [Touch.Cancel].\nfunc (t *Touch) MustCancel() *Touch {\n\tt.page.e(t.Cancel())\n\treturn t\n}\n\n// MustTap is similar to [Touch.Tap].\nfunc (t *Touch) MustTap(x, y float64) *Touch {\n\tt.page.e(t.Tap(x, y))\n\treturn t\n}\n\n// WithPanic returns an element clone with the specified panic function.\n// The fail must stop the current goroutine's execution immediately, such as use [runtime.Goexit] or panic inside it.\nfunc (el *Element) WithPanic(fail func(interface{})) *Element {\n\tn := *el\n\tn.e = genE(fail)\n\treturn &n\n}\n\n// MustDescribe is similar to [Element.Describe].\nfunc (el *Element) MustDescribe() *proto.DOMNode {\n\tnode, err := el.Describe(1, false)\n\tel.e(err)\n\treturn node\n}\n\n// MustShadowRoot is similar to [Element.ShadowRoot].\nfunc (el *Element) MustShadowRoot() *Element {\n\tnode, err := el.ShadowRoot()\n\tel.e(err)\n\treturn node\n}\n\n// MustFrame is similar to [Element.Frame].\nfunc (el *Element) MustFrame() *Page {\n\tp, err := el.Frame()\n\tel.e(err)\n\treturn p\n}\n\n// MustFocus is similar to [Element.Focus].\nfunc (el *Element) MustFocus() *Element {\n\tel.e(el.Focus())\n\treturn el\n}\n\n// MustScrollIntoView is similar to [Element.ScrollIntoView].\nfunc (el *Element) MustScrollIntoView() *Element {\n\tel.e(el.ScrollIntoView())\n\treturn el\n}\n\n// MustHover is similar to [Element.Hover].\nfunc (el *Element) MustHover() *Element {\n\tel.e(el.Hover())\n\treturn el\n}\n\n// MustClick is similar to [Element.Click].\nfunc (el *Element) MustClick() *Element {\n\tel.e(el.Click(proto.InputMouseButtonLeft, 1))\n\treturn el\n}\n\n// MustDoubleClick is similar to [Element.Click].\nfunc (el *Element) MustDoubleClick() *Element {\n\tel.e(el.Click(proto.InputMouseButtonLeft, 2))\n\treturn el\n}\n\n// MustTap is similar to [Element.Tap].\nfunc (el *Element) MustTap() *Element {\n\tel.e(el.Tap())\n\treturn el\n}\n\n// MustInteractable is similar to [Element.Interactable].\nfunc (el *Element) MustInteractable() bool {\n\t_, err := el.Interactable()\n\tif errors.Is(err, &NotInteractableError{}) {\n\t\treturn false\n\t}\n\tel.e(err)\n\treturn true\n}\n\n// MustWaitInteractable is similar to [Element.WaitInteractable].\nfunc (el *Element) MustWaitInteractable() *Element {\n\tel.e(el.WaitInteractable())\n\treturn el\n}\n\n// MustType is similar to [Element.Type].\nfunc (el *Element) MustType(keys ...input.Key) *Element {\n\tel.e(el.Type(keys...))\n\treturn el\n}\n\n// MustKeyActions is similar to [Element.KeyActions].\nfunc (el *Element) MustKeyActions() *KeyActions {\n\tka, err := el.KeyActions()\n\tel.e(err)\n\treturn ka\n}\n\n// MustSelectText is similar to [Element.SelectText].\nfunc (el *Element) MustSelectText(regex string) *Element {\n\tel.e(el.SelectText(regex))\n\treturn el\n}\n\n// MustSelectAllText is similar to [Element.SelectAllText].\nfunc (el *Element) MustSelectAllText() *Element {\n\tel.e(el.SelectAllText())\n\treturn el\n}\n\n// MustInput is similar to [Element.Input].\nfunc (el *Element) MustInput(text string) *Element {\n\tel.e(el.Input(text))\n\treturn el\n}\n\n// MustInputTime is similar to [Element.Input].\nfunc (el *Element) MustInputTime(t time.Time) *Element {\n\tel.e(el.InputTime(t))\n\treturn el\n}\n\n// MustInputColor is similar to [Element.InputColor].\nfunc (el *Element) MustInputColor(color string) *Element {\n\tel.e(el.InputColor(color))\n\treturn el\n}\n\n// MustBlur is similar to [Element.Blur].\nfunc (el *Element) MustBlur() *Element {\n\tel.e(el.Blur())\n\treturn el\n}\n\n// MustSelect is similar to [Element.Select].\nfunc (el *Element) MustSelect(selectors ...string) *Element {\n\tel.e(el.Select(selectors, true, SelectorTypeText))\n\treturn el\n}\n\n// MustMatches is similar to [Element.Matches].\nfunc (el *Element) MustMatches(selector string) bool {\n\tres, err := el.Matches(selector)\n\tel.e(err)\n\treturn res\n}\n\n// MustAttribute is similar to [Element.Attribute].\nfunc (el *Element) MustAttribute(name string) *string {\n\tattr, err := el.Attribute(name)\n\tel.e(err)\n\treturn attr\n}\n\n// MustProperty is similar to [Element.Property].\nfunc (el *Element) MustProperty(name string) gson.JSON {\n\tprop, err := el.Property(name)\n\tel.e(err)\n\treturn prop\n}\n\n// MustDisabled is similar to [Element.Disabled].\nfunc (el *Element) MustDisabled() bool {\n\tdisabled, err := el.Disabled()\n\tel.e(err)\n\treturn disabled\n}\n\n// MustContainsElement is similar to [Element.ContainsElement].\nfunc (el *Element) MustContainsElement(target *Element) bool {\n\tcontains, err := el.ContainsElement(target)\n\tel.e(err)\n\treturn contains\n}\n\n// MustSetFiles is similar to [Element.SetFiles].\nfunc (el *Element) MustSetFiles(paths ...string) *Element {\n\tel.e(el.SetFiles(paths))\n\treturn el\n}\n\n// MustSetDocumentContent is similar to [Page.SetDocumentContent].\nfunc (p *Page) MustSetDocumentContent(html string) *Page {\n\tp.e(p.SetDocumentContent(html))\n\treturn p\n}\n\n// MustText is similar to [Element.Text].\nfunc (el *Element) MustText() string {\n\ts, err := el.Text()\n\tel.e(err)\n\treturn s\n}\n\n// MustHTML is similar to [Element.HTML].\nfunc (el *Element) MustHTML() string {\n\ts, err := el.HTML()\n\tel.e(err)\n\treturn s\n}\n\n// MustVisible is similar to [Element.Visible].\nfunc (el *Element) MustVisible() bool {\n\tv, err := el.Visible()\n\tel.e(err)\n\treturn v\n}\n\n// MustWaitLoad is similar to [Element.WaitLoad].\nfunc (el *Element) MustWaitLoad() *Element {\n\tel.e(el.WaitLoad())\n\treturn el\n}\n\n// MustWaitStable is similar to [Element.WaitStable].\nfunc (el *Element) MustWaitStable() *Element {\n\tel.e(el.WaitStable(300 * time.Millisecond))\n\treturn el\n}\n\n// MustWait is similar to [Element.Wait].\nfunc (el *Element) MustWait(js string, params ...interface{}) *Element {\n\tel.e(el.Wait(Eval(js, params...)))\n\treturn el\n}\n\n// MustWaitVisible is similar to [Element.WaitVisible].\nfunc (el *Element) MustWaitVisible() *Element {\n\tel.e(el.WaitVisible())\n\treturn el\n}\n\n// MustWaitInvisible is similar to [Element.WaitInvisible]..\nfunc (el *Element) MustWaitInvisible() *Element {\n\tel.e(el.WaitInvisible())\n\treturn el\n}\n\n// MustWaitEnabled is similar to [Element.WaitEnabled].\nfunc (el *Element) MustWaitEnabled() *Element {\n\tel.e(el.WaitEnabled())\n\treturn el\n}\n\n// MustWaitWritable is similar to [Element.WaitWritable].\nfunc (el *Element) MustWaitWritable() *Element {\n\tel.e(el.WaitWritable())\n\treturn el\n}\n\n// MustShape is similar to [Element.Shape].\nfunc (el *Element) MustShape() *proto.DOMGetContentQuadsResult {\n\tshape, err := el.Shape()\n\tel.e(err)\n\treturn shape\n}\n\n// MustCanvasToImage is similar to [Element.CanvasToImage].\nfunc (el *Element) MustCanvasToImage() []byte {\n\tbin, err := el.CanvasToImage(\"\", -1)\n\tel.e(err)\n\treturn bin\n}\n\n// MustResource is similar to [Element.Resource].\nfunc (el *Element) MustResource() []byte {\n\tbin, err := el.Resource()\n\tel.e(err)\n\treturn bin\n}\n\n// MustBackgroundImage is similar to [Element.BackgroundImage].\nfunc (el *Element) MustBackgroundImage() []byte {\n\tbin, err := el.BackgroundImage()\n\tel.e(err)\n\treturn bin\n}\n\n// MustScreenshot is similar to [Element.Screenshot].\nfunc (el *Element) MustScreenshot(toFile ...string) []byte {\n\tbin, err := el.Screenshot(proto.PageCaptureScreenshotFormatPng, 0)\n\tel.e(err)\n\tel.e(saveFile(saveFileTypeScreenshot, bin, toFile))\n\treturn bin\n}\n\n// MustRelease is similar to [Element.Release].\nfunc (el *Element) MustRelease() {\n\tel.e(el.Release())\n}\n\n// MustRemove is similar to [Element.Remove].\nfunc (el *Element) MustRemove() {\n\tel.e(el.Remove())\n}\n\n// MustEval is similar to [Element.Eval].\nfunc (el *Element) MustEval(js string, params ...interface{}) gson.JSON {\n\tres, err := el.Eval(js, params...)\n\tel.e(err)\n\treturn res.Value\n}\n\n// MustHas is similar to [Element.Has].\nfunc (el *Element) MustHas(selector string) bool {\n\thas, _, err := el.Has(selector)\n\tel.e(err)\n\treturn has\n}\n\n// MustHasX is similar to [Element.HasX].\nfunc (el *Element) MustHasX(selector string) bool {\n\thas, _, err := el.HasX(selector)\n\tel.e(err)\n\treturn has\n}\n\n// MustHasR is similar to [Element.HasR].\nfunc (el *Element) MustHasR(selector, regex string) bool {\n\thas, _, err := el.HasR(selector, regex)\n\tel.e(err)\n\treturn has\n}\n\n// MustElement is similar to [Element.Element].\nfunc (el *Element) MustElement(selector string) *Element {\n\tel, err := el.Element(selector)\n\tel.e(err)\n\treturn el\n}\n\n// MustElementX is similar to [Element.ElementX].\nfunc (el *Element) MustElementX(xpath string) *Element {\n\tel, err := el.ElementX(xpath)\n\tel.e(err)\n\treturn el\n}\n\n// MustElementByJS is similar to [Element.ElementByJS].\nfunc (el *Element) MustElementByJS(js string, params ...interface{}) *Element {\n\tel, err := el.ElementByJS(Eval(js, params...))\n\tel.e(err)\n\treturn el\n}\n\n// MustParent is similar to [Element.Parent].\nfunc (el *Element) MustParent() *Element {\n\tparent, err := el.Parent()\n\tel.e(err)\n\treturn parent\n}\n\n// MustParents is similar to [Element.Parents].\nfunc (el *Element) MustParents(selector string) Elements {\n\tlist, err := el.Parents(selector)\n\tel.e(err)\n\treturn list\n}\n\n// MustNext is similar to [Element.Next].\nfunc (el *Element) MustNext() *Element {\n\tparent, err := el.Next()\n\tel.e(err)\n\treturn parent\n}\n\n// MustPrevious is similar to [Element.Previous].\nfunc (el *Element) MustPrevious() *Element {\n\tparent, err := el.Previous()\n\tel.e(err)\n\treturn parent\n}\n\n// MustElementR is similar to [Element.ElementR].\nfunc (el *Element) MustElementR(selector, regex string) *Element {\n\tsub, err := el.ElementR(selector, regex)\n\tel.e(err)\n\treturn sub\n}\n\n// MustElements is similar to [Element.Elements].\nfunc (el *Element) MustElements(selector string) Elements {\n\tlist, err := el.Elements(selector)\n\tel.e(err)\n\treturn list\n}\n\n// MustElementsX is similar to [Element.ElementsX].\nfunc (el *Element) MustElementsX(xpath string) Elements {\n\tlist, err := el.ElementsX(xpath)\n\tel.e(err)\n\treturn list\n}\n\n// MustElementsByJS is similar to [Element.ElementsByJS].\nfunc (el *Element) MustElementsByJS(js string, params ...interface{}) Elements {\n\tlist, err := el.ElementsByJS(Eval(js, params...))\n\tel.e(err)\n\treturn list\n}\n\n// MustAdd is similar to [HijackRouter.Add].\nfunc (r *HijackRouter) MustAdd(pattern string, handler func(*Hijack)) *HijackRouter {\n\tr.browser.e(r.Add(pattern, \"\", handler))\n\treturn r\n}\n\n// MustRemove is similar to [HijackRouter.Remove].\nfunc (r *HijackRouter) MustRemove(pattern string) *HijackRouter {\n\tr.browser.e(r.Remove(pattern))\n\treturn r\n}\n\n// MustStop is similar to [HijackRouter.Stop].\nfunc (r *HijackRouter) MustStop() {\n\tr.browser.e(r.Stop())\n}\n\n// MustLoadResponse is similar to [Hijack.LoadResponse].\nfunc (h *Hijack) MustLoadResponse() {\n\th.browser.e(h.LoadResponse(http.DefaultClient, true))\n}\n\n// MustEqual is similar to [Element.Equal].\nfunc (el *Element) MustEqual(elm *Element) bool {\n\tres, err := el.Equal(elm)\n\tel.e(err)\n\treturn res\n}\n\n// MustMoveMouseOut is similar to [Element.MoveMouseOut].\nfunc (el *Element) MustMoveMouseOut() *Element {\n\tel.e(el.MoveMouseOut())\n\treturn el\n}\n\n// MustGetXPath is similar to [Element.GetXPath].\nfunc (el *Element) MustGetXPath(optimized bool) string {\n\txpath, err := el.GetXPath(optimized)\n\tel.e(err)\n\treturn xpath\n}\n\n// MustGet an elem from the pool. Use the [Pool[T].Put] to make it reusable later.\nfunc (p Pool[T]) MustGet(create func() *T) *T {\n\telem := <-p\n\tif elem == nil {\n\t\telem = create()\n\t}\n\treturn elem\n}\n"
        },
        {
          "name": "must_test.go",
          "type": "blob",
          "size": 1.6923828125,
          "content": "package rod_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/proto\"\n)\n\nfunc TestBrowserWithPanic(t *testing.T) {\n\tg := setup(t)\n\n\tvar triggers int\n\ttrigger := func(x interface{}) {\n\t\ttriggers++\n\t\tpanic(x)\n\t}\n\n\tbrowser := g.browser.Sleeper(rod.NotFoundSleeper).WithPanic(trigger)\n\tg.Panic(func() { browser.MustPage(\"____\") })\n\tg.Eq(1, triggers)\n\n\tpage := browser.MustPage(g.blank())\n\tdefer page.MustClose()\n\n\tg.Panic(func() { page.MustElement(\"____\") })\n\tg.Eq(2, triggers)\n\n\tel := page.MustElement(\"html\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustClick()\n\t})\n\tg.Eq(3, triggers)\n}\n\nfunc TestPageWithPanic(t *testing.T) {\n\tg := setup(t)\n\n\tvar triggers int\n\ttrigger := func(x interface{}) {\n\t\ttriggers++\n\t\tpanic(x)\n\t}\n\n\tbrowser := g.browser.Sleeper(rod.NotFoundSleeper)\n\tg.Panic(func() { browser.MustPage(\"____\") })\n\tg.Eq(0, triggers)\n\n\tpage := browser.MustPage(g.blank()).WithPanic(trigger)\n\tdefer page.MustClose()\n\n\tg.Panic(func() { page.MustElement(\"____\") })\n\tg.Eq(1, triggers)\n\n\tel := page.MustElement(\"html\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustClick()\n\t})\n\tg.Eq(2, triggers)\n}\n\nfunc TestElementWithPanic(t *testing.T) {\n\tg := setup(t)\n\n\tvar triggers int\n\ttrigger := func(x interface{}) {\n\t\ttriggers++\n\t\tpanic(x)\n\t}\n\n\tbrowser := g.browser.Sleeper(rod.NotFoundSleeper)\n\tg.Panic(func() { browser.MustPage(\"____\") })\n\tg.Eq(0, triggers)\n\n\tpage := browser.MustPage(g.blank())\n\tdefer page.MustClose()\n\n\tg.Panic(func() { page.MustElement(\"____\") })\n\tg.Eq(0, triggers)\n\n\tel := page.MustElement(\"html\").WithPanic(trigger)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tel.MustClick()\n\t})\n\tg.Eq(1, triggers)\n}\n"
        },
        {
          "name": "page.go",
          "type": "blob",
          "size": 27.6484375,
          "content": "package rod\n\nimport (\n\t\"context\"\n\t\"crypto/md5\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/goob\"\n\t\"github.com/ysmood/got/lib/lcs\"\n\t\"github.com/ysmood/gson\"\n)\n\n// Page implements these interfaces.\nvar (\n\t_ proto.Client      = &Page{}\n\t_ proto.Contextable = &Page{}\n\t_ proto.Sessionable = &Page{}\n)\n\n// Page represents the webpage.\n// We try to hold as less states as possible.\n// When a page is closed by Rod or not all the ongoing operations an events on it will abort.\ntype Page struct {\n\t// TargetID is a unique ID for a remote page.\n\t// It's usually used in events sent from the browser to tell which page an event belongs to.\n\tTargetID proto.TargetTargetID\n\n\t// FrameID is a unique ID for a browsing context.\n\t// Usually, different FrameID means different javascript execution context.\n\t// Such as an iframe and the page it belongs to will have the same TargetID but different FrameIDs.\n\tFrameID proto.PageFrameID\n\n\t// SessionID is a unique ID for a page attachment to a controller.\n\t// It's usually used in transport layer to tell which page to send the control signal.\n\t// A page can attached to multiple controllers, the browser uses it distinguish controllers.\n\tSessionID proto.TargetSessionID\n\n\te eFunc\n\n\tctx context.Context\n\n\t// Used to abort all ongoing actions when a page closes.\n\tsessionCancel func()\n\n\troot *Page\n\n\tsleeper func() utils.Sleeper\n\n\tbrowser *Browser\n\tevent   *goob.Observable\n\n\t// devices\n\tMouse    *Mouse\n\tKeyboard *Keyboard\n\tTouch    *Touch\n\n\telement *Element // iframe only\n\n\tjsCtxLock   *sync.Mutex\n\tjsCtxID     *proto.RuntimeRemoteObjectID // use pointer so that page clones can share the change\n\thelpersLock *sync.Mutex\n\thelpers     map[proto.RuntimeRemoteObjectID]map[string]proto.RuntimeRemoteObjectID\n}\n\n// String interface.\nfunc (p *Page) String() string {\n\tid := p.TargetID\n\tif len(id) > 8 {\n\t\tid = id[:8]\n\t}\n\treturn fmt.Sprintf(\"<page:%s>\", id)\n}\n\n// IsIframe tells if it's iframe.\nfunc (p *Page) IsIframe() bool {\n\treturn p.element != nil\n}\n\n// GetSessionID interface.\nfunc (p *Page) GetSessionID() proto.TargetSessionID {\n\treturn p.SessionID\n}\n\n// Browser of the page.\nfunc (p *Page) Browser() *Browser {\n\treturn p.browser\n}\n\n// Info of the page, such as the URL or title of the page.\nfunc (p *Page) Info() (*proto.TargetTargetInfo, error) {\n\treturn p.browser.pageInfo(p.TargetID)\n}\n\n// HTML of the page.\nfunc (p *Page) HTML() (string, error) {\n\tel, err := p.Element(\"html\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn el.HTML()\n}\n\n// Cookies returns the page cookies. By default it will return the cookies for current page.\n// The urls is the list of URLs for which applicable cookies will be fetched.\nfunc (p *Page) Cookies(urls []string) ([]*proto.NetworkCookie, error) {\n\tif len(urls) == 0 {\n\t\tinfo, err := p.Info()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\turls = []string{info.URL}\n\t}\n\n\tres, err := proto.NetworkGetCookies{Urls: urls}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.Cookies, nil\n}\n\n// SetCookies is similar to Browser.SetCookies .\nfunc (p *Page) SetCookies(cookies []*proto.NetworkCookieParam) error {\n\tif cookies == nil {\n\t\treturn proto.NetworkClearBrowserCookies{}.Call(p)\n\t}\n\treturn proto.NetworkSetCookies{Cookies: cookies}.Call(p)\n}\n\n// SetExtraHeaders whether to always send extra HTTP headers with the requests from this page.\nfunc (p *Page) SetExtraHeaders(dict []string) (func(), error) {\n\theaders := proto.NetworkHeaders{}\n\n\tfor i := 0; i < len(dict); i += 2 {\n\t\theaders[dict[i]] = gson.New(dict[i+1])\n\t}\n\n\treturn p.EnableDomain(&proto.NetworkEnable{}), proto.NetworkSetExtraHTTPHeaders{Headers: headers}.Call(p)\n}\n\n// SetUserAgent (browser brand, accept-language, etc) of the page.\n// If req is nil, a default user agent will be used, a typical mac chrome.\nfunc (p *Page) SetUserAgent(req *proto.NetworkSetUserAgentOverride) error {\n\tif req == nil {\n\t\treq = devices.LaptopWithMDPIScreen.UserAgentEmulation()\n\t}\n\treturn req.Call(p)\n}\n\n// SetBlockedURLs For some requests that do not want to be triggered,\n// such as some dangerous operations, delete, quit logout, etc.\n// Wildcards ('*') are allowed, such as [\"*/api/logout/*\",\"delete\"].\n// NOTE: if you set empty pattern \"\", it will block all requests.\nfunc (p *Page) SetBlockedURLs(urls []string) error {\n\tif len(urls) == 0 {\n\t\treturn nil\n\t}\n\treturn proto.NetworkSetBlockedURLs{Urls: urls}.Call(p)\n}\n\n// Navigate to the url. If the url is empty, \"about:blank\" will be used.\n// It will return immediately after the server responds the http header.\nfunc (p *Page) Navigate(url string) error {\n\tif url == \"\" {\n\t\turl = \"about:blank\"\n\t}\n\n\t// try to stop loading\n\t_ = p.StopLoading()\n\n\tres, err := proto.PageNavigate{URL: url}.Call(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif res.ErrorText != \"\" {\n\t\treturn &NavigationError{res.ErrorText}\n\t}\n\n\tp.root.unsetJSCtxID()\n\n\treturn nil\n}\n\n// NavigateBack history.\nfunc (p *Page) NavigateBack() error {\n\t// Not using cdp API because it doesn't work for iframe\n\t_, err := p.Evaluate(Eval(`() => history.back()`).ByUser())\n\treturn err\n}\n\n// ResetNavigationHistory reset history.\nfunc (p *Page) ResetNavigationHistory() error {\n\terr := proto.PageResetNavigationHistory{}.Call(p)\n\treturn err\n}\n\n// GetNavigationHistory get navigation history.\nfunc (p *Page) GetNavigationHistory() (*proto.PageGetNavigationHistoryResult, error) {\n\treturn proto.PageGetNavigationHistory{}.Call(p)\n}\n\n// NavigateForward history.\nfunc (p *Page) NavigateForward() error {\n\t// Not using cdp API because it doesn't work for iframe\n\t_, err := p.Evaluate(Eval(`() => history.forward()`).ByUser())\n\treturn err\n}\n\n// Reload page.\nfunc (p *Page) Reload() error {\n\tp, cancel := p.WithCancel()\n\tdefer cancel()\n\n\twait := p.EachEvent(func(e *proto.PageFrameNavigated) bool {\n\t\treturn e.Frame.ID == p.FrameID\n\t})\n\n\t// Not using cdp API because it doesn't work for iframe\n\t_, err := p.Evaluate(Eval(`() => location.reload()`).ByUser())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twait()\n\n\tp.unsetJSCtxID()\n\n\treturn nil\n}\n\n// Activate (focuses) the page.\nfunc (p *Page) Activate() (*Page, error) {\n\terr := proto.TargetActivateTarget{TargetID: p.TargetID}.Call(p.browser)\n\treturn p, err\n}\n\nfunc (p *Page) getWindowID() (proto.BrowserWindowID, error) {\n\tres, err := proto.BrowserGetWindowForTarget{TargetID: p.TargetID}.Call(p)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn res.WindowID, err\n}\n\n// GetWindow position and size info.\nfunc (p *Page) GetWindow() (*proto.BrowserBounds, error) {\n\tid, err := p.getWindowID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := proto.BrowserGetWindowBounds{WindowID: id}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res.Bounds, nil\n}\n\n// SetWindow location and size.\nfunc (p *Page) SetWindow(bounds *proto.BrowserBounds) error {\n\tid, err := p.getWindowID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = proto.BrowserSetWindowBounds{WindowID: id, Bounds: bounds}.Call(p)\n\treturn err\n}\n\n// SetViewport overrides the values of device screen dimensions.\nfunc (p *Page) SetViewport(params *proto.EmulationSetDeviceMetricsOverride) error {\n\tif params == nil {\n\t\treturn proto.EmulationClearDeviceMetricsOverride{}.Call(p)\n\t}\n\treturn params.Call(p)\n}\n\n// SetDocumentContent sets the page document html content.\nfunc (p *Page) SetDocumentContent(html string) error {\n\treturn proto.PageSetDocumentContent{\n\t\tFrameID: p.FrameID,\n\t\tHTML:    html,\n\t}.Call(p)\n}\n\n// Emulate the device, such as iPhone9. If device is devices.Clear, it will clear the override.\nfunc (p *Page) Emulate(device devices.Device) error {\n\terr := p.SetViewport(device.MetricsEmulation())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = device.TouchEmulation().Call(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn p.SetUserAgent(device.UserAgentEmulation())\n}\n\n// StopLoading forces the page stop navigation and pending resource fetches.\nfunc (p *Page) StopLoading() error {\n\treturn proto.PageStopLoading{}.Call(p)\n}\n\n// Close tries to close page, running its beforeunload hooks, if has any.\nfunc (p *Page) Close() error {\n\tp.browser.targetsLock.Lock()\n\tdefer p.browser.targetsLock.Unlock()\n\n\tsuccess := true\n\tctx, cancel := context.WithCancel(p.ctx)\n\tdefer cancel()\n\tmessages := p.browser.Context(ctx).Event()\n\n\tfor {\n\t\terr := proto.PageClose{}.Call(p)\n\t\tif errors.Is(err, cdp.ErrNotAttachedToActivePage) {\n\t\t\t// TODO: I don't know why chromium doesn't allow us to close a page while it's navigating.\n\t\t\t// Looks like a bug in chromium.\n\t\t\tutils.Sleep(0.1)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbreak\n\t}\n\n\tfor msg := range messages {\n\t\tstop := false\n\n\t\tdestroyed := proto.TargetTargetDestroyed{}\n\t\tclosed := proto.PageJavascriptDialogClosed{}\n\t\tif msg.Load(&destroyed) {\n\t\t\tstop = destroyed.TargetID == p.TargetID\n\t\t} else if msg.SessionID == p.SessionID && msg.Load(&closed) {\n\t\t\tsuccess = closed.Result\n\t\t\tstop = !success\n\t\t}\n\n\t\tif stop {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif success {\n\t\tp.cleanupStates()\n\t} else {\n\t\treturn &PageCloseCanceledError{}\n\t}\n\n\treturn nil\n}\n\n// TriggerFavicon supports when browser in headless mode\n// to trigger favicon's request. Pay attention to this\n// function only supported when browser in headless mode,\n// if you call it in no-headless mode, it will raise an error\n// with the message \"browser is no-headless\".\nfunc (p *Page) TriggerFavicon() error {\n\t// check if browser whether in headless mode\n\t// if not in headless mode then raise error\n\tif !p.browser.isHeadless() {\n\t\treturn errors.New(\"browser is no-headless\")\n\t}\n\n\t_, err := p.Evaluate(evalHelper(js.TriggerFavicon).ByPromise())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// HandleDialog accepts or dismisses next JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).\n// Because modal dialog will block js, usually you have to trigger the dialog in another goroutine.\n// For example:\n//\n//\twait, handle := page.MustHandleDialog()\n//\tgo page.MustElement(\"button\").MustClick()\n//\twait()\n//\thandle(true, \"\")\nfunc (p *Page) HandleDialog() (\n\twait func() *proto.PageJavascriptDialogOpening,\n\thandle func(*proto.PageHandleJavaScriptDialog) error,\n) {\n\trestore := p.EnableDomain(&proto.PageEnable{})\n\n\tvar e proto.PageJavascriptDialogOpening\n\tw := p.WaitEvent(&e)\n\n\treturn func() *proto.PageJavascriptDialogOpening {\n\t\t\tw()\n\t\t\treturn &e\n\t\t}, func(h *proto.PageHandleJavaScriptDialog) error {\n\t\t\tdefer restore()\n\t\t\treturn h.Call(p)\n\t\t}\n}\n\n// HandleFileDialog return a functions that waits for the next file chooser dialog pops up and returns the element\n// for the event.\nfunc (p *Page) HandleFileDialog() (func([]string) error, error) {\n\terr := proto.PageSetInterceptFileChooserDialog{Enabled: true}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar e proto.PageFileChooserOpened\n\tw := p.WaitEvent(&e)\n\n\treturn func(paths []string) error {\n\t\tw()\n\n\t\terr := proto.PageSetInterceptFileChooserDialog{Enabled: false}.Call(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn proto.DOMSetFileInputFiles{\n\t\t\tFiles:         utils.AbsolutePaths(paths),\n\t\t\tBackendNodeID: e.BackendNodeID,\n\t\t}.Call(p)\n\t}, nil\n}\n\n// Screenshot captures the screenshot of current page.\nfunc (p *Page) Screenshot(fullPage bool, req *proto.PageCaptureScreenshot) ([]byte, error) {\n\tif req == nil {\n\t\treq = &proto.PageCaptureScreenshot{}\n\t}\n\tif fullPage {\n\t\tmetrics, err := proto.PageGetLayoutMetrics{}.Call(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif metrics.CSSContentSize == nil {\n\t\t\treturn nil, errors.New(\"failed to get css content size\")\n\t\t}\n\n\t\toldView := proto.EmulationSetDeviceMetricsOverride{}\n\t\tset := p.LoadState(&oldView)\n\t\tview := oldView\n\t\tview.Width = int(metrics.CSSContentSize.Width)\n\t\tview.Height = int(metrics.CSSContentSize.Height)\n\n\t\terr = p.SetViewport(&view)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdefer func() { // try to recover the viewport\n\t\t\tif !set {\n\t\t\t\t_ = proto.EmulationClearDeviceMetricsOverride{}.Call(p)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_ = p.SetViewport(&oldView)\n\t\t}()\n\t}\n\n\tshot, err := req.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn shot.Data, nil\n}\n\n// ScrollScreenshotOptions is the options for the ScrollScreenshot.\ntype ScrollScreenshotOptions struct {\n\t// Format (optional) Image compression format (defaults to png).\n\tFormat proto.PageCaptureScreenshotFormat `json:\"format,omitempty\"`\n\n\t// Quality (optional) Compression quality from range [0..100] (jpeg only).\n\tQuality *int `json:\"quality,omitempty\"`\n\n\t// FixedTop (optional) The number of pixels to skip from the top.\n\t// It is suitable for optimizing the screenshot effect when there is a fixed\n\t// positioning element at the top of the page.\n\tFixedTop float64\n\n\t// FixedBottom (optional) The number of pixels to skip from the bottom.\n\tFixedBottom float64\n\n\t// WaitPerScroll until no animation (default is 300ms)\n\tWaitPerScroll time.Duration\n}\n\n// ScrollScreenshot Scroll screenshot does not adjust the size of the viewport,\n// but achieves it by scrolling and capturing screenshots in a loop, and then stitching them together.\n// Note that this method also has a flaw: when there are elements with fixed\n// positioning on the page (usually header navigation components),\n// these elements will appear repeatedly, you can set the FixedTop parameter to optimize it.\n//\n// Only support png and jpeg format yet, webP is not supported because no suitable processing\n// library was found in golang.\nfunc (p *Page) ScrollScreenshot(opt *ScrollScreenshotOptions) ([]byte, error) {\n\tif opt == nil {\n\t\topt = &ScrollScreenshotOptions{}\n\t}\n\tif opt.WaitPerScroll == 0 {\n\t\topt.WaitPerScroll = time.Millisecond * 300\n\t}\n\n\tmetrics, err := proto.PageGetLayoutMetrics{}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif metrics.CSSContentSize == nil || metrics.CSSVisualViewport == nil {\n\t\treturn nil, errors.New(\"failed to get css content size\")\n\t}\n\n\tviewpointHeight := metrics.CSSVisualViewport.ClientHeight\n\tcontentHeight := metrics.CSSContentSize.Height\n\n\tvar scrollTop float64\n\tvar images []utils.ImgWithBox\n\n\tfor {\n\t\tclip := &proto.PageViewport{\n\t\t\tX:     0,\n\t\t\tY:     scrollTop,\n\t\t\tWidth: metrics.CSSVisualViewport.ClientWidth,\n\t\t\tScale: 1,\n\t\t}\n\n\t\tscrollY := viewpointHeight - (opt.FixedTop + opt.FixedBottom)\n\t\tif scrollTop+viewpointHeight > contentHeight {\n\t\t\tclip.Height = contentHeight - scrollTop\n\t\t} else {\n\t\t\tclip.Height = scrollY\n\t\t\tif scrollTop != 0 {\n\t\t\t\tclip.Y += opt.FixedTop\n\t\t\t}\n\t\t}\n\n\t\treq := &proto.PageCaptureScreenshot{\n\t\t\tFormat:                opt.Format,\n\t\t\tQuality:               opt.Quality,\n\t\t\tClip:                  clip,\n\t\t\tFromSurface:           false,\n\t\t\tCaptureBeyondViewport: false,\n\t\t\tOptimizeForSpeed:      false,\n\t\t}\n\t\tshot, err := req.Call(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\timages = append(images, utils.ImgWithBox{Img: shot.Data})\n\n\t\tscrollTop += scrollY\n\t\tif scrollTop >= contentHeight {\n\t\t\tbreak\n\t\t}\n\n\t\terr = p.Mouse.Scroll(0, scrollY, 1)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"scroll error: %w\", err)\n\t\t}\n\n\t\terr = p.WaitDOMStable(opt.WaitPerScroll, 0)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"WaitDOMStable error: %w\", err)\n\t\t}\n\t}\n\n\tvar imgOption *utils.ImgOption\n\tif opt.Quality != nil {\n\t\timgOption = &utils.ImgOption{\n\t\t\tQuality: *opt.Quality,\n\t\t}\n\t}\n\tbs, err := utils.SplicePngVertical(images, opt.Format, imgOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bs, nil\n}\n\n// CaptureDOMSnapshot Returns a document snapshot, including the full DOM tree of the root node\n// (including iframes, template contents, and imported documents) in a flattened array,\n// as well as layout and white-listed computed style information for the nodes.\n// Shadow DOM in the returned DOM tree is flattened.\n// `Documents` The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.\n// `Strings` Shared string table that all string properties refer to with indexes.\n// Normally use `Strings` is enough.\nfunc (p *Page) CaptureDOMSnapshot() (domSnapshot *proto.DOMSnapshotCaptureSnapshotResult, err error) {\n\t_ = proto.DOMSnapshotEnable{}.Call(p)\n\n\tsnapshot, err := proto.DOMSnapshotCaptureSnapshot{\n\t\tComputedStyles:                 []string{},\n\t\tIncludePaintOrder:              true,\n\t\tIncludeDOMRects:                true,\n\t\tIncludeBlendedBackgroundColors: true,\n\t\tIncludeTextColorOpacities:      true,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn snapshot, nil\n}\n\n// PDF prints page as PDF.\nfunc (p *Page) PDF(req *proto.PagePrintToPDF) (*StreamReader, error) {\n\treq.TransferMode = proto.PagePrintToPDFTransferModeReturnAsStream\n\tres, err := req.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewStreamReader(p, res.Stream), nil\n}\n\n// GetResource content by the url. Such as image, css, html, etc.\n// Use the [proto.PageGetResourceTree] to list all the resources.\nfunc (p *Page) GetResource(url string) ([]byte, error) {\n\tres, err := proto.PageGetResourceContent{\n\t\tFrameID: p.FrameID,\n\t\tURL:     url,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := res.Content\n\n\tvar bin []byte\n\tif res.Base64Encoded {\n\t\tbin, err = base64.StdEncoding.DecodeString(data)\n\t\tutils.E(err)\n\t} else {\n\t\tbin = []byte(data)\n\t}\n\n\treturn bin, nil\n}\n\n// WaitOpen waits for the next new page opened by the current one.\nfunc (p *Page) WaitOpen() func() (*Page, error) {\n\tvar targetID proto.TargetTargetID\n\n\tb := p.browser.Context(p.ctx)\n\twait := b.EachEvent(func(e *proto.TargetTargetCreated) bool {\n\t\ttargetID = e.TargetInfo.TargetID\n\t\treturn e.TargetInfo.OpenerID == p.TargetID\n\t})\n\n\treturn func() (*Page, error) {\n\t\tdefer p.tryTrace(TraceTypeWait, \"wait open\")()\n\t\twait()\n\t\treturn b.PageFromTarget(targetID)\n\t}\n}\n\n// EachEvent of the specified event types, if any callback returns true the wait function will resolve,\n// The type of each callback is (? means optional):\n//\n//\tfunc(proto.Event, proto.TargetSessionID?) bool?\n//\n// You can listen to multiple event types at the same time like:\n//\n//\tbrowser.EachEvent(func(a *proto.A) {}, func(b *proto.B) {})\n//\n// Such as subscribe the events to know when the navigation is complete or when the page is rendered.\n// Here's an example to dismiss all dialogs/alerts on the page:\n//\n//\tgo page.EachEvent(func(e *proto.PageJavascriptDialogOpening) {\n//\t    _ = proto.PageHandleJavaScriptDialog{ Accept: false, PromptText: \"\"}.Call(page)\n//\t})()\nfunc (p *Page) EachEvent(callbacks ...interface{}) (wait func()) {\n\treturn p.browser.Context(p.ctx).eachEvent(p.SessionID, callbacks...)\n}\n\n// WaitEvent waits for the next event for one time. It will also load the data into the event object.\nfunc (p *Page) WaitEvent(e proto.Event) (wait func()) {\n\tdefer p.tryTrace(TraceTypeWait, \"event\", e.ProtoEvent())()\n\treturn p.browser.Context(p.ctx).waitEvent(p.SessionID, e)\n}\n\n// WaitNavigation wait for a page lifecycle event when navigating.\n// Usually you will wait for [proto.PageLifecycleEventNameNetworkAlmostIdle].\nfunc (p *Page) WaitNavigation(name proto.PageLifecycleEventName) func() {\n\t_ = proto.PageSetLifecycleEventsEnabled{Enabled: true}.Call(p)\n\n\twait := p.EachEvent(func(e *proto.PageLifecycleEvent) bool {\n\t\treturn e.Name == name\n\t})\n\n\treturn func() {\n\t\tdefer p.tryTrace(TraceTypeWait, \"navigation\", name)()\n\t\twait()\n\t\t_ = proto.PageSetLifecycleEventsEnabled{Enabled: false}.Call(p)\n\t}\n}\n\n// WaitRequestIdle returns a wait function that waits until no request for d duration.\n// Be careful, d is not the max wait timeout, it's the least idle time.\n// If you want to set a timeout you can use the [Page.Timeout] function.\n// Use the includes and excludes regexp list to filter the requests by their url.\nfunc (p *Page) WaitRequestIdle(\n\td time.Duration,\n\tincludes, excludes []string,\n\texcludeTypes []proto.NetworkResourceType,\n) func() {\n\tdefer p.tryTrace(TraceTypeWait, \"request-idle\")()\n\n\tif excludeTypes == nil {\n\t\texcludeTypes = []proto.NetworkResourceType{\n\t\t\tproto.NetworkResourceTypeWebSocket,\n\t\t\tproto.NetworkResourceTypeEventSource,\n\t\t\tproto.NetworkResourceTypeMedia,\n\t\t\tproto.NetworkResourceTypeImage,\n\t\t\tproto.NetworkResourceTypeFont,\n\t\t}\n\t}\n\n\tif len(includes) == 0 {\n\t\tincludes = []string{\"\"}\n\t}\n\n\tp, cancel := p.WithCancel()\n\tmatch := genRegMatcher(includes, excludes)\n\twaitList := map[proto.NetworkRequestID]string{}\n\tidleCounter := utils.NewIdleCounter(d)\n\tupdate := p.tryTraceReq(includes, excludes)\n\tupdate(nil)\n\n\tcheckDone := func(id proto.NetworkRequestID) {\n\t\tif _, has := waitList[id]; has {\n\t\t\tdelete(waitList, id)\n\t\t\tupdate(waitList)\n\t\t\tidleCounter.Done()\n\t\t}\n\t}\n\n\twait := p.EachEvent(func(sent *proto.NetworkRequestWillBeSent) {\n\t\tfor _, t := range excludeTypes {\n\t\t\tif sent.Type == t {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif match(sent.Request.URL) {\n\t\t\t// Redirect will send multiple NetworkRequestWillBeSent events with the same RequestID,\n\t\t\t// we should filter them out.\n\t\t\tif _, has := waitList[sent.RequestID]; !has {\n\t\t\t\twaitList[sent.RequestID] = sent.Request.URL\n\t\t\t\tupdate(waitList)\n\t\t\t\tidleCounter.Add()\n\t\t\t}\n\t\t}\n\t}, func(e *proto.NetworkLoadingFinished) {\n\t\tcheckDone(e.RequestID)\n\t}, func(e *proto.NetworkLoadingFailed) {\n\t\tcheckDone(e.RequestID)\n\t})\n\n\treturn func() {\n\t\tgo func() {\n\t\t\tidleCounter.Wait(p.ctx)\n\t\t\tcancel()\n\t\t}()\n\t\twait()\n\t}\n}\n\n// WaitDOMStable waits until the change of the DOM tree is less or equal than diff percent for d duration.\n// Be careful, d is not the max wait timeout, it's the least stable time.\n// If you want to set a timeout you can use the [Page.Timeout] function.\nfunc (p *Page) WaitDOMStable(d time.Duration, diff float64) error {\n\tdefer p.tryTrace(TraceTypeWait, \"dom-stable\")()\n\n\tdomSnapshot, err := p.CaptureDOMSnapshot()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := time.NewTicker(d)\n\tdefer t.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-t.C:\n\t\tcase <-p.ctx.Done():\n\t\t\treturn p.ctx.Err()\n\t\t}\n\n\t\tcurrentDomSnapshot, err := p.CaptureDOMSnapshot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\txs := lcs.NewWords(domSnapshot.Strings)\n\t\tys := lcs.NewWords(currentDomSnapshot.Strings)\n\t\tlcs := xs.YadLCS(p.ctx, ys)\n\n\t\tdf := 1 - float64(len(lcs))/float64(len(ys))\n\t\tif df <= diff {\n\t\t\tbreak\n\t\t}\n\n\t\tdomSnapshot = currentDomSnapshot\n\t}\n\treturn nil\n}\n\n// WaitStable waits until the page is stable for d duration.\nfunc (p *Page) WaitStable(d time.Duration) error {\n\tdefer p.tryTrace(TraceTypeWait, \"stable\")()\n\n\tvar err error\n\n\tsetErr := sync.Once{}\n\n\tutils.All(func() {\n\t\te := p.WaitLoad()\n\t\tsetErr.Do(func() { err = e })\n\t}, func() {\n\t\tp.WaitRequestIdle(d, nil, nil, nil)()\n\t}, func() {\n\t\te := p.WaitDOMStable(d, 0)\n\t\tsetErr.Do(func() { err = e })\n\t})()\n\n\treturn err\n}\n\n// WaitIdle waits until the next window.requestIdleCallback is called.\nfunc (p *Page) WaitIdle(timeout time.Duration) (err error) {\n\t_, err = p.Evaluate(evalHelper(js.WaitIdle, timeout.Milliseconds()).ByPromise())\n\treturn err\n}\n\n// WaitRepaint waits until the next repaint.\n// Doc: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\nfunc (p *Page) WaitRepaint() error {\n\t// we use root here because iframe doesn't trigger requestAnimationFrame\n\t_, err := p.root.Eval(`() => new Promise(r => requestAnimationFrame(r))`)\n\treturn err\n}\n\n// WaitLoad waits for the `window.onload` event, it returns immediately if the event is already fired.\nfunc (p *Page) WaitLoad() error {\n\tdefer p.tryTrace(TraceTypeWait, \"load\")()\n\t_, err := p.Evaluate(evalHelper(js.WaitLoad).ByPromise())\n\treturn err\n}\n\n// AddScriptTag to page. If url is empty, content will be used.\nfunc (p *Page) AddScriptTag(url, content string) error {\n\thash := md5.Sum([]byte(url + content))\n\tid := hex.EncodeToString(hash[:])\n\t_, err := p.Evaluate(evalHelper(js.AddScriptTag, id, url, content).ByPromise())\n\treturn err\n}\n\n// AddStyleTag to page. If url is empty, content will be used.\nfunc (p *Page) AddStyleTag(url, content string) error {\n\thash := md5.Sum([]byte(url + content))\n\tid := hex.EncodeToString(hash[:])\n\t_, err := p.Evaluate(evalHelper(js.AddStyleTag, id, url, content).ByPromise())\n\treturn err\n}\n\n// EvalOnNewDocument Evaluates given script in every frame upon creation (before loading frame's scripts).\nfunc (p *Page) EvalOnNewDocument(js string) (remove func() error, err error) {\n\tres, err := proto.PageAddScriptToEvaluateOnNewDocument{Source: js}.Call(p)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tremove = func() error {\n\t\treturn proto.PageRemoveScriptToEvaluateOnNewDocument{\n\t\t\tIdentifier: res.Identifier,\n\t\t}.Call(p)\n\t}\n\n\treturn\n}\n\n// Wait until the js returns true.\nfunc (p *Page) Wait(opts *EvalOptions) error {\n\treturn utils.Retry(p.ctx, p.sleeper(), func() (bool, error) {\n\t\tres, err := p.Evaluate(opts)\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\treturn res.Value.Bool(), nil\n\t})\n}\n\n// WaitElementsMoreThan waits until there are more than num elements that match the selector.\nfunc (p *Page) WaitElementsMoreThan(selector string, num int) error {\n\treturn p.Wait(Eval(`(s, n) => document.querySelectorAll(s).length > n`, selector, num))\n}\n\n// ObjectToJSON by object id.\nfunc (p *Page) ObjectToJSON(obj *proto.RuntimeRemoteObject) (gson.JSON, error) {\n\tif obj.ObjectID == \"\" {\n\t\treturn obj.Value, nil\n\t}\n\n\tres, err := proto.RuntimeCallFunctionOn{\n\t\tObjectID:            obj.ObjectID,\n\t\tFunctionDeclaration: `function() { return this }`,\n\t\tReturnByValue:       true,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn gson.New(nil), err\n\t}\n\treturn res.Result.Value, nil\n}\n\n// ElementFromObject creates an Element from the remote object id.\nfunc (p *Page) ElementFromObject(obj *proto.RuntimeRemoteObject) (*Element, error) {\n\t// If the element is in an iframe, we need the jsCtxID to inject helper.js to the correct context.\n\tid, err := p.jsCtxIDByObjectID(obj.ObjectID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpid, err := p.getJSCtxID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif id != pid {\n\t\tclone := *p\n\t\tclone.jsCtxID = &id\n\t\tp = &clone\n\t}\n\n\treturn &Element{\n\t\te:       p.e,\n\t\tctx:     p.ctx,\n\t\tsleeper: p.sleeper,\n\t\tpage:    p,\n\t\tObject:  obj,\n\t}, nil\n}\n\n// ElementFromNode creates an Element from the node, [proto.DOMNodeID] or [proto.DOMBackendNodeID] must be specified.\nfunc (p *Page) ElementFromNode(node *proto.DOMNode) (*Element, error) {\n\tres, err := proto.DOMResolveNode{\n\t\tNodeID:        node.NodeID,\n\t\tBackendNodeID: node.BackendNodeID,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tel, err := p.ElementFromObject(res.Object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// make sure always return an element node\n\tdesc, err := el.Describe(0, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif desc.NodeName == \"#text\" {\n\t\tel, err = el.Parent()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn el, nil\n}\n\n// ElementFromPoint creates an Element from the absolute point on the page.\n// The point should include the window scroll offset.\nfunc (p *Page) ElementFromPoint(x, y int) (*Element, error) {\n\tnode, err := proto.DOMGetNodeForLocation{X: x, Y: y}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p.ElementFromNode(&proto.DOMNode{\n\t\tBackendNodeID: node.BackendNodeID,\n\t})\n}\n\n// Release the remote object. Usually, you don't need to call it.\n// When a page is closed or reloaded, all remote objects will be released automatically.\n// It's useful if the page never closes or reloads.\nfunc (p *Page) Release(obj *proto.RuntimeRemoteObject) error {\n\terr := proto.RuntimeReleaseObject{ObjectID: obj.ObjectID}.Call(p)\n\treturn err\n}\n\n// Call implements the [proto.Client].\nfunc (p *Page) Call(ctx context.Context, sessionID, methodName string, params interface{}) (res []byte, err error) {\n\treturn p.browser.Call(ctx, sessionID, methodName, params)\n}\n\n// Event of the page.\nfunc (p *Page) Event() <-chan *Message {\n\tdst := make(chan *Message)\n\ts := p.event.Subscribe(p.ctx)\n\n\tgo func() {\n\t\tdefer close(dst)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-p.ctx.Done():\n\t\t\t\treturn\n\t\t\tcase msg, ok := <-s:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-p.ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase dst <- msg.(*Message): //nolint: forcetypeassert\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn dst\n}\n\nfunc (p *Page) initEvents() {\n\tp.event = goob.New(p.ctx)\n\tevent := p.browser.Context(p.ctx).Event()\n\n\tgo func() {\n\t\tfor msg := range event {\n\t\t\tdetached := proto.TargetDetachedFromTarget{}\n\t\t\tdestroyed := proto.TargetTargetDestroyed{}\n\n\t\t\tif (msg.Load(&detached) && detached.SessionID == p.SessionID) ||\n\t\t\t\t(msg.Load(destroyed) && destroyed.TargetID == p.TargetID) {\n\t\t\t\tp.sessionCancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif msg.SessionID != p.SessionID {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp.event.Publish(msg)\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "page_eval.go",
          "type": "blob",
          "size": 9.16015625,
          "content": "// This file serves for the Page.Evaluate.\n\npackage rod\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\n// EvalOptions for Page.Evaluate.\ntype EvalOptions struct {\n\t// If enabled the eval result will be a plain JSON value.\n\t// If disabled the eval result will be a reference of a remote js object.\n\tByValue bool\n\n\tAwaitPromise bool\n\n\t// ThisObj represents the \"this\" object in the JS\n\tThisObj *proto.RuntimeRemoteObject\n\n\t// JS function definition to execute.\n\tJS string\n\n\t// JSArgs represents the arguments that will be passed to JS.\n\t// If an argument is [*proto.RuntimeRemoteObject] type, the corresponding remote object will be used.\n\t// Or it will be passed as a plain JSON value.\n\t// When an arg in the args is a *js.Function, the arg will be cached on the page's js context.\n\t// When the arg.Name exists in the page's cache, it reuse the cache without sending\n\t// the definition to the browser again.\n\t// Useful when you need to eval a huge js expression many times.\n\tJSArgs []interface{}\n\n\t// Whether execution should be treated as initiated by user in the UI.\n\tUserGesture bool\n}\n\n// Eval creates a [EvalOptions] with ByValue set to true.\nfunc Eval(js string, args ...interface{}) *EvalOptions {\n\treturn &EvalOptions{\n\t\tByValue:      true,\n\t\tAwaitPromise: false,\n\t\tThisObj:      nil,\n\t\tJS:           js,\n\t\tJSArgs:       args,\n\t\tUserGesture:  false,\n\t}\n}\n\nfunc evalHelper(fn *js.Function, args ...interface{}) *EvalOptions {\n\treturn &EvalOptions{\n\t\tByValue: true,\n\t\tJSArgs:  append([]interface{}{fn}, args...),\n\t\tJS:      fmt.Sprintf(`function (f /* %s */, ...args) { return f.apply(this, args) }`, fn.Name),\n\t}\n}\n\n// String interface.\nfunc (e *EvalOptions) String() string {\n\tfn := e.JS\n\targs := e.JSArgs\n\n\tparamsStr := \"\"\n\tthisStr := \"\"\n\n\tif e.ThisObj != nil {\n\t\tthisStr = e.ThisObj.Description\n\t}\n\tif len(args) > 0 {\n\t\tif f, ok := args[0].(*js.Function); ok {\n\t\t\tfn = \"rod.\" + f.Name\n\t\t\targs = e.JSArgs[1:]\n\t\t}\n\n\t\tparamsStr = strings.Trim(mustToJSONForDev(args), \"[]\\r\\n\")\n\t}\n\n\treturn fmt.Sprintf(\"%s(%s) %s\", fn, paramsStr, thisStr)\n}\n\n// This set the obj as ThisObj.\nfunc (e *EvalOptions) This(obj *proto.RuntimeRemoteObject) *EvalOptions {\n\te.ThisObj = obj\n\treturn e\n}\n\n// ByObject disables ByValue.\nfunc (e *EvalOptions) ByObject() *EvalOptions {\n\te.ByValue = false\n\treturn e\n}\n\n// ByUser enables UserGesture.\nfunc (e *EvalOptions) ByUser() *EvalOptions {\n\te.UserGesture = true\n\treturn e\n}\n\n// ByPromise enables AwaitPromise.\nfunc (e *EvalOptions) ByPromise() *EvalOptions {\n\te.AwaitPromise = true\n\treturn e\n}\n\nfunc (e *EvalOptions) formatToJSFunc() string {\n\tjs := strings.Trim(e.JS, \"\\t\\n\\v\\f\\r ;\")\n\treturn `function() { return (` + js + `).apply(this, arguments) }`\n}\n\n// Eval is a shortcut for [Page.Evaluate] with AwaitPromise, ByValue set to true.\nfunc (p *Page) Eval(js string, args ...interface{}) (*proto.RuntimeRemoteObject, error) {\n\treturn p.Evaluate(Eval(js, args...).ByPromise())\n}\n\n// Evaluate js on the page.\nfunc (p *Page) Evaluate(opts *EvalOptions) (res *proto.RuntimeRemoteObject, err error) {\n\tvar backoff utils.Sleeper\n\n\t// js context will be invalid if a frame is reloaded or not ready, then the isNilContextErr\n\t// will be true, then we retry the eval again.\n\tfor {\n\t\tres, err = p.evaluate(opts)\n\t\tif err != nil && errors.Is(err, cdp.ErrCtxNotFound) {\n\t\t\tif opts.ThisObj != nil {\n\t\t\t\treturn nil, &ObjectNotFoundError{opts.ThisObj}\n\t\t\t}\n\n\t\t\tif backoff == nil {\n\t\t\t\tbackoff = utils.BackoffSleeper(30*time.Millisecond, 3*time.Second, nil)\n\t\t\t} else {\n\t\t\t\t_ = backoff(p.ctx)\n\t\t\t}\n\n\t\t\tp.unsetJSCtxID()\n\n\t\t\tcontinue\n\t\t}\n\t\treturn\n\t}\n}\n\nfunc (p *Page) evaluate(opts *EvalOptions) (*proto.RuntimeRemoteObject, error) {\n\targs, err := p.formatArgs(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq := proto.RuntimeCallFunctionOn{\n\t\tAwaitPromise:        opts.AwaitPromise,\n\t\tReturnByValue:       opts.ByValue,\n\t\tUserGesture:         opts.UserGesture,\n\t\tFunctionDeclaration: opts.formatToJSFunc(),\n\t\tArguments:           args,\n\t}\n\n\tif opts.ThisObj == nil {\n\t\treq.ObjectID, err = p.getJSCtxID()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\treq.ObjectID = opts.ThisObj.ObjectID\n\t}\n\n\tres, err := req.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.ExceptionDetails != nil {\n\t\treturn nil, &EvalError{res.ExceptionDetails}\n\t}\n\n\treturn res.Result, nil\n}\n\n// Expose fn to the page's window object with the name. The exposure survives reloads.\n// Call stop to unbind the fn.\nfunc (p *Page) Expose(name string, fn func(gson.JSON) (interface{}, error)) (stop func() error, err error) {\n\tbind := \"_\" + utils.RandString(8)\n\n\terr = proto.RuntimeAddBinding{Name: bind}.Call(p)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = p.Evaluate(Eval(js.ExposeFunc.Definition, name, bind))\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcode := fmt.Sprintf(`(%s)(\"%s\", \"%s\")`, js.ExposeFunc.Definition, name, bind)\n\tremove, err := p.EvalOnNewDocument(code)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tp, cancel := p.WithCancel()\n\n\tstop = func() error {\n\t\tdefer cancel()\n\t\terr := remove()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn proto.RuntimeRemoveBinding{Name: bind}.Call(p)\n\t}\n\n\tgo p.EachEvent(func(e *proto.RuntimeBindingCalled) {\n\t\tif e.Name == bind {\n\t\t\tpayload := gson.NewFrom(e.Payload)\n\t\t\tres, err := fn(payload.Get(\"req\"))\n\t\t\tcode := fmt.Sprintf(\"(res, err) => %s(res, err)\", payload.Get(\"cb\").Str())\n\t\t\t_, _ = p.Evaluate(Eval(code, res, err))\n\t\t}\n\t})()\n\n\treturn\n}\n\nfunc (p *Page) formatArgs(opts *EvalOptions) ([]*proto.RuntimeCallArgument, error) {\n\tformatted := []*proto.RuntimeCallArgument{}\n\tfor _, arg := range opts.JSArgs {\n\t\tif obj, ok := arg.(*proto.RuntimeRemoteObject); ok { // remote object\n\t\t\tformatted = append(formatted, &proto.RuntimeCallArgument{ObjectID: obj.ObjectID})\n\t\t} else if obj, ok := arg.(*js.Function); ok { // js helper\n\t\t\tid, err := p.ensureJSHelper(obj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tformatted = append(formatted, &proto.RuntimeCallArgument{ObjectID: id})\n\t\t} else { // plain json data\n\t\t\tformatted = append(formatted, &proto.RuntimeCallArgument{Value: gson.New(arg)})\n\t\t}\n\t}\n\n\treturn formatted, nil\n}\n\n// Check the doc of EvalHelper.\nfunc (p *Page) ensureJSHelper(fn *js.Function) (proto.RuntimeRemoteObjectID, error) {\n\tjsCtxID, err := p.getJSCtxID()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfnID, has := p.getHelper(jsCtxID, js.Functions.Name)\n\tif !has {\n\t\tres, err := proto.RuntimeCallFunctionOn{\n\t\t\tObjectID:            jsCtxID,\n\t\t\tFunctionDeclaration: js.Functions.Definition,\n\t\t}.Call(p)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfnID = res.Result.ObjectID\n\t\tp.setHelper(jsCtxID, js.Functions.Name, fnID)\n\t}\n\n\tid, has := p.getHelper(jsCtxID, fn.Name)\n\tif !has {\n\t\tfor _, dep := range fn.Dependencies {\n\t\t\t_, err := p.ensureJSHelper(dep)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\n\t\tres, err := proto.RuntimeCallFunctionOn{\n\t\t\tObjectID:  jsCtxID,\n\t\t\tArguments: []*proto.RuntimeCallArgument{{ObjectID: fnID}},\n\n\t\t\tFunctionDeclaration: fmt.Sprintf(\n\t\t\t\t// we only need the object id, but the cdp will return the whole function string.\n\t\t\t\t// So we override the toString to reduce the overhead.\n\t\t\t\t\"functions => { const f = functions.%s = %s; f.toString = () => 'fn'; return f }\",\n\t\t\t\tfn.Name, fn.Definition,\n\t\t\t),\n\t\t}.Call(p)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tid = res.Result.ObjectID\n\t\tp.setHelper(jsCtxID, fn.Name, id)\n\t}\n\n\treturn id, nil\n}\n\nfunc (p *Page) getHelper(jsCtxID proto.RuntimeRemoteObjectID, name string) (proto.RuntimeRemoteObjectID, bool) {\n\tp.helpersLock.Lock()\n\tdefer p.helpersLock.Unlock()\n\n\tif p.helpers == nil {\n\t\tp.helpers = map[proto.RuntimeRemoteObjectID]map[string]proto.RuntimeRemoteObjectID{}\n\t}\n\n\tlist, ok := p.helpers[jsCtxID]\n\tif !ok {\n\t\tlist = map[string]proto.RuntimeRemoteObjectID{}\n\t\tp.helpers[jsCtxID] = list\n\t}\n\n\tid, ok := list[name]\n\treturn id, ok\n}\n\nfunc (p *Page) setHelper(jsCtxID proto.RuntimeRemoteObjectID, name string, fnID proto.RuntimeRemoteObjectID) {\n\tp.helpersLock.Lock()\n\tdefer p.helpersLock.Unlock()\n\n\tp.helpers[jsCtxID][name] = fnID\n}\n\n// Returns the page's window object, the page can be an iframe.\nfunc (p *Page) getJSCtxID() (proto.RuntimeRemoteObjectID, error) {\n\tp.jsCtxLock.Lock()\n\tdefer p.jsCtxLock.Unlock()\n\n\tif *p.jsCtxID != \"\" {\n\t\treturn *p.jsCtxID, nil\n\t}\n\n\tif !p.IsIframe() {\n\t\tobj, err := proto.RuntimeEvaluate{Expression: \"window\"}.Call(p)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t*p.jsCtxID = obj.Result.ObjectID\n\t\tp.helpersLock.Lock()\n\t\tp.helpers = nil\n\t\tp.helpersLock.Unlock()\n\t\treturn *p.jsCtxID, nil\n\t}\n\n\tnode, err := p.element.Describe(1, true)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tobj, err := proto.DOMResolveNode{BackendNodeID: node.ContentDocument.BackendNodeID}.Call(p)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tp.helpersLock.Lock()\n\tdelete(p.helpers, *p.jsCtxID)\n\tp.helpersLock.Unlock()\n\tid, err := p.jsCtxIDByObjectID(obj.Object.ObjectID)\n\t*p.jsCtxID = id\n\treturn *p.jsCtxID, err\n}\n\nfunc (p *Page) unsetJSCtxID() {\n\tp.jsCtxLock.Lock()\n\tdefer p.jsCtxLock.Unlock()\n\n\t*p.jsCtxID = \"\"\n}\n\nfunc (p *Page) jsCtxIDByObjectID(id proto.RuntimeRemoteObjectID) (proto.RuntimeRemoteObjectID, error) {\n\tres, err := proto.RuntimeCallFunctionOn{\n\t\tObjectID:            id,\n\t\tFunctionDeclaration: `() => window`,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Result.ObjectID, nil\n}\n"
        },
        {
          "name": "page_eval_test.go",
          "type": "blob",
          "size": 6.943359375,
          "content": "package rod_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestPageEvalOnNewDocument(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage()\n\n\tp.MustEvalOnNewDocument(`window.rod = 'ok'`)\n\n\t// to activate the script\n\tp.MustNavigate(g.blank())\n\n\tg.Eq(p.MustEval(\"() => rod\").String(), \"ok\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageAddScriptToEvaluateOnNewDocument{})\n\t\tp.MustEvalOnNewDocument(`1`)\n\t})\n}\n\nfunc TestPageEval(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.blank())\n\n\tg.Eq(3, page.MustEval(`\n\t\t(a, b) => a + b\n\t`, 1, 2).Int())\n\n\tg.Eq(10, page.MustEval(`(a, b, c, d) => a + b + c + d`, 1, 2, 3, 4).Int())\n\n\tg.Eq(page.MustEval(`function() {\n\t\treturn 11\n\t}`).Int(), 11)\n\n\tg.Eq(page.MustEval(`\t ; () => 1; `).Int(), 1)\n\n\t// reuse obj\n\tobj := page.MustEvaluate(rod.Eval(`() => () => 'ok'`).ByObject())\n\tg.Eq(\"ok\", page.MustEval(`f => f()`, obj).Str())\n\n\t_, err := page.Eval(`10`)\n\tg.Has(err.Error(), `eval js error: TypeError: 10.apply is not a function`)\n\n\t_, err = page.Eval(`() => notExist()`)\n\tg.Is(err, &rod.EvalError{})\n\tg.Has(err.Error(), `eval js error: ReferenceError: notExist is not defined`)\n}\n\nfunc TestPageEvaluateRetry(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.blank())\n\n\tg.mc.stub(1, proto.RuntimeCallFunctionOn{}, func(_ StubSend) (gson.JSON, error) {\n\t\tg.mc.stub(1, proto.RuntimeCallFunctionOn{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(nil), cdp.ErrCtxNotFound\n\t\t})\n\t\treturn gson.New(nil), cdp.ErrCtxNotFound\n\t})\n\tg.Eq(1, page.MustEval(`() => 1`).Int())\n}\n\nfunc TestPageUpdateJSCtxIDErr(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.srcFile(\"./fixtures/click-iframe.html\"))\n\n\tg.mc.stub(1, proto.RuntimeCallFunctionOn{}, func(_ StubSend) (gson.JSON, error) {\n\t\tg.mc.stubErr(1, proto.RuntimeEvaluate{})\n\t\treturn gson.New(nil), cdp.ErrCtxNotFound\n\t})\n\tg.Err(page.Eval(`() => 1`))\n\n\tframe := page.MustElement(\"iframe\").MustFrame()\n\n\tframe.MustReload()\n\tg.mc.stubErr(1, proto.DOMDescribeNode{})\n\tg.Err(frame.Element(`button`))\n\n\tframe.MustReload()\n\tg.mc.stubErr(1, proto.DOMResolveNode{})\n\tg.Err(frame.Element(`button`))\n}\n\nfunc TestPageExpose(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank()).MustWaitLoad()\n\n\tstop := page.MustExpose(\"exposedFunc\", func(g gson.JSON) (interface{}, error) {\n\t\treturn g.Get(\"k\").Str(), nil\n\t})\n\n\tutils.All(func() {\n\t\tres := page.MustEval(`() => exposedFunc({k: 'a'})`)\n\t\tg.Eq(\"a\", res.Str())\n\t}, func() {\n\t\tres := page.MustEval(`() => exposedFunc({k: 'b'})`)\n\t\tg.Eq(\"b\", res.Str())\n\t})()\n\n\t// survive the reload\n\tpage.MustReload().MustWaitLoad()\n\tres := page.MustEval(`() => exposedFunc({k: 'ok'})`)\n\tg.Eq(\"ok\", res.Str())\n\n\tstop()\n\n\tg.Panic(func() {\n\t\tstop()\n\t})\n\tg.Panic(func() {\n\t\tpage.MustReload().MustWaitLoad().MustEval(`() => exposedFunc()`)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tpage.MustExpose(\"exposedFunc\", nil)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeAddBinding{})\n\t\tpage.MustExpose(\"exposedFunc2\", nil)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageAddScriptToEvaluateOnNewDocument{})\n\t\tpage.MustExpose(\"exposedFunc\", nil)\n\t})\n}\n\nfunc TestObjectRelease(t *testing.T) {\n\tg := setup(t)\n\n\tres, err := g.page.Evaluate(rod.Eval(`() => document`).ByObject())\n\tg.E(err)\n\tg.page.MustRelease(res)\n}\n\nfunc TestPromiseLeak(t *testing.T) {\n\tg := setup(t)\n\n\t/*\n\t\tPerform a slow action then navigate the page to another url,\n\t\twe can see the slow operation will still be executed.\n\t*/\n\n\tp := g.page.MustNavigate(g.blank())\n\n\tutils.All(func() {\n\t\t_, err := p.Eval(`() => new Promise(r => setTimeout(() => r(location.href), 1000))`)\n\t\tg.Is(err, cdp.ErrCtxDestroyed)\n\t}, func() {\n\t\tutils.Sleep(0.3)\n\t\tp.MustNavigate(g.blank())\n\t})()\n}\n\nfunc TestObjectLeak(t *testing.T) {\n\tg := setup(t)\n\n\t/*\n\t\tSeems like it won't leak\n\t*/\n\n\tp := g.page.MustNavigate(g.blank())\n\n\tobj := p.MustEvaluate(rod.Eval(\"() => ({a:1})\").ByObject())\n\tp.MustReload().MustWaitLoad()\n\tg.Panic(func() {\n\t\tp.MustEvaluate(rod.Eval(`obj => obj`, obj))\n\t})\n}\n\nfunc TestPageObjectErr(t *testing.T) {\n\tg := setup(t)\n\n\tg.Panic(func() {\n\t\tg.page.MustObjectToJSON(&proto.RuntimeRemoteObject{\n\t\t\tObjectID: \"not-exists\",\n\t\t})\n\t})\n\tg.Panic(func() {\n\t\tg.page.MustElementFromNode(&proto.DOMNode{NodeID: -1})\n\t})\n\tg.Panic(func() {\n\t\tnode := g.page.MustNavigate(g.blank()).MustElement(`body`).MustDescribe()\n\t\tg.mc.stubErr(1, proto.DOMResolveNode{})\n\t\tg.page.MustElementFromNode(node)\n\t})\n}\n\nfunc TestGetJSHelperRetry(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\n\tg.mc.stub(1, proto.RuntimeCallFunctionOn{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.JSON{}, cdp.ErrCtxNotFound\n\t})\n\tg.page.MustElements(\"button\")\n}\n\nfunc TestConcurrentEval(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank())\n\tlist := make(chan int, 2)\n\n\tstart := time.Now()\n\tutils.All(func() {\n\t\tlist <- p.MustEval(`() => new Promise(r => setTimeout(r, 2500, 2))`).Int()\n\t}, func() {\n\t\tlist <- p.MustEval(`() => new Promise(r => setTimeout(r, 1500, 1))`).Int()\n\t})()\n\tduration := time.Since(start)\n\n\tg.Gt(duration, 1500*time.Millisecond)\n\tg.Lt(duration, 3000*time.Millisecond)\n\tg.Eq([]int{<-list, <-list}, []int{1, 2})\n}\n\nfunc TestPageSlowRender(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"./fixtures/slow-render.html\"))\n\tg.Eq(p.MustElement(\"div\").MustText(), \"ok\")\n}\n\nfunc TestPageIframeReload(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"./fixtures/click-iframe.html\"))\n\tframe := p.MustElement(\"iframe\").MustFrame()\n\tbtn := frame.MustElement(\"button\")\n\tg.Eq(btn.MustText(), \"click me\")\n\n\tframe.MustReload()\n\tbtn = frame.MustElement(\"button\")\n\tg.Eq(btn.MustText(), \"click me\")\n\n\tg.Has(*p.MustElement(\"iframe\").MustAttribute(\"src\"), \"click.html\")\n}\n\nfunc TestPageObjCrossNavigation(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank())\n\tobj := p.MustEvaluate(rod.Eval(`() => ({})`).ByObject())\n\n\tg.page.MustNavigate(g.blank())\n\n\t_, err := p.Evaluate(rod.Eval(`() => 1`).This(obj))\n\tg.Is(err, &rod.ObjectNotFoundError{})\n\tg.Has(err.Error(), \"cannot find object: {\\\"type\\\":\\\"object\\\"\")\n}\n\nfunc TestEnsureJSHelperErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank())\n\n\tg.mc.stubErr(2, proto.RuntimeCallFunctionOn{})\n\tg.Err(p.Elements(`button`))\n}\n\nfunc TestEvalOptionsString(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tel := p.MustElement(\"button\")\n\n\tg.Eq(rod.Eval(`() => this.parentElement`).This(el.Object).String(), \"() => this.parentElement() button\")\n}\n\nfunc TestEvalObjectReferenceChainIsTooLong(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank())\n\n\tobj, err := p.Evaluate(&rod.EvalOptions{\n\t\tJS: `() => {\n\t\t\tlet a = {b: 1}\n\t\t\ta.c = a\n\t\t\treturn a\n\t\t}`,\n\t})\n\tg.E(err)\n\n\t_, err = p.Eval(`a => a`, obj)\n\tg.Eq(err.Error(), \"{-32000 Object reference chain is too long }\")\n\n\tval := p.MustEval(`a => a.c.c.c.c.b`, obj)\n\tg.Eq(val.Int(), 1)\n}\n"
        },
        {
          "name": "page_test.go",
          "type": "blob",
          "size": 28.81640625,
          "content": "package rod_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image/png\"\n\t\"math\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/defaults\"\n\t\"github.com/go-rod/rod/lib/devices\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestGetPageBrowser(t *testing.T) {\n\tg := setup(t)\n\n\tg.Eq(g.page.Browser().BrowserContextID, g.browser.BrowserContextID)\n}\n\nfunc TestGetPageURL(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/click-iframe.html\")).MustWaitLoad()\n\tg.Regex(`/fixtures/click-iframe.html\\z`, g.page.MustInfo().URL)\n}\n\nfunc TestSetCookies(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\tpage := g.page.MustSetCookies([]*proto.NetworkCookieParam{{\n\t\tName:  \"cookie-a\",\n\t\tValue: \"1\",\n\t\tURL:   s.URL(),\n\t}, {\n\t\tName:  \"cookie-b\",\n\t\tValue: \"2\",\n\t\tURL:   s.URL(),\n\t}}...).MustNavigate(s.URL()).MustWaitLoad()\n\n\tcookies := page.MustCookies()\n\n\tsort.Slice(cookies, func(i, j int) bool {\n\t\treturn cookies[i].Value < cookies[j].Value\n\t})\n\n\tg.Eq(\"1\", cookies[0].Value)\n\tg.Eq(\"2\", cookies[1].Value)\n\n\tpage.MustSetCookies()\n\n\tcookies = page.MustCookies()\n\tg.Len(cookies, 0)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.TargetGetTargetInfo{})\n\t\tpage.MustCookies()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.NetworkGetCookies{})\n\t\tpage.MustCookies()\n\t})\n}\n\nfunc TestSetBlockedURLs(t *testing.T) {\n\tg := setup(t)\n\tpage := g.newPage()\n\turlsPattern := []string{}\n\tpage.EnableDomain(proto.NetworkEnable{})\n\tpage.MustSetBlockedURLs(urlsPattern...)\n\turlsPattern = append(urlsPattern, \"*.js\")\n\tpage.MustSetBlockedURLs(urlsPattern...)\n\tgo page.EachEvent(\n\t\tfunc(e *proto.NetworkLoadingFailed) {\n\t\t\tg.Eq(e.BlockedReason, proto.NetworkBlockedReasonInspector)\n\t\t},\n\t)\n\tpage.MustNavigate(\"https://github.com\")\n}\n\nfunc TestSetExtraHeaders(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\twg := sync.WaitGroup{}\n\tvar header http.Header\n\ts.Mux.HandleFunc(\"/set-header\", func(_ http.ResponseWriter, r *http.Request) {\n\t\theader = r.Header\n\t\twg.Done()\n\t})\n\n\tp := g.newPage()\n\tcleanup := p.MustSetExtraHeaders(\"a\", \"1\", \"b\", \"2\")\n\n\twg.Add(1)\n\tp.MustNavigate(s.URL(\"/set-header\"))\n\twg.Wait()\n\n\tg.Eq(header.Get(\"a\"), \"1\")\n\tg.Eq(header.Get(\"b\"), \"2\")\n\n\tcleanup()\n\n\twg.Add(1)\n\tp.MustReload()\n\twg.Wait()\n\n\tg.Eq(header.Get(\"a\"), \"\")\n\tg.Eq(header.Get(\"b\"), \"\")\n}\n\nfunc TestSetUserAgent(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\tua := \"\"\n\tlang := \"\"\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\n\ts.Mux.HandleFunc(\"/\", func(_ http.ResponseWriter, r *http.Request) {\n\t\tua = r.Header.Get(\"User-Agent\")\n\t\tlang = r.Header.Get(\"Accept-Language\")\n\t\twg.Done()\n\t})\n\n\tg.newPage().MustSetUserAgent(nil).MustNavigate(s.URL())\n\twg.Wait()\n\n\tg.Eq(ua, \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\")\n\tg.Eq(lang, \"en\")\n}\n\nfunc TestPageHTML(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\")).MustWaitLoad()\n\tp.MustElement(\"button\").MustClick()\n\tg.Has(p.MustHTML(), `a=\"ok\"`)\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(p.HTML())\n}\n\nfunc TestMustWaitElementsMoreThan(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/wait_elements.html\")).MustWaitElementsMoreThan(\"li\", 5)\n\tg.Gt(len(p.MustElements(\"li\")), 5)\n}\n\nfunc TestPageCloseCancel(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.browser.MustPage(g.srcFile(\"fixtures/prevent-close.html\"))\n\tpage.MustElement(\"body\").MustClick() // only focused page will handle beforeunload event\n\n\tw, h := page.MustHandleDialog()\n\tgo func() {\n\t\tw()\n\t\th(false, \"\")\n\t}()\n\tg.Eq(page.Close().Error(), \"page close canceled\")\n\n\tpage.MustEval(`() => window.onbeforeunload = null`)\n\tpage.MustClose()\n}\n\nfunc TestLoadState(t *testing.T) {\n\tg := setup(t)\n\n\tg.True(g.page.LoadState(&proto.PageEnable{}))\n}\n\nfunc TestDisableDomain(t *testing.T) {\n\tg := setup(t)\n\n\tdefer g.page.DisableDomain(&proto.PageEnable{})()\n}\n\nfunc TestPageContext(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.Timeout(time.Hour).CancelTimeout().MustEval(`() => 1`)\n\t_, _ = g.page.Timeout(time.Second).Timeout(time.Hour).CancelTimeout().Element(\"not-exist\")\n}\n\nfunc TestPageActivate(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustActivate()\n}\n\nfunc TestWindow(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank())\n\n\tg.E(page.SetViewport(nil))\n\n\tbounds := page.MustGetWindow()\n\tdefer page.MustSetWindow(\n\t\t*bounds.Left,\n\t\t*bounds.Top,\n\t\t*bounds.Width,\n\t\t*bounds.Height,\n\t)\n\n\tpage.MustWindowMaximize()\n\tpage.MustWindowNormal()\n\tpage.MustWindowFullscreen()\n\tpage.MustWindowNormal()\n\tpage.MustWindowMinimize()\n\tpage.MustWindowNormal()\n\n\tpage.MustSetWindow(0, 0, 1211, 611)\n\tw, err := proto.BrowserGetWindowForTarget{}.Call(page)\n\tg.E(err)\n\tg.Eq(w.Bounds.Width, 1211)\n\tg.Eq(w.Bounds.Height, 611)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.BrowserGetWindowForTarget{})\n\t\tpage.MustGetWindow()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.BrowserGetWindowBounds{})\n\t\tpage.MustGetWindow()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.BrowserGetWindowForTarget{})\n\t\tpage.MustSetWindow(0, 0, 1000, 1000)\n\t})\n}\n\nfunc TestSetViewport(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank())\n\tpage.MustSetViewport(317, 419, 0, false)\n\tres := page.MustEval(`() => [window.innerWidth, window.innerHeight]`)\n\tg.Eq(317, res.Get(\"0\").Int())\n\tg.Eq(419, res.Get(\"1\").Int())\n\n\tpage2 := g.newPage(g.blank())\n\tres = page2.MustEval(`() => [window.innerWidth, window.innerHeight]`)\n\tg.Neq(int(317), res.Get(\"0\").Int())\n}\n\nfunc TestSetDocumentContent(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank())\n\n\tdoctype := \"<!DOCTYPE html>\"\n\thtml4StrictDoctype := `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n\thtml4LooseDoctype := `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">`\n\txhtml11Doctype := `<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">`\n\n\texampleWithHTML4StrictDoctype := html4StrictDoctype + \"<html><head></head><body><div>test</div></body></html>\"\n\tpage.MustSetDocumentContent(exampleWithHTML4StrictDoctype)\n\texp1 := page.MustEval(`() => new XMLSerializer().serializeToString(document)`).Str()\n\tg.Eq(exp1, `<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body><div>test</div></body></html>`)\n\tg.Eq(page.MustElement(\"html\").MustHTML(), \"<html><head></head><body><div>test</div></body></html>\")\n\tg.Eq(page.MustElement(\"head\").MustText(), \"\")\n\n\texampleWithHTML4LooseDoctype := html4LooseDoctype + \"<html><head></head><body><div>test</div></body></html>\"\n\tpage.MustSetDocumentContent(exampleWithHTML4LooseDoctype)\n\texp2 := page.MustEval(`() => new XMLSerializer().serializeToString(document)`).Str()\n\tg.Eq(exp2, `<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body><div>test</div></body></html>`)\n\tg.Eq(page.MustElement(\"html\").MustHTML(), \"<html><head></head><body><div>test</div></body></html>\")\n\tg.Eq(page.MustElement(\"head\").MustText(), \"\")\n\n\texampleWithXHTMLDoctype := xhtml11Doctype + \"<html><head></head><body><div>test</div></body></html>\"\n\tpage.MustSetDocumentContent(exampleWithXHTMLDoctype)\n\texp3 := page.MustEval(`() => new XMLSerializer().serializeToString(document)`).Str()\n\tg.Eq(exp3, `<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body><div>test</div></body></html>`)\n\tg.Eq(page.MustElement(\"html\").MustHTML(), \"<html><head></head><body><div>test</div></body></html>\")\n\tg.Eq(page.MustElement(\"head\").MustText(), \"\")\n\n\texampleWithHTML5Doctype := doctype + \"<html><head></head><body><div>test</div></body></html>\"\n\tpage.MustSetDocumentContent(exampleWithHTML5Doctype)\n\texp4 := page.MustEval(`() => new XMLSerializer().serializeToString(document)`).Str()\n\tg.Eq(exp4, `<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body><div>test</div></body></html>`)\n\tg.Eq(page.MustElement(\"html\").MustHTML(), \"<html><head></head><body><div>test</div></body></html>\")\n\tg.Eq(page.MustElement(\"head\").MustText(), \"\")\n\n\texampleWithoutDoctype := \"<html><head></head><body><div>test</div></body></html>\"\n\tpage.MustSetDocumentContent(exampleWithoutDoctype)\n\tg.Eq(page.MustElement(\"html\").MustHTML(), \"<html><head></head><body><div>test</div></body></html>\")\n\n\texampleBasic := doctype + \"<div>test</div>\"\n\tpage.MustSetDocumentContent(exampleBasic)\n\tg.Eq(page.MustElement(\"div\").MustText(), \"test\")\n\n\texampleWithTrickyContent := \"<div>test</div>\\x7F\"\n\tpage.MustSetDocumentContent(exampleWithTrickyContent)\n\tg.Eq(page.MustElement(\"div\").MustText(), \"test\")\n\n\texampleWithEmoji := \"<div>💪</div>\"\n\tpage.MustSetDocumentContent(exampleWithEmoji)\n\tg.Eq(page.MustElement(\"div\").MustText(), \"💪\")\n}\n\nfunc TestEmulateDevice(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank())\n\tpage.MustEmulate(devices.IPhone6or7or8)\n\tres := page.MustEval(`() => [window.innerWidth, window.innerHeight, navigator.userAgent]`)\n\n\t// TODO: this seems like a bug of chromium\n\t{\n\t\tg.Lt(math.Abs(float64(980-res.Get(\"0\").Int())), 10)\n\t\tg.Lt(math.Abs(float64(1743-res.Get(\"1\").Int())), 10)\n\t}\n\n\tg.Eq(\n\t\t\"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1\",\n\t\tres.Get(\"2\").String(),\n\t)\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.EmulationSetDeviceMetricsOverride{})\n\t\tpage.MustEmulate(devices.IPad)\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.EmulationSetTouchEmulationEnabled{})\n\t\tpage.MustEmulate(devices.IPad)\n\t})\n}\n\nfunc TestPageCloseErr(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.newPage(g.blank())\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageClose{})\n\t\tpage.MustClose()\n\t})\n}\n\nfunc TestPageCloseWhenNotAttached(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.browser.MustPage(g.blank())\n\n\tg.mc.stub(1, proto.PageClose{}, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(nil), cdp.ErrNotAttachedToActivePage\n\t})\n\n\tg.E(p.Close())\n}\n\nfunc TestPageAddScriptTag(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.blank()).MustWaitLoad()\n\n\tres := p.MustAddScriptTag(g.srcFile(\"fixtures/add-script-tag.js\")).MustEval(`() => count()`)\n\tg.Eq(0, res.Int())\n\n\tres = p.MustAddScriptTag(g.srcFile(\"fixtures/add-script-tag.js\")).MustEval(`() => count()`)\n\tg.Eq(1, res.Int())\n\n\tg.E(p.AddScriptTag(\"\", `let ok = 'yes'`))\n\tres = p.MustEval(`() => ok`)\n\tg.Eq(\"yes\", res.String())\n}\n\nfunc TestPageAddStyleTag(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\")).MustWaitLoad()\n\n\tres := p.MustAddStyleTag(g.srcFile(\"fixtures/add-style-tag.css\")).\n\t\tMustElement(\"h4\").MustEval(`() => getComputedStyle(this).color`)\n\tg.Eq(\"rgb(255, 0, 0)\", res.String())\n\n\tp.MustAddStyleTag(g.srcFile(\"fixtures/add-style-tag.css\"))\n\tg.Len(p.MustElements(\"link\"), 1)\n\n\tg.E(p.AddStyleTag(\"\", \"h4 { color: green; }\"))\n\tres = p.MustElement(\"h4\").MustEval(`() => getComputedStyle(this).color`)\n\tg.Eq(\"rgb(0, 128, 0)\", res.String())\n}\n\nfunc TestPageWaitOpen(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/open-page.html\"))\n\n\twait := page.MustWaitOpen()\n\n\tpage.MustElement(\"a\").MustClick()\n\n\tnewPage := wait()\n\tdefer newPage.MustClose()\n\n\tg.Eq(\"new page\", newPage.MustEval(\"() => window.a\").String())\n}\n\nfunc TestPageWait(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tpage.MustWait(`() => document.querySelector('button') !== null`)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tpage.MustWait(``)\n\t})\n}\n\nfunc TestPageNavigateBlank(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(\"\")\n}\n\nfunc TestPageWaitNavigation(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve().Route(\"/\", \"\")\n\twait := g.page.MustWaitNavigation()\n\tg.page.MustNavigate(s.URL())\n\twait()\n}\n\nfunc TestPageWaitRequestIdle(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\tsleep := time.Second\n\n\ts.Route(\"/r1\", \"\")\n\ts.Mux.HandleFunc(\"/r2\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tg.E(w.Write([]byte(\"part\")))\n\t\tctx, cancel := context.WithTimeout(g.Context(), sleep)\n\t\tdefer cancel()\n\t\t<-ctx.Done()\n\t})\n\ts.Mux.HandleFunc(\"/r3\", func(rw http.ResponseWriter, _ *http.Request) {\n\t\trw.Header().Add(\"Location\", \"/r4\")\n\t\trw.WriteHeader(http.StatusFound)\n\t})\n\ts.Route(\"/r4\", \"\")\n\ts.Route(\"/img.jpg\", \".jpg\", \"img\")\n\ts.Route(\"/\", \".html\", `<html><body></body></html>`)\n\n\tpage := g.newPage(s.URL()).MustWaitLoad()\n\n\tcode := ` () => {\n\t\tfetch('/r2').then(r => r.text())\n\t\tfetch('/r1')\n\t\tfetch('/r3')\n\t\tdocument.body.innerHTML = '<img src=\"/img.jpg\" />'\n\t}`\n\n\twaitReq := \"\"\n\tg.browser.Logger(utils.Log(func(msg ...interface{}) {\n\t\ttyp := msg[0].(rod.TraceType)\n\t\tif typ == rod.TraceTypeWaitRequests {\n\t\t\tlist := msg[2].(map[string]string)\n\t\t\tfor _, v := range list {\n\t\t\t\twaitReq = v\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}))\n\tdefer g.browser.Logger(rod.DefaultLogger)\n\n\tg.browser.Trace(true)\n\twait := page.MustWaitRequestIdle(\"/r1\")\n\tg.browser.Trace(defaults.Trace)\n\tpage.MustEval(code)\n\tstart := time.Now()\n\twait()\n\tg.Gt(time.Since(start), sleep)\n\tg.Regex(\"/r2$\", waitReq)\n\n\twait = page.MustWaitRequestIdle(\"/r2\")\n\tpage.MustEval(code)\n\tstart = time.Now()\n\twait()\n\tg.Lt(time.Since(start), sleep)\n\n\tg.Panic(func() {\n\t\twait()\n\t})\n}\n\nfunc TestPageCaptureDOMSnapshot(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tdomSnapshot := p.MustCaptureDOMSnapshot()\n\tg.Is(domSnapshot.Strings, []string{})\n\n\ttimeOutPage := p.Timeout(1 * time.Second)\n\tutils.Sleep(1)\n\tsnapshot, err := timeOutPage.CaptureDOMSnapshot()\n\tg.Is(err, context.DeadlineExceeded)\n\tg.Nil(snapshot)\n}\n\nfunc TestPageWaitDOMStable(t *testing.T) {\n\tg := setup(t)\n\n\t{\n\t\tp := g.page.MustNavigate(g.srcFile(\"fixtures/page-wait-stable.html\"))\n\t\tp.MustWaitDOMStable()\n\t}\n\n\t{\n\t\tp := g.page.MustNavigate(g.srcFile(\"fixtures/page-wait-stable.html\"))\n\t\terr := p.Timeout(time.Second).WaitDOMStable(time.Second, 0)\n\t\tg.Is(err, context.DeadlineExceeded)\n\t}\n\n\t{\n\t\tg.Panic(func() {\n\t\t\tp := g.page.MustNavigate(g.srcFile(\"fixtures/page-wait-stable.html\"))\n\t\t\tg.mc.stubErr(1, proto.DOMSnapshotCaptureSnapshot{})\n\t\t\tp.MustWaitDOMStable()\n\t\t})\n\t}\n\n\t{\n\t\tg.Panic(func() {\n\t\t\tp := g.page.MustNavigate(g.srcFile(\"fixtures/page-wait-stable.html\"))\n\t\t\tg.mc.stubErr(2, proto.DOMSnapshotCaptureSnapshot{})\n\t\t\tp.MustWaitDOMStable()\n\t\t})\n\t}\n}\n\nfunc TestPageWaitStable(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/page-wait-stable.html\"))\n\tp.MustWaitStable()\n\n\tg.Panic(func() {\n\t\tg.mc.setCall(func(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error) {\n\t\t\tswitch method {\n\t\t\tcase (proto.DOMSnapshotCaptureSnapshot{}).ProtoReq():\n\t\t\t\tutils.Sleep(0.3)\n\t\t\t\treturn nil, errors.New(\"error\")\n\t\t\tcase (proto.RuntimeCallFunctionOn{}).ProtoReq():\n\t\t\t\treturn nil, errors.New(\"error\")\n\t\t\t}\n\n\t\t\treturn g.mc.principal.Call(ctx, sessionID, method, params)\n\t\t})\n\t\tdefer g.mc.resetCall()\n\n\t\tp.MustWaitStable()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.setCall(func(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error) {\n\t\t\tswitch method {\n\t\t\tcase (proto.DOMSnapshotCaptureSnapshot{}).ProtoReq():\n\t\t\t\treturn nil, errors.New(\"error\")\n\t\t\tcase (proto.RuntimeCallFunctionOn{}).ProtoReq():\n\t\t\t\tutils.Sleep(0.3)\n\t\t\t\treturn nil, errors.New(\"error\")\n\t\t\t}\n\n\t\t\treturn g.mc.principal.Call(ctx, sessionID, method, params)\n\t\t})\n\t\tdefer g.mc.resetCall()\n\n\t\tp.MustWaitStable()\n\t})\n}\n\nfunc TestPageWaitIdle(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tp.MustElement(\"button\").MustClick()\n\tp.MustWaitIdle()\n\n\tg.True(p.MustHas(\"[a=ok]\"))\n}\n\nfunc TestPageEventSession(t *testing.T) {\n\tg := setup(t)\n\n\ts := g.Serve()\n\tp := g.newPage(s.URL())\n\n\tp.EnableDomain(proto.NetworkEnable{})\n\tgo g.page.Context(g.Context()).EachEvent(func(_ *proto.NetworkRequestWillBeSent) {\n\t\tg.Log(\"should not goes to here\")\n\t\tg.Fail()\n\t})()\n\tp.MustEval(`u => fetch(u)`, s.URL())\n}\n\nfunc TestPageWaitEvent(t *testing.T) {\n\tg := setup(t)\n\n\twait := g.page.WaitEvent(&proto.PageFrameNavigated{})\n\tg.page.MustNavigate(g.blank())\n\twait()\n}\n\nfunc TestPageWaitEventParseEventOnlyOnce(t *testing.T) {\n\tg := setup(t)\n\n\tnav1 := g.page.WaitEvent(&proto.PageFrameNavigated{})\n\tnav2 := g.page.WaitEvent(&proto.PageFrameNavigated{})\n\tg.page.MustNavigate(g.blank())\n\tnav1()\n\tnav2()\n}\n\nfunc TestPageEvent(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.browser.MustPage()\n\tctx := g.Context()\n\tevents := p.Context(ctx).Event()\n\tp.MustNavigate(g.blank())\n\tfor msg := range events {\n\t\tif msg.Load(proto.PageFrameStartedLoading{}) {\n\t\t\tbreak\n\t\t}\n\t}\n\tutils.Sleep(0.3)\n\tctx.Cancel()\n\n\tgo func() {\n\t\tfor range p.Event() {\n\t\t\tutils.Noop()\n\t\t}\n\t}()\n\tp.MustClose()\n}\n\nfunc TestPageStopEventAfterDetach(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.browser.MustPage().Context(g.Context())\n\tgo func() {\n\t\tutils.Sleep(0.3)\n\t\tp.MustClose()\n\t}()\n\tfor range p.Event() {\n\t\tutils.Noop()\n\t}\n}\n\nfunc TestAlert(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.srcFile(\"fixtures/alert.html\"))\n\n\twait, handle := page.MustHandleDialog()\n\n\tgo page.MustElement(\"button\").MustClick()\n\n\te := wait()\n\tg.Eq(e.Message, \"clicked\")\n\thandle(true, \"\")\n}\n\nfunc TestPageHandleFileDialog(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(`[type=file]`)\n\n\tsetFiles := p.MustHandleFileDialog()\n\tel.MustClick()\n\tsetFiles(slash(\"fixtures/click.html\"), slash(\"fixtures/alert.html\"))\n\n\tlist := el.MustEval(\"() => Array.from(this.files).map(f => f.name)\").Arr()\n\tg.Len(list, 2)\n\tg.Eq(\"alert.html\", list[1].String())\n\n\t{\n\t\tg.mc.stubErr(1, proto.PageSetInterceptFileChooserDialog{})\n\t\tg.Err(p.HandleFileDialog())\n\t}\n\t{\n\t\tg.mc.stubErr(2, proto.PageSetInterceptFileChooserDialog{})\n\t\tsetFiles, _ := p.HandleFileDialog()\n\t\tel.MustClick()\n\t\tg.Err(setFiles([]string{slash(\"fixtures/click.html\")}))\n\t\tg.E(proto.PageSetInterceptFileChooserDialog{Enabled: false}.Call(p))\n\t}\n}\n\nfunc TestPageScreenshot(t *testing.T) {\n\tg := setup(t)\n\n\tf := filepath.Join(\"tmp\", \"screenshots\", g.RandStr(16)+\".png\")\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tp.MustElement(\"button\")\n\tp.MustScreenshot()\n\tdata := p.MustScreenshot(f)\n\timg, err := png.Decode(bytes.NewBuffer(data))\n\tg.E(err)\n\tg.Eq(1280, img.Bounds().Dx())\n\tg.Eq(800, img.Bounds().Dy())\n\tg.Nil(os.Stat(f))\n\n\tp.MustScreenshot(\"\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageCaptureScreenshot{})\n\t\tp.MustScreenshot()\n\t})\n}\n\nfunc TestScreenshotFullPage(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/scroll.html\"))\n\tp.MustElement(\"button\")\n\tdata := p.MustScreenshotFullPage()\n\timg, err := png.Decode(bytes.NewBuffer(data))\n\tg.E(err)\n\tres := p.MustEval(`() => ({w: document.documentElement.scrollWidth, h: document.documentElement.scrollHeight})`)\n\tg.Eq(res.Get(\"w\").Int(), img.Bounds().Dx())\n\tg.Eq(res.Get(\"h\").Int(), img.Bounds().Dy())\n\n\t// after the full page screenshot the window size should be the same as before\n\tres = p.MustEval(`() => ({w: innerWidth, h: innerHeight})`)\n\tg.Eq(1280, res.Get(\"w\").Int())\n\tg.Eq(800, res.Get(\"h\").Int())\n\n\tp.MustScreenshotFullPage()\n\n\tnoEmulation := g.newPage(g.blank())\n\tg.E(noEmulation.SetViewport(nil))\n\tnoEmulation.MustScreenshotFullPage()\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PageGetLayoutMetrics{})\n\t\tp.MustScreenshotFullPage()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.EmulationSetDeviceMetricsOverride{})\n\t\tp.MustScreenshotFullPage()\n\t})\n\n\tg.Panic(func() {\n\t\tg.mc.stub(1, proto.PageGetLayoutMetrics{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(proto.PageGetLayoutMetricsResult{}), nil\n\t\t})\n\t\tp.MustScreenshotFullPage()\n\t})\n}\n\nfunc TestScrollScreenshot(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/scroll-y.html\"))\n\tp.MustElement(\"button\")\n\tdata := p.MustScrollScreenshot()\n\timg, err := png.Decode(bytes.NewBuffer(data))\n\tg.E(err)\n\tres := p.MustEval(`() => ({w: document.documentElement.scrollWidth, h: document.documentElement.scrollHeight})`)\n\t// ScrollScreenshot do not support horizontal scrolling yet,\n\t// the width should be the same as the viewport.\n\t// However, since different devices have different scroll bar widths, this value may be different on different devices. We will not make test assertions for the time being.\n\tg.True(1280 >= img.Bounds().Dx() || 1000 <= img.Bounds().Dx())\n\tg.Eq(res.Get(\"h\").Int(), img.Bounds().Dy())\n\n\t// after the full page screenshot the window size should be the same as before\n\tres = p.MustEval(`() => ({w: innerWidth, h: innerHeight})`)\n\tg.Eq(1280, res.Get(\"w\").Int())\n\tg.Eq(800, res.Get(\"h\").Int())\n\n\tp.MustScrollScreenshot()\n\n\tnoEmulation := g.newPage(g.blank())\n\tg.E(noEmulation.SetViewport(nil))\n\tnoEmulation.MustScrollScreenshot()\n}\n\nfunc TestScrollScreenshotErrors(t *testing.T) {\n\tg := setup(t)\n\tg.cancelTimeout()\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/scroll-y.html\"))\n\n\tg.Panic(func() {\n\t\t// mock error for get CSSContentSize\n\t\tg.mc.stubErr(1, proto.PageGetLayoutMetrics{})\n\t\tp.MustScrollScreenshot()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stub(1, proto.PageGetLayoutMetrics{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(proto.PageGetLayoutMetricsResult{\n\t\t\t\tCSSVisualViewport: &proto.PageVisualViewport{},\n\t\t\t}), nil\n\t\t})\n\t\tp.MustScrollScreenshot()\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stub(1, proto.PageGetLayoutMetrics{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(proto.PageGetLayoutMetricsResult{\n\t\t\t\tCSSContentSize: &proto.DOMRect{},\n\t\t\t}), nil\n\t\t})\n\t\tp.MustScrollScreenshot()\n\t})\n\tg.Panic(func() {\n\t\t// mock error for scroll\n\t\tg.mc.stubErr(1, proto.InputDispatchMouseEvent{})\n\t\tp.MustScrollScreenshot()\n\t})\n\tg.Panic(func() {\n\t\t// mock error for Screenshot\n\t\tg.mc.stubErr(1, proto.PageCaptureScreenshot{})\n\t\tp.MustScrollScreenshot()\n\t})\n\tg.Panic(func() {\n\t\t// mock error for WaitStable\n\t\tg.mc.stubErr(1, proto.DOMSnapshotCaptureSnapshot{})\n\t\tp.MustScrollScreenshot()\n\t})\n\n\t// test unsupported format\n\t_, err := p.ScrollScreenshot(&rod.ScrollScreenshotOptions{\n\t\t/* cspell: disable-next-line */\n\t\tFormat:  proto.PageCaptureScreenshotFormatWebp,\n\t\tQuality: gson.Int(10),\n\t})\n\tg.Err(err)\n}\n\nfunc TestScreenshotFullPageInit(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage(g.srcFile(\"fixtures/scroll.html\"))\n\n\t// should not panic\n\tp.MustScreenshotFullPage()\n}\n\nfunc TestPageConsoleLog(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage(g.blank()).MustWaitLoad()\n\te := &proto.RuntimeConsoleAPICalled{}\n\twait := p.WaitEvent(e)\n\tp.MustEval(`() => console.log(1, {b: ['test']})`)\n\twait()\n\tg.Eq(\"test\", p.MustObjectToJSON(e.Args[1]).Get(\"b.0\").String())\n\tg.Eq(`1 map[b:[test]]`, p.MustObjectsToJSON(e.Args).Join(\" \"))\n}\n\nfunc TestFonts(t *testing.T) {\n\tg := setup(t)\n\n\tif !utils.InContainer { // No need to test font rendering on regular OS\n\t\tg.SkipNow()\n\t}\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/fonts.html\")).MustWaitLoad()\n\n\tp.MustPDF(\"tmp\", \"fonts.pdf\") // download the file from Github Actions Artifacts\n}\n\nfunc TestPagePDF(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\")).MustWaitLoad()\n\n\ts, err := p.PDF(&proto.PagePrintToPDF{})\n\tg.E(err)\n\tg.Nil(s.Close())\n\n\tp.MustPDF(\"\")\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.PagePrintToPDF{})\n\t\tp.MustPDF()\n\t})\n}\n\nfunc TestPageNavigateNetworkErr(t *testing.T) {\n\tg := setup(t)\n\tp := g.newPage()\n\n\terr := p.Navigate(\"http://127.0.0.1:1\")\n\tg.Is(err, &rod.NavigationError{})\n\tg.Is(err.Error(), \"navigation failed: net::ERR_NAME_NOT_RESOLVED\")\n\tp.MustNavigate(\"about:blank\")\n}\n\nfunc TestPageNavigateErr(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"TODO: This test on Windows is flaky\")\n\t}\n\n\tg := setup(t)\n\n\ts := g.Serve()\n\n\ts.Mux.HandleFunc(\"/404\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\ts.Mux.HandleFunc(\"/500\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t})\n\n\tg.Is(g.Panic(func() {\n\t\tg.page.MustNavigate(s.URL(\"/404\"))\n\t}), &rod.NavigationError{})\n\tg.Is(g.Panic(func() {\n\t\tg.page.MustNavigate(s.URL(\"/500\"))\n\t}), &rod.NavigationError{})\n}\n\nfunc TestPageWaitLoadErr(t *testing.T) {\n\tg := setup(t)\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tg.page.MustWaitLoad()\n\t})\n}\n\nfunc TestPageNavigation(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage().MustReload()\n\n\twait := p.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\tp.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\twait()\n\n\twait = p.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\tp.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\twait()\n\n\twait = p.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\tp.MustNavigateBack()\n\twait()\n\tg.Regex(\"fixtures/click.html$\", p.MustInfo().URL)\n\n\twait = p.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\tp.MustNavigateForward()\n\twait()\n\tg.Regex(\"fixtures/selector.html$\", p.MustInfo().URL)\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(p.Reload())\n}\n\nfunc TestPagePool(t *testing.T) {\n\tg := setup(t)\n\n\tpool := rod.NewPagePool(3)\n\n\tp, err := pool.Get(func() (*rod.Page, error) {\n\t\treturn g.browser.Page(proto.TargetCreateTarget{})\n\t})\n\tg.E(err)\n\tpool.Put(p)\n\n\tp = pool.MustGet(func() *rod.Page { return g.browser.MustPage() })\n\tpool.Put(p)\n\n\tpool.Cleanup(func(p *rod.Page) {\n\t\tp.MustClose()\n\t})\n}\n\nfunc TestPageUseNonExistSession(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.browser.PageFromSession(\"not-exist\")\n\terr := proto.PageClose{}.Call(p)\n\tg.Eq(err, cdp.ErrSessionNotFound)\n}\n\nfunc TestPageElementFromObjectErr(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.newPage()\n\twait := p.WaitNavigation(proto.PageLifecycleEventNameLoad)\n\tp.MustNavigate(g.srcFile(\"./fixtures/click.html\"))\n\twait()\n\tres, err := proto.DOMGetNodeForLocation{X: 10, Y: 10}.Call(p)\n\tg.E(err)\n\n\tobj, err := proto.DOMResolveNode{\n\t\tBackendNodeID: res.BackendNodeID,\n\t}.Call(p)\n\tg.E(err)\n\n\tg.mc.stubErr(1, proto.RuntimeEvaluate{})\n\tg.Err(p.ElementFromObject(obj.Object))\n}\n\nfunc TestPageTriggerFavicon(t *testing.T) {\n\tg := setup(t)\n\ts := g.Serve()\n\t// test browser in no-headless mode with an error\n\t{\n\t\tpage := g.newPage()\n\t\tpage.MustNavigate(s.URL())\n\t\tg.mc.stub(1, proto.BrowserGetBrowserCommandLine{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\tcommandLine := proto.BrowserGetBrowserCommandLineResult{Arguments: []string{\"\"}}\n\t\t\treturn gson.New(commandLine), nil\n\t\t})\n\t\terr := page.TriggerFavicon()\n\t\tg.Eq(err.Error(), \"browser is no-headless\")\n\t}\n\n\t// test browser in headless mode to trigger favicon request\n\t{\n\t\tfaviconURL := fmt.Sprintf(s.HostURL.String(), \"/favicon.ico\")\n\t\ts.Route(\"/test\", \"\")\n\t\ts.Route(\"/favicon.ico\", filepath.FromSlash(\"./fixtures/icon.png\"))\n\t\tpage := g.newPage()\n\t\tpage.MustNavigate(s.URL(\"/test\"))\n\t\tpage.MustWaitIdle()\n\t\tgo page.Context(g.Context()).EachEvent(\n\t\t\tfunc(e *proto.NetworkRequestWillBeSent) {\n\t\t\t\tif e.Request.URL == faviconURL {\n\t\t\t\t\tg.Eq(e.Request.URL, faviconURL)\n\t\t\t\t}\n\t\t\t},\n\t\t)()\n\t\tpage.MustTriggerFavicon()\n\t}\n\n\t// test browser in headless mode to trigger favicon request with an error\n\t{\n\t\tp := g.newPage().MustNavigate(s.URL())\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tg.Panic(func() {\n\t\t\tp.MustTriggerFavicon()\n\t\t})\n\t}\n}\n\nfunc TestPageActionAfterClose(t *testing.T) {\n\tg := setup(t)\n\n\t{\n\t\tp := g.browser.MustPage(g.blank())\n\n\t\tp.MustClose()\n\n\t\t_, err := p.Element(\"not-exists\")\n\t\tg.Eq(err, context.Canceled)\n\t}\n\n\t{\n\t\tp := g.browser.MustPage(g.blank())\n\t\tgo func() {\n\t\t\tutils.Sleep(1)\n\t\t\tp.MustClose()\n\t\t}()\n\n\t\t_, err := p.Eval(`() => new Promise(r => {})`)\n\t\tg.Eq(err, context.Canceled)\n\t}\n}\n\nfunc TestPageResetNavigationHistory(t *testing.T) {\n\tconst (\n\t\t// After resetting history, the record should contain only the current page entry\n\t\texpectedInitialHistoryLength = 1\n\t\tclickHTMLPath                = \"fixtures/click.html\"\n\t\tinputHTMLPath                = \"fixtures/input.html\"\n\t)\n\n\tg := setup(t)\n\n\t// Helper function for navigation\n\tnavigateTo := func(p *rod.Page, url string) {\n\t\twait := p.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\t\tp.MustNavigate(url)\n\t\twait()\n\t}\n\n\t// Initialize page with blank content\n\tpage := g.page.MustNavigate(g.blank())\n\n\t// Navigate to multiple pages\n\tnavigateTo(page, g.srcFile(clickHTMLPath))\n\tnavigateTo(page, g.srcFile(inputHTMLPath))\n\n\t// Verify navigation back functionality\n\twait := page.WaitNavigation(proto.PageLifecycleEventNameDOMContentLoaded)\n\tpage.MustNavigateBack()\n\twait()\n\n\tg.Regex(`/`+clickHTMLPath, page.MustInfo().URL)\n\n\t// Verify history has multiple entries\n\tinitialHistory, err := page.GetNavigationHistory()\n\tg.E(err)\n\tg.NotNil(initialHistory)\n\tg.Gt(len(initialHistory.Entries), expectedInitialHistoryLength)\n\n\t// Test resetting navigation history\n\terr = page.ResetNavigationHistory()\n\tg.E(err)\n\n\t// Verify history is reset to initial state\n\tresetHistory, err := page.GetNavigationHistory()\n\tg.E(err)\n\tg.NotNil(resetHistory)\n\tg.Eq(len(resetHistory.Entries), expectedInitialHistoryLength)\n\n\t// Navigate to another page\n\tnavigateTo(page, g.srcFile(inputHTMLPath))\n\n\t// Test resetting history again\n\tpage.MustResetNavigationHistory()\n\n\t// Verify history is reset again\n\tfinalHistory, err := page.GetNavigationHistory()\n\tg.E(err)\n\tg.NotNil(finalHistory)\n\tg.Eq(len(finalHistory.Entries), expectedInitialHistoryLength)\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 14.3173828125,
          "content": "// This file contains all query related code for Page and Element to separate the concerns.\n\npackage rod\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/js\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\n// SelectorType enum.\ntype SelectorType string\n\nconst (\n\t// SelectorTypeRegex type.\n\tSelectorTypeRegex SelectorType = \"regex\"\n\t// SelectorTypeCSSSector type.\n\tSelectorTypeCSSSector SelectorType = \"css-selector\"\n\t// SelectorTypeText type.\n\tSelectorTypeText SelectorType = \"text\"\n)\n\n// Elements provides some helpers to deal with element list.\ntype Elements []*Element\n\n// First returns the first element, if the list is empty returns nil.\nfunc (els Elements) First() *Element {\n\tif els.Empty() {\n\t\treturn nil\n\t}\n\treturn els[0]\n}\n\n// Last returns the last element, if the list is empty returns nil.\nfunc (els Elements) Last() *Element {\n\tif els.Empty() {\n\t\treturn nil\n\t}\n\treturn els[len(els)-1]\n}\n\n// Empty returns true if the list is empty.\nfunc (els Elements) Empty() bool {\n\treturn len(els) == 0\n}\n\n// Pages provides some helpers to deal with page list.\ntype Pages []*Page\n\n// First returns the first page, if the list is empty returns nil.\nfunc (ps Pages) First() *Page {\n\tif ps.Empty() {\n\t\treturn nil\n\t}\n\treturn ps[0]\n}\n\n// Last returns the last page, if the list is empty returns nil.\nfunc (ps Pages) Last() *Page {\n\tif ps.Empty() {\n\t\treturn nil\n\t}\n\treturn ps[len(ps)-1]\n}\n\n// Empty returns true if the list is empty.\nfunc (ps Pages) Empty() bool {\n\treturn len(ps) == 0\n}\n\n// Find the page that has the specified element with the css selector.\nfunc (ps Pages) Find(selector string) (*Page, error) {\n\tfor _, page := range ps {\n\t\thas, _, err := page.Has(selector)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif has {\n\t\t\treturn page, nil\n\t\t}\n\t}\n\treturn nil, &PageNotFoundError{}\n}\n\n// FindByURL returns the page that has the url that matches the jsRegex.\nfunc (ps Pages) FindByURL(jsRegex string) (*Page, error) {\n\tfor _, page := range ps {\n\t\tres, err := page.Eval(`() => location.href`)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\turl := res.Value.String()\n\t\tif regexp.MustCompile(jsRegex).MatchString(url) {\n\t\t\treturn page, nil\n\t\t}\n\t}\n\treturn nil, &PageNotFoundError{}\n}\n\n// Has an element that matches the css selector.\nfunc (p *Page) Has(selector string) (bool, *Element, error) {\n\tel, err := p.Sleeper(NotFoundSleeper).Element(selector)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\treturn true, el.Sleeper(p.sleeper), nil\n}\n\n// HasX an element that matches the XPath selector.\nfunc (p *Page) HasX(selector string) (bool, *Element, error) {\n\tel, err := p.Sleeper(NotFoundSleeper).ElementX(selector)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\treturn true, el.Sleeper(p.sleeper), nil\n}\n\n// HasR an element that matches the css selector and its display text matches the jsRegex.\nfunc (p *Page) HasR(selector, jsRegex string) (bool, *Element, error) {\n\tel, err := p.Sleeper(NotFoundSleeper).ElementR(selector, jsRegex)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\treturn true, el.Sleeper(p.sleeper), nil\n}\n\n// Element retries until an element in the page that matches the CSS selector, then returns\n// the matched element.\nfunc (p *Page) Element(selector string) (*Element, error) {\n\treturn p.ElementByJS(evalHelper(js.Element, selector))\n}\n\n// ElementR retries until an element in the page that matches the css selector and it's text matches the jsRegex,\n// then returns the matched element.\nfunc (p *Page) ElementR(selector, jsRegex string) (*Element, error) {\n\treturn p.ElementByJS(evalHelper(js.ElementR, selector, jsRegex))\n}\n\n// ElementX retries until an element in the page that matches one of the XPath selectors, then returns\n// the matched element.\nfunc (p *Page) ElementX(xPath string) (*Element, error) {\n\treturn p.ElementByJS(evalHelper(js.ElementX, xPath))\n}\n\n// ElementByJS returns the element from the return value of the js function.\n// If sleeper is nil, no retry will be performed.\n// By default, it will retry until the js function doesn't return null.\n// To customize the retry logic, check the examples of Page.Sleeper.\nfunc (p *Page) ElementByJS(opts *EvalOptions) (*Element, error) {\n\tvar res *proto.RuntimeRemoteObject\n\tvar err error\n\n\tremoveTrace := func() {}\n\terr = utils.Retry(p.ctx, p.sleeper(), func() (bool, error) {\n\t\tremove := p.tryTraceQuery(opts)\n\t\tremoveTrace()\n\t\tremoveTrace = remove\n\n\t\tres, err = p.Evaluate(opts.ByObject())\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tif res.Type == proto.RuntimeRemoteObjectTypeObject && res.Subtype == proto.RuntimeRemoteObjectSubtypeNull {\n\t\t\treturn false, nil\n\t\t}\n\n\t\treturn true, nil\n\t})\n\tremoveTrace()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.Subtype != proto.RuntimeRemoteObjectSubtypeNode {\n\t\treturn nil, &ExpectElementError{res}\n\t}\n\n\treturn p.ElementFromObject(res)\n}\n\n// Elements returns all elements that match the css selector.\nfunc (p *Page) Elements(selector string) (Elements, error) {\n\treturn p.ElementsByJS(evalHelper(js.Elements, selector))\n}\n\n// ElementsX returns all elements that match the XPath selector.\nfunc (p *Page) ElementsX(xpath string) (Elements, error) {\n\treturn p.ElementsByJS(evalHelper(js.ElementsX, xpath))\n}\n\n// ElementsByJS returns the elements from the return value of the js.\nfunc (p *Page) ElementsByJS(opts *EvalOptions) (Elements, error) {\n\tres, err := p.Evaluate(opts.ByObject())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.Subtype != proto.RuntimeRemoteObjectSubtypeArray {\n\t\treturn nil, &ExpectElementsError{res}\n\t}\n\n\tdefer func() { err = p.Release(res) }()\n\n\tlist, err := proto.RuntimeGetProperties{\n\t\tObjectID:      res.ObjectID,\n\t\tOwnProperties: true,\n\t}.Call(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\telemList := Elements{}\n\tfor _, obj := range list.Result {\n\t\tif obj.Name == \"__proto__\" || obj.Name == \"length\" {\n\t\t\tcontinue\n\t\t}\n\t\tval := obj.Value\n\n\t\tif val.Subtype != proto.RuntimeRemoteObjectSubtypeNode {\n\t\t\treturn nil, &ExpectElementsError{val}\n\t\t}\n\n\t\tel, err := p.ElementFromObject(val)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\telemList = append(elemList, el)\n\t}\n\n\treturn elemList, err\n}\n\n// Search for the given query in the DOM tree until the result count is not zero, before that it will keep retrying.\n// The query can be plain text or css selector or xpath.\n// It will search nested iframes and shadow doms too.\nfunc (p *Page) Search(query string) (*SearchResult, error) {\n\tsr := &SearchResult{\n\t\tpage:    p,\n\t\trestore: p.EnableDomain(proto.DOMEnable{}),\n\t}\n\n\terr := utils.Retry(p.ctx, p.sleeper(), func() (bool, error) {\n\t\tif sr.DOMPerformSearchResult != nil {\n\t\t\t_ = proto.DOMDiscardSearchResults{SearchID: sr.SearchID}.Call(p)\n\t\t}\n\n\t\tres, err := proto.DOMPerformSearch{\n\t\t\tQuery:                     query,\n\t\t\tIncludeUserAgentShadowDOM: true,\n\t\t}.Call(p)\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tsr.DOMPerformSearchResult = res\n\n\t\tif res.ResultCount == 0 {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tresult, err := proto.DOMGetSearchResults{\n\t\t\tSearchID:  res.SearchID,\n\t\t\tFromIndex: 0,\n\t\t\tToIndex:   1,\n\t\t}.Call(p)\n\t\tif err != nil {\n\t\t\t// when the page is still loading the search result is not ready\n\t\t\tif errors.Is(err, cdp.ErrCtxNotFound) ||\n\t\t\t\terrors.Is(err, cdp.ErrSearchSessionNotFound) {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\treturn true, err\n\t\t}\n\n\t\tid := result.NodeIDs[0]\n\n\t\t// TODO: This is definitely a bad design of cdp, hope they can optimize it in the future.\n\t\t// It's unnecessary to ask the user to explicitly call it.\n\t\t//\n\t\t// When the id is zero, it means the proto.DOMDocumentUpdated has fired which will\n\t\t// invalidate all the existing NodeID. We have to call proto.DOMGetDocument\n\t\t// to reset the remote browser's tracker.\n\t\tif id == 0 {\n\t\t\t_, _ = proto.DOMGetDocument{}.Call(p)\n\t\t\treturn false, nil\n\t\t}\n\n\t\tel, err := p.ElementFromNode(&proto.DOMNode{NodeID: id})\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tsr.First = el\n\n\t\treturn true, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn sr, nil\n}\n\n// SearchResult handler.\ntype SearchResult struct {\n\t*proto.DOMPerformSearchResult\n\n\tpage    *Page\n\trestore func()\n\n\t// First element in the search result\n\tFirst *Element\n}\n\n// Get l elements at the index of i from the remote search result.\nfunc (s *SearchResult) Get(i, l int) (Elements, error) {\n\tresult, err := proto.DOMGetSearchResults{\n\t\tSearchID:  s.SearchID,\n\t\tFromIndex: i,\n\t\tToIndex:   i + l,\n\t}.Call(s.page)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlist := Elements{}\n\n\tfor _, id := range result.NodeIDs {\n\t\tel, err := s.page.ElementFromNode(&proto.DOMNode{NodeID: id})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlist = append(list, el)\n\t}\n\n\treturn list, nil\n}\n\n// All returns all elements.\nfunc (s *SearchResult) All() (Elements, error) {\n\treturn s.Get(0, s.ResultCount)\n}\n\n// Release the remote search result.\nfunc (s *SearchResult) Release() {\n\ts.restore()\n\t_ = proto.DOMDiscardSearchResults{SearchID: s.SearchID}.Call(s.page)\n}\n\ntype raceBranch struct {\n\tcondition func(*Page) (*Element, error)\n\tcallback  func(*Element) error\n}\n\n// RaceContext stores the branches to race.\ntype RaceContext struct {\n\tpage     *Page\n\tbranches []*raceBranch\n}\n\n// Race creates a context to race selectors.\nfunc (p *Page) Race() *RaceContext {\n\treturn &RaceContext{page: p}\n}\n\n// ElementFunc takes a custom function to determine race success.\nfunc (rc *RaceContext) ElementFunc(fn func(*Page) (*Element, error)) *RaceContext {\n\trc.branches = append(rc.branches, &raceBranch{\n\t\tcondition: fn,\n\t})\n\treturn rc\n}\n\n// Element is similar to [Page.Element].\nfunc (rc *RaceContext) Element(selector string) *RaceContext {\n\treturn rc.ElementFunc(func(p *Page) (*Element, error) {\n\t\treturn p.Element(selector)\n\t})\n}\n\n// ElementX is similar to [Page.ElementX].\nfunc (rc *RaceContext) ElementX(selector string) *RaceContext {\n\treturn rc.ElementFunc(func(p *Page) (*Element, error) {\n\t\treturn p.ElementX(selector)\n\t})\n}\n\n// ElementR is similar to [Page.ElementR].\nfunc (rc *RaceContext) ElementR(selector, regex string) *RaceContext {\n\treturn rc.ElementFunc(func(p *Page) (*Element, error) {\n\t\treturn p.ElementR(selector, regex)\n\t})\n}\n\n// ElementByJS is similar to [Page.ElementByJS].\nfunc (rc *RaceContext) ElementByJS(opts *EvalOptions) *RaceContext {\n\treturn rc.ElementFunc(func(p *Page) (*Element, error) {\n\t\treturn p.ElementByJS(opts)\n\t})\n}\n\n// Search is similar to [Page.Search].\nfunc (rc *RaceContext) Search(query string) *RaceContext {\n\treturn rc.ElementFunc(func(p *Page) (*Element, error) {\n\t\tres, err := p.Search(query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres.Release()\n\t\treturn res.First, nil\n\t})\n}\n\n// Handle adds a callback function to the most recent chained selector.\n// The callback function is run, if the corresponding selector is\n// present first, in the Race condition.\nfunc (rc *RaceContext) Handle(callback func(*Element) error) *RaceContext {\n\trc.branches[len(rc.branches)-1].callback = callback\n\treturn rc\n}\n\n// Do the race.\nfunc (rc *RaceContext) Do() (*Element, error) {\n\tvar el *Element\n\terr := utils.Retry(rc.page.ctx, rc.page.sleeper(), func() (stop bool, err error) {\n\t\tfor _, branch := range rc.branches {\n\t\t\tbEl, err := branch.condition(rc.page.Sleeper(NotFoundSleeper))\n\t\t\tif err == nil {\n\t\t\t\tel = bEl.Sleeper(rc.page.sleeper)\n\n\t\t\t\tif branch.callback != nil {\n\t\t\t\t\terr = branch.callback(el)\n\t\t\t\t}\n\t\t\t\treturn true, err\n\t\t\t} else if !errors.Is(err, &ElementNotFoundError{}) {\n\t\t\t\treturn true, err\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n\treturn el, err\n}\n\n// Has an element that matches the css selector.\nfunc (el *Element) Has(selector string) (bool, *Element, error) {\n\tel, err := el.Element(selector)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\treturn err == nil, el, err\n}\n\n// HasX an element that matches the XPath selector.\nfunc (el *Element) HasX(selector string) (bool, *Element, error) {\n\tel, err := el.ElementX(selector)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\treturn err == nil, el, err\n}\n\n// HasR returns true if a child element that matches the css selector and its text matches the jsRegex.\nfunc (el *Element) HasR(selector, jsRegex string) (bool, *Element, error) {\n\tel, err := el.ElementR(selector, jsRegex)\n\tif errors.Is(err, &ElementNotFoundError{}) {\n\t\treturn false, nil, nil\n\t}\n\treturn err == nil, el, err\n}\n\n// Element returns the first child that matches the css selector.\nfunc (el *Element) Element(selector string) (*Element, error) {\n\treturn el.ElementByJS(evalHelper(js.Element, selector))\n}\n\n// ElementR returns the first child element that matches the css selector and its text matches the jsRegex.\nfunc (el *Element) ElementR(selector, jsRegex string) (*Element, error) {\n\treturn el.ElementByJS(evalHelper(js.ElementR, selector, jsRegex))\n}\n\n// ElementX returns the first child that matches the XPath selector.\nfunc (el *Element) ElementX(xPath string) (*Element, error) {\n\treturn el.ElementByJS(evalHelper(js.ElementX, xPath))\n}\n\n// ElementByJS returns the element from the return value of the js.\nfunc (el *Element) ElementByJS(opts *EvalOptions) (*Element, error) {\n\te, err := el.page.Context(el.ctx).Sleeper(NotFoundSleeper).ElementByJS(opts.This(el.Object))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e.Sleeper(el.sleeper), nil\n}\n\n// Parent returns the parent element in the DOM tree.\nfunc (el *Element) Parent() (*Element, error) {\n\treturn el.ElementByJS(Eval(`() => this.parentElement`))\n}\n\n// Parents that match the selector.\nfunc (el *Element) Parents(selector string) (Elements, error) {\n\treturn el.ElementsByJS(evalHelper(js.Parents, selector))\n}\n\n// Next returns the next sibling element in the DOM tree.\nfunc (el *Element) Next() (*Element, error) {\n\treturn el.ElementByJS(Eval(`() => this.nextElementSibling`))\n}\n\n// Previous returns the previous sibling element in the DOM tree.\nfunc (el *Element) Previous() (*Element, error) {\n\treturn el.ElementByJS(Eval(`() => this.previousElementSibling`))\n}\n\n// Elements returns all elements that match the css selector.\nfunc (el *Element) Elements(selector string) (Elements, error) {\n\treturn el.ElementsByJS(evalHelper(js.Elements, selector))\n}\n\n// ElementsX returns all elements that match the XPath selector.\nfunc (el *Element) ElementsX(xpath string) (Elements, error) {\n\treturn el.ElementsByJS(evalHelper(js.ElementsX, xpath))\n}\n\n// ElementsByJS returns the elements from the return value of the js.\nfunc (el *Element) ElementsByJS(opts *EvalOptions) (Elements, error) {\n\treturn el.page.Context(el.ctx).ElementsByJS(opts.This(el.Object))\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 11.5986328125,
          "content": "package rod_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/defaults\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/gson\"\n)\n\nfunc TestPageElements(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tg.page.MustElement(\"input\")\n\tlist := g.page.MustElements(\"input\")\n\tg.Eq(\"input\", list.First().MustDescribe().LocalName)\n\tg.Eq(\"submit\", list.Last().MustText())\n}\n\nfunc TestPagesQuery(t *testing.T) {\n\tg := setup(t)\n\n\tb := g.browser\n\n\tb.MustPage(g.srcFile(\"fixtures/click.html\")).MustWaitLoad()\n\tpages := b.MustPages()\n\n\tg.True(pages.MustFind(\"button\").MustHas(\"button\"))\n\tg.Panic(func() { rod.Pages{}.MustFind(\"____\") })\n\tg.True(pages.MustFindByURL(\"click.html\").MustHas(\"button\"))\n\tg.Panic(func() { rod.Pages{}.MustFindByURL(\"____\") })\n\n\t_, err := pages.Find(\"____\")\n\tg.Err(err)\n\tg.Eq(err.Error(), \"cannot find page\")\n\tg.Panic(func() {\n\t\tpages.MustFindByURL(\"____\")\n\t})\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tpages.MustFind(\"button\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tpages.MustFindByURL(\"____\")\n\t})\n}\n\nfunc TestPagesOthers(t *testing.T) {\n\tg := setup(t)\n\n\tlist := rod.Pages{}\n\tg.Nil(list.First())\n\tg.Nil(list.Last())\n\n\tlist = append(list, &rod.Page{})\n\n\tg.NotNil(list.First())\n\tg.NotNil(list.Last())\n}\n\nfunc TestPageHas(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tg.page.MustElement(\"body\")\n\tg.True(g.page.MustHas(\"span\"))\n\tg.False(g.page.MustHas(\"a\"))\n\tg.True(g.page.MustHasX(\"//span\"))\n\tg.False(g.page.MustHasX(\"//a\"))\n\tg.True(g.page.MustHasR(\"button\", \"03\"))\n\tg.False(g.page.MustHasR(\"button\", \"11\"))\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(g.page.HasX(\"//a\"))\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(g.page.HasR(\"button\", \"03\"))\n}\n\nfunc TestElementHas(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tb := g.page.MustElement(\"body\")\n\tg.True(b.MustHas(\"span\"))\n\tg.False(b.MustHas(\"a\"))\n\tg.True(b.MustHasX(\"//span\"))\n\tg.False(b.MustHasX(\"//a\"))\n\tg.True(b.MustHasR(\"button\", \"03\"))\n\tg.False(b.MustHasR(\"button\", \"11\"))\n}\n\nfunc TestSearch(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\n\tel := p.MustSearch(\"click me\")\n\tg.Eq(\"click me\", el.MustText())\n\tg.True(el.MustClick().MustMatches(\"[a=ok]\"))\n\n\t_, err := p.Sleeper(rod.NotFoundSleeper).Search(\"not-exists\")\n\tg.True(errors.Is(err, &rod.ElementNotFoundError{}))\n\tg.Eq(err.Error(), \"cannot find element\")\n\n\t// when search result is not ready\n\t{\n\t\tg.mc.stub(1, proto.DOMGetSearchResults{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(nil), cdp.ErrCtxNotFound\n\t\t})\n\t\tp.MustSearch(\"click me\")\n\t}\n\n\t// when node id is zero\n\t{\n\t\tg.mc.stub(1, proto.DOMGetSearchResults{}, func(_ StubSend) (gson.JSON, error) {\n\t\t\treturn gson.New(proto.DOMGetSearchResultsResult{\n\t\t\t\tNodeIDs: []proto.DOMNodeID{0},\n\t\t\t}), nil\n\t\t})\n\t\tp.MustSearch(\"click me\")\n\t}\n\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMPerformSearch{})\n\t\tp.MustSearch(\"click me\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.DOMGetSearchResults{})\n\t\tp.MustSearch(\"click me\")\n\t})\n\tg.Panic(func() {\n\t\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\t\tp.MustSearch(\"click me\")\n\t})\n}\n\nfunc TestSearchElements(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\n\t{\n\t\tres, err := p.Search(\"button\")\n\t\tg.E(err)\n\n\t\tc, err := res.All()\n\t\tg.E(err)\n\n\t\tg.Len(c, 4)\n\n\t\tg.mc.stubErr(1, proto.DOMGetSearchResults{})\n\t\tg.Err(res.All())\n\n\t\tg.mc.stubErr(1, proto.DOMResolveNode{})\n\t\tg.Err(res.All())\n\t}\n\n\t{ // disable retry\n\t\tsleeper := func() utils.Sleeper { return utils.CountSleeper(1) }\n\t\t_, err := p.Sleeper(sleeper).Search(\"not-exists\")\n\t\tg.Err(err)\n\t}\n}\n\nfunc TestSearchIframes(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click-iframes.html\"))\n\tel := p.MustSearch(\"button[onclick]\")\n\tg.Eq(\"click me\", el.MustText())\n\tg.True(el.MustClick().MustMatches(\"[a=ok]\"))\n}\n\nfunc TestSearchIframesAfterReload(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click-iframes.html\"))\n\tframe := p.MustElement(\"iframe\").MustFrame().MustElement(\"iframe\").MustFrame()\n\tframe.MustReload()\n\tel := p.MustSearch(\"button[onclick]\")\n\tg.Eq(\"click me\", el.MustText())\n\tg.True(el.MustClick().MustMatches(\"[a=ok]\"))\n}\n\nfunc TestPageRace(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\n\tp.Race().Element(\"button\").MustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) }).MustDo()\n\tg.Eq(\"01\", p.Race().Element(\"button\").MustDo().MustText())\n\n\tp.Race().ElementX(\"//button\").MustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) }).MustDo()\n\tg.Eq(\"01\", p.Race().ElementX(\"//button\").MustDo().MustText())\n\n\tp.Race().ElementR(\"button\", \"02\").MustHandle(func(e *rod.Element) { g.Eq(\"02\", e.MustText()) }).MustDo()\n\tg.Eq(\"02\", p.Race().ElementR(\"button\", \"02\").MustDo().MustText())\n\n\tp.Race().MustElementByJS(\"() => document.querySelector('button')\", nil).\n\t\tMustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) }).MustDo()\n\tg.Eq(\"01\", p.Race().MustElementByJS(\"() => document.querySelector('button')\", nil).MustDo().MustText())\n\n\tp.Race().Search(\"button\").MustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) }).MustDo()\n\tg.Eq(\"01\", p.Race().Search(\"button\").MustDo().MustText())\n\n\traceFunc := func(p *rod.Page) (*rod.Element, error) {\n\t\tel := p.MustElement(\"button\")\n\t\tg.Eq(\"01\", el.MustText())\n\t\treturn el, nil\n\t}\n\tp.Race().ElementFunc(raceFunc).MustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) }).MustDo()\n\tg.Eq(\"01\", p.Race().ElementFunc(raceFunc).MustDo().MustText())\n\n\tel, err := p.Sleeper(func() utils.Sleeper { return utils.CountSleeper(2) }).Race().\n\t\tElement(\"not-exists\").MustHandle(func(_ *rod.Element) {}).\n\t\tElementX(\"//not-exists\").\n\t\tElementR(\"not-exists\", \"test\").MustHandle(func(_ *rod.Element) {}).\n\t\tDo()\n\tg.Err(err)\n\tg.Nil(el)\n\n\tel, err = p.Race().MustElementByJS(`() => notExists()`, nil).Do()\n\tg.Err(err)\n\tg.Nil(el)\n}\n\nfunc TestPageRaceRetryInHandle(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tp.Race().Element(\"div\").MustHandle(func(e *rod.Element) {\n\t\tgo func() {\n\t\t\tutils.Sleep(0.5)\n\t\t\te.MustElement(\"button\").MustEval(`() => this.innerText = '04'`)\n\t\t}()\n\t\te.MustElement(\"button\").MustWait(\"() => this.innerText === '04'\")\n\t}).MustDo()\n}\n\nfunc TestPageRaceSearchCrossIframe(t *testing.T) {\n\tg := setup(t)\n\tg.srcFile(\"fixtures/selector.html\")\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/iframe.html\"))\n\n\trace := p.Race()\n\trace.Element(\"not exist\").MustHandle(func(_ *rod.Element) { panic(\"element not exist\") })\n\trace.Search(\"span\").MustHandle(func(e *rod.Element) { g.Eq(\"01\", e.MustText()) })\n\trace.MustDo()\n}\n\nfunc TestPageElementX(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tg.page.MustElement(\"body\")\n\ttxt := g.page.MustElementX(\"//div\").MustElementX(\"./button\").MustText()\n\tg.Eq(txt, \"02\")\n}\n\nfunc TestPageElementsX(t *testing.T) {\n\tg := setup(t)\n\n\tg.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tg.page.MustElement(\"body\")\n\tlist := g.page.MustElementsX(\"//button\")\n\tg.Len(list, 4)\n}\n\nfunc TestElementR(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tel := p.MustElementR(\"button\", `\\d1`)\n\tg.Eq(\"01\", el.MustText())\n\n\tel = p.MustElement(\"div\").MustElementR(\"button\", `03`)\n\tg.Eq(\"03\", el.MustText())\n\n\tp = g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel = p.MustElementR(\"input\", `submit`)\n\tg.Eq(\"submit\", el.MustText())\n\n\tel = p.MustElementR(\"input\", `placeholder`)\n\tg.Eq(\"blur\", *el.MustAttribute(\"id\"))\n\n\tel = p.MustElementR(\"option\", `/cc/i`)\n\tg.Eq(\"CC\", el.MustText())\n}\n\nfunc TestElementFromElement(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tel := p.MustElement(\"div\").MustElement(\"button\")\n\tg.Eq(\"02\", el.MustText())\n}\n\nfunc TestElementsFromElement(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"form\")\n\tlist := p.MustElement(\"form\").MustElements(\"option\")\n\n\tg.Len(list, 4)\n\tg.Eq(\"B\", list[1].MustText())\n\n\tg.mc.stubErr(1, proto.RuntimeCallFunctionOn{})\n\tg.Err(el.Elements(\"input\"))\n}\n\nfunc TestElementParent(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tel := p.MustElement(\"input\").MustParent()\n\tg.Eq(\"FORM\", el.MustEval(`() => this.tagName`).String())\n}\n\nfunc TestElementParents(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/input.html\"))\n\tg.Len(p.MustElement(\"option\").MustParents(\"*\"), 4)\n\tg.Len(p.MustElement(\"option\").MustParents(\"form\"), 1)\n}\n\nfunc TestElementSiblings(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tel := p.MustElement(\"div\")\n\ta := el.MustPrevious()\n\tb := el.MustNext()\n\n\tg.Eq(a.MustText(), \"01\")\n\tg.Eq(b.MustText(), \"04\")\n}\n\nfunc TestElementFromElementX(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tel := p.MustElement(\"div\").MustElementX(\"./button\")\n\tg.Eq(\"02\", el.MustText())\n}\n\nfunc TestElementsFromElementsX(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\"))\n\tlist := p.MustElement(\"div\").MustElementsX(\"./button\")\n\tg.Len(list, 2)\n}\n\nfunc TestElementTracing(t *testing.T) {\n\tg := setup(t)\n\n\tg.browser.Trace(true)\n\tg.browser.Logger(utils.LoggerQuiet)\n\tdefer func() {\n\t\tg.browser.Trace(defaults.Trace)\n\t\tg.browser.Logger(rod.DefaultLogger)\n\t}()\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\tg.Eq(`rod.element(\"code\") html`, p.MustElement(\"html\").MustElement(\"code\").MustText())\n}\n\nfunc TestPageElementByJS(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/click.html\"))\n\n\tg.Eq(p.MustElementByJS(`() => document.querySelector('button')`).MustText(), \"click me\")\n\n\t_, err := p.ElementByJS(rod.Eval(`() => 1`))\n\tg.Is(err, &rod.ExpectElementError{})\n\tg.Eq(err.Error(), \"expect js to return an element, but got: {\\\"type\\\":\\\"number\\\",\\\"value\\\":1,\\\"description\\\":\\\"1\\\"}\")\n}\n\nfunc TestPageElementsByJS(t *testing.T) {\n\tg := setup(t)\n\n\tp := g.page.MustNavigate(g.srcFile(\"fixtures/selector.html\")).MustWaitLoad()\n\n\tg.Len(p.MustElementsByJS(\"() => document.querySelectorAll('button')\"), 4)\n\n\t_, err := p.ElementsByJS(rod.Eval(`() => [1]`))\n\tg.Is(err, &rod.ExpectElementsError{})\n\tg.Eq(err.Error(), \"expect js to return an array of elements, but got: {\\\"type\\\":\\\"number\\\",\\\"value\\\":1,\\\"description\\\":\\\"1\\\"}\")\n\t_, err = p.ElementsByJS(rod.Eval(`() => 1`))\n\tg.Eq(err.Error(), \"expect js to return an array of elements, but got: {\\\"type\\\":\\\"number\\\",\\\"value\\\":1,\\\"description\\\":\\\"1\\\"}\")\n\t_, err = p.ElementsByJS(rod.Eval(`() => foo()`))\n\tg.Err(err)\n\n\tg.mc.stubErr(1, proto.RuntimeGetProperties{})\n\t_, err = p.ElementsByJS(rod.Eval(`() => [document.body]`))\n\tg.Err(err)\n\n\tg.mc.stubErr(4, proto.RuntimeCallFunctionOn{})\n\tg.Err(p.Elements(\"button\"))\n}\n\nfunc TestPageElementTimeout(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.blank())\n\tstart := time.Now()\n\t_, err := page.Timeout(300 * time.Millisecond).Element(\"not-exists\")\n\tg.Is(err, context.DeadlineExceeded)\n\tg.Gte(time.Since(start), 300*time.Millisecond)\n}\n\nfunc TestPageElementMaxRetry(t *testing.T) {\n\tg := setup(t)\n\n\tpage := g.page.MustNavigate(g.blank())\n\ts := func() utils.Sleeper { return utils.CountSleeper(5) }\n\t_, err := page.Sleeper(s).Element(\"not-exists\")\n\tg.Is(err, &utils.MaxSleepCountError{})\n}\n\nfunc TestElementsOthers(t *testing.T) {\n\tg := setup(t)\n\n\tlist := rod.Elements{}\n\tg.Nil(list.First())\n\tg.Nil(list.Last())\n}\n"
        },
        {
          "name": "rod_test.go",
          "type": "blob",
          "size": 0.5419921875,
          "content": "package rod_test\n\nimport (\n\t\"testing\"\n)\n\n// This is the template to demonstrate how to test Rod.\nfunc TestRod(t *testing.T) {\n\tg := setup(t)\n\tg.cancelTimeout() // Cancel timeout protection\n\n\t// You can use the pre-launched g.browser or g.page for testing\n\tbrowser, page := g.browser, g.page\n\n\t// You can also use the g.html to serve static html content\n\tpage.MustNavigate(g.html(doc)).MustWaitLoad()\n\n\tg.Eq(browser.MustVersion().ProtocolVersion, \"1.3\")\n\tg.Has(page.MustElement(\"body\").MustText(), \"ok\")\n}\n\nconst doc = `\n<html>\n  <body>ok</body>\n</html>\n`\n"
        },
        {
          "name": "setup_test.go",
          "type": "blob",
          "size": 8.3125,
          "content": "package rod_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/defaults\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n\t\"github.com/ysmood/got\"\n\t\"github.com/ysmood/gotrace\"\n\t\"github.com/ysmood/gson\"\n)\n\nvar TimeoutEach = flag.Duration(\"timeout-each\", time.Minute, \"timeout for each test\")\n\nvar LogDir = slash(fmt.Sprintf(\"tmp/cdp-log/%s\", time.Now().Format(\"2006-01-02_15-04-05\")))\n\nfunc init() {\n\tgot.DefaultFlags(\"timeout=5m\", \"run=/\")\n\n\tutils.E(os.MkdirAll(slash(\"tmp/cdp-log\"), 0o755))\n\n\tlauncher.NewBrowser().MustGet() // preload browser to local\n}\n\nvar testerPool rod.Pool[G]\n\nfunc TestMain(m *testing.M) {\n\ttesterPool = newTesterPool()\n\n\tcode := m.Run()\n\tif code != 0 {\n\t\tos.Exit(code)\n\t}\n\n\ttesterPool.Cleanup(func(g *G) {\n\t\tg.browser.MustClose()\n\t})\n\n\tif err := gotrace.Check(0, gotrace.IgnoreFuncs(\"internal/poll.runtime_pollWait\")); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// G is a tester. Testers are thread-safe, they shouldn't race each other.\ntype G struct {\n\tgot.G\n\n\t// mock client for proxy the cdp requests\n\tmc *MockClient\n\n\t// a random browser instance from the pool. If you have changed state of it, you must reset it\n\t// or it may affect other test cases.\n\tbrowser *rod.Browser\n\n\t// a random page instance from the pool. If you have changed state of it, you must reset it\n\t// or it may affect other test cases.\n\tpage *rod.Page\n\n\t// use it to cancel the TimeoutEach for current test case\n\tcancelTimeout func()\n}\n\n// If we don't use pool to cache, the total time will be much longer.\nfunc newTesterPool() rod.Pool[G] {\n\tparallel := got.Parallel()\n\tif parallel == 0 {\n\t\tparallel = runtime.GOMAXPROCS(0)\n\t}\n\n\tfmt.Println(\"parallel test\", parallel) //nolint: forbidigo\n\n\treturn rod.NewPool[G](parallel)\n}\n\nfunc newTester() *G {\n\tu := launcher.New().Set(\"proxy-bypass-list\", \"<-loopback>\").NoSandbox(true).MustLaunch()\n\n\tmc := newMockClient(u)\n\n\tbrowser := rod.New().Client(mc).MustConnect().MustIgnoreCertErrors(false)\n\n\tpages := browser.MustPages()\n\n\tvar page *rod.Page\n\tif pages.Empty() {\n\t\tpage = browser.MustPage()\n\t} else {\n\t\tpage = pages.First()\n\t}\n\n\treturn &G{\n\t\tmc:      mc,\n\t\tbrowser: browser,\n\t\tpage:    page,\n\t}\n}\n\nfunc setup(t *testing.T) G {\n\tt.Helper()\n\n\tif got.Parallel() != 1 {\n\t\tt.Parallel()\n\t}\n\n\ttester := testerPool.MustGet(newTester)\n\tt.Cleanup(func() { testerPool.Put(tester) })\n\n\ttester.G = got.New(t)\n\ttester.mc.t = t\n\ttester.mc.log.SetOutput(tester.Open(true, filepath.Join(LogDir, tester.mc.id, t.Name()+\".log\")))\n\n\ttester.checkLeaking()\n\n\ttester.page.MustNavigate(\"\")\n\n\treturn *tester\n}\n\nfunc (g G) enableCDPLog() {\n\tg.mc.principal.Logger(rod.DefaultLogger)\n}\n\nfunc (g G) dump(args ...interface{}) {\n\tg.Log(utils.Dump(args...))\n}\n\nfunc (g G) blank() string {\n\treturn g.srcFile(\"./fixtures/blank.html\")\n}\n\nfunc (g G) html(content string) string {\n\treturn g.Serve().Route(\"/\", \"\", content).URL()\n}\n\n// Get abs file path from fixtures folder, such as \"file:///a/b/click.html\".\n// Usually the path can be used for html src attribute like:\n//\n//\t<img src=\"file:///a/b\">\nfunc (g G) srcFile(path string) string {\n\tg.Helper()\n\tf, err := filepath.Abs(slash(path))\n\tg.E(err)\n\treturn \"file://\" + f\n}\n\nfunc (g G) newPage(u ...string) *rod.Page {\n\tg.Helper()\n\tp := g.browser.MustPage(u...)\n\tg.Cleanup(func() {\n\t\tif !g.Failed() {\n\t\t\tp.MustClose()\n\t\t}\n\t})\n\treturn p\n}\n\nfunc (g *G) checkLeaking() {\n\tig := gotrace.CombineIgnores(gotrace.IgnoreCurrent(), gotrace.IgnoreNonChildren())\n\tgotrace.CheckLeak(g.Testable, 0, ig)\n\n\tself := gotrace.Get(false)[0]\n\tg.cancelTimeout = g.DoAfter(*TimeoutEach, func() {\n\t\tt := gotrace.Get(true).Filter(func(t *gotrace.Trace) bool {\n\t\t\tif t.GoroutineID == self.GoroutineID {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn ig(t)\n\t\t}).String()\n\t\tpanic(fmt.Sprintf(`[rod_test.TimeoutEach] %s timeout after %v\nrunning goroutines: %s`, g.Name(), *TimeoutEach, t))\n\t})\n\n\tg.Cleanup(func() {\n\t\tif g.Failed() {\n\t\t\treturn\n\t\t}\n\n\t\t// close all other pages other than g.page\n\t\tres, err := proto.TargetGetTargets{}.Call(g.browser)\n\t\tg.E(err)\n\t\tfor _, info := range res.TargetInfos {\n\t\t\tif info.TargetID != g.page.TargetID {\n\t\t\t\tg.E(proto.TargetCloseTarget{TargetID: info.TargetID}.Call(g.browser))\n\t\t\t}\n\t\t}\n\n\t\tif g.browser.LoadState(g.page.SessionID, &proto.FetchEnable{}) {\n\t\t\tg.Logf(\"leaking FetchEnable\")\n\t\t\tg.FailNow()\n\t\t}\n\n\t\tg.mc.setCall(nil)\n\t})\n}\n\ntype Call func(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error)\n\nvar _ rod.CDPClient = &MockClient{}\n\ntype MockClient struct {\n\tsync.RWMutex\n\tid        string\n\tt         got.Testable\n\tlog       *log.Logger\n\tprincipal *cdp.Client\n\tcall      Call\n\tevent     <-chan *cdp.Event\n}\n\nvar mockClientCount int32\n\nfunc newMockClient(u string) *MockClient {\n\tid := fmt.Sprintf(\"%02d\", atomic.AddInt32(&mockClientCount, 1))\n\n\t// create init log file\n\tutils.E(os.MkdirAll(filepath.Join(LogDir, id), 0o755))\n\tf, err := os.Create(filepath.Join(LogDir, id, \"_.log\"))\n\tlog := log.New(f, \"\", log.Ltime)\n\tutils.E(err)\n\n\tclient := cdp.New().Logger(utils.MultiLogger(defaults.CDP, log)).Start(cdp.MustConnectWS(u))\n\n\treturn &MockClient{id: id, principal: client, log: log}\n}\n\nfunc (mc *MockClient) Event() <-chan *cdp.Event {\n\tif mc.event != nil {\n\t\treturn mc.event\n\t}\n\treturn mc.principal.Event()\n}\n\nfunc (mc *MockClient) Call(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error) {\n\treturn mc.getCall()(ctx, sessionID, method, params)\n}\n\nfunc (mc *MockClient) getCall() Call {\n\tmc.RLock()\n\tdefer mc.RUnlock()\n\n\tif mc.call == nil {\n\t\treturn mc.principal.Call\n\t}\n\treturn mc.call\n}\n\nfunc (mc *MockClient) setCall(fn Call) {\n\tmc.Lock()\n\tdefer mc.Unlock()\n\n\tif mc.call != nil {\n\t\tmc.t.Logf(\"leaking MockClient.stub\")\n\t\tmc.t.Fail()\n\t}\n\tmc.call = fn\n}\n\nfunc (mc *MockClient) resetCall() {\n\tmc.Lock()\n\tdefer mc.Unlock()\n\tmc.call = nil\n}\n\n// Use it to find out which cdp call to intercept. Put a print like log.Println(\"*****\") after the cdp call you want to intercept.\n// The output of the test should has something like:\n//\n//\t[stubCounter] begin\n//\t[stubCounter] 1, proto.DOMResolveNode{}\n//\t[stubCounter] 1, proto.RuntimeCallFunctionOn{}\n//\t[stubCounter] 2, proto.RuntimeCallFunctionOn{}\n//\t01:49:43 *****\n//\n// So the 3rd call is the one we want to intercept, then you can use the output with s.at or s.errorAt.\nfunc (mc *MockClient) stubCounter() {\n\tl := sync.Mutex{}\n\tmCount := map[string]int{}\n\n\tfmt.Fprintln(os.Stdout, \"[stubCounter] begin\")\n\n\tmc.setCall(func(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error) {\n\t\tl.Lock()\n\t\tmCount[method]++\n\t\tm := fmt.Sprintf(\"%d, proto.%s{}\", mCount[method], proto.GetType(method).Name())\n\t\t_, _ = fmt.Fprintln(os.Stdout, \"[stubCounter]\", m)\n\t\tl.Unlock()\n\n\t\treturn mc.principal.Call(ctx, sessionID, method, params)\n\t})\n}\n\ntype StubSend func() (gson.JSON, error)\n\n// When call the cdp.Client.Call the nth time use fn instead.\n// Use p to filter method.\nfunc (mc *MockClient) stub(nth int, p proto.Request, fn func(send StubSend) (gson.JSON, error)) {\n\tif p == nil {\n\t\tmc.t.Logf(\"p must be specified\")\n\t\tmc.t.FailNow()\n\t}\n\n\tcount := int64(0)\n\n\tmc.setCall(func(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error) {\n\t\tif method == p.ProtoReq() {\n\t\t\tif int(atomic.AddInt64(&count, 1)) == nth {\n\t\t\t\tmc.resetCall()\n\t\t\t\tj, err := fn(func() (gson.JSON, error) {\n\t\t\t\t\tb, err := mc.principal.Call(ctx, sessionID, method, params)\n\t\t\t\t\treturn gson.New(b), err\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn j.MarshalJSON()\n\t\t\t}\n\t\t}\n\t\treturn mc.principal.Call(ctx, sessionID, method, params)\n\t})\n}\n\n// When call the cdp.Client.Call the nth time return error.\n// Use p to filter method.\nfunc (mc *MockClient) stubErr(nth int, p proto.Request) {\n\tmc.stub(nth, p, func(_ StubSend) (gson.JSON, error) {\n\t\treturn gson.New(nil), errors.New(\"mock error\")\n\t})\n}\n\ntype MockRoundTripper struct {\n\tres *http.Response\n\terr error\n}\n\nfunc (mrt *MockRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {\n\treturn mrt.res, mrt.err\n}\n\ntype MockReader struct {\n\terr error\n}\n\nfunc (mr *MockReader) Read(_ []byte) (n int, err error) {\n\treturn 0, mr.err\n}\n\nfunc TestLintIgnore(t *testing.T) {\n\tt.Skip()\n\n\t_ = rod.Try(func() {\n\t\ttt := G{}\n\t\ttt.dump()\n\t\ttt.enableCDPLog()\n\n\t\tmc := &MockClient{}\n\t\tmc.stubCounter()\n\t})\n}\n\nvar slash = filepath.FromSlash\n"
        },
        {
          "name": "states.go",
          "type": "blob",
          "size": 3.263671875,
          "content": "package rod\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/go-rod/rod/lib/proto\"\n)\n\ntype stateKey struct {\n\tbrowserContextID proto.BrowserBrowserContextID\n\tsessionID        proto.TargetSessionID\n\tmethodName       string\n}\n\nfunc (b *Browser) key(sessionID proto.TargetSessionID, methodName string) stateKey {\n\treturn stateKey{\n\t\tbrowserContextID: b.BrowserContextID,\n\t\tsessionID:        sessionID,\n\t\tmethodName:       methodName,\n\t}\n}\n\nfunc (b *Browser) set(sessionID proto.TargetSessionID, methodName string, params interface{}) {\n\tb.states.Store(b.key(sessionID, methodName), params)\n\n\tkey := \"\"\n\tswitch methodName {\n\tcase (proto.EmulationClearDeviceMetricsOverride{}).ProtoReq():\n\t\tkey = (proto.EmulationSetDeviceMetricsOverride{}).ProtoReq()\n\tcase (proto.EmulationClearGeolocationOverride{}).ProtoReq():\n\t\tkey = (proto.EmulationSetGeolocationOverride{}).ProtoReq()\n\tdefault:\n\t\tdomain, name := proto.ParseMethodName(methodName)\n\t\tif name == \"disable\" {\n\t\t\tkey = domain + \".enable\"\n\t\t}\n\t}\n\tif key != \"\" {\n\t\tb.states.Delete(b.key(sessionID, key))\n\t}\n}\n\n// LoadState into the method, sessionID can be empty.\nfunc (b *Browser) LoadState(sessionID proto.TargetSessionID, method proto.Request) (has bool) {\n\tdata, has := b.states.Load(b.key(sessionID, method.ProtoReq()))\n\tif has {\n\t\treflect.Indirect(reflect.ValueOf(method)).Set(\n\t\t\treflect.Indirect(reflect.ValueOf(data)),\n\t\t)\n\t}\n\treturn\n}\n\n// RemoveState a state.\nfunc (b *Browser) RemoveState(key interface{}) {\n\tb.states.Delete(key)\n}\n\n// EnableDomain and returns a restore function to restore previous state.\nfunc (b *Browser) EnableDomain(sessionID proto.TargetSessionID, req proto.Request) (restore func()) {\n\t_, enabled := b.states.Load(b.key(sessionID, req.ProtoReq()))\n\n\tif !enabled {\n\t\t_, _ = b.Call(b.ctx, string(sessionID), req.ProtoReq(), req)\n\t}\n\n\treturn func() {\n\t\tif !enabled {\n\t\t\tdomain, _ := proto.ParseMethodName(req.ProtoReq())\n\t\t\t_, _ = b.Call(b.ctx, string(sessionID), domain+\".disable\", nil)\n\t\t}\n\t}\n}\n\n// DisableDomain and returns a restore function to restore previous state.\nfunc (b *Browser) DisableDomain(sessionID proto.TargetSessionID, req proto.Request) (restore func()) {\n\t_, enabled := b.states.Load(b.key(sessionID, req.ProtoReq()))\n\tdomain, _ := proto.ParseMethodName(req.ProtoReq())\n\n\tif enabled {\n\t\t_, _ = b.Call(b.ctx, string(sessionID), domain+\".disable\", nil)\n\t}\n\n\treturn func() {\n\t\tif enabled {\n\t\t\t_, _ = b.Call(b.ctx, string(sessionID), req.ProtoReq(), req)\n\t\t}\n\t}\n}\n\nfunc (b *Browser) cachePage(page *Page) {\n\tb.states.Store(page.TargetID, page)\n}\n\nfunc (b *Browser) loadCachedPage(id proto.TargetTargetID) *Page {\n\tif cache, ok := b.states.Load(id); ok {\n\t\treturn cache.(*Page) //nolint: forcetypeassert\n\t}\n\treturn nil\n}\n\n// LoadState into the method.\nfunc (p *Page) LoadState(method proto.Request) (has bool) {\n\treturn p.browser.LoadState(p.SessionID, method)\n}\n\n// EnableDomain and returns a restore function to restore previous state.\nfunc (p *Page) EnableDomain(method proto.Request) (restore func()) {\n\treturn p.browser.Context(p.ctx).EnableDomain(p.SessionID, method)\n}\n\n// DisableDomain and returns a restore function to restore previous state.\nfunc (p *Page) DisableDomain(method proto.Request) (restore func()) {\n\treturn p.browser.Context(p.ctx).DisableDomain(p.SessionID, method)\n}\n\nfunc (p *Page) cleanupStates() {\n\tp.browser.RemoveState(p.TargetID)\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 5.8017578125,
          "content": "package rod\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod/lib/cdp\"\n\t\"github.com/go-rod/rod/lib/proto\"\n\t\"github.com/go-rod/rod/lib/utils\"\n)\n\n// CDPClient is usually used to make rod side-effect free. Such as proxy all IO of rod.\ntype CDPClient interface {\n\tEvent() <-chan *cdp.Event\n\tCall(ctx context.Context, sessionID, method string, params interface{}) ([]byte, error)\n}\n\n// Message represents a cdp.Event.\ntype Message struct {\n\tSessionID proto.TargetSessionID\n\tMethod    string\n\n\tlock  *sync.Mutex\n\tdata  json.RawMessage\n\tevent reflect.Value\n}\n\n// Load data into e, returns true if e matches the event type.\nfunc (msg *Message) Load(e proto.Event) bool {\n\tif msg.Method != e.ProtoEvent() {\n\t\treturn false\n\t}\n\n\teVal := reflect.ValueOf(e)\n\tif eVal.Kind() != reflect.Ptr {\n\t\treturn true\n\t}\n\teVal = reflect.Indirect(eVal)\n\n\tmsg.lock.Lock()\n\tdefer msg.lock.Unlock()\n\tif msg.data == nil {\n\t\teVal.Set(msg.event)\n\t\treturn true\n\t}\n\n\tutils.E(json.Unmarshal(msg.data, e))\n\tmsg.event = eVal\n\tmsg.data = nil\n\treturn true\n}\n\n// DefaultLogger for rod.\nvar DefaultLogger = log.New(os.Stdout, \"[rod] \", log.LstdFlags)\n\n// DefaultSleeper generates the default sleeper for retry, it uses backoff to grow the interval.\n// The growth looks like:\n//\n//\tA(0) = 100ms, A(n) = A(n-1) * random[1.9, 2.1), A(n) < 1s\n//\n// Why the default is not RequestAnimationFrame or DOM change events is because of if a retry never\n// ends it can easily flood the program. But you can always easily config it into what you want.\nvar DefaultSleeper = func() utils.Sleeper {\n\treturn utils.BackoffSleeper(100*time.Millisecond, time.Second, nil)\n}\n\n// NewPagePool instance.\nfunc NewPagePool(limit int) Pool[Page] {\n\treturn NewPool[Page](limit)\n}\n\n// NewBrowserPool instance.\nfunc NewBrowserPool(limit int) Pool[Browser] {\n\treturn NewPool[Browser](limit)\n}\n\n// Pool is used to thread-safely limit the number of elements at the same time.\n// It's a common practice to use a channel to limit concurrency, it's not special for rod.\n// This helper is more like an example to use Go Channel.\n// Reference: https://golang.org/doc/effective_go#channels\ntype Pool[T any] chan *T\n\n// NewPool instance.\nfunc NewPool[T any](limit int) Pool[T] {\n\tp := make(chan *T, limit)\n\tfor i := 0; i < limit; i++ {\n\t\tp <- nil\n\t}\n\treturn p\n}\n\n// Get a elem from the pool, allow error. Use the [Pool[T].Put] to make it reusable later.\nfunc (p Pool[T]) Get(create func() (*T, error)) (elem *T, err error) {\n\telem = <-p\n\tif elem == nil {\n\t\telem, err = create()\n\t}\n\treturn\n}\n\n// Put an elem back to the pool.\nfunc (p Pool[T]) Put(elem *T) {\n\tp <- elem\n}\n\n// Cleanup helper.\nfunc (p Pool[T]) Cleanup(iteratee func(*T)) {\n\tfor i := 0; i < cap(p); i++ {\n\t\tselect {\n\t\tcase elem := <-p:\n\t\t\tif elem != nil {\n\t\t\t\titeratee(elem)\n\t\t\t}\n\t\tdefault:\n\t\t}\n\t}\n}\n\nvar _ io.ReadCloser = &StreamReader{}\n\n// StreamReader for browser data stream.\ntype StreamReader struct {\n\tOffset *int\n\n\tc      proto.Client\n\thandle proto.IOStreamHandle\n\tbuf    *bytes.Buffer\n}\n\n// NewStreamReader instance.\nfunc NewStreamReader(c proto.Client, h proto.IOStreamHandle) *StreamReader {\n\treturn &StreamReader{\n\t\tc:      c,\n\t\thandle: h,\n\t\tbuf:    &bytes.Buffer{},\n\t}\n}\n\nfunc (sr *StreamReader) Read(p []byte) (n int, err error) {\n\tres, err := proto.IORead{\n\t\tHandle: sr.handle,\n\t\tOffset: sr.Offset,\n\t}.Call(sr.c)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif !res.EOF {\n\t\tvar bin []byte\n\t\tif res.Base64Encoded {\n\t\t\tbin, err = base64.StdEncoding.DecodeString(res.Data)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t} else {\n\t\t\tbin = []byte(res.Data)\n\t\t}\n\n\t\t_, _ = sr.buf.Write(bin)\n\t}\n\n\treturn sr.buf.Read(p)\n}\n\n// Close the stream, discard any temporary backing storage.\nfunc (sr *StreamReader) Close() error {\n\treturn proto.IOClose{Handle: sr.handle}.Call(sr.c)\n}\n\n// Try try fn with recover, return the panic as rod.ErrTry.\nfunc Try(fn func()) (err error) {\n\tdefer func() {\n\t\tif val := recover(); val != nil {\n\t\t\terr = &TryError{val, string(debug.Stack())}\n\t\t}\n\t}()\n\n\tfn()\n\n\treturn err\n}\n\nfunc genRegMatcher(includes, excludes []string) func(string) bool {\n\tregIncludes := make([]*regexp.Regexp, len(includes))\n\tfor i, p := range includes {\n\t\tregIncludes[i] = regexp.MustCompile(p)\n\t}\n\n\tregExcludes := make([]*regexp.Regexp, len(excludes))\n\tfor i, p := range excludes {\n\t\tregExcludes[i] = regexp.MustCompile(p)\n\t}\n\n\treturn func(s string) bool {\n\t\tfor _, include := range regIncludes {\n\t\t\tif include.MatchString(s) {\n\t\t\t\tfor _, exclude := range regExcludes {\n\t\t\t\t\tif exclude.MatchString(s) {\n\t\t\t\t\t\tgoto end\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tend:\n\t\treturn false\n\t}\n}\n\ntype saveFileType int\n\nconst (\n\tsaveFileTypeScreenshot saveFileType = iota\n\tsaveFileTypePDF\n)\n\nfunc saveFile(fileType saveFileType, bin []byte, toFile []string) error {\n\tif len(toFile) == 0 {\n\t\treturn nil\n\t}\n\tif toFile[0] == \"\" {\n\t\tstamp := fmt.Sprintf(\"%d\", time.Now().UnixNano())\n\t\tswitch fileType {\n\t\tcase saveFileTypeScreenshot:\n\t\t\ttoFile = []string{\"tmp\", \"screenshots\", stamp + \".png\"}\n\t\tcase saveFileTypePDF:\n\t\t\ttoFile = []string{\"tmp\", \"pdf\", stamp + \".pdf\"}\n\t\t}\n\t}\n\treturn utils.OutputFile(filepath.Join(toFile...), bin)\n}\n\nfunc httHTML(w http.ResponseWriter, body string) {\n\tw.Header().Add(\"Content-Type\", \"text/html; charset=utf-8\")\n\t_, _ = w.Write([]byte(body))\n}\n\nfunc mustToJSONForDev(value interface{}) string {\n\tbuf := new(bytes.Buffer)\n\tenc := json.NewEncoder(buf)\n\tenc.SetEscapeHTML(false)\n\n\tutils.E(enc.Encode(value))\n\n\treturn buf.String()\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nvar regDataURI = regexp.MustCompile(`\\Adata:(.+?)?(;base64)?,`)\n\nfunc parseDataURI(uri string) (string, []byte) {\n\tmatches := regDataURI.FindStringSubmatch(uri)\n\tl := len(matches[0])\n\tcontentType := matches[1]\n\n\tbin, _ := base64.StdEncoding.DecodeString(uri[l:])\n\treturn contentType, bin\n}\n"
        }
      ]
    }
  ]
}