{
  "metadata": {
    "timestamp": 1736567794100,
    "page": 379,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fullstorydev/grpcui",
      "stars": 5323,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": "dist/\nVERSION\n.idea/\n*.iml\n.tmp/\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.76171875,
          "content": "builds:\n  - binary: grpcui\n    main: ./cmd/grpcui\n    goos:\n      - linux\n      - darwin\n      - windows\n    goarch:\n      - amd64\n      - 386\n      - arm64\n    ignore:\n      - goos: darwin\n        goarch: 386\n      - goos: windows\n        goarch: arm64\n    ldflags:\n      - -s -w -X main.version=v{{.Version}}\n\narchives:\n  - format: tar.gz\n    format_overrides:\n      - goos: windows\n        format: zip\n    name_template: >-\n      {{ .Binary }}_{{ .Version }}_\n      {{- if eq .Os \"darwin\" }}osx{{ else }}{{ .Os }}{{ end }}_\n      {{- if eq .Arch \"amd64\" }}x86_64{{ else if eq .Arch \"386\" }}x86_32{{ else }}{{ .Arch }}{{ end }}\n      {{- with .Arm }}v{{ . }}{{ end }}{{ with .Mips }}_{{ . }}{{ end }}{{ if not (eq .Amd64 \"v1\") }}{{ .Amd64 }}{{ end }}\n    files:\n      - LICENSE\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.01171875,
          "content": "FROM golang:1.23-alpine as builder\nMAINTAINER Fullstory Engineering\n\n# create non-privileged group and user\nRUN addgroup -S grpcui && adduser -S grpcui -G grpcui\n\nWORKDIR /tmp/fullstorydev/grpcui\n# copy just the files/sources we need to build grpcui\nCOPY VERSION *.go go.* /tmp/fullstorydev/grpcui/\nCOPY cmd /tmp/fullstorydev/grpcui/cmd\nCOPY internal /tmp/fullstorydev/grpcui/internal\nCOPY standalone /tmp/fullstorydev/grpcui/standalone\n# and build a completely static binary (so we can use\n# scratch as basis for the final image)\nENV CGO_ENABLED=0\nENV GO111MODULE=on\nRUN go build -o /grpcui \\\n    -ldflags \"-w -extldflags \\\"-static\\\" -X \\\"main.version=$(cat VERSION)\\\"\" \\\n    ./cmd/grpcui\n\n# New FROM so we have a nice'n'tiny image\nFROM scratch\nWORKDIR /\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt\nCOPY --from=builder /etc/passwd /etc/passwd\nCOPY --from=builder /grpcui /bin/grpcui\nUSER grpcui\nEXPOSE 8080\n\nENTRYPOINT [\"/bin/grpcui\", \"-bind=0.0.0.0\", \"-port=8080\", \"-open-browser=false\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Fullstory, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.6455078125,
          "content": "dev_build_version=$(shell git describe --tags --always --dirty)\n\nexport PATH := $(shell pwd)/.tmp/protoc/bin:$(PATH)\nexport PROTOC_VERSION := 22.0\n# Disable CGO for improved compatibility across distros\nexport CGO_ENABLED=0\n\n# TODO: run golint and errcheck, but only to catch *new* violations and\n# decide whether to change code or not (e.g. we need to be able to whitelist\n# violations already in the code). They can be useful to catch errors, but\n# they are just too noisy to be a requirement for a CI -- we don't even *want*\n# to fix some of the things they consider to be violations.\n.PHONY: ci\nci: deps checkgofmt checkgenerate vet staticcheck ineffassign predeclared test\n\n.PHONY: deps\ndeps:\n\tgo get -v -t ./...\n\tgo mod tidy\n\n.PHONY: updatedeps\nupdatedeps:\n\tgo get -d -v -t -u -f ./...\n\tgo mod tidy\n\n.PHONY: install\ninstall:\n\tgo install -ldflags '-X \"main.version=dev build $(dev_build_version)\"' ./...\n\n.PHONY: release\nrelease:\n\t@go install github.com/goreleaser/goreleaser@v1.21.0\n\tgoreleaser release --clean\n\n.PHONY: docker\ndocker:\n\t@echo $(dev_build_version) > VERSION\n\tdocker build -t fullstorydev/grpcui:$(dev_build_version) .\n\t@rm VERSION\n\n.PHONY: generate\ngenerate: .tmp/protoc/bin/protoc\n\t@go install google.golang.org/protobuf/cmd/protoc-gen-go@a709e31e5d12\n\t@go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1.0\n\t@go install github.com/jhump/protoreflect/desc/sourceinfo/cmd/protoc-gen-gosrcinfo@v1.14.1\n\tgo generate ./...\n\tgo mod tidy\n\n.PHONY: checkgenerate\ncheckgenerate: generate\n\tgit status --porcelain\n\t@if [ -n \"$$(git status --porcelain)\" ]; then \\\n\t\tgit diff; \\\n\t\texit 1; \\\n\tfi\n\n.PHONY: checkgofmt\ncheckgofmt:\n\tgofmt -s -l .\n\t@if [ -n \"$$(gofmt -s -l .)\" ]; then \\\n\t\tgit diff; \\\n\t\texit 1; \\\n\tfi\n\n.PHONY: vet\nvet:\n\tgo vet ./...\n\n.PHONY: staticcheck\nstaticcheck:\n\t@go install honnef.co/go/tools/cmd/staticcheck@v0.5.1\n\tstaticcheck ./...\n\n.PHONY: ineffassign\nineffassign:\n\t@go install github.com/gordonklaus/ineffassign@7953dde2c7bf\n\tineffassign .\n\n.PHONY: predeclared\npredeclared:\n\t@go install github.com/nishanths/predeclared@245576f9a85c96ea16c750df3887f1d827f01e9c\n\tpredeclared ./...\n\n# Intentionally omitted from CI, but target here for ad-hoc reports.\n.PHONY: golint\ngolint:\n\t@go install golang.org/x/lint/golint@v0.0.0-20210508222113-6edffad5e616\n\tgolint -min_confidence 0.9 -set_exit_status ./...\n\n# Intentionally omitted from CI, but target here for ad-hoc reports.\n.PHONY: errcheck\nerrcheck:\n\t@go install github.com/kisielk/errcheck@v1.2.0\n\terrcheck ./...\n\n.PHONY: test\ntest:\n\t# The race detector requires CGO: https://github.com/golang/go/issues/6508\n\tCGO_ENABLED=1 go test -race ./...\n\n.tmp/protoc/bin/protoc: ./Makefile ./download_protoc.sh\n\t./download_protoc.sh\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.1796875,
          "content": "# gRPC UI\n[![Build Status](https://circleci.com/gh/fullstorydev/grpcui/tree/master.svg?style=svg)](https://circleci.com/gh/fullstorydev/grpcui/tree/master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/fullstorydev/grpcui)](https://goreportcard.com/report/github.com/fullstorydev/grpcui)\n\n`grpcui` is a command-line tool that lets you interact with gRPC servers via a browser.\nIt's sort of like [Postman](https://www.getpostman.com/), but for gRPC APIs instead of\nREST.\n\nIn some ways, this is like an extension to [grpcurl](https://github.com/fullstorydev/grpcurl).\nWhereas `grpcurl` is a command-line interface, `grpcui` provides a web/browser-based\nGUI. This lets you interactively construct requests to send to a gRPC server.\n\nWith this tool you can also browse the schema for gRPC services, which is presented as a\nlist of available endpoints. This is enabled either by querying a server that supports\n[server reflection](https://github.com/grpc/grpc/blob/master/src/proto/grpc/reflection/v1/reflection.proto),\nby reading proto source files, or by loading in compiled \"protoset\" files (files that contain\nencoded file [descriptor protos](https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto)).\nIn fact, the way the tool transforms JSON request data into a binary encoded protobuf\nis using that very same schema. So, if the server you interact with does not support\nreflection, you will either need the proto source files that define the service or need\nprotoset files that `grpcui` can use.\n\nThis repo also provides two library packages\n1. `github.com/fullstorydev/grpcui`: This package contains the building blocks for embedding a\n   gRPC web form into any Go HTTP server. It has functions for accessing the HTML form, the\n   JavaScript code that powers it, as well as a sample CSS file, for styling the form.\n2. `github.com/fullstorydev/grpcui/standalone`: This package goes a step further and supplies\n   a single, simple HTTP handler that provides the entire gRPC web UI. You can just wire this\n   handler into your HTTP server to embed a gRPC web page that looks exactly like the one you\n   see when you use the `grpcui` command-line program. This single handler uses the above\n   package but also supplies the enclosing HTML page, some other script dependencies (jQuery\n   and jQuery-UI), and additional CSS and image resources.\n\n## Features\n`grpcui` supports all kinds of RPC methods, including streaming methods. However, it requires\nyou to construct the entire stream of request messages all at once and then renders the entire\nresulting stream of response messages all at once (so you can't interact with bidirectional\nstreams the way that `grpcurl` can).\n\n`grpcui` supports both plain-text and TLS servers and has numerous options for TLS\nconfiguration. It also supports mutual TLS, where the client is required to present a\nclient certificate.\n\nAs mentioned above, `grpcui` works seamlessly if the server supports the reflection\nservice. If not, you can supply the `.proto` source files or you can supply protoset\nfiles (containing compiled descriptors, produced by `protoc`) to `grpcui`.\n\nThe web UI allows you to set request metadata in addition to defining the request message data.\nWhen defining request message data, it uses a dynamic HTML form that supports data entry for\nall possible kinds of protobuf messages, including rich support for well-known types (such as\n`google.protobuf.Timestamp`), one ofs, and maps.\n\nIn addition to entering the data via HTML form, you can also enter the data in JSON format,\nby typing or pasting the entire JSON request body into a text form.\n\nUpon issuing an RPC, the web UI shows all gRPC response metadata, including both headers and\ntrailers sent by the server. And, of course, it shows a human-comprehensible response body, in\nthe form of an HTML table.\n\n## Installation\n\n### Homebrew (MacOS or Linux)\nInstall with `homebrew`:\n```shell\nbrew install grpcui\n```\n\n### From Source\nYou can use the `go` tool to install `grpcui`:\n```shell\ngo install github.com/fullstorydev/grpcui/cmd/grpcui@latest\n```\n\nThis installs the command into the `bin` sub-folder of wherever your `$GOPATH`\nenvironment variable points. If this directory is already in your `$PATH`, then\nyou should be good to go.\n\nIf you have already pulled down this repo to a location that is not in your\n`$GOPATH` and want to build from the sources, you can `cd` into the repo and then\nrun `make install`.\n\nIf you encounter compile errors, you could have out-dated versions of `grpcui`'s\ndependencies. You can update the dependencies by running `make updatedeps`.\n\n### Running without install\n\n```\ngo run ./cmd/grpcui/grpcui.go -plaintext localhost:9019\n```\n\n## Usage\nThe usage doc for the tool explains the numerous options:\n```shell\ngrpcui -help\n```\n\nMost of the flags control how the program connects to the gRPC server that to which\nrequests will be sent. However, there is one flag that controls `grpcui` itself: the\n`-port` flag controls what port the HTTP server should use to expose the web UI. If\nno port is specified, an ephemeral port will be used (so likely a different port each\ntime it is run, allocated by the operating system).\n\n### Web Form\nWhen you run `grpcui`, it will show you a URL to put into a browser in order to access\nthe web UI.\n\n```\n$ grpcui -plaintext localhost:12345\ngRPC Web UI available at http://127.0.0.1:60551/...\n\n```\n\nWhen you navigate to this URL, you are presented with the user interface:\n\n<p align=\"center\">\n  <img alt=\"web UI screenshots\" width=\"888\" src=\"doc-images/grpc-web-ui.png\">\n</p>\n\nThe top two listboxes allow you to select the service and method of the RPC to issue.\nOnce a selection is made, the panel below will show a form that allows you to define an\nRPC request. The form is constructed, dynamically, based on the actual request message\nstructure of the selected RPC.\n\nYou'll notice a second tab that lets you view (and edit) the raw JSON value for the\nrequest data. This can be useful to copy+paste a large request message, without having\nto point-and-click to define each field value, one at a time.\n\nThe third tab shows the response data. This tab is grayed out and disabled until you\nactually click the \"Invoke\" button, which can be found at the bottom of the page.\n\n### Request Form\nThe first thing to note about the form is that it will generally be a table, where each row\nis a field. The table has three important columns:\n\n1. The first column shows the name and type of the field.\n2. The second columns indicates the \"cardinality\" of the field. Typical fields are\n   optional. The second column for optional fields is a checkbox indicating whether the\n   field is present or not. If the field is not present, its default value is assumed.\n   Repeated fields show buttons in this column for adding and deletig values. The green\n   \"+\" allows you to add values to the repeated field. The red \"x\" next to a value will\n   remove that value. Finally, if the field is required (only supported in syntax\n   \"proto2\"), the column will contain only an asterisk.\n3. The third column shows the value of the field. If the field is absent, this will show\n   the default value for the field. Fields that are nested messages show \"unset\", but\n   scalar types show their default (usually the type's zero value, but default values are\n   configurable when using syntax \"proto2\"). Absent fields are also not editable -- you\n   must first check the box in column two to make the field present before editing its\n   value. Repeated fields show a nested table that occupies columns two and three and\n   allows for adding and removing values.\n\nFields whose type is a nested message will include a nested table in column three. This\nnested table has its own three columns and one row per field therein.\n\nOne-ofs are rendered a little differently. Instead of two columns indicating the presence\nand value of the field, they include a nested table showing all of the possible fields\nin the one-of. However, the middle column is a radio button instead of a checkbox, so that\nonly one of the fields can be present at any given time. In addition to a row for each\nfield in the one-of, there is also an option named *None*, which indicates a one-of where\nno value is set.\n\nHere's an example form for a message that has two required fields (`id` and `name`), one\nrepeated field (`labels`), a handful of normal optional fields, and a single one-of that\nhas four options. In the first image, no values are present (except, of course, for the\nrequired fields at the top). In the second, several field values are present.\n\n<p align=\"center\">\n  <img alt=\"web UI message fields\" width=\"408\" align=\"top\" src=\"doc-images/fields.png\">\n  <img alt=\"web UI message fields, with some values\" width=\"420\" align=\"top\" src=\"doc-images/fields-filled-out.png\">\n</p>\n\nFor RPCs that accept a *stream* of requests, the web form allows the user to define multiple\nmessages in the stream. It defaults to a single request, but the user can remove it to send none\nor can send many. A stream resembles a repeated field, but the repeated \"thing\" is the entire\nrequest:\n\n<p align=\"center\">\n  <img alt=\"web UI request stream\" width=\"380\" src=\"doc-images/streams-repeated.png\">\n</p>\n\nThat last example also shows how well-known message types get special treatment. In that example,\nthe request type is `google.protobuf.StringValue`. Instead of showing a form for a message with a\nsingle field named `value` with type `string`, the UI is simple and the \"boxing\" ceremony is\nelided. It instead just shows a simple textbox for entering the string value.\n\nA more interesting example of how well-known message types are treated is `google.protobuf.Timestamp`,\nwhere a date picker is shown:\n\n<p align=\"center\">\n  <img alt=\"web UI request stream\" width=\"640\" src=\"doc-images/timestamp.png\">\n</p>\n\n### Raw Request JSON\nThe second tab lets you view the JSON representation of the request data you have defined on the\nfirst tab. You can also directly edit the JSON data -- including pasting in an entire JSON message.\n\nThe JSON representation uses the standard [JSON mapping for Protocol Buffers](https://developers.google.com/protocol-buffers/docs/proto3#json).\n\n<p align=\"center\">\n  <img alt=\"web UI request JSON\" width=\"600\" src=\"doc-images/raw-json.png\">\n</p>\n\nWhen working with an RPC that has a streaming request, the JSON data will be a JSON array, where\neach element is a single message in the stream.\n\n### Responses\nWhen the \"Invoke\" button is pressed, the request data is sent to the server and the selected RPC\nmethod is invoked. The web form will then navigate to the third tab to show the server's response.\n\nThe response tab has three sections:\n\n1. Response Headers: Any response header metadata is shown here.\n2. Response Data: Any response messages are shown here as are any error messages. RPC methods with\n   a streaming response may show both message data *and* an error. Error messages show the gRPC\n   status code and the server-defined message text.\n3. Response Trailers: Finally, any response trailer metadata is shown.\n\n<p align=\"center\">\n  <img alt=\"web UI response\" width=\"500\" src=\"doc-images/response.png\">\n</p>\n\nEach of these three sections is a table of data. Response messages are the most interesting, and\ntheir structure closely resembles how messages are structured on the \"Request Form\" tab. Fields that\nhave nested messages will include a nested table.\n\n## Descriptor Sources\nThe `grpcui` tool can operate on a variety of sources for descriptors. The descriptors\nare required, in order for `grpcui` to understand the RPC schema, translate inputs\ninto the protobuf binary format as well as translate responses from the binary format\ninto text. The sections below document the supported sources and what command-line flags\nare needed to use them.\n\n### Server Reflection\nWithout any additional command-line flags, `grpcui` will try to use [server reflection](https://github.com/grpc/grpc/blob/master/src/proto/grpc/reflection/v1/reflection.proto).\n\nExamples for how to set up server reflection can be found [here](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md#known-implementations).\n\n### Proto Source Files\nTo use `grpcui` on servers that do not support reflection, you can use `.proto` source\nfiles.\n\nIn addition to using `-proto` flags to point `grpcui` at the relevant proto source file(s),\nyou may also need to supply `-import-path` flags to tell `grpcui` the folders from which\ndependencies can be imported.\n\nJust like when compiling with `protoc`, you do *not* need to provide an import path for the\nlocation of the standard protos included with `protoc` (which contain various \"well-known\ntypes\" with a package definition of `google.protobuf`). These files are \"known\" by `grpcui`\nas a snapshot of their descriptors is built into the `grpcui` binary.\n\n### Protoset Files\nYou can also use compiled protoset files with `grpcui`. Protoset files contain binary\nencoded `google.protobuf.FileDescriptorSet` protos. To create a protoset file, invoke\n`protoc` with the `*.proto` files that define the service:\n\n```shell\nprotoc --proto_path=. \\\n    --descriptor_set_out=myservice.protoset \\\n    --include_imports \\\n    my/custom/server/service.proto\n```\n\nThe `--descriptor_set_out` argument is what tells `protoc` to produce a protoset,\nand the `--include_imports` argument is necessary for the protoset to contain\neverything that `grpcui` needs to process and understand the schema.\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc-images",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.6796875,
          "content": "// Package grpcui provides a gRPC web UI in the form of HTTP handlers that can\n// be added to a web server.\n//\n// This package provides multiple functions which, all combined, provide a fully\n// functional web UI. Users of this package can use these pieces to embed a UI\n// into any existing web application. The web form sources can be embedded in an\n// existing HTML page, and the HTTP handlers wired up to make the form fully\n// functional.\n//\n// For users that don't need as much control over layout and style of the web\n// page, instead consider using standalone.Handler, which is an all-in-one\n// handler that includes its own HTML and CSS as well as all other dependencies.\npackage grpcui\n"
        },
        {
          "name": "download_protoc.sh",
          "type": "blob",
          "size": 1.0849609375,
          "content": "#!/usr/bin/env bash\n\nset -e\n\ncd $(dirname $0)\n\nif [[ -z \"$PROTOC_VERSION\" ]]; then\n  echo \"Set PROTOC_VERSION env var to indicate the version to download\" >&2\n  exit 1\nfi\nPROTOC_OS=\"$(uname -s)\"\nPROTOC_ARCH=\"$(uname -m)\"\ncase \"${PROTOC_OS}\" in\n  Darwin) PROTOC_OS=\"osx\" ;;\n  Linux) PROTOC_OS=\"linux\" ;;\n  *)\n    echo \"Invalid value for uname -s: ${PROTOC_OS}\" >&2\n    exit 1\nesac\n\n# This is for macs with M1 chips. Precompiled binaries for osx/amd64 are not available for download, so for that case\n# we download the x86_64 version instead. This will work as long as rosetta2 is installed.\nif [ \"$PROTOC_OS\" = \"osx\" ] && [ \"$PROTOC_ARCH\" = \"arm64\" ]; then\n  PROTOC_ARCH=\"x86_64\"\nfi\n\nPROTOC=\"${PWD}/.tmp/protoc/bin/protoc\"\n\nif [[ \"$(${PROTOC} --version 2>/dev/null)\" != \"libprotoc 3.${PROTOC_VERSION}\" ]]; then\n  rm -rf ./.tmp/protoc\n  mkdir -p .tmp/protoc\n  curl -L \"https://github.com/google/protobuf/releases/download/v${PROTOC_VERSION}/protoc-${PROTOC_VERSION}-${PROTOC_OS}-${PROTOC_ARCH}.zip\" > .tmp/protoc/protoc.zip\n  pushd ./.tmp/protoc && unzip protoc.zip && popd\n  touch -c ./.tmp/protoc/bin/protoc\nfi\n"
        },
        {
          "name": "files.go",
          "type": "blob",
          "size": 1.5048828125,
          "content": "package grpcui\n\nimport (\n\t\"github.com/jhump/protoreflect/desc\"\n\t\"github.com/jhump/protoreflect/grpcreflect\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\n\t\"github.com/fullstorydev/grpcurl\"\n)\n\n// AllFilesViaReflection returns a slice that contains the file descriptors\n// for all methods exposed by the server on the other end of the given\n// connection. This returns an error if the server does not support service\n// reflection. (See \"google.golang.org/grpc/reflection\" for more on service\n// reflection.)\nfunc AllFilesViaReflection(ctx context.Context, cc grpc.ClientConnInterface) ([]*desc.FileDescriptor, error) {\n\tcli := grpcreflect.NewClientAuto(ctx, cc)\n\tsource := grpcurl.DescriptorSourceFromServer(ctx, cli)\n\treturn grpcurl.GetAllFiles(source)\n}\n\n// AllFilesViaInProcess returns a slice that contains all file descriptors\n// known to this server process. This collects descriptors for all files\n// registered with protoregistry.GlobalFiles, which includes all compiled\n// proto files linked into the current program.\nfunc AllFilesViaInProcess() ([]*desc.FileDescriptor, error) {\n\tvar fds []*desc.FileDescriptor\n\tvar err error\n\tprotoregistry.GlobalFiles.RangeFiles(func(d protoreflect.FileDescriptor) bool {\n\t\tvar fd *desc.FileDescriptor\n\t\tfd, err = desc.LoadFileDescriptor(d.Path())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tfds = append(fds, fd)\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fds, nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.3466796875,
          "content": "module github.com/fullstorydev/grpcui\n\ngo 1.21\n\ntoolchain go1.21.3\n\nrequire (\n\tgithub.com/fullstorydev/grpcurl v1.9.2\n\tgithub.com/golang/protobuf v1.5.4\n\tgithub.com/jhump/protoreflect v1.16.0\n\tgithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4\n\tgolang.org/x/net v0.31.0\n\tgolang.org/x/term v0.26.0\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20231106174013-bbf56f31fb17\n\tgoogle.golang.org/grpc v1.61.0\n\tgoogle.golang.org/protobuf v1.34.2\n)\n\nrequire (\n\tcloud.google.com/go/compute v1.23.3 // indirect\n\tcloud.google.com/go/compute/metadata v0.2.3 // indirect\n\tgithub.com/bufbuild/protocompile v0.10.0 // indirect\n\tgithub.com/census-instrumentation/opencensus-proto v0.4.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.2.0 // indirect\n\tgithub.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe // indirect\n\tgithub.com/cncf/xds/go v0.0.0-20231109132714-523115ebc101 // indirect\n\tgithub.com/envoyproxy/go-control-plane v0.11.1 // indirect\n\tgithub.com/envoyproxy/protoc-gen-validate v1.0.2 // indirect\n\tgolang.org/x/oauth2 v0.14.0 // indirect\n\tgolang.org/x/sync v0.9.0 // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n\tgolang.org/x/text v0.20.0 // indirect\n\tgoogle.golang.org/appengine v1.6.8 // indirect\n\tgoogle.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17 // indirect\n\tgoogle.golang.org/genproto/googleapis/api v0.0.0-20231106174013-bbf56f31fb17 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 12.3193359375,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go/compute v1.23.3 h1:6sVlXXBmbd7jNX0Ipq0trII3e4n1/MsADLK6a+aiVlk=\ncloud.google.com/go/compute v1.23.3/go.mod h1:VCgBUoMnIVIR0CscqQiPJLAG25E3ZRZMzcFZeQ+h8CI=\ncloud.google.com/go/compute/metadata v0.2.3 h1:mg4jlk7mCAj6xXp9UJ4fjI9VUI5rubuGBW5aJ7UnBMY=\ncloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/bufbuild/protocompile v0.10.0 h1:+jW/wnLMLxaCEG8AX9lD0bQ5v9h1RUiMKOBOT5ll9dM=\ngithub.com/bufbuild/protocompile v0.10.0/go.mod h1:G9qQIQo0xZ6Uyj6CMNz0saGmx2so+KONo8/KrELABiY=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1 h1:iKLQ0xPNFxR/2hzXZMrBo8f1j86j5WHzznCCQxV/b8g=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=\ngithub.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe h1:QQ3GSy+MqSHxm/d8nCtnAiZdYFd45cYZPs8vOOIYKfk=\ngithub.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=\ngithub.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20231109132714-523115ebc101 h1:7To3pQ+pZo0i3dsWEbinPNFs5gPSBOsJtx3wTT94VBY=\ngithub.com/cncf/xds/go v0.0.0-20231109132714-523115ebc101/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.11.1 h1:wSUXTlLfiAQRWs2F+p+EKOY9rUyis1MyGqJ2DIk5HpM=\ngithub.com/envoyproxy/go-control-plane v0.11.1/go.mod h1:uhMcXKCQMEJHiAb0w+YGefQLaTEw+YhGluxZkrTmD0g=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/envoyproxy/protoc-gen-validate v1.0.2 h1:QkIBuU5k+x7/QXPvPPnWXWlCdaBFApVqftFV6k087DA=\ngithub.com/envoyproxy/protoc-gen-validate v1.0.2/go.mod h1:GpiZQP3dDbg4JouG/NNS7QWXpgx6x8QiMKdmN72jogE=\ngithub.com/fullstorydev/grpcurl v1.9.2 h1:ObqVQTZW7aFnhuqQoppUrvep2duMBanB0UYK2Mm8euo=\ngithub.com/fullstorydev/grpcurl v1.9.2/go.mod h1:jLfcF55HAz6TYIJY9xFFWgsl0D7o2HlxA5Z4lUG0Tdo=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/uuid v1.4.0 h1:MtMxsa51/r9yyhkyLsVeVt0B+BGQZzpQiTQ4eHZ8bc4=\ngithub.com/google/uuid v1.4.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/jhump/protoreflect v1.16.0 h1:54fZg+49widqXYQ0b+usAFHbMkBGR4PpXrsHc8+TBDg=\ngithub.com/jhump/protoreflect v1.16.0/go.mod h1:oYPd7nPvcBw/5wlDfm/AVmU9zH9BgqGCI469pGxfj/8=\ngithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4 h1:49lOXmGaUpV9Fz3gd7TFZY106KVlPVa5jcYD1gaQf98=\ngithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4/go.mod h1:4OwLy04Bl9Ef3GJJCoec+30X3LQs/0/m4HFRt/2LUSA=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.14.0 h1:P0Vrf/2538nmC0H+pEQ3MNFRRnVR7RlqyVw+bvm26z0=\ngolang.org/x/oauth2 v0.14.0/go.mod h1:lAtNWgaWfL4cm7j2OV8TxGi9Qb7ECORx8DktCY74OwM=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.26.0 h1:WEQa6V3Gja/BhNxg540hBip/kkaYtRg3cxg4oXSw4AU=\ngolang.org/x/term v0.26.0/go.mod h1:Si5m1o57C5nBNQo5z1iq+XDijt21BDBDp2bK0QI8e3E=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.8 h1:IhEN5q69dyKagZPYMSdIjS2HqprW324FRQZJcGqPAsM=\ngoogle.golang.org/appengine v1.6.8/go.mod h1:1jJ3jBArFh5pcgW8gCtRJnepW8FzD1V44FJffLiz/Ds=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17 h1:wpZ8pe2x1Q3f2KyT5f8oP/fa9rHAKgFPr/HZdNuS+PQ=\ngoogle.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17/go.mod h1:J7XzRzVy1+IPwWHZUzoD0IccYZIrXILAQpc+Qy9CMhY=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20231106174013-bbf56f31fb17 h1:JpwMPBpFN3uKhdaekDpiNlImDdkUAyiJ6ez/uxGaUSo=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20231106174013-bbf56f31fb17/go.mod h1:0xJLfVdJqpAPl8tDg1ujOCGzx6LFLttXT5NhllGOXY4=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20231106174013-bbf56f31fb17 h1:Jyp0Hsi0bmHXG6k9eATXoYtjd6e2UzZ1SCn/wIupY14=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20231106174013-bbf56f31fb17/go.mod h1:oQ5rr10WTTMvP4A36n8JpR1OrO1BEiV4f78CneXZxkA=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.61.0 h1:TOvOcuXn30kRao+gfcvsebNEa5iZIiLkisYEkf7R7o0=\ngoogle.golang.org/grpc v1.61.0/go.mod h1:VUbo7IFqmF1QtCAstipjG0GIoq49KvMe9+h1jFLBNJs=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "handlers.go",
          "type": "blob",
          "size": 19.1181640625,
          "content": "package grpcui\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/jsonpb\" //lint:ignore SA1019 we have to import this because it appears in grpcurl APIs used herein\n\t\"github.com/golang/protobuf/proto\"  //lint:ignore SA1019 we have to import this because it appears in grpcurl APIs used herein\n\t\"github.com/golang/protobuf/protoc-gen-go/descriptor\"\n\t\"github.com/jhump/protoreflect/desc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/fullstorydev/grpcui/internal\"\n\t\"github.com/fullstorydev/grpcurl\"\n)\n\n// RPCInvokeHandler returns an HTTP handler that can be used to invoke RPCs. The\n// request includes request data, header metadata, and an optional timeout.\n//\n// The handler accepts POST requests with JSON bodies and returns a JSON payload\n// in response. The URI path should name an RPC method (\"/service/method\"). The\n// format of the request and response bodies matches the formats sent and\n// expected by the JavaScript client code embedded in WebFormContents.\n//\n// The returned handler expects to serve \"/\". If it will instead be handling a\n// sub-path (e.g. handling \"/rpc/invoke/\") then use http.StripPrefix.\n//\n// Note that the returned handler does not implement any CSRF protection. To\n// provide that, you will need to wrap the returned handler with one that first\n// enforces CSRF checks.\nfunc RPCInvokeHandler(ch grpc.ClientConnInterface, descs []*desc.MethodDescriptor) http.Handler {\n\treturn RPCInvokeHandlerWithOptions(ch, descs, InvokeOptions{})\n}\n\n// InvokeOptions contains optional arguments when creating a gRPCui invocation\n// handler.\ntype InvokeOptions struct {\n\t// The set of metadata to add to all outgoing RPCs. If the invocation\n\t// request includes conflicting metadata, these values override, and the\n\t// values in the request will not be sent.\n\tExtraMetadata []string\n\t// The set of HTTP header names that will be preserved. These are HTTP\n\t// request headers included in the invocation request that will be added as\n\t// request metadata when invoking the RPC. If the invocation request\n\t// includes conflicting metadata, the values in the HTTP request headers\n\t// will override, and the values in the request will not be sent.\n\tPreserveHeaders []string\n\t// Whether or not default values should be emitted in the JSON response\n\tEmitDefaults bool\n\t// If verbosity is greater than zero, the handler may log events, such as\n\t// cases where the request included metadata that conflicts with the\n\t// ExtraMetadata and PreserveHeaders fields above. It is an int, instead\n\t// of a bool \"verbose\" flag, so that additional logs may be added in the\n\t// future and the caller control how detailed those logs will be.\n\tVerbosity int\n}\n\n// RPCInvokeHandlerWithOptions is the same as RPCInvokeHandler except that it\n// accepts an additional argument, options. This can be used to add extra\n// request metadata to all RPCs invoked.\nfunc RPCInvokeHandlerWithOptions(ch grpc.ClientConnInterface, descs []*desc.MethodDescriptor, options InvokeOptions) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" {\n\t\t\tw.Header().Set(\"Allow\", \"POST\")\n\t\t\thttp.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\t\thttp.Error(w, \"Request must be JSON\", http.StatusUnsupportedMediaType)\n\t\t\treturn\n\t\t}\n\n\t\tmethod := r.URL.Path\n\t\tif method[0] == '/' {\n\t\t\tmethod = method[1:]\n\t\t}\n\n\t\tfor _, md := range descs {\n\t\t\tif md.GetFullyQualifiedName() == method {\n\t\t\t\tdescSource, err := grpcurl.DescriptorSourceFromFileDescriptors(md.GetFile())\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Failed to create descriptor source: \"+err.Error(), http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresults, err := invokeRPC(r.Context(), method, ch, descSource, r.Header, r.Body, &options)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif _, ok := err.(errReadFail); ok {\n\t\t\t\t\t\thttp.Error(w, \"Failed to read request\", 499)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif _, ok := err.(errBadInput); ok {\n\t\t\t\t\t\thttp.Error(w, \"Failed to parse JSON: \"+err.Error(), http.StatusBadRequest)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\thttp.Error(w, \"Unexpected error: \"+err.Error(), http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\tenc := json.NewEncoder(w)\n\t\t\t\tenc.SetIndent(\"\", \"  \")\n\t\t\t\tenc.Encode(results)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\thttp.NotFound(w, r)\n\t})\n}\n\n// RPCMetadataHandler returns an HTTP handler that can be used to get metadata\n// for a specified method.\n//\n// The handler accepts GET requests, using a query parameter to indicate the\n// method whose schema metadata should be fetched. The response payload will be\n// JSON. The format of the response body matches the format expected by the\n// JavaScript client code embedded in WebFormContents.\nfunc RPCMetadataHandler(methods []*desc.MethodDescriptor, files []*desc.FileDescriptor) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"GET\" {\n\t\t\tw.Header().Set(\"Allow\", \"GET\")\n\t\t\thttp.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tmethod := r.URL.Query().Get(\"method\")\n\t\tvar results *schema\n\t\tif method == \"*\" {\n\t\t\t// This means gather *all* message types. This is used to\n\t\t\t// provide a drop-down for Any messages.\n\t\t\tresults = gatherAllMessageMetadata(files)\n\t\t} else {\n\t\t\tfor _, md := range methods {\n\t\t\t\tif md.GetFullyQualifiedName() == method {\n\t\t\t\t\tr, err := gatherMetadataForMethod(md)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\thttp.Error(w, \"Failed to gather metadata for RPC Method\", http.StatusUnprocessableEntity)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tresults = r\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif results == nil {\n\t\t\thttp.Error(w, \"Unknown RPC Method\", http.StatusUnprocessableEntity)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tenc := json.NewEncoder(w)\n\n\t\tenc.SetIndent(\"\", \"  \")\n\t\t// TODO: what if enc.Encode returns a non-I/O error?\n\t\tenc.Encode(results)\n\t})\n}\n\n// TODO(jaime, jhump): schema is playing double duty here. It's both a vehicle for all\n// message and enum metadata. As well as RPC method scoped metadata for a single method.\n// What if we wanted to load metadata for all methods? We should consider splitting this\n// into 2 separate types for metadata to respond with accordingly.\ntype schema struct {\n\tRequestType   string                  `json:\"requestType\"`\n\tRequestStream bool                    `json:\"requestStream\"`\n\tMessageTypes  map[string][]fieldDef   `json:\"messageTypes\"`\n\tEnumTypes     map[string][]enumValDef `json:\"enumTypes\"`\n}\n\ntype fieldDef struct {\n\tName        string      `json:\"name\"`\n\tProtoName   string      `json:\"protoName\"`\n\tType        fieldType   `json:\"type\"`\n\tOneOfFields []fieldDef  `json:\"oneOfFields\"`\n\tIsMessage   bool        `json:\"isMessage\"`\n\tIsEnum      bool        `json:\"isEnum\"`\n\tIsArray     bool        `json:\"isArray\"`\n\tIsMap       bool        `json:\"isMap\"`\n\tIsRequired  bool        `json:\"isRequired\"`\n\tDefaultVal  interface{} `json:\"defaultVal\"`\n\tDescription string      `json:\"description\"`\n}\n\ntype enumValDef struct {\n\tNum  int32  `json:\"num\"`\n\tName string `json:\"name\"`\n}\n\ntype fieldType string\n\nconst (\n\ttypeString   fieldType = \"string\"\n\ttypeBytes    fieldType = \"bytes\"\n\ttypeInt32    fieldType = \"int32\"\n\ttypeInt64    fieldType = \"int64\"\n\ttypeSint32   fieldType = \"sint32\"\n\ttypeSint64   fieldType = \"sint64\"\n\ttypeUint32   fieldType = \"uint32\"\n\ttypeUint64   fieldType = \"uint64\"\n\ttypeFixed32  fieldType = \"fixed32\"\n\ttypeFixed64  fieldType = \"fixed64\"\n\ttypeSfixed32 fieldType = \"sfixed32\"\n\ttypeSfixed64 fieldType = \"sfixed64\"\n\ttypeFloat    fieldType = \"float\"\n\ttypeDouble   fieldType = \"double\"\n\ttypeBool     fieldType = \"bool\"\n\ttypeOneOf    fieldType = \"oneof\"\n)\n\nvar typeMap = map[descriptor.FieldDescriptorProto_Type]fieldType{\n\tdescriptor.FieldDescriptorProto_TYPE_STRING:   typeString,\n\tdescriptor.FieldDescriptorProto_TYPE_BYTES:    typeBytes,\n\tdescriptor.FieldDescriptorProto_TYPE_INT32:    typeInt32,\n\tdescriptor.FieldDescriptorProto_TYPE_INT64:    typeInt64,\n\tdescriptor.FieldDescriptorProto_TYPE_SINT32:   typeSint32,\n\tdescriptor.FieldDescriptorProto_TYPE_SINT64:   typeSint64,\n\tdescriptor.FieldDescriptorProto_TYPE_UINT32:   typeUint32,\n\tdescriptor.FieldDescriptorProto_TYPE_UINT64:   typeUint64,\n\tdescriptor.FieldDescriptorProto_TYPE_FIXED32:  typeFixed32,\n\tdescriptor.FieldDescriptorProto_TYPE_FIXED64:  typeFixed64,\n\tdescriptor.FieldDescriptorProto_TYPE_SFIXED32: typeSfixed32,\n\tdescriptor.FieldDescriptorProto_TYPE_SFIXED64: typeSfixed64,\n\tdescriptor.FieldDescriptorProto_TYPE_FLOAT:    typeFloat,\n\tdescriptor.FieldDescriptorProto_TYPE_DOUBLE:   typeDouble,\n\tdescriptor.FieldDescriptorProto_TYPE_BOOL:     typeBool,\n}\n\nfunc gatherAllMessageMetadata(files []*desc.FileDescriptor) *schema {\n\tresult := &schema{\n\t\tMessageTypes: map[string][]fieldDef{},\n\t\tEnumTypes:    map[string][]enumValDef{},\n\t}\n\tfor _, fd := range files {\n\t\tgatherAllMessages(fd.GetMessageTypes(), result)\n\t}\n\treturn result\n}\n\nfunc gatherAllMessages(msgs []*desc.MessageDescriptor, result *schema) {\n\tfor _, md := range msgs {\n\t\tresult.visitMessage(md)\n\t\tgatherAllMessages(md.GetNestedMessageTypes(), result)\n\t}\n}\n\nfunc gatherMetadataForMethod(md *desc.MethodDescriptor) (*schema, error) {\n\tmsg := md.GetInputType()\n\tresult := &schema{\n\t\tRequestType:   msg.GetFullyQualifiedName(),\n\t\tRequestStream: md.IsClientStreaming(),\n\t\tMessageTypes:  map[string][]fieldDef{},\n\t\tEnumTypes:     map[string][]enumValDef{},\n\t}\n\n\tresult.visitMessage(msg)\n\n\treturn result, nil\n}\n\nfunc (s *schema) visitMessage(md *desc.MessageDescriptor) {\n\tif _, ok := s.MessageTypes[md.GetFullyQualifiedName()]; ok {\n\t\t// already visited\n\t\treturn\n\t}\n\n\tfields := make([]fieldDef, 0, len(md.GetFields()))\n\ts.MessageTypes[md.GetFullyQualifiedName()] = fields\n\n\toneOfsSeen := map[*desc.OneOfDescriptor]struct{}{}\n\tfor _, fd := range md.GetFields() {\n\t\tood := fd.GetOneOf()\n\t\tif ood != nil {\n\t\t\tif _, ok := oneOfsSeen[ood]; ok {\n\t\t\t\t// already processed this one\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toneOfsSeen[ood] = struct{}{}\n\t\t\tfields = append(fields, s.processOneOf(ood))\n\t\t} else {\n\t\t\tfields = append(fields, s.processField(fd))\n\t\t}\n\t}\n\n\ts.MessageTypes[md.GetFullyQualifiedName()] = fields\n}\n\nfunc (s *schema) processField(fd *desc.FieldDescriptor) fieldDef {\n\tdef := fieldDef{\n\t\tName:       fd.GetJSONName(),\n\t\tProtoName:  fd.GetName(),\n\t\tIsEnum:     fd.GetEnumType() != nil,\n\t\tIsMessage:  fd.GetMessageType() != nil,\n\t\tIsArray:    fd.IsRepeated() && !fd.IsMap(),\n\t\tIsMap:      fd.IsMap(),\n\t\tIsRequired: fd.IsRequired(),\n\t\tDefaultVal: fd.GetDefaultValue(),\n\t}\n\n\tif def.IsMap {\n\t\t// fd.GetDefaultValue returns empty map[interface{}]interface{}\n\t\t// as the default for map fields, but \"encoding/json\" refuses\n\t\t// to encode a map with interface{} keys (even if it's empty).\n\t\t// So we fix up the key type here.\n\t\tdef.DefaultVal = map[string]interface{}{}\n\t}\n\n\t// 64-bit int values are represented as strings in JSON\n\tif i, ok := def.DefaultVal.(int64); ok {\n\t\tdef.DefaultVal = fmt.Sprintf(\"%d\", i)\n\t} else if u, ok := def.DefaultVal.(uint64); ok {\n\t\tdef.DefaultVal = fmt.Sprintf(\"%d\", u)\n\t} else if b, ok := def.DefaultVal.([]byte); ok && b == nil {\n\t\t// bytes fields may have []byte(nil) as default value, but\n\t\t// that gets rendered as JSON null, not empty array\n\t\tdef.DefaultVal = []byte{}\n\t}\n\n\tswitch fd.GetType() {\n\tcase descriptor.FieldDescriptorProto_TYPE_ENUM:\n\t\tdef.Type = fieldType(fd.GetEnumType().GetFullyQualifiedName())\n\t\ts.visitEnum(fd.GetEnumType())\n\t\t// DefaultVal will be int32 for enums, but we want to instead\n\t\t// send enum name as string\n\t\tif val, ok := def.DefaultVal.(int32); ok {\n\t\t\tvalDesc := fd.GetEnumType().FindValueByNumber(val)\n\t\t\tif valDesc != nil {\n\t\t\t\tdef.DefaultVal = valDesc.GetName()\n\t\t\t}\n\t\t}\n\n\tcase descriptor.FieldDescriptorProto_TYPE_GROUP, descriptor.FieldDescriptorProto_TYPE_MESSAGE:\n\t\tdef.Type = fieldType(fd.GetMessageType().GetFullyQualifiedName())\n\t\ts.visitMessage(fd.GetMessageType())\n\n\tdefault:\n\t\tdef.Type = typeMap[fd.GetType()]\n\t}\n\n\tdesc, err := protoPrinter.PrintProtoToString(fd)\n\tif err != nil {\n\t\t// generate simple description with no comments or options\n\t\tvar label string\n\t\tif fd.IsRequired() {\n\t\t\tlabel = \"required \"\n\t\t} else if fd.IsRepeated() {\n\t\t\tlabel = \"repeated \"\n\t\t} else if fd.IsProto3Optional() || !fd.GetFile().IsProto3() {\n\t\t\tlabel = \"optional \"\n\t\t}\n\t\tdesc = fmt.Sprintf(\"%s%s %s = %d;\", label, def.Type, fd.GetName(), fd.GetNumber())\n\t}\n\tdef.Description = desc\n\n\treturn def\n}\n\nfunc (s *schema) processOneOf(ood *desc.OneOfDescriptor) fieldDef {\n\tchoices := make([]fieldDef, len(ood.GetChoices()))\n\tfor i, fd := range ood.GetChoices() {\n\t\tchoices[i] = s.processField(fd)\n\t}\n\treturn fieldDef{\n\t\tName:        ood.GetName(),\n\t\tType:        typeOneOf,\n\t\tOneOfFields: choices,\n\t}\n}\n\nfunc (s *schema) visitEnum(ed *desc.EnumDescriptor) {\n\tif _, ok := s.EnumTypes[ed.GetFullyQualifiedName()]; ok {\n\t\t// already visited\n\t\treturn\n\t}\n\n\tenumVals := make([]enumValDef, len(ed.GetValues()))\n\tfor i, evd := range ed.GetValues() {\n\t\tenumVals[i] = enumValDef{\n\t\t\tNum:  evd.GetNumber(),\n\t\t\tName: evd.GetName(),\n\t\t}\n\t}\n\n\ts.EnumTypes[ed.GetFullyQualifiedName()] = enumVals\n}\n\ntype errBadInput struct {\n\terr error\n}\n\nfunc (e errBadInput) Error() string {\n\treturn e.err.Error()\n}\n\ntype errReadFail struct {\n\terr error\n}\n\nfunc (e errReadFail) Error() string {\n\treturn e.err.Error()\n}\n\nfunc invokeRPC(ctx context.Context, methodName string, ch grpc.ClientConnInterface, descSource grpcurl.DescriptorSource, reqHdrs http.Header, body io.Reader, options *InvokeOptions) (*rpcResult, error) {\n\tjs, err := io.ReadAll(body)\n\tif err != nil {\n\t\treturn nil, errReadFail{err: err}\n\t}\n\n\tvar input rpcInput\n\tif err := json.Unmarshal(js, &input); err != nil {\n\t\treturn nil, errBadInput{err: err}\n\t}\n\n\treqStats := rpcRequestStats{\n\t\tTotal: len(input.Data),\n\t}\n\trequestFunc := func(m proto.Message) error {\n\t\tif len(input.Data) == 0 {\n\t\t\treturn io.EOF\n\t\t}\n\t\treqStats.Sent++\n\t\treq := input.Data[0]\n\t\tinput.Data = input.Data[1:]\n\t\tif err := jsonpb.Unmarshal(bytes.NewReader(req), m); err != nil {\n\t\t\treturn status.Errorf(codes.InvalidArgument, err.Error())\n\t\t}\n\t\treturn nil\n\t}\n\n\twebFormHdrs := make(metadata.MD, len(input.Metadata))\n\tfor _, hdr := range input.Metadata {\n\t\twebFormHdrs.Append(hdr.Name, hdr.Value)\n\t}\n\tinvokeHdrs := options.computeHeaders(reqHdrs, webFormHdrs)\n\n\tif input.TimeoutSeconds > 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeout := time.Duration(input.TimeoutSeconds * float32(time.Second))\n\t\t// If the timeout is too huge that it overflows int64, cap it off.\n\t\tif timeout < 0 {\n\t\t\ttimeout = time.Duration(math.MaxInt64)\n\t\t}\n\t\tctx, cancel = context.WithTimeout(ctx, timeout)\n\t\tdefer cancel()\n\t}\n\n\tresult := rpcResult{\n\t\tdescSource:   descSource,\n\t\temitDefaults: options.EmitDefaults,\n\t\tRequests:     &reqStats,\n\t}\n\tif err := grpcurl.InvokeRPC(ctx, descSource, ch, methodName, invokeHdrs, &result, requestFunc); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &result, nil\n}\n\nfunc (opts *InvokeOptions) overrideHeaders(reqHdrs http.Header) metadata.MD {\n\thdrs := grpcurl.MetadataFromHeaders(opts.ExtraMetadata)\n\tfor _, name := range opts.PreserveHeaders {\n\t\tvals := reqHdrs.Values(name)\n\t\tif opts.Verbosity > 0 {\n\t\t\tif existing := hdrs.Get(name); len(existing) > 0 {\n\t\t\t\tinternal.LogInfof(\"preserving HTTP header %q, which overrides given extra header\", name)\n\t\t\t}\n\t\t}\n\t\thdrs.Set(name, vals...)\n\t}\n\treturn hdrs\n}\n\nfunc (opts *InvokeOptions) computeHeaders(reqHdrs http.Header, webFormHdrs metadata.MD) []string {\n\t// add extra headers, overriding whatever was in the web form\n\toverrideHdrs := opts.overrideHeaders(reqHdrs)\n\tfor k, v := range overrideHdrs {\n\t\tif opts.Verbosity > 0 {\n\t\t\tif existing := webFormHdrs.Get(k); len(existing) > 0 {\n\t\t\t\tinternal.LogInfof(\"web form included metadata %q, but it will be ignored due to given extra/preserved headers\", k)\n\t\t\t}\n\t\t}\n\t\twebFormHdrs[k] = v\n\t}\n\n\t// convert them back to the form that the grpcurl lib expects\n\ttotalLen := 0\n\tkeys := make([]string, 0, len(webFormHdrs))\n\tfor k, vs := range webFormHdrs {\n\t\ttotalLen += len(vs)\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\tresult := make([]string, 0, totalLen)\n\tfor _, k := range keys {\n\t\tfor _, v := range webFormHdrs[k] {\n\t\t\tresult = append(result, fmt.Sprintf(\"%s: %s\", k, v))\n\t\t}\n\t}\n\treturn result\n}\n\ntype rpcMetadata struct {\n\tName  string `json:\"name\"`\n\tValue string `json:\"value\"`\n}\n\ntype rpcInput struct {\n\tTimeoutSeconds float32           `json:\"timeout_seconds\"`\n\tMetadata       []rpcMetadata     `json:\"metadata\"`\n\tData           []json.RawMessage `json:\"data\"`\n}\n\ntype rpcResponseElement struct {\n\tData    json.RawMessage `json:\"message\"`\n\tIsError bool            `json:\"isError\"`\n}\n\ntype rpcRequestStats struct {\n\tTotal int `json:\"total\"`\n\tSent  int `json:\"sent\"`\n}\n\ntype rpcError struct {\n\tCode    uint32               `json:\"code\"`\n\tName    string               `json:\"name\"`\n\tMessage string               `json:\"message\"`\n\tDetails []rpcResponseElement `json:\"details\"`\n}\n\ntype rpcResult struct {\n\tdescSource   grpcurl.DescriptorSource\n\temitDefaults bool\n\tHeaders      []rpcMetadata        `json:\"headers\"`\n\tError        *rpcError            `json:\"error\"`\n\tResponses    []rpcResponseElement `json:\"responses\"`\n\tRequests     *rpcRequestStats     `json:\"requests\"`\n\tTrailers     []rpcMetadata        `json:\"trailers\"`\n}\n\nfunc (*rpcResult) OnResolveMethod(*desc.MethodDescriptor) {}\n\nfunc (*rpcResult) OnSendHeaders(metadata.MD) {}\n\nfunc (r *rpcResult) OnReceiveHeaders(md metadata.MD) {\n\tr.Headers = responseMetadata(md)\n}\n\nfunc (r *rpcResult) OnReceiveResponse(m proto.Message) {\n\tr.Responses = append(r.Responses, responseToJSON(r.descSource, m, r.emitDefaults))\n}\n\nfunc (r *rpcResult) OnReceiveTrailers(stat *status.Status, md metadata.MD) {\n\tr.Trailers = responseMetadata(md)\n\tr.Error = toRpcError(r.descSource, stat, r.emitDefaults)\n}\n\nfunc responseMetadata(md metadata.MD) []rpcMetadata {\n\tkeys := make([]string, 0, len(md))\n\tfor k := range md {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\tret := make([]rpcMetadata, 0, len(md))\n\tfor _, k := range keys {\n\t\tvals := md[k]\n\t\tfor _, v := range vals {\n\t\t\tif strings.HasSuffix(k, \"-bin\") {\n\t\t\t\tv = base64.StdEncoding.EncodeToString([]byte(v))\n\t\t\t}\n\t\t\tret = append(ret, rpcMetadata{Name: k, Value: v})\n\t\t}\n\t}\n\treturn ret\n}\n\nfunc toRpcError(descSource grpcurl.DescriptorSource, stat *status.Status, emitDefaults bool) *rpcError {\n\tif stat.Code() == codes.OK {\n\t\treturn nil\n\t}\n\n\tdetails := stat.Proto().Details\n\tmsgs := make([]rpcResponseElement, len(details))\n\tfor i, d := range details {\n\t\tmsgs[i] = responseToJSON(descSource, d, emitDefaults)\n\t}\n\treturn &rpcError{\n\t\tCode:    uint32(stat.Code()),\n\t\tName:    stat.Code().String(),\n\t\tMessage: stat.Message(),\n\t\tDetails: msgs,\n\t}\n}\n\nfunc responseToJSON(descSource grpcurl.DescriptorSource, msg proto.Message, emitDefaults bool) rpcResponseElement {\n\tanyResolver := grpcurl.AnyResolverFromDescriptorSourceWithFallback(descSource)\n\tjsm := jsonpb.Marshaler{EmitDefaults: emitDefaults, OrigName: true, Indent: \"  \", AnyResolver: anyResolver}\n\tvar b bytes.Buffer\n\tif err := jsm.Marshal(&b, msg); err == nil {\n\t\treturn rpcResponseElement{Data: json.RawMessage(b.Bytes())}\n\t} else {\n\t\tb, err := json.Marshal(err.Error())\n\t\tif err != nil {\n\t\t\t// unable to marshal err message to JSON?\n\t\t\t// should never happen... here's a dumb fallback\n\t\t\tb = []byte(strconv.Quote(err.Error()))\n\t\t}\n\t\treturn rpcResponseElement{Data: b, IsError: true}\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "methods.go",
          "type": "blob",
          "size": 2.9931640625,
          "content": "package grpcui\n\nimport (\n\t\"github.com/jhump/protoreflect/desc\"\n\t\"github.com/jhump/protoreflect/grpcreflect\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\n// AllMethodsForServices returns a slice that contains the method descriptors\n// for all methods in the given services.\nfunc AllMethodsForServices(descs []*desc.ServiceDescriptor) []*desc.MethodDescriptor {\n\tseen := map[string]struct{}{}\n\tvar allMethods []*desc.MethodDescriptor\n\tfor _, sd := range descs {\n\t\tif _, ok := seen[sd.GetFullyQualifiedName()]; ok {\n\t\t\t// duplicate\n\t\t\tcontinue\n\t\t}\n\t\tseen[sd.GetFullyQualifiedName()] = struct{}{}\n\t\tallMethods = append(allMethods, sd.GetMethods()...)\n\t}\n\treturn allMethods\n}\n\n// AllMethodsForServer returns a slice that contains the method descriptors for\n// all methods exposed by the given gRPC server.\nfunc AllMethodsForServer(svr *grpc.Server) ([]*desc.MethodDescriptor, error) {\n\tsvcs, err := grpcreflect.LoadServiceDescriptors(svr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar descs []*desc.ServiceDescriptor\n\tfor _, sd := range svcs {\n\t\tdescs = append(descs, sd)\n\t}\n\treturn AllMethodsForServices(descs), nil\n}\n\n// AllMethodsViaReflection returns a slice that contains the method descriptors\n// for all methods exposed by the server on the other end of the given\n// connection. This returns an error if the server does not support service\n// reflection. (See \"google.golang.org/grpc/reflection\" for more on service\n// reflection.)\n// This automatically skips the reflection service, since it is assumed this is not\n// a desired inclusion.\nfunc AllMethodsViaReflection(ctx context.Context, cc grpc.ClientConnInterface) ([]*desc.MethodDescriptor, error) {\n\tcli := grpcreflect.NewClientAuto(ctx, cc)\n\tsvcNames, err := cli.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar descs []*desc.ServiceDescriptor\n\tfor _, svcName := range svcNames {\n\t\tsd, err := cli.ResolveService(svcName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfullyQualifiedName := sd.GetFullyQualifiedName()\n\t\tif fullyQualifiedName == \"grpc.reflection.v1alpha.ServerReflection\" || fullyQualifiedName == \"grpc.reflection.v1.ServerReflection\" {\n\t\t\tcontinue // skip reflection service\n\t\t}\n\t\tdescs = append(descs, sd)\n\t}\n\treturn AllMethodsForServices(descs), nil\n}\n\n// AllMethodsViaInProcess returns a slice that contains the method descriptors\n// for all methods exposed by the given server.\n// This automatically skips the reflection service, since it is assumed this is not\n// a desired inclusion.\nfunc AllMethodsViaInProcess(svr reflection.GRPCServer) ([]*desc.MethodDescriptor, error) {\n\tsds, err := grpcreflect.LoadServiceDescriptors(svr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar descs []*desc.ServiceDescriptor\n\tfor _, sd := range sds {\n\t\tfullyQualifiedName := sd.GetFullyQualifiedName()\n\t\tif fullyQualifiedName == \"grpc.reflection.v1alpha.ServerReflection\" || fullyQualifiedName == \"grpc.reflection.v1.ServerReflection\" {\n\t\t\tcontinue // skip reflection service\n\t\t}\n\t\tdescs = append(descs, sd)\n\t}\n\treturn AllMethodsForServices(descs), nil\n}\n"
        },
        {
          "name": "releasing",
          "type": "tree",
          "content": null
        },
        {
          "name": "standalone",
          "type": "tree",
          "content": null
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "webform.go",
          "type": "blob",
          "size": 7.1767578125,
          "content": "package grpcui\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/jhump/protoreflect/desc/builder\"\n\t\"github.com/jhump/protoreflect/desc/protoprint\"\n\t\"html/template\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/jhump/protoreflect/desc\"\n\n\t\"github.com/fullstorydev/grpcui/internal/resources/webform\"\n)\n\nvar (\n\twebFormTemplate = template.Must(template.New(\"grpc web form\").Parse(string(webform.Template())))\n\n\tprotoPrinter = protoprint.Printer{\n\t\tCompact: true,\n\t\tIndent:  \"   \",\n\t}\n)\n\n// WebFormContents returns an HTML form that can be embedded into a web UI to\n// provide an interactive form for issuing RPCs.\n//\n// For a fully self-contained handler that provides both an HTML UI and the\n// needed server handlers, see grpcui.UIHandler instead.\n//\n// The given invokeURI and metadataURI indicate the URI paths where server\n// handlers are registered for invoking RPCs and querying RPC metadata,\n// respectively. Handlers for these endpoints are provided via the\n// RPCInvokeHandler and RPCMetadataHandler functions:\n//\n//\t// This example uses \"/rpcs\" as the base URI.\n//\tpageHandler := func(w http.ResponseWriter, r *http.Request) {\n//\t  webForm := grpcui.WebFormContents(\"/rpcs/invoke/\", \"/rpcs/metadata\", descs)\n//\t  webFormJs := grpcui.WebFormScript()\n//\t  generateHTMLPage(w, r, webForm, webFormJs)\n//\t}\n//\n//\t// Make sure the RPC handlers are registered at the same URI paths\n//\t// that were used in the call to WebFormContents:\n//\trpcInvokeHandler := http.StripPrefix(\"/rpcs/invoke\", grpcui.RPCInvokeHandler(conn, descs))\n//\tmux.Handle(\"/rpcs/invoke/\", rpcInvokeHandler)\n//\tmux.Handle(\"/rpcs/metadata\", grpcui.RPCMetadataHandler(descs))\n//\tmux.HandleFunc(\"/rpcs/index.html\", pageHandler)\n//\n// The given descs is a slice of methods which are exposed through the web form.\n// You can use AllMethodsForServices, AllMethodsForServer, and\n// AllMethodsViaReflection helper functions to build this list.\n//\n// The returned HTML form requires that the contents of WebFormScript() have\n// already been loaded as a script in the page.\nfunc WebFormContents(invokeURI, metadataURI string, target string, descs []*desc.MethodDescriptor) []byte {\n\treturn WebFormContentsWithOptions(invokeURI, metadataURI, target, descs, WebFormOptions{})\n}\n\n// WebFormOptions contains optional arguments when creating a gRPCui web form.\ntype WebFormOptions struct {\n\t// The set of metadata to show in the web form by default. Each value in\n\t// the slice should be in the form \"name: value\"\n\tDefaultMetadata []string\n\t// If non-nil and true, the web form JS code will log debug information\n\t// to the JS console. If nil, whether debug is enabled or not depends on\n\t// an environment variable: GRPC_WEBFORM_DEBUG (if it's not blank, then\n\t// debug is enabled).\n\tDebug *bool\n}\n\n// WebFormContentsWithOptions is the same as WebFormContents except that it\n// accepts an additional argument, options. This can be used to toggle the JS\n// code into debug logging and can also be used to define the set of metadata to\n// show in the web form by default (empty if unspecified).\nfunc WebFormContentsWithOptions(invokeURI, metadataURI string, target string, descs []*desc.MethodDescriptor, opts WebFormOptions) []byte {\n\ttype metadataEntry struct {\n\t\tName, Value string\n\t}\n\tparams := struct {\n\t\tInvokeURI       string\n\t\tMetadataURI     string\n\t\tServices        []string\n\t\tSvcDescs        map[string]string\n\t\tMethods         map[string][]string\n\t\tMtdDescs        map[string]string\n\t\tDefaultMetadata []metadataEntry\n\t\tDebug           bool\n\t\tTarget          string\n\t}{\n\t\tInvokeURI:   invokeURI,\n\t\tMetadataURI: metadataURI,\n\t\tSvcDescs:    map[string]string{},\n\t\tMethods:     map[string][]string{},\n\t\tMtdDescs:    map[string]string{},\n\t\tDebug:       os.Getenv(\"GRPC_WEBFORM_DEBUG\") != \"\",\n\t\tTarget:      target,\n\t}\n\n\tif opts.Debug != nil {\n\t\tparams.Debug = *opts.Debug\n\t}\n\tfor _, md := range opts.DefaultMetadata {\n\t\tparts := strings.SplitN(md, \":\", 2)\n\t\tkey := strings.TrimSpace(parts[0])\n\t\tvar val string\n\t\tif len(parts) > 1 {\n\t\t\tval = strings.TrimLeftFunc(parts[1], unicode.IsSpace)\n\t\t}\n\t\tparams.DefaultMetadata = append(params.DefaultMetadata, metadataEntry{Name: key, Value: val})\n\t}\n\n\t// build list of distinct service and method names and sort them\n\tuniqueServices := map[string]*desc.ServiceDescriptor{}\n\tfor _, md := range descs {\n\t\tsd := md.GetService()\n\t\tsvcName := sd.GetFullyQualifiedName()\n\t\tuniqueServices[svcName] = sd\n\t\tparams.Methods[svcName] = append(params.Methods[svcName], md.GetName())\n\n\t\tdesc, err := protoPrinter.PrintProtoToString(md)\n\t\tif err != nil {\n\t\t\t// generate simple description with no comments or options\n\t\t\tvar reqStr, respStr string\n\t\t\tif md.IsClientStreaming() {\n\t\t\t\treqStr = \"stream \"\n\t\t\t}\n\t\t\tif md.IsServerStreaming() {\n\t\t\t\trespStr = \"stream \"\n\t\t\t}\n\t\t\tdesc = fmt.Sprintf(\"   rpc %s (%s%s) returns (%s%s);\", md.GetName(), reqStr, md.GetInputType().GetFullyQualifiedName(), respStr, md.GetOutputType().GetFullyQualifiedName())\n\t\t} else {\n\t\t\t// indent and remove trailing newline\n\t\t\tdesc = strings.TrimSuffix(desc, \"\\n\")\n\t\t\tparts := strings.Split(desc, \"\\n\")\n\t\t\tfor i := range parts {\n\t\t\t\tparts[i] = \"   \" + parts[i]\n\t\t\t}\n\t\t\tdesc = strings.Join(parts, \"\\n\")\n\t\t}\n\t\tparams.MtdDescs[md.GetFullyQualifiedName()] = desc\n\t}\n\tfor svcName, sd := range uniqueServices {\n\t\tparams.Services = append(params.Services, svcName)\n\t\t// for the service description, omit the methods (we just want the\n\t\t//  service's comments and options)\n\t\tsb, err := builder.FromService(sd)\n\t\tvar desc string\n\t\tif err == nil {\n\t\t\tfor _, md := range sd.GetMethods() {\n\t\t\t\tsb.RemoveMethod(md.GetName())\n\t\t\t}\n\t\t\tif s, e := sb.Build(); e == nil {\n\t\t\t\tdesc, err = protoPrinter.PrintProtoToString(s)\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\tdesc = fmt.Sprintf(\"service %s {\", sd.GetName())\n\t\t} else {\n\t\t\t// strip last line, trailing close brace\n\t\t\ttr := \"\\n}\"\n\t\t\tif strings.HasSuffix(desc, \"\\n\") {\n\t\t\t\ttr += \"\\n\"\n\t\t\t}\n\t\t\tdesc = strings.TrimSuffix(desc, tr)\n\t\t}\n\t\tparams.SvcDescs[sd.GetFullyQualifiedName()] = desc\n\t}\n\tsort.Strings(params.Services)\n\tfor _, methods := range params.Methods {\n\t\tsort.Strings(methods)\n\t}\n\n\t// render the template\n\tvar formBuf bytes.Buffer\n\tif err := webFormTemplate.Execute(&formBuf, params); err != nil {\n\t\tpanic(err)\n\t}\n\treturn formBuf.Bytes()\n}\n\n// WebFormScript returns the JavaScript that powers the web form returned by\n// WebFormContents.\n//\n// The returned JavaScript requires that jQuery and jQuery UI libraries already\n// be loaded in the container HTML page. It includes JavaScript code that relies\n// on the \"$\" symbol.\n//\n// Note that the script, by default, does not handle CSRF protection. To add\n// that, the enclosing page, in which the script is embedded, can use jQuery to\n// configure this. For example, you can use the $.ajaxSend() jQuery function to\n// intercept RPC invocations and automatically add a CSRF token header. To then\n// check the token on the server-side, you will need to create a wrapper handler\n// that first verifies the CSRF token header before delegating to a\n// RPCInvokeHandler.\nfunc WebFormScript() []byte {\n\treturn webform.Script()\n}\n\n// WebFormSampleCSS returns a CSS stylesheet for styling the HTML web form\n// returned by WebFormContents. It is possible for uses of the web form to\n// supply their own stylesheet, but this makes it simple to use default\n// styling.\nfunc WebFormSampleCSS() []byte {\n\treturn webform.SampleCSS()\n}\n"
        }
      ]
    }
  ]
}