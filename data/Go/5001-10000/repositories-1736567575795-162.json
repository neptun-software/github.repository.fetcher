{
  "metadata": {
    "timestamp": 1736567575795,
    "page": 162,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pressly/goose",
      "stars": 7433,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.140625,
          "content": ".idea\n.vscode\n.DS_Store\n*.swp\n*.test\n\n# Files output by tests\n/bin\n\n# Local testing\n.envrc\n*.FAIL\n\ndist/\nrelease_notes.txt\n\ngo.work\ngo.work.sum\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.1962890625,
          "content": "linters:\n  disable-all: true\n  enable:\n    # Default\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n    - gofmt\n    # Added\n    - testifylint\n    - misspell\n"
        },
        {
          "name": ".goreleaser.yaml",
          "type": "blob",
          "size": 0.87109375,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema.json\n#\n# See https://goreleaser.com/customization/ for more information.\nversion: 2\nproject_name: goose\n\nbefore:\n  hooks:\n    - go mod tidy\nbuilds:\n  - env:\n      - CGO_ENABLED=0\n    binary: goose\n    main: ./cmd/goose\n    goos:\n      - linux\n      - windows\n      - darwin\n    goarch:\n      - amd64\n      - arm64\n    ldflags:\n      # The v prefix is stripped by goreleaser, so we need to add it back.\n      # https://goreleaser.com/customization/templates/#fnref:version-prefix\n      - \"-s -w -X main.version=v{{ .Version }}\"\n\narchives:\n  - format: binary\n    name_template: >-\n      {{ .ProjectName }}_{{- tolower .Os }}_{{- if eq .Arch \"amd64\" }}x86_64{{- else }}{{ .Arch }}{{ end }}\nchecksum:\n  name_template: \"checksums.txt\"\nsnapshot:\n  version_template: \"{{ incpatch .Version }}-next\"\nchangelog:\n  use: github-native\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 12.0732421875,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project\nadheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [v3.24.1]\n\n- Fix regression (`v3.23.1` and `v3.24.0`) in postgres migration table existence check for\n  non-default schema. (#882, #883, #884).\n\n## [v3.24.0]\n\n- Add support for loading environment variables from `.env` files, enabled by default.\n  - The default file name is `.env`, but can be changed with the `-env=<filename>` flag.\n  - To disable this feature, set `-env=none`.\n\n## [v3.23.1]\n\n- Store implementations can **optionally** implement the `TableExists` method to provide optimized\n  table existence checks (#860)\n  - Default postgres Store implementation updated to use `pg_tables` system catalog, more to follow\n  - Backward compatible change - existing implementations will continue to work without modification\n\n```go\nTableExists(ctx context.Context, db database.DBTxConn) (bool, error)\n```\n\n## [v3.23.0]\n\n- Add `WithLogger` to `NewProvider` to allow custom loggers (#833)\n- Update Provider `WithVerbose` behavior to log all SQL statements (#851)\n- Upgrade dependencies and rebuild binaries with latest Go version (`go1.23.3`)\n\n## [v3.22.1]\n\n- Upgrade dependencies and rebuild binaries with latest Go version (`go1.23.1`)\n\n## [v3.22.0]\n\n- Minimum Go version is now 1.21\n- Add Unwrap to PartialError (#815)\n- Allow flags anywhere on the CLI (#814)\n\n`goose` uses the default Go `flag` parsing library, which means flags **must** be defined before the\nfirst positional argument. We've updated this behavior to allow flags to be defined anywhere. For\nmore details, see [blog post](https://mfridman.com/blog/2024/allowing-flags-anywhere-on-the-cli/).\n\n- Update `WithDisableGlobalRegistry` behavior (#783). When set, this will ignore globally-registered\n  migrationse entirely instead of the previous behavior of raising an error. Specifically, the\n  following check is removed:\n\n```go\nif len(global) > 0 {\n\treturn nil, errors.New(\"global registry disabled, but provider has registered go migrations\")\n}\n```\n\nThis enables creating isolated goose provider(s) in legacy environments where global migrations may\nbe registered. Without updating this behavior, it would be impossible to use\n`WithDisableGlobalRegistry` in combination with provider-scoped `WithGoMigrations`.\n\n- Postgres, updated schema to use identity instead of serial and make `tstamp` not nullable (#556)\n\n```diff\n- id serial NOT NULL,\n+ id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n\n- tstamp timestamp NULL default now(),\n+ tstamp timestamp NOT NULL DEFAULT now()\n```\n\n- MySQL, updated schema to not use SERIAL alias (#816)\n\n```diff\n- id serial NOT NULL,\n+ id bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n```\n\n## [v3.21.1]\n\n- Add `GetVersions` method to `goose.Provider`, returns the current (max db) version and the latest\n  (max filesystem) version. (#756)\n- Clarify `GetLatestVersion` method MUST return `ErrVersionNotFound` if no latest migration is\n  found. Previously it was returning a -1 and nil error, which was inconsistent with the rest of the\n  API surface.\n\n- Add `GetLatestVersion` implementations to all existing dialects. This is an optimization to avoid\n  loading all migrations when only the latest version is needed. This uses the `max` function in SQL\n  to get the latest version_id irrespective of the order of applied migrations.\n  - Refactor existing portions of the code to use the new `GetLatestVersion` method.\n\n## [v3.21.0]\n\n- Retracted. Broken release, please use v3.21.1 instead.\n\n## [v3.20.0]\n\n- Expand the `Store` interface by adding a `GetLatestVersion` method and make the interface public.\n- Add a (non-blocking) method to check if there are pending migrations to the `goose.Provider`\n  (#751):\n\n```go\nfunc (p *Provider) HasPending(context.Context) (bool, error) {}\n```\n\nThe underlying implementation **does not respect the `SessionLocker`** (if one is enabled) and can\nbe used to check for pending migrations without blocking or being blocked by other operations.\n\n- The methods `.Up`, `.UpByOne`, and `.UpTo` from `goose.Provider` will invoke `.HasPending` before\n  acquiring a lock with `SessionLocker` (if enabled). This addresses an edge case in\n  Kubernetes-style deployments where newer pods with long-running migrations prevent older pods -\n  which have all known migrations applied - from starting up due to an advisory lock. For more\n  details, refer to https://github.com/pressly/goose/pull/507#discussion_r1266498077 and #751.\n- Move integration tests to `./internal/testing` and make it a separate Go module. This will allow\n  us to have a cleaner top-level go.mod file and avoid imports unrelated to the goose project. See\n  [integration/README.md](https://github.com/pressly/goose/blob/d0641b5bfb3bd5d38d95fe7a63d7ddf2d282234d/internal/testing/integration/README.md)\n  for more details. This shouldn't affect users of the goose library.\n\n## [v3.19.2] - 2024-03-13\n\n- Remove duckdb support. The driver uses Cgo and we've decided to remove it until we can find a\n  better solution. If you were using duckdb with goose, please let us know by opening an issue.\n\n## [v3.19.1] - 2024-03-11\n\n- Fix selecting dialect for `redshift`\n- Add `GOOSE_MIGRATION_DIR` documentation\n- Bump github.com/opencontainers/runc to `v1.1.12` (security fix)\n- Update CI tests for go1.22\n- Make goose annotations case-insensitive\n  - All `-- +goose` annotations are now case-insensitive. This means that `-- +goose Up` and `--\n+goose up` are now equivalent. This change was made to improve the user experience and to make the\n    annotations more consistent.\n\n## [v3.19.0] - 2024-03-11\n\n- Use [v3.19.1] instead. This was tagged but not released and does not contain release binaries.\n\n## [v3.18.0] - 2024-01-31\n\n- Add environment variable substitution for SQL migrations. (#604)\n\n  - This feature is **disabled by default**, and can be enabled by adding an annotation to the\n    migration file:\n\n    ```sql\n    -- +goose ENVSUB ON\n    ```\n\n  - When enabled, goose will attempt to substitute environment variables in the SQL migration\n    queries until the end of the file, or until the annotation `-- +goose ENVSUB OFF` is found. For\n    example, if the environment variable `REGION` is set to `us_east_1`, the following SQL migration\n    will be substituted to `SELECT * FROM regions WHERE name = 'us_east_1';`\n\n    ```sql\n    -- +goose ENVSUB ON\n    -- +goose Up\n    SELECT * FROM regions WHERE name = '${REGION}';\n    ```\n\n- Add native [Turso](https://turso.tech/) support with libsql driver. (#658)\n\n- Fixed query for list migrations in YDB (#684)\n\n## [v3.17.0] - 2023-12-15\n\n- Standardised the MIT license (#647)\n- Improve provider `Apply()` errors, add `ErrNotApplied` when attempting to rollback a migration\n  that has not been previously applied. (#660)\n- Add `WithDisableGlobalRegistry` option to `NewProvider` to disable the global registry. (#645)\n- Add `-timeout` flag to CLI to set the maximum allowed duration for queries to run. Default remains\n  no timeout. (#627)\n- Add optional logging in `Provider` when `WithVerbose` option is supplied. (#668)\n\n⚠️ Potential Breaking Change ⚠️\n\n- Update `goose create` to use UTC time instead of local time. (#242)\n\n## [v3.16.0] - 2023-11-12\n\n- Added YDB support. (#592)\n- Fix sqlserver query to ensure DB version. (#601)\n- Allow setting / resetting the global Go migration registry. (#602)\n  - `SetGlobalMigrations` and `ResetGlobalMigrations` functions have been added.\n  - Introduce `NewGoMigration` for constructing Go migrations.\n- Add initial implementation of `goose.NewProvider`.\n\n🎉 Read more about this new feature here:\n\nhttps://pressly.github.io/goose/blog/2023/goose-provider/\n\nThe motivation behind the Provider was simple - to reduce global state and make goose easier to\nconsume as an imported package.\n\nHere's a quick summary:\n\n- Avoid global state\n- Make Provider safe to use concurrently\n- Unlock (no pun intended) new features, such as database locking\n- Make logging configurable\n- Better error handling with proper return values\n- Double down on Go migrations\n- ... and more!\n\n## [v3.15.1] - 2023-10-10\n\n- Fix regression that prevented registering Go migrations that didn't have the corresponding files\n  available in the filesystem. (#588)\n  - If Go migrations have been registered globally, but there are no .go files in the filesystem,\n    **always include** them.\n  - If Go migrations have been registered, and there are .go files in the filesystem, **only\n    include** those migrations. This was the original motivation behind #553.\n  - If there are .go files in the filesystem but not registered, **raise an error**. This is to\n    prevent accidentally adding valid looking Go migration files without explicitly registering\n    them.\n\n## [v3.15.0] - 2023-08-12\n\n- Fix `sqlparser` to avoid skipping the last statement when it's not terminated with a semicolon\n  within a StatementBegin/End block. (#580)\n- Add `go1.21` to the CI matrix.\n- Bump minimum version of module in go.mod to `go1.19`.\n- Fix version output when installing pre-built binaries (#585).\n\n## [v3.14.0] - 2023-07-26\n\n- Filter registered Go migrations from the global map with corresponding .go files from the\n  filesystem.\n  - The code previously assumed all .go migrations would be in the same folder, so this should not\n    be a breaking change.\n  - See #553 for more details\n- Improve output log message for applied up migrations. #562\n- Fix an issue where `AddMigrationNoTxContext` was registering the wrong source because it skipped\n  too many frames. #572\n- Improve binary version output when using go install.\n\n## [v3.13.4] - 2023-07-07\n\n- Fix pre-built binary versioning and make small improvements to GoReleaser config.\n- Fix an edge case in the `sqlparser` where the last up statement may be ignored if it's\n  unterminated with a semicolon and followed by a `-- +goose Down` annotation.\n- Trim `Logger` interface to `Printf` and `Fatalf` methods only. Projects that have previously\n  implemented the `Logger` interface should not be affected, and can remove unused methods.\n\n## [v3.13.1] - 2023-07-03\n\n- Add pre-built binaries with GoReleaser and update the build process.\n\n## [v3.13.0] - 2023-06-29\n\n- Add a changelog to the project, based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n- Update go.mod and retract all `v3.12.X` tags. They were accidentally pushed and contain a\n  reference to the wrong Go module.\n- Fix `up` and `up -allowing-missing` behavior.\n- Fix empty version in log output.\n- Add new `context.Context`-aware functions and methods, for both sql and go migrations.\n- Return error when no migration files found or dir is not a directory.\n\n[Unreleased]: https://github.com/pressly/goose/compare/v3.24.1...HEAD\n[v3.24.1]: https://github.com/pressly/goose/compare/v3.24.0...v3.24.1\n[v3.24.0]: https://github.com/pressly/goose/compare/v3.23.1...v3.24.0\n[v3.23.1]: https://github.com/pressly/goose/compare/v3.23.0...v3.23.1\n[v3.23.0]: https://github.com/pressly/goose/compare/v3.22.1...v3.23.0\n[v3.22.1]: https://github.com/pressly/goose/compare/v3.22.0...v3.22.1\n[v3.22.0]: https://github.com/pressly/goose/compare/v3.21.1...v3.22.0\n[v3.21.1]: https://github.com/pressly/goose/compare/v3.20.0...v3.21.1\n[v3.21.0]: https://github.com/pressly/goose/compare/v3.20.0...v3.21.0\n[v3.20.0]: https://github.com/pressly/goose/compare/v3.19.2...v3.20.0\n[v3.19.2]: https://github.com/pressly/goose/compare/v3.19.1...v3.19.2\n[v3.19.1]: https://github.com/pressly/goose/compare/v3.19.0...v3.19.1\n[v3.19.0]: https://github.com/pressly/goose/compare/v3.18.0...v3.19.0\n[v3.18.0]: https://github.com/pressly/goose/compare/v3.17.0...v3.18.0\n[v3.17.0]: https://github.com/pressly/goose/compare/v3.16.0...v3.17.0\n[v3.16.0]: https://github.com/pressly/goose/compare/v3.15.1...v3.16.0\n[v3.15.1]: https://github.com/pressly/goose/compare/v3.15.0...v3.15.1\n[v3.15.0]: https://github.com/pressly/goose/compare/v3.14.0...v3.15.0\n[v3.14.0]: https://github.com/pressly/goose/compare/v3.13.4...v3.14.0\n[v3.13.4]: https://github.com/pressly/goose/compare/v3.13.1...v3.13.4\n[v3.13.1]: https://github.com/pressly/goose/compare/v3.13.0...v3.13.1\n[v3.13.0]: https://github.com/pressly/goose/releases/tag/v3.13.0\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1689453125,
          "content": "MIT License\n\nOriginal work Copyright (c) 2012 Liam Staskawicz\nModified work Copyright (c) 2016 Vojtech Vitek\nModified work Copyright (c) 2021 Michael Fridman, Vojtech Vitek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.5810546875,
          "content": "GO_TEST_FLAGS ?= -race -count=1 -v -timeout=5m -json\n\n# These are the default values for the test database. They can be overridden\nDB_USER ?= dbuser\nDB_PASSWORD ?= password1\nDB_NAME ?= testdb\nDB_POSTGRES_PORT ?= 5433\nDB_MYSQL_PORT ?= 3307\nDB_CLICKHOUSE_PORT ?= 9001\nDB_YDB_PORT ?= 2136\nDB_TURSO_PORT ?= 8080\nDB_STARROCKS_PORT ?= 9030\n\nlist-build-tags:\n\t@echo \"Available build tags:\"\n\t@echo \"$$(rg -o --trim 'no_[a-zA-Z0-9_]+' ./cmd/goose \\\n\t\t--no-line-number --no-filename | sort | uniq | \\\n\t\txargs -n 4 | column -t | sed 's/^/  /')\"\n\n.PHONY: dist\ndist:\n\t@mkdir -p ./bin\n\t@rm -f ./bin/*\n\tGOOS=darwin  GOARCH=amd64 go build -o ./bin/goose-darwin64       ./cmd/goose\n\tGOOS=linux   GOARCH=amd64 go build -o ./bin/goose-linux64        ./cmd/goose\n\tGOOS=linux   GOARCH=386   go build -o ./bin/goose-linux386       ./cmd/goose\n\tGOOS=windows GOARCH=amd64 go build -o ./bin/goose-windows64.exe  ./cmd/goose\n\tGOOS=windows GOARCH=386   go build -o ./bin/goose-windows386.exe ./cmd/goose\n\n.PHONY: clean\nclean:\n\t@find . -type f -name '*.FAIL' -delete\n\n.PHONY: lint\nlint: tools\n\t@golangci-lint run ./... --fix\n\n.PHONY: tools\ntools:\n\t@go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\t@go install github.com/mfridman/tparse@main\n\ntest-packages:\n\tgo test $(GO_TEST_FLAGS) $$(go list ./... | grep -v -e /bin -e /cmd -e /examples) |\\\n\t\ttparse --follow -sort=elapsed -trimpath=auto -all\n\ntest-packages-short:\n\tgo test -test.short $(GO_TEST_FLAGS) $$(go list ./... | grep -v -e /bin -e /cmd -e /examples) |\\\n\t\ttparse --follow -sort=elapsed\n\ncoverage-short:\n\tgo test ./ -test.short $(GO_TEST_FLAGS) -cover -coverprofile=coverage.out | tparse --follow -sort=elapsed\n\tgo tool cover -html=coverage.out\n\ncoverage:\n\tgo test ./ $(GO_TEST_FLAGS) -cover -coverprofile=coverage.out | tparse --follow -sort=elapsed\n\tgo tool cover -html=coverage.out\n\n#\n# Integration-related targets\n#\nadd-gowork:\n\t@[ -f go.work ] || go work init\n\t@[ -f go.work.sum ] || go work use -r .\n\nremove-gowork:\n\trm -rf go.work go.work.sum\n\nupgrade-integration-deps:\n\tcd ./internal/testing && go get -u ./... && go mod tidy\n\ntest-postgres-long: add-gowork test-postgres\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='(TestPostgresProviderLocking|TestPostgresSessionLocker)' |\\\n\t\ttparse --follow -sort=elapsed\n\ntest-postgres: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run=\"^TestPostgres$$\" | tparse --follow -sort=elapsed\n\ntest-clickhouse: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='(TestClickhouse|TestClickhouseRemote)' |\\\n\t\ttparse --follow -sort=elapsed\n\ntest-mysql: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='TestMySQL' | tparse --follow -sort=elapsed\n\ntest-turso: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='TestTurso' | tparse --follow -sort=elapsed\n\ntest-vertica: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='TestVertica' | tparse --follow -sort=elapsed\n\ntest-ydb: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='TestYDB' | tparse --follow -sort=elapsed\n\ntest-starrocks: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration -run='TestStarrocks' | tparse --follow -sort=elapsed\n\ntest-integration: add-gowork\n\tgo test $(GO_TEST_FLAGS) ./internal/testing/integration/... | tparse --follow -sort=elapsed -trimpath=auto -all\n\n#\n# Docker-related targets\n#\n\ndocker-cleanup:\n\tdocker stop -t=0 $$(docker ps --filter=\"label=goose_test\" -aq)\n\ndocker-postgres:\n\tdocker run --rm -d \\\n\t\t-e POSTGRES_USER=$(DB_USER) \\\n\t\t-e POSTGRES_PASSWORD=$(DB_PASSWORD) \\\n\t\t-e POSTGRES_DB=$(DB_NAME) \\\n\t\t-p $(DB_POSTGRES_PORT):5432 \\\n\t\t-l goose_test \\\n\t\tpostgres:14-alpine -c log_statement=all\n\techo \"postgres://$(DB_USER):$(DB_PASSWORD)@localhost:$(DB_POSTGRES_PORT)/$(DB_NAME)?sslmode=disable\"\n\ndocker-mysql:\n\tdocker run --rm -d \\\n\t\t-e MYSQL_ROOT_PASSWORD=rootpassword1 \\\n\t\t-e MYSQL_DATABASE=$(DB_NAME) \\\n\t\t-e MYSQL_USER=$(DB_USER) \\\n\t\t-e MYSQL_PASSWORD=$(DB_PASSWORD) \\\n\t\t-p $(DB_MYSQL_PORT):3306 \\\n\t\t-l goose_test \\\n\t\tmysql:8.0.31\n\techo \"mysql://$(DB_USER):$(DB_PASSWORD)@localhost:$(DB_MYSQL_PORT)/$(DB_NAME)?parseTime=true\"\n\ndocker-clickhouse:\n\tdocker run --rm -d \\\n\t\t-e CLICKHOUSE_DB=$(DB_NAME) \\\n\t\t-e CLICKHOUSE_USER=$(DB_USER) \\\n\t\t-e CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT=1 \\\n\t\t-e CLICKHOUSE_PASSWORD=$(DB_PASSWORD) \\\n\t\t-p $(DB_CLICKHOUSE_PORT):9000/tcp \\\n\t\t-l goose_test \\\n\t\tclickhouse/clickhouse-server:23-alpine\n\techo \"clickhouse://$(DB_USER):$(DB_PASSWORD)@localhost:$(DB_CLICKHOUSE_PORT)/$(DB_NAME)\"\n\ndocker-turso:\n\tdocker run --rm -d \\\n\t\t-p $(DB_TURSO_PORT):8080 \\\n\t\t-l goose_test \\\n\t\tghcr.io/tursodatabase/libsql-server:v0.22.10\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.55078125,
          "content": "# goose\n\n<img align=\"right\" width=\"125\" src=\"assets/goose_logo.png\">\n\n[![Goose\nCI](https://github.com/pressly/goose/actions/workflows/ci.yaml/badge.svg)](https://github.com/pressly/goose/actions/workflows/ci.yaml)\n[![Go\nReference](https://pkg.go.dev/badge/github.com/pressly/goose/v3.svg)](https://pkg.go.dev/github.com/pressly/goose/v3)\n[![Go Report\nCard](https://goreportcard.com/badge/github.com/pressly/goose/v3)](https://goreportcard.com/report/github.com/pressly/goose/v3)\n\nGoose is a database migration tool. Both a CLI and a library.\n\nManage your **database schema** by creating incremental SQL changes or Go functions.\n\n#### Features\n\n- Works against multiple databases:\n  - Postgres, MySQL, SQLite, YDB, ClickHouse, MSSQL, Vertica, and\n    more.\n- Supports Go migrations written as plain functions.\n- Supports [embedded](https://pkg.go.dev/embed/) migrations.\n- Out-of-order migrations.\n- Seeding data.\n- Environment variable substitution in SQL migrations.\n- ... and more.\n\n# Install\n\n```shell\ngo install github.com/pressly/goose/v3/cmd/goose@latest\n```\n\nThis will install the `goose` binary to your `$GOPATH/bin` directory.\n\nBinary too big? Build a lite version by excluding the drivers you don't need:\n\n```shell\ngo build -tags='no_postgres no_mysql no_sqlite3 no_ydb' -o goose ./cmd/goose\n\n# Available build tags:\n#   no_clickhouse  no_libsql   no_mssql    no_mysql\n#   no_postgres    no_sqlite3  no_vertica  no_ydb\n```\n\nFor macOS users `goose` is available as a [Homebrew\nFormulae](https://formulae.brew.sh/formula/goose#default):\n\n```shell\nbrew install goose\n```\n\nSee [installation documentation](https://pressly.github.io/goose/installation/) for more details.\n\n# Usage\n\n<details>\n<summary>Click to show <code>goose help</code> output</summary>\n\n```\nUsage: goose [OPTIONS] DRIVER DBSTRING COMMAND\n\nor\n\nSet environment key\nGOOSE_DRIVER=DRIVER\nGOOSE_DBSTRING=DBSTRING\nGOOSE_MIGRATION_DIR=MIGRATION_DIR\n\nUsage: goose [OPTIONS] COMMAND\n\nDrivers:\n    postgres\n    mysql\n    sqlite3\n    mssql\n    redshift\n    tidb\n    clickhouse\n    vertica\n    ydb\n    starrocks\n\nExamples:\n    goose sqlite3 ./foo.db status\n    goose sqlite3 ./foo.db create init sql\n    goose sqlite3 ./foo.db create add_some_column sql\n    goose sqlite3 ./foo.db create fetch_user_data go\n    goose sqlite3 ./foo.db up\n\n    goose postgres \"user=postgres dbname=postgres sslmode=disable\" status\n    goose mysql \"user:password@/dbname?parseTime=true\" status\n    goose redshift \"postgres://user:password@qwerty.us-east-1.redshift.amazonaws.com:5439/db\" status\n    goose tidb \"user:password@/dbname?parseTime=true\" status\n    goose mssql \"sqlserver://user:password@hostname:1433?database=master\" status\n    goose clickhouse \"tcp://127.0.0.1:9000\" status\n    goose vertica \"vertica://user:password@localhost:5433/dbname?connection_load_balance=1\" status\n    goose ydb \"grpcs://localhost:2135/local?go_query_mode=scripting&go_fake_tx=scripting&go_query_bind=declare,numeric\" status\n    goose starrocks \"user:password@/dbname?parseTime=true&interpolateParams=true\" status\n\n    GOOSE_DRIVER=sqlite3 GOOSE_DBSTRING=./foo.db goose status\n    GOOSE_DRIVER=sqlite3 GOOSE_DBSTRING=./foo.db goose create init sql\n    GOOSE_DRIVER=postgres GOOSE_DBSTRING=\"user=postgres dbname=postgres sslmode=disable\" goose status\n    GOOSE_DRIVER=mysql GOOSE_DBSTRING=\"user:password@/dbname\" goose status\n    GOOSE_DRIVER=redshift GOOSE_DBSTRING=\"postgres://user:password@qwerty.us-east-1.redshift.amazonaws.com:5439/db\" goose status\n    GOOSE_DRIVER=clickhouse GOOSE_DBSTRING=\"clickhouse://user:password@qwerty.clickhouse.cloud:9440/dbname?secure=true&skip_verify=false\" goose status\n\nOptions:\n\n  -allow-missing\n        applies missing (out-of-order) migrations\n  -certfile string\n        file path to root CA's certificates in pem format (only support on mysql)\n  -dir string\n        directory with migration files (default \".\", can be set via the GOOSE_MIGRATION_DIR env variable).\n  -h    print help\n  -no-color\n        disable color output (NO_COLOR env variable supported)\n  -no-versioning\n        apply migration commands with no versioning, in file order, from directory pointed to\n  -s    use sequential numbering for new migrations\n  -ssl-cert string\n        file path to SSL certificates in pem format (only support on mysql)\n  -ssl-key string\n        file path to SSL key in pem format (only support on mysql)\n  -table string\n        migrations table name (default \"goose_db_version\")\n  -timeout duration\n        maximum allowed duration for queries to run; e.g., 1h13m\n  -v    enable verbose mode\n  -version\n        print version\n\nCommands:\n    up                   Migrate the DB to the most recent version available\n    up-by-one            Migrate the DB up by 1\n    up-to VERSION        Migrate the DB to a specific VERSION\n    down                 Roll back the version by 1\n    down-to VERSION      Roll back to a specific VERSION\n    redo                 Re-run the latest migration\n    reset                Roll back all migrations\n    status               Dump the migration status for the current DB\n    version              Print the current version of the database\n    create NAME [sql|go] Creates new migration file with the current timestamp\n    fix                  Apply sequential ordering to migrations\n    validate             Check migration files without running them\n```\n\n</details>\n\nCommonly used commands:\n\n[create](#create)<span>&nbsp;•&nbsp;</span> [up](#up)<span>&nbsp;•&nbsp;</span> [up-to](#up-to)<span>&nbsp;•&nbsp;</span> [down](#down)<span>&nbsp;•&nbsp;</span> [down-to](#down-to)<span>&nbsp;•&nbsp;</span> [status](#status)<span>&nbsp;•&nbsp;</span> [version](#version)\n\n## create\n\nCreate a new SQL migration.\n\n    $ goose create add_some_column sql\n    $ Created new file: 20170506082420_add_some_column.sql\n\n    $ goose -s create add_some_column sql\n    $ Created new file: 00001_add_some_column.sql\n\nEdit the newly created file to define the behavior of your migration.\n\nYou can also create a Go migration, if you then invoke it with [your own goose\nbinary](#go-migrations):\n\n    $ goose create fetch_user_data go\n    $ Created new file: 20170506082421_fetch_user_data.go\n\n## up\n\nApply all available migrations.\n\n    $ goose up\n    $ OK    001_basics.sql\n    $ OK    002_next.sql\n    $ OK    003_and_again.go\n\n## up-to\n\nMigrate up to a specific version.\n\n    $ goose up-to 20170506082420\n    $ OK    20170506082420_create_table.sql\n\n## up-by-one\n\nMigrate up a single migration from the current version\n\n    $ goose up-by-one\n    $ OK    20170614145246_change_type.sql\n\n## down\n\nRoll back a single migration from the current version.\n\n    $ goose down\n    $ OK    003_and_again.go\n\n## down-to\n\nRoll back migrations to a specific version.\n\n    $ goose down-to 20170506082527\n    $ OK    20170506082527_alter_column.sql\n\nOr, roll back all migrations (careful!):\n\n    $ goose down-to 0\n\n## status\n\nPrint the status of all migrations:\n\n    $ goose status\n    $   Applied At                  Migration\n    $   =======================================\n    $   Sun Jan  6 11:25:03 2013 -- 001_basics.sql\n    $   Sun Jan  6 11:25:03 2013 -- 002_next.sql\n    $   Pending                  -- 003_and_again.go\n\nNote: for MySQL [parseTime flag](https://github.com/go-sql-driver/mysql#parsetime) must be enabled.\n\nNote: for MySQL\n[`multiStatements`](https://github.com/go-sql-driver/mysql?tab=readme-ov-file#multistatements) must\nbe enabled. This is required when writing multiple queries separated by ';' characters in a single\nsql file.\n\n## version\n\nPrint the current version of the database:\n\n    $ goose version\n    $ goose: version 002\n\n# Environment Variables\n\nIf you prefer to use environment variables, instead of passing the driver and database string as\narguments, you can set the following environment variables:\n\n**1. Via environment variables:**\n\n```shell\nexport GOOSE_DRIVER=DRIVER\nexport GOOSE_DBSTRING=DBSTRING\nexport GOOSE_MIGRATION_DIR=MIGRATION_DIR\n```\n\n**2. Via `.env` files with corresponding variables. `.env` file example**:\n\n```env\nGOOSE_DRIVER=postgres\nGOOSE_DBSTRING=postgres://admin:admin@localhost:5432/admin_db\nGOOSE_MIGRATION_DIR=./migrations\n```\n\nLoading from `.env` files is enabled by default. To disable this feature, set the `-env=none` flag.\nIf you want to load from a specific file, set the `-env` flag to the file path.\n\nFor more details about environment variables, see the [official documentation on environment\nvariables](https://pressly.github.io/goose/documentation/environment-variables/).\n\n# Migrations\n\ngoose supports migrations written in SQL or in Go.\n\n## SQL Migrations\n\nA sample SQL migration looks like:\n\n```sql\n-- +goose Up\nCREATE TABLE post (\n    id int NOT NULL,\n    title text,\n    body text,\n    PRIMARY KEY(id)\n);\n\n-- +goose Down\nDROP TABLE post;\n```\n\nEach migration file must have exactly one `-- +goose Up` annotation. The `-- +goose Down` annotation\nis optional. If the file has both annotations, then the `-- +goose Up` annotation **must** come\nfirst.\n\nNotice the annotations in the comments. Any statements following `-- +goose Up` will be executed as\npart of a forward migration, and any statements following `-- +goose Down` will be executed as part\nof a rollback.\n\nBy default, all migrations are run within a transaction. Some statements like `CREATE DATABASE`,\nhowever, cannot be run within a transaction. You may optionally add `-- +goose NO TRANSACTION` to\nthe top of your migration file in order to skip transactions within that specific migration file.\nBoth Up and Down migrations within this file will be run without transactions.\n\nBy default, SQL statements are delimited by semicolons - in fact, query statements must end with a\nsemicolon to be properly recognized by goose.\n\nMore complex statements (PL/pgSQL) that have semicolons within them must be annotated with `--\n+goose StatementBegin` and `-- +goose StatementEnd` to be properly recognized. For example:\n\n```sql\n-- +goose Up\n-- +goose StatementBegin\nCREATE OR REPLACE FUNCTION histories_partition_creation( DATE, DATE )\nreturns void AS $$\nDECLARE\n  create_query text;\nBEGIN\n  FOR create_query IN SELECT\n      'CREATE TABLE IF NOT EXISTS histories_'\n      || TO_CHAR( d, 'YYYY_MM' )\n      || ' ( CHECK( created_at >= timestamp '''\n      || TO_CHAR( d, 'YYYY-MM-DD 00:00:00' )\n      || ''' AND created_at < timestamp '''\n      || TO_CHAR( d + INTERVAL '1 month', 'YYYY-MM-DD 00:00:00' )\n      || ''' ) ) inherits ( histories );'\n    FROM generate_series( $1, $2, '1 month' ) AS d\n  LOOP\n    EXECUTE create_query;\n  END LOOP;  -- LOOP END\nEND;         -- FUNCTION END\n$$\nlanguage plpgsql;\n-- +goose StatementEnd\n```\n\nGoose supports environment variable substitution in SQL migrations through annotations. To enable\nthis feature, use the `-- +goose ENVSUB ON` annotation before the queries where you want\nsubstitution applied. It stays active until the `-- +goose ENVSUB OFF` annotation is encountered.\nYou can use these annotations multiple times within a file.\n\nThis feature is disabled by default for backward compatibility with existing scripts.\n\nFor `PL/pgSQL` functions or other statements where substitution is not desired, wrap the annotations\nexplicitly around the relevant parts. For example, to exclude escaping the `**` characters:\n\n```sql\n-- +goose StatementBegin\nCREATE OR REPLACE FUNCTION test_func()\nRETURNS void AS $$\n-- +goose ENVSUB ON\nBEGIN\n\tRAISE NOTICE '${SOME_ENV_VAR}';\nEND;\n-- +goose ENVSUB OFF\n$$ LANGUAGE plpgsql;\n-- +goose StatementEnd\n```\n\n<details>\n<summary>Supported expansions (click here to expand):</summary>\n\n- `${VAR}` or $VAR - expands to the value of the environment variable `VAR`\n- `${VAR:-default}` - expands to the value of the environment variable `VAR`, or `default` if `VAR`\n  is unset or null\n- `${VAR-default}` - expands to the value of the environment variable `VAR`, or `default` if `VAR`\n  is unset\n- `${VAR?err_msg}` - expands to the value of the environment variable `VAR`, or prints `err_msg` and\n  error if `VAR` unset\n- ~~`${VAR:?err_msg}` - expands to the value of the environment variable `VAR`, or prints `err_msg`\n  and error if `VAR` unset or null.~~ **THIS IS NOT SUPPORTED**\n\nSee\n[mfridman/interpolate](https://github.com/mfridman/interpolate?tab=readme-ov-file#supported-expansions)\nfor more details on supported expansions.\n\n</details>\n\n## Embedded sql migrations\n\nGo 1.16 introduced new feature: [compile-time embedding](https://pkg.go.dev/embed/) files into\nbinary and corresponding [filesystem abstraction](https://pkg.go.dev/io/fs/).\n\nThis feature can be used only for applying existing migrations. Modifying operations such as `fix`\nand `create` will continue to operate on OS filesystem even if using embedded files. This is\nexpected behaviour because `io/fs` interfaces allows read-only access.\n\nMake sure to configure the correct SQL dialect, see [dialect.go](./dialect.go) for supported SQL\ndialects.\n\nExample usage, assuming that SQL migrations are placed in the `migrations` directory:\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"embed\"\n\n    \"github.com/pressly/goose/v3\"\n)\n\n//go:embed migrations/*.sql\nvar embedMigrations embed.FS\n\nfunc main() {\n    var db *sql.DB\n    // setup database\n\n    goose.SetBaseFS(embedMigrations)\n\n    if err := goose.SetDialect(\"postgres\"); err != nil {\n        panic(err)\n    }\n\n    if err := goose.Up(db, \"migrations\"); err != nil {\n        panic(err)\n    }\n\n    // run app\n}\n```\n\nNote that we pass `\"migrations\"` as directory argument in `Up` because embedding saves directory\nstructure.\n\n## Go Migrations\n\n1. Create your own goose binary, see [example](./examples/go-migrations)\n2. Import `github.com/pressly/goose`\n3. Register your migration functions\n4. Run goose command, ie. `goose.Up(db *sql.DB, dir string)`\n\nA [sample Go migration 00002_users_add_email.go file](./examples/go-migrations/00002_rename_root.go)\nlooks like:\n\n```go\npackage migrations\n\nimport (\n\t\"database/sql\"\n\n\t\"github.com/pressly/goose/v3\"\n)\n\nfunc init() {\n\tgoose.AddMigration(Up, Down)\n}\n\nfunc Up(tx *sql.Tx) error {\n\t_, err := tx.Exec(\"UPDATE users SET username='admin' WHERE username='root';\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc Down(tx *sql.Tx) error {\n\t_, err := tx.Exec(\"UPDATE users SET username='root' WHERE username='admin';\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```\n\nNote that Go migration files must begin with a numeric value, followed by an underscore, and must\nnot end with `*_test.go`.\n\n# Hybrid Versioning\n\nPlease, read the [versioning\nproblem](https://github.com/pressly/goose/issues/63#issuecomment-428681694) first.\n\nBy default, if you attempt to apply missing (out-of-order) migrations `goose` will raise an error.\nHowever, If you want to apply these missing migrations pass goose the `-allow-missing` flag, or if\nusing as a library supply the functional option `goose.WithAllowMissing()` to Up, UpTo or UpByOne.\n\nHowever, we strongly recommend adopting a hybrid versioning approach, using both timestamps and\nsequential numbers. Migrations created during the development process are timestamped and sequential\nversions are ran on production. We believe this method will prevent the problem of conflicting\nversions when writing software in a team environment.\n\nTo help you adopt this approach, `create` will use the current timestamp as the migration version.\nWhen you're ready to deploy your migrations in a production environment, we also provide a helpful\n`fix` command to convert your migrations into sequential order, while preserving the timestamp\nordering. We recommend running `fix` in the CI pipeline, and only when the migrations are ready for\nproduction.\n\n## Credit\n\nThe gopher mascot was designed by [Renée French](https://reneefrench.blogspot.com/) / [CC\n3.0.](https://creativecommons.org/licenses/by/3.0/) For more info check out the [Go\nBlog](https://go.dev/blog/gopher). Adapted by Ellen.\n\n## License\n\nLicensed under [MIT License](./LICENSE)\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "create.go",
          "type": "blob",
          "size": 2.720703125,
          "content": "package goose\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"text/template\"\n\t\"time\"\n)\n\ntype tmplVars struct {\n\tVersion   string\n\tCamelName string\n}\n\nvar (\n\tsequential = false\n)\n\n// SetSequential set whether to use sequential versioning instead of timestamp based versioning\nfunc SetSequential(s bool) {\n\tsequential = s\n}\n\n// Create writes a new blank migration file.\nfunc CreateWithTemplate(db *sql.DB, dir string, tmpl *template.Template, name, migrationType string) error {\n\tversion := time.Now().UTC().Format(timestampFormat)\n\n\tif sequential {\n\t\t// always use DirFS here because it's modifying operation\n\t\tmigrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion, registeredGoMigrations)\n\t\tif err != nil && !errors.Is(err, ErrNoMigrationFiles) {\n\t\t\treturn err\n\t\t}\n\n\t\tvMigrations, err := migrations.versioned()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif last, err := vMigrations.Last(); err == nil {\n\t\t\tversion = fmt.Sprintf(seqVersionTemplate, last.Version+1)\n\t\t} else {\n\t\t\tversion = fmt.Sprintf(seqVersionTemplate, int64(1))\n\t\t}\n\t}\n\n\tfilename := fmt.Sprintf(\"%v_%v.%v\", version, snakeCase(name), migrationType)\n\n\tif tmpl == nil {\n\t\tif migrationType == \"go\" {\n\t\t\ttmpl = goSQLMigrationTemplate\n\t\t} else {\n\t\t\ttmpl = sqlMigrationTemplate\n\t\t}\n\t}\n\n\tpath := filepath.Join(dir, filename)\n\tif _, err := os.Stat(path); !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"failed to create migration file: %w\", err)\n\t}\n\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create migration file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tvars := tmplVars{\n\t\tVersion:   version,\n\t\tCamelName: camelCase(name),\n\t}\n\tif err := tmpl.Execute(f, vars); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute tmpl: %w\", err)\n\t}\n\n\tlog.Printf(\"Created new file: %s\\n\", f.Name())\n\treturn nil\n}\n\n// Create writes a new blank migration file.\nfunc Create(db *sql.DB, dir, name, migrationType string) error {\n\treturn CreateWithTemplate(db, dir, nil, name, migrationType)\n}\n\nvar sqlMigrationTemplate = template.Must(template.New(\"goose.sql-migration\").Parse(`-- +goose Up\n-- +goose StatementBegin\nSELECT 'up SQL query';\n-- +goose StatementEnd\n\n-- +goose Down\n-- +goose StatementBegin\nSELECT 'down SQL query';\n-- +goose StatementEnd\n`))\n\nvar goSQLMigrationTemplate = template.Must(template.New(\"goose.go-migration\").Parse(`package migrations\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"github.com/pressly/goose/v3\"\n)\n\nfunc init() {\n\tgoose.AddMigrationContext(up{{.CamelName}}, down{{.CamelName}})\n}\n\nfunc up{{.CamelName}}(ctx context.Context, tx *sql.Tx) error {\n\t// This code is executed when the migration is applied.\n\treturn nil\n}\n\nfunc down{{.CamelName}}(ctx context.Context, tx *sql.Tx) error {\n\t// This code is executed when the migration is rolled back.\n\treturn nil\n}\n`))\n"
        },
        {
          "name": "create_test.go",
          "type": "blob",
          "size": 1.1611328125,
          "content": "package goose\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSequential(t *testing.T) {\n\tt.Parallel()\n\tif testing.Short() {\n\t\tt.Skip(\"skip long running test\")\n\t}\n\n\tdir := t.TempDir()\n\tdefer os.Remove(\"./bin/create-goose\") // clean up\n\n\tcommands := []string{\n\t\t\"go build -o ./bin/create-goose ./cmd/goose\",\n\t\tfmt.Sprintf(\"./bin/create-goose -s -dir=%s create create_table\", dir),\n\t\tfmt.Sprintf(\"./bin/create-goose -s -dir=%s create add_users\", dir),\n\t\tfmt.Sprintf(\"./bin/create-goose -s -dir=%s create add_indices\", dir),\n\t\tfmt.Sprintf(\"./bin/create-goose -s -dir=%s create update_users\", dir),\n\t}\n\n\tfor _, cmd := range commands {\n\t\targs := strings.Split(cmd, \" \")\n\t\ttime.Sleep(1 * time.Second)\n\t\tcmd := exec.Command(args[0], args[1:]...)\n\t\tcmd.Env = os.Environ()\n\t\tout, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s:\\n%v\\n\\n%s\", err, cmd, out)\n\t\t}\n\t}\n\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check that the files are in order\n\tfor i, f := range files {\n\t\texpected := fmt.Sprintf(\"%05v\", i+1)\n\t\tif !strings.HasPrefix(f.Name(), expected) {\n\t\t\tt.Errorf(\"failed to find %s prefix in %s\", expected, f.Name())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "database",
          "type": "tree",
          "content": null
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 1.544921875,
          "content": "package goose\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// OpenDBWithDriver creates a connection to a database, and modifies goose internals to be\n// compatible with the supplied driver by calling SetDialect.\nfunc OpenDBWithDriver(driver string, dbstring string) (*sql.DB, error) {\n\tif err := SetDialect(driver); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The Go ecosystem has added more and more drivers over the years. As a result, there's no\n\t// longer a one-to-one match between the driver name and the dialect name. For instance, there's\n\t// no \"redshift\" driver, but that's the internal dialect name within goose. Hence, we need to\n\t// convert the dialect name to a supported driver name. This conversion is a best-effort\n\t// attempt, as we can't support both lib/pq and pgx, which some users might have.\n\t//\n\t// We recommend users to create a [NewProvider] with the desired dialect, open a connection\n\t// using their preferred driver, and provide the *sql.DB to goose. This approach removes the\n\t// need for mapping dialects to drivers, rendering this function unnecessary.\n\n\tswitch driver {\n\tcase \"mssql\":\n\t\tdriver = \"sqlserver\"\n\tcase \"tidb\":\n\t\tdriver = \"mysql\"\n\tcase \"turso\":\n\t\tdriver = \"libsql\"\n\tcase \"sqlite3\":\n\t\tdriver = \"sqlite\"\n\tcase \"postgres\", \"redshift\":\n\t\tdriver = \"pgx\"\n\tcase \"starrocks\":\n\t\tdriver = \"mysql\"\n\t}\n\n\tswitch driver {\n\tcase \"postgres\", \"pgx\", \"sqlite3\", \"sqlite\", \"mysql\", \"sqlserver\", \"clickhouse\", \"vertica\", \"azuresql\", \"ydb\", \"libsql\", \"starrocks\":\n\t\treturn sql.Open(driver, dbstring)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported driver %s\", driver)\n\t}\n}\n"
        },
        {
          "name": "dialect.go",
          "type": "blob",
          "size": 1.54296875,
          "content": "package goose\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/pressly/goose/v3/internal/dialect\"\n)\n\n// Dialect is the type of database dialect. It is an alias for [database.Dialect].\ntype Dialect = database.Dialect\n\nconst (\n\tDialectClickHouse Dialect = database.DialectClickHouse\n\tDialectMSSQL      Dialect = database.DialectMSSQL\n\tDialectMySQL      Dialect = database.DialectMySQL\n\tDialectPostgres   Dialect = database.DialectPostgres\n\tDialectRedshift   Dialect = database.DialectRedshift\n\tDialectSQLite3    Dialect = database.DialectSQLite3\n\tDialectTiDB       Dialect = database.DialectTiDB\n\tDialectVertica    Dialect = database.DialectVertica\n\tDialectYdB        Dialect = database.DialectYdB\n\tDialectStarrocks  Dialect = database.DialectStarrocks\n)\n\nfunc init() {\n\tstore, _ = dialect.NewStore(dialect.Postgres)\n}\n\nvar store dialect.Store\n\n// SetDialect sets the dialect to use for the goose package.\nfunc SetDialect(s string) error {\n\tvar d dialect.Dialect\n\tswitch s {\n\tcase \"postgres\", \"pgx\":\n\t\td = dialect.Postgres\n\tcase \"mysql\":\n\t\td = dialect.Mysql\n\tcase \"sqlite3\", \"sqlite\":\n\t\td = dialect.Sqlite3\n\tcase \"mssql\", \"azuresql\", \"sqlserver\":\n\t\td = dialect.Sqlserver\n\tcase \"redshift\":\n\t\td = dialect.Redshift\n\tcase \"tidb\":\n\t\td = dialect.Tidb\n\tcase \"clickhouse\":\n\t\td = dialect.Clickhouse\n\tcase \"vertica\":\n\t\td = dialect.Vertica\n\tcase \"ydb\":\n\t\td = dialect.Ydb\n\tcase \"turso\":\n\t\td = dialect.Turso\n\tcase \"starrocks\":\n\t\td = dialect.Starrocks\n\tdefault:\n\t\treturn fmt.Errorf(\"%q: unknown dialect\", s)\n\t}\n\tvar err error\n\tstore, err = dialect.NewStore(d)\n\treturn err\n}\n"
        },
        {
          "name": "down.go",
          "type": "blob",
          "size": 2.8701171875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Down rolls back a single migration from the current version.\nfunc Down(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn DownContext(ctx, db, dir, opts...)\n}\n\n// DownContext rolls back a single migration from the current version.\nfunc DownContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif option.noVersioning {\n\t\tif len(migrations) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tcurrentVersion := migrations[len(migrations)-1].Version\n\t\t// Migrate only the latest migration down.\n\t\treturn downToNoVersioning(ctx, db, migrations, currentVersion-1)\n\t}\n\tcurrentVersion, err := GetDBVersionContext(ctx, db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcurrent, err := migrations.Current(currentVersion)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"migration %v: %w\", currentVersion, err)\n\t}\n\treturn current.DownContext(ctx, db)\n}\n\n// DownTo rolls back migrations to a specific version.\nfunc DownTo(db *sql.DB, dir string, version int64, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn DownToContext(ctx, db, dir, version, opts...)\n}\n\n// DownToContext rolls back migrations to a specific version.\nfunc DownToContext(ctx context.Context, db *sql.DB, dir string, version int64, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif option.noVersioning {\n\t\treturn downToNoVersioning(ctx, db, migrations, version)\n\t}\n\n\tfor {\n\t\tcurrentVersion, err := GetDBVersionContext(ctx, db)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif currentVersion == 0 {\n\t\t\tlog.Printf(\"goose: no migrations to run. current version: %d\\n\", currentVersion)\n\t\t\treturn nil\n\t\t}\n\t\tcurrent, err := migrations.Current(currentVersion)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"goose: migration file not found for current version (%d), error: %s\\n\", currentVersion, err)\n\t\t\treturn err\n\t\t}\n\n\t\tif current.Version <= version {\n\t\t\tlog.Printf(\"goose: no migrations to run. current version: %d\\n\", currentVersion)\n\t\t\treturn nil\n\t\t}\n\n\t\tif err = current.DownContext(ctx, db); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// downToNoVersioning applies down migrations down to, but not including, the\n// target version.\nfunc downToNoVersioning(ctx context.Context, db *sql.DB, migrations Migrations, version int64) error {\n\tvar finalVersion int64\n\tfor i := len(migrations) - 1; i >= 0; i-- {\n\t\tif version >= migrations[i].Version {\n\t\t\tfinalVersion = migrations[i].Version\n\t\t\tbreak\n\t\t}\n\t\tmigrations[i].noVersioning = true\n\t\tif err := migrations[i].DownContext(ctx, db); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tlog.Printf(\"goose: down to current file version: %d\\n\", finalVersion)\n\treturn nil\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fix.go",
          "type": "blob",
          "size": 1.078125,
          "content": "package goose\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst seqVersionTemplate = \"%05v\"\n\nfunc Fix(dir string) error {\n\t// always use osFS here because it's modifying operation\n\tmigrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion, registeredGoMigrations)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// split into timestamped and versioned migrations\n\ttsMigrations, err := migrations.timestamped()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvMigrations, err := migrations.versioned()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Initial version.\n\tversion := int64(1)\n\tif last, err := vMigrations.Last(); err == nil {\n\t\tversion = last.Version + 1\n\t}\n\n\t// fix filenames by replacing timestamps with sequential versions\n\tfor _, tsm := range tsMigrations {\n\t\toldPath := tsm.Source\n\t\tnewPath := strings.Replace(\n\t\t\toldPath,\n\t\t\tfmt.Sprintf(\"%d\", tsm.Version),\n\t\t\tfmt.Sprintf(seqVersionTemplate, version),\n\t\t\t1,\n\t\t)\n\n\t\tif err := os.Rename(oldPath, newPath); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog.Printf(\"RENAMED %s => %s\", filepath.Base(oldPath), filepath.Base(newPath))\n\t\tversion++\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "fix_test.go",
          "type": "blob",
          "size": 1.9384765625,
          "content": "package goose\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestFix(t *testing.T) {\n\tt.Parallel()\n\tif testing.Short() {\n\t\tt.Skip(\"skip long running test\")\n\t}\n\n\tdir := t.TempDir()\n\tdefer os.Remove(\"./bin/fix-goose\") // clean up\n\n\tcommands := []string{\n\t\t\"go build -o ./bin/fix-goose ./cmd/goose\",\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create create_table\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create add_users\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create add_indices\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create update_users\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s fix\", dir),\n\t}\n\n\tfor _, cmd := range commands {\n\t\targs := strings.Split(cmd, \" \")\n\t\ttime.Sleep(1 * time.Second)\n\t\tcmd := exec.Command(args[0], args[1:]...)\n\t\tcmd.Env = os.Environ()\n\t\tout, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s:\\n%v\\n\\n%s\", err, cmd, out)\n\t\t}\n\t}\n\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check that the files are in order\n\tfor i, f := range files {\n\t\texpected := fmt.Sprintf(\"%05v\", i+1)\n\t\tif !strings.HasPrefix(f.Name(), expected) {\n\t\t\tt.Errorf(\"failed to find %s prefix in %s\", expected, f.Name())\n\t\t}\n\t}\n\n\t// add more migrations and then fix it\n\tcommands = []string{\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create remove_column\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s create create_books_table\", dir),\n\t\tfmt.Sprintf(\"./bin/fix-goose -dir=%s fix\", dir),\n\t}\n\n\tfor _, cmd := range commands {\n\t\targs := strings.Split(cmd, \" \")\n\t\ttime.Sleep(1 * time.Second)\n\t\tout, err := exec.Command(args[0], args[1:]...).CombinedOutput()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s:\\n%v\\n\\n%s\", err, cmd, out)\n\t\t}\n\t}\n\n\tfiles, err = os.ReadDir(dir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check that the files still in order\n\tfor i, f := range files {\n\t\texpected := fmt.Sprintf(\"%05v\", i+1)\n\t\tif !strings.HasPrefix(f.Name(), expected) {\n\t\t\tt.Errorf(\"failed to find %s prefix in %s\", expected, f.Name())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "globals.go",
          "type": "blob",
          "size": 3.2451171875,
          "content": "package goose\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nvar (\n\tregisteredGoMigrations = make(map[int64]*Migration)\n)\n\n// ResetGlobalMigrations resets the global Go migrations registry.\n//\n// Not safe for concurrent use.\nfunc ResetGlobalMigrations() {\n\tregisteredGoMigrations = make(map[int64]*Migration)\n}\n\n// SetGlobalMigrations registers Go migrations globally. It returns an error if a migration with the\n// same version has already been registered. Go migrations must be constructed using the\n// [NewGoMigration] function.\n//\n// Not safe for concurrent use.\nfunc SetGlobalMigrations(migrations ...*Migration) error {\n\tfor _, m := range migrations {\n\t\tif _, ok := registeredGoMigrations[m.Version]; ok {\n\t\t\treturn fmt.Errorf(\"go migration with version %d already registered\", m.Version)\n\t\t}\n\t\tif err := checkGoMigration(m); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid go migration: %w\", err)\n\t\t}\n\t\tregisteredGoMigrations[m.Version] = m\n\t}\n\treturn nil\n}\n\nfunc checkGoMigration(m *Migration) error {\n\tif !m.construct {\n\t\treturn errors.New(\"must use NewGoMigration to construct migrations\")\n\t}\n\tif !m.Registered {\n\t\treturn errors.New(\"must be registered\")\n\t}\n\tif m.Type != TypeGo {\n\t\treturn fmt.Errorf(\"type must be %q\", TypeGo)\n\t}\n\tif m.Version < 1 {\n\t\treturn errors.New(\"version must be greater than zero\")\n\t}\n\tif m.Source != \"\" {\n\t\tif filepath.Ext(m.Source) != \".go\" {\n\t\t\treturn fmt.Errorf(\"source must have .go extension: %q\", m.Source)\n\t\t}\n\t\t// If the source is set, expect it to be a path with a numeric component that matches the\n\t\t// version. This field is not intended to be used for descriptive purposes.\n\t\tversion, err := NumericComponent(m.Source)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid source: %w\", err)\n\t\t}\n\t\tif version != m.Version {\n\t\t\treturn fmt.Errorf(\"version:%d does not match numeric component in source %q\", m.Version, m.Source)\n\t\t}\n\t}\n\tif err := checkGoFunc(m.goUp); err != nil {\n\t\treturn fmt.Errorf(\"up function: %w\", err)\n\t}\n\tif err := checkGoFunc(m.goDown); err != nil {\n\t\treturn fmt.Errorf(\"down function: %w\", err)\n\t}\n\tif m.UpFnContext != nil && m.UpFnNoTxContext != nil {\n\t\treturn errors.New(\"must specify exactly one of UpFnContext or UpFnNoTxContext\")\n\t}\n\tif m.UpFn != nil && m.UpFnNoTx != nil {\n\t\treturn errors.New(\"must specify exactly one of UpFn or UpFnNoTx\")\n\t}\n\tif m.DownFnContext != nil && m.DownFnNoTxContext != nil {\n\t\treturn errors.New(\"must specify exactly one of DownFnContext or DownFnNoTxContext\")\n\t}\n\tif m.DownFn != nil && m.DownFnNoTx != nil {\n\t\treturn errors.New(\"must specify exactly one of DownFn or DownFnNoTx\")\n\t}\n\treturn nil\n}\n\nfunc checkGoFunc(f *GoFunc) error {\n\tif f.RunTx != nil && f.RunDB != nil {\n\t\treturn errors.New(\"must specify exactly one of RunTx or RunDB\")\n\t}\n\tswitch f.Mode {\n\tcase TransactionEnabled, TransactionDisabled:\n\t\t// No functions, but mode is set. This is not an error. It means the user wants to\n\t\t// record a version with the given mode but not run any functions.\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid mode: %d\", f.Mode)\n\t}\n\tif f.RunDB != nil && f.Mode != TransactionDisabled {\n\t\treturn fmt.Errorf(\"transaction mode must be disabled or unspecified when RunDB is set\")\n\t}\n\tif f.RunTx != nil && f.Mode != TransactionEnabled {\n\t\treturn fmt.Errorf(\"transaction mode must be enabled or unspecified when RunTx is set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "globals_test.go",
          "type": "blob",
          "size": 11.2216796875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewGoMigration(t *testing.T) {\n\tt.Run(\"valid_both_nil\", func(t *testing.T) {\n\t\tm := NewGoMigration(1, nil, nil)\n\t\t// roundtrip\n\t\trequire.EqualValues(t, 1, m.Version)\n\t\trequire.Equal(t, TypeGo, m.Type)\n\t\trequire.True(t, m.Registered)\n\t\trequire.EqualValues(t, -1, m.Next)\n\t\trequire.EqualValues(t, -1, m.Previous)\n\t\trequire.Equal(t, \"\", m.Source)\n\t\trequire.Nil(t, m.UpFnNoTxContext)\n\t\trequire.Nil(t, m.DownFnNoTxContext)\n\t\trequire.Nil(t, m.UpFnContext)\n\t\trequire.Nil(t, m.DownFnContext)\n\t\trequire.Nil(t, m.UpFn)\n\t\trequire.Nil(t, m.DownFn)\n\t\trequire.Nil(t, m.UpFnNoTx)\n\t\trequire.Nil(t, m.DownFnNoTx)\n\t\trequire.NotNil(t, m.goUp)\n\t\trequire.NotNil(t, m.goDown)\n\t\trequire.Equal(t, TransactionEnabled, m.goUp.Mode)\n\t\trequire.Equal(t, TransactionEnabled, m.goDown.Mode)\n\t})\n\tt.Run(\"all_set\", func(t *testing.T) {\n\t\t// This will eventually be an error when registering migrations.\n\t\tm := NewGoMigration(\n\t\t\t1,\n\t\t\t&GoFunc{RunTx: func(context.Context, *sql.Tx) error { return nil }, RunDB: func(context.Context, *sql.DB) error { return nil }},\n\t\t\t&GoFunc{RunTx: func(context.Context, *sql.Tx) error { return nil }, RunDB: func(context.Context, *sql.DB) error { return nil }},\n\t\t)\n\t\t// check only functions\n\t\trequire.NotNil(t, m.UpFn)\n\t\trequire.NotNil(t, m.UpFnContext)\n\t\trequire.NotNil(t, m.UpFnNoTx)\n\t\trequire.NotNil(t, m.UpFnNoTxContext)\n\t\trequire.NotNil(t, m.DownFn)\n\t\trequire.NotNil(t, m.DownFnContext)\n\t\trequire.NotNil(t, m.DownFnNoTx)\n\t\trequire.NotNil(t, m.DownFnNoTxContext)\n\t})\n}\n\nfunc TestTransactionMode(t *testing.T) {\n\tt.Cleanup(ResetGlobalMigrations)\n\n\trunDB := func(context.Context, *sql.DB) error { return nil }\n\trunTx := func(context.Context, *sql.Tx) error { return nil }\n\n\terr := SetGlobalMigrations(\n\t\tNewGoMigration(1, &GoFunc{RunTx: runTx, RunDB: runDB}, nil), // cannot specify both\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"up function: must specify exactly one of RunTx or RunDB\")\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, nil, &GoFunc{RunTx: runTx, RunDB: runDB}), // cannot specify both\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"down function: must specify exactly one of RunTx or RunDB\")\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, &GoFunc{RunTx: runTx, Mode: TransactionDisabled}, nil), // invalid explicit mode tx\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"up function: transaction mode must be enabled or unspecified when RunTx is set\")\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, nil, &GoFunc{RunTx: runTx, Mode: TransactionDisabled}), // invalid explicit mode tx\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"down function: transaction mode must be enabled or unspecified when RunTx is set\")\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, &GoFunc{RunDB: runDB, Mode: TransactionEnabled}, nil), // invalid explicit mode no-tx\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"up function: transaction mode must be disabled or unspecified when RunDB is set\")\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, nil, &GoFunc{RunDB: runDB, Mode: TransactionEnabled}), // invalid explicit mode no-tx\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"down function: transaction mode must be disabled or unspecified when RunDB is set\")\n\n\tt.Run(\"default_mode\", func(t *testing.T) {\n\t\tt.Cleanup(ResetGlobalMigrations)\n\n\t\tm := NewGoMigration(1, nil, nil)\n\t\terr = SetGlobalMigrations(m)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, registeredGoMigrations, 1)\n\t\tregistered := registeredGoMigrations[1]\n\t\trequire.NotNil(t, registered.goUp)\n\t\trequire.NotNil(t, registered.goDown)\n\t\trequire.Equal(t, TransactionEnabled, registered.goUp.Mode)\n\t\trequire.Equal(t, TransactionEnabled, registered.goDown.Mode)\n\n\t\tmigration2 := NewGoMigration(2, nil, nil)\n\t\t// reset so we can check the default is set\n\t\tmigration2.goUp.Mode, migration2.goDown.Mode = 0, 0\n\t\terr = SetGlobalMigrations(migration2)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"invalid go migration: up function: invalid mode: 0\")\n\n\t\tmigration3 := NewGoMigration(3, nil, nil)\n\t\t// reset so we can check the default is set\n\t\tmigration3.goDown.Mode = 0\n\t\terr = SetGlobalMigrations(migration3)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"invalid go migration: down function: invalid mode: 0\")\n\t})\n\tt.Run(\"unknown_mode\", func(t *testing.T) {\n\t\tm := NewGoMigration(1, nil, nil)\n\t\tm.goUp.Mode, m.goDown.Mode = 3, 3 // reset to default\n\t\terr := SetGlobalMigrations(m)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"invalid mode: 3\")\n\t})\n}\n\nfunc TestLegacyFunctions(t *testing.T) {\n\tt.Cleanup(ResetGlobalMigrations)\n\n\trunDB := func(context.Context, *sql.DB) error { return nil }\n\trunTx := func(context.Context, *sql.Tx) error { return nil }\n\n\tassertMigration := func(t *testing.T, m *Migration, version int64) {\n\t\tt.Helper()\n\t\trequire.Equal(t, version, m.Version)\n\t\trequire.Equal(t, TypeGo, m.Type)\n\t\trequire.True(t, m.Registered)\n\t\trequire.EqualValues(t, -1, m.Next)\n\t\trequire.EqualValues(t, -1, m.Previous)\n\t\trequire.Equal(t, \"\", m.Source)\n\t}\n\n\tt.Run(\"all_tx\", func(t *testing.T) {\n\t\tt.Cleanup(ResetGlobalMigrations)\n\t\terr := SetGlobalMigrations(\n\t\t\tNewGoMigration(1, &GoFunc{RunTx: runTx}, &GoFunc{RunTx: runTx}),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, registeredGoMigrations, 1)\n\t\tm := registeredGoMigrations[1]\n\t\tassertMigration(t, m, 1)\n\t\t// Legacy functions.\n\t\trequire.Nil(t, m.UpFnNoTxContext)\n\t\trequire.Nil(t, m.DownFnNoTxContext)\n\t\t// Context-aware functions.\n\t\trequire.NotNil(t, m.goUp)\n\t\trequire.NotNil(t, m.UpFnContext)\n\t\trequire.NotNil(t, m.goDown)\n\t\trequire.NotNil(t, m.DownFnContext)\n\t\t// Always nil\n\t\trequire.NotNil(t, m.UpFn)\n\t\trequire.NotNil(t, m.DownFn)\n\t\trequire.Nil(t, m.UpFnNoTx)\n\t\trequire.Nil(t, m.DownFnNoTx)\n\t})\n\tt.Run(\"all_db\", func(t *testing.T) {\n\t\tt.Cleanup(ResetGlobalMigrations)\n\t\terr := SetGlobalMigrations(\n\t\t\tNewGoMigration(2, &GoFunc{RunDB: runDB}, &GoFunc{RunDB: runDB}),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, registeredGoMigrations, 1)\n\t\tm := registeredGoMigrations[2]\n\t\tassertMigration(t, m, 2)\n\t\t// Legacy functions.\n\t\trequire.NotNil(t, m.UpFnNoTxContext)\n\t\trequire.NotNil(t, m.goUp)\n\t\trequire.NotNil(t, m.DownFnNoTxContext)\n\t\trequire.NotNil(t, m.goDown)\n\t\t// Context-aware functions.\n\t\trequire.Nil(t, m.UpFnContext)\n\t\trequire.Nil(t, m.DownFnContext)\n\t\t// Always nil\n\t\trequire.Nil(t, m.UpFn)\n\t\trequire.Nil(t, m.DownFn)\n\t\trequire.NotNil(t, m.UpFnNoTx)\n\t\trequire.NotNil(t, m.DownFnNoTx)\n\t})\n}\n\nfunc TestGlobalRegister(t *testing.T) {\n\tt.Cleanup(ResetGlobalMigrations)\n\n\t// runDB := func(context.Context, *sql.DB) error { return nil }\n\trunTx := func(context.Context, *sql.Tx) error { return nil }\n\n\t// Success.\n\terr := SetGlobalMigrations([]*Migration{}...)\n\trequire.NoError(t, err)\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, &GoFunc{RunTx: runTx}, nil),\n\t)\n\trequire.NoError(t, err)\n\t// Try to register the same migration again.\n\terr = SetGlobalMigrations(\n\t\tNewGoMigration(1, &GoFunc{RunTx: runTx}, nil),\n\t)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"go migration with version 1 already registered\")\n\terr = SetGlobalMigrations(&Migration{Registered: true, Version: 2, Type: TypeGo})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must use NewGoMigration to construct migrations\")\n}\n\nfunc TestCheckMigration(t *testing.T) {\n\t// Success.\n\terr := checkGoMigration(NewGoMigration(1, nil, nil))\n\trequire.NoError(t, err)\n\t// Failures.\n\terr = checkGoMigration(&Migration{})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must use NewGoMigration to construct migrations\")\n\terr = checkGoMigration(&Migration{construct: true})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must be registered\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `type must be \"go\"`)\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"version must be greater than zero\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1, goUp: &GoFunc{}, goDown: &GoFunc{}})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"up function: invalid mode: 0\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1, goUp: &GoFunc{Mode: TransactionEnabled}, goDown: &GoFunc{}})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"down function: invalid mode: 0\")\n\t// Success.\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1, goUp: &GoFunc{Mode: TransactionEnabled}, goDown: &GoFunc{Mode: TransactionEnabled}})\n\trequire.NoError(t, err)\n\t// Failures.\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1, Source: \"foo\"})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `source must have .go extension: \"foo\"`)\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1, Source: \"foo.go\"})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `no filename separator '_' found`)\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 2, Source: \"00001_foo.sql\"})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `source must have .go extension: \"00001_foo.sql\"`)\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 2, Source: \"00001_foo.go\"})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `version:2 does not match numeric component in source \"00001_foo.go\"`)\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1,\n\t\tUpFnContext:     func(context.Context, *sql.Tx) error { return nil },\n\t\tUpFnNoTxContext: func(context.Context, *sql.DB) error { return nil },\n\t\tgoUp:            &GoFunc{Mode: TransactionEnabled},\n\t\tgoDown:          &GoFunc{Mode: TransactionEnabled},\n\t})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must specify exactly one of UpFnContext or UpFnNoTxContext\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1,\n\t\tDownFnContext:     func(context.Context, *sql.Tx) error { return nil },\n\t\tDownFnNoTxContext: func(context.Context, *sql.DB) error { return nil },\n\t\tgoUp:              &GoFunc{Mode: TransactionEnabled},\n\t\tgoDown:            &GoFunc{Mode: TransactionEnabled},\n\t})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must specify exactly one of DownFnContext or DownFnNoTxContext\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1,\n\t\tUpFn:     func(*sql.Tx) error { return nil },\n\t\tUpFnNoTx: func(*sql.DB) error { return nil },\n\t\tgoUp:     &GoFunc{Mode: TransactionEnabled},\n\t\tgoDown:   &GoFunc{Mode: TransactionEnabled},\n\t})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must specify exactly one of UpFn or UpFnNoTx\")\n\terr = checkGoMigration(&Migration{construct: true, Registered: true, Type: TypeGo, Version: 1,\n\t\tDownFn:     func(*sql.Tx) error { return nil },\n\t\tDownFnNoTx: func(*sql.DB) error { return nil },\n\t\tgoUp:       &GoFunc{Mode: TransactionEnabled},\n\t\tgoDown:     &GoFunc{Mode: TransactionEnabled},\n\t})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"must specify exactly one of DownFn or DownFnNoTx\")\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 3.4208984375,
          "content": "module github.com/pressly/goose/v3\n\ngo 1.21.0\n\nrequire (\n\tgithub.com/ClickHouse/clickhouse-go/v2 v2.30.0\n\tgithub.com/go-sql-driver/mysql v1.8.1\n\tgithub.com/jackc/pgx/v5 v5.7.1\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/mfridman/interpolate v0.0.2\n\tgithub.com/mfridman/xflag v0.1.0\n\tgithub.com/microsoft/go-mssqldb v1.8.0\n\tgithub.com/sethvargo/go-retry v0.3.0\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/tursodatabase/libsql-client-go v0.0.0-20240902231107-85af5b9d094d\n\tgithub.com/vertica/vertica-sql-go v1.3.3\n\tgithub.com/ydb-platform/ydb-go-sdk/v3 v3.95.3\n\tgithub.com/ziutek/mymysql v1.5.4\n\tgo.uber.org/multierr v1.11.0\n\tgolang.org/x/sync v0.10.0\n\tmodernc.org/sqlite v1.34.1\n)\n\nrequire (\n\tfilippo.io/edwards25519 v1.1.0 // indirect\n\tgithub.com/ClickHouse/ch-go v0.61.5 // indirect\n\tgithub.com/andybalholm/brotli v1.1.1 // indirect\n\tgithub.com/antlr4-go/antlr/v4 v4.13.0 // indirect\n\tgithub.com/coder/websocket v1.8.12 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dustin/go-humanize v1.0.1 // indirect\n\tgithub.com/elastic/go-sysinfo v1.11.2 // indirect\n\tgithub.com/elastic/go-windows v1.0.1 // indirect\n\tgithub.com/go-faster/city v1.0.1 // indirect\n\tgithub.com/go-faster/errors v0.7.1 // indirect\n\tgithub.com/golang-jwt/jwt/v4 v4.5.1 // indirect\n\tgithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect\n\tgithub.com/golang-sql/sqlexp v0.1.0 // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/hashicorp/golang-lru/v2 v2.0.7 // indirect\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.2 // indirect\n\tgithub.com/joeshaw/multierror v0.0.0-20140124173710-69b34d4ec901 // indirect\n\tgithub.com/jonboulle/clockwork v0.4.0 // indirect\n\tgithub.com/klauspost/compress v1.17.7 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/ncruces/go-strftime v0.1.9 // indirect\n\tgithub.com/paulmach/orb v0.11.1 // indirect\n\tgithub.com/pierrec/lz4/v4 v4.1.21 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/procfs v0.12.0 // indirect\n\tgithub.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect\n\tgithub.com/segmentio/asm v1.2.0 // indirect\n\tgithub.com/shopspring/decimal v1.4.0 // indirect\n\tgithub.com/ydb-platform/ydb-go-genproto v0.0.0-20241112172322-ea1f63298f77 // indirect\n\tgo.opentelemetry.io/otel v1.26.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.26.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/exp v0.0.0-20240325151524-a685a6edb6d8 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 // indirect\n\tgoogle.golang.org/grpc v1.62.1 // indirect\n\tgoogle.golang.org/protobuf v1.33.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\thowett.net/plist v1.0.0 // indirect\n\tmodernc.org/gc/v3 v3.0.0-20240107210532-573471604cb6 // indirect\n\tmodernc.org/libc v1.55.3 // indirect\n\tmodernc.org/mathutil v1.6.0 // indirect\n\tmodernc.org/memory v1.8.0 // indirect\n\tmodernc.org/strutil v1.2.0 // indirect\n\tmodernc.org/token v1.1.0 // indirect\n)\n\nretract (\n\tv3.21.0 // Invalid replace directives\n\tv3.12.2 // Invalid module reference\n\tv3.12.1 // Invalid module reference\n\tv3.12.0 // Invalid module reference\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 35.65234375,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\nfilippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngithub.com/Azure/azure-sdk-for-go/sdk/azcore v1.11.1 h1:E+OJmp2tPvt1W+amx48v1eqbjDYsgN+RzP4q16yV5eM=\ngithub.com/Azure/azure-sdk-for-go/sdk/azcore v1.11.1/go.mod h1:a6xsAQUZg+VsS3TJ05SRp524Hs4pZ/AeFSr5ENf0Yjo=\ngithub.com/Azure/azure-sdk-for-go/sdk/azidentity v1.6.0 h1:U2rTu3Ef+7w9FHKIAXM6ZyqF3UOWJZ12zIm8zECAFfg=\ngithub.com/Azure/azure-sdk-for-go/sdk/azidentity v1.6.0/go.mod h1:9kIvujWAA58nmPmWB1m23fyWic1kYZMxD9CxaWn4Qpg=\ngithub.com/Azure/azure-sdk-for-go/sdk/internal v1.8.0 h1:jBQA3cKT4L2rWMpgE7Yt3Hwh2aUj8KXjIGLxjHeYNNo=\ngithub.com/Azure/azure-sdk-for-go/sdk/internal v1.8.0/go.mod h1:4OG6tQ9EOP/MT0NMjDlRzWoVFxfu9rN9B2X+tlSVktg=\ngithub.com/Azure/azure-sdk-for-go/sdk/security/keyvault/azkeys v1.0.1 h1:MyVTgWR8qd/Jw1Le0NZebGBUCLbtak3bJ3z1OlqZBpw=\ngithub.com/Azure/azure-sdk-for-go/sdk/security/keyvault/azkeys v1.0.1/go.mod h1:GpPjLhVR9dnUoJMyHWSPy71xY9/lcmpzIPZXmF0FCVY=\ngithub.com/Azure/azure-sdk-for-go/sdk/security/keyvault/internal v1.0.0 h1:D3occbWoio4EBLkbkevetNMAVX197GkzbUMtqjGWn80=\ngithub.com/Azure/azure-sdk-for-go/sdk/security/keyvault/internal v1.0.0/go.mod h1:bTSOgj05NGRuHHhQwAdPnYr9TOdNmKlZTgGLL6nyAdI=\ngithub.com/AzureAD/microsoft-authentication-library-for-go v1.2.2 h1:XHOnouVk1mxXfQidrMEnLlPk9UMeRtyBTnEFtxkV0kU=\ngithub.com/AzureAD/microsoft-authentication-library-for-go v1.2.2/go.mod h1:wP83P5OoQ5p6ip3ScPr0BAq0BvuPAvacpEuSzyouqAI=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/ClickHouse/ch-go v0.61.5 h1:zwR8QbYI0tsMiEcze/uIMK+Tz1D3XZXLdNrlaOpeEI4=\ngithub.com/ClickHouse/ch-go v0.61.5/go.mod h1:s1LJW/F/LcFs5HJnuogFMta50kKDO0lf9zzfrbl0RQg=\ngithub.com/ClickHouse/clickhouse-go/v2 v2.30.0 h1:AG4D/hW39qa58+JHQIFOSnxyL46H6h2lrmGGk17dhFo=\ngithub.com/ClickHouse/clickhouse-go/v2 v2.30.0/go.mod h1:i9ZQAojcayW3RsdCb3YR+n+wC2h65eJsZCscZ1Z1wyo=\ngithub.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=\ngithub.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=\ngithub.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=\ngithub.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=\ngithub.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=\ngithub.com/antlr4-go/antlr/v4 v4.13.0 h1:lxCg3LAv+EUK6t1i0y1V6/SLeUi0eKEKdhQAlS8TVTI=\ngithub.com/antlr4-go/antlr/v4 v4.13.0/go.mod h1:pfChB/xh/Unjila75QW7+VU4TSnWnnk9UTnmpPaOR2g=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=\ngithub.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=\ngithub.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/coder/websocket v1.8.12 h1:5bUXkEPPIbewrnkU8LTCLVaxi4N4J8ahufH2vlo4NAo=\ngithub.com/coder/websocket v1.8.12/go.mod h1:LNVeNrXQZfe5qhS9ALED3uA+l5pPqvwXg3CKoDBB2gs=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=\ngithub.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=\ngithub.com/docker/docker v27.3.0+incompatible h1:BNb1QY6o4JdKpqwi9IB+HUYcRRrVN4aGFUTvDmWYK1A=\ngithub.com/docker/docker v27.3.0+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=\ngithub.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/elastic/go-sysinfo v1.8.1/go.mod h1:JfllUnzoQV/JRYymbH3dO1yggI3mV2oTKSXsDHM+uIM=\ngithub.com/elastic/go-sysinfo v1.11.2 h1:mcm4OSYVMyws6+n2HIVMGkln5HOpo5Ie1ZmbbNn0jg4=\ngithub.com/elastic/go-sysinfo v1.11.2/go.mod h1:GKqR8bbMK/1ITnez9NIsIfXQr25aLhRJa7AfT8HpBFQ=\ngithub.com/elastic/go-windows v1.0.0/go.mod h1:TsU0Nrp7/y3+VwE82FoZF8gC/XFg/Elz6CcloAxnPgU=\ngithub.com/elastic/go-windows v1.0.1 h1:AlYZOldA+UJ0/2nBuqWdo90GFCgG9xuyw9SYzGUtJm0=\ngithub.com/elastic/go-windows v1.0.1/go.mod h1:FoVvqWSun28vaDQPbj2Elfc0JahhPB7WQEGa3c814Ss=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=\ngithub.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-faster/city v1.0.1 h1:4WAxSZ3V2Ws4QRDrscLEDcibJY8uf41H6AhXDrNDcGw=\ngithub.com/go-faster/city v1.0.1/go.mod h1:jKcUJId49qdW3L1qKHH/3wPeUstCVpVSXTM6vO3VcTw=\ngithub.com/go-faster/errors v0.7.1 h1:MkJTnDoEdi9pDabt1dpWf7AA8/BaSYZqibYyhZ20AYg=\ngithub.com/go-faster/errors v0.7.1/go.mod h1:5ySTjWFiphBs07IKuiL69nxdfd5+fzh1u7FPGZP2quo=\ngithub.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=\ngithub.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=\ngithub.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=\ngithub.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=\ngithub.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=\ngithub.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=\ngithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 h1:au07oEsX2xN0ktxqI+Sida1w446QrXBRJ0nee3SNZlA=\ngithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=\ngithub.com/golang-sql/sqlexp v0.1.0 h1:ZCD6MBpcuOVfGVqsEmY5/4FtYiKz6tSyUv9LPEDei6A=\ngithub.com/golang-sql/sqlexp v0.1.0/go.mod h1:J4ad9Vo8ZCWQ2GMrC4UCQy1JpCbwU9m3EOqtpKwwwHI=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/golang/snappy v0.0.1/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20240409012703-83162a5b38cd h1:gbpYu9NMq8jhDVbvlGkMFWCjLFlqqEZjEmObmhUy6Vo=\ngithub.com/google/pprof v0.0.0-20240409012703-83162a5b38cd/go.mod h1:kf6iHlnVGwgKolg33glAes7Yg/8iWP8ukqeldJSO7jw=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=\ngithub.com/hashicorp/golang-lru/v2 v2.0.7 h1:a+bsQ5rvGLjzHuww6tVxozPZFVghXaHOwFs4luLUK2k=\ngithub.com/hashicorp/golang-lru/v2 v2.0.7/go.mod h1:QeFd9opnmA6QUJc5vARoKUSoFhyfM2/ZepoAG6RGpeM=\ngithub.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=\ngithub.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=\ngithub.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=\ngithub.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=\ngithub.com/jackc/pgx/v5 v5.7.1 h1:x7SYsPBYDkHDksogeSmZZ5xzThcTgRz++I5E+ePFUcs=\ngithub.com/jackc/pgx/v5 v5.7.1/go.mod h1:e7O26IywZZ+naJtWWos6i6fvWK+29etgITqrqHLfoZA=\ngithub.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=\ngithub.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/joeshaw/multierror v0.0.0-20140124173710-69b34d4ec901 h1:rp+c0RAYOWj8l6qbCUTSiRLG/iKnW3K3/QfPPuSsBt4=\ngithub.com/joeshaw/multierror v0.0.0-20140124173710-69b34d4ec901/go.mod h1:Z86h9688Y0wesXCyonoVr47MasHilkuLMqGhRZ4Hpak=\ngithub.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=\ngithub.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=\ngithub.com/jonboulle/clockwork v0.4.0 h1:p4Cf1aMWXnXAUh8lVfewRBx1zaTSYKrKMF2g3ST4RZ4=\ngithub.com/jonboulle/clockwork v0.4.0/go.mod h1:xgRqUGwRcjKCO1vbZUEtSLrqKoPSsUpK7fnezOII0kc=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=\ngithub.com/klauspost/compress v1.17.7 h1:ehO88t2UGzQK66LMdE8tibEd1ErmzZjNEqWkjLAKQQg=\ngithub.com/klauspost/compress v1.17.7/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mfridman/interpolate v0.0.2 h1:pnuTK7MQIxxFz1Gr+rjSIx9u7qVjf5VOoM/u6BbAxPY=\ngithub.com/mfridman/interpolate v0.0.2/go.mod h1:p+7uk6oE07mpE/Ik1b8EckO0O4ZXiGAfshKBWLUM9Xg=\ngithub.com/mfridman/xflag v0.1.0 h1:TWZrZwG1QklFX5S4j1vxfF1sZbZeZSGofMwPMLAF29M=\ngithub.com/mfridman/xflag v0.1.0/go.mod h1:/483ywM5ZO5SuMVjrIGquYNE5CzLrj5Ux/LxWWnjRaE=\ngithub.com/microsoft/go-mssqldb v1.8.0 h1:7cyZ/AT7ycDsEoWPIXibd+aVKFtteUNhDGf3aobP+tw=\ngithub.com/microsoft/go-mssqldb v1.8.0/go.mod h1:6znkekS3T2vp0waiMhen4GPU1BiAsrP+iXHcE7a7rFo=\ngithub.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=\ngithub.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=\ngithub.com/montanaflynn/stats v0.0.0-20171201202039-1bf9dbcd8cbe/go.mod h1:wL8QJuTMNUDYhXwkmfOly8iTdp5TEcJFWZD2D7SIkUc=\ngithub.com/ncruces/go-strftime v0.1.9 h1:bY0MQC28UADQmHmaF5dgpLmImcShSi2kHU9XLdhx/f4=\ngithub.com/ncruces/go-strftime v0.1.9/go.mod h1:Fwc5htZGVVkseilnfgOVb9mKy6w1naJmn9CehxcKcls=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=\ngithub.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=\ngithub.com/paulmach/orb v0.11.1 h1:3koVegMC4X/WeiXYz9iswopaTwMem53NzTJuTF20JzU=\ngithub.com/paulmach/orb v0.11.1/go.mod h1:5mULz1xQfs3bmQm63QEJA6lNGujuRafwA5S/EnuLaLU=\ngithub.com/paulmach/protoscan v0.2.1/go.mod h1:SpcSwydNLrxUGSDvXvO0P7g7AuhJ7lcKfDlhJCDw2gY=\ngithub.com/pierrec/lz4/v4 v4.1.21 h1:yOVMLb6qSIDP67pl/5F7RepeKYu/VmTyEXvuMI5d9mQ=\ngithub.com/pierrec/lz4/v4 v4.1.21/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=\ngithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/procfs v0.0.0-20190425082905-87a4384529e0/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.12.0 h1:jluTpSng7V9hY0O2R9DzzJHYb2xULk9VTR1V1R/k6Bo=\ngithub.com/prometheus/procfs v0.12.0/go.mod h1:pcuDEFsWDnvcgNzo4EEweacyhjeA9Zk3cnaOZAZEfOo=\ngithub.com/rekby/fixenv v0.6.1 h1:jUFiSPpajT4WY2cYuc++7Y1zWrnCxnovGCIX72PZniM=\ngithub.com/rekby/fixenv v0.6.1/go.mod h1:/b5LRc06BYJtslRtHKxsPWFT/ySpHV+rWvzTg+XWk4c=\ngithub.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec h1:W09IVJc94icq4NjY3clb7Lk8O1qJ8BdBEF8z0ibU0rE=\ngithub.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/segmentio/asm v1.2.0 h1:9BQrFxC+YOHJlTlHGkTrFWf59nbL3XnCoFLTwDCI7ys=\ngithub.com/segmentio/asm v1.2.0/go.mod h1:BqMnlJP91P8d+4ibuonYZw9mfnzI9HfxselHZr5aAcs=\ngithub.com/sethvargo/go-retry v0.3.0 h1:EEt31A35QhrcRZtrYFDTBg91cqZVnFL2navjDrah2SE=\ngithub.com/sethvargo/go-retry v0.3.0/go.mod h1:mNX17F0C/HguQMyMyJxcnU471gOZGxCLyYaFyAZraas=\ngithub.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=\ngithub.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tidwall/pretty v1.0.0/go.mod h1:XNkn88O1ChpSDQmQeStsy+sBenx6DDtFZJxhVysOjyk=\ngithub.com/tursodatabase/libsql-client-go v0.0.0-20240902231107-85af5b9d094d h1:dOMI4+zEbDI37KGb0TI44GUAwxHF9cMsIoDTJ7UmgfU=\ngithub.com/tursodatabase/libsql-client-go v0.0.0-20240902231107-85af5b9d094d/go.mod h1:l8xTsYB90uaVdMHXMCxKKLSgw5wLYBwBKKefNIUnm9s=\ngithub.com/vertica/vertica-sql-go v1.3.3 h1:fL+FKEAEy5ONmsvya2WH5T8bhkvY27y/Ik3ReR2T+Qw=\ngithub.com/vertica/vertica-sql-go v1.3.3/go.mod h1:jnn2GFuv+O2Jcjktb7zyc4Utlbu9YVqpHH/lx63+1M4=\ngithub.com/xdg-go/pbkdf2 v1.0.0/go.mod h1:jrpuAogTd400dnrH08LKmI/xc1MbPOebTwRqcT5RDeI=\ngithub.com/xdg-go/scram v1.1.1/go.mod h1:RaEWvsqvNKKvBPvcKeFjrG2cJqOkHTiyTpzz23ni57g=\ngithub.com/xdg-go/stringprep v1.0.3/go.mod h1:W3f5j4i+9rC0kuIEJL0ky1VpHXQU3ocBgklLGvcBnW8=\ngithub.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=\ngithub.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=\ngithub.com/ydb-platform/ydb-go-genproto v0.0.0-20241112172322-ea1f63298f77 h1:LY6cI8cP4B9rrpTleZk95+08kl2gF4rixG7+V/dwL6Q=\ngithub.com/ydb-platform/ydb-go-genproto v0.0.0-20241112172322-ea1f63298f77/go.mod h1:Er+FePu1dNUieD+XTMDduGpQuCPssK5Q4BjF+IIXJ3I=\ngithub.com/ydb-platform/ydb-go-sdk/v3 v3.95.3 h1:pgsQPKSFfRFy3JSZMUReCF4CSEwgxA+a5GymvtyRJO0=\ngithub.com/ydb-platform/ydb-go-sdk/v3 v3.95.3/go.mod h1:WiezFS4YCi2vHqbYGQkeu/2MDBYFLix6dIs/pd87Yck=\ngithub.com/youmark/pkcs8 v0.0.0-20181117223130-1be2e3e5546d/go.mod h1:rHwXgn7JulP+udvsHwJoVG1YGAP6VLg4y9I5dyZdqmA=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/ziutek/mymysql v1.5.4 h1:GB0qdRGsTwQSBVYuVShFBKaXSnSnYYC2d9knnE1LHFs=\ngithub.com/ziutek/mymysql v1.5.4/go.mod h1:LMSpPZ6DbqWFxNCHW77HeMg9I646SAhApZ/wKdgO/C0=\ngo.mongodb.org/mongo-driver v1.11.4/go.mod h1:PTSz5yu21bkT/wXpkS7WR5f0ddqw5quethTUn9WM+2g=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=\ngo.opentelemetry.io/otel v1.26.0 h1:LQwgL5s/1W7YiiRwxf03QGnWLb2HW4pLiAhaA5cZXBs=\ngo.opentelemetry.io/otel v1.26.0/go.mod h1:UmLkJHUAidDval2EICqBMbnAd0/m2vmpf/dAM+fvFs4=\ngo.opentelemetry.io/otel/metric v1.26.0 h1:7S39CLuY5Jgg9CrnA9HHiEjGMF/X2VHvoXGgSllRz30=\ngo.opentelemetry.io/otel/metric v1.26.0/go.mod h1:SY+rHOI4cEawI9a7N1A4nIg/nTQXe1ccCNWYOJUrpX4=\ngo.opentelemetry.io/otel/trace v1.26.0 h1:1ieeAUb4y0TE26jUFrCIXKpTuVK7uJGN9/Z/2LP5sQA=\ngo.opentelemetry.io/otel/trace v1.26.0/go.mod h1:4iDxvGDQuUkHve82hJJ8UqrwswHYsZuWCBllGV2U2y0=\ngo.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=\ngo.uber.org/mock v0.4.0 h1:VcM4ZOtdbR4f6VXfiOpwpVJDL6lCReaZ6mw31wqh7KU=\ngo.uber.org/mock v0.4.0/go.mod h1:a6FSlNadKUHUa9IP5Vyt1zh4fC7uAwxMutEAscFbkZc=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20240325151524-a685a6edb6d8 h1:aAcj0Da7eBAtrTp03QXWvm88pSyOt+UgdZw2BFZ+lEw=\ngolang.org/x/exp v0.0.0-20240325151524-a685a6edb6d8/go.mod h1:CQ1k9gNrJ50XIzaKCRR2hssIjF07kZFEiieALBM/ARQ=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 h1:NnYq6UN9ReLM9/Y01KWNOWyI5xQ9kbIms5GGJVwS/Yc=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237/go.mod h1:WtryC6hu0hhx87FDGxWCDptyssuo68sk10vYjF+T9fY=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=\ngoogle.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=\ngoogle.golang.org/grpc v1.47.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=\ngoogle.golang.org/grpc v1.62.1 h1:B4n+nfKzOICUXMgyrNd19h/I9oH0L1pizfk1d4zSgTk=\ngoogle.golang.org/grpc v1.62.1/go.mod h1:IWTG0VlJLCh1SkC58F7np9ka9mx/WNkjl4PGJaiq+QE=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=\ngoogle.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0/go.mod h1:WDnlLJ4WF5VGsH/HVa3CI79GS0ol3YnhVnKP89i0kNg=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhowett.net/plist v0.0.0-20181124034731-591f970eefbb/go.mod h1:vMygbs4qMhSZSc4lCUl2OEE+rDiIIJAIdR4m7MiMcm0=\nhowett.net/plist v1.0.0 h1:7CrbWYbPPO/PyNy38b2EB/+gYbjCe2DXBxgtOOZbSQM=\nhowett.net/plist v1.0.0/go.mod h1:lqaXoTrLY4hg8tnEzNru53gicrbv7rrk+2xJA/7hw9g=\nmodernc.org/cc/v4 v4.21.4 h1:3Be/Rdo1fpr8GrQ7IVw9OHtplU4gWbb+wNgeoBMmGLQ=\nmodernc.org/cc/v4 v4.21.4/go.mod h1:HM7VJTZbUCR3rV8EYBi9wxnJ0ZBRiGE5OeGXNA0IsLQ=\nmodernc.org/ccgo/v4 v4.19.2 h1:lwQZgvboKD0jBwdaeVCTouxhxAyN6iawF3STraAal8Y=\nmodernc.org/ccgo/v4 v4.19.2/go.mod h1:ysS3mxiMV38XGRTTcgo0DQTeTmAO4oCmJl1nX9VFI3s=\nmodernc.org/fileutil v1.3.0 h1:gQ5SIzK3H9kdfai/5x41oQiKValumqNTDXMvKo62HvE=\nmodernc.org/fileutil v1.3.0/go.mod h1:XatxS8fZi3pS8/hKG2GH/ArUogfxjpEKs3Ku3aK4JyQ=\nmodernc.org/gc/v2 v2.4.1 h1:9cNzOqPyMJBvrUipmynX0ZohMhcxPtMccYgGOJdOiBw=\nmodernc.org/gc/v2 v2.4.1/go.mod h1:wzN5dK1AzVGoH6XOzc3YZ+ey/jPgYHLuVckd62P0GYU=\nmodernc.org/gc/v3 v3.0.0-20240107210532-573471604cb6 h1:5D53IMaUuA5InSeMu9eJtlQXS2NxAhyWQvkKEgXZhHI=\nmodernc.org/gc/v3 v3.0.0-20240107210532-573471604cb6/go.mod h1:Qz0X07sNOR1jWYCrJMEnbW/X55x206Q7Vt4mz6/wHp4=\nmodernc.org/libc v1.55.3 h1:AzcW1mhlPNrRtjS5sS+eW2ISCgSOLLNyFzRh/V3Qj/U=\nmodernc.org/libc v1.55.3/go.mod h1:qFXepLhz+JjFThQ4kzwzOjA/y/artDeg+pcYnY+Q83w=\nmodernc.org/mathutil v1.6.0 h1:fRe9+AmYlaej+64JsEEhoWuAYBkOtQiMEU7n/XgfYi4=\nmodernc.org/mathutil v1.6.0/go.mod h1:Ui5Q9q1TR2gFm0AQRqQUaBWFLAhQpCwNcuhBOSedWPo=\nmodernc.org/memory v1.8.0 h1:IqGTL6eFMaDZZhEWwcREgeMXYwmW83LYW8cROZYkg+E=\nmodernc.org/memory v1.8.0/go.mod h1:XPZ936zp5OMKGWPqbD3JShgd/ZoQ7899TUuQqxY+peU=\nmodernc.org/opt v0.1.3 h1:3XOZf2yznlhC+ibLltsDGzABUGVx8J6pnFMS3E4dcq4=\nmodernc.org/opt v0.1.3/go.mod h1:WdSiB5evDcignE70guQKxYUl14mgWtbClRi5wmkkTX0=\nmodernc.org/sortutil v1.2.0 h1:jQiD3PfS2REGJNzNCMMaLSp/wdMNieTbKX920Cqdgqc=\nmodernc.org/sortutil v1.2.0/go.mod h1:TKU2s7kJMf1AE84OoiGppNHJwvB753OYfNl2WRb++Ss=\nmodernc.org/sqlite v1.34.1 h1:u3Yi6M0N8t9yKRDwhXcyp1eS5/ErhPTBggxWFuR6Hfk=\nmodernc.org/sqlite v1.34.1/go.mod h1:pXV2xHxhzXZsgT/RtTFAPY6JJDEvOTcTdwADQCCWD4k=\nmodernc.org/strutil v1.2.0 h1:agBi9dp1I+eOnxXeiZawM8F4LawKv4NzGWSaLfyeNZA=\nmodernc.org/strutil v1.2.0/go.mod h1:/mdcBmfOibveCTBxUl5B5l6W+TTH1FXPLHZE6bTosX0=\nmodernc.org/token v1.1.0 h1:Xl7Ap9dKaEs5kLoOQeQmPWevfnk/DM5qcLcYlA8ys6Y=\nmodernc.org/token v1.1.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\n"
        },
        {
          "name": "goose.go",
          "type": "blob",
          "size": 3.732421875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"strconv\"\n)\n\n// Deprecated: VERSION will no longer be supported in the next major release.\nconst VERSION = \"v3.18.0\"\n\nvar (\n\tminVersion      = int64(0)\n\tmaxVersion      = int64((1 << 63) - 1)\n\ttimestampFormat = \"20060102150405\"\n\tverbose         = false\n\tnoColor         = false\n\n\t// base fs to lookup migrations\n\tbaseFS fs.FS = osFS{}\n)\n\n// SetVerbose set the goose verbosity mode\nfunc SetVerbose(v bool) {\n\tverbose = v\n}\n\n// SetBaseFS sets a base FS to discover migrations. It can be used with 'embed' package.\n// Calling with 'nil' argument leads to default behaviour: discovering migrations from os filesystem.\n// Note that modifying operations like Create will use os filesystem anyway.\nfunc SetBaseFS(fsys fs.FS) {\n\tif fsys == nil {\n\t\tfsys = osFS{}\n\t}\n\n\tbaseFS = fsys\n}\n\n// Run runs a goose command.\n//\n// Deprecated: Use RunContext.\nfunc Run(command string, db *sql.DB, dir string, args ...string) error {\n\tctx := context.Background()\n\treturn RunContext(ctx, command, db, dir, args...)\n}\n\n// RunContext runs a goose command.\nfunc RunContext(ctx context.Context, command string, db *sql.DB, dir string, args ...string) error {\n\treturn run(ctx, command, db, dir, args)\n}\n\n// RunWithOptions runs a goose command with options.\n//\n// Deprecated: Use RunWithOptionsContext.\nfunc RunWithOptions(command string, db *sql.DB, dir string, args []string, options ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn RunWithOptionsContext(ctx, command, db, dir, args, options...)\n}\n\n// RunWithOptionsContext runs a goose command with options.\nfunc RunWithOptionsContext(ctx context.Context, command string, db *sql.DB, dir string, args []string, options ...OptionsFunc) error {\n\treturn run(ctx, command, db, dir, args, options...)\n}\n\nfunc run(ctx context.Context, command string, db *sql.DB, dir string, args []string, options ...OptionsFunc) error {\n\tswitch command {\n\tcase \"up\":\n\t\tif err := UpContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"up-by-one\":\n\t\tif err := UpByOneContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"up-to\":\n\t\tif len(args) == 0 {\n\t\t\treturn fmt.Errorf(\"up-to must be of form: goose [OPTIONS] DRIVER DBSTRING up-to VERSION\")\n\t\t}\n\n\t\tversion, err := strconv.ParseInt(args[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"version must be a number (got '%s')\", args[0])\n\t\t}\n\t\tif err := UpToContext(ctx, db, dir, version, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"create\":\n\t\tif len(args) == 0 {\n\t\t\treturn fmt.Errorf(\"create must be of form: goose [OPTIONS] DRIVER DBSTRING create NAME [go|sql]\")\n\t\t}\n\n\t\tmigrationType := \"go\"\n\t\tif len(args) == 2 {\n\t\t\tmigrationType = args[1]\n\t\t}\n\t\tif err := Create(db, dir, args[0], migrationType); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"down\":\n\t\tif err := DownContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"down-to\":\n\t\tif len(args) == 0 {\n\t\t\treturn fmt.Errorf(\"down-to must be of form: goose [OPTIONS] DRIVER DBSTRING down-to VERSION\")\n\t\t}\n\n\t\tversion, err := strconv.ParseInt(args[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"version must be a number (got '%s')\", args[0])\n\t\t}\n\t\tif err := DownToContext(ctx, db, dir, version, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"fix\":\n\t\tif err := Fix(dir); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"redo\":\n\t\tif err := RedoContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"reset\":\n\t\tif err := ResetContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"status\":\n\t\tif err := StatusContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"version\":\n\t\tif err := VersionContext(ctx, db, dir, options...); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"%q: no such command\", command)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "goose_cli_test.go",
          "type": "blob",
          "size": 6.2353515625,
          "content": "package goose_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t_ \"modernc.org/sqlite\"\n)\n\nconst (\n\t// gooseTestBinaryVersion is utilized in conjunction with a linker variable to set the version\n\t// of a binary created solely for testing purposes. It is used to test the --version flag.\n\tgooseTestBinaryVersion = \"v0.0.0\"\n)\n\nfunc TestFullBinary(t *testing.T) {\n\tt.Parallel()\n\tcli := buildGooseCLI(t, false)\n\tout, err := cli.run(\"--version\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"goose version: \"+gooseTestBinaryVersion+\"\\n\", out)\n}\n\nfunc TestLiteBinary(t *testing.T) {\n\tt.Parallel()\n\tcli := buildGooseCLI(t, true)\n\n\tt.Run(\"binary_version\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tout, err := cli.run(\"--version\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"goose version: \"+gooseTestBinaryVersion+\"\\n\", out)\n\t})\n\tt.Run(\"default_binary\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdir := t.TempDir()\n\t\ttotal := countSQLFiles(t, \"testdata/migrations\")\n\t\tcommands := []struct {\n\t\t\tcmd string\n\t\t\tout string\n\t\t}{\n\t\t\t{\"up\", \"goose: successfully migrated database to version: \" + strconv.Itoa(total)},\n\t\t\t{\"version\", \"goose: version \" + strconv.Itoa(total)},\n\t\t\t{\"down\", \"OK\"},\n\t\t\t{\"version\", \"goose: version \" + strconv.Itoa(total-1)},\n\t\t\t{\"status\", \"\"},\n\t\t\t{\"reset\", \"OK\"},\n\t\t\t{\"version\", \"goose: version 0\"},\n\t\t}\n\t\tfor _, c := range commands {\n\t\t\tout, err := cli.run(\"-dir=testdata/migrations\", \"sqlite3\", filepath.Join(dir, \"sql.db\"), c.cmd)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Contains(t, out, c.out)\n\t\t}\n\t})\n\tt.Run(\"gh_issue_532\", func(t *testing.T) {\n\t\t// https://github.com/pressly/goose/issues/532\n\t\tt.Parallel()\n\t\tdir := t.TempDir()\n\t\ttotal := countSQLFiles(t, \"testdata/migrations\")\n\t\t_, err := cli.run(\"-dir=testdata/migrations\", \"sqlite3\", filepath.Join(dir, \"sql.db\"), \"up\")\n\t\trequire.NoError(t, err)\n\t\tout, err := cli.run(\"-dir=testdata/migrations\", \"sqlite3\", filepath.Join(dir, \"sql.db\"), \"up\")\n\t\trequire.NoError(t, err)\n\t\trequire.Contains(t, out, \"goose: no migrations to run. current version: \"+strconv.Itoa(total))\n\t\tout, err = cli.run(\"-dir=testdata/migrations\", \"sqlite3\", filepath.Join(dir, \"sql.db\"), \"version\")\n\t\trequire.NoError(t, err)\n\t\trequire.Contains(t, out, \"goose: version \"+strconv.Itoa(total))\n\t})\n\tt.Run(\"gh_issue_293\", func(t *testing.T) {\n\t\t// https://github.com/pressly/goose/issues/293\n\t\tt.Parallel()\n\t\tdir := t.TempDir()\n\t\ttotal := countSQLFiles(t, \"testdata/migrations\")\n\t\tcommands := []struct {\n\t\t\tcmd string\n\t\t\tout string\n\t\t}{\n\t\t\t{\"up\", \"goose: successfully migrated database to version: \" + strconv.Itoa(total)},\n\t\t\t{\"version\", \"goose: version \" + strconv.Itoa(total)},\n\t\t\t{\"down\", \"OK\"},\n\t\t\t{\"down\", \"OK\"},\n\t\t\t{\"version\", \"goose: version \" + strconv.Itoa(total-2)},\n\t\t\t{\"up\", \"goose: successfully migrated database to version: \" + strconv.Itoa(total)},\n\t\t\t{\"status\", \"\"},\n\t\t}\n\t\tfor _, c := range commands {\n\t\t\tout, err := cli.run(\"-dir=testdata/migrations\", \"sqlite3\", filepath.Join(dir, \"sql.db\"), c.cmd)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Contains(t, out, c.out)\n\t\t}\n\t})\n\tt.Run(\"gh_issue_336\", func(t *testing.T) {\n\t\t// https://github.com/pressly/goose/issues/336\n\t\tt.Parallel()\n\t\tdir := t.TempDir()\n\t\t_, err := cli.run(\"-dir=\"+dir, \"sqlite3\", filepath.Join(dir, \"sql.db\"), \"up\")\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"goose run: no migration files found\")\n\t})\n\tt.Run(\"create_and_fix\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdir := t.TempDir()\n\t\tcreateEmptyFile(t, dir, \"00001_alpha.sql\")\n\t\tcreateEmptyFile(t, dir, \"00003_bravo.sql\")\n\t\tcreateEmptyFile(t, dir, \"20230826163141_charlie.sql\")\n\t\tcreateEmptyFile(t, dir, \"20230826163151_delta.go\")\n\t\ttotal, err := os.ReadDir(dir)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, total, 4)\n\t\tmigrationFiles := []struct {\n\t\t\tname     string\n\t\t\tfileType string\n\t\t}{\n\t\t\t{\"echo\", \"sql\"},\n\t\t\t{\"foxtrot\", \"go\"},\n\t\t\t{\"golf\", \"\"},\n\t\t}\n\t\tfor i, f := range migrationFiles {\n\t\t\targs := []string{\"-dir=\" + dir, \"create\", f.name}\n\t\t\tif f.fileType != \"\" {\n\t\t\t\targs = append(args, f.fileType)\n\t\t\t}\n\t\t\tout, err := cli.run(args...)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Contains(t, out, \"Created new file\")\n\t\t\t// ensure different timestamps, granularity is 1 second\n\t\t\tif i < len(migrationFiles)-1 {\n\t\t\t\ttime.Sleep(1100 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t\ttotal, err = os.ReadDir(dir)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, total, 7)\n\t\tout, err := cli.run(\"-dir=\"+dir, \"fix\")\n\t\trequire.NoError(t, err)\n\t\trequire.Contains(t, out, \"RENAMED\")\n\t\tfiles, err := os.ReadDir(dir)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, files, 7)\n\t\texpected := []string{\n\t\t\t\"00001_alpha.sql\",\n\t\t\t\"00003_bravo.sql\",\n\t\t\t\"00004_charlie.sql\",\n\t\t\t\"00005_delta.go\",\n\t\t\t\"00006_echo.sql\",\n\t\t\t\"00007_foxtrot.go\",\n\t\t\t\"00008_golf.go\",\n\t\t}\n\t\tfor i, f := range files {\n\t\t\trequire.Equal(t, f.Name(), expected[i])\n\t\t}\n\t})\n}\n\ntype gooseBinary struct {\n\tbinaryPath string\n}\n\nfunc (g gooseBinary) run(params ...string) (string, error) {\n\tcmd := exec.Command(g.binaryPath, params...)\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to run goose command: %v\\nout: %v\", err, string(out))\n\t}\n\treturn string(out), nil\n}\n\n// buildGooseCLI builds goose test binary, which is used for testing goose CLI. It is built with all\n// drivers enabled, unless lite is true, in which case all drivers are disabled except sqlite3\nfunc buildGooseCLI(t *testing.T, lite bool) gooseBinary {\n\tt.Helper()\n\tbinName := \"goose-test\"\n\tdir := t.TempDir()\n\toutput := filepath.Join(dir, binName)\n\t// usage: go build [-o output] [build flags] [packages]\n\targs := []string{\n\t\t\"build\",\n\t\t\"-o\", output,\n\t\t\"-ldflags=-s -w -X main.version=\" + gooseTestBinaryVersion,\n\t}\n\tif lite {\n\t\targs = append(args, \"-tags=no_clickhouse no_mssql no_mysql no_vertica no_postgres\")\n\t}\n\targs = append(args, \"./cmd/goose\")\n\tbuild := exec.Command(\"go\", args...)\n\tout, err := build.CombinedOutput()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to build %s binary: %v: %s\", binName, err, string(out))\n\t}\n\treturn gooseBinary{\n\t\tbinaryPath: output,\n\t}\n}\n\nfunc countSQLFiles(t *testing.T, dir string) int {\n\tt.Helper()\n\tfiles, err := filepath.Glob(filepath.Join(dir, \"*.sql\"))\n\trequire.NoError(t, err)\n\treturn len(files)\n}\n\nfunc createEmptyFile(t *testing.T, dir, name string) {\n\tt.Helper()\n\tpath := filepath.Join(dir, name)\n\tf, err := os.Create(path)\n\trequire.NoError(t, err)\n\tdefer f.Close()\n}\n"
        },
        {
          "name": "goose_embed_test.go",
          "type": "blob",
          "size": 1.546875,
          "content": "package goose_test\n\nimport (\n\t\"database/sql\"\n\t\"embed\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\t_ \"modernc.org/sqlite\"\n)\n\n//go:embed testdata/migrations/*.sql\nvar embedMigrations embed.FS\n\nfunc TestEmbeddedMigrations(t *testing.T) {\n\tdir := t.TempDir()\n\t// not using t.Parallel here to avoid races\n\tdb, err := sql.Open(\"sqlite\", filepath.Join(dir, \"sql_embed.db\"))\n\trequire.NoError(t, err)\n\n\tdb.SetMaxOpenConns(1)\n\n\tmigrationFiles, err := fs.ReadDir(embedMigrations, \"testdata/migrations\")\n\trequire.NoError(t, err)\n\ttotal := len(migrationFiles)\n\n\t// decouple from existing structure\n\tfsys, err := fs.Sub(embedMigrations, \"testdata/migrations\")\n\trequire.NoError(t, err)\n\n\tgoose.SetBaseFS(fsys)\n\tt.Cleanup(func() { goose.SetBaseFS(nil) })\n\trequire.NoError(t, goose.SetDialect(\"sqlite3\"))\n\n\tt.Run(\"migration_cycle\", func(t *testing.T) {\n\t\terr := goose.Up(db, \".\")\n\t\trequire.NoError(t, err)\n\t\tver, err := goose.GetDBVersion(db)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, ver, total)\n\t\terr = goose.Reset(db, \".\")\n\t\trequire.NoError(t, err)\n\t\tver, err = goose.GetDBVersion(db)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 0, ver)\n\t})\n\tt.Run(\"create_uses_os_fs\", func(t *testing.T) {\n\t\tdir := t.TempDir()\n\t\terr := goose.Create(db, dir, \"test\", \"sql\")\n\t\trequire.NoError(t, err)\n\t\tpaths, _ := filepath.Glob(filepath.Join(dir, \"*test.sql\"))\n\t\trequire.NotEmpty(t, paths)\n\t\terr = goose.Fix(dir)\n\t\trequire.NoError(t, err)\n\t\t_, err = os.Stat(filepath.Join(dir, \"00001_test.sql\"))\n\t\trequire.NoError(t, err)\n\t})\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 1.7900390625,
          "content": "package goose\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\ntype camelSnakeStateMachine int\n\nconst ( //                                           _$$_This is some text, OK?!\n\tidle          camelSnakeStateMachine = iota // 0 ↑                     ↑   ↑\n\tfirstAlphaNum                               // 1     ↑    ↑  ↑    ↑     ↑\n\talphaNum                                    // 2      ↑↑↑  ↑  ↑↑↑  ↑↑↑   ↑\n\tdelimiter                                   // 3         ↑  ↑    ↑    ↑   ↑\n)\n\nfunc (s camelSnakeStateMachine) next(r rune) camelSnakeStateMachine {\n\tswitch s {\n\tcase idle:\n\t\tif isAlphaNum(r) {\n\t\t\treturn firstAlphaNum\n\t\t}\n\tcase firstAlphaNum:\n\t\tif isAlphaNum(r) {\n\t\t\treturn alphaNum\n\t\t}\n\t\treturn delimiter\n\tcase alphaNum:\n\t\tif !isAlphaNum(r) {\n\t\t\treturn delimiter\n\t\t}\n\tcase delimiter:\n\t\tif isAlphaNum(r) {\n\t\t\treturn firstAlphaNum\n\t\t}\n\t\treturn idle\n\t}\n\treturn s\n}\n\nfunc camelCase(str string) string {\n\tvar b strings.Builder\n\n\tstateMachine := idle\n\tfor i := 0; i < len(str); {\n\t\tr, size := utf8.DecodeRuneInString(str[i:])\n\t\ti += size\n\t\tstateMachine = stateMachine.next(r)\n\t\tswitch stateMachine {\n\t\tcase firstAlphaNum:\n\t\t\tb.WriteRune(unicode.ToUpper(r))\n\t\tcase alphaNum:\n\t\t\tb.WriteRune(unicode.ToLower(r))\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc snakeCase(str string) string {\n\tvar b bytes.Buffer\n\n\tstateMachine := idle\n\tfor i := 0; i < len(str); {\n\t\tr, size := utf8.DecodeRuneInString(str[i:])\n\t\ti += size\n\t\tstateMachine = stateMachine.next(r)\n\t\tswitch stateMachine {\n\t\tcase firstAlphaNum, alphaNum:\n\t\t\tb.WriteRune(unicode.ToLower(r))\n\t\tcase delimiter:\n\t\t\tb.WriteByte('_')\n\t\t}\n\t}\n\tif stateMachine == idle {\n\t\treturn string(bytes.TrimSuffix(b.Bytes(), []byte{'_'}))\n\t}\n\treturn b.String()\n}\n\nfunc isAlphaNum(r rune) bool {\n\treturn unicode.IsLetter(r) || unicode.IsNumber(r)\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 0.671875,
          "content": "package goose\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCamelSnake(t *testing.T) {\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tin    string\n\t\tcamel string\n\t\tsnake string\n\t}{\n\t\t{in: \"Add updated_at to users table\", camel: \"AddUpdatedAtToUsersTable\", snake: \"add_updated_at_to_users_table\"},\n\t\t{in: \"$()&^%(_--crazy__--input$)\", camel: \"CrazyInput\", snake: \"crazy_input\"},\n\t}\n\n\tfor _, test := range tt {\n\t\tif got := camelCase(test.in); got != test.camel {\n\t\t\tt.Errorf(\"unexpected CamelCase for input(%q), got %q, want %q\", test.in, got, test.camel)\n\t\t}\n\t\tif got := snakeCase(test.in); got != test.snake {\n\t\t\tt.Errorf(\"unexpected snake_case for input(%q), got %q, want %q\", test.in, got, test.snake)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 1.0048828125,
          "content": "#!/bin/sh\n# Adapted from the Deno installer: Copyright 2019 the Deno authors. All rights reserved. MIT license.\n# Ref: https://github.com/denoland/deno_install\n# TODO(everyone): Keep this script simple and easily auditable.\n\n# TODO(mf): this should work on Linux and macOS. Not intended for Windows.\n\nset -e\n\nos=$(uname -s | tr '[:upper:]' '[:lower:]')\narch=$(uname -m)\n\nif [ \"$arch\" = \"aarch64\" ]; then\n\tarch=\"arm64\"\nfi\n\nif [ $# -eq 0 ]; then\n\tgoose_uri=\"https://github.com/pressly/goose/releases/latest/download/goose_${os}_${arch}\"\nelse\n\tgoose_uri=\"https://github.com/pressly/goose/releases/download/${1}/goose_${os}_${arch}\"\nfi\n\ngoose_install=\"${GOOSE_INSTALL:-/usr/local}\"\nbin_dir=\"${goose_install}/bin\"\nexe=\"${bin_dir}/goose\"\n\nif [ ! -d \"${bin_dir}\" ]; then\n\tmkdir -p \"${bin_dir}\"\nfi\n\ncurl --silent --show-error --location --fail --location --output \"${exe}\" \"$goose_uri\"\nchmod +x \"${exe}\"\n\necho \"Goose was installed successfully to ${exe}\"\nif command -v goose >/dev/null; then\n\techo \"Run 'goose --help' to get started\"\nfi\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "lock",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 0.853515625,
          "content": "package goose\n\nimport (\n\tstd \"log\"\n)\n\nvar log Logger = &stdLogger{}\n\n// Logger is standard logger interface\ntype Logger interface {\n\tFatalf(format string, v ...interface{})\n\tPrintf(format string, v ...interface{})\n}\n\n// SetLogger sets the logger for package output\nfunc SetLogger(l Logger) {\n\tlog = l\n}\n\n// stdLogger is a default logger that outputs to a stdlib's log.std logger.\ntype stdLogger struct{}\n\nfunc (*stdLogger) Fatalf(format string, v ...interface{}) { std.Fatalf(format, v...) }\nfunc (*stdLogger) Printf(format string, v ...interface{}) { std.Printf(format, v...) }\n\n// NopLogger returns a logger that discards all logged output.\nfunc NopLogger() Logger {\n\treturn &nopLogger{}\n}\n\ntype nopLogger struct{}\n\nvar _ Logger = (*nopLogger)(nil)\n\nfunc (*nopLogger) Fatalf(format string, v ...interface{}) {}\nfunc (*nopLogger) Printf(format string, v ...interface{}) {}\n"
        },
        {
          "name": "migrate.go",
          "type": "blob",
          "size": 10.6669921875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"math\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\t// ErrNoMigrationFiles when no migration files have been found.\n\tErrNoMigrationFiles = errors.New(\"no migration files found\")\n\t// ErrNoCurrentVersion when a current migration version is not found.\n\tErrNoCurrentVersion = errors.New(\"no current version found\")\n\t// ErrNoNextVersion when the next migration version is not found.\n\tErrNoNextVersion = errors.New(\"no next version found\")\n\t// MaxVersion is the maximum allowed version.\n\tMaxVersion int64 = math.MaxInt64\n)\n\n// Migrations slice.\ntype Migrations []*Migration\n\n// helpers so we can use pkg sort\nfunc (ms Migrations) Len() int      { return len(ms) }\nfunc (ms Migrations) Swap(i, j int) { ms[i], ms[j] = ms[j], ms[i] }\nfunc (ms Migrations) Less(i, j int) bool {\n\tif ms[i].Version == ms[j].Version {\n\t\tpanic(fmt.Sprintf(\"goose: duplicate version %v detected:\\n%v\\n%v\", ms[i].Version, ms[i].Source, ms[j].Source))\n\t}\n\treturn ms[i].Version < ms[j].Version\n}\n\n// Current gets the current migration.\nfunc (ms Migrations) Current(current int64) (*Migration, error) {\n\tfor i, migration := range ms {\n\t\tif migration.Version == current {\n\t\t\treturn ms[i], nil\n\t\t}\n\t}\n\n\treturn nil, ErrNoCurrentVersion\n}\n\n// Next gets the next migration.\nfunc (ms Migrations) Next(current int64) (*Migration, error) {\n\tfor i, migration := range ms {\n\t\tif migration.Version > current {\n\t\t\treturn ms[i], nil\n\t\t}\n\t}\n\n\treturn nil, ErrNoNextVersion\n}\n\n// Previous : Get the previous migration.\nfunc (ms Migrations) Previous(current int64) (*Migration, error) {\n\tfor i := len(ms) - 1; i >= 0; i-- {\n\t\tif ms[i].Version < current {\n\t\t\treturn ms[i], nil\n\t\t}\n\t}\n\n\treturn nil, ErrNoNextVersion\n}\n\n// Last gets the last migration.\nfunc (ms Migrations) Last() (*Migration, error) {\n\tif len(ms) == 0 {\n\t\treturn nil, ErrNoNextVersion\n\t}\n\n\treturn ms[len(ms)-1], nil\n}\n\n// Versioned gets versioned migrations.\nfunc (ms Migrations) versioned() (Migrations, error) {\n\tvar migrations Migrations\n\n\t// assume that the user will never have more than 19700101000000 migrations\n\tfor _, m := range ms {\n\t\t// parse version as timestamp\n\t\tversionTime, err := time.Parse(timestampFormat, fmt.Sprintf(\"%d\", m.Version))\n\n\t\tif versionTime.Before(time.Unix(0, 0)) || err != nil {\n\t\t\tmigrations = append(migrations, m)\n\t\t}\n\t}\n\n\treturn migrations, nil\n}\n\n// Timestamped gets the timestamped migrations.\nfunc (ms Migrations) timestamped() (Migrations, error) {\n\tvar migrations Migrations\n\n\t// assume that the user will never have more than 19700101000000 migrations\n\tfor _, m := range ms {\n\t\t// parse version as timestamp\n\t\tversionTime, err := time.Parse(timestampFormat, fmt.Sprintf(\"%d\", m.Version))\n\t\tif err != nil {\n\t\t\t// probably not a timestamp\n\t\t\tcontinue\n\t\t}\n\n\t\tif versionTime.After(time.Unix(0, 0)) {\n\t\t\tmigrations = append(migrations, m)\n\t\t}\n\t}\n\treturn migrations, nil\n}\n\nfunc (ms Migrations) String() string {\n\tstr := \"\"\n\tfor _, m := range ms {\n\t\tstr += fmt.Sprintln(m)\n\t}\n\treturn str\n}\n\nfunc collectMigrationsFS(\n\tfsys fs.FS,\n\tdirpath string,\n\tcurrent, target int64,\n\tregistered map[int64]*Migration,\n) (Migrations, error) {\n\tif _, err := fs.Stat(fsys, dirpath); err != nil {\n\t\tif errors.Is(err, fs.ErrNotExist) {\n\t\t\treturn nil, fmt.Errorf(\"%s directory does not exist\", dirpath)\n\t\t}\n\t\treturn nil, err\n\t}\n\tvar migrations Migrations\n\t// SQL migration files.\n\tsqlMigrationFiles, err := fs.Glob(fsys, path.Join(dirpath, \"*.sql\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, file := range sqlMigrationFiles {\n\t\tv, err := NumericComponent(file)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse SQL migration file %q: %w\", file, err)\n\t\t}\n\t\tif versionFilter(v, current, target) {\n\t\t\tmigrations = append(migrations, &Migration{\n\t\t\t\tVersion:  v,\n\t\t\t\tNext:     -1,\n\t\t\t\tPrevious: -1,\n\t\t\t\tSource:   file,\n\t\t\t})\n\t\t}\n\t}\n\t// Go migration files.\n\tgoMigrations, err := collectGoMigrations(fsys, dirpath, registered, current, target)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmigrations = append(migrations, goMigrations...)\n\tif len(migrations) == 0 {\n\t\treturn nil, ErrNoMigrationFiles\n\t}\n\treturn sortAndConnectMigrations(migrations), nil\n}\n\n// CollectMigrations returns all the valid looking migration scripts in the\n// migrations folder and go func registry, and key them by version.\nfunc CollectMigrations(dirpath string, current, target int64) (Migrations, error) {\n\treturn collectMigrationsFS(baseFS, dirpath, current, target, registeredGoMigrations)\n}\n\nfunc sortAndConnectMigrations(migrations Migrations) Migrations {\n\tsort.Sort(migrations)\n\n\t// now that we're sorted in the appropriate direction,\n\t// populate next and previous for each migration\n\tfor i, m := range migrations {\n\t\tprev := int64(-1)\n\t\tif i > 0 {\n\t\t\tprev = migrations[i-1].Version\n\t\t\tmigrations[i-1].Next = m.Version\n\t\t}\n\t\tmigrations[i].Previous = prev\n\t}\n\n\treturn migrations\n}\n\nfunc versionFilter(v, current, target int64) bool {\n\tif target > current {\n\t\treturn v > current && v <= target\n\t}\n\tif target < current {\n\t\treturn v <= current && v > target\n\t}\n\treturn false\n}\n\n// EnsureDBVersion retrieves the current version for this DB.\n// Create and initialize the DB version table if it doesn't exist.\nfunc EnsureDBVersion(db *sql.DB) (int64, error) {\n\tctx := context.Background()\n\treturn EnsureDBVersionContext(ctx, db)\n}\n\n// EnsureDBVersionContext retrieves the current version for this DB.\n// Create and initialize the DB version table if it doesn't exist.\nfunc EnsureDBVersionContext(ctx context.Context, db *sql.DB) (int64, error) {\n\tdbMigrations, err := store.ListMigrations(ctx, db, TableName())\n\tif err != nil {\n\t\treturn 0, createVersionTable(ctx, db)\n\t}\n\t// The most recent record for each migration specifies\n\t// whether it has been applied or rolled back.\n\t// The first version we find that has been applied is the current version.\n\t//\n\t// TODO(mf): for historic reasons, we continue to use the is_applied column,\n\t// but at some point we need to deprecate this logic and ideally remove\n\t// this column.\n\t//\n\t// For context, see:\n\t// https://github.com/pressly/goose/pull/131#pullrequestreview-178409168\n\t//\n\t// The dbMigrations list is expected to be ordered by descending ID. But\n\t// in the future we should be able to query the last record only.\n\tskipLookup := make(map[int64]struct{})\n\tfor _, m := range dbMigrations {\n\t\t// Have we already marked this version to be skipped?\n\t\tif _, ok := skipLookup[m.VersionID]; ok {\n\t\t\tcontinue\n\t\t}\n\t\t// If version has been applied we are done.\n\t\tif m.IsApplied {\n\t\t\treturn m.VersionID, nil\n\t\t}\n\t\t// Latest version of migration has not been applied.\n\t\tskipLookup[m.VersionID] = struct{}{}\n\t}\n\treturn 0, ErrNoNextVersion\n}\n\n// createVersionTable creates the db version table and inserts the\n// initial 0 value into it.\nfunc createVersionTable(ctx context.Context, db *sql.DB) error {\n\ttxn, err := db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := store.CreateVersionTable(ctx, txn, TableName()); err != nil {\n\t\t_ = txn.Rollback()\n\t\treturn err\n\t}\n\tif err := store.InsertVersion(ctx, txn, TableName(), 0); err != nil {\n\t\t_ = txn.Rollback()\n\t\treturn err\n\t}\n\treturn txn.Commit()\n}\n\n// GetDBVersion is an alias for EnsureDBVersion, but returns -1 in error.\nfunc GetDBVersion(db *sql.DB) (int64, error) {\n\tctx := context.Background()\n\treturn GetDBVersionContext(ctx, db)\n}\n\n// GetDBVersionContext is an alias for EnsureDBVersion, but returns -1 in error.\nfunc GetDBVersionContext(ctx context.Context, db *sql.DB) (int64, error) {\n\tversion, err := EnsureDBVersionContext(ctx, db)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\treturn version, nil\n}\n\n// collectGoMigrations collects Go migrations from the filesystem and merges them with registered\n// migrations.\n//\n// If Go migrations have been registered globally, with [goose.AddNamedMigration...], but there are\n// no corresponding .go files in the filesystem, add them to the migrations slice.\n//\n// If Go migrations have been registered, and there are .go files in the filesystem dirpath, ONLY\n// include those in the migrations slices.\n//\n// Lastly, if there are .go files in the filesystem but they have not been registered, raise an\n// error. This is to prevent users from accidentally adding valid looking Go files to the migrations\n// folder without registering them.\nfunc collectGoMigrations(\n\tfsys fs.FS,\n\tdirpath string,\n\tregisteredGoMigrations map[int64]*Migration,\n\tcurrent, target int64,\n) (Migrations, error) {\n\t// Sanity check registered migrations have the correct version prefix.\n\tfor _, m := range registeredGoMigrations {\n\t\tif _, err := NumericComponent(m.Source); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse go migration file %s: %w\", m.Source, err)\n\t\t}\n\t}\n\tgoFiles, err := fs.Glob(fsys, path.Join(dirpath, \"*.go\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// If there are no Go files in the filesystem and no registered Go migrations, return early.\n\tif len(goFiles) == 0 && len(registeredGoMigrations) == 0 {\n\t\treturn nil, nil\n\t}\n\ttype source struct {\n\t\tfullpath string\n\t\tversion  int64\n\t}\n\t// Find all Go files that have a version prefix and are within the requested range.\n\tvar sources []source\n\tfor _, fullpath := range goFiles {\n\t\tv, err := NumericComponent(fullpath)\n\t\tif err != nil {\n\t\t\tcontinue // Skip any files that don't have version prefix.\n\t\t}\n\t\tif strings.HasSuffix(fullpath, \"_test.go\") {\n\t\t\tcontinue // Skip Go test files.\n\t\t}\n\t\tif versionFilter(v, current, target) {\n\t\t\tsources = append(sources, source{\n\t\t\t\tfullpath: fullpath,\n\t\t\t\tversion:  v,\n\t\t\t})\n\t\t}\n\t}\n\tvar (\n\t\tmigrations Migrations\n\t)\n\tif len(sources) > 0 {\n\t\tfor _, s := range sources {\n\t\t\tmigration, ok := registeredGoMigrations[s.version]\n\t\t\tif ok {\n\t\t\t\tmigrations = append(migrations, migration)\n\t\t\t} else {\n\t\t\t\t// TODO(mf): something that bothers me about this implementation is it will be\n\t\t\t\t// lazily evaluated and the error will only be raised if the user tries to run the\n\t\t\t\t// migration. It would be better to raise an error much earlier in the process.\n\t\t\t\tmigrations = append(migrations, &Migration{\n\t\t\t\t\tVersion:    s.version,\n\t\t\t\t\tNext:       -1,\n\t\t\t\t\tPrevious:   -1,\n\t\t\t\t\tSource:     s.fullpath,\n\t\t\t\t\tRegistered: false,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Some users may register Go migrations manually via AddNamedMigration_ functions but not\n\t\t// provide the corresponding .go files in the filesystem. In this case, we include them\n\t\t// wholesale in the migrations slice.\n\t\t//\n\t\t// This is a valid use case because users may want to build a custom binary that only embeds\n\t\t// the SQL migration files and some other mechanism for registering Go migrations.\n\t\tfor _, migration := range registeredGoMigrations {\n\t\t\tv, err := NumericComponent(migration.Source)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not parse go migration file %s: %w\", migration.Source, err)\n\t\t\t}\n\t\t\tif versionFilter(v, current, target) {\n\t\t\t\tmigrations = append(migrations, migration)\n\t\t\t}\n\t\t}\n\t}\n\treturn migrations, nil\n}\n"
        },
        {
          "name": "migrate_test.go",
          "type": "blob",
          "size": 8.84375,
          "content": "package goose\n\nimport (\n\t\"io/fs\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMigrationSort(t *testing.T) {\n\tt.Parallel()\n\n\tms := Migrations{}\n\n\t// insert in any order\n\tms = append(ms, newMigration(20120000, \"test\"))\n\tms = append(ms, newMigration(20128000, \"test\"))\n\tms = append(ms, newMigration(20129000, \"test\"))\n\tms = append(ms, newMigration(20127000, \"test\"))\n\n\tms = sortAndConnectMigrations(ms)\n\n\tsorted := []int64{20120000, 20127000, 20128000, 20129000}\n\n\tvalidateMigrationSort(t, ms, sorted)\n}\n\nfunc newMigration(v int64, src string) *Migration {\n\treturn &Migration{Version: v, Previous: -1, Next: -1, Source: src}\n}\n\nfunc validateMigrationSort(t *testing.T, ms Migrations, sorted []int64) {\n\tt.Helper()\n\tfor i, m := range ms {\n\t\tif sorted[i] != m.Version {\n\t\t\tt.Error(\"incorrect sorted version\")\n\t\t}\n\n\t\tvar next, prev int64\n\n\t\tif i == 0 {\n\t\t\tprev = -1\n\t\t\tnext = ms[i+1].Version\n\t\t} else if i == len(ms)-1 {\n\t\t\tprev = ms[i-1].Version\n\t\t\tnext = -1\n\t\t} else {\n\t\t\tprev = ms[i-1].Version\n\t\t\tnext = ms[i+1].Version\n\t\t}\n\n\t\tif m.Next != next {\n\t\t\tt.Errorf(\"mismatched Next. v: %v, got %v, wanted %v\\n\", m, m.Next, next)\n\t\t}\n\n\t\tif m.Previous != prev {\n\t\t\tt.Errorf(\"mismatched Previous v: %v, got %v, wanted %v\\n\", m, m.Previous, prev)\n\t\t}\n\t}\n\n\tt.Log(ms)\n}\n\nfunc TestCollectMigrations(t *testing.T) {\n\t// Not safe to run in parallel\n\tt.Run(\"no_migration_files_found\", func(t *testing.T) {\n\t\ttmp := t.TempDir()\n\t\terr := os.MkdirAll(filepath.Join(tmp, \"migrations-test\"), 0755)\n\t\trequire.NoError(t, err)\n\t\t_, err = collectMigrationsFS(os.DirFS(tmp), \"migrations-test\", 0, math.MaxInt64, nil)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"no migration files found\")\n\t})\n\tt.Run(\"filesystem_registered_with_single_dirpath\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tfile1, file2 := \"09081_a.go\", \"09082_b.go\"\n\t\tfile3, file4 := \"19081_a.go\", \"19082_b.go\"\n\t\tAddNamedMigrationContext(file1, nil, nil)\n\t\tAddNamedMigrationContext(file2, nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 2)\n\t\ttmp := t.TempDir()\n\t\tdir := filepath.Join(tmp, \"migrations\", \"dir1\")\n\t\terr := os.MkdirAll(dir, 0755)\n\t\trequire.NoError(t, err)\n\t\tcreateEmptyFile(t, dir, file1)\n\t\tcreateEmptyFile(t, dir, file2)\n\t\tcreateEmptyFile(t, dir, file3)\n\t\tcreateEmptyFile(t, dir, file4)\n\t\tfsys := os.DirFS(tmp)\n\t\tfiles, err := fs.ReadDir(fsys, \"migrations/dir1\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, files, 4)\n\t\tall, err := collectMigrationsFS(fsys, \"migrations/dir1\", 0, math.MaxInt64, registeredGoMigrations)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, all, 4)\n\t\trequire.EqualValues(t, 9081, all[0].Version)\n\t\trequire.EqualValues(t, 9082, all[1].Version)\n\t\trequire.EqualValues(t, 19081, all[2].Version)\n\t\trequire.EqualValues(t, 19082, all[3].Version)\n\t})\n\tt.Run(\"filesystem_registered_with_multiple_dirpath\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tfile1, file2, file3 := \"00001_a.go\", \"00002_b.go\", \"01111_c.go\"\n\t\tAddNamedMigrationContext(file1, nil, nil)\n\t\tAddNamedMigrationContext(file2, nil, nil)\n\t\tAddNamedMigrationContext(file3, nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 3)\n\t\ttmp := t.TempDir()\n\t\tdir1 := filepath.Join(tmp, \"migrations\", \"dir1\")\n\t\tdir2 := filepath.Join(tmp, \"migrations\", \"dir2\")\n\t\terr := os.MkdirAll(dir1, 0755)\n\t\trequire.NoError(t, err)\n\t\terr = os.MkdirAll(dir2, 0755)\n\t\trequire.NoError(t, err)\n\t\tcreateEmptyFile(t, dir1, file1)\n\t\tcreateEmptyFile(t, dir1, file2)\n\t\tcreateEmptyFile(t, dir2, file3)\n\t\tfsys := os.DirFS(tmp)\n\t\t// Validate if dirpath 1 is specified we get the two Go migrations in migrations/dir1 folder\n\t\t// even though 3 Go migrations have been registered.\n\t\t{\n\t\t\tall, err := collectMigrationsFS(fsys, \"migrations/dir1\", 0, math.MaxInt64, registeredGoMigrations)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, all, 2)\n\t\t\trequire.EqualValues(t, 1, all[0].Version)\n\t\t\trequire.EqualValues(t, 2, all[1].Version)\n\t\t}\n\t\t// Validate if dirpath 2 is specified we only get the one Go migration in migrations/dir2 folder\n\t\t// even though 3 Go migrations have been registered.\n\t\t{\n\t\t\tall, err := collectMigrationsFS(fsys, \"migrations/dir2\", 0, math.MaxInt64, registeredGoMigrations)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, all, 1)\n\t\t\trequire.EqualValues(t, 1111, all[0].Version)\n\t\t}\n\t})\n\tt.Run(\"empty_filesystem_registered_manually\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tAddNamedMigrationContext(\"00101_a.go\", nil, nil)\n\t\tAddNamedMigrationContext(\"00102_b.go\", nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 2)\n\t\ttmp := t.TempDir()\n\t\terr := os.MkdirAll(filepath.Join(tmp, \"migrations\"), 0755)\n\t\trequire.NoError(t, err)\n\t\tall, err := collectMigrationsFS(os.DirFS(tmp), \"migrations\", 0, math.MaxInt64, registeredGoMigrations)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, all, 2)\n\t\trequire.EqualValues(t, 101, all[0].Version)\n\t\trequire.EqualValues(t, 102, all[1].Version)\n\t})\n\tt.Run(\"unregistered_go_migrations\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tfile1, file2, file3 := \"00001_a.go\", \"00998_b.go\", \"00999_c.go\"\n\t\t// Only register file1 and file3, somehow user forgot to init in the\n\t\t// valid looking file2 Go migration\n\t\tAddNamedMigrationContext(file1, nil, nil)\n\t\tAddNamedMigrationContext(file3, nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 2)\n\t\ttmp := t.TempDir()\n\t\tdir1 := filepath.Join(tmp, \"migrations\", \"dir1\")\n\t\terr := os.MkdirAll(dir1, 0755)\n\t\trequire.NoError(t, err)\n\t\t// Include the valid file2 with file1, file3. But remember, it has NOT been\n\t\t// registered.\n\t\tcreateEmptyFile(t, dir1, file1)\n\t\tcreateEmptyFile(t, dir1, file2)\n\t\tcreateEmptyFile(t, dir1, file3)\n\t\tall, err := collectMigrationsFS(os.DirFS(tmp), \"migrations/dir1\", 0, math.MaxInt64, registeredGoMigrations)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, all, 3)\n\t\trequire.EqualValues(t, 1, all[0].Version)\n\t\trequire.True(t, all[0].Registered)\n\t\trequire.EqualValues(t, 998, all[1].Version)\n\t\t// This migrations is marked unregistered and will lazily raise an error if/when this\n\t\t// migration is run\n\t\trequire.False(t, all[1].Registered)\n\t\trequire.EqualValues(t, 999, all[2].Version)\n\t\trequire.True(t, all[2].Registered)\n\t})\n\tt.Run(\"with_skipped_go_files\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tfile1, file2, file3, file4 := \"00001_a.go\", \"00002_b.sql\", \"00999_c_test.go\", \"embed.go\"\n\t\tAddNamedMigrationContext(file1, nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 1)\n\t\ttmp := t.TempDir()\n\t\tdir1 := filepath.Join(tmp, \"migrations\", \"dir1\")\n\t\terr := os.MkdirAll(dir1, 0755)\n\t\trequire.NoError(t, err)\n\t\tcreateEmptyFile(t, dir1, file1)\n\t\tcreateEmptyFile(t, dir1, file2)\n\t\tcreateEmptyFile(t, dir1, file3)\n\t\tcreateEmptyFile(t, dir1, file4)\n\t\tall, err := collectMigrationsFS(os.DirFS(tmp), \"migrations/dir1\", 0, math.MaxInt64, registeredGoMigrations)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, all, 2)\n\t\trequire.EqualValues(t, 1, all[0].Version)\n\t\trequire.True(t, all[0].Registered)\n\t\trequire.EqualValues(t, 2, all[1].Version)\n\t\trequire.False(t, all[1].Registered)\n\t})\n\tt.Run(\"current_and_target\", func(t *testing.T) {\n\t\tt.Cleanup(func() { clearMap(registeredGoMigrations) })\n\t\tfile1, file2, file3 := \"01001_a.go\", \"01002_b.sql\", \"01003_c.go\"\n\t\tAddNamedMigrationContext(file1, nil, nil)\n\t\tAddNamedMigrationContext(file3, nil, nil)\n\t\trequire.Len(t, registeredGoMigrations, 2)\n\t\ttmp := t.TempDir()\n\t\tdir1 := filepath.Join(tmp, \"migrations\", \"dir1\")\n\t\terr := os.MkdirAll(dir1, 0755)\n\t\trequire.NoError(t, err)\n\t\tcreateEmptyFile(t, dir1, file1)\n\t\tcreateEmptyFile(t, dir1, file2)\n\t\tcreateEmptyFile(t, dir1, file3)\n\t\tall, err := collectMigrationsFS(os.DirFS(tmp), \"migrations/dir1\", 1001, 1003, registeredGoMigrations)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, all, 2)\n\t\trequire.EqualValues(t, 1002, all[0].Version)\n\t\trequire.EqualValues(t, 1003, all[1].Version)\n\t})\n}\n\nfunc TestVersionFilter(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tv       int64\n\t\tcurrent int64\n\t\ttarget  int64\n\t\twant    bool\n\t}{\n\t\t{2, 1, 3, true},  // v is within the range\n\t\t{4, 1, 3, false}, // v is outside the range\n\t\t{2, 3, 1, true},  // v is within the reversed range\n\t\t{4, 3, 1, false}, // v is outside the reversed range\n\t\t{3, 1, 3, true},  // v is equal to target\n\t\t{1, 1, 3, false}, // v is equal to current, not within the range\n\t\t{1, 3, 1, false}, // v is equal to current, not within the reversed range\n\t\t// Always return false if current equal target\n\t\t{1, 2, 2, false},\n\t\t{2, 2, 2, false},\n\t\t{3, 2, 2, false},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := versionFilter(tc.v, tc.current, tc.target)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"versionFilter(%d, %d, %d) = %v, want %v\", tc.v, tc.current, tc.target, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\nfunc createEmptyFile(t *testing.T, dir, name string) {\n\tt.Helper()\n\tpath := filepath.Join(dir, name)\n\tf, err := os.Create(path)\n\trequire.NoError(t, err)\n\tdefer f.Close()\n}\n\nfunc clearMap(m map[int64]*Migration) {\n\tfor k := range m {\n\t\tdelete(m, k)\n\t}\n}\n"
        },
        {
          "name": "migration.go",
          "type": "blob",
          "size": 11.43359375,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pressly/goose/v3/internal/sqlparser\"\n)\n\n// NewGoMigration creates a new Go migration.\n//\n// Both up and down functions may be nil, in which case the migration will be recorded in the\n// versions table but no functions will be run. This is useful for recording (up) or deleting (down)\n// a version without running any functions. See [GoFunc] for more details.\nfunc NewGoMigration(version int64, up, down *GoFunc) *Migration {\n\tm := &Migration{\n\t\tType:       TypeGo,\n\t\tRegistered: true,\n\t\tVersion:    version,\n\t\tNext:       -1, Previous: -1,\n\t\tgoUp:      &GoFunc{Mode: TransactionEnabled},\n\t\tgoDown:    &GoFunc{Mode: TransactionEnabled},\n\t\tconstruct: true,\n\t}\n\tupdateMode := func(f *GoFunc) *GoFunc {\n\t\t// infer mode from function\n\t\tif f.Mode == 0 {\n\t\t\tif f.RunTx != nil && f.RunDB == nil {\n\t\t\t\tf.Mode = TransactionEnabled\n\t\t\t}\n\t\t\tif f.RunTx == nil && f.RunDB != nil {\n\t\t\t\tf.Mode = TransactionDisabled\n\t\t\t}\n\t\t\t// Always default to TransactionEnabled if both functions are nil. This is the most\n\t\t\t// common use case.\n\t\t\tif f.RunDB == nil && f.RunTx == nil {\n\t\t\t\tf.Mode = TransactionEnabled\n\t\t\t}\n\t\t}\n\t\treturn f\n\t}\n\t// To maintain backwards compatibility, we set ALL legacy functions. In a future major version,\n\t// we will remove these fields in favor of [GoFunc].\n\t//\n\t// Note, this function does not do any validation. Validation is lazily done when the migration\n\t// is registered.\n\tif up != nil {\n\t\tm.goUp = updateMode(up)\n\n\t\tif up.RunDB != nil {\n\t\t\tm.UpFnNoTxContext = up.RunDB          // func(context.Context, *sql.DB) error\n\t\t\tm.UpFnNoTx = withoutContext(up.RunDB) // func(*sql.DB) error\n\t\t}\n\t\tif up.RunTx != nil {\n\t\t\tm.UseTx = true\n\t\t\tm.UpFnContext = up.RunTx          // func(context.Context, *sql.Tx) error\n\t\t\tm.UpFn = withoutContext(up.RunTx) // func(*sql.Tx) error\n\t\t}\n\t}\n\tif down != nil {\n\t\tm.goDown = updateMode(down)\n\n\t\tif down.RunDB != nil {\n\t\t\tm.DownFnNoTxContext = down.RunDB          // func(context.Context, *sql.DB) error\n\t\t\tm.DownFnNoTx = withoutContext(down.RunDB) // func(*sql.DB) error\n\t\t}\n\t\tif down.RunTx != nil {\n\t\t\tm.UseTx = true\n\t\t\tm.DownFnContext = down.RunTx          // func(context.Context, *sql.Tx) error\n\t\t\tm.DownFn = withoutContext(down.RunTx) // func(*sql.Tx) error\n\t\t}\n\t}\n\treturn m\n}\n\n// Migration struct represents either a SQL or Go migration.\n//\n// Avoid constructing migrations manually, use [NewGoMigration] function.\ntype Migration struct {\n\tType    MigrationType\n\tVersion int64\n\t// Source is the path to the .sql script or .go file. It may be empty for Go migrations that\n\t// have been registered globally and don't have a source file.\n\tSource string\n\n\tUpFnContext, DownFnContext         GoMigrationContext\n\tUpFnNoTxContext, DownFnNoTxContext GoMigrationNoTxContext\n\n\t// These fields will be removed in a future major version. They are here for backwards\n\t// compatibility and are an implementation detail.\n\tRegistered bool\n\tUseTx      bool\n\tNext       int64 // next version, or -1 if none\n\tPrevious   int64 // previous version, -1 if none\n\n\t// We still save the non-context versions in the struct in case someone is using them. Goose\n\t// does not use these internally anymore in favor of the context-aware versions. These fields\n\t// will be removed in a future major version.\n\n\tUpFn       GoMigration     // Deprecated: use UpFnContext instead.\n\tDownFn     GoMigration     // Deprecated: use DownFnContext instead.\n\tUpFnNoTx   GoMigrationNoTx // Deprecated: use UpFnNoTxContext instead.\n\tDownFnNoTx GoMigrationNoTx // Deprecated: use DownFnNoTxContext instead.\n\n\tnoVersioning bool\n\n\t// These fields are used internally by goose and users are not expected to set them. Instead,\n\t// use [NewGoMigration] to create a new go migration.\n\tconstruct    bool\n\tgoUp, goDown *GoFunc\n\n\tsql sqlMigration\n}\n\ntype sqlMigration struct {\n\t// The Parsed field is used to track whether the SQL migration has been parsed. It serves as an\n\t// optimization to avoid parsing migrations that may never be needed. Typically, migrations are\n\t// incremental, and users often run only the most recent ones, making parsing of prior\n\t// migrations unnecessary in most cases.\n\tParsed bool\n\n\t// Parsed must be set to true before the following fields are used.\n\tUseTx bool\n\tUp    []string\n\tDown  []string\n}\n\n// GoFunc represents a Go migration function.\ntype GoFunc struct {\n\t// Exactly one of these must be set, or both must be nil.\n\tRunTx func(ctx context.Context, tx *sql.Tx) error\n\t// -- OR --\n\tRunDB func(ctx context.Context, db *sql.DB) error\n\n\t// Mode is the transaction mode for the migration. When one of the run functions is set, the\n\t// mode will be inferred from the function and the field is ignored. Users do not need to set\n\t// this field when supplying a run function.\n\t//\n\t// If both run functions are nil, the mode defaults to TransactionEnabled. The use case for nil\n\t// functions is to record a version in the version table without invoking a Go migration\n\t// function.\n\t//\n\t// The only time this field is required is if BOTH run functions are nil AND you want to\n\t// override the default transaction mode.\n\tMode TransactionMode\n}\n\n// TransactionMode represents the possible transaction modes for a migration.\ntype TransactionMode int\n\nconst (\n\tTransactionEnabled TransactionMode = iota + 1\n\tTransactionDisabled\n)\n\nfunc (m TransactionMode) String() string {\n\tswitch m {\n\tcase TransactionEnabled:\n\t\treturn \"transaction_enabled\"\n\tcase TransactionDisabled:\n\t\treturn \"transaction_disabled\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"unknown transaction mode (%d)\", m)\n\t}\n}\n\n// MigrationRecord struct.\n//\n// Deprecated: unused and will be removed in a future major version.\ntype MigrationRecord struct {\n\tVersionID int64\n\tTStamp    time.Time\n\tIsApplied bool // was this a result of up() or down()\n}\n\nfunc (m *Migration) String() string {\n\treturn fmt.Sprint(m.Source)\n}\n\n// Up runs an up migration.\nfunc (m *Migration) Up(db *sql.DB) error {\n\tctx := context.Background()\n\treturn m.UpContext(ctx, db)\n}\n\n// UpContext runs an up migration.\nfunc (m *Migration) UpContext(ctx context.Context, db *sql.DB) error {\n\tif err := m.run(ctx, db, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Down runs a down migration.\nfunc (m *Migration) Down(db *sql.DB) error {\n\tctx := context.Background()\n\treturn m.DownContext(ctx, db)\n}\n\n// DownContext runs a down migration.\nfunc (m *Migration) DownContext(ctx context.Context, db *sql.DB) error {\n\tif err := m.run(ctx, db, false); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *Migration) run(ctx context.Context, db *sql.DB, direction bool) error {\n\tswitch filepath.Ext(m.Source) {\n\tcase \".sql\":\n\t\tf, err := baseFS.Open(m.Source)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"ERROR %v: failed to open SQL migration file: %w\", filepath.Base(m.Source), err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tstatements, useTx, err := sqlparser.ParseSQLMigration(f, sqlparser.FromBool(direction), verbose)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"ERROR %v: failed to parse SQL migration file: %w\", filepath.Base(m.Source), err)\n\t\t}\n\n\t\tstart := time.Now()\n\t\tif err := runSQLMigration(ctx, db, statements, useTx, m.Version, direction, m.noVersioning); err != nil {\n\t\t\treturn fmt.Errorf(\"ERROR %v: failed to run SQL migration: %w\", filepath.Base(m.Source), err)\n\t\t}\n\t\tfinish := truncateDuration(time.Since(start))\n\n\t\tif len(statements) > 0 {\n\t\t\tlog.Printf(\"OK   %s (%s)\\n\", filepath.Base(m.Source), finish)\n\t\t} else {\n\t\t\tlog.Printf(\"EMPTY %s (%s)\\n\", filepath.Base(m.Source), finish)\n\t\t}\n\n\tcase \".go\":\n\t\tif !m.Registered {\n\t\t\treturn fmt.Errorf(\"ERROR %v: failed to run Go migration: Go functions must be registered and built into a custom binary (see https://github.com/pressly/goose/tree/master/examples/go-migrations)\", m.Source)\n\t\t}\n\t\tstart := time.Now()\n\t\tvar empty bool\n\t\tif m.UseTx {\n\t\t\t// Run go-based migration inside a tx.\n\t\t\tfn := m.DownFnContext\n\t\t\tif direction {\n\t\t\t\tfn = m.UpFnContext\n\t\t\t}\n\t\t\tempty = (fn == nil)\n\t\t\tif err := runGoMigration(\n\t\t\t\tctx,\n\t\t\t\tdb,\n\t\t\t\tfn,\n\t\t\t\tm.Version,\n\t\t\t\tdirection,\n\t\t\t\t!m.noVersioning,\n\t\t\t); err != nil {\n\t\t\t\treturn fmt.Errorf(\"ERROR go migration: %q: %w\", filepath.Base(m.Source), err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Run go-based migration outside a tx.\n\t\t\tfn := m.DownFnNoTxContext\n\t\t\tif direction {\n\t\t\t\tfn = m.UpFnNoTxContext\n\t\t\t}\n\t\t\tempty = (fn == nil)\n\t\t\tif err := runGoMigrationNoTx(\n\t\t\t\tctx,\n\t\t\t\tdb,\n\t\t\t\tfn,\n\t\t\t\tm.Version,\n\t\t\t\tdirection,\n\t\t\t\t!m.noVersioning,\n\t\t\t); err != nil {\n\t\t\t\treturn fmt.Errorf(\"ERROR go migration no tx: %q: %w\", filepath.Base(m.Source), err)\n\t\t\t}\n\t\t}\n\t\tfinish := truncateDuration(time.Since(start))\n\t\tif !empty {\n\t\t\tlog.Printf(\"OK   %s (%s)\\n\", filepath.Base(m.Source), finish)\n\t\t} else {\n\t\t\tlog.Printf(\"EMPTY %s (%s)\\n\", filepath.Base(m.Source), finish)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc runGoMigrationNoTx(\n\tctx context.Context,\n\tdb *sql.DB,\n\tfn GoMigrationNoTxContext,\n\tversion int64,\n\tdirection bool,\n\trecordVersion bool,\n) error {\n\tif fn != nil {\n\t\t// Run go migration function.\n\t\tif err := fn(ctx, db); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to run go migration: %w\", err)\n\t\t}\n\t}\n\tif recordVersion {\n\t\treturn insertOrDeleteVersionNoTx(ctx, db, version, direction)\n\t}\n\treturn nil\n}\n\nfunc runGoMigration(\n\tctx context.Context,\n\tdb *sql.DB,\n\tfn GoMigrationContext,\n\tversion int64,\n\tdirection bool,\n\trecordVersion bool,\n) error {\n\tif fn == nil && !recordVersion {\n\t\treturn nil\n\t}\n\ttx, err := db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tif fn != nil {\n\t\t// Run go migration function.\n\t\tif err := fn(ctx, tx); err != nil {\n\t\t\t_ = tx.Rollback()\n\t\t\treturn fmt.Errorf(\"failed to run go migration: %w\", err)\n\t\t}\n\t}\n\tif recordVersion {\n\t\tif err := insertOrDeleteVersion(ctx, tx, version, direction); err != nil {\n\t\t\t_ = tx.Rollback()\n\t\t\treturn fmt.Errorf(\"failed to update version: %w\", err)\n\t\t}\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\treturn fmt.Errorf(\"failed to commit transaction: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc insertOrDeleteVersion(ctx context.Context, tx *sql.Tx, version int64, direction bool) error {\n\tif direction {\n\t\treturn store.InsertVersion(ctx, tx, TableName(), version)\n\t}\n\treturn store.DeleteVersion(ctx, tx, TableName(), version)\n}\n\nfunc insertOrDeleteVersionNoTx(ctx context.Context, db *sql.DB, version int64, direction bool) error {\n\tif direction {\n\t\treturn store.InsertVersionNoTx(ctx, db, TableName(), version)\n\t}\n\treturn store.DeleteVersionNoTx(ctx, db, TableName(), version)\n}\n\n// NumericComponent parses the version from the migration file name.\n//\n// XXX_descriptivename.ext where XXX specifies the version number and ext specifies the type of\n// migration, either .sql or .go.\nfunc NumericComponent(filename string) (int64, error) {\n\tbase := filepath.Base(filename)\n\tif ext := filepath.Ext(base); ext != \".go\" && ext != \".sql\" {\n\t\treturn 0, errors.New(\"migration file does not have .sql or .go file extension\")\n\t}\n\tidx := strings.Index(base, \"_\")\n\tif idx < 0 {\n\t\treturn 0, errors.New(\"no filename separator '_' found\")\n\t}\n\tn, err := strconv.ParseInt(base[:idx], 10, 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to parse version from migration file: %s: %w\", base, err)\n\t}\n\tif n < 1 {\n\t\treturn 0, errors.New(\"migration version must be greater than zero\")\n\t}\n\treturn n, nil\n}\n\nfunc truncateDuration(d time.Duration) time.Duration {\n\tfor _, v := range []time.Duration{\n\t\ttime.Second,\n\t\ttime.Millisecond,\n\t\ttime.Microsecond,\n\t} {\n\t\tif d > v {\n\t\t\treturn d.Round(v / time.Duration(100))\n\t\t}\n\t}\n\treturn d\n}\n\n// ref returns a string that identifies the migration. This is used for logging and error messages.\nfunc (m *Migration) ref() string {\n\treturn fmt.Sprintf(\"(type:%s,version:%d)\", m.Type, m.Version)\n}\n"
        },
        {
          "name": "migration_sql.go",
          "type": "blob",
          "size": 2.7958984375,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"regexp\"\n)\n\n// Run a migration specified in raw SQL.\n//\n// Sections of the script can be annotated with a special comment,\n// starting with \"-- +goose\" to specify whether the section should\n// be applied during an Up or Down migration\n//\n// All statements following an Up or Down annotation are grouped together\n// until another direction annotation is found.\nfunc runSQLMigration(\n\tctx context.Context,\n\tdb *sql.DB,\n\tstatements []string,\n\tuseTx bool,\n\tv int64,\n\tdirection bool,\n\tnoVersioning bool,\n) error {\n\tif useTx {\n\t\t// TRANSACTION.\n\n\t\tverboseInfo(\"Begin transaction\")\n\n\t\ttx, err := db.BeginTx(ctx, nil)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t\t}\n\n\t\tfor _, query := range statements {\n\t\t\tverboseInfo(\"Executing statement: %s\\n\", clearStatement(query))\n\t\t\tif _, err := tx.ExecContext(ctx, query); err != nil {\n\t\t\t\tverboseInfo(\"Rollback transaction\")\n\t\t\t\t_ = tx.Rollback()\n\t\t\t\treturn fmt.Errorf(\"failed to execute SQL query %q: %w\", clearStatement(query), err)\n\t\t\t}\n\t\t}\n\n\t\tif !noVersioning {\n\t\t\tif direction {\n\t\t\t\tif err := store.InsertVersion(ctx, tx, TableName(), v); err != nil {\n\t\t\t\t\tverboseInfo(\"Rollback transaction\")\n\t\t\t\t\t_ = tx.Rollback()\n\t\t\t\t\treturn fmt.Errorf(\"failed to insert new goose version: %w\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := store.DeleteVersion(ctx, tx, TableName(), v); err != nil {\n\t\t\t\t\tverboseInfo(\"Rollback transaction\")\n\t\t\t\t\t_ = tx.Rollback()\n\t\t\t\t\treturn fmt.Errorf(\"failed to delete goose version: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tverboseInfo(\"Commit transaction\")\n\t\tif err := tx.Commit(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to commit transaction: %w\", err)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// NO TRANSACTION.\n\tfor _, query := range statements {\n\t\tverboseInfo(\"Executing statement: %s\", clearStatement(query))\n\t\tif _, err := db.ExecContext(ctx, query); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute SQL query %q: %w\", clearStatement(query), err)\n\t\t}\n\t}\n\tif !noVersioning {\n\t\tif direction {\n\t\t\tif err := store.InsertVersionNoTx(ctx, db, TableName(), v); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to insert new goose version: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err := store.DeleteVersionNoTx(ctx, db, TableName(), v); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to delete goose version: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nconst (\n\tgrayColor  = \"\\033[90m\"\n\tresetColor = \"\\033[00m\"\n)\n\nfunc verboseInfo(s string, args ...interface{}) {\n\tif verbose {\n\t\tif noColor {\n\t\t\tlog.Printf(s, args...)\n\t\t} else {\n\t\t\tlog.Printf(grayColor+s+resetColor, args...)\n\t\t}\n\t}\n}\n\nvar (\n\tmatchSQLComments = regexp.MustCompile(`(?m)^--.*$[\\r\\n]*`)\n\tmatchEmptyEOL    = regexp.MustCompile(`(?m)^$[\\r\\n]*`) // TODO: Duplicate\n)\n\nfunc clearStatement(s string) string {\n\ts = matchSQLComments.ReplaceAllString(s, ``)\n\treturn matchEmptyEOL.ReplaceAllString(s, ``)\n}\n"
        },
        {
          "name": "osfs.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "package goose\n\nimport (\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// osFS wraps functions working with os filesystem to implement fs.FS interfaces.\ntype osFS struct{}\n\nfunc (osFS) Open(name string) (fs.File, error) { return os.Open(filepath.FromSlash(name)) }\n\nfunc (osFS) ReadDir(name string) ([]fs.DirEntry, error) { return os.ReadDir(filepath.FromSlash(name)) }\n\nfunc (osFS) Stat(name string) (fs.FileInfo, error) { return os.Stat(filepath.FromSlash(name)) }\n\nfunc (osFS) ReadFile(name string) ([]byte, error) { return os.ReadFile(filepath.FromSlash(name)) }\n\nfunc (osFS) Glob(pattern string) ([]string, error) { return filepath.Glob(filepath.FromSlash(pattern)) }\n\ntype noopFS struct{}\n\nvar _ fs.FS = noopFS{}\n\nfunc (f noopFS) Open(name string) (fs.File, error) {\n\treturn nil, os.ErrNotExist\n}\n"
        },
        {
          "name": "provider.go",
          "type": "blob",
          "size": 20.61328125,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/pressly/goose/v3/internal/controller\"\n\t\"github.com/pressly/goose/v3/internal/gooseutil\"\n\t\"github.com/pressly/goose/v3/internal/sqlparser\"\n\t\"go.uber.org/multierr\"\n)\n\n// Provider is a goose migration provider.\ntype Provider struct {\n\t// mu protects all accesses to the provider and must be held when calling operations on the\n\t// database.\n\tmu sync.Mutex\n\n\tdb               *sql.DB\n\tstore            *controller.StoreController\n\tversionTableOnce sync.Once\n\n\tfsys fs.FS\n\tcfg  config\n\n\t// migrations are ordered by version in ascending order. This list will never be empty and\n\t// contains all migrations known to the provider.\n\tmigrations []*Migration\n}\n\n// NewProvider returns a new goose provider.\n//\n// The caller is responsible for matching the database dialect with the database/sql driver. For\n// example, if the database dialect is \"postgres\", the database/sql driver could be\n// github.com/lib/pq or github.com/jackc/pgx. Each dialect has a corresponding [database.Dialect]\n// constant backed by a default [database.Store] implementation. For more advanced use cases, such\n// as using a custom table name or supplying a custom store implementation, see [WithStore].\n//\n// fsys is the filesystem used to read migration files, but may be nil. Most users will want to use\n// [os.DirFS], os.DirFS(\"path/to/migrations\"), to read migrations from the local filesystem.\n// However, it is possible to use a different \"filesystem\", such as [embed.FS] or filter out\n// migrations using [fs.Sub].\n//\n// See [ProviderOption] for more information on configuring the provider.\n//\n// Unless otherwise specified, all methods on Provider are safe for concurrent use.\nfunc NewProvider(dialect Dialect, db *sql.DB, fsys fs.FS, opts ...ProviderOption) (*Provider, error) {\n\tif db == nil {\n\t\treturn nil, errors.New(\"db must not be nil\")\n\t}\n\tif fsys == nil {\n\t\tfsys = noopFS{}\n\t}\n\tcfg := config{\n\t\tregistered:      make(map[int64]*Migration),\n\t\texcludePaths:    make(map[string]bool),\n\t\texcludeVersions: make(map[int64]bool),\n\t\tlogger:          &stdLogger{},\n\t}\n\tfor _, opt := range opts {\n\t\tif err := opt.apply(&cfg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// Allow users to specify a custom store implementation, but only if they don't specify a\n\t// dialect. If they specify a dialect, we'll use the default store implementation.\n\tif dialect == \"\" && cfg.store == nil {\n\t\treturn nil, errors.New(\"dialect must not be empty\")\n\t}\n\tif dialect != \"\" && cfg.store != nil {\n\t\treturn nil, errors.New(\"dialect must be empty when using a custom store implementation\")\n\t}\n\tvar store database.Store\n\tif dialect != \"\" {\n\t\tvar err error\n\t\tstore, err = database.NewStore(dialect, DefaultTablename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tstore = cfg.store\n\t}\n\tif store.Tablename() == \"\" {\n\t\treturn nil, errors.New(\"invalid store implementation: table name must not be empty\")\n\t}\n\treturn newProvider(db, store, fsys, cfg, registeredGoMigrations /* global */)\n}\n\nfunc newProvider(\n\tdb *sql.DB,\n\tstore database.Store,\n\tfsys fs.FS,\n\tcfg config,\n\tglobal map[int64]*Migration,\n) (*Provider, error) {\n\t// Collect migrations from the filesystem and merge with registered migrations.\n\t//\n\t// Note, we don't parse SQL migrations here. They are parsed lazily when required.\n\n\t// feat(mf): we could add a flag to parse SQL migrations eagerly. This would allow us to return\n\t// an error if there are any SQL parsing errors. This adds a bit overhead to startup though, so\n\t// we should make it optional.\n\tfilesystemSources, err := collectFilesystemSources(fsys, false, cfg.excludePaths, cfg.excludeVersions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tversionToGoMigration := make(map[int64]*Migration)\n\t// Add user-registered Go migrations from the provider.\n\tfor version, m := range cfg.registered {\n\t\tversionToGoMigration[version] = m\n\t}\n\t// Skip adding global Go migrations if explicitly disabled.\n\tif cfg.disableGlobalRegistry {\n\t\t// TODO(mf): let's add a warn-level log here to inform users if len(global) > 0. Would like\n\t\t// to add this once we're on go1.21 and leverage the new slog package.\n\t} else {\n\t\tfor version, m := range global {\n\t\t\tif _, ok := versionToGoMigration[version]; ok {\n\t\t\t\treturn nil, fmt.Errorf(\"global go migration conflicts with provider-registered go migration with version %d\", version)\n\t\t\t}\n\t\t\tversionToGoMigration[version] = m\n\t\t}\n\t}\n\t// At this point we have all registered unique Go migrations (if any). We need to merge them\n\t// with SQL migrations from the filesystem.\n\tmigrations, err := merge(filesystemSources, versionToGoMigration)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(migrations) == 0 {\n\t\treturn nil, ErrNoMigrations\n\t}\n\treturn &Provider{\n\t\tdb:         db,\n\t\tfsys:       fsys,\n\t\tcfg:        cfg,\n\t\tstore:      controller.NewStoreController(store),\n\t\tmigrations: migrations,\n\t}, nil\n}\n\n// Status returns the status of all migrations, merging the list of migrations from the database and\n// filesystem. The returned items are ordered by version, in ascending order.\nfunc (p *Provider) Status(ctx context.Context) ([]*MigrationStatus, error) {\n\treturn p.status(ctx)\n}\n\n// HasPending returns true if there are pending migrations to apply, otherwise, it returns false. If\n// out-of-order migrations are disabled, yet some are detected, this method returns an error.\n//\n// Note, this method will not use a SessionLocker if one is configured. This allows callers to check\n// for pending migrations without blocking or being blocked by other operations.\nfunc (p *Provider) HasPending(ctx context.Context) (bool, error) {\n\treturn p.hasPending(ctx)\n}\n\n// GetVersions returns the max database version and the target version to migrate to.\n//\n// Note, this method will not use a SessionLocker if one is configured. This allows callers to check\n// for versions without blocking or being blocked by other operations.\nfunc (p *Provider) GetVersions(ctx context.Context) (current, target int64, err error) {\n\treturn p.getVersions(ctx)\n}\n\n// GetDBVersion returns the highest version recorded in the database, regardless of the order in\n// which migrations were applied. For example, if migrations were applied out of order (1,4,2,3),\n// this method returns 4. If no migrations have been applied, it returns 0.\nfunc (p *Provider) GetDBVersion(ctx context.Context) (int64, error) {\n\tif p.cfg.disableVersioning {\n\t\treturn -1, errors.New(\"getting database version not supported when versioning is disabled\")\n\t}\n\treturn p.getDBMaxVersion(ctx, nil)\n}\n\n// ListSources returns a list of all migration sources known to the provider, sorted in ascending\n// order by version. The path field may be empty for manually registered migrations, such as Go\n// migrations registered using the [WithGoMigrations] option.\nfunc (p *Provider) ListSources() []*Source {\n\tsources := make([]*Source, 0, len(p.migrations))\n\tfor _, m := range p.migrations {\n\t\tsources = append(sources, &Source{\n\t\t\tType:    m.Type,\n\t\t\tPath:    m.Source,\n\t\t\tVersion: m.Version,\n\t\t})\n\t}\n\treturn sources\n}\n\n// Ping attempts to ping the database to verify a connection is available.\nfunc (p *Provider) Ping(ctx context.Context) error {\n\treturn p.db.PingContext(ctx)\n}\n\n// Close closes the database connection initially supplied to the provider.\nfunc (p *Provider) Close() error {\n\treturn p.db.Close()\n}\n\n// ApplyVersion applies exactly one migration for the specified version. If there is no migration\n// available for the specified version, this method returns [ErrVersionNotFound]. If the migration\n// has already been applied, this method returns [ErrAlreadyApplied].\n//\n// The direction parameter determines the migration direction: true for up migration and false for\n// down migration.\nfunc (p *Provider) ApplyVersion(ctx context.Context, version int64, direction bool) (*MigrationResult, error) {\n\tres, err := p.apply(ctx, version, direction)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// This should never happen, we must return exactly one result.\n\tif len(res) != 1 {\n\t\tversions := make([]string, 0, len(res))\n\t\tfor _, r := range res {\n\t\t\tversions = append(versions, strconv.FormatInt(r.Source.Version, 10))\n\t\t}\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"unexpected number of migrations applied running apply, expecting exactly one result: %v\",\n\t\t\tstrings.Join(versions, \",\"),\n\t\t)\n\t}\n\treturn res[0], nil\n}\n\n// Up applies all pending migrations. If there are no new migrations to apply, this method returns\n// empty list and nil error.\nfunc (p *Provider) Up(ctx context.Context) ([]*MigrationResult, error) {\n\thasPending, err := p.HasPending(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !hasPending {\n\t\treturn nil, nil\n\t}\n\treturn p.up(ctx, false, math.MaxInt64)\n}\n\n// UpByOne applies the next pending migration. If there is no next migration to apply, this method\n// returns [ErrNoNextVersion].\nfunc (p *Provider) UpByOne(ctx context.Context) (*MigrationResult, error) {\n\thasPending, err := p.HasPending(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !hasPending {\n\t\treturn nil, ErrNoNextVersion\n\t}\n\tres, err := p.up(ctx, true, math.MaxInt64)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(res) == 0 {\n\t\treturn nil, ErrNoNextVersion\n\t}\n\t// This should never happen, we must return exactly one result.\n\tif len(res) != 1 {\n\t\tversions := make([]string, 0, len(res))\n\t\tfor _, r := range res {\n\t\t\tversions = append(versions, strconv.FormatInt(r.Source.Version, 10))\n\t\t}\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"unexpected number of migrations applied running up-by-one, expecting exactly one result: %v\",\n\t\t\tstrings.Join(versions, \",\"),\n\t\t)\n\t}\n\treturn res[0], nil\n}\n\n// UpTo applies all pending migrations up to, and including, the specified version. If there are no\n// migrations to apply, this method returns empty list and nil error.\n//\n// For example, if there are three new migrations (9,10,11) and the current database version is 8\n// with a requested version of 10, only versions 9,10 will be applied.\nfunc (p *Provider) UpTo(ctx context.Context, version int64) ([]*MigrationResult, error) {\n\thasPending, err := p.HasPending(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !hasPending {\n\t\treturn nil, nil\n\t}\n\treturn p.up(ctx, false, version)\n}\n\n// Down rolls back the most recently applied migration. If there are no migrations to rollback, this\n// method returns [ErrNoNextVersion].\n//\n// Note, migrations are rolled back in the order they were applied. And not in the reverse order of\n// the migration version. This only applies in scenarios where migrations are allowed to be applied\n// out of order.\nfunc (p *Provider) Down(ctx context.Context) (*MigrationResult, error) {\n\tres, err := p.down(ctx, true, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(res) == 0 {\n\t\treturn nil, ErrNoNextVersion\n\t}\n\t// This should never happen, we must return exactly one result.\n\tif len(res) != 1 {\n\t\tversions := make([]string, 0, len(res))\n\t\tfor _, r := range res {\n\t\t\tversions = append(versions, strconv.FormatInt(r.Source.Version, 10))\n\t\t}\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"unexpected number of migrations applied running down, expecting exactly one result: %v\",\n\t\t\tstrings.Join(versions, \",\"),\n\t\t)\n\t}\n\treturn res[0], nil\n}\n\n// DownTo rolls back all migrations down to, but not including, the specified version.\n//\n// For example, if the current database version is 11,10,9... and the requested version is 9, only\n// migrations 11, 10 will be rolled back.\n//\n// Note, migrations are rolled back in the order they were applied. And not in the reverse order of\n// the migration version. This only applies in scenarios where migrations are allowed to be applied\n// out of order.\nfunc (p *Provider) DownTo(ctx context.Context, version int64) ([]*MigrationResult, error) {\n\tif version < 0 {\n\t\treturn nil, fmt.Errorf(\"invalid version: must be a valid number or zero: %d\", version)\n\t}\n\treturn p.down(ctx, false, version)\n}\n\n// *** Internal methods ***\n\nfunc (p *Provider) up(\n\tctx context.Context,\n\tbyOne bool,\n\tversion int64,\n) (_ []*MigrationResult, retErr error) {\n\tif version < 1 {\n\t\treturn nil, errInvalidVersion\n\t}\n\tconn, cleanup, err := p.initialize(ctx, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\tif len(p.migrations) == 0 {\n\t\treturn nil, nil\n\t}\n\tvar apply []*Migration\n\tif p.cfg.disableVersioning {\n\t\tif byOne {\n\t\t\treturn nil, errors.New(\"up-by-one not supported when versioning is disabled\")\n\t\t}\n\t\tapply = p.migrations\n\t} else {\n\t\t// optimize(mf): Listing all migrations from the database isn't great.\n\t\t//\n\t\t// The ideal implementation would be to query for the current max version and then apply\n\t\t// migrations greater than that version. However, a nice property of the current\n\t\t// implementation is that we can make stronger guarantees about unapplied migrations.\n\t\t//\n\t\t// In cases where users do not use out-of-order migrations, we want to surface an error if\n\t\t// there are older unapplied migrations. See https://github.com/pressly/goose/issues/761 for\n\t\t// more details.\n\t\t//\n\t\t// And in cases where users do use out-of-order migrations, we need to build a list of older\n\t\t// migrations that need to be applied, so we need to query for all migrations anyways.\n\t\tdbMigrations, err := p.store.ListMigrations(ctx, conn)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(dbMigrations) == 0 {\n\t\t\treturn nil, errMissingZeroVersion\n\t\t}\n\t\tversions, err := gooseutil.UpVersions(\n\t\t\tgetVersionsFromMigrations(p.migrations),     // fsys versions\n\t\t\tgetVersionsFromListMigrations(dbMigrations), // db versions\n\t\t\tversion,\n\t\t\tp.cfg.allowMissing,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, v := range versions {\n\t\t\tm, err := p.getMigration(v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tapply = append(apply, m)\n\t\t}\n\t}\n\treturn p.runMigrations(ctx, conn, apply, sqlparser.DirectionUp, byOne)\n}\n\nfunc (p *Provider) down(\n\tctx context.Context,\n\tbyOne bool,\n\tversion int64,\n) (_ []*MigrationResult, retErr error) {\n\tconn, cleanup, err := p.initialize(ctx, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\tif len(p.migrations) == 0 {\n\t\treturn nil, nil\n\t}\n\tif p.cfg.disableVersioning {\n\t\tvar downMigrations []*Migration\n\t\tif byOne {\n\t\t\tlast := p.migrations[len(p.migrations)-1]\n\t\t\tdownMigrations = []*Migration{last}\n\t\t} else {\n\t\t\tdownMigrations = p.migrations\n\t\t}\n\t\treturn p.runMigrations(ctx, conn, downMigrations, sqlparser.DirectionDown, byOne)\n\t}\n\tdbMigrations, err := p.store.ListMigrations(ctx, conn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(dbMigrations) == 0 {\n\t\treturn nil, errMissingZeroVersion\n\t}\n\t// We never migrate the zero version down.\n\tif dbMigrations[0].Version == 0 {\n\t\tp.printf(\"no migrations to run, current version: 0\")\n\t\treturn nil, nil\n\t}\n\tvar apply []*Migration\n\tfor _, dbMigration := range dbMigrations {\n\t\tif dbMigration.Version <= version {\n\t\t\tbreak\n\t\t}\n\t\tm, err := p.getMigration(dbMigration.Version)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tapply = append(apply, m)\n\t}\n\treturn p.runMigrations(ctx, conn, apply, sqlparser.DirectionDown, byOne)\n}\n\nfunc (p *Provider) apply(\n\tctx context.Context,\n\tversion int64,\n\tdirection bool,\n) (_ []*MigrationResult, retErr error) {\n\tif version < 1 {\n\t\treturn nil, errInvalidVersion\n\t}\n\tm, err := p.getMigration(version)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, cleanup, err := p.initialize(ctx, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\tresult, err := p.store.GetMigration(ctx, conn, version)\n\tif err != nil && !errors.Is(err, database.ErrVersionNotFound) {\n\t\treturn nil, err\n\t}\n\t// There are a few states here:\n\t//  1. direction is up\n\t//    a. migration is applied, this is an error (ErrAlreadyApplied)\n\t//    b. migration is not applied, apply it\n\tif direction && result != nil {\n\t\treturn nil, fmt.Errorf(\"version %d: %w\", version, ErrAlreadyApplied)\n\t}\n\t//  2. direction is down\n\t//    a. migration is applied, rollback\n\t//    b. migration is not applied, this is an error (ErrNotApplied)\n\tif !direction && result == nil {\n\t\treturn nil, fmt.Errorf(\"version %d: %w\", version, ErrNotApplied)\n\t}\n\td := sqlparser.DirectionDown\n\tif direction {\n\t\td = sqlparser.DirectionUp\n\t}\n\treturn p.runMigrations(ctx, conn, []*Migration{m}, d, true)\n}\n\nfunc (p *Provider) getVersions(ctx context.Context) (current, target int64, retErr error) {\n\tconn, cleanup, err := p.initialize(ctx, false)\n\tif err != nil {\n\t\treturn -1, -1, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\ttarget = p.migrations[len(p.migrations)-1].Version\n\n\t// If versioning is disabled, we always have pending migrations and the target version is the\n\t// last migration.\n\tif p.cfg.disableVersioning {\n\t\treturn -1, target, nil\n\t}\n\n\tcurrent, err = p.store.GetLatestVersion(ctx, conn)\n\tif err != nil {\n\t\tif errors.Is(err, database.ErrVersionNotFound) {\n\t\t\treturn -1, target, errMissingZeroVersion\n\t\t}\n\t\treturn -1, target, err\n\t}\n\treturn current, target, nil\n}\n\nfunc (p *Provider) hasPending(ctx context.Context) (_ bool, retErr error) {\n\tconn, cleanup, err := p.initialize(ctx, false)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\t// If versioning is disabled, we always have pending migrations.\n\tif p.cfg.disableVersioning {\n\t\treturn true, nil\n\t}\n\n\t// List all migrations from the database. Careful, optimizations here can lead to subtle bugs.\n\t// We have 2 important cases to consider:\n\t//\n\t//  1.  Users have enabled out-of-order migrations, in which case we need to check if any\n\t//      migrations are missing and report that there are pending migrations. Do not surface an\n\t//      error because this is a valid state.\n\t//\n\t//  2.  Users have disabled out-of-order migrations (default), in which case we need to check if all\n\t//      migrations have been applied. We cannot check for the highest applied version because we lose the\n\t//      ability to surface an error if an out-of-order migration was introduced. It would be silently\n\t//      ignored and the user would not know that they have unapplied migrations.\n\t//\n\t//      Maybe we could consider adding a flag to the provider such as IgnoreMissing, which would\n\t//      allow silently ignoring missing migrations. This would be useful for users that have built\n\t//      checks that prevent missing migrations from being introduced.\n\n\tdbMigrations, err := p.store.ListMigrations(ctx, conn)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tapply, err := gooseutil.UpVersions(\n\t\tgetVersionsFromMigrations(p.migrations),     // fsys versions\n\t\tgetVersionsFromListMigrations(dbMigrations), // db versions\n\t\tmath.MaxInt64,\n\t\tp.cfg.allowMissing,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn len(apply) > 0, nil\n}\n\nfunc getVersionsFromMigrations(in []*Migration) []int64 {\n\tout := make([]int64, 0, len(in))\n\tfor _, m := range in {\n\t\tout = append(out, m.Version)\n\t}\n\treturn out\n\n}\n\nfunc getVersionsFromListMigrations(in []*database.ListMigrationsResult) []int64 {\n\tout := make([]int64, 0, len(in))\n\tfor _, m := range in {\n\t\tout = append(out, m.Version)\n\t}\n\treturn out\n\n}\n\nfunc (p *Provider) status(ctx context.Context) (_ []*MigrationStatus, retErr error) {\n\tconn, cleanup, err := p.initialize(ctx, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize: %w\", err)\n\t}\n\tdefer func() {\n\t\tretErr = multierr.Append(retErr, cleanup())\n\t}()\n\n\tstatus := make([]*MigrationStatus, 0, len(p.migrations))\n\tfor _, m := range p.migrations {\n\t\tmigrationStatus := &MigrationStatus{\n\t\t\tSource: &Source{\n\t\t\t\tType:    m.Type,\n\t\t\t\tPath:    m.Source,\n\t\t\t\tVersion: m.Version,\n\t\t\t},\n\t\t\tState: StatePending,\n\t\t}\n\t\t// If versioning is disabled, we can't check the database for applied migrations, so we\n\t\t// assume all migrations are pending.\n\t\tif !p.cfg.disableVersioning {\n\t\t\tdbResult, err := p.store.GetMigration(ctx, conn, m.Version)\n\t\t\tif err != nil && !errors.Is(err, database.ErrVersionNotFound) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif dbResult != nil {\n\t\t\t\tmigrationStatus.State = StateApplied\n\t\t\t\tmigrationStatus.AppliedAt = dbResult.Timestamp\n\t\t\t}\n\t\t}\n\t\tstatus = append(status, migrationStatus)\n\t}\n\n\treturn status, nil\n}\n\n// getDBMaxVersion returns the highest version recorded in the database, regardless of the order in\n// which migrations were applied. conn may be nil, in which case a connection is initialized.\nfunc (p *Provider) getDBMaxVersion(ctx context.Context, conn *sql.Conn) (_ int64, retErr error) {\n\tif conn == nil {\n\t\tvar cleanup func() error\n\t\tvar err error\n\t\tconn, cleanup, err = p.initialize(ctx, true)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tdefer func() {\n\t\t\tretErr = multierr.Append(retErr, cleanup())\n\t\t}()\n\t}\n\n\tlatest, err := p.store.GetLatestVersion(ctx, conn)\n\tif err != nil {\n\t\tif errors.Is(err, database.ErrVersionNotFound) {\n\t\t\treturn 0, errMissingZeroVersion\n\t\t}\n\t\treturn -1, err\n\t}\n\treturn latest, nil\n}\n"
        },
        {
          "name": "provider_collect.go",
          "type": "blob",
          "size": 5.9716796875,
          "content": "package goose\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// fileSources represents a collection of migration files on the filesystem.\ntype fileSources struct {\n\tsqlSources []Source\n\tgoSources  []Source\n}\n\n// collectFilesystemSources scans the file system for migration files that have a numeric prefix\n// (greater than one) followed by an underscore and a file extension of either .go or .sql. fsys may\n// be nil, in which case an empty fileSources is returned.\n//\n// If strict is true, then any error parsing the numeric component of the filename will result in an\n// error. The file is skipped otherwise.\n//\n// This function DOES NOT parse SQL migrations or merge registered Go migrations. It only collects\n// migration sources from the filesystem.\nfunc collectFilesystemSources(\n\tfsys fs.FS,\n\tstrict bool,\n\texcludePaths map[string]bool,\n\texcludeVersions map[int64]bool,\n) (*fileSources, error) {\n\tif fsys == nil {\n\t\treturn new(fileSources), nil\n\t}\n\tsources := new(fileSources)\n\tversionToBaseLookup := make(map[int64]string) // map[version]filepath.Base(fullpath)\n\tfor _, pattern := range []string{\n\t\t\"*.sql\",\n\t\t\"*.go\",\n\t} {\n\t\tfiles, err := fs.Glob(fsys, pattern)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to glob pattern %q: %w\", pattern, err)\n\t\t}\n\t\tfor _, fullpath := range files {\n\t\t\tbase := filepath.Base(fullpath)\n\t\t\tif strings.HasSuffix(base, \"_test.go\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif excludePaths[base] {\n\t\t\t\t// TODO(mf): log this?\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the filename has a valid looking version of the form: NUMBER_.{sql,go}, then use\n\t\t\t// that as the version. Otherwise, ignore it. This allows users to have arbitrary\n\t\t\t// filenames, but still have versioned migrations within the same directory. For\n\t\t\t// example, a user could have a helpers.go file which contains unexported helper\n\t\t\t// functions for migrations.\n\t\t\tversion, err := NumericComponent(base)\n\t\t\tif err != nil {\n\t\t\t\tif strict {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to parse numeric component from %q: %w\", base, err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif excludeVersions[version] {\n\t\t\t\t// TODO: log this?\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Ensure there are no duplicate versions.\n\t\t\tif existing, ok := versionToBaseLookup[version]; ok {\n\t\t\t\treturn nil, fmt.Errorf(\"found duplicate migration version %d:\\n\\texisting:%v\\n\\tcurrent:%v\",\n\t\t\t\t\tversion,\n\t\t\t\t\texisting,\n\t\t\t\t\tbase,\n\t\t\t\t)\n\t\t\t}\n\t\t\tswitch filepath.Ext(base) {\n\t\t\tcase \".sql\":\n\t\t\t\tsources.sqlSources = append(sources.sqlSources, Source{\n\t\t\t\t\tType:    TypeSQL,\n\t\t\t\t\tPath:    fullpath,\n\t\t\t\t\tVersion: version,\n\t\t\t\t})\n\t\t\tcase \".go\":\n\t\t\t\tsources.goSources = append(sources.goSources, Source{\n\t\t\t\t\tType:    TypeGo,\n\t\t\t\t\tPath:    fullpath,\n\t\t\t\t\tVersion: version,\n\t\t\t\t})\n\t\t\tdefault:\n\t\t\t\t// Should never happen since we already filtered out all other file types.\n\t\t\t\treturn nil, fmt.Errorf(\"invalid file extension: %q\", base)\n\t\t\t}\n\t\t\t// Add the version to the lookup map.\n\t\t\tversionToBaseLookup[version] = base\n\t\t}\n\t}\n\treturn sources, nil\n}\n\nfunc newSQLMigration(source Source) *Migration {\n\treturn &Migration{\n\t\tType:      source.Type,\n\t\tVersion:   source.Version,\n\t\tSource:    source.Path,\n\t\tconstruct: true,\n\t\tNext:      -1, Previous: -1,\n\t\tsql: sqlMigration{\n\t\t\tParsed: false, // SQL migrations are parsed lazily.\n\t\t},\n\t}\n}\n\nfunc merge(sources *fileSources, registered map[int64]*Migration) ([]*Migration, error) {\n\tvar migrations []*Migration\n\tmigrationLookup := make(map[int64]*Migration)\n\t// Add all SQL migrations to the list of migrations.\n\tfor _, source := range sources.sqlSources {\n\t\tm := newSQLMigration(source)\n\t\tmigrations = append(migrations, m)\n\t\tmigrationLookup[source.Version] = m\n\t}\n\t// If there are no Go files in the filesystem and no registered Go migrations, return early.\n\tif len(sources.goSources) == 0 && len(registered) == 0 {\n\t\treturn migrations, nil\n\t}\n\t// Return an error if the given sources contain a versioned Go migration that has not been\n\t// registered. This is a sanity check to ensure users didn't accidentally create a valid looking\n\t// Go migration file on disk and forget to register it.\n\t//\n\t// This is almost always a user error.\n\tvar unregistered []string\n\tfor _, s := range sources.goSources {\n\t\tm, ok := registered[s.Version]\n\t\tif !ok {\n\t\t\tunregistered = append(unregistered, s.Path)\n\t\t} else {\n\t\t\t// Populate the source path for registered Go migrations that have a corresponding file\n\t\t\t// on disk.\n\t\t\tm.Source = s.Path\n\t\t}\n\t}\n\tif len(unregistered) > 0 {\n\t\treturn nil, unregisteredError(unregistered)\n\t}\n\t// Add all registered Go migrations to the list of migrations, checking for duplicate versions.\n\t//\n\t// Important, users can register Go migrations manually via goose.Add_ functions. These\n\t// migrations may not have a corresponding file on disk. Which is fine! We include them\n\t// wholesale as part of migrations. This allows users to build a custom binary that only embeds\n\t// the SQL migration files.\n\tfor version, r := range registered {\n\t\t// Ensure there are no duplicate versions.\n\t\tif existing, ok := migrationLookup[version]; ok {\n\t\t\tfullpath := r.Source\n\t\t\tif fullpath == \"\" {\n\t\t\t\tfullpath = \"no source path\"\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"found duplicate migration version %d:\\n\\texisting:%v\\n\\tcurrent:%v\",\n\t\t\t\tversion,\n\t\t\t\texisting.Source,\n\t\t\t\tfullpath,\n\t\t\t)\n\t\t}\n\t\tmigrations = append(migrations, r)\n\t\tmigrationLookup[version] = r\n\t}\n\t// Sort migrations by version in ascending order.\n\tsort.Slice(migrations, func(i, j int) bool {\n\t\treturn migrations[i].Version < migrations[j].Version\n\t})\n\treturn migrations, nil\n}\n\nfunc unregisteredError(unregistered []string) error {\n\tconst (\n\t\thintURL = \"https://github.com/pressly/goose/tree/master/examples/go-migrations\"\n\t)\n\tf := \"file\"\n\tif len(unregistered) > 1 {\n\t\tf += \"s\"\n\t}\n\tvar b strings.Builder\n\n\tb.WriteString(fmt.Sprintf(\"error: detected %d unregistered Go %s:\\n\", len(unregistered), f))\n\tfor _, name := range unregistered {\n\t\tb.WriteString(\"\\t\" + name + \"\\n\")\n\t}\n\thint := fmt.Sprintf(\"hint: go functions must be registered and built into a custom binary see:\\n%s\", hintURL)\n\tb.WriteString(hint)\n\tb.WriteString(\"\\n\")\n\n\treturn errors.New(b.String())\n}\n"
        },
        {
          "name": "provider_collect_test.go",
          "type": "blob",
          "size": 10.6298828125,
          "content": "package goose\n\nimport (\n\t\"io/fs\"\n\t\"testing\"\n\t\"testing/fstest\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCollectFileSources(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"nil_fsys\", func(t *testing.T) {\n\t\tsources, err := collectFilesystemSources(nil, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sources)\n\t\trequire.Empty(t, sources.goSources)\n\t\trequire.Empty(t, sources.sqlSources)\n\t})\n\tt.Run(\"noop_fsys\", func(t *testing.T) {\n\t\tsources, err := collectFilesystemSources(noopFS{}, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sources)\n\t\trequire.Empty(t, sources.goSources)\n\t\trequire.Empty(t, sources.sqlSources)\n\t})\n\tt.Run(\"empty_fsys\", func(t *testing.T) {\n\t\tsources, err := collectFilesystemSources(fstest.MapFS{}, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Empty(t, sources.goSources)\n\t\trequire.Empty(t, sources.sqlSources)\n\t\trequire.NotNil(t, sources)\n\t})\n\tt.Run(\"incorrect_fsys\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"00000_foo.sql\": sqlMapFile,\n\t\t}\n\t\t// strict disable - should not error\n\t\tsources, err := collectFilesystemSources(mapFS, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Empty(t, sources.goSources)\n\t\trequire.Empty(t, sources.sqlSources)\n\t\t// strict enabled - should error\n\t\t_, err = collectFilesystemSources(mapFS, true, nil, nil)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"migration version must be greater than zero\")\n\t})\n\tt.Run(\"collect\", func(t *testing.T) {\n\t\tfsys, err := fs.Sub(newSQLOnlyFS(), \"migrations\")\n\t\trequire.NoError(t, err)\n\t\tsources, err := collectFilesystemSources(fsys, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, sources.sqlSources, 4)\n\t\trequire.Empty(t, sources.goSources)\n\t\texpected := fileSources{\n\t\t\tsqlSources: []Source{\n\t\t\t\tnewSource(TypeSQL, \"00001_foo.sql\", 1),\n\t\t\t\tnewSource(TypeSQL, \"00002_bar.sql\", 2),\n\t\t\t\tnewSource(TypeSQL, \"00003_baz.sql\", 3),\n\t\t\t\tnewSource(TypeSQL, \"00110_qux.sql\", 110),\n\t\t\t},\n\t\t}\n\t\tfor i := 0; i < len(sources.sqlSources); i++ {\n\t\t\trequire.Equal(t, sources.sqlSources[i], expected.sqlSources[i])\n\t\t}\n\t})\n\tt.Run(\"excludes\", func(t *testing.T) {\n\t\tfsys, err := fs.Sub(newSQLOnlyFS(), \"migrations\")\n\t\trequire.NoError(t, err)\n\t\tsources, err := collectFilesystemSources(\n\t\t\tfsys,\n\t\t\tfalse,\n\t\t\t// exclude 2 files explicitly\n\t\t\tmap[string]bool{\n\t\t\t\t\"00002_bar.sql\": true,\n\t\t\t\t\"00110_qux.sql\": true,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, sources.sqlSources, 2)\n\t\trequire.Empty(t, sources.goSources)\n\t\texpected := fileSources{\n\t\t\tsqlSources: []Source{\n\t\t\t\tnewSource(TypeSQL, \"00001_foo.sql\", 1),\n\t\t\t\tnewSource(TypeSQL, \"00003_baz.sql\", 3),\n\t\t\t},\n\t\t}\n\t\tfor i := 0; i < len(sources.sqlSources); i++ {\n\t\t\trequire.Equal(t, sources.sqlSources[i], expected.sqlSources[i])\n\t\t}\n\t})\n\tt.Run(\"strict\", func(t *testing.T) {\n\t\tmapFS := newSQLOnlyFS()\n\t\t// Add a file with no version number\n\t\tmapFS[\"migrations/not_valid.sql\"] = &fstest.MapFile{Data: []byte(\"invalid\")}\n\t\tfsys, err := fs.Sub(mapFS, \"migrations\")\n\t\trequire.NoError(t, err)\n\t\t_, err = collectFilesystemSources(fsys, true, nil, nil)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), `failed to parse numeric component from \"not_valid.sql\"`)\n\t})\n\tt.Run(\"skip_go_test_files\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"1_foo.sql\":     sqlMapFile,\n\t\t\t\"2_bar.sql\":     sqlMapFile,\n\t\t\t\"3_baz.sql\":     sqlMapFile,\n\t\t\t\"4_qux.sql\":     sqlMapFile,\n\t\t\t\"5_foo_test.go\": {Data: []byte(`package goose_test`)},\n\t\t}\n\t\tsources, err := collectFilesystemSources(mapFS, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, sources.sqlSources, 4)\n\t\trequire.Empty(t, sources.goSources)\n\t})\n\tt.Run(\"skip_random_files\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"1_foo.sql\":                sqlMapFile,\n\t\t\t\"4_something.go\":           {Data: []byte(`package goose`)},\n\t\t\t\"5_qux.sql\":                sqlMapFile,\n\t\t\t\"README.md\":                {Data: []byte(`# README`)},\n\t\t\t\"LICENSE\":                  {Data: []byte(`MIT`)},\n\t\t\t\"no_a_real_migration.sql\":  {Data: []byte(`SELECT 1;`)},\n\t\t\t\"some/other/dir/2_foo.sql\": {Data: []byte(`SELECT 1;`)},\n\t\t}\n\t\tsources, err := collectFilesystemSources(mapFS, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, sources.sqlSources, 2)\n\t\trequire.Len(t, sources.goSources, 1)\n\t\t// 1\n\t\trequire.Equal(t, \"1_foo.sql\", sources.sqlSources[0].Path)\n\t\trequire.EqualValues(t, 1, sources.sqlSources[0].Version)\n\t\t// 2\n\t\trequire.Equal(t, \"5_qux.sql\", sources.sqlSources[1].Path)\n\t\trequire.EqualValues(t, 5, sources.sqlSources[1].Version)\n\t\t// 3\n\t\trequire.Equal(t, \"4_something.go\", sources.goSources[0].Path)\n\t\trequire.EqualValues(t, 4, sources.goSources[0].Version)\n\t})\n\tt.Run(\"duplicate_versions\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"001_foo.sql\": sqlMapFile,\n\t\t\t\"01_bar.sql\":  sqlMapFile,\n\t\t}\n\t\t_, err := collectFilesystemSources(mapFS, false, nil, nil)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"found duplicate migration version 1\")\n\t})\n\tt.Run(\"dirpath\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"dir1/101_a.sql\": sqlMapFile,\n\t\t\t\"dir1/102_b.sql\": sqlMapFile,\n\t\t\t\"dir1/103_c.sql\": sqlMapFile,\n\t\t\t\"dir2/201_a.sql\": sqlMapFile,\n\t\t\t\"876_a.sql\":      sqlMapFile,\n\t\t}\n\t\tassertDirpath := func(dirpath string, sqlSources []Source) {\n\t\t\tt.Helper()\n\t\t\tf, err := fs.Sub(mapFS, dirpath)\n\t\t\trequire.NoError(t, err)\n\t\t\tgot, err := collectFilesystemSources(f, false, nil, nil)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, len(got.sqlSources), len(sqlSources))\n\t\t\trequire.Empty(t, got.goSources)\n\t\t\tfor i := 0; i < len(got.sqlSources); i++ {\n\t\t\t\trequire.Equal(t, got.sqlSources[i], sqlSources[i])\n\t\t\t}\n\t\t}\n\t\tassertDirpath(\".\", []Source{\n\t\t\tnewSource(TypeSQL, \"876_a.sql\", 876),\n\t\t})\n\t\tassertDirpath(\"dir1\", []Source{\n\t\t\tnewSource(TypeSQL, \"101_a.sql\", 101),\n\t\t\tnewSource(TypeSQL, \"102_b.sql\", 102),\n\t\t\tnewSource(TypeSQL, \"103_c.sql\", 103),\n\t\t})\n\t\tassertDirpath(\"dir2\", []Source{\n\t\t\tnewSource(TypeSQL, \"201_a.sql\", 201),\n\t\t})\n\t\tassertDirpath(\"dir3\", nil)\n\t})\n}\n\nfunc TestMerge(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"with_go_files_on_disk\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t// SQL\n\t\t\t\"migrations/00001_foo.sql\": sqlMapFile,\n\t\t\t// Go\n\t\t\t\"migrations/00002_bar.go\": {Data: []byte(`package migrations`)},\n\t\t\t\"migrations/00003_baz.go\": {Data: []byte(`package migrations`)},\n\t\t}\n\t\tfsys, err := fs.Sub(mapFS, \"migrations\")\n\t\trequire.NoError(t, err)\n\t\tsources, err := collectFilesystemSources(fsys, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, sources.sqlSources, 1)\n\t\trequire.Len(t, sources.goSources, 2)\n\t\tt.Run(\"valid\", func(t *testing.T) {\n\t\t\tregistered := map[int64]*Migration{\n\t\t\t\t2: NewGoMigration(2, nil, nil),\n\t\t\t\t3: NewGoMigration(3, nil, nil),\n\t\t\t}\n\t\t\tmigrations, err := merge(sources, registered)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, migrations, 3)\n\t\t\tassertMigration(t, migrations[0], newSource(TypeSQL, \"00001_foo.sql\", 1))\n\t\t\tassertMigration(t, migrations[1], newSource(TypeGo, \"00002_bar.go\", 2))\n\t\t\tassertMigration(t, migrations[2], newSource(TypeGo, \"00003_baz.go\", 3))\n\t\t})\n\t\tt.Run(\"unregistered_all\", func(t *testing.T) {\n\t\t\t_, err := merge(sources, nil)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"error: detected 2 unregistered Go files:\")\n\t\t\trequire.Contains(t, err.Error(), \"00002_bar.go\")\n\t\t\trequire.Contains(t, err.Error(), \"00003_baz.go\")\n\t\t})\n\t\tt.Run(\"unregistered_some\", func(t *testing.T) {\n\t\t\t_, err := merge(sources, map[int64]*Migration{2: NewGoMigration(2, nil, nil)})\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"error: detected 1 unregistered Go file\")\n\t\t\trequire.Contains(t, err.Error(), \"00003_baz.go\")\n\t\t})\n\t\tt.Run(\"duplicate_sql\", func(t *testing.T) {\n\t\t\t_, err := merge(sources, map[int64]*Migration{\n\t\t\t\t1: NewGoMigration(1, nil, nil), // duplicate. SQL already exists.\n\t\t\t\t2: NewGoMigration(2, nil, nil),\n\t\t\t\t3: NewGoMigration(3, nil, nil),\n\t\t\t})\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"found duplicate migration version 1\")\n\t\t})\n\t})\n\tt.Run(\"no_go_files_on_disk\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t// SQL\n\t\t\t\"migrations/00001_foo.sql\": sqlMapFile,\n\t\t\t\"migrations/00002_bar.sql\": sqlMapFile,\n\t\t\t\"migrations/00005_baz.sql\": sqlMapFile,\n\t\t}\n\t\tfsys, err := fs.Sub(mapFS, \"migrations\")\n\t\trequire.NoError(t, err)\n\t\tsources, err := collectFilesystemSources(fsys, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\tt.Run(\"unregistered_all\", func(t *testing.T) {\n\t\t\tmigrations, err := merge(sources, map[int64]*Migration{\n\t\t\t\t3: NewGoMigration(3, nil, nil),\n\t\t\t\t// 4 is missing\n\t\t\t\t6: NewGoMigration(6, nil, nil),\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, migrations, 5)\n\t\t\tassertMigration(t, migrations[0], newSource(TypeSQL, \"00001_foo.sql\", 1))\n\t\t\tassertMigration(t, migrations[1], newSource(TypeSQL, \"00002_bar.sql\", 2))\n\t\t\tassertMigration(t, migrations[2], newSource(TypeGo, \"\", 3))\n\t\t\tassertMigration(t, migrations[3], newSource(TypeSQL, \"00005_baz.sql\", 5))\n\t\t\tassertMigration(t, migrations[4], newSource(TypeGo, \"\", 6))\n\t\t})\n\t})\n\tt.Run(\"partial_go_files_on_disk\", func(t *testing.T) {\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"migrations/00001_foo.sql\": sqlMapFile,\n\t\t\t\"migrations/00002_bar.go\":  &fstest.MapFile{Data: []byte(`package migrations`)},\n\t\t}\n\t\tfsys, err := fs.Sub(mapFS, \"migrations\")\n\t\trequire.NoError(t, err)\n\t\tsources, err := collectFilesystemSources(fsys, false, nil, nil)\n\t\trequire.NoError(t, err)\n\t\tt.Run(\"unregistered_all\", func(t *testing.T) {\n\t\t\tmigrations, err := merge(sources, map[int64]*Migration{\n\t\t\t\t// This is the only Go file on disk.\n\t\t\t\t2: NewGoMigration(2, nil, nil),\n\t\t\t\t// These are not on disk. Explicitly registered.\n\t\t\t\t3: NewGoMigration(3, nil, nil),\n\t\t\t\t6: NewGoMigration(6, nil, nil),\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, migrations, 4)\n\t\t\tassertMigration(t, migrations[0], newSource(TypeSQL, \"00001_foo.sql\", 1))\n\t\t\tassertMigration(t, migrations[1], newSource(TypeGo, \"00002_bar.go\", 2))\n\t\t\tassertMigration(t, migrations[2], newSource(TypeGo, \"\", 3))\n\t\t\tassertMigration(t, migrations[3], newSource(TypeGo, \"\", 6))\n\t\t})\n\t})\n}\n\nfunc assertMigration(t *testing.T, got *Migration, want Source) {\n\tt.Helper()\n\trequire.Equal(t, want.Type, got.Type)\n\trequire.Equal(t, want.Version, got.Version)\n\trequire.Equal(t, want.Path, got.Source)\n\tswitch got.Type {\n\tcase TypeGo:\n\t\trequire.NotNil(t, got.goUp)\n\t\trequire.NotNil(t, got.goDown)\n\tcase TypeSQL:\n\t\trequire.False(t, got.sql.Parsed)\n\tdefault:\n\t\tt.Fatalf(\"unknown migration type: %s\", got.Type)\n\t}\n}\n\nfunc newSQLOnlyFS() fstest.MapFS {\n\treturn fstest.MapFS{\n\t\t\"migrations/00001_foo.sql\": sqlMapFile,\n\t\t\"migrations/00002_bar.sql\": sqlMapFile,\n\t\t\"migrations/00003_baz.sql\": sqlMapFile,\n\t\t\"migrations/00110_qux.sql\": sqlMapFile,\n\t}\n}\n\nfunc newSource(t MigrationType, fullpath string, version int64) Source {\n\treturn Source{\n\t\tType:    t,\n\t\tPath:    fullpath,\n\t\tVersion: version,\n\t}\n}\n\nvar (\n\tsqlMapFile = &fstest.MapFile{Data: []byte(`-- +goose Up`)}\n)\n"
        },
        {
          "name": "provider_errors.go",
          "type": "blob",
          "size": 1.6416015625,
          "content": "package goose\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar (\n\t// ErrVersionNotFound is returned when a specific migration version is not located. This can\n\t// occur if a .sql file or a Go migration function for the specified version is missing.\n\tErrVersionNotFound = errors.New(\"version not found\")\n\n\t// ErrNoMigrations is returned by [NewProvider] when no migrations are found.\n\tErrNoMigrations = errors.New(\"no migrations found\")\n\n\t// ErrAlreadyApplied indicates that the migration cannot be applied because it has already been\n\t// executed. This error is returned by [Provider.Apply].\n\tErrAlreadyApplied = errors.New(\"migration already applied\")\n\n\t// ErrNotApplied indicates that the rollback cannot be performed because the migration has not\n\t// yet been applied. This error is returned by [Provider.Apply].\n\tErrNotApplied = errors.New(\"migration not applied\")\n\n\t// errInvalidVersion is returned when a migration version is invalid.\n\terrInvalidVersion = errors.New(\"version must be greater than 0\")\n)\n\n// PartialError is returned when a migration fails, but some migrations already got applied.\ntype PartialError struct {\n\t// Applied are migrations that were applied successfully before the error occurred. May be\n\t// empty.\n\tApplied []*MigrationResult\n\t// Failed contains the result of the migration that failed. Cannot be nil.\n\tFailed *MigrationResult\n\t// Err is the error that occurred while running the migration and caused the failure.\n\tErr error\n}\n\nfunc (e *PartialError) Error() string {\n\treturn fmt.Sprintf(\n\t\t\"partial migration error (type:%s,version:%d): %v\",\n\t\te.Failed.Source.Type, e.Failed.Source.Version, e.Err,\n\t)\n}\n\nfunc (e *PartialError) Unwrap() error {\n\treturn e.Err\n}\n"
        },
        {
          "name": "provider_options.go",
          "type": "blob",
          "size": 5.8935546875,
          "content": "package goose\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/pressly/goose/v3/lock\"\n)\n\nconst (\n\t// DefaultTablename is the default name of the database table used to track history of applied\n\t// migrations.\n\tDefaultTablename = \"goose_db_version\"\n)\n\n// ProviderOption is a configuration option for a goose goose.\ntype ProviderOption interface {\n\tapply(*config) error\n}\n\n// WithStore configures the provider with a custom [database.Store] implementation.\n//\n// By default, the provider uses the [database.NewStore] function to create a store backed by the\n// given dialect. However, this option allows users to provide their own implementation or call\n// [database.NewStore] with custom options, such as setting the table name.\n//\n// Example:\n//\n//\t// Create a store with a custom table name.\n//\tstore, err := database.NewStore(database.DialectPostgres, \"my_custom_table_name\")\n//\tif err != nil {\n//\t    return err\n//\t}\n//\t// Create a provider with the custom store.\n//\tprovider, err := goose.NewProvider(\"\", db, nil, goose.WithStore(store))\n//\tif err != nil {\n//\t    return err\n//\t}\nfunc WithStore(store database.Store) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tif c.store != nil {\n\t\t\treturn fmt.Errorf(\"store already set: %T\", c.store)\n\t\t}\n\t\tif store == nil {\n\t\t\treturn errors.New(\"store must not be nil\")\n\t\t}\n\t\tif store.Tablename() == \"\" {\n\t\t\treturn errors.New(\"store implementation must set the table name\")\n\t\t}\n\t\tc.store = store\n\t\treturn nil\n\t})\n}\n\n// WithVerbose enables verbose logging.\nfunc WithVerbose(b bool) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tc.verbose = b\n\t\treturn nil\n\t})\n}\n\n// WithSessionLocker enables locking using the provided SessionLocker.\n//\n// If WithSessionLocker is not called, locking is disabled.\nfunc WithSessionLocker(locker lock.SessionLocker) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tif c.lockEnabled {\n\t\t\treturn errors.New(\"lock already enabled\")\n\t\t}\n\t\tif c.sessionLocker != nil {\n\t\t\treturn errors.New(\"session locker already set\")\n\t\t}\n\t\tif locker == nil {\n\t\t\treturn errors.New(\"session locker must not be nil\")\n\t\t}\n\t\tc.lockEnabled = true\n\t\tc.sessionLocker = locker\n\t\treturn nil\n\t})\n}\n\n// WithExcludeNames excludes the given file name from the list of migrations. If called multiple\n// times, the list of excludes is merged.\nfunc WithExcludeNames(excludes []string) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tfor _, name := range excludes {\n\t\t\tif _, ok := c.excludePaths[name]; ok {\n\t\t\t\treturn fmt.Errorf(\"duplicate exclude file name: %s\", name)\n\t\t\t}\n\t\t\tc.excludePaths[name] = true\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// WithExcludeVersions excludes the given versions from the list of migrations. If called multiple\n// times, the list of excludes is merged.\nfunc WithExcludeVersions(versions []int64) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tfor _, version := range versions {\n\t\t\tif version < 1 {\n\t\t\t\treturn errInvalidVersion\n\t\t\t}\n\t\t\tif _, ok := c.excludeVersions[version]; ok {\n\t\t\t\treturn fmt.Errorf(\"duplicate excludes version: %d\", version)\n\t\t\t}\n\t\t\tc.excludeVersions[version] = true\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// WithGoMigrations registers Go migrations with the provider. If a Go migration with the same\n// version has already been registered, an error will be returned.\n//\n// Go migrations must be constructed using the [NewGoMigration] function.\nfunc WithGoMigrations(migrations ...*Migration) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tfor _, m := range migrations {\n\t\t\tif _, ok := c.registered[m.Version]; ok {\n\t\t\t\treturn fmt.Errorf(\"go migration with version %d already registered\", m.Version)\n\t\t\t}\n\t\t\tif err := checkGoMigration(m); err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid go migration: %w\", err)\n\t\t\t}\n\t\t\tc.registered[m.Version] = m\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// WithDisableGlobalRegistry prevents the provider from registering Go migrations from the global\n// registry. By default, goose will register all Go migrations including those registered globally.\nfunc WithDisableGlobalRegistry(b bool) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tc.disableGlobalRegistry = b\n\t\treturn nil\n\t})\n}\n\n// WithAllowOutofOrder allows the provider to apply missing (out-of-order) migrations. By default,\n// goose will raise an error if it encounters a missing migration.\n//\n// For example: migrations 1,3 are applied and then version 2,6 are introduced. If this option is\n// true, then goose will apply 2 (missing) and 6 (new) instead of raising an error. The final order\n// of applied migrations will be: 1,3,2,6. Out-of-order migrations are always applied first,\n// followed by new migrations.\nfunc WithAllowOutofOrder(b bool) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tc.allowMissing = b\n\t\treturn nil\n\t})\n}\n\n// WithDisableVersioning disables versioning. Disabling versioning allows applying migrations\n// without tracking the versions in the database schema table. Useful for tests, seeding a database\n// or running ad-hoc queries. By default, goose will track all versions in the database schema\n// table.\nfunc WithDisableVersioning(b bool) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tc.disableVersioning = b\n\t\treturn nil\n\t})\n}\n\n// WithLogger will set a custom Logger, which will override the default logger.\nfunc WithLogger(l Logger) ProviderOption {\n\treturn configFunc(func(c *config) error {\n\t\tc.logger = l\n\t\treturn nil\n\t})\n}\n\ntype config struct {\n\tstore database.Store\n\n\tverbose         bool\n\texcludePaths    map[string]bool\n\texcludeVersions map[int64]bool\n\n\t// Go migrations registered by the user. These will be merged/resolved against the globally\n\t// registered migrations.\n\tregistered map[int64]*Migration\n\n\t// Locking options\n\tlockEnabled   bool\n\tsessionLocker lock.SessionLocker\n\n\t// Feature\n\tdisableVersioning     bool\n\tallowMissing          bool\n\tdisableGlobalRegistry bool\n\n\tlogger Logger\n}\n\ntype configFunc func(*config) error\n\nfunc (f configFunc) apply(cfg *config) error {\n\treturn f(cfg)\n}\n"
        },
        {
          "name": "provider_options_test.go",
          "type": "blob",
          "size": 2.013671875,
          "content": "package goose_test\n\nimport (\n\t\"database/sql\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"testing/fstest\"\n\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/stretchr/testify/require\"\n\t_ \"modernc.org/sqlite\"\n)\n\nfunc TestNewProvider(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := sql.Open(\"sqlite\", filepath.Join(dir, \"sql_embed.db\"))\n\trequire.NoError(t, err)\n\tfsys := fstest.MapFS{\n\t\t\"1_foo.sql\": {Data: []byte(migration1)},\n\t\t\"2_bar.sql\": {Data: []byte(migration2)},\n\t\t\"3_baz.sql\": {Data: []byte(migration3)},\n\t\t\"4_qux.sql\": {Data: []byte(migration4)},\n\t}\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\t// Empty dialect not allowed\n\t\t_, err = goose.NewProvider(\"\", db, fsys)\n\t\trequire.Error(t, err)\n\t\t// Invalid dialect not allowed\n\t\t_, err = goose.NewProvider(\"unknown-dialect\", db, fsys)\n\t\trequire.Error(t, err)\n\t\t// Nil db not allowed\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, nil, fsys)\n\t\trequire.Error(t, err)\n\t\t// Nil store not allowed\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, db, nil, goose.WithStore(nil))\n\t\trequire.Error(t, err)\n\t\t// Cannot set both dialect and store\n\t\tstore, err := database.NewStore(goose.DialectSQLite3, \"custom_table\")\n\t\trequire.NoError(t, err)\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, db, nil, goose.WithStore(store))\n\t\trequire.Error(t, err)\n\t\t// Multiple stores not allowed\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, db, nil,\n\t\t\tgoose.WithStore(store),\n\t\t\tgoose.WithStore(store),\n\t\t)\n\t\trequire.Error(t, err)\n\t})\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\t// Valid dialect, db, and fsys allowed\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, db, fsys)\n\t\trequire.NoError(t, err)\n\t\t// Valid dialect, db, fsys, and verbose allowed\n\t\t_, err = goose.NewProvider(goose.DialectSQLite3, db, fsys,\n\t\t\tgoose.WithVerbose(testing.Verbose()),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\t// Custom store allowed\n\t\tstore, err := database.NewStore(goose.DialectSQLite3, \"custom_table\")\n\t\trequire.NoError(t, err)\n\t\t_, err = goose.NewProvider(\"\", db, nil, goose.WithStore(store))\n\t\trequire.Error(t, err)\n\t})\n}\n"
        },
        {
          "name": "provider_run.go",
          "type": "blob",
          "size": 14.7431640625,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/pressly/goose/v3/internal/sqlparser\"\n\t\"github.com/sethvargo/go-retry\"\n\t\"go.uber.org/multierr\"\n)\n\nvar (\n\terrMissingZeroVersion = errors.New(\"missing zero version migration\")\n)\n\nfunc (p *Provider) prepareMigration(fsys fs.FS, m *Migration, direction bool) error {\n\tswitch m.Type {\n\tcase TypeGo:\n\t\tif m.goUp.Mode == 0 {\n\t\t\treturn errors.New(\"go up migration mode is not set\")\n\t\t}\n\t\tif m.goDown.Mode == 0 {\n\t\t\treturn errors.New(\"go down migration mode is not set\")\n\t\t}\n\t\tvar useTx bool\n\t\tif direction {\n\t\t\tuseTx = m.goUp.Mode == TransactionEnabled\n\t\t} else {\n\t\t\tuseTx = m.goDown.Mode == TransactionEnabled\n\t\t}\n\t\t// bug(mf): this is a potential deadlock scenario. We're running Go migrations with *sql.DB,\n\t\t// but are locking the database with *sql.Conn. If the caller sets max open connections to\n\t\t// 1, then this will deadlock because the Go migration will try to acquire a connection from\n\t\t// the pool, but the pool is exhausted because the lock is held.\n\t\t//\n\t\t// A potential solution is to expose a third Go register function *sql.Conn. Or continue to\n\t\t// use *sql.DB and document that the user SHOULD NOT SET max open connections to 1. This is\n\t\t// a bit of an edge case. For now, we guard against this scenario by checking the max open\n\t\t// connections and returning an error.\n\t\tif p.cfg.lockEnabled && p.cfg.sessionLocker != nil && p.db.Stats().MaxOpenConnections == 1 {\n\t\t\tif !useTx {\n\t\t\t\treturn errors.New(\"potential deadlock detected: cannot run Go migration without a transaction when max open connections set to 1\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase TypeSQL:\n\t\tif m.sql.Parsed {\n\t\t\treturn nil\n\t\t}\n\t\tparsed, err := sqlparser.ParseAllFromFS(fsys, m.Source, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.sql.Parsed = true\n\t\tm.sql.UseTx = parsed.UseTx\n\t\tm.sql.Up, m.sql.Down = parsed.Up, parsed.Down\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"invalid migration type: %+v\", m)\n}\n\n// printf is a helper function that prints the given message if verbose is enabled. It also prepends\n// the \"goose: \" prefix to the message.\nfunc (p *Provider) printf(msg string, args ...interface{}) {\n\tif p.cfg.verbose {\n\t\tif !strings.HasPrefix(msg, \"goose:\") {\n\t\t\tmsg = \"goose: \" + msg\n\t\t}\n\t\tp.cfg.logger.Printf(msg, args...)\n\t}\n}\n\n// runMigrations runs migrations sequentially in the given direction. If the migrations list is\n// empty, return nil without error.\nfunc (p *Provider) runMigrations(\n\tctx context.Context,\n\tconn *sql.Conn,\n\tmigrations []*Migration,\n\tdirection sqlparser.Direction,\n\tbyOne bool,\n) ([]*MigrationResult, error) {\n\tif len(migrations) == 0 {\n\t\tif !p.cfg.disableVersioning {\n\t\t\t// No need to print this message if versioning is disabled because there are no\n\t\t\t// migrations being tracked in the goose version table.\n\t\t\tmaxVersion, err := p.getDBMaxVersion(ctx, conn)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tp.printf(\"no migrations to run, current version: %d\", maxVersion)\n\t\t}\n\t\treturn nil, nil\n\t}\n\tapply := migrations\n\tif byOne {\n\t\tapply = migrations[:1]\n\t}\n\n\t// SQL migrations are lazily parsed in both directions. This is done before attempting to run\n\t// any migrations to catch errors early and prevent leaving the database in an incomplete state.\n\n\tfor _, m := range apply {\n\t\tif err := p.prepareMigration(p.fsys, m, direction.ToBool()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to prepare migration %s: %w\", m.ref(), err)\n\t\t}\n\t}\n\n\t// feat(mf): If we decide to add support for advisory locks at the transaction level, this may\n\t// be a good place to acquire the lock. However, we need to be sure that ALL migrations are safe\n\t// to run in a transaction.\n\n\t// feat(mf): this is where we can (optionally) group multiple migrations to be run in a single\n\t// transaction. The default is to apply each migration sequentially on its own. See the\n\t// following issues for more details:\n\t//  - https://github.com/pressly/goose/issues/485\n\t//  - https://github.com/pressly/goose/issues/222\n\t//\n\t// Be careful, we can't use a single transaction for all migrations because some may be marked\n\t// as not using a transaction.\n\n\tvar results []*MigrationResult\n\tfor _, m := range apply {\n\t\tresult := &MigrationResult{\n\t\t\tSource: &Source{\n\t\t\t\tType:    m.Type,\n\t\t\t\tPath:    m.Source,\n\t\t\t\tVersion: m.Version,\n\t\t\t},\n\t\t\tDirection: direction.String(),\n\t\t\tEmpty:     isEmpty(m, direction.ToBool()),\n\t\t}\n\t\tstart := time.Now()\n\t\tif err := p.runIndividually(ctx, conn, m, direction.ToBool()); err != nil {\n\t\t\t// TODO(mf): we should also return the pending migrations here, the remaining items in\n\t\t\t// the apply slice.\n\t\t\tresult.Error = err\n\t\t\tresult.Duration = time.Since(start)\n\t\t\treturn nil, &PartialError{\n\t\t\t\tApplied: results,\n\t\t\t\tFailed:  result,\n\t\t\t\tErr:     err,\n\t\t\t}\n\t\t}\n\t\tresult.Duration = time.Since(start)\n\t\tresults = append(results, result)\n\t\tp.printf(\"%s\", result)\n\t}\n\tif !p.cfg.disableVersioning && !byOne {\n\t\tmaxVersion, err := p.getDBMaxVersion(ctx, conn)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tp.printf(\"successfully migrated database, current version: %d\", maxVersion)\n\t}\n\treturn results, nil\n}\n\nfunc (p *Provider) runIndividually(\n\tctx context.Context,\n\tconn *sql.Conn,\n\tm *Migration,\n\tdirection bool,\n) error {\n\tuseTx, err := useTx(m, direction)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif useTx {\n\t\treturn beginTx(ctx, conn, func(tx *sql.Tx) error {\n\t\t\tif err := p.runMigration(ctx, tx, m, direction); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn p.maybeInsertOrDelete(ctx, tx, m.Version, direction)\n\t\t})\n\t}\n\tswitch m.Type {\n\tcase TypeGo:\n\t\t// Note, we are using *sql.DB instead of *sql.Conn because it's the Go migration contract.\n\t\t// This may be a deadlock scenario if max open connections is set to 1 AND a lock is\n\t\t// acquired on the database. In this case, the migration will block forever unable to\n\t\t// acquire a connection from the pool.\n\t\t//\n\t\t// For now, we guard against this scenario by checking the max open connections and\n\t\t// returning an error in the prepareMigration function.\n\t\tif err := p.runMigration(ctx, p.db, m, direction); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn p.maybeInsertOrDelete(ctx, p.db, m.Version, direction)\n\tcase TypeSQL:\n\t\tif err := p.runMigration(ctx, conn, m, direction); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn p.maybeInsertOrDelete(ctx, conn, m.Version, direction)\n\t}\n\treturn fmt.Errorf(\"failed to run individual migration: neither sql or go: %v\", m)\n}\n\nfunc (p *Provider) maybeInsertOrDelete(\n\tctx context.Context,\n\tdb database.DBTxConn,\n\tversion int64,\n\tdirection bool,\n) error {\n\t// If versioning is disabled, we don't need to insert or delete the migration version.\n\tif p.cfg.disableVersioning {\n\t\treturn nil\n\t}\n\tif direction {\n\t\treturn p.store.Insert(ctx, db, database.InsertRequest{Version: version})\n\t}\n\treturn p.store.Delete(ctx, db, version)\n}\n\n// beginTx begins a transaction and runs the given function. If the function returns an error, the\n// transaction is rolled back. Otherwise, the transaction is committed.\nfunc beginTx(ctx context.Context, conn *sql.Conn, fn func(tx *sql.Tx) error) (retErr error) {\n\ttx, err := conn.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\tretErr = multierr.Append(retErr, tx.Rollback())\n\t\t}\n\t}()\n\tif err := fn(tx); err != nil {\n\t\treturn err\n\t}\n\treturn tx.Commit()\n}\n\nfunc (p *Provider) initialize(ctx context.Context, useSessionLocker bool) (*sql.Conn, func() error, error) {\n\tp.mu.Lock()\n\tconn, err := p.db.Conn(ctx)\n\tif err != nil {\n\t\tp.mu.Unlock()\n\t\treturn nil, nil, err\n\t}\n\t// cleanup is a function that cleans up the connection, and optionally, the session lock.\n\tcleanup := func() error {\n\t\tp.mu.Unlock()\n\t\treturn conn.Close()\n\t}\n\tif useSessionLocker && p.cfg.sessionLocker != nil && p.cfg.lockEnabled {\n\t\tl := p.cfg.sessionLocker\n\t\tif err := l.SessionLock(ctx, conn); err != nil {\n\t\t\treturn nil, nil, multierr.Append(err, cleanup())\n\t\t}\n\t\t// A lock was acquired, so we need to unlock the session when we're done. This is done by\n\t\t// returning a cleanup function that unlocks the session and closes the connection.\n\t\tcleanup = func() error {\n\t\t\tp.mu.Unlock()\n\t\t\t// Use a detached context to unlock the session. This is because the context passed to\n\t\t\t// SessionLock may have been canceled, and we don't want to cancel the unlock.\n\t\t\treturn multierr.Append(l.SessionUnlock(context.WithoutCancel(ctx), conn), conn.Close())\n\t\t}\n\t}\n\t// If versioning is enabled, ensure the version table exists. For ad-hoc migrations, we don't\n\t// need the version table because no versions are being tracked.\n\tif !p.cfg.disableVersioning {\n\t\tif err := p.ensureVersionTable(ctx, conn); err != nil {\n\t\t\treturn nil, nil, multierr.Append(err, cleanup())\n\t\t}\n\t}\n\treturn conn, cleanup, nil\n}\n\nfunc (p *Provider) ensureVersionTable(\n\tctx context.Context,\n\tconn *sql.Conn,\n) (retErr error) {\n\t// There are 2 optimizations here:\n\t//  - 1. We create the version table once per Provider instance.\n\t//  - 2. We retry the operation a few times in case the table is being created concurrently.\n\t//\n\t// Regarding item 2, certain goose operations, like HasPending, don't respect a SessionLocker.\n\t// So, when goose is run for the first time in a multi-instance environment, it's possible that\n\t// multiple instances will try to create the version table at the same time. This is why we\n\t// retry this operation a few times. Best case, the table is created by one instance and all the\n\t// other instances see that change immediately. Worst case, all instances try to create the\n\t// table at the same time, but only one will succeed and the others will retry.\n\tp.versionTableOnce.Do(func() {\n\t\tretErr = p.tryEnsureVersionTable(ctx, conn)\n\t})\n\treturn retErr\n}\n\nfunc (p *Provider) tryEnsureVersionTable(ctx context.Context, conn *sql.Conn) error {\n\tb := retry.NewConstant(1 * time.Second)\n\tb = retry.WithMaxRetries(3, b)\n\treturn retry.Do(ctx, b, func(ctx context.Context) error {\n\t\texists, err := p.store.TableExists(ctx, conn)\n\t\tif err == nil && exists {\n\t\t\treturn nil\n\t\t} else if err != nil && errors.Is(err, errors.ErrUnsupported) {\n\t\t\t// Fallback strategy for checking table existence:\n\t\t\t//\n\t\t\t// When direct table existence checks aren't supported, we attempt to query the initial\n\t\t\t// migration (version 0). This approach has two implications:\n\t\t\t//\n\t\t\t//  1. If the table exists, the query succeeds and confirms existence\n\t\t\t//  2. If the table doesn't exist, the query fails and generates an error log\n\t\t\t//\n\t\t\t// Note: This check must occur outside any transaction, as a failed query would\n\t\t\t// otherwise cause the entire transaction to roll back. The error logs generated by this\n\t\t\t// approach are expected and can be safely ignored.\n\t\t\tif res, err := p.store.GetMigration(ctx, conn, 0); err == nil && res != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Fallthrough to create the table.\n\t\t} else if err != nil {\n\t\t\treturn fmt.Errorf(\"failed to check if version table exists: %w\", err)\n\t\t}\n\n\t\tif err := beginTx(ctx, conn, func(tx *sql.Tx) error {\n\t\t\tif err := p.store.CreateVersionTable(ctx, tx); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn p.store.Insert(ctx, tx, database.InsertRequest{Version: 0})\n\t\t}); err != nil {\n\t\t\t// Mark the error as retryable so we can try again. It's possible that another instance\n\t\t\t// is creating the table at the same time and the checks above will succeed on the next\n\t\t\t// iteration.\n\t\t\treturn retry.RetryableError(fmt.Errorf(\"failed to create version table: %w\", err))\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// getMigration returns the migration for the given version. If no migration is found, then\n// ErrVersionNotFound is returned.\nfunc (p *Provider) getMigration(version int64) (*Migration, error) {\n\tfor _, m := range p.migrations {\n\t\tif m.Version == version {\n\t\t\treturn m, nil\n\t\t}\n\t}\n\treturn nil, ErrVersionNotFound\n}\n\n// useTx is a helper function that returns true if the migration should be run in a transaction. It\n// must only be called after the migration has been parsed and initialized.\nfunc useTx(m *Migration, direction bool) (bool, error) {\n\tswitch m.Type {\n\tcase TypeGo:\n\t\tif m.goUp.Mode == 0 || m.goDown.Mode == 0 {\n\t\t\treturn false, fmt.Errorf(\"go migrations must have a mode set\")\n\t\t}\n\t\tif direction {\n\t\t\treturn m.goUp.Mode == TransactionEnabled, nil\n\t\t}\n\t\treturn m.goDown.Mode == TransactionEnabled, nil\n\tcase TypeSQL:\n\t\tif !m.sql.Parsed {\n\t\t\treturn false, fmt.Errorf(\"sql migrations must be parsed\")\n\t\t}\n\t\treturn m.sql.UseTx, nil\n\t}\n\treturn false, fmt.Errorf(\"use tx: invalid migration type: %q\", m.Type)\n}\n\n// isEmpty is a helper function that returns true if the migration has no functions or no statements\n// to execute. It must only be called after the migration has been parsed and initialized.\nfunc isEmpty(m *Migration, direction bool) bool {\n\tswitch m.Type {\n\tcase TypeGo:\n\t\tif direction {\n\t\t\treturn m.goUp.RunTx == nil && m.goUp.RunDB == nil\n\t\t}\n\t\treturn m.goDown.RunTx == nil && m.goDown.RunDB == nil\n\tcase TypeSQL:\n\t\tif direction {\n\t\t\treturn len(m.sql.Up) == 0\n\t\t}\n\t\treturn len(m.sql.Down) == 0\n\t}\n\treturn true\n}\n\n// runMigration is a helper function that runs the migration in the given direction. It must only be\n// called after the migration has been parsed and initialized.\nfunc (p *Provider) runMigration(ctx context.Context, db database.DBTxConn, m *Migration, direction bool) error {\n\tswitch m.Type {\n\tcase TypeGo:\n\t\treturn p.runGo(ctx, db, m, direction)\n\tcase TypeSQL:\n\t\treturn p.runSQL(ctx, db, m, direction)\n\t}\n\treturn fmt.Errorf(\"invalid migration type: %q\", m.Type)\n}\n\n// runGo is a helper function that runs the given Go functions in the given direction. It must only\n// be called after the migration has been initialized.\nfunc (p *Provider) runGo(ctx context.Context, db database.DBTxConn, m *Migration, direction bool) (retErr error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tretErr = fmt.Errorf(\"panic: %v\\n%s\", r, debug.Stack())\n\t\t}\n\t}()\n\n\tswitch db := db.(type) {\n\tcase *sql.Conn:\n\t\treturn fmt.Errorf(\"go migrations are not supported with *sql.Conn\")\n\tcase *sql.DB:\n\t\tif direction && m.goUp.RunDB != nil {\n\t\t\treturn m.goUp.RunDB(ctx, db)\n\t\t}\n\t\tif !direction && m.goDown.RunDB != nil {\n\t\t\treturn m.goDown.RunDB(ctx, db)\n\t\t}\n\t\treturn nil\n\tcase *sql.Tx:\n\t\tif direction && m.goUp.RunTx != nil {\n\t\t\treturn m.goUp.RunTx(ctx, db)\n\t\t}\n\t\tif !direction && m.goDown.RunTx != nil {\n\t\t\treturn m.goDown.RunTx(ctx, db)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"invalid database connection type: %T\", db)\n}\n\n// runSQL is a helper function that runs the given SQL statements in the given direction. It must\n// only be called after the migration has been parsed.\nfunc (p *Provider) runSQL(ctx context.Context, db database.DBTxConn, m *Migration, direction bool) error {\n\n\tif !m.sql.Parsed {\n\t\treturn fmt.Errorf(\"sql migrations must be parsed\")\n\t}\n\tvar statements []string\n\tif direction {\n\t\tstatements = m.sql.Up\n\t} else {\n\t\tstatements = m.sql.Down\n\t}\n\tfor _, stmt := range statements {\n\t\tif p.cfg.verbose {\n\t\t\tp.cfg.logger.Printf(\"Excuting statement: %s\", stmt)\n\t\t}\n\t\tif _, err := db.ExecContext(ctx, stmt); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "provider_run_test.go",
          "type": "blob",
          "size": 38.8095703125,
          "content": "package goose_test\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"testing/fstest\"\n\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/pressly/goose/v3/database\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProviderRun(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"closed_db\", func(t *testing.T) {\n\t\tp, db := newProviderWithDB(t)\n\t\trequire.NoError(t, db.Close())\n\t\t_, err := p.Up(context.Background())\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"failed to initialize: sql: database is closed\", err.Error())\n\t})\n\tt.Run(\"ping_and_close\", func(t *testing.T) {\n\t\tp, _ := newProviderWithDB(t)\n\t\tt.Cleanup(func() {\n\t\t\trequire.NoError(t, p.Close())\n\t\t})\n\t\trequire.NoError(t, p.Ping(context.Background()))\n\t})\n\tt.Run(\"apply_unknown_version\", func(t *testing.T) {\n\t\tp, _ := newProviderWithDB(t)\n\t\t_, err := p.ApplyVersion(context.Background(), 999, true)\n\t\trequire.Error(t, err)\n\t\trequire.ErrorIs(t, err, goose.ErrVersionNotFound)\n\t\t_, err = p.ApplyVersion(context.Background(), 999, false)\n\t\trequire.Error(t, err)\n\t\trequire.ErrorIs(t, err, goose.ErrVersionNotFound)\n\t})\n\tt.Run(\"run_zero\", func(t *testing.T) {\n\t\tp, _ := newProviderWithDB(t)\n\t\t_, err := p.UpTo(context.Background(), 0)\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"version must be greater than 0\", err.Error())\n\t\t_, err = p.DownTo(context.Background(), -1)\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"invalid version: must be a valid number or zero: -1\", err.Error())\n\t\t_, err = p.ApplyVersion(context.Background(), 0, true)\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"version must be greater than 0\", err.Error())\n\t})\n\tt.Run(\"up_and_down_all\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tconst (\n\t\t\tnumCount = 7\n\t\t)\n\t\tsources := p.ListSources()\n\t\trequire.Len(t, sources, numCount)\n\t\t// Ensure only SQL migrations are returned\n\t\tfor _, s := range sources {\n\t\t\trequire.Equal(t, goose.TypeSQL, s.Type)\n\t\t}\n\t\t// Test Up\n\t\tres, err := p.Up(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, numCount)\n\t\tassertResult(t, res[0], newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), \"up\", false)\n\t\tassertResult(t, res[1], newSource(goose.TypeSQL, \"00002_posts_table.sql\", 2), \"up\", false)\n\t\tassertResult(t, res[2], newSource(goose.TypeSQL, \"00003_comments_table.sql\", 3), \"up\", false)\n\t\tassertResult(t, res[3], newSource(goose.TypeSQL, \"00004_insert_data.sql\", 4), \"up\", false)\n\t\tassertResult(t, res[4], newSource(goose.TypeSQL, \"00005_posts_view.sql\", 5), \"up\", false)\n\t\tassertResult(t, res[5], newSource(goose.TypeSQL, \"00006_empty_up.sql\", 6), \"up\", true)\n\t\tassertResult(t, res[6], newSource(goose.TypeSQL, \"00007_empty_up_down.sql\", 7), \"up\", true)\n\t\t// Test Down\n\t\tres, err = p.DownTo(ctx, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, numCount)\n\t\tassertResult(t, res[0], newSource(goose.TypeSQL, \"00007_empty_up_down.sql\", 7), \"down\", true)\n\t\tassertResult(t, res[1], newSource(goose.TypeSQL, \"00006_empty_up.sql\", 6), \"down\", true)\n\t\tassertResult(t, res[2], newSource(goose.TypeSQL, \"00005_posts_view.sql\", 5), \"down\", false)\n\t\tassertResult(t, res[3], newSource(goose.TypeSQL, \"00004_insert_data.sql\", 4), \"down\", false)\n\t\tassertResult(t, res[4], newSource(goose.TypeSQL, \"00003_comments_table.sql\", 3), \"down\", false)\n\t\tassertResult(t, res[5], newSource(goose.TypeSQL, \"00002_posts_table.sql\", 2), \"down\", false)\n\t\tassertResult(t, res[6], newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), \"down\", false)\n\t})\n\tt.Run(\"up_and_down_by_one\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tmaxVersion := len(p.ListSources())\n\t\t// Apply all migrations one-by-one.\n\t\tvar counter int\n\t\tfor {\n\t\t\tres, err := p.UpByOne(ctx)\n\t\t\tcounter++\n\t\t\tif counter > maxVersion {\n\t\t\t\tif !errors.Is(err, goose.ErrNoNextVersion) {\n\t\t\t\t\tt.Fatalf(\"incorrect error: got:%v want:%v\", err, goose.ErrNoNextVersion)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, res)\n\t\t\trequire.Equal(t, res.Source.Version, int64(counter))\n\t\t}\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, currentVersion, int64(maxVersion))\n\t\t// Reset counter\n\t\tcounter = 0\n\t\t// Rollback all migrations one-by-one.\n\t\tfor {\n\t\t\tres, err := p.Down(ctx)\n\t\t\tcounter++\n\t\t\tif counter > maxVersion {\n\t\t\t\tif !errors.Is(err, goose.ErrNoNextVersion) {\n\t\t\t\t\tt.Fatalf(\"incorrect error: got:%v want:%v\", err, goose.ErrNoNextVersion)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, res)\n\t\t\trequire.Equal(t, res.Source.Version, int64(maxVersion-counter+1))\n\t\t}\n\t\t// Once everything is tested the version should match the highest testdata version\n\t\tcurrentVersion, err = p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 0, currentVersion)\n\t})\n\tt.Run(\"up_to\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, db := newProviderWithDB(t)\n\t\tconst (\n\t\t\tupToVersion int64 = 2\n\t\t)\n\t\tresults, err := p.UpTo(ctx, upToVersion)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, results, int(upToVersion))\n\t\tassertResult(t, results[0], newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), \"up\", false)\n\t\tassertResult(t, results[1], newSource(goose.TypeSQL, \"00002_posts_table.sql\", 2), \"up\", false)\n\t\t// Fetch the goose version from DB\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, upToVersion, currentVersion)\n\t\t// Validate the version actually matches what goose claims it is\n\t\tgotVersion, err := getMaxVersionID(db, goose.DefaultTablename)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, upToVersion, gotVersion)\n\t})\n\tt.Run(\"sql_connections\", func(t *testing.T) {\n\t\ttt := []struct {\n\t\t\tname         string\n\t\t\tmaxOpenConns int\n\t\t\tmaxIdleConns int\n\t\t\tuseDefaults  bool\n\t\t}{\n\t\t\t// Single connection ensures goose is able to function correctly when multiple\n\t\t\t// connections are not available.\n\t\t\t{name: \"single_conn\", maxOpenConns: 1, maxIdleConns: 1},\n\t\t\t{name: \"defaults\", useDefaults: true},\n\t\t}\n\t\tfor _, tc := range tt {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tctx := context.Background()\n\t\t\t\t// Start a new database for each test case.\n\t\t\t\tp, db := newProviderWithDB(t)\n\t\t\t\tif !tc.useDefaults {\n\t\t\t\t\tdb.SetMaxOpenConns(tc.maxOpenConns)\n\t\t\t\t\tdb.SetMaxIdleConns(tc.maxIdleConns)\n\t\t\t\t}\n\t\t\t\tsources := p.ListSources()\n\t\t\t\trequire.NotEmpty(t, sources)\n\n\t\t\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.EqualValues(t, 0, currentVersion)\n\n\t\t\t\t{\n\t\t\t\t\t// Apply all up migrations\n\t\t\t\t\tupResult, err := p.Up(ctx)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, len(upResult), len(sources))\n\t\t\t\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, currentVersion, p.ListSources()[len(sources)-1].Version)\n\t\t\t\t\t// Validate the db migration version actually matches what goose claims it is\n\t\t\t\t\tgotVersion, err := getMaxVersionID(db, goose.DefaultTablename)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, gotVersion, currentVersion)\n\t\t\t\t\ttables, err := getTableNames(db)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tif !reflect.DeepEqual(tables, knownTables) {\n\t\t\t\t\t\tt.Logf(\"got tables: %v\", tables)\n\t\t\t\t\t\tt.Logf(\"known tables: %v\", knownTables)\n\t\t\t\t\t\tt.Fatal(\"failed to match tables\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t// Apply all down migrations\n\t\t\t\t\tdownResult, err := p.DownTo(ctx, 0)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, len(downResult), len(sources))\n\t\t\t\t\tgotVersion, err := getMaxVersionID(db, goose.DefaultTablename)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.EqualValues(t, 0, gotVersion)\n\t\t\t\t\t// Should only be left with a single table, the default goose table\n\t\t\t\t\ttables, err := getTableNames(db)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tknownTables := []string{goose.DefaultTablename, \"sqlite_sequence\"}\n\t\t\t\t\tif !reflect.DeepEqual(tables, knownTables) {\n\t\t\t\t\t\tt.Logf(\"got tables: %v\", tables)\n\t\t\t\t\t\tt.Logf(\"known tables: %v\", knownTables)\n\t\t\t\t\t\tt.Fatal(\"failed to match tables\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"apply\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tsources := p.ListSources()\n\t\t// Apply all migrations in the up direction.\n\t\tfor _, s := range sources {\n\t\t\tres, err := p.ApplyVersion(ctx, s.Version, true)\n\t\t\trequire.NoError(t, err)\n\t\t\t// Round-trip the migration result through the database to ensure it's valid.\n\t\t\tvar empty bool\n\t\t\tif s.Version == 6 || s.Version == 7 {\n\t\t\t\tempty = true\n\t\t\t}\n\t\t\tassertResult(t, res, s, \"up\", empty)\n\t\t}\n\t\t// Apply all migrations in the down direction.\n\t\tfor i := len(sources) - 1; i >= 0; i-- {\n\t\t\ts := sources[i]\n\t\t\tres, err := p.ApplyVersion(ctx, s.Version, false)\n\t\t\trequire.NoError(t, err)\n\t\t\t// Round-trip the migration result through the database to ensure it's valid.\n\t\t\tvar empty bool\n\t\t\tif s.Version == 6 || s.Version == 7 {\n\t\t\t\tempty = true\n\t\t\t}\n\t\t\tassertResult(t, res, s, \"down\", empty)\n\t\t}\n\t\t// Try apply version 1 multiple times\n\t\t_, err := p.ApplyVersion(ctx, 1, true)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.ApplyVersion(ctx, 1, true)\n\t\trequire.Error(t, err)\n\t\trequire.ErrorIs(t, err, goose.ErrAlreadyApplied)\n\t\trequire.Contains(t, err.Error(), \"version 1: migration already applied\")\n\t})\n\tt.Run(\"status\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tnumCount := len(p.ListSources())\n\t\t// Before any migrations are applied, the status should be empty.\n\t\tstatus, err := p.Status(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, len(status), numCount)\n\t\tassertStatus(t, status[0], goose.StatePending, newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), true)\n\t\tassertStatus(t, status[1], goose.StatePending, newSource(goose.TypeSQL, \"00002_posts_table.sql\", 2), true)\n\t\tassertStatus(t, status[2], goose.StatePending, newSource(goose.TypeSQL, \"00003_comments_table.sql\", 3), true)\n\t\tassertStatus(t, status[3], goose.StatePending, newSource(goose.TypeSQL, \"00004_insert_data.sql\", 4), true)\n\t\tassertStatus(t, status[4], goose.StatePending, newSource(goose.TypeSQL, \"00005_posts_view.sql\", 5), true)\n\t\tassertStatus(t, status[5], goose.StatePending, newSource(goose.TypeSQL, \"00006_empty_up.sql\", 6), true)\n\t\tassertStatus(t, status[6], goose.StatePending, newSource(goose.TypeSQL, \"00007_empty_up_down.sql\", 7), true)\n\t\t// Apply all migrations\n\t\t_, err = p.Up(ctx)\n\t\trequire.NoError(t, err)\n\t\tstatus, err = p.Status(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, len(status), numCount)\n\t\tassertStatus(t, status[0], goose.StateApplied, newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), false)\n\t\tassertStatus(t, status[1], goose.StateApplied, newSource(goose.TypeSQL, \"00002_posts_table.sql\", 2), false)\n\t\tassertStatus(t, status[2], goose.StateApplied, newSource(goose.TypeSQL, \"00003_comments_table.sql\", 3), false)\n\t\tassertStatus(t, status[3], goose.StateApplied, newSource(goose.TypeSQL, \"00004_insert_data.sql\", 4), false)\n\t\tassertStatus(t, status[4], goose.StateApplied, newSource(goose.TypeSQL, \"00005_posts_view.sql\", 5), false)\n\t\tassertStatus(t, status[5], goose.StateApplied, newSource(goose.TypeSQL, \"00006_empty_up.sql\", 6), false)\n\t\tassertStatus(t, status[6], goose.StateApplied, newSource(goose.TypeSQL, \"00007_empty_up_down.sql\", 7), false)\n\t})\n\tt.Run(\"tx_partial_errors\", func(t *testing.T) {\n\t\tcountOwners := func(db *sql.DB) (int, error) {\n\t\t\tq := `SELECT count(*)FROM owners`\n\t\t\tvar count int\n\t\t\tif err := db.QueryRow(q).Scan(&count); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn count, nil\n\t\t}\n\n\t\tctx := context.Background()\n\t\tdb := newDB(t)\n\t\tmapFS := fstest.MapFS{\n\t\t\t\"00001_users_table.sql\": newMapFile(`\n-- +goose Up\nCREATE TABLE owners ( owner_name TEXT NOT NULL );\n`),\n\t\t\t\"00002_partial_error.sql\": newMapFile(`\n-- +goose Up\nINSERT INTO invalid_table (invalid_table) VALUES ('invalid_value');\n`),\n\t\t\t\"00003_insert_data.sql\": newMapFile(`\n-- +goose Up\nINSERT INTO owners (owner_name) VALUES ('seed-user-1');\nINSERT INTO owners (owner_name) VALUES ('seed-user-2');\nINSERT INTO owners (owner_name) VALUES ('seed-user-3');\n`),\n\t\t}\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, mapFS)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.Up(ctx)\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"partial migration error (type:sql,version:2)\")\n\t\texpected := new(goose.PartialError)\n\t\trequire.ErrorAs(t, err, &expected)\n\t\t// Check Err field\n\t\trequire.Contains(t, expected.Err.Error(), \"SQL logic error: no such table: invalid_table (1)\")\n\t\t// Check Results field\n\t\trequire.Len(t, expected.Applied, 1)\n\t\tassertResult(t, expected.Applied[0], newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), \"up\", false)\n\t\t// Check Failed field\n\t\trequire.NotNil(t, expected.Failed)\n\t\tassertSource(t, expected.Failed.Source, goose.TypeSQL, \"00002_partial_error.sql\", 2)\n\t\trequire.False(t, expected.Failed.Empty)\n\t\trequire.Error(t, expected.Failed.Error)\n\t\trequire.Contains(t, expected.Failed.Error.Error(), \"SQL logic error: no such table: invalid_table (1)\")\n\t\trequire.Equal(t, \"up\", expected.Failed.Direction)\n\t\trequire.Positive(t, expected.Failed.Duration)\n\n\t\t// Ensure the partial error did not affect the database.\n\t\tcount, err := countOwners(db)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, 0, count)\n\n\t\tstatus, err := p.Status(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, status, 3)\n\t\tassertStatus(t, status[0], goose.StateApplied, newSource(goose.TypeSQL, \"00001_users_table.sql\", 1), false)\n\t\tassertStatus(t, status[1], goose.StatePending, newSource(goose.TypeSQL, \"00002_partial_error.sql\", 2), true)\n\t\tassertStatus(t, status[2], goose.StatePending, newSource(goose.TypeSQL, \"00003_insert_data.sql\", 3), true)\n\t})\n}\n\nfunc TestConcurrentProvider(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"up\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tmaxVersion := len(p.ListSources())\n\n\t\tch := make(chan int64)\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < maxVersion; i++ {\n\t\t\twg.Add(1)\n\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tres, err := p.UpByOne(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif res == nil {\n\t\t\t\t\tt.Errorf(\"expected non-nil result, got nil\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tch <- res.Source.Version\n\t\t\t}()\n\t\t}\n\t\tgo func() {\n\t\t\twg.Wait()\n\t\t\tclose(ch)\n\t\t}()\n\t\tvar versions []int64\n\t\tfor version := range ch {\n\t\t\tversions = append(versions, version)\n\t\t}\n\t\t// Fail early if any of the goroutines failed.\n\t\tif t.Failed() {\n\t\t\treturn\n\t\t}\n\t\trequire.Equal(t, len(versions), maxVersion)\n\t\tfor i := 0; i < maxVersion; i++ {\n\t\t\trequire.Equal(t, versions[i], int64(i+1))\n\t\t}\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, currentVersion, maxVersion)\n\t})\n\tt.Run(\"down\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _ := newProviderWithDB(t)\n\t\tmaxVersion := len(p.ListSources())\n\t\t// Apply all migrations\n\t\t_, err := p.Up(ctx)\n\t\trequire.NoError(t, err)\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, currentVersion, maxVersion)\n\n\t\tch := make(chan []*goose.MigrationResult)\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < maxVersion; i++ {\n\t\t\twg.Add(1)\n\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tres, err := p.DownTo(ctx, 0)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tch <- res\n\t\t\t}()\n\t\t}\n\t\tgo func() {\n\t\t\twg.Wait()\n\t\t\tclose(ch)\n\t\t}()\n\t\tvar (\n\t\t\tvalid [][]*goose.MigrationResult\n\t\t\tempty [][]*goose.MigrationResult\n\t\t)\n\t\tfor results := range ch {\n\t\t\tif len(results) == 0 {\n\t\t\t\tempty = append(empty, results)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalid = append(valid, results)\n\t\t}\n\t\t// Fail early if any of the goroutines failed.\n\t\tif t.Failed() {\n\t\t\treturn\n\t\t}\n\t\trequire.Len(t, valid, 1)\n\t\trequire.Equal(t, len(empty), maxVersion-1)\n\t\t// Ensure the valid result is correct.\n\t\trequire.Equal(t, len(valid[0]), maxVersion)\n\t})\n}\n\nfunc TestNoVersioning(t *testing.T) {\n\tt.Parallel()\n\n\tcountSeedOwners := func(db *sql.DB) (int, error) {\n\t\tq := `SELECT count(*)FROM owners WHERE owner_name LIKE'seed-user-%'`\n\t\tvar count int\n\t\tif err := db.QueryRow(q).Scan(&count); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn count, nil\n\t}\n\tcountOwners := func(db *sql.DB) (int, error) {\n\t\tq := `SELECT count(*)FROM owners`\n\t\tvar count int\n\t\tif err := db.QueryRow(q).Scan(&count); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn count, nil\n\t}\n\tctx := context.Background()\n\tdbName := fmt.Sprintf(\"test_%s.db\", randomAlphaNumeric(8))\n\tdb, err := sql.Open(\"sqlite\", filepath.Join(t.TempDir(), dbName))\n\trequire.NoError(t, err)\n\tfsys := os.DirFS(filepath.Join(\"testdata\", \"no-versioning\", \"migrations\"))\n\tconst (\n\t\t// Total owners created by the seed files.\n\t\twantSeedOwnerCount = 250\n\t\t// These are owners created by migration files.\n\t\twantOwnerCount = 4\n\t)\n\tp, err := goose.NewProvider(goose.DialectSQLite3, db, fsys,\n\t\tgoose.WithVerbose(testing.Verbose()),\n\t\tgoose.WithDisableVersioning(false), // This is the default.\n\t)\n\trequire.Len(t, p.ListSources(), 3)\n\trequire.NoError(t, err)\n\t_, err = p.Up(ctx)\n\trequire.NoError(t, err)\n\tbaseVersion, err := p.GetDBVersion(ctx)\n\trequire.NoError(t, err)\n\trequire.EqualValues(t, 3, baseVersion)\n\tt.Run(\"seed-up-down-to-zero\", func(t *testing.T) {\n\t\tfsys := os.DirFS(filepath.Join(\"testdata\", \"no-versioning\", \"seed\"))\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, fsys,\n\t\t\tgoose.WithVerbose(testing.Verbose()),\n\t\t\tgoose.WithDisableVersioning(true), // Provider with no versioning.\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, p.ListSources(), 2)\n\n\t\t// Run (all) up migrations from the seed dir\n\t\t{\n\t\t\tupResult, err := p.Up(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, upResult, 2)\n\t\t\t// When versioning is disabled, we cannot track the version of the seed files.\n\t\t\t_, err = p.GetDBVersion(ctx)\n\t\t\trequire.Error(t, err)\n\t\t\tseedOwnerCount, err := countSeedOwners(db)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, wantSeedOwnerCount, seedOwnerCount)\n\t\t}\n\t\t// Run (all) down migrations from the seed dir\n\t\t{\n\t\t\tdownResult, err := p.DownTo(ctx, 0)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, downResult, 2)\n\t\t\t// When versioning is disabled, we cannot track the version of the seed files.\n\t\t\t_, err = p.GetDBVersion(ctx)\n\t\t\trequire.Error(t, err)\n\t\t\tseedOwnerCount, err := countSeedOwners(db)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, 0, seedOwnerCount)\n\t\t}\n\t\t// The migrations added 4 non-seed owners, they must remain in the database afterwards\n\t\townerCount, err := countOwners(db)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, wantOwnerCount, ownerCount)\n\t})\n}\n\nfunc TestAllowMissing(t *testing.T) {\n\tt.Parallel()\n\tctx := context.Background()\n\n\t// Developer A and B check out the \"main\" branch which is currently on version 3. Developer A\n\t// mistakenly creates migration 5 and commits. Developer B did not pull the latest changes and\n\t// commits migration 4. Oops -- now the migrations are out of order.\n\t//\n\t// When goose is set to allow missing migrations, then 5 is applied after 4 with no error.\n\t// Otherwise it's expected to be an error.\n\n\tt.Run(\"missing_now_allowed\", func(t *testing.T) {\n\t\tdb := newDB(t)\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, newFsys(),\n\t\t\tgoose.WithAllowOutofOrder(false),\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\t// Create and apply first 3 migrations.\n\t\t_, err = p.UpTo(ctx, 3)\n\t\trequire.NoError(t, err)\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 3, currentVersion)\n\n\t\t// Developer A - migration 5 (mistakenly applied)\n\t\tresult, err := p.ApplyVersion(ctx, 5, true)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 5, result.Source.Version)\n\t\tcurrent, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 5, current)\n\n\t\t// The database has migrations 1,2,3,5 applied.\n\n\t\t// Developer B is on version 3 (e.g., never pulled the latest changes). Adds migration 4. By\n\t\t// default goose does not allow missing (out-of-order) migrations, which means halt if a\n\t\t// missing migration is detected.\n\t\t_, err = p.Up(ctx)\n\t\trequire.Error(t, err)\n\t\t// found 1 missing (out-of-order) migration: [00004_insert_data.sql]\n\t\trequire.Contains(t, err.Error(), \"missing (out-of-order) migration\")\n\t\t// Confirm db version is unchanged.\n\t\tcurrent, err = p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 5, current)\n\n\t\t_, err = p.UpByOne(ctx)\n\t\trequire.Error(t, err)\n\t\t// found 1 missing (out-of-order) migration: [00004_insert_data.sql]\n\t\trequire.Contains(t, err.Error(), \"missing (out-of-order) migration\")\n\t\t// Confirm db version is unchanged.\n\t\tcurrent, err = p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 5, current)\n\n\t\t_, err = p.UpTo(ctx, math.MaxInt64)\n\t\trequire.Error(t, err)\n\t\t// found 1 missing (out-of-order) migration: [00004_insert_data.sql]\n\t\trequire.Contains(t, err.Error(), \"missing (out-of-order) migration\")\n\t\t// Confirm db version is unchanged.\n\t\tcurrent, err = p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 5, current)\n\t})\n\n\tt.Run(\"missing_allowed\", func(t *testing.T) {\n\t\tdb := newDB(t)\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, newFsys(),\n\t\t\tgoose.WithAllowOutofOrder(true),\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\t// Create and apply first 3 migrations.\n\t\t_, err = p.UpTo(ctx, 3)\n\t\trequire.NoError(t, err)\n\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 3, currentVersion)\n\n\t\t// Developer A - migration 5 (mistakenly applied)\n\t\t{\n\t\t\t_, err = p.ApplyVersion(ctx, 5, true)\n\t\t\trequire.NoError(t, err)\n\t\t\tcurrent, err := p.GetDBVersion(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.EqualValues(t, 5, current)\n\t\t}\n\t\t// Developer B - migration 4 (missing) and 6 (new)\n\t\t{\n\t\t\t// 4\n\t\t\tupResult, err := p.UpByOne(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, upResult)\n\t\t\trequire.EqualValues(t, 4, upResult.Source.Version)\n\t\t\t// 6\n\t\t\tupResult, err = p.UpByOne(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, upResult)\n\t\t\trequire.EqualValues(t, 6, upResult.Source.Version)\n\n\t\t\tcount, err := getGooseVersionCount(db, goose.DefaultTablename)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.EqualValues(t, 6, count)\n\t\t\tcurrent, err := p.GetDBVersion(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\t// Expecting max(version_id) to be 8\n\t\t\trequire.EqualValues(t, 6, current)\n\t\t}\n\n\t\t// The applied order in the database is expected to be:\n\t\t//      1,2,3,5,4,6\n\t\t// So migrating down should be the reverse of the applied order:\n\t\t//      6,4,5,3,2,1\n\n\t\ttestDownAndVersion := func(wantDBVersion, wantResultVersion int64) {\n\t\t\tcurrentVersion, err := p.GetDBVersion(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, wantDBVersion, currentVersion)\n\t\t\tdownRes, err := p.Down(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, downRes)\n\t\t\trequire.Equal(t, wantResultVersion, downRes.Source.Version)\n\t\t}\n\n\t\t// This behaviour may need to change, see the following issues for more details:\n\t\t//  - https://github.com/pressly/goose/issues/523\n\t\t//  - https://github.com/pressly/goose/issues/402\n\n\t\ttestDownAndVersion(6, 6)\n\t\ttestDownAndVersion(5, 4) // Ensure the max db version is 5 before down.\n\t\ttestDownAndVersion(5, 5)\n\t\ttestDownAndVersion(3, 3)\n\t\ttestDownAndVersion(2, 2)\n\t\ttestDownAndVersion(1, 1)\n\t\t_, err = p.Down(ctx)\n\t\trequire.Error(t, err)\n\t\trequire.ErrorIs(t, err, goose.ErrNoNextVersion)\n\t})\n}\n\nfunc TestSQLiteSharedCache(t *testing.T) {\n\tt.Parallel()\n\t// goose uses *sql.Conn for most operations (incl. creating the initial table), but for Go\n\t// migrations when running outside a transaction we use *sql.DB. This is a problem for SQLite\n\t// because it does not support shared cache mode by default and it does not see the table that\n\t// was created through the initial connection. This test ensures goose works with SQLite shared\n\t// cache mode.\n\t//\n\t// Ref: https://www.sqlite.org/inmemorydb.html\n\t//\n\t// \"In-memory databases are allowed to use shared cache if they are opened using a URI filename.\n\t// If the unadorned \":memory:\" name is used to specify the in-memory database, then that\n\t// database always has a private cache and is only visible to the database connection that\n\t// originally opened it. However, the same in-memory database can be opened by two or more\n\t// database connections as follows: file::memory:?cache=shared\"\n\tt.Run(\"shared_cache\", func(t *testing.T) {\n\t\tdb, err := sql.Open(\"sqlite\", \"file::memory:?cache=shared\")\n\t\trequire.NoError(t, err)\n\t\tfsys := fstest.MapFS{\"00001_a.sql\": newMapFile(`-- +goose Up`)}\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, fsys,\n\t\t\tgoose.WithGoMigrations(\n\t\t\t\tgoose.NewGoMigration(2, &goose.GoFunc{Mode: goose.TransactionDisabled}, nil),\n\t\t\t),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.Up(context.Background())\n\t\trequire.NoError(t, err)\n\t})\n\tt.Run(\"no_shared_cache\", func(t *testing.T) {\n\t\tdb, err := sql.Open(\"sqlite\", \"file::memory:\")\n\t\trequire.NoError(t, err)\n\t\tfsys := fstest.MapFS{\"00001_a.sql\": newMapFile(`-- +goose Up`)}\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, fsys,\n\t\t\tgoose.WithGoMigrations(\n\t\t\t\tgoose.NewGoMigration(2, &goose.GoFunc{Mode: goose.TransactionDisabled}, nil),\n\t\t\t),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.Up(context.Background())\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), \"SQL logic error: no such table: goose_db_version\")\n\t})\n}\n\nfunc TestGoMigrationPanic(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tconst (\n\t\twantErrString = \"panic: runtime error: index out of range [7] with length 0\"\n\t)\n\tmigration := goose.NewGoMigration(\n\t\t1,\n\t\t&goose.GoFunc{RunTx: func(ctx context.Context, tx *sql.Tx) error {\n\t\t\tvar ss []int\n\t\t\t_ = ss[7]\n\t\t\treturn nil\n\t\t}},\n\t\tnil,\n\t)\n\tp, err := goose.NewProvider(goose.DialectSQLite3, newDB(t), nil,\n\t\tgoose.WithGoMigrations(migration), // Add a Go migration that panics.\n\t)\n\trequire.NoError(t, err)\n\t_, err = p.Up(ctx)\n\trequire.Error(t, err)\n\texpected := new(goose.PartialError)\n\trequire.ErrorAs(t, err, &expected)\n\trequire.Contains(t, expected.Err.Error(), wantErrString)\n}\n\nfunc TestCustomStoreTableExists(t *testing.T) {\n\tt.Parallel()\n\tdb := newDB(t)\n\tstore, err := database.NewStore(database.DialectSQLite3, goose.DefaultTablename)\n\trequire.NoError(t, err)\n\tfor i := 0; i < 2; i++ {\n\t\tp, err := goose.NewProvider(\"\", db, newFsys(),\n\t\t\tgoose.WithStore(&customStoreSQLite3{store}),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.Up(context.Background())\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc TestProviderApply(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\tp, err := goose.NewProvider(goose.DialectSQLite3, newDB(t), newFsys())\n\trequire.NoError(t, err)\n\t_, err = p.ApplyVersion(ctx, 1, true)\n\trequire.NoError(t, err)\n\t// This version has a corresponding down migration, but has never been applied.\n\t_, err = p.ApplyVersion(ctx, 2, false)\n\trequire.Error(t, err)\n\trequire.ErrorIs(t, err, goose.ErrNotApplied)\n}\n\nfunc TestPending(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"allow_out_of_order\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tfsys := newFsys()\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, newDB(t), fsys,\n\t\t\tgoose.WithAllowOutofOrder(true),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\t// Some migrations have been applied out of order.\n\t\t_, err = p.ApplyVersion(ctx, 1, true)\n\t\trequire.NoError(t, err)\n\t\t_, err = p.ApplyVersion(ctx, 3, true)\n\t\trequire.NoError(t, err)\n\t\t// Even though the latest migration HAS been applied, there are still pending out-of-order\n\t\t// migrations.\n\t\tcurrent, target, err := p.GetVersions(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.EqualValues(t, 3, current)\n\t\trequire.Len(t, fsys, int(target))\n\t\thasPending, err := p.HasPending(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, hasPending)\n\t\t// Apply the missing migrations.\n\t\t_, err = p.Up(ctx)\n\t\trequire.NoError(t, err)\n\t\t// All migrations have been applied.\n\t\thasPending, err = p.HasPending(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.False(t, hasPending)\n\t\tcurrent, target, err = p.GetVersions(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, current, target)\n\t})\n\tt.Run(\"disallow_out_of_order\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tfsys := newFsys()\n\n\t\trun := func(t *testing.T, versionToApply int64) {\n\t\t\tt.Helper()\n\t\t\tp, err := goose.NewProvider(goose.DialectSQLite3, newDB(t), fsys,\n\t\t\t\tgoose.WithAllowOutofOrder(false),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\t// Some migrations have been applied.\n\t\t\t_, err = p.ApplyVersion(ctx, 1, true)\n\t\t\trequire.NoError(t, err)\n\t\t\t_, err = p.ApplyVersion(ctx, versionToApply, true)\n\t\t\trequire.NoError(t, err)\n\t\t\t// TODO(mf): revisit the pending check behavior in addition to the HasPending\n\t\t\t// method.\n\t\t\tcurrent, target, err := p.GetVersions(ctx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, current, versionToApply)\n\t\t\trequire.Len(t, fsys, int(target))\n\t\t\t_, err = p.HasPending(ctx)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"missing (out-of-order) migration\")\n\t\t\t_, err = p.Up(ctx)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"missing (out-of-order) migration\")\n\t\t}\n\n\t\tt.Run(\"latest_version\", func(t *testing.T) {\n\t\t\trun(t, int64(len(fsys)))\n\t\t})\n\t\tt.Run(\"latest_version_minus_one\", func(t *testing.T) {\n\t\t\trun(t, int64(len(fsys)-1))\n\t\t})\n\t})\n}\n\nvar _ database.StoreExtender = (*customStoreSQLite3)(nil)\n\ntype customStoreSQLite3 struct{ database.Store }\n\nfunc (s *customStoreSQLite3) TableExists(ctx context.Context, db database.DBTxConn) (bool, error) {\n\tq := `SELECT EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name=?) AS table_exists`\n\tvar exists bool\n\tif err := db.QueryRowContext(ctx, q, s.Tablename()).Scan(&exists); err != nil {\n\t\treturn false, err\n\t}\n\treturn exists, nil\n}\n\nfunc getGooseVersionCount(db *sql.DB, gooseTable string) (int64, error) {\n\tvar gotVersion int64\n\tif err := db.QueryRow(\n\t\tfmt.Sprintf(\"SELECT count(*) FROM %s WHERE version_id > 0\", gooseTable),\n\t).Scan(&gotVersion); err != nil {\n\t\treturn 0, err\n\t}\n\treturn gotVersion, nil\n}\n\nfunc TestGoOnly(t *testing.T) {\n\tt.Cleanup(goose.ResetGlobalMigrations)\n\t// Not parallel because each subtest modifies global state.\n\n\tcountUser := func(db *sql.DB) int {\n\t\tq := `SELECT count(*)FROM users`\n\t\tvar count int\n\t\terr := db.QueryRow(q).Scan(&count)\n\t\trequire.NoError(t, err)\n\t\treturn count\n\t}\n\n\tt.Run(\"with_tx\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tregister := []*goose.Migration{\n\t\t\tgoose.NewGoMigration(\n\t\t\t\t1,\n\t\t\t\t&goose.GoFunc{RunTx: newTxFn(\"CREATE TABLE users (id INTEGER PRIMARY KEY)\")},\n\t\t\t\t&goose.GoFunc{RunTx: newTxFn(\"DROP TABLE users\")},\n\t\t\t),\n\t\t}\n\t\terr := goose.SetGlobalMigrations(register...)\n\t\trequire.NoError(t, err)\n\t\tt.Cleanup(goose.ResetGlobalMigrations)\n\n\t\tdb := newDB(t)\n\t\tregister = []*goose.Migration{\n\t\t\tgoose.NewGoMigration(\n\t\t\t\t2,\n\t\t\t\t&goose.GoFunc{RunTx: newTxFn(\"INSERT INTO users (id) VALUES (1), (2), (3)\")},\n\t\t\t\t&goose.GoFunc{RunTx: newTxFn(\"DELETE FROM users\")},\n\t\t\t),\n\t\t}\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, nil,\n\t\t\tgoose.WithGoMigrations(register...),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\tsources := p.ListSources()\n\t\trequire.Len(t, p.ListSources(), 2)\n\t\tassertSource(t, sources[0], goose.TypeGo, \"\", 1)\n\t\tassertSource(t, sources[1], goose.TypeGo, \"\", 2)\n\t\t// Apply migration 1\n\t\tres, err := p.UpByOne(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 1), \"up\", false)\n\t\trequire.Equal(t, 0, countUser(db))\n\t\trequire.True(t, tableExists(t, db, \"users\"))\n\t\t// Apply migration 2\n\t\tres, err = p.UpByOne(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 2), \"up\", false)\n\t\trequire.Equal(t, 3, countUser(db))\n\t\t// Rollback migration 2\n\t\tres, err = p.Down(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 2), \"down\", false)\n\t\trequire.Equal(t, 0, countUser(db))\n\t\t// Rollback migration 1\n\t\tres, err = p.Down(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 1), \"down\", false)\n\t\t// Check table does not exist\n\t\trequire.False(t, tableExists(t, db, \"users\"))\n\t})\n\tt.Run(\"with_db\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tregister := []*goose.Migration{\n\t\t\tgoose.NewGoMigration(\n\t\t\t\t1,\n\t\t\t\t&goose.GoFunc{\n\t\t\t\t\tRunDB: newDBFn(\"CREATE TABLE users (id INTEGER PRIMARY KEY)\"),\n\t\t\t\t},\n\t\t\t\t&goose.GoFunc{\n\t\t\t\t\tRunDB: newDBFn(\"DROP TABLE users\"),\n\t\t\t\t},\n\t\t\t),\n\t\t}\n\t\terr := goose.SetGlobalMigrations(register...)\n\t\trequire.NoError(t, err)\n\t\tt.Cleanup(goose.ResetGlobalMigrations)\n\n\t\tdb := newDB(t)\n\t\tregister = []*goose.Migration{\n\t\t\tgoose.NewGoMigration(\n\t\t\t\t2,\n\t\t\t\t&goose.GoFunc{RunDB: newDBFn(\"INSERT INTO users (id) VALUES (1), (2), (3)\")},\n\t\t\t\t&goose.GoFunc{RunDB: newDBFn(\"DELETE FROM users\")},\n\t\t\t),\n\t\t}\n\t\tp, err := goose.NewProvider(goose.DialectSQLite3, db, nil,\n\t\t\tgoose.WithGoMigrations(register...),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\tsources := p.ListSources()\n\t\trequire.Len(t, p.ListSources(), 2)\n\t\tassertSource(t, sources[0], goose.TypeGo, \"\", 1)\n\t\tassertSource(t, sources[1], goose.TypeGo, \"\", 2)\n\t\t// Apply migration 1\n\t\tres, err := p.UpByOne(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 1), \"up\", false)\n\t\trequire.Equal(t, 0, countUser(db))\n\t\trequire.True(t, tableExists(t, db, \"users\"))\n\t\t// Apply migration 2\n\t\tres, err = p.UpByOne(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 2), \"up\", false)\n\t\trequire.Equal(t, 3, countUser(db))\n\t\t// Rollback migration 2\n\t\tres, err = p.Down(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 2), \"down\", false)\n\t\trequire.Equal(t, 0, countUser(db))\n\t\t// Rollback migration 1\n\t\tres, err = p.Down(ctx)\n\t\trequire.NoError(t, err)\n\t\tassertResult(t, res, newSource(goose.TypeGo, \"\", 1), \"down\", false)\n\t\t// Check table does not exist\n\t\trequire.False(t, tableExists(t, db, \"users\"))\n\t})\n}\n\nfunc newDBFn(query string) func(context.Context, *sql.DB) error {\n\treturn func(ctx context.Context, db *sql.DB) error {\n\t\t_, err := db.ExecContext(ctx, query)\n\t\treturn err\n\t}\n}\n\nfunc newTxFn(query string) func(context.Context, *sql.Tx) error {\n\treturn func(ctx context.Context, tx *sql.Tx) error {\n\t\t_, err := tx.ExecContext(ctx, query)\n\t\treturn err\n\t}\n}\n\nfunc tableExists(t *testing.T, db *sql.DB, table string) bool {\n\tq := fmt.Sprintf(`SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END AS table_exists FROM sqlite_master WHERE type = 'table' AND name = '%s'`, table)\n\tvar b string\n\terr := db.QueryRow(q).Scan(&b)\n\trequire.NoError(t, err)\n\treturn b == \"1\"\n}\n\nconst (\n\tcharset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n)\n\nfunc randomAlphaNumeric(length int) string {\n\tb := make([]byte, length)\n\tfor i := range b {\n\t\tb[i] = charset[rand.Intn(len(charset))]\n\t}\n\treturn string(b)\n}\n\nfunc newProviderWithDB(t *testing.T, opts ...goose.ProviderOption) (*goose.Provider, *sql.DB) {\n\tt.Helper()\n\tdb := newDB(t)\n\topts = append(\n\t\topts,\n\t\tgoose.WithVerbose(testing.Verbose()),\n\t)\n\tp, err := goose.NewProvider(goose.DialectSQLite3, db, newFsys(), opts...)\n\trequire.NoError(t, err)\n\treturn p, db\n}\n\nfunc newDB(t *testing.T) *sql.DB {\n\tt.Helper()\n\tdbName := fmt.Sprintf(\"test_%s.db\", randomAlphaNumeric(8))\n\tdb, err := sql.Open(\"sqlite\", filepath.Join(t.TempDir(), dbName))\n\trequire.NoError(t, err)\n\treturn db\n}\n\nfunc getMaxVersionID(db *sql.DB, gooseTable string) (int64, error) {\n\tvar gotVersion int64\n\tif err := db.QueryRow(\n\t\tfmt.Sprintf(\"select max(version_id) from %s\", gooseTable),\n\t).Scan(&gotVersion); err != nil {\n\t\treturn 0, err\n\t}\n\treturn gotVersion, nil\n}\n\nfunc getTableNames(db *sql.DB) ([]string, error) {\n\trows, err := db.Query(`SELECT name FROM sqlite_master WHERE type='table' ORDER BY name`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar tables []string\n\tfor rows.Next() {\n\t\tvar name string\n\t\tif err := rows.Scan(&name); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttables = append(tables, name)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn tables, nil\n}\n\nfunc assertStatus(\n\tt *testing.T,\n\tgot *goose.MigrationStatus,\n\tstate goose.State,\n\tsource *goose.Source,\n\tappliedIsZero bool,\n) {\n\tt.Helper()\n\trequire.Equal(t, got.State, state)\n\trequire.Equal(t, got.Source, source)\n\trequire.Equal(t, got.AppliedAt.IsZero(), appliedIsZero)\n}\n\nfunc assertResult(\n\tt *testing.T,\n\tgot *goose.MigrationResult,\n\tsource *goose.Source,\n\tdirection string,\n\tisEmpty bool,\n) {\n\tt.Helper()\n\trequire.NotNil(t, got)\n\trequire.Equal(t, got.Source, source)\n\trequire.Equal(t, got.Direction, direction)\n\trequire.Equal(t, got.Empty, isEmpty)\n\trequire.NoError(t, got.Error)\n\trequire.Positive(t, got.Duration)\n}\n\nfunc assertSource(t *testing.T, got *goose.Source, typ goose.MigrationType, name string, version int64) {\n\tt.Helper()\n\trequire.Equal(t, got.Type, typ)\n\trequire.Equal(t, got.Path, name)\n\trequire.Equal(t, got.Version, version)\n}\n\nfunc newSource(t goose.MigrationType, fullpath string, version int64) *goose.Source {\n\treturn &goose.Source{\n\t\tType:    t,\n\t\tPath:    fullpath,\n\t\tVersion: version,\n\t}\n}\n\nfunc newMapFile(data string) *fstest.MapFile {\n\treturn &fstest.MapFile{\n\t\tData: []byte(data),\n\t}\n}\n\nfunc newFsys() fstest.MapFS {\n\treturn fstest.MapFS{\n\t\t\"00001_users_table.sql\":    newMapFile(runMigration1),\n\t\t\"00002_posts_table.sql\":    newMapFile(runMigration2),\n\t\t\"00003_comments_table.sql\": newMapFile(runMigration3),\n\t\t\"00004_insert_data.sql\":    newMapFile(runMigration4),\n\t\t\"00005_posts_view.sql\":     newMapFile(runMigration5),\n\t\t\"00006_empty_up.sql\":       newMapFile(runMigration6),\n\t\t\"00007_empty_up_down.sql\":  newMapFile(runMigration7),\n\t}\n}\n\nvar (\n\n\t// known tables are the tables (including goose table) created by running all migration files.\n\t// If you add a table, make sure to add to this list and keep it in order.\n\tknownTables = []string{\n\t\t\"comments\",\n\t\t\"goose_db_version\",\n\t\t\"posts\",\n\t\t\"sqlite_sequence\",\n\t\t\"users\",\n\t}\n\n\trunMigration1 = `\n-- +goose Up\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY,\n    username TEXT NOT NULL,\n    email TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- +goose Down\nDROP TABLE users;\n`\n\n\trunMigration2 = `\n-- +goose Up\n-- +goose StatementBegin\nCREATE TABLE posts (\n    id INTEGER PRIMARY KEY,\n    title TEXT NOT NULL,\n    content TEXT NOT NULL,\n    author_id INTEGER NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (author_id) REFERENCES users(id)\n);\n-- +goose StatementEnd\nSELECT 1;\nSELECT 2;\n\n-- +goose Down\nDROP TABLE posts;\n`\n\n\trunMigration3 = `\n-- +goose Up\nCREATE TABLE comments (\n    id INTEGER PRIMARY KEY,\n    post_id INTEGER NOT NULL,\n    user_id INTEGER NOT NULL,\n    content TEXT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (post_id) REFERENCES posts(id),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- +goose Down\nDROP TABLE comments;\nSELECT 1;\nSELECT 2;\nSELECT 3;\n`\n\n\trunMigration4 = `\n-- +goose Up\nINSERT INTO users (id, username, email)\nVALUES\n    (1, 'john_doe', 'john@example.com'),\n    (2, 'jane_smith', 'jane@example.com'),\n    (3, 'alice_wonderland', 'alice@example.com');\n\nINSERT INTO posts (id, title, content, author_id)\nVALUES\n    (1, 'Introduction to SQL', 'SQL is a powerful language for managing databases...', 1),\n    (2, 'Data Modeling Techniques', 'Choosing the right data model is crucial...', 2),\n    (3, 'Advanced Query Optimization', 'Optimizing queries can greatly improve...', 1);\n\nINSERT INTO comments (id, post_id, user_id, content)\nVALUES\n    (1, 1, 3, 'Great introduction! Looking forward to more.'),\n    (2, 1, 2, 'SQL can be a bit tricky at first, but practice helps.'),\n    (3, 2, 1, 'You covered normalization really well in this post.');\n\n-- +goose Down\nDELETE FROM comments;\nDELETE FROM posts;\nDELETE FROM users;\n`\n\n\trunMigration5 = `\n-- +goose NO TRANSACTION\n\n-- +goose Up\nCREATE VIEW posts_view AS\n    SELECT\n        p.id,\n        p.title,\n        p.content,\n        p.created_at,\n        u.username AS author\n    FROM posts p\n    JOIN users u ON p.author_id = u.id;\n\n-- +goose Down\nDROP VIEW posts_view;\n`\n\n\trunMigration6 = `\n-- +goose Up\n`\n\n\trunMigration7 = `\n-- +goose Up\n-- +goose Down\n`\n)\n"
        },
        {
          "name": "provider_test.go",
          "type": "blob",
          "size": 1.9228515625,
          "content": "package goose_test\n\nimport (\n\t\"database/sql\"\n\t\"io/fs\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"testing/fstest\"\n\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\t_ \"modernc.org/sqlite\"\n)\n\nfunc TestProvider(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := sql.Open(\"sqlite\", filepath.Join(dir, \"sql_embed.db\"))\n\trequire.NoError(t, err)\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\t_, err := goose.NewProvider(goose.DialectSQLite3, db, fstest.MapFS{})\n\t\trequire.Error(t, err)\n\t\trequire.ErrorIs(t, err, goose.ErrNoMigrations)\n\t})\n\n\tmapFS := fstest.MapFS{\n\t\t\"migrations/001_foo.sql\": {Data: []byte(`-- +goose Up`)},\n\t\t\"migrations/002_bar.sql\": {Data: []byte(`-- +goose Up`)},\n\t}\n\tfsys, err := fs.Sub(mapFS, \"migrations\")\n\trequire.NoError(t, err)\n\tp, err := goose.NewProvider(goose.DialectSQLite3, db, fsys)\n\trequire.NoError(t, err)\n\tsources := p.ListSources()\n\trequire.Len(t, sources, 2)\n\trequire.Equal(t, sources[0], newSource(goose.TypeSQL, \"001_foo.sql\", 1))\n\trequire.Equal(t, sources[1], newSource(goose.TypeSQL, \"002_bar.sql\", 2))\n}\n\nvar (\n\tmigration1 = `\n-- +goose Up\nCREATE TABLE foo (id INTEGER PRIMARY KEY);\n-- +goose Down\nDROP TABLE foo;\n`\n\tmigration2 = `\n-- +goose Up\nALTER TABLE foo ADD COLUMN name TEXT;\n-- +goose Down\nALTER TABLE foo DROP COLUMN name;\n`\n\tmigration3 = `\n-- +goose Up\nCREATE TABLE bar (\n    id INTEGER PRIMARY KEY,\n    description TEXT\n);\n-- +goose Down\nDROP TABLE bar;\n`\n\tmigration4 = `\n-- +goose Up\n-- Rename the 'foo' table to 'my_foo'\nALTER TABLE foo RENAME TO my_foo;\n\n-- Add a new column 'timestamp' to 'my_foo'\nALTER TABLE my_foo ADD COLUMN timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\n\n-- +goose Down\n-- Remove the 'timestamp' column from 'my_foo'\nALTER TABLE my_foo DROP COLUMN timestamp;\n\n-- Rename the 'my_foo' table back to 'foo'\nALTER TABLE my_foo RENAME TO foo;\n`\n)\n\nfunc TestPartialErrorUnwrap(t *testing.T) {\n\terr := &goose.PartialError{Err: goose.ErrNoCurrentVersion}\n\trequire.ErrorIs(t, err, goose.ErrNoCurrentVersion)\n}\n"
        },
        {
          "name": "provider_types.go",
          "type": "blob",
          "size": 2.275390625,
          "content": "package goose\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// MigrationType is the type of migration.\ntype MigrationType string\n\nconst (\n\tTypeGo  MigrationType = \"go\"\n\tTypeSQL MigrationType = \"sql\"\n)\n\n// Source represents a single migration source.\n//\n// The Path field may be empty if the migration was registered manually. This is typically the case\n// for Go migrations registered using the [WithGoMigration] option.\ntype Source struct {\n\tType    MigrationType\n\tPath    string\n\tVersion int64\n}\n\n// MigrationResult is the result of a single migration operation.\ntype MigrationResult struct {\n\tSource    *Source\n\tDuration  time.Duration\n\tDirection string\n\t// Empty indicates no action was taken during the migration, but it was still versioned. For\n\t// SQL, it means no statements; for Go, it's a nil function.\n\tEmpty bool\n\t// Error is only set if the migration failed.\n\tError error\n}\n\n// String returns a string representation of the migration result.\n//\n// Example down:\n//\n//\tEMPTY down 00006_posts_view-copy.sql (607.83µs)\n//\tOK    down 00005_posts_view.sql (646.25µs)\n//\n// Example up:\n//\n//\tOK    up 00005_posts_view.sql (727.5µs)\n//\tEMPTY up 00006_posts_view-copy.sql (378.33µs)\nfunc (m *MigrationResult) String() string {\n\tvar format string\n\tif m.Direction == \"up\" {\n\t\tformat = \"%-5s %-2s %s (%s)\"\n\t} else {\n\t\tformat = \"%-5s %-4s %s (%s)\"\n\t}\n\tvar state string\n\tif m.Empty {\n\t\tstate = \"EMPTY\"\n\t} else {\n\t\tstate = \"OK\"\n\t}\n\treturn fmt.Sprintf(format,\n\t\tstate,\n\t\tm.Direction,\n\t\tfilepath.Base(m.Source.Path),\n\t\ttruncateDuration(m.Duration),\n\t)\n}\n\n// State represents the state of a migration.\ntype State string\n\nconst (\n\t// StatePending is a migration that exists on the filesystem, but not in the database.\n\tStatePending State = \"pending\"\n\t// StateApplied is a migration that has been applied to the database and exists on the\n\t// filesystem.\n\tStateApplied State = \"applied\"\n\n\t// TODO(mf): we could also add a third state for untracked migrations. This would be useful for\n\t// migrations that were manually applied to the database, but not versioned. Or the Source was\n\t// deleted, but the migration still exists in the database. StateUntracked State = \"untracked\"\n)\n\n// MigrationStatus represents the status of a single migration.\ntype MigrationStatus struct {\n\tSource    *Source\n\tState     State\n\tAppliedAt time.Time\n}\n"
        },
        {
          "name": "redo.go",
          "type": "blob",
          "size": 1.1240234375,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n)\n\n// Redo rolls back the most recently applied migration, then runs it again.\nfunc Redo(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn RedoContext(ctx, db, dir, opts...)\n}\n\n// RedoContext rolls back the most recently applied migration, then runs it again.\nfunc RedoContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\tcurrentVersion int64\n\t)\n\tif option.noVersioning {\n\t\tif len(migrations) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tcurrentVersion = migrations[len(migrations)-1].Version\n\t} else {\n\t\tif currentVersion, err = GetDBVersionContext(ctx, db); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcurrent, err := migrations.Current(currentVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcurrent.noVersioning = option.noVersioning\n\n\tif err := current.DownContext(ctx, db); err != nil {\n\t\treturn err\n\t}\n\tif err := current.UpContext(ctx, db); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "register.go",
          "type": "blob",
          "size": 4.0830078125,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"runtime\"\n)\n\n// GoMigrationContext is a Go migration func that is run within a transaction and receives a\n// context.\ntype GoMigrationContext func(ctx context.Context, tx *sql.Tx) error\n\n// AddMigrationContext adds Go migrations.\nfunc AddMigrationContext(up, down GoMigrationContext) {\n\t_, filename, _, _ := runtime.Caller(1)\n\tAddNamedMigrationContext(filename, up, down)\n}\n\n// AddNamedMigrationContext adds named Go migrations.\nfunc AddNamedMigrationContext(filename string, up, down GoMigrationContext) {\n\tif err := register(\n\t\tfilename,\n\t\ttrue,\n\t\t&GoFunc{RunTx: up, Mode: TransactionEnabled},\n\t\t&GoFunc{RunTx: down, Mode: TransactionEnabled},\n\t); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// GoMigrationNoTxContext is a Go migration func that is run outside a transaction and receives a\n// context.\ntype GoMigrationNoTxContext func(ctx context.Context, db *sql.DB) error\n\n// AddMigrationNoTxContext adds Go migrations that will be run outside transaction.\nfunc AddMigrationNoTxContext(up, down GoMigrationNoTxContext) {\n\t_, filename, _, _ := runtime.Caller(1)\n\tAddNamedMigrationNoTxContext(filename, up, down)\n}\n\n// AddNamedMigrationNoTxContext adds named Go migrations that will be run outside transaction.\nfunc AddNamedMigrationNoTxContext(filename string, up, down GoMigrationNoTxContext) {\n\tif err := register(\n\t\tfilename,\n\t\tfalse,\n\t\t&GoFunc{RunDB: up, Mode: TransactionDisabled},\n\t\t&GoFunc{RunDB: down, Mode: TransactionDisabled},\n\t); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc register(filename string, useTx bool, up, down *GoFunc) error {\n\tv, _ := NumericComponent(filename)\n\tif existing, ok := registeredGoMigrations[v]; ok {\n\t\treturn fmt.Errorf(\"failed to add migration %q: version %d conflicts with %q\",\n\t\t\tfilename,\n\t\t\tv,\n\t\t\texisting.Source,\n\t\t)\n\t}\n\t// Add to global as a registered migration.\n\tm := NewGoMigration(v, up, down)\n\tm.Source = filename\n\t// We explicitly set transaction to maintain existing behavior. Both up and down may be nil, but\n\t// we know based on the register function what the user is requesting.\n\tm.UseTx = useTx\n\tregisteredGoMigrations[v] = m\n\treturn nil\n}\n\n// withContext changes the signature of a function that receives one argument to receive a context\n// and the argument.\nfunc withContext[T any](fn func(T) error) func(context.Context, T) error {\n\tif fn == nil {\n\t\treturn nil\n\t}\n\treturn func(ctx context.Context, t T) error {\n\t\treturn fn(t)\n\t}\n}\n\n// withoutContext changes the signature of a function that receives a context and one argument to\n// receive only the argument. When called the passed context is always context.Background().\nfunc withoutContext[T any](fn func(context.Context, T) error) func(T) error {\n\tif fn == nil {\n\t\treturn nil\n\t}\n\treturn func(t T) error {\n\t\treturn fn(context.Background(), t)\n\t}\n}\n\n// GoMigration is a Go migration func that is run within a transaction.\n//\n// Deprecated: Use GoMigrationContext.\ntype GoMigration func(tx *sql.Tx) error\n\n// GoMigrationNoTx is a Go migration func that is run outside a transaction.\n//\n// Deprecated: Use GoMigrationNoTxContext.\ntype GoMigrationNoTx func(db *sql.DB) error\n\n// AddMigration adds Go migrations.\n//\n// Deprecated: Use AddMigrationContext.\nfunc AddMigration(up, down GoMigration) {\n\t_, filename, _, _ := runtime.Caller(1)\n\tAddNamedMigrationContext(filename, withContext(up), withContext(down))\n}\n\n// AddNamedMigration adds named Go migrations.\n//\n// Deprecated: Use AddNamedMigrationContext.\nfunc AddNamedMigration(filename string, up, down GoMigration) {\n\tAddNamedMigrationContext(filename, withContext(up), withContext(down))\n}\n\n// AddMigrationNoTx adds Go migrations that will be run outside transaction.\n//\n// Deprecated: Use AddMigrationNoTxContext.\nfunc AddMigrationNoTx(up, down GoMigrationNoTx) {\n\t_, filename, _, _ := runtime.Caller(1)\n\tAddNamedMigrationNoTxContext(filename, withContext(up), withContext(down))\n}\n\n// AddNamedMigrationNoTx adds named Go migrations that will be run outside transaction.\n//\n// Deprecated: Use AddNamedMigrationNoTxContext.\nfunc AddNamedMigrationNoTx(filename string, up, down GoMigrationNoTx) {\n\tAddNamedMigrationNoTxContext(filename, withContext(up), withContext(down))\n}\n"
        },
        {
          "name": "reset.go",
          "type": "blob",
          "size": 1.51171875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"sort\"\n)\n\n// Reset rolls back all migrations\nfunc Reset(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn ResetContext(ctx, db, dir, opts...)\n}\n\n// ResetContext rolls back all migrations\nfunc ResetContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to collect migrations: %w\", err)\n\t}\n\tif option.noVersioning {\n\t\treturn DownToContext(ctx, db, dir, minVersion, opts...)\n\t}\n\n\tstatuses, err := dbMigrationsStatus(ctx, db)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get status of migrations: %w\", err)\n\t}\n\tsort.Sort(sort.Reverse(migrations))\n\n\tfor _, migration := range migrations {\n\t\tif !statuses[migration.Version] {\n\t\t\tcontinue\n\t\t}\n\t\tif err = migration.DownContext(ctx, db); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to db-down: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc dbMigrationsStatus(ctx context.Context, db *sql.DB) (map[int64]bool, error) {\n\tdbMigrations, err := store.ListMigrations(ctx, db, TableName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// The most recent record for each migration specifies\n\t// whether it has been applied or rolled back.\n\tresults := make(map[int64]bool)\n\n\tfor _, m := range dbMigrations {\n\t\tif _, ok := results[m.VersionID]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tresults[m.VersionID] = m.IsApplied\n\t}\n\treturn results, nil\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "status.go",
          "type": "blob",
          "size": 1.888671875,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// Status prints the status of all migrations.\nfunc Status(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn StatusContext(ctx, db, dir, opts...)\n}\n\n// StatusContext prints the status of all migrations.\nfunc StatusContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to collect migrations: %w\", err)\n\t}\n\tif option.noVersioning {\n\t\tlog.Printf(\"    Applied At                  Migration\\n\")\n\t\tlog.Printf(\"    =======================================\\n\")\n\t\tfor _, current := range migrations {\n\t\t\tlog.Printf(\"    %-24s -- %v\\n\", \"no versioning\", filepath.Base(current.Source))\n\t\t}\n\t\treturn nil\n\t}\n\n\t// must ensure that the version table exists if we're running on a pristine DB\n\tif _, err := EnsureDBVersionContext(ctx, db); err != nil {\n\t\treturn fmt.Errorf(\"failed to ensure DB version: %w\", err)\n\t}\n\n\tlog.Printf(\"    Applied At                  Migration\\n\")\n\tlog.Printf(\"    =======================================\\n\")\n\tfor _, migration := range migrations {\n\t\tif err := printMigrationStatus(ctx, db, migration.Version, filepath.Base(migration.Source)); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to print status: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc printMigrationStatus(ctx context.Context, db *sql.DB, version int64, script string) error {\n\tm, err := store.GetMigration(ctx, db, TableName(), version)\n\tif err != nil && !errors.Is(err, sql.ErrNoRows) {\n\t\treturn fmt.Errorf(\"failed to query the latest migration: %w\", err)\n\t}\n\tappliedAt := \"Pending\"\n\tif m != nil && m.IsApplied {\n\t\tappliedAt = m.Timestamp.Format(time.ANSIC)\n\t}\n\tlog.Printf(\"    %-24s -- %v\\n\", appliedAt, script)\n\treturn nil\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "up.go",
          "type": "blob",
          "size": 6.39453125,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype options struct {\n\tallowMissing bool\n\tapplyUpByOne bool\n\tnoVersioning bool\n}\n\ntype OptionsFunc func(o *options)\n\nfunc WithAllowMissing() OptionsFunc {\n\treturn func(o *options) { o.allowMissing = true }\n}\n\nfunc WithNoVersioning() OptionsFunc {\n\treturn func(o *options) { o.noVersioning = true }\n}\n\nfunc WithNoColor(b bool) OptionsFunc {\n\treturn func(o *options) { noColor = b }\n}\n\nfunc withApplyUpByOne() OptionsFunc {\n\treturn func(o *options) { o.applyUpByOne = true }\n}\n\n// UpTo migrates up to a specific version.\nfunc UpTo(db *sql.DB, dir string, version int64, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn UpToContext(ctx, db, dir, version, opts...)\n}\n\nfunc UpToContext(ctx context.Context, db *sql.DB, dir string, version int64, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tfoundMigrations, err := CollectMigrations(dir, minVersion, version)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif option.noVersioning {\n\t\tif len(foundMigrations) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tif option.applyUpByOne {\n\t\t\t// For up-by-one this means keep re-applying the first\n\t\t\t// migration over and over.\n\t\t\tversion = foundMigrations[0].Version\n\t\t}\n\t\treturn upToNoVersioning(ctx, db, foundMigrations, version)\n\t}\n\n\tif _, err := EnsureDBVersionContext(ctx, db); err != nil {\n\t\treturn err\n\t}\n\tdbMigrations, err := listAllDBVersions(ctx, db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdbMaxVersion := dbMigrations[len(dbMigrations)-1].Version\n\t// lookupAppliedInDB is a map of all applied migrations in the database.\n\tlookupAppliedInDB := make(map[int64]bool)\n\tfor _, m := range dbMigrations {\n\t\tlookupAppliedInDB[m.Version] = true\n\t}\n\n\tmissingMigrations := findMissingMigrations(dbMigrations, foundMigrations, dbMaxVersion)\n\n\t// feature(mf): It is very possible someone may want to apply ONLY new migrations\n\t// and skip missing migrations altogether. At the moment this is not supported,\n\t// but leaving this comment because that's where that logic will be handled.\n\tif len(missingMigrations) > 0 && !option.allowMissing {\n\t\tvar collected []string\n\t\tfor _, m := range missingMigrations {\n\t\t\toutput := fmt.Sprintf(\"version %d: %s\", m.Version, m.Source)\n\t\t\tcollected = append(collected, output)\n\t\t}\n\t\treturn fmt.Errorf(\"error: found %d missing migrations before current version %d:\\n\\t%s\",\n\t\t\tlen(missingMigrations), dbMaxVersion, strings.Join(collected, \"\\n\\t\"))\n\t}\n\tvar migrationsToApply Migrations\n\tif option.allowMissing {\n\t\tmigrationsToApply = missingMigrations\n\t}\n\t// filter all migrations with a version greater than the supplied version (min) and less than or\n\t// equal to the requested version (max). Note, we do not need to filter out missing migrations\n\t// because we are only appending \"new\" migrations that have a higher version than the current\n\t// database max version, which inevitably means they are not \"missing\".\n\tfor _, m := range foundMigrations {\n\t\tif lookupAppliedInDB[m.Version] {\n\t\t\tcontinue\n\t\t}\n\t\tif m.Version > dbMaxVersion && m.Version <= version {\n\t\t\tmigrationsToApply = append(migrationsToApply, m)\n\t\t}\n\t}\n\n\tvar current int64\n\tfor _, m := range migrationsToApply {\n\t\tif err := m.UpContext(ctx, db); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif option.applyUpByOne {\n\t\t\treturn nil\n\t\t}\n\t\tcurrent = m.Version\n\t}\n\n\tif len(migrationsToApply) == 0 {\n\t\tcurrent, err = GetDBVersionContext(ctx, db)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog.Printf(\"goose: no migrations to run. current version: %d\\n\", current)\n\t} else {\n\t\tlog.Printf(\"goose: successfully migrated database to version: %d\\n\", current)\n\t}\n\n\t// At this point there are no more migrations to apply. But we need to maintain\n\t// the following behaviour:\n\t// UpByOne returns an error to signifying there are no more migrations.\n\t// Up and UpTo return nil\n\n\tif option.applyUpByOne {\n\t\treturn ErrNoNextVersion\n\t}\n\n\treturn nil\n}\n\n// upToNoVersioning applies up migrations up to, and including, the\n// target version.\nfunc upToNoVersioning(ctx context.Context, db *sql.DB, migrations Migrations, version int64) error {\n\tvar finalVersion int64\n\tfor _, current := range migrations {\n\t\tif current.Version > version {\n\t\t\tbreak\n\t\t}\n\t\tcurrent.noVersioning = true\n\t\tif err := current.UpContext(ctx, db); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinalVersion = current.Version\n\t}\n\tlog.Printf(\"goose: up to current file version: %d\\n\", finalVersion)\n\treturn nil\n}\n\n// Up applies all available migrations.\nfunc Up(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn UpContext(ctx, db, dir, opts...)\n}\n\n// UpContext applies all available migrations.\nfunc UpContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\treturn UpToContext(ctx, db, dir, maxVersion, opts...)\n}\n\n// UpByOne migrates up by a single version.\nfunc UpByOne(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn UpByOneContext(ctx, db, dir, opts...)\n}\n\n// UpByOneContext migrates up by a single version.\nfunc UpByOneContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\topts = append(opts, withApplyUpByOne())\n\treturn UpToContext(ctx, db, dir, maxVersion, opts...)\n}\n\n// listAllDBVersions returns a list of all migrations, ordered ascending.\nfunc listAllDBVersions(ctx context.Context, db *sql.DB) (Migrations, error) {\n\tdbMigrations, err := store.ListMigrations(ctx, db, TableName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tall := make(Migrations, 0, len(dbMigrations))\n\tfor _, m := range dbMigrations {\n\t\tall = append(all, &Migration{\n\t\t\tVersion: m.VersionID,\n\t\t})\n\t}\n\t// ListMigrations returns migrations in descending order by id.\n\t// But we want to return them in ascending order by version_id, so we re-sort.\n\tsort.SliceStable(all, func(i, j int) bool {\n\t\treturn all[i].Version < all[j].Version\n\t})\n\treturn all, nil\n}\n\n// findMissingMigrations migrations returns all missing migrations.\n// A migrations is considered missing if it has a version less than the\n// current known max version.\nfunc findMissingMigrations(knownMigrations, newMigrations Migrations, dbMaxVersion int64) Migrations {\n\texisting := make(map[int64]bool)\n\tfor _, known := range knownMigrations {\n\t\texisting[known.Version] = true\n\t}\n\tvar missing Migrations\n\tfor _, new := range newMigrations {\n\t\tif !existing[new.Version] && new.Version < dbMaxVersion {\n\t\t\tmissing = append(missing, new)\n\t\t}\n\t}\n\tsort.SliceStable(missing, func(i, j int) bool {\n\t\treturn missing[i].Version < missing[j].Version\n\t})\n\treturn missing\n}\n"
        },
        {
          "name": "up_test.go",
          "type": "blob",
          "size": 0.7890625,
          "content": "package goose\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFindMissingMigrations(t *testing.T) {\n\tknown := Migrations{\n\t\t{Version: 1},\n\t\t{Version: 3},\n\t\t{Version: 4},\n\t\t{Version: 5},\n\t\t{Version: 7}, // <-- database max version_id\n\t}\n\tnew := Migrations{\n\t\t{Version: 1},\n\t\t{Version: 2}, // missing migration\n\t\t{Version: 3},\n\t\t{Version: 4},\n\t\t{Version: 5},\n\t\t{Version: 6}, // missing migration\n\t\t{Version: 7}, // <-- database max version_id\n\t\t{Version: 8}, // new migration\n\t}\n\tgot := findMissingMigrations(known, new, 7)\n\tif len(got) != 2 {\n\t\tt.Fatalf(\"invalid migration count: got:%d want:%d\", len(got), 2)\n\t}\n\tif got[0].Version != 2 {\n\t\tt.Errorf(\"expecting first migration: got:%d want:%d\", got[0].Version, 2)\n\t}\n\tif got[1].Version != 6 {\n\t\tt.Errorf(\"expecting second migration: got:%d want:%d\", got[0].Version, 6)\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.1630859375,
          "content": "package goose\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Version prints the current version of the database.\nfunc Version(db *sql.DB, dir string, opts ...OptionsFunc) error {\n\tctx := context.Background()\n\treturn VersionContext(ctx, db, dir, opts...)\n}\n\n// VersionContext prints the current version of the database.\nfunc VersionContext(ctx context.Context, db *sql.DB, dir string, opts ...OptionsFunc) error {\n\toption := &options{}\n\tfor _, f := range opts {\n\t\tf(option)\n\t}\n\tif option.noVersioning {\n\t\tvar current int64\n\t\tmigrations, err := CollectMigrations(dir, minVersion, maxVersion)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to collect migrations: %w\", err)\n\t\t}\n\t\tif len(migrations) > 0 {\n\t\t\tcurrent = migrations[len(migrations)-1].Version\n\t\t}\n\t\tlog.Printf(\"goose: file version %v\\n\", current)\n\t\treturn nil\n\t}\n\n\tcurrent, err := GetDBVersionContext(ctx, db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Printf(\"goose: version %v\\n\", current)\n\treturn nil\n}\n\nvar tableName = \"goose_db_version\"\n\n// TableName returns goose db version table name\nfunc TableName() string {\n\treturn tableName\n}\n\n// SetTableName set goose db version table name\nfunc SetTableName(n string) {\n\ttableName = n\n}\n"
        }
      ]
    }
  ]
}