{
  "metadata": {
    "timestamp": 1736567754893,
    "page": 339,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shazow/ssh-chat",
      "stars": 5630,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0537109375,
          "content": "/build\nhost_key\nhost_key.pub\nssh-chat\n*.log\n.*\nvendor/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2421875,
          "content": "notifications:\n  email: false\n\nlanguage: go\n\ngo:\n  - 1.x\n\nenv:\n  - CGO_ENABLED=0 GO111MODULE=on\n\ninstall:\n  - go get github.com/gordonklaus/ineffassign\n\nscript:\n  - diff -u <(echo -n) <(gofmt -d .)\n  - ineffassign .\n  - go test -vet \"all\" -v ./...\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.3896484375,
          "content": "# Code of Conduct\n\nThis code of conduct applies to both: The `ssh.chat` code participants and the `ssh-chat` code contributors.\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces (such as inside the chat) and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at andrey.petrov@shazow.net. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.2880859375,
          "content": "# How to Contribute\n\nThis is a brief guide on how you can contribute to `ssh-chat`\n\n## Getting Started\n\nContributions come in the form of bug reports, feature requests, documentation and wiki edits, and pull requests. If you have an issue with a certain feature or encountered a bug, you will refer to the Issues section.\n\n### Submitting an Issue\n\n`ssh-chat` has a lot of issues, and we try to help every one of them as best we can. The best way to submit an issue is simple: check if it already exists using the search bar. If you encounter a bug or want a certain feature, make sure no one else has submitted it before so we can avoid duplicate issues.\n\nWhen submitting a bug report, make sure you submit very specific details surrounding the bug:\n\n* What did you do to create the bug?\n* Was there any error code given or exceptions thrown?\n* What operating system are you and which version of OpenSSH are you using?\n* If you built from source, what version of Golang did you use to build `ssh-chat`?\n\nThese details should help us to come to a solution.\n\nFor feature requests, use the search bar to look up if a feature you want has already been requested. If there was an issue already create, you can vote on it using the \"thumbs up\" emoji.\n\n### Submitting Code\n\nSubmitting code is another way to contribute. The best way to start contributing code would be to look at all the open Issues and see if you can find an interesting bug to tackle. Or if there's a feature you want to implement, check if an Issue was opened for it, or even submit the feature request yourself to open up a discussion.\n\nWhen submitting code, you should, in your commit message, refer to which issue you are working on. That way when the issue is resolved, or if future bugs are introduced because of it, we can refer to the pull request made and try to fix any bugs.\n\nOnce submitted, the code must meet the following conditions in order to be accepted:\n* Code must be formatted using `gofmt`\n* Code must pass code review\n* Code must pass the Travis CI testing stage\n\nIf the code meets these conditions, then it will be merged into the `master` branch.\n\n\n### Discussion Channels\n\nDevelopment discussion of `ssh-chat` can be found on Shazow's public `ssh-chat` server. Connect using any `ssh` client with the following:\n\n```bash\n$ ssh username@chat.shazow.net\n```\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3369140625,
          "content": "FROM golang:alpine AS builder\n\nWORKDIR /usr/src/app\n\nCOPY . .\nRUN apk add make openssh\nRUN make build\n\n\nFROM alpine\n\nRUN apk add openssh\nRUN mkdir /root/.ssh\nWORKDIR /root/.ssh\nRUN ssh-keygen -t rsa -C \"chatkey\" -f id_rsa\n\nWORKDIR /usr/local/bin\n\nCOPY --from=builder /usr/src/app/ssh-chat .\nRUN chmod +x ssh-chat\nCMD [\"/usr/local/bin/ssh-chat\"]\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 1.2431640625,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/alexcesaro/log\"\n  packages = [\".\",\"golog\"]\n  revision = \"61e686294e58a8698a9e1091268bb4ac1116bd5e\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/howeyc/gopass\"\n  packages = [\".\"]\n  revision = \"bf9dde6d0d2c004a008c27aaee91170c786f6db8\"\n\n[[projects]]\n  name = \"github.com/jessevdk/go-flags\"\n  packages = [\".\"]\n  revision = \"96dc06278ce32a0e9d957d590bb987c81ee66407\"\n  version = \"v1.3.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/shazow/rateio\"\n  packages = [\".\"]\n  revision = \"e8e00881e5c12090412414be41c04ca9c8a71106\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/crypto\"\n  packages = [\"curve25519\",\"ed25519\",\"ed25519/internal/edwards25519\",\"internal/chacha20\",\"poly1305\",\"ssh\",\"ssh/terminal\"]\n  revision = \"ee41a25c63fb5b74abf2213abb6dee3751e6ac4a\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/sys\"\n  packages = [\"unix\",\"windows\"]\n  revision = \"2c42eef0765b9837fbdab12011af7830f55f88f0\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  inputs-digest = \"48a7f7477a28e61efdd4256fe7f426bfaf93df53b5731e905088c0e9c2f10d3b\"\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.94921875,
          "content": "\n# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/alexcesaro/log\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/dustin/go-humanize\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/howeyc/gopass\"\n\n[[constraint]]\n  name = \"github.com/jessevdk/go-flags\"\n  version = \"1.3.0\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/shazow/rateio\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"golang.org/x/crypto\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Andrey Petrov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.0087890625,
          "content": "BINARY = ssh-chat\nKEY = host_key\nPORT = 2022\n\nSRCS = %.go\nVERSION := $(shell git describe --tags --dirty --always 2> /dev/null || echo \"dev\")\nLDFLAGS = -X main.Version=$(VERSION) -extldflags \"-static\"\n\nall: $(BINARY)\n\n$(BINARY): **/**/*.go **/*.go *.go\n\tgo build -ldflags \"$(LDFLAGS)\" ./cmd/ssh-chat\n\nbuild: $(BINARY)\n\nclean:\n\trm $(BINARY)\n\n$(KEY):\n\tssh-keygen -f $(KEY) -P ''\n\nrun: $(BINARY) $(KEY)\n\t./$(BINARY) -i $(KEY) --bind \":$(PORT)\" -vv\n\ndebug: $(BINARY) $(KEY)\n\t./$(BINARY) --pprof 6060 -i $(KEY) --bind \":$(PORT)\" -vv\n\ntest:\n\tgo test -race -test.timeout 5s ./...\n\nrelease:\n\t# We use static linking for release build. LDFLAGS via\n\t# https://github.com/golang/go/issues/26492\n\t# Can replace LDFLAGS with -static once the issue has been resolved.\n\tCGO_ENABLED=0 GOOS=linux GOARCH=amd64 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=linux GOARCH=386 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=6 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=linux GOARCH=arm64 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=darwin GOARCH=arm64 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=freebsd GOARCH=amd64 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\tCGO_ENABLED=0 GOOS=windows GOARCH=386 LDFLAGS='$(LDFLAGS)' ./build_release \"github.com/shazow/ssh-chat/cmd/ssh-chat\" README.md LICENSE\n\ndeploy: build/ssh-chat-linux_amd64.tgz\n\tssh -p 2022 ssh.chat tar xvz < build/ssh-chat-linux_amd64.tgz\n\t@echo \" --- Ready to deploy ---\"\n\t@echo \"Run: ssh -t -p 2022 ssh.chat sudo systemctl restart ssh-chat\"\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 1.6328125,
          "content": "## x/crypto/ssh/terminal\n\nThis project contains a fork of https://github.com/golang/crypto/tree/master/ssh/terminal\nunder the sshd/terminal directory. The project's original license applies:\n\n\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.46484375,
          "content": "[![Build Status](https://travis-ci.org/shazow/ssh-chat.svg?branch=master)](https://travis-ci.org/shazow/ssh-chat)\n[![GoDoc](https://godoc.org/github.com/shazow/ssh-chat?status.svg)](https://godoc.org/github.com/shazow/ssh-chat)\n[![Downloads](https://img.shields.io/github/downloads/shazow/ssh-chat/total.svg?color=orange)](https://github.com/shazow/ssh-chat/releases)\n[![Bountysource](https://www.bountysource.com/badge/team?team_id=52292&style=bounties_received)](https://www.bountysource.com/teams/ssh-chat/issues?utm_source=ssh-chat&utm_medium=shield&utm_campaign=bounties_received)\n\n\n# ssh-chat\n\nCustom SSH server written in Go. Instead of a shell, you get a chat prompt.\n\n## Demo\n\nJoin the party:\n\n``` console\n$ ssh ssh.chat\n```\n\nPlease abide by our [project's Code of Conduct](https://github.com/shazow/ssh-chat/blob/master/CODE_OF_CONDUCT.md) while participating in chat.\n\nThe host's public key is `ssh.chat ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKPrQofxXqoz2y9A7NFkkENt6iW8/mvpfes3RY/41Oyt` and the fingerprint is `SHA256:yoqMXkCysMTBsvhu2yRoMUl+EmZKlvkN+ZKmL3115xU` (as of 2021-10-13).\n\nIf you see something different, you might be [MITM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)'d.\n\n(Apologies if the server is down, try again shortly.)\n\n\n## Downloading a release\n\nRecent releases include builds for MacOS (darwin/amd64) and Linux (386,\namd64, and ARM6 for your RaspberryPi).\n\n**[Grab the latest binary release here](https://github.com/shazow/ssh-chat/releases/)**.\n\nPlay around with it. Additional [deploy examples are here](https://github.com/shazow/ssh-chat/wiki/Deployment).\n\n\n## Compiling / Developing\n\nMost people just want the [latest binary release](https://github.com/shazow/ssh-chat/releases/). If you're sure you want to compile it from source, read on:\n\nYou can compile ssh-chat by using `make build`. The resulting binary is portable and\ncan be run on any system with a similar OS and CPU arch. Go 1.8 or higher is required to compile.\n\nIf you're developing on this repo, there is a handy Makefile that should set\nthings up with `make run`.\n\nAdditionally, `make debug` runs the server with an http `pprof` server. This allows you to open\n[http://localhost:6060/debug/pprof/]() and view profiling data. See\n[net/http/pprof](http://golang.org/pkg/net/http/pprof/) for more information about `pprof`.\n\n\n## Quick Start\n\n``` console\nUsage:\n  ssh-chat [OPTIONS]\n\nApplication Options:\n  -v, --verbose    Show verbose logging.\n      --version    Print version and exit.\n  -i, --identity=  Private key to identify server with. (default: ~/.ssh/id_rsa)\n      --bind=      Host and port to listen on. (default: 0.0.0.0:2022)\n      --admin=     File of public keys who are admins.\n      --whitelist= Optional file of public keys who are allowed to connect.\n      --motd=      Optional Message of the Day file.\n      --log=       Write chat log to this file.\n      --pprof=     Enable pprof http server for profiling.\n\nHelp Options:\n  -h, --help       Show this help message\n```\n\nAfter doing `go get github.com/shazow/ssh-chat/...` on this repo, you should be able\nto run a command like:\n\n``` console\n$ ssh-chat --verbose --bind \":22\" --identity ~/.ssh/id_dsa\n```\n\nTo bind on port 22, you'll need to make sure it's free (move any other ssh\ndaemons to another port) and run ssh-chat as root (or with sudo).\n\n## Frequently Asked Questions\n\nThe FAQs can be found on the project's [Wiki page](https://github.com/shazow/ssh-chat/wiki/FAQ).\nFeel free to submit more questions to be answered and added to the page.\n\n## License\n\nMIT\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 8.9130859375,
          "content": "package sshchat\n\nimport (\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/shazow/ssh-chat/set\"\n\t\"github.com/shazow/ssh-chat/sshd\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// KeyLoader loads public keys, e.g. from an authorized_keys file.\n// It must return a nil slice on error.\ntype KeyLoader func() ([]ssh.PublicKey, error)\n\n// ErrNotAllowed Is the error returned when a key is checked that is not allowlisted,\n// when allowlisting is enabled.\nvar ErrNotAllowed = errors.New(\"not allowed\")\n\n// ErrBanned is the error returned when a client is banned.\nvar ErrBanned = errors.New(\"banned\")\n\n// ErrIncorrectPassphrase is the error returned when a provided passphrase is incorrect.\nvar ErrIncorrectPassphrase = errors.New(\"incorrect passphrase\")\n\n// newAuthKey returns string from an ssh.PublicKey used to index the key in our lookup.\nfunc newAuthKey(key ssh.PublicKey) string {\n\tif key == nil {\n\t\treturn \"\"\n\t}\n\t// FIXME: Is there a better way to index pubkeys without marshal'ing them into strings?\n\treturn sshd.Fingerprint(key)\n}\n\nfunc newAuthItem(key ssh.PublicKey) set.Item {\n\treturn set.StringItem(newAuthKey(key))\n}\n\n// newAuthAddr returns a string from a net.Addr used to index the address the key in our lookup.\nfunc newAuthAddr(addr net.Addr) string {\n\tif addr == nil {\n\t\treturn \"\"\n\t}\n\thost, _, _ := net.SplitHostPort(addr.String())\n\treturn host\n}\n\n// Auth stores lookups for bans, allowlists, and ops. It implements the sshd.Auth interface.\n// If the contained passphrase is not empty, it complements a allowlist.\ntype Auth struct {\n\tpassphraseHash []byte\n\tbannedAddr     *set.Set\n\tbannedClient   *set.Set\n\tbanned         *set.Set\n\tallowlist      *set.Set\n\tops            *set.Set\n\n\tsettingsMu      sync.RWMutex\n\tallowlistMode   bool\n\topLoader        KeyLoader\n\tallowlistLoader KeyLoader\n}\n\n// NewAuth creates a new empty Auth.\nfunc NewAuth() *Auth {\n\treturn &Auth{\n\t\tbannedAddr:   set.New(),\n\t\tbannedClient: set.New(),\n\t\tbanned:       set.New(),\n\t\tallowlist:    set.New(),\n\t\tops:          set.New(),\n\t}\n}\n\nfunc (a *Auth) AllowlistMode() bool {\n\ta.settingsMu.RLock()\n\tdefer a.settingsMu.RUnlock()\n\treturn a.allowlistMode\n}\n\nfunc (a *Auth) SetAllowlistMode(value bool) {\n\ta.settingsMu.Lock()\n\tdefer a.settingsMu.Unlock()\n\ta.allowlistMode = value\n}\n\n// SetPassphrase enables passphrase authentication with the given passphrase.\n// If an empty passphrase is given, disable passphrase authentication.\nfunc (a *Auth) SetPassphrase(passphrase string) {\n\tif passphrase == \"\" {\n\t\ta.passphraseHash = nil\n\t} else {\n\t\thashArray := sha256.Sum256([]byte(passphrase))\n\t\ta.passphraseHash = hashArray[:]\n\t}\n}\n\n// AllowAnonymous determines if anonymous users are permitted.\nfunc (a *Auth) AllowAnonymous() bool {\n\treturn !a.AllowlistMode() && a.passphraseHash == nil\n}\n\n// AcceptPassphrase determines if passphrase authentication is accepted.\nfunc (a *Auth) AcceptPassphrase() bool {\n\treturn a.passphraseHash != nil\n}\n\n// CheckBans checks IP, key and client bans.\nfunc (a *Auth) CheckBans(addr net.Addr, key ssh.PublicKey, clientVersion string) error {\n\tauthkey := newAuthKey(key)\n\n\tvar banned bool\n\tif authkey != \"\" {\n\t\tbanned = a.banned.In(authkey)\n\t}\n\tif !banned {\n\t\tbanned = a.bannedAddr.In(newAuthAddr(addr))\n\t}\n\tif !banned {\n\t\tbanned = a.bannedClient.In(clientVersion)\n\t}\n\t// Ops can bypass bans, just in case we ban ourselves.\n\tif banned && !a.IsOp(key) {\n\t\treturn ErrBanned\n\t}\n\n\treturn nil\n}\n\n// CheckPubkey determines if a pubkey fingerprint is permitted.\nfunc (a *Auth) CheckPublicKey(key ssh.PublicKey) error {\n\tauthkey := newAuthKey(key)\n\tallowlisted := a.allowlist.In(authkey)\n\tif a.AllowAnonymous() || allowlisted || a.IsOp(key) {\n\t\treturn nil\n\t} else {\n\t\treturn ErrNotAllowed\n\t}\n}\n\n// CheckPassphrase determines if a passphrase is permitted.\nfunc (a *Auth) CheckPassphrase(passphrase string) error {\n\tif !a.AcceptPassphrase() {\n\t\treturn errors.New(\"passphrases not accepted\") // this should never happen\n\t}\n\tpassedPassphraseHash := sha256.Sum256([]byte(passphrase))\n\tif subtle.ConstantTimeCompare(passedPassphraseHash[:], a.passphraseHash) == 0 {\n\t\treturn ErrIncorrectPassphrase\n\t}\n\treturn nil\n}\n\n// Op sets a public key as a known operator.\nfunc (a *Auth) Op(key ssh.PublicKey, d time.Duration) {\n\tif key == nil {\n\t\treturn\n\t}\n\tauthItem := newAuthItem(key)\n\tif d != 0 {\n\t\ta.ops.Set(set.Expire(authItem, d))\n\t} else {\n\t\ta.ops.Set(authItem)\n\t}\n\tlogger.Debugf(\"Added to ops: %q (for %s)\", authItem.Key(), d)\n}\n\n// IsOp checks if a public key is an op.\nfunc (a *Auth) IsOp(key ssh.PublicKey) bool {\n\tauthkey := newAuthKey(key)\n\treturn a.ops.In(authkey)\n}\n\n// LoadOps sets the public keys form loader to operators and saves the loader for later use\nfunc (a *Auth) LoadOps(loader KeyLoader) error {\n\ta.settingsMu.Lock()\n\ta.opLoader = loader\n\ta.settingsMu.Unlock()\n\treturn a.ReloadOps()\n}\n\n// ReloadOps sets the public keys from a loader saved in the last call to operators\nfunc (a *Auth) ReloadOps() error {\n\ta.settingsMu.RLock()\n\tdefer a.settingsMu.RUnlock()\n\treturn addFromLoader(a.opLoader, a.Op)\n}\n\n// Allowlist will set a public key as a allowlisted user.\nfunc (a *Auth) Allowlist(key ssh.PublicKey, d time.Duration) {\n\tif key == nil {\n\t\treturn\n\t}\n\tvar err error\n\tauthItem := newAuthItem(key)\n\tif d != 0 {\n\t\terr = a.allowlist.Set(set.Expire(authItem, d))\n\t} else {\n\t\terr = a.allowlist.Set(authItem)\n\t}\n\tif err == nil {\n\t\tlogger.Debugf(\"Added to allowlist: %q (for %s)\", authItem.Key(), d)\n\t} else {\n\t\tlogger.Errorf(\"Error adding %q to allowlist for %s: %s\", authItem.Key(), d, err)\n\t}\n}\n\n// LoadAllowlist adds the public keys from the loader to the allowlist and saves the loader for later use\nfunc (a *Auth) LoadAllowlist(loader KeyLoader) error {\n\ta.settingsMu.Lock()\n\ta.allowlistLoader = loader\n\ta.settingsMu.Unlock()\n\treturn a.ReloadAllowlist()\n}\n\n//  LoadAllowlist adds the public keys from a loader saved in a previous call to the allowlist\nfunc (a *Auth) ReloadAllowlist() error {\n\ta.settingsMu.RLock()\n\tdefer a.settingsMu.RUnlock()\n\treturn addFromLoader(a.allowlistLoader, a.Allowlist)\n}\n\nfunc addFromLoader(loader KeyLoader, adder func(ssh.PublicKey, time.Duration)) error {\n\tif loader == nil {\n\t\treturn nil\n\t}\n\tkeys, err := loader()\n\tfor _, key := range keys {\n\t\tadder(key, 0)\n\t}\n\treturn err\n}\n\n// Ban will set a public key as banned.\nfunc (a *Auth) Ban(key ssh.PublicKey, d time.Duration) {\n\tif key == nil {\n\t\treturn\n\t}\n\ta.BanFingerprint(newAuthKey(key), d)\n}\n\n// BanFingerprint will set a public key fingerprint as banned.\nfunc (a *Auth) BanFingerprint(authkey string, d time.Duration) {\n\t// FIXME: This is a case insensitive key, which isn't great...\n\tauthItem := set.StringItem(authkey)\n\tif d != 0 {\n\t\ta.banned.Set(set.Expire(authItem, d))\n\t} else {\n\t\ta.banned.Set(authItem)\n\t}\n\tlogger.Debugf(\"Added to banned: %q (for %s)\", authItem.Key(), d)\n}\n\n// BanClient will set client version as banned. Useful for misbehaving bots.\nfunc (a *Auth) BanClient(client string, d time.Duration) {\n\titem := set.StringItem(client)\n\tif d != 0 {\n\t\ta.bannedClient.Set(set.Expire(item, d))\n\t} else {\n\t\ta.bannedClient.Set(item)\n\t}\n\tlogger.Debugf(\"Added to banned: %q (for %s)\", item.Key(), d)\n}\n\n// Banned returns the list of banned keys.\nfunc (a *Auth) Banned() (ip []string, fingerprint []string, client []string) {\n\ta.banned.Each(func(key string, _ set.Item) error {\n\t\tfingerprint = append(fingerprint, key)\n\t\treturn nil\n\t})\n\ta.bannedAddr.Each(func(key string, _ set.Item) error {\n\t\tip = append(ip, key)\n\t\treturn nil\n\t})\n\ta.bannedClient.Each(func(key string, _ set.Item) error {\n\t\tclient = append(client, key)\n\t\treturn nil\n\t})\n\treturn\n}\n\n// BanAddr will set an IP address as banned.\nfunc (a *Auth) BanAddr(addr net.Addr, d time.Duration) {\n\tauthItem := set.StringItem(newAuthAddr(addr))\n\tif d != 0 {\n\t\ta.bannedAddr.Set(set.Expire(authItem, d))\n\t} else {\n\t\ta.bannedAddr.Set(authItem)\n\t}\n\tlogger.Debugf(\"Added to bannedAddr: %q (for %s)\", authItem.Key(), d)\n}\n\n// BanQuery takes space-separated key=\"value\" pairs to ban, including ip, fingerprint, client.\n// Fields without an = will be treated as a duration, applied to the next field.\n// For example: 5s client=foo 10min ip=1.1.1.1\n// Will ban client foo for 5 seconds, and ip 1.1.1.1 for 10min.\nfunc (a *Auth) BanQuery(q string) error {\n\tr := csv.NewReader(strings.NewReader(q))\n\tr.Comma = ' '\n\tfields, err := r.Read()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar d time.Duration\n\tif last := fields[len(fields)-1]; !strings.Contains(last, \"=\") {\n\t\td, err = time.ParseDuration(last)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfields = fields[:len(fields)-1]\n\t}\n\tfor _, field := range fields {\n\t\tparts := strings.SplitN(field, \"=\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn fmt.Errorf(\"invalid query: %q\", q)\n\t\t}\n\t\tkey, value := parts[0], parts[1]\n\t\tswitch key {\n\t\tcase \"client\":\n\t\t\ta.BanClient(value, d)\n\t\tcase \"fingerprint\":\n\t\t\t// TODO: Add a validity check?\n\t\t\ta.BanFingerprint(value, d)\n\t\tcase \"ip\":\n\t\t\tip := net.ParseIP(value)\n\t\t\tif ip.String() == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid ip value: %q\", ip)\n\t\t\t}\n\t\t\ta.BanAddr(&net.TCPAddr{IP: ip}, d)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown query field: %q\", field)\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 1.849609375,
          "content": "package sshchat\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc NewRandomPublicKey(bits int) (ssh.PublicKey, error) {\n\tkey, err := rsa.GenerateKey(rand.Reader, bits)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ssh.NewPublicKey(key.Public())\n}\n\nfunc ClonePublicKey(key ssh.PublicKey) (ssh.PublicKey, error) {\n\treturn ssh.ParsePublicKey(key.Marshal())\n}\n\nfunc TestAuthAllowlist(t *testing.T) {\n\tkey, err := NewRandomPublicKey(512)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tauth := NewAuth()\n\terr = auth.CheckPublicKey(key)\n\tif err != nil {\n\t\tt.Error(\"Failed to permit in default state:\", err)\n\t}\n\n\tauth.Allowlist(key, 0)\n\tauth.SetAllowlistMode(true)\n\n\tkeyClone, err := ClonePublicKey(key)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif string(keyClone.Marshal()) != string(key.Marshal()) {\n\t\tt.Error(\"Clone key does not match.\")\n\t}\n\n\terr = auth.CheckPublicKey(keyClone)\n\tif err != nil {\n\t\tt.Error(\"Failed to permit allowlisted:\", err)\n\t}\n\n\tkey2, err := NewRandomPublicKey(512)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = auth.CheckPublicKey(key2)\n\tif err == nil {\n\t\tt.Error(\"Failed to restrict not allowlisted:\", err)\n\t}\n}\n\nfunc TestAuthPassphrases(t *testing.T) {\n\tauth := NewAuth()\n\n\tif auth.AcceptPassphrase() {\n\t\tt.Error(\"Doesn't known it won't accept passphrases.\")\n\t}\n\tauth.SetPassphrase(\"\")\n\tif auth.AcceptPassphrase() {\n\t\tt.Error(\"Doesn't known it won't accept passphrases.\")\n\t}\n\n\terr := auth.CheckPassphrase(\"Pa$$w0rd\")\n\tif err == nil {\n\t\tt.Error(\"Failed to deny without passphrase:\", err)\n\t}\n\n\tauth.SetPassphrase(\"Pa$$w0rd\")\n\n\terr = auth.CheckPassphrase(\"Pa$$w0rd\")\n\tif err != nil {\n\t\tt.Error(\"Failed to allow vaild passphrase:\", err)\n\t}\n\n\terr = auth.CheckPassphrase(\"something else\")\n\tif err == nil {\n\t\tt.Error(\"Failed to restrict wrong passphrase:\", err)\n\t}\n\n\tauth.SetPassphrase(\"\")\n\tif auth.AcceptPassphrase() {\n\t\tt.Error(\"Didn't clear passphrase.\")\n\t}\n}\n"
        },
        {
          "name": "build_release",
          "type": "blob",
          "size": 1.314453125,
          "content": "#!/usr/bin/env bash\n\nusage() {\n    echo \"Build and bundle Go releases with the current dir as the build dir.\"\n    echo \"Usage: $0 PACKAGE [ASSETS...]\"\n}\n\nmain() {\n    set -eo pipefail\n    [[ \"$TRACE\" ]] && set -x\n\n    if [[ ! \"$1\" ]]; then\n        usage\n        exit 1\n    fi\n\n    if [[ ! \"$GOOS\" ]]; then\n        export GOOS=\"linux\"\n        echo \"Defaulting to GOOS=$GOOS\"\n    fi\n    if [[ ! \"$GOARCH\" ]]; then\n        export GOARCH=\"amd64\"\n        echo \"Defaulting to GOARCH=$GOARCH\"\n    fi\n    if [[ ! \"$BUILDDIR\" ]]; then\n        export BUILDDIR=\"build\"\n        echo \"Defaulting to BUILDDIR=$BUILDDIR\"\n    fi\n\n    build \"$@\"\n}\n\nbuild() {\n    local package=\"$1\"; shift\n    local assets=\"$@\"\n\n    local bin=\"$(basename $package)\"\n    local tarball=\"${bin}-${GOOS}_${GOARCH}.tgz\"\n    local outdir=\"$BUILDDIR/$bin\"\n    local tardir=\"$bin\"\n    if [ \"$GOOS\" == \"windows\" ]; then\n        bin=\"$bin.exe\"\n    fi\n\n\n    if [[ -d \"$outdir\" ]]; then\n        echo \"err: outdir already exists: $PWD/$outdir\"\n    fi\n    mkdir -p \"$outdir\"\n\n    go build -ldflags \"$LDFLAGS\" -o \"$outdir/$bin\" \"$package\"\n\n    # Stage asset bundle\n    if [[ \"$assets\" ]]; then\n        ln -f $assets \"$outdir\"\n    fi\n\n    # Create tarball\n    tar -C \"$BUILDDIR\" -czvf \"$BUILDDIR/$tarball\" \"$tardir\"\n\n    # Cleanup\n    rm -rf \"$outdir\"\n\n    echo \"Packaged: $tarball\"\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "chat",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.2333984375,
          "content": "version: '3.2'\nservices:\n  app:\n    container_name: ssh-chat\n    build: .\n    ports:\n      - 2022:2022\n    restart: unless-stopped\n    volumes:\n      - type: bind\n        source: ~/.ssh/\n        target: /root/.ssh/\n        read_only: true\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3427734375,
          "content": "module github.com/shazow/ssh-chat\n\nrequire (\n\tgithub.com/alexcesaro/log v0.0.0-20150915221235-61e686294e58\n\tgithub.com/jessevdk/go-flags v1.5.0\n\tgithub.com/shazow/rateio v0.0.0-20200113175441-4461efc8bdc4\n\tgolang.org/x/crypto v0.17.0\n\tgolang.org/x/sync v0.1.0\n\tgolang.org/x/sys v0.15.0\n\tgolang.org/x/term v0.15.0\n\tgolang.org/x/text v0.14.0\n)\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.552734375,
          "content": "github.com/alexcesaro/log v0.0.0-20150915221235-61e686294e58 h1:MkpmYfld/S8kXqTYI68DfL8/hHXjHogL120Dy00TIxc=\ngithub.com/alexcesaro/log v0.0.0-20150915221235-61e686294e58/go.mod h1:YNfsMyWSs+h+PaYkxGeMVmVCX75Zj/pqdjbu12ciCYE=\ngithub.com/jessevdk/go-flags v1.5.0 h1:1jKYvbxEjfUl0fmqTCOfonvskHHXMjBySTLW4y9LFvc=\ngithub.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=\ngithub.com/shazow/rateio v0.0.0-20200113175441-4461efc8bdc4 h1:zwQ1HBo5FYwn1ksMd19qBCKO8JAWE9wmHivEpkw/DvE=\ngithub.com/shazow/rateio v0.0.0-20200113175441-4461efc8bdc4/go.mod h1:vt2jWY/3Qw1bIzle5thrJWucsLuuX9iUNnp20CqCciI=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.17.0 h1:r8bRNjWL3GshPW3gkd+RpvzWrZAwPS49OmTGZ/uhM4k=\ngolang.org/x/crypto v0.17.0/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0 h1:wsuoTGHzEhffawBOhz5CYhcrV4IdKZbEyZjBMuTp12o=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.15.0 h1:h48lPFYpsTvQJZF4EKyI4aLHaev3CxivZmv7yZig9pc=\ngolang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.15.0 h1:y/Oo/a/q3IXu26lQgl04j/gjuBDOBlx7X6Om1j2CPW4=\ngolang.org/x/term v0.15.0/go.mod h1:BDl952bC7+uMoWR75FIrCDx79TPU9oHkTZ9yRbYOrX0=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "godoc.go",
          "type": "blob",
          "size": 0.337890625,
          "content": "/*\nPackage sshchat is an implementation of an ssh server which serves a chat room\ninstead of a shell.\n\nsshd subdirectory contains the ssh-related pieces which know nothing about chat.\n\nchat subdirectory contains the chat-related pieces which know nothing about ssh.\n\nThe Host type is the glue between the sshd and chat pieces.\n*/\npackage sshchat\n"
        },
        {
          "name": "host.go",
          "type": "blob",
          "size": 21.94921875,
          "content": "package sshchat\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n\n\t\"github.com/shazow/rateio\"\n\t\"github.com/shazow/ssh-chat/chat\"\n\t\"github.com/shazow/ssh-chat/chat/message\"\n\t\"github.com/shazow/ssh-chat/internal/humantime\"\n\t\"github.com/shazow/ssh-chat/internal/sanitize\"\n\t\"github.com/shazow/ssh-chat/set\"\n\t\"github.com/shazow/ssh-chat/sshd\"\n)\n\nconst maxInputLength int = 1024\n\n// GetPrompt will render the terminal prompt string based on the user.\nfunc GetPrompt(user *message.User) string {\n\tname := user.Name()\n\tcfg := user.Config()\n\tif cfg.Theme != nil {\n\t\tname = cfg.Theme.ColorName(user)\n\t}\n\treturn fmt.Sprintf(\"[%s] \", name)\n}\n\n// Host is the bridge between sshd and chat modules\n// TODO: Should be easy to add support for multiple rooms, if we want.\ntype Host struct {\n\t*chat.Room\n\tlistener *sshd.SSHListener\n\tcommands chat.Commands\n\tauth     *Auth\n\n\t// Version string to print on /version\n\tVersion string\n\n\t// Default theme\n\ttheme message.Theme\n\n\tmu    sync.Mutex\n\tmotd  string\n\tcount int\n\n\t// GetMOTD is used to reload the motd from an external source\n\tGetMOTD func() (string, error)\n\t// OnUserJoined is used to notify when a user joins a host\n\tOnUserJoined func(*message.User)\n}\n\n// NewHost creates a Host on top of an existing listener.\nfunc NewHost(listener *sshd.SSHListener, auth *Auth) *Host {\n\troom := chat.NewRoom()\n\th := Host{\n\t\tRoom:     room,\n\t\tlistener: listener,\n\t\tcommands: chat.Commands{},\n\t\tauth:     auth,\n\t}\n\n\t// Make our own commands registry instance.\n\tchat.InitCommands(&h.commands)\n\th.InitCommands(&h.commands)\n\troom.SetCommands(h.commands)\n\n\tgo room.Serve()\n\treturn &h\n}\n\n// SetTheme sets the default theme for the host.\nfunc (h *Host) SetTheme(theme message.Theme) {\n\th.mu.Lock()\n\th.theme = theme\n\th.mu.Unlock()\n}\n\n// SetMotd sets the host's message of the day.\n// TODO: Change to SetMOTD\nfunc (h *Host) SetMotd(motd string) {\n\th.mu.Lock()\n\th.motd = motd\n\th.mu.Unlock()\n}\n\nfunc (h *Host) isOp(conn sshd.Connection) bool {\n\tkey := conn.PublicKey()\n\tif key == nil {\n\t\treturn false\n\t}\n\treturn h.auth.IsOp(key)\n}\n\n// Connect a specific Terminal to this host and its room.\nfunc (h *Host) Connect(term *sshd.Terminal) {\n\tid := NewIdentity(term.Conn)\n\tuser := message.NewUserScreen(id, term)\n\tuser.OnChange = func() {\n\t\tterm.SetPrompt(GetPrompt(user))\n\t\tuser.SetHighlight(user.ID())\n\t}\n\tcfg := user.Config()\n\n\tapiMode := strings.ToLower(term.Term()) == \"bot\"\n\n\tif apiMode {\n\t\tcfg.Theme = message.MonoTheme\n\t\tcfg.Echo = false\n\t} else {\n\t\tterm.SetEnterClear(true) // We provide our own echo rendering\n\t\tcfg.Theme = &h.theme\n\t}\n\n\tuser.SetConfig(cfg)\n\tgo user.Consume()\n\n\t// Close term once user is closed.\n\tdefer user.Close()\n\tdefer term.Close()\n\n\th.mu.Lock()\n\tmotd := h.motd\n\tcount := h.count\n\th.count++\n\th.mu.Unlock()\n\n\t// Send MOTD\n\tif motd != \"\" && !apiMode {\n\t\tuser.Send(message.NewAnnounceMsg(motd))\n\t}\n\n\tmember, err := h.Join(user)\n\tif err != nil {\n\t\t// Try again...\n\t\tid.SetName(fmt.Sprintf(\"Guest%d\", count))\n\t\tmember, err = h.Join(user)\n\t}\n\tif err != nil {\n\t\tlogger.Errorf(\"[%s] Failed to join: %s\", term.Conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\n\t// Load user config overrides from ENV\n\t// TODO: Would be nice to skip the command parsing pipeline just to load\n\t// config values. Would need to factor out some command handler logic into\n\t// accessible helpers.\n\tenv := term.Env()\n\tfor _, e := range env {\n\t\tswitch e.Key {\n\t\tcase \"SSHCHAT_TIMESTAMP\":\n\t\t\tif e.Value != \"\" && e.Value != \"0\" {\n\t\t\t\tcmd := \"/timestamp\"\n\t\t\t\tif e.Value != \"1\" {\n\t\t\t\t\tcmd += \" \" + e.Value\n\t\t\t\t}\n\t\t\t\tif msg, ok := message.NewPublicMsg(cmd, user).ParseCommand(); ok {\n\t\t\t\t\th.Room.HandleMsg(msg)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"SSHCHAT_THEME\":\n\t\t\tcmd := \"/theme \" + e.Value\n\t\t\tif msg, ok := message.NewPublicMsg(cmd, user).ParseCommand(); ok {\n\t\t\t\th.Room.HandleMsg(msg)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Successfully joined.\n\tif !apiMode {\n\t\tterm.SetPrompt(GetPrompt(user))\n\t\tterm.AutoCompleteCallback = h.AutoCompleteFunction(user)\n\t\tuser.SetHighlight(user.Name())\n\t}\n\n\t// Should the user be op'd on join?\n\tif h.isOp(term.Conn) {\n\t\tmember.IsOp = true\n\t}\n\tratelimit := rateio.NewSimpleLimiter(3, time.Second*3)\n\n\tlogger.Debugf(\"[%s] Joined: %s\", term.Conn.RemoteAddr(), user.Name())\n\n\tif h.OnUserJoined != nil {\n\t\th.OnUserJoined(user)\n\t}\n\n\tfor {\n\t\tline, err := term.ReadLine()\n\t\tif err == io.EOF {\n\t\t\t// Closed\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tlogger.Errorf(\"[%s] Terminal reading error: %s\", term.Conn.RemoteAddr(), err)\n\t\t\tbreak\n\t\t}\n\n\t\terr = ratelimit.Count(1)\n\t\tif err != nil {\n\t\t\tuser.Send(message.NewSystemMsg(\"Message rejected: Rate limiting is in effect.\", user))\n\t\t\tcontinue\n\t\t}\n\t\tif len(line) > maxInputLength {\n\t\t\tuser.Send(message.NewSystemMsg(\"Message rejected: Input too long.\", user))\n\t\t\tcontinue\n\t\t}\n\t\tif line == \"\" {\n\t\t\t// Silently ignore empty lines.\n\t\t\tterm.Write([]byte{})\n\t\t\tcontinue\n\t\t}\n\n\t\tm := message.ParseInput(line, user)\n\n\t\tif !apiMode {\n\t\t\tif m, ok := m.(*message.CommandMsg); ok {\n\t\t\t\t// Other messages render themselves by the room, commands we'll\n\t\t\t\t// have to re-echo ourselves manually.\n\t\t\t\tuser.HandleMsg(m)\n\t\t\t}\n\t\t}\n\n\t\t// FIXME: Any reason to use h.room.Send(m) instead?\n\t\th.HandleMsg(m)\n\n\t\tif apiMode {\n\t\t\t// Skip the remaining rendering workarounds\n\t\t\tcontinue\n\t\t}\n\t}\n\n\terr = h.Leave(user)\n\tif err != nil {\n\t\tlogger.Errorf(\"[%s] Failed to leave: %s\", term.Conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\tlogger.Debugf(\"[%s] Leaving: %s\", term.Conn.RemoteAddr(), user.Name())\n}\n\n// Serve our chat room onto the listener\nfunc (h *Host) Serve() {\n\th.listener.HandlerFunc = h.Connect\n\th.listener.Serve()\n}\n\nfunc (h *Host) completeName(partial string, skipName string) string {\n\tnames := h.NamesPrefix(partial)\n\tif len(names) == 0 {\n\t\t// Didn't find anything\n\t\treturn \"\"\n\t} else if name := names[0]; name != skipName {\n\t\t// First name is not the skipName, great\n\t\treturn name\n\t} else if len(names) > 1 {\n\t\t// Next candidate\n\t\treturn names[1]\n\t}\n\treturn \"\"\n}\n\nfunc (h *Host) completeCommand(partial string) string {\n\tfor cmd := range h.commands {\n\t\tif strings.HasPrefix(cmd, partial) {\n\t\t\treturn cmd\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// AutoCompleteFunction returns a callback for terminal autocompletion\nfunc (h *Host) AutoCompleteFunction(u *message.User) func(line string, pos int, key rune) (newLine string, newPos int, ok bool) {\n\treturn func(line string, pos int, key rune) (newLine string, newPos int, ok bool) {\n\t\tif key != 9 {\n\t\t\treturn\n\t\t}\n\n\t\tif line == \"\" || strings.HasSuffix(line[:pos], \" \") {\n\t\t\t// Don't autocomplete spaces.\n\t\t\treturn\n\t\t}\n\n\t\tfields := strings.Fields(line[:pos])\n\t\tisFirst := len(fields) < 2\n\t\tpartial := \"\"\n\t\tif len(fields) > 0 {\n\t\t\tpartial = fields[len(fields)-1]\n\t\t}\n\t\tposPartial := pos - len(partial)\n\n\t\tvar completed string\n\t\tif isFirst && strings.HasPrefix(line, \"/\") {\n\t\t\t// Command\n\t\t\tcompleted = h.completeCommand(partial)\n\t\t\tif completed == \"/reply\" {\n\t\t\t\treplyTo := u.ReplyTo()\n\t\t\t\tif replyTo != nil {\n\t\t\t\t\tname := replyTo.ID()\n\t\t\t\t\t_, found := h.GetUser(name)\n\t\t\t\t\tif found {\n\t\t\t\t\t\tcompleted = \"/msg \" + name\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.SetReplyTo(nil)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Name\n\t\t\tcompleted = h.completeName(partial, u.Name())\n\t\t\tif completed == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif isFirst {\n\t\t\t\tcompleted += \":\"\n\t\t\t}\n\t\t}\n\t\tcompleted += \" \"\n\n\t\t// Reposition the cursor\n\t\tnewLine = strings.Replace(line[posPartial:], partial, completed, 1)\n\t\tnewLine = line[:posPartial] + newLine\n\t\tnewPos = pos + (len(completed) - len(partial))\n\t\tok = true\n\t\treturn\n\t}\n}\n\n// GetUser returns a message.User based on a name.\nfunc (h *Host) GetUser(name string) (*message.User, bool) {\n\tm, ok := h.MemberByID(name)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\treturn m.User, true\n}\n\n// InitCommands adds host-specific commands to a Commands container. These will\n// override any existing commands.\nfunc (h *Host) InitCommands(c *chat.Commands) {\n\tsendPM := func(room *chat.Room, msg string, from *message.User, target *message.User) error {\n\t\tm := message.NewPrivateMsg(msg, from, target)\n\t\troom.Send(&m)\n\n\t\ttxt := fmt.Sprintf(\"[Sent PM to %s]\", target.Name())\n\t\tif isAway, _, awayReason := target.GetAway(); isAway {\n\t\t\ttxt += \" Away: \" + awayReason\n\t\t}\n\t\tsysMsg := message.NewSystemMsg(txt, from)\n\t\troom.Send(sysMsg)\n\t\ttarget.SetReplyTo(from)\n\t\treturn nil\n\t}\n\n\tc.Add(chat.Command{\n\t\tPrefix:     \"/msg\",\n\t\tPrefixHelp: \"USER MESSAGE\",\n\t\tHelp:       \"Send MESSAGE to USER.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\targs := msg.Args()\n\t\t\tswitch len(args) {\n\t\t\tcase 0:\n\t\t\t\treturn errors.New(\"must specify user\")\n\t\t\tcase 1:\n\t\t\t\treturn errors.New(\"must specify message\")\n\t\t\t}\n\n\t\t\ttarget, ok := h.GetUser(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\n\t\t\treturn sendPM(room, strings.Join(args[1:], \" \"), msg.From(), target)\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tPrefix:     \"/reply\",\n\t\tPrefixHelp: \"MESSAGE\",\n\t\tHelp:       \"Reply with MESSAGE to the previous private message.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\targs := msg.Args()\n\t\t\tswitch len(args) {\n\t\t\tcase 0:\n\t\t\t\treturn errors.New(\"must specify message\")\n\t\t\t}\n\n\t\t\ttarget := msg.From().ReplyTo()\n\t\t\tif target == nil {\n\t\t\t\treturn errors.New(\"no message to reply to\")\n\t\t\t}\n\n\t\t\t_, found := h.GetUser(target.ID())\n\t\t\tif !found {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\n\t\t\treturn sendPM(room, strings.Join(args, \" \"), msg.From(), target)\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tPrefix:     \"/whois\",\n\t\tPrefixHelp: \"USER\",\n\t\tHelp:       \"Information about USER.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\targs := msg.Args()\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"must specify user\")\n\t\t\t}\n\n\t\t\ttarget, ok := h.GetUser(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\t\t\tid := target.Identifier.(*Identity)\n\t\t\tvar whois string\n\t\t\tswitch room.IsOp(msg.From()) {\n\t\t\tcase true:\n\t\t\t\twhois = id.WhoisAdmin(room)\n\t\t\tcase false:\n\t\t\t\twhois = id.Whois(room)\n\t\t\t}\n\t\t\troom.Send(message.NewSystemMsg(whois, msg.From()))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\t// Hidden commands\n\tc.Add(chat.Command{\n\t\tPrefix: \"/version\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\troom.Send(message.NewSystemMsg(h.Version, msg.From()))\n\t\t\treturn nil\n\t\t},\n\t})\n\n\ttimeStarted := time.Now()\n\tc.Add(chat.Command{\n\t\tPrefix: \"/uptime\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\troom.Send(message.NewSystemMsg(humantime.Since(timeStarted), msg.From()))\n\t\t\treturn nil\n\t\t},\n\t})\n\n\t// Op commands\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/kick\",\n\t\tPrefixHelp: \"USER\",\n\t\tHelp:       \"Kick USER from the server.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\targs := msg.Args()\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"must specify user\")\n\t\t\t}\n\n\t\t\ttarget, ok := h.GetUser(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\n\t\t\tbody := fmt.Sprintf(\"%s was kicked by %s.\", target.Name(), msg.From().Name())\n\t\t\troom.Send(message.NewAnnounceMsg(body))\n\t\t\ttarget.Close()\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/ban\",\n\t\tPrefixHelp: \"QUERY [DURATION]\",\n\t\tHelp:       \"Ban from the server. QUERY can be a username to ban the fingerprint and ip, or quoted \\\"key=value\\\" pairs with keys like ip, fingerprint, client.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\t// TODO: Would be nice to specify what to ban. Key? Ip? etc.\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\targs := msg.Args()\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"must specify user\")\n\t\t\t}\n\n\t\t\tquery := args[0]\n\t\t\ttarget, ok := h.GetUser(query)\n\t\t\tif !ok {\n\t\t\t\tquery = strings.Join(args, \" \")\n\t\t\t\tif strings.Contains(query, \"=\") {\n\t\t\t\t\treturn h.auth.BanQuery(query)\n\t\t\t\t}\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\n\t\t\tvar until time.Duration\n\t\t\tif len(args) > 1 {\n\t\t\t\tuntil, _ = time.ParseDuration(args[1])\n\t\t\t}\n\n\t\t\tid := target.Identifier.(*Identity)\n\t\t\th.auth.Ban(id.PublicKey(), until)\n\t\t\th.auth.BanAddr(id.RemoteAddr(), until)\n\n\t\t\tbody := fmt.Sprintf(\"%s was banned by %s.\", target.Name(), msg.From().Name())\n\t\t\troom.Send(message.NewAnnounceMsg(body))\n\t\t\ttarget.Close()\n\n\t\t\tlogger.Debugf(\"Banned: \\n-> %s\", id.Whois(room))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tOp:     true,\n\t\tPrefix: \"/banned\",\n\t\tHelp:   \"List the current ban conditions.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\tbannedIPs, bannedFingerprints, bannedClients := h.auth.Banned()\n\n\t\t\tbuf := bytes.Buffer{}\n\t\t\tfmt.Fprintf(&buf, \"Banned:\")\n\t\t\tfor _, key := range bannedIPs {\n\t\t\t\tfmt.Fprintf(&buf, \"\\n   \\\"ip=%s\\\"\", key)\n\t\t\t}\n\t\t\tfor _, key := range bannedFingerprints {\n\t\t\t\tfmt.Fprintf(&buf, \"\\n   \\\"fingerprint=%s\\\"\", key)\n\t\t\t}\n\t\t\tfor _, key := range bannedClients {\n\t\t\t\tfmt.Fprintf(&buf, \"\\n   \\\"client=%s\\\"\", key)\n\t\t\t}\n\n\t\t\troom.Send(message.NewSystemMsg(buf.String(), msg.From()))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/motd\",\n\t\tPrefixHelp: \"[MESSAGE]\",\n\t\tHelp:       \"Set a new MESSAGE of the day, or print the motd if no MESSAGE.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\targs := msg.Args()\n\t\t\tuser := msg.From()\n\n\t\t\th.mu.Lock()\n\t\t\tmotd := h.motd\n\t\t\th.mu.Unlock()\n\n\t\t\tif len(args) == 0 {\n\t\t\t\troom.Send(message.NewSystemMsg(motd, user))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif !room.IsOp(user) {\n\t\t\t\treturn errors.New(\"must be OP to modify the MOTD\")\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tvar s string = strings.Join(args, \" \")\n\n\t\t\tif s == \"@\" {\n\t\t\t\tif h.GetMOTD == nil {\n\t\t\t\t\treturn errors.New(\"motd reload not set\")\n\t\t\t\t}\n\t\t\t\tif s, err = h.GetMOTD(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\th.SetMotd(s)\n\t\t\tfromMsg := fmt.Sprintf(\"New message of the day set by %s:\", msg.From().Name())\n\t\t\troom.Send(message.NewAnnounceMsg(fromMsg + message.Newline + \"-> \" + s))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/op\",\n\t\tPrefixHelp: \"USER [DURATION|remove]\",\n\t\tHelp:       \"Set USER as admin. Duration only applies to pubkey reconnects.\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\targs := msg.Args()\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn errors.New(\"must specify user\")\n\t\t\t}\n\n\t\t\topValue := true\n\t\t\tvar until time.Duration\n\t\t\tif len(args) > 1 {\n\t\t\t\tif args[1] == \"remove\" {\n\t\t\t\t\t// Expire instantly\n\t\t\t\t\tuntil = time.Duration(1)\n\t\t\t\t\topValue = false\n\t\t\t\t} else {\n\t\t\t\t\tuntil, _ = time.ParseDuration(args[1])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmember, ok := room.MemberByID(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\t\t\tmember.IsOp = opValue\n\n\t\t\tid := member.Identifier.(*Identity)\n\t\t\th.auth.Op(id.PublicKey(), until)\n\n\t\t\tvar body string\n\t\t\tif opValue {\n\t\t\t\tbody = fmt.Sprintf(\"Made op by %s.\", msg.From().Name())\n\t\t\t} else {\n\t\t\t\tbody = fmt.Sprintf(\"Removed op by %s.\", msg.From().Name())\n\t\t\t}\n\t\t\troom.Send(message.NewSystemMsg(body, member.User))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/rename\",\n\t\tPrefixHelp: \"USER NEW_NAME [SYMBOL]\",\n\t\tHelp:       \"Rename USER to NEW_NAME, add optional SYMBOL prefix\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) error {\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\targs := msg.Args()\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn errors.New(\"must specify user and new name\")\n\t\t\t}\n\n\t\t\tmember, ok := room.MemberByID(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"user not found\")\n\t\t\t}\n\n\t\t\tsymbolSet := false\n\t\t\tif len(args) == 3 {\n\t\t\t\ts := args[2]\n\t\t\t\tif id, ok := member.Identifier.(*Identity); ok {\n\t\t\t\t\tid.SetSymbol(s)\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(\"user does not support setting symbol\")\n\t\t\t\t}\n\n\t\t\t\tbody := fmt.Sprintf(\"Assigned symbol %q by %s.\", s, msg.From().Name())\n\t\t\t\troom.Send(message.NewSystemMsg(body, member.User))\n\t\t\t\tsymbolSet = true\n\t\t\t}\n\n\t\t\toldID := member.ID()\n\t\t\tnewID := sanitize.Name(args[1])\n\t\t\tif newID == oldID && !symbolSet {\n\t\t\t\treturn errors.New(\"new name is the same as the original\")\n\t\t\t} else if (newID == \"\" || newID == oldID) && symbolSet {\n\t\t\t\tif member.User.OnChange != nil {\n\t\t\t\t\tmember.User.OnChange()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tmember.SetID(newID)\n\t\t\terr := room.Rename(oldID, member)\n\t\t\tif err != nil {\n\t\t\t\tmember.SetID(oldID)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbody := fmt.Sprintf(\"%s was renamed by %s.\", oldID, msg.From().Name())\n\t\t\troom.Send(message.NewAnnounceMsg(body))\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tforConnectedUsers := func(cmd func(*chat.Member, ssh.PublicKey) error) error {\n\t\treturn h.Members.Each(func(key string, item set.Item) error {\n\t\t\tv := item.Value()\n\t\t\tif v == nil { // expired between Each and here\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tuser := v.(*chat.Member)\n\t\t\tpk := user.Identifier.(*Identity).PublicKey()\n\t\t\treturn cmd(user, pk)\n\t\t})\n\t}\n\n\tforPubkeyUser := func(args []string, cmd func(ssh.PublicKey)) (errors []string) {\n\t\tinvalidUsers := []string{}\n\t\tinvalidKeys := []string{}\n\t\tnoKeyUsers := []string{}\n\t\tvar keyType string\n\t\tfor _, v := range args {\n\t\t\tswitch {\n\t\t\tcase keyType != \"\":\n\t\t\t\tpk, _, _, _, err := ssh.ParseAuthorizedKey([]byte(keyType + \" \" + v))\n\t\t\t\tif err == nil {\n\t\t\t\t\tcmd(pk)\n\t\t\t\t} else {\n\t\t\t\t\tinvalidKeys = append(invalidKeys, keyType+\" \"+v)\n\t\t\t\t}\n\t\t\t\tkeyType = \"\"\n\t\t\tcase strings.HasPrefix(v, \"ssh-\"):\n\t\t\t\tkeyType = v\n\t\t\tdefault:\n\t\t\t\tuser, ok := h.GetUser(v)\n\t\t\t\tif ok {\n\t\t\t\t\tpk := user.Identifier.(*Identity).PublicKey()\n\t\t\t\t\tif pk == nil {\n\t\t\t\t\t\tnoKeyUsers = append(noKeyUsers, user.Identifier.Name())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcmd(pk)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinvalidUsers = append(invalidUsers, v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif len(noKeyUsers) != 0 {\n\t\t\terrors = append(errors, fmt.Sprintf(\"users without a public key: %v\", noKeyUsers))\n\t\t}\n\t\tif len(invalidUsers) != 0 {\n\t\t\terrors = append(errors, fmt.Sprintf(\"invalid users: %v\", invalidUsers))\n\t\t}\n\t\tif len(invalidKeys) != 0 {\n\t\t\terrors = append(errors, fmt.Sprintf(\"invalid keys: %v\", invalidKeys))\n\t\t}\n\t\treturn\n\t}\n\n\tallowlistHelptext := []string{\n\t\t\"Usage: /allowlist help | on | off | add {PUBKEY|USER}... | remove {PUBKEY|USER}... | import [AGE] | reload {keep|flush} | reverify | status\",\n\t\t\"help: this help message\",\n\t\t\"on, off: set allowlist mode (applies to new connections)\",\n\t\t\"add, remove: add or remove keys from the allowlist\",\n\t\t\"import: add all keys of users connected since AGE (default 0) ago to the allowlist\",\n\t\t\"reload: re-read the allowlist file and keep or discard entries in the current allowlist but not in the file\",\n\t\t\"reverify: kick all users not in the allowlist if allowlisting is enabled\",\n\t\t\"status: show status information\",\n\t}\n\n\tallowlistImport := func(args []string) (msgs []string, err error) {\n\t\tvar since time.Duration\n\t\tif len(args) > 0 {\n\t\t\tsince, err = time.ParseDuration(args[0])\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tcutoff := time.Now().Add(-since)\n\t\tnoKeyUsers := []string{}\n\t\tforConnectedUsers(func(user *chat.Member, pk ssh.PublicKey) error {\n\t\t\tif user.Joined().Before(cutoff) {\n\t\t\t\tif pk == nil {\n\t\t\t\t\tnoKeyUsers = append(noKeyUsers, user.Identifier.Name())\n\t\t\t\t} else {\n\t\t\t\t\th.auth.Allowlist(pk, 0)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif len(noKeyUsers) != 0 {\n\t\t\tmsgs = []string{fmt.Sprintf(\"users without a public key: %v\", noKeyUsers)}\n\t\t}\n\t\treturn\n\t}\n\n\tallowlistReload := func(args []string) error {\n\t\tif !(len(args) > 0 && (args[0] == \"keep\" || args[0] == \"flush\")) {\n\t\t\treturn errors.New(\"must specify whether to keep or flush current entries\")\n\t\t}\n\t\tif args[0] == \"flush\" {\n\t\t\th.auth.allowlist.Clear()\n\t\t}\n\t\treturn h.auth.ReloadAllowlist()\n\t}\n\n\tallowlistReverify := func(room *chat.Room) []string {\n\t\tif !h.auth.AllowlistMode() {\n\t\t\treturn []string{\"allowlist is disabled, so nobody will be kicked\"}\n\t\t}\n\t\tvar kicked []string\n\t\tforConnectedUsers(func(user *chat.Member, pk ssh.PublicKey) error {\n\t\t\tif h.auth.CheckPublicKey(pk) != nil && !user.IsOp { // we do this check here as well for ops without keys\n\t\t\t\tkicked = append(kicked, user.Name())\n\t\t\t\tuser.Close()\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif kicked != nil {\n\t\t\troom.Send(message.NewAnnounceMsg(\"Kicked during pubkey reverification: \" + strings.Join(kicked, \", \")))\n\t\t}\n\t\treturn nil\n\t}\n\n\tallowlistStatus := func() (msgs []string) {\n\t\tif h.auth.AllowlistMode() {\n\t\t\tmsgs = []string{\"allowlist enabled\"}\n\t\t} else {\n\t\t\tmsgs = []string{\"allowlist disabled\"}\n\t\t}\n\t\tallowlistedUsers := []string{}\n\t\tallowlistedKeys := []string{}\n\t\th.auth.allowlist.Each(func(key string, item set.Item) error {\n\t\t\tkeyFP := item.Key()\n\t\t\tif forConnectedUsers(func(user *chat.Member, pk ssh.PublicKey) error {\n\t\t\t\tif pk != nil && sshd.Fingerprint(pk) == keyFP {\n\t\t\t\t\tallowlistedUsers = append(allowlistedUsers, user.Name())\n\t\t\t\t\treturn io.EOF\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}) == nil {\n\t\t\t\t// if we land here, the key matches no users\n\t\t\t\tallowlistedKeys = append(allowlistedKeys, keyFP)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif len(allowlistedUsers) != 0 {\n\t\t\tmsgs = append(msgs, \"Connected users on the allowlist: \"+strings.Join(allowlistedUsers, \", \"))\n\t\t}\n\t\tif len(allowlistedKeys) != 0 {\n\t\t\tmsgs = append(msgs, \"Keys on the allowlist without connected user: \"+strings.Join(allowlistedKeys, \", \"))\n\t\t}\n\t\treturn\n\t}\n\n\tc.Add(chat.Command{\n\t\tOp:         true,\n\t\tPrefix:     \"/allowlist\",\n\t\tPrefixHelp: \"COMMAND [ARGS...]\",\n\t\tHelp:       \"Modify the allowlist or allowlist state. See /allowlist help for subcommands\",\n\t\tHandler: func(room *chat.Room, msg message.CommandMsg) (err error) {\n\t\t\tif !room.IsOp(msg.From()) {\n\t\t\t\treturn errors.New(\"must be op\")\n\t\t\t}\n\n\t\t\targs := msg.Args()\n\t\t\tif len(args) == 0 {\n\t\t\t\targs = []string{\"help\"}\n\t\t\t}\n\n\t\t\t// send exactly one message to preserve order\n\t\t\tvar replyLines []string\n\n\t\t\tswitch args[0] {\n\t\t\tcase \"help\":\n\t\t\t\treplyLines = allowlistHelptext\n\t\t\tcase \"on\":\n\t\t\t\th.auth.SetAllowlistMode(true)\n\t\t\tcase \"off\":\n\t\t\t\th.auth.SetAllowlistMode(false)\n\t\t\tcase \"add\":\n\t\t\t\treplyLines = forPubkeyUser(args[1:], func(pk ssh.PublicKey) { h.auth.Allowlist(pk, 0) })\n\t\t\tcase \"remove\":\n\t\t\t\treplyLines = forPubkeyUser(args[1:], func(pk ssh.PublicKey) { h.auth.Allowlist(pk, 1) })\n\t\t\tcase \"import\":\n\t\t\t\treplyLines, err = allowlistImport(args[1:])\n\t\t\tcase \"reload\":\n\t\t\t\terr = allowlistReload(args[1:])\n\t\t\tcase \"reverify\":\n\t\t\t\treplyLines = allowlistReverify(room)\n\t\t\tcase \"status\":\n\t\t\t\treplyLines = allowlistStatus()\n\t\t\tdefault:\n\t\t\t\terr = errors.New(\"invalid subcommand: \" + args[0])\n\t\t\t}\n\t\t\tif err == nil && replyLines != nil {\n\t\t\t\troom.Send(message.NewSystemMsg(strings.Join(replyLines, \"\\r\\n\"), msg.From()))\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "host_test.go",
          "type": "blob",
          "size": 11.841796875,
          "content": "package sshchat\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\tmathRand \"math/rand\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/shazow/ssh-chat/chat/message\"\n\t\"github.com/shazow/ssh-chat/sshd\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nfunc stripPrompt(s string) string {\n\t// FIXME: Is there a better way to do this?\n\tif endPos := strings.Index(s, \"\\x1b[K \"); endPos > 0 {\n\t\treturn s[endPos+3:]\n\t}\n\tif endPos := strings.Index(s, \"\\x1b[2K \"); endPos > 0 {\n\t\treturn s[endPos+4:]\n\t}\n\tif endPos := strings.Index(s, \"\\x1b[K-> \"); endPos > 0 {\n\t\treturn s[endPos+6:]\n\t}\n\tif endPos := strings.Index(s, \"] \"); endPos > 0 {\n\t\treturn s[endPos+2:]\n\t}\n\tif strings.HasPrefix(s, \"-> \") {\n\t\treturn s[3:]\n\t}\n\treturn s\n}\n\nfunc TestStripPrompt(t *testing.T) {\n\ttests := []struct {\n\t\tInput string\n\t\tWant  string\n\t}{\n\t\t{\n\t\t\tInput: \"\\x1b[A\\x1b[2K[quux] hello\",\n\t\t\tWant:  \"hello\",\n\t\t},\n\t\t{\n\t\t\tInput: \"[foo] \\x1b[D\\x1b[D\\x1b[D\\x1b[D\\x1b[D\\x1b[D\\x1b[K * Guest1 joined. (Connected: 2)\\r\",\n\t\t\tWant:  \" * Guest1 joined. (Connected: 2)\\r\",\n\t\t},\n\t\t{\n\t\t\tInput: \"[foo] \\x1b[6D\\x1b[K-> From your friendly system.\\r\",\n\t\t\tWant:  \"From your friendly system.\\r\",\n\t\t},\n\t\t{\n\t\t\tInput: \"-> Err: must be op.\\r\",\n\t\t\tWant:  \"Err: must be op.\\r\",\n\t\t},\n\t}\n\n\tfor i, tc := range tests {\n\t\tif got, want := stripPrompt(tc.Input), tc.Want; got != want {\n\t\t\tt.Errorf(\"case #%d:\\n got: %q\\nwant: %q\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc TestHostGetPrompt(t *testing.T) {\n\tvar expected, actual string\n\n\t// Make the random colors consistent across tests\n\tmathRand.Seed(1)\n\n\tu := message.NewUser(&Identity{id: \"foo\"})\n\n\tactual = GetPrompt(u)\n\texpected = \"[foo] \"\n\tif actual != expected {\n\t\tt.Errorf(\"Invalid host prompt:\\n Got: %q;\\nWant: %q\", actual, expected)\n\t}\n\n\tu.SetConfig(message.UserConfig{\n\t\tTheme: &message.Themes[0],\n\t})\n\tactual = GetPrompt(u)\n\texpected = \"[\\033[38;05;88mfoo\\033[0m] \"\n\tif actual != expected {\n\t\tt.Errorf(\"Invalid host prompt:\\n Got: %q;\\nWant: %q\", actual, expected)\n\t}\n}\n\nfunc getHost(t *testing.T, auth *Auth) (*sshd.SSHListener, *Host) {\n\tkey, err := sshd.NewRandomSigner(1024)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar config *ssh.ServerConfig\n\tif auth == nil {\n\t\tconfig = sshd.MakeNoAuth()\n\t} else {\n\t\tconfig = sshd.MakeAuth(auth)\n\t}\n\tconfig.AddHostKey(key)\n\n\ts, err := sshd.ListenSSH(\"localhost:0\", config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn s, NewHost(s, auth)\n}\n\nfunc TestHostNameCollision(t *testing.T) {\n\ts, host := getHost(t, nil)\n\tdefer s.Close()\n\n\tnewUsers := make(chan *message.User)\n\thost.OnUserJoined = func(u *message.User) {\n\t\tnewUsers <- u\n\t}\n\tgo host.Serve()\n\n\tg := errgroup.Group{}\n\n\t// First client\n\tg.Go(func() error {\n\t\treturn sshd.ConnectShell(s.Addr().String(), \"foo\", func(r io.Reader, w io.WriteCloser) error {\n\t\t\t// second client\n\t\t\tname := (<-newUsers).Name()\n\t\t\tif name != \"Guest1\" {\n\t\t\t\tt.Errorf(\"Second client did not get Guest1 name: %q\", name)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t})\n\n\t// Second client\n\tg.Go(func() error {\n\t\t// first client\n\t\tname := (<-newUsers).Name()\n\t\tif name != \"foo\" {\n\t\t\tt.Errorf(\"First client did not get foo name: %q\", name)\n\t\t}\n\t\treturn sshd.ConnectShell(s.Addr().String(), \"foo\", func(r io.Reader, w io.WriteCloser) error {\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tif err := g.Wait(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestHostAllowlist(t *testing.T) {\n\tauth := NewAuth()\n\ts, host := getHost(t, auth)\n\tdefer s.Close()\n\tgo host.Serve()\n\n\ttarget := s.Addr().String()\n\n\tclientPrivateKey, err := sshd.NewRandomSigner(512)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclientKey := clientPrivateKey.PublicKey()\n\tloadCount := -1\n\tloader := func() ([]ssh.PublicKey, error) {\n\t\tloadCount++\n\t\treturn [][]ssh.PublicKey{\n\t\t\t{},\n\t\t\t{clientKey},\n\t\t}[loadCount], nil\n\t}\n\tauth.LoadAllowlist(loader)\n\n\terr = sshd.ConnectShell(target, \"foo\", func(r io.Reader, w io.WriteCloser) error { return nil })\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tauth.SetAllowlistMode(true)\n\terr = sshd.ConnectShell(target, \"foo\", func(r io.Reader, w io.WriteCloser) error { return nil })\n\tif err == nil {\n\t\tt.Error(err)\n\t}\n\terr = sshd.ConnectShellWithKey(target, \"foo\", clientPrivateKey, func(r io.Reader, w io.WriteCloser) error { return nil })\n\tif err == nil {\n\t\tt.Error(err)\n\t}\n\n\tauth.ReloadAllowlist()\n\terr = sshd.ConnectShell(target, \"foo\", func(r io.Reader, w io.WriteCloser) error { return nil })\n\tif err == nil {\n\t\tt.Error(\"Failed to block unallowlisted connection.\")\n\t}\n}\n\nfunc TestHostAllowlistCommand(t *testing.T) {\n\ts, host := getHost(t, NewAuth())\n\tdefer s.Close()\n\tgo host.Serve()\n\n\tusers := make(chan *message.User)\n\thost.OnUserJoined = func(u *message.User) {\n\t\tusers <- u\n\t}\n\n\tkickSignal := make(chan struct{})\n\tclientKey, err := sshd.NewRandomSigner(1024)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclientKeyFP := sshd.Fingerprint(clientKey.PublicKey())\n\tgo sshd.ConnectShellWithKey(s.Addr().String(), \"bar\", clientKey, func(r io.Reader, w io.WriteCloser) error {\n\t\t<-kickSignal\n\t\tn, err := w.Write([]byte(\"alive and well\"))\n\t\tif n != 0 || err == nil {\n\t\t\tt.Error(\"could write after being kicked\")\n\t\t}\n\t\treturn nil\n\t})\n\n\tsshd.ConnectShell(s.Addr().String(), \"foo\", func(r io.Reader, w io.WriteCloser) error {\n\t\t<-users\n\t\t<-users\n\t\tm, ok := host.MemberByID(\"foo\")\n\t\tif !ok {\n\t\t\tt.Fatal(\"can't get member foo\")\n\t\t}\n\n\t\tscanner := bufio.NewScanner(r)\n\t\tscanner.Scan() // Joined\n\t\tscanner.Scan()\n\n\t\tassertLineEq := func(expected ...string) {\n\t\t\tif !scanner.Scan() {\n\t\t\t\tt.Error(\"no line available\")\n\t\t\t}\n\t\t\tactual := stripPrompt(scanner.Text())\n\t\t\tfor _, exp := range expected {\n\t\t\t\tif exp == actual {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Errorf(\"expected %#v, got %q\", expected, actual)\n\t\t}\n\t\tsendCmd := func(cmd string, formatting ...interface{}) {\n\t\t\thost.HandleMsg(message.ParseInput(fmt.Sprintf(cmd, formatting...), m.User))\n\t\t}\n\n\t\tsendCmd(\"/allowlist\")\n\t\tassertLineEq(\"Err: must be op\\r\")\n\t\tm.IsOp = true\n\t\tsendCmd(\"/allowlist\")\n\t\tfor _, expected := range [...]string{\"Usage\", \"help\", \"on, off\", \"add, remove\", \"import\", \"reload\", \"reverify\", \"status\"} {\n\t\t\tif !scanner.Scan() {\n\t\t\t\tt.Error(\"no line available\")\n\t\t\t}\n\t\t\tif actual := stripPrompt(scanner.Text()); !strings.HasPrefix(actual, expected) {\n\t\t\t\tt.Errorf(\"Unexpected help message order: have %q, want prefix %q\", actual, expected)\n\t\t\t}\n\t\t}\n\n\t\tsendCmd(\"/allowlist on\")\n\t\tif !host.auth.AllowlistMode() {\n\t\t\tt.Error(\"allowlist not enabled after /allowlist on\")\n\t\t}\n\t\tsendCmd(\"/allowlist off\")\n\t\tif host.auth.AllowlistMode() {\n\t\t\tt.Error(\"allowlist not disabled after /allowlist off\")\n\t\t}\n\n\t\ttestKey := \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPUiNw0nQku4pcUCbZcJlIEAIf5bXJYTy/DKI1vh5b+P\"\n\t\ttestKeyFP := \"SHA256:GJNSl9NUcOS2pZYALn0C5Qgfh5deT+R+FfqNIUvpM9s=\"\n\n\t\tif host.auth.allowlist.Len() != 0 {\n\t\t\tt.Error(\"allowlist not empty before adding anyone\")\n\t\t}\n\t\tsendCmd(\"/allowlist add ssh-invalid blah ssh-rsa wrongAsWell invalid foo bar %s\", testKey)\n\t\tassertLineEq(\"users without a public key: [foo]\\r\")\n\t\tassertLineEq(\"invalid users: [invalid]\\r\")\n\t\tassertLineEq(\"invalid keys: [ssh-invalid blah ssh-rsa wrongAsWell]\\r\")\n\t\tif !host.auth.allowlist.In(testKeyFP) || !host.auth.allowlist.In(clientKeyFP) {\n\t\t\tt.Error(\"failed to add keys to allowlist\")\n\t\t}\n\t\tsendCmd(\"/allowlist remove invalid bar\")\n\t\tassertLineEq(\"invalid users: [invalid]\\r\")\n\t\tif host.auth.allowlist.In(clientKeyFP) {\n\t\t\tt.Error(\"failed to remove key from allowlist\")\n\t\t}\n\t\tif !host.auth.allowlist.In(testKeyFP) {\n\t\t\tt.Error(\"removed wrong key\")\n\t\t}\n\n\t\tsendCmd(\"/allowlist import 5h\")\n\t\tif host.auth.allowlist.In(clientKeyFP) {\n\t\t\tt.Error(\"imporrted key not seen long enough\")\n\t\t}\n\t\tsendCmd(\"/allowlist import\")\n\t\tassertLineEq(\"users without a public key: [foo]\\r\")\n\t\tif !host.auth.allowlist.In(clientKeyFP) {\n\t\t\tt.Error(\"failed to import key\")\n\t\t}\n\n\t\tsendCmd(\"/allowlist reload keep\")\n\t\tif !host.auth.allowlist.In(testKeyFP) {\n\t\t\tt.Error(\"cleared allowlist to be kept\")\n\t\t}\n\t\tsendCmd(\"/allowlist reload flush\")\n\t\tif host.auth.allowlist.In(testKeyFP) {\n\t\t\tt.Error(\"kept allowlist to be cleared\")\n\t\t}\n\t\tsendCmd(\"/allowlist reload thisIsWrong\")\n\t\tassertLineEq(\"Err: must specify whether to keep or flush current entries\\r\")\n\t\tsendCmd(\"/allowlist reload\")\n\t\tassertLineEq(\"Err: must specify whether to keep or flush current entries\\r\")\n\n\t\tsendCmd(\"/allowlist reverify\")\n\t\tassertLineEq(\"allowlist is disabled, so nobody will be kicked\\r\")\n\t\tsendCmd(\"/allowlist on\")\n\t\tsendCmd(\"/allowlist reverify\")\n\t\tassertLineEq(\" * Kicked during pubkey reverification: bar\\r\", \" * bar left. (After 0 seconds)\\r\")\n\t\tassertLineEq(\" * Kicked during pubkey reverification: bar\\r\", \" * bar left. (After 0 seconds)\\r\")\n\t\tkickSignal <- struct{}{}\n\n\t\tsendCmd(\"/allowlist add \" + testKey)\n\t\tsendCmd(\"/allowlist status\")\n\t\tassertLineEq(\"allowlist enabled\\r\")\n\t\tassertLineEq(fmt.Sprintf(\"Keys on the allowlist without connected user: %s\\r\", testKeyFP))\n\n\t\tsendCmd(\"/allowlist invalidSubcommand\")\n\t\tassertLineEq(\"Err: invalid subcommand: invalidSubcommand\\r\")\n\t\treturn nil\n\t})\n}\n\nfunc TestHostKick(t *testing.T) {\n\ts, host := getHost(t, NewAuth())\n\tdefer s.Close()\n\tgo host.Serve()\n\n\tg := errgroup.Group{}\n\tconnected := make(chan struct{})\n\tkicked := make(chan struct{})\n\n\tg.Go(func() error {\n\t\t// First client\n\t\treturn sshd.ConnectShell(s.Addr().String(), \"foo\", func(r io.Reader, w io.WriteCloser) error {\n\t\t\tscanner := bufio.NewScanner(r)\n\n\t\t\t// Consume the initial buffer\n\t\t\tscanner.Scan() // Joined\n\n\t\t\t// Make op\n\t\t\tmember, _ := host.Room.MemberByID(\"foo\")\n\t\t\tif member == nil {\n\t\t\t\treturn errors.New(\"failed to load MemberByID\")\n\t\t\t}\n\t\t\tmember.IsOp = true\n\n\t\t\t// Change nicks, make sure op sticks\n\t\t\tw.Write([]byte(\"/nick quux\\r\\n\"))\n\t\t\tscanner.Scan() // Prompt\n\t\t\tscanner.Scan() // Nick change response\n\n\t\t\t// Block until second client is here\n\t\t\tconnected <- struct{}{}\n\t\t\tscanner.Scan() // Connected message\n\n\t\t\tw.Write([]byte(\"/kick bar\\r\\n\"))\n\t\t\tscanner.Scan() // Prompt\n\n\t\t\tscanner.Scan() // Kick result\n\t\t\tif actual, expected := stripPrompt(scanner.Text()), \" * bar was kicked by quux.\\r\"; actual != expected {\n\t\t\t\tt.Errorf(\"Failed to detect kick:\\n Got: %q;\\nWant: %q\", actual, expected)\n\t\t\t}\n\n\t\t\tkicked <- struct{}{}\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tg.Go(func() error {\n\t\t// Second client\n\t\treturn sshd.ConnectShell(s.Addr().String(), \"bar\", func(r io.Reader, w io.WriteCloser) error {\n\t\t\tscanner := bufio.NewScanner(r)\n\t\t\t<-connected\n\t\t\tscanner.Scan()\n\n\t\t\t<-kicked\n\n\t\t\tif _, err := w.Write([]byte(\"am I still here?\\r\\n\")); err != io.EOF {\n\t\t\t\treturn errors.New(\"expected to be kicked\")\n\t\t\t}\n\n\t\t\tscanner.Scan()\n\t\t\tif err := scanner.Err(); err == io.EOF {\n\t\t\t\t// All good, we got kicked.\n\t\t\t\treturn nil\n\t\t\t} else {\n\t\t\t\treturn err\n\t\t\t}\n\t\t})\n\t})\n\n\tif err := g.Wait(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTimestampEnvConfig(t *testing.T) {\n\tcases := []struct {\n\t\tinput      string\n\t\ttimeformat *string\n\t}{\n\t\t{\"\", strptr(\"15:04\")},\n\t\t{\"1\", strptr(\"15:04\")},\n\t\t{\"0\", nil},\n\t\t{\"time +8h\", strptr(\"15:04\")},\n\t\t{\"datetime +8h\", strptr(\"2006-01-02 15:04:05\")},\n\t}\n\tfor _, tc := range cases {\n\t\tu := connectUserWithConfig(t, \"dingus\", map[string]string{\n\t\t\t\"SSHCHAT_TIMESTAMP\": tc.input,\n\t\t})\n\t\tuserConfig := u.Config()\n\t\tif userConfig.Timeformat != nil && tc.timeformat != nil {\n\t\t\tif *userConfig.Timeformat != *tc.timeformat {\n\t\t\t\tt.Fatal(\"unexpected timeformat:\", *userConfig.Timeformat, \"expected:\", *tc.timeformat)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc strptr(s string) *string {\n\treturn &s\n}\n\nfunc connectUserWithConfig(t *testing.T, name string, envConfig map[string]string) *message.User {\n\ts, host := getHost(t, nil)\n\tdefer s.Close()\n\n\tnewUsers := make(chan *message.User)\n\thost.OnUserJoined = func(u *message.User) {\n\t\tnewUsers <- u\n\t}\n\tgo host.Serve()\n\n\tclientConfig := sshd.NewClientConfig(name)\n\tconn, err := ssh.Dial(\"tcp\", s.Addr().String(), clientConfig)\n\tif err != nil {\n\t\tt.Fatal(\"unable to connect to test ssh-chat server:\", err)\n\t}\n\tdefer conn.Close()\n\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(\"unable to open session:\", err)\n\t}\n\tdefer session.Close()\n\n\tfor key := range envConfig {\n\t\tsession.Setenv(key, envConfig[key])\n\t}\n\n\terr = session.Shell()\n\tif err != nil {\n\t\tt.Fatal(\"unable to open shell:\", err)\n\t}\n\n\tfor u := range newUsers {\n\t\tif u.Name() == name {\n\t\t\treturn u\n\t\t}\n\t}\n\tt.Fatalf(\"user %s not found in the host\", name)\n\treturn nil\n}\n"
        },
        {
          "name": "identity.go",
          "type": "blob",
          "size": 3.1435546875,
          "content": "package sshchat\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/shazow/ssh-chat/chat\"\n\t\"github.com/shazow/ssh-chat/chat/message\"\n\t\"github.com/shazow/ssh-chat/internal/humantime\"\n\t\"github.com/shazow/ssh-chat/internal/sanitize\"\n\t\"github.com/shazow/ssh-chat/sshd\"\n)\n\n// Identity is a container for everything that identifies a client.\ntype Identity struct {\n\tsshd.Connection\n\tid      string\n\tsymbol  string // symbol is displayed as a prefix to the name\n\tcreated time.Time\n}\n\n// NewIdentity returns a new identity object from an sshd.Connection.\nfunc NewIdentity(conn sshd.Connection) *Identity {\n\treturn &Identity{\n\t\tConnection: conn,\n\t\tid:         sanitize.Name(conn.Name()),\n\t\tcreated:    time.Now(),\n\t}\n}\n\n// ID returns the name for the Identity\nfunc (i Identity) ID() string {\n\treturn i.id\n}\n\n// SetID Changes the Identity's name\nfunc (i *Identity) SetID(id string) {\n\ti.id = id\n}\n\n// SetName Changes the Identity's name\nfunc (i *Identity) SetName(name string) {\n\ti.SetID(name)\n}\n\nfunc (i *Identity) SetSymbol(symbol string) {\n\ti.symbol = symbol\n}\n\n// Name returns the name for the Identity\nfunc (i Identity) Name() string {\n\tif i.symbol != \"\" {\n\t\treturn i.symbol + \" \" + i.id\n\t}\n\treturn i.id\n}\n\n// Whois returns a whois description for non-admin users.\nfunc (i Identity) Whois(room *chat.Room) string {\n\tfingerprint := \"(no public key)\"\n\tif i.PublicKey() != nil {\n\t\tfingerprint = sshd.Fingerprint(i.PublicKey())\n\t}\n\t// TODO: Rewrite this using strings.Builder like WhoisAdmin\n\n\tawayMsg := \"\"\n\tif m, ok := room.MemberByID(i.ID()); ok {\n\t\tisAway, awaySince, awayMessage := m.GetAway()\n\t\tif isAway {\n\t\t\tawayMsg = fmt.Sprintf(\"%s > away: (%s ago) %s\", message.Newline, humantime.Since(awaySince), awayMessage)\n\t\t}\n\t}\n\treturn \"name: \" + i.Name() + message.Newline +\n\t\t\" > fingerprint: \" + fingerprint + message.Newline +\n\t\t\" > client: \" + sanitize.Data(string(i.ClientVersion()), 64) + message.Newline +\n\t\t\" > joined: \" + humantime.Since(i.created) + \" ago\" +\n\t\tawayMsg\n}\n\n// WhoisAdmin returns a whois description for admin users.\nfunc (i Identity) WhoisAdmin(room *chat.Room) string {\n\tip, _, _ := net.SplitHostPort(i.RemoteAddr().String())\n\tfingerprint := \"(no public key)\"\n\tif i.PublicKey() != nil {\n\t\tfingerprint = sshd.Fingerprint(i.PublicKey())\n\t}\n\n\tout := strings.Builder{}\n\tout.WriteString(\"name: \" + i.Name() + message.Newline +\n\t\t\" > ip: \" + ip + message.Newline +\n\t\t\" > fingerprint: \" + fingerprint + message.Newline +\n\t\t\" > client: \" + sanitize.Data(string(i.ClientVersion()), 64) + message.Newline +\n\t\t\" > joined: \" + humantime.Since(i.created) + \" ago\")\n\n\tif member, ok := room.MemberByID(i.ID()); ok {\n\t\t// Add room-specific whois\n\t\tif isAway, awaySince, awayMessage := member.GetAway(); isAway {\n\t\t\tfmt.Fprintf(&out, message.Newline+\" > away: (%s ago) %s\", humantime.Since(awaySince), awayMessage)\n\t\t}\n\t\t// FIXME: Should these always be present, even if they're false? Maybe\n\t\t// change that once we add room context to Whois() above.\n\t\tif !member.LastMsg().IsZero() {\n\t\t\tout.WriteString(message.Newline + \" > room/messaged: \" + humantime.Since(member.LastMsg()) + \" ago\")\n\t\t}\n\t\tif room.IsOp(member.User) {\n\t\t\tout.WriteString(message.Newline + \" > room/op: true\")\n\t\t}\n\t}\n\n\treturn out.String()\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.3173828125,
          "content": "package sshchat\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/alexcesaro/log\"\n\t\"github.com/alexcesaro/log/golog\"\n)\n\nvar logger *golog.Logger\n\n// SetLogger sets the package logging to use l.\nfunc SetLogger(l *golog.Logger) {\n\tlogger = l\n}\n\nfunc init() {\n\t// Set a default null logger\n\tSetLogger(golog.New(ioutil.Discard, log.Debug))\n}\n"
        },
        {
          "name": "motd.txt",
          "type": "blob",
          "size": 0.330078125,
          "content": "\u001b[31;1mWelcome to ssh-chat, enter \u001b[0m/help\u001b[31;1m for more.\n\u001b[32;1m Please enjoy our selection of bugs, but run your own server if you want to crash it:\u001b[0m https://ssh.chat/issues\n\u001b[33;1m Sponsors get an emoji prefix:\u001b[0m https://ssh.chat/sponsor\n\u001b[34;1m Be nice and follow our Code of Conduct:\u001b[0m https://ssh.chat/conduct\n"
        },
        {
          "name": "set",
          "type": "tree",
          "content": null
        },
        {
          "name": "sshd",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}