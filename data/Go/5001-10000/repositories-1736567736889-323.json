{
  "metadata": {
    "timestamp": 1736567736889,
    "page": 323,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "coder/sshcode",
      "stars": 5731,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": "vendor\nbin\n.vscode\nsshcode\nsshcode.exe\n"
        },
        {
          "name": ".sail",
          "type": "tree",
          "content": null
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.158203125,
          "content": "dist: xenial\nlanguage: go\ngo:\n- 1.12.x\ngo_import_path: go.coder.com/retry\nenv:\n  - GO111MODULE=on\nscript: \n- ./ci/ensuremod.sh\n- ./ci/lint.sh \n- go test -v ./...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "Copyright 2019 Coder Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1708984375,
          "content": "# sshcode\n\n**This project has been deprecated in favour of the [code-server install script](https://github.com/cdr/code-server#quick-install)**\n\n**See the discussion in [#185](https://github.com/cdr/sshcode/issues/185)**\n\n---\n\n[![\"Open Issues\"](https://img.shields.io/github/issues-raw/cdr/sshcode.svg)](https://github.com/cdr/sshcode/issues)\n[![\"Latest Release\"](https://img.shields.io/github/release/cdr/sshcode.svg)](https://github.com/cdr/sshcode/releases/latest)\n[![MIT license](https://img.shields.io/badge/license-MIT-green.svg)](https://github.com/cdr/sshcode/blob/master/LICENSE)\n[![Discord](https://img.shields.io/discord/463752820026376202.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/zxSwN8Z)\n[![Build Status](https://travis-ci.org/cdr/sshcode.svg?branch=master)](https://travis-ci.org/cdr/sshcode)\n\n`sshcode` is a CLI to automatically install and run [code-server](https://github.com/cdr/code-server) over SSH.\n\nIt uploads your extensions and settings automatically, so you can seamlessly use\nremote servers as [VS Code](https://code.visualstudio.com) hosts.\n\nIf you have Chrome installed, it opens the browser in app mode. That means\nthere's no keybind conflicts, address bar, or indication that you're coding within a browser.\n**It feels just like native VS Code.**\n\n![Demo](/demo.gif)\n\n## Install\n\n**Have Chrome installed for the best experience.**\n\nInstall with `go`:\n\n```bash\ngo get -u go.coder.com/sshcode\n```\n\nOr, grab a [pre-built binary](https://github.com/cdr/sshcode/releases).\n\n### OS Support\n\nWe currently support:\n- Linux\n- MacOS\n- WSL\n\nFor the remote server, we currently only support Linux `x86_64` (64-bit)\nservers with `glibc`. `musl` libc (which is most notably used by Alpine Linux)\nis currently not supported on the remote server:\n[#122](https://github.com/cdr/sshcode/issues/122).\n\n## Usage\n\n```bash\nsshcode kyle@dev.kwc.io\n# Starts code-server on dev.kwc.io and opens in a new browser window.\n```\n\nYou can specify a remote directory as the second argument:\n\n```bash\nsshcode kyle@dev.kwc.io \"~/projects/sourcegraph\"\n```\n\n## Extensions & Settings Sync\n\nBy default, `sshcode` will `rsync` your local VS Code settings and extensions\nto the remote server every time you connect.\n\nThis operation may take a while on a slow connections, but will be fast\non follow-up connections to the same server.\n\nTo disable this feature entirely, pass the `--skipsync` flag.\n\n### Custom settings directories\n\nIf you're using an alternate release of VS Code such as VS Code Insiders, you\nmust specify your settings directories through the `VSCODE_CONFIG_DIR` and\n`VSCODE_EXTENSIONS_DIR` environment variables.\n\nThe following will make `sshcode` work with VS Code Insiders:\n\n**MacOS**\n\n```bash\nexport VSCODE_CONFIG_DIR=\"$HOME/Library/Application Support/Code - Insiders/User\"\nexport VSCODE_EXTENSIONS_DIR=\"$HOME/.vscode-insiders/extensions\"\n```\n\n**Linux**\n\n```bash\nexport VSCODE_CONFIG_DIR=\"$HOME/.config/Code - Insiders/User\"\nexport VSCODE_EXTENSIONS_DIR=\"$HOME/.vscode-insiders/extensions\"\n```\n\n### Sync-back\n\nBy default, VS Code changes on the remote server won't be synced back\nwhen the connection closes. To synchronize back to local when the connection ends,\npass the `-b` flag.\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo.gif",
          "type": "blob",
          "size": 701.8876953125,
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.517578125,
          "content": "module go.coder.com/sshcode\n\ngo 1.12\n\nrequire (\n\tgithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4\n\tgithub.com/pkg/errors v0.8.1 // indirect\n\tgithub.com/spf13/pflag v1.0.3\n\tgithub.com/stretchr/testify v1.3.0\n\tgo.coder.com/cli v0.4.0\n\tgo.coder.com/flog v0.0.0-20190129195112-eaed154a0db8\n\tgo.coder.com/retry v0.0.0-20180926062817-cf12c95974ac\n\tgolang.org/x/crypto v0.0.0-20190422183909-d864b10871cd\n\tgolang.org/x/sys v0.0.0-20190418153312-f0ce4c0180be // indirect\n\tgolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.4697265625,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/mattn/go-colorable v0.0.9 h1:UVL0vNpWh04HeJXV0KLcaT7r06gOH2l4OW6ddYRUIY4=\ngithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-isatty v0.0.4 h1:bnP0vzxcAdeI1zdubAl5PjU6zsERjGZb7raWodagDYs=\ngithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4 h1:49lOXmGaUpV9Fz3gd7TFZY106KVlPVa5jcYD1gaQf98=\ngithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4/go.mod h1:4OwLy04Bl9Ef3GJJCoec+30X3LQs/0/m4HFRt/2LUSA=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/spf13/pflag v1.0.3 h1:zPAT6CGy6wXeQ7NtTnaTerfKOsV6V6F8agHXFiazDkg=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.1.4/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngo.coder.com/cli v0.4.0 h1:PruDGwm/CPFndyK/eMowZG3vzg5CgohRWeXWCTr3zi8=\ngo.coder.com/cli v0.4.0/go.mod h1:hRTOURCR3LJF1FRW9arecgrzX+AHG7mfYMwThPIgq+w=\ngo.coder.com/flog v0.0.0-20190129195112-eaed154a0db8 h1:PtQ3moPi4EAz3cyQhkUs1IGIXa2QgJpP60yMjOdu0kk=\ngo.coder.com/flog v0.0.0-20190129195112-eaed154a0db8/go.mod h1:83JsYgXYv0EOaXjIMnaZ1Fl6ddNB3fJnDZ/8845mUJ8=\ngo.coder.com/retry v0.0.0-20180926062817-cf12c95974ac h1:ekdpsuykRy/E+SDq5BquFomNhRCk8OOyhtnACW9Bi50=\ngo.coder.com/retry v0.0.0-20180926062817-cf12c95974ac/go.mod h1:h7MQcGZ698RYUan++Yu4aDcBvquTI2cSsup+GSy8D2Y=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190422183909-d864b10871cd h1:sMHc2rZHuzQmrbVoSpt9HgerkXPyIeCSO6k0zUMGfFk=\ngolang.org/x/crypto v0.0.0-20190422183909-d864b10871cd/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190418153312-f0ce4c0180be h1:mI+jhqkn68ybP0ORJqunXn+fq+Eeb4hHKqLQcFICjAc=\ngolang.org/x/sys v0.0.0-20190418153312-f0ce4c0180be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7 h1:9zdDQZ7Thm29KFXgAX/+yaf3eVbP7djjWp/dXAppNCc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 2.6904296875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/spf13/pflag\"\n\n\t\"go.coder.com/cli\"\n\t\"go.coder.com/flog\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().Unix())\n}\n\nconst helpTabWidth = 5\n\nvar (\n\thelpTab = strings.Repeat(\" \", helpTabWidth)\n\t// version is overwritten by ci/build.sh.\n\tversion string\n)\n\nfunc main() {\n\tcli.RunRoot(&rootCmd{})\n}\n\nvar _ interface {\n\tcli.Command\n\tcli.FlaggedCommand\n} = new(rootCmd)\n\ntype rootCmd struct {\n\tskipSync          bool\n\tsyncBack          bool\n\tprintVersion      bool\n\tnoReuseConnection bool\n\tbindAddr          string\n\tsshFlags          string\n\tuploadCodeServer  string\n}\n\nfunc (c *rootCmd) Spec() cli.CommandSpec {\n\treturn cli.CommandSpec{\n\t\tName:  \"sshcode\",\n\t\tUsage: c.usage(),\n\t\tDesc:  c.description(),\n\t}\n}\n\nfunc (c *rootCmd) RegisterFlags(fl *pflag.FlagSet) {\n\tfl.BoolVar(&c.skipSync, \"skipsync\", false, \"skip syncing local settings and extensions to remote host\")\n\tfl.BoolVar(&c.syncBack, \"b\", false, \"sync extensions back on termination\")\n\tfl.BoolVar(&c.printVersion, \"version\", false, \"print version information and exit\")\n\tfl.BoolVar(&c.noReuseConnection, \"no-reuse-connection\", false, \"do not reuse SSH connection via control socket\")\n\tfl.StringVar(&c.bindAddr, \"bind\", \"\", \"local bind address for SSH tunnel, in [HOST][:PORT] syntax (default: 127.0.0.1)\")\n\tfl.StringVar(&c.sshFlags, \"ssh-flags\", \"\", \"custom SSH flags\")\n\tfl.StringVar(&c.uploadCodeServer, \"upload-code-server\", \"\", \"custom code-server binary to upload to the remote host\")\n}\n\nfunc (c *rootCmd) Run(fl *pflag.FlagSet) {\n\tif c.printVersion {\n\t\tfmt.Printf(\"%v\\n\", version)\n\t\tos.Exit(0)\n\t}\n\n\thost := fl.Arg(0)\n\tif host == \"\" {\n\t\t// If no host is specified output the usage.\n\t\tfl.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tdir := fl.Arg(1)\n\tif dir == \"\" {\n\t\tdir = \"~\"\n\t}\n\n\t// Get linux relative path if on windows.\n\tif runtime.GOOS == \"windows\" {\n\t\tdir = gitbashWindowsDir(dir)\n\t}\n\n\terr := sshCode(host, dir, options{\n\t\tskipSync:         c.skipSync,\n\t\tsshFlags:         c.sshFlags,\n\t\tbindAddr:         c.bindAddr,\n\t\tsyncBack:         c.syncBack,\n\t\treuseConnection:  !c.noReuseConnection,\n\t\tuploadCodeServer: c.uploadCodeServer,\n\t})\n\n\tif err != nil {\n\t\tflog.Fatal(\"error: %v\", err)\n\t}\n}\n\nfunc (c *rootCmd) usage() string {\n\treturn \"[FLAGS] HOST [DIR]\"\n}\n\nfunc (c *rootCmd) description() string {\n\treturn fmt.Sprintf(`Start VS Code via code-server over SSH.\n\nEnvironment variables:\n%v%v use special VS Code settings dir.\n%v%v use special VS Code extensions dir.\n\nMore info: https://github.com/cdr/sshcode\n\nArguments:\n%vHOST is passed into the ssh command. Valid formats are '<ip-address>' or 'gcp:<instance-name>'.\n%vDIR is optional.`,\n\t\thelpTab, vsCodeConfigDirEnv,\n\t\thelpTab, vsCodeExtensionsDirEnv,\n\t\thelpTab,\n\t\thelpTab,\n\t)\n}\n"
        },
        {
          "name": "settings.go",
          "type": "blob",
          "size": 1.1455078125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\n\t\"golang.org/x/xerrors\"\n)\n\nconst (\n\tvsCodeConfigDirEnv     = \"VSCODE_CONFIG_DIR\"\n\tvsCodeExtensionsDirEnv = \"VSCODE_EXTENSIONS_DIR\"\n)\n\nfunc configDir() (string, error) {\n\tif env, ok := os.LookupEnv(vsCodeConfigDirEnv); ok {\n\t\treturn os.ExpandEnv(env), nil\n\t}\n\n\tvar path string\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tpath = os.ExpandEnv(\"$HOME/.config/Code/User/\")\n\tcase \"darwin\":\n\t\tpath = os.ExpandEnv(\"$HOME/Library/Application Support/Code/User/\")\n\tcase \"windows\":\n\t\treturn os.ExpandEnv(\"/c/Users/$USERNAME/AppData/Roaming/Code/User\"), nil\n\tdefault:\n\t\treturn \"\", xerrors.Errorf(\"unsupported platform: %s\", runtime.GOOS)\n\t}\n\treturn filepath.Clean(path), nil\n}\n\nfunc extensionsDir() (string, error) {\n\tif env, ok := os.LookupEnv(vsCodeExtensionsDirEnv); ok {\n\t\treturn os.ExpandEnv(env), nil\n\t}\n\n\tvar path string\n\tswitch runtime.GOOS {\n\tcase \"linux\", \"darwin\":\n\t\tpath = os.ExpandEnv(\"$HOME/.vscode/extensions/\")\n\tcase \"windows\":\n\t\treturn os.ExpandEnv(\"/c/Users/$USERNAME/.vscode/extensions\"), nil\n\tdefault:\n\t\treturn \"\", xerrors.Errorf(\"unsupported platform: %s\", runtime.GOOS)\n\t}\n\treturn filepath.Clean(path), nil\n}\n"
        },
        {
          "name": "sshcode.go",
          "type": "blob",
          "size": 17.376953125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/pkg/browser\"\n\t\"go.coder.com/flog\"\n\t\"golang.org/x/xerrors\"\n)\n\nconst codeServerPath = \"~/.cache/sshcode/sshcode-server\"\n\nconst (\n\tsshDirectory               = \"~/.ssh\"\n\tsshDirectoryUnsafeModeMask = 0022\n\tsshControlPath             = sshDirectory + \"/control-%h-%p-%r\"\n)\n\ntype options struct {\n\tskipSync         bool\n\tsyncBack         bool\n\tnoOpen           bool\n\treuseConnection  bool\n\tbindAddr         string\n\tremotePort       string\n\tsshFlags         string\n\tuploadCodeServer string\n}\n\nfunc sshCode(host, dir string, o options) error {\n\thost, extraSSHFlags, err := parseHost(host)\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to parse host IP: %w\", err)\n\t}\n\tif extraSSHFlags != \"\" {\n\t\to.sshFlags = strings.Join([]string{extraSSHFlags, o.sshFlags}, \" \")\n\t}\n\n\to.bindAddr, err = parseBindAddr(o.bindAddr)\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to parse bind address: %w\", err)\n\t}\n\n\tif o.remotePort == \"\" {\n\t\to.remotePort, err = randomPort()\n\t}\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to find available remote port: %w\", err)\n\t}\n\n\t// Check the SSH directory's permissions and warn the user if it is not safe.\n\to.reuseConnection = checkSSHDirectory(sshDirectory, o.reuseConnection)\n\n\t// Start SSH master connection socket. This prevents multiple password prompts from appearing as authentication\n\t// only happens on the initial connection.\n\tif o.reuseConnection {\n\t\tflog.Info(\"starting SSH master connection...\")\n\t\tnewSSHFlags, cancel, err := startSSHMaster(o.sshFlags, sshControlPath, host)\n\t\tdefer cancel()\n\t\tif err != nil {\n\t\t\tflog.Error(\"failed to start SSH master connection: %v\", err)\n\t\t\to.reuseConnection = false\n\t\t} else {\n\t\t\to.sshFlags = newSSHFlags\n\t\t}\n\t}\n\n\t// Upload local code-server or download code-server from CI server.\n\tif o.uploadCodeServer != \"\" {\n\t\tflog.Info(\"uploading local code-server binary...\")\n\t\terr = copyCodeServerBinary(o.sshFlags, host, o.uploadCodeServer, codeServerPath)\n\t\tif err != nil {\n\t\t\treturn xerrors.Errorf(\"failed to upload local code-server binary to remote server: %w\", err)\n\t\t}\n\n\t\tsshCmdStr :=\n\t\t\tfmt.Sprintf(\"ssh %v %v 'chmod +x %v'\",\n\t\t\t\to.sshFlags, host, codeServerPath,\n\t\t\t)\n\n\t\tsshCmd := exec.Command(\"sh\", \"-l\", \"-c\", sshCmdStr)\n\t\tsshCmd.Stdout = os.Stdout\n\t\tsshCmd.Stderr = os.Stderr\n\t\terr = sshCmd.Run()\n\t\tif err != nil {\n\t\t\treturn xerrors.Errorf(\"failed to make code-server binary executable:\\n---ssh cmd---\\n%s: %w\",\n\t\t\t\tsshCmdStr,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\t} else {\n\t\tflog.Info(\"ensuring code-server is updated...\")\n\t\tdlScript := downloadScript(codeServerPath)\n\n\t\t// Downloads the latest code-server and allows it to be executed.\n\t\tsshCmdStr := fmt.Sprintf(\"ssh %v %v '/usr/bin/env bash -l'\", o.sshFlags, host)\n\t\tsshCmd := exec.Command(\"sh\", \"-l\", \"-c\", sshCmdStr)\n\t\tsshCmd.Stdout = os.Stdout\n\t\tsshCmd.Stderr = os.Stderr\n\t\tsshCmd.Stdin = strings.NewReader(dlScript)\n\t\terr = sshCmd.Run()\n\t\tif err != nil {\n\t\t\treturn xerrors.Errorf(\"failed to update code-server:\\n---ssh cmd---\\n%s\"+\n\t\t\t\t\"\\n---download script---\\n%s: %w\",\n\t\t\t\tsshCmdStr,\n\t\t\t\tdlScript,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\t}\n\n\tif !o.skipSync {\n\t\tstart := time.Now()\n\t\tflog.Info(\"syncing settings\")\n\t\terr = syncUserSettings(o.sshFlags, host, false)\n\t\tif err != nil {\n\t\t\treturn xerrors.Errorf(\"failed to sync settings: %w\", err)\n\t\t}\n\n\t\tflog.Info(\"synced settings in %s\", time.Since(start))\n\n\t\tflog.Info(\"syncing extensions\")\n\t\terr = syncExtensions(o.sshFlags, host, false)\n\t\tif err != nil {\n\t\t\treturn xerrors.Errorf(\"failed to sync extensions: %w\", err)\n\t\t}\n\t\tflog.Info(\"synced extensions in %s\", time.Since(start))\n\t}\n\n\tflog.Info(\"starting code-server...\")\n\n\tflog.Info(\"Tunneling remote port %v to %v\", o.remotePort, o.bindAddr)\n\n\tsshCmdStr :=\n\t\tfmt.Sprintf(\"ssh -tt -q -L %v:localhost:%v %v %v '%v  %v --host 127.0.0.1 --auth none --port=%v'\",\n\t\t\to.bindAddr, o.remotePort, o.sshFlags, host, codeServerPath, dir, o.remotePort,\n\t\t)\n\t// Starts code-server and forwards the remote port.\n\tsshCmd := exec.Command(\"sh\", \"-l\", \"-c\", sshCmdStr)\n\tsshCmd.Stdin = os.Stdin\n\tsshCmd.Stdout = os.Stdout\n\tsshCmd.Stderr = os.Stderr\n\terr = sshCmd.Start()\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to start code-server: %w\", err)\n\t}\n\n\turl := fmt.Sprintf(\"http://%s\", o.bindAddr)\n\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)\n\tdefer cancel()\n\n\tclient := http.Client{\n\t\tTimeout: time.Second * 3,\n\t}\n\tfor {\n\t\tif ctx.Err() != nil {\n\t\t\treturn xerrors.Errorf(\"code-server didn't start in time: %w\", ctx.Err())\n\t\t}\n\t\t// Waits for code-server to be available before opening the browser.\n\t\tresp, err := client.Get(url)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tresp.Body.Close()\n\t\tbreak\n\t}\n\n\tctx, cancel = context.WithCancel(context.Background())\n\n\tif !o.noOpen {\n\t\topenBrowser(url)\n\t}\n\n\tgo func() {\n\t\tdefer cancel()\n\t\tsshCmd.Wait()\n\t}()\n\n\tc := make(chan os.Signal)\n\tsignal.Notify(c, os.Interrupt)\n\n\tselect {\n\tcase <-ctx.Done():\n\tcase <-c:\n\t}\n\n\tflog.Info(\"shutting down\")\n\tif !o.syncBack || o.skipSync {\n\t\treturn nil\n\t}\n\n\tflog.Info(\"synchronizing VS Code back to local\")\n\n\terr = syncExtensions(o.sshFlags, host, true)\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to sync extensions back: %w\", err)\n\t}\n\n\terr = syncUserSettings(o.sshFlags, host, true)\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to sync user settings back: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// expandPath returns an expanded version of path.\nfunc expandPath(path string) string {\n\tpath = filepath.Clean(os.ExpandEnv(path))\n\n\t// Replace tilde notation in path with the home directory. You can't replace the first instance of `~` in the\n\t// string with the homedir as having a tilde in the middle of a filename is valid.\n\thomedir := os.Getenv(\"HOME\")\n\tif homedir != \"\" {\n\t\tif path == \"~\" {\n\t\t\tpath = homedir\n\t\t} else if strings.HasPrefix(path, \"~/\") {\n\t\t\tpath = filepath.Join(homedir, path[2:])\n\t\t}\n\t}\n\n\treturn filepath.Clean(path)\n}\n\nfunc parseBindAddr(bindAddr string) (string, error) {\n\tif !strings.Contains(bindAddr, \":\") {\n\t\tbindAddr += \":\"\n\t}\n\n\thost, port, err := net.SplitHostPort(bindAddr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif host == \"\" {\n\t\thost = \"127.0.0.1\"\n\t}\n\n\tif port == \"\" {\n\t\tport, err = randomPort()\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn net.JoinHostPort(host, port), nil\n}\n\nfunc openBrowser(url string) {\n\tvar openCmd *exec.Cmd\n\n\tconst (\n\t\tmacPath = \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\"\n\t\twslPath = \"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\"\n\t\twinPath = \"C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\"\n\t)\n\n\tswitch {\n\tcase commandExists(\"chrome\"):\n\t\topenCmd = exec.Command(\"chrome\", chromeOptions(url)...)\n\tcase commandExists(\"google-chrome\"):\n\t\topenCmd = exec.Command(\"google-chrome\", chromeOptions(url)...)\n\tcase commandExists(\"google-chrome-stable\"):\n\t\topenCmd = exec.Command(\"google-chrome-stable\", chromeOptions(url)...)\n\tcase commandExists(\"chromium\"):\n\t\topenCmd = exec.Command(\"chromium\", chromeOptions(url)...)\n\tcase commandExists(\"chromium-browser\"):\n\t\topenCmd = exec.Command(\"chromium-browser\", chromeOptions(url)...)\n\tcase pathExists(macPath):\n\t\topenCmd = exec.Command(macPath, chromeOptions(url)...)\n\tcase pathExists(wslPath):\n\t\topenCmd = exec.Command(wslPath, chromeOptions(url)...)\n\tcase pathExists(winPath):\n\t\topenCmd = exec.Command(winPath, chromeOptions(url)...)\n\tdefault:\n\t\terr := browser.OpenURL(url)\n\t\tif err != nil {\n\t\t\tflog.Error(\"failed to open browser: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\n\t// We do not use CombinedOutput because if there is no chrome instance, this will block\n\t// and become the parent process instead of using an existing chrome instance.\n\terr := openCmd.Start()\n\tif err != nil {\n\t\tflog.Error(\"failed to open browser: %v\", err)\n\t}\n}\n\nfunc chromeOptions(url string) []string {\n\treturn []string{\"--app=\" + url, \"--disable-extensions\", \"--disable-plugins\", \"--incognito\"}\n}\n\n// Checks if a command exists locally.\nfunc commandExists(name string) bool {\n\t_, err := exec.LookPath(name)\n\treturn err == nil\n}\n\nfunc pathExists(name string) bool {\n\t_, err := os.Stat(name)\n\treturn err == nil\n}\n\n// randomPort picks a random port to start code-server on.\nfunc randomPort() (string, error) {\n\tconst (\n\t\tminPort  = 1024\n\t\tmaxPort  = 65535\n\t\tmaxTries = 10\n\t)\n\tfor i := 0; i < maxTries; i++ {\n\t\tport := rand.Intn(maxPort-minPort+1) + minPort\n\t\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\t\tif err == nil {\n\t\t\t_ = l.Close()\n\t\t\treturn strconv.Itoa(port), nil\n\t\t}\n\t\tflog.Info(\"port taken: %d\", port)\n\t}\n\n\treturn \"\", xerrors.Errorf(\"max number of tries exceeded: %d\", maxTries)\n}\n\n// checkSSHDirectory performs sanity and safety checks on sshDirectory, and\n// returns a new value for o.reuseConnection depending on the checks.\nfunc checkSSHDirectory(sshDirectory string, reuseConnection bool) bool {\n\tif runtime.GOOS == \"windows\" {\n\t\tflog.Info(\"OS is windows, disabling connection reuse feature\")\n\t\treturn false\n\t}\n\n\tsshDirectoryMode, err := os.Lstat(expandPath(sshDirectory))\n\tif err != nil {\n\t\tif reuseConnection {\n\t\t\tflog.Info(\"failed to stat %v directory, disabling connection reuse feature: %v\", sshDirectory, err)\n\t\t}\n\t\treuseConnection = false\n\t} else {\n\t\tif !sshDirectoryMode.IsDir() {\n\t\t\tif reuseConnection {\n\t\t\t\tflog.Info(\"%v is not a directory, disabling connection reuse feature\", sshDirectory)\n\t\t\t} else {\n\t\t\t\tflog.Info(\"warning: %v is not a directory\", sshDirectory)\n\t\t\t}\n\t\t\treuseConnection = false\n\t\t}\n\t\tif sshDirectoryMode.Mode().Perm()&sshDirectoryUnsafeModeMask != 0 {\n\t\t\tflog.Info(\"warning: the %v directory has unsafe permissions, they should only be writable by \"+\n\t\t\t\t\"the owner (and files inside should be set to 0600)\", sshDirectory)\n\t\t}\n\t}\n\treturn reuseConnection\n}\n\n// startSSHMaster starts an SSH master connection and waits for it to be ready.\n// It returns a new set of SSH flags for child SSH processes to use.\nfunc startSSHMaster(sshFlags string, sshControlPath string, host string) (string, func(), error) {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tnewSSHFlags := fmt.Sprintf(`%v -o \"ControlPath=%v\"`, sshFlags, sshControlPath)\n\n\t// -MN means \"start a master socket and don't open a session, just connect\".\n\tsshCmdStr := fmt.Sprintf(`exec ssh %v -MNq %v`, newSSHFlags, host)\n\tsshMasterCmd := exec.CommandContext(ctx, \"sh\", \"-c\", sshCmdStr)\n\tsshMasterCmd.Stdin = os.Stdin\n\tsshMasterCmd.Stderr = os.Stderr\n\n\t// Gracefully stop the SSH master.\n\tstopSSHMaster := func() {\n\t\tif sshMasterCmd.Process != nil {\n\t\t\tif sshMasterCmd.ProcessState != nil && sshMasterCmd.ProcessState.Exited() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr := sshMasterCmd.Process.Signal(syscall.SIGTERM)\n\t\t\tif err != nil {\n\t\t\t\tflog.Error(\"failed to send SIGTERM to SSH master process: %v\", err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t}\n\n\t// Start ssh master and wait. Waiting prevents the process from becoming a zombie process if it dies before\n\t// sshcode does, and allows sshMasterCmd.ProcessState to be populated.\n\terr := sshMasterCmd.Start()\n\tgo sshMasterCmd.Wait()\n\tif err != nil {\n\t\treturn \"\", stopSSHMaster, err\n\t}\n\terr = checkSSHMaster(sshMasterCmd, newSSHFlags, host)\n\tif err != nil {\n\t\tstopSSHMaster()\n\t\treturn \"\", stopSSHMaster, xerrors.Errorf(\"SSH master wasn't ready on time: %w\", err)\n\t}\n\treturn newSSHFlags, stopSSHMaster, nil\n}\n\n// checkSSHMaster polls every second for 30 seconds to check if the SSH master\n// is ready.\nfunc checkSSHMaster(sshMasterCmd *exec.Cmd, sshFlags string, host string) error {\n\tvar (\n\t\tmaxTries = 30\n\t\tsleepDur = time.Second\n\t\terr      error\n\t)\n\tfor i := 0; i < maxTries; i++ {\n\t\t// Check if the master is running.\n\t\tif sshMasterCmd.Process == nil || (sshMasterCmd.ProcessState != nil && sshMasterCmd.ProcessState.Exited()) {\n\t\t\treturn xerrors.Errorf(\"SSH master process is not running\")\n\t\t}\n\n\t\t// Check if it's ready.\n\t\tsshCmdStr := fmt.Sprintf(`ssh %v -O check %v`, sshFlags, host)\n\t\tsshCmd := exec.Command(\"sh\", \"-c\", sshCmdStr)\n\t\terr = sshCmd.Run()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(sleepDur)\n\t}\n\treturn xerrors.Errorf(\"max number of tries exceeded: %d\", maxTries)\n}\n\n// copyCodeServerBinary copies a code-server binary from local to remote.\nfunc copyCodeServerBinary(sshFlags string, host string, localPath string, remotePath string) error {\n\tif err := validateIsFile(localPath); err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tsrc  = localPath\n\t\tdest = host + \":\" + remotePath\n\t)\n\n\treturn rsync(src, dest, sshFlags)\n}\n\nfunc syncUserSettings(sshFlags string, host string, back bool) error {\n\tlocalConfDir, err := configDir()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ensureDir(localConfDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar remoteSettingsDir = \"~/.local/share/code-server/User/\"\n\tif runtime.GOOS == \"windows\" {\n\t\tremoteSettingsDir = \".local/share/code-server/User/\"\n\t}\n\tvar (\n\t\tsrc  = localConfDir + \"/\"\n\t\tdest = host + \":\" + remoteSettingsDir\n\t)\n\n\tif back {\n\t\tdest, src = src, dest\n\t}\n\n\t// Append \"/\" to have rsync copy the contents of the dir.\n\treturn rsync(src, dest, sshFlags, \"workspaceStorage\", \"logs\", \"CachedData\")\n}\n\nfunc syncExtensions(sshFlags string, host string, back bool) error {\n\tlocalExtensionsDir, err := extensionsDir()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ensureDir(localExtensionsDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar remoteExtensionsDir = \"~/.local/share/code-server/extensions/\"\n\tif runtime.GOOS == \"windows\" {\n\t\tremoteExtensionsDir = \".local/share/code-server/extensions/\"\n\t}\n\n\tvar (\n\t\tsrc  = localExtensionsDir + \"/\"\n\t\tdest = host + \":\" + remoteExtensionsDir\n\t)\n\tif back {\n\t\tdest, src = src, dest\n\t}\n\n\treturn rsync(src, dest, sshFlags)\n}\n\nfunc rsync(src string, dest string, sshFlags string, excludePaths ...string) error {\n\texcludeFlags := make([]string, len(excludePaths))\n\tfor i, path := range excludePaths {\n\t\texcludeFlags[i] = \"--exclude=\" + path\n\t}\n\n\tcmd := exec.Command(\"rsync\", append(excludeFlags, \"-azvr\",\n\t\t\"-e\", \"ssh \"+sshFlags,\n\t\t// Only update newer directories, and sync times\n\t\t// to keep things simple.\n\t\t\"-u\", \"--times\",\n\t\t// This is more unsafe, but it's obnoxious having to enter VS Code\n\t\t// locally in order to properly delete an extension.\n\t\t\"--delete\",\n\t\t\"--copy-unsafe-links\",\n\t\t\"-zz\",\n\t\tsrc, dest,\n\t)...,\n\t)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn xerrors.Errorf(\"failed to rsync '%s' to '%s': %w\", src, dest, err)\n\t}\n\n\treturn nil\n}\n\nfunc downloadScript(codeServerPath string) string {\n\treturn fmt.Sprintf(\n\t\t`set -euxo pipefail || exit 1\n\n[ \"$(uname -m)\" != \"x86_64\" ] && echo \"Unsupported server architecture $(uname -m). code-server only has releases for x86_64 systems.\" && exit 1\npkill -f %v || true\nmkdir -p $HOME/.local/share/code-server %v\ncd %v\ncurlflags=\"-o latest-linux\"\nif [ -f latest-linux ]; then\n\tcurlflags=\"$curlflags -z latest-linux\"\nfi\ncurl $curlflags https://codesrv-ci.cdr.sh/latest-linux\n[ -f %v ] && rm %v\nln latest-linux %v\nchmod +x %v`,\n\t\tcodeServerPath,\n\t\tfilepath.ToSlash(filepath.Dir(codeServerPath)),\n\t\tfilepath.ToSlash(filepath.Dir(codeServerPath)),\n\t\tcodeServerPath,\n\t\tcodeServerPath,\n\t\tcodeServerPath,\n\t\tcodeServerPath,\n\t)\n}\n\n// ensureDir creates a directory if it does not exist.\nfunc ensureDir(path string) error {\n\t_, err := os.Stat(path)\n\tif os.IsNotExist(err) {\n\t\t// This fixes a issue where Go reads `/c/` as `C:\\c\\` and creates\n\t\t// empty directories on the client that don't need to exist.\n\t\tif runtime.GOOS == \"windows\" && strings.HasPrefix(path, \"/c/\") {\n\t\t\tpath = \"C:\" + path[2:]\n\t\t}\n\t\terr = os.MkdirAll(path, 0750)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// validateIsFile tries to stat the specified path and ensure it's a file.\nfunc validateIsFile(path string) error {\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif info.IsDir() {\n\t\treturn xerrors.New(\"path is a directory\")\n\t}\n\treturn nil\n}\n\n// parseHost parses the host argument. If 'gcp:' is prefixed to the\n// host then a lookup is done using gcloud to determine the external IP and any\n// additional SSH arguments that should be used for ssh commands. Otherwise, host\n// is returned.\nfunc parseHost(host string) (parsedHost string, additionalFlags string, err error) {\n\thost = strings.TrimSpace(host)\n\tswitch {\n\tcase strings.HasPrefix(host, \"gcp:\"):\n\t\tinstance := strings.TrimPrefix(host, \"gcp:\")\n\t\treturn parseGCPSSHCmd(instance)\n\tdefault:\n\t\treturn host, \"\", nil\n\t}\n}\n\n// parseGCPSSHCmd parses the IP address and flags used by 'gcloud' when\n// ssh'ing to an instance.\nfunc parseGCPSSHCmd(instance string) (ip, sshFlags string, err error) {\n\tdryRunCmd := fmt.Sprintf(\"gcloud compute ssh --dry-run %v\", instance)\n\n\tout, err := exec.Command(\"sh\", \"-l\", \"-c\", dryRunCmd).CombinedOutput()\n\tif err != nil {\n\t\treturn \"\", \"\", xerrors.Errorf(\"%s: %w\", out, err)\n\t}\n\n\ttoks := strings.Split(string(out), \" \")\n\tif len(toks) < 2 {\n\t\treturn \"\", \"\", xerrors.Errorf(\"unexpected output for '%v' command, %s\", dryRunCmd, out)\n\t}\n\n\t// Slice off the '/usr/bin/ssh' prefix and the '<user>@<ip>' suffix.\n\tsshFlags = strings.Join(toks[1:len(toks)-1], \" \")\n\n\t// E.g. foo@1.2.3.4.\n\tuserIP := toks[len(toks)-1]\n\n\treturn strings.TrimSpace(userIP), sshFlags, nil\n}\n\n// gitbashWindowsDir strips a the msys2 install directory from the beginning of\n// the path. On msys2, if a user provides `/workspace` sshcode will receive\n// `C:/msys64/workspace` which won't work on the remote host.\nfunc gitbashWindowsDir(dir string) string {\n\n\t// Don't bother figuring out path if it's relative to home dir.\n\tif strings.HasPrefix(dir, \"~/\") {\n\t\tif dir == \"~\" {\n\t\t\treturn \"~/\"\n\t\t}\n\t\treturn dir\n\t}\n\n\tmingwPrefix, err := exec.Command(\"sh\", \"-c\", \"{ cd / && pwd -W; }\").Output()\n\tif err != nil {\n\t\t// Default to a sane location.\n\t\tmingwPrefix = []byte(\"C:/mingw64\")\n\t}\n\n\tprefix := strings.TrimSuffix(string(mingwPrefix), \"/\\n\")\n\treturn strings.TrimPrefix(dir, prefix)\n}\n"
        },
        {
          "name": "sshcode_test.go",
          "type": "blob",
          "size": 7.53125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.coder.com/retry\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestSSHCode(t *testing.T) {\n\tsshPort, err := randomPort()\n\trequire.NoError(t, err)\n\n\t// start up our jank ssh server\n\tdefer trassh(t, sshPort).Close()\n\n\tlocalPort := randomPortExclude(t, sshPort)\n\trequire.NotEmpty(t, localPort)\n\n\tremotePort := randomPortExclude(t, sshPort, localPort)\n\trequire.NotEmpty(t, remotePort)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terr := sshCode(\"foo@127.0.0.1\", \"\", options{\n\t\t\tsshFlags:   testSSHArgs(sshPort),\n\t\t\tbindAddr:   net.JoinHostPort(\"127.0.0.1\", localPort),\n\t\t\tremotePort: remotePort,\n\t\t\tnoOpen:     true,\n\t\t})\n\t\trequire.NoError(t, err)\n\t}()\n\n\twaitForSSHCode(t, localPort, time.Second*30)\n\twaitForSSHCode(t, remotePort, time.Second*30)\n\n\t// Typically we'd do an os.Stat call here but the os package doesn't expand '~'\n\tout, err := exec.Command(\"sh\", \"-l\", \"-c\", \"stat \"+codeServerPath).CombinedOutput()\n\trequire.NoError(t, err, \"%s\", out)\n\n\tout, err = exec.Command(\"pkill\", filepath.Base(codeServerPath)).CombinedOutput()\n\trequire.NoError(t, err, \"%s\", out)\n\n\twg.Wait()\n}\n\n// trassh is an incomplete, local, insecure ssh server\n// used for the purpose of testing the implementation without\n// requiring the user to have their own remote server.\nfunc trassh(t *testing.T, port string) io.Closer {\n\tprivate, err := ssh.ParsePrivateKey([]byte(fakeRSAKey))\n\trequire.NoError(t, err)\n\n\tconf := &ssh.ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\n\tconf.AddHostKey(private)\n\n\tlistener, err := net.Listen(\"tcp\", net.JoinHostPort(\"127.0.0.1\", port))\n\trequire.NoError(t, err)\n\n\tgo func() {\n\t\tfor {\n\t\t\tfunc() {\n\t\t\t\tconn, err := listener.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefer conn.Close()\n\n\t\t\t\tsshConn, chans, reqs, err := ssh.NewServerConn(conn, conf)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tgo ssh.DiscardRequests(reqs)\n\n\t\t\t\tfor c := range chans {\n\t\t\t\t\tswitch c.ChannelType() {\n\t\t\t\t\tcase \"direct-tcpip\":\n\t\t\t\t\t\tvar req directTCPIPReq\n\n\t\t\t\t\t\terr := ssh.Unmarshal(c.ExtraData(), &req)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Logf(\"failed to unmarshal tcpip data: %v\", err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tch, _, err := c.Accept()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tc.Reject(ssh.ConnectionFailed, fmt.Sprintf(\"unable to accept channel: %v\", err))\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgo handleDirectTCPIP(ch, &req, t)\n\t\t\t\t\tcase \"session\":\n\t\t\t\t\t\tch, inReqs, err := c.Accept()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tc.Reject(ssh.ConnectionFailed, fmt.Sprintf(\"unable to accept channel: %v\", err))\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgo handleSession(ch, inReqs, t)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tt.Logf(\"unsupported session type: %v\\n\", c.ChannelType())\n\t\t\t\t\t\tc.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsshConn.Wait()\n\t\t\t}()\n\t\t}\n\t}()\n\treturn listener\n}\n\nfunc handleDirectTCPIP(ch ssh.Channel, req *directTCPIPReq, t *testing.T) {\n\tdefer ch.Close()\n\n\tdstAddr := net.JoinHostPort(req.Host, strconv.Itoa(int(req.Port)))\n\n\tconn, err := net.Dial(\"tcp\", dstAddr)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tvar wg sync.WaitGroup\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tdefer ch.Close()\n\n\t\tio.Copy(ch, conn)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tdefer conn.Close()\n\n\t\tio.Copy(conn, ch)\n\t}()\n\twg.Wait()\n}\n\n// execReq describes an exec payload.\ntype execReq struct {\n\tCommand string\n}\n\n// directTCPIPReq describes the extra data sent in a\n// direct-tcpip request containing the host/port for the ssh server.\ntype directTCPIPReq struct {\n\tHost string\n\tPort uint32\n\n\tOrig     string\n\tOrigPort uint32\n}\n\n// exitStatus describes an 'exit-status' message\n// returned after a request.\ntype exitStatus struct {\n\tStatus uint32\n}\n\nfunc handleSession(ch ssh.Channel, in <-chan *ssh.Request, t *testing.T) {\n\tdefer ch.Close()\n\n\tfor req := range in {\n\t\tif req.WantReply {\n\t\t\treq.Reply(true, nil)\n\t\t}\n\n\t\t// TODO support the rest of the types e.g. env, pty, etc.\n\t\t// Right now they aren't necessary for the tests.\n\t\tif req.Type != \"exec\" {\n\t\t\tt.Logf(\"Unsupported session type %v, only 'exec' is supported\", req.Type)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar exReq execReq\n\t\terr := ssh.Unmarshal(req.Payload, &exReq)\n\t\tif err != nil {\n\t\t\tt.Logf(\"failed to unmarshal exec payload %s\", req.Payload)\n\t\t\treturn\n\t\t}\n\n\t\tcmd := exec.Command(\"sh\", \"-l\", \"-c\", exReq.Command)\n\n\t\tstdin, err := cmd.StdinPipe()\n\t\trequire.NoError(t, err)\n\n\t\tgo func() {\n\t\t\tdefer stdin.Close()\n\t\t\tio.Copy(stdin, ch)\n\t\t}()\n\n\t\tcmd.Stdout = ch\n\t\tcmd.Stderr = ch.Stderr()\n\t\terr = cmd.Run()\n\n\t\tvar exit exitStatus\n\t\tif err != nil {\n\t\t\texErr, ok := err.(*exec.ExitError)\n\t\t\trequire.True(t, ok, \"Not an exec.ExitError, was %T\", err)\n\n\t\t\texit.Status = uint32(exErr.ExitCode())\n\t\t}\n\n\t\t_, err = ch.SendRequest(\"exit-status\", false, ssh.Marshal(&exit))\n\t\tif err != nil {\n\t\t\tt.Logf(\"unable to send status: %v\", err)\n\t\t}\n\t\tbreak\n\t}\n}\n\nfunc waitForSSHCode(t *testing.T, port string, timeout time.Duration) {\n\tvar (\n\t\turl    = fmt.Sprintf(\"http://localhost:%v/\", port)\n\t\tclient = &http.Client{\n\t\t\tTimeout: time.Second,\n\t\t}\n\t)\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tbackoff := &retry.Backoff{\n\t\tFloor: time.Second,\n\t\tCeil:  time.Second,\n\t}\n\n\tfor {\n\t\tresp, err := client.Get(url)\n\t\tif err == nil {\n\t\t\trequire.Equal(t, http.StatusOK, resp.StatusCode)\n\t\t\treturn\n\t\t}\n\t\terr = backoff.Wait(ctx)\n\t\trequire.NoError(t, err)\n\t}\n}\n\n// fakeRSAKey isn't used for anything other than the trassh ssh\n// server.\nconst fakeRSAKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEAsbbGAxPQeqti2OgdzuMgJGBAwXe/bFhQTPuk0bIvavkZwX/a\nNhmXV0dhLino5KtjR8oEazLxOgnOkJ6mpwVEgUhNMZhD9jEHZ7at4DtBIwfxjHjv\nnF+kJAt4xX4AZYbwIfLN9TsDGGhv4wPlB7mbwv+lhmPK+HsLbajO4n69k3s0WW94\nLafJntx/98o9gL2R7hpbMxgUu8cSZjYakkRBQdab0xUuTiceq0HfAOBCQpEw0meF\ncmhMeeu7H5UwKGj573pBxON0G1SJgipkcs4TD2rZ9wjc29gDJjHjf3Ko/JzX1WFL\ndb21fzqRGWelgCHCUsIvUBeExk4jM1d63JrmFQIDAQABAoIBAQCdc9OSjG6tEMYe\naeFnGQK0V/dnskIOq1xSKK7J/7ZVb+iq8S0Tu67D7IEklos6dsMaqtkpZVQm2OOE\nbJw45MjiRn3mUAL+0EfAUzFQtw8qC3Kuw8N/55kVOnjBeba+PUTqvyZNfQBsErP3\nDc9Q/dkMdtZf8HC3oMTqXqMWN7adQBQRBspUBkLQeSemYsUm2cc+YSnCwKel98uN\nEuDJaTZwutxTUF1FBoXlejYlVKcldk1w5HtKkjGdW+mbo2xUpu8W0620Rs/fXNpU\n+guAlpB1/Wx5foZqZx33Ul8HINfDre/uqHwCd+ucDIyV7TfIh9JV5w3iRLa0QCz0\nkFe/GsEtAoGBAODRa1GwfyK+gcgxF2qwfsxF3I+DQhqWFiCA0o5kO2fpiUR3rDQj\nXhBoPxr/qYBSBtGErHIiB7WFeQ6GjVTEgY/cEkIIh1tY95UWQ3/oIZWW498dQGRh\nSUGXm3lMrSsVCyXxNexSH5yTrRzyZ2u4mZupMeyACoGRGkNTVppOU4XbAoGBAMpc\n1ifX3kr5m8CXa6mI+NWFAQlhW0Ak0hjhM/WDzMrSimYxLLSkaKyUSHnFP/8V4asA\ntV173lVut2Cjv5v5FcrOnI33Li2IcNlOzCRiLHzZ43HXckcoQDcU8iKTBq1a0Dx1\neXr2rs+a/2pTy7IMsxyJVCSP6IDBI9+2iW+Cxh7PAoGBAMOa0hJAS02yjX7d367v\nI1OeETo4jQJOxa/ABfLoGJvfoJQWv5iZkRUbbpSSDytbsx0Gn3eqTiTMnbhar4sq\nckP1yVj0zLhY3wkzVsVp9haOM3ODouvzjWZpf1d5tE2AwLNhfHZCOcjk4EEIU51w\n/w1ll89a1ElJM52SXA5jyd3zAoGBAKGtpKi2rvMGFKu+DxWnyu+FUXu2HhrUkEuy\nejn5MMEHj+3v8gDtrnfcDT/FGclrKR7f9QeYtN1bFQYQLkGmtAOSKcC/MVTNwyPL\n8gxLp7GkwDSvZq11ekDH6mE3SMluWhtD3Ggi+S4Db3f7NS6vONde3SxNEfz00v2l\nMI84U6Q/AoGAVTZGT5weqRTJSqnri6Noz+5j/73QMf/QiZDgHMMCF0giC2mxqOgR\nQF6+cxHQe0sbMQ/xJU5RYhgnqSa2TjLMju4N2nQ9i/HqI/3p0CPwjFsZWlXmWEK9\n5kdld52W7Bu2vQuFbg2Oy7aPhnI+1CqlubOFRgMe4AJND2t9SMTV+rc=\n-----END RSA PRIVATE KEY-----\n`\n\nfunc testSSHArgs(port string) string {\n\treturn \"-o StrictHostKeyChecking=no -p \" + port\n}\n\nfunc randomPortExclude(t *testing.T, exludedPorts ...string) string {\n\tvalid := func(port string) bool {\n\t\tfor _, exPort := range exludedPorts {\n\t\t\tif exPort == port {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tmaxTries := 10\n\tfor i := 0; i < maxTries; i++ {\n\t\tport, err := randomPort()\n\t\trequire.NoError(t, err)\n\n\t\tif valid(port) {\n\t\t\treturn port\n\t\t}\n\t}\n\n\treturn \"\"\n}\n"
        }
      ]
    }
  ]
}