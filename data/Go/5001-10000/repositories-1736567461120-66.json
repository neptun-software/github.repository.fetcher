{
  "metadata": {
    "timestamp": 1736567461120,
    "page": 66,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "a-h/templ",
      "stars": 8676,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.029296875,
          "content": ".git\nDockerfile\n.dockerignore\n"
        },
        {
          "name": ".envrc",
          "type": "blob",
          "size": 0.0087890625,
          "content": "use flake"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3271484375,
          "content": "# Output.\ncmd/templ/templ\n\n# Logs.\ncmd/templ/lspcmd/*log.txt\n\n# Go code coverage.\ncoverage.out\ncoverage\n\n# Mac filesystem jank.\n.DS_Store\n\n# Docusaurus.\ndocs/build/\ndocs/resources/_gen/\nnode_modules/\ndist/\n\n# Nix artifacts.\nresult\n\n# Editors\n## nvim\n.null-ls*\n\n# Go workspace.\ngo.work\n\n# direnv\n.direnv\n\n# templ txt files.\n*_templ.txt\n"
        },
        {
          "name": ".goreleaser.yaml",
          "type": "blob",
          "size": 1.2685546875,
          "content": "builds:\n  - env:\n      - CGO_ENABLED=0\n    dir: cmd/templ\n    mod_timestamp: '{{ .CommitTimestamp }}'\n    flags:\n      - -trimpath\n    ldflags:\n      - -s -w\n    goos:\n      - linux\n      - windows\n      - darwin\n\nchecksum:\n  name_template: 'checksums.txt'\n\nsigns:\n  - id: checksums\n    cmd: cosign\n    stdin: '{{ .Env.COSIGN_PASSWORD }}'\n    output: true\n    artifacts: checksum\n    args:\n      - sign-blob\n      - --yes\n      - --key\n      - env://COSIGN_PRIVATE_KEY\n      - '--output-certificate=${certificate}'\n      - '--output-signature=${signature}'\n      - '${artifact}'\n\narchives:\n  - format: tar.gz\n    name_template: >-\n      {{ .ProjectName }}_\n      {{- title .Os }}_\n      {{- if eq .Arch \"amd64\" }}x86_64\n      {{- else if eq .Arch \"386\" }}i386\n      {{- else }}{{ .Arch }}{{ end }}\n      {{- if .Arm }}v{{ .Arm }}{{ end }}\n\nkos:\n  - repository: ghcr.io/a-h/templ\n    platforms:\n    - linux/amd64\n    - linux/arm64\n    tags:\n    - latest\n    - '{{.Tag}}'\n    bare: true\n\ndocker_signs:\n  - cmd: cosign\n    artifacts: all\n    output: true\n    args:\n      - sign\n      - --yes\n      - --key\n      - env://COSIGN_PRIVATE_KEY\n      - '${artifact}'\n\nsnapshot:\n  name_template: \"{{ incpatch .Version }}-next\"\n\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n      - '^docs:'\n      - '^test:'\n"
        },
        {
          "name": ".ignore",
          "type": "blob",
          "size": 0.2431640625,
          "content": "*_templ.go\nexamples/integration-ct/static/index.js\nexamples/counter/assets/css/bulma.*\nexamples/counter/assets/js/htmx.min.js\nexamples/counter-basic/assets/css/bulma.*\nexamples/typescript/assets/index.js\npackage-lock.json\ngo.sum\ndocs/static/llms.md\n"
        },
        {
          "name": ".version",
          "type": "blob",
          "size": 0.0068359375,
          "content": "0.3.822"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.1044921875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nadrianhesketh@hushail.com.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 7.5986328125,
          "content": "# Contributing to templ\n\n## Vision\n\nEnable Go developers to build strongly typed, component-based HTML user interfaces with first-class developer tooling, and a short learning curve.\n\n## Come up with a design and share it\n\nBefore starting work on any major pull requests or code changes, start a discussion at https://github.com/a-h/templ/discussions or raise an issue.\n\nWe don't want you to spend time on a PR or feature that ultimately doesn't get merged because it doesn't fit with the project goals, or the design doesn't work for some reason.\n\nFor issues, it really helps if you provide a reproduction repo, or can create a failing unit test to describe the behaviour.\n\nIn designs, we need to consider:\n\n* Backwards compatibility - Not changing the public API between releases, introducing gradual deprecation - don't break people's code.\n* Correctness over time - How can we reduce the risk of defects both now, and in future releases?\n* Threat model - How could each change be used to inject vulnerabilities into web pages?\n* Go version - We target the oldest supported version of Go as per https://go.dev/doc/devel/release\n* Automatic migration - If we need to force through a change.\n* Compile time vs runtime errors - Prefer compile time.\n* Documentation - New features are only useful if people can understand the new feature, what would the documentation look like?\n* Examples - How will we demonstrate the feature?\n\n## Project structure\n\ntempl is structured into a few areas:\n\n### Parser `./parser`\n\nThe parser directory currently contains both v1 and v2 parsers.\n\nThe v1 parser is not maintained, it's only used to migrate v1 code over to the v2 syntax.\n\nThe parser is responsible for parsing templ files into an object model. The types that make up the object model are in `types.go`. Automatic formatting of the types is tested in `types_test.go`.\n\nA templ file is parsed into the `TemplateFile` struct object model.\n\n```go\ntype TemplateFile struct {\n\t// Header contains comments or whitespace at the top of the file.\n\tHeader []GoExpression\n\t// Package expression.\n\tPackage Package\n\t// Nodes in the file.\n\tNodes []TemplateFileNode\n}\n```\n\nParsers are individually tested using two types of unit test.\n\nOne test covers the successful parsing of text into an object. For example, the `HTMLCommentParser` test checks for successful patterns.\n\n```go\nfunc TestHTMLCommentParser(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected HTMLComment\n\t}{\n\t\t{\n\t\t\tname:  \"comment - single line\",\n\t\t\tinput: `<!-- single line comment -->`,\n\t\t\texpected: HTMLComment{\n\t\t\t\tContents: \" single line comment \",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"comment - no whitespace\",\n\t\t\tinput: `<!--no whitespace between sequence open and close-->`,\n\t\t\texpected: HTMLComment{\n\t\t\t\tContents: \"no whitespace between sequence open and close\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"comment - multiline\",\n\t\t\tinput: `<!-- multiline\n\t\t\t\t\t\t\t\tcomment\n\t\t\t\t\t-->`,\n\t\t\texpected: HTMLComment{\n\t\t\t\tContents: ` multiline\n\t\t\t\t\t\t\t\tcomment\n\t\t\t\t\t`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"comment - with tag\",\n\t\t\tinput: `<!-- <p class=\"test\">tag</p> -->`,\n\t\t\texpected: HTMLComment{\n\t\t\t\tContents: ` <p class=\"test\">tag</p> `,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"comments can contain tags\",\n\t\t\tinput: `<!-- <div> hello world </div> -->`,\n\t\t\texpected: HTMLComment{\n\t\t\t\tContents: ` <div> hello world </div> `,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinput := parse.NewInput(tt.input)\n\t\t\tresult, ok, err := htmlComment.Parse(input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parser error: %v\", err)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to parse at %d\", input.Index())\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expected, result); diff != \"\" {\n\t\t\t\tt.Errorf(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n```\n\nAlongside each success test, is a similar test to check that invalid syntax is detected.\n\n```go\nfunc TestHTMLCommentParserErrors(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected error\n\t}{\n\t\t{\n\t\t\tname:  \"unclosed HTML comment\",\n\t\t\tinput: `<!-- unclosed HTML comment`,\n\t\t\texpected: parse.Error(\"expected end comment literal '-->' not found\",\n\t\t\t\tparse.Position{\n\t\t\t\t\tIndex: 26,\n\t\t\t\t\tLine:  0,\n\t\t\t\t\tCol:   26,\n\t\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname:  \"comment in comment\",\n\t\t\tinput: `<!-- <-- other --> -->`,\n\t\t\texpected: parse.Error(\"comment contains invalid sequence '--'\", parse.Position{\n\t\t\t\tIndex: 8,\n\t\t\t\tLine:  0,\n\t\t\t\tCol:   8,\n\t\t\t}),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinput := parse.NewInput(tt.input)\n\t\t\t_, _, err := htmlComment.Parse(input)\n\t\t\tif diff := cmp.Diff(tt.expected, err); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n```\n\n### Generator\n\nThe generator takes the object model and writes out Go code that produces the expected output. Any changes to Go code output by templ are made in this area.\n\nTesting of the generator is carried out by creating a templ file, and a matching expected output file.\n\nFor example, `./generator/test-a-href` contains a templ file of:\n\n```templ\npackage testahref\n\ntempl render() {\n\t<a href=\"javascript:alert(&#39;unaffected&#39;);\">Ignored</a>\n\t<a href={ templ.URL(\"javascript:alert('should be sanitized')\") }>Sanitized</a>\n\t<a href={ templ.SafeURL(\"javascript:alert('should not be sanitized')\") }>Unsanitized</a>\n}\n```\n\nIt also contains an expected output file.\n\n```html\n<a href=\"javascript:alert(&#39;unaffected&#39;);\">Ignored</a>\n<a href=\"about:invalid#TemplFailedSanitizationURL\">Sanitized</a>\n<a href=\"javascript:alert(&#39;should not be sanitized&#39;)\">Unsanitized</a>\n```\n\nThese tests contribute towards the code coverage metrics by building an instrumented test CLI program. See the `test-cover` task in the `README.md` file.\n\n### CLI\n\nThe command line interface for templ is used to generate Go code from templ files, format templ files, and run the LSP.\n\nThe code for this is at `./cmd/templ`.\n\nTesting of the templ command line is done with unit tests to check the argument parsing.\n\nThe `templ generate` command is tested by generating templ files in the project, and testing that the expected output HTML is present.\n\n### Runtime\n\nThe runtime is used by generated code, and by template authors, to serve template content over HTTP, and to carry out various operations.\n\nIt is in the root directory of the project at `./runtime.go`. The runtime is unit tested, as well as being tested as part of the `generate` tests.\n\n### LSP\n\nThe LSP is structured within the command line interface, and proxies commands through to the `gopls` LSP.\n\n### Docs\n\nThe docs are a Docusaurus project at `./docs`.\n\n## Coding\n\n### Build tasks\n\ntempl uses the `xc` task runner - https://github.com/joerdav/xc\n\nIf you run `xc` you can get see a list of the development tasks that can be run, or you can read the `README.md` file and see the `Tasks` section.\n\nThe most useful tasks for local development are:\n\n* `install-snapshot` - this builds the templ CLI and installs it into `~/bin`. Ensure that this is in your path.\n* `test` - this regenerates all templates, and runs the unit tests.\n* `fmt` - run the `gofmt` tool to format all Go code.\n* `lint` - run the same linting as run in the CI process.\n* `docs-run` - run the Docusaurus documentation site.\n\n### Commit messages\n\nThe project using https://www.conventionalcommits.org/en/v1.0.0/\n\nExamples:\n\n* `feat: support Go comments in templates, fixes #234\"`\n\n### Coding style\n\n* Reduce nesting - i.e. prefer early returns over an `else` block, as per https://danp.net/posts/reducing-go-nesting/ or https://go.dev/doc/effective_go#if\n* Use line breaks to separate \"paragraphs\" of code - don't use line breaks in between lines, or at the start/end of functions etc.\n* Use the `fmt` and `lint` build tasks to format and lint your code before submitting a PR.\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2021 Adrian Hesketh\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6015625,
          "content": "![templ](https://github.com/a-h/templ/raw/main/templ.png)\n\n## An HTML templating language for Go that has great developer tooling.\n\n![templ](ide-demo.gif)\n\n\n## Documentation\n\nSee user documentation at https://templ.guide\n\n<p align=\"center\">\n<a href=\"https://pkg.go.dev/github.com/a-h/templ\"><img src=\"https://pkg.go.dev/badge/github.com/a-h/templ.svg\" alt=\"Go Reference\" /></a>\n<a href=\"https://xcfile.dev\"><img src=\"https://xcfile.dev/badge.svg\" alt=\"xc compatible\" /></a>\n<a href=\"https://raw.githack.com/wiki/a-h/templ/coverage.html\"><img src=\"https://github.com/a-h/templ/wiki/coverage.svg\" alt=\"Go Coverage\" /></a>\n<a href=\"https://goreportcard.com/report/github.com/a-h/templ\"><img src=\"https://goreportcard.com/badge/github.com/a-h/templ\" alt=\"Go Report Card\" /></a>\n</p>\n\n## Tasks\n\n### build\n\nBuild a local version.\n\n```sh\ngo run ./get-version > .version\ncd cmd/templ\ngo build\n```\n\n### install-snapshot\n\nBuild and install current version.\n\n```sh\n# Remove templ from the non-standard ~/bin/templ path\n# that this command previously used.\nrm -f ~/bin/templ\n# Clear LSP logs.\nrm -f cmd/templ/lspcmd/*.txt\n# Update version.\ngo run ./get-version > .version\n# Install to $GOPATH/bin or $HOME/go/bin\ncd cmd/templ && go install\n```\n\n### build-snapshot\n\nUse goreleaser to build the command line binary using goreleaser.\n\n```sh\ngoreleaser build --snapshot --clean\n```\n\n### generate\n\nRun templ generate using local version.\n\n```sh\ngo run ./cmd/templ generate -include-version=false\n```\n\n### test\n\nRun Go tests.\n\n```sh\ngo run ./get-version > .version\ngo run ./cmd/templ generate -include-version=false\ngo test ./...\n```\n\n### test-short\n\nRun Go tests.\n\n```sh\ngo run ./get-version > .version\ngo run ./cmd/templ generate -include-version=false\ngo test ./... -short\n```\n\n### test-cover\n\nRun Go tests.\n\n```sh\n# Create test profile directories.\nmkdir -p coverage/fmt\nmkdir -p coverage/generate\nmkdir -p coverage/version\nmkdir -p coverage/unit\n# Build the test binary.\ngo build -cover -o ./coverage/templ-cover ./cmd/templ\n# Run the covered generate command.\nGOCOVERDIR=coverage/fmt ./coverage/templ-cover fmt .\nGOCOVERDIR=coverage/generate ./coverage/templ-cover generate -include-version=false\nGOCOVERDIR=coverage/version ./coverage/templ-cover version\n# Run the unit tests.\ngo test -cover ./... -coverpkg ./... -args -test.gocoverdir=\"$PWD/coverage/unit\"\n# Display the combined percentage.\ngo tool covdata percent -i=./coverage/fmt,./coverage/generate,./coverage/version,./coverage/unit\n# Generate a text coverage profile for tooling to use.\ngo tool covdata textfmt -i=./coverage/fmt,./coverage/generate,./coverage/version,./coverage/unit -o coverage.out\n# Print total\ngo tool cover -func coverage.out | grep total\n```\n\n### test-cover-watch\n\n```sh\ngotestsum --watch -- -coverprofile=coverage.out\n```\n\n### test-fuzz\n\n```sh\n./parser/v2/fuzz.sh\n./parser/v2/goexpression/fuzz.sh\n```\n\n### benchmark\n\nRun benchmarks.\n\n```sh\ngo run ./cmd/templ generate -include-version=false && go test ./... -bench=. -benchmem\n```\n\n### fmt\n\nFormat all Go and templ code.\n\n```sh\ngofmt -s -w .\ngo run ./cmd/templ fmt .\n```\n\n### lint\n\nRun the lint operations that are run as part of the CI.\n\n```sh\ngolangci-lint run --verbose\n```\n\n### ensure-generated\n\nEnsure that templ files have been generated with the local version of templ, and that those files have been added to git.\n\nRequires: generate\n\n```sh\ngit diff --exit-code\n```\n\n### push-release-tag\n\nPush a semantic version number to Github to trigger the release process.\n\n```sh\n./push-tag.sh\n```\n\n### docs-run\n\nRun the development server.\n\nDirectory: docs\n\n```sh\nnpm run start\n```\n\n### docs-build\n\nBuild production docs site.\n\nDirectory: docs\n\n```sh\nnpm run build\n```\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.19140625,
          "content": "# Security Policy\n\n## Supported Versions\n\nThe latest version of templ is supported.\n\n## Reporting a Vulnerability\n\nUse the \"Security\" tab in Github and fill out the \"Report a vulnerability\" form.\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "cfg",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "cosign.pub",
          "type": "blob",
          "size": 0.173828125,
          "content": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEqHp75uAj8XqKrLO2YvY0M2EddckH\nevQnNAj+0GmBptqdf3NJcUCjL6w4z2Ikh/Zb8lh6b13akAwO/dJQaMLoMA==\n-----END PUBLIC KEY-----\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 2.4892578125,
          "content": "{\n  \"nodes\": {\n    \"flake-utils\": {\n      \"locked\": {\n        \"lastModified\": 1667395993,\n        \"narHash\": \"sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"5aed5285a952e0b949eb3ba02c12fa4fcfef535f\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"gitignore\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1709087332,\n        \"narHash\": \"sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"rev\": \"637db329424fd7e46cf4185293b9cc8c88c95394\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1735412871,\n        \"narHash\": \"sha256-Qoz0ow6jDGUIBHxduc7Y1cjYFS71tvEGJV5Src/mj98=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9f94733f93e4fe6e82f516efae007096e4ab5a21\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-24.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-unstable\": {\n      \"locked\": {\n        \"lastModified\": 1735471104,\n        \"narHash\": \"sha256-0q9NGQySwDQc7RhAV2ukfnu7Gxa5/ybJ2ANT8DQrQrs=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"88195a94f390381c6afcdaa933c2f6ff93959cb4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"gitignore\": \"gitignore\",\n        \"nixpkgs\": \"nixpkgs\",\n        \"nixpkgs-unstable\": \"nixpkgs-unstable\",\n        \"xc\": \"xc\"\n      }\n    },\n    \"xc\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils\",\n        \"nixpkgs\": [\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1724404748,\n        \"narHash\": \"sha256-p6rXzNiDm2uBvO1MLzC5pJp/0zRNzj/snBzZI0ce62s=\",\n        \"owner\": \"joerdav\",\n        \"repo\": \"xc\",\n        \"rev\": \"960ff9f109d47a19122cfb015721a76e3a0f23a2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"joerdav\",\n        \"repo\": \"xc\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 2.48046875,
          "content": "{\n  description = \"templ\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-24.11\";\n    nixpkgs-unstable.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    gitignore = {\n      url = \"github:hercules-ci/gitignore.nix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n    xc = {\n      url = \"github:joerdav/xc\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = { self, nixpkgs, nixpkgs-unstable, gitignore, xc }:\n    let\n      allSystems = [\n        \"x86_64-linux\" # 64-bit Intel/AMD Linux\n        \"aarch64-linux\" # 64-bit ARM Linux\n        \"x86_64-darwin\" # 64-bit Intel macOS\n        \"aarch64-darwin\" # 64-bit ARM macOS\n      ];\n      forAllSystems = f: nixpkgs.lib.genAttrs allSystems (system: f {\n        inherit system;\n        pkgs = import nixpkgs { inherit system; };\n        pkgs-unstable = import nixpkgs-unstable { inherit system; };\n      });\n    in\n    {\n      packages = forAllSystems ({ system, pkgs, ... }:\n        rec {\n          default = templ;\n\n          templ = pkgs.buildGo123Module {\n            name = \"templ\";\n            subPackages = [ \"cmd/templ\" ];\n            src = gitignore.lib.gitignoreSource ./.;\n            vendorHash = \"sha256-ipLn52MsgX7KQOJixYcwMR9TCeHz55kQQ7fgkIgnu7w=\";\n            CGO_ENABLED = 0;\n            flags = [\n              \"-trimpath\"\n            ];\n            ldflags = [\n              \"-s\"\n              \"-w\"\n              \"-extldflags -static\"\n            ];\n          };\n        });\n\n      # `nix develop` provides a shell containing development tools.\n      devShell = forAllSystems ({ system, pkgs, pkgs-unstable, ... }:\n        pkgs.mkShell {\n          buildInputs = [\n            pkgs.golangci-lint\n            pkgs.cosign # Used to sign container images.\n            pkgs.esbuild # Used to package JS examples.\n            pkgs.go\n            pkgs-unstable.gopls\n            pkgs.goreleaser\n            pkgs.gotestsum\n            pkgs.ko # Used to build Docker images.\n            pkgs.nodejs # Used to build templ-docs.\n            xc.packages.${system}.xc\n          ];\n        });\n\n      # This flake outputs an overlay that can be used to add templ and\n      # templ-docs to nixpkgs as per https://templ.guide/quick-start/installation/#nix\n      #\n      # Example usage:\n      #\n      # nixpkgs.overlays = [\n      #   inputs.templ.overlays.default\n      # ];\n      overlays.default = final: prev: {\n        templ = self.packages.${final.stdenv.system}.templ;\n        templ-docs = self.packages.${final.stdenv.system}.templ-docs;\n      };\n    };\n}\n\n"
        },
        {
          "name": "flush.go",
          "type": "blob",
          "size": 0.5625,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"io\"\n)\n\n// Flush flushes the output buffer after all its child components have been rendered.\nfunc Flush() FlushComponent {\n\treturn FlushComponent{}\n}\n\ntype FlushComponent struct {\n}\n\ntype flusherError interface {\n\tFlush() error\n}\n\ntype flusher interface {\n\tFlush()\n}\n\nfunc (f FlushComponent) Render(ctx context.Context, w io.Writer) (err error) {\n\tif err = GetChildren(ctx).Render(ctx, w); err != nil {\n\t\treturn err\n\t}\n\tswitch w := w.(type) {\n\tcase flusher:\n\t\tw.Flush()\n\t\treturn nil\n\tcase flusherError:\n\t\treturn w.Flush()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "flush_test.go",
          "type": "blob",
          "size": 3.0263671875,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype flushableErrorWriter struct {\n\tlastFlushPos    int\n\tpos             int\n\tsb              strings.Builder\n\tflushedSections []string\n}\n\nfunc (f *flushableErrorWriter) Write(p []byte) (n int, err error) {\n\tn, err = f.sb.Write(p)\n\tif err != nil {\n\t\treturn\n\t}\n\tif n < len(p) {\n\t\terr = io.ErrShortWrite\n\t}\n\tf.pos += n\n\treturn\n}\n\nfunc (f *flushableErrorWriter) Flush() error {\n\tf.flushedSections = append(f.flushedSections, f.sb.String()[f.lastFlushPos:f.pos])\n\tf.lastFlushPos = f.pos\n\treturn nil\n}\n\ntype flushableWriter struct {\n\tlastFlushPos    int\n\tpos             int\n\tsb              strings.Builder\n\tflushedSections []string\n}\n\nfunc (f *flushableWriter) Write(p []byte) (n int, err error) {\n\tn, err = f.sb.Write(p)\n\tif err != nil {\n\t\treturn\n\t}\n\tif n < len(p) {\n\t\terr = io.ErrShortWrite\n\t}\n\tf.pos += n\n\treturn\n}\n\nfunc (f *flushableWriter) Flush() {\n\tf.flushedSections = append(f.flushedSections, f.sb.String()[f.lastFlushPos:f.pos])\n\tf.lastFlushPos = f.pos\n}\n\nfunc TestFlush(t *testing.T) {\n\tt.Run(\"errors in child components are propagated\", func(t *testing.T) {\n\t\texpectedErr := fmt.Errorf(\"test error\")\n\t\tchild := ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\t\treturn expectedErr\n\t\t})\n\n\t\tsb := new(strings.Builder)\n\t\tctx := WithChildren(context.Background(), child)\n\n\t\terr := Flush().Render(ctx, sb)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expected an error, got nil\")\n\t\t}\n\t\tif err != expectedErr {\n\t\t\tt.Fatalf(\"expected error to be %v, got %v\", expectedErr, err)\n\t\t}\n\t})\n\tt.Run(\"can render to a flushable error writer\", func(t *testing.T) {\n\t\tchild := ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\t\t_, err := w.Write([]byte(\"hello\"))\n\t\t\treturn err\n\t\t})\n\n\t\tb := &flushableErrorWriter{}\n\t\tctx := WithChildren(context.Background(), child)\n\n\t\t// Render the FlushComponent to the buffer\n\t\tif err := Flush().Render(ctx, b); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\n\t\tif len(b.flushedSections) != 1 {\n\t\t\tt.Fatalf(\"expected 1 flushed section, got %d\", len(b.flushedSections))\n\t\t}\n\t\tif b.flushedSections[0] != \"hello\" {\n\t\t\tt.Fatalf(\"expected flushed section to be 'hello', got %q\", b.flushedSections[0])\n\t\t}\n\t})\n\tt.Run(\"can render to a flushable writer\", func(t *testing.T) {\n\t\tchild := ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\t\t_, err := w.Write([]byte(\"hello\"))\n\t\t\treturn err\n\t\t})\n\n\t\tb := &flushableWriter{}\n\t\tctx := WithChildren(context.Background(), child)\n\n\t\t// Render the FlushComponent to the buffer\n\t\tif err := Flush().Render(ctx, b); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\n\t\tif len(b.flushedSections) != 1 {\n\t\t\tt.Fatalf(\"expected 1 flushed section, got %d\", len(b.flushedSections))\n\t\t}\n\t\tif b.flushedSections[0] != \"hello\" {\n\t\t\tt.Fatalf(\"expected flushed section to be 'hello', got %q\", b.flushedSections[0])\n\t\t}\n\t})\n\tt.Run(\"non-flushable streams are a no-op\", func(t *testing.T) {\n\t\tsb := new(strings.Builder)\n\t\tif err := Flush().Render(context.Background(), sb); err != nil {\n\t\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "generator",
          "type": "tree",
          "content": null
        },
        {
          "name": "get-version",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.32421875,
          "content": "module github.com/a-h/templ\n\ngo 1.23\n\ntoolchain go1.23.3\n\nrequire (\n\tgithub.com/PuerkitoBio/goquery v1.10.1\n\tgithub.com/a-h/htmlformat v0.0.0-20231108124658-5bd994fe268e\n\tgithub.com/a-h/parse v0.0.0-20240121214402-3caf7543159a\n\tgithub.com/a-h/protocol v0.0.0-20240704131721-1e461c188041\n\tgithub.com/andybalholm/brotli v1.1.0\n\tgithub.com/cenkalti/backoff/v4 v4.3.0\n\tgithub.com/cli/browser v1.3.0\n\tgithub.com/fatih/color v1.16.0\n\tgithub.com/fsnotify/fsnotify v1.7.0\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/natefinch/atomic v1.0.1\n\tgithub.com/rs/cors v1.11.0\n\tgo.lsp.dev/jsonrpc2 v0.10.0\n\tgo.lsp.dev/uri v0.3.0\n\tgo.uber.org/zap v1.27.0\n\tgolang.org/x/mod v0.20.0\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/tools v0.24.0\n)\n\nrequire (\n\tgithub.com/andybalholm/cascadia v1.3.3 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/segmentio/asm v1.2.0 // indirect\n\tgithub.com/segmentio/encoding v0.4.0 // indirect\n\tgithub.com/stretchr/testify v1.8.4 // indirect\n\tgo.lsp.dev/pkg v0.0.0-20210717090340-384b27a52fb2 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n)\n\n// replace github.com/a-h/parse => /Users/adrian/github.com/a-h/parse\n// replace github.com/a-h/protocol => /Users/adrian/github.com/a-h/protocol\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 11.18359375,
          "content": "github.com/PuerkitoBio/goquery v1.10.1 h1:Y8JGYUkXWTGRB6Ars3+j3kN0xg1YqqlwvdTV8WTFQcU=\ngithub.com/PuerkitoBio/goquery v1.10.1/go.mod h1:IYiHrOMps66ag56LEH7QYDDupKXyo5A8qrjIx3ZtujY=\ngithub.com/a-h/htmlformat v0.0.0-20231108124658-5bd994fe268e h1:Eog54DQpku7NpPNff9wzQYT61TGu9jjq5N8UhAkqIgw=\ngithub.com/a-h/htmlformat v0.0.0-20231108124658-5bd994fe268e/go.mod h1:FMIm5afKmEfarNbIXOaPHFY8X7fo+fRQB6I9MPG2nB0=\ngithub.com/a-h/parse v0.0.0-20240121214402-3caf7543159a h1:vlmAfVwFK9sRpDlJyuHY8htP+KfGHB2VH02u0SoIufk=\ngithub.com/a-h/parse v0.0.0-20240121214402-3caf7543159a/go.mod h1:3mnrkvGpurZ4ZrTDbYU84xhwXW2TjTKShSwjRi2ihfQ=\ngithub.com/a-h/protocol v0.0.0-20240704131721-1e461c188041 h1:2enlC41iOwWklx9ZUqpQygsNAG6KIm3uMMUXzBJw5jA=\ngithub.com/a-h/protocol v0.0.0-20240704131721-1e461c188041/go.mod h1:Gm0KywveHnkiIhqFSMZglXwWZRQICg3KDWLYdglv/d8=\ngithub.com/andybalholm/brotli v1.1.0 h1:eLKJA0d02Lf0mVpIDgYnqXcUn0GqVmEFny3VuID1U3M=\ngithub.com/andybalholm/brotli v1.1.0/go.mod h1:sms7XGricyQI9K10gOSf56VKKWS4oLer58Q+mhRPtnY=\ngithub.com/andybalholm/cascadia v1.3.3 h1:AG2YHrzJIm4BZ19iwJ/DAua6Btl3IwJX+VI4kktS1LM=\ngithub.com/andybalholm/cascadia v1.3.3/go.mod h1:xNd9bqTn98Ln4DwST8/nG+H0yuB8Hmgu1YHNnWw0GeA=\ngithub.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=\ngithub.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=\ngithub.com/cli/browser v1.3.0 h1:LejqCrpWr+1pRqmEPDGnTZOjsMe7sehifLynZJuqJpo=\ngithub.com/cli/browser v1.3.0/go.mod h1:HH8s+fOAxjhQoBUAsKuPCbqUuxZDhQ2/aD+SzsEfBTk=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=\ngithub.com/fatih/color v1.16.0/go.mod h1:fL2Sau1YI5c0pdGEVCbKQbLXB6edEj1ZgiY4NijnWvE=\ngithub.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nosvA=\ngithub.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/natefinch/atomic v1.0.1 h1:ZPYKxkqQOx3KZ+RsbnP/YsgvxWQPGxjC0oBt2AhwV0A=\ngithub.com/natefinch/atomic v1.0.1/go.mod h1:N/D/ELrljoqDyT3rZrsUmtsuzvHkeB/wWjHV22AZRbM=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rs/cors v1.11.0 h1:0B9GE/r9Bc2UxRMMtymBkHTenPkHDv0CW4Y98GBY+po=\ngithub.com/rs/cors v1.11.0/go.mod h1:XyqrcTp5zjWr1wsJ8PIRZssZ8b/WMcMf71DJnit4EMU=\ngithub.com/segmentio/asm v1.2.0 h1:9BQrFxC+YOHJlTlHGkTrFWf59nbL3XnCoFLTwDCI7ys=\ngithub.com/segmentio/asm v1.2.0/go.mod h1:BqMnlJP91P8d+4ibuonYZw9mfnzI9HfxselHZr5aAcs=\ngithub.com/segmentio/encoding v0.4.0 h1:MEBYvRqiUB2nfR2criEXWqwdY6HJOUrCn5hboVOVmy8=\ngithub.com/segmentio/encoding v0.4.0/go.mod h1:/d03Cd8PoaDeceuhUUUQWjU0KhWjrmYrWPgtJHYZSnI=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngo.lsp.dev/jsonrpc2 v0.10.0 h1:Pr/YcXJoEOTMc/b6OTmcR1DPJ3mSWl/SWiU1Cct6VmI=\ngo.lsp.dev/jsonrpc2 v0.10.0/go.mod h1:fmEzIdXPi/rf6d4uFcayi8HpFP1nBF99ERP1htC72Ac=\ngo.lsp.dev/pkg v0.0.0-20210717090340-384b27a52fb2 h1:hCzQgh6UcwbKgNSRurYWSqh8MufqRRPODRBblutn4TE=\ngo.lsp.dev/pkg v0.0.0-20210717090340-384b27a52fb2/go.mod h1:gtSHRuYfbCT0qnbLnovpie/WEmqyJ7T4n6VXiFMBtcw=\ngo.lsp.dev/uri v0.3.0 h1:KcZJmh6nFIBeJzTugn5JTU6OOyG0lDOo3R9KwTxTYbo=\ngo.lsp.dev/uri v0.3.0/go.mod h1:P5sbO1IQR+qySTWOCnhnK7phBx+W3zbLqSMDJNTw88I=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.20.0 h1:utOm6MM3R3dnawAiJgn0y+xvuYRsm1RKM/4giyfDgV0=\ngolang.org/x/mod v0.20.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/tools v0.24.0 h1:J1shsA93PJUEVaUSaay7UXAyE8aimq3GW0pjlolpa24=\ngolang.org/x/tools v0.24.0/go.mod h1:YhNqVBIfWHdzvTLs0d8LCuMhkKUgSUKldakyV7W/WDQ=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "handler.go",
          "type": "blob",
          "size": 2.9091796875,
          "content": "package templ\n\nimport \"net/http\"\n\n// ComponentHandler is a http.Handler that renders components.\ntype ComponentHandler struct {\n\tComponent      Component\n\tStatus         int\n\tContentType    string\n\tErrorHandler   func(r *http.Request, err error) http.Handler\n\tStreamResponse bool\n}\n\nconst componentHandlerErrorMessage = \"templ: failed to render template\"\n\nfunc (ch *ComponentHandler) ServeHTTPBuffered(w http.ResponseWriter, r *http.Request) {\n\t// Since the component may error, write to a buffer first.\n\t// This prevents partial responses from being written to the client.\n\tbuf := GetBuffer()\n\tdefer ReleaseBuffer(buf)\n\terr := ch.Component.Render(r.Context(), buf)\n\tif err != nil {\n\t\tif ch.ErrorHandler != nil {\n\t\t\tw.Header().Set(\"Content-Type\", ch.ContentType)\n\t\t\tch.ErrorHandler(r, err).ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, componentHandlerErrorMessage, http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", ch.ContentType)\n\tif ch.Status != 0 {\n\t\tw.WriteHeader(ch.Status)\n\t}\n\t// Ignore write error like http.Error() does, because there is\n\t// no way to recover at this point.\n\t_, _ = w.Write(buf.Bytes())\n}\n\nfunc (ch *ComponentHandler) ServeHTTPStreamed(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", ch.ContentType)\n\tif ch.Status != 0 {\n\t\tw.WriteHeader(ch.Status)\n\t}\n\tif err := ch.Component.Render(r.Context(), w); err != nil {\n\t\tif ch.ErrorHandler != nil {\n\t\t\tw.Header().Set(\"Content-Type\", ch.ContentType)\n\t\t\tch.ErrorHandler(r, err).ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, componentHandlerErrorMessage, http.StatusInternalServerError)\n\t}\n}\n\n// ServeHTTP implements the http.Handler interface.\nfunc (ch ComponentHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif ch.StreamResponse {\n\t\tch.ServeHTTPStreamed(w, r)\n\t\treturn\n\t}\n\tch.ServeHTTPBuffered(w, r)\n}\n\n// Handler creates a http.Handler that renders the template.\nfunc Handler(c Component, options ...func(*ComponentHandler)) *ComponentHandler {\n\tch := &ComponentHandler{\n\t\tComponent:   c,\n\t\tContentType: \"text/html; charset=utf-8\",\n\t}\n\tfor _, o := range options {\n\t\to(ch)\n\t}\n\treturn ch\n}\n\n// WithStatus sets the HTTP status code returned by the ComponentHandler.\nfunc WithStatus(status int) func(*ComponentHandler) {\n\treturn func(ch *ComponentHandler) {\n\t\tch.Status = status\n\t}\n}\n\n// WithContentType sets the Content-Type header returned by the ComponentHandler.\nfunc WithContentType(contentType string) func(*ComponentHandler) {\n\treturn func(ch *ComponentHandler) {\n\t\tch.ContentType = contentType\n\t}\n}\n\n// WithErrorHandler sets the error handler used if rendering fails.\nfunc WithErrorHandler(eh func(r *http.Request, err error) http.Handler) func(*ComponentHandler) {\n\treturn func(ch *ComponentHandler) {\n\t\tch.ErrorHandler = eh\n\t}\n}\n\n// WithStreaming sets the ComponentHandler to stream the response instead of buffering it.\nfunc WithStreaming() func(*ComponentHandler) {\n\treturn func(ch *ComponentHandler) {\n\t\tch.StreamResponse = true\n\t}\n}\n"
        },
        {
          "name": "handler_test.go",
          "type": "blob",
          "size": 6.8984375,
          "content": "package templ_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestHandler(t *testing.T) {\n\thello := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\tif _, err := io.WriteString(w, \"Hello\"); err != nil {\n\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n\terrorComponent := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\tif _, err := io.WriteString(w, \"Hello\"); err != nil {\n\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t}\n\t\treturn errors.New(\"handler error\")\n\t})\n\n\ttests := []struct {\n\t\tname             string\n\t\tinput            *templ.ComponentHandler\n\t\texpectedStatus   int\n\t\texpectedMIMEType string\n\t\texpectedBody     string\n\t}{\n\t\t{\n\t\t\tname:             \"handlers return OK by default\",\n\t\t\tinput:            templ.Handler(hello),\n\t\t\texpectedStatus:   http.StatusOK,\n\t\t\texpectedMIMEType: \"text/html; charset=utf-8\",\n\t\t\texpectedBody:     \"Hello\",\n\t\t},\n\t\t{\n\t\t\tname:             \"handlers return OK by default\",\n\t\t\tinput:            templ.Handler(templ.Raw(`♠ ‘ &spades; &#8216;`)),\n\t\t\texpectedStatus:   http.StatusOK,\n\t\t\texpectedMIMEType: \"text/html; charset=utf-8\",\n\t\t\texpectedBody:     \"♠ ‘ &spades; &#8216;\",\n\t\t},\n\t\t{\n\t\t\tname:             \"handlers can be configured to return an alternative status code\",\n\t\t\tinput:            templ.Handler(hello, templ.WithStatus(http.StatusNotFound)),\n\t\t\texpectedStatus:   http.StatusNotFound,\n\t\t\texpectedMIMEType: \"text/html; charset=utf-8\",\n\t\t\texpectedBody:     \"Hello\",\n\t\t},\n\t\t{\n\t\t\tname:             \"handlers can be configured to return an alternative status code and content type\",\n\t\t\tinput:            templ.Handler(hello, templ.WithStatus(http.StatusOK), templ.WithContentType(\"text/csv\")),\n\t\t\texpectedStatus:   http.StatusOK,\n\t\t\texpectedMIMEType: \"text/csv\",\n\t\t\texpectedBody:     \"Hello\",\n\t\t},\n\t\t{\n\t\t\tname:             \"handlers that fail return a 500 error\",\n\t\t\tinput:            templ.Handler(errorComponent),\n\t\t\texpectedStatus:   http.StatusInternalServerError,\n\t\t\texpectedMIMEType: \"text/plain; charset=utf-8\",\n\t\t\texpectedBody:     \"templ: failed to render template\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"error handling can be customised\",\n\t\t\tinput: templ.Handler(errorComponent, templ.WithErrorHandler(func(r *http.Request, err error) http.Handler {\n\t\t\t\t// Because the error is received, it's possible to log the detail of the request.\n\t\t\t\t// log.Printf(\"template render error for %v %v: %v\", r.Method, r.URL.String(), err)\n\t\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t\tif _, err := io.WriteString(w, \"custom body\"); err != nil {\n\t\t\t\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})),\n\t\t\texpectedStatus:   http.StatusBadRequest,\n\t\t\texpectedMIMEType: \"text/html; charset=utf-8\",\n\t\t\texpectedBody:     \"custom body\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tr := httptest.NewRequest(\"GET\", \"/test\", nil)\n\t\t\ttt.input.ServeHTTP(w, r)\n\t\t\tif got := w.Result().StatusCode; tt.expectedStatus != got {\n\t\t\t\tt.Errorf(\"expected status %d, got %d\", tt.expectedStatus, got)\n\t\t\t}\n\t\t\tif mimeType := w.Result().Header.Get(\"Content-Type\"); tt.expectedMIMEType != mimeType {\n\t\t\t\tt.Errorf(\"expected content-type %s, got %s\", tt.expectedMIMEType, mimeType)\n\t\t\t}\n\t\t\tbody, err := io.ReadAll(w.Result().Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to read body: %v\", err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expectedBody, string(body)); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"streaming mode allows responses to be flushed\", func(t *testing.T) {\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/test\", nil)\n\n\t\tcomponent := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\t\t// Write part 1.\n\t\t\tif _, err := io.WriteString(w, \"Part 1\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Flush.\n\t\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t}\n\t\t\t// Check partial response.\n\t\t\twr := w.(*httptest.ResponseRecorder)\n\t\t\tactualBody := wr.Body.String()\n\t\t\tif diff := cmp.Diff(\"Part 1\", actualBody); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t\t// Write part 2.\n\t\t\tif _, err := io.WriteString(w, \"\\nPart 2\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\ttempl.Handler(component, templ.WithStatus(http.StatusCreated), templ.WithStreaming()).ServeHTTP(w, r)\n\t\tif got := w.Result().StatusCode; http.StatusCreated != got {\n\t\t\tt.Errorf(\"expected status %d, got %d\", http.StatusCreated, got)\n\t\t}\n\t\tif mimeType := w.Result().Header.Get(\"Content-Type\"); \"text/html; charset=utf-8\" != mimeType {\n\t\t\tt.Errorf(\"expected content-type %s, got %s\", \"text/html; charset=utf-8\", mimeType)\n\t\t}\n\t\tbody, err := io.ReadAll(w.Result().Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to read body: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"Part 1\\nPart 2\", string(body)); diff != \"\" {\n\t\t\tt.Error(diff)\n\t\t}\n\t})\n\tt.Run(\"streaming mode handles errors\", func(t *testing.T) {\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/test\", nil)\n\n\t\texpectedErr := errors.New(\"streaming error\")\n\n\t\tcomponent := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\t\tif _, err := io.WriteString(w, \"Body\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn expectedErr\n\t\t})\n\n\t\tvar errorHandlerCalled bool\n\t\terrorHandler := func(r *http.Request, err error) http.Handler {\n\t\t\tif expectedErr != err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", expectedErr, err)\n\t\t\t}\n\t\t\terrorHandlerCalled = true\n\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t// This will be ignored, because the header has already been written.\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t// This will be written, but will be appended to the written body.\n\t\t\t\tif _, err := io.WriteString(w, \"Error message\"); err != nil {\n\t\t\t\t\tt.Errorf(\"failed to write error message: %v\", err)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\th := templ.Handler(component,\n\t\t\ttempl.WithStatus(http.StatusCreated),\n\t\t\ttempl.WithStreaming(),\n\t\t\ttempl.WithErrorHandler(errorHandler),\n\t\t)\n\t\th.ServeHTTP(w, r)\n\n\t\tif !errorHandlerCalled {\n\t\t\tt.Error(\"expected error handler to be called\")\n\t\t}\n\t\t// Expect the status code to be 201, not 400, because in streaming mode,\n\t\t// we have to write the header before we can call the error handler.\n\t\tif actualRepsonseCode := w.Result().StatusCode; http.StatusCreated != actualRepsonseCode {\n\t\t\tt.Errorf(\"expected status %d, got %d\", http.StatusCreated, actualRepsonseCode)\n\t\t}\n\t\t// Expect the body to be \"BodyError message\", not just \"Error message\" because\n\t\t// in streaming mode, we've already written part of the body to the response, unlike in\n\t\t// standard mode where the body is written to a buffer before the response is written,\n\t\t// ensuring that partial responses are not sent.\n\t\tactualBody, err := io.ReadAll(w.Result().Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to read body: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"BodyError message\", string(actualBody)); diff != \"\" {\n\t\t\tt.Error(diff)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "ide-demo.gif",
          "type": "blob",
          "size": 531.39453125,
          "content": null
        },
        {
          "name": "join.go",
          "type": "blob",
          "size": 0.466796875,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"io\"\n)\n\n// Join returns a single `templ.Component` that will render provided components in order.\n// If any of the components return an error the Join component will immediately return with the error.\nfunc Join(components ...Component) Component {\n\treturn ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\tfor _, c := range components {\n\t\t\tif err = c.Render(ctx, w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n"
        },
        {
          "name": "join_test.go",
          "type": "blob",
          "size": 1.9423828125,
          "content": "package templ_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestJoin(t *testing.T) {\n\tcompErr := errors.New(\"component error\")\n\n\thello := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\tif _, err := io.WriteString(w, \"Hello\"); err != nil {\n\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n\tworld := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\tif _, err := io.WriteString(w, \"World\"); err != nil {\n\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n\terr := templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {\n\t\treturn compErr\n\t})\n\n\ttests := []struct {\n\t\tname           string\n\t\tinput          []templ.Component\n\t\texpectedOutput string\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tname:           \"a nil slice of components produces no output\",\n\t\t\tinput:          nil,\n\t\t\texpectedOutput: \"\",\n\t\t},\n\t\t{\n\t\t\tname:           \"an empty list of components produces no output\",\n\t\t\tinput:          []templ.Component{},\n\t\t\texpectedOutput: \"\",\n\t\t},\n\t\t{\n\t\t\tname:           \"components are rendered in order\",\n\t\t\tinput:          []templ.Component{hello, world},\n\t\t\texpectedOutput: \"HelloWorld\",\n\t\t},\n\t\t{\n\t\t\tname:           \"components are rendered in order, and errors returned\",\n\t\t\tinput:          []templ.Component{hello, err},\n\t\t\texpectedOutput: \"Hello\",\n\t\t\texpectedErr:    compErr,\n\t\t},\n\t\t{\n\t\t\tname:           \"no further components are rendered after an error\",\n\t\t\tinput:          []templ.Component{err, hello},\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedErr:    compErr,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := templ.Join(tt.input...)\n\t\t\tb := new(bytes.Buffer)\n\t\t\terr := got.Render(context.Background(), b)\n\t\t\tif err != tt.expectedErr {\n\t\t\t\tt.Fatalf(\"failed to render component: %v\", err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expectedOutput, b.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "js.go",
          "type": "blob",
          "size": 1.2978515625,
          "content": "package templ\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"html\"\n)\n\n// JSUnsafeFuncCall calls arbitrary JavaScript in the js parameter.\n//\n// Use of this function presents a security risk - the JavaScript must come\n// from a trusted source, because it will be included as-is in the output.\nfunc JSUnsafeFuncCall[T ~string](js T) ComponentScript {\n\tsum := sha256.Sum256([]byte(js))\n\treturn ComponentScript{\n\t\tName: \"jsUnsafeFuncCall_\" + hex.EncodeToString(sum[:]),\n\t\t// Function is empty because the body of the function is defined elsewhere,\n\t\t// e.g. in a <script> tag within a templ.Once block.\n\t\tFunction:   \"\",\n\t\tCall:       html.EscapeString(string(js)),\n\t\tCallInline: string(js),\n\t}\n}\n\n// JSFuncCall calls a JavaScript function with the given arguments.\n//\n// It can be used in event handlers, e.g. onclick, onhover, etc. or\n// directly in HTML.\nfunc JSFuncCall[T ~string](functionName T, args ...any) ComponentScript {\n\tcall := SafeScript(string(functionName), args...)\n\tsum := sha256.Sum256([]byte(call))\n\treturn ComponentScript{\n\t\tName: \"jsFuncCall_\" + hex.EncodeToString(sum[:]),\n\t\t// Function is empty because the body of the function is defined elsewhere,\n\t\t// e.g. in a <script> tag within a templ.Once block.\n\t\tFunction:   \"\",\n\t\tCall:       call,\n\t\tCallInline: SafeScriptInline(string(functionName), args...),\n\t}\n}\n"
        },
        {
          "name": "js_test.go",
          "type": "blob",
          "size": 5.2421875,
          "content": "package templ\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\n// Note: use of the RawEventHandler and JSFuncCall in ExpressionAttributes is tested in the parser package.\n\nfunc TestJSUnsafeFuncCall(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjs       string\n\t\texpected ComponentScript\n\t}{\n\t\t{\n\t\t\tname: \"alert\",\n\t\t\tjs:   \"alert('hello')\",\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:     \"jsUnsafeFuncCall_bc8b29d9abedc43cb4d79ec0af23be8c4255a4b76691aecf23ba3b0b8ab90011\",\n\t\t\t\tFunction: \"\",\n\t\t\t\t// Note that the Call field is attribute encoded.\n\t\t\t\tCall: \"alert(&#39;hello&#39;)\",\n\t\t\t\t// Whereas the CallInline field is what you would see inside a <script> tag.\n\t\t\t\tCallInline: \"alert('hello')\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"immediately executed function\",\n\t\t\tjs:   \"(function(x) { x < 3 ? alert('hello less than 3') : alert('more than 3'); })(2);\",\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsUnsafeFuncCall_e4c24908f83227fd10c1a984fe8f99e15bfb3f195985af517253f6a72ec9106b\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"(function(x) { x &lt; 3 ? alert(&#39;hello less than 3&#39;) : alert(&#39;more than 3&#39;); })(2);\",\n\t\t\t\tCallInline: \"(function(x) { x < 3 ? alert('hello less than 3') : alert('more than 3'); })(2);\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tactual := JSUnsafeFuncCall(tt.js)\n\t\t\tif diff := cmp.Diff(tt.expected, actual); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJSFuncCall(t *testing.T) {\n\ttests := []struct {\n\t\tname                    string\n\t\tfunctionName            string\n\t\targs                    []any\n\t\texpected                ComponentScript\n\t\texpectedComponentOutput string\n\t}{\n\t\t{\n\t\t\tname:         \"no arguments are supported\",\n\t\t\tfunctionName: \"doSomething\",\n\t\t\targs:         nil,\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsFuncCall_6e742483001f8d3c67652945c597b5a2025a7411cb9d1bae2f9e160bebfeb4c6\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"doSomething()\",\n\t\t\t\tCallInline: \"doSomething()\",\n\t\t\t},\n\t\t\texpectedComponentOutput: `<script type=\"text/javascript\">doSomething()</script>`,\n\t\t},\n\t\t{\n\t\t\tname:         \"single argument is supported\",\n\t\t\tfunctionName: \"alert\",\n\t\t\targs:         []any{\"hello\"},\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsFuncCall_92df7244f17dc5bfc41dfd02043df695e4664f8bf42c265a46d79b32b97693d0\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"alert(&#34;hello&#34;)\",\n\t\t\t\tCallInline: `alert(\"hello\")`,\n\t\t\t},\n\t\t\texpectedComponentOutput: `<script type=\"text/javascript\">alert(\"hello\")</script>`,\n\t\t},\n\t\t{\n\t\t\tname:         \"multiple arguments are supported\",\n\t\t\tfunctionName: \"console.log\",\n\t\t\targs:         []any{\"hello\", \"world\"},\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsFuncCall_2b3416c14fc2700d01e0013e7b7076bb8dd5f3126d19e2e801de409163e3960c\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"console.log(&#34;hello&#34;,&#34;world&#34;)\",\n\t\t\t\tCallInline: `console.log(\"hello\",\"world\")`,\n\t\t\t},\n\t\t\texpectedComponentOutput: `<script type=\"text/javascript\">console.log(\"hello\",\"world\")</script>`,\n\t\t},\n\t\t{\n\t\t\tname:         \"attribute injection fails\",\n\t\t\tfunctionName: `\" onmouseover=\"alert('hello')`,\n\t\t\targs:         nil,\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsFuncCall_e56d1214f3b4fbf27406f209e3f4a58c2842fa2760b6d83da5ee72e04c89f913\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"__templ_invalid_js_function_name()\",\n\t\t\t\tCallInline: \"__templ_invalid_js_function_name()\",\n\t\t\t},\n\t\t\texpectedComponentOutput: `<script type=\"text/javascript\">__templ_invalid_js_function_name()</script>`,\n\t\t},\n\t\t{\n\t\t\tname:         \"closing the script and injecting HTML fails\",\n\t\t\tfunctionName: `</script><div>Hello</div><script>`,\n\t\t\targs:         nil,\n\t\t\texpected: ComponentScript{\n\t\t\t\tName:       \"jsFuncCall_e56d1214f3b4fbf27406f209e3f4a58c2842fa2760b6d83da5ee72e04c89f913\",\n\t\t\t\tFunction:   \"\",\n\t\t\t\tCall:       \"__templ_invalid_js_function_name()\",\n\t\t\t\tCallInline: \"__templ_invalid_js_function_name()\",\n\t\t\t},\n\t\t\texpectedComponentOutput: `<script type=\"text/javascript\">__templ_invalid_js_function_name()</script>`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Test creation.\n\t\t\tactual := JSFuncCall(tt.functionName, tt.args...)\n\t\t\tif diff := cmp.Diff(tt.expected, actual); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\n\t\t\t// Test rendering.\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := actual.Render(context.Background(), buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expectedComponentOutput, buf.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc TestJSFunctionNameRegexp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \"console.log\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"alert\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"console.log('hello')\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"</script><div>Hello</div><script>\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\" onmouseover=\"alert('hello')`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"(new Date()).getTime\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"expressionThatReturnsAFunction()\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tactual := jsFunctionName.MatchString(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "jsonscript.go",
          "type": "blob",
          "size": 2.1728515625,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\nvar _ Component = JSONScriptElement{}\n\n// JSONScript renders a JSON object inside a script element.\n// e.g. <script type=\"application/json\">{\"foo\":\"bar\"}</script>\nfunc JSONScript(id string, data any) JSONScriptElement {\n\treturn JSONScriptElement{\n\t\tID:    id,\n\t\tType:  \"application/json\",\n\t\tData:  data,\n\t\tNonce: GetNonce,\n\t}\n}\n\n// WithType sets the value of the type attribute of the script element.\nfunc (j JSONScriptElement) WithType(t string) JSONScriptElement {\n\tj.Type = t\n\treturn j\n}\n\n// WithNonceFromString sets the value of the nonce attribute of the script element to the given string.\nfunc (j JSONScriptElement) WithNonceFromString(nonce string) JSONScriptElement {\n\tj.Nonce = func(context.Context) string {\n\t\treturn nonce\n\t}\n\treturn j\n}\n\n// WithNonceFrom sets the value of the nonce attribute of the script element to the value returned by the given function.\nfunc (j JSONScriptElement) WithNonceFrom(f func(context.Context) string) JSONScriptElement {\n\tj.Nonce = f\n\treturn j\n}\n\ntype JSONScriptElement struct {\n\t// ID of the element in the DOM.\n\tID string\n\t// Type of the script element, defaults to \"application/json\".\n\tType string\n\t// Data that will be encoded as JSON.\n\tData any\n\t// Nonce is a function that returns a CSP nonce.\n\t// Defaults to CSPNonceFromContext.\n\t// See https://content-security-policy.com/nonce for more information.\n\tNonce func(ctx context.Context) string\n}\n\nfunc (j JSONScriptElement) Render(ctx context.Context, w io.Writer) (err error) {\n\tif _, err = io.WriteString(w, \"<script\"); err != nil {\n\t\treturn err\n\t}\n\tif j.ID != \"\" {\n\t\tif _, err = fmt.Fprintf(w, \" id=\\\"%s\\\"\", EscapeString(j.ID)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif j.Type != \"\" {\n\t\tif _, err = fmt.Fprintf(w, \" type=\\\"%s\\\"\", EscapeString(j.Type)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif nonce := j.Nonce(ctx); nonce != \"\" {\n\t\tif _, err = fmt.Fprintf(w, \" nonce=\\\"%s\\\"\", EscapeString(nonce)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif _, err = io.WriteString(w, \">\"); err != nil {\n\t\treturn err\n\t}\n\tif err = json.NewEncoder(w).Encode(j.Data); err != nil {\n\t\treturn err\n\t}\n\tif _, err = io.WriteString(w, \"</script>\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "jsonscript_test.go",
          "type": "blob",
          "size": 1.9287109375,
          "content": "package templ_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestJSONScriptElement(t *testing.T) {\n\tdata := map[string]interface{}{\"foo\": \"bar\"}\n\ttests := []struct {\n\t\tname     string\n\t\tctx      context.Context\n\t\te        templ.JSONScriptElement\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"renders data as JSON inside a script element\",\n\t\t\te:        templ.JSONScript(\"id\", data),\n\t\t\texpected: \"<script id=\\\"id\\\" type=\\\"application/json\\\">{\\\"foo\\\":\\\"bar\\\"}\\n</script>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"if a nonce is available in the context, it is used\",\n\t\t\tctx:      templ.WithNonce(context.Background(), \"nonce-from-context\"),\n\t\t\te:        templ.JSONScript(\"idc\", data),\n\t\t\texpected: \"<script id=\\\"idc\\\" type=\\\"application/json\\\" nonce=\\\"nonce-from-context\\\">{\\\"foo\\\":\\\"bar\\\"}\\n</script>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"if a nonce is provided, it is used\",\n\t\t\te:        templ.JSONScript(\"ids\", data).WithNonceFromString(\"nonce-from-string\"),\n\t\t\texpected: \"<script id=\\\"ids\\\" type=\\\"application/json\\\" nonce=\\\"nonce-from-string\\\">{\\\"foo\\\":\\\"bar\\\"}\\n</script>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"if a nonce function is provided, it is used\",\n\t\t\te:        templ.JSONScript(\"idf\", data).WithNonceFrom(func(context.Context) string { return \"nonce-from-function\" }),\n\t\t\texpected: \"<script id=\\\"idf\\\" type=\\\"application/json\\\" nonce=\\\"nonce-from-function\\\">{\\\"foo\\\":\\\"bar\\\"}\\n</script>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"if a type is provided, it is used\",\n\t\t\te:        templ.JSONScript(\"idt\", data).WithType(\"application/ld+json\"),\n\t\t\texpected: \"<script id=\\\"idt\\\" type=\\\"application/ld+json\\\">{\\\"foo\\\":\\\"bar\\\"}\\n</script>\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tw := new(bytes.Buffer)\n\t\t\tif err := tt.e.Render(tt.ctx, w); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expected, w.String()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"unexpected output (-want +got):\\n%s\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "jsonstring.go",
          "type": "blob",
          "size": 0.21875,
          "content": "package templ\n\nimport (\n\t\"encoding/json\"\n)\n\n// JSONString returns a JSON encoded string of v.\nfunc JSONString(v any) (string, error) {\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(b), nil\n}\n"
        },
        {
          "name": "jsonstring_test.go",
          "type": "blob",
          "size": 0.64453125,
          "content": "package templ_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n)\n\nfunc TestJSONString(t *testing.T) {\n\tt.Run(\"renders input data as a JSON string\", func(t *testing.T) {\n\t\tdata := map[string]any{\"foo\": \"bar\"}\n\t\tactual, err := templ.JSONString(data)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\texpected := \"{\\\"foo\\\":\\\"bar\\\"}\"\n\t\tif actual != expected {\n\t\t\tt.Fatalf(\"unexpected output: want %q, got %q\", expected, actual)\n\t\t}\n\t})\n\tt.Run(\"returns an error if the data cannot be marshalled\", func(t *testing.T) {\n\t\tdata := make(chan int)\n\t\t_, err := templ.JSONString(data)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expected an error, got nil\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "logo",
          "type": "tree",
          "content": null
        },
        {
          "name": "once.go",
          "type": "blob",
          "size": 1.720703125,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"sync/atomic\"\n)\n\n// onceHandleIndex is used to identify unique once handles in a program run.\nvar onceHandleIndex int64\n\ntype OnceOpt func(*OnceHandle)\n\n// WithOnceComponent sets the component to be rendered once per context.\n// This can be used instead of setting the children of the `Once` method,\n// for example, if creating a code component outside of a templ HTML template.\nfunc WithComponent(c Component) OnceOpt {\n\treturn func(o *OnceHandle) {\n\t\to.c = c\n\t}\n}\n\n// NewOnceHandle creates a OnceHandle used to ensure that the children of its\n// `Once` method are only rendered once per context.\nfunc NewOnceHandle(opts ...OnceOpt) *OnceHandle {\n\toh := &OnceHandle{\n\t\tid: atomic.AddInt64(&onceHandleIndex, 1),\n\t}\n\tfor _, opt := range opts {\n\t\topt(oh)\n\t}\n\treturn oh\n}\n\n// OnceHandle is used to ensure that the children of its `Once` method are are only\n// rendered once per context.\ntype OnceHandle struct {\n\t// id is used to identify which instance of the OnceHandle is being used.\n\t// The OnceHandle can't be an empty struct, because:\n\t//\n\t//  | Two distinct zero-size variables may\n\t//  | have the same address in memory\n\t//\n\t// https://go.dev/ref/spec#Size_and_alignment_guarantees\n\tid int64\n\t// c is the component to be rendered once per context.\n\t// if c is nil, the children of the `Once` method are rendered.\n\tc Component\n}\n\n// Once returns a component that renders its children once per context.\nfunc (o *OnceHandle) Once() Component {\n\treturn ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\t_, v := getContext(ctx)\n\t\tif v.getHasBeenRendered(o) {\n\t\t\treturn nil\n\t\t}\n\t\tv.setHasBeenRendered(o)\n\t\tif o.c != nil {\n\t\t\treturn o.c.Render(ctx, w)\n\t\t}\n\t\treturn GetChildren(ctx).Render(ctx, w)\n\t})\n}\n"
        },
        {
          "name": "once_test.go",
          "type": "blob",
          "size": 2.7880859375,
          "content": "package templ_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\ntype onceHandleTest struct {\n\tctx      context.Context\n\texpected string\n}\n\nfunc TestOnceHandle(t *testing.T) {\n\twithHello := templ.WithChildren(context.Background(), templ.Raw(\"hello\"))\n\ttests := []struct {\n\t\tname  string\n\t\ttests []onceHandleTest\n\t}{\n\t\t{\n\t\t\tname: \"renders nothing without children\",\n\t\t\ttests: []onceHandleTest{\n\t\t\t\t{\n\t\t\t\t\tctx:      context.Background(),\n\t\t\t\t\texpected: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"children are rendered\",\n\t\t\ttests: []onceHandleTest{\n\t\t\t\t{\n\t\t\t\t\tctx:      templ.WithChildren(context.Background(), templ.Raw(\"hello\")),\n\t\t\t\t\texpected: \"hello\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"children are rendered once per context\",\n\t\t\ttests: []onceHandleTest{\n\t\t\t\t{\n\t\t\t\t\tctx:      withHello,\n\t\t\t\t\texpected: \"hello\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tctx:      withHello,\n\t\t\t\t\texpected: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"different contexts have different once state\",\n\t\t\ttests: []onceHandleTest{\n\t\t\t\t{\n\t\t\t\t\tctx:      templ.WithChildren(context.Background(), templ.Raw(\"hello\")),\n\t\t\t\t\texpected: \"hello\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tctx:      templ.WithChildren(context.Background(), templ.Raw(\"hello2\")),\n\t\t\t\t\texpected: \"hello2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := templ.NewOnceHandle().Once()\n\t\t\tfor i, test := range tt.tests {\n\t\t\t\tt.Run(fmt.Sprintf(\"render %d/%d\", i+1, len(tt.tests)), func(t *testing.T) {\n\t\t\t\t\thtml, err := templ.ToGoHTML(test.ctx, c)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif diff := cmp.Diff(test.expected, string(html)); diff != \"\" {\n\t\t\t\t\t\tt.Errorf(\"unexpected diff:\\n%v\", diff)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"each new handle manages different state\", func(t *testing.T) {\n\t\tctx := templ.WithChildren(context.Background(), templ.Raw(\"hello\"))\n\t\th1 := templ.NewOnceHandle()\n\t\tc1 := h1.Once()\n\t\th2 := templ.NewOnceHandle()\n\t\tc2 := h2.Once()\n\t\tc3 := h2.Once()\n\t\tvar w strings.Builder\n\t\tif err := c1.Render(ctx, &w); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\tif err := c2.Render(ctx, &w); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\tif err := c3.Render(ctx, &w); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"hellohello\", w.String()); diff != \"\" {\n\t\t\tt.Errorf(\"unexpected diff:\\n%v\", diff)\n\t\t}\n\t})\n\tt.Run(\"a handle can be used to render a specific component\", func(t *testing.T) {\n\t\tctx := templ.WithChildren(context.Background(), templ.Raw(\"child\"))\n\t\to := templ.NewOnceHandle(templ.WithComponent(templ.Raw(\"c\"))).Once()\n\t\tvar w strings.Builder\n\t\tif err := o.Render(ctx, &w); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"c\", w.String()); diff != \"\" {\n\t\t\tt.Errorf(\"unexpected diff:\\n%v\", diff)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "push-tag.sh",
          "type": "blob",
          "size": 0.3955078125,
          "content": "#!/bin/sh\nif [ `git rev-parse --abbrev-ref HEAD` != \"main\" ]; then\n  echo \"Error: Not on main branch. Please switch to main branch.\";\n  exit 1;\nfi\ngit pull\nif ! git diff --quiet; then\n  echo \"Error: Working directory is not clean. Please commit the changes first.\";\n  exit 1;\nfi\nexport VERSION=`cat .version`\necho Adding git tag with version v${VERSION};\ngit tag v${VERSION};\ngit push origin v${VERSION};\n"
        },
        {
          "name": "runtime.go",
          "type": "blob",
          "size": 15.791015625,
          "content": "package templ\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/a-h/templ/safehtml\"\n)\n\n// Types exposed by all components.\n\n// Component is the interface that all templates implement.\ntype Component interface {\n\t// Render the template.\n\tRender(ctx context.Context, w io.Writer) error\n}\n\n// ComponentFunc converts a function that matches the Component interface's\n// Render method into a Component.\ntype ComponentFunc func(ctx context.Context, w io.Writer) error\n\n// Render the template.\nfunc (cf ComponentFunc) Render(ctx context.Context, w io.Writer) error {\n\treturn cf(ctx, w)\n}\n\n// WithNonce sets a CSP nonce on the context and returns it.\nfunc WithNonce(ctx context.Context, nonce string) context.Context {\n\tctx, v := getContext(ctx)\n\tv.nonce = nonce\n\treturn ctx\n}\n\n// GetNonce returns the CSP nonce value set with WithNonce, or an\n// empty string if none has been set.\nfunc GetNonce(ctx context.Context) (nonce string) {\n\tif ctx == nil {\n\t\treturn \"\"\n\t}\n\t_, v := getContext(ctx)\n\treturn v.nonce\n}\n\nfunc WithChildren(ctx context.Context, children Component) context.Context {\n\tctx, v := getContext(ctx)\n\tv.children = &children\n\treturn ctx\n}\n\nfunc ClearChildren(ctx context.Context) context.Context {\n\t_, v := getContext(ctx)\n\tv.children = nil\n\treturn ctx\n}\n\n// NopComponent is a component that doesn't render anything.\nvar NopComponent = ComponentFunc(func(ctx context.Context, w io.Writer) error { return nil })\n\n// GetChildren from the context.\nfunc GetChildren(ctx context.Context) Component {\n\t_, v := getContext(ctx)\n\tif v.children == nil {\n\t\treturn NopComponent\n\t}\n\treturn *v.children\n}\n\n// EscapeString escapes HTML text within templates.\nfunc EscapeString(s string) string {\n\treturn html.EscapeString(s)\n}\n\n// Bool attribute value.\nfunc Bool(value bool) bool {\n\treturn value\n}\n\n// Classes for CSS.\n// Supported types are string, ConstantCSSClass, ComponentCSSClass, map[string]bool.\nfunc Classes(classes ...any) CSSClasses {\n\treturn CSSClasses(classes)\n}\n\n// CSSClasses is a slice of CSS classes.\ntype CSSClasses []any\n\n// String returns the names of all CSS classes.\nfunc (classes CSSClasses) String() string {\n\tif len(classes) == 0 {\n\t\treturn \"\"\n\t}\n\tcp := newCSSProcessor()\n\tfor _, v := range classes {\n\t\tcp.Add(v)\n\t}\n\treturn cp.String()\n}\n\nfunc newCSSProcessor() *cssProcessor {\n\treturn &cssProcessor{\n\t\tclassNameToEnabled: make(map[string]bool),\n\t}\n}\n\ntype cssProcessor struct {\n\tclassNameToEnabled map[string]bool\n\torderedNames       []string\n}\n\nfunc (cp *cssProcessor) Add(item any) {\n\tswitch c := item.(type) {\n\tcase []string:\n\t\tfor _, className := range c {\n\t\t\tcp.AddClassName(className, true)\n\t\t}\n\tcase string:\n\t\tcp.AddClassName(c, true)\n\tcase ConstantCSSClass:\n\t\tcp.AddClassName(c.ClassName(), true)\n\tcase ComponentCSSClass:\n\t\tcp.AddClassName(c.ClassName(), true)\n\tcase map[string]bool:\n\t\t// In Go, map keys are iterated in a randomized order.\n\t\t// So the keys in the map must be sorted to produce consistent output.\n\t\tkeys := make([]string, len(c))\n\t\tvar i int\n\t\tfor key := range c {\n\t\t\tkeys[i] = key\n\t\t\ti++\n\t\t}\n\t\tsort.Strings(keys)\n\t\tfor _, className := range keys {\n\t\t\tcp.AddClassName(className, c[className])\n\t\t}\n\tcase []KeyValue[string, bool]:\n\t\tfor _, kv := range c {\n\t\t\tcp.AddClassName(kv.Key, kv.Value)\n\t\t}\n\tcase KeyValue[string, bool]:\n\t\tcp.AddClassName(c.Key, c.Value)\n\tcase []KeyValue[CSSClass, bool]:\n\t\tfor _, kv := range c {\n\t\t\tcp.AddClassName(kv.Key.ClassName(), kv.Value)\n\t\t}\n\tcase KeyValue[CSSClass, bool]:\n\t\tcp.AddClassName(c.Key.ClassName(), c.Value)\n\tcase CSSClasses:\n\t\tfor _, item := range c {\n\t\t\tcp.Add(item)\n\t\t}\n\tcase []CSSClass:\n\t\tfor _, item := range c {\n\t\t\tcp.Add(item)\n\t\t}\n\tcase func() CSSClass:\n\t\tcp.AddClassName(c().ClassName(), true)\n\tdefault:\n\t\tcp.AddClassName(unknownTypeClassName, true)\n\t}\n}\n\nfunc (cp *cssProcessor) AddClassName(className string, enabled bool) {\n\tcp.classNameToEnabled[className] = enabled\n\tcp.orderedNames = append(cp.orderedNames, className)\n}\n\nfunc (cp *cssProcessor) String() string {\n\t// Order the outputs according to how they were input, and remove disabled names.\n\trendered := make(map[string]any, len(cp.classNameToEnabled))\n\tvar names []string\n\tfor _, name := range cp.orderedNames {\n\t\tif enabled := cp.classNameToEnabled[name]; !enabled {\n\t\t\tcontinue\n\t\t}\n\t\tif _, hasBeenRendered := rendered[name]; hasBeenRendered {\n\t\t\tcontinue\n\t\t}\n\t\tnames = append(names, name)\n\t\trendered[name] = struct{}{}\n\t}\n\n\treturn strings.Join(names, \" \")\n}\n\n// KeyValue is a key and value pair.\ntype KeyValue[TKey comparable, TValue any] struct {\n\tKey   TKey   `json:\"name\"`\n\tValue TValue `json:\"value\"`\n}\n\n// KV creates a new key/value pair from the input key and value.\nfunc KV[TKey comparable, TValue any](key TKey, value TValue) KeyValue[TKey, TValue] {\n\treturn KeyValue[TKey, TValue]{\n\t\tKey:   key,\n\t\tValue: value,\n\t}\n}\n\nconst unknownTypeClassName = \"--templ-css-class-unknown-type\"\n\n// Class returns a CSS class name.\n// Deprecated: use a string instead.\nfunc Class(name string) CSSClass {\n\treturn SafeClass(name)\n}\n\n// SafeClass bypasses CSS class name validation.\n// Deprecated: use a string instead.\nfunc SafeClass(name string) CSSClass {\n\treturn ConstantCSSClass(name)\n}\n\n// CSSClass provides a class name.\ntype CSSClass interface {\n\tClassName() string\n}\n\n// ConstantCSSClass is a string constant of a CSS class name.\n// Deprecated: use a string instead.\ntype ConstantCSSClass string\n\n// ClassName of the CSS class.\nfunc (css ConstantCSSClass) ClassName() string {\n\treturn string(css)\n}\n\n// ComponentCSSClass is a templ.CSS\ntype ComponentCSSClass struct {\n\t// ID of the class, will be autogenerated.\n\tID string\n\t// Definition of the CSS.\n\tClass SafeCSS\n}\n\n// ClassName of the CSS class.\nfunc (css ComponentCSSClass) ClassName() string {\n\treturn css.ID\n}\n\n// CSSID calculates an ID.\nfunc CSSID(name string, css string) string {\n\tsum := sha256.Sum256([]byte(css))\n\ths := hex.EncodeToString(sum[:])[0:8] // NOTE: See issue #978. Minimum recommended hs length is 6.\n\t// Benchmarking showed this was fastest, and with fewest allocations (1).\n\t// Using strings.Builder (2 allocs).\n\t// Using fmt.Sprintf (3 allocs).\n\treturn name + \"_\" + hs\n}\n\n// NewCSSMiddleware creates HTTP middleware that renders a global stylesheet of ComponentCSSClass\n// CSS if the request path matches, or updates the HTTP context to ensure that any handlers that\n// use templ.Components skip rendering <style> elements for classes that are included in the global\n// stylesheet. By default, the stylesheet path is /styles/templ.css\nfunc NewCSSMiddleware(next http.Handler, classes ...CSSClass) CSSMiddleware {\n\treturn CSSMiddleware{\n\t\tPath:       \"/styles/templ.css\",\n\t\tCSSHandler: NewCSSHandler(classes...),\n\t\tNext:       next,\n\t}\n}\n\n// CSSMiddleware renders a global stylesheet.\ntype CSSMiddleware struct {\n\tPath       string\n\tCSSHandler CSSHandler\n\tNext       http.Handler\n}\n\nfunc (cssm CSSMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path == cssm.Path {\n\t\tcssm.CSSHandler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\t// Add registered classes to the context.\n\tctx, v := getContext(r.Context())\n\tfor _, c := range cssm.CSSHandler.Classes {\n\t\tv.addClass(c.ID)\n\t}\n\t// Serve the request. Templ components will use the updated context\n\t// to know to skip rendering <style> elements for any component CSS\n\t// classes that have been included in the global stylesheet.\n\tcssm.Next.ServeHTTP(w, r.WithContext(ctx))\n}\n\n// NewCSSHandler creates a handler that serves a stylesheet containing the CSS of the\n// classes passed in. This is used by the CSSMiddleware to provide global stylesheets\n// for templ components.\nfunc NewCSSHandler(classes ...CSSClass) CSSHandler {\n\tccssc := make([]ComponentCSSClass, 0, len(classes))\n\tfor _, c := range classes {\n\t\tccss, ok := c.(ComponentCSSClass)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tccssc = append(ccssc, ccss)\n\t}\n\treturn CSSHandler{\n\t\tClasses: ccssc,\n\t}\n}\n\n// CSSHandler is a HTTP handler that serves CSS.\ntype CSSHandler struct {\n\tLogger  func(err error)\n\tClasses []ComponentCSSClass\n}\n\nfunc (cssh CSSHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/css\")\n\tfor _, c := range cssh.Classes {\n\t\t_, err := w.Write([]byte(c.Class))\n\t\tif err != nil && cssh.Logger != nil {\n\t\t\tcssh.Logger(err)\n\t\t}\n\t}\n}\n\n// RenderCSSItems renders the CSS to the writer, if the items haven't already been rendered.\nfunc RenderCSSItems(ctx context.Context, w io.Writer, classes ...any) (err error) {\n\tif len(classes) == 0 {\n\t\treturn nil\n\t}\n\t_, v := getContext(ctx)\n\tsb := new(strings.Builder)\n\trenderCSSItemsToBuilder(sb, v, classes...)\n\tif sb.Len() > 0 {\n\t\tif _, err = io.WriteString(w, `<style type=\"text/css\">`); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, sb.String()); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, `</style>`); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc renderCSSItemsToBuilder(sb *strings.Builder, v *contextValue, classes ...any) {\n\tfor _, c := range classes {\n\t\tswitch ccc := c.(type) {\n\t\tcase ComponentCSSClass:\n\t\t\tif !v.hasClassBeenRendered(ccc.ID) {\n\t\t\t\tsb.WriteString(string(ccc.Class))\n\t\t\t\tv.addClass(ccc.ID)\n\t\t\t}\n\t\tcase KeyValue[ComponentCSSClass, bool]:\n\t\t\tif !ccc.Value {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trenderCSSItemsToBuilder(sb, v, ccc.Key)\n\t\tcase KeyValue[CSSClass, bool]:\n\t\t\tif !ccc.Value {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trenderCSSItemsToBuilder(sb, v, ccc.Key)\n\t\tcase CSSClasses:\n\t\t\trenderCSSItemsToBuilder(sb, v, ccc...)\n\t\tcase []CSSClass:\n\t\t\tfor _, item := range ccc {\n\t\t\t\trenderCSSItemsToBuilder(sb, v, item)\n\t\t\t}\n\t\tcase func() CSSClass:\n\t\t\trenderCSSItemsToBuilder(sb, v, ccc())\n\t\tcase []string:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\tcase string:\n\t\t\t// Skip. This is a class name, not a CSS class.\n\t\tcase ConstantCSSClass:\n\t\t\t// Skip. This is a class name, not a CSS class.\n\t\tcase CSSClass:\n\t\t\t// Skip. This is a class name, not a CSS class.\n\t\tcase map[string]bool:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\tcase KeyValue[string, bool]:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\tcase []KeyValue[string, bool]:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\tcase KeyValue[ConstantCSSClass, bool]:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\tcase []KeyValue[ConstantCSSClass, bool]:\n\t\t\t// Skip. These are class names, not CSS classes.\n\t\t}\n\t}\n}\n\n// SafeCSS is CSS that has been sanitized.\ntype SafeCSS string\n\ntype SafeCSSProperty string\n\nvar safeCSSPropertyType = reflect.TypeOf(SafeCSSProperty(\"\"))\n\n// SanitizeCSS sanitizes CSS properties to ensure that they are safe.\nfunc SanitizeCSS[T ~string](property string, value T) SafeCSS {\n\tif reflect.TypeOf(value) == safeCSSPropertyType {\n\t\treturn SafeCSS(safehtml.SanitizeCSSProperty(property) + \":\" + string(value) + \";\")\n\t}\n\tp, v := safehtml.SanitizeCSS(property, string(value))\n\treturn SafeCSS(p + \":\" + v + \";\")\n}\n\n// Attributes is an alias to map[string]any made for spread attributes.\ntype Attributes map[string]any\n\n// sortedKeys returns the keys of a map in sorted order.\nfunc sortedKeys(m map[string]any) (keys []string) {\n\tkeys = make([]string, len(m))\n\tvar i int\n\tfor k := range m {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n\nfunc writeStrings(w io.Writer, ss ...string) (err error) {\n\tfor _, s := range ss {\n\t\tif _, err = io.WriteString(w, s); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc RenderAttributes(ctx context.Context, w io.Writer, attributes Attributes) (err error) {\n\tfor _, key := range sortedKeys(attributes) {\n\t\tvalue := attributes[key]\n\t\tswitch value := value.(type) {\n\t\tcase string:\n\t\t\tif err = writeStrings(w, ` `, EscapeString(key), `=\"`, EscapeString(value), `\"`); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase *string:\n\t\t\tif value != nil {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key), `=\"`, EscapeString(*value), `\"`); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\tcase bool:\n\t\t\tif value {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key)); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\tcase *bool:\n\t\t\tif value != nil && *value {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key)); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\tcase KeyValue[string, bool]:\n\t\t\tif value.Value {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key), `=\"`, EscapeString(value.Key), `\"`); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\tcase KeyValue[bool, bool]:\n\t\t\tif value.Value && value.Key {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key)); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\tcase func() bool:\n\t\t\tif value() {\n\t\t\t\tif err = writeStrings(w, ` `, EscapeString(key)); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Context.\n\ntype contextKeyType int\n\nconst contextKey = contextKeyType(0)\n\ntype contextValue struct {\n\tss          map[string]struct{}\n\tonceHandles map[*OnceHandle]struct{}\n\tchildren    *Component\n\tnonce       string\n}\n\nfunc (v *contextValue) setHasBeenRendered(h *OnceHandle) {\n\tif v.onceHandles == nil {\n\t\tv.onceHandles = map[*OnceHandle]struct{}{}\n\t}\n\tv.onceHandles[h] = struct{}{}\n}\n\nfunc (v *contextValue) getHasBeenRendered(h *OnceHandle) (ok bool) {\n\tif v.onceHandles == nil {\n\t\tv.onceHandles = map[*OnceHandle]struct{}{}\n\t}\n\t_, ok = v.onceHandles[h]\n\treturn\n}\n\nfunc (v *contextValue) addScript(s string) {\n\tif v.ss == nil {\n\t\tv.ss = map[string]struct{}{}\n\t}\n\tv.ss[\"script_\"+s] = struct{}{}\n}\n\nfunc (v *contextValue) hasScriptBeenRendered(s string) (ok bool) {\n\tif v.ss == nil {\n\t\tv.ss = map[string]struct{}{}\n\t}\n\t_, ok = v.ss[\"script_\"+s]\n\treturn\n}\n\nfunc (v *contextValue) addClass(s string) {\n\tif v.ss == nil {\n\t\tv.ss = map[string]struct{}{}\n\t}\n\tv.ss[\"class_\"+s] = struct{}{}\n}\n\nfunc (v *contextValue) hasClassBeenRendered(s string) (ok bool) {\n\tif v.ss == nil {\n\t\tv.ss = map[string]struct{}{}\n\t}\n\t_, ok = v.ss[\"class_\"+s]\n\treturn\n}\n\n// InitializeContext initializes context used to store internal state used during rendering.\nfunc InitializeContext(ctx context.Context) context.Context {\n\tif _, ok := ctx.Value(contextKey).(*contextValue); ok {\n\t\treturn ctx\n\t}\n\tv := &contextValue{}\n\tctx = context.WithValue(ctx, contextKey, v)\n\treturn ctx\n}\n\nfunc getContext(ctx context.Context) (context.Context, *contextValue) {\n\tv, ok := ctx.Value(contextKey).(*contextValue)\n\tif !ok {\n\t\tctx = InitializeContext(ctx)\n\t\tv = ctx.Value(contextKey).(*contextValue)\n\t}\n\treturn ctx, v\n}\n\nvar bufferPool = sync.Pool{\n\tNew: func() any {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\nfunc GetBuffer() *bytes.Buffer {\n\treturn bufferPool.Get().(*bytes.Buffer)\n}\n\nfunc ReleaseBuffer(b *bytes.Buffer) {\n\tb.Reset()\n\tbufferPool.Put(b)\n}\n\n// JoinStringErrs joins an optional list of errors.\nfunc JoinStringErrs(s string, errs ...error) (string, error) {\n\treturn s, errors.Join(errs...)\n}\n\n// Error returned during template rendering.\ntype Error struct {\n\tErr error\n\t// FileName of the template file.\n\tFileName string\n\t// Line index of the error.\n\tLine int\n\t// Col index of the error.\n\tCol int\n}\n\nfunc (e Error) Error() string {\n\tif e.FileName == \"\" {\n\t\te.FileName = \"templ\"\n\t}\n\treturn fmt.Sprintf(\"%s: error at line %d, col %d: %v\", e.FileName, e.Line, e.Col, e.Err)\n}\n\nfunc (e Error) Unwrap() error {\n\treturn e.Err\n}\n\n// Raw renders the input HTML to the output without applying HTML escaping.\n//\n// Use of this component presents a security risk - the HTML should come from\n// a trusted source, because it will be included as-is in the output.\nfunc Raw[T ~string](html T, errs ...error) Component {\n\treturn ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\tif err = errors.Join(errs...); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = io.WriteString(w, string(html))\n\t\treturn err\n\t})\n}\n\n// FromGoHTML creates a templ Component from a Go html/template template.\nfunc FromGoHTML(t *template.Template, data any) Component {\n\treturn ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\treturn t.Execute(w, data)\n\t})\n}\n\n// ToGoHTML renders the component to a Go html/template template.HTML string.\nfunc ToGoHTML(ctx context.Context, c Component) (s template.HTML, err error) {\n\tb := GetBuffer()\n\tdefer ReleaseBuffer(b)\n\tif err = c.Render(ctx, b); err != nil {\n\t\treturn\n\t}\n\ts = template.HTML(b.String())\n\treturn\n}\n"
        },
        {
          "name": "runtime",
          "type": "tree",
          "content": null
        },
        {
          "name": "runtime_test.go",
          "type": "blob",
          "size": 16.267578125,
          "content": "package templ_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestCSSID(t *testing.T) {\n\tt.Run(\"minimum hash suffix length is 8\", func(t *testing.T) {\n\t\t// See issue #978.\n\t\tname := \"classA\"\n\t\tcss := \"background-color:white;\"\n\t\tactual := len(templ.CSSID(name, css))\n\t\texpected := len(name) + 1 + 8\n\t\tif expected != actual {\n\t\t\tt.Errorf(\"expected length %d, got %d\", expected, actual)\n\t\t}\n\t})\n\tt.Run(\"known hash collisions are avoided\", func(t *testing.T) {\n\t\tname := \"classA\"\n\t\t// Note that the first 4 characters of the hash are the same.\n\t\tcss1 := \"grid-column:1;grid-row:1;\"  // After hash: f781266f\n\t\tcss2 := \"grid-column:13;grid-row:6;\" // After hash: f781f18b\n\t\tid1 := templ.CSSID(name, css1)\n\t\tid2 := templ.CSSID(name, css2)\n\t\tif id1 == id2 {\n\t\t\tt.Errorf(\"hash collision: %s == %s\", id1, id2)\n\t\t}\n\t})\n}\n\nfunc TestCSSHandler(t *testing.T) {\n\ttests := []struct {\n\t\tname             string\n\t\tinput            []templ.CSSClass\n\t\texpectedMIMEType string\n\t\texpectedBody     string\n\t}{\n\t\t{\n\t\t\tname:             \"no classes\",\n\t\t\tinput:            nil,\n\t\t\texpectedMIMEType: \"text/css\",\n\t\t\texpectedBody:     \"\",\n\t\t},\n\t\t{\n\t\t\tname:             \"classes are rendered\",\n\t\t\tinput:            []templ.CSSClass{templ.ComponentCSSClass{ID: \"className\", Class: templ.SafeCSS(\".className{background-color:white;}\")}},\n\t\t\texpectedMIMEType: \"text/css\",\n\t\t\texpectedBody:     \".className{background-color:white;}\",\n\t\t},\n\t\t{\n\t\t\tname: \"classes are rendered\",\n\t\t\tinput: []templ.CSSClass{\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classA\", Class: templ.SafeCSS(\".classA{background-color:white;}\")},\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classB\", Class: templ.SafeCSS(\".classB{background-color:green;}\")},\n\t\t\t},\n\t\t\texpectedMIMEType: \"text/css\",\n\t\t\texpectedBody:     \".classA{background-color:white;}.classB{background-color:green;}\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\th := templ.NewCSSHandler(tt.input...)\n\t\t\th.ServeHTTP(w, &http.Request{})\n\t\t\tif diff := cmp.Diff(tt.expectedMIMEType, w.Header().Get(\"Content-Type\")); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expectedBody, w.Body.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCSSMiddleware(t *testing.T) {\n\tpageHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif _, err := io.WriteString(w, \"Hello, World!\"); err != nil {\n\t\t\tt.Fatalf(\"failed to write string: %v\", err)\n\t\t}\n\t})\n\tc1 := templ.ComponentCSSClass{\n\t\tID:    \"c1\",\n\t\tClass: \".c1{color:red}\",\n\t}\n\tc2 := templ.ComponentCSSClass{\n\t\tID:    \"c2\",\n\t\tClass: \".c2{color:blue}\",\n\t}\n\n\ttests := []struct {\n\t\tname             string\n\t\tinput            *http.Request\n\t\thandler          http.Handler\n\t\texpectedMIMEType string\n\t\texpectedBody     string\n\t}{\n\t\t{\n\t\t\tname:             \"accessing /style/templ.css renders CSS, even if it's empty\",\n\t\t\tinput:            httptest.NewRequest(\"GET\", \"/styles/templ.css\", nil),\n\t\t\thandler:          templ.NewCSSMiddleware(pageHandler),\n\t\t\texpectedMIMEType: \"text/css\",\n\t\t\texpectedBody:     \"\",\n\t\t},\n\t\t{\n\t\t\tname:             \"accessing /style/templ.css renders CSS that includes the classes\",\n\t\t\tinput:            httptest.NewRequest(\"GET\", \"/styles/templ.css\", nil),\n\t\t\thandler:          templ.NewCSSMiddleware(pageHandler, c1, c2),\n\t\t\texpectedMIMEType: \"text/css\",\n\t\t\texpectedBody:     \".c1{color:red}.c2{color:blue}\",\n\t\t},\n\t\t{\n\t\t\tname:             \"the pageHandler is rendered\",\n\t\t\tinput:            httptest.NewRequest(\"GET\", \"/index.html\", nil),\n\t\t\thandler:          templ.NewCSSMiddleware(pageHandler, c1, c2),\n\t\t\texpectedMIMEType: \"text/plain; charset=utf-8\",\n\t\t\texpectedBody:     \"Hello, World!\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\ttt.handler.ServeHTTP(w, tt.input)\n\t\t\tif diff := cmp.Diff(tt.expectedMIMEType, w.Header().Get(\"Content-Type\")); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expectedBody, w.Body.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar cssInputs = []any{\n\t[]string{\"a\", \"b\"},          // []string\n\t\"c\",                         // string\n\ttempl.ConstantCSSClass(\"d\"), // ConstantCSSClass\n\ttempl.ComponentCSSClass{ID: \"e\", Class: \".e{color:red}\"}, // ComponentCSSClass\n\tmap[string]bool{\"f\": true, \"ff\": false},                  // map[string]bool\n\ttempl.KV(\"g\", true),                                      // KeyValue[string, bool]\n\ttempl.KV(\"gg\", false),                                    // KeyValue[string, bool]\n\t[]templ.KeyValue[string, bool]{\n\t\ttempl.KV(\"h\", true),\n\t\ttempl.KV(\"hh\", false),\n\t}, // []KeyValue[string, bool]\n\ttempl.KV(templ.ConstantCSSClass(\"i\"), true),   // KeyValue[CSSClass, bool]\n\ttempl.KV(templ.ConstantCSSClass(\"ii\"), false), // KeyValue[CSSClass, bool]\n\ttempl.KV(templ.ComponentCSSClass{\n\t\tID:    \"j\",\n\t\tClass: \".j{color:red}\",\n\t}, true), // KeyValue[ComponentCSSClass, bool]\n\ttempl.KV(templ.ComponentCSSClass{\n\t\tID:    \"jj\",\n\t\tClass: \".jj{color:red}\",\n\t}, false), // KeyValue[ComponentCSSClass, bool]\n\ttempl.CSSClasses{templ.ConstantCSSClass(\"k\")},                // CSSClasses\n\tfunc() templ.CSSClass { return templ.ConstantCSSClass(\"l\") }, // func() CSSClass\n\ttempl.CSSClass(templ.ConstantCSSClass(\"m\")),                  // CSSClass\n\tcustomClass{name: \"n\"},                                       // CSSClass\n\t[]templ.CSSClass{customClass{name: \"n\"}},                     // []CSSClass\n\ttempl.KV(templ.ConstantCSSClass(\"o\"), true),                  // KeyValue[ConstantCSSClass, bool]\n\t[]templ.KeyValue[templ.ConstantCSSClass, bool]{\n\t\ttempl.KV(templ.ConstantCSSClass(\"p\"), true),\n\t\ttempl.KV(templ.ConstantCSSClass(\"pp\"), false),\n\t}, // []KeyValue[ConstantCSSClass, bool]\n}\n\ntype customClass struct {\n\tname string\n}\n\nfunc (cc customClass) ClassName() string {\n\treturn cc.name\n}\n\nfunc TestRenderCSS(t *testing.T) {\n\tc1 := templ.ComponentCSSClass{\n\t\tID:    \"c1\",\n\t\tClass: \".c1{color:red}\",\n\t}\n\tc2 := templ.ComponentCSSClass{\n\t\tID:    \"c2\",\n\t\tClass: \".c2{color:blue}\",\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\ttoIgnore []any\n\t\ttoRender []any\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"if none are ignored, everything is rendered\",\n\t\t\ttoIgnore: nil,\n\t\t\ttoRender: []any{c1, c2},\n\t\t\texpected: `<style type=\"text/css\">.c1{color:red}.c2{color:blue}</style>`,\n\t\t},\n\t\t{\n\t\t\tname: \"if something outside the expected is ignored, if has no effect\",\n\t\t\ttoIgnore: []any{\n\t\t\t\ttempl.ComponentCSSClass{\n\t\t\t\t\tID:    \"c3\",\n\t\t\t\t\tClass: templ.SafeCSS(\".c3{color:yellow}\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\ttoRender: []any{c1, c2},\n\t\t\texpected: `<style type=\"text/css\">.c1{color:red}.c2{color:blue}</style>`,\n\t\t},\n\t\t{\n\t\t\tname:     \"if one is ignored, it's not rendered\",\n\t\t\ttoIgnore: []any{c1},\n\t\t\ttoRender: []any{c1, c2},\n\t\t\texpected: `<style type=\"text/css\">.c2{color:blue}</style>`,\n\t\t},\n\t\t{\n\t\t\tname: \"if all are ignored, not even style tags are rendered\",\n\t\t\ttoIgnore: []any{\n\t\t\t\tc1,\n\t\t\t\tc2,\n\t\t\t\ttempl.ComponentCSSClass{\n\t\t\t\t\tID:    \"c3\",\n\t\t\t\t\tClass: templ.SafeCSS(\".c3{color:yellow}\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\ttoRender: []any{c1, c2},\n\t\t\texpected: ``,\n\t\t},\n\t\t{\n\t\t\tname:     \"CSS classes are rendered\",\n\t\t\ttoIgnore: nil,\n\t\t\ttoRender: cssInputs,\n\t\t\texpected: `<style type=\"text/css\">.e{color:red}.j{color:red}</style>`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx := context.Background()\n\t\t\tb := new(bytes.Buffer)\n\n\t\t\t// Render twice, reusing the same context so that there's a memory of which classes have been rendered.\n\t\t\tctx = templ.InitializeContext(ctx)\n\t\t\terr := templ.RenderCSSItems(ctx, b, tt.toIgnore...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to render initial CSS: %v\", err)\n\t\t\t}\n\n\t\t\t// Now render again to check that only the expected classes were rendered.\n\t\t\tb.Reset()\n\t\t\terr = templ.RenderCSSItems(ctx, b, tt.toRender...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to render CSS: %v\", err)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tt.expected, b.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestClassesFunction(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []any\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"constants are allowed\",\n\t\t\tinput:    []any{\"a\", \"b\", \"c\", \"</style>\"},\n\t\t\texpected: \"a b c </style>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"legacy CSS types are supported\",\n\t\t\tinput:    []any{\"a\", templ.SafeClass(\"b\"), templ.Class(\"c\")},\n\t\t\texpected: \"a b c\",\n\t\t},\n\t\t{\n\t\t\tname: \"CSS components are included in the output\",\n\t\t\tinput: []any{\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classA\", Class: templ.SafeCSS(\".classA{background-color:white;}\")},\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classB\", Class: templ.SafeCSS(\".classB{background-color:green;}\")},\n\t\t\t\t\"c\",\n\t\t\t},\n\t\t\texpected: \"classA classB c\",\n\t\t},\n\t\t{\n\t\t\tname: \"optional classes can be applied with expressions\",\n\t\t\tinput: []any{\n\t\t\t\t\"a\",\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classA\", Class: templ.SafeCSS(\".classA{background-color:white;}\")},\n\t\t\t\ttempl.ComponentCSSClass{ID: \"classB\", Class: templ.SafeCSS(\".classB{background-color:green;}\")},\n\t\t\t\t\"c\",\n\t\t\t\tmap[string]bool{\n\t\t\t\t\t\"a\":      false,\n\t\t\t\t\t\"classA\": false,\n\t\t\t\t\t\"classB\": false,\n\t\t\t\t\t\"c\":      true,\n\t\t\t\t\t\"d\":      false,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"unknown types for classes get rendered as --templ-css-class-unknown-type\",\n\t\t\tinput: []any{\n\t\t\t\t123,\n\t\t\t\tmap[string]string{\"test\": \"no\"},\n\t\t\t\tfalse,\n\t\t\t\t\"c\",\n\t\t\t},\n\t\t\texpected: \"--templ-css-class-unknown-type c\",\n\t\t},\n\t\t{\n\t\t\tname: \"string arrays are supported\",\n\t\t\tinput: []any{\n\t\t\t\t[]string{\"a\", \"b\", \"c\", \"</style>\"},\n\t\t\t\t\"d\",\n\t\t\t},\n\t\t\texpected: \"a b c </style> d\",\n\t\t},\n\t\t{\n\t\t\tname: \"strings are broken up\",\n\t\t\tinput: []any{\n\t\t\t\t\"a </style>\",\n\t\t\t},\n\t\t\texpected: \"a </style>\",\n\t\t},\n\t\t{\n\t\t\tname: \"if a templ.CSSClasses is passed in, the nested CSSClasses are extracted\",\n\t\t\tinput: []any{\n\t\t\t\ttempl.Classes(\n\t\t\t\t\t\"a\",\n\t\t\t\t\ttempl.SafeClass(\"b\"),\n\t\t\t\t\ttempl.Class(\"c\"),\n\t\t\t\t\ttempl.ComponentCSSClass{\n\t\t\t\t\t\tID:    \"d\",\n\t\t\t\t\t\tClass: \"{}\",\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t},\n\t\t\texpected: \"a b c d\",\n\t\t},\n\t\t{\n\t\t\tname: \"kv types can be used to show or hide classes\",\n\t\t\tinput: []any{\n\t\t\t\t\"a\",\n\t\t\t\ttempl.KV(\"b\", true),\n\t\t\t\t\"c\",\n\t\t\t\ttempl.KV(\"c\", false),\n\t\t\t\ttempl.KV(templ.SafeClass(\"d\"), true),\n\t\t\t\ttempl.KV(templ.SafeClass(\"e\"), false),\n\t\t\t},\n\t\t\texpected: \"a b d\",\n\t\t},\n\t\t{\n\t\t\tname: \"an array of KV types can be used to show or hide classes\",\n\t\t\tinput: []any{\n\t\t\t\t\"a\",\n\t\t\t\t\"c\",\n\t\t\t\t[]templ.KeyValue[string, bool]{\n\t\t\t\t\ttempl.KV(\"b\", true),\n\t\t\t\t\ttempl.KV(\"c\", false),\n\t\t\t\t\t{\"d\", true},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"a b d\",\n\t\t},\n\t\t{\n\t\t\tname: \"the brackets on component CSS function calls can be elided\",\n\t\t\tinput: []any{\n\t\t\t\tfunc() templ.CSSClass {\n\t\t\t\t\treturn templ.ComponentCSSClass{\n\t\t\t\t\t\tID:    \"a\",\n\t\t\t\t\t\tClass: \"\",\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"a\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactual := templ.Classes(test.input...).String()\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype baseError struct {\n\tValue int\n}\n\nfunc (baseError) Error() string { return \"base error\" }\n\ntype nonMatchedError struct{}\n\nfunc (nonMatchedError) Error() string { return \"non matched error\" }\n\nfunc TestErrorWrapping(t *testing.T) {\n\tbaseErr := baseError{\n\t\tValue: 1,\n\t}\n\twrappedErr := templ.Error{Err: baseErr, Line: 1, Col: 2}\n\tt.Run(\"errors.Is() returns true for the base error\", func(t *testing.T) {\n\t\tif !errors.Is(wrappedErr, baseErr) {\n\t\t\tt.Error(\"errors.Is() returned false for the base error\")\n\t\t}\n\t})\n\tt.Run(\"errors.Is() returns false for a different error\", func(t *testing.T) {\n\t\tif errors.Is(wrappedErr, errors.New(\"different error\")) {\n\t\t\tt.Error(\"errors.Is() returned true for a different error\")\n\t\t}\n\t})\n\tt.Run(\"errors.As() returns true for the base error\", func(t *testing.T) {\n\t\tvar err baseError\n\t\tif !errors.As(wrappedErr, &err) {\n\t\t\tt.Error(\"errors.As() returned false for the base error\")\n\t\t}\n\t\tif err.Value != 1 {\n\t\t\tt.Errorf(\"errors.As() returned a different value: %v\", err.Value)\n\t\t}\n\t})\n\tt.Run(\"errors.As() returns false for a different error\", func(t *testing.T) {\n\t\tvar err nonMatchedError\n\t\tif errors.As(wrappedErr, &err) {\n\t\t\tt.Error(\"errors.As() returned true for a different error\")\n\t\t}\n\t})\n}\n\nfunc TestRawComponent(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       templ.Component\n\t\texpected    string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:     \"Raw content is not escaped\",\n\t\t\tinput:    templ.Raw(\"<div>Test &</div>\"),\n\t\t\texpected: `<div>Test &</div>`,\n\t\t},\n\t\t{\n\t\t\tname:        \"Raw will return errors first\",\n\t\t\tinput:       templ.Raw(\"\", nil, errors.New(\"test error\")),\n\t\t\texpected:    `<div>Test &</div>`,\n\t\t\texpectedErr: errors.New(\"test error\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Strings marked as safe are rendered without escaping\",\n\t\t\tinput:    templ.Raw(template.HTML(\"<div>\")),\n\t\t\texpected: `<div>`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb := new(bytes.Buffer)\n\t\t\terr := tt.input.Render(context.Background(), b)\n\t\t\tif tt.expectedErr != nil {\n\t\t\t\texpected := tt.expectedErr.Error()\n\t\t\t\tactual := fmt.Sprintf(\"%v\", err)\n\t\t\t\tif actual != expected {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", expected, actual)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to render content: %v\", err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.expected, b.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"Raw does not require allocations\", func(t *testing.T) {\n\t\tactualAllocs := testing.AllocsPerRun(4, func() {\n\t\t\tc := templ.Raw(\"<div>\")\n\t\t\tif c == nil {\n\t\t\t\tt.Fatalf(\"unexpected nil value\")\n\t\t\t}\n\t\t})\n\t\tif actualAllocs > 0 {\n\t\t\tt.Errorf(\"expected no allocs, got %v\", actualAllocs)\n\t\t}\n\t})\n}\n\nvar goTemplate = template.Must(template.New(\"example\").Parse(\"<div>{{ . }}</div>\"))\n\nfunc TestGoHTMLComponents(t *testing.T) {\n\tt.Run(\"Go templates can be rendered as templ components\", func(t *testing.T) {\n\t\tb := new(bytes.Buffer)\n\t\terr := templ.FromGoHTML(goTemplate, \"Test &\").Render(context.Background(), b)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to render content: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"<div>Test &amp;</div>\", b.String()); diff != \"\" {\n\t\t\tt.Error(diff)\n\t\t}\n\t})\n\tt.Run(\"templ components can be rendered in Go templates\", func(t *testing.T) {\n\t\tb := new(bytes.Buffer)\n\t\tc := templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\t\t_, err = io.WriteString(w, \"<div>Unsanitized &</div>\")\n\t\t\treturn err\n\t\t})\n\t\th, err := templ.ToGoHTML(context.Background(), c)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to convert to Go HTML: %v\", err)\n\t\t}\n\t\tif err = goTemplate.Execute(b, h); err != nil {\n\t\t\tt.Fatalf(\"failed to render content: %v\", err)\n\t\t}\n\t\tif diff := cmp.Diff(\"<div><div>Unsanitized &</div></div>\", b.String()); diff != \"\" {\n\t\t\tt.Error(diff)\n\t\t}\n\t})\n\tt.Run(\"errors in ToGoHTML are returned\", func(t *testing.T) {\n\t\texpectedErr := errors.New(\"test error\")\n\t\tc := templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\t\treturn expectedErr\n\t\t})\n\t\t_, err := templ.ToGoHTML(context.Background(), c)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expected error, got nil\")\n\t\t}\n\t\tif err != expectedErr {\n\t\t\tt.Fatalf(\"expected error %q, got %q\", expectedErr, err)\n\t\t}\n\t})\n\tt.Run(\"FromGoHTML does not require allocations\", func(t *testing.T) {\n\t\tactualAllocs := testing.AllocsPerRun(4, func() {\n\t\t\tc := templ.FromGoHTML(goTemplate, \"test &\")\n\t\t\tif c == nil {\n\t\t\t\tt.Fatalf(\"unexpected nil value\")\n\t\t\t}\n\t\t})\n\t\tif actualAllocs > 0 {\n\t\t\tt.Errorf(\"expected no allocs, got %v\", actualAllocs)\n\t\t}\n\t})\n\tt.Run(\"ToGoHTML requires one allocation\", func(t *testing.T) {\n\t\texpected := \"<div>Unsanitized &</div>\"\n\t\tc := templ.ComponentFunc(func(ctx context.Context, w io.Writer) (err error) {\n\t\t\t_, err = io.WriteString(w, expected)\n\t\t\treturn err\n\t\t})\n\t\tactualAllocs := testing.AllocsPerRun(4, func() {\n\t\t\th, err := templ.ToGoHTML(context.Background(), c)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to convert to Go HTML: %v\", err)\n\t\t\t}\n\t\t\tif h != template.HTML(expected) {\n\t\t\t\tt.Fatalf(\"unexpected value\")\n\t\t\t}\n\t\t})\n\t\tif actualAllocs > 1 {\n\t\t\tt.Errorf(\"expected 1 alloc, got %v\", actualAllocs)\n\t\t}\n\t})\n}\n\nfunc TestNonce(t *testing.T) {\n\tctx := context.Background()\n\tt.Run(\"returns empty string if not set\", func(t *testing.T) {\n\t\tactual := templ.GetNonce(ctx)\n\t\tif actual != \"\" {\n\t\t\tt.Errorf(\"expected empty string got %q\", actual)\n\t\t}\n\t})\n\tt.Run(\"returns value if one has been set\", func(t *testing.T) {\n\t\texpected := \"abc123\"\n\t\tctx := templ.WithNonce(context.Background(), expected)\n\t\tactual := templ.GetNonce(ctx)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"expected %q got %q\", expected, actual)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "safehtml",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripttemplate.go",
          "type": "blob",
          "size": 4.1083984375,
          "content": "package templ\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// ComponentScript is a templ Script template.\ntype ComponentScript struct {\n\t// Name of the script, e.g. print.\n\tName string\n\t// Function to render.\n\tFunction string\n\t// Call of the function in JavaScript syntax, including parameters, and\n\t// ensures parameters are HTML escaped; useful for injecting into HTML\n\t// attributes like onclick, onhover, etc.\n\t//\n\t// Given:\n\t//    functionName(\"some string\",12345)\n\t// It would render:\n\t//    __templ_functionName_sha(&#34;some string&#34;,12345))\n\t//\n\t// This is can be injected into HTML attributes:\n\t//    <button onClick=\"__templ_functionName_sha(&#34;some string&#34;,12345))\">Click Me</button>\n\tCall string\n\t// Call of the function in JavaScript syntax, including parameters. It\n\t// does not HTML escape parameters; useful for directly calling in script\n\t// elements.\n\t//\n\t// Given:\n\t//    functionName(\"some string\",12345)\n\t// It would render:\n\t//    __templ_functionName_sha(\"some string\",12345))\n\t//\n\t// This is can be used to call the function inside a script tag:\n\t//    <script>__templ_functionName_sha(\"some string\",12345))</script>\n\tCallInline string\n}\n\nvar _ Component = ComponentScript{}\n\nfunc writeScriptHeader(ctx context.Context, w io.Writer) (err error) {\n\tvar nonceAttr string\n\tif nonce := GetNonce(ctx); nonce != \"\" {\n\t\tnonceAttr = \" nonce=\\\"\" + EscapeString(nonce) + \"\\\"\"\n\t}\n\t_, err = fmt.Fprintf(w, `<script type=\"text/javascript\"%s>`, nonceAttr)\n\treturn err\n}\n\nfunc (c ComponentScript) Render(ctx context.Context, w io.Writer) error {\n\terr := RenderScriptItems(ctx, w, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.Call) > 0 {\n\t\tif err = writeScriptHeader(ctx, w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, c.CallInline); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, `</script>`); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// RenderScriptItems renders a <script> element, if the script has not already been rendered.\nfunc RenderScriptItems(ctx context.Context, w io.Writer, scripts ...ComponentScript) (err error) {\n\tif len(scripts) == 0 {\n\t\treturn nil\n\t}\n\t_, v := getContext(ctx)\n\tsb := new(strings.Builder)\n\tfor _, s := range scripts {\n\t\tif !v.hasScriptBeenRendered(s.Name) {\n\t\t\tsb.WriteString(s.Function)\n\t\t\tv.addScript(s.Name)\n\t\t}\n\t}\n\tif sb.Len() > 0 {\n\t\tif err = writeScriptHeader(ctx, w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, sb.String()); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err = io.WriteString(w, `</script>`); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// JSExpression represents a JavaScript expression intended for use as an argument for script templates.\n// The string value of JSExpression will be inserted directly as JavaScript code in function call arguments.\ntype JSExpression string\n\n// SafeScript encodes unknown parameters for safety for inside HTML attributes.\nfunc SafeScript(functionName string, params ...any) string {\n\tif !jsFunctionName.MatchString(functionName) {\n\t\tfunctionName = \"__templ_invalid_js_function_name\"\n\t}\n\tsb := new(strings.Builder)\n\tsb.WriteString(html.EscapeString(functionName))\n\tsb.WriteRune('(')\n\tfor i, p := range params {\n\t\tsb.WriteString(EscapeString(jsonEncodeParam(p)))\n\t\tif i < len(params)-1 {\n\t\t\tsb.WriteRune(',')\n\t\t}\n\t}\n\tsb.WriteRune(')')\n\treturn sb.String()\n}\n\n// SafeScript encodes unknown parameters for safety for inline scripts.\nfunc SafeScriptInline(functionName string, params ...any) string {\n\tif !jsFunctionName.MatchString(functionName) {\n\t\tfunctionName = \"__templ_invalid_js_function_name\"\n\t}\n\tsb := new(strings.Builder)\n\tsb.WriteString(functionName)\n\tsb.WriteRune('(')\n\tfor i, p := range params {\n\t\tsb.WriteString(jsonEncodeParam(p))\n\t\tif i < len(params)-1 {\n\t\t\tsb.WriteRune(',')\n\t\t}\n\t}\n\tsb.WriteRune(')')\n\treturn sb.String()\n}\n\nfunc jsonEncodeParam(param any) string {\n\tif val, ok := param.(JSExpression); ok {\n\t\treturn string(val)\n\t}\n\tenc, _ := json.Marshal(param)\n\treturn string(enc)\n}\n\n// isValidJSFunctionName returns true if the given string is a valid JavaScript function name, e.g. console.log, alert, etc.\nvar jsFunctionName = regexp.MustCompile(`^([$_a-zA-Z][$_a-zA-Z0-9]+\\.?)+$`)\n"
        },
        {
          "name": "scripttemplate_test.go",
          "type": "blob",
          "size": 2.5888671875,
          "content": "package templ_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/a-h/templ\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestRenderScriptItems(t *testing.T) {\n\ts1 := templ.ComponentScript{\n\t\tName:     \"s1\",\n\t\tFunction: \"function s1() { return 'hello1'; }\",\n\t}\n\ts2 := templ.ComponentScript{\n\t\tName:     \"s2\",\n\t\tFunction: \"function s2() { return 'hello2'; }\",\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\ttoIgnore []templ.ComponentScript\n\t\ttoRender []templ.ComponentScript\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"if none are ignored, everything is rendered\",\n\t\t\ttoIgnore: nil,\n\t\t\ttoRender: []templ.ComponentScript{s1, s2},\n\t\t\texpected: `<script type=\"text/javascript\">` + s1.Function + s2.Function + `</script>`,\n\t\t},\n\t\t{\n\t\t\tname: \"if something outside the expected is ignored, if has no effect\",\n\t\t\ttoIgnore: []templ.ComponentScript{\n\t\t\t\t{\n\t\t\t\t\tName:     \"s3\",\n\t\t\t\t\tFunction: \"function s3() { return 'hello3'; }\",\n\t\t\t\t},\n\t\t\t},\n\t\t\ttoRender: []templ.ComponentScript{s1, s2},\n\t\t\texpected: `<script type=\"text/javascript\">` + s1.Function + s2.Function + `</script>`,\n\t\t},\n\t\t{\n\t\t\tname:     \"if one is ignored, it's not rendered\",\n\t\t\ttoIgnore: []templ.ComponentScript{s1},\n\t\t\ttoRender: []templ.ComponentScript{s1, s2},\n\t\t\texpected: `<script type=\"text/javascript\">` + s2.Function + `</script>`,\n\t\t},\n\t\t{\n\t\t\tname: \"if all are ignored, not even style tags are rendered\",\n\t\t\ttoIgnore: []templ.ComponentScript{\n\t\t\t\ts1,\n\t\t\t\ts2,\n\t\t\t\t{\n\t\t\t\t\tName:     \"s3\",\n\t\t\t\t\tFunction: \"function s3() { return 'hello3'; }\",\n\t\t\t\t},\n\t\t\t},\n\t\t\ttoRender: []templ.ComponentScript{s1, s2},\n\t\t\texpected: ``,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx := context.Background()\n\t\t\tb := new(bytes.Buffer)\n\n\t\t\t// Render twice, reusing the same context so that there's a memory of which classes have been rendered.\n\t\t\tctx = templ.InitializeContext(ctx)\n\t\t\terr := templ.RenderScriptItems(ctx, b, tt.toIgnore...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to render initial scripts: %v\", err)\n\t\t\t}\n\n\t\t\t// Now render again to check that only the expected classes were rendered.\n\t\t\tb.Reset()\n\t\t\terr = templ.RenderScriptItems(ctx, b, tt.toRender...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to render scripts: %v\", err)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tt.expected, b.String()); diff != \"\" {\n\t\t\t\tt.Error(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJSExpression(t *testing.T) {\n\texpected := \"myJSFunction(\\\"StringValue\\\",123,event,1 + 2)\"\n\tactual := templ.SafeScriptInline(\"myJSFunction\", \"StringValue\", 123, templ.JSExpression(\"event\"), templ.JSExpression(\"1 + 2\"))\n\n\tif actual != expected {\n\t\tt.Fatalf(\"TestJSExpression: expected %q, got %q\", expected, actual)\n\t}\n}\n"
        },
        {
          "name": "storybook",
          "type": "tree",
          "content": null
        },
        {
          "name": "templ.png",
          "type": "blob",
          "size": 15.1640625,
          "content": null
        },
        {
          "name": "turbo",
          "type": "tree",
          "content": null
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 0.732421875,
          "content": "package templ\n\nimport \"strings\"\n\n// FailedSanitizationURL is returned if a URL fails sanitization checks.\nconst FailedSanitizationURL = SafeURL(\"about:invalid#TemplFailedSanitizationURL\")\n\n// URL sanitizes the input string s and returns a SafeURL.\nfunc URL(s string) SafeURL {\n\tif i := strings.IndexRune(s, ':'); i >= 0 && !strings.ContainsRune(s[:i], '/') {\n\t\tprotocol := s[:i]\n\t\tif !strings.EqualFold(protocol, \"http\") && !strings.EqualFold(protocol, \"https\") && !strings.EqualFold(protocol, \"mailto\") && !strings.EqualFold(protocol, \"tel\") && !strings.EqualFold(protocol, \"ftp\") && !strings.EqualFold(protocol, \"ftps\") {\n\t\t\treturn FailedSanitizationURL\n\t\t}\n\t}\n\treturn SafeURL(s)\n}\n\n// SafeURL is a URL that has been sanitized.\ntype SafeURL string\n"
        },
        {
          "name": "url_test.go",
          "type": "blob",
          "size": 1.2880859375,
          "content": "package templ\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\ntype urlTest struct {\n\turl             string\n\texpectSanitized bool\n}\n\nvar urlTests = []urlTest{\n\t{\"//example.com\", false},\n\t{\"/\", false},\n\t{\"/index\", false},\n\t{\"http://example.com\", false},\n\t{\"https://example.com\", false},\n\t{\"mailto:test@example.com\", false},\n\t{\"tel:+1234567890\", false},\n\t{\"ftp://example.com\", false},\n\t{\"ftps://example.com\", false},\n\t{\"irc://example.com\", true},\n\t{\"bitcoin://example.com\", true},\n}\n\nfunc testURL(t *testing.T, url string, expectSanitized bool) {\n\tu := URL(url)\n\twasSanitized := u == FailedSanitizationURL\n\tif expectSanitized != wasSanitized {\n\t\tt.Errorf(\"expected sanitized=%v, got %v\", expectSanitized, wasSanitized)\n\t}\n}\n\nfunc TestURL(t *testing.T) {\n\tfor _, test := range urlTests {\n\t\tt.Run(test.url, func(t *testing.T) {\n\t\t\ttestURL(t, test.url, test.expectSanitized)\n\t\t})\n\t\ttest.url = strings.ToUpper(test.url)\n\t\tt.Run(strings.ToUpper(test.url), func(t *testing.T) {\n\t\t\ttestURL(t, test.url, test.expectSanitized)\n\t\t})\n\t}\n}\n\nfunc BenchmarkURL(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range urlTests {\n\t\t\tu := URL(test.url)\n\t\t\twasSanitized := u == FailedSanitizationURL\n\t\t\tif test.expectSanitized != wasSanitized {\n\t\t\t\tb.Errorf(\"expected sanitized=%v, got %v\", test.expectSanitized, wasSanitized)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.1181640625,
          "content": "package templ\n\nimport _ \"embed\"\n\n//go:embed .version\nvar version string\n\nfunc Version() string {\n\treturn \"v\" + version\n}\n"
        },
        {
          "name": "watchmode.go",
          "type": "blob",
          "size": 2.3466796875,
          "content": "package templ\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// WriteWatchModeString is used when rendering templates in development mode.\n// the generator would have written non-go code to the _templ.txt file, which\n// is then read by this function and written to the output.\n//\n// Deprecated: since templ v0.3.x generated code uses WriteString.\nfunc WriteWatchModeString(w io.Writer, lineNum int) error {\n\t_, path, _, _ := runtime.Caller(1)\n\tif !strings.HasSuffix(path, \"_templ.go\") {\n\t\treturn errors.New(\"templ: WriteWatchModeString can only be called from _templ.go\")\n\t}\n\ttxtFilePath := strings.Replace(path, \"_templ.go\", \"_templ.txt\", 1)\n\n\tliterals, err := getWatchedStrings(txtFilePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"templ: failed to cache strings: %w\", err)\n\t}\n\n\tif lineNum > len(literals) {\n\t\treturn fmt.Errorf(\"templ: failed to find line %d in %s\", lineNum, txtFilePath)\n\t}\n\n\ts, err := strconv.Unquote(`\"` + literals[lineNum-1] + `\"`)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = io.WriteString(w, s)\n\treturn err\n}\n\nvar (\n\twatchModeCache  = map[string]watchState{}\n\twatchStateMutex sync.Mutex\n)\n\ntype watchState struct {\n\tmodTime time.Time\n\tstrings []string\n}\n\nfunc getWatchedStrings(txtFilePath string) ([]string, error) {\n\twatchStateMutex.Lock()\n\tdefer watchStateMutex.Unlock()\n\n\tstate, cached := watchModeCache[txtFilePath]\n\tif !cached {\n\t\treturn cacheStrings(txtFilePath)\n\t}\n\n\tif time.Since(state.modTime) < time.Millisecond*100 {\n\t\treturn state.strings, nil\n\t}\n\n\tinfo, err := os.Stat(txtFilePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"templ: failed to stat %s: %w\", txtFilePath, err)\n\t}\n\n\tif !info.ModTime().After(state.modTime) {\n\t\treturn state.strings, nil\n\t}\n\n\treturn cacheStrings(txtFilePath)\n}\n\nfunc cacheStrings(txtFilePath string) ([]string, error) {\n\ttxtFile, err := os.Open(txtFilePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"templ: failed to open %s: %w\", txtFilePath, err)\n\t}\n\tdefer txtFile.Close()\n\n\tinfo, err := txtFile.Stat()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"templ: failed to stat %s: %w\", txtFilePath, err)\n\t}\n\n\tall, err := io.ReadAll(txtFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"templ: failed to read %s: %w\", txtFilePath, err)\n\t}\n\n\tliterals := strings.Split(string(all), \"\\n\")\n\twatchModeCache[txtFilePath] = watchState{\n\t\tmodTime: info.ModTime(),\n\t\tstrings: literals,\n\t}\n\n\treturn literals, nil\n}\n"
        }
      ]
    }
  ]
}