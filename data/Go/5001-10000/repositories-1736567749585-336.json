{
  "metadata": {
    "timestamp": 1736567749585,
    "page": 336,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jinzhu/copier",
      "stars": 5652,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0166015625,
          "content": ".idea/\nttt/\ncmd/\n"
        },
        {
          "name": "License",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Jinzhu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.47265625,
          "content": "# Copier\n\nI am a copier, I copy everything from one to another\n\n[![test status](https://github.com/jinzhu/copier/workflows/tests/badge.svg?branch=master \"test status\")](https://github.com/jinzhu/copier/actions)\n\n## Key Features\n\n- Field-to-field and method-to-field copying based on matching names\n- Support for copying data:\n  - From slice to slice\n  - From struct to slice\n  - From map to map\n- Field manipulation through tags:\n  - Enforce field copying with `copier:\"must\"`\n  - Override fields even when `IgnoreEmpty` is set with `copier:\"override\"`\n  - Exclude fields from being copied with `copier:\"-\"`\n\n## Getting Started\n\n### Installation\n\nTo start using Copier, install Go and run go get:\n\n```bash\ngo get -u github.com/jinzhu/copier\n```\n\n## Basic\n\nImport Copier into your application to access its copying capabilities\n\n```go\nimport \"github.com/jinzhu/copier\"\n```\n\n### Basic Copying\n\n```go\ntype User struct {\n\tName string\n\tRole string\n\tAge  int32\n}\n\nfunc (user *User) DoubleAge() int32 {\n\treturn 2 * user.Age\n}\n\ntype Employee struct {\n\tName      string\n\tAge       int32\n\tDoubleAge int32\n\tSuperRole string\n}\n\nfunc (employee *Employee) Role(role string) {\n\temployee.SuperRole = \"Super \" + role\n}\n\nfunc main() {\n\tuser := User{Name: \"Jinzhu\", Age: 18, Role: \"Admin\"}\n\temployee := Employee{}\n\n\tcopier.Copy(&employee, &user)\n\tfmt.Printf(\"%#v\\n\", employee)\n\t// Output: Employee{Name:\"Jinzhu\", Age:18, DoubleAge:36, SuperRole:\"Super Admin\"}\n}\n```\n\n## Tag Usage Examples\n\n### `copier:\"-\"` - Ignoring Fields\n\nFields tagged with `copier:\"-\"` are explicitly ignored by Copier during the copying process.\n\n```go\ntype Source struct {\n    Name   string\n    Secret string // We do not want this to be copied.\n}\n\ntype Target struct {\n    Name   string\n    Secret string `copier:\"-\"`\n}\n\nfunc main() {\n    source := Source{Name: \"John\", Secret: \"so_secret\"}\n    target := Target{}\n\n    copier.Copy(&target, &source)\n    fmt.Printf(\"Name: %s, Secret: '%s'\\n\", target.Name, target.Secret)\n    // Output: Name: John, Secret: ''\n}\n```\n\n### `copier:\"must\"` - Enforcing Field Copy\n\nThe `copier:\"must\"` tag forces a field to be copied, resulting in a panic or an error if the field cannot be copied.\n\n```go\ntype MandatorySource struct {\n\tIdentification int\n}\n\ntype MandatoryTarget struct {\n\tID int `copier:\"must\"` // This field must be copied, or it will panic/error.\n}\n\nfunc main() {\n\tsource := MandatorySource{}\n\ttarget := MandatoryTarget{ID: 10}\n\n\t// This will result in a panic or an error since ID is a must field but is empty in source.\n\tif err := copier.Copy(&target, &source); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n### `copier:\"must,nopanic\"` - Enforcing Field Copy Without Panic\n\nSimilar to `copier:\"must\"`, but Copier returns an error instead of panicking if the field is not copied.\n\n```go\ntype SafeSource struct {\n\tID string\n}\n\ntype SafeTarget struct {\n\tCode string `copier:\"must,nopanic\"` // Enforce copying without panic.\n}\n\nfunc main() {\n\tsource := SafeSource{}\n\ttarget := SafeTarget{Code: \"200\"}\n\n\tif err := copier.Copy(&target, &source); err != nil {\n\t\tlog.Fatalln(\"Error:\", err)\n\t}\n\t// This will not panic, but will return an error due to missing mandatory field.\n}\n```\n\n### `copier:\"override\"` - Overriding Fields with IgnoreEmpty\n\nFields tagged with `copier:\"override\"` are copied even if IgnoreEmpty is set to true in Copier options and works for nil values.\n\n```go\ntype SourceWithNil struct {\n    Details *string\n}\n\ntype TargetOverride struct {\n    Details *string `copier:\"override\"` // Even if source is nil, copy it.\n}\n\nfunc main() {\n    details := \"Important details\"\n    source := SourceWithNil{Details: nil}\n    target := TargetOverride{Details: &details}\n\n    copier.CopyWithOption(&target, &source, copier.Option{IgnoreEmpty: true})\n    if target.Details == nil {\n        fmt.Println(\"Details field was overridden to nil.\")\n    }\n}\n```\n\n### Specifying Custom Field Names\n\nUse field tags to specify a custom field name when the source and destination field names do not match.\n\n```go\ntype SourceEmployee struct {\n    Identifier int64\n}\n\ntype TargetWorker struct {\n    ID int64 `copier:\"Identifier\"` // Map Identifier from SourceEmployee to ID in TargetWorker\n}\n\nfunc main() {\n    source := SourceEmployee{Identifier: 1001}\n    target := TargetWorker{}\n\n    copier.Copy(&target, &source)\n    fmt.Printf(\"Worker ID: %d\\n\", target.ID)\n    // Output: Worker ID: 1001\n}\n```\n\n## Other examples\n\n### Copy from Method to Field with Same Name\n\nIllustrates copying from a method to a field and vice versa.\n\n```go\n// Assuming User and Employee structs defined earlier with method and field respectively.\n\nfunc main() {\n    user := User{Name: \"Jinzhu\", Age: 18}\n    employee := Employee{}\n\n    copier.Copy(&employee, &user)\n    fmt.Printf(\"DoubleAge: %d\\n\", employee.DoubleAge)\n    // Output: DoubleAge: 36, demonstrating method to field copying.\n}\n```\n\n### Copy Struct to Slice\n\n```go\nfunc main() {\n    user := User{Name: \"Jinzhu\", Age: 18, Role: \"Admin\"}\n    var employees []Employee\n\n    copier.Copy(&employees, &user)\n    fmt.Printf(\"%#v\\n\", employees)\n    // Output: []Employee{{Name: \"Jinzhu\", Age: 18, DoubleAge: 36, SuperRole: \"Super Admin\"}}\n}\n```\n\n### Copy Slice to Slice\n\n```go\nfunc main() {\n    users := []User{{Name: \"Jinzhu\", Age: 18, Role: \"Admin\"}, {Name: \"jinzhu 2\", Age: 30, Role: \"Dev\"}}\n    var employees []Employee\n\n    copier.Copy(&employees, &users)\n    fmt.Printf(\"%#v\\n\", employees)\n    // Output: []Employee{{Name: \"Jinzhu\", Age: 18, DoubleAge: 36, SuperRole: \"Super Admin\"}, {Name: \"jinzhu 2\", Age: 30, DoubleAge: 60, SuperRole: \"Super Dev\"}}\n}\n```\n\n### Copy Map to Map\n\n```go\nfunc main() {\n    map1 := map[int]int{3: 6, 4: 8}\n    map2 := map[int32]int8{}\n\n    copier.Copy(&map2, map1)\n    fmt.Printf(\"%#v\\n\", map2)\n    // Output: map[int32]int8{3:6, 4:8}\n}\n```\n\n## Complex Data Copying: Nested Structures with Slices\n\nThis example demonstrates how Copier can be used to copy data involving complex, nested structures, including slices of structs, to showcase its ability to handle intricate data copying scenarios.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/jinzhu/copier\"\n)\n\ntype Address struct {\n\tCity    string\n\tCountry string\n}\n\ntype Contact struct {\n\tEmail  string\n\tPhones []string\n}\n\ntype Employee struct {\n\tName      string\n\tAge       int32\n\tAddresses []Address\n\tContact   *Contact\n}\n\ntype Manager struct {\n\tName            string `copier:\"must\"`\n\tAge             int32  `copier:\"must,nopanic\"`\n\tManagedCities   []string\n\tContact         *Contact `copier:\"override\"`\n\tSecondaryEmails []string\n}\n\nfunc main() {\n\temployee := Employee{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t\tAddresses: []Address{\n\t\t\t{City: \"New York\", Country: \"USA\"},\n\t\t\t{City: \"San Francisco\", Country: \"USA\"},\n\t\t},\n\t\tContact: nil,\n\t}\n\n\tmanager := Manager{\n\t\tManagedCities: []string{\"Los Angeles\", \"Boston\"},\n\t\tContact: &Contact{\n\t\t\tEmail:  \"john.doe@example.com\",\n\t\t\tPhones: []string{\"123-456-7890\", \"098-765-4321\"},\n\t\t}, // since override is set this should be overridden with nil\n\t\tSecondaryEmails: []string{\"secondary@example.com\"},\n\t}\n\n\tcopier.CopyWithOption(&manager, &employee, copier.Option{IgnoreEmpty: true, DeepCopy: true})\n\n\tfmt.Printf(\"Manager: %#v\\n\", manager)\n\t// Output: Manager struct showcasing copied fields from Employee,\n\t// including overridden and deeply copied nested slices.\n}\n```\n\n## Available tags\n\n| Tag                 | Description                                                                                                       |\n| ------------------- | ----------------------------------------------------------------------------------------------------------------- |\n| `copier:\"-\"`        | Explicitly ignores the field during copying.                                                                      |\n| `copier:\"must\"`     | Forces the field to be copied; Copier will panic or return an error if the field is not copied.                   |\n| `copier:\"nopanic\"`  | Copier will return an error instead of panicking.                                                                 |\n| `copier:\"override\"` | Forces the field to be copied even if `IgnoreEmpty` is set. Useful for overriding existing values with empty ones |\n| `FieldName`         | Specifies a custom field name for copying when field names do not match between structs.                          |\n\n## Contributing\n\nYou can help to make the project better, check out [http://gorm.io/contribute.html](http://gorm.io/contribute.html) for things you can do.\n\n# Author\n\n**jinzhu**\n\n- <http://github.com/jinzhu>\n- <wosmvp@gmail.com>\n- <http://twitter.com/zhangjinzhu>\n\n## License\n\nReleased under the [MIT License](https://github.com/jinzhu/copier/blob/master/License).\n"
        },
        {
          "name": "copier.go",
          "type": "blob",
          "size": 21.66796875,
          "content": "package copier\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"unicode\"\n)\n\n// These flags define options for tag handling\nconst (\n\t// Denotes that a destination field must be copied to. If copying fails then a panic will ensue.\n\ttagMust uint8 = 1 << iota\n\n\t// Denotes that the program should not panic when the must flag is on and\n\t// value is not copied. The program will return an error instead.\n\ttagNoPanic\n\n\t// Ignore a destination field from being copied to.\n\ttagIgnore\n\n\t// Denotes the fact that the field should be overridden, no matter if the IgnoreEmpty is set\n\ttagOverride\n\n\t// Denotes that the value as been copied\n\thasCopied\n\n\t// Some default converter types for a nicer syntax\n\tString  string  = \"\"\n\tBool    bool    = false\n\tInt     int     = 0\n\tFloat32 float32 = 0\n\tFloat64 float64 = 0\n)\n\n// Option sets copy options\ntype Option struct {\n\t// setting this value to true will ignore copying zero values of all the fields, including bools, as well as a\n\t// struct having all it's fields set to their zero values respectively (see IsZero() in reflect/value.go)\n\tIgnoreEmpty   bool\n\tCaseSensitive bool\n\tDeepCopy      bool\n\tConverters    []TypeConverter\n\t// Custom field name mappings to copy values with different names in `fromValue` and `toValue` types.\n\t// Examples can be found in `copier_field_name_mapping_test.go`.\n\tFieldNameMapping []FieldNameMapping\n}\n\nfunc (opt Option) converters() map[converterPair]TypeConverter {\n\tvar converters = map[converterPair]TypeConverter{}\n\n\t// save converters into map for faster lookup\n\tfor i := range opt.Converters {\n\t\tpair := converterPair{\n\t\t\tSrcType: reflect.TypeOf(opt.Converters[i].SrcType),\n\t\t\tDstType: reflect.TypeOf(opt.Converters[i].DstType),\n\t\t}\n\n\t\tconverters[pair] = opt.Converters[i]\n\t}\n\n\treturn converters\n}\n\ntype TypeConverter struct {\n\tSrcType interface{}\n\tDstType interface{}\n\tFn      func(src interface{}) (dst interface{}, err error)\n}\n\ntype converterPair struct {\n\tSrcType reflect.Type\n\tDstType reflect.Type\n}\n\nfunc (opt Option) fieldNameMapping() map[converterPair]FieldNameMapping {\n\tvar mapping = map[converterPair]FieldNameMapping{}\n\n\tfor i := range opt.FieldNameMapping {\n\t\tpair := converterPair{\n\t\t\tSrcType: reflect.TypeOf(opt.FieldNameMapping[i].SrcType),\n\t\t\tDstType: reflect.TypeOf(opt.FieldNameMapping[i].DstType),\n\t\t}\n\n\t\tmapping[pair] = opt.FieldNameMapping[i]\n\t}\n\n\treturn mapping\n}\n\ntype FieldNameMapping struct {\n\tSrcType interface{}\n\tDstType interface{}\n\tMapping map[string]string\n}\n\n// Tag Flags\ntype flags struct {\n\tBitFlags  map[string]uint8\n\tSrcNames  tagNameMapping\n\tDestNames tagNameMapping\n}\n\n// Field Tag name mapping\ntype tagNameMapping struct {\n\tFieldNameToTag map[string]string\n\tTagToFieldName map[string]string\n}\n\n// Copy copy things\nfunc Copy(toValue interface{}, fromValue interface{}) (err error) {\n\treturn copier(toValue, fromValue, Option{})\n}\n\n// CopyWithOption copy with option\nfunc CopyWithOption(toValue interface{}, fromValue interface{}, opt Option) (err error) {\n\treturn copier(toValue, fromValue, opt)\n}\n\nfunc copier(toValue interface{}, fromValue interface{}, opt Option) (err error) {\n\tvar (\n\t\tisSlice    bool\n\t\tamount     = 1\n\t\tfrom       = indirect(reflect.ValueOf(fromValue))\n\t\tto         = indirect(reflect.ValueOf(toValue))\n\t\tconverters = opt.converters()\n\t\tmappings   = opt.fieldNameMapping()\n\t)\n\n\tif !to.CanAddr() {\n\t\treturn ErrInvalidCopyDestination\n\t}\n\n\t// Return is from value is invalid\n\tif !from.IsValid() {\n\t\treturn ErrInvalidCopyFrom\n\t}\n\n\tfromType, isPtrFrom := indirectType(from.Type())\n\ttoType, _ := indirectType(to.Type())\n\n\tif fromType.Kind() == reflect.Interface {\n\t\tfromType = reflect.TypeOf(from.Interface())\n\t}\n\n\tif toType.Kind() == reflect.Interface {\n\t\ttoType, _ = indirectType(reflect.TypeOf(to.Interface()))\n\t\toldTo := to\n\t\tto = reflect.New(reflect.TypeOf(to.Interface())).Elem()\n\t\tdefer func() {\n\t\t\toldTo.Set(to)\n\t\t}()\n\t}\n\n\t// Just set it if possible to assign for normal types\n\tif from.Kind() != reflect.Slice && from.Kind() != reflect.Struct && from.Kind() != reflect.Map && (from.Type().AssignableTo(to.Type()) || from.Type().ConvertibleTo(to.Type())) {\n\t\tif !isPtrFrom || !opt.DeepCopy {\n\t\t\tto.Set(from.Convert(to.Type()))\n\t\t} else {\n\t\t\tfromCopy := reflect.New(from.Type())\n\t\t\tfromCopy.Set(from.Elem())\n\t\t\tto.Set(fromCopy.Convert(to.Type()))\n\t\t}\n\t\treturn\n\t}\n\n\tif from.Kind() != reflect.Slice && fromType.Kind() == reflect.Map && toType.Kind() == reflect.Map {\n\t\tif !fromType.Key().ConvertibleTo(toType.Key()) {\n\t\t\treturn ErrMapKeyNotMatch\n\t\t}\n\n\t\tif to.IsNil() {\n\t\t\tto.Set(reflect.MakeMapWithSize(toType, from.Len()))\n\t\t}\n\n\t\tfor _, k := range from.MapKeys() {\n\t\t\ttoKey := indirect(reflect.New(toType.Key()))\n\t\t\tisSet, err := set(toKey, k, opt.DeepCopy, converters)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !isSet {\n\t\t\t\treturn fmt.Errorf(\"%w map, old key: %v, new key: %v\", ErrNotSupported, k.Type(), toType.Key())\n\t\t\t}\n\n\t\t\telemType := toType.Elem()\n\t\t\tif elemType.Kind() != reflect.Slice {\n\t\t\t\telemType, _ = indirectType(elemType)\n\t\t\t}\n\t\t\ttoValue := indirect(reflect.New(elemType))\n\t\t\tisSet, err = set(toValue, from.MapIndex(k), opt.DeepCopy, converters)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !isSet {\n\t\t\t\tif err = copier(toValue.Addr().Interface(), from.MapIndex(k).Interface(), opt); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\tif elemType == toType.Elem() {\n\t\t\t\t\tto.SetMapIndex(toKey, toValue)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\telemType = reflect.PointerTo(elemType)\n\t\t\t\ttoValue = toValue.Addr()\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\tif from.Kind() == reflect.Slice && to.Kind() == reflect.Slice {\n\t\t// Return directly if both slices are nil\n\t\tif from.IsNil() && to.IsNil() {\n\t\t\treturn\n\t\t}\n\t\tif to.IsNil() {\n\t\t\tslice := reflect.MakeSlice(reflect.SliceOf(to.Type().Elem()), from.Len(), from.Cap())\n\t\t\tto.Set(slice)\n\t\t}\n\t\tif fromType.ConvertibleTo(toType) {\n\t\t\tfor i := 0; i < from.Len(); i++ {\n\t\t\t\tif to.Len() < i+1 {\n\t\t\t\t\tto.Set(reflect.Append(to, reflect.New(to.Type().Elem()).Elem()))\n\t\t\t\t}\n\t\t\t\tisSet, err := set(to.Index(i), from.Index(i), opt.DeepCopy, converters)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif !isSet {\n\t\t\t\t\t// ignore error while copy slice element\n\t\t\t\t\terr = copier(to.Index(i).Addr().Interface(), from.Index(i).Interface(), opt)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif to.Len() > from.Len() {\n\t\t\t\tto.SetLen(from.Len())\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t}\n\n\tif fromType.Kind() != reflect.Struct || toType.Kind() != reflect.Struct {\n\t\t// skip not supported type\n\t\treturn\n\t}\n\n\tif len(converters) > 0 {\n\t\tif ok, e := set(to, from, opt.DeepCopy, converters); e == nil && ok {\n\t\t\t// converter supported\n\t\t\treturn\n\t\t}\n\t}\n\n\tif from.Kind() == reflect.Slice || to.Kind() == reflect.Slice {\n\t\tisSlice = true\n\t\tif from.Kind() == reflect.Slice {\n\t\t\tamount = from.Len()\n\t\t}\n\t}\n\n\tfor i := 0; i < amount; i++ {\n\t\tvar dest, source reflect.Value\n\n\t\tif isSlice {\n\t\t\t// source\n\t\t\tif from.Kind() == reflect.Slice {\n\t\t\t\tsource = indirect(from.Index(i))\n\t\t\t} else {\n\t\t\t\tsource = indirect(from)\n\t\t\t}\n\t\t\t// dest\n\t\t\tdest = indirect(reflect.New(toType).Elem())\n\t\t} else {\n\t\t\tsource = indirect(from)\n\t\t\tdest = indirect(to)\n\t\t}\n\n\t\tif len(converters) > 0 {\n\t\t\tif ok, e := set(dest, source, opt.DeepCopy, converters); e == nil && ok {\n\t\t\t\tif isSlice {\n\t\t\t\t\t// FIXME: maybe should check the other types?\n\t\t\t\t\tif to.Type().Elem().Kind() == reflect.Ptr {\n\t\t\t\t\t\tto.Index(i).Set(dest.Addr())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif to.Len() < i+1 {\n\t\t\t\t\t\t\treflect.Append(to, dest)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tto.Index(i).Set(dest)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tto.Set(dest)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tdestKind := dest.Kind()\n\t\tinitDest := false\n\t\tif destKind == reflect.Interface {\n\t\t\tinitDest = true\n\t\t\tdest = indirect(reflect.New(toType))\n\t\t}\n\n\t\t// Get tag options\n\t\tflgs, err := getFlags(dest, source, toType, fromType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// check source\n\t\tif source.IsValid() {\n\t\t\tcopyUnexportedStructFields(dest, source)\n\n\t\t\t// Copy from source field to dest field or method\n\t\t\tfromTypeFields := deepFields(fromType)\n\t\t\tfor _, field := range fromTypeFields {\n\t\t\t\tname := field.Name\n\n\t\t\t\t// Get bit flags for field\n\t\t\t\tfieldFlags := flgs.BitFlags[name]\n\n\t\t\t\t// Check if we should ignore copying\n\t\t\t\tif (fieldFlags & tagIgnore) != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfieldNamesMapping := getFieldNamesMapping(mappings, fromType, toType)\n\n\t\t\t\tsrcFieldName, destFieldName := getFieldName(name, flgs, fieldNamesMapping)\n\n\t\t\t\tif fromField := fieldByNameOrZeroValue(source, srcFieldName); fromField.IsValid() && !shouldIgnore(fromField, fieldFlags, opt.IgnoreEmpty) {\n\t\t\t\t\t// process for nested anonymous field\n\t\t\t\t\tdestFieldNotSet := false\n\t\t\t\t\tif f, ok := dest.Type().FieldByName(destFieldName); ok {\n\t\t\t\t\t\t// only initialize parent embedded struct pointer in the path\n\t\t\t\t\t\tfor idx := range f.Index[:len(f.Index)-1] {\n\t\t\t\t\t\t\tdestField := dest.FieldByIndex(f.Index[:idx+1])\n\n\t\t\t\t\t\t\tif destField.Kind() != reflect.Ptr {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif !destField.IsNil() {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !destField.CanSet() {\n\t\t\t\t\t\t\t\tdestFieldNotSet = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// destField is a nil pointer that can be set\n\t\t\t\t\t\t\tnewValue := reflect.New(destField.Type().Elem())\n\t\t\t\t\t\t\tdestField.Set(newValue)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif destFieldNotSet {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\ttoField := fieldByName(dest, destFieldName, opt.CaseSensitive)\n\t\t\t\t\tif toField.IsValid() {\n\t\t\t\t\t\tif toField.CanSet() {\n\t\t\t\t\t\t\tisSet, err := set(toField, fromField, opt.DeepCopy, converters)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !isSet {\n\t\t\t\t\t\t\t\tif err := copier(toField.Addr().Interface(), fromField.Interface(), opt); err != nil {\n\t\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif fieldFlags != 0 {\n\t\t\t\t\t\t\t\t// Note that a copy was made\n\t\t\t\t\t\t\t\tflgs.BitFlags[name] = fieldFlags | hasCopied\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// try to set to method\n\t\t\t\t\t\tvar toMethod reflect.Value\n\t\t\t\t\t\tif dest.CanAddr() {\n\t\t\t\t\t\t\ttoMethod = dest.Addr().MethodByName(destFieldName)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoMethod = dest.MethodByName(destFieldName)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif toMethod.IsValid() && toMethod.Type().NumIn() == 1 && fromField.Type().AssignableTo(toMethod.Type().In(0)) {\n\t\t\t\t\t\t\ttoMethod.Call([]reflect.Value{fromField})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy from from method to dest field\n\t\t\tfor _, field := range deepFields(toType) {\n\t\t\t\tname := field.Name\n\t\t\t\tsrcFieldName, destFieldName := getFieldName(name, flgs, getFieldNamesMapping(mappings, fromType, toType))\n\n\t\t\t\tvar fromMethod reflect.Value\n\t\t\t\tif source.CanAddr() {\n\t\t\t\t\tfromMethod = source.Addr().MethodByName(srcFieldName)\n\t\t\t\t} else {\n\t\t\t\t\tfromMethod = source.MethodByName(srcFieldName)\n\t\t\t\t}\n\n\t\t\t\tif fromMethod.IsValid() && fromMethod.Type().NumIn() == 0 && fromMethod.Type().NumOut() == 1 && !shouldIgnore(fromMethod, flgs.BitFlags[name], opt.IgnoreEmpty) {\n\t\t\t\t\tif toField := fieldByName(dest, destFieldName, opt.CaseSensitive); toField.IsValid() && toField.CanSet() {\n\t\t\t\t\t\tvalues := fromMethod.Call([]reflect.Value{})\n\t\t\t\t\t\tif len(values) >= 1 {\n\t\t\t\t\t\t\tset(toField, values[0], opt.DeepCopy, converters)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif isSlice && to.Kind() == reflect.Slice {\n\t\t\tif dest.Addr().Type().AssignableTo(to.Type().Elem()) {\n\t\t\t\tif to.Len() < i+1 {\n\t\t\t\t\tto.Set(reflect.Append(to, dest.Addr()))\n\t\t\t\t} else {\n\t\t\t\t\tisSet, err := set(to.Index(i), dest.Addr(), opt.DeepCopy, converters)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif !isSet {\n\t\t\t\t\t\t// ignore error while copy slice element\n\t\t\t\t\t\terr = copier(to.Index(i).Addr().Interface(), dest.Addr().Interface(), opt)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if dest.Type().AssignableTo(to.Type().Elem()) {\n\t\t\t\tif to.Len() < i+1 {\n\t\t\t\t\tto.Set(reflect.Append(to, dest))\n\t\t\t\t} else {\n\t\t\t\t\tisSet, err := set(to.Index(i), dest, opt.DeepCopy, converters)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif !isSet {\n\t\t\t\t\t\t// ignore error while copy slice element\n\t\t\t\t\t\terr = copier(to.Index(i).Addr().Interface(), dest.Interface(), opt)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if initDest {\n\t\t\tto.Set(dest)\n\t\t}\n\n\t\terr = checkBitFlags(flgs.BitFlags)\n\t}\n\n\treturn\n}\n\nfunc getFieldNamesMapping(mappings map[converterPair]FieldNameMapping, fromType reflect.Type, toType reflect.Type) map[string]string {\n\tvar fieldNamesMapping map[string]string\n\n\tif len(mappings) > 0 {\n\t\tpair := converterPair{\n\t\t\tSrcType: fromType,\n\t\t\tDstType: toType,\n\t\t}\n\t\tif v, ok := mappings[pair]; ok {\n\t\t\tfieldNamesMapping = v.Mapping\n\t\t}\n\t}\n\treturn fieldNamesMapping\n}\n\nfunc fieldByNameOrZeroValue(source reflect.Value, fieldName string) (value reflect.Value) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tvalue = reflect.Value{}\n\t\t}\n\t}()\n\n\treturn source.FieldByName(fieldName)\n}\n\nfunc copyUnexportedStructFields(to, from reflect.Value) {\n\tif from.Kind() != reflect.Struct || to.Kind() != reflect.Struct || !from.Type().AssignableTo(to.Type()) {\n\t\treturn\n\t}\n\n\t// create a shallow copy of 'to' to get all fields\n\ttmp := indirect(reflect.New(to.Type()))\n\ttmp.Set(from)\n\n\t// revert exported fields\n\tfor i := 0; i < to.NumField(); i++ {\n\t\tif tmp.Field(i).CanSet() {\n\t\t\ttmp.Field(i).Set(to.Field(i))\n\t\t}\n\t}\n\tto.Set(tmp)\n}\n\nfunc shouldIgnore(v reflect.Value, bitFlags uint8, ignoreEmpty bool) bool {\n\treturn ignoreEmpty && bitFlags&tagOverride == 0 && v.IsZero()\n}\n\nvar deepFieldsLock sync.RWMutex\nvar deepFieldsMap = make(map[reflect.Type][]reflect.StructField)\n\nfunc deepFields(reflectType reflect.Type) []reflect.StructField {\n\tdeepFieldsLock.RLock()\n\tcache, ok := deepFieldsMap[reflectType]\n\tdeepFieldsLock.RUnlock()\n\tif ok {\n\t\treturn cache\n\t}\n\tvar res []reflect.StructField\n\tif reflectType, _ = indirectType(reflectType); reflectType.Kind() == reflect.Struct {\n\t\tfields := make([]reflect.StructField, 0, reflectType.NumField())\n\n\t\tfor i := 0; i < reflectType.NumField(); i++ {\n\t\t\tv := reflectType.Field(i)\n\t\t\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t\t\t// field name. It is empty for upper case (exported) field names.\n\t\t\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\t\t\tif v.PkgPath == \"\" {\n\t\t\t\tfields = append(fields, v)\n\t\t\t\tif v.Anonymous {\n\t\t\t\t\t// also consider fields of anonymous fields as fields of the root\n\t\t\t\t\tfields = append(fields, deepFields(v.Type)...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = fields\n\t}\n\n\tdeepFieldsLock.Lock()\n\tdeepFieldsMap[reflectType] = res\n\tdeepFieldsLock.Unlock()\n\treturn res\n}\n\nfunc indirect(reflectValue reflect.Value) reflect.Value {\n\tfor reflectValue.Kind() == reflect.Ptr {\n\t\treflectValue = reflectValue.Elem()\n\t}\n\treturn reflectValue\n}\n\nfunc indirectType(reflectType reflect.Type) (_ reflect.Type, isPtr bool) {\n\tfor reflectType.Kind() == reflect.Ptr || reflectType.Kind() == reflect.Slice {\n\t\treflectType = reflectType.Elem()\n\t\tisPtr = true\n\t}\n\treturn reflectType, isPtr\n}\n\nfunc set(to, from reflect.Value, deepCopy bool, converters map[converterPair]TypeConverter) (bool, error) {\n\tif !from.IsValid() {\n\t\treturn true, nil\n\t}\n\tif ok, err := lookupAndCopyWithConverter(to, from, converters); err != nil {\n\t\treturn false, err\n\t} else if ok {\n\t\treturn true, nil\n\t}\n\n\tif to.Kind() == reflect.Ptr {\n\t\t// set `to` to nil if from is nil\n\t\tif from.Kind() == reflect.Ptr && from.IsNil() {\n\t\t\tto.Set(reflect.Zero(to.Type()))\n\t\t\treturn true, nil\n\t\t} else if to.IsNil() {\n\t\t\t// `from`         -> `to`\n\t\t\t// sql.NullString -> *string\n\t\t\tif fromValuer, ok := driverValuer(from); ok {\n\t\t\t\tv, err := fromValuer.Value()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\t\t\t\t// if `from` is not valid do nothing with `to`\n\t\t\t\tif v == nil {\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\t// allocate new `to` variable with default value (eg. *string -> new(string))\n\t\t\tto.Set(reflect.New(to.Type().Elem()))\n\t\t} else if from.Kind() != reflect.Ptr && from.IsZero() {\n\t\t\tto.Set(reflect.Zero(to.Type()))\n\t\t\treturn true, nil\n\t\t}\n\t\t// depointer `to`\n\t\tto = to.Elem()\n\t}\n\n\tif deepCopy {\n\t\ttoKind := to.Kind()\n\t\tif toKind == reflect.Interface && to.IsNil() {\n\t\t\tif reflect.TypeOf(from.Interface()) != nil {\n\t\t\t\tto.Set(reflect.New(reflect.TypeOf(from.Interface())).Elem())\n\t\t\t\ttoKind = reflect.TypeOf(to.Interface()).Kind()\n\t\t\t}\n\t\t}\n\t\tif from.Kind() == reflect.Ptr && from.IsNil() {\n\t\t\tto.Set(reflect.Zero(to.Type()))\n\t\t\treturn true, nil\n\t\t}\n\t\tif _, ok := to.Addr().Interface().(sql.Scanner); !ok && (toKind == reflect.Struct || toKind == reflect.Map || toKind == reflect.Slice) {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\n\t// try convert directly\n\tif from.Type().ConvertibleTo(to.Type()) {\n\t\tto.Set(from.Convert(to.Type()))\n\t\treturn true, nil\n\t}\n\n\t// try Scanner\n\tif toScanner, ok := to.Addr().Interface().(sql.Scanner); ok {\n\t\t// `from`  -> `to`\n\t\t// *string -> sql.NullString\n\t\tif from.Kind() == reflect.Ptr {\n\t\t\t// if `from` is nil do nothing with `to`\n\t\t\tif from.IsNil() {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\t// depointer `from`\n\t\t\tfrom = indirect(from)\n\t\t}\n\t\t// `from` -> `to`\n\t\t// string -> sql.NullString\n\t\t// set `to` by invoking method Scan(`from`)\n\t\terr := toScanner.Scan(from.Interface())\n\t\tif err == nil {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\t// try Valuer\n\tif fromValuer, ok := driverValuer(from); ok {\n\t\t// `from`         -> `to`\n\t\t// sql.NullString -> string\n\t\tv, err := fromValuer.Value()\n\t\tif err != nil {\n\t\t\treturn false, nil\n\t\t}\n\t\t// if `from` is not valid do nothing with `to`\n\t\tif v == nil {\n\t\t\treturn true, nil\n\t\t}\n\t\trv := reflect.ValueOf(v)\n\t\tif rv.Type().AssignableTo(to.Type()) {\n\t\t\tto.Set(rv)\n\t\t\treturn true, nil\n\t\t}\n\t\tif to.CanSet() && rv.Type().ConvertibleTo(to.Type()) {\n\t\t\tto.Set(rv.Convert(to.Type()))\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t}\n\n\t// from is ptr\n\tif from.Kind() == reflect.Ptr {\n\t\treturn set(to, from.Elem(), deepCopy, converters)\n\t}\n\n\treturn false, nil\n}\n\n// lookupAndCopyWithConverter looks up the type pair, on success the TypeConverter Fn func is called to copy src to dst field.\nfunc lookupAndCopyWithConverter(to, from reflect.Value, converters map[converterPair]TypeConverter) (copied bool, err error) {\n\tpair := converterPair{\n\t\tSrcType: from.Type(),\n\t\tDstType: to.Type(),\n\t}\n\n\tif cnv, ok := converters[pair]; ok {\n\t\tresult, err := cnv.Fn(from.Interface())\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif result != nil {\n\t\t\tto.Set(reflect.ValueOf(result))\n\t\t} else {\n\t\t\t// in case we've got a nil value to copy\n\t\t\tto.Set(reflect.Zero(to.Type()))\n\t\t}\n\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// parseTags Parses struct tags and returns uint8 bit flags.\nfunc parseTags(tag string) (flg uint8, name string, err error) {\n\tfor _, t := range strings.Split(tag, \",\") {\n\t\tswitch t {\n\t\tcase \"-\":\n\t\t\tflg = tagIgnore\n\t\t\treturn\n\t\tcase \"must\":\n\t\t\tflg = flg | tagMust\n\t\tcase \"nopanic\":\n\t\t\tflg = flg | tagNoPanic\n\t\tcase \"override\":\n\t\t\tflg = flg | tagOverride\n\t\tdefault:\n\t\t\tif unicode.IsUpper([]rune(t)[0]) {\n\t\t\t\tname = strings.TrimSpace(t)\n\t\t\t} else {\n\t\t\t\terr = ErrFieldNameTagStartNotUpperCase\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// getTagFlags Parses struct tags for bit flags, field name.\nfunc getFlags(dest, src reflect.Value, toType, fromType reflect.Type) (flags, error) {\n\tflgs := flags{\n\t\tBitFlags: map[string]uint8{},\n\t\tSrcNames: tagNameMapping{\n\t\t\tFieldNameToTag: map[string]string{},\n\t\t\tTagToFieldName: map[string]string{},\n\t\t},\n\t\tDestNames: tagNameMapping{\n\t\t\tFieldNameToTag: map[string]string{},\n\t\t\tTagToFieldName: map[string]string{},\n\t\t},\n\t}\n\n\tvar toTypeFields, fromTypeFields []reflect.StructField\n\tif dest.IsValid() {\n\t\ttoTypeFields = deepFields(toType)\n\t}\n\tif src.IsValid() {\n\t\tfromTypeFields = deepFields(fromType)\n\t}\n\n\t// Get a list dest of tags\n\tfor _, field := range toTypeFields {\n\t\ttags := field.Tag.Get(\"copier\")\n\t\tif tags != \"\" {\n\t\t\tvar name string\n\t\t\tvar err error\n\t\t\tif flgs.BitFlags[field.Name], name, err = parseTags(tags); err != nil {\n\t\t\t\treturn flags{}, err\n\t\t\t} else if name != \"\" {\n\t\t\t\tflgs.DestNames.FieldNameToTag[field.Name] = name\n\t\t\t\tflgs.DestNames.TagToFieldName[name] = field.Name\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get a list source of tags\n\tfor _, field := range fromTypeFields {\n\t\ttags := field.Tag.Get(\"copier\")\n\t\tif tags != \"\" {\n\t\t\tvar name string\n\t\t\tvar err error\n\n\t\t\tif _, name, err = parseTags(tags); err != nil {\n\t\t\t\treturn flags{}, err\n\t\t\t} else if name != \"\" {\n\t\t\t\tflgs.SrcNames.FieldNameToTag[field.Name] = name\n\t\t\t\tflgs.SrcNames.TagToFieldName[name] = field.Name\n\t\t\t}\n\t\t}\n\t}\n\n\treturn flgs, nil\n}\n\n// checkBitFlags Checks flags for error or panic conditions.\nfunc checkBitFlags(flagsList map[string]uint8) (err error) {\n\t// Check flag conditions were met\n\tfor name, flgs := range flagsList {\n\t\tif flgs&hasCopied == 0 {\n\t\t\tswitch {\n\t\t\tcase flgs&tagMust != 0 && flgs&tagNoPanic != 0:\n\t\t\t\terr = fmt.Errorf(\"field %s has must tag but was not copied\", name)\n\t\t\t\treturn\n\t\t\tcase flgs&(tagMust) != 0:\n\t\t\t\tpanic(fmt.Sprintf(\"Field %s has must tag but was not copied\", name))\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc getFieldName(fieldName string, flgs flags, fieldNameMapping map[string]string) (srcFieldName string, destFieldName string) {\n\t// get dest field name\n\tif name, ok := fieldNameMapping[fieldName]; ok {\n\t\tsrcFieldName = fieldName\n\t\tdestFieldName = name\n\t\treturn\n\t}\n\n\tif srcTagName, ok := flgs.SrcNames.FieldNameToTag[fieldName]; ok {\n\t\tdestFieldName = srcTagName\n\t\tif destTagName, ok := flgs.DestNames.TagToFieldName[srcTagName]; ok {\n\t\t\tdestFieldName = destTagName\n\t\t}\n\t} else {\n\t\tif destTagName, ok := flgs.DestNames.TagToFieldName[fieldName]; ok {\n\t\t\tdestFieldName = destTagName\n\t\t}\n\t}\n\tif destFieldName == \"\" {\n\t\tdestFieldName = fieldName\n\t}\n\n\t// get source field name\n\tif destTagName, ok := flgs.DestNames.FieldNameToTag[fieldName]; ok {\n\t\tsrcFieldName = destTagName\n\t\tif srcField, ok := flgs.SrcNames.TagToFieldName[destTagName]; ok {\n\t\t\tsrcFieldName = srcField\n\t\t}\n\t} else {\n\t\tif srcField, ok := flgs.SrcNames.TagToFieldName[fieldName]; ok {\n\t\t\tsrcFieldName = srcField\n\t\t}\n\t}\n\n\tif srcFieldName == \"\" {\n\t\tsrcFieldName = fieldName\n\t}\n\treturn\n}\n\nfunc driverValuer(v reflect.Value) (i driver.Valuer, ok bool) {\n\tif !v.CanAddr() {\n\t\ti, ok = v.Interface().(driver.Valuer)\n\t\treturn\n\t}\n\n\ti, ok = v.Addr().Interface().(driver.Valuer)\n\treturn\n}\n\nfunc fieldByName(v reflect.Value, name string, caseSensitive bool) reflect.Value {\n\tif caseSensitive {\n\t\treturn v.FieldByName(name)\n\t}\n\n\treturn v.FieldByNameFunc(func(n string) bool { return strings.EqualFold(n, name) })\n}\n"
        },
        {
          "name": "copier_benchmark_test.go",
          "type": "blob",
          "size": 1.6044921875,
          "content": "package copier_test\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\nfunc BenchmarkCopyStruct(b *testing.B) {\n\tvar fakeAge int32 = 12\n\tuser := User{Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\tfor x := 0; x < b.N; x++ {\n\t\tcopier.Copy(&Employee{}, &user)\n\t}\n}\n\nfunc BenchmarkCopyStructFields(b *testing.B) {\n\tvar fakeAge int32 = 12\n\tuser := User{Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\tfor x := 0; x < b.N; x++ {\n\t\tcopier.Copy(&Employee{}, &user)\n\t}\n}\n\nfunc BenchmarkNamaCopy(b *testing.B) {\n\tvar fakeAge int32 = 12\n\tuser := User{Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\tfor x := 0; x < b.N; x++ {\n\t\temployee := &Employee{\n\t\t\tName:      user.Name,\n\t\t\tNickName:  &user.Nickname,\n\t\t\tAge:       int64(user.Age),\n\t\t\tFakeAge:   int(*user.FakeAge),\n\t\t\tDoubleAge: user.DoubleAge(),\n\t\t}\n\n\t\tfor _, note := range user.Notes {\n\t\t\temployee.Notes = append(employee.Notes, &note)\n\t\t}\n\t\temployee.Role(user.Role)\n\t}\n}\n\nfunc BenchmarkJsonMarshalCopy(b *testing.B) {\n\tvar fakeAge int32 = 12\n\tuser := User{Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\tfor x := 0; x < b.N; x++ {\n\t\tdata, _ := json.Marshal(user)\n\t\tvar employee Employee\n\t\tjson.Unmarshal(data, &employee)\n\n\t\temployee.DoubleAge = user.DoubleAge()\n\t\temployee.Role(user.Role)\n\t}\n}\n"
        },
        {
          "name": "copier_converter_test.go",
          "type": "blob",
          "size": 5.1259765625,
          "content": "package copier_test\n\nimport (\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\nfunc TestCopyWithTypeConverters(t *testing.T) {\n\ttype SrcStruct struct {\n\t\tField1 time.Time\n\t\tField2 *time.Time\n\t\tField3 *time.Time\n\t\tField4 string\n\t}\n\n\ttype DestStruct struct {\n\t\tField1 string\n\t\tField2 string\n\t\tField3 string\n\t\tField4 int\n\t}\n\n\ttestTime := time.Date(2021, 3, 5, 1, 30, 0, 123000000, time.UTC)\n\n\tsrc := SrcStruct{\n\t\tField1: testTime,\n\t\tField2: &testTime,\n\t\tField3: nil,\n\t\tField4: \"9000\",\n\t}\n\n\tvar dst DestStruct\n\n\terr := copier.CopyWithOption(&dst, &src, copier.Option{\n\t\tIgnoreEmpty: true,\n\t\tDeepCopy:    true,\n\t\tConverters: []copier.TypeConverter{\n\t\t\t{\n\t\t\t\tSrcType: time.Time{},\n\t\t\t\tDstType: copier.String,\n\t\t\t\tFn: func(src interface{}) (interface{}, error) {\n\t\t\t\t\ts, ok := src.(time.Time)\n\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, errors.New(\"src type not matching\")\n\t\t\t\t\t}\n\n\t\t\t\t\treturn s.Format(time.RFC3339), nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tSrcType: copier.String,\n\t\t\t\tDstType: copier.Int,\n\t\t\t\tFn: func(src interface{}) (interface{}, error) {\n\t\t\t\t\ts, ok := src.(string)\n\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, errors.New(\"src type not matching\")\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strconv.Atoi(s)\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatalf(`Should be able to copy from src to dst object. %v`, err)\n\t\treturn\n\t}\n\n\tdateStr := \"2021-03-05T01:30:00Z\"\n\n\tif dst.Field1 != dateStr {\n\t\tt.Fatalf(\"got %q, wanted %q\", dst.Field1, dateStr)\n\t}\n\n\tif dst.Field2 != dateStr {\n\t\tt.Fatalf(\"got %q, wanted %q\", dst.Field2, dateStr)\n\t}\n\n\tif dst.Field3 != \"\" {\n\t\tt.Fatalf(\"got %q, wanted %q\", dst.Field3, \"\")\n\t}\n\n\tif dst.Field4 != 9000 {\n\t\tt.Fatalf(\"got %q, wanted %q\", dst.Field4, 9000)\n\t}\n}\n\nfunc TestCopyWithConverterAndAnnotation(t *testing.T) {\n\ttype SrcStruct struct {\n\t\tField1 string\n\t}\n\n\ttype DestStruct struct {\n\t\tField1 string\n\t\tField2 string `copier:\"Field1\"`\n\t}\n\n\tsrc := SrcStruct{\n\t\tField1: \"test\",\n\t}\n\n\tvar dst DestStruct\n\n\terr := copier.CopyWithOption(&dst, &src, copier.Option{\n\t\tIgnoreEmpty: true,\n\t\tDeepCopy:    true,\n\t\tConverters: []copier.TypeConverter{\n\t\t\t{\n\t\t\t\tSrcType: copier.String,\n\t\t\t\tDstType: copier.String,\n\t\t\t\tFn: func(src interface{}) (interface{}, error) {\n\t\t\t\t\ts, ok := src.(string)\n\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, errors.New(\"src type not matching\")\n\t\t\t\t\t}\n\n\t\t\t\t\treturn s + \"2\", nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatalf(`Should be able to copy from src to dst object. %v`, err)\n\t\treturn\n\t}\n\n\tif dst.Field2 != \"test2\" {\n\t\tt.Fatalf(\"got %q, wanted %q\", dst.Field2, \"test2\")\n\t}\n}\n\nfunc TestCopyWithConverterStrToStrPointer(t *testing.T) {\n\ttype SrcStruct struct {\n\t\tField1 string\n\t}\n\n\ttype DestStruct struct {\n\t\tField1 *string\n\t}\n\n\tsrc := SrcStruct{\n\t\tField1: \"\",\n\t}\n\n\tvar dst DestStruct\n\n\tptrStrType := \"\"\n\n\terr := copier.CopyWithOption(&dst, &src, copier.Option{\n\t\tIgnoreEmpty: true,\n\t\tDeepCopy:    true,\n\t\tConverters: []copier.TypeConverter{\n\t\t\t{\n\t\t\t\tSrcType: copier.String,\n\t\t\t\tDstType: &ptrStrType,\n\t\t\t\tFn: func(src interface{}) (interface{}, error) {\n\t\t\t\t\ts, _ := src.(string)\n\n\t\t\t\t\t// return nil on empty string\n\t\t\t\t\tif s == \"\" {\n\t\t\t\t\t\treturn nil, nil\n\t\t\t\t\t}\n\n\t\t\t\t\treturn &s, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatalf(`Should be able to copy from src to dst object. %v`, err)\n\t\treturn\n\t}\n\n\tif dst.Field1 != nil {\n\t\tt.Fatalf(\"got %q, wanted nil\", *dst.Field1)\n\t}\n}\n\nfunc TestCopyWithConverterRaisingError(t *testing.T) {\n\ttype SrcStruct struct {\n\t\tField1 string\n\t}\n\n\ttype DestStruct struct {\n\t\tField1 *string\n\t}\n\n\tsrc := SrcStruct{\n\t\tField1: \"\",\n\t}\n\n\tvar dst DestStruct\n\n\tptrStrType := \"\"\n\n\terr := copier.CopyWithOption(&dst, &src, copier.Option{\n\t\tIgnoreEmpty: false,\n\t\tDeepCopy:    true,\n\t\tConverters: []copier.TypeConverter{\n\t\t\t{\n\t\t\t\tSrcType: copier.String,\n\t\t\t\tDstType: &ptrStrType,\n\t\t\t\tFn: func(src interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"src type not matching\")\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err == nil {\n\t\tt.Fatalf(`Should be raising an error.`)\n\t\treturn\n\t}\n}\n\ntype IntArray []int\n\nfunc (a IntArray) Value() (driver.Value, error) {\n\treturn json.Marshal(a)\n}\n\ntype Int int\n\ntype From struct {\n\tData IntArray\n}\n\ntype To struct {\n\tData []byte\n}\n\ntype FailedTo struct {\n\tData []Int\n}\n\nfunc TestValuerConv(t *testing.T) {\n\t// when the field of struct implement driver.Valuer and cannot convert to dest type directly,\n\t// copier.set() will return a unexpected (true, nil)\n\n\ttyp1 := reflect.TypeOf(IntArray{})\n\ttyp2 := reflect.TypeOf([]Int{})\n\n\tif typ1 == typ2 || typ1.ConvertibleTo(typ2) || typ1.AssignableTo(typ2) {\n\t\t// in 1.22 and older, u can not convert typ1 to typ2\n\t\tt.Errorf(\"can not convert %v to %v direct\", typ1, typ2)\n\t}\n\n\tvar (\n\t\tfrom = From{\n\t\t\tData: IntArray{1, 2, 3},\n\t\t}\n\t\tto       To\n\t\tfailedTo FailedTo\n\t)\n\tif err := copier.Copy(&to, from); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := copier.Copy(&failedTo, from); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Testcase1: valuer conv case\n\tif !bytes.Equal(to.Data, []byte(`[1,2,3]`)) {\n\t\tt.Errorf(\"can not convert %v to %v using valuer\", typ1, typ2)\n\t}\n\n\t// Testcase2: fallback case when valuer conv failed\n\tif len(failedTo.Data) != 3 || failedTo.Data[0] != 1 || failedTo.Data[1] != 2 || failedTo.Data[2] != 3 {\n\t\tt.Errorf(\"copier failed from %#v to %#v\", from, failedTo)\n\t}\n}\n"
        },
        {
          "name": "copier_different_type_test.go",
          "type": "blob",
          "size": 4.302734375,
          "content": "package copier_test\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\ntype TypeStruct1 struct {\n\tField1 string\n\tField2 string\n\tField3 TypeStruct2\n\tField4 *TypeStruct2\n\tField5 []*TypeStruct2\n\tField6 []TypeStruct2\n\tField7 []*TypeStruct2\n\tField8 []TypeStruct2\n\tField9 []string\n}\n\ntype TypeStruct2 struct {\n\tField1 int\n\tField2 string\n\tField3 []TypeStruct2\n\tField4 *TypeStruct2\n\tField5 *TypeStruct2\n\tField9 string\n}\n\ntype TypeStruct3 struct {\n\tField1 interface{}\n\tField2 string\n\tField3 TypeStruct4\n\tField4 *TypeStruct4\n\tField5 []*TypeStruct4\n\tField6 []*TypeStruct4\n\tField7 []TypeStruct4\n\tField8 []TypeStruct4\n}\n\ntype TypeStruct4 struct {\n\tfield1 int\n\tField2 string\n}\n\nfunc (t *TypeStruct4) Field1(i int) {\n\tt.field1 = i\n}\n\ntype TypeBaseStruct5 struct {\n\tA bool\n\tB byte\n\tC float64\n\tD int16\n\tE int32\n\tF int64\n\tG time.Time\n\tH string\n}\n\ntype TypeSqlNullStruct6 struct {\n\tA sql.NullBool    `json:\"a\"`\n\tB sql.NullByte    `json:\"b\"`\n\tC sql.NullFloat64 `json:\"c\"`\n\tD sql.NullInt16   `json:\"d\"`\n\tE sql.NullInt32   `json:\"e\"`\n\tF sql.NullInt64   `json:\"f\"`\n\tG sql.NullTime    `json:\"g\"`\n\tH sql.NullString  `json:\"h\"`\n}\n\nfunc TestCopyDifferentFieldType(t *testing.T) {\n\tts := &TypeStruct1{\n\t\tField1: \"str1\",\n\t\tField2: \"str2\",\n\t}\n\tts2 := &TypeStruct2{}\n\n\tcopier.Copy(ts2, ts)\n\n\tif ts2.Field2 != ts.Field2 || ts2.Field1 != 0 {\n\t\tt.Errorf(\"Should be able to copy from ts to ts2\")\n\t}\n}\n\nfunc TestCopyDifferentTypeMethod(t *testing.T) {\n\tts := &TypeStruct1{\n\t\tField1: \"str1\",\n\t\tField2: \"str2\",\n\t}\n\tts4 := &TypeStruct4{}\n\n\tcopier.Copy(ts4, ts)\n\n\tif ts4.Field2 != ts.Field2 || ts4.field1 != 0 {\n\t\tt.Errorf(\"Should be able to copy from ts to ts4\")\n\t}\n}\n\nfunc TestAssignableType(t *testing.T) {\n\tts := &TypeStruct1{\n\t\tField1: \"str1\",\n\t\tField2: \"str2\",\n\t\tField3: TypeStruct2{\n\t\t\tField1: 666,\n\t\t\tField2: \"str2\",\n\t\t},\n\t\tField4: &TypeStruct2{\n\t\t\tField1: 666,\n\t\t\tField2: \"str2\",\n\t\t},\n\t\tField5: []*TypeStruct2{\n\t\t\t{\n\t\t\t\tField1: 666,\n\t\t\t\tField2: \"str2\",\n\t\t\t},\n\t\t},\n\t\tField6: []TypeStruct2{\n\t\t\t{\n\t\t\t\tField1: 666,\n\t\t\t\tField2: \"str2\",\n\t\t\t},\n\t\t},\n\t\tField7: []*TypeStruct2{\n\t\t\t{\n\t\t\t\tField1: 666,\n\t\t\t\tField2: \"str2\",\n\t\t\t},\n\t\t},\n\t}\n\n\tts3 := &TypeStruct3{}\n\n\tcopier.CopyWithOption(&ts3, &ts, copier.Option{CaseSensitive: true})\n\n\tif v, ok := ts3.Field1.(string); !ok {\n\t\tt.Error(\"Assign to interface{} type did not succeed\")\n\t} else if v != \"str1\" {\n\t\tt.Error(\"String haven't been copied correctly\")\n\t}\n\n\tif ts3.Field2 != ts.Field2 {\n\t\tt.Errorf(\"Field2 should be copied\")\n\t}\n\n\tcheckType2WithType4(ts.Field3, ts3.Field3, t, \"Field3\")\n\tcheckType2WithType4(*ts.Field4, *ts3.Field4, t, \"Field4\")\n\n\tif len(ts3.Field5) != len(ts.Field5) {\n\t\tt.Fatalf(\"fields not equal, got %v, expects: %v\", len(ts3.Field5), len(ts.Field5))\n\t}\n\n\tfor idx, f := range ts.Field5 {\n\t\tcheckType2WithType4(*f, *(ts3.Field5[idx]), t, \"Field5\")\n\t}\n\n\tfor idx, f := range ts.Field6 {\n\t\tcheckType2WithType4(f, *(ts3.Field6[idx]), t, \"Field6\")\n\t}\n\n\tfor idx, f := range ts.Field7 {\n\t\tcheckType2WithType4(*f, ts3.Field7[idx], t, \"Field7\")\n\t}\n\n\tfor idx, f := range ts.Field8 {\n\t\tcheckType2WithType4(f, ts3.Field8[idx], t, \"Field8\")\n\t}\n}\n\nfunc checkType2WithType4(t2 TypeStruct2, t4 TypeStruct4, t *testing.T, testCase string) {\n\tif t2.Field1 != t4.field1 || t2.Field2 != t4.Field2 {\n\t\tt.Errorf(\"%v: type struct 4 and type struct 2 is not equal\", testCase)\n\t}\n}\n\nfunc TestCopyFromBaseToSqlNullWithOptionDeepCopy(t *testing.T) {\n\ta := TypeBaseStruct5{\n\t\tA: true,\n\t\tB: byte(2),\n\t\tC: 5.5,\n\t\tD: 1,\n\t\tE: 2,\n\t\tF: 3,\n\t\tG: time.Now(),\n\t\tH: \"deep\",\n\t}\n\tb := TypeSqlNullStruct6{}\n\n\terr := copier.CopyWithOption(&b, a, copier.Option{DeepCopy: true})\n\t// 检查是否有错误\n\tif err != nil {\n\t\tt.Errorf(\"CopyStructWithOption() error = %v\", err)\n\t\treturn\n\t}\n\t// 检查 b 结构体的字段是否符合预期\n\tif !b.A.Valid || b.A.Bool != true {\n\t\tt.Errorf(\"b.A = %v, want %v\", b.A, true)\n\t}\n\tif !b.B.Valid || b.B.Byte != byte(2) {\n\t\tt.Errorf(\"b.B = %v, want %v\", b.B, byte(2))\n\t}\n\tif !b.C.Valid || b.C.Float64 != 5.5 {\n\t\tt.Errorf(\"b.C = %v, want %v\", b.C, 5.5)\n\t}\n\tif !b.D.Valid || b.D.Int16 != 1 {\n\t\tt.Errorf(\"b.D = %v, want %v\", b.D, 1)\n\t}\n\tif !b.E.Valid || b.E.Int32 != 2 {\n\t\tt.Errorf(\"b.E = %v, want %v\", b.E, 2)\n\t}\n\tif !b.F.Valid || b.F.Int64 != 3 {\n\t\tt.Errorf(\"b.F = %v, want %v\", b.F, 3)\n\t}\n\tif !b.G.Valid || b.G.Time != a.G {\n\t\tt.Errorf(\"b.G = %v, want %v\", b.G, a.G)\n\t}\n\tif !b.H.Valid || b.H.String != \"deep\" {\n\t\tt.Errorf(\"b.H = %v, want %v\", b.H, \"deep\")\n\t}\n}\n"
        },
        {
          "name": "copier_field_name_mapping_test.go",
          "type": "blob",
          "size": 0.810546875,
          "content": "package copier_test\n\nimport (\n\t\"github.com/jinzhu/copier\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCustomFieldName(t *testing.T) {\n\ttype User1 struct {\n\t\tId      int64\n\t\tName    string\n\t\tAddress []string\n\t}\n\n\ttype User2 struct {\n\t\tId2      int64\n\t\tName2    string\n\t\tAddress2 []string\n\t}\n\n\tu1 := User1{Id: 1, Name: \"1\", Address: []string{\"1\"}}\n\tvar u2 User2\n\terr := copier.CopyWithOption(&u2, u1, copier.Option{FieldNameMapping: []copier.FieldNameMapping{\n\t\t{SrcType: u1, DstType: u2,\n\t\t\tMapping: map[string]string{\n\t\t\t\t\"Id\":      \"Id2\",\n\t\t\t\t\"Name\":    \"Name2\",\n\t\t\t\t\"Address\": \"Address2\"}},\n\t}})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif u1.Id != u2.Id2 {\n\t\tt.Error(\"copy id failed.\")\n\t}\n\n\tif u1.Name != u2.Name2 {\n\t\tt.Error(\"copy name failed.\")\n\t}\n\n\tif !reflect.DeepEqual(u1.Address, u2.Address2) {\n\t\tt.Error(\"copy address failed.\")\n\t}\n}\n"
        },
        {
          "name": "copier_issue170_test.go",
          "type": "blob",
          "size": 1.8388671875,
          "content": "package copier_test\n\nimport (\n\t\"github.com/jinzhu/copier\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype A struct {\n\tA int\n}\ntype B struct {\n\tA int\n\tb int\n}\n\nvar copied = B{A: 2387483274, b: 128387134}\n\nfunc newOptWithConverter() copier.Option {\n\treturn copier.Option{\n\t\tConverters: []copier.TypeConverter{\n\t\t\t{\n\t\t\t\tSrcType: A{},\n\t\t\t\tDstType: B{},\n\t\t\t\tFn: func(from interface{}) (interface{}, error) {\n\t\t\t\t\treturn copied, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Test_Struct_With_Converter(t *testing.T) {\n\taa := A{A: 11}\n\tbb := B{A: 10, b: 100}\n\terr := copier.CopyWithOption(&bb, &aa, newOptWithConverter())\n\tif err != nil || !reflect.DeepEqual(copied, bb) {\n\t\tt.Fatalf(\"Got %v, wanted %v\", bb, copied)\n\t}\n}\n\nfunc Test_Map_With_Converter(t *testing.T) {\n\taa := map[string]*A{\n\t\t\"a\": &A{A: 10},\n\t}\n\n\tbb := map[string]*B{\n\t\t\"a\": &B{A: 10, b: 100},\n\t}\n\n\terr := copier.CopyWithOption(&bb, &aa, newOptWithConverter())\n\tif err != nil {\n\t\tt.Fatalf(\"copy with converter failed: %v\", err)\n\t}\n\n\tfor _, v := range bb {\n\t\twanted := &copied\n\t\tif !reflect.DeepEqual(v, wanted) {\n\t\t\tt.Fatalf(\"Got %v, wanted %v\", v, wanted)\n\t\t}\n\t}\n}\n\nfunc Test_Slice_With_Converter(t *testing.T) {\n\taa := []*A{\n\t\t&A{A: 10},\n\t}\n\n\tbb := []*B{\n\t\t&B{A: 10, b: 100},\n\t}\n\n\terr := copier.CopyWithOption(&bb, &aa, newOptWithConverter())\n\n\tif err != nil {\n\t\tt.Fatalf(\"copy slice error: %v\", err)\n\t}\n\n\twanted := copied\n\tfor _, v := range bb {\n\t\ttemp := v\n\t\tif !reflect.DeepEqual(*temp, wanted) {\n\t\t\tt.Fatalf(\"Got %v, wanted %v\", *temp, wanted)\n\t\t}\n\t}\n}\n\nfunc Test_Slice_Embedded_With_Converter(t *testing.T) {\n\taa := struct {\n\t\tA []*A\n\t}{\n\t\tA: []*A{&A{A: 10}},\n\t}\n\n\tbb := struct {\n\t\tA []*B\n\t}{\n\t\tA: []*B{&B{A: 10, b: 100}},\n\t}\n\n\terr := copier.CopyWithOption(&bb, &aa, newOptWithConverter())\n\n\twanted := struct {\n\t\tA []*B\n\t}{\n\t\tA: []*B{&copied},\n\t}\n\n\tif err != nil || !reflect.DeepEqual(bb, wanted) {\n\t\tt.Fatalf(\"Got %v, wanted %v\", bb, wanted)\n\t}\n}\n"
        },
        {
          "name": "copier_issue84_test.go",
          "type": "blob",
          "size": 1.7138671875,
          "content": "package copier_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\ntype Embedded struct {\n\tField1 string\n\tField2 string\n}\n\ntype Embedder struct {\n\tEmbedded\n\tPtrField *string\n}\n\ntype Timestamps struct {\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}\n\ntype NotWork struct {\n\tID      string  `json:\"id\"`\n\tUserID  *string `json:\"user_id\"`\n\tName    string  `json:\"name\"`\n\tWebsite *string `json:\"website\"`\n\tTimestamps\n}\n\ntype Work struct {\n\tID      string  `json:\"id\"`\n\tName    string  `json:\"name\"`\n\tUserID  *string `json:\"user_id\"`\n\tWebsite *string `json:\"website\"`\n\tTimestamps\n}\n\nfunc TestIssue84(t *testing.T) {\n\tt.Run(\"test1\", func(t *testing.T) {\n\t\tvar embedder Embedder\n\t\tembedded := Embedded{\n\t\t\tField1: \"1\",\n\t\t\tField2: \"2\",\n\t\t}\n\t\terr := copier.Copy(&embedder, &embedded)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unable to copy: %s\", err)\n\t\t}\n\t\tif embedder.Field1 != embedded.Field1 {\n\t\t\tt.Errorf(\"field1 value is %s instead of %s\", embedder.Field1, embedded.Field1)\n\t\t}\n\t\tif embedder.Field2 != embedded.Field2 {\n\t\t\tt.Errorf(\"field2 value is %s instead of %s\", embedder.Field2, embedded.Field2)\n\t\t}\n\t})\n\tt.Run(\"from issue\", func(t *testing.T) {\n\t\tnotWorkObj := NotWork{\n\t\t\tID:      \"123\",\n\t\t\tName:    \"name\",\n\t\t\tWebsite: nil,\n\t\t\tUserID:  nil,\n\t\t\tTimestamps: Timestamps{\n\t\t\t\tUpdatedAt: time.Now(),\n\t\t\t},\n\t\t}\n\t\tworkObj := Work{\n\t\t\tID:      \"123\",\n\t\t\tName:    \"name\",\n\t\t\tWebsite: nil,\n\t\t\tUserID:  nil,\n\t\t\tTimestamps: Timestamps{\n\t\t\t\tUpdatedAt: time.Now(),\n\t\t\t},\n\t\t}\n\n\t\tdestObj1 := Work{}\n\t\tdestObj2 := NotWork{}\n\n\t\tcopier.CopyWithOption(&destObj1, &workObj, copier.Option{IgnoreEmpty: true, DeepCopy: false})\n\n\t\tcopier.CopyWithOption(&destObj2, &notWorkObj, copier.Option{IgnoreEmpty: true, DeepCopy: false})\n\t})\n}\n"
        },
        {
          "name": "copier_tags_test.go",
          "type": "blob",
          "size": 3.408203125,
          "content": "package copier_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\ntype EmployeeTags struct {\n\tName    string `copier:\"must\"`\n\tDOB     string\n\tAddress string\n\tID      int `copier:\"-\"`\n}\n\ntype User1 struct {\n\tName    string\n\tDOB     string\n\tAddress string `copier:\"override\"`\n\tID      int\n}\n\ntype User2 struct {\n\tDOB     string\n\tAddress *string `copier:\"override\"`\n\tID      int\n}\n\nfunc TestCopyTagIgnore(t *testing.T) {\n\temployee := EmployeeTags{ID: 100}\n\tuser := User1{Name: \"Dexter Ledesma\", DOB: \"1 November, 1970\", Address: \"21 Jump Street\", ID: 12345}\n\tcopier.Copy(&employee, user)\n\tif employee.ID == user.ID {\n\t\tt.Error(\"Was not expected to copy IDs\")\n\t}\n\tif employee.ID != 100 {\n\t\tt.Error(\"Original ID was overwritten\")\n\t}\n}\n\nfunc TestCopyTagMust(t *testing.T) {\n\temployee := &EmployeeTags{}\n\tuser := &User2{DOB: \"1 January 1970\"}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Expected a panic.\")\n\t\t}\n\t}()\n\tcopier.Copy(employee, user)\n}\n\nfunc TestCopyTagOverrideZeroValue(t *testing.T) {\n\toptions := copier.Option{IgnoreEmpty: true}\n\temployee := EmployeeTags{ID: 100, Address: \"\"}\n\tuser := User1{Name: \"Dexter Ledesma\", DOB: \"1 November, 1970\", Address: \"21 Jump Street\", ID: 12345}\n\n\tcopier.CopyWithOption(&user, employee, options)\n\tif user.Address != \"\" {\n\t\tt.Error(\"Original Address was not overwritten\")\n\t}\n}\n\nfunc TestCopyTagOverridePtrToZeroValue(t *testing.T) {\n\toptions := copier.Option{IgnoreEmpty: true}\n\taddress := \"21 Jump Street\"\n\tuser1 := User1{ID: 100, Address: \"\"}\n\tuser2 := User2{DOB: \"1 November, 1970\", Address: &address, ID: 12345}\n\n\tcopier.CopyWithOption(&user2, user1, options)\n\tif user2.Address != nil {\n\t\tt.Error(\"Original Address was not overwritten\")\n\t}\n}\n\nfunc TestCopyTagOverrideZeroValueToPtr(t *testing.T) {\n\toptions := copier.Option{IgnoreEmpty: true}\n\tuser1 := User2{DOB: \"1 November, 1970\", Address: nil, ID: 12345}\n\tuser2 := User1{ID: 100, Address: \"1 November, 1970\"}\n\n\tcopier.CopyWithOption(&user2, user1, options)\n\tif user1.Address != nil {\n\t\tt.Error(\"Original Address was not overwritten\")\n\t}\n}\n\nfunc TestCopyTagOverridePtr(t *testing.T) {\n\toptions := copier.Option{IgnoreEmpty: true}\n\taddress := \"21 Jump Street\"\n\tuser2 := User2{ID: 100, Address: nil}\n\tuser := User2{DOB: \"1 November, 1970\", Address: &address, ID: 12345}\n\n\tcopier.CopyWithOption(&user, user2, options)\n\tif user.Address != nil {\n\t\tt.Error(\"Original Address was not overwritten\")\n\t}\n}\n\nfunc TestCopyTagFieldName(t *testing.T) {\n\tt.Run(\"another name field copy\", func(t *testing.T) {\n\t\ttype SrcTags struct {\n\t\t\tFieldA string\n\t\t\tFieldB string `copier:\"Field2\"`\n\t\t\tFieldC string `copier:\"FieldTagMatch\"`\n\t\t}\n\n\t\ttype DestTags struct {\n\t\t\tField1 string `copier:\"FieldA\"`\n\t\t\tField2 string\n\t\t\tField3 string `copier:\"FieldTagMatch\"`\n\t\t}\n\n\t\tdst := &DestTags{}\n\t\tsrc := &SrcTags{\n\t\t\tFieldA: \"FieldA->Field1\",\n\t\t\tFieldB: \"FieldB->Field2\",\n\t\t\tFieldC: \"FieldC->Field3\",\n\t\t}\n\t\terr := copier.Copy(dst, src)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif dst.Field1 != src.FieldA {\n\t\t\tt.Error(\"Field1 no copy\")\n\t\t}\n\t\tif dst.Field2 != src.FieldB {\n\t\t\tt.Error(\"Field2 no copy\")\n\t\t}\n\t\tif dst.Field3 != src.FieldC {\n\t\t\tt.Error(\"Field3 no copy\")\n\t\t}\n\t})\n\n\tt.Run(\"validate error flag name\", func(t *testing.T) {\n\t\ttype SrcTags struct {\n\t\t\tfield string\n\t\t}\n\n\t\ttype DestTags struct {\n\t\t\tField1 string `copier:\"field\"`\n\t\t}\n\n\t\tdst := &DestTags{}\n\t\tsrc := &SrcTags{\n\t\t\tfield: \"field->Field1\",\n\t\t}\n\t\terr := copier.Copy(dst, src)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"must validate error\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "copier_test.go",
          "type": "blob",
          "size": 40.916015625,
          "content": "package copier_test\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jinzhu/copier\"\n)\n\ntype User struct {\n\tName     string\n\tBirthday *time.Time\n\tNickname string\n\tRole     string\n\tAge      int32\n\tFakeAge  *int32\n\tNotes    []string\n\tflags    []byte\n}\n\nfunc (user User) DoubleAge() int32 {\n\treturn 2 * user.Age\n}\n\ntype Employee struct {\n\t_User     *User\n\tName      string\n\tBirthday  *time.Time\n\tNickName  *string\n\tAge       int64\n\tFakeAge   int\n\tEmployeID int64\n\tDoubleAge int32\n\tSuperRule string\n\tNotes     []*string\n\tflags     []byte\n}\n\nfunc (employee *Employee) Role(role string) {\n\temployee.SuperRule = \"Super \" + role\n}\n\nfunc checkEmployee(employee Employee, user User, t *testing.T, testCase string) {\n\tif employee.Name != user.Name {\n\t\tt.Errorf(\"%v: Name haven't been copied correctly.\", testCase)\n\t}\n\tif employee.NickName == nil || *employee.NickName != user.Nickname {\n\t\tt.Errorf(\"%v: NickName haven't been copied correctly.\", testCase)\n\t}\n\tif employee.Birthday == nil && user.Birthday != nil {\n\t\tt.Errorf(\"%v: Birthday haven't been copied correctly.\", testCase)\n\t}\n\tif employee.Birthday != nil && user.Birthday == nil {\n\t\tt.Errorf(\"%v: Birthday haven't been copied correctly.\", testCase)\n\t}\n\tif employee.Birthday != nil && user.Birthday != nil &&\n\t\t!employee.Birthday.Equal(*(user.Birthday)) {\n\t\tt.Errorf(\"%v: Birthday haven't been copied correctly.\", testCase)\n\t}\n\tif employee.Age != int64(user.Age) {\n\t\tt.Errorf(\"%v: Age haven't been copied correctly.\", testCase)\n\t}\n\tif user.FakeAge != nil && employee.FakeAge != int(*user.FakeAge) {\n\t\tt.Errorf(\"%v: FakeAge haven't been copied correctly.\", testCase)\n\t}\n\tif employee.DoubleAge != user.DoubleAge() {\n\t\tt.Errorf(\"%v: Copy from method doesn't work\", testCase)\n\t}\n\tif employee.SuperRule != \"Super \"+user.Role {\n\t\tt.Errorf(\"%v: Copy to method doesn't work\", testCase)\n\t}\n\n\tif len(employee.Notes) != len(user.Notes) {\n\t\tt.Fatalf(\"%v: Copy from slice doesn't work, employee notes len: %v, user: %v\", testCase, len(employee.Notes), len(user.Notes))\n\t}\n\n\tfor idx, note := range user.Notes {\n\t\tif note != *employee.Notes[idx] {\n\t\t\tt.Fatalf(\"%v: Copy from slice doesn't work, notes idx: %v employee: %v user: %v\", testCase, idx, *employee.Notes[idx], note)\n\t\t}\n\t}\n}\n\nfunc TestCopySameStructWithPointerField(t *testing.T) {\n\tvar fakeAge int32 = 12\n\tvar currentTime time.Time = time.Now()\n\tuser := &User{Birthday: &currentTime, Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\tnewUser := &User{}\n\tcopier.Copy(newUser, user)\n\tif user.Birthday == newUser.Birthday {\n\t\tt.Errorf(\"TestCopySameStructWithPointerField: copy Birthday failed since they need to have different address\")\n\t}\n\n\tif user.FakeAge == newUser.FakeAge {\n\t\tt.Errorf(\"TestCopySameStructWithPointerField: copy FakeAge failed since they need to have different address\")\n\t}\n}\n\nfunc checkEmployee2(employee Employee, user *User, t *testing.T, testCase string) {\n\tif user == nil {\n\t\tif employee.Name != \"\" || employee.NickName != nil || employee.Birthday != nil || employee.Age != 0 ||\n\t\t\temployee.DoubleAge != 0 || employee.FakeAge != 0 || employee.SuperRule != \"\" || employee.Notes != nil {\n\t\t\tt.Errorf(\"%v : employee should be empty\", testCase)\n\t\t}\n\t\treturn\n\t}\n\n\tcheckEmployee(employee, *user, t, testCase)\n}\n\nfunc TestCopySliceOfDifferentTypes(t *testing.T) {\n\tvar ss []string\n\tvar is []int\n\tif err := copier.Copy(&ss, is); err != nil {\n\t\tt.Error(err)\n\t}\n\tvar anotherSs []string\n\tif !reflect.DeepEqual(ss, anotherSs) {\n\t\tt.Errorf(\"Copy nil slice to nil slice should get nil slice\")\n\t}\n}\n\nfunc TestCopyStruct(t *testing.T) {\n\tvar fakeAge int32 = 12\n\tuser := User{Name: \"Jinzhu\", Nickname: \"jinzhu\", Age: 18, FakeAge: &fakeAge, Role: \"Admin\", Notes: []string{\"hello world\", \"welcome\"}, flags: []byte{'x'}}\n\temployee := Employee{}\n\n\tif err := copier.Copy(employee, &user); err == nil {\n\t\tt.Errorf(\"Copy to unaddressable value should get error\")\n\t}\n\n\tcopier.Copy(&employee, &user)\n\tcheckEmployee(employee, user, t, \"Copy From Ptr To Ptr\")\n\n\temployee2 := Employee{}\n\tcopier.Copy(&employee2, user)\n\tcheckEmployee(employee2, user, t, \"Copy From Struct To Ptr\")\n\n\temployee3 := Employee{}\n\tptrToUser := &user\n\tcopier.Copy(&employee3, &ptrToUser)\n\tcheckEmployee(employee3, user, t, \"Copy From Double Ptr To Ptr\")\n\n\temployee4 := &Employee{}\n\tcopier.Copy(&employee4, user)\n\tcheckEmployee(*employee4, user, t, \"Copy From Ptr To Double Ptr\")\n\n\temployee5 := &Employee{}\n\tcopier.Copy(&employee5, &employee)\n\tcheckEmployee(*employee5, user, t, \"Copy From Employee To Employee\")\n}\n\nfunc TestCopyFromStructToSlice(t *testing.T) {\n\tuser := User{Name: \"Jinzhu\", Age: 18, Role: \"Admin\", Notes: []string{\"hello world\"}}\n\temployees := []Employee{}\n\n\tif err := copier.Copy(employees, &user); err != nil && len(employees) != 0 {\n\t\tt.Errorf(\"Copy to unaddressable value should get error\")\n\t}\n\n\tif copier.Copy(&employees, &user); len(employees) != 1 {\n\t\tt.Errorf(\"Should only have one elem when copy struct to slice\")\n\t} else {\n\t\tcheckEmployee(employees[0], user, t, \"Copy From Struct To Slice Ptr\")\n\t}\n\n\temployees2 := &[]Employee{}\n\tif copier.Copy(&employees2, user); len(*employees2) != 1 {\n\t\tt.Errorf(\"Should only have one elem when copy struct to slice\")\n\t} else {\n\t\tcheckEmployee((*employees2)[0], user, t, \"Copy From Struct To Double Slice Ptr\")\n\t}\n\n\temployees3 := []*Employee{}\n\tif copier.Copy(&employees3, user); len(employees3) != 1 {\n\t\tt.Errorf(\"Should only have one elem when copy struct to slice\")\n\t} else {\n\t\tcheckEmployee(*(employees3[0]), user, t, \"Copy From Struct To Ptr Slice Ptr\")\n\t}\n\n\temployees4 := &[]*Employee{}\n\tif copier.Copy(&employees4, user); len(*employees4) != 1 {\n\t\tt.Errorf(\"Should only have one elem when copy struct to slice\")\n\t} else {\n\t\tcheckEmployee(*((*employees4)[0]), user, t, \"Copy From Struct To Double Ptr Slice Ptr\")\n\t}\n}\n\nfunc TestCopyFromSliceToSlice(t *testing.T) {\n\tusers := []User{\n\t\t{Name: \"Jinzhu\", Age: 18, Role: \"Admin\", Notes: []string{\"hello world\"}},\n\t\t{Name: \"Jinzhu2\", Age: 22, Role: \"Dev\", Notes: []string{\"hello world\", \"hello\"}}}\n\temployees := []Employee{}\n\n\tif copier.Copy(&employees, users); len(employees) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee(employees[0], users[0], t, \"Copy From Slice To Slice Ptr @ 1\")\n\t\tcheckEmployee(employees[1], users[1], t, \"Copy From Slice To Slice Ptr @ 2\")\n\t}\n\n\temployees2 := &[]Employee{}\n\tif copier.Copy(&employees2, &users); len(*employees2) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee((*employees2)[0], users[0], t, \"Copy From Slice Ptr To Double Slice Ptr @ 1\")\n\t\tcheckEmployee((*employees2)[1], users[1], t, \"Copy From Slice Ptr To Double Slice Ptr @ 2\")\n\t}\n\n\temployees3 := []*Employee{}\n\tif copier.Copy(&employees3, users); len(employees3) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee(*(employees3[0]), users[0], t, \"Copy From Slice To Ptr Slice Ptr @ 1\")\n\t\tcheckEmployee(*(employees3[1]), users[1], t, \"Copy From Slice To Ptr Slice Ptr @ 2\")\n\t}\n\n\temployees4 := &[]*Employee{}\n\tif copier.Copy(&employees4, users); len(*employees4) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee(*((*employees4)[0]), users[0], t, \"Copy From Slice Ptr To Double Ptr Slice Ptr @ 1\")\n\t\tcheckEmployee(*((*employees4)[1]), users[1], t, \"Copy From Slice Ptr To Double Ptr Slice Ptr @ 2\")\n\t}\n}\n\nfunc TestCopyFromSliceToSlice2(t *testing.T) {\n\tusers := []*User{{Name: \"Jinzhu\", Age: 18, Role: \"Admin\", Notes: []string{\"hello world\"}}, nil}\n\temployees := []Employee{}\n\n\tif copier.Copy(&employees, users); len(employees) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee2(employees[0], users[0], t, \"Copy From Slice To Slice Ptr @ 1\")\n\t\tcheckEmployee2(employees[1], users[1], t, \"Copy From Slice To Slice Ptr @ 2\")\n\t}\n\n\temployees2 := &[]Employee{}\n\tif copier.Copy(&employees2, &users); len(*employees2) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee2((*employees2)[0], users[0], t, \"Copy From Slice Ptr To Double Slice Ptr @ 1\")\n\t\tcheckEmployee2((*employees2)[1], users[1], t, \"Copy From Slice Ptr To Double Slice Ptr @ 2\")\n\t}\n\n\temployees3 := []*Employee{}\n\tif copier.Copy(&employees3, users); len(employees3) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee2(*(employees3[0]), users[0], t, \"Copy From Slice To Ptr Slice Ptr @ 1\")\n\t\tcheckEmployee2(*(employees3[1]), users[1], t, \"Copy From Slice To Ptr Slice Ptr @ 2\")\n\t}\n\n\temployees4 := &[]*Employee{}\n\tif copier.Copy(&employees4, users); len(*employees4) != 2 {\n\t\tt.Errorf(\"Should have two elems when copy slice to slice\")\n\t} else {\n\t\tcheckEmployee2(*((*employees4)[0]), users[0], t, \"Copy From Slice Ptr To Double Ptr Slice Ptr @ 1\")\n\t\tcheckEmployee2(*((*employees4)[1]), users[1], t, \"Copy From Slice Ptr To Double Ptr Slice Ptr @ 2\")\n\t}\n}\n\nfunc TestCopyFromSliceToSlice3(t *testing.T) {\n\ttype CollectionAlias struct {\n\t\tCollectionName string `json:\"collection_name\"`\n\t\tName           string `json:\"name\"`\n\t}\n\n\texpectedResult := []*CollectionAlias{\n\t\t{\"collection\", \"collection_alias1\"},\n\t\t{\"collection\", \"collection_alias2\"},\n\t\t{\"collection\", \"collection_alias3\"},\n\t}\n\n\tmockedResult := []*CollectionAlias{}\n\tcopier.Copy(&mockedResult, &expectedResult)\n\n\tif len(mockedResult) != len(expectedResult) {\n\t\tt.Fatalf(\"failed to copy results\")\n\t}\n\n\tfor idx := range mockedResult {\n\t\tif mockedResult[idx].Name != mockedResult[idx].Name || mockedResult[idx].CollectionName != mockedResult[idx].CollectionName {\n\t\t\tt.Fatalf(\"failed to copy results\")\n\t\t}\n\t}\n}\n\nfunc TestEmbeddedAndBase(t *testing.T) {\n\ttype Base struct {\n\t\tBaseField1 int\n\t\tBaseField2 int\n\t\tUser       *User\n\t}\n\n\ttype Embed struct {\n\t\tEmbedField1 int\n\t\tEmbedField2 int\n\t\tBase\n\t}\n\n\tbase := Base{}\n\tembedded := Embed{}\n\tembedded.BaseField1 = 1\n\tembedded.BaseField2 = 2\n\tembedded.EmbedField1 = 3\n\tembedded.EmbedField2 = 4\n\n\tuser := User{\n\t\tName: \"testName\",\n\t}\n\tembedded.User = &user\n\n\tcopier.Copy(&base, &embedded)\n\n\tif base.BaseField1 != 1 || base.User.Name != \"testName\" {\n\t\tt.Error(\"Embedded fields not copied\")\n\t}\n\n\tbase.BaseField1 = 11\n\tbase.BaseField2 = 12\n\tuser1 := User{\n\t\tName: \"testName1\",\n\t}\n\tbase.User = &user1\n\n\tcopier.Copy(&embedded, &base)\n\tif embedded.BaseField1 != 11 || embedded.User.Name != \"testName1\" {\n\t\tt.Error(\"base fields not copied\")\n\t}\n}\n\nfunc TestStructField(t *testing.T) {\n\ttype Detail struct {\n\t\tInfo1 string\n\t\tInfo2 *string\n\t}\n\n\ttype SimilarDetail struct {\n\t\tInfo1 string\n\t\tInfo2 *string\n\t}\n\n\ttype UserWithDetailsPtr struct {\n\t\tDetails []*Detail\n\t\tDetail  *Detail\n\t\tNotes   *[]string\n\t\tNotes2  *[]string\n\t}\n\ttype UserWithDetails struct {\n\t\tDetails []Detail\n\t\tDetail  Detail\n\t\tNotes   []string\n\t\tNotes2  []string\n\t}\n\ttype UserWithSimilarDetailsPtr struct {\n\t\tDetail *SimilarDetail\n\t}\n\ttype UserWithSimilarDetails struct {\n\t\tDetail SimilarDetail\n\t}\n\ttype EmployeeWithDetails struct {\n\t\tDetail Detail\n\t}\n\ttype EmployeeWithDetailsPtr struct {\n\t\tDetail *Detail\n\t}\n\ttype EmployeeWithSimilarDetails struct {\n\t\tDetail SimilarDetail\n\t}\n\ttype EmployeeWithSimilarDetailsPtr struct {\n\t\tDetail *SimilarDetail\n\t}\n\n\toptionsDeepCopy := copier.Option{\n\t\tDeepCopy: true,\n\t}\n\n\tcheckDetail := func(t *testing.T, source Detail, target Detail) {\n\t\tif source.Info1 != target.Info1 {\n\t\t\tt.Errorf(\"info1 is diff: source: %v, target: %v\", source.Info1, target.Info1)\n\t\t}\n\n\t\tif (source.Info2 != nil || target.Info2 != nil) && (*source.Info2 != *target.Info2) {\n\t\t\tt.Errorf(\"info2 is diff: source: %v, target: %v\", *source.Info2, *target.Info2)\n\t\t}\n\t}\n\n\tt.Run(\"Should work without deepCopy\", func(t *testing.T) {\n\t\tt.Run(\"Should work with same type and both ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{\n\t\t\t\tDetail:  &Detail{Info1: \"hello\", Info2: &info2},\n\t\t\t\tDetails: []*Detail{{Info1: \"hello\", Info2: &info2}},\n\t\t\t}\n\t\t\tto := UserWithDetailsPtr{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tcheckDetail(t, *from.Detail, *to.Detail)\n\n\t\t\t*to.Detail.Info2 = \"new value\"\n\t\t\tif *from.Detail.Info2 != *to.Detail.Info2 {\n\t\t\t\tt.Fatalf(\"DeepCopy not enabled\")\n\t\t\t}\n\n\t\t\tif len(from.Details) != len(to.Details) {\n\t\t\t\tt.Fatalf(\"slice should be copied\")\n\t\t\t}\n\n\t\t\tfor idx, detail := range from.Details {\n\t\t\t\tcheckDetail(t, *detail, *to.Details[idx])\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with same type and both not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{\n\t\t\t\tDetail:  Detail{Info1: \"hello\", Info2: &info2},\n\t\t\t\tDetails: []Detail{{Info1: \"hello\", Info2: &info2}},\n\t\t\t}\n\t\t\tto := UserWithDetails{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tcheckDetail(t, from.Detail, to.Detail)\n\n\t\t\t*to.Detail.Info2 = \"new value\"\n\t\t\tif *from.Detail.Info2 != *to.Detail.Info2 {\n\t\t\t\tt.Fatalf(\"DeepCopy not enabled\")\n\t\t\t}\n\n\t\t\tif len(from.Details) != len(to.Details) {\n\t\t\t\tt.Fatalf(\"slice should be copied\")\n\t\t\t}\n\n\t\t\tfor idx, detail := range from.Details {\n\t\t\t\tcheckDetail(t, detail, to.Details[idx])\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with different type and both ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{Detail: &Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetailsPtr{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with different type and both not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{Detail: Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetails{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from ptr field and to not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{Detail: &Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetails{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from not ptr field and to ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{Detail: Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetailsPtr{}\n\t\t\tcopier.Copy(&to, from)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from a nil ptr slice field to a slice field\", func(t *testing.T) {\n\t\t\tnotes := []string{\"hello\", \"world\"}\n\t\t\tfrom := UserWithDetailsPtr{Notes: &notes, Notes2: nil}\n\t\t\tto := UserWithDetails{}\n\t\t\terr := copier.Copy(&to, from)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"should not return an error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(to.Notes) != len(*from.Notes) {\n\t\t\t\tt.Errorf(\"should be the same length\")\n\t\t\t}\n\t\t\tif to.Notes[0] != (*from.Notes)[0] {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Notes[1] != (*from.Notes)[1] {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Should work with deepCopy\", func(t *testing.T) {\n\t\tt.Run(\"Should work with same type and both ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{\n\t\t\t\tDetail:  &Detail{Info1: \"hello\", Info2: &info2},\n\t\t\t\tDetails: []*Detail{{Info1: \"hello\", Info2: &info2}},\n\t\t\t}\n\t\t\tto := UserWithDetailsPtr{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tcheckDetail(t, *from.Detail, *to.Detail)\n\n\t\t\t*to.Detail.Info2 = \"new value\"\n\t\t\tif *from.Detail.Info2 == *to.Detail.Info2 {\n\t\t\t\tt.Fatalf(\"DeepCopy enabled\")\n\t\t\t}\n\n\t\t\tif len(from.Details) != len(to.Details) {\n\t\t\t\tt.Fatalf(\"slice should be copied\")\n\t\t\t}\n\n\t\t\tfor idx, detail := range from.Details {\n\t\t\t\tcheckDetail(t, *detail, *to.Details[idx])\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Should work with same type and both not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{\n\t\t\t\tDetail:  Detail{Info1: \"hello\", Info2: &info2},\n\t\t\t\tDetails: []Detail{{Info1: \"hello\", Info2: &info2}},\n\t\t\t}\n\t\t\tto := UserWithDetails{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tcheckDetail(t, from.Detail, to.Detail)\n\n\t\t\t*to.Detail.Info2 = \"new value\"\n\t\t\tif *from.Detail.Info2 == *to.Detail.Info2 {\n\t\t\t\tt.Fatalf(\"DeepCopy enabled\")\n\t\t\t}\n\n\t\t\tif len(from.Details) != len(to.Details) {\n\t\t\t\tt.Fatalf(\"slice should be copied\")\n\t\t\t}\n\n\t\t\tfor idx, detail := range from.Details {\n\t\t\t\tcheckDetail(t, detail, to.Details[idx])\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with different type and both ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{Detail: &Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetailsPtr{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with different type and both not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{Detail: Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetails{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from ptr field and to not ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetailsPtr{Detail: &Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetails{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from not ptr field and to ptr field\", func(t *testing.T) {\n\t\t\tinfo2 := \"world\"\n\t\t\tfrom := UserWithDetails{Detail: Detail{Info1: \"hello\", Info2: &info2}}\n\t\t\tto := EmployeeWithDetailsPtr{}\n\t\t\tcopier.CopyWithOption(&to, from, optionsDeepCopy)\n\n\t\t\tnewValue := \"new value\"\n\t\t\tto.Detail.Info2 = &newValue\n\n\t\t\tif to.Detail.Info1 == \"\" {\n\t\t\t\tt.Errorf(\"should not be empty\")\n\t\t\t}\n\t\t\tif to.Detail.Info1 != from.Detail.Info1 {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Detail.Info2 == from.Detail.Info2 {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Should work with from a nil ptr slice field to a slice field\", func(t *testing.T) {\n\t\t\tnotes := []string{\"hello\", \"world\"}\n\t\t\tfrom := UserWithDetailsPtr{Notes: &notes, Notes2: nil}\n\t\t\tto := UserWithDetails{}\n\t\t\terr := copier.CopyWithOption(&to, from, optionsDeepCopy)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"should not return an error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(to.Notes) != len(*from.Notes) {\n\t\t\t\tt.Errorf(\"should be the same length\")\n\t\t\t}\n\t\t\tif to.Notes[0] != (*from.Notes)[0] {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\t\t\tif to.Notes[1] != (*from.Notes)[1] {\n\t\t\t\tt.Errorf(\"should be the same\")\n\t\t\t}\n\n\t\t\tnewValue := []string{\"new\", \"value\"}\n\t\t\tto.Notes = newValue\n\n\t\t\tif to.Notes[0] == (*from.Notes)[0] {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t\tif to.Notes[1] == (*from.Notes)[1] {\n\t\t\t\tt.Errorf(\"should be different\")\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestMapInterface(t *testing.T) {\n\ttype Inner struct {\n\t\tIntPtr          *int\n\t\tunexportedField string\n\t}\n\n\ttype Outer struct {\n\t\tInner Inner\n\t}\n\n\ttype DriverOptions struct {\n\t\tGenOptions map[string]interface{}\n\t}\n\n\tt.Run(\"Should work without deepCopy\", func(t *testing.T) {\n\t\tintVal := 5\n\t\touter := Outer{\n\t\t\tInner: Inner{\n\t\t\t\tIntPtr:          &intVal,\n\t\t\t\tunexportedField: \"hello\",\n\t\t\t},\n\t\t}\n\t\tfrom := DriverOptions{\n\t\t\tGenOptions: map[string]interface{}{\n\t\t\t\t\"key\": outer,\n\t\t\t},\n\t\t}\n\t\tto := DriverOptions{}\n\t\tif err := copier.Copy(&to, &from); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t*to.GenOptions[\"key\"].(Outer).Inner.IntPtr = 6\n\n\t\tif to.GenOptions[\"key\"].(Outer).Inner.IntPtr != from.GenOptions[\"key\"].(Outer).Inner.IntPtr {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with deepCopy\", func(t *testing.T) {\n\t\tintVal := 5\n\t\touter := Outer{\n\t\t\tInner: Inner{\n\t\t\t\tIntPtr:          &intVal,\n\t\t\t\tunexportedField: \"Hello\",\n\t\t\t},\n\t\t}\n\t\tfrom := DriverOptions{\n\t\t\tGenOptions: map[string]interface{}{\n\t\t\t\t\"key\": outer,\n\t\t\t},\n\t\t}\n\t\tto := DriverOptions{}\n\t\tif err := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t}); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t*to.GenOptions[\"key\"].(Outer).Inner.IntPtr = 6\n\n\t\tif to.GenOptions[\"key\"].(Outer).Inner.IntPtr == from.GenOptions[\"key\"].(Outer).Inner.IntPtr {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\t})\n\n\tt.Run(\"Test copy map with nil interface\", func(t *testing.T) {\n\t\tfrom := map[string]interface{}{\"eventId\": nil}\n\t\tto := map[string]interface{}{\"eventId\": nil}\n\t\tcopier.CopyWithOption(&to, &from, copier.Option{IgnoreEmpty: true, DeepCopy: true})\n\t\tif v, ok := to[\"eventId\"]; !ok || v != nil {\n\t\t\tt.Errorf(\"failed to deep copy map with nil, got %v\", v)\n\t\t}\n\n\t\tfrom[\"eventId\"] = 1\n\t\tif v, ok := to[\"eventId\"]; !ok || v != nil {\n\t\t\tt.Errorf(\"failed to deep copy map with nil, got %v\", v)\n\t\t}\n\n\t\tcopier.CopyWithOption(&to, &from, copier.Option{IgnoreEmpty: true, DeepCopy: true})\n\t\tif v, ok := to[\"eventId\"]; !ok || v != 1 {\n\t\t\tt.Errorf(\"failed to deep copy map with nil\")\n\t\t}\n\n\t\tfrom[\"eventId\"] = 2\n\t\tif v, ok := to[\"eventId\"]; !ok || v != 1 {\n\t\t\tt.Errorf(\"failed to deep copy map with nil\")\n\t\t}\n\t})\n\n\tt.Run(\"Test copy map with nested slice map\", func(t *testing.T) {\n\t\tvar out map[string]interface{}\n\t\tvalue := map[string]interface{}{\n\t\t\t\"list\": []map[string]interface{}{\n\t\t\t\t{\n\t\t\t\t\t\"shop_id\": 123,\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"list2\": []interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"shop_id\": 123,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr := copier.CopyWithOption(&out, &value, copier.Option{IgnoreEmpty: false, DeepCopy: true})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to deep copy nested map\")\n\t\t}\n\t\tif fmt.Sprintf(\"%v\", out) != fmt.Sprintf(\"%v\", value) {\n\t\t\tt.Fatalf(\"failed to deep copy nested map\")\n\t\t}\n\t})\n}\n\nfunc TestInterface(t *testing.T) {\n\ttype Inner struct {\n\t\tIntPtr *int\n\t}\n\n\ttype Outer struct {\n\t\tInner Inner\n\t}\n\n\ttype DriverOptions struct {\n\t\tGenOptions interface{}\n\t}\n\n\tt.Run(\"Should work without deepCopy\", func(t *testing.T) {\n\t\tintVal := 5\n\t\touter := Outer{\n\t\t\tInner: Inner{\n\t\t\t\tIntPtr: &intVal,\n\t\t\t},\n\t\t}\n\t\tfrom := DriverOptions{\n\t\t\tGenOptions: outer,\n\t\t}\n\t\tto := DriverOptions{}\n\t\tif err := copier.Copy(&to, from); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t*to.GenOptions.(Outer).Inner.IntPtr = 6\n\n\t\tif to.GenOptions.(Outer).Inner.IntPtr != from.GenOptions.(Outer).Inner.IntPtr {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with deepCopy\", func(t *testing.T) {\n\t\tintVal := 5\n\t\touter := Outer{\n\t\t\tInner: Inner{\n\t\t\t\tIntPtr: &intVal,\n\t\t\t},\n\t\t}\n\t\tfrom := DriverOptions{\n\t\t\tGenOptions: outer,\n\t\t}\n\t\tto := DriverOptions{}\n\t\tif err := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t}); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t*to.GenOptions.(Outer).Inner.IntPtr = 6\n\n\t\tif to.GenOptions.(Outer).Inner.IntPtr == from.GenOptions.(Outer).Inner.IntPtr {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\t})\n}\n\nfunc TestSlice(t *testing.T) {\n\ttype ElemOption struct {\n\t\tValue int\n\t}\n\n\ttype A struct {\n\t\tX       []int\n\t\tOptions []ElemOption\n\t}\n\n\ttype B struct {\n\t\tX       []int\n\t\tOptions []ElemOption\n\t}\n\n\tt.Run(\"Should work with simple slice\", func(t *testing.T) {\n\t\tfrom := []int{1, 2}\n\t\tvar to []int\n\n\t\tif err := copier.Copy(&to, from); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom[0] = 3\n\t\tfrom[1] = 4\n\n\t\tif to[0] == from[0] {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\n\t\tif len(to) != len(from) {\n\t\t\tt.Errorf(\"should be the same length, got len(from): %v, len(to): %v\", len(from), len(to))\n\t\t}\n\t})\n\n\tt.Run(\"Should work with empty slice\", func(t *testing.T) {\n\t\tfrom := []int{}\n\t\tto := []int{}\n\n\t\tif err := copier.Copy(&to, from); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif to == nil {\n\t\t\tt.Errorf(\"should be not nil\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work without deepCopy\", func(t *testing.T) {\n\t\tx := []int{1, 2}\n\t\toptions := []ElemOption{\n\t\t\t{Value: 10},\n\t\t\t{Value: 20},\n\t\t}\n\t\tfrom := A{X: x, Options: options}\n\t\tto := B{}\n\n\t\tif err := copier.Copy(&to, from); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.X[0] = 3\n\t\tfrom.X[1] = 4\n\t\tfrom.Options[0].Value = 30\n\t\tfrom.Options[1].Value = 40\n\n\t\tif to.X[0] != from.X[0] {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\n\t\tif len(to.X) != len(from.X) {\n\t\t\tt.Errorf(\"should be the same length, got len(from.X): %v, len(to.X): %v\", len(from.X), len(to.X))\n\t\t}\n\n\t\tif to.Options[0].Value != from.Options[0].Value {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\n\t\tif to.Options[0].Value != from.Options[0].Value {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\n\t\tif len(to.Options) != len(from.Options) {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with deepCopy\", func(t *testing.T) {\n\t\tx := []int{1, 2}\n\t\toptions := []ElemOption{\n\t\t\t{Value: 10},\n\t\t\t{Value: 20},\n\t\t}\n\t\tfrom := A{X: x, Options: options}\n\t\tto := B{}\n\n\t\tif err := copier.CopyWithOption(&to, from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t}); nil != err {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.X[0] = 3\n\t\tfrom.X[1] = 4\n\t\tfrom.Options[0].Value = 30\n\t\tfrom.Options[1].Value = 40\n\n\t\tif to.X[0] == from.X[0] {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\n\t\tif len(to.X) != len(from.X) {\n\t\t\tt.Errorf(\"should be the same length, got len(from.X): %v, len(to.X): %v\", len(from.X), len(to.X))\n\t\t}\n\n\t\tif to.Options[0].Value == from.Options[0].Value {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\n\t\tif len(to.Options) != len(from.Options) {\n\t\t\tt.Errorf(\"should be the same\")\n\t\t}\n\t})\n}\n\nfunc TestAnonymousFields(t *testing.T) {\n\tt.Run(\"Should work with unexported ptr fields\", func(t *testing.T) {\n\t\ttype nested struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentA struct {\n\t\t\t*nested\n\t\t}\n\t\ttype parentB struct {\n\t\t\t*nested\n\t\t}\n\n\t\tfrom := parentA{nested: &nested{A: \"a\"}}\n\t\tto := parentB{}\n\n\t\terr := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.nested.A = \"b\"\n\n\t\tif to.nested != nil {\n\t\t\tt.Errorf(\"should be nil\")\n\t\t}\n\t})\n\tt.Run(\"Should work with unexported fields\", func(t *testing.T) {\n\t\ttype nested struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentA struct {\n\t\t\tnested\n\t\t}\n\t\ttype parentB struct {\n\t\t\tnested\n\t\t}\n\n\t\tfrom := parentA{nested: nested{A: \"a\"}}\n\t\tto := parentB{}\n\n\t\terr := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.nested.A = \"b\"\n\n\t\tif to.nested.A == from.nested.A {\n\t\t\tt.Errorf(\"should be different\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with exported ptr fields\", func(t *testing.T) {\n\t\ttype Nested struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentA struct {\n\t\t\t*Nested\n\t\t}\n\t\ttype parentB struct {\n\t\t\t*Nested\n\t\t}\n\n\t\tfieldValue := \"a\"\n\t\tfrom := parentA{Nested: &Nested{A: fieldValue}}\n\t\tto := parentB{}\n\n\t\terr := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.Nested.A = \"b\"\n\n\t\tif to.Nested.A != fieldValue {\n\t\t\tt.Errorf(\"should not change\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with exported ptr fields with same name src field\", func(t *testing.T) {\n\t\ttype Nested struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentA struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentB struct {\n\t\t\t*Nested\n\t\t}\n\n\t\tfieldValue := \"a\"\n\t\tfrom := parentA{A: fieldValue}\n\t\tto := parentB{}\n\n\t\terr := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.A = \"b\"\n\n\t\tif to.Nested.A != fieldValue {\n\t\t\tt.Errorf(\"should not change\")\n\t\t}\n\t})\n\n\tt.Run(\"Should work with exported fields\", func(t *testing.T) {\n\t\ttype Nested struct {\n\t\t\tA string\n\t\t}\n\t\ttype parentA struct {\n\t\t\tNested\n\t\t}\n\t\ttype parentB struct {\n\t\t\tNested\n\t\t}\n\n\t\tfieldValue := \"a\"\n\t\tfrom := parentA{Nested: Nested{A: fieldValue}}\n\t\tto := parentB{}\n\n\t\terr := copier.CopyWithOption(&to, &from, copier.Option{\n\t\t\tDeepCopy: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfrom.Nested.A = \"b\"\n\n\t\tif to.Nested.A != fieldValue {\n\t\t\tt.Errorf(\"should not change\")\n\t\t}\n\t})\n}\n\ntype someStruct struct {\n\tIntField  int\n\tUIntField uint64\n}\n\ntype structSameName1 struct {\n\tA string\n\tB int64\n\tC time.Time\n\tD string\n\tE *someStruct\n}\n\ntype structSameName2 struct {\n\tA string\n\tB time.Time\n\tC int64\n\tD string\n\tE *someStruct\n}\n\nfunc TestCopyFieldsWithSameNameButDifferentTypes(t *testing.T) {\n\tobj1 := structSameName1{A: \"123\", B: 2, C: time.Now()}\n\tobj2 := &structSameName2{}\n\terr := copier.Copy(obj2, &obj1)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif obj2.A != obj1.A {\n\t\tt.Errorf(\"Field A should be copied\")\n\t}\n}\n\ntype Foo1 struct {\n\tName string\n\tAge  int32\n}\n\ntype Foo2 struct {\n\tName string\n}\n\ntype StructWithMap1 struct {\n\tMap map[int]Foo1\n}\n\ntype StructWithMap2 struct {\n\tMap map[int32]Foo2\n}\n\nfunc TestCopyMapOfStruct(t *testing.T) {\n\tobj1 := StructWithMap1{Map: map[int]Foo1{2: {Name: \"A pure foo\"}}}\n\tobj2 := &StructWithMap2{}\n\terr := copier.Copy(obj2, obj1)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\tfor k, v1 := range obj1.Map {\n\t\tv2, ok := obj2.Map[int32(k)]\n\t\tif !ok || v1.Name != v2.Name {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\t}\n}\n\nfunc TestCopyMapOfInt(t *testing.T) {\n\tmap1 := map[int]int{3: 6, 4: 8}\n\tmap2 := map[int32]int8{}\n\terr := copier.Copy(&map2, map1)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tfor k, v1 := range map1 {\n\t\tv2, ok := map2[int32(k)]\n\t\tif !ok || v1 != int(v2) {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\t}\n}\n\nfunc TestCopyMapOfSliceValue(t *testing.T) {\n\t// case1: map's value is a simple slice\n\tkey, value := 2, 3\n\tsrc := map[int][]int{key: {value}}\n\n\tdst1 := map[int][]int{}\n\tvar dst2 map[int][]int\n\terr := copier.Copy(&dst1, src)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\terr = copier.Copy(&dst2, src)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tfor k, v1 := range src {\n\t\tv2, ok := dst1[k]\n\t\tif !ok || len(v1) != len(v2) || k != key {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\t\tfor i := range v1 {\n\t\t\tif v2[i] != value {\n\t\t\t\tt.Errorf(\"Map's slice value shoud be copied\")\n\t\t\t}\n\t\t}\n\n\t\tv3, ok := dst2[k]\n\t\tif !ok || len(v1) != len(v3) {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\t\tfor i := range v1 {\n\t\t\tif v3[i] != value {\n\t\t\t\tt.Errorf(\"Map's slice value shoud be copied\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// case2: map's value is a slice whose element is map\n\tkey1, key2 := 2, 3\n\tvalue = 4\n\ts := map[int][]map[int]int{key1: {{key2: value}}}\n\td1 := map[int][]map[int]int{key1: {{key1: key2}}}\n\td2 := map[int][]map[int]int{key1: {}}\n\td3 := map[int][]map[int]int{key1: nil}\n\td4 := map[int][]map[int]int{}\n\td5 := map[int][]map[int]int(nil)\n\tms := []map[int][]map[int]int{d1, d2, d3, d4, d5}\n\tfor i := range ms {\n\t\tcopier.CopyWithOption(&ms[i], s, copier.Option{IgnoreEmpty: false, DeepCopy: true})\n\n\t\tif len(ms[i]) != len(s) {\n\t\t\tt.Errorf(\"Number of map's keys should be equal\")\n\t\t}\n\t\tfor k, sliceMap := range ms[i] {\n\t\t\tif k != key1 {\n\t\t\t\tt.Errorf(\"Map's key should be copied\")\n\t\t\t}\n\t\t\tif len(sliceMap) != len(s[key1]) || len(sliceMap) != 1 {\n\t\t\t\tt.Errorf(\"Map's slice value should be copied\")\n\t\t\t}\n\t\t\tm := sliceMap[0]\n\t\t\tif len(m) != len(s[key1][0]) || len(m) != 1 {\n\t\t\t\tt.Errorf(\"Map's slice value should be copied recursively\")\n\t\t\t}\n\t\t\tfor k, v := range m {\n\t\t\t\tif k != key2 || v != value {\n\t\t\t\t\tt.Errorf(\"Map's slice value should be copied recursively\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCopyMapOfPtrValue(t *testing.T) {\n\tintV := 3\n\tintv := intV\n\tsrc := map[int]*int{2: &intv}\n\tdst1 := map[int]*int{}\n\tvar dst2 map[int]*int\n\terr := copier.Copy(&dst1, src)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\terr = copier.Copy(&dst2, src)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tfor k, v1 := range src {\n\t\tv2, ok := dst1[k]\n\t\tif !ok || v2 == nil || v1 == nil || *v2 != *v1 || *v2 != intV {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\n\t\tv3, ok := dst2[k]\n\t\tif !ok || v3 == nil || *v3 != *v1 || *v3 != intV {\n\t\t\tt.Errorf(\"Map should be copied\")\n\t\t}\n\t}\n}\n\nfunc TestCopyWithOption(t *testing.T) {\n\tfrom := structSameName2{D: \"456\", E: &someStruct{IntField: 100, UIntField: 1000}}\n\tto := &structSameName1{A: \"123\", B: 2, C: time.Now(), D: \"123\", E: &someStruct{UIntField: 5000}}\n\tif err := copier.CopyWithOption(to, &from, copier.Option{IgnoreEmpty: true}); err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif to.A == from.A {\n\t\tt.Errorf(\"Field A should not be copied\")\n\t} else if to.D != from.D {\n\t\tt.Errorf(\"Field D should be copied\")\n\t}\n}\n\ntype ScannerValue struct {\n\tV int\n}\n\nfunc (s *ScannerValue) Scan(src interface{}) error {\n\treturn errors.New(\"I failed\")\n}\n\ntype ScannerStruct struct {\n\tV *ScannerValue\n}\n\ntype ScannerStructTo struct {\n\tV *ScannerValue\n}\n\nfunc TestScanner(t *testing.T) {\n\ts := &ScannerStruct{\n\t\tV: &ScannerValue{\n\t\t\tV: 12,\n\t\t},\n\t}\n\n\ts2 := &ScannerStructTo{}\n\n\terr := copier.Copy(s2, s)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif s.V.V != s2.V.V {\n\t\tt.Errorf(\"Field V should be copied\")\n\t}\n}\n\nfunc TestScanFromPtrToSqlNullable(t *testing.T) {\n\tvar (\n\t\tfrom struct {\n\t\t\tS     string\n\t\t\tSptr  *string\n\t\t\tSnull sql.NullString\n\t\t\tT1    sql.NullTime\n\t\t\tT2    sql.NullTime\n\t\t\tT3    *time.Time\n\t\t}\n\n\t\tto struct {\n\t\t\tS     sql.NullString\n\t\t\tSptr  sql.NullString\n\t\t\tSnull *string\n\t\t\tT1    time.Time\n\t\t\tT2    *time.Time\n\t\t\tT3    sql.NullTime\n\t\t}\n\n\t\ts string\n\n\t\terr error\n\t)\n\n\ts = \"test\"\n\tfrom.S = s\n\tfrom.Sptr = &s\n\n\tif from.T1.Valid || from.T2.Valid {\n\t\tt.Errorf(\"Must be not valid\")\n\t}\n\n\terr = copier.Copy(&to, from)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif !to.T1.IsZero() {\n\t\tt.Errorf(\"to.T1 should be Zero but %v\", to.T1)\n\t}\n\n\tif to.T2 != nil {\n\t\tt.Errorf(\"to.T2 should be nil but %v\", to.T2)\n\t}\n\n\tif to.Snull != nil {\n\t\tt.Errorf(\"to.Snull should be nil but %v\", to.Snull)\n\t}\n\n\tnow := time.Now()\n\n\tfrom.T1.Scan(now)\n\tfrom.T2.Scan(now)\n\n\terr = copier.Copy(&to, from)\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif to.S.String != from.S {\n\t\tt.Errorf(\"Field S should be copied\")\n\t}\n\n\tif to.Sptr.String != *from.Sptr {\n\t\tt.Errorf(\"Field Sptr should be copied\")\n\t}\n\n\tif from.T1.Time != to.T1 {\n\t\tt.Errorf(\"Fields T1 fields should be equal\")\n\t}\n\n\tif from.T2.Time != *to.T2 {\n\t\tt.Errorf(\"Fields T2 fields should be equal\")\n\t}\n}\n\nfunc TestDeepCopyInterface(t *testing.T) {\n\tm := make(map[string]string)\n\tm[\"a\"] = \"ccc\"\n\n\tfrom := []interface{}{[]int{7, 8, 9}, 2, 3, m, errors.New(\"aaaa\")}\n\tvar to []interface{}\n\n\tcopier.CopyWithOption(&to, &from, copier.Option{\n\t\tIgnoreEmpty: false,\n\t\tDeepCopy:    true,\n\t})\n\n\tfrom[0].([]int)[0] = 10\n\tfrom[1] = \"3\"\n\tfrom[3].(map[string]string)[\"a\"] = \"bbb\"\n\n\tif fmt.Sprint(to[0]) != fmt.Sprint([]int{7, 8, 9}) {\n\t\tt.Errorf(\"to value failed to be deep copied\")\n\t}\n\n\tif fmt.Sprint(to[1]) != \"2\" {\n\t\tt.Errorf(\"to value failed to be deep copied\")\n\t}\n\n\tif to[3].(map[string]string)[\"a\"] != \"ccc\" {\n\t\tt.Errorf(\"to value failed to be deep copied\")\n\t}\n}\n\nfunc TestDeepCopyTime(t *testing.T) {\n\ttype embedT1 struct {\n\t\tT5 time.Time\n\t}\n\n\ttype embedT2 struct {\n\t\tT6 *time.Time\n\t}\n\n\tvar (\n\t\tfrom struct {\n\t\t\tT1 time.Time\n\t\t\tT2 *time.Time\n\n\t\t\tT3 *time.Time\n\t\t\tT4 time.Time\n\t\t\tT5 time.Time\n\t\t\tT6 time.Time\n\t\t}\n\n\t\tto struct {\n\t\t\tT1 time.Time\n\t\t\tT2 *time.Time\n\n\t\t\tT3 time.Time\n\t\t\tT4 *time.Time\n\t\t\tembedT1\n\t\t\tembedT2\n\t\t}\n\t)\n\n\tt1 := time.Now()\n\tfrom.T1 = t1\n\tt2 := t1.Add(time.Second)\n\tfrom.T2 = &t2\n\tt3 := t2.Add(time.Second)\n\tfrom.T3 = &t3\n\tt4 := t3.Add(time.Second)\n\tfrom.T4 = t4\n\tt5 := t4.Add(time.Second)\n\tfrom.T5 = t5\n\tt6 := t5.Add(time.Second)\n\tfrom.T6 = t6\n\n\terr := copier.CopyWithOption(&to, from, copier.Option{DeepCopy: true})\n\tif err != nil {\n\t\tt.Error(\"Should not raise error\")\n\t}\n\n\tif !to.T1.Equal(from.T1) {\n\t\tt.Errorf(\"Field T1 should be copied\")\n\t}\n\tif !to.T2.Equal(*from.T2) {\n\t\tt.Errorf(\"Field T2 should be copied\")\n\t}\n\tif !to.T3.Equal(*from.T3) {\n\t\tt.Errorf(\"Field T3 should be copied\")\n\t}\n\tif !to.T4.Equal(from.T4) {\n\t\tt.Errorf(\"Field T4 should be copied\")\n\t}\n\tif !to.T5.Equal(from.T5) {\n\t\tt.Errorf(\"Field T5 should be copied\")\n\t}\n\tif !to.T6.Equal(from.T6) {\n\t\tt.Errorf(\"Field T6 should be copied\")\n\t}\n}\n\nfunc TestNestedPrivateData(t *testing.T) {\n\ttype hasPrivate struct {\n\t\tdata int\n\t}\n\n\ttype hasMembers struct {\n\t\tMember hasPrivate\n\t}\n\n\tsrc := hasMembers{\n\t\tMember: hasPrivate{\n\t\t\tdata: 42,\n\t\t},\n\t}\n\tvar shallow hasMembers\n\terr := copier.Copy(&shallow, &src)\n\tif err != nil {\n\t\tt.Errorf(\"could not complete shallow copy\")\n\t}\n\tif !reflect.DeepEqual(&src, &shallow) {\n\t\tt.Errorf(\"shallow copy faild\")\n\t}\n\n\tvar deep hasMembers\n\terr = copier.CopyWithOption(&deep, &src, copier.Option{DeepCopy: true})\n\tif err != nil {\n\t\tt.Errorf(\"could not complete deep copy\")\n\t}\n\tif !reflect.DeepEqual(&src, &deep) {\n\t\tt.Errorf(\"deep copy faild\")\n\t}\n\n\tif !reflect.DeepEqual(&shallow, &deep) {\n\t\tt.Errorf(\"unexpected difference between shallow and deep copy\")\n\t}\n}\n\nfunc TestDeepMapCopyTime(t *testing.T) {\n\tt1 := time.Now()\n\tt2 := t1.Add(time.Second)\n\tfrom := []map[string]interface{}{\n\t\t{\n\t\t\t\"t1\": t1,\n\t\t\t\"t2\": &t2,\n\t\t},\n\t}\n\tto := make([]map[string]interface{}, len(from))\n\n\terr := copier.CopyWithOption(&to, from, copier.Option{DeepCopy: true})\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif len(to) != len(from) {\n\t\tt.Errorf(\"slice should be copied\")\n\t}\n\tif !to[0][\"t1\"].(time.Time).Equal(from[0][\"t1\"].(time.Time)) {\n\t\tt.Errorf(\"nested time ptr should be copied\")\n\t}\n\tif !to[0][\"t2\"].(*time.Time).Equal(*from[0][\"t2\"].(*time.Time)) {\n\t\tt.Errorf(\"nested time ptr should be copied\")\n\t}\n}\n\nfunc TestCopySimpleTime(t *testing.T) {\n\tfrom := time.Now()\n\tto := time.Time{}\n\n\terr := copier.Copy(&to, from)\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif !from.Equal(to) {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to, from)\n\t}\n}\n\nfunc TestDeepCopySimpleTime(t *testing.T) {\n\tfrom := time.Now()\n\tto := time.Time{}\n\n\terr := copier.CopyWithOption(&to, from, copier.Option{DeepCopy: true})\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif !from.Equal(to) {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to, from)\n\t}\n}\n\ntype TimeWrapper struct {\n\ttime.Time\n}\n\nfunc TestDeepCopyAnonymousFieldTime(t *testing.T) {\n\tfrom := TimeWrapper{time.Now()}\n\tto := TimeWrapper{}\n\n\terr := copier.CopyWithOption(&to, from, copier.Option{DeepCopy: true})\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif !from.Time.Equal(to.Time) {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to.Time, from.Time)\n\t}\n}\n\nfunc TestSqlNullFiled(t *testing.T) {\n\n\ttype sqlStruct struct {\n\t\tMkId              sql.NullInt64\n\t\tMkExpiryDateType  sql.NullInt32\n\t\tMkExpiryDateStart sql.NullString\n\t}\n\n\ttype dataStruct struct {\n\t\tMkId              int64\n\t\tMkExpiryDateType  int32\n\t\tMkExpiryDateStart string\n\t}\n\n\tfrom := sqlStruct{\n\t\tMkId:              sql.NullInt64{Int64: 3, Valid: true},\n\t\tMkExpiryDateType:  sql.NullInt32{Int32: 4, Valid: true},\n\t\tMkExpiryDateStart: sql.NullString{String: \"5\", Valid: true},\n\t}\n\n\tto := dataStruct{}\n\n\terr := copier.Copy(&to, from)\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif from.MkId.Int64 != to.MkId {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to.MkId, from.MkId.Int64)\n\t}\n\n\tif from.MkExpiryDateStart.String != to.MkExpiryDateStart {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to.MkExpiryDateStart, from.MkExpiryDateStart.String)\n\t}\n\n\tif from.MkExpiryDateType.Int32 != to.MkExpiryDateType {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to.MkExpiryDateType, from.MkExpiryDateType.Int32)\n\t}\n}\n\nfunc TestEmptySlice(t *testing.T) {\n\ttype Str1 string\n\ttype Str2 string\n\ttype Input1 struct {\n\t\tVal Str1\n\t}\n\ttype Input2 struct {\n\t\tVal Str2\n\t}\n\tto := []*Input1(nil)\n\tfrom := []*Input2{}\n\terr := copier.Copy(&to, &from)\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif from == nil {\n\t\tt.Error(\"from should be empty slice not nil\")\n\t}\n\n\tto = []*Input1(nil)\n\tfrom = []*Input2(nil)\n\terr = copier.Copy(&to, &from)\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\tif from != nil {\n\t\tt.Error(\"from should be empty slice nil\")\n\t}\n}\n\nfunc TestNestedNilPointerStruct(t *testing.T) {\n\ttype destination struct {\n\t\tTitle string\n\t}\n\n\ttype NestedSource struct {\n\t\tID int\n\t}\n\n\ttype source struct {\n\t\tTitle string\n\t\t*NestedSource\n\t}\n\n\tfrom := &source{\n\t\tTitle: \"A title to be copied\",\n\t}\n\n\tto := destination{}\n\n\terr := copier.Copy(&to, from)\n\tif err != nil {\n\t\tt.Error(\"should not error\")\n\t}\n\n\tif from.Title != to.Title {\n\t\tt.Errorf(\"to (%v) value should equal from (%v) value\", to.Title, from.Title)\n\t}\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.4609375,
          "content": "package copier\n\nimport \"errors\"\n\nvar (\n\tErrInvalidCopyDestination        = errors.New(\"copy destination must be non-nil and addressable\")\n\tErrInvalidCopyFrom               = errors.New(\"copy from must be non-nil and addressable\")\n\tErrMapKeyNotMatch                = errors.New(\"map's key type doesn't match\")\n\tErrNotSupported                  = errors.New(\"not supported\")\n\tErrFieldNameTagStartNotUpperCase = errors.New(\"copier field name tag must be start upper case\")\n)\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0400390625,
          "content": "module github.com/jinzhu/copier\n\ngo 1.13\n"
        }
      ]
    }
  ]
}